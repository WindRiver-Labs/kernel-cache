From 36ed2d08350b919a51dd72b9595717cf8ae20bce Mon Sep 17 00:00:00 2001
From: Zhenhua Luo <zhenhua.luo@freescale.com>
Date: Fri, 12 Apr 2013 13:55:22 +0800
Subject: [PATCH 076/987] move fmd headers from include/linux to
 include/uapi/linux

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Currently fmd headers are in include/linux/ folder and "make headers_install"
doesn't install those headers, the headers in include/uapi/ will be installed.
so move fmd headers to include/uapi/linux.

Changes:
1. move fmd to include/uapi/linux
2. update include/uapi/linux/Kbuild to add fmd entry
3. update include path in ncsw_config.mk accordingly

Signed-off-by: Zhenhua Luo <zhenhua.luo@freescale.com>
Change-Id: Id7c3ea81583792c3dc9d1e08e34ac759390cb977
Reviewed-on: http://git.am.freescale.net:8181/1268
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Fix context to apply to WRL.]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/freescale/fman/ncsw_config.mk |    6 +-
 include/linux/fmd/Kbuild                           |    5 -
 include/linux/fmd/Peripherals/Kbuild               |    4 -
 include/linux/fmd/Peripherals/fm_ioctls.h          |  628 -----
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      | 2708 --------------------
 include/linux/fmd/Peripherals/fm_port_ioctls.h     |  921 -------
 include/linux/fmd/Peripherals/fm_test_ioctls.h     |  208 --
 include/linux/fmd/integrations/Kbuild              |    1 -
 .../linux/fmd/integrations/integration_ioctls.h    |   56 -
 include/linux/fmd/ioctls.h                         |   96 -
 include/linux/fmd/net_ioctls.h                     |  430 ----
 include/uapi/linux/Kbuild                          |    1 +
 include/uapi/linux/fmd/Kbuild                      |    5 +
 include/uapi/linux/fmd/Peripherals/Kbuild          |    4 +
 include/uapi/linux/fmd/Peripherals/fm_ioctls.h     |  628 +++++
 include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h | 2708 ++++++++++++++++++++
 .../uapi/linux/fmd/Peripherals/fm_port_ioctls.h    |  921 +++++++
 .../uapi/linux/fmd/Peripherals/fm_test_ioctls.h    |  208 ++
 include/uapi/linux/fmd/integrations/Kbuild         |    1 +
 .../linux/fmd/integrations/integration_ioctls.h    |   56 +
 include/uapi/linux/fmd/ioctls.h                    |   96 +
 include/uapi/linux/fmd/net_ioctls.h                |  430 ++++
 22 files changed, 5061 insertions(+), 5060 deletions(-)
 delete mode 100644 include/linux/fmd/Kbuild
 delete mode 100644 include/linux/fmd/Peripherals/Kbuild
 delete mode 100644 include/linux/fmd/Peripherals/fm_ioctls.h
 delete mode 100644 include/linux/fmd/Peripherals/fm_pcd_ioctls.h
 delete mode 100644 include/linux/fmd/Peripherals/fm_port_ioctls.h
 delete mode 100644 include/linux/fmd/Peripherals/fm_test_ioctls.h
 delete mode 100644 include/linux/fmd/integrations/Kbuild
 delete mode 100644 include/linux/fmd/integrations/integration_ioctls.h
 delete mode 100644 include/linux/fmd/ioctls.h
 delete mode 100644 include/linux/fmd/net_ioctls.h
 create mode 100644 include/uapi/linux/fmd/Kbuild
 create mode 100644 include/uapi/linux/fmd/Peripherals/Kbuild
 create mode 100644 include/uapi/linux/fmd/Peripherals/fm_ioctls.h
 create mode 100644 include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
 create mode 100644 include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
 create mode 100644 include/uapi/linux/fmd/Peripherals/fm_test_ioctls.h
 create mode 100644 include/uapi/linux/fmd/integrations/Kbuild
 create mode 100644 include/uapi/linux/fmd/integrations/integration_ioctls.h
 create mode 100644 include/uapi/linux/fmd/ioctls.h
 create mode 100644 include/uapi/linux/fmd/net_ioctls.h

diff --git a/drivers/net/ethernet/freescale/fman/ncsw_config.mk b/drivers/net/ethernet/freescale/fman/ncsw_config.mk
index 953b43e..14cb9d0 100644
--- a/drivers/net/ethernet/freescale/fman/ncsw_config.mk
+++ b/drivers/net/ethernet/freescale/fman/ncsw_config.mk
@@ -36,6 +36,6 @@ EXTRA_CFLAGS += -I$(FMAN)/src/inc
 EXTRA_CFLAGS += -I$(FMAN)/src/inc/system
 EXTRA_CFLAGS += -I$(FMAN)/src/inc/wrapper
 EXTRA_CFLAGS += -I$(FMAN)/src/inc/xx
-EXTRA_CFLAGS += -I$(srctree)/include/linux/fmd
-EXTRA_CFLAGS += -I$(srctree)/include/linux/fmd/Peripherals
-EXTRA_CFLAGS += -I$(srctree)/include/linux/fmd/integrations
+EXTRA_CFLAGS += -I$(srctree)/include/uapi/linux/fmd
+EXTRA_CFLAGS += -I$(srctree)/include/uapi/linux/fmd/Peripherals
+EXTRA_CFLAGS += -I$(srctree)/include/uapi/linux/fmd/integrations
diff --git a/include/linux/fmd/Kbuild b/include/linux/fmd/Kbuild
deleted file mode 100644
index 56a2040..0000000
--- a/include/linux/fmd/Kbuild
+++ /dev/null
@@ -1,5 +0,0 @@
-header-y += integrations/
-header-y += Peripherals/
-
-header-y += ioctls.h
-header-y += net_ioctls.h
diff --git a/include/linux/fmd/Peripherals/Kbuild b/include/linux/fmd/Peripherals/Kbuild
deleted file mode 100644
index 43883ef..0000000
--- a/include/linux/fmd/Peripherals/Kbuild
+++ /dev/null
@@ -1,4 +0,0 @@
-header-y += fm_ioctls.h
-header-y += fm_port_ioctls.h
-header-y += fm_pcd_ioctls.h
-header-y += fm_test_ioctls.h
diff --git a/include/linux/fmd/Peripherals/fm_ioctls.h b/include/linux/fmd/Peripherals/fm_ioctls.h
deleted file mode 100644
index d1b779b..0000000
--- a/include/linux/fmd/Peripherals/fm_ioctls.h
+++ /dev/null
@@ -1,628 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          fm_ioctls.h
-
- @Description   FM Char device ioctls
-*//***************************************************************************/
-#ifndef __FM_IOCTLS_H
-#define __FM_IOCTLS_H
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
-
- @Description   FM Linux ioctls definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection    FM IOCTL device ('/dev') definitions
-*//***************************************************************************/
-#define DEV_FM_NAME                 "fm" /**< Name of the FM chardev */
-
-#define DEV_FM_MINOR_BASE           0
-#define DEV_FM_PCD_MINOR_BASE       (DEV_FM_MINOR_BASE + 1)                                 /*/dev/fmx-pcd */
-#define DEV_FM_OH_PORTS_MINOR_BASE  (DEV_FM_PCD_MINOR_BASE + 1)                             /*/dev/fmx-port-ohy */
-#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OH_PORTS_MINOR_BASE + FM_MAX_NUM_OF_OH_PORTS)   /*/dev/fmx-port-rxy */
-#define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_RX_PORTS)   /*/dev/fmx-port-txy */
-#define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_TX_PORTS)
-
-#define FM_IOC_NUM(n)       (n)
-#define FM_PCD_IOC_NUM(n)   (n+20)
-#define FM_PORT_IOC_NUM(n)  (n+70)
-/* @} */
-
-#define IOC_FM_MAX_NUM_OF_PORTS         64
-
-
-/**************************************************************************//**
- @Description   Enum for defining port types
-                (must match enum e_FmPortType defined in fm_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_port_type {
-    e_IOC_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port */
-    e_IOC_FM_PORT_TYPE_RX,                      /**< 1G Rx port */
-    e_IOC_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port */
-    e_IOC_FM_PORT_TYPE_TX,                      /**< 1G Tx port */
-    e_IOC_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port */
-    e_IOC_FM_PORT_TYPE_DUMMY
-} ioc_fm_port_type;
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_lib_grp FM library
-
- @Description   FM API functions, definitions and enums
-                The FM module is the main driver module and is a mandatory module
-                for FM driver users. Before any further module initialization,
-                this module must be initialized.
-                The FM is a "single-tone" module. It is responsible of the common
-                HW modules: FPM, DMA, common QMI, common BMI initializations and
-                run-time control routines. This module must be initialized always
-                when working with any of the FM modules.
-                NOTE - We assumes that the FML will be initialize only by core No. 0!
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   FM Exceptions
-*//***************************************************************************/
-typedef enum ioc_fm_exceptions {
-    e_IOC_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
-    e_IOC_EX_DMA_READ_ECC,               /**< Read Buffer ECC error (Valid for FM rev < 6)*/
-    e_IOC_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
-    e_IOC_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
-    e_IOC_EX_DMA_SINGLE_PORT_ECC,        /**< Single Port ECC error on FM side (Valid for FM rev > 6)*/
-    e_IOC_EX_FPM_STALL_ON_TASKS,         /**< Stall of tasks on FPM */
-    e_IOC_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
-    e_IOC_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
-    e_IOC_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
-    e_IOC_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occurred on QMI */
-    e_IOC_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeue from unknown port id */
-    e_IOC_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
-    e_IOC_EX_BMI_STORAGE_PROFILE_ECC,    /**< Storage Profile ECC Error */
-    e_IOC_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
-    e_IOC_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
-    e_IOC_EX_IRAM_ECC,                   /**< Double bit ECC occurred on IRAM*/
-    e_IOC_EX_MURAM_ECC                   /**< Double bit ECC occurred on MURAM*/
-} ioc_fm_exceptions;
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
-
- @Description   FM Runtime control unit API functions, definitions and enums.
-                The FM driver provides a set of control routines for each module.
-                These routines may only be called after the module was fully
-                initialized (both configuration and initialization routines were
-                called). They are typically used to get information from hardware
-                (status, counters/statistics, revision etc.), to modify a current
-                state or to force/enable a required action. Run-time control may
-                be called whenever necessary and as many times as needed.
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection   General FM defines.
- *//***************************************************************************/
-#define IOC_FM_MAX_NUM_OF_VALID_PORTS  (FM_MAX_NUM_OF_OH_PORTS + \
-                                        FM_MAX_NUM_OF_1G_RX_PORTS +  \
-                                        FM_MAX_NUM_OF_10G_RX_PORTS + \
-                                        FM_MAX_NUM_OF_1G_TX_PORTS +  \
-                                        FM_MAX_NUM_OF_10G_TX_PORTS)
-/* @} */
-
-/**************************************************************************//**
- @Description   Structure for Port bandwidth requirement. Port is identified
-                by type and relative id.
-                (must be identical to t_FmPortBandwidth defined in fm_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_port_bandwidth_t {
-    ioc_fm_port_type    type;           /**< FM port type */
-    uint8_t             relative_port_id; /**< Type relative port id */
-    uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
-} ioc_fm_port_bandwidth_t;
-
-/**************************************************************************//**
- @Description   A Structure containing an array of Port bandwidth requirements.
-                The user should state the ports requiring bandwidth in terms of
-                percentage - i.e. all port's bandwidths in the array must add
-                up to 100.
-                (must be identical to t_FmPortsBandwidthParams defined in fm_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_port_bandwidth_params {
-    uint8_t                     num_of_ports;
-                                /**< num of ports listed in the array below */
-    ioc_fm_port_bandwidth_t     ports_bandwidths[IOC_FM_MAX_NUM_OF_VALID_PORTS];
-                                /**< for each port, it's bandwidth (all port's
-                                  bandwidths must add up to 100.*/
-} ioc_fm_port_bandwidth_params;
-
-/**************************************************************************//**
- @Description   enum for defining FM counters
-*//***************************************************************************/
-typedef enum ioc_fm_counters {
-    e_IOC_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
-    e_IOC_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
-    e_IOC_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
-    e_IOC_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
-    e_IOC_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
-    e_IOC_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
-    e_IOC_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
-    e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
-    e_IOC_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
-    e_IOC_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
-} ioc_fm_counters;
-
-typedef struct ioc_fm_obj_t {
-    void            *obj;
-} ioc_fm_obj_t;
-
-/**************************************************************************//**
- @Description   A structure for returning revision information
-                (must match struct t_FmRevisionInfo declared in fm_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_revision_info_t {
-    uint8_t         major;               /**< Major revision */
-    uint8_t         minor;               /**< Minor revision */
-} ioc_fm_revision_info_t;
-
-/**************************************************************************//**
- @Description   A structure for FM counters
-*//***************************************************************************/
-typedef struct ioc_fm_counters_params_t {
-    ioc_fm_counters cnt;                /**< The requested counter */
-    uint32_t        val;                /**< The requested value to get/set from/into the counter */
-} ioc_fm_counters_params_t;
-
-typedef union ioc_fm_api_version_t {
-    struct {
-        uint8_t major;
-        uint8_t minor;
-        uint8_t respin;
-        uint8_t reserved;
-    } version;
-    uint32_t ver;
-} ioc_fm_api_version_t;
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Description   A structure of information about each of the external
-                buffer pools used by a port or storage-profile.
-                (must be identical to t_FmExtPoolParams defined in fm_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_ext_pool_params {
-    uint8_t                 id;     /**< External buffer pool id */
-    uint16_t                size;   /**< External buffer pool buffer size */
-} ioc_fm_ext_pool_params;
-
-/**************************************************************************//**
- @Description   A structure for informing the driver about the external
-                buffer pools allocated in the BM and used by a port or a
-                storage-profile.
-                (must be identical to t_FmExtPools defined in fm_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_ext_pools {
-    uint8_t                 num_of_pools_used;     /**< Number of pools use by this port */
-    ioc_fm_ext_pool_params  ext_buf_pool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-                                                /**< Parameters for each port */
-} ioc_fm_ext_pools;
-
-typedef struct ioc_fm_vsp_params_t {
-    void                *p_fm;              /**< A handle to the FM object this VSP related to */
-    ioc_fm_ext_pools    ext_buf_pools;        /**< Which external buffer pools are used
-                                                 (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes.
-                                                 parameter associated with Rx / OP port */
-    uint16_t            liodn_offset;        /**< VSP's LIODN offset */
-    struct {
-        ioc_fm_port_type port_type;          /**< Port type */
-        uint8_t         port_id;             /**< Port Id - relative to type */
-    } portParams;
-    uint8_t             relative_profile_id;  /**< VSP Id - relative to VSP's range
-                                                 defined in relevant FM object */
-    void                *id;                /**< return value */
-} ioc_fm_vsp_params_t;
-#endif /* (DPAA_VERSION >= 11) */
-
-/**************************************************************************//**
- @Description   A structure for defining BM pool depletion criteria
-*//***************************************************************************/
-typedef struct ioc_fm_buf_pool_depletion_t {
-    bool        pools_grp_mode_enable;              /**< select mode in which pause frames will be sent after
-                                                         a number of pools (all together!) are depleted */
-    uint8_t     num_of_pools;                       /**< the number of depleted pools that will invoke
-                                                         pause frames transmission. */
-    bool        pools_to_consider[BM_MAX_NUM_OF_POOLS];
-                                                    /**< For each pool, TRUE if it should be considered for
-                                                         depletion (Note - this pool must be used by this port!). */
-    bool        single_pool_mode_enable;            /**< select mode in which pause frames will be sent after
-                                                         a single-pool is depleted; */
-    bool        pools_to_consider_for_single_mode[BM_MAX_NUM_OF_POOLS];
-                                                    /**< For each pool, TRUE if it should be considered for
-                                                         depletion (Note - this pool must be used by this port!) */
-#if (DPAA_VERSION >= 11)
-    bool        pfc_priorities_en[FM_MAX_NUM_OF_PFC_PRIORITIES];
-                                                    /**< This field is used by the MAC as the Priority Enable Vector in the PFC frame
-                                                         which is transmitted */
-#endif /* (DPAA_VERSION >= 11) */
-} ioc_fm_buf_pool_depletion_t;
-
-#if (DPAA_VERSION >= 11)
-typedef struct ioc_fm_buf_pool_depletion_params_t {
-    void        *p_fm_vsp;
-    ioc_fm_buf_pool_depletion_t fm_buf_pool_depletion;
-} ioc_fm_buf_pool_depletion_params_t;
-#endif /* (DPAA_VERSION >= 11) */
-
-typedef struct ioc_fm_buffer_prefix_content_t {
-    uint16_t    priv_data_size;       /**< Number of bytes to be left at the beginning
-                                         of the external buffer; Note that the private-area will
-                                         start from the base of the buffer address. */
-    bool        pass_prs_result;      /**< TRUE to pass the parse result to/from the FM;
-                                         User may use FM_PORT_GetBufferPrsResult() in order to
-                                         get the parser-result from a buffer. */
-    bool        pass_time_stamp;      /**< TRUE to pass the timeStamp to/from the FM
-                                         User may use FM_PORT_GetBufferTimeStamp() in order to
-                                         get the parser-result from a buffer. */
-    bool        pass_hash_result;     /**< TRUE to pass the KG hash result to/from the FM
-                                         User may use FM_PORT_GetBufferHashResult() in order to
-                                         get the parser-result from a buffer. */
-    bool        pass_all_other_pcd_info; /**< Add all other Internal-Context information:
-                                         AD, hash-result, key, etc. */
-    uint16_t    data_align;          /**< 0 to use driver's default alignment [64],
-                                         other value for selecting a data alignment (must be a power of 2);
-                                         if write optimization is used, must be >= 16. */
-    uint8_t     manip_extra_space;    /**< Maximum extra size needed (insertion-size minus removal-size);
-                                         Note that this field impacts the size of the buffer-prefix
-                                         (i.e. it pushes the data offset);
-                                         This field is irrelevant if DPAA_VERSION==10 */
-} ioc_fm_buffer_prefix_content_t;
-
-typedef struct ioc_fm_buffer_prefix_content_params_t {
-    void        *p_fm_vsp;
-    ioc_fm_buffer_prefix_content_t fm_buffer_prefix_content;
-} ioc_fm_buffer_prefix_content_params_t;
-
-#if (DPAA_VERSION >= 11)
-typedef struct ioc_fm_vsp_config_no_sg_params_t {
-    void        *p_fm_vsp;
-    bool        no_sg;
-} ioc_fm_vsp_config_no_sg_params_t;
-
-typedef struct ioc_fm_vsp_prs_result_params_t {
-    void        *p_fm_vsp;
-    void        *p_data;
-} ioc_fm_vsp_prs_result_params_t;
-#endif
-
-typedef struct fm_ctrl_mon_t {
-    uint8_t     percent_cnt[1];
-} fm_ctrl_mon_t;
-
-typedef struct ioc_fm_ctrl_mon_counters_params_t {
-    uint8_t     fm_ctrl_index;
-    fm_ctrl_mon_t *p_mon;
-} ioc_fm_ctrl_mon_counters_params_t;
-
-/**************************************************************************//**
- @Function      FM_IOC_SET_PORTS_BANDWIDTH
-
- @Description   Sets relative weights between ports when accessing common resources.
-
- @Param[in]     ioc_fm_port_bandwidth_params    Port bandwidth percentages,
- their sum must equal 100.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_SET_PORTS_BANDWIDTH                             _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(2), ioc_fm_port_bandwidth_params)
-
-/**************************************************************************//**
- @Function      FM_IOC_GET_REVISION
-
- @Description   Returns the FM revision
-
- @Param[out]    ioc_fm_revision_info_t  A structure of revision information parameters.
-
- @Return        None.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_GET_REVISION                                    _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(3), ioc_fm_revision_info_t)
-
-/**************************************************************************//**
- @Function      FM_IOC_GET_COUNTER
-
- @Description   Reads one of the FM counters.
-
- @Param[in,out] ioc_fm_counters_params_t The requested counter parameters.
-
- @Return        Counter's current value.
-
- @Cautions      Allowed only following FM_Init().
-                Note that it is user's responsibilty to call this routine only
-                for enabled counters, and there will be no indication if a
-                disabled counter is accessed.
-*//***************************************************************************/
-#define FM_IOC_GET_COUNTER                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(4), ioc_fm_counters_params_t)
-
-/**************************************************************************//**
- @Function      FM_IOC_SET_COUNTER
-
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
-
- @Param[in]     ioc_fm_counters_params_t The requested counter parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_SET_COUNTER                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(5), ioc_fm_counters_params_t)
-
-/**************************************************************************//**
- @Function      FM_IOC_FORCE_INTR
-
- @Description   Causes an interrupt event on the requested source.
-
- @Param[in]     ioc_fm_exceptions   An exception to be forced.
-
- @Return        E_OK on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_FORCE_INTR                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)
-
-/**************************************************************************//**
- @Function      FM_IOC_GET_API_VERSION
-
- @Description   Reads the FMD IOCTL API version.
-
- @Param[in,out] ioc_fm_api_version_t The requested counter parameters.
-
- @Return        Version's value.
-*//***************************************************************************/
-#define FM_IOC_GET_API_VERSION                               _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(7), ioc_fm_api_version_t)
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Function      FM_VSP_Config
-
- @Description   Creates descriptor for the FM VSP module.
-
-                The routine returns a handle (descriptor) to the FM VSP object.
-                This descriptor must be passed as first parameter to all other
-                FM VSP function calls.
-
-                No actual initialization or configuration of FM hardware is
-                done by this routine.
-
-@Param[in]      p_FmVspParams   Pointer to data structure of parameters
-
- @Retval        Handle to FM VSP object, or NULL for Failure.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_IOC_VSP_CONFIG_COMPAT                             _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(8), ioc_compat_fm_vsp_params_t)
-#endif
-#define FM_IOC_VSP_CONFIG                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(8), ioc_fm_vsp_params_t)
-
-/**************************************************************************//**
- @Function      FM_VSP_Init
-
- @Description   Initializes the FM VSP module
-
- @Param[in]     h_FmVsp - FM VSP module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_IOC_VSP_INIT_COMPAT                               _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(9), ioc_compat_fm_obj_t)
-#endif
-#define FM_IOC_VSP_INIT                                      _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(9), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_VSP_Free
-
- @Description   Frees all resources that were assigned to FM VSP module.
-
-                Calling this routine invalidates the descriptor.
-
- @Param[in]     h_FmVsp - FM VSP module descriptor
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_IOC_VSP_FREE_COMPAT                               _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(10), ioc_compat_fm_obj_t)
-#endif
-#define FM_IOC_VSP_FREE                                      _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(10), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigPoolDepletion
-
- @Description   Calling this routine enables pause frame generation depending on the
-                depletion status of BM pools. It also defines the conditions to activate
-                this functionality. By default, this functionality is disabled.
-
- @Param[in]     ioc_fm_buf_pool_depletion_params_t      A structure holding the required parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_IOC_VSP_CONFIG_POOL_DEPLETION_COMPAT              _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(11), ioc_compat_fm_buf_pool_depletion_params_t)
-#endif
-#define FM_IOC_VSP_CONFIG_POOL_DEPLETION                     _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(11), ioc_fm_buf_pool_depletion_params_t)
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigBufferPrefixContent
-
- @Description   Defines the structure, size and content of the application buffer.
-
-                The prefix will
-                In VSPs defined for Tx ports, if 'passPrsResult', the application
-                should set a value to their offsets in the prefix of
-                the FM will save the first 'privDataSize', than,
-                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
-                and timeStamp, and the packet itself (in this order), to the
-                application buffer, and to offset.
-
-                Calling this routine changes the buffer margins definitions
-                in the internal driver data base from its default
-                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
-                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
-                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
-
- @Param[in]     ioc_fm_buffer_prefix_content_params_t   A structure holding the required parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT_COMPAT       _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(12), ioc_compat_fm_buffer_prefix_content_params_t)
-#endif
-#define FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT              _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(12), ioc_fm_buffer_prefix_content_params_t)
-
-/**************************************************************************//**
- @Function      FM_VSP_ConfigNoScatherGather
-
- @Description   Calling this routine changes the possibility to receive S/G frame
-                in the internal driver data base
-                from its default configuration: optimize = [DEFAULT_FM_SP_noScatherGather]
-
- @Param[in]     ioc_fm_vsp_config_no_sg_params_t        A structure holding the required parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_IOC_VSP_CONFIG_NO_SG_COMPAT                     _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(13), ioc_compat_fm_vsp_config_no_sg_params_t)
-#endif
-#define FM_IOC_VSP_CONFIG_NO_SG                            _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(13), ioc_fm_vsp_config_no_sg_params_t)
-
-/**************************************************************************//**
- @Function      FM_VSP_GetBufferPrsResult
-
- @Description   Returns the pointer to the parse result in the data buffer.
-                In Rx ports this is relevant after reception, if parse
-                result is configured to be part of the data passed to the
-                application. For non Rx ports it may be used to get the pointer
-                of the area in the buffer where parse result should be
-                initialized - if so configured.
-                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
-                configuration.
-
- @Param[in]     ioc_fm_vsp_prs_result_params_t  A structure holding the required parameters.
-
- @Return        Parse result pointer on success, NULL if parse result was not
-                configured for this port.
-
- @Cautions      Allowed only following FM_VSP_Init().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_IOC_VSP_GET_BUFFER_PRS_RESULT_COMPAT            _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(14), ioc_compat_fm_vsp_prs_result_params_t)
-#endif
-#define FM_IOC_VSP_GET_BUFFER_PRS_RESULT                   _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(14), ioc_fm_vsp_prs_result_params_t)
-#endif /* (DPAA_VERSION >= 11) */
-
-/**************************************************************************//**
- @Function      FM_CtrlMonStart
-
- @Description   Start monitoring utilization of all available FM controllers.
-
-                In order to obtain FM controllers utilization the following sequence
-                should be used:
-                -# FM_CtrlMonStart()
-                -# FM_CtrlMonStop()
-                -# FM_CtrlMonGetCounters() - issued for each FM controller
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_CTRL_MON_START                              _IO(FM_IOC_TYPE_BASE, FM_IOC_NUM(15))
-
-
-/**************************************************************************//**
- @Function      FM_CtrlMonStop
-
- @Description   Stop monitoring utilization of all available FM controllers.
-
-                In order to obtain FM controllers utilization the following sequence
-                should be used:
-                -# FM_CtrlMonStart()
-                -# FM_CtrlMonStop()
-                -# FM_CtrlMonGetCounters() - issued for each FM controller
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_CTRL_MON_STOP                               _IO(FM_IOC_TYPE_BASE, FM_IOC_NUM(16))
-
-/**************************************************************************//**
- @Function      FM_CtrlMonGetCounters
-
- @Description   Obtain FM controller utilization parameters.
-
-                In order to obtain FM controllers utilization the following sequence
-                should be used:
-                -# FM_CtrlMonStart()
-                -# FM_CtrlMonStop()
-                -# FM_CtrlMonGetCounters() - issued for each FM controller
-
- @Param[in]     ioc_fm_ctrl_mon_counters_params_t       A structure holding the required parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_IOC_CTRL_MON_GET_COUNTERS_COMPAT                _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(17), ioc_compat_fm_ctrl_mon_counters_params_t)
-#endif
-#define FM_IOC_CTRL_MON_GET_COUNTERS                       _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(17), ioc_fm_ctrl_mon_counters_params_t)
-
-/** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */
-/** @} */ /* end of lnx_ioctl_FM_lib_grp group */
-/** @} */ /* end of lnx_ioctl_FM_grp */
-
-#define FMD_API_VERSION_MAJOR 18
-#define FMD_API_VERSION_MINOR 1
-#define FMD_API_VERSION_RESPIN 2
-
-#endif /* __FM_IOCTLS_H */
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
deleted file mode 100644
index 0123b17..0000000
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ /dev/null
@@ -1,2708 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/******************************************************************************
- @File          fm_pcd_ioctls.h
-
- @Description   FM PCD ...
-*//***************************************************************************/
-#ifndef __FM_PCD_IOCTLS_H
-#define __FM_PCD_IOCTLS_H
-
-#include "net_ioctls.h"
-#include "fm_ioctls.h"
-
-
-/**************************************************************************//**
-
- @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
-
- @Description   Frame Manager Linux ioctls definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PCD_grp FM PCD
-
- @Description   Frame Manager PCD API functions, definitions and enums
-
-                The FM PCD module is responsible for the initialization of all
-                global classifying FM modules. This includes the parser general and
-                common registers, the key generator global and common registers,
-                and the policer global and common registers.
-                In addition, the FM PCD SW module will initialize all required
-                key generator schemes, coarse classification flows, and policer
-                profiles. When an FM module is configured to work with one of these
-                entities, it will register to it using the FM PORT API. The PCD
-                module will manage the PCD resources - i.e. resource management of
-                KeyGen schemes, etc.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection    General PCD defines
-*//***************************************************************************/
-#define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
-
-#define IOC_FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
-#define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
-                                                                        /**< Number of distinction units is limited by
-                                                                             register size (32 bits) minus reserved bits
-                                                                             for private headers. */
-#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers
-                                                                             in a distinction unit */
-#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KeyGen registers */
-#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration;
-                                                                             For HW implementation reasons, in most
-                                                                             cases less than this will be allowed; The
-                                                                             driver will return an initialization error
-                                                                             if resource is unavailable. */
-#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KeyGen extractions. */
-#define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
-
-#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Maximum number of SW parser labels */
-#define IOC_FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of SW parser area */
-#define IOC_FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
-                                                                             of the SW parser area */
-#if DPAA_VERSION >= 11
-#define IOC_FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000240          /**< Number of bytes saved for patches */
-#else
-#define IOC_FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000200          /**< Number of bytes saved for patches */
-#endif
-
-#define IOC_FM_PCD_PRS_SW_TAIL_SIZE                     4                   /**< Number of bytes that must be cleared at
-                                                                             the end of the SW parser area */
-#define IOC_FM_SW_PRS_MAX_IMAGE_SIZE                    (IOC_FM_PCD_SW_PRS_SIZE-IOC_FM_PCD_PRS_SW_OFFSET-IOC_FM_PCD_PRS_SW_TAIL_SIZE-IOC_FM_PCD_PRS_SW_PATCHES_SIZE)
-                                                                        /**< Maximum size of SW parser code */
-
-#define IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
-                                                                             insert manipulation */
-
-#if DPAA_VERSION >= 11
-#define IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
-#endif /* DPAA_VERSION >= 11 */
-/* @} */
-
-#ifdef FM_CAPWAP_SUPPORT
-#error "FM_CAPWAP_SUPPORT not implemented!"
-#endif
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PCD_init_grp FM PCD Initialization Unit
-
- @Description   Frame Manager PCD Initialization Unit API
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   PCD counters
-                (must match enum e_FmPcdCounters defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_counters {
-    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< KeyGen counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter - counts the total number of RED packets that exit the Policer. */
-    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter - counts the total number of YELLOW packets that exit the Policer. */
-    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter - counts the number of packets that changed color to RED by the Policer;
-                                                                         This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_RED packet count, indicating active color changes. */
-    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter - counts the number of packets that changed color to YELLOW by the Policer;
-                                                                         This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW packet count, indicating active color changes. */
-    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter - counts the total number of packets passed in the Policer. */
-    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter - counts the number of packets with length mismatch. */
-    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter - counts the number of times the parser block is dispatched. */
-    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L2 parse result is returned (including errors). */
-    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L3 parse result is returned (including errors). */
-    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L4 parse result is returned (including errors). */
-    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter - counts the number of times SHIM parse result is returned (including errors). */
-    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L2 parse result is returned with errors. */
-    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L3 parse result is returned with errors. */
-    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L4 parse result is returned with errors. */
-    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter - counts the number of times SHIM parse result is returned with errors. */
-    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter - counts the number of cycles spent executing soft parser instruction (including stall cycles). */
-    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter - counts the number of cycles stalled waiting for parser internal memory reads while executing soft parser instruction. */
-    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter - counts the number of cycles spent executing hard parser (including stall cycles). */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter - counts the number of cycles while performing FMan Memory read. */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory read. */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter - counts the number of cycles while performing FMan Memory write. */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory write. */
-    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter - counts the number of cycles stalled while performing a FPM Command. */
-} ioc_fm_pcd_counters;
-
-/**************************************************************************//**
- @Description   PCD interrupts
-                (must match enum e_FmPcdExceptions defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_exceptions {
-    e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< KeyGen double-bit ECC error is detected on internal memory read access. */
-    e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< KeyGen scheme configuration error indicating a key size larger than 56 bytes. */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Policer double-bit ECC error has been detected on PRAM read access. */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Policer access to a non-initialized profile has been detected. */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,    /**< Policer RAM self-initialization complete */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,     /**< Policer atomic action complete */
-    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                  /**< Parser double-bit ECC error */
-    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                   /**< Parser single-bit ECC error */
-} ioc_fm_pcd_exceptions;
-
-/** @} */ /* end of lnx_ioctl_FM_PCD_init_grp group */
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
-
- @Description   Frame Manager PCD Runtime Unit
-
-                The runtime control allows creation of PCD infrastructure modules
-                such as Network Environment Characteristics, Classification Plan
-                Groups and Coarse Classification Trees.
-                It also allows on-the-fly initialization, modification and removal
-                of PCD modules such as KeyGen schemes, coarse classification nodes
-                and Policer profiles.
-
-                In order to explain the programming model of the PCD driver interface
-                a few terms should be explained, and will be used below.
-                  - Distinction Header - One of the 16 protocols supported by the FM parser,
-                    or one of the SHIM headers (1 or 2). May be a header with a special
-                    option (see below).
-                  - Interchangeable Headers Group - This is a group of Headers recognized
-                    by either one of them. For example, if in a specific context the user
-                    chooses to treat IPv4 and IPV6 in the same way, they may create an
-                    interchangeable Headers Unit consisting of these 2 headers.
-                  - A Distinction Unit - a Distinction Header or an Interchangeable Headers
-                    Group.
-                  - Header with special option - applies to Ethernet, MPLS, VLAN, IPv4 and
-                    IPv6, includes multicast, broadcast and other protocol specific options.
-                    In terms of hardware it relates to the options available in the classification
-                    plan.
-                  - Network Environment Characteristics - a set of Distinction Units that define
-                    the total recognizable header selection for a certain environment. This is
-                    NOT the list of all headers that will ever appear in a flow, but rather
-                    everything that needs distinction in a flow, where distinction is made by KeyGen
-                    schemes and coarse classification action descriptors.
-
-                The PCD runtime modules initialization is done in stages. The first stage after
-                initializing the PCD module itself is to establish a Network Flows Environment
-                Definition. The application may choose to establish one or more such environments.
-                Later, when needed, the application will have to state, for some of its modules,
-                to which single environment it belongs.
-
- @{
-*//***************************************************************************/
-
-
-/**************************************************************************//**
- @Description   structure for FM counters
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_counters_params_t {
-    ioc_fm_pcd_counters cnt;                /**< The requested counter */
-    uint32_t            val;                /**< The requested value to get/set from/into the counter */
-} ioc_fm_pcd_counters_params_t;
-
-/**************************************************************************//**
- @Description   structure for FM exception definitios
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_exception_params_t {
-    ioc_fm_pcd_exceptions exception;        /**< The requested exception */
-    bool                  enable;           /**< TRUE to enable interrupt, FALSE to mask it. */
-} ioc_fm_pcd_exception_params_t;
-
-/**************************************************************************//**
- @Description   A structure for SW parser labels
-                (must be identical to struct t_FmPcdPrsLabelParams defined in fm_pcd_ext.h)
- *//***************************************************************************/
-typedef struct ioc_fm_pcd_prs_label_params_t {
-    uint32_t                instruction_offset;             /**< SW parser label instruction offset (2 bytes
-                                                                 resolution), relative to Parser RAM. */
-    ioc_net_header_type     hdr;                            /**< The existence of this header will invoke
-                                                                 the SW parser code. */
-    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one SW parser
-                                                                 attachments for the same header, use this
-                                                                 index to distinguish between them. */
-} ioc_fm_pcd_prs_label_params_t;
-
-/**************************************************************************//**
- @Description   A structure for SW parser
-                (Must match struct t_FmPcdPrsSwParams defined in fm_pcd_ext.h)
- *//***************************************************************************/
-typedef struct ioc_fm_pcd_prs_sw_params_t {
-    bool                    override;                   /**< FALSE to invoke a check that nothing else
-                                                             was loaded to this address, including
-                                                             internal patches.
-                                                             TRUE to override any existing code.*/
-    uint32_t                size;                       /**< SW parser code size */
-    uint16_t                base;                       /**< SW parser base (in instruction counts!
-                                                             must be larger than 0x20)*/
-    uint8_t                 *p_code;                    /**< SW parser code */
-    uint32_t                sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
-                                                        /**< SW parser data (parameters) */
-    uint8_t                 num_of_labels;              /**< Number of labels for SW parser. */
-    ioc_fm_pcd_prs_label_params_t labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
-                                                        /**< SW parser labels table,
-                                                             containing num_of_labels entries */
-} ioc_fm_pcd_prs_sw_params_t;
-
-/**************************************************************************//**
- @Description   A structure to set the a KeyGen default value
- *//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
-    uint8_t                         valueId;                /**< 0,1 - one of 2 global default values */
-    uint32_t                        value;                  /**< The requested default value */
-} ioc_fm_pcd_kg_dflt_value_params_t;
-
-
-/**************************************************************************//**
- @Function      FM_PCD_Enable
-
- @Description   This routine should be called after PCD is initialized for enabling all
-                PCD engines according to their existing configuration.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only when PCD is disabled.
-*//***************************************************************************/
-#define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
-
-/**************************************************************************//**
- @Function      FM_PCD_Disable
-
- @Description   This routine may be called when PCD is enabled in order to
-                disable all PCD engines. It may be called
-                only when none of the ports in the system are using the PCD.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only when PCD is enabled.
-*//***************************************************************************/
-#define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
-
- /**************************************************************************//**
- @Function      FM_PCD_PrsLoadSw
-
- @Description   This routine may be called only when all ports in the
-                system are actively using the classification plan scheme.
-                In such cases it is recommended in order to save resources.
-                The driver automatically saves 8 classification plans for
-                ports that do NOT use the classification plan mechanism, to
-                avoid this (in order to save those entries) this routine may
-                be called.
-
- @Param[in]     ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only when PCD is disabled.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_PRS_LOAD_SW_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_compat_fm_pcd_prs_sw_params_t)
-#endif
-#define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSetDfltValue
-
- @Description   Calling this routine sets a global default value to be used
-                by the KeyGen when parser does not recognize a required
-                field/header.
-                By default default values are 0.
-
- @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   A pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only when PCD is disabled.
-*//***************************************************************************/
-#define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSetAdditionalDataAfterParsing
-
- @Description   Calling this routine allows the keygen to access data past
-                the parser finishing point.
-
- @Param[in]     uint8_t   payload-offset; the number of bytes beyond the parser location.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only when PCD is disabled.
-*//***************************************************************************/
-#define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_SetException
-
- @Description   Calling this routine enables/disables PCD interrupts.
-
- @Param[in]     ioc_fm_pcd_exception_params_t     Arguments struct with exception to be enabled/disabled.
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_GetCounter
-
- @Description   Reads one of the FM PCD counters.
-
- @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Note that it is user's responsibilty to call this routine only
-                for enabled counters, and there will be no indication if a
-                disabled counter is accessed.
-*//***************************************************************************/
-#define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
-
-#if 0
-TODO: unused IOCTL
-/**************************************************************************//**
- @Function      FM_PCD_ModifyCounter
-
- @Description   Writes a value to an enabled counter. Use "0" to reset the counter.
-
- @Param[in]     ioc_fm_pcd_counters_params_t - The requested counter parameters.
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#define FM_PCD_IOC_MODIFY_COUNTER   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
-#define FM_PCD_IOC_SET_COUNTER      FM_PCD_IOC_MODIFY_COUNTER
-#endif
-
-/**************************************************************************//**
- @Function      FM_PCD_ForceIntr
-
- @Description   Causes an interrupt event on the requested source.
-
- @Param[in]     ioc_fm_pcd_exceptions - An exception to be forced.
-
- @Return        0 on success; error code if the exception is not enabled,
-                or is not able to create interrupt.
-*//***************************************************************************/
-#define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
-
-/**************************************************************************//**
- @Collection    Definitions of coarse classification parameters as required by KeyGen
-                (when coarse classification is the next engine after this scheme).
-*//***************************************************************************/
-#define IOC_FM_PCD_MAX_NUM_OF_CC_TREES              8
-#define IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS             16
-#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS              4
-#define IOC_FM_PCD_MAX_NUM_OF_KEYS                  256
-#define IOC_FM_PCD_MAX_NUM_OF_FLOWS                 (4*KILOBYTE)
-#define IOC_FM_PCD_MAX_SIZE_OF_KEY                  56
-#define IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
-#define IOC_FM_PCD_LAST_KEY_INDEX                   0xffff
-#define IOC_FM_PCD_MANIP_DSCP_VALUES                64
-/* @} */
-
-/**************************************************************************//**
- @Collection    A set of definitions to allow protocol
-                special option description.
-*//***************************************************************************/
-typedef uint32_t            ioc_protocol_opt_t;      /**< A general type to define a protocol option. */
-
-typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol options. */
-#define IOC_ETH_BROADCAST               0x80000000   /**< Ethernet Broadcast. */
-#define IOC_ETH_MULTICAST               0x40000000   /**< Ethernet Multicast. */
-
-typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
-#define IOC_VLAN_STACKED                0x20000000   /**< Stacked VLAN. */
-
-typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
-#define IOC_MPLS_STACKED                0x10000000   /**< Stacked MPLS. */
-
-typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
-#define IOC_IPV4_BROADCAST_1            0x08000000   /**< IPv4 Broadcast. */
-#define IOC_IPV4_MULTICAST_1            0x04000000   /**< IPv4 Multicast. */
-#define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
-#define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
-
-#define IOC_IPV4_FRAG_1                 0x00000008   /**< IPV4 reassembly option.
-                                                          IPV4 Reassembly manipulation requires network
-                                                          environment with IPV4 header and IPV4_FRAG_1 option  */
-
-typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
-#define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
-#define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
-#define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
-
-#define IOC_IPV6_FRAG_1                 0x00000004   /**< IPV6 reassembly option.
-                                                          IPV6 Reassembly manipulation requires network
-                                                          environment with IPV6 header and IPV6_FRAG_1 option  */
-
-/* @} */
-
-#define IOC_FM_PCD_MANIP_MAX_HDR_SIZE               256
-#define IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS         64
-/**************************************************************************//**
- @Collection    A set of definitions to support Header Manipulation selection.
-*//***************************************************************************/
-typedef uint32_t                        ioc_hdr_manip_flags_t;              /**< A general type to define a HMan update command flags. */
-
-typedef ioc_hdr_manip_flags_t           ioc_ipv4_hdr_manip_update_flags_t;  /**< IPv4 protocol HMan update command flags. */
-
-#define IOC_HDR_MANIP_IPV4_TOS          0x80000000          /**< update TOS with the given value ('tos' field
-                                                                 of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
-#define IOC_HDR_MANIP_IPV4_ID           0x40000000          /**< update IP ID with the given value ('id' field
-                                                                 of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
-#define IOC_HDR_MANIP_IPV4_TTL          0x20000000          /**< Decrement TTL by 1 */
-#define IOC_HDR_MANIP_IPV4_SRC          0x10000000          /**< update IP source address with the given value
-                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
-#define IOC_HDR_MANIP_IPV4_DST          0x08000000          /**< update IP destination address with the given value
-                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
-
-typedef ioc_hdr_manip_flags_t           ioc_ipv6_hdr_manip_update_flags_t;  /**< IPv6 protocol HMan update command flags. */
-
-#define IOC_HDR_MANIP_IPV6_TC           0x80000000          /**< update Traffic Class address with the given value
-                                                                 ('traffic_class' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
-#define IOC_HDR_MANIP_IPV6_HL           0x40000000          /**< Decrement Hop Limit by 1 */
-#define IOC_HDR_MANIP_IPV6_SRC          0x20000000          /**< update IP source address with the given value
-                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
-#define IOC_HDR_MANIP_IPV6_DST          0x10000000          /**< update IP destination address with the given value
-                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
-
-typedef ioc_hdr_manip_flags_t           ioc_tcp_udp_hdr_manip_update_flags_t;/**< TCP/UDP protocol HMan update command flags. */
-
-#define IOC_HDR_MANIP_TCP_UDP_SRC       0x80000000          /**< update TCP/UDP source address with the given value
-                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
-#define IOC_HDR_MANIP_TCP_UDP_DST       0x40000000          /**< update TCP/UDP destination address with the given value
-                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
-#define IOC_HDR_MANIP_TCP_UDP_CHECKSUM  0x20000000          /**< update TCP/UDP checksum */
-
-/* @} */
-
-/**************************************************************************//**
- @Description   A type used for returning the order of the key extraction.
-                each value in this array represents the index of the extraction
-                command as defined by the user in the initialization extraction array.
-                The valid size of this array is the user define number of extractions
-                required (also marked by the second '0' in this array).
-*//***************************************************************************/
-typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
-
-/**************************************************************************//**
- @Description   All PCD engines
-                (must match enum e_FmPcdEngine defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_engine {
-    e_IOC_FM_PCD_INVALID = 0,   /**< Invalid PCD engine */
-    e_IOC_FM_PCD_DONE,          /**< No PCD Engine indicated */
-    e_IOC_FM_PCD_KG,            /**< KeyGen */
-    e_IOC_FM_PCD_CC,            /**< Coarse Classifier */
-    e_IOC_FM_PCD_PLCR,          /**< Policer */
-    e_IOC_FM_PCD_PRS,           /**< Parser */
-#if DPAA_VERSION >= 11
-    e_IOC_FM_PCD_FR,            /**< Frame Replicator */
-#endif /* DPAA_VERSION >= 11 */
-    e_IOC_FM_PCD_HASH           /**< Hash Table */
-} ioc_fm_pcd_engine;
-
-/**************************************************************************//**
- @Description   An enum for selecting extraction by header types
-                (Must match enum e_FmPcdExtractByHdrType defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_extract_by_hdr_type {
-    e_IOC_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
-    e_IOC_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
-    e_IOC_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
-} ioc_fm_pcd_extract_by_hdr_type;
-
-/**************************************************************************//**
- @Description   An enum for selecting extraction source (when it is not the header)
-                (Must match enum e_FmPcdExtractFrom defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_extract_from {
-    e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
-    e_IOC_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
-    e_IOC_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG only: Extract from the point where parsing had finished */
-    e_IOC_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
-    e_IOC_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
-    e_IOC_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG & CC: Extract from the parser result */
-    e_IOC_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
-    e_IOC_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
-} ioc_fm_pcd_extract_from;
-
-/**************************************************************************//**
- @Description   An enum for selecting extraction type
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_extract_type {
-    e_IOC_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
-    e_IOC_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
-    e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
-} ioc_fm_pcd_extract_type;
-
-/**************************************************************************//**
- @Description   An enum for selecting a default
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_kg_extract_dflt_select {
-    e_IOC_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
-    e_IOC_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
-    e_IOC_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
-    e_IOC_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
-    e_IOC_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
-} ioc_fm_pcd_kg_extract_dflt_select;
-
-/**************************************************************************//**
- @Description   Enumeration type defining all default groups - each group shares
-                a default value, one of four user-initialized values.
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
-    e_IOC_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
-    e_IOC_FM_PCD_KG_TCI,                    /**< TCI field */
-    e_IOC_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
-    e_IOC_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
-    e_IOC_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
-    e_IOC_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
-    e_IOC_FM_PCD_KG_IP_ADDR,                /**< IP addr */
-    e_IOC_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
-    e_IOC_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
-    e_IOC_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
-    e_IOC_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
-    e_IOC_FM_PCD_KG_L4_PORT,                /**< L4 Port */
-    e_IOC_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
-    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by SW,
-                                                 any data extraction that is not the full
-                                                 field described above  */
-    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by SW,
-                                                 any data extraction without validation */
-    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by SW,
-                                                 extraction from parser result or
-                                                 direct use of default value  */
-} ioc_fm_pcd_kg_known_fields_dflt_types;
-
-/**************************************************************************//**
- @Description   Enumeration type for defining header index for scenarios with
-                multiple (tunneled) headers
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_hdr_index {
-    e_IOC_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
-                                                     to specify regular IP (not tunneled). */
-    e_IOC_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
-    e_IOC_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
-    e_IOC_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
-    e_IOC_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
-} ioc_fm_pcd_hdr_index;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer profile functional type
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_profile_type_selection {
-    e_IOC_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
-    e_IOC_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
-} ioc_fm_pcd_profile_type_selection;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer profile algorithm
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_algorithm_selection {
-    e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
-    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorithm RFC 2698 */
-    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorithm RFC 4115 */
-} ioc_fm_pcd_plcr_algorithm_selection;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting a policer profile color mode
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_color_mode {
-    e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
-    e_IOC_FM_PCD_PLCR_COLOR_AWARE   /**< Color aware */
-} ioc_fm_pcd_plcr_color_mode;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting a policer profile color
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_color {
-    e_IOC_FM_PCD_PLCR_GREEN,    /**< Green */
-    e_IOC_FM_PCD_PLCR_YELLOW,   /**< Yellow */
-    e_IOC_FM_PCD_PLCR_RED,      /**< Red */
-    e_IOC_FM_PCD_PLCR_OVERRIDE  /**< Color override */
-} ioc_fm_pcd_plcr_color;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer profile packet frame length selector
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_frame_length_select {
-  e_IOC_FM_PCD_PLCR_L2_FRM_LEN,     /**< L2 frame length */
-  e_IOC_FM_PCD_PLCR_L3_FRM_LEN,     /**< L3 frame length */
-  e_IOC_FM_PCD_PLCR_L4_FRM_LEN,     /**< L4 frame length */
-  e_IOC_FM_PCD_PLCR_FULL_FRM_LEN    /**< Full frame length */
-} ioc_fm_pcd_plcr_frame_length_select;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting roll-back frame
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
-  e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
-  e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
-} ioc_fm_pcd_plcr_roll_back_frame_select;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer profile packet or byte mode
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_rate_mode {
-    e_IOC_FM_PCD_PLCR_BYTE_MODE,    /**< Byte mode */
-    e_IOC_FM_PCD_PLCR_PACKET_MODE   /**< Packet mode */
-} ioc_fm_pcd_plcr_rate_mode;
-
-/**************************************************************************//**
- @Description   Enumeration type for defining action of frame
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_done_action {
-    e_IOC_FM_PCD_ENQ_FRAME = 0,     /**< Enqueue frame */
-    e_IOC_FM_PCD_DROP_FRAME         /**< Drop frame */
-} ioc_fm_pcd_done_action;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the policer counter
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_profile_counters {
-    e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
-    e_IOC_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
-    e_IOC_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
-    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
-    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
-} ioc_fm_pcd_plcr_profile_counters;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting the PCD action after extraction
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_action {
-    e_IOC_FM_PCD_ACTION_NONE,                           /**< NONE  */
-    e_IOC_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction*/
-    e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
-} ioc_fm_pcd_action;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of insert manipulation
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_insrt_type {
-    e_IOC_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
-    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
-#ifdef FM_CAPWAP_SUPPORT
-    e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
-#endif /* FM_CAPWAP_SUPPORT */
-} ioc_fm_pcd_manip_hdr_insrt_type;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of remove manipulation
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_rmv_type {
-    e_IOC_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
-    e_IOC_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
-} ioc_fm_pcd_manip_hdr_rmv_type;
-
-/**************************************************************************//**
- @Description   An enum for selecting specific L2 fields removal
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_rmv_specific_l2 {
-    e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET,                /**< Ethernet/802.3 MAC */
-    e_IOC_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS,           /**< stacked QTags */
-    e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS,       /**< MPLS and Ethernet/802.3 MAC header until
-                                                             the header which follows the MPLS header */
-    e_IOC_FM_PCD_MANIP_HDR_RMV_MPLS                     /**< Remove MPLS header (Unlimited MPLS labels) */
-} ioc_fm_pcd_manip_hdr_rmv_specific_l2;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting specific fields updates
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_field_update_type {
-    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN,           /**< VLAN updates */
-    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4,           /**< IPV4 updates */
-    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6,           /**< IPV6 updates */
-    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP,        /**< TCP_UDP updates */
-} ioc_fm_pcd_manip_hdr_field_update_type;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting VLAN updates
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_field_update_vlan {
-    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI,      /**< Replace VPri of outer most VLAN tag. */
-    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN    /**< DSCP to VLAN priority bits translation */
-} ioc_fm_pcd_manip_hdr_field_update_vlan;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting specific L2 fields removal
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_insrt_specific_l2 {
-    e_IOC_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
-} ioc_fm_pcd_manip_hdr_insrt_specific_l2;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of header insertion
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_insrt_by_hdr_type {
-    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2         /**< Specific L2 fields insertion */
-} ioc_fm_pcd_manip_hdr_insrt_by_hdr_type;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting specific custom command
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_custom_type {
-    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE,           /**< Replace IPv4/IPv6 */
-} ioc_fm_pcd_manip_hdr_custom_type;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting specific custom command
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_custom_ip_replace {
-    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6, /**< Replace IPv4 by IPv6 */
-    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4  /**< Replace IPv6 by IPv4 */
-} ioc_fm_pcd_manip_hdr_custom_ip_replace;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of header removal
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_hdr_rmv_by_hdr_type {
-    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0       /**< Specific L2 fields removal */
-#ifdef FM_CAPWAP_SUPPORT
-    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
-#endif /* FM_CAPWAP_SUPPORT */
-} ioc_fm_pcd_manip_hdr_rmv_by_hdr_type;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of timeout mode
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_reassem_time_out_mode {
-    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES,         /**< Limits the time of the reassembly process
-                                                             from the first fragment to the last */
-    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG            /**< Limits the time of receiving the fragment */
-} ioc_fm_pcd_manip_reassem_time_out_mode;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of WaysNumber mode
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_reassem_ways_number {
-    e_IOC_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< One way hash    */
-    e_IOC_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< Two ways hash   */
-    e_IOC_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< Three ways hash */
-    e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< Four ways hash  */
-    e_IOC_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< Five ways hash  */
-    e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< Six ways hash   */
-    e_IOC_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< Seven ways hash */
-    e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< Eight ways hash */
-} ioc_fm_pcd_manip_reassem_ways_number;
-
-#ifdef FM_CAPWAP_SUPPORT
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of statistics mode
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_stats {
-    e_IOC_FM_PCD_STATS_PER_FLOWID = 0       /**< Flow ID is used as index for getting statistics */
-} ioc_fm_pcd_stats;
-#endif
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting manipulation type
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_type {
-    e_IOC_FM_PCD_MANIP_HDR = 0,             /**< Header manipulation */
-    e_IOC_FM_PCD_MANIP_REASSEM,             /**< Reassembly */
-    e_IOC_FM_PCD_MANIP_FRAG,                /**< Fragmentation */
-    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD      /**< Special Offloading */
-} ioc_fm_pcd_manip_type;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of statistics mode
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_cc_stats_mode {
-    e_IOC_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
-    e_IOC_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
-    e_IOC_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
-    e_IOC_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics */
-} ioc_fm_pcd_cc_stats_mode;
-
-/**************************************************************************//**
- @Description   Enumeration type for determining the action in case an IP packet
-                is larger than MTU but its DF (Don't Fragment) bit is set.
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_dont_frag_action {
-    e_IOC_FM_PCD_MANIP_DISCARD_PACKET = 0,      /**< Discard packet */
-    e_IOC_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET =  e_IOC_FM_PCD_MANIP_DISCARD_PACKET,
-                                                /**< Obsolete, cannot enqueue to error queue;
-                                                     In practice, selects to discard packets;
-                                                     Will be removed in the future */
-    e_IOC_FM_PCD_MANIP_FRAGMENT_PACKECT,        /**< Fragment packet and continue normal processing */
-    e_IOC_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG    /**< Continue normal processing without fragmenting the packet */
-} ioc_fm_pcd_manip_dont_frag_action;
-
-/**************************************************************************//**
- @Description   Enumeration type for selecting type of special offload manipulation
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_special_offload_type {
-    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC    /**< IPSec offload manipulation */
-} ioc_fm_pcd_manip_special_offload_type;
-
-/**************************************************************************//**
- @Description   A union of protocol dependent special options
-                (Must match union u_FmPcdHdrProtocolOpt defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef union ioc_fm_pcd_hdr_protocol_opt_u {
-    ioc_eth_protocol_opt_t    eth_opt;     /**< Ethernet options */
-    ioc_vlan_protocol_opt_t   vlan_opt;    /**< Vlan options */
-    ioc_mpls_protocol_opt_t   mpls_opt;    /**< MPLS options */
-    ioc_ipv4_protocol_opt_t   ipv4_opt;    /**< IPv4 options */
-    ioc_ipv6_protocol_opt_t   ipv6_opt;    /**< IPv6 options */
-} ioc_fm_pcd_hdr_protocol_opt_u;
-
-/**************************************************************************//**
- @Description   A union holding all known protocol fields
-*//***************************************************************************/
-typedef union ioc_fm_pcd_fields_u {
-    ioc_header_field_eth_t              eth;            /**< Ethernet               */
-    ioc_header_field_vlan_t             vlan;           /**< VLAN                   */
-    ioc_header_field_llc_snap_t         llc_snap;       /**< LLC SNAP               */
-    ioc_header_field_pppoe_t            pppoe;          /**< PPPoE                  */
-    ioc_header_field_mpls_t             mpls;           /**< MPLS                   */
-    ioc_header_field_ip_t               ip;             /**< IP                     */
-    ioc_header_field_ipv4_t             ipv4;           /**< IPv4                   */
-    ioc_header_field_ipv6_t             ipv6;           /**< IPv6                   */
-    ioc_header_field_udp_t              udp;            /**< UDP                    */
-    ioc_header_field_tcp_t              tcp;            /**< TCP                    */
-    ioc_header_field_sctp_t             sctp;           /**< SCTP                   */
-    ioc_header_field_dccp_t             dccp;           /**< DCCP                   */
-    ioc_header_field_gre_t              gre;            /**< GRE                    */
-    ioc_header_field_minencap_t         minencap;       /**< Minimal Encapsulation  */
-    ioc_header_field_ipsec_ah_t         ipsec_ah;       /**< IPSec AH               */
-    ioc_header_field_ipsec_esp_t        ipsec_esp;      /**< IPSec ESP              */
-    ioc_header_field_udp_encap_esp_t    udp_encap_esp;  /**< UDP Encapsulation ESP  */
-} ioc_fm_pcd_fields_u;
-
-/**************************************************************************//**
- @Description   Parameters for defining header extraction for key generation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_from_hdr_t {
-    uint8_t             size;           /**< Size in byte */
-    uint8_t             offset;         /**< Byte offset */
-} ioc_fm_pcd_from_hdr_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining field extraction for key generation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_from_field_t {
-    ioc_fm_pcd_fields_u field;          /**< Field selection */
-    uint8_t             size;           /**< Size in byte */
-    uint8_t             offset;         /**< Byte offset */
-} ioc_fm_pcd_from_field_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining a single network environment unit
-                A distinction unit should be defined if it will later be used
-                by one or more PCD engines to distinguish between flows.
-                (Must match struct t_FmPcdDistinctionUnit defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_distinction_unit_t {
-    struct {
-        ioc_net_header_type             hdr;                /**< One of the headers supported by the FM */
-        ioc_fm_pcd_hdr_protocol_opt_u   opt;                /**< Select only one option! */
-    } hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS];
-} ioc_fm_pcd_distinction_unit_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining all different distinction units supported
-                by a specific PCD Network Environment Characteristics module.
-
-                Each unit represent a protocol or a group of protocols that may
-                be used later by the different PCD engines to distinguish between flows.
-                (Must match struct t_FmPcdNetEnvParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_net_env_params_t {
-    uint8_t                         num_of_distinction_units;/**< Number of different units to be identified */
-    ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
-                                                            /**< An array of num_of_distinction_units of the
-                                                                     different units to be identified */
-    void                            *id;                    /**< Output parameter; Returns the net-env Id to be used */
-} ioc_fm_pcd_net_env_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining a single extraction action when
-                creating a key
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_extract_entry_t {
-    ioc_fm_pcd_extract_type                 type;           /**< Extraction type select */
-    union {
-        struct {
-            ioc_net_header_type             hdr;            /**< Header selection */
-            bool                            ignore_protocol_validation;
-                                                            /**< Ignore protocol validation */
-            ioc_fm_pcd_hdr_index            hdr_index;      /**< Relevant only for MPLS, VLAN and tunneled
-                                                                 IP. Otherwise should be cleared.*/
-            ioc_fm_pcd_extract_by_hdr_type  type;           /**< Header extraction type select */
-            union {
-                ioc_fm_pcd_from_hdr_t       from_hdr;       /**< Extract bytes from header parameters */
-                ioc_fm_pcd_from_field_t     from_field;     /**< Extract bytes from field parameters */
-                ioc_fm_pcd_fields_u         full_field;     /**< Extract full field parameters */
-            } extract_by_hdr_type;
-        } extract_by_hdr;                                   /**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
-        struct {
-            ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
-            ioc_fm_pcd_action               action;         /**< Relevant for CC Only */
-            uint16_t                        ic_indx_mask;   /**< Relevant only for CC when
-                                                                 action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP;
-                                                                 Note that the number of bits that are set within
-                                                                 this mask must be log2 of the CC-node 'num_of_keys'.
-                                                                 Note that the mask cannot be set on the lower bits. */
-            uint8_t                         offset;         /**< Byte offset */
-            uint8_t                         size;           /**< Size in bytes */
-        } extract_non_hdr;                                  /**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
-    } extract_params;
-} ioc_fm_pcd_extract_entry_t;
-
-/**************************************************************************//**
- @Description   A structure for defining masks for each extracted
-                field in the key.
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_extract_mask_t {
-    uint8_t                extract_array_index;         /**< Index in the extraction array, as initialized by user */
-    uint8_t                offset;                      /**< Byte offset */
-    uint8_t                mask;                        /**< A byte mask (selected bits will be ignored) */
-} ioc_fm_pcd_kg_extract_mask_t;
-
-/**************************************************************************//**
- @Description   A structure for defining default selection per groups
-                of fields
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_extract_dflt_t {
-    ioc_fm_pcd_kg_known_fields_dflt_types    type;          /**< Default type select*/
-    ioc_fm_pcd_kg_extract_dflt_select        dflt_select;   /**< Default register select */
-} ioc_fm_pcd_kg_extract_dflt_t;
-
-
-/**************************************************************************//**
- @Description   A structure for defining all parameters needed for
-                generation a key and using a hash function
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
-    uint32_t                            private_dflt0;          /**< Scheme default register 0 */
-    uint32_t                            private_dflt1;          /**< Scheme default register 1 */
-    uint8_t                             num_of_used_extracts;   /**< defines the valid size of the following array */
-    ioc_fm_pcd_extract_entry_t          extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
-                                                                /**< An array of extraction definitions. */
-    uint8_t                             num_of_used_dflts;      /**< defines the valid size of the following array */
-    ioc_fm_pcd_kg_extract_dflt_t        dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
-                                                                /**< For each extraction used in this scheme, specify the required
-                                                                     default register to be used when header is not found.
-                                                                     types not specified in this array will get undefined value. */
-    uint8_t                             num_of_used_masks;      /**< Defines the valid size of the following array */
-    ioc_fm_pcd_kg_extract_mask_t        masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
-    uint8_t                             hash_shift;             /**< Hash result right shift.
-                                                                     Selects the 24 bits out of the 64 hash result.
-                                                                     0 means using the 24 LSB's, otherwise use the
-                                                                     24 LSB's after shifting right.*/
-    uint32_t                            hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
-                                                                             of queues for the key and hash functionality */
-    uint8_t                             hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
-    bool                                symmetric_hash;         /**< TRUE to generate the same hash for frames with swapped source and
-                                                                     destination fields on all layers; If TRUE, driver will check that for
-                                                                     all layers, if SRC extraction is selected, DST extraction must also be
-                                                                     selected, and vice versa. */
-} ioc_fm_pcd_kg_key_extract_and_hash_params_t;
-
-/**************************************************************************//**
- @Description   A structure of parameters for defining a single
-                Qid mask (extracted OR).
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_extracted_or_params_t {
-    ioc_fm_pcd_extract_type                 type;               /**< Extraction type select */
-    union {
-        struct {                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
-            ioc_net_header_type             hdr;
-            ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
-                                                                     IP. Otherwise should be cleared.*/
-            bool                            ignore_protocol_validation;
-
-        } extract_by_hdr;
-        ioc_fm_pcd_extract_from             src;                /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
-    } extract_params;
-    uint8_t                                 extraction_offset;  /**< Offset for extraction */
-    ioc_fm_pcd_kg_extract_dflt_select       dflt_value;         /**< Select register from which extraction is taken if
-                                                                     field not found */
-    uint8_t                                 mask;               /**< Mask LSB byte of extraction (specified bits are ignored) */
-    uint8_t                         bit_offset_in_fqid;    /**< 0-31, Selects which bits of the 24 FQID bits to effect using
-                                                             the extracted byte; Assume byte is placed as the 8 MSB's in
-                                                             a 32 bit word where the lower bits
-                                                             are the FQID; i.e if bitOffsetInFqid=1 than its LSB
-                                                             will effect the FQID MSB, if bitOffsetInFqid=24 than the
-                                                             extracted byte will effect the 8 LSB's of the FQID,
-                                                             if bitOffsetInFqid=31 than the byte's MSB will effect
-                                                             the FQID's LSB; 0 means - no effect on FQID;
-                                                             Note that one, and only one of
-                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
-                                                             extracted byte must effect either FQID or Policer profile).*/
-    uint8_t                         bit_offset_in_plcr_profile;
-                                                        /**< 0-15, Selects which bits of the 8 policer profile id bits to
-                                                             effect using the extracted byte; Assume byte is placed
-                                                             as the 8 MSB's in a 16 bit word where the lower bits
-                                                             are the policer profile id; i.e if bitOffsetInPlcrProfile=1
-                                                             than its LSB will effect the profile MSB, if bitOffsetInFqid=8
-                                                             than the extracted byte will effect the whole policer profile id,
-                                                             if bitOffsetInFqid=15 than the byte's MSB will effect
-                                                             the Policer Profile id's LSB;
-                                                             0 means - no effect on policer profile; Note that one, and only one of
-                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
-                                                             extracted byte must effect either FQID or Policer profile).*/
-} ioc_fm_pcd_kg_extracted_or_params_t;
-
-/**************************************************************************//**
- @Description   A structure for configuring scheme counter
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_scheme_counter_t {
-    bool        update;     /**< FALSE to keep the current counter state
-                                 and continue from that point, TRUE to update/reset
-                                 the counter when the scheme is written. */
-    uint32_t    value;      /**< If update=TRUE, this value will be written into the
-                                 counter; clear this field to reset the counter. */
-} ioc_fm_pcd_kg_scheme_counter_t;
-
-/**************************************************************************//**
- @Description   A structure for defining policer profile parameters as required by keygen
-                (when policer is the next engine after this scheme).
-                (Must match struct t_FmPcdKgPlcrProfile defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_plcr_profile_t {
-    bool                shared_profile;                 /**< TRUE if this profile is shared between ports
-                                                             (i.e. managed by master partition) May not be TRUE
-                                                             if profile is after Coarse Classification*/
-    bool                direct;                         /**< If TRUE, direct_relative_profile_id only selects the profile
-                                                             id, if FALSE fqid_offset_relative_profile_id_base is used
-                                                             together with fqid_offset_shift and num_of_profiles
-                                                             parameters, to define a range of profiles from
-                                                             which the KeyGen result will determine the
-                                                             destination policer profile.  */
-    union {
-        uint16_t        direct_relative_profile_id;     /**< Used if 'direct' is TRUE, to select policer profile.
-                                                             This parameter should indicate the policer profile offset within the port's
-                                                             policer profiles or SHARED window. */
-        struct {
-            uint8_t     fqid_offset_shift;              /**< Shift of KG results without the qid base */
-            uint8_t     fqid_offset_relative_profile_id_base;
-                                                        /**< OR of KG results without the qid base
-                                                             This parameter should indicate the policer profile
-                                                             offset within the port's policer profiles window
-                                                             or SHARED window depends on shared_profile */
-            uint8_t     num_of_profiles;                /**< Range of profiles starting at base */
-        } indirect_profile;                             /**< Indirect profile parameters */
-    } profile_select;                                   /**< Direct/indirect profile selection and parameters */
-} ioc_fm_pcd_kg_plcr_profile_t;
-
-#if DPAA_VERSION >= 11
-/**************************************************************************//**
- @Description   Parameters for configuring a storage profile for a KeyGen scheme.
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_storage_profile_t {
-    bool                direct;                     /**< If TRUE, directRelativeProfileId only selects the
-                                                         profile id;
-                                                         If FALSE, fqidOffsetRelativeProfileIdBase is used
-                                                         together with fqidOffsetShift and numOfProfiles
-                                                         parameters to define a range of profiles from which
-                                                         the KeyGen result will determine the destination
-                                                         storage profile. */
-    union {
-        uint16_t        direct_relative_profileId;    /**< Used when 'direct' is TRUE, to select a storage profile;
-                                                         should indicate the storage profile offset within the
-                                                         port's storage profiles window. */
-        struct {
-            uint8_t     fqid_offset_shift;            /**< Shift of KeyGen results without the FQID base */
-            uint8_t     fqid_offset_relative_profile_id_base;
-                                                    /**< OR of KeyGen results without the FQID base;
-                                                         should indicate the policer profile offset within the
-                                                         port's storage profiles window. */
-            uint8_t     num_of_profiles;              /**< Range of profiles starting at base. */
-        } indirect_profile;                          /**< Indirect profile parameters. */
-    } profile_select;                                /**< Direct/indirect profile selection and parameters. */
-} ioc_fm_pcd_kg_storage_profile_t;
-#endif /* DPAA_VERSION >= 11 */
-
-/**************************************************************************//**
- @Description   Parameters for defining CC as the next engine after KeyGen
-                (Must match struct t_FmPcdKgCc defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_cc_t {
-    void                            *tree_id;           /**< CC Tree id */
-    uint8_t                         grp_id;             /**< CC group id within the CC tree */
-    bool                            plcr_next;          /**< TRUE if after CC, in case of data frame,
-                                                             policing is required. */
-    bool                            bypass_plcr_profile_generation;
-                                                        /**< TRUE to bypass KeyGen policer profile generation;
-                                                             selected profile is the one set at port initialization. */
-    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< Valid only if plcr_next = TRUE and
-                                                             bypass_plcr_profile_generation = FALSE */
-} ioc_fm_pcd_kg_cc_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining initializing a KeyGen scheme
-                (Must match struct t_FmPcdKgSchemeParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_scheme_params_t {
-    bool                                modify;         /**< TRUE to change an existing scheme */
-    union {
-        uint8_t                         relative_scheme_id;
-                                                        /**< if modify=FALSE: partition-relative scheme id */
-        void                            *scheme_id;     /**< if modify=TRUE: the id of an existing scheme */
-    } scm_id;
-    bool                                always_direct;  /**< This scheme is reached only directly, i.e. no need
-                                                             for match vector; KeyGen will ignore it when matching */
-    struct {                                            /**< HL relevant only if always_direct=FALSE */
-        void                            *net_env_id;    /**< The id of the Network Environment as returned
-                                                             by FM_PCD_NetEnvCharacteristicsSet() */
-        uint8_t                         num_of_distinction_units;
-                                                        /**< Number of NetEnv units listed in unit_ids array */
-        uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
-                                                        /**< Indexes as passed to SetNetEnvCharacteristics (?) array */
-    } net_env_params;
-    bool                                use_hash;       /**< use the KG Hash functionality */
-    ioc_fm_pcd_kg_key_extract_and_hash_params_t key_extract_and_hash_params;
-                                                        /**< used only if useHash = TRUE */
-    bool                                bypass_fqid_generation;
-                                                        /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
-                                                             In such a case FQID after KG will be the default FQID
-                                                             defined for the relevant port, or the FQID defined by CC
-                                                             in cases where CC was the previous engine. */
-    uint32_t                            base_fqid;      /**< Base FQID; Relevant only if bypass_fqid_generation = FALSE;
-                                                             If hash is used and an even distribution is expected
-                                                             according to hash_distribution_num_of_fqids, base_fqid must be aligned to
-                                                             hash_distribution_num_of_fqids. */
-    uint8_t                             num_of_used_extracted_ors;
-                                                        /**< Number of FQID masks listed in extracted_ors array*/
-    ioc_fm_pcd_kg_extracted_or_params_t extracted_ors[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
-                                                        /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
-                                                             registers are shared between qid_masks
-                                                             functionality and some of the extraction
-                                                             actions; Normally only some will be used
-                                                             for qid_mask. Driver will return error if
-                                                             resource is full at initialization time. */
-#if DPAA_VERSION >= 11
-    bool                                override_storage_profile;
-                                                        /**< TRUE if KeyGen override previously decided storage profile */
-    ioc_fm_pcd_kg_storage_profile_t     storage_profile;/**< Used when override_storage_profile=TRUE */
-#endif /* DPAA_VERSION >= 11 */
-    ioc_fm_pcd_engine                   next_engine;     /**< may be BMI, PLCR or CC */
-    union {                                              /**< depends on nextEngine */
-        ioc_fm_pcd_done_action          done_action;     /**< Used when next engine is BMI (done) */
-        ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;    /**< Used when next engine is PLCR */
-        ioc_fm_pcd_kg_cc_t              cc;              /**< Used when next engine is CC */
-    } kg_next_engine_params;
-    ioc_fm_pcd_kg_scheme_counter_t      scheme_counter;  /**< A structure of parameters for updating
-                                                              the scheme counter */
-    void                                *id;             /**< Returns the scheme Id to be used */
-} ioc_fm_pcd_kg_scheme_params_t;
-
-/**************************************************************************//**
- @Collection
-*//***************************************************************************/
-#define IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR      10  /* Maximal supported number of frame length ranges */
-#define IOC_FM_PCD_CC_STATS_FLR_SIZE            2   /* Size in bytes of a frame length range limit */
-#define IOC_FM_PCD_CC_STATS_FLR_COUNT_SIZE      4   /* Size in bytes of a frame length range counter */
-/* @} */
-
-/**************************************************************************//**
- @Description   Parameters for defining CC as the next engine after a CC node.
-                (Must match struct t_FmPcdCcNextCcParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_cc_params_t {
-    void        *cc_node_id;                             /**< Id of the next CC node */
-} ioc_fm_pcd_cc_next_cc_params_t;
-
-#if DPAA_VERSION >= 11
-/**************************************************************************//**
- @Description   A structure for defining Frame Replicator as the next engine after a CC node.
-                (Must match struct t_FmPcdCcNextFrParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_fr_params_t {
-    void*       frm_replic_id;              /**< The id of the next frame replicator group */
-} ioc_fm_pcd_cc_next_fr_params_t;
-#endif /* DPAA_VERSION >= 11 */
-
-/**************************************************************************//**
- @Description   A structure for defining PLCR params when PLCR is the
-                next engine after a CC node
-                (Must match struct t_FmPcdCcNextPlcrParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
-    bool        override_params;            /**< TRUE if CC override previously decided parameters*/
-    bool        shared_profile;             /**< Relevant only if overrideParams=TRUE:
-                                                TRUE if this profile is shared between ports */
-    uint16_t    new_relative_profile_id;    /**< Relevant only if overrideParams=TRUE:
-                                                (otherwise profile id is taken from keygen);
-                                                This parameter should indicate the policer
-                                                profile offset within the port's
-                                                policer profiles or from SHARED window.*/
-    uint32_t    new_fqid;                   /**< Relevant only if overrideParams=TRUE:
-                                                FQID for enquing the frame;
-                                                In earlier chips  if policer next engine is KEYGEN,
-                                                this parameter can be 0, because the KEYGEN always decides
-                                                the enqueue FQID.*/
-#if DPAA_VERSION >= 11
-    uint8_t     new_relative_storage_profile_id;
-                                            /**< Indicates the relative storage profile offset within
-                                                 the port's storage profiles window;
-                                                 Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 11 */
-} ioc_fm_pcd_cc_next_plcr_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining enqueue params when BMI is the
-                next engine after a CC node
-                (Must match struct t_FmPcdCcNextEnqueueParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
-    ioc_fm_pcd_done_action  action;         /**< Action - when next engine is BMI (done) */
-    bool                    override_fqid;  /**< TRUE if CC override previously decided fqid and vspid,
-                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME */
-    uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
-                                                 (otherwise FQID is taken from KeyGen),
-                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
-#if DPAA_VERSION >= 11
-    uint8_t                 new_relative_storage_profile_id;
-                                            /**< Valid if override_fqid=TRUE, Indicates the relative virtual
-                                                 storage profile offset within the port's storage profiles
-                                                 window; Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 11 */
-
-} ioc_fm_pcd_cc_next_enqueue_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining KG params when KG is the next engine after a CC node
-                (Must match struct t_FmPcdCcNextKgParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_kg_params_t {
-    bool       override_fqid;               /**< TRUE if CC override previously decided fqid and vspid,
-                                                 Note - this parameters are irrelevant for earlier chips */
-    uint32_t   new_fqid;                    /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
-                                                 (otherwise FQID is taken from KeyGen),
-                                                 Note - this parameters are irrelevant for earlier chips */
-#if DPAA_VERSION >= 11
-    uint8_t              new_relative_storage_profile_id;
-                                            /**< Valid if override_fqid=TRUE, Indicates the relative virtual
-                                                 storage profile offset within the port's storage profiles
-                                                 window; Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 11 */
-    void       *p_direct_scheme;            /**< Direct scheme id to go to. */
-} ioc_fm_pcd_cc_next_kg_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining the next engine after a CC node.
-                (Must match struct t_FmPcdCcNextEngineParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_engine_params_t {
-    ioc_fm_pcd_engine                           next_engine;    /**< User has to initialize parameters
-                                                                     according to nextEngine definition */
-    union {
-            ioc_fm_pcd_cc_next_cc_params_t      cc_params;      /**< Parameters in case next engine is CC */
-            ioc_fm_pcd_cc_next_plcr_params_t    plcr_params;    /**< Parameters in case next engine is PLCR */
-            ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
-            ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
-#if DPAA_VERSION >= 11
-            ioc_fm_pcd_cc_next_fr_params_t      fr_params;      /**< Parameters in case next engine is FR */
-#endif /* DPAA_VERSION >= 11 */
-    } params;                                                   /**< Union used for all the next-engine parameters options */
-    void                                        *manip_id;      /**< Handle to Manipulation object.
-                                                                     Relevant if next engine is of type result
-                                                                     (e_IOC_FM_PCD_PLCR, e_IOC_FM_PCD_KG, e_IOC_FM_PCD_DONE) */
-    bool                                        statistics_en;  /**< If TRUE, statistics counters are incremented
-                                                                      for each frame passing through this
-                                                                      Coarse Classification entry. */
-} ioc_fm_pcd_cc_next_engine_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining a single CC key
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_key_params_t {
-    uint8_t                 *p_key;         /**< pointer to the key of the size defined in key_size */
-    uint8_t                 *p_mask;        /**< pointer to the Mask per key of the size defined
-                                                 in keySize. p_key and p_mask (if defined) has to be
-                                                 of the same size defined in the key_size */
-    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
-                                            /**< parameters for the next for the defined Key in p_key */
-
-} ioc_fm_pcd_cc_key_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining CC keys parameters
-                The driver supports two methods for CC node allocation: dynamic and static.
-                Static mode was created in order to prevent runtime alloc/free
-                of FMan memory (MURAM), which may cause fragmentation; in this mode,
-                the driver automatically allocates the memory according to
-                'max_num_of_keys' parameter. The driver calculates the maximal memory
-                size that may be used for this CC-Node taking into consideration
-                'mask_support' and 'statistics_mode' parameters.
-                When 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
-                parameters of this node, 'max_num_of_keys' must be equal to 'num_of_keys'.
-                In dynamic mode, 'max_num_of_keys' must be zero. At initialization,
-                all required structures are allocated according to 'num_of_keys'
-                parameter. During runtime modification, these structures are
-                re-allocated according to the updated number of keys.
-
-                Please note that 'action' and 'ic_indx_mask' mentioned in the
-                specific parameter explanations are passed in the extraction
-                parameters of the node (fields of extractccparams.extractnonhdr).
-*//***************************************************************************/
-typedef struct ioc_keys_params_t {
-    uint16_t                    max_num_of_keys;/**< Maximum number of keys that will (ever) be used in this CC-Node;
-                                                     A value of zero may be used for dynamic memory allocation. */
-    bool                        mask_support;   /**< This parameter is relevant only if a node is initialized with
-                                                     action = e_IOC_FM_PCD_ACTION_EXACT_MATCH and max_num_of_keys > 0;
-                                                     Should be TRUE to reserve table memory for key masks, even if
-                                                     initial keys do not contain masks, or if the node was initialized
-                                                     as 'empty' (without keys); this will allow user to add keys with
-                                                     masks at runtime. */
-    ioc_fm_pcd_cc_stats_mode    statistics_mode;/**< Determines the supported statistics mode for all node's keys.
-                                                     To enable statistics gathering, statistics should be enabled per
-                                                     every key, using 'statistics_en' in next engine parameters structure
-                                                     of that key;
-                                                     If 'max_num_of_keys' is set, all required structures will be
-                                                     preallocated for all keys. */
-#if (DPAA_VERSION >= 11)
-    uint16_t                    frame_length_ranges[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
-                                                /**< Relevant only for 'RMON' statistics mode
-                                                     (this feature is supported only on B4860 device);
-                                                     Holds a list of programmable thresholds. For each received frame,
-                                                     its length in bytes is examined against these range thresholds and
-                                                     the appropriate counter is incremented by 1. For example, to belong
-                                                     to range i, the following should hold:
-                                                     range i-1 threshold < frame length <= range i threshold
-                                                     Each range threshold must be larger then its preceding range
-                                                     threshold. Last range threshold must be 0xFFFF. */
-#endif /* (DPAA_VERSION >= 11) */
-    uint16_t                    num_of_keys;    /**< Number of initial keys;
-                                                     Note that in case of 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP,
-                                                     this field should be power-of-2 of the number of bits that are
-                                                     set in 'ic_indx_mask'. */
-    uint8_t                     key_size;       /**< Size of key - for extraction of type FULL_FIELD, 'key_size' has
-                                                     to be the standard size of the selected key; For other extraction
-                                                     types, 'key_size' has to be as size of extraction; When 'action' =
-                                                     e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
-    ioc_fm_pcd_cc_key_params_t  key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
-                                                /**< An array with 'num_of_keys' entries, each entry specifies the
-                                                     corresponding key parameters;
-                                                     When 'action' = e_IOC_FM_PCD_ACTION_EXACT_MATCH, this value must not
-                                                     exceed 255 (IOC_FM_PCD_MAX_NUM_OF_KEYS-1) as the last entry is saved
-                                                     for the 'miss' entry. */
-    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
-                                                /**< Parameters for defining the next engine when a key is not matched;
-                                                     Not relevant if action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP. */
-} ioc_keys_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining a CC node
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_params_t {
-    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< Extraction parameters */
-    ioc_keys_params_t                   keys_params;        /**< Keys definition matching the selected extraction */
-    void                                *id;                /**< Output parameter; returns the CC node Id to be used */
-} ioc_fm_pcd_cc_node_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining a hash table
-                (Must match struct t_FmPcdHashTableParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_hash_table_params_t {
-    uint16_t                    max_num_of_keys;            /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
-    ioc_fm_pcd_cc_stats_mode    statistics_mode;            /**< If not e_IOC_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
-                                                                 requested statistics mode will be allocated according to max_num_of_keys. */
-    uint16_t                    hash_res_mask;              /**< Mask that will be used on the hash-result;
-                                                                 The number-of-sets for this hash will be calculated
-                                                                 as (2^(number of bits set in 'hash_res_mask'));
-                                                                 The 4 lower bits must be cleared. */
-    uint8_t                     hash_shift;                 /**< Byte offset from the beginning of the KeyGen hash result to the
-                                                                 2-bytes to be used as hash index. */
-    uint8_t                     match_key_size;             /**< Size of the exact match keys held by the hash buckets */
-
-    ioc_fm_pcd_cc_next_engine_params_t   cc_next_engine_params_for_miss;
-                                                            /**< Parameters for defining the next engine when a key is not matched */
-    void                        *id;
-} ioc_fm_pcd_hash_table_params_t;
-
-/**************************************************************************//**
- @Description   A structure with the arguments for the FM_PCD_HashTableAddKey ioctl() call
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_hash_table_add_key_params_t {
-    void                        *p_hash_tbl;
-    uint8_t                     key_size;
-    ioc_fm_pcd_cc_key_params_t  key_params;
-} ioc_fm_pcd_hash_table_add_key_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining a CC tree group.
-
-                This structure defines a CC group in terms of NetEnv units
-                and the action to be taken in each case. The unit_ids list must
-                be given in order from low to high indices.
-
-                ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
-                structures where each defines the next action to be taken for
-                each units combination. for example:
-                num_of_distinction_units = 2
-                unit_ids = {1,3}
-                next_engine_per_entries_in_grp[0] = ioc_fm_pcd_cc_next_engine_params_t for the case that
-                                                    unit 1 - not found; unit 3 - not found;
-                next_engine_per_entries_in_grp[1] = ioc_fm_pcd_cc_next_engine_params_t for the case that
-                                                    unit 1 - not found; unit 3 - found;
-                next_engine_per_entries_in_grp[2] = ioc_fm_pcd_cc_next_engine_params_t for the case that
-                                                    unit 1 - found; unit 3 - not found;
-                next_engine_per_entries_in_grp[3] = ioc_fm_pcd_cc_next_engine_params_t for the case that
-                                                    unit 1 - found; unit 3 - found;
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_grp_params_t {
-    uint8_t                             num_of_distinction_units;   /**< Up to 4 */
-    uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
-                                                                    /**< Indexes of the units as defined in
-                                                                         FM_PCD_NetEnvCharacteristicsSet() */
-    ioc_fm_pcd_cc_next_engine_params_t  next_engine_per_entries_in_grp[IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
-                                                                    /**< Maximum entries per group is 16 */
-} ioc_fm_pcd_cc_grp_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining the CC tree groups
-                (Must match struct t_FmPcdCcTreeParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_tree_params_t {
-        void                            *net_env_id;    /**< Id of the Network Environment as returned
-                                                             by FM_PCD_NetEnvCharacteristicsSet() */
-        uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
-        ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
-                                                        /**< Parameters for each group. */
-        void                            *id;            /**< Output parameter; Returns the tree Id to be used */
-} ioc_fm_pcd_cc_tree_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining policer byte rate
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
-    ioc_fm_pcd_plcr_frame_length_select     frame_length_selection;     /**< Frame length selection */
-    ioc_fm_pcd_plcr_roll_back_frame_select  roll_back_frame_selection;  /**< relevant option only e_IOC_FM_PCD_PLCR_L2_FRM_LEN,
-                                                                             e_IOC_FM_PCD_PLCR_FULL_FRM_LEN */
-} ioc_fm_pcd_plcr_byte_rate_mode_param_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining the policer profile (based on
-                RFC-2698 or RFC-4115 attributes).
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
-    ioc_fm_pcd_plcr_rate_mode               rate_mode;                      /**< Byte / Packet */
-    ioc_fm_pcd_plcr_byte_rate_mode_param_t  byte_mode_param;                /**< Valid for Byte NULL for Packet */
-    uint32_t                                comitted_info_rate;             /**< KBits/Sec or Packets/Sec */
-    uint32_t                                comitted_burst_size;            /**< KBits or Packets */
-    uint32_t                                peak_or_accessive_info_rate;    /**< KBits/Sec or Packets/Sec */
-    uint32_t                                peak_or_accessive_burst_size;   /**< KBits or Packets */
-} ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining the next engine after policer
-*//***************************************************************************/
-typedef union ioc_fm_pcd_plcr_next_engine_params_u {
-        ioc_fm_pcd_done_action     action;              /**< Action - when next engine is BMI (done) */
-        void                       *p_profile;          /**< Policer profile handle -  used when next engine
-                                                             is PLCR, must be a SHARED profile */
-        void                       *p_direct_scheme;    /**< Direct scheme select - when next engine is Keygen */
-} ioc_fm_pcd_plcr_next_engine_params_u;
-
-typedef struct ioc_fm_pcd_port_params_t {
-    ioc_fm_port_type                    port_type;          /**< Type of port for this profile */
-    uint8_t                             port_id;            /**< FM-Port id of port for this profile */
-} ioc_fm_pcd_port_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining the policer profile entry
-                (Must match struct t_FmPcdPlcrProfileParams defined in fm_pcd_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_plcr_profile_params_t {
-    bool                                        modify;                     /**< TRUE to change an existing profile */
-    union {
-        struct {
-            ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
-            ioc_fm_pcd_port_params_t            *p_fm_port;                 /**< Relevant for per-port profiles only */
-            uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
-        } new_params;                                                       /**< Use it when modify = FALSE */
-        void                                    *p_profile;                 /**< A handle to a profile - use it when modify=TRUE */
-    } profile_select;
-    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algorithm PASS_THROUGH, RFC_2698, RFC_4115 */
-    ioc_fm_pcd_plcr_color_mode                  color_mode;                 /**< COLOR_BLIND, COLOR_AWARE */
-
-    union {
-        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode; the policer will re-color
-                                                                                 any incoming packet with the default value. */
-        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes; the profile response to a
-                                                                                 pre-color value of 2'b11. */
-    } color;
-
-    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 parameters */
-
-    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Next engine for green-colored frames */
-    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Next engine parameters for green-colored frames  */
-
-    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Next engine for yellow-colored frames */
-    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Next engine parameters for yellow-colored frames  */
-
-    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Next engine for red-colored frames */
-    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Next engine parameters for red-colored frames  */
-
-    bool                                        trap_profile_on_flow_A;     /**< Obsolete - do not use */
-    bool                                        trap_profile_on_flow_B;     /**< Obsolete - do not use */
-    bool                                        trap_profile_on_flow_C;     /**< Obsolete - do not use */
-
-    void                                        *id;                        /**< output parameter; Returns the profile Id to be used */
-} ioc_fm_pcd_plcr_profile_params_t;
-
-/**************************************************************************//**
- @Description   A structure for modifying CC tree next engine
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
-    void                                *id;                /**< CC tree Id to be used */
-    uint8_t                             grp_indx;           /**< A Group index in the tree */
-    uint8_t                             indx;               /**< Entry index in the group defined by grp_index */
-    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
-                                                            /**< Parameters for the next for the defined Key in the p_Key */
-} ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
-
-/**************************************************************************//**
- @Description   A structure for modifying CC node next engine
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
-    void                                *id;                /**< CC node Id to be used */
-    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
-                                                                 NOTE: This parameter is IGNORED for miss-key!  */
-    uint8_t                             key_size;           /**< Key size of added key */
-    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
-                                                            /**< parameters for the next for the defined Key in the p_Key */
-} ioc_fm_pcd_cc_node_modify_next_engine_params_t;
-
-/**************************************************************************//**
- @Description   A structure for remove CC node key
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
-    void                                *id;                /**< CC node Id to be used */
-    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
-                                                                 NOTE: This parameter is IGNORED for miss-key!  */
-} ioc_fm_pcd_cc_node_remove_key_params_t;
-
-/**************************************************************************//**
- @Description   A structure for modifying CC node key and next engine
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
-    void                                *id;                /**< CC node Id to be used */
-    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
-                                                                 NOTE: This parameter is IGNORED for miss-key!  */
-    uint8_t                             key_size;           /**< Key size of added key */
-    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
-                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
-} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
-
-/**************************************************************************//**
- @Description   A structure for modifying CC node key
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
-    void                                *id;                /**< CC node Id to be used */
-    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
-                                                                 NOTE: This parameter is IGNORED for miss-key!  */
-    uint8_t                             key_size;           /**< Key size of added key */
-    uint8_t                             *p_key;             /**< Pointer to the key of the size defined in key_size */
-    uint8_t                             *p_mask;            /**< Pointer to the Mask per key of the size defined
-                                                                 in keySize. p_Key and p_Mask (if defined) have to be
-                                                                 of the same size as defined in the key_size */
-} ioc_fm_pcd_cc_node_modify_key_params_t;
-
-/**************************************************************************//**
- @Description   A structure with the arguments for the FM_PCD_HashTableRemoveKey ioctl() call
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
-    void       *p_hash_tbl;     /**< The id of the hash table */
-    uint8_t     key_size;       /**< The size of the key to remove */
-    uint8_t    *p_key;          /**< Pointer to the key to remove */
-} ioc_fm_pcd_hash_table_remove_key_params_t;
-
-#ifdef FM_CAPWAP_SUPPORT
-/**************************************************************************//**
- @Description   Parameters for selecting a location for requested manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_manip_hdr_info_t {
-    ioc_net_header_type                 hdr;            /**< Header selection */
-    ioc_fm_pcd_hdr_index                hdr_index;      /**< Relevant only for MPLS, VLAN and tunneled IP. Otherwise should be cleared. */
-    bool                                by_field;       /**< TRUE if the location of manipulation is according to some field in the specific header*/
-    ioc_fm_pcd_fields_u                 full_field;     /**< Relevant only when by_field = TRUE: Extract field */
-} ioc_fm_manip_hdr_info_t;
-#endif /* FM_CAPWAP_SUPPORT */
-
-/**************************************************************************//**
- @Description   Parameters for defining header removal by header type
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t {
-    ioc_fm_pcd_manip_hdr_rmv_by_hdr_type        type;  /**< Selection of header removal location */
-    union {
-#ifdef FM_CAPWAP_SUPPORT
-        struct {
-            bool                                include;/**< If FALSE, remove until the specified header (not including the header);
-                                                             If TRUE, remove also the specified header. */
-            ioc_fm_manip_hdr_info_t             hdr_info;
-        } from_start_by_hdr;                           /**< Relevant when type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
-#endif /* FM_CAPWAP_SUPPORT */
-        ioc_fm_pcd_manip_hdr_rmv_specific_l2    specific_l2;/**< Relevant when type = e_IOC_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
-                                                                 Defines which L2 headers to remove. */
-    } u;
-} ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for configuring IP fragmentation manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
-    uint16_t                    size_for_fragmentation;     /**< If length of the frame is greater than this value,
-                                                                 IP fragmentation will be executed.*/
-#if DPAA_VERSION == 10
-    uint8_t                     scratch_bpid;               /**< Absolute buffer pool id according to BM configuration.*/
-#endif /* DPAA_VERSION == 10 */
-    bool                        sg_bpid_en;                 /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
-                                                                 If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
-                                                                 received frame's buffer. */
-    uint8_t                     sg_bpid;                    /**< Scatter/Gather buffer pool id;
-                                                                 This parameter is relevant when 'sg_bpid_en=TRUE';
-                                                                 Same LIODN number is used for these buffers as for the received frames buffers, so buffers
-                                                                 of this pool need to be allocated in the same memory area as the received buffers.
-                                                                 If the received buffers arrive from different sources, the Scatter/Gather BP id should be
-                                                                 mutual to all these sources. */
-    ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;    /**< Dont Fragment Action - If an IP packet is larger
-                                                                 than MTU and its DF bit is set, then this field will
-                                                                 determine the action to be taken.*/
-} ioc_fm_pcd_manip_frag_ip_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for configuring IP reassembly manipulation.
-
-                This is a common structure for both IPv4 and IPv6 reassembly
-                manipulation. For reassembly of both IPv4 and IPv6, make sure to
-                set the 'hdr' field in ioc_fm_pcd_manip_reassem_params_t to IOC_HEADER_TYPE_IPv6.
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_reassem_ip_params_t {
-    uint8_t                         relative_scheme_id[2];    /**< Partition relative scheme id:
-                                                                 relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
-                                                                 relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
-                                                                 NOTE: The following comment is relevant only for FMAN v2 devices:
-                                                                 Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
-                                                                 the user schemes id to ensure that the reassembly's schemes will be first match.
-                                                                 The remaining schemes, if defined, should have higher relative scheme ID. */
-#if DPAA_VERSION >= 11
-    uint32_t                        non_consistent_sp_fqid; /**< In case that other fragments of the frame corresponds to different storage
-                                                                 profile than the opening fragment (Non-Consistent-SP state)
-                                                                 then one of two possible scenarios occurs:
-                                                                 if 'nonConsistentSpFqid != 0', the reassembled frame will be enqueued to
-                                                                 this fqid, otherwise a 'Non Consistent SP' bit will be set in the FD[status].*/
-#else
-    uint8_t                         sg_bpid;                /**< Buffer pool id for the S/G frame created by the reassembly process */
-#endif /* DPAA_VERSION >= 11 */
-    uint8_t                         data_mem_id;            /**< Memory partition ID for the IPR's external tables structure */
-    uint16_t                        data_liodn_offset;      /**< LIODN offset for access the IPR's external tables structure. */
-    uint16_t                        min_frag_size[2];       /**< Minimum fragment size:
-                                                                 minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
-    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry[2];
-                                                            /**< Number of frames per hash entry needed for reassembly process:
-                                                                 numOfFramesPerHashEntry[0] - for ipv4 (max value is e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH);
-                                                                 numOfFramesPerHashEntry[1] - for ipv6 (max value is e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH). */
-    uint16_t                        max_num_frames_in_process;/**< Number of frames which can be processed by Reassembly in the same time;
-                                                                 Must be power of 2;
-                                                                 In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
-                                                                 In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
-    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;  /**< Expiration delay initialized by Reassembly process */
-    uint32_t                        fqid_for_time_out_frames;/**< FQID in which time out frames will enqueue during Time Out Process  */
-    uint32_t                        timeout_threshold_for_reassm_process;
-                                                            /**< Represents the time interval in microseconds which defines
-                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
-} ioc_fm_pcd_manip_reassem_ip_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining IPSEC manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_special_offload_ipsec_params_t {
-    bool    decryption;                     /**< TRUE if being used in decryption direction;
-                                                 FALSE if being used in encryption direction. */
-    bool    ecn_copy;                       /**< TRUE to copy the ECN bits from inner/outer to outer/inner
-                                                 (direction depends on the 'decryption' field). */
-    bool    dscp_copy;                      /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
-                                                 (direction depends on the 'decryption' field). */
-    bool    variable_ip_hdr_len;            /**< TRUE for supporting variable IP header length in decryption. */
-    bool    variable_ip_version;            /**< TRUE for supporting both IP version on the same SA in encryption */
-    uint8_t outer_ip_hdr_len;               /**< If 'variable_ip_version == TRUE' than this field must be set to non-zero value;
-                                                 It is specifies the length of the outer IP header that was configured in the
-                                                 corresponding SA. */
-} ioc_fm_pcd_manip_special_offload_ipsec_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining special offload manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_special_offload_params_t {
-    ioc_fm_pcd_manip_special_offload_type               type;       /**< Type of special offload manipulation */
-    union
-    {
-        ioc_fm_pcd_manip_special_offload_ipsec_params_t ipsec;      /**< Parameters for IPSec; Relevant when
-                                                                         type = e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
-    } u;
-} ioc_fm_pcd_manip_special_offload_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining generic removal manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_rmv_generic_params_t {
-    uint8_t                         offset;         /**< Offset from beginning of header to the start
-                                                         location of the removal */
-    uint8_t                         size;           /**< Size of removed section */
-} ioc_fm_pcd_manip_hdr_rmv_generic_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining generic insertion manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_insrt_generic_params_t {
-    uint8_t                         offset;         /**< Offset from beginning of header to the start
-                                                         location of the insertion */
-    uint8_t                         size;           /**< Size of inserted section */
-    bool                            replace;        /**< TRUE to override (replace) existing data at
-                                                         'offset', FALSE to insert */
-    uint8_t                         *p_data;        /**< Pointer to data to be inserted */
-} ioc_fm_pcd_manip_hdr_insrt_generic_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation VLAN DSCP To Vpri translation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t {
-    uint8_t                         dscp_to_vpri_table[IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS];
-                                                    /**< A table of VPri values for each DSCP value;
-                                                         The index is the D_SCP value (0-0x3F) and the
-                                                         value is the corresponding VPRI (0-15). */
-    uint8_t                         vpri_def_val;   /**< 0-7, Relevant only if if update_type =
-                                                         e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN,
-                                                         this field is the Q Tag default value if the
-                                                         IP header is not found. */
-} ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation VLAN fields updates
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_t {
-    ioc_fm_pcd_manip_hdr_field_update_vlan  update_type;    /**< Selects VLAN update type */
-    union {
-        uint8_t                                     vpri;   /**< 0-7, Relevant only if If update_type =
-                                                                 e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_PRI, this
-                                                                 is the new VLAN pri. */
-        ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t    dscp_to_vpri;
-                                                            /**<  Parameters structure, Relevant only if update_type =
-                                                                  e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN. */
-    } u;
-} ioc_fm_pcd_manip_hdr_field_update_vlan_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation IPV4 fields updates
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv4_t {
-    ioc_ipv4_hdr_manip_update_flags_t       valid_updates;  /**< ORed flag, selecting the required updates */
-    uint8_t                                 tos;            /**< 8 bit New TOS; Relevant if valid_updates contains
-                                                                 IOC_HDR_MANIP_IPV4_TOS */
-    uint16_t                                id;             /**< 16 bit New IP ID; Relevant only if valid_updates
-                                                                 contains IOC_HDR_MANIP_IPV4_ID */
-    uint32_t                                src;            /**< 32 bit New IP SRC; Relevant only if valid_updates
-                                                                 contains IOC_HDR_MANIP_IPV4_SRC */
-    uint32_t                                dst;            /**< 32 bit New IP DST; Relevant only if valid_updates
-                                                                 contains IOC_HDR_MANIP_IPV4_DST */
-} ioc_fm_pcd_manip_hdr_field_update_ipv4_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation IPV6 fields updates
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv6_t {
-    ioc_ipv6_hdr_manip_update_flags_t       valid_updates;  /**< ORed flag, selecting the required updates */
-    uint8_t                                 traffic_class;  /**< 8 bit New Traffic Class; Relevant if valid_updates contains
-                                                                 IOC_HDR_MANIP_IPV6_TC */
-    uint8_t                                 src[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
-                                                            /**< 16 byte new IP SRC; Relevant only if valid_updates
-                                                                 contains IOC_HDR_MANIP_IPV6_SRC */
-    uint8_t                                 dst[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
-                                                            /**< 16 byte new IP DST; Relevant only if valid_updates
-                                                                 contains IOC_HDR_MANIP_IPV6_DST */
-} ioc_fm_pcd_manip_hdr_field_update_ipv6_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation TCP/UDP fields updates
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t {
-    ioc_tcp_udp_hdr_manip_update_flags_t    valid_updates;  /**< ORed flag, selecting the required updates */
-    uint16_t                                src;            /**< 16 bit New TCP/UDP SRC; Relevant only if valid_updates
-                                                                 contains IOC_HDR_MANIP_TCP_UDP_SRC */
-    uint16_t                                dst;            /**< 16 bit New TCP/UDP DST; Relevant only if valid_updates
-                                                                 contains IOC_HDR_MANIP_TCP_UDP_DST */
-} ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation fields updates
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_field_update_params_t {
-    ioc_fm_pcd_manip_hdr_field_update_type          type;   /**< Type of header field update manipulation */
-    union {
-        ioc_fm_pcd_manip_hdr_field_update_vlan_t    vlan;   /**< Parameters for VLAN update. Relevant when
-                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN */
-        ioc_fm_pcd_manip_hdr_field_update_ipv4_t    ipv4;   /**< Parameters for IPv4 update. Relevant when
-                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4 */
-        ioc_fm_pcd_manip_hdr_field_update_ipv6_t    ipv6;   /**< Parameters for IPv6 update. Relevant when
-                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6 */
-        ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t tcp_udp;/**< Parameters for TCP/UDP update. Relevant when
-                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP */
-    } u;
-} ioc_fm_pcd_manip_hdr_field_update_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining custom header manipulation for IP replacement
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t {
-    ioc_fm_pcd_manip_hdr_custom_ip_replace  replace_type;   /**< Selects replace update type */
-    bool                                    dec_ttl_hl;     /**< Decrement TTL (IPV4) or Hop limit (IPV6) by 1 */
-    bool                                    update_ipv4_id; /**< Relevant when replace_type =
-                                                                 e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4 */
-    uint16_t                                id;             /**< 16 bit New IP ID; Relevant only if
-                                                                 update_ipv4_id = TRUE */
-    uint8_t                                 hdr_size;       /**< The size of the new IP header */
-    uint8_t                                 hdr[IOC_FM_PCD_MANIP_MAX_HDR_SIZE];
-                                                            /**< The new IP header */
-} ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining custom header manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_custom_params_t {
-    ioc_fm_pcd_manip_hdr_custom_type                type;   /**< Type of header field update manipulation */
-    union {
-        ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t    ip_hdr_replace;
-                                                            /**< Parameters IP header replacement */
-    } u;
-} ioc_fm_pcd_manip_hdr_custom_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining specific L2 insertion manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
-    ioc_fm_pcd_manip_hdr_insrt_specific_l2  specific_l2;    /**< Selects which L2 headers to insert */
-    bool                                    update;         /**< TRUE to update MPLS header */
-    uint8_t                                 size;           /**< size of inserted section */
-    uint8_t                                *p_data;         /**< data to be inserted */
-} ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header insertion manipulation by header type
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
-    ioc_fm_pcd_manip_hdr_insrt_by_hdr_type          type;   /**< Selects manipulation type */
-    union {
-       ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t  specific_l2_params;
-                                                            /**< Used when type = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
-                                                                 Selects which L2 headers to remove */
-    } u;
-} ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header insertion manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_insrt_params_t {
-    ioc_fm_pcd_manip_hdr_insrt_type                     type;   /**< Type of insertion manipulation */
-    union {
-        ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t      by_hdr; /**< Parameters for defining header insertion manipulation by header type,
-                                                                     relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR */
-        ioc_fm_pcd_manip_hdr_insrt_generic_params_t     generic;/**< Parameters for defining generic header insertion manipulation,
-                                                                     relevant if type = e_IOC_FM_PCD_MANIP_INSRT_GENERIC */
-#ifdef FM_CAPWAP_SUPPORT
-        ioc_fm_pcd_manip_hdr_insrt_by_template_params_t by_template;
-                                                                /**< Parameters for defining header insertion manipulation by template,
-                                                                     relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
-#endif /* FM_CAPWAP_SUPPORT */
-    } u;
-} ioc_fm_pcd_manip_hdr_insrt_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header removal manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_rmv_params_t {
-    ioc_fm_pcd_manip_hdr_rmv_type                  type;       /**< Type of header removal manipulation */
-    union {
-        ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t   by_hdr;     /**< Parameters for defining header removal manipulation by header type,
-                                                                    relevant if type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR */
-        ioc_fm_pcd_manip_hdr_rmv_generic_params_t  generic;    /**< Parameters for defining generic header removal manipulation,
-                                                                    relevant if type = e_IOC_FM_PCD_MANIP_RMV_GENERIC */
-    } u;
-} ioc_fm_pcd_manip_hdr_rmv_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining header manipulation node
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_hdr_params_t {
-    bool                                        rmv;                  /**< TRUE, to define removal manipulation */
-    ioc_fm_pcd_manip_hdr_rmv_params_t           rmv_params;           /**< Parameters for removal manipulation, relevant if 'rmv' = TRUE */
-
-    bool                                        insrt;                /**< TRUE, to define insertion manipulation */
-    ioc_fm_pcd_manip_hdr_insrt_params_t         insrt_params;         /**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
-
-    bool                                        field_update;         /**< TRUE, to define field update manipulation */
-    ioc_fm_pcd_manip_hdr_field_update_params_t  field_update_params;  /**< Parameters for field update manipulation, relevant if 'fieldUpdate' = TRUE */
-
-    bool                                        custom;               /**< TRUE, to define custom manipulation */
-    ioc_fm_pcd_manip_hdr_custom_params_t        custom_params;        /**< Parameters for custom manipulation, relevant if 'custom' = TRUE */
-
-    bool                                        dont_parse_after_manip;/**< FALSE to activate the parser a second time after
-                                                                            completing the manipulation on the frame */
-} ioc_fm_pcd_manip_hdr_params_t;
-
-
-/**************************************************************************//**
- @Description   structure for defining fragmentation manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_frag_params_t {
-    ioc_net_header_type                     hdr;            /**< Header selection */
-    union {
-        ioc_fm_pcd_manip_frag_ip_params_t   ip_frag;        /**< Parameters for defining IP fragmentation,
-                                                                 relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
-    } u;
-} ioc_fm_pcd_manip_frag_params_t;
-
-/**************************************************************************//**
- @Description   structure for defining reassemble manipulation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_reassem_params_t {
-    ioc_net_header_type                         hdr;        /**< Header selection */
-    union {
-        ioc_fm_pcd_manip_reassem_ip_params_t    ip_reassem; /**< Parameters for defining IP reassembly,
-                                                                 relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
-    } u;
-} ioc_fm_pcd_manip_reassem_params_t;
-
-/**************************************************************************//**
- @Description   Parameters for defining a manipulation node
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_params_t {
-    ioc_fm_pcd_manip_type                           type;   /**< Selects type of manipulation node */
-    union {
-        ioc_fm_pcd_manip_hdr_params_t               hdr;    /**< Parameters for defining header manipulation node */
-        ioc_fm_pcd_manip_reassem_params_t           reassem;/**< Parameters for defining reassembly manipulation node */
-        ioc_fm_pcd_manip_frag_params_t              frag;   /**< Parameters for defining fragmentation manipulation node */
-        ioc_fm_pcd_manip_special_offload_params_t   special_offload;/**< Parameters for defining special offload manipulation node */
-    } u;
-    void                                            *p_next_manip;/**< Handle to another (previously defined) manipulation node;
-                                                                 Allows concatenation of manipulation actions
-                                                                 This parameter is optional and may be NULL. */
-#ifdef FM_CAPWAP_SUPPORT
-#error "FM_CAPWAP_SUPPORT feature not supported!"
-    bool                                            frag_or_reasm;/**< TRUE, if defined fragmentation/reassembly manipulation */
-    ioc_fm_pcd_manip_frag_or_reasm_params_t         frag_or_reasm_params;/**< Parameters for fragmentation/reassembly manipulation,
-                                                                            relevant if frag_or_reasm = TRUE */
-#endif /* FM_CAPWAP_SUPPORT */
-    void                                           *id;
-} ioc_fm_pcd_manip_params_t;
-
-/**************************************************************************//**
- @Description   Structure for retrieving IP reassembly statistics
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_reassem_ip_stats_t {
-    /* common counters for both IPv4 and IPv6 */
-    uint32_t    timeout;                        /**< Counts the number of TimeOut occurrences */
-    uint32_t    rfd_pool_busy;                    /**< Counts the number of failed attempts to allocate
-                                                     a Reassembly Frame Descriptor */
-    uint32_t    internal_buffer_busy;             /**< Counts the number of times an internal buffer busy occurred */
-    uint32_t    external_buffer_busy;             /**< Counts the number of times external buffer busy occurred */
-    uint32_t    sg_fragments;                    /**< Counts the number of Scatter/Gather fragments */
-    uint32_t    dma_semaphore_depletion;          /**< Counts the number of failed attempts to allocate a DMA semaphore */
-    struct {
-        uint32_t    successfully_reassembled;    /**< Counts the number of successfully reassembled frames */
-        uint32_t    valid_fragments;             /**< Counts the total number of valid fragments that
-                                                     have been processed for all frames */
-        uint32_t    processed_fragments;         /**< Counts the number of processed fragments
-                                                     (valid and error fragments) for all frames */
-        uint32_t    malformed_fragments;         /**< Counts the number of malformed fragments processed for all frames */
-        uint32_t    discarded_fragments;         /**< Counts the number of fragments discarded by the reassembly process */
-        uint32_t    auto_learn_busy;              /**< Counts the number of times a busy condition occurs when attempting
-                                                     to access an IP-Reassembly Automatic Learning Hash set */
-        uint32_t    more_than16fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
-                                                     exceeds 16 */
-    } specific_hdr_statistics[2];                 /**< slot '0' is for IPv4, slot '1' is for IPv6 */
-} ioc_fm_pcd_manip_reassem_ip_stats_t;
-
-/**************************************************************************//**
- @Description   Structure for retrieving IP fragmentation statistics
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_frag_ip_stats_t {
-    uint32_t    total_frames;            /**< Number of frames that passed through the manipulation node */
-    uint32_t    fragmented_frames;       /**< Number of frames that were fragmented */
-    uint32_t    generated_fragments;     /**< Number of fragments that were generated */
-} ioc_fm_pcd_manip_frag_ip_stats_t;
-
-/**************************************************************************//**
- @Description   Structure for retrieving reassembly statistics
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_reassem_stats_t {
-    union {
-        ioc_fm_pcd_manip_reassem_ip_stats_t  ip_reassem;  /**< Structure for IP reassembly statistics */
-    } u;
-} ioc_fm_pcd_manip_reassem_stats_t;
-
-/**************************************************************************//**
- @Description   structure for retrieving fragmentation statistics
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_frag_stats_t {
-    union {
-        ioc_fm_pcd_manip_frag_ip_stats_t     ip_frag;     /**< Structure for IP fragmentation statistics */
-    } u;
-} ioc_fm_pcd_manip_frag_stats_t;
-
-/**************************************************************************//**
- @Description   structure for defining manipulation statistics
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_stats_t {
-    union {
-        ioc_fm_pcd_manip_reassem_stats_t  reassem;    /**< Structure for reassembly statistics */
-        ioc_fm_pcd_manip_frag_stats_t     frag;       /**< Structure for fragmentation statistics */
-    } u;
-} ioc_fm_pcd_manip_stats_t;
-
-#if DPAA_VERSION >= 11
-/**************************************************************************//**
- @Description   Parameters for defining frame replicator group and its members
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_frm_replic_group_params_t {
-    uint8_t                     max_num_of_entries;    /**< Maximal number of members in the group  - must be at least two */
-    uint8_t                     num_of_entries;       /**< Number of members in the group - must be at least 1 */
-    ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
-                                                    /**< Array of members' parameters */
-    void                        *id;
-} ioc_fm_pcd_frm_replic_group_params_t;
-
-typedef struct ioc_fm_pcd_frm_replic_member_t {
-    void *h_replic_group;
-    uint16_t member_index;
-} ioc_fm_pcd_frm_replic_member_t;
-
-typedef struct ioc_fm_pcd_frm_replic_member_params_t {
-    ioc_fm_pcd_frm_replic_member_t member;
-    ioc_fm_pcd_cc_next_engine_params_t next_engine_params;
-} ioc_fm_pcd_frm_replic_member_params_t;
-#endif /* DPAA_VERSION >= 11 */
-
-/**************************************************************************//**
- @Function      FM_PCD_NetEnvCharacteristicsSet
-
- @Description   Define a set of Network Environment Characteristics.
-
-                When setting an environment it is important to understand its
-                application. It is not meant to describe the flows that will run
-                on the ports using this environment, but what the user means TO DO
-                with the PCD mechanisms in order to parse-classify-distribute those
-                frames.
-                By specifying a distinction unit, the user means it would use that option
-                for distinction between frames at either a KeyGen scheme or a coarse
-                classification action descriptor. Using interchangeable headers to define a
-                unit means that the user is indifferent to which of the interchangeable
-                headers is present in the frame, and wants the distinction to be based
-                on the presence of either one of them.
-
-                Depending on context, there are limitations to the use of environments. A
-                port using the PCD functionality is bound to an environment. Some or even
-                all ports may share an environment but also an environment per port is
-                possible. When initializing a scheme, a classification plan group (see below),
-                or a coarse classification tree, one of the initialized environments must be
-                stated and related to. When a port is bound to a scheme, a classification
-                plan group, or a coarse classification tree, it MUST be bound to the same
-                environment.
-
-                The different PCD modules, may relate (for flows definition) ONLY on
-                distinction units as defined by their environment. When initializing a
-                scheme for example, it may not choose to select IPV4 as a match for
-                recognizing flows unless it was defined in the relating environment. In
-                fact, to guide the user through the configuration of the PCD, each module's
-                characterization in terms of flows is not done using protocol names, but using
-                environment indexes.
-
-                In terms of HW implementation, the list of distinction units sets the LCV vectors
-                and later used for match vector, classification plan vectors and coarse classification
-                indexing.
-
- @Param[in,out] ioc_fm_pcd_net_env_params_t   A structure defining the distiction units for this configuration.
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_compat_fm_pcd_net_env_params_t)
-#endif
-#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_NetEnvCharacteristicsDelete
-
- @Description   Deletes a set of Network Environment Charecteristics.
-
- @Param[in]     ioc_fm_obj_t - The id of a Network Environment object.
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_compat_fm_obj_t)
-#endif
-#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSchemeSet
-
- @Description   Initializing or modifying and enabling a scheme for the KeyGen.
-                This routine should be called for adding or modifying a scheme.
-                When a scheme needs modifying, the API requires that it will be
-                rewritten. In such a case 'modify' should be TRUE. If the
-                routine is called for a valid scheme and 'modify' is FALSE,
-                it will return error.
-
- @Param[in,out] ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_KG_SCHEME_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_compat_fm_pcd_kg_scheme_params_t)
-#endif
-#define FM_PCD_IOC_KG_SCHEME_SET    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_KgSchemeDelete
-
- @Description   Deleting an initialized scheme.
-
- @Param[in]     ioc_fm_obj_t        scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_compat_fm_obj_t)
-#endif
-#define FM_PCD_IOC_KG_SCHEME_DELETE     _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_CcRootBuild
-
- @Description   This routine must be called to define a complete coarse
-                classification tree. This is the way to define coarse
-                classification to a certain flow - the KeyGen schemes
-                may point only to trees defined in this way.
-
- @Param[in,out] ioc_fm_pcd_cc_tree_params_t     A structure of parameters to define the tree.
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_ROOT_BUILD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), compat_uptr_t)
-#endif
-#define FM_PCD_IOC_CC_ROOT_BUILD    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), void *) /* workaround ...*/
-
-/**************************************************************************//**
- @Function      FM_PCD_CcRootDelete
-
- @Description   Deleting a built tree.
-
- @Param[in]     ioc_fm_obj_t - The id of a CC tree.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_ROOT_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_compat_fm_obj_t)
-#endif
-#define FM_PCD_IOC_CC_ROOT_DELETE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableSet
-
- @Description   This routine should be called for each CC (coarse classification)
-                node. The whole CC tree should be built bottom up so that each
-                node points to already defined nodes. p_NodeId returns the node
-                Id to be used by other nodes.
-
- @Param[in,out] ioc_fm_pcd_cc_node_params_t       A structure for defining the CC node params
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MATCH_TABLE_SET_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), compat_uptr_t)
-#endif
-#define FM_PCD_IOC_MATCH_TABLE_SET    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), void *) /* workaround ...*/
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableDelete
-
- @Description   Deleting a built node.
-
- @Param[in]     ioc_fm_obj_t - The id of a CC node.
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_compat_fm_obj_t)
-#endif
-#define FM_PCD_IOC_MATCH_TABLE_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_CcRootModifyNextEngine
-
- @Description   Modify the Next Engine Parameters in the entry of the tree.
-
- @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_CcRootBuild().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)
-#endif
-#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableModifyNextEngine
-
- @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
-#endif
-#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableModifyMissNextEngine
-
- @Description   Modify the Next Engine Parameters of the Miss key case of the node.
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
-#endif
-#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableRemoveKey
-
- @Description   Remove the key (including next engine parameters of this key)
-                defined by the index of the relevant node.
-
- @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  A pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
-                node and for all of the nodes that lead to it.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_compat_fm_pcd_cc_node_remove_key_params_t)
-#endif
-#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableAddKey
-
- @Description   Add the key (including next engine parameters of this key in the
-                index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
-                may be used when the user doesn't care about the position of the
-                key in the table - in that case, the key will be automatically
-                added by the driver in the last available entry.
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
-                node and for all of the nodes that lead to it.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-#endif
-#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableModifyKeyAndNextEngine
-
- @Description   Modify the key and Next Engine Parameters of this key in the index defined by key_index.
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_MatchTableSet() not only of the relevnt node but also
-                the node that points to this node
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-#endif
-#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_MatchTableModifyKey
-
- @Description   Modify the key at the index defined by key_index.
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t - Pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
-                node and for all of the nodes that lead to it.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_compat_fm_pcd_cc_node_modify_key_params_t)
-#endif
-#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableSet
-
- @Description   This routine initializes a hash table structure.
-                KeyGen hash result determines the hash bucket.
-                Next, KeyGen key is compared against all keys of this
-                bucket (exact match).
-                Number of sets (number of buckets) of the hash equals to the
-                number of 1-s in 'hash_res_mask' in the provided parameters.
-                Number of hash table ways is then calculated by dividing
-                'max_num_of_keys' equally between the hash sets. This is the maximal
-                number of keys that a hash bucket may hold.
-                The hash table is initialized empty and keys may be
-                added to it following the initialization. Keys masks are not
-                supported in current hash table implementation.
-                The initialized hash table can be integrated as a node in a
-                CC tree.
-
- @Param[in,out] ioc_fm_pcd_hash_table_params_t - Pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_HASH_TABLE_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_pcd_hash_table_params_t)
-#endif
-#define FM_PCD_IOC_HASH_TABLE_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_hash_table_params_t)
-
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableDelete
-
- @Description   This routine deletes the provided hash table and released all
-                its allocated resources.
-
- @Param[in]     ioc_fm_obj_t - The ID of a hash table.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_HASH_TABLE_DELETE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_obj_t)
-#endif
-#define FM_PCD_IOC_HASH_TABLE_DELETE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableAddKey
-
- @Description   This routine adds the provided key (including next engine
-                parameters of this key) to the hash table.
-                The key is added as the last key of the bucket that it is
-                mapped to.
-
- @Param[in]     ioc_fm_pcd_hash_table_add_key_params_t - Pointer to a structure with the relevant parameters
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_HASH_TABLE_ADD_KEY_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_compat_fm_pcd_hash_table_add_key_params_t)
-#endif
-#define FM_PCD_IOC_HASH_TABLE_ADD_KEY _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_fm_pcd_hash_table_add_key_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_HashTableRemoveKey
-
- @Description   This routine removes the requested key (including next engine
-                parameters of this key) from the hash table.
-
- @Param[in]     ioc_fm_pcd_hash_table_remove_key_params_t - Pointer to a structure with the relevant parameters
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_HashTableSet().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_compat_fm_pcd_hash_table_remove_key_params_t)
-#endif
-#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_fm_pcd_hash_table_remove_key_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_PlcrProfileSet
-
- @Description   Sets a profile entry in the policer profile table.
-                The routine overrides any existing value.
-
- @Param[in,out] ioc_fm_pcd_plcr_profile_params_t    A structure of parameters for defining a
-                                                    policer profile entry.
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_pcd_plcr_profile_params_t)
-#endif
-#define FM_PCD_IOC_PLCR_PROFILE_SET     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_pcd_plcr_profile_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_PlcrProfileDelete
-
- @Description   Delete a profile entry in the policer profile table.
-                The routine set entry to invalid.
-
- @Param[in]     ioc_fm_obj_t        The id of a policer profile.
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_obj_t)
-#endif
-#define FM_PCD_IOC_PLCR_PROFILE_DELETE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_ManipNodeSet
-
- @Description   This routine should be called for defining a manipulation
-                node. A manipulation node must be defined before the CC node
-                that precedes it.
-
- @Param[in]     ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MANIP_NODE_SET_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_compat_fm_pcd_manip_params_t)
-#endif
-#define FM_PCD_IOC_MANIP_NODE_SET   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_fm_pcd_manip_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_ManipNodeReplace
-
- @Description   Change existing manipulation node to be according to new requirement.
-                (Here, it's implemented as a variant of the same IOCTL as for
-                FM_PCD_ManipNodeSet(), and one that when called, the 'id' member
-                in its 'ioc_fm_pcd_manip_params_t' argument is set to contain
-                the manip node's handle)
-
- @Param[in]     ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_ManipNodeSet().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MANIP_NODE_REPLACE_COMPAT    FM_PCD_IOC_MANIP_NODE_SET_COMPAT
-#endif
-#define FM_PCD_IOC_MANIP_NODE_REPLACE           FM_PCD_IOC_MANIP_NODE_SET
-
-/**************************************************************************//**
- @Function      FM_PCD_ManipNodeDelete
-
- @Description   Delete an existing manipulation node.
-
- @Param[in]     ioc_fm_obj_t       The id of the manipulation node to delete.
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_ManipNodeSet().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_compat_fm_obj_t)
-#endif
-#define FM_PCD_IOC_MANIP_NODE_DELETE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_fm_obj_t)
-
-/**************************************************************************//**
-@Function      FM_PCD_SetAdvancedOffloadSupport
-
-@Description   This routine must be called in order to support the following features:
-               IP-fragmentation, IP-reassembly, IPsec, Header-manipulation, frame-replicator.
-
-@Param[in]     h_FmPcd         FM PCD module descriptor.
-
-@Return        0 on success; error code otherwise.
-
-@Cautions      Allowed only when PCD is disabled.
-*//***************************************************************************/
-#define FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45))
-
-#if (DPAA_VERSION >= 11)
-/**************************************************************************//**
- @Function      FM_PCD_FrmReplicSetGroup
-
- @Description   Initialize a Frame Replicator group.
-
- @Param[in]     h_FmPcd                FM PCD module descriptor.
- @Param[in]     p_FrmReplicGroupParam  A structure of parameters for the initialization of
-                                       the frame replicator group.
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_compat_fm_pcd_frm_replic_group_params_t)
-#endif
-#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_fm_pcd_frm_replic_group_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_FrmReplicDeleteGroup
-
- @Description   Delete a Frame Replicator group.
-
- @Param[in]     h_FrmReplicGroup  A handle to the frame replicator group.
-
- @Return        E_OK on success;  Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_compat_fm_obj_t)
-#endif
-#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_FrmReplicAddMember
-
- @Description   Add the member in the index defined by the memberIndex.
-
- @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
- @Param[in]     memberIndex        member index for adding.
- @Param[in]     p_MemberParams     A pointer to the new member parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(48), ioc_compat_fm_pcd_frm_replic_member_params_t)
-#endif
-#define FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(48), ioc_fm_pcd_frm_replic_member_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_FrmReplicRemoveMember
-
- @Description   Remove the member defined by the index from the relevant group.
-
- @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
- @Param[in]     memberIndex        member index for removing.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(49), ioc_compat_fm_pcd_frm_replic_member_t)
-#endif
-#define FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(49), ioc_fm_pcd_frm_replic_member_t)
-
-#endif
-
-#ifdef FM_CAPWAP_SUPPORT
-#warning "CAPWAP IOCTL not implemented"
-/**************************************************************************//**
- @Function      FM_PCD_StatisticsSetNode
-
- @Description   This routine should be called for defining a statistics node.
-
- @Param[in,out] ioc_fm_pcd_stats_params_t A structure of parameters defining the statistics
-
- @Return        0 on success; Error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_STATISTICS_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
-#endif
-#define FM_PCD_IOC_STATISTICS_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
-
-#endif /* FM_CAPWAP_SUPPORT */
-
-#ifdef NCSW_BACKWARD_COMPATIBLE_API
-#if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT \
-                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT
-#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT \
-                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT
-#define FM_PCD_IOC_KG_SET_SCHEME_COMPAT         FM_PCD_IOC_KG_SCHEME_SET_COMPAT
-#define FM_PCD_IOC_KG_DEL_SCHEME_COMPAT         FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT
-#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT         FM_PCD_IOC_CC_ROOT_BUILD_COMPAT
-#define FM_PCD_IOC_CC_DELETE_TREE_COMPAT        FM_PCD_IOC_CC_ROOT_DELETE_COMPAT
-#define FM_PCD_IOC_CC_DELETE_NODE_COMPAT        FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT
-#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT \
-                                                FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT
-#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT \
-                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT
-#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT \
-                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT
-#define FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT
-#define FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT       FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT \
-                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT
-#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT
-#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT
-#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT        FM_PCD_IOC_MANIP_NODE_SET_COMPAT
-#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT     FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT
-#endif
-#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET
-#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS \
-                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE
-#define FM_PCD_IOC_KG_SET_SCHEME                FM_PCD_IOC_KG_SCHEME_SET
-#define FM_PCD_IOC_KG_DEL_SCHEME                FM_PCD_IOC_KG_SCHEME_DELETE
-#define FM_PCD_IOC_CC_BUILD_TREE                FM_PCD_IOC_CC_ROOT_BUILD
-#define FM_PCD_IOC_CC_DELETE_TREE               FM_PCD_IOC_CC_ROOT_DELETE
-#define FM_PCD_IOC_CC_DELETE_NODE               FM_PCD_IOC_MATCH_TABLE_DELETE
-#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE
-#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE
-#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE \
-                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE
-#define FM_PCD_IOC_CC_NODE_REMOVE_KEY           FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY
-#define FM_PCD_IOC_CC_NODE_ADD_KEY              FM_PCD_IOC_MATCH_TABLE_ADD_KEY
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE \
-                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY           FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY
-#define FM_PCD_IOC_PLCR_SET_PROFILE             FM_PCD_IOC_PLCR_PROFILE_SET
-#define FM_PCD_IOC_PLCR_DEL_PROFILE             FM_PCD_IOC_PLCR_PROFILE_DELETE
-#define FM_PCD_IOC_MANIP_SET_NODE               FM_PCD_IOC_MANIP_NODE_SET
-#define FM_PCD_IOC_MANIP_DELETE_NODE            FM_PCD_IOC_MANIP_NODE_DELETE
-#endif /* NCSW_BACKWARD_COMPATIBLE_API */
-
-#endif /* __FM_PCD_IOCTLS_H */
-/** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
-/** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
-/** @} */ /* end of lnx_ioctl_FM_grp group */
diff --git a/include/linux/fmd/Peripherals/fm_port_ioctls.h b/include/linux/fmd/Peripherals/fm_port_ioctls.h
deleted file mode 100644
index 8488845..0000000
--- a/include/linux/fmd/Peripherals/fm_port_ioctls.h
+++ /dev/null
@@ -1,921 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/******************************************************************************
- @File          fm_port_ioctls.h
-
- @Description   FM Port routines
-*//***************************************************************************/
-#ifndef __FM_PORT_IOCTLS_H
-#define __FM_PORT_IOCTLS_H
-
-#include "enet_ext.h"
-#include "net_ioctls.h"
-#include "fm_ioctls.h"
-#include "fm_pcd_ioctls.h"
-
-
-/**************************************************************************//**
-
- @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
-
- @Description   FM Linux ioctls definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PORT_grp FM Port
-
- @Description   FM Port API
-
-                The FM uses a general module called "port" to represent a Tx port
-                (MAC), an Rx port (MAC), offline parsing flow or host command
-                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
-                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
-                Host command/Offline parsing ports. The SW driver manages these
-                ports as sub-modules of the FM, i.e. after an FM is initialized,
-                its ports may be initialized and operated upon.
-
-                The port is initialized aware of its type, but other functions on
-                a port may be indifferent to its type. When necessary, the driver
-                verifies coherency and returns error if applicable.
-
-                On initialization, user specifies the port type and it's index
-                (relative to the port's type). Host command and Offline parsing
-                ports share the same id range, I.e user may not initialized host
-                command port 0 and offline parsing port 0.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   An enum for defining port PCD modes.
-                (Must match enum e_FmPortPcdSupport defined in fm_port_ext.h)
-
-                This enum defines the superset of PCD engines support - i.e. not
-                all engines have to be used, but all have to be enabled. The real
-                flow of a specific frame depends on the PCD configuration and the
-                frame headers and payload.
-                Note: the first engine and the first engine after the parser (if
-                exists) should be in order, the order is important as it will
-                define the flow of the port. However, as for the rest engines
-                (the ones that follows), the order is not important anymore as
-                it is defined by the PCD graph itself.
-*//***************************************************************************/
-typedef enum ioc_fm_port_pcd_support {
-      e_IOC_FM_PORT_PCD_SUPPORT_NONE = 0                /**< BMI to BMI, PCD is not used */
-    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY                /**< Use only Parser */
-    , e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY               /**< Use only Policer */
-    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR            /**< Use Parser and Policer */
-    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG              /**< Use Parser and Keygen */
-    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC       /**< Use Parser, Keygen and Coarse Classification */
-    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
-                                                        /**< Use all PCD engines */
-    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
-    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
-    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
-#ifdef FM_CAPWAP_SUPPORT
-    , e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
-    , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
-    , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
-#endif /* FM_CAPWAP_SUPPORT */
-} ioc_fm_port_pcd_support;
-
-
-/**************************************************************************//**
- @Collection   FM Frame error
-*//***************************************************************************/
-typedef uint32_t    ioc_fm_port_frame_err_select_t;     /**< typedef for defining Frame Descriptor errors */
-
-/* @} */
-
-
-/**************************************************************************//**
- @Description   An enum for defining Dual Tx rate limiting scale.
-                (Must match e_FmPortDualRateLimiterScaleDown defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_port_dual_rate_limiter_scale_down {
-    e_IOC_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
-    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
-    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
-    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
-} ioc_fm_port_dual_rate_limiter_scale_down;
-
-/**************************************************************************//**
- @Description   A structure for defining Tx rate limiting
-                (Must match struct t_FmPortRateLimit defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_port_rate_limit_t {
-    uint16_t                            max_burst_size;         /**< in KBytes for Tx ports, in frames
-                                                                     for offline parsing ports. (note that
-                                                                     for early chips burst size is
-                                                                     rounded up to a multiply of 1000 frames).*/
-    uint32_t                            rate_limit;             /**< in Kb/sec for Tx ports, in frame/sec for
-                                                                     offline parsing ports. Rate limit refers to
-                                                                     data rate (rather than line rate). */
-    ioc_fm_port_dual_rate_limiter_scale_down rate_limit_divider;    /**< For offline parsing ports only. Not-valid
-                                                                     for some earlier chip revisions */
-} ioc_fm_port_rate_limit_t;
-
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
-
- @Description   FM Port Runtime control unit API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   An enum for defining FM Port counters.
-                (Must match enum e_FmPortCounters defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef enum ioc_fm_port_counters {
-    e_IOC_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
-    e_IOC_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
-    e_IOC_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
-    e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx, OP & HC statistics counter */
-    e_IOC_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER,  /**< BMI Rx, OP & HC only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
-    e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
-    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI total QM dequeues counter */
-    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI total QM enqueues counter */
-    e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
-    e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
-} ioc_fm_port_counters;
-
-/**************************************************************************//**
- @Description   Structure for Port id parameters.
-                (Description may be inaccurate;
-                must match struct t_FmPortCongestionGrps defined in fm_port_ext.h)
-
-                Fields commented 'IN' are passed by the port module to be used
-                by the FM module.
-                Fields commented 'OUT' will be filled by FM before returning to port.
-*//***************************************************************************/
-typedef struct ioc_fm_port_congestion_groups_t {
-    uint16_t    num_of_congestion_grps_to_consider;     /**< The number of required congestion groups
-                                                             to define the size of the following array */
-    uint8_t     congestion_grps_to_consider [FM_PORT_NUM_OF_CONGESTION_GRPS];
-                                                        /**< An array of CG indexes;
-                                                             Note that the size of the array should be
-                                                             'num_of_congestion_grps_to_consider'. */
-#if DPAA_VERSION >= 11
-    bool        pfc_priorities_enable[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
-                                                        /**< A matrix that represents the map between the CG ids
-                                                             defined in 'congestion_grps_to_consider' to the priorities
-                                                             mapping array. */
-#endif /* DPAA_VERSION >= 11 */
-} ioc_fm_port_congestion_groups_t;
-
-
-
-/**************************************************************************//**
- @Function      FM_PORT_Disable
-
- @Description   Gracefully disable an FM port. The port will not start new tasks after all
-                tasks associated with the port are terminated.
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      This is a blocking routine, it returns after port is
-                gracefully stopped, i.e. the port will not except new frames,
-                but it will finish all frames or tasks which were already began
-*//***************************************************************************/
-#define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
-
-/**************************************************************************//**
- @Function      FM_PORT_Enable
-
- @Description   A runtime routine provided to allow disable/enable of port.
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
-
-/**************************************************************************//**
- @Function      FM_PORT_SetRateLimit
-
- @Description   Calling this routine enables rate limit algorithm.
-                By default, this functionality is disabled.
-                Note that rate-limit mechanism uses the FM time stamp.
-                The selected rate limit specified here would be
-                rounded DOWN to the nearest 16M.
-
-                May be used for Tx and offline parsing ports only
-
- @Param[in]     ioc_fm_port_rate_limit A structure of rate limit parameters
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_SET_RATE_LIMIT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_rate_limit_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_DeleteRateLimit
-
- @Description   Calling this routine disables the previously enabled rate limit.
-
-                May be used for Tx and offline parsing ports only
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_DELETE_RATE_LIMIT   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(5))
-#define FM_PORT_IOC_REMOVE_RATE_LIMIT   FM_PORT_IOC_DELETE_RATE_LIMIT
-
-
-/**************************************************************************//**
- @Function      FM_PORT_AddCongestionGrps
-
- @Description   This routine effects the corresponding Tx port.
-                It should be called in order to enable pause
-                frame transmission in case of congestion in one or more
-                of the congestion groups relevant to this port.
-                Each call to this routine may add one or more congestion
-                groups to be considered relevant to this port.
-
-                May be used for Rx, or RX+OP ports only (depending on chip)
-
- @Param[in]     ioc_fm_port_congestion_groups_t - A pointer to an array of
-                                                congestion group ids to consider.
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_ADD_CONGESTION_GRPS    _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(34), ioc_fm_port_congestion_groups_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_RemoveCongestionGrps
-
- @Description   This routine effects the corresponding Tx port. It should be
-                called when congestion groups were
-                defined for this port and are no longer relevant, or pause
-                frames transmitting is not required on their behalf.
-                Each call to this routine may remove one or more congestion
-                groups to be considered relevant to this port.
-
-                May be used for Rx, or RX+OP ports only (depending on chip)
-
- @Param[in]     ioc_fm_port_congestion_groups_t - A pointer to an array of
-                                                congestion group ids to consider.
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_REMOVE_CONGESTION_GRPS    _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(35), ioc_fm_port_congestion_groups_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_SetErrorsRoute
-
- @Description   Errors selected for this routine will cause a frame with that error
-                to be enqueued to error queue.
-                Errors not selected for this routine will cause a frame with that error
-                to be enqueued to the one of the other port queues.
-                By default all errors are defined to be enqueued to error queue.
-                Errors that were configured to be discarded (at initialization)
-                may not be selected here.
-
-                May be used for Rx and offline parsing ports only
-
- @Param[in]     ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-                (szbs001: How is it possible to have one function that needs to be
-                          called BEFORE FM_PORT_Init() implemented as an ioctl,
-                          which will ALWAYS be called AFTER the FM_PORT_Init()
-                          for that port!?!?!?!???!?!??!?!?)
-*//***************************************************************************/
-#define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(4), ioc_fm_port_frame_err_select_t)
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
-
- @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   A structure defining the KG scheme after the parser.
-                (Must match struct t_FmPcdKgSchemeSelect defined in fm_port_ext.h)
-
-                This is relevant only to change scheme selection mode - from
-                direct to indirect and vice versa, or when the scheme is selected directly,
-                to select the scheme id.
-
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_scheme_select_t {
-    bool        direct;                     /**< TRUE to use 'scheme_id' directly, FALSE to use LCV.*/
-    void       *scheme_id;                  /**< Relevant for 'direct'=TRUE only.
-                                                 'scheme_id' selects the scheme after parser. */
-} ioc_fm_pcd_kg_scheme_select_t;
-
-/**************************************************************************//**
- @Description   Scheme IDs structure
-                (Must match struct t_FmPcdPortSchemesParams defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_port_schemes_params_t {
-    uint8_t     num_of_schemes;                         /**< Number of schemes for port to be bound to. */
-    void        *scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];  /**< Array of 'num_of_schemes' schemes for the
-                                                             port to be bound to */
-} ioc_fm_pcd_port_schemes_params_t;
-
-/**************************************************************************//**
- @Description   A union for defining port protocol parameters for parser
-                (Must match union u_FmPcdHdrPrsOpts defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef union ioc_fm_pcd_hdr_prs_opts_u {
-    /* MPLS */
-    struct {
-        bool                label_interpretation_enable;/**< When this bit is set, the last MPLS label will be
-                                                             interpreted as described in HW spec table. When the bit
-                                                             is cleared, the parser will advance to MPLS next parse */
-        ioc_net_header_type next_parse;                 /**< must be equal or higher than IPv4 */
-    } mpls_prs_options;
-
-    /* VLAN */
-    struct {
-        uint16_t            tag_protocol_id1;           /**< User defined Tag Protocol Identifier, to be recognized
-                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
-        uint16_t            tag_protocol_id2;           /**< User defined Tag Protocol Identifier, to be recognized
-                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
-    } vlan_prs_options;
-
-    /* PPP */
-    struct{
-        bool                enable_mtu_check;           /**< Check validity of MTU according to RFC2516 */
-    } pppoe_prs_options;
-
-    /* IPV6 */
-    struct {
-        bool                routing_hdr_disable;        /**< Disable routing header */
-    } ipv6_prs_options;
-
-    /* UDP */
-    struct {
-        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
-    } udp_prs_options;
-
-    /* TCP */
-    struct {
-        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
-    } tcp_prs_options;
-} ioc_fm_pcd_hdr_prs_opts_u;
-
-/**************************************************************************//**
- @Description   A structure for defining each header for the parser
-                (must match struct t_FmPcdPrsAdditionalHdrParams defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
-    ioc_net_header_type         hdr;                /**< Selected header */
-    bool                        err_disable;        /**< TRUE to disable error indication */
-    bool                        soft_prs_enable;    /**< Enable jump to SW parser when this
-                                                         header is recognized by the HW parser. */
-    uint8_t                     index_per_hdr;      /**< Normally 0, if more than one sw parser
-                                                         attachments exists for the same header,
-                                                         (in the main sw parser code) use this
-                                                         index to distinguish between them. */
-    bool                        use_prs_opts;       /**< TRUE to use parser options. */
-    ioc_fm_pcd_hdr_prs_opts_u   prs_opts;           /**< A unuion according to header type,
-                                                         defining the parser options selected.*/
-} ioc_fm_pcd_prs_additional_hdr_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining port PCD parameters
-                (Must match t_FmPortPcdPrsParams defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_prs_params_t {
-    uint8_t                         prs_res_priv_info;      /**< The private info provides a method of inserting
-                                                                 port information into the parser result. This information
-                                                                 may be extracted by KeyGen and be used for frames
-                                                                 distribution when a per-port distinction is required,
-                                                                 it may also be used as a port logical id for analyzing
-                                                                 incoming frames. */
-    uint8_t                         parsing_offset;         /**< Number of bytes from begining of packet to start parsing */
-    ioc_net_header_type             first_prs_hdr;          /**< The type of the first header axpected at 'parsing_offset' */
-    bool                            include_in_prs_statistics; /**< TRUE to include this port in the parser statistics */
-    uint8_t                         num_of_hdrs_with_additional_params;
-                                                            /**< Normally 0, some headers may get special parameters */
-    ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
-                                                            /**< 'num_of_hdrs_with_additional_params' structures
-                                                                  additional parameters for each header that requires them */
-    bool                            set_vlan_tpid1;         /**< TRUE to configure user selection of Ethertype to
-                                                                 indicate a VLAN tag (in addition to the TPID values
-                                                                 0x8100 and 0x88A8). */
-    uint16_t                        vlan_tpid1;             /**< extra tag to use if set_vlan_tpid1=TRUE. */
-    bool                            set_vlan_tpid2;         /**< TRUE to configure user selection of Ethertype to
-                                                                 indicate a VLAN tag (in addition to the TPID values
-                                                                 0x8100 and 0x88A8). */
-    uint16_t                        vlan_tpid2;             /**< extra tag to use if set_vlan_tpid1=TRUE. */
-} ioc_fm_port_pcd_prs_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining coarse alassification parameters
-                (Must match t_FmPortPcdCcParams defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_cc_params_t {
-    void                *cc_tree_id; /**< CC tree id */
-} ioc_fm_port_pcd_cc_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining keygen parameters
-                (Must match t_FmPortPcdKgParams defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_kg_params_t {
-    uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
-    void               *scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];
-                                                        /**< Array of 'num_of_schemes' schemes for the
-                                                             port to be bound to */
-    bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
-                                                             regardless of parser result */
-    void               *direct_scheme_id;               /**< Scheme id, as returned by FM_PCD_KgSetScheme;
-                                                             relevant only if direct=TRUE. */
-} ioc_fm_port_pcd_kg_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining policer parameters
-                (Must match t_FmPortPcdPlcrParams defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_plcr_params_t {
-    void                *plcr_profile_id;               /**< Selected profile handle;
-                                                             relevant in one of the following cases:
-                                                             e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
-                                                             e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
-                                                             or if any flow uses a KG scheme where policer
-                                                                profile is not generated (bypass_plcr_profile_generation selected) */
-} ioc_fm_port_pcd_plcr_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining port PCD parameters
-                (Must match struct t_FmPortPcdParams defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_params_t {
-    ioc_fm_port_pcd_support         pcd_support;    /**< Relevant for Rx and offline ports only.
-                                                         Describes the active PCD engines for this port. */
-    void                            *net_env_id;    /**< HL Unused in PLCR only mode */
-    ioc_fm_port_pcd_prs_params_t    *p_prs_params;  /**< Parser parameters for this port */
-    ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
-    ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
-    ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
-    void                            *p_ip_reassembly_manip;/**< IP Reassembly manipulation */
-} ioc_fm_port_pcd_params_t;
-
-
-/**************************************************************************//**
- @Description   A structure for defining the Parser starting point
-                (Must match struct t_FmPcdPrsStart defined in fm_port_ext.h)
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_prs_start_t {
-    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
-                                             start parsing */
-    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
-                                             'parsing_offset' */
-} ioc_fm_pcd_prs_start_t;
-
-
-/**************************************************************************//**
- @Description   FQID parameters structure
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_fqids_params_t {
-    uint32_t            num_fqids;  /**< Number of fqids to be allocated for the port */
-    uint8_t             alignment;  /**< Alignment required for this port */
-    uint32_t            base_fqid;  /**< output parameter - the base fqid */
-} ioc_fm_port_pcd_fqids_params_t;
-
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_ALLOC_PCD_FQIDS
-
- @Description   Allocates FQID's
-
-                May be used for Rx and offline parsing ports only
-
- @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_FREE_PCD_FQIDS
-
- @Description   Frees previously-allocated FQIDs
-
-                May be used for Rx and offline parsing ports only
-
- @Param[in]		uint32_t	Base FQID of previously allocated range.
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_FREE_PCD_FQIDS   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), uint32_t)
-
-
-/**************************************************************************//**
- @Function      FM_PORT_SetPCD
-
- @Description   Calling this routine defines the port's PCD configuration.
-                It changes it from its default configuration which is PCD
-                disabled (BMI to BMI) and configures it according to the passed
-                parameters.
-
-                May be used for Rx and offline parsing ports only
-
- @Param[in]     ioc_fm_port_pcd_params_t    A Structure of parameters defining the port's PCD
-                                            configuration.
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PORT_IOC_SET_PCD_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_compat_fm_port_pcd_params_t)
-#endif
-#define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_DeletePCD
-
- @Description   Calling this routine releases the port's PCD configuration.
-                The port returns to its default configuration which is PCD
-                disabled (BMI to BMI) and all PCD configuration is removed.
-
-                May be used for Rx and offline parsing ports which are
-                in PCD mode only
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
-
-/**************************************************************************//**
- @Function      FM_PORT_AttachPCD
-
- @Description   This routine may be called after FM_PORT_DetachPCD was called,
-                to return to the originally configured PCD support flow.
-                The couple of routines are used to allow PCD configuration changes
-                that demand that PCD will not be used while changes take place.
-
-                May be used for Rx and offline parsing ports which are
-                in PCD mode only
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
-
-/**************************************************************************//**
- @Function      FM_PORT_DetachPCD
-
- @Description   Calling this routine detaches the port from its PCD functionality.
-                The port returns to its default flow which is BMI to BMI.
-
-                May be used for Rx and offline parsing ports which are
-                in PCD mode only
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdPlcrAllocProfiles
-
- @Description   This routine may be called only for ports that use the Policer in
-                order to allocate private policer profiles.
-
- @Param[in]     uint16_t       The number of required policer profiles
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      Allowed before FM_PORT_SetPCD() only.
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES     _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdPlcrFreeProfiles
-
- @Description   This routine should be called for freeing private policer profiles.
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      Allowed before FM_PORT_SetPCD() only.
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES     _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdKgModifyInitialScheme
-
- @Description   This routine may be called only for ports that use the keygen in
-                order to change the initial scheme frame should be routed to.
-                The change may be of a scheme id (in case of direct mode),
-                from direct to indirect, or from indirect to direct - specifying the scheme id.
-
- @Param[in]     ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
-                                                a scheme is direct/indirect, and if direct - scheme id.
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_compat_fm_pcd_kg_scheme_select_t)
-#endif
-#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdPlcrModifyInitialProfile
-
- @Description   This routine may be called for ports with flows
-                e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only,
-                to change the initial Policer profile frame should be routed to.
-                The change may be of a profile and/or absolute/direct mode selection.
-
- @Param[in]     ioc_fm_obj_t       Policer profile Id as returned from FM_PCD_PlcrSetProfile.
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_compat_fm_obj_t)
-#endif
-#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdCcModifyTree
-
- @Description   This routine may be called to change this port connection to
-                a pre-initializes coarse classification Tree.
-
- @Param[in]     ioc_fm_obj_t    Id of new coarse classification tree selected for this port.
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_SetPCD() and FM_PORT_DetachPCD()
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PORT_IOC_PCD_CC_MODIFY_TREE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_compat_fm_obj_t)
-#endif
-#define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdKgBindSchemes
-
- @Description   These routines may be called for modifying the binding of ports
-                to schemes. The scheme itself is not added,
-                just this specific port starts using it.
-
- @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_SetPCD().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_compat_fm_pcd_port_schemes_params_t)
-#endif
-#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdKgUnbindSchemes
-
- @Description   These routines may be called for modifying the binding of ports
-                to schemes. The scheme itself is not removed or invalidated,
-                just this specific port stops using it.
-
- @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
-
- @Return        0 on success; error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_SetPCD().
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_compat_fm_pcd_port_schemes_params_t)
-#endif
-#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_PcdPrsModifyStartOffset
-
- @Description   Runtime change of the parser start offset within the header.
-
- @Param[in]     ioc_fm_pcd_prs_start_t  A structure of parameters for defining the
-                                        start point for the parser.
-
- @Return        0 on success; error code otherwise.
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)
-
-typedef struct ioc_fm_port_mac_addr_params_t {
-    uint8_t addr[ENET_NUM_OCTETS_PER_ADDRESS];
-} ioc_fm_port_mac_addr_params_t;
-
-/**************************************************************************//**
- @Function      FM_MAC_AddHashMacAddr
-
- @Description   Add an Address to the hash table. This is for filter purpose only.
-
- @Param[in]     ioc_fm_port_mac_addr_params_t - Ethernet Mac address
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init(). It is a filter only address.
- @Cautions      Some address need to be filtered out in upper FM blocks.
-*//***************************************************************************/
-#define FM_PORT_IOC_ADD_RX_HASH_MAC_ADDR   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(36), ioc_fm_port_mac_addr_params_t)
-
-/**************************************************************************//**
- @Function      FM_MAC_RemoveHashMacAddr
-
- @Description   Delete an Address to the hash table. This is for filter purpose only.
-
- @Param[in]     ioc_fm_port_mac_addr_params_t - Ethernet Mac address
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_REMOVE_RX_HASH_MAC_ADDR   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(37), ioc_fm_port_mac_addr_params_t)
-
-typedef struct ioc_fm_port_tx_pause_frames_params_t {
-    uint8_t  priority;
-    uint16_t pause_time;
-    uint16_t thresh_time;
-} ioc_fm_port_tx_pause_frames_params_t;
-
-/**************************************************************************//**
- @Function      FM_MAC_SetTxPauseFrames
-
- @Description   Enable/Disable transmission of Pause-Frames.
-                The routine changes the default configuration:
-                pause-time - [0xf000]
-                threshold-time - [0]
-
- @Param[in]     ioc_fm_port_tx_pause_frames_params_t A structure holding the required parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Init().
-                PFC is supported only on new mEMAC; i.e. in MACs that don't have
-                PFC support (10G-MAC and dTSEC), user should use 'FM_MAC_NO_PFC'
-                in the 'priority' field.
-*//***************************************************************************/
-#define FM_PORT_IOC_SET_TX_PAUSE_FRAMES       _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(40), ioc_fm_port_tx_pause_frames_params_t)
-
-typedef struct ioc_fm_port_mac_statistics_t {
-    /* RMON */
-        uint64_t  e_stat_pkts_64;            /**< r-10G tr-DT 64 byte frame counter */
-        uint64_t  e_stat_pkts_65_to_127;     /**< r-10G 65 to 127 byte frame counter */
-        uint64_t  e_stat_pkts_128_to_255;    /**< r-10G 128 to 255 byte frame counter */
-        uint64_t  e_stat_pkts_256_to_511;    /**< r-10G 256 to 511 byte frame counter */
-        uint64_t  e_stat_pkts_512_to_1023;   /**< r-10G 512 to 1023 byte frame counter */
-        uint64_t  e_stat_pkts_1024_to_1518;  /**< r-10G 1024 to 1518 byte frame counter */
-        uint64_t  e_stat_pkts_1519_to_1522;  /**< r-10G 1519 to 1522 byte good frame count */
-    /* */
-        uint64_t  e_stat_fragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
-        uint64_t  e_stat_jabbers;            /**< Total number of packets longer than valid maximum length octets */
-        uint64_t  e_stat_drop_events;        /**< number of dropped packets due to internal errors of the MAC Client (during recieve). */
-        uint64_t  e_stat_CRC_align_errors;   /**< Incremented when frames of correct length but with CRC error are received.*/
-        uint64_t  e_stat_undersize_pkts;     /**< Incremented for frames under 64 bytes with a valid FCS and otherwise well formed;
-                                                This count does not include range length errors */
-        uint64_t  e_stat_oversize_pkts;      /**< Incremented for frames which exceed 1518 (non VLAN) or 1522 (VLAN) and contains
-                                                a valid FCS and otherwise well formed */
-    /* Pause */
-        uint64_t  te_stat_pause;             /**< Pause MAC Control received */
-        uint64_t  re_stat_pause;             /**< Pause MAC Control sent */
-    /* MIB II */
-        uint64_t  if_in_octets;              /**< Total number of byte received. */
-        uint64_t  if_in_pkts;                /**< Total number of packets received.*/
-        uint64_t  if_in_ucast_pkts;          /**< Total number of unicast frame received;
-                                             NOTE: this counter is not supported on dTSEC MAC */
-        uint64_t  if_in_mcast_pkts;          /**< Total number of multicast frame received*/
-        uint64_t  if_in_bcast_pkts;          /**< Total number of broadcast frame received */
-        uint64_t  if_in_discards;            /**< Frames received, but discarded due to problems within the MAC RX. */
-        uint64_t  if_in_errors;              /**< Number of frames received with error:
-                                                   - FIFO Overflow Error
-                                                   - CRC Error
-                                                   - Frame Too Long Error
-                                                   - Alignment Error
-                                                   - The dedicated Error Code (0xfe, not a code error) was received */
-        uint64_t  if_out_octets;             /**< Total number of byte sent. */
-        uint64_t  if_out_pkts;               /**< Total number of packets sent .*/
-        uint64_t  if_out_ucast_pkts;         /**< Total number of unicast frame sent;
-                                             NOTE: this counter is not supported on dTSEC MAC */
-        uint64_t  if_out_mcast_pkts;         /**< Total number of multicast frame sent */
-        uint64_t  if_out_bcast_pkts;         /**< Total number of multicast frame sent */
-        uint64_t  if_out_discards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
-        uint64_t  if_out_errors;             /**< Number of frames transmitted with error:
-                                                   - FIFO Overflow Error
-                                                   - FIFO Underflow Error
-                                                   - Other */
-} ioc_fm_port_mac_statistics_t;
-
-/**************************************************************************//**
- @Function      FM_MAC_GetStatistics
-
- @Description   get all MAC statistics counters
-
- @Param[out]    ioc_fm_port_mac_statistics_t    A structure holding the statistics
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_GET_MAC_STATISTICS        _IOR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(41), ioc_fm_port_mac_statistics_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigBufferPrefixContent
-
- @Description   Defines the structure, size and content of the application buffer.
-                The prefix will
-                In Tx ports, if 'passPrsResult', the application
-                should set a value to their offsets in the prefix of
-                the FM will save the first 'privDataSize', than,
-                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
-                and timeStamp, and the packet itself (in this order), to the
-                application buffer, and to offset.
-                Calling this routine changes the buffer margins definitions
-                in the internal driver data base from its default
-                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
-                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
-                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
-
-                May be used for all ports
-
- @Param[in]     ioc_fm_buffer_prefix_content_t  A structure holding the required parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_CONFIG_BUFFER_PREFIX_CONTENT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(39), ioc_fm_buffer_prefix_content_t)
-
-#if (DPAA_VERSION >= 11)
-typedef struct ioc_fm_port_vsp_alloc_params_t {
-    uint8_t     num_of_profiles;          /**< Number of Virtual Storage Profiles */
-    uint8_t     dflt_relative_id;         /**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
-                                             The same default Virtual-Storage-Profile-id will be for coupled Tx port
-                                             if relevant function called for Rx port */
-    void    *p_fm_tx_port;             /**< Handle to coupled Tx Port; not relevant for OP port. */
-}ioc_fm_port_vsp_alloc_params_t;
-
-/**************************************************************************//**
- @Function      FM_PORT_VSPAlloc
-
- @Description   This routine allocated VSPs per port and forces the port to work
-                in VSP mode. Note that the port is initialized by default with the
-                physical-storage-profile only.
-
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     p_Params    A structure of parameters for allocation VSP's per port
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init(), and before FM_PORT_SetPCD()
-                and also before FM_PORT_Enable() (i.e. the port should be disabled).
-*//***************************************************************************/
-#if defined(CONFIG_COMPAT)
-#define FM_PORT_IOC_VSP_ALLOC_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_compat_fm_port_vsp_alloc_params_t)
-#endif
-#define FM_PORT_IOC_VSP_ALLOC _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_fm_port_vsp_alloc_params_t)
-#endif /* (DPAA_VERSION >= 11) */
-
-/** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
-/** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
-
-/** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
-/** @} */ /* end of lnx_ioctl_FM_grp group */
-#endif /* __FM_PORT_IOCTLS_H */
diff --git a/include/linux/fmd/Peripherals/fm_test_ioctls.h b/include/linux/fmd/Peripherals/fm_test_ioctls.h
deleted file mode 100644
index 207ed1e..0000000
--- a/include/linux/fmd/Peripherals/fm_test_ioctls.h
+++ /dev/null
@@ -1,208 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          fm_test_ioctls.h
-
- @Description   FM Char device ioctls
-*//***************************************************************************/
-#ifndef __FM_TEST_IOCTLS_H
-#define __FM_TEST_IOCTLS_H
-
-#include "ioctls.h"
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FMT_grp Frame Manager Test Linux IOCTL API
-
- @Description   FM-Test Linux ioctls definitions and enums
-
- @{
-*//***************************************************************************/
-
-#define IOC_FMT_MAX_NUM_OF_PORTS        26
-
-/**************************************************************************//**
- @Collection    TEST Parameters
-*//***************************************************************************/
-/**************************************************************************//**
-  @Description: Name of the FM-Test chardev
-*//***************************************************************************/
-#define DEV_FM_TEST_NAME                "fm-test-port"
-
-#define DEV_FM_TEST_PORTS_MINOR_BASE    0
-#define DEV_FM_TEST_MAX_MINORS          (DEV_FM_TEST_PORTS_MINOR_BASE + IOC_FMT_MAX_NUM_OF_PORTS)
-
-#define FMT_PORT_IOC_NUM(n)             n
-/* @} */
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FMT_lib_grp FM-Test library
-
- @Description   TODO
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   TODO
-*//***************************************************************************/
-typedef uint8_t ioc_fmt_xxx_t;
-
-#define FM_PRS_MAX 32
-#define FM_TIME_STAMP_MAX 8
-
-/**************************************************************************//**
- @Description   FM Port buffer content description
-*//***************************************************************************/
-typedef struct ioc_fmt_buff_context_t {
-    void            *p_user_priv;
-    uint8_t         fm_prs_res[FM_PRS_MAX];
-    uint8_t         fm_time_stamp[FM_TIME_STAMP_MAX];
-} ioc_fmt_buff_context_t;
-
-#if defined(__KERNEL__) && defined(CONFIG_COMPAT)
-typedef struct ioc_fmt_compat_buff_context_t {
-    compat_uptr_t         p_user_priv;
-    uint8_t               fm_prs_res[FM_PRS_MAX];
-    uint8_t               fm_time_stamp[FM_TIME_STAMP_MAX];
-} ioc_fmt_compat_buff_context_t;
-#endif
-
-/**************************************************************************//**
- @Description   Buffer descriptor
-*//***************************************************************************/
-typedef struct ioc_fmt_buff_desc_t {
-    uint32_t               qid;
-    void                   *p_data;
-    uint32_t               size;
-    uint32_t               status;
-    ioc_fmt_buff_context_t buff_context;
-} ioc_fmt_buff_desc_t;
-
-#if defined(__KERNEL__) && defined(CONFIG_COMPAT)
-typedef struct ioc_fmt_compat_buff_desc_t {
-    uint32_t                qid;
-    compat_uptr_t           p_data;
-    uint32_t                size;
-    uint32_t                status;
-    ioc_fmt_compat_buff_context_t buff_context;
-} ioc_fmt_compat_buff_desc_t;
-#endif
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit
-
- @Description   TODO
- @{
-*//***************************************************************************/
-
-/** @} */ /* end of lnx_ioctl_FMT_runtime_control_grp group */
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library
-
- @Description   TODO
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   FM-Test FM port type
-*//***************************************************************************/
-typedef enum ioc_fmt_port_type {
-    e_IOC_FMT_PORT_T_RXTX,  /**< Standard port */
-    e_IOC_FMT_PORT_T_OP,    /**< Offline-parsing port */
-} ioc_fmt_port_type;
-
-/**************************************************************************//**
- @Description   TODO
-*//***************************************************************************/
-typedef struct ioc_fmt_port_param_t {
-    uint8_t             fm_id;
-    ioc_fmt_port_type   fm_port_type;
-    uint8_t             fm_port_id;
-    uint32_t            num_tx_queues;
-} ioc_fmt_port_param_t;
-
-
-/**************************************************************************//**
- @Function      FMT_PORT_IOC_INIT
-
- @Description   TODO
-
- @Param[in]     ioc_fmt_port_param_t  TODO
-
- @Cautions      Allowed only after the FM equivalent port is already initialized.
-*//***************************************************************************/
-#define FMT_PORT_IOC_INIT           _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
-
-/**************************************************************************//**
- @Function      FMT_PORT_IOC_SET_DIAG_MODE
-
- @Description   TODO
-
- @Param[in]     ioc_diag_mode  TODO
-
- @Cautions      Allowed only following FMT_PORT_IOC_INIT().
-*//***************************************************************************/
-#define FMT_PORT_IOC_SET_DIAG_MODE  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(1), ioc_diag_mode)
-
-/**************************************************************************//**
- @Function      FMT_PORT_IOC_SET_IP_HEADER_MANIP
-
- @Description   Set IP header manipulations for this port.
-
- @Param[in]     int     1 to enable; 0 to disable
-
- @Cautions      Allowed only following FMT_PORT_IOC_INIT().
-*//***************************************************************************/
-#define FMT_PORT_IOC_SET_IP_HEADER_MANIP  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(2), int)
-
-/**************************************************************************//**
- @Function      FMT_PORT_IOC_SET_DPAECHO_MODE
-
- @Description   Set DPA in echo mode - all frame are sent back.
-
- @Param[in]     int     1 to enable; 0 to disable
-
- @Cautions      Allowed only following FMT_PORT_IOC_INIT().
-*//***************************************************************************/
-#define FMT_PORT_IOC_SET_DPAECHO_MODE     _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(3), int)
-
-/** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */
-/** @} */ /* end of lnx_ioctl_FMT_lib_grp group */
-/** @} */ /* end of lnx_ioctl_FMT_grp */
-
-
-#endif /* __FM_TEST_IOCTLS_H */
diff --git a/include/linux/fmd/integrations/Kbuild b/include/linux/fmd/integrations/Kbuild
deleted file mode 100644
index e548d676..0000000
--- a/include/linux/fmd/integrations/Kbuild
+++ /dev/null
@@ -1 +0,0 @@
-header-y += integration_ioctls.h
diff --git a/include/linux/fmd/integrations/integration_ioctls.h b/include/linux/fmd/integrations/integration_ioctls.h
deleted file mode 100644
index 61d696e..0000000
--- a/include/linux/fmd/integrations/integration_ioctls.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          integration_ioctls.h
-
- @Description   External header file for Integration unit routines.
-*//***************************************************************************/
-
-#ifndef __INTG_IOCTLS_H
-#define __INTG_IOCTLS_H
-
-
-#define FM_IOC_TYPE_BASE            (NCSW_IOC_TYPE_BASE+1)
-#define FMT_IOC_TYPE_BASE           (NCSW_IOC_TYPE_BASE+3)
-
-/*#define FM_IOCTL_DBG*/
-
-#if defined(FM_IOCTL_DBG)
-    #define _fm_ioctl_dbg(format, arg...) \
-        printk("fm ioctl [%s:%u](cpu:%u) - " format, \
-            __func__, __LINE__, smp_processor_id(), ##arg)
-#else
-#   define _fm_ioctl_dbg(arg...)
-#endif
-
-#endif /* __INTG_IOCTLS_H */
diff --git a/include/linux/fmd/ioctls.h b/include/linux/fmd/ioctls.h
deleted file mode 100644
index 4f36cb0..0000000
--- a/include/linux/fmd/ioctls.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          ioctls.h
-
- @Description   Structures and definitions for Command Relay Ioctls
-*//***************************************************************************/
-
-#ifndef __IOCTLS_H__
-#define __IOCTLS_H__
-
-#include <asm/ioctl.h>
-
-#include "integration_ioctls.h"
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_ncsw_grp    NetCommSw Linux User-Space (IOCTL) API
- @{
-*//***************************************************************************/
-
-#define NCSW_IOC_TYPE_BASE          0xe0    /**< defines the IOCTL type for all
-                                                 the NCSW Linux module commands */
-
-
-/**************************************************************************//**
- @Description   IOCTL Memory allocation types.
-*//***************************************************************************/
-typedef enum ioc_mem_type {
-    e_IOC_MEM_INVALID      = 0x00000000,  /**< Invalid memory type (error) */
-    e_IOC_MEM_CACHABLE_SYS = 0x00000001,  /**< Primary DDR, cacheable segment */
-    e_IOC_MEM_NOCACHE_SYS  = 0x00000004,  /**< Primary DDR, non-cacheable segment */
-    e_IOC_MEM_SECONDARY    = 0x00000002,  /**< Either secondary DDR or SDRAM */
-    e_IOC_MEM_PRAM         = 0x00000008   /**< Multi-user RAM identifier */
-} ioc_mem_type;
-
-/**************************************************************************//**
- @Description   Enumeration (bit flags) of communication modes (Transmit,
-                receive or both).
-*//***************************************************************************/
-typedef enum ioc_comm_mode {
-      e_IOC_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
-    , e_IOC_COMM_MODE_RX           = 1  /**< Only receive communication */
-    , e_IOC_COMM_MODE_TX           = 2  /**< Only transmit communication */
-    , e_IOC_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
-} ioc_comm_mode;
-
-/**************************************************************************//**
- @Description   General Diagnostic Mode
-*//***************************************************************************/
-typedef enum ioc_diag_mode
-{
-    e_IOC_DIAG_MODE_NONE = 0,
-    e_IOC_DIAG_MODE_CTRL_LOOPBACK,      /**< loopback in the controller; E.g. MAC, TDM, etc. */
-    e_IOC_DIAG_MODE_CHIP_LOOPBACK,      /**< loopback in the chip but not in controller;
-                                         E.g. IO-pins, SerDes, etc. */
-    e_IOC_DIAG_MODE_PHY_LOOPBACK,       /**< loopback in the external PHY */
-    e_IOC_DIAG_MODE_LINE_LOOPBACK,      /**< loopback in the external line */
-    e_IOC_DIAG_MODE_CTRL_ECHO,          /**< */
-    e_IOC_DIAG_MODE_PHY_ECHO            /**< */
-} ioc_diag_mode;
-
-/** @} */ /* end of lnx_ioctl_ncsw_grp */
-
-
-#endif /* __IOCTLS_H__ */
diff --git a/include/linux/fmd/net_ioctls.h b/include/linux/fmd/net_ioctls.h
deleted file mode 100644
index c99d64c..0000000
--- a/include/linux/fmd/net_ioctls.h
+++ /dev/null
@@ -1,430 +0,0 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/**************************************************************************//**
- @File          net_ioctls.h
-
- @Description   This file contains common and general netcomm headers definitions.
-*//***************************************************************************/
-#ifndef __NET_IOCTLS_H
-#define __NET_IOCTLS_H
-
-#include "ioctls.h"
-
-
-typedef uint8_t ioc_header_field_ppp_t;
-
-#define IOC_NET_HEADER_FIELD_PPP_PID                        (1)
-#define IOC_NET_HEADER_FIELD_PPP_COMPRESSED                 (IOC_NET_HEADER_FIELD_PPP_PID << 1)
-#define IOC_NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_PPP_PID << 2) - 1)
-
-
-typedef uint8_t ioc_header_field_pppoe_t;
-
-#define IOC_NET_HEADER_FIELD_PPPoE_VER                      (1)
-#define IOC_NET_HEADER_FIELD_PPPoE_TYPE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 1)
-#define IOC_NET_HEADER_FIELD_PPPoE_CODE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 2)
-#define IOC_NET_HEADER_FIELD_PPPoE_SID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 3)
-#define IOC_NET_HEADER_FIELD_PPPoE_LEN                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 4)
-#define IOC_NET_HEADER_FIELD_PPPoE_SESSION                  (IOC_NET_HEADER_FIELD_PPPoE_VER << 5)
-#define IOC_NET_HEADER_FIELD_PPPoE_PID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 6)
-#define IOC_NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
-
-#define IOC_NET_HEADER_FIELD_PPPMUX_PID                     (1)
-#define IOC_NET_HEADER_FIELD_PPPMUX_CKSUM                   (IOC_NET_HEADER_FIELD_PPPMUX_PID << 1)
-#define IOC_NET_HEADER_FIELD_PPPMUX_COMPRESSED              (IOC_NET_HEADER_FIELD_PPPMUX_PID << 2)
-#define IOC_NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
-
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
-
-
-typedef uint8_t ioc_header_field_eth_t;
-
-#define IOC_NET_HEADER_FIELD_ETH_DA                         (1)
-#define IOC_NET_HEADER_FIELD_ETH_SA                         (IOC_NET_HEADER_FIELD_ETH_DA << 1)
-#define IOC_NET_HEADER_FIELD_ETH_LENGTH                     (IOC_NET_HEADER_FIELD_ETH_DA << 2)
-#define IOC_NET_HEADER_FIELD_ETH_TYPE                       (IOC_NET_HEADER_FIELD_ETH_DA << 3)
-#define IOC_NET_HEADER_FIELD_ETH_FINAL_CKSUM                (IOC_NET_HEADER_FIELD_ETH_DA << 4)
-#define IOC_NET_HEADER_FIELD_ETH_PADDING                    (IOC_NET_HEADER_FIELD_ETH_DA << 5)
-#define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
-
-#define IOC_NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
-
-typedef uint16_t ioc_header_field_ip_t;
-
-#define IOC_NET_HEADER_FIELD_IP_VER                         (1)
-#define IOC_NET_HEADER_FIELD_IP_DSCP                        (IOC_NET_HEADER_FIELD_IP_VER << 2)
-#define IOC_NET_HEADER_FIELD_IP_ECN                         (IOC_NET_HEADER_FIELD_IP_VER << 3)
-#define IOC_NET_HEADER_FIELD_IP_PROTO                       (IOC_NET_HEADER_FIELD_IP_VER << 4)
-
-#define IOC_NET_HEADER_FIELD_IP_PROTO_SIZE                  1
-
-typedef uint16_t ioc_header_field_ipv4_t;
-
-#define IOC_NET_HEADER_FIELD_IPv4_VER                       (1)
-#define IOC_NET_HEADER_FIELD_IPv4_HDR_LEN                   (IOC_NET_HEADER_FIELD_IPv4_VER << 1)
-#define IOC_NET_HEADER_FIELD_IPv4_TOS                       (IOC_NET_HEADER_FIELD_IPv4_VER << 2)
-#define IOC_NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (IOC_NET_HEADER_FIELD_IPv4_VER << 3)
-#define IOC_NET_HEADER_FIELD_IPv4_ID                        (IOC_NET_HEADER_FIELD_IPv4_VER << 4)
-#define IOC_NET_HEADER_FIELD_IPv4_FLAG_D                    (IOC_NET_HEADER_FIELD_IPv4_VER << 5)
-#define IOC_NET_HEADER_FIELD_IPv4_FLAG_M                    (IOC_NET_HEADER_FIELD_IPv4_VER << 6)
-#define IOC_NET_HEADER_FIELD_IPv4_OFFSET                    (IOC_NET_HEADER_FIELD_IPv4_VER << 7)
-#define IOC_NET_HEADER_FIELD_IPv4_TTL                       (IOC_NET_HEADER_FIELD_IPv4_VER << 8)
-#define IOC_NET_HEADER_FIELD_IPv4_PROTO                     (IOC_NET_HEADER_FIELD_IPv4_VER << 9)
-#define IOC_NET_HEADER_FIELD_IPv4_CKSUM                     (IOC_NET_HEADER_FIELD_IPv4_VER << 10)
-#define IOC_NET_HEADER_FIELD_IPv4_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 11)
-#define IOC_NET_HEADER_FIELD_IPv4_DST_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 12)
-#define IOC_NET_HEADER_FIELD_IPv4_OPTS                      (IOC_NET_HEADER_FIELD_IPv4_VER << 13)
-#define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT                (IOC_NET_HEADER_FIELD_IPv4_VER << 14)
-#define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
-
-#define IOC_NET_HEADER_FIELD_IPv4_ADDR_SIZE                 4
-#define IOC_NET_HEADER_FIELD_IPv4_PROTO_SIZE                1
-
-
-typedef uint8_t ioc_header_field_ipv6_t;
-
-#define IOC_NET_HEADER_FIELD_IPv6_VER                       (1)
-#define IOC_NET_HEADER_FIELD_IPv6_TC                        (IOC_NET_HEADER_FIELD_IPv6_VER << 1)
-#define IOC_NET_HEADER_FIELD_IPv6_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 2)
-#define IOC_NET_HEADER_FIELD_IPv6_DST_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 3)
-#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR                  (IOC_NET_HEADER_FIELD_IPv6_VER << 4)
-#define IOC_NET_HEADER_FIELD_IPv6_FL                        (IOC_NET_HEADER_FIELD_IPv6_VER << 5)
-#define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (IOC_NET_HEADER_FIELD_IPv6_VER << 6)
-#define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
-
-#define IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE                 16
-#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR_SIZE             1
-
-#define IOC_NET_HEADER_FIELD_ICMP_TYPE                      (1)
-#define IOC_NET_HEADER_FIELD_ICMP_CODE                      (IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
-#define IOC_NET_HEADER_FIELD_ICMP_CKSUM                     (IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
-#define IOC_NET_HEADER_FIELD_ICMP_ID                        (IOC_NET_HEADER_FIELD_ICMP_TYPE << 3)
-#define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM                    (IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
-#define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
-
-#define IOC_NET_HEADER_FIELD_ICMP_CODE_SIZE                 1
-#define IOC_NET_HEADER_FIELD_ICMP_TYPE_SIZE                 1
-
-#define IOC_NET_HEADER_FIELD_IGMP_VERSION                   (1)
-#define IOC_NET_HEADER_FIELD_IGMP_TYPE                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
-#define IOC_NET_HEADER_FIELD_IGMP_CKSUM                     (IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
-#define IOC_NET_HEADER_FIELD_IGMP_DATA                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 3)
-#define IOC_NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
-
-
-typedef uint16_t ioc_header_field_tcp_t;
-
-#define IOC_NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
-#define IOC_NET_HEADER_FIELD_TCP_PORT_DST                   (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_TCP_SEQ                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 2)
-#define IOC_NET_HEADER_FIELD_TCP_ACK                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 3)
-#define IOC_NET_HEADER_FIELD_TCP_OFFSET                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 4)
-#define IOC_NET_HEADER_FIELD_TCP_FLAGS                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 5)
-#define IOC_NET_HEADER_FIELD_TCP_WINDOW                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 6)
-#define IOC_NET_HEADER_FIELD_TCP_CKSUM                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 7)
-#define IOC_NET_HEADER_FIELD_TCP_URGPTR                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 8)
-#define IOC_NET_HEADER_FIELD_TCP_OPTS                       (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 9)
-#define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT                 (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
-#define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
-
-#define IOC_NET_HEADER_FIELD_TCP_PORT_SIZE                  2
-
-
-typedef uint8_t ioc_header_field_sctp_t;
-
-#define IOC_NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
-#define IOC_NET_HEADER_FIELD_SCTP_PORT_DST                  (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_SCTP_VER_TAG                   (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
-#define IOC_NET_HEADER_FIELD_SCTP_CKSUM                     (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
-#define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
-
-#define IOC_NET_HEADER_FIELD_SCTP_PORT_SIZE                 2
-
-typedef uint8_t ioc_header_field_dccp_t;
-
-#define IOC_NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
-#define IOC_NET_HEADER_FIELD_DCCP_PORT_DST                  (IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
-
-#define IOC_NET_HEADER_FIELD_DCCP_PORT_SIZE                 2
-
-
-typedef uint8_t ioc_header_field_udp_t;
-
-#define IOC_NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
-#define IOC_NET_HEADER_FIELD_UDP_PORT_DST                   (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_UDP_LEN                        (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 2)
-#define IOC_NET_HEADER_FIELD_UDP_CKSUM                      (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
-#define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
-
-#define IOC_NET_HEADER_FIELD_UDP_PORT_SIZE                  2
-
-typedef uint8_t ioc_header_field_udp_lite_t;
-
-#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC              (1)
-#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_DST              (IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_UDP_LITE_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 2) - 1)
-
-#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SIZE             2
-
-typedef uint8_t ioc_header_field_udp_encap_esp_t;
-
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST         (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN              (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM            (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI              (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
-
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SIZE        2
-#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI_SIZE         4
-
-#define IOC_NET_HEADER_FIELD_IPHC_CID                       (1)
-#define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE                  (IOC_NET_HEADER_FIELD_IPHC_CID << 1)
-#define IOC_NET_HEADER_FIELD_IPHC_HCINDEX                   (IOC_NET_HEADER_FIELD_IPHC_CID << 2)
-#define IOC_NET_HEADER_FIELD_IPHC_GEN                       (IOC_NET_HEADER_FIELD_IPHC_CID << 3)
-#define IOC_NET_HEADER_FIELD_IPHC_D_BIT                     (IOC_NET_HEADER_FIELD_IPHC_CID << 4)
-#define IOC_NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPHC_CID << 5) - 1)
-
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
-
-#define IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
-#define IOC_NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
-#define IOC_NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
-#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
-#define IOC_NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
-#define IOC_NET_HEADER_FIELD_L2TPv2_VERSION                 (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
-#define IOC_NET_HEADER_FIELD_L2TPv2_LEN                     (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
-#define IOC_NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
-#define IOC_NET_HEADER_FIELD_L2TPv2_SESSION_ID              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
-#define IOC_NET_HEADER_FIELD_L2TPv2_NS                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
-#define IOC_NET_HEADER_FIELD_L2TPv2_NR                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
-#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
-#define IOC_NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
-#define IOC_NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
-
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
-
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ID                 (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
-
-
-typedef uint8_t ioc_header_field_vlan_t;
-
-#define IOC_NET_HEADER_FIELD_VLAN_VPRI                      (1)
-#define IOC_NET_HEADER_FIELD_VLAN_CFI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 1)
-#define IOC_NET_HEADER_FIELD_VLAN_VID                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 2)
-#define IOC_NET_HEADER_FIELD_VLAN_LENGTH                    (IOC_NET_HEADER_FIELD_VLAN_VPRI << 3)
-#define IOC_NET_HEADER_FIELD_VLAN_TYPE                      (IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
-#define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
-
-#define IOC_NET_HEADER_FIELD_VLAN_TCI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI | \
-                                                             IOC_NET_HEADER_FIELD_VLAN_CFI | \
-                                                             IOC_NET_HEADER_FIELD_VLAN_VID)
-
-
-typedef uint8_t ioc_header_field_llc_t;
-
-#define IOC_NET_HEADER_FIELD_LLC_DSAP                       (1)
-#define IOC_NET_HEADER_FIELD_LLC_SSAP                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 1)
-#define IOC_NET_HEADER_FIELD_LLC_CTRL                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 2)
-#define IOC_NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
-
-#define IOC_NET_HEADER_FIELD_NLPID_NLPID                    (1)
-#define IOC_NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
-
-
-typedef uint8_t ioc_header_field_snap_t;
-
-#define IOC_NET_HEADER_FIELD_SNAP_OUI                       (1)
-#define IOC_NET_HEADER_FIELD_SNAP_PID                       (IOC_NET_HEADER_FIELD_SNAP_OUI << 1)
-#define IOC_NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
-
-
-typedef uint8_t ioc_header_field_llc_snap_t;
-
-#define IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
-#define IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE << 1) - 1)
-
-#define IOC_NET_HEADER_FIELD_ARP_HTYPE                      (1)
-#define IOC_NET_HEADER_FIELD_ARP_PTYPE                      (IOC_NET_HEADER_FIELD_ARP_HTYPE << 1)
-#define IOC_NET_HEADER_FIELD_ARP_HLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 2)
-#define IOC_NET_HEADER_FIELD_ARP_PLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 3)
-#define IOC_NET_HEADER_FIELD_ARP_OPER                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 4)
-#define IOC_NET_HEADER_FIELD_ARP_SHA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 5)
-#define IOC_NET_HEADER_FIELD_ARP_SPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 6)
-#define IOC_NET_HEADER_FIELD_ARP_THA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 7)
-#define IOC_NET_HEADER_FIELD_ARP_TPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 8)
-#define IOC_NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
-
-#define IOC_NET_HEADER_FIELD_RFC2684_LLC                    (1)
-#define IOC_NET_HEADER_FIELD_RFC2684_NLPID                  (IOC_NET_HEADER_FIELD_RFC2684_LLC << 1)
-#define IOC_NET_HEADER_FIELD_RFC2684_OUI                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 2)
-#define IOC_NET_HEADER_FIELD_RFC2684_PID                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 3)
-#define IOC_NET_HEADER_FIELD_RFC2684_VPN_OUI                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 4)
-#define IOC_NET_HEADER_FIELD_RFC2684_VPN_IDX                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 5)
-#define IOC_NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
-
-#define IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
-#define IOC_NET_HEADER_FIELD_USER_DEFINED_PCDID             (IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
-#define IOC_NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
-
-#define IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
-#define IOC_NET_HEADER_FIELD_PAYLOAD_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
-#define IOC_NET_HEADER_FIELD_MAX_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
-#define IOC_NET_HEADER_FIELD_MIN_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
-#define IOC_NET_HEADER_FIELD_PAYLOAD_TYPE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
-#define IOC_NET_HEADER_FIELD_FRAME_SIZE                     (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
-#define IOC_NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
-
-
-typedef uint8_t ioc_header_field_gre_t;
-
-#define IOC_NET_HEADER_FIELD_GRE_TYPE                       (1)
-#define IOC_NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
-
-
-typedef uint8_t ioc_header_field_minencap_t;
-
-#define IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
-#define IOC_NET_HEADER_FIELD_MINENCAP_DST_IP                (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
-#define IOC_NET_HEADER_FIELD_MINENCAP_TYPE                  (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
-#define IOC_NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
-
-
-typedef uint8_t ioc_header_field_ipsec_ah_t;
-
-#define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
-#define IOC_NET_HEADER_FIELD_IPSEC_AH_NH                    (IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
-#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
-
-
-typedef uint8_t ioc_header_field_ipsec_esp_t;
-
-#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                  (1)
-#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM         (IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
-#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
-
-#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI_SIZE             4
-
-
-typedef uint8_t ioc_header_field_mpls_t;
-
-#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
-#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
-
-
-typedef uint8_t ioc_header_field_macsec_t;
-
-#define IOC_NET_HEADER_FIELD_MACSEC_SECTAG                  (1)
-#define IOC_NET_HEADER_FIELD_MACSEC_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
-
-
-typedef enum {
-    e_IOC_NET_HEADER_TYPE_NONE = 0,
-    e_IOC_NET_HEADER_TYPE_PAYLOAD,
-    e_IOC_NET_HEADER_TYPE_ETH,
-    e_IOC_NET_HEADER_TYPE_VLAN,
-    e_IOC_NET_HEADER_TYPE_IPv4,
-    e_IOC_NET_HEADER_TYPE_IPv6,
-    e_IOC_NET_HEADER_TYPE_IP,
-    e_IOC_NET_HEADER_TYPE_TCP,
-    e_IOC_NET_HEADER_TYPE_UDP,
-    e_IOC_NET_HEADER_TYPE_UDP_LITE,
-    e_IOC_NET_HEADER_TYPE_IPHC,
-    e_IOC_NET_HEADER_TYPE_SCTP,
-    e_IOC_NET_HEADER_TYPE_SCTP_CHUNK_DATA,
-    e_IOC_NET_HEADER_TYPE_PPPoE,
-    e_IOC_NET_HEADER_TYPE_PPP,
-    e_IOC_NET_HEADER_TYPE_PPPMUX,
-    e_IOC_NET_HEADER_TYPE_PPPMUX_SUBFRAME,
-    e_IOC_NET_HEADER_TYPE_L2TPv2,
-    e_IOC_NET_HEADER_TYPE_L2TPv3_CTRL,
-    e_IOC_NET_HEADER_TYPE_L2TPv3_SESS,
-    e_IOC_NET_HEADER_TYPE_LLC,
-    e_IOC_NET_HEADER_TYPE_LLC_SNAP,
-    e_IOC_NET_HEADER_TYPE_NLPID,
-    e_IOC_NET_HEADER_TYPE_SNAP,
-    e_IOC_NET_HEADER_TYPE_MPLS,
-    e_IOC_NET_HEADER_TYPE_IPSEC_AH,
-    e_IOC_NET_HEADER_TYPE_IPSEC_ESP,
-    e_IOC_NET_HEADER_TYPE_UDP_ENCAP_ESP, /* RFC 3948 */
-    e_IOC_NET_HEADER_TYPE_MACSEC,
-    e_IOC_NET_HEADER_TYPE_GRE,
-    e_IOC_NET_HEADER_TYPE_MINENCAP,
-    e_IOC_NET_HEADER_TYPE_DCCP,
-    e_IOC_NET_HEADER_TYPE_ICMP,
-    e_IOC_NET_HEADER_TYPE_IGMP,
-    e_IOC_NET_HEADER_TYPE_ARP,
-    e_IOC_NET_HEADER_TYPE_CAPWAP,
-    e_IOC_NET_HEADER_TYPE_CAPWAP_DTLS,
-    e_IOC_NET_HEADER_TYPE_RFC2684,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L2,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L3,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L4,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM1,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM2,
-    e_IOC_NET_MAX_HEADER_TYPE_COUNT
-} ioc_net_header_type;
-
-
-#endif /* __NET_IOCTLS_H */
diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
index 1a0006a..5d49673 100644
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -4,6 +4,7 @@ header-y += byteorder/
 header-y += can/
 header-y += caif/
 header-y += dvb/
+header-y += fmd/
 header-y += hdlc/
 header-y += hsi/
 header-y += iio/
diff --git a/include/uapi/linux/fmd/Kbuild b/include/uapi/linux/fmd/Kbuild
new file mode 100644
index 0000000..56a2040
--- /dev/null
+++ b/include/uapi/linux/fmd/Kbuild
@@ -0,0 +1,5 @@
+header-y += integrations/
+header-y += Peripherals/
+
+header-y += ioctls.h
+header-y += net_ioctls.h
diff --git a/include/uapi/linux/fmd/Peripherals/Kbuild b/include/uapi/linux/fmd/Peripherals/Kbuild
new file mode 100644
index 0000000..43883ef
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/Kbuild
@@ -0,0 +1,4 @@
+header-y += fm_ioctls.h
+header-y += fm_port_ioctls.h
+header-y += fm_pcd_ioctls.h
+header-y += fm_test_ioctls.h
diff --git a/include/uapi/linux/fmd/Peripherals/fm_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
new file mode 100644
index 0000000..d1b779b
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
@@ -0,0 +1,628 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_IOCTLS_H
+#define __FM_IOCTLS_H
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    FM IOCTL device ('/dev') definitions
+*//***************************************************************************/
+#define DEV_FM_NAME                 "fm" /**< Name of the FM chardev */
+
+#define DEV_FM_MINOR_BASE           0
+#define DEV_FM_PCD_MINOR_BASE       (DEV_FM_MINOR_BASE + 1)                                 /*/dev/fmx-pcd */
+#define DEV_FM_OH_PORTS_MINOR_BASE  (DEV_FM_PCD_MINOR_BASE + 1)                             /*/dev/fmx-port-ohy */
+#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OH_PORTS_MINOR_BASE + FM_MAX_NUM_OF_OH_PORTS)   /*/dev/fmx-port-rxy */
+#define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_RX_PORTS)   /*/dev/fmx-port-txy */
+#define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_TX_PORTS)
+
+#define FM_IOC_NUM(n)       (n)
+#define FM_PCD_IOC_NUM(n)   (n+20)
+#define FM_PORT_IOC_NUM(n)  (n+70)
+/* @} */
+
+#define IOC_FM_MAX_NUM_OF_PORTS         64
+
+
+/**************************************************************************//**
+ @Description   Enum for defining port types
+                (must match enum e_FmPortType defined in fm_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_type {
+    e_IOC_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port */
+    e_IOC_FM_PORT_TYPE_RX,                      /**< 1G Rx port */
+    e_IOC_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port */
+    e_IOC_FM_PORT_TYPE_TX,                      /**< 1G Tx port */
+    e_IOC_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port */
+    e_IOC_FM_PORT_TYPE_DUMMY
+} ioc_fm_port_type;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. Before any further module initialization,
+                this module must be initialized.
+                The FM is a "single-tone" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum ioc_fm_exceptions {
+    e_IOC_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_IOC_EX_DMA_READ_ECC,               /**< Read Buffer ECC error (Valid for FM rev < 6)*/
+    e_IOC_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
+    e_IOC_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
+    e_IOC_EX_DMA_SINGLE_PORT_ECC,        /**< Single Port ECC error on FM side (Valid for FM rev > 6)*/
+    e_IOC_EX_FPM_STALL_ON_TASKS,         /**< Stall of tasks on FPM */
+    e_IOC_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_IOC_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_IOC_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_IOC_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occurred on QMI */
+    e_IOC_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeue from unknown port id */
+    e_IOC_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_IOC_EX_BMI_STORAGE_PROFILE_ECC,    /**< Storage Profile ECC Error */
+    e_IOC_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_IOC_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
+    e_IOC_EX_IRAM_ECC,                   /**< Double bit ECC occurred on IRAM*/
+    e_IOC_EX_MURAM_ECC                   /**< Double bit ECC occurred on MURAM*/
+} ioc_fm_exceptions;
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines for each module.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+ *//***************************************************************************/
+#define IOC_FM_MAX_NUM_OF_VALID_PORTS  (FM_MAX_NUM_OF_OH_PORTS + \
+                                        FM_MAX_NUM_OF_1G_RX_PORTS +  \
+                                        FM_MAX_NUM_OF_10G_RX_PORTS + \
+                                        FM_MAX_NUM_OF_1G_TX_PORTS +  \
+                                        FM_MAX_NUM_OF_10G_TX_PORTS)
+/* @} */
+
+/**************************************************************************//**
+ @Description   Structure for Port bandwidth requirement. Port is identified
+                by type and relative id.
+                (must be identical to t_FmPortBandwidth defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_bandwidth_t {
+    ioc_fm_port_type    type;           /**< FM port type */
+    uint8_t             relative_port_id; /**< Type relative port id */
+    uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
+} ioc_fm_port_bandwidth_t;
+
+/**************************************************************************//**
+ @Description   A Structure containing an array of Port bandwidth requirements.
+                The user should state the ports requiring bandwidth in terms of
+                percentage - i.e. all port's bandwidths in the array must add
+                up to 100.
+                (must be identical to t_FmPortsBandwidthParams defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_bandwidth_params {
+    uint8_t                     num_of_ports;
+                                /**< num of ports listed in the array below */
+    ioc_fm_port_bandwidth_t     ports_bandwidths[IOC_FM_MAX_NUM_OF_VALID_PORTS];
+                                /**< for each port, it's bandwidth (all port's
+                                  bandwidths must add up to 100.*/
+} ioc_fm_port_bandwidth_params;
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum ioc_fm_counters {
+    e_IOC_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_IOC_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+} ioc_fm_counters;
+
+typedef struct ioc_fm_obj_t {
+    void            *obj;
+} ioc_fm_obj_t;
+
+/**************************************************************************//**
+ @Description   A structure for returning revision information
+                (must match struct t_FmRevisionInfo declared in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_revision_info_t {
+    uint8_t         major;               /**< Major revision */
+    uint8_t         minor;               /**< Minor revision */
+} ioc_fm_revision_info_t;
+
+/**************************************************************************//**
+ @Description   A structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_counters_params_t {
+    ioc_fm_counters cnt;                /**< The requested counter */
+    uint32_t        val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_counters_params_t;
+
+typedef union ioc_fm_api_version_t {
+    struct {
+        uint8_t major;
+        uint8_t minor;
+        uint8_t respin;
+        uint8_t reserved;
+    } version;
+    uint32_t ver;
+} ioc_fm_api_version_t;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by a port or storage-profile.
+                (must be identical to t_FmExtPoolParams defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_ext_pool_params {
+    uint8_t                 id;     /**< External buffer pool id */
+    uint16_t                size;   /**< External buffer pool buffer size */
+} ioc_fm_ext_pool_params;
+
+/**************************************************************************//**
+ @Description   A structure for informing the driver about the external
+                buffer pools allocated in the BM and used by a port or a
+                storage-profile.
+                (must be identical to t_FmExtPools defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_ext_pools {
+    uint8_t                 num_of_pools_used;     /**< Number of pools use by this port */
+    ioc_fm_ext_pool_params  ext_buf_pool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                /**< Parameters for each port */
+} ioc_fm_ext_pools;
+
+typedef struct ioc_fm_vsp_params_t {
+    void                *p_fm;              /**< A handle to the FM object this VSP related to */
+    ioc_fm_ext_pools    ext_buf_pools;        /**< Which external buffer pools are used
+                                                 (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes.
+                                                 parameter associated with Rx / OP port */
+    uint16_t            liodn_offset;        /**< VSP's LIODN offset */
+    struct {
+        ioc_fm_port_type port_type;          /**< Port type */
+        uint8_t         port_id;             /**< Port Id - relative to type */
+    } portParams;
+    uint8_t             relative_profile_id;  /**< VSP Id - relative to VSP's range
+                                                 defined in relevant FM object */
+    void                *id;                /**< return value */
+} ioc_fm_vsp_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   A structure for defining BM pool depletion criteria
+*//***************************************************************************/
+typedef struct ioc_fm_buf_pool_depletion_t {
+    bool        pools_grp_mode_enable;              /**< select mode in which pause frames will be sent after
+                                                         a number of pools (all together!) are depleted */
+    uint8_t     num_of_pools;                       /**< the number of depleted pools that will invoke
+                                                         pause frames transmission. */
+    bool        pools_to_consider[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!). */
+    bool        single_pool_mode_enable;            /**< select mode in which pause frames will be sent after
+                                                         a single-pool is depleted; */
+    bool        pools_to_consider_for_single_mode[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!) */
+#if (DPAA_VERSION >= 11)
+    bool        pfc_priorities_en[FM_MAX_NUM_OF_PFC_PRIORITIES];
+                                                    /**< This field is used by the MAC as the Priority Enable Vector in the PFC frame
+                                                         which is transmitted */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_buf_pool_depletion_t;
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_fm_buf_pool_depletion_params_t {
+    void        *p_fm_vsp;
+    ioc_fm_buf_pool_depletion_t fm_buf_pool_depletion;
+} ioc_fm_buf_pool_depletion_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+typedef struct ioc_fm_buffer_prefix_content_t {
+    uint16_t    priv_data_size;       /**< Number of bytes to be left at the beginning
+                                         of the external buffer; Note that the private-area will
+                                         start from the base of the buffer address. */
+    bool        pass_prs_result;      /**< TRUE to pass the parse result to/from the FM;
+                                         User may use FM_PORT_GetBufferPrsResult() in order to
+                                         get the parser-result from a buffer. */
+    bool        pass_time_stamp;      /**< TRUE to pass the timeStamp to/from the FM
+                                         User may use FM_PORT_GetBufferTimeStamp() in order to
+                                         get the parser-result from a buffer. */
+    bool        pass_hash_result;     /**< TRUE to pass the KG hash result to/from the FM
+                                         User may use FM_PORT_GetBufferHashResult() in order to
+                                         get the parser-result from a buffer. */
+    bool        pass_all_other_pcd_info; /**< Add all other Internal-Context information:
+                                         AD, hash-result, key, etc. */
+    uint16_t    data_align;          /**< 0 to use driver's default alignment [64],
+                                         other value for selecting a data alignment (must be a power of 2);
+                                         if write optimization is used, must be >= 16. */
+    uint8_t     manip_extra_space;    /**< Maximum extra size needed (insertion-size minus removal-size);
+                                         Note that this field impacts the size of the buffer-prefix
+                                         (i.e. it pushes the data offset);
+                                         This field is irrelevant if DPAA_VERSION==10 */
+} ioc_fm_buffer_prefix_content_t;
+
+typedef struct ioc_fm_buffer_prefix_content_params_t {
+    void        *p_fm_vsp;
+    ioc_fm_buffer_prefix_content_t fm_buffer_prefix_content;
+} ioc_fm_buffer_prefix_content_params_t;
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_fm_vsp_config_no_sg_params_t {
+    void        *p_fm_vsp;
+    bool        no_sg;
+} ioc_fm_vsp_config_no_sg_params_t;
+
+typedef struct ioc_fm_vsp_prs_result_params_t {
+    void        *p_fm_vsp;
+    void        *p_data;
+} ioc_fm_vsp_prs_result_params_t;
+#endif
+
+typedef struct fm_ctrl_mon_t {
+    uint8_t     percent_cnt[1];
+} fm_ctrl_mon_t;
+
+typedef struct ioc_fm_ctrl_mon_counters_params_t {
+    uint8_t     fm_ctrl_index;
+    fm_ctrl_mon_t *p_mon;
+} ioc_fm_ctrl_mon_counters_params_t;
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_PORTS_BANDWIDTH
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     ioc_fm_port_bandwidth_params    Port bandwidth percentages,
+ their sum must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_PORTS_BANDWIDTH                             _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(2), ioc_fm_port_bandwidth_params)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_REVISION
+
+ @Description   Returns the FM revision
+
+ @Param[out]    ioc_fm_revision_info_t  A structure of revision information parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_GET_REVISION                                    _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(3), ioc_fm_revision_info_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in,out] ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_IOC_GET_COUNTER                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(4), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_COUNTER                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(5), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_exceptions   An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_FORCE_INTR                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_API_VERSION
+
+ @Description   Reads the FMD IOCTL API version.
+
+ @Param[in,out] ioc_fm_api_version_t The requested counter parameters.
+
+ @Return        Version's value.
+*//***************************************************************************/
+#define FM_IOC_GET_API_VERSION                               _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(7), ioc_fm_api_version_t)
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function      FM_VSP_Config
+
+ @Description   Creates descriptor for the FM VSP module.
+
+                The routine returns a handle (descriptor) to the FM VSP object.
+                This descriptor must be passed as first parameter to all other
+                FM VSP function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+@Param[in]      p_FmVspParams   Pointer to data structure of parameters
+
+ @Retval        Handle to FM VSP object, or NULL for Failure.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_CONFIG_COMPAT                             _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(8), ioc_compat_fm_vsp_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(8), ioc_fm_vsp_params_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_Init
+
+ @Description   Initializes the FM VSP module
+
+ @Param[in]     h_FmVsp - FM VSP module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_INIT_COMPAT                               _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(9), ioc_compat_fm_obj_t)
+#endif
+#define FM_IOC_VSP_INIT                                      _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(9), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_Free
+
+ @Description   Frees all resources that were assigned to FM VSP module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmVsp - FM VSP module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_FREE_COMPAT                               _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(10), ioc_compat_fm_obj_t)
+#endif
+#define FM_IOC_VSP_FREE                                      _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(10), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+                depletion status of BM pools. It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+ @Param[in]     ioc_fm_buf_pool_depletion_params_t      A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_CONFIG_POOL_DEPLETION_COMPAT              _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(11), ioc_compat_fm_buf_pool_depletion_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG_POOL_DEPLETION                     _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(11), ioc_fm_buf_pool_depletion_params_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+
+                The prefix will
+                In VSPs defined for Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+
+ @Param[in]     ioc_fm_buffer_prefix_content_params_t   A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT_COMPAT       _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(12), ioc_compat_fm_buffer_prefix_content_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT              _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(12), ioc_fm_buffer_prefix_content_params_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigNoScatherGather
+
+ @Description   Calling this routine changes the possibility to receive S/G frame
+                in the internal driver data base
+                from its default configuration: optimize = [DEFAULT_FM_SP_noScatherGather]
+
+ @Param[in]     ioc_fm_vsp_config_no_sg_params_t        A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_CONFIG_NO_SG_COMPAT                     _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(13), ioc_compat_fm_vsp_config_no_sg_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG_NO_SG                            _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(13), ioc_fm_vsp_config_no_sg_params_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where parse result should be
+                initialized - if so configured.
+                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     ioc_fm_vsp_prs_result_params_t  A structure holding the required parameters.
+
+ @Return        Parse result pointer on success, NULL if parse result was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_VSP_GET_BUFFER_PRS_RESULT_COMPAT            _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(14), ioc_compat_fm_vsp_prs_result_params_t)
+#endif
+#define FM_IOC_VSP_GET_BUFFER_PRS_RESULT                   _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(14), ioc_fm_vsp_prs_result_params_t)
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Function      FM_CtrlMonStart
+
+ @Description   Start monitoring utilization of all available FM controllers.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_CTRL_MON_START                              _IO(FM_IOC_TYPE_BASE, FM_IOC_NUM(15))
+
+
+/**************************************************************************//**
+ @Function      FM_CtrlMonStop
+
+ @Description   Stop monitoring utilization of all available FM controllers.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_CTRL_MON_STOP                               _IO(FM_IOC_TYPE_BASE, FM_IOC_NUM(16))
+
+/**************************************************************************//**
+ @Function      FM_CtrlMonGetCounters
+
+ @Description   Obtain FM controller utilization parameters.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Param[in]     ioc_fm_ctrl_mon_counters_params_t       A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_IOC_CTRL_MON_GET_COUNTERS_COMPAT                _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(17), ioc_compat_fm_ctrl_mon_counters_params_t)
+#endif
+#define FM_IOC_CTRL_MON_GET_COUNTERS                       _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(17), ioc_fm_ctrl_mon_counters_params_t)
+
+/** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp */
+
+#define FMD_API_VERSION_MAJOR 18
+#define FMD_API_VERSION_MINOR 1
+#define FMD_API_VERSION_RESPIN 2
+
+#endif /* __FM_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
new file mode 100644
index 0000000..0123b17
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -0,0 +1,2708 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_pcd_ioctls.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_IOCTLS_H
+#define __FM_PCD_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+
+
+/**************************************************************************//**
+
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   Frame Manager Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_grp FM PCD
+
+ @Description   Frame Manager PCD API functions, definitions and enums
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and policer
+                profiles. When an FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                KeyGen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
+
+#define IOC_FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+#define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                        /**< Number of distinction units is limited by
+                                                                             register size (32 bits) minus reserved bits
+                                                                             for private headers. */
+#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers
+                                                                             in a distinction unit */
+#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KeyGen registers */
+#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration;
+                                                                             For HW implementation reasons, in most
+                                                                             cases less than this will be allowed; The
+                                                                             driver will return an initialization error
+                                                                             if resource is unavailable. */
+#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KeyGen extractions. */
+#define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Maximum number of SW parser labels */
+#define IOC_FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of SW parser area */
+#define IOC_FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
+                                                                             of the SW parser area */
+#if DPAA_VERSION >= 11
+#define IOC_FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000240          /**< Number of bytes saved for patches */
+#else
+#define IOC_FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000200          /**< Number of bytes saved for patches */
+#endif
+
+#define IOC_FM_PCD_PRS_SW_TAIL_SIZE                     4                   /**< Number of bytes that must be cleared at
+                                                                             the end of the SW parser area */
+#define IOC_FM_SW_PRS_MAX_IMAGE_SIZE                    (IOC_FM_PCD_SW_PRS_SIZE-IOC_FM_PCD_PRS_SW_OFFSET-IOC_FM_PCD_PRS_SW_TAIL_SIZE-IOC_FM_PCD_PRS_SW_PATCHES_SIZE)
+                                                                        /**< Maximum size of SW parser code */
+
+#define IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
+                                                                             insert manipulation */
+
+#if DPAA_VERSION >= 11
+#define IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
+#endif /* DPAA_VERSION >= 11 */
+/* @} */
+
+#ifdef FM_CAPWAP_SUPPORT
+#error "FM_CAPWAP_SUPPORT not implemented!"
+#endif
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_init_grp FM PCD Initialization Unit
+
+ @Description   Frame Manager PCD Initialization Unit API
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+                (must match enum e_FmPcdCounters defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_counters {
+    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< KeyGen counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter - counts the total number of RED packets that exit the Policer. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter - counts the total number of YELLOW packets that exit the Policer. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter - counts the number of packets that changed color to RED by the Policer;
+                                                                         This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_RED packet count, indicating active color changes. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter - counts the number of packets that changed color to YELLOW by the Policer;
+                                                                         This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW packet count, indicating active color changes. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter - counts the total number of packets passed in the Policer. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter - counts the number of packets with length mismatch. */
+    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter - counts the number of times the parser block is dispatched. */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L2 parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L3 parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L4 parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter - counts the number of times SHIM parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L2 parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L3 parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L4 parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter - counts the number of times SHIM parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter - counts the number of cycles spent executing soft parser instruction (including stall cycles). */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter - counts the number of cycles stalled waiting for parser internal memory reads while executing soft parser instruction. */
+    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter - counts the number of cycles spent executing hard parser (including stall cycles). */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter - counts the number of cycles while performing FMan Memory read. */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory read. */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter - counts the number of cycles while performing FMan Memory write. */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory write. */
+    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter - counts the number of cycles stalled while performing a FPM Command. */
+} ioc_fm_pcd_counters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+                (must match enum e_FmPcdExceptions defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_exceptions {
+    e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< KeyGen double-bit ECC error is detected on internal memory read access. */
+    e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< KeyGen scheme configuration error indicating a key size larger than 56 bytes. */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Policer double-bit ECC error has been detected on PRAM read access. */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Policer access to a non-initialized profile has been detected. */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,    /**< Policer RAM self-initialization complete */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,     /**< Policer atomic action complete */
+    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                  /**< Parser double-bit ECC error */
+    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                   /**< Parser single-bit ECC error */
+} ioc_fm_pcd_exceptions;
+
+/** @} */ /* end of lnx_ioctl_FM_PCD_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   Frame Manager PCD Runtime Unit
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as KeyGen schemes, coarse classification nodes
+                and Policer profiles.
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  - Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the SHIM headers (1 or 2). May be a header with a special
+                    option (see below).
+                  - Interchangeable Headers Group - This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    interchangeable Headers Unit consisting of these 2 headers.
+                  - A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  - Header with special option - applies to Ethernet, MPLS, VLAN, IPv4 and
+                    IPv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  - Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by KeyGen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_counters_params_t {
+    ioc_fm_pcd_counters cnt;                /**< The requested counter */
+    uint32_t            val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_pcd_counters_params_t;
+
+/**************************************************************************//**
+ @Description   structure for FM exception definitios
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_exception_params_t {
+    ioc_fm_pcd_exceptions exception;        /**< The requested exception */
+    bool                  enable;           /**< TRUE to enable interrupt, FALSE to mask it. */
+} ioc_fm_pcd_exception_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for SW parser labels
+                (must be identical to struct t_FmPcdPrsLabelParams defined in fm_pcd_ext.h)
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_label_params_t {
+    uint32_t                instruction_offset;             /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    ioc_net_header_type     hdr;                            /**< The existence of this header will invoke
+                                                                 the SW parser code. */
+    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one SW parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} ioc_fm_pcd_prs_label_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for SW parser
+                (Must match struct t_FmPcdPrsSwParams defined in fm_pcd_ext.h)
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_sw_params_t {
+    bool                    override;                   /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patches.
+                                                             TRUE to override any existing code.*/
+    uint32_t                size;                       /**< SW parser code size */
+    uint16_t                base;                       /**< SW parser base (in instruction counts!
+                                                             must be larger than 0x20)*/
+    uint8_t                 *p_code;                    /**< SW parser code */
+    uint32_t                sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                 num_of_labels;              /**< Number of labels for SW parser. */
+    ioc_fm_pcd_prs_label_params_t labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table,
+                                                             containing num_of_labels entries */
+} ioc_fm_pcd_prs_sw_params_t;
+
+/**************************************************************************//**
+ @Description   A structure to set the a KeyGen default value
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
+    uint8_t                         valueId;                /**< 0,1 - one of 2 global default values */
+    uint32_t                        value;                  /**< The requested default value */
+} ioc_fm_pcd_kg_dflt_value_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_Enable
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PCD_Disable
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is enabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
+
+ /**************************************************************************//**
+ @Function      FM_PCD_PrsLoadSw
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases it is recommended in order to save resources.
+                The driver automatically saves 8 classification plans for
+                ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be called.
+
+ @Param[in]     ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_PRS_LOAD_SW_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_compat_fm_pcd_prs_sw_params_t)
+#endif
+#define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetDfltValue
+
+ @Description   Calling this routine sets a global default value to be used
+                by the KeyGen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetAdditionalDataAfterParsing
+
+ @Description   Calling this routine allows the keygen to access data past
+                the parser finishing point.
+
+ @Param[in]     uint8_t   payload-offset; the number of bytes beyond the parser location.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetException
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     ioc_fm_pcd_exception_params_t     Arguments struct with exception to be enabled/disabled.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_GetCounter
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
+
+#if 0
+TODO: unused IOCTL
+/**************************************************************************//**
+ @Function      FM_PCD_ModifyCounter
+
+ @Description   Writes a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_pcd_counters_params_t - The requested counter parameters.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_MODIFY_COUNTER   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+#define FM_PCD_IOC_SET_COUNTER      FM_PCD_IOC_MODIFY_COUNTER
+#endif
+
+/**************************************************************************//**
+ @Function      FM_PCD_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_pcd_exceptions - An exception to be forced.
+
+ @Return        0 on success; error code if the exception is not enabled,
+                or is not able to create interrupt.
+*//***************************************************************************/
+#define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification parameters as required by KeyGen
+                (when coarse classification is the next engine after this scheme).
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_CC_TREES              8
+#define IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS             16
+#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS              4
+#define IOC_FM_PCD_MAX_NUM_OF_KEYS                  256
+#define IOC_FM_PCD_MAX_NUM_OF_FLOWS                 (4*KILOBYTE)
+#define IOC_FM_PCD_MAX_SIZE_OF_KEY                  56
+#define IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
+#define IOC_FM_PCD_LAST_KEY_INDEX                   0xffff
+#define IOC_FM_PCD_MANIP_DSCP_VALUES                64
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t            ioc_protocol_opt_t;      /**< A general type to define a protocol option. */
+
+typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol options. */
+#define IOC_ETH_BROADCAST               0x80000000   /**< Ethernet Broadcast. */
+#define IOC_ETH_MULTICAST               0x40000000   /**< Ethernet Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
+#define IOC_VLAN_STACKED                0x20000000   /**< Stacked VLAN. */
+
+typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
+#define IOC_MPLS_STACKED                0x10000000   /**< Stacked MPLS. */
+
+typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
+#define IOC_IPV4_BROADCAST_1            0x08000000   /**< IPv4 Broadcast. */
+#define IOC_IPV4_MULTICAST_1            0x04000000   /**< IPv4 Multicast. */
+#define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
+#define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+#define IOC_IPV4_FRAG_1                 0x00000008   /**< IPV4 reassembly option.
+                                                          IPV4 Reassembly manipulation requires network
+                                                          environment with IPV4 header and IPV4_FRAG_1 option  */
+
+typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
+#define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
+#define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
+#define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
+
+#define IOC_IPV6_FRAG_1                 0x00000004   /**< IPV6 reassembly option.
+                                                          IPV6 Reassembly manipulation requires network
+                                                          environment with IPV6 header and IPV6_FRAG_1 option  */
+
+/* @} */
+
+#define IOC_FM_PCD_MANIP_MAX_HDR_SIZE               256
+#define IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS         64
+/**************************************************************************//**
+ @Collection    A set of definitions to support Header Manipulation selection.
+*//***************************************************************************/
+typedef uint32_t                        ioc_hdr_manip_flags_t;              /**< A general type to define a HMan update command flags. */
+
+typedef ioc_hdr_manip_flags_t           ioc_ipv4_hdr_manip_update_flags_t;  /**< IPv4 protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_IPV4_TOS          0x80000000          /**< update TOS with the given value ('tos' field
+                                                                 of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_ID           0x40000000          /**< update IP ID with the given value ('id' field
+                                                                 of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_TTL          0x20000000          /**< Decrement TTL by 1 */
+#define IOC_HDR_MANIP_IPV4_SRC          0x10000000          /**< update IP source address with the given value
+                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_DST          0x08000000          /**< update IP destination address with the given value
+                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+
+typedef ioc_hdr_manip_flags_t           ioc_ipv6_hdr_manip_update_flags_t;  /**< IPv6 protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_IPV6_TC           0x80000000          /**< update Traffic Class address with the given value
+                                                                 ('traffic_class' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+#define IOC_HDR_MANIP_IPV6_HL           0x40000000          /**< Decrement Hop Limit by 1 */
+#define IOC_HDR_MANIP_IPV6_SRC          0x20000000          /**< update IP source address with the given value
+                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+#define IOC_HDR_MANIP_IPV6_DST          0x10000000          /**< update IP destination address with the given value
+                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+
+typedef ioc_hdr_manip_flags_t           ioc_tcp_udp_hdr_manip_update_flags_t;/**< TCP/UDP protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_TCP_UDP_SRC       0x80000000          /**< update TCP/UDP source address with the given value
+                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
+#define IOC_HDR_MANIP_TCP_UDP_DST       0x40000000          /**< update TCP/UDP destination address with the given value
+                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
+#define IOC_HDR_MANIP_TCP_UDP_CHECKSUM  0x20000000          /**< update TCP/UDP checksum */
+
+/* @} */
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   All PCD engines
+                (must match enum e_FmPcdEngine defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_engine {
+    e_IOC_FM_PCD_INVALID = 0,   /**< Invalid PCD engine */
+    e_IOC_FM_PCD_DONE,          /**< No PCD Engine indicated */
+    e_IOC_FM_PCD_KG,            /**< KeyGen */
+    e_IOC_FM_PCD_CC,            /**< Coarse Classifier */
+    e_IOC_FM_PCD_PLCR,          /**< Policer */
+    e_IOC_FM_PCD_PRS,           /**< Parser */
+#if DPAA_VERSION >= 11
+    e_IOC_FM_PCD_FR,            /**< Frame Replicator */
+#endif /* DPAA_VERSION >= 11 */
+    e_IOC_FM_PCD_HASH           /**< Hash Table */
+} ioc_fm_pcd_engine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+                (Must match enum e_FmPcdExtractByHdrType defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_by_hdr_type {
+    e_IOC_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_IOC_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_IOC_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} ioc_fm_pcd_extract_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source (when it is not the header)
+                (Must match enum e_FmPcdExtractFrom defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_from {
+    e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
+    e_IOC_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
+    e_IOC_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG only: Extract from the point where parsing had finished */
+    e_IOC_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
+    e_IOC_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
+    e_IOC_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG & CC: Extract from the parser result */
+    e_IOC_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
+    e_IOC_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
+} ioc_fm_pcd_extract_from;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_type {
+    e_IOC_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_IOC_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} ioc_fm_pcd_extract_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_extract_dflt_select {
+    e_IOC_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_IOC_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_IOC_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} ioc_fm_pcd_kg_extract_dflt_select;
+
+/**************************************************************************//**
+ @Description   Enumeration type defining all default groups - each group shares
+                a default value, one of four user-initialized values.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
+    e_IOC_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_IOC_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_IOC_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_IOC_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_IOC_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_IOC_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_IOC_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_IOC_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_IOC_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_IOC_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_IOC_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_IOC_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_IOC_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by SW,
+                                                 any data extraction that is not the full
+                                                 field described above  */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by SW,
+                                                 any data extraction without validation */
+    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by SW,
+                                                 extraction from parser result or
+                                                 direct use of default value  */
+} ioc_fm_pcd_kg_known_fields_dflt_types;
+
+/**************************************************************************//**
+ @Description   Enumeration type for defining header index for scenarios with
+                multiple (tunneled) headers
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_hdr_index {
+    e_IOC_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
+                                                     to specify regular IP (not tunneled). */
+    e_IOC_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
+    e_IOC_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
+} ioc_fm_pcd_hdr_index;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile functional type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_profile_type_selection {
+    e_IOC_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
+    e_IOC_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
+} ioc_fm_pcd_profile_type_selection;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile algorithm
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_algorithm_selection {
+    e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
+    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorithm RFC 2698 */
+    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorithm RFC 4115 */
+} ioc_fm_pcd_plcr_algorithm_selection;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting a policer profile color mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color_mode {
+    e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
+    e_IOC_FM_PCD_PLCR_COLOR_AWARE   /**< Color aware */
+} ioc_fm_pcd_plcr_color_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting a policer profile color
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color {
+    e_IOC_FM_PCD_PLCR_GREEN,    /**< Green */
+    e_IOC_FM_PCD_PLCR_YELLOW,   /**< Yellow */
+    e_IOC_FM_PCD_PLCR_RED,      /**< Red */
+    e_IOC_FM_PCD_PLCR_OVERRIDE  /**< Color override */
+} ioc_fm_pcd_plcr_color;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_frame_length_select {
+  e_IOC_FM_PCD_PLCR_L2_FRM_LEN,     /**< L2 frame length */
+  e_IOC_FM_PCD_PLCR_L3_FRM_LEN,     /**< L3 frame length */
+  e_IOC_FM_PCD_PLCR_L4_FRM_LEN,     /**< L4 frame length */
+  e_IOC_FM_PCD_PLCR_FULL_FRM_LEN    /**< Full frame length */
+} ioc_fm_pcd_plcr_frame_length_select;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting roll-back frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
+  e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
+  e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} ioc_fm_pcd_plcr_roll_back_frame_select;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_rate_mode {
+    e_IOC_FM_PCD_PLCR_BYTE_MODE,    /**< Byte mode */
+    e_IOC_FM_PCD_PLCR_PACKET_MODE   /**< Packet mode */
+} ioc_fm_pcd_plcr_rate_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for defining action of frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_done_action {
+    e_IOC_FM_PCD_ENQ_FRAME = 0,     /**< Enqueue frame */
+    e_IOC_FM_PCD_DROP_FRAME         /**< Drop frame */
+} ioc_fm_pcd_done_action;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer counter
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_profile_counters {
+    e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} ioc_fm_pcd_plcr_profile_counters;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the PCD action after extraction
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_action {
+    e_IOC_FM_PCD_ACTION_NONE,                           /**< NONE  */
+    e_IOC_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction*/
+    e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
+} ioc_fm_pcd_action;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of insert manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_type {
+    e_IOC_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
+#ifdef FM_CAPWAP_SUPPORT
+    e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
+#endif /* FM_CAPWAP_SUPPORT */
+} ioc_fm_pcd_manip_hdr_insrt_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of remove manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_type {
+    e_IOC_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
+} ioc_fm_pcd_manip_hdr_rmv_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_specific_l2 {
+    e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET,                /**< Ethernet/802.3 MAC */
+    e_IOC_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS,           /**< stacked QTags */
+    e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS,       /**< MPLS and Ethernet/802.3 MAC header until
+                                                             the header which follows the MPLS header */
+    e_IOC_FM_PCD_MANIP_HDR_RMV_MPLS                     /**< Remove MPLS header (Unlimited MPLS labels) */
+} ioc_fm_pcd_manip_hdr_rmv_specific_l2;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific fields updates
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_field_update_type {
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN,           /**< VLAN updates */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4,           /**< IPV4 updates */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6,           /**< IPV6 updates */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP,        /**< TCP_UDP updates */
+} ioc_fm_pcd_manip_hdr_field_update_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting VLAN updates
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_field_update_vlan {
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI,      /**< Replace VPri of outer most VLAN tag. */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN    /**< DSCP to VLAN priority bits translation */
+} ioc_fm_pcd_manip_hdr_field_update_vlan;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_specific_l2 {
+    e_IOC_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
+} ioc_fm_pcd_manip_hdr_insrt_specific_l2;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header insertion
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_by_hdr_type {
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2         /**< Specific L2 fields insertion */
+} ioc_fm_pcd_manip_hdr_insrt_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific custom command
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_custom_type {
+    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE,           /**< Replace IPv4/IPv6 */
+} ioc_fm_pcd_manip_hdr_custom_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific custom command
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_custom_ip_replace {
+    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6, /**< Replace IPv4 by IPv6 */
+    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4  /**< Replace IPv6 by IPv4 */
+} ioc_fm_pcd_manip_hdr_custom_ip_replace;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_by_hdr_type {
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0       /**< Specific L2 fields removal */
+#ifdef FM_CAPWAP_SUPPORT
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
+#endif /* FM_CAPWAP_SUPPORT */
+} ioc_fm_pcd_manip_hdr_rmv_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of timeout mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_reassem_time_out_mode {
+    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES,         /**< Limits the time of the reassembly process
+                                                             from the first fragment to the last */
+    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG            /**< Limits the time of receiving the fragment */
+} ioc_fm_pcd_manip_reassem_time_out_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of WaysNumber mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_reassem_ways_number {
+    e_IOC_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< One way hash    */
+    e_IOC_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< Two ways hash   */
+    e_IOC_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< Three ways hash */
+    e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< Four ways hash  */
+    e_IOC_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< Five ways hash  */
+    e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< Six ways hash   */
+    e_IOC_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< Seven ways hash */
+    e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< Eight ways hash */
+} ioc_fm_pcd_manip_reassem_ways_number;
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_stats {
+    e_IOC_FM_PCD_STATS_PER_FLOWID = 0       /**< Flow ID is used as index for getting statistics */
+} ioc_fm_pcd_stats;
+#endif
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting manipulation type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_type {
+    e_IOC_FM_PCD_MANIP_HDR = 0,             /**< Header manipulation */
+    e_IOC_FM_PCD_MANIP_REASSEM,             /**< Reassembly */
+    e_IOC_FM_PCD_MANIP_FRAG,                /**< Fragmentation */
+    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD      /**< Special Offloading */
+} ioc_fm_pcd_manip_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_cc_stats_mode {
+    e_IOC_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
+    e_IOC_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
+    e_IOC_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
+    e_IOC_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics */
+} ioc_fm_pcd_cc_stats_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for determining the action in case an IP packet
+                is larger than MTU but its DF (Don't Fragment) bit is set.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_dont_frag_action {
+    e_IOC_FM_PCD_MANIP_DISCARD_PACKET = 0,      /**< Discard packet */
+    e_IOC_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET =  e_IOC_FM_PCD_MANIP_DISCARD_PACKET,
+                                                /**< Obsolete, cannot enqueue to error queue;
+                                                     In practice, selects to discard packets;
+                                                     Will be removed in the future */
+    e_IOC_FM_PCD_MANIP_FRAGMENT_PACKECT,        /**< Fragment packet and continue normal processing */
+    e_IOC_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG    /**< Continue normal processing without fragmenting the packet */
+} ioc_fm_pcd_manip_dont_frag_action;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of special offload manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_special_offload_type {
+    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC    /**< IPSec offload manipulation */
+} ioc_fm_pcd_manip_special_offload_type;
+
+/**************************************************************************//**
+ @Description   A union of protocol dependent special options
+                (Must match union u_FmPcdHdrProtocolOpt defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_protocol_opt_u {
+    ioc_eth_protocol_opt_t    eth_opt;     /**< Ethernet options */
+    ioc_vlan_protocol_opt_t   vlan_opt;    /**< Vlan options */
+    ioc_mpls_protocol_opt_t   mpls_opt;    /**< MPLS options */
+    ioc_ipv4_protocol_opt_t   ipv4_opt;    /**< IPv4 options */
+    ioc_ipv6_protocol_opt_t   ipv6_opt;    /**< IPv6 options */
+} ioc_fm_pcd_hdr_protocol_opt_u;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union ioc_fm_pcd_fields_u {
+    ioc_header_field_eth_t              eth;            /**< Ethernet               */
+    ioc_header_field_vlan_t             vlan;           /**< VLAN                   */
+    ioc_header_field_llc_snap_t         llc_snap;       /**< LLC SNAP               */
+    ioc_header_field_pppoe_t            pppoe;          /**< PPPoE                  */
+    ioc_header_field_mpls_t             mpls;           /**< MPLS                   */
+    ioc_header_field_ip_t               ip;             /**< IP                     */
+    ioc_header_field_ipv4_t             ipv4;           /**< IPv4                   */
+    ioc_header_field_ipv6_t             ipv6;           /**< IPv6                   */
+    ioc_header_field_udp_t              udp;            /**< UDP                    */
+    ioc_header_field_tcp_t              tcp;            /**< TCP                    */
+    ioc_header_field_sctp_t             sctp;           /**< SCTP                   */
+    ioc_header_field_dccp_t             dccp;           /**< DCCP                   */
+    ioc_header_field_gre_t              gre;            /**< GRE                    */
+    ioc_header_field_minencap_t         minencap;       /**< Minimal Encapsulation  */
+    ioc_header_field_ipsec_ah_t         ipsec_ah;       /**< IPSec AH               */
+    ioc_header_field_ipsec_esp_t        ipsec_esp;      /**< IPSec ESP              */
+    ioc_header_field_udp_encap_esp_t    udp_encap_esp;  /**< UDP Encapsulation ESP  */
+} ioc_fm_pcd_fields_u;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_hdr_t {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_hdr_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_field_t {
+    ioc_fm_pcd_fields_u field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_field_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single network environment unit
+                A distinction unit should be defined if it will later be used
+                by one or more PCD engines to distinguish between flows.
+                (Must match struct t_FmPcdDistinctionUnit defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_distinction_unit_t {
+    struct {
+        ioc_net_header_type             hdr;                /**< One of the headers supported by the FM */
+        ioc_fm_pcd_hdr_protocol_opt_u   opt;                /**< Select only one option! */
+    } hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS];
+} ioc_fm_pcd_distinction_unit_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining all different distinction units supported
+                by a specific PCD Network Environment Characteristics module.
+
+                Each unit represent a protocol or a group of protocols that may
+                be used later by the different PCD engines to distinguish between flows.
+                (Must match struct t_FmPcdNetEnvParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_net_env_params_t {
+    uint8_t                         num_of_distinction_units;/**< Number of different units to be identified */
+    ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                            /**< An array of num_of_distinction_units of the
+                                                                     different units to be identified */
+    void                            *id;                    /**< Output parameter; Returns the net-env Id to be used */
+} ioc_fm_pcd_net_env_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single extraction action when
+                creating a key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_extract_entry_t {
+    ioc_fm_pcd_extract_type                 type;           /**< Extraction type select */
+    union {
+        struct {
+            ioc_net_header_type             hdr;            /**< Header selection */
+            bool                            ignore_protocol_validation;
+                                                            /**< Ignore protocol validation */
+            ioc_fm_pcd_hdr_index            hdr_index;      /**< Relevant only for MPLS, VLAN and tunneled
+                                                                 IP. Otherwise should be cleared.*/
+            ioc_fm_pcd_extract_by_hdr_type  type;           /**< Header extraction type select */
+            union {
+                ioc_fm_pcd_from_hdr_t       from_hdr;       /**< Extract bytes from header parameters */
+                ioc_fm_pcd_from_field_t     from_field;     /**< Extract bytes from field parameters */
+                ioc_fm_pcd_fields_u         full_field;     /**< Extract full field parameters */
+            } extract_by_hdr_type;
+        } extract_by_hdr;                                   /**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+        struct {
+            ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
+            ioc_fm_pcd_action               action;         /**< Relevant for CC Only */
+            uint16_t                        ic_indx_mask;   /**< Relevant only for CC when
+                                                                 action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP;
+                                                                 Note that the number of bits that are set within
+                                                                 this mask must be log2 of the CC-node 'num_of_keys'.
+                                                                 Note that the mask cannot be set on the lower bits. */
+            uint8_t                         offset;         /**< Byte offset */
+            uint8_t                         size;           /**< Size in bytes */
+        } extract_non_hdr;                                  /**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extract_params;
+} ioc_fm_pcd_extract_entry_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+                field in the key.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_mask_t {
+    uint8_t                extract_array_index;         /**< Index in the extraction array, as initialized by user */
+    uint8_t                offset;                      /**< Byte offset */
+    uint8_t                mask;                        /**< A byte mask (selected bits will be ignored) */
+} ioc_fm_pcd_kg_extract_mask_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+                of fields
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_dflt_t {
+    ioc_fm_pcd_kg_known_fields_dflt_types    type;          /**< Default type select*/
+    ioc_fm_pcd_kg_extract_dflt_select        dflt_select;   /**< Default register select */
+} ioc_fm_pcd_kg_extract_dflt_t;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+                generation a key and using a hash function
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
+    uint32_t                            private_dflt0;          /**< Scheme default register 0 */
+    uint32_t                            private_dflt1;          /**< Scheme default register 1 */
+    uint8_t                             num_of_used_extracts;   /**< defines the valid size of the following array */
+    ioc_fm_pcd_extract_entry_t          extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+                                                                /**< An array of extraction definitions. */
+    uint8_t                             num_of_used_dflts;      /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_dflt_t        dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+                                                                /**< For each extraction used in this scheme, specify the required
+                                                                     default register to be used when header is not found.
+                                                                     types not specified in this array will get undefined value. */
+    uint8_t                             num_of_used_masks;      /**< Defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_mask_t        masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                             hash_shift;             /**< Hash result right shift.
+                                                                     Selects the 24 bits out of the 64 hash result.
+                                                                     0 means using the 24 LSB's, otherwise use the
+                                                                     24 LSB's after shifting right.*/
+    uint32_t                            hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
+                                                                             of queues for the key and hash functionality */
+    uint8_t                             hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
+    bool                                symmetric_hash;         /**< TRUE to generate the same hash for frames with swapped source and
+                                                                     destination fields on all layers; If TRUE, driver will check that for
+                                                                     all layers, if SRC extraction is selected, DST extraction must also be
+                                                                     selected, and vice versa. */
+} ioc_fm_pcd_kg_key_extract_and_hash_params_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+                Qid mask (extracted OR).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extracted_or_params_t {
+    ioc_fm_pcd_extract_type                 type;               /**< Extraction type select */
+    union {
+        struct {                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;
+            ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
+                                                                     IP. Otherwise should be cleared.*/
+            bool                            ignore_protocol_validation;
+
+        } extract_by_hdr;
+        ioc_fm_pcd_extract_from             src;                /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extract_params;
+    uint8_t                                 extraction_offset;  /**< Offset for extraction */
+    ioc_fm_pcd_kg_extract_dflt_select       dflt_value;         /**< Select register from which extraction is taken if
+                                                                     field not found */
+    uint8_t                                 mask;               /**< Mask LSB byte of extraction (specified bits are ignored) */
+    uint8_t                         bit_offset_in_fqid;    /**< 0-31, Selects which bits of the 24 FQID bits to effect using
+                                                             the extracted byte; Assume byte is placed as the 8 MSB's in
+                                                             a 32 bit word where the lower bits
+                                                             are the FQID; i.e if bitOffsetInFqid=1 than its LSB
+                                                             will effect the FQID MSB, if bitOffsetInFqid=24 than the
+                                                             extracted byte will effect the 8 LSB's of the FQID,
+                                                             if bitOffsetInFqid=31 than the byte's MSB will effect
+                                                             the FQID's LSB; 0 means - no effect on FQID;
+                                                             Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+    uint8_t                         bit_offset_in_plcr_profile;
+                                                        /**< 0-15, Selects which bits of the 8 policer profile id bits to
+                                                             effect using the extracted byte; Assume byte is placed
+                                                             as the 8 MSB's in a 16 bit word where the lower bits
+                                                             are the policer profile id; i.e if bitOffsetInPlcrProfile=1
+                                                             than its LSB will effect the profile MSB, if bitOffsetInFqid=8
+                                                             than the extracted byte will effect the whole policer profile id,
+                                                             if bitOffsetInFqid=15 than the byte's MSB will effect
+                                                             the Policer Profile id's LSB;
+                                                             0 means - no effect on policer profile; Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+} ioc_fm_pcd_kg_extracted_or_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_counter_t {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter; clear this field to reset the counter. */
+} ioc_fm_pcd_kg_scheme_counter_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile parameters as required by keygen
+                (when policer is the next engine after this scheme).
+                (Must match struct t_FmPcdKgPlcrProfile defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_plcr_profile_t {
+    bool                shared_profile;                 /**< TRUE if this profile is shared between ports
+                                                             (i.e. managed by master partition) May not be TRUE
+                                                             if profile is after Coarse Classification*/
+    bool                direct;                         /**< If TRUE, direct_relative_profile_id only selects the profile
+                                                             id, if FALSE fqid_offset_relative_profile_id_base is used
+                                                             together with fqid_offset_shift and num_of_profiles
+                                                             parameters, to define a range of profiles from
+                                                             which the KeyGen result will determine the
+                                                             destination policer profile.  */
+    union {
+        uint16_t        direct_relative_profile_id;     /**< Used if 'direct' is TRUE, to select policer profile.
+                                                             This parameter should indicate the policer profile offset within the port's
+                                                             policer profiles or SHARED window. */
+        struct {
+            uint8_t     fqid_offset_shift;              /**< Shift of KG results without the qid base */
+            uint8_t     fqid_offset_relative_profile_id_base;
+                                                        /**< OR of KG results without the qid base
+                                                             This parameter should indicate the policer profile
+                                                             offset within the port's policer profiles window
+                                                             or SHARED window depends on shared_profile */
+            uint8_t     num_of_profiles;                /**< Range of profiles starting at base */
+        } indirect_profile;                             /**< Indirect profile parameters */
+    } profile_select;                                   /**< Direct/indirect profile selection and parameters */
+} ioc_fm_pcd_kg_plcr_profile_t;
+
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   Parameters for configuring a storage profile for a KeyGen scheme.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_storage_profile_t {
+    bool                direct;                     /**< If TRUE, directRelativeProfileId only selects the
+                                                         profile id;
+                                                         If FALSE, fqidOffsetRelativeProfileIdBase is used
+                                                         together with fqidOffsetShift and numOfProfiles
+                                                         parameters to define a range of profiles from which
+                                                         the KeyGen result will determine the destination
+                                                         storage profile. */
+    union {
+        uint16_t        direct_relative_profileId;    /**< Used when 'direct' is TRUE, to select a storage profile;
+                                                         should indicate the storage profile offset within the
+                                                         port's storage profiles window. */
+        struct {
+            uint8_t     fqid_offset_shift;            /**< Shift of KeyGen results without the FQID base */
+            uint8_t     fqid_offset_relative_profile_id_base;
+                                                    /**< OR of KeyGen results without the FQID base;
+                                                         should indicate the policer profile offset within the
+                                                         port's storage profiles window. */
+            uint8_t     num_of_profiles;              /**< Range of profiles starting at base. */
+        } indirect_profile;                          /**< Indirect profile parameters. */
+    } profile_select;                                /**< Direct/indirect profile selection and parameters. */
+} ioc_fm_pcd_kg_storage_profile_t;
+#endif /* DPAA_VERSION >= 11 */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after KeyGen
+                (Must match struct t_FmPcdKgCc defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_cc_t {
+    void                            *tree_id;           /**< CC Tree id */
+    uint8_t                         grp_id;             /**< CC group id within the CC tree */
+    bool                            plcr_next;          /**< TRUE if after CC, in case of data frame,
+                                                             policing is required. */
+    bool                            bypass_plcr_profile_generation;
+                                                        /**< TRUE to bypass KeyGen policer profile generation;
+                                                             selected profile is the one set at port initialization. */
+    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< Valid only if plcr_next = TRUE and
+                                                             bypass_plcr_profile_generation = FALSE */
+} ioc_fm_pcd_kg_cc_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining initializing a KeyGen scheme
+                (Must match struct t_FmPcdKgSchemeParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_params_t {
+    bool                                modify;         /**< TRUE to change an existing scheme */
+    union {
+        uint8_t                         relative_scheme_id;
+                                                        /**< if modify=FALSE: partition-relative scheme id */
+        void                            *scheme_id;     /**< if modify=TRUE: the id of an existing scheme */
+    } scm_id;
+    bool                                always_direct;  /**< This scheme is reached only directly, i.e. no need
+                                                             for match vector; KeyGen will ignore it when matching */
+    struct {                                            /**< HL relevant only if always_direct=FALSE */
+        void                            *net_env_id;    /**< The id of the Network Environment as returned
+                                                             by FM_PCD_NetEnvCharacteristicsSet() */
+        uint8_t                         num_of_distinction_units;
+                                                        /**< Number of NetEnv units listed in unit_ids array */
+        uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                        /**< Indexes as passed to SetNetEnvCharacteristics (?) array */
+    } net_env_params;
+    bool                                use_hash;       /**< use the KG Hash functionality */
+    ioc_fm_pcd_kg_key_extract_and_hash_params_t key_extract_and_hash_params;
+                                                        /**< used only if useHash = TRUE */
+    bool                                bypass_fqid_generation;
+                                                        /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
+                                                             In such a case FQID after KG will be the default FQID
+                                                             defined for the relevant port, or the FQID defined by CC
+                                                             in cases where CC was the previous engine. */
+    uint32_t                            base_fqid;      /**< Base FQID; Relevant only if bypass_fqid_generation = FALSE;
+                                                             If hash is used and an even distribution is expected
+                                                             according to hash_distribution_num_of_fqids, base_fqid must be aligned to
+                                                             hash_distribution_num_of_fqids. */
+    uint8_t                             num_of_used_extracted_ors;
+                                                        /**< Number of FQID masks listed in extracted_ors array*/
+    ioc_fm_pcd_kg_extracted_or_params_t extracted_ors[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                        /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                             registers are shared between qid_masks
+                                                             functionality and some of the extraction
+                                                             actions; Normally only some will be used
+                                                             for qid_mask. Driver will return error if
+                                                             resource is full at initialization time. */
+#if DPAA_VERSION >= 11
+    bool                                override_storage_profile;
+                                                        /**< TRUE if KeyGen override previously decided storage profile */
+    ioc_fm_pcd_kg_storage_profile_t     storage_profile;/**< Used when override_storage_profile=TRUE */
+#endif /* DPAA_VERSION >= 11 */
+    ioc_fm_pcd_engine                   next_engine;     /**< may be BMI, PLCR or CC */
+    union {                                              /**< depends on nextEngine */
+        ioc_fm_pcd_done_action          done_action;     /**< Used when next engine is BMI (done) */
+        ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;    /**< Used when next engine is PLCR */
+        ioc_fm_pcd_kg_cc_t              cc;              /**< Used when next engine is CC */
+    } kg_next_engine_params;
+    ioc_fm_pcd_kg_scheme_counter_t      scheme_counter;  /**< A structure of parameters for updating
+                                                              the scheme counter */
+    void                                *id;             /**< Returns the scheme Id to be used */
+} ioc_fm_pcd_kg_scheme_params_t;
+
+/**************************************************************************//**
+ @Collection
+*//***************************************************************************/
+#define IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR      10  /* Maximal supported number of frame length ranges */
+#define IOC_FM_PCD_CC_STATS_FLR_SIZE            2   /* Size in bytes of a frame length range limit */
+#define IOC_FM_PCD_CC_STATS_FLR_COUNT_SIZE      4   /* Size in bytes of a frame length range counter */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after a CC node.
+                (Must match struct t_FmPcdCcNextCcParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_cc_params_t {
+    void        *cc_node_id;                             /**< Id of the next CC node */
+} ioc_fm_pcd_cc_next_cc_params_t;
+
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   A structure for defining Frame Replicator as the next engine after a CC node.
+                (Must match struct t_FmPcdCcNextFrParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_fr_params_t {
+    void*       frm_replic_id;              /**< The id of the next frame replicator group */
+} ioc_fm_pcd_cc_next_fr_params_t;
+#endif /* DPAA_VERSION >= 11 */
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+                next engine after a CC node
+                (Must match struct t_FmPcdCcNextPlcrParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
+    bool        override_params;            /**< TRUE if CC override previously decided parameters*/
+    bool        shared_profile;             /**< Relevant only if overrideParams=TRUE:
+                                                TRUE if this profile is shared between ports */
+    uint16_t    new_relative_profile_id;    /**< Relevant only if overrideParams=TRUE:
+                                                (otherwise profile id is taken from keygen);
+                                                This parameter should indicate the policer
+                                                profile offset within the port's
+                                                policer profiles or from SHARED window.*/
+    uint32_t    new_fqid;                   /**< Relevant only if overrideParams=TRUE:
+                                                FQID for enquing the frame;
+                                                In earlier chips  if policer next engine is KEYGEN,
+                                                this parameter can be 0, because the KEYGEN always decides
+                                                the enqueue FQID.*/
+#if DPAA_VERSION >= 11
+    uint8_t     new_relative_storage_profile_id;
+                                            /**< Indicates the relative storage profile offset within
+                                                 the port's storage profiles window;
+                                                 Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 11 */
+} ioc_fm_pcd_cc_next_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+                next engine after a CC node
+                (Must match struct t_FmPcdCcNextEnqueueParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
+    ioc_fm_pcd_done_action  action;         /**< Action - when next engine is BMI (done) */
+    bool                    override_fqid;  /**< TRUE if CC override previously decided fqid and vspid,
+                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME */
+    uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+                                                 (otherwise FQID is taken from KeyGen),
+                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
+#if DPAA_VERSION >= 11
+    uint8_t                 new_relative_storage_profile_id;
+                                            /**< Valid if override_fqid=TRUE, Indicates the relative virtual
+                                                 storage profile offset within the port's storage profiles
+                                                 window; Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 11 */
+
+} ioc_fm_pcd_cc_next_enqueue_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the next engine after a CC node
+                (Must match struct t_FmPcdCcNextKgParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_kg_params_t {
+    bool       override_fqid;               /**< TRUE if CC override previously decided fqid and vspid,
+                                                 Note - this parameters are irrelevant for earlier chips */
+    uint32_t   new_fqid;                    /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+                                                 (otherwise FQID is taken from KeyGen),
+                                                 Note - this parameters are irrelevant for earlier chips */
+#if DPAA_VERSION >= 11
+    uint8_t              new_relative_storage_profile_id;
+                                            /**< Valid if override_fqid=TRUE, Indicates the relative virtual
+                                                 storage profile offset within the port's storage profiles
+                                                 window; Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 11 */
+    void       *p_direct_scheme;            /**< Direct scheme id to go to. */
+} ioc_fm_pcd_cc_next_kg_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the next engine after a CC node.
+                (Must match struct t_FmPcdCcNextEngineParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_engine_params_t {
+    ioc_fm_pcd_engine                           next_engine;    /**< User has to initialize parameters
+                                                                     according to nextEngine definition */
+    union {
+            ioc_fm_pcd_cc_next_cc_params_t      cc_params;      /**< Parameters in case next engine is CC */
+            ioc_fm_pcd_cc_next_plcr_params_t    plcr_params;    /**< Parameters in case next engine is PLCR */
+            ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
+            ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
+#if DPAA_VERSION >= 11
+            ioc_fm_pcd_cc_next_fr_params_t      fr_params;      /**< Parameters in case next engine is FR */
+#endif /* DPAA_VERSION >= 11 */
+    } params;                                                   /**< Union used for all the next-engine parameters options */
+    void                                        *manip_id;      /**< Handle to Manipulation object.
+                                                                     Relevant if next engine is of type result
+                                                                     (e_IOC_FM_PCD_PLCR, e_IOC_FM_PCD_KG, e_IOC_FM_PCD_DONE) */
+    bool                                        statistics_en;  /**< If TRUE, statistics counters are incremented
+                                                                      for each frame passing through this
+                                                                      Coarse Classification entry. */
+} ioc_fm_pcd_cc_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single CC key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_key_params_t {
+    uint8_t                 *p_key;         /**< pointer to the key of the size defined in key_size */
+    uint8_t                 *p_mask;        /**< pointer to the Mask per key of the size defined
+                                                 in keySize. p_key and p_mask (if defined) has to be
+                                                 of the same size defined in the key_size */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                            /**< parameters for the next for the defined Key in p_key */
+
+} ioc_fm_pcd_cc_key_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC keys parameters
+                The driver supports two methods for CC node allocation: dynamic and static.
+                Static mode was created in order to prevent runtime alloc/free
+                of FMan memory (MURAM), which may cause fragmentation; in this mode,
+                the driver automatically allocates the memory according to
+                'max_num_of_keys' parameter. The driver calculates the maximal memory
+                size that may be used for this CC-Node taking into consideration
+                'mask_support' and 'statistics_mode' parameters.
+                When 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
+                parameters of this node, 'max_num_of_keys' must be equal to 'num_of_keys'.
+                In dynamic mode, 'max_num_of_keys' must be zero. At initialization,
+                all required structures are allocated according to 'num_of_keys'
+                parameter. During runtime modification, these structures are
+                re-allocated according to the updated number of keys.
+
+                Please note that 'action' and 'ic_indx_mask' mentioned in the
+                specific parameter explanations are passed in the extraction
+                parameters of the node (fields of extractccparams.extractnonhdr).
+*//***************************************************************************/
+typedef struct ioc_keys_params_t {
+    uint16_t                    max_num_of_keys;/**< Maximum number of keys that will (ever) be used in this CC-Node;
+                                                     A value of zero may be used for dynamic memory allocation. */
+    bool                        mask_support;   /**< This parameter is relevant only if a node is initialized with
+                                                     action = e_IOC_FM_PCD_ACTION_EXACT_MATCH and max_num_of_keys > 0;
+                                                     Should be TRUE to reserve table memory for key masks, even if
+                                                     initial keys do not contain masks, or if the node was initialized
+                                                     as 'empty' (without keys); this will allow user to add keys with
+                                                     masks at runtime. */
+    ioc_fm_pcd_cc_stats_mode    statistics_mode;/**< Determines the supported statistics mode for all node's keys.
+                                                     To enable statistics gathering, statistics should be enabled per
+                                                     every key, using 'statistics_en' in next engine parameters structure
+                                                     of that key;
+                                                     If 'max_num_of_keys' is set, all required structures will be
+                                                     preallocated for all keys. */
+#if (DPAA_VERSION >= 11)
+    uint16_t                    frame_length_ranges[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+                                                /**< Relevant only for 'RMON' statistics mode
+                                                     (this feature is supported only on B4860 device);
+                                                     Holds a list of programmable thresholds. For each received frame,
+                                                     its length in bytes is examined against these range thresholds and
+                                                     the appropriate counter is incremented by 1. For example, to belong
+                                                     to range i, the following should hold:
+                                                     range i-1 threshold < frame length <= range i threshold
+                                                     Each range threshold must be larger then its preceding range
+                                                     threshold. Last range threshold must be 0xFFFF. */
+#endif /* (DPAA_VERSION >= 11) */
+    uint16_t                    num_of_keys;    /**< Number of initial keys;
+                                                     Note that in case of 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP,
+                                                     this field should be power-of-2 of the number of bits that are
+                                                     set in 'ic_indx_mask'. */
+    uint8_t                     key_size;       /**< Size of key - for extraction of type FULL_FIELD, 'key_size' has
+                                                     to be the standard size of the selected key; For other extraction
+                                                     types, 'key_size' has to be as size of extraction; When 'action' =
+                                                     e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
+    ioc_fm_pcd_cc_key_params_t  key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
+                                                /**< An array with 'num_of_keys' entries, each entry specifies the
+                                                     corresponding key parameters;
+                                                     When 'action' = e_IOC_FM_PCD_ACTION_EXACT_MATCH, this value must not
+                                                     exceed 255 (IOC_FM_PCD_MAX_NUM_OF_KEYS-1) as the last entry is saved
+                                                     for the 'miss' entry. */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
+                                                /**< Parameters for defining the next engine when a key is not matched;
+                                                     Not relevant if action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP. */
+} ioc_keys_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_params_t {
+    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< Extraction parameters */
+    ioc_keys_params_t                   keys_params;        /**< Keys definition matching the selected extraction */
+    void                                *id;                /**< Output parameter; returns the CC node Id to be used */
+} ioc_fm_pcd_cc_node_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a hash table
+                (Must match struct t_FmPcdHashTableParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_params_t {
+    uint16_t                    max_num_of_keys;            /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
+    ioc_fm_pcd_cc_stats_mode    statistics_mode;            /**< If not e_IOC_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
+                                                                 requested statistics mode will be allocated according to max_num_of_keys. */
+    uint16_t                    hash_res_mask;              /**< Mask that will be used on the hash-result;
+                                                                 The number-of-sets for this hash will be calculated
+                                                                 as (2^(number of bits set in 'hash_res_mask'));
+                                                                 The 4 lower bits must be cleared. */
+    uint8_t                     hash_shift;                 /**< Byte offset from the beginning of the KeyGen hash result to the
+                                                                 2-bytes to be used as hash index. */
+    uint8_t                     match_key_size;             /**< Size of the exact match keys held by the hash buckets */
+
+    ioc_fm_pcd_cc_next_engine_params_t   cc_next_engine_params_for_miss;
+                                                            /**< Parameters for defining the next engine when a key is not matched */
+    void                        *id;
+} ioc_fm_pcd_hash_table_params_t;
+
+/**************************************************************************//**
+ @Description   A structure with the arguments for the FM_PCD_HashTableAddKey ioctl() call
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_add_key_params_t {
+    void                        *p_hash_tbl;
+    uint8_t                     key_size;
+    ioc_fm_pcd_cc_key_params_t  key_params;
+} ioc_fm_pcd_hash_table_add_key_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a CC tree group.
+
+                This structure defines a CC group in terms of NetEnv units
+                and the action to be taken in each case. The unit_ids list must
+                be given in order from low to high indices.
+
+                ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                num_of_distinction_units = 2
+                unit_ids = {1,3}
+                next_engine_per_entries_in_grp[0] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - not found;
+                next_engine_per_entries_in_grp[1] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - found;
+                next_engine_per_entries_in_grp[2] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - not found;
+                next_engine_per_entries_in_grp[3] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_grp_params_t {
+    uint8_t                             num_of_distinction_units;   /**< Up to 4 */
+    uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                    /**< Indexes of the units as defined in
+                                                                         FM_PCD_NetEnvCharacteristicsSet() */
+    ioc_fm_pcd_cc_next_engine_params_t  next_engine_per_entries_in_grp[IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
+                                                                    /**< Maximum entries per group is 16 */
+} ioc_fm_pcd_cc_grp_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the CC tree groups
+                (Must match struct t_FmPcdCcTreeParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_params_t {
+        void                            *net_env_id;    /**< Id of the Network Environment as returned
+                                                             by FM_PCD_NetEnvCharacteristicsSet() */
+        uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
+        ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
+                                                        /**< Parameters for each group. */
+        void                            *id;            /**< Output parameter; Returns the tree Id to be used */
+} ioc_fm_pcd_cc_tree_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining policer byte rate
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
+    ioc_fm_pcd_plcr_frame_length_select     frame_length_selection;     /**< Frame length selection */
+    ioc_fm_pcd_plcr_roll_back_frame_select  roll_back_frame_selection;  /**< relevant option only e_IOC_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                             e_IOC_FM_PCD_PLCR_FULL_FRM_LEN */
+} ioc_fm_pcd_plcr_byte_rate_mode_param_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the policer profile (based on
+                RFC-2698 or RFC-4115 attributes).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
+    ioc_fm_pcd_plcr_rate_mode               rate_mode;                      /**< Byte / Packet */
+    ioc_fm_pcd_plcr_byte_rate_mode_param_t  byte_mode_param;                /**< Valid for Byte NULL for Packet */
+    uint32_t                                comitted_info_rate;             /**< KBits/Sec or Packets/Sec */
+    uint32_t                                comitted_burst_size;            /**< KBits or Packets */
+    uint32_t                                peak_or_accessive_info_rate;    /**< KBits/Sec or Packets/Sec */
+    uint32_t                                peak_or_accessive_burst_size;   /**< KBits or Packets */
+} ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the next engine after policer
+*//***************************************************************************/
+typedef union ioc_fm_pcd_plcr_next_engine_params_u {
+        ioc_fm_pcd_done_action     action;              /**< Action - when next engine is BMI (done) */
+        void                       *p_profile;          /**< Policer profile handle -  used when next engine
+                                                             is PLCR, must be a SHARED profile */
+        void                       *p_direct_scheme;    /**< Direct scheme select - when next engine is Keygen */
+} ioc_fm_pcd_plcr_next_engine_params_u;
+
+typedef struct ioc_fm_pcd_port_params_t {
+    ioc_fm_port_type                    port_type;          /**< Type of port for this profile */
+    uint8_t                             port_id;            /**< FM-Port id of port for this profile */
+} ioc_fm_pcd_port_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the policer profile entry
+                (Must match struct t_FmPcdPlcrProfileParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_profile_params_t {
+    bool                                        modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
+            ioc_fm_pcd_port_params_t            *p_fm_port;                 /**< Relevant for per-port profiles only */
+            uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
+        } new_params;                                                       /**< Use it when modify = FALSE */
+        void                                    *p_profile;                 /**< A handle to a profile - use it when modify=TRUE */
+    } profile_select;
+    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algorithm PASS_THROUGH, RFC_2698, RFC_4115 */
+    ioc_fm_pcd_plcr_color_mode                  color_mode;                 /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode; the policer will re-color
+                                                                                 any incoming packet with the default value. */
+        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes; the profile response to a
+                                                                                 pre-color value of 2'b11. */
+    } color;
+
+    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 parameters */
+
+    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Next engine for green-colored frames */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Next engine parameters for green-colored frames  */
+
+    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Next engine for yellow-colored frames */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Next engine parameters for yellow-colored frames  */
+
+    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Next engine for red-colored frames */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Next engine parameters for red-colored frames  */
+
+    bool                                        trap_profile_on_flow_A;     /**< Obsolete - do not use */
+    bool                                        trap_profile_on_flow_B;     /**< Obsolete - do not use */
+    bool                                        trap_profile_on_flow_C;     /**< Obsolete - do not use */
+
+    void                                        *id;                        /**< output parameter; Returns the profile Id to be used */
+} ioc_fm_pcd_plcr_profile_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC tree next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
+    void                                *id;                /**< CC tree Id to be used */
+    uint8_t                             grp_indx;           /**< A Group index in the tree */
+    uint8_t                             indx;               /**< Entry index in the group defined by grp_index */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< Parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_node_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for remove CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+} ioc_fm_pcd_cc_node_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key and next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
+                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
+} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    uint8_t                             *p_key;             /**< Pointer to the key of the size defined in key_size */
+    uint8_t                             *p_mask;            /**< Pointer to the Mask per key of the size defined
+                                                                 in keySize. p_Key and p_Mask (if defined) have to be
+                                                                 of the same size as defined in the key_size */
+} ioc_fm_pcd_cc_node_modify_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure with the arguments for the FM_PCD_HashTableRemoveKey ioctl() call
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
+    void       *p_hash_tbl;     /**< The id of the hash table */
+    uint8_t     key_size;       /**< The size of the key to remove */
+    uint8_t    *p_key;          /**< Pointer to the key to remove */
+} ioc_fm_pcd_hash_table_remove_key_params_t;
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   Parameters for selecting a location for requested manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_manip_hdr_info_t {
+    ioc_net_header_type                 hdr;            /**< Header selection */
+    ioc_fm_pcd_hdr_index                hdr_index;      /**< Relevant only for MPLS, VLAN and tunneled IP. Otherwise should be cleared. */
+    bool                                by_field;       /**< TRUE if the location of manipulation is according to some field in the specific header*/
+    ioc_fm_pcd_fields_u                 full_field;     /**< Relevant only when by_field = TRUE: Extract field */
+} ioc_fm_manip_hdr_info_t;
+#endif /* FM_CAPWAP_SUPPORT */
+
+/**************************************************************************//**
+ @Description   Parameters for defining header removal by header type
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t {
+    ioc_fm_pcd_manip_hdr_rmv_by_hdr_type        type;  /**< Selection of header removal location */
+    union {
+#ifdef FM_CAPWAP_SUPPORT
+        struct {
+            bool                                include;/**< If FALSE, remove until the specified header (not including the header);
+                                                             If TRUE, remove also the specified header. */
+            ioc_fm_manip_hdr_info_t             hdr_info;
+        } from_start_by_hdr;                           /**< Relevant when type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* FM_CAPWAP_SUPPORT */
+        ioc_fm_pcd_manip_hdr_rmv_specific_l2    specific_l2;/**< Relevant when type = e_IOC_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
+                                                                 Defines which L2 headers to remove. */
+    } u;
+} ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP fragmentation manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
+    uint16_t                    size_for_fragmentation;     /**< If length of the frame is greater than this value,
+                                                                 IP fragmentation will be executed.*/
+#if DPAA_VERSION == 10
+    uint8_t                     scratch_bpid;               /**< Absolute buffer pool id according to BM configuration.*/
+#endif /* DPAA_VERSION == 10 */
+    bool                        sg_bpid_en;                 /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                                 If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                                 received frame's buffer. */
+    uint8_t                     sg_bpid;                    /**< Scatter/Gather buffer pool id;
+                                                                 This parameter is relevant when 'sg_bpid_en=TRUE';
+                                                                 Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                                 of this pool need to be allocated in the same memory area as the received buffers.
+                                                                 If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                                 mutual to all these sources. */
+    ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;    /**< Dont Fragment Action - If an IP packet is larger
+                                                                 than MTU and its DF bit is set, then this field will
+                                                                 determine the action to be taken.*/
+} ioc_fm_pcd_manip_frag_ip_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP reassembly manipulation.
+
+                This is a common structure for both IPv4 and IPv6 reassembly
+                manipulation. For reassembly of both IPv4 and IPv6, make sure to
+                set the 'hdr' field in ioc_fm_pcd_manip_reassem_params_t to IOC_HEADER_TYPE_IPv6.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_ip_params_t {
+    uint8_t                         relative_scheme_id[2];    /**< Partition relative scheme id:
+                                                                 relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
+                                                                 relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
+                                                                 NOTE: The following comment is relevant only for FMAN v2 devices:
+                                                                 Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
+                                                                 the user schemes id to ensure that the reassembly's schemes will be first match.
+                                                                 The remaining schemes, if defined, should have higher relative scheme ID. */
+#if DPAA_VERSION >= 11
+    uint32_t                        non_consistent_sp_fqid; /**< In case that other fragments of the frame corresponds to different storage
+                                                                 profile than the opening fragment (Non-Consistent-SP state)
+                                                                 then one of two possible scenarios occurs:
+                                                                 if 'nonConsistentSpFqid != 0', the reassembled frame will be enqueued to
+                                                                 this fqid, otherwise a 'Non Consistent SP' bit will be set in the FD[status].*/
+#else
+    uint8_t                         sg_bpid;                /**< Buffer pool id for the S/G frame created by the reassembly process */
+#endif /* DPAA_VERSION >= 11 */
+    uint8_t                         data_mem_id;            /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        data_liodn_offset;      /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        min_frag_size[2];       /**< Minimum fragment size:
+                                                                 minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
+    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry[2];
+                                                            /**< Number of frames per hash entry needed for reassembly process:
+                                                                 numOfFramesPerHashEntry[0] - for ipv4 (max value is e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH);
+                                                                 numOfFramesPerHashEntry[1] - for ipv6 (max value is e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH). */
+    uint16_t                        max_num_frames_in_process;/**< Number of frames which can be processed by Reassembly in the same time;
+                                                                 Must be power of 2;
+                                                                 In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
+                                                                 In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
+    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;  /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqid_for_time_out_frames;/**< FQID in which time out frames will enqueue during Time Out Process  */
+    uint32_t                        timeout_threshold_for_reassm_process;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} ioc_fm_pcd_manip_reassem_ip_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining IPSEC manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_ipsec_params_t {
+    bool    decryption;                     /**< TRUE if being used in decryption direction;
+                                                 FALSE if being used in encryption direction. */
+    bool    ecn_copy;                       /**< TRUE to copy the ECN bits from inner/outer to outer/inner
+                                                 (direction depends on the 'decryption' field). */
+    bool    dscp_copy;                      /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
+                                                 (direction depends on the 'decryption' field). */
+    bool    variable_ip_hdr_len;            /**< TRUE for supporting variable IP header length in decryption. */
+    bool    variable_ip_version;            /**< TRUE for supporting both IP version on the same SA in encryption */
+    uint8_t outer_ip_hdr_len;               /**< If 'variable_ip_version == TRUE' than this field must be set to non-zero value;
+                                                 It is specifies the length of the outer IP header that was configured in the
+                                                 corresponding SA. */
+} ioc_fm_pcd_manip_special_offload_ipsec_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining special offload manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_params_t {
+    ioc_fm_pcd_manip_special_offload_type               type;       /**< Type of special offload manipulation */
+    union
+    {
+        ioc_fm_pcd_manip_special_offload_ipsec_params_t ipsec;      /**< Parameters for IPSec; Relevant when
+                                                                         type = e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
+    } u;
+} ioc_fm_pcd_manip_special_offload_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic removal manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_generic_params_t {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the removal */
+    uint8_t                         size;           /**< Size of removed section */
+} ioc_fm_pcd_manip_hdr_rmv_generic_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_generic_params_t {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the insertion */
+    uint8_t                         size;           /**< Size of inserted section */
+    bool                            replace;        /**< TRUE to override (replace) existing data at
+                                                         'offset', FALSE to insert */
+    uint8_t                         *p_data;        /**< Pointer to data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_generic_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN DSCP To Vpri translation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t {
+    uint8_t                         dscp_to_vpri_table[IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS];
+                                                    /**< A table of VPri values for each DSCP value;
+                                                         The index is the D_SCP value (0-0x3F) and the
+                                                         value is the corresponding VPRI (0-15). */
+    uint8_t                         vpri_def_val;   /**< 0-7, Relevant only if if update_type =
+                                                         e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN,
+                                                         this field is the Q Tag default value if the
+                                                         IP header is not found. */
+} ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_t {
+    ioc_fm_pcd_manip_hdr_field_update_vlan  update_type;    /**< Selects VLAN update type */
+    union {
+        uint8_t                                     vpri;   /**< 0-7, Relevant only if If update_type =
+                                                                 e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_PRI, this
+                                                                 is the new VLAN pri. */
+        ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t    dscp_to_vpri;
+                                                            /**<  Parameters structure, Relevant only if update_type =
+                                                                  e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN. */
+    } u;
+} ioc_fm_pcd_manip_hdr_field_update_vlan_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV4 fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv4_t {
+    ioc_ipv4_hdr_manip_update_flags_t       valid_updates;  /**< ORed flag, selecting the required updates */
+    uint8_t                                 tos;            /**< 8 bit New TOS; Relevant if valid_updates contains
+                                                                 IOC_HDR_MANIP_IPV4_TOS */
+    uint16_t                                id;             /**< 16 bit New IP ID; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV4_ID */
+    uint32_t                                src;            /**< 32 bit New IP SRC; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV4_SRC */
+    uint32_t                                dst;            /**< 32 bit New IP DST; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV4_DST */
+} ioc_fm_pcd_manip_hdr_field_update_ipv4_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV6 fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv6_t {
+    ioc_ipv6_hdr_manip_update_flags_t       valid_updates;  /**< ORed flag, selecting the required updates */
+    uint8_t                                 traffic_class;  /**< 8 bit New Traffic Class; Relevant if valid_updates contains
+                                                                 IOC_HDR_MANIP_IPV6_TC */
+    uint8_t                                 src[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                            /**< 16 byte new IP SRC; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV6_SRC */
+    uint8_t                                 dst[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                            /**< 16 byte new IP DST; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV6_DST */
+} ioc_fm_pcd_manip_hdr_field_update_ipv6_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation TCP/UDP fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t {
+    ioc_tcp_udp_hdr_manip_update_flags_t    valid_updates;  /**< ORed flag, selecting the required updates */
+    uint16_t                                src;            /**< 16 bit New TCP/UDP SRC; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_TCP_UDP_SRC */
+    uint16_t                                dst;            /**< 16 bit New TCP/UDP DST; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_TCP_UDP_DST */
+} ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_params_t {
+    ioc_fm_pcd_manip_hdr_field_update_type          type;   /**< Type of header field update manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_field_update_vlan_t    vlan;   /**< Parameters for VLAN update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN */
+        ioc_fm_pcd_manip_hdr_field_update_ipv4_t    ipv4;   /**< Parameters for IPv4 update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4 */
+        ioc_fm_pcd_manip_hdr_field_update_ipv6_t    ipv6;   /**< Parameters for IPv6 update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6 */
+        ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t tcp_udp;/**< Parameters for TCP/UDP update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP */
+    } u;
+} ioc_fm_pcd_manip_hdr_field_update_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation for IP replacement
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t {
+    ioc_fm_pcd_manip_hdr_custom_ip_replace  replace_type;   /**< Selects replace update type */
+    bool                                    dec_ttl_hl;     /**< Decrement TTL (IPV4) or Hop limit (IPV6) by 1 */
+    bool                                    update_ipv4_id; /**< Relevant when replace_type =
+                                                                 e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4 */
+    uint16_t                                id;             /**< 16 bit New IP ID; Relevant only if
+                                                                 update_ipv4_id = TRUE */
+    uint8_t                                 hdr_size;       /**< The size of the new IP header */
+    uint8_t                                 hdr[IOC_FM_PCD_MANIP_MAX_HDR_SIZE];
+                                                            /**< The new IP header */
+} ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_custom_params_t {
+    ioc_fm_pcd_manip_hdr_custom_type                type;   /**< Type of header field update manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t    ip_hdr_replace;
+                                                            /**< Parameters IP header replacement */
+    } u;
+} ioc_fm_pcd_manip_hdr_custom_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining specific L2 insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
+    ioc_fm_pcd_manip_hdr_insrt_specific_l2  specific_l2;    /**< Selects which L2 headers to insert */
+    bool                                    update;         /**< TRUE to update MPLS header */
+    uint8_t                                 size;           /**< size of inserted section */
+    uint8_t                                *p_data;         /**< data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation by header type
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
+    ioc_fm_pcd_manip_hdr_insrt_by_hdr_type          type;   /**< Selects manipulation type */
+    union {
+       ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t  specific_l2_params;
+                                                            /**< Used when type = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
+                                                                 Selects which L2 headers to remove */
+    } u;
+} ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_params_t {
+    ioc_fm_pcd_manip_hdr_insrt_type                     type;   /**< Type of insertion manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t      by_hdr; /**< Parameters for defining header insertion manipulation by header type,
+                                                                     relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR */
+        ioc_fm_pcd_manip_hdr_insrt_generic_params_t     generic;/**< Parameters for defining generic header insertion manipulation,
+                                                                     relevant if type = e_IOC_FM_PCD_MANIP_INSRT_GENERIC */
+#ifdef FM_CAPWAP_SUPPORT
+        ioc_fm_pcd_manip_hdr_insrt_by_template_params_t by_template;
+                                                                /**< Parameters for defining header insertion manipulation by template,
+                                                                     relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
+#endif /* FM_CAPWAP_SUPPORT */
+    } u;
+} ioc_fm_pcd_manip_hdr_insrt_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header removal manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_params_t {
+    ioc_fm_pcd_manip_hdr_rmv_type                  type;       /**< Type of header removal manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t   by_hdr;     /**< Parameters for defining header removal manipulation by header type,
+                                                                    relevant if type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR */
+        ioc_fm_pcd_manip_hdr_rmv_generic_params_t  generic;    /**< Parameters for defining generic header removal manipulation,
+                                                                    relevant if type = e_IOC_FM_PCD_MANIP_RMV_GENERIC */
+    } u;
+} ioc_fm_pcd_manip_hdr_rmv_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_params_t {
+    bool                                        rmv;                  /**< TRUE, to define removal manipulation */
+    ioc_fm_pcd_manip_hdr_rmv_params_t           rmv_params;           /**< Parameters for removal manipulation, relevant if 'rmv' = TRUE */
+
+    bool                                        insrt;                /**< TRUE, to define insertion manipulation */
+    ioc_fm_pcd_manip_hdr_insrt_params_t         insrt_params;         /**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
+
+    bool                                        field_update;         /**< TRUE, to define field update manipulation */
+    ioc_fm_pcd_manip_hdr_field_update_params_t  field_update_params;  /**< Parameters for field update manipulation, relevant if 'fieldUpdate' = TRUE */
+
+    bool                                        custom;               /**< TRUE, to define custom manipulation */
+    ioc_fm_pcd_manip_hdr_custom_params_t        custom_params;        /**< Parameters for custom manipulation, relevant if 'custom' = TRUE */
+
+    bool                                        dont_parse_after_manip;/**< FALSE to activate the parser a second time after
+                                                                            completing the manipulation on the frame */
+} ioc_fm_pcd_manip_hdr_params_t;
+
+
+/**************************************************************************//**
+ @Description   structure for defining fragmentation manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_params_t {
+    ioc_net_header_type                     hdr;            /**< Header selection */
+    union {
+        ioc_fm_pcd_manip_frag_ip_params_t   ip_frag;        /**< Parameters for defining IP fragmentation,
+                                                                 relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} ioc_fm_pcd_manip_frag_params_t;
+
+/**************************************************************************//**
+ @Description   structure for defining reassemble manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_params_t {
+    ioc_net_header_type                         hdr;        /**< Header selection */
+    union {
+        ioc_fm_pcd_manip_reassem_ip_params_t    ip_reassem; /**< Parameters for defining IP reassembly,
+                                                                 relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} ioc_fm_pcd_manip_reassem_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a manipulation node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_params_t {
+    ioc_fm_pcd_manip_type                           type;   /**< Selects type of manipulation node */
+    union {
+        ioc_fm_pcd_manip_hdr_params_t               hdr;    /**< Parameters for defining header manipulation node */
+        ioc_fm_pcd_manip_reassem_params_t           reassem;/**< Parameters for defining reassembly manipulation node */
+        ioc_fm_pcd_manip_frag_params_t              frag;   /**< Parameters for defining fragmentation manipulation node */
+        ioc_fm_pcd_manip_special_offload_params_t   special_offload;/**< Parameters for defining special offload manipulation node */
+    } u;
+    void                                            *p_next_manip;/**< Handle to another (previously defined) manipulation node;
+                                                                 Allows concatenation of manipulation actions
+                                                                 This parameter is optional and may be NULL. */
+#ifdef FM_CAPWAP_SUPPORT
+#error "FM_CAPWAP_SUPPORT feature not supported!"
+    bool                                            frag_or_reasm;/**< TRUE, if defined fragmentation/reassembly manipulation */
+    ioc_fm_pcd_manip_frag_or_reasm_params_t         frag_or_reasm_params;/**< Parameters for fragmentation/reassembly manipulation,
+                                                                            relevant if frag_or_reasm = TRUE */
+#endif /* FM_CAPWAP_SUPPORT */
+    void                                           *id;
+} ioc_fm_pcd_manip_params_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving IP reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_ip_stats_t {
+    /* common counters for both IPv4 and IPv6 */
+    uint32_t    timeout;                        /**< Counts the number of TimeOut occurrences */
+    uint32_t    rfd_pool_busy;                    /**< Counts the number of failed attempts to allocate
+                                                     a Reassembly Frame Descriptor */
+    uint32_t    internal_buffer_busy;             /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t    external_buffer_busy;             /**< Counts the number of times external buffer busy occurred */
+    uint32_t    sg_fragments;                    /**< Counts the number of Scatter/Gather fragments */
+    uint32_t    dma_semaphore_depletion;          /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    struct {
+        uint32_t    successfully_reassembled;    /**< Counts the number of successfully reassembled frames */
+        uint32_t    valid_fragments;             /**< Counts the total number of valid fragments that
+                                                     have been processed for all frames */
+        uint32_t    processed_fragments;         /**< Counts the number of processed fragments
+                                                     (valid and error fragments) for all frames */
+        uint32_t    malformed_fragments;         /**< Counts the number of malformed fragments processed for all frames */
+        uint32_t    discarded_fragments;         /**< Counts the number of fragments discarded by the reassembly process */
+        uint32_t    auto_learn_busy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                     to access an IP-Reassembly Automatic Learning Hash set */
+        uint32_t    more_than16fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                     exceeds 16 */
+    } specific_hdr_statistics[2];                 /**< slot '0' is for IPv4, slot '1' is for IPv6 */
+} ioc_fm_pcd_manip_reassem_ip_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving IP fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_ip_stats_t {
+    uint32_t    total_frames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmented_frames;       /**< Number of frames that were fragmented */
+    uint32_t    generated_fragments;     /**< Number of fragments that were generated */
+} ioc_fm_pcd_manip_frag_ip_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_stats_t {
+    union {
+        ioc_fm_pcd_manip_reassem_ip_stats_t  ip_reassem;  /**< Structure for IP reassembly statistics */
+    } u;
+} ioc_fm_pcd_manip_reassem_stats_t;
+
+/**************************************************************************//**
+ @Description   structure for retrieving fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_stats_t {
+    union {
+        ioc_fm_pcd_manip_frag_ip_stats_t     ip_frag;     /**< Structure for IP fragmentation statistics */
+    } u;
+} ioc_fm_pcd_manip_frag_stats_t;
+
+/**************************************************************************//**
+ @Description   structure for defining manipulation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_stats_t {
+    union {
+        ioc_fm_pcd_manip_reassem_stats_t  reassem;    /**< Structure for reassembly statistics */
+        ioc_fm_pcd_manip_frag_stats_t     frag;       /**< Structure for fragmentation statistics */
+    } u;
+} ioc_fm_pcd_manip_stats_t;
+
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   Parameters for defining frame replicator group and its members
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_frm_replic_group_params_t {
+    uint8_t                     max_num_of_entries;    /**< Maximal number of members in the group  - must be at least two */
+    uint8_t                     num_of_entries;       /**< Number of members in the group - must be at least 1 */
+    ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
+                                                    /**< Array of members' parameters */
+    void                        *id;
+} ioc_fm_pcd_frm_replic_group_params_t;
+
+typedef struct ioc_fm_pcd_frm_replic_member_t {
+    void *h_replic_group;
+    uint16_t member_index;
+} ioc_fm_pcd_frm_replic_member_t;
+
+typedef struct ioc_fm_pcd_frm_replic_member_params_t {
+    ioc_fm_pcd_frm_replic_member_t member;
+    ioc_fm_pcd_cc_next_engine_params_t next_engine_params;
+} ioc_fm_pcd_frm_replic_member_params_t;
+#endif /* DPAA_VERSION >= 11 */
+
+/**************************************************************************//**
+ @Function      FM_PCD_NetEnvCharacteristicsSet
+
+ @Description   Define a set of Network Environment Characteristics.
+
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a KeyGen scheme or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and wants the distinction to be based
+                on the presence of either one of them.
+
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in,out] ioc_fm_pcd_net_env_params_t   A structure defining the distiction units for this configuration.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_compat_fm_pcd_net_env_params_t)
+#endif
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_NetEnvCharacteristicsDelete
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]     ioc_fm_obj_t - The id of a Network Environment object.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSchemeSet
+
+ @Description   Initializing or modifying and enabling a scheme for the KeyGen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'modify' should be TRUE. If the
+                routine is called for a valid scheme and 'modify' is FALSE,
+                it will return error.
+
+ @Param[in,out] ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_KG_SCHEME_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_compat_fm_pcd_kg_scheme_params_t)
+#endif
+#define FM_PCD_IOC_KG_SCHEME_SET    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSchemeDelete
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     ioc_fm_obj_t        scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_KG_SCHEME_DELETE     _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRootBuild
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the KeyGen schemes
+                may point only to trees defined in this way.
+
+ @Param[in,out] ioc_fm_pcd_cc_tree_params_t     A structure of parameters to define the tree.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_ROOT_BUILD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), compat_uptr_t)
+#endif
+#define FM_PCD_IOC_CC_ROOT_BUILD    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), void *) /* workaround ...*/
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRootDelete
+
+ @Description   Deleting a built tree.
+
+ @Param[in]     ioc_fm_obj_t - The id of a CC tree.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_ROOT_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_CC_ROOT_DELETE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableSet
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes. p_NodeId returns the node
+                Id to be used by other nodes.
+
+ @Param[in,out] ioc_fm_pcd_cc_node_params_t       A structure for defining the CC node params
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_SET_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), compat_uptr_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_SET    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), void *) /* workaround ...*/
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableDelete
+
+ @Description   Deleting a built node.
+
+ @Param[in]     ioc_fm_obj_t - The id of a CC node.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRootModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcRootBuild().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyMissNextEngine
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableRemoveKey
+
+ @Description   Remove the key (including next engine parameters of this key)
+                defined by the index of the relevant node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
+                node and for all of the nodes that lead to it.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_compat_fm_pcd_cc_node_remove_key_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableAddKey
+
+ @Description   Add the key (including next engine parameters of this key in the
+                index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
+                may be used when the user doesn't care about the position of the
+                key in the table - in that case, the key will be automatically
+                added by the driver in the last available entry.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
+                node and for all of the nodes that lead to it.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by key_index.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyKey
+
+ @Description   Modify the key at the index defined by key_index.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
+                node and for all of the nodes that lead to it.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_compat_fm_pcd_cc_node_modify_key_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableSet
+
+ @Description   This routine initializes a hash table structure.
+                KeyGen hash result determines the hash bucket.
+                Next, KeyGen key is compared against all keys of this
+                bucket (exact match).
+                Number of sets (number of buckets) of the hash equals to the
+                number of 1-s in 'hash_res_mask' in the provided parameters.
+                Number of hash table ways is then calculated by dividing
+                'max_num_of_keys' equally between the hash sets. This is the maximal
+                number of keys that a hash bucket may hold.
+                The hash table is initialized empty and keys may be
+                added to it following the initialization. Keys masks are not
+                supported in current hash table implementation.
+                The initialized hash table can be integrated as a node in a
+                CC tree.
+
+ @Param[in,out] ioc_fm_pcd_hash_table_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_pcd_hash_table_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_hash_table_params_t)
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableDelete
+
+ @Description   This routine deletes the provided hash table and released all
+                its allocated resources.
+
+ @Param[in]     ioc_fm_obj_t - The ID of a hash table.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_DELETE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_DELETE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableAddKey
+
+ @Description   This routine adds the provided key (including next engine
+                parameters of this key) to the hash table.
+                The key is added as the last key of the bucket that it is
+                mapped to.
+
+ @Param[in]     ioc_fm_pcd_hash_table_add_key_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_ADD_KEY_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_compat_fm_pcd_hash_table_add_key_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_ADD_KEY _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_fm_pcd_hash_table_add_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableRemoveKey
+
+ @Description   This routine removes the requested key (including next engine
+                parameters of this key) from the hash table.
+
+ @Param[in]     ioc_fm_pcd_hash_table_remove_key_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_compat_fm_pcd_hash_table_remove_key_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_fm_pcd_hash_table_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileSet
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in,out] ioc_fm_pcd_plcr_profile_params_t    A structure of parameters for defining a
+                                                    policer profile entry.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_pcd_plcr_profile_params_t)
+#endif
+#define FM_PCD_IOC_PLCR_PROFILE_SET     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_pcd_plcr_profile_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileDelete
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     ioc_fm_obj_t        The id of a policer profile.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_PLCR_PROFILE_DELETE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeSet
+
+ @Description   This routine should be called for defining a manipulation
+                node. A manipulation node must be defined before the CC node
+                that precedes it.
+
+ @Param[in]     ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_SET_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_compat_fm_pcd_manip_params_t)
+#endif
+#define FM_PCD_IOC_MANIP_NODE_SET   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_fm_pcd_manip_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeReplace
+
+ @Description   Change existing manipulation node to be according to new requirement.
+                (Here, it's implemented as a variant of the same IOCTL as for
+                FM_PCD_ManipNodeSet(), and one that when called, the 'id' member
+                in its 'ioc_fm_pcd_manip_params_t' argument is set to contain
+                the manip node's handle)
+
+ @Param[in]     ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_REPLACE_COMPAT    FM_PCD_IOC_MANIP_NODE_SET_COMPAT
+#endif
+#define FM_PCD_IOC_MANIP_NODE_REPLACE           FM_PCD_IOC_MANIP_NODE_SET
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeDelete
+
+ @Description   Delete an existing manipulation node.
+
+ @Param[in]     ioc_fm_obj_t       The id of the manipulation node to delete.
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_MANIP_NODE_DELETE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_fm_obj_t)
+
+/**************************************************************************//**
+@Function      FM_PCD_SetAdvancedOffloadSupport
+
+@Description   This routine must be called in order to support the following features:
+               IP-fragmentation, IP-reassembly, IPsec, Header-manipulation, frame-replicator.
+
+@Param[in]     h_FmPcd         FM PCD module descriptor.
+
+@Return        0 on success; error code otherwise.
+
+@Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45))
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicSetGroup
+
+ @Description   Initialize a Frame Replicator group.
+
+ @Param[in]     h_FmPcd                FM PCD module descriptor.
+ @Param[in]     p_FrmReplicGroupParam  A structure of parameters for the initialization of
+                                       the frame replicator group.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_compat_fm_pcd_frm_replic_group_params_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_fm_pcd_frm_replic_group_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicDeleteGroup
+
+ @Description   Delete a Frame Replicator group.
+
+ @Param[in]     h_FrmReplicGroup  A handle to the frame replicator group.
+
+ @Return        E_OK on success;  Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicAddMember
+
+ @Description   Add the member in the index defined by the memberIndex.
+
+ @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]     memberIndex        member index for adding.
+ @Param[in]     p_MemberParams     A pointer to the new member parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(48), ioc_compat_fm_pcd_frm_replic_member_params_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(48), ioc_fm_pcd_frm_replic_member_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicRemoveMember
+
+ @Description   Remove the member defined by the index from the relevant group.
+
+ @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]     memberIndex        member index for removing.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(49), ioc_compat_fm_pcd_frm_replic_member_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(49), ioc_fm_pcd_frm_replic_member_t)
+
+#endif
+
+#ifdef FM_CAPWAP_SUPPORT
+#warning "CAPWAP IOCTL not implemented"
+/**************************************************************************//**
+ @Function      FM_PCD_StatisticsSetNode
+
+ @Description   This routine should be called for defining a statistics node.
+
+ @Param[in,out] ioc_fm_pcd_stats_params_t A structure of parameters defining the statistics
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_STATISTICS_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
+#endif
+#define FM_PCD_IOC_STATISTICS_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
+
+#endif /* FM_CAPWAP_SUPPORT */
+
+#ifdef NCSW_BACKWARD_COMPATIBLE_API
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT \
+                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT \
+                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT
+#define FM_PCD_IOC_KG_SET_SCHEME_COMPAT         FM_PCD_IOC_KG_SCHEME_SET_COMPAT
+#define FM_PCD_IOC_KG_DEL_SCHEME_COMPAT         FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT
+#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT         FM_PCD_IOC_CC_ROOT_BUILD_COMPAT
+#define FM_PCD_IOC_CC_DELETE_TREE_COMPAT        FM_PCD_IOC_CC_ROOT_DELETE_COMPAT
+#define FM_PCD_IOC_CC_DELETE_NODE_COMPAT        FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT
+#define FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT       FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT
+#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT
+#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT
+#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT        FM_PCD_IOC_MANIP_NODE_SET_COMPAT
+#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT     FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT
+#endif
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS \
+                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE
+#define FM_PCD_IOC_KG_SET_SCHEME                FM_PCD_IOC_KG_SCHEME_SET
+#define FM_PCD_IOC_KG_DEL_SCHEME                FM_PCD_IOC_KG_SCHEME_DELETE
+#define FM_PCD_IOC_CC_BUILD_TREE                FM_PCD_IOC_CC_ROOT_BUILD
+#define FM_PCD_IOC_CC_DELETE_TREE               FM_PCD_IOC_CC_ROOT_DELETE
+#define FM_PCD_IOC_CC_DELETE_NODE               FM_PCD_IOC_MATCH_TABLE_DELETE
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY           FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY
+#define FM_PCD_IOC_CC_NODE_ADD_KEY              FM_PCD_IOC_MATCH_TABLE_ADD_KEY
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY           FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY
+#define FM_PCD_IOC_PLCR_SET_PROFILE             FM_PCD_IOC_PLCR_PROFILE_SET
+#define FM_PCD_IOC_PLCR_DEL_PROFILE             FM_PCD_IOC_PLCR_PROFILE_DELETE
+#define FM_PCD_IOC_MANIP_SET_NODE               FM_PCD_IOC_MANIP_NODE_SET
+#define FM_PCD_IOC_MANIP_DELETE_NODE            FM_PCD_IOC_MANIP_NODE_DELETE
+#endif /* NCSW_BACKWARD_COMPATIBLE_API */
+
+#endif /* __FM_PCD_IOCTLS_H */
+/** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
diff --git a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
new file mode 100644
index 0000000..8488845
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -0,0 +1,921 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port_ioctls.h
+
+ @Description   FM Port routines
+*//***************************************************************************/
+#ifndef __FM_PORT_IOCTLS_H
+#define __FM_PORT_IOCTLS_H
+
+#include "enet_ext.h"
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+
+
+/**************************************************************************//**
+
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC), offline parsing flow or host command
+                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+                Host command/Offline parsing ports. The SW driver manages these
+                ports as sub-modules of the FM, i.e. after an FM is initialized,
+                its ports may be initialized and operated upon.
+
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherency and returns error if applicable.
+
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type). Host command and Offline parsing
+                ports share the same id range, I.e user may not initialized host
+                command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining port PCD modes.
+                (Must match enum e_FmPortPcdSupport defined in fm_port_ext.h)
+
+                This enum defines the superset of PCD engines support - i.e. not
+                all engines have to be used, but all have to be enabled. The real
+                flow of a specific frame depends on the PCD configuration and the
+                frame headers and payload.
+                Note: the first engine and the first engine after the parser (if
+                exists) should be in order, the order is important as it will
+                define the flow of the port. However, as for the rest engines
+                (the ones that follows), the order is not important anymore as
+                it is defined by the PCD graph itself.
+*//***************************************************************************/
+typedef enum ioc_fm_port_pcd_support {
+      e_IOC_FM_PORT_PCD_SUPPORT_NONE = 0                /**< BMI to BMI, PCD is not used */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY                /**< Use only Parser */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY               /**< Use only Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR            /**< Use Parser and Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG              /**< Use Parser and Keygen */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC       /**< Use Parser, Keygen and Coarse Classification */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
+                                                        /**< Use all PCD engines */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
+#ifdef FM_CAPWAP_SUPPORT
+    , e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
+    , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
+    , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
+#endif /* FM_CAPWAP_SUPPORT */
+} ioc_fm_port_pcd_support;
+
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    ioc_fm_port_frame_err_select_t;     /**< typedef for defining Frame Descriptor errors */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   An enum for defining Dual Tx rate limiting scale.
+                (Must match e_FmPortDualRateLimiterScaleDown defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_dual_rate_limiter_scale_down {
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
+} ioc_fm_port_dual_rate_limiter_scale_down;
+
+/**************************************************************************//**
+ @Description   A structure for defining Tx rate limiting
+                (Must match struct t_FmPortRateLimit defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_rate_limit_t {
+    uint16_t                            max_burst_size;         /**< in KBytes for Tx ports, in frames
+                                                                     for offline parsing ports. (note that
+                                                                     for early chips burst size is
+                                                                     rounded up to a multiply of 1000 frames).*/
+    uint32_t                            rate_limit;             /**< in Kb/sec for Tx ports, in frame/sec for
+                                                                     offline parsing ports. Rate limit refers to
+                                                                     data rate (rather than line rate). */
+    ioc_fm_port_dual_rate_limiter_scale_down rate_limit_divider;    /**< For offline parsing ports only. Not-valid
+                                                                     for some earlier chip revisions */
+} ioc_fm_port_rate_limit_t;
+
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining FM Port counters.
+                (Must match enum e_FmPortCounters defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_counters {
+    e_IOC_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_IOC_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx, OP & HC statistics counter */
+    e_IOC_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER,  /**< BMI Rx, OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI total QM dequeues counter */
+    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI total QM enqueues counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} ioc_fm_port_counters;
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                (Description may be inaccurate;
+                must match struct t_FmPortCongestionGrps defined in fm_port_ext.h)
+
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct ioc_fm_port_congestion_groups_t {
+    uint16_t    num_of_congestion_grps_to_consider;     /**< The number of required congestion groups
+                                                             to define the size of the following array */
+    uint8_t     congestion_grps_to_consider [FM_PORT_NUM_OF_CONGESTION_GRPS];
+                                                        /**< An array of CG indexes;
+                                                             Note that the size of the array should be
+                                                             'num_of_congestion_grps_to_consider'. */
+#if DPAA_VERSION >= 11
+    bool        pfc_priorities_enable[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
+                                                        /**< A matrix that represents the map between the CG ids
+                                                             defined in 'congestion_grps_to_consider' to the priorities
+                                                             mapping array. */
+#endif /* DPAA_VERSION >= 11 */
+} ioc_fm_port_congestion_groups_t;
+
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_Disable
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+#define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PORT_Enable
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetRateLimit
+
+ @Description   Calling this routine enables rate limit algorithm.
+                By default, this functionality is disabled.
+                Note that rate-limit mechanism uses the FM time stamp.
+                The selected rate limit specified here would be
+                rounded DOWN to the nearest 16M.
+
+                May be used for Tx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_rate_limit A structure of rate limit parameters
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_RATE_LIMIT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_rate_limit_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeleteRateLimit
+
+ @Description   Calling this routine disables the previously enabled rate limit.
+
+                May be used for Tx and offline parsing ports only
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_RATE_LIMIT   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(5))
+#define FM_PORT_IOC_REMOVE_RATE_LIMIT   FM_PORT_IOC_DELETE_RATE_LIMIT
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_AddCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port.
+                It should be called in order to enable pause
+                frame transmission in case of congestion in one or more
+                of the congestion groups relevant to this port.
+                Each call to this routine may add one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]     ioc_fm_port_congestion_groups_t - A pointer to an array of
+                                                congestion group ids to consider.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ADD_CONGESTION_GRPS    _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(34), ioc_fm_port_congestion_groups_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_RemoveCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port. It should be
+                called when congestion groups were
+                defined for this port and are no longer relevant, or pause
+                frames transmitting is not required on their behalf.
+                Each call to this routine may remove one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]     ioc_fm_port_congestion_groups_t - A pointer to an array of
+                                                congestion group ids to consider.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_REMOVE_CONGESTION_GRPS    _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(35), ioc_fm_port_congestion_groups_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetErrorsRoute
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                (szbs001: How is it possible to have one function that needs to be
+                          called BEFORE FM_PORT_Init() implemented as an ioctl,
+                          which will ALWAYS be called AFTER the FM_PORT_Init()
+                          for that port!?!?!?!???!?!??!?!?)
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(4), ioc_fm_port_frame_err_select_t)
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure defining the KG scheme after the parser.
+                (Must match struct t_FmPcdKgSchemeSelect defined in fm_port_ext.h)
+
+                This is relevant only to change scheme selection mode - from
+                direct to indirect and vice versa, or when the scheme is selected directly,
+                to select the scheme id.
+
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_select_t {
+    bool        direct;                     /**< TRUE to use 'scheme_id' directly, FALSE to use LCV.*/
+    void       *scheme_id;                  /**< Relevant for 'direct'=TRUE only.
+                                                 'scheme_id' selects the scheme after parser. */
+} ioc_fm_pcd_kg_scheme_select_t;
+
+/**************************************************************************//**
+ @Description   Scheme IDs structure
+                (Must match struct t_FmPcdPortSchemesParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_port_schemes_params_t {
+    uint8_t     num_of_schemes;                         /**< Number of schemes for port to be bound to. */
+    void        *scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];  /**< Array of 'num_of_schemes' schemes for the
+                                                             port to be bound to */
+} ioc_fm_pcd_port_schemes_params_t;
+
+/**************************************************************************//**
+ @Description   A union for defining port protocol parameters for parser
+                (Must match union u_FmPcdHdrPrsOpts defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_prs_opts_u {
+    /* MPLS */
+    struct {
+        bool                label_interpretation_enable;/**< When this bit is set, the last MPLS label will be
+                                                             interpreted as described in HW spec table. When the bit
+                                                             is cleared, the parser will advance to MPLS next parse */
+        ioc_net_header_type next_parse;                 /**< must be equal or higher than IPv4 */
+    } mpls_prs_options;
+
+    /* VLAN */
+    struct {
+        uint16_t            tag_protocol_id1;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t            tag_protocol_id2;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlan_prs_options;
+
+    /* PPP */
+    struct{
+        bool                enable_mtu_check;           /**< Check validity of MTU according to RFC2516 */
+    } pppoe_prs_options;
+
+    /* IPV6 */
+    struct {
+        bool                routing_hdr_disable;        /**< Disable routing header */
+    } ipv6_prs_options;
+
+    /* UDP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } udp_prs_options;
+
+    /* TCP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } tcp_prs_options;
+} ioc_fm_pcd_hdr_prs_opts_u;
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+                (must match struct t_FmPcdPrsAdditionalHdrParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
+    ioc_net_header_type         hdr;                /**< Selected header */
+    bool                        err_disable;        /**< TRUE to disable error indication */
+    bool                        soft_prs_enable;    /**< Enable jump to SW parser when this
+                                                         header is recognized by the HW parser. */
+    uint8_t                     index_per_hdr;      /**< Normally 0, if more than one sw parser
+                                                         attachments exists for the same header,
+                                                         (in the main sw parser code) use this
+                                                         index to distinguish between them. */
+    bool                        use_prs_opts;       /**< TRUE to use parser options. */
+    ioc_fm_pcd_hdr_prs_opts_u   prs_opts;           /**< A unuion according to header type,
+                                                         defining the parser options selected.*/
+} ioc_fm_pcd_prs_additional_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining port PCD parameters
+                (Must match t_FmPortPcdPrsParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_prs_params_t {
+    uint8_t                         prs_res_priv_info;      /**< The private info provides a method of inserting
+                                                                 port information into the parser result. This information
+                                                                 may be extracted by KeyGen and be used for frames
+                                                                 distribution when a per-port distinction is required,
+                                                                 it may also be used as a port logical id for analyzing
+                                                                 incoming frames. */
+    uint8_t                         parsing_offset;         /**< Number of bytes from begining of packet to start parsing */
+    ioc_net_header_type             first_prs_hdr;          /**< The type of the first header axpected at 'parsing_offset' */
+    bool                            include_in_prs_statistics; /**< TRUE to include this port in the parser statistics */
+    uint8_t                         num_of_hdrs_with_additional_params;
+                                                            /**< Normally 0, some headers may get special parameters */
+    ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                            /**< 'num_of_hdrs_with_additional_params' structures
+                                                                  additional parameters for each header that requires them */
+    bool                            set_vlan_tpid1;         /**< TRUE to configure user selection of Ethertype to
+                                                                 indicate a VLAN tag (in addition to the TPID values
+                                                                 0x8100 and 0x88A8). */
+    uint16_t                        vlan_tpid1;             /**< extra tag to use if set_vlan_tpid1=TRUE. */
+    bool                            set_vlan_tpid2;         /**< TRUE to configure user selection of Ethertype to
+                                                                 indicate a VLAN tag (in addition to the TPID values
+                                                                 0x8100 and 0x88A8). */
+    uint16_t                        vlan_tpid2;             /**< extra tag to use if set_vlan_tpid1=TRUE. */
+} ioc_fm_port_pcd_prs_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining coarse alassification parameters
+                (Must match t_FmPortPcdCcParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_cc_params_t {
+    void                *cc_tree_id; /**< CC tree id */
+} ioc_fm_port_pcd_cc_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining keygen parameters
+                (Must match t_FmPortPcdKgParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_kg_params_t {
+    uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
+    void               *scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'num_of_schemes' schemes for the
+                                                             port to be bound to */
+    bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    void               *direct_scheme_id;               /**< Scheme id, as returned by FM_PCD_KgSetScheme;
+                                                             relevant only if direct=TRUE. */
+} ioc_fm_port_pcd_kg_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer parameters
+                (Must match t_FmPortPcdPlcrParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_plcr_params_t {
+    void                *plcr_profile_id;               /**< Selected profile handle;
+                                                             relevant in one of the following cases:
+                                                             e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
+                                                             e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
+                                                             or if any flow uses a KG scheme where policer
+                                                                profile is not generated (bypass_plcr_profile_generation selected) */
+} ioc_fm_port_pcd_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining port PCD parameters
+                (Must match struct t_FmPortPcdParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_params_t {
+    ioc_fm_port_pcd_support         pcd_support;    /**< Relevant for Rx and offline ports only.
+                                                         Describes the active PCD engines for this port. */
+    void                            *net_env_id;    /**< HL Unused in PLCR only mode */
+    ioc_fm_port_pcd_prs_params_t    *p_prs_params;  /**< Parser parameters for this port */
+    ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
+    ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
+    ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
+    void                            *p_ip_reassembly_manip;/**< IP Reassembly manipulation */
+} ioc_fm_port_pcd_params_t;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining the Parser starting point
+                (Must match struct t_FmPcdPrsStart defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_start_t {
+    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
+                                             start parsing */
+    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
+                                             'parsing_offset' */
+} ioc_fm_pcd_prs_start_t;
+
+
+/**************************************************************************//**
+ @Description   FQID parameters structure
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_fqids_params_t {
+    uint32_t            num_fqids;  /**< Number of fqids to be allocated for the port */
+    uint8_t             alignment;  /**< Alignment required for this port */
+    uint32_t            base_fqid;  /**< output parameter - the base fqid */
+} ioc_fm_port_pcd_fqids_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ALLOC_PCD_FQIDS
+
+ @Description   Allocates FQID's
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_FREE_PCD_FQIDS
+
+ @Description   Frees previously-allocated FQIDs
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]		uint32_t	Base FQID of previously allocated range.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_FREE_PCD_FQIDS   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), uint32_t)
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_pcd_params_t    A Structure of parameters defining the port's PCD
+                                            configuration.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_SET_PCD_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_compat_fm_port_pcd_params_t)
+#endif
+#define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeletePCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
+
+/**************************************************************************//**
+ @Function      FM_PORT_AttachPCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
+
+/**************************************************************************//**
+ @Function      FM_PORT_DetachPCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrAllocProfiles
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     uint16_t       The number of required policer profiles
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed before FM_PORT_SetPCD() only.
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES     _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrFreeProfiles
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed before FM_PORT_SetPCD() only.
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES     _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgModifyInitialScheme
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
+                                                a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_compat_fm_pcd_kg_scheme_select_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrModifyInitialProfile
+
+ @Description   This routine may be called for ports with flows
+                e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only,
+                to change the initial Policer profile frame should be routed to.
+                The change may be of a profile and/or absolute/direct mode selection.
+
+ @Param[in]     ioc_fm_obj_t       Policer profile Id as returned from FM_PCD_PlcrSetProfile.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_compat_fm_obj_t)
+#endif
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdCcModifyTree
+
+ @Description   This routine may be called to change this port connection to
+                a pre-initializes coarse classification Tree.
+
+ @Param[in]     ioc_fm_obj_t    Id of new coarse classification tree selected for this port.
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_compat_fm_obj_t)
+#endif
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgBindSchemes
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not added,
+                just this specific port starts using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_SetPCD().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_compat_fm_pcd_port_schemes_params_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgUnbindSchemes
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not removed or invalidated,
+                just this specific port stops using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_SetPCD().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_compat_fm_pcd_port_schemes_params_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPrsModifyStartOffset
+
+ @Description   Runtime change of the parser start offset within the header.
+
+ @Param[in]     ioc_fm_pcd_prs_start_t  A structure of parameters for defining the
+                                        start point for the parser.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)
+
+typedef struct ioc_fm_port_mac_addr_params_t {
+    uint8_t addr[ENET_NUM_OCTETS_PER_ADDRESS];
+} ioc_fm_port_mac_addr_params_t;
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddHashMacAddr
+
+ @Description   Add an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     ioc_fm_port_mac_addr_params_t - Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init(). It is a filter only address.
+ @Cautions      Some address need to be filtered out in upper FM blocks.
+*//***************************************************************************/
+#define FM_PORT_IOC_ADD_RX_HASH_MAC_ADDR   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(36), ioc_fm_port_mac_addr_params_t)
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemoveHashMacAddr
+
+ @Description   Delete an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     ioc_fm_port_mac_addr_params_t - Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_REMOVE_RX_HASH_MAC_ADDR   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(37), ioc_fm_port_mac_addr_params_t)
+
+typedef struct ioc_fm_port_tx_pause_frames_params_t {
+    uint8_t  priority;
+    uint16_t pause_time;
+    uint16_t thresh_time;
+} ioc_fm_port_tx_pause_frames_params_t;
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetTxPauseFrames
+
+ @Description   Enable/Disable transmission of Pause-Frames.
+                The routine changes the default configuration:
+                pause-time - [0xf000]
+                threshold-time - [0]
+
+ @Param[in]     ioc_fm_port_tx_pause_frames_params_t A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+                PFC is supported only on new mEMAC; i.e. in MACs that don't have
+                PFC support (10G-MAC and dTSEC), user should use 'FM_MAC_NO_PFC'
+                in the 'priority' field.
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_TX_PAUSE_FRAMES       _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(40), ioc_fm_port_tx_pause_frames_params_t)
+
+typedef struct ioc_fm_port_mac_statistics_t {
+    /* RMON */
+        uint64_t  e_stat_pkts_64;            /**< r-10G tr-DT 64 byte frame counter */
+        uint64_t  e_stat_pkts_65_to_127;     /**< r-10G 65 to 127 byte frame counter */
+        uint64_t  e_stat_pkts_128_to_255;    /**< r-10G 128 to 255 byte frame counter */
+        uint64_t  e_stat_pkts_256_to_511;    /**< r-10G 256 to 511 byte frame counter */
+        uint64_t  e_stat_pkts_512_to_1023;   /**< r-10G 512 to 1023 byte frame counter */
+        uint64_t  e_stat_pkts_1024_to_1518;  /**< r-10G 1024 to 1518 byte frame counter */
+        uint64_t  e_stat_pkts_1519_to_1522;  /**< r-10G 1519 to 1522 byte good frame count */
+    /* */
+        uint64_t  e_stat_fragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+        uint64_t  e_stat_jabbers;            /**< Total number of packets longer than valid maximum length octets */
+        uint64_t  e_stat_drop_events;        /**< number of dropped packets due to internal errors of the MAC Client (during recieve). */
+        uint64_t  e_stat_CRC_align_errors;   /**< Incremented when frames of correct length but with CRC error are received.*/
+        uint64_t  e_stat_undersize_pkts;     /**< Incremented for frames under 64 bytes with a valid FCS and otherwise well formed;
+                                                This count does not include range length errors */
+        uint64_t  e_stat_oversize_pkts;      /**< Incremented for frames which exceed 1518 (non VLAN) or 1522 (VLAN) and contains
+                                                a valid FCS and otherwise well formed */
+    /* Pause */
+        uint64_t  te_stat_pause;             /**< Pause MAC Control received */
+        uint64_t  re_stat_pause;             /**< Pause MAC Control sent */
+    /* MIB II */
+        uint64_t  if_in_octets;              /**< Total number of byte received. */
+        uint64_t  if_in_pkts;                /**< Total number of packets received.*/
+        uint64_t  if_in_ucast_pkts;          /**< Total number of unicast frame received;
+                                             NOTE: this counter is not supported on dTSEC MAC */
+        uint64_t  if_in_mcast_pkts;          /**< Total number of multicast frame received*/
+        uint64_t  if_in_bcast_pkts;          /**< Total number of broadcast frame received */
+        uint64_t  if_in_discards;            /**< Frames received, but discarded due to problems within the MAC RX. */
+        uint64_t  if_in_errors;              /**< Number of frames received with error:
+                                                   - FIFO Overflow Error
+                                                   - CRC Error
+                                                   - Frame Too Long Error
+                                                   - Alignment Error
+                                                   - The dedicated Error Code (0xfe, not a code error) was received */
+        uint64_t  if_out_octets;             /**< Total number of byte sent. */
+        uint64_t  if_out_pkts;               /**< Total number of packets sent .*/
+        uint64_t  if_out_ucast_pkts;         /**< Total number of unicast frame sent;
+                                             NOTE: this counter is not supported on dTSEC MAC */
+        uint64_t  if_out_mcast_pkts;         /**< Total number of multicast frame sent */
+        uint64_t  if_out_bcast_pkts;         /**< Total number of multicast frame sent */
+        uint64_t  if_out_discards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+        uint64_t  if_out_errors;             /**< Number of frames transmitted with error:
+                                                   - FIFO Overflow Error
+                                                   - FIFO Underflow Error
+                                                   - Other */
+} ioc_fm_port_mac_statistics_t;
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetStatistics
+
+ @Description   get all MAC statistics counters
+
+ @Param[out]    ioc_fm_port_mac_statistics_t    A structure holding the statistics
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_GET_MAC_STATISTICS        _IOR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(41), ioc_fm_port_mac_statistics_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+                The prefix will
+                In Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+
+                May be used for all ports
+
+ @Param[in]     ioc_fm_buffer_prefix_content_t  A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_CONFIG_BUFFER_PREFIX_CONTENT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(39), ioc_fm_buffer_prefix_content_t)
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_fm_port_vsp_alloc_params_t {
+    uint8_t     num_of_profiles;          /**< Number of Virtual Storage Profiles */
+    uint8_t     dflt_relative_id;         /**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
+                                             The same default Virtual-Storage-Profile-id will be for coupled Tx port
+                                             if relevant function called for Rx port */
+    void    *p_fm_tx_port;             /**< Handle to coupled Tx Port; not relevant for OP port. */
+}ioc_fm_port_vsp_alloc_params_t;
+
+/**************************************************************************//**
+ @Function      FM_PORT_VSPAlloc
+
+ @Description   This routine allocated VSPs per port and forces the port to work
+                in VSP mode. Note that the port is initialized by default with the
+                physical-storage-profile only.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_Params    A structure of parameters for allocation VSP's per port
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), and before FM_PORT_SetPCD()
+                and also before FM_PORT_Enable() (i.e. the port should be disabled).
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_VSP_ALLOC_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_compat_fm_port_vsp_alloc_params_t)
+#endif
+#define FM_PORT_IOC_VSP_ALLOC _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_fm_port_vsp_alloc_params_t)
+#endif /* (DPAA_VERSION >= 11) */
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+#endif /* __FM_PORT_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/Peripherals/fm_test_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_test_ioctls.h
new file mode 100644
index 0000000..207ed1e
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/fm_test_ioctls.h
@@ -0,0 +1,208 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_test_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_TEST_IOCTLS_H
+#define __FM_TEST_IOCTLS_H
+
+#include "ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_grp Frame Manager Test Linux IOCTL API
+
+ @Description   FM-Test Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+#define IOC_FMT_MAX_NUM_OF_PORTS        26
+
+/**************************************************************************//**
+ @Collection    TEST Parameters
+*//***************************************************************************/
+/**************************************************************************//**
+  @Description: Name of the FM-Test chardev
+*//***************************************************************************/
+#define DEV_FM_TEST_NAME                "fm-test-port"
+
+#define DEV_FM_TEST_PORTS_MINOR_BASE    0
+#define DEV_FM_TEST_MAX_MINORS          (DEV_FM_TEST_PORTS_MINOR_BASE + IOC_FMT_MAX_NUM_OF_PORTS)
+
+#define FMT_PORT_IOC_NUM(n)             n
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_lib_grp FM-Test library
+
+ @Description   TODO
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   TODO
+*//***************************************************************************/
+typedef uint8_t ioc_fmt_xxx_t;
+
+#define FM_PRS_MAX 32
+#define FM_TIME_STAMP_MAX 8
+
+/**************************************************************************//**
+ @Description   FM Port buffer content description
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_context_t {
+    void            *p_user_priv;
+    uint8_t         fm_prs_res[FM_PRS_MAX];
+    uint8_t         fm_time_stamp[FM_TIME_STAMP_MAX];
+} ioc_fmt_buff_context_t;
+
+#if defined(__KERNEL__) && defined(CONFIG_COMPAT)
+typedef struct ioc_fmt_compat_buff_context_t {
+    compat_uptr_t         p_user_priv;
+    uint8_t               fm_prs_res[FM_PRS_MAX];
+    uint8_t               fm_time_stamp[FM_TIME_STAMP_MAX];
+} ioc_fmt_compat_buff_context_t;
+#endif
+
+/**************************************************************************//**
+ @Description   Buffer descriptor
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_desc_t {
+    uint32_t               qid;
+    void                   *p_data;
+    uint32_t               size;
+    uint32_t               status;
+    ioc_fmt_buff_context_t buff_context;
+} ioc_fmt_buff_desc_t;
+
+#if defined(__KERNEL__) && defined(CONFIG_COMPAT)
+typedef struct ioc_fmt_compat_buff_desc_t {
+    uint32_t                qid;
+    compat_uptr_t           p_data;
+    uint32_t                size;
+    uint32_t                status;
+    ioc_fmt_compat_buff_context_t buff_context;
+} ioc_fmt_compat_buff_desc_t;
+#endif
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit
+
+ @Description   TODO
+ @{
+*//***************************************************************************/
+
+/** @} */ /* end of lnx_ioctl_FMT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library
+
+ @Description   TODO
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM-Test FM port type
+*//***************************************************************************/
+typedef enum ioc_fmt_port_type {
+    e_IOC_FMT_PORT_T_RXTX,  /**< Standard port */
+    e_IOC_FMT_PORT_T_OP,    /**< Offline-parsing port */
+} ioc_fmt_port_type;
+
+/**************************************************************************//**
+ @Description   TODO
+*//***************************************************************************/
+typedef struct ioc_fmt_port_param_t {
+    uint8_t             fm_id;
+    ioc_fmt_port_type   fm_port_type;
+    uint8_t             fm_port_id;
+    uint32_t            num_tx_queues;
+} ioc_fmt_port_param_t;
+
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_INIT
+
+ @Description   TODO
+
+ @Param[in]     ioc_fmt_port_param_t  TODO
+
+ @Cautions      Allowed only after the FM equivalent port is already initialized.
+*//***************************************************************************/
+#define FMT_PORT_IOC_INIT           _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_DIAG_MODE
+
+ @Description   TODO
+
+ @Param[in]     ioc_diag_mode  TODO
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_DIAG_MODE  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(1), ioc_diag_mode)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_IP_HEADER_MANIP
+
+ @Description   Set IP header manipulations for this port.
+
+ @Param[in]     int     1 to enable; 0 to disable
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_IP_HEADER_MANIP  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(2), int)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_DPAECHO_MODE
+
+ @Description   Set DPA in echo mode - all frame are sent back.
+
+ @Param[in]     int     1 to enable; 0 to disable
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_DPAECHO_MODE     _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(3), int)
+
+/** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_grp */
+
+
+#endif /* __FM_TEST_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/integrations/Kbuild b/include/uapi/linux/fmd/integrations/Kbuild
new file mode 100644
index 0000000..e548d676
--- /dev/null
+++ b/include/uapi/linux/fmd/integrations/Kbuild
@@ -0,0 +1 @@
+header-y += integration_ioctls.h
diff --git a/include/uapi/linux/fmd/integrations/integration_ioctls.h b/include/uapi/linux/fmd/integrations/integration_ioctls.h
new file mode 100644
index 0000000..61d696e
--- /dev/null
+++ b/include/uapi/linux/fmd/integrations/integration_ioctls.h
@@ -0,0 +1,56 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          integration_ioctls.h
+
+ @Description   External header file for Integration unit routines.
+*//***************************************************************************/
+
+#ifndef __INTG_IOCTLS_H
+#define __INTG_IOCTLS_H
+
+
+#define FM_IOC_TYPE_BASE            (NCSW_IOC_TYPE_BASE+1)
+#define FMT_IOC_TYPE_BASE           (NCSW_IOC_TYPE_BASE+3)
+
+/*#define FM_IOCTL_DBG*/
+
+#if defined(FM_IOCTL_DBG)
+    #define _fm_ioctl_dbg(format, arg...) \
+        printk("fm ioctl [%s:%u](cpu:%u) - " format, \
+            __func__, __LINE__, smp_processor_id(), ##arg)
+#else
+#   define _fm_ioctl_dbg(arg...)
+#endif
+
+#endif /* __INTG_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/ioctls.h b/include/uapi/linux/fmd/ioctls.h
new file mode 100644
index 0000000..4f36cb0
--- /dev/null
+++ b/include/uapi/linux/fmd/ioctls.h
@@ -0,0 +1,96 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ioctls.h
+
+ @Description   Structures and definitions for Command Relay Ioctls
+*//***************************************************************************/
+
+#ifndef __IOCTLS_H__
+#define __IOCTLS_H__
+
+#include <asm/ioctl.h>
+
+#include "integration_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_ncsw_grp    NetCommSw Linux User-Space (IOCTL) API
+ @{
+*//***************************************************************************/
+
+#define NCSW_IOC_TYPE_BASE          0xe0    /**< defines the IOCTL type for all
+                                                 the NCSW Linux module commands */
+
+
+/**************************************************************************//**
+ @Description   IOCTL Memory allocation types.
+*//***************************************************************************/
+typedef enum ioc_mem_type {
+    e_IOC_MEM_INVALID      = 0x00000000,  /**< Invalid memory type (error) */
+    e_IOC_MEM_CACHABLE_SYS = 0x00000001,  /**< Primary DDR, cacheable segment */
+    e_IOC_MEM_NOCACHE_SYS  = 0x00000004,  /**< Primary DDR, non-cacheable segment */
+    e_IOC_MEM_SECONDARY    = 0x00000002,  /**< Either secondary DDR or SDRAM */
+    e_IOC_MEM_PRAM         = 0x00000008   /**< Multi-user RAM identifier */
+} ioc_mem_type;
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum ioc_comm_mode {
+      e_IOC_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
+    , e_IOC_COMM_MODE_RX           = 1  /**< Only receive communication */
+    , e_IOC_COMM_MODE_TX           = 2  /**< Only transmit communication */
+    , e_IOC_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
+} ioc_comm_mode;
+
+/**************************************************************************//**
+ @Description   General Diagnostic Mode
+*//***************************************************************************/
+typedef enum ioc_diag_mode
+{
+    e_IOC_DIAG_MODE_NONE = 0,
+    e_IOC_DIAG_MODE_CTRL_LOOPBACK,      /**< loopback in the controller; E.g. MAC, TDM, etc. */
+    e_IOC_DIAG_MODE_CHIP_LOOPBACK,      /**< loopback in the chip but not in controller;
+                                         E.g. IO-pins, SerDes, etc. */
+    e_IOC_DIAG_MODE_PHY_LOOPBACK,       /**< loopback in the external PHY */
+    e_IOC_DIAG_MODE_LINE_LOOPBACK,      /**< loopback in the external line */
+    e_IOC_DIAG_MODE_CTRL_ECHO,          /**< */
+    e_IOC_DIAG_MODE_PHY_ECHO            /**< */
+} ioc_diag_mode;
+
+/** @} */ /* end of lnx_ioctl_ncsw_grp */
+
+
+#endif /* __IOCTLS_H__ */
diff --git a/include/uapi/linux/fmd/net_ioctls.h b/include/uapi/linux/fmd/net_ioctls.h
new file mode 100644
index 0000000..c99d64c
--- /dev/null
+++ b/include/uapi/linux/fmd/net_ioctls.h
@@ -0,0 +1,430 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/**************************************************************************//**
+ @File          net_ioctls.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_IOCTLS_H
+#define __NET_IOCTLS_H
+
+#include "ioctls.h"
+
+
+typedef uint8_t ioc_header_field_ppp_t;
+
+#define IOC_NET_HEADER_FIELD_PPP_PID                        (1)
+#define IOC_NET_HEADER_FIELD_PPP_COMPRESSED                 (IOC_NET_HEADER_FIELD_PPP_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_pppoe_t;
+
+#define IOC_NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define IOC_NET_HEADER_FIELD_PPPoE_TYPE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 1)
+#define IOC_NET_HEADER_FIELD_PPPoE_CODE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 2)
+#define IOC_NET_HEADER_FIELD_PPPoE_SID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 3)
+#define IOC_NET_HEADER_FIELD_PPPoE_LEN                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 4)
+#define IOC_NET_HEADER_FIELD_PPPoE_SESSION                  (IOC_NET_HEADER_FIELD_PPPoE_VER << 5)
+#define IOC_NET_HEADER_FIELD_PPPoE_PID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 6)
+#define IOC_NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_CKSUM                   (IOC_NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_COMPRESSED              (IOC_NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t ioc_header_field_eth_t;
+
+#define IOC_NET_HEADER_FIELD_ETH_DA                         (1)
+#define IOC_NET_HEADER_FIELD_ETH_SA                         (IOC_NET_HEADER_FIELD_ETH_DA << 1)
+#define IOC_NET_HEADER_FIELD_ETH_LENGTH                     (IOC_NET_HEADER_FIELD_ETH_DA << 2)
+#define IOC_NET_HEADER_FIELD_ETH_TYPE                       (IOC_NET_HEADER_FIELD_ETH_DA << 3)
+#define IOC_NET_HEADER_FIELD_ETH_FINAL_CKSUM                (IOC_NET_HEADER_FIELD_ETH_DA << 4)
+#define IOC_NET_HEADER_FIELD_ETH_PADDING                    (IOC_NET_HEADER_FIELD_ETH_DA << 5)
+#define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
+
+typedef uint16_t ioc_header_field_ip_t;
+
+#define IOC_NET_HEADER_FIELD_IP_VER                         (1)
+#define IOC_NET_HEADER_FIELD_IP_DSCP                        (IOC_NET_HEADER_FIELD_IP_VER << 2)
+#define IOC_NET_HEADER_FIELD_IP_ECN                         (IOC_NET_HEADER_FIELD_IP_VER << 3)
+#define IOC_NET_HEADER_FIELD_IP_PROTO                       (IOC_NET_HEADER_FIELD_IP_VER << 4)
+
+#define IOC_NET_HEADER_FIELD_IP_PROTO_SIZE                  1
+
+typedef uint16_t ioc_header_field_ipv4_t;
+
+#define IOC_NET_HEADER_FIELD_IPv4_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv4_HDR_LEN                   (IOC_NET_HEADER_FIELD_IPv4_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv4_TOS                       (IOC_NET_HEADER_FIELD_IPv4_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (IOC_NET_HEADER_FIELD_IPv4_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv4_ID                        (IOC_NET_HEADER_FIELD_IPv4_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_D                    (IOC_NET_HEADER_FIELD_IPv4_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_M                    (IOC_NET_HEADER_FIELD_IPv4_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv4_OFFSET                    (IOC_NET_HEADER_FIELD_IPv4_VER << 7)
+#define IOC_NET_HEADER_FIELD_IPv4_TTL                       (IOC_NET_HEADER_FIELD_IPv4_VER << 8)
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO                     (IOC_NET_HEADER_FIELD_IPv4_VER << 9)
+#define IOC_NET_HEADER_FIELD_IPv4_CKSUM                     (IOC_NET_HEADER_FIELD_IPv4_VER << 10)
+#define IOC_NET_HEADER_FIELD_IPv4_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 11)
+#define IOC_NET_HEADER_FIELD_IPv4_DST_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 12)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS                      (IOC_NET_HEADER_FIELD_IPv4_VER << 13)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT                (IOC_NET_HEADER_FIELD_IPv4_VER << 14)
+#define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPv4_ADDR_SIZE                 4
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO_SIZE                1
+
+
+typedef uint8_t ioc_header_field_ipv6_t;
+
+#define IOC_NET_HEADER_FIELD_IPv6_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv6_TC                        (IOC_NET_HEADER_FIELD_IPv6_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv6_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv6_DST_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR                  (IOC_NET_HEADER_FIELD_IPv6_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv6_FL                        (IOC_NET_HEADER_FIELD_IPv6_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (IOC_NET_HEADER_FIELD_IPv6_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE                 16
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR_SIZE             1
+
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ICMP_CODE                      (IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_ICMP_CKSUM                     (IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_ICMP_ID                        (IOC_NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM                    (IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_ICMP_CODE_SIZE                 1
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE_SIZE                 1
+
+#define IOC_NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define IOC_NET_HEADER_FIELD_IGMP_TYPE                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define IOC_NET_HEADER_FIELD_IGMP_CKSUM                     (IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define IOC_NET_HEADER_FIELD_IGMP_DATA                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define IOC_NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t ioc_header_field_tcp_t;
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_TCP_PORT_DST                   (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_TCP_SEQ                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_TCP_ACK                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_TCP_OFFSET                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_TCP_FLAGS                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_TCP_WINDOW                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define IOC_NET_HEADER_FIELD_TCP_CKSUM                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define IOC_NET_HEADER_FIELD_TCP_URGPTR                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS                       (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT                 (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SIZE                  2
+
+
+typedef uint8_t ioc_header_field_sctp_t;
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_DST                  (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_VER_TAG                   (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CKSUM                     (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SIZE                 2
+
+typedef uint8_t ioc_header_field_dccp_t;
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_DST                  (IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SIZE                 2
+
+
+typedef uint8_t ioc_header_field_udp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_UDP_PORT_DST                   (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LEN                        (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_CKSUM                      (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SIZE                  2
+
+typedef uint8_t ioc_header_field_udp_lite_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC              (1)
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_DST              (IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LITE_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SIZE             2
+
+typedef uint8_t ioc_header_field_udp_encap_esp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST         (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN              (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM            (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI              (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SIZE        2
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI_SIZE         4
+
+#define IOC_NET_HEADER_FIELD_IPHC_CID                       (1)
+#define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE                  (IOC_NET_HEADER_FIELD_IPHC_CID << 1)
+#define IOC_NET_HEADER_FIELD_IPHC_HCINDEX                   (IOC_NET_HEADER_FIELD_IPHC_CID << 2)
+#define IOC_NET_HEADER_FIELD_IPHC_GEN                       (IOC_NET_HEADER_FIELD_IPHC_CID << 3)
+#define IOC_NET_HEADER_FIELD_IPHC_D_BIT                     (IOC_NET_HEADER_FIELD_IPHC_CID << 4)
+#define IOC_NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv2_VERSION                 (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LEN                     (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SESSION_ID              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NS                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NR                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define IOC_NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define IOC_NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ID                 (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_vlan_t;
+
+#define IOC_NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define IOC_NET_HEADER_FIELD_VLAN_CFI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define IOC_NET_HEADER_FIELD_VLAN_VID                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define IOC_NET_HEADER_FIELD_VLAN_LENGTH                    (IOC_NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define IOC_NET_HEADER_FIELD_VLAN_TYPE                      (IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_VLAN_TCI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI | \
+                                                             IOC_NET_HEADER_FIELD_VLAN_CFI | \
+                                                             IOC_NET_HEADER_FIELD_VLAN_VID)
+
+
+typedef uint8_t ioc_header_field_llc_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define IOC_NET_HEADER_FIELD_LLC_SSAP                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 1)
+#define IOC_NET_HEADER_FIELD_LLC_CTRL                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 2)
+#define IOC_NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define IOC_NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_snap_t;
+
+#define IOC_NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define IOC_NET_HEADER_FIELD_SNAP_PID                       (IOC_NET_HEADER_FIELD_SNAP_OUI << 1)
+#define IOC_NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_snap_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE << 1) - 1)
+
+#define IOC_NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ARP_PTYPE                      (IOC_NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define IOC_NET_HEADER_FIELD_ARP_HLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define IOC_NET_HEADER_FIELD_ARP_PLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define IOC_NET_HEADER_FIELD_ARP_OPER                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define IOC_NET_HEADER_FIELD_ARP_SHA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define IOC_NET_HEADER_FIELD_ARP_SPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define IOC_NET_HEADER_FIELD_ARP_THA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define IOC_NET_HEADER_FIELD_ARP_TPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define IOC_NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define IOC_NET_HEADER_FIELD_RFC2684_NLPID                  (IOC_NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define IOC_NET_HEADER_FIELD_RFC2684_OUI                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define IOC_NET_HEADER_FIELD_RFC2684_PID                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_OUI                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_IDX                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define IOC_NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_PCDID             (IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define IOC_NET_HEADER_FIELD_MAX_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define IOC_NET_HEADER_FIELD_MIN_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_TYPE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define IOC_NET_HEADER_FIELD_FRAME_SIZE                     (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_gre_t;
+
+#define IOC_NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define IOC_NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_minencap_t;
+
+#define IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_DST_IP                (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_TYPE                  (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define IOC_NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_ah_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_NH                    (IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_esp_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                  (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM         (IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI_SIZE             4
+
+
+typedef uint8_t ioc_header_field_mpls_t;
+
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_macsec_t;
+
+#define IOC_NET_HEADER_FIELD_MACSEC_SECTAG                  (1)
+#define IOC_NET_HEADER_FIELD_MACSEC_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
+
+
+typedef enum {
+    e_IOC_NET_HEADER_TYPE_NONE = 0,
+    e_IOC_NET_HEADER_TYPE_PAYLOAD,
+    e_IOC_NET_HEADER_TYPE_ETH,
+    e_IOC_NET_HEADER_TYPE_VLAN,
+    e_IOC_NET_HEADER_TYPE_IPv4,
+    e_IOC_NET_HEADER_TYPE_IPv6,
+    e_IOC_NET_HEADER_TYPE_IP,
+    e_IOC_NET_HEADER_TYPE_TCP,
+    e_IOC_NET_HEADER_TYPE_UDP,
+    e_IOC_NET_HEADER_TYPE_UDP_LITE,
+    e_IOC_NET_HEADER_TYPE_IPHC,
+    e_IOC_NET_HEADER_TYPE_SCTP,
+    e_IOC_NET_HEADER_TYPE_SCTP_CHUNK_DATA,
+    e_IOC_NET_HEADER_TYPE_PPPoE,
+    e_IOC_NET_HEADER_TYPE_PPP,
+    e_IOC_NET_HEADER_TYPE_PPPMUX,
+    e_IOC_NET_HEADER_TYPE_PPPMUX_SUBFRAME,
+    e_IOC_NET_HEADER_TYPE_L2TPv2,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_CTRL,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_SESS,
+    e_IOC_NET_HEADER_TYPE_LLC,
+    e_IOC_NET_HEADER_TYPE_LLC_SNAP,
+    e_IOC_NET_HEADER_TYPE_NLPID,
+    e_IOC_NET_HEADER_TYPE_SNAP,
+    e_IOC_NET_HEADER_TYPE_MPLS,
+    e_IOC_NET_HEADER_TYPE_IPSEC_AH,
+    e_IOC_NET_HEADER_TYPE_IPSEC_ESP,
+    e_IOC_NET_HEADER_TYPE_UDP_ENCAP_ESP, /* RFC 3948 */
+    e_IOC_NET_HEADER_TYPE_MACSEC,
+    e_IOC_NET_HEADER_TYPE_GRE,
+    e_IOC_NET_HEADER_TYPE_MINENCAP,
+    e_IOC_NET_HEADER_TYPE_DCCP,
+    e_IOC_NET_HEADER_TYPE_ICMP,
+    e_IOC_NET_HEADER_TYPE_IGMP,
+    e_IOC_NET_HEADER_TYPE_ARP,
+    e_IOC_NET_HEADER_TYPE_CAPWAP,
+    e_IOC_NET_HEADER_TYPE_CAPWAP_DTLS,
+    e_IOC_NET_HEADER_TYPE_RFC2684,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L2,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L3,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L4,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM1,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM2,
+    e_IOC_NET_MAX_HEADER_TYPE_COUNT
+} ioc_net_header_type;
+
+
+#endif /* __NET_IOCTLS_H */
-- 
1.9.1

