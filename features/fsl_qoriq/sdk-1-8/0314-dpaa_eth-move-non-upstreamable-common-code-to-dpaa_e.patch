From 264fe2e6e0c70fef72f5536359a2e03d6a132e46 Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Mon, 5 Aug 2013 15:58:37 +0300
Subject: [PATCH 314/987] dpaa_eth: move non-upstreamable common code to
 dpaa_eth_base

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

The common code contains some parts that are not used in the
private interface code. Moved that code to a new file.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Change-Id: I5095bc0e7503c413d39e78cd5dff7bf84eebaca9
Reviewed-on: http://git.am.freescale.net:8181/3810
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Rivera Jose-B46482 <Jose.G.Rivera@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/Makefile        |   8 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth_base.c | 219 +++++++++++++++++++++
 drivers/net/ethernet/freescale/dpa/dpaa_eth_base.h |  46 +++++
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   | 175 ----------------
 .../net/ethernet/freescale/dpa/dpaa_eth_common.h   |   5 -
 .../net/ethernet/freescale/dpa/dpaa_eth_macless.c  |   1 +
 .../net/ethernet/freescale/dpa/dpaa_eth_proxy.c    |   1 +
 .../net/ethernet/freescale/dpa/dpaa_eth_shared.c   |   1 +
 8 files changed, 273 insertions(+), 183 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/dpaa_eth_base.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/dpaa_eth_base.h

diff --git a/drivers/net/ethernet/freescale/dpa/Makefile b/drivers/net/ethernet/freescale/dpa/Makefile
index 413bd06..b088046 100644
--- a/drivers/net/ethernet/freescale/dpa/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/Makefile
@@ -12,13 +12,15 @@ obj-$(CONFIG_FSL_DPAA_1588) += dpaa_1588.o
 obj-$(CONFIG_FSL_DPAA_ETH_SG_SUPPORT) += fsl-dpa-sg.o
 # dpaa_debugfs needs to be initialized before dpaa_eth
 obj-$(CONFIG_FSL_DPAA_ETH_DEBUGFS) += dpaa_debugfs.o
-obj-$(CONFIG_FSL_DPAA_ETH) += fsl-mac.o fsl-dpa.o \
- fsl-dpa-shared.o fsl-dpa-macless.o fsl-dpa-proxy.o
+obj-$(CONFIG_FSL_DPAA_ETH) += fsl-mac.o fsl-dpa.o fsl-dpa-common.o \
+ fsl-dpa-base.o fsl-dpa-shared.o fsl-dpa-macless.o fsl-dpa-proxy.o
 obj-$(CONFIG_FSL_DPAA_OFFLINE_PORTS) += fsl-oh.o
 obj-$(CONFIG_FSL_DPAA_ETH_UNIT_TESTS) += dpaa_eth_unit_test.o
 
-fsl-dpa-objs	:= dpa-ethtool.o dpaa_eth_common.o dpaa_eth_sysfs.o \
+fsl-dpa-objs	:= dpa-ethtool.o dpaa_eth_sysfs.o \
   dpaa_eth.o dpaa_eth_non_sg.o
+fsl-dpa-common-objs	:= dpaa_eth_common.o
+fsl-dpa-base-objs	:= dpaa_eth_base.o
 fsl-dpa-sg-objs	:= dpaa_eth_sg.o
 fsl-dpa-shared-objs	:= dpaa_eth_shared.o
 fsl-dpa-macless-objs	:= dpaa_eth_macless.o
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_base.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_base.c
new file mode 100644
index 0000000..95da2a3
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_base.c
@@ -0,0 +1,219 @@
+/* Copyright 2008-2013 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_net.h>
+#include <linux/etherdevice.h>
+#include <linux/kthread.h>
+#include <linux/percpu.h>
+#include <linux/highmem.h>
+#include <linux/sort.h>
+#include <linux/fsl_qman.h>
+#include "dpaa_eth.h"
+#include "dpaa_eth_common.h"
+
+static int dpa_bp_cmp(const void *dpa_bp0, const void *dpa_bp1)
+{
+	return ((struct dpa_bp *)dpa_bp0)->size -
+			((struct dpa_bp *)dpa_bp1)->size;
+}
+
+struct dpa_bp * __cold __must_check /* __attribute__((nonnull)) */
+dpa_bp_probe(struct platform_device *_of_dev, size_t *count)
+{
+	int			 i, lenp, na, ns;
+	struct device		*dev;
+	struct device_node	*dev_node;
+	const phandle		*phandle_prop;
+	const uint32_t		*bpid;
+	const uint32_t		*bpool_cfg;
+	struct dpa_bp		*dpa_bp;
+
+	dev = &_of_dev->dev;
+
+	/* The default is one, if there's no property */
+	*count = 1;
+
+	/* Get the buffer pools to be used */
+	phandle_prop = of_get_property(dev->of_node,
+					"fsl,bman-buffer-pools", &lenp);
+
+	if (phandle_prop)
+		*count = lenp / sizeof(phandle);
+	else {
+		dev_err(dev,
+			"missing fsl,bman-buffer-pools device tree entry\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	dpa_bp = devm_kzalloc(dev, *count * sizeof(*dpa_bp), GFP_KERNEL);
+	if (unlikely(dpa_bp == NULL)) {
+		dev_err(dev, "devm_kzalloc() failed\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	dev_node = of_find_node_by_path("/");
+	if (unlikely(dev_node == NULL)) {
+		dev_err(dev, "of_find_node_by_path(/) failed\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	na = of_n_addr_cells(dev_node);
+	ns = of_n_size_cells(dev_node);
+
+	for (i = 0; i < *count && phandle_prop; i++) {
+		of_node_put(dev_node);
+		dev_node = of_find_node_by_phandle(phandle_prop[i]);
+		if (unlikely(dev_node == NULL)) {
+			dev_err(dev, "of_find_node_by_phandle() failed\n");
+			return ERR_PTR(-EFAULT);
+		}
+
+		if (unlikely(!of_device_is_compatible(dev_node, "fsl,bpool"))) {
+			dev_err(dev,
+				"!of_device_is_compatible(%s, fsl,bpool)\n",
+				dev_node->full_name);
+			dpa_bp = ERR_PTR(-EINVAL);
+			goto _return_of_node_put;
+		}
+
+		bpid = of_get_property(dev_node, "fsl,bpid", &lenp);
+		if ((bpid == NULL) || (lenp != sizeof(*bpid))) {
+			dev_err(dev, "fsl,bpid property not found.\n");
+			dpa_bp = ERR_PTR(-EINVAL);
+			goto _return_of_node_put;
+		}
+		dpa_bp[i].bpid = *bpid;
+
+		bpool_cfg = of_get_property(dev_node, "fsl,bpool-ethernet-cfg",
+					&lenp);
+		if (bpool_cfg && (lenp == (2 * ns + na) * sizeof(*bpool_cfg))) {
+			const uint32_t *seed_pool;
+
+			dpa_bp[i].config_count =
+				(int)of_read_number(bpool_cfg, ns);
+			dpa_bp[i].size	= of_read_number(bpool_cfg + ns, ns);
+			dpa_bp[i].paddr	=
+				of_read_number(bpool_cfg + 2 * ns, na);
+
+			seed_pool = of_get_property(dev_node,
+					"fsl,bpool-ethernet-seeds", &lenp);
+			dpa_bp[i].seed_pool = !!seed_pool;
+
+		} else {
+			dev_err(dev,
+				"Missing/invalid fsl,bpool-ethernet-cfg device tree entry for node %s\n",
+				dev_node->full_name);
+			dpa_bp = ERR_PTR(-EINVAL);
+			goto _return_of_node_put;
+		}
+	}
+
+	sort(dpa_bp, *count, sizeof(*dpa_bp), dpa_bp_cmp, NULL);
+
+	return dpa_bp;
+
+_return_of_node_put:
+	if (dev_node)
+		of_node_put(dev_node);
+
+	return dpa_bp;
+}
+
+int dpa_bp_shared_port_seed(struct dpa_bp *bp)
+{
+	/* In MAC-less and Shared-MAC scenarios the physical
+	 * address of the buffer pool in device tree is set
+	 * to 0 to specify that another entity (USDPAA) will
+	 * allocate and seed the buffers
+	 */
+	if (!bp->paddr)
+		return 0;
+
+	/* allocate memory region for buffers */
+	devm_request_mem_region(bp->dev, bp->paddr,
+			bp->size * bp->config_count, KBUILD_MODNAME);
+	bp->vaddr = devm_ioremap_prot(bp->dev, bp->paddr,
+			bp->size * bp->config_count, 0);
+	if (bp->vaddr == NULL) {
+		pr_err("Could not map memory for pool %d\n", bp->bpid);
+		return -EIO;
+	}
+
+	/* seed pool with buffers from that memory region */
+	if (bp->seed_pool) {
+		int count = bp->target_count;
+		size_t addr = bp->paddr;
+
+		while (count) {
+			struct bm_buffer bufs[8];
+			int num_bufs = 0;
+
+			do {
+				BUG_ON(addr > 0xffffffffffffull);
+				bufs[num_bufs].bpid = bp->bpid;
+				bm_buffer_set64(&bufs[num_bufs++], addr);
+				addr += bp->size;
+
+			} while (--count && (num_bufs < 8));
+
+			while (bman_release(bp->pool, bufs, num_bufs, 0))
+				cpu_relax();
+		}
+	}
+
+	return 0;
+}
+
+int dpa_bp_create(struct net_device *net_dev, struct dpa_bp *dpa_bp,
+		size_t count)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	int i;
+
+	priv->dpa_bp = dpa_bp;
+	priv->bp_count = count;
+
+	for (i = 0; i < count; i++) {
+		int err;
+		err = dpa_bp_alloc(&dpa_bp[i]);
+		if (err < 0) {
+			dpa_bp_free(priv, dpa_bp);
+			priv->dpa_bp = NULL;
+			return err;
+		}
+	}
+
+	return 0;
+}
+
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_base.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth_base.h
new file mode 100644
index 0000000..5b5ef1e
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_base.h
@@ -0,0 +1,46 @@
+/* Copyright 2008-2013 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DPAA_ETH_BASE_H
+#define __DPAA_ETH_BASE_H
+
+#include <linux/etherdevice.h> /* struct net_device */
+#include <linux/fsl_bman.h> /* struct bm_buffer */
+#include <linux/of_platform.h> /* struct platform_device */
+#include <linux/net_tstamp.h>	/* struct hwtstamp_config */
+
+struct dpa_bp * __cold __must_check /* __attribute__((nonnull)) */
+dpa_bp_probe(struct platform_device *_of_dev, size_t *count);
+int dpa_bp_create(struct net_device *net_dev, struct dpa_bp *dpa_bp,
+		size_t count);
+int dpa_bp_shared_port_seed(struct dpa_bp *bp);
+
+#endif /* __DPAA_ETH_BASE_H */
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index 1e6569d..5be9db0 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -643,159 +643,6 @@ void dpa_set_buffers_layout(struct mac_device *mac_dev,
 	layout[RX].data_align = params.data_align ? : DPA_FD_DATA_ALIGNMENT;
 }
 
-static int dpa_bp_cmp(const void *dpa_bp0, const void *dpa_bp1)
-{
-	return ((struct dpa_bp *)dpa_bp0)->size -
-			((struct dpa_bp *)dpa_bp1)->size;
-}
-
-struct dpa_bp * __cold __must_check /* __attribute__((nonnull)) */
-dpa_bp_probe(struct platform_device *_of_dev, size_t *count)
-{
-	int			 i, lenp, na, ns;
-	struct device		*dev;
-	struct device_node	*dev_node;
-	const phandle		*phandle_prop;
-	const uint32_t		*bpid;
-	const uint32_t		*bpool_cfg;
-	struct dpa_bp		*dpa_bp;
-
-	dev = &_of_dev->dev;
-
-	/* The default is one, if there's no property */
-	*count = 1;
-
-	/* Get the buffer pools to be used */
-	phandle_prop = of_get_property(dev->of_node,
-					"fsl,bman-buffer-pools", &lenp);
-
-	if (phandle_prop)
-		*count = lenp / sizeof(phandle);
-	else {
-		dev_err(dev,
-			"missing fsl,bman-buffer-pools device tree entry\n");
-		return ERR_PTR(-EINVAL);
-	}
-
-	dpa_bp = devm_kzalloc(dev, *count * sizeof(*dpa_bp), GFP_KERNEL);
-	if (unlikely(dpa_bp == NULL)) {
-		dev_err(dev, "devm_kzalloc() failed\n");
-		return ERR_PTR(-ENOMEM);
-	}
-
-	dev_node = of_find_node_by_path("/");
-	if (unlikely(dev_node == NULL)) {
-		dev_err(dev, "of_find_node_by_path(/) failed\n");
-		return ERR_PTR(-EINVAL);
-	}
-
-	na = of_n_addr_cells(dev_node);
-	ns = of_n_size_cells(dev_node);
-
-	for (i = 0; i < *count && phandle_prop; i++) {
-		of_node_put(dev_node);
-		dev_node = of_find_node_by_phandle(phandle_prop[i]);
-		if (unlikely(dev_node == NULL)) {
-			dev_err(dev, "of_find_node_by_phandle() failed\n");
-			return ERR_PTR(-EFAULT);
-		}
-
-		if (unlikely(!of_device_is_compatible(dev_node, "fsl,bpool"))) {
-			dev_err(dev,
-				"!of_device_is_compatible(%s, fsl,bpool)\n",
-				dev_node->full_name);
-			dpa_bp = ERR_PTR(-EINVAL);
-			goto _return_of_node_put;
-		}
-
-		bpid = of_get_property(dev_node, "fsl,bpid", &lenp);
-		if ((bpid == NULL) || (lenp != sizeof(*bpid))) {
-			dev_err(dev, "fsl,bpid property not found.\n");
-			dpa_bp = ERR_PTR(-EINVAL);
-			goto _return_of_node_put;
-		}
-		dpa_bp[i].bpid = *bpid;
-
-		bpool_cfg = of_get_property(dev_node, "fsl,bpool-ethernet-cfg",
-					&lenp);
-		if (bpool_cfg && (lenp == (2 * ns + na) * sizeof(*bpool_cfg))) {
-			const uint32_t *seed_pool;
-
-			dpa_bp[i].config_count =
-				(int)of_read_number(bpool_cfg, ns);
-			dpa_bp[i].size	= of_read_number(bpool_cfg + ns, ns);
-			dpa_bp[i].paddr	=
-				of_read_number(bpool_cfg + 2 * ns, na);
-
-			seed_pool = of_get_property(dev_node,
-					"fsl,bpool-ethernet-seeds", &lenp);
-			dpa_bp[i].seed_pool = !!seed_pool;
-
-		} else {
-			dev_err(dev,
-				"Missing/invalid fsl,bpool-ethernet-cfg device tree entry for node %s\n",
-				dev_node->full_name);
-			dpa_bp = ERR_PTR(-EINVAL);
-			goto _return_of_node_put;
-		}
-	}
-
-	sort(dpa_bp, *count, sizeof(*dpa_bp), dpa_bp_cmp, NULL);
-
-	return dpa_bp;
-
-_return_of_node_put:
-	if (dev_node)
-		of_node_put(dev_node);
-
-	return dpa_bp;
-}
-
-int dpa_bp_shared_port_seed(struct dpa_bp *bp)
-{
-	/* In MAC-less and Shared-MAC scenarios the physical
-	 * address of the buffer pool in device tree is set
-	 * to 0 to specify that another entity (USDPAA) will
-	 * allocate and seed the buffers
-	 */
-	if (!bp->paddr)
-		return 0;
-
-	/* allocate memory region for buffers */
-	devm_request_mem_region(bp->dev, bp->paddr,
-			bp->size * bp->config_count, KBUILD_MODNAME);
-	bp->vaddr = devm_ioremap_prot(bp->dev, bp->paddr,
-			bp->size * bp->config_count, 0);
-	if (bp->vaddr == NULL) {
-		pr_err("Could not map memory for pool %d\n", bp->bpid);
-		return -EIO;
-	}
-
-	/* seed pool with buffers from that memory region */
-	if (bp->seed_pool) {
-		int count = bp->target_count;
-		size_t addr = bp->paddr;
-
-		while (count) {
-			struct bm_buffer bufs[8];
-			int num_bufs = 0;
-
-			do {
-				BUG_ON(addr > 0xffffffffffffull);
-				bufs[num_bufs].bpid = bp->bpid;
-				bm_buffer_set64(&bufs[num_bufs++], addr);
-				addr += bp->size;
-
-			} while (--count && (num_bufs < 8));
-
-			while (bman_release(bp->pool, bufs, num_bufs, 0))
-				cpu_relax();
-		}
-	}
-
-	return 0;
-}
-
 int __attribute__((nonnull))
 dpa_bp_alloc(struct dpa_bp *dpa_bp)
 {
@@ -857,28 +704,6 @@ pdev_register_failed:
 	return err;
 }
 
-int dpa_bp_create(struct net_device *net_dev, struct dpa_bp *dpa_bp,
-		size_t count)
-{
-	struct dpa_priv_s *priv = netdev_priv(net_dev);
-	int i;
-
-	priv->dpa_bp = dpa_bp;
-	priv->bp_count = count;
-
-	for (i = 0; i < count; i++) {
-		int err;
-		err = dpa_bp_alloc(&dpa_bp[i]);
-		if (err < 0) {
-			dpa_bp_free(priv, dpa_bp);
-			priv->dpa_bp = NULL;
-			return err;
-		}
-	}
-
-	return 0;
-}
-
 void dpa_bp_drain(struct dpa_bp *bp)
 {
 	int num;
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
index 8d11fe9..6ee9825 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
@@ -84,11 +84,6 @@ int dpa_set_mac_address(struct net_device *net_dev, void *addr);
 void dpa_set_rx_mode(struct net_device *net_dev);
 void dpa_set_buffers_layout(struct mac_device *mac_dev,
 		struct dpa_buffer_layout_s *layout);
-struct dpa_bp * __cold __must_check /* __attribute__((nonnull)) */
-dpa_bp_probe(struct platform_device *_of_dev, size_t *count);
-int dpa_bp_create(struct net_device *net_dev, struct dpa_bp *dpa_bp,
-		size_t count);
-int dpa_bp_shared_port_seed(struct dpa_bp *bp);
 int __attribute__((nonnull))
 dpa_bp_alloc(struct dpa_bp *dpa_bp);
 void __cold __attribute__((nonnull))
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c
index 3dc845e..b3736cb 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c
@@ -45,6 +45,7 @@
 #include <linux/fsl_qman.h>
 #include "dpaa_eth.h"
 #include "dpaa_eth_common.h"
+#include "dpaa_eth_base.h"
 #include "lnxwrp_fsl_fman.h" /* fm_get_rx_extra_headroom(), fm_get_max_frm() */
 
 /* For MAC-based interfaces, we compute the tx needed headroom from the
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c
index 22a941a..49636f4 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c
@@ -39,6 +39,7 @@
 #include <linux/of_platform.h>
 #include "dpaa_eth.h"
 #include "dpaa_eth_common.h"
+#include "dpaa_eth_base.h"
 #include "lnxwrp_fsl_fman.h" /* fm_get_rx_extra_headroom(), fm_get_max_frm() */
 
 #define DPA_DESCRIPTION "FSL DPAA Proxy initialization driver"
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
index c0b9cf2..0280088 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
@@ -44,6 +44,7 @@
 #include <linux/fsl_qman.h>
 #include "dpaa_eth.h"
 #include "dpaa_eth_common.h"
+#include "dpaa_eth_base.h"
 #include "lnxwrp_fsl_fman.h" /* fm_get_rx_extra_headroom(), fm_get_max_frm() */
 
 /* forward declarations */
-- 
1.9.1

