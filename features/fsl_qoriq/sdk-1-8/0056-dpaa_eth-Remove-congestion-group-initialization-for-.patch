From 067d3a512762e9a41d5fca9897f0ea5e56f04469 Mon Sep 17 00:00:00 2001
From: Cristian Sovaiala <cristian.sovaiala@freescale.com>
Date: Thu, 21 Feb 2013 18:59:13 +0000
Subject: [PATCH 056/987] dpaa_eth: Remove congestion group initialization for
 mac-less interfaces

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

MAC-less devices initialize their own RX frame queues, assuming that
the TX queues will be initialized by the other partition.

We cannot rely on the second partition to place the TX queues of
the first partition into congestion groups because the congestion
interrupt will then be received by the second partition instead
of the partition enqueueing the frames (in this case the first
partition).

Supporting congestion on MAC-less devices would involve too much
code and device tree changes so we simply use taildrop mechanism
for now.

Change-Id: I91f9f65a1197f0bacf6193e2515681f6ee0e43c1
Signed-off-by: Cristian Sovaiala <cristian.sovaiala@freescale.com>
(cherry picked from commit 541a17db5a2a0d17d9548eae67492ed6c2d0b736)
Reviewed-on: http://git.am.freescale.net:8181/1054
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c | 17 ++++++++---------
 1 file changed, 8 insertions(+), 9 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index ab848b3..3253243 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -95,8 +95,6 @@
  *	- running out of memory if the CS threshold is set too high.
  */
 #define DPA_CS_THRESHOLD_1G	0x06000000
-/* Set a congestion threshold for MAC-less devices, too. */
-#define DPA_CS_THRESHOLD_MACLESS	0x10000000
 
 /* S/G table requires at least 256 bytes */
 #define SGT_BUFFER_SIZE		DPA_BP_SIZE(256)
@@ -3823,9 +3821,7 @@ static int dpaa_eth_cgr_init(struct dpa_priv_s *priv)
 	 * lower than its max, e.g. if a dTSEC later negotiates a 100Mbps link.
 	 * In such cases, we ought to reconfigure the threshold, too.
 	 */
-	if (!priv->mac_dev)
-		cs_th = DPA_CS_THRESHOLD_MACLESS;
-	else if (priv->mac_dev->if_support & SUPPORTED_10000baseT_Full)
+	if (priv->mac_dev->if_support & SUPPORTED_10000baseT_Full)
 		cs_th = DPA_CS_THRESHOLD_10G;
 	else
 		cs_th = DPA_CS_THRESHOLD_1G;
@@ -4013,11 +4009,14 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		 * dynamically-allocated CGR ID.
 		 * Must be executed after probing the MAC, but before
 		 * assigning the egress FQs to the CGRs.
+		 * Don't create a congestion group for MAC-less interfaces.
 		 */
-		err = dpaa_eth_cgr_init(priv);
-		if (err < 0) {
-			dpaa_eth_err(dev, "Error initializing CGR\n");
-			goto cgr_init_failed;
+		if (priv->mac_dev) {
+			err = dpaa_eth_cgr_init(priv);
+			if (err < 0) {
+				dpaa_eth_err(dev, "Error initializing CGR\n");
+				goto cgr_init_failed;
+			}
 		}
 
 		/* Add the FQs to the interface, and make them active */
-- 
1.9.1

