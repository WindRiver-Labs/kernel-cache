From 5d462e91594be443673104d8b982479a754f08f9 Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Thu, 11 Sep 2014 16:59:20 +0800
Subject: [PATCH 446/987] dpaa_eth: Fix DMA unmapping of buffers on Rx

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

On the Rx path, we only DMA unmap the data buffer once we are
certain that we can allocate an associated skb. Otherwise we need
to keep the original mapping and release the buffer back into the
bpool.

This fixes a bug introduced by the patch that added ASF hooks in
the S/G driver code.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: I2fc5389727e94655113b52f31cad4b893b6a93f0
Reviewed-on: http://git.am.freescale.net:8181/6974
Reviewed-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
(cherry picked from commit 8ef708a109ced1eeaf2af87d7c897fff74c15cbd)
Old change Id: I2fc5389727e94655113b52f31cad4b893b6a93f0
Reviewed-on: http://git.am.freescale.net:8181/7071
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/7682
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Tested-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index c423b04..7d37ada 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -555,14 +555,17 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	/* The only FD types that we may receive are contig and S/G */
 	DPA_BUG_ON((fd->format != qm_fd_contig) && (fd->format != qm_fd_sg));
 
-	dma_unmap_single(dpa_bp->dev, addr, dpa_bp->size, DMA_BIDIRECTIONAL);
 	if (likely(fd->format == qm_fd_contig)) {
 		/* Execute the Rx processing hook, if it exists. */
 		if (dpaa_eth_hooks.rx_default &&
 			dpaa_eth_hooks.rx_default((void *)fd, net_dev, fqid)
-						== DPAA_ETH_STOLEN)
+						== DPAA_ETH_STOLEN) {
+			/* It's safe to unmap the buffer now */
+			dma_unmap_single(dpa_bp->dev, addr, dpa_bp->size,
+					 DMA_BIDIRECTIONAL);
 			/* won't count the rx bytes in */
 			return;
+		}
 		skb = contig_fd_to_skb(priv, fd, &use_gro);
 	} else
 		skb = sg_fd_to_skb(priv, fd, &use_gro);
@@ -577,6 +580,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	 * Also, permanently unmap the buffer.
 	 */
 	(*count_ptr)--;
+	dma_unmap_single(dpa_bp->dev, addr, dpa_bp->size, DMA_BIDIRECTIONAL);
 
 	skb->protocol = eth_type_trans(skb, net_dev);
 
-- 
1.9.1

