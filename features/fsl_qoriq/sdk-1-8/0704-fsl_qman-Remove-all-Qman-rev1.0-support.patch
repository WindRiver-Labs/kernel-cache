From ecbaf91c6c32192721e0842d7fe30f06a6aaf00c Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Wed, 14 Aug 2013 17:43:56 -0400
Subject: [PATCH 704/987] fsl_qman: Remove all Qman rev1.0 support

Because P4080 Rev1 is not supported any more.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: I78197d0a539cd825a6a63dc222b80ee551b13e33
Reviewed-on: http://git.am.freescale.net:8181/4298
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thorpe Geoff-R01361 <Geoff.Thorpe@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/Kconfig        |  13 ----
 drivers/staging/fsl_qbman/qman_config.c  |  38 +++--------
 drivers/staging/fsl_qbman/qman_debugfs.c |  16 ++---
 drivers/staging/fsl_qbman/qman_driver.c  |   4 +-
 drivers/staging/fsl_qbman/qman_high.c    |  40 +----------
 drivers/staging/fsl_qbman/qman_low.h     | 112 -------------------------------
 drivers/staging/fsl_qbman/qman_private.h |   1 -
 7 files changed, 18 insertions(+), 206 deletions(-)

diff --git a/drivers/staging/fsl_qbman/Kconfig b/drivers/staging/fsl_qbman/Kconfig
index e6b63e2..c857514 100644
--- a/drivers/staging/fsl_qbman/Kconfig
+++ b/drivers/staging/fsl_qbman/Kconfig
@@ -89,19 +89,6 @@ config FSL_QMAN
 
 if FSL_QMAN
 
-config FSL_QMAN_BUG_AND_FEATURE_REV1
-	bool "workarounds for errata and missing features in p4080 rev1"
-	default y
-	---help---
-	  If this option is selected, the driver will be compiled with
-	  workarounds for errata as well as feature limitations (relative to
-	  more recent parts) of p4080 rev1. On unaffected revisions, this
-	  support incurs only a negligable overhead, typically only a couple of
-	  instructions per non-fast-path operation (the fast-path operations are
-	  unaffected).
-
-	  If in doubt, say Y.
-
 config FSL_QMAN_POLL_LIMIT
 	int
 	default 32
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 3ab72b4..706d3ec 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -319,21 +319,6 @@ static void qm_set_wq_scheduling(struct qman *qm, enum qm_wq_class wq_class,
 			u8 cs_elev, u8 csw2, u8 csw3, u8 csw4, u8 csw5,
 			u8 csw6, u8 csw7)
 {
-#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
-#define csw(x) \
-do { \
-	if (++x == 8) \
-		x = 7; \
-} while (0)
-	if (qman_ip_rev == QMAN_REV10) {
-		csw(csw2);
-		csw(csw3);
-		csw(csw4);
-		csw(csw5);
-		csw(csw6);
-		csw(csw7);
-	}
-#endif
 	qm_out(WQ_CS_CFG(wq_class), ((cs_elev & 0xff) << 24) |
 		((csw2 & 0x7) << 20) | ((csw3 & 0x7) << 16) |
 		((csw4 & 0x7) << 12) | ((csw5 & 0x7) << 8) |
@@ -342,11 +327,6 @@ do { \
 
 static void qm_set_hid(struct qman *qm)
 {
-#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
-	if (qman_ip_rev == QMAN_REV10)
-		qm_out(HID_CFG, 3);
-	else
-#endif
 	qm_out(HID_CFG, 0);
 }
 
@@ -538,9 +518,11 @@ static int __init fsl_qman_init(struct device_node *node)
 	qm_get_version(qm, &id, &major, &minor, &cfg);
 	pr_info("Qman ver:%04x,%02x,%02x,%02x\n", id, major, minor, cfg);
 	if (!qman_ip_rev) {
-		if ((major == 1) && (minor == 0))
-			qman_ip_rev = QMAN_REV10;
-		else if ((major == 1) && (minor == 1))
+		if ((major == 1) && (minor == 0)) {
+			pr_err("QMAN rev1.0 on P4080 rev1 is not supported!\n");
+			iounmap(regs);
+			return -ENODEV;
+		} else if ((major == 1) && (minor == 1))
 			qman_ip_rev = QMAN_REV11;
 		else if	((major == 1) && (minor == 2))
 			qman_ip_rev = QMAN_REV12;
@@ -1080,12 +1062,10 @@ static int of_fsl_qman_probe(struct platform_device *ofdev)
 	ret = sysfs_create_group(&ofdev->dev.kobj, &qman_dev_attr_grp);
 	if (ret)
 		goto done;
-	if (qman_ip_rev != QMAN_REV10) {
-		ret = sysfs_add_file_to_group(&ofdev->dev.kobj,
-			&dev_attr_sfdr_in_use.attr, qman_dev_attr_grp.name);
-		if (ret)
-			goto del_group_0;
-	}
+	ret = sysfs_add_file_to_group(&ofdev->dev.kobj,
+		&dev_attr_sfdr_in_use.attr, qman_dev_attr_grp.name);
+	if (ret)
+		goto del_group_0;
 	ret = sysfs_create_group(&ofdev->dev.kobj, &qman_dev_ecr_grp);
 	if (ret)
 		goto del_group_0;
diff --git a/drivers/staging/fsl_qbman/qman_debugfs.c b/drivers/staging/fsl_qbman/qman_debugfs.c
index 1459150..06e52b1 100644
--- a/drivers/staging/fsl_qbman/qman_debugfs.c
+++ b/drivers/staging/fsl_qbman/qman_debugfs.c
@@ -537,11 +537,9 @@ static int query_cgr_show(struct seq_file *file, void *offset)
 	seq_printf(file, " cs_thresh_TA: %u, cs_thresh_Tn: %u\n",
 		cgrd.cgr.cs_thres.TA, cgrd.cgr.cs_thres.Tn);
 
-	if (qman_ip_rev != QMAN_REV10) {
-		seq_printf(file, " mode: %s\n",
-			(cgrd.cgr.mode & QMAN_CGR_MODE_FRAME) ?
-			"frame count" : "byte count");
-	}
+	seq_printf(file, " mode: %s\n",
+		(cgrd.cgr.mode & QMAN_CGR_MODE_FRAME) ?
+		"frame count" : "byte count");
 	seq_printf(file, " i_bcnt: %llu\n", qm_mcr_querycgr_i_get64(&cgrd));
 	seq_printf(file, " a_bcnt: %llu\n", qm_mcr_querycgr_a_get64(&cgrd));
 
@@ -622,11 +620,9 @@ static int testwrite_cgr_show(struct seq_file *file, void *offset)
 		result.cgr.cs_thres.TA, result.cgr.cs_thres.Tn);
 
 	/* Add Mode for Si 2 */
-	if (qman_ip_rev != QMAN_REV10) {
-		seq_printf(file, " mode: %s\n",
-			(result.cgr.mode & QMAN_CGR_MODE_FRAME) ?
-			"frame count" : "byte count");
-	}
+	seq_printf(file, " mode: %s\n",
+		(result.cgr.mode & QMAN_CGR_MODE_FRAME) ?
+		"frame count" : "byte count");
 
 	seq_printf(file, " i_bcnt: %llu\n",
 		qm_mcr_cgrtestwrite_i_get64(&result));
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index ce42213..d74369b 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -299,8 +299,8 @@ static void qman_get_ip_revision(struct device_node *dn)
 			continue;
 		if (of_device_is_compatible(dn, "fsl,qman-portal-1.0") ||
 			of_device_is_compatible(dn, "fsl,qman-portal-1.0.0")) {
-			ip_rev = QMAN_REV10;
-			qman_portal_max = 10;
+			pr_err("QMAN rev1.0 on P4080 rev1 is not supported!\n");
+			BUG_ON(1);
 		} else if (of_device_is_compatible(dn, "fsl,qman-portal-1.1") ||
 			of_device_is_compatible(dn, "fsl,qman-portal-1.1.0")) {
 			ip_rev = QMAN_REV11;
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 4bfc337..370e260 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -1491,9 +1491,6 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 		return -EINVAL;
 #endif
 	if (opts && (opts->we_mask & QM_INITFQ_WE_OAC)) {
-		/* OAC not supported on rev1.0 */
-		if (unlikely(qman_ip_rev == QMAN_REV10))
-			return -EINVAL;
 		/* And can't be set at the same time as TDTHRESH */
 		if (opts->we_mask & QM_INITFQ_WE_TDTHRESH)
 			return -EINVAL;
@@ -2204,34 +2201,7 @@ static inline struct qm_eqcr_entry *try_p_eq_start(struct qman_portal *p,
 #else
 	eq->tag = (u32)(uintptr_t)fq;
 #endif
-	/* From p4080 rev1 -> rev2, the FD struct's address went from 48-bit to
-	 * 40-bit but rev1 chips will still interpret it as 48-bit, meaning we
-	 * have to scrub the upper 8-bits, just in case the user left noise in
-	 * there. Doing this selectively via a run-time check of the h/w
-	 * revision (as we do for most errata, for example) is too slow in this
-	 * critical path code. The most inexpensive way to handle this is just
-	 * to reinterpret the FD as 4 32-bit words and to mask the first word
-	 * appropriately, irrespecitive of the h/w revision. The struct fields
-	 * corresponding to this word are;
-	 *     u8 dd:2;
-	 *     u8 liodn_offset:6;
-	 *     u8 bpid;
-	 *     u8 eliodn_offset:4;
-	 *     u8 __reserved:4;
-	 *     u8 addr_hi;
-	 * So we mask this word with 0xc0ff00ff, which implicitly scrubs out
-	 * liodn_offset, eliodn_offset, and __reserved - the latter two fields
-	 * are interpreted as the 8 msbits of the 48-bit address in the case of
-	 * rev1.
-	 */
-	{
-		const u32 *src = (const u32 *)fd;
-		u32 *dest = (u32 *)&eq->fd;
-		dest[0] = src[0] & 0xc0ff00ff;
-		dest[1] = src[1];
-		dest[2] = src[2];
-		dest[3] = src[3];
-	}
+	eq->fd = *fd;
 	return eq;
 }
 
@@ -2558,14 +2528,6 @@ int qman_modify_cgr(struct qman_cgr *cgr, u32 flags,
 	u8 res;
 	u8 verb = QM_MCC_VERB_MODIFYCGR;
 
-	/* frame mode not supported on rev1.0 */
-	if (unlikely(qman_ip_rev == QMAN_REV10)) {
-		if (opts && (opts->we_mask & QM_CGR_WE_MODE) &&
-				opts->cgr.mode == QMAN_CGR_MODE_FRAME) {
-			put_affine_portal();
-			return -EIO;
-		}
-	}
 	PORTAL_IRQ_LOCK(p, irqflags);
 	mcc = qm_mc_start(&p->p);
 	if (opts)
diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index ab6b1a0..5d3e820 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -207,28 +207,7 @@ struct qm_mc {
 #endif
 };
 
-#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
-/* For workarounds that require storage. The struct alignment is required for
- * cases where operations on "shadow" structs need the same alignment as is
- * present on the corresponding h/w data structs (specifically, there is a
- * zero-bit present above the range required to address the ring, so that
- * iteration can be achieved by incrementing a ring pointer and clearing the
- * carry-bit). The "portal" struct needs the same alignment because this type
- * goes at its head, so it has a more radical alignment requirement if this
- * structure is used. (NB: "64" instead of "L1_CACHE_BYTES", because this
- * alignment relates to the h/w interface, not the CPU cache granularity!)*/
-#define QM_PORTAL_ALIGNMENT __attribute__((aligned(32 * 64)))
-struct qm_portal_bugs {
-	/* shadow MR ring, for QMAN9 workaround, 8-CL-aligned */
-	struct qm_mr_entry mr[QM_MR_SIZE];
-	/* shadow MC result, for QMAN6 and QMAN7 workarounds, CL-aligned */
-	struct qm_mc_result result;
-	/* boolean switch for QMAN7 workaround */
-	int initfq_and_sched;
-} QM_PORTAL_ALIGNMENT;
-#else
 #define QM_PORTAL_ALIGNMENT ____cacheline_aligned
-#endif
 
 struct qm_addr {
 	void __iomem *addr_ce;	/* cache-enabled */
@@ -236,9 +215,6 @@ struct qm_addr {
 };
 
 struct qm_portal {
-#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
-	struct qm_portal_bugs bugs;
-#endif
 	/* In the non-CONFIG_FSL_DPA_CHECKING case, the following stuff up to
 	 * and including 'mc' fits within a cacheline (yay!). The 'config' part
 	 * is setup-only, so isn't a cause for a concern. In other words, don't
@@ -886,45 +862,15 @@ static inline const struct qm_mr_entry *MR_INC(const struct qm_mr_entry *e)
 	return MR_CARRYCLEAR(e + 1);
 }
 
-#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
-static inline void __mr_copy_and_fixup(struct qm_portal *p, u8 idx)
-{
-	if (qman_ip_rev == QMAN_REV10) {
-		struct qm_mr_entry *shadow = qm_cl(p->bugs.mr, idx);
-		struct qm_mr_entry *res = qm_cl(p->mr.ring, idx);
-		copy_words(shadow, res, sizeof(*res));
-		/* Bypass the QM_MR_RC_*** definitions, and check the byte value
-		 * directly to handle the erratum. */
-		if (shadow->ern.rc == 0x06)
-			shadow->ern.rc = 0x60;
-	}
-}
-#else
-#define __mr_copy_and_fixup(p, idx) do { ; } while (0)
-#endif
-
 static inline int qm_mr_init(struct qm_portal *portal, enum qm_mr_pmode pmode,
 		enum qm_mr_cmode cmode)
 {
 	register struct qm_mr *mr = &portal->mr;
 	u32 cfg;
-	int loop;
 
-#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
-	if ((qman_ip_rev == QMAN_REV10) && (pmode != qm_mr_pvb)) {
-		pr_err("Qman is rev1, so QMAN9 workaround requires 'pvb'\n");
-		return -EINVAL;
-	}
-#endif
 	mr->ring = portal->addr.addr_ce + QM_CL_MR;
 	mr->pi = qm_in(MR_PI_CINH) & (QM_MR_SIZE - 1);
 	mr->ci = qm_in(MR_CI_CINH) & (QM_MR_SIZE - 1);
-#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
-	if (qman_ip_rev == QMAN_REV10)
-		/* Situate the cursor in the shadow ring */
-		mr->cursor = portal->bugs.mr + mr->ci;
-	else
-#endif
 	mr->cursor = mr->ring + mr->ci;
 	mr->fill = qm_cyc_diff(QM_MR_SIZE, mr->ci, mr->pi);
 	mr->vbit = (qm_in(MR_PI_CINH) & QM_MR_SIZE) ? QM_MR_VERB_VBIT : 0;
@@ -933,10 +879,6 @@ static inline int qm_mr_init(struct qm_portal *portal, enum qm_mr_pmode pmode,
 	mr->pmode = pmode;
 	mr->cmode = cmode;
 #endif
-	/* Only new entries get the copy-and-fixup treatment from
-	 * qm_mr_pvb_update(), so perform it here for any stale entries. */
-	for (loop = 0; loop < mr->fill; loop++)
-		__mr_copy_and_fixup(portal, (mr->ci + loop) & (QM_MR_SIZE - 1));
 	cfg = (qm_in(CFG) & 0xfffff0ff) |
 		((cmode & 1) << 8);		/* QCSP_CFG:MM */
 	qm_out(CFG, cfg);
@@ -1010,7 +952,6 @@ static inline void qm_mr_pvb_update(struct qm_portal *portal)
 	/* when accessing 'verb', use __raw_readb() to ensure that compiler
 	 * inlining doesn't try to optimise out "excess reads". */
 	if ((__raw_readb(&res->verb) & QM_MR_VERB_VBIT) == mr->vbit) {
-		__mr_copy_and_fixup(portal, mr->pi);
 		mr->pi = (mr->pi + 1) & (QM_MR_SIZE - 1);
 		if (!mr->pi)
 			mr->vbit ^= QM_MR_VERB_VBIT;
@@ -1131,40 +1072,6 @@ static inline void qm_mc_commit(struct qm_portal *portal, u8 myverb)
 	struct qm_mc_result *rr = mc->rr + mc->rridx;
 	DPA_ASSERT(mc->state == qman_mc_user);
 	lwsync();
-#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
-	if ((qman_ip_rev == QMAN_REV10) && ((myverb & QM_MCC_VERB_MASK) ==
-					QM_MCC_VERB_INITFQ_SCHED)) {
-		u32 fqid = mc->cr->initfq.fqid;
-		/* Do two commands to avoid the hw bug. Note, we poll locally
-		 * rather than using qm_mc_result() because from a DPA_CHECKING
-		 * perspective, we don't want to appear to have "finished" until
-		 * both commands are done. */
-		mc->cr->__dont_write_directly__verb = mc->vbit |
-					QM_MCC_VERB_INITFQ_PARKED;
-		dcbf(mc->cr);
-		portal->bugs.initfq_and_sched = 1;
-		do {
-			dcbit_ro(rr);
-		} while (!__raw_readb(&rr->verb));
-#ifdef CONFIG_FSL_DPA_CHECKING
-		mc->state = qman_mc_idle;
-#endif
-		if (rr->result != QM_MCR_RESULT_OK) {
-#ifdef CONFIG_FSL_DPA_CHECKING
-			mc->state = qman_mc_hw;
-#endif
-			return;
-		}
-		mc->rridx ^= 1;
-		mc->vbit ^= QM_MCC_VERB_VBIT;
-		rr = mc->rr + mc->rridx;
-		dcbz_64(mc->cr);
-		mc->cr->alterfq.fqid = fqid;
-		lwsync();
-		myverb = QM_MCC_VERB_ALTER_SCHED;
-	} else
-		portal->bugs.initfq_and_sched = 0;
-#endif
 	mc->cr->__dont_write_directly__verb = myverb | mc->vbit;
 	dcbf(mc->cr);
 	dcbit_ro(rr);
@@ -1185,25 +1092,6 @@ static inline struct qm_mc_result *qm_mc_result(struct qm_portal *portal)
 		dcbit_ro(rr);
 		return NULL;
 	}
-#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
-	if (qman_ip_rev == QMAN_REV10) {
-		if ((__raw_readb(&rr->verb) & QM_MCR_VERB_MASK) ==
-						QM_MCR_VERB_QUERYFQ) {
-			void *misplaced = (void *)rr + 50;
-			copy_words(&portal->bugs.result, rr, sizeof(*rr));
-			rr = &portal->bugs.result;
-			copy_shorts(&rr->queryfq.fqd.td, misplaced,
-				sizeof(rr->queryfq.fqd.td));
-		} else if (portal->bugs.initfq_and_sched) {
-			/* We split the user-requested command, make the final
-			 * result match the requested type. */
-			copy_words(&portal->bugs.result, rr, sizeof(*rr));
-			rr = &portal->bugs.result;
-			rr->verb = (rr->verb & QM_MCR_VERB_RRID) |
-					QM_MCR_VERB_INITFQ_SCHED;
-		}
-	}
-#endif
 	mc->rridx ^= 1;
 	mc->vbit ^= QM_MCC_VERB_VBIT;
 #ifdef CONFIG_FSL_DPA_CHECKING
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index e6c8cf8..e9f60d5 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -188,7 +188,6 @@ struct qm_portal_config {
 };
 
 /* Revision info (for errata and feature handling) */
-#define QMAN_REV10 0x0100
 #define QMAN_REV11 0x0101
 #define QMAN_REV12 0x0102
 #define QMAN_REV20 0x0200
-- 
1.9.1

