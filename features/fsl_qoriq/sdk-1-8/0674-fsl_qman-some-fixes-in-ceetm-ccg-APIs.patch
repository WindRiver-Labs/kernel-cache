From 37c9dfac4e0db1116f3d49e676ccfd764d885b0d Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Tue, 6 May 2014 17:04:44 -0400
Subject: [PATCH 674/987] fsl_qman: some fixes in ceetm ccg APIs

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

In ceetm_ccg_set(), check whether the cb_node is already in the list
before adding it to the list in order to make sure the cb_node will
only be added to list once. Also update the CSCN target only when
CSCN_EN mask is set. In ceetm_ccg_release(), check whether the
ccg->cb_node is in the list before deleting it.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: Ie48e3459d0c856d91fa84ff74676d2bbe69850ae
Reviewed-on: http://git.am.freescale.net:8181/11999
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/qman_high.c | 25 +++++++++++--------------
 1 file changed, 11 insertions(+), 14 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 7745401..4bfc337 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -4665,6 +4665,7 @@ int qman_ceetm_ccg_claim(struct qm_ceetm_ccg **ccg,
 	p->parent = channel;
 	p->cb = cscn;
 	p->cb_ctx = cb_ctx;
+	INIT_LIST_HEAD(&p->cb_node);
 
 	*ccg = p;
 	return 0;
@@ -4674,29 +4675,20 @@ EXPORT_SYMBOL(qman_ceetm_ccg_claim);
 int qman_ceetm_ccg_release(struct qm_ceetm_ccg *ccg)
 {
 	unsigned long irqflags __maybe_unused;
-	struct qm_ceetm_ccg *i;
 	struct qm_mcc_ceetm_ccgr_config config_opts;
 	int ret = 0;
 	struct qman_portal *p = get_affine_portal();
 
 	memset(&config_opts, 0, sizeof(struct qm_mcc_ceetm_ccgr_config));
 	spin_lock_irqsave(&p->ccgr_lock, irqflags);
-	list_del(&ccg->cb_node);
-	/*
-	 * If there is no other CCG objects for this CCGID, update
-	 * CSCN_TARG_UPP_CTR accordingly.
-	 */
-	list_for_each_entry(i, &p->ccgr_cbs[ccg->parent->dcp_idx], cb_node)
-		if ((i->idx == ccg->idx) && i->cb)
-			goto release_lock;
+	if (!list_empty(&ccg->cb_node))
+		list_del(&ccg->cb_node);
 	config_opts.ccgrid = CEETM_CCGR_CM_CONFIGURE |
 				(ccg->parent->idx << 4) | ccg->idx;
 	config_opts.dcpid = ccg->parent->dcp_idx;
 	config_opts.we_mask = QM_CCGR_WE_CSCN_TUPD;
 	config_opts.cm_config.cscn_tupd = PORTAL_IDX(p);
-
 	ret = qman_ceetm_configure_ccgr(&config_opts);
-release_lock:
 	spin_unlock_irqrestore(&p->ccgr_lock, irqflags);
 
 	list_del(&ccg->node);
@@ -4725,9 +4717,11 @@ int qman_ceetm_ccg_set(struct qm_ceetm_ccg *ccg, u16 we_mask,
 				(ccg->parent->idx << 4) | ccg->idx;
 	config_opts.dcpid = ccg->parent->dcp_idx;
 	config_opts.we_mask = we_mask;
-	config_opts.we_mask |= QM_CCGR_WE_CSCN_TUPD;
-	config_opts.cm_config.cscn_tupd =
+	if (we_mask & QM_CCGR_WE_CSCN_EN) {
+		config_opts.we_mask |= QM_CCGR_WE_CSCN_TUPD;
+		config_opts.cm_config.cscn_tupd =
 			QM_CGR_TARG_UDP_CTRL_WRITE_BIT | PORTAL_IDX(p);
+	}
 	config_opts.cm_config.ctl = (params->wr_en_g << 6) |
 				(params->wr_en_y << 5) |
 				(params->wr_en_r << 4) |
@@ -4748,7 +4742,10 @@ int qman_ceetm_ccg_set(struct qm_ceetm_ccg *ccg, u16 we_mask,
 		goto release_lock;
 	}
 
-	list_add(&ccg->cb_node, &p->ccgr_cbs[ccg->parent->dcp_idx]);
+	if (we_mask & QM_CCGR_WE_CSCN_EN)
+		if (list_empty(&ccg->cb_node))
+			list_add(&ccg->cb_node,
+				&p->ccgr_cbs[ccg->parent->dcp_idx]);
 release_lock:
 	spin_unlock_irqrestore(&p->ccgr_lock, irqflags);
 	put_affine_portal();
-- 
1.9.1

