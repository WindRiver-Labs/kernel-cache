From bd87dd0d66d753974c864d7e308f103db4895f0d Mon Sep 17 00:00:00 2001
From: Hou Zhiqiang <B48286@freescale.com>
Date: Wed, 26 Nov 2014 19:39:18 +0800
Subject: [PATCH 32/45] spi/fsl-espi: Add the 4Byte address width device
 support

Get the address width information from the spi_message to correct the
address to operate.

when the one-time transfer length exceed the max limited length of eSPI
controller 0xFFFF, for the subsequent transfer, the address to operate
need to be corrected.

Signed-off-by: Hou Zhiqiang <B48286@freescale.com>
Change-Id: I54cf8e76c29c660603b864ff1ef2096a2f817dba
Reviewed-on: http://git.am.freescale.net:8181/24586
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Original patch taken from QorIQ-SDK-V1.8-20150619-yocto]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/spi/spi-fsl-espi.c |   31 ++++++++++++++++++++++---------
 1 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 13fb9d3..78dedc8 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -250,19 +250,30 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	return mpc8xxx_spi->count;
 }
 
-static inline void fsl_espi_addr2cmd(unsigned int addr, u8 *cmd)
+static inline void fsl_espi_addr2cmd(unsigned int addr, u8 *cmd, u8 addr_width)
 {
 	if (cmd) {
-		cmd[1] = (u8)(addr >> 16);
-		cmd[2] = (u8)(addr >> 8);
-		cmd[3] = (u8)(addr >> 0);
+		if (addr_width == 3) {
+			cmd[1] = (u8)(addr >> 16);
+			cmd[2] = (u8)(addr >> 8);
+			cmd[3] = (u8)(addr >> 0);
+		} else if (addr_width == 4) {
+			cmd[1] = (u8)(addr >> 24);
+			cmd[2] = (u8)(addr >> 16);
+			cmd[3] = (u8)(addr >> 8);
+			cmd[4] = (u8)(addr >> 0);
+		}
 	}
 }
 
-static inline unsigned int fsl_espi_cmd2addr(u8 *cmd)
+static inline unsigned int fsl_espi_cmd2addr(u8 *cmd, u8 addr_width)
 {
-	if (cmd)
-		return cmd[1] << 16 | cmd[2] << 8 | cmd[3] << 0;
+	if (cmd) {
+		if (addr_width == 3)
+			return cmd[1] << 16 | cmd[2] << 8 | cmd[3] << 0;
+		else if (addr_width == 4)
+			return cmd[1] << 24 |cmd[2] << 16 | cmd[3] << 8 | cmd[4] << 0;
+	}
 
 	return 0;
 }
@@ -369,7 +380,9 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 	unsigned int rx_pos = 0;
 	unsigned int pos;
 	int i, loop;
+	u8 addr_width;
 
+	addr_width = m->addr_width;
 	local_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);
 	if (!local_buf) {
 		espi_trans->status = -ENOMEM;
@@ -399,9 +412,9 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 
 		/* Update device offset */
 		if (pos > 0) {
-			addr = fsl_espi_cmd2addr(local_buf);
+			addr = fsl_espi_cmd2addr(local_buf, addr_width);
 			addr += rx_pos;
-			fsl_espi_addr2cmd(addr, local_buf);
+			fsl_espi_addr2cmd(addr, local_buf, addr_width);
 		}
 
 		espi_trans->len = trans_len;
-- 
1.7.5.4

