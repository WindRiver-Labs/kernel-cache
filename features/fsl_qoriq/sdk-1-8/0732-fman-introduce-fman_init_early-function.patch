From 2cb8cfd1ce20bc24ddc60f1989a0a78a9671c98d Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 5 Dec 2012 17:32:13 +0800
Subject: [PATCH 732/987] fman: introduce fman_init_early function

We can't reset B/QMAN in dump kernel. So we just free all
the B/Qman resources before booting the dump kernel. Since we
also need to shutdown FMAN before we free these resources,
introduce fman_init_early function for kexec to register
a crash shutdown hooks to do this.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
[Modify for current kernel context.]
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/powerpc/platforms/85xx/corenet_generic.c      |  6 ++++
 .../freescale/fman/src/wrapper/lnxwrp_fm.c         | 35 ++++++++++++++++++++++
 2 files changed, 41 insertions(+)
 mode change 100755 => 100644 drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c

diff --git a/arch/powerpc/platforms/85xx/corenet_generic.c b/arch/powerpc/platforms/85xx/corenet_generic.c
index da98a81..372afee 100644
--- a/arch/powerpc/platforms/85xx/corenet_generic.c
+++ b/arch/powerpc/platforms/85xx/corenet_generic.c
@@ -206,6 +206,9 @@ static int __init corenet_generic_probe(void)
 /* Early setup is required for large chunks of contiguous (and coarsely-aligned)
  * memory. The following shoe-horns Q/Bman "init_early" calls into the
  * platform setup to let them parse their CCSR nodes early on. */
+#ifdef CONFIG_FSL_FMAN
+void __init fman_init_early(void);
+#endif
 #ifdef CONFIG_FSL_QMAN_CONFIG
 void __init qman_init_early(void);
 #endif
@@ -215,6 +218,9 @@ void __init bman_init_early(void);
 
 static __init void corenet_ds_init_early(void)
 {
+#ifdef CONFIG_FSL_FMAN
+	fman_init_early();
+#endif
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	qman_init_early();
 #endif
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
old mode 100755
new mode 100644
index 7978346..05bc1a1
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
@@ -64,6 +64,8 @@
 #include <linux/stat.h>	   /* For file access mask */
 #include <linux/skbuff.h>
 #include <linux/proc_fs.h>
+#include <linux/device.h>
+#include <asm/kexec.h>
 
 /* NetCommSw Headers --------------- */
 #include "std_ext.h"
@@ -1956,6 +1958,39 @@ EXPORT_SYMBOL(fm_mutex_unlock);
 
 static t_Handle h_FmLnxWrp;
 
+#ifdef CONFIG_KEXEC
+static int fm_crash_shutdown(struct device *dev, void *data)
+{
+
+	t_LnxWrpFmDev   *p;
+
+        struct platform_driver *drv = data;
+
+        if (dev->driver != &drv->driver)
+                return 0;
+
+        p = dev_get_drvdata(dev);
+
+        if (p->h_Dev)
+                FM_Free(p->h_Dev);
+
+        return 0;
+}
+
+static void fm_crash_shutdown_all(void)
+{
+        bus_for_each_dev(&platform_bus_type, NULL,
+                        &fm_driver, fm_crash_shutdown);
+}
+
+void __init fman_init_early(void)
+{
+        crash_shutdown_register(&fm_crash_shutdown_all);
+}
+#else
+void __init fman_init_early(void) {}
+#endif
+
 static int __init __cold fm_load (void)
 {
     if ((h_FmLnxWrp = LNXWRP_FM_Init()) == NULL)
-- 
1.9.1

