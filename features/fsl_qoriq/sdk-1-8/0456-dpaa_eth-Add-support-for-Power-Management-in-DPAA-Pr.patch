From 3d8f918259dcf53d1b099af70a0e3107d898ce85 Mon Sep 17 00:00:00 2001
From: Cristian Sovaiala <cristian.sovaiala@freescale.com>
Date: Fri, 25 Oct 2013 09:49:31 +0300
Subject: [PATCH 456/987] dpaa_eth: Add support for Power Management in DPAA
 Private Driver

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Implement Power Management suspend_noirq/resume_noirq specific
callbacks where we disable/enable the port if it is not AutoResponse
enabled (the decision is taken by the FMan driver), otherwise the
port remains enabled during deep sleep state.

Signed-off-by: Cristian Sovaiala <cristian.sovaiala@freescale.com>
Change-Id: I6d62a4bace1d4fac06f398f151cec2968475afdd
Reviewed-on: http://git.am.freescale.net:8181/6844
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Ruxandra Ioana Radulescu <ruxandra.radulescu@freescale.com>
Reviewed-by: Marian Cristian Rotariu <marian.rotariu@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/7692
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Tested-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c | 68 +++++++++++++++++++++++++++
 1 file changed, 68 insertions(+)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index f549d44..07b096c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -118,6 +118,73 @@ uint8_t dpa_priv_common_bpid;
 
 extern u16 qman_portal_max;
 
+#ifdef CONFIG_PM
+
+static int dpaa_suspend_noirq(struct device *dev)
+{
+	struct net_device	*net_dev;
+	struct dpa_priv_s	*priv;
+	struct mac_device	*mac_dev;
+	int			err = 0;
+
+	net_dev = dev_get_drvdata(dev);
+
+	if (net_dev->flags & IFF_UP) {
+		priv = netdev_priv(net_dev);
+		mac_dev = priv->mac_dev;
+
+		err = fm_port_suspend(mac_dev->port_dev[RX]);
+		if (err)
+			goto port_suspend_failed;
+
+		err = fm_port_suspend(mac_dev->port_dev[TX]);
+		if (err)
+			err = fm_port_resume(mac_dev->port_dev[RX]);
+	}
+
+port_suspend_failed:
+	return err;
+}
+
+static int dpaa_resume_noirq(struct device *dev)
+{
+	struct net_device	*net_dev;
+	struct dpa_priv_s	*priv;
+	struct mac_device	*mac_dev;
+	int			err = 0;
+
+	net_dev = dev_get_drvdata(dev);
+
+	if (net_dev->flags & IFF_UP) {
+		priv = netdev_priv(net_dev);
+		mac_dev = priv->mac_dev;
+
+		err = fm_port_resume(mac_dev->port_dev[TX]);
+		if (err)
+			goto port_resume_failed;
+
+		err = fm_port_resume(mac_dev->port_dev[RX]);
+		if (err)
+			err = fm_port_suspend(mac_dev->port_dev[TX]);
+	}
+
+port_resume_failed:
+	return err;
+}
+
+static const struct dev_pm_ops dpaa_pm_ops = {
+	.suspend_noirq = dpaa_suspend_noirq,
+	.resume_noirq = dpaa_resume_noirq,
+};
+
+#define DPAA_PM_OPS (&dpaa_pm_ops)
+
+#else /* CONFIG_PM */
+
+#define DPAA_PM_OPS NULL
+
+#endif /* CONFIG_PM */
+
 /* Checks whether the checksum field in Parse Results array is valid
  * (equals 0xFFFF) and increments the .cse counter otherwise
  */
@@ -989,6 +1056,7 @@ static struct platform_driver dpa_driver = {
 		.name		= KBUILD_MODNAME,
 		.of_match_table	= dpa_match,
 		.owner		= THIS_MODULE,
+		.pm		= DPAA_PM_OPS,
 	},
 	.probe		= dpaa_eth_priv_probe,
 	.remove		= dpa_remove
-- 
1.9.1

