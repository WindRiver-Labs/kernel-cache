From 603e6655ea004f2bf911cd8ab1c8d8cc3f9f53f6 Mon Sep 17 00:00:00 2001
From: Marian Rotariu <marian.rotariu@freescale.com>
Date: Mon, 7 Apr 2014 17:44:55 +0300
Subject: [PATCH 754/987] dpaa_eth: fix CSUM for macless

Macless is a type of generic DPAA driver that does not know its immediate
underlying HW block on TX. It can be connected with an OH port, a TX port,
directly with another Macless driver in Macless-Macless scenario or with
another HW module.

Because not all HW modules know how to calculate CSUM, Macless triggers
software computation of the CSUM. If another HW block modifies the frame it
needs to trigger the Parser to recalculate CSUM.

This patch adds different default values for the parse results structure
that forbids the Parser from doing CSUM validation or computation. The _DTC and
_RPD flags inside the Frame Descriptor are enabled together. This is the only
way to deactivate HW CSUM in all the flows.

Signed-off-by: Marian Rotariu <marian.rotariu@freescale.com>
Change-Id: I6f2e27825f082c9319ff44241d19b06bda3faf47
Reviewed-on: http://git.am.freescale.net:8181/13671
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 .../net/ethernet/freescale/dpa/dpaa_eth_shared.c   | 33 ++++++++++++++++++----
 1 file changed, 27 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
index f6671f9..7b88592 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
@@ -461,6 +461,7 @@ int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
 	int err;
 	void *dpa_bp_vaddr;
 	fm_prs_result_t parse_results;
+	fm_prs_result_t *parse_results_ref;
 
 	priv = netdev_priv(net_dev);
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
@@ -504,9 +505,20 @@ int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
 					  dpa_fd_length(&fd));
 
 		/* if no mac device or peer set it's macless */
-		if (!priv->mac_dev || priv->peer)
-			fd.cmd |= FM_FD_CMD_DTC;
-		else {
+		if (!priv->mac_dev || priv->peer) {
+			parse_results_ref = (fm_prs_result_t *) (dpa_bp_vaddr +
+				DPA_TX_PRIV_DATA_SIZE);
+			/* Default values; FMan will not generate/validate
+			 * CSUM;
+			 */
+			parse_results_ref->l3r = 0;
+			parse_results_ref->l4r = 0;
+			parse_results_ref->ip_off[0] = 0xff;
+			parse_results_ref->ip_off[1] = 0xff;
+			parse_results_ref->l4_off = 0xff;
+
+			fd.cmd |= FM_FD_CMD_DTC | FM_FD_CMD_RPD;
+		} else {
 			/* Enable L3/L4 hardware checksum computation,
 			* if applicable
 			*/
@@ -523,9 +535,18 @@ int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
 		}
 
 	} else {
-		if (!priv->mac_dev || priv->peer)
-			fd.cmd |= FM_FD_CMD_DTC;
-		else {
+		if (!priv->mac_dev || priv->peer) {
+			/* Default values; FMan will not generate/validate
+			 * CSUM;
+			 */
+			parse_results.l3r = 0;
+			parse_results.l4r = 0;
+			parse_results.ip_off[0] = 0xff;
+			parse_results.ip_off[1] = 0xff;
+			parse_results.l4_off = 0xff;
+
+			fd.cmd |= FM_FD_CMD_DTC | FM_FD_CMD_RPD;
+		} else {
 			/* Enable L3/L4 hardware checksum computation,
 			 * if applicable
 			 */
-- 
1.9.1

