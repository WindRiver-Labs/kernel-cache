From a1a30a5259427cec74e592caef2d19e8aeeafb02 Mon Sep 17 00:00:00 2001
From: Rotariu Marian Cristian-B44860 <marian.rotariu@freescale.com>
Date: Thu, 9 Oct 2014 13:22:27 +0300
Subject: [PATCH 883/987] dpaa_eth: convert fq dts entries to CPU endianess

The data related to fqs from dts are in BE. In order to be used by the CPU, the
data need to be converted into CPU endianess. Because the current fqids
structure is used in many ways and in many files, the code for endianess
conversion is not localized. To make this patch as simple as possible, an
intermediary variable was used.

Change-Id: I1beec33fa3ce816899e3bb02e0cf88ed0b0d0520
Signed-off-by: Rotariu Marian Cristian-B44860 <marian.rotariu@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/20964
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/32495
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   | 27 +++++++++++++++++-----
 1 file changed, 21 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index 48b8405..be4c317 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -76,7 +76,7 @@ static const struct fqid_cell tx_confirm_fqids[] = {
 	{0, DPAA_ETH_TX_QUEUES}
 };
 
-static const struct fqid_cell default_fqids[][3] = {
+static struct fqid_cell default_fqids[][3] = {
 	[RX] = { {0, 1}, {0, 1}, {0, DPAA_ETH_RX_QUEUES} },
 	[TX] = { {0, 1}, {0, 1}, {0, DPAA_ETH_TX_QUEUES} }
 };
@@ -932,8 +932,9 @@ int dpa_fq_probe_mac(struct device *dev, struct list_head *list,
 			    bool alloc_tx_conf_fqs,
 			    enum port_type ptype)
 {
-	const struct fqid_cell *fqids;
-	struct dpa_fq *dpa_fq;
+	struct fqid_cell *fqids = NULL;
+	const void *fqids_off = NULL;
+	struct dpa_fq *dpa_fq = NULL;
 	struct device_node *np = dev->of_node;
 	int num_ranges;
 	int i, lenp;
@@ -944,13 +945,26 @@ int dpa_fq_probe_mac(struct device *dev, struct list_head *list,
 			goto fq_alloc_failed;
 	}
 
-	fqids = of_get_property(np, fsl_qman_frame_queues[ptype], &lenp);
-	if (fqids == NULL) {
+	fqids_off = of_get_property(np, fsl_qman_frame_queues[ptype], &lenp);
+	if (fqids_off == NULL) {
 		/* No dts definition, so use the defaults. */
 		fqids = default_fqids[ptype];
 		num_ranges = 3;
 	} else {
 		num_ranges = lenp / sizeof(*fqids);
+
+		fqids = devm_kzalloc(dev, sizeof(*fqids) * num_ranges,
+				GFP_KERNEL);
+		if (fqids == NULL)
+			goto fqids_alloc_failed;
+
+		/* convert to CPU endianess */
+		for (i = 0; i < num_ranges; i++) {
+			fqids[i].start = be32_to_cpup(fqids_off +
+					i * sizeof(*fqids));
+			fqids[i].count = be32_to_cpup(fqids_off +
+					i * sizeof(*fqids) + sizeof(__be32));
+		}
 	}
 
 	for (i = 0; i < num_ranges; i++) {
@@ -1001,7 +1015,8 @@ int dpa_fq_probe_mac(struct device *dev, struct list_head *list,
 	return 0;
 
 fq_alloc_failed:
-	dev_err(dev, "dpa_fq_alloc() failed\n");
+fqids_alloc_failed:
+	dev_err(dev, "Cannot allocate memory for frame queues\n");
 	return -ENOMEM;
 
 invalid_default_queue:
-- 
1.9.1

