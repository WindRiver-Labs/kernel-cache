From d4895828d58caa55bf86f85780da44e9fce2f5b8 Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@Freescale.com>
Date: Fri, 17 Jan 2014 11:04:52 -0600
Subject: [PATCH 505/987] fsl_qbman: Make local symbols 'static'

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

This fixes the following sparse warning(s)

warning: symbol 'bman_portal_max' was not declared. Should it be static?
warning: symbol 'params_nocb' was not declared. Should it be static?
warning: symbol 'params_cb' was not declared. Should it be static?
warning: symbol 'qman_ceetm_configure_lfqmt' was not declared. Should it be static?
warning: symbol 'qman_ceetm_query_lfqmt' was not declared. Should it be static?
warning: symbol 'qman_ceetm_configure_cq' was not declared. Should it be static?
warning: symbol 'qman_ceetm_configure_dct' was not declared. Should it be static?
warning: symbol 'qman_ceetm_query_dct' was not declared. Should it be static?
warning: symbol 'qman_ceetm_configure_class_scheduler' was not declared.  Should it be static?
warning: symbol 'qman_ceetm_query_class_scheduler' was not declared.  Should it be static?
warning: symbol 'qman_ceetm_configure_mapping_shaper_tcfc' was not declared. Should it be static?
warning: symbol 'qman_ceetm_query_mapping_shaper_tcfc' was not declared.  Should it be static?
warning: symbol 'qman_ceetm_configure_ccgr' was not declared. Should it be static?
warning: symbol 'qman_ceetm_cq_peek_pop_xsfdrread' was not declared.  Should it be static?
warning: symbol 'qman_ceetm_query_statistics' was not declared. Should it be static?
warning: symbol 'qman_ceetm_write_statistics' was not declared. Should it be static?
warning: symbol 'qman_get_ip_revision' was not declared. Should it be static?

Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Change-Id: I167a9f0d7851a05150be000a927daaac4ca03482
Reviewed-on: http://git.am.freescale.net:8181/8100
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Haiying Wang <Haiying.Wang@freescale.com>
Reviewed-by: Emilian Medve <Emilian.Medve@freescale.com>
---
 drivers/staging/fsl_qbman/bman_driver.c      |  2 +-
 drivers/staging/fsl_qbman/bman_test_thresh.c |  4 ++--
 drivers/staging/fsl_qbman/qman_driver.c      |  2 +-
 drivers/staging/fsl_qbman/qman_high.c        | 26 +++++++++++++-------------
 4 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 6c4d093..bdf257d 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -41,7 +41,7 @@ u16 bman_ip_rev;
 EXPORT_SYMBOL(bman_ip_rev);
 u16 bman_pool_max;
 EXPORT_SYMBOL(bman_pool_max);
-u16 bman_portal_max;
+static u16 bman_portal_max;
 
 /* After initialising cpus that own shared portal configs, we cache the
  * resulting portals (ie. not just the configs) in this array. Then we
diff --git a/drivers/staging/fsl_qbman/bman_test_thresh.c b/drivers/staging/fsl_qbman/bman_test_thresh.c
index e4e98ef..6709369 100644
--- a/drivers/staging/fsl_qbman/bman_test_thresh.c
+++ b/drivers/staging/fsl_qbman/bman_test_thresh.c
@@ -68,13 +68,13 @@ static void cb_depletion(struct bman_portal *portal,
 }
 
 /* Params used to set up a pool, this also dynamically allocates a BPID */
-struct bman_pool_params params_nocb = {
+static const struct bman_pool_params params_nocb = {
 	.flags = BMAN_POOL_FLAG_DYNAMIC_BPID | BMAN_POOL_FLAG_THRESH,
 	.thresholds = { TEST_ENTRY, TEST_EXIT, 0, 0 }
 };
 
 /* Params used to set up each cpu's pool with callbacks enabled */
-struct bman_pool_params params_cb = {
+static struct bman_pool_params params_cb = {
 	.bpid = 0, /* will be replaced to match pool_nocb */
 	.flags = BMAN_POOL_FLAG_DEPLETION,
 	.cb = cb_depletion
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index b8c6553..a7031e6 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -288,7 +288,7 @@ static __init int fsl_ceetm_init(struct device_node *node)
 	return 0;
 }
 
-void qman_get_ip_revision(struct device_node *dn)
+static void qman_get_ip_revision(struct device_node *dn)
 {
 	u16 ip_rev = 0;
 	for_each_compatible_node(dn, NULL, "fsl,qman-portal") {
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index a12be0b..6c465c0 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -2725,7 +2725,7 @@ int qm_set_clock(u64 clock_hz)
 EXPORT_SYMBOL(qm_set_clock);
 
 /* CEETM management command */
-int qman_ceetm_configure_lfqmt(struct qm_mcc_ceetm_lfqmt_config *opts)
+static int qman_ceetm_configure_lfqmt(struct qm_mcc_ceetm_lfqmt_config *opts)
 {
 	struct qm_mc_command *mcc;
 	struct qm_mc_result *mcr;
@@ -2754,7 +2754,7 @@ int qman_ceetm_configure_lfqmt(struct qm_mcc_ceetm_lfqmt_config *opts)
 	return 0;
 }
 
-int qman_ceetm_query_lfqmt(int lfqid,
+static int qman_ceetm_query_lfqmt(int lfqid,
 			struct qm_mcr_ceetm_lfqmt_query *lfqmt_query)
 {
 	struct qm_mc_command *mcc;
@@ -2785,7 +2785,7 @@ int qman_ceetm_query_lfqmt(int lfqid,
 	return 0;
 }
 
-int qman_ceetm_configure_cq(struct qm_mcc_ceetm_cq_config *opts)
+static int qman_ceetm_configure_cq(struct qm_mcc_ceetm_cq_config *opts)
 {
 	struct qm_mc_command *mcc;
 	struct qm_mc_result *mcr;
@@ -2848,7 +2848,7 @@ int qman_ceetm_query_cq(unsigned int cqid, unsigned int dcpid,
 }
 EXPORT_SYMBOL(qman_ceetm_query_cq);
 
-int qman_ceetm_configure_dct(struct qm_mcc_ceetm_dct_config *opts)
+static int qman_ceetm_configure_dct(struct qm_mcc_ceetm_dct_config *opts)
 {
 	struct qm_mc_command *mcc;
 	struct qm_mc_result *mcr;
@@ -2877,7 +2877,7 @@ int qman_ceetm_configure_dct(struct qm_mcc_ceetm_dct_config *opts)
 	return 0;
 }
 
-int qman_ceetm_query_dct(struct qm_mcc_ceetm_dct_query *opts,
+static int qman_ceetm_query_dct(struct qm_mcc_ceetm_dct_query *opts,
 			 struct qm_mcr_ceetm_dct_query *dct_query)
 {
 	struct qm_mc_command *mcc;
@@ -2908,7 +2908,7 @@ int qman_ceetm_query_dct(struct qm_mcc_ceetm_dct_query *opts,
 	return 0;
 }
 
-int qman_ceetm_configure_class_scheduler(
+static int qman_ceetm_configure_class_scheduler(
 			struct qm_mcc_ceetm_class_scheduler_config *opts)
 {
 	struct qm_mc_command *mcc;
@@ -2939,7 +2939,7 @@ int qman_ceetm_configure_class_scheduler(
 	return 0;
 }
 
-int qman_ceetm_query_class_scheduler(struct qm_ceetm_channel *channel,
+static int qman_ceetm_query_class_scheduler(struct qm_ceetm_channel *channel,
 			struct qm_mcr_ceetm_class_scheduler_query *query)
 {
 	struct qm_mc_command *mcc;
@@ -2972,7 +2972,7 @@ int qman_ceetm_query_class_scheduler(struct qm_ceetm_channel *channel,
 	return 0;
 }
 
-int qman_ceetm_configure_mapping_shaper_tcfc(
+static int qman_ceetm_configure_mapping_shaper_tcfc(
 		struct qm_mcc_ceetm_mapping_shaper_tcfc_config *opts)
 {
 	struct qm_mc_command *mcc;
@@ -3003,7 +3003,7 @@ int qman_ceetm_configure_mapping_shaper_tcfc(
 	return 0;
 }
 
-int qman_ceetm_query_mapping_shaper_tcfc(
+static int qman_ceetm_query_mapping_shaper_tcfc(
 		struct qm_mcc_ceetm_mapping_shaper_tcfc_query *opts,
 		struct qm_mcr_ceetm_mapping_shaper_tcfc_query *response)
 {
@@ -3037,7 +3037,7 @@ int qman_ceetm_query_mapping_shaper_tcfc(
 	return 0;
 }
 
-int qman_ceetm_configure_ccgr(struct qm_mcc_ceetm_ccgr_config *opts)
+static int qman_ceetm_configure_ccgr(struct qm_mcc_ceetm_ccgr_config *opts)
 {
 	struct qm_mc_command *mcc;
 	struct qm_mc_result *mcr;
@@ -3100,7 +3100,7 @@ int qman_ceetm_query_ccgr(struct qm_mcc_ceetm_ccgr_query *ccgr_query,
 }
 EXPORT_SYMBOL(qman_ceetm_query_ccgr);
 
-int qman_ceetm_cq_peek_pop_xsfdrread(struct qm_ceetm_cq *cq,
+static int qman_ceetm_cq_peek_pop_xsfdrread(struct qm_ceetm_cq *cq,
 			u8 command_type, u16 xsfdr,
 			struct qm_mcr_ceetm_cq_peek_pop_xsfdrread *cq_ppxr)
 {
@@ -3145,7 +3145,7 @@ int qman_ceetm_cq_peek_pop_xsfdrread(struct qm_ceetm_cq *cq,
 	return 0;
 }
 
-int qman_ceetm_query_statistics(u16 cid,
+static int qman_ceetm_query_statistics(u16 cid,
 			enum qm_dc_portal dcp_idx,
 			u16 command_type,
 			struct qm_mcr_ceetm_statistics_query *query_result)
@@ -3182,7 +3182,7 @@ int qman_ceetm_query_statistics(u16 cid,
 	return 0;
 }
 
-int qman_ceetm_write_statistics(u16 cid, enum qm_dc_portal dcp_idx,
+static int qman_ceetm_write_statistics(u16 cid, enum qm_dc_portal dcp_idx,
 			u16 command_type, u64 frame_count, u64 byte_count)
 {
 	struct qm_mc_command *mcc;
-- 
1.9.1

