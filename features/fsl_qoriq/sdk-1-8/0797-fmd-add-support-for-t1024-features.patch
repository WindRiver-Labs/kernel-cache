From 61f4280c199fbaab1336345e2cca45fa53ae8b64 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Wed, 19 Nov 2014 08:42:16 +0200
Subject: [PATCH 797/987] fmd: add support for t1024 features

Change-Id: I37dbffe63e57af8a783b251d0f78087400b09d99
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/23940
Reviewed-by: Eyal Harari <Eyal.Harari@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Nir Erez <nir.erez@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 .../freescale/fman/Peripherals/FM/Port/fm_port.c   |  6 +-
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    | 67 ++++++++++++++++++----
 .../ethernet/freescale/fman/Peripherals/FM/fm.h    |  2 +-
 .../freescale/fman/Peripherals/FM/inc/fm_common.h  |  2 +-
 .../freescale/fman/src/wrapper/lnxwrp_fm_port.c    | 32 ++++++++++-
 .../freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c  | 10 +++-
 6 files changed, 99 insertions(+), 20 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index dc62655..d8e2ead 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -521,7 +521,7 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
     /* Verify the size  */
     if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
         DBG(INFO,
-	    ("FIFO size is %d and should be enlarged to %d bytes",p_FmPort->fifoBufs.num, minFifoSizeRequired));
+           ("FIFO size is %d and should be enlarged to %d bytes",p_FmPort->fifoBufs.num, minFifoSizeRequired));
     else if (p_FmPort->fifoBufs.num < optFifoSizeForB2B)
         DBG(INFO,
 	    ("For back-to-back frames processing, FIFO size is %d and needs to enlarge to %d bytes", p_FmPort->fifoBufs.num, optFifoSizeForB2B));
@@ -2218,7 +2218,9 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 
     /* calculate global portId number */
     p_FmPort->hardwarePortId = SwPortIdToHwPortId(p_FmPort->portType,
-                                    p_FmPortParams->portId);
+                                    p_FmPortParams->portId,
+                                    p_FmPort->fmRevInfo.majorRev,
+                                    p_FmPort->fmRevInfo.minorRev);
 
     if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index aa48455..6574521 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -323,6 +323,7 @@ static void    DmaErrEvent(t_Fm *p_Fm)
     {
         com_id = fman_get_dma_com_id(dma_rg);
         hardwarePortId = (uint8_t)(((com_id & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT));
+        ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
         HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
         tnum = (uint8_t)((com_id & DMA_TRANSFER_TNUM_MASK) >> DMA_TRANSFER_TNUM_SHIFT);
         liodn = (uint16_t)(com_id & DMA_TRANSFER_LIODN_MASK);
@@ -1237,8 +1238,14 @@ t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
     SANITY_CHECK_RETURN_ERROR((macId == 0), E_NOT_SUPPORTED);
     SANITY_CHECK_RETURN_ERROR(IsFmanCtrlCodeLoaded(p_Fm), E_INVALID_STATE);
 
-    rxHardwarePortId = SwPortIdToHwPortId(e_FM_PORT_TYPE_RX_10G, macId);
-    txHardwarePortId = SwPortIdToHwPortId(e_FM_PORT_TYPE_TX_10G, macId);
+    rxHardwarePortId = SwPortIdToHwPortId(e_FM_PORT_TYPE_RX_10G,
+                                    macId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
+    txHardwarePortId = SwPortIdToHwPortId(e_FM_PORT_TYPE_TX_10G,
+                                    macId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     if ((p_Fm->p_FmStateStruct->portsTypes[rxHardwarePortId] != e_FM_PORT_TYPE_DUMMY) ||
         (p_Fm->p_FmStateStruct->portsTypes[txHardwarePortId] != e_FM_PORT_TYPE_DUMMY))
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
@@ -1537,7 +1544,10 @@ t_Error FmVSPAllocForPort (t_Handle        h_Fm,
         RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
     }
 
-    hardwarePortId = SwPortIdToHwPortId(portType, portId);
+    hardwarePortId = SwPortIdToHwPortId(portType,
+                                    portId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
     p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = numOfVSPs;
@@ -1562,7 +1572,10 @@ t_Error FmVSPFreeForPort(t_Handle        h_Fm,
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-    hardwarePortId = SwPortIdToHwPortId(portType, portId);
+    hardwarePortId = SwPortIdToHwPortId(portType,
+                                    portId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
     numOfVSPs = (uint8_t)p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
@@ -2900,7 +2913,10 @@ t_Error FmVSPCheckRelativeProfile(t_Handle        h_Fm,
     ASSERT_COND(h_Fm);
     p_Fm = (t_Fm*)h_Fm;
 
-    hardwarePortId = SwPortIdToHwPortId(portType, portId);
+    hardwarePortId = SwPortIdToHwPortId(portType,
+                                    portId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     ASSERT_COND(hardwarePortId);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
@@ -2933,7 +2949,10 @@ t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
     if (err != E_OK)
         return err;
 
-    hardwarePortId = SwPortIdToHwPortId(portType, portId);
+    hardwarePortId = SwPortIdToHwPortId(portType,
+                                    portId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     ASSERT_COND(hardwarePortId);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
@@ -3174,7 +3193,7 @@ static __inline__ enum fman_exceptions FmanExceptionTrans(e_FmExceptions excepti
         }
 }
 
-uint8_t SwPortIdToHwPortId(e_FmPortType type, uint8_t relativePortId)
+uint8_t SwPortIdToHwPortId(e_FmPortType type, uint8_t relativePortId, uint8_t majorRev, uint8_t minorRev)
 {
 	switch (type)
 	{
@@ -3186,14 +3205,36 @@ uint8_t SwPortIdToHwPortId(e_FmPortType type, uint8_t relativePortId)
 			CHECK_PORT_ID_1G_RX_PORTS(relativePortId);
 			return (uint8_t)(BASE_1G_RX_PORTID + (relativePortId));
 		case (e_FM_PORT_TYPE_RX_10G):
-			CHECK_PORT_ID_10G_RX_PORTS(relativePortId);
-			return (uint8_t)(BASE_10G_RX_PORTID + (relativePortId));
+                       /* The 10G port in T1024 (FMan Version 6.4) is the first port.
+                        * This is the reason why the 1G port offset is used.
+                        */
+                       if (majorRev == 6 && minorRev == 4)
+                       {
+                               CHECK_PORT_ID_1G_RX_PORTS(relativePortId);
+                               return (uint8_t)(BASE_1G_RX_PORTID + (relativePortId));
+                       }
+                       else
+                       {
+                               CHECK_PORT_ID_10G_RX_PORTS(relativePortId);
+                               return (uint8_t)(BASE_10G_RX_PORTID + (relativePortId));
+                       }
 		case (e_FM_PORT_TYPE_TX):
 			CHECK_PORT_ID_1G_TX_PORTS(relativePortId);
 			return (uint8_t)(BASE_1G_TX_PORTID + (relativePortId));
 		case (e_FM_PORT_TYPE_TX_10G):
-			CHECK_PORT_ID_10G_TX_PORTS(relativePortId);
-			return (uint8_t)(BASE_10G_TX_PORTID + (relativePortId));
+                       /* The 10G port in T1024 (FMan Version 6.4) is the first port.
+                        * This is the reason why the 1G port offset is used.
+                        */
+                       if (majorRev == 6 && minorRev == 4)
+                       {
+                               CHECK_PORT_ID_1G_TX_PORTS(relativePortId);
+                               return (uint8_t)(BASE_1G_TX_PORTID + (relativePortId));
+                       }
+                       else
+                       {
+                               CHECK_PORT_ID_10G_TX_PORTS(relativePortId);
+                               return (uint8_t)(BASE_10G_TX_PORTID + (relativePortId));
+                       }
 		default:
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));
 			return 0;
@@ -4485,7 +4526,9 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
         /* find the location of this port within the register */
         hardwarePortId =
             SwPortIdToHwPortId(p_PortsBandwidth->portsBandwidths[i].type,
-                               p_PortsBandwidth->portsBandwidths[i].relativePortId);
+                               p_PortsBandwidth->portsBandwidths[i].relativePortId,
+                               p_Fm->p_FmStateStruct->revInfo.majorRev,
+                               p_Fm->p_FmStateStruct->revInfo.minorRev);
 
         ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
         weights[hardwarePortId] = weight;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
index 817b70e..b7b42b5 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
@@ -332,7 +332,7 @@ switch (exception){                                         \
 #else  /* (DPAA_VERSION < 11) */
 /* Defaults are registers' reset values */
 #define DEFAULT_totalFifoSize(major, minor)	\
-    (((major == 6) && (minor == 1)) ? (142*KILOBYTE) : (295*KILOBYTE))
+    (((major == 6) && ((minor == 1) || (minor == 4))) ? (142*KILOBYTE) : (295*KILOBYTE))
 
 #define DEFAULT_totalNumOfTasks             124
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
index c89cba3..67728f1 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
@@ -512,7 +512,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 10G_TX_PORT port id"))
 #endif
 
-uint8_t SwPortIdToHwPortId(e_FmPortType _type, uint8_t _relativePortId);
+uint8_t SwPortIdToHwPortId(e_FmPortType type, uint8_t relativePortId, uint8_t majorRev, uint8_t minorRev);
 
 #define HW_PORT_ID_TO_SW_PORT_ID(_relativePortId, hardwarePortId)                   \
 {   if (((hardwarePortId) >= BASE_OH_PORTID) &&                                     \
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
index e3d6b2f..c8c28eb 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
@@ -51,6 +51,7 @@
 #include <linux/cdev.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#include <asm/mpc85xx.h>
 
 #include "sprint_ext.h"
 #include "fm_common.h"
@@ -81,6 +82,8 @@ do {\
 	} \
 } while (0)
 
+#define IS_T1023_T1024	(SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1024 || \
+			SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1023)
 
 static volatile int hcFrmRcv/* = 0 */;
 static spinlock_t lock;
@@ -357,6 +360,8 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 		}
 		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop +
 			FM_MAX_NUM_OF_1G_TX_PORTS];
+		if (IS_T1023_T1024)
+			p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop];
 
 		p_LnxWrpFmPortDev->id = *uint32_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
@@ -400,6 +405,9 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop +
 			FM_MAX_NUM_OF_1G_RX_PORTS];
 
+		if (IS_T1023_T1024)
+			p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop];
+
 		p_LnxWrpFmPortDev->id = *uint32_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
 			p_LnxWrpFmPortDev->id;
@@ -687,9 +695,11 @@ static t_Error CheckNSetFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         if (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         {
             portId = fmVspParams.portParams.portId;
-            if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G)
-                portId += FM_MAX_NUM_OF_1G_RX_PORTS;
-            portVSPAllocParams.h_FmTxPort =
+            if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G){
+		if (!(IS_T1023_T1024))
+                    portId += FM_MAX_NUM_OF_1G_RX_PORTS;
+	    }
+	    portVSPAllocParams.h_FmTxPort =
                 p_LnxWrpFmDev->txPorts[portId].h_Dev;
             fmVspParams.liodnOffset =
                 p_LnxWrpFmDev->rxPorts[portId].settings.param.specificParams.rxParams.liodnOffset;
@@ -1262,6 +1272,14 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 		p_LnxWrpFmPortDev->minor =
 			p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_RX_PORTS +
 			DEV_FM_RX_PORTS_MINOR_BASE;
+		if (IS_T1023_T1024) {
+			Sprint(p_LnxWrpFmPortDev->name, "%s-port-rx%d",
+				p_LnxWrpFmDev->name,
+				p_LnxWrpFmPortDev->id);
+			p_LnxWrpFmPortDev->minor =
+				p_LnxWrpFmPortDev->id +
+				DEV_FM_RX_PORTS_MINOR_BASE;
+		}
 	} else if (p_LnxWrpFmPortDev->settings.param.portType ==
 		 e_FM_PORT_TYPE_TX) {
 		Sprint(p_LnxWrpFmPortDev->name, "%s-port-tx%d",
@@ -1276,6 +1294,14 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 		p_LnxWrpFmPortDev->minor =
 			p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_TX_PORTS +
 			DEV_FM_TX_PORTS_MINOR_BASE;
+		if (IS_T1023_T1024) {
+			Sprint(p_LnxWrpFmPortDev->name, "%s-port-tx%d",
+				p_LnxWrpFmDev->name,
+				p_LnxWrpFmPortDev->id);
+			p_LnxWrpFmPortDev->minor =
+				p_LnxWrpFmPortDev->id +
+				DEV_FM_TX_PORTS_MINOR_BASE;
+		}
 	} else if (p_LnxWrpFmPortDev->settings.param.portType ==
 		 e_FM_PORT_TYPE_OH_HOST_COMMAND) {
 		Sprint(p_LnxWrpFmPortDev->name, "%s-port-oh%d",
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
index 8fa4c89..4161a23 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
@@ -60,6 +60,7 @@
 #include <asm/uaccess.h>
 #include <asm/errno.h>
 #include <sysdev/fsl_soc.h>
+#include <asm/mpc85xx.h>
 
 #if defined(CONFIG_COMPAT)
 #include <linux/compat.h>
@@ -71,6 +72,9 @@
 #include "fm_port_ioctls.h"
 #include "fm_vsp_ext.h"
 
+#define IS_T1023_T1024	(SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1024 || \
+			SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1023)
+
 #define __ERR_MODULE__  MODULE_FM
 
 #if defined(CONFIG_COMPAT)
@@ -1431,7 +1435,11 @@ Status: feature not supported
 
                     case (e_IOC_FM_PORT_TYPE_RX_10G):
                         if (port_params->port_id < FM_MAX_NUM_OF_10G_RX_PORTS) {
-                            h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
+                            if (IS_T1023_T1024) {
+                                h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id].h_Dev;
+                            } else {
+                                h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
+                            }
                             break;
                         }
                         goto invalid_port_id;
-- 
1.9.1

