From 4ae0fed309882441bad9e7135831e4ada996360b Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Wed, 3 Sep 2014 18:06:05 +0800
Subject: [PATCH 1212/1226] uio: Allow drivers to override the pgprot for
 mmap()

For some devices, the default behavior of pgprot_noncached() is not
appropriate for all of its mappable regions. This provides a means for
the kernel side of the UIO driver to override the flags without having
to implement its own full mmap callback.

Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Geoff Thorpe <geoff@geoffthorpe.net>
Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 Documentation/DocBook/uio-howto.tmpl | 12 ++++++++++++
 drivers/uio/uio.c                    |  6 +++++-
 include/linux/uio_driver.h           |  3 +++
 3 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/Documentation/DocBook/uio-howto.tmpl b/Documentation/DocBook/uio-howto.tmpl
index cd0e452..2fb55c1 100644
--- a/Documentation/DocBook/uio-howto.tmpl
+++ b/Documentation/DocBook/uio-howto.tmpl
@@ -510,6 +510,18 @@ interrupts from userspace by writing to <filename>/dev/uioX</filename>,
 you can implement this function. The parameter <varname>irq_on</varname>
 will be 0 to disable interrupts and 1 to enable them.
 </para></listitem>
+
+<listitem><para>
+<varname>pgprot_t (*set_pgprot)(struct uio_info *info, unsigned int mem_idx,
+pgprot_t prot)</varname>: Optional. If special flags are required when mapping
+certain hardware regions, then this callback can be used to specify those flags.
+The default flags are given by the host architecture's definition of
+<function>pgprot_noncached()</function> and are passed to the callback as the
+<varname>prot</varname> parameter, but the return value is what is used for the
+resulting mapping. Note that this callback is only used by the built in mapping
+logic (when the <function>mmap()</function> callback has not been set), and then
+only for UIO_MEM_PHYS regions.
+</para></listitem>
 </itemizedlist>
 
 <para>
diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index 65bf067..d405ae4 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -647,7 +647,11 @@ static int uio_mmap_physical(struct vm_area_struct *vma)
 		return -EINVAL;
 
 	vma->vm_ops = &uio_physical_vm_ops;
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (idev->info->set_pgprot)
+		vma->vm_page_prot = idev->info->set_pgprot(idev->info, mi,
+							   vma->vm_page_prot);
+	else
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
 	/*
 	 * We cannot use the vm_iomap_memory() helper here,
diff --git a/include/linux/uio_driver.h b/include/linux/uio_driver.h
index 32c0e83..abe018b 100644
--- a/include/linux/uio_driver.h
+++ b/include/linux/uio_driver.h
@@ -90,6 +90,7 @@ struct uio_device {
  * @open:		open operation for this uio device
  * @release:		release operation for this uio device
  * @irqcontrol:		disable/enable irqs when 0/1 is written to /dev/uioX
+ * @set_pgprot:		allow driver to override default(noncached) pgprot
  */
 struct uio_info {
 	struct uio_device	*uio_dev;
@@ -105,6 +106,8 @@ struct uio_info {
 	int (*open)(struct uio_info *info, struct inode *inode);
 	int (*release)(struct uio_info *info, struct inode *inode);
 	int (*irqcontrol)(struct uio_info *info, s32 irq_on);
+	pgprot_t (*set_pgprot)(struct uio_info *uio, unsigned int mem_idx,
+			       pgprot_t prot);
 };
 
 extern int __must_check
-- 
2.0.2

