From 4d6ca3349532d2b20734bcd6beac42b065de66e5 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Mon, 15 Oct 2012 09:53:21 +0300
Subject: [PATCH 046/987] dpaa_eth: Do not copy skb->data into SG fd

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Directly map the linear part of the egress fragmented skbuff rather than
copying it into the first fragment of the SG fd we're composing to FMan.

Change-Id: I28db929d5dd0b48d53073a5f854b9ad3a0ef49f5
Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
(cherry picked from commit 80fd59dc890d2198fcd9fc57afa8a6d10a84a7f9)
Reviewed-on: http://git.am.freescale.net:8181/1044
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 56 +++++-------------------
 1 file changed, 10 insertions(+), 46 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 011ef52..067318c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -232,14 +232,13 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 	if (fd->format == qm_fd_sg) {
 		/*
-		 * All storage items used are pages, but only the sgt and
-		 * the first page are guaranteed to reside in lowmem.
+		 * The sgt page is guaranteed to reside in lowmem.
 		 */
 		sgt = phys_to_virt(addr + dpa_fd_offset(fd));
 
-		/* page 0 is from lowmem, was dma_map_single()-ed */
+		/* sgt[0] is from lowmem, was dma_map_single()-ed */
 		dma_unmap_single(dpa_bp->dev, sgt[0].addr,
-				 dpa_bp->size, dma_dir);
+				sgt[0].length, dma_dir);
 
 		/* remaining pages were mapped with dma_map_page() */
 		for (i = 1; i < skb_shinfo(skb)->nr_frags; i++) {
@@ -257,8 +256,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 		/* Free separately the pages that we allocated on Tx */
 		free_page((unsigned long)phys_to_virt(addr));
-		free_page((unsigned long)phys_to_virt(sgt[0].addr));
-	}
+}
 
 	return skb;
 }
@@ -604,7 +602,7 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	int err;
 
 	struct qm_sg_entry *sgt;
-	unsigned long sgt_page, sg0_page;
+	unsigned long sgt_page;
 	void *buffer_start;
 	skb_frag_t *frag;
 	int i, j;
@@ -634,45 +632,12 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	}
 
 	sgt = (struct qm_sg_entry *)(sgt_page + DPA_BP_HEAD);
-	/*
-	 * TODO: do we need to memset all entries or just the number of entries
-	 * we really use? Might improve perf...
-	 */
-	memset(sgt, 0, DPA_SGT_MAX_ENTRIES * sizeof(*sgt));
-
-	/*
-	 * Populate the first SGT entry
-	 * get a new page to store the skb linear buffer content
-	 * in the first SGT entry
-	 *
-	 * TODO: See if we can use the original page that contains
-	 * the linear buffer
-	 */
-	sg0_page = __get_free_page(GFP_ATOMIC);
-	if (unlikely(!sg0_page)) {
-		dpaa_eth_err(dpa_bp->dev, "__get_free_page() failed\n");
-		err = -ENOMEM;
-		goto sg0_page_alloc_failed;
-	}
-
 	sgt[0].bpid = dpa_bp->bpid;
 	sgt[0].offset = 0;
 	sgt[0].length = skb_headlen(skb);
-
-	/*
-	 * FIXME need more than one page if the linear part of the skb
-	 * is longer than PAGE_SIZE
-	 */
-	if (unlikely(sgt[0].offset + skb_headlen(skb) > dpa_bp->size)) {
-		pr_warn_once("tx headlen %d larger than available buffs %d\n",
-			skb_headlen(skb), dpa_bp->size);
-		err = -EINVAL;
-		goto skb_linear_too_large;
-	}
-
-	buffer_start = (void *)sg0_page;
-	memcpy(buffer_start + sgt[0].offset, skb->data, skb_headlen(skb));
-	addr = dma_map_single(dpa_bp->dev, buffer_start, dpa_bp->size, dma_dir);
+	sgt[0].extension = 0;
+	sgt[0].final = 0;
+	addr = dma_map_single(dpa_bp->dev, skb->data, sgt[0].length, dma_dir);
 	if (unlikely(dma_mapping_error(dpa_bp->dev, addr))) {
 		dpaa_eth_err(dpa_bp->dev, "DMA mapping failed");
 		err = -EINVAL;
@@ -688,6 +653,8 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 		sgt[i].bpid = dpa_bp->bpid;
 		sgt[i].offset = 0;
 		sgt[i].length = frag->size;
+		sgt[i].extension = 0;
+		sgt[i].final = 0;
 
 		/* This shouldn't happen */
 		BUG_ON(!frag->page.p);
@@ -732,9 +699,6 @@ sg_map_failed:
 		dma_unmap_page(dpa_bp->dev, qm_sg_addr(&sgt[j]),
 			dpa_bp->size, dma_dir);
 sg0_map_failed:
-	free_page(sg0_page);
-skb_linear_too_large:
-sg0_page_alloc_failed:
 csum_failed:
 	free_page(sgt_page);
 
-- 
1.9.1

