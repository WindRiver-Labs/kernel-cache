From 4d46a6b95353e44027f79756f83a88a58718cdaf Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Mon, 28 Jan 2013 17:13:41 +0200
Subject: [PATCH 043/987] dpaa_eth: Make header reallocation unlikely

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

The headroom of an egress skb should be at least equal to
the netdevice's needed_headroom, even in forwarding cases. In fact,
the stack itself reallocs the headroom (ip_finish_output2()) if the
current one is less than LL_RESERVED_SPACE(dev).

Make the guarding condition unlikely. Probably the only scenario we're
talking about is ASF, and even that only in some cases.

Change-Id: Id87cdbd4859db2c0b1d782cd762c5245d91e31ea
Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
(cherry picked from commit 9c587291b0e5b5b7350fc5d2fa4830b485ac18e6)
Reviewed-on: http://git.am.freescale.net:8181/1041
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c    | 2 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h    | 1 +
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 5 +++--
 3 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index fb2fa52..b1d5153 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -1843,7 +1843,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	/* Use the Tx queue of the current cpu */
 	queue_mapping = smp_processor_id();
 
-	if (skb_headroom(skb) < DPA_BP_HEAD) {
+	if (unlikely(skb_headroom(skb) < DPA_BP_HEAD)) {
 		struct sk_buff *skb_new;
 
 		skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 343c38c..30e10c4 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -146,6 +146,7 @@ struct dpaa_eth_hooks_s {
 
 void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 
+/* The netdevice's needed_headroom */
 #define DPA_BP_HEAD (DPA_TX_PRIV_DATA_SIZE + DPA_PARSE_RESULTS_SIZE + \
 			DPA_HASH_RESULTS_SIZE)
 #define DPA_BP_SIZE(s)	(DPA_BP_HEAD + dpa_get_rx_extra_headroom() + (s))
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 97b31fb..0ca0c86 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -802,9 +802,10 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	} else {
 		/*
 		 * Make sure we have enough headroom to accomodate private
-		 * data, parse results, etc
+		 * data, parse results, etc. Normally this shouldn't happen if
+		 * we're here via the standard kernel stack.
 		 */
-		if (skb_headroom(skb) < DPA_BP_HEAD) {
+		if (unlikely(skb_headroom(skb) < DPA_BP_HEAD)) {
 			struct sk_buff *skb_new;
 
 			skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
-- 
1.9.1

