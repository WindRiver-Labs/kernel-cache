From 447c7e80bd3c1af662a07f396f8ca8d7b21a60e5 Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Thu, 24 Oct 2013 15:14:56 -0400
Subject: [PATCH 417/987] fsl_qbman: remove the portal migration functions

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Because we only need to change the portal irq affinity and/or sdest
for hotplug, we don't really migrate the portal. Also because the irq
and sdest are updated via qm_portal_config object, as such, we move
the code from *_high.c to *_driver.c.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: I937e6b6195e6e701d03a8cf738e6fa8e6afa260c
Reviewed-on: http://git.am.freescale.net:8181/6040
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/bman_driver.c  | 16 +++++++---
 drivers/staging/fsl_qbman/bman_high.c    | 25 ++--------------
 drivers/staging/fsl_qbman/bman_private.h |  8 ++---
 drivers/staging/fsl_qbman/qman_driver.c  | 43 ++++++++++++++++++++++++---
 drivers/staging/fsl_qbman/qman_high.c    | 50 ++------------------------------
 drivers/staging/fsl_qbman/qman_private.h |  8 ++---
 6 files changed, 61 insertions(+), 89 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 513c7f1..d71301c 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -296,18 +296,26 @@ __setup("bportals=", parse_bportals);
 static void bman_offline_cpu(unsigned int cpu)
 {
 	struct bman_portal *p;
+	const struct bm_portal_config *pcfg;
 	p = (struct bman_portal *)affine_bportals[cpu];
-	if (p && (!bman_portal_is_sharing_redirect(p)))
-		bman_migrate_portal(p);
+	if (p) {
+		pcfg = bman_get_bm_portal_config(p);
+		if (pcfg)
+			irq_set_affinity(pcfg->public_cfg.irq, cpumask_of(0));
+	}
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
 static void bman_online_cpu(unsigned int cpu)
 {
 	struct bman_portal *p;
+	const struct bm_portal_config *pcfg;
 	p = (struct bman_portal *)affine_bportals[cpu];
-	if (p && (!bman_portal_is_sharing_redirect(p)))
-		bman_migrate_portal_back(p, cpu);
+	if (p) {
+		pcfg = bman_get_bm_portal_config(p);
+		if (pcfg)
+			irq_set_affinity(pcfg->public_cfg.irq, cpumask_of(cpu));
+	}
 }
 
 static int __cpuinit bman_hotplug_cpu_callback(struct notifier_block *nfb,
diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index d070d34..da46a5a 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -1048,27 +1048,8 @@ int bman_shutdown_pool(u32 bpid)
 }
 EXPORT_SYMBOL(bman_shutdown_pool);
 
-int bman_portal_is_sharing_redirect(struct bman_portal *portal)
+const struct bm_portal_config *bman_get_bm_portal_config(
+						struct bman_portal *portal)
 {
-	return portal->sharing_redirect ? 1 : 0;
+	return portal->sharing_redirect ? NULL : portal->config;
 }
-
-/* Migrate the portal to the boot cpu(cpu0) for offline cpu */
-void bman_migrate_portal(struct bman_portal *portal)
-{
-	unsigned long irqflags __maybe_unused;
-	PORTAL_IRQ_LOCK(portal, irqflags);
-	irq_set_affinity(portal->config->public_cfg.irq, cpumask_of(0));
-	PORTAL_IRQ_UNLOCK(portal, irqflags);
-}
-
-#ifdef CONFIG_HOTPLUG_CPU
-/* Migrate the portal back to the affined cpu once that cpu reappears.*/
-void bman_migrate_portal_back(struct bman_portal *portal, unsigned int cpu)
-{
-	unsigned long irqflags __maybe_unused;
-	PORTAL_IRQ_LOCK(portal, irqflags);
-	irq_set_affinity(portal->config->public_cfg.irq, cpumask_of(cpu));
-	PORTAL_IRQ_UNLOCK(portal, irqflags);
-}
-#endif /* CONFIG_HOTPLUG_CPU */
diff --git a/drivers/staging/fsl_qbman/bman_private.h b/drivers/staging/fsl_qbman/bman_private.h
index 22e4a8c..e24588b 100644
--- a/drivers/staging/fsl_qbman/bman_private.h
+++ b/drivers/staging/fsl_qbman/bman_private.h
@@ -156,10 +156,6 @@ u32 bm_pool_free_buffers(u32 bpid);
 __init int bman_init(void);
 __init int bman_resource_init(void);
 
-/* Portal migration */
-int bman_portal_is_sharing_redirect(struct bman_portal *portal);
-void bman_migrate_portal(struct bman_portal *portal);
-#ifdef CONFIG_HOTPLUG_CPU
-void bman_migrate_portal_back(struct bman_portal *portal, unsigned int cpu);
-#endif /* CONFIG_HOTPLUG_CPU */
+const struct bm_portal_config *bman_get_bm_portal_config(
+						struct bman_portal *portal);
 #endif /* CONFIG_FSL_BMAN_CONFIG */
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 78ecd98..5df2074 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -639,21 +639,56 @@ static int __init parse_qportals(char *str)
 }
 __setup("qportals=", parse_qportals);
 
+static void qman_portal_update_sdest(const struct qm_portal_config *pcfg,
+							unsigned int cpu)
+{
+	struct iommu_stash_attribute stash_attr;
+	int ret;
+
+	if (pcfg->iommu_domain) {
+		stash_attr.cpu = cpu;
+		stash_attr.cache = IOMMU_ATTR_CACHE_L1;
+		stash_attr.window = ~(u32)0;
+		ret = iommu_domain_set_attr(pcfg->iommu_domain,
+				DOMAIN_ATTR_PAMU_STASH, &stash_attr);
+		if (ret < 0) {
+			pr_err("Failed to update pamu stash setting\n");
+			return;
+		}
+	}
+#ifdef CONFIG_FSL_QMAN_CONFIG
+	if (qman_set_sdest(pcfg->public_cfg.channel, cpu))
+#endif
+		pr_warning("Failed to update portal's stash request queue\n");
+}
+
 static void qman_offline_cpu(unsigned int cpu)
 {
 	struct qman_portal *p;
+	const struct qm_portal_config *pcfg;
 	p = (struct qman_portal *)affine_portals[cpu];
-	if (p && (!qman_portal_is_sharing_redirect(p)))
-		qman_migrate_portal(p);
+	if (p) {
+		pcfg = qman_get_qm_portal_config(p);
+		if (pcfg) {
+			irq_set_affinity(pcfg->public_cfg.irq, cpumask_of(0));
+			qman_portal_update_sdest(pcfg, 0);
+		}
+	}
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
 static void qman_online_cpu(unsigned int cpu)
 {
 	struct qman_portal *p;
+	const struct qm_portal_config *pcfg;
 	p = (struct qman_portal *)affine_portals[cpu];
-	if (p && (!qman_portal_is_sharing_redirect(p)))
-		qman_migrate_portal_back(p, cpu);
+	if (p) {
+		pcfg = qman_get_qm_portal_config(p);
+		if (pcfg) {
+			irq_set_affinity(pcfg->public_cfg.irq, cpumask_of(cpu));
+			qman_portal_update_sdest(pcfg, cpu);
+		}
+	}
 }
 
 static int __cpuinit qman_hotplug_cpu_callback(struct notifier_block *nfb,
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 9d449f6..bc46b98 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -4935,52 +4935,8 @@ int qman_shutdown_fq(u32 fqid)
 	return ret;
 }
 
-static void qman_portal_update_sdest(const struct qm_portal_config *pcfg,
-							unsigned int cpu)
+const struct qm_portal_config *qman_get_qm_portal_config(
+						struct qman_portal *portal)
 {
-	struct iommu_stash_attribute stash_attr;
-	int ret;
-
-	if (pcfg->iommu_domain) {
-		stash_attr.cpu = cpu;
-		stash_attr.cache = IOMMU_ATTR_CACHE_L1;
-		stash_attr.window = ~(u32)0;
-		ret = iommu_domain_set_attr(pcfg->iommu_domain,
-				DOMAIN_ATTR_PAMU_STASH,	&stash_attr);
-		if (ret < 0) {
-			pr_err("Failed to update pamu stash setting\n");
-			return;
-		}
-	}
-#ifdef CONFIG_FSL_QMAN_CONFIG
-	if (qman_set_sdest(pcfg->public_cfg.channel, cpu))
-#endif
-		pr_warning("Failed to update portal's stash request queue\n");
-}
-
-int qman_portal_is_sharing_redirect(struct qman_portal *portal)
-{
-	return portal->sharing_redirect ? 1 : 0;
-}
-
-/* Migrate the portal to the boot cpu(cpu0) for offline cpu */
-void qman_migrate_portal(struct qman_portal *portal)
-{
-	unsigned long irqflags __maybe_unused;
-	PORTAL_IRQ_LOCK(portal, irqflags);
-	irq_set_affinity(portal->config->public_cfg.irq, cpumask_of(0));
-	qman_portal_update_sdest(portal->config, 0);
-	PORTAL_IRQ_UNLOCK(portal, irqflags);
-}
-
-#ifdef CONFIG_HOTPLUG_CPU
-/* Migrate the portal back to the affined cpu once that cpu appears.*/
-void qman_migrate_portal_back(struct qman_portal *portal, unsigned int cpu)
-{
-	unsigned long irqflags __maybe_unused;
-	PORTAL_IRQ_LOCK(portal, irqflags);
-	qman_portal_update_sdest(portal->config, cpu);
-	irq_set_affinity(portal->config->public_cfg.irq, cpumask_of(cpu));
-	PORTAL_IRQ_UNLOCK(portal, irqflags);
+	return portal->sharing_redirect ? NULL : portal->config;
 }
-#endif /* CONFIG_HOTPLUG_CPU */
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index 17314a8..465c791 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -391,10 +391,6 @@ int qman_ceetm_query_ccgr(struct qm_mcc_ceetm_ccgr_query *ccgr_query,
 				struct qm_mcr_ceetm_ccgr_query *response);
 int qman_ceetm_get_xsfdr(enum qm_dc_portal portal, unsigned int *num);
 
-/* Portal migration */
 extern void *affine_portals[NR_CPUS];
-int qman_portal_is_sharing_redirect(struct qman_portal *portal);
-void qman_migrate_portal(struct qman_portal *portal);
-#ifdef CONFIG_HOTPLUG_CPU
-void qman_migrate_portal_back(struct qman_portal *portal, unsigned int cpu);
-#endif /* CONFIG_HOTPLUG_CPU */
+const struct qm_portal_config *qman_get_qm_portal_config(
+						struct qman_portal *portal);
-- 
1.9.1

