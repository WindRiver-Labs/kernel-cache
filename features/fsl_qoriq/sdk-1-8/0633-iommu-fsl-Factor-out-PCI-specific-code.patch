From 5ea6dd4447c177f85520cb26f1809f47a74931fb Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Fri, 19 Sep 2014 10:13:37 +0800
Subject: [PATCH 633/987] iommu/fsl: Factor out PCI specific code.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Factor out PCI specific code in the PAMU driver.

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Change-Id: Ia6d73dca46b7274e14f7d7099aaef22d6510d1aa
Reviewed-on: http://git.am.freescale.net:8181/10256
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
[Fix context to apply to WRL.]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/iommu/fsl_pamu_domain.c | 88 ++++++++++++++++-------------------------
 1 file changed, 34 insertions(+), 54 deletions(-)

diff --git a/drivers/iommu/fsl_pamu_domain.c b/drivers/iommu/fsl_pamu_domain.c
index 4895bbc..44f256b 100644
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@ -702,23 +702,15 @@ static int handle_attach_device(struct fsl_dma_domain *dma_domain,
 	return ret;
 }
 
-static int fsl_pamu_attach_device(struct iommu_domain *domain,
-				  struct device *dev)
+static struct device *get_dma_device(struct device *dev)
 {
-	struct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);
-	const u32 *liodn;
 	struct device *dma_dev = dev;
-	u32 liodn_cnt;
-	int len, ret = 0;
 #ifdef CONFIG_PCI
-	struct pci_dev *pdev = NULL;
-	struct pci_controller *pci_ctl;
 
-	/*
-	 * Use LIODN of the PCI controller while attaching a
-	 * PCI device.
-	 */
-	if (dev_is_pci(dev)) {
+	if (dev->bus == &pci_bus_type) {
+		struct pci_controller *pci_ctl;
+		struct pci_dev *pdev;
+
 		pdev = to_pci_dev(dev);
 		pci_ctl = pci_bus_to_host(pdev->bus);
 		/*
@@ -729,6 +721,19 @@ static int fsl_pamu_attach_device(struct iommu_domain *domain,
 		dma_dev = pci_ctl->parent;
 	}
 #endif
+	return dma_dev;
+}
+
+static int fsl_pamu_attach_device(struct iommu_domain *domain,
+				  struct device *dev)
+{
+	struct fsl_dma_domain *dma_domain = domain->priv;
+	struct device *dma_dev;
+	const u32 *liodn;
+	u32 liodn_cnt;
+	int len, ret = 0;
+
+	dma_dev = get_dma_device(dev);
 
 	liodn = of_get_property(dma_dev->of_node, "fsl,liodn", &len);
 	if (liodn) {
@@ -736,7 +741,7 @@ static int fsl_pamu_attach_device(struct iommu_domain *domain,
 		ret = handle_attach_device(dma_domain, dev, liodn, liodn_cnt);
 	} else {
 		pr_debug("missing fsl,liodn property at %s\n",
-		          dma_dev->of_node->full_name);
+			dma_dev->of_node->full_name);
 		ret = -EINVAL;
 	}
 
@@ -747,35 +752,18 @@ static void fsl_pamu_detach_device(struct iommu_domain *domain,
 				   struct device *dev)
 {
 	struct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);
-	struct device *dma_dev = dev;
+	struct device *dma_dev;
 	const u32 *prop;
 	int len;
-#ifdef CONFIG_PCI
-	struct pci_dev *pdev = NULL;
-	struct pci_controller *pci_ctl;
 
-	/*
-	 * Use LIODN of the PCI controller while detaching a
-	 * PCI device.
-	 */
-	if (dev_is_pci(dev)) {
-		pdev = to_pci_dev(dev);
-		pci_ctl = pci_bus_to_host(pdev->bus);
-		/*
-		 * make dev point to pci controller device
-		 * so we can get the LIODN programmed by
-		 * u-boot.
-		 */
-		dma_dev = pci_ctl->parent;
-	}
-#endif
+	dma_dev = get_dma_device(dev);
 
 	prop = of_get_property(dma_dev->of_node, "fsl,liodn", &len);
 	if (prop)
 		detach_device(dev, dma_domain);
 	else
 		pr_debug("missing fsl,liodn property at %s\n",
-		          dma_dev->of_node->full_name);
+			dma_dev->of_node->full_name);
 }
 
 static  int configure_domain_geometry(struct iommu_domain *domain, void *data)
@@ -1032,12 +1020,6 @@ static struct iommu_group *get_device_iommu_group(struct device *dev)
 }
 
 #ifdef CONFIG_PCI
-static void swap_pci_ref(struct pci_dev **from, struct pci_dev *to)
-{
-	pci_dev_put(*from);
-	*from = to;
-}
-
 static  bool check_pci_ctl_endpt_part(struct pci_controller *pci_ctl)
 {
 	u32 version;
@@ -1075,12 +1057,18 @@ static struct iommu_group *get_shared_pci_device_group(struct pci_dev *pdev)
 	return NULL;
 }
 
-static struct iommu_group *get_pci_device_group(struct pci_dev *pdev)
+static struct iommu_group *get_pci_device_group(struct device *dev)
 {
 	struct pci_controller *pci_ctl;
 	bool pci_endpt_partioning;
 	struct iommu_group *group = NULL;
+	struct pci_dev *bridge, *pdev;
+	struct pci_dev *dma_pdev = NULL;
 
+	pdev = to_pci_dev(dev);
+	/* Don't create device groups for virtual PCI bridges */
+	if (pdev->subordinate)
+		return NULL;
 	pci_ctl = pci_bus_to_host(pdev->bus);
 	pci_endpt_partioning = check_pci_ctl_endpt_part(pci_ctl);
 	/* We can partition PCIe devices so assign device group to the device */
@@ -1124,28 +1112,20 @@ static int fsl_pamu_add_device(struct device *dev)
 	struct iommu_group *group = ERR_PTR(-ENODEV);
 	const u32 *prop;
 	int ret = 0, len;
-#ifdef CONFIG_PCI
-	struct pci_dev *pdev;
 
 	/*
 	 * For platform devices we allocate a separate group for
 	 * each of the devices.
 	 */
-	if (dev_is_pci(dev)) {
-		pdev = to_pci_dev(dev);
-		/* Don't create device groups for virtual PCI bridges */
-		if (pdev->subordinate)
-			return 0;
-
-		group = get_pci_device_group(pdev);
-
-	} else {
-#endif
+	if (dev->bus == &platform_bus_type) {
 		prop = of_get_property(dev->of_node, "fsl,liodn", &len);
 		if (prop)
 			group = get_device_iommu_group(dev);
 	}
-
+#ifdef CONFIG_PCI
+	else
+		group = get_pci_device_group(dev);
+#endif
 	if (IS_ERR(group))
 		return PTR_ERR(group);
 
-- 
1.9.1

