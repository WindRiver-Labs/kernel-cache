From 4ffb11556fc3a80c37c8f2f8f70c773a58ed7fcd Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Mon, 15 Sep 2014 17:31:24 +0800
Subject: [PATCH 1157/1207] powerpc/rcpm: add RCPM driver

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

There is a RCPM (Run Control/Power Management) in Freescale QorIQ
series processors. The device performs tasks associated with device
run control and power management.

The driver implements some features: mask/unmask irq, enter/exit low
power states, freeze time base, etc.

There are two versions of register map in RCPM, which is specified by
the compatible entry in the RCPM node of device tree.

Change-Id: I113211311c7241df95f067103d0ed81ada26d2ed
Signed-off-by: Chenhui Zhao <chenhui.zhao@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/10706
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Yang Li <LeoLi@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 arch/powerpc/include/asm/fsl_guts.h |   2 +-
 arch/powerpc/include/asm/fsl_pm.h   |  37 ++++
 arch/powerpc/platforms/85xx/Kconfig |   2 +-
 arch/powerpc/platforms/85xx/smp.c   |  74 +++-----
 arch/powerpc/sysdev/fsl_rcpm.c      | 335 +++++++++++++++++++++++++++---------
 5 files changed, 319 insertions(+), 131 deletions(-)
 create mode 100644 arch/powerpc/include/asm/fsl_pm.h

diff --git a/arch/powerpc/include/asm/fsl_guts.h b/arch/powerpc/include/asm/fsl_guts.h
index 38d0b57..77b5bd8 100644
--- a/arch/powerpc/include/asm/fsl_guts.h
+++ b/arch/powerpc/include/asm/fsl_guts.h
@@ -109,7 +109,7 @@ struct ccsr_guts {
 /* Alternate function signal multiplex control */
 #define MPC85xx_PMUXCR_QE(x) (0x8000 >> (x))
 
-struct ccsr_rcpm {
+struct ccsr_rcpm_v1 {
 	u8	res0000[4];
 	__be32	cdozsr;		/* 0x0004 - Core Doze Status Register */
 	u8	res0008[4];
diff --git a/arch/powerpc/include/asm/fsl_pm.h b/arch/powerpc/include/asm/fsl_pm.h
new file mode 100644
index 0000000..03f35a4
--- /dev/null
+++ b/arch/powerpc/include/asm/fsl_pm.h
@@ -0,0 +1,37 @@
+/*
+ * Support Power Management
+ *
+ * Copyright 2014 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef __PPC_FSL_PM_H
+#define __PPC_FSL_PM_H
+#ifdef	__KERNEL__
+
+#define E500_PM_PH10	1
+#define E500_PM_PH15	2
+#define E500_PM_PH20	3
+#define E500_PM_PH30	4
+#define E500_PM_DOZE	E500_PM_PH10
+#define E500_PM_NAP	E500_PM_PH15
+
+#define PLAT_PM_SLEEP	20
+#define PLAT_PM_LPM20	30
+
+struct fsl_pm_ops {
+	void (*irq_mask)(int cpu);
+	void (*irq_unmask)(int cpu);
+	void (*cpu_enter_state)(int cpu, int state);
+	void (*cpu_exit_state)(int cpu, int state);
+	int (*plat_enter_state)(int state);
+	void (*freeze_time_base)(int freeze);
+	void (*set_ip_power)(int enable, u32 mask);
+};
+
+extern const struct fsl_pm_ops *qoriq_pm_ops;
+#endif	/* __KERNEL__ */
+#endif  /* __PPC_FSL_PM_H */
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 839a812..58ce025 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -8,7 +8,7 @@ menuconfig FSL_SOC_BOOKE
 	select FSL_PCI if PCI
 	select SERIAL_8250_EXTENDED if SERIAL_8250
 	select SERIAL_8250_SHARE_IRQ if SERIAL_8250
-	select FSL_CORENET_RCPM if SUSPEND && PPC_E500MC
+	select FSL_CORENET_RCPM if PPC_E500MC
 	default y
 
 if FSL_SOC_BOOKE
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index 08e5552..ef42c75 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -29,6 +29,7 @@
 #include <asm/fsl_guts.h>
 #include <asm/code-patching.h>
 #include <asm/cputhreads.h>
+#include <asm/fsl_pm.h>
 
 #include <sysdev/fsl_soc.h>
 #include <sysdev/mpic.h>
@@ -48,10 +49,12 @@ static u64 timebase;
 static int tb_req;
 static int tb_valid;
 static u32 cur_booting_core;
-static bool rcpmv2;
 
 extern void fsl_enable_threads(void);
 
+/* specify the cpu PM state when cpu dies, PH15/NAP is the default */
+int qoriq_cpu_die_state = E500_PM_PH15;
+
 #ifdef CONFIG_PPC_E500MC
 /* get a physical mask of online cores and booting core */
 static inline u32 get_phy_cpu_mask(void)
@@ -74,25 +77,10 @@ static inline u32 get_phy_cpu_mask(void)
 	return mask;
 }
 
-static void __cpuinit mpc85xx_timebase_freeze(int freeze)
+static void mpc85xx_timebase_freeze(int freeze)
 {
-	u32 *addr;
-	u32 mask = get_phy_cpu_mask();
-
-	if (rcpmv2)
-		addr = &((struct ccsr_rcpm_v2 *)guts_regs)->pctbenr;
-	else
-		addr = &((struct ccsr_rcpm *)guts_regs)->ctbenr;
-
-	if (freeze)
-		clrbits32(addr, mask);
-	else
-		setbits32(addr, mask);
-
-	/* read back to push the previous write */
-	in_be32(addr);
+	qoriq_pm_ops->freeze_time_base(freeze);
 }
-
 #else
 static void __cpuinit mpc85xx_timebase_freeze(int freeze)
 {
@@ -212,36 +200,27 @@ static void __cpuinit smp_85xx_mach_cpu_die(void)
 {
 	unsigned int cpu = smp_processor_id();
 
-	local_irq_disable();
+	hard_irq_disable();
 	idle_task_exit();
-	mb();
+
+	if (qoriq_pm_ops->irq_mask)
+		qoriq_pm_ops->irq_mask(cpu);
 
 	mtspr(SPRN_TCR, 0);
+	mtspr(SPRN_TSR, mfspr(SPRN_TSR));
+
+	generic_set_cpu_dead(cpu);
 
 	if (cur_cpu_spec && cur_cpu_spec->cpu_flush_caches)
 		cur_cpu_spec->cpu_flush_caches();
 
-	generic_set_cpu_dead(cpu);
+	if (is_core_down(cpu))
+		qoriq_pm_ops->cpu_enter_state(cpu, qoriq_cpu_die_state);
 
 	while (1)
 		;
 }
 
-void platform_cpu_die(unsigned int cpu)
-{
-	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
-	struct ccsr_rcpm __iomem *rcpm;
-
-	if (rcpmv2 && is_core_down(cpu)) {
-		/* enter PH20 status */
-		setbits32(&((struct ccsr_rcpm_v2 *)guts_regs)->pcph20setr,
-				1 << cpu_core_index_of_thread(hw_cpu));
-	} else if (!rcpmv2) {
-		rcpm = guts_regs;
-		/* Core Nap Operation */
-		setbits32(&rcpm->cnapcr, 1 << hw_cpu);
-	}
-}
 #else
 /* for e500v1 and e500v2 */
 static void smp_85xx_mach_cpu_die(void)
@@ -316,10 +295,6 @@ static int smp_85xx_kick_cpu(int nr)
 	int hw_cpu = get_hard_smp_processor_id(nr);
 	int ioremappable;
 	int ret = 0;
-#ifdef CONFIG_PPC_E500MC
-	struct ccsr_rcpm __iomem *rcpm = guts_regs;
-	struct ccsr_rcpm_v2 __iomem *rcpm_v2 = guts_regs;
-#endif
 
 	WARN_ON(nr < 0 || nr >= NR_CPUS);
 	WARN_ON(hw_cpu < 0 || hw_cpu >= NR_CPUS);
@@ -388,15 +363,6 @@ static int smp_85xx_kick_cpu(int nr)
 		out_be32(&spin_table->addr_l, 0);
 		flush_spin_table(spin_table);
 
-#ifdef CONFIG_PPC_E500MC
-		/* Due to an erratum, wake the core before reset. */
-		if (rcpmv2)
-			setbits32(&rcpm_v2->pcph20clrr,
-				1 << cpu_core_index_of_thread(hw_cpu));
-		else
-			clrbits32(&rcpm->cnapcr, 1 << hw_cpu);
-#endif
-
 		/*
 		 * We don't set the BPTR register here since it already points
 		 * to the boot page properly.
@@ -419,6 +385,11 @@ static int smp_85xx_kick_cpu(int nr)
 
 		/*  clear the acknowledge status */
 		__secondary_hold_acknowledge = -1;
+
+#ifdef CONFIG_PPC_E500MC
+		if (qoriq_pm_ops->irq_unmask)
+			qoriq_pm_ops->irq_unmask(nr);
+#endif
 	}
 	flush_spin_table(spin_table);
 	out_be32(&spin_table->pir, hw_cpu);
@@ -617,9 +588,6 @@ void __init mpc85xx_smp_init(void)
 
 	np = of_find_matching_node(NULL, mpc85xx_smp_guts_ids);
 	if (np) {
-		if (of_device_is_compatible(np, "fsl,qoriq-rcpm-2"))
-			rcpmv2 = true;
-
 		guts_regs = of_iomap(np, 0);
 		of_node_put(np);
 		if (!guts_regs) {
@@ -632,6 +600,8 @@ void __init mpc85xx_smp_init(void)
 #ifdef CONFIG_HOTPLUG_CPU
 		ppc_md.cpu_die = smp_85xx_mach_cpu_die;
 #endif
+		if (!strcmp(cur_cpu_spec->cpu_name, "e6500"))
+			qoriq_cpu_die_state = E500_PM_PH20;
 	}
 
 	smp_ops = &smp_85xx_ops;
diff --git a/arch/powerpc/sysdev/fsl_rcpm.c b/arch/powerpc/sysdev/fsl_rcpm.c
index ecf43a2..4f888f1 100644
--- a/arch/powerpc/sysdev/fsl_rcpm.c
+++ b/arch/powerpc/sysdev/fsl_rcpm.c
@@ -1,7 +1,9 @@
 /*
  * RCPM(Run Control/Power Management) support
  *
- * Copyright 2012 Freescale Semiconductor Inc.
+ * Copyright 2012-2014 Freescale Semiconductor Inc.
+ *
+ * Author: Chenhui Zhao <chenhui.zhao@freescale.com>
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -10,141 +12,320 @@
  */
 #include <linux/types.h>
 #include <linux/errno.h>
-#include <linux/suspend.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/of_platform.h>
+#include <linux/of_address.h>
 #include <linux/export.h>
 
 #include <asm/io.h>
-#include <asm/cacheflush.h>
 #include <asm/fsl_guts.h>
+#include <asm/cputhreads.h>
+#include <asm/fsl_pm.h>
+
+#define RCPM_V1		1
+#define RCPM_V2		2
+
+const struct fsl_pm_ops *qoriq_pm_ops;
+
+static struct ccsr_rcpm_v1 __iomem *rcpm_v1_regs;
+static struct ccsr_rcpm_v2 __iomem *rcpm_v2_regs;
+
+static void rcpm_v1_irq_mask(int cpu)
+{
+	int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	setbits32(&rcpm_v1_regs->cpmimr, mask);
+	setbits32(&rcpm_v1_regs->cpmcimr, mask);
+	setbits32(&rcpm_v1_regs->cpmmcmr, mask);
+	setbits32(&rcpm_v1_regs->cpmnmimr, mask);
+}
 
-struct ccsr_rcpm __iomem *rcpm1_regs;
-struct ccsr_rcpm_v2 __iomem *rcpm2_regs;
+static void rcpm_v1_irq_unmask(int cpu)
+{
+	int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	clrbits32(&rcpm_v1_regs->cpmimr, mask);
+	clrbits32(&rcpm_v1_regs->cpmcimr, mask);
+	clrbits32(&rcpm_v1_regs->cpmmcmr, mask);
+	clrbits32(&rcpm_v1_regs->cpmnmimr, mask);
+}
+
+static void rcpm_v1_set_ip_power(int enable, u32 mask)
+{
+	if (enable)
+		setbits32(&rcpm_v1_regs->ippdexpcr, mask);
+	else
+		clrbits32(&rcpm_v1_regs->ippdexpcr, mask);
+}
 
-static int rcpm_suspend_enter(suspend_state_t state)
+static void rcpm_v1_cpu_enter_state(int cpu, int state)
 {
+	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	switch (state) {
+	case E500_PM_PH10:
+		setbits32(&rcpm_v1_regs->cdozcr, mask);
+		break;
+	case E500_PM_PH15:
+		setbits32(&rcpm_v1_regs->cnapcr, mask);
+		break;
+	default:
+		pr_err("%s: Unknown cpu PM state (%d)\n", __func__, state);
+		break;
+	}
+}
+
+static void rcpm_v1_cpu_exit_state(int cpu, int state)
+{
+	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	switch (state) {
+	case E500_PM_PH10:
+		clrbits32(&rcpm_v1_regs->cdozcr, mask);
+		break;
+	case E500_PM_PH15:
+		clrbits32(&rcpm_v1_regs->cnapcr, mask);
+		break;
+	default:
+		pr_err("%s: Unknown cpu PM state (%d)\n", __func__, state);
+		break;
+	}
+}
+
+static int rcpm_v1_plat_enter_state(int state)
+{
+	u32 *pmcsr_reg = &rcpm_v1_regs->powmgtcsr;
 	int ret = 0;
 	int result;
 
 	switch (state) {
-	case PM_SUSPEND_STANDBY:
-
-		flush_dcache_L1();
-		flush_backside_L2_cache();
+	case PLAT_PM_SLEEP:
+		setbits32(pmcsr_reg, RCPM_POWMGTCSR_SLP);
 
-		setbits32(&rcpm1_regs->powmgtcsr, RCPM_POWMGTCSR_SLP);
 		/* At this point, the device is in sleep mode. */
 
-		/* Upon resume, wait for SLP bit to be clear. */
+		/* Upon resume, wait for RCPM_POWMGTCSR_SLP bit to be clear. */
 		result = spin_event_timeout(
-		  (in_be32(&rcpm1_regs->powmgtcsr) & RCPM_POWMGTCSR_SLP) == 0,
-		  10000, 10);
+		  !(in_be32(pmcsr_reg) & RCPM_POWMGTCSR_SLP), 10000, 10);
 		if (!result) {
-			pr_err("%s: timeout waiting for SLP bit "
-				"to be cleared\n", __func__);
+			pr_err("%s: timeout waiting for SLP bit to be cleared\n",
+			       __func__);
 			ret = -ETIMEDOUT;
 		}
 		break;
-
 	default:
+		pr_err("%s: Unknown platform PM state (%d)\n",
+		       __func__, state);
 		ret = -EINVAL;
-
 	}
+
 	return ret;
 }
 
-static int rcpm_v2_suspend_enter(suspend_state_t state)
+static void rcpm_common_freeze_time_base(u32 *tben_reg, int freeze)
+{
+	static u32 mask;
+
+	if (freeze) {
+		mask = in_be32(tben_reg);
+		clrbits32(tben_reg, mask);
+	} else {
+		setbits32(tben_reg, mask);
+	}
+
+	/* read back to push the previous write */
+	in_be32(tben_reg);
+}
+
+static void rcpm_v1_freeze_time_base(int freeze)
+{
+	rcpm_common_freeze_time_base(&rcpm_v1_regs->ctbenr, freeze);
+}
+
+static void rcpm_v2_freeze_time_base(int freeze)
+{
+	rcpm_common_freeze_time_base(&rcpm_v2_regs->pctbenr, freeze);
+}
+
+static void rcpm_v2_irq_mask(int cpu)
+{
+	int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	setbits32(&rcpm_v2_regs->tpmimr0, mask);
+	setbits32(&rcpm_v2_regs->tpmcimr0, mask);
+	setbits32(&rcpm_v2_regs->tpmmcmr0, mask);
+	setbits32(&rcpm_v2_regs->tpmnmimr0, mask);
+}
+
+static void rcpm_v2_irq_unmask(int cpu)
+{
+	int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	clrbits32(&rcpm_v2_regs->tpmimr0, mask);
+	clrbits32(&rcpm_v2_regs->tpmcimr0, mask);
+	clrbits32(&rcpm_v2_regs->tpmmcmr0, mask);
+	clrbits32(&rcpm_v2_regs->tpmnmimr0, mask);
+}
+
+static void rcpm_v2_set_ip_power(int enable, u32 mask)
+{
+	if (enable)
+		/* enable power of IP blocks in deep sleep mode */
+		setbits32(&rcpm_v2_regs->ippdexpcr[0], mask);
+	else
+		clrbits32(&rcpm_v2_regs->ippdexpcr[0], mask);
+}
+
+static void rcpm_v2_cpu_enter_state(int cpu, int state)
+{
+	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
+	u32 mask = 1 << cpu_core_index_of_thread(hw_cpu);
+
+	switch (state) {
+	case E500_PM_PH10:
+		/* one bit corresponds to one thread for PH10 of 6500 */
+		setbits32(&rcpm_v2_regs->tph10setr0, 1 << hw_cpu);
+		break;
+	case E500_PM_PH15:
+		setbits32(&rcpm_v2_regs->pcph15setr, mask);
+		break;
+	case E500_PM_PH20:
+		setbits32(&rcpm_v2_regs->pcph20setr, mask);
+		break;
+	case E500_PM_PH30:
+		setbits32(&rcpm_v2_regs->pcph30setr, mask);
+		break;
+	default:
+		pr_err("%s: Unknown cpu PM state (%d)\n", __func__, state);
+	}
+}
+
+static void rcpm_v2_cpu_exit_state(int cpu, int state)
+{
+	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
+	u32 mask = 1 << cpu_core_index_of_thread(hw_cpu);
+
+	switch (state) {
+	case E500_PM_PH10:
+		setbits32(&rcpm_v2_regs->tph10clrr0, 1 << hw_cpu);
+		break;
+	case E500_PM_PH15:
+		setbits32(&rcpm_v2_regs->pcph15clrr, mask);
+		break;
+	case E500_PM_PH20:
+		setbits32(&rcpm_v2_regs->pcph20clrr, mask);
+		break;
+	case E500_PM_PH30:
+		setbits32(&rcpm_v2_regs->pcph30clrr, mask);
+		break;
+	default:
+		pr_err("%s: Unknown cpu PM state (%d)\n", __func__, state);
+	}
+}
+
+static int rcpm_v2_plat_enter_state(int state)
 {
+	u32 *pmcsr_reg = &rcpm_v2_regs->powmgtcsr;
 	int ret = 0;
 	int result;
 
 	switch (state) {
-	case PM_SUSPEND_STANDBY:
-
+	case PLAT_PM_LPM20:
 		/* clear previous LPM20 status */
-		setbits32(&rcpm2_regs->powmgtcsr, RCPM_POWMGTCSR_P_LPM20_ST);
+		setbits32(pmcsr_reg, RCPM_POWMGTCSR_P_LPM20_ST);
 		/* enter LPM20 status */
-		setbits32(&rcpm2_regs->powmgtcsr, RCPM_POWMGTCSR_LPM20_RQ);
+		setbits32(pmcsr_reg, RCPM_POWMGTCSR_LPM20_RQ);
 
 		/* At this point, the device is in LPM20 status. */
 
 		/* resume ... */
 		result = spin_event_timeout(
-		      (in_be32(&rcpm2_regs->powmgtcsr) & RCPM_POWMGTCSR_LPM20_ST)
-		      == 0, 10000, 10);
+		  !(in_be32(pmcsr_reg) & RCPM_POWMGTCSR_LPM20_ST), 10000, 10);
 		if (!result) {
 			pr_err("%s: timeout waiting for LPM20 bit to be cleared\n",
-				__func__);
+			       __func__);
 			ret = -ETIMEDOUT;
 		}
-
 		break;
-
 	default:
+		pr_err("%s: Unknown platform PM state (%d)\n",
+		       __func__, state);
 		ret = -EINVAL;
-
 	}
 
 	return ret;
-
-}
-
-static int rcpm_suspend_valid(suspend_state_t state)
-{
-	if (state == PM_SUSPEND_STANDBY)
-		return 1;
-	else
-		return 0;
 }
 
-static struct platform_suspend_ops rcpm_suspend_ops = {
-	.valid = rcpm_suspend_valid,
+static const struct fsl_pm_ops qoriq_rcpm_v1_ops = {
+	.irq_mask = rcpm_v1_irq_mask,
+	.irq_unmask = rcpm_v1_irq_unmask,
+	.cpu_enter_state = rcpm_v1_cpu_enter_state,
+	.cpu_exit_state = rcpm_v1_cpu_exit_state,
+	.plat_enter_state = rcpm_v1_plat_enter_state,
+	.set_ip_power = rcpm_v1_set_ip_power,
+	.freeze_time_base = rcpm_v1_freeze_time_base,
 };
 
-static int rcpm_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
+static const struct fsl_pm_ops qoriq_rcpm_v2_ops = {
+	.irq_mask = rcpm_v2_irq_mask,
+	.irq_unmask = rcpm_v2_irq_unmask,
+	.cpu_enter_state = rcpm_v2_cpu_enter_state,
+	.cpu_exit_state = rcpm_v2_cpu_exit_state,
+	.plat_enter_state = rcpm_v2_plat_enter_state,
+	.set_ip_power = rcpm_v2_set_ip_power,
+	.freeze_time_base = rcpm_v2_freeze_time_base,
+};
 
-	if (of_device_is_compatible(np, "fsl,qoriq-rcpm-2.0")) {
-		rcpm2_regs = of_iomap(np, 0);
-		if (!rcpm2_regs)
-			return -ENOMEM;
+static const struct of_device_id rcpm_matches[] = {
+	{
+		.compatible = "fsl,qoriq-rcpm-1.0",
+		.data = (void *)RCPM_V1,
+	},
+	{
+		.compatible = "fsl,qoriq-rcpm-2.0",
+		.data = (void *)RCPM_V2,
+	},
+	{},
+};
 
-		rcpm_suspend_ops.enter = rcpm_v2_suspend_enter;
-	} else {
-		rcpm1_regs= of_iomap(np, 0);
-		if (!rcpm1_regs)
-			return -ENOMEM;
+int fsl_rcpm_init(void)
+{
+	struct device_node *np;
+	const struct of_device_id *match;
+	void __iomem *base;
 
-		rcpm_suspend_ops.enter = rcpm_suspend_enter;
+	np = of_find_matching_node_and_match(NULL, rcpm_matches, &match);
+	if (!np) {
+		pr_err("%s: can't find the rcpm node.\n", __func__);
+		return -EINVAL;
 	}
 
-	suspend_set_ops(&rcpm_suspend_ops);
+	base = of_iomap(np, 0);
+	of_node_put(np);
+	if (!base)
+		return -ENOMEM;
 
-	dev_info(&pdev->dev, "Freescale RCPM driver\n");
-	return 0;
-}
+	switch ((unsigned long)match->data) {
+	case RCPM_V1:
+		rcpm_v1_regs = base;
+		qoriq_pm_ops = &qoriq_rcpm_v1_ops;
+		break;
 
-static const struct of_device_id rcpm_ids[] = {
-	{ .compatible = "fsl,qoriq-rcpm-1.0", },
-	{ .compatible = "fsl,qoriq-rcpm-2.0", },
-	{ },
-};
+	case RCPM_V2:
+		rcpm_v2_regs = base;
+		qoriq_pm_ops = &qoriq_rcpm_v2_ops;
+		break;
 
-static struct platform_driver rcpm_driver = {
-	.driver = {
-		.name = "fsl-rcpm",
-		.owner = THIS_MODULE,
-		.of_match_table = rcpm_ids,
-	},
-	.probe = rcpm_probe,
-};
+	default:
+		break;
+	}
 
-static int __init rcpm_init(void)
-{
-	return platform_driver_register(&rcpm_driver);
+	return 0;
 }
 
-device_initcall(rcpm_init);
+/* need to call this before SMP init */
+early_initcall(fsl_rcpm_init);
-- 
2.0.2

