From 80020bd4aa56e8dd6ccd1ea69c3834d3844a56d7 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Thu, 31 Oct 2013 18:51:23 +0200
Subject: [PATCH 440/987] fmd: fmd22 integration

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

- Fix for PCD: key mask not properly enabled in exact match table
- Fix for PFC mapping function
- Added counters for miss entry in match and hash tables
- Added counter for IPv4 options in IP fragmentation

Change-Id: I1626afc661d412c518172d405860a33d801cd005
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/6251
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>

Conflicts:
	drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
	drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
Change-Id: If356927d0cd4e22e8949a0106c2a403fcf1343a2
Reviewed-on: http://git.am.freescale.net:8181/7665
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Tested-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
---
 .../ethernet/freescale/fman/Peripherals/FM/HC/hc.c |    8 +
 .../freescale/fman/Peripherals/FM/MAC/Makefile     |    2 +-
 .../freescale/fman/Peripherals/FM/MAC/dtsec.c      |    5 +-
 .../freescale/fman/Peripherals/FM/MAC/fman_dtsec.c |   19 +-
 .../freescale/fman/Peripherals/FM/MAC/fman_memac.c |   12 +
 .../fman/Peripherals/FM/MAC/fman_memac_mii_acc.c   |  213 ++
 .../freescale/fman/Peripherals/FM/MAC/fman_tgec.c  |   15 +-
 .../freescale/fman/Peripherals/FM/MAC/memac.c      |   23 +-
 .../freescale/fman/Peripherals/FM/MAC/memac.h      |    4 +-
 .../fman/Peripherals/FM/MAC/memac_mii_acc.c        |  183 +-
 .../freescale/fman/Peripherals/FM/MAC/tgec.c       |   11 +-
 .../freescale/fman/Peripherals/FM/Makefile         |    2 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.c      | 2317 +++++++++----------
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.h      |    1 -
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.c   |   38 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.h   |    2 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_replic.c  |    1 +
 .../freescale/fman/Peripherals/FM/Port/Makefile    |    2 +-
 .../freescale/fman/Peripherals/FM/Port/fm_port.c   | 2356 +++++++-------------
 .../freescale/fman/Peripherals/FM/Port/fm_port.h   |   52 +-
 .../fman/Peripherals/FM/Port/fm_port_im.c          |    2 +-
 .../freescale/fman/Peripherals/FM/Port/fman_port.c | 1570 +++++++++++++
 .../freescale/fman/Peripherals/FM/Rtc/fm_rtc.c     |   20 +-
 .../freescale/fman/Peripherals/FM/SP/fm_sp.c       |   15 +-
 .../freescale/fman/Peripherals/FM/SP/fman_sp.c     |  286 +--
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    | 2235 +++++--------------
 .../ethernet/freescale/fman/Peripherals/FM/fm.h    |  565 ++---
 .../ethernet/freescale/fman/Peripherals/FM/fman.c  | 1365 ++++++++++++
 .../freescale/fman/Peripherals/FM/inc/fm_common.h  |   41 +-
 .../freescale/fman/inc/Peripherals/dpaa_ext.h      |    2 +
 .../freescale/fman/inc/Peripherals/fm_mac_ext.h    |    6 +-
 .../freescale/fman/inc/Peripherals/fm_pcd_ext.h    |   25 +-
 .../freescale/fman/inc/Peripherals/fm_port_ext.h   |   40 +-
 .../net/ethernet/freescale/fman/inc/ddr_std_ext.h  |    3 +-
 .../ethernet/freescale/fman/inc/flib/fman_common.h |   78 +
 .../ethernet/freescale/fman/inc/flib/fsl_enet.h    |  214 +-
 .../ethernet/freescale/fman/inc/flib/fsl_fman.h    |  707 +++++-
 .../freescale/fman/inc/flib/fsl_fman_dtsec.h       |   68 +-
 .../freescale/fman/inc/flib/fsl_fman_memac.h       |   18 +-
 .../fman/inc/flib/fsl_fman_memac_mii_acc.h         |   78 +
 .../freescale/fman/inc/flib/fsl_fman_port.h        |  594 +++++
 .../freescale/fman/inc/flib/fsl_fman_rtc.h         |   20 +
 .../freescale/fman/inc/flib/fsl_fman_tgec.h        |   24 +-
 .../inc/integrations/T4240/dpaa_integration_ext.h  |    6 +-
 .../freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c   |    4 +-
 45 files changed, 8047 insertions(+), 5205 deletions(-)
 create mode 100755 drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac_mii_acc.c
 create mode 100755 drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
 create mode 100755 drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
 create mode 100755 drivers/net/ethernet/freescale/fman/inc/flib/fman_common.h
 create mode 100755 drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac_mii_acc.h
 create mode 100755 drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
index 463a095..a06dd9d 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
@@ -275,6 +275,14 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
         XX_Free(p_FmHc);
         return NULL;
     }
+ 
+    err = FM_PORT_ConfigMaxFrameLength(p_FmHc->h_HcPortDev, sizeof(t_HcFrame));
+    if (err != E_OK)
+    {
+        REPORT_ERROR(MAJOR, err, ("FM HC port init!"));
+        FmHcFree(p_FmHc);
+        return NULL;
+    }
 
     /* final init */
     err = FM_PORT_Init(p_FmHc->h_HcPortDev);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/Makefile
index a018ab2..f89b563 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/Makefile
@@ -17,5 +17,5 @@ fsl-ncsw-MAC-objs	:=  dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o \
 			    fman_tgec.o fman_crc32.o
 
 ifeq ($(CONFIG_FMAN_T4240),y)
-fsl-ncsw-MAC-objs	+=  memac.o memac_mii_acc.o
+fsl-ncsw-MAC-objs	+=  memac.o memac_mii_acc.o fman_memac_mii_acc.o
 endif
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
index e6fdb3f..ccaaaec 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
@@ -409,8 +409,7 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
     }
 
     if (mode & e_COMM_MODE_TX)
-#if defined(FM_GTS_ERRATA_DTSEC_A004) || \
-    defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012)
+#if defined(FM_GTS_ERRATA_DTSEC_A004) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012)
     if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
         DBG(INFO, ("GTS not supported due to DTSEC_A004 errata."));
 #else  /* not defined(FM_GTS_ERRATA_DTSEC_A004) ||... */
@@ -1051,7 +1050,7 @@ static t_Error DtsecSetStatistics(t_Handle h_Dtsec, e_FmMacStatisticsLevel stati
     p_Dtsec->statisticsLevel = statisticsLevel;
 
     err = (t_Error)fman_dtsec_set_stat_level(p_Dtsec->p_MemMap,
-                                        (enum mac_stat_level)statisticsLevel);
+                                        (enum dtsec_stat_level)statisticsLevel);
     if (err != E_OK)
         return err;
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
index 0bedf58..0915546 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
@@ -379,6 +379,20 @@ void fman_dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr)
 	macaddr[5] = (uint8_t)((tmp1 & 0xff000000) >> 24);
 }
 
+void fman_dtsec_set_hash_table(struct dtsec_regs *regs, uint32_t crc, bool mcast, bool ghtx)
+{
+    int32_t bucket;
+    if (ghtx)
+        bucket = (int32_t)((crc >> 23) & 0x1ff);
+    else {
+        bucket = (int32_t)((crc >> 24) & 0xff);
+        /* if !ghtx and mcast the bit must be set in gaddr instead of igaddr. */
+        if (mcast)
+            bucket += 0x100;
+    }
+    fman_dtsec_set_bucket(regs, bucket, TRUE);
+}
+
 void fman_dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable)
 {
 	int reg_idx = (bucket >> 5) & 0xf;
@@ -430,6 +444,8 @@ int fman_dtsec_adjust_link(struct dtsec_regs *regs,
 		enum enet_speed speed, bool full_dx)
 {
 	uint32_t		tmp;
+	
+	UNUSED(iface_mode);
 
 	if ((speed == E_ENET_SPEED_1000) && !full_dx)
 		return -EINVAL;
@@ -500,7 +516,6 @@ bool fman_dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
 	return (bool)((*car1 | *car2) ? TRUE : FALSE);
 }
 
-
 void fman_dtsec_reset_stat(struct dtsec_regs *regs)
 {
 	/* clear HW counters */
@@ -508,7 +523,7 @@ void fman_dtsec_reset_stat(struct dtsec_regs *regs)
 			DTSEC_ECNTRL_CLRCNT, &regs->ecntrl);
 }
 
-int fman_dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level)
+int fman_dtsec_set_stat_level(struct dtsec_regs *regs, enum dtsec_stat_level level)
 {
 	switch (level) {
 	case E_MAC_STAT_NONE:
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
index ad0955d..145fb03 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
@@ -230,6 +230,18 @@ void fman_memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable
     iowrite32be(tmp, &regs->imask);
 }
 
+void fman_memac_reset_filter_table(struct memac_regs *regs)
+{
+	uint32_t i;
+	for (i = 0; i < 64; i++)
+		iowrite32be(i & ~HASH_CTRL_MCAST_EN, &regs->hashtable_ctrl);
+}
+
+void fman_memac_set_hash_table_entry(struct memac_regs *regs, uint32_t crc)
+{
+	iowrite32be(crc | HASH_CTRL_MCAST_EN, &regs->hashtable_ctrl);
+}
+
 void fman_memac_set_hash_table(struct memac_regs *regs, uint32_t val)
 {
     iowrite32be(val, &regs->hashtable_ctrl);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac_mii_acc.c
new file mode 100755
index 0000000..ccda11e
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac_mii_acc.c
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "fsl_fman_memac_mii_acc.h"
+
+static void write_phy_reg_10g(struct memac_mii_access_mem_map *mii_regs,
+	uint8_t phy_addr, uint8_t reg, uint16_t data)
+{
+	uint32_t                tmp_reg;
+
+	tmp_reg = ioread32be(&mii_regs->mdio_cfg);
+	/* Leave only MDIO_CLK_DIV bits set on */
+	tmp_reg &= MDIO_CFG_CLK_DIV_MASK;
+	/* Set maximum MDIO_HOLD value to allow phy to see
+	change of data signal */
+	tmp_reg |= MDIO_CFG_HOLD_MASK;
+	/* Add 10G interface mode */
+	tmp_reg |= MDIO_CFG_ENC45;
+	iowrite32be(tmp_reg, &mii_regs->mdio_cfg);
+
+	/* Wait for command completion */
+	while ((ioread32be(&mii_regs->mdio_cfg)) & MDIO_CFG_BSY)
+		udelay(1);
+
+	/* Specify phy and register to be accessed */
+	iowrite32be(phy_addr, &mii_regs->mdio_ctrl);
+	iowrite32be(reg, &mii_regs->mdio_addr);
+	wmb();
+
+	while ((ioread32be(&mii_regs->mdio_cfg)) & MDIO_CFG_BSY)
+		udelay(1);
+
+	/* Write data */
+	iowrite32be(data, &mii_regs->mdio_data);
+	wmb();
+
+	/* Wait for write transaction end */
+	while ((ioread32be(&mii_regs->mdio_data)) & MDIO_DATA_BSY)
+		udelay(1);
+}
+
+static uint32_t read_phy_reg_10g(struct memac_mii_access_mem_map *mii_regs,
+	uint8_t phy_addr, uint8_t reg, uint16_t *data)
+{
+	uint32_t                tmp_reg;
+
+	tmp_reg = ioread32be(&mii_regs->mdio_cfg);
+	/* Leave only MDIO_CLK_DIV bits set on */
+	tmp_reg &= MDIO_CFG_CLK_DIV_MASK;
+	/* Set maximum MDIO_HOLD value to allow phy to see
+	change of data signal */
+	tmp_reg |= MDIO_CFG_HOLD_MASK;
+	/* Add 10G interface mode */
+	tmp_reg |= MDIO_CFG_ENC45;
+	iowrite32be(tmp_reg, &mii_regs->mdio_cfg);
+
+	/* Wait for command completion */
+	while ((ioread32be(&mii_regs->mdio_cfg)) & MDIO_CFG_BSY)
+		udelay(1);
+
+	/* Specify phy and register to be accessed */
+	iowrite32be(phy_addr, &mii_regs->mdio_ctrl);
+	iowrite32be(reg, &mii_regs->mdio_addr);
+	wmb();
+
+	while ((ioread32be(&mii_regs->mdio_cfg)) & MDIO_CFG_BSY)
+		udelay(1);
+
+	/* Read cycle */
+	tmp_reg = phy_addr;
+	tmp_reg |= MDIO_CTL_READ;
+	iowrite32be(tmp_reg, &mii_regs->mdio_ctrl);
+	wmb();
+
+	/* Wait for data to be available */
+	while ((ioread32be(&mii_regs->mdio_data)) & MDIO_DATA_BSY)
+		udelay(1);
+
+	*data =  (uint16_t)ioread32be(&mii_regs->mdio_data);
+
+	/* Check if there was an error */
+	return ioread32be(&mii_regs->mdio_cfg);
+}
+
+static void write_phy_reg_1g(struct memac_mii_access_mem_map *mii_regs,
+	uint8_t phy_addr, uint8_t reg, uint16_t data)
+{
+	uint32_t                tmp_reg;
+
+	/* Leave only MDIO_CLK_DIV and MDIO_HOLD bits set on */
+	tmp_reg = ioread32be(&mii_regs->mdio_cfg);
+	tmp_reg &= (MDIO_CFG_CLK_DIV_MASK | MDIO_CFG_HOLD_MASK);
+	iowrite32be(tmp_reg, &mii_regs->mdio_cfg);
+
+	/* Wait for command completion */
+	while ((ioread32be(&mii_regs->mdio_cfg)) & MDIO_CFG_BSY)
+		udelay(1);
+
+	/* Write transaction */
+	tmp_reg = (phy_addr << MDIO_CTL_PHY_ADDR_SHIFT);
+	tmp_reg |= reg;
+	iowrite32be(tmp_reg, &mii_regs->mdio_ctrl);
+
+	while ((ioread32be(&mii_regs->mdio_cfg)) & MDIO_CFG_BSY)
+		udelay(1);
+
+	iowrite32be(data, &mii_regs->mdio_data);
+
+	wmb();
+
+	/* Wait for write transaction to end */
+	while ((ioread32be(&mii_regs->mdio_data)) & MDIO_DATA_BSY)
+		udelay(1);
+}
+
+static uint32_t read_phy_reg_1g(struct memac_mii_access_mem_map *mii_regs,
+	uint8_t phy_addr, uint8_t reg, uint16_t *data)
+{
+	uint32_t tmp_reg;
+
+	/* Leave only MDIO_CLK_DIV and MDIO_HOLD bits set on */
+	tmp_reg = ioread32be(&mii_regs->mdio_cfg);
+	tmp_reg &= (MDIO_CFG_CLK_DIV_MASK | MDIO_CFG_HOLD_MASK);
+	iowrite32be(tmp_reg, &mii_regs->mdio_cfg);
+
+	/* Wait for command completion */
+	while ((ioread32be(&mii_regs->mdio_cfg)) & MDIO_CFG_BSY)
+		udelay(1);
+
+	/* Read transaction */
+	tmp_reg = (phy_addr << MDIO_CTL_PHY_ADDR_SHIFT);
+	tmp_reg |= reg;
+	tmp_reg |= MDIO_CTL_READ;
+	iowrite32be(tmp_reg, &mii_regs->mdio_ctrl);
+
+	while ((ioread32be(&mii_regs->mdio_cfg)) & MDIO_CFG_BSY)
+		udelay(1);
+
+	/* Wait for data to be available */
+	while ((ioread32be(&mii_regs->mdio_data)) & MDIO_DATA_BSY)
+		udelay(1);
+
+	*data =  (uint16_t)ioread32be(&mii_regs->mdio_data);
+
+	/* Check error */
+	return ioread32be(&mii_regs->mdio_cfg);
+}
+
+/*****************************************************************************/
+int fman_memac_mii_write_phy_reg(struct memac_mii_access_mem_map *mii_regs,
+	uint8_t phy_addr, uint8_t reg, uint16_t data,
+	enum enet_speed enet_speed)
+{
+	/* Figure out interface type - 10G vs 1G.
+	In 10G interface both phy_addr and devAddr present. */
+	if (enet_speed == E_ENET_SPEED_10000)
+		write_phy_reg_10g(mii_regs, phy_addr, reg, data);
+	else
+		write_phy_reg_1g(mii_regs, phy_addr, reg, data);
+
+	return 0;
+}
+
+/*****************************************************************************/
+int fman_memac_mii_read_phy_reg(struct memac_mii_access_mem_map *mii_regs,
+	uint8_t phy_addr, uint8_t reg, uint16_t *data,
+	enum enet_speed enet_speed)
+{
+	uint32_t ans;
+	/* Figure out interface type - 10G vs 1G.
+	In 10G interface both phy_addr and devAddr present. */
+	if (enet_speed == E_ENET_SPEED_10000)
+		ans = read_phy_reg_10g(mii_regs, phy_addr, reg, data);
+	else
+		ans = read_phy_reg_1g(mii_regs, phy_addr, reg, data);
+
+	if (ans & MDIO_CFG_READ_ERR)
+		return -EINVAL;
+	return 0;
+}
+
+/* ......................................................................... */
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_tgec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_tgec.c
index 9ff36a3..fff9d5d 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_tgec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_tgec.c
@@ -190,6 +190,19 @@ void fman_tgec_set_promiscuous(struct tgec_regs *regs, bool val)
 	iowrite32be(tmp, &regs->command_config);
 }
 
+void fman_tgec_reset_filter_table(struct tgec_regs *regs)
+{
+	uint32_t i;
+	for (i = 0; i < 512; i++)
+		iowrite32be(i & ~TGEC_HASH_MCAST_EN, &regs->hashtable_ctrl);
+}
+
+void fman_tgec_set_hash_table_entry(struct tgec_regs *regs, uint32_t crc)
+{
+    uint32_t hash = (crc >> TGEC_HASH_MCAST_SHIFT) & TGEC_HASH_ADR_MSK;        /* Take 9 MSB bits */
+	iowrite32be(hash | TGEC_HASH_MCAST_EN, &regs->hashtable_ctrl);
+}
+
 void fman_tgec_set_hash_table(struct tgec_regs *regs, uint32_t value)
 {
 	iowrite32be(value, &regs->hashtable_ctrl);
@@ -348,7 +361,7 @@ void fman_tgec_set_erratum_tx_fifo_corruption_10gmac_a007(struct tgec_regs *regs
 	uint32_t tmp;
 
 	/* restore the default tx ipg Length */
-	tmp = (ioread32be(&regs->tx_ipg_len) & ~TX_IPG_LENGTH_MASK) | 12;
+	tmp = (ioread32be(&regs->tx_ipg_len) & ~TGEC_TX_IPG_LENGTH_MASK) | 12;
 
 	iowrite32be(tmp, &regs->tx_ipg_len);
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
index ca8e5da..2ae7eb80 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
@@ -83,6 +83,13 @@ static uint32_t GetMacAddrHashCode(uint64_t ethAddr)
 static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
 {
     uint16_t    tmpReg16;
+    e_EnetMode  enetMode;
+
+     /* In case the higher MACs are used (i.e. the MACs that should support 10G),
+        speed=10000 is provided for SGMII ports. Temporary modify enet mode
+        to 1G one, so MII functions can work correctly. */
+    enetMode = p_Memac->enetMode;
+    p_Memac->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Memac->enetMode), e_ENET_SPEED_1000);
 
     /* SGMII mode + AN enable */
     tmpReg16 = PHY_SGMII_IF_MODE_AN | PHY_SGMII_IF_MODE_SGMII;
@@ -109,6 +116,9 @@ static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
     /* Restart AN */
     tmpReg16 = PHY_SGMII_CR_DEF_VAL | PHY_SGMII_CR_RESET_AN;
     MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x0, tmpReg16);
+
+    /* Restore original enet mode */
+    p_Memac->enetMode = enetMode;
 }
 
 /* ......................................................................... */
@@ -116,6 +126,13 @@ static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
 static void SetupSgmiiInternalPhyBaseX(t_Memac *p_Memac, uint8_t phyAddr)
 {
     uint16_t    tmpReg16;
+    e_EnetMode  enetMode;
+
+     /* In case the higher MACs are used (i.e. the MACs that should support 10G),
+        speed=10000 is provided for SGMII ports. Temporary modify enet mode
+        to 1G one, so MII functions can work correctly. */
+    enetMode = p_Memac->enetMode;
+    p_Memac->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Memac->enetMode), e_ENET_SPEED_1000);
 
     /* 1000BaseX mode */
     tmpReg16 = PHY_SGMII_IF_MODE_1000X;
@@ -142,6 +159,9 @@ static void SetupSgmiiInternalPhyBaseX(t_Memac *p_Memac, uint8_t phyAddr)
     /* Restart AN */
     tmpReg16 = PHY_SGMII_CR_DEF_VAL | PHY_SGMII_CR_RESET_AN;
     MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x0, tmpReg16);
+
+    /* Restore original enet mode */
+    p_Memac->enetMode = enetMode;
 }
 
 /* ......................................................................... */
@@ -415,7 +435,6 @@ static t_Error MemacSetTxPauseFrames(t_Handle h_Memac,
                                      uint16_t threshTime)
 {
     t_Memac     *p_Memac = (t_Memac *)h_Memac;
-    t_Error     err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
@@ -1047,7 +1066,7 @@ t_Handle MEMAC_Config(t_FmMacParams *p_FmMacParam)
     p_Memac->addr           = ENET_ADDR_TO_UINT64(p_FmMacParam->addr);
 
     p_Memac->p_MemMap       = (struct memac_regs *)UINT_TO_PTR(baseAddr);
-    p_Memac->p_MiiMemMap    = (t_MemacMiiAccessMemMap *)UINT_TO_PTR(baseAddr + MEMAC_TO_MII_OFFSET);
+    p_Memac->p_MiiMemMap    = (struct memac_mii_access_mem_map*)UINT_TO_PTR(baseAddr + MEMAC_TO_MII_OFFSET);
 
     p_Memac->enetMode       = p_FmMacParam->enetMode;
     p_Memac->macId          = p_FmMacParam->macId;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h
index d0436ac..05a0b2a 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h
@@ -43,7 +43,7 @@
 #include "error_ext.h"
 #include "list_ext.h"
 
-#include "memac_mii_acc.h"
+#include "fsl_fman_memac_mii_acc.h"
 #include "fm_mac.h"
 #include "fsl_fman_memac.h"
 
@@ -66,7 +66,7 @@ typedef struct
     t_FmMacControllerDriver     fmMacControllerDriver;               /**< Upper Mac control block */
     t_Handle                    h_App;                               /**< Handle to the upper layer application  */
     struct memac_regs           *p_MemMap;                           /**< Pointer to MAC memory mapped registers */
-    t_MemacMiiAccessMemMap      *p_MiiMemMap;                        /**< Pointer to MII memory mapped registers */
+    struct memac_mii_access_mem_map *p_MiiMemMap;                        /**< Pointer to MII memory mapped registers */
     uint64_t                    addr;                                /**< MAC address of device */
     e_EnetMode                  enetMode;                            /**< Ethernet physical interface  */
     t_FmMacExceptionCallback    *f_Exception;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.c
index 6fe7f74..56eaffb 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.c
@@ -38,158 +38,9 @@
 #include "xx_ext.h"
 
 #include "fm_common.h"
+#include "memac_mii_acc.h"
 
 
-static void WritePhyReg10G(t_MemacMiiAccessMemMap   *p_MiiAccess,
-                           uint8_t                  phyAddr,
-                           uint8_t                  reg,
-                           uint16_t                 data)
-{
-    uint32_t                tmpReg;
-
-    tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
-    /* Leave only MDIO_CLK_DIV bits set on */
-    tmpReg &= MDIO_CFG_CLK_DIV_MASK;
-    /* Set maximum MDIO_HOLD value to allow phy to see
-       change of data signal */
-    tmpReg |= MDIO_CFG_HOLD_MASK;
-    /* Add 10G interface mode */
-    tmpReg |= MDIO_CFG_ENC45;
-    WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
-
-    /* Wait for command completion */
-    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
-        XX_UDelay(1);
-
-    /* Specify phy and register to be accessed */
-    WRITE_UINT32(p_MiiAccess->mdio_ctrl, phyAddr);
-    WRITE_UINT32(p_MiiAccess->mdio_addr, reg);
-    CORE_MemoryBarrier();
-
-    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
-        XX_UDelay(1);
-
-    /* Write data */
-    WRITE_UINT32(p_MiiAccess->mdio_data, data);
-    CORE_MemoryBarrier();
-
-    /* Wait for write transaction end */
-    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
-        XX_UDelay(1);
-}
-
-static uint32_t ReadPhyReg10G(t_MemacMiiAccessMemMap *p_MiiAccess,
-                              uint8_t                phyAddr,
-                              uint8_t                reg,
-                              uint16_t               *p_Data)
-{
-    uint32_t                tmpReg;
-
-    tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
-    /* Leave only MDIO_CLK_DIV bits set on */
-    tmpReg &= MDIO_CFG_CLK_DIV_MASK;
-    /* Set maximum MDIO_HOLD value to allow phy to see
-       change of data signal */
-    tmpReg |= MDIO_CFG_HOLD_MASK;
-    /* Add 10G interface mode */
-    tmpReg |= MDIO_CFG_ENC45;
-    WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
-
-    /* Wait for command completion */
-    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
-        XX_UDelay(1);
-
-    /* Specify phy and register to be accessed */
-    WRITE_UINT32(p_MiiAccess->mdio_ctrl, phyAddr);
-    WRITE_UINT32(p_MiiAccess->mdio_addr, reg);
-    CORE_MemoryBarrier();
-
-    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
-        XX_UDelay(1);
-
-    /* Read cycle */
-    tmpReg = phyAddr;
-    tmpReg |= MDIO_CTL_READ;
-    WRITE_UINT32(p_MiiAccess->mdio_ctrl, tmpReg);
-    CORE_MemoryBarrier();
-
-    /* Wait for data to be available */
-    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
-        XX_UDelay(1);
-
-    *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
-
-    /* Check if there was an error */
-    return GET_UINT32(p_MiiAccess->mdio_cfg);
-}
-
-static void WritePhyReg1G(t_MemacMiiAccessMemMap    *p_MiiAccess,
-                          uint8_t                   phyAddr,
-                          uint8_t                   reg,
-                          uint16_t                  data)
-{
-    uint32_t                tmpReg;
-
-    /* Leave only MDIO_CLK_DIV and MDIO_HOLD bits set on */
-    tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
-    tmpReg &= (MDIO_CFG_CLK_DIV_MASK | MDIO_CFG_HOLD_MASK);
-    WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
-
-    /* Wait for command completion */
-    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
-        XX_UDelay(1);
-
-    /* Write transaction */
-    tmpReg = (phyAddr << MDIO_CTL_PHY_ADDR_SHIFT);
-    tmpReg |= reg;
-    WRITE_UINT32(p_MiiAccess->mdio_ctrl, tmpReg);
-
-    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
-        XX_UDelay(1);
-
-    WRITE_UINT32(p_MiiAccess->mdio_data, data);
-    CORE_MemoryBarrier();
-
-    /* Wait for write transaction to end */
-    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
-        XX_UDelay(1);
-}
-
-static uint32_t ReadPhyReg1G(t_MemacMiiAccessMemMap  *p_MiiAccess,
-                             uint8_t                 phyAddr,
-                             uint8_t                 reg,
-                             uint16_t                *p_Data)
-{
-    uint32_t                tmpReg;
-
-    /* Leave only MDIO_CLK_DIV and MDIO_HOLD bits set on */
-    tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
-    tmpReg &= (MDIO_CFG_CLK_DIV_MASK | MDIO_CFG_HOLD_MASK);
-    WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
-
-    /* Wait for command completion */
-    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
-        XX_UDelay(1);
-
-    /* Read transaction */
-    tmpReg = (phyAddr << MDIO_CTL_PHY_ADDR_SHIFT);
-    tmpReg |= reg;
-    tmpReg |= MDIO_CTL_READ;
-    WRITE_UINT32(p_MiiAccess->mdio_ctrl, tmpReg);
-
-    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
-        XX_UDelay(1);
-
-    /* Wait for data to be available */
-    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
-        XX_UDelay(1);
-
-    *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
-
-    /* Check error */
-    return GET_UINT32(p_MiiAccess->mdio_cfg);
-}
-
 /*****************************************************************************/
 t_Error MEMAC_MII_WritePhyReg(t_Handle  h_Memac,
                              uint8_t    phyAddr,
@@ -201,14 +52,11 @@ t_Error MEMAC_MII_WritePhyReg(t_Handle  h_Memac,
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MiiMemMap, E_INVALID_HANDLE);
 
-    /* Figure out interface type - 10G vs 1G.
-       In 10G interface both phyAddr and devAddr present. */
-    if (ENET_SPEED_FROM_MODE(p_Memac->enetMode) == e_ENET_SPEED_10000)
-        WritePhyReg10G(p_Memac->p_MiiMemMap, phyAddr, reg, data);
-    else
-        WritePhyReg1G(p_Memac->p_MiiMemMap, phyAddr, reg, data);
-
-    return E_OK;
+    return (t_Error)fman_memac_mii_write_phy_reg(p_Memac->p_MiiMemMap,
+                                                 phyAddr,
+                                                 reg,
+                                                 data,
+                                                 (enum enet_speed)ENET_SPEED_FROM_MODE(p_Memac->enetMode));
 }
 
 /*****************************************************************************/
@@ -218,22 +66,13 @@ t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,
                             uint16_t  *p_Data)
 {
     t_Memac                 *p_Memac = (t_Memac *)h_Memac;
-    uint32_t                ans;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MiiMemMap, E_INVALID_HANDLE);
 
-    /* Figure out interface type - 10G vs 1G.
-       In 10G interface both phyAddr and devAddr present. */
-    if (ENET_SPEED_FROM_MODE(p_Memac->enetMode) == e_ENET_SPEED_10000)
-        ans = ReadPhyReg10G(p_Memac->p_MiiMemMap, phyAddr, reg, p_Data);
-    else
-        ans = ReadPhyReg1G(p_Memac->p_MiiMemMap, phyAddr, reg, p_Data);
-
-    if (ans & MDIO_CFG_READ_ERR)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE,
-                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfgReg 0x%x",
-                      ((phyAddr & 0xe0) >> 5), (phyAddr & 0x1f), reg, ans));
-
-    return E_OK;
+    return fman_memac_mii_read_phy_reg(p_Memac->p_MiiMemMap,
+                                       phyAddr,
+                                       reg,
+                                       p_Data,
+                                       (enum enet_speed)ENET_SPEED_FROM_MODE(p_Memac->enetMode));
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
index a9531a2..f4bace5 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
@@ -820,14 +820,11 @@ static t_Error TgecInit(t_Handle h_Tgec)
 #endif /* FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005 */
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev <= 6 /*fixed for rev3 */)
+    if (!p_Tgec->p_TgecDriverParam->skip_fman11_workaround &&
+        ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
     {
-        if (!p_Tgec->p_TgecDriverParam->skip_fman11_workaround &&
-            ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
-        {
-            FreeInitResources(p_Tgec);
-            REPORT_ERROR(MINOR, err, ("TgecTxEccWorkaround FAILED"));
-        }
+        FreeInitResources(p_Tgec);
+        REPORT_ERROR(MINOR, err, ("TgecTxEccWorkaround FAILED"));
     }
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile
index e96de26..e02b57e 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile
@@ -12,7 +12,7 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-PFM1.o
 
-fsl-ncsw-PFM1-objs	:=   fm.o fm_muram.o
+fsl-ncsw-PFM1-objs	:=   fm.o fm_muram.o fman.o
 
 obj-y		+= MAC/
 obj-y		+= Pcd/
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
index a8a52b2..c610a4c 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
@@ -2225,9 +2225,26 @@ static t_Error UpdateGblMask(t_FmPcdCcNode *p_CcNode,
         (keySize <= 4) &&
         !p_CcNode->lclMask)
     {
-        memcpy(p_CcNode->p_GlblMask, p_Mask, (sizeof(uint8_t))*keySize);
-        p_CcNode->glblMaskUpdated = TRUE;
-        p_CcNode->glblMaskSize = 4;
+        if (p_CcNode->parseCode &&
+            (p_CcNode->parseCode != CC_PC_FF_TCI1) &&
+            (p_CcNode->parseCode != CC_PC_FF_TCI2) &&
+            (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
+            (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST) &&
+            (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
+            (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
+            (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
+            (p_CcNode->parseCode != CC_PC_FF_IPDSCP) &&
+            (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) )
+        {
+            p_CcNode->glblMaskSize = 0;
+            p_CcNode->lclMask = TRUE;
+        }
+        else
+        {
+            memcpy(p_CcNode->p_GlblMask, p_Mask, (sizeof(uint8_t))*keySize);
+            p_CcNode->glblMaskUpdated = TRUE;
+            p_CcNode->glblMaskSize = 4;
+        }
     }
     else if (p_Mask &&
              (keySize <= 4) &&
@@ -4015,634 +4032,935 @@ static t_Error MatchTableGetKeyStatistics(t_FmPcdCcNode           *p_CcNode,
     return E_OK;
 }
 
-
-/*****************************************************************************/
-/*              Inter-module API routines                                    */
-/*****************************************************************************/
-
-t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
+static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdCcNodeParams *p_CcNodeParam)
 {
-    t_CcNodeInformation *p_CcInformation;
-    t_List              *p_Pos;
-    uint32_t            intFlags;
-
-    intFlags = XX_LockIntrSpinlock(h_Spinlock);
-
-    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
-    {
-        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *) h_FmPcd;
+    t_FmPcdCcNode           *p_FmPcdCcNextNode;
+    t_Error                 err = E_OK;
+    uint32_t                tmp, keySize;
+    bool                    glblMask = FALSE;
+    t_FmPcdCcKeyParams      *p_KeyParams;
+    t_Handle                h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
+#if (DPAA_VERSION >= 11)
+    t_Handle                h_StatsFLRs;
+#endif /* (DPAA_VERSION >= 11) */
+    bool                    fullField = FALSE;
+    ccPrivateInfo_t         icCode = CC_PRIVATE_INFO_NONE;
+    bool                    isKeyTblAlloc, fromIc = FALSE;
+    uint32_t                matchTableSize, adTableSize;
+    t_CcNodeInformation     ccNodeInfo, *p_CcInformation;
+    t_FmPcdStatsObj         *p_StatsObj;
+    t_FmPcdCcStatsParams    statsParams = {0};
+    t_Handle                h_Manip;
 
-        ASSERT_COND(p_CcInformation->h_CcNode);
+    ASSERT_COND(h_FmPcd);
+    ASSERT_COND(p_CcNode);
+    ASSERT_COND(p_CcNodeParam);
 
-        if (p_CcInformation->h_CcNode == h_Info)
-        {
-            XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
-            return p_CcInformation;
-        }
-    }
+    p_CcNode->p_GlblMask = (t_Handle)XX_Malloc(CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+    memset(p_CcNode->p_GlblMask, 0, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
-    XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+    p_CcNode->h_FmPcd           = h_FmPcd;
+    p_CcNode->numOfKeys         = p_CcNodeParam->keysParams.numOfKeys;
+    p_CcNode->maxNumOfKeys      = p_CcNodeParam->keysParams.maxNumOfKeys;
+    p_CcNode->maskSupport       = p_CcNodeParam->keysParams.maskSupport;
+    p_CcNode->statisticsMode    = p_CcNodeParam->keysParams.statisticsMode;
 
-    return NULL;
-}
+    /* For backward compatibility - even if statistics mode is nullified,
+       we'll fix it to frame mode so we can support per-key request for
+       statistics using 'statisticsEn' in next engine parameters */
+    if (!p_CcNode->maxNumOfKeys &&
+        (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE))
+        p_CcNode->statisticsMode = e_FM_PCD_CC_STATS_MODE_FRAME;
 
-void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo, t_Handle h_Spinlock)
-{
-    t_CcNodeInformation *p_CcInformation;
-    uint32_t            intFlags = 0;
+    h_FmMuram = FmPcdGetMuramHandle(h_FmPcd);
+    if (!h_FmMuram)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM MURAM"));
 
-    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(sizeof(t_CcNodeInformation));
+    INIT_LIST(&p_CcNode->ccPrevNodesLst);
+    INIT_LIST(&p_CcNode->ccTreeIdLst);
+    INIT_LIST(&p_CcNode->ccTreesLst);
+    INIT_LIST(&p_CcNode->availableStatsLst);
 
-    if (p_CcInformation)
+    p_CcNode->h_Spinlock = XX_InitSpinlock();
+    if (!p_CcNode->h_Spinlock)
     {
-        memset(p_CcInformation, 0, sizeof(t_CcNodeInformation));
-        memcpy(p_CcInformation, p_CcInfo, sizeof(t_CcNodeInformation));
-        INIT_LIST(&p_CcInformation->node);
+        DeleteNode(p_CcNode);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("CC node spinlock"));
+    }
 
-        if (h_Spinlock)
-            intFlags = XX_LockIntrSpinlock(h_Spinlock);
+    if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR) &&
+        ((p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv4) ||
+        (p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv6)) &&
+        (p_CcNodeParam->extractCcParams.extractByHdr.type == e_FM_PCD_EXTRACT_FULL_FIELD) &&
+        ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6 == NET_HEADER_FIELD_IPv6_HOP_LIMIT) ||
+        (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4 == NET_HEADER_FIELD_IPv4_TTL)))
+    {
+        err = Ipv4TtlOrIpv6HopLimitCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
+        glblMask = FALSE;
+    }
+    else if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
+             ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_KEY) ||
+              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
+              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
+    {
+        if ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
+            (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
+        {
+            DeleteNode(p_CcNode);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
+        }
 
-        LIST_AddToTail(&p_CcInformation->node, p_List);
+        icCode = IcDefineCode(p_CcNodeParam);
+        fromIc = TRUE;
+        if (icCode == CC_PRIVATE_INFO_NONE)
+        {
+            DeleteNode(p_CcNode);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
+        }
 
-        if (h_Spinlock)
-            XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+        if ((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP) ||
+            (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
+        {
+            err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
+            glblMask = TRUE;
+        }
+        else
+        {
+            err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
+            if (p_CcNode->glblMaskSize)
+                glblMask = TRUE;
+        }
     }
     else
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Node Information"));
-}
-
-void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
-{
-    t_CcNodeInformation *p_CcInformation = NULL;
-    uint32_t            intFlags = 0;
-    t_List              *p_Pos;
-
-    if (h_Spinlock)
-        intFlags = XX_LockIntrSpinlock(h_Spinlock);
-
-    if (LIST_IsEmpty(p_List))
     {
-        XX_RestoreAllIntr(intFlags);
-        return;
+        err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
+        if (p_CcNode->glblMaskSize)
+            glblMask = TRUE;
     }
 
-    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    if (err)
     {
-        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
-        ASSERT_COND(p_CcInformation);
-        ASSERT_COND(p_CcInformation->h_CcNode);
-        if (p_CcInformation->h_CcNode == h_Info)
-            break;
+        DeleteNode(p_CcNode);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if (p_CcInformation)
+    switch (p_CcNodeParam->extractCcParams.type)
     {
-        LIST_DelAndInit(&p_CcInformation->node);
-        XX_Free(p_CcInformation);
-    }
+        case (e_FM_PCD_EXTRACT_BY_HDR):
+            switch (p_CcNodeParam->extractCcParams.extractByHdr.type)
+            {
+                case (e_FM_PCD_EXTRACT_FULL_FIELD):
+                    p_CcNode->parseCode =
+                        GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                              p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                              p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
+                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                       p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField,
+                                       &p_CcNode->sizeOfExtraction);
+                    fullField = TRUE;
+                    if ((p_CcNode->parseCode != CC_PC_FF_TCI1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_TCI2) &&
+                        (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPDSCP) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
+                        glblMask)
+                    {
+                        glblMask = FALSE;
+                        p_CcNode->glblMaskSize = 4;
+                        p_CcNode->lclMask = TRUE;
+                    }
+                    break;
 
-    if (h_Spinlock)
-        XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
-}
+                case (e_FM_PCD_EXTRACT_FROM_HDR):
+                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
+                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                    p_CcNode->parseCode =
+                        GetPrParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                       p_CcNode->offset,glblMask,
+                                       &p_CcNode->prsArrayOffset);
+                    break;
 
-void NextStepAd(t_Handle                     h_Ad,
-                t_FmPcdCcStatsParams         *p_FmPcdCcStatsParams,
-                t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
-                t_FmPcd                      *p_FmPcd)
-{
-    switch (p_FmPcdCcNextEngineParams->nextEngine)
-    {
-        case (e_FM_PCD_KG):
-        case (e_FM_PCD_PLCR):
-        case (e_FM_PCD_DONE):
-            /* if NIA is not CC, create a "result" type AD */
-            FillAdOfTypeResult(h_Ad,
-                               p_FmPcdCcStatsParams,
-                               p_FmPcd,
-                               p_FmPcdCcNextEngineParams);
-            break;
-#if (DPAA_VERSION >= 11)
-        case (e_FM_PCD_FR):
-            if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
-            {
-                FillAdOfTypeContLookup(h_Ad,
-                                       p_FmPcdCcStatsParams,
-                                       p_FmPcd,
-                                       p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-                                       p_FmPcdCcNextEngineParams->h_Manip,
-                                       p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
-                FrmReplicGroupUpdateOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
-                                          TRUE/* add */);
+                case (e_FM_PCD_EXTRACT_FROM_FIELD):
+                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
+                    p_CcNode->parseCode =
+                        GetFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                          p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
+                                          p_CcNode->offset,
+                                          &p_CcNode->prsArrayOffset,
+                                          p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
+                    break;
+
+                default:
+                    DeleteNode(p_CcNode);
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             }
             break;
-#endif /* (DPAA_VERSION >= 11) */
 
-        case (e_FM_PCD_CC):
-            /* if NIA is not CC, create a TD to continue the CC lookup */
-            FillAdOfTypeContLookup(h_Ad,
-                                   p_FmPcdCcStatsParams,
-                                   p_FmPcd,
-                                   p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-                                   p_FmPcdCcNextEngineParams->h_Manip,
-                                   NULL);
+        case (e_FM_PCD_EXTRACT_NON_HDR):
+            /* get the field code for the generic extract */
+            p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
+            p_CcNode->offset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_CcNode->parseCode =
+                GetGenParseCode(h_FmPcd,
+                                p_CcNodeParam->extractCcParams.extractNonHdr.src,
+                                p_CcNode->offset,
+                                glblMask,
+                                &p_CcNode->prsArrayOffset,
+                                fromIc,icCode);
 
-            UpdateNodeOwner(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode, TRUE);
+            if (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+            {
+                if ((p_CcNode->offset + p_CcNode->sizeOfExtraction) > 8)
+                {
+                     DeleteNode(p_CcNode);
+                     RETURN_ERROR(MAJOR, E_INVALID_SELECTION,("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
+                }
+            }
+            if ((p_CcNode->parseCode == CC_PC_GENERIC_IC_GMASK) ||
+                (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
+            {
+                p_CcNode->offset +=  p_CcNode->prsArrayOffset;
+                p_CcNode->prsArrayOffset = 0;
+            }
             break;
 
-         default:
-             return;
+       default:
+            DeleteNode(p_CcNode);
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
     }
-}
-
-t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
-                          t_Handle  h_FmTree,
-                          t_Handle  h_NetEnv,
-                          t_Handle  h_IpReassemblyManip,
-                          bool      createSchemes)
-{
-    t_FmPcdCcTree               *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
-    t_FmPcdCcNextEngineParams   nextEngineParams;
-    t_NetEnvParams              netEnvParams;
-    t_Handle                    h_Ad;
-    bool                        isIpv6Present;
-    uint8_t                     ipv4GroupId, ipv6GroupId;
-    t_Error                     err;
-
-    ASSERT_COND(p_FmPcdCcTree);
-
-    /* this routine must be protected by the calling routine! */
-
-    memset(&nextEngineParams, 0, sizeof(t_FmPcdCcNextEngineParams));
-    memset(&netEnvParams, 0, sizeof(t_NetEnvParams));
-
-    h_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-    isIpv6Present = FmPcdManipIpReassmIsIpv6Hdr(h_IpReassemblyManip);
+    if (p_CcNode->parseCode == CC_PC_ILLEGAL)
+    {
+        DeleteNode(p_CcNode);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("illegal extraction type"));
+    }
 
-    if (isIpv6Present && (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-2)))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
+    if ((p_CcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY) ||
+        !p_CcNode->sizeOfExtraction)
+    {
+        DeleteNode(p_CcNode);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("sizeOfExatrction can not be greater than 56 and not 0"));
+    }
 
-    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-1))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
+    if (p_CcNodeParam->keysParams.keySize != p_CcNode->sizeOfExtraction)
+    {
+        DeleteNode(p_CcNode);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
+    }
 
-    nextEngineParams.nextEngine = e_FM_PCD_DONE;
-    nextEngineParams.h_Manip = h_IpReassemblyManip;
+    p_CcNode->userSizeOfExtraction = p_CcNode->sizeOfExtraction;
 
-    /* Lock tree */
-    err = CcRootTryLock(p_FmPcdCcTree);
-    if (err)
-        return ERROR_CODE(E_BUSY);
+    if (!glblMask)
+        memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE  * sizeof(uint8_t));
 
-    if (p_FmPcdCcTree->h_IpReassemblyManip == h_IpReassemblyManip)
+    err = CheckAndSetManipParamsWithCcNodeParams(p_CcNode);
+    if (err != E_OK)
     {
-        CcRootReleaseLock(p_FmPcdCcTree);
-        return E_OK;
+        DeleteNode(p_CcNode);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
     }
 
-    if ((p_FmPcdCcTree->h_IpReassemblyManip) &&
-        (p_FmPcdCcTree->h_IpReassemblyManip != h_IpReassemblyManip))
-    {
-        CcRootReleaseLock(p_FmPcdCcTree);
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This tree was previously updated with different IPR"));
-    }
+    /* Calculating matching table entry size by rounding up the user-defined size of extraction to valid entry size */
+    GetCcExtractKeySize(p_CcNode->sizeOfExtraction, &p_CcNode->ccKeySizeAccExtraction);
 
-    /* Initialize IPR for the first time for this tree */
-    if (isIpv6Present)
+    /* If local mask is used, it is stored next to each key in the keys match table */
+    if (p_CcNode->lclMask)
+        keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
+    else
+        keySize = p_CcNode->ccKeySizeAccExtraction;
+
+    /* Update CC shadow with maximal size required by this node */
+    if (p_CcNode->maxNumOfKeys)
     {
-        ipv6GroupId = p_FmPcdCcTree->numOfGrps++;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-2);
+        err = CalcAndUpdateCcShadow(p_CcNode,
+                                    isKeyTblAlloc,
+                                    &matchTableSize,
+                                    &adTableSize);
+        if (err != E_OK)
+        {
+            DeleteNode(p_CcNode);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
 
-        if (createSchemes)
+        p_CcNode->keysMatchTableMaxSize = matchTableSize;
+
+        if (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE)
         {
-            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, FALSE, ipv6GroupId);
-            if (err)
+            err = AllocStatsObjs(p_CcNode);
+            if (err != E_OK)
             {
-                p_FmPcdCcTree->numOfGrps--;
-                CcRootReleaseLock(p_FmPcdCcTree);
+                DeleteNode(p_CcNode);
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
 
-        NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-2) * FM_PCD_CC_AD_ENTRY_SIZE),
-                   NULL,
-                   &nextEngineParams,
-                   h_FmPcd);
-    }
-
-    ipv4GroupId = p_FmPcdCcTree->numOfGrps++;
-    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].totalBitsMask = 0;
-    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-1);
-
-    if (createSchemes)
-    {
-        err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
-        if (err)
+        /* If manipulation will be initialized before this node, it will use the table
+           descriptor in the AD table of previous node and this node will need an extra
+           AD as his table descriptor. */
+        p_CcNode->h_TmpAd = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+                                                     FM_PCD_CC_AD_ENTRY_SIZE,
+                                                     FM_PCD_CC_AD_TABLE_ALIGN);
+        if (!p_CcNode->h_TmpAd)
         {
-            p_FmPcdCcTree->numOfGrps--;
-            if (isIpv6Present)
-            {
-                p_FmPcdCcTree->numOfGrps--;
-                FmPcdManipDeleteIpReassmSchemes(h_IpReassemblyManip);
-            }
-            CcRootReleaseLock(p_FmPcdCcTree);
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+            DeleteNode(p_CcNode);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
         }
     }
+    else
+    {
+        matchTableSize = (uint32_t)(keySize * sizeof(uint8_t) * (p_CcNode->numOfKeys + 1));
+        adTableSize    = (uint32_t)(FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNode->numOfKeys + 1));
+    }
 
-    NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
-               NULL,
-               &nextEngineParams,
-               h_FmPcd);
+#if (DPAA_VERSION >= 11)
+    switch (p_CcNode->statisticsMode)
+    {
 
-    p_FmPcdCcTree->h_IpReassemblyManip = h_IpReassemblyManip;
+        case e_FM_PCD_CC_STATS_MODE_RMON:
+            /* If RMON statistics or RMON conditional statistics modes are requested,
+               allocate frame length ranges array */
+            p_CcNode->h_StatsFLRs =
+                    FM_MURAM_AllocMem(h_FmMuram,
+                                      (uint32_t)(p_CcNode->numOfStatsFLRs) * FM_PCD_CC_STATS_FLR_SIZE,
+                                      FM_PCD_CC_AD_TABLE_ALIGN);
 
-    CcRootReleaseLock(p_FmPcdCcTree);
+            if (!p_CcNode->h_StatsFLRs)
+            {
+                DeleteNode(p_CcNode);
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC frame length ranges array"));
+            }
 
-    return E_OK;
-}
+            /* Initialize using value received from the user */
+            for (tmp = 0; tmp < p_CcNode->numOfStatsFLRs; tmp++)
+            {
+                h_StatsFLRs = PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
 
+                Mem2IOCpy32(h_StatsFLRs,
+                            &(p_CcNodeParam->keysParams.frameLengthRanges[tmp]),
+                            FM_PCD_CC_STATS_FLR_SIZE);
+            }
+            break;
 
-t_Handle FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree)
-{
-    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+        default:
+            break;
+    }
+#endif /* (DPAA_VERSION >= 11) */
 
-    ASSERT_COND(p_FmPcdCcTree);
 
-    return p_FmPcdCcTree->h_FmPcdCcSavedManipParams;
-}
+    /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
+       identification, IPv6 hop count identification, etc. */
+    if (isKeyTblAlloc)
+    {
+        p_CcNode->h_KeysMatchTable =
+            (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+                                        matchTableSize,
+                                        FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+        if (!p_CcNode->h_KeysMatchTable)
+        {
+            DeleteNode(p_CcNode);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
+        }
+        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable,
+                   0,
+                   matchTableSize);
+    }
 
-void   FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams)
-{
-    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+    /* Allocate action descriptors table */
+    p_CcNode->h_AdTable =
+        (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+                                    adTableSize,
+                                    FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_CcNode->h_AdTable)
+    {
+        DeleteNode(p_CcNode);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
+    }
+    IOMemSet32((uint8_t *)p_CcNode->h_AdTable, 0, adTableSize);
 
-    ASSERT_COND(p_FmPcdCcTree);
+    p_KeysMatchTblTmp = p_CcNode->h_KeysMatchTable;
+    p_AdTableTmp      = p_CcNode->h_AdTable;
 
-    p_FmPcdCcTree->h_FmPcdCcSavedManipParams = h_SavedManipParams;
-}
+    /* For each key, create the key and the next step AD */
+    for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
-uint8_t FmPcdCcGetParseCode(t_Handle h_CcNode)
-{
-    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+        if (p_KeysMatchTblTmp)
+        {
+            /* Copy the key */
+            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_CcNode->sizeOfExtraction);
 
-    ASSERT_COND(p_CcNode);
+            /* Copy the key mask or initialize it to 0xFF..F */
+            if (p_CcNode->lclMask && p_KeyParams->p_Mask)
+            {
+                Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp,
+                                     p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
+                            p_KeyParams->p_Mask,
+                            p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
+            }
+            else if (p_CcNode->lclMask)
+            {
+                IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
+                                    p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
+                           0xff,
+                           p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
+            }
 
-    return p_CcNode->parseCode;
-}
+            p_KeysMatchTblTmp = PTR_MOVE(p_KeysMatchTblTmp, keySize * sizeof(uint8_t));
+        }
 
-uint8_t FmPcdCcGetOffset(t_Handle h_CcNode)
-{
-    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+        /* Create the next action descriptor in the match table */
+        if (p_KeyParams->ccNextEngineParams.statisticsEn)
+        {
+            p_StatsObj = GetStatsObj(p_CcNode);
+            ASSERT_COND(p_StatsObj);
 
-    ASSERT_COND(p_CcNode);
+            statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
+            statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
+#if (DPAA_VERSION >= 11)
+            statsParams.h_StatsFLRs = p_CcNode->h_StatsFLRs;
 
-    return p_CcNode->offset;
-}
+#endif /* (DPAA_VERSION >= 11) */
+            NextStepAd(p_AdTableTmp,
+                       &statsParams,
+                       &p_KeyParams->ccNextEngineParams,
+                       p_FmPcd);
 
-uint16_t FmPcdCcGetNumOfKeys(t_Handle h_CcNode)
-{
-    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+            p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = p_StatsObj;
+        }
+        else
+        {
+            NextStepAd(p_AdTableTmp,
+                       NULL,
+                       &p_KeyParams->ccNextEngineParams,
+                       p_FmPcd);
 
-    ASSERT_COND(p_CcNode);
+            p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = NULL;
+        }
 
-    return p_CcNode->numOfKeys;
-}
+        p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+    }
 
-t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
-                                         t_Handle                   h_FmPcdCcTree,
-                                         uint8_t                    grpId,
-                                         uint8_t                    index,
-                                         t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
-{
-    t_FmPcdCcTree                       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    uint16_t                            keyIndex;
-    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
-    t_Error                             err = E_OK;
+    /* Update next engine for the 'miss' entry */
+    if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.statisticsEn)
+    {
+        p_StatsObj = GetStatsObj(p_CcNode);
+        ASSERT_COND(p_StatsObj);
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
+        /* All 'bucket' nodes of a hash table should share the same statistics counters,
+           allocated by the hash table. So, if this node is a bucket of a hash table,
+           we'll replace the locally allocated counters with the shared counters. */
+        if (p_CcNode->isHashBucket)
+        {
+            ASSERT_COND(p_CcNode->h_MissStatsCounters);
 
-    if (grpId >= p_FmPcdCcTree->numOfGrps)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+            /* Store original counters pointer and replace it with mutual preallocated pointer */
+            p_CcNode->h_PrivMissStatsCounters = p_StatsObj->h_StatsCounters;
+            p_StatsObj->h_StatsCounters = p_CcNode->h_MissStatsCounters;
+        }
 
-    if (index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
+        statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
+        statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
+#if (DPAA_VERSION >= 11)
+        statsParams.h_StatsFLRs = p_CcNode->h_StatsFLRs;
 
-    p_FmPcd = (t_FmPcd *)h_FmPcd;
+#endif /* (DPAA_VERSION >= 11) */
 
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
+        NextStepAd(p_AdTableTmp,
+                   &statsParams,
+                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                   p_FmPcd);
 
-    keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index);
+        p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = p_StatsObj;
+    }
+    else
+    {
+        NextStepAd(p_AdTableTmp,
+                   NULL,
+                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                   p_FmPcd);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_FmPcdCcTree, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, TRUE);
-    if (!p_ModifyKeyParams)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+        p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = NULL;
+    }
 
-    p_ModifyKeyParams->tree = TRUE;
+    /* This parameter will be used to initialize the "key length" field in the action descriptor
+       that points to this node and it should be 0 for full field extraction */
+    if (fullField == TRUE)
+        p_CcNode->sizeOfExtraction = 0;
 
-    if (p_FmPcd->p_CcShadow &&
-        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, CC_MAX_NUM_OF_KEYS); tmp++)
     {
-        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        {
+            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
+            p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccPrevNodesLst,
+                                                        (t_Handle)p_CcNode,
+                                                        p_FmPcdCcNextNode->h_Spinlock);
+            if (!p_CcInformation)
+            {
+                memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
+                ccNodeInfo.index = 1;
+                EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNextNode->ccPrevNodesLst,
+                                             &ccNodeInfo,
+                                             p_FmPcdCcNextNode->h_Spinlock);
+            }
+            else
+                p_CcInformation->index++;
+
+            if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+            {
+                h_Manip = p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
+                p_CcInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
+                                                             (t_Handle)p_CcNode,
+                                                             FmPcdManipGetSpinlock(h_Manip));
+                if (!p_CcInformation)
+                {
+                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                     ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
+                     ccNodeInfo.index = 1;
+                     EnqueueNodeInfoToRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
+                                                  &ccNodeInfo,
+                                                  FmPcdManipGetSpinlock(h_Manip));
+                }
+                else
+                    p_CcInformation->index++;
+            }
+        }
+    }
+
+    p_AdTableTmp = p_CcNode->h_AdTable;
+
+    if (!FmPcdLockTryLockAll(h_FmPcd))
+    {
+        FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
         return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine(p_FmPcd,
-                                       p_FmPcdCcTree,
-                                       keyIndex,
-                                       p_FmPcdCcNextEngineParams,
-                                       &h_OldPointersLst,
-                                       &h_NewPointersLst,
-                                       p_ModifyKeyParams);
-    if (err)
+    /* Required action for each next engine */
+    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, CC_MAX_NUM_OF_KEYS); tmp++)
     {
-        XX_Free(p_ModifyKeyParams);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
+        {
+            err = SetRequiredAction(h_FmPcd,
+                                    p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
+                                    &p_CcNode->keyAndNextEngineParams[tmp],
+                                    p_AdTableTmp,
+                                    1,
+                                    NULL);
+            if (err)
+            {
+                FmPcdLockUnlockAll(h_FmPcd);
+                FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+            p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+        }
     }
 
-    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+    FmPcdLockUnlockAll(h_FmPcd);
 
-    if (p_FmPcd->p_CcShadow)
-        RELEASE_LOCK(p_FmPcd->shadowLock);
+    return E_OK;
+}
+/************************** End of static functions **************************/
 
-    return err;
 
-}
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
 
-t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
-                         t_Handle   h_FmPcdCcNode,
-                         uint16_t   keyIndex)
+t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
 {
+    t_CcNodeInformation *p_CcInformation;
+    t_List              *p_Pos;
+    uint32_t            intFlags;
 
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    bool                                useShadowStructs = FALSE;
-    t_Error                             err = E_OK;
-
-    if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("impossible to remove key when numOfKeys <= keyIndex"));
+    intFlags = XX_LockIntrSpinlock(h_Spinlock);
 
-    if (!p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    {
+        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
 
-    if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+        ASSERT_COND(p_CcInformation->h_CcNode);
 
-    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+        if (p_CcInformation->h_CcNode == h_Info)
+        {
+            XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+            return p_CcInformation;
+        }
+    }
 
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
+    XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_REMOVE, TRUE, TRUE, FALSE);
-    if (!p_ModifyKeyParams)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    return NULL;
+}
 
-    if (p_CcNode->maxNumOfKeys)
-    {
-        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
-        {
-            XX_Free(p_ModifyKeyParams);
-            return ERROR_CODE(E_BUSY);
-        }
-
-        useShadowStructs = TRUE;
-    }
+void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo, t_Handle h_Spinlock)
+{
+    t_CcNodeInformation *p_CcInformation;
+    uint32_t            intFlags = 0;
 
-    err = BuildNewNodeRemoveKey(p_CcNode, keyIndex, p_ModifyKeyParams);
-    if (err)
-    {
-        XX_Free(p_ModifyKeyParams);
-        if (p_CcNode->maxNumOfKeys)
-            RELEASE_LOCK(p_FmPcd->shadowLock);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(sizeof(t_CcNodeInformation));
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
-                                           &h_OldPointersLst,
-                                           &h_NewPointersLst);
-    if (err)
+    if (p_CcInformation)
     {
-        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
-        XX_Free(p_ModifyKeyParams);
-        if (p_CcNode->maxNumOfKeys)
-            RELEASE_LOCK(p_FmPcd->shadowLock);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        memset(p_CcInformation, 0, sizeof(t_CcNodeInformation));
+        memcpy(p_CcInformation, p_CcInfo, sizeof(t_CcNodeInformation));
+        INIT_LIST(&p_CcInformation->node);
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+        if (h_Spinlock)
+            intFlags = XX_LockIntrSpinlock(h_Spinlock);
 
-    if (p_CcNode->maxNumOfKeys)
-        RELEASE_LOCK(p_FmPcd->shadowLock);
+        LIST_AddToTail(&p_CcInformation->node, p_List);
 
-    return err;
+        if (h_Spinlock)
+            XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+    }
+    else
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Node Information"));
 }
 
-t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
-                         t_Handle   h_FmPcdCcNode,
-                         uint16_t   keyIndex,
-                         uint8_t    keySize,
-                         uint8_t    *p_Key,
-                         uint8_t    *p_Mask)
+void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    uint16_t                            tmpKeyIndex;
-    bool                                useShadowStructs = FALSE;
-    t_Error                             err = E_OK;
-
-    if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
-
-    if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size for ModifyKey has to be the same as defined in SetNode"));
-
-    if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
-
-    err = FindKeyIndex(h_FmPcdCcNode,
-                       keySize,
-                       p_Key,
-                       p_Mask,
-                       &tmpKeyIndex);
-    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
-        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
-                     ("The received key and mask pair was already found in the match table of the provided node"));
-
-    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
-
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
+    t_CcNodeInformation *p_CcInformation = NULL;
+    uint32_t            intFlags = 0;
+    t_List              *p_Pos;
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
-    if (!p_ModifyKeyParams)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    if (h_Spinlock)
+        intFlags = XX_LockIntrSpinlock(h_Spinlock);
 
-    if (p_CcNode->maxNumOfKeys)
+    if (LIST_IsEmpty(p_List))
     {
-        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
-        {
-            XX_Free(p_ModifyKeyParams);
-            return ERROR_CODE(E_BUSY);
-        }
-
-        useShadowStructs = TRUE;
+        XX_RestoreAllIntr(intFlags);
+        return;
     }
 
-    err = BuildNewNodeModifyKey(p_CcNode,
-                                keyIndex,
-                                p_Key,
-                                p_Mask,
-                                p_ModifyKeyParams);
-    if (err)
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
     {
-        XX_Free(p_ModifyKeyParams);
-        if (p_CcNode->maxNumOfKeys)
-            RELEASE_LOCK(p_FmPcd->shadowLock);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcInformation);
+        ASSERT_COND(p_CcInformation->h_CcNode);
+        if (p_CcInformation->h_CcNode == h_Info)
+            break;
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
-                                           &h_OldPointersLst,
-                                           &h_NewPointersLst);
-    if (err)
+    if (p_CcInformation)
     {
-        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
-        XX_Free(p_ModifyKeyParams);
-        if (p_CcNode->maxNumOfKeys)
-            RELEASE_LOCK(p_FmPcd->shadowLock);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        LIST_DelAndInit(&p_CcInformation->node);
+        XX_Free(p_CcInformation);
     }
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+    if (h_Spinlock)
+        XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+}
 
-    if (p_CcNode->maxNumOfKeys)
-        RELEASE_LOCK(p_FmPcd->shadowLock);
+void NextStepAd(t_Handle                     h_Ad,
+                t_FmPcdCcStatsParams         *p_FmPcdCcStatsParams,
+                t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
+                t_FmPcd                      *p_FmPcd)
+{
+    switch (p_FmPcdCcNextEngineParams->nextEngine)
+    {
+        case (e_FM_PCD_KG):
+        case (e_FM_PCD_PLCR):
+        case (e_FM_PCD_DONE):
+            /* if NIA is not CC, create a "result" type AD */
+            FillAdOfTypeResult(h_Ad,
+                               p_FmPcdCcStatsParams,
+                               p_FmPcd,
+                               p_FmPcdCcNextEngineParams);
+            break;
+#if (DPAA_VERSION >= 11)
+        case (e_FM_PCD_FR):
+            if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
+            {
+                FillAdOfTypeContLookup(h_Ad,
+                                       p_FmPcdCcStatsParams,
+                                       p_FmPcd,
+                                       p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                                       p_FmPcdCcNextEngineParams->h_Manip,
+                                       p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
+                FrmReplicGroupUpdateOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
+                                          TRUE/* add */);
+            }
+            break;
+#endif /* (DPAA_VERSION >= 11) */
 
-    return err;
+        case (e_FM_PCD_CC):
+            /* if NIA is not CC, create a TD to continue the CC lookup */
+            FillAdOfTypeContLookup(h_Ad,
+                                   p_FmPcdCcStatsParams,
+                                   p_FmPcd,
+                                   p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                                   p_FmPcdCcNextEngineParams->h_Manip,
+                                   NULL);
+
+            UpdateNodeOwner(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode, TRUE);
+            break;
+
+         default:
+             return;
+    }
 }
 
-t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
-                                             t_Handle                   h_FmPcdCcNode,
-                                             t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
+t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
+                          t_Handle  h_FmTree,
+                          t_Handle  h_NetEnv,
+                          t_Handle  h_IpReassemblyManip,
+                          bool      createSchemes)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    uint16_t                            keyIndex;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_Error                             err = E_OK;
+    t_FmPcdCcTree               *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+    t_FmPcdCcNextEngineParams   nextEngineParams;
+    t_NetEnvParams              netEnvParams;
+    t_Handle                    h_Ad;
+    bool                        isIpv6Present;
+    uint8_t                     ipv4GroupId, ipv6GroupId;
+    t_Error                     err;
 
-    SANITY_CHECK_RETURN_ERROR(p_CcNode,E_INVALID_VALUE);
+    ASSERT_COND(p_FmPcdCcTree);
 
-    keyIndex = p_CcNode->numOfKeys;
+    /* this routine must be protected by the calling routine! */
 
-    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    memset(&nextEngineParams, 0, sizeof(t_FmPcdCcNextEngineParams));
+    memset(&netEnvParams, 0, sizeof(t_NetEnvParams));
 
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
+    h_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, TRUE, FALSE);
-    if (!p_ModifyKeyParams)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    isIpv6Present = FmPcdManipIpReassmIsIpv6Hdr(h_IpReassemblyManip);
 
-    if (p_CcNode->maxNumOfKeys &&
-        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
-    {
-        XX_Free(p_ModifyKeyParams);
+    if (isIpv6Present && (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-2)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
+
+    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-1))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
+
+    nextEngineParams.nextEngine = e_FM_PCD_DONE;
+    nextEngineParams.h_Manip = h_IpReassemblyManip;
+
+    /* Lock tree */
+    err = CcRootTryLock(p_FmPcdCcTree);
+    if (err)
         return ERROR_CODE(E_BUSY);
+
+    if (p_FmPcdCcTree->h_IpReassemblyManip == h_IpReassemblyManip)
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        return E_OK;
     }
 
-    err = BuildNewNodeModifyNextEngine(h_FmPcd,
-                                       p_CcNode,
-                                       keyIndex,
-                                       p_FmPcdCcNextEngineParams,
+    if ((p_FmPcdCcTree->h_IpReassemblyManip) &&
+        (p_FmPcdCcTree->h_IpReassemblyManip != h_IpReassemblyManip))
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This tree was previously updated with different IPR"));
+    }
+
+    /* Initialize IPR for the first time for this tree */
+    if (isIpv6Present)
+    {
+        ipv6GroupId = p_FmPcdCcTree->numOfGrps++;
+        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-2);
+
+        if (createSchemes)
+        {
+            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, FALSE, ipv6GroupId);
+            if (err)
+            {
+                p_FmPcdCcTree->numOfGrps--;
+                CcRootReleaseLock(p_FmPcdCcTree);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+        }
+
+        NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-2) * FM_PCD_CC_AD_ENTRY_SIZE),
+                   NULL,
+                   &nextEngineParams,
+                   h_FmPcd);
+    }
+
+    ipv4GroupId = p_FmPcdCcTree->numOfGrps++;
+    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].totalBitsMask = 0;
+    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-1);
+
+    if (createSchemes)
+    {
+        err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
+        if (err)
+        {
+            p_FmPcdCcTree->numOfGrps--;
+            if (isIpv6Present)
+            {
+                p_FmPcdCcTree->numOfGrps--;
+                FmPcdManipDeleteIpReassmSchemes(h_IpReassemblyManip);
+            }
+            CcRootReleaseLock(p_FmPcdCcTree);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+    }
+
+    NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
+               NULL,
+               &nextEngineParams,
+               h_FmPcd);
+
+    p_FmPcdCcTree->h_IpReassemblyManip = h_IpReassemblyManip;
+
+    CcRootReleaseLock(p_FmPcdCcTree);
+
+    return E_OK;
+}
+
+t_Handle FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+
+    ASSERT_COND(p_FmPcdCcTree);
+
+    return p_FmPcdCcTree->h_FmPcdCcSavedManipParams;
+}
+
+void   FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+
+    ASSERT_COND(p_FmPcdCcTree);
+
+    p_FmPcdCcTree->h_FmPcdCcSavedManipParams = h_SavedManipParams;
+}
+
+uint8_t FmPcdCcGetParseCode(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_CcNode);
+
+    return p_CcNode->parseCode;
+}
+
+uint8_t FmPcdCcGetOffset(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_CcNode);
+
+    return p_CcNode->offset;
+}
+
+uint16_t FmPcdCcGetNumOfKeys(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_CcNode);
+
+    return p_CcNode->numOfKeys;
+}
+
+t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
+                                         t_Handle                   h_FmPcdCcTree,
+                                         uint8_t                    grpId,
+                                         uint8_t                    index,
+                                         t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcdCcTree                       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcd                             *p_FmPcd;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    uint16_t                            keyIndex;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_Error                             err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
+
+    if (grpId >= p_FmPcdCcTree->numOfGrps)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+
+    if (index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
+
+    p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index);
+
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_FmPcdCcTree, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, TRUE);
+    if (!p_ModifyKeyParams)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_ModifyKeyParams->tree = TRUE;
+
+    if (p_FmPcd->p_CcShadow &&
+        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    {
+        XX_Free(p_ModifyKeyParams);
+        return ERROR_CODE(E_BUSY);
+    }
+
+    err = BuildNewNodeModifyNextEngine(p_FmPcd,
+                                       p_FmPcdCcTree,
+                                       keyIndex,
+                                       p_FmPcdCcNextEngineParams,
                                        &h_OldPointersLst,
                                        &h_NewPointersLst,
                                        p_ModifyKeyParams);
     if (err)
     {
         XX_Free(p_ModifyKeyParams);
-        if (p_CcNode->maxNumOfKeys)
-            RELEASE_LOCK(p_FmPcd->shadowLock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
 
-    if (p_CcNode->maxNumOfKeys)
+    if (p_FmPcd->p_CcShadow)
         RELEASE_LOCK(p_FmPcd->shadowLock);
 
     return err;
+
 }
 
-t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
-                      t_Handle              h_FmPcdCcNode,
-                      uint16_t              keyIndex,
-                      uint8_t               keySize,
-                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
+                         t_Handle   h_FmPcdCcNode,
+                         uint16_t   keyIndex)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
     t_FmPcd                             *p_FmPcd;
     t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
     t_List                              h_OldPointersLst, h_NewPointersLst;
     bool                                useShadowStructs = FALSE;
-    uint16_t                            tmpKeyIndex;
     t_Error                             err = E_OK;
 
-    if (keyIndex > p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("keyIndex > previously cleared last index + 1"));
+    if (keyIndex >= p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("impossible to remove key when numOfKeys <= keyIndex"));
 
-    if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
+    if (!p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    if (p_CcNode->maxNumOfKeys)
-    {
-        if (p_CcNode->numOfKeys == p_CcNode->maxNumOfKeys)
-            RETURN_ERROR(MAJOR, E_FULL, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
-    }
-    else if (p_CcNode->numOfKeys == FM_PCD_MAX_NUM_OF_KEYS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys can not be larger than %d", FM_PCD_MAX_NUM_OF_KEYS));
-
-    err = FindKeyIndex(h_FmPcdCcNode,
-                       keySize,
-                       p_FmPcdCcKeyParams->p_Key,
-                       p_FmPcdCcKeyParams->p_Mask,
-                       &tmpKeyIndex);
-    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
-        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS,
-                     ("The received key and mask pair was already found in the match table of the provided node"));
-
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode,
-                                             keyIndex,
-                                             e_MODIFY_STATE_ADD,
-                                             TRUE,
-                                             TRUE,
-                                             FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_REMOVE, TRUE, TRUE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -4657,15 +4975,9 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         useShadowStructs = TRUE;
     }
 
-    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
-                                                 p_CcNode,
-                                                 keyIndex,
-                                                 p_FmPcdCcKeyParams,
-                                                 p_ModifyKeyParams,
-                                                 TRUE);
+    err = BuildNewNodeRemoveKey(p_CcNode, keyIndex, p_ModifyKeyParams);
     if (err)
     {
-        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
         XX_Free(p_ModifyKeyParams);
         if (p_CcNode->maxNumOfKeys)
             RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -4690,17 +5002,19 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
                           &h_NewPointersLst,
                           p_ModifyKeyParams,
                           useShadowStructs);
+
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
 
     return err;
 }
 
-t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
-                                      t_Handle              h_FmPcdCcNode,
-                                      uint16_t              keyIndex,
-                                      uint8_t               keySize,
-                                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
+                         t_Handle   h_FmPcdCcNode,
+                         uint16_t   keyIndex,
+                         uint8_t    keySize,
+                         uint8_t    *p_Key,
+                         uint8_t    *p_Mask)
 {
     t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
     t_FmPcd                             *p_FmPcd;
@@ -4710,19 +5024,19 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
     bool                                useShadowStructs = FALSE;
     t_Error                             err = E_OK;
 
-    if (keyIndex > p_CcNode->numOfKeys)
+    if (keyIndex >= p_CcNode->numOfKeys)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size for ModifyKey has to be the same as defined in SetNode"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
     err = FindKeyIndex(h_FmPcdCcNode,
                        keySize,
-                       p_FmPcdCcKeyParams->p_Key,
-                       p_FmPcdCcKeyParams->p_Mask,
+                       p_Key,
+                       p_Mask,
                        &tmpKeyIndex);
     if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
         RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
@@ -4748,15 +5062,13 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
         useShadowStructs = TRUE;
     }
 
-    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
-                                                 p_CcNode,
-                                                 keyIndex,
-                                                 p_FmPcdCcKeyParams,
-                                                 p_ModifyKeyParams,
-                                                 FALSE);
+    err = BuildNewNodeModifyKey(p_CcNode,
+                                keyIndex,
+                                p_Key,
+                                p_Mask,
+                                p_ModifyKeyParams);
     if (err)
     {
-        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
         XX_Free(p_ModifyKeyParams);
         if (p_CcNode->maxNumOfKeys)
             RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -4788,12 +5100,262 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
     return err;
 }
 
-uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer)
+t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
+                                             t_Handle                   h_FmPcdCcNode,
+                                             t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_CcNodeInformation             *p_CcNodeInfo;
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                             *p_FmPcd;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    uint16_t                            keyIndex;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    t_Error                             err = E_OK;
 
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode,E_INVALID_VALUE);
+
+    keyIndex = p_CcNode->numOfKeys;
+
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, TRUE, FALSE);
+    if (!p_ModifyKeyParams)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    if (p_CcNode->maxNumOfKeys &&
+        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    {
+        XX_Free(p_ModifyKeyParams);
+        return ERROR_CODE(E_BUSY);
+    }
+
+    err = BuildNewNodeModifyNextEngine(h_FmPcd,
+                                       p_CcNode,
+                                       keyIndex,
+                                       p_FmPcdCcNextEngineParams,
+                                       &h_OldPointersLst,
+                                       &h_NewPointersLst,
+                                       p_ModifyKeyParams);
+    if (err)
+    {
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+
+    if (p_CcNode->maxNumOfKeys)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+
+    return err;
+}
+
+t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
+                      t_Handle              h_FmPcdCcNode,
+                      uint16_t              keyIndex,
+                      uint8_t               keySize,
+                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+{
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                             *p_FmPcd;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    bool                                useShadowStructs = FALSE;
+    uint16_t                            tmpKeyIndex;
+    t_Error                             err = E_OK;
+
+    if (keyIndex > p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("keyIndex > previously cleared last index + 1"));
+
+    if (keySize != p_CcNode->userSizeOfExtraction)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
+
+    if (p_CcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if (p_CcNode->numOfKeys == p_CcNode->maxNumOfKeys)
+            RETURN_ERROR(MAJOR, E_FULL, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
+    }
+    else if (p_CcNode->numOfKeys == FM_PCD_MAX_NUM_OF_KEYS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys can not be larger than %d", FM_PCD_MAX_NUM_OF_KEYS));
+
+    err = FindKeyIndex(h_FmPcdCcNode,
+                       keySize,
+                       p_FmPcdCcKeyParams->p_Key,
+                       p_FmPcdCcKeyParams->p_Mask,
+                       &tmpKeyIndex);
+    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS,
+                     ("The received key and mask pair was already found in the match table of the provided node"));
+
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode,
+                                             keyIndex,
+                                             e_MODIFY_STATE_ADD,
+                                             TRUE,
+                                             TRUE,
+                                             FALSE);
+    if (!p_ModifyKeyParams)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        {
+            XX_Free(p_ModifyKeyParams);
+            return ERROR_CODE(E_BUSY);
+        }
+
+        useShadowStructs = TRUE;
+    }
+
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
+                                                 p_CcNode,
+                                                 keyIndex,
+                                                 p_FmPcdCcKeyParams,
+                                                 p_ModifyKeyParams,
+                                                 TRUE);
+    if (err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
+                                           p_ModifyKeyParams,
+                                           &h_OldPointersLst,
+                                           &h_NewPointersLst);
+    if (err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = DoDynamicChange(p_FmPcd,
+                          &h_OldPointersLst,
+                          &h_NewPointersLst,
+                          p_ModifyKeyParams,
+                          useShadowStructs);
+    if (p_CcNode->maxNumOfKeys)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+
+    return err;
+}
+
+t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
+                                      t_Handle              h_FmPcdCcNode,
+                                      uint16_t              keyIndex,
+                                      uint8_t               keySize,
+                                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+{
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                             *p_FmPcd;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    uint16_t                            tmpKeyIndex;
+    bool                                useShadowStructs = FALSE;
+    t_Error                             err = E_OK;
+
+    if (keyIndex > p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+
+    if (keySize != p_CcNode->userSizeOfExtraction)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
+
+    if (p_CcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+
+    err = FindKeyIndex(h_FmPcdCcNode,
+                       keySize,
+                       p_FmPcdCcKeyParams->p_Key,
+                       p_FmPcdCcKeyParams->p_Mask,
+                       &tmpKeyIndex);
+    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
+        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
+                     ("The received key and mask pair was already found in the match table of the provided node"));
+
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
+    if (!p_ModifyKeyParams)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        {
+            XX_Free(p_ModifyKeyParams);
+            return ERROR_CODE(E_BUSY);
+        }
+
+        useShadowStructs = TRUE;
+    }
+
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
+                                                 p_CcNode,
+                                                 keyIndex,
+                                                 p_FmPcdCcKeyParams,
+                                                 p_ModifyKeyParams,
+                                                 FALSE);
+    if (err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
+                                           p_ModifyKeyParams,
+                                           &h_OldPointersLst,
+                                           &h_NewPointersLst);
+    if (err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = DoDynamicChange(p_FmPcd,
+                          &h_OldPointersLst,
+                          &h_NewPointersLst,
+                          p_ModifyKeyParams,
+                          useShadowStructs);
+
+    if (p_CcNode->maxNumOfKeys)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+
+    return err;
+}
+
+uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_CcNodeInformation             *p_CcNodeInfo;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
 
     p_CcNodeInfo = CC_NODE_F_OBJECT(h_Pointer);
 
@@ -4871,699 +5433,154 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *
 
     LIST_FOR_EACH(p_Pos, &p_CcNode->ccTreesLst)
     {
-        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
-        ASSERT_COND(p_CcNodeInfo->h_CcNode);
-
-        err = CcRootTryLock(p_CcNodeInfo->h_CcNode);
-
-        if (err)
-        {
-            LIST_FOR_EACH(p_Tmp, &p_CcNode->ccTreesLst)
-            {
-                if (p_Tmp == p_Pos)
-                    break;
-
-                CcRootReleaseLock(p_CcNodeInfo->h_CcNode);
-            }
-            break;
-        }
-
-        memset(&nodeInfo, 0, sizeof(t_CcNodeInformation));
-        nodeInfo.h_CcNode = p_CcNodeInfo->h_CcNode;
-        EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo, NULL);
-    }
-
-    FmPcdUnlock(h_FmPcd, intFlags);
-    CORE_MemoryBarrier();
-
-    return err;
-}
-
-void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
-{
-    t_List              *p_Pos;
-    t_CcNodeInformation *p_CcNodeInfo;
-    t_Handle            h_FmPcdCcTree;
-    uint32_t            intFlags;
-
-    intFlags = FmPcdLock(h_FmPcd);
-
-    LIST_FOR_EACH(p_Pos, p_List)
-    {
-        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
-        h_FmPcdCcTree = p_CcNodeInfo->h_CcNode;
-        CcRootReleaseLock(h_FmPcdCcTree);
-    }
-
-    ReleaseLst(p_List);
-
-    FmPcdUnlock(h_FmPcd, intFlags);
-    CORE_MemoryBarrier();
-}
-
-
-t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
-{
-    uint32_t    intFlags;
-    uint32_t    newSize = 0, newAlign = 0;
-    bool        allocFail = FALSE;
-
-    ASSERT_COND(p_FmPcd);
-
-    if (!size)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size must be larger then 0"));
-
-    if (!POWER_OF_2(align))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("alignment must be power of 2"));
-
-    newSize  = p_FmPcd->ccShadowSize;
-    newAlign = p_FmPcd->ccShadowAlign;
-
-    /* Check if current shadow is large enough to hold the requested size */
-    if (size > p_FmPcd->ccShadowSize)
-        newSize = size;
-
-    /* Check if current shadow matches the requested alignment */
-    if (align > p_FmPcd->ccShadowAlign)
-        newAlign = align;
-
-    /* If a bigger shadow size or bigger shadow alignment are required,
-       a new shadow will be allocated */
-    if ((newSize != p_FmPcd->ccShadowSize) || (newAlign != p_FmPcd->ccShadowAlign))
-    {
-        intFlags = FmPcdLock(p_FmPcd);
-
-        if (p_FmPcd->p_CcShadow)
-        {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), p_FmPcd->p_CcShadow);
-            p_FmPcd->ccShadowSize  = 0;
-            p_FmPcd->ccShadowAlign = 0;
-        }
-
-        p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                                newSize,
-                                                newAlign);
-        if (!p_FmPcd->p_CcShadow)
-        {
-            allocFail = TRUE;
-
-            /* If new shadow size allocation failed,
-               re-allocate with previous parameters */
-            p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                                    p_FmPcd->ccShadowSize,
-                                                    p_FmPcd->ccShadowAlign);
-        }
-
-        FmPcdUnlock(p_FmPcd, intFlags);
-
-        if (allocFail)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Shadow memory"));
-
-        p_FmPcd->ccShadowSize  = newSize;
-        p_FmPcd->ccShadowAlign = newAlign;
-    }
-
-    return E_OK;
-}
-
-#if (DPAA_VERSION >= 11)
-void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
-                                              t_Handle  h_ReplicGroup,
-                                              t_List    *p_AdTables,
-                                              uint32_t  *p_NumOfAdTables)
-{
-    t_FmPcdCcNode           *p_CurrentNode = (t_FmPcdCcNode *)h_Node;
-    int                     i = 0;
-    void *                  p_AdTable;
-    t_CcNodeInformation     ccNodeInfo;
-
-    ASSERT_COND(h_Node);
-    *p_NumOfAdTables = 0;
-
-    /* search in the current node which exact index points on this current replicator group for getting AD */
-    for (i = 0; i < p_CurrentNode->numOfKeys + 1; i++)
-    {
-        if ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic == (t_Handle)h_ReplicGroup)))
-        {
-            /* save the current ad table in the list */
-            /* this entry uses the input replicator group */
-            p_AdTable = PTR_MOVE(p_CurrentNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
-            memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-            ccNodeInfo.h_CcNode = p_AdTable;
-            EnqueueNodeInfoToRelevantLst(p_AdTables, &ccNodeInfo, NULL);
-            (*p_NumOfAdTables)++;
-        }
-    }
-
-    ASSERT_COND(i != p_CurrentNode->numOfKeys);
-}
-#endif /* (DPAA_VERSION >= 11) */
-
-t_Error FmPcdCcMatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdCcNodeParams *p_CcNodeParam)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *) h_FmPcd;
-    t_FmPcdCcNode           *p_FmPcdCcNextNode;
-    t_Error                 err = E_OK;
-    uint32_t                tmp, keySize;
-    bool                    glblMask = FALSE;
-    t_FmPcdCcKeyParams      *p_KeyParams;
-    t_Handle                h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
-#if (DPAA_VERSION >= 11)
-    t_Handle                h_StatsFLRs;
-#endif /* (DPAA_VERSION >= 11) */
-    bool                    fullField = FALSE;
-    ccPrivateInfo_t         icCode = CC_PRIVATE_INFO_NONE;
-    bool                    isKeyTblAlloc, fromIc = FALSE;
-    uint32_t                matchTableSize, adTableSize;
-    t_CcNodeInformation     ccNodeInfo, *p_CcInformation;
-    t_FmPcdStatsObj         *p_StatsObj;
-    t_FmPcdCcStatsParams    statsParams = {0};
-    t_Handle                h_Manip;
-
-    ASSERT_COND(h_FmPcd);
-    ASSERT_COND(p_CcNode);
-    ASSERT_COND(p_CcNodeParam);
-
-    p_CcNode->p_GlblMask = (t_Handle)XX_Malloc(CC_GLBL_MASK_SIZE * sizeof(uint8_t));
-    memset(p_CcNode->p_GlblMask, 0, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
-
-    p_CcNode->h_FmPcd           = h_FmPcd;
-    p_CcNode->numOfKeys         = p_CcNodeParam->keysParams.numOfKeys;
-    p_CcNode->maxNumOfKeys      = p_CcNodeParam->keysParams.maxNumOfKeys;
-    p_CcNode->maskSupport       = p_CcNodeParam->keysParams.maskSupport;
-    p_CcNode->statisticsMode    = p_CcNodeParam->keysParams.statisticsMode;
-
-    /* For backward compatibility - even if statistics mode is nullified,
-       we'll fix it to frame mode so we can support per-key request for
-       statistics using 'statisticsEn' in next engine parameters */
-    if (!p_CcNode->maxNumOfKeys &&
-        (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE))
-        p_CcNode->statisticsMode = e_FM_PCD_CC_STATS_MODE_FRAME;
-
-    h_FmMuram = FmPcdGetMuramHandle(h_FmPcd);
-    if (!h_FmMuram)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM MURAM"));
-
-    INIT_LIST(&p_CcNode->ccPrevNodesLst);
-    INIT_LIST(&p_CcNode->ccTreeIdLst);
-    INIT_LIST(&p_CcNode->ccTreesLst);
-    INIT_LIST(&p_CcNode->availableStatsLst);
-
-    p_CcNode->h_Spinlock = XX_InitSpinlock();
-    if (!p_CcNode->h_Spinlock)
-    {
-        DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("CC node spinlock"));
-    }
-
-    if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR) &&
-        ((p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv4) ||
-        (p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv6)) &&
-        (p_CcNodeParam->extractCcParams.extractByHdr.type == e_FM_PCD_EXTRACT_FULL_FIELD) &&
-        ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6 == NET_HEADER_FIELD_IPv6_HOP_LIMIT) ||
-        (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4 == NET_HEADER_FIELD_IPv4_TTL)))
-    {
-        err = Ipv4TtlOrIpv6HopLimitCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
-        glblMask = FALSE;
-    }
-    else if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
-             ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_KEY) ||
-              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
-              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
-    {
-        if ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
-            (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
-        {
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                         ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
-        }
-
-        icCode = IcDefineCode(p_CcNodeParam);
-        fromIc = TRUE;
-        if (icCode == CC_PRIVATE_INFO_NONE)
-        {
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                         ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
-        }
-
-        if ((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP) ||
-            (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
-        {
-            err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
-            glblMask = TRUE;
-        }
-        else
-        {
-            err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
-            if (p_CcNode->glblMaskSize)
-                glblMask = TRUE;
-        }
-    }
-    else
-    {
-        err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
-        if (p_CcNode->glblMaskSize)
-            glblMask = TRUE;
-    }
-
-    if (err)
-    {
-        DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-    switch (p_CcNodeParam->extractCcParams.type)
-    {
-        case (e_FM_PCD_EXTRACT_BY_HDR):
-            switch (p_CcNodeParam->extractCcParams.extractByHdr.type)
-            {
-                case (e_FM_PCD_EXTRACT_FULL_FIELD):
-                    p_CcNode->parseCode =
-                        GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                              p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                              p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
-                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                       p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField,
-                                       &p_CcNode->sizeOfExtraction);
-                    fullField = TRUE;
-                    if ((p_CcNode->parseCode != CC_PC_FF_TCI1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_TCI2) &&
-                        (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPDSCP) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
-                        glblMask)
-                    {
-                        glblMask = FALSE;
-                        p_CcNode->glblMaskSize = 4;
-                        p_CcNode->lclMask = TRUE;
-                    }
-                    break;
-
-                case (e_FM_PCD_EXTRACT_FROM_HDR):
-                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
-                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
-                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
-                    p_CcNode->parseCode =
-                        GetPrParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                       p_CcNode->offset,glblMask,
-                                       &p_CcNode->prsArrayOffset);
-                    break;
-
-                case (e_FM_PCD_EXTRACT_FROM_FIELD):
-                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
-                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
-                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
-                    p_CcNode->parseCode =
-                        GetFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                          p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
-                                          p_CcNode->offset,
-                                          &p_CcNode->prsArrayOffset,
-                                          p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
-                    break;
-
-                default:
-                    DeleteNode(p_CcNode);
-                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-            }
-            break;
-
-        case (e_FM_PCD_EXTRACT_NON_HDR):
-            /* get the field code for the generic extract */
-            p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
-            p_CcNode->offset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
-            p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
-            p_CcNode->parseCode =
-                GetGenParseCode(h_FmPcd,
-                                p_CcNodeParam->extractCcParams.extractNonHdr.src,
-                                p_CcNode->offset,
-                                glblMask,
-                                &p_CcNode->prsArrayOffset,
-                                fromIc,icCode);
-
-            if (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
-            {
-                if ((p_CcNode->offset + p_CcNode->sizeOfExtraction) > 8)
-                {
-                     DeleteNode(p_CcNode);
-                     RETURN_ERROR(MAJOR, E_INVALID_SELECTION,("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
-                }
-            }
-            if ((p_CcNode->parseCode == CC_PC_GENERIC_IC_GMASK) ||
-                (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
-            {
-                p_CcNode->offset +=  p_CcNode->prsArrayOffset;
-                p_CcNode->prsArrayOffset = 0;
-            }
-            break;
-
-       default:
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-    }
-
-    if (p_CcNode->parseCode == CC_PC_ILLEGAL)
-    {
-        DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("illegal extraction type"));
-    }
-
-    if ((p_CcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY) ||
-        !p_CcNode->sizeOfExtraction)
-    {
-        DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("sizeOfExatrction can not be greater than 56 and not 0"));
-    }
-
-    if (p_CcNodeParam->keysParams.keySize != p_CcNode->sizeOfExtraction)
-    {
-        DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
-    }
-
-    p_CcNode->userSizeOfExtraction = p_CcNode->sizeOfExtraction;
-
-    if (!glblMask)
-        memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE  * sizeof(uint8_t));
-
-    err = CheckAndSetManipParamsWithCcNodeParams(p_CcNode);
-    if (err != E_OK)
-    {
-        DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
-    }
-
-    /* Calculating matching table entry size by rounding up the user-defined size of extraction to valid entry size */
-    GetCcExtractKeySize(p_CcNode->sizeOfExtraction, &p_CcNode->ccKeySizeAccExtraction);
-
-    /* If local mask is used, it is stored next to each key in the keys match table */
-    if (p_CcNode->lclMask)
-        keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
-    else
-        keySize = p_CcNode->ccKeySizeAccExtraction;
-
-    /* Update CC shadow with maximal size required by this node */
-    if (p_CcNode->maxNumOfKeys)
-    {
-        err = CalcAndUpdateCcShadow(p_CcNode,
-                                    isKeyTblAlloc,
-                                    &matchTableSize,
-                                    &adTableSize);
-        if (err != E_OK)
-        {
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        }
-
-        p_CcNode->keysMatchTableMaxSize = matchTableSize;
-
-        if (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE)
-        {
-            err = AllocStatsObjs(p_CcNode);
-            if (err != E_OK)
-            {
-                DeleteNode(p_CcNode);
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-            }
-        }
-
-        /* If manipulation will be initialized before this node, it will use the table
-           descriptor in the AD table of previous node and this node will need an extra
-           AD as his table descriptor. */
-        p_CcNode->h_TmpAd = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                                     FM_PCD_CC_AD_ENTRY_SIZE,
-                                                     FM_PCD_CC_AD_TABLE_ALIGN);
-        if (!p_CcNode->h_TmpAd)
-        {
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
-        }
-    }
-    else
-    {
-        matchTableSize = (uint32_t)(keySize * sizeof(uint8_t) * (p_CcNode->numOfKeys + 1));
-        adTableSize    = (uint32_t)(FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNode->numOfKeys + 1));
-    }
-
-#if (DPAA_VERSION >= 11)
-    switch (p_CcNode->statisticsMode)
-    {
-
-        case e_FM_PCD_CC_STATS_MODE_RMON:
-            /* If RMON statistics or RMON conditional statistics modes are requested,
-               allocate frame length ranges array */
-            p_CcNode->h_StatsFLRs =
-                    FM_MURAM_AllocMem(h_FmMuram,
-                                      (uint32_t)(p_CcNode->numOfStatsFLRs) * FM_PCD_CC_STATS_FLR_SIZE,
-                                      FM_PCD_CC_AD_TABLE_ALIGN);
-
-            if (!p_CcNode->h_StatsFLRs)
-            {
-                DeleteNode(p_CcNode);
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC frame length ranges array"));
-            }
-
-            /* Initialize using value received from the user */
-            for (tmp = 0; tmp < p_CcNode->numOfStatsFLRs; tmp++)
-            {
-                h_StatsFLRs = PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
-
-                Mem2IOCpy32(h_StatsFLRs,
-                            &(p_CcNodeParam->keysParams.frameLengthRanges[tmp]),
-                            FM_PCD_CC_STATS_FLR_SIZE);
-            }
-            break;
-
-        default:
-            break;
-    }
-#endif /* (DPAA_VERSION >= 11) */
-
-
-    /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
-       identification, IPv6 hop count identification, etc. */
-    if (isKeyTblAlloc)
-    {
-        p_CcNode->h_KeysMatchTable =
-            (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                        matchTableSize,
-                                        FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
-        if (!p_CcNode->h_KeysMatchTable)
-        {
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
-        }
-        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable,
-                   0,
-                   matchTableSize);
-    }
-
-    /* Allocate action descriptors table */
-    p_CcNode->h_AdTable =
-        (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                    adTableSize,
-                                    FM_PCD_CC_AD_TABLE_ALIGN);
-    if (!p_CcNode->h_AdTable)
-    {
-        DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
-    }
-    IOMemSet32((uint8_t *)p_CcNode->h_AdTable, 0, adTableSize);
-
-    p_KeysMatchTblTmp = p_CcNode->h_KeysMatchTable;
-    p_AdTableTmp      = p_CcNode->h_AdTable;
-
-    /* For each key, create the key and the next step AD */
-    for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
-    {
-        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcNodeInfo->h_CcNode);
 
-        if (p_KeysMatchTblTmp)
-        {
-            /* Copy the key */
-            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_CcNode->sizeOfExtraction);
+        err = CcRootTryLock(p_CcNodeInfo->h_CcNode);
 
-            /* Copy the key mask or initialize it to 0xFF..F */
-            if (p_CcNode->lclMask && p_KeyParams->p_Mask)
-            {
-                Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp,
-                                     p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
-                            p_KeyParams->p_Mask,
-                            p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
-            }
-            else if (p_CcNode->lclMask)
+        if (err)
+        {
+            LIST_FOR_EACH(p_Tmp, &p_CcNode->ccTreesLst)
             {
-                IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
-                                    p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
-                           0xff,
-                           p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
-            }
+                if (p_Tmp == p_Pos)
+                    break;
 
-            p_KeysMatchTblTmp = PTR_MOVE(p_KeysMatchTblTmp, keySize * sizeof(uint8_t));
+                CcRootReleaseLock(p_CcNodeInfo->h_CcNode);
+            }
+            break;
         }
 
-        /* Create the next action descriptor in the match table */
-        if (p_KeyParams->ccNextEngineParams.statisticsEn)
-        {
-            p_StatsObj = GetStatsObj(p_CcNode);
-            ASSERT_COND(p_StatsObj);
+        memset(&nodeInfo, 0, sizeof(t_CcNodeInformation));
+        nodeInfo.h_CcNode = p_CcNodeInfo->h_CcNode;
+        EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo, NULL);
+    }
 
-            statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
-            statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
-#if (DPAA_VERSION >= 11)
-            statsParams.h_StatsFLRs = p_CcNode->h_StatsFLRs;
+    FmPcdUnlock(h_FmPcd, intFlags);
+    CORE_MemoryBarrier();
 
-#endif /* (DPAA_VERSION >= 11) */
-            NextStepAd(p_AdTableTmp,
-                       &statsParams,
-                       &p_KeyParams->ccNextEngineParams,
-                       p_FmPcd);
+    return err;
+}
 
-            p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = p_StatsObj;
-        }
-        else
-        {
-            NextStepAd(p_AdTableTmp,
-                       NULL,
-                       &p_KeyParams->ccNextEngineParams,
-                       p_FmPcd);
+void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
+{
+    t_List              *p_Pos;
+    t_CcNodeInformation *p_CcNodeInfo;
+    t_Handle            h_FmPcdCcTree;
+    uint32_t            intFlags;
 
-            p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = NULL;
-        }
+    intFlags = FmPcdLock(h_FmPcd);
 
-        p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
+        h_FmPcdCcTree = p_CcNodeInfo->h_CcNode;
+        CcRootReleaseLock(h_FmPcdCcTree);
     }
 
-    /* Update next engine for the 'miss' entry */
-    if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.statisticsEn)
-    {
-        p_StatsObj = GetStatsObj(p_CcNode);
-        ASSERT_COND(p_StatsObj);
+    ReleaseLst(p_List);
 
-        /* All 'bucket' nodes of a hash table should share the same statistics counters,
-           allocated by the hash table. So, if this node is a bucket of a hash table,
-           we'll replace the locally allocated counters with the shared counters. */
-        if (p_CcNode->isHashBucket)
-        {
-            ASSERT_COND(p_CcNode->h_MissStatsCounters);
+    FmPcdUnlock(h_FmPcd, intFlags);
+    CORE_MemoryBarrier();
+}
 
-            /* Store original counters pointer and replace it with mutual preallocated pointer */
-            p_CcNode->h_PrivMissStatsCounters = p_StatsObj->h_StatsCounters;
-            p_StatsObj->h_StatsCounters = p_CcNode->h_MissStatsCounters;
-        }
 
-        statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
-        statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
-#if (DPAA_VERSION >= 11)
-        statsParams.h_StatsFLRs = p_CcNode->h_StatsFLRs;
+t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
+{
+    uint32_t    intFlags;
+    uint32_t    newSize = 0, newAlign = 0;
+    bool        allocFail = FALSE;
 
-#endif /* (DPAA_VERSION >= 11) */
+    ASSERT_COND(p_FmPcd);
 
-        NextStepAd(p_AdTableTmp,
-                   &statsParams,
-                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
-                   p_FmPcd);
+    if (!size)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size must be larger then 0"));
 
-        p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = p_StatsObj;
-    }
-    else
-    {
-        NextStepAd(p_AdTableTmp,
-                   NULL,
-                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
-                   p_FmPcd);
+    if (!POWER_OF_2(align))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("alignment must be power of 2"));
 
-        p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = NULL;
-    }
+    newSize  = p_FmPcd->ccShadowSize;
+    newAlign = p_FmPcd->ccShadowAlign;
 
-    /* This parameter will be used to initialize the "key length" field in the action descriptor
-       that points to this node and it should be 0 for full field extraction */
-    if (fullField == TRUE)
-        p_CcNode->sizeOfExtraction = 0;
+    /* Check if current shadow is large enough to hold the requested size */
+    if (size > p_FmPcd->ccShadowSize)
+        newSize = size;
 
-    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, CC_MAX_NUM_OF_KEYS); tmp++)
+    /* Check if current shadow matches the requested alignment */
+    if (align > p_FmPcd->ccShadowAlign)
+        newAlign = align;
+
+    /* If a bigger shadow size or bigger shadow alignment are required,
+       a new shadow will be allocated */
+    if ((newSize != p_FmPcd->ccShadowSize) || (newAlign != p_FmPcd->ccShadowAlign))
     {
-        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        intFlags = FmPcdLock(p_FmPcd);
+
+        if (p_FmPcd->p_CcShadow)
         {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
-            p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccPrevNodesLst,
-                                                        (t_Handle)p_CcNode,
-                                                        p_FmPcdCcNextNode->h_Spinlock);
-            if (!p_CcInformation)
-            {
-                memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
-                ccNodeInfo.index = 1;
-                EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNextNode->ccPrevNodesLst,
-                                             &ccNodeInfo,
-                                             p_FmPcdCcNextNode->h_Spinlock);
-            }
-            else
-                p_CcInformation->index++;
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), p_FmPcd->p_CcShadow);
+            p_FmPcd->ccShadowSize  = 0;
+            p_FmPcd->ccShadowAlign = 0;
+        }
 
-            if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
-            {
-                h_Manip = p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
-                p_CcInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
-                                                             (t_Handle)p_CcNode,
-                                                             FmPcdManipGetSpinlock(h_Manip));
-                if (!p_CcInformation)
-                {
-                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                     ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
-                     ccNodeInfo.index = 1;
-                     EnqueueNodeInfoToRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
-                                                  &ccNodeInfo,
-                                                  FmPcdManipGetSpinlock(h_Manip));
-                }
-                else
-                    p_CcInformation->index++;
-            }
+        p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
+                                                newSize,
+                                                newAlign);
+        if (!p_FmPcd->p_CcShadow)
+        {
+            allocFail = TRUE;
+
+            /* If new shadow size allocation failed,
+               re-allocate with previous parameters */
+            p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
+                                                    p_FmPcd->ccShadowSize,
+                                                    p_FmPcd->ccShadowAlign);
         }
-    }
 
-    p_AdTableTmp = p_CcNode->h_AdTable;
+        FmPcdUnlock(p_FmPcd, intFlags);
 
-    if (!FmPcdLockTryLockAll(h_FmPcd))
-    {
-        FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
-        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
-        return ERROR_CODE(E_BUSY);
+        if (allocFail)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Shadow memory"));
+
+        p_FmPcd->ccShadowSize  = newSize;
+        p_FmPcd->ccShadowAlign = newAlign;
     }
 
-    /* Required action for each next engine */
-    for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, CC_MAX_NUM_OF_KEYS); tmp++)
+    return E_OK;
+}
+
+#if (DPAA_VERSION >= 11)
+void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
+                                              t_Handle  h_ReplicGroup,
+                                              t_List    *p_AdTables,
+                                              uint32_t  *p_NumOfAdTables)
+{
+    t_FmPcdCcNode           *p_CurrentNode = (t_FmPcdCcNode *)h_Node;
+    int                     i = 0;
+    void *                  p_AdTable;
+    t_CcNodeInformation     ccNodeInfo;
+
+    ASSERT_COND(h_Node);
+    *p_NumOfAdTables = 0;
+
+    /* search in the current node which exact index points on this current replicator group for getting AD */
+    for (i = 0; i < p_CurrentNode->numOfKeys + 1; i++)
     {
-        if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
+        if ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic == (t_Handle)h_ReplicGroup)))
         {
-            err = SetRequiredAction(h_FmPcd,
-                                    p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
-                                    &p_CcNode->keyAndNextEngineParams[tmp],
-                                    p_AdTableTmp,
-                                    1,
-                                    NULL);
-            if (err)
-            {
-                FmPcdLockUnlockAll(h_FmPcd);
-                FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-            }
-            p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+            /* save the current ad table in the list */
+            /* this entry uses the input replicator group */
+            p_AdTable = PTR_MOVE(p_CurrentNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+            memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+            ccNodeInfo.h_CcNode = p_AdTable;
+            EnqueueNodeInfoToRelevantLst(p_AdTables, &ccNodeInfo, NULL);
+            (*p_NumOfAdTables)++;
         }
     }
 
-    FmPcdLockUnlockAll(h_FmPcd);
-
-    return E_OK;
+    ASSERT_COND(i != p_CurrentNode->numOfKeys);
 }
+#endif /* (DPAA_VERSION >= 11) */
 /*********************** End of inter-module routines ************************/
 
 
@@ -5947,7 +5964,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     }
     memset(p_CcNode, 0, sizeof(t_FmPcdCcNode));
 
-    err = FmPcdCcMatchTableSet(h_FmPcd, p_CcNode, p_CcNodeParam);
+    err = MatchTableSet(h_FmPcd, p_CcNode, p_CcNodeParam);
 
     switch (GET_ERROR_TYPE(err))
     {
@@ -6794,7 +6811,7 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         p_CcNode->isHashBucket = TRUE;
         p_CcNode->h_MissStatsCounters = h_MissStatsCounters;
 
-        err = FmPcdCcMatchTableSet(h_FmPcd, p_CcNode, p_ExactMatchCcNodeParam);
+        err = MatchTableSet(h_FmPcd, p_CcNode, p_ExactMatchCcNodeParam);
         if (err)
             break;
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
index 997eb5d..ab2e50c 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
@@ -394,7 +394,6 @@ typedef struct
 } t_FmPcdCcTree;
 
 
-bool        FmPcdManipIsManipNode(t_Handle h_Ad);
 t_Error     FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List);
 void        FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List);
 t_Error     FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
index a55bb25..1027783 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
@@ -1366,7 +1366,7 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
         case (1):
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate TNUM"));
         case (2):
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer from the HC-Port"));
         case (3):
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("'Disable Timeout Task' with invalid IPRCPT"));
         case (4):
@@ -1631,34 +1631,34 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
 
     if (p_Manip->updateParams)
     {
-        if ((!(p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))) ||
-            ((p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))))
+        if ((!(p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))) ||
+            ((p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
         fmPortGetSetCcParams.setCcParams.type = 0;
-        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams | FM_REV;
         if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))
+        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK | FM_REV))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
     }
     else if (validate)
     {
-        if ((!(p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))) ||
-            ((p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))))
+        if ((!(p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))) ||
+            ((p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
 
         fmPortGetSetCcParams.setCcParams.type = 0;
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
         if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))
+        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
     }
 
     if (p_Manip->updateParams)
     {
-        if (p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))
+        if (p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
         {
             t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
             uint8_t     *p_Ptr, i, totalNumOfTnums;
@@ -1693,8 +1693,8 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
                        ((uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)) - p_FmPcd->physicalMuramBase));
             WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->internalBufferManagement, tmpReg32);
 
-            p_Manip->updateParams &= ~(NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
-            p_Manip->shadowUpdateParams |= (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
+            p_Manip->updateParams &= ~(NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK);
+            p_Manip->shadowUpdateParams |= (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK);
         }
     }
 
@@ -1710,12 +1710,6 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
     }
 
 #if (DPAA_VERSION >= 11)
-    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
-    fmPortGetSetCcParams.setCcParams.type = 0;
-    fmPortGetSetCcParams.getCcParams.type = FM_REV;
-    if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
     if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev >= 6)
     {
         if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage)) != E_OK)
@@ -1738,6 +1732,12 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
             WRITE_UINT32(p_ParamsPage->iprIpv6Nia, tmpReg32);
         }
     }
+#else
+    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev < 6)
+    {
+        WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->discardMask,
+                     fmPortGetSetCcParams.getCcParams.discardMask);
+    }
 #endif /* (DPAA_VERSION >= 11) */
 
     return E_OK;
@@ -2561,7 +2561,7 @@ static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, bool ipv4)
 
     /* Sets the second Ad register (matchTblPtr) - Buffer pool ID (BPID for V2) and Scatter/Gather table offset*/
     /* mark the Scatter/Gather table offset to be set later on when the port will be known */
-    p_Manip->updateParams = (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
+    p_Manip->updateParams = (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK);
 
 #if (DPAA_VERSION == 10)
     tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.sgBpid << 8);
@@ -4142,7 +4142,7 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
         FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
     }
 
-    if (p_Manip->p_Hmct && MANIP_IS_UNIFIED_FIRST(p_Manip))
+    if (p_Manip->p_Hmct && (MANIP_IS_UNIFIED_FIRST(p_Manip) || !MANIP_IS_UNIFIED(p_Manip)))
         FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_Hmct);
 
     if (p_Manip->h_Spinlock)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
index 2ab9b15..f770c0f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
@@ -333,7 +333,7 @@ typedef _Packed struct t_IpReassCommonTbl {
     volatile uint32_t totalSgFragmentCounter;
     volatile uint32_t totalDmaSemaphoreDepletionCounter;
     volatile uint32_t totalNCSPCounter;
-    volatile uint32_t reserved3[1];
+    volatile uint32_t discardMask;
 } _PackedType t_IpReassCommonTbl;
 
 typedef _Packed struct t_Hmtd {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c
index ae72b25..7f84080 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c
@@ -454,6 +454,7 @@ static t_Error RemoveMember(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
 
     p_FmPcd         = p_ReplicGroup->h_FmPcd;
     ASSERT_COND(p_FmPcd);
+    UNUSED(p_FmPcd);
 
     p_CurrentMember = GetMemberByIndex(p_ReplicGroup, memberIndex);
     ASSERT_COND(p_CurrentMember);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/Makefile
index f8dbc8a..c94c54c 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/Makefile
@@ -12,4 +12,4 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-Pcd.o
 
-fsl-ncsw-Pcd-objs	:=   fm_port.o fm_port_im.o
+fsl-ncsw-Pcd-objs	:=   fm_port.o fm_port_im.o fman_port.o
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index b2dbcac..edb86f6 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -43,8 +43,10 @@
 #include "debug_ext.h"
 #include "fm_muram_ext.h"
 
+#include "fman_common.h"
 #include "fm_port.h"
 
+#include "common/general.h"
 
 /****************************************/
 /*       static functions               */
@@ -53,13 +55,14 @@
 static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 {
     t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
+    struct fman_port_cfg    *p_DfltConfig = &p_Params->dfltCfg;
     t_Error             ans = E_OK;
     uint32_t            unusedMask;
 
     if (p_FmPort->imEn)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-            if (p_FmPort->fifoDeqPipelineDepth > 2)
+            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for IM 10G can't be larger than 2"));
 
         if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
@@ -70,20 +73,24 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx only                            */
         /****************************************/
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+            (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         {
             /* external buffer pools */
             if (!p_Params->extBufPools.numOfPoolsUsed)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
 
-            if (FmSpCheckBufPoolsParams(&p_Params->extBufPools, p_Params->p_BackupBmPools, &p_Params->bufPoolDepletion)!= E_OK)
+            if (FmSpCheckBufPoolsParams(&p_Params->extBufPools,
+                                        p_Params->p_BackupBmPools,
+                                        &p_Params->bufPoolDepletion)!= E_OK)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
             /* Check that part of IC that needs copying is small enough to enter start margin */
             if (p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
 
-            if (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK)
+            if ((p_Params->liodnOffset != DPAA_LIODN_DONT_OVERRIDE) &&
+                (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
 
 #ifdef FM_NO_BACKUP_POOLS
@@ -102,15 +109,18 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", FM_MAX_NUM_OF_SUB_PORTALS));
 
             /* to protect HW internal-context from overwrite */
-            if ((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
+            if ((p_Params->intContext.size) &&
+                (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
 
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
-                    /* in O/H DEFAULT_notSupported indicates that it is not suppported and should not be checked */
-                    || (p_FmPort->fifoDeqPipelineDepth != DEFAULT_notSupported))
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
+                (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+                    /* in O/H DEFAULT_notSupported indicates that it is not supported and should not be checked */
+                    || (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth != DEFAULT_notSupported))
             {
                 /* Check that not larger than 8 */
-                if ((!p_FmPort->fifoDeqPipelineDepth) ||( p_FmPort->fifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
+                if ((!p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth) ||
+                    ( p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth > MAX_FIFO_PIPELINE_DEPTH))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
             }
         }
@@ -118,9 +128,10 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx Or Offline Parsing              */
         /****************************************/
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+            (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         {
-
             if (!p_Params->dfltFqid)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
 #if defined(FM_CAPWAP_SUPPORT) && defined(FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004)
@@ -146,18 +157,17 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
-        /* Check that divisible by 256 and not larger than 256 */
-        if (p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
+        if (p_DfltConfig->rx_pri_elevation % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if (!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-        if (p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
+        if ((p_DfltConfig->rx_pri_elevation < BMI_FIFO_UNITS) || (p_DfltConfig->rx_pri_elevation > MAX_PORT_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+        if (p_DfltConfig->rx_fifo_thr % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
-        if (!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+        if ((p_DfltConfig->rx_fifo_thr < BMI_FIFO_UNITS) ||(p_DfltConfig->rx_fifo_thr > MAX_PORT_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
 
         /* Check that not larger than 16 */
-        if (p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
+        if (p_DfltConfig->rx_cut_end_bytes > FRAME_END_DATA_SIZE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
 
         if (FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
@@ -174,7 +184,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         if (p_FmPort->fmRevInfo.majorRev == 4)
         {
             /* Check that not larger than 16 */
-            if (p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+            if (p_DfltConfig->rx_cut_end_bytes + p_DfltConfig->checksum_bytes_ignore > FRAME_END_DATA_SIZE)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
         }
 #endif /* FM_CSI_CFED_LIMIT */
@@ -193,18 +203,17 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
-        /* Check that divisible by 256 and not larger than 256 */
-        if (p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
+        if (p_DfltConfig->tx_fifo_min_level % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if (p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", BMI_MAX_FIFO_SIZE));
-        if (p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
+        if (p_DfltConfig->tx_fifo_min_level > (MAX_PORT_FIFO_SIZE - 256))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", (MAX_PORT_FIFO_SIZE - 256)));
+        if (p_DfltConfig->tx_fifo_low_comf_level % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if (!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+        if ((p_DfltConfig->tx_fifo_low_comf_level < BMI_FIFO_UNITS) || (p_DfltConfig->tx_fifo_low_comf_level > MAX_PORT_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_TX)
-            if (p_FmPort->fifoDeqPipelineDepth > 2)
+            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
     }
 
@@ -212,7 +221,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /*   Non Tx Ports                       */
     /****************************************/
     /* If discard override was selected , no frames may be discarded. */
-    else if (p_Params->frmDiscardOverride && p_Params->errorsToDiscard)
+    else if (p_DfltConfig->discard_override && p_Params->errorsToDiscard)
         RETURN_ERROR(MAJOR, E_CONFLICT,
                      ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
 
@@ -260,17 +269,18 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
         if ((!((p_FmPort->fmRevInfo.majorRev == 4) ||
                (p_FmPort->fmRevInfo.majorRev >= 6))) &&
-            (p_FmPort->fifoDeqPipelineDepth != DEFAULT_notSupported))
+            (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth != DEFAULT_notSupported))
                 /* this is an indication that user called config for this mode which is not supported in this integration */
                 RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
     }
+
     /****************************************/
     /*   All ports                          */
     /****************************************/
-
     /* Check that not larger than 16 */
-    if ((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
+    if ((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) &&
+        ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
 
     if (FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
@@ -285,8 +295,8 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
     if (p_Params->setNumOfOpenDmas && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    if (p_Params->setSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+    if (p_Params->setSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > MAX_PORT_FIFO_SIZE)))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
     if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
 
@@ -302,7 +312,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
 static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 {
-    uint32_t                minFifoSizeRequired = 0;
+    uint32_t    minFifoSizeRequired = 0, optFifoSizeForB2B = 0;
 
     /*************************/
     /*    TX PORTS           */
@@ -310,19 +320,20 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
-        minFifoSizeRequired = (uint32_t)DIV_CEIL(p_FmPort->maxFrameLength, BMI_FIFO_UNITS);
-        if (p_FmPort->imEn)
-            minFifoSizeRequired += 3*BMI_FIFO_UNITS;
-        else
-            minFifoSizeRequired += (p_FmPort->fifoDeqPipelineDepth+3)*BMI_FIFO_UNITS;
+        minFifoSizeRequired = (uint32_t)
+            (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + (3*BMI_FIFO_UNITS));
+        if (!p_FmPort->imEn)
+            minFifoSizeRequired += p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth * BMI_FIFO_UNITS;
 
-        /* add some margin for back to back capability to improve performance
-         * allows the hardware to pipeline new frame dma while the previous
-         * frame not yet transmitted. */
+        optFifoSizeForB2B = minFifoSizeRequired;
+
+        /* Add some margin for back-to-back capability to improve performance,
+           allows the hardware to pipeline new frame dma while the previous
+           frame not yet transmitted. */
         if (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
-            minFifoSizeRequired += 3*BMI_FIFO_UNITS;
+            optFifoSizeForB2B += 3*BMI_FIFO_UNITS;
         else
-            minFifoSizeRequired += 2*BMI_FIFO_UNITS;
+            optFifoSizeForB2B += 2*BMI_FIFO_UNITS;
     }
 
     /*************************/
@@ -331,8 +342,10 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
     else if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
              p_FmPort->imEn)
-        minFifoSizeRequired = (uint32_t)(DIV_CEIL(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) +
-                                         (4*BMI_FIFO_UNITS));
+    {
+        optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)
+            (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + (4*BMI_FIFO_UNITS));
+    }
 
     /*************************/
     /*    RX non-IM PORTS    */
@@ -341,52 +354,61 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
              !p_FmPort->imEn)
     {
-#ifdef FM_FIFO_ALLOCATION_ALG
         if (p_FmPort->fmRevInfo.majorRev == 4)
         {
             if (p_FmPort->rxPoolsParams.numOfPools == 1)
                 minFifoSizeRequired = 8*BMI_FIFO_UNITS;
             else
-                minFifoSizeRequired = (uint32_t)(DIV_CEIL(p_FmPort->rxPoolsParams.secondLargestBufSize, BMI_FIFO_UNITS) +
-                                                 (7*BMI_FIFO_UNITS));
+                minFifoSizeRequired = (uint32_t)
+                    (ROUND_UP(p_FmPort->rxPoolsParams.secondLargestBufSize, BMI_FIFO_UNITS) + (7*BMI_FIFO_UNITS));
         }
         else
-#endif /* FM_FIFO_ALLOCATION_ALG */
-            minFifoSizeRequired = (uint32_t)(DIV_CEIL(p_FmPort->rxPoolsParams.largestBufSize, BMI_FIFO_UNITS) +
-                                             (7*BMI_FIFO_UNITS));
+        {
+#if (DPAA_VERSION >= 11)
+            minFifoSizeRequired = (uint32_t)
+                (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + (5*BMI_FIFO_UNITS));
+                /* 4 according to spec + 1 for FOF>0 */
+#else
+            minFifoSizeRequired = (uint32_t)
+                (ROUND_UP(MIN(p_FmPort->maxFrameLength, p_FmPort->rxPoolsParams.largestBufSize), BMI_FIFO_UNITS)
+                 + (7*BMI_FIFO_UNITS));
+#endif /* (DPAA_VERSION >= 11) */
+        }
+
+        optFifoSizeForB2B = minFifoSizeRequired;
 
+        /* Add some margin for back-to-back capability to improve performance,
+           allows the hardware to pipeline new frame dma while the previous
+           frame not yet transmitted. */
         if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-            minFifoSizeRequired += 12*BMI_FIFO_UNITS;
+            optFifoSizeForB2B += 8*BMI_FIFO_UNITS;
         else
-            minFifoSizeRequired += 3*BMI_FIFO_UNITS;
+            optFifoSizeForB2B += 3*BMI_FIFO_UNITS;
     }
 
     /* For O/H ports, check fifo size and update if necessary */
     else if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
              (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        minFifoSizeRequired = (uint32_t)((p_FmPort->tasks.num + 4)*BMI_FIFO_UNITS);
-
-    /* for all ports - verify size  */
-    if (minFifoSizeRequired && (p_FmPort->fifoBufs.num < minFifoSizeRequired))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("User defined FIFO size should be enlarged to %d",
-                      minFifoSizeRequired));
-
-    /* check if pool size is not too big */
-    /* This is a definition problem in which if the fifo for the RX port
-       is lower than the largest pool size the hardware will allocate scatter gather
-       buffers even though the frame size can fit in a single buffer. */
-    if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-         (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-        && !p_FmPort->imEn)
     {
-        if (p_FmPort->rxPoolsParams.largestBufSize > p_FmPort->fifoBufs.num)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                         ("Frame larger than port Fifo size (%u) will be split to more "\
-                          "than a single buffer (S/G) even if shorter than largest buffer size (%u)",
-                          p_FmPort->fifoBufs.num, p_FmPort->rxPoolsParams.largestBufSize));
+#if (DPAA_VERSION >= 11)
+        optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)
+            (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + ((p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth + 5) * BMI_FIFO_UNITS));
+            /* 4 according to spec + 1 for FOF>0 */
+#else
+        optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)((p_FmPort->tasks.num + 2) * BMI_FIFO_UNITS);
+#endif /* (DPAA_VERSION >= 11) */
     }
 
+    ASSERT_COND(minFifoSizeRequired > 0);
+    ASSERT_COND(optFifoSizeForB2B >= minFifoSizeRequired);
+
+    /* Verify the size  */
+    if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
+        DBG(INFO, ("FIFO size is %d and should be enlarged to %d bytes", p_FmPort->fifoBufs.num, minFifoSizeRequired));
+    else if (p_FmPort->fifoBufs.num < optFifoSizeForB2B)
+        DBG(INFO, ("For back-to-back frames processing, FIFO size may need to be enlarged to %d bytes", optFifoSizeForB2B));
+
+
     return E_OK;
 }
 
@@ -403,75 +425,44 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 {
     t_FmExtPools                *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
     t_FmBufPoolDepletion        *p_BufPoolDepletion = &p_FmPort->p_FmPortDriverParam->bufPoolDepletion;
-    volatile uint32_t           *p_ExtBufRegs;
-    volatile uint32_t           *p_BufPoolDepletionReg;
-    bool                        rxPort;
     uint8_t                     orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
     uint16_t                    sizesArray[BM_MAX_NUM_OF_POOLS];
-    uint8_t                     numOfPools;
-    int                         i=0, j=0;
-    uint32_t                    tmpReg, vector;
+    int                         i=0, j=0, err;
+    struct fman_port_bpools     bpools;
 
     memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
     memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
     memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmExtPools));
 
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi;
-            p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rmpd;
-            rxPort = TRUE;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi;
-            p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ompd;
-            rxPort = FALSE;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for port type"));
-    }
-
     FmSpSetBufPoolsInAscOrderOfBufSizes(p_ExtBufPools, orderedArray, sizesArray);
 
-    /* build the register value */
-    for (i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
+    /* Prepare flibs bpools structure */
+    memset(&bpools, 0, sizeof(struct fman_port_bpools));
+    bpools.count = p_ExtBufPools->numOfPoolsUsed;
+    bpools.counters_enable = TRUE;
+    for (i=0; i<p_ExtBufPools->numOfPoolsUsed; i++)
     {
-        tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
-        tmpReg |= ((uint32_t)orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
-        tmpReg |= sizesArray[orderedArray[i]];
-        /* functionality available only for some deriviatives (limited by config) */
+        bpools.bpool[i].bpid = orderedArray[i];
+        bpools.bpool[i].size = sizesArray[orderedArray[i]];
+         /* functionality available only for some derivatives (limited by config) */
         if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-            for (j=0;j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;j++)
+            for (j=0; j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools; j++)
                 if (orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
                 {
-                    tmpReg |= BMI_EXT_BUF_POOL_BACKUP;
+                    bpools.bpool[i].is_backup = TRUE;
                     break;
                 }
-        WRITE_UINT32(*(p_ExtBufRegs+i), tmpReg);
     }
 
-    if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-        XX_Free(p_FmPort->p_FmPortDriverParam->p_BackupBmPools);
-
-    numOfPools = (uint8_t)(rxPort ? FM_PORT_MAX_NUM_OF_EXT_POOLS:FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS);
-
-    /* clear unused pools */
-    for (i=p_ExtBufPools->numOfPoolsUsed;i<numOfPools;i++)
-        WRITE_UINT32(*(p_ExtBufRegs+i), 0);
-
     /* save pools parameters for later use */
     p_FmPort->rxPoolsParams.numOfPools = p_ExtBufPools->numOfPoolsUsed;
     p_FmPort->rxPoolsParams.largestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-1]];
     p_FmPort->rxPoolsParams.secondLargestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-2]];
 
     /* FMBM_RMPD reg. - pool depletion */
-    tmpReg = 0;
     if (p_BufPoolDepletion->poolsGrpModeEnable)
     {
-        /* calculate vector for number of pools depletion */
-        vector = 0;
+        bpools.grp_bp_depleted_num = p_BufPoolDepletion->numOfPools;
         for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
             if (p_BufPoolDepletion->poolsToConsider[i])
@@ -480,21 +471,16 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
                 {
                     if (i == orderedArray[j])
                     {
-                        vector |= 0x80000000 >> j;
+                        bpools.bpool[j].grp_bp_depleted = TRUE;
                         break;
                     }
                 }
             }
         }
-        /* configure num of pools and vector for number of pools mode */
-        tmpReg |= (((uint32_t)p_BufPoolDepletion->numOfPools - 1) << BMI_POOL_DEP_NUM_OF_POOLS_SHIFT);
-        tmpReg |= vector;
     }
 
     if (p_BufPoolDepletion->singlePoolModeEnable)
     {
-        /* calculate vector for number of pools depletion */
-        vector = 0;
         for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
             if (p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
@@ -503,13 +489,12 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
                 {
                     if (i == orderedArray[j])
                      {
-                        vector |= 0x00000080 >> j;
+                        bpools.bpool[j].single_bp_depleted = TRUE;
                         break;
                     }
                 }
             }
         }
-        tmpReg |= vector;
     }
 
 #if (DPAA_VERSION >= 11)
@@ -517,19 +502,23 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     if (p_BufPoolDepletion->poolsGrpModeEnable ||
         p_BufPoolDepletion->singlePoolModeEnable)
     {
-        vector = 0;
         for (i=0; i<FM_MAX_NUM_OF_PFC_PRIORITIES; i++)
         {
             if (p_BufPoolDepletion->pfcPrioritiesEn[i] == TRUE)
             {
-                vector |= 0x00008000 >> i;
+                bpools.bpool[i].pfc_priorities_en = TRUE;
             }
         }
-        tmpReg |= vector;
     }
 #endif /* (DPAA_VERSION >= 11) */
 
-    WRITE_UINT32(*p_BufPoolDepletionReg, tmpReg);
+    /* Issue flibs function */
+    err = fman_port_set_bpools(&p_FmPort->port, &bpools);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_bpools"));
+
+    if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+        XX_Free(p_FmPort->p_FmPortDriverParam->p_BackupBmPools);
 
     return E_OK;
 }
@@ -544,749 +533,319 @@ static t_Error ClearPerfCnts(t_FmPort *p_FmPort)
     return E_OK;
 }
 
-static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
+
+static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
 {
-    t_FmPortRxBmiRegs       *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
-    uint32_t                tmpReg;
-    t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
-    uint32_t                errorsToEnq = 0;
-    t_FmPortPerformanceCnt  performanceContersParams;
+    t_FmPortDriverParam     *p_DriverParams = p_FmPort->p_FmPortDriverParam;
+    struct fman_port_params portParams;
+    uint32_t                tmpVal;
     t_Error                 err;
 
-    /* check that port is not busy */
-    if (GET_UINT32(p_Regs->fmbm_rcfg) & BMI_PORT_CFG_EN)
-         RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                      ("Port(%d,%d) is already enabled",p_FmPort->portType, p_FmPort->portId));
-
-    /* Set Config register */
-    tmpReg = 0;
-    if (p_FmPort->imEn)
-        tmpReg |= BMI_PORT_CFG_IM;
-    /* No discard - all error frames go to error queue */
-    else if (p_Params->frmDiscardOverride)
-        tmpReg |= BMI_PORT_CFG_FDOVR;
-
-    WRITE_UINT32(p_Regs->fmbm_rcfg, tmpReg);
-
-    /* Configure dma attributes */
-    tmpReg = 0;
-    tmpReg |= (uint32_t)p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
-    tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
-    tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
-    tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
-    if (p_Params->dmaWriteOptimize)
-        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
-
-    WRITE_UINT32(p_Regs->fmbm_rda, tmpReg);
-
-    /* Configure Rx Fifo params */
-    tmpReg = 0;
-    tmpReg |= ((p_Params->rxFifoPriElevationLevel/BMI_FIFO_UNITS - 1) << BMI_RX_FIFO_PRI_ELEVATION_SHIFT);
-    tmpReg |= ((p_Params->rxFifoThreshold/BMI_FIFO_UNITS - 1) << BMI_RX_FIFO_THRESHOLD_SHIFT);
-
-    WRITE_UINT32(p_Regs->fmbm_rfp, tmpReg);
-
-#ifdef FM_NO_RESTRICT_ON_ACCESS_RSRC
-    if (p_FmPort->fmRevInfo.majorRev < 6)
-        /* always allow access to the extra resources */
-        WRITE_UINT32(p_Regs->fmbm_reth, BMI_RX_FIFO_THRESHOLD_BC);
-#endif /* FM_NO_RESTRICT_ON_ACCESS_RSRC */
-
-     /* frame end parameters */
-    tmpReg = 0;
-    tmpReg |= ((uint32_t)p_Params->cheksumLastBytesIgnore << BMI_RX_FRAME_END_CS_IGNORE_SHIFT);
-    tmpReg |= ((uint32_t)p_Params->cutBytesFromEnd<< BMI_RX_FRAME_END_CUT_SHIFT);
-#ifdef FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
-    /* zero cutBytesFromEnd field which means that bmi doesn't
-       remove further bytes because the MAC already remove the CRC.
-       the workaround is relevant only in initial rev of FMan v3.
-     */
-    if ((p_FmPort->fmRevInfo.majorRev == 6) && (p_FmPort->fmRevInfo.minorRev == 0))
-        tmpReg &= 0xffe0ffff;
-#endif /* FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320 */
-    WRITE_UINT32(p_Regs->fmbm_rfed, tmpReg);
-
-    /* IC parameters */
-    tmpReg = 0;
-    tmpReg |= (((uint32_t)p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
-    tmpReg |= (((uint32_t)p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
-    tmpReg |= (((uint32_t)p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
-
-    WRITE_UINT32(p_Regs->fmbm_ricp, tmpReg);
-
-    if (!p_FmPort->imEn)
-    {
-        /* Call the external Buffer routine which also checks fifo
-           size and updates it if necessary */
-        /* define external buffer pools and pool depletion*/
-
-        /* check if the largest external buffer pool is large enough */
-        if ((p_Params->bufMargins.startMargins +
-             MIN_EXT_BUF_SIZE +
-             p_Params->bufMargins.endMargins) > p_FmPort->rxPoolsParams.largestBufSize)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                         ("bufMargins.startMargins (%d) + minimum buf size (64) + "
-                          "bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
-                            p_Params->bufMargins.startMargins,
-                            p_Params->bufMargins.endMargins,
-                            p_FmPort->rxPoolsParams.largestBufSize));
-
-        /* buffer margins */
-        tmpReg = 0;
-        tmpReg |= (((uint32_t)p_Params->bufMargins.startMargins) << BMI_EXT_BUF_MARG_START_SHIFT);
-        tmpReg |= (((uint32_t)p_Params->bufMargins.endMargins) << BMI_EXT_BUF_MARG_END_SHIFT);
-#if (DPAA_VERSION >= 11)
-        if (p_Params->noScatherGather)
-            tmpReg |= BMI_SG_DISABLE;
-#endif
-        WRITE_UINT32(p_Regs->fmbm_rebm, tmpReg);
-    }
-
-    if (p_FmPort->internalBufferOffset)
-    {
-        tmpReg = (uint32_t)((p_FmPort->internalBufferOffset%OFFSET_UNITS) ?
-                            (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1) :
-                            (p_FmPort->internalBufferOffset/OFFSET_UNITS));
-        p_FmPort->internalBufferOffset = (uint8_t)(tmpReg * OFFSET_UNITS);
-        WRITE_UINT32(p_Regs->fmbm_rim, tmpReg << BMI_IM_FOF_SHIFT);
-    }
+    /* Set up flibs parameters and issue init function */
 
-    /* NIA */
-    if (p_FmPort->imEn)
-        WRITE_UINT32(p_Regs->fmbm_rfne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_RX);
-    else
-    {
-        tmpReg = 0;
-        if (p_Params->forwardReuseIntContext)
-            tmpReg |= BMI_PORT_RFNE_FRWD_RPD;
-        /* L3/L4 checksum verify is enabled by default. */
-        /*tmpReg |= BMI_PORT_RFNE_FRWD_DCL4C;*/
-        WRITE_UINT32(p_Regs->fmbm_rfne, tmpReg | GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
-    }
-    WRITE_UINT32(p_Regs->fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
-
-    /* command attribute */
-    tmpReg = BMI_CMD_RX_MR_DEF;
-    if (!p_FmPort->imEn)
+    memset(&portParams, 0, sizeof(struct fman_port_params));
+    portParams.discard_mask = p_DriverParams->errorsToDiscard;
+    portParams.dflt_fqid = p_DriverParams->dfltFqid;
+    portParams.err_fqid = p_DriverParams->errFqid;
+    portParams.deq_sp = p_DriverParams->deqSubPortal;
+    portParams.dont_release_buf = p_DriverParams->dontReleaseBuf;
+    switch (p_FmPort->portType)
     {
-        tmpReg |= BMI_CMD_ATTR_ORDER;
-        if (p_Params->syncReq)
-            tmpReg |= BMI_CMD_ATTR_SYNC;
-        tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
-    }
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            portParams.err_mask = (RX_ERRS_TO_ENQ & ~portParams.discard_mask);
+            if (!p_FmPort->imEn)
+            {
+                if (p_DriverParams->forwardReuseIntContext)
+                    p_DriverParams->dfltCfg.rx_fd_bits = (uint8_t)(BMI_PORT_RFNE_FRWD_RPD >> 24);
+            }
+            break;
 
-    WRITE_UINT32(p_Regs->fmbm_rfca, tmpReg);
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            portParams.err_mask = (OP_ERRS_TO_ENQ & ~portParams.discard_mask);
+            break;
+            break;
 
-    /* default queues */
-    if (!p_FmPort->imEn)
-    {
-        WRITE_UINT32(p_Regs->fmbm_rfqid, p_Params->dfltFqid);
-        WRITE_UINT32(p_Regs->fmbm_refqid, p_Params->errFqid);
+        default:
+            break;
     }
 
-    /* set counters */
-    WRITE_UINT32(p_Regs->fmbm_rstc, BMI_COUNTERS_EN);
-
-    performanceContersParams.taskCompVal    = (uint8_t)p_FmPort->tasks.num;
-    performanceContersParams.queueCompVal   = 1;
-    performanceContersParams.dmaCompVal     =(uint8_t) p_FmPort->openDmas.num;
-    performanceContersParams.fifoCompVal    = p_FmPort->fifoBufs.num;
-    if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    WRITE_UINT32(p_Regs->fmbm_rpc, BMI_COUNTERS_EN);
-
-    /* error/status mask  - check that if discard OV is set, no
-       discard is required for specific errors.*/
-    WRITE_UINT32(p_Regs->fmbm_rfsdm, p_Params->errorsToDiscard);
-
-    errorsToEnq = (RX_ERRS_TO_ENQ & ~p_Params->errorsToDiscard);
-    WRITE_UINT32(p_Regs->fmbm_rfsem, errorsToEnq);
-
-    return E_OK;
-}
-
-static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
-{
-    t_FmPortTxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
-    uint32_t            tmpReg;
-    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
-    /*uint32_t            rateCountUnit;*/
-    t_FmPortPerformanceCnt  performanceContersParams;
-
-    /* check that port is not busy */
-    if (GET_UINT32(p_Regs->fmbm_tcfg) & BMI_PORT_CFG_EN)
-         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
-
-    tmpReg = 0;
-    if (p_FmPort->imEn)
-        tmpReg |= BMI_PORT_CFG_IM;
-
-    WRITE_UINT32(p_Regs->fmbm_tcfg, tmpReg);
-
-    /* Configure dma attributes */
-    tmpReg = 0;
-    tmpReg |= (uint32_t)p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
-    tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
-    tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
-    tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+    tmpVal = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
+                        (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
+                        (p_FmPort->internalBufferOffset/OFFSET_UNITS));
+    p_FmPort->internalBufferOffset = (uint8_t)(tmpVal * OFFSET_UNITS);
+    p_DriverParams->dfltCfg.int_buf_start_margin = p_FmPort->internalBufferOffset;
 
-    WRITE_UINT32(p_Regs->fmbm_tda, tmpReg);
+    p_DriverParams->dfltCfg.ext_buf_start_margin = p_DriverParams->bufMargins.startMargins;
+    p_DriverParams->dfltCfg.ext_buf_end_margin = p_DriverParams->bufMargins.endMargins;
 
-    /* Configure Tx Fifo params */
-    tmpReg = 0;
-    tmpReg |= ((p_Params->txFifoMinFillLevel/BMI_FIFO_UNITS) << BMI_TX_FIFO_MIN_FILL_SHIFT);
-    tmpReg |= (((uint32_t)p_FmPort->fifoDeqPipelineDepth - 1) << BMI_FIFO_PIPELINE_DEPTH_SHIFT);
-    tmpReg |= ((p_Params->txFifoLowComfLevel/BMI_FIFO_UNITS - 1) << BMI_TX_LOW_COMF_SHIFT);
+    p_DriverParams->dfltCfg.ic_ext_offset = p_DriverParams->intContext.extBufOffset;
+    p_DriverParams->dfltCfg.ic_int_offset = p_DriverParams->intContext.intContextOffset;
+    p_DriverParams->dfltCfg.ic_size = p_DriverParams->intContext.size;
 
-    WRITE_UINT32(p_Regs->fmbm_tfp, tmpReg);
+    p_DriverParams->dfltCfg.stats_counters_enable = TRUE;
+    p_DriverParams->dfltCfg.perf_counters_enable = TRUE;
+    p_DriverParams->dfltCfg.queue_counters_enable = TRUE;
 
-    /* frame end parameters */
-    tmpReg = 0;
-    tmpReg |= ((uint32_t)p_Params->cheksumLastBytesIgnore << BMI_FRAME_END_CS_IGNORE_SHIFT);
-
-    WRITE_UINT32(p_Regs->fmbm_tfed, tmpReg);
-
-    if (!p_FmPort->imEn)
-    {
-        /* IC parameters */
-        tmpReg = 0;
-        tmpReg |= (((uint32_t)p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
-        tmpReg |= (((uint32_t)p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
-        tmpReg |= (((uint32_t)p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+    p_DriverParams->dfltCfg.perf_cnt_params.task_val    = (uint8_t)p_FmPort->tasks.num;
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
+        p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+        p_DriverParams->dfltCfg.perf_cnt_params.queue_val   = 0;
+    else
+        p_DriverParams->dfltCfg.perf_cnt_params.queue_val   = 1;
+    p_DriverParams->dfltCfg.perf_cnt_params.dma_val     =(uint8_t) p_FmPort->openDmas.num;
+    p_DriverParams->dfltCfg.perf_cnt_params.fifo_val    = p_FmPort->fifoBufs.num;
 
-        WRITE_UINT32(p_Regs->fmbm_ticp, tmpReg);
-    }
+    if (0 != fman_port_init(&p_FmPort->port, &p_DriverParams->dfltCfg, &portParams))
+        RETURN_ERROR(MAJOR, E_NO_DEVICE, ("fman_port_init"));
 
-    /* NIA */
-    if (p_FmPort->imEn)
+    if (p_FmPort->imEn && ((err = FmPortImInit(p_FmPort)) != E_OK))
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    else
     {
-        WRITE_UINT32(p_Regs->fmbm_tfdne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
-        WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
-#if (DPAA_VERSION >= 11)
-/* TODO - what should be the TFNE for FMan v3 IM? */
-#endif /* (DPAA_VERSION >= 11) */
+    //  from QMIInit
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+            (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        {
+            if (p_DriverParams->deqPrefetchOption == e_FM_PORT_DEQ_NO_PREFETCH)
+                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, FALSE);
+            else
+                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, TRUE);
+        }
     }
-    else
+    /* The code bellow is a trick so the FM will not release the buffer
+       to BM nor will try to enqueue the frame to QM */
+    if (((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+         (p_FmPort->portType == e_FM_PORT_TYPE_TX)) &&
+        (!p_FmPort->imEn))
     {
-        WRITE_UINT32(p_Regs->fmbm_tfdne, NIA_ENG_QMI_DEQ);
-        WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
-#if (DPAA_VERSION >= 11)
-        WRITE_UINT32(p_Regs->fmbm_tfne,
-                     (!p_Params->dfltFqid ?
-                        BMI_EBD_EN | NIA_BMI_AC_FETCH_ALL_FRAME :
-                        NIA_BMI_AC_FETCH_ALL_FRAME));
-#endif /* (DPAA_VERSION >= 11) */
-
-        /* The line bellow is a trick so the FM will not release the buffer
-           to BM nor will try to enq the frame to QM */
-        if (!p_Params->dfltFqid && p_Params->dontReleaseBuf)
+        if (!p_DriverParams->dfltFqid && p_DriverParams->dontReleaseBuf)
         {
             /* override fmbm_tcfqid 0 with a false non-0 value. This will force FM to
-             * act according to tfene. Otherwise, if fmbm_tcfqid is 0 the FM will release
+             * act acording to tfene. Otherwise, if fmbm_tcfqid is 0 the FM will release
              * buffers to BM regardless of fmbm_tfene
              */
-            WRITE_UINT32(p_Regs->fmbm_tcfqid, 0xFFFFFF);
-            WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
-#if (DPAA_VERSION >= 11)
-            WRITE_UINT32(p_Regs->fmbm_tfne,
-                         (GET_UINT32(p_Regs->fmbm_tfne) & ~BMI_EBD_EN));
-#endif /* (DPAA_VERSION >= 11) */
+            WRITE_UINT32(p_FmPort->port.bmi_regs->tx.fmbm_tcfqid, 0xFFFFFF);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->tx.fmbm_tfene, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
         }
     }
 
-    /* command attribute */
-    tmpReg = BMI_CMD_TX_MR_DEF;
-    if (p_FmPort->imEn)
-        tmpReg |= BMI_CMD_MR_DEAS;
-    else
-    {
-        tmpReg |= BMI_CMD_ATTR_ORDER;
-        tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
-    }
-    WRITE_UINT32(p_Regs->fmbm_tfca, tmpReg);
-
-    /* default queues */
-    if (!p_FmPort->imEn)
-    {
-        if (p_Params->dfltFqid || !p_Params->dontReleaseBuf)
-            WRITE_UINT32(p_Regs->fmbm_tcfqid, p_Params->dfltFqid);
-        WRITE_UINT32(p_Regs->fmbm_tfeqid, p_Params->errFqid);
-    }
-
-    /* statistics & performance counters */
-    WRITE_UINT32(p_Regs->fmbm_tstc, BMI_COUNTERS_EN);
-
-    performanceContersParams.taskCompVal    = (uint8_t)p_FmPort->tasks.num;
-    performanceContersParams.queueCompVal   = 1;
-    performanceContersParams.dmaCompVal     = (uint8_t)p_FmPort->openDmas.num;
-    performanceContersParams.fifoCompVal    = p_FmPort->fifoBufs.num;
-    FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams);
-
-    WRITE_UINT32(p_Regs->fmbm_tpc, BMI_COUNTERS_EN);
-
-
     return E_OK;
 }
 
-static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
-{
-    t_FmPortOhBmiRegs       *p_Regs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
-    uint32_t                tmpReg, errorsToEnq = 0;
-    t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
-    t_FmPortPerformanceCnt  performanceContersParams;
-
-    /* check that port is not busy */
-    if (GET_UINT32(p_Regs->fmbm_ocfg) & BMI_PORT_CFG_EN)
-         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
-
-    /* Configure dma attributes */
-    tmpReg = 0;
-    tmpReg |= (uint32_t)p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
-    tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
-    tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
-    tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
-    if (p_Params->dmaWriteOptimize)
-        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
-
-    WRITE_UINT32(p_Regs->fmbm_oda, tmpReg);
-
-    /* IC parameters */
-    tmpReg = 0;
-    tmpReg |= (((uint32_t)p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
-    tmpReg |= (((uint32_t)p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
-    tmpReg |= (((uint32_t)p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
-
-    WRITE_UINT32(p_Regs->fmbm_oicp, tmpReg);
-
-    /* NIA */
-    WRITE_UINT32(p_Regs->fmbm_ofdne, NIA_ENG_QMI_DEQ);
-
-    if (p_FmPort->portType==e_FM_PORT_TYPE_OH_HOST_COMMAND)
-        WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ);
-    else
-        WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
-
-    /* command attribute */
-    if (p_FmPort->portType==e_FM_PORT_TYPE_OH_HOST_COMMAND)
-        tmpReg =  BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
-    else
-        tmpReg = BMI_CMD_ATTR_ORDER | BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
-
-    if (p_Params->syncReq)
-        tmpReg |= BMI_CMD_ATTR_SYNC;
-    tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
-    WRITE_UINT32(p_Regs->fmbm_ofca, tmpReg);
-
-    /* No discard - all error frames go to error queue */
-    if (p_Params->frmDiscardOverride)
-        tmpReg = BMI_PORT_CFG_FDOVR;
-    else
-        tmpReg = 0;
-    WRITE_UINT32(p_Regs->fmbm_ocfg, tmpReg);
-
-    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-    {
-        WRITE_UINT32(p_Regs->fmbm_ofsdm, p_Params->errorsToDiscard);
-
-        errorsToEnq = (OP_ERRS_TO_ENQ & ~p_Params->errorsToDiscard);
-        WRITE_UINT32(p_Regs->fmbm_ofsem, errorsToEnq);
-
-        /* NIA */
-        WRITE_UINT32(p_Regs->fmbm_ofne, GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
-
-#ifndef FM_NO_OP_OBSERVED_POOLS
-        /* Call the external Buffer routine which also checks fifo
-           size and updates it if necessary */
-        if ((p_FmPort->fmRevInfo.majorRev == 4) &&
-            p_Params->enBufPoolDepletion)
-        {
-            /* define external buffer pools */
-            t_Error err = SetExtBufferPools(p_FmPort);
-            if (err)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-        }
-#endif /* FM_NO_OP_OBSERVED_POOLS */
-    }
-    else
-        /* NIA */
-        WRITE_UINT32(p_Regs->fmbm_ofne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_HC);
-
-    /* default queues */
-    WRITE_UINT32(p_Regs->fmbm_ofqid, p_Params->dfltFqid);
-    WRITE_UINT32(p_Regs->fmbm_oefqid, p_Params->errFqid);
-
-    if (p_FmPort->internalBufferOffset)
-    {
-        tmpReg = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
-                            (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
-                            (p_FmPort->internalBufferOffset/OFFSET_UNITS));
-        p_FmPort->internalBufferOffset = (uint8_t)(tmpReg * OFFSET_UNITS);
-        WRITE_UINT32(p_Regs->fmbm_oim, tmpReg << BMI_IM_FOF_SHIFT);
-    }
-    /* statistics & performance counters */
-    WRITE_UINT32(p_Regs->fmbm_ostc, BMI_COUNTERS_EN);
-
-    performanceContersParams.taskCompVal    = (uint8_t)p_FmPort->tasks.num;
-    performanceContersParams.queueCompVal   = 0;
-    performanceContersParams.dmaCompVal     = (uint8_t)p_FmPort->openDmas.num;
-    performanceContersParams.fifoCompVal    = p_FmPort->fifoBufs.num;
-    FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams);
-
-    WRITE_UINT32(p_Regs->fmbm_opc, BMI_COUNTERS_EN);
-#ifdef FM_DEQ_PIPELINE_PARAMS_FOR_OP
-    if ((p_FmPort->fmRevInfo.majorRev == 4) ||
-        (p_FmPort->fmRevInfo.majorRev >= 6))
-    {
-        tmpReg = (((uint32_t)p_FmPort->fifoDeqPipelineDepth - 1) << BMI_FIFO_PIPELINE_DEPTH_SHIFT);
-        WRITE_UINT32(p_Regs->fmbm_ofp, tmpReg);
-    }
-#endif /* FM_DEQ_PIPELINE_PARAMS_FOR_OP */
 
-#ifdef FM_FRAME_END_PARAMS_FOR_OP
-    if (p_FmPort->fmRevInfo.majorRev >= 6)
-    {
-        /* frame end parameters */
-        tmpReg = 0;
-        tmpReg |= ((uint32_t)p_Params->cheksumLastBytesIgnore << BMI_FRAME_END_CS_IGNORE_SHIFT);
-
-        WRITE_UINT32(p_Regs->fmbm_ofed, tmpReg);
-    }
-#endif /* FM_FRAME_END_PARAMS_FOR_OP */
-
-    return E_OK;
-}
-
-static t_Error QmiInit(t_FmPort *p_FmPort)
+static bool CheckRxBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
 {
-    t_FmPortDriverParam             *p_Params = NULL;
-    uint32_t                        tmpReg;
-
-    p_Params = p_FmPort->p_FmPortDriverParam;
-
-    /* check that port is not busy */
-    if (((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX)) &&
-       (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN))
-         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
-
-    /* enable & clear counters */
-    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, QMI_PORT_CFG_EN_COUNTERS);
+    UNUSED(p_FmPort);
 
-    /* The following is  done for non-Rx ports only */
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    switch (counter)
     {
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
-            (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        {
-            /* define dequeue NIA */
-            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
-            /* define enqueue NIA */
-            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
-        }
-        else  /* for HC & OP */
-        {
-            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
-            /* define enqueue NIA */
-            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
-        }
-
-        /* configure dequeue */
-        tmpReg = 0;
-        if (p_Params->deqHighPriority)
-            tmpReg |= QMI_DEQ_CFG_PRI;
-
-        switch (p_Params->deqType)
-        {
-            case (e_FM_PORT_DEQ_TYPE1):
-                tmpReg |= QMI_DEQ_CFG_TYPE1;
-                break;
-            case (e_FM_PORT_DEQ_TYPE2):
-                tmpReg |= QMI_DEQ_CFG_TYPE2;
-                break;
-            case (e_FM_PORT_DEQ_TYPE3):
-                tmpReg |= QMI_DEQ_CFG_TYPE3;
-                break;
-            default:
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue type"));
-        }
-
-#ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-        if (p_FmPort->fmRevInfo.majorRev != 4)
-#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-        switch (p_Params->deqPrefetchOption)
-        {
-            case (e_FM_PORT_DEQ_NO_PREFETCH):
-                /* Do nothing - QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_1_FRAME = 0 */
-                break;
-            case (e_FM_PORT_DEQ_PARTIAL_PREFETCH):
-                tmpReg |= QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
-                break;
-            case (e_FM_PORT_DEQ_FULL_PREFETCH):
-                tmpReg |= QMI_DEQ_CFG_PREFETCH_NO_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
-                break;
-            default:
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue prefetch option"));
-        }
-#ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-        if (p_FmPort->fmRevInfo.majorRev != 4)
-#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-        if (p_Params->deqPrefetchOption == e_FM_PORT_DEQ_NO_PREFETCH)
-            FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, FALSE);
-        else
-            FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, TRUE);
-
-        tmpReg |= p_Params->deqByteCnt;
-        tmpReg |= (uint32_t)p_Params->deqSubPortal << QMI_DEQ_CFG_SUBPORTAL_SHIFT;
-
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndc, tmpReg);
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+            return TRUE;
+        default:
+            return FALSE;
     }
-    else /* rx port */
-        /* define enqueue NIA */
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
-
-    return E_OK;
 }
 
-static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+static bool CheckTxBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
 {
-    t_FmPortRxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
-
-     /* check that counters are enabled */
-    switch (counter)
-    {
-        case (e_FM_PORT_COUNTERS_CYCLE):
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
-        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
-            /* performance counters - may be read when disabled */
-            break;
-        case (e_FM_PORT_COUNTERS_FRAME):
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
-        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
-            if (!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
-            break;
-         default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
-    }
+    UNUSED(p_FmPort);
 
-    /* Set counter */
     switch (counter)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
-            *p_Ptr = &p_BmiRegs->fmbm_rccn;
-            break;
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
-            *p_Ptr = &p_BmiRegs->fmbm_rtuc;
-            break;
-        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
-            *p_Ptr = &p_BmiRegs->fmbm_rrquc;
-            break;
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
-            *p_Ptr = &p_BmiRegs->fmbm_rduc;
-            break;
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
-            *p_Ptr = &p_BmiRegs->fmbm_rfuc;
-            break;
-        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
-            *p_Ptr = &p_BmiRegs->fmbm_rpac;
-            break;
-        case (e_FM_PORT_COUNTERS_FRAME):
-            *p_Ptr = &p_BmiRegs->fmbm_rfrc;
-            break;
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
-            *p_Ptr = &p_BmiRegs->fmbm_rfcd;
-            break;
-        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
-            *p_Ptr = &p_BmiRegs->fmbm_rfbc;
-            break;
-        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
-            *p_Ptr = &p_BmiRegs->fmbm_rlfc;
-            break;
-        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-            *p_Ptr = &p_BmiRegs->fmbm_rffc;
-            break;
-        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-            *p_Ptr = &p_BmiRegs->fmbm_rfldec;
-            break;
-        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-            *p_Ptr = &p_BmiRegs->fmbm_rodc;
-            break;
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            *p_Ptr = &p_BmiRegs->fmbm_rbdc;
-            break;
-        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
-            *p_Ptr = &p_BmiRegs->fmbm_rpec;
-            break;
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            return TRUE;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+            return FALSE;
     }
-
-    return E_OK;
 }
 
-static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+static bool CheckOhBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
 {
-    t_FmPortTxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
-
-     /* check that counters are enabled */
     switch (counter)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
-        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
-            /* performance counters - may be read when disabled */
-            break;
-        case (e_FM_PORT_COUNTERS_FRAME):
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            if (!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
-            break;
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            return TRUE;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+            if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+                return FALSE;
+            else
+                return TRUE;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+            return FALSE;
     }
+}
 
-    /* Set counter */
-    switch (counter)
+static t_Error BmiPortCheckAndGetCounterType(t_FmPort                      *p_FmPort,
+                                             e_FmPortCounters              counter,
+                                             enum fman_port_stats_counters *p_StatsType,
+                                             enum fman_port_perf_counters  *p_PerfType,
+                                             bool                          *p_IsStats)
+{
+    volatile uint32_t   *p_Reg;
+    bool                isValid;
+
+    switch (p_FmPort->portType)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
-           *p_Ptr = &p_BmiRegs->fmbm_tccn;
-            break;
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
-           *p_Ptr = &p_BmiRegs->fmbm_ttuc;
-            break;
-        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
-            *p_Ptr = &p_BmiRegs->fmbm_ttcquc;
-            break;
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
-           *p_Ptr = &p_BmiRegs->fmbm_tduc;
-            break;
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
-           *p_Ptr = &p_BmiRegs->fmbm_tfuc;
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_Reg = &p_FmPort->port.bmi_regs->rx.fmbm_rstc;
+            isValid = CheckRxBmiCounter(p_FmPort, counter);
             break;
-        case (e_FM_PORT_COUNTERS_FRAME):
-           *p_Ptr = &p_BmiRegs->fmbm_tfrc;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_Reg = &p_FmPort->port.bmi_regs->tx.fmbm_tstc;
+            isValid = CheckTxBmiCounter(p_FmPort, counter);
             break;
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
-           *p_Ptr = &p_BmiRegs->fmbm_tfdc;
-            break;
-        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
-           *p_Ptr = &p_BmiRegs->fmbm_tfledc;
-            break;
-        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-            *p_Ptr = &p_BmiRegs->fmbm_tfufdc;
-            break;
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            *p_Ptr = &p_BmiRegs->fmbm_tbdc;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_Reg = &p_FmPort->port.bmi_regs->oh.fmbm_ostc;
+            isValid = CheckOhBmiCounter(p_FmPort, counter);
             break;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
     }
 
-    return E_OK;
-}
-
-static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
-{
-    t_FmPortOhBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
+    if (!isValid)
+        RETURN_ERROR(MINOR, E_INVALID_STATE,
+                ("Requested counter is not available for this port type"));
 
-    /* check that counters are enabled */
+     /* check that counters are enabled */
     switch (counter)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             /* performance counters - may be read when disabled */
             break;
-        case (e_FM_PORT_COUNTERS_FRAME):
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
-        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+            if (!(GET_UINT32(*p_Reg) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
-        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
-            /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
-            ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
-            if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+         default:
             break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter(%d) is not available for O/H ports", counter));
     }
 
     /* Set counter */
     switch (counter)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
-           *p_Ptr = &p_BmiRegs->fmbm_occn;
+        case(e_FM_PORT_COUNTERS_CYCLE):
+            *p_PerfType = E_FMAN_PORT_PERF_CNT_CYCLE;
+            *p_IsStats = FALSE;
             break;
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
-           *p_Ptr = &p_BmiRegs->fmbm_otuc;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+            *p_PerfType = E_FMAN_PORT_PERF_CNT_TASK_UTIL;
             break;
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
-           *p_Ptr = &p_BmiRegs->fmbm_oduc;
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+            *p_PerfType = E_FMAN_PORT_PERF_CNT_QUEUE_UTIL;
+            *p_IsStats = FALSE;
             break;
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
-           *p_Ptr = &p_BmiRegs->fmbm_ofuc;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+            *p_PerfType = E_FMAN_PORT_PERF_CNT_DMA_UTIL;
+            *p_IsStats = FALSE;
             break;
-        case (e_FM_PORT_COUNTERS_FRAME):
-           *p_Ptr = &p_BmiRegs->fmbm_ofrc;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            *p_PerfType = E_FMAN_PORT_PERF_CNT_FIFO_UTIL;
+            *p_IsStats = FALSE;
             break;
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
-           *p_Ptr = &p_BmiRegs->fmbm_ofdc;
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+            *p_PerfType = E_FMAN_PORT_PERF_CNT_RX_PAUSE;
+            *p_IsStats = FALSE;
             break;
-        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-           *p_Ptr = &p_BmiRegs->fmbm_offc;
+        case(e_FM_PORT_COUNTERS_FRAME):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_FRAME;
+            *p_IsStats = TRUE;
             break;
-        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-          *p_Ptr = &p_BmiRegs->fmbm_ofldec;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_DISCARD;
+            *p_IsStats = TRUE;
             break;
-        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
-           *p_Ptr = &p_BmiRegs->fmbm_ofwdc;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_DEALLOC_BUF;
+            *p_IsStats = TRUE;
             break;
-        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
-           *p_Ptr = &p_BmiRegs->fmbm_ofledc;
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_BAD_FRAME;
+            *p_IsStats = TRUE;
             break;
-        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-            *p_Ptr = &p_BmiRegs->fmbm_ofufdc;
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_LARGE_FRAME;
+            *p_IsStats = TRUE;
             break;
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            *p_Ptr = &p_BmiRegs->fmbm_obdc;
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_OUT_OF_BUF;
+            *p_IsStats = TRUE;
             break;
-        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-            *p_Ptr = &p_BmiRegs->fmbm_oodc;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_FILTERED_FRAME;
             break;
-        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
-            *p_Ptr = &p_BmiRegs->fmbm_opec;
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_DMA_ERR;
+            *p_IsStats = TRUE;
             break;
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_WRED_DISCARD;
+            *p_IsStats = TRUE;
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_LEN_ERR;
+            *p_IsStats = TRUE;
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+            *p_StatsType = E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT;
+            *p_IsStats = TRUE;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            break;
     }
 
     return E_OK;
 }
 
+
 static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
 {
     uint8_t                     hdrNum, Ipv4HdrNum;
@@ -1495,18 +1054,18 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
-            p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
-            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
-            p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[0];
-            p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
+            p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
+            p_BmiPrsNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfpne;
+            p_BmiPrsStartOffset = &p_FmPort->port.bmi_regs->rx.fmbm_rpso;
+            p_BmiInitPrsResult = &p_FmPort->port.bmi_regs->rx.fmbm_rprai[0];
+            p_BmiCcBase = &p_FmPort->port.bmi_regs->rx.fmbm_rccb;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-            p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
-            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
-            p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[0];
-            p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
+            p_BmiPrsNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofpne;
+            p_BmiPrsStartOffset = &p_FmPort->port.bmi_regs->oh.fmbm_opso;
+            p_BmiInitPrsResult = &p_FmPort->port.bmi_regs->oh.fmbm_oprai[0];
+            p_BmiCcBase = &p_FmPort->port.bmi_regs->oh.fmbm_occb;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
@@ -1869,12 +1428,12 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
-            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+            p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
+            p_BmiPrsStartOffset = &p_FmPort->port.bmi_regs->rx.fmbm_rpso;
             break;
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+            p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
+            p_BmiPrsStartOffset = &p_FmPort->port.bmi_regs->oh.fmbm_opso;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
@@ -1935,9 +1494,9 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
 
     /* get PCD registers pointers */
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-        p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
     else
-        p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+        p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
 
     /* check that current NIA is BMI to BMI */
     if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
@@ -1951,9 +1510,9 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
     if (p_FmPort->requiredAction & UPDATE_NIA_CMNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ocmne, p_FmPort->savedBmiCmne);
         else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rcmne, p_FmPort->savedBmiCmne);
     }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
@@ -1962,25 +1521,25 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
     if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, p_FmPort->savedBmiFene);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene, p_FmPort->savedBmiFene);
         else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene, p_FmPort->savedBmiFene);
     }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_FPNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne, p_FmPort->savedBmiFpne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne, p_FmPort->savedBmiFpne);
         else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne, p_FmPort->savedBmiFpne);
     }
 
     WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
     {
-        p_FmPort->origNonRxQmiRegsPndn = GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn);
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
+        p_FmPort->origNonRxQmiRegsPndn = GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn);
+        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
     }
 
     return E_OK;
@@ -1994,12 +1553,12 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
 
     /* get PCD registers pointers */
     if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->origNonRxQmiRegsPndn);
+        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn, p_FmPort->origNonRxQmiRegsPndn);
 
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-        p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
     else
-        p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+        p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
 
     WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) |
                             GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
@@ -2010,13 +1569,13 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
         else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
     }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
 
     if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
         if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
@@ -2049,7 +1608,7 @@ void FmPortSetMacsecLcv(t_Handle h_FmPort)
         return;
     }
 
-    p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
+    p_BmiCfgReg = &p_FmPort->port.bmi_regs->rx.fmbm_rcfg;
     /* get LCV for MACSEC */
     if ((p_FmPort->h_FmPcd) && ((lcv = FmPcdGetMacsecLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId))!= 0))
     {
@@ -2080,7 +1639,7 @@ void FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci)
         return;
     }
 
-    p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfca;
+    p_BmiCfgReg = &p_FmPort->port.bmi_regs->tx.fmbm_tfca;
     tmpReg = GET_UINT32(*p_BmiCfgReg) & ~BMI_CMD_ATTR_MACCMD_MASK;
     tmpReg |= BMI_CMD_ATTR_MACCMD_SECURED;
     tmpReg |= (((uint32_t)dfltSci << BMI_CMD_ATTR_MACCMD_SC_SHIFT) & BMI_CMD_ATTR_MACCMD_SC_MASK);
@@ -2204,6 +1763,16 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         p_CcParams->getCcParams.revInfo.minorRev = p_FmPort->fmRevInfo.minorRev;
         p_CcParams->getCcParams.type &= ~FM_REV;
     }
+    if (p_CcParams->getCcParams.type & DISCARD_MASK)
+    {
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            p_CcParams->getCcParams.discardMask =
+                GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm);
+        else
+            p_CcParams->getCcParams.discardMask =
+                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm);
+        p_CcParams->getCcParams.type &= ~DISCARD_MASK;
+    }
     if (p_CcParams->getCcParams.type & MANIP_EXTRA_SPACE)
     {
         p_CcParams->getCcParams.internalBufferOffset = p_FmPort->internalBufferOffset;
@@ -2212,9 +1781,9 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     if (p_CcParams->getCcParams.type & GET_NIA_FPNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne);
+            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne);
         else
-            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne);
+            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne);
         p_CcParams->getCcParams.type &= ~GET_NIA_FPNE;
     }
     if (p_CcParams->getCcParams.type & GET_NIA_PNDN)
@@ -2297,18 +1866,19 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         !(p_FmPort->requiredAction & UPDATE_PSO))
     {
         /* get PCD registers pointers */
-         switch (p_FmPort->portType)
-         {
-             case (e_FM_PORT_TYPE_RX_10G):
-             case (e_FM_PORT_TYPE_RX):
-                 p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
-                 break;
-             case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-                 p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
-                 break;
-             default:
-                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-         }
+        switch (p_FmPort->portType)
+        {
+            case (e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_RX):
+                p_BmiPrsStartOffset = &p_FmPort->port.bmi_regs->rx.fmbm_rpso;
+                break;
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                p_BmiPrsStartOffset = &p_FmPort->port.bmi_regs->oh.fmbm_opso;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+        }
+
         /* set start parsing offset */
         tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)+ p_CcParams->setCcParams.psoSize;
         if (tmpInt>0)
@@ -2316,7 +1886,6 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
 
         p_FmPort->requiredAction |= UPDATE_PSO;
         p_FmPort->savedPrsStartOffset = p_CcParams->setCcParams.psoSize;
-
     }
     else if (p_CcParams->setCcParams.type & UPDATE_PSO)
     {
@@ -2385,7 +1954,45 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             DBG(WARNING, ("Use non-zero portId for OP port due to insufficient resources on portId 0."));
     }
 
-    /* Initialize FM port parameters for initialization phase only */
+    /* Set up FM port parameters for initialization phase only */
+
+    /* First, fill in flibs struct */
+    fman_port_defconfig(&p_FmPort->p_FmPortDriverParam->dfltCfg, (enum fman_port_type)p_FmPort->portType);
+    /* Overwrite some integration specific parameters */
+    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_pri_elevation = DEFAULT_PORT_rxFifoPriElevationLevel;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_fifo_thr = DEFAULT_PORT_rxFifoThreshold;
+
+#if defined(FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675) || defined(FM_ERROR_VSP_NO_MATCH_SW006)
+    p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006675 = TRUE;
+#else
+    p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006675 = FALSE;
+#endif
+    if ((p_FmPort->fmRevInfo.majorRev == 6) && (p_FmPort->fmRevInfo.minorRev == 0))
+        p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006320 = TRUE;
+    else
+        p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006320 = FALSE;
+
+    /* Excessive Threshold register - exists for pre-FMv3 chips only */
+    if (p_FmPort->fmRevInfo.majorRev < 6)
+    {
+#ifdef FM_NO_RESTRICT_ON_ACCESS_RSRC
+        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register = TRUE;
+#endif
+        p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_rebm_has_sgd = FALSE;
+        p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_tfne_has_features = FALSE;
+    }
+    else
+    {
+        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register = FALSE;
+        p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_rebm_has_sgd = TRUE;
+        p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_tfne_has_features = TRUE;
+    }
+    if (p_FmPort->fmRevInfo.majorRev == 4)
+        p_FmPort->p_FmPortDriverParam->dfltCfg.qmi_deq_options_support = FALSE;
+    else
+        p_FmPort->p_FmPortDriverParam->dfltCfg.qmi_deq_options_support = TRUE;
+
+    /* Continue with other parameters */
     p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
     /* set memory map pointers */
     p_FmPort->p_FmPortQmiRegs     = (t_FmPortQmiRegs *)UINT_TO_PTR(baseAddr + QMI_PORT_REGS_OFFSET);
@@ -2398,14 +2005,13 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo
                                                                     = DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign    = DEFAULT_PORT_bufferPrefixContent_dataAlign;
-    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = (e_FmDmaSwapOption)DEFAULT_PORT_dmaSwapData;
+/*    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = (e_FmDmaSwapOption)DEFAULT_PORT_dmaSwapData;
     p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = (e_FmDmaCacheOption)DEFAULT_PORT_dmaIntContextCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = (e_FmDmaCacheOption)DEFAULT_PORT_dmaHeaderCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = (e_FmDmaCacheOption)DEFAULT_PORT_dmaScatterGatherCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
-    p_FmPort->p_FmPortDriverParam->liodnBase                        = p_FmPortParams->liodnBase;
+*/    p_FmPort->p_FmPortDriverParam->liodnBase                        = p_FmPortParams->liodnBase;
     p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore           = DEFAULT_PORT_cheksumLastBytesIgnore;
-    p_FmPort->p_FmPortDriverParam->color                            = DEFAULT_PORT_color;
 
     p_FmPort->maxFrameLength                                        = DEFAULT_PORT_maxFrameLength;
     /* resource distribution. */
@@ -2455,16 +2061,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         }
 #endif /* FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981 */
 
-    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
-        p_FmPort->p_FmPortDriverParam->syncReq                      = DEFAULT_PORT_syncReqForHc;
-    else
-        p_FmPort->p_FmPortDriverParam->syncReq                      = DEFAULT_PORT_syncReq;
-
     /* Port type specific initialization: */
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
-        p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
-
     switch (p_FmPort->portType)
     {
     case (e_FM_PORT_TYPE_RX):
@@ -2506,7 +2103,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
         {
             p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel       = DEFAULT_PORT_txFifoMinFillLevel;
-            p_FmPort->fifoDeqPipelineDepth                          =
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth                          =
                 (uint8_t)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
                           DEFAULT_PORT_fifoDeqPipelineDepth_1G :
                           DEFAULT_PORT_fifoDeqPipelineDepth_10G);
@@ -2518,7 +2115,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp);
             p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel =
                 ((tmpReg & BMI_TX_FIFO_MIN_FILL_MASK) >> BMI_TX_FIFO_MIN_FILL_SHIFT) * BMI_FIFO_UNITS ;
-            p_FmPort->fifoDeqPipelineDepth =
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
                 (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK) >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
             p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel =
                 (((tmpReg & BMI_TX_LOW_COMF_MASK) >> BMI_TX_LOW_COMF_SHIFT) + 1) * BMI_FIFO_UNITS;
@@ -2548,18 +2145,18 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
     if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-        p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+        p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
     else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
     {
         tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofp);
-        p_FmPort->fifoDeqPipelineDepth =
+        p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
             (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK) >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
         if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
             (p_FmPortParams->portId != FM_OH_PORT_ID))
         {
             /* Overwrite HC defaults */
-            p_FmPort->fifoDeqPipelineDepth = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
         }
     }
 
@@ -2571,7 +2168,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
     if (!((p_FmPort->fmRevInfo.majorRev == 4) ||
           (p_FmPort->fmRevInfo.majorRev >= 6)))
-            p_FmPort->fifoDeqPipelineDepth                          = DEFAULT_notSupported;
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth                          = DEFAULT_notSupported;
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
         break;
 
@@ -2592,7 +2189,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     {
         if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
             (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
-            p_FmPort->fifoDeqPipelineDepth = DEFAULT_PORT_fifoDeqPipelineDepth_IM;
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = DEFAULT_PORT_fifoDeqPipelineDepth_IM;
         FmPortConfigIM(p_FmPort, p_FmPortParams);
     }
     else
@@ -2667,20 +2264,21 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 t_Error FM_PORT_Init(t_Handle h_FmPort)
 {
     t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPortDriverParam             *p_Params;
-    t_Error                         err = E_OK;
+    t_FmPortDriverParam             *p_DriverParams;
+    t_Error                         errCode;
     t_FmInterModulePortInitParams   fmParams;
+    t_FmRevisionInfo                revInfo;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    err = FmSpBuildBufferStructure(&p_FmPort->p_FmPortDriverParam->intContext,
-                                   &p_FmPort->p_FmPortDriverParam->bufferPrefixContent,
-                                   &p_FmPort->p_FmPortDriverParam->bufMargins,
-                                   &p_FmPort->bufferOffsets,
-                                   &p_FmPort->internalBufferOffset);
-    if (err != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    errCode = FmSpBuildBufferStructure(&p_FmPort->p_FmPortDriverParam->intContext,
+                                       &p_FmPort->p_FmPortDriverParam->bufferPrefixContent,
+                                       &p_FmPort->p_FmPortDriverParam->bufMargins,
+                                       &p_FmPort->bufferOffsets,
+                                       &p_FmPort->internalBufferOffset);
+    if (errCode != E_OK)
+        RETURN_ERROR(MAJOR, errCode, NO_MSG);
 #ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
     if ((p_FmPort->p_FmPortDriverParam->bcbWorkaround) &&
            (p_FmPort->portType == e_FM_PORT_TYPE_RX))
@@ -2694,19 +2292,58 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
     CHECK_INIT_PARAMETERS(p_FmPort, CheckInitParameters);
 
-    p_Params = p_FmPort->p_FmPortDriverParam;
-
-    if  ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
+    p_DriverParams = p_FmPort->p_FmPortDriverParam;
+
+    /* Set up flibs port structure */
+    memset(&p_FmPort->port, 0, sizeof(struct fman_port));
+    p_FmPort->port.type = (enum fman_port_type)p_FmPort->portType;
+    FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+    p_FmPort->port.fm_rev_maj = revInfo.majorRev;
+    p_FmPort->port.fm_rev_min = revInfo.minorRev;
+    p_FmPort->port.bmi_regs = (union fman_port_bmi_regs *)
+            UINT_TO_PTR(p_DriverParams->baseAddr + BMI_PORT_REGS_OFFSET);
+    p_FmPort->port.qmi_regs = (struct fman_port_qmi_regs *)
+            UINT_TO_PTR(p_DriverParams->baseAddr + QMI_PORT_REGS_OFFSET);
+    p_FmPort->port.ext_pools_num = (uint8_t)((revInfo.majorRev == 4) ? 4 : 8);
+    p_FmPort->port.im_en = p_FmPort->imEn;
+    p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(p_DriverParams->baseAddr + PRS_PORT_REGS_OFFSET);
+
+    if  (((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
          (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-        if (!p_FmPort->imEn)
-        {
+        && !p_FmPort->imEn)
+    {
             /* Call the external Buffer routine which also checks fifo
              size and updates it if necessary */
             /* define external buffer pools and pool depletion*/
-            err = SetExtBufferPools(p_FmPort);
-            if (err)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
+            errCode = SetExtBufferPools(p_FmPort);
+            if (errCode)
+                RETURN_ERROR(MAJOR, errCode, NO_MSG);
+            /* check if the largest external buffer pool is large enough */
+            if (p_DriverParams->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_DriverParams->bufMargins.endMargins >
+                p_FmPort->rxPoolsParams.largestBufSize)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                             ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
+                              p_DriverParams->bufMargins.startMargins,
+                              p_DriverParams->bufMargins.endMargins,
+                              p_FmPort->rxPoolsParams.largestBufSize));
+    }
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    {
+        {
+#ifdef FM_NO_OP_OBSERVED_POOLS
+            t_FmRevisionInfo        revInfo;
+
+            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 4) && (p_DriverParams->enBufPoolDepletion))
+#endif /* FM_NO_OP_OBSERVED_POOLS */
+            {
+                /* define external buffer pools */
+                errCode = SetExtBufferPools(p_FmPort);
+                if (errCode)
+                    RETURN_ERROR(MAJOR, errCode, NO_MSG);
+            }
         }
+    }
 
     /************************************************************/
     /* Call FM module routine for communicating parameters      */
@@ -2718,18 +2355,19 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
     fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
+
     if (p_FmPort->fifoBufs.num)
     {
-        err = VerifySizeOfFifo(p_FmPort);
-        if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        errCode = VerifySizeOfFifo(p_FmPort);
+        if (errCode != E_OK)
+            RETURN_ERROR(MAJOR, errCode, NO_MSG);
     }
     fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
     fmParams.extraSizeOfFifo    = p_FmPort->fifoBufs.extra;
     fmParams.independentMode    = p_FmPort->imEn;
-    fmParams.liodnOffset        = p_Params->liodnOffset;
-    fmParams.liodnBase          = p_Params->liodnBase;
-    fmParams.deqPipelineDepth   = p_FmPort->fifoDeqPipelineDepth;
+    fmParams.liodnOffset        = p_DriverParams->liodnOffset;
+    fmParams.liodnBase          = p_DriverParams->liodnBase;
+    fmParams.deqPipelineDepth   = p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth;
     fmParams.maxFrameLength     = p_FmPort->maxFrameLength;
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
     if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
@@ -2745,9 +2383,9 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
 
 
-    err = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    errCode = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
+    if (errCode)
+        RETURN_ERROR(MAJOR, errCode, NO_MSG);
 
     /* get params for use in init */
     p_FmPort->fmMuramPhysBaseAddr =
@@ -2767,41 +2405,9 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     }
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
 
-    /**********************/
-    /* Init BMI Registers */
-    /**********************/
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            err = BmiRxPortInit(p_FmPort);
-            if (err)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-            break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
-            err = BmiTxPortInit(p_FmPort);
-            if (err)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            err = BmiOhPortInit(p_FmPort);
-            if (err)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-    }
-
-    /**********************/
-    /* Init QMI Registers */
-    /**********************/
-    if (!p_FmPort->imEn && ((err = QmiInit(p_FmPort)) != E_OK))
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    if (p_FmPort->imEn && ((err = FmPortImInit(p_FmPort)) != E_OK))
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    errCode = InitLowLevelDriver(p_FmPort);
+    if (errCode != E_OK)
+        RETURN_ERROR(MAJOR, errCode, NO_MSG);
 
     FmPortDriverParamFree(p_FmPort);
 
@@ -2875,7 +2481,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 
     fmParams.hardwarePortId = p_FmPort->hardwarePortId;
     fmParams.portType = (e_FmPortType)p_FmPort->portType;
-    fmParams.deqPipelineDepth = p_FmPort->fifoDeqPipelineDepth;
+    fmParams.deqPipelineDepth = p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth;
 
     FmFreePortParams(p_FmPort->h_Fm, &fmParams);
 
@@ -2949,7 +2555,7 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for Rx ports"));
 
-    p_FmPort->p_FmPortDriverParam->deqHighPriority = highPri;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_high_pri = highPri;
 
     return E_OK;
 }
@@ -2963,7 +2569,7 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
 
-    p_FmPort->p_FmPortDriverParam->deqType = deqType;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_type = (enum fman_port_deq_type)deqType;
 
     return E_OK;
 }
@@ -2976,7 +2582,8 @@ t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOp
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
-    p_FmPort->p_FmPortDriverParam->deqPrefetchOption = deqPrefetchOption;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_prefetch_opt = (enum fman_port_deq_prefetch)deqPrefetchOption;
+
     return E_OK;
 }
 
@@ -3006,7 +2613,7 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
 
-    p_FmPort->p_FmPortDriverParam->deqByteCnt = deqByteCnt;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_byte_cnt = deqByteCnt;
 
     return E_OK;
 }
@@ -3019,21 +2626,21 @@ t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmBufferPrefixCon
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent, p_FmBufferPrefixContent, sizeof(t_FmBufferPrefixContent));
-    /* if dataAlign was not initialized by user, we return to driver's deafult */
+    /* if dataAlign was not initialized by user, we return to driver's default */
     if (!p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign)
         p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign = DEFAULT_PORT_bufferPrefixContent_dataAlign;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore)
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t checksumLastBytesIgnore)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore = cheksumLastBytesIgnore;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.checksum_bytes_ignore = checksumLastBytesIgnore;
 
     return E_OK;
 }
@@ -3047,7 +2654,7 @@ t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->cutBytesFromEnd = cutBytesFromEnd;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_cut_end_bytes = cutBytesFromEnd;
 
     return E_OK;
 }
@@ -3122,7 +2729,7 @@ t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    p_FmPort->p_FmPortDriverParam->color = color;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.color = (enum fman_port_color)color;
 
     return E_OK;
 }
@@ -3137,7 +2744,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
 
-    p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.sync_req = syncReq;
 
     return E_OK;
 }
@@ -3152,7 +2759,7 @@ t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
 
-    p_FmPort->p_FmPortDriverParam->frmDiscardOverride = override;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.discard_override = override;
 
     return E_OK;
 }
@@ -3179,7 +2786,7 @@ t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dmaSwapData = swapData;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.dma_swap_data = (enum fman_port_dma_swap)swapData;
 
     return E_OK;
 }
@@ -3191,7 +2798,8 @@ t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intCo
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr = intContextCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.dma_ic_stash_on =
+        (bool)(intContextCacheAttr == e_FM_DMA_STASH);
 
     return E_OK;
 }
@@ -3203,7 +2811,8 @@ t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCac
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr = headerCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.dma_header_stash_on =
+        (bool)(headerCacheAttr == e_FM_DMA_STASH);
 
     return E_OK;
 }
@@ -3215,7 +2824,8 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr = scatterGatherCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.dma_sg_stash_on =
+        (bool)(scatterGatherCacheAttr == e_FM_DMA_STASH);
 
     return E_OK;
 }
@@ -3230,7 +2840,7 @@ t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
 
-    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.dma_write_optimize = optimize;
 
     return E_OK;
 }
@@ -3306,7 +2916,7 @@ t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLeve
     if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = minFillLevel;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_min_level = minFillLevel;
 
     return E_OK;
 }
@@ -3324,7 +2934,7 @@ t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelin
     if (p_FmPort->imEn)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for IM ports!"));
 
-    p_FmPort->fifoDeqPipelineDepth = deqPipelineDepth;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = deqPipelineDepth;
 
     return E_OK;
 }
@@ -3338,7 +2948,7 @@ t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComf
     if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = fifoLowComfLevel;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_low_comf_level = fifoLowComfLevel;
 
     return E_OK;
 }
@@ -3352,7 +2962,7 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->rxFifoThreshold = fifoThreshold;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_fifo_thr = fifoThreshold;
 
     return E_OK;
 }
@@ -3366,7 +2976,7 @@ t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priEle
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel = priElevationLevel;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_pri_elevation = priElevationLevel;
 
     return E_OK;
 }
@@ -3428,8 +3038,8 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if (!p_SizeOfFifo->num || (p_SizeOfFifo->num > BMI_MAX_FIFO_SIZE))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+    if (!p_SizeOfFifo->num || (p_SizeOfFifo->num > MAX_PORT_FIFO_SIZE))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
     if (p_SizeOfFifo->num % BMI_FIFO_UNITS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be divisible by %d", BMI_FIFO_UNITS));
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
@@ -3524,92 +3134,27 @@ uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data)
 
 t_Error FM_PORT_Disable(t_Handle h_FmPort)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t           *p_BmiCfgReg = NULL;
-    volatile uint32_t           *p_BmiStatusReg = NULL;
-    bool                        rxPort = FALSE;
-    int                         tries;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
-            p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rst;
-            rxPort = TRUE;
-            break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
-             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
-             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tst;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
-            p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ost;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-    }
-
-    /* check if port is already disabled */
-    if (!(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN))
-    {
-        if (!rxPort && !p_FmPort->imEn)
-        {
-            if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN))
-                /* port is disabled */
-                return E_OK;
-            else
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistency: Port's QMI is enabled but BMI disabled"));
-        }
-        /* port is disabled */
-        return E_OK;
-    }
-
-    /* Disable QMI */
-    if (!rxPort && !p_FmPort->imEn)
-    {
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
-                     GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & ~QMI_PORT_CFG_EN);
-        /* wait for QMI to finish Handling dequeue tnums */
-        tries=1000;
-        while ((GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pns) & QMI_PORT_STATUS_DEQ_FD_BSY) &&
-                --tries)
-            XX_UDelay(1);
-        if (!tries)
-        {
-            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
-                         GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
-            RETURN_ERROR(MAJOR, E_BUSY, ("%s: can't disable! QMI busy", p_FmPort->name));
-        }
-    }
-
-    /* Disable BMI */
-    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) & ~BMI_PORT_CFG_EN);
-
     if (p_FmPort->imEn)
         FmPortImDisable(p_FmPort);
 
-    tries=5000;
-    while ((GET_UINT32(*p_BmiStatusReg) & BMI_PORT_STATUS_BSY) &&
-            --tries)
-        XX_UDelay(1);
-
-    if (!tries)
+    err = fman_port_disable(&p_FmPort->port);
+    if (err == -EBUSY)
     {
-        if (!rxPort && !p_FmPort->imEn)
-            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
-                         GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
-        WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
-
-        RETURN_ERROR(MAJOR, E_BUSY, ("%s: can't disable! BMI Busy", p_FmPort->name));
+        fman_port_enable(&p_FmPort->port);
+        RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable! BMI or QMI is Busy", p_FmPort->name));
+    }
+    else if (err != 0)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_disable"));
     }
 
-    p_FmPort->enabled = 0;
+    p_FmPort->enabled = FALSE;
 
     return E_OK;
 }
@@ -3617,58 +3162,26 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
 t_Error FM_PORT_Enable(t_Handle h_FmPort)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t           *p_BmiCfgReg = NULL;
-    bool                        rxPort = FALSE;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
-            rxPort = TRUE;
-            break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
-             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-    }
-
-    /* check if port is already enabled */
-    if (GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN)
-    {
-        if (!rxPort && !p_FmPort->imEn)
-        {
-            if (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN)
-                /* port is enabled */
-                return E_OK;
-            else
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistency: Port's BMI is enabled but QMI disabled"));
-        }
-        /* port is enabled */
-        return E_OK;
-    }
+    /* Used by FM_PORT_Free routine as indication
+       if to disable port. Thus set it to TRUE prior
+       to enabling itself. This way if part of enable
+       process fails there will be still things
+       to disable during Free. For example, if BMI
+       enable succeeded but QMI failed, still  BMI
+       needs to be disabled by Free. */
+    p_FmPort->enabled = TRUE;
 
     if (p_FmPort->imEn)
         FmPortImEnable(p_FmPort);
 
-    /* Enable QMI */
-    if (!rxPort && !p_FmPort->imEn)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
-                     GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
-
-    /* Enable BMI */
-    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
-
-    p_FmPort->enabled = 1;
+    err = fman_port_enable(&p_FmPort->port);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_enable"));
 
     return E_OK;
 }
@@ -3676,33 +3189,25 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
 t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t            tmpRateLimit, tmpRateLimitScale;
-    volatile uint32_t   *p_RateLimitReg, *p_RateLimitScaleReg;
     uint8_t             factor, countUnitBit;
     uint16_t            baseGran;
+    struct fman_port_rate_limiter params;
+    int                 err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-                                                (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
-
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
-            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
-            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
-            baseGran = 16000;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            baseGran = BMI_RATE_LIMIT_GRAN_TX;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
-            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
-            baseGran = 10000;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            baseGran = BMI_RATE_LIMIT_GRAN_OP;
            break;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
     }
 
     countUnitBit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm);  /* TimeStamp per nano seconds units */
@@ -3721,38 +3226,23 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
     if (p_RateLimit->rateLimit > ((uint32_t)baseGran * (1<<10) * (uint32_t)factor))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too large"));
 
-    tmpRateLimit = (uint32_t)(p_RateLimit->rateLimit*factor/baseGran - 1);
-
-    if (!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > MAX_BURST_SIZE))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
+    if (!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > BMI_RATE_LIMIT_MAX_BURST_SIZE))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("maxBurstSize must be between 1K and %dk", BMI_RATE_LIMIT_MAX_BURST_SIZE));
 
-    tmpRateLimitScale = ((31 - (uint32_t)countUnitBit) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
+    params.count_1micro_bit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm);
+    params.high_burst_size_gran = FALSE;
+    params.burst_size = p_RateLimit->maxBurstSize;
+    params.rate = p_RateLimit->rateLimit;
+    params.rate_factor = E_FMAN_PORT_RATE_DOWN_NONE;
 
-    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-        tmpRateLimit |= (uint32_t)(p_RateLimit->maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
-    else
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
     {
 #ifndef FM_NO_ADVANCED_RATE_LIMITER
 
         if ((p_FmPort->fmRevInfo.majorRev == 4) || (p_FmPort->fmRevInfo.majorRev >= 6))
         {
-            switch (p_RateLimit->rateLimitDivider)
-            {
-                case (e_FM_PORT_DUAL_RATE_LIMITER_NONE):
-                    break;
-                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2):
-                    tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_2;
-                    break;
-                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4):
-                    tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_4;
-                    break;
-                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8):
-                    tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_8;
-                    break;
-                default:
-                    break;
-            }
-            tmpRateLimit |= BMI_RATE_LIMIT_BURST_SIZE_GRAN;
+            params.high_burst_size_gran = TRUE;
         }
         else
 #endif /* ! FM_NO_ADVANCED_RATE_LIMITER */
@@ -3768,45 +3258,34 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
             else
                 p_RateLimit->maxBurstSize = (uint16_t)(p_RateLimit->maxBurstSize/1000);
         }
-        tmpRateLimit |= (uint32_t)(p_RateLimit->maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
-
+        params.rate_factor = (enum fman_port_rate_limiter_scale_down)p_RateLimit->rateLimitDivider;
+        params.burst_size = p_RateLimit->maxBurstSize;
     }
-    WRITE_UINT32(*p_RateLimitScaleReg, tmpRateLimitScale);
-    WRITE_UINT32(*p_RateLimitReg, tmpRateLimit);
-
-    return E_OK;
-}
-
-t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
-{
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t   *p_RateLimitReg, *p_RateLimitScaleReg;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    err = fman_port_set_rate_limiter(&p_FmPort->port, &params);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_rate_limiter"));
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-                                                (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
-
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
-            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
-            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
-            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
-           break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-    }
+    return E_OK;
+}
+
+t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    int                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    WRITE_UINT32(*p_RateLimitScaleReg, 0);
-    WRITE_UINT32(*p_RateLimitReg, 0);
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
+       (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+       (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                ("available for Tx and Offline parsing ports only"));
 
+    err = fman_port_delete_rate_limiter(&p_FmPort->port);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_rate_limiter"));
     return E_OK;
 }
 
@@ -3840,82 +3319,39 @@ t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio,
 t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t                tmpReg;
+    int                     err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    tmpReg = GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc);
-    if (enable)
-        tmpReg |= QMI_PORT_CFG_EN_COUNTERS ;
-    else
-        tmpReg &= ~QMI_PORT_CFG_EN_COUNTERS;
-
-    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, tmpReg);
-
+    err = fman_port_set_queue_cnt_mode(&p_FmPort->port, enable);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_perf_cnt_mode"));
     return E_OK;
 }
 
 t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t       *p_BmiPcReg = NULL;
+    int                     err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpc;
-            break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
-            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpc;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opc;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-    }
-
-    if (enable)
-        WRITE_UINT32(*p_BmiPcReg, BMI_COUNTERS_EN);
-    else
-        WRITE_UINT32(*p_BmiPcReg, 0);
-
+    err = fman_port_set_perf_cnt_mode(&p_FmPort->port, enable);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_perf_cnt_mode"));
     return E_OK;
 }
 
 t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t                tmpReg;
-    volatile uint32_t       *p_BmiPcpReg = NULL;
+    struct fman_port_perf_cnt_params    params;
+    int                                 err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpcp;
-            break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
-            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpcp;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opcp;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-    }
-
     /* check parameters */
     if (!p_FmPortPerformanceCnt->taskCompVal ||
         (p_FmPortPerformanceCnt->taskCompVal > p_FmPort->tasks.num))
@@ -3968,14 +3404,14 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    tmpReg = 0;
-    tmpReg |= ((uint32_t)(p_FmPortPerformanceCnt->queueCompVal - 1) << BMI_PERFORMANCE_PORT_COMP_SHIFT);
-    tmpReg |= ((uint32_t)(p_FmPortPerformanceCnt->dmaCompVal- 1) << BMI_PERFORMANCE_DMA_COMP_SHIFT);
-    tmpReg |= ((uint32_t)(p_FmPortPerformanceCnt->fifoCompVal/BMI_FIFO_UNITS - 1) << BMI_PERFORMANCE_FIFO_COMP_SHIFT);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING) && (p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        tmpReg |= ((uint32_t)(p_FmPortPerformanceCnt->taskCompVal - 1) << BMI_PERFORMANCE_TASK_COMP_SHIFT);
+    params.task_val     = p_FmPortPerformanceCnt->taskCompVal;
+    params.queue_val    = p_FmPortPerformanceCnt->queueCompVal;
+    params.dma_val      = p_FmPortPerformanceCnt->dmaCompVal;
+    params.fifo_val     = p_FmPortPerformanceCnt->fifoCompVal;
 
-    WRITE_UINT32(*p_BmiPcpReg, tmpReg);
+    err = fman_port_set_perf_cnt_params(&p_FmPort->port, &params);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_perf_cnt_params"));
 
     return E_OK;
 }
@@ -4070,68 +3506,29 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
 
 t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t                tmpReg;
-    volatile uint32_t       *p_BmiStcReg = NULL;
+    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+    int         err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rstc;
-            break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
-            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tstc;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ostc;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-    }
-
-    tmpReg = GET_UINT32(*p_BmiStcReg);
-
-    if (enable)
-        tmpReg |= BMI_COUNTERS_EN;
-    else
-        tmpReg &= ~BMI_COUNTERS_EN;
-
-    WRITE_UINT32(*p_BmiStcReg, tmpReg);
-
+    err = fman_port_set_stats_cnt_mode(&p_FmPort->port, enable);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_stats_cnt_mode"));
     return E_OK;
 }
 
 t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t       *p_ErrQReg, *p_ErrDiscard;
-
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem;
-            p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem;
-            p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
-            break;
-        default:
-           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-    }
+    volatile uint32_t       *p_ErrDiscard = NULL;
+    int                     err;
 
-    if (GET_UINT32(*p_ErrDiscard) & errs)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Selectd Errors that were configured to cause frame discard."));
+    UNUSED(p_ErrDiscard);
+    err = fman_port_set_err_mask(&p_FmPort->port, (uint32_t)errs);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_err_mask"));
 
-    WRITE_UINT32(*p_ErrQReg, errs);
- 
 #ifdef FM_ERROR_VSP_NO_MATCH_SW006
     if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
@@ -4139,18 +3536,29 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
 
         FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
         ASSERT_COND(p_ParamsPage);
+        switch (p_FmPort->portType)
+        {
+            case (e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_RX):
+                p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
+                break;
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
+                break;
+            default:
+               RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+        }
         WRITE_UINT32(p_ParamsPage->errorsDiscardMask, GET_UINT32(*p_ErrDiscard) | errs);
     }
 #endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
- 
+
     return E_OK;
 }
 
 t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable)
 {
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t                tmpReg;
-    int                     i;
+    int                     err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_POOLS, E_INVALID_HANDLE);
@@ -4159,48 +3567,40 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-    for (i=0 ; i< FM_PORT_MAX_NUM_OF_EXT_POOLS ; i++)
-    {
-        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
-        if ((uint8_t)((tmpReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT) == poolId)
-        {
-            if (enable)
-                tmpReg |= BMI_EXT_BUF_POOL_EN_COUNTER;
-            else
-                tmpReg &= ~BMI_EXT_BUF_POOL_EN_COUNTER;
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], tmpReg);
-            break;
-        }
-    }
-    if (i == FM_PORT_MAX_NUM_OF_EXT_POOLS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("poolId %d is not included in this ports pools", poolId));
-
+    err = fman_port_set_bpool_cnt_mode(&p_FmPort->port, poolId, enable);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_bpool_cnt_mode"));
     return E_OK;
 }
 
 uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    bool                bmiCounter = FALSE;
-    volatile uint32_t   *p_Reg;
+    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                            bmiCounter = FALSE;
+    enum fman_port_stats_counters   statsType;
+    enum fman_port_perf_counters    perfType;
+    enum fman_port_qmi_counters   queueType;
+    bool                            isStats;
+    t_Error                         errCode;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     switch (counter)
     {
-        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
             if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-                (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
             {
-                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+                REPORT_ERROR(MINOR, E_INVALID_STATE,
+                        ("Requested counter is not available for Rx ports"));
                 return 0;
             }
             bmiCounter = FALSE;
-        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -4210,83 +3610,76 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
 
     if (bmiCounter)
     {
-        switch (p_FmPort->portType)
+        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType, &perfType, &isStats);
+        if (errCode != E_OK)
         {
-            case (e_FM_PORT_TYPE_RX_10G):
-            case (e_FM_PORT_TYPE_RX):
-                if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
-                {
-                    REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-                    return 0;
-                }
-                break;
-            case (e_FM_PORT_TYPE_TX_10G):
-            case (e_FM_PORT_TYPE_TX):
-                if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
-                {
-                    REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-                    return 0;
-                }
-                break;
-            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-                if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
-                {
-                    REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-                    return 0;
-                }
-                break;
-            default:
-                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported port type"));
-                return 0;
+            REPORT_ERROR(MINOR, errCode, NO_MSG);
+            return 0;
         }
-        return GET_UINT32(*p_Reg);
+        if (isStats)
+            return fman_port_get_stats_counter(&p_FmPort->port, statsType);
+        else
+            return fman_port_get_perf_counter(&p_FmPort->port, perfType);
     }
     else /* QMI counter */
     {
         /* check that counters are enabled */
-        if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+
         {
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             return 0;
         }
 
         /* Set counter */
         switch (counter)
         {
-           case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
-                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc);
-            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
-                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc);
-            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc);
-            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
-                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc);
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+                queueType = E_FMAN_PORT_ENQ_TOTAL;
+               break;
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                queueType = E_FMAN_PORT_DEQ_TOTAL;
+               break;
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                queueType = E_FMAN_PORT_DEQ_FROM_DFLT;
+               break;
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                queueType = E_FMAN_PORT_DEQ_CONFIRM;
+               break;
             default:
-                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available"));
-                return 0;
+               REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+               return 0;
         }
+
+        return fman_port_get_qmi_counter(&p_FmPort->port, queueType);
     }
+
+    return 0;
 }
 
 t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t value)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    bool                bmiCounter = FALSE;
-    volatile uint32_t   *p_Reg;
+    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                            bmiCounter = FALSE;
+    enum fman_port_stats_counters   statsType;
+    enum fman_port_perf_counters    perfType;
+    enum fman_port_qmi_counters   queueType;
+    bool                            isStats;
+    t_Error                         errCode;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     switch (counter)
     {
-        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
-        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -4296,131 +3689,78 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
 
     if (bmiCounter)
     {
-        switch (p_FmPort->portType)
+        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType, &perfType, &isStats);
+        if (errCode != E_OK)
         {
-            case (e_FM_PORT_TYPE_RX_10G):
-            case (e_FM_PORT_TYPE_RX):
-               if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-                break;
-            case (e_FM_PORT_TYPE_TX_10G):
-            case (e_FM_PORT_TYPE_TX):
-               if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-                break;
-            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-               if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-                 break;
-            default:
-               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported port type"));
+            RETURN_ERROR(MINOR, errCode, NO_MSG);
         }
-        WRITE_UINT32(*p_Reg, value);
+        if (isStats)
+            fman_port_set_stats_counter(&p_FmPort->port, statsType, value);
+        else
+            fman_port_set_perf_counter(&p_FmPort->port, perfType, value);
     }
     else /* QMI counter */
     {
-
         /* check that counters are enabled */
-        if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        {
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+        }
 
         /* Set counter */
         switch (counter)
         {
-           case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc, value);
-                break;
-            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc, value);
-                break;
-            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc, value);
-                break;
-            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc, value);
-                break;
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+                queueType = E_FMAN_PORT_ENQ_TOTAL;
+               break;
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                queueType = E_FMAN_PORT_DEQ_TOTAL;
+               break;
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                queueType = E_FMAN_PORT_DEQ_FROM_DFLT;
+               break;
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                queueType = E_FMAN_PORT_DEQ_CONFIRM;
+               break;
             default:
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available"));
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
         }
+
+        fman_port_set_qmi_counter(&p_FmPort->port, queueType, value);
     }
 
     return E_OK;
 }
 
+
 uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
 {
     t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t        extPoolReg;
-    uint8_t         tmpPool;
-    uint8_t         i;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
         return 0;
     }
-
-    for (i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
-    {
-        extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
-        if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
-        {
-            tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
-            if (tmpPool == poolId)
-            {
-                if (extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
-                    return  GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i]);
-                else
-                {
-                    REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not enabled"));
-                    return 0;
-                }
-            }
-        }
-    }
-    REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
-    return 0;
+    return fman_port_get_bpool_counter(&p_FmPort->port, poolId);
 }
 
 t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_t value)
 {
     t_FmPort        *p_FmPort = (t_FmPort *)h_FmPort;
-    uint32_t        extPoolReg;
-    uint8_t         tmpPool;
-    uint8_t         i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
 
-
-    for (i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
-    {
-        extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
-        if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
-        {
-            tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
-            if (tmpPool == poolId)
-            {
-                if (extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
-                {
-                    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], value);
-                    return E_OK;
-                }
-                else
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not enabled"));
-            }
-        }
-    }
-    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
+    fman_port_set_bpool_counter(&p_FmPort->port, poolId, value);
+    return E_OK;
 }
-
 bool FM_PORT_IsStalled(t_Handle h_FmPort)
 {
     t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
@@ -4452,7 +3792,7 @@ t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort)
 t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t tmpReg;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -4461,12 +3801,16 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
         (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-    tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne);
     if (l4Checksum)
-        tmpReg &= ~BMI_PORT_RFNE_FRWD_DCL4C;
+        err = fman_port_modify_rx_fd_bits(&p_FmPort->port,
+                                          (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
+                                          TRUE);
     else
-        tmpReg |= BMI_PORT_RFNE_FRWD_DCL4C;
-    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne, tmpReg);
+        err = fman_port_modify_rx_fd_bits(&p_FmPort->port,
+                                          (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
+                                          FALSE);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_modify_rx_fd_bits"));
 
     return E_OK;
 }
@@ -4555,7 +3899,7 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
 
     p_FmPort->vspe = TRUE;
     p_FmPort->dfltRelativeId = p_VSPParams->dfltRelativeId;
- 
+
     tmpReg = GET_UINT32(*p_BmiStorageProfileId) & ~BMI_SP_ID_MASK;
     tmpReg |= (uint32_t)hwStoragePrflId<<BMI_SP_ID_SHIFT;
     WRITE_UINT32(*p_BmiStorageProfileId, tmpReg);
@@ -4632,10 +3976,10 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            p_BmiHpnia = &p_FmPort->port.bmi_regs->rx.fmbm_rfpne;
             break;
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            p_BmiHpnia = &p_FmPort->port.bmi_regs->oh.fmbm_ofpne;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
@@ -4701,13 +4045,13 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
-            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
+            p_BmiHpnia = &p_FmPort->port.bmi_regs->rx.fmbm_rfpne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
+            p_BmiHpnia = &p_FmPort->port.bmi_regs->oh.fmbm_ofpne;
             tmpReg = 0;
             break;
         default:
@@ -4763,10 +4107,10 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
             break;
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
@@ -4794,10 +4138,10 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         {
             case (e_FM_PORT_TYPE_RX_10G):
             case (e_FM_PORT_TYPE_RX):
-                p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
+                p_BmiCcBase = &p_FmPort->port.bmi_regs->rx.fmbm_rccb;
                 break;
             case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-                p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
+                p_BmiCcBase = &p_FmPort->port.bmi_regs->oh.fmbm_occb;
                 break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
@@ -5176,7 +4520,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
          }
- 
+
         FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
         ASSERT_COND(p_ParamsPage);
 
@@ -5695,14 +5039,12 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
 t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    bool                tmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS], opPort;
     uint8_t             priorityTmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
-    int                 i;
-    uint8_t             mod;
-    uint32_t            tmpReg = 0;
+    uint8_t             mod, index;
+    uint32_t            i, grpsMap[FMAN_PORT_CG_MAP_NUM];
+    int                 err;
 #if (DPAA_VERSION >= 11)
     int                 j;
-    t_Error             err;
 #endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
@@ -5729,19 +5071,22 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
         (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
 
-    opPort = (bool)((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? TRUE:FALSE);
-
-    /* to minimize memory access (groups may belong to the same regsiter, and may
-       be out of order), we first collect all information into a 256 booleans array,
-       representing each possible group. */
+    /* Prepare groups map array */
+    memset(grpsMap, 0, FMAN_PORT_CG_MAP_NUM * sizeof(uint32_t));
+    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+    {
+        index = (uint8_t)(p_CongestionGrps->congestionGrpsToConsider[i] / 32);
+        mod = (uint8_t)(p_CongestionGrps->congestionGrpsToConsider[i] % 32);
+        if (p_FmPort->fmRevInfo.majorRev != 4)
+            grpsMap[7 - index] |= (uint32_t)(1 << mod);
+        else
+            grpsMap[0] |= (uint32_t)(1 << mod);
+    }
 
-    memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
     memset(&priorityTmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(uint8_t));
 
     for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
     {
-        tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
-
 #if (DPAA_VERSION >= 11)
         for (j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
             if (p_CongestionGrps->pfcPrioritiesEn[i][j])
@@ -5749,35 +5094,18 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 #endif /* (DPAA_VERSION >= 11) */
     }
 
+#if (DPAA_VERSION >= 11)
     for (i=0; i<FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
     {
-        mod = (uint8_t)(i%32);
-        /* each 32 congestion groups are represented by a register */
-        if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
-            tmpReg = opPort ? GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
-                              GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)]);
-
-        /* set in the register, the bit representing the relevant congestion group. */
-
-        if (tmpArray[i])
-        {
-            tmpReg |=  (0x00000001 << (uint32_t)mod);
-
-#if (DPAA_VERSION >= 11)
             err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm,i,priorityTmpArray[i]);
             if (err)
                 return err;
+     }
 #endif /* (DPAA_VERSION >= 11) */
-        }
 
-        if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
-        {
-            if (opPort)
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
-            else
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)], tmpReg);
-        }
-    }
+    err = fman_port_add_congestion_grps(&p_FmPort->port, grpsMap);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_add_congestion_grps"));
 
     return  E_OK;
 }
@@ -5785,77 +5113,73 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    bool                tmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS], opPort;
-    int                 i;
-    uint8_t             mod;
-    uint32_t            tmpReg = 0;
+    uint8_t             mod, index;
+    uint32_t            i, grpsMap[FMAN_PORT_CG_MAP_NUM];
+    int                 err;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    /* un-necessary check of the indexes; probably will be needed in the future when there
-       will be more CGs available ....
-    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
-        if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("CG id!"));
-    */
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-#ifdef FM_NO_OP_OBSERVED_CGS
-    if ((p_FmPort->fmRevInfo.majorRev != 4) &&
-        (p_FmPort->fmRevInfo.majorRev < 6))
     {
+#ifdef FM_NO_OP_OBSERVED_CGS
+        t_FmRevisionInfo    revInfo;
+
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if (revInfo.majorRev != 4)
+        {
+            if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+               (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+        }
+        else
+#endif /* FM_NO_OP_OBSERVED_CGS */
         if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-                (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+           (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+           (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
     }
-    else
-#endif /* FM_NO_OP_OBSERVED_CGS */
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
 
-    opPort = (bool)((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? TRUE:FALSE);
-
-    /* to minimize memory access (groups may belong to the same regsiter, and may
-    be out of order), we first collect all information into a 256 booleans array,
-    representing each possible group. */
-    memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
-    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
-        tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
-
-    for (i=0; i<FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
+    /* Prepare groups map array */
+    memset(grpsMap, 0, FMAN_PORT_CG_MAP_NUM * sizeof(uint32_t));
+    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
     {
-        mod = (uint8_t)(i%32);
-        /* each 32 congestion groups are represented by a register */
-        if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
-            tmpReg = opPort ?   GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
-                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)]);
-
-        /* set in the register, the bit representing the relevant congestion group. */
-        if (tmpArray[i])
-        {
-            tmpReg &=  ~(0x00000001 << (uint32_t)mod);
+        index = (uint8_t)(p_CongestionGrps->congestionGrpsToConsider[i] / 32);
+        mod = (uint8_t)(p_CongestionGrps->congestionGrpsToConsider[i] % 32);
+        if (p_FmPort->fmRevInfo.majorRev != 4)
+            grpsMap[7 - index] |= (uint32_t)(1 << mod);
+        else
+            grpsMap[0] |= (uint32_t)(1 << mod);
+    }
 
 #if (DPAA_VERSION >= 11)
-            {
-                t_Error err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm, i, 0);
-                if (err)
-                    return err;
-            }
-#endif /* (DPAA_VERSION >= 11) */
-        }
-        if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
-        {
-            if (opPort)
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
-            else
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)], tmpReg);
-        }
+    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+    {
+    t_Error err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm,
+        p_CongestionGrps->congestionGrpsToConsider[i], 0);
+    if (err)
+        return err;
     }
+#endif /* (DPAA_VERSION >= 11) */
 
+    err = fman_port_remove_congestion_grps(&p_FmPort->port, grpsMap);
+    if (err != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_remove_congestion_grps"));
     return  E_OK;
 }
 
 #if (DPAA_VERSION >= 11)
+t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount)
+{
+    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_ParamsPage, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Ipv4OptionsCount, E_NULL_POINTER);
+
+    *p_Ipv4OptionsCount = GET_UINT32(p_FmPort->p_ParamsPage->ipfOptionsCounter);
+
+    return E_OK;
+}
 #endif /* (DPAA_VERSION >= 11) */
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
index 12be3c2..d4cc285 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
@@ -47,6 +47,7 @@
 #include "fm_sp_common.h"
 #include "fsl_fman_sp.h"
 
+#include "fsl_fman_port.h"
 
 #define __ERR_MODULE__  MODULE_FM_PORT
 
@@ -54,6 +55,7 @@
 #define MIN_EXT_BUF_SIZE                                64
 #define DATA_ALIGNMENT                                  64
 #define MAX_LIODN_OFFSET                                64
+#define MAX_PORT_FIFO_SIZE                              MIN(BMI_MAX_FIFO_SIZE, 1024*BMI_FIFO_UNITS)
 
 /**************************************************************************//**
  @Description       Memory Map defines
@@ -105,8 +107,8 @@
 #define DEFAULT_notSupported                            0xff
 
 #if (DPAA_VERSION < 11)
-#define DEFAULT_PORT_rxFifoPriElevationLevel            BMI_MAX_FIFO_SIZE
-#define DEFAULT_PORT_rxFifoThreshold                    (BMI_MAX_FIFO_SIZE*3/4)
+#define DEFAULT_PORT_rxFifoPriElevationLevel            MAX_PORT_FIFO_SIZE
+#define DEFAULT_PORT_rxFifoThreshold                    (MAX_PORT_FIFO_SIZE*3/4)
 
 #define DEFAULT_PORT_txFifoMinFillLevel                 0
 #define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
@@ -124,26 +126,22 @@
                  ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 3 : 1))
 
 #define DEFAULT_PORT_extraNumOfTasks(type)                  \
-    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
-                ((type) == e_FM_PORT_TYPE_TX_10G)) ? 8 :    \
-               ((((type) == e_FM_PORT_TYPE_RX) ||           \
-                 ((type) == e_FM_PORT_TYPE_TX)) ? 2 : 0))
+    (uint32_t)(((type) == e_FM_PORT_TYPE_RX_10G)  ? 8 :    \
+               (((type) == e_FM_PORT_TYPE_RX) ? 2 : 0))
 
 #define DEFAULT_PORT_numOfOpenDmas(type)                    \
     (uint32_t)((((type) == e_FM_PORT_TYPE_TX_10G) ||        \
                 ((type) == e_FM_PORT_TYPE_RX_10G)) ? 8 : 1 )
 
 #define DEFAULT_PORT_extraNumOfOpenDmas(type)               \
-    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
-                ((type) == e_FM_PORT_TYPE_TX_10G)) ? 8 :    \
-               ((((type) == e_FM_PORT_TYPE_RX) ||           \
-                 ((type) == e_FM_PORT_TYPE_TX)) ? 1 : 0))
+    (uint32_t)(((type) == e_FM_PORT_TYPE_RX_10G) ? 8 :    \
+               (((type) == e_FM_PORT_TYPE_RX) ? 1 : 0))
 
 #define DEFAULT_PORT_numOfFifoBufs(type)                    \
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
                 ((type) == e_FM_PORT_TYPE_TX_10G)) ? 48 :   \
-               ((((type) == e_FM_PORT_TYPE_RX) ||           \
-                 ((type) == e_FM_PORT_TYPE_TX)) ? 44 : 8))
+                ((type) == e_FM_PORT_TYPE_RX) ? 45 :        \
+                ((type) == e_FM_PORT_TYPE_TX) ? 44 : 8)
 
 #define DEFAULT_PORT_extraNumOfFifoBufs             0
 
@@ -161,7 +159,7 @@
 
 #define DEFAULT_PORT_numOfTasks(type)                       \
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
-                ((type) == e_FM_PORT_TYPE_TX_10G)) ? 14 :  \
+                ((type) == e_FM_PORT_TYPE_TX_10G)) ? 14 :   \
                (((type) == e_FM_PORT_TYPE_RX) ||            \
                  ((type) == e_FM_PORT_TYPE_TX)) ? 4 :       \
                  ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? 6 : 1)
@@ -170,17 +168,17 @@
 
 #define DEFAULT_PORT_numOfOpenDmas(type)                    \
     (uint32_t)(((type) == e_FM_PORT_TYPE_RX_10G) ? 8 :      \
-               ((type) == e_FM_PORT_TYPE_TX_10G) ? 12 :    \
+               ((type) == e_FM_PORT_TYPE_TX_10G) ? 12 :     \
                ((type) == e_FM_PORT_TYPE_RX)     ? 2 :      \
                ((type) == e_FM_PORT_TYPE_TX)     ? 3 :      \
-               ((type) == e_FM_PORT_TYPE_OH_HOST_COMMAND) ? 2 : 4 )
+               ((type) == e_FM_PORT_TYPE_OH_HOST_COMMAND) ? 2 : 4)
 
 #define DEFAULT_PORT_extraNumOfOpenDmas(type)       0
 
 #define DEFAULT_PORT_numOfFifoBufs(type)                   \
     (uint32_t) (((type) == e_FM_PORT_TYPE_RX_10G) ? 96 : \
                 ((type) == e_FM_PORT_TYPE_TX_10G) ? 64 : \
-                ((type) == e_FM_PORT_TYPE_OH_HOST_COMMAND) ? 10 : 50 )
+                ((type) == e_FM_PORT_TYPE_OH_HOST_COMMAND) ? 10 : 50)
 
 #define DEFAULT_PORT_extraNumOfFifoBufs             0
 
@@ -491,7 +489,6 @@ typedef _Packed struct
 #define BMI_SP_ID_MASK                          0xff000000
 #define BMI_SP_ID_SHIFT                         24
 #define BMI_SP_EN                               0x01000000
-#define BMI_EBD_EN                              0x80000000
 #endif /* (DPAA_VERSION >= 11) */
 
 #define BMI_PORT_CFG_EN                         0x80000000
@@ -500,7 +497,6 @@ typedef _Packed struct
 #define BMI_PORT_CFG_IM                         0x01000000
 #define BMI_PORT_STATUS_BSY                     0x80000000
 #define BMI_COUNTERS_EN                         0x80000000
-#define BMI_DMA_ATTR_WRITE_OPTIMIZE             FMAN_SP_DMA_ATTR_WRITE_OPTIMIZE
 
 #define BMI_PORT_RFNE_FRWD_DCL4C                0x10000000
 #define BMI_PORT_RFNE_FRWD_RPD                  0x40000000
@@ -510,7 +506,6 @@ typedef _Packed struct
 #define BMI_CMD_MR_SLEAC                        0x00100000
 #define BMI_CMD_MR_MA                           0x00080000
 #define BMI_CMD_MR_DEAS                         0x00040000
-#define BMI_CMD_TX_MR_DEF                       (0)
 #define BMI_CMD_RX_MR_DEF                       (BMI_CMD_MR_LEAC | \
                                                  BMI_CMD_MR_SLEAC | \
                                                  BMI_CMD_MR_MA | \
@@ -523,11 +518,6 @@ typedef _Packed struct
 #define BMI_CMD_ATTR_MACCMD_SECURED             0x00001000
 #define BMI_CMD_ATTR_MACCMD_SC_MASK             0x00000f00
 
-#define BMI_EXT_BUF_POOL_EN_COUNTER             FMAN_SP_EXT_BUF_POOL_EN_COUNTER
-#define BMI_EXT_BUF_POOL_VALID                  FMAN_SP_EXT_BUF_POOL_VALID
-
-#define BMI_EXT_BUF_POOL_BACKUP                 FMAN_SP_EXT_BUF_POOL_BACKUP
-
 #define BMI_EXT_BUF_POOL_ID_MASK                0x003F0000
 #define BMI_STATUS_RX_MASK_UNUSED               (uint32_t)(~(FM_PORT_FRM_ERR_DMA                    | \
                                                              FM_PORT_FRM_ERR_PHYSICAL               | \
@@ -592,7 +582,6 @@ typedef _Packed struct
 
 /* shifts */
 #define BMI_PORT_CFG_MS_SEL_SHIFT               16
-#define BMI_DMA_ATTR_SWP_SHIFT                  FMAN_SP_DMA_ATTR_SWP_SHIFT
 #define BMI_DMA_ATTR_IC_CACHE_SHIFT             FMAN_SP_DMA_ATTR_IC_CACHE_SHIFT
 #define BMI_DMA_ATTR_HDR_CACHE_SHIFT            FMAN_SP_DMA_ATTR_HDR_CACHE_SHIFT
 #define BMI_DMA_ATTR_SG_CACHE_SHIFT             FMAN_SP_DMA_ATTR_SG_CACHE_SHIFT
@@ -606,14 +595,10 @@ typedef _Packed struct
 #define BMI_RX_FRAME_END_CS_IGNORE_SHIFT        24
 #define BMI_RX_FRAME_END_CUT_SHIFT              16
 
-#define BMI_IC_TO_EXT_SHIFT                     FMAN_SP_IC_TO_EXT_SHIFT
-#define BMI_IC_FROM_INT_SHIFT                   FMAN_SP_IC_FROM_INT_SHIFT
 #define BMI_IC_SIZE_SHIFT                       FMAN_SP_IC_SIZE_SHIFT
 
 #define BMI_INT_BUF_MARG_SHIFT                  28
 
-#define BMI_EXT_BUF_MARG_START_SHIFT            FMAN_SP_EXT_BUF_MARG_START_SHIFT
-#define BMI_SG_DISABLE                          FMAN_SP_SG_DISABLE
 #define BMI_EXT_BUF_MARG_END_SHIFT              FMAN_SP_EXT_BUF_MARG_END_SHIFT
 
 #define BMI_CMD_ATTR_COLOR_SHIFT                26
@@ -623,16 +608,11 @@ typedef _Packed struct
 #define BMI_CMD_ATTR_MACCMD_SECURED_SHIFT       12
 #define BMI_CMD_ATTR_MACCMD_SC_SHIFT            8
 
-#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT         FMAN_SP_POOL_DEP_NUM_OF_POOLS_SHIFT
 #define BMI_POOL_DEP_NUM_OF_POOLS_VECTOR_SHIFT  24
 
-#define BMI_EXT_BUF_POOL_ID_SHIFT               FMAN_SP_EXT_BUF_POOL_ID_SHIFT
 #define BMI_TX_FIFO_MIN_FILL_SHIFT              16
-#define BMI_FIFO_PIPELINE_DEPTH_SHIFT           12
 #define BMI_TX_LOW_COMF_SHIFT                   0
 
-#define BMI_FRAME_END_CS_IGNORE_SHIFT           24
-
 #define BMI_PERFORMANCE_TASK_COMP_SHIFT         24
 #define BMI_PERFORMANCE_PORT_COMP_SHIFT         16
 #define BMI_PERFORMANCE_DMA_COMP_SHIFT          12
@@ -658,6 +638,7 @@ typedef _Packed struct
 #define MAX_BURST_SIZE                          1024
 #define MIN_NUM_OF_OP_DMAS                      2
 
+
 /**************************************************************************//**
  @Description       QMI defines
 *//***************************************************************************/
@@ -810,6 +791,7 @@ typedef struct {
 
 
 typedef struct {
+    struct fman_port_cfg                dfltCfg;
     uint32_t                            dfltFqid;
     uint32_t                            confFqid;
     uint32_t                            errFqid;
@@ -873,6 +855,7 @@ typedef struct t_FmPortRxPoolsParams
 } t_FmPortRxPoolsParams;
 
 typedef struct {
+    struct fman_port            port;
     t_Handle                    h_Fm;
     t_Handle                    h_FmPcd;
     t_Handle                    h_FmMuram;
@@ -902,7 +885,6 @@ typedef struct {
     /* Independent-Mode parameters support */
     bool                        imEn;
     t_FmMacIm                   im;
-    uint8_t                     fifoDeqPipelineDepth;
     volatile bool               lock;
     t_Handle                    h_Spinlock;
     t_FmPortExceptionCallback   *f_Exception;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c
index bf358a5..7f70cc9 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c
@@ -59,7 +59,7 @@ static void ImException(t_Handle h_FmPort, uint32_t event)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
-    ASSERT_COND(((event & IM_EV_RX) && FmIsMaster(p_FmPort->h_Fm)) ||
+    ASSERT_COND(((event & (IM_EV_RX | IM_EV_BSY)) && FmIsMaster(p_FmPort->h_Fm)) ||
                 !FmIsMaster(p_FmPort->h_Fm));
 
     if (event & IM_EV_RX)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
new file mode 100755
index 0000000..2e4ff3b
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
@@ -0,0 +1,1570 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "common/general.h"
+
+#include "fman_common.h"
+#include "fsl_fman_port.h"
+
+
+/* problem Eyal: the following should not be here*/
+#define NIA_FM_CTL_AC_NO_IPACC_PRE_BMI_ENQ_FRAME        0x00000028
+
+static uint32_t get_no_pcd_nia_bmi_ac_enc_frame(struct fman_port_cfg *cfg)
+{
+    if (cfg->errata_A006675)
+        return NIA_ENG_FM_CTL |
+            NIA_FM_CTL_AC_NO_IPACC_PRE_BMI_ENQ_FRAME;
+    else
+        return NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME;
+}
+
+static int init_bmi_rx(struct fman_port *port,
+        struct fman_port_cfg *cfg,
+        struct fman_port_params *params)
+{
+    struct fman_port_rx_bmi_regs *regs = &port->bmi_regs->rx;
+    uint32_t tmp;
+
+    /* Rx Configuration register */
+    tmp = 0;
+    if (port->im_en)
+        tmp |= BMI_PORT_CFG_IM;
+    else if (cfg->discard_override)
+        tmp |= BMI_PORT_CFG_FDOVR;
+    iowrite32be(tmp, &regs->fmbm_rcfg);
+
+    /* DMA attributes */
+    tmp = (uint32_t)cfg->dma_swap_data << BMI_DMA_ATTR_SWP_SHIFT;
+    if (cfg->dma_ic_stash_on)
+        tmp |= BMI_DMA_ATTR_IC_STASH_ON;
+    if (cfg->dma_header_stash_on)
+        tmp |= BMI_DMA_ATTR_HDR_STASH_ON;
+    if (cfg->dma_sg_stash_on)
+        tmp |= BMI_DMA_ATTR_SG_STASH_ON;
+    if (cfg->dma_write_optimize)
+        tmp |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+    iowrite32be(tmp, &regs->fmbm_rda);
+
+    /* Rx FIFO parameters */
+    tmp = (cfg->rx_pri_elevation / FMAN_PORT_BMI_FIFO_UNITS - 1) <<
+            BMI_RX_FIFO_PRI_ELEVATION_SHIFT;
+    tmp |= cfg->rx_fifo_thr / FMAN_PORT_BMI_FIFO_UNITS - 1;
+    iowrite32be(tmp, &regs->fmbm_rfp);
+
+    if (cfg->excessive_threshold_register)
+        /* always allow access to the extra resources */
+        iowrite32be(BMI_RX_FIFO_THRESHOLD_ETHE, &regs->fmbm_reth);
+
+    /* Frame end data */
+    tmp = (uint32_t)cfg->checksum_bytes_ignore <<
+            BMI_RX_FRAME_END_CS_IGNORE_SHIFT;
+    tmp |= (uint32_t)cfg->rx_cut_end_bytes <<
+            BMI_RX_FRAME_END_CUT_SHIFT;
+    if (cfg->errata_A006320)
+        tmp &= 0xffe0ffff;
+    iowrite32be(tmp, &regs->fmbm_rfed);
+
+    /* Internal context parameters */
+    tmp = ((uint32_t)cfg->ic_ext_offset / FMAN_PORT_IC_OFFSET_UNITS) <<
+            BMI_IC_TO_EXT_SHIFT;
+    tmp |= ((uint32_t)cfg->ic_int_offset / FMAN_PORT_IC_OFFSET_UNITS) <<
+            BMI_IC_FROM_INT_SHIFT;
+    tmp |= cfg->ic_size / FMAN_PORT_IC_OFFSET_UNITS;
+    iowrite32be(tmp, &regs->fmbm_ricp);
+
+    /* Internal buffer offset */
+    tmp = ((uint32_t)cfg->int_buf_start_margin / FMAN_PORT_IC_OFFSET_UNITS)
+            << BMI_INT_BUF_MARG_SHIFT;
+    iowrite32be(tmp, &regs->fmbm_rim);
+
+    /* External buffer margins */
+    if (!port->im_en)
+    {
+        tmp = (uint32_t)cfg->ext_buf_start_margin <<
+                BMI_EXT_BUF_MARG_START_SHIFT;
+        tmp |= (uint32_t)cfg->ext_buf_end_margin;
+        if (cfg->fmbm_rebm_has_sgd && cfg->no_scatter_gather)
+            tmp |= BMI_SG_DISABLE;
+        iowrite32be(tmp, &regs->fmbm_rebm);
+    }
+
+    /* Frame attributes */
+    tmp = BMI_CMD_RX_MR_DEF;
+    if (!port->im_en)
+    {
+        tmp |= BMI_CMD_ATTR_ORDER;
+        tmp |= (uint32_t)cfg->color << BMI_CMD_ATTR_COLOR_SHIFT;
+        if (cfg->sync_req)
+            tmp |= BMI_CMD_ATTR_SYNC;
+    }
+    iowrite32be(tmp, &regs->fmbm_rfca);
+
+    /* NIA */
+    if (port->im_en)
+        tmp = NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_RX;
+    else
+    {
+        tmp = (uint32_t)cfg->rx_fd_bits << BMI_NEXT_ENG_FD_BITS_SHIFT;
+        tmp |= get_no_pcd_nia_bmi_ac_enc_frame(cfg);
+    }
+    iowrite32be(tmp, &regs->fmbm_rfne);
+
+    /* Enqueue NIA */
+    iowrite32be(NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR, &regs->fmbm_rfene);
+
+    /* Default/error queues */
+    if (!port->im_en)
+    {
+        iowrite32be((params->dflt_fqid & 0x00FFFFFF), &regs->fmbm_rfqid);
+        iowrite32be((params->err_fqid & 0x00FFFFFF), &regs->fmbm_refqid);
+    }
+
+    /* Discard/error masks */
+    iowrite32be(params->discard_mask, &regs->fmbm_rfsdm);
+    iowrite32be(params->err_mask, &regs->fmbm_rfsem);
+
+    /* Statistics counters */
+    tmp = 0;
+    if (cfg->stats_counters_enable)
+        tmp = BMI_COUNTERS_EN;
+    iowrite32be(tmp, &regs->fmbm_rstc);
+
+    /* Performance counters */
+    fman_port_set_perf_cnt_params(port, &cfg->perf_cnt_params);
+    tmp = 0;
+    if (cfg->perf_counters_enable)
+        tmp = BMI_COUNTERS_EN;
+    iowrite32be(tmp, &regs->fmbm_rpc);
+
+    return 0;
+}
+
+static int init_bmi_tx(struct fman_port *port,
+        struct fman_port_cfg *cfg,
+        struct fman_port_params *params)
+{
+    struct fman_port_tx_bmi_regs *regs = &port->bmi_regs->tx;
+    uint32_t tmp;
+
+    /* Tx Configuration register */
+    tmp = 0;
+    if (port->im_en)
+        tmp |= BMI_PORT_CFG_IM;
+    iowrite32be(tmp, &regs->fmbm_tcfg);
+
+    /* DMA attributes */
+    tmp = (uint32_t)cfg->dma_swap_data << BMI_DMA_ATTR_SWP_SHIFT;
+    if (cfg->dma_ic_stash_on)
+        tmp |= BMI_DMA_ATTR_IC_STASH_ON;
+    if (cfg->dma_header_stash_on)
+        tmp |= BMI_DMA_ATTR_HDR_STASH_ON;
+    if (cfg->dma_sg_stash_on)
+        tmp |= BMI_DMA_ATTR_SG_STASH_ON;
+    iowrite32be(tmp, &regs->fmbm_tda);
+
+    /* Tx FIFO parameters */
+    tmp = (cfg->tx_fifo_min_level / FMAN_PORT_BMI_FIFO_UNITS) <<
+            BMI_TX_FIFO_MIN_FILL_SHIFT;
+    tmp |= ((uint32_t)cfg->tx_fifo_deq_pipeline_depth - 1) <<
+            BMI_FIFO_PIPELINE_DEPTH_SHIFT;
+    tmp |= (uint32_t)(cfg->tx_fifo_low_comf_level /
+            FMAN_PORT_BMI_FIFO_UNITS - 1);
+    iowrite32be(tmp, &regs->fmbm_tfp);
+
+    /* Frame end data */
+    tmp = (uint32_t)cfg->checksum_bytes_ignore <<
+            BMI_FRAME_END_CS_IGNORE_SHIFT;
+    iowrite32be(tmp, &regs->fmbm_tfed);
+
+    /* Internal context parameters */
+    if (!port->im_en)
+    {
+        tmp = ((uint32_t)cfg->ic_ext_offset / FMAN_PORT_IC_OFFSET_UNITS) <<
+                BMI_IC_TO_EXT_SHIFT;
+        tmp |= ((uint32_t)cfg->ic_int_offset / FMAN_PORT_IC_OFFSET_UNITS) <<
+                BMI_IC_FROM_INT_SHIFT;
+        tmp |= cfg->ic_size / FMAN_PORT_IC_OFFSET_UNITS;
+        iowrite32be(tmp, &regs->fmbm_ticp);
+    }
+    /* Frame attributes */
+    tmp = BMI_CMD_TX_MR_DEF;
+    if (port->im_en)
+        tmp |= BMI_CMD_MR_DEAS;
+    else
+    {
+        tmp |= BMI_CMD_ATTR_ORDER;
+        tmp |= (uint32_t)cfg->color << BMI_CMD_ATTR_COLOR_SHIFT;
+    }
+    iowrite32be(tmp, &regs->fmbm_tfca);
+
+    /* Dequeue NIA + enqueue NIA */
+    if (port->im_en)
+    {
+        iowrite32be(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX, &regs->fmbm_tfdne);
+        iowrite32be(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX, &regs->fmbm_tfene);
+    }
+    else
+    {
+        iowrite32be(NIA_ENG_QMI_DEQ, &regs->fmbm_tfdne);
+        iowrite32be(NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR, &regs->fmbm_tfene);
+        if (cfg->fmbm_tfne_has_features)
+            iowrite32be(!params->dflt_fqid ?
+                BMI_EBD_EN | NIA_BMI_AC_FETCH_ALL_FRAME :
+                NIA_BMI_AC_FETCH_ALL_FRAME, &regs->fmbm_tfne);
+        if (!params->dflt_fqid && params->dont_release_buf)
+        {
+            iowrite32be(0x00FFFFFF, &regs->fmbm_tcfqid);
+            iowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE, &regs->fmbm_tfene);
+            if (cfg->fmbm_tfne_has_features)
+                iowrite32be(ioread32be(&regs->fmbm_tfne) & ~BMI_EBD_EN, &regs->fmbm_tfne);
+        }
+    }
+
+    /* Confirmation/error queues */
+    if (!port->im_en)
+    {
+        if (params->dflt_fqid || !params->dont_release_buf)
+            iowrite32be(params->dflt_fqid & 0x00FFFFFF, &regs->fmbm_tcfqid);
+        iowrite32be((params->err_fqid & 0x00FFFFFF), &regs->fmbm_tefqid);
+    }
+    /* Statistics counters */
+    tmp = 0;
+    if (cfg->stats_counters_enable)
+        tmp = BMI_COUNTERS_EN;
+    iowrite32be(tmp, &regs->fmbm_tstc);
+
+    /* Performance counters */
+    fman_port_set_perf_cnt_params(port, &cfg->perf_cnt_params);
+    tmp = 0;
+    if (cfg->perf_counters_enable)
+        tmp = BMI_COUNTERS_EN;
+    iowrite32be(tmp, &regs->fmbm_tpc);
+
+    return 0;
+}
+
+static int init_bmi_oh(struct fman_port *port,
+        struct fman_port_cfg *cfg,
+        struct fman_port_params *params)
+{
+    struct fman_port_oh_bmi_regs *regs = &port->bmi_regs->oh;
+    uint32_t tmp;
+
+    /* OP Configuration register */
+    tmp = 0;
+    if (cfg->discard_override)
+        tmp |= BMI_PORT_CFG_FDOVR;
+    iowrite32be(tmp, &regs->fmbm_ocfg);
+
+    /* DMA attributes */
+    tmp = (uint32_t)cfg->dma_swap_data << BMI_DMA_ATTR_SWP_SHIFT;
+    if (cfg->dma_ic_stash_on)
+        tmp |= BMI_DMA_ATTR_IC_STASH_ON;
+    if (cfg->dma_header_stash_on)
+        tmp |= BMI_DMA_ATTR_HDR_STASH_ON;
+    if (cfg->dma_sg_stash_on)
+        tmp |= BMI_DMA_ATTR_SG_STASH_ON;
+    if (cfg->dma_write_optimize)
+        tmp |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+    iowrite32be(tmp, &regs->fmbm_oda);
+
+    /* Tx FIFO parameters */
+    tmp = ((uint32_t)cfg->tx_fifo_deq_pipeline_depth - 1) <<
+            BMI_FIFO_PIPELINE_DEPTH_SHIFT;
+    iowrite32be(tmp, &regs->fmbm_ofp);
+
+    /* Internal context parameters */
+    tmp = ((uint32_t)cfg->ic_ext_offset / FMAN_PORT_IC_OFFSET_UNITS) <<
+            BMI_IC_TO_EXT_SHIFT;
+    tmp |= ((uint32_t)cfg->ic_int_offset / FMAN_PORT_IC_OFFSET_UNITS) <<
+            BMI_IC_FROM_INT_SHIFT;
+    tmp |= cfg->ic_size / FMAN_PORT_IC_OFFSET_UNITS;
+    iowrite32be(tmp, &regs->fmbm_oicp);
+
+    /* Frame attributes */
+    tmp = BMI_CMD_OP_MR_DEF;
+    tmp |= (uint32_t)cfg->color << BMI_CMD_ATTR_COLOR_SHIFT;
+    if (cfg->sync_req)
+        tmp |= BMI_CMD_ATTR_SYNC;
+    if (port->type == E_FMAN_PORT_TYPE_OP)
+        tmp |= BMI_CMD_ATTR_ORDER;
+    iowrite32be(tmp, &regs->fmbm_ofca);
+
+    /* Internal buffer offset */
+    tmp = ((uint32_t)cfg->int_buf_start_margin / FMAN_PORT_IC_OFFSET_UNITS)
+            << BMI_INT_BUF_MARG_SHIFT;
+    iowrite32be(tmp, &regs->fmbm_oim);
+
+    /* Dequeue NIA */
+    iowrite32be(NIA_ENG_QMI_DEQ, &regs->fmbm_ofdne);
+
+    /* NIA and Enqueue NIA */
+    if (port->type == E_FMAN_PORT_TYPE_HC) {
+        iowrite32be(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_HC,
+                &regs->fmbm_ofne);
+        iowrite32be(NIA_ENG_QMI_ENQ, &regs->fmbm_ofene);
+    } else {
+        iowrite32be(get_no_pcd_nia_bmi_ac_enc_frame(cfg),
+                &regs->fmbm_ofne);
+        iowrite32be(NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR,
+                &regs->fmbm_ofene);
+    }
+
+    /* Default/error queues */
+    iowrite32be((params->dflt_fqid & 0x00FFFFFF), &regs->fmbm_ofqid);
+    iowrite32be((params->err_fqid & 0x00FFFFFF), &regs->fmbm_oefqid);
+
+    /* Discard/error masks */
+    if (port->type == E_FMAN_PORT_TYPE_OP) {
+        iowrite32be(params->discard_mask, &regs->fmbm_ofsdm);
+        iowrite32be(params->err_mask, &regs->fmbm_ofsem);
+    }
+
+    /* Statistics counters */
+    tmp = 0;
+    if (cfg->stats_counters_enable)
+        tmp = BMI_COUNTERS_EN;
+    iowrite32be(tmp, &regs->fmbm_ostc);
+
+    /* Performance counters */
+    fman_port_set_perf_cnt_params(port, &cfg->perf_cnt_params);
+    tmp = 0;
+    if (cfg->perf_counters_enable)
+        tmp = BMI_COUNTERS_EN;
+    iowrite32be(tmp, &regs->fmbm_opc);
+
+    return 0;
+}
+
+static int init_qmi(struct fman_port *port,
+        struct fman_port_cfg *cfg,
+        struct fman_port_params *params)
+{
+    struct fman_port_qmi_regs *regs = port->qmi_regs;
+    uint32_t tmp;
+
+    tmp = 0;
+    if (cfg->queue_counters_enable)
+        tmp |= QMI_PORT_CFG_EN_COUNTERS;
+    iowrite32be(tmp, &regs->fmqm_pnc);
+
+    /* Rx port configuration */
+    if ((port->type == E_FMAN_PORT_TYPE_RX) ||
+            (port->type == E_FMAN_PORT_TYPE_RX_10G)) {
+        /* Enqueue NIA */
+        iowrite32be(NIA_ENG_BMI | NIA_BMI_AC_RELEASE, &regs->fmqm_pnen);
+        return 0;
+    }
+
+    /* Continue with Tx and O/H port configuration */
+    if ((port->type == E_FMAN_PORT_TYPE_TX) ||
+            (port->type == E_FMAN_PORT_TYPE_TX_10G)) {
+        /* Enqueue NIA */
+        iowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE,
+                &regs->fmqm_pnen);
+        /* Dequeue NIA */
+        iowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX, &regs->fmqm_pndn);
+    } else {
+        /* Enqueue NIA */
+        iowrite32be(NIA_ENG_BMI | NIA_BMI_AC_RELEASE, &regs->fmqm_pnen);
+        /* Dequeue NIA */
+        iowrite32be(NIA_ENG_BMI | NIA_BMI_AC_FETCH, &regs->fmqm_pndn);
+    }
+
+    /* Dequeue Configuration register */
+    tmp = 0;
+    if (cfg->deq_high_pri)
+        tmp |= QMI_DEQ_CFG_PRI;
+
+    switch (cfg->deq_type) {
+    case E_FMAN_PORT_DEQ_BY_PRI:
+        tmp |= QMI_DEQ_CFG_TYPE1;
+        break;
+    case E_FMAN_PORT_DEQ_ACTIVE_FQ:
+        tmp |= QMI_DEQ_CFG_TYPE2;
+        break;
+    case E_FMAN_PORT_DEQ_ACTIVE_FQ_NO_ICS:
+        tmp |= QMI_DEQ_CFG_TYPE3;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    if (cfg->qmi_deq_options_support) {
+        if ((port->type == E_FMAN_PORT_TYPE_HC) &&
+            (cfg->deq_prefetch_opt != E_FMAN_PORT_DEQ_NO_PREFETCH))
+            return -EINVAL;
+
+        switch (cfg->deq_prefetch_opt) {
+        case E_FMAN_PORT_DEQ_NO_PREFETCH:
+            break;
+        case E_FMAN_PORT_DEQ_PART_PREFETCH:
+            tmp |= QMI_DEQ_CFG_PREFETCH_PARTIAL;
+            break;
+        case E_FMAN_PORT_DEQ_FULL_PREFETCH:
+            tmp |= QMI_DEQ_CFG_PREFETCH_FULL;
+            break;
+        default:
+            return -EINVAL;
+        }
+    }
+    tmp |= (uint32_t)(params->deq_sp & QMI_DEQ_CFG_SP_MASK) <<
+            QMI_DEQ_CFG_SP_SHIFT;
+    tmp |= cfg->deq_byte_cnt;
+    iowrite32be(tmp, &regs->fmqm_pndc);
+
+    return 0;
+}
+
+static void get_rx_stats_reg(struct fman_port *port,
+        enum fman_port_stats_counters counter,
+        uint32_t **stats_reg)
+{
+    struct fman_port_rx_bmi_regs *regs = &port->bmi_regs->rx;
+
+    switch (counter) {
+    case E_FMAN_PORT_STATS_CNT_FRAME:
+        *stats_reg = &regs->fmbm_rfrc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_DISCARD:
+        *stats_reg = &regs->fmbm_rfdc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_DEALLOC_BUF:
+        *stats_reg = &regs->fmbm_rbdc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_RX_BAD_FRAME:
+        *stats_reg = &regs->fmbm_rfbc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_RX_LARGE_FRAME:
+        *stats_reg = &regs->fmbm_rlfc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_RX_OUT_OF_BUF:
+        *stats_reg = &regs->fmbm_rodc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_FILTERED_FRAME:
+        *stats_reg = &regs->fmbm_rffc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_DMA_ERR:
+        *stats_reg = &regs->fmbm_rfldec;
+        break;
+    default:
+        *stats_reg = NULL;
+    }
+}
+
+static void get_tx_stats_reg(struct fman_port *port,
+        enum fman_port_stats_counters counter,
+        uint32_t **stats_reg)
+{
+    struct fman_port_tx_bmi_regs *regs = &port->bmi_regs->tx;
+
+    switch (counter) {
+    case E_FMAN_PORT_STATS_CNT_FRAME:
+        *stats_reg = &regs->fmbm_tfrc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_DISCARD:
+        *stats_reg = &regs->fmbm_tfdc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_DEALLOC_BUF:
+        *stats_reg = &regs->fmbm_tbdc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_LEN_ERR:
+        *stats_reg = &regs->fmbm_tfledc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT:
+        *stats_reg = &regs->fmbm_tfufdc;
+        break;
+    default:
+        *stats_reg = NULL;
+    }
+}
+
+static void get_oh_stats_reg(struct fman_port *port,
+        enum fman_port_stats_counters counter,
+        uint32_t **stats_reg)
+{
+    struct fman_port_oh_bmi_regs *regs = &port->bmi_regs->oh;
+
+    switch (counter) {
+    case E_FMAN_PORT_STATS_CNT_FRAME:
+        *stats_reg = &regs->fmbm_ofrc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_DISCARD:
+        *stats_reg = &regs->fmbm_ofdc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_DEALLOC_BUF:
+        *stats_reg = &regs->fmbm_obdc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_FILTERED_FRAME:
+        *stats_reg = &regs->fmbm_offc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_DMA_ERR:
+        *stats_reg = &regs->fmbm_ofldec;
+        break;
+    case E_FMAN_PORT_STATS_CNT_LEN_ERR:
+        *stats_reg = &regs->fmbm_ofledc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT:
+        *stats_reg = &regs->fmbm_ofufdc;
+        break;
+    case E_FMAN_PORT_STATS_CNT_WRED_DISCARD:
+        *stats_reg = &regs->fmbm_ofwdc;
+        break;
+    default:
+        *stats_reg = NULL;
+    }
+}
+
+static void get_rx_perf_reg(struct fman_port *port,
+        enum fman_port_perf_counters counter,
+        uint32_t **perf_reg)
+{
+    struct fman_port_rx_bmi_regs *regs = &port->bmi_regs->rx;
+
+    switch (counter) {
+    case E_FMAN_PORT_PERF_CNT_CYCLE:
+        *perf_reg = &regs->fmbm_rccn;
+        break;
+    case E_FMAN_PORT_PERF_CNT_TASK_UTIL:
+        *perf_reg = &regs->fmbm_rtuc;
+        break;
+    case E_FMAN_PORT_PERF_CNT_QUEUE_UTIL:
+        *perf_reg = &regs->fmbm_rrquc;
+        break;
+    case E_FMAN_PORT_PERF_CNT_DMA_UTIL:
+        *perf_reg = &regs->fmbm_rduc;
+        break;
+    case E_FMAN_PORT_PERF_CNT_FIFO_UTIL:
+        *perf_reg = &regs->fmbm_rfuc;
+        break;
+    case E_FMAN_PORT_PERF_CNT_RX_PAUSE:
+        *perf_reg = &regs->fmbm_rpac;
+        break;
+    default:
+        *perf_reg = NULL;
+    }
+}
+
+static void get_tx_perf_reg(struct fman_port *port,
+        enum fman_port_perf_counters counter,
+        uint32_t **perf_reg)
+{
+    struct fman_port_tx_bmi_regs *regs = &port->bmi_regs->tx;
+
+    switch (counter) {
+    case E_FMAN_PORT_PERF_CNT_CYCLE:
+        *perf_reg = &regs->fmbm_tccn;
+        break;
+    case E_FMAN_PORT_PERF_CNT_TASK_UTIL:
+        *perf_reg = &regs->fmbm_ttuc;
+        break;
+    case E_FMAN_PORT_PERF_CNT_QUEUE_UTIL:
+        *perf_reg = &regs->fmbm_ttcquc;
+        break;
+    case E_FMAN_PORT_PERF_CNT_DMA_UTIL:
+        *perf_reg = &regs->fmbm_tduc;
+        break;
+    case E_FMAN_PORT_PERF_CNT_FIFO_UTIL:
+        *perf_reg = &regs->fmbm_tfuc;
+        break;
+    default:
+        *perf_reg = NULL;
+    }
+}
+
+static void get_oh_perf_reg(struct fman_port *port,
+        enum fman_port_perf_counters counter,
+        uint32_t **perf_reg)
+{
+    struct fman_port_oh_bmi_regs *regs = &port->bmi_regs->oh;
+
+    switch (counter) {
+    case E_FMAN_PORT_PERF_CNT_CYCLE:
+        *perf_reg = &regs->fmbm_occn;
+        break;
+    case E_FMAN_PORT_PERF_CNT_TASK_UTIL:
+        *perf_reg = &regs->fmbm_otuc;
+        break;
+    case E_FMAN_PORT_PERF_CNT_DMA_UTIL:
+        *perf_reg = &regs->fmbm_oduc;
+        break;
+    case E_FMAN_PORT_PERF_CNT_FIFO_UTIL:
+        *perf_reg = &regs->fmbm_ofuc;
+        break;
+    default:
+        *perf_reg = NULL;
+    }
+}
+
+static void get_qmi_counter_reg(struct fman_port *port,
+        enum fman_port_qmi_counters  counter,
+        uint32_t **queue_reg)
+{
+    struct fman_port_qmi_regs *regs = port->qmi_regs;
+
+    switch (counter) {
+    case E_FMAN_PORT_ENQ_TOTAL:
+        *queue_reg = &regs->fmqm_pnetfc;
+        break;
+    case E_FMAN_PORT_DEQ_TOTAL:
+        if ((port->type == E_FMAN_PORT_TYPE_RX) ||
+                (port->type == E_FMAN_PORT_TYPE_RX_10G))
+            /* Counter not available for Rx ports */
+            *queue_reg = NULL;
+        else
+            *queue_reg = &regs->fmqm_pndtfc;
+        break;
+    case E_FMAN_PORT_DEQ_FROM_DFLT:
+        if ((port->type == E_FMAN_PORT_TYPE_RX) ||
+                (port->type == E_FMAN_PORT_TYPE_RX_10G))
+            /* Counter not available for Rx ports */
+            *queue_reg = NULL;
+        else
+            *queue_reg = &regs->fmqm_pndfdc;
+        break;
+    case E_FMAN_PORT_DEQ_CONFIRM:
+        if ((port->type == E_FMAN_PORT_TYPE_RX) ||
+                (port->type == E_FMAN_PORT_TYPE_RX_10G))
+            /* Counter not available for Rx ports */
+            *queue_reg = NULL;
+        else
+            *queue_reg = &regs->fmqm_pndcc;
+        break;
+    default:
+        *queue_reg = NULL;
+    }
+}
+
+void fman_port_defconfig(struct fman_port_cfg *cfg, enum fman_port_type type)
+{
+    cfg->dma_swap_data = E_FMAN_PORT_DMA_NO_SWAP;
+    cfg->dma_ic_stash_on = FALSE;
+    cfg->dma_header_stash_on = FALSE;
+    cfg->dma_sg_stash_on = FALSE;
+    cfg->dma_write_optimize = TRUE;
+    cfg->color = E_FMAN_PORT_COLOR_GREEN;
+    cfg->discard_override = FALSE;
+    cfg->checksum_bytes_ignore = 0;
+    cfg->rx_cut_end_bytes = 4;
+    cfg->rx_pri_elevation = ((0x3FF + 1) * FMAN_PORT_BMI_FIFO_UNITS);
+    cfg->rx_fifo_thr = ((0x3FF + 1) * FMAN_PORT_BMI_FIFO_UNITS);
+    cfg->rx_fd_bits = 0;
+    cfg->ic_ext_offset = 0;
+    cfg->ic_int_offset = 0;
+    cfg->ic_size = 0;
+    cfg->int_buf_start_margin = 0;
+    cfg->ext_buf_start_margin = 0;
+    cfg->ext_buf_end_margin = 0;
+    cfg->tx_fifo_min_level  = 0;
+    cfg->tx_fifo_low_comf_level = (5 * KILOBYTE);
+    cfg->stats_counters_enable = TRUE;
+    cfg->perf_counters_enable = TRUE;
+    cfg->deq_type = E_FMAN_PORT_DEQ_BY_PRI;
+
+    if (type == E_FMAN_PORT_TYPE_HC) {
+        cfg->sync_req = FALSE;
+        cfg->deq_prefetch_opt = E_FMAN_PORT_DEQ_NO_PREFETCH;
+    } else {
+        cfg->sync_req = TRUE;
+        cfg->deq_prefetch_opt = E_FMAN_PORT_DEQ_FULL_PREFETCH;
+    }
+
+    if (type == E_FMAN_PORT_TYPE_TX_10G) {
+        cfg->tx_fifo_deq_pipeline_depth = 4;
+        cfg->deq_high_pri = TRUE;
+        cfg->deq_byte_cnt = 0x1400;
+    } else {
+        if ((type == E_FMAN_PORT_TYPE_HC) ||
+                (type == E_FMAN_PORT_TYPE_OP))
+            cfg->tx_fifo_deq_pipeline_depth = 2;
+        else
+            cfg->tx_fifo_deq_pipeline_depth = 1;
+
+        cfg->deq_high_pri = FALSE;
+        cfg->deq_byte_cnt = 0x400;
+    }
+    cfg->no_scatter_gather = DEFAULT_FMAN_SP_NO_SCATTER_GATHER;
+}
+
+static uint8_t fman_port_find_bpool(struct fman_port *port, uint8_t bpid)
+{
+    uint32_t *bp_reg, tmp;
+    uint8_t i, id;
+
+    /* Find the pool */
+    bp_reg = port->bmi_regs->rx.fmbm_ebmpi;
+    for (i = 0; i < port->ext_pools_num; i++) {
+        tmp = ioread32be(&bp_reg[i]);
+        id = (uint8_t)((tmp & BMI_EXT_BUF_POOL_ID_MASK) >>
+                BMI_EXT_BUF_POOL_ID_SHIFT);
+
+        if (id == bpid)
+            break;
+    }
+
+    return i;
+}
+
+int fman_port_init(struct fman_port *port,
+        struct fman_port_cfg *cfg,
+        struct fman_port_params *params)
+{
+    int err;
+
+    /* Init BMI registers */
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        err = init_bmi_rx(port, cfg, params);
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        err = init_bmi_tx(port, cfg, params);
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        err = init_bmi_oh(port, cfg, params);
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    if (err)
+        return err;
+
+    /* Init QMI registers */
+    if (!port->im_en)
+    {
+        err = init_qmi(port, cfg, params);
+        return err;
+    }
+    return 0;
+}
+
+int fman_port_enable(struct fman_port *port)
+{
+    uint32_t *bmi_cfg_reg, tmp;
+    bool rx_port;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        bmi_cfg_reg = &port->bmi_regs->rx.fmbm_rcfg;
+        rx_port = TRUE;
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        bmi_cfg_reg = &port->bmi_regs->tx.fmbm_tcfg;
+        rx_port = FALSE;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        bmi_cfg_reg = &port->bmi_regs->oh.fmbm_ocfg;
+        rx_port = FALSE;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    /* Enable QMI */
+    if (!rx_port) {
+        tmp = ioread32be(&port->qmi_regs->fmqm_pnc) | QMI_PORT_CFG_EN;
+        iowrite32be(tmp, &port->qmi_regs->fmqm_pnc);
+    }
+
+    /* Enable BMI */
+    tmp = ioread32be(bmi_cfg_reg) | BMI_PORT_CFG_EN;
+    iowrite32be(tmp, bmi_cfg_reg);
+
+    return 0;
+}
+
+int fman_port_disable(const struct fman_port *port)
+{
+    uint32_t *bmi_cfg_reg, *bmi_status_reg, tmp;
+    bool rx_port, failure = FALSE;
+    int count;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        bmi_cfg_reg = &port->bmi_regs->rx.fmbm_rcfg;
+        bmi_status_reg = &port->bmi_regs->rx.fmbm_rst;
+        rx_port = TRUE;
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        bmi_cfg_reg = &port->bmi_regs->tx.fmbm_tcfg;
+        bmi_status_reg = &port->bmi_regs->tx.fmbm_tst;
+        rx_port = FALSE;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        bmi_cfg_reg = &port->bmi_regs->oh.fmbm_ocfg;
+        bmi_status_reg = &port->bmi_regs->oh.fmbm_ost;
+        rx_port = FALSE;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    /* Disable QMI */
+    if (!rx_port) {
+        tmp = ioread32be(&port->qmi_regs->fmqm_pnc) & ~QMI_PORT_CFG_EN;
+        iowrite32be(tmp, &port->qmi_regs->fmqm_pnc);
+
+        /* Wait for QMI to finish FD handling */
+        count = 100;
+        do {
+            udelay(10);
+            tmp = ioread32be(&port->qmi_regs->fmqm_pns);
+        } while ((tmp & QMI_PORT_STATUS_DEQ_FD_BSY) && --count);
+
+        if (count == 0)
+        {
+            /* Timeout */
+            iowrite32be(ioread32be(&port->qmi_regs->fmqm_pnc) |
+                QMI_PORT_CFG_EN, &port->qmi_regs->fmqm_pnc);
+            failure = TRUE;
+        }
+    }
+
+    /* Disable BMI */
+    tmp = ioread32be(bmi_cfg_reg) & ~BMI_PORT_CFG_EN;
+    iowrite32be(tmp, bmi_cfg_reg);
+
+    /* Wait for graceful stop end */
+    count = 500;
+    do {
+        udelay(10);
+        tmp = ioread32be(bmi_status_reg);
+    } while ((tmp & BMI_PORT_STATUS_BSY) && --count);
+
+    if (count == 0)
+    {
+        /* Timeout */
+        iowrite32be(ioread32be(&port->qmi_regs->fmqm_pnc) |
+            QMI_PORT_CFG_EN, &port->qmi_regs->fmqm_pnc);
+        iowrite32be(ioread32be(bmi_cfg_reg) | BMI_PORT_CFG_EN,
+            bmi_cfg_reg);
+        failure = TRUE;
+    }
+
+    if (failure)
+        return -EBUSY;
+
+    return 0;
+}
+
+int fman_port_set_bpools(const struct fman_port *port,
+        const struct fman_port_bpools *bp)
+{
+    uint32_t tmp, *bp_reg, *bp_depl_reg;
+    uint8_t i, max_bp_num;
+    bool grp_depl_used = FALSE, rx_port;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        max_bp_num = port->ext_pools_num;
+        rx_port = TRUE;
+        bp_reg = port->bmi_regs->rx.fmbm_ebmpi;
+        bp_depl_reg = &port->bmi_regs->rx.fmbm_mpd;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+        if (port->fm_rev_maj != 4)
+            return -EINVAL;
+        max_bp_num = FMAN_PORT_OBS_EXT_POOLS_NUM;
+        rx_port = FALSE;
+        bp_reg = port->bmi_regs->oh.fmbm_oebmpi;
+        bp_depl_reg = &port->bmi_regs->oh.fmbm_ompd;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    if (rx_port) {
+        /* Check buffers are provided in ascending order */
+        for (i = 0; i < (bp->count-1); i++) {
+            if (bp->bpool[i].size > bp->bpool[i+1].size)
+                return -EINVAL;
+        }
+    }
+
+    /* Set up external buffers pools */
+    for (i = 0; i < bp->count; i++) {
+        tmp = BMI_EXT_BUF_POOL_VALID;
+        tmp |= ((uint32_t)bp->bpool[i].bpid <<
+            BMI_EXT_BUF_POOL_ID_SHIFT) & BMI_EXT_BUF_POOL_ID_MASK;
+
+        if (rx_port) {
+            if (bp->counters_enable)
+                tmp |= BMI_EXT_BUF_POOL_EN_COUNTER;
+
+            if (bp->bpool[i].is_backup)
+                tmp |= BMI_EXT_BUF_POOL_BACKUP;
+
+            tmp |= (uint32_t)bp->bpool[i].size;
+        }
+
+        iowrite32be(tmp, &bp_reg[i]);
+    }
+
+    /* Clear unused pools */
+    for (i = bp->count; i < max_bp_num; i++)
+        iowrite32be(0, &bp_reg[i]);
+
+    /* Pools depletion */
+    tmp = 0;
+    for (i = 0; i < bp->count; i++) {
+        if (bp->bpool[i].grp_bp_depleted) {
+            grp_depl_used = TRUE;
+            tmp |= 0x80000000 >> i;
+        }
+
+        if (bp->bpool[i].single_bp_depleted)
+            tmp |= 0x80 >> i;
+
+        if (bp->bpool[i].pfc_priorities_en)
+            tmp |= 0x0100 << i;
+    }
+
+    if (grp_depl_used)
+        tmp |= ((uint32_t)bp->grp_bp_depleted_num - 1) <<
+            BMI_POOL_DEP_NUM_OF_POOLS_SHIFT;
+
+    iowrite32be(tmp, bp_depl_reg);
+    return 0;
+}
+
+int fman_port_set_rate_limiter(struct fman_port *port,
+        struct fman_port_rate_limiter *rate_limiter)
+{
+    uint32_t *rate_limit_reg, *rate_limit_scale_reg;
+    uint32_t granularity, tmp;
+    uint8_t usec_bit, factor;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        rate_limit_reg = &port->bmi_regs->tx.fmbm_trlmt;
+        rate_limit_scale_reg = &port->bmi_regs->tx.fmbm_trlmts;
+        granularity = BMI_RATE_LIMIT_GRAN_TX;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+        rate_limit_reg = &port->bmi_regs->oh.fmbm_orlmt;
+        rate_limit_scale_reg = &port->bmi_regs->oh.fmbm_orlmts;
+        granularity = BMI_RATE_LIMIT_GRAN_OP;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    /* Factor is per 1 usec count */
+    factor = 1;
+    usec_bit = rate_limiter->count_1micro_bit;
+
+    /* If rate limit is too small for an 1usec factor, adjust timestamp
+     * scale and multiply the factor */
+    while (rate_limiter->rate < (granularity / factor)) {
+        if (usec_bit == 31)
+            /* Can't configure rate limiter - rate is too small */
+            return -EINVAL;
+
+        usec_bit++;
+        factor <<= 1;
+    }
+
+    /* Figure out register value. The "while" above quarantees that
+     * (rate_limiter->rate * factor / granularity) >= 1 */
+    tmp = (uint32_t)(rate_limiter->rate * factor / granularity - 1);
+
+    /* Check rate limit isn't too large */
+    if (tmp >= BMI_RATE_LIMIT_MAX_RATE_IN_GRAN_UNITS)
+        return -EINVAL;
+
+    /* Check burst size is in allowed range */
+    if ((rate_limiter->burst_size == 0) ||
+            (rate_limiter->burst_size >
+                BMI_RATE_LIMIT_MAX_BURST_SIZE))
+        return -EINVAL;
+
+    tmp |= (uint32_t)(rate_limiter->burst_size - 1) <<
+            BMI_RATE_LIMIT_MAX_BURST_SHIFT;
+
+    if ((port->type == E_FMAN_PORT_TYPE_OP) &&
+            (port->fm_rev_maj == 4)) {
+        if (rate_limiter->high_burst_size_gran)
+            tmp |= BMI_RATE_LIMIT_HIGH_BURST_SIZE_GRAN;
+    }
+
+    iowrite32be(tmp, rate_limit_reg);
+
+    /* Set up rate limiter scale register */
+    tmp = BMI_RATE_LIMIT_SCALE_EN;
+    tmp |= (31 - (uint32_t)usec_bit) << BMI_RATE_LIMIT_SCALE_TSBS_SHIFT;
+
+    if ((port->type == E_FMAN_PORT_TYPE_OP) &&
+            (port->fm_rev_maj == 4))
+        tmp |= rate_limiter->rate_factor;
+
+    iowrite32be(tmp, rate_limit_scale_reg);
+
+    return 0;
+}
+
+int fman_port_delete_rate_limiter(struct fman_port *port)
+{
+    uint32_t *rate_limit_scale_reg;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        rate_limit_scale_reg = &port->bmi_regs->tx.fmbm_trlmts;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+        rate_limit_scale_reg = &port->bmi_regs->oh.fmbm_orlmts;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    iowrite32be(0, rate_limit_scale_reg);
+    return 0;
+}
+
+int fman_port_set_err_mask(struct fman_port *port, uint32_t err_mask)
+{
+    uint32_t *err_mask_reg;
+
+    /* Obtain register address */
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        err_mask_reg = &port->bmi_regs->rx.fmbm_rfsem;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+        err_mask_reg = &port->bmi_regs->oh.fmbm_ofsem;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    iowrite32be(err_mask, err_mask_reg);
+    return 0;
+}
+
+int fman_port_set_discard_mask(struct fman_port *port, uint32_t discard_mask)
+{
+    uint32_t *discard_mask_reg;
+
+    /* Obtain register address */
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        discard_mask_reg = &port->bmi_regs->rx.fmbm_rfsdm;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+        discard_mask_reg = &port->bmi_regs->oh.fmbm_ofsdm;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    iowrite32be(discard_mask, discard_mask_reg);
+    return 0;
+}
+
+int fman_port_modify_rx_fd_bits(struct fman_port *port,
+        uint8_t rx_fd_bits,
+        bool add)
+{
+    uint32_t    tmp;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    tmp = ioread32be(&port->bmi_regs->rx.fmbm_rfne);
+
+    if (add)
+        tmp |= (uint32_t)rx_fd_bits << BMI_NEXT_ENG_FD_BITS_SHIFT;
+    else
+        tmp &= ~((uint32_t)rx_fd_bits << BMI_NEXT_ENG_FD_BITS_SHIFT);
+
+    iowrite32be(tmp, &port->bmi_regs->rx.fmbm_rfne);
+    return 0;
+}
+
+int fman_port_set_perf_cnt_params(struct fman_port *port,
+        struct fman_port_perf_cnt_params *params)
+{
+    uint32_t *pcp_reg, tmp;
+
+    /* Obtain register address and check parameters are in range */
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        pcp_reg = &port->bmi_regs->rx.fmbm_rpcp;
+        if ((params->queue_val == 0) ||
+            (params->queue_val > MAX_PERFORMANCE_RX_QUEUE_COMP))
+            return -EINVAL;
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        pcp_reg = &port->bmi_regs->tx.fmbm_tpcp;
+        if ((params->queue_val == 0) ||
+            (params->queue_val > MAX_PERFORMANCE_TX_QUEUE_COMP))
+            return -EINVAL;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        pcp_reg = &port->bmi_regs->oh.fmbm_opcp;
+        if (params->queue_val != 0)
+            return -EINVAL;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    if ((params->task_val == 0) ||
+            (params->task_val > MAX_PERFORMANCE_TASK_COMP))
+        return -EINVAL;
+    if ((params->dma_val == 0) ||
+            (params->dma_val > MAX_PERFORMANCE_DMA_COMP))
+        return -EINVAL;
+    if ((params->fifo_val == 0) ||
+            ((params->fifo_val / FMAN_PORT_BMI_FIFO_UNITS) >
+                MAX_PERFORMANCE_FIFO_COMP))
+        return -EINVAL;
+    tmp = (uint32_t)(params->task_val - 1) <<
+            BMI_PERFORMANCE_TASK_COMP_SHIFT;
+    tmp |= (uint32_t)(params->dma_val - 1) <<
+            BMI_PERFORMANCE_DMA_COMP_SHIFT;
+    tmp |= (uint32_t)(params->fifo_val / FMAN_PORT_BMI_FIFO_UNITS - 1);
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        tmp |= (uint32_t)(params->queue_val - 1) <<
+            BMI_PERFORMANCE_QUEUE_COMP_SHIFT;
+        break;
+    default:
+        break;
+    }
+
+
+    iowrite32be(tmp, pcp_reg);
+    return 0;
+}
+
+int fman_port_set_stats_cnt_mode(struct fman_port *port, bool enable)
+{
+    uint32_t *stats_reg, tmp;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        stats_reg = &port->bmi_regs->rx.fmbm_rstc;
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        stats_reg = &port->bmi_regs->tx.fmbm_tstc;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        stats_reg = &port->bmi_regs->oh.fmbm_ostc;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    tmp = ioread32be(stats_reg);
+
+    if (enable)
+        tmp |= BMI_COUNTERS_EN;
+    else
+        tmp &= ~BMI_COUNTERS_EN;
+
+    iowrite32be(tmp, stats_reg);
+    return 0;
+}
+
+int fman_port_set_perf_cnt_mode(struct fman_port *port, bool enable)
+{
+    uint32_t *stats_reg, tmp;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        stats_reg = &port->bmi_regs->rx.fmbm_rpc;
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        stats_reg = &port->bmi_regs->tx.fmbm_tpc;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        stats_reg = &port->bmi_regs->oh.fmbm_opc;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    tmp = ioread32be(stats_reg);
+
+    if (enable)
+        tmp |= BMI_COUNTERS_EN;
+    else
+        tmp &= ~BMI_COUNTERS_EN;
+
+    iowrite32be(tmp, stats_reg);
+    return 0;
+}
+
+int fman_port_set_queue_cnt_mode(struct fman_port *port, bool enable)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&port->qmi_regs->fmqm_pnc);
+
+    if (enable)
+        tmp |= QMI_PORT_CFG_EN_COUNTERS;
+    else
+        tmp &= ~QMI_PORT_CFG_EN_COUNTERS;
+
+    iowrite32be(tmp, &port->qmi_regs->fmqm_pnc);
+    return 0;
+}
+
+int fman_port_set_bpool_cnt_mode(struct fman_port *port,
+        uint8_t bpid,
+        bool enable)
+{
+    uint8_t index;
+    uint32_t tmp;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    /* Find the pool */
+    index = fman_port_find_bpool(port, bpid);
+    if (index == port->ext_pools_num)
+        /* Not found */
+        return -EINVAL;
+
+    tmp = ioread32be(&port->bmi_regs->rx.fmbm_ebmpi[index]);
+
+    if (enable)
+        tmp |= BMI_EXT_BUF_POOL_EN_COUNTER;
+    else
+        tmp &= ~BMI_EXT_BUF_POOL_EN_COUNTER;
+
+    iowrite32be(tmp, &port->bmi_regs->rx.fmbm_ebmpi[index]);
+    return 0;
+}
+
+uint32_t fman_port_get_stats_counter(struct fman_port *port,
+        enum fman_port_stats_counters  counter)
+{
+    uint32_t *stats_reg, ret_val;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        get_rx_stats_reg(port, counter, &stats_reg);
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        get_tx_stats_reg(port, counter, &stats_reg);
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        get_oh_stats_reg(port, counter, &stats_reg);
+        break;
+    default:
+        stats_reg = NULL;
+    }
+
+    if (stats_reg == NULL)
+        return 0;
+
+    ret_val = ioread32be(stats_reg);
+    return ret_val;
+}
+
+void fman_port_set_stats_counter(struct fman_port *port,
+        enum fman_port_stats_counters counter,
+        uint32_t value)
+{
+    uint32_t *stats_reg;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        get_rx_stats_reg(port, counter, &stats_reg);
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        get_tx_stats_reg(port, counter, &stats_reg);
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        get_oh_stats_reg(port, counter, &stats_reg);
+        break;
+    default:
+        stats_reg = NULL;
+    }
+
+    if (stats_reg == NULL)
+        return;
+
+    iowrite32be(value, stats_reg);
+}
+
+uint32_t fman_port_get_perf_counter(struct fman_port *port,
+        enum fman_port_perf_counters counter)
+{
+    uint32_t *perf_reg, ret_val;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        get_rx_perf_reg(port, counter, &perf_reg);
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        get_tx_perf_reg(port, counter, &perf_reg);
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        get_oh_perf_reg(port, counter, &perf_reg);
+        break;
+    default:
+        perf_reg = NULL;
+    }
+
+    if (perf_reg == NULL)
+        return 0;
+
+    ret_val = ioread32be(perf_reg);
+    return ret_val;
+}
+
+void fman_port_set_perf_counter(struct fman_port *port,
+        enum fman_port_perf_counters counter,
+        uint32_t value)
+{
+    uint32_t *perf_reg;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        get_rx_perf_reg(port, counter, &perf_reg);
+        break;
+    case E_FMAN_PORT_TYPE_TX:
+    case E_FMAN_PORT_TYPE_TX_10G:
+        get_tx_perf_reg(port, counter, &perf_reg);
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+    case E_FMAN_PORT_TYPE_HC:
+        get_oh_perf_reg(port, counter, &perf_reg);
+        break;
+    default:
+        perf_reg = NULL;
+    }
+
+    if (perf_reg == NULL)
+        return;
+
+    iowrite32be(value, perf_reg);
+}
+
+uint32_t fman_port_get_qmi_counter(struct fman_port *port,
+        enum fman_port_qmi_counters  counter)
+{
+    uint32_t *queue_reg, ret_val;
+
+    get_qmi_counter_reg(port, counter, &queue_reg);
+
+    if (queue_reg == NULL)
+        return 0;
+
+    ret_val = ioread32be(queue_reg);
+    return ret_val;
+}
+
+void fman_port_set_qmi_counter(struct fman_port *port,
+        enum fman_port_qmi_counters counter,
+        uint32_t value)
+{
+    uint32_t *queue_reg;
+
+    get_qmi_counter_reg(port, counter, &queue_reg);
+
+    if (queue_reg == NULL)
+        return;
+
+    iowrite32be(value, queue_reg);
+}
+
+uint32_t fman_port_get_bpool_counter(struct fman_port *port, uint8_t bpid)
+{
+    uint8_t index;
+    uint32_t ret_val;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        break;
+    default:
+        return 0;
+    }
+
+    /* Find the pool */
+    index = fman_port_find_bpool(port, bpid);
+    if (index == port->ext_pools_num)
+        /* Not found */
+        return 0;
+
+    ret_val = ioread32be(&port->bmi_regs->rx.fmbm_acnt[index]);
+    return ret_val;
+}
+
+void fman_port_set_bpool_counter(struct fman_port *port,
+        uint8_t bpid,
+        uint32_t value)
+{
+    uint8_t index;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        break;
+    default:
+        return;
+    }
+
+    /* Find the pool */
+    index = fman_port_find_bpool(port, bpid);
+    if (index == port->ext_pools_num)
+        /* Not found */
+        return;
+
+    iowrite32be(value, &port->bmi_regs->rx.fmbm_acnt[index]);
+}
+
+int fman_port_add_congestion_grps(struct fman_port *port,
+        uint32_t grps_map[FMAN_PORT_CG_MAP_NUM])
+{
+    int i;
+    uint32_t tmp, *grp_map_reg;
+    uint8_t max_grp_map_num;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        if (port->fm_rev_maj == 4)
+            max_grp_map_num = 1;
+        else
+            max_grp_map_num = FMAN_PORT_CG_MAP_NUM;
+        grp_map_reg = port->bmi_regs->rx.fmbm_rcgm;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+        max_grp_map_num = 1;
+        if (port->fm_rev_maj != 4)
+            return -EINVAL;
+        grp_map_reg = &port->bmi_regs->oh.fmbm_ocgm;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    for (i = (max_grp_map_num - 1); i >= 0; i--) {
+        if (grps_map[i] == 0)
+            continue;
+        tmp = ioread32be(&grp_map_reg[i]);
+        tmp |= grps_map[i];
+        iowrite32be(tmp, &grp_map_reg[i]);
+    }
+
+    return 0;
+}
+
+int fman_port_remove_congestion_grps(struct fman_port *port,
+        uint32_t grps_map[FMAN_PORT_CG_MAP_NUM])
+{
+    int i;
+    uint32_t tmp, *grp_map_reg;
+    uint8_t max_grp_map_num;
+
+    switch (port->type) {
+    case E_FMAN_PORT_TYPE_RX:
+    case E_FMAN_PORT_TYPE_RX_10G:
+        if (port->fm_rev_maj == 4)
+            max_grp_map_num = 1;
+        else
+            max_grp_map_num = FMAN_PORT_CG_MAP_NUM;
+        grp_map_reg = port->bmi_regs->rx.fmbm_rcgm;
+        break;
+    case E_FMAN_PORT_TYPE_OP:
+        max_grp_map_num = 1;
+        if (port->fm_rev_maj != 4)
+            return -EINVAL;
+        grp_map_reg = &port->bmi_regs->oh.fmbm_ocgm;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    for (i = (max_grp_map_num - 1); i >= 0; i--) {
+        if (grps_map[i] == 0)
+            continue;
+        tmp = ioread32be(&grp_map_reg[i]);
+        tmp &= ~grps_map[i];
+        iowrite32be(tmp, &grp_map_reg[i]);
+    }
+    return 0;
+}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
index d036fcd..312e5e3 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
@@ -467,9 +467,13 @@ t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams
     }
 
     if (p_FmRtcAlarmParams->alarmTime < p_Rtc->clockPeriodNanoSec)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm time must be equal or larger than RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION,
+                     ("Alarm time must be equal or larger than RTC period - %d nanoseconds",
+                      p_Rtc->clockPeriodNanoSec));
     if (p_FmRtcAlarmParams->alarmTime % (uint64_t)p_Rtc->clockPeriodNanoSec)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm time must be a multiple of RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION,
+                     ("Alarm time must be a multiple of RTC period - %d nanoseconds",
+                      p_Rtc->clockPeriodNanoSec));
     tmpAlarm = p_FmRtcAlarmParams->alarmTime/(uint64_t)p_Rtc->clockPeriodNanoSec;
 
     if (p_FmRtcAlarmParams->f_AlarmCallback)
@@ -501,12 +505,18 @@ t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_
     if (fman_rtc_is_enabled(p_Rtc->p_MemMap))
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Can't set Periodic pulse when RTC is enabled."));
     if (p_FmRtcPeriodicPulseParams->periodicPulsePeriod < p_Rtc->clockPeriodNanoSec)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse must be equal or larger than RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION,
+                     ("Periodic pulse must be equal or larger than RTC period - %d nanoseconds",
+                      p_Rtc->clockPeriodNanoSec));
     if (p_FmRtcPeriodicPulseParams->periodicPulsePeriod % (uint64_t)p_Rtc->clockPeriodNanoSec)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse must be a multiple of RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION,
+                     ("Periodic pulse must be a multiple of RTC period - %d nanoseconds",
+                      p_Rtc->clockPeriodNanoSec));
     tmpFiper = p_FmRtcPeriodicPulseParams->periodicPulsePeriod/(uint64_t)p_Rtc->clockPeriodNanoSec;
     if (tmpFiper & 0xffffffff00000000LL)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse/RTC Period must be smaller than 4294967296", p_Rtc->clockPeriodNanoSec));
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION,
+                     ("Periodic pulse/RTC Period must be smaller than 4294967296",
+                      p_Rtc->clockPeriodNanoSec));
 
     if (p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback)
     {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
index 1f1cdf2..14b15a1 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
@@ -48,8 +48,8 @@
 #include "fm_common.h"
 #include "fsl_fman_sp.h"
 
-#if (DPAA_VERSION >= 11)
 
+#if (DPAA_VERSION >= 11)
 static t_Error CheckParamsGeneratedInternally(t_FmVspEntry *p_FmVspEntry)
 {
     t_Error err = E_OK;
@@ -61,6 +61,7 @@ static t_Error CheckParamsGeneratedInternally(t_FmVspEntry *p_FmVspEntry)
     return err;
 
 }
+
 static t_Error CheckParams(t_FmVspEntry *p_FmVspEntry)
 {
     t_Error err = E_OK;
@@ -538,18 +539,18 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     fm_vsp_params.buf_margins = (struct fman_sp_buf_margins*)&p_FmVspEntry->bufMargins;
     fm_vsp_params.int_context = (struct fman_sp_int_context_data_copy*)&p_FmVspEntry->intContext;
 
-   /*no check on err - it was checked earlier*/
+    /* no check on err - it was checked earlier */
     FmVSPGetAbsoluteProfileId(p_FmVspEntry->h_Fm,
-                                   p_FmVspEntry->portType,
-                                   p_FmVspEntry->portId,
-                                   p_FmVspEntry->relativeProfileId,
-                                   &absoluteProfileId);
-
+                              p_FmVspEntry->portType,
+                              p_FmVspEntry->portId,
+                              p_FmVspEntry->relativeProfileId,
+                              &absoluteProfileId);
 
     ASSERT_COND(p_FmVspEntry->p_FmSpRegsBase);
     ASSERT_COND(fm_vsp_params.int_context);
     ASSERT_COND(fm_vsp_params.buf_margins);
     ASSERT_COND(IN_RANGE(0, absoluteProfileId, FM_VSP_MAX_NUM_OF_ENTRIES));
+
     /* Set all registers related to VSP */
     fman_vsp_init(p_FmVspEntry->p_FmSpRegsBase, absoluteProfileId, &fm_vsp_params,FM_PORT_MAX_NUM_OF_EXT_POOLS, BM_MAX_NUM_OF_POOLS, FM_MAX_NUM_OF_PFC_PRIORITIES);
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fman_sp.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fman_sp.c
index d1f1467..0f772e9 100755
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fman_sp.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fman_sp.c
@@ -34,164 +34,164 @@
 
 
 uint32_t fman_vsp_get_statistics(struct fm_pcd_storage_profile_regs   *regs,
-					uint16_t                      index)
+                    uint16_t                      index)
 {
-	struct fm_pcd_storage_profile_regs *sp_regs;
-	sp_regs = &regs[index];
-	return ioread32be(&sp_regs->fm_sp_acnt);
+    struct fm_pcd_storage_profile_regs *sp_regs;
+    sp_regs = &regs[index];
+    return ioread32be(&sp_regs->fm_sp_acnt);
 }
 
 void fman_vsp_set_statistics(struct fm_pcd_storage_profile_regs *regs,
-			uint16_t index,	uint32_t value)
+            uint16_t index,	uint32_t value)
 {
-	struct fm_pcd_storage_profile_regs *sp_regs;
-	sp_regs = &regs[index];
-	iowrite32be(value, &sp_regs->fm_sp_acnt);
+    struct fm_pcd_storage_profile_regs *sp_regs;
+    sp_regs = &regs[index];
+    iowrite32be(value, &sp_regs->fm_sp_acnt);
 }
 
 void fman_vsp_defconfig(struct fm_storage_profile_params *cfg)
 {
-	cfg->dma_swap_data =
-			DEFAULT_FMAN_SP_DMA_SWAP_DATA;
-	cfg->int_context_cache_attr =
-			DEFAULT_FMAN_SP_DMA_INT_CONTEXT_CACHE_ATTR;
-	cfg->header_cache_attr =
-			DEFAULT_FMAN_SP_DMA_HEADER_CACHE_ATTR;
-	cfg->scatter_gather_cache_attr =
-			DEFAULT_FMAN_SP_DMA_SCATTER_GATHER_CACHE_ATTR;
-	cfg->dma_write_optimize =
-			DEFAULT_FMAN_SP_DMA_WRITE_OPTIMIZE;
-	cfg->no_scather_gather =
-			DEFAULT_FMAN_SP_NO_SCATTER_GATHER;
+    cfg->dma_swap_data =
+            DEFAULT_FMAN_SP_DMA_SWAP_DATA;
+    cfg->int_context_cache_attr =
+            DEFAULT_FMAN_SP_DMA_INT_CONTEXT_CACHE_ATTR;
+    cfg->header_cache_attr =
+            DEFAULT_FMAN_SP_DMA_HEADER_CACHE_ATTR;
+    cfg->scatter_gather_cache_attr =
+            DEFAULT_FMAN_SP_DMA_SCATTER_GATHER_CACHE_ATTR;
+    cfg->dma_write_optimize =
+            DEFAULT_FMAN_SP_DMA_WRITE_OPTIMIZE;
+    cfg->no_scather_gather =
+            DEFAULT_FMAN_SP_NO_SCATTER_GATHER;
 }
 
 static inline uint32_t calc_vec_dep(int max_pools, bool *pools,
-		struct fman_ext_pools *ext_buf_pools, uint32_t mask)
+        struct fman_ext_pools *ext_buf_pools, uint32_t mask)
 {
-	int i, j;
-	uint32_t vector = 0;
-	for (i = 0; i < max_pools; i++)
-		if (pools[i])
-			for (j = 0; j < ext_buf_pools->num_pools_used; j++)
-				if (i == ext_buf_pools->ext_buf_pool[j].id) {
-					vector |= mask >> j;
-					break;
-				}
-	return vector;
+    int i, j;
+    uint32_t vector = 0;
+    for (i = 0; i < max_pools; i++)
+        if (pools[i])
+            for (j = 0; j < ext_buf_pools->num_pools_used; j++)
+                if (i == ext_buf_pools->ext_buf_pool[j].id) {
+                    vector |= mask >> j;
+                    break;
+                }
+    return vector;
 }
 
 void fman_vsp_init(struct fm_pcd_storage_profile_regs   *regs,
-	uint16_t index, struct fm_storage_profile_params *fm_vsp_params,
-	int port_max_num_of_ext_pools, int bm_max_num_of_pools,
-	int max_num_of_pfc_priorities)
+    uint16_t index, struct fm_storage_profile_params *fm_vsp_params,
+    int port_max_num_of_ext_pools, int bm_max_num_of_pools,
+    int max_num_of_pfc_priorities)
 {
-	int i = 0, j = 0;
-	struct fm_pcd_storage_profile_regs *sp_regs;
-	uint32_t tmp_reg, vector;
-	struct fman_ext_pools *ext_buf_pools = &fm_vsp_params->fm_ext_pools;
-	struct fman_buf_pool_depletion *buf_pool_depletion =
-					&fm_vsp_params->buf_pool_depletion;
-	struct fman_backup_bm_pools *backup_pools =
-					&fm_vsp_params->backup_pools;
-	struct fman_sp_int_context_data_copy *int_context_data_copy =
-						fm_vsp_params->int_context;
-	struct fman_sp_buf_margins *external_buffer_margins =
-						fm_vsp_params->buf_margins;
-	bool no_scather_gather = fm_vsp_params->no_scather_gather;
-	uint16_t liodn_offset = fm_vsp_params->liodn_offset;
-
-	sp_regs = &regs[index];
-
-	/* fill external buffers manager pool information register*/
-	for (i = 0; i < ext_buf_pools->num_pools_used; i++) {
-		tmp_reg = FMAN_SP_EXT_BUF_POOL_VALID |
-			FMAN_SP_EXT_BUF_POOL_EN_COUNTER;
-		tmp_reg |= ((uint32_t)ext_buf_pools->ext_buf_pool[i].id <<
-			FMAN_SP_EXT_BUF_POOL_ID_SHIFT);
-		tmp_reg |= ext_buf_pools->ext_buf_pool[i].size;
-		/* functionality available only for some deriviatives
-			 (limited by config) */
-		for (j = 0; j < backup_pools->num_backup_pools; j++)
-			if (ext_buf_pools->ext_buf_pool[i].id ==
-				backup_pools->pool_ids[j]) {
-				tmp_reg |= FMAN_SP_EXT_BUF_POOL_BACKUP;
-				break;
-			}
-		iowrite32be(tmp_reg, &sp_regs->fm_sp_ebmpi[i]);
-	}
-
-	/* clear unused pools */
-	for (i = ext_buf_pools->num_pools_used;
-		i < port_max_num_of_ext_pools; i++)
-		iowrite32be(0, &sp_regs->fm_sp_ebmpi[i]);
-
-	/* fill pool depletion register*/
-	tmp_reg = 0;
-	if (buf_pool_depletion->buf_pool_depletion_enabled && buf_pool_depletion->pools_grp_mode_enable) {
-		/* calculate vector for number of pools depletion */
-		vector = calc_vec_dep(bm_max_num_of_pools, buf_pool_depletion->
-				pools_to_consider, ext_buf_pools, 0x80000000);
-
-		/* configure num of pools and vector for number of pools mode */
-		tmp_reg |= (((uint32_t)buf_pool_depletion->num_pools - 1) <<
-			FMAN_SP_POOL_DEP_NUM_OF_POOLS_SHIFT);
-		tmp_reg |= vector;
-	}
-
-	if (buf_pool_depletion->buf_pool_depletion_enabled && buf_pool_depletion->single_pool_mode_enable) {
-		/* calculate vector for number of pools depletion */
-		vector = calc_vec_dep(bm_max_num_of_pools, buf_pool_depletion->
-				pools_to_consider_for_single_mode,
-				ext_buf_pools, 0x00000080);
-
-		/* configure num of pools and vector for number of pools mode */
-		tmp_reg |= vector;
-	}
-
-	/* fill QbbPEV */
-	if (buf_pool_depletion->buf_pool_depletion_enabled) {
-		vector = 0;
-		for (i = 0; i < max_num_of_pfc_priorities; i++)
-			if (buf_pool_depletion->pfc_priorities_en[i] == TRUE)
-				vector |= 0x00008000 >> i;
-		tmp_reg |= vector;
-	}
-	iowrite32be(tmp_reg, &sp_regs->fm_sp_mpd);
-
-	/* fill dma attributes register */
-	tmp_reg = 0;
-	tmp_reg |= (uint32_t)fm_vsp_params->dma_swap_data <<
-		FMAN_SP_DMA_ATTR_SWP_SHIFT;
-	tmp_reg |= (uint32_t)fm_vsp_params->int_context_cache_attr <<
-		FMAN_SP_DMA_ATTR_IC_CACHE_SHIFT;
-	tmp_reg |= (uint32_t)fm_vsp_params->header_cache_attr <<
-		FMAN_SP_DMA_ATTR_HDR_CACHE_SHIFT;
-	tmp_reg |= (uint32_t)fm_vsp_params->scatter_gather_cache_attr <<
-		FMAN_SP_DMA_ATTR_SG_CACHE_SHIFT;
-	if (fm_vsp_params->dma_write_optimize)
-		tmp_reg |= FMAN_SP_DMA_ATTR_WRITE_OPTIMIZE;
-	iowrite32be(tmp_reg, &sp_regs->fm_sp_da);
-
-	/* IC parameters - fill internal context parameters register */
-	tmp_reg = 0;
-	tmp_reg |= (((uint32_t)int_context_data_copy->ext_buf_offset/
-		OFFSET_UNITS) << FMAN_SP_IC_TO_EXT_SHIFT);
-	tmp_reg |= (((uint32_t)int_context_data_copy->int_context_offset/
-		OFFSET_UNITS) << FMAN_SP_IC_FROM_INT_SHIFT);
-	tmp_reg |= (((uint32_t)int_context_data_copy->size/OFFSET_UNITS) <<
-		FMAN_SP_IC_SIZE_SHIFT);
-	iowrite32be(tmp_reg, &sp_regs->fm_sp_icp);
-
-	/* buffer margins - fill external buffer margins register */
-	tmp_reg = 0;
-	tmp_reg |= (((uint32_t)external_buffer_margins->start_margins) <<
-		FMAN_SP_EXT_BUF_MARG_START_SHIFT);
-	tmp_reg |= (((uint32_t)external_buffer_margins->end_margins) <<
-		FMAN_SP_EXT_BUF_MARG_END_SHIFT);
-	if (no_scather_gather)
-		tmp_reg |= FMAN_SP_SG_DISABLE;
-	iowrite32be(tmp_reg, &sp_regs->fm_sp_ebm);
-
-	/* buffer margins - fill spliodn register */
-	iowrite32be(liodn_offset, &sp_regs->fm_sp_spliodn);
+    int i = 0, j = 0;
+    struct fm_pcd_storage_profile_regs *sp_regs;
+    uint32_t tmp_reg, vector;
+    struct fman_ext_pools *ext_buf_pools = &fm_vsp_params->fm_ext_pools;
+    struct fman_buf_pool_depletion *buf_pool_depletion =
+                    &fm_vsp_params->buf_pool_depletion;
+    struct fman_backup_bm_pools *backup_pools =
+                    &fm_vsp_params->backup_pools;
+    struct fman_sp_int_context_data_copy *int_context_data_copy =
+                        fm_vsp_params->int_context;
+    struct fman_sp_buf_margins *external_buffer_margins =
+                        fm_vsp_params->buf_margins;
+    bool no_scather_gather = fm_vsp_params->no_scather_gather;
+    uint16_t liodn_offset = fm_vsp_params->liodn_offset;
+
+    sp_regs = &regs[index];
+
+    /* fill external buffers manager pool information register*/
+    for (i = 0; i < ext_buf_pools->num_pools_used; i++) {
+        tmp_reg = FMAN_SP_EXT_BUF_POOL_VALID |
+            FMAN_SP_EXT_BUF_POOL_EN_COUNTER;
+        tmp_reg |= ((uint32_t)ext_buf_pools->ext_buf_pool[i].id <<
+            FMAN_SP_EXT_BUF_POOL_ID_SHIFT);
+        tmp_reg |= ext_buf_pools->ext_buf_pool[i].size;
+        /* functionality available only for some deriviatives
+             (limited by config) */
+        for (j = 0; j < backup_pools->num_backup_pools; j++)
+            if (ext_buf_pools->ext_buf_pool[i].id ==
+                backup_pools->pool_ids[j]) {
+                tmp_reg |= FMAN_SP_EXT_BUF_POOL_BACKUP;
+                break;
+            }
+        iowrite32be(tmp_reg, &sp_regs->fm_sp_ebmpi[i]);
+    }
+
+    /* clear unused pools */
+    for (i = ext_buf_pools->num_pools_used;
+        i < port_max_num_of_ext_pools; i++)
+        iowrite32be(0, &sp_regs->fm_sp_ebmpi[i]);
+
+    /* fill pool depletion register*/
+    tmp_reg = 0;
+    if (buf_pool_depletion->buf_pool_depletion_enabled && buf_pool_depletion->pools_grp_mode_enable) {
+        /* calculate vector for number of pools depletion */
+        vector = calc_vec_dep(bm_max_num_of_pools, buf_pool_depletion->
+                pools_to_consider, ext_buf_pools, 0x80000000);
+
+        /* configure num of pools and vector for number of pools mode */
+        tmp_reg |= (((uint32_t)buf_pool_depletion->num_pools - 1) <<
+            FMAN_SP_POOL_DEP_NUM_OF_POOLS_SHIFT);
+        tmp_reg |= vector;
+    }
+
+    if (buf_pool_depletion->buf_pool_depletion_enabled && buf_pool_depletion->single_pool_mode_enable) {
+        /* calculate vector for number of pools depletion */
+        vector = calc_vec_dep(bm_max_num_of_pools, buf_pool_depletion->
+                pools_to_consider_for_single_mode,
+                ext_buf_pools, 0x00000080);
+
+        /* configure num of pools and vector for number of pools mode */
+        tmp_reg |= vector;
+    }
+
+    /* fill QbbPEV */
+    if (buf_pool_depletion->buf_pool_depletion_enabled) {
+        vector = 0;
+        for (i = 0; i < max_num_of_pfc_priorities; i++)
+            if (buf_pool_depletion->pfc_priorities_en[i] == TRUE)
+                vector |= 0x00000100 << i;
+        tmp_reg |= vector;
+    }
+    iowrite32be(tmp_reg, &sp_regs->fm_sp_mpd);
+
+    /* fill dma attributes register */
+    tmp_reg = 0;
+    tmp_reg |= (uint32_t)fm_vsp_params->dma_swap_data <<
+        FMAN_SP_DMA_ATTR_SWP_SHIFT;
+    tmp_reg |= (uint32_t)fm_vsp_params->int_context_cache_attr <<
+        FMAN_SP_DMA_ATTR_IC_CACHE_SHIFT;
+    tmp_reg |= (uint32_t)fm_vsp_params->header_cache_attr <<
+        FMAN_SP_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmp_reg |= (uint32_t)fm_vsp_params->scatter_gather_cache_attr <<
+        FMAN_SP_DMA_ATTR_SG_CACHE_SHIFT;
+    if (fm_vsp_params->dma_write_optimize)
+        tmp_reg |= FMAN_SP_DMA_ATTR_WRITE_OPTIMIZE;
+    iowrite32be(tmp_reg, &sp_regs->fm_sp_da);
+
+    /* IC parameters - fill internal context parameters register */
+    tmp_reg = 0;
+    tmp_reg |= (((uint32_t)int_context_data_copy->ext_buf_offset/
+        OFFSET_UNITS) << FMAN_SP_IC_TO_EXT_SHIFT);
+    tmp_reg |= (((uint32_t)int_context_data_copy->int_context_offset/
+        OFFSET_UNITS) << FMAN_SP_IC_FROM_INT_SHIFT);
+    tmp_reg |= (((uint32_t)int_context_data_copy->size/OFFSET_UNITS) <<
+        FMAN_SP_IC_SIZE_SHIFT);
+    iowrite32be(tmp_reg, &sp_regs->fm_sp_icp);
+
+    /* buffer margins - fill external buffer margins register */
+    tmp_reg = 0;
+    tmp_reg |= (((uint32_t)external_buffer_margins->start_margins) <<
+        FMAN_SP_EXT_BUF_MARG_START_SHIFT);
+    tmp_reg |= (((uint32_t)external_buffer_margins->end_margins) <<
+        FMAN_SP_EXT_BUF_MARG_END_SHIFT);
+    if (no_scather_gather)
+        tmp_reg |= FMAN_SP_SG_DISABLE;
+    iowrite32be(tmp_reg, &sp_regs->fm_sp_ebm);
+
+    /* buffer margins - fill spliodn register */
+    iowrite32be(liodn_offset, &sp_regs->fm_sp_spliodn);
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index 8cb96a0..e321adb 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -48,6 +48,7 @@
 #include "fm_ipc.h"
 #include "fm.h"
 #include <asm/mpc85xx.h>
+#include "fsl_fman.h"
 
 
 /****************************************/
@@ -87,59 +88,60 @@ static bool IsFmanCtrlCodeLoaded(t_Fm *p_Fm)
 
 static t_Error CheckFmParameters(t_Fm *p_Fm)
 {
-    if (IsFmanCtrlCodeLoaded(p_Fm) && !p_Fm->p_FmDriverParam->resetOnInit)
+    if (IsFmanCtrlCodeLoaded(p_Fm) && !p_Fm->resetOnInit)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old FMan CTRL code is loaded; FM must be reset!"));
 #if (DPAA_VERSION < 11)
-    if (!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
+    if (!p_Fm->p_FmDriverParam->dma_axi_dbg_num_of_beats ||
+        (p_Fm->p_FmDriverParam->dma_axi_dbg_num_of_beats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
 #endif /* (DPAA_VERSION < 11) */
-    if (p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be divisble by %d", DMA_CAM_UNITS));
-    if (!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be in the range 1 - %d", DMA_MODE_MAX_CAM_NUM_OF_ENTRIES));
-    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
-    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
-    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency must be smaller than dmaCommQThresholds.assertEmergency"));
+    if (p_Fm->p_FmDriverParam->dma_cam_num_of_entries % DMA_CAM_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_cam_num_of_entries has to be divisble by %d", DMA_CAM_UNITS));
+//    if (!p_Fm->p_FmDriverParam->dma_cam_num_of_entries || (p_Fm->p_FmDriverParam->dma_cam_num_of_entries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
+//        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_cam_num_of_entries has to be in the range 1 - %d", DMA_MODE_MAX_CAM_NUM_OF_ENTRIES));
+    if (p_Fm->p_FmDriverParam->dma_comm_qtsh_asrt_emer > DMA_THRESH_MAX_COMMQ)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_comm_qtsh_asrt_emer can not be larger than %d", DMA_THRESH_MAX_COMMQ));
+    if (p_Fm->p_FmDriverParam->dma_comm_qtsh_clr_emer > DMA_THRESH_MAX_COMMQ)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_comm_qtsh_clr_emer can not be larger than %d", DMA_THRESH_MAX_COMMQ));
+    if (p_Fm->p_FmDriverParam->dma_comm_qtsh_clr_emer >= p_Fm->p_FmDriverParam->dma_comm_qtsh_asrt_emer)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_comm_qtsh_clr_emer must be smaller than dma_comm_qtsh_asrt_emer"));
 #if (DPAA_VERSION < 11)
-    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency must be smaller than dmaReadBufThresholds.assertEmergency"));
-    if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency must be smaller than dmaWriteBufThresholds.assertEmergency"));
-#endif /* (DPAA_VERSION < 11) */
-#if (DPAA_VERSION >= 11)
-    if ((p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_READ_EM)||
-            (p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_WRITE_EM) ||
-            (p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_RAW_WAR_PROT))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaDbgCntMode value not supported by this integration."));
-    if ((p_Fm->p_FmDriverParam->dmaEmergency.emergencyBusSelect == FM_DMA_MURAM_READ_EMERGENCY)||
-            (p_Fm->p_FmDriverParam->dmaEmergency.emergencyBusSelect == FM_DMA_MURAM_WRITE_EMERGENCY))
+    if (p_Fm->p_FmDriverParam->dma_read_buf_tsh_asrt_emer > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_read_buf_tsh_asrt_emer can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if (p_Fm->p_FmDriverParam->dma_read_buf_tsh_clr_emer > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_read_buf_tsh_clr_emer can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if (p_Fm->p_FmDriverParam->dma_read_buf_tsh_clr_emer >= p_Fm->p_FmDriverParam->dma_read_buf_tsh_asrt_emer)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_read_buf_tsh_clr_emer must be smaller than dma_read_buf_tsh_asrt_emer"));
+    if (p_Fm->p_FmDriverParam->dma_write_buf_tsh_asrt_emer > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_write_buf_tsh_asrt_emer can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if (p_Fm->p_FmDriverParam->dma_write_buf_tsh_clr_emer > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_write_buf_tsh_clr_emer can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if (p_Fm->p_FmDriverParam->dma_write_buf_tsh_clr_emer >= p_Fm->p_FmDriverParam->dma_write_buf_tsh_asrt_emer)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_write_buf_tsh_clr_emer must be smaller than dma_write_buf_tsh_asrt_emer"));
+#else /* (DPAA_VERSION >= 11) */
+    if ((p_Fm->p_FmDriverParam->dma_dbg_cnt_mode == E_FMAN_DMA_DBG_CNT_INT_READ_EM)||
+            (p_Fm->p_FmDriverParam->dma_dbg_cnt_mode == E_FMAN_DMA_DBG_CNT_INT_WRITE_EM) ||
+            (p_Fm->p_FmDriverParam->dma_dbg_cnt_mode == E_FMAN_DMA_DBG_CNT_RAW_WAR_PROT))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_dbg_cnt_mode value not supported by this integration."));
+    if ((p_Fm->p_FmDriverParam->dma_emergency_bus_select == FM_DMA_MURAM_READ_EMERGENCY)||
+            (p_Fm->p_FmDriverParam->dma_emergency_bus_select == FM_DMA_MURAM_WRITE_EMERGENCY))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("emergencyBusSelect value not supported by this integration."));
-    if (p_Fm->p_FmDriverParam->dmaStopOnBusError)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaStopOnBusError not supported by this integration."));
+    if (p_Fm->p_FmDriverParam->dma_stop_on_bus_error)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_stop_on_bus_error not supported by this integration."));
 #ifdef FM_AID_MODE_NO_TNUM_SW005
-    if (p_Fm->p_FmDriverParam->dmaAidMode != e_FM_DMA_AID_OUT_PORT_ID)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaAidMode not supported by this integration."));
+    if (p_Fm->p_FmDriverParam->dma_aid_mode != E_FMAN_DMA_AID_OUT_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_aid_mode not supported by this integration."));
 #endif /* FM_AID_MODE_NO_TNUM_SW005 */
-    if (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaAxiDbgNumOfBeats not supported by this integration."));
-#endif /* (DPAA_VERSION >= 11) */
+    if (p_Fm->p_FmDriverParam->dma_axi_dbg_num_of_beats)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dma_axi_dbg_num_of_beats not supported by this integration."));
+#endif /* (DPAA_VERSION < 11) */
 
     if (!p_Fm->p_FmStateStruct->fmClkFreq)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq must be set."));
-    if (USEC_TO_CLK(p_Fm->p_FmDriverParam->dmaWatchdog, p_Fm->p_FmStateStruct->fmClkFreq) > DMA_MAX_WATCHDOG)
+    if (USEC_TO_CLK(p_Fm->p_FmDriverParam->dma_watchdog, p_Fm->p_FmStateStruct->fmClkFreq) > DMA_MAX_WATCHDOG)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("dmaWatchdog depends on FM clock. dmaWatchdog(in microseconds) * clk (in Mhz), may not exceed 0x08x", DMA_MAX_WATCHDOG));
+                     ("dma_watchdog depends on FM clock. dma_watchdog(in microseconds) * clk (in Mhz), may not exceed 0x08x", DMA_MAX_WATCHDOG));
 
 #if (DPAA_VERSION >= 11)
     if ((p_Fm->partVSPBase + p_Fm->partNumOfVSPs) > FM_VSP_MAX_NUM_OF_ENTRIES)
@@ -150,7 +152,10 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be divisible by %d", BMI_FIFO_UNITS));
     if (!p_Fm->p_FmStateStruct->totalFifoSize ||
         (p_Fm->p_FmStateStruct->totalFifoSize > BMI_MAX_FIFO_SIZE))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be in the range 256 - %d", BMI_MAX_FIFO_SIZE));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("totalFifoSize (curr - %d) has to be in the range 256 - %d",
+                      p_Fm->p_FmStateStruct->totalFifoSize,
+                      BMI_MAX_FIFO_SIZE));
     if (!p_Fm->p_FmStateStruct->totalNumOfTasks ||
         (p_Fm->p_FmStateStruct->totalNumOfTasks > BMI_MAX_NUM_OF_TASKS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalNumOfTasks number has to be in the range 1 - %d", BMI_MAX_NUM_OF_TASKS));
@@ -161,8 +166,8 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfOpenDmas number has to be in the range 1 - %d", BMI_MAX_NUM_OF_DMAS));
 #endif /* FM_HAS_TOTAL_DMAS */
 
-    if (p_Fm->p_FmDriverParam->thresholds.dispLimit > FPM_MAX_DISP_LIMIT)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("thresholds.dispLimit can't be greater than %d", FPM_MAX_DISP_LIMIT));
+    if (p_Fm->p_FmDriverParam->disp_limit_tsh > FPM_MAX_DISP_LIMIT)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("disp_limit_tsh can't be greater than %d", FPM_MAX_DISP_LIMIT));
 
     if (!p_Fm->f_Exception)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
@@ -171,20 +176,20 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 
 #ifdef FM_NO_WATCHDOG
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 2) &&
-        (p_Fm->p_FmDriverParam->dmaWatchdog))
+        (p_Fm->p_FmDriverParam->dma_watchdog))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("watchdog!"));
 #endif /* FM_NO_WATCHDOG */
 
 #ifdef FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) &&
-        (p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError))
+        (p_Fm->p_FmDriverParam->halt_on_unrecov_ecc_err))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
 #endif /* FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
 
 #ifdef FM_NO_TNUM_AGING
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) &&
         (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
-        if (p_Fm->tnumAgingPeriod)
+        if (p_Fm->p_FmDriverParam->tnum_aging_period)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Tnum aging!"));
 #endif /* FM_NO_TNUM_AGING */
 
@@ -192,19 +197,19 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 #ifdef FM_NO_DISPATCH_RAM_ECC
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) &&
         (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
-        if (p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
+        if (p_Fm->userSetExceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("exception e_FM_EX_BMI_DISPATCH_RAM_ECC!"));
 #endif /* FM_NO_DISPATCH_RAM_ECC */
 
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
     if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
-        if (p_Fm->p_FmDriverParam->userSetExceptions & (FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC))
+        if (p_Fm->userSetExceptions & (FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC))
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC/e_FM_EX_QMI_DOUBLE_ECC!"));
 #endif /* FM_QMI_NO_ECC_EXCEPTIONS */
 
 #ifdef FM_QMI_NO_SINGLE_ECC_EXCEPTION
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        if (p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_QMI_SINGLE_ECC)
+        if (p_Fm->userSetExceptions & FM_EX_QMI_SINGLE_ECC)
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC!"));
 #endif /* FM_QMI_NO_SINGLE_ECC_EXCEPTION */
 
@@ -248,19 +253,11 @@ static void SendIpcIsr(t_Fm *p_Fm, uint32_t macEvent, uint32_t pendingReg)
 
 static void BmiErrEvent(t_Fm *p_Fm)
 {
-    uint32_t    event, mask, force;
-
-    event  = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr);
-    mask   = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-    event &= mask;
+    uint32_t    event;
+    struct fman_bmi_regs *bmi_rg = p_Fm->p_FmBmiRegs;
 
-    /* clear the forced events */
-    force = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr);
-    if (force & event)
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, force & ~event);
 
-    /* clear the acknowledged events */
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, event);
+    event = fman_get_bmi_err_event(bmi_rg);
 
     if (event & BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_STORAGE_PROFILE_ECC);
@@ -274,20 +271,10 @@ static void BmiErrEvent(t_Fm *p_Fm)
 
 static void    QmiErrEvent(t_Fm *p_Fm)
 {
-    uint32_t    event, mask, force;
-
-    event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie);
-    mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-
-    event &= mask;
-
-    /* clear the forced events */
-    force = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif);
-    if (force & event)
-        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, force & ~event);
+    uint32_t    event;
+    struct fman_qmi_regs *qmi_rg = p_Fm->p_FmQmiRegs;
 
-    /* clear the acknowledged events */
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, event);
+    event = fman_get_qmi_err_event(qmi_rg);
 
     if (event & QMI_ERR_INTR_EN_DOUBLE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DOUBLE_ECC);
@@ -297,45 +284,30 @@ static void    QmiErrEvent(t_Fm *p_Fm)
 
 static void    DmaErrEvent(t_Fm *p_Fm)
 {
-    uint64_t            addr=0;
-    uint32_t            status, mask, tmpReg=0;
+    uint32_t            status, com_id;
     uint8_t             tnum;
     uint8_t             hardwarePortId;
     uint8_t             relativePortId;
     uint16_t            liodn;
+    struct fman_dma_regs *dma_rg = p_Fm->p_FmDmaRegs;
 
-    status = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
-    mask = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-
-    /* get bus error regs before clearing BER */
-    if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
-    {
-        addr = (uint64_t)GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtal);
-        addr |= ((uint64_t)(GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtah)) << 32);
-
-        /* get information about the owner of that bus error */
-        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtcid);
-    }
-
-    /* clear set events */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, status);
+    status = fman_get_dma_err_event(dma_rg);
 
-    if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
+    if (status & DMA_STATUS_BUS_ERR)
     {
-        hardwarePortId = (uint8_t)(((tmpReg & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT));
+        com_id = fman_get_dma_com_id(dma_rg);
+        hardwarePortId = (uint8_t)(((com_id & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT));
         HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
-        tnum = (uint8_t)((tmpReg & DMA_TRANSFER_TNUM_MASK) >> DMA_TRANSFER_TNUM_SHIFT);
-        liodn = (uint16_t)(tmpReg & DMA_TRANSFER_LIODN_MASK);
+        tnum = (uint8_t)((com_id & DMA_TRANSFER_TNUM_MASK) >> DMA_TRANSFER_TNUM_SHIFT);
+        liodn = (uint16_t)(com_id & DMA_TRANSFER_LIODN_MASK);
         ASSERT_COND(p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] != e_FM_PORT_TYPE_DUMMY);
         p_Fm->f_BusError(p_Fm->h_App,
                          p_Fm->p_FmStateStruct->portsTypes[hardwarePortId],
                          relativePortId,
-                         addr,
+                         fman_get_dma_addr(dma_rg),
                          tnum,
                          liodn);
     }
-    if (mask & DMA_MODE_ECC)
-    {
         if (status & DMA_STATUS_FM_SPDAT_ECC)
             p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_SINGLE_PORT_ECC);
         if (status & DMA_STATUS_READ_ECC)
@@ -345,16 +317,13 @@ static void    DmaErrEvent(t_Fm *p_Fm)
         if (status & DMA_STATUS_FM_WRITE_ECC)
             p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_FM_WRITE_ECC);
     }
-}
 
 static void    FpmErrEvent(t_Fm *p_Fm)
 {
     uint32_t    event;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
-    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
-
-    /* clear the all occurred events */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, event);
+    event = fman_get_fpm_err_event(fpm_rg);
 
     if ((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_DOUBLE_ECC);
@@ -366,58 +335,32 @@ static void    FpmErrEvent(t_Fm *p_Fm)
 
 static void    MuramErrIntr(t_Fm *p_Fm)
 {
-    uint32_t    event, mask;
-
-    event = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr);
-    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
-
-    ASSERT_COND(event & FPM_RAM_CTL_MURAM_ECC);
-
-    /* clear MURAM event bit */
-    /* Prior to V3 this event bit clearing does not work ! ) */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, event & ~FPM_RAM_CTL_IRAM_ECC);
+    uint32_t    event;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
-    ASSERT_COND(event & FPM_RAM_CTL_RAMS_ECC_EN);
+    event = fman_get_muram_err_event(fpm_rg);
 
-    if ((mask & FPM_MURAM_ECC_ERR_EX_EN))
+    if (event & FPM_RAM_MURAM_ECC)
         p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_MURAM_ECC);
 }
 
 static void IramErrIntr(t_Fm *p_Fm)
 {
-    uint32_t    event, mask;
-
-    event = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr) ;
-    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
-
-    ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC);
-
-    /* clear the acknowledged events (do not clear IRAM event) */
-    /* Prior to V3 this event bit clearing does not work ! ) */
-   WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, event & ~FPM_RAM_CTL_MURAM_ECC);
+    uint32_t    event;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
-    ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC_EN);
+    event = fman_get_iram_err_event(fpm_rg);
 
-    if ((mask & FPM_IRAM_ECC_ERR_EX_EN))
+    if (event & FPM_RAM_IRAM_ECC)
         p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_IRAM_ECC);
 }
 
 static void QmiEvent(t_Fm *p_Fm)
 {
-    uint32_t    event, mask, force;
-
-    event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie);
-    mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
-
-    event &= mask;
-
-    /* clear the forced events */
-    force = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_if);
-    if (force & event)
-        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, force & ~event);
+    uint32_t    event;
+    struct fman_qmi_regs *qmi_rg = p_Fm->p_FmQmiRegs;
 
-    /* clear the acknowledged events */
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, event);
+    event = fman_get_qmi_event(qmi_rg);
 
     if (event & QMI_INTR_EN_SINGLE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
@@ -439,34 +382,13 @@ static void UnimplementedFmanCtrlIsr(t_Handle h_Arg, uint32_t event)
 
 static void EnableTimeStamp(t_Fm *p_Fm)
 {
-    uint64_t                fraction;
-    uint32_t                integer, tsFrequency, tmpReg;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
     ASSERT_COND(p_Fm);
     ASSERT_COND(p_Fm->p_FmStateStruct);
     ASSERT_COND(p_Fm->p_FmStateStruct->count1MicroBit);
 
-    tsFrequency = (uint32_t)(1<<p_Fm->p_FmStateStruct->count1MicroBit); /* in Mhz */
-
-    /* configure timestamp so that bit 8 will count 1 microsecond */
-    /* Find effective count rate at TIMESTAMP least significant bits:
-       Effective_Count_Rate = 1MHz x 2^8 = 256MHz
-       Find frequency ratio between effective count rate and the clock:
-       Effective_Count_Rate / CLK e.g. for 600 MHz clock:
-       256/600 = 0.4266666... */
-    integer = tsFrequency/p_Fm->p_FmStateStruct->fmClkFreq;
-    /* we multiply by 2^16 to keep the fraction of the division */
-    /* we do not divide back, since we write this value as fraction - see spec */
-    fraction = ((tsFrequency << 16) - (integer << 16) * p_Fm->p_FmStateStruct->fmClkFreq) / p_Fm->p_FmStateStruct->fmClkFreq;
-    /* we check remainder of the division in order to round up if not integer */
-    if (((tsFrequency << 16) - (integer << 16) * p_Fm->p_FmStateStruct->fmClkFreq) % p_Fm->p_FmStateStruct->fmClkFreq)
-        fraction++;
-
-    tmpReg = (integer << FPM_TS_INT_SHIFT) | (uint16_t)fraction;
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_tsc2, tmpReg);
-
-    /* enable timestamp with original clock */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_tsc1, FPM_TS_CTL_EN);
+    fman_enable_time_stamp(fpm_rg, p_Fm->p_FmStateStruct->count1MicroBit, p_Fm->p_FmStateStruct->fmClkFreq);
 
     p_Fm->p_FmStateStruct->enabledTimeStamp = TRUE;
 }
@@ -507,31 +429,31 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
     WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
     while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
 
-    for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
-        WRITE_UINT32(p_Iram->idata, p_Fm->p_FmDriverParam->firmware.p_Code[i]);
+    for (i=0; i < (p_Fm->firmware.size / 4); i++)
+        WRITE_UINT32(p_Iram->idata, p_Fm->firmware.p_Code[i]);
 
-    compTo16 = (uint8_t)(p_Fm->p_FmDriverParam->firmware.size % 16);
+    compTo16 = (uint8_t)(p_Fm->firmware.size % 16);
     if (compTo16)
         for (i=0; i < ((16-compTo16) / 4); i++)
             WRITE_UINT32(p_Iram->idata, 0xffffffff);
 
-    WRITE_UINT32(p_Iram->iadd,p_Fm->p_FmDriverParam->firmware.size-4);
-    while (GET_UINT32(p_Iram->iadd) != (p_Fm->p_FmDriverParam->firmware.size-4)) ;
+    WRITE_UINT32(p_Iram->iadd,p_Fm->firmware.size-4);
+    while (GET_UINT32(p_Iram->iadd) != (p_Fm->firmware.size-4)) ;
 
     /* verify that writing has completed */
-    while (GET_UINT32(p_Iram->idata) != p_Fm->p_FmDriverParam->firmware.p_Code[(p_Fm->p_FmDriverParam->firmware.size / 4)-1]) ;
+    while (GET_UINT32(p_Iram->idata) != p_Fm->firmware.p_Code[(p_Fm->firmware.size / 4)-1]) ;
 
-    if (p_Fm->p_FmDriverParam->fwVerify)
+    if (p_Fm->fwVerify)
     {
         WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
         while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
-        for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
+        for (i=0; i < (p_Fm->firmware.size / 4); i++)
         {
             tmp = GET_UINT32(p_Iram->idata);
-            if (tmp != p_Fm->p_FmDriverParam->firmware.p_Code[i])
+            if (tmp != p_Fm->firmware.p_Code[i])
                 RETURN_ERROR(MAJOR, E_WRITE_FAILED,
                              ("UCode write error : write 0x%x, read 0x%x",
-                              p_Fm->p_FmDriverParam->firmware.p_Code[i],tmp));
+                              p_Fm->firmware.p_Code[i],tmp));
         }
         WRITE_UINT32(p_Iram->iadd, 0x0);
     }
@@ -541,9 +463,9 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
     XX_UDelay(1000);
 
     DBG(INFO, ("FMan-Controller code (ver %d.%d.%d) loaded to IRAM.",
-               ((uint16_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[2],
-               ((uint8_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[6],
-               ((uint8_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[7]));
+               ((uint16_t *)p_Fm->firmware.p_Code)[2],
+               ((uint8_t *)p_Fm->firmware.p_Code)[6],
+               ((uint8_t *)p_Fm->firmware.p_Code)[7]));
 
     return E_OK;
 }
@@ -553,6 +475,7 @@ static t_Error FwNotResetErratumBugzilla6173WA(t_Fm *p_Fm)
 {
     t_FMIramRegs    *p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
     uint32_t        tmpReg;
+    uint32_t        savedSpliodn[63];
 
     /* write to IRAM first location the debug instruction */
     WRITE_UINT32(p_Iram->iadd, 0);
@@ -567,6 +490,9 @@ static t_Error FwNotResetErratumBugzilla6173WA(t_Fm *p_Fm)
     WRITE_UINT32(p_Iram->iready, IRAM_READY);
     CORE_MemoryBarrier();
     XX_UDelay(100);
+    IO2MemCpy32((uint8_t *)savedSpliodn,
+                (uint8_t *)p_Fm->p_FmBmiRegs->fmbm_spliodn,
+                63*sizeof(uint32_t));
 
     /* reset FMAN */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
@@ -583,7 +509,7 @@ static t_Error FwNotResetErratumBugzilla6173WA(t_Fm *p_Fm)
     /*************************************/
     if (ClearIRam(p_Fm) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-    if (p_Fm->p_FmDriverParam->firmware.p_Code &&
+    if (p_Fm->firmware.p_Code &&
         (LoadFmanCtrlCode(p_Fm) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
     XX_UDelay(100);
@@ -592,13 +518,13 @@ static t_Error FwNotResetErratumBugzilla6173WA(t_Fm *p_Fm)
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
     CORE_MemoryBarrier();
     XX_UDelay(100);
+    Mem2IOCpy32((uint8_t *)p_Fm->p_FmBmiRegs->fmbm_spliodn,
+                (uint8_t *)savedSpliodn,
+                63*sizeof(uint32_t));
 
-    if (GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gs) & QMI_GS_HALT_NOT_BUSY)
+    if (fman_is_qmi_halt_not_busy_state(p_Fm->p_FmQmiRegs))
     {
-        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
-        /* clear tmpReg event bits in order not to clear standing events */
-        tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg | FPM_EV_MASK_RELEASE_FM);
+        fman_resume(p_Fm->p_FmFpmRegs);
         CORE_MemoryBarrier();
         XX_UDelay(100);
     }
@@ -683,7 +609,6 @@ static t_Error SetVSPWindow(t_Handle  h_Fm,
                             uint8_t   log2NumOfProfiles)
 {
     t_Fm                    *p_Fm = (t_Fm *)h_Fm;
-    uint32_t                tmpReg;
 
     ASSERT_COND(h_Fm);
     ASSERT_COND(hardwarePortId);
@@ -719,10 +644,10 @@ static t_Error SetVSPWindow(t_Handle  h_Fm,
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
                      ("Either IPC or 'baseAddress' is required!"));
 
-    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1]);
-    tmpReg |= (uint32_t)((uint32_t)baseStorageProfile & 0x3f) << 16;
-    tmpReg |= (uint32_t)log2NumOfProfiles << 28;
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], tmpReg);
+    fman_set_vsp_window(p_Fm->p_FmBmiRegs,
+                        hardwarePortId,
+                        baseStorageProfile,
+                        log2NumOfProfiles);
 
     return E_OK;
 }
@@ -1103,15 +1028,11 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
         case (FM_GET_PARAMS):
         {
              t_FmIpcParams  ipcParams;
-             uint32_t       tmpReg;
 
             /* Get clock frequency */
             ipcParams.fmClkFreq = p_Fm->p_FmStateStruct->fmClkFreq;
 
-            /* read FM revision register 1 */
-            tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
-            ipcParams.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
-            ipcParams.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+            fman_get_revision(p_Fm->p_FmFpmRegs,&ipcParams.majorRev,&ipcParams.minorRev);
 
             memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcParams, sizeof(t_FmIpcParams));
             *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcParams);
@@ -1262,12 +1183,12 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
-    int             timeout = 1000;
     t_Error         err = E_OK;
     t_FmIpcMsg      msg;
     t_FmIpcReply    reply;
     uint32_t        replyLength;
     uint8_t         rxHardwarePortId, txHardwarePortId;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -1298,13 +1219,8 @@ t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
         (p_Fm->p_FmStateStruct->portsTypes[txHardwarePortId] != e_FM_PORT_TYPE_DUMMY))
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
                      ("MAC should be initialized prior to Rx and Tx ports!"));
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_extc, 0x40000000);
-    CORE_MemoryBarrier();
-    while ((GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_extc) & 0x40000000) &&
-           --timeout) ;
-    if (!timeout)
-        return ERROR_CODE(E_TIMEOUT);
-    return E_OK;
+
+    return fman_set_erratum_10gmac_a004_wa(fpm_rg);
 }
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
@@ -1374,35 +1290,11 @@ t_Error FmSetCongestionGroupPFCpriority(t_Handle    h_Fm,
 
     if (p_Fm->guestId == NCSW_MASTER_ID)
     {
-        uint32_t    *p_Cpg = (uint32_t*)(p_Fm->baseAddr+FM_MM_CGP);
-        uint32_t    tmpReg;
-        uint32_t    reg_num;
-        uint32_t    offset;
-        uint32_t    mask;
-
         ASSERT_COND(p_Fm->baseAddr);
-        reg_num = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))/4;
-        offset  = (congestionGroupId%4);
-
-        tmpReg = GET_UINT32(p_Cpg[reg_num]);
-
-        /* Adding priorities*/
-        if (priorityBitMap)
-        {
-            if (tmpReg & (0xFF << (offset*8)))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                             ("PFC priority for the congestion group is already set!"));
-        }
-        else /* Deleting priorities */
-        {
-            mask = (uint32_t)(0xFF << (offset*8));
-            tmpReg &= ~mask;
-        }
-
-        tmpReg |= (uint32_t)priorityBitMap << (offset*8);
-        WRITE_UINT32(p_Cpg[reg_num], tmpReg);
+        fman_set_congestion_group_pfc_priority((uint32_t *)((p_Fm->baseAddr+FM_MM_CGP)),
+                                               congestionGroupId,
+                                               priorityBitMap);
     }
-
     else if (p_Fm->h_IpcSessions[0])
     {
         t_Error                              err;
@@ -1756,6 +1648,7 @@ void FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId)
 void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, uint32_t enableEvents)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->p_FmFpmRegs &&
@@ -1789,12 +1682,13 @@ void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, uint32_t enableEvents)
     }
 
     ASSERT_COND(eventRegId < FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[eventRegId], enableEvents);
+    fman_set_ctrl_intr(fpm_rg, eventRegId, enableEvents);
 }
 
 uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->p_FmFpmRegs &&
@@ -1837,7 +1731,7 @@ uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
         return 0;
     }
 
-    return GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[eventRegId]);
+    return fman_get_ctrl_intr(fpm_rg, eventRegId);
 }
 
 void FmRegisterIntr(t_Handle                h_Fm,
@@ -1979,11 +1873,12 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle     h_Fm,
 {
 
     t_Fm                        *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                    tmpReg = 0;
+    struct fman_fpm_regs *fpm_rg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((numOfFmanCtrls > 0) && (numOfFmanCtrls < 3)) , E_INVALID_HANDLE);
 
+    fpm_rg = p_Fm->p_FmFpmRegs;
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->p_FmFpmRegs &&
         p_Fm->h_IpcSessions[0])
@@ -2013,26 +1908,23 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle     h_Fm,
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
                      ("Either IPC or 'baseAddress' is required!"));
 
-    tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
-
-    /* TODO - maybe to put CTL# according to another criteria */
-    if (numOfFmanCtrls == 2)
-        tmpReg = FPM_PORT_FM_CTL2 | FPM_PORT_FM_CTL1;
-
-    /* order restoration */
-    tmpReg |= (orFmanCtrl << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | orFmanCtrl;
-
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_prc, tmpReg);
+    fman_set_num_of_riscs_per_port(fpm_rg, hardwarePortId, numOfFmanCtrls, orFmanCtrl);
 
     return E_OK;
 }
 
-t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
+t_Error FmGetSetPortParams(t_Handle h_Fm, t_FmInterModulePortInitParams *p_PortParams)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     t_Error                 err;
-    uint32_t                tmpReg, intFlags;
+    uint32_t                intFlags;
     uint8_t                 hardwarePortId = p_PortParams->hardwarePortId, macId;
+    struct fman_rg          fman_rg;
+
+    fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
+    fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
+    fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
+    fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -2093,7 +1985,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         /* set port parameters */
         p_Fm->independentMode = p_PortParams->independentMode;
         /* disable dispatch limit */
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_mxd, 0);
+        fman_qmi_disable_dispatch_limit(fman_rg.fpm_rg);
     }
 
     if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
@@ -2124,33 +2016,25 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     {
         uint8_t     enqTh;
         uint8_t     deqTh;
-        bool        update = FALSE;
 
         /* update qmi ENQ/DEQ threshold */
         p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums += p_PortParams->deqPipelineDepth;
-        tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
-        enqTh = (uint8_t)(tmpReg>>8);
+        enqTh = fman_get_qmi_enq_th(fman_rg.qmi_rg);
         /* if enqTh is too big, we reduce it to the max value that is still OK */
         if (enqTh >= (QMI_MAX_NUM_OF_TNUMS - p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums))
         {
             enqTh = (uint8_t)(QMI_MAX_NUM_OF_TNUMS - p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums - 1);
-            tmpReg &= ~QMI_CFG_ENQ_MASK;
-            tmpReg |= ((uint32_t)enqTh << 8);
-            update = TRUE;
+            fman_set_qmi_enq_th(fman_rg.qmi_rg, enqTh);
         }
 
-        deqTh = (uint8_t)tmpReg;
+        deqTh = fman_get_qmi_deq_th(fman_rg.qmi_rg);
         /* if deqTh is too small, we enlarge it to the min value that is still OK.
          deqTh may not be larger than 63 (QMI_MAX_NUM_OF_TNUMS-1). */
         if ((deqTh <= p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums)  && (deqTh < QMI_MAX_NUM_OF_TNUMS-1))
         {
             deqTh = (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums + 1);
-            tmpReg &= ~QMI_CFG_DEQ_MASK;
-            tmpReg |= (uint32_t)deqTh;
-            update = TRUE;
+            fman_set_qmi_deq_th(fman_rg.qmi_rg, deqTh);
         }
-        if (update)
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
     }
 
 #ifdef FM_LOW_END_RESTRICTION
@@ -2188,44 +2072,16 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], (uint32_t)p_PortParams->liodnOffset);
+    fman_set_liodn_per_port(&fman_rg,
+                            hardwarePortId,
+                            p_PortParams->liodnBase,
+                            p_PortParams->liodnOffset);
 
     if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
-    {
-        tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
-        if (p_PortParams->independentMode)
-        {
-            if ((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
-                tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
-            else
-                tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
-        }
-        else
-        {
-            tmpReg |= (FPM_PORT_FM_CTL2|FPM_PORT_FM_CTL1);
-
-            /* order restoration */
-            if (hardwarePortId%2)
-                tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
-            else
-                tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
-        }
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_prc, tmpReg);
-    }
-
-    /* set LIODN base for this port */
-    tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
-    if (hardwarePortId%2)
-    {
-        tmpReg &= ~FM_LIODN_BASE_MASK;
-        tmpReg |= (uint32_t)p_PortParams->liodnBase;
-    }
-    else
-    {
-        tmpReg &= ~(FM_LIODN_BASE_MASK<< DMA_LIODN_SHIFT);
-        tmpReg |= (uint32_t)p_PortParams->liodnBase << DMA_LIODN_SHIFT;
-    }
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], tmpReg);
+        fman_set_order_restoration_per_port(fman_rg.fpm_rg,
+                                            hardwarePortId,
+                                            p_PortParams->independentMode,
+                                            !!((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G)));
 
     HW_PORT_ID_TO_SW_PORT_ID(macId, hardwarePortId);
 
@@ -2260,12 +2116,15 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                tmpReg, intFlags;
+    uint32_t                intFlags;
     uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
-    uint8_t                 numOfTasks, macId;
+    uint8_t                 numOfTasks, numOfDmas, macId;
+    uint16_t                sizeOfFifo;
     t_Error                 err;
     t_FmIpcPortFreeParams   portParams;
     t_FmIpcMsg              msg;
+    struct fman_qmi_regs *qmi_rg = p_Fm->p_FmQmiRegs;
+    struct fman_bmi_regs *bmi_rg = p_Fm->p_FmBmiRegs;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -2299,34 +2158,32 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 
     p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] = e_FM_PORT_TYPE_DUMMY;
 
-    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
     /* free numOfTasks */
-    numOfTasks = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
+    numOfTasks = fman_get_num_of_tasks(bmi_rg, hardwarePortId);
     ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= numOfTasks);
     p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= numOfTasks;
 
     /* free numOfOpenDmas */
-    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >=
-        ((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
-    p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -=
-        (((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
+    numOfDmas = fman_get_num_of_dmas(bmi_rg, hardwarePortId);
+    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >= numOfDmas);
+    p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -= numOfDmas;
 
 #ifdef FM_HAS_TOTAL_DMAS
     if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
         /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
-        tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+        fman_set_num_of_open_dmas(bmi_rg,
+                                  hardwarePortId,
+                                  1,
+                                  0,
+                         (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize));
     }
 #endif /* FM_HAS_TOTAL_DMAS */
 
     /* free sizeOfFifo */
-    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
-    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >=
-                (((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS));
-    p_Fm->p_FmStateStruct->accumulatedFifoSize -=
-        (((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS);
+    sizeOfFifo = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
+    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= (sizeOfFifo * BMI_FIFO_UNITS));
+    p_Fm->p_FmStateStruct->accumulatedFifoSize -= (sizeOfFifo * BMI_FIFO_UNITS);
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
@@ -2338,31 +2195,23 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
         uint8_t     enqTh;
         uint8_t     deqTh;
 
-        tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
         /* update qmi ENQ/DEQ threshold */
         p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums -= p_PortParams->deqPipelineDepth;
 
         /* p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums is now smaller,
            so we can enlarge enqTh */
         enqTh = (uint8_t)(QMI_MAX_NUM_OF_TNUMS - p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums - 1);
-        tmpReg &= ~QMI_CFG_ENQ_MASK;
-        tmpReg |= ((uint32_t)enqTh << QMI_CFG_ENQ_SHIFT);
 
          /* p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums is now smaller,
             so we can reduce deqTh */
         deqTh = (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums + 1);
-        tmpReg &= ~QMI_CFG_DEQ_MASK;
-        tmpReg |= (uint32_t)deqTh;
 
-        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
+        fman_set_qmi_enq_th(qmi_rg, enqTh);
+        fman_set_qmi_deq_th(qmi_rg, deqTh);
     }
 
     HW_PORT_ID_TO_SW_PORT_ID(macId, hardwarePortId);
 
-    /* Delete prefetch configuration*/
-    p_Fm->portsPreFetchConfigured[macId] = FALSE;
-    p_Fm->portsPreFetchValue[macId]      = FALSE;
-
 #if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
     if ((p_PortParams->portType == e_FM_PORT_TYPE_TX_10G) ||
         (p_PortParams->portType == e_FM_PORT_TYPE_RX_10G))
@@ -2389,11 +2238,11 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
-    uint32_t        tmpReg;
     t_Error         err;
     t_FmIpcMsg      msg;
     t_FmIpcReply    reply;
     uint32_t        replyLength;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
@@ -2424,8 +2273,7 @@ t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
                      ("Either IPC or 'baseAddress' is required!"));
 
-    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId]);
-    *p_IsStalled = (bool)!!(tmpReg & FPM_PS_STALLED);
+    *p_IsStalled = fman_is_port_stalled(fpm_rg, hardwarePortId);
 
     return E_OK;
 }
@@ -2433,9 +2281,9 @@ t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled
 t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
-    uint32_t        tmpReg;
     t_Error         err;
     bool            isStalled;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
@@ -2477,8 +2325,7 @@ t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
     if (!isStalled)
         return E_OK;
 
-    tmpReg = (uint32_t)((hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT) | FPM_PRC_REALSE_STALLED);
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_prc, tmpReg);
+    fman_resume_stalled_port(fpm_rg, hardwarePortId);
 
     return E_OK;
 }
@@ -2486,19 +2333,20 @@ t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
 t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    uint32_t            bitMask;
+    t_Error             err;
+    struct fman_fpm_regs *fpm_rg = p_Fm->p_FmFpmRegs;
 
-#ifndef FM_MAC_RESET
+#if (DPAA_VERSION >= 11)
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        return E_OK;
-#endif /*(FM_MAC_RESET >= 11)*/
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("FMan MAC reset!"));
+#endif /*(DPAA_VERSION >= 11)*/
 
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
         p_Fm->h_IpcSessions[0])
     {
         t_FmIpcMacParams    macParams;
-        t_Error             err;
         t_FmIpcMsg          msg;
         t_FmIpcReply        reply;
         uint32_t            replyLength;
@@ -2527,56 +2375,12 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
                      ("Either IPC or 'baseAddress' is required!"));
 
-    /* Get the relevant bit mask */
-    if (type == e_FM_MAC_10G)
-    {
-        switch (macId)
-        {
-            case (0):
-                bitMask = FPM_RSTC_10G0_RESET;
-                break;
-            case (1):
-                bitMask = FPM_RSTC_10G1_RESET;
-                break;
-            default:
-                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
-        }
-    }
-    else
-    {
-        switch (macId)
-        {
-            case (0):
-                bitMask = FPM_RSTC_1G0_RESET;
-                break;
-            case (1):
-                bitMask = FPM_RSTC_1G1_RESET;
-                break;
-            case (2):
-                bitMask = FPM_RSTC_1G2_RESET;
-                break;
-            case (3):
-                bitMask = FPM_RSTC_1G3_RESET;
-                break;
-            case (4):
-                bitMask = FPM_RSTC_1G4_RESET;
-                break;
-            case (5):
-                bitMask = FPM_RSTC_1G5_RESET;
-                break;
-            case (6):
-                bitMask = FPM_RSTC_1G6_RESET;
-                break;
-            case (7):
-                bitMask = FPM_RSTC_1G7_RESET;
-                break;
-            default:
-                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
-        }
-    }
+    err = (t_Error)fman_reset_mac(fpm_rg, macId, !!(type == e_FM_MAC_10G));
 
-    /* reset */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, bitMask);
+    if (err == E_INVALID_VALUE)
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
+    else if (err == E_TIMEOUT)
+        return ERROR_CODE(E_TIMEOUT);
 
     return E_OK;
 }
@@ -2738,7 +2542,6 @@ bool FmIsMaster(t_Handle h_Fm)
     return (p_Fm->guestId == NCSW_MASTER_ID);
 }
 
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
 t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
                         uint8_t     hardwarePortId,
                         uint32_t    *p_SizeOfFifo,
@@ -2748,8 +2551,9 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     t_FmIpcPortRsrcParams   rsrcParams;
     t_Error                 err;
-    uint32_t                tmpReg = 0, sizeOfFifo = *p_SizeOfFifo, extraSizeOfFifo = *p_ExtraSizeOfFifo;
-    uint16_t                oldVal = 0;
+    struct fman_bmi_regs    *bmi_rg = p_Fm->p_FmBmiRegs;
+    uint32_t                sizeOfFifo = *p_SizeOfFifo, extraSizeOfFifo = *p_ExtraSizeOfFifo;
+    uint16_t                currentVal = 0, currentExtraVal = 0;
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
 
@@ -2788,142 +2592,40 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     {
         DBG(WARNING, ("No IPC - can't validate FM total-fifo size."));
 
-        tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
-                            ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
-    }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
-
-    if (!initialConfig)
-    {
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
-        /* read into oldVal the current extra fifo size */
-        oldVal = (uint16_t)((((tmpReg & BMI_EXTRA_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS) >> BMI_EXTRA_FIFO_SIZE_SHIFT);
-    }
-
-    if (extraSizeOfFifo > oldVal)
+#ifndef FM_NO_GUARANTEED_RESET_VALUES
+        if (!sizeOfFifo)
+        /* first config without explicit value: Do Nothing - reset value shouldn't be
+           changed, read register for port save */
     {
-        if (extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
-            /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
-             * must be initialized to 1 buffer per port
-             */
-            p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
-
-        p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
+            *p_ExtraSizeOfFifo = fman_get_size_of_extra_fifo(bmi_rg, hardwarePortId);
+            *p_SizeOfFifo = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
     }
-
-    if (!initialConfig)
-        /* read into oldVal the current num of tasks */
-        oldVal = (uint16_t)(((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS);
-
-    /* check that there are enough uncommitted fifo size */
-    if ((p_Fm->p_FmStateStruct->accumulatedFifoSize - oldVal + sizeOfFifo) >
-        (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
     else
-    {
-        /* update accumulated */
-        ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= oldVal);
-        p_Fm->p_FmStateStruct->accumulatedFifoSize -= oldVal;
-        p_Fm->p_FmStateStruct->accumulatedFifoSize += sizeOfFifo;
-        /* calculate reg */
-        tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
-                            ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
-    }
-
-    return E_OK;
-}
-
-#else /*FM_NO_GUARANTEED_RESET_VALUES*/
-t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
-                        uint8_t     hardwarePortId,
-                        uint32_t    *p_SizeOfFifo,
-                        uint32_t    *p_ExtraSizeOfFifo,
-                        bool        initialConfig)
-{
-    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    t_FmIpcPortRsrcParams   rsrcParams;
-    t_Error                 err;
-    uint32_t                tmpReg = 0, sizeOfFifo = *p_SizeOfFifo, extraSizeOfFifo = *p_ExtraSizeOfFifo;
-    uint16_t                currentVal, currentExtraVal;
-
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    /* it's illegal to be in a state where this is not the first set and no value is specified */
-    ASSERT_COND(initialConfig || sizeOfFifo);
-
-    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
-        !p_Fm->baseAddr &&
-        p_Fm->h_IpcSessions[0])
-    {
-        t_FmIpcMsg          msg;
-        t_FmIpcReply        reply;
-        uint32_t            replyLength;
-
-        rsrcParams.hardwarePortId = hardwarePortId;
-        rsrcParams.val = sizeOfFifo;
-        rsrcParams.extra = extraSizeOfFifo;
-        rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
-
-        memset(&msg, 0, sizeof(msg));
-        memset(&reply, 0, sizeof(reply));
-        msg.msgId = FM_SET_SIZE_OF_FIFO;
-        memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
-        replyLength = sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(rsrcParams),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        if (replyLength != sizeof(uint32_t))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        return (t_Error)(reply.error);
-    }
-    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
-             p_Fm->baseAddr)
-    {
-        DBG(WARNING, ("No IPC - can't validate FM total-fifo size."));
-
-        if (sizeOfFifo)
-        {
             /* whether it is the first time with explicit value, or runtime "set" - write register */
-            tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
-                                ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
-        }
-        else /* first config without explicit value: Do Nothing - reset value shouldn't be
-                changed, read register for port save */
-        {
-            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
-            /* read into oldVal the current extra fifo size */
-            *p_ExtraSizeOfFifo = (uint16_t)((((tmpReg & BMI_EXTRA_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS) >> BMI_EXTRA_FIFO_SIZE_SHIFT);
-            *p_SizeOfFifo = (uint16_t)(((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS);
-        }
+#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
+        fman_set_size_of_fifo(bmi_rg, hardwarePortId, sizeOfFifo, extraSizeOfFifo);
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
                      ("running in guest-mode without neither IPC nor mapped register!"));
 
-    if (!initialConfig || !sizeOfFifo)
+    if (!initialConfig)
     {
         /* !initialConfig - runtime change of existing value.
-         * !numOfTasks - first configuration according to values in regs.
-         * In both cases: read the current FIFO size */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
-        /* read into oldVal the current extra fifo size */
-        currentExtraVal = (uint16_t)((((tmpReg & BMI_EXTRA_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS) >> BMI_EXTRA_FIFO_SIZE_SHIFT);
-        currentVal = (uint16_t)(((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS);
+         * - read the current FIFO and extra FIFO size */
+        currentExtraVal = fman_get_size_of_extra_fifo(bmi_rg, hardwarePortId);
+        currentVal = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
     }
-    else /* first time and sizeOfFifo explicitly specified */
-        currentVal = currentExtraVal = 0;
 
+#ifndef FM_NO_GUARANTEED_RESET_VALUES
+    /* it's illegal to be in a state where this is not the first set and no value is specified */
+    ASSERT_COND(initialConfig || sizeOfFifo);
     if (!sizeOfFifo)
     {
+        /* !sizeOfFifo - first configuration according to values in regs.
+         * - read the current FIFO  and extra FIFO size  */
+        currentExtraVal = fman_get_size_of_extra_fifo(bmi_rg, hardwarePortId);
+        currentVal = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
         /* This is the first configuration and user did not specify value (!numOfTasks),
          * reset values will be used and we just save these values for resource management */
         if (currentExtraVal)
@@ -2944,14 +2646,13 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
 
         *p_SizeOfFifo = currentVal;
         *p_ExtraSizeOfFifo = currentExtraVal;
-
+        return E_OK;
     }
-    else
-    {
-        /* user requires a specific value.
+    /* else: user requires a specific value.
          * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
          * otherwise they hold the value written in the register.
          */
+#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
         if (extraSizeOfFifo > currentExtraVal)
         {
             if (extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
@@ -2973,21 +2674,12 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
             ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= currentVal);
             p_Fm->p_FmStateStruct->accumulatedFifoSize -= currentVal;
             p_Fm->p_FmStateStruct->accumulatedFifoSize += sizeOfFifo;
-            /* calculate reg */
-            tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
-                                ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
-        }
-        *p_SizeOfFifo = sizeOfFifo;
-        *p_ExtraSizeOfFifo = extraSizeOfFifo;
-
+        fman_set_size_of_fifo(bmi_rg, hardwarePortId, sizeOfFifo, extraSizeOfFifo);
     }
 
     return E_OK;
 }
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
 
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
 t_Error FmSetNumOfTasks(t_Handle    h_Fm,
                         uint8_t     hardwarePortId,
                         uint8_t     *p_NumOfTasks,
@@ -2996,8 +2688,8 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
 {
     t_Fm                    *p_Fm = (t_Fm *)h_Fm;
     t_Error                 err;
-    uint32_t                tmpReg = 0;
-    uint8_t                 oldVal = 0, numOfTasks = *p_NumOfTasks, numOfExtraTasks = *p_NumOfExtraTasks;
+    struct fman_bmi_regs    *bmi_rg = p_Fm->p_FmBmiRegs;
+    uint8_t                 currentVal = 0, currentExtraVal = 0, numOfTasks = *p_NumOfTasks, numOfExtraTasks = *p_NumOfExtraTasks;
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
 
@@ -3037,11 +2729,18 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
     {
         DBG(WARNING, ("No IPC - can't validate FM total-num-of-tasks."));
 
-        /* calculate reg */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
-        tmpReg |= (uint32_t)(((numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
-                    (numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
+#ifndef FM_NO_GUARANTEED_RESET_VALUES
+        if (!numOfTasks)
+        /* first config without explicit value: Do Nothing - reset value shouldn't be
+           changed, read register for port save */
+    {
+           *p_NumOfTasks = fman_get_num_of_tasks(bmi_rg, hardwarePortId);
+           *p_NumOfExtraTasks = fman_get_num_extra_tasks(bmi_rg, hardwarePortId);
+    }
+    else
+            /* whether it is the first time with explicit value, or runtime "set" - write register */
+#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
+        fman_set_num_of_tasks(bmi_rg, hardwarePortId, numOfTasks, numOfExtraTasks);
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
@@ -3049,56 +2748,76 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
 
     if (!initialConfig)
     {
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
-        /* read into oldVal the current extra tasks */
-        oldVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_TASKS_MASK) >> BMI_EXTRA_NUM_OF_TASKS_SHIFT);
+        /* !initialConfig - runtime change of existing value.
+         * - read the current number of tasks */
+        currentVal = fman_get_num_of_tasks(bmi_rg, hardwarePortId);
+        currentExtraVal = fman_get_num_extra_tasks(bmi_rg, hardwarePortId);
     }
 
-    if (numOfExtraTasks > oldVal)
-        p_Fm->p_FmStateStruct->extraTasksPoolSize =
-            (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
-
-    if (!initialConfig)
-        /* read into oldVal the current num of tasks */
-        oldVal = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
-
-    /* check that there are enough uncommitted tasks */
-    if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - oldVal + numOfTasks) >
-       (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                     ("Requested numOfTasks and extra tasks pool for fm%d exceed total numOfTasks.",
-                      p_Fm->p_FmStateStruct->fmId));
-    else
+#ifndef FM_NO_GUARANTEED_RESET_VALUES
+    /* it's illegal to be in a state where this is not the first set and no value is specified */
+    ASSERT_COND(initialConfig || numOfTasks);
+    if (!numOfTasks)
     {
-        ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= oldVal);
+        /* !numOfTasks - first configuration according to values in regs.
+         * - read the current number of tasks */
+        currentVal = fman_get_num_of_tasks(bmi_rg, hardwarePortId);
+        currentExtraVal = fman_get_num_extra_tasks(bmi_rg, hardwarePortId);
+        /* This is the first configuration and user did not specify value (!numOfTasks),
+         * reset values will be used and we just save these values for resource management */
+         p_Fm->p_FmStateStruct->extraTasksPoolSize =
+                    (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, currentExtraVal);
+         if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks + currentVal) >
+                 (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
+             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                                      ("Total ports' numOfTasks and extra tasks pool for fm%d exceed total available numOfTasks.",
+                                       p_Fm->p_FmStateStruct->fmId));
+        p_Fm->p_FmStateStruct->accumulatedNumOfTasks += currentVal;
+        *p_NumOfTasks = currentVal;
+        *p_NumOfExtraTasks = currentExtraVal;
+        return E_OK;
+    }
+    /* else - user requires a specific value.
+         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
+         * otherwise they hold the value written in the register.
+         */
+#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
+        if (numOfExtraTasks > currentExtraVal)
+             p_Fm->p_FmStateStruct->extraTasksPoolSize =
+                 (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
+
+        /* check that there are enough uncommitted tasks */
+        if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - currentVal + numOfTasks) >
+           (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                         ("Requested numOfTasks and extra tasks pool for fm%d exceed total numOfTasks.",
+                          p_Fm->p_FmStateStruct->fmId));
+        else
+        {
+            ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= currentVal);
         /* update accumulated */
-        p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= oldVal;
-        p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
-        /* calculate reg */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
-        tmpReg |= (uint32_t)(((numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
-                    (numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
+            p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= currentVal;
+            p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
+        fman_set_num_of_tasks(bmi_rg, hardwarePortId, numOfTasks, numOfExtraTasks);
     }
 
     return E_OK;
 }
 
-#else /*FM_NO_GUARANTEED_RESET_VALUES*/
-t_Error FmSetNumOfTasks(t_Handle    h_Fm,
-                        uint8_t     hardwarePortId,
-                        uint8_t     *p_NumOfTasks,
-                        uint8_t     *p_NumOfExtraTasks,
-                        bool        initialConfig)
+t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
+                           uint8_t hardwarePortId,
+                           uint8_t *p_NumOfOpenDmas,
+                           uint8_t *p_NumOfExtraOpenDmas,
+                           bool    initialConfig)
+
 {
     t_Fm                    *p_Fm = (t_Fm *)h_Fm;
     t_Error                 err;
-    uint32_t                tmpReg = 0;
-    uint8_t                 currentVal, currentExtraVal,numOfTasks = *p_NumOfTasks, numOfExtraTasks = *p_NumOfExtraTasks;
+    struct fman_bmi_regs    *bmi_rg = p_Fm->p_FmBmiRegs;
+    uint8_t                 numOfOpenDmas = *p_NumOfOpenDmas, numOfExtraOpenDmas = *p_NumOfExtraOpenDmas;
+    uint8_t                 totalNumDmas = 0, currentVal = 0, currentExtraVal = 0;
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    /* it's illegal to be in a state where this is not the first set and no value is specified */
-    ASSERT_COND(initialConfig || numOfTasks);
 
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
@@ -3110,13 +2829,13 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
         uint32_t                replyLength;
 
         rsrcParams.hardwarePortId = hardwarePortId;
-        rsrcParams.val = numOfTasks;
-        rsrcParams.extra = numOfExtraTasks;
+        rsrcParams.val = numOfOpenDmas;
+        rsrcParams.extra = numOfExtraOpenDmas;
         rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
 
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
-        msg.msgId = FM_SET_NUM_OF_TASKS;
+        msg.msgId = FM_SET_NUM_OF_OPEN_DMAS;
         memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
         replyLength = sizeof(uint32_t);
         if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
@@ -3131,157 +2850,33 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         return (t_Error)(reply.error);
     }
+#ifdef FM_HAS_TOTAL_DMAS
+    else if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("running in guest-mode without IPC!"));
+#else
     else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
-             p_Fm->baseAddr)
+             p_Fm->baseAddr &&
+             (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
     {
-        DBG(WARNING, ("No Ipc - can't validate FM total-num-of-tasks."));
+        /*DBG(WARNING, ("No IPC - can't validate FM total-num-of-dmas."));*/
 
-        if (numOfTasks)
-        {
-            /* whether it is the first time with explicit value, or runtime "set" - write register */
-            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
-            tmpReg |= (uint32_t)(((numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
-                        (numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
-        }
-        else /* first config without explicit value: Do Nothing - reset value shouldn't be
-                 changed, read register for port save */
-         {
-            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
-            *p_NumOfTasks = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
-            *p_NumOfExtraTasks = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_TASKS_MASK) >> BMI_EXTRA_NUM_OF_TASKS_SHIFT);
-         }
-
-    }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
-
-    if (!initialConfig || !numOfTasks)
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
+        if (!numOfOpenDmas)
     {
-        /* !initialConfig - runtime change of existing value.
-         * !numOfTasks - first configuration according to values in regs.
-         * In both cases: read the current number of tasks */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
-        currentVal = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
-        currentExtraVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_TASKS_MASK) >> BMI_EXTRA_NUM_OF_TASKS_SHIFT);
-    }
-    else /* first time and numOfTasks explicitly specified */
-        currentVal = currentExtraVal = 0;
-
-    if (!numOfTasks)
-    {
-        /* This is the first configuration and user did not specify value (!numOfTasks),
-         * reset values will be used and we just save these values for resource management */
-         p_Fm->p_FmStateStruct->extraTasksPoolSize =
-                    (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, currentExtraVal);
-         if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks + currentVal) >
-                 (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
-             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                                      ("Total ports' numOfTasks and extra tasks pool for fm%d exceed total available numOfTasks.",
-                                       p_Fm->p_FmStateStruct->fmId));
-        p_Fm->p_FmStateStruct->accumulatedNumOfTasks += currentVal;
-        *p_NumOfTasks = currentVal;
-        *p_NumOfExtraTasks = currentExtraVal;
+         /* first config without explic it value: Do Nothing - reset value shouldn't be
+            changed, read register for port save */
+            *p_NumOfOpenDmas = fman_get_num_of_dmas(bmi_rg, hardwarePortId);
+            *p_NumOfExtraOpenDmas = fman_get_num_extra_dmas(bmi_rg, hardwarePortId);
     }
     else
-    {
-        /* user requires a specific value.
-         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
-         * otherwise they hold the value written in the register.
-         */
-        if (numOfExtraTasks > currentExtraVal)
-             p_Fm->p_FmStateStruct->extraTasksPoolSize =
-                 (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
-
-        /* check that there are enough uncommitted tasks */
-        if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - currentVal + numOfTasks) >
-           (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                         ("Requested numOfTasks and extra tasks pool for fm%d exceed total numOfTasks.",
-                          p_Fm->p_FmStateStruct->fmId));
-        else
-        {
-            ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= currentVal);
-            /* update acummulated */
-            p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= currentVal;
-            p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
-            /* calculate reg */
-            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
-            tmpReg |= (uint32_t)(((numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
-                        (numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
-        }
-        *p_NumOfTasks = numOfTasks;
-        *p_NumOfExtraTasks = numOfExtraTasks;
-    }
-
-    return E_OK;
-}
+            /* whether it is the first time with explicit value, or runtime "set" - write register */
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
-
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
-                            uint8_t hardwarePortId,
-                            uint8_t *p_NumOfOpenDmas,
-                            uint8_t *p_NumOfExtraOpenDmas,
-                            bool    initialConfig)
-
-{
-    t_Fm                    *p_Fm = (t_Fm *)h_Fm;
-    uint8_t                 oldVal = 0, numOfOpenDmas = *p_NumOfOpenDmas, numOfExtraOpenDmas = *p_NumOfExtraOpenDmas;
-    uint32_t                tmpReg = 0;
-    t_Error                 err;
-
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-
-    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
-        !p_Fm->baseAddr &&
-        p_Fm->h_IpcSessions[0])
-    {
-        t_FmIpcPortRsrcParams   rsrcParams;
-        t_FmIpcMsg              msg;
-        t_FmIpcReply            reply;
-        uint32_t                replyLength;
-
-        rsrcParams.hardwarePortId = hardwarePortId;
-        rsrcParams.val = numOfOpenDmas;
-        rsrcParams.extra = numOfExtraOpenDmas;
-        rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
-
-        memset(&msg, 0, sizeof(msg));
-        memset(&reply, 0, sizeof(reply));
-        msg.msgId = FM_SET_NUM_OF_OPEN_DMAS;
-        memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
-        replyLength = sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(rsrcParams),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        if (replyLength != sizeof(uint32_t))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        return (t_Error)(reply.error);
-    }
-#ifdef FM_HAS_TOTAL_DMAS
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without IPC!"));
-#else
-    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
-             p_Fm->baseAddr &&
-             (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
-    {
-        /*DBG(WARNING, ("No IPC - can't validate FM total-num-of-dmas."));*/
-
-        /* calculate reg */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
-        tmpReg |= (uint32_t)(((numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
-                    (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
+        fman_set_num_of_open_dmas(bmi_rg,
+                               hardwarePortId,
+                               numOfOpenDmas,
+                               numOfExtraOpenDmas,
+                               p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize);
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
@@ -3290,163 +2885,21 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
 
     if (!initialConfig)
     {
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
-        /* read into oldVal the current extra tasks */
-        oldVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_DMAS_MASK) >> BMI_EXTRA_NUM_OF_DMAS_SHIFT);
-    }
-
-    if (numOfExtraOpenDmas > oldVal)
-        p_Fm->p_FmStateStruct->extraOpenDmasPoolSize =
-            (uint8_t)MAX(p_Fm->p_FmStateStruct->extraOpenDmasPoolSize, numOfExtraOpenDmas);
-
-    if (!initialConfig)
-        /* read into oldVal the current num of tasks */
-        oldVal = (uint8_t)(((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
-
-    /* check that there are enough uncommitted open DMA's */
-    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >= oldVal);
-#ifdef FM_HAS_TOTAL_DMAS
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) &&
-        (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas >
-            p_Fm->p_FmStateStruct->maxNumOfOpenDmas))
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                         ("Requested numOfOpenDmas for fm%d exceeds total numOfOpenDmas.",
-                         p_Fm->p_FmStateStruct->fmId));
-#else
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev >= 6) &&
-#ifdef FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981
-         !((p_Fm->p_FmStateStruct->revInfo.majorRev == 6) &&
-           (p_Fm->p_FmStateStruct->revInfo.minorRev == 0)) &&
-#endif /* FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981 */
-        (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas > DMA_THRESH_MAX_COMMQ + 1))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                     ("Requested numOfOpenDmas for fm%d exceeds DMA Command queue (%d)",
-                      p_Fm->p_FmStateStruct->fmId, DMA_THRESH_MAX_COMMQ+1));
-#endif /* FM_HAS_TOTAL_DMAS */
-    else
-    {
-        /* update acummulated */
-        p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -= oldVal;
-        p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas += numOfOpenDmas;
-
-        /* calculate reg */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
-        tmpReg |= (uint32_t)(((numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
-                    (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
-
-#ifdef FM_HAS_TOTAL_DMAS
-        if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
-        {
-            /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
-            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
-            tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
-        }
-#endif /* FM_HAS_TOTAL_DMAS */
-    }
-
-
-    return E_OK;
-}
-
-#else /* FM_NO_GUARANTEED_RESET_VALUES */
-t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
-                            uint8_t hardwarePortId,
-                            uint8_t *p_NumOfOpenDmas,
-                            uint8_t *p_NumOfExtraOpenDmas,
-                            bool    initialConfig)
-
-{
-    t_Fm                    *p_Fm = (t_Fm *)h_Fm;
-    uint32_t                tmpReg = 0;
-    t_Error                 err;
-    uint8_t                 currentVal, currentExtraVal, numOfOpenDmas = *p_NumOfOpenDmas, numOfExtraOpenDmas = *p_NumOfExtraOpenDmas;
-
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-
-    if ((p_Fm->guestId != NCSW_MASTER_ID) &&
-        !p_Fm->baseAddr &&
-        p_Fm->h_IpcSessions[0])
-    {
-        t_FmIpcPortRsrcParams   rsrcParams;
-        t_FmIpcMsg              msg;
-        t_FmIpcReply            reply;
-        uint32_t                replyLength;
-
-        rsrcParams.hardwarePortId = hardwarePortId;
-        rsrcParams.val = numOfOpenDmas;
-        rsrcParams.extra = numOfExtraOpenDmas;
-        rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
-
-        memset(&msg, 0, sizeof(msg));
-        memset(&reply, 0, sizeof(reply));
-        msg.msgId = FM_SET_NUM_OF_OPEN_DMAS;
-        memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
-        replyLength = sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(rsrcParams),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        if (replyLength != sizeof(uint32_t))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        return (t_Error)(reply.error);
-    }
-#ifdef FM_HAS_TOTAL_DMAS
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without IPC!"));
-#else
-    else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
-             p_Fm->baseAddr &&
-             (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
-    {
-        /*DBG(WARNING, ("No IPC - can't validate FM total-num-of-dmas."));*/
-
-        if (numOfOpenDmas)
-        {
-            /* whether it is the first time with explicit value, or runtime "set" - write register */
-            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
-            tmpReg |= (uint32_t)(((numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
-                        (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
-        }
-        else /* first config without explicit value: Do Nothing - reset value shouldn't be
-                changed, read register for port save */
-        {
-            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
-            /* read into oldVal the current extra tasks */
-            *p_NumOfOpenDmas = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_DMAS_MASK) >> BMI_EXTRA_NUM_OF_DMAS_SHIFT);
-            *p_NumOfExtraOpenDmas = (uint8_t)(((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
-        }
+        /* !initialConfig - runtime change of existing value.
+         * - read the current number of open Dma's */
+        currentExtraVal = fman_get_num_extra_dmas(bmi_rg, hardwarePortId);
+        currentVal = fman_get_num_of_dmas(bmi_rg, hardwarePortId);
     }
-    else if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without neither IPC nor mapped register!"));
-#endif /* FM_HAS_TOTAL_DMAS */
 
+#ifdef FM_NO_GUARANTEED_RESET_VALUES
     /* it's illegal to be in a state where this is not the first set and no value is specified */
     ASSERT_COND(initialConfig || numOfOpenDmas);
-
-    if (!initialConfig || !numOfOpenDmas)
-    {
-        /* !initialConfig - runtime change of existing value.
-         * !numOfTasks - first configuration according to values in regs.
-         * In both cases: read the current number of open Dma's */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
-        /* read into oldVal the current extra tasks */
-        currentExtraVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_DMAS_MASK) >> BMI_EXTRA_NUM_OF_DMAS_SHIFT);
-        currentVal = (uint8_t)(((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
-    }
-    else /* first time and numOfTasks explicitly specified */
-        currentVal = currentExtraVal = 0;
-
     if (!numOfOpenDmas)
     {
+        /* !numOfOpenDmas - first configuration according to values in regs.
+         * - read the current number of open Dma's */
+        currentExtraVal = fman_get_num_extra_dmas(bmi_rg, hardwarePortId);
+        currentVal = fman_get_num_of_dmas(bmi_rg, hardwarePortId);
         /* This is the first configuration and user did not specify value (!numOfOpenDmas),
          * reset values will be used and we just save these values for resource management */
         p_Fm->p_FmStateStruct->extraOpenDmasPoolSize =
@@ -3454,19 +2907,14 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
         p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas += currentVal;
         *p_NumOfOpenDmas = currentVal;
         *p_NumOfExtraOpenDmas = currentExtraVal;
+        return E_OK;
     }
-    else
-    {
-        /* user requires a specific value.
-         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
-         * otherwise they hold the value written in the register.
-         */
+#endif /* FM_NO_GUARANTEED_RESET_VALUES */
+
         if (numOfExtraOpenDmas > currentExtraVal)
              p_Fm->p_FmStateStruct->extraOpenDmasPoolSize =
                  (uint8_t)MAX(p_Fm->p_FmStateStruct->extraOpenDmasPoolSize, numOfExtraOpenDmas);
 
-
-        /* read into oldVal the current num of tasks */
 #ifdef FM_HAS_TOTAL_DMAS
         if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) &&
             (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - currentVal + numOfOpenDmas >
@@ -3476,6 +2924,10 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
                              p_Fm->p_FmStateStruct->fmId));
 #else
         if ((p_Fm->p_FmStateStruct->revInfo.majorRev >= 6) &&
+#ifdef FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981
+            !((p_Fm->p_FmStateStruct->revInfo.majorRev == 6) &&
+              (p_Fm->p_FmStateStruct->revInfo.minorRev == 0)) &&
+#endif /* FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981 */
             (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - currentVal + numOfOpenDmas > DMA_THRESH_MAX_COMMQ + 1))
             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
                          ("Requested numOfOpenDmas for fm%d exceeds DMA Command queue (%d)",
@@ -3488,30 +2940,19 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
             p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -= currentVal;
             p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas += numOfOpenDmas;
 
-            /* calculate reg */
-            tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
-            tmpReg |= (uint32_t)(((numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
-                        (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
 #ifdef FM_HAS_TOTAL_DMAS
             if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
-            {
-                /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
-                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
-                tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
-                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
-            }
+            totalNumDmas = (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize);
 #endif /* FM_HAS_TOTAL_DMAS */
-
+        fman_set_num_of_open_dmas(bmi_rg,
+                               hardwarePortId,
+                               numOfOpenDmas,
+                               numOfExtraOpenDmas,
+                               totalNumDmas);
         }
-        *p_NumOfOpenDmas = numOfOpenDmas;
-        *p_NumOfExtraOpenDmas = numOfExtraOpenDmas;
-    }
-
 
     return E_OK;
 }
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
 
 #if (DPAA_VERSION >= 11)
 t_Error FmVSPCheckRelativeProfile(t_Handle        h_Fm,
@@ -3574,108 +3015,38 @@ t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
 
 static t_Error InitFmDma(t_Fm *p_Fm)
 {
-    t_FmDriverParam         *p_FmDriverParam = NULL;
-    uint32_t                tmpReg;
-
-    ASSERT_COND(p_Fm);
-    ASSERT_COND(p_Fm->p_FmDriverParam);
-
-    p_FmDriverParam = p_Fm->p_FmDriverParam;
+    t_Error err;
 
-    /* clear status reg events */
-#if (DPAA_VERSION >= 11)
-        tmpReg = DMA_STATUS_FM_SPDAT_ECC;
-#else
-        tmpReg = DMA_STATUS_FM_ECC;
-#endif /* DPAA_VERSION >= 11 */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr) | tmpReg);
-
-    /* configure mode register */
-    tmpReg = 0;
-    tmpReg |= p_FmDriverParam->dmaCacheOverride << DMA_MODE_CACHE_OR_SHIFT;
-    if (p_FmDriverParam->dmaAidOverride)
-        tmpReg |= DMA_MODE_AID_OR;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_BUS_ERROR)
-        tmpReg |= DMA_MODE_BER;
-    if (p_FmDriverParam->dmaEnEmergency)
-    {
-        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyBusSelect;
-        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyLevel << DMA_MODE_EMERGENCY_LEVEL_SHIFT;
-        if (p_FmDriverParam->dmaEnEmergencySmoother)
-            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr, p_FmDriverParam->dmaEmergencySwitchCounter);
-    }
-    tmpReg |= ((p_FmDriverParam->dmaCamNumOfEntries/DMA_CAM_UNITS) - 1) << DMA_MODE_CEN_SHIFT;
-    tmpReg |= p_FmDriverParam->dmaDbgCntMode << DMA_MODE_DBG_SHIFT;
-    tmpReg |= DMA_MODE_SECURE_PROT;
-    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
-
-#if (DPAA_VERSION >= 11)
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SINGLE_PORT_ECC)
-        tmpReg |= DMA_MODE_ECC;
-#else
-    if ((p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_FM_WRITE_ECC))
-        tmpReg |= DMA_MODE_ECC;
-    if (p_FmDriverParam->dmaStopOnBusError)
-        tmpReg |= DMA_MODE_SBER;
-    tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
-#ifdef FM_PEDANTIC_DMA
-    tmpReg |= DMA_MODE_EMERGENCY_READ;
-#endif /* FM_PEDANTIC_DMA */
-#endif /* DPAA_VERSION >= 11 */
-
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
-
-    /* configure thresholds register */
-    tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtr);
-    tmpReg &= ~DMA_THRESH_COMMQ_MASK;
-    tmpReg |= ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT);
-#if (DPAA_VERSION < 11)
-    tmpReg &= ~(DMA_THRESH_READ_INT_BUF_MASK | DMA_THRESH_WRITE_INT_BUF_MASK);
-    tmpReg |= ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
-               ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
-#endif /* (DPAA_VERSION < 11) */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmtr, tmpReg);
-
-    /* configure hysteresis register */
-    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.clearEmergency << DMA_THRESH_COMMQ_SHIFT);
-#if (DPAA_VERSION < 11)
-    tmpReg |= ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
-              ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.clearEmergency);
-#endif /* (DPAA_VERSION < 11) */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmhy, tmpReg);
-
-    /* configure emergency threshold */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsetr, p_FmDriverParam->dmaSosEmergency);
-
-    /* configure Watchdog */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmwcr, USEC_TO_CLK(p_FmDriverParam->dmaWatchdog, p_Fm->p_FmStateStruct->fmClkFreq));
+    err = (t_Error)fman_dma_init(p_Fm->p_FmDmaRegs, p_Fm->p_FmDriverParam);
+    if (err != E_OK)
+        return err;
 
     /* Allocate MURAM for CAM */
     p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
-                                                      (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY),
+                                                      (uint32_t)(p_Fm->p_FmDriverParam->dma_cam_num_of_entries*DMA_CAM_SIZEOF_ENTRY),
                                                       DMA_CAM_ALIGN));
     if (!p_Fm->camBaseAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
 
     WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
                 0,
-                (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
+                (uint32_t)(p_Fm->p_FmDriverParam->dma_cam_num_of_entries*DMA_CAM_SIZEOF_ENTRY));
 
     if (p_Fm->p_FmStateStruct->revInfo.majorRev == 2)
     {
         FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
 
         p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
-                                                          (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128),
+                                                          (uint32_t)(p_Fm->p_FmDriverParam->dma_cam_num_of_entries*72 + 128),
                                                           64));
         if (!p_Fm->camBaseAddr)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
 
         WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
                    0,
-                   (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128));
+               (uint32_t)(p_Fm->p_FmDriverParam->dma_cam_num_of_entries*72 + 128));
 
-        switch (p_FmDriverParam->dmaCamNumOfEntries)
+        switch(p_Fm->p_FmDriverParam->dma_cam_num_of_entries)
         {
             case (8):
                 WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xff000000);
@@ -3690,190 +3061,29 @@ static t_Error InitFmDma(t_Fm *p_Fm)
                 WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffffffff);
                 break;
             default:
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("wrong dmaCamNumOfEntries"));
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("wrong dma_cam_num_of_entries"));
         }
     }
 
-    /* VirtToPhys */
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
-                 (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->camBaseAddr)) - p_Fm->fmMuramPhysBaseAddr));
+    p_Fm->p_FmDriverParam->cam_base_addr =
+                 (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->camBaseAddr)) - p_Fm->fmMuramPhysBaseAddr);
 
     return E_OK;
 }
 
 static t_Error InitFmFpm(t_Fm *p_Fm)
 {
-    t_FmDriverParam         *p_FmDriverParam = NULL;
-    uint32_t                tmpReg;
-    int                     i;
-
-    ASSERT_COND(p_Fm);
-    ASSERT_COND(p_Fm->p_FmDriverParam);
-
-    p_FmDriverParam = p_Fm->p_FmDriverParam;
-
-    tmpReg = (uint32_t)(p_FmDriverParam->thresholds.dispLimit << FPM_DISP_LIMIT_SHIFT);
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_mxd, tmpReg);
-
-    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.prsDispTh  << FPM_THR1_PRS_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.kgDispTh  << FPM_THR1_KG_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.plcrDispTh  << FPM_THR1_PLCR_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.bmiDispTh  << FPM_THR1_BMI_SHIFT));
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis1, tmpReg);
-
-    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.qmiEnqDispTh  << FPM_THR2_QMI_ENQ_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.qmiDeqDispTh  << FPM_THR2_QMI_DEQ_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.fmCtl1DispTh  << FPM_THR2_FM_CTL1_SHIFT) |
-                ((uint32_t)p_FmDriverParam->thresholds.fmCtl2DispTh  << FPM_THR2_FM_CTL2_SHIFT));
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis2, tmpReg);
-
-    /* define exceptions and error behavior */
-    tmpReg = 0;
-    /* Clear events */
-    tmpReg |= (FPM_EV_MASK_STALL | FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_SINGLE_ECC);
-    /* enable interrupts */
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_STALL_ON_TASKS)
-        tmpReg |= FPM_EV_MASK_STALL_EN;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_SINGLE_ECC)
-        tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_DOUBLE_ECC)
-        tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
-    tmpReg |= (p_Fm->p_FmDriverParam->catastrophicErr  << FPM_EV_MASK_CAT_ERR_SHIFT);
-    tmpReg |= (p_Fm->p_FmDriverParam->dmaErr << FPM_EV_MASK_DMA_ERR_SHIFT);
-    if (!p_Fm->p_FmDriverParam->haltOnExternalActivation)
-        tmpReg |= FPM_EV_MASK_EXTERNAL_HALT;
-    if (!p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError)
-        tmpReg |= FPM_EV_MASK_ECC_ERR_HALT;
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg);
-
-    /* clear all fmCtls event registers */
-    for (i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[i], 0xFFFFFFFF);
-
-    /* RAM ECC -  enable and clear events */
-    /* first we need to clear all parser memory, as it is uninitialized and
-       may cause ECC errors
-     */
-    tmpReg = 0;
-    /* event bits */
-    tmpReg = (FPM_RAM_CTL_MURAM_ECC | FPM_RAM_CTL_IRAM_ECC);
-    /* Rams enable is not effected by the RCR bit, but by a COP configuration */
-    if (p_Fm->p_FmDriverParam->externalEccRamsEnable)
-        tmpReg |= FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL;
-
-    /* enable test mode */
-    if (p_FmDriverParam->enMuramTestMode)
-        tmpReg |= FPM_RAM_CTL_MURAM_TEST_ECC;
-    if (p_FmDriverParam->enIramTestMode)
-        tmpReg |= FPM_RAM_CTL_IRAM_TEST_ECC;
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg);
-
-    tmpReg = 0;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_IRAM_ECC)
-    {
-        tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
-        FmEnableRamsEcc(p_Fm);
-    }
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_MURAM_ECC)
-    {
-        tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
-        FmEnableRamsEcc(p_Fm);
-    }
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rie, tmpReg);
-
-    return E_OK;
+    return (t_Error)fman_fpm_init(p_Fm->p_FmFpmRegs, p_Fm->p_FmDriverParam);
 }
 
 static t_Error InitFmBmi(t_Fm *p_Fm)
 {
-    uint32_t                tmpReg;
-
-    ASSERT_COND(p_Fm);
-    ASSERT_COND(p_Fm->p_FmDriverParam);
-
-    tmpReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->fifoBaseAddr)) - p_Fm->fmMuramPhysBaseAddr);
-    tmpReg = tmpReg / BMI_FIFO_ALIGN;
-
-    tmpReg |= ((p_Fm->p_FmStateStruct->totalFifoSize/BMI_FIFO_UNITS - 1) << BMI_CFG1_FIFO_SIZE_SHIFT);
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, tmpReg);
-
-    tmpReg =  ((uint32_t)(p_Fm->p_FmStateStruct->totalNumOfTasks - 1) << BMI_CFG2_TASKS_SHIFT);
-#ifdef FM_HAS_TOTAL_DMAS
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
-        tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->maxNumOfOpenDmas - 1) << BMI_CFG2_DMAS_SHIFT;
-#endif /* FM_HAS_TOTAL_DMAS */
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
-
-    /* define unmaskable exceptions, enable and clear events */
-    tmpReg = 0;
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC |
-                                                BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC |
-                                                BMI_ERR_INTR_EN_STATISTICS_RAM_ECC |
-                                                BMI_ERR_INTR_EN_DISPATCH_RAM_ECC));
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC)
-        tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STORAGE_PROFILE_ECC)
-        tmpReg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC)
-        tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
-        tmpReg |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
-
-    return E_OK;
+    return (t_Error)fman_bmi_init(p_Fm->p_FmBmiRegs, p_Fm->p_FmDriverParam);
 }
 
 static t_Error InitFmQmi(t_Fm *p_Fm)
 {
-    uint32_t                tmpReg;
-
-    ASSERT_COND(p_Fm);
-    ASSERT_COND(p_Fm->p_FmDriverParam);
-
-     /* Clear error interrupt events */
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, (QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF));
-    tmpReg = 0;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
-        tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC)
-        tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
-    /* enable events */
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
-
-    if (p_Fm->tnumAgingPeriod)
-    {
-        uint16_t                periodInFmClocks;
-        uint8_t                 remainder;
-
-        /* tnumAgingPeriod is in units of microseconds, p_FmClockFreq is in Mhz */
-        periodInFmClocks = (uint16_t)(p_Fm->tnumAgingPeriod * p_Fm->p_FmStateStruct->fmClkFreq);
-        /* periodInFmClocks must be a 64 multiply */
-        remainder = (uint8_t)(periodInFmClocks % 64);
-        if (remainder > 64)
-            tmpReg = (uint32_t)((periodInFmClocks/64) + 1);
-        else
-        {
-            tmpReg = (uint32_t)(periodInFmClocks/64);
-            if (!tmpReg)
-                tmpReg = 1;
-        }
-        tmpReg <<= QMI_TAPC_TAP;
-        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_tapc, tmpReg);
-
-    }
-
-    tmpReg = 0;
-    /* Clear interrupt events */
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
-    {
-        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
-        if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
-            tmpReg |= QMI_INTR_EN_SINGLE_ECC;
-        /* enable events */
-        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
-    }
-
-    return E_OK;
+    return (t_Error)fman_qmi_init(p_Fm->p_FmQmiRegs, p_Fm->p_FmDriverParam);
 }
 
 static t_Error InitGuestMode(t_Fm *p_Fm)
@@ -3954,17 +3164,15 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
     }
     else
     {
-        uint32_t    tmpReg;
-
         DBG(WARNING, ("FM Guest mode - without IPC"));
         if (!p_Fm->p_FmStateStruct->fmClkFreq)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No fmClkFreq configured for guest without IPC"));
         if (p_Fm->baseAddr)
         {
-            /* read revision register 1 */
-            tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
-            p_Fm->p_FmStateStruct->revInfo.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
-            p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+            fman_get_revision(p_Fm->p_FmFpmRegs,
+                              &p_Fm->p_FmStateStruct->revInfo.majorRev,
+                              &p_Fm->p_FmStateStruct->revInfo.minorRev);
+
         }
     }
 
@@ -4032,7 +3240,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     t_Fm                *p_Fm;
     uint8_t             i;
     uintptr_t           baseAddr;
-    uint32_t            tmpReg;
 
     SANITY_CHECK_RETURN_VALUE(p_FmParam, E_NULL_POINTER, NULL);
     SANITY_CHECK_RETURN_VALUE(((p_FmParam->firmware.p_Code && p_FmParam->firmware.size) ||
@@ -4067,7 +3274,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->p_FmStateStruct->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
 
     /* Allocate the FM driver's parameters structure */
-    p_Fm->p_FmDriverParam = (t_FmDriverParam *)XX_Malloc(sizeof(t_FmDriverParam));
+    p_Fm->p_FmDriverParam = (struct fman_cfg *)XX_Malloc(sizeof(struct fman_cfg));
     if (!p_Fm->p_FmDriverParam)
     {
         XX_Free(p_Fm->p_FmStateStruct);
@@ -4075,7 +3282,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver parameters"));
         return NULL;
     }
-    memset(p_Fm->p_FmDriverParam, 0, sizeof(t_FmDriverParam));
+    memset(p_Fm->p_FmDriverParam, 0, sizeof(struct fman_cfg));
 
 #if (DPAA_VERSION >= 11)
     p_Fm->p_FmSp = (t_FmSp *)XX_Malloc(sizeof(t_FmSp));
@@ -4100,10 +3307,11 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmStateStruct->fmClkFreq            = p_FmParam->fmClkFreq;
     p_Fm->f_Exception                           = p_FmParam->f_Exception;
     p_Fm->f_BusError                            = p_FmParam->f_BusError;
-    p_Fm->p_FmFpmRegs                           = (t_FmFpmRegs *)UINT_TO_PTR(baseAddr + FM_MM_FPM);
-    p_Fm->p_FmBmiRegs                           = (t_FmBmiRegs *)UINT_TO_PTR(baseAddr + FM_MM_BMI);
-    p_Fm->p_FmQmiRegs                           = (t_FmQmiRegs *)UINT_TO_PTR(baseAddr + FM_MM_QMI);
-    p_Fm->p_FmDmaRegs                           = (t_FmDmaRegs *)UINT_TO_PTR(baseAddr + FM_MM_DMA);
+    p_Fm->p_FmFpmRegs = (struct fman_fpm_regs *)UINT_TO_PTR(baseAddr + FM_MM_FPM);
+    p_Fm->p_FmBmiRegs = (struct fman_bmi_regs *)UINT_TO_PTR(baseAddr + FM_MM_BMI);
+    p_Fm->p_FmQmiRegs = (struct fman_qmi_regs *)UINT_TO_PTR(baseAddr + FM_MM_QMI);
+    p_Fm->p_FmDmaRegs = (struct fman_dma_regs *)UINT_TO_PTR(baseAddr + FM_MM_DMA);
+    p_Fm->p_FmRegs       = (struct fman_regs *)UINT_TO_PTR(baseAddr + FM_MM_BMI);
     p_Fm->baseAddr                              = baseAddr;
     p_Fm->p_FmStateStruct->irq                  = p_FmParam->irq;
     p_Fm->p_FmStateStruct->errIrq               = p_FmParam->errIrq;
@@ -4126,28 +3334,27 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->vspBaseAddr = p_FmParam->vspBaseAddr;
 #endif /* (DPAA_VERSION >= 11) */
 
-
+    fman_defconfig(p_Fm->p_FmDriverParam,
+                  !!(p_Fm->guestId == NCSW_MASTER_ID));
+/* overide macros dependent parameters */
+#ifdef FM_PEDANTIC_DMA
+    p_Fm->p_FmDriverParam->pedantic_dma = TRUE;
+    p_Fm->p_FmDriverParam->dma_aid_override = TRUE;
+#endif /* FM_PEDANTIC_DMA */
+#ifndef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+    p_Fm->p_FmDriverParam->qmi_deq_option_support = TRUE;
+#endif /* !FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     p_Fm->p_FmStateStruct->ramsEccEnable        = FALSE;
     p_Fm->p_FmStateStruct->extraFifoPoolSize    = 0;
     p_Fm->p_FmStateStruct->exceptions           = DEFAULT_exceptions;
-    /*p_Fm->p_FmDriverParam->numOfPartitions                    = p_FmParam->numOfPartitions;    */
-    p_Fm->p_FmDriverParam->resetOnInit                          = DEFAULT_resetOnInit;
-
-    p_Fm->p_FmDriverParam->catastrophicErr                      = DEFAULT_catastrophicErr;
-    p_Fm->p_FmDriverParam->dmaErr                               = DEFAULT_dmaErr;
-    p_Fm->p_FmDriverParam->haltOnExternalActivation             = DEFAULT_haltOnExternalActivation;
-    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError          = DEFAULT_haltOnUnrecoverableEccError;
-    p_Fm->p_FmDriverParam->enIramTestMode                       = FALSE;
-    p_Fm->p_FmDriverParam->enMuramTestMode                      = FALSE;
-    p_Fm->p_FmDriverParam->externalEccRamsEnable                = DEFAULT_externalEccRamsEnable;
-
-    p_Fm->p_FmDriverParam->fwVerify                             = DEFAULT_VerifyUcode;
-    p_Fm->p_FmDriverParam->firmware.size                        = p_FmParam->firmware.size;
-    if (p_Fm->p_FmDriverParam->firmware.size)
-    {
-        p_Fm->p_FmDriverParam->firmware.p_Code = (uint32_t *)XX_Malloc(p_Fm->p_FmDriverParam->firmware.size);
-        if (!p_Fm->p_FmDriverParam->firmware.p_Code)
+    p_Fm->resetOnInit                          = DEFAULT_resetOnInit;
+    p_Fm->fwVerify                             = DEFAULT_VerifyUcode;
+    p_Fm->firmware.size                        = p_FmParam->firmware.size;
+    if (p_Fm->firmware.size)
+    {
+        p_Fm->firmware.p_Code = (uint32_t *)XX_Malloc(p_Fm->firmware.size);
+        if (!p_Fm->firmware.p_Code)
         {
             XX_FreeSpinlock(p_Fm->h_Spinlock);
             XX_Free(p_Fm->p_FmStateStruct);
@@ -4156,25 +3363,26 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM firmware code"));
             return NULL;
         }
-        memcpy(p_Fm->p_FmDriverParam->firmware.p_Code, p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
+        memcpy(p_Fm->firmware.p_Code, p_FmParam->firmware.p_Code ,p_Fm->firmware.size);
     }
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
         return p_Fm;
 
-    /* read revision register 1 */
-    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
-    p_Fm->p_FmStateStruct->revInfo.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
-    p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+    /* read revision */
     /* Chip dependent, will be configured in Init */
+    fman_get_revision(p_Fm->p_FmFpmRegs,
+                      &p_Fm->p_FmStateStruct->revInfo.majorRev,
+                      &p_Fm->p_FmStateStruct->revInfo.minorRev);
 
-    p_Fm->tnumAgingPeriod                                       = DEFAULT_tnumAgingPeriod;
-    p_Fm->p_FmDriverParam->dmaAidOverride                       = DEFAULT_aidOverride;
-    p_Fm->p_FmDriverParam->dmaAidMode                           = DEFAULT_aidMode;
 #ifdef FM_AID_MODE_NO_TNUM_SW005
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        p_Fm->p_FmDriverParam->dmaAidMode                       = e_FM_DMA_AID_OUT_PORT_ID;
+        p_Fm->p_FmDriverParam->dma_aid_mode = e_FM_DMA_AID_OUT_PORT_ID;
 #endif /* FM_AID_MODE_NO_TNUM_SW005 */
+#ifndef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+   if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+        p_Fm->p_FmDriverParam->qmi_def_tnums_thresh = QMI_DEF_TNUMS_THRESH;
+#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
     if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
@@ -4182,92 +3390,40 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->p_FmStateStruct->totalNumOfTasks      = DEFAULT_totalNumOfTasks;
 #ifdef FM_HAS_TOTAL_DMAS
         p_Fm->p_FmStateStruct->maxNumOfOpenDmas     = BMI_MAX_NUM_OF_DMAS;
-#endif
-        p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency        = DEFAULT_dmaCommQLow;
-        p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency       = DEFAULT_dmaCommQHigh;
+#endif /* FM_HAS_TOTAL_DMAS */
 #if (DPAA_VERSION < 11)
-        p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency      = DEFAULT_dmaReadIntBufLow;
-        p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency     = DEFAULT_dmaReadIntBufHigh;
-        p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency     = DEFAULT_dmaWriteIntBufLow;
-        p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency    = DEFAULT_dmaWriteIntBufHigh;
-        p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats                      = DEFAULT_axiDbgNumOfBeats;
+        p_Fm->p_FmDriverParam->dma_comm_qtsh_clr_emer        = DEFAULT_dmaCommQLow;
+        p_Fm->p_FmDriverParam->dma_comm_qtsh_asrt_emer       = DEFAULT_dmaCommQHigh;
+        p_Fm->p_FmDriverParam->dma_cam_num_of_entries        = DEFAULT_dmaCamNumOfEntries;
+        p_Fm->p_FmDriverParam->dma_read_buf_tsh_clr_emer      = DEFAULT_dmaReadIntBufLow;
+        p_Fm->p_FmDriverParam->dma_read_buf_tsh_asrt_emer     = DEFAULT_dmaReadIntBufHigh;
+        p_Fm->p_FmDriverParam->dma_write_buf_tsh_clr_emer     = DEFAULT_dmaWriteIntBufLow;
+        p_Fm->p_FmDriverParam->dma_write_buf_tsh_asrt_emer    = DEFAULT_dmaWriteIntBufHigh;
+        p_Fm->p_FmDriverParam->dma_axi_dbg_num_of_beats       = DEFAULT_axiDbgNumOfBeats;
 #endif /* (DPAA_VERSION < 11) */
-        p_Fm->p_FmDriverParam->dmaCacheOverride                     = DEFAULT_cacheOverride;
-        p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = DEFAULT_dmaCamNumOfEntries;
-        p_Fm->p_FmDriverParam->dmaDbgCntMode                        = DEFAULT_dmaDbgCntMode;
-        p_Fm->p_FmDriverParam->dmaEnEmergency                       = DEFAULT_dmaEnEmergency;
-        p_Fm->p_FmDriverParam->dmaSosEmergency                      = DEFAULT_dmaSosEmergency;
-        p_Fm->p_FmDriverParam->dmaWatchdog                          = DEFAULT_dmaWatchdog;
-        p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = DEFAULT_dmaEnEmergencySmoother;
-        p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter            = DEFAULT_dmaEmergencySwitchCounter;
-        p_Fm->p_FmDriverParam->thresholds.dispLimit                 = DEFAULT_dispLimit;
-        p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = DEFAULT_prsDispTh;
-        p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = DEFAULT_plcrDispTh;
-        p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = DEFAULT_kgDispTh;
-        p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = DEFAULT_bmiDispTh;
-        p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = DEFAULT_qmiEnqDispTh;
-        p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = DEFAULT_qmiDeqDispTh;
-        p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = DEFAULT_fmCtl1DispTh;
-        p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = DEFAULT_fmCtl2DispTh;
     }
     else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
     {
-        /* read the values from the registers as they are initialized by the HW with
-         * the required values.
-         */
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1);
-        p_Fm->p_FmStateStruct->totalFifoSize =
-            (((tmpReg & BMI_TOTAL_FIFO_SIZE_MASK) >> BMI_CFG1_FIFO_SIZE_SHIFT) + 1) * BMI_FIFO_UNITS;
+        struct fman_rg          fman_rg;
+
+        fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
+        fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
+        fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
+        fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
 
 #ifdef FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
-        tmpReg = 0x007B0000;
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, 0x007B0000);
 #endif /* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 */
+        fman_regconfig(&fman_rg, p_Fm->p_FmDriverParam);
 
-        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2);
-        p_Fm->p_FmStateStruct->totalNumOfTasks =
-            (uint8_t)(((tmpReg & BMI_TOTAL_NUM_OF_TASKS_MASK) >> BMI_CFG2_TASKS_SHIFT) + 1);
-
-        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtr);
-        p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency =
-            (uint8_t)(tmpReg >> DMA_THRESH_COMMQ_SHIFT);
-
-        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmhy);
-        p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency =
-            (uint8_t)(tmpReg >> DMA_THRESH_COMMQ_SHIFT);
-
-        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-        p_Fm->p_FmDriverParam->dmaCacheOverride                     = (e_FmDmaCacheOverride)((tmpReg & DMA_MODE_CACHE_OR_MASK) >> DMA_MODE_CACHE_OR_SHIFT);
-        p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = (uint8_t)((((tmpReg & DMA_MODE_CEN_MASK) >> DMA_MODE_CEN_SHIFT) +1)*DMA_CAM_UNITS);
-        p_Fm->p_FmDriverParam->dmaDbgCntMode                        = (e_FmDmaDbgCntMode)((tmpReg & DMA_MODE_DBG_MASK) >> DMA_MODE_DBG_SHIFT);
-        p_Fm->p_FmDriverParam->dmaEnEmergency                       = (bool)((tmpReg & DMA_MODE_EB)? TRUE : FALSE);
-
-        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_mxd);
-        p_Fm->p_FmDriverParam->thresholds.dispLimit                 = (uint8_t)((tmpReg & FPM_DISP_LIMIT_MASK) << FPM_DISP_LIMIT_SHIFT);
-
-        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis1);
-        p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = (uint8_t)((tmpReg & FPM_THR1_PRS_MASK ) >> FPM_THR1_PRS_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = (uint8_t)((tmpReg & FPM_THR1_KG_MASK ) >> FPM_THR1_KG_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = (uint8_t)((tmpReg & FPM_THR1_PLCR_MASK ) >> FPM_THR1_PLCR_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = (uint8_t)((tmpReg & FPM_THR1_BMI_MASK ) >> FPM_THR1_BMI_SHIFT);
-
-        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis2);
-        p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = (uint8_t)((tmpReg & FPM_THR2_QMI_ENQ_MASK ) >> FPM_THR2_QMI_ENQ_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = (uint8_t)((tmpReg & FPM_THR2_QMI_DEQ_MASK ) >> FPM_THR2_QMI_DEQ_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = (uint8_t)((tmpReg & FPM_THR2_FM_CTL1_MASK ) >> FPM_THR2_FM_CTL1_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = (uint8_t)((tmpReg & FPM_THR2_FM_CTL2_MASK ) >> FPM_THR2_FM_CTL2_SHIFT);
-
-        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsetr);
-        p_Fm->p_FmDriverParam->dmaSosEmergency                        = tmpReg;
-
-        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmwcr);
-        p_Fm->p_FmDriverParam->dmaWatchdog                          = tmpReg/p_Fm->p_FmStateStruct->fmClkFreq;
-
-        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr);
-        p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = (bool)((tmpReg & DMA_EMSR_EMSTR_MASK)? TRUE : FALSE);
-        p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter            = (tmpReg & DMA_EMSR_EMSTR_MASK);
+        p_Fm->p_FmStateStruct->totalFifoSize = p_Fm->p_FmDriverParam->total_fifo_size;
+        p_Fm->p_FmStateStruct->totalNumOfTasks = p_Fm->p_FmDriverParam->total_num_of_tasks;
     }
+#ifdef FM_NO_TNUM_AGING
+    p_Fm->p_FmDriverParam->tnum_aging_period = 0;
+#endif
+    p_Fm->tnumAgingPeriod = p_Fm->p_FmDriverParam->tnum_aging_period;
 
    return p_Fm;
 }
@@ -4284,15 +3440,22 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
 t_Error FM_Init(t_Handle h_Fm)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    t_FmDriverParam         *p_FmDriverParam = NULL;
+    struct fman_cfg         *p_FmDriverParam = NULL;
     t_Error                 err = E_OK;
-    uint32_t                cfgReg = 0;
     int                     i;
+    t_FmRevisionInfo        revInfo;
+    struct fman_rg          fman_rg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
+    fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
+    fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
+    fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
+    fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
+
     p_Fm->p_FmStateStruct->count1MicroBit = FM_TIMESTAMP_1_USEC_BIT;
+    p_Fm->p_FmDriverParam->num_of_fman_ctrl_evnt_regs = FM_NUM_OF_FMAN_CTRL_EVENT_REGS;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
         return InitGuestMode(p_Fm);
@@ -4310,20 +3473,22 @@ t_Error FM_Init(t_Handle h_Fm)
 
     p_FmDriverParam = p_Fm->p_FmDriverParam;
 
+    FM_GetRevision(p_Fm, &revInfo);
+
     /* clear revision-dependent non existing exception */
 #ifdef FM_NO_DISPATCH_RAM_ECC
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) &&
-        (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
+    if ((revInfo.majorRev != 4) &&
+        (revInfo.majorRev < 6))
         p_Fm->p_FmStateStruct->exceptions &= ~FM_EX_BMI_DISPATCH_RAM_ECC;
 #endif /* FM_NO_DISPATCH_RAM_ECC */
 
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
+    if (revInfo.majorRev == 4)
         p_Fm->p_FmStateStruct->exceptions &= ~(FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC);
 #endif /* FM_QMI_NO_ECC_EXCEPTIONS */
 
 #ifdef FM_QMI_NO_SINGLE_ECC_EXCEPTION
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+    if (revInfo.majorRev >= 6)
        p_Fm->p_FmStateStruct->exceptions &= ~FM_EX_QMI_SINGLE_ECC;
 #endif /* FM_QMI_NO_SINGLE_ECC_EXCEPTION */
 
@@ -4333,10 +3498,10 @@ t_Error FM_Init(t_Handle h_Fm)
     IOMemSet32(UINT_TO_PTR(p_Fm->baseAddr + FM_MM_CGP), 0, FM_PORT_NUM_OF_CONGESTION_GRPS);
 
     /* add to the default exceptions the user's definitions */
-    p_Fm->p_FmStateStruct->exceptions |= p_FmDriverParam->userSetExceptions;
+    p_Fm->p_FmStateStruct->exceptions |= p_Fm->userSetExceptions;
 
 #ifdef FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
-    if (p_FmDriverParam->resetOnInit)
+    if (p_Fm->resetOnInit)
     {
         if ((err = FwNotResetErratumBugzilla6173WA(p_Fm)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -4346,7 +3511,7 @@ t_Error FM_Init(t_Handle h_Fm)
 #endif /* FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
 
     /* Reset the FM if required. */
-    if (p_FmDriverParam->resetOnInit)
+    if (p_Fm->resetOnInit)
     {
 	u32 svr = mfspr(SPRN_SVR);
 
@@ -4358,13 +3523,9 @@ t_Error FM_Init(t_Handle h_Fm)
 		XX_UDelay(100);
 	}
 
-        if (GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gs) & QMI_GS_HALT_NOT_BUSY)
+        if (fman_is_qmi_halt_not_busy_state(p_Fm->p_FmQmiRegs))
         {
-            uint32_t tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
-            /* clear tmpReg event bits in order not to clear standing events */
-            tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg | FPM_EV_MASK_RELEASE_FM);
-            CORE_MemoryBarrier();
+            fman_resume(p_Fm->p_FmFpmRegs);
             XX_UDelay(100);
         }
     }
@@ -4374,7 +3535,7 @@ t_Error FM_Init(t_Handle h_Fm)
     /*************************************/
     if (ClearIRam(p_Fm) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-    if (p_Fm->p_FmDriverParam->firmware.p_Code &&
+    if (p_Fm->firmware.p_Code &&
         (LoadFmanCtrlCode(p_Fm) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 #ifdef FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
@@ -4405,6 +3566,8 @@ t_Error FM_Init(t_Handle h_Fm)
     for (i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
         p_Fm->fmanCtrlIntr[i].f_Isr = UnimplementedFmanCtrlIsr;
 
+    p_FmDriverParam->exceptions = p_Fm->p_FmStateStruct->exceptions;
+
     /**********************/
     /* Init DMA Registers */
     /**********************/
@@ -4436,6 +3599,11 @@ t_Error FM_Init(t_Handle h_Fm)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for BMI FIFO failed"));
     }
 
+    p_FmDriverParam->fifo_base_addr = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->fifoBaseAddr)) - p_Fm->fmMuramPhysBaseAddr);
+    p_FmDriverParam->total_fifo_size = p_Fm->p_FmStateStruct->totalFifoSize;
+    p_FmDriverParam->total_num_of_tasks = p_Fm->p_FmStateStruct->totalNumOfTasks;
+    p_FmDriverParam->clk_freq = p_Fm->p_FmStateStruct->fmClkFreq;
+
     /**********************/
     /* Init BMI Registers */
     /**********************/
@@ -4483,26 +3651,16 @@ t_Error FM_Init(t_Handle h_Fm)
         XX_EnableIntr(p_Fm->p_FmStateStruct->errIrq);
     }
 
-    /**********************/
-    /* Enable all modules */
-    /**********************/
-    /* clear & enable global counters  - calculate reg and save for later,
-       because it's the same reg for QMI enable */
-    cfgReg = QMI_CFG_EN_COUNTERS;
-#ifndef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
-        cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) | (uint32_t)QMI_DEF_TNUMS_THRESH);
-#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_init, BMI_INIT_START);
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, cfgReg | QMI_CFG_ENQ_EN | QMI_CFG_DEQ_EN);
+    err = (t_Error)fman_enable(&fman_rg , p_FmDriverParam);
+    if (err != E_OK)
+        return err; /* FIXME */
 
     EnableTimeStamp(p_Fm);
 
-    if (p_Fm->p_FmDriverParam->firmware.p_Code)
+    if (p_Fm->firmware.p_Code)
     {
-        XX_Free(p_Fm->p_FmDriverParam->firmware.p_Code);
-        p_Fm->p_FmDriverParam->firmware.p_Code = NULL;
+        XX_Free(p_Fm->firmware.p_Code);
+        p_Fm->firmware.p_Code = NULL;
     }
 
     XX_Free(p_Fm->p_FmDriverParam);
@@ -4525,9 +3683,15 @@ t_Error FM_Init(t_Handle h_Fm)
 t_Error FM_Free(t_Handle h_Fm)
 {
     t_Fm    *p_Fm = (t_Fm*)h_Fm;
+    struct fman_rg          fman_rg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
+    fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
+    fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
+    fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
+    fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
+
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
 #if (DPAA_VERSION >= 11)
@@ -4551,9 +3715,7 @@ t_Error FM_Free(t_Handle h_Fm)
         return E_OK;
     }
 
-    /* disable BMI and QMI */
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_init, 0);
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, 0);
+    fman_free_resources(&fman_rg);
 
     if ((p_Fm->guestId == NCSW_MASTER_ID) && (p_Fm->fmModuleName[0] != 0))
         XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
@@ -4587,8 +3749,8 @@ t_Error FM_Free(t_Handle h_Fm)
 
     if (p_Fm->p_FmDriverParam)
     {
-        if (p_Fm->p_FmDriverParam->firmware.p_Code)
-            XX_Free(p_Fm->p_FmDriverParam->firmware.p_Code);
+        if (p_Fm->firmware.p_Code)
+            XX_Free(p_Fm->firmware.p_Code);
         XX_Free(p_Fm->p_FmDriverParam);
         p_Fm->p_FmDriverParam = NULL;
     }
@@ -4609,14 +3771,13 @@ t_Error FM_Free(t_Handle h_Fm)
 
 t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable)
 {
-
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->resetOnInit = enable;
+    p_Fm->resetOnInit = enable;
 
     return E_OK;
 }
@@ -4636,13 +3797,15 @@ t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize)
 
 t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride)
 {
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    t_Fm                            *p_Fm = (t_Fm*)h_Fm;
+    enum fman_dma_cache_override    fsl_cache_override;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaCacheOverride = cacheOverride;
+    FMAN_CACHE_OVERRIDE_TRANS(fsl_cache_override, cacheOverride)
+    p_Fm->p_FmDriverParam->dma_cache_override = fsl_cache_override;
 
     return E_OK;
 }
@@ -4655,20 +3818,22 @@ t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaAidOverride = aidOverride;
+    p_Fm->p_FmDriverParam->dma_aid_override = aidOverride;
 
     return E_OK;
 }
 
 t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode)
 {
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    enum fman_dma_aid_mode  fsl_aid_mode;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaAidMode = aidMode;
+    FMAN_AID_MODE_TRANS(fsl_aid_mode, aidMode);
+    p_Fm->p_FmDriverParam->dma_aid_mode = fsl_aid_mode;
 
     return E_OK;
 }
@@ -4683,8 +3848,8 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats)
 
 #if (DPAA_VERSION >= 11)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
-#endif
-    p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats = axiDbgNumOfBeats;
+#endif /* (DPAA_VERSION >= 11) */
+    p_Fm->p_FmDriverParam->dma_axi_dbg_num_of_beats = axiDbgNumOfBeats;
 
     return E_OK;
 }
@@ -4697,20 +3862,22 @@ t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaCamNumOfEntries = numOfEntries;
+    p_Fm->p_FmDriverParam->dma_cam_num_of_entries = numOfEntries;
 
     return E_OK;
 }
 
 t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
 {
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    t_Fm                        *p_Fm = (t_Fm*)h_Fm;
+    enum fman_dma_dbg_cnt_mode  fsl_dma_dbg_cnt;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaDbgCntMode = fmDmaDbgCntMode;
+    FMAN_DMA_DBG_CNT_TRANS(fsl_dma_dbg_cnt, fmDmaDbgCntMode);
+    p_Fm->p_FmDriverParam->dma_dbg_cnt_mode = fsl_dma_dbg_cnt;
 
     return E_OK;
 }
@@ -4723,21 +3890,24 @@ t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaStopOnBusError = stop;
+    p_Fm->p_FmDriverParam->dma_stop_on_bus_error = stop;
 
     return E_OK;
 }
 
 t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency)
 {
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    t_Fm                            *p_Fm = (t_Fm*)h_Fm;
+    enum fman_dma_emergency_level   fsl_dma_emer;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaEnEmergency = TRUE;
-    memcpy(&p_Fm->p_FmDriverParam->dmaEmergency, p_Emergency, sizeof(t_FmDmaEmergency));
+    FMAN_DMA_EMER_TRANS(fsl_dma_emer, p_Emergency->emergencyLevel);
+    p_Fm->p_FmDriverParam->dma_en_emergency = TRUE;
+    p_Fm->p_FmDriverParam->dma_emergency_bus_select = (uint32_t)p_Emergency->emergencyBusSelect;
+    p_Fm->p_FmDriverParam->dma_emergency_level = fsl_dma_emer;
 
     return E_OK;
 }
@@ -4750,34 +3920,38 @@ t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother = TRUE;
-    p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter = emergencyCnt;
+    p_Fm->p_FmDriverParam->dma_en_emergency_smoother = TRUE;
+    p_Fm->p_FmDriverParam->dma_emergency_switch_counter = emergencyCnt;
 
     return E_OK;
 }
 
 t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr)
 {
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    enum fman_dma_err   fsl_dma_err;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaErr = dmaErr;
+    FMAN_DMA_ERR_TRANS(fsl_dma_err, dmaErr);
+    p_Fm->p_FmDriverParam->dma_err = fsl_dma_err;
 
     return E_OK;
 }
 
 t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr)
 {
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    t_Fm                        *p_Fm = (t_Fm*)h_Fm;
+    enum fman_catastrophic_err  fsl_catastrophic_err;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->catastrophicErr = catastrophicErr;
+    FMAN_CATASTROPHIC_ERR_TRANS(fsl_catastrophic_err, catastrophicErr);
+    p_Fm->p_FmDriverParam->catastrophic_err = fsl_catastrophic_err;
 
     return E_OK;
 }
@@ -4793,7 +3967,7 @@ t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm)
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
 
-    p_Fm->p_FmDriverParam->enMuramTestMode = TRUE;
+    p_Fm->p_FmDriverParam->en_muram_test_mode = TRUE;
 
     return E_OK;
 }
@@ -4809,7 +3983,7 @@ t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm)
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
 
-    p_Fm->p_FmDriverParam->enIramTestMode = TRUE;
+    p_Fm->p_FmDriverParam->en_iram_test_mode = TRUE;
 
     return E_OK;
 }
@@ -4822,7 +3996,7 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->haltOnExternalActivation = enable;
+    p_Fm->p_FmDriverParam->halt_on_external_activ = enable;
 
     return E_OK;
 }
@@ -4838,7 +4012,8 @@ t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable)
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
 
-    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError = enable;
+    p_Fm->p_FmDriverParam->halt_on_unrecov_ecc_err = enable;
+
     return E_OK;
 }
 
@@ -4855,7 +4030,7 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
     if (bitMask)
     {
         if (enable)
-            p_Fm->p_FmDriverParam->userSetExceptions |= bitMask;
+            p_Fm->userSetExceptions |= bitMask;
         else
             p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
    }
@@ -4873,7 +4048,7 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->externalEccRamsEnable = enable;
+    p_Fm->p_FmDriverParam->external_ecc_rams_enable = enable;
 
     return E_OK;
 }
@@ -4886,7 +4061,8 @@ t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->tnumAgingPeriod = tnumAgingPeriod;
+    p_Fm->p_FmDriverParam->tnum_aging_period = tnumAgingPeriod;
+    p_Fm->tnumAgingPeriod = p_Fm->p_FmDriverParam->tnum_aging_period;
 
     return E_OK;
 }
@@ -4903,7 +4079,15 @@ t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    memcpy(&p_Fm->p_FmDriverParam->thresholds, p_FmThresholds, sizeof(t_FmThresholds));
+    p_Fm->p_FmDriverParam->disp_limit_tsh  = p_FmThresholds->dispLimit;
+    p_Fm->p_FmDriverParam->prs_disp_tsh    = p_FmThresholds->prsDispTh;
+    p_Fm->p_FmDriverParam->plcr_disp_tsh   = p_FmThresholds->plcrDispTh;
+    p_Fm->p_FmDriverParam->kg_disp_tsh     = p_FmThresholds->kgDispTh;
+    p_Fm->p_FmDriverParam->bmi_disp_tsh    = p_FmThresholds->bmiDispTh;
+    p_Fm->p_FmDriverParam->qmi_enq_disp_tsh = p_FmThresholds->qmiEnqDispTh;
+    p_Fm->p_FmDriverParam->qmi_deq_disp_tsh = p_FmThresholds->qmiDeqDispTh;
+    p_Fm->p_FmDriverParam->fm_ctl1_disp_tsh = p_FmThresholds->fmCtl1DispTh;
+    p_Fm->p_FmDriverParam->fm_ctl2_disp_tsh = p_FmThresholds->fmCtl2DispTh;
 
     return E_OK;
 }
@@ -4916,7 +4100,7 @@ t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergenc
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaSosEmergency = dmaSosEmergency;
+    p_Fm->p_FmDriverParam->dma_sos_emergency = dmaSosEmergency;
 
     return E_OK;
 }
@@ -4933,7 +4117,8 @@ t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDma
 #if (DPAA_VERSION >= 11)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
 #endif
-    memcpy(&p_Fm->p_FmDriverParam->dmaWriteBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+    p_Fm->p_FmDriverParam->dma_write_buf_tsh_asrt_emer = p_FmDmaThresholds->assertEmergency;
+    p_Fm->p_FmDriverParam->dma_write_buf_tsh_clr_emer  = p_FmDmaThresholds->clearEmergency;
 
     return E_OK;
 }
@@ -4946,7 +4131,8 @@ t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThr
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    memcpy(&p_Fm->p_FmDriverParam->dmaCommQThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+    p_Fm->p_FmDriverParam->dma_comm_qtsh_asrt_emer    = p_FmDmaThresholds->assertEmergency;
+    p_Fm->p_FmDriverParam->dma_comm_qtsh_clr_emer     = p_FmDmaThresholds->clearEmergency;
 
     return E_OK;
 }
@@ -4962,7 +4148,8 @@ t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaT
 #if (DPAA_VERSION >= 11)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
 #endif
-    memcpy(&p_Fm->p_FmDriverParam->dmaReadBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+    p_Fm->p_FmDriverParam->dma_read_buf_tsh_clr_emer   = p_FmDmaThresholds->clearEmergency;
+    p_Fm->p_FmDriverParam->dma_read_buf_tsh_asrt_emer  = p_FmDmaThresholds->assertEmergency;
 
     return E_OK;
 }
@@ -4975,7 +4162,7 @@ t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->dmaWatchdog = watchdogValue;
+    p_Fm->p_FmDriverParam->dma_watchdog = watchdogValue;
 
     return E_OK;
 }
@@ -5012,13 +4199,16 @@ void FM_EventIsr(t_Handle h_Fm)
     }
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     uint32_t                pending, event;
+    struct fman_fpm_regs *fpm_rg;
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
+    fpm_rg = p_Fm->p_FmFpmRegs;
+
     /* normal interrupts */
-    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fm_npi);
+    pending = fman_get_normal_pending(fpm_rg);
     if (!pending)
         return;
 
@@ -5056,8 +4246,7 @@ void FM_EventIsr(t_Handle h_Fm)
     /* IM port events may belong to different partitions */
     if (pending & INTR_EN_REV0)
     {
-        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_fcev[0]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[0]);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[0], event);
+        event = fman_get_controller_event(fpm_rg, 0);
         if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_0].guestId)
             /*TODO IPC ISR For Fman Ctrl */
             ASSERT_COND(0);
@@ -5068,8 +4257,7 @@ void FM_EventIsr(t_Handle h_Fm)
     }
     if (pending & INTR_EN_REV1)
     {
-        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_fcev[1]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[1]);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[1], event);
+        event = fman_get_controller_event(fpm_rg, 1);
         if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_1].guestId)
             /*TODO IPC ISR For Fman Ctrl */
             ASSERT_COND(0);
@@ -5079,8 +4267,7 @@ void FM_EventIsr(t_Handle h_Fm)
     }
     if (pending & INTR_EN_REV2)
     {
-        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_fcev[2]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[2]);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[2], event);
+        event = fman_get_controller_event(fpm_rg, 2);
         if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_2].guestId)
             /*TODO IPC ISR For Fman Ctrl */
             ASSERT_COND(0);
@@ -5090,8 +4277,7 @@ void FM_EventIsr(t_Handle h_Fm)
     }
     if (pending & INTR_EN_REV3)
     {
-        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_fcev[3]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_cee[3]);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[3], event);
+        event = fman_get_controller_event(fpm_rg, 3);
         if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_3].guestId)
             /*TODO IPC ISR For Fman Ctrl */
             ASSERT_COND(0);
@@ -5128,13 +4314,16 @@ t_Error FM_ErrorIsr(t_Handle h_Fm)
     }
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     uint32_t                pending;
+    struct fman_fpm_regs *fpm_rg;
 
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
+    fpm_rg = p_Fm->p_FmFpmRegs;
+
     /* error interrupts */
-    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fm_epi);
+    pending = fman_get_fpm_error_interrupts(fpm_rg);
     if (!pending)
         return ERROR_CODE(E_EMPTY);
 
@@ -5198,13 +4387,17 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
     int         i;
     uint8_t     sum;
     uint8_t     hardwarePortId;
-    uint32_t    tmpRegs[8] = {0,0,0,0,0,0,0,0};
-    uint8_t     relativePortId, shift, weight, maxPercent = 0;
+    uint8_t     weights[64];
+    uint8_t     weight, maxPercent = 0;
+    struct fman_bmi_regs *bmi_rg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
+    bmi_rg = p_Fm->p_FmBmiRegs;
+
+    memset(weights, 0, (sizeof(uint8_t) * 64));
     /* check that all ports add up to 100% */
     sum = 0;
     for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
@@ -5236,19 +4429,11 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
         SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId,
                                  p_PortsBandwidth->portsBandwidths[i].type,
                                  p_PortsBandwidth->portsBandwidths[i].relativePortId);
-        relativePortId = (uint8_t)(hardwarePortId % 8);
-        shift = (uint8_t)(32-4*(relativePortId+1));
 
-
-        if (weight > 1)
-            /* Add this port to tmpReg */
-            /* (each 8 ports result in one register)*/
-            tmpRegs[hardwarePortId/8] |= ((weight-1) << shift);
+        weights[hardwarePortId] = weight;
     }
 
-    for (i=0;i<8;i++)
-        if (tmpRegs[i])
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_arb[i], tmpRegs[i]);
+    fman_set_ports_bandwidth(bmi_rg, weights);
 
     return E_OK;
 }
@@ -5256,10 +4441,11 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
 t_Error FM_EnableRamsEcc(t_Handle h_Fm)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
-    uint32_t    tmpReg;
+    struct fman_fpm_regs *fpm_rg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    /*SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);*/
+
+    fpm_rg = p_Fm->p_FmFpmRegs;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -5288,11 +4474,7 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm)
         return E_OK;
     else
     {
-        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr);
-        if (tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg | FPM_RAM_CTL_IRAM_ECC_EN);
-        else
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg | (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        fman_enable_rams_ecc(fpm_rg);
         p_Fm->p_FmStateStruct->ramsEccEnable = TRUE;
     }
 
@@ -5302,12 +4484,13 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm)
 t_Error FM_DisableRamsEcc(t_Handle h_Fm)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
-    uint32_t    tmpReg;
     bool        explicitDisable = FALSE;
+    struct fman_fpm_regs *fpm_rg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-    /*SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);*/
+
+    fpm_rg = p_Fm->p_FmFpmRegs;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -5344,14 +4527,7 @@ t_Error FM_DisableRamsEcc(t_Handle h_Fm)
                routines are called */
             p_Fm->p_FmStateStruct->explicitEnable = FALSE;
 
-        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr);
-        if (tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
-        {
-            DBG(WARNING, ("Rams ECC is configured to be controlled through JTAG"));
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg & ~FPM_RAM_CTL_IRAM_ECC_EN);
-        }
-        else
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, tmpReg & ~(FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        fman_enable_rams_ecc(fpm_rg);
         p_Fm->p_FmStateStruct->ramsEccEnable = FALSE;
     }
 
@@ -5362,11 +4538,16 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
     uint32_t            bitMask = 0;
-    uint32_t            tmpReg;
+    enum fman_exceptions fslException;
+    struct fman_rg       fman_rg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
+
+    fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
+    fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
+    fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
+    fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
 
     GET_EXCEPTION_FLAG(bitMask, exception);
     if (bitMask)
@@ -5376,170 +4557,13 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
         else
             p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
 
-        switch (exception)
-        {
-             case (e_FM_EX_DMA_BUS_ERROR):
-                tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-                if (enable)
-                    tmpReg |= DMA_MODE_BER;
-                else
-                    tmpReg &= ~DMA_MODE_BER;
-                /* disable bus error */
-                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
-                break;
-             case (e_FM_EX_DMA_READ_ECC):
-             case (e_FM_EX_DMA_SYSTEM_WRITE_ECC):
-             case (e_FM_EX_DMA_FM_WRITE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-                if (enable)
-                    tmpReg |= DMA_MODE_ECC;
-                else
-                    tmpReg &= ~DMA_MODE_ECC;
-                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
-                break;
-             case (e_FM_EX_FPM_STALL_ON_TASKS):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
-                if (enable)
-                    tmpReg |= FPM_EV_MASK_STALL_EN;
-                else
-                    tmpReg &= ~FPM_EV_MASK_STALL_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg);
-                break;
-             case (e_FM_EX_FPM_SINGLE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
-                if (enable)
-                    tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
-                else
-                    tmpReg &= ~FPM_EV_MASK_SINGLE_ECC_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg);
-                break;
-            case ( e_FM_EX_FPM_DOUBLE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
-                if (enable)
-                    tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
-                else
-                    tmpReg &= ~FPM_EV_MASK_DOUBLE_ECC_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg);
-                break;
-            case ( e_FM_EX_QMI_SINGLE_ECC):
-#if defined(FM_QMI_NO_ECC_EXCEPTIONS) || defined(FM_QMI_NO_SINGLE_ECC_EXCEPTION)
-               if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 4) ||
-                   (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
-                {
-                   REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_SINGLE_ECC"));
-                   return E_OK;
-                }
-#endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
-                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
-                if (enable)
-                    tmpReg |= QMI_INTR_EN_SINGLE_ECC;
-                else
-                    tmpReg &= ~QMI_INTR_EN_SINGLE_ECC;
-                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
-                break;
-             case (e_FM_EX_QMI_DOUBLE_ECC):
-#ifdef FM_QMI_NO_ECC_EXCEPTIONS
-                if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
-                {
-                   REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_DOUBLE_ECC"));
-                   return E_OK;
-                }
-#endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
-                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-                if (enable)
-                    tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
-                else
-                    tmpReg &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
-                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
-                break;
-             case (e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID):
-                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-                if (enable)
-                    tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
-                else
-                    tmpReg &= ~QMI_ERR_INTR_EN_DEQ_FROM_DEF;
-                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
-                break;
-             case (e_FM_EX_BMI_LIST_RAM_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if (enable)
-                    tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
-                else
-                    tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
-                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
-                break;
-             case (e_FM_EX_BMI_STORAGE_PROFILE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if (enable)
-                    tmpReg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
-                else
-                    tmpReg &= ~BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
-                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
-                break;
-             case (e_FM_EX_BMI_STATISTICS_RAM_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if (enable)
-                    tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
-                else
-                    tmpReg &= ~BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
-                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
-                break;
-             case (e_FM_EX_BMI_DISPATCH_RAM_ECC):
-               tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-               if (enable)
-               {
-#ifdef FM_NO_DISPATCH_RAM_ECC
-                   if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
-                   {
-                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_DISPATCH_RAM_ECC"));
-                       return E_OK;
-                   }
-#endif /* FM_NO_DISPATCH_RAM_ECC */
-                   tmpReg |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
-               }
-               else
-                   tmpReg &= ~BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
-               WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
-               break;
-             case (e_FM_EX_IRAM_ECC):
-                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
-                if (enable)
-                {
-                    /* enable ECC if not enabled */
-                    FmEnableRamsEcc(p_Fm);
-                    /* enable ECC interrupts */
-                    tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
-                }
-                else
-                {
-                    /* ECC mechanism may be disabled, depending on driver status  */
-                    FmDisableRamsEcc(p_Fm);
-                    tmpReg &= ~FPM_IRAM_ECC_ERR_EX_EN;
-                }
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rie, tmpReg);
-                break;
+        FMAN_EXCEPTION_TRANS(fslException, exception);
 
-             case (e_FM_EX_MURAM_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
-                if (enable)
-                {
-                    /* enable ECC if not enabled */
-                    FmEnableRamsEcc(p_Fm);
-                    /* enable ECC interrupts */
-                    tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
-                }
-                else
-                {
-                    /* ECC mechanism may be disabled, depending on driver status  */
-                    FmDisableRamsEcc(p_Fm);
-                    tmpReg &= ~FPM_MURAM_ECC_ERR_EX_EN;
-                }
-
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rie, tmpReg);
-                break;
-            default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
-        }
+
+
+        return (t_Error)fman_set_exception(&fman_rg,
+                                  fslException,
+                                  enable);
     }
     else
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
@@ -5615,10 +4639,17 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
     t_Error     err;
     uint32_t    counterValue;
+    struct fman_rg       fman_rg;
+    enum fman_counters fsl_counter;
 
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
 
+    fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
+    fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
+    fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
+    fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
+
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
         p_Fm->h_IpcSessions[0])
@@ -5688,146 +4719,65 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
             break;
     }
 
-    switch (counter)
-    {
-        case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc);
-        case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc);
-        case (e_FM_COUNTERS_DEQ_0):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0);
-        case (e_FM_COUNTERS_DEQ_1):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1);
-        case (e_FM_COUNTERS_DEQ_2):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2);
-        case (e_FM_COUNTERS_DEQ_3):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3);
-        case (e_FM_COUNTERS_DEQ_FROM_DEFAULT):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc);
-        case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc);
-        case (e_FM_COUNTERS_DEQ_FROM_FD):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc);
-        case (e_FM_COUNTERS_DEQ_CONFIRM):
-            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc);
-            break;
-    }
-    /* should never get here */
-    ASSERT_COND(FALSE);
-    return 0;
+    FMAN_COUNTERS_TRANS(fsl_counter, counter);
+    return fman_get_counter(&fman_rg, fsl_counter);
 }
 
 t_Error FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
+    struct fman_rg          fman_rg;
+    enum fman_counters fsl_counter;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    /* When applicable (when there is an 'enable counters' bit,
-    check that counters are enabled */
-    switch (counter)
-    {
-        case (e_FM_COUNTERS_DEQ_1):
-        case (e_FM_COUNTERS_DEQ_2):
-        case (e_FM_COUNTERS_DEQ_3):
-             if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
-        case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
-        case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
-        case (e_FM_COUNTERS_DEQ_0):
-        case (e_FM_COUNTERS_DEQ_FROM_DEFAULT):
-        case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
-        case (e_FM_COUNTERS_DEQ_FROM_FD):
-        case (e_FM_COUNTERS_DEQ_CONFIRM):
-            if (!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
-            break;
-        default:
-            break;
-    }
+   fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
+   fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
+   fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
+   fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
 
-    /* Set counter */
-    switch (counter)
-    {
-        case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc, val);
-            break;
-        case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc, val);
-            break;
-        case (e_FM_COUNTERS_DEQ_0):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0, val);
-            break;
-        case (e_FM_COUNTERS_DEQ_1):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1, val);
-            break;
-        case (e_FM_COUNTERS_DEQ_2):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2, val);
-            break;
-        case (e_FM_COUNTERS_DEQ_3):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3, val);
-            break;
-        case (e_FM_COUNTERS_DEQ_FROM_DEFAULT):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc, val);
-            break;
-        case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc, val);
-            break;
-        case (e_FM_COUNTERS_DEQ_FROM_FD):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc, val);
-            break;
-        case (e_FM_COUNTERS_DEQ_CONFIRM):
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc, val);
-            break;
-        default:
-            break;
-    }
-
-    return E_OK;
+   FMAN_COUNTERS_TRANS(fsl_counter, counter);
+   return  (t_Error)fman_modify_counter(&fman_rg, fsl_counter, val);
 }
 
 void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
-    uint32_t    bitMask;
+    struct fman_dma_regs *dma_rg;
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
-
-    bitMask = (uint32_t)((muramPort==e_FM_DMA_MURAM_PORT_WRITE) ? DMA_MODE_EMERGENCY_WRITE : DMA_MODE_EMERGENCY_READ);
 
-    if (enable)
-        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | bitMask);
-    else /* disable */
-        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) & ~bitMask);
+    dma_rg = p_Fm->p_FmDmaRegs;
 
-    return;
+    fman_set_dma_emergency(dma_rg, !!(muramPort==e_FM_DMA_MURAM_PORT_WRITE), enable);
 }
 
 void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
+    struct fman_dma_regs *dma_rg;
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | ((uint32_t)pri << DMA_MODE_BUS_PRI_SHIFT) );
+    dma_rg = p_Fm->p_FmDmaRegs;
 
-    return;
+    fman_set_dma_ext_bus_pri(dma_rg, pri);
 }
 
 void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    uint32_t            tmpReg;
+    uint32_t             dmaStatus;
+    struct fman_dma_regs *dma_rg;
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
 
+    dma_rg = p_Fm->p_FmDmaRegs;
+
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
         p_Fm->h_IpcSessions[0])
@@ -5876,33 +4826,32 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
         return;
     }
 
-    tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
+    dmaStatus = fman_get_dma_status(dma_rg);
 
-    p_FmDmaStatus->cmqNotEmpty = (bool)(tmpReg & DMA_STATUS_CMD_QUEUE_NOT_EMPTY);
-    p_FmDmaStatus->busError = (bool)(tmpReg & DMA_STATUS_BUS_ERR);
+    p_FmDmaStatus->cmqNotEmpty = (bool)(dmaStatus & DMA_STATUS_CMD_QUEUE_NOT_EMPTY);
+    p_FmDmaStatus->busError = (bool)(dmaStatus & DMA_STATUS_BUS_ERR);
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        p_FmDmaStatus->singlePortEccError = (bool)(tmpReg & DMA_STATUS_FM_SPDAT_ECC);
+        p_FmDmaStatus->singlePortEccError = (bool)(dmaStatus & DMA_STATUS_FM_SPDAT_ECC);
     else
     {
-        p_FmDmaStatus->readBufEccError = (bool)(tmpReg & DMA_STATUS_READ_ECC);
-        p_FmDmaStatus->writeBufEccSysError = (bool)(tmpReg & DMA_STATUS_SYSTEM_WRITE_ECC);
-        p_FmDmaStatus->writeBufEccFmError = (bool)(tmpReg & DMA_STATUS_FM_WRITE_ECC);
+        p_FmDmaStatus->readBufEccError = (bool)(dmaStatus & DMA_STATUS_READ_ECC);
+        p_FmDmaStatus->writeBufEccSysError = (bool)(dmaStatus & DMA_STATUS_SYSTEM_WRITE_ECC);
+        p_FmDmaStatus->writeBufEccFmError = (bool)(dmaStatus & DMA_STATUS_FM_WRITE_ECC);
     }
 }
 
 void FM_Resume(t_Handle h_Fm)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
-    uint32_t        tmpReg;
+    struct fman_fpm_regs *fpm_rg;
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
-    /* clear tmpReg event bits in order not to clear standing events */
-    tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg | FPM_EV_MASK_RELEASE_FM);
+    fpm_rg = p_Fm->p_FmFpmRegs;
+
+    fman_resume(fpm_rg);
 }
 
 t_Error FM_GetSpecialOperationCoding(t_Handle               h_Fm,
@@ -6077,8 +5026,8 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_prc);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_brkc);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_mxd);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dis1);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dis2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dist1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dist2);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_epi);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_rie);
 
@@ -6184,6 +5133,7 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_if);
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gs);
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_etfc);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_tapc);
 
     return E_OK;
 }
@@ -6198,16 +5148,22 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
 t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
+    enum fman_exceptions fslException;
+    struct fman_rg fman_rg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
 
+    fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
+    fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
+    fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
+    fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
+
     switch (exception)
     {
         case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
             if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DEQ_FROM_DEF);
             break;
         case e_FM_EX_QMI_SINGLE_ECC:
             if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
@@ -6215,36 +5171,33 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
 
             if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, QMI_INTR_EN_SINGLE_ECC);
             break;
         case e_FM_EX_QMI_DOUBLE_ECC:
             if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DOUBLE_ECC);
             break;
         case e_FM_EX_BMI_LIST_RAM_ECC:
             if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_LIST_RAM_ECC);
             break;
         case e_FM_EX_BMI_STORAGE_PROFILE_ECC:
             if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STORAGE_PROFILE_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC);
             break;
         case e_FM_EX_BMI_STATISTICS_RAM_ECC:
             if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STATISTICS_RAM_ECC);
             break;
         case e_FM_EX_BMI_DISPATCH_RAM_ECC:
             if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_DISPATCH_RAM_ECC);
             break;
         default:
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
     }
 
+    FMAN_EXCEPTION_TRANS(fslException, exception);
+    fman_force_intr (&fman_rg, fslException);
+
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
index cb97d3e..3e5b2ec 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
@@ -44,6 +44,7 @@
 #include "fm_ext.h"
 #include "fm_ipc.h"
 
+#include "fsl_fman.h"
 
 #define __ERR_MODULE__  MODULE_FM
 
@@ -71,6 +72,12 @@
 #define FM_EX_BMI_DISPATCH_RAM_ECC          0x00010000
 #define FM_EX_DMA_SINGLE_PORT_ECC           0x00008000
 
+#define DMA_EMSR_EMSTR_MASK                 0x0000FFFF
+
+#define DMA_THRESH_COMMQ_MASK               0xFF000000
+#define DMA_THRESH_READ_INT_BUF_MASK        0x007F0000
+#define DMA_THRESH_WRITE_INT_BUF_MASK       0x0000007F
+
 #define GET_EXCEPTION_FLAG(bitMask, exception)              \
 switch (exception){                                         \
     case e_FM_EX_DMA_BUS_ERROR:                             \
@@ -150,6 +157,146 @@ switch (exception){                                         \
         break;                                                                                      \
     }
 
+#define FMAN_EXCEPTION_TRANS(fsl_exception, _exception) \
+    switch (_exception) {\
+        case  e_FM_EX_DMA_BUS_ERROR:                    \
+            fsl_exception =  E_FMAN_EX_DMA_BUS_ERROR; break;    \
+        case  e_FM_EX_DMA_READ_ECC:                    \
+            fsl_exception =  E_FMAN_EX_DMA_READ_ECC; break;        \
+        case  e_FM_EX_DMA_SYSTEM_WRITE_ECC:                \
+            fsl_exception =  E_FMAN_EX_DMA_SYSTEM_WRITE_ECC; break;    \
+        case  e_FM_EX_DMA_FM_WRITE_ECC:                    \
+            fsl_exception =  E_FMAN_EX_DMA_FM_WRITE_ECC; break;    \
+        case  e_FM_EX_FPM_STALL_ON_TASKS:                \
+            fsl_exception =  E_FMAN_EX_FPM_STALL_ON_TASKS; break;    \
+        case  e_FM_EX_FPM_SINGLE_ECC:                    \
+            fsl_exception =  E_FMAN_EX_FPM_SINGLE_ECC; break;    \
+        case  e_FM_EX_FPM_DOUBLE_ECC:                    \
+            fsl_exception =  E_FMAN_EX_FPM_DOUBLE_ECC; break;    \
+        case  e_FM_EX_QMI_SINGLE_ECC:                    \
+            fsl_exception =  E_FMAN_EX_QMI_SINGLE_ECC; break;    \
+        case  e_FM_EX_QMI_DOUBLE_ECC:                    \
+            fsl_exception =  E_FMAN_EX_QMI_DOUBLE_ECC; break;    \
+        case  e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:            \
+            fsl_exception =  E_FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID; break; \
+        case  e_FM_EX_BMI_LIST_RAM_ECC:                    \
+            fsl_exception =  E_FMAN_EX_BMI_LIST_RAM_ECC; break;    \
+        case  e_FM_EX_BMI_STORAGE_PROFILE_ECC:                    \
+            fsl_exception =  E_FMAN_EX_BMI_STORAGE_PROFILE_ECC; break;    \
+        case  e_FM_EX_BMI_STATISTICS_RAM_ECC:                \
+            fsl_exception =  E_FMAN_EX_BMI_STATISTICS_RAM_ECC; break; \
+        case  e_FM_EX_BMI_DISPATCH_RAM_ECC:                \
+            fsl_exception =  E_FMAN_EX_BMI_DISPATCH_RAM_ECC; break;    \
+        case  e_FM_EX_IRAM_ECC:                        \
+            fsl_exception =  E_FMAN_EX_IRAM_ECC; break;        \
+        case  e_FM_EX_MURAM_ECC:                    \
+            fsl_exception =  E_FMAN_EX_MURAM_ECC; break;        \
+        default: \
+            fsl_exception =  E_FMAN_EX_DMA_BUS_ERROR; break;    \
+    }
+
+#define FMAN_CACHE_OVERRIDE_TRANS(fsl_cache_override, _cache_override) \
+    switch (_cache_override){ \
+        case  e_FM_DMA_NO_CACHE_OR:                    \
+            fsl_cache_override =  E_FMAN_DMA_NO_CACHE_OR; break;    \
+        case  e_FM_DMA_NO_STASH_DATA:                    \
+            fsl_cache_override =  E_FMAN_DMA_NO_STASH_DATA; break;        \
+        case  e_FM_DMA_MAY_STASH_DATA:                    \
+            fsl_cache_override =  E_FMAN_DMA_MAY_STASH_DATA; break;    \
+        case  e_FM_DMA_STASH_DATA:                        \
+            fsl_cache_override =  E_FMAN_DMA_STASH_DATA; break;        \
+        default: \
+            fsl_cache_override =  E_FMAN_DMA_NO_CACHE_OR; break;    \
+    }
+
+#define FMAN_AID_MODE_TRANS(fsl_aid_mode, _aid_mode) \
+    switch (_aid_mode){ \
+        case  e_FM_DMA_AID_OUT_PORT_ID:                    \
+            fsl_aid_mode =  E_FMAN_DMA_AID_OUT_PORT_ID; break;    \
+        case  e_FM_DMA_AID_OUT_TNUM:                    \
+            fsl_aid_mode =  E_FMAN_DMA_AID_OUT_TNUM; break;        \
+        default: \
+            fsl_aid_mode =  E_FMAN_DMA_AID_OUT_PORT_ID; break;    \
+    }
+
+#define FMAN_DMA_DBG_CNT_TRANS(fsl_dma_dbg_cnt, _dma_dbg_cnt) \
+    switch (_dma_dbg_cnt){ \
+        case  e_FM_DMA_DBG_NO_CNT:                    \
+            fsl_dma_dbg_cnt =  E_FMAN_DMA_DBG_NO_CNT; break;    \
+        case  e_FM_DMA_DBG_CNT_DONE:                    \
+            fsl_dma_dbg_cnt =  E_FMAN_DMA_DBG_CNT_DONE; break;        \
+        case  e_FM_DMA_DBG_CNT_COMM_Q_EM:                    \
+            fsl_dma_dbg_cnt =  E_FMAN_DMA_DBG_CNT_COMM_Q_EM; break;    \
+        case  e_FM_DMA_DBG_CNT_INT_READ_EM:                        \
+            fsl_dma_dbg_cnt =  E_FMAN_DMA_DBG_CNT_INT_READ_EM; break;        \
+        case  e_FM_DMA_DBG_CNT_INT_WRITE_EM:                        \
+            fsl_dma_dbg_cnt = E_FMAN_DMA_DBG_CNT_INT_WRITE_EM ; break;        \
+        case  e_FM_DMA_DBG_CNT_FPM_WAIT:                        \
+            fsl_dma_dbg_cnt = E_FMAN_DMA_DBG_CNT_FPM_WAIT ; break;        \
+        case  e_FM_DMA_DBG_CNT_SIGLE_BIT_ECC:                        \
+            fsl_dma_dbg_cnt = E_FMAN_DMA_DBG_CNT_SIGLE_BIT_ECC ; break;        \
+        case  e_FM_DMA_DBG_CNT_RAW_WAR_PROT:                        \
+            fsl_dma_dbg_cnt = E_FMAN_DMA_DBG_CNT_RAW_WAR_PROT ; break;        \
+        default: \
+            fsl_dma_dbg_cnt =  E_FMAN_DMA_DBG_NO_CNT; break;    \
+    }
+
+#define FMAN_DMA_EMER_TRANS(fsl_dma_emer, _dma_emer) \
+    switch (_dma_emer){ \
+        case  e_FM_DMA_EM_EBS:                    \
+            fsl_dma_emer =  E_FMAN_DMA_EM_EBS; break;    \
+        case  e_FM_DMA_EM_SOS:                    \
+            fsl_dma_emer =  E_FMAN_DMA_EM_SOS; break;        \
+        default: \
+            fsl_dma_emer =  E_FMAN_DMA_EM_EBS; break;    \
+    }
+
+#define FMAN_DMA_ERR_TRANS(fsl_dma_err, _dma_err) \
+    switch (_dma_err){ \
+        case  e_FM_DMA_ERR_CATASTROPHIC:                    \
+            fsl_dma_err =  E_FMAN_DMA_ERR_CATASTROPHIC; break;    \
+        case  e_FM_DMA_ERR_REPORT:                    \
+            fsl_dma_err =  E_FMAN_DMA_ERR_REPORT; break;        \
+        default: \
+            fsl_dma_err =  E_FMAN_DMA_ERR_CATASTROPHIC; break;    \
+    }
+
+#define FMAN_CATASTROPHIC_ERR_TRANS(fsl_catastrophic_err, _catastrophic_err) \
+    switch (_catastrophic_err){ \
+        case  e_FM_CATASTROPHIC_ERR_STALL_PORT:                    \
+            fsl_catastrophic_err =  E_FMAN_CATAST_ERR_STALL_PORT; break;    \
+        case  e_FM_CATASTROPHIC_ERR_STALL_TASK:                    \
+            fsl_catastrophic_err =  E_FMAN_CATAST_ERR_STALL_TASK; break;        \
+        default: \
+            fsl_catastrophic_err =  E_FMAN_CATAST_ERR_STALL_PORT; break;    \
+    }
+
+#define FMAN_COUNTERS_TRANS(fsl_counters, _counters) \
+    switch (_counters){ \
+        case  e_FM_COUNTERS_ENQ_TOTAL_FRAME:                    \
+            fsl_counters =  E_FMAN_COUNTERS_ENQ_TOTAL_FRAME; break;    \
+        case  e_FM_COUNTERS_DEQ_TOTAL_FRAME:                    \
+            fsl_counters =  E_FMAN_COUNTERS_DEQ_TOTAL_FRAME; break;        \
+        case  e_FM_COUNTERS_DEQ_0:                    \
+            fsl_counters =  E_FMAN_COUNTERS_DEQ_0; break;    \
+        case  e_FM_COUNTERS_DEQ_1:                    \
+            fsl_counters =  E_FMAN_COUNTERS_DEQ_1; break;        \
+        case  e_FM_COUNTERS_DEQ_2:                    \
+            fsl_counters =  E_FMAN_COUNTERS_DEQ_2; break;    \
+        case  e_FM_COUNTERS_DEQ_3:                    \
+            fsl_counters =  E_FMAN_COUNTERS_DEQ_3; break;        \
+        case  e_FM_COUNTERS_DEQ_FROM_DEFAULT:                    \
+            fsl_counters =  E_FMAN_COUNTERS_DEQ_FROM_DEFAULT; break;    \
+        case  e_FM_COUNTERS_DEQ_FROM_CONTEXT:                    \
+            fsl_counters =  E_FMAN_COUNTERS_DEQ_FROM_CONTEXT; break;        \
+        case  e_FM_COUNTERS_DEQ_FROM_FD:                    \
+            fsl_counters =  E_FMAN_COUNTERS_DEQ_FROM_FD; break;    \
+        case  e_FM_COUNTERS_DEQ_CONFIRM:                    \
+            fsl_counters =  E_FMAN_COUNTERS_DEQ_CONFIRM; break;        \
+        default: \
+            fsl_counters =  E_FMAN_COUNTERS_ENQ_TOTAL_FRAME; break;    \
+    }
+
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
@@ -191,7 +338,6 @@ switch (exception){                                         \
 #define DEFAULT_haltOnUnrecoverableEccError FALSE   /* do not change! if changed, must be disabled for rev1 ! */
 #define DEFAULT_externalEccRamsEnable       FALSE
 #define DEFAULT_VerifyUcode                 FALSE
-#define DEFAULT_tnumAgingPeriod             0
 
 #if (DPAA_VERSION < 11)
 #define DEFAULT_totalFifoSize(major)    \
@@ -248,7 +394,6 @@ switch (exception){                                         \
 #define DEFAULT_fmCtl2DispTh                16
 #endif /* (DPAA_VERSION < 11) */
 
-
 #define FM_TIMESTAMP_1_USEC_BIT             8
 
 /**************************************************************************//**
@@ -316,7 +461,6 @@ switch (exception){                                         \
 #define FM_MM_SP                0x000dc000
 #endif /* (DPAA_VERSION >= 11) */
 
-
 /**************************************************************************//**
  @Description       Memory Mapped Registers
 *//***************************************************************************/
@@ -324,145 +468,6 @@ switch (exception){                                         \
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-
-typedef _Packed struct
-{
-    volatile uint32_t   fmfp_tnc;       /**< FPM TNUM Control */
-    volatile uint32_t   fmfp_prc;       /**< FPM Port_ID FmCtl Association */
-    volatile uint32_t   fmfp_brkc;      /**< FPM Breakpoint Control */
-    volatile uint32_t   fmfp_mxd;       /**< FPM Maximum dispatch */
-    volatile uint32_t   fmfp_dis1;      /**< FPM Dispatch Thresholds1 */
-    volatile uint32_t   fmfp_dis2;      /**< FPM Dispatch Thresholds2  */
-    volatile uint32_t   fm_epi;         /**< FM Error Pending Interrupts */
-    volatile uint32_t   fm_rie;         /**< FM Error Interrupt Enable */
-    volatile uint32_t   fmfp_fcev[4];   /**< FPM FMan-Controller Event 1-4 */
-    volatile uint8_t    res1[16];       /**< reserved */
-    volatile uint32_t   fmfp_cee[4];    /**< PM FMan-Controller Event 1-4 */
-    volatile uint8_t    res2[16];       /**< reserved */
-    volatile uint32_t   fmfp_tsc1;      /**< FPM TimeStamp Control1 */
-    volatile uint32_t   fmfp_tsc2;      /**< FPM TimeStamp Control2 */
-    volatile uint32_t   fmfp_tsp;       /**< FPM Time Stamp */
-    volatile uint32_t   fmfp_tsf;       /**< FPM Time Stamp Fraction */
-    volatile uint32_t   fm_rcr;         /**< FM Rams Control */
-    volatile uint32_t   fmfp_extc;      /**< FPM External Requests Control */
-    volatile uint32_t   fmfp_ext1;      /**< FPM External Requests Config1 */
-    volatile uint32_t   fmfp_ext2;      /**< FPM External Requests Config2 */
-    volatile uint32_t   fmfp_drd[4];    /**< FPM Data_Ram Data 0-3 */
-    volatile uint8_t    res3[48];       /**< reserved */
-    volatile uint32_t   fmfp_dra;       /**< FPM Data Ram Access */
-    volatile uint32_t   fm_ip_rev_1;    /**< FM IP Block Revision 1 */
-    volatile uint32_t   fm_ip_rev_2;    /**< FM IP Block Revision 2 */
-    volatile uint32_t   fm_rstc;        /**< FM Reset Command */
-    volatile uint32_t   fm_cld;         /**< FM Classifier Debug */
-    volatile uint32_t   fm_npi;         /**< FM Normal Pending Interrupts  */
-    volatile uint32_t   fmfp_exte;      /**< FPM External Requests Enable */
-    volatile uint32_t   fmfp_ee;        /**< FPM Event & Enable */
-    volatile uint32_t   fmfp_cev[4];    /**< FPM CPU Event 1-4 */
-    volatile uint8_t    res4[16];       /**< reserved */
-    volatile uint32_t   fmfp_ps[0x40];  /**< FPM Port Status */
-    volatile uint8_t    reserved1[0x200];
-    volatile uint32_t   fmfp_ts[128];     /**< 0x400: FPM Task Status */
-} _PackedType t_FmFpmRegs;
-
-#define NUM_OF_DBG_TRAPS    3
-
-typedef _Packed struct
-{
-   volatile uint32_t   fmbm_init;       /**< BMI Initialization */
-   volatile uint32_t   fmbm_cfg1;       /**< BMI Configuration 1 */
-   volatile uint32_t   fmbm_cfg2;       /**< BMI Configuration 2 */
-   volatile uint32_t   reserved[5];
-   volatile uint32_t   fmbm_ievr;       /**< Interrupt Event Register */
-   volatile uint32_t   fmbm_ier;        /**< Interrupt Enable Register */
-   volatile uint32_t   fmbm_ifr;        /**< Interrupt Force Register */
-   volatile uint32_t   reserved1[5];
-   volatile uint32_t   fmbm_arb[8];     /**< BMI Arbitration */
-   volatile uint32_t   reserved2[12];
-   volatile uint32_t   fmbm_dtc[NUM_OF_DBG_TRAPS];      /**< BMI Debug Trap Counter */
-   volatile uint32_t   reserved3;
-   volatile uint32_t   fmbm_dcv[NUM_OF_DBG_TRAPS][4];   /**< BMI Debug Compare Value */
-   volatile uint32_t   fmbm_dcm[NUM_OF_DBG_TRAPS][4];   /**< BMI Debug Compare Mask */
-   volatile uint32_t   fmbm_gde;        /**< BMI Global Debug Enable */
-   volatile uint32_t   fmbm_pp[63];     /**< BMI Port Parameters */
-   volatile uint32_t   reserved4;
-   volatile uint32_t   fmbm_pfs[63];    /**< BMI Port FIFO Size */
-   volatile uint32_t   reserved5;
-   volatile uint32_t   fmbm_spliodn[63];   /**< Port Partition ID */
-} _PackedType t_FmBmiRegs;
-
-typedef _Packed struct
-{
-    volatile uint32_t   fmqm_gc;        /**<  General Configuration Register */
-    volatile uint32_t   reserved0;
-    volatile uint32_t   fmqm_eie;       /**<  Error Interrupt Event Register */
-    volatile uint32_t   fmqm_eien;      /**<  Error Interrupt Enable Register */
-    volatile uint32_t   fmqm_eif;       /**<  Error Interrupt Force Register */
-    volatile uint32_t   fmqm_ie;        /**<  Interrupt Event Register */
-    volatile uint32_t   fmqm_ien;       /**<  Interrupt Enable Register */
-    volatile uint32_t   fmqm_if;        /**<  Interrupt Force Register */
-    volatile uint32_t   fmqm_gs;        /**<  Global Status Register */
-    volatile uint32_t   reserved1;
-    volatile uint32_t   fmqm_etfc;      /**<  Enqueue Total Frame Counter */
-    volatile uint32_t   fmqm_dtfc;      /**<  Dequeue Total Frame Counter */
-    volatile uint32_t   fmqm_dc0;       /**<  Dequeue Counter 0 */
-    volatile uint32_t   fmqm_dc1;       /**<  Dequeue Counter 1 */
-    volatile uint32_t   fmqm_dc2;       /**<  Dequeue Counter 2 */
-    volatile uint32_t   fmqm_dc3;       /**<  Dequeue Counter 3 */
-    volatile uint32_t   fmqm_dfdc;      /**<  Dequeue FQID from Default Counter */
-    volatile uint32_t   fmqm_dfcc;      /**<  Dequeue FQID from Context Counter */
-    volatile uint32_t   fmqm_dffc;      /**<  Dequeue FQID from FD Counter */
-    volatile uint32_t   fmqm_dcc;       /**<  Dequeue Confirm Counter */
-    volatile uint32_t   reserved1a[7];
-    volatile uint32_t   fmqm_tapc;      /**<  Tnum Aging Period Control */
-    volatile uint32_t   fmqm_dmcvc;     /**<  Dequeue MAC Command Valid Counter */
-    volatile uint32_t   fmqm_difdcc;    /**<  Dequeue Invalid FD Command Counter */
-    volatile uint32_t   fmqm_da1v;      /**<  Dequeue A1 Valid Counter */
-    volatile uint32_t   reserved1b;
-    volatile uint32_t   fmqm_dtc;       /**<  0x0080 Debug Trap Counter */
-    volatile uint32_t   fmqm_efddd;     /**<  0x0084 Enqueue Frame Descriptor Dynamic Debug */
-    volatile uint32_t   reserved3[2];
-    _Packed struct {
-        volatile uint32_t   fmqm_dtcfg1;    /**<  0x0090 Debug Trap Configuration 1 Register */
-        volatile uint32_t   fmqm_dtval1;    /**<  Debug Trap Value 1 Register */
-        volatile uint32_t   fmqm_dtm1;      /**<  Debug Trap Mask 1 Register */
-        volatile uint32_t   fmqm_dtc1;      /**<  Debug Trap Counter 1 Register */
-        volatile uint32_t   fmqm_dtcfg2;    /**<  Debug Trap Configuration 2 Register */
-        volatile uint32_t   fmqm_dtval2;    /**<  Debug Trap Value 2 Register */
-        volatile uint32_t   fmqm_dtm2;      /**<  Debug Trap Mask 2 Register */
-        volatile uint32_t   reserved1;
-    } _PackedType dbgTraps[NUM_OF_DBG_TRAPS];
-} _PackedType t_FmQmiRegs;
-
-typedef _Packed struct
-{
-    volatile uint32_t   fmdmsr;         /**< FM DMA status register 0x04 */
-    volatile uint32_t   fmdmmr;         /**< FM DMA mode register 0x08 */
-    volatile uint32_t   fmdmtr;         /**< FM DMA bus threshold register 0x0c */
-    volatile uint32_t   fmdmhy;         /**< FM DMA bus hysteresis register 0x10 */
-    volatile uint32_t   fmdmsetr;       /**< FM DMA SOS emergency Threshold Register 0x14 */
-    volatile uint32_t   fmdmtah;        /**< FM DMA transfer bus address high register 0x18  */
-    volatile uint32_t   fmdmtal;        /**< FM DMA transfer bus address low register 0x1C  */
-    volatile uint32_t   fmdmtcid;       /**< FM DMA transfer bus communication ID register 0x20  */
-    volatile uint32_t   fmdmra;         /**< FM DMA bus internal ram address register 0x24  */
-    volatile uint32_t   fmdmrd;         /**< FM DMA bus internal ram data register 0x28  */
-    volatile uint32_t   fmdmwcr;        /**< FM DMA CAM watchdog counter value 0x2C  */
-    volatile uint32_t   fmdmebcr;       /**< FM DMA CAM base in MURAM register 0x30  */
-    volatile uint32_t   fmdmccqdr;      /**< FM DMA CAM and CMD Queue Debug register 0x34  */
-    volatile uint32_t   fmdmccqvr1;     /**< FM DMA CAM and CMD Queue Value register #1 0x38  */
-    volatile uint32_t   fmdmccqvr2;     /**< FM DMA CAM and CMD Queue Value register #2 0x3C  */
-    volatile uint32_t   fmdmcqvr3;      /**< FM DMA CMD Queue Value register #3 0x40  */
-    volatile uint32_t   fmdmcqvr4;      /**< FM DMA CMD Queue Value register #4 0x44  */
-    volatile uint32_t   fmdmcqvr5;      /**< FM DMA CMD Queue Value register #5 0x48  */
-    volatile uint32_t   fmdmsefrc;      /**< FM DMA Semaphore Entry Full Reject Counter 0x50  */
-    volatile uint32_t   fmdmsqfrc;      /**< FM DMA Semaphore Queue Full Reject Counter 0x54  */
-    volatile uint32_t   fmdmssrc;       /**< FM DMA Semaphore SYNC Reject Counter 0x54  */
-    volatile uint32_t   fmdmdcr;        /**< FM DMA Debug Counter */
-    volatile uint32_t   fmdmemsr;       /**< FM DMA Emrgency Smoother Register */
-    volatile uint32_t   reserved;
-    volatile uint32_t   fmdmplr[FM_MAX_NUM_OF_HW_PORT_IDS/2];
-                                        /**< FM DMA PID-LIODN # register  */
-} _PackedType t_FmDmaRegs;
-
 typedef _Packed struct
 {
     volatile uint32_t   iadd;           /**< FM IRAM instruction address register */
@@ -506,8 +511,6 @@ typedef _Packed struct t_FmTrbRegs
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
-
-
 /**************************************************************************//**
  @Description       General defines
 *//***************************************************************************/
@@ -515,192 +518,10 @@ typedef _Packed struct t_FmTrbRegs
 #define FM_FW_DEBUG_INSTRUCTION             0x6ffff805UL
 
 /**************************************************************************//**
- @Description       DMA definitions
-*//***************************************************************************/
-/* masks */
-#define DMA_MODE_AID_OR                     0x20000000
-#define DMA_MODE_SBER                       0x10000000
-#define DMA_MODE_BER                        0x00200000
-#define DMA_MODE_EB                         0x00100000
-#define DMA_MODE_ECC                        0x00000020
-#define DMA_MODE_PRIVILEGE_PROT             0x00001000
-#define DMA_MODE_SECURE_PROT                0x00000800
-#define DMA_MODE_EMERGENCY_READ             0x00080000
-#define DMA_MODE_EMERGENCY_WRITE            0x00040000
-#define DMA_MODE_CACHE_OR_MASK              0xC0000000
-#define DMA_MODE_CEN_MASK                   0x0000E000
-#define DMA_MODE_DBG_MASK                   0x00000380
-
-#define DMA_TRANSFER_PORTID_MASK            0xFF000000
-#define DMA_TRANSFER_TNUM_MASK              0x00FF0000
-#define DMA_TRANSFER_LIODN_MASK             0x00000FFF
-
-#define DMA_HIGH_LIODN_MASK                 0x0FFF0000
-#define DMA_LOW_LIODN_MASK                  0x00000FFF
-
-#define DMA_STATUS_CMD_QUEUE_NOT_EMPTY      0x10000000
-#define DMA_STATUS_BUS_ERR                  0x08000000
-#define DMA_STATUS_READ_ECC                 0x04000000
-#define DMA_STATUS_SYSTEM_WRITE_ECC         0x02000000
-#define DMA_STATUS_FM_WRITE_ECC             0x01000000
-#define DMA_STATUS_SYSTEM_DPEXT_ECC         0x00800000
-#define DMA_STATUS_FM_DPEXT_ECC             0x00400000
-#define DMA_STATUS_SYSTEM_DPDAT_ECC         0x00200000
-#define DMA_STATUS_FM_DPDAT_ECC             0x00100000
-#define DMA_STATUS_FM_SPDAT_ECC             0x00080000
-
-#define DMA_STATUS_FM_ECC                   (DMA_STATUS_READ_ECC |          \
-                                             DMA_STATUS_SYSTEM_WRITE_ECC |  \
-                                             DMA_STATUS_FM_WRITE_ECC |      \
-                                             DMA_STATUS_SYSTEM_DPEXT_ECC |  \
-                                             DMA_STATUS_FM_DPEXT_ECC |      \
-                                             DMA_STATUS_SYSTEM_DPDAT_ECC |  \
-                                             DMA_STATUS_FM_DPDAT_ECC |      \
-                                             DMA_STATUS_FM_SPDAT_ECC)
-
-#define FM_LIODN_BASE_MASK                  0x00000FFF
-
-#define DMA_EMSR_EMSTR_MASK                 0x0000FFFF
-
-#define DMA_THRESH_COMMQ_MASK               0xFF000000
-#define DMA_THRESH_READ_INT_BUF_MASK        0x007F0000
-#define DMA_THRESH_WRITE_INT_BUF_MASK       0x0000007F
-
-/* shifts */
-#define DMA_MODE_CACHE_OR_SHIFT             30
-#define DMA_MODE_BUS_PRI_SHIFT              16
-#define DMA_MODE_AXI_DBG_SHIFT              24
-#define DMA_MODE_CEN_SHIFT                  13
-#define DMA_MODE_BUS_PROT_SHIFT             10
-#define DMA_MODE_DBG_SHIFT                  7
-#define DMA_MODE_EMERGENCY_LEVEL_SHIFT      6
-#define DMA_MODE_AID_MODE_SHIFT             4
-#define DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS   16
-#define DMA_MODE_MAX_CAM_NUM_OF_ENTRIES     64
-
-#define DMA_THRESH_COMMQ_SHIFT              24
-#define DMA_THRESH_READ_INT_BUF_SHIFT       16
-
-#define DMA_LIODN_SHIFT                     16
-
-#define DMA_TRANSFER_PORTID_SHIFT           24
-#define DMA_TRANSFER_TNUM_SHIFT             16
-
-/* sizes */
-#define DMA_MAX_WATCHDOG                    0xffffffff
-
-/* others */
-#define DMA_CAM_SIZEOF_ENTRY                0x40
-#define DMA_CAM_ALIGN                       0x1000
-#define DMA_CAM_UNITS                       8
-
-
-/**************************************************************************//**
  @Description       FPM defines
 *//***************************************************************************/
 /* masks */
-#define FPM_EV_MASK_DOUBLE_ECC          0x80000000
-#define FPM_EV_MASK_STALL               0x40000000
-#define FPM_EV_MASK_SINGLE_ECC          0x20000000
-#define FPM_EV_MASK_RELEASE_FM          0x00010000
-#define FPM_EV_MASK_DOUBLE_ECC_EN       0x00008000
-#define FPM_EV_MASK_STALL_EN            0x00004000
-#define FPM_EV_MASK_SINGLE_ECC_EN       0x00002000
-#define FPM_EV_MASK_EXTERNAL_HALT       0x00000008
-#define FPM_EV_MASK_ECC_ERR_HALT        0x00000004
-
-#define FPM_RAM_CTL_RAMS_ECC_EN         0x80000000
-#define FPM_RAM_CTL_IRAM_ECC_EN         0x40000000
-#define FPM_RAM_CTL_MURAM_ECC           0x00008000
-#define FPM_RAM_CTL_IRAM_ECC            0x00004000
-#define FPM_RAM_CTL_MURAM_TEST_ECC      0x20000000
-#define FPM_RAM_CTL_IRAM_TEST_ECC       0x10000000
-#define FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL 0x08000000
-
-#define FPM_IRAM_ECC_ERR_EX_EN          0x00020000
-#define FPM_MURAM_ECC_ERR_EX_EN         0x00040000
-
-#define FPM_REV1_MAJOR_MASK             0x0000FF00
-#define FPM_REV1_MINOR_MASK             0x000000FF
-
-#define FPM_REV2_INTEG_MASK             0x00FF0000
-#define FPM_REV2_ERR_MASK               0x0000FF00
-#define FPM_REV2_CFG_MASK               0x000000FF
-
-#define FPM_TS_FRACTION_MASK            0x0000FFFF
-#define FPM_TS_CTL_EN                   0x80000000
-
-#define FPM_PRC_REALSE_STALLED          0x00800000
-
-#define FPM_PS_STALLED                  0x00800000
-#define FPM_PS_FM_CTL1_SEL              0x80000000
-#define FPM_PS_FM_CTL2_SEL              0x40000000
-#define FPM_PS_FM_CTL_SEL_MASK          (FPM_PS_FM_CTL1_SEL | FPM_PS_FM_CTL2_SEL)
-
-#define FPM_RSTC_FM_RESET               0x80000000
-#define FPM_RSTC_1G0_RESET              0x40000000
-#define FPM_RSTC_1G1_RESET              0x20000000
-#define FPM_RSTC_1G2_RESET              0x10000000
-#define FPM_RSTC_1G3_RESET              0x08000000
-#define FPM_RSTC_10G0_RESET             0x04000000
-#define FPM_RSTC_1G4_RESET              0x02000000
-#define FPM_RSTC_1G5_RESET              0x01000000
-#define FPM_RSTC_1G6_RESET              0x00800000
-#define FPM_RSTC_1G7_RESET              0x00400000
-#define FPM_RSTC_10G1_RESET             0x00200000
-
-
-#define FPM_DISP_LIMIT_MASK             0x1F000000
-#define FPM_THR1_PRS_MASK               0xFF000000
-#define FPM_THR1_KG_MASK                0x00FF0000
-#define FPM_THR1_PLCR_MASK              0x0000FF00
-#define FPM_THR1_BMI_MASK               0x000000FF
-
-#define FPM_THR2_QMI_ENQ_MASK           0xFF000000
-#define FPM_THR2_QMI_DEQ_MASK           0x000000FF
-#define FPM_THR2_FM_CTL1_MASK           0x00FF0000
-#define FPM_THR2_FM_CTL2_MASK           0x0000FF00
-
 #define FPM_BRKC_RDBG                   0x00000200
-
-/* shifts */
-#define FPM_DISP_LIMIT_SHIFT            24
-
-#define FPM_THR1_PRS_SHIFT              24
-#define FPM_THR1_KG_SHIFT               16
-#define FPM_THR1_PLCR_SHIFT             8
-#define FPM_THR1_BMI_SHIFT              0
-
-#define FPM_THR2_QMI_ENQ_SHIFT          24
-#define FPM_THR2_QMI_DEQ_SHIFT          0
-#define FPM_THR2_FM_CTL1_SHIFT          16
-#define FPM_THR2_FM_CTL2_SHIFT          8
-
-#define FPM_EV_MASK_CAT_ERR_SHIFT       1
-#define FPM_EV_MASK_DMA_ERR_SHIFT       0
-
-#define FPM_REV1_MAJOR_SHIFT            8
-#define FPM_REV1_MINOR_SHIFT            0
-
-#define FPM_REV2_INTEG_SHIFT            16
-#define FPM_REV2_ERR_SHIFT              8
-#define FPM_REV2_CFG_SHIFT              0
-
-#define FPM_TS_INT_SHIFT                16
-
-#define FPM_PORT_FM_CTL_PORTID_SHIFT      24
-
-#define FPM_PS_FM_CTL_SEL_SHIFT           30
-#define FPM_PRC_ORA_FM_CTL_SEL_SHIFT      16
-
-/* Interrupts defines */
-#define FPM_EVENT_FM_CTL_0                0x00008000
-#define FPM_EVENT_FM_CTL                  0x0000FF00
-#define FPM_EVENT_FM_CTL_BRK              0x00000080
-
-/* others */
-#define FPM_MAX_DISP_LIMIT              31
-
 /**************************************************************************//**
  @Description       BMI defines
 *//***************************************************************************/
@@ -710,52 +531,14 @@ typedef _Packed struct t_FmTrbRegs
 #define BMI_ERR_INTR_EN_LIST_RAM_ECC        0x40000000
 #define BMI_ERR_INTR_EN_STATISTICS_RAM_ECC  0x20000000
 #define BMI_ERR_INTR_EN_DISPATCH_RAM_ECC    0x10000000
-
-#define BMI_NUM_OF_TASKS_MASK               0x3F000000 /* port */
-#define BMI_NUM_OF_EXTRA_TASKS_MASK         0x000F0000
-#define BMI_NUM_OF_DMAS_MASK                0x00000F00
-#define BMI_NUM_OF_EXTRA_DMAS_MASK          0x0000000F
-#define BMI_FIFO_SIZE_MASK                  0x000003FF /* port */
-#define BMI_EXTRA_FIFO_SIZE_MASK            0x03FF0000
-#define BMI_CFG2_DMAS_MASK                  0x0000003F
-
-#define BMI_TOTAL_FIFO_SIZE_MASK           0x07FF0000
-#define BMI_TOTAL_NUM_OF_TASKS_MASK        0x007F0000
-/* shifts */
-#define BMI_CFG2_TASKS_SHIFT            16
-#define BMI_CFG2_DMAS_SHIFT             0
-#define BMI_CFG1_FIFO_SIZE_SHIFT        16
-#define BMI_FIFO_SIZE_SHIFT             0
-#define BMI_EXTRA_FIFO_SIZE_SHIFT       16
-#define BMI_NUM_OF_TASKS_SHIFT          24
-#define BMI_EXTRA_NUM_OF_TASKS_SHIFT    16
-#define BMI_NUM_OF_DMAS_SHIFT           8
-#define BMI_EXTRA_NUM_OF_DMAS_SHIFT     0
-
-/* others */
-#define BMI_FIFO_ALIGN                  0x100
-
 /**************************************************************************//**
  @Description       QMI defines
 *//***************************************************************************/
 /* masks */
-#define QMI_CFG_ENQ_EN                  0x80000000
-#define QMI_CFG_DEQ_EN                  0x40000000
-#define QMI_CFG_EN_COUNTERS             0x10000000
-#define QMI_CFG_SOFT_RESET              0x01000000
-#define QMI_CFG_DEQ_MASK                0x0000003F
-#define QMI_CFG_ENQ_MASK                0x00003F00
-
-#define QMI_GS_HALT_NOT_BUSY            0x00000002
-
 #define QMI_ERR_INTR_EN_DOUBLE_ECC      0x80000000
 #define QMI_ERR_INTR_EN_DEQ_FROM_DEF    0x40000000
 #define QMI_INTR_EN_SINGLE_ECC          0x80000000
 
-/* shifts */
-#define QMI_CFG_ENQ_SHIFT               8
-#define QMI_TAPC_TAP                    22
-
 /**************************************************************************//**
  @Description       IRAM defines
 *//***************************************************************************/
@@ -772,44 +555,11 @@ typedef _Packed struct t_FmTrbRegs
 #define TRB_TCRH_DISABLE_COUNTERS   0x8400C000
 #define TRB_TCRL_RESET              0x20000000
 #define TRB_TCRL_UTIL               0x00000460
-
 typedef struct {
     void        (*f_Isr) (t_Handle h_Arg, uint32_t event);
     t_Handle    h_SrcHandle;
 } t_FmanCtrlIntrSrc;
 
-typedef struct
-{
- /*   uint8_t                     numOfPartitions; */
-    bool                        resetOnInit;
-    t_FmThresholds              thresholds;
-    e_FmDmaCacheOverride        dmaCacheOverride;
-    e_FmDmaAidMode              dmaAidMode;
-    bool                        dmaAidOverride;
-    uint8_t                     dmaAxiDbgNumOfBeats;
-    uint8_t                     dmaCamNumOfEntries;
-    uint32_t                    dmaWatchdog;
-    t_FmDmaThresholds           dmaCommQThresholds;
-    t_FmDmaThresholds           dmaWriteBufThresholds;
-    t_FmDmaThresholds           dmaReadBufThresholds;
-    uint32_t                    dmaSosEmergency;
-    e_FmDmaDbgCntMode           dmaDbgCntMode;
-    bool                        dmaStopOnBusError;
-    bool                        dmaEnEmergency;
-    t_FmDmaEmergency            dmaEmergency;
-    bool                        dmaEnEmergencySmoother;
-    uint32_t                    dmaEmergencySwitchCounter;
-    bool                        haltOnExternalActivation;
-    bool                        haltOnUnrecoverableEccError;
-    e_FmCatastrophicErr         catastrophicErr;
-    e_FmDmaErr                  dmaErr;
-    bool                        enMuramTestMode;
-    bool                        enIramTestMode;
-    bool                        externalEccRamsEnable;
-    t_FmFirmwareParams          firmware;
-    bool                        fwVerify;
-    uint32_t                    userSetExceptions;
-} t_FmDriverParam;
 
 typedef void (t_FmanCtrlIsr)( t_Handle h_Fm, uint32_t event);
 
@@ -817,6 +567,7 @@ typedef struct
 {
 /***************************/
 /* Master/Guest parameters */
+/***************************/
     uint8_t                     fmId;
     e_FmPortType                portsTypes[FM_MAX_NUM_OF_HW_PORT_IDS];
     uint16_t                    fmClkFreq;
@@ -877,10 +628,8 @@ typedef struct t_FmSp {
     t_FmPcdSpEntry  profiles[FM_VSP_MAX_NUM_OF_ENTRIES];
     t_FmMapParam    portsMapping[FM_MAX_NUM_OF_PORTS];
 } t_FmSp;
-
 #endif /* (DPAA_VERSION >= 11) */
 
-
 typedef struct t_Fm
 {
 /***************************/
@@ -900,10 +649,11 @@ typedef struct t_Fm
 /* Master Only parameters */
 /**************************/
 /* locals for recovery */
-    t_FmFpmRegs                 *p_FmFpmRegs;
-    t_FmBmiRegs                 *p_FmBmiRegs;
-    t_FmQmiRegs                 *p_FmQmiRegs;
-    t_FmDmaRegs                 *p_FmDmaRegs;
+    struct fman_fpm_regs *p_FmFpmRegs;
+    struct fman_bmi_regs *p_FmBmiRegs;
+    struct fman_qmi_regs *p_FmQmiRegs;
+    struct fman_dma_regs *p_FmDmaRegs;
+    struct fman_regs            *p_FmRegs;
     t_FmExceptionsCallback      *f_Exception;
     t_FmBusErrorCallback        *f_BusError;
     t_Handle                    h_App;                          /* Application handle */
@@ -918,9 +668,10 @@ typedef struct t_Fm
     uintptr_t                   vspBaseAddr;
 #endif /* (DPAA_VERSION >= 11) */
     bool                        portsPreFetchConfigured[FM_MAX_NUM_OF_HW_PORT_IDS]; /* Prefetch configration per Tx-port */
-    bool                        portsPreFetchValue[FM_MAX_NUM_OF_HW_PORT_IDS];      /* Prefetch value per Tx-port */
+    bool                        portsPreFetchValue[FM_MAX_NUM_OF_HW_PORT_IDS];      /* Prefetch configration per Tx-port */
 
 /* un-needed for recovery */
+    struct fman_cfg             *p_FmDriverParam;
     t_Handle                    h_FmMuram;
     uint64_t                    fmMuramPhysBaseAddr;
     bool                        independentMode;
@@ -930,8 +681,10 @@ typedef struct t_Fm
     uintptr_t                   fifoBaseAddr;                   /* save for freeing */
     t_FmanCtrlIntrSrc           fmanCtrlIntr[FM_NUM_OF_FMAN_CTRL_EVENT_REGS];    /* FM exceptions user callback */
     bool                        usedEventRegs[FM_NUM_OF_FMAN_CTRL_EVENT_REGS];
-
-    t_FmDriverParam             *p_FmDriverParam;
+    t_FmFirmwareParams          firmware;
+    bool                        fwVerify;
+    bool                        resetOnInit;
+    uint32_t                    userSetExceptions;
 } t_Fm;
 
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
new file mode 100755
index 0000000..996841c
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
@@ -0,0 +1,1365 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+
+#include "fsl_fman.h"
+#include "dpaa_integration_ext.h"
+
+uint32_t fman_get_bmi_err_event(struct fman_bmi_regs *bmi_rg)
+{
+	uint32_t	event, mask, force;
+
+	event = ioread32be(&bmi_rg->fmbm_ievr);
+	mask = ioread32be(&bmi_rg->fmbm_ier);
+	event &= mask;
+	/* clear the forced events */
+	force = ioread32be(&bmi_rg->fmbm_ifr);
+	if (force & event)
+		iowrite32be(force & ~event, &bmi_rg->fmbm_ifr);
+	/* clear the acknowledged events */
+	iowrite32be(event, &bmi_rg->fmbm_ievr);
+	return event;
+}
+
+uint32_t fman_get_qmi_err_event(struct fman_qmi_regs *qmi_rg)
+{
+	uint32_t	event, mask, force;
+
+	event = ioread32be(&qmi_rg->fmqm_eie);
+	mask = ioread32be(&qmi_rg->fmqm_eien);
+	event &= mask;
+
+	/* clear the forced events */
+	force = ioread32be(&qmi_rg->fmqm_eif);
+	if (force & event)
+		iowrite32be(force & ~event, &qmi_rg->fmqm_eif);
+	/* clear the acknowledged events */
+	iowrite32be(event, &qmi_rg->fmqm_eie);
+	return event;
+}
+
+uint32_t fman_get_dma_com_id(struct fman_dma_regs *dma_rg)
+{
+	return ioread32be(&dma_rg->fmdmtcid);
+}
+
+uint64_t fman_get_dma_addr(struct fman_dma_regs *dma_rg)
+{
+	uint64_t addr;
+
+	addr = (uint64_t)ioread32be(&dma_rg->fmdmtal);
+	addr |= ((uint64_t)(ioread32be(&dma_rg->fmdmtah)) << 32);
+
+	return addr;
+}
+
+uint32_t fman_get_dma_err_event(struct fman_dma_regs *dma_rg)
+{
+	uint32_t status, mask;
+
+	status = ioread32be(&dma_rg->fmdmsr);
+	mask = ioread32be(&dma_rg->fmdmmr);
+
+	/* clear DMA_STATUS_BUS_ERR if mask has no DMA_MODE_BER */
+	if ((mask & DMA_MODE_BER) != DMA_MODE_BER)
+		status &= ~DMA_STATUS_BUS_ERR;
+
+	/* clear relevant bits if mask has no DMA_MODE_ECC */
+	if ((mask & DMA_MODE_ECC) != DMA_MODE_ECC)
+		status &= ~(DMA_STATUS_FM_SPDAT_ECC |
+		        DMA_STATUS_READ_ECC |
+				DMA_STATUS_SYSTEM_WRITE_ECC |
+				DMA_STATUS_FM_WRITE_ECC);
+
+	/* clear set events */
+	iowrite32be(status, &dma_rg->fmdmsr);
+
+	return status;
+}
+
+uint32_t fman_get_fpm_err_event(struct fman_fpm_regs *fpm_rg)
+{
+	uint32_t	event;
+
+	event = ioread32be(&fpm_rg->fmfp_ee);
+	/* clear the all occurred events */
+	iowrite32be(event, &fpm_rg->fmfp_ee);
+	return event;
+}
+
+uint32_t fman_get_muram_err_event(struct fman_fpm_regs *fpm_rg)
+{
+	uint32_t	event, mask;
+
+	event = ioread32be(&fpm_rg->fm_rcr);
+	mask = ioread32be(&fpm_rg->fm_rie);
+
+	/* clear MURAM event bit (do not clear IRAM event) */
+	iowrite32be(event & ~FPM_RAM_IRAM_ECC, &fpm_rg->fm_rcr);
+
+	if ((mask & FPM_MURAM_ECC_ERR_EX_EN))
+		return event;
+	else
+		return 0;
+}
+
+uint32_t fman_get_iram_err_event(struct fman_fpm_regs *fpm_rg)
+{
+	uint32_t    event, mask;
+
+	event = ioread32be(&fpm_rg->fm_rcr) ;
+	mask = ioread32be(&fpm_rg->fm_rie);
+	/* clear IRAM event bit (do not clear MURAM event) */
+	iowrite32be(event & ~FPM_RAM_MURAM_ECC,
+			&fpm_rg->fm_rcr);
+
+	if ((mask & FPM_IRAM_ECC_ERR_EX_EN))
+		return event;
+	else
+		return 0;
+}
+
+uint32_t fman_get_qmi_event(struct fman_qmi_regs *qmi_rg)
+{
+	uint32_t	event, mask, force;
+
+	event = ioread32be(&qmi_rg->fmqm_ie);
+	mask = ioread32be(&qmi_rg->fmqm_ien);
+	event &= mask;
+	/* clear the forced events */
+	force = ioread32be(&qmi_rg->fmqm_if);
+	if (force & event)
+		iowrite32be(force & ~event, &qmi_rg->fmqm_if);
+	/* clear the acknowledged events */
+	iowrite32be(event, &qmi_rg->fmqm_ie);
+	return event;
+}
+
+void fman_enable_time_stamp(struct fman_fpm_regs *fpm_rg,
+				uint8_t count1ubit,
+				uint16_t fm_clk_freq)
+{
+	uint32_t tmp;
+	uint64_t frac;
+	uint32_t intgr;
+	uint32_t ts_freq = (uint32_t)(1 << count1ubit); /* in Mhz */
+
+	/* configure timestamp so that bit 8 will count 1 microsecond
+	 * Find effective count rate at TIMESTAMP least significant bits:
+	 * Effective_Count_Rate = 1MHz x 2^8 = 256MHz
+	 * Find frequency ratio between effective count rate and the clock:
+	 * Effective_Count_Rate / CLK e.g. for 600 MHz clock:
+	 * 256/600 = 0.4266666... */
+
+	intgr = ts_freq / fm_clk_freq;
+	/* we multiply by 2^16 to keep the fraction of the division
+	 * we do not div back, since we write this value as a fraction
+	 * see spec */
+
+	frac = ((ts_freq << 16) - (intgr << 16) * fm_clk_freq) / fm_clk_freq;
+	/* we check remainder of the division in order to round up if not int */
+	if (((ts_freq << 16) - (intgr << 16)*fm_clk_freq) % fm_clk_freq)
+		frac++;
+
+	tmp = (intgr << FPM_TS_INT_SHIFT) | (uint16_t)frac;
+	iowrite32be(tmp, &fpm_rg->fmfp_tsc2);
+
+	/* enable timestamp with original clock */
+	iowrite32be(FPM_TS_CTL_EN, &fpm_rg->fmfp_tsc1);
+}
+
+uint32_t fman_get_fpm_error_interrupts(struct fman_fpm_regs *fpm_rg)
+{
+	return ioread32be(&fpm_rg->fm_epi);
+}
+
+
+int fman_set_erratum_10gmac_a004_wa(struct fman_fpm_regs *fpm_rg)
+{
+	int timeout = 100;
+
+	iowrite32be(0x40000000, &fpm_rg->fmfp_extc);
+
+	while ((ioread32be(&fpm_rg->fmfp_extc) & 0x40000000) && --timeout)
+		udelay(10);
+
+	if (!timeout)
+		return -EBUSY;
+	return 0;
+}
+
+void fman_set_ctrl_intr(struct fman_fpm_regs *fpm_rg,
+			uint8_t event_reg_id,
+			uint32_t enable_events)
+{
+	iowrite32be(enable_events, &fpm_rg->fmfp_cee[event_reg_id]);
+}
+
+uint32_t fman_get_ctrl_intr(struct fman_fpm_regs *fpm_rg, uint8_t event_reg_id)
+{
+	return ioread32be(&fpm_rg->fmfp_cee[event_reg_id]);
+}
+
+void fman_set_num_of_riscs_per_port(struct fman_fpm_regs *fpm_rg,
+					uint8_t port_id,
+					uint8_t num_fman_ctrls,
+					uint32_t or_fman_ctrl)
+{
+	uint32_t tmp = 0;
+
+	tmp = (uint32_t)(port_id << FPM_PORT_FM_CTL_PORTID_SHIFT);
+	/*TODO - maybe to put CTL# according to another criteria*/
+	if (num_fman_ctrls == 2)
+		tmp = FPM_PRT_FM_CTL2 | FPM_PRT_FM_CTL1;
+	/* order restoration */
+	tmp |= (or_fman_ctrl << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | or_fman_ctrl;
+
+	iowrite32be(tmp, &fpm_rg->fmfp_prc);
+}
+
+void fman_set_order_restoration_per_port(struct fman_fpm_regs *fpm_rg,
+					uint8_t port_id,
+					bool independent_mode,
+					bool is_rx_port)
+{
+	uint32_t tmp = 0;
+
+	tmp = (uint32_t)(port_id << FPM_PORT_FM_CTL_PORTID_SHIFT);
+	if (independent_mode) {
+		if (is_rx_port)
+			tmp |= (FPM_PRT_FM_CTL1 <<
+				FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | FPM_PRT_FM_CTL1;
+		else
+			tmp |= (FPM_PRT_FM_CTL2 <<
+				FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | FPM_PRT_FM_CTL2;
+	} else {
+		tmp |= (FPM_PRT_FM_CTL2|FPM_PRT_FM_CTL1);
+
+		/* order restoration */
+		if (port_id % 2)
+			tmp |= (FPM_PRT_FM_CTL1 <<
+					FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+		else
+			tmp |= (FPM_PRT_FM_CTL2 <<
+					FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+	}
+	iowrite32be(tmp, &fpm_rg->fmfp_prc);
+}
+
+uint8_t fman_get_qmi_deq_th(struct fman_qmi_regs *qmi_rg)
+{
+	return (uint8_t)ioread32be(&qmi_rg->fmqm_gc);
+}
+
+uint8_t fman_get_qmi_enq_th(struct fman_qmi_regs *qmi_rg)
+{
+	return (uint8_t)(ioread32be(&qmi_rg->fmqm_gc) >> 8);
+}
+
+void fman_set_qmi_enq_th(struct fman_qmi_regs *qmi_rg, uint8_t val)
+{
+	uint32_t tmp_reg;
+
+	tmp_reg = ioread32be(&qmi_rg->fmqm_gc);
+	tmp_reg &= ~QMI_CFG_ENQ_MASK;
+	tmp_reg |= ((uint32_t)val << 8);
+	iowrite32be(tmp_reg, &qmi_rg->fmqm_gc);
+}
+
+void fman_set_qmi_deq_th(struct fman_qmi_regs *qmi_rg, uint8_t val)
+{
+	uint32_t tmp_reg;
+
+	tmp_reg = ioread32be(&qmi_rg->fmqm_gc);
+	tmp_reg &= ~QMI_CFG_DEQ_MASK;
+	tmp_reg |= (uint32_t)val;
+	iowrite32be(tmp_reg, &qmi_rg->fmqm_gc);
+}
+
+void fman_qmi_disable_dispatch_limit(struct fman_fpm_regs *fpm_rg)
+{
+	iowrite32be(0, &fpm_rg->fmfp_mxd);
+}
+
+void fman_set_liodn_per_port(struct fman_rg *fman_rg, uint8_t port_id,
+				uint16_t liodn_base,
+				uint16_t liodn_ofst)
+{
+	uint32_t tmp;
+
+	/* set LIODN base for this port */
+	tmp = ioread32be(&fman_rg->dma_rg->fmdmplr[port_id / 2]);
+	if (port_id % 2) {
+		tmp &= ~FM_LIODN_BASE_MASK;
+		tmp |= (uint32_t)liodn_base;
+	} else {
+		tmp &= ~(FM_LIODN_BASE_MASK << DMA_LIODN_SHIFT);
+		tmp |= (uint32_t)liodn_base << DMA_LIODN_SHIFT;
+	}
+	iowrite32be(tmp, &fman_rg->dma_rg->fmdmplr[port_id / 2]);
+	iowrite32be((uint32_t)liodn_ofst,
+			&fman_rg->bmi_rg->fmbm_spliodn[port_id - 1]);
+}
+
+bool fman_is_port_stalled(struct fman_fpm_regs *fpm_rg, uint8_t port_id)
+{
+	return (bool)!!(ioread32be(&fpm_rg->fmfp_ps[port_id]) & FPM_PS_STALLED);
+}
+
+void fman_resume_stalled_port(struct fman_fpm_regs *fpm_rg, uint8_t port_id)
+{
+	uint32_t	tmp;
+
+	tmp = (uint32_t)((port_id << FPM_PORT_FM_CTL_PORTID_SHIFT) |
+				FPM_PRC_REALSE_STALLED);
+	iowrite32be(tmp, &fpm_rg->fmfp_prc);
+}
+
+int fman_reset_mac(struct fman_fpm_regs *fpm_rg, uint8_t mac_id, bool is_10g)
+{
+	uint32_t msk, timeout = 100;
+
+	/* Get the relevant bit mask */
+	if (is_10g) {
+		switch (mac_id) {
+		case(0):
+			msk = FPM_RSTC_10G0_RESET;
+			break;
+        case(1):
+            msk = FPM_RSTC_10G1_RESET;
+            break;
+		default:
+			return -EINVAL;
+		}
+	} else {
+		switch (mac_id) {
+		case(0):
+			msk = FPM_RSTC_1G0_RESET;
+			break;
+		case(1):
+			msk = FPM_RSTC_1G1_RESET;
+			break;
+		case(2):
+			msk = FPM_RSTC_1G2_RESET;
+			break;
+		case(3):
+			msk = FPM_RSTC_1G3_RESET;
+			break;
+		case(4):
+			msk = FPM_RSTC_1G4_RESET;
+			break;
+        case (5):
+            msk = FPM_RSTC_1G5_RESET;
+            break;
+        case (6):
+            msk = FPM_RSTC_1G6_RESET;
+            break;
+        case (7):
+            msk = FPM_RSTC_1G7_RESET;
+            break;
+		default:
+			return -EINVAL;
+		}
+	}
+	/* reset */
+	iowrite32be(msk, &fpm_rg->fm_rstc);
+	while ((ioread32be(&fpm_rg->fm_rstc) & msk) && --timeout)
+		udelay(10);
+
+	if (!timeout)
+		return -EBUSY;
+	return 0;
+}
+
+uint16_t fman_get_size_of_fifo(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
+{
+	uint32_t tmp_reg;
+
+	tmp_reg = ioread32be(&bmi_rg->fmbm_pfs[port_id - 1]);
+	return (uint16_t)((tmp_reg & BMI_FIFO_SIZE_MASK) + 1);
+}
+
+uint32_t fman_get_total_fifo_size(struct fman_bmi_regs *bmi_rg)
+{
+	uint32_t reg, res;
+
+	reg = ioread32be(&bmi_rg->fmbm_cfg1);
+	res = (reg >> BMI_CFG1_FIFO_SIZE_SHIFT) & 0x3ff;
+	return res * FMAN_BMI_FIFO_UNITS;
+}
+
+uint16_t fman_get_size_of_extra_fifo(struct fman_bmi_regs *bmi_rg,
+					uint8_t port_id)
+{
+	uint32_t tmp_reg;
+
+	tmp_reg = ioread32be(&bmi_rg->fmbm_pfs[port_id-1]);
+	return (uint16_t)((tmp_reg & BMI_EXTRA_FIFO_SIZE_MASK) >>
+				BMI_EXTRA_FIFO_SIZE_SHIFT);
+}
+
+void fman_set_size_of_fifo(struct fman_bmi_regs *bmi_rg,
+				uint8_t port_id,
+				uint32_t sz_fifo,
+				uint32_t extra_sz_fifo)
+{
+	uint32_t tmp;
+
+	/* calculate reg */
+	tmp = (uint32_t)((sz_fifo / FMAN_BMI_FIFO_UNITS - 1) |
+		((extra_sz_fifo / FMAN_BMI_FIFO_UNITS) <<
+				BMI_EXTRA_FIFO_SIZE_SHIFT));
+	iowrite32be(tmp, &bmi_rg->fmbm_pfs[port_id - 1]);
+}
+
+uint8_t fman_get_num_of_tasks(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]);
+	return (uint8_t)(((tmp & BMI_NUM_OF_TASKS_MASK) >>
+				BMI_NUM_OF_TASKS_SHIFT) + 1);
+}
+
+uint8_t fman_get_num_extra_tasks(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]);
+	return (uint8_t)((tmp & BMI_NUM_OF_EXTRA_TASKS_MASK) >>
+				BMI_EXTRA_NUM_OF_TASKS_SHIFT);
+}
+
+void fman_set_num_of_tasks(struct fman_bmi_regs *bmi_rg,
+				uint8_t port_id,
+				uint8_t num_tasks,
+				uint8_t num_extra_tasks)
+{
+	uint32_t tmp;
+
+	/* calculate reg */
+	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]) &
+			~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
+	tmp |= (uint32_t)(((num_tasks - 1) << BMI_NUM_OF_TASKS_SHIFT) |
+			(num_extra_tasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
+	iowrite32be(tmp, &bmi_rg->fmbm_pp[port_id - 1]);
+}
+
+uint8_t fman_get_num_of_dmas(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]);
+	return (uint8_t)(((tmp & BMI_NUM_OF_DMAS_MASK) >>
+			BMI_NUM_OF_DMAS_SHIFT) + 1);
+}
+
+uint8_t fman_get_num_extra_dmas(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]);
+	return (uint8_t)((tmp & BMI_NUM_OF_EXTRA_DMAS_MASK) >>
+			BMI_EXTRA_NUM_OF_DMAS_SHIFT);
+}
+
+void fman_set_num_of_open_dmas(struct fman_bmi_regs *bmi_rg,
+				uint8_t port_id,
+				uint8_t num_open_dmas,
+				uint8_t num_extra_open_dmas,
+				uint8_t total_num_dmas)
+{
+	uint32_t tmp = 0;
+	/* calculate reg */
+	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]) &
+			~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
+	tmp |= (uint32_t)(((num_open_dmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
+			(num_extra_open_dmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
+	iowrite32be(tmp, &bmi_rg->fmbm_pp[port_id - 1]);
+
+	/* update total num of DMA's with committed number of open DMAS,
+	 * and max uncommitted pool. */
+    if (total_num_dmas)
+    {
+        tmp = ioread32be(&bmi_rg->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
+        tmp |= (uint32_t)(total_num_dmas - 1) << BMI_CFG2_DMAS_SHIFT;
+        iowrite32be(tmp, &bmi_rg->fmbm_cfg2);
+    }
+}
+
+void fman_set_vsp_window(struct fman_bmi_regs *bmi_rg,
+			    	     uint8_t port_id,
+				         uint8_t base_storage_profile,
+				         uint8_t log2_num_of_profiles)
+{
+	uint32_t tmp = 0;
+
+    tmp = ioread32be(&bmi_rg->fmbm_spliodn[port_id-1]);
+    tmp |= (uint32_t)((uint32_t)base_storage_profile & 0x3f) << 16;
+    tmp |= (uint32_t)log2_num_of_profiles << 28;
+    iowrite32be(tmp, &bmi_rg->fmbm_spliodn[port_id-1]);
+}
+void fman_set_congestion_group_pfc_priority(uint32_t *cpg_rg,
+			    	                        uint32_t congestion_group_id,
+				                            uint8_t priority_bit_map)
+{
+	uint32_t reg_num, offset, tmp = 0;
+ 
+    reg_num = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-congestion_group_id)/4;
+    offset  = (congestion_group_id%4)*8;
+
+    tmp = ioread32be(&cpg_rg[reg_num]);
+    tmp &= ~(0xFF<<offset);
+    tmp |= (uint32_t)priority_bit_map << offset;
+ 
+    iowrite32be(tmp,&cpg_rg[reg_num]);
+}
+
+/*****************************************************************************/
+/*                      API Init unit functions                              */
+/*****************************************************************************/
+void fman_defconfig(struct fman_cfg *cfg, bool is_master)
+{
+    memset(cfg, 0, sizeof(struct fman_cfg));
+
+    cfg->catastrophic_err               = DEFAULT_CATASTROPHIC_ERR;
+    cfg->dma_err                        = DEFAULT_DMA_ERR;
+    cfg->halt_on_external_activ         = DEFAULT_HALT_ON_EXTERNAL_ACTIVATION;
+    cfg->halt_on_unrecov_ecc_err        = DEFAULT_HALT_ON_UNRECOVERABLE_ECC_ERROR;
+    cfg->en_iram_test_mode              = FALSE;
+    cfg->en_muram_test_mode             = FALSE;
+    cfg->external_ecc_rams_enable       = DEFAULT_EXTERNAL_ECC_RAMS_ENABLE;
+
+	if (!is_master)
+	    return;
+
+    cfg->dma_aid_override               = DEFAULT_AID_OVERRIDE;
+    cfg->dma_aid_mode                   = DEFAULT_AID_MODE;
+    cfg->dma_comm_qtsh_clr_emer         = DEFAULT_DMA_COMM_Q_LOW;
+    cfg->dma_comm_qtsh_asrt_emer        = DEFAULT_DMA_COMM_Q_HIGH;
+    cfg->dma_cache_override             = DEFAULT_CACHE_OVERRIDE;
+    cfg->dma_cam_num_of_entries         = DEFAULT_DMA_CAM_NUM_OF_ENTRIES;
+    cfg->dma_dbg_cnt_mode               = DEFAULT_DMA_DBG_CNT_MODE;
+    cfg->dma_en_emergency               = DEFAULT_DMA_EN_EMERGENCY;
+    cfg->dma_sos_emergency              = DEFAULT_DMA_SOS_EMERGENCY;
+    cfg->dma_watchdog                   = DEFAULT_DMA_WATCHDOG;
+    cfg->dma_en_emergency_smoother      = DEFAULT_DMA_EN_EMERGENCY_SMOOTHER;
+    cfg->dma_emergency_switch_counter   = DEFAULT_DMA_EMERGENCY_SWITCH_COUNTER;
+    cfg->disp_limit_tsh                 = DEFAULT_DISP_LIMIT;
+    cfg->prs_disp_tsh                   = DEFAULT_PRS_DISP_TH;
+    cfg->plcr_disp_tsh                  = DEFAULT_PLCR_DISP_TH;
+    cfg->kg_disp_tsh                    = DEFAULT_KG_DISP_TH;
+    cfg->bmi_disp_tsh                   = DEFAULT_BMI_DISP_TH;
+    cfg->qmi_enq_disp_tsh               = DEFAULT_QMI_ENQ_DISP_TH;
+    cfg->qmi_deq_disp_tsh               = DEFAULT_QMI_DEQ_DISP_TH;
+    cfg->fm_ctl1_disp_tsh               = DEFAULT_FM_CTL1_DISP_TH;
+    cfg->fm_ctl2_disp_tsh               = DEFAULT_FM_CTL2_DISP_TH;
+ 
+	cfg->pedantic_dma                   = FALSE;
+	cfg->tnum_aging_period              = DEFAULT_TNUM_AGING_PERIOD;
+	cfg->dma_stop_on_bus_error          = FALSE;
+	cfg->qmi_deq_option_support         = FALSE;
+}
+
+void fman_regconfig(struct fman_rg *fman_rg, struct fman_cfg *cfg)
+{
+	uint32_t tmp_reg;
+
+    /* read the values from the registers as they are initialized by the HW with
+     * the required values.
+     */
+    tmp_reg = ioread32be(&fman_rg->bmi_rg->fmbm_cfg1);
+    cfg->total_fifo_size =
+        (((tmp_reg & BMI_TOTAL_FIFO_SIZE_MASK) >> BMI_CFG1_FIFO_SIZE_SHIFT) + 1) * FMAN_BMI_FIFO_UNITS;
+
+    tmp_reg = ioread32be(&fman_rg->bmi_rg->fmbm_cfg2);
+    cfg->total_num_of_tasks =
+        (uint8_t)(((tmp_reg & BMI_TOTAL_NUM_OF_TASKS_MASK) >> BMI_CFG2_TASKS_SHIFT) + 1);
+
+    tmp_reg = ioread32be(&fman_rg->dma_rg->fmdmtr);
+    cfg->dma_comm_qtsh_asrt_emer = (uint8_t)(tmp_reg >> DMA_THRESH_COMMQ_SHIFT);
+
+    tmp_reg = ioread32be(&fman_rg->dma_rg->fmdmhy);
+    cfg->dma_comm_qtsh_clr_emer  = (uint8_t)(tmp_reg >> DMA_THRESH_COMMQ_SHIFT);
+
+    tmp_reg = ioread32be(&fman_rg->dma_rg->fmdmmr);
+    cfg->dma_cache_override      = (enum fman_dma_cache_override)((tmp_reg & DMA_MODE_CACHE_OR_MASK) >> DMA_MODE_CACHE_OR_SHIFT);
+    cfg->dma_cam_num_of_entries  = (uint8_t)((((tmp_reg & DMA_MODE_CEN_MASK) >> DMA_MODE_CEN_SHIFT) +1)*DMA_CAM_UNITS);
+    cfg->dma_aid_override        = (bool)((tmp_reg & DMA_MODE_AID_OR)? TRUE:FALSE);
+    cfg->dma_dbg_cnt_mode        = (enum fman_dma_dbg_cnt_mode)((tmp_reg & DMA_MODE_DBG_MASK) >> DMA_MODE_DBG_SHIFT);
+    cfg->dma_en_emergency        = (bool)((tmp_reg & DMA_MODE_EB)? TRUE : FALSE);
+
+    tmp_reg = ioread32be(&fman_rg->fpm_rg->fmfp_mxd);
+    cfg->disp_limit_tsh          = (uint8_t)((tmp_reg & FPM_DISP_LIMIT_MASK) >> FPM_DISP_LIMIT_SHIFT);
+
+    tmp_reg = ioread32be(&fman_rg->fpm_rg->fmfp_dist1);
+    cfg->prs_disp_tsh            = (uint8_t)((tmp_reg & FPM_THR1_PRS_MASK ) >> FPM_THR1_PRS_SHIFT);
+    cfg->plcr_disp_tsh           = (uint8_t)((tmp_reg & FPM_THR1_KG_MASK ) >> FPM_THR1_KG_SHIFT);
+    cfg->kg_disp_tsh             = (uint8_t)((tmp_reg & FPM_THR1_PLCR_MASK ) >> FPM_THR1_PLCR_SHIFT);
+    cfg->bmi_disp_tsh            = (uint8_t)((tmp_reg & FPM_THR1_BMI_MASK ) >> FPM_THR1_BMI_SHIFT);
+
+    tmp_reg = ioread32be(&fman_rg->fpm_rg->fmfp_dist2);
+    cfg->qmi_enq_disp_tsh        = (uint8_t)((tmp_reg & FPM_THR2_QMI_ENQ_MASK ) >> FPM_THR2_QMI_ENQ_SHIFT);
+    cfg->qmi_deq_disp_tsh        = (uint8_t)((tmp_reg & FPM_THR2_QMI_DEQ_MASK ) >> FPM_THR2_QMI_DEQ_SHIFT);
+    cfg->fm_ctl1_disp_tsh        = (uint8_t)((tmp_reg & FPM_THR2_FM_CTL1_MASK ) >> FPM_THR2_FM_CTL1_SHIFT);
+    cfg->fm_ctl2_disp_tsh        = (uint8_t)((tmp_reg & FPM_THR2_FM_CTL2_MASK ) >> FPM_THR2_FM_CTL2_SHIFT);
+
+    tmp_reg = ioread32be(&fman_rg->dma_rg->fmdmsetr);
+    cfg->dma_sos_emergency       = tmp_reg;
+
+    tmp_reg = ioread32be(&fman_rg->dma_rg->fmdmwcr);
+    cfg->dma_watchdog            = tmp_reg/cfg->clk_freq;
+
+    tmp_reg = ioread32be(&fman_rg->dma_rg->fmdmemsr);
+    cfg->dma_en_emergency_smoother = (bool)((tmp_reg & DMA_EMSR_EMSTR_MASK)? TRUE : FALSE);
+    cfg->dma_emergency_switch_counter = (tmp_reg & DMA_EMSR_EMSTR_MASK);
+}
+
+void fman_reset(struct fman_fpm_regs *fpm_rg)
+{
+	iowrite32be(FPM_RSTC_FM_RESET, &fpm_rg->fm_rstc);
+}
+
+/**************************************************************************//**
+ @Function      FM_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+int fman_dma_init(struct fman_dma_regs *dma_rg, struct fman_cfg *cfg)
+{
+	uint32_t    tmp_reg;
+
+	/**********************/
+	/* Init DMA Registers */
+	/**********************/
+	/* clear status reg events */
+	/* oren - check!!!  */
+	tmp_reg = (DMA_STATUS_BUS_ERR | DMA_STATUS_READ_ECC |
+			DMA_STATUS_SYSTEM_WRITE_ECC | DMA_STATUS_FM_WRITE_ECC);
+	iowrite32be(ioread32be(&dma_rg->fmdmsr) | tmp_reg,
+			&dma_rg->fmdmsr);
+
+	/* configure mode register */
+	tmp_reg = 0;
+	tmp_reg |= cfg->dma_cache_override << DMA_MODE_CACHE_OR_SHIFT;
+	if (cfg->dma_aid_override)
+		tmp_reg |= DMA_MODE_AID_OR;
+	if (cfg->exceptions & FMAN_EX_DMA_BUS_ERROR)
+		tmp_reg |= DMA_MODE_BER;
+	if ((cfg->exceptions & FMAN_EX_DMA_SYSTEM_WRITE_ECC) |
+		(cfg->exceptions & FMAN_EX_DMA_READ_ECC) |
+		(cfg->exceptions & FMAN_EX_DMA_FM_WRITE_ECC))
+		tmp_reg |= DMA_MODE_ECC;
+	if (cfg->dma_stop_on_bus_error)
+		tmp_reg |= DMA_MODE_SBER;
+	if(cfg->dma_axi_dbg_num_of_beats)
+	    tmp_reg |= (uint32_t)(DMA_MODE_AXI_DBG_MASK &
+		           ((cfg->dma_axi_dbg_num_of_beats - 1) << DMA_MODE_AXI_DBG_SHIFT));
+
+	if (cfg->dma_en_emergency) {
+		tmp_reg |= cfg->dma_emergency_bus_select;
+		tmp_reg |= cfg->dma_emergency_level << DMA_MODE_EMER_LVL_SHIFT;
+	if (cfg->dma_en_emergency_smoother)
+		iowrite32be(cfg->dma_emergency_switch_counter,
+				&dma_rg->fmdmemsr);
+	}
+	tmp_reg |= ((cfg->dma_cam_num_of_entries / DMA_CAM_UNITS) - 1) <<
+			DMA_MODE_CEN_SHIFT;
+	tmp_reg |= DMA_MODE_SECURE_PROT;
+	tmp_reg |= cfg->dma_dbg_cnt_mode << DMA_MODE_DBG_SHIFT;
+	tmp_reg |= cfg->dma_aid_mode << DMA_MODE_AID_MODE_SHIFT;
+
+	if (cfg->pedantic_dma)
+		tmp_reg |= DMA_MODE_EMER_READ;
+
+	iowrite32be(tmp_reg, &dma_rg->fmdmmr);
+
+	/* configure thresholds register */
+	tmp_reg = ((uint32_t)cfg->dma_comm_qtsh_asrt_emer <<
+			DMA_THRESH_COMMQ_SHIFT) |
+			((uint32_t)cfg->dma_read_buf_tsh_asrt_emer <<
+			DMA_THRESH_READ_INT_BUF_SHIFT) |
+			((uint32_t)cfg->dma_write_buf_tsh_asrt_emer);
+
+	iowrite32be(tmp_reg, &dma_rg->fmdmtr);
+
+	/* configure hysteresis register */
+	tmp_reg = ((uint32_t)cfg->dma_comm_qtsh_clr_emer <<
+		DMA_THRESH_COMMQ_SHIFT) |
+		((uint32_t)cfg->dma_read_buf_tsh_clr_emer <<
+		DMA_THRESH_READ_INT_BUF_SHIFT) |
+		((uint32_t)cfg->dma_write_buf_tsh_clr_emer);
+
+	iowrite32be(tmp_reg, &dma_rg->fmdmhy);
+
+	/* configure emergency threshold */
+	iowrite32be(cfg->dma_sos_emergency, &dma_rg->fmdmsetr);
+
+	/* configure Watchdog */
+	iowrite32be((cfg->dma_watchdog * cfg->clk_freq),
+			&dma_rg->fmdmwcr);
+
+	iowrite32be(cfg->cam_base_addr, &dma_rg->fmdmebcr);
+
+	return 0;
+}
+
+int fman_fpm_init(struct fman_fpm_regs *fpm_rg, struct fman_cfg *cfg)
+{
+	uint32_t tmp_reg;
+	int i;
+
+	/**********************/
+	/* Init FPM Registers */
+	/**********************/
+	tmp_reg = (uint32_t)(cfg->disp_limit_tsh << FPM_DISP_LIMIT_SHIFT);
+	iowrite32be(tmp_reg, &fpm_rg->fmfp_mxd);
+
+	tmp_reg = (((uint32_t)cfg->prs_disp_tsh << FPM_THR1_PRS_SHIFT) |
+		((uint32_t)cfg->kg_disp_tsh << FPM_THR1_KG_SHIFT) |
+		((uint32_t)cfg->plcr_disp_tsh << FPM_THR1_PLCR_SHIFT) |
+		((uint32_t)cfg->bmi_disp_tsh << FPM_THR1_BMI_SHIFT));
+	iowrite32be(tmp_reg, &fpm_rg->fmfp_dist1);
+
+	tmp_reg = (((uint32_t)cfg->qmi_enq_disp_tsh << FPM_THR2_QMI_ENQ_SHIFT) |
+		((uint32_t)cfg->qmi_deq_disp_tsh << FPM_THR2_QMI_DEQ_SHIFT) |
+		((uint32_t)cfg->fm_ctl1_disp_tsh << FPM_THR2_FM_CTL1_SHIFT) |
+		((uint32_t)cfg->fm_ctl2_disp_tsh << FPM_THR2_FM_CTL2_SHIFT));
+	iowrite32be(tmp_reg, &fpm_rg->fmfp_dist2);
+
+	/* define exceptions and error behavior */
+	tmp_reg = 0;
+	/* Clear events */
+	tmp_reg |= (FPM_EV_MASK_STALL | FPM_EV_MASK_DOUBLE_ECC |
+		FPM_EV_MASK_SINGLE_ECC);
+	/* enable interrupts */
+	if (cfg->exceptions & FMAN_EX_FPM_STALL_ON_TASKS)
+		tmp_reg |= FPM_EV_MASK_STALL_EN;
+	if (cfg->exceptions & FMAN_EX_FPM_SINGLE_ECC)
+		tmp_reg |= FPM_EV_MASK_SINGLE_ECC_EN;
+	if (cfg->exceptions & FMAN_EX_FPM_DOUBLE_ECC)
+		tmp_reg |= FPM_EV_MASK_DOUBLE_ECC_EN;
+	tmp_reg |= (cfg->catastrophic_err  << FPM_EV_MASK_CAT_ERR_SHIFT);
+	tmp_reg |= (cfg->dma_err << FPM_EV_MASK_DMA_ERR_SHIFT);
+	if (!cfg->halt_on_external_activ)
+		tmp_reg |= FPM_EV_MASK_EXTERNAL_HALT;
+	if (!cfg->halt_on_unrecov_ecc_err)
+		tmp_reg |= FPM_EV_MASK_ECC_ERR_HALT;
+	iowrite32be(tmp_reg, &fpm_rg->fmfp_ee);
+
+	/* clear all fmCtls event registers */
+	for (i = 0; i < cfg->num_of_fman_ctrl_evnt_regs; i++)
+		iowrite32be(0xFFFFFFFF, &fpm_rg->fmfp_cev[i]);
+
+	/* RAM ECC -  enable and clear events*/
+	/* first we need to clear all parser memory,
+	 * as it is uninitialized and may cause ECC errors */
+	tmp_reg = 0;
+	/* event bits */
+	tmp_reg = (FPM_RAM_MURAM_ECC | FPM_RAM_IRAM_ECC);
+	/* Rams enable not effected by RCR bit, but by a COP configuration */
+	if (cfg->external_ecc_rams_enable)
+		tmp_reg |= FPM_RAM_RAMS_ECC_EN_SRC_SEL;
+
+	/* enable test mode */
+	if (cfg->en_muram_test_mode)
+		tmp_reg |= FPM_RAM_MURAM_TEST_ECC;
+	if (cfg->en_iram_test_mode)
+		tmp_reg |= FPM_RAM_IRAM_TEST_ECC;
+	iowrite32be(tmp_reg, &fpm_rg->fm_rcr);
+
+	tmp_reg = 0;
+	if (cfg->exceptions & FMAN_EX_IRAM_ECC) {
+		tmp_reg |= FPM_IRAM_ECC_ERR_EX_EN;
+		fman_enable_rams_ecc(fpm_rg);
+	}
+	if (cfg->exceptions & FMAN_EX_NURAM_ECC) {
+		tmp_reg |= FPM_MURAM_ECC_ERR_EX_EN;
+		fman_enable_rams_ecc(fpm_rg);
+	}
+	iowrite32be(tmp_reg, &fpm_rg->fm_rie);
+
+	return 0;
+}
+
+int fman_bmi_init(struct fman_bmi_regs *bmi_rg, struct fman_cfg *cfg)
+{
+	uint32_t tmp_reg;
+
+	/**********************/
+	/* Init BMI Registers */
+	/**********************/
+
+	/* define common resources */
+	tmp_reg = cfg->fifo_base_addr;
+	tmp_reg = tmp_reg / BMI_FIFO_ALIGN;
+
+	tmp_reg |= ((cfg->total_fifo_size / FMAN_BMI_FIFO_UNITS - 1) <<
+			BMI_CFG1_FIFO_SIZE_SHIFT);
+	iowrite32be(tmp_reg, &bmi_rg->fmbm_cfg1);
+
+	tmp_reg = ((uint32_t)(cfg->total_num_of_tasks - 1) <<
+			BMI_CFG2_TASKS_SHIFT);
+	/* num of DMA's will be dynamically updated when each port is set */
+	iowrite32be(tmp_reg, &bmi_rg->fmbm_cfg2);
+
+	/* define unmaskable exceptions, enable and clear events */
+	tmp_reg = 0;
+	iowrite32be(BMI_ERR_INTR_EN_LIST_RAM_ECC |
+			BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC |
+			BMI_ERR_INTR_EN_STATISTICS_RAM_ECC |
+			BMI_ERR_INTR_EN_DISPATCH_RAM_ECC,
+			&bmi_rg->fmbm_ievr);
+
+	if (cfg->exceptions & FMAN_EX_BMI_LIST_RAM_ECC)
+		tmp_reg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+	if (cfg->exceptions & FMAN_EX_BMI_PIPELINE_ECC)
+		tmp_reg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
+	if (cfg->exceptions & FMAN_EX_BMI_STATISTICS_RAM_ECC)
+		tmp_reg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+	if (cfg->exceptions & FMAN_EX_BMI_DISPATCH_RAM_ECC)
+		tmp_reg |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
+	iowrite32be(tmp_reg, &bmi_rg->fmbm_ier);
+
+	return 0;
+}
+
+int fman_qmi_init(struct fman_qmi_regs *qmi_rg, struct fman_cfg *cfg)
+{
+	uint32_t tmp_reg;
+	uint16_t period_in_fm_clocks;
+	uint8_t remainder;
+	/**********************/
+	/* Init QMI Registers */
+	/**********************/
+	/* Clear error interrupt events */
+
+	iowrite32be(QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF,
+			&qmi_rg->fmqm_eie);
+	tmp_reg = 0;
+	if (cfg->exceptions & FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
+		tmp_reg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+	if (cfg->exceptions & FMAN_EX_QMI_DOUBLE_ECC)
+		tmp_reg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
+	/* enable events */
+	iowrite32be(tmp_reg, &qmi_rg->fmqm_eien);
+
+	if (cfg->tnum_aging_period) {
+		/* tnumAgingPeriod is in units of usec, p_FmClockFreq in Mhz */
+		period_in_fm_clocks = (uint16_t)
+				(cfg->tnum_aging_period * cfg->clk_freq);
+		/* periodInFmClocks must be a 64 multiply */
+		remainder = (uint8_t)(period_in_fm_clocks % 64);
+		if (remainder > 64)
+			tmp_reg = (uint32_t)((period_in_fm_clocks / 64) + 1);
+		else{
+			tmp_reg = (uint32_t)(period_in_fm_clocks / 64);
+			if (!tmp_reg)
+				tmp_reg = 1;
+		}
+		tmp_reg <<= QMI_TAPC_TAP;
+		iowrite32be(tmp_reg, &qmi_rg->fmqm_tapc);
+	}
+	tmp_reg = 0;
+	/* Clear interrupt events */
+	iowrite32be(QMI_INTR_EN_SINGLE_ECC, &qmi_rg->fmqm_ie);
+	if (cfg->exceptions & FMAN_EX_QMI_SINGLE_ECC)
+		tmp_reg |= QMI_INTR_EN_SINGLE_ECC;
+	/* enable events */
+	iowrite32be(tmp_reg, &qmi_rg->fmqm_ien);
+
+	return 0;
+}
+
+int fman_enable(struct fman_rg *fman_rg, struct fman_cfg *cfg)
+{
+	uint32_t cfg_reg = 0;
+
+	/**********************/
+	/* Enable all modules */
+	/**********************/
+	/* clear & enable global counters  - calculate reg and save for later,
+	because it's the same reg for QMI enable */
+	cfg_reg = QMI_CFG_EN_COUNTERS;
+	if (cfg->qmi_deq_option_support)
+		cfg_reg |= (uint32_t)(((cfg->qmi_def_tnums_thresh) << 8) |
+				(uint32_t)cfg->qmi_def_tnums_thresh);
+
+	iowrite32be(BMI_INIT_START, &fman_rg->bmi_rg->fmbm_init);
+	iowrite32be(cfg_reg | QMI_CFG_ENQ_EN | QMI_CFG_DEQ_EN,
+			&fman_rg->qmi_rg->fmqm_gc);
+
+	return 0;
+}
+
+void fman_free_resources(struct fman_rg *fman_rg)
+{
+	/* disable BMI and QMI */
+	iowrite32be(0, &fman_rg->bmi_rg->fmbm_init);
+	iowrite32be(0, &fman_rg->qmi_rg->fmqm_gc);
+
+	/* release BMI resources */
+	iowrite32be(0, &fman_rg->bmi_rg->fmbm_cfg2);
+	iowrite32be(0, &fman_rg->bmi_rg->fmbm_cfg1);
+
+	/* disable ECC */
+	iowrite32be(0, &fman_rg->fpm_rg->fm_rcr);
+}
+
+/****************************************************/
+/*       API Run-time Control uint functions        */
+/****************************************************/
+uint32_t fman_get_normal_pending(struct fman_fpm_regs *fpm_rg)
+{
+	return ioread32be(&fpm_rg->fm_npi);
+}
+
+uint32_t fman_get_controller_event(struct fman_fpm_regs *fpm_rg, uint8_t reg_id)
+{
+	uint32_t event;
+
+	event = ioread32be(&fpm_rg->fmfp_fcev[reg_id]) &
+			ioread32be(&fpm_rg->fmfp_cee[reg_id]);
+	iowrite32be(event, &fpm_rg->fmfp_cev[reg_id]);
+
+	return event;
+}
+
+uint32_t fman_get_error_pending(struct fman_fpm_regs *fpm_rg)
+{
+	return ioread32be(&fpm_rg->fm_epi);
+}
+
+void fman_set_ports_bandwidth(struct fman_bmi_regs *bmi_rg, uint8_t *weights)
+{
+	int i;
+	uint8_t shift;
+	uint32_t tmp = 0;
+
+	for (i = 0; i < 64; i++) {
+		if (weights[i] > 1) { /* no need to write 1 since it is 0 */
+			/* Add this port to tmp_reg */
+			/* (each 8 ports result in one register)*/
+			shift = (uint8_t)(32 - 4 * ((i % 8) + 1));
+			tmp |= ((weights[i] - 1) << shift);
+		}
+		if (i % 8 == 7) { /* last in this set */
+			iowrite32be(tmp, &bmi_rg->fmbm_arb[i / 8]);
+			tmp = 0;
+		}
+	}
+}
+
+void fman_enable_rams_ecc(struct fman_fpm_regs *fpm_rg)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&fpm_rg->fm_rcr);
+	if (tmp & FPM_RAM_RAMS_ECC_EN_SRC_SEL)
+		iowrite32be(tmp | FPM_RAM_IRAM_ECC_EN,
+				&fpm_rg->fm_rcr);
+	else
+		iowrite32be(tmp | FPM_RAM_RAMS_ECC_EN |
+				FPM_RAM_IRAM_ECC_EN,
+				&fpm_rg->fm_rcr);
+}
+
+void fman_disable_rams_ecc(struct fman_fpm_regs *fpm_rg)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&fpm_rg->fm_rcr);
+	if (tmp & FPM_RAM_RAMS_ECC_EN_SRC_SEL)
+		iowrite32be(tmp & ~FPM_RAM_IRAM_ECC_EN,
+				&fpm_rg->fm_rcr);
+	else
+		iowrite32be(tmp & ~(FPM_RAM_RAMS_ECC_EN | FPM_RAM_IRAM_ECC_EN),
+				&fpm_rg->fm_rcr);
+}
+
+int fman_set_exception(struct fman_rg *fman_rg,
+			enum fman_exceptions exception,
+			bool enable)
+{
+	uint32_t tmp;
+
+	switch (exception) {
+	case(E_FMAN_EX_DMA_BUS_ERROR):
+		tmp = ioread32be(&fman_rg->dma_rg->fmdmmr);
+		if (enable)
+			tmp |= DMA_MODE_BER;
+		else
+			tmp &= ~DMA_MODE_BER;
+		/* disable bus error */
+		iowrite32be(tmp, &fman_rg->dma_rg->fmdmmr);
+		break;
+	case(E_FMAN_EX_DMA_READ_ECC):
+	case(E_FMAN_EX_DMA_SYSTEM_WRITE_ECC):
+	case(E_FMAN_EX_DMA_FM_WRITE_ECC):
+		tmp = ioread32be(&fman_rg->dma_rg->fmdmmr);
+		if (enable)
+			tmp |= DMA_MODE_ECC;
+		else
+			tmp &= ~DMA_MODE_ECC;
+		iowrite32be(tmp, &fman_rg->dma_rg->fmdmmr);
+		break;
+	case(E_FMAN_EX_FPM_STALL_ON_TASKS):
+		tmp = ioread32be(&fman_rg->fpm_rg->fmfp_ee);
+		if (enable)
+			tmp |= FPM_EV_MASK_STALL_EN;
+		else
+			tmp &= ~FPM_EV_MASK_STALL_EN;
+		iowrite32be(tmp, &fman_rg->fpm_rg->fmfp_ee);
+		break;
+	case(E_FMAN_EX_FPM_SINGLE_ECC):
+		tmp = ioread32be(&fman_rg->fpm_rg->fmfp_ee);
+		if (enable)
+			tmp |= FPM_EV_MASK_SINGLE_ECC_EN;
+		else
+			tmp &= ~FPM_EV_MASK_SINGLE_ECC_EN;
+		iowrite32be(tmp, &fman_rg->fpm_rg->fmfp_ee);
+		break;
+	case(E_FMAN_EX_FPM_DOUBLE_ECC):
+		tmp = ioread32be(&fman_rg->fpm_rg->fmfp_ee);
+		if (enable)
+			tmp |= FPM_EV_MASK_DOUBLE_ECC_EN;
+		else
+			tmp &= ~FPM_EV_MASK_DOUBLE_ECC_EN;
+		iowrite32be(tmp, &fman_rg->fpm_rg->fmfp_ee);
+		break;
+	case(E_FMAN_EX_QMI_SINGLE_ECC):
+		tmp = ioread32be(&fman_rg->qmi_rg->fmqm_ien);
+		if (enable)
+			tmp |= QMI_INTR_EN_SINGLE_ECC;
+		else
+			tmp &= ~QMI_INTR_EN_SINGLE_ECC;
+		iowrite32be(tmp, &fman_rg->qmi_rg->fmqm_ien);
+		break;
+	case(E_FMAN_EX_QMI_DOUBLE_ECC):
+		tmp = ioread32be(&fman_rg->qmi_rg->fmqm_eien);
+		if (enable)
+			tmp |= QMI_ERR_INTR_EN_DOUBLE_ECC;
+		else
+			tmp &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
+		iowrite32be(tmp, &fman_rg->qmi_rg->fmqm_eien);
+		break;
+	case(E_FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID):
+		tmp = ioread32be(&fman_rg->qmi_rg->fmqm_eien);
+		if (enable)
+			tmp |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+		else
+			tmp &= ~QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+		iowrite32be(tmp, &fman_rg->qmi_rg->fmqm_eien);
+		break;
+	case(E_FMAN_EX_BMI_LIST_RAM_ECC):
+		tmp = ioread32be(&fman_rg->bmi_rg->fmbm_ier);
+		if (enable)
+			tmp |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+		else
+			tmp &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
+		iowrite32be(tmp, &fman_rg->bmi_rg->fmbm_ier);
+		break;
+	case(E_FMAN_EX_BMI_STORAGE_PROFILE_ECC):
+		tmp = ioread32be(&fman_rg->bmi_rg->fmbm_ier);
+		if (enable)
+			tmp |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
+		else
+			tmp &= ~BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
+		iowrite32be(tmp, &fman_rg->bmi_rg->fmbm_ier);
+		break;
+	case(E_FMAN_EX_BMI_STATISTICS_RAM_ECC):
+		tmp = ioread32be(&fman_rg->bmi_rg->fmbm_ier);
+		if (enable)
+			tmp |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+		else
+			tmp &= ~BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+		iowrite32be(tmp, &fman_rg->bmi_rg->fmbm_ier);
+		break;
+	case(E_FMAN_EX_BMI_DISPATCH_RAM_ECC):
+		tmp = ioread32be(&fman_rg->bmi_rg->fmbm_ier);
+		if (enable)
+			tmp |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
+		else
+			tmp &= ~BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
+		iowrite32be(tmp, &fman_rg->bmi_rg->fmbm_ier);
+		break;
+	case(E_FMAN_EX_IRAM_ECC):
+		tmp = ioread32be(&fman_rg->fpm_rg->fm_rie);
+		if (enable) {
+			/* enable ECC if not enabled */
+			fman_enable_rams_ecc(fman_rg->fpm_rg);
+			/* enable ECC interrupts */
+			tmp |= FPM_IRAM_ECC_ERR_EX_EN;
+		} else {
+			/* ECC mechanism may be disabled,
+			 * depending on driver status  */
+			fman_disable_rams_ecc(fman_rg->fpm_rg);
+			tmp &= ~FPM_IRAM_ECC_ERR_EX_EN;
+		}
+		iowrite32be(tmp, &fman_rg->fpm_rg->fm_rie);
+		break;
+	case(E_FMAN_EX_MURAM_ECC):
+		tmp = ioread32be(&fman_rg->fpm_rg->fm_rie);
+		if (enable) {
+			/* enable ECC if not enabled */
+			fman_enable_rams_ecc(fman_rg->fpm_rg);
+			/* enable ECC interrupts */
+			tmp |= FPM_MURAM_ECC_ERR_EX_EN;
+		} else {
+			/* ECC mechanism may be disabled,
+			 * depending on driver status  */
+			fman_disable_rams_ecc(fman_rg->fpm_rg);
+			tmp &= ~FPM_MURAM_ECC_ERR_EX_EN;
+		}
+		iowrite32be(tmp, &fman_rg->fpm_rg->fm_rie);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+void fman_get_revision(struct fman_fpm_regs *fpm_rg,
+			uint8_t *major,
+			uint8_t *minor)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&fpm_rg->fm_ip_rev_1);
+	*major = (uint8_t)((tmp & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
+	*minor = (uint8_t)((tmp & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+
+}
+
+uint32_t fman_get_counter(struct fman_rg *fman_rg,
+				enum fman_counters reg_name)
+{
+	uint32_t ret_val;
+
+	switch (reg_name) {
+	case(E_FMAN_COUNTERS_ENQ_TOTAL_FRAME):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_etfc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_TOTAL_FRAME):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_dtfc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_0):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_dc0);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_1):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_dc1);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_2):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_dc2);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_3):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_dc3);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_FROM_DEFAULT):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_dfdc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_FROM_CONTEXT):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_dfcc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_FROM_FD):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_dffc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_CONFIRM):
+		ret_val = ioread32be(&fman_rg->qmi_rg->fmqm_dcc);
+		break;
+	default:
+		ret_val = 0;
+	}
+	return ret_val;
+}
+
+int fman_modify_counter(struct fman_rg *fman_rg,
+			enum fman_counters reg_name,
+			uint32_t val)
+{
+	/* When applicable (when there is an 'enable counters' bit,
+	 * check that counters are enabled */
+	switch (reg_name) {
+	case(E_FMAN_COUNTERS_ENQ_TOTAL_FRAME):
+	case(E_FMAN_COUNTERS_DEQ_TOTAL_FRAME):
+	case(E_FMAN_COUNTERS_DEQ_0):
+	case(E_FMAN_COUNTERS_DEQ_1):
+	case(E_FMAN_COUNTERS_DEQ_2):
+	case(E_FMAN_COUNTERS_DEQ_3):
+	case(E_FMAN_COUNTERS_DEQ_FROM_DEFAULT):
+	case(E_FMAN_COUNTERS_DEQ_FROM_CONTEXT):
+	case(E_FMAN_COUNTERS_DEQ_FROM_FD):
+	case(E_FMAN_COUNTERS_DEQ_CONFIRM):
+		if (!(ioread32be(&fman_rg->qmi_rg->fmqm_gc) &
+				QMI_CFG_EN_COUNTERS))
+			return -EINVAL;
+		break;
+	default:
+		break;
+	}
+	/* Set counter */
+	switch (reg_name) {
+	case(E_FMAN_COUNTERS_ENQ_TOTAL_FRAME):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_etfc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_TOTAL_FRAME):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_dtfc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_0):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_dc0);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_1):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_dc1);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_2):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_dc2);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_3):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_dc3);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_FROM_DEFAULT):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_dfdc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_FROM_CONTEXT):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_dfcc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_FROM_FD):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_dffc);
+		break;
+	case(E_FMAN_COUNTERS_DEQ_CONFIRM):
+		iowrite32be(val, &fman_rg->qmi_rg->fmqm_dcc);
+		break;
+	case(E_FMAN_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT):
+		iowrite32be(val, &fman_rg->dma_rg->fmdmsefrc);
+		break;
+	case(E_FMAN_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT):
+		iowrite32be(val, &fman_rg->dma_rg->fmdmsqfrc);
+		break;
+	case(E_FMAN_COUNTERS_SEMAPHOR_SYNC_REJECT):
+		iowrite32be(val, &fman_rg->dma_rg->fmdmssrc);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+void fman_set_dma_emergency(struct fman_dma_regs *dma_rg,
+				bool is_write,
+				bool enable)
+{
+	uint32_t msk;
+
+	msk = (uint32_t)(is_write ? DMA_MODE_EMER_WRITE : DMA_MODE_EMER_READ);
+
+	if (enable)
+		iowrite32be(ioread32be(&dma_rg->fmdmmr) | msk,
+				&dma_rg->fmdmmr);
+	else /* disable */
+		iowrite32be(ioread32be(&dma_rg->fmdmmr) & ~msk,
+				&dma_rg->fmdmmr);
+}
+
+void fman_set_dma_ext_bus_pri(struct fman_dma_regs *dma_rg, uint32_t pri)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&dma_rg->fmdmmr) |
+			(pri << DMA_MODE_BUS_PRI_SHIFT);
+
+	iowrite32be(tmp, &dma_rg->fmdmmr);
+}
+
+uint32_t fman_get_dma_status(struct fman_dma_regs *dma_rg)
+{
+	return ioread32be(&dma_rg->fmdmsr);
+}
+
+void fman_force_intr(struct fman_rg *fman_rg,
+		enum fman_exceptions exception)
+{
+	switch (exception) {
+	case E_FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
+		iowrite32be(QMI_ERR_INTR_EN_DEQ_FROM_DEF,
+				&fman_rg->qmi_rg->fmqm_eif);
+		break;
+	case E_FMAN_EX_QMI_SINGLE_ECC:
+		iowrite32be(QMI_INTR_EN_SINGLE_ECC,
+				&fman_rg->qmi_rg->fmqm_if);
+		break;
+	case E_FMAN_EX_QMI_DOUBLE_ECC:
+		iowrite32be(QMI_ERR_INTR_EN_DOUBLE_ECC,
+				&fman_rg->qmi_rg->fmqm_eif);
+		break;
+	case E_FMAN_EX_BMI_LIST_RAM_ECC:
+		iowrite32be(BMI_ERR_INTR_EN_LIST_RAM_ECC,
+				&fman_rg->bmi_rg->fmbm_ifr);
+		break;
+	case E_FMAN_EX_BMI_STORAGE_PROFILE_ECC:
+		iowrite32be(BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC,
+				&fman_rg->bmi_rg->fmbm_ifr);
+		break;
+	case E_FMAN_EX_BMI_STATISTICS_RAM_ECC:
+		iowrite32be(BMI_ERR_INTR_EN_STATISTICS_RAM_ECC,
+				&fman_rg->bmi_rg->fmbm_ifr);
+		break;
+	case E_FMAN_EX_BMI_DISPATCH_RAM_ECC:
+		iowrite32be(BMI_ERR_INTR_EN_DISPATCH_RAM_ECC,
+				&fman_rg->bmi_rg->fmbm_ifr);
+		break;
+	default:
+		break;
+	}
+}
+
+bool fman_is_qmi_halt_not_busy_state(struct fman_qmi_regs *qmi_rg)
+{
+	return (bool)!!(ioread32be(&qmi_rg->fmqm_gs) & QMI_GS_HALT_NOT_BUSY);
+}
+void fman_resume(struct fman_fpm_regs *fpm_rg)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&fpm_rg->fmfp_ee);
+	/* clear tmp_reg event bits in order not to clear standing events */
+	tmp &= ~(FPM_EV_MASK_DOUBLE_ECC |
+			FPM_EV_MASK_STALL |
+			FPM_EV_MASK_SINGLE_ECC);
+	tmp |= FPM_EV_MASK_RELEASE_FM;
+
+	iowrite32be(tmp, &fpm_rg->fmfp_ee);
+}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
index a2ca82a..d23c1d0 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
@@ -242,6 +242,7 @@ typedef struct {
     uint8_t             hardwarePortId;
     t_FmRevisionInfo    revInfo;
     uint32_t            nia;
+    uint32_t            discardMask;
 } t_GetCcParams;
 
 typedef struct {
@@ -300,6 +301,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define GET_NIA_FPNE                            0x01000000
 #define GET_NIA_PNDN                            0x00800000
 #define NUM_OF_EXTRA_TASKS                      0x00400000
+#define DISCARD_MASK                            0x00200000
 
 #define UPDATE_NIA_PNEN                         0x80000000
 #define UPDATE_PSO                              0x40000000
@@ -374,7 +376,6 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define NIA_BMI_AC_TX               0x00000274
 #define NIA_BMI_AC_FETCH            0x00000208
 #define NIA_BMI_AC_MASK             0x000003FF
-#define NIA_BMI_AC_FETCH_ALL_FRAME  0x0000020c
 
 #define NIA_KG_DIRECT               0x00000100
 #define NIA_KG_CC_EN                0x00000200
@@ -443,59 +444,59 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal OH_PORT port id"))
 #endif
 #if (FM_MAX_NUM_OF_1G_RX_PORTS > 0)
-#define CHECK_PORT_ID_1G_RX_PORTS(_relativePortId)                     \
-    if ((_relativePortId) >= FM_MAX_NUM_OF_1G_RX_PORTS)                \
+#define CHECK_PORT_ID_1G_RX_PORTS(_relativePortId)                  \
+    if ((_relativePortId) >= FM_MAX_NUM_OF_1G_RX_PORTS)             \
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 1G_RX_PORT port id"))
 #else
-#define CHECK_PORT_ID_1G_RX_PORTS(_relativePortId)                     \
+#define CHECK_PORT_ID_1G_RX_PORTS(_relativePortId)                  \
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 1G_RX_PORT port id"))
 #endif
 #if (FM_MAX_NUM_OF_10G_RX_PORTS > 0)
-#define CHECK_PORT_ID_10G_RX_PORTS(_relativePortId)                     \
-    if ((_relativePortId) >= FM_MAX_NUM_OF_10G_RX_PORTS)                \
+#define CHECK_PORT_ID_10G_RX_PORTS(_relativePortId)                 \
+    if ((_relativePortId) >= FM_MAX_NUM_OF_10G_RX_PORTS)            \
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 10G_RX_PORT port id"))
 #else
-#define CHECK_PORT_ID_10G_RX_PORTS(_relativePortId)                     \
+#define CHECK_PORT_ID_10G_RX_PORTS(_relativePortId)                 \
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 10G_RX_PORT port id"))
 #endif
 #if (FM_MAX_NUM_OF_1G_TX_PORTS > 0)
-#define CHECK_PORT_ID_1G_TX_PORTS(_relativePortId)                     \
-    if ((_relativePortId) >= FM_MAX_NUM_OF_1G_TX_PORTS)                \
+#define CHECK_PORT_ID_1G_TX_PORTS(_relativePortId)                  \
+    if ((_relativePortId) >= FM_MAX_NUM_OF_1G_TX_PORTS)             \
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 1G_TX_PORT port id"))
 #else
-#define CHECK_PORT_ID_1G_TX_PORTS(_relativePortId)                     \
+#define CHECK_PORT_ID_1G_TX_PORTS(_relativePortId)                  \
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 1G_TX_PORT port id"))
 #endif
 #if (FM_MAX_NUM_OF_10G_TX_PORTS > 0)
-#define CHECK_PORT_ID_10G_TX_PORTS(_relativePortId)                     \
-    if ((_relativePortId) >= FM_MAX_NUM_OF_10G_TX_PORTS)                \
+#define CHECK_PORT_ID_10G_TX_PORTS(_relativePortId)                 \
+    if ((_relativePortId) >= FM_MAX_NUM_OF_10G_TX_PORTS)            \
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 10G_TX_PORT port id"))
 #else
-#define CHECK_PORT_ID_10G_TX_PORTS(_relativePortId)                     \
+#define CHECK_PORT_ID_10G_TX_PORTS(_relativePortId)                 \
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 10G_TX_PORT port id"))
 #endif
 
 
 #define SW_PORT_ID_TO_HW_PORT_ID(_port, _type, _relativePortId)         \
 switch (_type) {                                                        \
-    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):                            \
-    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):                               \
+    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):                           \
+    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):                              \
         CHECK_PORT_ID_OH_PORTS(_relativePortId);                        \
         _port = (uint8_t)(BASE_OH_PORTID + (_relativePortId));          \
         break;                                                          \
-    case (e_FM_PORT_TYPE_RX):                                            \
+    case (e_FM_PORT_TYPE_RX):                                           \
         CHECK_PORT_ID_1G_RX_PORTS(_relativePortId);                     \
         _port = (uint8_t)(BASE_1G_RX_PORTID + (_relativePortId));       \
         break;                                                          \
-    case (e_FM_PORT_TYPE_RX_10G):                                        \
+    case (e_FM_PORT_TYPE_RX_10G):                                       \
         CHECK_PORT_ID_10G_RX_PORTS(_relativePortId);                    \
         _port = (uint8_t)(BASE_10G_RX_PORTID + (_relativePortId));      \
         break;                                                          \
-    case (e_FM_PORT_TYPE_TX):                                            \
+    case (e_FM_PORT_TYPE_TX):                                           \
         CHECK_PORT_ID_1G_TX_PORTS(_relativePortId);                     \
         _port = (uint8_t)(BASE_1G_TX_PORTID + (_relativePortId));       \
         break;                                                          \
-    case (e_FM_PORT_TYPE_TX_10G):                                        \
+    case (e_FM_PORT_TYPE_TX_10G):                                       \
         CHECK_PORT_ID_10G_TX_PORTS(_relativePortId);                    \
         _port = (uint8_t)(BASE_10G_TX_PORTID + (_relativePortId));      \
         break;                                                          \
@@ -733,14 +734,12 @@ t_Error     FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx,uint3
 /***********************************************************************/
 uint8_t     FmPcdCcGetParseCode(t_Handle h_CcNode);
 uint8_t     FmPcdCcGetOffset(t_Handle h_CcNode);
-uint32_t    FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer);
 t_Error     FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex);
 t_Error     FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPCdCcKeyParams);
 t_Error     FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask);
 t_Error     FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams);
 t_Error     FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint16_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
 t_Handle    FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree);
 void        FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams);
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/dpaa_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/dpaa_ext.h
index c20a6eb..66fa760 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/dpaa_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/dpaa_ext.h
@@ -199,6 +199,8 @@ do {                                                            \
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
 
+#define DPAA_LIODN_DONT_OVERRIDE    (-1)
+
 /** @} */ /* end of DPAA_grp group */
 
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h
index 94b305c..b7128b5 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h
@@ -210,7 +210,11 @@ typedef struct t_FmMacStatistics {
 typedef struct t_FmMacParams {
     uintptr_t                   baseAddr;           /**< Base of memory mapped FM MAC registers */
     t_EnetAddr                  addr;               /**< MAC address of device; First octet is sent first */
-    uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G-MAC 0>      */
+    uint8_t                     macId;              /**< MAC ID;
+                                                         numbering of dTSEC and 1G-mEMAC:
+                                                            0 - FM_MAX_NUM_OF_1G_MACS;
+                                                         numbering of 10G-MAC (TGEC) and 10G-mEMAC:
+                                                            0 - FM_MAX_NUM_OF_10G_MACS */
     e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed);
                                                          Note that the speed should indicate the maximum rate that
                                                          this MAC should support rather than the actual speed;
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
index 00750ba..83cf237 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
@@ -47,7 +47,6 @@
 
 
 /**************************************************************************//**
-
  @Group         FM_grp Frame Manager API
 
  @Description   Frame Manager Application Programming Interface
@@ -2538,6 +2537,7 @@ typedef struct t_FmPcdManipReassemParams {
     } u;
 } t_FmPcdManipReassemParams;
 
+
 /**************************************************************************//**
  @Description   Parameters for defining a manipulation node
 *//***************************************************************************/
@@ -2935,6 +2935,10 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode);
 
  @Cautions      Allowed only following FM_PCD_MatchTableSet();
                 Not relevant in the case the node is of type 'INDEXED_LOOKUP'.
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
+ 
 *//***************************************************************************/
 t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                  h_CcNode,
                                               t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
@@ -2992,6 +2996,10 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_MatchTableSet().
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
+ 
 *//***************************************************************************/
 t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle                  h_CcNode,
                                           uint16_t                  keyIndex,
@@ -3013,6 +3021,9 @@ t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle                  h_CcNode,
 
  @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
                 node and the nodes that lead to it.
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
 *//***************************************************************************/
 t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle            h_CcNode,
                                                 uint16_t            keyIndex,
@@ -3082,6 +3093,9 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_MatchTableSet().
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
 *//***************************************************************************/
 t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNode,
                                                uint8_t                   keySize,
@@ -3108,6 +3122,9 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
 
  @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
                 node and the nodes that lead to it.
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
 *//***************************************************************************/
 t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNode,
                                                      uint8_t             keySize,
@@ -3390,6 +3407,9 @@ t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_HashTableSet().
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
 *//***************************************************************************/
 t_Error FM_PCD_HashTableModifyNextEngine(t_Handle                  h_HashTbl,
                                          uint8_t                   keySize,
@@ -3408,6 +3428,9 @@ t_Error FM_PCD_HashTableModifyNextEngine(t_Handle                  h_HashTbl,
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_HashTableSet().
+                When configuring nextEngine = e_FM_PCD_CC, note that
+                p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
+                from the currently changed table.
 *//***************************************************************************/
 t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl,
                                              t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
index 89fabbc..6f344b8 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
@@ -136,7 +136,7 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 #define FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)        /**< IPR error */
 #define FM_PORT_FRM_ERR_IPR_NCSP                (FM_FD_ERR_IPR_NCSP & ~FM_FD_IPR)   /**< IPR non-consistent-sp */
 
-#define FM_PORT_FRM_ERR_IPFE                    0 /**< Obsolete; will be removed in the future */
+#define FM_PORT_FRM_ERR_IPFE                    0                                   /**< Obsolete; will be removed in the future */
 
 #ifdef FM_CAPWAP_SUPPORT
 #define FM_PORT_FRM_ERR_CRE                     FM_FD_ERR_CRE
@@ -147,7 +147,7 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
                                                                                      error (SGMII and TBI modes), FIFO parity error. PHY
                                                                                      Sequence error, PHY error control character detected. */
 #define FM_PORT_FRM_ERR_SIZE                    FM_FD_ERR_SIZE                  /**< Frame too long OR Frame size exceeds max_length_frame  */
-#define FM_PORT_FRM_ERR_CLS_DISCARD             FM_FD_ERR_CLS_DISCARD           /**< classification discard */
+#define FM_PORT_FRM_ERR_CLS_DISCARD             FM_FD_ERR_CLS_DISCARD           /**< indicates a classifier "drop" operation */
 #define FM_PORT_FRM_ERR_EXTRACTION              FM_FD_ERR_EXTRACTION            /**< Extract Out of Frame */
 #define FM_PORT_FRM_ERR_NO_SCHEME               FM_FD_ERR_NO_SCHEME             /**< No Scheme Selected */
 #define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW        FM_FD_ERR_KEYSIZE_OVERFLOW      /**< Keysize Overflow */
@@ -159,7 +159,7 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 #define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT        FM_FD_ERR_PRS_ILL_INSTRUCT      /**< Invalid Soft Parser instruction */
 #define FM_PORT_FRM_ERR_PRS_HDR_ERR             FM_FD_ERR_PRS_HDR_ERR           /**< Header error was identified during parsing */
 #define FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED    FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  /**< Frame parsed beyind 256 first bytes */
-#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT         0x00000001       /**< FPM Frame Processing Timeout Exceeded */
+#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT         0x00000001                      /**< FPM Frame Processing Timeout Exceeded */
 /* @} */
 
 
@@ -1093,9 +1093,10 @@ t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLeve
                 pipeline depth parameter in the internal driver data base
 
                 from its default configuration: 1G ports: [DEFAULT_PORT_fifoDeqPipelineDepth_1G],
-                10G port: [DEFAULT_PORT_fifoDeqPipelineDepth_10G]
+                10G port: [DEFAULT_PORT_fifoDeqPipelineDepth_10G],
+                OP port: [DEFAULT_PORT_fifoDeqPipelineDepth_OH]
 
-                May be used for Tx ports only
+                May be used for Tx/OP ports only
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
  @Param[in]     deqPipelineDepth    New value
@@ -1907,13 +1908,7 @@ typedef struct t_FmPortPcdKgParams {
  @Description   struct for defining policer parameters
 *//***************************************************************************/
 typedef struct t_FmPortPcdPlcrParams {
-    t_Handle                h_Profile;          /**< Selected profile handle; Relevant for one of
-                                                     following cases:
-                                                     e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
-                                                     e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
-                                                     or if any flow uses a KG scheme were policer
-                                                     profile is not generated
-                                                     (bypassPlcrProfileGeneration selected) */
+    t_Handle                h_Profile;          /**< Selected profile handle */
 } t_FmPortPcdPlcrParams;
 
 /**************************************************************************//**
@@ -1926,7 +1921,13 @@ typedef struct t_FmPortPcdParams {
     t_FmPortPcdPrsParams    *p_PrsParams;       /**< Parser parameters for this port */
     t_FmPortPcdCcParams     *p_CcParams;        /**< Coarse classification parameters for this port */
     t_FmPortPcdKgParams     *p_KgParams;        /**< Keygen parameters for this port */
-    t_FmPortPcdPlcrParams   *p_PlcrParams;      /**< Policer parameters for this port */
+    t_FmPortPcdPlcrParams   *p_PlcrParams;      /**< Policer parameters for this port; Relevant for one of
+                                                     following cases:
+                                                     e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
+                                                     e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
+                                                     or if any flow uses a KG scheme were policer
+                                                     profile is not generated
+                                                     ('bypassPlcrProfileGeneration selected'). */
     t_Handle                h_IpReassemblyManip;/**< IP Reassembly manipulation */
 } t_FmPortPcdParams;
 
@@ -2180,6 +2181,19 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
 *//***************************************************************************/
 t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
 
+/**************************************************************************//**
+ @Function      FM_PORT_GetIPv4OptionsCount
+
+ @Description   TODO
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[out]    p_Ipv4OptionsCount  will hold the counter value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init()
+*//***************************************************************************/
+t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount);
 
 /** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
 /** @} */ /* end of FM_PORT_runtime_control_grp group */
diff --git a/drivers/net/ethernet/freescale/fman/inc/ddr_std_ext.h b/drivers/net/ethernet/freescale/fman/inc/ddr_std_ext.h
index 69a0025..8bb343fc 100644
--- a/drivers/net/ethernet/freescale/fman/inc/ddr_std_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/ddr_std_ext.h
@@ -56,7 +56,8 @@ typedef enum e_DdrType
     e_DDR_DDR1,
     e_DDR_DDR2,
     e_DDR_DDR3,
-    e_DDR_DDR3L
+    e_DDR_DDR3L,
+    e_DDR_DDR4
 } e_DdrType;
 
 /**************************************************************************//**
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fman_common.h b/drivers/net/ethernet/freescale/fman/inc/flib/fman_common.h
new file mode 100755
index 0000000..8b194e9
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fman_common.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __FMAN_COMMON_H
+#define __FMAN_COMMON_H
+
+/**************************************************************************//**
+  @Description       NIA Description
+*//***************************************************************************/
+#define NIA_ORDER_RESTOR                        0x00800000
+#define NIA_ENG_FM_CTL                          0x00000000
+#define NIA_ENG_PRS                             0x00440000
+#define NIA_ENG_KG                              0x00480000
+#define NIA_ENG_PLCR                            0x004C0000
+#define NIA_ENG_BMI                             0x00500000
+#define NIA_ENG_QMI_ENQ                         0x00540000
+#define NIA_ENG_QMI_DEQ                         0x00580000
+#define NIA_ENG_MASK                            0x007C0000
+
+#define NIA_FM_CTL_AC_CC                        0x00000006
+#define NIA_FM_CTL_AC_HC                        0x0000000C
+#define NIA_FM_CTL_AC_IND_MODE_TX               0x00000008
+#define NIA_FM_CTL_AC_IND_MODE_RX               0x0000000A
+#define NIA_FM_CTL_AC_FRAG                      0x0000000e
+#define NIA_FM_CTL_AC_PRE_FETCH                 0x00000010
+#define NIA_FM_CTL_AC_POST_FETCH_PCD            0x00000012
+#define NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN    0x00000018
+#define NIA_FM_CTL_AC_POST_FETCH_NO_PCD         0x00000012
+#define NIA_FM_CTL_AC_FRAG_CHECK                0x00000014
+#define NIA_FM_CTL_AC_PRE_CC                    0x00000020
+
+
+#define NIA_BMI_AC_ENQ_FRAME                    0x00000002
+#define NIA_BMI_AC_TX_RELEASE                   0x000002C0
+#define NIA_BMI_AC_RELEASE                      0x000000C0
+#define NIA_BMI_AC_DISCARD                      0x000000C1
+#define NIA_BMI_AC_TX                           0x00000274
+#define NIA_BMI_AC_FETCH                        0x00000208
+#define NIA_BMI_AC_MASK                         0x000003FF
+
+#define NIA_KG_DIRECT                           0x00000100
+#define NIA_KG_CC_EN                            0x00000200
+#define NIA_PLCR_ABSOLUTE                       0x00008000
+
+#define NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA        0x00000202
+#define NIA_BMI_AC_FETCH_ALL_FRAME              0x0000020c
+
+#endif /* __FMAN_COMMON_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_enet.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_enet.h
index bb0dea9..dde6a4e 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_enet.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_enet.h
@@ -61,16 +61,212 @@ enum enet_speed {
 	E_ENET_SPEED_10000	= 10000	/**< 10000 Mbps = 10 Gbps */
 };
 
-enum mac_stat_level {
-	/* No statistics */
-	E_MAC_STAT_NONE = 0,
-	/* Only RMON MIB group 1 (ether stats). Optimized for performance */
-	E_MAC_STAT_MIB_GRP1,
-	/* Only error counters are available. Optimized for performance */
-	E_MAC_STAT_PARTIAL,
-	/* All counters available. Not optimized for performance */
-	E_MAC_STAT_FULL
+enum mac_type {
+	E_MAC_DTSEC,
+	E_MAC_TGEC,
+	E_MAC_MEMAC
 };
 
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+enum fman_event_modules {
+	E_FMAN_MOD_PRS,                   /**< Parser event */
+	E_FMAN_MOD_KG,                    /**< Keygen event */
+	E_FMAN_MOD_PLCR,                  /**< Policer event */
+	E_FMAN_MOD_10G_MAC,               /**< 10G MAC event */
+	E_FMAN_MOD_1G_MAC,                /**< 1G MAC event */
+	E_FMAN_MOD_TMR,                   /**< Timer event */
+	E_FMAN_MOD_FMAN_CTRL,             /**< FMAN Controller  Timer event */
+	E_FMAN_MOD_MACSEC,
+	E_FMAN_MOD_DUMMY_LAST
+};
+
+/**************************************************************************//**
+ @Description   Enum for interrupts types
+*//***************************************************************************/
+enum fman_intr_type {
+	E_FMAN_INTR_TYPE_ERR,
+	E_FMAN_INTR_TYPE_NORMAL
+};
+
+/**************************************************************************//**
+ @Description   enum for defining MAC types
+*//***************************************************************************/
+enum fman_mac_type {
+	E_FMAN_MAC_10G = 0,               /**< 10G MAC */
+	E_FMAN_MAC_1G                     /**< 1G MAC */
+};
+
+enum fman_mac_exceptions {
+	E_FMAN_MAC_EX_10G_MDIO_SCAN_EVENTMDIO = 0,
+		/**< 10GEC MDIO scan event interrupt */
+	E_FMAN_MAC_EX_10G_MDIO_CMD_CMPL,
+		/**< 10GEC MDIO command completion interrupt */
+	E_FMAN_MAC_EX_10G_REM_FAULT,
+		/**< 10GEC, mEMAC Remote fault interrupt */
+	E_FMAN_MAC_EX_10G_LOC_FAULT,
+		/**< 10GEC, mEMAC Local fault interrupt */
+	E_FMAN_MAC_EX_10G_1TX_ECC_ER,
+		/**< 10GEC, mEMAC Transmit frame ECC error interrupt */
+	E_FMAN_MAC_EX_10G_TX_FIFO_UNFL,
+		/**< 10GEC, mEMAC Transmit FIFO underflow interrupt */
+	E_FMAN_MAC_EX_10G_TX_FIFO_OVFL,
+		/**< 10GEC, mEMAC Transmit FIFO overflow interrupt */
+	E_FMAN_MAC_EX_10G_TX_ER,
+		/**< 10GEC Transmit frame error interrupt */
+	E_FMAN_MAC_EX_10G_RX_FIFO_OVFL,
+		/**< 10GEC, mEMAC Receive FIFO overflow interrupt */
+	E_FMAN_MAC_EX_10G_RX_ECC_ER,
+		/**< 10GEC, mEMAC Receive frame ECC error interrupt */
+	E_FMAN_MAC_EX_10G_RX_JAB_FRM,
+		/**< 10GEC Receive jabber frame interrupt */
+	E_FMAN_MAC_EX_10G_RX_OVRSZ_FRM,
+		/**< 10GEC Receive oversized frame interrupt */
+	E_FMAN_MAC_EX_10G_RX_RUNT_FRM,
+		/**< 10GEC Receive runt frame interrupt */
+	E_FMAN_MAC_EX_10G_RX_FRAG_FRM,
+		/**< 10GEC Receive fragment frame interrupt */
+	E_FMAN_MAC_EX_10G_RX_LEN_ER,
+		/**< 10GEC Receive payload length error interrupt */
+	E_FMAN_MAC_EX_10G_RX_CRC_ER,
+		/**< 10GEC Receive CRC error interrupt */
+	E_FMAN_MAC_EX_10G_RX_ALIGN_ER,
+		/**< 10GEC Receive alignment error interrupt */
+	E_FMAN_MAC_EX_1G_BAB_RX,
+		/**< dTSEC Babbling receive error */
+	E_FMAN_MAC_EX_1G_RX_CTL,
+		/**< dTSEC Receive control (pause frame) interrupt */
+	E_FMAN_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET,
+		/**< dTSEC Graceful transmit stop complete */
+	E_FMAN_MAC_EX_1G_BAB_TX,
+		/**< dTSEC Babbling transmit error */
+	E_FMAN_MAC_EX_1G_TX_CTL,
+		/**< dTSEC Transmit control (pause frame) interrupt */
+	E_FMAN_MAC_EX_1G_TX_ERR,
+		/**< dTSEC Transmit error */
+	E_FMAN_MAC_EX_1G_LATE_COL,
+		/**< dTSEC Late collision */
+	E_FMAN_MAC_EX_1G_COL_RET_LMT,
+		/**< dTSEC Collision retry limit */
+	E_FMAN_MAC_EX_1G_TX_FIFO_UNDRN,
+		/**< dTSEC Transmit FIFO underrun */
+	E_FMAN_MAC_EX_1G_MAG_PCKT,
+		/**< dTSEC Magic Packet detection */
+	E_FMAN_MAC_EX_1G_MII_MNG_RD_COMPLET,
+		/**< dTSEC MII management read completion */
+	E_FMAN_MAC_EX_1G_MII_MNG_WR_COMPLET,
+		/**< dTSEC MII management write completion */
+	E_FMAN_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET,
+		/**< dTSEC Graceful receive stop complete */
+	E_FMAN_MAC_EX_1G_TX_DATA_ERR,
+		/**< dTSEC Internal data error on transmit */
+	E_FMAN_MAC_EX_1G_RX_DATA_ERR,
+		/**< dTSEC Internal data error on receive */
+	E_FMAN_MAC_EX_1G_1588_TS_RX_ERR,
+		/**< dTSEC Time-Stamp Receive Error */
+	E_FMAN_MAC_EX_1G_RX_MIB_CNT_OVFL,
+		/**< dTSEC MIB counter overflow */
+	E_FMAN_MAC_EX_TS_FIFO_ECC_ERR,
+		/**< mEMAC Time-stamp FIFO ECC error interrupt;
+		not supported on T4240/B4860 rev1 chips */
+};
+
+#define ENET_IF_SGMII_BASEX 0x80000000
+	/**< SGMII/QSGII interface with 1000BaseX auto-negotiation between MAC
+	and phy or backplane;
+	Note: 1000BaseX auto-negotiation relates only to interface between MAC
+	and phy/backplane, SGMII phy can still synchronize with far-end phy at
+	10Mbps, 100Mbps or 1000Mbps */
+
+enum enet_mode {
+	E_ENET_MODE_INVALID           = 0,
+		/**< Invalid Ethernet mode */
+	E_ENET_MODE_MII_10            = (E_ENET_IF_MII   | E_ENET_SPEED_10),
+		/**<    10 Mbps MII   */
+	E_ENET_MODE_MII_100           = (E_ENET_IF_MII   | E_ENET_SPEED_100),
+		/**<   100 Mbps MII   */
+	E_ENET_MODE_RMII_10           = (E_ENET_IF_RMII  | E_ENET_SPEED_10),
+		/**<    10 Mbps RMII  */
+	E_ENET_MODE_RMII_100          = (E_ENET_IF_RMII  | E_ENET_SPEED_100),
+		/**<   100 Mbps RMII  */
+	E_ENET_MODE_SMII_10           = (E_ENET_IF_SMII  | E_ENET_SPEED_10),
+		/**<    10 Mbps SMII  */
+	E_ENET_MODE_SMII_100          = (E_ENET_IF_SMII  | E_ENET_SPEED_100),
+		/**<   100 Mbps SMII  */
+	E_ENET_MODE_GMII_1000         = (E_ENET_IF_GMII  | E_ENET_SPEED_1000),
+		/**<  1000 Mbps GMII  */
+	E_ENET_MODE_RGMII_10          = (E_ENET_IF_RGMII | E_ENET_SPEED_10),
+		/**<    10 Mbps RGMII */
+	E_ENET_MODE_RGMII_100         = (E_ENET_IF_RGMII | E_ENET_SPEED_100),
+		/**<   100 Mbps RGMII */
+	E_ENET_MODE_RGMII_1000        = (E_ENET_IF_RGMII | E_ENET_SPEED_1000),
+		/**<  1000 Mbps RGMII */
+	E_ENET_MODE_TBI_1000          = (E_ENET_IF_TBI   | E_ENET_SPEED_1000),
+		/**<  1000 Mbps TBI   */
+	E_ENET_MODE_RTBI_1000         = (E_ENET_IF_RTBI  | E_ENET_SPEED_1000),
+		/**<  1000 Mbps RTBI  */
+	E_ENET_MODE_SGMII_10          = (E_ENET_IF_SGMII | E_ENET_SPEED_10),
+		/**< 10 Mbps SGMII with auto-negotiation between MAC and
+		SGMII phy according to Cisco SGMII specification */
+	E_ENET_MODE_SGMII_100         = (E_ENET_IF_SGMII | E_ENET_SPEED_100),
+		/**< 100 Mbps SGMII with auto-negotiation between MAC and
+		SGMII phy according to Cisco SGMII specification */
+	E_ENET_MODE_SGMII_1000        = (E_ENET_IF_SGMII | E_ENET_SPEED_1000),
+		/**< 1000 Mbps SGMII with auto-negotiation between MAC and
+		SGMII phy according to Cisco SGMII specification */
+	E_ENET_MODE_SGMII_BASEX_10    = (ENET_IF_SGMII_BASEX | E_ENET_IF_SGMII
+		| E_ENET_SPEED_10),
+		/**< 10 Mbps SGMII with 1000BaseX auto-negotiation between
+		MAC and SGMII phy or backplane */
+	E_ENET_MODE_SGMII_BASEX_100   = (ENET_IF_SGMII_BASEX | E_ENET_IF_SGMII
+		| E_ENET_SPEED_100),
+		/**< 100 Mbps SGMII with 1000BaseX auto-negotiation between
+		MAC and SGMII phy or backplane */
+	E_ENET_MODE_SGMII_BASEX_1000  = (ENET_IF_SGMII_BASEX | E_ENET_IF_SGMII
+		| E_ENET_SPEED_1000),
+		/**< 1000 Mbps SGMII with 1000BaseX auto-negotiation between
+		MAC and SGMII phy or backplane */
+	E_ENET_MODE_QSGMII_1000       = (E_ENET_IF_QSGMII | E_ENET_SPEED_1000),
+		/**< 1000 Mbps QSGMII with auto-negotiation between MAC and
+		QSGMII phy according to Cisco QSGMII specification */
+	E_ENET_MODE_QSGMII_BASEX_1000 = (ENET_IF_SGMII_BASEX | E_ENET_IF_QSGMII
+		| E_ENET_SPEED_1000),
+		/**< 1000 Mbps QSGMII with 1000BaseX auto-negotiation between
+		MAC and QSGMII phy or backplane */
+	E_ENET_MODE_XGMII_10000       = (E_ENET_IF_XGMII | E_ENET_SPEED_10000),
+		/**< 10000 Mbps XGMII */
+	E_ENET_MODE_XFI_10000         = (E_ENET_IF_XFI   | E_ENET_SPEED_10000)
+		/**< 10000 Mbps XFI */
+};
+
+enum fmam_mac_statistics_level {
+	E_FMAN_MAC_NONE_STATISTICS,	/**< No statistics */
+	E_FMAN_MAC_PARTIAL_STATISTICS,	/**< Only error counters are available;
+					Optimized for performance */
+	E_FMAN_MAC_FULL_STATISTICS	/**< All counters available; Not
+					optimized for performance */
+};
+
+#define _MAKE_ENET_MODE(_interface, _speed) (enum enet_mode)((_interface) \
+	| (_speed))
+
+#define _ENET_INTERFACE_FROM_MODE(mode) (enum enet_interface) \
+	((mode) & 0x0FFF0000)
+#define _ENET_SPEED_FROM_MODE(mode) (enum enet_speed)((mode) & 0x0000FFFF)
+#define _ENET_ADDR_TO_UINT64(_enet_addr)		\
+	(uint64_t)(((uint64_t)(_enet_addr)[0] << 40) |	\
+		((uint64_t)(_enet_addr)[1] << 32) |	\
+		((uint64_t)(_enet_addr)[2] << 24) |	\
+		((uint64_t)(_enet_addr)[3] << 16) |	\
+		((uint64_t)(_enet_addr)[4] << 8) |	\
+		((uint64_t)(_enet_addr)[5]))
+
+#define _MAKE_ENET_ADDR_FROM_UINT64(_addr64, _enet_addr)		\
+	do {								\
+		int i;							\
+		for (i = 0; i < ENET_NUM_OCTETS_PER_ADDRESS; i++)	\
+			(_enet_addr)[i] = (uint8_t)((_addr64) >> ((5-i)*8));\
+	} while (0)
 
 #endif /* __FSL_ENET_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
index 2933f75..e66ad73 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
@@ -35,7 +35,6 @@
 
 #include "common/general.h"
 
-
 struct fman_ext_pool_params {
 	uint8_t                 id;    /**< External buffer pool id */
 	uint16_t                size;  /**< External buffer pool buffer size */
@@ -109,6 +108,11 @@ typedef struct t_FmPrsResult fm_prs_result_t;
 typedef enum e_EnetMode enet_mode_t;
 typedef t_Handle handle_t;
 
+struct fman_revision_info {
+	uint8_t         majorRev;               /**< Major revision */
+	uint8_t         minorRev;               /**< Minor revision */
+};
+
 /* sizes */
 #define CAPWAP_FRAG_EXTRA_SPACE                 32
 #define OFFSET_UNITS                            16
@@ -117,5 +121,706 @@ typedef t_Handle handle_t;
 #define MAX_EXT_OFFSET                          496
 #define MAX_EXT_BUFFER_OFFSET                   511
 
+/**************************************************************************
+ @Description       Memory Mapped Registers
+***************************************************************************/
+#define FMAN_LIODN_TBL	64	/* size of LIODN table */
+
+struct fman_fpm_regs {
+	uint32_t fmfp_tnc;	/**< FPM TNUM Control 0x00 */
+	uint32_t fmfp_prc;	/**< FPM Port_ID FmCtl Association 0x04 */
+	uint32_t fmfp_brkc;		/**< FPM Breakpoint Control 0x08 */
+	uint32_t fmfp_mxd;	/**< FPM Flush Control 0x0c */
+	uint32_t fmfp_dist1;	/**< FPM Dispatch Thresholds1 0x10 */
+	uint32_t fmfp_dist2;	/**< FPM Dispatch Thresholds2 0x14 */
+	uint32_t fm_epi;	/**< FM Error Pending Interrupts 0x18 */
+	uint32_t fm_rie;	/**< FM Error Interrupt Enable 0x1c */
+	uint32_t fmfp_fcev[4];	/**< FPM FMan-Controller Event 1-4 0x20-0x2f */
+	uint32_t res0030[4];	/**< res 0x30 - 0x3f */
+	uint32_t fmfp_cee[4];	/**< PM FMan-Controller Event 1-4 0x40-0x4f */
+	uint32_t res0050[4];	/**< res 0x50-0x5f */
+	uint32_t fmfp_tsc1;	/**< FPM TimeStamp Control1 0x60 */
+	uint32_t fmfp_tsc2;	/**< FPM TimeStamp Control2 0x64 */
+	uint32_t fmfp_tsp;	/**< FPM Time Stamp 0x68 */
+	uint32_t fmfp_tsf;	/**< FPM Time Stamp Fraction 0x6c */
+	uint32_t fm_rcr;	/**< FM Rams Control 0x70 */
+	uint32_t fmfp_extc;	/**< FPM External Requests Control 0x74 */
+	uint32_t fmfp_ext1;	/**< FPM External Requests Config1 0x78 */
+	uint32_t fmfp_ext2;	/**< FPM External Requests Config2 0x7c */
+	uint32_t fmfp_drd[16];	/**< FPM Data_Ram Data 0-15 0x80 - 0xbf */
+	uint32_t fmfp_dra;	/**< FPM Data Ram Access 0xc0 */
+	uint32_t fm_ip_rev_1;	/**< FM IP Block Revision 1 0xc4 */
+	uint32_t fm_ip_rev_2;	/**< FM IP Block Revision 2 0xc8 */
+	uint32_t fm_rstc;	/**< FM Reset Command 0xcc */
+	uint32_t fm_cld;	/**< FM Classifier Debug 0xd0 */
+	uint32_t fm_npi;	/**< FM Normal Pending Interrupts 0xd4 */
+	uint32_t fmfp_exte;	/**< FPM External Requests Enable 0xd8 */
+	uint32_t fmfp_ee;	/**< FPM Event & Mask 0xdc */
+	uint32_t fmfp_cev[4];	/**< FPM CPU Event 1-4 0xe0-0xef */
+	uint32_t res00f0[4];	/**< res 0xf0-0xff */
+	uint32_t fmfp_ps[50];	/**< FPM Port Status 0x100-0x1c7 */
+	uint32_t res01c8[14];	/**< res 0x1c8-0x1ff */
+	uint32_t fmfp_clfabc;	/**< FPM CLFABC 0x200 */
+	uint32_t fmfp_clfcc;	/**< FPM CLFCC 0x204 */
+	uint32_t fmfp_clfaval;	/**< FPM CLFAVAL 0x208 */
+	uint32_t fmfp_clfbval;	/**< FPM CLFBVAL 0x20c */
+	uint32_t fmfp_clfcval;	/**< FPM CLFCVAL 0x210 */
+	uint32_t fmfp_clfamsk;	/**< FPM CLFAMSK 0x214 */
+	uint32_t fmfp_clfbmsk;	/**< FPM CLFBMSK 0x218 */
+	uint32_t fmfp_clfcmsk;	/**< FPM CLFCMSK 0x21c */
+	uint32_t fmfp_clfamc;	/**< FPM CLFAMC 0x220 */
+	uint32_t fmfp_clfbmc;	/**< FPM CLFBMC 0x224 */
+	uint32_t fmfp_clfcmc;	/**< FPM CLFCMC 0x228 */
+	uint32_t fmfp_decceh;	/**< FPM DECCEH 0x22c */
+	uint32_t res0230[116];	/**< res 0x230 - 0x3ff */
+	uint32_t fmfp_ts[128];	/**< 0x400: FPM Task Status 0x400 - 0x5ff */
+	uint32_t res0600[0x400 - 384];
+};
+
+struct fman_bmi_regs {
+	uint32_t fmbm_init; /**< BMI Initialization 0x00 */
+	uint32_t fmbm_cfg1; /**< BMI Configuration 1 0x04 */
+	uint32_t fmbm_cfg2; /**< BMI Configuration 2 0x08 */
+	uint32_t res000c[5]; /**< 0x0c - 0x1f */
+	uint32_t fmbm_ievr; /**< Interrupt Event Register 0x20 */
+	uint32_t fmbm_ier; /**< Interrupt Enable Register 0x24 */
+	uint32_t fmbm_ifr; /**< Interrupt Force Register 0x28 */
+	uint32_t res002c[5]; /**< 0x2c - 0x3f */
+	uint32_t fmbm_arb[8]; /**< BMI Arbitration 0x40 - 0x5f */
+	uint32_t res0060[12]; /**<0x60 - 0x8f */
+	uint32_t fmbm_dtc[3]; /**< Debug Trap Counter 0x90 - 0x9b */
+	uint32_t res009c; /**< 0x9c */
+	uint32_t fmbm_dcv[3][4]; /**< Debug Compare val 0xa0-0xcf */
+	uint32_t fmbm_dcm[3][4]; /**< Debug Compare Mask 0xd0-0xff */
+	uint32_t fmbm_gde; /**< BMI Global Debug Enable 0x100 */
+	uint32_t fmbm_pp[63]; /**< BMI Port Parameters 0x104 - 0x1ff */
+	uint32_t res0200; /**< 0x200 */
+	uint32_t fmbm_pfs[63]; /**< BMI Port FIFO Size 0x204 - 0x2ff */
+	uint32_t res0300; /**< 0x300 */
+	uint32_t fmbm_spliodn[63]; /**< Port Partition ID 0x304 - 0x3ff */
+};
+
+struct fman_qmi_regs {
+	uint32_t fmqm_gc; /**< General Configuration Register 0x00 */
+	uint32_t res0004; /**< 0x04 */
+	uint32_t fmqm_eie; /**< Error Interrupt Event Register 0x08 */
+	uint32_t fmqm_eien; /**< Error Interrupt Enable Register 0x0c */
+	uint32_t fmqm_eif; /**< Error Interrupt Force Register 0x10 */
+	uint32_t fmqm_ie; /**< Interrupt Event Register 0x14 */
+	uint32_t fmqm_ien; /**< Interrupt Enable Register 0x18 */
+	uint32_t fmqm_if; /**< Interrupt Force Register 0x1c */
+	uint32_t fmqm_gs; /**< Global Status Register 0x20 */
+	uint32_t fmqm_ts; /**< Task Status Register 0x24 */
+	uint32_t fmqm_etfc; /**< Enqueue Total Frame Counter 0x28 */
+	uint32_t fmqm_dtfc; /**< Dequeue Total Frame Counter 0x2c */
+	uint32_t fmqm_dc0; /**< Dequeue Counter 0 0x30 */
+	uint32_t fmqm_dc1; /**< Dequeue Counter 1 0x34 */
+	uint32_t fmqm_dc2; /**< Dequeue Counter 2 0x38 */
+	uint32_t fmqm_dc3; /**< Dequeue Counter 3 0x3c */
+	uint32_t fmqm_dfdc; /**< Dequeue FQID from Default Counter 0x40 */
+	uint32_t fmqm_dfcc; /**< Dequeue FQID from Context Counter 0x44 */
+	uint32_t fmqm_dffc; /**< Dequeue FQID from FD Counter 0x48 */
+	uint32_t fmqm_dcc; /**< Dequeue Confirm Counter 0x4c */
+	uint32_t res0050[7]; /**< 0x50 - 0x6b */
+	uint32_t fmqm_tapc; /**< Tnum Aging Period Control 0x6c */
+	uint32_t fmqm_dmcvc; /**< Dequeue MAC Command Valid Counter 0x70 */
+	uint32_t fmqm_difdcc; /**< Dequeue Invalid FD Command Counter 0x74 */
+	uint32_t fmqm_da1v; /**< Dequeue A1 Valid Counter 0x78 */
+	uint32_t res007c; /**< 0x7c */
+	uint32_t fmqm_dtc; /**< 0x80 Debug Trap Counter 0x80 */
+	uint32_t fmqm_efddd; /**< 0x84 Enqueue Frame desc Dynamic dbg 0x84 */
+	uint32_t res0088[2]; /**< 0x88 - 0x8f */
+	struct {
+		uint32_t fmqm_dtcfg1; /**< 0x90 dbg trap cfg 1 Register 0x00 */
+		uint32_t fmqm_dtval1; /**< Debug Trap Value 1 Register 0x04 */
+		uint32_t fmqm_dtm1; /**< Debug Trap Mask 1 Register 0x08 */
+		uint32_t fmqm_dtc1; /**< Debug Trap Counter 1 Register 0x0c */
+		uint32_t fmqm_dtcfg2; /**< dbg Trap cfg 2 Register 0x10 */
+		uint32_t fmqm_dtval2; /**< Debug Trap Value 2 Register 0x14 */
+		uint32_t fmqm_dtm2; /**< Debug Trap Mask 2 Register 0x18 */
+		uint32_t res001c; /**< 0x1c */
+	} dbg_traps[3]; /**< 0x90 - 0xef */
+	uint8_t res00f0[0x400 - 0xf0]; /**< 0xf0 - 0x3ff */
+};
+
+struct fman_dma_regs {
+	uint32_t fmdmsr; /**< FM DMA status register 0x00 */
+	uint32_t fmdmmr; /**< FM DMA mode register 0x04 */
+	uint32_t fmdmtr; /**< FM DMA bus threshold register 0x08 */
+	uint32_t fmdmhy; /**< FM DMA bus hysteresis register 0x0c */
+	uint32_t fmdmsetr; /**< FM DMA SOS emergency Threshold Register 0x10 */
+	uint32_t fmdmtah; /**< FM DMA transfer bus address high reg 0x14 */
+	uint32_t fmdmtal; /**< FM DMA transfer bus address low reg 0x18 */
+	uint32_t fmdmtcid; /**< FM DMA transfer bus communication ID reg 0x1c */
+	uint32_t fmdmra; /**< FM DMA bus internal ram address register 0x20 */
+	uint32_t fmdmrd; /**< FM DMA bus internal ram data register 0x24 */
+	uint32_t fmdmwcr; /**< FM DMA CAM watchdog counter value 0x28 */
+	uint32_t fmdmebcr; /**< FM DMA CAM base in MURAM register 0x2c */
+	uint32_t fmdmccqdr; /**< FM DMA CAM and CMD Queue Debug reg 0x30 */
+	uint32_t fmdmccqvr1; /**< FM DMA CAM and CMD Queue Value reg #1 0x34 */
+	uint32_t fmdmccqvr2; /**< FM DMA CAM and CMD Queue Value reg #2 0x38 */
+	uint32_t fmdmcqvr3; /**< FM DMA CMD Queue Value register #3 0x3c */
+	uint32_t fmdmcqvr4; /**< FM DMA CMD Queue Value register #4 0x40 */
+	uint32_t fmdmcqvr5; /**< FM DMA CMD Queue Value register #5 0x44 */
+	uint32_t fmdmsefrc; /**< FM DMA Semaphore Entry Full Reject Cntr 0x48 */
+	uint32_t fmdmsqfrc; /**< FM DMA Semaphore Queue Full Reject Cntr 0x4c */
+	uint32_t fmdmssrc; /**< FM DMA Semaphore SYNC Reject Counter 0x50 */
+	uint32_t fmdmdcr;  /**< FM DMA Debug Counter 0x54 */
+	uint32_t fmdmemsr; /**< FM DMA Emergency Smoother Register 0x58 */
+	uint32_t res005c; /**< 0x5c */
+	uint32_t fmdmplr[FMAN_LIODN_TBL / 2]; /**< DMA LIODN regs 0x60-0xdf */
+	uint32_t res00e0[0x400 - 56];
+};
+
+struct fman_rg {
+	struct fman_fpm_regs *fpm_rg;
+	struct fman_dma_regs *dma_rg;
+	struct fman_bmi_regs *bmi_rg;
+	struct fman_qmi_regs *qmi_rg;
+};
+
+enum fman_dma_cache_override {
+	E_FMAN_DMA_NO_CACHE_OR = 0, /**< No override of the Cache field */
+	E_FMAN_DMA_NO_STASH_DATA, /**< No data stashing in system level cache */
+	E_FMAN_DMA_MAY_STASH_DATA, /**< Stashing allowed in sys level cache */
+	E_FMAN_DMA_STASH_DATA /**< Stashing performed in system level cache */
+};
+
+enum fman_dma_aid_mode {
+	E_FMAN_DMA_AID_OUT_PORT_ID = 0,           /**< 4 LSB of PORT_ID */
+	E_FMAN_DMA_AID_OUT_TNUM                   /**< 4 LSB of TNUM */
+};
+
+enum fman_dma_dbg_cnt_mode {
+	E_FMAN_DMA_DBG_NO_CNT = 0, /**< No counting */
+	E_FMAN_DMA_DBG_CNT_DONE, /**< Count DONE commands */
+	E_FMAN_DMA_DBG_CNT_COMM_Q_EM, /**< command Q emergency signal */
+	E_FMAN_DMA_DBG_CNT_INT_READ_EM, /**< Read buf emergency signal */
+	E_FMAN_DMA_DBG_CNT_INT_WRITE_EM, /**< Write buf emergency signal */
+	E_FMAN_DMA_DBG_CNT_FPM_WAIT, /**< FPM WAIT signal */
+	E_FMAN_DMA_DBG_CNT_SIGLE_BIT_ECC, /**< Single bit ECC errors */
+	E_FMAN_DMA_DBG_CNT_RAW_WAR_PROT /**< RAW & WAR protection counter */
+};
+
+enum fman_dma_emergency_level {
+	E_FMAN_DMA_EM_EBS = 0, /**< EBS emergency */
+	E_FMAN_DMA_EM_SOS /**< SOS emergency */
+};
+
+enum fman_catastrophic_err {
+	E_FMAN_CATAST_ERR_STALL_PORT = 0, /**< Port_ID stalled reset required */
+	E_FMAN_CATAST_ERR_STALL_TASK /**< Only erroneous task is stalled */
+};
+
+enum fman_dma_err {
+	E_FMAN_DMA_ERR_CATASTROPHIC = 0, /**< Catastrophic DMA error */
+	E_FMAN_DMA_ERR_REPORT /**< Reported DMA error */
+};
+
+struct fman_cfg {
+	uint16_t	liodn_bs_pr_port[FMAN_LIODN_TBL];/* base per port */
+	bool		en_counters;
+	uint8_t		disp_limit_tsh;
+	uint8_t		prs_disp_tsh;
+	uint8_t		plcr_disp_tsh;
+	uint8_t		kg_disp_tsh;
+	uint8_t		bmi_disp_tsh;
+	uint8_t		qmi_enq_disp_tsh;
+	uint8_t		qmi_deq_disp_tsh;
+	uint8_t		fm_ctl1_disp_tsh;
+	uint8_t		fm_ctl2_disp_tsh;
+	enum fman_dma_cache_override	dma_cache_override;
+	enum fman_dma_aid_mode		dma_aid_mode;
+	bool		dma_aid_override;
+	uint8_t		dma_axi_dbg_num_of_beats;
+	uint8_t		dma_cam_num_of_entries;
+	uint32_t	dma_watchdog;
+	uint8_t		dma_comm_qtsh_asrt_emer;
+	uint8_t		dma_write_buf_tsh_asrt_emer;
+	uint8_t		dma_read_buf_tsh_asrt_emer;
+	uint8_t		dma_comm_qtsh_clr_emer;
+	uint8_t		dma_write_buf_tsh_clr_emer;
+	uint8_t		dma_read_buf_tsh_clr_emer;
+	uint32_t	dma_sos_emergency;
+	enum fman_dma_dbg_cnt_mode	dma_dbg_cnt_mode;
+	bool		dma_stop_on_bus_error;
+	bool		dma_en_emergency;
+	uint32_t	dma_emergency_bus_select;
+	enum fman_dma_emergency_level	dma_emergency_level;
+	bool		dma_en_emergency_smoother;
+	uint32_t	dma_emergency_switch_counter;
+	bool		halt_on_external_activ;
+	bool		halt_on_unrecov_ecc_err;
+	enum fman_catastrophic_err	catastrophic_err;
+	enum fman_dma_err		dma_err;
+	bool		en_muram_test_mode;
+	bool		en_iram_test_mode;
+	bool		external_ecc_rams_enable;
+	uint16_t	tnum_aging_period;
+	uint32_t	exceptions;
+	uint16_t	clk_freq;
+	bool		pedantic_dma;
+	uint32_t	cam_base_addr;
+	uint32_t	fifo_base_addr;
+	uint32_t	total_fifo_size;
+	uint8_t		total_num_of_tasks;
+	bool		qmi_deq_option_support;
+	uint32_t	qmi_def_tnums_thresh;
+	bool		fman_partition_array;
+	uint8_t		num_of_fman_ctrl_evnt_regs;
+};
+
+/**************************************************************************//**
+ @Description       Exceptions
+*//***************************************************************************/
+#define FMAN_EX_DMA_BUS_ERROR			0x80000000
+#define FMAN_EX_DMA_READ_ECC			0x40000000
+#define FMAN_EX_DMA_SYSTEM_WRITE_ECC		0x20000000
+#define FMAN_EX_DMA_FM_WRITE_ECC		0x10000000
+#define FMAN_EX_FPM_STALL_ON_TASKS		0x08000000
+#define FMAN_EX_FPM_SINGLE_ECC			0x04000000
+#define FMAN_EX_FPM_DOUBLE_ECC			0x02000000
+#define FMAN_EX_QMI_SINGLE_ECC			0x01000000
+#define FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID	0x00800000
+#define FMAN_EX_QMI_DOUBLE_ECC			0x00400000
+#define FMAN_EX_BMI_LIST_RAM_ECC		0x00200000
+#define FMAN_EX_BMI_PIPELINE_ECC		0x00100000
+#define FMAN_EX_BMI_STATISTICS_RAM_ECC		0x00080000
+#define FMAN_EX_IRAM_ECC			0x00040000
+#define FMAN_EX_NURAM_ECC			0x00020000
+#define FMAN_EX_BMI_DISPATCH_RAM_ECC		0x00010000
+
+enum fman_exceptions {
+	E_FMAN_EX_DMA_BUS_ERROR = 0, /**< DMA bus error. */
+	E_FMAN_EX_DMA_READ_ECC, /**< Read Buffer ECC error */
+	E_FMAN_EX_DMA_SYSTEM_WRITE_ECC, /**< Write Buffer ECC err on sys side */
+	E_FMAN_EX_DMA_FM_WRITE_ECC, /**< Write Buffer ECC error on FM side */
+	E_FMAN_EX_FPM_STALL_ON_TASKS, /**< Stall of tasks on FPM */
+	E_FMAN_EX_FPM_SINGLE_ECC, /**< Single ECC on FPM. */
+	E_FMAN_EX_FPM_DOUBLE_ECC, /**< Double ECC error on FPM ram access */
+	E_FMAN_EX_QMI_SINGLE_ECC, /**< Single ECC on QMI. */
+	E_FMAN_EX_QMI_DOUBLE_ECC, /**< Double bit ECC occurred on QMI */
+	E_FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< DeQ from unknown port id */
+	E_FMAN_EX_BMI_LIST_RAM_ECC, /**< Linked List RAM ECC error */
+	E_FMAN_EX_BMI_STORAGE_PROFILE_ECC, /**< storage profile */
+	E_FMAN_EX_BMI_STATISTICS_RAM_ECC, /**< Statistics RAM ECC Err Enable */
+	E_FMAN_EX_BMI_DISPATCH_RAM_ECC, /**< Dispatch RAM ECC Error Enable */
+	E_FMAN_EX_IRAM_ECC, /**< Double bit ECC occurred on IRAM*/
+	E_FMAN_EX_MURAM_ECC /**< Double bit ECC occurred on MURAM*/
+};
+
+enum fman_counters {
+	E_FMAN_COUNTERS_ENQ_TOTAL_FRAME = 0, /**< QMI tot enQ frames counter */
+	E_FMAN_COUNTERS_DEQ_TOTAL_FRAME, /**< QMI tot deQ frames counter */
+	E_FMAN_COUNTERS_DEQ_0, /**< QMI 0 frames from QMan counter */
+	E_FMAN_COUNTERS_DEQ_1, /**< QMI 1 frames from QMan counter */
+	E_FMAN_COUNTERS_DEQ_2, /**< QMI 2 frames from QMan counter */
+	E_FMAN_COUNTERS_DEQ_3, /**< QMI 3 frames from QMan counter */
+	E_FMAN_COUNTERS_DEQ_FROM_DEFAULT, /**< QMI deQ from dflt queue cntr */
+	E_FMAN_COUNTERS_DEQ_FROM_CONTEXT, /**< QMI deQ from FQ context cntr */
+	E_FMAN_COUNTERS_DEQ_FROM_FD, /**< QMI deQ from FD command field cntr */
+	E_FMAN_COUNTERS_DEQ_CONFIRM, /**< QMI dequeue confirm counter */
+	E_FMAN_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT, /**< DMA full entry cntr */
+	E_FMAN_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT, /**< DMA full CAM Q cntr */
+	E_FMAN_COUNTERS_SEMAPHOR_SYNC_REJECT /**< DMA sync counter */
+};
+
+#define FPM_PRT_FM_CTL1	0x00000001
+#define FPM_PRT_FM_CTL2	0x00000002
+
+/**************************************************************************//**
+ @Description       DMA definitions
+*//***************************************************************************/
+
+/* masks */
+#define DMA_MODE_AID_OR			0x20000000
+#define DMA_MODE_SBER			0x10000000
+#define DMA_MODE_BER			0x00200000
+#define DMA_MODE_EB             0x00100000
+#define DMA_MODE_ECC			0x00000020
+#define DMA_MODE_PRIVILEGE_PROT	0x00001000
+#define DMA_MODE_SECURE_PROT	0x00000800
+#define DMA_MODE_EMER_READ		0x00080000
+#define DMA_MODE_EMER_WRITE		0x00040000
+#define DMA_MODE_CACHE_OR_MASK  0xC0000000
+#define DMA_MODE_CEN_MASK       0x0000E000
+#define DMA_MODE_DBG_MASK       0x00000380
+#define DMA_MODE_AXI_DBG_MASK   0x0F000000
+
+#define DMA_EMSR_EMSTR_MASK         0x0000FFFF
+
+#define DMA_TRANSFER_PORTID_MASK	0xFF000000
+#define DMA_TRANSFER_TNUM_MASK		0x00FF0000
+#define DMA_TRANSFER_LIODN_MASK		0x00000FFF
+
+#define DMA_HIGH_LIODN_MASK		0x0FFF0000
+#define DMA_LOW_LIODN_MASK		0x00000FFF
+
+#define DMA_STATUS_CMD_QUEUE_NOT_EMPTY	0x10000000
+#define DMA_STATUS_BUS_ERR		0x08000000
+#define DMA_STATUS_READ_ECC		0x04000000
+#define DMA_STATUS_SYSTEM_WRITE_ECC	0x02000000
+#define DMA_STATUS_FM_WRITE_ECC		0x01000000
+#define DMA_STATUS_SYSTEM_DPEXT_ECC	0x00800000
+#define DMA_STATUS_FM_DPEXT_ECC		0x00400000
+#define DMA_STATUS_SYSTEM_DPDAT_ECC	0x00200000
+#define DMA_STATUS_FM_DPDAT_ECC		0x00100000
+#define DMA_STATUS_FM_SPDAT_ECC		0x00080000
+
+#define FM_LIODN_BASE_MASK		0x00000FFF
+
+/* shifts */
+#define DMA_MODE_CACHE_OR_SHIFT			30
+#define DMA_MODE_BUS_PRI_SHIFT			16
+#define DMA_MODE_AXI_DBG_SHIFT			24
+#define DMA_MODE_CEN_SHIFT			13
+#define DMA_MODE_BUS_PROT_SHIFT			10
+#define DMA_MODE_DBG_SHIFT			7
+#define DMA_MODE_EMER_LVL_SHIFT			6
+#define DMA_MODE_AID_MODE_SHIFT			4
+#define DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS	16
+#define DMA_MODE_MAX_CAM_NUM_OF_ENTRIES		32
+
+#define DMA_THRESH_COMMQ_SHIFT			24
+#define DMA_THRESH_READ_INT_BUF_SHIFT		16
+
+#define DMA_LIODN_SHIFT				16
+
+#define DMA_TRANSFER_PORTID_SHIFT		24
+#define DMA_TRANSFER_TNUM_SHIFT			16
+
+/* sizes */
+#define DMA_MAX_WATCHDOG			0xffffffff
+
+/* others */
+#define DMA_CAM_SIZEOF_ENTRY			0x40
+#define DMA_CAM_ALIGN				0x1000
+#define DMA_CAM_UNITS				8
+
+/**************************************************************************//**
+ @Description       General defines
+*//***************************************************************************/
+
+#define FM_DEBUG_STATUS_REGISTER_OFFSET	0x000d1084UL
+#define FM_UCODE_DEBUG_INSTRUCTION	0x6ffff805UL
+
+/**************************************************************************//**
+ @Description       FPM defines
+*//***************************************************************************/
+
+/* masks */
+#define FPM_EV_MASK_DOUBLE_ECC		0x80000000
+#define FPM_EV_MASK_STALL		0x40000000
+#define FPM_EV_MASK_SINGLE_ECC		0x20000000
+#define FPM_EV_MASK_RELEASE_FM		0x00010000
+#define FPM_EV_MASK_DOUBLE_ECC_EN	0x00008000
+#define FPM_EV_MASK_STALL_EN		0x00004000
+#define FPM_EV_MASK_SINGLE_ECC_EN	0x00002000
+#define FPM_EV_MASK_EXTERNAL_HALT	0x00000008
+#define FPM_EV_MASK_ECC_ERR_HALT	0x00000004
+
+#define FPM_RAM_RAMS_ECC_EN		0x80000000
+#define FPM_RAM_IRAM_ECC_EN		0x40000000
+#define FPM_RAM_MURAM_ECC		0x00008000
+#define FPM_RAM_IRAM_ECC		0x00004000
+#define FPM_RAM_MURAM_TEST_ECC		0x20000000
+#define FPM_RAM_IRAM_TEST_ECC		0x10000000
+#define FPM_RAM_RAMS_ECC_EN_SRC_SEL	0x08000000
+
+#define FPM_IRAM_ECC_ERR_EX_EN		0x00020000
+#define FPM_MURAM_ECC_ERR_EX_EN		0x00040000
+
+#define FPM_REV1_MAJOR_MASK		0x0000FF00
+#define FPM_REV1_MINOR_MASK		0x000000FF
+
+#define FPM_REV2_INTEG_MASK		0x00FF0000
+#define FPM_REV2_ERR_MASK		0x0000FF00
+#define FPM_REV2_CFG_MASK		0x000000FF
+
+#define FPM_TS_FRACTION_MASK		0x0000FFFF
+#define FPM_TS_CTL_EN			0x80000000
+
+#define FPM_PRC_REALSE_STALLED		0x00800000
+
+#define FPM_PS_STALLED			0x00800000
+#define FPM_PS_FM_CTL1_SEL		0x80000000
+#define FPM_PS_FM_CTL2_SEL		0x40000000
+#define FPM_PS_FM_CTL_SEL_MASK	(FPM_PS_FM_CTL1_SEL | FPM_PS_FM_CTL2_SEL)
+
+#define FPM_RSTC_FM_RESET		0x80000000
+#define FPM_RSTC_10G0_RESET		0x04000000
+#define FPM_RSTC_1G0_RESET		0x40000000
+#define FPM_RSTC_1G1_RESET		0x20000000
+#define FPM_RSTC_1G2_RESET		0x10000000
+#define FPM_RSTC_1G3_RESET		0x08000000
+#define FPM_RSTC_1G4_RESET		0x02000000
+
+
+#define FPM_DISP_LIMIT_MASK             0x1F000000
+#define FPM_THR1_PRS_MASK               0xFF000000
+#define FPM_THR1_KG_MASK                0x00FF0000
+#define FPM_THR1_PLCR_MASK              0x0000FF00
+#define FPM_THR1_BMI_MASK               0x000000FF
+
+#define FPM_THR2_QMI_ENQ_MASK           0xFF000000
+#define FPM_THR2_QMI_DEQ_MASK           0x000000FF
+#define FPM_THR2_FM_CTL1_MASK           0x00FF0000
+#define FPM_THR2_FM_CTL2_MASK           0x0000FF00
+
+/* shifts */
+#define FPM_DISP_LIMIT_SHIFT		24
+
+#define FPM_THR1_PRS_SHIFT		24
+#define FPM_THR1_KG_SHIFT		16
+#define FPM_THR1_PLCR_SHIFT		8
+#define FPM_THR1_BMI_SHIFT		0
+
+#define FPM_THR2_QMI_ENQ_SHIFT		24
+#define FPM_THR2_QMI_DEQ_SHIFT		0
+#define FPM_THR2_FM_CTL1_SHIFT		16
+#define FPM_THR2_FM_CTL2_SHIFT		8
+
+#define FPM_EV_MASK_CAT_ERR_SHIFT	1
+#define FPM_EV_MASK_DMA_ERR_SHIFT	0
+
+#define FPM_REV1_MAJOR_SHIFT		8
+#define FPM_REV1_MINOR_SHIFT		0
+
+#define FPM_REV2_INTEG_SHIFT		16
+#define FPM_REV2_ERR_SHIFT		8
+#define FPM_REV2_CFG_SHIFT		0
+
+#define FPM_TS_INT_SHIFT		16
+
+#define FPM_PORT_FM_CTL_PORTID_SHIFT	24
+
+#define FPM_PS_FM_CTL_SEL_SHIFT		30
+#define FPM_PRC_ORA_FM_CTL_SEL_SHIFT	16
+
+#define FPM_DISP_LIMIT_SHIFT            24
+
+/* Interrupts defines */
+#define FPM_EVENT_FM_CTL_0		0x00008000
+#define FPM_EVENT_FM_CTL		0x0000FF00
+#define FPM_EVENT_FM_CTL_BRK		0x00000080
+
+/* others */
+#define FPM_MAX_DISP_LIMIT		31
+#define FPM_RSTC_FM_RESET               0x80000000
+#define FPM_RSTC_1G0_RESET              0x40000000
+#define FPM_RSTC_1G1_RESET              0x20000000
+#define FPM_RSTC_1G2_RESET              0x10000000
+#define FPM_RSTC_1G3_RESET              0x08000000
+#define FPM_RSTC_10G0_RESET             0x04000000
+#define FPM_RSTC_1G4_RESET              0x02000000
+#define FPM_RSTC_1G5_RESET              0x01000000
+#define FPM_RSTC_1G6_RESET              0x00800000
+#define FPM_RSTC_1G7_RESET              0x00400000
+#define FPM_RSTC_10G1_RESET             0x00200000
+/**************************************************************************//**
+ @Description       BMI defines
+*//***************************************************************************/
+/* masks */
+#define BMI_INIT_START				0x80000000
+#define BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC	0x80000000
+#define BMI_ERR_INTR_EN_LIST_RAM_ECC		0x40000000
+#define BMI_ERR_INTR_EN_STATISTICS_RAM_ECC	0x20000000
+#define BMI_ERR_INTR_EN_DISPATCH_RAM_ECC	0x10000000
+#define BMI_NUM_OF_TASKS_MASK			0x3F000000
+#define BMI_NUM_OF_EXTRA_TASKS_MASK		0x000F0000
+#define BMI_NUM_OF_DMAS_MASK			0x00000F00
+#define BMI_NUM_OF_EXTRA_DMAS_MASK		0x0000000F
+#define BMI_FIFO_SIZE_MASK			0x000003FF
+#define BMI_EXTRA_FIFO_SIZE_MASK		0x03FF0000
+#define BMI_CFG2_DMAS_MASK			0x0000003F
+#define BMI_TOTAL_FIFO_SIZE_MASK           0x07FF0000
+#define BMI_TOTAL_NUM_OF_TASKS_MASK        0x007F0000
+
+/* shifts */
+#define BMI_CFG2_TASKS_SHIFT		16
+#define BMI_CFG2_DMAS_SHIFT		0
+#define BMI_CFG1_FIFO_SIZE_SHIFT	16
+#define BMI_FIFO_SIZE_SHIFT		0
+#define BMI_EXTRA_FIFO_SIZE_SHIFT	16
+#define BMI_NUM_OF_TASKS_SHIFT		24
+#define BMI_EXTRA_NUM_OF_TASKS_SHIFT	16
+#define BMI_NUM_OF_DMAS_SHIFT		8
+#define BMI_EXTRA_NUM_OF_DMAS_SHIFT	0
+
+/* others */
+#define BMI_FIFO_ALIGN			0x100
+#define FMAN_BMI_FIFO_UNITS		0x100
+
+
+/**************************************************************************//**
+ @Description       QMI defines
+*//***************************************************************************/
+/* masks */
+#define QMI_CFG_ENQ_EN			0x80000000
+#define QMI_CFG_DEQ_EN			0x40000000
+#define QMI_CFG_EN_COUNTERS		0x10000000
+#define QMI_CFG_SOFT_RESET		0x01000000
+#define QMI_CFG_DEQ_MASK		0x0000003F
+#define QMI_CFG_ENQ_MASK		0x00003F00
+
+#define QMI_ERR_INTR_EN_DOUBLE_ECC	0x80000000
+#define QMI_ERR_INTR_EN_DEQ_FROM_DEF	0x40000000
+#define QMI_INTR_EN_SINGLE_ECC		0x80000000
+
+/* shifts */
+#define QMI_CFG_ENQ_SHIFT		8
+#define QMI_TAPC_TAP			22
+
+#define QMI_GS_HALT_NOT_BUSY            0x00000002
+
+
+/**************************************************************************//**
+ @Description       IRAM defines
+*//***************************************************************************/
+/* masks */
+#define IRAM_IADD_AIE			0x80000000
+#define IRAM_READY			0x80000000
+
+uint32_t fman_get_bmi_err_event(struct fman_bmi_regs *bmi_rg);
+uint32_t fman_get_qmi_err_event(struct fman_qmi_regs *qmi_rg);
+uint32_t fman_get_dma_com_id(struct fman_dma_regs *dma_rg);
+uint64_t fman_get_dma_addr(struct fman_dma_regs *dma_rg);
+uint32_t fman_get_dma_err_event(struct fman_dma_regs *dma_rg);
+uint32_t fman_get_fpm_err_event(struct fman_fpm_regs *fpm_rg);
+uint32_t fman_get_muram_err_event(struct fman_fpm_regs *fpm_rg);
+uint32_t fman_get_iram_err_event(struct fman_fpm_regs *fpm_rg);
+uint32_t fman_get_qmi_event(struct fman_qmi_regs *qmi_rg);
+uint32_t fman_get_fpm_error_interrupts(struct fman_fpm_regs *fpm_rg);
+uint32_t fman_get_ctrl_intr(struct fman_fpm_regs *fpm_rg,
+				uint8_t event_reg_id);
+uint8_t fman_get_qmi_deq_th(struct fman_qmi_regs *qmi_rg);
+uint8_t fman_get_qmi_enq_th(struct fman_qmi_regs *qmi_rg);
+uint16_t fman_get_size_of_fifo(struct fman_bmi_regs *bmi_rg, uint8_t port_id);
+uint32_t fman_get_total_fifo_size(struct fman_bmi_regs *bmi_rg);
+uint16_t fman_get_size_of_extra_fifo(struct fman_bmi_regs *bmi_rg,
+				uint8_t port_id);
+uint8_t fman_get_num_of_tasks(struct fman_bmi_regs *bmi_rg, uint8_t port_id);
+uint8_t fman_get_num_extra_tasks(struct fman_bmi_regs *bmi_rg,
+				uint8_t port_id);
+uint8_t fman_get_num_of_dmas(struct fman_bmi_regs *bmi_rg, uint8_t port_id);
+uint8_t fman_get_num_extra_dmas(struct fman_bmi_regs *bmi_rg,
+				uint8_t port_id);
+uint32_t fman_get_normal_pending(struct fman_fpm_regs *fpm_rg);
+uint32_t fman_get_controller_event(struct fman_fpm_regs *fpm_rg,
+					uint8_t reg_id);
+uint32_t fman_get_error_pending(struct fman_fpm_regs *fpm_rg);
+void fman_get_revision(struct fman_fpm_regs *fpm_rg, uint8_t *major,
+				uint8_t *minor);
+uint32_t fman_get_counter(struct fman_rg *fman_rg,
+				enum fman_counters reg_name);
+uint32_t fman_get_dma_status(struct fman_dma_regs *dma_rg);
+
+
+int fman_set_erratum_10gmac_a004_wa(struct fman_fpm_regs *fpm_rg);
+void fman_set_ctrl_intr(struct fman_fpm_regs *fpm_rg, uint8_t event_reg_id,
+				uint32_t enable_events);
+void fman_set_num_of_riscs_per_port(struct fman_fpm_regs *fpm_rg,
+				uint8_t port_id,
+				uint8_t num_fman_ctrls,
+				uint32_t or_fman_ctrl);
+void fman_set_order_restoration_per_port(struct fman_fpm_regs *fpm_rg,
+				uint8_t port_id,
+				bool independent_mode,
+				bool is_rx_port);
+void fman_set_qmi_enq_th(struct fman_qmi_regs *qmi_rg, uint8_t val);
+void fman_set_qmi_deq_th(struct fman_qmi_regs *qmi_rg, uint8_t val);
+void fman_set_liodn_per_port(struct fman_rg *fman_rg,
+				uint8_t port_id,
+				uint16_t liodn_base,
+				uint16_t liodn_offset);
+void fman_set_size_of_fifo(struct fman_bmi_regs *bmi_rg,
+				uint8_t port_id,
+				uint32_t size_of_fifo,
+				uint32_t extra_size_of_fifo);
+void fman_set_num_of_tasks(struct fman_bmi_regs *bmi_rg,
+				uint8_t port_id,
+				uint8_t num_of_tasks,
+				uint8_t num_of_extra_tasks);
+void fman_set_num_of_open_dmas(struct fman_bmi_regs *bmi_rg,
+				uint8_t port_id,
+				uint8_t num_of_open_dmas,
+				uint8_t num_of_extra_open_dmas,
+				uint8_t total_num_of_dmas);
+void fman_set_ports_bandwidth(struct fman_bmi_regs *bmi_rg, uint8_t *weights);
+int fman_set_exception(struct fman_rg *fman_rg,
+				enum fman_exceptions exception,
+				bool enable);
+void fman_set_dma_emergency(struct fman_dma_regs *dma_rg, bool is_write,
+				bool enable);
+void fman_set_dma_ext_bus_pri(struct fman_dma_regs *dma_rg, uint32_t pri);
+void fman_set_congestion_group_pfc_priority(uint32_t *cpg_rg,
+			    	                        uint32_t congestion_group_id,
+				                            uint8_t priority_bit_map);
+
+
+void fman_defconfig(struct fman_cfg *cfg, bool is_master);
+void fman_regconfig(struct fman_rg *fman_rg, struct fman_cfg *cfg);
+int fman_fpm_init(struct fman_fpm_regs *fpm_rg, struct fman_cfg *cfg);
+int fman_bmi_init(struct fman_bmi_regs *bmi_rg, struct fman_cfg *cfg);
+int fman_qmi_init(struct fman_qmi_regs *qmi_rg, struct fman_cfg *cfg);
+int fman_dma_init(struct fman_dma_regs *dma_rg, struct fman_cfg *cfg);
+void fman_free_resources(struct fman_rg *fman_rg);
+int fman_enable(struct fman_rg *fman_rg, struct fman_cfg *cfg);
+void fman_reset(struct fman_fpm_regs *fpm_rg);
+void fman_resume(struct fman_fpm_regs *fpm_rg);
+
+
+void fman_enable_time_stamp(struct fman_fpm_regs *fpm_rg,
+				uint8_t count1ubit,
+				uint16_t fm_clk_freq);
+void fman_enable_rams_ecc(struct fman_fpm_regs *fpm_rg);
+void fman_qmi_disable_dispatch_limit(struct fman_fpm_regs *fpm_rg);
+void fman_disable_rams_ecc(struct fman_fpm_regs *fpm_rg);
+void fman_resume_stalled_port(struct fman_fpm_regs *fpm_rg, uint8_t port_id);
+int fman_reset_mac(struct fman_fpm_regs *fpm_rg, uint8_t macId, bool is_10g);
+bool fman_is_port_stalled(struct fman_fpm_regs *fpm_rg, uint8_t port_id);
+bool fman_rams_ecc_is_external_ctl(struct fman_fpm_regs *fpm_rg);
+bool fman_is_qmi_halt_not_busy_state(struct fman_qmi_regs *qmi_rg);
+int fman_modify_counter(struct fman_rg *fman_rg,
+				enum fman_counters reg_name,
+				uint32_t val);
+void fman_force_intr(struct fman_rg *fman_rg,
+				enum fman_exceptions exception);
+void fman_set_vsp_window(struct fman_bmi_regs *bmi_rg,
+			    	     uint8_t port_id,
+				         uint8_t base_storage_profile,
+				         uint8_t log2_num_of_profiles);
+
+/**************************************************************************//**
+ @Description       default values
+*//***************************************************************************/
+#define DEFAULT_CATASTROPHIC_ERR                E_FMAN_CATAST_ERR_STALL_PORT
+#define DEFAULT_DMA_ERR                         E_FMAN_DMA_ERR_CATASTROPHIC
+#define DEFAULT_HALT_ON_EXTERNAL_ACTIVATION     FALSE   /* do not change! if changed, must be disabled for rev1 ! */
+#define DEFAULT_HALT_ON_UNRECOVERABLE_ECC_ERROR FALSE   /* do not change! if changed, must be disabled for rev1 ! */
+#define DEFAULT_EXTERNAL_ECC_RAMS_ENABLE        FALSE
+#define DEFAULT_AID_OVERRIDE                    FALSE
+#define DEFAULT_AID_MODE                        E_FMAN_DMA_AID_OUT_TNUM
+#define DEFAULT_DMA_COMM_Q_LOW                  0x2A
+#define DEFAULT_DMA_COMM_Q_HIGH                 0x3F
+#define DEFAULT_CACHE_OVERRIDE                  E_FMAN_DMA_NO_CACHE_OR
+#define DEFAULT_DMA_CAM_NUM_OF_ENTRIES          64
+#define DEFAULT_DMA_DBG_CNT_MODE                E_FMAN_DMA_DBG_NO_CNT
+#define DEFAULT_DMA_EN_EMERGENCY                FALSE
+#define DEFAULT_DMA_SOS_EMERGENCY               0
+#define DEFAULT_DMA_WATCHDOG                    0 /* disabled */
+#define DEFAULT_DMA_EN_EMERGENCY_SMOOTHER       FALSE
+#define DEFAULT_DMA_EMERGENCY_SWITCH_COUNTER    0
+#define DEFAULT_DISP_LIMIT                      0
+#define DEFAULT_PRS_DISP_TH                     16
+#define DEFAULT_PLCR_DISP_TH                    16
+#define DEFAULT_KG_DISP_TH                      16
+#define DEFAULT_BMI_DISP_TH                     16
+#define DEFAULT_QMI_ENQ_DISP_TH                 16
+#define DEFAULT_QMI_DEQ_DISP_TH                 16
+#define DEFAULT_FM_CTL1_DISP_TH                 16
+#define DEFAULT_FM_CTL2_DISP_TH                 16
+#define DEFAULT_TNUM_AGING_PERIOD               4
+
 
 #endif /* __FSL_FMAN_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h
index 628ef3a..940087e 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h
@@ -41,8 +41,8 @@
  *
  * To prepare dTSEC block for transfer use the following call sequence:
  *
- * - fman_dtsec_defconfig() - This step is optional and yet recommended. Its use is
- * to obtain the default dTSEC configuration parameters.
+ * - fman_dtsec_defconfig() - This step is optional and yet recommended. Its
+ * use is to obtain the default dTSEC configuration parameters.
  *
  * - Change dtsec configuration in &dtsec_cfg. This structure will be used
  * to customize the dTSEC behavior.
@@ -63,12 +63,12 @@
 /**
  * DOC: dTSEC Graceful stop
  *
- * To temporary stop dTSEC activity use fman_dtsec_stop_tx() and fman_dtsec_stop_rx().
- * Note that these functions request dTSEC graceful stop but return before this
- * stop is complete.  To query for graceful stop completion use
- * fman_dtsec_get_event() and check DTSEC_IEVENT_GTSC and DTSEC_IEVENT_GRSC bits.
- * Alternatively the dTSEC interrupt mask can be set to enable graceful stop
- * interrupts.
+ * To temporary stop dTSEC activity use fman_dtsec_stop_tx() and
+ * fman_dtsec_stop_rx(). Note that these functions request dTSEC graceful stop
+ * but return before this stop is complete.  To query for graceful stop
+ * completion use fman_dtsec_get_event() and check DTSEC_IEVENT_GTSC and
+ * DTSEC_IEVENT_GRSC bits. Alternatively the dTSEC interrupt mask can be set to
+ * enable graceful stop interrupts.
  *
  * To resume operation after graceful stop use fman_dtsec_start_tx() and
  * fman_dtsec_start_rx().
@@ -96,8 +96,8 @@
  * To poll for event status use the fman_dtsec_get_event() function.
  * To configure the interrupt mask use fman_dtsec_enable_interrupt() and
  * fman_dtsec_disable_interrupt() functions.
- * After servicing a dTSEC interrupt use fman_dtsec_ack_event to reset the serviced
- * event bit.
+ * After servicing a dTSEC interrupt use fman_dtsec_ack_event to reset the
+ * serviced event bit.
  *
  * The following events may be signaled by dTSEC hardware:
  *
@@ -185,7 +185,7 @@
 #define DTSEC_IMASK_TDPEEN	0x00000002
 #define DTSEC_IMASK_RDPEEN	0x00000001
 
-#define DTSEC_EVENTS_MASK                              \
+#define DTSEC_EVENTS_MASK					\
 	((uint32_t)(DTSEC_IMASK_BREN    | \
 				DTSEC_IMASK_RXCEN   | \
 				DTSEC_IMASK_BTEN    | \
@@ -614,6 +614,17 @@ enum dtsec_stat_counters {
 	E_DTSEC_STAT_TDRP
 };
 
+enum dtsec_stat_level {
+	/* No statistics */
+	E_MAC_STAT_NONE = 0,
+	/* Only RMON MIB group 1 (ether stats). Optimized for performance */
+	E_MAC_STAT_MIB_GRP1,
+	/* Only error counters are available. Optimized for performance */
+	E_MAC_STAT_PARTIAL,
+	/* All counters available. Not optimized for performance */
+	E_MAC_STAT_FULL
+};
+
 
 /**
  * struct dtsec_cfg - dTSEC configuration
@@ -679,8 +690,8 @@ enum dtsec_stat_counters {
  *			precedes the layer 2 header.
  *
  * This structure contains basic dTSEC configuration and must be passed to
- * fman_dtsec_init() function.  A default set of configuration values can be obtained
- * by calling fman_dtsec_defconfig().
+ * fman_dtsec_init() function.  A default set of configuration values can be
+ * obtained by calling fman_dtsec_defconfig().
  */
 struct dtsec_cfg {
 	bool		halfdup_on;
@@ -795,8 +806,9 @@ uint32_t fman_dtsec_get_revision(struct dtsec_regs *regs);
  * @macaddr:    MAC address array
  *
  * This function sets MAC station address.  To enable unicast reception call
- * this after fman_dtsec_init().  While promiscuous mode is disabled dTSEC will match
- * the destination address of received unicast frames against this address.
+ * this after fman_dtsec_init().  While promiscuous mode is disabled dTSEC will
+ * match the destination address of received unicast frames against this
+ * address.
  */
 void fman_dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
 
@@ -815,8 +827,8 @@ void fman_dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
  * Use this function to enable/disable dTSEC L2 address filtering.  If the
  * address filtering is disabled all unicast packets are accepted.
  * To set dTSEC in promiscuous mode call both fman_dtsec_set_uc_promisc() and
- * fman_dtsec_set_mc_promisc() to disable filtering for both unicast and multicast
- * addresses.
+ * fman_dtsec_set_mc_promisc() to disable filtering for both unicast and
+ * multicast addresses.
  */
 void fman_dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable);
 
@@ -828,8 +840,8 @@ void fman_dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable);
  * @full_dx:	True for full-duplex, false for half-duplex.
  *
  * This function configures the MAC to function and the desired rates.  Use it
- * to configure dTSEC after fman_dtsec_init() and whenever the link speed changes
- * (for instance following PHY auto-negociation).
+ * to configure dTSEC after fman_dtsec_init() and whenever the link speed
+ * changes (for instance following PHY auto-negociation).
  *
  * Returns: 0 if successful, an error code otherwise.
  */
@@ -983,6 +995,18 @@ void fman_dtsec_set_ts(struct dtsec_regs *regs, bool en);
 void fman_dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable);
 
 /**
+ * dtsec_set_hash_table() - insert a crc code into thr filter table
+ * @regs:	Pointer to dTSEC register block
+ * @crc:	crc to insert
+ * @mcast:	true is this is a multicast address
+ * @ghtx:	true if we are in ghtx mode
+ *
+ * This function inserts a crc code into the filter table.
+ */
+void fman_dtsec_set_hash_table(struct dtsec_regs *regs, uint32_t crc,
+	bool mcast, bool ghtx);
+
+/**
  * fman_dtsec_reset_filter_table() - Resets the address filtering table
  * @regs:	Pointer to dTSEC register block
  * @mcast:	Reset multicast entries
@@ -995,7 +1019,8 @@ void fman_dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable);
  * This does not affect the primary nor the 15 additional addresses configured
  * using dtsec_set_address() or dtsec_set_match_address().
  */
-void fman_dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast);
+void fman_dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast,
+	bool ucast);
 
 /**
  * fman_dtsec_set_mc_promisc() - Set multicast promiscous mode
@@ -1020,7 +1045,8 @@ void fman_dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable);
  *
  * Returns: error if invalid @level value given.
  */
-int fman_dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level);
+int fman_dtsec_set_stat_level(struct dtsec_regs *regs,
+	enum dtsec_stat_level level);
 
 /**
  * fman_dtsec_reset_stat() - Completely resets all dTSEC HW counters
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
index 314463c..61e37b0 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
@@ -361,21 +361,25 @@ uint64_t fman_memac_get_counter(struct memac_regs *regs,
 	enum memac_counters reg_name);
 
 void fman_memac_set_tx_pause_frames(struct memac_regs *regs,
-	uint8_t priority,
-	uint16_t pauseTime,
-	uint16_t threshTime);
+	uint8_t priority, uint16_t pauseTime, uint16_t threshTime);
 
 uint16_t fman_memac_get_max_frame_len(struct memac_regs *regs);
 
-void fman_memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable);
+void fman_memac_set_exception(struct memac_regs *regs, uint32_t val,
+	bool enable);
 
 void fman_memac_reset_stat(struct memac_regs *regs);
 
 void fman_memac_reset(struct memac_regs *regs);
 
+void fman_memac_reset_filter_table(struct memac_regs *regs);
+
+void fman_memac_set_hash_table_entry(struct memac_regs *regs, uint32_t crc);
+
 void fman_memac_set_hash_table(struct memac_regs *regs, uint32_t val);
 
-void fman_memac_set_rx_ignore_pause_frames(struct memac_regs  *regs,bool enable);
+void fman_memac_set_rx_ignore_pause_frames(struct memac_regs *regs,
+	bool enable);
 
 uint32_t fman_memac_get_event(struct memac_regs *regs, uint32_t ev_mask);
 
@@ -384,8 +388,8 @@ void fman_memac_ack_event(struct memac_regs *regs, uint32_t ev_mask);
 uint32_t fman_memac_get_interrupt_mask(struct memac_regs *regs);
 
 void fman_memac_adjust_link(struct memac_regs *regs,
-        enum enet_interface iface_mode,
-        enum enet_speed speed, bool full_dx);
+	enum enet_interface iface_mode,
+	enum enet_speed speed, bool full_dx);
 
 
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac_mii_acc.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac_mii_acc.h
new file mode 100755
index 0000000..ff9aaa4
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac_mii_acc.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_MEMAC_MII_ACC_H
+#define __FSL_FMAN_MEMAC_MII_ACC_H
+
+#include "common/general.h"
+#include "fsl_enet.h"
+/* MII Management Registers */
+#define MDIO_CFG_CLK_DIV_MASK       0x0000ff80
+#define MDIO_CFG_CLK_DIV_SHIFT      7
+#define MDIO_CFG_HOLD_MASK          0x0000001c
+#define MDIO_CFG_ENC45              0x00000040
+#define MDIO_CFG_READ_ERR           0x00000002
+#define MDIO_CFG_BSY                0x00000001
+
+#define MDIO_CTL_PHY_ADDR_SHIFT     5
+#define MDIO_CTL_READ               0x00008000
+
+#define MDIO_DATA_BSY               0x80000000
+
+/*MEMAC Internal PHY Registers - SGMII */
+#define PHY_SGMII_CR_PHY_RESET          0x8000
+#define PHY_SGMII_CR_RESET_AN           0x0200
+#define PHY_SGMII_CR_DEF_VAL            0x1140
+#define PHY_SGMII_DEV_ABILITY_SGMII     0x4001
+#define PHY_SGMII_DEV_ABILITY_1000X     0x01A0
+#define PHY_SGMII_IF_MODE_AN            0x0002
+#define PHY_SGMII_IF_MODE_SGMII         0x0001
+#define PHY_SGMII_IF_MODE_1000X         0x0000
+
+/*----------------------------------------------------*/
+/* MII Configuration Control Memory Map Registers     */
+/*----------------------------------------------------*/
+struct memac_mii_access_mem_map {
+	uint32_t   mdio_cfg;       /* 0x030  */
+	uint32_t   mdio_ctrl;      /* 0x034  */
+	uint32_t   mdio_data;      /* 0x038  */
+	uint32_t   mdio_addr;      /* 0x03c  */
+};
+
+int fman_memac_mii_read_phy_reg(struct memac_mii_access_mem_map *mii_regs,
+	uint8_t phy_addr, uint8_t reg, uint16_t *data,
+	enum enet_speed enet_speed);
+int fman_memac_mii_write_phy_reg(struct memac_mii_access_mem_map *mii_regs,
+	uint8_t phy_addr, uint8_t reg, uint16_t data,
+	enum enet_speed enet_speed);
+
+#endif /* __MAC_API_MEMAC_MII_ACC_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
new file mode 100755
index 0000000..8a10164
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
@@ -0,0 +1,594 @@
+/*
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_PORT_H
+#define __FSL_FMAN_PORT_H
+
+#include "fsl_fman_sp.h"
+
+/** @Collection  Registers bit fields */
+
+/** @Description  BMI defines */
+#define BMI_EBD_EN				0x80000000
+
+#define BMI_PORT_CFG_EN				0x80000000
+#define BMI_PORT_CFG_FDOVR			0x02000000
+#define BMI_PORT_CFG_IM				0x01000000
+
+#define BMI_PORT_STATUS_BSY			0x80000000
+
+#define BMI_DMA_ATTR_SWP_SHIFT			FMAN_SP_DMA_ATTR_SWP_SHIFT
+#define BMI_DMA_ATTR_IC_STASH_ON		0x10000000
+#define BMI_DMA_ATTR_HDR_STASH_ON		0x04000000
+#define BMI_DMA_ATTR_SG_STASH_ON		0x01000000
+#define BMI_DMA_ATTR_WRITE_OPTIMIZE		FMAN_SP_DMA_ATTR_WRITE_OPTIMIZE
+
+#define BMI_RX_FIFO_PRI_ELEVATION_SHIFT		16
+#define BMI_RX_FIFO_THRESHOLD_ETHE		0x80000000
+
+#define BMI_TX_FRAME_END_CS_IGNORE_SHIFT	24
+#define BMI_RX_FRAME_END_CS_IGNORE_SHIFT	24
+#define BMI_RX_FRAME_END_CUT_SHIFT		16
+
+#define BMI_IC_TO_EXT_SHIFT			FMAN_SP_IC_TO_EXT_SHIFT
+#define BMI_IC_FROM_INT_SHIFT			FMAN_SP_IC_FROM_INT_SHIFT
+
+#define BMI_INT_BUF_MARG_SHIFT			28
+#define BMI_EXT_BUF_MARG_START_SHIFT		FMAN_SP_EXT_BUF_MARG_START_SHIFT
+
+#define BMI_CMD_MR_LEAC				0x00200000
+#define BMI_CMD_MR_SLEAC			0x00100000
+#define BMI_CMD_MR_MA				0x00080000
+#define BMI_CMD_MR_DEAS				0x00040000
+#define BMI_CMD_RX_MR_DEF			(BMI_CMD_MR_LEAC | \
+						BMI_CMD_MR_SLEAC | \
+						BMI_CMD_MR_MA | \
+						BMI_CMD_MR_DEAS)
+#define BMI_CMD_TX_MR_DEF			0
+#define BMI_CMD_OP_MR_DEF			(BMI_CMD_MR_DEAS | \
+						BMI_CMD_MR_MA)
+
+#define BMI_CMD_ATTR_ORDER			0x80000000
+#define BMI_CMD_ATTR_SYNC			0x02000000
+#define BMI_CMD_ATTR_COLOR_SHIFT		26
+
+#define BMI_FIFO_PIPELINE_DEPTH_SHIFT           12
+#define BMI_NEXT_ENG_FD_BITS_SHIFT		24
+#define BMI_FRAME_END_CS_IGNORE_SHIFT           24
+
+#define BMI_COUNTERS_EN				0x80000000
+
+#define BMI_EXT_BUF_POOL_VALID			FMAN_SP_EXT_BUF_POOL_VALID
+#define BMI_EXT_BUF_POOL_EN_COUNTER		FMAN_SP_EXT_BUF_POOL_EN_COUNTER
+#define BMI_EXT_BUF_POOL_BACKUP			FMAN_SP_EXT_BUF_POOL_BACKUP
+#define BMI_EXT_BUF_POOL_ID_SHIFT		16
+#define BMI_EXT_BUF_POOL_ID_MASK		0x003F0000
+#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT		16
+
+#define BMI_TX_FIFO_MIN_FILL_SHIFT		16
+#define BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT	12
+
+#define MAX_PERFORMANCE_TASK_COMP		64
+#define MAX_PERFORMANCE_RX_QUEUE_COMP		64
+#define MAX_PERFORMANCE_TX_QUEUE_COMP		8
+#define MAX_PERFORMANCE_DMA_COMP		16
+#define MAX_PERFORMANCE_FIFO_COMP		1024
+
+#define BMI_PERFORMANCE_TASK_COMP_SHIFT		24
+#define BMI_PERFORMANCE_QUEUE_COMP_SHIFT	16
+#define BMI_PERFORMANCE_DMA_COMP_SHIFT		12
+
+#define BMI_RATE_LIMIT_GRAN_TX			16000 /* In Kbps */
+#define BMI_RATE_LIMIT_GRAN_OP			10000 /* In frames */
+#define BMI_RATE_LIMIT_MAX_RATE_IN_GRAN_UNITS	1024
+#define BMI_RATE_LIMIT_MAX_BURST_SIZE		1024 /* In KBytes */
+#define BMI_RATE_LIMIT_MAX_BURST_SHIFT		16
+#define BMI_RATE_LIMIT_HIGH_BURST_SIZE_GRAN	0x80000000
+#define BMI_RATE_LIMIT_SCALE_TSBS_SHIFT		16
+#define BMI_RATE_LIMIT_SCALE_EN			0x80000000
+#define BMI_SG_DISABLE                          FMAN_SP_SG_DISABLE
+
+/** @Description  QMI defines */
+#define QMI_PORT_CFG_EN				0x80000000
+#define QMI_PORT_CFG_EN_COUNTERS		0x10000000
+
+#define QMI_PORT_STATUS_DEQ_TNUM_BSY		0x80000000
+#define QMI_PORT_STATUS_DEQ_FD_BSY		0x20000000
+
+#define QMI_DEQ_CFG_PRI				0x80000000
+#define QMI_DEQ_CFG_TYPE1			0x10000000
+#define QMI_DEQ_CFG_TYPE2			0x20000000
+#define QMI_DEQ_CFG_TYPE3			0x30000000
+#define QMI_DEQ_CFG_PREFETCH_PARTIAL		0x01000000
+#define QMI_DEQ_CFG_PREFETCH_FULL		0x03000000
+#define QMI_DEQ_CFG_SP_MASK			0xf
+#define QMI_DEQ_CFG_SP_SHIFT			20
+
+
+/** @Description  General port defines */
+#define FMAN_PORT_EXT_POOLS_NUM(fm_rev_maj) \
+		(((fm_rev_maj) == 4) ? 4 : 8)
+#define FMAN_PORT_MAX_EXT_POOLS_NUM	8
+#define FMAN_PORT_OBS_EXT_POOLS_NUM	2
+#define FMAN_PORT_CG_MAP_NUM		8
+#define FMAN_PORT_PRS_RESULT_WORDS_NUM	8
+#define FMAN_PORT_BMI_FIFO_UNITS	0x100
+#define FMAN_PORT_IC_OFFSET_UNITS	0x10
+
+
+/** @Collection    FM Port Register Map */
+
+/** @Description   BMI Rx port register map */
+struct fman_port_rx_bmi_regs {
+	uint32_t fmbm_rcfg;		/**< Rx Configuration */
+	uint32_t fmbm_rst;		/**< Rx Status */
+	uint32_t fmbm_rda;		/**< Rx DMA attributes*/
+	uint32_t fmbm_rfp;		/**< Rx FIFO Parameters*/
+	uint32_t fmbm_rfed;		/**< Rx Frame End Data*/
+	uint32_t fmbm_ricp;		/**< Rx Internal Context Parameters*/
+	uint32_t fmbm_rim;		/**< Rx Internal Buffer Margins*/
+	uint32_t fmbm_rebm;		/**< Rx External Buffer Margins*/
+	uint32_t fmbm_rfne;		/**< Rx Frame Next Engine*/
+	uint32_t fmbm_rfca;		/**< Rx Frame Command Attributes.*/
+	uint32_t fmbm_rfpne;		/**< Rx Frame Parser Next Engine*/
+	uint32_t fmbm_rpso;		/**< Rx Parse Start Offset*/
+	uint32_t fmbm_rpp;		/**< Rx Policer Profile  */
+	uint32_t fmbm_rccb;		/**< Rx Coarse Classification Base */
+	uint32_t fmbm_reth;		/**< Rx Excessive Threshold */
+	uint32_t reserved003c[1];	/**< (0x03C 0x03F) */
+	uint32_t fmbm_rprai[FMAN_PORT_PRS_RESULT_WORDS_NUM];
+					/**< Rx Parse Results Array Init*/
+	uint32_t fmbm_rfqid;		/**< Rx Frame Queue ID*/
+	uint32_t fmbm_refqid;		/**< Rx Error Frame Queue ID*/
+	uint32_t fmbm_rfsdm;		/**< Rx Frame Status Discard Mask*/
+	uint32_t fmbm_rfsem;		/**< Rx Frame Status Error Mask*/
+	uint32_t fmbm_rfene;		/**< Rx Frame Enqueue Next Engine */
+	uint32_t reserved0074[0x2];	/**< (0x074-0x07C)  */
+	uint32_t fmbm_rcmne;		/**< Rx Frame Continuous Mode Next Engine */
+	uint32_t reserved0080[0x20];/**< (0x080 0x0FF)  */
+	uint32_t fmbm_ebmpi[FMAN_PORT_MAX_EXT_POOLS_NUM];
+					/**< Buffer Manager pool Information-*/
+	uint32_t fmbm_acnt[FMAN_PORT_MAX_EXT_POOLS_NUM];
+					/**< Allocate Counter-*/
+	uint32_t reserved0130[8];
+					/**< 0x130/0x140 - 0x15F reserved -*/
+	uint32_t fmbm_rcgm[FMAN_PORT_CG_MAP_NUM];
+					/**< Congestion Group Map*/
+	uint32_t fmbm_mpd;		/**< BM Pool Depletion  */
+	uint32_t reserved0184[0x1F];	/**< (0x184 0x1FF) */
+	uint32_t fmbm_rstc;		/**< Rx Statistics Counters*/
+	uint32_t fmbm_rfrc;		/**< Rx Frame Counter*/
+	uint32_t fmbm_rfbc;		/**< Rx Bad Frames Counter*/
+	uint32_t fmbm_rlfc;		/**< Rx Large Frames Counter*/
+	uint32_t fmbm_rffc;		/**< Rx Filter Frames Counter*/
+	uint32_t fmbm_rfdc;		/**< Rx Frame Discard Counter*/
+	uint32_t fmbm_rfldec;		/**< Rx Frames List DMA Error Counter*/
+	uint32_t fmbm_rodc;		/**< Rx Out of Buffers Discard nntr*/
+	uint32_t fmbm_rbdc;		/**< Rx Buffers Deallocate Counter*/
+	uint32_t reserved0224[0x17];	/**< (0x224 0x27F) */
+	uint32_t fmbm_rpc;		/**< Rx Performance Counters*/
+	uint32_t fmbm_rpcp;		/**< Rx Performance Count Parameters*/
+	uint32_t fmbm_rccn;		/**< Rx Cycle Counter*/
+	uint32_t fmbm_rtuc;		/**< Rx Tasks Utilization Counter*/
+	uint32_t fmbm_rrquc;		/**< Rx Receive Queue Utilization cntr*/
+	uint32_t fmbm_rduc;		/**< Rx DMA Utilization Counter*/
+	uint32_t fmbm_rfuc;		/**< Rx FIFO Utilization Counter*/
+	uint32_t fmbm_rpac;		/**< Rx Pause Activation Counter*/
+	uint32_t reserved02a0[0x18];	/**< (0x2A0 0x2FF) */
+	uint32_t fmbm_rdbg;		/**< Rx Debug-*/
+};
+
+/** @Description   BMI Tx port register map */
+struct fman_port_tx_bmi_regs {
+	uint32_t fmbm_tcfg;		/**< Tx Configuration */
+	uint32_t fmbm_tst;		/**< Tx Status */
+	uint32_t fmbm_tda;		/**< Tx DMA attributes */
+	uint32_t fmbm_tfp;		/**< Tx FIFO Parameters */
+	uint32_t fmbm_tfed;		/**< Tx Frame End Data */
+	uint32_t fmbm_ticp;		/**< Tx Internal Context Parameters */
+	uint32_t fmbm_tfdne;		/**< Tx Frame Dequeue Next Engine. */
+	uint32_t fmbm_tfca;		/**< Tx Frame Command attribute. */
+	uint32_t fmbm_tcfqid;		/**< Tx Confirmation Frame Queue ID. */
+	uint32_t fmbm_tefqid;		/**< Tx Frame Error Queue ID */
+	uint32_t fmbm_tfene;		/**< Tx Frame Enqueue Next Engine */
+	uint32_t fmbm_trlmts;		/**< Tx Rate Limiter Scale */
+	uint32_t fmbm_trlmt;		/**< Tx Rate Limiter */
+	uint32_t reserved0034[0x0e];	/**< (0x034-0x6c) */
+	uint32_t fmbm_tccb;		/**< Tx Coarse Classification base */
+	uint32_t fmbm_tfne;		/**< Tx Frame Next Engine */
+	uint32_t fmbm_tpfcm[0x02];	/**< Tx Priority based Flow Control (PFC) Mapping */
+	uint32_t fmbm_tcmne;		/**< Tx Frame Continuous Mode Next Engine */
+	uint32_t reserved0080[0x60];	/**< (0x080-0x200) */
+	uint32_t fmbm_tstc;		/**< Tx Statistics Counters */
+	uint32_t fmbm_tfrc;		/**< Tx Frame Counter */
+	uint32_t fmbm_tfdc;		/**< Tx Frames Discard Counter */
+	uint32_t fmbm_tfledc;		/**< Tx Frame len error discard cntr */
+	uint32_t fmbm_tfufdc;		/**< Tx Frame unsprt frmt discard cntr*/
+	uint32_t fmbm_tbdc;		/**< Tx Buffers Deallocate Counter */
+	uint32_t reserved0218[0x1A];	/**< (0x218-0x280) */
+	uint32_t fmbm_tpc;		/**< Tx Performance Counters*/
+	uint32_t fmbm_tpcp;		/**< Tx Performance Count Parameters*/
+	uint32_t fmbm_tccn;		/**< Tx Cycle Counter*/
+	uint32_t fmbm_ttuc;		/**< Tx Tasks Utilization Counter*/
+	uint32_t fmbm_ttcquc;		/**< Tx Transmit conf Q util Counter*/
+	uint32_t fmbm_tduc;		/**< Tx DMA Utilization Counter*/
+	uint32_t fmbm_tfuc;		/**< Tx FIFO Utilization Counter*/
+};
+
+/** @Description   BMI O/H port register map */
+struct fman_port_oh_bmi_regs {
+	uint32_t fmbm_ocfg;		/**< O/H Configuration  */
+	uint32_t fmbm_ost;		/**< O/H Status */
+	uint32_t fmbm_oda;		/**< O/H DMA attributes  */
+	uint32_t fmbm_oicp;		/**< O/H Internal Context Parameters */
+	uint32_t fmbm_ofdne;		/**< O/H Frame Dequeue Next Engine  */
+	uint32_t fmbm_ofne;		/**< O/H Frame Next Engine  */
+	uint32_t fmbm_ofca;		/**< O/H Frame Command Attributes.  */
+	uint32_t fmbm_ofpne;		/**< O/H Frame Parser Next Engine  */
+	uint32_t fmbm_opso;		/**< O/H Parse Start Offset  */
+	uint32_t fmbm_opp;		/**< O/H Policer Profile */
+	uint32_t fmbm_occb;		/**< O/H Coarse Classification base */
+	uint32_t fmbm_oim;		/**< O/H Internal margins*/
+	uint32_t fmbm_ofp;		/**< O/H Fifo Parameters*/
+	uint32_t fmbm_ofed;		/**< O/H Frame End Data*/
+	uint32_t reserved0030[2];	/**< (0x038 - 0x03F) */
+	uint32_t fmbm_oprai[FMAN_PORT_PRS_RESULT_WORDS_NUM];
+				/**< O/H Parse Results Array Initialization  */
+	uint32_t fmbm_ofqid;		/**< O/H Frame Queue ID  */
+	uint32_t fmbm_oefqid;		/**< O/H Error Frame Queue ID  */
+	uint32_t fmbm_ofsdm;		/**< O/H Frame Status Discard Mask  */
+	uint32_t fmbm_ofsem;		/**< O/H Frame Status Error Mask  */
+	uint32_t fmbm_ofene;		/**< O/H Frame Enqueue Next Engine  */
+	uint32_t fmbm_orlmts;		/**< O/H Rate Limiter Scale  */
+	uint32_t fmbm_orlmt;		/**< O/H Rate Limiter  */
+	uint32_t fmbm_ocmne;		/**< O/H Continuous Mode Next Engine  */
+	uint32_t reserved0080[0x20];	/**< 0x080 - 0x0FF Reserved */
+	uint32_t fmbm_oebmpi[2];	/**< Buf Mngr Observed Pool Info */
+	uint32_t reserved0108[0x16];	/**< 0x108 - 0x15F Reserved */
+	uint32_t fmbm_ocgm;		/**< Observed Congestion Group Map */
+	uint32_t reserved0164[0x7];	/**< 0x164 - 0x17F Reserved */
+	uint32_t fmbm_ompd;		/**< Observed BMan Pool Depletion */
+	uint32_t reserved0184[0x1F];	/**< 0x184 - 0x1FF Reserved */
+	uint32_t fmbm_ostc;		/**< O/H Statistics Counters  */
+	uint32_t fmbm_ofrc;		/**< O/H Frame Counter  */
+	uint32_t fmbm_ofdc;		/**< O/H Frames Discard Counter  */
+	uint32_t fmbm_ofledc;		/**< O/H Frames Len Err Discard Cntr */
+	uint32_t fmbm_ofufdc;		/**< O/H Frames Unsprtd Discard Cutr  */
+	uint32_t fmbm_offc;		/**< O/H Filter Frames Counter  */
+	uint32_t fmbm_ofwdc;		/**< Rx Frames WRED Discard Counter  */
+	uint32_t fmbm_ofldec;		/**< O/H Frames List DMA Error Cntr */
+	uint32_t fmbm_obdc;		/**< O/H Buffers Deallocate Counter */
+	uint32_t reserved0218[0x17];	/**< (0x218 - 0x27F) */
+	uint32_t fmbm_opc;		/**< O/H Performance Counters  */
+	uint32_t fmbm_opcp;		/**< O/H Performance Count Parameters */
+	uint32_t fmbm_occn;		/**< O/H Cycle Counter  */
+	uint32_t fmbm_otuc;		/**< O/H Tasks Utilization Counter  */
+	uint32_t fmbm_oduc;		/**< O/H DMA Utilization Counter */
+	uint32_t fmbm_ofuc;		/**< O/H FIFO Utilization Counter */
+};
+
+/** @Description   BMI port register map */
+union fman_port_bmi_regs {
+	struct fman_port_rx_bmi_regs rx;
+	struct fman_port_tx_bmi_regs tx;
+	struct fman_port_oh_bmi_regs oh;
+};
+
+/** @Description   QMI port register map */
+struct fman_port_qmi_regs {
+	uint32_t fmqm_pnc;		/**< PortID n Configuration Register */
+	uint32_t fmqm_pns;		/**< PortID n Status Register */
+	uint32_t fmqm_pnts;		/**< PortID n Task Status Register */
+	uint32_t reserved00c[4];	/**< 0xn00C - 0xn01B */
+	uint32_t fmqm_pnen;		/**< PortID n Enqueue NIA Register */
+	uint32_t fmqm_pnetfc;		/**< PortID n Enq Total Frame Counter */
+	uint32_t reserved024[2];	/**< 0xn024 - 0x02B */
+	uint32_t fmqm_pndn;		/**< PortID n Dequeue NIA Register */
+	uint32_t fmqm_pndc;		/**< PortID n Dequeue Config Register */
+	uint32_t fmqm_pndtfc;		/**< PortID n Dequeue tot Frame cntr */
+	uint32_t fmqm_pndfdc;		/**< PortID n Dequeue FQID Dflt Cntr */
+	uint32_t fmqm_pndcc;		/**< PortID n Dequeue Confirm Counter */
+};
+
+
+enum fman_port_dma_swap {
+	E_FMAN_PORT_DMA_NO_SWAP,	/**< No swap, transfer data as is */
+	E_FMAN_PORT_DMA_SWAP_LE,
+	/**< The transferred data should be swapped in PPC Little Endian mode */
+	E_FMAN_PORT_DMA_SWAP_BE
+	/**< The transferred data should be swapped in Big Endian mode */
+};
+
+/* Default port color */
+enum fman_port_color {
+	E_FMAN_PORT_COLOR_GREEN,	/**< Default port color is green */
+	E_FMAN_PORT_COLOR_YELLOW,	/**< Default port color is yellow */
+	E_FMAN_PORT_COLOR_RED,		/**< Default port color is red */
+	E_FMAN_PORT_COLOR_OVERRIDE	/**< Ignore color */
+};
+
+/* QMI dequeue from the SP channel - types */
+enum fman_port_deq_type {
+	E_FMAN_PORT_DEQ_BY_PRI,
+	/**< Priority precedence and Intra-Class scheduling */
+	E_FMAN_PORT_DEQ_ACTIVE_FQ,
+	/**< Active FQ precedence and Intra-Class scheduling */
+	E_FMAN_PORT_DEQ_ACTIVE_FQ_NO_ICS
+	/**< Active FQ precedence and override Intra-Class scheduling */
+};
+
+/* QMI dequeue prefetch modes */
+enum fman_port_deq_prefetch {
+	E_FMAN_PORT_DEQ_NO_PREFETCH, /**< No prefetch mode */
+	E_FMAN_PORT_DEQ_PART_PREFETCH, /**< Partial prefetch mode */
+	E_FMAN_PORT_DEQ_FULL_PREFETCH /**< Full prefetch mode */
+};
+
+/* Parameters for defining performance counters behavior */
+struct fman_port_perf_cnt_params {
+	uint8_t task_val;	/**< Task compare value */
+	uint8_t queue_val;
+	/**< Rx or Tx conf queue compare value (unused for O/H ports) */
+	uint8_t dma_val;	/**< Dma compare value */
+	uint32_t fifo_val;	/**< Fifo compare value (in bytes) */
+};
+
+/** @Description   FM Port configuration structure, used at init */
+struct fman_port_cfg {
+	struct fman_port_perf_cnt_params perf_cnt_params;
+	/* BMI parameters */
+	enum fman_port_dma_swap		dma_swap_data;
+	bool				dma_ic_stash_on;
+	bool				dma_header_stash_on;
+	bool				dma_sg_stash_on;
+	bool				dma_write_optimize;
+	uint16_t			ic_ext_offset;
+	uint8_t				ic_int_offset;
+	uint16_t			ic_size;
+	enum fman_port_color		color;
+	bool				sync_req;
+	bool				discard_override;
+	uint8_t				checksum_bytes_ignore;
+	uint8_t				rx_cut_end_bytes;
+	uint32_t			rx_pri_elevation;
+	uint32_t			rx_fifo_thr;
+	uint8_t				rx_fd_bits;
+	uint8_t				int_buf_start_margin;
+	uint16_t			ext_buf_start_margin;
+	uint16_t			ext_buf_end_margin;
+	uint32_t			tx_fifo_min_level;
+	uint32_t			tx_fifo_low_comf_level;
+	uint8_t				tx_fifo_deq_pipeline_depth;
+	bool				stats_counters_enable;
+	bool				perf_counters_enable;
+	/* QMI parameters */
+	bool				deq_high_pri;
+	enum fman_port_deq_type		deq_type;
+	enum fman_port_deq_prefetch	deq_prefetch_opt;
+	uint16_t			deq_byte_cnt;
+	bool				queue_counters_enable;
+	bool				no_scatter_gather;
+	int				errata_A006675;
+	int				errata_A006320;
+	int				excessive_threshold_register;
+	int				fmbm_rebm_has_sgd;
+	int				fmbm_tfne_has_features;
+	int				qmi_deq_options_support;
+};
+
+enum fman_port_type {
+	E_FMAN_PORT_TYPE_OP = 0,
+	/**< Offline parsing port, shares id-s with
+	 * host command, so must have exclusive id-s */
+	E_FMAN_PORT_TYPE_RX,        /**< 1G Rx port */
+	E_FMAN_PORT_TYPE_RX_10G,    /**< 10G Rx port */
+	E_FMAN_PORT_TYPE_TX,        /**< 1G Tx port */
+	E_FMAN_PORT_TYPE_TX_10G,     /**< 10G Tx port */
+	E_FMAN_PORT_TYPE_DUMMY,
+	E_FMAN_PORT_TYPE_HC = E_FMAN_PORT_TYPE_DUMMY
+	/**< Host command port, shares id-s with
+	 * offline parsing ports, so must have exclusive id-s */
+};
+
+struct fman_port_params {
+	uint32_t discard_mask;
+	uint32_t err_mask;
+	uint32_t dflt_fqid;
+	uint32_t err_fqid;
+	uint8_t deq_sp;
+	bool dont_release_buf;
+};
+
+/* Port context - used by most API functions */
+struct fman_port {
+	enum fman_port_type type;
+	uint8_t fm_rev_maj;
+	uint8_t fm_rev_min;
+	union fman_port_bmi_regs *bmi_regs;
+	struct fman_port_qmi_regs *qmi_regs;
+	bool im_en;
+	uint8_t ext_pools_num;
+};
+
+/** @Description   External buffer pools configuration */
+struct fman_port_bpools {
+	uint8_t	count;			/**< Num of pools to set up */
+	bool	counters_enable;	/**< Enable allocate counters */
+	uint8_t grp_bp_depleted_num;
+	/**< Number of depleted pools - if reached the BMI indicates
+	 * the MAC to send a pause frame */
+	struct {
+		uint8_t		bpid;	/**< BM pool ID */
+		uint16_t	size;
+		/**< Pool's size - must be in ascending order */
+		bool		is_backup;
+		/**< If this is a backup pool */
+		bool		grp_bp_depleted;
+		/**< Consider this buffer in multiple pools depletion criteria*/
+		bool		single_bp_depleted;
+		/**< Consider this buffer in single pool depletion criteria */
+		bool		pfc_priorities_en;
+	} bpool[FMAN_PORT_MAX_EXT_POOLS_NUM];
+};
+
+enum fman_port_rate_limiter_scale_down {
+	E_FMAN_PORT_RATE_DOWN_NONE,
+	E_FMAN_PORT_RATE_DOWN_BY_2,
+	E_FMAN_PORT_RATE_DOWN_BY_4,
+	E_FMAN_PORT_RATE_DOWN_BY_8
+};
+
+/* Rate limiter configuration */
+struct fman_port_rate_limiter {
+	uint8_t		count_1micro_bit;
+	bool		high_burst_size_gran;
+	/**< Defines burst_size granularity for OP ports; when TRUE,
+	 * burst_size below counts in frames, otherwise in 10^3 frames */
+	uint16_t	burst_size;
+	/**< Max burst size, in KBytes for Tx port, according to
+	 * high_burst_size_gran definition for OP port */
+	uint32_t	rate;
+	/**< In Kbps for Tx port, in frames/sec for OP port */
+	enum fman_port_rate_limiter_scale_down rate_factor;
+};
+
+/* BMI statistics counters */
+enum fman_port_stats_counters {
+	E_FMAN_PORT_STATS_CNT_FRAME,
+	/**< Number of processed frames; valid for all ports */
+	E_FMAN_PORT_STATS_CNT_DISCARD,
+	/**< For Rx ports - frames discarded by QMAN, for Tx or O/H ports -
+	 * frames discarded due to DMA error; valid for all ports */
+	E_FMAN_PORT_STATS_CNT_DEALLOC_BUF,
+	/**< Number of buffer deallocate operations; valid for all ports */
+	E_FMAN_PORT_STATS_CNT_RX_BAD_FRAME,
+	/**< Number of bad Rx frames, like CRC error, Rx FIFO overflow etc;
+	 * valid for Rx ports only */
+	E_FMAN_PORT_STATS_CNT_RX_LARGE_FRAME,
+	/**< Number of Rx oversized frames, that is frames exceeding max frame
+	 * size configured for the corresponding ETH controller;
+	 * valid for Rx ports only */
+	E_FMAN_PORT_STATS_CNT_RX_OUT_OF_BUF,
+	/**< Frames discarded due to lack of external buffers; valid for
+	 * Rx ports only */
+	E_FMAN_PORT_STATS_CNT_LEN_ERR,
+	/**< Frames discarded due to frame length error; valid for Tx and
+	 * O/H ports only */
+	E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT,
+	/**< Frames discarded due to unsupported FD format; valid for Tx
+	 * and O/H ports only */
+	E_FMAN_PORT_STATS_CNT_FILTERED_FRAME,
+	/**< Number of frames filtered out by PCD module; valid for
+	 * Rx and OP ports only */
+	E_FMAN_PORT_STATS_CNT_DMA_ERR,
+	/**< Frames rejected by QMAN that were not able to release their
+	 * buffers due to DMA error; valid for Rx and O/H ports only */
+	E_FMAN_PORT_STATS_CNT_WRED_DISCARD
+	/**< Frames going through O/H port that were not able to to enter the
+	 * return queue due to WRED algorithm; valid for O/H ports only */
+};
+
+/* BMI performance counters */
+enum fman_port_perf_counters {
+	E_FMAN_PORT_PERF_CNT_CYCLE,	/**< Cycle counter */
+	E_FMAN_PORT_PERF_CNT_TASK_UTIL,	/**< Tasks utilization counter */
+	E_FMAN_PORT_PERF_CNT_QUEUE_UTIL,
+	/**< For Rx ports - Rx queue utilization, for Tx ports - Tx conf queue
+	 * utilization; not valid for O/H ports */
+	E_FMAN_PORT_PERF_CNT_DMA_UTIL,	/**< DMA utilization counter */
+	E_FMAN_PORT_PERF_CNT_FIFO_UTIL,	/**< FIFO utilization counter */
+	E_FMAN_PORT_PERF_CNT_RX_PAUSE
+	/**< Number of cycles in which Rx pause activation control is on;
+	 * valid for Rx ports only */
+};
+
+/* QMI counters */
+enum fman_port_qmi_counters {
+	E_FMAN_PORT_ENQ_TOTAL,	/**< EnQ tot frame cntr */
+	E_FMAN_PORT_DEQ_TOTAL,	/**< DeQ tot frame cntr; invalid for Rx ports */
+	E_FMAN_PORT_DEQ_FROM_DFLT,
+	/**< Dequeue from default FQID counter not valid for Rx ports */
+	E_FMAN_PORT_DEQ_CONFIRM	/**< DeQ confirm cntr invalid for Rx ports */
+};
+
+
+/** @Collection    FM Port API */
+void fman_port_defconfig(struct fman_port_cfg *cfg, enum fman_port_type type);
+int fman_port_init(struct fman_port *port,
+		struct fman_port_cfg *cfg,
+		struct fman_port_params *params);
+int fman_port_enable(struct fman_port *port);
+int fman_port_disable(const struct fman_port *port);
+int fman_port_set_bpools(const struct fman_port *port,
+		const struct fman_port_bpools *bp);
+int fman_port_set_rate_limiter(struct fman_port *port,
+		struct fman_port_rate_limiter *rate_limiter);
+int fman_port_delete_rate_limiter(struct fman_port *port);
+int fman_port_set_err_mask(struct fman_port *port, uint32_t err_mask);
+int fman_port_set_discard_mask(struct fman_port *port, uint32_t discard_mask);
+int fman_port_modify_rx_fd_bits(struct fman_port *port,
+		uint8_t rx_fd_bits,
+		bool add);
+int fman_port_set_perf_cnt_params(struct fman_port *port,
+		struct fman_port_perf_cnt_params *params);
+int fman_port_set_stats_cnt_mode(struct fman_port *port, bool enable);
+int fman_port_set_perf_cnt_mode(struct fman_port *port, bool enable);
+int fman_port_set_queue_cnt_mode(struct fman_port *port, bool enable);
+int fman_port_set_bpool_cnt_mode(struct fman_port *port,
+		uint8_t bpid,
+		bool enable);
+uint32_t fman_port_get_stats_counter(struct fman_port *port,
+		enum fman_port_stats_counters counter);
+void fman_port_set_stats_counter(struct fman_port *port,
+		enum fman_port_stats_counters counter,
+		uint32_t value);
+uint32_t fman_port_get_perf_counter(struct fman_port *port,
+		enum fman_port_perf_counters counter);
+void fman_port_set_perf_counter(struct fman_port *port,
+		enum fman_port_perf_counters counter,
+		uint32_t value);
+uint32_t fman_port_get_qmi_counter(struct fman_port *port,
+		enum fman_port_qmi_counters counter);
+void fman_port_set_qmi_counter(struct fman_port *port,
+		enum fman_port_qmi_counters counter,
+		uint32_t value);
+uint32_t fman_port_get_bpool_counter(struct fman_port *port, uint8_t bpid);
+void fman_port_set_bpool_counter(struct fman_port *port,
+		uint8_t bpid,
+		uint32_t value);
+int fman_port_add_congestion_grps(struct fman_port *port,
+		uint32_t grps_map[FMAN_PORT_CG_MAP_NUM]);
+int fman_port_remove_congestion_grps(struct fman_port  *port,
+		uint32_t grps_map[FMAN_PORT_CG_MAP_NUM]);
+
+
+#endif /* __FSL_FMAN_PORT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h
index aa6fd73..fddf763 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h
@@ -426,4 +426,24 @@ void fman_rtc_set_periodic_pulse(struct rtc_regs *regs, int id, uint32_t val,
 void fman_rtc_set_ext_trigger(struct rtc_regs *regs, int id, bool enable,
 	bool use_pulse_as_input);
 
+struct fm_rtc_alarm_params {
+	uint8_t alarm_id;            	/**< 0 or 1 */
+	uint64_t alarm_time;         	/**< In nanoseconds, the time when the
+					alarm should go off - must be a
+					multiple of the RTC period */
+	void (*f_alarm_callback)(void* app, uint8_t id); /**< This routine will
+					be called when RTC reaches alarmTime */
+	bool clear_on_expiration;   	/**< TRUE to turn off the alarm once
+					expired.*/
+};
+
+struct fm_rtc_periodic_pulse_params {
+	uint8_t periodic_pulse_id;      /**< 0 or 1 */
+	uint64_t periodic_pulse_period; /**< In Nanoseconds. Must be a multiple
+					of the RTC period */
+	void (*f_periodic_pulse_callback)(void* app, uint8_t id); /**< This
+					routine will be called every
+					periodicPulsePeriod. */
+};
+
 #endif /* __FSL_FMAN_RTC_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_tgec.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_tgec.h
index e031ccf..a037314 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_tgec.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_tgec.h
@@ -38,7 +38,7 @@
 
 
 /* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
-#define TX_IPG_LENGTH_MASK	0x000003ff
+#define TGEC_TX_IPG_LENGTH_MASK	0x000003ff
 
 enum tgec_counters {
 	E_TGEC_COUNTER_R64,
@@ -106,14 +106,14 @@ enum tgec_counters {
 #define TGEC_IMASK_RX_ALIGN_ER		0x00000001
 
 #define TGEC_EVENTS_MASK					\
-	((uint32_t)(TGEC_IMASK_MDIO_SCAN_EVENT	| \
+	((uint32_t)(TGEC_IMASK_MDIO_SCAN_EVENT			| \
 				TGEC_IMASK_MDIO_CMD_CMPL	| \
 				TGEC_IMASK_REM_FAULT		| \
 				TGEC_IMASK_LOC_FAULT		| \
 				TGEC_IMASK_TX_ECC_ER		| \
 				TGEC_IMASK_TX_FIFO_UNFL		| \
 				TGEC_IMASK_TX_FIFO_OVFL		| \
-				TGEC_IMASK_TX_ER			| \
+				TGEC_IMASK_TX_ER		| \
 				TGEC_IMASK_RX_FIFO_OVFL		| \
 				TGEC_IMASK_RX_ECC_ER		| \
 				TGEC_IMASK_RX_JAB_FRM		| \
@@ -328,8 +328,8 @@ struct tgec_regs {
  *            (increasing bandwidth).
  *
  * This structure contains basic TGEC configuration and must be passed to
- * fman_tgec_init() function.  A default set of configuration values can be obtained
- * by calling fman_tgec_defconfig().
+ * fman_tgec_init() function.  A default set of configuration values can be
+ * obtained by calling fman_tgec_defconfig().
  */
 struct tgec_cfg {
 	bool		rx_error_discard;
@@ -391,7 +391,8 @@ void fman_tgec_reset_stat(struct tgec_regs *regs);
  *
  * Returns:    Required counter value
  */
-uint64_t fman_tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name);
+uint64_t fman_tgec_get_counter(struct tgec_regs *regs,
+	enum tgec_counters reg_name);
 
 /**
  * fman_tgec_set_hash_table() - Sets the Hashtable Control Register
@@ -453,6 +454,11 @@ void fman_tgec_enable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
 
 void fman_tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
 
+void fman_tgec_reset_filter_table(struct tgec_regs *regs);
+
+void fman_tgec_set_hash_table_entry(struct tgec_regs *regs, uint32_t crc);
+
+
 /**
  * fman_tgec_get_max_frame_len() - Returns the maximum frame length value
  * @regs:    Pointer to TGEC register block
@@ -460,12 +466,14 @@ void fman_tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
 uint16_t fman_tgec_get_max_frame_len(struct tgec_regs *regs);
 
 /**
- * fman_tgec_set_erratum_tx_fifo_corruption_10gmac_a007() - Initialize the main tgec configuration parameters
+ * fman_tgec_set_erratum_tx_fifo_corruption_10gmac_a007() - Initialize the
+ * main tgec configuration parameters
  * @regs:    Pointer to TGEC register block
  *
  * TODO
  */
-void fman_tgec_set_erratum_tx_fifo_corruption_10gmac_a007(struct tgec_regs *regs);
+void fman_tgec_set_erratum_tx_fifo_corruption_10gmac_a007(struct tgec_regs
+	*regs);
 
 
 #endif /* __FSL_FMAN_TGEC_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
index b6780b9..6fa8c25 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
@@ -231,8 +231,7 @@ typedef enum
 
 /* QMI defines */
 #define QMI_MAX_NUM_OF_TNUMS            64
-#define QMI_DEF_TNUMS_THRESH            48
-
+#define QMI_DEF_TNUMS_THRESH            32
 /* FPM defines */
 #define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
 
@@ -256,7 +255,6 @@ typedef enum
 #define FM_DEQ_PIPELINE_PARAMS_FOR_OP
 #define FM_QMI_NO_SINGLE_ECC_EXCEPTION
 
-
 #define FM_NO_GUARANTEED_RESET_VALUES
 
 /* FM errata */
@@ -277,5 +275,7 @@ typedef enum
 #define RM_MAX_NUM_OF_IB        4           /**< Number of inbound blocks */
 #define RM_NUM_OF_IBCU          8           /**< NUmber of classification units in an inbound block */
 
+/* RMan erratas */
+#define RM_ERRONEOUS_ACK_ERRATA_RMAN_A006756
 
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
index edb3d51..5c632ba 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
@@ -1620,8 +1620,8 @@ int fm_fpm_dump_regs(void *h_fm, char *buf, int nn)
 	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_prc);
 	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_brkc);
 	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_mxd);
-	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_dis1);
-	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_dis2);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_dist1);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_dist2);
 	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_epi);
 	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_rie);
 
-- 
1.9.1

