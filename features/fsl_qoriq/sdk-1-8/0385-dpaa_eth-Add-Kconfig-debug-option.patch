From 02dde82cc37374ee51e92b05196dc3d6065e9fd1 Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Thu, 11 Sep 2014 14:43:37 +0800
Subject: [PATCH 385/987] dpaa_eth: Add Kconfig debug option

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Add a Kconfig option that enables debug support in the driver.
For a start, move (most of) the BUG_ON()'s in the driver's fastpath
under this debug option.
New debug information (such as trace events, frame content dumps, etc)
can be added later under the same umbrella.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: I8023a75751cdad9e80d96957b9071f707a03e2b2
Reviewed-on: http://git.am.freescale.net:8181/4839
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/Kconfig       |  7 +++++
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h    |  6 +++++
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 33 ++++++++++++------------
 3 files changed, 30 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/Kconfig b/drivers/net/ethernet/freescale/dpa/Kconfig
index c416d5d..92506ee 100644
--- a/drivers/net/ethernet/freescale/dpa/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/Kconfig
@@ -127,3 +127,10 @@ config FSL_DPAA_ETH_DEBUGFS
 	default y
 	---help---
 	  This option compiles debugfs code for the DPAA Ethernet driver.
+
+config FSL_DPAA_ETH_DEBUG
+	bool "DPAA Ethernet Debug Support"
+	depends on FSL_DPAA_ETH
+	default n
+	---help---
+	  This option compiles debug code for the DPAA Ethernet driver.
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index f33ff0a..cda8f2c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -83,6 +83,12 @@ struct dpa_buffer_layout_s {
 	uint16_t	data_align;
 };
 
+#ifdef CONFIG_FSL_DPAA_ETH_DEBUG
+#define DPA_BUG_ON(cond)	BUG_ON(cond)
+#else
+#define DPA_BUG_ON(cond)
+#endif
+
 #define DPA_TX_PRIV_DATA_SIZE	16
 #define DPA_PARSE_RESULTS_SIZE sizeof(fm_prs_result_t)
 #define DPA_TIME_STAMP_SIZE 8
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 67ff53d..15d0f82 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -232,7 +232,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 		/* remaining pages were mapped with dma_map_page() */
 		for (i = 1; i < nr_frags; i++) {
-			BUG_ON(sgt[i].extension);
+			DPA_BUG_ON(sgt[i].extension);
 
 			dma_unmap_page(dpa_bp->dev, sgt[i].addr,
 					sgt[i].length, dma_dir);
@@ -335,7 +335,7 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	struct sk_buff *skb = NULL;
 
 	vaddr = phys_to_virt(addr);
-	BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
+	DPA_BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
 
 	/* Build the skb and adjust data and tail pointers */
 	skb = build_skb(vaddr, dpa_bp->size + DPA_SKB_TAILROOM);
@@ -356,7 +356,7 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	 * skb_shinfo) be SMP_CACHE_BYTES-aligned. The former is aligned,
 	 * thanks to vaddr. We still need to adjust the size accordingly.
 	 */
-	BUG_ON(fd_off != priv->rx_headroom);
+	DPA_BUG_ON(fd_off != priv->rx_headroom);
 	skb_reserve(skb, fd_off);
 	skb_put(skb, dpa_fd_length(fd));
 
@@ -397,21 +397,22 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 	int *count_ptr;
 
 	vaddr = phys_to_virt(addr);
-	BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
+	DPA_BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
 
 	/* Iterate through the SGT entries and add data buffers to the skb */
 	sgt = vaddr + fd_off;
 	for (i = 0; i < DPA_SGT_MAX_ENTRIES; i++) {
 		/* Extension bit is not supported */
-		BUG_ON(sgt[i].extension);
+		DPA_BUG_ON(sgt[i].extension);
 
 		dpa_bp = dpa_bpid2pool(sgt[i].bpid);
-		BUG_ON(!dpa_bp);
+		DPA_BUG_ON(!dpa_bp);
 		count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 
 		sg_addr = qm_sg_addr(&sgt[i]);
 		sg_vaddr = phys_to_virt(sg_addr);
-		BUG_ON(!IS_ALIGNED((unsigned long)sg_vaddr, SMP_CACHE_BYTES));
+		DPA_BUG_ON(!IS_ALIGNED((unsigned long)sg_vaddr,
+				SMP_CACHE_BYTES));
 
 		if (i == 0) {
 			/* Tentatively access the first buffer, but don't unmap
@@ -458,7 +459,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 			/* Make sure forwarded skbs will have enough space
 			 * on Tx, if extra headers are added.
 			 */
-			BUG_ON(fd_off != priv->rx_headroom);
+			DPA_BUG_ON(fd_off != priv->rx_headroom);
 			skb_reserve(skb, fd_off);
 			skb_put(skb, sgt[i].length);
 		} else {
@@ -499,7 +500,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 
 	/* recycle the SGT fragment */
 	dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(!dpa_bp);
+	DPA_BUG_ON(!dpa_bp);
 	dpa_bp_recycle_frag(dpa_bp, (unsigned long)vaddr);
 	return skb;
 }
@@ -529,7 +530,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	}
 
 	dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(!dpa_bp);
+	DPA_BUG_ON(!dpa_bp);
 	count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 	/* Prepare to read from the buffer, but don't unmap it until
 	 * we know the skb allocation succeeded. At this point we already
@@ -541,13 +542,12 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	/* prefetch the first 64 bytes of the frame or the SGT start */
 	prefetch(phys_to_virt(addr) + dpa_fd_offset(fd));
 
+	/* The only FD types that we may receive are contig and S/G */
+	DPA_BUG_ON((fd->format != qm_fd_contig) && (fd->format != qm_fd_sg));
 	if (likely(fd->format == qm_fd_contig))
 		skb = contig_fd_to_skb(priv, fd, &use_gro);
-	else if (fd->format == qm_fd_sg)
-		skb = sg_fd_to_skb(priv, fd, &use_gro);
 	else
-		/* The only FD types that we may receive are contig and S/G */
-		BUG();
+		skb = sg_fd_to_skb(priv, fd, &use_gro);
 	if (unlikely(!skb))
 		/* We haven't yet touched the DMA mapping or the pool count;
 		 * dpa_fd_release() will just put the buffer back in the pool
@@ -630,7 +630,7 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 		 */
 		fd->cmd |= FM_FD_CMD_FCO;
 		fd->bpid = dpa_bp->bpid;
-		BUG_ON(skb->data - buffer_start > DPA_MAX_FD_OFFSET);
+		DPA_BUG_ON(skb->data - buffer_start > DPA_MAX_FD_OFFSET);
 		fd->offset = (uint16_t)(skb->data - buffer_start);
 		dma_dir = DMA_BIDIRECTIONAL;
 	} else
@@ -739,12 +739,13 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	for (i = 1; i <= nr_frags; i++) {
 		frag = &skb_shinfo(skb)->frags[i - 1];
 		sgt[i].bpid = dpa_bp->bpid;
+
 		sgt[i].offset = 0;
 		sgt[i].length = frag->size;
 		sgt[i].extension = 0;
 		sgt[i].final = 0;
 
-		BUG_ON(!skb_frag_page(frag));
+		DPA_BUG_ON(!skb_frag_page(frag));
 		addr = skb_frag_dma_map(dpa_bp->dev, frag, 0, sgt[i].length,
 					dma_dir);
 		if (unlikely(dma_mapping_error(dpa_bp->dev, addr))) {
-- 
1.9.1

