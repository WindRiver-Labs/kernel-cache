From 18d3b455d34036e3bb04d1144b4ccb3d08b4d090 Mon Sep 17 00:00:00 2001
From: Rotariu Marian Cristian-B44860 <marian.rotariu@freescale.com>
Date: Thu, 9 Oct 2014 16:46:25 +0300
Subject: [PATCH 884/987] offline_port: convert dt into CPU endianness

The device tree values are stored in BE format by the dt compiler. In order to
support different architectures, not only BE, the values read by the offline
port driver should be converted into CPU endianness.

This patch convert the dt values into CPU endianness and fixes some sparse
errors related to endianness.

Signed-off-by: Rotariu Marian Cristian-B44860 <marian.rotariu@freescale.com>
Change-Id: Id7adce3b6f73619c58ac1cee9201bb63131f8d58
Reviewed-on: http://git.am.freescale.net:8181/21083
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/32496
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/offline_port.c | 128 +++++++++-------------
 1 file changed, 49 insertions(+), 79 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/offline_port.c b/drivers/net/ethernet/freescale/dpa/offline_port.c
index 042f44a..ddbfdce 100644
--- a/drivers/net/ethernet/freescale/dpa/offline_port.c
+++ b/drivers/net/ethernet/freescale/dpa/offline_port.c
@@ -250,14 +250,13 @@ oh_port_probe(struct platform_device *_of_dev)
 	struct device_node *dpa_oh_node;
 	int lenp, _errno = 0, fq_idx, duple_idx;
 	int n_size, i, j, ret, duples_count;
-	const phandle *oh_port_handle, *bpool_handle;
 	struct platform_device *oh_of_dev;
 	struct device_node *oh_node, *bpool_node = NULL, *root_node;
 	struct device *oh_dev;
 	struct dpa_oh_config_s *oh_config = NULL;
-	uint32_t *oh_all_queues;
-	uint32_t *channel_ids;
-	uint32_t *oh_tx_queues;
+	const __be32 *oh_all_queues;
+	const __be32 *channel_ids;
+	const __be32 *oh_tx_queues;
 	uint32_t queues_count;
 	uint32_t crt_fqid_base;
 	uint32_t crt_fq_count;
@@ -270,17 +269,18 @@ oh_port_probe(struct platform_device *_of_dev)
 	bool init_oh_port;
 
 	const struct of_device_id *match;
-	uint32_t crt_ext_pools_count, ext_pool_size;
-	const unsigned int *port_id;
-	const unsigned int *channel_id;
+	int crt_ext_pools_count;
+	u32 ext_pool_size;
+	u32 port_id;
+	u32 channel_id;
 
 	int channel_ids_count;
 	int channel_idx;
 	struct fq_duple *fqd;
 	struct list_head *fq_list, *fq_list_tmp;
 
-	const uint32_t *bpool_cfg;
-	const uint32_t *bpid;
+	const __be32 *bpool_cfg;
+	uint32_t bpid;
 
 	memset(&oh_port_tx_params, 0, sizeof(oh_port_tx_params));
 	dpa_oh_dev = &_of_dev->dev;
@@ -294,49 +294,28 @@ oh_port_probe(struct platform_device *_of_dev)
 	dev_dbg(dpa_oh_dev, "Probing OH port...\n");
 
 	/* Find the referenced OH node */
-
-	oh_port_handle = of_get_property(dpa_oh_node,
-		"fsl,fman-oh-port", &lenp);
-	if (oh_port_handle == NULL) {
-		dev_err(dpa_oh_dev, "No OH port handle found in node %s\n",
-			dpa_oh_node->full_name);
-		return -EINVAL;
-	}
-
-	BUG_ON(lenp % sizeof(*oh_port_handle));
-	if (lenp != sizeof(*oh_port_handle)) {
-		dev_err(dpa_oh_dev,
-			"Found %lu OH port bindings in node %s, only 1 phandle is allowed.\n",
-			(unsigned long int)(lenp / sizeof(*oh_port_handle)),
-			dpa_oh_node->full_name);
-		return -EINVAL;
-	}
-
-	/* Read configuration for the OH port */
-	oh_node = of_find_node_by_phandle(*oh_port_handle);
+	oh_node = of_parse_phandle(dpa_oh_node, "fsl,fman-oh-port", 0);
 	if (oh_node == NULL) {
 		dev_err(dpa_oh_dev,
 			"Can't find OH node referenced from node %s\n",
 			dpa_oh_node->full_name);
 		return -EINVAL;
 	}
-	dev_info(dpa_oh_dev, "Found OH node handle compatible with %s.\n",
+	dev_info(dpa_oh_dev, "Found OH node handle compatible with %s\n",
 		match->compatible);
 
-	port_id = of_get_property(oh_node, "cell-index", &lenp);
-	if (port_id == NULL) {
+	_errno = of_property_read_u32(oh_node, "cell-index", &port_id);
+	if (_errno) {
 		dev_err(dpa_oh_dev, "No port id found in node %s\n",
 			dpa_oh_node->full_name);
-		_errno = -EINVAL;
 		goto return_kfree;
 	}
-	BUG_ON(lenp % sizeof(*port_id));
 
-	channel_id = of_get_property(oh_node, "fsl,qman-channel-id", &lenp);
-	if (channel_id == NULL) {
+	_errno = of_property_read_u32(oh_node, "fsl,qman-channel-id",
+			&channel_id);
+	if (_errno) {
 		dev_err(dpa_oh_dev, "No channel id found in node %s\n",
 			dpa_oh_node->full_name);
-		_errno = -EINVAL;
 		goto return_kfree;
 	}
 
@@ -383,7 +362,7 @@ oh_port_probe(struct platform_device *_of_dev)
 
 	/* FQs that enter OH port */
 	lenp = 0;
-	oh_all_queues = (uint32_t *)of_get_property(dpa_oh_node,
+	oh_all_queues = of_get_property(dpa_oh_node,
 		"fsl,qman-frame-queues-ingress", &lenp);
 	if (lenp % (2 * sizeof(*oh_all_queues))) {
 		dev_warn(dpa_oh_dev,
@@ -396,8 +375,8 @@ oh_port_probe(struct platform_device *_of_dev)
 	dev_err(dpa_oh_dev, "Allocating %d ingress frame queues duples\n",
 			duples_count);
 	for (duple_idx = 0; duple_idx < duples_count; duple_idx++) {
-		crt_fqid_base = oh_all_queues[2 * duple_idx];
-		crt_fq_count = oh_all_queues[2 * duple_idx + 1];
+		crt_fqid_base = be32_to_cpu(oh_all_queues[2 * duple_idx]);
+		crt_fq_count = be32_to_cpu(oh_all_queues[2 * duple_idx + 1]);
 
 		fqd = devm_kzalloc(dpa_oh_dev,
 				sizeof(struct fq_duple), GFP_KERNEL);
@@ -423,7 +402,7 @@ oh_port_probe(struct platform_device *_of_dev)
 		for (j = 0; j < crt_fq_count; j++)
 			(fqd->fqs + j)->fqid = crt_fqid_base + j;
 		fqd->fqs_count = crt_fq_count;
-		fqd->channel_id = (uint16_t)*channel_id;
+		fqd->channel_id = (uint16_t)channel_id;
 		list_add(&fqd->fq_list, &oh_config->fqs_ingress_list);
 	}
 
@@ -448,7 +427,7 @@ oh_port_probe(struct platform_device *_of_dev)
 
 	/* FQs that exit OH port */
 	lenp = 0;
-	oh_all_queues = (uint32_t *)of_get_property(dpa_oh_node,
+	oh_all_queues = of_get_property(dpa_oh_node,
 		"fsl,qman-frame-queues-egress", &lenp);
 	if (lenp % (2 * sizeof(*oh_all_queues))) {
 		dev_warn(dpa_oh_dev,
@@ -461,8 +440,8 @@ oh_port_probe(struct platform_device *_of_dev)
 	dev_dbg(dpa_oh_dev, "Allocating %d egress frame queues duples\n",
 			duples_count);
 	for (duple_idx = 0; duple_idx < duples_count; duple_idx++) {
-		crt_fqid_base = oh_all_queues[2 * duple_idx];
-		crt_fq_count = oh_all_queues[2 * duple_idx + 1];
+		crt_fqid_base = be32_to_cpu(oh_all_queues[2 * duple_idx]);
+		crt_fq_count = be32_to_cpu(oh_all_queues[2 * duple_idx + 1]);
 
 		fqd = devm_kzalloc(dpa_oh_dev,
 				sizeof(struct fq_duple), GFP_KERNEL);
@@ -499,7 +478,7 @@ oh_port_probe(struct platform_device *_of_dev)
 
 	/* channel_ids for FQs that exit OH port */
 	lenp = 0;
-	channel_ids = (uint32_t *)of_get_property(dpa_oh_node,
+	channel_ids = of_get_property(dpa_oh_node,
 		"fsl,qman-channel-ids-egress", &lenp);
 
 	channel_ids_count = lenp / (sizeof(*channel_ids));
@@ -515,7 +494,8 @@ oh_port_probe(struct platform_device *_of_dev)
 		if (channel_idx + 1 > channel_ids_count)
 			break;
 		fqd = list_entry(fq_list, struct fq_duple, fq_list);
-		fqd->channel_id = (uint16_t)channel_ids[channel_idx++];
+		fqd->channel_id =
+			(uint16_t)be32_to_cpu(channel_ids[channel_idx++]);
 	}
 
 	/* create egress queues */
@@ -543,7 +523,7 @@ oh_port_probe(struct platform_device *_of_dev)
 	}
 
 	/* Read FQ ids/nums for the DPA OH node */
-	oh_all_queues = (uint32_t *)of_get_property(dpa_oh_node,
+	oh_all_queues = of_get_property(dpa_oh_node,
 		"fsl,qman-frame-queues-oh", &lenp);
 	if (oh_all_queues == NULL) {
 		dev_err(dpa_oh_dev,
@@ -569,8 +549,8 @@ oh_port_probe(struct platform_device *_of_dev)
 	fq_idx = 0;
 
 	/* Error FQID - must be present */
-	crt_fqid_base = oh_all_queues[fq_idx++];
-	crt_fq_count = oh_all_queues[fq_idx++];
+	crt_fqid_base = be32_to_cpu(oh_all_queues[fq_idx++]);
+	crt_fq_count = be32_to_cpu(oh_all_queues[fq_idx++]);
 	if (crt_fq_count != 1) {
 		dev_err(dpa_oh_dev,
 			"Only 1 Error FQ allowed in OH node %s referenced from node %s (read: %d FQIDs).\n",
@@ -584,8 +564,8 @@ oh_port_probe(struct platform_device *_of_dev)
 		oh_config->error_fqid, oh_node->full_name);
 
 	/* Default FQID - must be present */
-	crt_fqid_base = oh_all_queues[fq_idx++];
-	crt_fq_count = oh_all_queues[fq_idx++];
+	crt_fqid_base = be32_to_cpu(oh_all_queues[fq_idx++]);
+	crt_fq_count = be32_to_cpu(oh_all_queues[fq_idx++]);
 	if (crt_fq_count != 1) {
 		dev_err(dpa_oh_dev,
 			"Only 1 Default FQ allowed in OH node %s referenced from %s (read: %d FQIDs).\n",
@@ -599,8 +579,8 @@ oh_port_probe(struct platform_device *_of_dev)
 		oh_config->default_fqid, oh_node->full_name);
 
 	/* TX FQID - presence is optional */
-	oh_tx_queues = (uint32_t *)of_get_property(dpa_oh_node,
-		"fsl,qman-frame-queues-tx", &lenp);
+	oh_tx_queues = of_get_property(dpa_oh_node, "fsl,qman-frame-queues-tx",
+			&lenp);
 	if (oh_tx_queues == NULL) {
 		dev_dbg(dpa_oh_dev,
 			"No tx queues have been defined for OH node %s referenced from node %s\n",
@@ -619,19 +599,9 @@ oh_port_probe(struct platform_device *_of_dev)
 		goto return_kfree;
 	}
 
-	/* Read channel id for the queues */
-	channel_id = of_get_property(oh_node, "fsl,qman-channel-id", &lenp);
-	if (channel_id == NULL) {
-		dev_err(dpa_oh_dev, "No channel id found in node %s\n",
-			dpa_oh_node->full_name);
-		_errno = -EINVAL;
-		goto return_kfree;
-	}
-	BUG_ON(lenp % sizeof(*channel_id));
-
 	fq_idx = 0;
-	crt_fqid_base = oh_tx_queues[fq_idx++];
-	crt_fq_count = oh_tx_queues[fq_idx++];
+	crt_fqid_base = be32_to_cpu(oh_tx_queues[fq_idx++]);
+	crt_fq_count = be32_to_cpu(oh_tx_queues[fq_idx++]);
 	oh_config->egress_cnt = crt_fq_count;
 
 	/* Allocate TX queues */
@@ -649,7 +619,7 @@ oh_port_probe(struct platform_device *_of_dev)
 	/* Create TX queues */
 	for (i = 0; i < crt_fq_count; i++) {
 		ret = oh_fq_create(oh_config->egress_fqs + i,
-			crt_fqid_base + i, (uint16_t)*channel_id, 3);
+			crt_fqid_base + i, (uint16_t)channel_id, 3);
 		if (ret != 0) {
 			dev_err(dpa_oh_dev,
 				"Unable to create TX frame queue %d for OH node %s referenced from node %s!\n",
@@ -673,10 +643,11 @@ config_port:
 	}
 
 	oh_set_buffer_layout(oh_config->oh_port, &buf_layout);
-	bpool_handle = of_get_property(dpa_oh_node,
-			"fsl,bman-buffer-pools", &lenp);
 
-	if (bpool_handle == NULL) {
+	/* read the pool handlers */
+	crt_ext_pools_count = of_count_phandle_with_args(dpa_oh_node,
+			"fsl,bman-buffer-pools", NULL);
+	if (crt_ext_pools_count <= 0) {
 		dev_info(dpa_oh_dev,
 			 "OH port %s has no buffer pool. Fragmentation will not be enabled\n",
 			oh_node->full_name);
@@ -694,29 +665,29 @@ config_port:
 	n_size = of_n_size_cells(root_node);
 	of_node_put(root_node);
 
-	crt_ext_pools_count = lenp / sizeof(phandle);
-	dev_dbg(dpa_oh_dev, "OH port number of pools = %u\n",
+	dev_dbg(dpa_oh_dev, "OH port number of pools = %d\n",
 			crt_ext_pools_count);
 
 	oh_port_tx_params.num_pools = (uint8_t)crt_ext_pools_count;
 
 	for (i = 0; i < crt_ext_pools_count; i++) {
-		bpool_node = of_find_node_by_phandle(bpool_handle[i]);
+		bpool_node = of_parse_phandle(dpa_oh_node,
+				"fsl,bman-buffer-pools", i);
 		if (bpool_node == NULL) {
 			dev_err(dpa_oh_dev, "Invalid Buffer pool node\n");
 			_errno = -EINVAL;
 			goto return_kfree;
 		}
 
-		bpid = of_get_property(bpool_node, "fsl,bpid", &lenp);
-		if ((bpid == NULL) || (lenp != sizeof(*bpid))) {
-			dev_err(dpa_oh_dev, "Invalid Buffer pool Id\n");
+		_errno = of_property_read_u32(bpool_node, "fsl,bpid", &bpid);
+		if (_errno) {
+			dev_err(dpa_oh_dev, "Invalid Buffer Pool ID\n");
 			_errno = -EINVAL;
 			goto return_kfree;
 		}
 
-		oh_port_tx_params.pool_param[i].id = (uint8_t)*bpid;
-		dev_dbg(dpa_oh_dev, "OH port bpool id = %u\n", *bpid);
+		oh_port_tx_params.pool_param[i].id = (uint8_t)bpid;
+		dev_dbg(dpa_oh_dev, "OH port bpool id = %u\n", bpid);
 
 		bpool_cfg = of_get_property(bpool_node,
 				"fsl,bpool-ethernet-cfg", &lenp);
@@ -726,7 +697,6 @@ config_port:
 			goto return_kfree;
 		}
 
-		of_read_number(bpool_cfg, n_size);
 		ext_pool_size = of_read_number(bpool_cfg + n_size, n_size);
 		oh_port_tx_params.pool_param[i].size = (uint16_t)ext_pool_size;
 		dev_dbg(dpa_oh_dev, "OH port bpool size = %u\n",
@@ -741,7 +711,7 @@ config_port:
 
 	frag_enabled = true;
 	dev_info(dpa_oh_dev, "IP Fragmentation enabled for OH port %d",
-		     *port_id);
+			port_id);
 
 init_port:
 	of_node_put(oh_node);
-- 
1.9.1

