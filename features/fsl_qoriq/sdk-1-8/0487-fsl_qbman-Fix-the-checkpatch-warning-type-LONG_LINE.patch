From c37287623baca5dfabf50eff509c7b247830d3e3 Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@Freescale.com>
Date: Wed, 8 Jan 2014 04:41:02 -0600
Subject: [PATCH 487/987] fsl_qbman: Fix the checkpatch warning type LONG_LINE

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

WARNING:LONG_LINE: line over 80 characters

Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Change-Id: I2437493f24859184397a666b7e7375749c639229
Reviewed-on: http://git.am.freescale.net:8181/7784
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Haiying Wang <Haiying.Wang@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Emilian Medve <Emilian.Medve@freescale.com>
---
 drivers/staging/fsl_qbman/bman_config.c | 24 ++++++++++++++++--------
 drivers/staging/fsl_qbman/fsl_usdpaa.c  |  6 ++++--
 drivers/staging/fsl_qbman/qman_config.c | 27 ++++++++++++++++++---------
 drivers/staging/fsl_qbman/qman_low.h    |  9 +++++----
 include/linux/fsl_bman.h                |  6 ++++--
 5 files changed, 47 insertions(+), 25 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index c92a8cf..2f5ff2f 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -132,14 +132,22 @@ static const struct bman_error_info_mdata error_mdata[] = {
  * the BM_EIRQ_*** definitions. Note that "bm_err_isr_enable_write" means
  * "write the enable register" rather than "enable the write register"!
  */
-#define bm_err_isr_status_read(bm)	__bm_err_isr_read(bm, bm_isr_status)
-#define bm_err_isr_status_clear(bm, m)	__bm_err_isr_write(bm, bm_isr_status, m)
-#define bm_err_isr_enable_read(bm)	__bm_err_isr_read(bm, bm_isr_enable)
-#define bm_err_isr_enable_write(bm, v)	__bm_err_isr_write(bm, bm_isr_enable, v)
-#define bm_err_isr_disable_read(bm)	__bm_err_isr_read(bm, bm_isr_disable)
-#define bm_err_isr_disable_write(bm, v)	__bm_err_isr_write(bm, bm_isr_disable, v)
-#define bm_err_isr_inhibit(bm)		__bm_err_isr_write(bm, bm_isr_inhibit, 1)
-#define bm_err_isr_uninhibit(bm)	__bm_err_isr_write(bm, bm_isr_inhibit, 0)
+#define bm_err_isr_status_read(bm)	\
+		__bm_err_isr_read(bm, bm_isr_status)
+#define bm_err_isr_status_clear(bm, m)	\
+		__bm_err_isr_write(bm, bm_isr_status, m)
+#define bm_err_isr_enable_read(bm)	\
+		__bm_err_isr_read(bm, bm_isr_enable)
+#define bm_err_isr_enable_write(bm, v)	\
+		__bm_err_isr_write(bm, bm_isr_enable, v)
+#define bm_err_isr_disable_read(bm)	\
+		__bm_err_isr_read(bm, bm_isr_disable)
+#define bm_err_isr_disable_write(bm, v)	\
+		__bm_err_isr_write(bm, bm_isr_disable, v)
+#define bm_err_isr_inhibit(bm)		\
+		__bm_err_isr_write(bm, bm_isr_inhibit, 1)
+#define bm_err_isr_uninhibit(bm)	\
+		__bm_err_isr_write(bm, bm_isr_inhibit, 0)
 
 /*
  * TODO: unimplemented registers
diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 25da5c8..e9cb12b 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -1426,10 +1426,12 @@ int usdpaa_get_portal_config(struct file *filp, void *cinh,
 		    portal->user.addr.cinh == cinh) {
 			if (ptype == usdpaa_portal_qman) {
 				*irq = portal->qportal->public_cfg.irq;
-				*iir_reg = portal->qportal->addr_virt[1] + QM_REG_IIR;
+				*iir_reg = portal->qportal->addr_virt[1] +
+					QM_REG_IIR;
 			} else {
 				*irq = portal->bportal->public_cfg.irq;
-				*iir_reg = portal->bportal->addr_virt[1] + BM_REG_IIR;
+				*iir_reg = portal->bportal->addr_virt[1] +
+					BM_REG_IIR;
 			}
 			spin_unlock(&context->lock);
 			return 0;
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 4ae99dc..95fdbb8 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -250,14 +250,22 @@ static const struct qman_error_info_mdata error_mdata[] = {
  * the QM_EIRQ_*** definitions. Note that "qm_err_isr_enable_write" means
  * "write the enable register" rather than "enable the write register"!
  */
-#define qm_err_isr_status_read(qm)	__qm_err_isr_read(qm, qm_isr_status)
-#define qm_err_isr_status_clear(qm, m)	__qm_err_isr_write(qm, qm_isr_status, m)
-#define qm_err_isr_enable_read(qm)	__qm_err_isr_read(qm, qm_isr_enable)
-#define qm_err_isr_enable_write(qm, v)	__qm_err_isr_write(qm, qm_isr_enable, v)
-#define qm_err_isr_disable_read(qm)	__qm_err_isr_read(qm, qm_isr_disable)
-#define qm_err_isr_disable_write(qm, v)	__qm_err_isr_write(qm, qm_isr_disable, v)
-#define qm_err_isr_inhibit(qm)		__qm_err_isr_write(qm, qm_isr_inhibit, 1)
-#define qm_err_isr_uninhibit(qm)	__qm_err_isr_write(qm, qm_isr_inhibit, 0)
+#define qm_err_isr_status_read(qm)	\
+		__qm_err_isr_read(qm, qm_isr_status)
+#define qm_err_isr_status_clear(qm, m)	\
+		__qm_err_isr_write(qm, qm_isr_status, m)
+#define qm_err_isr_enable_read(qm)	\
+		__qm_err_isr_read(qm, qm_isr_enable)
+#define qm_err_isr_enable_write(qm, v)	\
+		__qm_err_isr_write(qm, qm_isr_enable, v)
+#define qm_err_isr_disable_read(qm)	\
+		__qm_err_isr_read(qm, qm_isr_disable)
+#define qm_err_isr_disable_write(qm, v)	\
+		__qm_err_isr_write(qm, qm_isr_disable, v)
+#define qm_err_isr_inhibit(qm)		\
+		__qm_err_isr_write(qm, qm_isr_inhibit, 1)
+#define qm_err_isr_uninhibit(qm)	\
+		__qm_err_isr_write(qm, qm_isr_inhibit, 0)
 
 /*
  * TODO: unimplemented registers
@@ -310,7 +318,8 @@ static void qm_set_ddebug(struct qman *qm, u8 mdd, u8 m_cfg)
 	qm_out(DD_CFG, ((mdd & 0x3) << 4) | (m_cfg & 0xf));
 }
 
-static void qm_set_dc_ddebug(struct qman *qm, enum qm_dc_portal portal, u16 ecd_tp_cfg)
+static void qm_set_dc_ddebug(struct qman *qm, enum qm_dc_portal portal,
+			     u16 ecd_tp_cfg)
 {
 	qm_out(DCP_DD_CFG(portal), ecd_tp_cfg & 0x1ff);
 }
diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index a4bcbc4..18221ee 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -1281,10 +1281,11 @@ static inline int qm_shutdown_fq(struct qm_portal **portal, int portal_count,
 						  QM_SDQCR_CHANNELS_DEDICATED);
 			else
 				for (i = 0; i < portal_count; i++)
-					qm_dqrr_sdqcr_set(portal[i],
-							  QM_SDQCR_TYPE_ACTIVE |
-							  QM_SDQCR_CHANNELS_POOL_CONV
-							  (channel));
+					qm_dqrr_sdqcr_set(
+						portal[i],
+						QM_SDQCR_TYPE_ACTIVE |
+						QM_SDQCR_CHANNELS_POOL_CONV
+						(channel));
 			while (!found_fqrn) {
 				/* Keep draining DQRR while checking the MR*/
 				for (i = 0; i < portal_count; i++) {
diff --git a/include/linux/fsl_bman.h b/include/linux/fsl_bman.h
index e1cab5e..62bb66c 100644
--- a/include/linux/fsl_bman.h
+++ b/include/linux/fsl_bman.h
@@ -200,9 +200,11 @@ struct bm_mc_result {
 #define BM_MCR_VERB_CMD_ERR_ECC		0x70
 #define BM_MCR_VERB_ACQUIRE_BUFCOUNT	BM_MCC_VERB_ACQUIRE_BUFCOUNT /* 0..8 */
 /* Determine the "availability state" of pool 'p' from a query result 'r' */
-#define BM_MCR_QUERY_AVAILABILITY(r, p) bman_depletion_get(&r->query.as.state, p)
+#define BM_MCR_QUERY_AVAILABILITY(r, p)	\
+		bman_depletion_get(&r->query.as.state, p)
 /* Determine the "depletion state" of pool 'p' from a query result 'r' */
-#define BM_MCR_QUERY_DEPLETION(r, p) bman_depletion_get(&r->query.ds.state, p)
+#define BM_MCR_QUERY_DEPLETION(r, p)	\
+		bman_depletion_get(&r->query.ds.state, p)
 
 /*******************************************************************/
 /* Managed (aka "shared" or "mux/demux") portal, high-level i/face */
-- 
1.9.1

