From e28f373b8e21e292d6c20807e3a60099fa74f50d Mon Sep 17 00:00:00 2001
From: Tudor Ambarus <tudor.ambarus@freescale.com>
Date: Mon, 11 May 2015 19:16:26 +0300
Subject: [PATCH 1331/1336] crypto: caam/qi - tls10 support for 32bit platforms

Tested with tcrypt on p1023rdb platform.

Change-Id: Ic19a8d2ed5ce3603d2d9f893736b68eea03d480b
Signed-off-by: Tudor Ambarus <tudor.ambarus@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/36220
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Horia Ioan Geanta Neag <horia.geanta@freescale.com>
Reviewed-by: Honghua Yin <Hong-Hua.Yin@freescale.com>
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/crypto/caam/caamalg_qi.c | 111 +++++++++++++++++++++++++++++++++------
 1 file changed, 94 insertions(+), 17 deletions(-)

diff --git a/drivers/crypto/caam/caamalg_qi.c b/drivers/crypto/caam/caamalg_qi.c
index 81b82bd..cc47085 100644
--- a/drivers/crypto/caam/caamalg_qi.c
+++ b/drivers/crypto/caam/caamalg_qi.c
@@ -376,6 +376,12 @@ static int tls_set_sh_desc(struct crypto_aead *aead)
 	unsigned int blocksize = crypto_aead_blocksize(aead);
 	/* Associated data length is always = 13 for TLS */
 	unsigned int assoclen = 13;
+	/*
+	 * Pointer Size bool determines the size of address pointers.
+	 * false - Pointers fit in one 32-bit word.
+	 * true - Pointers fit in two 32-bit words.
+	 */
+	static const bool ps = (CAAM_PTR_SZ != CAAM_CMD_SZ);
 
 	if (!ctx->enckeylen || !ctx->authsize)
 		return 0;
@@ -587,6 +593,10 @@ static int tls_set_sh_desc(struct crypto_aead *aead)
 	/* VSOL = payloadlen + icvlen + padlen */
 	append_math_add(desc, VARSEQOUTLEN, ZERO, REG3, 4);
 
+#ifdef __LITTLE_ENDIAN
+	append_moveb(desc, MOVE_WAITCOMP |
+		     MOVE_SRC_MATH0 | MOVE_DEST_MATH0 | 8);
+#endif
 	/* update Len field */
 	append_math_sub(desc, REG0, REG0, REG2, 8);
 
@@ -626,23 +636,90 @@ static int tls_set_sh_desc(struct crypto_aead *aead)
 	/* VSIL = (payloadlen + icvlen + padlen) - icvlen + padlen */
 	append_math_sub(desc, VARSEQINLEN, REG3, REG2, 4);
 
-	/* move seqoutptr fields into math registers */
-	append_move(desc, MOVE_WAITCOMP | MOVE_SRC_DESCBUF | MOVE_DEST_MATH0 |
-			(54 * 4 << MOVE_OFFSET_SHIFT) | 20);
-	/* seqinptr will point to seqoutptr */
-	append_math_and_imm_u32(desc, REG0, REG0, IMM,
-				~(CMD_SEQ_IN_PTR ^ CMD_SEQ_OUT_PTR));
-	/* Load jump command */
-	jumpback = CMD_JUMP | (char)-9;
-	append_load_imm_u32(desc, jumpback, LDST_CLASS_DECO | LDST_IMM |
-			    LDST_SRCDST_WORD_DECO_MATH2 |
-			    (4 << LDST_OFFSET_SHIFT));
-	append_jump(desc, JUMP_TEST_ALL | JUMP_COND_CALM | 1);
-	/* move updated seqinptr fields to JD */
-	append_move(desc, MOVE_WAITCOMP | MOVE_SRC_MATH0 | MOVE_DEST_DESCBUF |
-			(54 * 4 << MOVE_OFFSET_SHIFT) | 24);
-	/* read updated seqinptr */
-	append_jump(desc, JUMP_TEST_ALL | JUMP_COND_CALM | 6);
+	/*
+	 * Start a new input sequence using the SEQ OUT PTR command options,
+	 * pointer and length used when the current output sequence was defined.
+	 */
+	if (ps) {
+		/*
+		 * Move the lower 32 bits of Shared Descriptor address, the
+		 * SEQ OUT PTR command, Output Pointer (2 words) and
+		 * Output Length into math registers.
+		 */
+#ifdef __LITTLE_ENDIAN
+		append_move(desc, MOVE_WAITCOMP | MOVE_SRC_DESCBUF |
+			    MOVE_DEST_MATH0 | (55 * 4 << MOVE_OFFSET_SHIFT) |
+			    20);
+#else
+		append_move(desc, MOVE_WAITCOMP | MOVE_SRC_DESCBUF |
+			    MOVE_DEST_MATH0 | (54 * 4 << MOVE_OFFSET_SHIFT) |
+			    20);
+#endif
+		/* Transform SEQ OUT PTR command in SEQ IN PTR command */
+		append_math_and_imm_u32(desc, REG0, REG0, IMM,
+					~(CMD_SEQ_IN_PTR ^ CMD_SEQ_OUT_PTR));
+		/* Append a JUMP command after the copied fields */
+		jumpback = CMD_JUMP | (char)-9;
+		append_load_imm_u32(desc, jumpback, LDST_CLASS_DECO | LDST_IMM |
+				    LDST_SRCDST_WORD_DECO_MATH2 |
+				    (4 << LDST_OFFSET_SHIFT));
+		append_jump(desc, JUMP_TEST_ALL | JUMP_COND_CALM | 1);
+		/* Move the updated fields back to the Job Descriptor */
+#ifdef __LITTLE_ENDIAN
+		append_move(desc, MOVE_WAITCOMP | MOVE_SRC_MATH0 |
+			    MOVE_DEST_DESCBUF | (55 * 4 << MOVE_OFFSET_SHIFT) |
+			    24);
+#else
+		append_move(desc, MOVE_WAITCOMP | MOVE_SRC_MATH0 |
+			    MOVE_DEST_DESCBUF | (54 * 4 << MOVE_OFFSET_SHIFT) |
+			    24);
+#endif
+		/*
+		 * Read the new SEQ IN PTR command, Input Pointer, Input Length
+		 * and then jump back to the next command from the
+		 * Shared Descriptor.
+		 */
+		append_jump(desc, JUMP_TEST_ALL | JUMP_COND_CALM | 6);
+	} else {
+		/*
+		 * Move the SEQ OUT PTR command, Output Pointer (1 word) and
+		 * Output Length into math registers.
+		 */
+#ifdef __LITTLE_ENDIAN
+		append_move(desc, MOVE_WAITCOMP | MOVE_SRC_DESCBUF |
+			    MOVE_DEST_MATH0 | (54 * 4 << MOVE_OFFSET_SHIFT) |
+			    12);
+#else
+		append_move(desc, MOVE_WAITCOMP | MOVE_SRC_DESCBUF |
+			    MOVE_DEST_MATH0 | (53 * 4 << MOVE_OFFSET_SHIFT) |
+			    12);
+#endif
+		/* Transform SEQ OUT PTR command in SEQ IN PTR command */
+		append_math_and_imm_u64(desc, REG0, REG0, IMM,
+			~(((u64)(CMD_SEQ_IN_PTR ^ CMD_SEQ_OUT_PTR)) << 32));
+		/* Append a JUMP command after the copied fields */
+		jumpback = CMD_JUMP | (char)-7;
+		append_load_imm_u32(desc, jumpback, LDST_CLASS_DECO | LDST_IMM |
+				    LDST_SRCDST_WORD_DECO_MATH1 |
+				    (4 << LDST_OFFSET_SHIFT));
+		append_jump(desc, JUMP_TEST_ALL | JUMP_COND_CALM | 1);
+		/* Move the updated fields back to the Job Descriptor */
+#ifdef __LITTLE_ENDIAN
+		append_move(desc, MOVE_WAITCOMP | MOVE_SRC_MATH0 |
+			    MOVE_DEST_DESCBUF | (54 * 4 << MOVE_OFFSET_SHIFT) |
+			    16);
+#else
+		append_move(desc, MOVE_WAITCOMP | MOVE_SRC_MATH0 |
+			    MOVE_DEST_DESCBUF | (53 * 4 << MOVE_OFFSET_SHIFT) |
+			    16);
+#endif
+		/*
+		 * Read the new SEQ IN PTR command, Input Pointer, Input Length
+		 * and then jump back to the next command from the
+		 * Shared Descriptor.
+		 */
+		 append_jump(desc, JUMP_TEST_ALL | JUMP_COND_CALM | 5);
+	}
 
 	/* skip payload */
 	append_seq_fifo_load(desc, 0, FIFOLD_CLASS_SKIP | FIFOLDST_VLF);
-- 
2.0.2

