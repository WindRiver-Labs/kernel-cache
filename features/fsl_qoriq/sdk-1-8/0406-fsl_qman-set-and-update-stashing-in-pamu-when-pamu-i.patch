From 157081c10fe0f89c8b7d8b2fe10397a1047de91d Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Wed, 23 Oct 2013 14:27:25 -0400
Subject: [PATCH 406/987] fsl_qman: set and update stashing in pamu when pamu
 is available

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

For the SoC without PAMU, we need to restrict the iommu domain apis
under the condition of CONFIG_FSL_PAMU, then avoid to update the pamu
stash setting for migrating portal when iommu_domain is not available.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: Iaa826e8f3a0173ba7d5c8781964a0aa7d0cc3657
Reviewed-on: http://git.am.freescale.net:8181/5954
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thorpe Geoff-R01361 <Geoff.Thorpe@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/qman_driver.c |  5 +++++
 drivers/staging/fsl_qbman/qman_high.c   | 31 +++++++++++--------------------
 2 files changed, 16 insertions(+), 20 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 53e5f176..78ecd98 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -475,6 +475,7 @@ static struct qm_portal_config *get_pcfg_idx(struct list_head *list, u32 idx)
 
 static void portal_set_cpu(struct qm_portal_config *pcfg, int cpu)
 {
+#ifdef CONFIG_FSL_PAMU
 	int ret;
 	int window_count = 1;
 	struct iommu_domain_geometry geom_attr;
@@ -536,6 +537,7 @@ static void portal_set_cpu(struct qm_portal_config *pcfg, int cpu)
 	}
 
 _no_iommu:
+#endif
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	if (qman_set_sdest(pcfg->public_cfg.channel, cpu))
 #endif
@@ -543,10 +545,12 @@ _no_iommu:
 
 	return;
 
+#ifdef CONFIG_FSL_PAMU
 _iommu_detach_device:
 	iommu_detach_device(pcfg->iommu_domain, NULL);
 _iommu_domain_free:
 	iommu_domain_free(pcfg->iommu_domain);
+#endif
 }
 
 struct qm_portal_config *qm_get_unused_portal_idx(u32 idx)
@@ -587,6 +591,7 @@ static struct qman_portal *init_pcfg(struct qm_portal_config *pcfg)
 {
 	struct qman_portal *p;
 
+	pcfg->iommu_domain = NULL;
 	portal_set_cpu(pcfg, pcfg->public_cfg.cpu);
 	p = qman_create_affine_portal(pcfg, NULL);
 	if (p) {
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 951ec3b..9d449f6 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -4941,30 +4941,21 @@ static void qman_portal_update_sdest(const struct qm_portal_config *pcfg,
 	struct iommu_stash_attribute stash_attr;
 	int ret;
 
-	if (!pcfg->iommu_domain) {
-		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_alloc() failed",
-			__func__);
-		goto _no_iommu;
-	}
-
-	stash_attr.cpu = cpu;
-	stash_attr.cache = IOMMU_ATTR_CACHE_L1;
-	stash_attr.window = ~(u32)0;
-	ret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_PAMU_STASH,
-					&stash_attr);
-	if (ret < 0) {
-		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_set_attr() = %d",
-					__func__, ret);
-		return;
+	if (pcfg->iommu_domain) {
+		stash_attr.cpu = cpu;
+		stash_attr.cache = IOMMU_ATTR_CACHE_L1;
+		stash_attr.window = ~(u32)0;
+		ret = iommu_domain_set_attr(pcfg->iommu_domain,
+				DOMAIN_ATTR_PAMU_STASH,	&stash_attr);
+		if (ret < 0) {
+			pr_err("Failed to update pamu stash setting\n");
+			return;
+		}
 	}
-
-_no_iommu:
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	if (qman_set_sdest(pcfg->public_cfg.channel, cpu))
 #endif
-		pr_warn("Failed to update portal's stash request queue\n");
-
-	return;
+		pr_warning("Failed to update portal's stash request queue\n");
 }
 
 int qman_portal_is_sharing_redirect(struct qman_portal *portal)
-- 
1.9.1

