From cd64ff3ca94c8ecdcf339a8b9eefde341416cdea Mon Sep 17 00:00:00 2001
From: Jiucheng Xu <Jiucheng.Xu@freescale.com>
Date: Thu, 16 Jan 2014 12:11:50 +0800
Subject: [PATCH 605/987] QE-TDM: add support to make QE-TDM work on 36bit
 physical address

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Signed-off-by: Jiucheng Xu <Jiucheng.Xu@freescale.com>
Signed-off-by: Zhao Qiang <B45475@freescale.com>
Change-Id: I3841888a780f6d4d3d38589c5de4cdd3916921ef
Reviewed-on: http://git.am.freescale.net:8181/9214
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Xiaobo Xie <X.Xie@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/10110
---
 arch/powerpc/include/asm/ucc_fast.h |  2 +-
 drivers/tdm/device/fsl_ucc_tdm.c    | 65 +++++++++++++++++++------------------
 drivers/tdm/device/fsl_ucc_tdm.h    |  4 +--
 3 files changed, 37 insertions(+), 34 deletions(-)

diff --git a/arch/powerpc/include/asm/ucc_fast.h b/arch/powerpc/include/asm/ucc_fast.h
index ec3b889..74fdd31 100644
--- a/arch/powerpc/include/asm/ucc_fast.h
+++ b/arch/powerpc/include/asm/ucc_fast.h
@@ -125,7 +125,7 @@ struct ucc_fast_info {
 	enum qe_clock tx_clock;
 	enum qe_clock rx_sync;
 	enum qe_clock tx_sync;
-	u32 regs;
+	resource_size_t regs;
 	int irq;
 	u32 uccm_mask;
 	int bd_mem_part;
diff --git a/drivers/tdm/device/fsl_ucc_tdm.c b/drivers/tdm/device/fsl_ucc_tdm.c
index 0f6b7b3..44204a3 100644
--- a/drivers/tdm/device/fsl_ucc_tdm.c
+++ b/drivers/tdm/device/fsl_ucc_tdm.c
@@ -347,34 +347,32 @@ static int utdm_init(struct ucc_tdm_private *priv)
 	/* Set UPSMR normal mode */
 	out_be32(&priv->uf_regs->upsmr, 0);
 
-	/* Alloc Rx BD */
-	priv->rx_bd_offset = qe_muram_alloc(NUM_OF_BUF * sizeof(struct qe_bd),
-			QE_ALIGNMENT_OF_BD);
-	if (IS_ERR_VALUE(priv->rx_bd_offset)) {
-		dev_err(priv->dev, "Cannot allocate MURAM memory for RxBDs\n");
+	priv->tx_bd = dma_alloc_coherent(priv->dev,
+			NUM_OF_BUF * MAX_RX_BUF_LENGTH,
+			&priv->dma_tx_bd, GFP_KERNEL);
+
+	if (!priv->tx_bd) {
+		dev_err(priv->dev, "Could not allocate buffer descriptors\n");
 		ret = -ENOMEM;
 		goto rxbd_alloc_error;
 	}
 
-	/* Alloc Tx BD */
-	priv->tx_bd_offset = qe_muram_alloc(NUM_OF_BUF * sizeof(struct qe_bd),
-				QE_ALIGNMENT_OF_BD);
-	if (IS_ERR_VALUE(priv->tx_bd_offset)) {
-		dev_err(priv->dev, "Cannot allocate MURAM memory for TxBDs\n");
+	priv->rx_bd = dma_alloc_coherent(priv->dev,
+			NUM_OF_BUF * MAX_RX_BUF_LENGTH,
+			&priv->dma_rx_bd, GFP_KERNEL);
+	if (!priv->rx_bd) {
+		dev_err(priv->dev, "Could not allocate buffer descriptors\n");
 		ret = -ENOMEM;
 		goto txbd_alloc_error;
 	}
 
-	priv->tx_bd = qe_muram_addr(priv->tx_bd_offset);
-	priv->rx_bd = qe_muram_addr(priv->rx_bd_offset);
-
 	/* Alloc parameter ram for ucc transparent */
-	priv->ucc_pram_offset = qe_muram_alloc(sizeof(priv->ucc_pram),
+	priv->ucc_pram_offset = qe_muram_alloc(sizeof(*priv->ucc_pram),
 				ALIGNMENT_OF_UCC_TRANS_PRAM);
 
 	if (IS_ERR_VALUE(priv->ucc_pram_offset)) {
 		dev_err(priv->dev, "Can not allocate MURAM for hdlc prameter.\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
 		goto pram_alloc_error;
 	}
 
@@ -413,16 +411,9 @@ static int utdm_init(struct ucc_tdm_private *priv)
 	/* Set MRBLR */
 	out_be16(&priv->ucc_pram->mrblr, (u16)MAX_RX_BUF_LENGTH);
 
-	/* QE couldn't support >= 4G */
-	if (cpm_muram_dma(priv->rx_bd) & ~(0xffffffffULL) &&
-	    cpm_muram_dma(priv->tx_bd) & ~(0xffffffffULL)) {
-		dev_err(priv->dev, "QE address couldn't support > 4G");
-		ret = -EFAULT;
-		goto tiptr_alloc_error;
-	}
-		/* Set RBASE, TBASE */
-	out_be32(&priv->ucc_pram->rbase, (u32)cpm_muram_dma(priv->rx_bd));
-	out_be32(&priv->ucc_pram->tbase, (u32)cpm_muram_dma(priv->tx_bd));
+	/* Set RBASE, TBASE */
+	out_be32(&priv->ucc_pram->rbase, (u32)priv->dma_rx_bd);
+	out_be32(&priv->ucc_pram->tbase, (u32)priv->dma_tx_bd);
 
 	/* Set RSTATE, TSTATE */
 	out_be32(&priv->ucc_pram->rstate, 0x30000000);
@@ -484,9 +475,13 @@ tiptr_alloc_error:
 riptr_alloc_error:
 	qe_muram_free(priv->ucc_pram_offset);
 pram_alloc_error:
-	qe_muram_free(priv->tx_bd_offset);
+	dma_free_coherent(priv->dev,
+		NUM_OF_BUF * MAX_RX_BUF_LENGTH,
+		priv->rx_bd, priv->dma_rx_bd);
 txbd_alloc_error:
-	qe_muram_free(priv->rx_bd_offset);
+	dma_free_coherent(priv->dev,
+		NUM_OF_BUF * MAX_RX_BUF_LENGTH,
+		priv->tx_bd, priv->dma_tx_bd);
 rxbd_alloc_error:
 	ucc_fast_free(priv->uccf);
 
@@ -657,15 +652,19 @@ static void utdm_memclean(struct ucc_tdm_private *priv)
 	qe_muram_free(priv->ucc_pram->tiptr);
 
 	if (priv->rx_bd) {
-		qe_muram_free(priv->rx_bd_offset);
+		dma_free_coherent(priv->dev,
+			NUM_OF_BUF * MAX_RX_BUF_LENGTH,
+			priv->rx_bd, priv->dma_rx_bd);
 		priv->rx_bd = NULL;
-		priv->rx_bd_offset = 0;
+		priv->dma_rx_bd = 0;
 	}
 
 	if (priv->tx_bd) {
-		qe_muram_free(priv->tx_bd_offset);
+		dma_free_coherent(priv->dev,
+			NUM_OF_BUF * MAX_RX_BUF_LENGTH,
+			priv->tx_bd, priv->dma_tx_bd);
 		priv->tx_bd = NULL;
-		priv->tx_bd_offset = 0;
+		priv->dma_tx_bd = 0;
 	}
 
 	if (priv->ucc_pram) {
@@ -810,6 +809,10 @@ static int ucc_tdm_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	/* use the same clock when work in loopback */
+	if (ut_info->uf_info.rx_clock == ut_info->uf_info.tx_clock)
+		qe_setbrg(ut_info->uf_info.rx_clock, 2000000, 1);
+
 	sprop = of_get_property(np, "fsl,rx-sync-clock", NULL);
 	if (sprop) {
 		ut_info->uf_info.rx_sync = qe_clock_source(sprop);
diff --git a/drivers/tdm/device/fsl_ucc_tdm.h b/drivers/tdm/device/fsl_ucc_tdm.h
index e15c0f2..627eb6c 100644
--- a/drivers/tdm/device/fsl_ucc_tdm.h
+++ b/drivers/tdm/device/fsl_ucc_tdm.h
@@ -147,8 +147,8 @@ struct ucc_tdm_private {
 	u8 phase_rx;
 	u8 phase_tx;
 	u32 ucc_pram_offset;
-	u32 tx_bd_offset;
-	u32 rx_bd_offset;
+	dma_addr_t dma_rx_bd;
+	dma_addr_t dma_tx_bd;
 	spinlock_t tdmlock;
 	wait_queue_head_t tdm_queue;
 	bool tdm_queue_flag;
-- 
1.9.1

