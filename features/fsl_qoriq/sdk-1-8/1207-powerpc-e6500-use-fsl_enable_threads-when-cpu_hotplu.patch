From 55a293ce0afc632ccad8261c8bfd94facde5939e Mon Sep 17 00:00:00 2001
From: Quanyang Wang <quanyang.wang@windriver.com>
Date: Wed, 4 Nov 2015 12:12:21 +0000
Subject: [PATCH 1207/1207] powerpc/e6500: use fsl_enable_threads when
 cpu_hotplug

When run cpu_hotplug in the state of SYSTEM_RUNNING, for example
down thread1 on core1 then up it, at first, we need to disable thread1
 before update value in TMRN_INIA1 and TMRN_IMSR1, and the second is
we should get the cpu id of the thread0 and write this value to
__thread0_cpu_id. So we use the function "fsl_enable_threads" to guarantee
these two points.

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/powerpc/platforms/85xx/smp.c | 11 ++++++++---
 1 file changed, 8 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index e2a73c2..5343cac 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -463,13 +463,18 @@ static void wake_hw_thread(void *info)
 	void fsl_secondary_thread_init(void);
 	unsigned long imsr1, inia1;
 	int nr = *(const int *)info;
+	int ret;
 
 	imsr1 = MSR_KERNEL;
 	inia1 = *(unsigned long *)fsl_secondary_thread_init;
 
-	mttmr(TMRN_IMSR1, imsr1);
-	mttmr(TMRN_INIA1, inia1);
-	mtspr(SPRN_TENS, TEN_THREAD(1));
+	if (system_state == SYSTEM_BOOTING) {
+		mttmr(TMRN_IMSR1, imsr1);
+		mttmr(TMRN_INIA1, inia1);
+		mtspr(SPRN_TENS, TEN_THREAD(1));
+	} else {
+		fsl_enable_threads(&ret);
+	}
 
 	smp_generic_kick_cpu(nr);
 }
-- 
2.0.2

