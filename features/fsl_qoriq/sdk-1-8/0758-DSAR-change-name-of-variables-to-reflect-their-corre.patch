From 7e24db3b32e8fc8ec7bd6752e3ee1a1c6845b913 Mon Sep 17 00:00:00 2001
From: Eyal Harari <Eyal.Harari@freesacle.com>
Date: Tue, 29 Jul 2014 09:56:56 +0300
Subject: [PATCH 758/987] DSAR: change name of variables to reflect their
 correct behaviour

Signed-off-by: Eyal Harari <Eyal.Harari@freesacle.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 .../ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c    |  6 +++---
 .../ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h    | 12 ++++++------
 .../freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h         | 12 ++++++------
 3 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index 920749b..68393ba 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -5729,11 +5729,11 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // filtering
     if (params->p_AutoResFilteringInfo)
     {
-        if (params->p_AutoResFilteringInfo->ipProtDropOnHit)
+        if (params->p_AutoResFilteringInfo->ipProtPassOnHit)
             tmp |= IP_PROT_TBL_PASS_MASK;
-        if (params->p_AutoResFilteringInfo->udpPortDropOnHit)
+        if (params->p_AutoResFilteringInfo->udpPortPassOnHit)
             tmp |= UDP_PORT_TBL_PASS_MASK;
-        if (params->p_AutoResFilteringInfo->tcpPortDropOnHit)
+        if (params->p_AutoResFilteringInfo->tcpPortPassOnHit)
             tmp |= TCP_PORT_TBL_PASS_MASK;
         WRITE_UINT8(ArCommonDescPtr->filterControl, tmp);
         WRITE_UINT16(ArCommonDescPtr->tcpControlPass, params->p_AutoResFilteringInfo->tcpFlagsMask);
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
index 3d5401c..3e9470b 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
@@ -1456,16 +1456,16 @@ typedef struct t_FmPortDsarFilteringInfo
     /* IP protocol filtering parameters */
     uint8_t     ipProtTableSize;
     uint8_t     *p_IpProtTablePtr;
-    bool        ipProtDropOnHit;  /* when TRUE, hit in the table will cause the packet to be droped,
-                                         miss will pass the packet to UDP/TCP filters if needed and if not
+    bool        ipProtPassOnHit;  /* when TRUE, miss in the table will cause the packet to be droped,
+                                         hit will pass the packet to UDP/TCP filters if needed and if not
                                          to the classification tree. If the classification tree will pass
                                          the packet to a queue it will cause a wake interupt.
                                          When FALSE it the other way around. */
     /* UDP port filtering parameters */
     uint8_t     udpPortsTableSize;
     t_FmPortDsarFilteringEntry *p_UdpPortsTablePtr;
-    bool        udpPortDropOnHit; /* when TRUE, hit in the table will cause the packet to be droped,
-                                         miss will pass the packet to classification tree.
+    bool        udpPortPassOnHit; /* when TRUE, miss in the table will cause the packet to be droped,
+                                         hit will pass the packet to classification tree.
                                          If the classification tree will pass the packet to a queue it
                                          will cause a wake interupt.
                                          When FALSE it the other way around. */
@@ -1473,8 +1473,8 @@ typedef struct t_FmPortDsarFilteringInfo
     uint16_t    tcpFlagsMask;
     uint8_t     tcpPortsTableSize;
     t_FmPortDsarFilteringEntry *p_TcpPortsTablePtr;
-    bool        tcpPortDropOnHit; /* when TRUE, hit in the table will cause the packet to be droped,
-                                         miss will pass the packet to classification tree.
+    bool        tcpPortPassOnHit; /* when TRUE, miss in the table will cause the packet to be droped,
+                                         hit will pass the packet to classification tree.
                                          If the classification tree will pass the packet to a queue it
                                          will cause a wake interupt.
                                          When FALSE it the other way around. */
diff --git a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
index 4e66564..aa3ec30 100644
--- a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
+++ b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
@@ -484,8 +484,8 @@ struct   auto_res_filtering_info
 	/* IP protocol filtering parameters */
 	uint8_t     ip_prot_table_size;
 	uint8_t     *ip_prot_table_ptr;
-	bool        ip_prot_drop_on_hit;  /* when TRUE, hit in the table will
-		cause the packet to be droped, miss will pass the packet to
+	bool        ip_prot_pass_on_hit;  /* when TRUE, miss in the table will
+		cause the packet to be droped, hit will pass the packet to
 		UDP/TCP filters if needed and if not to the classification
 		tree. If the classification tree will pass the packet to a
 		queue it will cause a wake interupt. When FALSE it the other
@@ -493,8 +493,8 @@ struct   auto_res_filtering_info
 	/* UDP port filtering parameters */
 	uint8_t     udp_ports_table_size;
 	struct auto_res_port_filtering_entry *udp_ports_table_ptr;
-	bool        udp_port_drop_on_hit; /* when TRUE, hit in the table will
-		cause the packet to be droped, miss will pass the packet to
+	bool        udp_port_pass_on_hit; /* when TRUE, miss in the table will
+		cause the packet to be droped, hit will pass the packet to
 		classification tree. If the classification tree will pass the
 		packet to a queue it will cause a wake interupt. When FALSE it
 		the other way around. */
@@ -502,8 +502,8 @@ struct   auto_res_filtering_info
 	uint16_t    tcp_flags_mask;
 	uint8_t     tcp_ports_table_size;
 	struct auto_res_port_filtering_entry *tcp_ports_table_ptr;
-	bool        tcp_port_drop_on_hit; /* when TRUE, hit in the table will
-		cause the packet to be droped, miss will pass the packet to
+	bool        tcp_port_pass_on_hit; /* when TRUE, miss in the table will
+		cause the packet to be droped, hit will pass the packet to
 		classification tree. If the classification tree will pass the
 		packet to a queue it will cause a wake interupt. When FALSE it
 		the other way around. */
-- 
1.9.1

