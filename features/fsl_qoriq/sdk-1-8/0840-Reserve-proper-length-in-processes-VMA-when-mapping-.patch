From 263ba30a3507b035c6d9b7aa135b7eebf1898585 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Tue, 2 Dec 2014 11:19:07 -0500
Subject: [PATCH 840/987] Reserve proper length in processes VMA when mapping
 USDPAA memory

USDPAA memory mapping were not properly reserving the entire
length of the memory area when perfoming mapping of not power
of 4 regions.  This causes issues if the choosen address overlapped
with an existing memory area.

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: I078d12279a43ddf3fc7c5de4b9e4a932d588832e
Reviewed-on: http://git.am.freescale.net:8181/25329
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Matthew Weigel <Matthew.Weigel@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index b1b38f5..dc0fa69 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -754,14 +754,13 @@ static unsigned long usdpaa_get_unmapped_area(struct file *file,
 
 	if (len % PAGE_SIZE)
 		return -EINVAL;
-	/* Need to align to largest pagesize to ensure all pages
-	   will be correctly aligned */
-	len = largest_page_size(len);
-
 	if (!len)
 		return -EINVAL;
 
-	addr = USDPAA_MEM_ROUNDUP(addr, len);
+	/* Need to align the address to the largest pagesize of the mapping
+	 * because the MMU requires the virtual address to have the same
+	 * alignment as the physical address */
+	addr = USDPAA_MEM_ROUNDUP(addr, largest_page_size(len));
 	vma = find_vma(current->mm, addr);
 	/* Keep searching until we reach the end of currently-used virtual
 	 * address-space or we find a big enough gap. */
@@ -769,7 +768,7 @@ static unsigned long usdpaa_get_unmapped_area(struct file *file,
 		if ((addr + len) < vma->vm_start)
 			return addr;
 
-		addr = USDPAA_MEM_ROUNDUP(vma->vm_end, len);
+		addr = USDPAA_MEM_ROUNDUP(vma->vm_end,  largest_page_size(len));
 		vma = vma->vm_next;
 	}
 	if ((TASK_SIZE - len) < addr)
-- 
1.9.1

