From c5b9b7aa71fc668d12776834b78fa6e62712d516 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Sun, 15 Mar 2015 23:42:46 +0900
Subject: [PATCH 926/987] fmd: Add support for reading BMI counters from US

Technical Details :  Add support for the following BMI counters
and make them available to the DPA stats interface in the
User Space:

 e_FM_PORT_COUNTERS_DISCARD_FRAME,
    /* BMI stat counter */
 e_FM_PORT_COUNTERS_RX_BAD_FRAME,
    /* BMI Rx stat counter */
 e_FM_PORT_COUNTERS_RX_LARGE_FRAME,
    /* BMI Rx stat counter */
 e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,
   /* BMI Rx OP stat counter */
 e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,
   /* BMI Rx OP stat counter */
 e_FM_PORT_COUNTERS_WRED_DISCARD,
   /* BMI OP stat counter */

 @Function      FM_PORT_GetBmiCounters

 @Description   Read port's BMI stat counters and place them into
                a designated structure of counters.

 @Param[in]     h_FmPort    A handle to a FM Port module.
 @Param[out]    p_BmiStats  counters structure

Change-Id: I464b5defc29e149252002c911b22e69343e61adf
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/32755
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Igal Liberman <Igal.Liberman@freescale.com>
Reviewed-by: Honghua Yin <Hong-Hua.Yin@freescale.com>
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../freescale/fman/Peripherals/FM/Port/fm_port.c   | 140 +++++++++++++++++++++
 .../freescale/fman/inc/Peripherals/fm_port_ext.h   |  34 +++++
 .../freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c  |  23 +++-
 .../uapi/linux/fmd/Peripherals/fm_port_ioctls.h    |  37 ++++++
 4 files changed, 233 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index d8e2ead..683b33f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -3989,6 +3989,146 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId,
     return E_OK;
 }
 
+t_Error FM_PORT_GetBmiCounters(t_Handle h_FmPort, t_FmPortBmiStats *p_BmiStats)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)){
+        p_BmiStats->cntCycle =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_CYCLE);
+            /* fmbm_rccn */
+        p_BmiStats->cntTaskUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL);
+            /* fmbm_rtuc */
+        p_BmiStats->cntQueueUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_QUEUE_UTIL);
+            /* fmbm_rrquc */
+        p_BmiStats->cntDmaUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL);
+            /* fmbm_rduc */
+        p_BmiStats->cntFifoUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL);
+            /* fmbm_rfuc */
+        p_BmiStats->cntRxPauseActivation =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION);
+            /* fmbm_rpac */
+        p_BmiStats->cntFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FRAME);
+            /* fmbm_rfrc */
+        p_BmiStats->cntDiscardFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DISCARD_FRAME);
+            /* fmbm_rfdc */
+        p_BmiStats->cntDeallocBuf =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DEALLOC_BUF);
+            /* fmbm_rbdc */
+        p_BmiStats->cntRxBadFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_BAD_FRAME);
+            /* fmbm_rfbc */
+        p_BmiStats->cntRxLargeFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_LARGE_FRAME);
+            /* fmbm_rlfc */
+        p_BmiStats->cntRxFilterFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_FILTER_FRAME);
+            /* fmbm_rffc */
+        p_BmiStats->cntRxListDmaErr =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR);
+            /* fmbm_rfldec */
+        p_BmiStats->cntRxOutOfBuffersDiscard =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD);
+            /* fmbm_rodc */
+        p_BmiStats->cntWredDiscard = 0;
+        p_BmiStats->cntLengthErr = 0;
+        p_BmiStats->cntUnsupportedFormat = 0;
+    }
+    else if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)){
+        p_BmiStats->cntCycle =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_CYCLE);
+            /* fmbm_tccn */
+        p_BmiStats->cntTaskUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL);
+            /* fmbm_ttuc */
+        p_BmiStats->cntQueueUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_QUEUE_UTIL);
+            /* fmbm_ttcquc */
+        p_BmiStats->cntDmaUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL);
+            /* fmbm_tduc */
+        p_BmiStats->cntFifoUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL);
+            /* fmbm_tfuc */
+        p_BmiStats->cntRxPauseActivation = 0;
+        p_BmiStats->cntFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FRAME);
+            /* fmbm_tfrc */
+        p_BmiStats->cntDiscardFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DISCARD_FRAME);
+            /* fmbm_tfdc */
+        p_BmiStats->cntDeallocBuf =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DEALLOC_BUF);
+            /* fmbm_tbdc */
+        p_BmiStats->cntRxBadFrame = 0;
+        p_BmiStats->cntRxLargeFrame = 0;
+        p_BmiStats->cntRxFilterFrame = 0;
+        p_BmiStats->cntRxListDmaErr = 0;
+        p_BmiStats->cntRxOutOfBuffersDiscard = 0;
+        p_BmiStats->cntWredDiscard = 0;
+        p_BmiStats->cntLengthErr =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_LENGTH_ERR);
+            /* fmbm_tfledc */
+        p_BmiStats->cntUnsupportedFormat =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT);
+            /* fmbm_tfufdc */
+    }
+    else if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) {
+        p_BmiStats->cntCycle =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_CYCLE);
+            /* fmbm_occn */
+        p_BmiStats->cntTaskUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL);
+            /* fmbm_otuc */
+        p_BmiStats->cntQueueUtil = 0;
+        p_BmiStats->cntDmaUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL);
+            /* fmbm_oduc */
+        p_BmiStats->cntFifoUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL);
+            /* fmbm_ofuc*/
+        p_BmiStats->cntRxPauseActivation = 0;
+        p_BmiStats->cntFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FRAME);
+            /* fmbm_ofrc */
+        p_BmiStats->cntDiscardFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DISCARD_FRAME);
+            /* fmbm_ofdc */
+        p_BmiStats->cntDeallocBuf =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DEALLOC_BUF);
+            /* fmbm_obdc*/
+        p_BmiStats->cntRxBadFrame = 0;
+        p_BmiStats->cntRxLargeFrame = 0;
+        p_BmiStats->cntRxFilterFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_FILTER_FRAME);
+            /* fmbm_offc */
+        p_BmiStats->cntRxListDmaErr =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR);
+            /* fmbm_ofldec */
+        p_BmiStats->cntRxOutOfBuffersDiscard =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD);
+            /* fmbm_rodc */
+        p_BmiStats->cntWredDiscard =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_WRED_DISCARD);
+            /* fmbm_ofwdc */
+        p_BmiStats->cntLengthErr =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_LENGTH_ERR);
+            /* fmbm_ofledc */
+        p_BmiStats->cntUnsupportedFormat =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT);
+            /* fmbm_ofufdc */
+    }
+    return E_OK;
+}
+
 uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
index fda908a..804b598 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
@@ -1294,6 +1294,25 @@ typedef enum e_FmPortCounters {
     e_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
 } e_FmPortCounters;
 
+typedef struct t_FmPortBmiStats {
+    uint32_t cntCycle;
+    uint32_t cntTaskUtil;
+    uint32_t cntQueueUtil;
+    uint32_t cntDmaUtil;
+    uint32_t cntFifoUtil;
+    uint32_t cntRxPauseActivation;
+    uint32_t cntFrame;
+    uint32_t cntDiscardFrame;
+    uint32_t cntDeallocBuf;
+    uint32_t cntRxBadFrame;
+    uint32_t cntRxLargeFrame;
+    uint32_t cntRxFilterFrame;
+    uint32_t cntRxListDmaErr;
+    uint32_t cntRxOutOfBuffersDiscard;
+    uint32_t cntWredDiscard;
+    uint32_t cntLengthErr;
+    uint32_t cntUnsupportedFormat;
+} t_FmPortBmiStats;
 
 /**************************************************************************//**
  @Description   Structure for Port id parameters.
@@ -1842,6 +1861,21 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort);
 t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
 
 /**************************************************************************//**
+ @Function      FM_PORT_GetBmiCounters
+
+ @Description   Read port's BMI stat counters and place them into
+                a designated structure of counters.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[out]    p_BmiStats  counters structure
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_GetBmiCounters(t_Handle h_FmPort, t_FmPortBmiStats *p_BmiStats);
+
+/**************************************************************************//**
  @Function      FM_PORT_GetCounter
 
  @Description   Reads one of the FM PORT counters.
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
index ffa1a2d..109dd36 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
@@ -3550,7 +3550,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
     t_Error err = E_OK;
 
     _fm_ioctl_dbg("cmd:0x%08x(type:0x%02x, nr:%u).\n",
-        cmd, _IOC_TYPE(cmd), _IOC_NR(cmd) - 50);
+        cmd, _IOC_TYPE(cmd), _IOC_NR(cmd) - 70);
 
     switch (cmd)
     {
@@ -4475,6 +4475,27 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             break;
         }
 
+        case FM_PORT_IOC_GET_BMI_COUNTERS:
+        {
+            t_LnxWrpFmDev *p_LnxWrpFmDev =
+                    (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+            ioc_fm_port_bmi_stats_t param;
+            int port_id = p_LnxWrpFmPortDev->id;
+
+            if (!p_LnxWrpFmDev)
+                RETURN_ERROR(MINOR, E_NOT_AVAILABLE, ("Port not initialized or other error!"));
+
+            if (FM_PORT_GetBmiCounters(p_LnxWrpFmPortDev->h_Dev,
+                        (t_FmPortBmiStats *)&param))
+                RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+
+            if (copy_to_user((ioc_fm_port_bmi_stats_t *)arg, &param,
+                        sizeof(ioc_fm_port_bmi_stats_t)))
+                RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+
+            break;
+        }
+
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION,
                 ("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
diff --git a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
index 49d1f50..0d5965e 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -186,6 +186,26 @@ typedef enum ioc_fm_port_counters {
     e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
 } ioc_fm_port_counters;
 
+typedef struct ioc_fm_port_bmi_stats_t {
+    uint32_t cnt_cycle;
+    uint32_t cnt_task_util;
+    uint32_t cnt_queue_util;
+    uint32_t cnt_dma_util;
+    uint32_t cnt_fifo_util;
+    uint32_t cnt_rx_pause_activation;
+    uint32_t cnt_frame;
+    uint32_t cnt_discard_frame;
+    uint32_t cnt_dealloc_buf;
+    uint32_t cnt_rx_bad_frame;
+    uint32_t cnt_rx_large_frame;
+    uint32_t cnt_rx_filter_frame;
+    uint32_t cnt_rx_list_dma_err;
+    uint32_t cnt_rx_out_of_buffers_discard;
+    uint32_t cnt_wred_discard;
+    uint32_t cnt_length_err;
+    uint32_t cnt_unsupported_format;
+} ioc_fm_port_bmi_stats_t;
+
 /**************************************************************************//**
  @Description   Structure for Port id parameters.
                 (Description may be inaccurate;
@@ -915,6 +935,23 @@ typedef struct ioc_fm_port_vsp_alloc_params_t {
 #define FM_PORT_IOC_VSP_ALLOC _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_fm_port_vsp_alloc_params_t)
 #endif /* (DPAA_VERSION >= 11) */
 
+/**************************************************************************//**
+ @Function      FM_PORT_GetBmiCounters
+
+ @Description   Read port's BMI stat counters and place them into
+                a designated structure of counters.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[out]    p_BmiStats  counters structure
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+
+#define FM_PORT_IOC_GET_BMI_COUNTERS _IOR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(42), ioc_fm_port_bmi_stats_t)
+
+
 /** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
 /** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
 
-- 
1.9.1

