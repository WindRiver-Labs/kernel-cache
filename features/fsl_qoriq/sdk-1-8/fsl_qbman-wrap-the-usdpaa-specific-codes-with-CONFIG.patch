From 912040e2ab5ffcee9a81d5a9bd62fc20a817c0f8 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 25 Apr 2016 16:16:39 +0800
Subject: [PATCH] fsl_qbman: wrap the usdpaa specific codes with
 CONFIG_FSL_USDPAA

Fix the following build warnings and errors when CONFIG_FSL_USDPAA
is disabled:
drivers/staging/fsl_qbman/dpa_sys.h:299:9: warning: 'enum usdpaa_portal_type' declared inside parameter list
         void **iir_reg);
         ^
drivers/staging/fsl_qbman/bman_driver.c:229:34: error: 'QBMAN_ANY_PORTAL_IDX' undeclared (first use in this function)
  return bm_get_unused_portal_idx(QBMAN_ANY_PORTAL_IDX);
                                  ^
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/bman_driver.c  |    4 ++-
 drivers/staging/fsl_qbman/bman_private.h |    2 +
 drivers/staging/fsl_qbman/dpa_sys.h      |    3 +-
 drivers/staging/fsl_qbman/qman_driver.c  |   33 ++++++++++++++++-------------
 drivers/staging/fsl_qbman/qman_private.h |    2 +
 5 files changed, 27 insertions(+), 17 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 980a7d3..12565d0 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -49,7 +49,6 @@ static struct bman_portal *shared_portals[NR_CPUS];
 static int num_shared_portals;
 static int shared_portals_idx;
 static LIST_HEAD(unused_pcfgs);
-static DEFINE_SPINLOCK(unused_pcfgs_lock);
 static void *affine_bportals[NR_CPUS];
 
 static int __init fsl_bpool_init(struct device_node *node)
@@ -209,6 +208,7 @@ static struct bm_portal_config *get_pcfg(struct list_head *list)
 	return pcfg;
 }
 
+#ifdef CONFIG_FSL_USDPAA
 static struct bm_portal_config *get_pcfg_idx(struct list_head *list,
 					     uint32_t idx)
 {
@@ -224,6 +224,7 @@ static struct bm_portal_config *get_pcfg_idx(struct list_head *list,
 	return NULL;
 }
 
+static DEFINE_SPINLOCK(unused_pcfgs_lock);
 struct bm_portal_config *bm_get_unused_portal(void)
 {
 	return bm_get_unused_portal_idx(QBMAN_ANY_PORTAL_IDX);
@@ -247,6 +248,7 @@ void bm_put_unused_portal(struct bm_portal_config *pcfg)
 	list_add(&pcfg->list, &unused_pcfgs);
 	spin_unlock(&unused_pcfgs_lock);
 }
+#endif
 
 static struct bman_portal *init_pcfg(struct bm_portal_config *pcfg)
 {
diff --git a/drivers/staging/fsl_qbman/bman_private.h b/drivers/staging/fsl_qbman/bman_private.h
index 34e4127..ae7f4ca 100644
--- a/drivers/staging/fsl_qbman/bman_private.h
+++ b/drivers/staging/fsl_qbman/bman_private.h
@@ -81,11 +81,13 @@ void bman_destroy_portal(struct bman_portal *bm);
 
 const struct bm_portal_config *bman_destroy_affine_portal(void);
 
+#ifdef CONFIG_FSL_USDPAA
 /* Hooks from fsl_usdpaa.c to bman_driver.c */
 struct bm_portal_config *bm_get_unused_portal(void);
 struct bm_portal_config *bm_get_unused_portal_idx(uint32_t idx);
 void bm_put_unused_portal(struct bm_portal_config *pcfg);
 void bm_set_liodns(struct bm_portal_config *pcfg);
+#endif
 
 /* Pool logic in the portal driver, during initialisation, needs to know if
  * there's access to CCSR or not (if not, it'll cripple the pool allocator). */
diff --git a/drivers/staging/fsl_qbman/dpa_sys.h b/drivers/staging/fsl_qbman/dpa_sys.h
index 7dd0640..cc0d4d3 100644
--- a/drivers/staging/fsl_qbman/dpa_sys.h
+++ b/drivers/staging/fsl_qbman/dpa_sys.h
@@ -293,9 +293,10 @@ err:
 	return -EINVAL;
 }
 
+#ifdef CONFIG_FSL_USDPAA
 /* Hooks from fsl_usdpaa_irq.c to fsl_usdpaa.c */
 int usdpaa_get_portal_config(struct file *filp, void *cinh,
 			     enum usdpaa_portal_type ptype, unsigned int *irq,
 			     void **iir_reg);
-
+#endif
 #endif /* DPA_SYS_H */
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index c3566f8..cc07afd 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -69,7 +69,6 @@ static struct qman_portal *shared_portals[NR_CPUS];
 static int num_shared_portals;
 static int shared_portals_idx;
 static LIST_HEAD(unused_pcfgs);
-static DEFINE_SPINLOCK(unused_pcfgs_lock);
 
 /* A SDQCR mask comprising all the available/visible pool channels */
 static u32 pools_sdqcr;
@@ -472,20 +471,6 @@ static struct qm_portal_config *get_pcfg(struct list_head *list)
 	return pcfg;
 }
 
-static struct qm_portal_config *get_pcfg_idx(struct list_head *list, u32 idx)
-{
-	struct qm_portal_config *pcfg;
-	if (list_empty(list))
-		return NULL;
-	list_for_each_entry(pcfg, list, list) {
-		if (pcfg->public_cfg.index == idx) {
-			list_del(&pcfg->list);
-			return pcfg;
-		}
-	}
-	return NULL;
-}
-
 static void portal_set_cpu(struct qm_portal_config *pcfg, int cpu)
 {
 #ifdef CONFIG_FSL_PAMU
@@ -569,6 +554,23 @@ _iommu_domain_free:
 #endif
 }
 
+#ifdef CONFIG_FSL_USDPAA
+static DEFINE_SPINLOCK(unused_pcfgs_lock);
+
+static struct qm_portal_config *get_pcfg_idx(struct list_head *list, u32 idx)
+{
+	struct qm_portal_config *pcfg;
+	if (list_empty(list))
+		return NULL;
+	list_for_each_entry(pcfg, list, list) {
+		if (pcfg->public_cfg.index == idx) {
+			list_del(&pcfg->list);
+			return pcfg;
+		}
+	}
+	return NULL;
+}
+
 struct qm_portal_config *qm_get_unused_portal_idx(u32 idx)
 {
 	struct qm_portal_config *ret;
@@ -603,6 +605,7 @@ void qm_put_unused_portal(struct qm_portal_config *pcfg)
 	list_add(&pcfg->list, &unused_pcfgs);
 	spin_unlock(&unused_pcfgs_lock);
 }
+#endif
 
 static struct qman_portal *init_pcfg(struct qm_portal_config *pcfg)
 {
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index e9f60d5..911de7f 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -228,12 +228,14 @@ struct qman_portal *qman_create_affine_slave(struct qman_portal *redirect,
 const struct qm_portal_config *qman_destroy_affine_portal(void);
 void qman_destroy_portal(struct qman_portal *qm);
 
+#ifdef CONFIG_FSL_USDPAA
 /* Hooks from fsl_usdpaa.c to qman_driver.c */
 struct qm_portal_config *qm_get_unused_portal(void);
 struct qm_portal_config *qm_get_unused_portal_idx(uint32_t idx);
 
 void qm_put_unused_portal(struct qm_portal_config *pcfg);
 void qm_set_liodns(struct qm_portal_config *pcfg);
+#endif
 
 /* This CGR feature is supported by h/w and required by unit-tests and the
  * debugfs hooks, so is implemented in the driver. However it allows an explicit
-- 
1.7.5.4

