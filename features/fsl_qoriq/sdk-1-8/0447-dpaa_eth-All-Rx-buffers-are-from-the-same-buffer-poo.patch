From aa97f54a64b095bae5bf466d1c43ab626a45f524 Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Wed, 4 Dec 2013 21:13:54 +0000
Subject: [PATCH 447/987] dpaa_eth: All Rx buffers are from the same buffer
 pool

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

We only have a single, global Rx buffer pool so there's no need to
read the bpid from every FD or S/G entry.
As a safeguard, keep BUG_ONs in place to detect any malformed buffer.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: I1c0f9e91255519704a8d24892bffe6190a2332ad
Reviewed-on: http://git.am.freescale.net:8181/7090
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
(cherry picked from commit 5f8d28c25f3053a7a55fea503eefadd1f2c58685)
Old change Id: I1c0f9e91255519704a8d24892bffe6190a2332ad
Reviewed-on: http://git.am.freescale.net:8181/7106
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/7683
Tested-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 7d37ada..93ce7f5 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -408,14 +408,15 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 	vaddr = phys_to_virt(addr);
 	DPA_BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
 
+	dpa_bp = priv->dpa_bp;
 	/* Iterate through the SGT entries and add data buffers to the skb */
 	sgt = vaddr + fd_off;
 	for (i = 0; i < DPA_SGT_MAX_ENTRIES; i++) {
 		/* Extension bit is not supported */
 		DPA_BUG_ON(sgt[i].extension);
 
-		dpa_bp = dpa_bpid2pool(sgt[i].bpid);
-		DPA_BUG_ON(!dpa_bp);
+		/* We use a single global Rx pool */
+		DPA_BUG_ON(dpa_bp != dpa_bpid2pool(sgt[i].bpid));
 		count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 
 		sg_addr = qm_sg_addr(&sgt[i]);
@@ -508,8 +509,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 	WARN_ONCE(i == DPA_SGT_MAX_ENTRIES, "No final bit on SGT\n");
 
 	/* recycle the SGT fragment */
-	dpa_bp = dpa_bpid2pool(fd->bpid);
-	DPA_BUG_ON(!dpa_bp);
+	DPA_BUG_ON(dpa_bp != dpa_bpid2pool(fd->bpid));
 	dpa_bp_recycle_frag(dpa_bp, (unsigned long)vaddr);
 	return skb;
 }
@@ -539,8 +539,8 @@ void __hot _dpa_rx(struct net_device *net_dev,
 		goto _release_frame;
 	}
 
-	dpa_bp = dpa_bpid2pool(fd->bpid);
-	DPA_BUG_ON(!dpa_bp);
+	dpa_bp = priv->dpa_bp;
+	DPA_BUG_ON(dpa_bp != dpa_bpid2pool(fd->bpid));
 	count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 	/* Prepare to read from the buffer, but don't unmap it until
 	 * we know the skb allocation succeeded. At this point we already
-- 
1.9.1

