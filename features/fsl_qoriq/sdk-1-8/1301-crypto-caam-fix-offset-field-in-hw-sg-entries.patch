From ebc48bf7377a20e951200ff585fe17c1f8649b92 Mon Sep 17 00:00:00 2001
From: Cristian Stoica <cristian.stoica@freescale.com>
Date: Mon, 22 Sep 2014 18:15:07 +0300
Subject: [PATCH 1301/1336] crypto: caam: fix offset field in hw sg entries

The offset field is 13 bits wide; make sure we don't overwrite more than
that in the caam hardware scatter gather structure

Signed-off-by: Cristian Stoica <cristian.stoica@freescale.com>
Change-Id: Id590d2aa9362d58e6920d9e54076ff6f184f3815
Reviewed-on: http://git.am.freescale.net:8181/19801
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Mircea Pop <mircea.pop@freescale.com>
Reviewed-by: Matthew Weigel <Matthew.Weigel@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/crypto/caam/desc.h       | 1 +
 drivers/crypto/caam/sg_sw_qm.h   | 8 ++++----
 drivers/crypto/caam/sg_sw_sec4.h | 8 ++++----
 include/linux/fsl_qman.h         | 1 +
 4 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h
index e45e598..d16d0b3 100644
--- a/drivers/crypto/caam/desc.h
+++ b/drivers/crypto/caam/desc.h
@@ -15,6 +15,7 @@ struct sec4_sg_entry {
 	u32 len;
 	u8 reserved;
 	u8 buf_pool_id;
+#define SEC4_SG_OFFSET_MASK 0x1FFF
 	u16 offset;
 };
 
diff --git a/drivers/crypto/caam/sg_sw_qm.h b/drivers/crypto/caam/sg_sw_qm.h
index de867ef..2778dbf 100644
--- a/drivers/crypto/caam/sg_sw_qm.h
+++ b/drivers/crypto/caam/sg_sw_qm.h
@@ -35,7 +35,7 @@
 #include "linux/fsl_qman.h"
 
 static inline void dma_to_qm_sg_one(struct qm_sg_entry *qm_sg_ptr,
-				      dma_addr_t dma, u32 len, u32 offset)
+				      dma_addr_t dma, u32 len, u16 offset)
 {
 	qm_sg_ptr->addr = dma;
 	qm_sg_ptr->extension = 0;
@@ -44,7 +44,7 @@ static inline void dma_to_qm_sg_one(struct qm_sg_entry *qm_sg_ptr,
 	qm_sg_ptr->__reserved2 = 0;
 	qm_sg_ptr->bpid = 0;
 	qm_sg_ptr->__reserved3 = 0;
-	qm_sg_ptr->offset = offset;
+	qm_sg_ptr->offset = offset & QM_SG_OFFSET_MASK;
 }
 
 /*
@@ -53,7 +53,7 @@ static inline void dma_to_qm_sg_one(struct qm_sg_entry *qm_sg_ptr,
  */
 static inline struct qm_sg_entry *
 sg_to_qm_sg(struct scatterlist *sg, int sg_count,
-	    struct qm_sg_entry *qm_sg_ptr, u32 offset)
+	    struct qm_sg_entry *qm_sg_ptr, u16 offset)
 {
 	while (sg_count) {
 		dma_to_qm_sg_one(qm_sg_ptr, sg_dma_address(sg),
@@ -72,7 +72,7 @@ sg_to_qm_sg(struct scatterlist *sg, int sg_count,
  */
 static inline void sg_to_qm_sg_last(struct scatterlist *sg, int sg_count,
 				      struct qm_sg_entry *qm_sg_ptr,
-				      u32 offset)
+				      u16 offset)
 {
 	qm_sg_ptr = sg_to_qm_sg(sg, sg_count, qm_sg_ptr, offset);
 	qm_sg_ptr->final = 1;
diff --git a/drivers/crypto/caam/sg_sw_sec4.h b/drivers/crypto/caam/sg_sw_sec4.h
index aa36fcf..8095475 100644
--- a/drivers/crypto/caam/sg_sw_sec4.h
+++ b/drivers/crypto/caam/sg_sw_sec4.h
@@ -11,13 +11,13 @@ struct sec4_sg_entry;
  * convert single dma address to h/w link table format
  */
 static inline void dma_to_sec4_sg_one(struct sec4_sg_entry *sec4_sg_ptr,
-				      dma_addr_t dma, u32 len, u32 offset)
+				      dma_addr_t dma, u32 len, u16 offset)
 {
 	sec4_sg_ptr->ptr = dma;
 	sec4_sg_ptr->len = len;
 	sec4_sg_ptr->reserved = 0;
 	sec4_sg_ptr->buf_pool_id = 0;
-	sec4_sg_ptr->offset = offset;
+	sec4_sg_ptr->offset = offset & SEC4_SG_OFFSET_MASK;
 #ifdef DEBUG
 	print_hex_dump(KERN_ERR, "sec4_sg_ptr@: ",
 		       DUMP_PREFIX_ADDRESS, 16, 4, sec4_sg_ptr,
@@ -31,7 +31,7 @@ static inline void dma_to_sec4_sg_one(struct sec4_sg_entry *sec4_sg_ptr,
  */
 static inline struct sec4_sg_entry *
 sg_to_sec4_sg(struct scatterlist *sg, int sg_count,
-	      struct sec4_sg_entry *sec4_sg_ptr, u32 offset)
+	      struct sec4_sg_entry *sec4_sg_ptr, u16 offset)
 {
 	while (sg_count) {
 		dma_to_sec4_sg_one(sec4_sg_ptr, sg_dma_address(sg),
@@ -49,7 +49,7 @@ sg_to_sec4_sg(struct scatterlist *sg, int sg_count,
  */
 static inline void sg_to_sec4_sg_last(struct scatterlist *sg, int sg_count,
 				      struct sec4_sg_entry *sec4_sg_ptr,
-				      u32 offset)
+				      u16 offset)
 {
 	sec4_sg_ptr = sg_to_sec4_sg(sg, sg_count, sec4_sg_ptr, offset);
 	sec4_sg_ptr->len |= SEC4_SG_LEN_FIN;
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 7e0103b..0e68263 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -230,6 +230,7 @@ static inline dma_addr_t qm_fd_addr(const struct qm_fd *fd)
 	{ cmd } }
 
 /* See 2.2.1.3 Multi-Core Datapath Acceleration Architecture */
+#define QM_SG_OFFSET_MASK 0x1FFF
 struct qm_sg_entry {
 	union {
 		struct {
-- 
2.0.2

