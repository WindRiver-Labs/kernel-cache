From 8ce2ae353bc09617746b5d515ed6408c16f64f03 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 20 Jul 2012 18:10:32 +0800
Subject: [PATCH 724/987] Q/BMAN: set IRQF_NOBALANCING for the portal irq
 handler

The Q/BMAN portal is bound to a specific cpu. It make no sense
to migrate the portal irq to orther cpu when a cpu is down. And the
portal irq handler also doesn't support reentry. That mean we can't
handle two portal irq on a single cpu. So set the portal irq with
IQF_NOBALANCING flag to avoid irq migration or setting affinity
by userspace.

But after we set IRQF_NOBALANCING when call request_irq() firstly,

request_irq() -> request_threaded_irq() -> __setup_irq()

{
...
        /* Exclude IRQ from balancing if requested */
        if (new->flags & IRQF_NOBALANCING) {
            irq_settings_set_no_balancing(desc);
            irqd_set(&desc->irq_data, IRQD_NO_BALANCING);
        }
...
}

and current kernel will call irq_can_set_affinity() to check if
one given irq can be set affinity:

int irq_can_set_affinity(unsigned int irq)
{
    struct irq_desc *desc = irq_to_desc(irq);

    if (!desc || !irqd_can_balance(&desc->irq_data) ||
        !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)
        return 0;

    return 1;
}

So if this irq can't be balanced we can't do this properly. Here we have
to check/set irq affinity at first then disable irq blance from request_irq.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/bman_high.c | 10 +++++-----
 drivers/staging/fsl_qbman/qman_high.c | 10 +++++-----
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index cc25de4..f0aa67f 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -307,11 +307,6 @@ struct bman_portal *bman_create_portal(
 	bm_isr_enable_write(__p, portal->irq_sources);
 	bm_isr_status_clear(__p, 0xffffffff);
 	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->public_cfg.cpu);
-	if (request_irq(config->public_cfg.irq, portal_isr, 0, portal->irqname,
-			portal)) {
-		pr_err("request_irq() failed\n");
-		goto fail_irq;
-	}
 	if ((config->public_cfg.cpu != -1) &&
 			irq_can_set_affinity(config->public_cfg.irq) &&
 			irq_set_affinity(config->public_cfg.irq,
@@ -319,6 +314,11 @@ struct bman_portal *bman_create_portal(
 		pr_err("irq_set_affinity() failed\n");
 		goto fail_affinity;
 	}
+	if (request_irq(config->public_cfg.irq, portal_isr, IRQF_NOBALANCING, portal->irqname,
+			portal)) {
+		pr_err("request_irq() failed\n");
+		goto fail_irq;
+	}
 
 	/* Need RCR to be empty before continuing */
 	ret = bm_rcr_get_fill(__p);
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 370e260..5a5bfb3 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -516,11 +516,6 @@ struct qman_portal *qman_create_portal(
 	qm_isr_enable_write(__p, portal->irq_sources);
 	qm_isr_status_clear(__p, 0xffffffff);
 	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->public_cfg.cpu);
-	if (request_irq(config->public_cfg.irq, portal_isr, 0, portal->irqname,
-				portal)) {
-		pr_err("request_irq() failed\n");
-		goto fail_irq;
-	}
 	if ((config->public_cfg.cpu != -1) &&
 			irq_can_set_affinity(config->public_cfg.irq) &&
 			irq_set_affinity(config->public_cfg.irq,
@@ -528,6 +523,11 @@ struct qman_portal *qman_create_portal(
 		pr_err("irq_set_affinity() failed\n");
 		goto fail_affinity;
 	}
+	if (request_irq(config->public_cfg.irq, portal_isr, IRQF_NOBALANCING, portal->irqname,
+				portal)) {
+		pr_err("request_irq() failed\n");
+		goto fail_irq;
+	}
 
 	/* Need EQCR to be empty before continuing */
 	isdr ^= QM_PIRQ_EQCI;
-- 
1.9.1

