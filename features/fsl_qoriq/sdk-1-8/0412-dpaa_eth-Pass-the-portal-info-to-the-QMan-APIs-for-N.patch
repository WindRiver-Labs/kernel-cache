From ae72a419a079c77d76612d7e17bc7ce4606922cd Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Mon, 30 Sep 2013 13:52:29 -0400
Subject: [PATCH 412/987] dpaa_eth: Pass the portal info to the QMan APIs for
 NAPI scheduling.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Pass the portal info via callbacks in order to call the new qman apis for napi
schedule and napi poll, thus follow the portal to disable its DQRI or enable
DQRI for NAPI, regardless the portal is migrated to other cpu (in hotplug case)
or not.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: Ie79a5ba106726032837299c4c5dd3291e8a10789
Reviewed-on: http://git.am.freescale.net:8181/5454
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c | 15 +++++++++++----
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h |  3 ++-
 2 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 9cd3214..b68d8d1 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -275,12 +275,15 @@ void __hot _dpa_process_parse_results(const fm_prs_result_t *parse_results,
 
 static int dpaa_eth_poll(struct napi_struct *napi, int budget)
 {
-	int cleaned = qman_poll_dqrr(budget);
+	struct dpa_percpu_priv_s *percpu_priv =
+			container_of(napi, struct dpa_percpu_priv_s, napi);
+
+	int cleaned = qman_p_poll_dqrr(percpu_priv->p, budget);
 
 	if (cleaned < budget) {
 		int tmp;
 		napi_complete(napi);
-		tmp = qman_irqsource_add(QM_PIRQ_DQRI);
+		tmp = qman_p_irqsource_add(percpu_priv->p, QM_PIRQ_DQRI);
 		BUG_ON(tmp);
 	}
 
@@ -336,6 +339,7 @@ priv_rx_error_dqrr(struct qman_portal		*portal,
 	priv = netdev_priv(net_dev);
 
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
+	percpu_priv->p = portal;
 
 	if (dpaa_eth_napi_schedule(percpu_priv))
 		return qman_cb_dqrr_stop;
@@ -370,6 +374,7 @@ priv_rx_default_dqrr(struct qman_portal		*portal,
 
 	/* IRQ handler, non-migratable; safe to use __this_cpu_ptr here */
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
+	percpu_priv->p = portal;
 
 	if (unlikely(dpaa_eth_napi_schedule(percpu_priv)))
 		return qman_cb_dqrr_stop;
@@ -401,6 +406,7 @@ priv_tx_conf_error_dqrr(struct qman_portal		*portal,
 	priv = netdev_priv(net_dev);
 
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
+	percpu_priv->p = portal;
 
 	if (dpaa_eth_napi_schedule(percpu_priv))
 		return qman_cb_dqrr_stop;
@@ -427,6 +433,7 @@ priv_tx_conf_default_dqrr(struct qman_portal		*portal,
 
 	/* Non-migratable context, safe to use __this_cpu_ptr */
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
+	percpu_priv->p = portal;
 
 	if (dpaa_eth_napi_schedule(percpu_priv))
 		return qman_cb_dqrr_stop;
@@ -545,9 +552,9 @@ static void dpaa_eth_poll_controller(struct net_device *net_dev)
 		__this_cpu_ptr(priv->percpu_priv);
 	struct napi_struct napi = percpu_priv->napi;
 
-	qman_irqsource_remove(QM_PIRQ_DQRI);
+	qman_p_irqsource_remove(percpu_priv->p, QM_PIRQ_DQRI);
 	qman_poll_dqrr(napi.weight);
-	qman_irqsource_add(QM_PIRQ_DQRI);
+	qman_p_irqsource_add(percpu_priv->p, QM_PIRQ_DQRI);
 }
 #endif
 
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index d179fda..97f3672 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -383,6 +383,7 @@ struct dpa_ern_cnt {
 struct dpa_percpu_priv_s {
 	struct net_device *net_dev;
 	struct napi_struct napi;
+	struct qman_portal *p;
 	u64 in_interrupt;
 	u64 tx_returned;
 	u64 tx_confirm;
@@ -504,7 +505,7 @@ static inline int dpaa_eth_napi_schedule(struct dpa_percpu_priv_s *percpu_priv)
 	 */
 	if (unlikely(in_irq() || !in_serving_softirq())) {
 		/* Disable QMan IRQ and invoke NAPI */
-		int ret = qman_irqsource_remove(QM_PIRQ_DQRI);
+		int ret = qman_p_irqsource_remove(percpu_priv->p, QM_PIRQ_DQRI);
 		if (likely(!ret)) {
 			napi_schedule(&percpu_priv->napi);
 			percpu_priv->in_interrupt++;
-- 
1.9.1

