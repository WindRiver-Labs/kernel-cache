From e5b6c489d898619c814a8b8a67fc31457654386f Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Mon, 15 Jul 2013 09:23:46 -0400
Subject: [PATCH 302/987] fsl_qman: correctly update the cscn target when
 deleting cgr and releasing ccg

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: I7f0351f735232442c1bef4df80323852523e0315
Reviewed-on: http://git.am.freescale.net:8181/3304
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/staging/fsl_qbman/qman_high.c | 14 +++++---------
 1 file changed, 5 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 85cdcf1..8dbb0ce 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -114,14 +114,12 @@ struct qman_portal {
 	struct list_head cgr_cbs;
 	/* list lock */
 	spinlock_t cgr_lock;
-
 	/* 2-element array. ccgrs[0] is mask, ccgrs[1] is snapshot. */
 	struct qman_ccgrs *ccgrs[QMAN_CEETM_MAX];
 	/* 256-element array, each is a linked-list of CCSCN handlers. */
 	struct list_head ccgr_cbs[QMAN_CEETM_MAX];
 	/* list lock */
 	spinlock_t ccgr_lock;
-
 	/* track if memory was allocated by the driver */
 	u8 alloced;
 };
@@ -599,7 +597,6 @@ void qman_destroy_portal(struct qman_portal *qm)
 	/* Stop dequeues on the portal */
 	qm_dqrr_sdqcr_set(&qm->p, 0);
 
-
 	/* NB we do this to "quiesce" EQCR. If we add enqueue-completions or
 	 * something related to QM_PIRQ_EQCI, this may need fixing.
 	 * Also, due to the prefetching model used for CI updates in the enqueue
@@ -716,7 +713,6 @@ static u32 __poll_portal_slow(struct qman_portal *p, u32 is)
 		 * state change.
 		 */
 		qm_isr_status_clear(&p->p, QM_PIRQ_CSCI);
-
 		qm_mc_start(&p->p);
 		qm_mc_commit(&p->p, QM_MCC_VERB_QUERYCONGESTION);
 		while (!(mcr = qm_mc_result(&p->p)))
@@ -871,7 +867,6 @@ mr_loop:
 mr_done:
 		qm_mr_cci_consume(&p->p, num);
 	}
-
 	/*
 	 * QM_PIRQ_CSCI/CCSCI has already been cleared, as part of its specific
 	 * processing. If that interrupt source has meanwhile been re-asserted,
@@ -2339,8 +2334,7 @@ int qman_delete_cgr(struct qman_cgr *cgr)
 	/* Overwrite TARG */
 	local_opts.we_mask = QM_CGR_WE_CSCN_TARG;
 	if ((qman_ip_rev & 0xFF00) >= QMAN_REV30)
-		local_opts.cgr.cscn_targ_upd_ctrl =
-			~QM_CGR_TARG_UDP_CTRL_WRITE_BIT | PORTAL_IDX(p);
+		local_opts.cgr.cscn_targ_upd_ctrl = PORTAL_IDX(p);
 	else
 		local_opts.cgr.cscn_targ = cgr_state.cgr.cscn_targ &
 							 ~(TARG_MASK(p));
@@ -4233,9 +4227,11 @@ int qman_ceetm_ccg_release(struct qm_ceetm_ccg *ccg)
 	list_for_each_entry(i, &p->ccgr_cbs[ccg->parent->dcp_idx], cb_node)
 		if ((i->idx == ccg->idx) && i->cb)
 			goto release_lock;
+	config_opts.ccgrid = CEETM_CCGR_CM_CONFIGURE |
+				(ccg->parent->idx << 4) | ccg->idx;
+	config_opts.dcpid = ccg->parent->dcp_idx;
 	config_opts.we_mask = QM_CCGR_WE_CSCN_TUPD;
-	config_opts.cm_config.cscn_tupd =
-			~QM_CGR_TARG_UDP_CTRL_WRITE_BIT | PORTAL_IDX(p);
+	config_opts.cm_config.cscn_tupd = PORTAL_IDX(p);
 
 	ret = qman_ceetm_configure_ccgr(&config_opts);
 release_lock:
-- 
1.9.1

