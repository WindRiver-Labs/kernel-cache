From 52fc261b84502a672140be93cb32ead8a16f6d05 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Tue, 4 Feb 2014 16:25:28 -0500
Subject: [PATCH 578/987] Add support for raw portal allocation

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Add support for allocation of raw (unconfigured) portals to the
USDPAA kernel driver.  This allows a USDPAA process to allocate
a portal on behalf of another user.

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: I5764ff1f8e46c8d22cb28367a70ce5a83a8ede85
Reviewed-on: http://git.am.freescale.net:8181/9381
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Vakul Garg <vakul@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c | 233 ++++++++++++++++++++++++++++++++-
 include/linux/fsl_usdpaa.h             |  63 +++++++++
 2 files changed, 295 insertions(+), 1 deletion(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 421dbcd..9b355cc 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -85,6 +85,7 @@ struct portal_mapping {
 	};
 	struct list_head list;
 	struct resource *phys;
+	struct iommu_domain *iommu_domain;
 };
 
 /* Track the DPAA resources the process is using */
@@ -844,7 +845,7 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 {
 	struct mem_fragment *frag, *start_frag, *next_frag;
 	struct mem_mapping *map, *tmp;
-	int ret = 0, k;
+	int ret = 0;
 	u32 largest_page, so_far = 0;
 	int frag_count = 0;
 	unsigned long next_addr = PAGE_SIZE, populate;
@@ -1162,7 +1163,10 @@ static long ioctl_portal_map(struct file *fp, struct ctx *ctx,
 
 	if (!mapping)
 		return -ENOMEM;
+
 	mapping->user = *arg;
+	mapping->iommu_domain = NULL;
+
 	if (mapping->user.type == usdpaa_portal_qman) {
 		mapping->qportal =
 			qm_get_unused_portal_idx(mapping->user.index);
@@ -1270,6 +1274,179 @@ found:
 	return 0;
 }
 
+static void portal_config_pamu(struct qm_portal_config *pcfg, uint8_t sdest,
+			       uint32_t cpu, uint32_t cache, uint32_t window)
+{
+#ifdef CONFIG_FSL_PAMU
+	int ret;
+	int window_count = 1;
+	struct iommu_domain_geometry geom_attr;
+	struct pamu_stash_attribute stash_attr;
+
+	pcfg->iommu_domain = iommu_domain_alloc(&platform_bus_type);
+	if (!pcfg->iommu_domain) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_alloc() failed",
+			   __func__);
+		goto _no_iommu;
+	}
+	geom_attr.aperture_start = 0;
+	geom_attr.aperture_end =
+		((dma_addr_t)1 << min(8 * sizeof(dma_addr_t), (size_t)36)) - 1;
+	geom_attr.force_aperture = true;
+	ret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_GEOMETRY,
+				    &geom_attr);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_set_attr() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	ret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_WINDOWS,
+				    &window_count);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_set_attr() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	stash_attr.cpu = cpu;
+	stash_attr.cache = cache;
+
+	ret = iommu_domain_set_attr(pcfg->iommu_domain,
+				    DOMAIN_ATTR_FSL_PAMU_STASH,
+				    &stash_attr);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_set_attr() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	ret = iommu_domain_window_enable(pcfg->iommu_domain, 0, 0, 1ULL << 36,
+					 IOMMU_READ | IOMMU_WRITE);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_window_enable() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	ret = iommu_attach_device(pcfg->iommu_domain, &pcfg->dev);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_device_attach() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	ret = iommu_domain_set_attr(pcfg->iommu_domain,
+				    DOMAIN_ATTR_FSL_PAMU_ENABLE,
+				    &window_count);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_set_attr() = %d",
+			   __func__, ret);
+		goto _iommu_detach_device;
+	}
+_no_iommu:
+#endif
+
+#ifdef CONFIG_FSL_QMAN_CONFIG
+	if (qman_set_sdest(pcfg->public_cfg.channel, sdest))
+#endif
+		pr_warn("Failed to set QMan portal's stash request queue\n");
+
+	return;
+
+#ifdef CONFIG_FSL_PAMU
+_iommu_detach_device:
+	iommu_detach_device(pcfg->iommu_domain, NULL);
+_iommu_domain_free:
+	iommu_domain_free(pcfg->iommu_domain);
+#endif
+}
+
+static long ioctl_allocate_raw_portal(struct file *fp, struct ctx *ctx,
+				      struct usdpaa_ioctl_raw_portal *arg)
+{
+	struct portal_mapping *mapping = kmalloc(sizeof(*mapping), GFP_KERNEL);
+	int ret;
+
+	if (!mapping)
+		return -ENOMEM;
+
+	mapping->user.type = arg->type;
+	mapping->iommu_domain = NULL;
+	if (arg->type == usdpaa_portal_qman) {
+		mapping->qportal = qm_get_unused_portal_idx(arg->index);
+		if (!mapping->qportal) {
+			ret = -ENODEV;
+			goto err;
+		}
+		mapping->phys = &mapping->qportal->addr_phys[0];
+		arg->index = mapping->qportal->public_cfg.index;
+		arg->cinh = mapping->qportal->addr_phys[DPA_PORTAL_CI].start;
+		arg->cena = mapping->qportal->addr_phys[DPA_PORTAL_CE].start;
+		if (arg->enable_stash) {
+			/* Setup the PAMU with the supplied parameters */
+			portal_config_pamu(mapping->qportal, arg->sdest,
+					   arg->cpu, arg->cache, arg->window);
+		}
+	} else if (mapping->user.type == usdpaa_portal_bman) {
+		mapping->bportal =
+			bm_get_unused_portal_idx(arg->index);
+		if (!mapping->bportal) {
+			ret = -ENODEV;
+			goto err;
+		}
+		mapping->phys = &mapping->bportal->addr_phys[0];
+		arg->index = mapping->bportal->public_cfg.index;
+		arg->cinh = mapping->bportal->addr_phys[DPA_PORTAL_CI].start;
+		arg->cena = mapping->bportal->addr_phys[DPA_PORTAL_CE].start;
+	} else {
+		ret = -EINVAL;
+		goto err;
+	}
+	/* Need to put pcfg in ctx's list before the mmaps because the mmap
+	 * handlers look it up. */
+	spin_lock(&mem_lock);
+	list_add(&mapping->list, &ctx->portals);
+	spin_unlock(&mem_lock);
+	return 0;
+err:
+	kfree(mapping);
+	return ret;
+}
+
+static long ioctl_free_raw_portal(struct file *fp, struct ctx *ctx,
+				      struct usdpaa_ioctl_raw_portal *arg)
+{
+	struct portal_mapping *mapping;
+	u32 channel;
+
+	/* Find the corresponding portal */
+	spin_lock(&mem_lock);
+	list_for_each_entry(mapping, &ctx->portals, list) {
+		if (mapping->phys[DPA_PORTAL_CI].start == arg->cinh)
+			goto found;
+	}
+	mapping = NULL;
+found:
+	if (mapping)
+		list_del(&mapping->list);
+	spin_unlock(&mem_lock);
+	if (!mapping)
+		return -ENODEV;
+	if (mapping->user.type == usdpaa_portal_qman) {
+		init_qm_portal(mapping->qportal,
+				       &mapping->qman_portal_low);
+
+		/* Tear down any FQs this portal is referencing */
+		channel = mapping->qportal->public_cfg.channel;
+		qm_check_and_destroy_fqs(&mapping->qman_portal_low,
+					 &channel,
+					 check_portal_channel);
+		qm_put_unused_portal(mapping->qportal);
+	} else if (mapping->user.type == usdpaa_portal_bman) {
+		init_bm_portal(mapping->bportal,
+			       &mapping->bman_portal_low);
+		bm_put_unused_portal(mapping->bportal);
+	}
+	kfree(mapping);
+	return 0;
+}
+
 static long usdpaa_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
 {
 	struct ctx *ctx = fp->private_data;
@@ -1318,6 +1495,24 @@ static long usdpaa_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
 	}
 	case USDPAA_IOCTL_DMA_USED:
 		return ioctl_dma_stats(ctx, a);
+	case USDPAA_IOCTL_ALLOC_RAW_PORTAL:
+	{
+		struct usdpaa_ioctl_raw_portal input;
+		int ret;
+		if (copy_from_user(&input, a, sizeof(input)))
+			return -EFAULT;
+		ret = ioctl_allocate_raw_portal(fp, ctx, &input);
+		if (copy_to_user(a, &input, sizeof(input)))
+			return -EFAULT;
+		return ret;
+	}
+	case USDPAA_IOCTL_FREE_RAW_PORTAL:
+	{
+		struct usdpaa_ioctl_raw_portal input;
+		if (copy_from_user(&input, a, sizeof(input)))
+			return -EFAULT;
+		return ioctl_free_raw_portal(fp, ctx, &input);
+	}
 	}
 	return -EINVAL;
 }
@@ -1388,6 +1583,42 @@ static long usdpaa_ioctl_compat(struct file *fp, unsigned int cmd,
 		converted.cena = compat_ptr(input.cena);
 		return ioctl_portal_unmap(ctx, &converted);
 	}
+	case USDPAA_IOCTL_ALLOC_RAW_PORTAL_COMPAT:
+	{
+		int ret;
+		struct usdpaa_ioctl_raw_portal converted;
+		struct compat_ioctl_raw_portal input;
+		if (copy_from_user(&input, a, sizeof(input)))
+			return -EFAULT;
+		converted.type = input.type;
+		converted.index = input.index;
+		converted.enable_stash = input.enable_stash;
+		converted.cpu = input.cpu;
+		converted.cache = input.cache;
+		converted.window = input.window;
+		converted.sdest = input.sdest;
+		ret = ioctl_allocate_raw_portal(fp, ctx, &converted);
+
+		input.cinh = converted.cinh;
+		input.cena = converted.cena;
+		input.index = converted.index;
+
+		if (copy_to_user(a, &input, sizeof(input)))
+			return -EFAULT;
+		return ret;
+	}
+	case USDPAA_IOCTL_FREE_RAW_PORTAL_COMPAT:
+	{
+		struct usdpaa_ioctl_raw_portal converted;
+		struct compat_ioctl_raw_portal input;
+		if (copy_from_user(&input, a, sizeof(input)))
+			return -EFAULT;
+		converted.type = input.type;
+		converted.index = input.index;
+		converted.cinh = input.cinh;
+		converted.cena = input.cena;
+		return ioctl_free_raw_portal(fp, ctx, &converted);
+	}
 #endif
 	default:
 		return usdpaa_ioctl(fp, cmd, arg);
diff --git a/include/linux/fsl_usdpaa.h b/include/linux/fsl_usdpaa.h
index fbf9480..896c03a 100644
--- a/include/linux/fsl_usdpaa.h
+++ b/include/linux/fsl_usdpaa.h
@@ -244,6 +244,69 @@ struct usdpaa_ioctl_dma_used {
 #define USDPAA_IOCTL_DMA_USED \
 	_IOR(USDPAA_IOCTL_MAGIC, 0x0B, struct usdpaa_ioctl_dma_used)
 
+/* ioctl to allocate a raw portal */
+struct usdpaa_ioctl_raw_portal {
+	/* inputs */
+	enum usdpaa_portal_type type; /* Type of portal to allocate */
+
+	 /* set to non zero to turn on stashing */
+	uint8_t enable_stash;
+	/* Stashing attributes for the portal */
+	uint32_t cpu;
+	uint32_t cache;
+	uint32_t window;
+
+	/* Specifies the stash request queue this portal should use */
+	uint8_t sdest;
+
+	/* Specifes a specific portal index to map or QBMAN_ANY_PORTAL_IDX
+	 * for don't care.  The portal index will be populated by the
+	 * driver when the ioctl() successfully completes */
+	uint32_t index;
+
+	/* outputs */
+	uint64_t cinh;
+	uint64_t cena;
+};
+
+#define USDPAA_IOCTL_ALLOC_RAW_PORTAL \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x0C, struct usdpaa_ioctl_raw_portal)
+
+#define USDPAA_IOCTL_FREE_RAW_PORTAL \
+	_IOR(USDPAA_IOCTL_MAGIC, 0x0D, struct usdpaa_ioctl_raw_portal)
+
+#ifdef CONFIG_COMPAT
+
+struct compat_ioctl_raw_portal {
+	/* inputs */
+	enum usdpaa_portal_type type; /* Type of portal to allocate */
+
+	 /* set to non zero to turn on stashing */
+	uint8_t enable_stash;
+	/* Stashing attributes for the portal */
+	uint32_t cpu;
+	uint32_t cache;
+	uint32_t window;
+	/* Specifies the stash request queue this portal should use */
+	uint8_t sdest;
+
+	/* Specifes a specific portal index to map or QBMAN_ANY_PORTAL_IDX
+	 * for don't care.  The portal index will be populated by the
+	 * driver when the ioctl() successfully completes */
+	uint32_t index;
+
+	/* outputs */
+	uint64_t cinh;
+	uint64_t cena;
+};
+
+#define USDPAA_IOCTL_ALLOC_RAW_PORTAL_COMPAT \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x0C, struct compat_ioctl_raw_portal)
+
+#define USDPAA_IOCTL_FREE_RAW_PORTAL_COMPAT \
+	_IOR(USDPAA_IOCTL_MAGIC, 0x0D, struct compat_ioctl_raw_portal)
+
+#endif
 
 #ifdef __KERNEL__
 
-- 
1.9.1

