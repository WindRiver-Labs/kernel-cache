From 10acb0d9c3f66d8d7bd88004c46678ff730aef48 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Thu, 31 Oct 2013 18:10:20 +0200
Subject: [PATCH 418/987] fmd: add a new counter for fragmented IP packets

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Add a new counter for fragmented IP packets with IP header options

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Change-Id: I94d93bd0960025c9f2c4bcf4aab7c17e8344fd39
Reviewed-on: http://git.am.freescale.net:8181/6252
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Nir Erez <nir.erez@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 .../freescale/fman/src/wrapper/lnxwrp_fm.h         |  3 +
 .../fman/src/wrapper/lnxwrp_sysfs_fm_port.c        | 73 +++++++++++++++++++++-
 .../fman/src/wrapper/lnxwrp_sysfs_fm_port.h        |  4 ++
 3 files changed, 78 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h
index 99cbfa4..30b6bf2 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h
@@ -115,6 +115,9 @@ typedef struct {
     struct device_attribute     *dev_attr_regs;
     struct device_attribute     *dev_attr_bmi_regs;
     struct device_attribute     *dev_attr_qmi_regs;
+#if (DPAA_VERSION >= 11)
+    struct device_attribute     *dev_attr_ipv4_opt;
+#endif
 } t_LnxWrpFmPortDev;
 
 typedef struct {
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
index 8a8589d..848cea9 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
@@ -278,7 +278,47 @@ static ssize_t show_fm_port_regs(struct device *dev,
 }
 
 
+#if (DPAA_VERSION >= 11)
+static ssize_t show_fm_port_ipv4_options(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmPortDev *p_LnxWrpFmPortDev =
+			(t_LnxWrpFmPortDev *) dev_get_drvdata(dev);
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	local_irq_save(flags);
+
+	if (!p_LnxWrpFmPortDev->h_Dev) {
+		n = snprintf(buf, PAGE_SIZE, "\tFM Port not configured...\n");
+		return n;
+	} else {
+		n = snprintf(buf, PAGE_SIZE,
+			"Counter for fragmented pkt with IP header options\n");
+		n = fm_port_dump_ipv4_opt(p_LnxWrpFmPortDev->h_Dev, buf, n);
+	}
+
+	local_irq_restore(flags);
 
+	return n;
+#else
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+
+	return n;
+#endif
+}
+
+#endif
 
 static ssize_t show_fm_port_bmi_regs(struct device *dev,
 		struct device_attribute *attr, char *buf)
@@ -361,6 +401,9 @@ static ssize_t show_fm_port_qmi_regs(struct device *dev,
 static DEVICE_ATTR(fm_port_regs, 0x644, show_fm_port_regs, NULL);
 static DEVICE_ATTR(fm_port_qmi_regs, 0x644, show_fm_port_qmi_regs, NULL);
 static DEVICE_ATTR(fm_port_bmi_regs, 0x644, show_fm_port_bmi_regs, NULL);
+#if (DPAA_VERSION >= 11)
+static DEVICE_ATTR(fm_port_ipv4_opt, 0x644, show_fm_port_ipv4_options, NULL);
+#endif
 
 int fm_port_sysfs_create(struct device *dev)
 {
@@ -377,7 +420,9 @@ int fm_port_sysfs_create(struct device *dev)
 	p_LnxWrpFmPortDev->dev_attr_regs = &dev_attr_fm_port_regs;
 	p_LnxWrpFmPortDev->dev_attr_qmi_regs = &dev_attr_fm_port_qmi_regs;
 	p_LnxWrpFmPortDev->dev_attr_bmi_regs = &dev_attr_fm_port_bmi_regs;
-
+#if (DPAA_VERSION >= 11)
+	p_LnxWrpFmPortDev->dev_attr_ipv4_opt = &dev_attr_fm_port_ipv4_opt;
+#endif
 	/* Registers dump entry - in future will be moved to debugfs */
 	if (device_create_file(dev, &dev_attr_fm_port_regs) != 0)
 		return -EIO;
@@ -385,7 +430,11 @@ int fm_port_sysfs_create(struct device *dev)
 		return -EIO;
 	if (device_create_file(dev, &dev_attr_fm_port_bmi_regs) != 0)
 		return -EIO;
-
+#if (DPAA_VERSION >= 11)
+	if (device_create_file(dev, &dev_attr_fm_port_ipv4_opt) != 0)
+		return -EIO;
+#endif
+		
 	/* FM Ports statistics */
 	switch (p_LnxWrpFmPortDev->settings.param.portType) {
 	case e_FM_PORT_TYPE_TX:
@@ -452,6 +501,9 @@ void fm_port_sysfs_destroy(struct device *dev)
 	device_remove_file(dev, p_LnxWrpFmPortDev->dev_attr_regs);
 	device_remove_file(dev, p_LnxWrpFmPortDev->dev_attr_qmi_regs);
 	device_remove_file(dev, p_LnxWrpFmPortDev->dev_attr_bmi_regs);
+#if (DPAA_VERSION >= 11)
+	device_remove_file(dev, p_LnxWrpFmPortDev->dev_attr_ipv4_opt);
+#endif
 }
 
 
@@ -493,6 +545,23 @@ int fm_port_dump_regs(void *h_dev, char *buf, int nn)
 	return n;
 }
 
+#if (DPAA_VERSION >= 11)
+
+int fm_port_dump_ipv4_opt(void *h_dev, char *buf, int nn)
+{
+	t_FmPort *p_FmPort;
+	int n = nn;
+
+	p_FmPort = (t_FmPort *)h_dev;
+
+	FM_DMP_V32(buf, n, p_FmPort->p_ParamsPage, ipfOptionsCounter);
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	return n;
+}
+#endif
+
 int fm_port_dump_regs_bmi(void *h_dev, char *buf, int nn)
 {
 	t_FmPort *p_FmPort;
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.h
index 525e46c..1e7636f 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.h
@@ -49,4 +49,8 @@ int fm_port_dump_regs(void *h_dev, char *buf, int n);
 int fm_port_dump_regs_bmi(void *h_dev, char *buf, int n);
 int fm_port_dump_regs_qmi(void *h_dev, char *buf, int n);
 
+#if (DPAA_VERSION >= 11)
+int fm_port_dump_ipv4_opt(void *h_dev, char *buf, int n);
+#endif
+
 #endif /* LNXWRP_SYSFS_FM_PORT_H_ */
-- 
1.9.1

