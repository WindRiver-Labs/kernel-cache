From 910b0c986c7b876863ec69eab274691424f66b16 Mon Sep 17 00:00:00 2001
From: Horia Geanta <horia.geanta@freescale.com>
Date: Tue, 17 Dec 2013 19:33:58 +0200
Subject: [PATCH 1253/1336] crypto: caam/qi - fix listlock access method

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Use interrupt-safe version of spin_lock_* for listlock,
since the lock is used also in interrupt context.

If not, deadlocks can occur - for e.g.:
-CPU 1 takes listlock when doing caam_qi_enqueue()
-net_rx_action preempts CPU1, CPU1 tries to take listlock in
fd_to_drv_req()->lookup_drv_req()

INFO: rcu_sched self-detected stall on CPU { 1}  (t=5250 jiffies g=92 c=91 q=9)
Call Trace:
[c00000017ffa3210] [c000000000008e08] .show_stack+0x78/0x1e0 (unreliable)
[c00000017ffa32e0] [c0000000000ac74c] .rcu_check_callbacks+0x41c/0x850
[c00000017ffa3400] [c000000000049508] .update_process_times+0x48/0x90
[c00000017ffa3490] [c00000000008750c] .tick_sched_handle.isra.12+0x3c/0x50
[c00000017ffa3500] [c00000000008770c] .tick_sched_timer+0x5c/0xa0
[c00000017ffa35a0] [c0000000000641d0] .__run_hrtimer.isra.31+0x80/0x130
[c00000017ffa3630] [c000000000064e60] .hrtimer_interrupt+0x130/0x3d0
[c00000017ffa3730] [c00000000000ff24] .timer_interrupt+0x114/0x1c0
[c00000017ffa37d0] [c000000000017e84] exc_0x900_common+0x104/0x108
---
 drivers/crypto/caam/qi.c | 23 +++++++++++++++--------
 1 file changed, 15 insertions(+), 8 deletions(-)

diff --git a/drivers/crypto/caam/qi.c b/drivers/crypto/caam/qi.c
index 232e841..40cc64c 100644
--- a/drivers/crypto/caam/qi.c
+++ b/drivers/crypto/caam/qi.c
@@ -93,6 +93,7 @@ int caam_qi_enqueue(struct device *qidev, struct caam_drv_req *req)
 	size_t size;
 	struct list_head *list;
 	int num_retries = 0;
+	unsigned long flags;
 
 	fd.cmd = 0;
 	fd.format = qm_fd_compound;
@@ -109,9 +110,11 @@ int caam_qi_enqueue(struct device *qidev, struct caam_drv_req *req)
 	req->hwaddr = qm_fd_addr(&fd);
 	list = &per_cpu(pcpu_qipriv.bklog_list, req->drv_ctx->cpu);
 
-	spin_lock(&per_cpu(pcpu_qipriv.listlock, req->drv_ctx->cpu));
+	spin_lock_irqsave(&per_cpu(pcpu_qipriv.listlock, req->drv_ctx->cpu),
+			  flags);
 	list_add_tail(&req->hdr__, list);
-	spin_unlock(&per_cpu(pcpu_qipriv.listlock, req->drv_ctx->cpu));
+	spin_unlock_irqrestore(&per_cpu(pcpu_qipriv.listlock,
+					req->drv_ctx->cpu), flags);
 	atomic_inc(&per_cpu(pcpu_qipriv.pending, req->drv_ctx->cpu));
 
 	do {
@@ -126,9 +129,11 @@ int caam_qi_enqueue(struct device *qidev, struct caam_drv_req *req)
 
 	dev_err(qidev, "qman_enqueue failed: %d\n", ret);
 
-	spin_lock(&per_cpu(pcpu_qipriv.listlock, req->drv_ctx->cpu));
+	spin_lock_irqsave(&per_cpu(pcpu_qipriv.listlock, req->drv_ctx->cpu),
+			  flags);
 	list_del(&req->hdr__);
-	spin_unlock(&per_cpu(pcpu_qipriv.listlock, req->drv_ctx->cpu));
+	spin_unlock_irqrestore(&per_cpu(pcpu_qipriv.listlock,
+					req->drv_ctx->cpu), flags);
 	atomic_dec(&per_cpu(pcpu_qipriv.pending, req->drv_ctx->cpu));
 
 	dma_unmap_single(qidev, fd.addr, size, DMA_BIDIRECTIONAL);
@@ -140,6 +145,7 @@ struct caam_drv_req *lookup_drv_req(const struct qm_fd *fd, int cpu)
 {
 	struct list_head *pos, *list, *n;
 	struct caam_drv_req *req;
+	unsigned long flags;
 
 	list = &per_cpu(pcpu_qipriv.bklog_list, cpu);
 	list_for_each_safe(pos, n, list) {
@@ -148,11 +154,12 @@ struct caam_drv_req *lookup_drv_req(const struct qm_fd *fd, int cpu)
 		if (req->hwaddr == qm_fd_addr(fd)) {
 			BUG_ON(req->drv_ctx->cpu != cpu);
 
-			spin_lock(&per_cpu(pcpu_qipriv.listlock,
-					   req->drv_ctx->cpu));
+			spin_lock_irqsave(&per_cpu(pcpu_qipriv.listlock,
+						   req->drv_ctx->cpu), flags);
 			list_del(&req->hdr__);
-			spin_unlock(&per_cpu(pcpu_qipriv.listlock,
-					     req->drv_ctx->cpu));
+			spin_unlock_irqrestore(&per_cpu(pcpu_qipriv.listlock,
+							req->drv_ctx->cpu),
+					       flags);
 			atomic_dec(&per_cpu(pcpu_qipriv.pending,
 					    req->drv_ctx->cpu));
 			return req;
-- 
2.0.2

