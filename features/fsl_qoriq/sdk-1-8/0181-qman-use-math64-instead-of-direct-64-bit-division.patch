From d65e0a61d3de32830f2f441df137c6e605c21f70 Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Fri, 17 May 2013 14:23:44 -0400
Subject: [PATCH 181/987] qman: use math64 instead of direct 64-bit division.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

In 32-bit builds, the ROUNDING macro was breaking kernel assumptions when
fed with 64-bit parameters. This forces it to use the recommended
wrappers in <linux/math64.h> instead.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Change-Id: Id708cdad58593f38683112adf59984ffd3d763f7
Reviewed-on: http://git.am.freescale.net:8181/2580
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/staging/fsl_qbman/dpa_sys.h   |  1 +
 drivers/staging/fsl_qbman/qman_high.c | 11 +++++++++++
 include/linux/fsl_qman.h              | 11 -----------
 3 files changed, 12 insertions(+), 11 deletions(-)

diff --git a/drivers/staging/fsl_qbman/dpa_sys.h b/drivers/staging/fsl_qbman/dpa_sys.h
index 4dedf1e..9306d87 100644
--- a/drivers/staging/fsl_qbman/dpa_sys.h
+++ b/drivers/staging/fsl_qbman/dpa_sys.h
@@ -60,6 +60,7 @@
 #include <linux/fsl_hypervisor.h>
 #include <linux/vmalloc.h>
 #include <linux/ctype.h>
+#include <linux/math64.h>
 
 #include <linux/fsl_usdpaa.h>
 
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 700ea06..22f512b 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -37,6 +37,17 @@
 #define IRQNAME		"QMan portal %d"
 #define MAX_IRQNAME	16	/* big enough for "QMan portal %d" */
 
+/* Divide 'n' by 'd', rounding down if 'r' is negative, rounding up if it's
+ * positive, and rounding to the closest value if it's zero. NB, this macro
+ * implicitly upgrades parameters to unsigned 64-bit, so feed it with types
+ * that are compatible with this. NB, these arguments should not be expressions
+ * unless it is safe for them to be evaluated multiple times. Eg. do not pass
+ * in "some_value++" as a parameter to the macro! */
+#define ROUNDING(n, d, r) \
+	(((r) < 0) ? div64_u64((n), (d)) : \
+	(((r) > 0) ? div64_u64(((n) + (d) - 1), (d)) : \
+	div64_u64(((n) + ((d) / 2)), (d))))
+
 /* Lock/unlock frame queues, subject to the "LOCKED" flag. This is about
  * inter-processor locking only. Note, FQLOCK() is always called either under a
  * local_irq_save() or from interrupt context - hence there's no need for irq
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index da2c67d3..673724a 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -2417,17 +2417,6 @@ struct qm_ceetm_lfq {
 	qman_cb_mr ern;
 };
 
-/* Divide 'n' by 'd', rounding down if 'r' is negative, rounding up if
- * it's positive, and rounding to the closest value if it's zero. NB,
- * this macro assumes no particular type, so feed it with types that are
- * appropriate for its use. NB, these arguments should not be expressions
- * unless it is safe for them to be evaluated multiple times. Eg. do not
- * pass in "some_value++" as a parameter to the macro! */
-#define ROUNDING(n, d, r) \
-	(((r) < 0) ? ((n) / (d)) : \
-	(((r) > 0) ? (((n) + (d) - 1) / (d)) : \
-	(((n) + ((d) / 2)) / (d))))
-
 /**
  * qman_ceetm_bps2tokenrate - Given a desired rate 'bps' measured in bps
  * (ie. bits-per-second), compute the 'token_rate' fraction that best
-- 
1.9.1

