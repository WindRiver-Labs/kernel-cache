From a797838549390dd840651c0f519cf175d90e876c Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Mon, 15 Sep 2014 17:01:33 +0800
Subject: [PATCH 634/987] iommu/fsl: Enable default DMA window for PCIe devices
 once detached from domain.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Once the PCIe device assigned to a guest VM (via VFIO) gets detached from the iommu domain
(when guest terminates), its PAMU table entry is disabled. So, this would prevent the device
from being used once it's assigned back to the host.

This patch allows for creation of a default DMA window corresponding to the device
and subsequently enabling the PAMU table entry. Before we enable the entry, we ensure that
the device's bus master capability is disabled (device quiesced).

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Change-Id: Iab4da4adfac8536a6834011431a395ba3a4982d2
Reviewed-on: http://git.am.freescale.net:8181/10257
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
[Fix context to apply to WRL.]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/iommu/fsl_pamu.c        |  4 +++-
 drivers/iommu/fsl_pamu_domain.c | 20 +++-----------------
 2 files changed, 6 insertions(+), 18 deletions(-)

diff --git a/drivers/iommu/fsl_pamu.c b/drivers/iommu/fsl_pamu.c
index e60ee35..af9137a 100644
--- a/drivers/iommu/fsl_pamu.c
+++ b/drivers/iommu/fsl_pamu.c
@@ -247,7 +247,7 @@ static unsigned long pamu_get_fspi_and_allocate(u32 subwin_cnt)
 }
 
 /*
- * Defaul PPAACE settings for an LIODN.
+ * Default PPAACE settings for an LIODN.
  */
 static void setup_default_ppaace(struct paace *ppaace)
 {
@@ -276,6 +276,8 @@ void enable_default_dma_window(int liodn)
 	memset(ppaace, 0, sizeof(struct paace));
 
 	setup_default_ppaace(ppaace);
+
+	/* Ensure that all other stores to the ppaace complete first */
 	mb();
 	pamu_enable_liodn(liodn);
 }
diff --git a/drivers/iommu/fsl_pamu_domain.c b/drivers/iommu/fsl_pamu_domain.c
index 44f256b..94df3f8 100644
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@ -351,9 +351,9 @@ static void disable_device_dma(struct device_domain_info *info,
 #ifdef CONFIG_PCI
 	if (info->dev->bus == &pci_bus_type) {
 		struct pci_dev *pdev = NULL;
+
 		pdev = to_pci_dev(info->dev);
-		if (pci_is_enabled(pdev))
-			pci_disable_device(pdev);
+		pci_clear_master(pdev);
 	}
 #endif
 
@@ -381,9 +381,8 @@ static int check_for_shared_liodn(struct device_domain_info *info)
 
 static void remove_device_ref(struct device_domain_info *info, u32 win_cnt)
 {
-	int enable_dma_window = 0;
-
 	unsigned long flags;
+	int enable_dma_window = 0;
 
 	list_del(&info->link);
 	spin_lock_irqsave(&iommu_lock, flags);
@@ -946,9 +945,6 @@ static int fsl_pamu_set_domain_attr(struct iommu_domain *domain,
 	case DOMAIN_ATTR_FSL_PAMU_ENABLE:
 		ret = configure_domain_dma_state(dma_domain, *(int *)data);
 		break;
-	case DOMAIN_ATTR_PAMU_OP_MAP:
-		ret = configure_domain_op_map(dma_domain, data);
-		break;
 	case DOMAIN_ATTR_FSL_PAMU_OP_MAP:
 		ret = configure_domain_op_map(dma_domain, data);
 		break;
@@ -1156,16 +1152,6 @@ static void dma_domain_init_windows(struct fsl_dma_domain *dma_domain)
 	}
 }
 
-static void dma_domain_init_windows(struct fsl_dma_domain *dma_domain)
-{
-	int i;
-
-	for (i = 0; i < dma_domain->win_cnt; i++) {
-		dma_domain->win_arr[i].stash_id = ~(u32)0;
-		dma_domain->win_arr[i].omi = ~(u32)0;
-	}
-}
-
 static int fsl_pamu_set_windows(struct iommu_domain *domain, u32 w_count)
 {
 	struct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);
-- 
1.9.1

