From a588bd1f614f7ad3cfd784ec9201a0ae30f85081 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Sun, 23 Nov 2014 11:48:34 +0200
Subject: [PATCH 798/987] fmd: adjust compat layer following capwap support

The addition of the capwap related structures required
a few changes in the compat layer to better support
64b kernel space working with 32b user space

Change-Id: I7d49c8cec351ada65259f928df2d6014f5d81342
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/24499
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jiafei Pan <Jiafei.Pan@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 .../freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c  | 20 +++++++++--
 .../fman/src/wrapper/lnxwrp_ioctls_fm_compat.c     |  7 +++-
 .../fman/src/wrapper/lnxwrp_ioctls_fm_compat.h     | 26 +++++++++++++--
 include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h | 39 +++++++++++-----------
 .../uapi/linux/fmd/Peripherals/fm_port_ioctls.h    |  2 +-
 5 files changed, 66 insertions(+), 28 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
index 4161a23..75c628a 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
@@ -327,6 +327,20 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     /* fm_pcd_ext.h == fm_pcd_ioctls.h */
     /*ioc_fm_pcd_counters_params_t  : NOT USED */
     /*ioc_fm_pcd_exception_params_t : private */
+#if (DPAA_VERSION >= 11)
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_capwap_params_t) == sizeof(t_FmPcdManipFragCapwapParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_capwap_params_t) == sizeof(t_FmPcdManipReassemCapwapParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t) == sizeof(t_FmPcdManipHdrInsrtByHdrParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_insrt_ip_params_t) == sizeof(t_FmPcdManipHdrInsrtIpParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_insrt_t) == sizeof(t_FmPcdManipHdrInsrt));
+    ASSERT_COND(sizeof(ioc_fm_manip_hdr_info_t) == sizeof(t_FmManipHdrInfo));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t) == sizeof(t_FmPcdManipHdrRmvByHdrParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_special_offload_capwap_params_t) == sizeof(t_FmPcdManipSpecialOffloadCapwapParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_capwap_stats_t) == sizeof(t_FmPcdManipFragCapwapStats));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_capwap_stats_t) == sizeof(t_FmPcdManipReassemCapwapStats));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_params_t) == sizeof(t_FmPcdManipFragParams));
+#endif /* (DPAA_VERSION >= 11) */
+
     ASSERT_COND(sizeof(ioc_fm_pcd_prs_label_params_t) == sizeof(t_FmPcdPrsLabelParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_prs_sw_params_t) == sizeof(t_FmPcdPrsSwParams));
     /*ioc_fm_pcd_kg_dflt_value_params_t : private */
@@ -384,8 +398,6 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(TODO) == sizeof(t_FmPcdManipHdrInsrtByTemplateParams));
     ASSERT_COND(sizeof(TODO) == sizeof(t_CapwapFragmentationParams));
     ASSERT_COND(sizeof(TODO) == sizeof(t_CapwapReassemblyParams));
-    ASSERT_COND(sizeof(TODO) == sizeof(t_FmPcdManipFragOrReasmParams));
-    ASSERT_COND(sizeof(TODO) == sizeof(t_FmPcdManipHdrRmvByHdrParams));
 */
 #endif
 
@@ -3702,7 +3714,9 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
                     port_pcd_params->p_kg_params           = compat_ptr(compat_port_pcd_params->p_kg_params);
                     port_pcd_params->p_plcr_params         = compat_ptr(compat_port_pcd_params->p_plcr_params);
                     port_pcd_params->p_ip_reassembly_manip = compat_ptr(compat_port_pcd_params->p_ip_reassembly_manip);
-
+#if (DPAA_VERSION >= 11)
+                    port_pcd_params->p_capwap_reassembly_manip = compat_ptr(compat_port_pcd_params->p_capwap_reassembly_manip);
+#endif
                     /* the prs member is the same, no compat structure...memcpy only */
                     if (port_pcd_params->p_prs_params)
                     {
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
index 5dc7294..3c29593 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -806,7 +806,9 @@ void compat_copy_fm_port_pcd(
         _fm_cpt_dbg(compat," param->p_kg_params=%p  \n", param->p_kg_params);
         _fm_cpt_dbg(compat," param->p_plcr_params=%p  \n", param->p_plcr_params);
         _fm_cpt_dbg(compat," param->p_ip_reassembly_manip=%p  \n", param->p_ip_reassembly_manip);
-
+#if (DPAA_VERSION >= 11)
+        _fm_cpt_dbg(compat," param->p_capwap_reassembly_manip=%p  \n", param->p_capwap_reassembly_manip);
+#endif
         param->pcd_support = compat_param->pcd_support;
         param->net_env_id = compat_pcd_id2ptr(compat_param->net_env_id);
 
@@ -817,6 +819,9 @@ void compat_copy_fm_port_pcd(
         if (param->p_plcr_params)
             param->p_plcr_params->plcr_profile_id = compat_pcd_id2ptr(compat_port_pcd_plcr_params->plcr_profile_id);
         param->p_ip_reassembly_manip = compat_pcd_id2ptr(compat_param->p_ip_reassembly_manip);
+#if (DPAA_VERSION >= 11)
+        param->p_capwap_reassembly_manip = compat_pcd_id2ptr(compat_param->p_capwap_reassembly_manip);
+#endif
     }
 }
 
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
index 471a1cf..7340396 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -416,10 +416,30 @@ typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
     compat_uptr_t                           p_data;
 } ioc_compat_fm_pcd_manip_hdr_insrt_specific_l2_params_t;
 
+typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_t {
+    uint8_t       size;          /**< size of inserted section */
+    compat_uptr_t p_data;        /**< data to be inserted */
+} ioc_compat_fm_pcd_manip_hdr_insrt_t;
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_ip_params_t {
+    bool    calc_l4_checksum; /**< Calculate L4 checksum. */
+    ioc_fm_pcd_manip_hdr_qos_mapping_mode   mapping_mode; /**< TODO */
+    uint8_t last_pid_offset;     /**< the offset of the last Protocol within
+                                 the inserted header */
+    uint16_t  id;           /**< 16 bit New IP ID */
+    ioc_compat_fm_pcd_manip_hdr_insrt_t insrt; /**< size and data to be inserted. */
+} ioc_compat_fm_pcd_manip_hdr_insrt_ip_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
 typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
     ioc_fm_pcd_manip_hdr_insrt_by_hdr_type                      type;
     union {
        ioc_compat_fm_pcd_manip_hdr_insrt_specific_l2_params_t   specific_l2_params;
+#if (DPAA_VERSION >= 11)
+        ioc_compat_fm_pcd_manip_hdr_insrt_ip_params_t          ip_params;
+        ioc_compat_fm_pcd_manip_hdr_insrt_t             insrt;
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_compat_fm_pcd_manip_hdr_insrt_by_hdr_params_t;
 
@@ -428,8 +448,8 @@ typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_params_t {
     union {
         ioc_compat_fm_pcd_manip_hdr_insrt_by_hdr_params_t   by_hdr;
         ioc_compat_fm_pcd_manip_hdr_insrt_generic_params_t  generic;
-#ifdef FM_CAPWAP_SUPPORT
-#error CAPWAP not supported!
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+#error "FM_CAPWAP_SUPPORT feature not supported!"
         ioc_fm_pcd_manip_hdr_insrt_by_template_params_t     by_template;
 #endif /* FM_CAPWAP_SUPPORT */
     } u;
@@ -456,7 +476,7 @@ typedef struct ioc_compat_fm_pcd_manip_params_t {
         ioc_fm_pcd_manip_special_offload_params_t special_offload;
     } u;
     compat_uptr_t                                 p_next_manip;
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 #error "FM_CAPWAP_SUPPORT feature not supported!"
     bool                                          frag_or_reasm;
     ioc_fm_pcd_manip_frag_or_reasm_params_t       frag_or_reasm_params;
diff --git a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
index daa3345..da52749 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -708,7 +708,7 @@ typedef enum ioc_fm_pcd_action {
 typedef enum ioc_fm_pcd_manip_hdr_insrt_type {
     e_IOC_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
     e_IOC_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
 #endif /* FM_CAPWAP_SUPPORT */
 } ioc_fm_pcd_manip_hdr_insrt_type;
@@ -846,7 +846,7 @@ typedef enum ioc_fm_pcd_manip_reassem_ways_number {
     e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< Eight ways hash */
 } ioc_fm_pcd_manip_reassem_ways_number;
 
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of statistics mode
 *//***************************************************************************/
@@ -929,6 +929,7 @@ typedef union ioc_fm_pcd_fields_u {
     ioc_header_field_ipv4_t             ipv4;           /**< IPv4                   */
     ioc_header_field_ipv6_t             ipv6;           /**< IPv6                   */
     ioc_header_field_udp_t              udp;            /**< UDP                    */
+    ioc_header_field_udp_lite_t         udp_lite;       /**< UDP_Lite               */
     ioc_header_field_tcp_t              tcp;            /**< TCP                    */
     ioc_header_field_sctp_t             sctp;           /**< SCTP                   */
     ioc_header_field_dccp_t             dccp;           /**< DCCP                   */
@@ -1908,10 +1909,10 @@ typedef struct ioc_fm_pcd_manip_hdr_rmv_generic_params_t {
 /**************************************************************************//**
  @Description   Parameters for defining insertion manipulation
 *//***************************************************************************/
-typedef struct fm_pcd_manip_hdr_insrt_t {
+typedef struct ioc_fm_pcd_manip_hdr_insrt_t {
     uint8_t size;           /**< size of inserted section */
     uint8_t *p_data;        /**< data to be inserted */
-} fm_pcd_manip_hdr_insrt_t;
+} ioc_fm_pcd_manip_hdr_insrt_t;
 
 /**************************************************************************//**
  @Description   Parameters for defining generic insertion manipulation
@@ -2052,14 +2053,14 @@ typedef struct ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
 /**************************************************************************//**
  @Description   Parameters for defining IP insertion manipulation
 *//***************************************************************************/
-typedef struct fm_pcd_manip_hdr_insrt_ip_params_t {
+typedef struct ioc_fm_pcd_manip_hdr_insrt_ip_params_t {
     bool    calc_l4_checksum; /**< Calculate L4 checksum. */
     ioc_fm_pcd_manip_hdr_qos_mapping_mode   mapping_mode; /**< TODO */
     uint8_t last_pid_offset;     /**< the offset of the last Protocol within
                                  the inserted header */
     uint16_t  id;           /**< 16 bit New IP ID */
-    fm_pcd_manip_hdr_insrt_t insrt; /**< size and data to be inserted. */
-} fm_pcd_manip_hdr_insrt_ip_params_t;
+    ioc_fm_pcd_manip_hdr_insrt_t insrt; /**< size and data to be inserted. */
+} ioc_fm_pcd_manip_hdr_insrt_ip_params_t;
 #endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
@@ -2072,8 +2073,8 @@ typedef struct ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
                                                             /**< Used when type = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
                                                                  Selects which L2 headers to remove */
 #if (DPAA_VERSION >= 11)
-        fm_pcd_manip_hdr_insrt_ip_params_t          ip_params;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
-        fm_pcd_manip_hdr_insrt_t                    insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
+        ioc_fm_pcd_manip_hdr_insrt_ip_params_t      ip_params;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
+        ioc_fm_pcd_manip_hdr_insrt_t                insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
                                                                 e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE, or
                                                                 e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP */
 #endif /* (DPAA_VERSION >= 11) */
@@ -2090,7 +2091,7 @@ typedef struct ioc_fm_pcd_manip_hdr_insrt_params_t {
                                                                      relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR */
         ioc_fm_pcd_manip_hdr_insrt_generic_params_t     generic;/**< Parameters for defining generic header insertion manipulation,
                                                                      relevant if type = e_IOC_FM_PCD_MANIP_INSRT_GENERIC */
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         ioc_fm_pcd_manip_hdr_insrt_by_template_params_t by_template;
                                                                 /**< Parameters for defining header insertion manipulation by template,
                                                                      relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
@@ -2176,8 +2177,7 @@ typedef struct ioc_fm_pcd_manip_params_t {
     void                                            *p_next_manip;/**< Handle to another (previously defined) manipulation node;
                                                                  Allows concatenation of manipulation actions
                                                                  This parameter is optional and may be NULL. */
-#ifdef FM_CAPWAP_SUPPORT
-#error "FM_CAPWAP_SUPPORT feature not supported!"
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     bool                                            frag_or_reasm;/**< TRUE, if defined fragmentation/reassembly manipulation */
     ioc_fm_pcd_manip_frag_or_reasm_params_t         frag_or_reasm_params;/**< Parameters for fragmentation/reassembly manipulation,
                                                                             relevant if frag_or_reasm = TRUE */
@@ -2229,7 +2229,7 @@ typedef struct ioc_fm_pcd_manip_frag_ip_stats_t {
 /**************************************************************************//**
  @Description   Structure for retrieving CAPWAP reassembly statistics
 *//***************************************************************************/
-typedef struct fm_pcd_manip_reassem_capwap_stats_t {
+typedef struct ioc_fm_pcd_manip_reassem_capwap_stats_t {
     uint32_t    timeout;                    /**< Counts the number of timeout occurrences */
     uint32_t    rfd_pool_busy;                /**< Counts the number of failed attempts to allocate
                                                  a Reassembly Frame Descriptor */
@@ -2250,19 +2250,19 @@ typedef struct fm_pcd_manip_reassem_capwap_stats_t {
                                                  exceeds 16 */
     uint32_t    exceed_max_reassembly_frame_len;/**< ounts the number of times that a successful reassembled frame
                                                  length exceeds MaxReassembledFrameLength value */
-} fm_pcd_manip_reassem_capwap_stats_t;
+} ioc_fm_pcd_manip_reassem_capwap_stats_t;
 
 /**************************************************************************//**
  @Description   Structure for retrieving CAPWAP fragmentation statistics
 *//***************************************************************************/
-typedef struct fm_pcd_manip_frag_capwap_stats_t {
+typedef struct ioc_fm_pcd_manip_frag_capwap_stats_t {
     uint32_t    total_frames;            /**< Number of frames that passed through the manipulation node */
     uint32_t    fragmented_frames;       /**< Number of frames that were fragmented */
     uint32_t    generated_fragments;     /**< Number of fragments that were generated */
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
     uint8_t     sg_allocation_failure;    /**< Number of allocation failure of s/g buffers */
 #endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
-} fm_pcd_manip_frag_capwap_stats_t;
+} ioc_fm_pcd_manip_frag_capwap_stats_t;
 #endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
@@ -2272,7 +2272,7 @@ typedef struct ioc_fm_pcd_manip_reassem_stats_t {
     union {
         ioc_fm_pcd_manip_reassem_ip_stats_t  ip_reassem;  /**< Structure for IP reassembly statistics */
 #if (DPAA_VERSION >= 11)
-        fm_pcd_manip_reassem_capwap_stats_t  capwap_reassem;  /**< Structure for CAPWAP reassembly statistics */
+        ioc_fm_pcd_manip_reassem_capwap_stats_t  capwap_reassem;  /**< Structure for CAPWAP reassembly statistics */
 #endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_fm_pcd_manip_reassem_stats_t;
@@ -2284,7 +2284,7 @@ typedef struct ioc_fm_pcd_manip_frag_stats_t {
     union {
         ioc_fm_pcd_manip_frag_ip_stats_t     ip_frag;     /**< Structure for IP fragmentation statistics */
 #if (DPAA_VERSION >= 11)
-        fm_pcd_manip_frag_capwap_stats_t capwap_frag; /**< Structure for CAPWAP fragmentation statistics */
+        ioc_fm_pcd_manip_frag_capwap_stats_t capwap_frag; /**< Structure for CAPWAP fragmentation statistics */
 #endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_fm_pcd_manip_frag_stats_t;
@@ -2921,8 +2921,7 @@ typedef struct ioc_fm_pcd_cc_tbl_get_miss_params_t {
 
 #endif
 
-#ifdef FM_CAPWAP_SUPPORT
-#warning "CAPWAP IOCTL not implemented"
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 /**************************************************************************//**
  @Function      FM_PCD_StatisticsSetNode
 
diff --git a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
index dc7cc32..49d1f50 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -104,8 +104,8 @@ typedef enum ioc_fm_port_pcd_support {
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
-#ifdef FM_CAPWAP_SUPPORT
     , e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
     , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
 #endif /* FM_CAPWAP_SUPPORT */
-- 
1.9.1

