From 39b7b7ab0fb2f3ed6f5c4a3622705c8e81e7f5e9 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Thu, 27 Feb 2014 16:28:17 +0200
Subject: [PATCH 584/987] fmd: adjust allocation of fifo resources for fmanv3l

Change-Id: I249456d0f157547fab221286e1c18e59ce5345d3
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/9257
Reviewed-by: Igal Liberman <Igal.Liberman@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Tested-by: Jose Rivera <German.Rivera@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/9448
---
 .../freescale/fman/Peripherals/FM/MAC/fman_memac.c | 43 ++++++++++++++--------
 .../fman/Peripherals/FM/MAC/memac_mii_acc.h        |  2 +-
 .../freescale/fman/Peripherals/FM/Port/fm_port.c   |  4 +-
 .../freescale/fman/Peripherals/FM/Port/fm_port.h   |  5 +--
 .../freescale/fman/Peripherals/FM/Port/fman_port.c | 14 ++++---
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    |  3 +-
 .../ethernet/freescale/fman/Peripherals/FM/fm.h    | 10 +++--
 .../ethernet/freescale/fman/Peripherals/FM/fman.c  | 34 +++++++++++++++++
 .../freescale/fman/inc/flib/fsl_fman_memac.h       | 22 +++++++++++
 .../fman/inc/flib/fsl_fman_memac_mii_acc.h         |  2 +-
 .../freescale/fman/inc/flib/fsl_fman_port.h        |  2 +-
 11 files changed, 107 insertions(+), 34 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
index f040be4..1fcb1ee 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
@@ -211,16 +211,19 @@ int fman_memac_init(struct memac_regs *regs,
             tmp |= IF_MODE_RGMII | IF_MODE_RGMII_AUTO;
     }
     iowrite32be(tmp, &regs->if_mode);
-    
-    /* from RM: For 10G rate mac tx_fifo_sections[TX_AVAIL] should be 0x19 */
-    if (enet_interface == E_ENET_IF_XGMII || 
-        enet_interface == E_ENET_IF_XFI) {
-        tmp = ioread32be(&regs->tx_fifo_sections);
-        tmp &= 0xffff0000;
-        tmp |= 0x00000019;
-        iowrite32be(tmp, &regs->tx_fifo_sections);
-    }
-    
+
+	/* TX_FIFO_SECTIONS */
+	tmp = 0;
+	if (enet_interface == E_ENET_IF_XGMII ||
+		enet_interface == E_ENET_IF_XFI) {
+		tmp |= (TX_FIFO_SECTIONS_TX_AVAIL_10G |
+				TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G);
+	} else {
+		tmp |= (TX_FIFO_SECTIONS_TX_AVAIL_1G |
+				TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_1G);
+	}
+	iowrite32be(tmp, &regs->tx_fifo_sections);
+
     /* clear all pending events and set-up interrupts */
     fman_memac_ack_event(regs, 0xffffffff);
     fman_memac_set_exception(regs, exceptions, TRUE);
@@ -275,13 +278,21 @@ void fman_memac_set_tx_pause_frames(struct memac_regs *regs,
 {
     uint32_t tmp;
 
-    tmp = ioread32be(&regs->command_config);
-    if (priority == 0xff) {
-        tmp &= ~CMD_CFG_PFC_MODE;
-        priority = 0;
+	tmp = ioread32be(&regs->tx_fifo_sections);
+
+	if (priority == 0xff) {
+		GET_TX_EMPTY_DEFAULT_VALUE(tmp);
+		iowrite32be(tmp, &regs->tx_fifo_sections);
+
+		tmp &= ~CMD_CFG_PFC_MODE;
+		priority = 0;
+	} else {
+		GET_TX_EMPTY_PFC_VALUE(tmp);
+		iowrite32be(tmp, &regs->tx_fifo_sections);
+
+		tmp = ioread32be(&regs->command_config);
+		tmp |= CMD_CFG_PFC_MODE;
     }
-    else
-        tmp |= CMD_CFG_PFC_MODE;
 
     iowrite32be(tmp, &regs->command_config);
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h
index dab4360..a8824ef 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h
@@ -38,7 +38,7 @@
 
 
 /* MII Management Registers */
-#define MDIO_CFG_CLK_DIV_MASK       0x0000ff80
+#define MDIO_CFG_CLK_DIV_MASK       0x0080ff80
 #define MDIO_CFG_CLK_DIV_SHIFT      7
 #define MDIO_CFG_HOLD_MASK          0x0000001c
 #define MDIO_CFG_ENC45              0x00000040
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index 4949b79..9924d3b 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -405,7 +405,7 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 
     /* Verify the size  */
     if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
-        DBG(INFO, ("FIFO size is %d and should be enlarged to %d bytes", p_FmPort->fifoBufs.num, minFifoSizeRequired));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FIFO size should be enlarged to %d bytes", minFifoSizeRequired));
     else if (p_FmPort->fifoBufs.num < optFifoSizeForB2B)
         DBG(INFO, ("For back-to-back frames processing, FIFO size may need to be enlarged to %d bytes", optFifoSizeForB2B));
 
@@ -2450,7 +2450,7 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
     if (p_FmPort->deepSleepVars.autoResMaxSizes)
         FmPortConfigAutoResForDeepSleepSupport1(p_FmPort);
-	
+
     return E_OK;
 }
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
index 7568258..58369a8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
@@ -147,8 +147,8 @@
 
 #else  /* (DPAA_VERSION < 11) */
 /* Defaults are registers' reset values */
-#define DEFAULT_PORT_rxFifoPriElevationLevel            (256 * KILOBYTE)
-#define DEFAULT_PORT_rxFifoThreshold                    (256 * KILOBYTE)
+#define DEFAULT_PORT_rxFifoPriElevationLevel            MAX_PORT_FIFO_SIZE
+#define DEFAULT_PORT_rxFifoThreshold                    MAX_PORT_FIFO_SIZE
 
 #define DEFAULT_PORT_txFifoMinFillLevel                 0
 #define DEFAULT_PORT_txFifoLowComfLevel                 (5 * KILOBYTE)
@@ -863,7 +863,6 @@ typedef struct t_FmPortDsarVars {
     uint32_t                    fmbm_rfpne;
     bool                        dsarEnabledParser;
 } t_FmPortDsarVars;
-
 typedef struct {
     struct fman_port            port;
     t_Handle                    h_Fm;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
index 2e4ff3b..c748a16 100755
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
@@ -724,7 +724,9 @@ static uint8_t fman_port_find_bpool(struct fman_port *port, uint8_t bpid)
 
     /* Find the pool */
     bp_reg = port->bmi_regs->rx.fmbm_ebmpi;
-    for (i = 0; i < port->ext_pools_num; i++) {
+    for (i = 0;
+         (i < port->ext_pools_num && (i < FMAN_PORT_MAX_EXT_POOLS_NUM));
+         i++) {
         tmp = ioread32be(&bp_reg[i]);
         id = (uint8_t)((tmp & BMI_EXT_BUF_POOL_ID_MASK) >>
                 BMI_EXT_BUF_POOL_ID_SHIFT);
@@ -916,7 +918,9 @@ int fman_port_set_bpools(const struct fman_port *port,
 
     if (rx_port) {
         /* Check buffers are provided in ascending order */
-        for (i = 0; i < (bp->count-1); i++) {
+        for (i = 0;
+             (i < (bp->count-1) && (i < FMAN_PORT_MAX_EXT_POOLS_NUM - 1));
+             i++) {
             if (bp->bpool[i].size > bp->bpool[i+1].size)
                 return -EINVAL;
         }
@@ -1291,7 +1295,7 @@ int fman_port_set_bpool_cnt_mode(struct fman_port *port,
 
     /* Find the pool */
     index = fman_port_find_bpool(port, bpid);
-    if (index == port->ext_pools_num)
+    if (index == port->ext_pools_num || index == FMAN_PORT_MAX_EXT_POOLS_NUM)
         /* Not found */
         return -EINVAL;
 
@@ -1465,7 +1469,7 @@ uint32_t fman_port_get_bpool_counter(struct fman_port *port, uint8_t bpid)
 
     /* Find the pool */
     index = fman_port_find_bpool(port, bpid);
-    if (index == port->ext_pools_num)
+    if (index == port->ext_pools_num || index == FMAN_PORT_MAX_EXT_POOLS_NUM)
         /* Not found */
         return 0;
 
@@ -1489,7 +1493,7 @@ void fman_port_set_bpool_counter(struct fman_port *port,
 
     /* Find the pool */
     index = fman_port_find_bpool(port, bpid);
-    if (index == port->ext_pools_num)
+    if (index == port->ext_pools_num || index == FMAN_PORT_MAX_EXT_POOLS_NUM)
         /* Not found */
         return;
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index 17ac17e..a4ea833 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -3466,7 +3466,8 @@ t_Error FM_Init(t_Handle h_Fm)
          * according to chip. otherwise, we use user's configuration.
          */
         if (p_Fm->p_FmStateStruct->totalFifoSize == 0)
-            p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev);
+            p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                                                         p_Fm->p_FmStateStruct->revInfo.minorRev);
 #endif  /* FM_NO_GUARANTEED_RESET_VALUES */
 
     CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
index 3e5b2ec..0d56be0 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
@@ -340,9 +340,9 @@ switch (exception){                                         \
 #define DEFAULT_VerifyUcode                 FALSE
 
 #if (DPAA_VERSION < 11)
-#define DEFAULT_totalFifoSize(major)    \
-    (((major == 2) || (major == 5)) ?   \
-     (100*KILOBYTE) : ((major == 4) ?   \
+#define DEFAULT_totalFifoSize(major, minor)     \
+    (((major == 2) || (major == 5)) ?           \
+     (100*KILOBYTE) : ((major == 4) ?           \
      (46*KILOBYTE) : (122*KILOBYTE)))
 #define DEFAULT_totalNumOfTasks             BMI_MAX_NUM_OF_TASKS
 
@@ -369,7 +369,9 @@ switch (exception){                                         \
 
 #else  /* (DPAA_VERSION < 11) */
 /* Defaults are registers' reset values */
-#define DEFAULT_totalFifoSize(major)        (295 * KILOBYTE )
+#define DEFAULT_totalFifoSize(major, minor)	\
+    (((major == 6) && (minor == 1)) ? (128*KILOBYTE) : (295*KILOBYTE))
+
 #define DEFAULT_totalNumOfTasks             124
 
 #define DEFAULT_dmaCommQLow                 0x2A
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
index 996841c..16a0854 100755
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
@@ -317,6 +317,9 @@ void fman_set_liodn_per_port(struct fman_rg *fman_rg, uint8_t port_id,
 {
 	uint32_t tmp;
 
+	if ((port_id > 63) || (port_id < 1))
+	        return;
+
 	/* set LIODN base for this port */
 	tmp = ioread32be(&fman_rg->dma_rg->fmdmplr[port_id / 2]);
 	if (port_id % 2) {
@@ -405,6 +408,9 @@ uint16_t fman_get_size_of_fifo(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
 {
 	uint32_t tmp_reg;
 
+    if ((port_id > 63) || (port_id < 1))
+            return 0;
+
 	tmp_reg = ioread32be(&bmi_rg->fmbm_pfs[port_id - 1]);
 	return (uint16_t)((tmp_reg & BMI_FIFO_SIZE_MASK) + 1);
 }
@@ -423,6 +429,9 @@ uint16_t fman_get_size_of_extra_fifo(struct fman_bmi_regs *bmi_rg,
 {
 	uint32_t tmp_reg;
 
+    if ((port_id > 63) || (port_id < 1))
+            return 0;
+
 	tmp_reg = ioread32be(&bmi_rg->fmbm_pfs[port_id-1]);
 	return (uint16_t)((tmp_reg & BMI_EXTRA_FIFO_SIZE_MASK) >>
 				BMI_EXTRA_FIFO_SIZE_SHIFT);
@@ -435,6 +444,9 @@ void fman_set_size_of_fifo(struct fman_bmi_regs *bmi_rg,
 {
 	uint32_t tmp;
 
+	if ((port_id > 63) || (port_id < 1))
+	        return;
+
 	/* calculate reg */
 	tmp = (uint32_t)((sz_fifo / FMAN_BMI_FIFO_UNITS - 1) |
 		((extra_sz_fifo / FMAN_BMI_FIFO_UNITS) <<
@@ -446,6 +458,9 @@ uint8_t fman_get_num_of_tasks(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
 {
 	uint32_t tmp;
 
+    if ((port_id > 63) || (port_id < 1))
+        return 0;
+
 	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]);
 	return (uint8_t)(((tmp & BMI_NUM_OF_TASKS_MASK) >>
 				BMI_NUM_OF_TASKS_SHIFT) + 1);
@@ -455,6 +470,9 @@ uint8_t fman_get_num_extra_tasks(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
 {
 	uint32_t tmp;
 
+    if ((port_id > 63) || (port_id < 1))
+        return 0;
+
 	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]);
 	return (uint8_t)((tmp & BMI_NUM_OF_EXTRA_TASKS_MASK) >>
 				BMI_EXTRA_NUM_OF_TASKS_SHIFT);
@@ -467,6 +485,9 @@ void fman_set_num_of_tasks(struct fman_bmi_regs *bmi_rg,
 {
 	uint32_t tmp;
 
+	if ((port_id > 63) || (port_id < 1))
+	    return;
+
 	/* calculate reg */
 	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]) &
 			~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
@@ -479,6 +500,9 @@ uint8_t fman_get_num_of_dmas(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
 {
 	uint32_t tmp;
 
+    if ((port_id > 63) || (port_id < 1))
+            return 0;
+
 	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]);
 	return (uint8_t)(((tmp & BMI_NUM_OF_DMAS_MASK) >>
 			BMI_NUM_OF_DMAS_SHIFT) + 1);
@@ -488,6 +512,9 @@ uint8_t fman_get_num_extra_dmas(struct fman_bmi_regs *bmi_rg, uint8_t port_id)
 {
 	uint32_t tmp;
 
+	if ((port_id > 63) || (port_id < 1))
+	        return 0;
+
 	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]);
 	return (uint8_t)((tmp & BMI_NUM_OF_EXTRA_DMAS_MASK) >>
 			BMI_EXTRA_NUM_OF_DMAS_SHIFT);
@@ -500,6 +527,10 @@ void fman_set_num_of_open_dmas(struct fman_bmi_regs *bmi_rg,
 				uint8_t total_num_dmas)
 {
 	uint32_t tmp = 0;
+
+	if ((port_id > 63) || (port_id < 1))
+	    return;
+
 	/* calculate reg */
 	tmp = ioread32be(&bmi_rg->fmbm_pp[port_id - 1]) &
 			~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
@@ -523,12 +554,15 @@ void fman_set_vsp_window(struct fman_bmi_regs *bmi_rg,
 				         uint8_t log2_num_of_profiles)
 {
 	uint32_t tmp = 0;
+	if ((port_id > 63) || (port_id < 1))
+	    return;
 
     tmp = ioread32be(&bmi_rg->fmbm_spliodn[port_id-1]);
     tmp |= (uint32_t)((uint32_t)base_storage_profile & 0x3f) << 16;
     tmp |= (uint32_t)log2_num_of_profiles << 28;
     iowrite32be(tmp, &bmi_rg->fmbm_spliodn[port_id-1]);
 }
+
 void fman_set_congestion_group_pfc_priority(uint32_t *cpg_rg,
 			    	                        uint32_t congestion_group_id,
 				                            uint8_t priority_bit_map)
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
index 69cb22a..2d2e795 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
@@ -62,6 +62,28 @@
 #define CMD_CFG_RX_EN		0x00000002 /* 30 MAC receive path enable */
 #define CMD_CFG_TX_EN		0x00000001 /* 31 MAC transmit path enable */
 
+/* Transmit FIFO Sections Register (TX_FIFO_SECTIONS) */
+#define TX_FIFO_SECTIONS_TX_EMPTY_MASK			0xFFFF0000
+#define TX_FIFO_SECTIONS_TX_AVAIL_MASK			0x0000FFFF
+#define TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G	0x00400000
+#define TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_1G	0x00100000
+#define TX_FIFO_SECTIONS_TX_EMPTY_PFC_10G		0x00360000
+#define TX_FIFO_SECTIONS_TX_EMPTY_PFC_1G		0x00040000
+#define TX_FIFO_SECTIONS_TX_AVAIL_10G			0x00000019
+#define TX_FIFO_SECTIONS_TX_AVAIL_1G			0x00000020
+
+#define GET_TX_EMPTY_DEFAULT_VALUE(_val)					\
+_val &= ~TX_FIFO_SECTIONS_TX_EMPTY_MASK;					\
+((_val == TX_FIFO_SECTIONS_TX_AVAIL_10G) ?					\
+		(_val |= TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G) :	\
+		(_val |= TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_1G));
+
+#define GET_TX_EMPTY_PFC_VALUE(_val)						\
+_val &= ~TX_FIFO_SECTIONS_TX_EMPTY_MASK;					\
+((_val == TX_FIFO_SECTIONS_TX_AVAIL_10G) ?					\
+		(_val |= TX_FIFO_SECTIONS_TX_EMPTY_PFC_10G) :		\
+		(_val |= TX_FIFO_SECTIONS_TX_EMPTY_PFC_1G));
+
 /* Interface Mode Register (IF_MODE) */
 #define IF_MODE_MASK		0x00000003 /* 30-31 Mask on i/f mode bits */
 #define IF_MODE_XGMII		0x00000000 /* 30-31 XGMII (10G) interface */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac_mii_acc.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac_mii_acc.h
index ff9aaa4..b430445 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac_mii_acc.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac_mii_acc.h
@@ -36,7 +36,7 @@
 #include "common/general.h"
 #include "fsl_enet.h"
 /* MII Management Registers */
-#define MDIO_CFG_CLK_DIV_MASK       0x0000ff80
+#define MDIO_CFG_CLK_DIV_MASK       0x0080ff80
 #define MDIO_CFG_CLK_DIV_SHIFT      7
 #define MDIO_CFG_HOLD_MASK          0x0000001c
 #define MDIO_CFG_ENC45              0x00000040
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
index 8a10164..292d37d 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
@@ -38,7 +38,7 @@
 /** @Collection  Registers bit fields */
 
 /** @Description  BMI defines */
-#define BMI_EBD_EN				0x80000000
+#define BMI_EBD_EN                              0x80000000
 
 #define BMI_PORT_CFG_EN				0x80000000
 #define BMI_PORT_CFG_FDOVR			0x02000000
-- 
1.9.1

