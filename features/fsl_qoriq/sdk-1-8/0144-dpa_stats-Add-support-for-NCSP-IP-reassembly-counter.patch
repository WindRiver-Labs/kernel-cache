From afbcbfbb175a81b3c7c509e8b3156ab40dd1909c Mon Sep 17 00:00:00 2001
From: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Date: Mon, 22 Apr 2013 16:45:42 +0300
Subject: [PATCH 144/987] dpa_stats: Add support for NCSP IP reassembly counter

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Added support for non consistent storage profile reassembly counter
for FMANv3 capable platforms. For non FMANv3 platforms the driver will
accept the stat selection, but will always return 0

Signed-off-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Change-Id: I27501de84499c1db5085510eb7c320709786617e
Reviewed-on: http://git.am.freescale.net:8181/2241
Reviewed-by: Floarea Anca Jeanina-B12569 <anca.floarea@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c | 46 +++++++++++++++++--------
 include/linux/fsl_dpa_stats.h               | 53 ++++++++++++++++-------------
 2 files changed, 61 insertions(+), 38 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index e0226c7..13f550c 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -731,60 +731,68 @@ static void create_cnt_reass_stats(struct dpa_stats *dpa_stats)
 	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][5] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			dmaSemaphoreDepletion);
+#if (DPAA_VERSION >= 11)
+	/* DPA_STATS_CNT_REASS_NON_CONSISTENT_SP */
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][6] = offsetof(
+			struct t_FmPcdManipReassemIpStats,
+			nonConsistentSp);
+#else
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][6] = 0;
+#endif /* (DPAA_VERSION >= 11) */
 	/* DPA_STATS_CNT_REASS_IPv4_FRAMES */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][7] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][8] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[0].successfullyReassembled);
 	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_VALID */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][8] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][9] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[0].validFragments);
 	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_TOTAL */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][9] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][10] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[0].processedFragments);
 	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_MALFORMED */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][10] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][11] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[0].malformedFragments);
 	/* DPA_STATS_CNT_REASS_IPv4_FRAGS_DISCARDED */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][11] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][12] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[0].discardedFragments);
 	/* DPA_STATS_CNT_REASS_IPv4_AUTOLEARN_BUSY */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][12] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][13] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[0].autoLearnBusy);
 	/* DPA_STATS_CNT_REASS_IPv4_EXCEED_16FRAGS */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][13] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][14] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[0].moreThan16Fragments);
 	/* DPA_STATS_CNT_REASS_IPv6_FRAMES */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][15] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][16] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[1].successfullyReassembled);
 	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_VALID */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][16] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][17] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[1].validFragments);
 	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_TOTAL */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][17] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][18] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[1].processedFragments);
 	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_MALFORMED */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][18] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][19] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[1].malformedFragments);
 	/* DPA_STATS_CNT_REASS_IPv6_FRAGS_DISCARDED */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][19] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][20] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[1].discardedFragments);
 	/* DPA_STATS_CNT_REASS_IPv6_AUTOLEARN_BUSY */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][20] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][21] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[1].autoLearnBusy);
 	/* DPA_STATS_CNT_REASS_IPv6_EXCEED_16FRAGS */
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][21] = offsetof(
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][22] = offsetof(
 			struct t_FmPcdManipReassemIpStats,
 			specificHdrStatistics[1].moreThan16Fragments);
 }
@@ -2058,6 +2066,16 @@ static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 	uint64_t stats_val;
 
 	for (j = 0; j < stats_info->stats_num; j++) {
+
+		if (!stats_info->stats_off[j]) {
+			/* Write the memory location */
+			memset(req_cb->request_area, 0, STATS_VAL_SIZE);
+
+			/* Update the memory pointer */
+			req_cb->request_area += STATS_VAL_SIZE ;
+			continue;
+		}
+
 		/* Get statistics value */
 		stats_val = (uint64_t)(*((uint32_t *)
 				(stats + stats_info->stats_off[j])));
diff --git a/include/linux/fsl_dpa_stats.h b/include/linux/fsl_dpa_stats.h
index 6abd08f..6046787 100644
--- a/include/linux/fsl_dpa_stats.h
+++ b/include/linux/fsl_dpa_stats.h
@@ -223,19 +223,24 @@ struct dpa_stats_cnt_eth {
  */
 enum dpa_stats_cnt_reass_gen_sel {
 	/* Number of timeout occurrences */
-	DPA_STATS_CNT_REASS_TIMEOUT		= 0x00000001,
+	DPA_STATS_CNT_REASS_TIMEOUT			= 0x00000001,
 	/* Number of failed attempts to allocate a Reassembly Frame Descriptor*/
-	DPA_STATS_CNT_REASS_RFD_POOL_BUSY	= 0x00000002,
+	DPA_STATS_CNT_REASS_RFD_POOL_BUSY		= 0x00000002,
 	/* Number of internal buffer busy occurrences */
-	DPA_STATS_CNT_REASS_INT_BUFF_BUSY	= 0x00000004,
+	DPA_STATS_CNT_REASS_INT_BUFF_BUSY		= 0x00000004,
 	/* Number of external buffer busy occurrences */
-	DPA_STATS_CNT_REASS_EXT_BUFF_BUSY	= 0x00000008,
+	DPA_STATS_CNT_REASS_EXT_BUFF_BUSY		= 0x00000008,
 	/* Number of Scatter/Gather fragments */
-	DPA_STATS_CNT_REASS_SG_FRAGS		= 0x00000010,
+	DPA_STATS_CNT_REASS_SG_FRAGS			= 0x00000010,
 	/* Number of failed attempts to allocate a DMA semaphore */
-	DPA_STATS_CNT_REASS_DMA_SEM		= 0x00000020,
-	/* Select all counters from dpa_stats_cnt_reass_common_sel */
-	DPA_STATS_CNT_REASS_GEN_ALL		= 0x00000040
+	DPA_STATS_CNT_REASS_DMA_SEM			= 0x00000020,
+	/*
+	 * Number of Non Consistent Storage Profile occurrences for successfully
+	 * reassembled frames
+	 */
+	DPA_STATS_CNT_REASS_NON_CONSISTENT_SP		= 0x00000040,
+	/* Select all counters from dpa_stats_cnt_reass_gen_sel */
+	DPA_STATS_CNT_REASS_GEN_ALL			= 0x00000080
 };
 
 /*
@@ -244,24 +249,24 @@ enum dpa_stats_cnt_reass_gen_sel {
  */
 enum dpa_stats_cnt_reass_ipv4_sel {
 	/* Number of successfully reassembled IPv4 frames */
-	DPA_STATS_CNT_REASS_IPv4_FRAMES		= 0x00000080,
+	DPA_STATS_CNT_REASS_IPv4_FRAMES		= 0x00000100,
 	/* Number of valid IPv4 fragments */
-	DPA_STATS_CNT_REASS_IPv4_FRAGS_VALID	 = 0x00000100,
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_VALID	 = 0x00000200,
 	/* Number of processed IPv4 fragments */
-	DPA_STATS_CNT_REASS_IPv4_FRAGS_TOTAL	 = 0x00000200,
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_TOTAL	 = 0x00000400,
 	/* Number of malformed IPv4 fragments */
-	DPA_STATS_CNT_REASS_IPv4_FRAGS_MALFORMED = 0x00000400,
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_MALFORMED = 0x00000800,
 	/* Number of discarded IPv4 fragments except Timeout condition */
-	DPA_STATS_CNT_REASS_IPv4_FRAGS_DISCARDED = 0x00000800,
+	DPA_STATS_CNT_REASS_IPv4_FRAGS_DISCARDED = 0x00001000,
 	/* Number of busy conditions due to Automatic Learning Hash access */
-	DPA_STATS_CNT_REASS_IPv4_AUTOLEARN_BUSY	 = 0x00001000,
+	DPA_STATS_CNT_REASS_IPv4_AUTOLEARN_BUSY	 = 0x00002000,
 	/*
 	 * Number of IPv4 fragments occurrences when the number of
 	 * fragments-per-frame exceeds 16
 	 */
-	DPA_STATS_CNT_REASS_IPv4_EXCEED_16FRAGS  = 0x00002000,
+	DPA_STATS_CNT_REASS_IPv4_EXCEED_16FRAGS  = 0x00004000,
 	/* Select all counters from dpa_stats_cnt_reass_ipv4_sel */
-	DPA_STATS_CNT_REASS_IPv4_ALL		 = 0x00004000
+	DPA_STATS_CNT_REASS_IPv4_ALL		 = 0x00008000
 };
 
 /*
@@ -270,24 +275,24 @@ enum dpa_stats_cnt_reass_ipv4_sel {
  */
 enum dpa_stats_cnt_reass_ipv6_sel {
 	/* Number of successfully reassembled IPv6 frames*/
-	DPA_STATS_CNT_REASS_IPv6_FRAMES		= 0x00008000,
+	DPA_STATS_CNT_REASS_IPv6_FRAMES		= 0x00010000,
 	/* Number of valid IPv6 fragments */
-	DPA_STATS_CNT_REASS_IPv6_FRAGS_VALID	 = 0x00010000,
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_VALID	 = 0x00020000,
 	/* Number of processed IPv6 fragments */
-	DPA_STATS_CNT_REASS_IPv6_FRAGS_TOTAL	 = 0x00020000,
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_TOTAL	 = 0x00040000,
 	/* Number of malformed IPv6 fragments */
-	DPA_STATS_CNT_REASS_IPv6_FRAGS_MALFORMED = 0x00040000,
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_MALFORMED = 0x00080000,
 	/* Number of discarded IPv6 fragments except Timeout condition */
-	DPA_STATS_CNT_REASS_IPv6_FRAGS_DISCARDED = 0x00080000,
+	DPA_STATS_CNT_REASS_IPv6_FRAGS_DISCARDED = 0x00100000,
 	/* Number of busy conditions due to Automatic Learning Hash access */
-	DPA_STATS_CNT_REASS_IPv6_AUTOLEARN_BUSY  = 0x00100000,
+	DPA_STATS_CNT_REASS_IPv6_AUTOLEARN_BUSY  = 0x00200000,
 	/*
 	 * Number of IPv6 fragments occurrences when the number of
 	 * fragments-per-frame exceeds 16
 	 */
-	DPA_STATS_CNT_REASS_IPv6_EXCEED_16FRAGS  = 0x00200000,
+	DPA_STATS_CNT_REASS_IPv6_EXCEED_16FRAGS  = 0x00400000,
 	/* Select all counters from dpa_stats_cnt_reass_ipv6_sel */
-	DPA_STATS_CNT_REASS_IPv6_ALL		 = 0x00400000
+	DPA_STATS_CNT_REASS_IPv6_ALL		 = 0x00800000
 };
 
 /* DPA Stats IP Reassembly counter parameters */
-- 
1.9.1

