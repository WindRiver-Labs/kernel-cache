From 3a52ff7b5bd521fa42ee4718c4698dba1d241f65 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 21 Jul 2014 17:51:41 +0300
Subject: [PATCH 806/987] dpa_offload: Adjust debug information for
 dpa_classifier

Added possibility to display some more debugging information.

Change-Id: I66a7a110953b6dbcea15b3ee983cd5814fc65ce7
Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/15222
Reviewed-by: Radu-Andrei Bulie <Radu.Bulie@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c | 86 +++++++++++++++++++++---
 1 file changed, 78 insertions(+), 8 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index ae96fce..fe22df8 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -3777,6 +3777,8 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 			/* Node does not exist, we need to create it */
 			hm->hm_node[i] = kzalloc(sizeof(struct dpa_cls_hm_node),
 						 GFP_KERNEL);
+			dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Created new hm_node = 0x%p\n", __func__,
+				__LINE__, hm->hm_node[i]));
 			if (!hm->hm_node[i]) {
 				log_err("Not enough memory for HM node "
 					"management.\n");
@@ -4009,8 +4011,8 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 	pcurrent->params.h_NextManip = (pnext) ? (t_Handle)pnext->node : NULL;
 
 #ifdef DPA_CLASSIFIER_DEBUG
-	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Dumping HM node params.\n",
-		__func__, __LINE__));
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Dumping HM node params for hm_node @ 0x%p\n",
+		__func__, __LINE__, pcurrent));
 	switch (pcurrent->params.type) {
 	case e_FM_PCD_MANIP_HDR:
 		dpa_cls_dbg(("	hm_node_params.type = "
@@ -4018,9 +4020,33 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 		dpa_cls_dbg(("	hm_node_params.u.hdr.rmv = %d\n",
 			pcurrent->params.u.hdr.rmv));
 		if (pcurrent->params.u.hdr.rmv) {
-			dpa_cls_dbg(("	hm_node_params.u.hdr.rmvParams"
-				".type = %d\n",
-				pcurrent->params.u.hdr.rmvParams.type));
+			switch (pcurrent->params.u.hdr.rmvParams.type) {
+			case e_FM_PCD_MANIP_RMV_GENERIC:
+				dpa_cls_dbg(("	hm_node_params.u.hdr.rmvParams"
+					".type = e_FM_PCD_MANIP_RMV_GENERIC\n"));
+				dpa_cls_dbg(("	hm_node_params.u.hdr.rmvParams."
+					"u.generic.offset = %u\n",
+					pcurrent->params.u.hdr.rmvParams.u.generic.offset));
+				dpa_cls_dbg(("	hm_node_params.u.hdr.rmvParams."
+					"u.generic.size = %u\n",
+					pcurrent->params.u.hdr.rmvParams.u.generic.size));
+				break;
+			case e_FM_PCD_MANIP_RMV_BY_HDR:
+				dpa_cls_dbg(("	hm_node_params.u.hdr.rmvParams"
+					".type = e_FM_PCD_MANIP_RMV_BY_HDR\n"));
+				if (pcurrent->params.u.hdr.rmvParams.u.byHdr.type == e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2) {
+					dpa_cls_dbg(("	hm_node_params.u.hdr.rmvParams."
+						"u.byHdr.type = e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2\n"));
+					dpa_cls_dbg(("	hm_node_params.u.hdr.rmvParams."
+						"u.byHdr.u.specificL2 = %d\n",
+						pcurrent->params.u.hdr.rmvParams.u.byHdr.u.specificL2));
+				} else {
+					dpa_cls_dbg(("	hm_node_params.u.hdr.rmvParams."
+						"u.byHdr.type = %d\n",
+						pcurrent->params.u.hdr.rmvParams.u.byHdr.type));
+				}
+				break;
+			}
 		}
 		dpa_cls_dbg(("	hm_node_params.u.hdr.insrt = %d\n",
 			pcurrent->params.u.hdr.insrt));
@@ -4113,10 +4139,26 @@ static int init_hm_chain(void *fm_pcd, struct list_head *chain_head,
 		dpa_cls_dbg(("	hm_node_params.u.hdr.custom = %d\n",
 			pcurrent->params.u.hdr.custom));
 		if (pcurrent->params.u.hdr.custom) {
-			dpa_cls_dbg(("	hm_node_params.u.hdr."
-				"custom.type = %d\n",
-				pcurrent->params.u.hdr.customParams.type));
+			if (pcurrent->params.u.hdr.customParams.type ==
+					e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE) {
+				dpa_cls_dbg(("	hm_node_params.u.hdr.customParams."
+					"type = e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE\n"));
+				dpa_cls_dbg(("	hm_node_params.u.hdr.customParams.u.ipHdrReplace.replaceType = %d\n",
+					pcurrent->params.u.hdr.customParams.u.ipHdrReplace.replaceType));
+				dpa_cls_dbg(("	hm_node_params.u.hdr.customParams.u.ipHdrReplace.decTtlHl = %d\n",
+					pcurrent->params.u.hdr.customParams.u.ipHdrReplace.decTtlHl));
+				dpa_cls_dbg(("	hm_node_params.u.hdr.customParams.u.ipHdrReplace.updateIpv4Id = %d\n",
+					pcurrent->params.u.hdr.customParams.u.ipHdrReplace.updateIpv4Id));
+				dpa_cls_dbg(("	hm_node_params.u.hdr.customParams.u.ipHdrReplace.id = %u\n",
+					pcurrent->params.u.hdr.customParams.u.ipHdrReplace.id));
+				dpa_cls_dbg(("	hm_node_params.u.hdr.customParams.u.ipHdrReplace.hdrSize = %u\n",
+					pcurrent->params.u.hdr.customParams.u.ipHdrReplace.hdrSize));
+			} else
+				dpa_cls_dbg(("	hm_node_params.u.hdr.customParams.type = %d\n",
+					pcurrent->params.u.hdr.customParams.type));
 		}
+		dpa_cls_dbg(("	hm_node_params.u.hdr.dontParseAfterManip = %d\n",
+			pcurrent->params.u.hdr.dontParseAfterManip));
 		break;
 	case e_FM_PCD_MANIP_FRAG:
 		dpa_cls_dbg(("	hm_node_params.type = "
@@ -4464,6 +4506,9 @@ static int nat_hm_prepare_nodes(struct dpa_cls_hm *pnat_hm,
 	if (res) { /* Import HM nodes */
 		phm_nodes = &res->l3_update_node;
 
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+			__LINE__));
+
 		return import_hm_nodes_to_chain(phm_nodes,
 					pnat_hm->num_nodes,
 					pnat_hm);
@@ -4973,6 +5018,9 @@ static int fwd_hm_prepare_nodes(struct dpa_cls_hm *pfwd_hm,
 	if (res) { /* Import HM nodes */
 		phm_nodes = &res->fwd_node;
 
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+			__LINE__));
+
 		return import_hm_nodes_to_chain(phm_nodes,
 					pfwd_hm->num_nodes,
 					pfwd_hm);
@@ -4980,6 +5028,9 @@ static int fwd_hm_prepare_nodes(struct dpa_cls_hm *pfwd_hm,
 
 	/* Create a header manip node: */
 	hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+
+	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Created new hm_node = 0x%p\n", __func__,
+		__LINE__, hm_node));
 	if (!hm_node) {
 		log_err("No more memory for header manip nodes.\n");
 		return -ENOMEM;
@@ -4996,6 +5047,8 @@ static int fwd_hm_prepare_nodes(struct dpa_cls_hm *pfwd_hm,
 		/* IP fragmentation option is enabled */
 		/* Create a header manip node: */
 		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Created new hm_node = 0x%p\n", __func__,
+			__LINE__, hm_node));
 		if (!hm_node) {
 			log_err("No more memory for header manip nodes.\n");
 			return -ENOMEM;
@@ -5418,6 +5471,9 @@ static int remove_hm_prepare_nodes(struct dpa_cls_hm *premove_hm,
 	if (hm_node == NULL) {
 		/* Create a header manip node for this remove: */
 		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Created new hm_node = 0x%p\n", __func__,
+			__LINE__, hm_node));
 		if (!hm_node) {
 			log_err("No more memory for header manip nodes.\n");
 			return -ENOMEM;
@@ -5716,6 +5772,9 @@ static int insert_hm_prepare_nodes(struct dpa_cls_hm *pinsert_hm,
 	if (hm_node == NULL) {
 		/* Create a header manip node for this insert: */
 		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Created new hm_node = 0x%p\n", __func__,
+			__LINE__, hm_node));
 		if (!hm_node) {
 			log_err("No more memory for header manip nodes.\n");
 			return -ENOMEM;
@@ -6121,6 +6180,9 @@ static int update_hm_prepare_nodes(struct dpa_cls_hm *pupdate_hm,
 	if (res) { /* Import HM nodes */
 		phm_nodes = &res->update_node;
 
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
+			__LINE__));
+
 		return import_hm_nodes_to_chain(phm_nodes,
 					pupdate_hm->num_nodes,
 					pupdate_hm);
@@ -6151,6 +6213,8 @@ static int update_hm_prepare_nodes(struct dpa_cls_hm *pupdate_hm,
 		/* IP fragmentation option is enabled */
 		/* Create a header manip node: */
 		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Created new hm_node = 0x%p\n", __func__,
+			__LINE__, hm_node));
 		if (!hm_node) {
 			log_err("No more memory for header manip nodes.\n");
 			return -ENOMEM;
@@ -6758,6 +6822,9 @@ static int vlan_hm_prepare_nodes(struct dpa_cls_hm *pvlan_hm,
 	if (hm_node == NULL) {
 		/* Create a header manip node for this insert: */
 		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Created new hm_node = 0x%p\n", __func__,
+			__LINE__, hm_node));
 		if (!hm_node) {
 			log_err("No more memory for header manip nodes.\n");
 			return -ENOMEM;
@@ -7156,6 +7223,9 @@ static int mpls_hm_prepare_nodes(struct dpa_cls_hm *pmpls_hm,
 	if (hm_node == NULL) {
 		/* Create a header manip node for this insert: */
 		hm_node = kzalloc(sizeof(*hm_node), GFP_KERNEL);
+
+		dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d): Created new hm_node = 0x%p\n", __func__,
+			__LINE__, hm_node));
 		if (!hm_node) {
 			log_err("No more memory for header manip nodes.\n");
 			return -ENOMEM;
-- 
1.9.1

