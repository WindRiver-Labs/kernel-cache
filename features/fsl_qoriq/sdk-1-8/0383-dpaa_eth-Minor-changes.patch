From fb96df6e1883327fa10f9edb1451788c8d3bc5d7 Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Wed, 18 Sep 2013 12:50:48 +0300
Subject: [PATCH 383/987] dpaa_eth: Minor changes

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

A bit of cleanup in function skb_to_contig_fd().

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: Ifbf32b298d1588574b9eabf90d0bd1607b733d2c
Reviewed-on: http://git.am.freescale.net:8181/4837
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 23 ++++++++++++-----------
 1 file changed, 12 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 5919867..2b3d1d5 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -606,9 +606,9 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 	struct dpa_bp *dpa_bp = priv->dpa_bp;
 	struct net_device *net_dev = priv->net_dev;
 	int err;
-	enum dma_data_direction dma_dir = DMA_TO_DEVICE;
+	enum dma_data_direction dma_dir;
 	int *count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
-	unsigned char *rec_buf_start;
+	unsigned char *buffer_start;
 
 #ifndef CONFIG_FSL_DPAA_TS
 	/* Check recycling conditions; only if timestamp support is not
@@ -623,15 +623,14 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 	if (likely((*count_ptr < dpa_bp->target_count) &&
 		   dpa_skb_is_recyclable(skb) &&
 		   dpa_buf_is_recyclable(skb, dpa_bp->size,
-					 priv->tx_headroom, &rec_buf_start))) {
-		/* Buffer is recyclable; use the new start address */
-		skbh = (struct sk_buff **)rec_buf_start;
-
-		/* and set fd parameters and DMA mapping direction */
+					 priv->tx_headroom, &buffer_start))) {
+		/* Buffer is recyclable; use the new start address
+		 * and set fd parameters and DMA mapping direction
+		 */
 		fd->cmd |= FM_FD_CMD_FCO;
 		fd->bpid = dpa_bp->bpid;
-		BUG_ON(skb->data - rec_buf_start > DPA_MAX_FD_OFFSET);
-		fd->offset = (uint16_t)(skb->data - rec_buf_start);
+		BUG_ON(skb->data - buffer_start > DPA_MAX_FD_OFFSET);
+		fd->offset = (uint16_t)(skb->data - buffer_start);
 		dma_dir = DMA_BIDIRECTIONAL;
 	} else
 #endif
@@ -640,10 +639,12 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 		 * We are guaranteed to have at least tx_headroom bytes
 		 * available, so just use that for offset.
 		 */
-		skbh = (struct sk_buff **)(skb->data - priv->tx_headroom);
+		buffer_start = skb->data - priv->tx_headroom;
 		fd->offset = priv->tx_headroom;
+		dma_dir = DMA_TO_DEVICE;
 	}
 
+	skbh = (struct sk_buff **)buffer_start;
 	*skbh = skb;
 
 	/* Enable L3/L4 hardware checksum computation.
@@ -665,7 +666,7 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 
 	/* Map the entire buffer size that may be seen by FMan, but no more */
 	addr = dma_map_single(dpa_bp->dev, skbh,
-			skb_end_pointer(skb) - (unsigned char *)skbh, dma_dir);
+			skb_end_pointer(skb) - buffer_start, dma_dir);
 	if (unlikely(dma_mapping_error(dpa_bp->dev, addr))) {
 		if (netif_msg_tx_err(priv) && net_ratelimit())
 			netdev_err(net_dev, "dma_map_single() failed\n");
-- 
1.9.1

