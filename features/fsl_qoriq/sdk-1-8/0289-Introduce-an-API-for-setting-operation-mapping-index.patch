From 98570ee4da44587bf8618640c13650b4a238498d Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Tue, 9 Sep 2014 15:20:25 +0800
Subject: [PATCH 289/987] Introduce an API for setting operation mapping index
 per window.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

This API can be used for setting operation mapping per DMA window.

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
[Fix context to apply to WRL.]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/iommu/fsl_pamu.c        |  4 +++
 drivers/iommu/fsl_pamu.h        |  1 +
 drivers/iommu/fsl_pamu_domain.c | 58 +++++++++++++++++++++++++++++++++++++++++
 include/linux/iommu.h           |  6 +++++
 4 files changed, 69 insertions(+)

diff --git a/drivers/iommu/fsl_pamu.c b/drivers/iommu/fsl_pamu.c
index d749443..ac9b08a 100644
--- a/drivers/iommu/fsl_pamu.c
+++ b/drivers/iommu/fsl_pamu.c
@@ -281,6 +281,10 @@ int  pamu_update_paace_field(int liodn, u32 subwin, int field, u32 value)
 	case PAACE_STASH_FIELD:
 		set_bf(paace->impl_attr, PAACE_IA_CID, value);
 		break;
+	case PAACE_OMI_FIELD:
+		set_bf(paace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);
+		paace->op_encode.index_ot.omi = value;
+		break;
 	default:
 		pr_debug("Invalid field, can't update\n");
 		return -EINVAL;
diff --git a/drivers/iommu/fsl_pamu.h b/drivers/iommu/fsl_pamu.h
index ed616e6..f897f65 100644
--- a/drivers/iommu/fsl_pamu.h
+++ b/drivers/iommu/fsl_pamu.h
@@ -392,6 +392,7 @@ struct ome {
 
 enum  paace_field {
 	PAACE_STASH_FIELD,
+	PAACE_OMI_FIELD,
 	PAACE_FIELD_MAX,
 };
 
diff --git a/drivers/iommu/fsl_pamu_domain.c b/drivers/iommu/fsl_pamu_domain.c
index 9df0d18..966dc7f 100644
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@ -785,6 +785,49 @@ static  int configure_domain_geometry(struct iommu_domain *domain, void *data)
 	return 0;
 }
 
+/* Set the domain operation mapping attribute */
+static int configure_domain_op_map(struct fsl_dma_domain *dma_domain,
+				    void *data)
+{
+	struct dma_window *wnd;
+	unsigned long flags;
+	struct pamu_attr_info attr_info;
+	int ret, i;
+	struct iommu_omi_attribute *omi_attr = data;
+
+	spin_lock_irqsave(&dma_domain->domain_lock, flags);
+
+	if (!dma_domain->win_arr) {
+		pr_err("Number of windows not configured\n");
+		spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
+		return -ENODEV;
+	}
+
+	if (omi_attr->omi >= OMI_MAX) {
+		pr_err("Invalid operation mapping index\n");
+		spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
+		return -EINVAL;
+	}
+
+	if (~omi_attr->window == 0) {
+		wnd = &dma_domain->win_arr[0];
+		for (i = 0; i < dma_domain->win_cnt; i++)
+			wnd[i].omi = omi_attr->omi;
+	} else {
+		wnd = &dma_domain->win_arr[omi_attr->window];
+		wnd->omi = omi_attr->omi;
+	}
+
+	attr_info.window = omi_attr->window;
+	attr_info.field = PAACE_OMI_FIELD;
+	attr_info.value = omi_attr->omi;
+	ret = update_domain_attr(dma_domain, &attr_info);
+
+	spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
+
+	return ret;
+}
+
 /* Set the domain stash attribute */
 static int configure_domain_stash(struct fsl_dma_domain *dma_domain, void *data)
 {
@@ -878,6 +921,9 @@ static int fsl_pamu_set_domain_attr(struct iommu_domain *domain,
 	case DOMAIN_ATTR_FSL_PAMU_ENABLE:
 		ret = configure_domain_dma_state(dma_domain, *(int *)data);
 		break;
+	case DOMAIN_ATTR_PAMU_OP_MAP:
+		ret = configure_domain_op_map(dma_domain, data);
+		break;
 	default:
 		pr_debug("Unsupported attribute type\n");
 		ret = -EINVAL;
@@ -912,6 +958,18 @@ static int fsl_pamu_get_domain_attr(struct iommu_domain *domain,
 		memcpy(stash_attr, &wnd->stash_attr, sizeof(struct iommu_stash_attribute));
 		break;
 	}
+	case DOMAIN_ATTR_PAMU_OP_MAP: {
+		struct iommu_omi_attribute *omi_attr = data;
+		struct dma_window *wnd;
+
+		if (omi_attr->window >= dma_domain->win_cnt ||
+			~omi_attr->window == 0)
+			return -EINVAL;
+
+		wnd = &dma_domain->win_arr[omi_attr->window];
+		omi_attr->omi = wnd->omi;
+		break;
+	}
 	default:
 		pr_debug("Unsupported attribute type\n");
 		ret = -EINVAL;
diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index bb196b4..9f55876 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -45,6 +45,11 @@ struct notifier_block;
 typedef int (*iommu_fault_handler_t)(struct iommu_domain *,
 			struct device *, unsigned long, int, void *);
 
+struct iommu_omi_attribute {
+	u32 omi;   /* index in the operation mapping table */
+	u32 window; /* ~0 indicates all windows */
+};
+
 struct iommu_domain_geometry {
 	dma_addr_t aperture_start; /* First address that can be mapped    */
 	dma_addr_t aperture_end;   /* Last address that can be mapped     */
@@ -118,6 +123,7 @@ enum iommu_attr {
 	DOMAIN_ATTR_FSL_PAMU_STASH,
 	DOMAIN_ATTR_FSL_PAMU_ENABLE,
 	DOMAIN_ATTR_FSL_PAMUV1,
+	DOMAIN_ATTR_PAMU_OP_MAP,
 	DOMAIN_ATTR_NESTING,	/* two stages of translation */
 	DOMAIN_ATTR_MAX,
 };
-- 
1.9.1

