From cda8a69c0b573e1dcec22a0d757aec4cce12052e Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Tue, 18 Nov 2014 15:34:02 -0500
Subject: [PATCH 30/45] Disable CPU migration during USDPAA Cleanup

CPU specific variables are used during USDPAA cleanup. Disabling
CPU migration is needed to avoid the cleanup process from being
moved to another CPU (especially when using the RT preemption models)

Change-Id: If0133117fcec82f69e6123cb4da3167363b0dad3
Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/24105
Reviewed-by: Roy Pledge <roy.pledge@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Original patch taken from QorIQ-SDK-V1.8-20150619-yocto]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c |   15 +++++++++++++--
 1 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 285a050..31875c4 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -522,6 +522,10 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 	struct qm_portal *portal_array[qman_portal_max];
 	int portal_count = 0;
 
+	/* Ensure the release operation cannot be migrated to another
+	   CPU as CPU specific variables may be needed during cleanup */
+	migrate_disable();
+
 	/* The following logic is used to recover resources that were not
 	   correctly released by the process that is closing the FD.
 	   Step 1: syncronize the HW with the qm_portal/bm_portal structures
@@ -557,12 +561,15 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 		qm_alloced_portal = qm_get_unused_portal();
 		if (!qm_alloced_portal) {
 			pr_crit("No QMan portal avalaible for cleanup\n");
+			migrate_enable();
 			return -1;
 		}
 		qm_cleanup_portal = kmalloc(sizeof(struct qm_portal),
 					    GFP_KERNEL);
-		if (!qm_cleanup_portal)
+		if (!qm_cleanup_portal) {
+			migrate_enable();
 			return -ENOMEM;
+		}
 		init_qm_portal(qm_alloced_portal, qm_cleanup_portal);
 		portal_array[portal_count] = qm_cleanup_portal;
 		++portal_count;
@@ -571,12 +578,15 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 		bm_alloced_portal = bm_get_unused_portal();
 		if (!bm_alloced_portal) {
 			pr_crit("No BMan portal avalaible for cleanup\n");
+			migrate_enable();
 			return -1;
 		}
 		bm_cleanup_portal = kmalloc(sizeof(struct bm_portal),
 					    GFP_KERNEL);
-		if (!bm_cleanup_portal)
+		if (!bm_cleanup_portal) {
+			migrate_enable();
 			return -ENOMEM;
+		}
 		init_bm_portal(bm_alloced_portal, bm_cleanup_portal);
 	}
 
@@ -652,6 +662,7 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 	}
 
 	kfree(ctx);
+	migrate_enable();
 	return 0;
 }
 
-- 
1.7.5.4

