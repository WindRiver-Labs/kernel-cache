From c3818ea111048a63854abf74bd4182100eaf9595 Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Wed, 11 Dec 2013 19:53:09 +0200
Subject: [PATCH 467/987] fsl_qbman: fix a few spelling errors

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Fix some spelling errors reported by codespell.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Change-Id: I4c2f89d218389b0019ae4ff80206e05b94d715e4
Reviewed-on: http://git.am.freescale.net:8181/7707
Reviewed-by: Haiying Wang <Haiying.Wang@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/bman_low.h            | 4 ++--
 drivers/staging/fsl_qbman/fsl_usdpaa.c          | 2 +-
 drivers/staging/fsl_qbman/fsl_usdpaa_irq.c      | 2 +-
 drivers/staging/fsl_qbman/qman_high.c           | 2 +-
 drivers/staging/fsl_qbman/qman_low.h            | 2 +-
 drivers/staging/fsl_qbman/qman_test_hotpotato.c | 2 +-
 include/linux/fsl_bman.h                        | 8 ++++----
 include/linux/fsl_qman.h                        | 4 ++--
 8 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_low.h b/drivers/staging/fsl_qbman/bman_low.h
index 6f267d9..aea97ed 100644
--- a/drivers/staging/fsl_qbman/bman_low.h
+++ b/drivers/staging/fsl_qbman/bman_low.h
@@ -187,7 +187,7 @@ static inline void RCR_INC(struct bm_rcr *rcr)
 static inline int bm_rcr_init(struct bm_portal *portal, enum bm_rcr_pmode pmode,
 		__maybe_unused enum bm_rcr_cmode cmode)
 {
-	/* This use of 'register', as well as all other occurances, is because
+	/* This use of 'register', as well as all other occurrences, is because
 	 * it has been observed to generate much faster code with gcc than is
 	 * otherwise the case. */
 	register struct bm_rcr *rcr = &portal->rcr;
@@ -505,7 +505,7 @@ static inline int bm_shutdown_pool(struct bm_portal *p, u32 bpid)
 	int aq_count = 0;
 	bool stop = false;
 	while (!stop) {
-		/* Aquire buffers until empty */
+		/* Acquire buffers until empty */
 		bm_cmd = bm_mc_start(p);
 		bm_cmd->acquire.bpid = bpid;
 		bm_mc_commit(p, BM_MCC_VERB_CMD_ACQUIRE |  1);
diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 87ddb2c..4dac5c0 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -897,7 +897,7 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 		ret = -EINVAL;
 		goto out;
 	}
-	/* Verify there is sufficent space to do the mapping */
+	/* Verify there is sufficient space to do the mapping */
 	down_write(&current->mm->mmap_sem);
 	next_addr = usdpaa_get_unmapped_area(fp, next_addr, i->len, 0, 0);
 	up_write(&current->mm->mmap_sem);
diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c b/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
index 54073fb..ca93593 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
@@ -31,7 +31,7 @@
  */
 
 /* define a device that allows USPDAA processes to open a file
-   decriptor and specify which IRQ it wants to montior using an ioctl()
+   descriptor and specify which IRQ it wants to montior using an ioctl()
    When an IRQ is received, the device becomes readable so that a process
    can use read() or select() type calls to monitor for IRQs */
 
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index bc46b98..edbdced 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -3236,7 +3236,7 @@ int qman_ceetm_bps2tokenrate(u32 bps, struct qm_ceetm_rate *token_rate,
 
 	/* token-rate = bytes-per-second * update-reference-period
 	 *
-	 * Where token-rate is N/8192 for a interger N, and
+	 * Where token-rate is N/8192 for a integer N, and
 	 * update-reference-period is (2^22)/(PRES*QHz), where PRES
 	 * is the prescalar value and QHz is the QMan clock frequency.
 	 * So:
diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index 5d40f44b..cbf47af 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -281,7 +281,7 @@ static inline int qm_eqcr_init(struct qm_portal *portal,
 				unsigned int eq_stash_thresh,
 				int eq_stash_prio)
 {
-	/* This use of 'register', as well as all other occurances, is because
+	/* This use of 'register', as well as all other occurrences, is because
 	 * it has been observed to generate much faster code with gcc than is
 	 * otherwise the case. */
 	register struct qm_eqcr *eqcr = &portal->eqcr;
diff --git a/drivers/staging/fsl_qbman/qman_test_hotpotato.c b/drivers/staging/fsl_qbman/qman_test_hotpotato.c
index 91e01d7..deeb1c7 100644
--- a/drivers/staging/fsl_qbman/qman_test_hotpotato.c
+++ b/drivers/staging/fsl_qbman/qman_test_hotpotato.c
@@ -42,7 +42,7 @@
  * shuttle a "hot potato" frame around them such that every forwarding action
  * moves it from one cpu to another. (The use of more than one handler per cpu
  * is to allow enough handlers/FQs to truly test the significance of caching -
- * ie. when cache-expiries are occuring.)
+ * ie. when cache-expiries are occurring.)
  *
  * The "hot potato" frame content will be HP_NUM_WORDS*4 bytes in size, and the
  * first and last words of the frame data will undergo a transformation step on
diff --git a/include/linux/fsl_bman.h b/include/linux/fsl_bman.h
index 4bb5551..021a916 100644
--- a/include/linux/fsl_bman.h
+++ b/include/linux/fsl_bman.h
@@ -107,7 +107,7 @@ static inline dma_addr_t bm_buf_addr(const struct bm_buffer *buf)
 	return (dma_addr_t)buf->addr;
 }
 /* Macro, so we compile better if 'v' isn't always 64-bit */
-/* Note: this first version is causing a noticable performance degradation,
+/* Note: this first version is causing a noticeable performance degradation,
  * which needs analysis, so leaving it commented out for now. The second version
  * achieves optimal performance. */
 #if 0
@@ -164,8 +164,8 @@ struct bm_mc_command {
 #define BM_MCC_VERB_CMD_QUERY		0x40
 #define BM_MCC_VERB_ACQUIRE_BUFCOUNT	0x0f	/* values 1..8 go here */
 
-/* See 1.5.3.3: "Acquire Reponse" */
-/* See 1.5.3.4: "Query Reponse" */
+/* See 1.5.3.3: "Acquire Response" */
+/* See 1.5.3.4: "Query Response" */
 struct bm_pool_state {
 	u8 __reserved1[32];
 	/* "availability state" and "depletion state" */
@@ -486,7 +486,7 @@ int bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs, u8 num,
  * @flags: bit-mask of BMAN_RELEASE_FLAG_*** options
  *
  * Adds stockpile buffers to RCR entries until the stockpile is empty.
- * The return value will be a negative error code if a h/w error occured.
+ * The return value will be a negative error code if a h/w error occurred.
  * If BMAN_RELEASE_FLAG_NOW flag is passed and RCR ring is full,
  * -EAGAIN will be returned.
  */
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index f306c4b..d78a3b1b 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -2735,8 +2735,8 @@ int qman_ceetm_lni_get_excess_rate(struct qm_ceetm_lni *lni,
  * of range as indicated above, or -EIO if the configure/query tcfcc command
  * returns error.
  *
- * Refer to the section of QMan CEETM traffic class flow control in the Refernce
- * Manual.
+ * Refer to the section of QMan CEETM traffic class flow control in the
+ * Reference Manual.
  */
 int qman_ceetm_lni_set_tcfcc(struct qm_ceetm_lni *lni,
 			     unsigned int cq_level,
-- 
1.9.1

