From 39cb621e52fe1c3c80891892b64ce0e51ac18fc5 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Mon, 31 Mar 2014 15:12:07 -0400
Subject: [PATCH 632/987] Reduce reference count of DMA memory fragments during
 unmap

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

If a process explictly unmapped DMA fragments the reference
count of each fragement wasn't properly decremented causing
a leak.  This would only occur if the proccess explicitly
umapped the memory, exiting the process did correctly adjust
the reference counts

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: Ia9adfccd5249d17d5506796b1fe71c32f46cab30
Reviewed-on: http://git.am.freescale.net:8181/10527
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 021dff8..5e8e416 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -1008,7 +1008,8 @@ static long ioctl_dma_unmap(struct ctx *ctx, void __user *arg)
 {
 	struct mem_mapping *map;
 	struct vm_area_struct *vma;
-	int ret;
+	int ret, i;
+	struct mem_fragment *current_frag;
 
 	down_write(&current->mm->mmap_sem);
 	vma = find_vma(current->mm, (unsigned long)arg);
@@ -1030,6 +1031,13 @@ static long ioctl_dma_unmap(struct ctx *ctx, void __user *arg)
 	}
 	map = NULL;
 map_match:
+	current_frag = map->root_frag;
+	for (i = 0; i < map->frag_count; i++) {
+		DPA_ASSERT(current_frag->refs > 0);
+		--current_frag->refs;
+		current_frag = list_entry(current_frag->list.prev,
+					  struct mem_fragment, list);
+	}
 	list_del(&map->list);
 	compress_frags();
 	spin_unlock(&mem_lock);
-- 
1.9.1

