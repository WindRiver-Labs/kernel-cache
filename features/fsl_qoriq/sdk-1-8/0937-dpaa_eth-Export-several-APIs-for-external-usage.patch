From dfef6c8cb1595023c8a3d277c39a5df8ebf09819 Mon Sep 17 00:00:00 2001
From: Cristian Sovaiala <cristian.sovaiala@freescale.com>
Date: Fri, 27 Mar 2015 15:13:21 +0200
Subject: [PATCH 937/987] dpaa_eth: Export several APIs for external usage

Some APIs can be used by other DPAA drivers (such as MACsec driver)
which hook into the processing path of the DPAA Ethernet driver therefore we
export those APIs for external usage.

Signed-off-by: Camelia Groza <camelia.groza@freescale.com>
Signed-off-by: Andrei Vasiliu <andrei.vasiliu@freescale.com>
Signed-off-by: Iulia Manda <manda.iulia@freescale.com>
Signed-off-by: Cristian Sovaiala <cristian.sovaiala@freescale.com>
Change-Id: I312d281002a047d05b9471ecf4ea12c36b28c6b0
Reviewed-on: http://git.am.freescale.net:8181/33831
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Tested-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      | 13 ++++----
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      | 33 +++++++++++++++++++
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   |  4 ++-
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c   | 38 +++++++---------------
 4 files changed, 55 insertions(+), 33 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index c439785..3c737ac 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -411,7 +411,7 @@ static void __hot _dpa_tx_conf(struct net_device	*net_dev,
 	dev_kfree_skb(skb);
 }
 
-static enum qman_cb_dqrr_result
+enum qman_cb_dqrr_result
 priv_rx_error_dqrr(struct qman_portal		*portal,
 		      struct qman_fq			*fq,
 		      const struct qm_dqrr_entry	*dq)
@@ -443,7 +443,7 @@ priv_rx_error_dqrr(struct qman_portal		*portal,
 }
 
 
-static enum qman_cb_dqrr_result __hot
+enum qman_cb_dqrr_result __hot
 priv_rx_default_dqrr(struct qman_portal		*portal,
 			struct qman_fq			*fq,
 			const struct qm_dqrr_entry	*dq)
@@ -483,7 +483,7 @@ priv_rx_default_dqrr(struct qman_portal		*portal,
 	return qman_cb_dqrr_consume;
 }
 
-static enum qman_cb_dqrr_result
+enum qman_cb_dqrr_result
 priv_tx_conf_error_dqrr(struct qman_portal		*portal,
 		      struct qman_fq			*fq,
 		      const struct qm_dqrr_entry	*dq)
@@ -505,7 +505,7 @@ priv_tx_conf_error_dqrr(struct qman_portal		*portal,
 	return qman_cb_dqrr_consume;
 }
 
-static enum qman_cb_dqrr_result __hot
+enum qman_cb_dqrr_result __hot
 priv_tx_conf_default_dqrr(struct qman_portal		*portal,
 			struct qman_fq			*fq,
 			const struct qm_dqrr_entry	*dq)
@@ -531,7 +531,7 @@ priv_tx_conf_default_dqrr(struct qman_portal		*portal,
 	return qman_cb_dqrr_consume;
 }
 
-static void priv_ern(struct qman_portal	*portal,
+void priv_ern(struct qman_portal	*portal,
 		       struct qman_fq		*fq,
 		       const struct qm_mr_entry	*msg)
 {
@@ -563,13 +563,14 @@ static void priv_ern(struct qman_portal	*portal,
 	dev_kfree_skb_any(skb);
 }
 
-static const struct dpa_fq_cbs_t private_fq_cbs = {
+const struct dpa_fq_cbs_t private_fq_cbs = {
 	.rx_defq = { .cb = { .dqrr = priv_rx_default_dqrr } },
 	.tx_defq = { .cb = { .dqrr = priv_tx_conf_default_dqrr } },
 	.rx_errq = { .cb = { .dqrr = priv_rx_error_dqrr } },
 	.tx_errq = { .cb = { .dqrr = priv_tx_conf_error_dqrr } },
 	.egress_ern = { .cb = { .ern = priv_ern } }
 };
+EXPORT_SYMBOL(private_fq_cbs);
 
 static void dpaa_eth_napi_enable(struct dpa_priv_s *priv)
 {
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 477e22e..dbadc3d 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -187,6 +187,25 @@ struct dpa_buffer_layout_s {
 
 #define DPAA_ETH_RX_QUEUES	128
 
+/* Convenience macros for storing/retrieving the skb back-pointers. They must
+ * accommodate both recycling and confirmation paths - i.e. cases when the buf
+ * was allocated by ourselves, respectively by the stack. In the former case,
+ * we could store the skb at negative offset; in the latter case, we can't,
+ * so we'll use 0 as offset.
+ *
+ * NB: @off is an offset from a (struct sk_buff **) pointer!
+ */
+#define DPA_WRITE_SKB_PTR(skb, skbh, addr, off) \
+{ \
+	skbh = (struct sk_buff **)addr; \
+	*(skbh + (off)) = skb; \
+}
+#define DPA_READ_SKB_PTR(skb, skbh, addr, off) \
+{ \
+	skbh = (struct sk_buff **)addr; \
+	skb = *(skbh + (off)); \
+}
+
 #ifdef CONFIG_PM
 /* Magic Packet wakeup */
 #define DPAA_WOL_MAGIC		0x00000001
@@ -413,6 +432,20 @@ void __hot _dpa_process_parse_results(const fm_prs_result_t *parse_results,
 				      const struct qm_fd *fd,
 				      struct sk_buff *skb,
 				      int *use_gro);
+#ifndef CONFIG_FSL_DPAA_TS
+bool dpa_skb_is_recyclable(struct sk_buff *skb);
+bool dpa_buf_is_recyclable(struct sk_buff *skb,
+			   uint32_t min_size,
+			   uint16_t min_offset,
+			   unsigned char **new_buf_start);
+#endif
+int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
+			   struct sk_buff *skb, struct qm_fd *fd,
+			   int *count_ptr, int *offset);
+int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
+		       struct sk_buff *skb, struct qm_fd *fd);
+int __cold __attribute__((nonnull))
+	_dpa_fq_free(struct device *dev, struct qman_fq *fq);
 
 /* Turn on HW checksum computation for this outgoing frame.
  * If the current protocol is not something we support in this regard
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index ba721a0..4f6fe65 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -88,6 +88,7 @@ static const char fsl_qman_frame_queues[][25] = {
 #ifdef CONFIG_FSL_DPAA_HOOKS
 /* A set of callbacks for hooking into the fastpath at different points. */
 struct dpaa_eth_hooks_s dpaa_eth_hooks;
+EXPORT_SYMBOL(dpaa_eth_hooks);
 /* This function should only be called on the probe paths, since it makes no
  * effort to guarantee consistency of the destination hooks structure.
  */
@@ -1393,7 +1394,7 @@ int dpa_fq_init(struct dpa_fq *dpa_fq, bool td_enable)
 }
 EXPORT_SYMBOL(dpa_fq_init);
 
-static int __cold __attribute__((nonnull))
+int __cold __attribute__((nonnull))
 _dpa_fq_free(struct device *dev, struct qman_fq *fq)
 {
 	int			 _errno, __errno;
@@ -1425,6 +1426,7 @@ _dpa_fq_free(struct device *dev, struct qman_fq *fq)
 
 	return _errno;
 }
+EXPORT_SYMBOL(_dpa_fq_free);
 
 int __cold __attribute__((nonnull))
 dpa_fq_free(struct device *dev, struct list_head *list)
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 4554c90..8a1739c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -49,25 +49,6 @@
 #include "dpaa_1588.h"
 #endif
 
-/* Convenience macros for storing/retrieving the skb back-pointers. They must
- * accommodate both recycling and confirmation paths - i.e. cases when the buf
- * was allocated by ourselves, respectively by the stack. In the former case,
- * we could store the skb at negative offset; in the latter case, we can't,
- * so we'll use 0 as offset.
- *
- * NB: @off is an offset from a (struct sk_buff **) pointer!
- */
-#define DPA_WRITE_SKB_PTR(skb, skbh, addr, off) \
-	{ \
-		skbh = (struct sk_buff **)addr; \
-		*(skbh + (off)) = skb; \
-	}
-#define DPA_READ_SKB_PTR(skb, skbh, addr, off) \
-	{ \
-		skbh = (struct sk_buff **)addr; \
-		skb = *(skbh + (off)); \
-	}
-
 /* DMA map and add a page frag back into the bpool.
  * @vaddr fragment must have been allocated with netdev_alloc_frag(),
  * specifically for fitting into @dpa_bp.
@@ -303,9 +284,10 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 	return skb;
 }
+EXPORT_SYMBOL(_dpa_cleanup_tx_fd);
 
 #ifndef CONFIG_FSL_DPAA_TS
-static bool dpa_skb_is_recyclable(struct sk_buff *skb)
+bool dpa_skb_is_recyclable(struct sk_buff *skb)
 {
 	/* No recycling possible if skb buffer is kmalloc'ed  */
 	if (skb->head_frag == 0)
@@ -322,8 +304,9 @@ static bool dpa_skb_is_recyclable(struct sk_buff *skb)
 
 	return true;
 }
+EXPORT_SYMBOL(dpa_skb_is_recyclable);
 
-static bool dpa_buf_is_recyclable(struct sk_buff *skb,
+bool dpa_buf_is_recyclable(struct sk_buff *skb,
 				  uint32_t min_size,
 				  uint16_t min_offset,
 				  unsigned char **new_buf_start)
@@ -352,6 +335,7 @@ static bool dpa_buf_is_recyclable(struct sk_buff *skb,
 
 	return false;
 }
+EXPORT_SYMBOL(dpa_buf_is_recyclable);
 #endif
 
 /* Build a linear skb around the received buffer.
@@ -652,9 +636,9 @@ _release_frame:
 	dpa_fd_release(net_dev, fd);
 }
 
-static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
-				  struct sk_buff *skb, struct qm_fd *fd,
-				  int *count_ptr, int *offset)
+int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
+			   struct sk_buff *skb, struct qm_fd *fd,
+			   int *count_ptr, int *offset)
 {
 	struct sk_buff **skbh;
 	dma_addr_t addr;
@@ -738,9 +722,10 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 
 	return 0;
 }
+EXPORT_SYMBOL(skb_to_contig_fd);
 
-static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
-			      struct sk_buff *skb, struct qm_fd *fd)
+int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
+		       struct sk_buff *skb, struct qm_fd *fd)
 {
 	struct dpa_bp *dpa_bp = priv->dpa_bp;
 	dma_addr_t addr;
@@ -855,6 +840,7 @@ csum_failed:
 
 	return err;
 }
+EXPORT_SYMBOL(skb_to_sg_fd);
 
 int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 {
-- 
1.9.1

