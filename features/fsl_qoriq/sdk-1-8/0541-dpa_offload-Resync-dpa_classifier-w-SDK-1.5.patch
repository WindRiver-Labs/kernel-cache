From 942183dd0d4577f0a81e488bb0bfdedb759a6c5e Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 11 Feb 2014 11:52:30 +0200
Subject: [PATCH 541/987] dpa_offload: Resync dpa_classifier w/ SDK 1.5

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Updated the dpa_classifier component to bring it to the version
delivered with SDK 1.5.

Change-Id: I0bfad6dd46c64d55517de58def73525dc7714d07
Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/8716
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Andrei Varvara <andrei.varvara@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   | 540 ++++++++++++++-------
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |   2 +-
 include/linux/fsl_dpa_classifier.h                 |   5 +-
 3 files changed, 381 insertions(+), 166 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 5f7c7f7..e4610d4 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -605,12 +605,11 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 	LOCK_OBJECT(table_array, td, ptable, -EINVAL);
 
 	/* Check for unsupported modifications */
-	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
-		(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
+	if (ptable->params.type == DPA_CLS_TBL_INDEXED && mod_params->type !=
+			DPA_CLS_TBL_MODIFY_ACTION) {
 		RELEASE_OBJECT(ptable);
-		log_err("Modify entry key is supported only on exact match "
-			"tables. You attempted to use it on table td=%d which "
-			"is of type=%d.\n", td, ptable->params.type);
+		log_err("Modify entry key is supported only on exact match and hash tables. You attempted to use it on table td=%d which is of type=%d.\n",
+			td, ptable->params.type);
 		return -ENOSYS;
 	}
 
@@ -709,26 +708,22 @@ int dpa_classif_table_modify_entry_by_key(int			td,
 						DPA_CLS_TBL_EXACT_MATCH);
 				/* Parameter sanity check: */
 				if (!mod_params->action) {
-					log_err("\"mod_params->action\" cannot "
-						"be NULL.\n");
+					log_err("\"mod_params->action\" cannot be NULL.\n");
 					return -EINVAL;
 				}
 
 				ret = action_to_next_engine_params(
-					mod_params->action,
-					&key_params.ccNextEngineParams,
-					NULL,
-					(t_Handle)ptable->params.
+						mod_params->action,
+						&key_params.ccNextEngineParams,
+						NULL,
+						(t_Handle)ptable->params.
 						distribution,
-					(t_Handle)ptable->params.
+						(t_Handle)ptable->params.
 						classification);
 				if (ret < 0) {
 					RELEASE_OBJECT(ptable);
-					log_err("Failed verification of new "
-						"action params while modifying "
-						"entry by KEY in table td=%d. "
-						"Lookup key (hex) (%d byte(s)):",
-						td, key->size);
+					log_err("Failed verification of new action params while modifying entry by KEY in table td=%d. Lookup key (hex) (%d byte(s)):",
+							td, key->size);
 					dump_lookup_key(key);
 					pr_err("\n");
 					return ret;
@@ -880,10 +875,9 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 
 	/* Check for unsupported modifications */
 	if ((mod_params->type != DPA_CLS_TBL_MODIFY_ACTION) &&
-			(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH)) {
-		log_err("Modify entry key is supported only on exact match "
-			"tables. You attempted to use it on table td=%d which "
-			"is of type=%d.\n", td, ptable->params.type);
+			(ptable->params.type == DPA_CLS_TBL_INDEXED)) {
+		log_err("Modify entry key is supported only on exact match and hash tables. You attempted to use it on table td=%d which is of type=%d.\n",
+				td, ptable->params.type);
 		return -ENOSYS;
 	}
 
@@ -900,11 +894,193 @@ int dpa_classif_table_modify_entry_by_ref(int			td,
 }
 EXPORT_SYMBOL(dpa_classif_table_modify_entry_by_ref);
 
+static int hash_table_modify_entry(
+		struct dpa_cls_table *ptable,
+		int entry_id,
+		const struct dpa_offload_lookup_key *key,
+		struct dpa_cls_tbl_action *action)
+{
+	int hmd, errno;
+	unsigned int cc_node_index;
+	uint8_t entry_index;
+	u64 hash_set_index;
+	t_Error err;
+
+	t_Handle cc_node;
+	struct list_head *shadow_list_entry;
+	t_FmPcdCcKeyParams key_params;
+
+	struct dpa_cls_tbl_shadow_entry *shadow_entry;
+	struct dpa_cls_tbl_action *local_action;
+
+	hash_set_index = crc64_ecma_seed();
+	hash_set_index = crc64_ecma(key->byte,
+			ptable->params.hash_params.key_size,
+			hash_set_index);
+	hash_set_index =
+			(u64)(hash_set_index & ptable->hash_mask) >>
+			(8 * (6 - ptable->params.hash_params.hash_offs) + 4);
+
+	/*
+	 * Check if there are entries still available in the
+	 * selected set
+	 */
+	if (ptable->int_cc_node[hash_set_index].used >=
+			ptable->int_cc_node[hash_set_index].table_size) {
+		log_err("Hash set #%llu is full (%d entries). Unable to modify this entry.\n",
+				hash_set_index,
+				ptable->int_cc_node[hash_set_index].table_size);
+		return -ENOSPC;
+	}
+
+	memset(&key_params, 0, sizeof(t_FmPcdCcKeyParams));
+
+	cc_node_index =
+			ptable->entry[entry_id].int_cc_node_index;
+	entry_index = ptable->entry[entry_id].entry_index;
+
+	cc_node =
+			(t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
+
+	if (!action) {
+		/* Save action to next engine params */
+		if (ptable->shadow_table) {
+			shadow_list_entry =
+					ptable->entry[entry_id].shadow_entry;
+			shadow_entry = list_entry(shadow_list_entry,
+					struct dpa_cls_tbl_shadow_entry,
+					list_node);
+			local_action	= &shadow_entry->action;
+			dpa_classif_hm_release_chain(
+					ptable->entry[entry_id].hmd);
+			errno = action_to_next_engine_params(
+				local_action,
+				&key_params.ccNextEngineParams,
+				&hmd,
+				(t_Handle)ptable->params.distribution,
+				(t_Handle)ptable->params.classification);
+			if (errno < 0)
+				return errno;
+		} else {
+			err = FM_PCD_MatchTableGetNextEngine(
+					cc_node,
+					entry_index,
+					&key_params.ccNextEngineParams);
+			if (err)
+				return -err;
+
+			hmd = ptable->entry[entry_id].hmd;
+		}
+	} else {
+		/*
+		 * Release old header manip chain if available and save
+		 * the action
+		 */
+		dpa_classif_hm_release_chain(
+				ptable->entry[entry_id].hmd);
+		errno = action_to_next_engine_params(
+				action,
+				&key_params.ccNextEngineParams,
+				&hmd,
+				(t_Handle)ptable->params.distribution,
+				(t_Handle)ptable->params.classification);
+		if (errno < 0)
+			return errno;
+	}
+
+	if (hash_set_index != ptable->entry[entry_id].int_cc_node_index) {
+		BUG_ON(hash_set_index >= ptable->int_cc_nodes_count);
+		key_params.p_Key = key->byte;
+
+		/* Remove the key */
+		err = FM_PCD_MatchTableRemoveKey(cc_node, entry_index);
+		if (err != E_OK) {
+			log_err("FMan driver call failed - FM_PCD_MatchTableRemoveKey. Entry ref=%d, Cc node handle=0x%p, entry index=%d.\n",
+					entry_id, cc_node, entry_index);
+			return -EBUSY;
+		}
+	ptable->int_cc_node[ptable->entry[entry_id].int_cc_node_index].used--;
+
+		/* Insert the new key */
+		ptable->entry[entry_id].int_cc_node_index =
+				(unsigned int)hash_set_index;
+		ptable->entry[entry_id].entry_index =
+			(uint8_t)ptable->int_cc_node[hash_set_index].used;
+
+		/* Add the key to the selected Cc node */
+		err = FM_PCD_MatchTableAddKey((t_Handle)ptable->
+				int_cc_node[hash_set_index].cc_node,
+				ptable->entry[entry_id].entry_index,
+				ptable->params.hash_params.key_size,
+				&key_params);
+		if (err != E_OK) {
+			log_err("FMan driver call failed - FM_PCD_MatchTableAddKey. Entry ref=%d, HASH set=%llu, Cc node handle=0x%p, entry index=%d.\n",
+				entry_id, hash_set_index,
+				ptable->int_cc_node[hash_set_index].cc_node,
+				ptable->entry[entry_id].entry_index);
+			return -EBUSY;
+		}
+
+		ptable->int_cc_node[hash_set_index].used++;
+	} else {
+		if (!action) {
+			err = FM_PCD_MatchTableModifyKey((t_Handle)ptable->
+					int_cc_node[hash_set_index].cc_node,
+					ptable->entry[entry_id].entry_index,
+					ptable->params.hash_params.key_size,
+					key->mask, key->mask);
+			if (err != E_OK) {
+				log_err("FMan driver call failed - FM_PCD_MatchTableModifyKey. Entry ref=%d, HASH set=%llu, Cc node handle=0x%p, entry index=%d.\n",
+				entry_id, hash_set_index,
+				ptable->int_cc_node[hash_set_index].cc_node,
+				ptable->entry[entry_id].entry_index);
+				return -EBUSY;
+			}
+		} else {
+			err = FM_PCD_MatchTableModifyKeyAndNextEngine(
+			(t_Handle)ptable->int_cc_node[hash_set_index].cc_node,
+			ptable->entry[entry_id].entry_index,
+			ptable->params.hash_params.key_size,
+			&key_params);
+			if (err != E_OK) {
+				log_err("FMan driver call failed - FM_PCD_MatchTableModifyKeyAndNextEngine. Entry ref=%d, HASH set=%llu, Cc node handle=0x%p, entry index=%d.\n",
+				entry_id, hash_set_index,
+				ptable->int_cc_node[hash_set_index].cc_node,
+				ptable->entry[entry_id].entry_index);
+				return -EBUSY;
+			}
+		}
+	}
+	return E_OK;
+}
+
+static int hash_table_check_key(struct dpa_cls_table *ptable,
+		const struct dpa_offload_lookup_key *key)
+{
+	int i = 0;
+	if (key->size !=
+			ptable->params.hash_params.key_size) {
+		log_err("New key size (%d bytes) doesn't match the table key size (%d bytes).\n",
+				key->size,
+				ptable->params.hash_params.key_size);
+		return -EINVAL;
+	}
+	if (key->mask) {
+		/* Only full 0xFF masks supported: */
+		for (i = 0; i < key->size; i++)
+			if (key->mask[i] ^ 0xff) {
+				log_err("Only key masks 0xff all over are supported by HASH tables.\n");
+				return -EINVAL;
+			}
+	}
+	return E_OK;
+}
+
 static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		int						entry_id,
 		const struct dpa_cls_tbl_entry_mod_params	*mod_params)
 {
-	struct dpa_cls_tbl_shadow_entry *shadow_entry;
+	struct dpa_cls_tbl_shadow_entry *shadow_entry = NULL;
 	struct dpa_cls_tbl_shadow_entry_indexed *shadow_entry_indexed;
 	struct dpa_cls_tbl_action *action;
 	struct dpa_offload_lookup_key *key;
@@ -950,8 +1126,8 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 	}
 
 	cc_node	= (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
-	switch (mod_params->type) {
-	case DPA_CLS_TBL_MODIFY_ACTION:
+
+	if (mod_params->type == DPA_CLS_TBL_MODIFY_ACTION) {
 		/* Parameter sanity check: */
 		if (!mod_params->action) {
 			log_err("\"mod_params->action\" cannot be NULL.\n");
@@ -961,12 +1137,10 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 		/* Release old header manip chain if available */
 		dpa_classif_hm_release_chain(ptable->entry[entry_id].hmd);
 		errno = action_to_next_engine_params(mod_params->action,
-					&next_engine_params,
-					&ptable->entry[entry_id].hmd,
-					(t_Handle)ptable->params.
-						distribution,
-					(t_Handle)ptable->params.
-						classification);
+				&next_engine_params,
+				&ptable->entry[entry_id].hmd,
+				(t_Handle)ptable->params.distribution,
+				(t_Handle)ptable->params.classification);
 		if (errno < 0)
 			return errno;
 
@@ -974,139 +1148,170 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 						entry_index,
 						&next_engine_params);
 		if (err != E_OK) {
-			log_err("FMan driver call failed - "
-				"FM_PCD_MatchTableModifyNextEngine. Entry "
-				"ref=%d, Cc node handle=0x%p, entry index=%d.\n",
-				entry_id, cc_node, entry_index);
+			log_err("FMan driver call failed - FM_PCD_MatchTableModifyNextEngine. Entry ref=%d, Cc node handle=0x%p, entry index=%d.\n",
+					entry_id, cc_node, entry_index);
 			return -EBUSY;
 		}
-
-		break;
-	case DPA_CLS_TBL_MODIFY_KEY:
-		/* Only exact match tables support this type of modification. */
-		BUG_ON(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH);
+	} else {
+		/*
+		 * Only exact match and hash tables support this type of
+		 * modification.
+		 */
+		BUG_ON(ptable->params.type == DPA_CLS_TBL_INDEXED);
 
 		/* Parameters sanity checks: */
 		if (!mod_params->key) {
 			log_err("\"mod_params->key\" cannot be NULL.\n");
 			return -EINVAL;
 		}
-		if (mod_params->key->size !=
-			ptable->params.exact_match_params.key_size) {
-			log_err("New key size (%d bytes) doesn't match the "
-				"table key size (%d bytes).\n",
-				mod_params->key->size,
-				ptable->params.exact_match_params.key_size);
-			return -EINVAL;
-		}
 
 		/*
-		 * Have to copy the data from the key and mask because the FMD
-		 * is not using const pointers and we cannot provide it the
-		 * const pointers that the user provided.
+		 * Have to copy the data from the key and mask because
+		 * the FMD is not using const pointers and we cannot
+		 * provide it the const pointers that the user provided.
 		 */
 		memset(&key_params, 0, sizeof(key_params));
-		memcpy(key_data,
-			mod_params->key->byte,
-			mod_params->key->size);
+		memcpy(key_data, mod_params->key->byte, mod_params->key->size);
 		key_params.p_Key = key_data;
-		if (mod_params->key->mask) {
-			memcpy(mask_data,
-				mod_params->key->mask,
-				mod_params->key->size);
-			key_params.p_Mask = mask_data;
-		}
-
-		err = FM_PCD_MatchTableModifyKey(cc_node,
-				entry_index,
-				ptable->params.exact_match_params.key_size,
-				key_params.p_Key,
-				key_params.p_Mask);
-		if (err != E_OK) {
-			log_err("FMan driver call failed - "
-				"FM_PCD_MatchTableModifyKey. Entry ref=%d, Cc "
-				"node handle=0x%p, entry index=%d.\n", entry_id,
-				cc_node, entry_index);
-			return -EBUSY;
-		}
-
-		break;
-	case DPA_CLS_TBL_MODIFY_KEY_AND_ACTION:
-		/* Only exact match tables support this type of modification. */
-		BUG_ON(ptable->params.type != DPA_CLS_TBL_EXACT_MATCH);
-
-		/* Parameters sanity checks: */
-		if (!mod_params->key) {
-			log_err("\"mod_params->key\" cannot be NULL.\n");
-			return -EINVAL;
-		}
-		if (!mod_params->action) {
-			log_err("\"mod_params->action\" cannot be NULL.\n");
-			return -EINVAL;
-		}
-		if (mod_params->key->size !=
-			ptable->params.exact_match_params.key_size) {
-			log_err("New key size (%d bytes) doesn't match the "
-				"table key size (%d bytes).\n",
-				mod_params->key->size,
-				ptable->params.exact_match_params.key_size);
-			return -EINVAL;
-		}
 
-		memset(&key_params, 0, sizeof(key_params));
-
-		/* Release old header manip chain if available */
-		dpa_classif_hm_release_chain(ptable->entry[entry_id].hmd);
-		errno = action_to_next_engine_params(mod_params->action,
-					&key_params.ccNextEngineParams,
-					&ptable->entry[entry_id].hmd,
-					(t_Handle)ptable->params.
-						distribution,
-					(t_Handle)ptable->params.
-						classification);
-		if (errno < 0)
-			return errno;
+		switch (mod_params->type) {
+		case DPA_CLS_TBL_MODIFY_ACTION:
+			break;
+		case DPA_CLS_TBL_MODIFY_KEY:
+			switch (ptable->params.type) {
+			case DPA_CLS_TBL_EXACT_MATCH:
+				key_size =
+				ptable->params.exact_match_params.key_size;
+				if (mod_params->key->size != key_size) {
+					log_err("New key size (%d bytes) doesn't match the table key size (%d bytes).\n",
+							mod_params->key->size,
+							key_size);
+					return -EINVAL;
+				}
+				if (mod_params->key->mask) {
+					memcpy(mask_data, mod_params->key->mask,
+							mod_params->key->size);
+					key_params.p_Mask = mask_data;
+				}
+				err = FM_PCD_MatchTableModifyKey(cc_node,
+							entry_index,
+							key_size,
+							key_params.p_Key,
+							key_params.p_Mask);
+				if (err != E_OK) {
+					log_err("FMan driver call failed - FM_PCD_MatchTableModifyKey. Entry ref=%d, Cc node handle=0x%p, entry index=%d.\n",
+						entry_id, cc_node, entry_index);
+					return -EBUSY;
+				}
+				break;
+			case DPA_CLS_TBL_HASH:
+				/* Check the key parameter */
+				err = hash_table_check_key(ptable,
+							mod_params->key);
+				if (err)
+					return err;
+				err = hash_table_modify_entry(ptable,
+							entry_id,
+							mod_params->key,
+							NULL);
+				if (err)
+					return err;
+				break;
+			case DPA_CLS_TBL_INDEXED:
+				break;
+			}
 
-		/*
-		 * Have to copy the data from the key and mask because the FMD
-		 * is not using const pointers and we cannot provide it the
-		 * const pointers that the user provided.
-		 */
-		memcpy(key_data,
-			mod_params->key->byte,
-			mod_params->key->size);
-		key_params.p_Key = key_data;
-		if (mod_params->key->mask) {
-			memcpy(mask_data,
-				mod_params->key->mask,
-				mod_params->key->size);
-			key_params.p_Mask = mask_data;
-		}
+			break;
+		case DPA_CLS_TBL_MODIFY_KEY_AND_ACTION:
+				/* Parameter sanity checks */
+				if (!mod_params->action) {
+					log_err("\"mod_params->action\" cannot be NULL.\n");
+					return -EINVAL;
+				}
 
-		err = FM_PCD_MatchTableModifyKeyAndNextEngine(cc_node,
-				entry_index,
-				ptable->params.exact_match_params.key_size,
-				&key_params);
-		if (err != E_OK) {
-			log_err("FMan driver call failed - "
-				"FM_PCD_MatchTableModifyKeyAndNextEngine. "
-				"Entry ref=%d, Cc node handle=0x%p, entry "
-				"index=%d.\n", entry_id, cc_node, entry_index);
-			return -EBUSY;
+				switch (ptable->params.type) {
+				case DPA_CLS_TBL_EXACT_MATCH:
+					key_size =
+				ptable->params.exact_match_params.key_size;
+					if (mod_params->key->size != key_size) {
+						log_err("New key size (%d bytes) doesn't match the table key size (%d bytes).\n",
+							mod_params->key->size,
+							key_size);
+						return -EINVAL;
+					}
+					/*
+					 * Have to copy the data from the key
+					 * and mask because the FMD is not
+					 * using const pointers and we cannot
+					 * provide it the const pointers that
+					 * the user provided.
+					 */
+					if (mod_params->key->mask) {
+						memcpy(mask_data,
+							mod_params->key->mask,
+							mod_params->key->size);
+						key_params.p_Mask = mask_data;
+					}
+					/*
+					 * Release old header manip chain
+					 * if available
+					 */
+					dpa_classif_hm_release_chain(
+						ptable->entry[entry_id].hmd);
+					errno = action_to_next_engine_params(
+						mod_params->action,
+						&key_params.ccNextEngineParams,
+						&ptable->entry[entry_id].hmd,
+						(t_Handle)ptable->
+						params.distribution,
+						(t_Handle)ptable->
+						params.classification);
+					if (errno < 0)
+						return errno;
+					err =
+					FM_PCD_MatchTableModifyKeyAndNextEngine(
+								cc_node,
+								entry_index,
+								key_size,
+								&key_params);
+					if (err != E_OK) {
+						log_err("FMan driver call failed - FM_PCD_MatchTableModifyKeyAndNextEngine. Entry ref=%d, Cc node handle=0x%p, entry index=%d.\n",
+								entry_id,
+								cc_node,
+								entry_index);
+						return -EBUSY;
+					}
+					break;
+				case DPA_CLS_TBL_HASH:
+					/* Check the key parameter */
+					err = hash_table_check_key(ptable,
+							mod_params->key);
+					if (err)
+						return err;
+					err = hash_table_modify_entry(
+							ptable,
+							entry_id,
+							mod_params->key,
+							mod_params->action);
+					if (err)
+						return err;
+					break;
+				case DPA_CLS_TBL_INDEXED:
+					break;
+				}
+				break;
 		}
-
-		break;
 	}
 
 	/* If a shadow table exists, update the data in the shadow table */
 	if (ptable->shadow_table) {
 		if (ptable->params.type == DPA_CLS_TBL_INDEXED) {
 			shadow_list_entry =
-				ptable->shadow_table->
+					ptable->shadow_table->
 					shadow_entry[entry_index].next;
 			shadow_entry_indexed = list_entry(shadow_list_entry,
-				struct dpa_cls_tbl_shadow_entry_indexed,
-				list_node);
+					struct dpa_cls_tbl_shadow_entry_indexed,
+					list_node);
 
 			action	= &shadow_entry_indexed->action;
 		} else {
@@ -1119,46 +1324,42 @@ static int table_modify_entry_by_ref(struct dpa_cls_table	*ptable,
 			key	= &shadow_entry->key;
 			action	= &shadow_entry->action;
 
-			if ((mod_params->type == DPA_CLS_TBL_MODIFY_KEY) ||
-				(mod_params->type ==
-					DPA_CLS_TBL_MODIFY_KEY_AND_ACTION)) {
+			if (mod_params->type == DPA_CLS_TBL_MODIFY_KEY ||
+			mod_params->type == DPA_CLS_TBL_MODIFY_KEY_AND_ACTION) {
 				/*
 				 * The entry needs to be re-hashed with the new
 				 * key
 				 */
-			key_size = ptable->params.exact_match_params.key_size;
+				key_size =
+				ptable->params.exact_match_params.key_size;
 				key_apply_mask(mod_params->key,
 						masked_key);
 				shadow_table_index = crc8(crc8_table,
-							masked_key,
-							key_size,
-							0);
+						masked_key,
+						key_size,
+						0);
 
 				new_bucket_list =
 			&ptable->shadow_table->shadow_entry[shadow_table_index];
 				list_del(&shadow_entry->list_node);
 				list_add(&shadow_entry->list_node,
-						new_bucket_list);
+							new_bucket_list);
 			}
 
-			if ((mod_params->type == DPA_CLS_TBL_MODIFY_KEY) ||
-				(mod_params->type ==
-					DPA_CLS_TBL_MODIFY_KEY_AND_ACTION)) {
-				memcpy(key->byte,
-					mod_params->key->byte,
-					key->size);
+			if (mod_params->type == DPA_CLS_TBL_MODIFY_KEY ||
+			mod_params->type == DPA_CLS_TBL_MODIFY_KEY_AND_ACTION) {
+				memcpy(key->byte, mod_params->key->byte,
+								key->size);
 				if ((key->mask) && (mod_params->key->mask))
-					memcpy(key->mask,
-						mod_params->key->mask,
-						key->size);
+					memcpy(key->mask, mod_params->key->mask,
+								key->size);
 			}
 		}
 
-		if ((mod_params->type == DPA_CLS_TBL_MODIFY_ACTION) ||
-			(mod_params->type == DPA_CLS_TBL_MODIFY_KEY_AND_ACTION))
-			memcpy(action,
-				mod_params->action,
-				sizeof(struct dpa_cls_tbl_action));
+		if (mod_params->type == DPA_CLS_TBL_MODIFY_ACTION ||
+			mod_params->type == DPA_CLS_TBL_MODIFY_KEY_AND_ACTION)
+			memcpy(action, mod_params->action,
+					sizeof(struct dpa_cls_tbl_action));
 	}
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
@@ -1803,6 +2004,9 @@ static int table_get_entry_stats_by_ref(struct dpa_cls_table	*ptable,
 	uint8_t entry_index;
 	t_Handle cc_node;
 	struct dpa_cls_tbl_entry *index_entry;
+	t_FmPcdCcKeyStatistics key_stats;
+	t_Error err;
+	int ret = 0;
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) -->\n", __func__,
 		__LINE__));
@@ -1830,13 +2034,21 @@ static int table_get_entry_stats_by_ref(struct dpa_cls_table	*ptable,
 	entry_index	= index_entry->entry_index;
 
 	cc_node = (t_Handle)ptable->int_cc_node[cc_node_index].cc_node;
-	stats->total_pkts = (unsigned long)
-		FM_PCD_MatchTableGetKeyCounter(cc_node,	entry_index);
+	err = FM_PCD_MatchTableGetKeyStatistics(cc_node, entry_index,
+								&key_stats);
+	if (err != E_OK) {
+		log_warn("FMan driver call failed - FM_PCD_MatchTableGetKeyStatistics. Failed to acquire key statistics.\n");
+		memset(stats, 0, sizeof(*stats));
+		ret = -EPERM;
+	} else {
+		stats->pkts	= key_stats.frameCount;
+		stats->bytes	= key_stats.byteCount;
+	}
 
 	dpa_cls_dbg(("DEBUG: dpa_classifier %s (%d) <--\n", __func__,
 		__LINE__));
 
-	return 0;
+	return ret;
 }
 
 int dpa_classif_table_get_params(int td, struct dpa_cls_tbl_params *params)
@@ -7273,7 +7485,7 @@ int dpa_classif_mcast_create_group(
 		const struct dpa_cls_mcast_group_resources *res)
 {
 
-	t_Error err = 0;
+	int err = 0;
 	struct dpa_cls_mcast_group *pgroup;
 	int member_id;
 	uint8_t max_members;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index df0fee2..88a157c 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -364,7 +364,7 @@ struct compat_ioc_dpa_cls_hm_vlan_params {
 struct compat_ipv4_header {
 	struct iphdr			header;
 	compat_uptr_t			options;
-	unsigned int			options_size;
+	uint8_t				options_size;
 };
 
 struct dpa_cls_compat_hm_nat_pt_params {
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index 6199aa0..f81909f 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -345,7 +345,10 @@ struct dpa_cls_tbl_entry_mod_params {
 struct dpa_cls_tbl_entry_stats {
 
 	/* The total number of packets that have hit the entry */
-	uint64_t		total_pkts;
+	uint32_t	pkts;
+
+	/* The total number of bytes that have hit the entry */
+	uint32_t	bytes;
 };
 
 
-- 
1.9.1

