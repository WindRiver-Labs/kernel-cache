From 95ca80cb5e23618d81a5c5b764a42eea2f3ec27a Mon Sep 17 00:00:00 2001
From: Prabhakar Kushwaha <prabhakar@freescale.com>
Date: Wed, 19 Mar 2014 11:14:22 +0530
Subject: [PATCH 13/45] powerpc/mpc85xx: Add deep sleep support for IFC

Add support of suspend, resume function to support deep sleep.
Also make sure of SRAM initialization  during resume.

Signed-off-by: Prabhakar Kushwaha <prabhakar@freescale.com>
Change-Id: Ia3d484ff272d6c7feebb74a5ad95f74fb91cdd68
Reviewed-on: http://git.am.freescale.net:8181/9444
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Dongsheng Wang <dongsheng.wang@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
(cherry picked from commit 82a066c3f93441a7e80c1a603ff185ee4d16bf25)
Reviewed-on: http://git.am.freescale.net:8181/9928
[Original patch taken from QorIQ-SDK-V1.8-20150619-yocto, remove the
part for initcall level change since it was already merged.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/memory/fsl_ifc.c |   55 ++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/fsl_ifc.h  |    6 +++++
 2 files changed, 61 insertions(+), 0 deletions(-)

diff --git a/drivers/memory/fsl_ifc.c b/drivers/memory/fsl_ifc.c
index 410c397..5f8c1cd 100644
--- a/drivers/memory/fsl_ifc.c
+++ b/drivers/memory/fsl_ifc.c
@@ -23,6 +23,7 @@
 #include <linux/kernel.h>
 #include <linux/compiler.h>
 #include <linux/spinlock.h>
+#include <linux/delay.h>
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/io.h>
@@ -34,6 +35,8 @@
 
 struct fsl_ifc_ctrl *fsl_ifc_ctrl_dev;
 EXPORT_SYMBOL(fsl_ifc_ctrl_dev);
+#define FSL_IFC_V1_3_0	0x01030000
+#define IFC_TIMEOUT_MSECS	100000 /* 100ms */
 
 /*
  * convert_ifc_address - convert the base address
@@ -291,6 +294,53 @@ err:
 	return ret;
 }
 
+#ifdef CONFIG_PM_SLEEP
+/* save ifc registers */
+static int fsl_ifc_suspend(struct device *dev)
+{
+	struct fsl_ifc_ctrl *ctrl = dev_get_drvdata(dev);
+	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+
+	ctrl->saved_regs = kzalloc(sizeof(struct fsl_ifc_regs), GFP_KERNEL);
+	if (!ctrl->saved_regs)
+		return -ENOMEM;
+
+	_memcpy_fromio(ctrl->saved_regs, ifc, sizeof(struct fsl_ifc_regs));
+
+	return 0;
+}
+
+/* restore ifc registers */
+static int fsl_ifc_resume(struct device *dev)
+{
+	struct fsl_ifc_ctrl *ctrl = dev_get_drvdata(dev);
+	struct fsl_ifc_regs __iomem *ifc = ctrl->regs;
+	uint32_t ver = 0, ncfgr, status;
+
+	if (ctrl->saved_regs) {
+		_memcpy_toio(ifc, ctrl->saved_regs,
+				sizeof(struct fsl_ifc_regs));
+		kfree(ctrl->saved_regs);
+		ctrl->saved_regs = NULL;
+	}
+
+	ver = in_be32(&ctrl->regs->ifc_rev);
+	ncfgr = in_be32(&ifc->ifc_nand.ncfgr);
+	if (ver >= FSL_IFC_V1_3_0) {
+		out_be32(&ifc->ifc_nand.ncfgr, ncfgr | IFC_NAND_SRAM_INIT_EN);
+
+		/* wait for  SRAM_INIT bit to be clear or timeout */
+		status = spin_event_timeout(!(in_be32(&ifc->ifc_nand.ncfgr)
+				   & IFC_NAND_SRAM_INIT_EN),
+				   IFC_TIMEOUT_MSECS, 0);
+		if (!status)
+			dev_err(ctrl->dev, "Timeout waiting for IFC SRAM INIT");
+	}
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
 static const struct of_device_id fsl_ifc_match[] = {
 	{
 		.compatible = "fsl,ifc",
@@ -298,10 +348,15 @@ static const struct of_device_id fsl_ifc_match[] = {
 	{},
 };
 
+static const struct dev_pm_ops ifc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(fsl_ifc_suspend, fsl_ifc_resume)
+};
+
 static struct platform_driver fsl_ifc_ctrl_driver = {
 	.driver = {
 		.name	= "fsl-ifc",
 		.of_match_table = fsl_ifc_match,
+		.pm = &ifc_pm_ops,
 	},
 	.probe       = fsl_ifc_ctrl_probe,
 	.remove      = fsl_ifc_ctrl_remove,
diff --git a/include/linux/fsl_ifc.h b/include/linux/fsl_ifc.h
index bf0321e..8860a09 100644
--- a/include/linux/fsl_ifc.h
+++ b/include/linux/fsl_ifc.h
@@ -270,6 +270,8 @@
  */
 /* Auto Boot Mode */
 #define IFC_NAND_NCFGR_BOOT		0x80000000
+/* SRAM INIT EN */
+#define IFC_NAND_SRAM_INIT_EN		0x20000000
 /* Addressing Mode-ROW0+n/COL0 */
 #define IFC_NAND_NCFGR_ADDR_MODE_RC0	0x00000000
 /* Addressing Mode-ROW0+n/COL0+n */
@@ -841,6 +843,10 @@ struct fsl_ifc_ctrl {
 
 	u32 nand_stat;
 	wait_queue_head_t nand_wait;
+#ifdef CONFIG_PM_SLEEP
+	/* save regs when system go to deep-sleep */
+	struct fsl_ifc_regs		*saved_regs;
+#endif
 };
 
 extern struct fsl_ifc_ctrl *fsl_ifc_ctrl_dev;
-- 
1.7.5.4

