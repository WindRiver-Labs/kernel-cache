From f62624f2231255dff1c3c1c94d8764a6b273c71b Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Thu, 25 Sep 2014 10:19:16 +0800
Subject: [PATCH 718/987] dpaa_eth: Compile dpaa_eth_hooks only for FMan Test

FMan Test are using the dpaa_eth_hooks therefore we
compile the hooks if one of the two are defined.

Signed-off-by: Cristian Sovaiala <cristian.sovaiala@freescale.com>
Change-Id: I620d030fa5131fee7f3854be1eb64c24fab4bc9e
Reviewed-on: http://git.am.freescale.net:8181/6928
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Reviewed-by: Ruxandra Ioana Radulescu <ruxandra.radulescu@freescale.com>
Reviewed-by: Zhenhua Luo <zhenhua.luo@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso
 Remove ASF codes]
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c        | 12 ++++++------
 drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c |  4 ++--
 drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h |  3 ++-
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c     |  6 ++++--
 4 files changed, 14 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index dc3ff8c..a4e37cb 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -255,12 +255,12 @@ static void _dpa_rx_error(struct net_device *net_dev,
 		if (netif_msg_hw(priv) && net_ratelimit())
 			netdev_err(net_dev, "Err FD status = 0x%08x\n",
 					fd->status & FM_FD_STAT_RX_ERRORS);
-
+#if defined(CONFIG_FSL_FMAN_TEST)
 	if (dpaa_eth_hooks.rx_error &&
 		dpaa_eth_hooks.rx_error(net_dev, fd, fqid) == DPAA_ETH_STOLEN)
 		/* it's up to the hook to perform resource cleanup */
 		return;
-
+#endif
 	percpu_priv->stats.rx_errors++;
 
 	if (fd->status & FM_PORT_FRM_ERR_DMA)
@@ -288,12 +288,12 @@ static void _dpa_tx_error(struct net_device		*net_dev,
 	if (netif_msg_hw(priv) && net_ratelimit())
 		netdev_warn(net_dev, "FD status = 0x%08x\n",
 				fd->status & FM_FD_STAT_TX_ERRORS);
-
+#if defined(CONFIG_FSL_FMAN_TEST)
 	if (dpaa_eth_hooks.tx_error &&
 		dpaa_eth_hooks.tx_error(net_dev, fd, fqid) == DPAA_ETH_STOLEN)
 		/* now the hook must ensure proper cleanup */
 		return;
-
+#endif
 	percpu_priv->stats.tx_errors++;
 
 	/* If we intended the buffers from this frame to go into the bpools
@@ -393,12 +393,12 @@ static void __hot _dpa_tx_conf(struct net_device	*net_dev,
 	}
 
 	/* hopefully we need not get the timestamp before the hook */
-
+#if defined(CONFIG_FSL_FMAN_TEST)
 	if (dpaa_eth_hooks.tx_confirm && dpaa_eth_hooks.tx_confirm(net_dev,
 		fd, fqid) == DPAA_ETH_STOLEN)
 		/* it's the hook that must now perform cleanup */
 		return;
-
+#endif
 	/* This might not perfectly reflect the reality, if the core dequeuing
 	 * the Tx confirmation is different from the one that did the enqueue,
 	 * but at least it'll show up in the total count.
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index 0ec3a1d..d023162 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -80,7 +80,7 @@ static const char fsl_qman_frame_queues[][25] = {
 	[RX] = "fsl,qman-frame-queues-rx",
 	[TX] = "fsl,qman-frame-queues-tx"
 };
-
+#if defined(CONFIG_FSL_FMAN_TEST)
 /* A set of callbacks for hooking into the fastpath at different points. */
 struct dpaa_eth_hooks_s dpaa_eth_hooks;
 /* This function should only be called on the probe paths, since it makes no
@@ -94,7 +94,7 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks)
 		pr_err("NULL pointer to hooks!\n");
 }
 EXPORT_SYMBOL(fsl_dpaa_eth_set_hooks);
-
+#endif
 int dpa_netdev_init(struct device_node *dpa_node,
 		struct net_device *net_dev,
 		const uint8_t *mac_addr,
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
index 74a80dc..33d6a35 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
@@ -95,6 +95,7 @@ extern u16 qman_portal_max;
 /* from dpa_ethtool.c */
 extern const struct ethtool_ops dpa_ethtool_ops;
 
+#if defined(CONFIG_FSL_FMAN_TEST)
 /* Various hooks used for unit-testing and/or fastpath optimizations.
  * Currently only one set of such hooks is supported.
  */
@@ -125,7 +126,7 @@ struct dpaa_eth_hooks_s {
 void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 
 extern struct dpaa_eth_hooks_s dpaa_eth_hooks;
-
+#endif
 
 int dpa_netdev_init(struct device_node *dpa_node,
 		struct net_device *net_dev,
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index ef671f1..fe576dd 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -578,6 +578,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	DPA_BUG_ON((fd->format != qm_fd_contig) && (fd->format != qm_fd_sg));
 
 	if (likely(fd->format == qm_fd_contig)) {
+#if defined(CONFIG_FSL_FMAN_TEST)
 		/* Execute the Rx processing hook, if it exists. */
 		if (dpaa_eth_hooks.rx_default &&
 			dpaa_eth_hooks.rx_default((void *)fd, net_dev, fqid)
@@ -585,6 +586,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 			/* won't count the rx bytes in */
 			return;
 		}
+#endif
 		skb = contig_fd_to_skb(priv, fd, &use_gro);
 	} else
 		skb = sg_fd_to_skb(priv, fd, &use_gro, count_ptr);
@@ -853,13 +855,13 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	const int queue_mapping = dpa_get_queue_mapping(skb);
 	const bool nonlinear = skb_is_nonlinear(skb);
 	int *countptr, offset = 0;
-
+#if defined(CONFIG_FSL_FMAN_TEST)
 	/* If there is a Tx hook, run it. */
 	if (dpaa_eth_hooks.tx &&
 		dpaa_eth_hooks.tx(skb, net_dev) == DPAA_ETH_STOLEN)
 		/* won't update any Tx stats */
 		return NETDEV_TX_OK;
-
+#endif
 	priv = netdev_priv(net_dev);
 	/* Non-migratable context, safe to use __this_cpu_ptr */
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
-- 
1.9.1

