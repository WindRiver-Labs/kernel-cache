From 912dd36ddf5e5a6f47a42e30e7539198157b0996 Mon Sep 17 00:00:00 2001
From: Andrei Varvara <andrei.varvara@freescale.com>
Date: Fri, 15 Mar 2013 12:12:00 +0200
Subject: [PATCH 139/987] dpa_offload: Add DPA IPsec Wrapper

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

This code is exporting the DPA IPSec API to user-space.
Create a character device called dpa_ipsec.
Ioctls for every DPA IPsec API function.
Compat case treated i.e US & KS can be compiled on 32 or 64 bit

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Signed-off-by: Mihai Serb
Change-Id: I0050a1d0226f918be709cd5a98c2b49139c41874
Reviewed-on: http://git.am.freescale.net:8181/2236
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h |  302 +++++
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c   | 1306 +++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h   |   60 +
 3 files changed, 1668 insertions(+)
 create mode 100644 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
 create mode 100644 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
 create mode 100644 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
new file mode 100644
index 0000000..2054da2
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
@@ -0,0 +1,302 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA IPsec Wrapper Application Programming Interface
+ */
+
+#ifndef __DPA_IPSEC_IOCTL_H
+#define __DPA_IPSEC_IOCTL_H
+
+#include "linux/ioctl.h"
+#ifdef CONFIG_COMPAT
+#include "linux/compat.h"
+#include "dpa_classifier_ioctl.h"
+#endif
+
+struct ioc_dpa_ipsec_params {
+	struct dpa_ipsec_params dpa_ipsec_params;
+	int dpa_ipsec_id;
+};
+
+#ifdef CONFIG_COMPAT
+struct ioc_compat_ipsec_init_params {
+	struct dpa_ipsec_pre_sec_in_params pre_sec_in_params;
+	struct dpa_ipsec_post_sec_in_params post_sec_in_params;
+	struct dpa_ipsec_pre_sec_out_params pre_sec_out_params;
+	struct dpa_ipsec_post_sec_out_params post_sec_out_params;
+	compat_uptr_t fm_pcd;
+	uint16_t qm_sec_ch;
+	uint16_t max_sa_pairs;
+	uint32_t max_sa_manip_ops;
+	compat_uptr_t fqid_range;
+	uint8_t ipf_bpid;
+};
+
+struct ioc_compat_dpa_ipsec_params {
+	struct ioc_compat_ipsec_init_params dpa_ipsec_params;
+	int dpa_ipsec_id;
+};
+#endif
+
+struct ioc_dpa_ipsec_sa_params {
+	int dpa_ipsec_id;
+	struct dpa_ipsec_sa_params sa_params;
+	int sa_id;
+};
+
+#ifdef CONFIG_COMPAT
+struct ioc_compat_sa_init_vector {
+	compat_uptr_t init_vector;
+	uint8_t length;
+};
+
+struct ioc_compat_sa_crypto_params {
+	enum dpa_ipsec_cipher_alg alg_suite;
+	compat_uptr_t cipher_key;
+	uint8_t cipher_key_len;
+	compat_uptr_t auth_key;
+	uint8_t auth_key_len;
+};
+
+struct ioc_compat_sa_out_params {
+	compat_uptr_t init_vector;
+	unsigned int ip_ver;
+	uint16_t ip_hdr_size;
+	compat_uptr_t outer_ip_header;
+	compat_uptr_t outer_udp_header;
+	uint16_t post_sec_flow_id;
+};
+
+struct ioc_compat_sa_in_params {
+	enum dpa_ipsec_arw arw;
+	int use_var_iphdr_len;
+	struct dpa_offload_ip_address src_addr;
+	struct dpa_offload_ip_address dest_addr;
+	bool use_udp_encap;
+	uint16_t src_port;
+	uint16_t dest_port;
+	struct dpa_cls_compat_tbl_action policy_miss_action;
+	struct dpa_cls_compat_tbl_action post_ipsec_action;
+};
+
+struct ioc_compat_sa_params {
+	uint32_t spi;
+	bool use_ext_seq_num;
+	uint64_t start_seq_num;
+	uint32_t l2_hdr_size;
+	enum dpa_ipsec_sa_mode sa_mode;
+	enum dpa_ipsec_sa_proto sa_proto;
+	uint8_t hdr_upd_flags;
+	uint8_t sa_wqid;
+	uint8_t sa_bpid;
+	bool enable_stats;
+	struct ioc_compat_sa_crypto_params crypto_params;
+	enum dpa_ipsec_direction sa_dir;
+	union {
+		struct ioc_compat_sa_in_params sa_in_params;
+		struct ioc_compat_sa_out_params sa_out_params;
+	};
+};
+
+struct ioc_compat_dpa_ipsec_sa_params {
+	int dpa_ipsec_id;
+	struct ioc_compat_sa_params sa_params;
+	int sa_id;
+};
+#endif
+
+struct ioc_dpa_ipsec_add_rem_policy {
+	struct dpa_ipsec_policy_params pol_params;
+	int sa_id;
+};
+
+#ifdef CONFIG_COMPAT
+struct ioc_compat_pol_dir_params {
+	enum dpa_ipsec_pol_dir_params_type type;
+	union {
+		int manip_desc;
+		struct dpa_cls_compat_tbl_action in_action;
+	};
+};
+
+struct ioc_compat_policy_params {
+	struct dpa_offload_ip_address src_addr;
+	uint8_t src_prefix_len;
+	struct dpa_offload_ip_address dest_addr;
+	uint8_t dest_prefix_len;
+	uint8_t protocol;
+	bool masked_proto;
+	union {
+		struct dpa_ipsec_l4_params	l4;
+		struct dpa_ipsec_icmp_params	icmp;
+	};
+	struct ioc_compat_pol_dir_params dir_params;
+	int priority;		/* Policy priority			      */
+};
+
+struct ioc_compat_dpa_ipsec_add_rem_policy {
+	struct ioc_compat_policy_params pol_params;
+	int sa_id;
+};
+#endif
+
+struct ioc_dpa_ipsec_rekey_prm {
+	struct dpa_ipsec_sa_params sa_params;
+	int auto_rmv_old_sa;
+	int sa_id;		/* old sa id */
+	int new_sa_id;		/* newly created sa id */
+};
+
+#ifdef CONFIG_COMPAT
+struct ioc_compat_dpa_ipsec_rekey_prm {
+	struct ioc_compat_sa_params sa_params;
+	int auto_rmv_old_sa;
+	int sa_id;		/* old sa id */
+	int new_sa_id;		/* newly created sa id */
+};
+#endif
+
+struct ioc_dpa_ipsec_get_policies {
+	int sa_id;		/* sa id */
+	struct dpa_ipsec_policy_params *policy_params;
+	int num_pol;		/* number of policies */
+};
+
+#ifdef CONFIG_COMPAT
+struct ioc_compat_dpa_ipsec_get_policies {
+	int sa_id;		/* sa id */
+	compat_uptr_t policy_params;
+	int num_pol;		/* number of policies */
+};
+#endif
+
+struct ioc_dpa_ipsec_sa_get_stats {
+	int sa_id;		/* sa id */
+	struct dpa_ipsec_sa_stats sa_stats;
+};
+
+struct ioc_dpa_ipsec_sa_modify_prm {
+	int sa_id;		/* security association id */
+	struct dpa_ipsec_sa_modify_prm modify_prm;
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_dpa_ipsec_sa_modify_prm {
+	enum dpa_ipsec_sa_modify_type type;
+	union {
+		enum dpa_ipsec_arw arw;
+		uint32_t seq;
+		uint64_t ext_seq;
+		struct ioc_compat_sa_crypto_params crypto_params;
+	};
+};
+
+struct ioc_compat_dpa_ipsec_sa_modify_prm {
+	int sa_id;		/* security association id */
+	struct compat_dpa_ipsec_sa_modify_prm modify_prm;
+};
+#endif
+
+#define DPA_IPSEC_IOC_MAGIC	0xee
+
+#define DPA_IPSEC_IOC_INIT \
+		_IOWR(DPA_IPSEC_IOC_MAGIC, 0, struct ioc_dpa_ipsec_params)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_INIT_COMPAT \
+		_IOWR(DPA_IPSEC_IOC_MAGIC, 0, \
+		      struct ioc_compat_dpa_ipsec_params)
+#endif
+
+#define DPA_IPSEC_IOC_FREE \
+		_IOW(DPA_IPSEC_IOC_MAGIC, 1, int)
+
+#define DPA_IPSEC_IOC_CREATE_SA \
+		_IOWR(DPA_IPSEC_IOC_MAGIC, 2, struct ioc_dpa_ipsec_sa_params)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_CREATE_SA_COMPAT \
+		_IOWR(DPA_IPSEC_IOC_MAGIC, 2, \
+		      struct ioc_compat_dpa_ipsec_sa_params)
+#endif
+
+#define DPA_IPSEC_IOC_REMOVE_SA \
+		_IOW(DPA_IPSEC_IOC_MAGIC, 3, int)
+
+#define DPA_IPSEC_IOC_ADD_POLICY \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 4, struct ioc_dpa_ipsec_add_rem_policy)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_ADD_POLICY_COMPAT \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 4, struct ioc_compat_dpa_ipsec_add_rem_policy)
+#endif
+
+#define DPA_IPSEC_IOC_REMOVE_POLICY \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 5, struct ioc_dpa_ipsec_add_rem_policy)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_REMOVE_POLICY_COMPAT \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 5, struct ioc_compat_dpa_ipsec_add_rem_policy)
+#endif
+
+#define DPA_IPSEC_IOC_SA_REKEYING \
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 6, struct ioc_dpa_ipsec_rekey_prm)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_SA_REKEYING_COMPAT \
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 6, struct ioc_compat_dpa_ipsec_rekey_prm)
+#endif
+
+#define DPA_IPSEC_IOC_FLUSH_ALL_SA \
+		_IOW(DPA_IPSEC_IOC_MAGIC, 7, int)
+
+#define DPA_IPSEC_IOC_GET_SA_POLICIES \
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 8, struct ioc_dpa_ipsec_get_policies)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_GET_SA_POLICIES_COMPAT \
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 8, struct ioc_compat_dpa_ipsec_get_policies)
+#endif
+
+#define DPA_IPSEC_IOC_FLUSH_SA_POLICIES \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 9, int)
+
+#define DPA_IPSEC_IOC_DISABLE_SA \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 10, int)
+
+#define DPA_IPSEC_IOC_GET_SA_STATS \
+	_IOWR(DPA_IPSEC_IOC_MAGIC, 11, struct ioc_dpa_ipsec_sa_get_stats)
+
+#define DPA_IPSEC_IOC_SA_MODIFY \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 12, struct ioc_dpa_ipsec_sa_modify_prm)
+#ifdef CONFIG_COMPAT
+#define DPA_IPSEC_IOC_SA_MODIFY_COMPAT \
+	_IOW(DPA_IPSEC_IOC_MAGIC, 12, \
+	     struct ioc_compat_dpa_ipsec_sa_modify_prm)
+#endif
+
+#endif	/* __DPA_IPSEC_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
new file mode 100644
index 0000000..83c59c1
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -0,0 +1,1306 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * DPA IPsec Wrapper implementation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/uaccess.h>
+#include <linux/export.h>
+
+#include <linux/fsl_dpa_ipsec.h>
+#include "dpa_ipsec_ioctl.h"
+#include "wrp_dpa_ipsec.h"
+
+/* Other includes */
+#include <linux/fdtable.h>
+#include "lnxwrp_fm.h"
+
+#define UDP_HDR_SIZE 8
+
+static const struct file_operations dpa_ipsec_fops = {
+	.owner = THIS_MODULE,
+	.open = wrp_dpa_ipsec_open,
+	.read = NULL,
+	.write = NULL,
+	.unlocked_ioctl = wrp_dpa_ipsec_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = wrp_dpa_ipsec_ioctl_compat,
+#endif
+	.release = wrp_dpa_ipsec_release
+};
+
+static int dpa_ipsec_cdev_major = -1;
+static long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
+				   unsigned long args, bool compat);
+
+#ifdef CONFIG_COMPAT
+
+#define COMPAT_K_TO_US 0 /* copy from Kernel to User */
+#define COMPAT_US_TO_K 1 /* copy from User to Kernel */
+
+static void compat_copy_dpa_ipsec_init(struct ioc_dpa_ipsec_params *prm,
+				struct ioc_compat_dpa_ipsec_params *compat_prm,
+				uint8_t	compat)
+{
+	struct ioc_compat_ipsec_init_params *init_compat_prm;
+	struct dpa_ipsec_params	*init_prm;
+
+	init_compat_prm = &compat_prm->dpa_ipsec_params;
+	init_prm = &prm->dpa_ipsec_params;
+
+	if (compat == COMPAT_US_TO_K) {
+		init_prm->fm_pcd = (void *)compat_ptr(init_compat_prm->fm_pcd);
+		init_prm->fqid_range = (struct dpa_ipsec_fqid_range *)
+					compat_ptr(init_compat_prm->fqid_range);
+		init_prm->ipf_bpid = init_compat_prm->ipf_bpid;
+		init_prm->max_sa_pairs = init_compat_prm->max_sa_pairs;
+		init_prm->post_sec_in_params =
+					init_compat_prm->post_sec_in_params;
+		init_prm->max_sa_manip_ops = init_compat_prm->max_sa_manip_ops;
+		init_prm->post_sec_out_params =
+					init_compat_prm->post_sec_out_params;
+		init_prm->pre_sec_in_params =
+					init_compat_prm->pre_sec_in_params;
+		init_prm->pre_sec_out_params =
+					init_compat_prm->pre_sec_out_params;
+		init_prm->qm_sec_ch = init_compat_prm->qm_sec_ch;
+	} else
+		/* copy the ID of the newly initialized DPA IPSec instance */
+		compat_prm->dpa_ipsec_id = prm->dpa_ipsec_id;
+		/*
+		 * the other members of structure have not been changed and
+		 * there is no need to update their values
+		 */
+}
+
+static void compat_copy_sa_in_params(struct dpa_ipsec_sa_in_params *prm,
+				struct ioc_compat_sa_in_params *compat_prm,
+				uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		prm->arw = compat_prm->arw;
+		prm->use_var_iphdr_len = compat_prm->use_var_iphdr_len;
+		prm->src_addr = compat_prm->src_addr;
+		prm->dest_addr = compat_prm->dest_addr;
+		prm->use_udp_encap = compat_prm->use_udp_encap;
+		prm->src_port = compat_prm->src_port;
+		prm->dest_port = compat_prm->dest_port;
+		memset(&prm->policy_miss_action, 0,
+		       sizeof(prm->policy_miss_action));
+		dpa_cls_tbl_action_params_compatcpy(&prm->policy_miss_action,
+					&compat_prm->policy_miss_action);
+		memset(&prm->post_ipsec_action, 0,
+		       sizeof(prm->post_ipsec_action));
+		dpa_cls_tbl_action_params_compatcpy(&prm->post_ipsec_action,
+					&compat_prm->post_ipsec_action);
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+}
+static void compat_copy_sa_out_params(struct dpa_ipsec_sa_out_params *prm,
+				struct ioc_compat_sa_out_params *compat_prm,
+				uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		prm->init_vector = (struct dpa_ipsec_init_vector *)
+					compat_ptr(compat_prm->init_vector);
+		prm->ip_ver = compat_prm->ip_ver;
+		prm->ip_hdr_size = compat_prm->ip_hdr_size;
+		prm->outer_ip_header = (void *)
+					compat_ptr(compat_prm->outer_ip_header);
+		prm->outer_udp_header =	(void *)
+				compat_ptr(compat_prm->outer_udp_header);
+		prm->post_sec_flow_id = compat_prm->post_sec_flow_id;
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+}
+
+static void compat_copy_sa_crypto_params(struct dpa_ipsec_sa_crypto_params *prm,
+				struct ioc_compat_sa_crypto_params *compat_prm,
+				uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+
+		prm->alg_suite = compat_prm->alg_suite;
+		prm->auth_key = (uint8_t *)compat_ptr(compat_prm->auth_key);
+		prm->auth_key_len = compat_prm->auth_key_len;
+		prm->cipher_key = (uint8_t *)compat_ptr(compat_prm->cipher_key);
+		prm->cipher_key_len = compat_prm->cipher_key_len;
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+}
+
+static void compat_copy_sa_params(struct dpa_ipsec_sa_params *sa_prm,
+				struct ioc_compat_sa_params *sa_compat_prm,
+				bool compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		/* copy common (both IN & OUT SA) parameters */
+		sa_prm->spi = sa_compat_prm->spi;
+		sa_prm->use_ext_seq_num = sa_compat_prm->use_ext_seq_num;
+		sa_prm->start_seq_num = sa_compat_prm->start_seq_num;
+		sa_prm->l2_hdr_size = sa_compat_prm->l2_hdr_size;
+		sa_prm->sa_mode = sa_compat_prm->sa_mode;
+		sa_prm->sa_proto = sa_compat_prm->sa_proto;
+		sa_prm->hdr_upd_flags = sa_compat_prm->hdr_upd_flags;
+		sa_prm->sa_wqid = sa_compat_prm->sa_wqid;
+		sa_prm->sa_bpid = sa_compat_prm->sa_bpid;
+		sa_prm->enable_stats = sa_compat_prm->enable_stats;
+		sa_prm->sa_dir = sa_compat_prm->sa_dir;
+
+		/* copy crypto parameters (containing multiple pointers) */
+		compat_copy_sa_crypto_params(&sa_prm->crypto_params,
+					     &sa_compat_prm->crypto_params,
+					     COMPAT_US_TO_K);
+
+		/* copy direction specific (IN / OUT) parameters */
+		if (sa_prm->sa_dir == DPA_IPSEC_INBOUND)
+			compat_copy_sa_in_params(&sa_prm->sa_in_params,
+						 &sa_compat_prm->sa_in_params,
+						 COMPAT_US_TO_K);
+		else
+			compat_copy_sa_out_params(&sa_prm->sa_out_params,
+						  &sa_compat_prm->sa_out_params,
+						  COMPAT_US_TO_K);
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+}
+
+static void compat_copy_dpa_ipsec_create_sa(struct ioc_dpa_ipsec_sa_params *prm,
+			struct ioc_compat_dpa_ipsec_sa_params *compat_prm,
+			uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K)
+		/* copy SA params from userspace */
+		compat_copy_sa_params(&prm->sa_params, &compat_prm->sa_params,
+				      compat);
+	else
+		/* copy the ID of the newly created DPA IPSec SA */
+		compat_prm->sa_id = prm->sa_id;
+		/*
+		 * the other members of structure have not been changed and
+		 * there is no need to update their values
+		 */
+}
+
+static int compat_copy_sa_out_iv(struct dpa_ipsec_init_vector *sa_iv,
+				compat_uptr_t compat_iv_ptr, uint8_t compat)
+{
+	struct ioc_compat_sa_init_vector *compat_sa_iv, tmp_sa_iv;
+
+	compat_sa_iv =
+		(struct ioc_compat_sa_init_vector *)compat_ptr(compat_iv_ptr);
+
+	if (compat == COMPAT_US_TO_K) {
+		if (copy_from_user(&tmp_sa_iv, compat_sa_iv, sizeof(tmp_sa_iv)))
+			return -EINVAL;
+		sa_iv->init_vector = (uint8_t *)
+					compat_ptr(tmp_sa_iv.init_vector);
+		sa_iv->length = tmp_sa_iv.length;
+	}
+	/*
+	 * for COMPAT_K_TO_US no member values have to be updated
+	 * because none have been changed by the call to the DPA IPSec function
+	 */
+	return 0;
+}
+
+static void compat_copy_dpa_ipsec_rekey_sa(struct ioc_dpa_ipsec_rekey_prm *prm,
+			struct ioc_compat_dpa_ipsec_rekey_prm *compat_prm,
+			uint8_t	compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		/* copy rekeying specific params */
+		prm->auto_rmv_old_sa = compat_prm->auto_rmv_old_sa;
+		prm->sa_id = compat_prm->sa_id;
+
+		/* copy SA params from userspace */
+		compat_copy_sa_params(&prm->sa_params, &compat_prm->sa_params,
+				      compat);
+	} else
+		/* copy the ID of the newly created DPA IPSec SA */
+		compat_prm->new_sa_id = prm->new_sa_id;
+		/*
+		 * the other members of structure have not been changed and
+		 * there is no need to update their values
+		 */
+}
+
+static void compat_copy_dpa_ipsec_add_rem_policy(
+			struct ioc_dpa_ipsec_add_rem_policy *prm,
+			struct ioc_compat_dpa_ipsec_add_rem_policy *compat_prm,
+			uint8_t compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		prm->sa_id = compat_prm->sa_id;
+		prm->pol_params.src_addr = compat_prm->pol_params.src_addr;
+		prm->pol_params.src_prefix_len =
+					  compat_prm->pol_params.src_prefix_len;
+		prm->pol_params.dest_addr = compat_prm->pol_params.dest_addr;
+		prm->pol_params.dest_prefix_len =
+					 compat_prm->pol_params.dest_prefix_len;
+		prm->pol_params.protocol = compat_prm->pol_params.protocol;
+		prm->pol_params.masked_proto =
+					    compat_prm->pol_params.masked_proto;
+		prm->pol_params.l4 = compat_prm->pol_params.l4;
+		memset(&prm->pol_params.dir_params, 0,
+					    sizeof(prm->pol_params.dir_params));
+		if (compat_prm->pol_params.dir_params.type ==
+						DPA_IPSEC_POL_DIR_PARAMS_MANIP)
+			prm->pol_params.dir_params.manip_desc =
+				   compat_prm->pol_params.dir_params.manip_desc;
+		else if (compat_prm->pol_params.dir_params.type ==
+						 DPA_IPSEC_POL_DIR_PARAMS_ACT) {
+			dpa_cls_tbl_action_params_compatcpy(
+				  &prm->pol_params.dir_params.in_action,
+				  &compat_prm->pol_params.dir_params.in_action);
+		}
+		prm->pol_params.dir_params.type =
+					 compat_prm->pol_params.dir_params.type;
+		prm->pol_params.priority =
+					 compat_prm->pol_params.priority;
+	} else {
+		memset(compat_prm, 0,
+			sizeof(struct ioc_compat_dpa_ipsec_add_rem_policy));
+		compat_prm->sa_id = prm->sa_id;
+		compat_prm->pol_params.src_addr = prm->pol_params.src_addr;
+		compat_prm->pol_params.src_prefix_len =
+						 prm->pol_params.src_prefix_len;
+		compat_prm->pol_params.dest_addr = prm->pol_params.dest_addr;
+		compat_prm->pol_params.dest_prefix_len =
+						prm->pol_params.dest_prefix_len;
+		compat_prm->pol_params.protocol = prm->pol_params.protocol;
+		compat_prm->pol_params.masked_proto =
+						   prm->pol_params.masked_proto;
+		compat_prm->pol_params.l4 = prm->pol_params.l4;
+		memset(&compat_prm->pol_params.dir_params, 0,
+		       sizeof(compat_prm->pol_params.dir_params));
+		if (prm->pol_params.dir_params.type ==
+						DPA_IPSEC_POL_DIR_PARAMS_MANIP)
+			compat_prm->pol_params.dir_params.manip_desc =
+					  prm->pol_params.dir_params.manip_desc;
+		else if (prm->pol_params.dir_params.type ==
+						 DPA_IPSEC_POL_DIR_PARAMS_ACT) {
+			dpa_cls_tbl_action_params_rcompatcpy(
+				  &compat_prm->pol_params.dir_params.in_action,
+				  &prm->pol_params.dir_params.in_action);
+		}
+		compat_prm->pol_params.dir_params.type =
+						prm->pol_params.dir_params.type;
+		compat_prm->pol_params.priority =
+						prm->pol_params.priority;
+	}
+
+}
+
+static void compat_copy_dpa_ipsec_get_pols(
+			struct ioc_dpa_ipsec_get_policies *prm,
+			struct ioc_compat_dpa_ipsec_get_policies *compat_prm,
+			uint8_t compat)
+{
+	if (compat == COMPAT_US_TO_K) {
+		prm->num_pol = compat_prm->num_pol;
+		prm->sa_id = compat_prm->sa_id;
+		prm->policy_params = (struct dpa_ipsec_policy_params *)
+					compat_ptr(compat_prm->policy_params);
+	} else
+		compat_prm->num_pol = prm->num_pol;
+}
+
+#endif
+
+static int copy_policer_params(struct dpa_cls_tbl_action *cls_action,
+			       struct dpa_cls_tbl_policer_params **policer_prm)
+{
+	struct dpa_cls_tbl_policer_params *policer_params;
+
+	if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ &&
+	    cls_action->enq_params.policer_params != NULL) {
+		policer_params = kmalloc(sizeof(*policer_params), GFP_KERNEL);
+		if (!policer_params) {
+			pr_err("Error alloc CLS POL param");
+			return -ENOMEM;
+		}
+		*policer_prm = policer_params;
+		if (copy_from_user(policer_params,
+				  cls_action->enq_params.policer_params,
+				  sizeof(*policer_params))) {
+			pr_err("Error - copy CLS POL param");
+			return -EINVAL;
+		}
+		cls_action->enq_params.policer_params = policer_params;
+	}
+	return 0;
+}
+
+/* free memory allocated for copying SA params from US */
+static void free_sa_params(struct dpa_ipsec_sa_params *prm)
+{
+	struct dpa_ipsec_sa_crypto_params *crypto_params;
+
+	if (prm->sa_dir == DPA_IPSEC_OUTBOUND) {
+		struct dpa_ipsec_sa_out_params *sa_out_prm;
+
+		sa_out_prm = &prm->sa_out_params;
+		if (sa_out_prm->init_vector) {
+			kfree(sa_out_prm->init_vector->init_vector);
+			kfree(sa_out_prm->init_vector);
+		}
+		kfree(sa_out_prm->outer_ip_header);
+		kfree(sa_out_prm->outer_udp_header);
+	} else {
+		struct dpa_cls_tbl_action *cls_action;
+
+		cls_action = &prm->sa_in_params.policy_miss_action;
+		if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ)
+			kfree(cls_action->enq_params.policer_params);
+
+		cls_action = &prm->sa_in_params.post_ipsec_action;
+		if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ)
+			kfree(cls_action->enq_params.policer_params);
+	}
+
+	crypto_params = &prm->crypto_params;
+	kfree(crypto_params->auth_key);
+	kfree(crypto_params->cipher_key);
+}
+
+/* handle any required memory transfers (US to K) when creating/rekeying a SA */
+#ifdef CONFIG_COMPAT
+static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm,
+			     struct ioc_compat_sa_params *compat_prm,
+			     bool compat)
+#else
+static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
+#endif
+{
+	struct dpa_ipsec_sa_out_params *sa_out_prm;
+	struct dpa_ipsec_sa_crypto_params *crypto_params;
+	struct dpa_ipsec_init_vector *sa_out_iv = NULL;
+	uint8_t *auth_key =  NULL, *cipher_key = NULL, *iv_array = NULL;
+	void *out_ip_hdr = NULL, *out_udp_hdr = NULL;
+	struct dpa_cls_tbl_policer_params *policer_prm_hit = NULL;
+	struct dpa_cls_tbl_policer_params *policer_prm_miss = NULL;
+	int err = 0;
+
+	/* allocate memory and copy SA out params (if required)*/
+	if (prm->sa_dir == DPA_IPSEC_OUTBOUND) {
+		sa_out_prm = &prm->sa_out_params;
+		if (sa_out_prm->outer_ip_header) {
+			out_ip_hdr = kmalloc(sa_out_prm->ip_hdr_size,
+					     GFP_KERNEL);
+			if (!out_ip_hdr) {
+				pr_err("Error - alloc SA out hdr");
+				return -ENOMEM;
+			}
+			if (copy_from_user(out_ip_hdr,
+					   sa_out_prm->outer_ip_header,
+					   sa_out_prm->ip_hdr_size)) {
+				pr_err("Error - copy SA out hdr");
+				err = -EINVAL;
+				goto free_create_copied_sa_mem;
+			}
+			sa_out_prm->outer_ip_header = out_ip_hdr;
+		}
+		if (sa_out_prm->outer_udp_header) {
+			out_udp_hdr = kmalloc(UDP_HDR_SIZE, GFP_KERNEL);
+			if (!out_udp_hdr) {
+				pr_err("Error - alloc SA out udp hdr");
+				err = -ENOMEM;
+				goto free_create_copied_sa_mem;
+			}
+			if (copy_from_user(out_udp_hdr,
+					   sa_out_prm->outer_udp_header,
+					   UDP_HDR_SIZE)) {
+				pr_err("Error - copy SA out udp hdr");
+				err = -EINVAL;
+				goto free_create_copied_sa_mem;
+			}
+			sa_out_prm->outer_udp_header = out_udp_hdr;
+		}
+		if (sa_out_prm->init_vector) {
+			sa_out_iv = kmalloc(sizeof(*sa_out_iv), GFP_KERNEL);
+			if (!sa_out_iv) {
+				pr_err("Error - alloc SA out IV struct");
+				err = -ENOMEM;
+				goto free_create_copied_sa_mem;
+			}
+#ifdef CONFIG_COMPAT
+			if (compat) {
+				struct ioc_compat_sa_out_params *compat_out_prm;
+
+				compat_out_prm = &compat_prm->sa_out_params;
+				err = compat_copy_sa_out_iv(sa_out_iv,
+						compat_out_prm->init_vector,
+						COMPAT_US_TO_K);
+			} else
+#endif
+				if (copy_from_user(sa_out_iv,
+						   sa_out_prm->init_vector,
+						   sizeof(*sa_out_iv)))
+					err = -EINVAL;
+			if (err < 0) {
+				pr_err("Error - copy SA out IV struct");
+				kfree(sa_out_iv);
+				return err;
+			}
+			sa_out_prm->init_vector = sa_out_iv;
+
+			/* if the IV array is NULL, don't bother to copy it */
+			if (!sa_out_iv->init_vector)
+				goto copy_crypto_keys;
+
+			iv_array = kmalloc(sa_out_iv->length, GFP_KERNEL);
+			if (!iv_array) {
+				pr_err("Error - alloc SA out IV array");
+				err = -ENOMEM;
+				goto free_create_copied_sa_mem;
+			}
+			if (copy_from_user(iv_array, sa_out_iv->init_vector,
+					   sa_out_iv->length)) {
+				pr_err("Error - copy SA out IV array");
+				err = -EINVAL;
+				goto free_create_copied_sa_mem;
+			}
+			sa_out_iv->init_vector = iv_array;
+		}
+	} else {
+		/* handle any required memory transfer from US to K */
+		struct dpa_cls_tbl_action *cls_action;
+
+		/* copy policer params for policy miss action -  if any */
+		cls_action = &prm->sa_in_params.policy_miss_action;
+		err = copy_policer_params(cls_action, &policer_prm_miss);
+		if (err < 0) {
+			if (!policer_prm_miss)
+				return err;
+			else
+				goto free_create_copied_sa_mem;
+		}
+
+		/* copy policer params for post decryption action -  if any */
+		cls_action = &prm->sa_in_params.post_ipsec_action;
+		err = copy_policer_params(cls_action, &policer_prm_hit);
+		if (err < 0) {
+			if (!policer_prm_hit)
+				return err;
+			else
+				goto free_create_copied_sa_mem;
+		}
+	}
+
+copy_crypto_keys:
+	/*
+	 * allocate memory and copy the keys from userspace
+	 * (if required - if keys are not NULL)
+	 */
+	crypto_params = &prm->crypto_params;
+	if (crypto_params->auth_key) {
+		auth_key = kmalloc(crypto_params->auth_key_len, GFP_KERNEL);
+		if (!auth_key) {
+			pr_err("Couldn't allocate memory for SA auth key");
+			err = -ENOMEM;
+			goto free_create_sa_keys_mem;
+		}
+		if (copy_from_user(auth_key, crypto_params->auth_key,
+				   crypto_params->auth_key_len)) {
+			pr_err("Could not copy SA auth key!");
+			err = -EINVAL;
+			goto free_create_sa_keys_mem;
+		}
+		crypto_params->auth_key = auth_key;
+	}
+
+	if (crypto_params->cipher_key) {
+		cipher_key = kmalloc(crypto_params->cipher_key_len, GFP_KERNEL);
+		if (!cipher_key) {
+			pr_err("Couldn't allocate memory for SA cipher key");
+			err = -ENOMEM;
+			goto free_create_sa_keys_mem;
+		}
+		if (copy_from_user(cipher_key, crypto_params->cipher_key,
+				   crypto_params->cipher_key_len)) {
+			pr_err("Could not copy SA auth key!");
+			err = -EINVAL;
+			goto free_create_sa_keys_mem;
+		}
+		crypto_params->cipher_key = cipher_key;
+	}
+
+	return 0;
+
+free_create_sa_keys_mem:
+	kfree(auth_key);
+	kfree(cipher_key);
+
+free_create_copied_sa_mem:
+	if (prm->sa_dir == DPA_IPSEC_OUTBOUND) {
+		kfree(iv_array);
+		kfree(sa_out_iv);
+		kfree(out_ip_hdr);
+		kfree(out_udp_hdr);
+	} else {
+		kfree(policer_prm_miss);
+		kfree(policer_prm_hit);
+	}
+
+	return err;
+}
+
+static int do_init_ioctl(void *args, bool compat)
+{
+	struct ioc_dpa_ipsec_params prm;
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_dpa_ipsec_params compat_prm;
+#endif
+	struct dpa_ipsec_fqid_range *fqid_range = NULL;
+	struct file *fm_pcd_file;
+	t_LnxWrpFmDev *fm_wrapper_dev;
+	int err;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+			pr_err("Could not copy DPA IPSec init parameters");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_init(&prm, &compat_prm, COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm, args, sizeof(prm))) {
+			pr_err("Could not copy DPA IPSec init parameters");
+			return -EINVAL;
+		}
+
+	/* copy FQID range params - if configured */
+	if (prm.dpa_ipsec_params.fqid_range) {
+		fqid_range = kmalloc(sizeof(*fqid_range), GFP_KERNEL);
+		if (!fqid_range) {
+			pr_err("FQID range allocation failed!\n");
+			return -EINVAL;
+		}
+		if (copy_from_user(prm.dpa_ipsec_params.fqid_range, fqid_range,
+				   sizeof(*fqid_range))) {
+			pr_err("Could not copy FQID range params!\n");
+			err = -EINVAL;
+			goto free_ipsec_init_mem;
+		}
+		prm.dpa_ipsec_params.fqid_range = fqid_range;
+	}
+
+	/* Translate FM_PCD file descriptor */
+	fm_pcd_file = fcheck((unsigned long)prm.dpa_ipsec_params.fm_pcd);
+	if (!fm_pcd_file) {
+		pr_err("Could not acquire PCD handle");
+		err = -EINVAL;
+		goto free_ipsec_init_mem;
+	}
+	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
+	prm.dpa_ipsec_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+	err = dpa_ipsec_init(&prm.dpa_ipsec_params,
+			     &prm.dpa_ipsec_id);
+	if (err < 0)
+		goto free_ipsec_init_mem;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		compat_copy_dpa_ipsec_init(&prm, &compat_prm, COMPAT_K_TO_US);
+		if (copy_to_user((void *)args, &compat_prm,
+				 sizeof(compat_prm))) {
+			pr_err("Could not copy to user the DPA IPSec ID");
+			err = -EINVAL;
+		}
+	} else
+#endif
+		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+			pr_err("Could not copy to user the ID");
+			err = -EINVAL;
+		}
+
+free_ipsec_init_mem:
+	kfree(fqid_range);
+
+	return err;
+}
+
+static int do_create_sa_ioctl(void *args, bool compat)
+{
+	struct ioc_dpa_ipsec_sa_params prm;
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_dpa_ipsec_sa_params compat_prm;
+#endif
+	int err = 0;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+			pr_err("Could not copy SA parameters");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_create_sa(&prm, &compat_prm,
+						COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm, args, sizeof(prm))) {
+			pr_err("Could not copy SA parameters");
+			return -EINVAL;
+		}
+
+#ifdef CONFIG_COMPAT
+	err = do_copy_sa_params(&prm.sa_params, &compat_prm.sa_params, compat);
+#else
+	err = do_copy_sa_params(&prm.sa_params);
+#endif
+	if (err < 0)
+		return err;
+
+	err = dpa_ipsec_create_sa(prm.dpa_ipsec_id, &prm.sa_params, &prm.sa_id);
+	if (err < 0)
+		goto free_create_sa_mem;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		compat_copy_dpa_ipsec_create_sa(&prm, &compat_prm,
+						COMPAT_K_TO_US);
+		if (copy_to_user((void *)args, &compat_prm,
+				 sizeof(compat_prm))) {
+			pr_err("Could not copy to user the SA ID");
+			err = -EINVAL;
+		}
+	} else
+#endif
+		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+			pr_err("Could not copy to user the SA ID");
+			err = -EINVAL;
+		}
+
+free_create_sa_mem:
+	free_sa_params(&prm.sa_params);
+
+	return err;
+}
+
+static int do_sa_rekey_ioctl(void *args, bool compat)
+{
+	struct ioc_dpa_ipsec_rekey_prm prm;
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_dpa_ipsec_rekey_prm compat_prm;
+#endif
+	int err = 0;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+			pr_err("Could not copy SA rekeying params");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_rekey_sa(&prm, &compat_prm,
+					       COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm, args, sizeof(prm))) {
+			pr_err("Could not copy SA rekeying params");
+			return -EINVAL;
+		}
+
+#ifdef CONFIG_COMPAT
+	err = do_copy_sa_params(&prm.sa_params, &compat_prm.sa_params, compat);
+#else
+	err = do_copy_sa_params(&prm.sa_params);
+#endif
+	if (err < 0)
+		return err;
+
+	err = dpa_ipsec_sa_rekeying(prm.sa_id, &prm.sa_params,
+				    default_rekey_event_cb, prm.auto_rmv_old_sa,
+				    &prm.new_sa_id);
+	if (err < 0)
+		goto free_rekey_sa_mem;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		compat_copy_dpa_ipsec_rekey_sa(&prm, &compat_prm,
+					       COMPAT_K_TO_US);
+		if (copy_to_user((void *)args, &compat_prm,
+				 sizeof(compat_prm))) {
+			pr_err("Could not copy to user new SA ID");
+			err = -EINVAL;
+		}
+	} else
+#endif
+		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+			pr_err("Could not copy to user new SA ID");
+			err = -EINVAL;
+		}
+
+free_rekey_sa_mem:
+	free_sa_params(&prm.sa_params);
+
+	return err;
+}
+
+static int do_add_rem_policy_ioctl(void *args, bool add_pol, bool compat)
+{
+	struct ioc_dpa_ipsec_add_rem_policy prm;
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_dpa_ipsec_add_rem_policy compat_prm;
+#endif
+	struct dpa_cls_tbl_policer_params *policer_prm = NULL;
+	int err;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm,
+			   (struct ioc_compat_dpa_ipsec_add_rem_policy *) args,
+			    sizeof(compat_prm))) {
+			pr_err("Could not copy parameters\n");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_add_rem_policy(&prm, &compat_prm,
+						     COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm,
+			   (struct ioc_dpa_ipsec_add_rem_policy *) args,
+			    sizeof(prm))) {
+			pr_err("Could not copy parameters\n");
+			return -EINVAL;
+		}
+
+	if (prm.pol_params.dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_ACT) {
+		err = copy_policer_params(&prm.pol_params.dir_params.in_action,
+					  &policer_prm);
+		if (err < 0) {
+			if (!policer_prm)
+				return err;
+			else
+				goto free_pol_memory;
+		}
+	}
+
+	if (add_pol)
+		err = dpa_ipsec_sa_add_policy(prm.sa_id, &prm.pol_params);
+	else
+		err = dpa_ipsec_sa_remove_policy(prm.sa_id, &prm.pol_params);
+
+free_pol_memory:
+	kfree(policer_prm);
+
+	return err;
+}
+
+static int do_sa_get_policies_ioctl(void *args, bool compat)
+{
+	struct ioc_dpa_ipsec_get_policies prm;
+	struct dpa_ipsec_policy_params *policy_params = NULL;
+#ifdef CONFIG_COMPAT
+	struct ioc_dpa_ipsec_add_rem_policy kparam;
+	struct ioc_compat_dpa_ipsec_get_policies compat_prm;
+	struct ioc_compat_policy_params *compat_pol_params = NULL;
+	struct ioc_compat_dpa_ipsec_add_rem_policy compat_uparam;
+	int i;
+#endif
+	int sa_id, num_pol, err = 0;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+			pr_err("Could not copy params for policy retrieval");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_get_pols(&prm, &compat_prm,
+					       COMPAT_US_TO_K);
+	} else
+#endif
+		if (copy_from_user(&prm, args, sizeof(prm))) {
+			pr_err("Could not copy params for policy retrieval");
+			return -EINVAL;
+		}
+
+	if (prm.sa_id < 0) {
+		pr_err("Invalid input SA id\n");
+		return -EINVAL;
+	}
+
+	sa_id = prm.sa_id;
+	if (!prm.policy_params) {
+		err = dpa_ipsec_sa_get_policies(sa_id, NULL, &num_pol);
+		if (err < 0) {
+			pr_err("Get policies count failed\n");
+			return err;
+		}
+
+		prm.num_pol = num_pol;
+#ifdef CONFIG_COMPAT
+		if (compat) {
+			compat_copy_dpa_ipsec_get_pols(&prm, &compat_prm,
+						       COMPAT_K_TO_US);
+		if (copy_to_user(args, &compat_prm, sizeof(compat_prm))) {
+				pr_err("Cannot copy policy count to user");
+				return -EINVAL;
+			}
+		} else
+#endif
+			if (copy_to_user(args, &prm, sizeof(prm))) {
+				pr_err("Cannot copy policy count to user");
+				return -EINVAL;
+			}
+		return 0;
+	}
+
+	num_pol = prm.num_pol;
+	if (num_pol <= 0) {
+		pr_err("Invalid number of policies for SA ID# %d\n", sa_id);
+		return -EINVAL;
+	}
+
+	policy_params =	kzalloc(num_pol * sizeof(*policy_params), GFP_KERNEL);
+	if (!policy_params) {
+		pr_err("Could not allocate memory for policy array");
+		return -ENOMEM;
+	}
+
+	err = dpa_ipsec_sa_get_policies(sa_id, policy_params, &num_pol);
+	if (err < 0 && err != -EAGAIN) {
+		pr_err("Could not retrieve SA policies");
+		goto err_pol_cleanup;
+	} else if (err == -EAGAIN)
+		pr_err("Not all SA policies could be retrieved");
+
+#ifdef CONFIG_COMPAT
+	compat_pol_params = kzalloc(num_pol * sizeof(*compat_pol_params),
+				    GFP_KERNEL);
+	if (!compat_pol_params) {
+		pr_err("Could not allocate memory for compat policy array!\n");
+		kfree(policy_params);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < num_pol; i++) {
+		memcpy(&kparam.pol_params, &policy_params[i],
+			sizeof(kparam.pol_params));
+		compat_copy_dpa_ipsec_add_rem_policy(&kparam,
+						     &compat_uparam,
+						     COMPAT_K_TO_US);
+		memcpy(&compat_pol_params[i], &compat_uparam.pol_params,
+			sizeof(compat_uparam.pol_params));
+	}
+	if (copy_to_user(prm.policy_params, compat_pol_params,
+			 num_pol * sizeof(*compat_pol_params))) {
+		pr_err("Could not return policy parameters\n");
+		err = -EINVAL;
+	}
+#else
+	if (copy_to_user(prm.policy_params, policy_params,
+			 num_pol * sizeof(*policy_params))) {
+		pr_err("Could not return policy parameters\n");
+		err = -EINVAL;
+	}
+#endif
+	/*
+	 * None of the values of the members in the input structure have been
+	 * modified, so there is no need to copy the input structure back to the
+	 * user
+	 */
+
+err_pol_cleanup:
+#ifdef CONFIG_COMPAT
+	kfree(compat_pol_params);
+#endif
+	kfree(policy_params);
+
+	return err;
+}
+
+/* Set mprm - no compat case */
+static int do_sa_modify_ioctl(unsigned long args, int *sa_id,
+			      struct dpa_ipsec_sa_modify_prm *mprm)
+{
+	struct ioc_dpa_ipsec_sa_modify_prm prm;
+
+	if (copy_from_user(&prm,
+			   (struct ioc_dpa_ipsec_sa_modify_prm *)args,
+			   sizeof(prm))) {
+		pr_err("Could not copy from user modify parameters\n");
+		return -EINVAL;
+	}
+
+	if (prm.sa_id < 0) {
+		pr_err("Invalid input SA id\n");
+		return -EINVAL;
+	}
+
+	*sa_id = prm.sa_id;
+
+	if (prm.modify_prm.type == DPA_IPSEC_SA_MODIFY_CRYPTO) {
+		struct dpa_ipsec_sa_crypto_params *crypto_prm;
+		crypto_prm = &prm.modify_prm.crypto_params;
+		mprm->crypto_params.cipher_key =
+			kmalloc(crypto_prm->cipher_key_len, GFP_KERNEL);
+		if (!mprm->crypto_params.cipher_key) {
+			pr_err("Allocation failed for cipher key\n");
+			return -ENOMEM;
+		}
+
+		mprm->crypto_params.auth_key =
+			kmalloc(crypto_prm->auth_key_len, GFP_KERNEL);
+		if (!mprm->crypto_params.auth_key) {
+			pr_err("Allocation failed for authentication key\n");
+			return -ENOMEM;
+		}
+
+		mprm->type = prm.modify_prm.type;
+		memcpy(mprm->crypto_params.cipher_key,
+		       crypto_prm->cipher_key,
+		       crypto_prm->cipher_key_len);
+		memcpy(mprm->crypto_params.auth_key,
+		       crypto_prm->auth_key,
+		       crypto_prm->auth_key_len);
+	} else {
+		memcpy(mprm, &prm.modify_prm, sizeof(prm.modify_prm));
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+/* Set mprm - compat case */
+static int do_sa_modify_ioctl_compat(unsigned long args, int *sa_id,
+				     struct dpa_ipsec_sa_modify_prm *mprm)
+{
+	struct ioc_compat_dpa_ipsec_sa_modify_prm prm;
+
+	if (copy_from_user(&prm,
+			   (struct ioc_compat_dpa_ipsec_sa_modify_prm *)args,
+			   sizeof(prm))) {
+		pr_err("Could not copy from user modify parameters\n");
+		return -EINVAL;
+	}
+
+	if (prm.sa_id < 0) {
+		pr_err("Invalid input SA id\n");
+		return -EINVAL;
+	}
+
+	*sa_id = prm.sa_id;
+
+	if (prm.modify_prm.type == DPA_IPSEC_SA_MODIFY_CRYPTO) {
+		struct ioc_compat_sa_crypto_params *crypto_prm;
+		crypto_prm = &prm.modify_prm.crypto_params;
+		mprm->crypto_params.cipher_key =
+			kmalloc(crypto_prm->cipher_key_len, GFP_KERNEL);
+		if (!mprm->crypto_params.cipher_key) {
+			pr_err("Allocation failed for cipher key\n");
+			return -ENOMEM;
+		}
+
+		mprm->crypto_params.auth_key =
+			kmalloc(crypto_prm->auth_key_len, GFP_KERNEL);
+		if (!mprm->crypto_params.auth_key) {
+			pr_err("Allocation failed for authentication key\n");
+			return -ENOMEM;
+		}
+
+		mprm->type = prm.modify_prm.type;
+		memcpy(mprm->crypto_params.cipher_key,
+		       compat_ptr(crypto_prm->cipher_key),
+		       crypto_prm->cipher_key_len);
+		memcpy(mprm->crypto_params.auth_key,
+		       compat_ptr(crypto_prm->auth_key),
+		       crypto_prm->auth_key_len);
+	} else {
+		memcpy(mprm, &prm.modify_prm, sizeof(prm.modify_prm));
+	}
+
+	return 0;
+}
+#endif
+
+int wrp_dpa_ipsec_init(void)
+{
+	/* Cannot initialize the wrapper twice */
+	if (dpa_ipsec_cdev_major >= 0)
+		return -EBUSY;
+
+	dpa_ipsec_cdev_major =
+	    register_chrdev(0, DPA_IPSEC_CDEV, &dpa_ipsec_fops);
+	if (dpa_ipsec_cdev_major < 0) {
+		pr_err("Could not register Dpa Ipsec character device");
+		return dpa_ipsec_cdev_major;
+	}
+	return 0;
+}
+
+
+int wrp_dpa_ipsec_exit(void)
+{
+	if (dpa_ipsec_cdev_major < 0)
+		return 0;
+	unregister_chrdev(dpa_ipsec_cdev_major, DPA_IPSEC_CDEV);
+	dpa_ipsec_cdev_major = -1;
+	return 0;
+}
+
+
+int wrp_dpa_ipsec_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+
+int wrp_dpa_ipsec_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
+			    unsigned long args)
+{
+	return wrp_dpa_ipsec_do_ioctl(filp, cmd, args, false);
+}
+
+#ifdef CONFIG_COMPAT
+long wrp_dpa_ipsec_ioctl_compat(struct file *filp, unsigned int cmd,
+				unsigned long args)
+{
+	return wrp_dpa_ipsec_do_ioctl(filp, cmd, args, true);
+}
+#endif
+
+long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long args, bool compat)
+{
+	long ret = 0;
+	int err = 0;
+
+	switch (cmd) {
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_INIT_COMPAT:
+#endif
+	case DPA_IPSEC_IOC_INIT: {
+		ret = do_init_ioctl((void *)args, compat);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_FREE: {
+		int dpa_ipsec_id;
+		if (copy_from_user(&dpa_ipsec_id, (int *)args,
+				    sizeof(int))) {
+			pr_err("Could not copy parameters");
+			return -EINVAL;
+		}
+		err = dpa_ipsec_free(dpa_ipsec_id);
+		if (err < 0)
+			return err;
+		break;
+	}
+
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_CREATE_SA_COMPAT:
+#endif
+	case DPA_IPSEC_IOC_CREATE_SA: {
+		ret = do_create_sa_ioctl((void *)args, compat);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_REMOVE_SA: {
+		int sa_id;
+		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
+			pr_err("Could not copy parameters");
+			return -EINVAL;
+		}
+
+		err = dpa_ipsec_remove_sa(sa_id);
+		if (err < 0)
+			return err;
+		break;
+	}
+
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_ADD_POLICY_COMPAT:
+#endif
+	case DPA_IPSEC_IOC_ADD_POLICY: {
+		ret = do_add_rem_policy_ioctl((void *)args, true, compat);
+		break;
+	}
+
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_REMOVE_POLICY_COMPAT:
+#endif
+	case DPA_IPSEC_IOC_REMOVE_POLICY: {
+		ret = do_add_rem_policy_ioctl((void *)args, false, compat);
+		break;
+	}
+
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_SA_REKEYING_COMPAT:
+#endif
+	case DPA_IPSEC_IOC_SA_REKEYING: {
+		ret = do_sa_rekey_ioctl((void *)args, compat);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_FLUSH_ALL_SA: {
+		int dpa_ipsec_id;
+
+		if (copy_from_user(&dpa_ipsec_id,
+				    (int *)args, sizeof(int))) {
+			pr_err("Could not copy parameters");
+			return -EINVAL;
+		}
+
+		err = dpa_ipsec_flush_all_sa(dpa_ipsec_id);
+		if (err < 0)
+			return err;
+		break;
+	}
+
+#ifdef CONFIG_COMPAT
+	case DPA_IPSEC_IOC_GET_SA_POLICIES_COMPAT:
+#endif
+	case DPA_IPSEC_IOC_GET_SA_POLICIES: {
+		ret = do_sa_get_policies_ioctl((void *)args, compat);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_FLUSH_SA_POLICIES: {
+		int sa_id;
+
+		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
+			pr_err("Could not copy SA id");
+			return -EINVAL;
+		}
+
+		err = dpa_ipsec_sa_flush_policies(sa_id);
+		if (err < 0)
+			return err;
+		break;
+	}
+
+	case DPA_IPSEC_IOC_DISABLE_SA: {
+		int sa_id;
+
+		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
+			pr_err("Could not copy SA id\n");
+			return -EINVAL;
+		}
+
+		err = dpa_ipsec_disable_sa(sa_id);
+		if (err < 0)
+			return err;
+		break;
+	}
+
+	case DPA_IPSEC_IOC_GET_SA_STATS: {
+		struct ioc_dpa_ipsec_sa_get_stats prm;
+
+		if (copy_from_user(&prm,
+				(struct ioc_dpa_ipsec_sa_get_stats *)args,
+				sizeof(prm))) {
+			pr_err("Could not copy from user stats params");
+			return -EINVAL;
+		}
+
+		if (prm.sa_id < 0) {
+			pr_err("Invalid input SA id\n");
+			return -EINVAL;
+		}
+
+		err = dpa_ipsec_sa_get_stats(prm.sa_id, &prm.sa_stats);
+		if (err < 0) {
+			pr_err("Getting stats failed\n");
+			return err;
+		}
+
+		if (copy_to_user((struct ioc_dpa_ipsec_sa_get_stats *)args,
+				 &prm, sizeof(prm))) {
+			pr_err("Could not copy stats to user\n");
+			return -EINVAL;
+		}
+
+		break;
+	}
+
+	case DPA_IPSEC_IOC_SA_MODIFY: {
+		struct dpa_ipsec_sa_modify_prm modify_prm;
+		int sa_id, ret;
+
+#ifdef CONFIG_COMPAT
+		if (compat)
+			ret = do_sa_modify_ioctl_compat(args, &sa_id,
+							&modify_prm);
+		else
+#endif /* CONFIG_COMPAT */
+		ret = do_sa_modify_ioctl(args, &sa_id, &modify_prm);
+
+		if (IS_ERR_VALUE(ret))
+			goto free;
+
+		ret = dpa_ipsec_sa_modify(sa_id, &modify_prm);
+		if (IS_ERR_VALUE(ret))
+			pr_err("Modifying SA %d failed\n", sa_id);
+free:
+		if (modify_prm.type == DPA_IPSEC_SA_MODIFY_CRYPTO) {
+			kfree(modify_prm.crypto_params.cipher_key);
+			kfree(modify_prm.crypto_params.auth_key);
+		}
+
+		break;
+	}
+	default:
+		pr_err("Invalid DPA IPsec ioctl\n");
+		break;
+	}
+
+	return ret;
+}
+
+
+int default_rekey_event_cb(int dpa_ipsec_id, int sa_id, int error)
+{
+	pr_info("DPA IPSec Instance %d || new sa_id %d || error %d\n",
+		dpa_ipsec_id, sa_id, error);
+	return 0;
+}
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h
new file mode 100644
index 0000000..f67abad
--- /dev/null
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.h
@@ -0,0 +1,60 @@
+
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef WRP_DPA_IPSEC_H_
+#define WRP_DPA_IPSEC_H_
+
+#include <linux/fs.h>
+
+
+#define DPA_IPSEC_CDEV					"dpa_ipsec"
+
+
+int wrp_dpa_ipsec_init(void);
+
+int wrp_dpa_ipsec_exit(void);
+
+int wrp_dpa_ipsec_open(struct inode *inode, struct file *filp);
+
+int wrp_dpa_ipsec_release(struct inode *inode, struct file *filp);
+
+long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
+			 unsigned long args);
+
+#ifdef CONFIG_COMPAT
+long wrp_dpa_ipsec_ioctl_compat(struct file *filp, unsigned int cmd,
+				unsigned long args);
+#endif
+
+int default_rekey_event_cb(int dpa_ipsec_id, int sa_id, int error);
+
+#endif	/* WRP_DPA_IPSEC_H_ */
-- 
1.9.1

