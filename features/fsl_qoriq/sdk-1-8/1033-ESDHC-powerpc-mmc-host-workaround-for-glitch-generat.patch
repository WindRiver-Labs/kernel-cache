From cb2226d9d96a6e50743cea2c563b1b9520b23abb Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Wed, 3 Sep 2014 17:20:26 +0800
Subject: [PATCH 1033/1094] ESDHC-powerpc mmc:host workaround for glitch
 generated when clock changed

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

A-005055: SDHC: Glitch is generated on the card clock with software reset or
clock divider change.

A simple workaround is to disable the SD card clock before the software reset,
and enable it when the module resumes normal operation.The Host and the SD card
are in a master-slave relationship. The Host provides clock and control
transfer across the interface. Therefore, any existing operation is discarded
when the Host controller is reset.
The recommended flow is as follows:
1. Software disable bit[3], SDCLKEN, of the System Control Register
2. Trigger software reset and/or set clock divider
3. Check bit[3], SDSTB, of the Present State Register for stable clock
4. Enable bit[3], SDCLKEN, of the System Control Register
Using the above method, the eSDHC cannot send command or transfer data when
there is a glitch in the clock line, and the glitch does not cause any issue.

In case the reason of Reset All command, we use reset data and reset command
to instead.
In case the reason of Clock change, this situation can only be occurred in card
setup phases, so just go idle state and re-init the card(Card detect can do
this for us).

Signed-off-by: Jerry Huang <Chang-Ming.Huang@freescale.com>
Signed-off-by: Haijun Zhang <haijun.zhang@freescale.com>
Change-Id: I1add2738ecf77369adc9f30718bd6a6e08ee4f17
Reviewed-on: http://git.am.freescale.net:8181/569
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
[Fix context to apply to WRL.]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/mmc/host/sdhci-of-esdhc.c | 24 ++++++++++++++++++++++++
 drivers/mmc/host/sdhci-pltfm.c    |  9 +++++++++
 drivers/mmc/host/sdhci.h          |  2 ++
 3 files changed, 35 insertions(+)

diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c
index 2a98777..06fecbe 100644
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@ -139,6 +139,15 @@ static void esdhc_writeb(struct sdhci_host *host, u8 val, int reg)
 	/* Prevent SDHCI core from writing reserved bits (e.g. HISPD). */
 	if (reg == SDHCI_HOST_CONTROL)
 		val &= ~ESDHC_HOST_CONTROL_RES;
+
+	/* If we have this quirk just use reset cmd and reset data to
+	 * instead of reset all.
+	 */
+	if ((reg == SDHCI_SOFTWARE_RESET) &&
+			(host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL) &&
+			(val & SDHCI_RESET_ALL))
+		val = SDHCI_RESET_CMD | SDHCI_RESET_DATA;
+
 	sdhci_be32bs_writeb(host, val, reg);
 }
 
@@ -241,6 +250,19 @@ static void esdhc_of_set_clock(struct sdhci_host *host, unsigned int clock)
 	mdelay(1);
 }
 
+static u32 clock;
+static void esdhc_of_platform_reset_enter(struct sdhci_host *host, u8 mask)
+{
+	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
+		clock = host->clock;
+}
+
+static void esdhc_of_platform_reset_exit(struct sdhci_host *host, u8 mask)
+{
+	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
+		host->clock = clock;
+}
+
 static void esdhc_of_platform_init(struct sdhci_host *host)
 {
 	u32 vvn;
@@ -320,6 +342,8 @@ static const struct sdhci_ops sdhci_esdhc_ops = {
 	.enable_dma = esdhc_of_enable_dma,
 	.get_max_clock = esdhc_of_get_max_clock,
 	.get_min_clock = esdhc_of_get_min_clock,
+	.platform_reset_enter = esdhc_of_platform_reset_enter,
+	.platform_reset_exit = esdhc_of_platform_reset_exit,
 	.platform_init = esdhc_of_platform_init,
 	.get_cd = esdhc_of_get_cd,
 	.adma_workaround = esdhci_of_adma_workaround,
diff --git a/drivers/mmc/host/sdhci-pltfm.c b/drivers/mmc/host/sdhci-pltfm.c
index a207f5a..275f071 100644
--- a/drivers/mmc/host/sdhci-pltfm.c
+++ b/drivers/mmc/host/sdhci-pltfm.c
@@ -101,6 +101,15 @@ void sdhci_get_of_property(struct platform_device *pdev)
 	    of_device_is_compatible(np, "fsl,mpc8536-esdhc"))
 		host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
 
+	if (of_device_is_compatible(np, "fsl,t4240-esdhc"))
+		host->quirks2 |= SDHCI_QUIRK2_BROKEN_RESET_ALL;
+
+	if (of_device_is_compatible(np, "fsl,p4860-rev1-esdhc") ||
+	    of_device_is_compatible(np, "fsl,p1010-esdhc") ||
+	    of_device_is_compatible(np, "fsl,p2041-esdhc") ||
+	    of_device_is_compatible(np, "fsl,p3041-esdhc"))
+		host->quirks2 |= SDHCI_QUIRK2_BROKEN_RESET_ALL;
+
 	clk = of_get_property(np, "clock-frequency", &size);
 	if (clk && size == sizeof(*clk) && *clk)
 		pltfm_host->clock = be32_to_cpup(clk);
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index e639b7f..cc14016 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -409,6 +409,8 @@ struct sdhci_host {
 #define SDHCI_QUIRK2_SUPPORT_SINGLE			(1<<13)
 /* Controller broken with using ACMD23 */
 #define SDHCI_QUIRK2_ACMD23_BROKEN			(1<<14)
+/* Controller can't perform reset all successfully */
+#define SDHCI_QUIRK2_BROKEN_RESET_ALL			(1U<<31)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
-- 
2.0.2

