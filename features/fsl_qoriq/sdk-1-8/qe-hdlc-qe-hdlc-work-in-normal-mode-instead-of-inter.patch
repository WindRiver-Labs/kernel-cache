From 6461ed836bf00c640b75f7fe7b1c9ff3f0775fe6 Mon Sep 17 00:00:00 2001
From: Zhao Qiang <B45475@freescale.com>
Date: Wed, 17 Sep 2014 16:00:27 +0800
Subject: [PATCH 29/57] qe-hdlc: qe-hdlc work in normal mode instead of
 internal-loopback mode

qe-hdlc worked in internal-loopback without TDMR ds26522,
now it can work with TDMR ds26522 in normal mode,
so modify it to normal mode.

Signed-off-by: Zhao Qiang <B45475@freescale.com>
Change-Id: I7eeb4ec196d74cb53f3bffced0889637c72ed5d6
Reviewed-on: http://git.am.freescale.net:8181/19008
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Xiaobo Xie <X.Xie@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Original patch taken from QorIQ-SDK-V1.8-20150619-yocto.]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/powerpc/boot/dts/t1040rdb.dts |   10 +++++-----
 drivers/net/wan/fsl_ucc_hdlc.c     |   27 ++++++++++++++++-----------
 2 files changed, 21 insertions(+), 16 deletions(-)

diff --git a/arch/powerpc/boot/dts/t1040rdb.dts b/arch/powerpc/boot/dts/t1040rdb.dts
index 5695fbc..6e085a8 100644
--- a/arch/powerpc/boot/dts/t1040rdb.dts
+++ b/arch/powerpc/boot/dts/t1040rdb.dts
@@ -405,17 +405,17 @@
 
 		ucc@2200 {
 			compatible = "fsl,ucc_hdlc";
-			rx-clock-name = "brg2";
-			tx-clock-name = "brg2";
-			fsl,rx-sync-clock = "none";
-			fsl,tx-sync-clock = "none";
+			rx-clock-name = "clk10";
+			tx-clock-name = "clk11";
+			fsl,rx-sync-clock = "rsync_pin";
+			fsl,tx-sync-clock = "tsync_pin";
 			fsl,tx-timeslot = <0xfffffffe>;
 			fsl,rx-timeslot = <0xfffffffe>;
 			fsl,tdm-framer-type = "e1";
 			fsl,tdm-mode = "normal";
 			fsl,tdm-id = <1>;
 			fsl,siram-entry-id = <2>;
-			fsl,inter-loopback;
+			fsl,tdm-interface;
 		};
 	};
 };
diff --git a/drivers/net/wan/fsl_ucc_hdlc.c b/drivers/net/wan/fsl_ucc_hdlc.c
index 0c8cac6..8471dfa 100644
--- a/drivers/net/wan/fsl_ucc_hdlc.c
+++ b/drivers/net/wan/fsl_ucc_hdlc.c
@@ -35,6 +35,7 @@
 #define DRV_NAME "ucc_hdlc"
 
 #undef DEBUG
+/* #define QE_HDLC_TEST */
 
 static struct ucc_hdlc_info uhdlc_primary_info = {
 	.uf_info = {
@@ -60,7 +61,11 @@ static struct ucc_hdlc_info uhdlc_primary_info = {
 	},
 
 	.si_info = {
+#ifdef CONFIG_FSL_PQ_MDS_T1
 		.simr_rfsd = 1,		/* TDM card need 1 bit delay */
+#else
+		.simr_rfsd = 0,
+#endif
 		.simr_tfsd = 0,
 		.simr_crt = 0,
 		.simr_sl = 0,
@@ -417,7 +422,7 @@ static int uhdlc_init(struct ucc_hdlc_private *priv)
 		goto riptr_alloc_error;
 	}
 
-	tiptr = qe_muram_alloc(32, 32);
+	tiptr = qe_muram_alloc(64, 32);
 	if (IS_ERR_VALUE(tiptr)) {
 		dev_err(priv->dev, "Cannot allocate MURAM mem for transmit internal temp data pointer\n");
 		ret = -ENOMEM;
@@ -535,11 +540,11 @@ static netdev_tx_t ucc_hdlc_tx(struct sk_buff *skb, struct net_device *dev)
 
 	send_buf = (u8 *)skb->data;
 
-	if (priv->loopback) {
-		pr_info("\nTransmitted data:\n");
-		for (i = 0; (i < 16); i++)
-			pr_info("%x ", send_buf[i]);
-	}
+#ifdef QE_HDLC_TEST
+	pr_info("\nTransmitted data:\n");
+	for (i = 0; (i < 16); i++)
+		pr_info("%x ", send_buf[i]);
+#endif
 
 	/* Start from the next BD that should be filled */
 	bd = priv->curtx_bd;
@@ -640,11 +645,11 @@ static int hdlc_rx_done(struct ucc_hdlc_private *priv, int rx_work_limit)
 			(priv->currx_bdnum * MAX_RX_BUF_LENGTH);
 		length = (u16) (bd_status & BD_LENGTH_MASK);
 
-		if (priv->loopback) {
-			pr_info("\nReceived data:\n");
-			for (i = 0; (i < 16); i++)
-				pr_info("%x ", bdbuffer[i]);
-		}
+#ifdef QE_HDLC_TEST
+		pr_info("\nReceived data:\n");
+		for (i = 0; (i < 16); i++)
+			pr_info("%x ", bdbuffer[i]);
+#endif
 
 		bdbuffer += HDLC_HEAD_LEN;
 		length -= (HDLC_HEAD_LEN + HDLC_CRC_SIZE);
-- 
1.7.5.4

