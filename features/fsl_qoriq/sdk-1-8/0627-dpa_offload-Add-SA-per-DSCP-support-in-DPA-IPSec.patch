From fb1f91dfd1fc51cf7152325e440362c6a49f8b14 Mon Sep 17 00:00:00 2001
From: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Date: Tue, 18 Mar 2014 16:53:06 +0200
Subject: [PATCH 627/987] dpa_offload: Add SA per DSCP support in DPA IPSec

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

If different classes of traffic defined by DSCP are sent on the same SA
and if the receiver is using an optional anti-replay feature, this could
result in discarding lower priority packets. To avoid this, the sender
should send traffic with different classes, but the same selector values
on different SA's in order to support QoS appropriately. The IPSec
implementation must permit establishment and maitenance of multuple SA's
between sender and receiver, with the same selectors. The receiver must
process the packets from the different SAs without prejudice. These
requirements apply to both transport and tunnel mode SA's. (RFC-4301)

On IPSec inbound path there are no needed modifcations in order to
support this feature. The idea behind this feature is to direct outbount
traffic with different DSCP to different outbound SA's, even if it has
the same SA selector with the rest of the traffic.

On the outbound direction the selectors for the policies are partially
custom. Now the user can select fields from the following group of
supported fields:

	* IPSA (supports mask)
	* IPDA (supports mask)
	* IPPROTO
	* DSCP
	* SPORT (for TCP/UDP/SCTP)
	* DPORT (for TCP/UDP/SCTP)
	* ICMP_TYPE
	* ICMP_CODE

The format of the key is fixed and cannot be modified, but the user has
the possibility to mask the fields wants to use in the policy selector.
For the DSCP field, the user can set a range of values between
dscp_start and dscp_end. The DPA IPSec will create a policy selector for
every DSCP value entered by the user. In case dscp_start equals
dscp_end, only one policy will be added.
This requires the user to properly configure the outbound pre-SEC CC
nodes to generate the key using also the DSCP field.
The statistics returned for the SA with a range of DSCP values defined,
will totalize the statistics for every policy selector.

Change-Id: I96c1629ca2d52bc6023af494929e27865348230a
Signed-off-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/9874
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Andrei Varvara <andrei.varvara@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c | 220 ++++++++++++++++++++++------
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h |  13 +-
 include/linux/fsl_dpa_ipsec.h               |  17 ++-
 3 files changed, 198 insertions(+), 52 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 7b64293..f6fcdbd 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -440,6 +440,9 @@ static void calc_in_pol_key_size(struct dpa_ipsec *dpa_ipsec, uint8_t *key_size)
 		case DPA_IPSEC_KEY_FIELD_DPORT:
 			*key_size += PORT_FIELD_LEN;
 			break;
+		case DPA_IPSEC_KEY_FIELD_DSCP:
+			*key_size += DSCP_FIELD_LEN;
+			break;
 		}
 	}
 }
@@ -1347,7 +1350,8 @@ static int set_flow_id_action(struct dpa_ipsec_sa *sa,
 static int fill_policy_key(int td,
 			   struct dpa_ipsec_policy_params *pol_params,
 			   uint8_t key_fields,
-			   uint8_t *key, uint8_t *mask, uint8_t *key_len)
+			   uint8_t *key, uint8_t *mask, uint8_t *key_len,
+			   uint8_t dscp_value)
 {
 	struct dpa_cls_tbl_params tbl_params;
 	uint8_t offset = 0, field_mask = 0, tbl_key_size = 0;
@@ -1429,6 +1433,17 @@ static int fill_policy_key(int td,
 				offset += PORT_FIELD_LEN;
 			}
 			break;
+
+		case DPA_IPSEC_KEY_FIELD_DSCP:
+			if (pol_params->use_dscp) {
+				*(uint8_t *)(key + offset) = dscp_value << 2;
+				SET_BYTE_VAL_IN_ARRAY(mask, offset, 0xFC);
+			} else {
+				*(uint8_t *)(key + offset) = 0;
+				SET_BYTE_VAL_IN_ARRAY(mask, offset, 0);
+			}
+			offset += DSCP_FIELD_LEN;
+			break;
 		}
 	}
 
@@ -1741,7 +1756,7 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 				      pol_params,
 				      dpa_ipsec->config.post_sec_in_params.
 				      key_fields, tbl_key.byte, tbl_key.mask,
-				      &key_len);
+				      &key_len, 0);
 		if (err < 0)
 			return err;
 
@@ -1759,10 +1774,10 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 			log_err("Could not insert key in EM table\n");
 			return err;
 		}
-		policy_entry->entry_id = entry_id;
+		*policy_entry->entry_id = entry_id;
 		break;
 	case MNG_OP_REMOVE:
-		entry_id = policy_entry->entry_id;
+		entry_id = *policy_entry->entry_id;
 		err = dpa_classif_table_delete_entry_by_ref(sa->em_inpol_td,
 							    entry_id);
 		if (err < 0) {
@@ -1778,6 +1793,25 @@ static int update_inbound_policy(struct dpa_ipsec_sa *sa,
 	return 0;
 }
 
+static inline int remove_dscp_policy(struct dpa_ipsec_sa *sa,
+				     struct dpa_ipsec_policy_entry *pol_entry,
+				     int table)
+{
+	int dscp_idx = 0, err = 0, ret = 0;
+	do {
+		ret = dpa_classif_table_delete_entry_by_ref(
+						table,
+						pol_entry->entry_id[dscp_idx]);
+		if (ret < 0) {
+			log_err("Cannot remove key from EM table\n");
+			err = ret;
+		}
+		dscp_idx += 1;
+	} while (dscp_idx <= sa->dscp_end - sa->dscp_start);
+
+	return err;
+}
+
 static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 				  struct dpa_ipsec_policy_entry *policy_entry,
 				  enum mng_op_type op_type)
@@ -1785,11 +1819,11 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_pre_sec_out_params *pre_sec_out_params;
 	struct dpa_ipsec_policy_params *pol_params;
-	uint8_t key_len, table_idx, key_fields;
+	uint8_t key_len, table_idx, key_fields, dscp_value;
 	struct dpa_offload_lookup_key tbl_key;
 	struct dpa_cls_tbl_action action;
 	struct dpa_cls_tbl_entry_mod_params params;
-	int table, err;
+	int table, err, dscp_idx = 0;
 	int manip_hmd = DPA_OFFLD_DESC_NONE, pol_hmd = DPA_OFFLD_DESC_NONE;
 	uint8_t key_data[DPA_OFFLD_MAXENTRYKEYSIZE];
 	uint8_t mask_data[DPA_OFFLD_MAXENTRYKEYSIZE];
@@ -1822,24 +1856,10 @@ static int update_outbound_policy(struct dpa_ipsec_sa *sa,
 
 	switch (op_type) {
 	case MNG_OP_ADD:
+		dscp_value = sa->dscp_start;
 		tbl_key.byte = key_data;
 		tbl_key.mask = mask_data;
 
-		/*
-		 * Key may contain:
-		 * IP SRC ADDR  - from Policy handle
-		 * IP DST ADDR  - from Policy handle
-		 * IP_PROTO     - from Policy handle
-		 * SRC_PORT     - from Policy handle (for UDP & TCP & SCTP)
-		 * DST_PORT     - from Policy handle (for UDP & TCP & SCTP)
-		 */
-		err = fill_policy_key(table, pol_params, key_fields,
-				tbl_key.byte, tbl_key.mask, &key_len);
-		if (err < 0)
-			return err;
-
-		tbl_key.size = key_len;
-
 		/* Configure fragmentation */
 		if (pol_params->dir_params.type ==
 					DPA_IPSEC_POL_DIR_PARAMS_MANIP) {
@@ -1900,21 +1920,80 @@ set_manipulation:
 		fill_cls_action_enq(&action,
 				    sa->enable_extended_stats ? true : false,
 				    qman_fq_fqid(sa->to_sec_fq), pol_hmd);
+		/*
+		 * Key may contain:
+		 * IP SRC ADDR  - from Policy handle
+		 * IP DST ADDR  - from Policy handle
+		 * IP_PROTO     - from Policy handle
+		 * DSCP         - from Policy handle
+		 * SRC_PORT     - from Policy handle (for UDP & TCP & SCTP)
+		 * DST_PORT     - from Policy handle (for UDP & TCP & SCTP)
+		 */
 
-		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
-					      policy_entry->pol_params.priority,
-					      &policy_entry->entry_id);
-		if (err < 0) {
-			log_err("Could not add key in exact match table\n");
-			return err;
+		/*
+		 * If SA per DSCP feature is disabled only one key is inserted
+		 * and then will go out
+		 */
+		if (!pol_params->use_dscp) {
+			err = fill_policy_key(table, pol_params, key_fields,
+					      tbl_key.byte, tbl_key.mask,
+					      &key_len, 0);
+			if (err < 0)
+				return err;
+
+			tbl_key.size = key_len;
+
+			err = dpa_classif_table_insert_entry(table, &tbl_key,
+					&action,
+					policy_entry->pol_params.priority,
+					&policy_entry->entry_id[dscp_idx]);
+			if (err < 0) {
+				log_err("Could not add key in exact match table\n");
+				return err;
+			}
+			break;
 		}
+
+		/*
+		 * In case the SA per DSCP feature will be used, it will iterate
+		 * through all DSCP values and insert a key for each one.
+		 */
+		do {
+			err = fill_policy_key(table, pol_params, key_fields,
+					      tbl_key.byte, tbl_key.mask,
+					      &key_len, dscp_value);
+			if (err < 0)
+				return err;
+
+			tbl_key.size = key_len;
+
+			err = dpa_classif_table_insert_entry(table, &tbl_key,
+					&action,
+					policy_entry->pol_params.priority,
+					&policy_entry->entry_id[dscp_idx]);
+			if (err < 0) {
+				log_err("Could not add key in exact match table\n");
+				return err;
+			}
+
+			dscp_value += 1;
+			dscp_idx += 1;
+		} while (dscp_value <= sa->dscp_end);
+
 		break;
 	case MNG_OP_REMOVE:
-		err = dpa_classif_table_delete_entry_by_ref(table,
-							policy_entry->entry_id);
-		if (err < 0) {
-			log_err("Could not remove key from EM table\n");
-			return err;
+		if (pol_params->use_dscp) {
+			err = remove_dscp_policy(sa, policy_entry, table);
+			if (err < 0)
+				return err;
+
+		} else {
+			err = dpa_classif_table_delete_entry_by_ref(table,
+					*policy_entry->entry_id);
+			if (err < 0) {
+				log_err("Could not remove key from EM table\n");
+				return err;
+			}
 		}
 
 		if (policy_entry->hmd != DPA_OFFLD_DESC_NONE) {
@@ -1947,8 +2026,8 @@ set_manipulation:
 		params.action = &action;
 
 		err = dpa_classif_table_modify_entry_by_ref(table,
-							 policy_entry->entry_id,
-							 &params);
+							*policy_entry->entry_id,
+							&params);
 		if (err < 0) {
 			log_err("Could not modify key in EM table\n");
 			return err;
@@ -2599,6 +2678,15 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 	sa->l2_hdr_size = sa_params->l2_hdr_size;
 	sa->enable_stats = sa_params->enable_stats;
 	sa->enable_extended_stats = sa_params->enable_extended_stats;
+	if (sa_params->sa_out_params.dscp_end <
+					sa_params->sa_out_params.dscp_start) {
+		log_err("Wrong DSCP interval, dscp_start (%d) cannot be greater than dscp_end (%d)\n",
+			 sa_params->sa_out_params.dscp_start,
+			 sa_params->sa_out_params.dscp_end);
+		return -EINVAL;
+	}
+	sa->dscp_start = sa_params->sa_out_params.dscp_start;
+	sa->dscp_end = sa_params->sa_out_params.dscp_end;
 #ifdef DEBUG_PARAM
 	/* Printing all the parameters */
 	print_sa_sec_param(sa);
@@ -2824,6 +2912,7 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 {
 	struct dpa_ipsec_policy_entry *pol_entry;
 	struct dpa_ipsec_pol_dir_params *dir = NULL;
+	int size = 1; /* By default the size of the entry_id array is one */
 
 	BUG_ON(!sa);
 	BUG_ON(!policy_params);
@@ -2860,6 +2949,15 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 		       enq_params.policer_params = plcr;
 	}
 
+	if (policy_params->use_dscp)
+		size = sa->dscp_end - sa->dscp_start + 1;
+
+	/*
+	 * allocate memory for entry id: a single value or an array in case
+	 * of SA per DSCP
+	 */
+	pol_entry->entry_id = kcalloc(size, sizeof(int), GFP_KERNEL);
+
 	/* add policy to the SA's policy list */
 	list_add(&pol_entry->node, &sa->policy_headlist);
 
@@ -3028,6 +3126,8 @@ static int remove_policy_from_sa_policy_list(struct dpa_ipsec_sa *sa,
 	    dir->in_action.enq_params.policer_params)
 		kfree(dir->in_action.enq_params.policer_params);
 
+	/* release memory used for holding policy entry id array*/
+	kfree(policy_entry->entry_id);
 	/* release memory used for holding policy general parameters */
 	kfree(policy_entry);
 
@@ -5152,7 +5252,7 @@ int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats)
 {
 	struct dpa_ipsec *dpa_ipsec;
 	struct dpa_ipsec_sa *sa;
-	int ret = 0;
+	int ret = 0, dscp_idx = 0;
 	uint32_t *desc;
 	struct dpa_cls_tbl_entry_stats stats;
 
@@ -5246,18 +5346,50 @@ int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats)
 						policy_params->protocol,
 						IPV6);
 			td = psop->table[table_idx].dpa_cls_td;
-			ret = dpa_classif_table_get_entry_stats_by_ref(
+
+			/*
+			 * In case the SA per DSCP feature is disabled, will
+			 * acquire statistics for the policy and exit
+			 */
+			if (!policy_params->use_dscp) {
+				ret = dpa_classif_table_get_entry_stats_by_ref(
 						td,
-						out_policy->entry_id,
+						*out_policy->entry_id,
 						&stats);
-			if (ret != 0) {
-				log_err("Failed to acquire total packets counter for outbound SA Id=%d. Failure occured on outbound policy table %d (td=%d).\n",
-					sa_id, table_idx, td);
-				mutex_unlock(&sa->lock);
-				goto out;
-			} else {
-				sa_stats->input_packets	+= stats.pkts;
+				if (ret != 0) {
+					log_err("Failed to acquire total packets counter for outbound SA Id=%d. Failure occured on outbound policy table %d (td=%d).\n",
+						sa_id, table_idx, td);
+					mutex_unlock(&sa->lock);
+					goto out;
+				} else {
+					sa_stats->input_packets	+= stats.pkts;
+					goto sa_get_stats_return;
+				}
 			}
+
+			/*
+			 * In case the SA per DSCP feature is enabled, will
+			 * iterate through all DSCP values defined for the
+			 * SA and totalize statistics
+			 */
+			do {
+				ret = dpa_classif_table_get_entry_stats_by_ref(
+						td,
+						out_policy->entry_id[dscp_idx],
+						&stats);
+
+				if (ret != 0) {
+					/*
+					 * In case of error just print the
+					 * message and get to the next value
+					 */
+					log_err("Failed to acquire packets counter for outbound SA Id=%d. Failure occured on outbound policy table %d (td=%d).\n",
+							sa_id, table_idx, td);
+				} else {
+					sa_stats->input_packets	+= stats.pkts;
+				}
+				dscp_idx += 1;
+			} while (dscp_idx <= sa->dscp_end - sa->dscp_start);
 		}
 	}
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 79b1184..353c817 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -300,6 +300,8 @@ struct dpa_ipsec_sa {
 	dpa_ipsec_rekey_event_cb rekey_event_cb;
 	uint32_t l2_hdr_size; /* Size of the Ethernet header, including any
 			      * VLAN information.			      */
+	uint8_t dscp_start; /* DSCP range start value */
+	uint8_t dscp_end; /* DSCP range end value */
 	struct mutex lock; /* Lock for this SA structure */
 };
 
@@ -386,8 +388,11 @@ struct hmd_entry {
 
 /* DPA IPSEC - Security Policy Parameter Entry */
 struct dpa_ipsec_policy_entry {
-	struct dpa_ipsec_policy_params pol_params; /* Policy parameters       */
-	int entry_id;		/* Set by dpa_classif_table_insert_entry      */
+	/* Policy parameters */
+	struct dpa_ipsec_policy_params pol_params;
+
+	/* Entry id array that is set by dpa_classif_table_insert_entry */
+	int *entry_id;
 
 	/*
 	 * Header manip for IPSec special operation or
@@ -401,7 +406,9 @@ struct dpa_ipsec_policy_entry {
 	 * is hmd refers to an outside manip object
 	 */
 	bool hmd_special_op;
-	struct list_head node;	/* Node in linked list			      */
+
+	/* Node in linked list */
+	struct list_head node;
 };
 
 void sa_rekeying_work_func(struct work_struct *work);
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 6516078..445e6ce 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -43,6 +43,7 @@
 #define ESP_SPI_FIELD_LEN		4
 #define PORT_FIELD_LEN			2
 #define ICMP_HDR_FIELD_LEN		1
+#define DSCP_FIELD_LEN			1
 
 #define MAX_SIZE_IP_UDP_SPI_KEY	\
 		(1 * DPA_OFFLD_IPv6_ADDR_LEN_BYTES + \
@@ -89,11 +90,12 @@
 #define DPA_IPSEC_KEY_FIELD_SIP		0x01 /* Use source IP address in key  */
 #define DPA_IPSEC_KEY_FIELD_DIP		0x02 /* Use destination IP in key     */
 #define	DPA_IPSEC_KEY_FIELD_PROTO	0x04 /* Use IP protocol field in key  */
-#define DPA_IPSEC_KEY_FIELD_SPORT	0x08 /* Use source port in key        */
-#define DPA_IPSEC_KEY_FIELD_ICMP_TYPE	0x08 /* Use ICMP type field in key    */
-#define DPA_IPSEC_KEY_FIELD_DPORT	0x10 /* Use destination port in key   */
-#define DPA_IPSEC_KEY_FIELD_ICMP_CODE	0x10 /* Use ICMP code field in key    */
-#define	DPA_IPSEC_MAX_KEY_FIELDS	5    /* Maximum key components        */
+#define DPA_IPSEC_KEY_FIELD_DSCP	0x08 /* Use DSCP field in key         */
+#define DPA_IPSEC_KEY_FIELD_SPORT	0x10 /* Use source port in key        */
+#define DPA_IPSEC_KEY_FIELD_ICMP_TYPE	0x10 /* Use ICMP type field in key    */
+#define DPA_IPSEC_KEY_FIELD_DPORT	0x20 /* Use destination port in key   */
+#define DPA_IPSEC_KEY_FIELD_ICMP_CODE	0x20 /* Use ICMP code field in key    */
+#define	DPA_IPSEC_MAX_KEY_FIELDS	6    /* Maximum key components        */
 
 #define DPA_IPSEC_DEF_PAD_VAL		0xAA /* Value to be used as padding in
 					      * classification keys           */
@@ -302,6 +304,10 @@ struct dpa_ipsec_sa_out_params {
 	void *outer_udp_header;
 	/* Flow ID used to mark frames encrypted using this SA		      */
 	uint16_t post_sec_flow_id;
+	uint8_t dscp_start;	/* DSCP range start value; ignored if the DSCP
+				 * selector wasn't enabled for this SA */
+	uint8_t dscp_end;	/* DSCP range end value; ignored if the DSCP
+				 * selector wasn't enabled for this SA */
 };
 
 /* DPA-IPSec Security Association In Parameters */
@@ -464,6 +470,7 @@ struct dpa_ipsec_policy_params {
 	uint8_t dest_prefix_len; /* Destination network prefix		      */
 	uint8_t protocol;	/* Protocol				      */
 	bool masked_proto;	/* Mask the entire protocol field	      */
+	bool use_dscp;		/* Enable DSCP value in policy selector       */
 	union {
 		struct dpa_ipsec_l4_params	l4;	/* L4 protos params   */
 		struct dpa_ipsec_icmp_params	icmp;	/* ICMP proto params  */
-- 
1.9.1

