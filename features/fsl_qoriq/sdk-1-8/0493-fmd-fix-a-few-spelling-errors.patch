From 0f5a297753a2ae4b466539df70d30b3031b05118 Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Wed, 11 Dec 2013 19:33:02 +0200
Subject: [PATCH 493/987] fmd: fix a few spelling errors

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Fix some spelling errors reported by codespell.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Change-Id: Ife8a41b1439798191140e2b3abc24f75ac208553
Reviewed-on: http://git.am.freescale.net:8181/7659
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Tested-by: Jose Rivera <German.Rivera@freescale.com>
(cherry picked from commit 7ef92c5cb08d9b09436daf52f5f359294995832c)
Reviewed-on: http://git.am.freescale.net:8181/7825
---
 drivers/net/ethernet/freescale/fman/Kconfig                       | 2 +-
 .../freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c        | 2 +-
 drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c   | 8 ++++----
 drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h   | 2 +-
 .../net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd_ipc.h   | 2 +-
 drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c | 4 ++--
 drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c           | 2 +-
 drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h  | 2 +-
 drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h | 2 +-
 drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h     | 4 ++--
 drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h       | 4 ++--
 .../net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h | 2 +-
 drivers/net/ethernet/freescale/fman/src/wrapper/fman_test.c       | 4 ++--
 drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c       | 2 +-
 drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c | 6 +++---
 15 files changed, 24 insertions(+), 24 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Kconfig b/drivers/net/ethernet/freescale/fman/Kconfig
index 6bc9822..f839f4d 100644
--- a/drivers/net/ethernet/freescale/fman/Kconfig
+++ b/drivers/net/ethernet/freescale/fman/Kconfig
@@ -65,7 +65,7 @@ config FSL_FM_MAX_FRAME_SIZE
 		Configure this in relation to the maximum possible MTU of your
 		network configuration. In particular, one would need to
 		increase this value in order to use jumbo frames.
-		FSL_FM_MAX_FRAME_SIZE must accomodate the Ethernet FCS (4 bytes)
+		FSL_FM_MAX_FRAME_SIZE must accommodate the Ethernet FCS (4 bytes)
 		and one ETH+VLAN header (18 bytes), to a total of 22 bytes in
 		excess of the desired L3 MTU.
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
index 1831f09..8819f8f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
@@ -114,7 +114,7 @@ int fman_dtsec_mii_write_reg(struct dtsec_mii_reg *regs, uint8_t addr,
 	tmp = ioread32be(&regs->miimcon);
 	wmb();
 
-	/* Wait untill MII management write is complete */
+	/* Wait until MII management write is complete */
 	/* todo: a timeout could be useful here */
 	while ((ioread32be(&regs->miimind)) & MIIMIND_BUSY)
 		/* busy wait */;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
index 6bde6a0..37ff0fd 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
@@ -521,13 +521,13 @@ bool  FmPcdNetEnvIsHdrExist(t_Handle h_FmPcd, uint8_t netEnvId, e_NetHeaderType
     return FALSE;
 }
 
-uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr, bool interchangable, protocolOpt_t opt)
+uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr, bool interchangeable, protocolOpt_t opt)
 {
     uint8_t     i, k;
 
     ASSERT_COND(p_FmPcd);
 
-    if (interchangable)
+    if (interchangeable)
     {
         for (i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
                  (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
@@ -1369,7 +1369,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             {
                 /* If IPv4+Frag, we need to set 2 units - SHIM 2 and IPv4. We first set SHIM2, and than check if
                  * IPv4 exists. If so we don't need to set an extra unit
-                 * We consider as "having IPv4" any IPv4 without interchangable headers
+                 * We consider as "having IPv4" any IPv4 without interchangeable headers
                  * but including any options.  */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv4;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV4_FRAG_1;
@@ -1389,7 +1389,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             {
                 /* If IPv6+Frag, we need to set 2 units - SHIM 2 and IPv6. We first set SHIM2, and than check if
                  * IPv4 exists. If so we don't need to set an extra unit
-                 * We consider as "having IPv6" any IPv6 without interchangable headers
+                 * We consider as "having IPv6" any IPv6 without interchangeable headers
                  * but including any options.  */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv6;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV6_FRAG_1;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
index b6b9b35..965f46b 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
@@ -392,7 +392,7 @@ t_Error     PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlan
 void        FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId);
 e_NetHeaderType FmPcdGetAliasHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
 uint8_t     FmPcdNetEnvGetUnitIdForSingleHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
-uint8_t     FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr, bool interchangable, protocolOpt_t opt);
+uint8_t     FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr, bool interchangeable, protocolOpt_t opt);
 
 t_Error     FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint8_t groupId);
 t_Error     FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd_ipc.h
index 5184ce6..325d3e3 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -63,7 +63,7 @@
 *//***************************************************************************/
 typedef _Packed struct t_FmPcdIpcSwPrsLable
 {
-    uint32_t    enumHdr;                        /**< IN. The existance of this header will envoke
+    uint32_t    enumHdr;                        /**< IN. The existence of this header will invoke
                                                      the sw parser code. */
     uint8_t     indexPerHdr;                    /**< IN. Normally 0, if more than one sw parser
                                                      attachments for the same header, use this
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index edb86f6..bfa05c5 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -622,7 +622,7 @@ static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
         if (!p_DriverParams->dfltFqid && p_DriverParams->dontReleaseBuf)
         {
             /* override fmbm_tcfqid 0 with a false non-0 value. This will force FM to
-             * act acording to tfene. Otherwise, if fmbm_tcfqid is 0 the FM will release
+             * act according to tfene. Otherwise, if fmbm_tcfqid is 0 the FM will release
              * buffers to BM regardless of fmbm_tfene
              */
             WRITE_UINT32(p_FmPort->port.bmi_regs->tx.fmbm_tcfqid, 0xFFFFFF);
@@ -901,7 +901,7 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
         }
     }
 
-    /* set software parsing (address is devided in 2 since parser uses 2 byte access. */
+    /* set software parsing (address is divided in 2 since parser uses 2 byte access. */
     if (p_HdrParams->swPrsEnable)
     {
         tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index e321adb..5bb8282 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -3324,7 +3324,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         XX_Free(p_Fm->p_FmDriverParam);
         XX_Free(p_Fm->p_FmStateStruct);
         XX_Free(p_Fm);
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("cant allocate spinlock!"));
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("can't allocate spinlock!"));
         return NULL;
     }
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h
index b7128b5..0411ec1 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h
@@ -159,7 +159,7 @@ typedef struct t_FmMacStatistics {
 /* */
     uint64_t  eStatFragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
     uint64_t  eStatJabbers;            /**< Total number of packets longer than valid maximum length octets */
-    uint64_t  eStatsDropEvents;        /**< number of dropped packets due to internal errors of the MAC Client (during recieve). */
+    uint64_t  eStatsDropEvents;        /**< number of dropped packets due to internal errors of the MAC Client (during receive). */
     uint64_t  eStatCRCAlignErrors;     /**< Incremented when frames of correct length but with CRC error are received.*/
     uint64_t  eStatUndersizePkts;      /**< Incremented for frames under 64 bytes with a valid FCS and otherwise well formed;
                                             This count does not include range length errors */
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
index 6f344b8..4d05857 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
@@ -1505,7 +1505,7 @@ t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable);
 
  @Description   User may call this routine to so the driver will analyze if the
                 basic performance parameters are correct and also the driver may
-                suggest of improvments; The basic parameters are FIFO sizes, number
+                suggest of improvements; The basic parameters are FIFO sizes, number
                 of DMAs and number of TNUMs for the port.
 
                 May be used for all port types
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h
index 940087e..0419d74 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h
@@ -1023,9 +1023,9 @@ void fman_dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast,
 	bool ucast);
 
 /**
- * fman_dtsec_set_mc_promisc() - Set multicast promiscous mode
+ * fman_dtsec_set_mc_promisc() - Set multicast promiscuous mode
  * @regs:	Pointer to dTSEC register block
- * @enable:	Enable multicast promiscous mode
+ * @enable:	Enable multicast promiscuous mode
  *
  * Call this to enable/disable L2 address filtering for multicast packets.
  */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h
index fddf763..f6b69a1 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h
@@ -203,11 +203,11 @@ uint32_t fman_rtc_get_interrupt_mask(struct rtc_regs *regs);
 void fman_rtc_set_interrupt_mask(struct rtc_regs *regs, uint32_t mask);
 
 /**
- * fman_rtc_get_event() - Check if specific events occured
+ * fman_rtc_get_event() - Check if specific events occurred
  * @regs:		Pointer to RTC register block
  * @ev_mask:	a mask of the events to check
  *
- * Returns: 0 if the events did not occur. Non zero if one of the events occured
+ * Returns: 0 if the events did not occur. Non zero if one of the events occurred
  */
 uint32_t fman_rtc_get_event(struct rtc_regs *regs, uint32_t ev_mask);
 
diff --git a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
index b197b13..8383fc9 100644
--- a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
+++ b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
@@ -208,7 +208,7 @@ void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params);
  @Function	fm_port_get_buff_layout_ext_params
 
  @Description	Get data_align and manip_extra_space from the device tree
-                chosen node if aplied.
+                chosen node if applied.
                 This function will only update these two parameters.
                 When this port has no such parameters in the device tree
                 values will be set to 0.
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/fman_test.c b/drivers/net/ethernet/freescale/fman/src/wrapper/fman_test.c
index 4bd6261..7d04f20 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/fman_test.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/fman_test.c
@@ -113,7 +113,7 @@ struct fmt_port_s {
 	spinlock_t          rx_q_lock;
 	struct list_head    rx_q;
 
-	/* tx queuee for injecting trafic */
+	/* tx queuee for injecting traffic */
 	int                 num_of_tx_fqs;
 	struct fmt_fqs_s    p_tx_fqs[FMAN_TEST_MAX_TX_FQS];
 
@@ -1542,7 +1542,7 @@ ssize_t fmt_write(
 		return -EFAULT;
 	}
 
-	/* TODO: dma_map_single here (cannnot access the bpool struct) */
+	/* TODO: dma_map_single here (cannot access the bpool struct) */
 
 	/* prepare fd */
 	memset(&fd, 0, sizeof(fd));
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
index 3666f12..a540ed3 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
@@ -122,7 +122,7 @@ extern struct device_node *GetFmPortAdvArgsDevTreeNode (struct device_node *fm_n
  * Max frame size, across all interfaces.
  * Configurable from Kconfig or bootargs, to avoid allocating
  * oversized (socket) buffers when not using jumbo frames.
- * Must be large enough to accomodate the network MTU, but small enough
+ * Must be large enough to accommodate the network MTU, but small enough
  * to avoid wasting skb memory.
  *
  * Could be overridden once, at boot-time, via the
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
index 5c632ba..0ea6d1c 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
@@ -1755,7 +1755,7 @@ int fm_get_counter(void *h_fm, e_FmCounters cnt_e, uint32_t *cnt_val)
 	case (e_FM_COUNTERS_DEQ_2):
 	case (e_FM_COUNTERS_DEQ_3):
 		if (p_fm->p_FmStateStruct->revInfo.majorRev >= 6)
-			return -EINVAL; /* counter not avilable */
+			return -EINVAL; /* counter not available */
 
 	case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
 	case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
@@ -1766,7 +1766,7 @@ int fm_get_counter(void *h_fm, e_FmCounters cnt_e, uint32_t *cnt_val)
 	case (e_FM_COUNTERS_DEQ_CONFIRM):
 		if (!(ioread32be(&p_fm->p_FmQmiRegs->fmqm_gc) &
 			QMI_CFG_EN_COUNTERS))
-			return -EINVAL; /* Requested counter not avilable */
+			return -EINVAL; /* Requested counter not available */
 		break;
 	default:
 		break;
@@ -1805,5 +1805,5 @@ int fm_get_counter(void *h_fm, e_FmCounters cnt_e, uint32_t *cnt_val)
 		return 0;
 	}
 	/* should never get here */
-	return -EINVAL; /* counter not avilable */
+	return -EINVAL; /* counter not available */
 }
-- 
1.9.1

