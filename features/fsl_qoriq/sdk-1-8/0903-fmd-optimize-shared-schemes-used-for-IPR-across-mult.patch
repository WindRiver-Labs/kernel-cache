From 3d38672bd5a28462c7eb5a7d3620a147f8231069 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Mon, 16 Mar 2015 20:39:33 +0900
Subject: [PATCH 903/987] fmd: optimize shared schemes used for IPR across
 multiple ports

Change-Id: Ifb357bd9b78c06042aa6e9fbb7c50b821f955064
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/32794
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Liron Himi <Liron.Himi@freescale.com>
Reviewed-by: Pinghua An <pinghua.an@freescale.com>
Reviewed-by: Honghua Yin <Hong-Hua.Yin@freescale.com>
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../freescale/fman/Peripherals/FM/Pcd/fm_kg.c      | 24 +++++++++++++++++++++
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.c   | 25 +++++++++++++++++++---
 .../freescale/fman/Peripherals/FM/inc/fm_common.h  |  4 +++-
 3 files changed, 49 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
index cadc12a..dae5575 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
@@ -2794,6 +2794,30 @@ uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
     return FM_PCD_KG_NUM_OF_SCHEMES;
 }
 
+t_Handle FmPcdKgGetSchemeHandle(t_Handle h_FmPcd, uint8_t relativeSchemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(p_FmPcd);
+
+    /* check that schemeId is in range */
+    if (relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("relative-scheme-id %d!", relativeSchemeId));
+        return NULL;
+    }
+
+    if (!FmPcdKgIsSchemeValidSw(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]))
+        return NULL;
+
+    return &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+}
+
+bool FmPcdKgIsSchemeHasOwners(t_Handle h_Scheme)
+{
+    return (((t_FmPcdKgScheme*)h_Scheme)->owners == 0)?FALSE:TRUE;
+}
+
 t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requiredAction, uint32_t value)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
index 60a4aeb..c122787 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
@@ -4900,6 +4900,7 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv,
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
     t_FmPcdKgSchemeParams *p_SchemeParams = NULL;
+    t_Handle h_Scheme;
 
     ASSERT_COND(p_FmPcd);
     ASSERT_COND(h_NetEnv);
@@ -4909,7 +4910,23 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv,
     if (p_Manip->reassmParams.ip.h_Ipv4Scheme)
         return E_OK;
 
-    p_SchemeParams = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
+    if (isIpv4) {
+        h_Scheme = FmPcdKgGetSchemeHandle(p_FmPcd, p_Manip->reassmParams.ip.relativeSchemeId[0]);
+        if (h_Scheme) {
+            /* scheme was found */
+            p_Manip->reassmParams.ip.h_Ipv4Scheme = h_Scheme;
+            return E_OK;
+        }
+    } else {
+        h_Scheme = FmPcdKgGetSchemeHandle(p_FmPcd, p_Manip->reassmParams.ip.relativeSchemeId[1]);
+        if (h_Scheme) {
+            /* scheme was found */
+            p_Manip->reassmParams.ip.h_Ipv6Scheme = h_Scheme;
+            return E_OK;
+        }
+    }
+
+     p_SchemeParams = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
     if (!p_SchemeParams)
         RETURN_ERROR(MAJOR, E_NO_MEMORY,
                      ("Memory allocation failed for scheme"));
@@ -4950,10 +4967,12 @@ t_Error FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip)
 
     ASSERT_COND(p_Manip);
 
-    if (p_Manip->reassmParams.ip.h_Ipv4Scheme)
+    if ((p_Manip->reassmParams.ip.h_Ipv4Scheme) &&
+        !FmPcdKgIsSchemeHasOwners(p_Manip->reassmParams.ip.h_Ipv4Scheme))
         FM_PCD_KgSchemeDelete(p_Manip->reassmParams.ip.h_Ipv4Scheme);
 
-    if (p_Manip->reassmParams.ip.h_Ipv6Scheme)
+    if ((p_Manip->reassmParams.ip.h_Ipv6Scheme) &&
+        !FmPcdKgIsSchemeHasOwners(p_Manip->reassmParams.ip.h_Ipv6Scheme))
         FM_PCD_KgSchemeDelete(p_Manip->reassmParams.ip.h_Ipv6Scheme);
 
     return E_OK;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
index 67728f1..1c08bb1 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
@@ -280,7 +280,7 @@ typedef struct {
 typedef struct {
     t_FmSetParams setParams;
     t_FmGetParams getParams;
-} t_FmGetSetParams; 
+} t_FmGetSetParams;
 
 t_Error FmGetSetParams(t_Handle h_Fm, t_FmGetSetParams *p_Params);
 
@@ -701,6 +701,8 @@ void        FmPcdKgUpdateRequiredAction(t_Handle h_Scheme, uint32_t requiredActi
 bool        FmPcdKgIsDirectPlcr(t_Handle h_FmPcd, uint8_t schemeId);
 bool        FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId);
 uint16_t    FmPcdKgGetRelativeProfileId(t_Handle h_FmPcd, uint8_t schemeId);
+t_Handle    FmPcdKgGetSchemeHandle(t_Handle h_FmPcd, uint8_t relativeSchemeId);
+bool        FmPcdKgIsSchemeHasOwners(t_Handle h_Scheme);
 t_Error     FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t requiredAction, uint32_t value);
 t_Error     FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp);
 t_Error     FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
-- 
1.9.1

