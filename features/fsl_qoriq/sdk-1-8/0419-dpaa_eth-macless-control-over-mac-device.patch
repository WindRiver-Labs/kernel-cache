From f7fb5d86237040428b12205d61d8ddb5132272cf Mon Sep 17 00:00:00 2001
From: Marian Rotariu <marian.rotariu@freescale.com>
Date: Tue, 29 Oct 2013 15:56:44 +0200
Subject: [PATCH 419/987] dpaa_eth: macless control over mac device

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

This patch adds a new feature to macless DPAA Ethernet Driver. The macless
interface is now able to control a mac device through proxy DPAA Ethernet
Driver. To do that, it maintains a reference to a proxy interface.

The proxy interface offers a simple API to macless interface for start/stop and
for adding and removing mac unicast and multicast addresses.

Additionally, this patch will generalize some of mac API handlers. In previous
implementation, the mac handler and net_device structure belong to the same
network interface. With this patch, mac handler and net_device structure could
belong to different network interfaces. This is needed for the new macless
multicast capability, when the proxy interface that contains the mac device
reference should configure multicast addresses on behalf of a macless
interface.

This feature is optional and can be activated by setting "proxy" attribute in
the device tree node of the macless interfaces. Look in feature design document
for more details.

Change-Id: I92bf506324a9a834fdf27cbf989df817751b446d
Signed-off-by: Marian Rotariu <marian.rotariu@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/6102
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Ruxandra Ioana Radulescu <ruxandra.radulescu@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      |   2 +
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   |   4 +-
 .../net/ethernet/freescale/dpa/dpaa_eth_common.h   |  12 +++
 .../net/ethernet/freescale/dpa/dpaa_eth_macless.c  | 103 +++++++++++++++++++--
 .../net/ethernet/freescale/dpa/dpaa_eth_proxy.c    | 103 +++++++++++++++++++++
 drivers/net/ethernet/freescale/dpa/mac-api.c       |  41 ++++----
 drivers/net/ethernet/freescale/dpa/mac.h           |   5 +-
 7 files changed, 231 insertions(+), 39 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index dea880a..6844d9a 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -458,6 +458,8 @@ struct dpa_priv_s {
 	struct dpa_buffer_layout_s *buf_layout;
 	uint16_t rx_headroom;
 	char if_type[30];
+
+	void *peer;
 };
 
 struct fm_port_fqs {
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index b24581e..fdc0a0d 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -125,7 +125,7 @@ int __cold dpa_start(struct net_device *net_dev)
 	priv = netdev_priv(net_dev);
 	mac_dev = priv->mac_dev;
 
-	err = mac_dev->init_phy(net_dev);
+	err = mac_dev->init_phy(net_dev, priv->mac_dev);
 	if (err < 0) {
 		if (netif_msg_ifup(priv))
 			netdev_err(net_dev, "init_phy() = %d\n", err);
@@ -610,7 +610,7 @@ void dpa_set_rx_mode(struct net_device *net_dev)
 					   _errno);
 	}
 
-	_errno = priv->mac_dev->set_multi(net_dev);
+	_errno = priv->mac_dev->set_multi(net_dev, priv->mac_dev);
 	if (unlikely(_errno < 0) && netif_msg_drv(priv))
 		netdev_err(net_dev, "mac_dev->set_multi() = %d\n", _errno);
 }
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
index 6ee9825..9964915 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
@@ -125,4 +125,16 @@ void count_ern(struct dpa_percpu_priv_s *percpu_priv,
 int dpa_enable_tx_csum(struct dpa_priv_s *priv,
 	struct sk_buff *skb, struct qm_fd *fd, char *parse_results);
 
+struct proxy_device {
+		struct mac_device *mac_dev;
+};
+
+/* mac device control functions exposed by proxy interface*/
+int dpa_proxy_start(struct net_device *net_dev);
+int dpa_proxy_stop(struct proxy_device *proxy_dev, struct net_device *net_dev);
+int dpa_proxy_set_mac_address(struct proxy_device *proxy_dev,
+			  struct net_device *net_dev);
+int dpa_proxy_set_rx_mode(struct proxy_device *proxy_dev,
+		      struct net_device *net_dev);
+
 #endif /* __DPAA_ETH_COMMON_H */
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c
index 8065a81..87215c3 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c
@@ -76,7 +76,10 @@ int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev);
 /* forward declarations */
 static int __cold dpa_macless_start(struct net_device *net_dev);
 static int __cold dpa_macless_stop(struct net_device *net_dev);
-static int dpa_set_macless_address(struct net_device *net_dev, void *addr);
+static int __cold dpa_macless_set_address(struct net_device *net_dev,
+					  void *addr);
+static void __cold dpa_macless_set_rx_mode(struct net_device *net_dev);
+
 static int dpaa_eth_macless_probe(struct platform_device *_of_dev);
 static netdev_features_t
 dpa_macless_fix_features(struct net_device *dev, netdev_features_t features);
@@ -89,7 +92,8 @@ static const struct net_device_ops dpa_macless_ops = {
 	.ndo_stop = dpa_macless_stop,
 	.ndo_tx_timeout = dpa_timeout,
 	.ndo_get_stats64 = dpa_get_stats64,
-	.ndo_set_mac_address = dpa_set_macless_address,
+	.ndo_set_mac_address = dpa_macless_set_address,
+	.ndo_set_rx_mode = dpa_macless_set_rx_mode,
 	.ndo_validate_addr = eth_validate_addr,
 #ifdef CONFIG_FSL_DPAA_ETH_USE_NDO_SELECT_QUEUE
 	.ndo_select_queue = dpa_select_queue,
@@ -125,37 +129,66 @@ static const char macless_frame_queues[][25] = {
 
 static int __cold dpa_macless_start(struct net_device *net_dev)
 {
+	const struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct proxy_device *proxy_dev = (struct proxy_device *)priv->peer;
+
 	netif_tx_start_all_queues(net_dev);
 
+	if (proxy_dev)
+		dpa_proxy_start(net_dev);
+
+
 	return 0;
 }
 
 static int __cold dpa_macless_stop(struct net_device *net_dev)
 {
+	const struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct proxy_device *proxy_dev = (struct proxy_device *)priv->peer;
+
 	netif_tx_stop_all_queues(net_dev);
 
+	if (proxy_dev)
+		dpa_proxy_stop(proxy_dev, net_dev);
+
 	return 0;
 }
 
-static int dpa_set_macless_address(struct net_device *net_dev, void *addr)
+static int dpa_macless_set_address(struct net_device *net_dev, void *addr)
 {
-	const struct dpa_priv_s	*priv;
+	const struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct proxy_device *proxy_dev = (struct proxy_device *)priv->peer;
 	int			 _errno;
 
-	priv = netdev_priv(net_dev);
-
 	_errno = eth_mac_addr(net_dev, addr);
 	if (_errno < 0) {
 		if (netif_msg_drv(priv))
-			netdev_err(net_dev,
-				       "eth_mac_addr() = %d\n",
-				       _errno);
+			netdev_err(net_dev, "eth_mac_addr() = %d\n", _errno);
 		return _errno;
 	}
 
+	if (proxy_dev) {
+		_errno = dpa_proxy_set_mac_address(proxy_dev, net_dev);
+		if (_errno < 0) {
+			if (netif_msg_drv(priv))
+				netdev_err(net_dev, "proxy_set_mac_address() = %d\n",
+						_errno);
+			return _errno;
+		}
+	}
+
 	return 0;
 }
 
+static void __cold dpa_macless_set_rx_mode(struct net_device *net_dev)
+{
+	const struct dpa_priv_s	*priv = netdev_priv(net_dev);
+	struct proxy_device *proxy_dev = (struct proxy_device *)priv->peer;
+
+	if (proxy_dev)
+		dpa_proxy_set_rx_mode(proxy_dev, net_dev);
+}
+
 static netdev_features_t
 dpa_macless_fix_features(struct net_device *dev, netdev_features_t features)
 {
@@ -178,6 +211,7 @@ static int dpa_macless_netdev_init(struct device_node *dpa_node,
 				struct net_device *net_dev)
 {
 	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct proxy_device *proxy_dev = (struct proxy_device *)priv->peer;
 	struct device *dev = net_dev->dev.parent;
 	const uint8_t *mac_addr;
 
@@ -191,6 +225,12 @@ static int dpa_macless_netdev_init(struct device_node *dpa_node,
 		return -EINVAL;
 	}
 
+	if (proxy_dev) {
+		struct mac_device *mac_dev = proxy_dev->mac_dev;
+		net_dev->mem_start = mac_dev->res->start;
+		net_dev->mem_end = mac_dev->res->end;
+	}
+
 	return dpa_netdev_init(dpa_node, net_dev, mac_addr, tx_timeout);
 }
 
@@ -223,6 +263,41 @@ static int dpa_fq_probe_macless(struct device *dev, struct list_head *list,
 	return 0;
 }
 
+struct proxy_device *dpa_macless_proxy_probe(struct platform_device *_of_dev)
+{
+	struct device		*dev;
+	const phandle		*proxy_prop;
+	struct proxy_device	*proxy_dev;
+	struct device_node	*proxy_node;
+	struct platform_device  *proxy_pdev;
+	int lenp;
+
+	dev = &_of_dev->dev;
+
+	proxy_prop = of_get_property(dev->of_node, "proxy", &lenp);
+	if (!proxy_prop)
+		return NULL;
+
+	proxy_node = of_find_node_by_phandle(*proxy_prop);
+	if (!proxy_node) {
+		dev_err(dev, "Cannot find proxy node\n");
+		return NULL;
+	}
+
+	proxy_pdev = of_find_device_by_node(proxy_node);
+	if (!proxy_pdev) {
+		of_node_put(proxy_node);
+		dev_err(dev, "Cannot find device represented by proxy node\n");
+		return NULL;
+	}
+
+	proxy_dev = dev_get_drvdata(&proxy_pdev->dev);
+
+	of_node_put(proxy_node);
+
+	return proxy_dev;
+}
+
 static int dpaa_eth_macless_probe(struct platform_device *_of_dev)
 {
 	int err = 0, i;
@@ -234,6 +309,7 @@ static int dpaa_eth_macless_probe(struct platform_device *_of_dev)
 	struct net_device *net_dev = NULL;
 	struct dpa_priv_s *priv = NULL;
 	struct dpa_percpu_priv_s *percpu_priv;
+	static struct proxy_device *proxy_dev;
 	struct fm_port_fqs port_fqs;
 	struct task_struct *kth;
 	static u8 macless_idx;
@@ -250,6 +326,8 @@ static int dpaa_eth_macless_probe(struct platform_device *_of_dev)
 	if (IS_ERR(dpa_bp))
 		return PTR_ERR(dpa_bp);
 
+	proxy_dev = dpa_macless_proxy_probe(_of_dev);
+
 	dpa_bp->seed_cb = dpa_bp_shared_port_seed;
 
 	/* Allocate this early, so we can store relevant information in
@@ -270,6 +348,8 @@ static int dpaa_eth_macless_probe(struct platform_device *_of_dev)
 	sprintf(priv->if_type, "macless%d", macless_idx++);
 
 	priv->msg_enable = netif_msg_init(debug, -1);
+	/* control over proxy's mac device */
+	priv->peer = (void *)proxy_dev;
 
 	INIT_LIST_HEAD(&priv->dpa_fq_list);
 
@@ -397,7 +477,10 @@ static int __init __cold dpa_macless_load(void)
 
 	return _errno;
 }
-module_init(dpa_macless_load);
+/* waits for proxy to initialize first, in case MAC device reference
+ * is needed
+ */
+late_initcall(dpa_macless_load);
 
 static void __exit __cold dpa_macless_unload(void)
 {
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c
index adb1125..95ad3ea 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c
@@ -74,6 +74,8 @@ static struct platform_driver dpa_proxy_driver = {
 	.remove		= dpa_eth_proxy_remove
 };
 
+static struct proxy_device *proxy_dev;
+
 static int dpaa_eth_proxy_probe(struct platform_device *_of_dev)
 {
 	int err = 0, i;
@@ -102,6 +104,15 @@ static int dpaa_eth_proxy_probe(struct platform_device *_of_dev)
 	if (IS_ERR(mac_dev))
 		return PTR_ERR(mac_dev);
 
+	proxy_dev = devm_kzalloc(dev, sizeof(*proxy_dev), GFP_KERNEL);
+	if (!proxy_dev) {
+		dev_err(dev, "devm_kzalloc() failed\n");
+		return -ENOMEM;
+	}
+
+	proxy_dev->mac_dev = mac_dev;
+	dev_set_drvdata(dev, proxy_dev);
+
 	/* We have physical ports, so we need to establish
 	 * the buffer layout.
 	 */
@@ -150,8 +161,100 @@ static int dpaa_eth_proxy_probe(struct platform_device *_of_dev)
 	return 0; /* Proxy interface initialization ended */
 }
 
+int dpa_proxy_set_mac_address(struct proxy_device *proxy_dev,
+			  struct net_device *net_dev)
+{
+	struct mac_device	*mac_dev;
+	int			 _errno;
+
+	mac_dev = proxy_dev->mac_dev;
+
+	_errno = mac_dev->change_addr(mac_dev->get_mac_handle(mac_dev),
+			net_dev->dev_addr);
+	if (_errno < 0)
+		return _errno;
+
+	return 0;
+}
+
+int dpa_proxy_set_rx_mode(struct proxy_device *proxy_dev,
+		       struct net_device *net_dev)
+{
+	struct mac_device *mac_dev = proxy_dev->mac_dev;
+	const struct dpa_priv_s	*priv = netdev_priv(net_dev);
+	int _errno;
+
+	_errno = mac_dev->set_multi(net_dev, mac_dev);
+	if (unlikely(_errno < 0))
+		return _errno;
+
+	return 0;
+}
+
+int dpa_proxy_start(struct net_device *net_dev)
+{
+	struct mac_device	*mac_dev;
+	const struct dpa_priv_s	*priv;
+	struct proxy_device	*proxy_dev;
+	int			 _errno;
+	int			i;
+
+	priv = netdev_priv(net_dev);
+	proxy_dev = (struct proxy_device *)priv->peer;
+	mac_dev = proxy_dev->mac_dev;
+
+	_errno = mac_dev->init_phy(net_dev, mac_dev);
+	if (_errno < 0) {
+		pr_alert("init_phy() = %d\n", _errno);
+		return _errno;
+	}
+
+	for_each_port_device(i, mac_dev->port_dev)
+		fm_port_enable(mac_dev->port_dev[i]);
+
+	_errno = mac_dev->start(mac_dev);
+	if (_errno < 0) {
+		pr_alert("mac_dev->start() = %d\n", _errno);
+		return _errno;
+	}
+
+	return _errno;
+}
+
+int dpa_proxy_stop(struct proxy_device *proxy_dev, struct net_device *net_dev)
+{
+	struct mac_device	*mac_dev;
+	int			 _errno;
+	int			i;
+
+	mac_dev = proxy_dev->mac_dev;
+
+	_errno = mac_dev->stop(mac_dev);
+	if (_errno < 0) {
+		pr_alert("mac_dev->stop() = %d\n", _errno);
+		return _errno;
+	}
+
+	for_each_port_device(i, mac_dev->port_dev)
+		fm_port_disable(mac_dev->port_dev[i]);
+
+	if (mac_dev->phy_dev)
+		phy_disconnect(mac_dev->phy_dev);
+	mac_dev->phy_dev = NULL;
+
+	return _errno;
+}
+
 static int __cold dpa_eth_proxy_remove(struct platform_device *of_dev)
 {
+	struct device *dev;
+
+	dev = &of_dev->dev;
+	dev_set_drvdata(dev, NULL);
+
+	if (proxy_dev)
+		kfree(proxy_dev);
+
 	return 0;
 }
 
diff --git a/drivers/net/ethernet/freescale/dpa/mac-api.c b/drivers/net/ethernet/freescale/dpa/mac-api.c
index 438fe1f..09889e4 100644
--- a/drivers/net/ethernet/freescale/dpa/mac-api.c
+++ b/drivers/net/ethernet/freescale/dpa/mac-api.c
@@ -41,6 +41,7 @@
 #include <linux/netdevice.h>
 
 #include "dpaa_eth.h"
+#include "dpaa_eth_common.h"
 #include "mac.h"
 #include "lnxwrp_fsl_fman.h"
 
@@ -285,17 +286,14 @@ static int __cold stop(struct mac_device *mac_dev)
 	return fm_mac_disable(mac_dev->get_mac_handle(mac_dev));
 }
 
-static int __cold set_multi(struct net_device *net_dev)
+static int __cold set_multi(struct net_device *net_dev,
+			    struct mac_device *mac_dev)
 {
-	struct dpa_priv_s	*priv;
-	struct mac_device	*mac_dev;
 	struct mac_priv_s	*mac_priv;
 	struct mac_address	*old_addr, *tmp;
 	struct netdev_hw_addr	*ha;
 	int			_errno;
 
-	priv = netdev_priv(net_dev);
-	mac_dev = priv->mac_dev;
 	mac_priv = macdev_priv(mac_dev);
 
 	/* Clear previous address list */
@@ -330,7 +328,9 @@ static int __cold set_multi(struct net_device *net_dev)
 static void adjust_link(struct net_device *net_dev)
 {
 	struct dpa_priv_s *priv = netdev_priv(net_dev);
-	struct mac_device *mac_dev = priv->mac_dev;
+	struct proxy_device *proxy_dev = (struct proxy_device *)priv->peer;
+	struct mac_device *mac_dev = proxy_dev ? proxy_dev->mac_dev :
+		priv->mac_dev;
 	struct phy_device *phy_dev = mac_dev->phy_dev;
 
 	fm_mac_adjust_link(mac_dev->get_mac_handle(mac_dev),
@@ -340,15 +340,11 @@ static void adjust_link(struct net_device *net_dev)
 /* Initializes driver's PHY state, and attaches to the PHY.
  * Returns 0 on success.
  */
-static int dtsec_init_phy(struct net_device *net_dev)
+static int dtsec_init_phy(struct net_device *net_dev,
+			  struct mac_device *mac_dev)
 {
-	struct dpa_priv_s	*priv;
-	struct mac_device	*mac_dev;
 	struct phy_device	*phy_dev;
 
-	priv = netdev_priv(net_dev);
-	mac_dev = priv->mac_dev;
-
 	if (!mac_dev->phy_node)
 		phy_dev = phy_connect(net_dev, mac_dev->fixed_bus_id,
 				&adjust_link, 0, mac_dev->phy_if);
@@ -364,18 +360,17 @@ static int dtsec_init_phy(struct net_device *net_dev)
 	}
 
 	/* Remove any features not supported by the controller */
-	phy_dev->supported &= priv->mac_dev->if_support;
+	phy_dev->supported &= mac_dev->if_support;
 	phy_dev->advertising = phy_dev->supported;
 
-	priv->mac_dev->phy_dev = phy_dev;
+	mac_dev->phy_dev = phy_dev;
 
 	return 0;
 }
 
-static int xgmac_init_phy(struct net_device *net_dev)
+static int xgmac_init_phy(struct net_device *net_dev,
+			  struct mac_device *mac_dev)
 {
-	struct dpa_priv_s *priv = netdev_priv(net_dev);
-	struct mac_device *mac_dev = priv->mac_dev;
 	struct phy_device *phy_dev;
 
 	if (!mac_dev->phy_node)
@@ -392,7 +387,7 @@ static int xgmac_init_phy(struct net_device *net_dev)
 		return phy_dev == NULL ? -ENODEV : PTR_ERR(phy_dev);
 	}
 
-	phy_dev->supported &= priv->mac_dev->if_support;
+	phy_dev->supported &= mac_dev->if_support;
 	phy_dev->advertising = phy_dev->supported;
 
 	mac_dev->phy_dev = phy_dev;
@@ -400,15 +395,11 @@ static int xgmac_init_phy(struct net_device *net_dev)
 	return 0;
 }
 
-static int memac_init_phy(struct net_device *net_dev)
+static int memac_init_phy(struct net_device *net_dev,
+			  struct mac_device *mac_dev)
 {
-	struct dpa_priv_s       *priv;
-	struct mac_device       *mac_dev;
 	struct phy_device       *phy_dev;
 
-	priv = netdev_priv(net_dev);
-	mac_dev = priv->mac_dev;
-
 	if (macdev2enetinterface(mac_dev) == e_ENET_MODE_XGMII_10000) {
 		if (!mac_dev->phy_node) {
 			mac_dev->phy_dev = NULL;
@@ -434,7 +425,7 @@ static int memac_init_phy(struct net_device *net_dev)
 	}
 
 	/* Remove any features not supported by the controller */
-	phy_dev->supported &= priv->mac_dev->if_support;
+	phy_dev->supported &= mac_dev->if_support;
 	phy_dev->advertising = phy_dev->supported;
 
 	mac_dev->phy_dev = phy_dev;
diff --git a/drivers/net/ethernet/freescale/dpa/mac.h b/drivers/net/ethernet/freescale/dpa/mac.h
index 270ee90..37abc7f 100644
--- a/drivers/net/ethernet/freescale/dpa/mac.h
+++ b/drivers/net/ethernet/freescale/dpa/mac.h
@@ -72,13 +72,14 @@ struct mac_device {
 	u32	tx_pause;
 
 	struct fm_mac_dev *(*get_mac_handle)(struct mac_device *mac_dev);
-	int (*init_phy)(struct net_device *net_dev);
+	int (*init_phy)(struct net_device *net_dev, struct mac_device *mac_dev);
 	int (*init)(struct mac_device *mac_dev);
 	int (*start)(struct mac_device *mac_dev);
 	int (*stop)(struct mac_device *mac_dev);
 	int (*set_promisc)(struct fm_mac_dev *fm_mac_dev, bool enable);
 	int (*change_addr)(struct fm_mac_dev *fm_mac_dev, uint8_t *addr);
-	int (*set_multi)(struct net_device *net_dev);
+	int (*set_multi)(struct net_device *net_dev,
+			 struct mac_device *mac_dev);
 	int (*uninit)(struct fm_mac_dev *fm_mac_dev);
 	int (*ptp_enable)(struct fm_mac_dev *fm_mac_dev);
 	int (*ptp_disable)(struct fm_mac_dev *fm_mac_dev);
-- 
1.9.1

