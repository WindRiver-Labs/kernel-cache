From 1a9a4aac31764c7ba86b417e1e869f2b3816c931 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Sun, 9 Jun 2013 14:49:20 +0300
Subject: [PATCH 292/987] dpaa_eth: Simplify computation of skb headroom

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Make it clear that on Rx the needed headroom is precisely fd.offset.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Change-Id: I62bf538c1dcb7a8f4a4feadc403e8bddd0707ef7
Reviewed-on: http://git.am.freescale.net:8181/3475
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 7f0e8702..9aa28ee 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -289,6 +289,7 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	const struct qm_fd *fd, int *use_gro)
 {
 	dma_addr_t addr = qm_fd_addr(fd);
+	ssize_t fd_off = dpa_fd_offset(fd);
 	void *vaddr;
 	struct dpa_bp *dpa_bp = priv->dpa_bp;
 	const t_FmPrsResult *parse_results;
@@ -310,7 +311,8 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	/* Make sure forwarded skbs will have enough space on Tx,
 	 * if extra headers are added.
 	 */
-	skb_reserve(skb, priv->tx_headroom + dpa_get_rx_extra_headroom());
+	BUG_ON(fd_off != priv->tx_headroom + dpa_get_rx_extra_headroom());
+	skb_reserve(skb, fd_off);
 	skb_put(skb, dpa_fd_length(fd));
 
 	/* Peek at the parse results for csum validation */
@@ -337,6 +339,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 {
 	const struct qm_sg_entry *sgt;
 	dma_addr_t addr = qm_fd_addr(fd);
+	ssize_t fd_off = dpa_fd_offset(fd);
 	dma_addr_t sg_addr;
 	void *vaddr, *sg_vaddr;
 	struct dpa_bp *dpa_bp;
@@ -360,7 +363,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 #endif /* CONFIG_FSL_DPAA_TS */
 
 	/* Iterate through the SGT entries and add data buffers to the skb */
-	sgt = vaddr + dpa_fd_offset(fd);
+	sgt = vaddr + fd_off;
 	for (i = 0; i < DPA_SGT_MAX_ENTRIES; i++) {
 		/* Extension bit is not supported */
 		BUG_ON(sgt[i].extension);
@@ -406,8 +409,9 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 			/* Make sure forwarded skbs will have enough space
 			 * on Tx, if extra headers are added.
 			 */
-			skb_reserve(skb, priv->tx_headroom +
+			BUG_ON(fd_off != priv->tx_headroom +
 				dpa_get_rx_extra_headroom());
+			skb_reserve(skb, fd_off);
 			skb_put(skb, sgt[i].length);
 		} else {
 			dma_unmap_single(dpa_bp->dev, sg_addr, dpa_bp->size,
-- 
1.9.1

