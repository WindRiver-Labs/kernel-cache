From 8124fbe418e3921ef790c2851193acdb9a48c196 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Tue, 20 Aug 2013 16:47:27 +0300
Subject: [PATCH 410/987] fmd: add fman registers representation inside the
 sysfs

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Added the following new sysfs files:
*.fman/*.port/fm_port_regs
*.fman/*.port/fm_port_bmi_regs
*.fman/*.port/fm_port_qmi_regs
*.fman/fm_regs
*.fman/fm_ctrl_code_ver
*.fman/fm_muram_free_size
*.fman/fm_plcr_regs
*.fman/fm_kg_pe_regs
*.fman/fm_kg_regs
*.fman/cls_plans/cls_plan_*
*.fman/schemes/scheme_*
*.fman/profiles/profile_*
*.fman/fm_prs_regs
*.fman/fm_fpm_regs
*.fman/tnums_dbg/tnum_dbg_*

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Change-Id: If625ef3550bf66da5fb6fb282975a70df78438b1
Reviewed-on: http://git.am.freescale.net:8181/5843
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
---
 .../freescale/fman/src/wrapper/lnxwrp_fm.c         |    2 +
 .../freescale/fman/src/wrapper/lnxwrp_fm.h         |   14 +-
 .../freescale/fman/src/wrapper/lnxwrp_fm_port.c    |    2 +
 .../freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c  |    2 +
 .../freescale/fman/src/wrapper/lnxwrp_sysfs.c      |   10 +-
 .../freescale/fman/src/wrapper/lnxwrp_sysfs.h      |   17 +-
 .../freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c   | 1542 +++++++++++++++++---
 .../freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h   |  100 +-
 .../fman/src/wrapper/lnxwrp_sysfs_fm_port.c        |  503 ++++++-
 .../fman/src/wrapper/lnxwrp_sysfs_fm_port.h        |    4 +
 10 files changed, 1949 insertions(+), 247 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
index a95a603..82ba4f7 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
@@ -80,6 +80,8 @@
 #include "lnxwrp_exp_sym.h"
 #endif
 
+#define __ERR_MODULE__  MODULE_FM
+
 extern struct device_node *GetFmPortAdvArgsDevTreeNode (struct device_node *fm_node,
                                                          e_FmPortType       portType,
                                                          uint8_t            portId);
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h
index feab96f..99cbfa4 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h
@@ -50,8 +50,6 @@
 
 #include "lnxwrp_fm_ext.h"
 
-#define __ERR_MODULE__      MODULE_FM
-
 #define FM_MAX_NUM_OF_ADV_SETTINGS          10
 
 #define LNXWRP_FM_NUM_OF_SHARED_PROFILES    16
@@ -115,6 +113,8 @@ typedef struct {
     struct device               *dev;
     struct device_attribute     *dev_attr_stats;
     struct device_attribute     *dev_attr_regs;
+    struct device_attribute     *dev_attr_bmi_regs;
+    struct device_attribute     *dev_attr_qmi_regs;
 } t_LnxWrpFmPortDev;
 
 typedef struct {
@@ -227,8 +227,14 @@ typedef struct {
     struct device_attribute     *dev_attr_regs;
 
     struct device_attribute     *dev_pcd_attr_stats;
-    struct device_attribute     *dev_pcd_attr_regs;
+    struct device_attribute     *dev_plcr_attr_regs;
+    struct device_attribute     *dev_prs_attr_regs;
+    struct device_attribute     *dev_fm_fpm_attr_regs;
+    struct device_attribute     *dev_fm_kg_attr_regs;
+    struct device_attribute     *dev_fm_kg_pe_attr_regs;
     struct device_attribute     *dev_attr_muram_free_size;
+    struct device_attribute     *dev_attr_fm_ctrl_code_ver;
+
 
     struct qman_fq              *hc_tx_conf_fq, *hc_tx_err_fq, *hc_tx_fq;
 } t_LnxWrpFmDev;
@@ -243,6 +249,7 @@ t_Error  LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned
 t_Error  LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd, unsigned long arg, bool compat);
 
 
+#if 0
 static __inline__ t_Error AllocSchemesForPort(t_LnxWrpFmDev *p_LnxWrpFmDev, uint8_t numSchemes, uint8_t *p_BaseSchemeNum)
 {
     uint32_t    schemeMask;
@@ -269,6 +276,7 @@ static __inline__ t_Error AllocSchemesForPort(t_LnxWrpFmDev *p_LnxWrpFmDev, uint
         RETURN_ERROR(MINOR, E_FULL, ("schemes!!!"));
     return E_OK;
 }
+#endif
 
 void LnxWrpPCDIOCTLTypeChecking(void);
 void LnxWrpPCDIOCTLEnumChecking(void);
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
index c18310e..ccc10c3 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
@@ -61,6 +61,8 @@
 #include "lnxwrp_resources.h"
 #include "lnxwrp_sysfs_fm_port.h"
 
+#define __ERR_MODULE__  MODULE_FM
+
 extern struct device_node *GetFmAdvArgsDevTreeNode (uint8_t fmIndx);
 
 /* TODO: duplicated, see lnxwrp_fm.c */
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
index 3104385..990092e 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
@@ -71,6 +71,8 @@
 #include "fm_port_ioctls.h"
 #include "fm_vsp_ext.h"
 
+#define __ERR_MODULE__  MODULE_FM
+
 #if defined(CONFIG_COMPAT)
 #include "lnxwrp_ioctls_fm_compat.h"
 #endif
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.c
index 3f122b5..813771b 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.c
@@ -41,16 +41,16 @@
 #include "lnxwrp_sysfs.h"
 
 uint8_t fm_find_statistic_counter_by_name(const char *attr_name,
-					  const struct SysfsStats_t *sysfs_stats,
-					  uint8_t *offset)
+				const struct sysfs_stats_t *sysfs_stats,
+				uint8_t *offset)
 {
 	int i = 0;
 
-	while (sysfs_stats[i].statisticName != NULL) {
-		if (strcmp(sysfs_stats[i].statisticName, attr_name) == 0) {
+	while (sysfs_stats[i].stat_name != NULL) {
+		if (strcmp(sysfs_stats[i].stat_name, attr_name) == 0) {
 			if (offset != NULL)
 				*offset = i;
-			return sysfs_stats[i].statisticCounter;
+			return sysfs_stats[i].stat_counter;
 		}
 
 		i++;
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.h
index 67cb2b0..2098b24 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.h
@@ -30,13 +30,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- @File          lnxwrp_sysfs.h
-
- @Description   FM sysfs functions.
-
-*/
-
 #ifndef LNXWRP_SYSFS_H_
 #define LNXWRP_SYSFS_H_
 
@@ -55,13 +48,13 @@
 #include <linux/device.h>
 #include <linux/sysfs.h>
 
-struct SysfsStats_t {
-	const char *statisticName;
-	uint8_t statisticCounter;
+struct sysfs_stats_t {
+	const char *stat_name;
+	uint8_t stat_counter;
 };
 
 uint8_t fm_find_statistic_counter_by_name(const char *attr_name,
-					  const struct SysfsStats_t *sysfs_stats,
-					  uint8_t *offset);
+				const struct sysfs_stats_t *sysfs_stats,
+				uint8_t *offset);
 
 #endif /* LNXWRP_SYSFS_H_ */
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
index 9237688..edb3d51 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
@@ -30,198 +30,207 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- @File          lnxwrp_sysfs_fm.c
+#include "lnxwrp_sysfs.h"
+#include "lnxwrp_sysfs_fm.h"
+#include "lnxwrp_fm.h"
 
- @Description   FM sysfs related functions.
+#include "../../fman/Peripherals/FM/inc/fm_common.h"
+#include "../../fman/Peripherals/FM/Pcd/fm_pcd.h"
+#include "../../fman/Peripherals/FM/Pcd/fm_kg.h"
+#include "../../fman/Peripherals/FM/Pcd/fm_plcr.h"
 
-*/
+#if defined(__ERR_MODULE__)
+#undef __ERR_MODULE__
+#endif
+
+#include "../../fman/Peripherals/FM/fm.h"
 
-#include "lnxwrp_sysfs.h"
-#include "lnxwrp_fm.h"
 
-enum e_FmDmaMatchStatistics {
-	e_FM_DMA_COUNTERS_CMQ_NOT_EMPTY,
-	e_FM_DMA_COUNTERS_BUS_ERROR,
-	e_FM_DMA_COUNTERS_READ_BUF_ECC_ERROR,
-	e_FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR,
-	e_FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR
+static int fm_get_counter(void *h_fm, e_FmCounters cnt_e, uint32_t *cnt_val);
+
+enum fm_dma_match_stats {
+	FM_DMA_COUNTERS_CMQ_NOT_EMPTY,
+	FM_DMA_COUNTERS_BUS_ERROR,
+	FM_DMA_COUNTERS_READ_BUF_ECC_ERROR,
+	FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR,
+	FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR
 };
 
-static const struct SysfsStats_t fmSysfsStats[] = {
+static const struct sysfs_stats_t fm_sysfs_stats[] = {
 	/* FM statistics */
 	{
-	 .statisticName = "enq_total_frame",
-	 .statisticCounter = e_FM_COUNTERS_ENQ_TOTAL_FRAME,
+	 .stat_name = "enq_total_frame",
+	 .stat_counter = e_FM_COUNTERS_ENQ_TOTAL_FRAME,
 	 },
 	{
-	 .statisticName = "deq_total_frame",
-	 .statisticCounter = e_FM_COUNTERS_DEQ_TOTAL_FRAME,
+	 .stat_name = "deq_total_frame",
+	 .stat_counter = e_FM_COUNTERS_DEQ_TOTAL_FRAME,
 	 },
 	{
-	 .statisticName = "deq_0",
-	 .statisticCounter = e_FM_COUNTERS_DEQ_0,
+	 .stat_name = "deq_0",
+	 .stat_counter = e_FM_COUNTERS_DEQ_0,
 	 },
 	{
-	 .statisticName = "deq_1",
-	 .statisticCounter = e_FM_COUNTERS_DEQ_1,
+	 .stat_name = "deq_1",
+	 .stat_counter = e_FM_COUNTERS_DEQ_1,
 	 },
 	{
-	 .statisticName = "deq_2",
-	 .statisticCounter = e_FM_COUNTERS_DEQ_2,
+	 .stat_name = "deq_2",
+	 .stat_counter = e_FM_COUNTERS_DEQ_2,
 	 },
 	{
-	 .statisticName = "deq_3",
-	 .statisticCounter = e_FM_COUNTERS_DEQ_3,
+	 .stat_name = "deq_3",
+	 .stat_counter = e_FM_COUNTERS_DEQ_3,
 	 },
 	{
-	 .statisticName = "deq_from_default",
-	 .statisticCounter = e_FM_COUNTERS_DEQ_FROM_DEFAULT,
+	 .stat_name = "deq_from_default",
+	 .stat_counter = e_FM_COUNTERS_DEQ_FROM_DEFAULT,
 	 },
 	{
-	 .statisticName = "deq_from_context",
-	 .statisticCounter = e_FM_COUNTERS_DEQ_FROM_CONTEXT,
+	 .stat_name = "deq_from_context",
+	 .stat_counter = e_FM_COUNTERS_DEQ_FROM_CONTEXT,
 	 },
 	{
-	 .statisticName = "deq_from_fd",
-	 .statisticCounter = e_FM_COUNTERS_DEQ_FROM_FD,
+	 .stat_name = "deq_from_fd",
+	 .stat_counter = e_FM_COUNTERS_DEQ_FROM_FD,
 	 },
 	{
-	 .statisticName = "deq_confirm",
-	 .statisticCounter = e_FM_COUNTERS_DEQ_CONFIRM,
+	 .stat_name = "deq_confirm",
+	 .stat_counter = e_FM_COUNTERS_DEQ_CONFIRM,
 	 },
 	/* FM:DMA  statistics */
 	{
-	 .statisticName = "cmq_not_empty",
-	 .statisticCounter = e_FM_DMA_COUNTERS_CMQ_NOT_EMPTY,
+	 .stat_name = "cmq_not_empty",
+	 .stat_counter = FM_DMA_COUNTERS_CMQ_NOT_EMPTY,
 	 },
 	{
-	 .statisticName = "bus_error",
-	 .statisticCounter = e_FM_DMA_COUNTERS_BUS_ERROR,
+	 .stat_name = "bus_error",
+	 .stat_counter = FM_DMA_COUNTERS_BUS_ERROR,
 	 },
 	{
-	 .statisticName = "read_buf_ecc_error",
-	 .statisticCounter = e_FM_DMA_COUNTERS_READ_BUF_ECC_ERROR,
+	 .stat_name = "read_buf_ecc_error",
+	 .stat_counter = FM_DMA_COUNTERS_READ_BUF_ECC_ERROR,
 	 },
 	{
-	 .statisticName = "write_buf_ecc_sys_error",
-	 .statisticCounter = e_FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR,
+	 .stat_name = "write_buf_ecc_sys_error",
+	 .stat_counter = FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR,
 	 },
 	{
-	 .statisticName = "write_buf_ecc_fm_error",
-	 .statisticCounter = e_FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR,
+	 .stat_name = "write_buf_ecc_fm_error",
+	 .stat_counter = FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR,
 	 },
 	/* FM:PCD  statistics */
 	{
-	 .statisticName = "pcd_kg_total",
-	 .statisticCounter = e_FM_PCD_KG_COUNTERS_TOTAL,
+	 .stat_name = "pcd_kg_total",
+	 .stat_counter = e_FM_PCD_KG_COUNTERS_TOTAL,
 	 },
 	{
-	 .statisticName = "pcd_plcr_yellow",
-	 .statisticCounter = e_FM_PCD_PLCR_COUNTERS_YELLOW,
+	 .stat_name = "pcd_plcr_yellow",
+	 .stat_counter = e_FM_PCD_PLCR_COUNTERS_YELLOW,
 	 },
 	{
-	 .statisticName = "pcd_plcr_red",
-	 .statisticCounter = e_FM_PCD_PLCR_COUNTERS_RED,
+	 .stat_name = "pcd_plcr_red",
+	 .stat_counter = e_FM_PCD_PLCR_COUNTERS_RED,
 	 },
 	{
-	 .statisticName = "pcd_plcr_recolored_to_red",
-	 .statisticCounter = e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,
+	 .stat_name = "pcd_plcr_recolored_to_red",
+	 .stat_counter = e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,
 	 },
 	{
-	 .statisticName = "pcd_plcr_recolored_to_yellow",
-	 .statisticCounter = e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,
+	 .stat_name = "pcd_plcr_recolored_to_yellow",
+	 .stat_counter = e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,
 	 },
 	{
-	 .statisticName = "pcd_plcr_total",
-	 .statisticCounter = e_FM_PCD_PLCR_COUNTERS_TOTAL,
+	 .stat_name = "pcd_plcr_total",
+	 .stat_counter = e_FM_PCD_PLCR_COUNTERS_TOTAL,
 	 },
 	{
-	 .statisticName = "pcd_plcr_length_mismatch",
-	 .statisticCounter = e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,
+	 .stat_name = "pcd_plcr_length_mismatch",
+	 .stat_counter = e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,
 	 },
 	{
-	 .statisticName = "pcd_prs_parse_dispatch",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,
+	 .stat_name = "pcd_prs_parse_dispatch",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,
 	 },
 	{
-	 .statisticName = "pcd_prs_l2_parse_result_returned",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,
+	 .stat_name = "pcd_prs_l2_parse_result_returned",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,
 	 },
 	{
-	 .statisticName = "pcd_prs_l3_parse_result_returned",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,
+	 .stat_name = "pcd_prs_l3_parse_result_returned",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,
 	 },
 	{
-	 .statisticName = "pcd_prs_l4_parse_result_returned",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,
+	 .stat_name = "pcd_prs_l4_parse_result_returned",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,
 	 },
 	{
-	 .statisticName = "pcd_prs_shim_parse_result_returned",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,
+	 .stat_name = "pcd_prs_shim_parse_result_returned",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,
 	 },
 	{
-	 .statisticName = "pcd_prs_l2_parse_result_returned_with_err",
-	 .statisticCounter =
+	 .stat_name = "pcd_prs_l2_parse_result_returned_with_err",
+	 .stat_counter =
 	 e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,
 	 },
 	{
-	 .statisticName = "pcd_prs_l3_parse_result_returned_with_err",
-	 .statisticCounter =
+	 .stat_name = "pcd_prs_l3_parse_result_returned_with_err",
+	 .stat_counter =
 	 e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,
 	 },
 	{
-	 .statisticName = "pcd_prs_l4_parse_result_returned_with_err",
-	 .statisticCounter =
+	 .stat_name = "pcd_prs_l4_parse_result_returned_with_err",
+	 .stat_counter =
 	 e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,
 	 },
 	{
-	 .statisticName = "pcd_prs_shim_parse_result_returned_with_err",
-	 .statisticCounter =
+	 .stat_name = "pcd_prs_shim_parse_result_returned_with_err",
+	 .stat_counter =
 	 e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,
 	 },
 	{
-	 .statisticName = "pcd_prs_soft_prs_cycles",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,
+	 .stat_name = "pcd_prs_soft_prs_cycles",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,
 	 },
 	{
-	 .statisticName = "pcd_prs_soft_prs_stall_cycles",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,
+	 .stat_name = "pcd_prs_soft_prs_stall_cycles",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,
 	 },
 	{
-	 .statisticName = "pcd_prs_hard_prs_cycle_incl_stall_cycles",
-	 .statisticCounter =
+	 .stat_name = "pcd_prs_hard_prs_cycle_incl_stall_cycles",
+	 .stat_counter =
 	 e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,
 	 },
 	{
-	 .statisticName = "pcd_prs_muram_read_cycles",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,
+	 .stat_name = "pcd_prs_muram_read_cycles",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,
 	 },
 	{
-	 .statisticName = "pcd_prs_muram_read_stall_cycles",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,
+	 .stat_name = "pcd_prs_muram_read_stall_cycles",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,
 	 },
 	{
-	 .statisticName = "pcd_prs_muram_write_cycles",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,
+	 .stat_name = "pcd_prs_muram_write_cycles",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,
 	 },
 	{
-	 .statisticName = "pcd_prs_muram_write_stall_cycles",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,
+	 .stat_name = "pcd_prs_muram_write_stall_cycles",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,
 	 },
 	{
-	 .statisticName = "pcd_prs_fpm_command_stall_cycles",
-	 .statisticCounter = e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES,
+	 .stat_name = "pcd_prs_fpm_command_stall_cycles",
+	 .stat_counter = e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES,
 	 },
 	{}
 };
 
+
 /* Fm stats and regs dumps via sysfs */
 static ssize_t show_fm_dma_stats(struct device *dev,
-				 struct device_attribute *attr, char *buf)
+				struct device_attribute *attr, char *buf)
 {
-	t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
-	t_FmDmaStatus fmDmaStatus;
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+	t_FmDmaStatus dma_status;
 	unsigned long flags = 0;
 	unsigned n = 0;
 	uint8_t counter_value = 0, counter = 0;
@@ -229,46 +238,46 @@ static ssize_t show_fm_dma_stats(struct device *dev,
 	if (attr == NULL || buf == NULL || dev == NULL)
 		return -EINVAL;
 
-	p_LnxWrpFmDev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
-	if (WARN_ON(p_LnxWrpFmDev == NULL))
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
 		return -EINVAL;
 
-	if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_Dev)
 		return -EIO;
 
 	counter = fm_find_statistic_counter_by_name(
 			attr->attr.name,
-			fmSysfsStats, NULL);
+			fm_sysfs_stats, NULL);
 
 	local_irq_save(flags);
 
-	memset(&fmDmaStatus, 0, sizeof(fmDmaStatus));
-	FM_GetDmaStatus(p_LnxWrpFmDev->h_Dev, &fmDmaStatus);
+	memset(&dma_status, 0, sizeof(dma_status));
+	FM_GetDmaStatus(p_wrp_fm_dev->h_Dev, &dma_status);
 
 	switch (counter) {
-	case e_FM_DMA_COUNTERS_CMQ_NOT_EMPTY:
-		counter_value = fmDmaStatus.cmqNotEmpty;
+	case FM_DMA_COUNTERS_CMQ_NOT_EMPTY:
+		counter_value = dma_status.cmqNotEmpty;
 		break;
-	case e_FM_DMA_COUNTERS_BUS_ERROR:
-		counter_value = fmDmaStatus.busError;
+	case FM_DMA_COUNTERS_BUS_ERROR:
+		counter_value = dma_status.busError;
 		break;
-	case e_FM_DMA_COUNTERS_READ_BUF_ECC_ERROR:
-		counter_value = fmDmaStatus.readBufEccError;
+	case FM_DMA_COUNTERS_READ_BUF_ECC_ERROR:
+		counter_value = dma_status.readBufEccError;
 		break;
-	case e_FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR:
-		counter_value = fmDmaStatus.writeBufEccSysError;
+	case FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR:
+		counter_value = dma_status.writeBufEccSysError;
 		break;
-	case e_FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR:
-		counter_value = fmDmaStatus.writeBufEccFmError;
+	case FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR:
+		counter_value = dma_status.writeBufEccFmError;
 		break;
 	default:
 		WARN(1, "FMD: failure at %s:%d/%s()!\n", __FILE__, __LINE__,
-		     __func__);
+			__func__);
 		break;
 	};
 
 	n = snprintf(buf, PAGE_SIZE, "\tFM %u counter: %c\n",
-		     p_LnxWrpFmDev->id, counter_value ? 'T' : 'F');
+		p_wrp_fm_dev->id, counter_value ? 'T' : 'F');
 
 	local_irq_restore(flags);
 
@@ -278,40 +287,46 @@ static ssize_t show_fm_dma_stats(struct device *dev,
 static ssize_t show_fm_stats(struct device *dev,
 			     struct device_attribute *attr, char *buf)
 {
-	t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
 	unsigned long flags = 0;
-	unsigned n = 0, counter = 0;
+	unsigned n = 0, cnt_e = 0;
+	uint32_t cnt_val;
+	int err;
 
 	if (attr == NULL || buf == NULL || dev == NULL)
 		return -EINVAL;
 
-	p_LnxWrpFmDev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
-	if (WARN_ON(p_LnxWrpFmDev == NULL))
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
 		return -EINVAL;
 
-	if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_Dev)
 		return -EIO;
 
-	counter = fm_find_statistic_counter_by_name(
+	cnt_e = fm_find_statistic_counter_by_name(
 			attr->attr.name,
-			fmSysfsStats, NULL);
+			fm_sysfs_stats, NULL);
+
+	err = fm_get_counter(p_wrp_fm_dev->h_Dev,
+		(e_FmCounters) cnt_e, &cnt_val);
+
+	if (err)
+		return err;
 
 	local_irq_save(flags);
 
 	n = snprintf(buf, PAGE_SIZE, "\tFM %d counter: %d\n",
-		     p_LnxWrpFmDev->id,
-		     FM_GetCounter(p_LnxWrpFmDev->h_Dev,
-				   (e_FmCounters) counter));
+			p_wrp_fm_dev->id, cnt_val);
 
 	local_irq_restore(flags);
 
 	return n;
 }
 
-static ssize_t show_fm_muram_free_size(struct device *dev,
-			     struct device_attribute *attr, char *buf)
+static ssize_t show_fm_muram_free_sz(struct device *dev,
+				struct device_attribute *attr, char *buf)
 {
-	t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
 	unsigned long flags = 0;
 	unsigned n = 0;
 	uint64_t muram_free_size = 0;
@@ -319,56 +334,263 @@ static ssize_t show_fm_muram_free_size(struct device *dev,
 	if (attr == NULL || buf == NULL || dev == NULL)
 		return -EINVAL;
 
-	p_LnxWrpFmDev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
-	if (WARN_ON(p_LnxWrpFmDev == NULL))
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
 		return -EINVAL;
 
-	if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_Dev)
 		return -EIO;
 
-	muram_free_size = FM_MURAM_GetFreeMemSize(p_LnxWrpFmDev->h_MuramDev);
+	muram_free_size = FM_MURAM_GetFreeMemSize(p_wrp_fm_dev->h_MuramDev);
 
 	local_irq_save(flags);
 
 	n = snprintf(buf, PAGE_SIZE, "\tFM %d muram_free_size: %lld\n",
-		     p_LnxWrpFmDev->id, muram_free_size);
+			p_wrp_fm_dev->id, muram_free_size);
 
 	local_irq_restore(flags);
 
 	return n;
 }
 
+static ssize_t show_fm_ctrl_code_ver(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+	unsigned long flags = 0;
+	unsigned n = 0;
+	t_FmCtrlCodeRevisionInfo rv_info;
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
+		return -EINVAL;
+
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_Dev)
+		return -EIO;
+
+	FM_GetFmanCtrlCodeRevision((t_Fm *)p_wrp_fm_dev->h_Dev, &rv_info);
+
+	local_irq_save(flags);
+
+	FM_DMP_LN(buf, n, "- FM %d ctrl code pkg info:\n", p_wrp_fm_dev->id);
+	FM_DMP_LN(buf, n, "Package rev: %d\n", rv_info.packageRev);
+	FM_DMP_LN(buf, n, "major rev: %d\n", rv_info.majorRev);
+	FM_DMP_LN(buf, n, "minor rev: %d\n", rv_info.minorRev);
+
+	local_irq_restore(flags);
+
+	return n;
+}
 
 static ssize_t show_fm_pcd_stats(struct device *dev,
-				 struct device_attribute *attr, char *buf)
+				struct device_attribute *attr, char *buf)
 {
-	t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
 	unsigned long flags = 0;
 	unsigned n = 0, counter = 0;
 
 	if (attr == NULL || buf == NULL || dev == NULL)
 		return -EINVAL;
 
-	p_LnxWrpFmDev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
-	if (WARN_ON(p_LnxWrpFmDev == NULL))
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
 		return -EINVAL;
 
-	if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev ||
-			!p_LnxWrpFmDev->h_PcdDev)
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_Dev ||
+			!p_wrp_fm_dev->h_PcdDev)
 		return -EIO;
 
 	counter = fm_find_statistic_counter_by_name(
 			attr->attr.name,
-			fmSysfsStats, NULL);
+			fm_sysfs_stats, NULL);
 
 	local_irq_save(flags);
 
 	n = snprintf(buf, PAGE_SIZE, "\tFM %d counter: %d\n",
-		     p_LnxWrpFmDev->id,
-		     FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev,
-				       (e_FmPcdCounters) counter));
+			p_wrp_fm_dev->id,
+			FM_PCD_GetCounter(p_wrp_fm_dev->h_PcdDev,
+					(e_FmPcdCounters) counter));
+
+	local_irq_restore(flags);
+
+	return n;
+}
+
+static ssize_t show_fm_tnum_dbg(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	if (!p_wrp_fm_dev->active)
+		return -EIO;
+	else {
+		int tn_s;
+
+		if (!sscanf(attr->attr.name, "tnum_dbg_%d", &tn_s))
+			return -EINVAL;
+
+		n = fm_dump_tnum_dbg(p_wrp_fm_dev->h_Dev,
+					tn_s, tn_s + 15, buf, n);
+	}
+	local_irq_restore(flags);
+#else
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+	return n;
+}
+
+static ssize_t show_fm_cls_plan(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	n = snprintf(buf, PAGE_SIZE, "\n FM-KG classification plan dump.\n");
 
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_PcdDev)
+		return -EIO;
+	else {
+		int cpn;
+
+		if (!sscanf(attr->attr.name, "cls_plan_%d", &cpn))
+			return -EINVAL;
+
+		n = fm_dump_cls_plan(p_wrp_fm_dev->h_PcdDev, cpn, buf, n);
+	}
 	local_irq_restore(flags);
+#else
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+	return n;
+}
+
+static ssize_t show_fm_profiles(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	n = snprintf(buf, PAGE_SIZE, "FM policer profile dump.\n");
+
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_PcdDev)
+		return -EIO;
+	else {
+		int pn;
+
+		if (!sscanf(attr->attr.name, "profile_%d", &pn))
+			return -EINVAL;
+
+		n = fm_profile_dump_regs(p_wrp_fm_dev->h_PcdDev, pn, buf, n);
+	}
+	local_irq_restore(flags);
+#else
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+	return n;
+}
+
+static ssize_t show_fm_schemes(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	n = snprintf(buf, PAGE_SIZE, "FM-KG driver schemes dump.\n");
+
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_PcdDev)
+		return -EIO;
+	else {
+		int sn;
+
+		if (!sscanf(attr->attr.name, "scheme_%d", &sn))
+			return -EINVAL;
+
+		n = fm_dump_scheme(p_wrp_fm_dev->h_PcdDev, sn, buf, n);
+	}
+	local_irq_restore(flags);
+#else
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+		     "Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+#endif /* (defined(DEBUG_ERRORS) && ... */
 
 	return n;
 }
@@ -434,6 +656,115 @@ static DEVICE_ATTR(pcd_prs_muram_write_stall_cycles, S_IRUGO,
 static DEVICE_ATTR(pcd_prs_fpm_command_stall_cycles, S_IRUGO,
 		   show_fm_pcd_stats, NULL);
 
+static DEVICE_ATTR(tnum_dbg_0, S_IRUGO, show_fm_tnum_dbg, NULL);
+static DEVICE_ATTR(tnum_dbg_16, S_IRUGO, show_fm_tnum_dbg, NULL);
+static DEVICE_ATTR(tnum_dbg_32, S_IRUGO, show_fm_tnum_dbg, NULL);
+static DEVICE_ATTR(tnum_dbg_48, S_IRUGO, show_fm_tnum_dbg, NULL);
+static DEVICE_ATTR(tnum_dbg_64, S_IRUGO, show_fm_tnum_dbg, NULL);
+static DEVICE_ATTR(tnum_dbg_80, S_IRUGO, show_fm_tnum_dbg, NULL);
+static DEVICE_ATTR(tnum_dbg_96, S_IRUGO, show_fm_tnum_dbg, NULL);
+static DEVICE_ATTR(tnum_dbg_112, S_IRUGO, show_fm_tnum_dbg, NULL);
+
+static DEVICE_ATTR(cls_plan_0, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_1, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_2, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_3, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_4, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_5, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_6, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_7, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_8, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_9, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_10, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_11, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_12, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_13, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_14, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_15, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_16, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_17, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_18, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_19, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_20, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_21, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_22, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_23, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_24, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_25, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_26, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_27, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_28, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_29, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_30, S_IRUGO, show_fm_cls_plan, NULL);
+static DEVICE_ATTR(cls_plan_31, S_IRUGO, show_fm_cls_plan, NULL);
+
+static DEVICE_ATTR(profile_0, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_1, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_2, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_3, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_4, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_5, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_6, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_7, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_8, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_9, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_10, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_11, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_12, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_13, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_14, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_15, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_16, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_17, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_18, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_19, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_20, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_21, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_22, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_23, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_24, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_25, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_26, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_27, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_28, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_29, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_30, S_IRUGO, show_fm_profiles, NULL);
+static DEVICE_ATTR(profile_31, S_IRUGO, show_fm_profiles, NULL);
+
+static DEVICE_ATTR(scheme_0, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_1, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_2, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_3, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_4, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_5, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_6, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_7, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_8, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_9, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_10, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_11, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_12, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_13, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_14, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_15, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_16, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_17, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_18, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_19, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_20, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_21, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_22, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_23, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_24, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_25, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_26, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_27, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_28, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_29, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_30, S_IRUGO, show_fm_schemes, NULL);
+static DEVICE_ATTR(scheme_31, S_IRUGO, show_fm_schemes, NULL);
+
+
 static struct attribute *fm_dev_stats_attributes[] = {
 	&dev_attr_enq_total_frame.attr,
 	&dev_attr_deq_total_frame.attr,
@@ -477,74 +808,336 @@ static struct attribute *fm_dev_stats_attributes[] = {
 	NULL
 };
 
+static struct attribute *fm_dev_tnums_dbg_attributes[] = {
+	&dev_attr_tnum_dbg_0.attr,
+	&dev_attr_tnum_dbg_16.attr,
+	&dev_attr_tnum_dbg_32.attr,
+	&dev_attr_tnum_dbg_48.attr,
+	&dev_attr_tnum_dbg_64.attr,
+	&dev_attr_tnum_dbg_80.attr,
+	&dev_attr_tnum_dbg_96.attr,
+	&dev_attr_tnum_dbg_112.attr,
+	NULL
+};
+
+static struct attribute *fm_dev_cls_plans_attributes[] = {
+	&dev_attr_cls_plan_0.attr,
+	&dev_attr_cls_plan_1.attr,
+	&dev_attr_cls_plan_2.attr,
+	&dev_attr_cls_plan_3.attr,
+	&dev_attr_cls_plan_4.attr,
+	&dev_attr_cls_plan_5.attr,
+	&dev_attr_cls_plan_6.attr,
+	&dev_attr_cls_plan_7.attr,
+	&dev_attr_cls_plan_8.attr,
+	&dev_attr_cls_plan_9.attr,
+	&dev_attr_cls_plan_10.attr,
+	&dev_attr_cls_plan_11.attr,
+	&dev_attr_cls_plan_12.attr,
+	&dev_attr_cls_plan_13.attr,
+	&dev_attr_cls_plan_14.attr,
+	&dev_attr_cls_plan_15.attr,
+	&dev_attr_cls_plan_16.attr,
+	&dev_attr_cls_plan_17.attr,
+	&dev_attr_cls_plan_18.attr,
+	&dev_attr_cls_plan_19.attr,
+	&dev_attr_cls_plan_20.attr,
+	&dev_attr_cls_plan_21.attr,
+	&dev_attr_cls_plan_22.attr,
+	&dev_attr_cls_plan_23.attr,
+	&dev_attr_cls_plan_24.attr,
+	&dev_attr_cls_plan_25.attr,
+	&dev_attr_cls_plan_26.attr,
+	&dev_attr_cls_plan_27.attr,
+	&dev_attr_cls_plan_28.attr,
+	&dev_attr_cls_plan_29.attr,
+	&dev_attr_cls_plan_30.attr,
+	&dev_attr_cls_plan_31.attr,
+	NULL
+};
+
+static struct attribute *fm_dev_profiles_attributes[] = {
+	&dev_attr_profile_0.attr,
+	&dev_attr_profile_1.attr,
+	&dev_attr_profile_2.attr,
+	&dev_attr_profile_3.attr,
+	&dev_attr_profile_4.attr,
+	&dev_attr_profile_5.attr,
+	&dev_attr_profile_6.attr,
+	&dev_attr_profile_7.attr,
+	&dev_attr_profile_8.attr,
+	&dev_attr_profile_9.attr,
+	&dev_attr_profile_10.attr,
+	&dev_attr_profile_11.attr,
+	&dev_attr_profile_12.attr,
+	&dev_attr_profile_13.attr,
+	&dev_attr_profile_14.attr,
+	&dev_attr_profile_15.attr,
+	&dev_attr_profile_16.attr,
+	&dev_attr_profile_17.attr,
+	&dev_attr_profile_18.attr,
+	&dev_attr_profile_19.attr,
+	&dev_attr_profile_20.attr,
+	&dev_attr_profile_21.attr,
+	&dev_attr_profile_22.attr,
+	&dev_attr_profile_23.attr,
+	&dev_attr_profile_24.attr,
+	&dev_attr_profile_25.attr,
+	&dev_attr_profile_26.attr,
+	&dev_attr_profile_27.attr,
+	&dev_attr_profile_28.attr,
+	&dev_attr_profile_29.attr,
+	&dev_attr_profile_30.attr,
+	&dev_attr_profile_31.attr,
+	NULL
+};
+
+static struct attribute *fm_dev_schemes_attributes[] = {
+	&dev_attr_scheme_0.attr,
+	&dev_attr_scheme_1.attr,
+	&dev_attr_scheme_2.attr,
+	&dev_attr_scheme_3.attr,
+	&dev_attr_scheme_4.attr,
+	&dev_attr_scheme_5.attr,
+	&dev_attr_scheme_6.attr,
+	&dev_attr_scheme_7.attr,
+	&dev_attr_scheme_8.attr,
+	&dev_attr_scheme_9.attr,
+	&dev_attr_scheme_10.attr,
+	&dev_attr_scheme_11.attr,
+	&dev_attr_scheme_12.attr,
+	&dev_attr_scheme_13.attr,
+	&dev_attr_scheme_14.attr,
+	&dev_attr_scheme_15.attr,
+	&dev_attr_scheme_16.attr,
+	&dev_attr_scheme_17.attr,
+	&dev_attr_scheme_18.attr,
+	&dev_attr_scheme_19.attr,
+	&dev_attr_scheme_20.attr,
+	&dev_attr_scheme_21.attr,
+	&dev_attr_scheme_22.attr,
+	&dev_attr_scheme_23.attr,
+	&dev_attr_scheme_24.attr,
+	&dev_attr_scheme_25.attr,
+	&dev_attr_scheme_26.attr,
+	&dev_attr_scheme_27.attr,
+	&dev_attr_scheme_28.attr,
+	&dev_attr_scheme_29.attr,
+	&dev_attr_scheme_30.attr,
+	&dev_attr_scheme_31.attr,
+	NULL
+};
+
 static const struct attribute_group fm_dev_stats_attr_grp = {
 	.name = "statistics",
 	.attrs = fm_dev_stats_attributes
 };
 
-static ssize_t show_fm_regs(struct device *dev, struct device_attribute *attr,
-			    char *buf)
+static const struct attribute_group fm_dev_tnums_dbg_attr_grp = {
+	.name = "tnums_dbg",
+	.attrs = fm_dev_tnums_dbg_attributes
+};
+
+static const struct attribute_group fm_dev_cls_plans_attr_grp = {
+	.name = "cls_plans",
+	.attrs = fm_dev_cls_plans_attributes
+};
+
+static const struct attribute_group fm_dev_schemes_attr_grp = {
+	.name = "schemes",
+	.attrs = fm_dev_schemes_attributes
+};
+
+static const struct attribute_group fm_dev_profiles_attr_grp = {
+	.name = "profiles",
+	.attrs = fm_dev_profiles_attributes
+};
+
+static ssize_t show_fm_regs(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
 {
 	unsigned long flags;
 	unsigned n = 0;
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-	t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
 #endif
-
 	if (attr == NULL || buf == NULL || dev == NULL)
 		return -EINVAL;
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 
-	p_LnxWrpFmDev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
-	if (WARN_ON(p_LnxWrpFmDev == NULL))
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
 		return -EINVAL;
 
 	local_irq_save(flags);
 
 	n = snprintf(buf, PAGE_SIZE, "FM driver registers dump.\n");
 
-	if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_Dev)
 		return -EIO;
 	else
-		FM_DumpRegs(p_LnxWrpFmDev->h_Dev);
+		n = fm_dump_regs(p_wrp_fm_dev->h_Dev, buf, n);
 
 	local_irq_restore(flags);
 #else
 
 	local_irq_save(flags);
 	n = snprintf(buf, PAGE_SIZE,
-		     "Debug level is too low to dump registers!!!\n");
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+	return n;
+}
+
+static ssize_t show_fm_kg_pe_regs(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	n = snprintf(buf, PAGE_SIZE,
+			"\n FM-KG Port Partition Config registers dump.\n");
+
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_PcdDev)
+		return -EIO;
+	else
+		n = fm_kg_pe_dump_regs(p_wrp_fm_dev->h_PcdDev, buf, n);
+
+	local_irq_restore(flags);
+#else
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+	return n;
+}
+
+static ssize_t show_fm_kg_regs(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	n = snprintf(buf, PAGE_SIZE, "FM-KG registers dump.\n");
+
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_PcdDev)
+		return -EIO;
+	else
+		n = fm_kg_dump_regs(p_wrp_fm_dev->h_PcdDev, buf, n);
+
+	local_irq_restore(flags);
+#else
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+	return n;
+}
+
+
+static ssize_t show_fm_fpm_regs(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	n = snprintf(buf, PAGE_SIZE, "FM-FPM registers dump.\n");
+
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_Dev)
+		return -EIO;
+	else
+		n = fm_fpm_dump_regs(p_wrp_fm_dev->h_Dev, buf, n);
+
+	local_irq_restore(flags);
+#else
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
 	local_irq_restore(flags);
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
 	return n;
 }
 
-static ssize_t show_pcd_regs(struct device *dev,
+static ssize_t show_prs_regs(struct device *dev,
 			     struct device_attribute *attr, char *buf)
 {
 	unsigned long flags;
 	unsigned n = 0;
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-	t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
 #endif
 
 	if (attr == NULL || buf == NULL || dev == NULL)
 		return -EINVAL;
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-	p_LnxWrpFmDev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
-	if (WARN_ON(p_LnxWrpFmDev == NULL))
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
 		return -EINVAL;
 
 	local_irq_save(flags);
-	n = snprintf(buf, PAGE_SIZE, "FM driver registers dump.\n");
+	n = snprintf(buf, PAGE_SIZE, "FM Policer registers dump.\n");
 
-	if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_PcdDev)
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_PcdDev)
 		return -EIO;
 	else
-		FM_PCD_DumpRegs(p_LnxWrpFmDev->h_PcdDev);
+		n = fm_prs_dump_regs(p_wrp_fm_dev->h_PcdDev, buf, n);
 
 	local_irq_restore(flags);
 #else
@@ -559,35 +1152,114 @@ static ssize_t show_pcd_regs(struct device *dev,
 	return n;
 }
 
+static ssize_t show_plcr_regs(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
+		return -EINVAL;
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE, "FM Policer registers dump.\n");
+
+	if (!p_wrp_fm_dev->active || !p_wrp_fm_dev->h_PcdDev)
+		return -EIO;
+	else
+		n = fm_plcr_dump_regs(p_wrp_fm_dev->h_PcdDev, buf, n);
+
+	local_irq_restore(flags);
+#else
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+	return n;
+}
+
 static DEVICE_ATTR(fm_regs, S_IRUGO, show_fm_regs, NULL);
-static DEVICE_ATTR(fm_pcd_regs, S_IRUGO, show_pcd_regs, NULL);
-static DEVICE_ATTR(fm_muram_free_size, S_IRUGO, show_fm_muram_free_size, NULL);
+static DEVICE_ATTR(fm_fpm_regs, S_IRUGO, show_fm_fpm_regs, NULL);
+static DEVICE_ATTR(fm_kg_regs, S_IRUGO, show_fm_kg_regs, NULL);
+static DEVICE_ATTR(fm_kg_pe_regs, S_IRUGO, show_fm_kg_pe_regs, NULL);
+static DEVICE_ATTR(fm_plcr_regs, S_IRUGO, show_plcr_regs, NULL);
+static DEVICE_ATTR(fm_prs_regs, S_IRUGO, show_prs_regs, NULL);
+static DEVICE_ATTR(fm_muram_free_size, S_IRUGO, show_fm_muram_free_sz, NULL);
+static DEVICE_ATTR(fm_ctrl_code_ver, S_IRUGO, show_fm_ctrl_code_ver, NULL);
 
 int fm_sysfs_create(struct device *dev)
 {
-	t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
 
 	if (dev == NULL)
 		return -EIO;
 
-	p_LnxWrpFmDev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
 
 	/* store to remove them when module is disabled */
-	p_LnxWrpFmDev->dev_attr_regs = &dev_attr_fm_regs;
-	p_LnxWrpFmDev->dev_pcd_attr_regs = &dev_attr_fm_pcd_regs;
-	p_LnxWrpFmDev->dev_attr_muram_free_size = &dev_attr_fm_muram_free_size;
+	p_wrp_fm_dev->dev_attr_regs = &dev_attr_fm_regs;
+	p_wrp_fm_dev->dev_fm_fpm_attr_regs = &dev_attr_fm_fpm_regs;
+	p_wrp_fm_dev->dev_fm_kg_attr_regs = &dev_attr_fm_kg_regs;
+	p_wrp_fm_dev->dev_fm_kg_pe_attr_regs = &dev_attr_fm_kg_pe_regs;
+	p_wrp_fm_dev->dev_plcr_attr_regs = &dev_attr_fm_plcr_regs;
+	p_wrp_fm_dev->dev_prs_attr_regs = &dev_attr_fm_prs_regs;
+	p_wrp_fm_dev->dev_attr_muram_free_size = &dev_attr_fm_muram_free_size;
+	p_wrp_fm_dev->dev_attr_fm_ctrl_code_ver = &dev_attr_fm_ctrl_code_ver;
 
 	/* Create sysfs statistics group for FM module */
 	if (sysfs_create_group(&dev->kobj, &fm_dev_stats_attr_grp) != 0)
 		return -EIO;
 
+	if (sysfs_create_group(&dev->kobj, &fm_dev_schemes_attr_grp) != 0)
+		return -EIO;
+
+	if (sysfs_create_group(&dev->kobj, &fm_dev_profiles_attr_grp) != 0)
+		return -EIO;
+
+	if (sysfs_create_group(&dev->kobj, &fm_dev_tnums_dbg_attr_grp) != 0)
+		return -EIO;
+
+	if (sysfs_create_group(&dev->kobj, &fm_dev_cls_plans_attr_grp) != 0)
+		return -EIO;
+
 	/* Registers dump entry - in future will be moved to debugfs */
-	if (device_create_file(dev, &dev_attr_fm_regs) != 0 ||
-	    device_create_file(dev, &dev_attr_fm_pcd_regs) != 0)
+	if (device_create_file(dev, &dev_attr_fm_regs) != 0)
+		return -EIO;
+
+	if (device_create_file(dev, &dev_attr_fm_fpm_regs) != 0)
+		return -EIO;
+
+	if (device_create_file(dev, &dev_attr_fm_kg_regs) != 0)
+		return -EIO;
+
+	if (device_create_file(dev, &dev_attr_fm_kg_pe_regs) != 0)
+		return -EIO;
+
+	if (device_create_file(dev, &dev_attr_fm_plcr_regs) != 0)
+		return -EIO;
+
+	if (device_create_file(dev, &dev_attr_fm_prs_regs) != 0)
 		return -EIO;
 
 	/* muram free size */
-	if (device_create_file(dev, &dev_attr_fm_muram_free_size) != 0 )
+	if (device_create_file(dev, &dev_attr_fm_muram_free_size) != 0)
+		return -EIO;
+
+	/* fm ctrl code version */
+	if (device_create_file(dev, &dev_attr_fm_ctrl_code_ver) != 0)
 		return -EIO;
 
 	return 0;
@@ -595,17 +1267,543 @@ int fm_sysfs_create(struct device *dev)
 
 void fm_sysfs_destroy(struct device *dev)
 {
-	t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+	t_LnxWrpFmDev *p_wrp_fm_dev = NULL;
 
 	if (WARN_ON(dev == NULL))
 		return;
 
-	p_LnxWrpFmDev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
-	if (WARN_ON(p_LnxWrpFmDev == NULL))
+	p_wrp_fm_dev = (t_LnxWrpFmDev *) dev_get_drvdata(dev);
+	if (WARN_ON(p_wrp_fm_dev == NULL))
 		return;
 
 	sysfs_remove_group(&dev->kobj, &fm_dev_stats_attr_grp);
-	device_remove_file(dev, p_LnxWrpFmDev->dev_attr_regs);
-	device_remove_file(dev, p_LnxWrpFmDev->dev_pcd_attr_regs);
-	device_remove_file(dev, p_LnxWrpFmDev->dev_attr_muram_free_size);	
+	sysfs_remove_group(&dev->kobj, &fm_dev_schemes_attr_grp);
+	sysfs_remove_group(&dev->kobj, &fm_dev_profiles_attr_grp);
+	sysfs_remove_group(&dev->kobj, &fm_dev_cls_plans_attr_grp);
+	sysfs_remove_group(&dev->kobj, &fm_dev_tnums_dbg_attr_grp);
+	device_remove_file(dev, p_wrp_fm_dev->dev_attr_regs);
+	device_remove_file(dev, p_wrp_fm_dev->dev_fm_fpm_attr_regs);
+	device_remove_file(dev, p_wrp_fm_dev->dev_fm_kg_attr_regs);
+	device_remove_file(dev, p_wrp_fm_dev->dev_fm_kg_pe_attr_regs);
+	device_remove_file(dev, p_wrp_fm_dev->dev_plcr_attr_regs);
+	device_remove_file(dev, p_wrp_fm_dev->dev_prs_attr_regs);
+	device_remove_file(dev, p_wrp_fm_dev->dev_attr_muram_free_size);
+	device_remove_file(dev, p_wrp_fm_dev->dev_attr_fm_ctrl_code_ver);
+}
+
+int fm_dump_regs(void *h_fm, char *buf, int nn)
+{
+	t_Fm		*p_Fm = (t_Fm *)h_fm;
+	uint8_t		i = 0;
+	int		n = nn;
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	FM_DMP_TITLE(buf, n, p_Fm->p_FmDmaRegs, "FM-DMA Regs");
+
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmsr);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmemsr);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmmr);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmtr);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmhy);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmsetr);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmtah);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmtal);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmtcid);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmra);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmrd);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmwcr);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmebcr);
+	FM_DMP_V32(buf, n, p_Fm->p_FmDmaRegs, fmdmdcr);
+
+	FM_DMP_TITLE(buf, n, &p_Fm->p_FmDmaRegs->fmdmplr, "fmdmplr");
+
+	for (i = 0; i < FM_MAX_NUM_OF_HW_PORT_IDS / 2 ; ++i)
+		FM_DMP_MEM_32(buf, n, &p_Fm->p_FmDmaRegs->fmdmplr[i]);
+
+	FM_DMP_TITLE(buf, n, p_Fm->p_FmBmiRegs, "FM-BMI COMMON Regs");
+	FM_DMP_V32(buf, n, p_Fm->p_FmBmiRegs, fmbm_init);
+	FM_DMP_V32(buf, n, p_Fm->p_FmBmiRegs, fmbm_cfg1);
+	FM_DMP_V32(buf, n, p_Fm->p_FmBmiRegs, fmbm_cfg2);
+	FM_DMP_V32(buf, n, p_Fm->p_FmBmiRegs, fmbm_ievr);
+	FM_DMP_V32(buf, n, p_Fm->p_FmBmiRegs, fmbm_ier);
+
+	FM_DMP_TITLE(buf, n, &p_Fm->p_FmBmiRegs->fmbm_arb, "fmbm_arb");
+	for (i = 0; i < 8 ; ++i)
+		FM_DMP_MEM_32(buf, n, &p_Fm->p_FmBmiRegs->fmbm_arb[i]);
+
+	FM_DMP_TITLE(buf, n, p_Fm->p_FmQmiRegs, "FM-QMI COMMON Regs");
+	FM_DMP_V32(buf, n, p_Fm->p_FmQmiRegs, fmqm_gc);
+	FM_DMP_V32(buf, n, p_Fm->p_FmQmiRegs, fmqm_eie);
+	FM_DMP_V32(buf, n, p_Fm->p_FmQmiRegs, fmqm_eien);
+	FM_DMP_V32(buf, n, p_Fm->p_FmQmiRegs, fmqm_eif);
+	FM_DMP_V32(buf, n, p_Fm->p_FmQmiRegs, fmqm_ie);
+	FM_DMP_V32(buf, n, p_Fm->p_FmQmiRegs, fmqm_ien);
+	FM_DMP_V32(buf, n, p_Fm->p_FmQmiRegs, fmqm_if);
+	FM_DMP_V32(buf, n, p_Fm->p_FmQmiRegs, fmqm_gs);
+	FM_DMP_V32(buf, n, p_Fm->p_FmQmiRegs, fmqm_etfc);
+
+	return n;
+}
+
+int fm_dump_tnum_dbg(void *h_fm, int tn_s, int tn_e, char *buf, int nn)
+{
+	t_Fm		*p_Fm = (t_Fm *)h_fm;
+	uint8_t		i, j = 0;
+	int		n = nn;
+
+	FM_DMP_TITLE(buf, n, NULL, "Tnums and Tnum dbg regs %d - %d",
+			tn_s, tn_e);
+
+	iowrite32be(tn_s << 24, &p_Fm->p_FmFpmRegs->fmfp_dra);
+
+	mb();
+
+	for (j = tn_s; j <= tn_e; j++) {
+		FM_DMP_LN(buf, n, "> fmfp_ts[%d]\n", j);
+		FM_DMP_MEM_32(buf, n, &p_Fm->p_FmFpmRegs->fmfp_ts[j]);
+		FM_DMP_V32(buf, n, p_Fm->p_FmFpmRegs, fmfp_dra);
+		FM_DMP_LN(buf, n, "> fmfp_drd[0-3]\n");
+
+		for (i = 0; i < 4 ; ++i)
+			FM_DMP_MEM_32(buf, n, &p_Fm->p_FmFpmRegs->fmfp_drd[i]);
+
+		FM_DMP_LN(buf, n, "\n");
+
+	}
+
+	return n;
+}
+
+int fm_dump_cls_plan(void *h_fm_pcd, int cpn, char *buf, int nn)
+{
+	t_FmPcd				*p_pcd = (t_FmPcd *)h_fm_pcd;
+	int				i = 0;
+	uint32_t			tmp;
+	unsigned long			i_flg;
+	int				n = nn;
+	u_FmPcdKgIndirectAccessRegs	*idac;
+	spinlock_t			*p_lk;
+
+	p_lk = (spinlock_t *)p_pcd->p_FmPcdKg->h_HwSpinlock;
+	idac = p_pcd->p_FmPcdKg->p_IndirectAccessRegs;
+
+	spin_lock_irqsave(p_lk, i_flg);
+
+	/* Read ClsPlan Block Action Regs */
+	tmp =  (uint32_t)(FM_KG_KGAR_GO |
+		FM_KG_KGAR_READ |
+		FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+		DUMMY_PORT_ID |
+		((uint32_t)cpn << FM_PCD_KG_KGAR_NUM_SHIFT) |
+		FM_PCD_KG_KGAR_WSEL_MASK);
+
+	if (fman_kg_write_ar_wait(p_pcd->p_FmPcdKg->p_FmPcdKgRegs, tmp)) {
+		FM_DMP_LN(buf, nn, "Keygen scheme access violation");
+		spin_unlock_irqrestore(p_lk, i_flg);
+		return nn;
+	}
+	FM_DMP_TITLE(buf, n, &idac->clsPlanRegs,
+			"ClsPlan %d Indirect Access Regs", cpn);
+
+	for (i = 0; i < 8; i++)
+		FM_DMP_MEM_32(buf, n, &idac->clsPlanRegs.kgcpe[i]);
+
+	spin_unlock_irqrestore(p_lk, i_flg);
+
+	return n;
+}
+
+int fm_profile_dump_regs(void *h_fm_pcd, int ppn, char *buf, int nn)
+{
+	t_FmPcd				*p_pcd = (t_FmPcd *)h_fm_pcd;
+	t_FmPcdPlcrProfileRegs		*p_prof_regs;
+	t_FmPcdPlcrRegs			*p_plcr_regs;
+	t_FmPcdPlcr			*p_plcr;
+	uint32_t			tmp;
+	unsigned long			i_flg;
+	int				n = nn;
+	int				toc = 10;
+	spinlock_t			*p_lk;
+
+	p_plcr = p_pcd->p_FmPcdPlcr;
+	p_prof_regs = &p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
+	p_plcr_regs = p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+	p_lk = (spinlock_t *)((t_FmPcdPlcr *)p_plcr)->h_HwSpinlock;
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+	FM_DMP_TITLE(buf, n, p_plcr_regs, "FM-PCD policer-profile regs");
+
+	tmp =  (uint32_t)(FM_PCD_PLCR_PAR_GO |
+			FM_PCD_PLCR_PAR_R |
+			((uint32_t)ppn << FM_PCD_PLCR_PAR_PNUM_SHIFT) |
+			FM_PCD_PLCR_PAR_PWSEL_MASK);
+
+	spin_lock_irqsave(p_lk, i_flg);
+
+	iowrite32be(tmp, &p_plcr_regs->fmpl_par);
+
+	mb();
+
+	/* wait for the porfile regs to be present */
+	do {
+		--toc;
+		udelay(10);
+		if (!toc) {
+			/* looks like PLCR_PAR_GO refuses to clear */
+			spin_unlock_irqrestore(p_lk, i_flg);
+			FM_DMP_LN(buf, n, "Profile regs not accessible -");
+			FM_DMP_LN(buf, n, " check profile init process\n");
+			return n;
+		}
+	} while ((ioread32be(&p_plcr_regs->fmpl_par) & FM_PCD_PLCR_PAR_GO));
+
+	FM_DMP_TITLE(buf, n, p_prof_regs, "Profile %d regs", ppn);
+
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pemode);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pegnia);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_peynia);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pernia);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pecir);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pecbs);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pepepir_eir);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pepbs_ebs);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pelts);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pects);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pepts_ets);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_pegpc);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_peypc);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_perpc);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_perypc);
+	FM_DMP_V32(buf, n, p_prof_regs, fmpl_perrpc);
+
+	spin_unlock_irqrestore(p_lk, i_flg);
+
+	return n;
+}
+
+int fm_dump_scheme(void *h_fm_pcd, int scnum, char *buf, int nn)
+{
+	t_FmPcd				*p_pcd = (t_FmPcd *)h_fm_pcd;
+	uint32_t			tmp_ar;
+	unsigned long			i_flg;
+	int				i, n = nn;
+	spinlock_t			*p_lk;
+	u_FmPcdKgIndirectAccessRegs	*idac;
+
+	idac = p_pcd->p_FmPcdKg->p_IndirectAccessRegs;
+	p_lk = (spinlock_t *)p_pcd->p_FmPcdKg->h_HwSpinlock;
+
+	spin_lock_irqsave(p_lk, i_flg);
+
+	tmp_ar = FmPcdKgBuildReadSchemeActionReg((uint8_t)scnum);
+	if (fman_kg_write_ar_wait(p_pcd->p_FmPcdKg->p_FmPcdKgRegs, tmp_ar)) {
+		FM_DMP_LN(buf, nn,
+			"Keygen scheme access violation or no such scheme");
+		spin_unlock_irqrestore(p_lk, i_flg);
+		return nn;
+	}
+
+	FM_DMP_TITLE(buf, n, &idac->schemeRegs,
+			"Scheme %d Indirect Access Regs", scnum);
+
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_mode);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_ekfc);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_ekdv);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_bmch);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_bmcl);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_fqb);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_hc);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_ppc);
+
+	FM_DMP_TITLE(buf, n, &idac->schemeRegs.kgse_gec, "kgse_gec");
+
+	for (i = 0; i < FM_KG_NUM_OF_GENERIC_REGS; i++)
+		FM_DMP_MEM_32(buf, n, &idac->schemeRegs.kgse_gec[i]);
+
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_spc);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_dv0);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_dv1);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_ccbs);
+	FM_DMP_V32(buf, n, &idac->schemeRegs, kgse_mv);
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	spin_unlock_irqrestore(p_lk, i_flg);
+
+	return n;
+}
+
+int fm_kg_pe_dump_regs(void *h_fm_pcd, char *buf, int nn)
+{
+	t_FmPcd				*p_pcd = (t_FmPcd *)h_fm_pcd;
+	int				i = 0;
+	uint8_t				prt_id = 0;
+	uint32_t			tmp_ar;
+	unsigned long			i_flg;
+	int				n = nn;
+	u_FmPcdKgIndirectAccessRegs	*idac;
+	t_FmPcdKg			*p_kg;
+	spinlock_t			*p_lk;
+
+	p_kg = p_pcd->p_FmPcdKg;
+	idac = p_pcd->p_FmPcdKg->p_IndirectAccessRegs;
+	p_lk = (spinlock_t *)p_kg->h_HwSpinlock;
+
+	spin_lock_irqsave(p_lk, i_flg);
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++) {
+		SW_PORT_INDX_TO_HW_PORT_ID(prt_id, i);
+
+		tmp_ar = FmPcdKgBuildReadPortSchemeBindActionReg(prt_id);
+
+		if (fman_kg_write_ar_wait(p_kg->p_FmPcdKgRegs, tmp_ar)) {
+			FM_DMP_LN(buf, nn, "Keygen scheme access violation");
+			spin_unlock_irqrestore(p_lk, i_flg);
+			return nn;
+		}
+		FM_DMP_TITLE(buf, n, &idac->portRegs, "Port %d regs", prt_id);
+		FM_DMP_V32(buf, n, &idac->portRegs, fmkg_pe_sp);
+		FM_DMP_V32(buf, n, &idac->portRegs, fmkg_pe_cpp);
+	}
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	spin_unlock_irqrestore(p_lk, i_flg);
+
+	return n;
+}
+
+int fm_kg_dump_regs(void *h_fm_pcd, char *buf, int nn)
+{
+	t_FmPcd		*p_pcd = (t_FmPcd *)h_fm_pcd;
+	int			n = nn;
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+	FM_DMP_TITLE(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs,
+			"FmPcdKgRegs Regs");
+
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_gcr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_eer);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_eeer);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_seer);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_seeer);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_gsr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_tpc);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_serc);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_fdor);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_gdv0r);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_gdv1r);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_feer);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdKg->p_FmPcdKgRegs, fmkg_ar);
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	return n;
+}
+
+
+int fm_fpm_dump_regs(void *h_fm, char *buf, int nn)
+{
+	t_Fm		*p_fm = (t_Fm *)h_fm;
+	uint8_t		i;
+	int		n = nn;
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	FM_DMP_TITLE(buf, n, p_fm->p_FmFpmRegs, "FM-FPM Regs");
+
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_tnc);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_prc);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_brkc);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_mxd);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_dis1);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_dis2);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_epi);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_rie);
+
+	FM_DMP_TITLE(buf, n, &p_fm->p_FmFpmRegs->fmfp_fcev, "fmfp_fcev");
+	for (i = 0; i < 4; ++i)
+		FM_DMP_MEM_32(buf, n, &p_fm->p_FmFpmRegs->fmfp_fcev[i]);
+
+	FM_DMP_TITLE(buf, n, &p_fm->p_FmFpmRegs->fmfp_cee, "fmfp_cee");
+	for (i = 0; i < 4; ++i)
+		FM_DMP_MEM_32(buf, n, &p_fm->p_FmFpmRegs->fmfp_cee[i]);
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_tsc1);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_tsc2);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_tsp);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_tsf);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_rcr);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_extc);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_ext1);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_ext2);
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_ip_rev_1);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_ip_rev_2);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_rstc);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_cld);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fm_npi);
+	FM_DMP_V32(buf, n, p_fm->p_FmFpmRegs, fmfp_ee);
+
+	FM_DMP_TITLE(buf, n, &p_fm->p_FmFpmRegs->fmfp_cev, "fmfp_cev");
+	for (i = 0; i < 4; ++i)
+		FM_DMP_MEM_32(buf, n, &p_fm->p_FmFpmRegs->fmfp_cev[i]);
+
+	FM_DMP_TITLE(buf, n, &p_fm->p_FmFpmRegs->fmfp_ps, "fmfp_ps");
+	for (i = 0; i < 64; ++i)
+		FM_DMP_MEM_32(buf, n, &p_fm->p_FmFpmRegs->fmfp_ps[i]);
+
+	return n;
+}
+
+int fm_prs_dump_regs(void *h_fm_pcd, char *buf, int nn)
+{
+	t_FmPcd		*p_pcd = (t_FmPcd *)h_fm_pcd;
+	int		n = nn;
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	FM_DMP_TITLE(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs,
+			"FM-PCD parser regs");
+
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_rpclim);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_rpimac);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, pmeec);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_pevr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_pever);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_perr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_perer);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_ppsc);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_pds);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_l2rrs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_l3rrs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_l4rrs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_srrs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_l2rres);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_l3rres);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_l4rres);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_srres);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_spcs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_spscs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_hxscs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_mrcs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_mwcs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_mrscs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_mwscs);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPrs->p_FmPcdPrsRegs, fmpr_fcscs);
+
+	return n;
+}
+
+int fm_plcr_dump_regs(void *h_fm_pcd, char *buf, int nn)
+{
+	t_FmPcd		*p_pcd = (t_FmPcd *)h_fm_pcd;
+	int		i = 0;
+	int		n = nn;
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	FM_DMP_TITLE(buf, n,
+			p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,
+			"FM policer regs");
+
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_gcr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_gsr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_evr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_ier);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_ifr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_eevr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_eier);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_eifr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_rpcnt);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_ypcnt);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_rrpcnt);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_rypcnt);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_tpcnt);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_flmcnt);
+
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_serc);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_upcr);
+	FM_DMP_V32(buf, n, p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, fmpl_dpmr);
+
+	FM_DMP_TITLE(buf, n,
+			&p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr,
+			"fmpl_pmr");
+
+	for (i = 0; i < 64; ++i)
+		FM_DMP_MEM_32(buf, n,
+			&p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i]);
+
+	return n;
+}
+
+int fm_get_counter(void *h_fm, e_FmCounters cnt_e, uint32_t *cnt_val)
+{
+	t_Fm		*p_fm = (t_Fm *)h_fm;
+
+	/* When applicable (when there is an "enable counters" bit),
+	check that counters are enabled */
+
+	switch (cnt_e) {
+	case (e_FM_COUNTERS_DEQ_1):
+	case (e_FM_COUNTERS_DEQ_2):
+	case (e_FM_COUNTERS_DEQ_3):
+		if (p_fm->p_FmStateStruct->revInfo.majorRev >= 6)
+			return -EINVAL; /* counter not avilable */
+
+	case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+	case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+	case (e_FM_COUNTERS_DEQ_0):
+	case (e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+	case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+	case (e_FM_COUNTERS_DEQ_FROM_FD):
+	case (e_FM_COUNTERS_DEQ_CONFIRM):
+		if (!(ioread32be(&p_fm->p_FmQmiRegs->fmqm_gc) &
+			QMI_CFG_EN_COUNTERS))
+			return -EINVAL; /* Requested counter not avilable */
+		break;
+	default:
+		break;
+	}
+
+	switch (cnt_e) {
+	case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+		*cnt_val = ioread32be(&p_fm->p_FmQmiRegs->fmqm_etfc);
+		return 0;
+	case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+		*cnt_val =  ioread32be(&p_fm->p_FmQmiRegs->fmqm_dtfc);
+		return 0;
+	case (e_FM_COUNTERS_DEQ_0):
+		*cnt_val =  ioread32be(&p_fm->p_FmQmiRegs->fmqm_dc0);
+		return 0;
+	case (e_FM_COUNTERS_DEQ_1):
+		*cnt_val =  ioread32be(&p_fm->p_FmQmiRegs->fmqm_dc1);
+		return 0;
+	case (e_FM_COUNTERS_DEQ_2):
+		*cnt_val =  ioread32be(&p_fm->p_FmQmiRegs->fmqm_dc2);
+		return 0;
+	case (e_FM_COUNTERS_DEQ_3):
+		*cnt_val =  ioread32be(&p_fm->p_FmQmiRegs->fmqm_dc3);
+		return 0;
+	case (e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+		*cnt_val =  ioread32be(&p_fm->p_FmQmiRegs->fmqm_dfdc);
+		return 0;
+	case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+		*cnt_val =  ioread32be(&p_fm->p_FmQmiRegs->fmqm_dfcc);
+		return 0;
+	case (e_FM_COUNTERS_DEQ_FROM_FD):
+		*cnt_val =  ioread32be(&p_fm->p_FmQmiRegs->fmqm_dffc);
+		return 0;
+	case (e_FM_COUNTERS_DEQ_CONFIRM):
+		*cnt_val =  ioread32be(&p_fm->p_FmQmiRegs->fmqm_dcc);
+		return 0;
+	}
+	/* should never get here */
+	return -EINVAL; /* counter not avilable */
 }
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h
index 8aff850..e6bf83e 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h
@@ -30,12 +30,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- @File          lnxwrp_sysfs_fm.h
-
- @Description   FM sysfs functions.
-
-*/
 
 #ifndef LNXWRP_SYSFS_FM_H_
 #define LNXWRP_SYSFS_FM_H_
@@ -44,5 +38,99 @@
 
 int fm_sysfs_create(struct device *dev);
 void fm_sysfs_destroy(struct device *dev);
+int fm_dump_regs(void *h_dev, char *buf, int nn);
+int fm_fpm_dump_regs(void *h_dev, char *buf, int nn);
+int fm_kg_dump_regs(void *h_pcd, char *buf, int nn);
+int fm_kg_pe_dump_regs(void *h_pcd, char *buf, int nn);
+int fm_dump_scheme(void *h_pcd, int scnum, char *buf, int nn);
+int fm_dump_tnum_dbg(void *h_fm, int tn_s, int tn_e, char *buf, int nn);
+int fm_dump_cls_plan(void *h_pcd, int cpn, char *buf, int nn);
+int fm_plcr_dump_regs(void *h_pcd, char *buf, int nn);
+int fm_prs_dump_regs(void *h_pcd, char *buf, int nn);
+int fm_profile_dump_regs(void *h_pcd, int ppnum, char *buf, int nn);
+
+#define FM_DMP_PGSZ_ERR { \
+			snprintf(&buf[PAGE_SIZE - 80], 70, \
+			"\n Err: current sysfs buffer reached PAGE_SIZE\n");\
+			n = PAGE_SIZE - 2; \
+			}
+
+#define FM_DMP_LN(buf, n, ...) \
+	do { \
+		int k, m = n; \
+		m += k = snprintf(&buf[m], PAGE_SIZE - m, __VA_ARGS__); \
+		if (k < 0 || m > PAGE_SIZE - 90) \
+			FM_DMP_PGSZ_ERR \
+		n = m; \
+	} while (0)
+
+#define FM_DMP_TITLE(buf, n, addr, ...) \
+	do { \
+		int k, m = n; \
+		m += k = snprintf(&buf[m], PAGE_SIZE - m, "\n"); \
+		if (k < 0 || m > PAGE_SIZE - 90) \
+			FM_DMP_PGSZ_ERR \
+		m += k = snprintf(&buf[m], PAGE_SIZE - m, __VA_ARGS__); \
+		if (k < 0 || m > PAGE_SIZE - 90) \
+			FM_DMP_PGSZ_ERR \
+		if (addr) {                           \
+			phys_addr_t pa; \
+			pa = virt_to_phys(addr); \
+			m += k = \
+			snprintf(&buf[m], PAGE_SIZE - m, " (0x%lX)", \
+				(long unsigned int)(pa)); \
+			if (k < 0 || m > PAGE_SIZE - 90) \
+				FM_DMP_PGSZ_ERR \
+		} \
+		m += k = snprintf(&buf[m], PAGE_SIZE - m, \
+			"\n----------------------------------------\n\n"); \
+			if (k < 0 || m > PAGE_SIZE - 90) \
+				FM_DMP_PGSZ_ERR \
+		n = m; \
+	} while (0)
+
+#define FM_DMP_SUBTITLE(buf, n, ...) \
+	do { \
+		int k, m = n; \
+		m += k = snprintf(&buf[m], PAGE_SIZE - m, "------- "); \
+		if (k < 0 || m > PAGE_SIZE - 90) \
+			FM_DMP_PGSZ_ERR \
+		m += k = snprintf(&buf[m], PAGE_SIZE - m, __VA_ARGS__); \
+		if (k < 0 || m > PAGE_SIZE - 90) \
+			FM_DMP_PGSZ_ERR \
+		m += k = snprintf(&buf[m], PAGE_SIZE - m, "\n"); \
+		if (k < 0 || m > PAGE_SIZE - 90) \
+			FM_DMP_PGSZ_ERR \
+		n = m; \
+	} while (0)
+
+#define FM_DMP_MEM_32(buf, n, addr) \
+	{ \
+		uint32_t val; \
+		phys_addr_t pa; \
+		int k, m = n; \
+		pa = virt_to_phys(addr); \
+		val = ioread32be((addr)); \
+		do { \
+			m += k = snprintf(&buf[m], \
+				PAGE_SIZE - m, "0x%010llX: 0x%08x\n", \
+				pa, val); \
+			if (k < 0 || m > PAGE_SIZE - 90) \
+				FM_DMP_PGSZ_ERR \
+			n += k; \
+		} while (0) ;\
+	}
+
+#define FM_DMP_V32(buf, n, st, phrase) \
+	do { \
+		int k, m = n; \
+		phys_addr_t pa = virt_to_phys(&((st)->phrase)); \
+		k = snprintf(&buf[m], PAGE_SIZE - m, \
+		"0x%010llX: 0x%08x%8s\t%s\n", pa, \
+		ioread32be((uint32_t *)&((st)->phrase)), "", #phrase); \
+		if (k < 0 || m > PAGE_SIZE - 90) \
+			FM_DMP_PGSZ_ERR \
+		n += k; \
+	} while (0)
 
 #endif /* LNXWRP_SYSFS_FM_H_ */
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
index cab44ef..8a8589d 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
@@ -30,71 +30,75 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/*
- @File          lnxwrp_sysfs_fm_port.c
+#include "lnxwrp_sysfs.h"
+#include "lnxwrp_fm.h"
+#include "debug_ext.h"
+#include "lnxwrp_sysfs_fm_port.h"
+#include "lnxwrp_sysfs_fm.h"
 
- @Description   FM port sysfs related functions.
+#include "../../fman/Peripherals/FM/Port/fm_port.h"
 
-*/
+#if defined(__ERR_MODULE__)
+#undef __ERR_MODULE__
+#endif
 
-#include "lnxwrp_sysfs.h"
-#include "lnxwrp_fm.h"
+#include "../../fman/Peripherals/FM/fm.h"
 
-static const struct SysfsStats_t portSysfsStats[] = {
+static const struct sysfs_stats_t portSysfsStats[] = {
 	/* RX/TX/OH common statistics */
 	{
-	 .statisticName = "port_frame",
-	 .statisticCounter = e_FM_PORT_COUNTERS_FRAME,
+	 .stat_name = "port_frame",
+	 .stat_counter = e_FM_PORT_COUNTERS_FRAME,
 	 },
 	{
-	 .statisticName = "port_discard_frame",
-	 .statisticCounter = e_FM_PORT_COUNTERS_DISCARD_FRAME,
+	 .stat_name = "port_discard_frame",
+	 .stat_counter = e_FM_PORT_COUNTERS_DISCARD_FRAME,
 	 },
 	{
-	 .statisticName = "port_dealloc_buf",
-	 .statisticCounter = e_FM_PORT_COUNTERS_DEALLOC_BUF,
+	 .stat_name = "port_dealloc_buf",
+	 .stat_counter = e_FM_PORT_COUNTERS_DEALLOC_BUF,
 	 },
 	{
-	 .statisticName = "port_enq_total",
-	 .statisticCounter = e_FM_PORT_COUNTERS_ENQ_TOTAL,
+	 .stat_name = "port_enq_total",
+	 .stat_counter = e_FM_PORT_COUNTERS_ENQ_TOTAL,
 	 },
 	/* TX/OH */
 	{
-	 .statisticName = "port_length_err",
-	 .statisticCounter = e_FM_PORT_COUNTERS_LENGTH_ERR,
+	 .stat_name = "port_length_err",
+	 .stat_counter = e_FM_PORT_COUNTERS_LENGTH_ERR,
 	 },
 	{
-	 .statisticName = "port_unsupprted_format",
-	 .statisticCounter = e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,
+	 .stat_name = "port_unsupprted_format",
+	 .stat_counter = e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,
 	 },
 	{
-	 .statisticName = "port_deq_total",
-	 .statisticCounter = e_FM_PORT_COUNTERS_DEQ_TOTAL,
+	 .stat_name = "port_deq_total",
+	 .stat_counter = e_FM_PORT_COUNTERS_DEQ_TOTAL,
 	 },
 	{
-	 .statisticName = "port_deq_from_default",
-	 .statisticCounter = e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,
+	 .stat_name = "port_deq_from_default",
+	 .stat_counter = e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,
 	 },
 	{
-	 .statisticName = "port_deq_confirm",
-	 .statisticCounter = e_FM_PORT_COUNTERS_DEQ_CONFIRM,
+	 .stat_name = "port_deq_confirm",
+	 .stat_counter = e_FM_PORT_COUNTERS_DEQ_CONFIRM,
 	 },
 	/* RX/OH */
 	{
-	 .statisticName = "port_rx_bad_frame",
-	 .statisticCounter = e_FM_PORT_COUNTERS_RX_BAD_FRAME,
+	 .stat_name = "port_rx_bad_frame",
+	 .stat_counter = e_FM_PORT_COUNTERS_RX_BAD_FRAME,
 	 },
 	{
-	 .statisticName = "port_rx_large_frame",
-	 .statisticCounter = e_FM_PORT_COUNTERS_RX_LARGE_FRAME,
+	 .stat_name = "port_rx_large_frame",
+	 .stat_counter = e_FM_PORT_COUNTERS_RX_LARGE_FRAME,
 	 },
 	{
-	 .statisticName = "port_rx_out_of_buffers_discard",
-	 .statisticCounter = e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,
+	 .stat_name = "port_rx_out_of_buffers_discard",
+	 .stat_counter = e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,
 	 },
 	{
-	 .statisticName = "port_rx_filter_frame",
-	 .statisticCounter = e_FM_PORT_COUNTERS_RX_FILTER_FRAME,
+	 .stat_name = "port_rx_filter_frame",
+	 .stat_counter = e_FM_PORT_COUNTERS_RX_FILTER_FRAME,
 	 },
 	/* TODO: Particular statistics for OH ports */
 	{}
@@ -134,13 +138,14 @@ static ssize_t show_fm_port_stats(struct device *dev,
 
 	if (counter == e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR) {
 		uint32_t fmRev = 0;
-		fmRev = 0xffff & ioread32(UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr
-							+ 0x000c30c4));
+		fmRev = 0xffff &
+			ioread32(UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr +
+			0x000c30c4));
 
 		if (fmRev == 0x0100) {
 			local_irq_save(flags);
 			n = snprintf(buf, PAGE_SIZE,
-				     "counter not available for revision 1\n");
+				"counter not available for revision 1\n");
 			local_irq_restore(flags);
 		}
 		return n;
@@ -171,7 +176,7 @@ static DEVICE_ATTR(port_deq_confirm, S_IRUGO, show_fm_port_stats, NULL);
 static DEVICE_ATTR(port_rx_bad_frame, S_IRUGO, show_fm_port_stats, NULL);
 static DEVICE_ATTR(port_rx_large_frame, S_IRUGO, show_fm_port_stats, NULL);
 static DEVICE_ATTR(port_rx_out_of_buffers_discard, S_IRUGO,
-		   show_fm_port_stats, NULL);
+		show_fm_port_stats, NULL);
 static DEVICE_ATTR(port_rx_filter_frame, S_IRUGO, show_fm_port_stats, NULL);
 
 /* FM PORT TX statistics */
@@ -217,7 +222,7 @@ static struct attribute *fm_oh_port_dev_stats_attributes[] = {
 	&dev_attr_port_discard_frame.attr,
 	&dev_attr_port_dealloc_buf.attr,
 	&dev_attr_port_enq_total.attr,
-	 /*TX*/ &dev_attr_port_length_err.attr,
+	/*TX*/ &dev_attr_port_length_err.attr,
 	&dev_attr_port_unsupprted_format.attr,
 	&dev_attr_port_deq_total.attr,
 	&dev_attr_port_deq_from_default.attr,
@@ -241,6 +246,86 @@ static ssize_t show_fm_port_regs(struct device *dev,
 	unsigned n = 0;
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 	t_LnxWrpFmPortDev *p_LnxWrpFmPortDev =
+		(t_LnxWrpFmPortDev *) dev_get_drvdata(dev);
+#endif
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	local_irq_save(flags);
+
+	if (!p_LnxWrpFmPortDev->h_Dev) {
+		n = snprintf(buf, PAGE_SIZE, "\tFM Port not configured...\n");
+		return n;
+	} else {
+		n = snprintf(buf, PAGE_SIZE,
+				"FM port driver registers dump.\n");
+		n = fm_port_dump_regs(p_LnxWrpFmPortDev->h_Dev, buf, n);
+	}
+
+	local_irq_restore(flags);
+
+	return n;
+#else
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+
+	return n;
+#endif
+}
+
+
+
+
+static ssize_t show_fm_port_bmi_regs(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmPortDev *p_LnxWrpFmPortDev =
+			(t_LnxWrpFmPortDev *) dev_get_drvdata(dev);
+#endif
+
+	if (attr == NULL || buf == NULL || dev == NULL)
+		return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	local_irq_save(flags);
+
+	if (!p_LnxWrpFmPortDev->h_Dev) {
+		n = snprintf(buf, PAGE_SIZE, "\tFM Port not configured...\n");
+		return n;
+	} else {
+		n = snprintf(buf, PAGE_SIZE,
+				"FM port driver registers dump.\n");
+		n = fm_port_dump_regs_bmi(p_LnxWrpFmPortDev->h_Dev, buf, n);
+	}
+
+	local_irq_restore(flags);
+
+	return n;
+#else
+
+	local_irq_save(flags);
+	n = snprintf(buf, PAGE_SIZE,
+			"Debug level is too low to dump registers!!!\n");
+	local_irq_restore(flags);
+
+	return n;
+#endif
+}
+
+static ssize_t show_fm_port_qmi_regs(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned long flags;
+	unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+	t_LnxWrpFmPortDev *p_LnxWrpFmPortDev =
 	    (t_LnxWrpFmPortDev *) dev_get_drvdata(dev);
 #endif
 
@@ -255,8 +340,8 @@ static ssize_t show_fm_port_regs(struct device *dev,
 		return n;
 	} else {
 		n = snprintf(buf, PAGE_SIZE,
-			     "FM port driver registers dump.\n");
-		FM_PORT_DumpRegs(p_LnxWrpFmPortDev->h_Dev);
+				"FM port driver registers dump.\n");
+		n = fm_port_dump_regs_qmi(p_LnxWrpFmPortDev->h_Dev, buf, n);
 	}
 
 	local_irq_restore(flags);
@@ -266,7 +351,7 @@ static ssize_t show_fm_port_regs(struct device *dev,
 
 	local_irq_save(flags);
 	n = snprintf(buf, PAGE_SIZE,
-		     "Debug level is too low to dump registers!!!\n");
+			"Debug level is too low to dump registers!!!\n");
 	local_irq_restore(flags);
 
 	return n;
@@ -274,6 +359,8 @@ static ssize_t show_fm_port_regs(struct device *dev,
 }
 
 static DEVICE_ATTR(fm_port_regs, 0x644, show_fm_port_regs, NULL);
+static DEVICE_ATTR(fm_port_qmi_regs, 0x644, show_fm_port_qmi_regs, NULL);
+static DEVICE_ATTR(fm_port_bmi_regs, 0x644, show_fm_port_bmi_regs, NULL);
 
 int fm_port_sysfs_create(struct device *dev)
 {
@@ -288,36 +375,40 @@ int fm_port_sysfs_create(struct device *dev)
 
 	/* store to remove them when module is disabled */
 	p_LnxWrpFmPortDev->dev_attr_regs = &dev_attr_fm_port_regs;
+	p_LnxWrpFmPortDev->dev_attr_qmi_regs = &dev_attr_fm_port_qmi_regs;
+	p_LnxWrpFmPortDev->dev_attr_bmi_regs = &dev_attr_fm_port_bmi_regs;
 
 	/* Registers dump entry - in future will be moved to debugfs */
 	if (device_create_file(dev, &dev_attr_fm_port_regs) != 0)
 		return -EIO;
+	if (device_create_file(dev, &dev_attr_fm_port_qmi_regs) != 0)
+		return -EIO;
+	if (device_create_file(dev, &dev_attr_fm_port_bmi_regs) != 0)
+		return -EIO;
 
 	/* FM Ports statistics */
 	switch (p_LnxWrpFmPortDev->settings.param.portType) {
 	case e_FM_PORT_TYPE_TX:
 	case e_FM_PORT_TYPE_TX_10G:
 		if (sysfs_create_group
-		    (&dev->kobj, &fm_tx_port_dev_stats_attr_grp) != 0)
+			(&dev->kobj, &fm_tx_port_dev_stats_attr_grp) != 0)
 			return -EIO;
 		break;
 	case e_FM_PORT_TYPE_RX:
 	case e_FM_PORT_TYPE_RX_10G:
 		if (sysfs_create_group
-		    (&dev->kobj, &fm_rx_port_dev_stats_attr_grp) != 0)
+			(&dev->kobj, &fm_rx_port_dev_stats_attr_grp) != 0)
 			return -EIO;
 		break;
-	/* TODO:FMD16 e_FM_PORT_TYPE_DUMMY is accutally a HC port.
-	 * NetCommSw defined this way... no idea why!!! */
 	case e_FM_PORT_TYPE_DUMMY:
 	case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
 		if (sysfs_create_group
-		    (&dev->kobj, &fm_oh_port_dev_stats_attr_grp) != 0)
+			(&dev->kobj, &fm_oh_port_dev_stats_attr_grp) != 0)
 			return -EIO;
 		break;
 	default:
 		WARN(1, "FMD: failure at %s:%d/%s()!\n", __FILE__, __LINE__,
-		     __func__);
+			__func__);
 		return -EINVAL;
 		break;
 	};
@@ -348,8 +439,6 @@ void fm_port_sysfs_destroy(struct device *dev)
 	case e_FM_PORT_TYPE_RX_10G:
 		sysfs_remove_group(&dev->kobj, &fm_rx_port_dev_stats_attr_grp);
 		break;
-	/* TODO:FMD16 e_FM_PORT_TYPE_DUMMY is accutally a HC port.
-	 * NetCommSw defined this way... no idea why!!! */
 	case e_FM_PORT_TYPE_DUMMY:
 	case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
 		sysfs_remove_group(&dev->kobj, &fm_oh_port_dev_stats_attr_grp);
@@ -361,4 +450,320 @@ void fm_port_sysfs_destroy(struct device *dev)
 	};
 
 	device_remove_file(dev, p_LnxWrpFmPortDev->dev_attr_regs);
+	device_remove_file(dev, p_LnxWrpFmPortDev->dev_attr_qmi_regs);
+	device_remove_file(dev, p_LnxWrpFmPortDev->dev_attr_bmi_regs);
+}
+
+
+int fm_port_dump_regs(void *h_dev, char *buf, int nn)
+{
+	t_FmPort *p_FmPort;
+	t_Fm *p_Fm;
+	uint8_t hardwarePortId;
+	int n = nn;
+
+	p_FmPort = (t_FmPort *)h_dev;
+	hardwarePortId = p_FmPort->hardwarePortId;
+	p_Fm = (t_Fm *)p_FmPort->h_Fm;
+
+	FM_DMP_TITLE(buf, n, &p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId - 1],
+			"fmbm_pp for port %u", hardwarePortId);
+	FM_DMP_MEM_32(buf, n,
+			&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId - 1]);
+
+	FM_DMP_TITLE(buf, n, &p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId - 1],
+			"fmbm_pfs for port %u", hardwarePortId);
+	FM_DMP_MEM_32(buf, n,
+		&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId - 1]);
+
+	FM_DMP_TITLE(buf, n,
+			&p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId - 1],
+			"fmbm_spliodn for port %u", hardwarePortId);
+	FM_DMP_MEM_32(buf, n,
+			&p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId - 1]);
+
+	FM_DMP_TITLE(buf, n, &p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId],
+			"fmfp_psfor port %u", hardwarePortId);
+	FM_DMP_MEM_32(buf, n, &p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId]);
+
+	FM_DMP_TITLE(buf, n, &p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId / 2],
+			"fmdmplrfor port %u", hardwarePortId);
+	FM_DMP_MEM_32(buf, n,
+			&p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId / 2]);
+	return n;
 }
+
+int fm_port_dump_regs_bmi(void *h_dev, char *buf, int nn)
+{
+	t_FmPort *p_FmPort;
+	u_FmPortBmiRegs *p_bmi;
+
+	char		arr[20];
+	uint8_t		flag;
+	int		i = 0;
+	int		n = nn;
+
+	p_FmPort = (t_FmPort *)h_dev;
+	p_bmi = p_FmPort->p_FmPortBmiRegs;
+
+	memset(arr, 0, sizeof(arr));
+	switch (p_FmPort->portType) {
+	case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+		strcpy(arr, "OFFLINE-PARSING");
+		flag = 0;
+		break;
+	case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+		strcpy(arr, "HOST-COMMAND");
+		flag = 0;
+		break;
+	case (e_FM_PORT_TYPE_RX):
+		strcpy(arr, "RX");
+		flag = 1;
+		break;
+	case (e_FM_PORT_TYPE_RX_10G):
+		strcpy(arr, "RX-10G");
+		flag = 1;
+		break;
+	case (e_FM_PORT_TYPE_TX):
+		strcpy(arr, "TX");
+		flag = 2;
+		break;
+	case (e_FM_PORT_TYPE_TX_10G):
+		strcpy(arr, "TX-10G");
+		flag = 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	FM_DMP_TITLE(buf, n, NULL,
+		"FMan-Port (%s #%d) registers:",
+		arr, p_FmPort->portId);
+
+	FM_DMP_TITLE(buf, n, p_bmi, "Bmi Port Regs");
+
+	switch (flag) {
+	case (0):
+		FM_DMP_SUBTITLE(buf, n, "\n");
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ocfg);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ost);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_oda);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_oicp);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofdne);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofne);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofca);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofpne);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_opso);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_opp);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_occb);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_oim);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofp);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofed);
+
+		FM_DMP_TITLE(buf, n,
+			&(p_bmi->ohPortBmiRegs.fmbm_oprai), "fmbm_oprai");
+		for (i = 0; i < FM_PORT_PRS_RESULT_NUM_OF_WORDS; ++i) {
+			FM_DMP_MEM_32(buf, n,
+				&(p_bmi->ohPortBmiRegs.fmbm_oprai[i]));
+		}
+		FM_DMP_SUBTITLE(buf, n, "\n");
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofqid);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_oefqid);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofsdm);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofsem);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofene);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_orlmts);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_orlmt);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ocmne);
+		{
+#ifndef FM_NO_OP_OBSERVED_POOLS
+		if (p_FmPort->fmRevInfo.majorRev == 4) {
+			FM_DMP_TITLE(buf, n,
+				&p_bmi->ohPortBmiRegs.fmbm_oebmpi,
+				"fmbm_oebmpi");
+
+			for (i = 0; i < FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS; ++i) {
+				FM_DMP_MEM_32(buf, n,
+					&(p_bmi->ohPortBmiRegs.fmbm_oebmpi[i]));
+			}
+			FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ocgm);
+		}
+#endif /* !FM_NO_OP_OBSERVED_POOLS */
+		}
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ostc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofrc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofdc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofledc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofufdc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_offc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofwdc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofldec);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_opc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_opcp);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_occn);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_otuc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_oduc);
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ofuc);
+		FM_DMP_TITLE(buf, n, &(p_bmi->ohPortBmiRegs.fmbm_odcfg),
+				"fmbm_odcfg");
+		for (i = 0; i < 3; ++i) {
+			FM_DMP_MEM_32(buf, n,
+				&(p_bmi->ohPortBmiRegs.fmbm_odcfg[i]));
+		}
+		FM_DMP_SUBTITLE(buf, n, "\n");
+
+		FM_DMP_V32(buf, n, &p_bmi->ohPortBmiRegs, fmbm_ogpr);
+	break;
+	case (1):
+		FM_DMP_SUBTITLE(buf, n, "\n");
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rcfg);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rst);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rda);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfp);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_reth);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfed);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_ricp);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rebm);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfne);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfca);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfpne);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rpso);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rpp);
+		FM_DMP_TITLE(buf, n, &(p_bmi->rxPortBmiRegs.fmbm_rprai),
+			"fmbm_rprai");
+		for (i = 0; i < FM_PORT_PRS_RESULT_NUM_OF_WORDS; ++i) {
+			FM_DMP_MEM_32(buf, n,
+				&(p_bmi->rxPortBmiRegs.fmbm_rprai[i]));
+		}
+		FM_DMP_SUBTITLE(buf, n, "\n");
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfqid);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_refqid);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfsdm);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfsem);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfene);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rcmne);
+		FM_DMP_TITLE(buf, n, &p_bmi->rxPortBmiRegs.fmbm_ebmpi,
+				"fmbm_ebmpi");
+		for (i = 0; i < FM_PORT_MAX_NUM_OF_EXT_POOLS; ++i) {
+			FM_DMP_MEM_32(buf, n,
+				&(p_bmi->rxPortBmiRegs.fmbm_ebmpi[i]));
+		}
+		FM_DMP_TITLE(buf, n, &p_bmi->rxPortBmiRegs.fmbm_acnt,
+				"fmbm_acnt");
+		for (i = 0; i < FM_PORT_MAX_NUM_OF_EXT_POOLS; ++i) {
+			FM_DMP_MEM_32(buf, n,
+				&(p_bmi->rxPortBmiRegs.fmbm_acnt[i]));
+		}
+		FM_DMP_TITLE(buf, n, &p_bmi->rxPortBmiRegs.fmbm_rcgm,
+				"fmbm_rcgm");
+		for (i = 0; i < FM_PORT_NUM_OF_CONGESTION_GRPS / 32; ++i) {
+			FM_DMP_MEM_32(buf, n,
+				&(p_bmi->rxPortBmiRegs.fmbm_rcgm[i]));
+		}
+
+		FM_DMP_SUBTITLE(buf, n, "\n");
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rmpd);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rstc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfrc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfbc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rlfc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rffc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfcd);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfldec);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rodc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rpc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rpcp);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rccn);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rtuc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rrquc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rduc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rfuc);
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rpac);
+		FM_DMP_TITLE(buf, n, &(p_bmi->rxPortBmiRegs.fmbm_rdcfg),
+				"fmbm_rdcfg");
+		for (i = 0; i < 3; ++i) {
+			FM_DMP_MEM_32(buf, n,
+				&(p_bmi->rxPortBmiRegs.fmbm_rdcfg[i]));
+		}
+		FM_DMP_SUBTITLE(buf, n, "\n");
+		FM_DMP_V32(buf, n, &p_bmi->rxPortBmiRegs, fmbm_rgpr);
+		break;
+	case (2):
+		FM_DMP_SUBTITLE(buf, n, "\n");
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tcfg);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tst);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tda);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfp);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfed);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_ticp);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfdne);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfca);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tcfqid);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfeqid);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfene);
+#if (DPAA_VERSION >= 11)
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfne);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tcmne);
+#endif /* (DPAA_VERSION >= 11) */
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_trlmts);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_trlmt);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tstc);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfrc);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfdc);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfledc);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfufdc);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tpc);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tpcp);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tccn);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_ttuc);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_ttcquc);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tduc);
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tfuc);
+		FM_DMP_TITLE(buf, n, &(p_bmi->txPortBmiRegs.fmbm_tdcfg),
+				"fmbm_tdcfg");
+		for (i = 0; i < 3 ; ++i) {
+			FM_DMP_MEM_32(buf, n,
+				&(p_bmi->txPortBmiRegs.fmbm_tdcfg[i]));
+		}
+		FM_DMP_SUBTITLE(buf, n, "\n");
+		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tgpr);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	return n;
+}
+
+int fm_port_dump_regs_qmi(void *h_dev, char *buf, int nn)
+{
+	t_FmPort *p_FmPort;
+	int n = nn;
+
+	p_FmPort = (t_FmPort *)h_dev;
+
+	FM_DMP_TITLE(buf, n, p_FmPort->p_FmPortQmiRegs, "Qmi Port Regs");
+
+	FM_DMP_V32(buf, n, p_FmPort->p_FmPortQmiRegs, fmqm_pnc);
+	FM_DMP_V32(buf, n, p_FmPort->p_FmPortQmiRegs, fmqm_pns);
+	FM_DMP_V32(buf, n, p_FmPort->p_FmPortQmiRegs, fmqm_pnts);
+	FM_DMP_V32(buf, n, p_FmPort->p_FmPortQmiRegs, fmqm_pnen);
+	FM_DMP_V32(buf, n, p_FmPort->p_FmPortQmiRegs, fmqm_pnetfc);
+	FM_DMP_V32(buf, n,
+		&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs, fmqm_pndn);
+	FM_DMP_V32(buf, n,
+		&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs, fmqm_pndc);
+	FM_DMP_V32(buf, n,
+		&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs, fmqm_pndtfc);
+	FM_DMP_V32(buf, n,
+		&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs, fmqm_pndfdc);
+	FM_DMP_V32(buf, n,
+		&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs, fmqm_pndcc);
+
+	FM_DMP_SUBTITLE(buf, n, "\n");
+
+	return n;
+}
+
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.h
index 03b3a03..525e46c 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.h
@@ -45,4 +45,8 @@
 int fm_port_sysfs_create(struct device *dev);
 void fm_port_sysfs_destroy(struct device *dev);
 
+int fm_port_dump_regs(void *h_dev, char *buf, int n);
+int fm_port_dump_regs_bmi(void *h_dev, char *buf, int n);
+int fm_port_dump_regs_qmi(void *h_dev, char *buf, int n);
+
 #endif /* LNXWRP_SYSFS_FM_PORT_H_ */
-- 
1.9.1

