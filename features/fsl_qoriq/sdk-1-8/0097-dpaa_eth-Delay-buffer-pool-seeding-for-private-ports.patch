From a07a276e1dd5797f7641dde0c3fbe6617812f15f Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Thu, 4 Sep 2014 18:35:25 +0800
Subject: [PATCH 097/987] dpaa_eth: Delay buffer pool seeding for private ports

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Until now, all private ports had to be configured to use the same
buffer size, as they all share a common buffer pool.

Create the framework for working with different buffer sizes on the
private ports; a single, common buffer pool is still used by all
private ports.
The pool is seeded with buffers large enough to accomodate frames
for all private ports. In order to be able to compute the largest
needed buffer size, the buffer pool seeding is delayed until the
first private interface is raised.

Temporarily disable the boot-time ethernet unit test, which requires
the use of the common buffer pool.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: I22d40d136e35320b7b4af76e18e53faff7460cbf
Reviewed-on: http://git.am.freescale.net:8181/1466
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/Kconfig    |  5 +--
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c | 56 ++++++++++++++++++++-------
 2 files changed, 43 insertions(+), 18 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/Kconfig b/drivers/net/ethernet/freescale/dpa/Kconfig
index 1dbe8f1..6ef0918 100644
--- a/drivers/net/ethernet/freescale/dpa/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/Kconfig
@@ -91,7 +91,6 @@ config DPAA_ETH_USE_NDO_SELECT_QUEUE
 	  and use the standard XPS support instead.
 
 config DPAA_ETH_UNIT_TESTS
-	bool "Run Unit Tests for DPAA Ethernet"
+	bool
 	depends on DPA_ETH
-	default y
-
+	default n
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 5f6bb55..4b54ce4 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -75,6 +75,10 @@
 /* DPAA platforms benefit from hardware-assisted queue management */
 #define DPA_NETIF_FEATURES	(0)
 
+#ifdef CONFIG_DPAA_ETH_UNIT_TESTS
+#undef CONFIG_DPAA_ETH_UNIT_TESTS
+#endif
+
 #define DEFAULT_COUNT		128
 #define REFILL_THRESHOLD	80
 
@@ -169,6 +173,8 @@ int dpa_free_pcd_fqids(struct device *, uint32_t) __attribute__((weak));
 static struct dpa_bp *dpa_bp_array[64];
 
 static struct dpa_bp *default_pool;
+static bool default_pool_seeded;
+static uint32_t default_buf_size;
 
 /* A set of callbacks for hooking into the fastpath at different points. */
 static struct dpaa_eth_hooks_s dpaa_eth_hooks;
@@ -484,7 +490,6 @@ dpa_bp_alloc(struct dpa_bp *dpa_bp)
 	dpa_bp->dev = &pdev->dev;
 
 	if (dpa_bp->kernel_pool) {
-		dpa_make_private_pool(dpa_bp);
 		if (!default_pool)
 			default_pool = dpa_bp;
 	} else {
@@ -1467,6 +1472,11 @@ static struct dpa_bp *dpa_size2pool(struct dpa_priv_s *priv, size_t size)
 	return ERR_PTR(-ENODEV);
 }
 
+static inline uint32_t dpa_bp_size(struct fm_port *rx_port)
+{
+	return DEFAULT_BUF_SIZE;
+}
+
 /**
  * Turn on HW checksum computation for this outgoing frame.
  * If the current protocol is not something we support in this regard
@@ -2702,6 +2712,7 @@ static int __cold dpa_start(struct net_device *net_dev)
 	int err, i;
 	struct dpa_priv_s *priv;
 	struct mac_device *mac_dev;
+	struct dpa_percpu_priv_s *percpu_priv;
 
 	priv = netdev_priv(net_dev);
 	mac_dev = priv->mac_dev;
@@ -2709,6 +2720,23 @@ static int __cold dpa_start(struct net_device *net_dev)
 	if (!mac_dev)
 		goto no_mac;
 
+	/* Seed the global buffer pool at the first ifconfig up
+	 * of a private port. Update the percpu buffer counters
+	 * of each private interface.
+	 */
+	if (!priv->shared && !default_pool_seeded) {
+		default_pool->size = default_buf_size;
+		dpa_make_private_pool(default_pool);
+		default_pool_seeded = true;
+	}
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		if (!priv->shared && !percpu_priv->dpa_bp)
+			percpu_priv->dpa_bp = priv->dpa_bp;
+			percpu_priv->dpa_bp_count =
+				per_cpu_ptr(priv->dpa_bp->percpu_count, i);
+	}
+
 	dpaa_eth_napi_enable(priv);
 
 	err = mac_dev->init_phy(net_dev);
@@ -2905,14 +2933,6 @@ dpa_bp_probe(struct platform_device *_of_dev, size_t *count)
 		goto _return_of_node_put;
 	} else if (has_kernel_pool) {
 		dpa_bp->target_count = DEFAULT_COUNT;
-		dpa_bp->size = DEFAULT_BUF_SIZE;
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
-		if (dpa_bp->size > PAGE_SIZE) {
-			dev_warn(dev, "Default buffer size too large. "
-				     "Round down to PAGE_SIZE\n");
-			dpa_bp->size = PAGE_SIZE;
-		}
-#endif
 		dpa_bp->kernel_pool = 1;
 	}
 
@@ -3607,7 +3627,6 @@ dpaa_eth_init_rx_port(struct fm_port *port, struct dpa_bp *bp, size_t count,
 	for (i = 0; i < count; i++) {
 		if (i >= rx_port_param.num_pools)
 			break;
-
 		rx_port_param.pool_param[i].id = bp[i].bpid;
 		rx_port_param.pool_param[i].size = bp[i].size;
 	}
@@ -3772,9 +3791,6 @@ static int dpa_private_netdev_init(struct device_node *dpa_node,
 		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
 		percpu_priv->net_dev = net_dev;
 
-		percpu_priv->dpa_bp = priv->dpa_bp;
-		percpu_priv->dpa_bp_count =
-			per_cpu_ptr(priv->dpa_bp->percpu_count, i);
 #ifdef CONFIG_DPAA_ETH_SG_SUPPORT
 		/* init the percpu list and add some skbs */
 		skb_queue_head_init(&percpu_priv->skb_list);
@@ -3942,8 +3958,6 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		err = PTR_ERR(dpa_bp);
 		goto bp_probe_failed;
 	}
-	if (!dpa_bp->kernel_pool)
-		is_shared = true;
 
 	mac_dev = dpa_mac_probe(_of_dev);
 	if (IS_ERR(mac_dev)) {
@@ -3954,6 +3968,18 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		txport = mac_dev->port_dev[TX];
 	}
 
+	if (!dpa_bp->kernel_pool) {
+		is_shared = true;
+	} else {
+		/* For private ports, need to compute the size of the default
+		 * buffer pool, based on FMan port buffer layout;also update
+		 * the maximum buffer size for private ports if necessary
+		 */
+		dpa_bp->size = dpa_bp_size(rxport);
+		if (dpa_bp->size > default_buf_size)
+			default_buf_size = dpa_bp->size;
+	}
+
 	INIT_LIST_HEAD(&rxfqlist);
 	INIT_LIST_HEAD(&txfqlist);
 
-- 
1.9.1

