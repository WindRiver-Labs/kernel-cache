From cc586735d5e787d2613e2ed4728263f055ac1adc Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 21 Jul 2014 17:43:52 +0300
Subject: [PATCH 805/987] dpa_offload: Add reparsing option to HM operations

Added the reparsing option to the DPA classifier driver API so that
users can request a relaunch of the FMan parser immediatley after
the configured header manipulation operation.

Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
Change-Id: I3e6c9ea03da57e65e21a411fda9ba3cb5a3d5e87
Reviewed-on: http://git.am.freescale.net:8181/15221
Reviewed-by: Radu-Andrei Bulie <Radu.Bulie@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   | 78 +++++++++++++++++-----
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h | 21 ++++--
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   | 33 +++++----
 include/linux/fsl_dpa_classifier.h                 | 38 +++++++++++
 4 files changed, 133 insertions(+), 37 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index f3dcb51..ae96fce 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -3742,7 +3742,6 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 	BUG_ON(!node_array);
 	BUG_ON(!hm);
 
-	/* This HM operation is linked to another HM op */
 	for (i = num_nodes - 1; i >= 0; i--) {
 		/*
 		 * If the node is empty, save an empty space and skip
@@ -3788,6 +3787,9 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 			hm->hm_node[i]->node = node_array[i];
 			INIT_LIST_HEAD(&hm->hm_node[i]->list_node);
 
+			/* Initialize dontParseAfterManip to TRUE */
+			hm->hm_node[i]->params.u.hdr.dontParseAfterManip = TRUE;
+
 			/* Add this new node to the HM chain: */
 			list_add(&hm->hm_node[i]->list_node,
 				hm->hm_chain);
@@ -4478,6 +4480,10 @@ static int nat_hm_prepare_nodes(struct dpa_cls_hm *pnat_hm,
 	}
 
 	INIT_LIST_HEAD(&hm_node->list_node);
+
+	/* Initialize dontParseAfterManip to TRUE */
+	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 	pnat_hm->hm_node[0] = hm_node;
 
 	if (pnat_hm->nat_params.flags &
@@ -4491,6 +4497,10 @@ static int nat_hm_prepare_nodes(struct dpa_cls_hm *pnat_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 		pnat_hm->hm_node[1] = hm_node;
 	}
 
@@ -4518,7 +4528,12 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
 		hm_node = pnat_hm->hm_node[0];
 
 		hm_node->params.type = e_FM_PCD_MANIP_HDR;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+		if (pnat_hm->hm_node[1])
+			hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+		else
+			hm_node->params.u.hdr.dontParseAfterManip &=
+					(pnat_hm->nat_params.reparse) ? FALSE :
+						TRUE;
 
 		if (pnat_hm->nat_params.type ==
 					DPA_CLS_HM_NAT_TYPE_TRADITIONAL) {
@@ -4633,10 +4648,12 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
 
 		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.fieldUpdate	= TRUE;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 		hm_node->params.u.hdr.fieldUpdateParams.type =
 				e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP;
 
+		hm_node->params.u.hdr.dontParseAfterManip &=
+				(pnat_hm->nat_params.reparse) ? FALSE : TRUE;
+
 		if (pnat_hm->nat_params.flags & DPA_CLS_HM_NAT_UPDATE_SPORT) {
 			hm_node->params.u.hdr.fieldUpdateParams.u.tcpUdp.
 				validUpdates |= HDR_MANIP_TCP_UDP_SRC;
@@ -4969,6 +4986,10 @@ static int fwd_hm_prepare_nodes(struct dpa_cls_hm *pfwd_hm,
 	}
 
 	INIT_LIST_HEAD(&hm_node->list_node);
+
+	/* Initialize dontParseAfterManip to TRUE */
+	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 	pfwd_hm->hm_node[0] = hm_node;
 
 	if (pfwd_hm->update_params.ip_frag_params.mtu) {
@@ -5007,8 +5028,10 @@ static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 
 	hm_node = pfwd_hm->hm_node[0];
 
-	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
-	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+	hm_node->params.type = e_FM_PCD_MANIP_HDR;
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pfwd_hm->fwd_params.reparse) ? FALSE : TRUE;
+
 	switch (pfwd_hm->fwd_params.out_if_type) {
 	case DPA_CLS_HM_IF_TYPE_ETHERNET:
 		/* Update Ethernet MACS */
@@ -5016,7 +5039,6 @@ static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 		hm_node->params.u.hdr.insrtParams.type	=
 						e_FM_PCD_MANIP_INSRT_GENERIC;
 		hm_node->params.u.hdr.insrtParams.u.generic.replace = TRUE;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		size = (uint8_t)(sizeof(struct ethhdr) - ETHERTYPE_SIZE);
 		pdata = kzalloc(size, GFP_KERNEL);
@@ -5402,6 +5424,9 @@ static int remove_hm_prepare_nodes(struct dpa_cls_hm *premove_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 	}
 
 	premove_hm->hm_node[0] = hm_node;
@@ -5427,9 +5452,11 @@ static int remove_hm_update_params(struct dpa_cls_hm *premove_hm)
 
 	hm_node = premove_hm->hm_node[0];
 
-	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
-	hm_node->params.u.hdr.rmv		= TRUE;
-	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+	hm_node->params.type		= e_FM_PCD_MANIP_HDR;
+	hm_node->params.u.hdr.rmv	= TRUE;
+
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(premove_hm->remove_params.reparse) ? FALSE : TRUE;
 
 	switch (premove_hm->remove_params.type) {
 	case DPA_CLS_HM_REMOVE_ETHERNET:
@@ -5695,6 +5722,9 @@ static int insert_hm_prepare_nodes(struct dpa_cls_hm *pinsert_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 	}
 
 	pinsert_hm->hm_node[0] = hm_node;
@@ -5726,7 +5756,9 @@ static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm)
 	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 	hm_node->params.u.hdr.insrt		= TRUE;
 	hm_node->params.u.hdr.insrtParams.type	= e_FM_PCD_MANIP_INSRT_GENERIC;
-	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pinsert_hm->insert_params.reparse) ? FALSE : TRUE;
 
 	switch (pinsert_hm->insert_params.type) {
 	case DPA_CLS_HM_INSERT_ETHERNET:
@@ -6108,6 +6140,9 @@ static int update_hm_prepare_nodes(struct dpa_cls_hm *pupdate_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 	}
 
 	pupdate_hm->hm_node[0] = hm_node;
@@ -6153,10 +6188,10 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 
 	hm_node = pupdate_hm->hm_node[0];
 
+	hm_node->params.type = e_FM_PCD_MANIP_HDR;
+
 	if (pupdate_hm->update_params.op_flags & update_ops) {
-		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.fieldUpdate	= TRUE;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_UPDATE_IPv4_UPDATE) {
@@ -6296,11 +6331,9 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 	}
 
 	if (pupdate_hm->update_params.op_flags & replace_ops) {
-		hm_node->params.type		= e_FM_PCD_MANIP_HDR;
-		hm_node->params.u.hdr.custom	= TRUE;
+		hm_node->params.u.hdr.custom = TRUE;
 		hm_node->params.u.hdr.customParams.type =
 				e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_REPLACE_IPv4_BY_IPv6) {
@@ -6339,6 +6372,9 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 		}
 	}
 
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pupdate_hm->update_params.reparse) ? FALSE : TRUE;
+
 	hm_node = pupdate_hm->hm_node[1];
 
 	if (pupdate_hm->update_params.ip_frag_params.mtu) {
@@ -6728,6 +6764,9 @@ static int vlan_hm_prepare_nodes(struct dpa_cls_hm *pvlan_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 	}
 
 	pvlan_hm->hm_node[0] = hm_node;
@@ -6756,6 +6795,8 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 	hm_node = pvlan_hm->hm_node[0];
 
 	hm_node->params.type = e_FM_PCD_MANIP_HDR;
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pvlan_hm->vlan_params.reparse) ? FALSE : TRUE;
 
 	switch (pvlan_hm->vlan_params.type) {
 	case DPA_CLS_HM_VLAN_INGRESS:
@@ -6766,7 +6807,6 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 					e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2;
 		hm_node->params.u.hdr.rmvParams.u.byHdr.u.specificL2 =
 					e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		break;
 	case DPA_CLS_HM_VLAN_EGRESS:
@@ -6808,7 +6848,6 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 			hm_node->params.u.hdr.fieldUpdate = TRUE;
 			hm_node->params.u.hdr.fieldUpdateParams.type =
 					e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN;
-			hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 			switch (pvlan_hm->vlan_params.egress.update_op) {
 			case DPA_CLS_HM_VLAN_UPDATE_VPri:
@@ -7123,6 +7162,9 @@ static int mpls_hm_prepare_nodes(struct dpa_cls_hm *pmpls_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 	}
 
 	pmpls_hm->hm_node[0] = hm_node;
@@ -7151,6 +7193,8 @@ static int mpls_hm_update_params(struct dpa_cls_hm *pmpls_hm)
 	hm_node = pmpls_hm->hm_node[0];
 
 	hm_node->params.type = e_FM_PCD_MANIP_HDR;
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pmpls_hm->mpls_params.reparse) ? FALSE : TRUE;
 
 	switch (pmpls_hm->mpls_params.type) {
 	case DPA_CLS_HM_MPLS_REMOVE_ALL_LABELS:
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index 88a157c..1e73bd6 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -298,6 +298,7 @@ struct dpa_cls_compat_hm_remove_params {
 	enum dpa_cls_hm_remove_type	type;
 	struct dpa_cls_hm_custom_rm_params custom;
 	compat_uptr_t fm_pcd;
+	bool reparse;
 };
 
 struct compat_ioc_dpa_cls_hm_remove_params {
@@ -320,14 +321,15 @@ struct dpa_cls_compat_hm_custom_ins_params {
 };
 
 struct dpa_cls_compat_hm_insert_params {
-	enum dpa_cls_hm_insert_type	type;
+	enum dpa_cls_hm_insert_type type;
 	union {
 		struct dpa_cls_hm_eth_ins_params eth;
-		struct dpa_cls_hm_pppoe_ins_params		pppoe;
-		uint16_t					ppp_pid;
-		struct dpa_cls_compat_hm_custom_ins_params	custom;
+		struct dpa_cls_hm_pppoe_ins_params pppoe;
+		uint16_t ppp_pid;
+		struct dpa_cls_compat_hm_custom_ins_params custom;
 	};
-	compat_uptr_t	fm_pcd;
+	compat_uptr_t fm_pcd;
+	bool reparse;
 };
 
 struct compat_ioc_dpa_cls_hm_insert_params {
@@ -346,6 +348,7 @@ struct dpa_cls_compat_hm_vlan_params {
 		struct dpa_cls_hm_egress_vlan_params	egress;
 	};
 	compat_uptr_t	fm_pcd;
+	bool reparse;
 };
 
 struct dpa_cls_compat_hm_vlan_resources {
@@ -377,7 +380,7 @@ struct dpa_cls_compat_hm_nat_pt_params {
 };
 
 struct dpa_cls_compat_hm_nat_params {
-	int	flags;
+	int		flags;
 	enum dpa_cls_hm_nat_proto	proto;
 	enum dpa_cls_hm_nat_type	type;
 	union {
@@ -387,6 +390,7 @@ struct dpa_cls_compat_hm_nat_params {
 	uint16_t	sport;
 	uint16_t	dport;
 	compat_uptr_t	fm_pcd;
+	bool		reparse;
 };
 
 struct dpa_cls_compat_hm_nat_resources {
@@ -404,7 +408,7 @@ struct compat_ioc_dpa_cls_hm_nat_params {
 };
 
 struct dpa_cls_compat_hm_update_params {
-	int	op_flags;
+	int					op_flags;
 	union {
 		struct compat_ipv4_header	new_ipv4_hdr;
 		struct ipv6_header		new_ipv6_hdr;
@@ -415,6 +419,7 @@ struct dpa_cls_compat_hm_update_params {
 	} update;
 	struct dpa_cls_hm_ip_frag_params	ip_frag_params;
 	compat_uptr_t				fm_pcd;
+	bool					reparse;
 };
 
 struct dpa_cls_compat_hm_update_resources {
@@ -441,6 +446,7 @@ struct dpa_cls_compat_hm_fwd_params {
 	};
 	struct dpa_cls_hm_ip_frag_params	ip_frag_params;
 	compat_uptr_t				fm_pcd;
+	bool					reparse;
 };
 
 struct dpa_cls_compat_hm_fwd_resources {
@@ -463,6 +469,7 @@ struct dpa_cls_compat_hm_mpls_params {
 	struct mpls_header		mpls_hdr[DPA_CLS_HM_MAX_MPLS_LABELS];
 	unsigned int			num_labels;
 	compat_uptr_t			fm_pcd;
+	bool				reparse;
 };
 
 struct dpa_cls_compat_hm_mpls_resources {
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 1e35b09..0e08edd 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -2637,9 +2637,10 @@ int dpa_cls_hm_remove_params_compatcpy(
 	memcpy(&kparam->rm_params.custom, &uparam->rm_params.custom,
 		sizeof(struct dpa_cls_hm_custom_rm_params));
 
-	kparam->rm_params.fm_pcd = compat_ptr(uparam->rm_params.fm_pcd);
-	kparam->next_hmd	= uparam->next_hmd;
-	kparam->hmd		= uparam->hmd;
+	kparam->rm_params.fm_pcd	= compat_ptr(uparam->rm_params.fm_pcd);
+	kparam->rm_params.reparse	= uparam->rm_params.reparse;
+	kparam->next_hmd		= uparam->next_hmd;
+	kparam->hmd			= uparam->hmd;
 
 	if (uparam->res.remove_node)
 		kparam->res.remove_node	= compat_get_id2ptr(
@@ -2687,9 +2688,10 @@ int dpa_cls_hm_insert_params_compatcpy(
 		break;
 	}
 
-	kparam->ins_params.fm_pcd = compat_ptr(uparam->ins_params.fm_pcd);
-	kparam->next_hmd	= uparam->next_hmd;
-	kparam->hmd		= uparam->hmd;
+	kparam->ins_params.fm_pcd	= compat_ptr(uparam->ins_params.fm_pcd);
+	kparam->ins_params.reparse	= uparam->ins_params.reparse;
+	kparam->next_hmd		= uparam->next_hmd;
+	kparam->hmd			= uparam->hmd;
 	if (uparam->res.insert_node)
 		kparam->res.insert_node	= compat_get_id2ptr(
 							uparam->res.insert_node,
@@ -2727,6 +2729,7 @@ int dpa_cls_hm_vlan_params_compatcpy(
 	}
 
 	kparam->vlan_params.fm_pcd = compat_ptr(uparam->vlan_params.fm_pcd);
+	kparam->vlan_params.reparse = uparam->vlan_params.reparse;
 	kparam->next_hmd	= uparam->next_hmd;
 	kparam->hmd		= uparam->hmd;
 
@@ -2778,11 +2781,12 @@ int dpa_cls_hm_nat_params_compatcpy(
 			memcpy(&kparam->nat_params.nat, &uparam->nat_params.nat,
 			      sizeof(struct dpa_cls_hm_traditional_nat_params));
 
-	kparam->nat_params.fm_pcd = compat_ptr(uparam->nat_params.fm_pcd);
-	kparam->nat_params.sport = uparam->nat_params.sport;
-	kparam->nat_params.dport = uparam->nat_params.dport;
-	kparam->next_hmd	= uparam->next_hmd;
-	kparam->hmd		= uparam->hmd;
+	kparam->nat_params.fm_pcd	= compat_ptr(uparam->nat_params.fm_pcd);
+	kparam->nat_params.reparse	= uparam->nat_params.reparse;
+	kparam->nat_params.sport	= uparam->nat_params.sport;
+	kparam->nat_params.dport	= uparam->nat_params.dport;
+	kparam->next_hmd		= uparam->next_hmd;
+	kparam->hmd			= uparam->hmd;
 
 	if (uparam->res.l3_update_node)
 		kparam->res.l3_update_node = compat_get_id2ptr(
@@ -2840,6 +2844,7 @@ int dpa_cls_hm_update_params_compatcpy(
 
 
 	kparam->update_params.fm_pcd = compat_ptr(uparam->update_params.fm_pcd);
+	kparam->update_params.reparse = uparam->update_params.reparse;
 	kparam->next_hmd	= uparam->next_hmd;
 	kparam->hmd		= uparam->hmd;
 
@@ -2869,8 +2874,9 @@ int dpa_cls_hm_fwd_params_compatcpy(
 {
 	int type;
 
-	kparam->fwd_params.out_if_type = uparam->fwd_params.out_if_type;
-	kparam->fwd_params.fm_pcd = compat_ptr(uparam->fwd_params.fm_pcd);
+	kparam->fwd_params.out_if_type	= uparam->fwd_params.out_if_type;
+	kparam->fwd_params.fm_pcd	= compat_ptr(uparam->fwd_params.fm_pcd);
+	kparam->fwd_params.reparse	= uparam->fwd_params.reparse;
 
 	type = kparam->fwd_params.out_if_type;
 	switch (type) {
@@ -2932,6 +2938,7 @@ int dpa_cls_hm_mpls_params_compatcpy(
 		sizeof(struct mpls_header) * DPA_CLS_HM_MAX_MPLS_LABELS);
 	kparam->mpls_params.num_labels = uparam->mpls_params.num_labels;
 	kparam->mpls_params.fm_pcd = compat_ptr(uparam->mpls_params.fm_pcd);
+	kparam->mpls_params.reparse = uparam->mpls_params.reparse;
 	kparam->next_hmd	= uparam->next_hmd;
 	kparam->hmd		= uparam->hmd;
 
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index f81909f..cefa20c 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -634,6 +634,11 @@ struct dpa_cls_hm_nat_params {
 	 * manipulation object.
 	 */
 	void							*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this NAT.
+	 */
+	bool							reparse;
 };
 
 /* Output interface type for forwarding */
@@ -766,6 +771,12 @@ struct dpa_cls_hm_fwd_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this forwarding
+	 * header manipulation.
+	 */
+	bool						reparse;
 };
 
 /* Types of the remove header manipulation operations */
@@ -831,6 +842,11 @@ struct dpa_cls_hm_remove_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this header remove.
+	 */
+	bool						reparse;
 };
 
 /* Types of insert header manipulation operations */
@@ -953,6 +969,11 @@ struct dpa_cls_hm_insert_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this header insert.
+	 */
+	bool						reparse;
 };
 
 /* Update header manipulation op flags */
@@ -1111,6 +1132,11 @@ struct dpa_cls_hm_update_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this header update.
+	 */
+	bool						reparse;
 };
 
 /* VLAN specific header manipulation operation types */
@@ -1231,6 +1257,12 @@ struct dpa_cls_hm_vlan_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this VLAN header
+	 * update.
+	 */
+	bool						reparse;
 };
 
 /* MPLS specific header manipulation operation types */
@@ -1281,6 +1313,12 @@ struct dpa_cls_hm_mpls_params {
 	 * manipulation object.
 	 */
 	void				*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this MPLS header
+	 * update.
+	 */
+	bool				reparse;
 };
 
 
-- 
1.9.1

