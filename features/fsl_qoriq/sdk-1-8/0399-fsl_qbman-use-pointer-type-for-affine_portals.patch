From f4a6b62034f4d6a435c79ef678fa4c8f576112dd Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Tue, 15 Oct 2013 12:00:59 -0400
Subject: [PATCH 399/987] fsl_qbman: use pointer type for affine_portals

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Those pointers don't need to be converted to a "numerical" form

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: Ic6ee5d3e20ae6134bbb571a832938996b3a023e7
Reviewed-on: http://git.am.freescale.net:8181/5633
Reviewed-by: Ladouceur Jeffrey-R11498 <Jeffrey.Ladouceur@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thorpe Geoff-R01361 <Geoff.Thorpe@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/bman_driver.c  | 6 +++---
 drivers/staging/fsl_qbman/qman_driver.c  | 2 +-
 drivers/staging/fsl_qbman/qman_high.c    | 8 ++++----
 drivers/staging/fsl_qbman/qman_private.h | 2 +-
 include/linux/fsl_qman.h                 | 2 +-
 5 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 2a59721..3bd5160 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -52,7 +52,7 @@ static int num_shared_portals;
 static int shared_portals_idx;
 static LIST_HEAD(unused_pcfgs);
 static DEFINE_SPINLOCK(unused_pcfgs_lock);
-static uintptr_t affine_bportals[NR_CPUS];
+static void *affine_bportals[NR_CPUS];
 
 static int __init fsl_bpool_init(struct device_node *node)
 {
@@ -252,7 +252,7 @@ static struct bman_portal *init_pcfg(struct bm_portal_config *pcfg)
 		pr_info("Bman portal %sinitialised, cpu %d\n",
 			pcfg->public_cfg.is_shared ? "(shared) " : "",
 			pcfg->public_cfg.cpu);
-		affine_bportals[pcfg->public_cfg.cpu] = (uintptr_t)p;
+		affine_bportals[pcfg->public_cfg.cpu] = p;
 	} else
 		pr_crit("Bman portal failure on cpu %d\n",
 			pcfg->public_cfg.cpu);
@@ -269,7 +269,7 @@ static void init_slave(int cpu)
 		pr_info("Bman portal %sinitialised, cpu %d\n", "(slave) ", cpu);
 	if (shared_portals_idx >= num_shared_portals)
 		shared_portals_idx = 0;
-	affine_bportals[cpu] = (uintptr_t)p;
+	affine_bportals[cpu] = p;
 }
 
 /* Bootarg "bportals=[...]" has the same syntax as "qportals=", and so the
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 10ee9cd..4119128 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -725,7 +725,7 @@ __init int qman_init(void)
 			return ret;
 	}
 
-	memset(&affine_portals, 0, sizeof(uintptr_t) * num_possible_cpus());
+	memset(affine_portals, 0, sizeof(void *) * num_possible_cpus());
 	/* Initialise portals. See bman_driver.c for comments */
 	for_each_compatible_node(dn, NULL, "fsl,qman-portal") {
 		if (!of_device_is_available(dn))
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index b0a5de3..b369cd5 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -154,7 +154,7 @@ static cpumask_t affine_mask;
 static DEFINE_SPINLOCK(affine_mask_lock);
 static u16 affine_channels[NR_CPUS];
 static DEFINE_PER_CPU(struct qman_portal, qman_affine_portal);
-uintptr_t affine_portals[NR_CPUS];
+void *affine_portals[NR_CPUS];
 
 /* "raw" gets the cpu-local struct whether it's a redirect or not. */
 static inline struct qman_portal *get_raw_affine_portal(void)
@@ -560,7 +560,7 @@ struct qman_portal *qman_create_affine_portal(
 		cpumask_set_cpu(config->public_cfg.cpu, &affine_mask);
 		affine_channels[config->public_cfg.cpu] =
 			config->public_cfg.channel;
-		affine_portals[config->public_cfg.cpu] = (uintptr_t)portal;
+		affine_portals[config->public_cfg.cpu] = portal;
 		spin_unlock(&affine_mask_lock);
 	}
 	return res;
@@ -583,7 +583,7 @@ struct qman_portal *qman_create_affine_slave(struct qman_portal *redirect,
 	/* These are the only elements to initialise when redirecting */
 	p->irq_sources = 0;
 	p->sharing_redirect = redirect;
-	affine_portals[cpu] = (uintptr_t)p;
+	affine_portals[cpu] = p;
 	return p;
 #else
 	BUG();
@@ -1090,7 +1090,7 @@ u16 qman_affine_channel(int cpu)
 }
 EXPORT_SYMBOL(qman_affine_channel);
 
-uintptr_t qman_get_affine_portal(int cpu)
+void *qman_get_affine_portal(int cpu)
 {
 	return affine_portals[cpu];
 }
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index 5f9912b..fd322e0 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -392,7 +392,7 @@ int qman_ceetm_query_ccgr(struct qm_mcc_ceetm_ccgr_query *ccgr_query,
 int qman_ceetm_get_xsfdr(enum qm_dc_portal portal, unsigned int *num);
 
 /* Portal migration */
-extern uintptr_t affine_portals[NR_CPUS];
+extern void *affine_portals[NR_CPUS];
 int qman_portal_is_sharing_redirect(struct qman_portal *portal);
 void qman_migrate_portal(struct qman_portal *portal);
 void qman_migrate_portal_back(struct qman_portal *portal, unsigned int cpu);
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 4c74bb4..d1ba1fe 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1672,7 +1672,7 @@ u16 qman_affine_channel(int cpu);
  * @cpu: the cpu whose affine portal is the subject of the query
  *
  */
-uintptr_t qman_get_affine_portal(int cpu);
+void *qman_get_affine_portal(int cpu);
 
 /**
  * qman_poll_dqrr - process DQRR (fast-path) entries
-- 
1.9.1

