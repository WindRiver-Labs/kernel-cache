From 24255f1fb8dd13129afdd345fa4aab7f7c08539c Mon Sep 17 00:00:00 2001
From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date: Thu, 27 Mar 2014 14:09:02 +0100
Subject: [PATCH] ls10xx: net: gianfar: do not try to cleanup TX packets if
 they are not done

What I observe is that the TX queue is not empty and does not make any
progress. gfar_clean_tx_ring() does not clean up the packet because it
is not completed yet.
The root cause is that the DMA engine did not start yet (it was
preempted before doing so) and that dumb loop, loops until that packet
is gone.
This is broken since c233cf4 ("gianfar: Fix tx napi polling").

What remains are spurious interrupts if CPU0 cleans up TX packages and
CPU1 returns with IRQ_NONE.

Cc: stable-rt@vger.kernel.org
Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
[Kevin: Only minor modification due to the context change.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   11 +++++++----
 1 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 2be57fd..fd4c1f9 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -167,7 +167,6 @@ static int gfar_poll_tx(struct napi_struct *napi, int budget);
 static void gfar_netpoll(struct net_device *dev);
 #endif
 int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit);
-static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue);
 static void gfar_process_frame(struct net_device *dev, struct sk_buff *skb,
 			       int amount_pull, struct napi_struct *napi);
 static int __gfar_is_rx_idle(struct gfar_private *priv);
@@ -2803,7 +2802,7 @@ static void gfar_recycle_skb(struct sk_buff *skb)
 }
 
 /* Interrupt Handler for Transmit complete */
-static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
+static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 {
 	struct net_device *dev = tx_queue->dev;
 	struct netdev_queue *txq;
@@ -2936,6 +2935,7 @@ static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 	/* Update dirty indicators */
 	tx_queue->skb_dirtytx = skb_dirtytx;
 	tx_queue->dirty_tx = bdp;
+	return howmany;
 }
 
 static struct sk_buff *gfar_alloc_skb(struct net_device *dev)
@@ -3381,8 +3381,11 @@ static int gfar_poll_tx(struct napi_struct *napi, int budget)
 		tx_queue = priv->tx_queue[i];
 		/* run Tx cleanup to completion */
 		if (tx_queue->tx_skbuff[tx_queue->skb_dirtytx]) {
-			gfar_clean_tx_ring(tx_queue);
-			has_tx_work = 1;
+			int ret;
+
+			ret = gfar_clean_tx_ring(tx_queue);
+			if (ret)
+				has_tx_work++;
 		}
 	}
 
-- 
1.7.5.4

