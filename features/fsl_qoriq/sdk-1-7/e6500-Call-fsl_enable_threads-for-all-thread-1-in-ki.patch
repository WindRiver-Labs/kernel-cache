From 3546c5463b6f8b800a5b74c977e6de530c12b0c2 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Tue, 3 Feb 2015 14:30:38 +0800
Subject: [PATCH] e6500:Call fsl_enable_threads() for all thread 1 in
 kick_cpu()

There is a new implementation of kick_cpu() on e6500 introduced by
commit 6c716f16(Fix e6500-based platform CPU hotplug issue).

The new implementation leads following call-trace when wake up thread 1 in
core 0, and can not wake up thread 1 in other cores.

BUG: scheduling while atomic: sh/17609/0x00000002
CPU: 0 PID: 17609 Comm: sh Tainted: G C 3.14.23-WR7.0.0.2_cgl #1
Call Trace:
[c0000000f58431b0] [c00000000000a748] .show_stack+0x168/0x278 (unreliable)
[c0000000f58432a0] [c000000000b41b78] .dump_stack+0x9c/0xfc
[c0000000f5843320] [c0000000000a76c0] .__schedule_bug+0x74/0x8c
[c0000000f58433a0] [c000000000b2d5d0] .__schedule+0x6a0/0x848
[c0000000f5843600] [c000000000b2c704] .schedule_timeout+0x16c/0x2c4
[c0000000f5843700] [c00000000007eb84] .msleep+0x40/0x5c
[c0000000f5843790] [c000000000026ee0] .__cpu_up+0x22c/0x2ac
[c0000000f5843830] [c00000000006c08c] ._cpu_up+0x1b8/0x1f4
[c0000000f58438f0] [c00000000006c17c] .cpu_up+0xb4/0xd8
[c0000000f5843980] [c0000000009a8c18] .cpu_subsys_online+0x24/0x3c

The calltrace is triggered by following sequence:
	get_cpu()-->preempt_off()
then
	work_on_cpu()-->__schedule()

Since this piece of code works in an interrupt-disabled context, we
could call smp_processor_id() directly.

Actually, sending an IPI can not wakeup thread 1. Thread 1 in each
core must start by invoking fsl_enable_threads() by the thread 0 on
the same core. This patch invokes fsl_enable_threads() for thread1
instead of sending an IPI.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/platforms/85xx/smp.c |   25 +++++++------------------
 1 files changed, 7 insertions(+), 18 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index 1001f6d..e03d0e5 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -489,25 +489,14 @@ static int smp_85xx_kick_cpu(int nr)
 #ifdef CONFIG_PPC_E500MC
 			if (system_state == SYSTEM_RUNNING) {
 				/*
-				 * In cpu hotplug case, Thread 1 of Core0
-				 * must start by Thread0 of Core0 calling
-				 * fsl_enable_threads().
+				 * In cpu hotplug case, Thread 1 must start by calling
+				 * fsl_enable_threads() by the thread0 on the same core.
 				 */
-				if (nr == 1) {
-					if (get_cpu() == boot_cpuid)
-						fsl_enable_threads(&ret);
-					else
-						work_on_cpu(boot_cpuid,
-						    fsl_enable_threads, NULL);
-				}
-
-				/*
-				 * Thread 1 of other cores can be waken up from
-				 * low-power state when Thread 0 is online,
-				 * or restart by Thread 0 after core reset.
-				 */
-				if (!strcmp(cur_cpu_spec->cpu_name, "e6500"))
-					arch_send_call_function_single_ipi(nr);
+				if (smp_processor_id() == cpu_first_thread_sibling(nr))
+					fsl_enable_threads(NULL);
+				else
+					work_on_cpu(cpu_first_thread_sibling(nr),
+						fsl_enable_threads, NULL);
 
 				if (qoriq_pm_ops->irq_unmask)
 					qoriq_pm_ops->irq_unmask(nr);
-- 
1.7.5.4

