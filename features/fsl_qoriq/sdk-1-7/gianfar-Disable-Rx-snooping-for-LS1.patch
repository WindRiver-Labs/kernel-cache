From e4136c9ba9298fee27695a0a567345fbb371de17 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Wed, 3 Dec 2014 17:10:44 +0200
Subject: [PATCH 122/128] gianfar: Disable Rx snooping for LS1

It was observed that Rx snooping incurs a significant
performance penalty.  My suspicion is that it interferes
with the DMA software coherency, currently performed
by DMA-API.  It is known that there are H/W coherency
issues at least for the Tx side (see read data interleaving
issue) which is why the software coherency is needed in the
first place.  This patch disables Rx snooping as well, as a
workaround, until the root cause for the Rx side coherency
related issue is found.

Change-Id: I00c3a5723d52d2f9a9d18e11b5c64c9c208c466b
Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/25325
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
Reviewed-by: Matthew Weigel <Matthew.Weigel@freescale.com>
[Xulin: Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto_RDS_20150206.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   34 +++++++++++++++--------------
 drivers/net/ethernet/freescale/gianfar.h |    8 ++++++-
 2 files changed, 25 insertions(+), 17 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index ed4523b..9a780b4 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -238,10 +238,9 @@ static int gfar_init_bds(struct net_device *ndev)
 			struct sk_buff *skb = rx_queue->rx_skbuff[j];
 
 			if (skb) {
-				gfar_init_rxbdp(rx_queue, rxbdp,
-						be32_to_cpu(rxbdp->bufPtr));
+				bufaddr = be32_to_cpu(rxbdp->bufPtr);
 			} else {
-				skb = gfar_alloc_skb(ndev);
+				skb = gfar_new_skb(ndev, &bufaddr);
 				if (!skb) {
 					netdev_err(ndev, "Can't allocate RX buffers\n");
 					return -ENOMEM;
@@ -1836,9 +1835,7 @@ static int gfar_resume(struct device *dev)
 	struct net_device *ndev = priv->ndev;
 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
 	u32 tempval;
-	int magic_packet = priv->wol_en &&
-			   (priv->device_flags &
-			    FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+	u16 wol = priv->wol_opts;
 
 	if (!netif_running(ndev))
 		return 0;
@@ -2968,22 +2965,28 @@ static struct sk_buff *gfar_alloc_skb(struct net_device *dev)
 	return skb;
 }
 
-struct sk_buff *gfar_new_skb(struct net_device *dev)
+static struct sk_buff *gfar_new_skb(struct net_device *dev, dma_addr_t *bufaddr)
 {
        struct gfar_private *priv = netdev_priv(dev);
        struct sk_buff *skb;
+	dma_addr_t addr;
 
-       if (likely(priv->rx_buffer_size <= DEFAULT_RX_BUFFER_SIZE)) {
-               struct sk_buff_head *h = &__get_cpu_var(skb_recycle_list);
+	skb = gfar_alloc_skb(dev);
+	if (!skb)
+		return NULL;
 
-               skb = __skb_dequeue(h);
-               if (skb != NULL)
-                       return skb;
-       }
+	addr = dma_map_single(priv->dev, skb->data,
+			      priv->rx_buffer_size, DMA_FROM_DEVICE);
+	if (unlikely(dma_mapping_error(priv->dev, addr))) {
+		dev_kfree_skb_any(skb);
+		return NULL;
+	}
 
-       return gfar_alloc_skb(dev);
+	*bufaddr = addr;
+	return skb;
 }
 
+
 irqreturn_t gfar_receive(int irq, void *grp_id)
 {
 	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
@@ -3013,7 +3016,6 @@ irqreturn_t gfar_receive(int irq, void *grp_id)
 
 	return IRQ_HANDLED;
 }
-EXPORT_SYMBOL(gfar_new_skb);
 
 /* Interrupt Handler for Transmit complete */
 static irqreturn_t gfar_transmit(int irq, void *grp_id)
@@ -3171,7 +3173,7 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 
 	amount_pull = priv->uses_rxfcb ? GMAC_FCB_LEN : 0;
 
-	while (!((bdp->status & RXBD_EMPTY) || (--rx_work_limit < 0))) {
+	while (!(be16_to_cpu(bdp->status) & RXBD_EMPTY) && rx_work_limit--) {
 		struct sk_buff *newskb;
 		dma_addr_t bufaddr;
 
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 7f55492..262e896 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -29,6 +29,7 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
+#include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -495,7 +496,12 @@ extern const char gfar_driver_version[];
 #define ATTR_BUFSTASH		0x00004000
 
 #define ATTR_SNOOPING		0x000000c0
+
+#ifdef CONFIG_SOC_LS1021A
+#define ATTR_INIT_SETTINGS      0
+#else
 #define ATTR_INIT_SETTINGS      ATTR_SNOOPING
+#endif
 
 #define ATTRELI_INIT_SETTINGS   0x0
 #define ATTRELI_EL_MASK		0x3fff0000
@@ -1670,7 +1676,7 @@ static inline void gfar_init_rxbdp(struct gfar_priv_rx_q *rx_queue,
 	if (bdp == rx_queue->rx_bd_base + rx_queue->rx_ring_size - 1)
 		lstatus |= BD_LFLAG(RXBD_WRAP);
 
-	eieio();
+	gfar_wmb();
 
 	bdp->lstatus = cpu_to_be32(lstatus);
 }
-- 
1.7.5.4

