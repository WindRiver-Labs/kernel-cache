From 10b5e989e9bdf1f3f2edf96bc52d2161c3ff35d5 Mon Sep 17 00:00:00 2001
From: Ahmed Mansour <Ahmed.Mansour@freescale.com>
Date: Wed, 5 Nov 2014 15:28:53 -0500
Subject: [PATCH 090/399] qbman: Corrections based on static analysis

ioctl_dma_map. String length check

Added check to ensure the string copied from user space is within
the length allowed for by the buffer and is null terminated.

qm_shutdown_fq. Remove deadcode

Removed the case statement label for QM_MCR_NP_STATE_OOS since
that condition is checked for earlier in the code and in that
case the function exits immediately.

ioctl_dma_lock. Remove NULL dereference

A pointer is made null and then there is an attempt to dereference one
of the members of the struct that it points to. This condition is never
reached normally, but in error conditions this path of execution may be
possible.

Added return -EFAULT to exit function safely and unlocked locked resources

usdpaa_get_unmapped_area. Arithmetic overflow protection

Added a check to ensure that memory length passed in does not result in
an invalid size to be passed because of a possible arithmetic overflow
that can occur in the subtraction in the macro USDPAA_MEM_ROUNDUP.

qman_ceetm_ccg_claim. If condition fix

Removed a check against an unsigned int value that checks if it is
below zero (negative). The unsigned value cannot be negative and the
compare will always fail in reality.

qman_create_portal. Add comment to clarify flow

Clarified why no check is made to ensure that qm_mr_current()
returned successfully. The addition of a redundant check was rejected
because it impairs the reader's understanding of the flow
by implying the possibility of a physically impossible path.

dpa_alloc_new. Fix memory leak in error conditions

Previously allocated memory which is passed by reference in
success (list_add_tail) is not freed in error conditions
that occur in other parts of the function. Added code to free
allocated memory in error cases.

qman_create_portal. Fix memory leak in error path

Added cleanup code that deletes malloced memory in case
of function failure after memory is allocated.

ioctl_dma_map. Input bound checks on values from USDPAA

Check the struct usdpaa_ioctl_dma_map, input, to ensure that values
copied from user space are valid input.

qman_init. Check init_pcfg return

Previously unused assignment is now being used. The return of
init_pcfg() was not checked for success. Now we check for success
and print an error message in case of failure.
There is a similar issue in bman_driver.

bman_init. Check init_pcfg return

Added check to ensure init_pcfg() is returning successfully.
Print an error message and return if in error case.
There is a similar issue in qman_driver.

Signed-off-by: Ahmed Mansour <Ahmed.Mansour@freescale.com>
Change-Id: I230678948c3e8e43aa5738045244c5dac0b5f5f5
Reviewed-on: http://git.am.freescale.net:8181/21381
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Reviewed-by: Matthew Weigel <Matthew.Weigel@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/bman_driver.c |    4 ++
 drivers/staging/fsl_qbman/dpa_alloc.c   |    2 +
 drivers/staging/fsl_qbman/fsl_usdpaa.c  |   14 +++++++-
 drivers/staging/fsl_qbman/qman_driver.c |    4 ++
 drivers/staging/fsl_qbman/qman_high.c   |   54 +++++++++++++++++++++++++-----
 drivers/staging/fsl_qbman/qman_low.h    |    3 --
 6 files changed, 68 insertions(+), 13 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 7ef20e3..2eb590f 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -468,6 +468,10 @@ __init int bman_init(void)
 	list_for_each_entry(pcfg, &unshared_pcfgs, list) {
 		pcfg->public_cfg.is_shared = 0;
 		p = init_pcfg(pcfg);
+		if (!p) {
+			pr_crit("Unable to initialize bman portal\n");
+			return 0;
+		}
 	}
 	/* Step 5. */
 	list_for_each_entry(pcfg, &shared_pcfgs, list) {
diff --git a/drivers/staging/fsl_qbman/dpa_alloc.c b/drivers/staging/fsl_qbman/dpa_alloc.c
index e102368..b62b502 100644
--- a/drivers/staging/fsl_qbman/dpa_alloc.c
+++ b/drivers/staging/fsl_qbman/dpa_alloc.c
@@ -510,6 +510,8 @@ done:
 		*result = base;
 	} else {
 		spin_unlock_irq(&alloc->lock);
+		kfree(margin_left);
+		kfree(margin_right);
 	}
 
 err:
diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index e8f66ca..b1b38f5 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -758,6 +758,9 @@ static unsigned long usdpaa_get_unmapped_area(struct file *file,
 	   will be correctly aligned */
 	len = largest_page_size(len);
 
+	if (!len)
+		return -EINVAL;
+
 	addr = USDPAA_MEM_ROUNDUP(addr, len);
 	vma = find_vma(current->mm, addr);
 	/* Keep searching until we reach the end of currently-used virtual
@@ -907,7 +910,8 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 	int frag_count = 0;
 	unsigned long next_addr = PAGE_SIZE, populate;
 
-	if (i->len && i->len % PAGE_SIZE)
+	/* error checking to ensure values copied from user space are valid */
+	if (!i->len || (i->len % PAGE_SIZE))
 		return -EINVAL;
 
 	map = kmalloc(sizeof(*map), GFP_KERNEL);
@@ -1038,8 +1042,14 @@ do_map:
 				       struct mem_fragment, list);
 	}
 	if (i->did_create) {
+		size_t name_len = 0;
 		start_frag->flags = i->flags;
 		strncpy(start_frag->name, i->name, USDPAA_DMA_NAME_MAX);
+		name_len = strnlen(start_frag->name, USDPAA_DMA_NAME_MAX);
+		if (name_len >= USDPAA_DMA_NAME_MAX) {
+			ret = -EFAULT;
+			goto out;
+		}
 		start_frag->map_len = i->len;
 		start_frag->has_locking = i->has_locking;
 		init_waitqueue_head(&start_frag->wq);
@@ -1187,6 +1197,8 @@ map_match:
 	spin_unlock(&mem_lock);
 	up_read(&current->mm->mmap_sem);
 
+	if (!map)
+		return -EFAULT;
 	if (!map->root_frag->has_locking)
 		return -ENODEV;
 	return wait_event_interruptible(map->root_frag->wq, test_lock(map));
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index e98bafb..9d3ddb5 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -856,6 +856,10 @@ __init int qman_init(void)
 	list_for_each_entry(pcfg, &unshared_pcfgs, list) {
 		pcfg->public_cfg.is_shared = 0;
 		p = init_pcfg(pcfg);
+		if (!p) {
+			pr_crit("Unable to configure portals\n");
+			return 0;
+		}
 	}
 	list_for_each_entry(pcfg, &shared_pcfgs, list) {
 		pcfg->public_cfg.is_shared = 1;
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 9218de4..bd06301 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -571,6 +571,10 @@ struct qman_portal *qman_create_portal(
 		/* drain all mr message */
 		if (qm_drain_mr(__p)) {
 			const struct qm_mr_entry *e = qm_mr_current(__p);
+			/*
+			 * Message ring cannot be empty no need to check
+			 * qm_mr_current returned successfully
+			 */
 			pr_err("Qman MR unclean, MR VERB 0x%x, "
 			       "rc 0x%x\n, addr 0x%x",
 			       e->verb, e->ern.rc, e->ern.fd.addr_lo);
@@ -609,6 +613,8 @@ fail_mr:
 fail_dqrr:
 	qm_eqcr_finish(__p);
 fail_eqcr:
+	if (portal->alloced)
+		kfree(portal);
 	return NULL;
 }
 
@@ -3640,10 +3646,16 @@ int qman_ceetm_channel_claim(struct qm_ceetm_channel **channel,
 	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
 	static u8 map;
 
-	if (lni->dcp_idx == qm_dc_portal_fman0)
+	if (lni->dcp_idx == qm_dc_portal_fman0) {
 		ret = qman_alloc_ceetm0_channel(&channel_idx);
-	if (lni->dcp_idx == qm_dc_portal_fman1)
+	} else if (lni->dcp_idx == qm_dc_portal_fman1) {
 		ret = qman_alloc_ceetm1_channel(&channel_idx);
+	} else {
+		pr_err("dcp_idx %u does not correspond to a known fman in this driver\n",
+			lni->dcp_idx);
+		return -EINVAL;
+	}
+
 	if (ret) {
 		pr_err("The is no channel available for LNI#%d\n", lni->idx);
 		return -ENODEV;
@@ -3684,6 +3696,14 @@ int qman_ceetm_channel_release(struct qm_ceetm_channel *channel)
 		return -EBUSY;
 	}
 
+	/* channel->dcp_idx corresponds to known fman validation */
+	if ((channel->dcp_idx != qm_dc_portal_fman0) &&
+	    (channel->dcp_idx != qm_dc_portal_fman1)) {
+		pr_err("dcp_idx %u does not correspond to a known fman in this driver\n",
+			channel->dcp_idx);
+		return -EINVAL;
+	}
+
 	config_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
 	config_opts.dcpid = channel->dcp_idx;
 	memset(&config_opts.shaper_config, 0,
@@ -3693,10 +3713,15 @@ int qman_ceetm_channel_release(struct qm_ceetm_channel *channel)
 		return -EINVAL;
 	}
 
-	if (channel->dcp_idx == qm_dc_portal_fman0)
+	if (channel->dcp_idx == qm_dc_portal_fman0) {
 		qman_release_ceetm0_channelid(channel->idx);
-	if (channel->dcp_idx == qm_dc_portal_fman1)
+	} else if (channel->dcp_idx == qm_dc_portal_fman1) {
 		qman_release_ceetm1_channelid(channel->idx);
+	} else {
+		pr_err("dcp_idx %u does not correspond to a known fman in this driver\n",
+			channel->dcp_idx);
+		return -EINVAL;
+	}
 	list_del(&channel->node);
 	kfree(channel);
 
@@ -4452,10 +4477,16 @@ int qman_ceetm_lfq_claim(struct qm_ceetm_lfq **lfq,
 	int ret = 0;
 	struct qm_mcc_ceetm_lfqmt_config lfqmt_config;
 
-	if (cq->parent->dcp_idx == qm_dc_portal_fman0)
+	if (cq->parent->dcp_idx == qm_dc_portal_fman0) {
 		ret = qman_alloc_ceetm0_lfqid(&lfqid);
-	if (cq->parent->dcp_idx == qm_dc_portal_fman1)
+	} else if (cq->parent->dcp_idx == qm_dc_portal_fman1) {
 		ret = qman_alloc_ceetm1_lfqid(&lfqid);
+	} else {
+		pr_err("dcp_idx %u does not correspond to a known fman in this driver\n",
+			cq->parent->dcp_idx);
+		return -EINVAL;
+	}
+
 	if (ret) {
 		pr_err("There is no lfqid avalaible for CQ#%d!\n", cq->idx);
 		return -ENODEV;
@@ -4485,10 +4516,15 @@ EXPORT_SYMBOL(qman_ceetm_lfq_claim);
 
 int qman_ceetm_lfq_release(struct qm_ceetm_lfq *lfq)
 {
-	if (lfq->parent->dcp_idx == qm_dc_portal_fman0)
+	if (lfq->parent->dcp_idx == qm_dc_portal_fman0) {
 		qman_release_ceetm0_lfqid(lfq->idx);
-	if (lfq->parent->dcp_idx == qm_dc_portal_fman1)
+	} else if (lfq->parent->dcp_idx == qm_dc_portal_fman1) {
 		qman_release_ceetm1_lfqid(lfq->idx);
+	} else {
+		pr_err("dcp_idx %u does not correspond to a known fman in this driver\n",
+			lfq->parent->dcp_idx);
+		return -EINVAL;
+	}
 	list_del(&lfq->node);
 	kfree(lfq);
 	return 0;
@@ -4552,7 +4588,7 @@ int qman_ceetm_ccg_claim(struct qm_ceetm_ccg **ccg,
 {
 	struct qm_ceetm_ccg *p;
 
-	if ((idx < 0) || (idx > 15)) {
+	if (idx > 15) {
 		pr_err("The given ccg index is out of range\n");
 		return -EINVAL;
 	}
diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index 5d3e820..2fe7a1e 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -1339,9 +1339,6 @@ static inline int qm_shutdown_fq(struct qm_portal **portal, int portal_count,
 			return -1;
 		}
 		return 0;
-	case QM_MCR_NP_STATE_OOS:
-		/*  Done */
-		return 0;
 	}
 	return -1;
 }
-- 
1.7.5.4

