From bd771a566cfc8c8d095f9608d09c7d9f6629d826 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 16 Sep 2014 12:19:36 +0300
Subject: [PATCH 070/399] dpa_offload: Avoid leaking memory in DPA statistics
 wrapper

Two memory leaks were fixed in DPA statistics wrapper.

In function "do_ioctl_stats_get_counters" the allocated memory for
"prm.req_params.cnts_ids" leaks in some cases of error and even in
successful function return.

In function "dpa_stats_tbl_cls_compatcpy" the memory allocated for "us_keys"
may leak in case the key type is DPA_STATS_CLASSIF_SINGLE_KEY.

Change-Id: Ifffd8d67f972473b75a43190155754d1af68fe84
Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/18810
Reviewed-by: Anca Jeanina Floarea <anca.floarea@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |   14 ++++++++++----
 1 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 57784a9..90d988c 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -1504,8 +1504,10 @@ static int do_ioctl_stats_get_counters(void *args)
 	/* If counters request is asynchronous */
 	if (prm.request_done) {
 		ret = store_get_cnts_async_params(&prm, cnts_ids);
-		if (ret < 0)
+		if (ret < 0) {
+			kfree(prm.req_params.cnts_ids);
 			return ret;
+		}
 	}
 
 	ret = dpa_stats_get_counters(prm.req_params,
@@ -1524,6 +1526,7 @@ static int do_ioctl_stats_get_counters(void *args)
 					  prm.req_params.storage_area_offset),
 					  prm.cnts_len)) {
 				log_err("Cannot copy counter values to storage area\n");
+				kfree(prm.req_params.cnts_ids);
 				return -EINVAL;
 			}
 
@@ -1588,8 +1591,10 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 	if (kprm.request_done) {
 		ret = store_get_cnts_async_params(&kprm,
 				(compat_ptr)(uprm.req_params.cnts_ids));
-		if (ret < 0)
+		if (ret < 0) {
+			kfree(kprm.req_params.cnts_ids);
 			return ret;
+		}
 	}
 
 	ret = dpa_stats_get_counters(kprm.req_params,
@@ -1915,7 +1920,6 @@ static long store_get_cnts_async_params(
 	mutex_lock(&wrp_dpa_stats.async_req_lock);
 	if (list_empty(&wrp_dpa_stats.async_req_pool)) {
 		log_err("Reached maximum supported number of simultaneous asynchronous requests\n");
-		kfree(kprm->req_params.cnts_ids);
 		mutex_unlock(&wrp_dpa_stats.async_req_lock);
 		return -EDOM;
 	}
@@ -2416,7 +2420,6 @@ static long dpa_stats_tbl_cls_compatcpy(
 				return ret;
 			}
 		}
-		kfree(us_keys);
 	}
 
 	if (kprm->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
@@ -2481,6 +2484,9 @@ static long dpa_stats_tbl_cls_compatcpy(
 			}
 		}
 	}
+
+	kfree(us_keys);
+
 	return 0;
 }
 
-- 
1.7.5.4

