From 4a208475a020e4176fcd94b2671edab268ed92e2 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Tue, 7 Oct 2014 10:44:29 +0300
Subject: [PATCH 237/399] net/fsl_pq_mdio: Use ioread/iowrite32be() portable
 accessors

commit f5bbd262e70ff2355ce4284b0ad9eaf93fb5e374 upstream

in_be32()/out_be32() are not defined by ARM.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 drivers/net/ethernet/freescale/fsl_pq_mdio.c |   28 +++++++++++++-------------
 1 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fsl_pq_mdio.c b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
index 958353c..f9fbb5f 100644
--- a/drivers/net/ethernet/freescale/fsl_pq_mdio.c
+++ b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
@@ -105,14 +105,14 @@ static int fsl_pq_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
 	u32 status;
 
 	/* Set the PHY address and the register address we want to write */
-	out_be32(&regs->miimadd, (mii_id << 8) | regnum);
+	iowrite32be((mii_id << 8) | regnum, &regs->miimadd);
 
 	/* Write out the value we want */
-	out_be32(&regs->miimcon, value);
+	iowrite32be(value, &regs->miimcon);
 
 	/* Wait for the transaction to finish */
-	status = spin_event_timeout(!(in_be32(&regs->miimind) &	MIIMIND_BUSY),
-				    MII_TIMEOUT, 0);
+	status = spin_event_timeout(!(ioread32be(&regs->miimind) &
+				    MIIMIND_BUSY), MII_TIMEOUT, 0);
 
 	return status ? 0 : -ETIMEDOUT;
 }
@@ -135,21 +135,21 @@ static int fsl_pq_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
 	u16 value;
 
 	/* Set the PHY address and the register address we want to read */
-	out_be32(&regs->miimadd, (mii_id << 8) | regnum);
+	iowrite32be((mii_id << 8) | regnum, &regs->miimadd);
 
 	/* Clear miimcom, and then initiate a read */
-	out_be32(&regs->miimcom, 0);
-	out_be32(&regs->miimcom, MII_READ_COMMAND);
+	iowrite32be(0, &regs->miimcom);
+	iowrite32be(MII_READ_COMMAND, &regs->miimcom);
 
 	/* Wait for the transaction to finish, normally less than 100us */
-	status = spin_event_timeout(!(in_be32(&regs->miimind) &
+	status = spin_event_timeout(!(ioread32be(&regs->miimind) &
 				    (MIIMIND_NOTVALID | MIIMIND_BUSY)),
 				    MII_TIMEOUT, 0);
 	if (!status)
 		return -ETIMEDOUT;
 
 	/* Grab the value of the register from miimstat */
-	value = in_be32(&regs->miimstat);
+	value = ioread32be(&regs->miimstat);
 
 	dev_dbg(&bus->dev, "read %04x from address %x/%x\n", value, mii_id, regnum);
 	return value;
@@ -165,14 +165,14 @@ static int fsl_pq_mdio_reset(struct mii_bus *bus)
 	mutex_lock(&bus->mdio_lock);
 
 	/* Reset the management interface */
-	out_be32(&regs->miimcfg, MIIMCFG_RESET);
+	iowrite32be(MIIMCFG_RESET, &regs->miimcfg);
 
 	/* Setup the MII Mgmt clock speed */
-	out_be32(&regs->miimcfg, MIIMCFG_INIT_VALUE);
+	iowrite32be(MIIMCFG_INIT_VALUE, &regs->miimcfg);
 
 	/* Wait until the bus is free */
-	status = spin_event_timeout(!(in_be32(&regs->miimind) &	MIIMIND_BUSY),
-				    MII_TIMEOUT, 0);
+	status = spin_event_timeout(!(ioread32be(&regs->miimind) &
+				    MIIMIND_BUSY), MII_TIMEOUT, 0);
 
 	mutex_unlock(&bus->mdio_lock);
 
@@ -433,7 +433,7 @@ static int fsl_pq_mdio_probe(struct platform_device *pdev)
 
 			tbipa = data->get_tbipa(priv->map);
 
-			out_be32(tbipa, be32_to_cpup(prop));
+			iowrite32be(be32_to_cpup(prop), tbipa);
 		}
 	}
 
-- 
1.7.5.4

