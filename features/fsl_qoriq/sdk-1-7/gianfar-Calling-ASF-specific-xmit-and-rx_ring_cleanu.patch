From db8b0513f6a18ad9b846ae9e26f8414289f8c07b Mon Sep 17 00:00:00 2001
From: Alok Makhariya <B46187@freescale.com>
Date: Fri, 28 Mar 2014 17:40:01 +0530
Subject: [PATCH 099/128] gianfar: Calling ASF specific xmit and
 rx_ring_cleanup functions

xmit and rx_ring_cleanup function in asf_gianfar.c
are called from gianfar.c

Change-Id: If44afeba7843a484cbd8c144b64e4e1cfe9fe331
CQ ID : ENGR00304852
Signed-off-by: Alok Makhariya <B46187@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/10352
Reviewed-by: Rajan Gupta <rajan.gupta@freescale.com>
Reviewed-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
[Xulin: Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto_RDS_20150206.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   24 +++++++++++++++++++++++-
 1 files changed, 23 insertions(+), 1 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 0bb340e..370252f 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -107,6 +107,10 @@
 
 #include "gianfar.h"
 
+#ifdef CONFIG_AS_FASTPATH
+#include "asf_gianfar.h"
+#endif
+
 #define TX_TIMEOUT      (1*HZ)
 
 const char gfar_driver_version[] = "1.3";
@@ -159,7 +163,7 @@ MODULE_AUTHOR("Freescale Semiconductor, Inc");
 MODULE_DESCRIPTION("Gianfar Ethernet Driver");
 MODULE_LICENSE("GPL");
 
-static DEFINE_PER_CPU(struct sk_buff_head, skb_recycle_list);
+DEFINE_PER_CPU(struct sk_buff_head, skb_recycle_list);
 
 #define GFAR_RXB_REC_SZ (DEFAULT_RX_BUFFER_SIZE + RXBUF_ALIGNMENT)
 
@@ -810,6 +814,11 @@ static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_AS_FASTPATH
+	/* Creating multilple queues for avoiding lock in xmit function.*/
+	num_tx_qs = (num_tx_qs < 2) ? 2 : num_tx_qs;
+#endif
+
 	*pdev = alloc_etherdev_mq(sizeof(*priv), num_tx_qs);
 	dev = *pdev;
 	if (NULL == dev)
@@ -2155,6 +2164,10 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	u32 bufaddr;
 	unsigned int nr_frags, nr_txbds, bytes_sent, fcb_len = 0;
 
+#ifdef CONFIG_AS_FASTPATH
+	return gfar_asf_start_xmit(skb, dev);
+#endif
+
 	rq = skb->queue_mapping;
 	tx_queue = priv->tx_queue[rq];
 	txq = netdev_get_tx_queue(dev, rq);
@@ -2698,6 +2711,7 @@ irqreturn_t gfar_receive(int irq, void *grp_id)
 
 	return IRQ_HANDLED;
 }
+EXPORT_SYMBOL(gfar_new_skb);
 
 /* Interrupt Handler for Transmit complete */
 static irqreturn_t gfar_transmit(int irq, void *grp_id)
@@ -2706,6 +2720,10 @@ static irqreturn_t gfar_transmit(int irq, void *grp_id)
 	unsigned long flags;
 	u32 imask;
 
+#ifdef CONFIG_AS_FASTPATH
+	return gfar_enable_tx_queue(irq, grp_id);
+#endif
+
 	if (likely(napi_schedule_prep(&grp->napi_tx))) {
 		spin_lock_irqsave(&grp->grplock, flags);
 		imask = gfar_read(&grp->regs->imask);
@@ -2812,6 +2830,10 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 	int howmany = 0;
 	struct gfar_private *priv = netdev_priv(dev);
 
+#ifdef CONFIG_AS_FASTPATH
+	return gfar_asf_clean_rx_ring(rx_queue, rx_work_limit);
+#endif
+
 	/* Get the first full descriptor */
 	bdp = rx_queue->cur_rx;
 	base = rx_queue->rx_bd_base;
-- 
1.7.5.4

