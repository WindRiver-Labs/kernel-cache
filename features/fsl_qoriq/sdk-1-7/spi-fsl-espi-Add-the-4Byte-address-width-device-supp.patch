From 41ded7ec6c81b2e029a551f13e326dc013647d8c Mon Sep 17 00:00:00 2001
From: Hou Zhiqiang <B48286@freescale.com>
Date: Wed, 26 Nov 2014 19:39:18 +0800
Subject: [PATCH 385/399] spi/fsl-espi: Add the 4Byte address width device
 support

Get the address width information from the spi_message to correct the
address to operate.

when the one-time transfer length exceed the max limited length of eSPI
controller 0xFFFF, for the subsequent transfer, the address to operate
need to be corrected.

Signed-off-by: Hou Zhiqiang <B48286@freescale.com>
Change-Id: I54cf8e76c29c660603b864ff1ef2096a2f817dba
Reviewed-on: http://git.am.freescale.net:8181/24586
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/spi/spi-fsl-espi.c |   31 ++++++++++++++++++++++---------
 1 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 428dc7a..8ccdf47 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -255,19 +255,30 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	return mpc8xxx_spi->count;
 }
 
-static inline void fsl_espi_addr2cmd(unsigned int addr, u8 *cmd)
+static inline void fsl_espi_addr2cmd(unsigned int addr, u8 *cmd, u8 addr_width)
 {
 	if (cmd) {
-		cmd[1] = (u8)(addr >> 16);
-		cmd[2] = (u8)(addr >> 8);
-		cmd[3] = (u8)(addr >> 0);
+		if (addr_width == 3) {
+			cmd[1] = (u8)(addr >> 16);
+			cmd[2] = (u8)(addr >> 8);
+			cmd[3] = (u8)(addr >> 0);
+		} else if (addr_width == 4) {
+			cmd[1] = (u8)(addr >> 24);
+			cmd[2] = (u8)(addr >> 16);
+			cmd[3] = (u8)(addr >> 8);
+			cmd[4] = (u8)(addr >> 0);
+		}
 	}
 }
 
-static inline unsigned int fsl_espi_cmd2addr(u8 *cmd)
+static inline unsigned int fsl_espi_cmd2addr(u8 *cmd, u8 addr_width)
 {
-	if (cmd)
-		return cmd[1] << 16 | cmd[2] << 8 | cmd[3] << 0;
+	if (cmd) {
+		if (addr_width == 3)
+			return cmd[1] << 16 | cmd[2] << 8 | cmd[3] << 0;
+		else if (addr_width == 4)
+			return cmd[1] << 24 |cmd[2] << 16 | cmd[3] << 8 | cmd[4] << 0;
+	}
 
 	return 0;
 }
@@ -372,7 +383,9 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 	unsigned int trans_len;
 	unsigned int addr;
 	int i, pos, loop;
+	u8 addr_width;
 
+	addr_width = m->addr_width;
 	local_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);
 	if (!local_buf) {
 		espi_trans->status = -ENOMEM;
@@ -393,9 +406,9 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 		}
 
 		if (pos > 0) {
-			addr = fsl_espi_cmd2addr(local_buf);
+			addr = fsl_espi_cmd2addr(local_buf, addr_width);
 			addr += pos;
-			fsl_espi_addr2cmd(addr, local_buf);
+			fsl_espi_addr2cmd(addr, local_buf, addr_width);
 		}
 
 		espi_trans->n_tx = n_tx;
-- 
1.7.5.4

