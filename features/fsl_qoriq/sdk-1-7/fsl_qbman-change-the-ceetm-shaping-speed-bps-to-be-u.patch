From 5362f291a6ff7d854d5375027e2160483995a0b3 Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Fri, 24 Oct 2014 13:36:02 -0400
Subject: [PATCH 087/399] fsl_qbman: change the ceetm shaping speed bps to be
 u64 typed

The original u32 define limited the ceetm shaping speed.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: I02fe21c541e5c78151b181b8ab75cc84d019661d
Reviewed-on: http://git.am.freescale.net:8181/22074
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c |   12 ++++++++----
 include/linux/fsl_qman.h              |    4 ++--
 2 files changed, 10 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 3a8715d..87caac5 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -3157,7 +3157,7 @@ static int qman_ceetm_query_statistics(u16 cid,
 	return 0;
 }
 
-int qman_ceetm_bps2tokenrate(u32 bps, struct qm_ceetm_rate *token_rate,
+int qman_ceetm_bps2tokenrate(u64 bps, struct qm_ceetm_rate *token_rate,
 							int rounding)
 {
 	u16 pres;
@@ -3188,16 +3188,20 @@ int qman_ceetm_bps2tokenrate(u32 bps, struct qm_ceetm_rate *token_rate,
 	 *	token-rate = (bps*2^19) / (PRES*QHZ)
 	 *	N = (bps*2^32) / (PRES*QHz)
 	 *
+	 * And to avoid 64-bit overflow if 'bps' is larger than 4Gbps
+	 * (yet minimise rounding error if 'bps' is small), we reorganise
+	 * the formula to use two 16-bit shifts rather than 1 32-bit shift.
+	 *      N = (((bps*2^16)/PRES)*2^16)/QHz
 	 */
-	temp = ROUNDING(((u64)bps << 32), pres, rounding);
-	temp = ROUNDING(temp, qman_freq, rounding);
+	temp = ROUNDING((bps << 16), pres, rounding);
+	temp = ROUNDING((temp << 16), qman_freq, rounding);
 	token_rate->whole = temp >> 13;
 	token_rate->fraction = temp & (((u64)1 << 13) - 1);
 	return 0;
 }
 EXPORT_SYMBOL(qman_ceetm_bps2tokenrate);
 
-int qman_ceetm_tokenrate2bps(const struct qm_ceetm_rate *token_rate, u32 *bps,
+int qman_ceetm_tokenrate2bps(const struct qm_ceetm_rate *token_rate, u64 *bps,
 							int rounding)
 {
 	u16 pres;
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index f6491c9..76c547d 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -2480,7 +2480,7 @@ struct qm_ceetm_lfq {
  *
  * Return 0 for success, or -EINVAL if prescaler or qman clock is not available.
   */
-int qman_ceetm_bps2tokenrate(u32 bps,
+int qman_ceetm_bps2tokenrate(u64 bps,
 				struct qm_ceetm_rate *token_rate,
 				int rounding);
 
@@ -2494,7 +2494,7 @@ int qman_ceetm_bps2tokenrate(u32 bps,
  * Return 0 for success, or -EINVAL if prescaler or qman clock is not available.
  */
 int qman_ceetm_tokenrate2bps(const struct qm_ceetm_rate *token_rate,
-			      u32 *bps,
+			      u64 *bps,
 			      int rounding);
 
 int qman_alloc_ceetm0_channel_range(u32 *result, u32 count, u32 align,
-- 
1.7.5.4

