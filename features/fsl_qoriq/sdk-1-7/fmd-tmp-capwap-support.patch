From ffd8d34fabf2040c49917a1fff928a0bba4ccbe6 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Tue, 15 Jul 2014 19:09:49 +0300
Subject: [PATCH 036/399] fmd: tmp capwap support

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Change-Id: I426f384c05479a5ddc1607e9b8fa92d972c612ce
Reviewed-on: http://git.am.freescale.net:8181/21432
Reviewed-by: Jiafei Pan <Jiafei.Pan@freescale.com>
Reviewed-by: Shengzhou Liu <Shengzhou.Liu@freescale.com>
Tested-by: Shengzhou Liu <Shengzhou.Liu@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 .../ethernet/freescale/fman/Peripherals/FM/HC/hc.c |   31 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.c      | 5308 +++++++++++---------
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.h      |    1 +
 .../freescale/fman/Peripherals/FM/Pcd/fm_kg.c      |    5 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.c   | 5066 ++++++++++++-------
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.h   |  174 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_pcd.c     |   47 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_pcd.h     |    3 +
 .../freescale/fman/Peripherals/FM/Pcd/fm_prs.c     |    4 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_prs.h     |  187 +-
 .../freescale/fman/Peripherals/FM/Port/fm_port.c   | 4004 +++++++++------
 .../freescale/fman/Peripherals/FM/Port/fm_port.h   |   29 +-
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    |   68 +-
 .../freescale/fman/Peripherals/FM/inc/fm_common.h  |   19 +-
 .../freescale/fman/Peripherals/FM/inc/fm_hc.h      |    2 +-
 .../freescale/fman/inc/Peripherals/fm_ext.h        |   16 +-
 .../freescale/fman/inc/Peripherals/fm_pcd_ext.h    |  242 +-
 .../freescale/fman/inc/Peripherals/fm_port_ext.h   |   19 +-
 .../inc/integrations/T4240/dpaa_integration_ext.h  |    2 +-
 include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h |  229 +-
 .../uapi/linux/fmd/Peripherals/fm_port_ioctls.h    |    4 +-
 21 files changed, 9233 insertions(+), 6227 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
index 9485caa..5d25111 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
@@ -50,14 +50,14 @@
 #define HC_HCOR_OPCODE_SYNC                                     0x2
 #define HC_HCOR_OPCODE_CC                                       0x3
 #define HC_HCOR_OPCODE_CC_CAPWAP_REASSM_TIMEOUT                 0x5
-#define HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT                     0x10
-#define HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION                0x11
-#define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT       24
-#define HC_HCOR_EXTRA_REG_IP_REASSM_TIMEOUT_TSBS_SHIFT          24
-#define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_SHIFT          16
-#define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK           0xF
-#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_CMD_SHIFT       24
-#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_BPID            16
+#define HC_HCOR_OPCODE_CC_REASSM_TIMEOUT                     0x10
+#define HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION             0x11
+#define HC_HCOR_ACTION_REG_REASSM_TIMEOUT_ACTIVE_SHIFT       24
+#define HC_HCOR_EXTRA_REG_REASSM_TIMEOUT_TSBS_SHIFT          24
+#define HC_HCOR_ACTION_REG_REASSM_TIMEOUT_RES_SHIFT          16
+#define HC_HCOR_ACTION_REG_REASSM_TIMEOUT_RES_MASK           0xF
+#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_CMD_SHIFT    24
+#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_BPID         16
 
 #define HC_HCOR_GBL                         0x20000000
 
@@ -108,7 +108,7 @@ typedef _Packed struct t_HcFrame {
         t_FmPcdKgPortRegs                       portRegsForRead;
         volatile uint32_t                       clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
         t_FmPcdCcCapwapReassmTimeoutParams      ccCapwapReassmTimeout;
-        t_FmPcdCcIpReassmTimeoutParams          ccIpReassmTimeout;
+        t_FmPcdCcReassmTimeoutParams            ccReassmTimeout;
     } hcSpecificData;
 } _PackedType t_HcFrame;
 
@@ -275,7 +275,7 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
         XX_Free(p_FmHc);
         return NULL;
     }
- 
+
     err = FM_PORT_ConfigMaxFrameLength(p_FmHc->h_HcPortDev, sizeof(t_HcFrame));
     if (err != E_OK)
     {
@@ -660,6 +660,7 @@ t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_S
         p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
         p_HcFrame->actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
         p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
+        ASSERT_COND(IN_RANGE(0, (i-p_Set->baseEntry) ,FM_PCD_MAX_NUM_OF_CLS_PLANS-1));
         memcpy((void*)&p_HcFrame->hcSpecificData.clsPlanEntries, (void *)&p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
         p_HcFrame->commandSequence = seqNum;
 
@@ -764,7 +765,7 @@ t_Error FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragS
     return E_OK;
 }
 
-t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams *p_CcIpReassmTimeoutParams, uint8_t *p_Result)
+t_Error FmHcPcdCcTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcReassmTimeoutParams *p_CcReassmTimeoutParams, uint8_t *p_Result)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame                           *p_HcFrame;
@@ -779,9 +780,9 @@ t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
-    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT);
-    p_HcFrame->actionReg = (uint32_t)((p_CcIpReassmTimeoutParams->activate ? 0 : 1) << HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT);
-    p_HcFrame->extraReg = (p_CcIpReassmTimeoutParams->tsbs << HC_HCOR_EXTRA_REG_IP_REASSM_TIMEOUT_TSBS_SHIFT) | p_CcIpReassmTimeoutParams->iprcpt;
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_REASSM_TIMEOUT);
+    p_HcFrame->actionReg = (uint32_t)((p_CcReassmTimeoutParams->activate ? 0 : 1) << HC_HCOR_ACTION_REG_REASSM_TIMEOUT_ACTIVE_SHIFT);
+    p_HcFrame->extraReg = (p_CcReassmTimeoutParams->tsbs << HC_HCOR_EXTRA_REG_REASSM_TIMEOUT_TSBS_SHIFT) | p_CcReassmTimeoutParams->iprcpt;
     p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
@@ -792,7 +793,7 @@ t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams
     }
 
     *p_Result = (uint8_t)
-        ((p_HcFrame->actionReg >> HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_SHIFT) & HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK);
+        ((p_HcFrame->actionReg >> HC_HCOR_ACTION_REG_REASSM_TIMEOUT_RES_SHIFT) & HC_HCOR_ACTION_REG_REASSM_TIMEOUT_RES_MASK);
 
     PutBuf(p_FmHc, p_HcFrame, seqNum);
     return E_OK;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
index 09eec69..52a3314 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
@@ -35,7 +35,7 @@
  @File          fm_cc.c
 
  @Description   FM Coarse Classifier implementation
-*//***************************************************************************/
+ *//***************************************************************************/
 #include "std_ext.h"
 #include "error_ext.h"
 #include "string_ext.h"
@@ -49,7 +49,6 @@
 #include "fm_cc.h"
 #include "crc64.h"
 
-
 /****************************************/
 /*       static functions               */
 /****************************************/
@@ -57,7 +56,7 @@
 
 static t_Error CcRootTryLock(t_Handle h_FmPcdCcTree)
 {
-    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     ASSERT_COND(h_FmPcdCcTree);
 
@@ -69,16 +68,16 @@ static t_Error CcRootTryLock(t_Handle h_FmPcdCcTree)
 
 static void CcRootReleaseLock(t_Handle h_FmPcdCcTree)
 {
-    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     ASSERT_COND(h_FmPcdCcTree);
 
     FmPcdLockUnlock(p_FmPcdCcTree->p_Lock);
 }
 
-static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
+static void UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
 {
-    uint32_t    intFlags;
+    uint32_t intFlags;
 
     ASSERT_COND(p_CcNode);
 
@@ -97,8 +96,8 @@ static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
 
 static __inline__ t_FmPcdStatsObj* DequeueStatsObj(t_List *p_List)
 {
-    t_FmPcdStatsObj  *p_StatsObj = NULL;
-    t_List           *p_Next;
+    t_FmPcdStatsObj *p_StatsObj = NULL;
+    t_List *p_Next;
 
     if (!LIST_IsEmpty(p_List))
     {
@@ -111,16 +110,15 @@ static __inline__ t_FmPcdStatsObj* DequeueStatsObj(t_List *p_List)
     return p_StatsObj;
 }
 
-static __inline__ void EnqueueStatsObj(t_List              *p_List,
-                                       t_FmPcdStatsObj     *p_StatsObj)
+static __inline__ void EnqueueStatsObj(t_List *p_List,
+                                       t_FmPcdStatsObj *p_StatsObj)
 {
     LIST_AddToTail(&p_StatsObj->node, p_List);
 }
 
-static void FreeStatObjects(t_List     *p_List,
-                            t_Handle   h_FmMuram)
+static void FreeStatObjects(t_List *p_List, t_Handle h_FmMuram)
 {
-    t_FmPcdStatsObj     *p_StatsObj;
+    t_FmPcdStatsObj *p_StatsObj;
 
     while (!LIST_IsEmpty(p_List))
     {
@@ -136,13 +134,13 @@ static void FreeStatObjects(t_List     *p_List,
 
 static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
 {
-    t_FmPcdStatsObj*    p_StatsObj;
-    t_Handle            h_FmMuram;
+    t_FmPcdStatsObj* p_StatsObj;
+    t_Handle h_FmMuram;
 
     ASSERT_COND(p_CcNode);
 
     /* If 'maxNumOfKeys' was passed, all statistics object were preallocated
-       upon node initialization */
+     upon node initialization */
     if (p_CcNode->maxNumOfKeys)
     {
         p_StatsObj = DequeueStatsObj(&p_CcNode->availableStatsLst);
@@ -159,9 +157,8 @@ static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
             return NULL;
         }
 
-        p_StatsObj->h_StatsAd = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                                            FM_PCD_CC_AD_ENTRY_SIZE,
-                                                            FM_PCD_CC_AD_TABLE_ALIGN);
+        p_StatsObj->h_StatsAd = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE, FM_PCD_CC_AD_TABLE_ALIGN);
         if (!p_StatsObj->h_StatsAd)
         {
             XX_Free(p_StatsObj);
@@ -170,9 +167,9 @@ static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
         }
         IOMemSet32(p_StatsObj->h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        p_StatsObj->h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                                                  p_CcNode->countersArraySize,
-                                                                  FM_PCD_CC_AD_TABLE_ALIGN);
+        p_StatsObj->h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, p_CcNode->countersArraySize,
+                FM_PCD_CC_AD_TABLE_ALIGN);
         if (!p_StatsObj->h_StatsCounters)
         {
             FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsAd);
@@ -186,16 +183,15 @@ static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
     return p_StatsObj;
 }
 
-static void PutStatsObj(t_FmPcdCcNode       *p_CcNode,
-                        t_FmPcdStatsObj     *p_StatsObj)
+static void PutStatsObj(t_FmPcdCcNode *p_CcNode, t_FmPcdStatsObj *p_StatsObj)
 {
-    t_Handle            h_FmMuram;
+    t_Handle h_FmMuram;
 
     ASSERT_COND(p_CcNode);
     ASSERT_COND(p_StatsObj);
 
     /* If 'maxNumOfKeys' was passed, all statistics object were preallocated
-       upon node initialization and now will be enqueued back to the list */
+     upon node initialization and now will be enqueued back to the list */
     if (p_CcNode->maxNumOfKeys)
     {
         /* Nullify counters */
@@ -216,7 +212,7 @@ static void PutStatsObj(t_FmPcdCcNode       *p_CcNode,
 }
 
 static void SetStatsCounters(t_AdOfTypeStats *p_StatsAd,
-                             uint32_t        statsCountersAddr)
+                             uint32_t statsCountersAddr)
 {
     uint32_t tmp = (statsCountersAddr & FM_PCD_AD_STATS_COUNTERS_ADDR_MASK);
 
@@ -224,14 +220,13 @@ static void SetStatsCounters(t_AdOfTypeStats *p_StatsAd,
 }
 
 
-static void UpdateStatsAd(t_FmPcdCcStatsParams  *p_FmPcdCcStatsParams,
-                          t_Handle              h_Ad,
-                          uint64_t              physicalMuramBase)
+static void UpdateStatsAd(t_FmPcdCcStatsParams *p_FmPcdCcStatsParams,
+                          t_Handle h_Ad, uint64_t physicalMuramBase)
 {
     t_AdOfTypeStats *p_StatsAd;
-    uint32_t        statsCountersAddr, nextActionAddr, tmp;
+    uint32_t statsCountersAddr, nextActionAddr, tmp;
 #if (DPAA_VERSION >= 11)
-    uint32_t        frameLengthRangesAddr;
+    uint32_t frameLengthRangesAddr;
 #endif /* (DPAA_VERSION >= 11) */
 
     p_StatsAd = (t_AdOfTypeStats *)p_FmPcdCcStatsParams->h_StatsAd;
@@ -241,7 +236,8 @@ static void UpdateStatsAd(t_FmPcdCcStatsParams  *p_FmPcdCcStatsParams,
 #if (DPAA_VERSION >= 11)
     if (p_FmPcdCcStatsParams->h_StatsFLRs)
     {
-        frameLengthRangesAddr = (uint32_t)((XX_VirtToPhys(p_FmPcdCcStatsParams->h_StatsFLRs) - physicalMuramBase));
+        frameLengthRangesAddr = (uint32_t)((XX_VirtToPhys(
+                p_FmPcdCcStatsParams->h_StatsFLRs) - physicalMuramBase));
         tmp |= (frameLengthRangesAddr & FM_PCD_AD_STATS_FLR_ADDR_MASK);
     }
 #endif /* (DPAA_VERSION >= 11) */
@@ -249,7 +245,8 @@ static void UpdateStatsAd(t_FmPcdCcStatsParams  *p_FmPcdCcStatsParams,
 
     nextActionAddr = (uint32_t)((XX_VirtToPhys(h_Ad) - physicalMuramBase));
     tmp = 0;
-    tmp |= (uint32_t)((nextActionAddr << FM_PCD_AD_STATS_NEXT_ACTION_SHIFT) & FM_PCD_AD_STATS_NEXT_ACTION_MASK);
+    tmp |= (uint32_t)((nextActionAddr << FM_PCD_AD_STATS_NEXT_ACTION_SHIFT)
+            & FM_PCD_AD_STATS_NEXT_ACTION_MASK);
     tmp |= (FM_PCD_AD_STATS_NAD_EN | FM_PCD_AD_STATS_OP_CODE);
 
 #if (DPAA_VERSION >= 11)
@@ -259,23 +256,22 @@ static void UpdateStatsAd(t_FmPcdCcStatsParams  *p_FmPcdCcStatsParams,
 
     WRITE_UINT32(p_StatsAd->nextActionIndx, tmp);
 
-    statsCountersAddr = (uint32_t)((XX_VirtToPhys(p_FmPcdCcStatsParams->h_StatsCounters) - physicalMuramBase));
+    statsCountersAddr = (uint32_t)((XX_VirtToPhys(
+            p_FmPcdCcStatsParams->h_StatsCounters) - physicalMuramBase));
     SetStatsCounters(p_StatsAd, statsCountersAddr);
 }
 
-static void FillAdOfTypeContLookup(t_Handle                 h_Ad,
-                                   t_FmPcdCcStatsParams     *p_FmPcdCcStatsParams,
-                                   t_Handle                 h_FmPcd,
-                                   t_Handle                 p_CcNode,
-                                   t_Handle                 h_Manip,
-                                   t_Handle                 h_FrmReplic)
+static void FillAdOfTypeContLookup(t_Handle h_Ad,
+                                   t_FmPcdCcStatsParams *p_FmPcdCcStatsParams,
+                                   t_Handle h_FmPcd, t_Handle p_CcNode,
+                                   t_Handle h_Manip, t_Handle h_FrmReplic)
 {
-    t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_CcNode;
-    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)h_Ad;
-    t_Handle                h_TmpAd;
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                tmpReg32;
-    t_Handle                p_AdNewPtr = NULL;
+    t_FmPcdCcNode *p_Node = (t_FmPcdCcNode *)p_CcNode;
+    t_AdOfTypeContLookup *p_AdContLookup = (t_AdOfTypeContLookup *)h_Ad;
+    t_Handle h_TmpAd;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t tmpReg32;
+    t_Handle p_AdNewPtr = NULL;
 
     UNUSED(h_Manip);
     UNUSED(h_FrmReplic);
@@ -311,33 +307,37 @@ static void FillAdOfTypeContLookup(t_Handle                 h_Ad,
         p_AdContLookup = h_Ad;
 
         /* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
-        UpdateStatsAd(p_FmPcdCcStatsParams,
-                      h_Ad,
-                      p_FmPcd->physicalMuramBase);
+        UpdateStatsAd(p_FmPcdCcStatsParams, h_Ad, p_FmPcd->physicalMuramBase);
     }
 
 #if DPAA_VERSION >= 11
     if (h_Manip && h_FrmReplic)
-        FmPcdManipUpdateAdContLookupForCc(h_Manip,
-                                          h_Ad,
-                                          &p_AdNewPtr,
-                                          (uint32_t)((XX_VirtToPhys(FrmReplicGroupGetSourceTableDescriptor(h_FrmReplic)) - p_FmPcd->physicalMuramBase)));
-    else if (h_FrmReplic)
-        FrmReplicGroupUpdateAd(h_FrmReplic, h_Ad, &p_AdNewPtr);
+        FmPcdManipUpdateAdContLookupForCc(
+                h_Manip,
+                h_Ad,
+                &p_AdNewPtr,
+                (uint32_t)((XX_VirtToPhys(
+                        FrmReplicGroupGetSourceTableDescriptor(h_FrmReplic))
+                        - p_FmPcd->physicalMuramBase)));
     else
+        if (h_FrmReplic)
+            FrmReplicGroupUpdateAd(h_FrmReplic, h_Ad, &p_AdNewPtr);
+        else
 #endif /* (DPAA_VERSION >= 11) */
-    if (h_Manip)
-        FmPcdManipUpdateAdContLookupForCc(h_Manip,
-                                          h_Ad,
-                                          &p_AdNewPtr,
+            if (h_Manip)
+                FmPcdManipUpdateAdContLookupForCc(
+                        h_Manip,
+                        h_Ad,
+                        &p_AdNewPtr,
 
 #ifdef FM_CAPWAP_SUPPORT
-                                          /*no check for opcode of manip - this step can be reached only with capwap_applic_specific*/
-                                          (uint32_t)((XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase))
+                        /*no check for opcode of manip - this step can be reached only with capwap_applic_specific*/
+                        (uint32_t)((XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase))
 #else  /* not FM_CAPWAP_SUPPORT */
-                                          (uint32_t)((XX_VirtToPhys(p_Node->h_Ad) - p_FmPcd->physicalMuramBase))
+                        (uint32_t)((XX_VirtToPhys(p_Node->h_Ad)
+                                - p_FmPcd->physicalMuramBase))
 #endif /* not FM_CAPWAP_SUPPORT */
-                                          );
+                        );
 
     /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
     if (p_AdNewPtr)
@@ -345,15 +345,20 @@ static void FillAdOfTypeContLookup(t_Handle                 h_Ad,
         /* cases (1) & (2) */
         tmpReg32 = 0;
         tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-        tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
-        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase);
+        tmpReg32 |=
+                p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) :
+                        0;
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Node->h_AdTable)
+                - p_FmPcd->physicalMuramBase);
         WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
 
         tmpReg32 = 0;
         tmpReg32 |= p_Node->numOfKeys << 24;
         tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
-        tmpReg32 |= p_Node->h_KeysMatchTable ?
-                        (uint32_t)(XX_VirtToPhys(p_Node->h_KeysMatchTable) - p_FmPcd->physicalMuramBase) : 0;
+        tmpReg32 |=
+                p_Node->h_KeysMatchTable ? (uint32_t)(XX_VirtToPhys(
+                        p_Node->h_KeysMatchTable) - p_FmPcd->physicalMuramBase) :
+                        0;
         WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
 
         tmpReg32 = 0;
@@ -362,14 +367,15 @@ static void FillAdOfTypeContLookup(t_Handle                 h_Ad,
         tmpReg32 |= p_Node->parseCode;
         WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
 
-        Mem2IOCpy32((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask, CC_GLBL_MASK_SIZE);
+        Mem2IOCpy32((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask,
+                    CC_GLBL_MASK_SIZE);
     }
 }
 
 static t_Error AllocAndFillAdForContLookupManip(t_Handle h_CcNode)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            intFlags;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t intFlags;
 
     ASSERT_COND(p_CcNode);
 
@@ -380,23 +386,20 @@ static t_Error AllocAndFillAdForContLookupManip(t_Handle h_CcNode)
         if (p_CcNode->maxNumOfKeys)
             p_CcNode->h_Ad = p_CcNode->h_TmpAd;
         else
-            p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram,
-                                                         FM_PCD_CC_AD_ENTRY_SIZE,
-                                                         FM_PCD_CC_AD_TABLE_ALIGN);
+            p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(
+                    ((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram,
+                    FM_PCD_CC_AD_ENTRY_SIZE, FM_PCD_CC_AD_TABLE_ALIGN);
 
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
         if (!p_CcNode->h_Ad)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC action descriptor"));
 
-        IOMemSet32(p_CcNode->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        IOMemSet32(p_CcNode->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        FillAdOfTypeContLookup(p_CcNode->h_Ad,
-                               NULL,
-                               p_CcNode->h_FmPcd,
-                               p_CcNode,
-                               NULL,
-                               NULL);
+        FillAdOfTypeContLookup(p_CcNode->h_Ad, NULL, p_CcNode->h_FmPcd,
+                               p_CcNode, NULL, NULL);
     }
     else
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
@@ -404,26 +407,23 @@ static t_Error AllocAndFillAdForContLookupManip(t_Handle h_CcNode)
     return E_OK;
 }
 
-
-static t_Error SetRequiredAction1(t_Handle                            h_FmPcd,
-                                 uint32_t                            requiredAction,
-                                 t_FmPcdCcKeyAndNextEngineParams     *p_CcKeyAndNextEngineParamsTmp,
-                                 t_Handle                            h_AdTmp,
-                                 uint16_t                            numOfEntries,
-                                 t_Handle                            h_Tree)
+static t_Error SetRequiredAction1(
+        t_Handle h_FmPcd, uint32_t requiredAction,
+        t_FmPcdCcKeyAndNextEngineParams *p_CcKeyAndNextEngineParamsTmp,
+        t_Handle h_AdTmp, uint16_t numOfEntries, t_Handle h_Tree)
 {
-    t_AdOfTypeResult    *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
-    uint32_t            tmpReg32;
-    t_Error             err;
-    t_FmPcdCcNode       *p_CcNode;
-    int                 i = 0;
-    uint16_t            tmp = 0;
-    uint16_t            profileId;
-    uint8_t             relativeSchemeId, physicalSchemeId;
+    t_AdOfTypeResult *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
+    uint32_t tmpReg32;
+    t_Error err;
+    t_FmPcdCcNode *p_CcNode;
+    int i = 0;
+    uint16_t tmp = 0;
+    uint16_t profileId;
+    uint8_t relativeSchemeId, physicalSchemeId;
     t_CcNodeInformation ccNodeInfo;
 
-     for (i = 0; i < numOfEntries; i++)
-     {
+    for (i = 0; i < numOfEntries; i++)
+    {
         if (i == 0)
             h_AdTmp = PTR_MOVE(h_AdTmp, i*FM_PCD_CC_AD_ENTRY_SIZE);
         else
@@ -434,139 +434,182 @@ static t_Error SetRequiredAction1(t_Handle                            h_FmPcd,
             case (e_FM_PCD_CC):
                 if (requiredAction)
                 {
-                    p_CcNode = p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
+                    p_CcNode =
+                            p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
                     ASSERT_COND(p_CcNode);
                     if (p_CcNode->shadowAction == requiredAction)
                         break;
-                    if ((requiredAction & UPDATE_CC_WITH_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
+                    if ((requiredAction & UPDATE_CC_WITH_TREE)
+                            && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
                     {
 
                         memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                         ccNodeInfo.h_CcNode = h_Tree;
-                        EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst, &ccNodeInfo, NULL);
-                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_TREE;
+                        EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst,
+                                                     &ccNodeInfo, NULL);
+                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                                UPDATE_CC_WITH_TREE;
                     }
-                    if ((requiredAction & UPDATE_CC_SHADOW_CLEAR) && !(p_CcNode->shadowAction & UPDATE_CC_SHADOW_CLEAR))
+                    if ((requiredAction & UPDATE_CC_SHADOW_CLEAR)
+                            && !(p_CcNode->shadowAction & UPDATE_CC_SHADOW_CLEAR))
                     {
 
-                         p_CcNode->shadowAction = 0;
+                        p_CcNode->shadowAction = 0;
                     }
 
-                   if ((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
+                    if ((requiredAction & UPDATE_CC_WITH_DELETE_TREE)
+                            && !(p_CcNode->shadowAction
+                                    & UPDATE_CC_WITH_DELETE_TREE))
                     {
-                        DequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst, h_Tree, NULL);
-                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_DELETE_TREE;
+                        DequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst,
+                                                       h_Tree, NULL);
+                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                                UPDATE_CC_WITH_DELETE_TREE;
                     }
-                    if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
-                        tmp  = (uint8_t)(p_CcNode->numOfKeys + 1);
+                    if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine
+                            != e_FM_PCD_INVALID)
+                        tmp = (uint8_t)(p_CcNode->numOfKeys + 1);
                     else
                         tmp = p_CcNode->numOfKeys;
-                    err = SetRequiredAction1(h_FmPcd,
-                                            requiredAction,
-                                            p_CcNode->keyAndNextEngineParams,
-                                            p_CcNode->h_AdTable,
-                                            tmp,
-                                            h_Tree);
+                    err = SetRequiredAction1(h_FmPcd, requiredAction,
+                                             p_CcNode->keyAndNextEngineParams,
+                                             p_CcNode->h_AdTable, tmp, h_Tree);
                     if (err != E_OK)
                         return err;
-                    if(requiredAction != UPDATE_CC_SHADOW_CLEAR)
-                    	p_CcNode->shadowAction |= requiredAction;
+                    if (requiredAction != UPDATE_CC_SHADOW_CLEAR)
+                        p_CcNode->shadowAction |= requiredAction;
                 }
                 break;
 
             case (e_FM_PCD_KG):
-                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+                        && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction
+                                & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
-                    physicalSchemeId = FmPcdKgGetSchemeId(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme);
-                    relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, physicalSchemeId);
+                    physicalSchemeId =
+                            FmPcdKgGetSchemeId(
+                                    p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme);
+                    relativeSchemeId = FmPcdKgGetRelativeSchemeId(
+                            h_FmPcd, physicalSchemeId);
                     if (relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-                    if (!FmPcdKgIsSchemeValidSw(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme))
-                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
+                    if (!FmPcdKgIsSchemeValidSw(
+                            p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                     ("Invalid direct scheme."));
                     if (!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this action scheme has to be direct."));
-                    err = FmPcdKgCcGetSetParams(h_FmPcd, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme, requiredAction, 0);
+                        RETURN_ERROR(
+                                MAJOR, E_INVALID_STATE,
+                                ("For this action scheme has to be direct."));
+                    err =
+                            FmPcdKgCcGetSetParams(
+                                    h_FmPcd,
+                                    p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme,
+                                    requiredAction, 0);
                     if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
-                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                            requiredAction;
                 }
                 break;
 
             case (e_FM_PCD_PLCR):
-                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+                        && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction
+                                & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
-                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_NOT_SUPPORTED,
+                                ("In this initialization only overrideFqid can be initialized"));
                     if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
-                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
-                    err =  FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd, e_FM_PCD_PLCR_SHARED, NULL, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
-                    if (err!= E_OK)
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_NOT_SUPPORTED,
+                                ("In this initialization only overrideFqid can be initialized"));
+                    err =
+                            FmPcdPlcrGetAbsoluteIdByProfileParams(
+                                    h_FmPcd,
+                                    e_FM_PCD_PLCR_SHARED,
+                                    NULL,
+                                    p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId,
+                                    &profileId);
+                    if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
-                    err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId, requiredAction);
+                    err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId,
+                                                  requiredAction);
                     if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
-                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                            requiredAction;
                 }
                 break;
 
             case (e_FM_PCD_DONE):
-                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+                        && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction
+                                & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     tmpReg32 = GET_UINT32(p_AdTmp->nia);
-                    if ((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)) != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine was previously assigned not as PCD_DONE"));
+                    if ((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
+                            != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_INVALID_STATE,
+                                ("Next engine was previously assigned not as PCD_DONE"));
                     tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
                     WRITE_UINT32(p_AdTmp->nia, tmpReg32);
-                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                            requiredAction;
                 }
                 break;
 
             default:
                 break;
         }
-     }
+    }
 
-     return E_OK;
+    return E_OK;
 }
 
-static t_Error SetRequiredAction(t_Handle                            h_FmPcd,
-                                 uint32_t                            requiredAction,
-                                 t_FmPcdCcKeyAndNextEngineParams     *p_CcKeyAndNextEngineParamsTmp,
-                                 t_Handle                            h_AdTmp,
-                                 uint16_t                            numOfEntries,
-                                 t_Handle                            h_Tree)
+static t_Error SetRequiredAction(
+        t_Handle h_FmPcd, uint32_t requiredAction,
+        t_FmPcdCcKeyAndNextEngineParams *p_CcKeyAndNextEngineParamsTmp,
+        t_Handle h_AdTmp, uint16_t numOfEntries, t_Handle h_Tree)
 {
-    t_Error err = SetRequiredAction1(h_FmPcd, requiredAction, p_CcKeyAndNextEngineParamsTmp,
-                       h_AdTmp, numOfEntries, h_Tree);
+    t_Error err = SetRequiredAction1(h_FmPcd, requiredAction,
+                                     p_CcKeyAndNextEngineParamsTmp, h_AdTmp,
+                                     numOfEntries, h_Tree);
     if (err != E_OK)
         return err;
-    return SetRequiredAction1(h_FmPcd, UPDATE_CC_SHADOW_CLEAR, p_CcKeyAndNextEngineParamsTmp,
-                           h_AdTmp, numOfEntries, h_Tree);
+    return SetRequiredAction1(h_FmPcd, UPDATE_CC_SHADOW_CLEAR,
+                              p_CcKeyAndNextEngineParamsTmp, h_AdTmp,
+                              numOfEntries, h_Tree);
 }
 
-static t_Error ReleaseModifiedDataStructure(t_Handle                            h_FmPcd,
-                                            t_List                              *h_FmPcdOldPointersLst,
-                                            t_List                              *h_FmPcdNewPointersLst,
-                                            uint16_t                            numOfGoodChanges,
-                                            t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalParams,
-                                            bool                                useShadowStructs)
+static t_Error ReleaseModifiedDataStructure(
+        t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst,
+        t_List *h_FmPcdNewPointersLst, uint16_t numOfGoodChanges,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalParams,
+        bool useShadowStructs)
 {
-    t_List                  *p_Pos;
-    t_Error                 err = E_OK;
-    t_CcNodeInformation     ccNodeInfo, *p_CcNodeInformation;
-    t_Handle                h_Muram;
-    t_FmPcdCcNode           *p_FmPcdCcNextNode, *p_FmPcdCcWorkingOnNode;
-    t_List                  *p_UpdateLst;
-    uint32_t                intFlags;
-    
+    t_List *p_Pos;
+    t_Error err = E_OK;
+    t_CcNodeInformation ccNodeInfo, *p_CcNodeInformation;
+    t_Handle h_Muram;
+    t_FmPcdCcNode *p_FmPcdCcNextNode, *p_FmPcdCcWorkingOnNode;
+    t_List *p_UpdateLst;
+    uint32_t intFlags;
 
     UNUSED(numOfGoodChanges);
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_AdditionalParams->h_CurrentNode,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointersLst,E_INVALID_HANDLE);
- 
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_AdditionalParams->h_CurrentNode,
+                              E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointersLst, E_INVALID_HANDLE);
+
     /* We don't update subtree of the new node with new tree because it was done in the previous stage */
     if (p_AdditionalParams->h_NodeForAdd)
     {
@@ -577,9 +620,9 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
         else
             p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
 
-        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst,
-                                                        p_AdditionalParams->h_CurrentNode,
-                                                        p_FmPcdCcNextNode->h_Spinlock);
+        p_CcNodeInformation = FindNodeInfoInReleventLst(
+                p_UpdateLst, p_AdditionalParams->h_CurrentNode,
+                p_FmPcdCcNextNode->h_Spinlock);
 
         if (p_CcNodeInformation)
             p_CcNodeInformation->index++;
@@ -588,26 +631,31 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
             memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
             ccNodeInfo.h_CcNode = (t_Handle)p_AdditionalParams->h_CurrentNode;
             ccNodeInfo.index = 1;
-            EnqueueNodeInfoToRelevantLst(p_UpdateLst,
-                                         &ccNodeInfo,
+            EnqueueNodeInfoToRelevantLst(p_UpdateLst, &ccNodeInfo,
                                          p_FmPcdCcNextNode->h_Spinlock);
         }
         if (p_AdditionalParams->h_ManipForAdd)
         {
-            p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForAdd),
-                                                             p_AdditionalParams->h_CurrentNode,
-                                                             FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForAdd));
+            p_CcNodeInformation = FindNodeInfoInReleventLst(
+                    FmPcdManipGetNodeLstPointedOnThisManip(
+                            p_AdditionalParams->h_ManipForAdd),
+                    p_AdditionalParams->h_CurrentNode,
+                    FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForAdd));
 
             if (p_CcNodeInformation)
                 p_CcNodeInformation->index++;
             else
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                ccNodeInfo.h_CcNode = (t_Handle)p_AdditionalParams->h_CurrentNode;
+                ccNodeInfo.h_CcNode =
+                        (t_Handle)p_AdditionalParams->h_CurrentNode;
                 ccNodeInfo.index = 1;
-                EnqueueNodeInfoToRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForAdd),
-                                            &ccNodeInfo,
-                                             FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForAdd));
+                EnqueueNodeInfoToRelevantLst(
+                        FmPcdManipGetNodeLstPointedOnThisManip(
+                                p_AdditionalParams->h_ManipForAdd),
+                        &ccNodeInfo,
+                        FmPcdManipGetSpinlock(
+                                p_AdditionalParams->h_ManipForAdd));
             }
         }
     }
@@ -619,44 +667,47 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
         if (!p_AdditionalParams->tree)
         {
             p_UpdateLst = &p_FmPcdCcNextNode->ccPrevNodesLst;
-			p_FmPcdCcWorkingOnNode = (t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode);
-            
-            for (p_Pos = LIST_FIRST(&p_FmPcdCcWorkingOnNode->ccTreesLst); 
-            						p_Pos != (&p_FmPcdCcWorkingOnNode->ccTreesLst); 
-            						p_Pos = LIST_NEXT(p_Pos))
+            p_FmPcdCcWorkingOnNode =
+                    (t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode);
+
+            for (p_Pos = LIST_FIRST(&p_FmPcdCcWorkingOnNode->ccTreesLst);
+                    p_Pos != (&p_FmPcdCcWorkingOnNode->ccTreesLst); p_Pos =
+                            LIST_NEXT(p_Pos))
             {
                 p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
 
                 ASSERT_COND(p_CcNodeInformation->h_CcNode);
 
-                err = SetRequiredAction(h_FmPcd,
-                                        UPDATE_CC_WITH_DELETE_TREE,
-                                        &((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
-                                        PTR_MOVE(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable, p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                        1,
-                                        p_CcNodeInformation->h_CcNode);
+                err =
+                        SetRequiredAction(
+                                h_FmPcd,
+                                UPDATE_CC_WITH_DELETE_TREE,
+                                &((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
+                                PTR_MOVE(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable, p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                1, p_CcNodeInformation->h_CcNode);
             }
         }
         else
         {
             p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
 
-            err = SetRequiredAction(h_FmPcd,
-                                    UPDATE_CC_WITH_DELETE_TREE,
-                                    &((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
-                                    UINT_TO_PTR(((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->ccTreeBaseAddr + p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                    1,
-                                    p_AdditionalParams->h_CurrentNode);
+            err =
+                    SetRequiredAction(
+                            h_FmPcd,
+                            UPDATE_CC_WITH_DELETE_TREE,
+                            &((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
+                            UINT_TO_PTR(((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->ccTreeBaseAddr + p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                            1, p_AdditionalParams->h_CurrentNode);
         }
         if (err)
             return err;
 
         /* We remove from the subtree of the removed node tree because it wasn't done in the previous stage
-           Update ccPrevNodesLst or ccTreeIdLst of the removed node
-           Update of the node owner */
-        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst,
-                                                        p_AdditionalParams->h_CurrentNode,
-                                                        p_FmPcdCcNextNode->h_Spinlock);
+         Update ccPrevNodesLst or ccTreeIdLst of the removed node
+         Update of the node owner */
+        p_CcNodeInformation = FindNodeInfoInReleventLst(
+                p_UpdateLst, p_AdditionalParams->h_CurrentNode,
+                p_FmPcdCcNextNode->h_Spinlock);
 
         ASSERT_COND(p_CcNodeInformation);
         ASSERT_COND(p_CcNodeInformation->index);
@@ -664,17 +715,19 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
         p_CcNodeInformation->index--;
 
         if (p_CcNodeInformation->index == 0)
-           DequeueNodeInfoFromRelevantLst(p_UpdateLst,
-                                          p_AdditionalParams->h_CurrentNode,
-                                          p_FmPcdCcNextNode->h_Spinlock);
+            DequeueNodeInfoFromRelevantLst(p_UpdateLst,
+                                           p_AdditionalParams->h_CurrentNode,
+                                           p_FmPcdCcNextNode->h_Spinlock);
 
         UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
 
         if (p_AdditionalParams->h_ManipForRmv)
         {
-             p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForRmv),
-                                                             p_AdditionalParams->h_CurrentNode,
-                                                             FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForRmv));
+            p_CcNodeInformation = FindNodeInfoInReleventLst(
+                    FmPcdManipGetNodeLstPointedOnThisManip(
+                            p_AdditionalParams->h_ManipForRmv),
+                    p_AdditionalParams->h_CurrentNode,
+                    FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForRmv));
 
             ASSERT_COND(p_CcNodeInformation);
             ASSERT_COND(p_CcNodeInformation->index);
@@ -682,9 +735,12 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
             p_CcNodeInformation->index--;
 
             if (p_CcNodeInformation->index == 0)
-               DequeueNodeInfoFromRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForRmv),
-                                              p_AdditionalParams->h_CurrentNode,
-                                              FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForRmv));
+                DequeueNodeInfoFromRelevantLst(
+                        FmPcdManipGetNodeLstPointedOnThisManip(
+                                p_AdditionalParams->h_ManipForRmv),
+                        p_AdditionalParams->h_CurrentNode,
+                        FmPcdManipGetSpinlock(
+                                p_AdditionalParams->h_ManipForRmv));
         }
     }
 
@@ -706,55 +762,61 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
         h_Muram = FmPcdGetMuramHandle(h_FmPcd);
         ASSERT_COND(h_Muram);
 
-        if ((p_AdditionalParams->tree &&
-             !((t_FmPcd *)h_FmPcd)->p_CcShadow) ||
-            (!p_AdditionalParams->tree &&
-             !((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->maxNumOfKeys))
+        if ((p_AdditionalParams->tree && !((t_FmPcd *)h_FmPcd)->p_CcShadow)
+                || (!p_AdditionalParams->tree
+                        && !((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->maxNumOfKeys))
         {
             /* We release new AD which was allocated and updated for copy from to actual AD */
-            for (p_Pos = LIST_FIRST(h_FmPcdNewPointersLst); 
-						p_Pos != (h_FmPcdNewPointersLst); 
-						p_Pos = LIST_NEXT(p_Pos))
+            for (p_Pos = LIST_FIRST(h_FmPcdNewPointersLst);
+                    p_Pos != (h_FmPcdNewPointersLst); p_Pos = LIST_NEXT(p_Pos))
             {
-   
-	            p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-	            ASSERT_COND(p_CcNodeInformation->h_CcNode);
-	            FM_MURAM_FreeMem(h_Muram, p_CcNodeInformation->h_CcNode);
+
+                p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+                ASSERT_COND(p_CcNodeInformation->h_CcNode);
+                FM_MURAM_FreeMem(h_Muram, p_CcNodeInformation->h_CcNode);
             }
         }
 
         /* Free Old data structure if it has to be freed - new data structure was allocated*/
         if (p_AdditionalParams->p_AdTableOld)
-            FM_MURAM_FreeMem(h_Muram,p_AdditionalParams->p_AdTableOld);
+            FM_MURAM_FreeMem(h_Muram, p_AdditionalParams->p_AdTableOld);
 
         if (p_AdditionalParams->p_KeysMatchTableOld)
-            FM_MURAM_FreeMem(h_Muram,p_AdditionalParams->p_KeysMatchTableOld);
+            FM_MURAM_FreeMem(h_Muram, p_AdditionalParams->p_KeysMatchTableOld);
     }
 
     /* Update current modified node with changed fields if it's required*/
     if (!p_AdditionalParams->tree)
     {
         if (p_AdditionalParams->p_AdTableNew)
-            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable = p_AdditionalParams->p_AdTableNew;
+            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable =
+                    p_AdditionalParams->p_AdTableNew;
 
         if (p_AdditionalParams->p_KeysMatchTableNew)
-            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_KeysMatchTable = p_AdditionalParams->p_KeysMatchTableNew;
+            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_KeysMatchTable =
+                    p_AdditionalParams->p_KeysMatchTableNew;
 
         /* Locking node's spinlock before updating 'keys and next engine' structure,
-           as it maybe used to retrieve keys statistics */
-        intFlags = XX_LockIntrSpinlock(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock);
+         as it maybe used to retrieve keys statistics */
+        intFlags =
+                XX_LockIntrSpinlock(
+                        ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock);
 
-        ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->numOfKeys = p_AdditionalParams->numOfKeys;
+        ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->numOfKeys =
+                p_AdditionalParams->numOfKeys;
 
         memcpy(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
-                &p_AdditionalParams->keyAndNextEngineParams,
-                sizeof(t_FmPcdCcKeyAndNextEngineParams) * (CC_MAX_NUM_OF_KEYS));
+               &p_AdditionalParams->keyAndNextEngineParams,
+               sizeof(t_FmPcdCcKeyAndNextEngineParams) * (CC_MAX_NUM_OF_KEYS));
 
-        XX_UnlockIntrSpinlock(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock, intFlags);
+        XX_UnlockIntrSpinlock(
+                ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock,
+                intFlags);
     }
     else
     {
-        uint8_t numEntries = ((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->numOfEntries;
+        uint8_t numEntries =
+                ((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->numOfEntries;
         ASSERT_COND(numEntries < FM_PCD_MAX_NUM_OF_CC_GROUPS);
         memcpy(&((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
                &p_AdditionalParams->keyAndNextEngineParams,
@@ -769,12 +831,13 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
     return E_OK;
 }
 
-static t_Handle BuildNewAd(t_Handle                             h_Ad,
-                           t_FmPcdModifyCcKeyAdditionalParams   *p_FmPcdModifyCcKeyAdditionalParams,
-                           t_FmPcdCcNode                        *p_CcNode,
-                           t_FmPcdCcNextEngineParams            *p_FmPcdCcNextEngineParams)
+static t_Handle BuildNewAd(
+        t_Handle h_Ad,
+        t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams,
+        t_FmPcdCcNode *p_CcNode,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_FmPcdCcNodeTmp;
+    t_FmPcdCcNode *p_FmPcdCcNodeTmp;
 
     p_FmPcdCcNodeTmp = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
     if (!p_FmPcdCcNodeTmp)
@@ -784,48 +847,46 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     }
     memset(p_FmPcdCcNodeTmp, 0, sizeof(t_FmPcdCcNode));
 
-    p_FmPcdCcNodeTmp->numOfKeys        = p_FmPcdModifyCcKeyAdditionalParams->numOfKeys;
-    p_FmPcdCcNodeTmp->h_KeysMatchTable = p_FmPcdModifyCcKeyAdditionalParams->p_KeysMatchTableNew;
-    p_FmPcdCcNodeTmp->h_AdTable        = p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
-
-    p_FmPcdCcNodeTmp->lclMask                = p_CcNode->lclMask;
-    p_FmPcdCcNodeTmp->parseCode              = p_CcNode->parseCode;
-    p_FmPcdCcNodeTmp->offset                 = p_CcNode->offset;
-    p_FmPcdCcNodeTmp->prsArrayOffset         = p_CcNode->prsArrayOffset;
-    p_FmPcdCcNodeTmp->ctrlFlow               = p_CcNode->ctrlFlow;
+    p_FmPcdCcNodeTmp->numOfKeys = p_FmPcdModifyCcKeyAdditionalParams->numOfKeys;
+    p_FmPcdCcNodeTmp->h_KeysMatchTable =
+            p_FmPcdModifyCcKeyAdditionalParams->p_KeysMatchTableNew;
+    p_FmPcdCcNodeTmp->h_AdTable =
+            p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
+
+    p_FmPcdCcNodeTmp->lclMask = p_CcNode->lclMask;
+    p_FmPcdCcNodeTmp->parseCode = p_CcNode->parseCode;
+    p_FmPcdCcNodeTmp->offset = p_CcNode->offset;
+    p_FmPcdCcNodeTmp->prsArrayOffset = p_CcNode->prsArrayOffset;
+    p_FmPcdCcNodeTmp->ctrlFlow = p_CcNode->ctrlFlow;
     p_FmPcdCcNodeTmp->ccKeySizeAccExtraction = p_CcNode->ccKeySizeAccExtraction;
-    p_FmPcdCcNodeTmp->sizeOfExtraction       = p_CcNode->sizeOfExtraction;
-    p_FmPcdCcNodeTmp->glblMaskSize           = p_CcNode->glblMaskSize;
-    p_FmPcdCcNodeTmp->p_GlblMask             = p_CcNode->p_GlblMask;
+    p_FmPcdCcNodeTmp->sizeOfExtraction = p_CcNode->sizeOfExtraction;
+    p_FmPcdCcNodeTmp->glblMaskSize = p_CcNode->glblMaskSize;
+    p_FmPcdCcNodeTmp->p_GlblMask = p_CcNode->p_GlblMask;
 
     if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC)
     {
         if (p_FmPcdCcNextEngineParams->h_Manip)
         {
-            if (AllocAndFillAdForContLookupManip(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)!= E_OK)
+            if (AllocAndFillAdForContLookupManip(
+                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
+                    != E_OK)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                 return NULL;
             }
         }
-        FillAdOfTypeContLookup(h_Ad,
-                               NULL,
-                               p_CcNode->h_FmPcd,
-                               p_FmPcdCcNodeTmp,
-                               p_FmPcdCcNextEngineParams->h_Manip,
-                               NULL);
+        FillAdOfTypeContLookup(h_Ad, NULL, p_CcNode->h_FmPcd, p_FmPcdCcNodeTmp,
+                               p_FmPcdCcNextEngineParams->h_Manip, NULL);
     }
 
 #if (DPAA_VERSION >= 11)
-    if ((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
-        (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic))
+    if ((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_FR)
+            && (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic))
     {
-        FillAdOfTypeContLookup(h_Ad,
-                               NULL,
-                               p_CcNode->h_FmPcd,
-                               p_FmPcdCcNodeTmp,
-                               p_FmPcdCcNextEngineParams->h_Manip,
-                               p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
+        FillAdOfTypeContLookup(
+                h_Ad, NULL, p_CcNode->h_FmPcd, p_FmPcdCcNodeTmp,
+                p_FmPcdCcNextEngineParams->h_Manip,
+                p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
     }
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -834,17 +895,16 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     return E_OK;
 }
 
-static t_Error DynamicChangeHc(t_Handle                             h_FmPcd,
-                               t_List                               *h_OldPointersLst,
-                               t_List                               *h_NewPointersLst,
-                               t_FmPcdModifyCcKeyAdditionalParams   *p_AdditionalParams,
-                               bool                                 useShadowStructs)
+static t_Error DynamicChangeHc(
+        t_Handle h_FmPcd, t_List *h_OldPointersLst, t_List *h_NewPointersLst,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalParams,
+        bool useShadowStructs)
 {
-    t_List      *p_PosOld, *p_PosNew;
-    uint32_t    oldAdAddrOffset, newAdAddrOffset;
-    uint16_t    i = 0;
-    t_Error     err = E_OK;
-    uint8_t     numOfModifiedPtr;
+    t_List *p_PosOld, *p_PosNew;
+    uint32_t oldAdAddrOffset, newAdAddrOffset;
+    uint16_t i = 0;
+    t_Error err = E_OK;
+    uint8_t numOfModifiedPtr;
 
     ASSERT_COND(h_FmPcd);
     ASSERT_COND(h_OldPointersLst);
@@ -852,92 +912,93 @@ static t_Error DynamicChangeHc(t_Handle                             h_FmPcd,
 
     numOfModifiedPtr = (uint8_t)LIST_NumOfObjs(h_OldPointersLst);
 
-    if (numOfModifiedPtr) 
+    if (numOfModifiedPtr)
     {
-    p_PosNew = LIST_FIRST(h_NewPointersLst);
-    p_PosOld = LIST_FIRST(h_OldPointersLst);
+        p_PosNew = LIST_FIRST(h_NewPointersLst);
+        p_PosOld = LIST_FIRST(h_OldPointersLst);
 
-    /* Retrieve address of new AD */
-    newAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd, p_PosNew);
-    if (newAdAddrOffset == (uint32_t)ILLEGAL_BASE)
-    {
-        ReleaseModifiedDataStructure(h_FmPcd,
-                                     h_OldPointersLst,
-                                     h_NewPointersLst,
-                                     0,
-                                     p_AdditionalParams,
-                                     useShadowStructs);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("New AD address"));
-    }
-
-    for (i=0; i<numOfModifiedPtr; i++)
-    {
-        /* Retrieve address of current AD */
-        oldAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd, p_PosOld);
-        if (oldAdAddrOffset == (uint32_t)ILLEGAL_BASE)
+        /* Retrieve address of new AD */
+        newAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd,
+                                                               p_PosNew);
+        if (newAdAddrOffset == (uint32_t)ILLEGAL_BASE)
         {
-            ReleaseModifiedDataStructure(h_FmPcd,
-                                         h_OldPointersLst,
-                                         h_NewPointersLst,
-                                         i,
-                                         p_AdditionalParams,
-                                         useShadowStructs);
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old AD address"));
+            ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
+                                         h_NewPointersLst, 0,
+                                         p_AdditionalParams, useShadowStructs);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("New AD address"));
         }
 
-        /* Invoke host command to copy from new AD to old AD */
-        err = FmHcPcdCcDoDynamicChange(((t_FmPcd *)h_FmPcd)->h_Hc, oldAdAddrOffset, newAdAddrOffset);
-        if (err)
+        for (i = 0; i < numOfModifiedPtr; i++)
         {
-            ReleaseModifiedDataStructure(h_FmPcd,
-                                         h_OldPointersLst,
-                                         h_NewPointersLst,
-                                         i,
-                                         p_AdditionalParams,
-                                         useShadowStructs);
-            RETURN_ERROR(MAJOR, err, ("For part of nodes changes are done - situation is danger"));
-        }
+            /* Retrieve address of current AD */
+            oldAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd,
+                                                                   p_PosOld);
+            if (oldAdAddrOffset == (uint32_t)ILLEGAL_BASE)
+            {
+                ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
+                                             h_NewPointersLst, i,
+                                             p_AdditionalParams,
+                                             useShadowStructs);
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old AD address"));
+            }
 
-        p_PosOld = LIST_NEXT(p_PosOld);
-    }
+            /* Invoke host command to copy from new AD to old AD */
+            err = FmHcPcdCcDoDynamicChange(((t_FmPcd *)h_FmPcd)->h_Hc,
+                                           oldAdAddrOffset, newAdAddrOffset);
+            if (err)
+            {
+                ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
+                                             h_NewPointersLst, i,
+                                             p_AdditionalParams,
+                                             useShadowStructs);
+                RETURN_ERROR(
+                        MAJOR,
+                        err,
+                        ("For part of nodes changes are done - situation is danger"));
+            }
+
+            p_PosOld = LIST_NEXT(p_PosOld);
+        }
     }
     return E_OK;
 }
 
-static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
-                               t_List                               *h_OldPointersLst,
-                               t_List                               *h_NewPointersLst,
-                               t_FmPcdModifyCcKeyAdditionalParams   *p_AdditionalParams,
-                               bool                                 useShadowStructs)
+static t_Error DoDynamicChange(
+        t_Handle h_FmPcd, t_List *h_OldPointersLst, t_List *h_NewPointersLst,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalParams,
+        bool useShadowStructs)
 {
-    t_FmPcdCcNode               *p_CcNode = (t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode);
-    t_List                      *p_PosNew;
-    t_CcNodeInformation         *p_CcNodeInfo;
-    t_FmPcdCcNextEngineParams   nextEngineParams;
-    t_Handle                    h_Ad;
-    uint32_t                    keySize;
-    t_Error                     err = E_OK;
-    uint8_t                     numOfModifiedPtr;
+    t_FmPcdCcNode *p_CcNode =
+            (t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode);
+    t_List *p_PosNew;
+    t_CcNodeInformation *p_CcNodeInfo;
+    t_FmPcdCcNextEngineParams nextEngineParams;
+    t_Handle h_Ad;
+    uint32_t keySize;
+    t_Error err = E_OK;
+    uint8_t numOfModifiedPtr;
 
     ASSERT_COND(h_FmPcd);
 
-
     memset(&nextEngineParams, 0, sizeof(t_FmPcdCcNextEngineParams));
 
     numOfModifiedPtr = (uint8_t)LIST_NumOfObjs(h_OldPointersLst);
 
+    if (numOfModifiedPtr)
+    {
 
-    p_PosNew = LIST_FIRST(h_NewPointersLst);
+        p_PosNew = LIST_FIRST(h_NewPointersLst);
 
-    /* Invoke host-command to copy from the new Ad to existing Ads */
-    err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst, p_AdditionalParams, useShadowStructs);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-	    
+        /* Invoke host-command to copy from the new Ad to existing Ads */
+        err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst,
+                              p_AdditionalParams, useShadowStructs);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
     if (useShadowStructs)
     {
         /* When the host-command above has ended, the old structures are 'free'and we can update
-           them by copying from the new shadow structures. */
+         them by copying from the new shadow structures. */
         if (p_CcNode->lclMask)
             keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
         else
@@ -945,42 +1006,38 @@ static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
 
         IO2IOCpy32(p_AdditionalParams->p_KeysMatchTableOld,
                    p_AdditionalParams->p_KeysMatchTableNew,
-                   p_CcNode->maxNumOfKeys * keySize * sizeof (uint8_t));
-
-        IO2IOCpy32(p_AdditionalParams->p_AdTableOld,
-                   p_AdditionalParams->p_AdTableNew,
-                   (uint32_t)((p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
-
+                   p_CcNode->maxNumOfKeys * keySize * sizeof(uint8_t));
 
-        p_AdditionalParams->p_KeysMatchTableNew = p_AdditionalParams->p_KeysMatchTableOld;
-        p_AdditionalParams->p_AdTableNew        = p_AdditionalParams->p_AdTableOld;
+        IO2IOCpy32(
+                p_AdditionalParams->p_AdTableOld,
+                p_AdditionalParams->p_AdTableNew,
+                (uint32_t)((p_CcNode->maxNumOfKeys + 1)
+                        * FM_PCD_CC_AD_ENTRY_SIZE));
 
-        if (numOfModifiedPtr) 
-        {
         /* Retrieve the address of the allocated Ad */
-	        p_CcNodeInfo = CC_NODE_F_OBJECT(p_PosNew);
-	        h_Ad = p_CcNodeInfo->h_CcNode;
-	        nextEngineParams.nextEngine = e_FM_PCD_CC;
-	        nextEngineParams.params.ccParams.h_CcNode = (t_Handle)p_CcNode;
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_PosNew);
+        h_Ad = p_CcNodeInfo->h_CcNode;
 
         /* Build a new Ad that holds the old (now updated) structures */
-	        BuildNewAd(h_Ad, p_AdditionalParams, p_CcNode, &nextEngineParams);
-        }
- 
+        p_AdditionalParams->p_KeysMatchTableNew =
+                p_AdditionalParams->p_KeysMatchTableOld;
+        p_AdditionalParams->p_AdTableNew = p_AdditionalParams->p_AdTableOld;
+
+        nextEngineParams.nextEngine = e_FM_PCD_CC;
+        nextEngineParams.params.ccParams.h_CcNode = (t_Handle)p_CcNode;
+
+        BuildNewAd(h_Ad, p_AdditionalParams, p_CcNode, &nextEngineParams);
+
         /* HC to copy from the new Ad (old updated structures) to current Ad (uses shadow structures) */
-        err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst, p_AdditionalParams, useShadowStructs);
+        err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst,
+                              p_AdditionalParams, useShadowStructs);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-
-
-    err = ReleaseModifiedDataStructure(h_FmPcd,
-                                       h_OldPointersLst,
-                                       h_NewPointersLst,
-                                       numOfModifiedPtr,
-                                       p_AdditionalParams,
-                                       useShadowStructs);
+    err = ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
+                                       h_NewPointersLst, numOfModifiedPtr,
+                                       p_AdditionalParams, useShadowStructs);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -991,7 +1048,7 @@ static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
 static bool IsCapwapApplSpecific(t_Handle h_Node)
 {
     t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_Node;
-    bool    isManipForCapwapApplSpecificBuild = FALSE;
+    bool isManipForCapwapApplSpecificBuild = FALSE;
     int i = 0;
 
     ASSERT_COND(h_Node);
@@ -999,7 +1056,7 @@ static bool IsCapwapApplSpecific(t_Handle h_Node)
     for (i = 0; i < p_CcNode->numOfKeys; i++)
     {
         if ( p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip &&
-            FmPcdManipIsCapwapApplSpecific(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip))
+                FmPcdManipIsCapwapApplSpecific(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip))
         {
             isManipForCapwapApplSpecificBuild = TRUE;
             break;
@@ -1010,84 +1067,77 @@ static bool IsCapwapApplSpecific(t_Handle h_Node)
 }
 #endif /* FM_CAPWAP_SUPPORT */
 
-static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
-                             t_Handle                           h_PcdParams,
-                             t_Handle                           h_FmPort,
-                             t_FmPcdCcKeyAndNextEngineParams    *p_CcKeyAndNextEngineParams,
-                             uint16_t                           numOfEntries,
-                             t_Handle                           h_Ad,
-                             bool                               validate,
-                             uint16_t                           level,
-                             t_Handle                           h_FmTree,
-                             bool                               modify)
+static t_Error CcUpdateParam(
+        t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort,
+        t_FmPcdCcKeyAndNextEngineParams *p_CcKeyAndNextEngineParams,
+        uint16_t numOfEntries, t_Handle h_Ad, bool validate, uint16_t level,
+        t_Handle h_FmTree, bool modify)
 {
-    t_FmPcdCcNode       *p_CcNode;
-    t_Error             err;
-    uint16_t            tmp = 0;
-    int                 i = 0;
-    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
+    t_FmPcdCcNode *p_CcNode;
+    t_Error err;
+    uint16_t tmp = 0;
+    int i = 0;
+    t_FmPcdCcTree *p_CcTree = (t_FmPcdCcTree *)h_FmTree;
 
     level++;
 
     if (p_CcTree->h_IpReassemblyManip)
     {
-        err = FmPcdManipUpdate(h_FmPcd,
-                               h_PcdParams,
-                               h_FmPort,
-                               p_CcTree->h_IpReassemblyManip,
-                               NULL,
-                               validate,
-                               level,
-                               h_FmTree,
-                               modify);
+        err = FmPcdManipUpdate(h_FmPcd, h_PcdParams, h_FmPort,
+                               p_CcTree->h_IpReassemblyManip, NULL, validate,
+                               level, h_FmTree, modify);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if (p_CcTree->h_CapwapReassemblyManip)
+    {
+        err = FmPcdManipUpdate(h_FmPcd, h_PcdParams, h_FmPort,
+                               p_CcTree->h_CapwapReassemblyManip, NULL, validate,
+                               level, h_FmTree, modify);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if (numOfEntries)
     {
-        for (i=0; i<numOfEntries; i++)
+        for (i = 0; i < numOfEntries; i++)
         {
             if (i == 0)
                 h_Ad = PTR_MOVE(h_Ad, i*FM_PCD_CC_AD_ENTRY_SIZE);
             else
                 h_Ad = PTR_MOVE(h_Ad, FM_PCD_CC_AD_ENTRY_SIZE);
 
-            if (p_CcKeyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_CcKeyAndNextEngineParams[i].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
             {
-                p_CcNode = p_CcKeyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+                p_CcNode =
+                        p_CcKeyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
                 ASSERT_COND(p_CcNode);
 
                 if (p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
                 {
-                    err = FmPcdManipUpdate(h_FmPcd,
-                                           NULL,
-                                           h_FmPort,
-                                           p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
-                                           h_Ad,
-                                           validate,
-                                           level,
-                                           h_FmTree,
-                                           modify);
+                    err =
+                            FmPcdManipUpdate(
+                                    h_FmPcd,
+                                    NULL,
+                                    h_FmPort,
+                                    p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                                    h_Ad, validate, level, h_FmTree, modify);
                     if (err)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                 }
 
-                if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
-                    tmp  = (uint8_t)(p_CcNode->numOfKeys + 1);
+                if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine
+                        != e_FM_PCD_INVALID)
+                    tmp = (uint8_t)(p_CcNode->numOfKeys + 1);
                 else
                     tmp = p_CcNode->numOfKeys;
 
-                err = CcUpdateParam(h_FmPcd,
-                                    h_PcdParams,
-                                    h_FmPort,
-                                    p_CcNode->keyAndNextEngineParams,
-                                    tmp,
-                                    p_CcNode->h_AdTable,
-                                    validate,
-                                    level,
-                                    h_FmTree,
-                                    modify);
+                err = CcUpdateParam(h_FmPcd, h_PcdParams, h_FmPort,
+                                    p_CcNode->keyAndNextEngineParams, tmp,
+                                    p_CcNode->h_AdTable, validate, level,
+                                    h_FmTree, modify);
                 if (err)
                     RETURN_ERROR(MAJOR, err, NO_MSG);
             }
@@ -1095,15 +1145,13 @@ static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
             {
                 if (p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
                 {
-                    err = FmPcdManipUpdate(h_FmPcd,
-                                           NULL,
-                                           h_FmPort,
-                                           p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
-                                           h_Ad,
-                                           validate,
-                                           level,
-                                           h_FmTree,
-                                           modify);
+                    err =
+                            FmPcdManipUpdate(
+                                    h_FmPcd,
+                                    NULL,
+                                    h_FmPort,
+                                    p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                                    h_Ad, validate, level, h_FmTree, modify);
                     if (err)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                 }
@@ -1137,19 +1185,20 @@ static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
                 case (e_FM_PCD_EXTRACT_FROM_FLOW_ID):
                     return CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP;
                 default:
-                  return  CC_PRIVATE_INFO_NONE;
+                    return CC_PRIVATE_INFO_NONE;
             }
 
-       default:
-           break;
+        default:
+            break;
     }
 
     return CC_PRIVATE_INFO_NONE;
 }
 
-static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List)
+static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(
+        t_List *p_List)
 {
-    t_CcNodeInformation   *p_CcNodeInfo = NULL;
+    t_CcNodeInformation *p_CcNodeInfo = NULL;
 
     if (!LIST_IsEmpty(p_List))
     {
@@ -1162,7 +1211,7 @@ static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List
 
 void ReleaseLst(t_List *p_List)
 {
-    t_CcNodeInformation   *p_CcNodeInfo = NULL;
+    t_CcNodeInformation *p_CcNodeInfo = NULL;
 
     if (!LIST_IsEmpty(p_List))
     {
@@ -1192,26 +1241,30 @@ static void DeleteNode(t_FmPcdCcNode *p_CcNode)
 
     if (p_CcNode->h_KeysMatchTable)
     {
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_KeysMatchTable);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                         p_CcNode->h_KeysMatchTable);
         p_CcNode->h_KeysMatchTable = NULL;
     }
 
     if (p_CcNode->h_AdTable)
     {
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_AdTable);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                         p_CcNode->h_AdTable);
         p_CcNode->h_AdTable = NULL;
     }
 
     if (p_CcNode->h_Ad)
     {
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_Ad);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                         p_CcNode->h_Ad);
         p_CcNode->h_Ad = NULL;
         p_CcNode->h_TmpAd = NULL;
     }
 
     if (p_CcNode->h_StatsFLRs)
     {
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_StatsFLRs);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                         p_CcNode->h_StatsFLRs);
         p_CcNode->h_StatsFLRs = NULL;
     }
 
@@ -1222,17 +1275,20 @@ static void DeleteNode(t_FmPcdCcNode *p_CcNode)
     }
 
     /* Restore the original counters pointer instead of the mutual pointer (mutual to all hash buckets) */
-    if (p_CcNode->isHashBucket && (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE))
-        p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].p_StatsObj->h_StatsCounters = p_CcNode->h_PrivMissStatsCounters;
+    if (p_CcNode->isHashBucket
+            && (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE))
+        p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].p_StatsObj->h_StatsCounters =
+                p_CcNode->h_PrivMissStatsCounters;
 
     /* Releasing all currently used statistics objects, including 'miss' entry */
     for (i = 0; i < p_CcNode->numOfKeys + 1; i++)
         if (p_CcNode->keyAndNextEngineParams[i].p_StatsObj)
-            PutStatsObj(p_CcNode, p_CcNode->keyAndNextEngineParams[i].p_StatsObj);
+            PutStatsObj(p_CcNode,
+                        p_CcNode->keyAndNextEngineParams[i].p_StatsObj);
 
     if (!LIST_IsEmpty(&p_CcNode->availableStatsLst))
     {
-        t_Handle    h_FmMuram = FmPcdGetMuramHandle(p_CcNode->h_FmPcd);
+        t_Handle h_FmMuram = FmPcdGetMuramHandle(p_CcNode->h_FmPcd);
         ASSERT_COND(h_FmMuram);
 
         FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
@@ -1253,7 +1309,8 @@ static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
     {
         if (p_FmPcdTree->ccTreeBaseAddr)
         {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), UINT_TO_PTR(p_FmPcdTree->ccTreeBaseAddr));
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd),
+                             UINT_TO_PTR(p_FmPcdTree->ccTreeBaseAddr));
             p_FmPcdTree->ccTreeBaseAddr = 0;
         }
 
@@ -1263,36 +1320,49 @@ static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
     }
 }
 
-static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCcSize)
+static void GetCcExtractKeySize(uint8_t parseCodeRealSize,
+                                uint8_t *parseCodeCcSize)
 {
     if ((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
         *parseCodeCcSize = 1;
-    else if (parseCodeRealSize == 2)
-        *parseCodeCcSize = 2;
-    else if ((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
-        *parseCodeCcSize = 4;
-    else if ((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
-        *parseCodeCcSize = 8;
-    else if ((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
-        *parseCodeCcSize = 16;
-    else if ((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
-        *parseCodeCcSize = 24;
-    else if ((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
-        *parseCodeCcSize = 32;
-    else if ((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
-        *parseCodeCcSize = 40;
-    else if ((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
-        *parseCodeCcSize = 48;
-    else if ((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
-        *parseCodeCcSize = 56;
     else
-        *parseCodeCcSize = 0;
+        if (parseCodeRealSize == 2)
+            *parseCodeCcSize = 2;
+        else
+            if ((parseCodeRealSize > 2) && (parseCodeRealSize <= 4))
+                *parseCodeCcSize = 4;
+            else
+                if ((parseCodeRealSize > 4) && (parseCodeRealSize <= 8))
+                    *parseCodeCcSize = 8;
+                else
+                    if ((parseCodeRealSize > 8) && (parseCodeRealSize <= 16))
+                        *parseCodeCcSize = 16;
+                    else
+                        if ((parseCodeRealSize > 16)
+                                && (parseCodeRealSize <= 24))
+                            *parseCodeCcSize = 24;
+                        else
+                            if ((parseCodeRealSize > 24)
+                                    && (parseCodeRealSize <= 32))
+                                *parseCodeCcSize = 32;
+                            else
+                                if ((parseCodeRealSize > 32)
+                                        && (parseCodeRealSize <= 40))
+                                    *parseCodeCcSize = 40;
+                                else
+                                    if ((parseCodeRealSize > 40)
+                                            && (parseCodeRealSize <= 48))
+                                        *parseCodeCcSize = 48;
+                                    else
+                                        if ((parseCodeRealSize > 48)
+                                                && (parseCodeRealSize <= 56))
+                                            *parseCodeCcSize = 56;
+                                        else
+                                            *parseCodeCcSize = 0;
 }
 
-static void  GetSizeHeaderField(e_NetHeaderType     hdr,
-                                e_FmPcdHdrIndex     index,
-                                t_FmPcdFields       field,
-                                uint8_t             *parseCodeRealSize)
+static void GetSizeHeaderField(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
+                               t_FmPcdFields field, uint8_t *parseCodeRealSize)
 {
     UNUSED(index);
     switch (hdr)
@@ -1336,7 +1406,7 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
         case (HEADER_TYPE_VLAN):
             switch (field.vlan)
             {
-               case (NET_HEADER_FIELD_VLAN_TCI):
+                case (NET_HEADER_FIELD_VLAN_TCI):
                     *parseCodeRealSize = 2;
                     break;
 
@@ -1374,7 +1444,8 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
                     *parseCodeRealSize = 1;
                     break;
 
-                case (NET_HEADER_FIELD_IPv4_DST_IP | NET_HEADER_FIELD_IPv4_SRC_IP):
+                case (NET_HEADER_FIELD_IPv4_DST_IP
+                        | NET_HEADER_FIELD_IPv4_SRC_IP):
                     *parseCodeRealSize = 8;
                     break;
 
@@ -1392,18 +1463,34 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
         case (HEADER_TYPE_IPv6):
             switch (field.ipv6)
             {
-                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
-                   *parseCodeRealSize = 4;
-                   break;
+                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL
+                        | NET_HEADER_FIELD_IPv6_TC):
+                    *parseCodeRealSize = 4;
+                    break;
 
                 case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
                 case (NET_HEADER_FIELD_IPv6_HOP_LIMIT):
-                   *parseCodeRealSize = 1;
+                    *parseCodeRealSize = 1;
                     break;
 
                 case (NET_HEADER_FIELD_IPv6_DST_IP):
                 case (NET_HEADER_FIELD_IPv6_SRC_IP):
-                   *parseCodeRealSize = 16;
+                    *parseCodeRealSize = 16;
+                    break;
+
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported5"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+
+        case (HEADER_TYPE_IP):
+            switch (field.ip)
+            {
+                case (NET_HEADER_FIELD_IP_DSCP):
+                case (NET_HEADER_FIELD_IP_PROTO):
+                    *parseCodeRealSize = 1;
                     break;
 
                 default:
@@ -1413,26 +1500,11 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             }
             break;
 
-       case (HEADER_TYPE_IP):
-           switch (field.ip)
-           {
-               case (NET_HEADER_FIELD_IP_DSCP):
-               case (NET_HEADER_FIELD_IP_PROTO):
-                   *parseCodeRealSize = 1;
-                   break;
-
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported5"));
-                   *parseCodeRealSize = CC_SIZE_ILLEGAL;
-                   break;
-           }
-           break;
-
-       case (HEADER_TYPE_GRE):
+        case (HEADER_TYPE_GRE):
             switch (field.gre)
             {
-                case ( NET_HEADER_FIELD_GRE_TYPE):
-                   *parseCodeRealSize = 2;
+                case (NET_HEADER_FIELD_GRE_TYPE):
+                    *parseCodeRealSize = 2;
                     break;
 
                 default:
@@ -1446,16 +1518,17 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             switch (field.minencap)
             {
                 case (NET_HEADER_FIELD_MINENCAP_TYPE):
-                   *parseCodeRealSize = 1;
+                    *parseCodeRealSize = 1;
                     break;
 
                 case (NET_HEADER_FIELD_MINENCAP_DST_IP):
                 case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
-                  *parseCodeRealSize = 4;
+                    *parseCodeRealSize = 4;
                     break;
 
-                 case (NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
-                  *parseCodeRealSize = 8;
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP
+                        | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    *parseCodeRealSize = 8;
                     break;
 
                 default:
@@ -1470,11 +1543,12 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             {
                 case (NET_HEADER_FIELD_TCP_PORT_SRC):
                 case (NET_HEADER_FIELD_TCP_PORT_DST):
-                   *parseCodeRealSize = 2;
+                    *parseCodeRealSize = 2;
                     break;
 
-                 case (NET_HEADER_FIELD_TCP_PORT_SRC | NET_HEADER_FIELD_TCP_PORT_DST):
-                  *parseCodeRealSize = 4;
+                case (NET_HEADER_FIELD_TCP_PORT_SRC
+                        | NET_HEADER_FIELD_TCP_PORT_DST):
+                    *parseCodeRealSize = 4;
                     break;
 
                 default:
@@ -1489,11 +1563,12 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             {
                 case (NET_HEADER_FIELD_UDP_PORT_SRC):
                 case (NET_HEADER_FIELD_UDP_PORT_DST):
-                   *parseCodeRealSize = 2;
+                    *parseCodeRealSize = 2;
                     break;
 
-                 case (NET_HEADER_FIELD_UDP_PORT_SRC | NET_HEADER_FIELD_UDP_PORT_DST):
-                  *parseCodeRealSize = 4;
+                case (NET_HEADER_FIELD_UDP_PORT_SRC
+                        | NET_HEADER_FIELD_UDP_PORT_DST):
+                    *parseCodeRealSize = 4;
                     break;
 
                 default:
@@ -1503,26 +1578,28 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             }
             break;
 
-       default:
+        default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported10"));
             *parseCodeRealSize = CC_SIZE_ILLEGAL;
             break;
     }
 }
 
-t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
-                                 t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams,
-                                 e_FmPcdCcStatsMode         statsMode)
+t_Error ValidateNextEngineParams(
+        t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,
+        e_FmPcdCcStatsMode statsMode)
 {
-    uint16_t    absoluteProfileId;
-    t_Error     err = E_OK;
-    uint8_t     relativeSchemeId;
+    uint16_t absoluteProfileId;
+    t_Error err = E_OK;
+    uint8_t relativeSchemeId;
 
-    if ((statsMode == e_FM_PCD_CC_STATS_MODE_NONE) &&
-        (p_FmPcdCcNextEngineParams->statisticsEn))
-        RETURN_ERROR(MAJOR, E_CONFLICT,
-                     ("Statistics are requested for a key, but statistics mode was set"
-                      "to 'NONE' upon initialization"));
+    if ((statsMode == e_FM_PCD_CC_STATS_MODE_NONE)
+            && (p_FmPcdCcNextEngineParams->statisticsEn))
+        RETURN_ERROR(
+                MAJOR,
+                E_CONFLICT,
+                ("Statistics are requested for a key, but statistics mode was set"
+                "to 'NONE' upon initialization"));
 
     switch (p_FmPcdCcNextEngineParams->nextEngine)
     {
@@ -1531,25 +1608,40 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
             break;
 
         case (e_FM_PCD_DONE):
-            if ((p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME) &&
-                p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+            if ((p_FmPcdCcNextEngineParams->params.enqueueParams.action
+                    == e_FM_PCD_ENQ_FRAME)
+                    && p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
             {
                 if (!p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid)
-                    RETURN_ERROR(MAJOR, E_CONFLICT, ("When overrideFqid is set, newFqid must not be zero"));
-                if (p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_CONFLICT,
+                            ("When overrideFqid is set, newFqid must not be zero"));
+                if (p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid
+                        & ~0x00FFFFFF)
+                    RETURN_ERROR(
+                            MAJOR, E_INVALID_VALUE,
+                            ("fqidForCtrlFlow must be between 1 and 2^24-1"));
             }
             break;
 
         case (e_FM_PCD_KG):
-            relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd,
-                                                          FmPcdKgGetSchemeId(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme));
+            relativeSchemeId =
+                    FmPcdKgGetRelativeSchemeId(
+                            h_FmPcd,
+                            FmPcdKgGetSchemeId(
+                                    p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme));
             if (relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-            if (!FmPcdKgIsSchemeValidSw(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not valid schemeIndex in KG next engine param"));
+            if (!FmPcdKgIsSchemeValidSw(
+                    p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("not valid schemeIndex in KG next engine param"));
             if (!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("CC Node may point only to a scheme that is always direct."));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("CC Node may point only to a scheme that is always direct."));
             break;
 
         case (e_FM_PCD_PLCR):
@@ -1558,15 +1650,19 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
                 /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
                 if (p_FmPcdCcNextEngineParams->params.plcrParams.sharedProfile)
                 {
-                    err = FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd,
-                                                        e_FM_PCD_PLCR_SHARED,
-                                                        NULL,
-                                                        p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId,
-                                                        &absoluteProfileId);
+                    err =
+                            FmPcdPlcrGetAbsoluteIdByProfileParams(
+                                    h_FmPcd,
+                                    e_FM_PCD_PLCR_SHARED,
+                                    NULL,
+                                    p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId,
+                                    &absoluteProfileId);
                     if (err)
-                        RETURN_ERROR(MAJOR, err, ("Shared profile offset is out of range"));
+                        RETURN_ERROR(MAJOR, err,
+                                     ("Shared profile offset is out of range"));
                     if (!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile"));
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                     ("Invalid profile"));
                 }
             }
             break;
@@ -1575,31 +1671,30 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
             p_FmPcdCcNextEngineParams->nextEngine = e_FM_PCD_CC;
         case (e_FM_PCD_CC):
             if (!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
-                RETURN_ERROR(MAJOR, E_NULL_POINTER, ("handler to next Node is NULL"));
+                RETURN_ERROR(MAJOR, E_NULL_POINTER,
+                             ("handler to next Node is NULL"));
             break;
 
 #if (DPAA_VERSION >= 11)
-         case (e_FM_PCD_FR):
+        case (e_FM_PCD_FR):
             if (!p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
                 err = E_NOT_SUPPORTED;
             break;
 #endif /* (DPAA_VERSION >= 11) */
 
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("Next engine is not correct"));
     }
 
 
     return err;
 }
 
-static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
-                               e_FmPcdExtractFrom   src,
-                               uint32_t             offset,
-                               bool                 glblMask,
-                               uint8_t              *parseArrayOffset,
-                               bool                 fromIc,
-                               ccPrivateInfo_t      icCode)
+static uint8_t GetGenParseCode(t_Handle h_FmPcd, e_FmPcdExtractFrom src,
+                               uint32_t offset, bool glblMask,
+                               uint8_t *parseArrayOffset, bool fromIc,
+                               ccPrivateInfo_t icCode)
 {
     UNUSED(h_FmPcd);
 
@@ -1609,9 +1704,9 @@ static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
         {
             case (e_FM_PCD_EXTRACT_FROM_FRAME_START):
                 if (glblMask)
-                    return CC_PC_GENERIC_WITH_MASK ;
+                    return CC_PC_GENERIC_WITH_MASK;
                 else
-                  return CC_PC_GENERIC_WITHOUT_MASK;
+                    return CC_PC_GENERIC_WITHOUT_MASK;
 
             case (e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
                 *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
@@ -1630,20 +1725,20 @@ static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
         switch (icCode)
         {
             case (CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH):
-                 *parseArrayOffset = 0x50;
-                 return CC_PC_GENERIC_IC_GMASK;
+                *parseArrayOffset = 0x50;
+                return CC_PC_GENERIC_IC_GMASK;
 
             case (CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH):
-               *parseArrayOffset = 0x48;
-               return CC_PC_GENERIC_IC_GMASK;
+                *parseArrayOffset = 0x48;
+                return CC_PC_GENERIC_IC_GMASK;
 
             case (CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP):
                 *parseArrayOffset = 0x48;
-                 return CC_PC_GENERIC_IC_HASH_INDEXED;
+                return CC_PC_GENERIC_IC_HASH_INDEXED;
 
             case (CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP):
                 *parseArrayOffset = 0x16;
-                 return CC_PC_GENERIC_IC_HASH_INDEXED;
+                return CC_PC_GENERIC_IC_HASH_INDEXED;
 
             default:
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
@@ -1654,9 +1749,8 @@ static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
     return CC_PC_ILLEGAL;
 }
 
-static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
-                                     e_FmPcdHdrIndex    index,
-                                     t_FmPcdFields      field)
+static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
+                                     t_FmPcdFields field)
 {
     switch (hdr)
     {
@@ -1682,7 +1776,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             switch (field.vlan)
             {
                 case (NET_HEADER_FIELD_VLAN_TCI):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_TCI1;
                     if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return CC_PC_FF_TCI2;
@@ -1697,7 +1792,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             switch (field.mpls)
             {
                 case (NET_HEADER_FIELD_MPLS_LABEL_STACK):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_MPLS1;
                     if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return CC_PC_FF_MPLS_LAST;
@@ -1712,35 +1808,41 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             switch (field.ipv4)
             {
                 case (NET_HEADER_FIELD_IPv4_DST_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4DST1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4DST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
                 case (NET_HEADER_FIELD_IPv4_TOS):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4IPTOS_TC1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4IPTOS_TC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
                 case (NET_HEADER_FIELD_IPv4_PROTO):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4PTYPE1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
                 case (NET_HEADER_FIELD_IPv4_SRC_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4SRC1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4SRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-                case (NET_HEADER_FIELD_IPv4_SRC_IP | NET_HEADER_FIELD_IPv4_DST_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_SRC_IP
+                        | NET_HEADER_FIELD_IPv4_DST_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4SRC1_IPV4DST1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4SRC2_IPV4DST2;
@@ -1754,10 +1856,12 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             }
 
         case (HEADER_TYPE_IPv6):
-             switch (field.ipv6)
+            switch (field.ipv6)
             {
-                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL
+                        | NET_HEADER_FIELD_IPv6_TC):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2;
@@ -1765,7 +1869,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
 
                 case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV6PTYPE1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6PTYPE2;
@@ -1775,7 +1880,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
 
                 case (NET_HEADER_FIELD_IPv6_DST_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV6DST1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6DST2;
@@ -1783,7 +1889,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
 
                 case (NET_HEADER_FIELD_IPv6_SRC_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV6SRC1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6SRC2;
@@ -1798,113 +1905,115 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
             }
 
-       case (HEADER_TYPE_IP):
-           switch (field.ip)
-           {
-               case (NET_HEADER_FIELD_IP_DSCP):
-                   if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
-                       return CC_PC_FF_IPDSCP;
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
-                   return CC_PC_ILLEGAL;
-
-               case (NET_HEADER_FIELD_IP_PROTO):
-                   if (index == e_FM_PCD_HDR_INDEX_LAST)
-                       return CC_PC_FF_IPPID;
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
-                   return CC_PC_ILLEGAL;
-
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
-
-       case (HEADER_TYPE_GRE):
-           switch (field.gre)
-           {
-               case (NET_HEADER_FIELD_GRE_TYPE):
-                   return CC_PC_FF_GREPTYPE;
-
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
-
-       case (HEADER_TYPE_MINENCAP):
-           switch (field.minencap)
-           {
-               case (NET_HEADER_FIELD_MINENCAP_TYPE):
-                   return CC_PC_FF_MINENCAP_PTYPE;
-
-               case (NET_HEADER_FIELD_MINENCAP_DST_IP):
-                   return CC_PC_FF_MINENCAP_IPDST;
-
-               case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
-                   return CC_PC_FF_MINENCAP_IPSRC;
-
-               case (NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
-                   return CC_PC_FF_MINENCAP_IPSRC_IPDST;
-
-               default:
+        case (HEADER_TYPE_IP):
+            switch (field.ip)
+            {
+                case (NET_HEADER_FIELD_IP_DSCP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPDSCP;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
+                    return CC_PC_ILLEGAL;
+
+                case (NET_HEADER_FIELD_IP_PROTO):
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
+                        return CC_PC_FF_IPPID;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
+                    return CC_PC_ILLEGAL;
+
+                default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-           }
+            }
 
-       case (HEADER_TYPE_TCP):
-           switch (field.tcp)
-           {
-               case (NET_HEADER_FIELD_TCP_PORT_SRC):
-                   return CC_PC_FF_L4PSRC;
+        case (HEADER_TYPE_GRE):
+            switch (field.gre)
+            {
+                case (NET_HEADER_FIELD_GRE_TYPE):
+                    return CC_PC_FF_GREPTYPE;
 
-               case (NET_HEADER_FIELD_TCP_PORT_DST):
-                   return CC_PC_FF_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
 
-               case (NET_HEADER_FIELD_TCP_PORT_DST | NET_HEADER_FIELD_TCP_PORT_SRC):
-                   return CC_PC_FF_L4PSRC_L4PDST;
+        case (HEADER_TYPE_MINENCAP):
+            switch (field.minencap)
+            {
+                case (NET_HEADER_FIELD_MINENCAP_TYPE):
+                    return CC_PC_FF_MINENCAP_PTYPE;
 
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
+                case (NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPDST;
 
-       case (HEADER_TYPE_PPPoE):
-           switch (field.pppoe)
-           {
-               case (NET_HEADER_FIELD_PPPoE_PID):
-                   return CC_PC_FF_PPPPID;
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC;
 
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP
+                        | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC_IPDST;
 
-       case (HEADER_TYPE_UDP):
-           switch (field.udp)
-           {
-               case (NET_HEADER_FIELD_UDP_PORT_SRC):
-                   return CC_PC_FF_L4PSRC;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+
+        case (HEADER_TYPE_TCP):
+            switch (field.tcp)
+            {
+                case (NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
+
+                case (NET_HEADER_FIELD_TCP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
+
+                case (NET_HEADER_FIELD_TCP_PORT_DST
+                        | NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
+
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+
+        case (HEADER_TYPE_PPPoE):
+            switch (field.pppoe)
+            {
+                case (NET_HEADER_FIELD_PPPoE_PID):
+                    return CC_PC_FF_PPPPID;
+
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
 
-               case (NET_HEADER_FIELD_UDP_PORT_DST):
-                   return CC_PC_FF_L4PDST;
+        case (HEADER_TYPE_UDP):
+            switch (field.udp)
+            {
+                case (NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
 
-               case (NET_HEADER_FIELD_UDP_PORT_DST | NET_HEADER_FIELD_UDP_PORT_SRC):
-                   return CC_PC_FF_L4PSRC_L4PDST;
+                case (NET_HEADER_FIELD_UDP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
 
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
+                case (NET_HEADER_FIELD_UDP_PORT_DST
+                        | NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
+
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
 
         default:
-           REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-           return CC_PC_ILLEGAL;
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return CC_PC_ILLEGAL;
     }
 }
 
-static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
-                              e_FmPcdHdrIndex   hdrIndex,
-                              uint32_t          offset,
-                              bool              glblMask,
-                              uint8_t           *parseArrayOffset)
+static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex,
+                              uint32_t offset, bool glblMask,
+                              uint8_t *parseArrayOffset)
 {
     bool offsetRelevant = FALSE;
 
@@ -1944,28 +2053,32 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
             break;
 
         case (HEADER_TYPE_MPLS):
-            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                    *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
-            else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                    *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                    || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
             else
-            {
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
-                return CC_PC_ILLEGAL;
-            }
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                else
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                    return CC_PC_ILLEGAL;
+                }
             break;
 
         case (HEADER_TYPE_IPv4):
         case (HEADER_TYPE_IPv6):
-            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                    || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                 *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
-            else if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
-                *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
             else
-            {
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
-                return CC_PC_ILLEGAL;
-            }
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+                else
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
+                    return CC_PC_ILLEGAL;
+                }
             break;
 
         case (HEADER_TYPE_MINENCAP):
@@ -1988,7 +2101,7 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
         default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header for this type of operation"));
             return CC_PC_ILLEGAL;
-     }
+    }
 
     if (offsetRelevant)
         return CC_PR_OFFSET;
@@ -1996,11 +2109,9 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
         return CC_PR_WITHOUT_OFFSET;
 }
 
-static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
-                                 t_FmPcdFields      field,
-                                 uint32_t           offset,
-                                 uint8_t            *parseArrayOffset,
-                                 e_FmPcdHdrIndex    hdrIndex)
+static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field,
+                                 uint32_t offset, uint8_t *parseArrayOffset,
+                                 e_FmPcdHdrIndex hdrIndex)
 {
     bool offsetRelevant = FALSE;
 
@@ -2010,7 +2121,7 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
     switch (hdr)
     {
         case (HEADER_TYPE_NONE):
-                ASSERT_COND(FALSE);
+            ASSERT_COND(FALSE);
         case (HEADER_TYPE_ETH):
             switch (field.eth)
             {
@@ -2028,10 +2139,12 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
             switch (field.vlan)
             {
                 case (NET_HEADER_FIELD_VLAN_TCI):
-                    if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                            || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                         *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
-                    else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                        *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                    else
+                        if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                            *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
                     break;
 
                 default:
@@ -2051,16 +2164,16 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
         return CC_PR_WITHOUT_OFFSET;
 }
 
-static void FillAdOfTypeResult(t_Handle                    h_Ad,
-                               t_FmPcdCcStatsParams        *p_FmPcdCcStatsParams,
-                               t_FmPcd                     *p_FmPcd,
-                               t_FmPcdCcNextEngineParams   *p_CcNextEngineParams)
+static void FillAdOfTypeResult(t_Handle h_Ad,
+                               t_FmPcdCcStatsParams *p_FmPcdCcStatsParams,
+                               t_FmPcd *p_FmPcd,
+                               t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
 {
-    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult *)h_Ad;
-    t_Handle            h_TmpAd;
-    uint32_t            tmp = 0, tmpNia = 0;
-    uint16_t            profileId;
-    t_Handle            p_AdNewPtr = NULL;
+    t_AdOfTypeResult *p_AdResult = (t_AdOfTypeResult *)h_Ad;
+    t_Handle h_TmpAd;
+    uint32_t tmp = 0, tmpNia = 0;
+    uint16_t profileId;
+    t_Handle p_AdNewPtr = NULL;
 
     /* There are 3 cases handled in this routine of building a "result" type AD.
      * Case 1: No Manip. The action descriptor is built within the match table.
@@ -2096,17 +2209,13 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
         p_AdResult = h_Ad;
 
         /* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
-        UpdateStatsAd(p_FmPcdCcStatsParams,
-                      h_Ad,
-                      p_FmPcd->physicalMuramBase);
+        UpdateStatsAd(p_FmPcdCcStatsParams, h_Ad, p_FmPcd->physicalMuramBase);
     }
 
     /* Create manip and return p_AdNewPtr to either a new descriptor or NULL */
     if (p_CcNextEngineParams->h_Manip)
         FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip,
-                                      p_CcNextEngineParams,
-                                      h_Ad,
-                                      &p_AdNewPtr);
+                                      p_CcNextEngineParams, h_Ad, &p_AdNewPtr);
 
     /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
     if (p_AdNewPtr)
@@ -2115,24 +2224,30 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
         switch (p_CcNextEngineParams->nextEngine)
         {
             case (e_FM_PCD_DONE):
-                if (p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
+                if (p_CcNextEngineParams->params.enqueueParams.action
+                        == e_FM_PCD_ENQ_FRAME)
                 {
                     if (p_CcNextEngineParams->params.enqueueParams.overrideFqid)
                     {
-                       tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
-                       tmp |= p_CcNextEngineParams->params.enqueueParams.newFqid;
+                        tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+                        tmp |=
+                                p_CcNextEngineParams->params.enqueueParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                       tmp |= (p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
+                        tmp |=
+                                (p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId
+                                        & FM_PCD_AD_RESULT_VSP_MASK)
+                                        << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                     }
                     else
                     {
-                       tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
-                       tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+                        tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                        tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
                     }
                 }
 
-                if (p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
+                if (p_CcNextEngineParams->params.enqueueParams.action
+                        == e_FM_PCD_DROP_FRAME)
                     tmpNia |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
                 else
                     tmpNia |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
@@ -2144,7 +2259,10 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                     tmp |= p_CcNextEngineParams->params.kgParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                    tmp |= (p_CcNextEngineParams->params.kgParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
+                    tmp |=
+                            (p_CcNextEngineParams->params.kgParams.newRelativeStorageProfileId
+                                    & FM_PCD_AD_RESULT_VSP_MASK)
+                                    << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                 }
                 else
@@ -2155,7 +2273,8 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
                 tmpNia = NIA_KG_DIRECT;
                 tmpNia |= NIA_ENG_KG;
                 tmpNia |= NIA_KG_CC_EN;
-                tmpNia |= FmPcdKgGetSchemeId(p_CcNextEngineParams->params.kgParams.h_DirectScheme);
+                tmpNia |= FmPcdKgGetSchemeId(
+                        p_CcNextEngineParams->params.kgParams.h_DirectScheme);
                 break;
 
             case (e_FM_PCD_PLCR):
@@ -2168,36 +2287,45 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
                     if (p_CcNextEngineParams->params.plcrParams.sharedProfile)
                     {
                         tmpNia |= NIA_PLCR_ABSOLUTE;
-                        FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,
-                                                              e_FM_PCD_PLCR_SHARED,
-                                                              NULL,
-                                                              p_CcNextEngineParams->params.plcrParams.newRelativeProfileId,
-                                                              &profileId);
+                        FmPcdPlcrGetAbsoluteIdByProfileParams(
+                                (t_Handle)p_FmPcd,
+                                e_FM_PCD_PLCR_SHARED,
+                                NULL,
+                                p_CcNextEngineParams->params.plcrParams.newRelativeProfileId,
+                                &profileId);
                     }
                     else
-                        profileId = p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
+                        profileId =
+                                p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
 
                     tmp |= p_CcNextEngineParams->params.plcrParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                    tmp |= (p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK)<< FM_PCD_AD_RESULT_VSP_SHIFT;
+                    tmp |=
+                            (p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId
+                                    & FM_PCD_AD_RESULT_VSP_MASK)
+                                    << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
-                    WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
+                    WRITE_UINT32(
+                            p_AdResult->plcrProfile,
+                            (uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
                 }
                 else
-                   tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                    tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
 
-                tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
-               break;
+                tmpNia |=
+                        NIA_ENG_PLCR
+                                | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
+                break;
 
             default:
                 return;
-        }
-        WRITE_UINT32(p_AdResult->fqid, tmp);
+        }WRITE_UINT32(p_AdResult->fqid, tmp);
 
         if (p_CcNextEngineParams->h_Manip)
         {
             tmp = GET_UINT32(p_AdResult->plcrProfile);
-            tmp |= (uint32_t)(XX_VirtToPhys(p_AdNewPtr) - (p_FmPcd->physicalMuramBase)) >> 4;
+            tmp |= (uint32_t)(XX_VirtToPhys(p_AdNewPtr)
+                    - (p_FmPcd->physicalMuramBase)) >> 4;
             WRITE_UINT32(p_AdResult->plcrProfile, tmp);
 
             tmpNia |= FM_PCD_AD_RESULT_EXTENDED_MODE;
@@ -2211,97 +2339,92 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
     }
 }
 
-static t_Error CcUpdateParams(t_Handle      h_FmPcd,
-                              t_Handle      h_PcdParams,
-                              t_Handle      h_FmPort,
-                              t_Handle      h_FmTree,
-                              bool          validate)
+static t_Error CcUpdateParams(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                              t_Handle h_FmPort, t_Handle h_FmTree,
+                              bool validate)
 {
-    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
+    t_FmPcdCcTree *p_CcTree = (t_FmPcdCcTree *)h_FmTree;
 
-    return CcUpdateParam(h_FmPcd,
-                         h_PcdParams,
-                         h_FmPort,
+    return CcUpdateParam(h_FmPcd, h_PcdParams, h_FmPort,
                          p_CcTree->keyAndNextEngineParams,
                          p_CcTree->numOfEntries,
-                         UINT_TO_PTR(p_CcTree->ccTreeBaseAddr),
-                         validate,
-                         0,
-                         h_FmTree,
-                         FALSE);
+                         UINT_TO_PTR(p_CcTree->ccTreeBaseAddr), validate, 0,
+                         h_FmTree, FALSE);
 }
 
 
-static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static void ReleaseNewNodeCommonPart(
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     if (p_AdditionalInfo->p_AdTableNew)
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
-                         p_AdditionalInfo->p_AdTableNew);
+        FM_MURAM_FreeMem(
+                FmPcdGetMuramHandle(
+                        ((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
+                p_AdditionalInfo->p_AdTableNew);
 
     if (p_AdditionalInfo->p_KeysMatchTableNew)
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
-                         p_AdditionalInfo->p_KeysMatchTableNew);
+        FM_MURAM_FreeMem(
+                FmPcdGetMuramHandle(
+                        ((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
+                p_AdditionalInfo->p_KeysMatchTableNew);
 }
 
-static t_Error UpdateGblMask(t_FmPcdCcNode *p_CcNode,
-                             uint8_t       keySize,
-                             uint8_t       *p_Mask)
+static t_Error UpdateGblMask(t_FmPcdCcNode *p_CcNode, uint8_t keySize,
+                             uint8_t *p_Mask)
 {
     uint8_t prvGlblMaskSize = p_CcNode->glblMaskSize;
 
-    if (p_Mask &&
-        !p_CcNode->glblMaskUpdated &&
-        (keySize <= 4) &&
-        !p_CcNode->lclMask)
-    {
-        if (p_CcNode->parseCode &&
-            (p_CcNode->parseCode != CC_PC_FF_TCI1) &&
-            (p_CcNode->parseCode != CC_PC_FF_TCI2) &&
-            (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
-            (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPDSCP) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) )
+    if (p_Mask && !p_CcNode->glblMaskUpdated && (keySize <= 4)
+            && !p_CcNode->lclMask)
+    {
+        if (p_CcNode->parseCode && (p_CcNode->parseCode != CC_PC_FF_TCI1)
+                && (p_CcNode->parseCode != CC_PC_FF_TCI2)
+                && (p_CcNode->parseCode != CC_PC_FF_MPLS1)
+                && (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST)
+                && (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1)
+                && (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2)
+                && (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1)
+                && (p_CcNode->parseCode != CC_PC_FF_IPDSCP)
+                && (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2))
         {
             p_CcNode->glblMaskSize = 0;
             p_CcNode->lclMask = TRUE;
         }
         else
         {
-            memcpy(p_CcNode->p_GlblMask, p_Mask, (sizeof(uint8_t))*keySize);
+            memcpy(p_CcNode->p_GlblMask, p_Mask, (sizeof(uint8_t)) * keySize);
             p_CcNode->glblMaskUpdated = TRUE;
             p_CcNode->glblMaskSize = 4;
         }
     }
-    else if (p_Mask &&
-             (keySize <= 4) &&
-             !p_CcNode->lclMask)
-    {
-        if (memcmp(p_CcNode->p_GlblMask, p_Mask, keySize) != 0)
-        {
-            p_CcNode->lclMask = TRUE;
-            p_CcNode->glblMaskSize = 0;
-        }
-    }
-    else if (!p_Mask && p_CcNode->glblMaskUpdated && (keySize <= 4))
-    {
-        uint32_t tmpMask = 0xffffffff;
-        if (memcmp(p_CcNode->p_GlblMask, &tmpMask, 4) != 0)
+    else
+        if (p_Mask && (keySize <= 4) && !p_CcNode->lclMask)
         {
-            p_CcNode->lclMask = TRUE;
-            p_CcNode->glblMaskSize = 0;
+            if (memcmp(p_CcNode->p_GlblMask, p_Mask, keySize) != 0)
+            {
+                p_CcNode->lclMask = TRUE;
+                p_CcNode->glblMaskSize = 0;
+            }
         }
-    }
-    else if (p_Mask)
-    {
-        p_CcNode->lclMask = TRUE;
-        p_CcNode->glblMaskSize = 0;
-    }
+        else
+            if (!p_Mask && p_CcNode->glblMaskUpdated && (keySize <= 4))
+            {
+                uint32_t tmpMask = 0xffffffff;
+                if (memcmp(p_CcNode->p_GlblMask, &tmpMask, 4) != 0)
+                {
+                    p_CcNode->lclMask = TRUE;
+                    p_CcNode->glblMaskSize = 0;
+                }
+            }
+            else
+                if (p_Mask)
+                {
+                    p_CcNode->lclMask = TRUE;
+                    p_CcNode->glblMaskSize = 0;
+                }
 
     /* In static mode (maxNumOfKeys > 0), local mask is supported
-       only is mask support was enabled at initialization */
+     only is mask support was enabled at initialization */
     if (p_CcNode->maxNumOfKeys && (!p_CcNode->maskSupport) && p_CcNode->lclMask)
     {
         p_CcNode->lclMask = FALSE;
@@ -2312,26 +2435,26 @@ static t_Error UpdateGblMask(t_FmPcdCcNode *p_CcNode,
     return E_OK;
 }
 
-static __inline__ t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
+static __inline__ t_Handle GetNewAd(t_Handle h_FmPcdCcNodeOrTree, bool isTree)
 {
-    t_FmPcd         *p_FmPcd;
-    t_Handle        h_Ad;
+    t_FmPcd *p_FmPcd;
+    t_Handle h_Ad;
 
     if (isTree)
         p_FmPcd = (t_FmPcd *)(((t_FmPcdCcTree *)h_FmPcdCcNodeOrTree)->h_FmPcd);
     else
         p_FmPcd = (t_FmPcd *)(((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_FmPcd);
 
-    if ((isTree && p_FmPcd->p_CcShadow) ||
-        (!isTree && ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->maxNumOfKeys))
+    if ((isTree && p_FmPcd->p_CcShadow)
+            || (!isTree && ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->maxNumOfKeys))
     {
         /* The allocated shadow is divided as follows:
-           0 . . .       16 . . .
-           ---------------------------------------------------
-           |   Shadow   |   Shadow Keys   |   Shadow Next    |
-           |     Ad     |   Match Table   |   Engine Table   |
-           | (16 bytes) | (maximal size)  |  (maximal size)  |
-           ---------------------------------------------------
+         0 . . .       16 . . .
+         ---------------------------------------------------
+         |   Shadow   |   Shadow Keys   |   Shadow Next    |
+         |     Ad     |   Match Table   |   Engine Table   |
+         | (16 bytes) | (maximal size)  |  (maximal size)  |
+         ---------------------------------------------------
          */
         if (!p_FmPcd->p_CcShadow)
         {
@@ -2356,9 +2479,9 @@ static __inline__ t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
     return h_Ad;
 }
 
-static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_CcNode,
-                                      int                                   *size,
-                                      t_FmPcdModifyCcKeyAdditionalParams    *p_AdditionalInfo)
+static t_Error BuildNewNodeCommonPart(
+        t_FmPcdCcNode *p_CcNode, int *size,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
@@ -2369,77 +2492,92 @@ static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_C
 
     if (p_CcNode->maxNumOfKeys == 0)
     {
-        p_AdditionalInfo->p_AdTableNew =
-            (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                        (uint32_t)( (p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
-                                        FM_PCD_CC_AD_TABLE_ALIGN);
+        p_AdditionalInfo->p_AdTableNew = (t_Handle)FM_MURAM_AllocMem(
+                FmPcdGetMuramHandle(p_FmPcd),
+                (uint32_t)((p_AdditionalInfo->numOfKeys + 1)
+                        * FM_PCD_CC_AD_ENTRY_SIZE),
+                FM_PCD_CC_AD_TABLE_ALIGN);
         if (!p_AdditionalInfo->p_AdTableNew)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
-
-        p_AdditionalInfo->p_KeysMatchTableNew =
-            (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                        (uint32_t)(*size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1)),
-                                        FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+            RETURN_ERROR(
+                    MAJOR, E_NO_MEMORY,
+                    ("MURAM allocation for CC node action descriptors table"));
+
+        p_AdditionalInfo->p_KeysMatchTableNew = (t_Handle)FM_MURAM_AllocMem(
+                FmPcdGetMuramHandle(p_FmPcd),
+                (uint32_t)(*size * sizeof(uint8_t)
+                        * (p_AdditionalInfo->numOfKeys + 1)),
+                FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
         if (!p_AdditionalInfo->p_KeysMatchTableNew)
         {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                             p_AdditionalInfo->p_AdTableNew);
             p_AdditionalInfo->p_AdTableNew = NULL;
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC node key match table"));
         }
 
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0, *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
+        IOMemSet32(
+                (uint8_t*)p_AdditionalInfo->p_AdTableNew,
+                0,
+                (uint32_t)((p_AdditionalInfo->numOfKeys + 1)
+                        * FM_PCD_CC_AD_ENTRY_SIZE));
+        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0,
+                   *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
     }
     else
     {
         /* The allocated shadow is divided as follows:
-           0 . . .       16 . . .
-           ---------------------------------------------------
-           |   Shadow   |   Shadow Keys   |   Shadow Next    |
-           |     Ad     |   Match Table   |   Engine Table   |
-           | (16 bytes) | (maximal size)  |  (maximal size)  |
-           ---------------------------------------------------
+         0 . . .       16 . . .
+         ---------------------------------------------------
+         |   Shadow   |   Shadow Keys   |   Shadow Next    |
+         |     Ad     |   Match Table   |   Engine Table   |
+         | (16 bytes) | (maximal size)  |  (maximal size)  |
+         ---------------------------------------------------
          */
 
         if (!p_FmPcd->p_CcShadow)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("CC Shadow not allocated"));
 
-        p_AdditionalInfo->p_KeysMatchTableNew = PTR_MOVE(p_FmPcd->p_CcShadow, FM_PCD_CC_AD_ENTRY_SIZE);
-        p_AdditionalInfo->p_AdTableNew        = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, p_CcNode->keysMatchTableMaxSize);
+        p_AdditionalInfo->p_KeysMatchTableNew =
+                PTR_MOVE(p_FmPcd->p_CcShadow, FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdditionalInfo->p_AdTableNew =
+                PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, p_CcNode->keysMatchTableMaxSize);
 
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0, (*size) * sizeof(uint8_t) * (p_CcNode->maxNumOfKeys));
+        IOMemSet32(
+                (uint8_t*)p_AdditionalInfo->p_AdTableNew,
+                0,
+                (uint32_t)((p_CcNode->maxNumOfKeys + 1)
+                        * FM_PCD_CC_AD_ENTRY_SIZE));
+        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0,
+                   (*size) * sizeof(uint8_t) * (p_CcNode->maxNumOfKeys));
     }
 
-    p_AdditionalInfo->p_AdTableOld          = p_CcNode->h_AdTable;
-    p_AdditionalInfo->p_KeysMatchTableOld   = p_CcNode->h_KeysMatchTable;
+    p_AdditionalInfo->p_AdTableOld = p_CcNode->h_AdTable;
+    p_AdditionalInfo->p_KeysMatchTableOld = p_CcNode->h_KeysMatchTable;
 
     return E_OK;
 }
 
-static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle                           h_FmPcd,
-                                                     t_FmPcdCcNode                      *p_CcNode,
-                                                     uint16_t                           keyIndex,
-                                                     t_FmPcdCcKeyParams                 *p_KeyParams,
-                                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo,
-                                                     bool                               add)
+static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
+        t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, uint16_t keyIndex,
+        t_FmPcdCcKeyParams *p_KeyParams,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo, bool add)
 {
-    t_Error                 err = E_OK;
-    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
-    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
-    int                     size;
-    int                     i = 0, j = 0;
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                requiredAction = 0;
-    bool                    prvLclMask;
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcStatsParams    statsParams = {0};
-    t_List                  *p_Pos;
-    t_FmPcdStatsObj         *p_StatsObj;
+    t_Error err = E_OK;
+    t_Handle p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int size;
+    int i = 0, j = 0;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t requiredAction = 0;
+    bool prvLclMask;
+    t_CcNodeInformation *p_CcNodeInformation;
+    t_FmPcdCcStatsParams statsParams = { 0 };
+    t_List *p_Pos;
+    t_FmPcdStatsObj *p_StatsObj;
 
     /* Check that new NIA is legal */
-    err = ValidateNextEngineParams(h_FmPcd,
-                                   &p_KeyParams->ccNextEngineParams,
+    err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams,
                                    p_CcNode->statisticsMode);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2447,36 +2585,34 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     prvLclMask = p_CcNode->lclMask;
 
     /* Check that new key is not require update of localMask */
-    err = UpdateGblMask(p_CcNode,
-                        p_CcNode->ccKeySizeAccExtraction,
+    err = UpdateGblMask(p_CcNode, p_CcNode->ccKeySizeAccExtraction,
                         p_KeyParams->p_Mask);
     if (err)
         RETURN_ERROR(MAJOR, err, (NO_MSG));
 
     /* Update internal data structure with new next engine for the given index */
     memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,
-           &p_KeyParams->ccNextEngineParams,
-           sizeof(t_FmPcdCcNextEngineParams));
+           &p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
 
     memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key,
-            p_KeyParams->p_Key,
-            p_CcNode->userSizeOfExtraction);
+           p_KeyParams->p_Key, p_CcNode->userSizeOfExtraction);
 
-    if ((p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        && p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
+    if ((p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
+            && p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
     {
-        err = AllocAndFillAdForContLookupManip(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode);
+        err =
+                AllocAndFillAdForContLookupManip(
+                        p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
     if (p_KeyParams->p_Mask)
         memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
-               p_KeyParams->p_Mask,
-               p_CcNode->userSizeOfExtraction);
+               p_KeyParams->p_Mask, p_CcNode->userSizeOfExtraction);
     else
-        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
-               0xFF,
+        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask, 0xFF,
                p_CcNode->userSizeOfExtraction);
 
     /* Update numOfKeys */
@@ -2493,35 +2629,40 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     /* Check that manip is legal and what requiredAction is necessary for this manip */
     if (p_KeyParams->ccNextEngineParams.h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams,&requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(
+                &p_KeyParams->ccNextEngineParams, &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
-    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction = requiredAction;
-    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction =
+            requiredAction;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |=
+            UPDATE_CC_WITH_TREE;
 
     /* Update new Ad and new Key Table according to new requirement */
     i = 0;
     for (j = 0; j < p_AdditionalInfo->numOfKeys; j++)
     {
-        p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableNewTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
 
         if (j == keyIndex)
         {
             if (p_KeyParams->ccNextEngineParams.statisticsEn)
             {
                 /* Allocate a statistics object that holds statistics AD and counters.
-                   - For added key - New statistics AD and counters pointer need to be allocated
-                     new statistics object. If statistics were enabled, we need to replace the
-                     existing descriptor with a new descriptor with nullified counters.
+                 - For added key - New statistics AD and counters pointer need to be allocated
+                 new statistics object. If statistics were enabled, we need to replace the
+                 existing descriptor with a new descriptor with nullified counters.
                  */
                 p_StatsObj = GetStatsObj(p_CcNode);
                 ASSERT_COND(p_StatsObj);
 
                 /* Store allocated statistics object */
                 ASSERT_COND(keyIndex < CC_MAX_NUM_OF_KEYS);
-                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj =
+                        p_StatsObj;
 
                 statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
                 statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
@@ -2531,24 +2672,22 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 #endif /* (DPAA_VERSION >= 11) */
 
                 /* Building action descriptor for the received new key */
-                NextStepAd(p_AdTableNewTmp,
-                           &statsParams,
-                           &p_KeyParams->ccNextEngineParams,
-                           p_FmPcd);
+                NextStepAd(p_AdTableNewTmp, &statsParams,
+                           &p_KeyParams->ccNextEngineParams, p_FmPcd);
             }
             else
             {
                 /* Building action descriptor for the received new key */
-                NextStepAd(p_AdTableNewTmp,
-                           NULL,
-                           &p_KeyParams->ccNextEngineParams,
-                           p_FmPcd);
+                NextStepAd(p_AdTableNewTmp, NULL,
+                           &p_KeyParams->ccNextEngineParams, p_FmPcd);
             }
 
             /* Copy the received new key into keys match table */
-            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size*sizeof(uint8_t));
+            p_KeysMatchTableNewTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size*sizeof(uint8_t));
 
-            Mem2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_CcNode->userSizeOfExtraction);
+            Mem2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key,
+                        p_CcNode->userSizeOfExtraction);
 
             /* Update mask for the received new key */
             if (p_CcNode->lclMask)
@@ -2556,79 +2695,87 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
                 if (p_KeyParams->p_Mask)
                 {
                     Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                p_CcNode->ccKeySizeAccExtraction),
+                            p_CcNode->ccKeySizeAccExtraction),
                                 p_KeyParams->p_Mask,
                                 p_CcNode->userSizeOfExtraction);
                 }
-                else if (p_CcNode->ccKeySizeAccExtraction > 4)
-                {
-                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                               p_CcNode->ccKeySizeAccExtraction),
-                               0xff,
-                               p_CcNode->userSizeOfExtraction);
-                }
                 else
-                {
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                    if (p_CcNode->ccKeySizeAccExtraction > 4)
+                    {
+                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
-                                p_CcNode->p_GlblMask,
-                                p_CcNode->userSizeOfExtraction);
-                }
+                                   0xff, p_CcNode->userSizeOfExtraction);
+                    }
+                    else
+                    {
+                        Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                    p_CcNode->p_GlblMask,
+                                    p_CcNode->userSizeOfExtraction);
+                    }
             }
 
             /* If key modification requested, the old entry is omitted and replaced by the new parameters */
             if (!add)
                 i++;
-         }
-         else
-         {
-             /* Copy existing action descriptors to the newly allocated Ad table */
-             p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
-             IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
-
-             /* Copy existing keys and their masks to the newly allocated keys match table */
-             p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
-             p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, i * size * sizeof(uint8_t));
-
-             if (p_CcNode->lclMask)
-             {
-                 if (prvLclMask)
-                 {
-                     IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
-                                PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
-                                p_CcNode->ccKeySizeAccExtraction);
-                 }
-                 else
-                 {
-                     p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable,
-                                                       i * p_CcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
-
-                     if (p_CcNode->ccKeySizeAccExtraction > 4)
-                     {
-                         IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                    p_CcNode->ccKeySizeAccExtraction),
-                                    0xff,
-                                    p_CcNode->userSizeOfExtraction);
-                     }
-                     else
-                     {
-                         IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                    p_CcNode->ccKeySizeAccExtraction),
-                                    p_CcNode->p_GlblMask,
-                                    p_CcNode->userSizeOfExtraction);
-                     }
-                 }
-             }
+        }
+        else
+        {
+            /* Copy existing action descriptors to the newly allocated Ad table */
+            p_AdTableOldTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+            IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,
+                       FM_PCD_CC_AD_ENTRY_SIZE);
+
+            /* Copy existing keys and their masks to the newly allocated keys match table */
+            p_KeysMatchTableNewTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, i * size * sizeof(uint8_t));
 
-             IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction);
+            if (p_CcNode->lclMask)
+            {
+                if (prvLclMask)
+                {
+                    IO2IOCpy32(
+                            PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
+                            PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
+                            p_CcNode->ccKeySizeAccExtraction);
+                }
+                else
+                {
+                    p_KeysMatchTableOldTmp =
+                            PTR_MOVE(p_CcNode->h_KeysMatchTable,
+                                    i * p_CcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
 
-             i++;
+                    if (p_CcNode->ccKeySizeAccExtraction > 4)
+                    {
+                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                   0xff, p_CcNode->userSizeOfExtraction);
+                    }
+                    else
+                    {
+                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                   p_CcNode->p_GlblMask,
+                                   p_CcNode->userSizeOfExtraction);
+                    }
+                }
+            }
+
+            IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
+                       p_CcNode->ccKeySizeAccExtraction);
+
+            i++;
         }
     }
 
     /* Miss action descriptor */
-    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i * FM_PCD_CC_AD_ENTRY_SIZE);
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     if (!LIST_IsEmpty(&p_CcNode->ccTreesLst))
@@ -2639,25 +2786,27 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
             ASSERT_COND(p_CcNodeInformation->h_CcNode);
             /* Update the manipulation which has to be updated from parameters of the port */
             /* It's has to be updated with restrictions defined in the function */
-            err = SetRequiredAction(p_CcNode->h_FmPcd,
-                                    p_CcNode->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
-                                    &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                    PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                    1,
-                                    p_CcNodeInformation->h_CcNode);
+            err =
+                    SetRequiredAction(
+                            p_CcNode->h_FmPcd,
+                            p_CcNode->shadowAction
+                                    | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                            &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                            1, p_CcNodeInformation->h_CcNode);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-            err = CcUpdateParam(p_CcNode->h_FmPcd,
-                                NULL,
-                                NULL,
-                                &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                1,
-                                PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                TRUE,
-                                p_CcNodeInformation->index,
-                                p_CcNodeInformation->h_CcNode,
-                                TRUE);
+            err =
+                    CcUpdateParam(
+                            p_CcNode->h_FmPcd,
+                            NULL,
+                            NULL,
+                            &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                            1,
+                            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                            TRUE, p_CcNodeInformation->index,
+                            p_CcNodeInformation->h_CcNode, TRUE);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -2667,49 +2816,58 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
         memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
     if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC)
-        p_AdditionalInfo->h_NodeForAdd = p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
+        p_AdditionalInfo->h_NodeForAdd =
+                p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
     if (p_KeyParams->ccNextEngineParams.h_Manip)
-        p_AdditionalInfo->h_ManipForAdd = p_KeyParams->ccNextEngineParams.h_Manip;
+        p_AdditionalInfo->h_ManipForAdd =
+                p_KeyParams->ccNextEngineParams.h_Manip;
 
 #if (DPAA_VERSION >= 11)
-        if ((p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForAdd = p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic;
+    if ((p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_FR)
+            && (p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic))
+        p_AdditionalInfo->h_FrmReplicForAdd =
+                p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
     if (!add)
     {
-        if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            p_AdditionalInfo->h_NodeForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+        if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv =
+                    p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
 
         if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
-            p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+            p_AdditionalInfo->h_ManipForRmv =
+                    p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
         /* If statistics were previously enabled, store the old statistics object to be released */
         if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
         {
-            p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+            p_AdditionalInfo->p_StatsObjForRmv =
+                    p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
         }
 
 #if (DPAA_VERSION >= 11)
-        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
+            p_AdditionalInfo->h_FrmReplicForRmv =
+                    p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
     }
 
     return E_OK;
 }
 
-static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNode,
-                                     uint16_t                           keyIndex,
-                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeRemoveKey(
+        t_FmPcdCcNode *p_CcNode, uint16_t keyIndex,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    int         i = 0, j = 0;
-    t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
-    t_Handle    p_KeysMatchTableOldTmp, p_AdTableOldTmp;
-    int         size;
-    t_Error     err = E_OK;
+    int i = 0, j = 0;
+    t_Handle p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int size;
+    t_Error err = E_OK;
 
     /*save new numOfKeys*/
     p_AdditionalInfo->numOfKeys = (uint16_t)(p_CcNode->numOfKeys - 1);
@@ -2720,89 +2878,93 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNod
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*update new Ad and new Key Table according to new requirement*/
-    for (i=0, j=0; j<p_CcNode->numOfKeys; i++, j++)
+    for (i = 0, j = 0; j < p_CcNode->numOfKeys; i++, j++)
     {
         if (j == keyIndex)
         {
-            p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
+            p_AdTableOldTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
             j++;
         }
         if (j == p_CcNode->numOfKeys)
             break;
-        p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
-        p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableNewTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableOldTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
         IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j * size * sizeof(uint8_t));
-        p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i * size * sizeof(uint8_t));
-        IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, size * sizeof(uint8_t));
+        p_KeysMatchTableOldTmp =
+                PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j * size * sizeof(uint8_t));
+        p_KeysMatchTableNewTmp =
+                PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i * size * sizeof(uint8_t));
+        IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
+                   size * sizeof(uint8_t));
     }
 
-    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-    if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+    if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForRmv =
-            p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+                p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
 
     if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
         p_AdditionalInfo->h_ManipForRmv =
-            p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+                p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
     /* If statistics were previously enabled, store the old statistics object to be released */
     if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
     {
-        p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+        p_AdditionalInfo->p_StatsObjForRmv =
+                p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
     }
 
 #if (DPAA_VERSION >= 11)
-        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
-             p_AdditionalInfo->h_FrmReplicForRmv =
+    if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+            == e_FM_PCD_FR)
+            && (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
+        p_AdditionalInfo->h_FrmReplicForRmv =
                 p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
-   return E_OK;
+    return E_OK;
 }
 
-static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNode,
-                                     uint16_t                           keyIndex,
-                                     uint8_t                            *p_Key,
-                                     uint8_t                            *p_Mask,
-                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeModifyKey(
+        t_FmPcdCcNode *p_CcNode, uint16_t keyIndex, uint8_t *p_Key,
+        uint8_t *p_Mask, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
-    t_Error                 err = E_OK;
-    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
-    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
-    int                     size;
-    int                     i = 0, j = 0;
-    bool                    prvLclMask;
-    t_FmPcdStatsObj         *p_StatsObj, tmpStatsObj;
-    p_AdditionalInfo->numOfKeys =  p_CcNode->numOfKeys;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    t_Error err = E_OK;
+    t_Handle p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int size;
+    int i = 0, j = 0;
+    bool prvLclMask;
+    t_FmPcdStatsObj *p_StatsObj, tmpStatsObj;
+    p_AdditionalInfo->numOfKeys = p_CcNode->numOfKeys;
 
     prvLclMask = p_CcNode->lclMask;
 
     /* Check that new key is not require update of localMask */
-    err = UpdateGblMask(p_CcNode,
-                        p_CcNode->ccKeySizeAccExtraction,
-                        p_Mask);
+    err = UpdateGblMask(p_CcNode, p_CcNode->ccKeySizeAccExtraction, p_Mask);
     if (err)
         RETURN_ERROR(MAJOR, err, (NO_MSG));
 
     /* Update internal data structure with new next engine for the given index */
-    memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key,
-           p_Key,
+    memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key, p_Key,
            p_CcNode->userSizeOfExtraction);
 
     if (p_Mask)
-        memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
-               p_Mask,
+        memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask, p_Mask,
                p_CcNode->userSizeOfExtraction);
     else
-        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
-               0xFF,
+        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask, 0xFF,
                p_CcNode->userSizeOfExtraction);
 
     /*function which build in the memory new KeyTbl, AdTbl*/
@@ -2811,10 +2973,12 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*fill the New AdTable and New KeyTable*/
-    for (j=0, i=0; j<p_AdditionalInfo->numOfKeys; j++, i++)
+    for (j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
     {
-        p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
-        p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableNewTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableOldTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
 
         IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -2824,88 +2988,99 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
             if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
             {
                 /* As statistics were enabled, we need to update the existing
-                   statistics descriptor with a new nullified counters. */
+                 statistics descriptor with a new nullified counters. */
                 p_StatsObj = GetStatsObj(p_CcNode);
                 ASSERT_COND(p_StatsObj);
 
-                SetStatsCounters(p_AdTableNewTmp,
-                                 (uint32_t)((XX_VirtToPhys(p_StatsObj->h_StatsCounters) - p_FmPcd->physicalMuramBase)));
+                SetStatsCounters(
+                        p_AdTableNewTmp,
+                        (uint32_t)((XX_VirtToPhys(p_StatsObj->h_StatsCounters)
+                                - p_FmPcd->physicalMuramBase)));
 
                 tmpStatsObj.h_StatsAd = p_StatsObj->h_StatsAd;
                 tmpStatsObj.h_StatsCounters = p_StatsObj->h_StatsCounters;
 
                 /* As we need to replace only the counters, we build a new statistics
-                   object that holds the old AD and the new counters - this will be the
-                   currently used statistics object.
-                   The newly allocated AD is not required and may be released back to
-                   the available objects with the previous counters pointer. */
-                p_StatsObj->h_StatsAd = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
+                 object that holds the old AD and the new counters - this will be the
+                 currently used statistics object.
+                 The newly allocated AD is not required and may be released back to
+                 the available objects with the previous counters pointer. */
+                p_StatsObj->h_StatsAd =
+                        p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
 
-                p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd = tmpStatsObj.h_StatsAd;
+                p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd =
+                        tmpStatsObj.h_StatsAd;
 
                 /* Store allocated statistics object */
-                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj =
+                        p_StatsObj;
 
                 /* As statistics were previously enabled, store the old statistics object to be released */
-                p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+                p_AdditionalInfo->p_StatsObjForRmv =
+                        p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
             }
 
-            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
+            p_KeysMatchTableNewTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
 
-            Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key, p_CcNode->userSizeOfExtraction);
+            Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key,
+                        p_CcNode->userSizeOfExtraction);
 
             if (p_CcNode->lclMask)
             {
                 if (p_Mask)
                     Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                p_CcNode->ccKeySizeAccExtraction),
-                                p_Mask,
-                                p_CcNode->userSizeOfExtraction);
-                else if (p_CcNode->ccKeySizeAccExtraction > 4)
-                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                               p_CcNode->ccKeySizeAccExtraction),
-                               0xff,
-                               p_CcNode->userSizeOfExtraction);
+                            p_CcNode->ccKeySizeAccExtraction),
+                                p_Mask, p_CcNode->userSizeOfExtraction);
                 else
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                    if (p_CcNode->ccKeySizeAccExtraction > 4)
+                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
-                                p_CcNode->p_GlblMask,
-                                p_CcNode->userSizeOfExtraction);
+                                   0xff, p_CcNode->userSizeOfExtraction);
+                    else
+                        Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                    p_CcNode->p_GlblMask,
+                                    p_CcNode->userSizeOfExtraction);
             }
         }
         else
         {
-            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
-            p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i * size * sizeof(uint8_t));
+            p_KeysMatchTableNewTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp =
+                    PTR_MOVE(p_CcNode->h_KeysMatchTable, i * size * sizeof(uint8_t));
 
             if (p_CcNode->lclMask)
             {
                 if (prvLclMask)
-                    IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
-                               PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
-                               p_CcNode->userSizeOfExtraction);
+                    IO2IOCpy32(
+                            PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
+                            PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
+                            p_CcNode->userSizeOfExtraction);
                 else
                 {
-                    p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i * p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
+                    p_KeysMatchTableOldTmp =
+                            PTR_MOVE(p_CcNode->h_KeysMatchTable, i * p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
 
                     if (p_CcNode->ccKeySizeAccExtraction > 4)
                         IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                   p_CcNode->ccKeySizeAccExtraction),
-                                   0xff,
-                                   p_CcNode->userSizeOfExtraction);
+                                p_CcNode->ccKeySizeAccExtraction),
+                                   0xff, p_CcNode->userSizeOfExtraction);
                     else
-                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
-                                   p_CcNode->p_GlblMask,
-                                   p_CcNode->userSizeOfExtraction);
+                        IO2IOCpy32(
+                                PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
+                                p_CcNode->p_GlblMask,
+                                p_CcNode->userSizeOfExtraction);
                 }
             }
-            IO2IOCpy32((void*)p_KeysMatchTableNewTmp,
-                       p_KeysMatchTableOldTmp,
+            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
                        p_CcNode->ccKeySizeAccExtraction);
         }
     }
 
-    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
     p_AdTableOldTmp = PTR_MOVE(p_CcNode->h_AdTable, i * FM_PCD_CC_AD_ENTRY_SIZE);
 
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
@@ -2913,48 +3088,44 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
     return E_OK;
 }
 
-static t_Error BuildNewNodeModifyNextEngine(t_Handle                            h_FmPcd,
-                                            t_Handle                            h_FmPcdCcNodeOrTree,
-                                            uint16_t                            keyIndex,
-                                            t_FmPcdCcNextEngineParams           *p_CcNextEngineParams,
-                                            t_List                              *h_OldLst,
-                                            t_List                              *h_NewLst,
-                                            t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalInfo)
+static t_Error BuildNewNodeModifyNextEngine(
+        t_Handle h_FmPcd, t_Handle h_FmPcdCcNodeOrTree, uint16_t keyIndex,
+        t_FmPcdCcNextEngineParams *p_CcNextEngineParams, t_List *h_OldLst,
+        t_List *h_NewLst, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    t_Error                 err = E_OK;
-    uint32_t                requiredAction = 0;
-    t_List                  *p_Pos;
-    t_CcNodeInformation     *p_CcNodeInformation, ccNodeInfo;
-    t_Handle                p_Ad;
-    t_FmPcdCcNode           *p_FmPcdCcNode1 = NULL;
-    t_FmPcdCcTree           *p_FmPcdCcTree = NULL;
-    t_FmPcdStatsObj         *p_StatsObj;
-    t_FmPcdCcStatsParams    statsParams = {0};
+    t_Error err = E_OK;
+    uint32_t requiredAction = 0;
+    t_List *p_Pos;
+    t_CcNodeInformation *p_CcNodeInformation, ccNodeInfo;
+    t_Handle p_Ad;
+    t_FmPcdCcNode *p_FmPcdCcNode1 = NULL;
+    t_FmPcdCcTree *p_FmPcdCcTree = NULL;
+    t_FmPcdStatsObj *p_StatsObj;
+    t_FmPcdCcStatsParams statsParams = { 0 };
 
     ASSERT_COND(p_CcNextEngineParams);
 
     /* check that new NIA is legal */
     if (!p_AdditionalInfo->tree)
-        err = ValidateNextEngineParams(h_FmPcd,
-                                       p_CcNextEngineParams,
-                                       ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->statisticsMode);
+        err = ValidateNextEngineParams(
+                h_FmPcd, p_CcNextEngineParams,
+                ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->statisticsMode);
     else
         /* Statistics are not supported for CC root */
-        err = ValidateNextEngineParams(h_FmPcd,
-                                       p_CcNextEngineParams,
+        err = ValidateNextEngineParams(h_FmPcd, p_CcNextEngineParams,
                                        e_FM_PCD_CC_STATS_MODE_NONE);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* Update internal data structure for next engine per index (index - key) */
     memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,
-           p_CcNextEngineParams,
-           sizeof(t_FmPcdCcNextEngineParams));
+           p_CcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
 
     /* Check that manip is legal and what requiredAction is necessary for this manip */
     if (p_CcNextEngineParams->h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEngine(p_CcNextEngineParams, &requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(p_CcNextEngineParams,
+                                                   &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -2962,19 +3133,24 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (!p_AdditionalInfo->tree)
     {
         p_FmPcdCcNode1 = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
-        p_AdditionalInfo->numOfKeys =  p_FmPcdCcNode1->numOfKeys;
+        p_AdditionalInfo->numOfKeys = p_FmPcdCcNode1->numOfKeys;
         p_Ad = p_FmPcdCcNode1->h_AdTable;
 
-        if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+        if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv =
+                    p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
 
         if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
-            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+            p_AdditionalInfo->h_ManipForRmv =
+                    p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
 #if (DPAA_VERSION >= 11)
-        if ((p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+        if ((p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
+            p_AdditionalInfo->h_FrmReplicForRmv =
+                    p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
     }
     else
@@ -2982,23 +3158,29 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
         p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
         p_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-        if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+        if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv =
+                    p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
 
         if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
-            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+            p_AdditionalInfo->h_ManipForRmv =
+                    p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
 #if (DPAA_VERSION >= 11)
-        if ((p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+        if ((p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
+            p_AdditionalInfo->h_FrmReplicForRmv =
+                    p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
     }
 
     if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
-        && p_CcNextEngineParams->h_Manip)
+            && p_CcNextEngineParams->h_Manip)
     {
-        err = AllocAndFillAdForContLookupManip(p_CcNextEngineParams->params.ccParams.h_CcNode);
+        err = AllocAndFillAdForContLookupManip(
+                p_CcNextEngineParams->params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3009,57 +3191,57 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     ccNodeInfo.h_CcNode = PTR_MOVE(p_Ad, keyIndex * FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* If statistics were enabled, this Ad is the statistics Ad. Need to follow its
-       nextAction to retrieve the actual Nia-Ad. If statistics should remain enabled,
-       only the actual Nia-Ad should be modified. */
-    if ((!p_AdditionalInfo->tree) &&
-        (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
-        (p_CcNextEngineParams->statisticsEn))
-        ccNodeInfo.h_CcNode = ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
+     nextAction to retrieve the actual Nia-Ad. If statistics should remain enabled,
+     only the actual Nia-Ad should be modified. */
+    if ((!p_AdditionalInfo->tree)
+            && (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj)
+            && (p_CcNextEngineParams->statisticsEn))
+        ccNodeInfo.h_CcNode =
+                ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
 
     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
     p_Ad = GetNewAd(h_FmPcdCcNodeOrTree, p_AdditionalInfo->tree);
     if (!p_Ad)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptor"));
-    IOMemSet32((uint8_t *)p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM allocation for CC node action descriptor"));
+    IOMemSet32((uint8_t *)p_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* If statistics were not enabled before, but requested now -  Allocate a statistics
-       object that holds statistics AD and counters. */
-    if ((!p_AdditionalInfo->tree) &&
-        (!((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
-        (p_CcNextEngineParams->statisticsEn))
+     object that holds statistics AD and counters. */
+    if ((!p_AdditionalInfo->tree)
+            && (!((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj)
+            && (p_CcNextEngineParams->statisticsEn))
     {
         p_StatsObj = GetStatsObj((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree);
         ASSERT_COND(p_StatsObj);
 
         /* Store allocated statistics object */
-        p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+        p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj =
+                p_StatsObj;
 
         statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
         statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
 
 #if (DPAA_VERSION >= 11)
-        statsParams.h_StatsFLRs = ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_StatsFLRs;
+        statsParams.h_StatsFLRs =
+                ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_StatsFLRs;
 
 #endif /* (DPAA_VERSION >= 11) */
 
-        NextStepAd(p_Ad,
-                   &statsParams,
-                   p_CcNextEngineParams,
-                   h_FmPcd);
+        NextStepAd(p_Ad, &statsParams, p_CcNextEngineParams, h_FmPcd);
     }
     else
-        NextStepAd(p_Ad,
-                   NULL,
-                   p_CcNextEngineParams,
-                   h_FmPcd);
+        NextStepAd(p_Ad, NULL, p_CcNextEngineParams, h_FmPcd);
 
     ccNodeInfo.h_CcNode = p_Ad;
     EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo, NULL);
 
-    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction = requiredAction;
-    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction =
+            requiredAction;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |=
+            UPDATE_CC_WITH_TREE;
 
     if (!p_AdditionalInfo->tree)
     {
@@ -3072,27 +3254,23 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
 
                 ASSERT_COND(p_CcNodeInformation->h_CcNode);
                 /* Update the manipulation which has to be updated from parameters of the port
-                   it's has to be updated with restrictions defined in the function */
-
-                err = SetRequiredAction(p_FmPcdCcNode1->h_FmPcd,
-                                        p_FmPcdCcNode1->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
-                                        &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                        p_Ad,
-                                        1,
-                                        p_CcNodeInformation->h_CcNode);
+                 it's has to be updated with restrictions defined in the function */
+
+                err =
+                        SetRequiredAction(
+                                p_FmPcdCcNode1->h_FmPcd,
+                                p_FmPcdCcNode1->shadowAction
+                                        | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                                &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                p_Ad, 1, p_CcNodeInformation->h_CcNode);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-                err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd,
-                                    NULL,
-                                    NULL,
-                                    &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                    1,
-                                    p_Ad,
-                                    TRUE,
-                                    p_CcNodeInformation->index,
-                                    p_CcNodeInformation->h_CcNode,
-                                    TRUE);
+                err = CcUpdateParam(
+                        p_FmPcdCcNode1->h_FmPcd, NULL, NULL,
+                        &p_AdditionalInfo->keyAndNextEngineParams[keyIndex], 1,
+                        p_Ad, TRUE, p_CcNodeInformation->index,
+                        p_CcNodeInformation->h_CcNode, TRUE);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
             }
@@ -3100,40 +3278,36 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     }
     else
     {
-       ASSERT_COND(p_FmPcdCcTree);
+        ASSERT_COND(p_FmPcdCcTree);
 
-       err = SetRequiredAction(h_FmPcd,
-                               p_FmPcdCcTree->requiredAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
-                               &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                               p_Ad,
-                               1,
-                               (t_Handle)p_FmPcdCcTree);
+        err =
+                SetRequiredAction(
+                        h_FmPcd,
+                        p_FmPcdCcTree->requiredAction
+                                | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                        &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                        p_Ad, 1, (t_Handle)p_FmPcdCcTree);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-        err = CcUpdateParam(h_FmPcd,
-                            NULL,
-                            NULL,
+        err = CcUpdateParam(h_FmPcd, NULL, NULL,
                             &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                            1,
-                            p_Ad,
-                            TRUE,
-                            0,
-                            (t_Handle)p_FmPcdCcTree, TRUE);
+                            1, p_Ad, TRUE, 0, (t_Handle)p_FmPcdCcTree, TRUE);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
     if (p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
-        p_AdditionalInfo->h_NodeForAdd = p_CcNextEngineParams->params.ccParams.h_CcNode;
+        p_AdditionalInfo->h_NodeForAdd =
+                p_CcNextEngineParams->params.ccParams.h_CcNode;
     if (p_CcNextEngineParams->h_Manip)
         p_AdditionalInfo->h_ManipForAdd = p_CcNextEngineParams->h_Manip;
 
     /* If statistics were previously enabled, but now are disabled,
-       store the old statistics object to be released */
-    if ((!p_AdditionalInfo->tree) &&
-         (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
-         (!p_CcNextEngineParams->statisticsEn))
+     store the old statistics object to be released */
+    if ((!p_AdditionalInfo->tree)
+            && (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj)
+            && (!p_CcNextEngineParams->statisticsEn))
     {
         p_AdditionalInfo->p_StatsObjForRmv =
                 ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj;
@@ -3142,54 +3316,60 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
         p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = NULL;
     }
 #if (DPAA_VERSION >= 11)
-        if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
-            (p_CcNextEngineParams->params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForAdd = p_CcNextEngineParams->params.frParams.h_FrmReplic;
+    if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_FR)
+            && (p_CcNextEngineParams->params.frParams.h_FrmReplic))
+        p_AdditionalInfo->h_FrmReplicForAdd =
+                p_CcNextEngineParams->params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
     return E_OK;
 }
 
-static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode                *p_CrntMdfNode,
-                                                       t_List                       *h_OldLst,
-                                                       t_FmPcdCcNextEngineParams    **p_NextEngineParams)
+static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(
+        t_FmPcdCcNode *p_CrntMdfNode, t_List *h_OldLst,
+        t_FmPcdCcNextEngineParams **p_NextEngineParams)
 {
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfNode = NULL;
-    t_List                  *p_Pos;
-    int                     i = 0;
-    t_Handle                p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
-    t_CcNodeInformation     ccNodeInfo;
+    t_CcNodeInformation *p_CcNodeInformation;
+    t_FmPcdCcNode *p_NodePtrOnCurrentMdfNode = NULL;
+    t_List *p_Pos;
+    int i = 0;
+    t_Handle p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
+    t_CcNodeInformation ccNodeInfo;
 
     LIST_FOR_EACH(p_Pos, &p_CrntMdfNode->ccPrevNodesLst)
     {
         p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        p_NodePtrOnCurrentMdfNode = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
+        p_NodePtrOnCurrentMdfNode =
+                (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
 
         ASSERT_COND(p_NodePtrOnCurrentMdfNode);
 
         /* Search in the previous node which exact index points on this current modified node for getting AD */
         for (i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
         {
-            if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
             {
-                if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode
+                        == (t_Handle)p_CrntMdfNode)
                 {
                     if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
                         p_AdTablePtOnCrntCurrentMdfNode = p_CrntMdfNode->h_Ad;
-                    else if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj)
-                        p_AdTablePtOnCrntCurrentMdfNode =
-                                p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj->h_StatsAd;
                     else
-                        p_AdTablePtOnCrntCurrentMdfNode =
-                                PTR_MOVE(p_NodePtrOnCurrentMdfNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+                        if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj)
+                            p_AdTablePtOnCrntCurrentMdfNode =
+                                    p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj->h_StatsAd;
+                        else
+                            p_AdTablePtOnCrntCurrentMdfNode =
+                                    PTR_MOVE(p_NodePtrOnCurrentMdfNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
 
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
                     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
                     if (!(*p_NextEngineParams))
-                        *p_NextEngineParams = &p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
+                        *p_NextEngineParams =
+                                &p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
                 }
             }
         }
@@ -3198,38 +3378,43 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
     }
 }
 
-static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode                *p_CrntMdfNode,
-                                                       t_List                       *h_OldLst,
-                                                       t_FmPcdCcNextEngineParams    **p_NextEngineParams)
+static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(
+        t_FmPcdCcNode *p_CrntMdfNode, t_List *h_OldLst,
+        t_FmPcdCcNextEngineParams **p_NextEngineParams)
 {
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcTree           *p_TreePtrOnCurrentMdfNode = NULL;
-    t_List                  *p_Pos;
-    int                     i = 0;
-    t_Handle                p_AdTableTmp;
-    t_CcNodeInformation     ccNodeInfo;
+    t_CcNodeInformation *p_CcNodeInformation;
+    t_FmPcdCcTree *p_TreePtrOnCurrentMdfNode = NULL;
+    t_List *p_Pos;
+    int i = 0;
+    t_Handle p_AdTableTmp;
+    t_CcNodeInformation ccNodeInfo;
 
     LIST_FOR_EACH(p_Pos, &p_CrntMdfNode->ccTreeIdLst)
     {
         p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        p_TreePtrOnCurrentMdfNode = (t_FmPcdCcTree *)p_CcNodeInformation->h_CcNode;
+        p_TreePtrOnCurrentMdfNode =
+                (t_FmPcdCcTree *)p_CcNodeInformation->h_CcNode;
 
         ASSERT_COND(p_TreePtrOnCurrentMdfNode);
 
         /*search in the trees which exact index points on this current modified node for getting AD */
         for (i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
         {
-            if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
             {
-                if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode
+                        == (t_Handle)p_CrntMdfNode)
                 {
-                    p_AdTableTmp = UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
+                    p_AdTableTmp =
+                            UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTableTmp;
                     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
                     if (!(*p_NextEngineParams))
-                        *p_NextEngineParams = &p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
+                        *p_NextEngineParams =
+                                &p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
                 }
             }
         }
@@ -3238,20 +3423,17 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
     }
 }
 
-static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle        h_FmPcdCcNodeOrTree,
-                                                                 uint16_t        keyIndex,
-                                                                 e_ModifyState   modifyState,
-                                                                 bool            ttlCheck,
-                                                                 bool            hashCheck,
-                                                                 bool            tree)
+static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(
+        t_Handle h_FmPcdCcNodeOrTree, uint16_t keyIndex,
+        e_ModifyState modifyState, bool ttlCheck, bool hashCheck, bool tree)
 {
-    t_FmPcdModifyCcKeyAdditionalParams  *p_FmPcdModifyCcKeyAdditionalParams;
-    int                                 i = 0, j = 0;
-    bool                                wasUpdate = FALSE;
-    t_FmPcdCcNode                       *p_CcNode = NULL;
-    t_FmPcdCcTree                       *p_FmPcdCcTree;
-    uint16_t                            numOfKeys;
-    t_FmPcdCcKeyAndNextEngineParams     *p_KeyAndNextEngineParams;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+    int i = 0, j = 0;
+    bool wasUpdate = FALSE;
+    t_FmPcdCcNode *p_CcNode = NULL;
+    t_FmPcdCcTree *p_FmPcdCcTree;
+    uint16_t numOfKeys;
+    t_FmPcdCcKeyAndNextEngineParams *p_KeyAndNextEngineParams;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcdCcNodeOrTree, E_INVALID_HANDLE, NULL);
 
@@ -3261,22 +3443,21 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
         numOfKeys = p_CcNode->numOfKeys;
 
         /* node has to be pointed by another node or tree */
-       
- 
-        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*(numOfKeys+1));
+
+        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(
+                sizeof(t_FmPcdCcKeyAndNextEngineParams) * (numOfKeys + 1));
         if (!p_KeyAndNextEngineParams)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Next engine and required action structure"));
             return NULL;
         }
-        memcpy(p_KeyAndNextEngineParams,
-               p_CcNode->keyAndNextEngineParams,
-               (numOfKeys+1) * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+        memcpy(p_KeyAndNextEngineParams, p_CcNode->keyAndNextEngineParams,
+               (numOfKeys + 1) * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
         if (ttlCheck)
         {
-            if ((p_CcNode->parseCode == CC_PC_FF_IPV4TTL) ||
-               (p_CcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT))
+            if ((p_CcNode->parseCode == CC_PC_FF_IPV4TTL)
+                    || (p_CcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT))
             {
                 XX_Free(p_KeyAndNextEngineParams);
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for this operation"));
@@ -3299,7 +3480,9 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
         p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
         numOfKeys = p_FmPcdCcTree->numOfEntries;
 
-        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*FM_PCD_MAX_NUM_OF_CC_GROUPS);
+        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(
+                sizeof(t_FmPcdCcKeyAndNextEngineParams)
+                        * FM_PCD_MAX_NUM_OF_CC_GROUPS);
         if (!p_KeyAndNextEngineParams)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Next engine and required action structure"));
@@ -3307,18 +3490,21 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
         }
         memcpy(p_KeyAndNextEngineParams,
                p_FmPcdCcTree->keyAndNextEngineParams,
-               FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+               FM_PCD_MAX_NUM_OF_CC_GROUPS
+                       * sizeof(t_FmPcdCcKeyAndNextEngineParams));
     }
 
     p_FmPcdModifyCcKeyAdditionalParams =
-        (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+            (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(
+                    sizeof(t_FmPcdModifyCcKeyAdditionalParams));
     if (!p_FmPcdModifyCcKeyAdditionalParams)
     {
         XX_Free(p_KeyAndNextEngineParams);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of internal data structure FAILED"));
         return NULL;
     }
-    memset(p_FmPcdModifyCcKeyAdditionalParams, 0, sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+    memset(p_FmPcdModifyCcKeyAdditionalParams, 0,
+           sizeof(t_FmPcdModifyCcKeyAdditionalParams));
 
     p_FmPcdModifyCcKeyAdditionalParams->h_CurrentNode = h_FmPcdCcNodeOrTree;
     p_FmPcdModifyCcKeyAdditionalParams->savedKeyIndex = keyIndex;
@@ -3329,8 +3515,9 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
         {
             if (modifyState == e_MODIFY_STATE_ADD)
                 j++;
-            else if (modifyState == e_MODIFY_STATE_REMOVE)
-                i++;
+            else
+                if (modifyState == e_MODIFY_STATE_REMOVE)
+                    i++;
             wasUpdate = TRUE;
         }
         else
@@ -3347,8 +3534,9 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
     {
         if (modifyState == e_MODIFY_STATE_ADD)
             j++;
-        else if (modifyState == e_MODIFY_STATE_REMOVE)
-            i++;
+        else
+            if (modifyState == e_MODIFY_STATE_REMOVE)
+                i++;
     }
 
     memcpy(&p_FmPcdModifyCcKeyAdditionalParams->keyAndNextEngineParams[j],
@@ -3360,39 +3548,39 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
     return p_FmPcdModifyCcKeyAdditionalParams;
 }
 
-static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode                       *p_CcNode,
-                                                t_FmPcdModifyCcKeyAdditionalParams  *p_FmPcdModifyCcKeyAdditionalParams,
-                                                t_List                              *h_OldLst,
-                                                t_List                              *h_NewLst)
+static t_Error UpdatePtrWhichPointOnCrntMdfNode(
+        t_FmPcdCcNode *p_CcNode,
+        t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams,
+        t_List *h_OldLst, t_List *h_NewLst)
 {
-    t_FmPcdCcNextEngineParams   *p_NextEngineParams = NULL;
-    t_CcNodeInformation         ccNodeInfo = {0};
-    t_Handle                    h_NewAd;
+    t_FmPcdCcNextEngineParams *p_NextEngineParams = NULL;
+    t_CcNodeInformation ccNodeInfo = { 0 };
+    t_Handle h_NewAd;
 
     /* Building a list of all action descriptors that point to the previous node */
     if (!LIST_IsEmpty(&p_CcNode->ccPrevNodesLst))
-        UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
+        UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst,
+                                                   &p_NextEngineParams);
 
     if (!LIST_IsEmpty(&p_CcNode->ccTreeIdLst))
-        UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
+        UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst,
+                                                   &p_NextEngineParams);
 
     /* This node must be found as next engine of one of its previous nodes or trees*/
-    if(p_NextEngineParams) 
+    if (p_NextEngineParams)
     {
-    	
-	    /* Building a new action descriptor that points to the modified node */
-	    h_NewAd = GetNewAd(p_CcNode, FALSE);
-	    if (!h_NewAd)
-	        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-	    IOMemSet32(h_NewAd, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
-	    BuildNewAd(h_NewAd,
-	               p_FmPcdModifyCcKeyAdditionalParams,
-	               p_CcNode,
-	               p_NextEngineParams);
+        /* Building a new action descriptor that points to the modified node */
+        h_NewAd = GetNewAd(p_CcNode, FALSE);
+        if (!h_NewAd)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        IOMemSet32(h_NewAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+        BuildNewAd(h_NewAd, p_FmPcdModifyCcKeyAdditionalParams, p_CcNode,
+                   p_NextEngineParams);
 
-	    ccNodeInfo.h_CcNode = h_NewAd;
-	    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo, NULL);
+        ccNodeInfo.h_CcNode = h_NewAd;
+        EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo, NULL);
     }
     return E_OK;
 }
@@ -3404,7 +3592,7 @@ static void UpdateCcRootOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
     /* this routine must be protected by the calling routine! */
 
     if (add)
-       p_FmPcdCcTree->owners++;
+        p_FmPcdCcTree->owners++;
     else
     {
         ASSERT_COND(p_FmPcdCcTree->owners);
@@ -3415,14 +3603,16 @@ static void UpdateCcRootOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
 static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
 {
     t_Error err = E_OK;
-    int     i = 0;
+    int i = 0;
 
     for (i = 0; i < p_CcNode->numOfKeys; i++)
     {
         if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
         {
-            err = FmPcdManipCheckParamsWithCcNodeParams(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
-                                                        (t_Handle)p_CcNode);
+            err =
+                    FmPcdManipCheckParamsWithCcNodeParams(
+                            p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                            (t_Handle)p_CcNode);
             if (err)
                 return err;
         }
@@ -3430,13 +3620,13 @@ static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
 
     return err;
 }
-static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode        *p_CcNode,
-                                          t_FmPcdCcNodeParams  *p_CcNodeParam,
-                                          uint32_t             *p_NumOfRanges,
-                                          uint32_t             *p_CountersArraySize)
+static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode *p_CcNode,
+                                          t_FmPcdCcNodeParams *p_CcNodeParam,
+                                          uint32_t *p_NumOfRanges,
+                                          uint32_t *p_CountersArraySize)
 {
-    e_FmPcdCcStatsMode  statisticsMode = p_CcNode->statisticsMode;
-    uint32_t            i;
+    e_FmPcdCcStatsMode statisticsMode = p_CcNode->statisticsMode;
+    uint32_t i;
 
     UNUSED(p_CcNodeParam);
 
@@ -3445,8 +3635,10 @@ static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode        *p_CcNode,
         case e_FM_PCD_CC_STATS_MODE_NONE:
             for (i = 0; i < p_CcNode->numOfKeys; i++)
                 if (p_CcNodeParam->keysParams.keyParams[i].ccNextEngineParams.statisticsEn)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                                 ("Statistics cannot be enabled for key %d when statistics mode was set to 'NONE'", i));
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_VALUE,
+                            ("Statistics cannot be enabled for key %d when statistics mode was set to 'NONE'", i));
             return E_OK;
 
         case e_FM_PCD_CC_STATS_MODE_FRAME:
@@ -3457,42 +3649,47 @@ static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode        *p_CcNode,
 
 #if (DPAA_VERSION >= 11)
         case e_FM_PCD_CC_STATS_MODE_RMON:
-            {
-                uint16_t    *p_FrameLengthRanges = p_CcNodeParam->keysParams.frameLengthRanges;
-                uint32_t    i;
-
-                if (p_FrameLengthRanges[0] <= 0)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
+        {
+            uint16_t *p_FrameLengthRanges =
+                    p_CcNodeParam->keysParams.frameLengthRanges;
+            uint32_t i;
 
-                if (p_FrameLengthRanges[0] == 0xFFFF)
-                {
-                    *p_NumOfRanges = 1;
-                    *p_CountersArraySize = 2 * FM_PCD_CC_STATS_COUNTER_SIZE;
-                    return E_OK;
-                }
+            if (p_FrameLengthRanges[0] <= 0)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
 
-                for (i = 1; i < FM_PCD_CC_STATS_MAX_NUM_OF_FLR; i++)
-                {
-                    if (p_FrameLengthRanges[i-1] >= p_FrameLengthRanges[i])
-                        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                                     ("Frame length range must be larger at least by 1 from preceding range"));
+            if (p_FrameLengthRanges[0] == 0xFFFF)
+            {
+                *p_NumOfRanges = 1;
+                *p_CountersArraySize = 2 * FM_PCD_CC_STATS_COUNTER_SIZE;
+                return E_OK;
+            }
 
-                    /* Stop when last range is reached */
-                    if (p_FrameLengthRanges[i] == 0xFFFF)
-                        break;
-                }
+            for (i = 1; i < FM_PCD_CC_STATS_MAX_NUM_OF_FLR; i++)
+            {
+                if (p_FrameLengthRanges[i - 1] >= p_FrameLengthRanges[i])
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_VALUE,
+                            ("Frame length range must be larger at least by 1 from preceding range"));
+
+                /* Stop when last range is reached */
+                if (p_FrameLengthRanges[i] == 0xFFFF)
+                    break;
+            }
 
-                if ((i >= FM_PCD_CC_STATS_MAX_NUM_OF_FLR) ||
-                    (p_FrameLengthRanges[i] != 0xFFFF))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Last Frame length range must be 0xFFFF"));
+            if ((i >= FM_PCD_CC_STATS_MAX_NUM_OF_FLR)
+                    || (p_FrameLengthRanges[i] != 0xFFFF))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                             ("Last Frame length range must be 0xFFFF"));
 
-                *p_NumOfRanges = i+1;
+            *p_NumOfRanges = i + 1;
 
-                /* Allocate an extra counter for byte count, as counters
-                   array always begins with byte count */
-                *p_CountersArraySize = (*p_NumOfRanges + 1) * FM_PCD_CC_STATS_COUNTER_SIZE;
+            /* Allocate an extra counter for byte count, as counters
+             array always begins with byte count */
+            *p_CountersArraySize = (*p_NumOfRanges + 1)
+                    * FM_PCD_CC_STATS_COUNTER_SIZE;
 
-            }
+        }
             return E_OK;
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -3501,34 +3698,34 @@ static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode        *p_CcNode,
     }
 }
 
-static t_Error CheckParams(t_Handle             h_FmPcd,
-                           t_FmPcdCcNodeParams  *p_CcNodeParam,
-                           t_FmPcdCcNode        *p_CcNode,
-                           bool                 *isKeyTblAlloc)
+static t_Error CheckParams(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam,
+                           t_FmPcdCcNode *p_CcNode, bool *isKeyTblAlloc)
 {
-    int                     tmp = 0;
-    t_FmPcdCcKeyParams      *p_KeyParams;
-    t_Error                 err;
-    uint32_t                requiredAction = 0;
+    int tmp = 0;
+    t_FmPcdCcKeyParams *p_KeyParams;
+    t_Error err;
+    uint32_t requiredAction = 0;
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNode,
-                                     p_CcNodeParam,
+    err = ValidateAndCalcStatsParams(p_CcNode, p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
     if (err)
         RETURN_ERROR(MAJOR, err, ("Invalid statistics parameters"));
 
     /* Validate next engine parameters on Miss */
-    err = ValidateNextEngineParams(h_FmPcd,
-                                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
-                                   p_CcNode->statisticsMode);
+    err = ValidateNextEngineParams(
+            h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+            p_CcNode->statisticsMode);
     if (err)
-        RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
+        RETURN_ERROR(MAJOR, err,
+                     ("For this node MissNextEngineParams are not valid"));
 
     if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEngine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(
+                &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3537,12 +3734,16 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
            &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
            sizeof(t_FmPcdCcNextEngineParams));
 
-    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction = requiredAction;
+    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction =
+            requiredAction;
 
-    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
+    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
+            && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
     {
-        err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
+        err =
+                AllocAndFillAdForContLookupManip(
+                        p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3560,29 +3761,28 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-        err = UpdateGblMask(p_CcNode,
-                            p_CcNodeParam->keysParams.keySize,
+        err = UpdateGblMask(p_CcNode, p_CcNodeParam->keysParams.keySize,
                             p_KeyParams->p_Mask);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
         if (p_KeyParams->ccNextEngineParams.h_Manip)
         {
-            err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+            err = FmPcdManipCheckParamsForCcNextEngine(
+                    &p_KeyParams->ccNextEngineParams, &requiredAction);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
 
         /* Store 'key' parameters - key, mask (if passed by the user) */
-        memcpy(p_CcNode->keyAndNextEngineParams[tmp].key, p_KeyParams->p_Key, p_CcNodeParam->keysParams.keySize);
+        memcpy(p_CcNode->keyAndNextEngineParams[tmp].key, p_KeyParams->p_Key,
+               p_CcNodeParam->keysParams.keySize);
 
         if (p_KeyParams->p_Mask)
             memcpy(p_CcNode->keyAndNextEngineParams[tmp].mask,
-                   p_KeyParams->p_Mask,
-                   p_CcNodeParam->keysParams.keySize);
+                   p_KeyParams->p_Mask, p_CcNodeParam->keysParams.keySize);
         else
-            memset((void *)(p_CcNode->keyAndNextEngineParams[tmp].mask),
-                   0xFF,
+            memset((void *)(p_CcNode->keyAndNextEngineParams[tmp].mask), 0xFF,
                    p_CcNodeParam->keysParams.keySize);
 
         /* Store next engine parameters */
@@ -3592,10 +3792,13 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
 
         p_CcNode->keyAndNextEngineParams[tmp].requiredAction = requiredAction;
 
-        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+                && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
         {
-            err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+            err =
+                    AllocAndFillAdForContLookupManip(
+                            p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -3604,7 +3807,10 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     if (p_CcNode->maxNumOfKeys)
     {
         if (p_CcNode->maxNumOfKeys < p_CcNode->numOfKeys)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Number of keys exceed the provided maximal number of keys"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("Number of keys exceed the provided maximal number of keys"));
     }
 
     *isKeyTblAlloc = TRUE;
@@ -3612,40 +3818,48 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     return E_OK;
 }
 
-static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
-                                                t_FmPcdCcNodeParams *p_CcNodeParam,
-                                                t_FmPcdCcNode       *p_CcNode,
-                                                bool                *isKeyTblAlloc)
+static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(
+        t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam,
+        t_FmPcdCcNode *p_CcNode, bool *isKeyTblAlloc)
 {
-    int                 tmp = 0;
-    t_FmPcdCcKeyParams  *p_KeyParams;
-    t_Error             err;
-    uint8_t             key = 0x01;
-    uint32_t            requiredAction = 0;
+    int tmp = 0;
+    t_FmPcdCcKeyParams *p_KeyParams;
+    t_Error err;
+    uint8_t key = 0x01;
+    uint32_t requiredAction = 0;
 
     if (p_CcNode->numOfKeys != 1)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'numOfKeys' is 1"));
-
-    if ((p_CcNodeParam->keysParams.maxNumOfKeys) && (p_CcNodeParam->keysParams.maxNumOfKeys != 1))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'numOfKeys' is 1"));
+
+    if ((p_CcNodeParam->keysParams.maxNumOfKeys)
+            && (p_CcNodeParam->keysParams.maxNumOfKeys != 1))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"));
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNode,
-                                     p_CcNodeParam,
+    err = ValidateAndCalcStatsParams(p_CcNode, p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
     if (err)
         RETURN_ERROR(MAJOR, err, ("Invalid statistics parameters"));
 
-    err = ValidateNextEngineParams(h_FmPcd,
-                                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
-                                   p_CcNodeParam->keysParams.statisticsMode);
+    err = ValidateNextEngineParams(
+            h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+            p_CcNodeParam->keysParams.statisticsMode);
     if (err)
-        RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
+        RETURN_ERROR(MAJOR, err,
+                     ("For this node MissNextEngineParams are not valid"));
 
     if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEngine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(
+                &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3654,12 +3868,16 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
            &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
            sizeof(t_FmPcdCcNextEngineParams));
 
-    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction = requiredAction;
+    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction =
+            requiredAction;
 
-    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
+    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
+            && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
     {
-        err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
+        err =
+                AllocAndFillAdForContLookupManip(
+                        p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3669,10 +3887,16 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
         if (p_KeyParams->p_Mask)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Mask can not be initialized"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Mask can not be initialized"));
 
         if (memcmp(p_KeyParams->p_Key, &key, 1) != 0)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"));
 
         err = ValidateNextEngineParams(h_FmPcd,
                                        &p_KeyParams->ccNextEngineParams,
@@ -3682,13 +3906,14 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
 
         if (p_KeyParams->ccNextEngineParams.h_Manip)
         {
-            err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+            err = FmPcdManipCheckParamsForCcNextEngine(
+                    &p_KeyParams->ccNextEngineParams, &requiredAction);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
 
         /* Store 'key' parameters - key (fixed to 0x01), key size of 1 byte and full mask */
-        p_CcNode->keyAndNextEngineParams[tmp].key[0]  = key;
+        p_CcNode->keyAndNextEngineParams[tmp].key[0] = key;
         p_CcNode->keyAndNextEngineParams[tmp].mask[0] = 0xFF;
 
         /* Store NextEngine parameters */
@@ -3696,10 +3921,13 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
                &p_KeyParams->ccNextEngineParams,
                sizeof(t_FmPcdCcNextEngineParams));
 
-        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+                && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
         {
-            err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+            err =
+                    AllocAndFillAdForContLookupManip(
+                            p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -3711,20 +3939,21 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
     return E_OK;
 }
 
-static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
+static t_Error IcHashIndexedCheckParams(t_Handle h_FmPcd,
                                         t_FmPcdCcNodeParams *p_CcNodeParam,
-                                        t_FmPcdCcNode       *p_CcNode,
-                                        bool                *isKeyTblAlloc)
+                                        t_FmPcdCcNode *p_CcNode,
+                                        bool *isKeyTblAlloc)
 {
-    int                 tmp = 0, countOnes = 0;
-    t_FmPcdCcKeyParams  *p_KeyParams;
-    t_Error             err;
-    uint16_t            glblMask = p_CcNodeParam->extractCcParams.extractNonHdr.icIndxMask;
-    uint16_t            countMask = (uint16_t)(glblMask >> 4);
-    uint32_t            requiredAction = 0;
+    int tmp = 0, countOnes = 0;
+    t_FmPcdCcKeyParams *p_KeyParams;
+    t_Error err;
+    uint16_t glblMask = p_CcNodeParam->extractCcParams.extractNonHdr.icIndxMask;
+    uint16_t countMask = (uint16_t)(glblMask >> 4);
+    uint32_t requiredAction = 0;
 
     if (glblMask & 0x000f)
-       RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("icIndxMask has to be with last nibble 0"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("icIndxMask has to be with last nibble 0"));
 
     while (countMask)
     {
@@ -3733,35 +3962,49 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     }
 
     if (!POWER_OF_2(p_CcNode->numOfKeys))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED numOfKeys has to be powerOfTwo"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For Node of the type INDEXED numOfKeys has to be powerOfTwo"));
 
     if (p_CcNode->numOfKeys != ((uint32_t)1 << countOnes))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"));
-
-    if (p_CcNodeParam->keysParams.maxNumOfKeys &&
-        (p_CcNodeParam->keysParams.maxNumOfKeys != p_CcNode->numOfKeys))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"));
+
+    if (p_CcNodeParam->keysParams.maxNumOfKeys
+            && (p_CcNodeParam->keysParams.maxNumOfKeys != p_CcNode->numOfKeys))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNode,
-                                     p_CcNodeParam,
+    err = ValidateAndCalcStatsParams(p_CcNode, p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
     if (err)
         RETURN_ERROR(MAJOR, err, ("Invalid statistics parameters"));
 
-    err = ValidateNextEngineParams(h_FmPcd,
-                                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
-                                   p_CcNode->statisticsMode);
-    if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
-        RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
+    err = ValidateNextEngineParams(
+            h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+            p_CcNode->statisticsMode);
+    if (GET_ERROR_TYPE(err) != E_NOT_SUPPORTED)
+        RETURN_ERROR(
+                MAJOR,
+                err,
+                ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
 
     for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
         if (p_KeyParams->p_Mask || p_KeyParams->p_Key)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
 
         if ((glblMask & (tmp * 16)) == (tmp * 16))
         {
@@ -3769,24 +4012,32 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
                                            &p_KeyParams->ccNextEngineParams,
                                            p_CcNode->statisticsMode);
             if (err)
-                RETURN_ERROR(MAJOR, err, ("This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "));
+                RETURN_ERROR(
+                        MAJOR,
+                        err,
+                        ("This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "));
 
             if (p_KeyParams->ccNextEngineParams.h_Manip)
             {
-                err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+                err = FmPcdManipCheckParamsForCcNextEngine(
+                        &p_KeyParams->ccNextEngineParams, &requiredAction);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
-                p_CcNode->keyAndNextEngineParams[tmp].requiredAction = requiredAction;
+                p_CcNode->keyAndNextEngineParams[tmp].requiredAction =
+                        requiredAction;
             }
 
             memcpy(&p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams,
                    &p_KeyParams->ccNextEngineParams,
                    sizeof(t_FmPcdCcNextEngineParams));
 
-            if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
-                && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+            if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
+                    && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
             {
-                err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+                err =
+                        AllocAndFillAdForContLookupManip(
+                                p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
             }
@@ -3796,8 +4047,11 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
             err = ValidateNextEngineParams(h_FmPcd,
                                            &p_KeyParams->ccNextEngineParams,
                                            p_CcNode->statisticsMode);
-            if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
-                RETURN_ERROR(MAJOR, err, ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
+            if (GET_ERROR_TYPE(err) != E_NOT_SUPPORTED)
+                RETURN_ERROR(
+                        MAJOR,
+                        err,
+                        ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
         }
     }
 
@@ -3807,45 +4061,44 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     return E_OK;
 }
 
-static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
-                                         t_Handle                    h_FmPcdCcNode,
-                                         uint16_t                    keyIndex,
-                                         t_FmPcdCcNextEngineParams   *p_FmPcdCcNextEngineParams)
+static t_Error ModifyNextEngineParamNode(
+        t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_Error err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(p_CcNode,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("keyIndex > previously cleared last index + 1"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, FALSE,
+                                             FALSE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    if (p_CcNode->maxNumOfKeys &&
-        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    if (p_CcNode->maxNumOfKeys
+            && !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
     {
         XX_Free(p_ModifyKeyParams);
         return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine(h_FmPcd,
-                                       p_CcNode,
-                                       keyIndex,
+    err = BuildNewNodeModifyNextEngine(h_FmPcd, p_CcNode, keyIndex,
                                        p_FmPcdCcNextEngineParams,
-                                       &h_OldPointersLst,
-                                       &h_NewPointersLst,
+                                       &h_OldPointersLst, &h_NewPointersLst,
                                        p_ModifyKeyParams);
     if (err)
     {
@@ -3855,7 +4108,8 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, FALSE);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -3863,36 +4117,37 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
     return err;
 }
 
-static t_Error FindKeyIndex(t_Handle    h_CcNode,
-                            uint8_t     keySize,
-                            uint8_t     *p_Key,
-                            uint8_t     *p_Mask,
-                            uint16_t    *p_KeyIndex)
+static t_Error FindKeyIndex(t_Handle h_CcNode, uint8_t keySize, uint8_t *p_Key,
+                            uint8_t *p_Mask, uint16_t *p_KeyIndex)
 {
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint8_t         tmpMask[FM_PCD_MAX_SIZE_OF_KEY];
-    uint16_t        i;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint8_t tmpMask[FM_PCD_MAX_SIZE_OF_KEY];
+    uint16_t i;
 
     ASSERT_COND(p_Key);
     ASSERT_COND(p_KeyIndex);
     ASSERT_COND(keySize < FM_PCD_MAX_SIZE_OF_KEY);
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Key size doesn't match the extraction size of the node"));
+        RETURN_ERROR(
+                MINOR, E_INVALID_VALUE,
+                ("Key size doesn't match the extraction size of the node"));
 
     /* If user didn't pass a mask for this key, we'll look for full extraction mask */
     if (!p_Mask)
         memset(tmpMask, 0xFF, keySize);
 
-    for (i = 0 ; i < p_CcNode->numOfKeys; i++)
+    for (i = 0; i < p_CcNode->numOfKeys; i++)
     {
         /* Comparing received key */
-        if (memcmp(p_Key, p_CcNode->keyAndNextEngineParams[i].key, keySize) == 0)
+        if (memcmp(p_Key, p_CcNode->keyAndNextEngineParams[i].key, keySize)
+                == 0)
         {
             if (p_Mask)
             {
                 /* If a user passed a mask for this key, it must match to the existing key's mask for a correct match */
-                if (memcmp(p_Mask, p_CcNode->keyAndNextEngineParams[i].mask, keySize) == 0)
+                if (memcmp(p_Mask, p_CcNode->keyAndNextEngineParams[i].mask,
+                           keySize) == 0)
                 {
                     *p_KeyIndex = i;
                     return E_OK;
@@ -3901,7 +4156,8 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
             else
             {
                 /* If user didn't pass a mask for this key, check if the existing key mask is full extraction */
-                if (memcmp(tmpMask, p_CcNode->keyAndNextEngineParams[i].mask, keySize) == 0)
+                if (memcmp(tmpMask, p_CcNode->keyAndNextEngineParams[i].mask,
+                           keySize) == 0)
                 {
                     *p_KeyIndex = i;
                     return E_OK;
@@ -3913,30 +4169,32 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
     return ERROR_CODE(E_NOT_FOUND);
 }
 
-static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode  *p_CcNode,
-                                     bool           isKeyTblAlloc,
-                                     uint32_t       *p_MatchTableSize,
-                                     uint32_t       *p_AdTableSize)
+static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode *p_CcNode,
+                                     bool isKeyTblAlloc,
+                                     uint32_t *p_MatchTableSize,
+                                     uint32_t *p_AdTableSize)
 {
-    uint32_t    shadowSize;
-    t_Error     err;
+    uint32_t shadowSize;
+    t_Error err;
 
     /* Calculate keys table maximal size - each entry consists of a key and a mask,
-       (if local mask support is requested) */
-    *p_MatchTableSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t) * p_CcNode->maxNumOfKeys;
+     (if local mask support is requested) */
+    *p_MatchTableSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t)
+            * p_CcNode->maxNumOfKeys;
 
     if (p_CcNode->maskSupport)
         *p_MatchTableSize *= 2;
 
     /* Calculate next action descriptors table, including one more entry for miss */
-    *p_AdTableSize = (uint32_t)((p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE);
+    *p_AdTableSize = (uint32_t)((p_CcNode->maxNumOfKeys + 1)
+            * FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Calculate maximal shadow size of this node.
-       All shadow structures will be used for runtime modifications host command. If
-       keys table was allocated for this node, the keys table and next engines table may
-       be modified in run time (entries added or removed), so shadow tables are requires.
-       Otherwise, the only supported runtime modification is a specific next engine update
-       and this requires shadow memory of a single AD */
+     All shadow structures will be used for runtime modifications host command. If
+     keys table was allocated for this node, the keys table and next engines table may
+     be modified in run time (entries added or removed), so shadow tables are requires.
+     Otherwise, the only supported runtime modification is a specific next engine update
+     and this requires shadow memory of a single AD */
 
     /* Shadow size should be enough to hold the following 3 structures:
      * 1 - an action descriptor */
@@ -3950,7 +4208,8 @@ static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode  *p_CcNode,
     shadowSize += *p_AdTableSize;
 
     /* Update shadow to the calculated size */
-    err = FmPcdUpdateCcShadow (p_CcNode->h_FmPcd, (uint32_t)shadowSize, FM_PCD_CC_AD_TABLE_ALIGN);
+    err = FmPcdUpdateCcShadow(p_CcNode->h_FmPcd, (uint32_t)shadowSize,
+                              FM_PCD_CC_AD_TABLE_ALIGN);
     if (err != E_OK)
     {
         DeleteNode(p_CcNode);
@@ -3962,16 +4221,16 @@ static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode  *p_CcNode,
 
 static t_Error AllocStatsObjs(t_FmPcdCcNode *p_CcNode)
 {
-    t_FmPcdStatsObj     *p_StatsObj;
-    t_Handle            h_FmMuram, h_StatsAd, h_StatsCounters;
-    uint32_t            i;
+    t_FmPcdStatsObj *p_StatsObj;
+    t_Handle h_FmMuram, h_StatsAd, h_StatsCounters;
+    uint32_t i;
 
     h_FmMuram = FmPcdGetMuramHandle(p_CcNode->h_FmPcd);
     if (!h_FmMuram)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM MURAM"));
 
     /* Allocate statistics ADs and statistics counter. An extra pair (AD + counters)
-       will be allocated to support runtime modifications */
+     will be allocated to support runtime modifications */
     for (i = 0; i < p_CcNode->maxNumOfKeys + 2; i++)
     {
         /* Allocate list object structure */
@@ -3991,20 +4250,22 @@ static t_Error AllocStatsObjs(t_FmPcdCcNode *p_CcNode)
         {
             FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
             XX_Free(p_StatsObj);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics ADs"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for statistics ADs"));
         }
         IOMemSet32(h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
         /* Allocate statistics counters from MURAM */
-        h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                                      p_CcNode->countersArraySize,
-                                                      FM_PCD_CC_AD_TABLE_ALIGN);
+        h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, p_CcNode->countersArraySize,
+                FM_PCD_CC_AD_TABLE_ALIGN);
         if (!h_StatsCounters)
         {
             FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
             FM_MURAM_FreeMem(h_FmMuram, h_StatsAd);
             XX_Free(p_StatsObj);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics counters"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for statistics counters"));
         }
         IOMemSet32(h_StatsCounters, 0, p_CcNode->countersArraySize);
 
@@ -4017,78 +4278,85 @@ static t_Error AllocStatsObjs(t_FmPcdCcNode *p_CcNode)
     return E_OK;
 }
 
-static t_Error MatchTableGetKeyStatistics(t_FmPcdCcNode           *p_CcNode,
-                                          uint16_t                keyIndex,
-                                          t_FmPcdCcKeyStatistics  *p_KeyStatistics)
+static t_Error MatchTableGetKeyStatistics(
+        t_FmPcdCcNode *p_CcNode, uint16_t keyIndex,
+        t_FmPcdCcKeyStatistics *p_KeyStatistics)
 {
-    uint32_t    *p_StatsCounters, i;
+    uint32_t *p_StatsCounters, i;
 
     if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for this match table"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("Statistics were not enabled for this match table"));
 
     if (!p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for this key"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("Statistics were not enabled for this key"));
 
-    memset(p_KeyStatistics, 0, sizeof (t_FmPcdCcKeyStatistics));
+    memset(p_KeyStatistics, 0, sizeof(t_FmPcdCcKeyStatistics));
 
-    p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
+    p_StatsCounters =
+            p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
     ASSERT_COND(p_StatsCounters);
 
     p_KeyStatistics->byteCount = GET_UINT32(*p_StatsCounters);
 
     for (i = 1; i <= p_CcNode->numOfStatsFLRs; i++)
     {
-        p_StatsCounters = PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_COUNTER_SIZE);
+        p_StatsCounters =
+                PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_COUNTER_SIZE);
 
         p_KeyStatistics->frameCount += GET_UINT32(*p_StatsCounters);
 
 #if (DPAA_VERSION >= 11)
-        p_KeyStatistics->frameLengthRangeCount[i-1] = GET_UINT32(*p_StatsCounters);
+        p_KeyStatistics->frameLengthRangeCount[i - 1] =
+                GET_UINT32(*p_StatsCounters);
 #endif /* (DPAA_VERSION >= 11) */
     }
 
     return E_OK;
 }
 
-static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdCcNodeParams *p_CcNodeParam)
+static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode,
+                             t_FmPcdCcNodeParams *p_CcNodeParam)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *) h_FmPcd;
-    t_FmPcdCcNode           *p_FmPcdCcNextNode;
-    t_Error                 err = E_OK;
-    uint32_t                tmp, keySize;
-    bool                    glblMask = FALSE;
-    t_FmPcdCcKeyParams      *p_KeyParams;
-    t_Handle                h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcNode *p_FmPcdCcNextNode;
+    t_Error err = E_OK;
+    uint32_t tmp, keySize;
+    bool glblMask = FALSE;
+    t_FmPcdCcKeyParams *p_KeyParams;
+    t_Handle h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
 #if (DPAA_VERSION >= 11)
-    t_Handle                h_StatsFLRs;
+    t_Handle h_StatsFLRs;
 #endif /* (DPAA_VERSION >= 11) */
-    bool                    fullField = FALSE;
-    ccPrivateInfo_t         icCode = CC_PRIVATE_INFO_NONE;
-    bool                    isKeyTblAlloc, fromIc = FALSE;
-    uint32_t                matchTableSize, adTableSize;
-    t_CcNodeInformation     ccNodeInfo, *p_CcInformation;
-    t_FmPcdStatsObj         *p_StatsObj;
-    t_FmPcdCcStatsParams    statsParams = {0};
-    t_Handle                h_Manip;
+    bool fullField = FALSE;
+    ccPrivateInfo_t icCode = CC_PRIVATE_INFO_NONE;
+    bool isKeyTblAlloc, fromIc = FALSE;
+    uint32_t matchTableSize, adTableSize;
+    t_CcNodeInformation ccNodeInfo, *p_CcInformation;
+    t_FmPcdStatsObj *p_StatsObj;
+    t_FmPcdCcStatsParams statsParams = { 0 };
+    t_Handle h_Manip;
 
     ASSERT_COND(h_FmPcd);
     ASSERT_COND(p_CcNode);
     ASSERT_COND(p_CcNodeParam);
 
-    p_CcNode->p_GlblMask = (t_Handle)XX_Malloc(CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+    p_CcNode->p_GlblMask = (t_Handle)XX_Malloc(
+            CC_GLBL_MASK_SIZE * sizeof(uint8_t));
     memset(p_CcNode->p_GlblMask, 0, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
-    p_CcNode->h_FmPcd           = h_FmPcd;
-    p_CcNode->numOfKeys         = p_CcNodeParam->keysParams.numOfKeys;
-    p_CcNode->maxNumOfKeys      = p_CcNodeParam->keysParams.maxNumOfKeys;
-    p_CcNode->maskSupport       = p_CcNodeParam->keysParams.maskSupport;
-    p_CcNode->statisticsMode    = p_CcNodeParam->keysParams.statisticsMode;
+    p_CcNode->h_FmPcd = h_FmPcd;
+    p_CcNode->numOfKeys = p_CcNodeParam->keysParams.numOfKeys;
+    p_CcNode->maxNumOfKeys = p_CcNodeParam->keysParams.maxNumOfKeys;
+    p_CcNode->maskSupport = p_CcNodeParam->keysParams.maskSupport;
+    p_CcNode->statisticsMode = p_CcNodeParam->keysParams.statisticsMode;
 
     /* For backward compatibility - even if statistics mode is nullified,
-       we'll fix it to frame mode so we can support per-key request for
-       statistics using 'statisticsEn' in next engine parameters */
-    if (!p_CcNode->maxNumOfKeys &&
-        (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE))
+     we'll fix it to frame mode so we can support per-key request for
+     statistics using 'statisticsEn' in next engine parameters */
+    if (!p_CcNode->maxNumOfKeys
+            && (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE))
         p_CcNode->statisticsMode = e_FM_PCD_CC_STATS_MODE_FRAME;
 
     h_FmMuram = FmPcdGetMuramHandle(h_FmPcd);
@@ -4107,43 +4375,67 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("CC node spinlock"));
     }
 
-    if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR) &&
-        ((p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv4) ||
-        (p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv6)) &&
-        (p_CcNodeParam->extractCcParams.extractByHdr.type == e_FM_PCD_EXTRACT_FULL_FIELD) &&
-        ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6 == NET_HEADER_FIELD_IPv6_HOP_LIMIT) ||
-        (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4 == NET_HEADER_FIELD_IPv4_TTL)))
-    {
-        err = Ipv4TtlOrIpv6HopLimitCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
+    if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR)
+            && ((p_CcNodeParam->extractCcParams.extractByHdr.hdr
+                    == HEADER_TYPE_IPv4)
+                    || (p_CcNodeParam->extractCcParams.extractByHdr.hdr
+                            == HEADER_TYPE_IPv6))
+            && (p_CcNodeParam->extractCcParams.extractByHdr.type
+                    == e_FM_PCD_EXTRACT_FULL_FIELD)
+            && ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6
+                    == NET_HEADER_FIELD_IPv6_HOP_LIMIT)
+                    || (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4
+                            == NET_HEADER_FIELD_IPv4_TTL)))
+    {
+        err = Ipv4TtlOrIpv6HopLimitCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode,
+                                               &isKeyTblAlloc);
         glblMask = FALSE;
     }
-    else if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
-             ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_KEY) ||
-              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
-              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
-    {
-        if ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
-            (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
+    else
+        if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR)
+                && ((p_CcNodeParam->extractCcParams.extractNonHdr.src
+                        == e_FM_PCD_EXTRACT_FROM_KEY)
+                        || (p_CcNodeParam->extractCcParams.extractNonHdr.src
+                                == e_FM_PCD_EXTRACT_FROM_HASH)
+                        || (p_CcNodeParam->extractCcParams.extractNonHdr.src
+                                == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
         {
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                         ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
-        }
+            if ((p_CcNodeParam->extractCcParams.extractNonHdr.src
+                    == e_FM_PCD_EXTRACT_FROM_FLOW_ID)
+                    && (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
+            {
+                DeleteNode(p_CcNode);
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
+            }
 
-        icCode = IcDefineCode(p_CcNodeParam);
-        fromIc = TRUE;
-        if (icCode == CC_PRIVATE_INFO_NONE)
-        {
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                         ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
-        }
+            icCode = IcDefineCode(p_CcNodeParam);
+            fromIc = TRUE;
+            if (icCode == CC_PRIVATE_INFO_NONE)
+            {
+                DeleteNode(p_CcNode);
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
+            }
 
-        if ((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP) ||
-            (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
-        {
-            err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
-            glblMask = TRUE;
+            if ((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP)
+                    || (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
+            {
+                err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode,
+                                               &isKeyTblAlloc);
+                glblMask = TRUE;
+            }
+            else
+            {
+                err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode,
+                                  &isKeyTblAlloc);
+                if (p_CcNode->glblMaskSize)
+                    glblMask = TRUE;
+            }
         }
         else
         {
@@ -4151,13 +4443,6 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
             if (p_CcNode->glblMaskSize)
                 glblMask = TRUE;
         }
-    }
-    else
-    {
-        err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
-        if (p_CcNode->glblMaskSize)
-            glblMask = TRUE;
-    }
 
     if (err)
     {
@@ -4172,24 +4457,28 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
             {
                 case (e_FM_PCD_EXTRACT_FULL_FIELD):
                     p_CcNode->parseCode =
-                        GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                              p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                              p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
-                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                       p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField,
-                                       &p_CcNode->sizeOfExtraction);
+                            GetFullFieldParseCode(
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
+                    GetSizeHeaderField(
+                            p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                            p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField,
+                            &p_CcNode->sizeOfExtraction);
                     fullField = TRUE;
-                    if ((p_CcNode->parseCode != CC_PC_FF_TCI1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_TCI2) &&
-                        (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPDSCP) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
-                        glblMask)
+                    if ((p_CcNode->parseCode != CC_PC_FF_TCI1)
+                            && (p_CcNode->parseCode != CC_PC_FF_TCI2)
+                            && (p_CcNode->parseCode != CC_PC_FF_MPLS1)
+                            && (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST)
+                            && (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1)
+                            && (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2)
+                            && (p_CcNode->parseCode
+                                    != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1)
+                            && (p_CcNode->parseCode != CC_PC_FF_IPDSCP)
+                            && (p_CcNode->parseCode
+                                    != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2)
+                            && glblMask)
                     {
                         glblMask = FALSE;
                         p_CcNode->glblMaskSize = 4;
@@ -4198,26 +4487,34 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
                     break;
 
                 case (e_FM_PCD_EXTRACT_FROM_HDR):
-                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
-                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
-                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                    p_CcNode->sizeOfExtraction =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
+                    p_CcNode->offset =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                    p_CcNode->userOffset =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
                     p_CcNode->parseCode =
-                        GetPrParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                       p_CcNode->offset,glblMask,
-                                       &p_CcNode->prsArrayOffset);
+                            GetPrParseCode(
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                    p_CcNode->offset, glblMask,
+                                    &p_CcNode->prsArrayOffset);
                     break;
 
                 case (e_FM_PCD_EXTRACT_FROM_FIELD):
-                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
-                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
-                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
+                    p_CcNode->offset =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                    p_CcNode->userOffset =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                    p_CcNode->sizeOfExtraction =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
                     p_CcNode->parseCode =
-                        GetFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                          p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
-                                          p_CcNode->offset,
-                                          &p_CcNode->prsArrayOffset,
-                                          p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
+                            GetFieldParseCode(
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
+                                    p_CcNode->offset,
+                                    &p_CcNode->prsArrayOffset,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
                     break;
 
                 default:
@@ -4228,34 +4525,37 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 
         case (e_FM_PCD_EXTRACT_NON_HDR):
             /* get the field code for the generic extract */
-            p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
-            p_CcNode->offset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
-            p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
-            p_CcNode->parseCode =
-                GetGenParseCode(h_FmPcd,
-                                p_CcNodeParam->extractCcParams.extractNonHdr.src,
-                                p_CcNode->offset,
-                                glblMask,
-                                &p_CcNode->prsArrayOffset,
-                                fromIc,icCode);
+            p_CcNode->sizeOfExtraction =
+                    p_CcNodeParam->extractCcParams.extractNonHdr.size;
+            p_CcNode->offset =
+                    p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_CcNode->userOffset =
+                    p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_CcNode->parseCode = GetGenParseCode(
+                    h_FmPcd, p_CcNodeParam->extractCcParams.extractNonHdr.src,
+                    p_CcNode->offset, glblMask, &p_CcNode->prsArrayOffset,
+                    fromIc, icCode);
 
             if (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
                 if ((p_CcNode->offset + p_CcNode->sizeOfExtraction) > 8)
                 {
-                     DeleteNode(p_CcNode);
-                     RETURN_ERROR(MAJOR, E_INVALID_SELECTION,("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
+                    DeleteNode(p_CcNode);
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_SELECTION,
+                            ("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
                 }
             }
-            if ((p_CcNode->parseCode == CC_PC_GENERIC_IC_GMASK) ||
-                (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
+            if ((p_CcNode->parseCode == CC_PC_GENERIC_IC_GMASK)
+                    || (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
             {
-                p_CcNode->offset +=  p_CcNode->prsArrayOffset;
+                p_CcNode->offset += p_CcNode->prsArrayOffset;
                 p_CcNode->prsArrayOffset = 0;
             }
             break;
 
-       default:
+        default:
             DeleteNode(p_CcNode);
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
     }
@@ -4266,33 +4566,37 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("illegal extraction type"));
     }
 
-    if ((p_CcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY) ||
-        !p_CcNode->sizeOfExtraction)
+    if ((p_CcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY)
+            || !p_CcNode->sizeOfExtraction)
     {
         DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("sizeOfExatrction can not be greater than 56 and not 0"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("sizeOfExatrction can not be greater than 56 and not 0"));
     }
 
     if (p_CcNodeParam->keysParams.keySize != p_CcNode->sizeOfExtraction)
     {
         DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("keySize has to be equal to sizeOfExtraction"));
     }
 
     p_CcNode->userSizeOfExtraction = p_CcNode->sizeOfExtraction;
 
     if (!glblMask)
-        memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE  * sizeof(uint8_t));
+        memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
     err = CheckAndSetManipParamsWithCcNodeParams(p_CcNode);
     if (err != E_OK)
     {
         DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("keySize has to be equal to sizeOfExtraction"));
     }
 
     /* Calculating matching table entry size by rounding up the user-defined size of extraction to valid entry size */
-    GetCcExtractKeySize(p_CcNode->sizeOfExtraction, &p_CcNode->ccKeySizeAccExtraction);
+    GetCcExtractKeySize(p_CcNode->sizeOfExtraction,
+                        &p_CcNode->ccKeySizeAccExtraction);
 
     /* If local mask is used, it is stored next to each key in the keys match table */
     if (p_CcNode->lclMask)
@@ -4303,9 +4607,7 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     /* Update CC shadow with maximal size required by this node */
     if (p_CcNode->maxNumOfKeys)
     {
-        err = CalcAndUpdateCcShadow(p_CcNode,
-                                    isKeyTblAlloc,
-                                    &matchTableSize,
+        err = CalcAndUpdateCcShadow(p_CcNode, isKeyTblAlloc, &matchTableSize,
                                     &adTableSize);
         if (err != E_OK)
         {
@@ -4326,21 +4628,23 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         }
 
         /* If manipulation will be initialized before this node, it will use the table
-           descriptor in the AD table of previous node and this node will need an extra
-           AD as his table descriptor. */
-        p_CcNode->h_TmpAd = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                                     FM_PCD_CC_AD_ENTRY_SIZE,
-                                                     FM_PCD_CC_AD_TABLE_ALIGN);
+         descriptor in the AD table of previous node and this node will need an extra
+         AD as his table descriptor. */
+        p_CcNode->h_TmpAd = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE, FM_PCD_CC_AD_TABLE_ALIGN);
         if (!p_CcNode->h_TmpAd)
         {
             DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC action descriptor"));
         }
     }
     else
     {
-        matchTableSize = (uint32_t)(keySize * sizeof(uint8_t) * (p_CcNode->numOfKeys + 1));
-        adTableSize    = (uint32_t)(FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNode->numOfKeys + 1));
+        matchTableSize = (uint32_t)(keySize * sizeof(uint8_t)
+                * (p_CcNode->numOfKeys + 1));
+        adTableSize = (uint32_t)(FM_PCD_CC_AD_ENTRY_SIZE
+                * (p_CcNode->numOfKeys + 1));
     }
 
 #if (DPAA_VERSION >= 11)
@@ -4349,22 +4653,26 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 
         case e_FM_PCD_CC_STATS_MODE_RMON:
             /* If RMON statistics or RMON conditional statistics modes are requested,
-               allocate frame length ranges array */
-            p_CcNode->h_StatsFLRs =
-                    FM_MURAM_AllocMem(h_FmMuram,
-                                      (uint32_t)(p_CcNode->numOfStatsFLRs) * FM_PCD_CC_STATS_FLR_SIZE,
-                                      FM_PCD_CC_AD_TABLE_ALIGN);
+             allocate frame length ranges array */
+            p_CcNode->h_StatsFLRs = FM_MURAM_AllocMem(
+                    h_FmMuram,
+                    (uint32_t)(p_CcNode->numOfStatsFLRs)
+                            * FM_PCD_CC_STATS_FLR_SIZE,
+                    FM_PCD_CC_AD_TABLE_ALIGN);
 
             if (!p_CcNode->h_StatsFLRs)
             {
                 DeleteNode(p_CcNode);
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC frame length ranges array"));
+                RETURN_ERROR(
+                        MAJOR, E_NO_MEMORY,
+                        ("MURAM allocation for CC frame length ranges array"));
             }
 
             /* Initialize using value received from the user */
             for (tmp = 0; tmp < p_CcNode->numOfStatsFLRs; tmp++)
             {
-                h_StatsFLRs = PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
+                h_StatsFLRs =
+                        PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
 
                 Mem2IOCpy32(h_StatsFLRs,
                             &(p_CcNodeParam->keysParams.frameLengthRanges[tmp]),
@@ -4377,39 +4685,34 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     }
 #endif /* (DPAA_VERSION >= 11) */
 
-
     /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
-       identification, IPv6 hop count identification, etc. */
+     identification, IPv6 hop count identification, etc. */
     if (isKeyTblAlloc)
     {
-        p_CcNode->h_KeysMatchTable =
-            (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                        matchTableSize,
-                                        FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+        p_CcNode->h_KeysMatchTable = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, matchTableSize, FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
         if (!p_CcNode->h_KeysMatchTable)
         {
             DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC node key match table"));
         }
-        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable,
-                   0,
-                   matchTableSize);
+        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable, 0, matchTableSize);
     }
 
     /* Allocate action descriptors table */
-    p_CcNode->h_AdTable =
-        (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                    adTableSize,
-                                    FM_PCD_CC_AD_TABLE_ALIGN);
+    p_CcNode->h_AdTable = (t_Handle)FM_MURAM_AllocMem(h_FmMuram, adTableSize,
+                                                      FM_PCD_CC_AD_TABLE_ALIGN);
     if (!p_CcNode->h_AdTable)
     {
         DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM allocation for CC node action descriptors table"));
     }
     IOMemSet32((uint8_t *)p_CcNode->h_AdTable, 0, adTableSize);
 
     p_KeysMatchTblTmp = p_CcNode->h_KeysMatchTable;
-    p_AdTableTmp      = p_CcNode->h_AdTable;
+    p_AdTableTmp = p_CcNode->h_AdTable;
 
     /* For each key, create the key and the next step AD */
     for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
@@ -4419,25 +4722,26 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         if (p_KeysMatchTblTmp)
         {
             /* Copy the key */
-            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_CcNode->sizeOfExtraction);
+            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key,
+                        p_CcNode->sizeOfExtraction);
 
             /* Copy the key mask or initialize it to 0xFF..F */
             if (p_CcNode->lclMask && p_KeyParams->p_Mask)
             {
                 Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp,
-                                     p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
-                            p_KeyParams->p_Mask,
-                            p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
-            }
-            else if (p_CcNode->lclMask)
-            {
-                IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
-                                    p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
-                           0xff,
-                           p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
+                        p_CcNode->ccKeySizeAccExtraction), /* User's size of extraction rounded up to a valid matching table entry size */
+                            p_KeyParams->p_Mask, p_CcNode->sizeOfExtraction); /* Exact size of extraction as received from the user */
             }
+            else
+                if (p_CcNode->lclMask)
+                {
+                    IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
+                            p_CcNode->ccKeySizeAccExtraction), /* User's size of extraction rounded up to a valid matching table entry size */
+                               0xff, p_CcNode->sizeOfExtraction); /* Exact size of extraction as received from the user */
+                }
 
-            p_KeysMatchTblTmp = PTR_MOVE(p_KeysMatchTblTmp, keySize * sizeof(uint8_t));
+            p_KeysMatchTblTmp =
+                    PTR_MOVE(p_KeysMatchTblTmp, keySize * sizeof(uint8_t));
         }
 
         /* Create the next action descriptor in the match table */
@@ -4452,18 +4756,14 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
             statsParams.h_StatsFLRs = p_CcNode->h_StatsFLRs;
 
 #endif /* (DPAA_VERSION >= 11) */
-            NextStepAd(p_AdTableTmp,
-                       &statsParams,
-                       &p_KeyParams->ccNextEngineParams,
-                       p_FmPcd);
+            NextStepAd(p_AdTableTmp, &statsParams,
+                       &p_KeyParams->ccNextEngineParams, p_FmPcd);
 
             p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = p_StatsObj;
         }
         else
         {
-            NextStepAd(p_AdTableTmp,
-                       NULL,
-                       &p_KeyParams->ccNextEngineParams,
+            NextStepAd(p_AdTableTmp, NULL, &p_KeyParams->ccNextEngineParams,
                        p_FmPcd);
 
             p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = NULL;
@@ -4479,8 +4779,8 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         ASSERT_COND(p_StatsObj);
 
         /* All 'bucket' nodes of a hash table should share the same statistics counters,
-           allocated by the hash table. So, if this node is a bucket of a hash table,
-           we'll replace the locally allocated counters with the shared counters. */
+         allocated by the hash table. So, if this node is a bucket of a hash table,
+         we'll replace the locally allocated counters with the shared counters. */
         if (p_CcNode->isHashBucket)
         {
             ASSERT_COND(p_CcNode->h_MissStatsCounters);
@@ -4497,8 +4797,7 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 
 #endif /* (DPAA_VERSION >= 11) */
 
-        NextStepAd(p_AdTableTmp,
-                   &statsParams,
+        NextStepAd(p_AdTableTmp, &statsParams,
                    &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
                    p_FmPcd);
 
@@ -4506,8 +4805,7 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     }
     else
     {
-        NextStepAd(p_AdTableTmp,
-                   NULL,
+        NextStepAd(p_AdTableTmp, NULL,
                    &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
                    p_FmPcd);
 
@@ -4515,18 +4813,20 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     }
 
     /* This parameter will be used to initialize the "key length" field in the action descriptor
-       that points to this node and it should be 0 for full field extraction */
+     that points to this node and it should be 0 for full field extraction */
     if (fullField == TRUE)
         p_CcNode->sizeOfExtraction = 0;
 
     for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, CC_MAX_NUM_OF_KEYS); tmp++)
     {
-        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
         {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
-            p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccPrevNodesLst,
-                                                        (t_Handle)p_CcNode,
-                                                        p_FmPcdCcNextNode->h_Spinlock);
+            p_FmPcdCcNextNode =
+                    (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
+            p_CcInformation = FindNodeInfoInReleventLst(
+                    &p_FmPcdCcNextNode->ccPrevNodesLst, (t_Handle)p_CcNode,
+                    p_FmPcdCcNextNode->h_Spinlock);
             if (!p_CcInformation)
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
@@ -4541,18 +4841,19 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 
             if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
             {
-                h_Manip = p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
-                p_CcInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
-                                                             (t_Handle)p_CcNode,
-                                                             FmPcdManipGetSpinlock(h_Manip));
+                h_Manip =
+                        p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
+                p_CcInformation = FindNodeInfoInReleventLst(
+                        FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
+                        (t_Handle)p_CcNode, FmPcdManipGetSpinlock(h_Manip));
                 if (!p_CcInformation)
                 {
-                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                     ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
-                     ccNodeInfo.index = 1;
-                     EnqueueNodeInfoToRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
-                                                  &ccNodeInfo,
-                                                  FmPcdManipGetSpinlock(h_Manip));
+                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                    ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
+                    ccNodeInfo.index = 1;
+                    EnqueueNodeInfoToRelevantLst(
+                            FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
+                            &ccNodeInfo, FmPcdManipGetSpinlock(h_Manip));
                 }
                 else
                     p_CcInformation->index++;
@@ -4574,12 +4875,11 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     {
         if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
         {
-            err = SetRequiredAction(h_FmPcd,
-                                    p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
-                                    &p_CcNode->keyAndNextEngineParams[tmp],
-                                    p_AdTableTmp,
-                                    1,
-                                    NULL);
+            err = SetRequiredAction(
+                    h_FmPcd,
+                    p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
+                    &p_CcNode->keyAndNextEngineParams[tmp], p_AdTableTmp, 1,
+                    NULL);
             if (err)
             {
                 FmPcdLockUnlockAll(h_FmPcd);
@@ -4596,20 +4896,21 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 }
 /************************** End of static functions **************************/
 
-
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
 
-t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
+t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info,
+                                               t_Handle h_Spinlock)
 {
     t_CcNodeInformation *p_CcInformation;
-    t_List              *p_Pos;
-    uint32_t            intFlags;
+    t_List *p_Pos;
+    uint32_t intFlags;
 
     intFlags = XX_LockIntrSpinlock(h_Spinlock);
 
-    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List);
+            p_Pos = LIST_NEXT(p_Pos))
     {
         p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
 
@@ -4627,12 +4928,14 @@ t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info,
     return NULL;
 }
 
-void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo, t_Handle h_Spinlock)
+void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo,
+                                  t_Handle h_Spinlock)
 {
     t_CcNodeInformation *p_CcInformation;
-    uint32_t            intFlags = 0;
+    uint32_t intFlags = 0;
 
-    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(sizeof(t_CcNodeInformation));
+    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(
+            sizeof(t_CcNodeInformation));
 
     if (p_CcInformation)
     {
@@ -4652,11 +4955,12 @@ void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo,
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Node Information"));
 }
 
-void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
+void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info,
+                                    t_Handle h_Spinlock)
 {
     t_CcNodeInformation *p_CcInformation = NULL;
-    uint32_t            intFlags = 0;
-    t_List              *p_Pos;
+    uint32_t intFlags = 0;
+    t_List *p_Pos;
 
     if (h_Spinlock)
         intFlags = XX_LockIntrSpinlock(h_Spinlock);
@@ -4667,7 +4971,8 @@ void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_
         return;
     }
 
-    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List);
+            p_Pos = LIST_NEXT(p_Pos))
     {
         p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
         ASSERT_COND(p_CcInformation);
@@ -4686,10 +4991,9 @@ void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_
         XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
 }
 
-void NextStepAd(t_Handle                     h_Ad,
-                t_FmPcdCcStatsParams         *p_FmPcdCcStatsParams,
-                t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
-                t_FmPcd                      *p_FmPcd)
+void NextStepAd(t_Handle h_Ad, t_FmPcdCcStatsParams *p_FmPcdCcStatsParams,
+                t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,
+                t_FmPcd *p_FmPcd)
 {
     switch (p_FmPcdCcNextEngineParams->nextEngine)
     {
@@ -4697,57 +5001,52 @@ void NextStepAd(t_Handle                     h_Ad,
         case (e_FM_PCD_PLCR):
         case (e_FM_PCD_DONE):
             /* if NIA is not CC, create a "result" type AD */
-            FillAdOfTypeResult(h_Ad,
-                               p_FmPcdCcStatsParams,
-                               p_FmPcd,
+            FillAdOfTypeResult(h_Ad, p_FmPcdCcStatsParams, p_FmPcd,
                                p_FmPcdCcNextEngineParams);
             break;
 #if (DPAA_VERSION >= 11)
         case (e_FM_PCD_FR):
             if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
             {
-                FillAdOfTypeContLookup(h_Ad,
-                                       p_FmPcdCcStatsParams,
-                                       p_FmPcd,
-                                       p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-                                       p_FmPcdCcNextEngineParams->h_Manip,
-                                       p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
-                FrmReplicGroupUpdateOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
-                                          TRUE/* add */);
+                FillAdOfTypeContLookup(
+                        h_Ad, p_FmPcdCcStatsParams, p_FmPcd,
+                        p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                        p_FmPcdCcNextEngineParams->h_Manip,
+                        p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
+                FrmReplicGroupUpdateOwner(
+                        p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
+                        TRUE/* add */);
             }
             break;
 #endif /* (DPAA_VERSION >= 11) */
 
         case (e_FM_PCD_CC):
             /* if NIA is not CC, create a TD to continue the CC lookup */
-            FillAdOfTypeContLookup(h_Ad,
-                                   p_FmPcdCcStatsParams,
-                                   p_FmPcd,
-                                   p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-                                   p_FmPcdCcNextEngineParams->h_Manip,
-                                   NULL);
-
-            UpdateNodeOwner(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode, TRUE);
+            FillAdOfTypeContLookup(
+                    h_Ad, p_FmPcdCcStatsParams, p_FmPcd,
+                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                    p_FmPcdCcNextEngineParams->h_Manip, NULL);
+
+            UpdateNodeOwner(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                            TRUE);
             break;
 
-         default:
-             return;
+        default:
+            return;
     }
 }
 
-t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
-                          t_Handle  h_FmTree,
-                          t_Handle  h_NetEnv,
-                          t_Handle  h_IpReassemblyManip,
-                          bool      createSchemes)
+t_Error FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree,
+                          t_Handle h_NetEnv, t_Handle h_IpReassemblyManip,
+                          bool createSchemes)
 {
-    t_FmPcdCcTree               *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
-    t_FmPcdCcNextEngineParams   nextEngineParams;
-    t_NetEnvParams              netEnvParams;
-    t_Handle                    h_Ad;
-    bool                        isIpv6Present;
-    uint8_t                     ipv4GroupId, ipv6GroupId;
-    t_Error                     err;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+    t_FmPcdCcNextEngineParams nextEngineParams;
+    t_NetEnvParams netEnvParams;
+    t_Handle h_Ad;
+    bool isIpv6Present;
+    uint8_t ipv4GroupId, ipv6GroupId;
+    t_Error err;
 
     ASSERT_COND(p_FmPcdCcTree);
 
@@ -4760,10 +5059,11 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
 
     isIpv6Present = FmPcdManipIpReassmIsIpv6Hdr(h_IpReassemblyManip);
 
-    if (isIpv6Present && (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-2)))
+    if (isIpv6Present
+            && (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS - 2)))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
 
-    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-1))
+    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS - 1))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
 
     nextEngineParams.nextEngine = e_FM_PCD_DONE;
@@ -4780,22 +5080,27 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
         return E_OK;
     }
 
-    if ((p_FmPcdCcTree->h_IpReassemblyManip) &&
-        (p_FmPcdCcTree->h_IpReassemblyManip != h_IpReassemblyManip))
+    if ((p_FmPcdCcTree->h_IpReassemblyManip)
+            && (p_FmPcdCcTree->h_IpReassemblyManip != h_IpReassemblyManip))
     {
         CcRootReleaseLock(p_FmPcdCcTree);
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This tree was previously updated with different IPR"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("This tree was previously updated with different IPR"));
     }
 
     /* Initialize IPR for the first time for this tree */
     if (isIpv6Present)
     {
         ipv6GroupId = p_FmPcdCcTree->numOfGrps++;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-2);
+        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry =
+                (FM_PCD_MAX_NUM_OF_CC_GROUPS - 2);
 
         if (createSchemes)
         {
-            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, FALSE, ipv6GroupId);
+            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv,
+                                                p_FmPcdCcTree,
+                                                h_IpReassemblyManip, FALSE,
+                                                ipv6GroupId);
             if (err)
             {
                 p_FmPcdCcTree->numOfGrps--;
@@ -4804,19 +5109,21 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
             }
         }
 
-        NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-2) * FM_PCD_CC_AD_ENTRY_SIZE),
-                   NULL,
-                   &nextEngineParams,
-                   h_FmPcd);
+        NextStepAd(
+                PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-2) * FM_PCD_CC_AD_ENTRY_SIZE),
+                NULL, &nextEngineParams, h_FmPcd);
     }
 
     ipv4GroupId = p_FmPcdCcTree->numOfGrps++;
     p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].totalBitsMask = 0;
-    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-1);
+    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry =
+            (FM_PCD_MAX_NUM_OF_CC_GROUPS - 1);
 
     if (createSchemes)
     {
-        err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
+        err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree,
+                                            h_IpReassemblyManip, TRUE,
+                                            ipv4GroupId);
         if (err)
         {
             p_FmPcdCcTree->numOfGrps--;
@@ -4830,10 +5137,9 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
         }
     }
 
-    NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
-               NULL,
-               &nextEngineParams,
-               h_FmPcd);
+    NextStepAd(
+            PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
+            NULL, &nextEngineParams, h_FmPcd);
 
     p_FmPcdCcTree->h_IpReassemblyManip = h_IpReassemblyManip;
 
@@ -4842,6 +5148,78 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
     return E_OK;
 }
 
+t_Error FmPcdCcTreeAddCPR(t_Handle h_FmPcd, t_Handle h_FmTree,
+                          t_Handle h_NetEnv, t_Handle h_ReassemblyManip,
+                          bool createSchemes)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+    t_FmPcdCcNextEngineParams nextEngineParams;
+    t_NetEnvParams netEnvParams;
+    t_Handle h_Ad;
+    uint8_t groupId;
+    t_Error err;
+
+    ASSERT_COND(p_FmPcdCcTree);
+
+    /* this routine must be protected by the calling routine! */
+    memset(&nextEngineParams, 0, sizeof(t_FmPcdCcNextEngineParams));
+    memset(&netEnvParams, 0, sizeof(t_NetEnvParams));
+
+    h_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
+
+    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS - 1))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need one free entries for CPR"));
+
+    nextEngineParams.nextEngine = e_FM_PCD_DONE;
+    nextEngineParams.h_Manip = h_ReassemblyManip;
+
+    /* Lock tree */
+    err = CcRootTryLock(p_FmPcdCcTree);
+    if (err)
+        return ERROR_CODE(E_BUSY);
+
+    if (p_FmPcdCcTree->h_CapwapReassemblyManip == h_ReassemblyManip)
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        return E_OK;
+    }
+
+    if ((p_FmPcdCcTree->h_CapwapReassemblyManip)
+            && (p_FmPcdCcTree->h_CapwapReassemblyManip != h_ReassemblyManip))
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("This tree was previously updated with different CPR"));
+    }
+
+    groupId = p_FmPcdCcTree->numOfGrps++;
+    p_FmPcdCcTree->fmPcdGroupParam[groupId].baseGroupEntry =
+            (FM_PCD_MAX_NUM_OF_CC_GROUPS - 1);
+
+    if (createSchemes)
+    {
+        err = FmPcdManipBuildCapwapReassmScheme(h_FmPcd, h_NetEnv,
+                                                p_FmPcdCcTree,
+                                                h_ReassemblyManip, groupId);
+        if (err)
+        {
+            p_FmPcdCcTree->numOfGrps--;
+            CcRootReleaseLock(p_FmPcdCcTree);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+    }
+
+    NextStepAd(
+            PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
+            NULL, &nextEngineParams, h_FmPcd);
+
+    p_FmPcdCcTree->h_CapwapReassemblyManip = h_ReassemblyManip;
+
+    CcRootReleaseLock(p_FmPcdCcTree);
+
+    return E_OK;
+}
+
 t_Handle FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree)
 {
     t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
@@ -4851,7 +5229,8 @@ t_Handle FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree)
     return p_FmPcdCcTree->h_FmPcdCcSavedManipParams;
 }
 
-void   FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams)
+void FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree,
+                                    t_Handle h_SavedManipParams)
 {
     t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
 
@@ -4887,25 +5266,24 @@ uint16_t FmPcdCcGetNumOfKeys(t_Handle h_CcNode)
     return p_CcNode->numOfKeys;
 }
 
-t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
-                                         t_Handle                   h_FmPcdCcTree,
-                                         uint8_t                    grpId,
-                                         uint8_t                    index,
-                                         t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
+t_Error FmPcdCcModifyNextEngineParamTree(
+        t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcTree                       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    uint16_t                            keyIndex;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    uint16_t keyIndex;
     t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
-    t_Error                             err = E_OK;
+    t_Error err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7), E_INVALID_VALUE);
 
     if (grpId >= p_FmPcdCcTree->numOfGrps)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE,
+                     ("grpId you asked > numOfGroup of relevant tree"));
 
     if (index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
@@ -4915,27 +5293,27 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index);
+    keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry
+            + index);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_FmPcdCcTree, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, TRUE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_FmPcdCcTree, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, FALSE,
+                                             FALSE, TRUE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     p_ModifyKeyParams->tree = TRUE;
 
-    if (p_FmPcd->p_CcShadow &&
-        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    if (p_FmPcd->p_CcShadow
+            && !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
     {
         XX_Free(p_ModifyKeyParams);
         return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine(p_FmPcd,
-                                       p_FmPcdCcTree,
-                                       keyIndex,
+    err = BuildNewNodeModifyNextEngine(p_FmPcd, p_FmPcdCcTree, keyIndex,
                                        p_FmPcdCcNextEngineParams,
-                                       &h_OldPointersLst,
-                                       &h_NewPointersLst,
+                                       &h_OldPointersLst, &h_NewPointersLst,
                                        p_ModifyKeyParams);
     if (err)
     {
@@ -4943,7 +5321,8 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, FALSE);
 
     if (p_FmPcd->p_CcShadow)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -4952,33 +5331,41 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
 
 }
 
-t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
-                         t_Handle   h_FmPcdCcNode,
-                         uint16_t   keyIndex)
+t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                         uint16_t keyIndex)
 {
 
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    bool                                useShadowStructs = FALSE;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    bool useShadowStructs = FALSE;
+    t_Error err = E_OK;
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("impossible to remove key when numOfKeys <= keyIndex"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("impossible to remove key when numOfKeys <= keyIndex"));
 
     if (!p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("handler to FmPcd is different from the handle provided at node initialization time"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_REMOVE, TRUE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_REMOVE, TRUE, TRUE,
+                                             FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -5002,8 +5389,7 @@ t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode, p_ModifyKeyParams,
                                            &h_OldPointersLst,
                                            &h_NewPointersLst);
     if (err)
@@ -5015,11 +5401,8 @@ t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, useShadowStructs);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -5027,45 +5410,49 @@ t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
     return err;
 }
 
-t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
-                         t_Handle   h_FmPcdCcNode,
-                         uint16_t   keyIndex,
-                         uint8_t    keySize,
-                         uint8_t    *p_Key,
-                         uint8_t    *p_Mask)
+t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                         uint16_t keyIndex, uint8_t keySize, uint8_t *p_Key,
+                         uint8_t *p_Mask)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    uint16_t                            tmpKeyIndex;
-    bool                                useShadowStructs = FALSE;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    uint16_t tmpKeyIndex;
+    bool useShadowStructs = FALSE;
+    t_Error err = E_OK;
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("keyIndex > previously cleared last index + 1"));
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size for ModifyKey has to be the same as defined in SetNode"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("size for ModifyKey has to be the same as defined in SetNode"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    err = FindKeyIndex(h_FmPcdCcNode,
-                       keySize,
-                       p_Key,
-                       p_Mask,
-                       &tmpKeyIndex);
+    err = FindKeyIndex(h_FmPcdCcNode, keySize, p_Key, p_Mask, &tmpKeyIndex);
     if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
-        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
-                     ("The received key and mask pair was already found in the match table of the provided node"));
+        RETURN_ERROR(
+                MINOR,
+                E_ALREADY_EXISTS,
+                ("The received key and mask pair was already found in the match table of the provided node"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, TRUE, TRUE,
+                                             FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -5080,10 +5467,7 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
         useShadowStructs = TRUE;
     }
 
-    err = BuildNewNodeModifyKey(p_CcNode,
-                                keyIndex,
-                                p_Key,
-                                p_Mask,
+    err = BuildNewNodeModifyKey(p_CcNode, keyIndex, p_Key, p_Mask,
                                 p_ModifyKeyParams);
     if (err)
     {
@@ -5093,8 +5477,7 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode, p_ModifyKeyParams,
                                            &h_OldPointersLst,
                                            &h_NewPointersLst);
     if (err)
@@ -5106,11 +5489,8 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, useShadowStructs);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -5118,18 +5498,18 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
     return err;
 }
 
-t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
-                                             t_Handle                   h_FmPcdCcNode,
-                                             t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
+t_Error FmPcdCcModifyMissNextEngineParamNode(
+        t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    uint16_t                            keyIndex;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    uint16_t keyIndex;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_Error err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(p_CcNode,E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_VALUE);
 
     keyIndex = p_CcNode->numOfKeys;
 
@@ -5138,23 +5518,22 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, FALSE, TRUE,
+                                             FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    if (p_CcNode->maxNumOfKeys &&
-        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    if (p_CcNode->maxNumOfKeys
+            && !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
     {
         XX_Free(p_ModifyKeyParams);
         return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine(h_FmPcd,
-                                       p_CcNode,
-                                       keyIndex,
+    err = BuildNewNodeModifyNextEngine(h_FmPcd, p_CcNode, keyIndex,
                                        p_FmPcdCcNextEngineParams,
-                                       &h_OldPointersLst,
-                                       &h_NewPointersLst,
+                                       &h_OldPointersLst, &h_NewPointersLst,
                                        p_ModifyKeyParams);
     if (err)
     {
@@ -5164,7 +5543,8 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, FALSE);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -5172,56 +5552,64 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
     return err;
 }
 
-t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
-                      t_Handle              h_FmPcdCcNode,
-                      uint16_t              keyIndex,
-                      uint8_t               keySize,
-                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                      uint16_t keyIndex, uint8_t keySize,
+                      t_FmPcdCcKeyParams *p_FmPcdCcKeyParams)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    bool                                useShadowStructs = FALSE;
-    uint16_t                            tmpKeyIndex;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    bool useShadowStructs = FALSE;
+    uint16_t tmpKeyIndex;
+    t_Error err = E_OK;
 
     if (keyIndex > p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("keyIndex > previously cleared last index + 1"));
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE,
+                     ("keyIndex > previously cleared last index + 1"));
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("keySize has to be defined as it was defined in initialization step"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("handler to FmPcd is different from the handle provided at node initialization time"));
 
     if (p_CcNode->maxNumOfKeys)
     {
         if (p_CcNode->numOfKeys == p_CcNode->maxNumOfKeys)
-            RETURN_ERROR(MAJOR, E_FULL, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_FULL,
+                    ("number of keys exceeds the maximal number of keys provided at node initialization time"));
     }
-    else if (p_CcNode->numOfKeys == FM_PCD_MAX_NUM_OF_KEYS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys can not be larger than %d", FM_PCD_MAX_NUM_OF_KEYS));
-
-    err = FindKeyIndex(h_FmPcdCcNode,
-                       keySize,
-                       p_FmPcdCcKeyParams->p_Key,
-                       p_FmPcdCcKeyParams->p_Mask,
-                       &tmpKeyIndex);
+    else
+        if (p_CcNode->numOfKeys == FM_PCD_MAX_NUM_OF_KEYS)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("number of keys can not be larger than %d", FM_PCD_MAX_NUM_OF_KEYS));
+
+    err = FindKeyIndex(h_FmPcdCcNode, keySize, p_FmPcdCcKeyParams->p_Key,
+                       p_FmPcdCcKeyParams->p_Mask, &tmpKeyIndex);
     if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
-        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS,
-                     ("The received key and mask pair was already found in the match table of the provided node"));
+        RETURN_ERROR(
+                MAJOR,
+                E_ALREADY_EXISTS,
+                ("The received key and mask pair was already found in the match table of the provided node"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode,
-                                             keyIndex,
-                                             e_MODIFY_STATE_ADD,
-                                             TRUE,
-                                             TRUE,
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_ADD, TRUE, TRUE,
                                              FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
@@ -5237,12 +5625,9 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         useShadowStructs = TRUE;
     }
 
-    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
-                                                 p_CcNode,
-                                                 keyIndex,
-                                                 p_FmPcdCcKeyParams,
-                                                 p_ModifyKeyParams,
-                                                 TRUE);
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine(h_FmPcd, p_CcNode, keyIndex,
+                                                p_FmPcdCcKeyParams,
+                                                p_ModifyKeyParams, TRUE);
     if (err)
     {
         ReleaseNewNodeCommonPart(p_ModifyKeyParams);
@@ -5252,8 +5637,7 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode, p_ModifyKeyParams,
                                            &h_OldPointersLst,
                                            &h_NewPointersLst);
     if (err)
@@ -5265,55 +5649,58 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, useShadowStructs);
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
 
     return err;
 }
 
-t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
-                                      t_Handle              h_FmPcdCcNode,
-                                      uint16_t              keyIndex,
-                                      uint8_t               keySize,
-                                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                                      uint16_t keyIndex, uint8_t keySize,
+                                      t_FmPcdCcKeyParams *p_FmPcdCcKeyParams)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    uint16_t                            tmpKeyIndex;
-    bool                                useShadowStructs = FALSE;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    uint16_t tmpKeyIndex;
+    bool useShadowStructs = FALSE;
+    t_Error err = E_OK;
 
     if (keyIndex > p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("keyIndex > previously cleared last index + 1"));
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("keySize has to be defined as it was defined in initialization step"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    err = FindKeyIndex(h_FmPcdCcNode,
-                       keySize,
-                       p_FmPcdCcKeyParams->p_Key,
-                       p_FmPcdCcKeyParams->p_Mask,
-                       &tmpKeyIndex);
+    err = FindKeyIndex(h_FmPcdCcNode, keySize, p_FmPcdCcKeyParams->p_Key,
+                       p_FmPcdCcKeyParams->p_Mask, &tmpKeyIndex);
     if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
-        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
-                     ("The received key and mask pair was already found in the match table of the provided node"));
+        RETURN_ERROR(
+                MINOR,
+                E_ALREADY_EXISTS,
+                ("The received key and mask pair was already found in the match table of the provided node"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, TRUE, TRUE,
+                                             FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -5328,12 +5715,9 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
         useShadowStructs = TRUE;
     }
 
-    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
-                                                 p_CcNode,
-                                                 keyIndex,
-                                                 p_FmPcdCcKeyParams,
-                                                 p_ModifyKeyParams,
-                                                 FALSE);
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine(h_FmPcd, p_CcNode, keyIndex,
+                                                p_FmPcdCcKeyParams,
+                                                p_ModifyKeyParams, FALSE);
     if (err)
     {
         ReleaseNewNodeCommonPart(p_ModifyKeyParams);
@@ -5343,8 +5727,7 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode, p_ModifyKeyParams,
                                            &h_OldPointersLst,
                                            &h_NewPointersLst);
     if (err)
@@ -5356,11 +5739,8 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, useShadowStructs);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -5368,26 +5748,31 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
     return err;
 }
 
-uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer)
+uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd,
+                                              t_Handle h_Pointer)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_CcNodeInformation             *p_CcNodeInfo;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_CcNodeInformation *p_CcNodeInfo;
 
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE,
+                              (uint32_t)ILLEGAL_BASE);
 
     p_CcNodeInfo = CC_NODE_F_OBJECT(h_Pointer);
 
-    return (uint32_t)(XX_VirtToPhys(p_CcNodeInfo->h_CcNode) - p_FmPcd->physicalMuramBase);
+    return (uint32_t)(XX_VirtToPhys(p_CcNodeInfo->h_CcNode)
+            - p_FmPcd->physicalMuramBase);
 }
 
-t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase)
+t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId,
+                            uint32_t *p_GrpBits, uint8_t *p_GrpBase)
 {
-    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *) h_FmPcdCcTree;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
 
     if (grpId >= p_FmPcdCcTree->numOfGrps)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE,
+                     ("grpId you asked > numOfGroup of relevant tree"));
 
     *p_GrpBits = p_FmPcdCcTree->fmPcdGroupParam[grpId].totalBitsMask;
     *p_GrpBase = p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry;
@@ -5395,15 +5780,13 @@ t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_G
     return E_OK;
 }
 
-t_Error  FmPcdCcBindTree(t_Handle h_FmPcd,
-                         t_Handle h_PcdParams,
-                         t_Handle h_FmPcdCcTree,
-                         uint32_t *p_Offset,
-                         t_Handle h_FmPort)
+t_Error FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                        t_Handle h_FmPcdCcTree, uint32_t *p_Offset,
+                        t_Handle h_FmPort)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
-    t_Error             err = E_OK;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
@@ -5415,39 +5798,42 @@ t_Error  FmPcdCcBindTree(t_Handle h_FmPcd,
     if (err == E_OK)
         UpdateCcRootOwner(p_FmPcdCcTree, TRUE);
 
-    *p_Offset = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr)) -
-                           p_FmPcd->physicalMuramBase);
+    *p_Offset = (uint32_t)(XX_VirtToPhys(
+            UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr))
+            - p_FmPcd->physicalMuramBase);
 
     return err;
 }
 
-t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
+t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree)
 {
-    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     /* this routine must be protected by the calling routine by locking all PCD modules! */
 
     UNUSED(h_FmPcd);
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
 
     UpdateCcRootOwner(p_FmPcdCcTree, FALSE);
 
     return E_OK;
 }
 
-t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
+t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                               t_List *p_List)
 {
-    t_FmPcdCcNode           *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_List                  *p_Pos, *p_Tmp;
-    t_CcNodeInformation     *p_CcNodeInfo, nodeInfo;
-    uint32_t                intFlags;
-    t_Error                 err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_List *p_Pos, *p_Tmp;
+    t_CcNodeInformation *p_CcNodeInfo, nodeInfo;
+    uint32_t intFlags;
+    t_Error err = E_OK;
 
     intFlags = FmPcdLock(h_FmPcd);
 
-    if (LIST_IsEmpty(&p_CcNode->ccTreesLst))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"));
+ //   if (LIST_IsEmpty(&p_CcNode->ccTreesLst))
+   //     RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+  //                   ("asked for more nodes in CC than MAX"));
 
     LIST_FOR_EACH(p_Pos, &p_CcNode->ccTreesLst)
     {
@@ -5481,10 +5867,10 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *
 
 void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
 {
-    t_List              *p_Pos;
+    t_List *p_Pos;
     t_CcNodeInformation *p_CcNodeInfo;
-    t_Handle            h_FmPcdCcTree;
-    uint32_t            intFlags;
+    t_Handle h_FmPcdCcTree;
+    uint32_t intFlags;
 
     intFlags = FmPcdLock(h_FmPcd);
 
@@ -5501,12 +5887,11 @@ void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
     CORE_MemoryBarrier();
 }
 
-
-t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
+t_Error FmPcdUpdateCcShadow(t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
 {
-    uint32_t    intFlags;
-    uint32_t    newSize = 0, newAlign = 0;
-    bool        allocFail = FALSE;
+    uint32_t intFlags;
+    uint32_t newSize = 0, newAlign = 0;
+    bool allocFail = FALSE;
 
     ASSERT_COND(p_FmPcd);
 
@@ -5516,7 +5901,7 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
     if (!POWER_OF_2(align))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("alignment must be power of 2"));
 
-    newSize  = p_FmPcd->ccShadowSize;
+    newSize = p_FmPcd->ccShadowSize;
     newAlign = p_FmPcd->ccShadowAlign;
 
     /* Check if current shadow is large enough to hold the requested size */
@@ -5528,38 +5913,39 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
         newAlign = align;
 
     /* If a bigger shadow size or bigger shadow alignment are required,
-       a new shadow will be allocated */
-    if ((newSize != p_FmPcd->ccShadowSize) || (newAlign != p_FmPcd->ccShadowAlign))
+     a new shadow will be allocated */
+    if ((newSize != p_FmPcd->ccShadowSize)
+            || (newAlign != p_FmPcd->ccShadowAlign))
     {
         intFlags = FmPcdLock(p_FmPcd);
 
         if (p_FmPcd->p_CcShadow)
         {
             FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), p_FmPcd->p_CcShadow);
-            p_FmPcd->ccShadowSize  = 0;
+            p_FmPcd->ccShadowSize = 0;
             p_FmPcd->ccShadowAlign = 0;
         }
 
         p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                                newSize,
-                                                newAlign);
+                                                newSize, newAlign);
         if (!p_FmPcd->p_CcShadow)
         {
             allocFail = TRUE;
 
             /* If new shadow size allocation failed,
-               re-allocate with previous parameters */
-            p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                                    p_FmPcd->ccShadowSize,
-                                                    p_FmPcd->ccShadowAlign);
+             re-allocate with previous parameters */
+            p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(
+                    FmPcdGetMuramHandle(p_FmPcd), p_FmPcd->ccShadowSize,
+                    p_FmPcd->ccShadowAlign);
         }
 
         FmPcdUnlock(p_FmPcd, intFlags);
 
         if (allocFail)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Shadow memory"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC Shadow memory"));
 
-        p_FmPcd->ccShadowSize  = newSize;
+        p_FmPcd->ccShadowSize = newSize;
         p_FmPcd->ccShadowAlign = newAlign;
     }
 
@@ -5567,15 +5953,15 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
 }
 
 #if (DPAA_VERSION >= 11)
-void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
-                                              t_Handle  h_ReplicGroup,
-                                              t_List    *p_AdTables,
-                                              uint32_t  *p_NumOfAdTables)
+void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle h_Node,
+                                              t_Handle h_ReplicGroup,
+                                              t_List *p_AdTables,
+                                              uint32_t *p_NumOfAdTables)
 {
-    t_FmPcdCcNode           *p_CurrentNode = (t_FmPcdCcNode *)h_Node;
-    int                     i = 0;
-    void *                  p_AdTable;
-    t_CcNodeInformation     ccNodeInfo;
+    t_FmPcdCcNode *p_CurrentNode = (t_FmPcdCcNode *)h_Node;
+    int i = 0;
+    void * p_AdTable;
+    t_CcNodeInformation ccNodeInfo;
 
     ASSERT_COND(h_Node);
     *p_NumOfAdTables = 0;
@@ -5583,12 +5969,15 @@ void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
     /* search in the current node which exact index points on this current replicator group for getting AD */
     for (i = 0; i < p_CurrentNode->numOfKeys + 1; i++)
     {
-        if ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic == (t_Handle)h_ReplicGroup)))
+        if ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic
+                        == (t_Handle)h_ReplicGroup)))
         {
             /* save the current ad table in the list */
             /* this entry uses the input replicator group */
-            p_AdTable = PTR_MOVE(p_CurrentNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+            p_AdTable =
+                    PTR_MOVE(p_CurrentNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
             memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
             ccNodeInfo.h_CcNode = p_AdTable;
             EnqueueNodeInfoToRelevantLst(p_AdTables, &ccNodeInfo, NULL);
@@ -5601,29 +5990,29 @@ void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
 #endif /* (DPAA_VERSION >= 11) */
 /*********************** End of inter-module routines ************************/
 
-
 /****************************************/
 /*       API Init unit functions        */
 /****************************************/
 
-t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam)
+t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd,
+                            t_FmPcdCcTreeParams *p_PcdGroupsParam)
 {
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_Error                     err = E_OK;
-    int                         i = 0, j = 0, k = 0;
-    t_FmPcdCcTree               *p_FmPcdCcTree;
-    uint8_t                     numOfEntries;
-    t_Handle                    p_CcTreeTmp;
-    t_FmPcdCcGrpParams          *p_FmPcdCcGroupParams;
-    t_FmPcdCcKeyAndNextEngineParams   *p_Params, *p_KeyAndNextEngineParams;
-    t_NetEnvParams              netEnvParams;
-    uint8_t                     lastOne = 0;
-    uint32_t                    requiredAction = 0;
-    t_FmPcdCcNode               *p_FmPcdCcNextNode;
-    t_CcNodeInformation         ccNodeInfo, *p_CcInformation;
-
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam,E_INVALID_HANDLE, NULL);
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_Error err = E_OK;
+    int i = 0, j = 0, k = 0;
+    t_FmPcdCcTree *p_FmPcdCcTree;
+    uint8_t numOfEntries;
+    t_Handle p_CcTreeTmp;
+    t_FmPcdCcGrpParams *p_FmPcdCcGroupParams;
+    t_FmPcdCcKeyAndNextEngineParams *p_Params, *p_KeyAndNextEngineParams;
+    t_NetEnvParams netEnvParams;
+    uint8_t lastOne = 0;
+    uint32_t requiredAction = 0;
+    t_FmPcdCcNode *p_FmPcdCcNextNode;
+    t_CcNodeInformation ccNodeInfo, *p_CcInformation;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam, E_INVALID_HANDLE, NULL);
 
     if (p_PcdGroupsParam->numOfGrps > FM_PCD_MAX_NUM_OF_CC_GROUPS)
     {
@@ -5640,17 +6029,22 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree));
     p_FmPcdCcTree->h_FmPcd = h_FmPcd;
 
-    p_Params = (t_FmPcdCcKeyAndNextEngineParams*)XX_Malloc(FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
-    memset(p_Params, 0, FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+    p_Params = (t_FmPcdCcKeyAndNextEngineParams*)XX_Malloc(
+            FM_PCD_MAX_NUM_OF_CC_GROUPS
+                    * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+    memset(p_Params,
+           0,
+           FM_PCD_MAX_NUM_OF_CC_GROUPS
+                   * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
     INIT_LIST(&p_FmPcdCcTree->fmPortsLst);
 
 #ifdef FM_CAPWAP_SUPPORT
     if ((p_PcdGroupsParam->numOfGrps == 1) &&
-        (p_PcdGroupsParam->ccGrpParams[0].numOfDistinctionUnits == 0) &&
-        (p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].nextEngine == e_FM_PCD_CC) &&
-        p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode &&
-        IsCapwapApplSpecific(p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode))
+            (p_PcdGroupsParam->ccGrpParams[0].numOfDistinctionUnits == 0) &&
+            (p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].nextEngine == e_FM_PCD_CC) &&
+            p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode &&
+            IsCapwapApplSpecific(p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode))
     {
         p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip = FmPcdManipApplSpecificBuild();
         if (!p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip)
@@ -5670,21 +6064,23 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     {
         p_FmPcdCcGroupParams = &p_PcdGroupsParam->ccGrpParams[i];
 
-        if (p_FmPcdCcGroupParams->numOfDistinctionUnits > FM_PCD_MAX_NUM_OF_CC_UNITS)
+        if (p_FmPcdCcGroupParams->numOfDistinctionUnits
+                > FM_PCD_MAX_NUM_OF_CC_UNITS)
         {
-            DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            DeleteTree(p_FmPcdCcTree, p_FmPcd);
             XX_Free(p_Params);
             REPORT_ERROR(MAJOR, E_INVALID_VALUE,
-                         ("numOfDistinctionUnits (group %d) should not exceed %d", i, FM_PCD_MAX_NUM_OF_CC_UNITS));
+                    ("numOfDistinctionUnits (group %d) should not exceed %d", i, FM_PCD_MAX_NUM_OF_CC_UNITS));
             return NULL;
         }
 
         p_FmPcdCcTree->fmPcdGroupParam[i].baseGroupEntry = numOfEntries;
-        p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup =(uint8_t)( 0x01 << p_FmPcdCcGroupParams->numOfDistinctionUnits);
+        p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup = (uint8_t)(0x01
+                << p_FmPcdCcGroupParams->numOfDistinctionUnits);
         numOfEntries += p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
         if (numOfEntries > FM_PCD_MAX_NUM_OF_CC_GROUPS)
         {
-            DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            DeleteTree(p_FmPcdCcTree, p_FmPcd);
             XX_Free(p_Params);
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("numOfEntries can not be larger than %d", FM_PCD_MAX_NUM_OF_CC_GROUPS));
             return NULL;
@@ -5694,7 +6090,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         {
             if (p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
             {
-                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                DeleteTree(p_FmPcdCcTree, p_FmPcd);
                 XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, E_CONFLICT, ("numOfEntries per group must be set in descending order"));
                 return NULL;
@@ -5704,30 +6100,32 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         lastOne = p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
 
         netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
-        netEnvParams.numOfDistinctionUnits = p_FmPcdCcGroupParams->numOfDistinctionUnits;
+        netEnvParams.numOfDistinctionUnits =
+                p_FmPcdCcGroupParams->numOfDistinctionUnits;
 
-        memcpy(netEnvParams.unitIds,
-               &p_FmPcdCcGroupParams->unitIds,
+        memcpy(netEnvParams.unitIds, &p_FmPcdCcGroupParams->unitIds,
                (sizeof(uint8_t)) * p_FmPcdCcGroupParams->numOfDistinctionUnits);
 
         err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
         if (err)
         {
-            DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            DeleteTree(p_FmPcdCcTree, p_FmPcd);
             XX_Free(p_Params);
             REPORT_ERROR(MAJOR, err, NO_MSG);
             return NULL;
         }
 
         p_FmPcdCcTree->fmPcdGroupParam[i].totalBitsMask = netEnvParams.vector;
-        for (j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup; j++)
+        for (j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
+                j++)
         {
-            err = ValidateNextEngineParams(h_FmPcd,
-                                           &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
-                                           e_FM_PCD_CC_STATS_MODE_NONE);
+            err = ValidateNextEngineParams(
+                    h_FmPcd,
+                    &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
+                    e_FM_PCD_CC_STATS_MODE_NONE);
             if (err)
             {
-                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                DeleteTree(p_FmPcdCcTree, p_FmPcd);
                 XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, err, (NO_MSG));
                 return NULL;
@@ -5735,28 +6133,33 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
             if (p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j].h_Manip)
             {
-                err = FmPcdManipCheckParamsForCcNextEngine(&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], &requiredAction);
+                err = FmPcdManipCheckParamsForCcNextEngine(
+                        &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
+                        &requiredAction);
                 if (err)
                 {
-                    DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                    DeleteTree(p_FmPcdCcTree, p_FmPcd);
                     XX_Free(p_Params);
                     REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                     return NULL;
                 }
             }
-            p_KeyAndNextEngineParams = p_Params+k;
+            p_KeyAndNextEngineParams = p_Params + k;
 
             memcpy(&p_KeyAndNextEngineParams->nextEngineParams,
                    &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
                    sizeof(t_FmPcdCcNextEngineParams));
 
-            if ((p_KeyAndNextEngineParams->nextEngineParams.nextEngine == e_FM_PCD_CC)
-                && p_KeyAndNextEngineParams->nextEngineParams.h_Manip)
+            if ((p_KeyAndNextEngineParams->nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
+                    && p_KeyAndNextEngineParams->nextEngineParams.h_Manip)
             {
-                err = AllocAndFillAdForContLookupManip(p_KeyAndNextEngineParams->nextEngineParams.params.ccParams.h_CcNode);
+                err =
+                        AllocAndFillAdForContLookupManip(
+                                p_KeyAndNextEngineParams->nextEngineParams.params.ccParams.h_CcNode);
                 if (err)
                 {
-                    DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                    DeleteTree(p_FmPcdCcTree, p_FmPcd);
                     XX_Free(p_Params);
                     REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Tree"));
                     return NULL;
@@ -5774,17 +6177,19 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     p_FmPcdCcTree->numOfGrps = p_PcdGroupsParam->numOfGrps;
 
     p_FmPcdCcTree->ccTreeBaseAddr =
-        PTR_TO_UINT(FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
-                                      (uint32_t)( FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE),
-                                      FM_PCD_CC_TREE_ADDR_ALIGN));
+            PTR_TO_UINT(FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
+                            (uint32_t)( FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE),
+                            FM_PCD_CC_TREE_ADDR_ALIGN));
     if (!p_FmPcdCcTree->ccTreeBaseAddr)
     {
-        DeleteTree(p_FmPcdCcTree,p_FmPcd);
+        DeleteTree(p_FmPcdCcTree, p_FmPcd);
         XX_Free(p_Params);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Tree"));
         return NULL;
     }
-    IOMemSet32(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr), 0, (uint32_t)(FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32(
+            UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr), 0,
+            (uint32_t)(FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE));
 
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
@@ -5793,10 +6198,8 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     {
         p_KeyAndNextEngineParams = p_Params + i;
 
-        NextStepAd(p_CcTreeTmp,
-                   NULL,
-                   &p_KeyAndNextEngineParams->nextEngineParams,
-                   p_FmPcd);
+        NextStepAd(p_CcTreeTmp, NULL,
+                   &p_KeyAndNextEngineParams->nextEngineParams, p_FmPcd);
 
         p_CcTreeTmp = PTR_MOVE(p_CcTreeTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -5804,12 +6207,14 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
                p_KeyAndNextEngineParams,
                sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
-        if (p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
+        if (p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
         {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
-            p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,
-                                                        (t_Handle)p_FmPcdCcTree,
-                                                        p_FmPcdCcNextNode->h_Spinlock);
+            p_FmPcdCcNextNode =
+                    (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+            p_CcInformation = FindNodeInfoInReleventLst(
+                    &p_FmPcdCcNextNode->ccTreeIdLst, (t_Handle)p_FmPcdCcTree,
+                    p_FmPcdCcNextNode->h_Spinlock);
 
             if (!p_CcInformation)
             {
@@ -5828,24 +6233,23 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     FmPcdIncNetEnvOwners(h_FmPcd, p_FmPcdCcTree->netEnvId);
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-     if (!FmPcdLockTryLockAll(p_FmPcd))
+    if (!FmPcdLockTryLockAll(p_FmPcd))
     {
-         FM_PCD_CcRootDelete(p_FmPcdCcTree);
-         XX_Free(p_Params);
-         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
-         return NULL;
+        FM_PCD_CcRootDelete(p_FmPcdCcTree);
+        XX_Free(p_Params);
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return NULL;
     }
 
     for (i = 0; i < numOfEntries; i++)
     {
         if (p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
         {
-            err = SetRequiredAction(h_FmPcd,
-                                    p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction,
-                                    &p_FmPcdCcTree->keyAndNextEngineParams[i],
-                                    p_CcTreeTmp,
-                                    1,
-                                    p_FmPcdCcTree);
+            err = SetRequiredAction(
+                    h_FmPcd,
+                    p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction,
+                    &p_FmPcdCcTree->keyAndNextEngineParams[i], p_CcTreeTmp, 1,
+                    p_FmPcdCcTree);
             if (err)
             {
                 FmPcdLockUnlockAll(p_FmPcd);
@@ -5875,51 +6279,68 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
 t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcTree   *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
-    int             i= 0;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcTree *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
+    int i = 0;
 
-    SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcTree, E_INVALID_STATE);
     p_FmPcd = (t_FmPcd *)p_CcTree->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
     FmPcdDecNetEnvOwners(p_FmPcd, p_CcTree->netEnvId);
 
     if (p_CcTree->owners)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_SELECTION,
+                ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
 
-    /* Delete reassembly schemes if exist */
+    /* Delete ip-reassembly schemes if exist */
     if (p_CcTree->h_IpReassemblyManip)
     {
         FmPcdManipDeleteIpReassmSchemes(p_CcTree->h_IpReassemblyManip);
         FmPcdManipUpdateOwner(p_CcTree->h_IpReassemblyManip, FALSE);
     }
 
-    for (i = 0; i <p_CcTree->numOfEntries; i++)
+    /* Delete capwap-reassembly schemes if exist */
+    if (p_CcTree->h_CapwapReassemblyManip)
+    {
+        FmPcdManipDeleteCapwapReassmSchemes(p_CcTree->h_CapwapReassemblyManip);
+        FmPcdManipUpdateOwner(p_CcTree->h_CapwapReassemblyManip, FALSE);
+    }
+
+    for (i = 0; i < p_CcTree->numOfEntries; i++)
     {
-        if (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            UpdateNodeOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+        if (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            UpdateNodeOwner(
+                    p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode,
+                    FALSE);
 
         if (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
-            FmPcdManipUpdateOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.h_Manip, FALSE);
+            FmPcdManipUpdateOwner(
+                    p_CcTree->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                    FALSE);
 
 #ifdef FM_CAPWAP_SUPPORT
         if ((p_CcTree->numOfGrps == 1) &&
-            (p_CcTree->fmPcdGroupParam[0].numOfEntriesInGroup == 1) &&
-            (p_CcTree->keyAndNextEngineParams[0].nextEngineParams.nextEngine == e_FM_PCD_CC) &&
-            p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode &&
-            IsCapwapApplSpecific(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode))
+                (p_CcTree->fmPcdGroupParam[0].numOfEntriesInGroup == 1) &&
+                (p_CcTree->keyAndNextEngineParams[0].nextEngineParams.nextEngine == e_FM_PCD_CC) &&
+                p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode &&
+                IsCapwapApplSpecific(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode))
         {
             if (FM_PCD_ManipNodeDelete(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.h_Manip) != E_OK)
-                return E_INVALID_STATE;
+            return E_INVALID_STATE;
         }
 #endif /* FM_CAPWAP_SUPPORT */
 
 #if (DPAA_VERSION >= 11)
-        if ((p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
-            FrmReplicGroupUpdateOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
-                                      FALSE);
+        if ((p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
+            FrmReplicGroupUpdateOwner(
+                    p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
+                    FALSE);
 #endif /* (DPAA_VERSION >= 11) */
     }
 
@@ -5931,17 +6352,16 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
     return E_OK;
 }
 
-t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
-                                      uint8_t                   grpId,
-                                      uint8_t                   index,
-                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_CcRootModifyNextEngine(
+        t_Handle h_CcTree, uint8_t grpId, uint8_t index,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcTree   *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcTree *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcTree, E_INVALID_STATE);
     p_FmPcd = (t_FmPcd *)p_CcTree->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
@@ -5951,10 +6371,7 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcModifyNextEngineParamTree(p_FmPcd,
-                                           p_CcTree,
-                                           grpId,
-                                           index,
+    err = FmPcdCcModifyNextEngineParamTree(p_FmPcd, p_CcTree, grpId, index,
                                            p_FmPcdCcNextEngineParams);
     FmPcdLockUnlockAll(p_FmPcd);
 
@@ -5966,10 +6383,11 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
     return E_OK;
 }
 
-t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
+t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd,
+                              t_FmPcdCcNodeParams *p_CcNodeParam)
 {
-    t_FmPcdCcNode   *p_CcNode;
-    t_Error         err;
+    t_FmPcdCcNode *p_CcNode;
+    t_Error err;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_CcNodeParam, E_NULL_POINTER, NULL);
@@ -5984,18 +6402,18 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
     err = MatchTableSet(h_FmPcd, p_CcNode, p_CcNodeParam);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            break;
+        break;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return NULL;
+        DBG(TRACE, ("E_BUSY error"));
+        return NULL;
 
         default:
-            REPORT_ERROR(MAJOR, err, NO_MSG);
-            return NULL;
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
     }
 
     return p_CcNode;
@@ -6003,9 +6421,9 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
 t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    int             i = 0;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    int i = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
@@ -6014,27 +6432,40 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
     UNUSED(p_FmPcd);
 
     if (p_CcNode->owners)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This node cannot be removed because it is occupied; first unbind this node"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("This node cannot be removed because it is occupied; first unbind this node"));
 
     for (i = 0; i < p_CcNode->numOfKeys; i++)
-        if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
-
-    if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+        if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            UpdateNodeOwner(
+                    p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode,
+                    FALSE);
+
+    if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
+        UpdateNodeOwner(
+                p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode,
+                FALSE);
 
     /* Handle also Miss entry */
     for (i = 0; i < p_CcNode->numOfKeys + 1; i++)
     {
         if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
-            FmPcdManipUpdateOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip, FALSE);
+            FmPcdManipUpdateOwner(
+                    p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                    FALSE);
 
 #if (DPAA_VERSION >= 11)
-        if ((p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
+        if ((p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
         {
-            FrmReplicGroupUpdateOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
-                                      FALSE);
+            FrmReplicGroupUpdateOwner(
+                    p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
+                    FALSE);
         }
 #endif /* (DPAA_VERSION >= 11) */
     }
@@ -6044,14 +6475,13 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
-                                uint16_t            keyIndex,
-                                uint8_t             keySize,
-                                t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_MatchTableAddKey(t_Handle h_CcNode, uint16_t keyIndex,
+                                uint8_t keySize,
+                                t_FmPcdCcKeyParams *p_KeyParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6068,33 +6498,29 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcAddKey(p_FmPcd,
-                        p_CcNode,
-                        keyIndex,
-                        keySize,
-                        p_KeyParams);
+    err = FmPcdCcAddKey(p_FmPcd, p_CcNode, keyIndex, keySize, p_KeyParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
 t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
@@ -6111,32 +6537,30 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
-                                   uint16_t keyIndex,
-                                   uint8_t  keySize,
-                                   uint8_t  *p_Key,
-                                   uint8_t  *p_Mask)
+t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode, uint16_t keyIndex,
+                                   uint8_t keySize, uint8_t *p_Key,
+                                   uint8_t *p_Mask)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List h_List;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
@@ -6153,36 +6577,31 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcModifyKey(p_FmPcd,
-                           p_CcNode,
-                           keyIndex,
-                           keySize,
-                           p_Key,
-                           p_Mask);
+    err = FmPcdCcModifyKey(p_FmPcd, p_CcNode, keyIndex, keySize, p_Key, p_Mask);
 
     FmPcdCcNodeTreeReleaseLock(p_FmPcd, &h_List);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
-                                          uint16_t keyIndex,
-                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableModifyNextEngine(
+        t_Handle h_CcNode, uint16_t keyIndex,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6196,33 +6615,31 @@ t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = ModifyNextEngineParamNode(p_FmPcd,
-                                    p_CcNode,
-                                    keyIndex,
+    err = ModifyNextEngineParamNode(p_FmPcd, p_CcNode, keyIndex,
                                     p_FmPcdCcNextEngineParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                      h_CcNode,
-                                              t_FmPcdCcNextEngineParams     *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableModifyMissNextEngine(
+        t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6236,34 +6653,33 @@ t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                      h_Cc
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcModifyMissNextEngineParamNode(p_FmPcd,
-                                               p_CcNode,
+    err = FmPcdCcModifyMissNextEngineParamNode(p_FmPcd, p_CcNode,
                                                p_FmPcdCcNextEngineParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
-                                                uint16_t    keyIndex,
-                                                uint8_t     keySize,
-                                                t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle h_CcNode,
+                                                uint16_t keyIndex,
+                                                uint8_t keySize,
+                                                t_FmPcdCcKeyParams *p_KeyParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6277,38 +6693,32 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd,
-                                        p_CcNode,
-                                        keyIndex,
-                                        keySize,
+    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd, p_CcNode, keyIndex, keySize,
                                         p_KeyParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-
-t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
-                                        uint8_t  keySize,
-                                        uint8_t  *p_Key,
-                                        uint8_t  *p_Mask)
+t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode, uint8_t keySize,
+                                        uint8_t *p_Key, uint8_t *p_Mask)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t        keyIndex;
-    t_Error         err;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t keyIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6326,38 +6736,38 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdLockUnlockAll(p_FmPcd);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+        RETURN_ERROR(
+                MAJOR,
+                err,
+                ("The received key and mask pair was not found in the match table of the provided node"));
     }
 
     err = FmPcdCcRemoveKey(p_FmPcd, p_CcNode, keyIndex);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-
-t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNode,
-                                               uint8_t                   keySize,
-                                               uint8_t                   *p_Key,
-                                               uint8_t                   *p_Mask,
-                                               t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableFindNModifyNextEngine(
+        t_Handle h_CcNode, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t        keyIndex;
-    t_Error         err;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t keyIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -6376,40 +6786,39 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdLockUnlockAll(p_FmPcd);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+        RETURN_ERROR(
+                MAJOR,
+                err,
+                ("The received key and mask pair was not found in the match table of the provided node"));
     }
 
-    err = ModifyNextEngineParamNode(p_FmPcd,
-                                    p_CcNode,
-                                    keyIndex,
+    err = ModifyNextEngineParamNode(p_FmPcd, p_CcNode, keyIndex,
                                     p_FmPcdCcNextEngineParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNode,
-                                                     uint8_t             keySize,
-                                                     uint8_t             *p_Key,
-                                                     uint8_t             *p_Mask,
-                                                     t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(
+        t_Handle h_CcNode, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask,
+        t_FmPcdCcKeyParams *p_KeyParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t        keyIndex;
-    t_Error         err;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t keyIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
@@ -6428,43 +6837,40 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdLockUnlockAll(p_FmPcd);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+        RETURN_ERROR(
+                MAJOR,
+                err,
+                ("The received key and mask pair was not found in the match table of the provided node"));
     }
 
-    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd,
-                                        h_CcNode,
-                                        keyIndex,
-                                        keySize,
+    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd, h_CcNode, keyIndex, keySize,
                                         p_KeyParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
-                                        uint8_t  keySize,
-                                        uint8_t  *p_Key,
-                                        uint8_t  *p_Mask,
-                                        uint8_t  *p_NewKey,
-                                        uint8_t  *p_NewMask)
+t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode, uint8_t keySize,
+                                        uint8_t *p_Key, uint8_t *p_Mask,
+                                        uint8_t *p_NewKey, uint8_t *p_NewMask)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
-    uint16_t        keyIndex;
-    t_Error         err;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List h_List;
+    uint16_t keyIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_NewKey, E_NULL_POINTER);
@@ -6486,47 +6892,48 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(p_FmPcd, &h_List);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the "
-                                  "match table of the provided node"));
+        RETURN_ERROR(MAJOR, err,
+                     ("The received key and mask pair was not found in the "
+                     "match table of the provided node"));
     }
 
-    err = FmPcdCcModifyKey(p_FmPcd,
-                           p_CcNode,
-                           keyIndex,
-                           keySize,
-                           p_NewKey,
+    err = FmPcdCcModifyKey(p_FmPcd, p_CcNode, keyIndex, keySize, p_NewKey,
                            p_NewMask);
 
     FmPcdCcNodeTreeReleaseLock(p_FmPcd, &h_List);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
-                                       uint16_t                     keyIndex,
-                                       t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableGetNextEngine(
+        t_Handle h_CcNode, uint16_t keyIndex,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex exceeds current number of keys"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("keyIndex exceeds current number of keys"));
 
     if (keyIndex > (FM_PCD_MAX_NUM_OF_KEYS - 1))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex can not be larger than %d", (FM_PCD_MAX_NUM_OF_KEYS - 1)));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("keyIndex can not be larger than %d", (FM_PCD_MAX_NUM_OF_KEYS - 1)));
 
     memcpy(p_FmPcdCcNextEngineParams,
            &p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams,
@@ -6538,9 +6945,9 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
 
 uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            *p_StatsCounters, frameCount;
-    uint32_t            intFlags;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t *p_StatsCounters, frameCount;
+    uint32_t intFlags;
 
     SANITY_CHECK_RETURN_VALUE(p_CcNode, E_INVALID_HANDLE, 0);
 
@@ -6550,8 +6957,9 @@ uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
         return 0;
     }
 
-    if ((p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_FRAME) &&
-        (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
+    if ((p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_FRAME)
+            && (p_CcNode->statisticsMode
+                    != e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
     {
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Frame count is not supported in the statistics mode of this match table"));
         return 0;
@@ -6573,25 +6981,26 @@ uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
         return 0;
     }
 
-    p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
+    p_StatsCounters =
+            p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
     ASSERT_COND(p_StatsCounters);
 
     /* The first counter is byte counter, so we need to advance to the next counter */
     frameCount = GET_UINT32(*(uint32_t *)(PTR_MOVE(p_StatsCounters,
-                                                   FM_PCD_CC_STATS_COUNTER_SIZE)));
+                            FM_PCD_CC_STATS_COUNTER_SIZE)));
 
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
     return frameCount;
 }
 
-t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
-                                          uint16_t                  keyIndex,
-                                          t_FmPcdCcKeyStatistics    *p_KeyStatistics)
+t_Error FM_PCD_MatchTableGetKeyStatistics(
+        t_Handle h_CcNode, uint16_t keyIndex,
+        t_FmPcdCcKeyStatistics *p_KeyStatistics)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            intFlags;
-    t_Error             err;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t intFlags;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
@@ -6599,11 +7008,12 @@ t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
     intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("The provided keyIndex exceeds the number of keys in this match table"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("The provided keyIndex exceeds the number of keys in this match table"));
 
-    err = MatchTableGetKeyStatistics(p_CcNode,
-                                     keyIndex,
-                                     p_KeyStatistics);
+    err = MatchTableGetKeyStatistics(p_CcNode, keyIndex, p_KeyStatistics);
 
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
@@ -6613,20 +7023,19 @@ t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableGetMissStatistics(t_Handle                  h_CcNode,
-                                           t_FmPcdCcKeyStatistics    *p_MissStatistics)
+t_Error FM_PCD_MatchTableGetMissStatistics(
+        t_Handle h_CcNode, t_FmPcdCcKeyStatistics *p_MissStatistics)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            intFlags;
-    t_Error             err;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t intFlags;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_MissStatistics, E_NULL_POINTER);
 
     intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
 
-    err = MatchTableGetKeyStatistics(p_CcNode,
-                                     p_CcNode->numOfKeys,
+    err = MatchTableGetKeyStatistics(p_CcNode, p_CcNode->numOfKeys,
                                      p_MissStatistics);
 
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
@@ -6637,16 +7046,14 @@ t_Error FM_PCD_MatchTableGetMissStatistics(t_Handle                  h_CcNode,
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode,
-                                               uint8_t                  keySize,
-                                               uint8_t                  *p_Key,
-                                               uint8_t                  *p_Mask,
-                                               t_FmPcdCcKeyStatistics   *p_KeyStatistics)
+t_Error FM_PCD_MatchTableFindNGetKeyStatistics(
+        t_Handle h_CcNode, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask,
+        t_FmPcdCcKeyStatistics *p_KeyStatistics)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t            keyIndex;
-    uint32_t            intFlags;
-    t_Error             err;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t keyIndex;
+    uint32_t intFlags;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
@@ -6657,15 +7064,14 @@ t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the "
-                                  "match table of the provided node"));
+        RETURN_ERROR(MAJOR, err,
+                     ("The received key and mask pair was not found in the "
+                     "match table of the provided node"));
     }
 
     ASSERT_COND(keyIndex < p_CcNode->numOfKeys);
 
-    err = MatchTableGetKeyStatistics(p_CcNode,
-                                     keyIndex,
-                                     p_KeyStatistics);
+    err = MatchTableGetKeyStatistics(p_CcNode, keyIndex, p_KeyStatistics);
 
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
@@ -6675,20 +7081,21 @@ t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
-                                              uint8_t     keySize,
-                                              uint8_t     *p_Key,
-                                              uint8_t     hashShift,
-                                              t_Handle    *p_CcNodeBucketHandle,
-                                              uint8_t     *p_BucketIndex,
-                                              uint16_t    *p_LastIndex)
+t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle h_CcNode,
+                                              uint8_t keySize, uint8_t *p_Key,
+                                              uint8_t hashShift,
+                                              t_Handle *p_CcNodeBucketHandle,
+                                              uint8_t *p_BucketIndex,
+                                              uint16_t *p_LastIndex)
 {
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t        glblMask;
-    uint64_t        crc64 = 0;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t glblMask;
+    uint64_t crc64 = 0;
 
     SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(
+            p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED,
+            E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNodeBucketHandle, E_NULL_POINTER);
 
@@ -6698,11 +7105,13 @@ t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
     crc64 = crc64_compute(p_Key, keySize, crc64);
     crc64 >>= hashShift;
 
-    *p_BucketIndex = (uint8_t)(((crc64 >> (8 * (6 - p_CcNode->userOffset))) & glblMask) >> 4);
+    *p_BucketIndex = (uint8_t)(((crc64 >> (8 * (6 - p_CcNode->userOffset)))
+            & glblMask) >> 4);
     if (*p_BucketIndex >= p_CcNode->numOfKeys)
         RETURN_ERROR(MINOR, E_NOT_IN_RANGE, ("bucket index!"));
 
-    *p_CcNodeBucketHandle = p_CcNode->keyAndNextEngineParams[*p_BucketIndex].nextEngineParams.params.ccParams.h_CcNode;
+    *p_CcNodeBucketHandle =
+            p_CcNode->keyAndNextEngineParams[*p_BucketIndex].nextEngineParams.params.ccParams.h_CcNode;
     if (!*p_CcNodeBucketHandle)
         RETURN_ERROR(MINOR, E_NOT_FOUND, ("bucket!"));
 
@@ -6713,15 +7122,15 @@ t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
 
 t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
 {
-    t_FmPcdCcNode           *p_CcNodeHashTbl;
-    t_FmPcdCcNodeParams     *p_IndxHashCcNodeParam, *p_ExactMatchCcNodeParam;
-    t_FmPcdCcNode           *p_CcNode;
-    t_Handle                h_MissStatsCounters = NULL;
-    t_FmPcdCcKeyParams      *p_HashKeyParams;
-    int                     i;
-    uint16_t                numOfSets, numOfWays, countMask, onesCount = 0;
-    bool                    statsEnForMiss = FALSE;
-    t_Error                 err;
+    t_FmPcdCcNode *p_CcNodeHashTbl;
+    t_FmPcdCcNodeParams *p_IndxHashCcNodeParam, *p_ExactMatchCcNodeParam;
+    t_FmPcdCcNode *p_CcNode;
+    t_Handle h_MissStatsCounters = NULL;
+    t_FmPcdCcKeyParams *p_HashKeyParams;
+    int i;
+    uint16_t numOfSets, numOfWays, countMask, onesCount = 0;
+    bool statsEnForMiss = FALSE;
+    t_Error err;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_Param, E_NULL_POINTER, NULL);
@@ -6742,12 +7151,13 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     if (p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
     {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("RMON statistics mode is not supported for hash table"));
+                ("RMON statistics mode is not supported for hash table"));
         return NULL;
     }
 #endif /* (DPAA_VERSION >= 11) */
 
-    p_ExactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    p_ExactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(
+            sizeof(t_FmPcdCcNodeParams));
     if (!p_ExactMatchCcNodeParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_ExactMatchCcNodeParam"));
@@ -6755,7 +7165,8 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     }
     memset(p_ExactMatchCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
 
-    p_IndxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    p_IndxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(
+            sizeof(t_FmPcdCcNodeParams));
     if (!p_IndxHashCcNodeParam)
     {
         XX_Free(p_ExactMatchCcNodeParam);
@@ -6778,14 +7189,14 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     if (p_Param->maxNumOfKeys % numOfSets)
         DBG(INFO, ("'maxNumOfKeys' is not a multiple of hash number of ways, so number of ways will be rounded up"));
 
-    if ((p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_FRAME) ||
-        (p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
+    if ((p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_FRAME)
+            || (p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
     {
         /* Allocating a statistics counters table that will be used by all
-           'miss' entries of the hash table */
-        h_MissStatsCounters = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
-                                                          2 * FM_PCD_CC_STATS_COUNTER_SIZE,
-                                                          FM_PCD_CC_AD_TABLE_ALIGN);
+         'miss' entries of the hash table */
+        h_MissStatsCounters = (t_Handle)FM_MURAM_AllocMem(
+                FmPcdGetMuramHandle(h_FmPcd), 2 * FM_PCD_CC_STATS_COUNTER_SIZE,
+                FM_PCD_CC_AD_TABLE_ALIGN);
         if (!h_MissStatsCounters)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics table for hash miss"));
@@ -6794,8 +7205,8 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         memset(h_MissStatsCounters, 0, (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
 
         /* Always enable statistics for 'miss', so that a statistics AD will be
-           initialized from the start. We'll store the requested 'statistics enable'
-           value and it will be used when statistics are read by the user. */
+         initialized from the start. We'll store the requested 'statistics enable'
+         value and it will be used when statistics are read by the user. */
         statsEnForMiss = p_Param->ccNextEngineParamsForMiss.statisticsEn;
         p_Param->ccNextEngineParamsForMiss.statisticsEn = TRUE;
     }
@@ -6803,24 +7214,29 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     /* Building exact-match node params, will be used to create the hash buckets */
     p_ExactMatchCcNodeParam->extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
 
-    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.src     = e_FM_PCD_EXTRACT_FROM_KEY;
-    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.action  = e_FM_PCD_ACTION_EXACT_MATCH;
-    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.offset  = 0;
-    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.size    = p_Param->matchKeySize;
-
-    p_ExactMatchCcNodeParam->keysParams.maxNumOfKeys               = numOfWays;
-    p_ExactMatchCcNodeParam->keysParams.maskSupport                = FALSE;
-    p_ExactMatchCcNodeParam->keysParams.statisticsMode             = p_Param->statisticsMode;
-    p_ExactMatchCcNodeParam->keysParams.numOfKeys                  = 0;
-    p_ExactMatchCcNodeParam->keysParams.keySize                    = p_Param->matchKeySize;
-    p_ExactMatchCcNodeParam->keysParams.ccNextEngineParamsForMiss  = p_Param->ccNextEngineParamsForMiss;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.src =
+            e_FM_PCD_EXTRACT_FROM_KEY;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.action =
+            e_FM_PCD_ACTION_EXACT_MATCH;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.offset = 0;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.size =
+            p_Param->matchKeySize;
+
+    p_ExactMatchCcNodeParam->keysParams.maxNumOfKeys = numOfWays;
+    p_ExactMatchCcNodeParam->keysParams.maskSupport = FALSE;
+    p_ExactMatchCcNodeParam->keysParams.statisticsMode =
+            p_Param->statisticsMode;
+    p_ExactMatchCcNodeParam->keysParams.numOfKeys = 0;
+    p_ExactMatchCcNodeParam->keysParams.keySize = p_Param->matchKeySize;
+    p_ExactMatchCcNodeParam->keysParams.ccNextEngineParamsForMiss =
+            p_Param->ccNextEngineParamsForMiss;
 
     p_HashKeyParams = p_IndxHashCcNodeParam->keysParams.keyParams;
 
     for (i = 0; i < numOfSets; i++)
     {
         /* Each exact-match node will be marked as a 'bucket' and provided with a pointer to statistics counters,
-           to be used for 'miss' entry statistics */
+         to be used for 'miss' entry statistics */
         p_CcNode = (t_FmPcdCcNode *)XX_Malloc(sizeof(t_FmPcdCcNode));
         if (!p_CcNode)
             break;
@@ -6833,15 +7249,17 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         if (err)
             break;
 
-        p_HashKeyParams[i].ccNextEngineParams.nextEngine               = e_FM_PCD_CC;
-        p_HashKeyParams[i].ccNextEngineParams.statisticsEn             = FALSE;
-        p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode = p_CcNode;
+        p_HashKeyParams[i].ccNextEngineParams.nextEngine = e_FM_PCD_CC;
+        p_HashKeyParams[i].ccNextEngineParams.statisticsEn = FALSE;
+        p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode =
+                p_CcNode;
     }
 
     if (i < numOfSets)
     {
-        for (i = i-1; i >=0; i--)
-            FM_PCD_MatchTableDelete(p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode);
+        for (i = i - 1; i >= 0; i--)
+            FM_PCD_MatchTableDelete(
+                    p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode);
 
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(h_FmPcd), h_MissStatsCounters);
 
@@ -6852,18 +7270,23 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     }
 
     /* Creating indexed-hash CC node */
-    p_IndxHashCcNodeParam->extractCcParams.type                     = e_FM_PCD_EXTRACT_NON_HDR;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.src        = e_FM_PCD_EXTRACT_FROM_HASH;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.action     = e_FM_PCD_ACTION_INDEXED_LOOKUP;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.icIndxMask = p_Param->hashResMask;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.offset     = p_Param->hashShift;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.size       = 2;
-
-    p_IndxHashCcNodeParam->keysParams.maxNumOfKeys   = numOfSets;
-    p_IndxHashCcNodeParam->keysParams.maskSupport    = FALSE;
-    p_IndxHashCcNodeParam->keysParams.statisticsMode = e_FM_PCD_CC_STATS_MODE_NONE;
-    p_IndxHashCcNodeParam->keysParams.numOfKeys      = numOfSets;      /* Number of keys of this node is number of sets of the hash */
-    p_IndxHashCcNodeParam->keysParams.keySize        = 2;
+    p_IndxHashCcNodeParam->extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.src =
+            e_FM_PCD_EXTRACT_FROM_HASH;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.action =
+            e_FM_PCD_ACTION_INDEXED_LOOKUP;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.icIndxMask =
+            p_Param->hashResMask;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.offset =
+            p_Param->hashShift;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.size = 2;
+
+    p_IndxHashCcNodeParam->keysParams.maxNumOfKeys = numOfSets;
+    p_IndxHashCcNodeParam->keysParams.maskSupport = FALSE;
+    p_IndxHashCcNodeParam->keysParams.statisticsMode =
+            e_FM_PCD_CC_STATS_MODE_NONE;
+    p_IndxHashCcNodeParam->keysParams.numOfKeys = numOfSets; /* Number of keys of this node is number of sets of the hash */
+    p_IndxHashCcNodeParam->keysParams.keySize = 2;
 
     p_CcNodeHashTbl = FM_PCD_MatchTableSet(h_FmPcd, p_IndxHashCcNodeParam);
 
@@ -6872,7 +7295,7 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         p_CcNodeHashTbl->kgHashShift = p_Param->kgHashShift;
 
         /* Storing the allocated counters for buckets 'miss' in the hash table
-        and is statistics for miss wre enabled. */
+         and is statistics for miss wre enabled. */
         p_CcNodeHashTbl->h_MissStatsCounters = h_MissStatsCounters;
         p_CcNodeHashTbl->statsEnForMiss = statsEnForMiss;
     }
@@ -6885,11 +7308,11 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
 
 t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_FmPcd;
-    t_Handle        *p_HashBuckets, h_MissStatsCounters;
-    uint16_t        i, numOfBuckets;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_FmPcd;
+    t_Handle *p_HashBuckets, h_MissStatsCounters;
+    uint16_t i, numOfBuckets;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
 
@@ -6901,7 +7324,8 @@ t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
 
     for (i = 0; i < numOfBuckets; i++)
-        p_HashBuckets[i] = p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+        p_HashBuckets[i] =
+                p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
 
     h_FmPcd = p_HashTbl->h_FmPcd;
     h_MissStatsCounters = p_HashTbl->h_MissStatsCounters;
@@ -6925,123 +7349,112 @@ t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
     return E_OK;
 }
 
-t_Error FM_PCD_HashTableAddKey(t_Handle            h_HashTbl,
-                               uint8_t             keySize,
-                               t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_HashTableAddKey(t_Handle h_HashTbl, uint8_t keySize,
+                               t_FmPcdCcKeyParams *p_KeyParams)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         bucketIndex;
-    uint16_t        lastIndex;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t bucketIndex;
+    uint16_t lastIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_KeyParams->p_Key, E_NULL_POINTER);
 
     if (p_KeyParams->p_Mask)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Keys masks not supported for hash table"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("Keys masks not supported for hash table"));
 
-    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
-                                                keySize,
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl, keySize,
                                                 p_KeyParams->p_Key,
                                                 p_HashTbl->kgHashShift,
-                                                &h_HashBucket,
-                                                &bucketIndex,
+                                                &h_HashBucket, &bucketIndex,
                                                 &lastIndex);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FM_PCD_MatchTableAddKey(h_HashBucket,
-                                   FM_PCD_LAST_KEY_INDEX,
-                                   keySize,
+    return FM_PCD_MatchTableAddKey(h_HashBucket, FM_PCD_LAST_KEY_INDEX, keySize,
                                    p_KeyParams);
 }
 
-t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
-                                  uint8_t  keySize,
-                                  uint8_t  *p_Key)
+t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl, uint8_t keySize,
+                                  uint8_t *p_Key)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         bucketIndex;
-    uint16_t        lastIndex;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t bucketIndex;
+    uint16_t lastIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
 
-    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
-                                                keySize,
-                                                p_Key,
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl, keySize, p_Key,
                                                 p_HashTbl->kgHashShift,
-                                                &h_HashBucket,
-                                                &bucketIndex,
+                                                &h_HashBucket, &bucketIndex,
                                                 &lastIndex);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FM_PCD_MatchTableFindNRemoveKey(h_HashBucket,
-                                           keySize,
-                                           p_Key,
-                                           NULL);
+    return FM_PCD_MatchTableFindNRemoveKey(h_HashBucket, keySize, p_Key, NULL);
 }
 
-t_Error FM_PCD_HashTableModifyNextEngine(t_Handle                  h_HashTbl,
-                                         uint8_t                   keySize,
-                                         uint8_t                   *p_Key,
-                                         t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_HashTableModifyNextEngine(
+        t_Handle h_HashTbl, uint8_t keySize, uint8_t *p_Key,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         bucketIndex;
-    uint16_t        lastIndex;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t bucketIndex;
+    uint16_t lastIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
 
-    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
-                                                keySize,
-                                                p_Key,
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl, keySize, p_Key,
                                                 p_HashTbl->kgHashShift,
-                                                &h_HashBucket,
-                                                &bucketIndex,
+                                                &h_HashBucket, &bucketIndex,
                                                 &lastIndex);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FM_PCD_MatchTableFindNModifyNextEngine(h_HashBucket,
-                                                  keySize,
-                                                  p_Key,
+    return FM_PCD_MatchTableFindNModifyNextEngine(h_HashBucket, keySize, p_Key,
                                                   NULL,
                                                   p_FmPcdCcNextEngineParams);
 }
 
-t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl,
-                                             t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_HashTableModifyMissNextEngine(
+        t_Handle h_HashTbl,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         i;
-    bool            nullifyMissStats = FALSE;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t i;
+    bool nullifyMissStats = FALSE;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(h_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
 
-    if ((!p_HashTbl->h_MissStatsCounters) && (p_FmPcdCcNextEngineParams->statisticsEn))
-        RETURN_ERROR(MAJOR, E_CONFLICT,
-                             ("Statistics are requested for a key, but statistics mode was set"
-                              "to 'NONE' upon initialization"));
+    if ((!p_HashTbl->h_MissStatsCounters)
+            && (p_FmPcdCcNextEngineParams->statisticsEn))
+        RETURN_ERROR(
+                MAJOR,
+                E_CONFLICT,
+                ("Statistics are requested for a key, but statistics mode was set"
+                "to 'NONE' upon initialization"));
 
     if (p_HashTbl->h_MissStatsCounters)
     {
-        if ((!p_HashTbl->statsEnForMiss) && (p_FmPcdCcNextEngineParams->statisticsEn))
+        if ((!p_HashTbl->statsEnForMiss)
+                && (p_FmPcdCcNextEngineParams->statisticsEn))
             nullifyMissStats = TRUE;
 
-        if ((p_HashTbl->statsEnForMiss) && (!p_FmPcdCcNextEngineParams->statisticsEn))
+        if ((p_HashTbl->statsEnForMiss)
+                && (!p_FmPcdCcNextEngineParams->statisticsEn))
         {
             p_HashTbl->statsEnForMiss = FALSE;
             p_FmPcdCcNextEngineParams->statisticsEn = TRUE;
@@ -7050,7 +7463,8 @@ t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl
 
     for (i = 0; i < p_HashTbl->numOfKeys; i++)
     {
-        h_HashBucket = p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+        h_HashBucket =
+                p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
 
         err = FM_PCD_MatchTableModifyMissNextEngine(h_HashBucket,
                                                     p_FmPcdCcNextEngineParams);
@@ -7060,8 +7474,10 @@ t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl
 
     if (nullifyMissStats)
     {
-        memset(p_HashTbl->h_MissStatsCounters, 0, (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
-        memset(p_HashTbl->h_MissStatsCounters, 0, (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
+        memset(p_HashTbl->h_MissStatsCounters, 0,
+               (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
+        memset(p_HashTbl->h_MissStatsCounters, 0,
+               (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
         p_HashTbl->statsEnForMiss = TRUE;
     }
 
@@ -7069,16 +7485,18 @@ t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl
 }
 
 
-t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl,
-                                          t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_HashTableGetMissNextEngine(
+        t_Handle h_HashTbl,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_FmPcdCcNode   *p_HashBucket;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_FmPcdCcNode *p_HashBucket;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
 
     /* Miss next engine of each bucket was initialized with the next engine of the hash table */
-    p_HashBucket = p_HashTbl->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode;
+    p_HashBucket =
+            p_HashTbl->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode;
 
     memcpy(p_FmPcdCcNextEngineParams,
            &p_HashBucket->keyAndNextEngineParams[p_HashBucket->numOfKeys].nextEngineParams,
@@ -7087,52 +7505,46 @@ t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl
     return E_OK;
 }
 
-t_Error FM_PCD_HashTableFindNGetKeyStatistics(t_Handle                 h_HashTbl,
-                                              uint8_t                  keySize,
-                                              uint8_t                  *p_Key,
-                                              t_FmPcdCcKeyStatistics   *p_KeyStatistics)
+t_Error FM_PCD_HashTableFindNGetKeyStatistics(
+        t_Handle h_HashTbl, uint8_t keySize, uint8_t *p_Key,
+        t_FmPcdCcKeyStatistics *p_KeyStatistics)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         bucketIndex;
-    uint16_t        lastIndex;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t bucketIndex;
+    uint16_t lastIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
 
-    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
-                                                keySize,
-                                                p_Key,
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl, keySize, p_Key,
                                                 p_HashTbl->kgHashShift,
-                                                &h_HashBucket,
-                                                &bucketIndex,
+                                                &h_HashBucket, &bucketIndex,
                                                 &lastIndex);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FM_PCD_MatchTableFindNGetKeyStatistics(h_HashBucket,
-                                                  keySize,
-                                                  p_Key,
-                                                  NULL,
-                                                  p_KeyStatistics);
+    return FM_PCD_MatchTableFindNGetKeyStatistics(h_HashBucket, keySize, p_Key,
+                                                  NULL, p_KeyStatistics);
 }
 
-t_Error FM_PCD_HashTableGetMissStatistics(t_Handle                 h_HashTbl,
-                                          t_FmPcdCcKeyStatistics   *p_MissStatistics)
+t_Error FM_PCD_HashTableGetMissStatistics(
+        t_Handle h_HashTbl, t_FmPcdCcKeyStatistics *p_MissStatistics)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_MissStatistics, E_NULL_POINTER);
 
     if (!p_HashTbl->statsEnForMiss)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for miss"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("Statistics were not enabled for miss"));
 
-    h_HashBucket = p_HashTbl->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode;
+    h_HashBucket =
+            p_HashTbl->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode;
 
-    return FM_PCD_MatchTableGetMissStatistics(h_HashBucket,
-                                              p_MissStatistics);
+    return FM_PCD_MatchTableGetMissStatistics(h_HashBucket, p_MissStatistics);
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
index 0461260..ceb8e1d 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
@@ -389,6 +389,7 @@ typedef struct
     bool                modifiedState;
     uint32_t            requiredAction;
     t_Handle            h_IpReassemblyManip;
+    t_Handle            h_CapwapReassemblyManip;
 
     t_FmPcdCcKeyAndNextEngineParams keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];
 } t_FmPcdCcTree;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
index 769a7ab..e423d90 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
@@ -1382,12 +1382,11 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                 case (e_FM_PCD_EXTRACT_BY_HDR):
                     switch (p_Extract->extractByHdr.hdr)
                     {
-
-#ifdef FM_CAPWAP_SUPPORT
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
                         case (HEADER_TYPE_UDP_LITE):
                             p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
                             break;
-#endif
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
                         case (HEADER_TYPE_UDP_ENCAP_ESP):
                             switch (p_Extract->extractByHdr.type)
                             {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
index 1027783..48cadee 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
@@ -35,7 +35,7 @@
  @File          fm_manip.c
 
  @Description   FM PCD manip ...
-*//***************************************************************************/
+ *//***************************************************************************/
 #include "std_ext.h"
 #include "error_ext.h"
 #include "string_ext.h"
@@ -49,13 +49,12 @@
 #include "fm_hc.h"
 #include "fm_manip.h"
 
-
 /****************************************/
 /*       static functions               */
 /****************************************/
 static t_Handle GetManipInfo(t_FmPcdManip *p_Manip, e_ManipInfo manipInfo)
 {
-     t_FmPcdManip     *p_CurManip = p_Manip;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     if (!MANIP_IS_UNIFIED(p_Manip))
         p_CurManip = p_Manip;
@@ -78,10 +77,11 @@ static t_Handle GetManipInfo(t_FmPcdManip *p_Manip, e_ManipInfo manipInfo)
             return NULL;
     }
 }
-static uint16_t    GetHmctSize(t_FmPcdManip *p_Manip)
+
+static uint16_t GetHmctSize(t_FmPcdManip *p_Manip)
 {
-    uint16_t         size = 0;
-    t_FmPcdManip     *p_CurManip = p_Manip;
+    uint16_t size = 0;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     if (!MANIP_IS_UNIFIED(p_Manip))
         return p_Manip->tableSize;
@@ -97,12 +97,13 @@ static uint16_t    GetHmctSize(t_FmPcdManip *p_Manip)
     }
     size += p_CurManip->tableSize; /* add last size */
 
-    return(size);
+    return (size);
 }
-static uint16_t    GetDataSize(t_FmPcdManip *p_Manip)
+
+static uint16_t GetDataSize(t_FmPcdManip *p_Manip)
 {
-    uint16_t         size = 0;
-    t_FmPcdManip     *p_CurManip = p_Manip;
+    uint16_t size = 0;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     if (!MANIP_IS_UNIFIED(p_Manip))
         return p_Manip->dataSize;
@@ -118,111 +119,179 @@ static uint16_t    GetDataSize(t_FmPcdManip *p_Manip)
     }
     size += p_CurManip->dataSize; /* add last size */
 
-    return(size);
+    return (size);
 }
-static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16_t *p_TableSize, uint8_t *p_DataSize)
+
+static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams,
+                                  uint16_t *p_TableSize, uint8_t *p_DataSize)
 {
     uint8_t localDataSize, remain, tableSize = 0, dataSize = 0;
 
     if (p_FmPcdManipParams->u.hdr.rmv)
     {
-        switch (p_FmPcdManipParams->u.hdr.rmvParams.type){
+        switch (p_FmPcdManipParams->u.hdr.rmvParams.type)
+        {
             case (e_FM_PCD_MANIP_RMV_GENERIC):
+                tableSize += HMCD_BASIC_SIZE;
+                break;
             case (e_FM_PCD_MANIP_RMV_BY_HDR):
-                /* As long as the only rmv command is the L2, no check on type is required */
-                tableSize +=  HMCD_BASIC_SIZE;
-            break;
+                switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.type)
+                {
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2):
+#if (DPAA_VERSION >= 11)
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP):
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START):
+#endif /* (DPAA_VERSION >= 11) */
+                        tableSize += HMCD_BASIC_SIZE;
+                        break;
+                    default:
+                        RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                                     ("Unknown byHdr.type"));
+                }
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown rmvParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown rmvParams.type"));
         }
     }
 
     if (p_FmPcdManipParams->u.hdr.insrt)
     {
-        switch (p_FmPcdManipParams->u.hdr.insrtParams.type){
+        switch (p_FmPcdManipParams->u.hdr.insrtParams.type)
+        {
             case (e_FM_PCD_MANIP_INSRT_GENERIC):
-                remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
+                remain =
+                        (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size
+                                % 4);
                 if (remain)
-                    localDataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
+                    localDataSize =
+                            (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size
+                                    + 4 - remain);
                 else
-                    localDataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
+                    localDataSize =
+                            p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
                 tableSize += (uint8_t)(HMCD_BASIC_SIZE + localDataSize);
-            break;
+                break;
             case (e_FM_PCD_MANIP_INSRT_BY_HDR):
-                /* As long as the only insert command is the internal L2, no check on type is required */
-                tableSize += HMCD_BASIC_SIZE+HMCD_PTR_SIZE;
-                if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
-                    switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
-                    {
-                        case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
-                            dataSize += p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+            {
+                switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type)
+                {
+
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2):
+                        tableSize += HMCD_BASIC_SIZE + HMCD_PTR_SIZE;
+                        switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
+                        {
+                            case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
+                                dataSize +=
+                                        p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+                                break;
+                            default:
+                                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+                        }
                         break;
-                        default:
-                            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
-                    }
-            break;
+#if (DPAA_VERSION >= 11)
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_IP):
+                        tableSize +=
+                                (HMCD_BASIC_SIZE + HMCD_PTR_SIZE
+                                        + HMCD_PARAM_SIZE
+                                        + p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size);
+                        dataSize += 2;
+                        break;
+
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP):
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE):
+                        tableSize += (HMCD_BASIC_SIZE + HMCD_L4_HDR_SIZE);
+
+                        break;
+
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP):
+                        tableSize +=
+                                (HMCD_BASIC_SIZE
+                                        + p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size);
+                        break;
+#endif /* (DPAA_VERSION >= 11) */
+                    default:
+                        RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                                     ("Unknown byHdr.type"));
+                }
+            }
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown insrtParams.type"));
         }
     }
+
     if (p_FmPcdManipParams->u.hdr.fieldUpdate)
     {
-        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type)
+        {
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
                 tableSize += HMCD_BASIC_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
-                   e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                        == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                 {
                     tableSize += HMCD_PTR_SIZE;
                     dataSize += DSCP_TO_VLAN_TABLE_SIZE;
                 }
-            break;
+                break;
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
                 tableSize += HMCD_BASIC_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_ID)
                 {
                     tableSize += HMCD_PARAM_SIZE;
                     dataSize += 2;
                 }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_SRC)
                     tableSize += HMCD_IPV4_ADDR_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_DST)
                     tableSize += HMCD_IPV4_ADDR_SIZE;
-            break;
+                break;
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
                 tableSize += HMCD_BASIC_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV6_SRC)
                     tableSize += HMCD_IPV6_ADDR_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV6_DST)
                     tableSize += HMCD_IPV6_ADDR_SIZE;
-            break;
+                break;
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                        == HDR_MANIP_TCP_UDP_CHECKSUM)
                     /* we implement this case with the update-checksum descriptor */
                     tableSize += HMCD_BASIC_SIZE;
                 else
                     /* we implement this case with the TCP/UDP-update descriptor */
                     tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE;
-            break;
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown fieldUpdateParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown fieldUpdateParams.type"));
         }
     }
 
     if (p_FmPcdManipParams->u.hdr.custom)
     {
-        switch (p_FmPcdManipParams->u.hdr.customParams.type){
+        switch (p_FmPcdManipParams->u.hdr.customParams.type)
+        {
             case (e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
             {
                 tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE + HMCD_PARAM_SIZE;
-                dataSize += p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
-                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
-                        (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
+                dataSize +=
+                        p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
+                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType
+                        == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
+                        && (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
                     dataSize += 2;
             }
-            break;
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown customParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown customParams.type"));
         }
     }
 
@@ -232,74 +301,238 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
     return E_OK;
 }
 
-static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams, uint8_t *p_DestHmct, uint8_t *p_DestData, bool new)
+static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo,
+                                          uint8_t *parseArrayOffset)
+{
+    e_NetHeaderType hdr = p_HdrInfo->hdr;
+    e_FmPcdHdrIndex hdrIndex = p_HdrInfo->hdrIndex;
+    bool byField = p_HdrInfo->byField;
+    t_FmPcdFields field;
+
+    if (byField)
+        field = p_HdrInfo->fullField;
+
+    if (byField)
+    {
+        switch (hdr)
+        {
+            case (HEADER_TYPE_ETH):
+                switch (field.eth)
+                {
+                    case (NET_HEADER_FIELD_ETH_TYPE):
+                        *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
+                        break;
+                    default:
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_NOT_SUPPORTED,
+                                ("Header manipulation of the type Ethernet with this field not supported"));
+                }
+                break;
+            case (HEADER_TYPE_VLAN):
+                switch (field.vlan)
+                {
+                    case (NET_HEADER_FIELD_VLAN_TCI):
+                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                                || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                            *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
+                        else
+                            if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                                *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                        break;
+                    default:
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_NOT_SUPPORTED,
+                                ("Header manipulation of the type VLAN with this field not supported"));
+                }
+                break;
+            default:
+                RETURN_ERROR(
+                        MAJOR,
+                        E_NOT_SUPPORTED,
+                        ("Header manipulation of this header by field not supported"));
+        }
+    }
+    else
+    {
+        switch (hdr)
+        {
+            case (HEADER_TYPE_ETH):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
+                break;
+            case (HEADER_TYPE_USER_DEFINED_SHIM1):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
+                break;
+            case (HEADER_TYPE_USER_DEFINED_SHIM2):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
+                break;
+            case (HEADER_TYPE_LLC_SNAP):
+                *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
+                break;
+            case (HEADER_TYPE_PPPoE):
+                *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
+                break;
+            case (HEADER_TYPE_MPLS):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                        || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                else
+                    if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                break;
+            case (HEADER_TYPE_IPv4):
+            case (HEADER_TYPE_IPv6):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                        || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
+                else
+                    if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                        *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+                break;
+            case (HEADER_TYPE_MINENCAP):
+                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
+                break;
+            case (HEADER_TYPE_GRE):
+                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
+                break;
+            case (HEADER_TYPE_TCP):
+            case (HEADER_TYPE_UDP):
+            case (HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_SCTP):
+                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
+                break;
+            case (HEADER_TYPE_CAPWAP):
+            case (HEADER_TYPE_CAPWAP_DTLS):
+                *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+                break;
+            default:
+                RETURN_ERROR(
+                        MAJOR,
+                        E_NOT_SUPPORTED,
+                        ("Header manipulation of this header is not supported"));
+        }
+    }
+    return E_OK;
+}
+
+static t_Error BuildHmct(t_FmPcdManip *p_Manip,
+                         t_FmPcdManipParams *p_FmPcdManipParams,
+                         uint8_t *p_DestHmct, uint8_t *p_DestData, bool new)
 {
-    uint32_t        *p_TmpHmct = (uint32_t*)p_DestHmct, *p_LocalData;
-    uint32_t        tmpReg=0, *p_Last = NULL;
-    uint8_t         remain, i, size=0, origSize, *p_UsrData = NULL, *p_TmpData = p_DestData;
-    t_Handle        h_FmPcd = p_Manip->h_FmPcd;
-    uint8_t         j=0;
+    uint32_t *p_TmpHmct = (uint32_t*)p_DestHmct, *p_LocalData;
+    uint32_t tmpReg = 0, *p_Last = NULL, tmp_ipv6_addr;
+    uint8_t remain, i, size = 0, origSize, *p_UsrData = NULL, *p_TmpData =
+            p_DestData;
+    t_Handle h_FmPcd = p_Manip->h_FmPcd;
+    uint8_t j = 0;
 
     if (p_FmPcdManipParams->u.hdr.rmv)
     {
-        if (p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_GENERIC)
+        if (p_FmPcdManipParams->u.hdr.rmvParams.type
+                == e_FM_PCD_MANIP_RMV_GENERIC)
         {
             /* initialize HMCD */
             tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_RMV) << HMCD_OC_SHIFT;
             /* tmp, should be conditional */
-            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset << HMCD_RMV_OFFSET_SHIFT;
-            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size << HMCD_RMV_SIZE_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset
+                    << HMCD_RMV_OFFSET_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size
+                    << HMCD_RMV_SIZE_SHIFT;
         }
-        else if (p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_BY_HDR)
-        {
-            uint8_t     hmcdOpt;
-            if (!p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.type == e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2)
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+        else
+            if (p_FmPcdManipParams->u.hdr.rmvParams.type
+                    == e_FM_PCD_MANIP_RMV_BY_HDR)
+            {
+                switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.type)
+                {
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2):
+                    {
+                        uint8_t hmcdOpt;
 
-            /* initialize HMCD */
-            tmpReg = (uint32_t)(HMCD_OPCODE_L2_RMV) << HMCD_OC_SHIFT;
+                        /* initialize HMCD */
+                        tmpReg = (uint32_t)(HMCD_OPCODE_L2_RMV) << HMCD_OC_SHIFT;
+
+                        switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.specificL2)
+                        {
+                            case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET):
+                                hmcdOpt = HMCD_RMV_L2_ETHERNET;
+                                break;
+                            case (e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS):
+                                hmcdOpt = HMCD_RMV_L2_STACKED_QTAGS;
+                                break;
+                            case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS):
+                                hmcdOpt = HMCD_RMV_L2_ETHERNET_AND_MPLS;
+                                break;
+                            case (e_FM_PCD_MANIP_HDR_RMV_MPLS):
+                                hmcdOpt = HMCD_RMV_L2_MPLS;
+                                break;
+                            default:
+                                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+                        }
+                        tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
+                        break;
+                    }
+#if (DPAA_VERSION >= 11)
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP):
+                        tmpReg = (uint32_t)(HMCD_OPCODE_CAPWAP_RMV)
+                                << HMCD_OC_SHIFT;
+                        break;
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START):
+                    {
+                        uint8_t prsArrayOffset;
+                        t_Error err = E_OK;
+
+                        UNUSED(err);
+                        tmpReg = (uint32_t)(HMCD_OPCODE_RMV_TILL)
+                                << HMCD_OC_SHIFT;
+
+                        err =
+                                GetPrOffsetByHeaderOrField(
+                                        &p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.hdrInfo,
+                                        &prsArrayOffset);
+                        ASSERT_COND(!err);
+                        /* was previously checked */
+
+                        tmpReg |= ((uint32_t)prsArrayOffset << 16);
+                    }
+                        break;
+#endif /* (DPAA_VERSION >= 11) */
+                    default:
+                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                                     ("manip header remove by hdr type!"));
+                }
 
-            switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.specificL2)
-            {
-                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET):
-                    hmcdOpt = HMCD_RMV_L2_ETHERNET;
-                    break;
-                case (e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS):
-                    hmcdOpt = HMCD_RMV_L2_STACKED_QTAGS;
-                    break;
-                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS):
-                    hmcdOpt = HMCD_RMV_L2_ETHERNET_AND_MPLS;
-                    break;
-                case (e_FM_PCD_MANIP_HDR_RMV_MPLS):
-                    hmcdOpt = HMCD_RMV_L2_MPLS;
-                    break;
-                default:
-                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
             }
-            tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
-        }
-        else
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header remove type!"));
+            else
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                             ("manip header remove type!"));
 
         WRITE_UINT32(*p_TmpHmct, tmpReg);
         /* save a pointer to the "last" indication word */
         p_Last = p_TmpHmct;
         /* advance to next command */
-        p_TmpHmct += HMCD_BASIC_SIZE/4;
+        p_TmpHmct += HMCD_BASIC_SIZE / 4;
     }
 
     if (p_FmPcdManipParams->u.hdr.insrt)
     {
-        if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
+        if (p_FmPcdManipParams->u.hdr.insrtParams.type
+                == e_FM_PCD_MANIP_INSRT_GENERIC)
         {
             /* initialize HMCD */
             if (p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
-                tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_REPLACE) << HMCD_OC_SHIFT;
+                tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_REPLACE)
+                        << HMCD_OC_SHIFT;
             else
                 tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_INSRT) << HMCD_OC_SHIFT;
 
-            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.offset << HMCD_INSRT_OFFSET_SHIFT;
-            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size << HMCD_INSRT_SIZE_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.offset
+                    << HMCD_INSRT_OFFSET_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size
+                    << HMCD_INSRT_SIZE_SHIFT;
 
             size = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
             p_UsrData = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.p_Data;
@@ -308,7 +541,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             /* save a pointer to the "last" indication word */
             p_Last = p_TmpHmct;
 
-            p_TmpHmct += HMCD_BASIC_SIZE/4;
+            p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
             /* initialize data to be inserted */
             /* if size is not a multiple of 4, padd with 0's */
@@ -325,232 +558,397 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 p_LocalData = (uint32_t*)p_UsrData;
 
             /* initialize data and advance pointer to next command */
-            for (i = 0; i<size/4 ; i++, p_TmpHmct += HMCD_BASIC_SIZE/4)
+            for (i = 0; i < size / 4; i++, p_TmpHmct += HMCD_BASIC_SIZE / 4)
                 WRITE_UINT32(*p_TmpHmct, *(p_LocalData+i));
 
             if (remain)
                 XX_Free(p_LocalData);
         }
 
-        else if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_BY_HDR)
-        {
-            uint8_t     hmcdOpt;
-            if (!p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+        else
+            if (p_FmPcdManipParams->u.hdr.insrtParams.type
+                    == e_FM_PCD_MANIP_INSRT_BY_HDR)
+            {
+                switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type)
+                {
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2):
+                    {
+                        uint8_t hmcdOpt;
 
-            /* initialize HMCD */
-            tmpReg = (uint32_t)(HMCD_OPCODE_L2_INSRT) << HMCD_OC_SHIFT;
+                        /* initialize HMCD */
+                        tmpReg = (uint32_t)(HMCD_OPCODE_L2_INSRT)
+                                << HMCD_OC_SHIFT;
 
-            switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
-            {
-                case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
-                    if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.update)
-                        hmcdOpt = HMCD_INSRT_N_UPDATE_L2_MPLS;
-                    else
-                        hmcdOpt = HMCD_INSRT_L2_MPLS;
-                break;
-                default:
-                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
-            }
-            tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
+                        switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
+                        {
+                            case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
+                                if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.update)
+                                    hmcdOpt = HMCD_INSRT_N_UPDATE_L2_MPLS;
+                                else
+                                    hmcdOpt = HMCD_INSRT_L2_MPLS;
+                                break;
+                            default:
+                                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+                        }
+                        tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
+
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
+
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
+
+                        /* set size and pointer of user's data */
+                        size =
+                                (uint8_t)p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+
+                        ASSERT_COND(p_TmpData);
+                        Mem2IOCpy32(
+                                p_TmpData,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.p_Data,
+                                size);
+                        tmpReg =
+                                (size << HMCD_INSRT_L2_SIZE_SHIFT)
+                                        | (uint32_t)(XX_VirtToPhys(p_TmpData)
+                                                - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+                        p_TmpHmct += HMCD_PTR_SIZE / 4;
+                        p_TmpData += size;
+                    }
+                        break;
+#if (DPAA_VERSION >= 11)
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_IP):
+                        tmpReg = (uint32_t)(HMCD_OPCODE_IP_INSRT)
+                                << HMCD_OC_SHIFT;
+                        if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.calcL4Checksum)
+                            tmpReg |= HMCD_IP_L4_CS_CALC;
+                        if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.mappingMode
+                                == e_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS)
+                            tmpReg |= HMCD_IP_OR_QOS;
+                        tmpReg |=
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.lastPidOffset
+                                        & HMCD_IP_LAST_PID_MASK;
+                        tmpReg |=
+                                ((p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size
+                                        << HMCD_IP_SIZE_SHIFT)
+                                        & HMCD_IP_SIZE_MASK);
+
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
+
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
+
+                        /* set IP id */
+                        ASSERT_COND(p_TmpData);
+                        WRITE_UINT16(
+                                *(uint16_t*)p_TmpData,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.id);
+                        WRITE_UINT32(
+                                *p_TmpHmct,
+                                (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+                        p_TmpData += 2;
+                        p_TmpHmct += HMCD_PTR_SIZE / 4;
+                        p_TmpHmct += HMCD_PARAM_SIZE / 4;
+
+                        Mem2IOCpy32(
+                                p_TmpHmct,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.p_Data,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size);
+                        p_TmpHmct +=
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size
+                                        / 4;
+                        break;
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE):
+                        tmpReg = HMCD_INSRT_UDP_LITE;
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP):
+                        tmpReg |= (uint32_t)(HMCD_OPCODE_UDP_INSRT)
+                                << HMCD_OC_SHIFT;
+
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
+
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
+
+                        Mem2IOCpy32(
+                                p_TmpHmct,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.p_Data,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size);
+                        p_TmpHmct +=
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size
+                                        / 4;
+                        break;
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP):
+                        tmpReg = (uint32_t)(HMCD_OPCODE_CAPWAP_INSRT)
+                                << HMCD_OC_SHIFT;
+                        tmpReg |= HMCD_CAPWAP_INSRT;
 
-            WRITE_UINT32(*p_TmpHmct, tmpReg);
-            /* save a pointer to the "last" indication word */
-            p_Last = p_TmpHmct;
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
 
-            p_TmpHmct += HMCD_BASIC_SIZE/4;
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
 
-            /* set size and pointer of user's data */
-            size = (uint8_t)p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
-            ASSERT_COND(p_TmpData);
-            Mem2IOCpy32(p_TmpData, p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.p_Data, size);
-            tmpReg = (size << HMCD_INSRT_L2_SIZE_SHIFT) | (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
-            WRITE_UINT32(*p_TmpHmct, tmpReg);
-            p_TmpHmct += HMCD_PTR_SIZE/4;
-            p_TmpData += size;
-        }
-        else
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header insert type!"));
+                        Mem2IOCpy32(
+                                p_TmpHmct,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.p_Data,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size);
+                        p_TmpHmct +=
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size
+                                        / 4;
+                        break;
+#endif /* (DPAA_VERSION >= 11) */
+                    default:
+                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                                     ("manip header insert by header type!"));
+
+                }
+            }
+            else
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                             ("manip header insert type!"));
     }
 
     if (p_FmPcdManipParams->u.hdr.fieldUpdate)
     {
-        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type)
+        {
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
                 /* set opcode */
-                tmpReg = (uint32_t)(HMCD_OPCODE_VLAN_PRI_UPDATE) << HMCD_OC_SHIFT;
+                tmpReg = (uint32_t)(HMCD_OPCODE_VLAN_PRI_UPDATE)
+                        << HMCD_OC_SHIFT;
 
                 /* set mode & table pointer */
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
-                   e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                        == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                 {
                     /* set Mode */
-                    tmpReg |= (uint32_t)(HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI) << HMCD_VLAN_PRI_REP_MODE_SHIFT;
+                    tmpReg |= (uint32_t)(HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI)
+                            << HMCD_VLAN_PRI_REP_MODE_SHIFT;
                     /* set VPRI default */
-                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal;
+                    tmpReg |=
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal;
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
                     p_Last = p_TmpHmct;
                     /* write the table pointer into the Manip descriptor */
-                    p_TmpHmct += HMCD_BASIC_SIZE/4;
+                    p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
                     tmpReg = 0;
                     ASSERT_COND(p_TmpData);
-                    for (i=0; i<HMCD_DSCP_VALUES; i++)
+                    for (i = 0; i < HMCD_DSCP_VALUES; i++)
                     {
                         /* first we build from each 8 values a 32bit register */
-                        tmpReg |= (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i]) << (32-4*(j+1));
+                        tmpReg |=
+                                (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i])
+                                        << (32 - 4 * (j + 1));
                         j++;
                         /* Than we write this register to the next table word
                          * (i=7-->word 0, i=15-->word 1,... i=63-->word 7) */
-                        if ((i%8) == 7)
+                        if ((i % 8) == 7)
                         {
-                            WRITE_UINT32(*((uint32_t*)p_TmpData + (i+1)/8-1), tmpReg);
+                            WRITE_UINT32(*((uint32_t*)p_TmpData + (i+1)/8-1),
+                                         tmpReg);
                             tmpReg = 0;
                             j = 0;
                         }
                     }
-                    WRITE_UINT32(*p_TmpHmct, (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
-                    p_TmpHmct += HMCD_PTR_SIZE/4;
+
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
+                    p_TmpHmct += HMCD_PTR_SIZE / 4;
 
                     p_TmpData += DSCP_TO_VLAN_TABLE_SIZE;
                 }
-                else if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
-                   e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
-                {
-                    /* set Mode */
-                    /* line commented out as it has no-side-effect ('0' value). */
-                    /*tmpReg |= HMCD_VLAN_PRI_UPDATE << HMCD_VLAN_PRI_REP_MODE_SHIFT*/;
-                    /* set VPRI parameter */
-                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri;
-                    WRITE_UINT32(*p_TmpHmct, tmpReg);
-                    /* save a pointer to the "last" indication word */
-                    p_Last = p_TmpHmct;
-                    p_TmpHmct += HMCD_BASIC_SIZE/4;
-                }
+                else
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                            == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
+                    {
+                        /* set Mode */
+                        /* line commented out as it has no-side-effect ('0' value). */
+                        /*tmpReg |= HMCD_VLAN_PRI_UPDATE << HMCD_VLAN_PRI_REP_MODE_SHIFT*/;
+                        /* set VPRI parameter */
+                        tmpReg |=
+                                p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri;
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
+                    }
                 break;
 
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_IPV4_UPDATE) << HMCD_OC_SHIFT;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_TTL)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_TTL)
                     tmpReg |= HMCD_IPV4_UPDATE_TTL;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_TOS)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_TOS)
                 {
                     tmpReg |= HMCD_IPV4_UPDATE_TOS;
-                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.tos << HMCD_IPV4_UPDATE_TOS_SHIFT;
+                    tmpReg |=
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.tos
+                                    << HMCD_IPV4_UPDATE_TOS_SHIFT;
                 }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_ID)
                     tmpReg |= HMCD_IPV4_UPDATE_ID;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_SRC)
                     tmpReg |= HMCD_IPV4_UPDATE_SRC;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_DST)
                     tmpReg |= HMCD_IPV4_UPDATE_DST;
                 /* write the first 4 bytes of the descriptor */
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
                 /* save a pointer to the "last" indication word */
                 p_Last = p_TmpHmct;
 
-                p_TmpHmct += HMCD_BASIC_SIZE/4;
+                p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_ID)
                 {
                     ASSERT_COND(p_TmpData);
-                    WRITE_UINT16(*(uint16_t*)p_TmpData, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.id);
-                    WRITE_UINT32(*p_TmpHmct, (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+                    WRITE_UINT16(
+                            *(uint16_t*)p_TmpData,
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.id);
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
                     p_TmpData += 2;
-                    p_TmpHmct += HMCD_PTR_SIZE/4;
+                    p_TmpHmct += HMCD_PTR_SIZE / 4;
                 }
 
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_SRC)
                 {
-                    WRITE_UINT32(*p_TmpHmct, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.src);
-                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE/4;
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.src);
+                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE / 4;
                 }
 
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_DST)
                 {
-                    WRITE_UINT32(*p_TmpHmct, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.dst);
-                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE/4;
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.dst);
+                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE / 4;
                 }
                 break;
 
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_IPV6_UPDATE) << HMCD_OC_SHIFT;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_HL)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_HL)
                     tmpReg |= HMCD_IPV6_UPDATE_HL;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_TC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_TC)
                 {
                     tmpReg |= HMCD_IPV6_UPDATE_TC;
-                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.trafficClass << HMCD_IPV6_UPDATE_TC_SHIFT;
+                    tmpReg |=
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.trafficClass
+                                    << HMCD_IPV6_UPDATE_TC_SHIFT;
                 }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_SRC)
                     tmpReg |= HMCD_IPV6_UPDATE_SRC;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_DST)
                     tmpReg |= HMCD_IPV6_UPDATE_DST;
                 /* write the first 4 bytes of the descriptor */
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
                 /* save a pointer to the "last" indication word */
                 p_Last = p_TmpHmct;
 
-                p_TmpHmct += HMCD_BASIC_SIZE/4;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
-                    for (i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
+                p_TmpHmct += HMCD_BASIC_SIZE / 4;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_SRC)
+                {
+                    for (i = 0; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE; i += 4)
                     {
-                        WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.src[i]);
-                        p_TmpHmct += HMCD_PTR_SIZE/4;
+                        memcpy(&tmp_ipv6_addr,
+                               &p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.src[i],
+                               sizeof(uint32_t));
+                        WRITE_UINT32(*p_TmpHmct, tmp_ipv6_addr);
+                        p_TmpHmct += HMCD_PTR_SIZE / 4;
                     }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
-                    for (i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
+                }
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_DST)
+                {
+                    for (i = 0; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE; i += 4)
                     {
-                        WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.dst[i]);
-                        p_TmpHmct += HMCD_PTR_SIZE/4;
+                        memcpy(&tmp_ipv6_addr,
+                               &p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.dst[i],
+                               sizeof(uint32_t));
+                        WRITE_UINT32(*p_TmpHmct, tmp_ipv6_addr);
+                        p_TmpHmct += HMCD_PTR_SIZE / 4;
                     }
+                }
                 break;
 
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                        == HDR_MANIP_TCP_UDP_CHECKSUM)
                 {
                     /* we implement this case with the update-checksum descriptor */
                     /* set opcode */
-                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_CHECKSUM) << HMCD_OC_SHIFT;
+                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_CHECKSUM)
+                            << HMCD_OC_SHIFT;
                     /* write the first 4 bytes of the descriptor */
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
                     p_Last = p_TmpHmct;
 
-                    p_TmpHmct += HMCD_BASIC_SIZE/4;
+                    p_TmpHmct += HMCD_BASIC_SIZE / 4;
                 }
                 else
                 {
                     /* we implement this case with the TCP/UDP update descriptor */
                     /* set opcode */
-                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_UPDATE) << HMCD_OC_SHIFT;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
-                         tmpReg |= HMCD_TCP_UDP_UPDATE_DST;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
-                         tmpReg |= HMCD_TCP_UDP_UPDATE_SRC;
+                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_UPDATE)
+                            << HMCD_OC_SHIFT;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                            & HDR_MANIP_TCP_UDP_DST)
+                        tmpReg |= HMCD_TCP_UDP_UPDATE_DST;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                            & HDR_MANIP_TCP_UDP_SRC)
+                        tmpReg |= HMCD_TCP_UDP_UPDATE_SRC;
                     /* write the first 4 bytes of the descriptor */
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
                     p_Last = p_TmpHmct;
 
-                    p_TmpHmct += HMCD_BASIC_SIZE/4;
+                    p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
                     tmpReg = 0;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
-                        tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.src) << HMCD_TCP_UDP_UPDATE_SRC_SHIFT;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
-                        tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.dst);
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                            & HDR_MANIP_TCP_UDP_SRC)
+                        tmpReg |=
+                                ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.src)
+                                        << HMCD_TCP_UDP_UPDATE_SRC_SHIFT;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                            & HDR_MANIP_TCP_UDP_DST)
+                        tmpReg |=
+                                ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.dst);
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
-                    p_TmpHmct += HMCD_PTR_SIZE/4;
+                    p_TmpHmct += HMCD_PTR_SIZE / 4;
                 }
                 break;
 
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown fieldUpdateParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown fieldUpdateParams.type"));
         }
     }
 
@@ -564,73 +962,92 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
 
                 if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.decTtlHl)
                     tmpReg |= HMCD_IP_REPLACE_TTL_HL;
-                if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6)
+                if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType
+                        == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6)
                     /* line commented out as it has no-side-effect ('0' value). */
                     /*tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV4*/;
-                else if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
-                {
-                    tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV6;
-                    if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id)
-                        tmpReg |= HMCD_IP_REPLACE_ID;
-                }
                 else
-                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                                 ("One flag out of HDR_MANIP_IP_REPLACE_IPV4, HDR_MANIP_IP_REPLACE_IPV6 - must be set."));
+                    if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType
+                            == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
+                    {
+                        tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV6;
+                        if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id)
+                            tmpReg |= HMCD_IP_REPLACE_ID;
+                    }
+                    else
+                        RETURN_ERROR(
+                                MINOR,
+                                E_NOT_SUPPORTED,
+                                ("One flag out of HDR_MANIP_IP_REPLACE_IPV4, HDR_MANIP_IP_REPLACE_IPV6 - must be set."));
 
                 /* write the first 4 bytes of the descriptor */
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
                 /* save a pointer to the "last" indication word */
                 p_Last = p_TmpHmct;
 
-                p_TmpHmct += HMCD_BASIC_SIZE/4;
+                p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
-                size = p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
+                size =
+                        p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
                 ASSERT_COND(p_TmpData);
-                Mem2IOCpy32(p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdr, size);
+                Mem2IOCpy32(
+                        p_TmpData,
+                        p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdr,
+                        size);
                 tmpReg = (uint32_t)(size << HMCD_IP_REPLACE_L3HDRSIZE_SHIFT);
-                tmpReg |= (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
+                tmpReg |= (uint32_t)(XX_VirtToPhys(p_TmpData)
+                        - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
-                p_TmpHmct += HMCD_PTR_SIZE/4;
+                p_TmpHmct += HMCD_PTR_SIZE / 4;
                 p_TmpData += size;
 
-                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
-                        (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
+                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType
+                        == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
+                        && (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
                 {
-                    WRITE_UINT16(*(uint16_t*)p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.id);
-                    WRITE_UINT32(*p_TmpHmct, (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
+                    WRITE_UINT16(
+                            *(uint16_t*)p_TmpData,
+                            p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.id);
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
                     p_TmpData += 2;
                 }
-                p_TmpHmct += HMCD_PTR_SIZE/4;
-            break;
+                p_TmpHmct += HMCD_PTR_SIZE / 4;
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown customParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown customParams.type"));
         }
     }
 
 
     /* If this node has a nextManip, and no parsing is required after it, the old table must be copied to the new table
-       the old table and should be freed */
-    if (p_FmPcdManipParams->h_NextManip &&
-        (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
+     the old table and should be freed */
+    if (p_FmPcdManipParams->h_NextManip
+            && (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
     {
         if (new)
         {
-        /* If this is the first time this manip is created we need to free unused memory. If it
-         * is a dynamic changes case, the memory used is either the CC shadow or the existing
-         * table - no allocation, no free */
+            /* If this is the first time this manip is created we need to free unused memory. If it
+             * is a dynamic changes case, the memory used is either the CC shadow or the existing
+             * table - no allocation, no free */
             MANIP_UPDATE_UNIFIED_POSITION(p_FmPcdManipParams->h_NextManip);
 
             p_Manip->unifiedPosition = e_MANIP_UNIFIED_FIRST;
 
             /* The HMTD of the next Manip is never going to be used */
             if (((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->muramAllocate)
-                FM_MURAM_FreeMem(((t_FmPcd *)((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_FmPcd)->h_FmMuram, ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
+                FM_MURAM_FreeMem(
+                        ((t_FmPcd *)((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_FmPcd)->h_FmMuram,
+                        ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
             else
                 XX_Free(((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
             ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad = NULL;
 
             /* advance pointer */
-            p_TmpHmct += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
+            p_TmpHmct += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)
+                    / 4;
         }
     }
     else
@@ -643,63 +1060,71 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
     return E_OK;
 }
 
-static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip,
+                                    t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    t_FmPcdManip    *p_CurManip;
-    t_Error         err;
-    uint32_t        nextSize = 0, totalSize;
-    uint16_t        tmpReg;
-    uint8_t         *p_OldHmct, *p_TmpHmctPtr, *p_TmpDataPtr;
+    t_FmPcdManip *p_CurManip;
+    t_Error err;
+    uint32_t nextSize = 0, totalSize;
+    uint16_t tmpReg;
+    uint8_t *p_OldHmct, *p_TmpHmctPtr, *p_TmpDataPtr;
 
     /* set Manip structure */
     if (p_FmPcdManipParams->h_NextManip)
     {
         if (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
-            nextSize = (uint32_t)(GetHmctSize(p_FmPcdManipParams->h_NextManip) + GetDataSize(p_FmPcdManipParams->h_NextManip));
+            nextSize = (uint32_t)(GetHmctSize(p_FmPcdManipParams->h_NextManip)
+                    + GetDataSize(p_FmPcdManipParams->h_NextManip));
         else
             p_Manip->cascadedNext = TRUE;
     }
-    p_Manip->dontParseAfterManip = p_FmPcdManipParams->u.hdr.dontParseAfterManip;
+    p_Manip->dontParseAfterManip =
+            p_FmPcdManipParams->u.hdr.dontParseAfterManip;
 
     /* Allocate new table */
     /* calculate table size according to manip parameters */
-    err = CalculateTableSize(p_FmPcdManipParams, &p_Manip->tableSize, &p_Manip->dataSize);
+    err = CalculateTableSize(p_FmPcdManipParams, &p_Manip->tableSize,
+                             &p_Manip->dataSize);
     if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
-    totalSize =(uint16_t)(p_Manip->tableSize + p_Manip->dataSize + nextSize);
+    totalSize = (uint16_t)(p_Manip->tableSize + p_Manip->dataSize + nextSize);
 
-    p_Manip->p_Hmct = (uint8_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, totalSize, 4);
+    p_Manip->p_Hmct = (uint8_t*)FM_MURAM_AllocMem(
+            ((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, totalSize, 4);
     if (!p_Manip->p_Hmct)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
 
     if (p_Manip->dataSize)
-        p_Manip->p_Data = (uint8_t*)PTR_MOVE(p_Manip->p_Hmct, (p_Manip->tableSize + nextSize));
+        p_Manip->p_Data =
+                (uint8_t*)PTR_MOVE(p_Manip->p_Hmct, (p_Manip->tableSize + nextSize));
 
     /* update shadow size to allow runtime replacement of Header manipulation */
     /* The allocated shadow is divided as follows:
-       0 . . .       16 . . .
-       --------------------------------
-       |   Shadow   |   Shadow HMTD   |
-       |   HMTD     |   Match Table   |
-       | (16 bytes) | (maximal size)  |
-       --------------------------------
+     0 . . .       16 . . .
+     --------------------------------
+     |   Shadow   |   Shadow HMTD   |
+     |   HMTD     |   Match Table   |
+     | (16 bytes) | (maximal size)  |
+     --------------------------------
      */
 
-    err = FmPcdUpdateCcShadow (p_Manip->h_FmPcd, (uint32_t)(totalSize + 16), (uint16_t)FM_PCD_CC_AD_TABLE_ALIGN);
+    err = FmPcdUpdateCcShadow(p_Manip->h_FmPcd, (uint32_t)(totalSize + 16),
+                              (uint16_t)FM_PCD_CC_AD_TABLE_ALIGN);
     if (err != E_OK)
     {
         FM_MURAM_FreeMem(p_Manip->h_FmPcd, p_Manip->p_Hmct);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for HdrManip node shadow"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM allocation for HdrManip node shadow"));
     }
 
-
-    if (p_FmPcdManipParams->h_NextManip &&
-        (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
+    if (p_FmPcdManipParams->h_NextManip
+            && (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
     {
-        p_OldHmct = (uint8_t *)GetManipInfo(p_FmPcdManipParams->h_NextManip, e_MANIP_HMCT);
+        p_OldHmct = (uint8_t *)GetManipInfo(p_FmPcdManipParams->h_NextManip,
+                                            e_MANIP_HMCT);
         p_CurManip = p_FmPcdManipParams->h_NextManip;
-       /* Run till the last Manip (which is the first to configure) */
+        /* Run till the last Manip (which is the first to configure) */
         while (MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
             p_CurManip = p_CurManip->h_NextManip;
 
@@ -707,32 +1132,35 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
         {
             /* If this is a unified table, point to the part of the table
              * which is the relative offset in HMCT.
-            */
+             */
             p_TmpHmctPtr = (uint8_t*)PTR_MOVE(p_Manip->p_Hmct,
-                                              (p_Manip->tableSize +
-                                               (PTR_TO_UINT(p_CurManip->p_Hmct) -
-                                                PTR_TO_UINT(p_OldHmct))));
+                    (p_Manip->tableSize +
+                            (PTR_TO_UINT(p_CurManip->p_Hmct) -
+                                    PTR_TO_UINT(p_OldHmct))));
             if (p_CurManip->p_Data)
                 p_TmpDataPtr = (uint8_t*)PTR_MOVE(p_Manip->p_Hmct,
-                                                  (p_Manip->tableSize +
-                                                   (PTR_TO_UINT(p_CurManip->p_Data) -
-                                                    PTR_TO_UINT(p_OldHmct))));
+                        (p_Manip->tableSize +
+                                (PTR_TO_UINT(p_CurManip->p_Data) -
+                                        PTR_TO_UINT(p_OldHmct))));
             else
                 p_TmpDataPtr = NULL;
 
-            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr,
+                      p_TmpDataPtr, FALSE);
             /* update old manip table pointer */
             MANIP_SET_HMCT_PTR(p_CurManip, p_TmpHmctPtr);
             MANIP_SET_DATA_PTR(p_CurManip, p_TmpDataPtr);
 
             p_CurManip = p_CurManip->h_PrevManip;
-       }
+        }
         /* We copied the HMCT to create a new large HMCT so we can free the old one */
-        FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), p_OldHmct);
+        FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip),
+                         p_OldHmct);
     }
 
     /* Fill table */
-    err = BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, TRUE);
+    err = BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct,
+                    p_Manip->p_Data, TRUE);
     if (err)
     {
         FM_MURAM_FreeMem(p_Manip->h_FmPcd, p_Manip->p_Hmct);
@@ -745,32 +1173,34 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
     if (!p_Manip->dontParseAfterManip)
         tmpReg |= HMTD_CFG_PRS_AFTER_HM;
     /* create cascade */
-    if (p_FmPcdManipParams->h_NextManip &&
-        !MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+    if (p_FmPcdManipParams->h_NextManip
+            && !MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
     {
         /* indicate that there's another HM table descriptor */
         tmpReg |= HMTD_CFG_NEXT_AD_EN;
-        WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
-                     (uint16_t)((uint32_t)(XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip)) -
-                                (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
+        WRITE_UINT16(
+                ((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
+                (uint16_t)((uint32_t)(XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip)) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
     }
 
     WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->cfg, tmpReg);
-    WRITE_UINT32(((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
-                 (uint32_t)(XX_VirtToPhys(p_Manip->p_Hmct) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+    WRITE_UINT32(
+            ((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
+            (uint32_t)(XX_VirtToPhys(p_Manip->p_Hmct) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
 
     WRITE_UINT8(((t_Hmtd *)p_Manip->h_Ad)->opCode, HMAN_OC);
 
     return E_OK;
 }
 
-static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip,
+                                       t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    uint8_t         *p_WholeHmct, *p_TmpHmctPtr, newDataSize, *p_TmpDataPtr = NULL;
-    uint16_t        newSize;
-    t_FmPcd         *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
-    t_Error         err;
-    t_FmPcdManip    *p_CurManip = p_Manip;
+    uint8_t *p_WholeHmct, *p_TmpHmctPtr, newDataSize, *p_TmpDataPtr = NULL;
+    uint16_t newSize;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+    t_Error err;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     err = CalculateTableSize(p_FmPcdManipParams, &newSize, &newDataSize);
     if (err)
@@ -778,29 +1208,45 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
 
     /* check coherency of new table parameters */
     if (newSize > p_Manip->tableSize)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (command table)."));
+        RETURN_ERROR(
+                MINOR,
+                E_INVALID_VALUE,
+                ("New Hdr Manip configuration requires larger size than current one (command table)."));
     if (newDataSize > p_Manip->dataSize)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (data)."));
+        RETURN_ERROR(
+                MINOR,
+                E_INVALID_VALUE,
+                ("New Hdr Manip configuration requires larger size than current one (data)."));
     if (p_FmPcdManipParams->h_NextManip)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration can not contain h_NextManip."));
+        RETURN_ERROR(
+                MINOR, E_INVALID_VALUE,
+                ("New Hdr Manip configuration can not contain h_NextManip."));
     if (MANIP_IS_UNIFIED(p_Manip) && (newSize != p_Manip->tableSize))
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration in a chained manipulation requires different size than current one."));
-    if (p_Manip->dontParseAfterManip != p_FmPcdManipParams->u.hdr.dontParseAfterManip)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration differs in dontParseAfterManip value."));
+        RETURN_ERROR(
+                MINOR,
+                E_INVALID_VALUE,
+                ("New Hdr Manip configuration in a chained manipulation requires different size than current one."));
+    if (p_Manip->dontParseAfterManip
+            != p_FmPcdManipParams->u.hdr.dontParseAfterManip)
+        RETURN_ERROR(
+                MINOR,
+                E_INVALID_VALUE,
+                ("New Hdr Manip configuration differs in dontParseAfterManip value."));
 
     p_Manip->tableSize = newSize;
     p_Manip->dataSize = newDataSize;
 
-
     /* Build the new table in the shadow */
     if (!MANIP_IS_UNIFIED(p_Manip))
     {
         p_TmpHmctPtr = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow, 16);
         if (p_Manip->p_Data)
-            p_TmpDataPtr = (uint8_t*)PTR_MOVE(p_TmpHmctPtr,
-                                              (PTR_TO_UINT(p_Manip->p_Data) - PTR_TO_UINT(p_Manip->p_Hmct)));
+            p_TmpDataPtr =
+                    (uint8_t*)PTR_MOVE(p_TmpHmctPtr,
+                            (PTR_TO_UINT(p_Manip->p_Data) - PTR_TO_UINT(p_Manip->p_Hmct)));
 
-        BuildHmct(p_Manip, p_FmPcdManipParams, p_TmpHmctPtr, p_Manip->p_Data, FALSE);
+        BuildHmct(p_Manip, p_FmPcdManipParams, p_TmpHmctPtr, p_Manip->p_Data,
+                  FALSE);
     }
     else
     {
@@ -818,13 +1264,16 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
              * else, point to the beginning of the
              * shadow table (we save 16 for the HMTD.
              */
-            p_TmpHmctPtr = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
-                                              (16 + PTR_TO_UINT(p_CurManip->p_Hmct) - PTR_TO_UINT(p_WholeHmct)));
+            p_TmpHmctPtr =
+                    (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
+                            (16 + PTR_TO_UINT(p_CurManip->p_Hmct) - PTR_TO_UINT(p_WholeHmct)));
             if (p_CurManip->p_Data)
-                p_TmpDataPtr = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
-                                                  (16 + PTR_TO_UINT(p_CurManip->p_Data) - PTR_TO_UINT(p_WholeHmct)));
+                p_TmpDataPtr =
+                        (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
+                                (16 + PTR_TO_UINT(p_CurManip->p_Data) - PTR_TO_UINT(p_WholeHmct)));
 
-            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr,
+                      p_TmpDataPtr, FALSE);
             p_CurManip = p_CurManip->h_PrevManip;
         }
     }
@@ -832,16 +1281,18 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
     return E_OK;
 }
 
-static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+static t_Error CreateManipActionBackToOrig(
+        t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    uint8_t         *p_WholeHmct = NULL, *p_TmpHmctPtr, *p_TmpDataPtr;
-    t_FmPcdManip    *p_CurManip = p_Manip;
+    uint8_t *p_WholeHmct = NULL, *p_TmpHmctPtr, *p_TmpDataPtr;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     UNUSED(p_WholeHmct);
 
     /* Build the new table in the shadow */
     if (!MANIP_IS_UNIFIED(p_Manip))
-        BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, FALSE);
+        BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data,
+                  FALSE);
     else
     {
         p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);
@@ -859,7 +1310,8 @@ static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipPa
             p_TmpHmctPtr = p_CurManip->p_Hmct; /*- (uint32_t)p_WholeHmct*/
             p_TmpDataPtr = p_CurManip->p_Data; /*- (uint32_t)p_WholeHmct*/
 
-            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr,
+                      p_TmpDataPtr, FALSE);
 
             p_CurManip = p_CurManip->h_PrevManip;
         }
@@ -868,77 +1320,86 @@ static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipPa
     return E_OK;
 }
 
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Handle      p_Ad;
-    uint32_t      tmpReg32 = 0;
-    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    t_Handle p_Ad;
+    uint32_t tmpReg32 = 0;
+    SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
 
     switch (p_Manip->opcode)
     {
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-           if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+        p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+        if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+        {
+            tmpReg32 =
+            *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
+            tmpReg32 |= (uint32_t)((uint32_t)icOffset << 16);
+            *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets =
+            tmpReg32;
+            p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
+            p_Manip->icOffset = icOffset;
+        }
+        else
+        {
+            if (p_Manip->icOffset != icOffset)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("this manipulation was updated previously by different value"););
+        }
+        break;
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        if (p_Manip->h_Frag)
+        {
+            if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
             {
-                tmpReg32 = *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
-                tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
-                *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets = tmpReg32;
+                p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+                tmpReg32 |= GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets);
+                tmpReg32 |= (uint32_t)((uint32_t)icOffset << 16);
+                WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets, tmpReg32);
                 p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
                 p_Manip->icOffset = icOffset;
             }
             else
             {
                 if (p_Manip->icOffset != icOffset)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previously by different value"););
-            }
-            break;
-#ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if (p_Manip->h_Frag)
-            {
-                if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
-                {
-                    p_Ad     = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-                    tmpReg32 |= GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets);
-                    tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
-                    WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets, tmpReg32);
-                    p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
-                    p_Manip->icOffset = icOffset;
-                }
-                else
-                {
-                    if (p_Manip->icOffset != icOffset)
-                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
-                }
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
             }
-            break;
-#endif /* FM_CAPWAP_SUPPORT */
+        }
+        break;
     }
 
     return E_OK;
 }
 
-static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate)
+static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(
+        t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate)
 {
 
-    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)h_Ad;
-    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
-    t_Error                 err;
-    uint32_t                tmpReg32;
+    t_AdOfTypeContLookup *p_Ad = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
+    uint32_t tmpReg32;
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(
+            (p_Manip->opcode & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX),
+            E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->muramAllocate, E_INVALID_STATE);
 
     if (p_Manip->updateParams)
     {
-        if ((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
-           (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        if ((!(p_Manip->updateParams & OFFSET_OF_PR))
+                || (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("in this stage parameters from Port has not be updated"));
 
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_PSO;
@@ -946,27 +1407,34 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("Parser result offset wasn't configured previousely"));
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
         ASSERT_COND(!(fmPortGetSetCcParams.getCcParams.prOffset % 16));
 #endif
     }
-    else if (validate)
+    else
+    if (validate)
     {
-         if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
-           (p_Manip->updateParams & OFFSET_OF_PR))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+                || (p_Manip->updateParams & OFFSET_OF_PR))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("in this stage parameters from Port has be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_PSO;
         fmPortGetSetCcParams.setCcParams.psoSize = 16;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("Parser result offset wasn't configured previousely"));
 
     }
 
@@ -976,76 +1444,80 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
     {
         tmpReg32 = 0;
         tmpReg32 |= fmPortGetSetCcParams.getCcParams.prOffset;
-        WRITE_UINT32(p_Ad->matchTblPtr, (GET_UINT32(p_Ad->matchTblPtr) | tmpReg32));
+        WRITE_UINT32(p_Ad->matchTblPtr,
+                (GET_UINT32(p_Ad->matchTblPtr) | tmpReg32));
         p_Manip->updateParams &= ~OFFSET_OF_PR;
         p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
     }
-    else if (validate)
+    else
+    if (validate)
     {
         tmpReg32 = GET_UINT32(p_Ad->matchTblPtr);
         if ((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"););
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("this manipulation was updated previousely by different value"););
     }
 
     return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
 static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate,t_Handle h_FmTree)
 {
-    t_AdOfTypeContLookup            *p_Ad         = (t_AdOfTypeContLookup *)h_Ad;
-    t_FmPcdCcSavedManipParams       *p_SavedManipParams = NULL;
-    uint32_t                        tmpReg32 = 0;
+    t_AdOfTypeContLookup *p_Ad = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPcdCcSavedManipParams *p_SavedManipParams = NULL;
+    uint32_t tmpReg32 = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->opcode == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
 
-    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
     if (p_Manip->updateParams)
     {
 
         if ((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
-           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+                ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
         if (!p_SavedManipParams)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
-        p_Manip->fragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
+        p_Manip->capwapFragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
 
         tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
-        tmpReg32 |= ((uint32_t)p_Manip->fragParams.dataOffset<< 16);
+        tmpReg32 |= ((uint32_t)p_Manip->capwapFragParams.dataOffset<< 16);
         WRITE_UINT32(p_Ad->pcAndOffsets,tmpReg32);
 
         p_Manip->updateParams &= ~OFFSET_OF_DATA;
         p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
     }
-   else if (validate)
-   {
+    else if (validate)
+    {
 
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
         if (!p_SavedManipParams)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
-        if (p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
-   }
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
+        if (p_Manip->capwapFragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
+    }
 
     return E_OK;
 }
 
-static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
-                                             t_FmPcdManip   *p_Manip,
-                                             t_Handle       h_Ad,
-                                             bool           validate,
-                                             t_Handle       h_FmTree)
+static t_Error UpdateInitCapwapFragmentation(t_Handle h_FmPort,
+        t_FmPcdManip *p_Manip,
+        t_Handle h_Ad,
+        bool validate,
+        t_Handle h_FmTree)
 {
-    t_AdOfTypeContLookup        *p_Ad;
-    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
-    t_Error                     err;
-    uint32_t                    tmpReg32 = 0;
-    t_FmPcdCcSavedManipParams   *p_SavedManipParams;
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
+    uint32_t tmpReg32 = 0;
+    t_FmPcdCcSavedManipParams *p_SavedManipParams;
 
     UNUSED(h_Ad);
 
@@ -1053,15 +1525,15 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION) ||
-                               (p_Manip->opcode == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+                    (p_Manip->opcode == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
 
-    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
     if (p_Manip->updateParams)
     {
         if ((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
-            ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+                ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
@@ -1070,10 +1542,10 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
 
         p_SavedManipParams = (t_FmPcdCcSavedManipParams *)XX_Malloc(sizeof(t_FmPcdCcSavedManipParams));
         p_SavedManipParams->capwapParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
@@ -1087,17 +1559,17 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
     else if (validate)
     {
         if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) ||
-            ((p_Manip->updateParams & OFFSET_OF_DATA)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+                ((p_Manip->updateParams & OFFSET_OF_DATA)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
     }
 
     if (p_Manip->updateParams)
@@ -1108,31 +1580,31 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
 
         p_Manip->updateParams &= ~OFFSET_OF_DATA;
         p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
-        p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+        p_Manip->capwapFragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
     }
     else if (validate)
     {
-        if (p_Manip->fragParams.dataOffset != fmPortGetSetCcParams.getCcParams.dataOffset)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
+        if (p_Manip->capwapFragParams.dataOffset != fmPortGetSetCcParams.getCcParams.dataOffset)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
     }
 
     return E_OK;
 }
 
-static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
-                                     t_Handle      h_FmPort,
-                                     t_FmPcdManip  *p_Manip,
-                                     t_Handle      h_Ad,
-                                     bool          validate)
+static t_Error UpdateInitCapwapReasm(t_Handle h_FmPcd,
+        t_Handle h_FmPort,
+        t_FmPcdManip *p_Manip,
+        t_Handle h_Ad,
+        bool validate)
 {
-    t_CapwapReasmPram                   *p_ReassmTbl;
-    t_Error                             err;
-    t_FmPortGetSetCcParams              fmPortGetSetCcParams;
-    uint8_t                             i = 0;
-    uint16_t                            size;
-    uint32_t                            tmpReg32;
-    t_FmPcd                             *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdCcCapwapReassmTimeoutParams  ccCapwapReassmTimeoutParams;
+    t_CapwapReasmPram *p_ReassmTbl;
+    t_Error err;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    uint8_t i = 0;
+    uint16_t size;
+    uint32_t tmpReg32;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcCapwapReassmTimeoutParams ccCapwapReassmTimeoutParams;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
@@ -1142,24 +1614,24 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
 
     if (p_Manip->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                     ("handler of PCD previously was initiated by different value"));
+    RETURN_ERROR(MAJOR, E_INVALID_STATE,
+            ("handler of PCD previously was initiated by different value"));
 
     UNUSED(h_Ad);
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
-    p_ReassmTbl  = (t_CapwapReasmPram *)p_Manip->h_Frag;
+    p_ReassmTbl = (t_CapwapReasmPram *)p_Manip->h_Frag;
 
     if (p_Manip->updateParams)
     {
         if ((!(p_Manip->updateParams & NUM_OF_TASKS) &&
-             !(p_Manip->updateParams & OFFSET_OF_DATA) &&
-             !(p_Manip->updateParams & OFFSET_OF_PR) &&
-             !(p_Manip->updateParams & HW_PORT_ID)) ||
-            ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) ||
-             (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR) ||
-             (p_Manip->shadowUpdateParams & HW_PORT_ID)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+                        !(p_Manip->updateParams & OFFSET_OF_DATA) &&
+                        !(p_Manip->updateParams & OFFSET_OF_PR) &&
+                        !(p_Manip->updateParams & HW_PORT_ID)) ||
+                ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) ||
+                        (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR) ||
+                        (p_Manip->shadowUpdateParams & HW_PORT_ID)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
@@ -1167,28 +1639,28 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previousely"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previousely"));
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
         if (fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
         ASSERT_COND((fmPortGetSetCcParams.getCcParams.dataOffset % 16) == 0);
 #endif /* FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004 */
     }
     else if (validate)
     {
-         if ((!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
-              !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
-              !(p_Manip->shadowUpdateParams & OFFSET_OF_PR) &&
-              !(p_Manip->shadowUpdateParams & HW_PORT_ID)) &&
-             ((p_Manip->updateParams & NUM_OF_TASKS) ||
-              (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR) ||
-              (p_Manip->updateParams & HW_PORT_ID)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        if ((!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
+                        !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
+                        !(p_Manip->shadowUpdateParams & OFFSET_OF_PR) &&
+                        !(p_Manip->shadowUpdateParams & HW_PORT_ID)) &&
+                ((p_Manip->updateParams & NUM_OF_TASKS) ||
+                        (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR) ||
+                        (p_Manip->updateParams & HW_PORT_ID)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
 
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
@@ -1196,14 +1668,14 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previously"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previously"));
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previously"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previously"));
         if (fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
     }
 
     if (p_Manip->updateParams)
@@ -1211,57 +1683,57 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
         if (p_Manip->updateParams & NUM_OF_TASKS)
         {
             /*recommendation of Microcode team - (maxNumFramesInProcess * 2) */
-            size = (uint16_t)(p_Manip->fragParams.maxNumFramesInProcess*2 + fmPortGetSetCcParams.getCcParams.numOfTasks);
-            if (size  > 255)
-                RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"));
+            size = (uint16_t)(p_Manip->capwapFragParams.maxNumFramesInProcess*2 + fmPortGetSetCcParams.getCcParams.numOfTasks);
+            if (size > 255)
+            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"));
 
-            p_Manip->fragParams.numOfTasks = fmPortGetSetCcParams.getCcParams.numOfTasks;
+            p_Manip->capwapFragParams.numOfTasks = fmPortGetSetCcParams.getCcParams.numOfTasks;
 
             /*p_ReassmFrmDescrIndxPoolTbl*/
-            p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl =
-                (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                            (uint32_t)(size + 1),
-                                            4);
-            if (!p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer index pool table"));
+            p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl =
+            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                    (uint32_t)(size + 1),
+                    4);
+            if (!p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer index pool table"));
 
-            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size + 1));
+            IOMemSet32(p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl, 0, (uint32_t)(size + 1));
 
             for ( i = 0; i < size; i++)
-                WRITE_UINT8(*(uint8_t *)PTR_MOVE(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, i), (uint8_t)(i+1));
+            WRITE_UINT8(*(uint8_t *)PTR_MOVE(p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl, i), (uint8_t)(i+1));
 
-            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
 
             WRITE_UINT32(p_ReassmTbl->reasmFrmDescIndexPoolTblPtr, tmpReg32);
 
             /*p_ReassmFrmDescrPoolTbl*/
-            p_Manip->fragParams.p_ReassmFrmDescrPoolTbl =
-                (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                            (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
-                                            4);
+            p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl =
+            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                    (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
+                    4);
 
-           if (!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer pool table"));
+            if (!p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer pool table"));
 
-            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl, 0,  (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
+            IOMemSet32(p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl, 0, (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
 
-            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl) - p_FmPcd->physicalMuramBase);
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl) - p_FmPcd->physicalMuramBase);
 
             WRITE_UINT32(p_ReassmTbl->reasmFrmDescPoolTblPtr, tmpReg32);
 
             /*p_TimeOutTbl*/
 
-            p_Manip->fragParams.p_TimeOutTbl =
-                (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                            (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
-                                            4);
+            p_Manip->capwapFragParams.p_TimeOutTbl =
+            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                    (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
+                    4);
 
-            if (!p_Manip->fragParams.p_TimeOutTbl)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly timeout table"));
+            if (!p_Manip->capwapFragParams.p_TimeOutTbl)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly timeout table"));
 
-            IOMemSet32(p_Manip->fragParams.p_TimeOutTbl, 0,  (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
+            IOMemSet32(p_Manip->capwapFragParams.p_TimeOutTbl, 0, (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
 
-            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_TimeOutTbl) - p_FmPcd->physicalMuramBase);
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_TimeOutTbl) - p_FmPcd->physicalMuramBase);
             WRITE_UINT32(p_ReassmTbl->timeOutTblPtr, tmpReg32);
 
             p_Manip->updateParams &= ~NUM_OF_TASKS;
@@ -1270,9 +1742,9 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         if (p_Manip->updateParams & OFFSET_OF_DATA)
         {
-            p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+            p_Manip->capwapFragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
             tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
-            tmpReg32|= p_Manip->fragParams.dataOffset;
+            tmpReg32|= p_Manip->capwapFragParams.dataOffset;
             WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
             p_Manip->updateParams &= ~OFFSET_OF_DATA;
             p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
@@ -1280,83 +1752,84 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         if (!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
         {
-            p_Manip->fragParams.prOffset = fmPortGetSetCcParams.getCcParams.prOffset;
+            p_Manip->capwapFragParams.prOffset = fmPortGetSetCcParams.getCcParams.prOffset;
 
             tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
             tmpReg32|= FM_PCD_MANIP_CAPWAP_REASM_PR_COPY;
             WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
 
             tmpReg32 = GET_UINT32(p_ReassmTbl->intStatsTblPtr);
-            tmpReg32 |= (uint32_t)p_Manip->fragParams.prOffset << 24;
+            tmpReg32 |= (uint32_t)p_Manip->capwapFragParams.prOffset << 24;
             WRITE_UINT32(p_ReassmTbl->intStatsTblPtr, tmpReg32);
-           p_Manip->updateParams &= ~OFFSET_OF_PR;
-           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
-       }
-       else
-       {
-           p_Manip->fragParams.prOffset = 0xff;
-           p_Manip->updateParams &= ~OFFSET_OF_PR;
-           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
-       }
-
-       p_Manip->fragParams.hwPortId = fmPortGetSetCcParams.getCcParams.hardwarePortId;
-       p_Manip->updateParams &= ~HW_PORT_ID;
-       p_Manip->shadowUpdateParams |= HW_PORT_ID;
+            p_Manip->updateParams &= ~OFFSET_OF_PR;
+            p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+        }
+        else
+        {
+            p_Manip->capwapFragParams.prOffset = 0xff;
+            p_Manip->updateParams &= ~OFFSET_OF_PR;
+            p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+        }
+
+        p_Manip->capwapFragParams.hwPortId = fmPortGetSetCcParams.getCcParams.hardwarePortId;
+        p_Manip->updateParams &= ~HW_PORT_ID;
+        p_Manip->shadowUpdateParams |= HW_PORT_ID;
 
         /*timeout hc */
-       ccCapwapReassmTimeoutParams.fqidForTimeOutFrames = p_Manip->fragParams.fqidForTimeOutFrames;
-       ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl = (uint32_t)p_Manip->fragParams.hwPortId << 24;
-       ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl |= (uint32_t)((XX_VirtToPhys(p_ReassmTbl) - p_FmPcd->physicalMuramBase));
-       ccCapwapReassmTimeoutParams.timeoutRequestTime = (((uint32_t)1<<p_Manip->fragParams.bitFor1Micro) * p_Manip->fragParams.timeoutRoutineRequestTime)/2;
-       return FmHcPcdCcCapwapTimeoutReassm(p_FmPcd->h_Hc,&ccCapwapReassmTimeoutParams);
+        ccCapwapReassmTimeoutParams.fqidForTimeOutFrames = p_Manip->capwapFragParams.fqidForTimeOutFrames;
+        ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl = (uint32_t)p_Manip->capwapFragParams.hwPortId << 24;
+        ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl |= (uint32_t)((XX_VirtToPhys(p_ReassmTbl) - p_FmPcd->physicalMuramBase));
+        ccCapwapReassmTimeoutParams.timeoutRequestTime = (((uint32_t)1<<p_Manip->capwapFragParams.bitFor1Micro) * p_Manip->capwapFragParams.timeoutRoutineRequestTime)/2;
+        return FmHcPcdCcCapwapTimeoutReassm(p_FmPcd->h_Hc,&ccCapwapReassmTimeoutParams);
     }
 
     else if (validate)
     {
-        if (fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
-        if (fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
-
+        if (fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->capwapFragParams.hwPortId)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
+        if (fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->capwapFragParams.numOfTasks)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
 
         if (!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
         {
-            if (p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+            if (p_Manip->capwapFragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
         }
         else
         {
-            if (p_Manip->fragParams.prOffset != 0xff)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+            if (p_Manip->capwapFragParams.prOffset != 0xff)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
         }
-        if (fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));
+        if (fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->capwapFragParams.dataOffset)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));
     }
 
     return E_OK;
 }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
-t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
+t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_ReasmCommonPramTbl)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcIpReassmTimeoutParams  ccIpReassmTimeoutParams = {0};
-    t_Error                         err = E_OK;
-    uint8_t                         result;
-    uint32_t                        bitFor1Micro, tsbs, log2num;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcReassmTimeoutParams ccReassmTimeoutParams = { 0 };
+    t_Error err = E_OK;
+    uint8_t result;
+    uint32_t bitFor1Micro, tsbs, log2num;
 
     ASSERT_COND(p_FmPcd);
-    ASSERT_COND(h_IpReasmCommonPramTbl);
+    ASSERT_COND(h_ReasmCommonPramTbl);
 
     bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
     bitFor1Micro = 32 - bitFor1Micro;
-    LOG2(FM_PCD_MANIP_IP_REASSM_TIMEOUT_THREAD_THRESH, log2num);
+    LOG2(FM_PCD_MANIP_REASM_TIMEOUT_THREAD_THRESH, log2num);
     tsbs = bitFor1Micro - log2num;
 
-    ccIpReassmTimeoutParams.iprcpt      = (uint32_t)(XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
-    ccIpReassmTimeoutParams.tsbs        = (uint8_t)tsbs;
-    ccIpReassmTimeoutParams.activate    = TRUE;
-    if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
+    ccReassmTimeoutParams.iprcpt = (uint32_t)(XX_VirtToPhys(
+            h_ReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccReassmTimeoutParams.tsbs = (uint8_t)tsbs;
+    ccReassmTimeoutParams.activate = TRUE;
+    if ((err = FmHcPcdCcTimeoutReassm(p_FmPcd->h_Hc, &ccReassmTimeoutParams,
+                                      &result)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     switch (result)
@@ -1366,9 +1839,12 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
         case (1):
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate TNUM"));
         case (2):
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer from the HC-Port"));
+            RETURN_ERROR(
+                    MAJOR, E_NO_MEMORY,
+                    ("failed to allocate internal buffer from the HC-Port"));
         case (3):
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("'Disable Timeout Task' with invalid IPRCPT"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("'Disable Timeout Task' with invalid IPRCPT"));
         case (4):
             RETURN_ERROR(MAJOR, E_FULL, ("too many timeout tasks"));
         case (5):
@@ -1379,137 +1855,188 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
     return E_OK;
 }
 
-static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
+static t_Error CreateReassCommonTable(t_FmPcdManip *p_Manip)
 {
-    uint32_t    tmpReg32 = 0, i;
-    uint64_t    tmpReg64, size;
-    t_FmPcd     *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
-    t_Error     err = E_OK;
+    uint32_t tmpReg32 = 0, i;
+    uint64_t tmpReg64, size;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+    t_Error err = E_OK;
 
-    /* Allocation of the IP Reassembly Common Parameters table. This table is located in the
-    MURAM. Its size is 64 bytes and its base address should be 8-byte aligned.
-    It contains parameters that are common to both the IPv4 reassembly function and IPv6
-    reassembly function.*/
-    p_Manip->ipReassmParams.p_IpReassCommonTbl =
-        (t_IpReassCommonTbl *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE,
-                                                FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN);
+    /* Allocation of the Reassembly Common Parameters table. This table is located in the
+     MURAM. Its size is 64 bytes and its base address should be 8-byte aligned. */
+    p_Manip->reassmParams.p_ReassCommonTbl =
+            (t_ReassCommonTbl *)FM_MURAM_AllocMem(
+                    p_FmPcd->h_FmMuram,
+                    FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_SIZE,
+                    FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_ALIGN);
 
-    if (!p_Manip->ipReassmParams.p_IpReassCommonTbl)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly common parameters table"));
+    if (!p_Manip->reassmParams.p_ReassCommonTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Reassembly common parameters table"));
 
-    IOMemSet32(p_Manip->ipReassmParams.p_IpReassCommonTbl, 0,  FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE);
+    IOMemSet32(p_Manip->reassmParams.p_ReassCommonTbl, 0,
+               FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_SIZE);
 
     /* Setting the TimeOut Mode.*/
     tmpReg32 = 0;
-    if (p_Manip->ipReassmParams.timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
-        tmpReg32 |= FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES;
+    if (p_Manip->reassmParams.timeOutMode
+            == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
+        tmpReg32 |= FM_PCD_MANIP_REASM_TIME_OUT_BETWEEN_FRAMES;
 
     /* Setting TimeOut FQID - Frames that time out are enqueued to this FQID.
-    In order to cause TimeOut frames to be discarded, this queue should be configured accordingly*/
-    tmpReg32 |= p_Manip->ipReassmParams.fqidForTimeOutFrames;
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->timeoutModeAndFqid, tmpReg32);
+     In order to cause TimeOut frames to be discarded, this queue should be configured accordingly*/
+    tmpReg32 |= p_Manip->reassmParams.fqidForTimeOutFrames;
+    WRITE_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->timeoutModeAndFqid,
+                 tmpReg32);
 
     /* Calculation the size of IP Reassembly Frame Descriptor - number of frames that are allowed to be reassembled simultaneously + 129.*/
-    size = p_Manip->ipReassmParams.maxNumFramesInProcess + 129;
+    size = p_Manip->reassmParams.maxNumFramesInProcess + 129;
 
     /*Allocation of IP Reassembly Frame Descriptor Indexes Pool - This pool resides in the MURAM */
-    p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr =
-         PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                       (uint32_t)(size * 2),
-                                       256));
-    if (!p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly frame descriptor indexes pool"));
-
-    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr), 0,  (uint32_t)(size * 2));
+    p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr =
+            PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                            (uint32_t)(size * 2),
+                            256));
+    if (!p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr)
+        RETURN_ERROR(
+                MAJOR, E_NO_MEMORY,
+                ("MURAM alloc for Reassembly frame descriptor indexes pool"));
+
+    IOMemSet32(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr),
+               0, (uint32_t)(size * 2));
 
     /* The entries in IP Reassembly Frame Descriptor Indexes Pool contains indexes starting with 1 up to
-    the maximum number of frames that are allowed to be reassembled simultaneously + 128.
-    The last entry in this pool must contain the index zero*/
-    for (i=0; i<(size-1); i++)
-        WRITE_UINT16(*(uint16_t *)PTR_MOVE(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr), (i<<1)),
-                     (uint16_t)(i+1));
+     the maximum number of frames that are allowed to be reassembled simultaneously + 128.
+     The last entry in this pool must contain the index zero*/
+    for (i = 0; i < (size - 1); i++)
+        WRITE_UINT16(
+                *(uint16_t *)PTR_MOVE(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr), (i<<1)),
+                (uint16_t)(i+1));
 
     /* Sets the IP Reassembly Frame Descriptor Indexes Pool offset from MURAM */
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)) - p_FmPcd->physicalMuramBase);
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->reassFrmDescIndexPoolTblPtr, tmpReg32);
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(
+            UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr))
+            - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(
+            p_Manip->reassmParams.p_ReassCommonTbl->reassFrmDescIndexPoolTblPtr,
+            tmpReg32);
 
     /* Allocation of the Reassembly Frame Descriptors Pool - This pool resides in external memory.
-    The number of entries in this pool should be equal to the number of entries in IP Reassembly Frame Descriptor Indexes Pool.*/
-    p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr =
-        PTR_TO_UINT(XX_MallocSmart((uint32_t)(size * 64), p_Manip->ipReassmParams.dataMemId, 64));
+     The number of entries in this pool should be equal to the number of entries in IP Reassembly Frame Descriptor Indexes Pool.*/
+    p_Manip->reassmParams.reassFrmDescrPoolTblAddr =
+            PTR_TO_UINT(XX_MallocSmart((uint32_t)(size * 64), p_Manip->reassmParams.dataMemId, 64));
 
-    if (!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
+    if (!p_Manip->reassmParams.reassFrmDescrPoolTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
 
-    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr), 0,  (uint32_t)(size * 64));
+    IOMemSet32(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrPoolTblAddr), 0,
+               (uint32_t)(size * 64));
 
     /* Sets the Reassembly Frame Descriptors Pool and liodn offset*/
-    tmpReg64 = (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)));
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->liodnAndReassFrmDescPoolPtrHi, (uint32_t)(tmpReg64 >> 32));
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->reassFrmDescPoolPtrLow, (uint32_t)tmpReg64);
+    tmpReg64 = (uint64_t)(XX_VirtToPhys(
+            UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrPoolTblAddr)));
+    tmpReg64 |= ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_LIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_ELIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_ELIODN_SHIFT);
+    WRITE_UINT32(
+            p_Manip->reassmParams.p_ReassCommonTbl->liodnAndReassFrmDescPoolPtrHi,
+            (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32(
+            p_Manip->reassmParams.p_ReassCommonTbl->reassFrmDescPoolPtrLow,
+            (uint32_t)tmpReg64);
 
     /*Allocation of the TimeOut table - This table resides in the MURAM.
-    The number of entries in this table is identical to the number of entries in the Reassembly Frame Descriptors Pool*/
-    p_Manip->ipReassmParams.timeOutTblAddr =
-        PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)(size  * 8),8));
+     The number of entries in this table is identical to the number of entries in the Reassembly Frame Descriptors Pool*/
+    p_Manip->reassmParams.timeOutTblAddr =
+            PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)(size * 8),8));
 
-    if (!p_Manip->ipReassmParams.timeOutTblAddr)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly timeout table"));
+    if (!p_Manip->reassmParams.timeOutTblAddr)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Reassembly timeout table"));
 
-    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr), 0,  (uint16_t)(size * 8));
+    IOMemSet32(UINT_TO_PTR(p_Manip->reassmParams.timeOutTblAddr), 0,
+               (uint16_t)(size * 8));
 
     /* Sets the TimeOut table offset from MURAM */
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr)) - p_FmPcd->physicalMuramBase);
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->timeOutTblPtr, tmpReg32);
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(
+            UINT_TO_PTR(p_Manip->reassmParams.timeOutTblAddr))
+            - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->timeOutTblPtr,
+                 tmpReg32);
 
     /* Sets the Expiration Delay */
     tmpReg32 = 0;
-    tmpReg32 |= (((uint32_t)(1 << FmGetTimeStampScale(p_FmPcd->h_Fm))) * p_Manip->ipReassmParams.timeoutThresholdForReassmProcess);
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->expirationDelay, tmpReg32);
+    tmpReg32 |= (((uint32_t)(1 << FmGetTimeStampScale(p_FmPcd->h_Fm)))
+            * p_Manip->reassmParams.timeoutThresholdForReassmProcess);
+    WRITE_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->expirationDelay,
+                 tmpReg32);
 
-    err = FmPcdRegisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
+    err = FmPcdRegisterReassmPort(p_FmPcd,
+                                  p_Manip->reassmParams.p_ReassCommonTbl);
     if (err != E_OK)
     {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_IpReassCommonTbl);
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                         p_Manip->reassmParams.p_ReassCommonTbl);
         RETURN_ERROR(MAJOR, err, ("port registration"));
     }
 
     return err;
 }
 
-static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
+static t_Error CreateReassTable(t_FmPcdManip *p_Manip, e_NetHeaderType hdr)
 {
-    t_FmPcd                 *p_FmPcd = p_Manip->h_FmPcd;
-    uint32_t                tmpReg32, autoLearnHashTblSize;
-    uint32_t                numOfWays, setSize, setSizeCode, keySize;
-    uint32_t                waySize, numOfSets, numOfEntries;
-    uint64_t                tmpReg64;
-    uint16_t                minFragSize;
-    uintptr_t               *p_AutoLearnHashTblAddr, *p_AutoLearnSetLockTblAddr;
-    t_IpReassTbl            **p_IpReassTbl;
-
-    if (ipv4)
-    {
-        p_IpReassTbl = &p_Manip->ipReassmParams.p_Ipv4ReassTbl;
-        p_AutoLearnHashTblAddr = &p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr;
-        p_AutoLearnSetLockTblAddr = &p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr;
-        minFragSize = p_Manip->ipReassmParams.minFragSize[0];
-        numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry[0];
-        keySize = 4 + 4 + 1 + 2; /* 3-tuple + IP-Id */
-    }
-    else
+    t_FmPcd *p_FmPcd = p_Manip->h_FmPcd;
+    uint32_t tmpReg32, autoLearnHashTblSize;
+    uint32_t numOfWays, setSize, setSizeCode, keySize;
+    uint32_t waySize, numOfSets, numOfEntries;
+    uint64_t tmpReg64;
+    uint16_t minFragSize;
+    uint16_t maxReassemSize;
+    uintptr_t *p_AutoLearnHashTblAddr, *p_AutoLearnSetLockTblAddr;
+    t_ReassTbl **p_ReassTbl;
+
+    switch (hdr)
     {
-        p_IpReassTbl = &p_Manip->ipReassmParams.p_Ipv6ReassTbl;
-        p_AutoLearnHashTblAddr = &p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr;
-        p_AutoLearnSetLockTblAddr = &p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr;
-        minFragSize = p_Manip->ipReassmParams.minFragSize[1];
-        numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry[1];
-        keySize = 16 + 16 + 4; /* 2-tuple + IP-Id */
-        if (numOfWays > e_FM_PCD_MANIP_SIX_WAYS_HASH)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("num of ways"));
+        case HEADER_TYPE_IPv4:
+            p_ReassTbl = &p_Manip->reassmParams.ip.p_Ipv4ReassTbl;
+            p_AutoLearnHashTblAddr =
+                    &p_Manip->reassmParams.ip.ipv4AutoLearnHashTblAddr;
+            p_AutoLearnSetLockTblAddr =
+                    &p_Manip->reassmParams.ip.ipv4AutoLearnSetLockTblAddr;
+            minFragSize = p_Manip->reassmParams.ip.minFragSize[0];
+            maxReassemSize = 0;
+            numOfWays = p_Manip->reassmParams.ip.numOfFramesPerHashEntry[0];
+            keySize = 4 + 4 + 1 + 2; /* 3-tuple + IP-Id */
+            break;
+        case HEADER_TYPE_IPv6:
+            p_ReassTbl = &p_Manip->reassmParams.ip.p_Ipv6ReassTbl;
+            p_AutoLearnHashTblAddr =
+                    &p_Manip->reassmParams.ip.ipv6AutoLearnHashTblAddr;
+            p_AutoLearnSetLockTblAddr =
+                    &p_Manip->reassmParams.ip.ipv6AutoLearnSetLockTblAddr;
+            minFragSize = p_Manip->reassmParams.ip.minFragSize[1];
+            maxReassemSize = 0;
+            numOfWays = p_Manip->reassmParams.ip.numOfFramesPerHashEntry[1];
+            keySize = 16 + 16 + 4; /* 2-tuple + IP-Id */
+            if (numOfWays > e_FM_PCD_MANIP_SIX_WAYS_HASH)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("num of ways"));
+            break;
+        case HEADER_TYPE_CAPWAP:
+            p_ReassTbl = &p_Manip->reassmParams.capwap.p_ReassTbl;
+            p_AutoLearnHashTblAddr =
+                    &p_Manip->reassmParams.capwap.autoLearnHashTblAddr;
+            p_AutoLearnSetLockTblAddr =
+                    &p_Manip->reassmParams.capwap.autoLearnSetLockTblAddr;
+            minFragSize = 0;
+            maxReassemSize = p_Manip->reassmParams.capwap.maxRessembledsSize;
+            numOfWays = p_Manip->reassmParams.capwap.numOfFramesPerHashEntry;
+            keySize = 4;
+            break;
+        default:
+            break;
     }
     keySize += 2; /* 2 bytes reserved for RFDIndex */
 #if (DPAA_VERSION >= 11)
@@ -1517,17 +2044,19 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
 #endif /* (DPAA_VERSION >= 11) */
     waySize = ROUND_UP(keySize, 8);
 
-    /* Allocates the IP Reassembly Parameters Table - This table is located in the MURAM.*/
-    *p_IpReassTbl = (t_IpReassTbl *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                      FM_PCD_MANIP_IP_REASM_TABLE_SIZE,
-                                                      FM_PCD_MANIP_IP_REASM_TABLE_ALIGN);
-    if (!*p_IpReassTbl)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly IPv4/IPv6 specific parameters table"));
-    memset(*p_IpReassTbl, 0, sizeof(t_IpReassTbl));
+    /* Allocates the Reassembly Parameters Table - This table is located in the MURAM.*/
+    *p_ReassTbl = (t_ReassTbl *)FM_MURAM_AllocMem(
+            p_FmPcd->h_FmMuram, FM_PCD_MANIP_REASM_TABLE_SIZE,
+            FM_PCD_MANIP_REASM_TABLE_ALIGN);
+    if (!*p_ReassTbl)
+        RETURN_ERROR( MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Reassembly specific parameters table"));
+    memset(*p_ReassTbl, 0, sizeof(t_ReassTbl));
 
-    /* Sets the IP Reassembly common Parameters table offset from MURAM in the IP Reassembly Table descriptor*/
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_IpReassCommonTbl) - p_FmPcd->physicalMuramBase);
-    WRITE_UINT32((*p_IpReassTbl)->ipReassCommonPrmTblPtr, tmpReg32);
+    /* Sets the Reassembly common Parameters table offset from MURAM in the Reassembly Table descriptor*/
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->reassmParams.p_ReassCommonTbl)
+            - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32((*p_ReassTbl)->reassCommonPrmTblPtr, tmpReg32);
 
     /* Calculate set size (set size is rounded-up to next power of 2) */
     NEXT_POWER_OF_2(numOfWays * waySize, setSize);
@@ -1536,12 +2065,13 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     LOG2(setSize, setSizeCode);
 
     /* Sets ways number and set size code */
-    WRITE_UINT16((*p_IpReassTbl)->waysNumAndSetSize, (uint16_t)((numOfWays << 8) | setSizeCode));
+    WRITE_UINT16((*p_ReassTbl)->waysNumAndSetSize,
+                 (uint16_t)((numOfWays << 8) | setSizeCode));
 
     /* It is recommended that the total number of entries in this table
-    (number of sets * number of ways) will be twice the number of frames that
+     (number of sets * number of ways) will be twice the number of frames that
      are expected to be reassembled simultaneously.*/
-    numOfEntries = (uint32_t)(p_Manip->ipReassmParams.maxNumFramesInProcess * 2);
+    numOfEntries = (uint32_t)(p_Manip->reassmParams.maxNumFramesInProcess * 2);
 
     /* sets number calculation - number of entries = number of sets * number of ways */
     numOfSets = numOfEntries / numOfWays;
@@ -1549,77 +2079,92 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     /* Sets AutoLearnHashKeyMask*/
     NEXT_POWER_OF_2(numOfSets, numOfSets);
 
-    WRITE_UINT16((*p_IpReassTbl)->autoLearnHashKeyMask, (uint16_t)(numOfSets - 1));
+    WRITE_UINT16((*p_ReassTbl)->autoLearnHashKeyMask,
+                 (uint16_t)(numOfSets - 1));
 
-    /* Allocation of IP Reassembly Automatic Learning Hash Table - This table resides in external memory.
-    The size of this table is determined by the number of sets and the set size.
-    Table size = set size * number of sets
-    This table base address should be aligned to SetSize.*/
+    /* Allocation of Reassembly Automatic Learning Hash Table - This table resides in external memory.
+     The size of this table is determined by the number of sets and the set size.
+     Table size = set size * number of sets
+     This table base address should be aligned to SetSize.*/
     autoLearnHashTblSize = numOfSets * setSize;
 
-    *p_AutoLearnHashTblAddr = PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize));
+    *p_AutoLearnHashTblAddr =
+            PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->reassmParams.dataMemId, setSize));
     if (!*p_AutoLearnHashTblAddr)
     {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
-        *p_IpReassTbl = NULL;
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_ReassTbl);
+        *p_ReassTbl = NULL;
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
-    IOMemSet32(UINT_TO_PTR(*p_AutoLearnHashTblAddr), 0,  autoLearnHashTblSize);
-
-    /* Sets the IP Reassembly Automatic Learning Hash Table and liodn offset */
-    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    IOMemSet32(UINT_TO_PTR(*p_AutoLearnHashTblAddr), 0, autoLearnHashTblSize);
+
+    /* Sets the Reassembly Automatic Learning Hash Table and liodn offset */
+    tmpReg64 = ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_LIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_ELIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_ELIODN_SHIFT);
     tmpReg64 |= XX_VirtToPhys(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
-    WRITE_UINT32((*p_IpReassTbl)->liodnAlAndAutoLearnHashTblPtrHi, (uint32_t)(tmpReg64 >> 32));
-    WRITE_UINT32((*p_IpReassTbl)->autoLearnHashTblPtrLow, (uint32_t)tmpReg64);
+    WRITE_UINT32( (*p_ReassTbl)->liodnAlAndAutoLearnHashTblPtrHi,
+                 (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32((*p_ReassTbl)->autoLearnHashTblPtrLow, (uint32_t)tmpReg64);
 
     /* Allocation of the Set Lock table - This table resides in external memory
-    The size of this table is (number of sets in the IP Reassembly Automatic Learning Hash table)*4 bytes.
-    This table resides in external memory and its base address should be 4-byte aligned */
-    *p_AutoLearnSetLockTblAddr = PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4));
+     The size of this table is (number of sets in the Reassembly Automatic Learning Hash table)*4 bytes.
+     This table resides in external memory and its base address should be 4-byte aligned */
+    *p_AutoLearnSetLockTblAddr =
+            PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->reassmParams.dataMemId, 4));
     if (!*p_AutoLearnSetLockTblAddr)
     {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
-        *p_IpReassTbl = NULL;
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_ReassTbl);
+        *p_ReassTbl = NULL;
         XX_FreeSmart(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
         *p_AutoLearnHashTblAddr = 0;
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
-    IOMemSet32(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr), 0,  (numOfSets * 4));
+    IOMemSet32(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr), 0, (numOfSets * 4));
 
     /* sets Set Lock table pointer and liodn offset*/
-    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    tmpReg64 = ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_LIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_ELIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_ELIODN_SHIFT);
     tmpReg64 |= XX_VirtToPhys(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr));
-    WRITE_UINT32((*p_IpReassTbl)->liodnSlAndAutoLearnSetLockTblPtrHi, (uint32_t)(tmpReg64 >> 32));
-    WRITE_UINT32((*p_IpReassTbl)->autoLearnSetLockTblPtrLow, (uint32_t)tmpReg64);
+    WRITE_UINT32( (*p_ReassTbl)->liodnSlAndAutoLearnSetLockTblPtrHi,
+                 (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32((*p_ReassTbl)->autoLearnSetLockTblPtrLow, (uint32_t)tmpReg64);
 
     /* Sets user's requested minimum fragment size (in Bytes) for First/Middle fragment */
-    WRITE_UINT16((*p_IpReassTbl)->minFragSize, minFragSize);
+    WRITE_UINT16((*p_ReassTbl)->minFragSize, minFragSize);
+
+    WRITE_UINT16((*p_ReassTbl)->maxReassemblySize, maxReassemSize);
 
     return E_OK;
 }
 
-static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
-                                 t_Handle       h_PcdParams,
-                                 t_Handle       h_FmPort,
-                                 t_FmPcdManip   *p_Manip,
-                                 t_Handle       h_Ad,
-                                 bool           validate)
+static t_Error UpdateInitReasm(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                               t_Handle h_FmPort, t_FmPcdManip *p_Manip,
+                               t_Handle h_Ad, bool validate)
 {
-    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
-    uint32_t                    tmpReg32;
-    t_Error                     err;
-    t_FmPortPcdParams           *p_PcdParams = (t_FmPortPcdParams *)h_PcdParams;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    uint32_t tmpReg32;
+    t_Error err;
+    t_FmPortPcdParams *p_PcdParams = (t_FmPortPcdParams *)h_PcdParams;
 #if (DPAA_VERSION >= 11)
-    t_FmPcdCtrlParamsPage       *p_ParamsPage;
+    t_FmPcdCtrlParamsPage *p_ParamsPage;
 #endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->frag, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_IP_REASSEMBLY), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(
+            (p_Manip->opcode == HMAN_OC_IP_REASSEMBLY) || (p_Manip->opcode == HMAN_OC_CAPWAP_REASSEMBLY),
+            E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Manip->updateParams || h_PcdParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->updateParams || h_PcdParams,
+                              E_INVALID_HANDLE);
 
     UNUSED(h_Ad);
 
@@ -1627,128 +2172,184 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
         return E_OK;
 
     if (p_Manip->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("handler of PCD previously was initiated by different value"));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("handler of PCD previously was initiated by different value"));
 
     if (p_Manip->updateParams)
     {
-        if ((!(p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))) ||
-            ((p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        if ((!(p_Manip->updateParams
+                & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK)))
+                || ((p_Manip->shadowUpdateParams
+                        & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
+            RETURN_ERROR(
+                    MAJOR, E_INVALID_STATE,
+                    ("in this stage parameters from Port has not be updated"));
 
         fmPortGetSetCcParams.setCcParams.type = 0;
+        if (p_Manip->opcode == HMAN_OC_CAPWAP_REASSEMBLY)
+        {
+            fmPortGetSetCcParams.setCcParams.type |= UPDATE_OFP_DPTE;
+            fmPortGetSetCcParams.setCcParams.ofpDpde = 0xF;
+        }
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams | FM_REV;
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK | FM_REV))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
-    }
-    else if (validate)
-    {
-        if ((!(p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))) ||
-            ((p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
-
-        fmPortGetSetCcParams.setCcParams.type = 0;
-        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
+        if (fmPortGetSetCcParams.getCcParams.type
+                & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK | FM_REV))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("offset of the data wasn't configured previously"));
     }
+    else
+        if (validate)
+        {
+            if ((!(p_Manip->shadowUpdateParams
+                    & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK)))
+                    || ((p_Manip->updateParams
+                            & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_STATE,
+                        ("in this stage parameters from Port has be updated"));
+
+            fmPortGetSetCcParams.setCcParams.type = 0;
+            fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                    != E_OK)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            if (fmPortGetSetCcParams.getCcParams.type
+                    & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_STATE,
+                        ("offset of the data wasn't configured previously"));
+        }
 
     if (p_Manip->updateParams)
     {
-        if (p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
+        if (p_Manip->updateParams
+                & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
         {
-            t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-            uint8_t     *p_Ptr, i, totalNumOfTnums;
+            t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+            uint8_t *p_Ptr, i, totalNumOfTnums;
 
-            totalNumOfTnums = (uint8_t)(fmPortGetSetCcParams.getCcParams.numOfTasks +
-                                        fmPortGetSetCcParams.getCcParams.numOfExtraTasks);
+            totalNumOfTnums =
+                    (uint8_t)(fmPortGetSetCcParams.getCcParams.numOfTasks
+                            + fmPortGetSetCcParams.getCcParams.numOfExtraTasks);
 
-            p_Manip->ipReassmParams.internalBufferPoolAddr =
+            p_Manip->reassmParams.internalBufferPoolAddr =
                     PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS),
-                                                  BMI_FIFO_UNITS));
-            if (!p_Manip->ipReassmParams.internalBufferPoolAddr)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly internal buffers pool"));
-            IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr),
-                       0,
-                       (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS));
-
-            p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr =
+                                    (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS),
+                                    BMI_FIFO_UNITS));
+            if (!p_Manip->reassmParams.internalBufferPoolAddr)
+                RETURN_ERROR(
+                        MAJOR, E_NO_MEMORY,
+                        ("MURAM alloc for Reassembly internal buffers pool"));
+            IOMemSet32(
+                    UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolAddr),
+                    0, (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS));
+
+            p_Manip->reassmParams.internalBufferPoolManagementIndexAddr =
                     PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  (uint32_t)(5 + totalNumOfTnums),
-                                                  4));
-            if (!p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly internal buffers management"));
-
-            p_Ptr = (uint8_t*)UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr);
-            WRITE_UINT32(*(uint32_t*)p_Ptr, (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr)) - p_FmPcd->physicalMuramBase));
-            for (i=0, p_Ptr += 4; i < totalNumOfTnums; i++, p_Ptr++)
+                                    (uint32_t)(5 + totalNumOfTnums),
+                                    4));
+            if (!p_Manip->reassmParams.internalBufferPoolManagementIndexAddr)
+                RETURN_ERROR(
+                        MAJOR,
+                        E_NO_MEMORY,
+                        ("MURAM alloc for Reassembly internal buffers management"));
+
+            p_Ptr =
+                    (uint8_t*)UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolManagementIndexAddr);
+            WRITE_UINT32(
+                    *(uint32_t*)p_Ptr,
+                    (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolAddr)) - p_FmPcd->physicalMuramBase));
+            for (i = 0, p_Ptr += 4; i < totalNumOfTnums; i++, p_Ptr++)
                 WRITE_UINT8(*p_Ptr, i);
             WRITE_UINT8(*p_Ptr, 0xFF);
 
-            tmpReg32 = (4 << FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_SHIFT) |
-                       ((uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)) - p_FmPcd->physicalMuramBase));
-            WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->internalBufferManagement, tmpReg32);
-
-            p_Manip->updateParams &= ~(NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK);
-            p_Manip->shadowUpdateParams |= (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK);
+            tmpReg32 =
+                    (4 << FM_PCD_MANIP_REASM_COMMON_INT_BUFFER_IDX_SHIFT)
+                            | ((uint32_t)(XX_VirtToPhys(
+                                    UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolManagementIndexAddr))
+                                    - p_FmPcd->physicalMuramBase));
+            WRITE_UINT32(
+                    p_Manip->reassmParams.p_ReassCommonTbl->internalBufferManagement,
+                    tmpReg32);
+
+            p_Manip->updateParams &= ~(NUM_OF_TASKS | NUM_OF_EXTRA_TASKS
+                    | DISCARD_MASK);
+            p_Manip->shadowUpdateParams |= (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS
+                    | DISCARD_MASK);
         }
     }
 
-    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
-    {
-        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv4Scheme;
-        p_PcdParams->p_KgParams->numOfSchemes++;
-    }
-    if (p_Manip->ipReassmParams.h_Ipv6Scheme)
+    if (p_Manip->opcode == HMAN_OC_CAPWAP_REASSEMBLY)
     {
-        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv6Scheme;
-        p_PcdParams->p_KgParams->numOfSchemes++;
-    }
+        if (p_Manip->reassmParams.capwap.h_Scheme)
+        {
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] =
+                    p_Manip->reassmParams.capwap.h_Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
+        }
 
-#if (DPAA_VERSION >= 11)
-    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev >= 6)
+    }
+    else
     {
-        if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage)) != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-
-        tmpReg32 = NIA_ENG_KG;
-        if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+        if (p_Manip->reassmParams.ip.h_Ipv4Scheme)
         {
-            tmpReg32 |= NIA_KG_DIRECT;
-            tmpReg32 |= NIA_KG_CC_EN;
-            tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv4Scheme);
-            WRITE_UINT32(p_ParamsPage->iprIpv4Nia, tmpReg32);
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] =
+                    p_Manip->reassmParams.ip.h_Ipv4Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
         }
-        if (p_Manip->ipReassmParams.h_Ipv6Scheme)
+        if (p_Manip->reassmParams.ip.h_Ipv6Scheme)
         {
-            tmpReg32 &= ~NIA_AC_MASK;
-            tmpReg32 |= NIA_KG_DIRECT;
-            tmpReg32 |= NIA_KG_CC_EN;
-            tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv6Scheme);
-            WRITE_UINT32(p_ParamsPage->iprIpv6Nia, tmpReg32);
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] =
+                    p_Manip->reassmParams.ip.h_Ipv6Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
+        }
+#if (DPAA_VERSION >= 11)
+        if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev >= 6)
+        {
+            if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                                        (void**)&p_ParamsPage)) != E_OK)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+
+            tmpReg32 = NIA_ENG_KG;
+            if (p_Manip->reassmParams.ip.h_Ipv4Scheme)
+            {
+                tmpReg32 |= NIA_KG_DIRECT;
+                tmpReg32 |= NIA_KG_CC_EN;
+                tmpReg32 |= FmPcdKgGetSchemeId(
+                        p_Manip->reassmParams.ip.h_Ipv4Scheme);
+                WRITE_UINT32(p_ParamsPage->iprIpv4Nia, tmpReg32);
+            }
+            if (p_Manip->reassmParams.ip.h_Ipv6Scheme)
+            {
+                tmpReg32 &= ~NIA_AC_MASK;
+                tmpReg32 |= NIA_KG_DIRECT;
+                tmpReg32 |= NIA_KG_CC_EN;
+                tmpReg32 |= FmPcdKgGetSchemeId(
+                        p_Manip->reassmParams.ip.h_Ipv6Scheme);
+                WRITE_UINT32(p_ParamsPage->iprIpv6Nia, tmpReg32);
+            }
         }
-    }
 #else
-    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev < 6)
-    {
-        WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->discardMask,
-                     fmPortGetSetCcParams.getCcParams.discardMask);
-    }
+        if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev < 6)
+        {
+            WRITE_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->discardMask,
+                    fmPortGetSetCcParams.getCcParams.discardMask);
+        }
 #endif /* (DPAA_VERSION >= 11) */
-
+    }
     return E_OK;
 }
 
 #if (DPAA_VERSION == 10)
 static t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
 {
-    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcFragScratchPoolCmdParams   fmPcdCcFragScratchPoolCmdParams;
-    t_Error                             err;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcFragScratchPoolCmdParams fmPcdCcFragScratchPoolCmdParams;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
@@ -1757,21 +2358,21 @@ static t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
     fmPcdCcFragScratchPoolCmdParams.numOfBuffers = NUM_OF_SCRATCH_POOL_BUFFERS;
     fmPcdCcFragScratchPoolCmdParams.bufferPoolId = scratchBpid;
     if ((err = FmHcPcdCcIpFragScratchPollCmd(p_FmPcd->h_Hc, TRUE, &fmPcdCcFragScratchPoolCmdParams)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    RETURN_ERROR(MAJOR, err, NO_MSG);
 
     if (fmPcdCcFragScratchPoolCmdParams.numOfBuffers != 0)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Fill scratch pool failed,"
-                                              "Failed to release %d buffers to the BM (missing FBPRs)",
-                                              fmPcdCcFragScratchPoolCmdParams.numOfBuffers));
+    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Fill scratch pool failed,"
+                    "Failed to release %d buffers to the BM (missing FBPRs)",
+                    fmPcdCcFragScratchPoolCmdParams.numOfBuffers));
 
     return E_OK;
 }
 
 static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid)
 {
-    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcFragScratchPoolCmdParams   fmPcdCcFragScratchPoolCmdParams;
-    t_Error                             err;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcFragScratchPoolCmdParams fmPcdCcFragScratchPoolCmdParams;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
@@ -1779,7 +2380,7 @@ static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid
 
     fmPcdCcFragScratchPoolCmdParams.bufferPoolId = scratchBpid;
     if ((err = FmHcPcdCcIpFragScratchPollCmd(p_FmPcd->h_Hc, FALSE, &fmPcdCcFragScratchPoolCmdParams)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -1800,134 +2401,163 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_Template);
         p_Manip->p_Template = NULL;
     }
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     if (p_Manip->h_Frag)
     {
-        if (p_Manip->fragParams.p_AutoLearnHashTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_AutoLearnHashTbl);
-        if (p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrPoolTbl);
-        if (p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl);
-        if (p_Manip->fragParams.p_TimeOutTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_TimeOutTbl);
+        if (p_Manip->capwapFragParams.p_AutoLearnHashTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                p_Manip->capwapFragParams.p_AutoLearnHashTbl);
+        if (p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl);
+        if (p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl);
+        if (p_Manip->capwapFragParams.p_TimeOutTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                p_Manip->capwapFragParams.p_TimeOutTbl);
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Frag);
 
     }
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     if (p_Manip->frag)
     {
-        if (p_Manip->ipFragParams.p_Frag)
+        if (p_Manip->fragParams.p_Frag)
         {
 #if (DPAA_VERSION == 10)
-            FmPcdFragHcScratchPoolEmpty((t_Handle)p_FmPcd, p_Manip->ipFragParams.scratchBpid);
+            FmPcdFragHcScratchPoolEmpty((t_Handle)p_FmPcd, p_Manip->fragParams.scratchBpid);
 #endif /* (DPAA_VERSION == 10) */
 
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_Frag);
         }
     }
-    else if (p_Manip->reassm)
-    {
-        FmPcdUnregisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
-
-        if (p_Manip->ipReassmParams.timeOutTblAddr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr));
-        if (p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr));
-
-        if (p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr));
-        if (p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr));
-        if (p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr));
-        if (p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr));
-        if (p_Manip->ipReassmParams.p_Ipv4ReassTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv4ReassTbl);
-        if (p_Manip->ipReassmParams.p_Ipv6ReassTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv6ReassTbl);
-        if (p_Manip->ipReassmParams.p_IpReassCommonTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_IpReassCommonTbl);
-        if (p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr));
-        if (p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr));
-        if (p_Manip->ipReassmParams.internalBufferPoolAddr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr));
-
-        if (p_Manip->ipReassmParams.h_Ipv6Ad)
-            XX_FreeSmart(p_Manip->ipReassmParams.h_Ipv6Ad);
-        if (p_Manip->ipReassmParams.h_Ipv4Ad)
-            XX_FreeSmart(p_Manip->ipReassmParams.h_Ipv4Ad);
-    }
+    else
+        if (p_Manip->reassm)
+        {
+            FmPcdUnregisterReassmPort(p_FmPcd,
+                                      p_Manip->reassmParams.p_ReassCommonTbl);
+
+            if (p_Manip->reassmParams.timeOutTblAddr)
+                FM_MURAM_FreeMem(
+                        p_FmPcd->h_FmMuram,
+                        UINT_TO_PTR(p_Manip->reassmParams.timeOutTblAddr));
+            if (p_Manip->reassmParams.reassFrmDescrPoolTblAddr)
+                XX_FreeSmart(
+                        UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrPoolTblAddr));
+            if (p_Manip->reassmParams.p_ReassCommonTbl)
+                FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                                 p_Manip->reassmParams.p_ReassCommonTbl);
+            if (p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr)
+                FM_MURAM_FreeMem(
+                        p_FmPcd->h_FmMuram,
+                        UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr));
+            if (p_Manip->reassmParams.internalBufferPoolManagementIndexAddr)
+                FM_MURAM_FreeMem(
+                        p_FmPcd->h_FmMuram,
+                        UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolManagementIndexAddr));
+            if (p_Manip->reassmParams.internalBufferPoolAddr)
+                FM_MURAM_FreeMem(
+                        p_FmPcd->h_FmMuram,
+                        UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolAddr));
+            if (p_Manip->reassmParams.hdr == HEADER_TYPE_CAPWAP)
+            {
+
+            }
+            else
+            {
+                if (p_Manip->reassmParams.ip.ipv4AutoLearnHashTblAddr)
+                    XX_FreeSmart(
+                            UINT_TO_PTR(p_Manip->reassmParams.ip.ipv4AutoLearnHashTblAddr));
+                if (p_Manip->reassmParams.ip.ipv6AutoLearnHashTblAddr)
+                    XX_FreeSmart(
+                            UINT_TO_PTR(p_Manip->reassmParams.ip.ipv6AutoLearnHashTblAddr));
+                if (p_Manip->reassmParams.ip.ipv4AutoLearnSetLockTblAddr)
+                    XX_FreeSmart(
+                            UINT_TO_PTR(p_Manip->reassmParams.ip.ipv4AutoLearnSetLockTblAddr));
+                if (p_Manip->reassmParams.ip.ipv6AutoLearnSetLockTblAddr)
+                    XX_FreeSmart(
+                            UINT_TO_PTR(p_Manip->reassmParams.ip.ipv6AutoLearnSetLockTblAddr));
+                if (p_Manip->reassmParams.ip.p_Ipv4ReassTbl)
+                    FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                                     p_Manip->reassmParams.ip.p_Ipv4ReassTbl);
+                if (p_Manip->reassmParams.ip.p_Ipv6ReassTbl)
+                    FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                                     p_Manip->reassmParams.ip.p_Ipv6ReassTbl);
+                if (p_Manip->reassmParams.ip.h_Ipv6Ad)
+                    XX_FreeSmart(p_Manip->reassmParams.ip.h_Ipv6Ad);
+                if (p_Manip->reassmParams.ip.h_Ipv4Ad)
+                    XX_FreeSmart(p_Manip->reassmParams.ip.h_Ipv4Ad);
+            }
+        }
 
     if (p_Manip->p_StatsTbl)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_StatsTbl);
 }
 
-#ifdef FM_CAPWAP_SUPPORT
-static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_ManipParams)
 {
     if (p_ManipParams->u.hdr.rmv)
     {
         switch (p_ManipParams->u.hdr.rmvParams.type)
         {
             case (e_FM_PCD_MANIP_RMV_BY_HDR):
-                switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+            {
+                case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
+                if (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
                 {
-                    case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
-                        if (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
-                        {
-                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
-                            {
-                                case (HEADER_TYPE_CAPWAP_DTLS) :
-                                    p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
-                                    p_Manip->muramAllocate = TRUE;
-                                    if (p_ManipParams->u.hdr.insrt)
-                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
-                                    if (p_ManipParams->fragOrReasm)
-                                    {
-                                        if (!p_ManipParams->fragOrReasmParams.frag)
-                                        {
-                                            switch (p_ManipParams->fragOrReasmParams.hdr)
-                                            {
-                                                case (HEADER_TYPE_CAPWAP):
-                                                    p_Manip->opcode = HMAN_OC_CAPWAP_REASSEMBLY;
-                                                    break;
-                                                default:
-                                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
-                                            }
-                                        }
-                                        else
-                                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for this type of manipulation frag can not be TRUE"));
-                                    }
-                                break;
-                                default:
-                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid net header of remove location"));
-                            }
-                        }
-                        else
+                    switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                    {
+                        case (HEADER_TYPE_CAPWAP_DTLS) :
+                        p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+                        p_Manip->muramAllocate = TRUE;
+                        if (p_ManipParams->u.hdr.insrt)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
+                        if (p_ManipParams->fragOrReasm)
                         {
-                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            if (!p_ManipParams->fragOrReasmParams.frag)
                             {
-                                case (HEADER_TYPE_CAPWAP_DTLS) :
-                                case (HEADER_TYPE_CAPWAP) :
-                                    if  (p_ManipParams->fragOrReasm || p_ManipParams->u.hdr.insrt)
-                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"));
-                                    p_Manip->opcode = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
-                                    p_Manip->muramAllocate = TRUE;
-                                    p_ManipParams->u.hdr.insrt = TRUE; //internal frame header
+                                switch (p_ManipParams->fragOrReasmParams.hdr)
+                                {
+                                    case (HEADER_TYPE_CAPWAP):
+                                    p_Manip->opcode = HMAN_OC_CAPWAP_REASSEMBLY;
                                     break;
-                                default :
-                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+                                    default:
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
+                                }
                             }
+                            else
+                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for this type of manipulation frag can not be TRUE"));
                         }
                         break;
-                    default :
-                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
-               }
-               break;
-           default:
+                        default:
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid net header of remove location"));
+                    }
+                }
+                else
+                {
+                    switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                    {
+                        case (HEADER_TYPE_CAPWAP_DTLS) :
+                        case (HEADER_TYPE_CAPWAP) :
+                        if (p_ManipParams->fragOrReasm || p_ManipParams->u.hdr.insrt)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"));
+                        p_Manip->opcode = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                        p_Manip->muramAllocate = TRUE;
+                        p_ManipParams->u.hdr.insrt = TRUE; //internal frame header
+                        break;
+                        default :
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+                    }
+                }
+                break;
+                default :
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+            }
+            break;
+            default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
         }
     }
     else if (p_ManipParams->u.hdr.insrt)
@@ -1936,28 +2566,28 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
         {
             case (e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
 
-                p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
-                p_Manip->muramAllocate = FALSE;
-                if (p_ManipParams->fragOrReasm)
+            p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+            p_Manip->muramAllocate = FALSE;
+            if (p_ManipParams->fragOrReasm)
+            {
+                if (p_ManipParams->fragOrReasmParams.frag)
                 {
-                    if (p_ManipParams->fragOrReasmParams.frag)
+                    switch (p_ManipParams->fragOrReasmParams.hdr)
                     {
-                           switch (p_ManipParams->fragOrReasmParams.hdr)
-                           {
-                                case (HEADER_TYPE_CAPWAP):
-                                    p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
-                                    break;
-                                default:
-                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header for fragmentation"));
-                           }
+                        case (HEADER_TYPE_CAPWAP):
+                        p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
+                        break;
+                        default:
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header for fragmentation"));
                     }
-                    else
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE,("can not reach this point"));
                 }
-                break;
+                else
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,("can not reach this point"));
+            }
+            break;
 
             default:
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
         }
     }
     else if (p_ManipParams->fragOrReasm)
@@ -1967,47 +2597,54 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
             switch (p_ManipParams->fragOrReasmParams.hdr)
             {
                 case (HEADER_TYPE_CAPWAP):
-                    p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
-                    p_Manip->muramAllocate = FALSE;
-                    break;
+                p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
+                p_Manip->muramAllocate = FALSE;
+                break;
                 default:
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for fragmentation"));
-             }
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for fragmentation"));
+            }
         }
         else
         {
             switch (p_ManipParams->fragOrReasmParams.hdr)
             {
                 case (HEADER_TYPE_CAPWAP):
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
                 default:
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
             }
         }
 
     }
     else
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("User didn't ask for any manipulation"));
+    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("User didn't ask for any manipulation"));
 
     p_Manip->insrt = p_ManipParams->u.hdr.insrt;
-    p_Manip->rmv   = p_ManipParams->u.hdr.rmv;
+    p_Manip->rmv = p_ManipParams->u.hdr.rmv;
 
     return E_OK;
 }
 
-#else /* not FM_CAPWAP_SUPPORT */
-static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_ManipParams)
+#else /* not (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip,
+                                          t_FmPcdManipParams *p_ManipParams)
 {
     switch (p_ManipParams->type)
     {
-        case e_FM_PCD_MANIP_HDR :
+        case e_FM_PCD_MANIP_HDR:
             /* Check that next-manip is not already used */
             if (p_ManipParams->h_NextManip)
             {
                 if (!MANIP_IS_FIRST(p_ManipParams->h_NextManip))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_NextManip is already a part of another chain"));
-                if (MANIP_GET_TYPE(p_ManipParams->h_NextManip) != e_FM_PCD_MANIP_HDR)
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("For a Header Manipulation node - no support of h_NextManip of type other than Header Manipulation."));
+                    RETURN_ERROR(
+                            MAJOR, E_INVALID_STATE,
+                            ("h_NextManip is already a part of another chain"));
+                if (MANIP_GET_TYPE(p_ManipParams->h_NextManip)
+                        != e_FM_PCD_MANIP_HDR)
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_NOT_SUPPORTED,
+                            ("For a Header Manipulation node - no support of h_NextManip of type other than Header Manipulation."));
             }
 
             if (p_ManipParams->u.hdr.rmv)
@@ -2017,136 +2654,240 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                     case (e_FM_PCD_MANIP_RMV_BY_HDR):
                         switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
                         {
-                            case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2) :
-                                p_Manip->opcode = HMAN_OC;
-                                p_Manip->muramAllocate = TRUE;
+                            case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2):
                                 break;
-                            default :
-                                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+#if (DPAA_VERSION >= 11)
+                            case (e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP):
+                                break;
+                            case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START):
+                            {
+                                t_Error err;
+                                uint8_t prsArrayOffset;
+
+                                err =
+                                        GetPrOffsetByHeaderOrField(
+                                                &p_ManipParams->u.hdr.rmvParams.u.byHdr.u.hdrInfo,
+                                                &prsArrayOffset);
+                                if (err)
+                                    RETURN_ERROR(MAJOR, err, NO_MSG);
+                                break;
+                            }
+#endif /* (DPAA_VERSION >= 11) */
+                            default:
+                                RETURN_ERROR(
+                                        MAJOR,
+                                        E_INVALID_STATE,
+                                        ("invalid type of remove manipulation"));
                         }
                         break;
-                   case (e_FM_PCD_MANIP_RMV_GENERIC):
-                       p_Manip->opcode = HMAN_OC;
-                       p_Manip->muramAllocate = TRUE;
-                       break;
-                   default:
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
-                }
-                p_Manip->rmv = TRUE;
-            }
-            else if (p_ManipParams->u.hdr.insrt)
-            {
-                switch (p_ManipParams->u.hdr.insrtParams.type)
-                {
-                    case (e_FM_PCD_MANIP_INSRT_BY_HDR) :
-                    case (e_FM_PCD_MANIP_INSRT_GENERIC):
-                        p_Manip->opcode = HMAN_OC;
-                        p_Manip->muramAllocate = TRUE;
+                    case (e_FM_PCD_MANIP_RMV_GENERIC):
                         break;
                     default:
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                     ("invalid type of remove manipulation"));
                 }
-                p_Manip->insrt = TRUE;
+                p_Manip->opcode = HMAN_OC;
+                p_Manip->muramAllocate = TRUE;
+                p_Manip->rmv = TRUE;
             }
-            else if (p_ManipParams->u.hdr.fieldUpdate)
-            {
-                /* Check parameters */
-                if (p_ManipParams->u.hdr.fieldUpdateParams.type == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN)
+            else
+                if (p_ManipParams->u.hdr.insrt)
                 {
-                    if ((p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
-                        && (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri > 7))
-                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpri should get values of 0-7 "));
-                    if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                    switch (p_ManipParams->u.hdr.insrtParams.type)
                     {
-                        int i;
-
-                        if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal > 7)
-                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpriDefVal should get values of 0-7 "));
-                        for (i = 0 ; i < FM_PCD_MANIP_DSCP_TO_VLAN_TRANS ; i++)
-                            if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i] & 0xf0)
-                                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dscpToVpriTabl value out of range (0-15)"));
+                        case (e_FM_PCD_MANIP_INSRT_BY_HDR):
+                        {
+                            switch (p_ManipParams->u.hdr.insrtParams.u.byHdr.type)
+                            {
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2):
+                                    /* nothing to check */
+                                    break;
+#if (DPAA_VERSION >= 11)
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_IP):
+                                    if (p_ManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size
+                                            % 4)
+                                        RETURN_ERROR(
+                                                MAJOR,
+                                                E_INVALID_VALUE,
+                                                ("IP inserted header must be of size which is a multiple of four bytes"));
+                                    break;
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP):
+                                    if (p_ManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size
+                                            % 4)
+                                        RETURN_ERROR(
+                                                MAJOR,
+                                                E_INVALID_VALUE,
+                                                ("CAPWAP inserted header must be of size which is a multiple of four bytes"));
+                                    break;
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP):
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE):
+                                    if (p_ManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size
+                                            != 8)
+                                        RETURN_ERROR(
+                                                MAJOR,
+                                                E_INVALID_VALUE,
+                                                ("Inserted header must be of size 8"));
+                                    break;
+#endif /* (DPAA_VERSION >= 11) */
+                                default:
+                                    RETURN_ERROR(
+                                            MAJOR,
+                                            E_INVALID_STATE,
+                                            ("unsupported insert by header type"));
+                            }
+                        }
+                        case (e_FM_PCD_MANIP_INSRT_GENERIC):
+                            break;
+                        default:
+                            RETURN_ERROR(
+                                    MAJOR,
+                                    E_INVALID_STATE,
+                                    ("for only insert manipulation unsupported type"));
                     }
-
+                    p_Manip->opcode = HMAN_OC;
+                    p_Manip->muramAllocate = TRUE;
+                    p_Manip->insrt = TRUE;
                 }
+                else
+                    if (p_ManipParams->u.hdr.fieldUpdate)
+                    {
+                        /* Check parameters */
+                        if (p_ManipParams->u.hdr.fieldUpdateParams.type
+                                == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN)
+                        {
+                            if ((p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                                    == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
+                                    && (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri
+                                            > 7))
+                                RETURN_ERROR(
+                                        MAJOR, E_INVALID_VALUE,
+                                        ("vpri should get values of 0-7 "));
+                            if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                                    == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                            {
+                                int i;
+
+                                if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal
+                                        > 7)
+                                    RETURN_ERROR(
+                                            MAJOR,
+                                            E_INVALID_VALUE,
+                                            ("vpriDefVal should get values of 0-7 "));
+                                for (i = 0; i < FM_PCD_MANIP_DSCP_TO_VLAN_TRANS;
+                                        i++)
+                                    if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i]
+                                            & 0xf0)
+                                        RETURN_ERROR(
+                                                MAJOR,
+                                                E_INVALID_VALUE,
+                                                ("dscpToVpriTabl value out of range (0-15)"));
+                            }
 
-                p_Manip->opcode = HMAN_OC;
-                p_Manip->muramAllocate = TRUE;
-                p_Manip->fieldUpdate = TRUE;
-            }
-            else if (p_ManipParams->u.hdr.custom)
-            {
-                p_Manip->opcode = HMAN_OC;
-                p_Manip->muramAllocate = TRUE;
-                p_Manip->custom = TRUE;
-            }
+                        }
+
+                        p_Manip->opcode = HMAN_OC;
+                        p_Manip->muramAllocate = TRUE;
+                        p_Manip->fieldUpdate = TRUE;
+                    }
+                    else
+                        if (p_ManipParams->u.hdr.custom)
+                        {
+                            p_Manip->opcode = HMAN_OC;
+                            p_Manip->muramAllocate = TRUE;
+                            p_Manip->custom = TRUE;
+                        }
             break;
-        case e_FM_PCD_MANIP_REASSEM :
+        case e_FM_PCD_MANIP_REASSEM:
             if (p_ManipParams->h_NextManip)
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with reassembly"));
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                             ("next manip with reassembly"));
             switch (p_ManipParams->u.reassem.hdr)
             {
                 case (HEADER_TYPE_IPv4):
-                    p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv4;
+                    p_Manip->reassmParams.hdr = HEADER_TYPE_IPv4;
+                    p_Manip->opcode = HMAN_OC_IP_REASSEMBLY;
                     break;
                 case (HEADER_TYPE_IPv6):
-                    p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv6;
+                    p_Manip->reassmParams.hdr = HEADER_TYPE_IPv6;
+                    p_Manip->opcode = HMAN_OC_IP_REASSEMBLY;
+                    break;
+#if (DPAA_VERSION >= 11)
+                case (HEADER_TYPE_CAPWAP):
+                    p_Manip->reassmParams.hdr = HEADER_TYPE_CAPWAP;
+                    p_Manip->opcode = HMAN_OC_CAPWAP_REASSEMBLY;
                     break;
+#endif /* (DPAA_VERSION >= 11) */
                 default:
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for reassembly"));
-             }
-            p_Manip->opcode = HMAN_OC_IP_REASSEMBLY;
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                                 ("header for reassembly"));
+            }
             break;
-        case e_FM_PCD_MANIP_FRAG :
+        case e_FM_PCD_MANIP_FRAG:
             if (p_ManipParams->h_NextManip)
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with fragmentation"));
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                             ("next manip with fragmentation"));
             switch (p_ManipParams->u.frag.hdr)
             {
                 case (HEADER_TYPE_IPv4):
                 case (HEADER_TYPE_IPv6):
+                    p_Manip->opcode = HMAN_OC_IP_FRAGMENTATION;
+                    break;
+#if (DPAA_VERSION >= 11)
+                case (HEADER_TYPE_CAPWAP):
+                    p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
                     break;
+#endif /* (DPAA_VERSION >= 11) */
                 default:
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for fragmentation"));
-             }
-            p_Manip->opcode = HMAN_OC_IP_FRAGMENTATION;
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                                 ("header for fragmentation"));
+            }
             p_Manip->muramAllocate = TRUE;
             break;
-        case e_FM_PCD_MANIP_SPECIAL_OFFLOAD :
+        case e_FM_PCD_MANIP_SPECIAL_OFFLOAD:
             switch (p_ManipParams->u.specialOffload.type)
             {
                 case (e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC):
                     p_Manip->opcode = HMAN_OC_IPSEC_MANIP;
                     p_Manip->muramAllocate = TRUE;
                     break;
+#if (DPAA_VERSION >= 11)
+                case (e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP):
+                    p_Manip->opcode = HMAN_OC_CAPWAP_MANIP;
+                    p_Manip->muramAllocate = TRUE;
+                    break;
+#endif /* (DPAA_VERSION >= 11) */
                 default:
-                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("special offload type"));
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                                 ("special offload type"));
             }
             break;
-        default :
+        default:
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("manip type"));
     }
 
     return E_OK;
 }
-#endif /* not FM_CAPWAP_SUPPORT */
+#endif /* not (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
-#ifdef FM_CAPWAP_SUPPORT
-static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
-                               t_Handle     h_FmPort,
-                               t_FmPcdManip *p_Manip)
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+
+static t_Error UpdateIndxStats(t_Handle h_FmPcd,
+        t_Handle h_FmPort,
+        t_FmPcdManip *p_Manip)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t                tmpReg32 = 0;
-    t_AdOfTypeContLookup    *p_Ad;
-    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
-    t_Error                 err;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t tmpReg32 = 0;
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
-    p_Ad    = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
     if (p_Manip->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                     ("handler of PCD previously was initiated by different value"));
+    RETURN_ERROR(MAJOR, E_INVALID_STATE,
+            ("handler of PCD previously was initiated by different value"));
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
@@ -2157,25 +2898,25 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 = GET_UINT32(p_Ad->ccAdBase);
 
         p_Manip->p_StatsTbl =
-            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                        (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
-                                        4);
+        (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
+                4);
         if (!p_Manip->p_StatsTbl)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation indexed statistics table"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation indexed statistics table"));
 
-        IOMemSet32(p_Manip->p_StatsTbl, 0,  (uint32_t)(p_Manip->owner * 4));
+        IOMemSet32(p_Manip->p_StatsTbl, 0, (uint32_t)(p_Manip->owner * 4));
 
         tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->p_StatsTbl) - p_FmPcd->physicalMuramBase);
 
         if (p_Manip->cnia)
-            tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_CNIA;
+        tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_CNIA;
 
-        tmpReg32 |=  FM_PCD_MANIP_INDEXED_STATS_DPD;
+        tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_DPD;
         WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
     }
     else
@@ -2184,133 +2925,36 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     return E_OK;
 }
 
-static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *parseArrayOffset)
+static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams *p_ManipParams, t_FmPcdManip *p_Manip)
 {
-    e_NetHeaderType hdr         = p_HdrInfo->hdr;
-    e_FmPcdHdrIndex hdrIndex    = p_HdrInfo->hdrIndex;
-    bool            byField     = p_HdrInfo->byField;
-    t_FmPcdFields   field;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t tmpReg32 = 0;
+    uint8_t prsArrayOffset = 0;
+    t_Error err;
 
-    if (byField)
-        field = p_HdrInfo->fullField;
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
-    if (byField)
-    {
-        switch (hdr)
-        {
-            case (HEADER_TYPE_ETH):
-                switch (field.eth)
-                {
-                    case (NET_HEADER_FIELD_ETH_TYPE):
-                        *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
-                        break;
-                    default:
-                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type Ethernet with this field not supported"));
-                }
-                break;
-            case (HEADER_TYPE_VLAN):
-                switch (field.vlan)
-                {
-                    case (NET_HEADER_FIELD_VLAN_TCI) :
-                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                            *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
-                        else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                             *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
-                        break;
-                    default:
-                       RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type VLAN with this field not supported"));
-                }
-                break;
-           default:
-               RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header by field not supported"));
-        }
-    }
-    else
-    {
-        switch (hdr){
-             case (HEADER_TYPE_ETH):
-                 *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
-                break;
-            case (HEADER_TYPE_USER_DEFINED_SHIM1):
-                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
-                break;
-            case (HEADER_TYPE_USER_DEFINED_SHIM2):
-                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
-                break;
-            case (HEADER_TYPE_LLC_SNAP):
-                *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
-                break;
-            case (HEADER_TYPE_PPPoE):
-                *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
-                break;
-            case (HEADER_TYPE_MPLS):
-                 if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                        *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
-                else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
-                break;
-            case (HEADER_TYPE_IPv4):
-            case (HEADER_TYPE_IPv6):
-              if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
-              else if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
-                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
-                break;
-            case (HEADER_TYPE_MINENCAP):
-                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
-                break;
-            case (HEADER_TYPE_GRE):
-                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
-                break;
-            case (HEADER_TYPE_TCP):
-            case (HEADER_TYPE_UDP):
-            case (HEADER_TYPE_IPSEC_AH):
-            case (HEADER_TYPE_IPSEC_ESP):
-            case (HEADER_TYPE_DCCP):
-            case (HEADER_TYPE_SCTP):
-                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
-                break;
-            case (HEADER_TYPE_CAPWAP):
-            case (HEADER_TYPE_CAPWAP_DTLS):
-                *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
-                break;
-            default:
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header is not supported"));
-     }
-    }
-    return E_OK;
-}
-
-static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_ManipParams, t_FmPcdManip *p_Manip)
-{
-    t_AdOfTypeContLookup    *p_Ad;
-    uint32_t                tmpReg32 = 0;
-    uint8_t                 prsArrayOffset = 0;
-    t_Error                 err;
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-
-    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if (p_Manip->rmv)
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if (p_Manip->rmv)
     {
         err = GetPrOffsetByHeaderOrField(&p_ManipParams->u.byHdr.u.fromStartByHdr.hdrInfo, &prsArrayOffset);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 |= (uint32_t)prsArrayOffset << 24;
         tmpReg32 |= HMAN_RMV_HDR;
     }
 
     if (p_Manip->insrt)
-        tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
+    tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
 
     tmpReg32 |= (uint32_t)HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
 
@@ -2322,14 +2966,14 @@ static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_M
 
     return E_OK;
 }
-#endif /* FM_CAPWAP_SUPPORT */
 
-static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip, bool caamUsed)
+static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip,
+        bool caamUsed)
 {
-    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    uint32_t                tmpReg32 = 0;
+    t_AdOfTypeContLookup *p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    uint32_t tmpReg32 = 0;
 
-    SANITY_CHECK_RETURN_ERROR(p_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Ad, E_INVALID_HANDLE);
 
     p_Manip->updateParams |= OFFSET_OF_PR | INTERNAL_CONTEXT_OFFSET;
 
@@ -2343,21 +2987,20 @@ static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip, bo
     *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
 
     if (caamUsed)
-        *(uint32_t *)&p_Ad->gmask = 0xf0000000;
+    *(uint32_t *)&p_Ad->gmask = 0xf0000000;
 
     return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
 static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
 {
-    t_AdOfTypeContLookup    *p_Ad;
-    uint32_t                tmpReg32 = 0;
-    t_Error                 err = E_OK;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t tmpReg32 = 0;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
-    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
@@ -2378,81 +3021,80 @@ static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
     return err;
 }
 
-static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
-                                t_FmPcdManip                *p_Manip,
-                                t_FmPcd                     *p_FmPcd,
-                                uint8_t                     poolId)
+static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
+        t_FmPcdManip *p_Manip,
+        t_FmPcd *p_FmPcd,
+        uint8_t poolId)
 {
-    t_Handle    p_Table;
-    uint32_t    tmpReg32 = 0;
-    int         i = 0;
-    uint8_t     log2Num;
-    uint8_t     numOfSets;
-    uint32_t    j = 0;
+    t_Handle p_Table;
+    uint32_t tmpReg32 = 0;
+    int i = 0;
+    uint8_t log2Num;
+    uint8_t numOfSets;
+    uint32_t j = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
     if (!p_FmPcd->h_Hc)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("hc port has to be initialized in this mode"));
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE,("hc port has to be initialized in this mode"));
     if (!POWER_OF_2(p_ManipParams->timeoutRoutineRequestTime))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeoutRoutineRequestTime has to be power of 2"));
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeoutRoutineRequestTime has to be power of 2"));
     if (!POWER_OF_2(p_ManipParams->maxNumFramesInProcess))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("maxNumFramesInProcess has to be power of 2"));
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE,("maxNumFramesInProcess has to be power of 2"));
     if (!p_ManipParams->timeoutRoutineRequestTime && p_ManipParams->timeoutThresholdForReassmProcess)
-        DBG(WARNING, ("if timeoutRoutineRequestTime 0,  timeoutThresholdForReassmProcess is uselessly"));
+    DBG(WARNING, ("if timeoutRoutineRequestTime 0,  timeoutThresholdForReassmProcess is uselessly"));
     if (p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH)
     {
         if ((p_ManipParams->maxNumFramesInProcess < 4) ||
-            (p_ManipParams->maxNumFramesInProcess > 512))
-            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"));
+                (p_ManipParams->maxNumFramesInProcess > 512))
+        RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"));
     }
     else
     {
         if ((p_ManipParams->maxNumFramesInProcess < 8) ||
-            (p_ManipParams->maxNumFramesInProcess > 2048))
-            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"));
+                (p_ManipParams->maxNumFramesInProcess > 2048))
+        RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"));
     }
 
     p_Manip->updateParams |= (NUM_OF_TASKS | OFFSET_OF_PR | OFFSET_OF_DATA | HW_PORT_ID);
 
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
-                                                  FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+            FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
+            FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
     if (!p_Manip->h_Frag)
-         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc CAPWAP reassembly parameters table"));
+    RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc CAPWAP reassembly parameters table"));
 
-    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
+    IOMemSet32(p_Manip->h_Frag, 0, FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
 
     p_Table = (t_CapwapReasmPram *)p_Manip->h_Frag;
 
-    p_Manip->fragParams.p_AutoLearnHashTbl =
-        (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                    (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE),
-                                    FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
-
-    if (!p_Manip->fragParams.p_AutoLearnHashTbl)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
+    p_Manip->capwapFragParams.p_AutoLearnHashTbl =
+    (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+            (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE),
+            FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
 
-    IOMemSet32(p_Manip->fragParams.p_AutoLearnHashTbl, 0,  (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
+    if (!p_Manip->capwapFragParams.p_AutoLearnHashTbl)
+    RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
 
+    IOMemSet32(p_Manip->capwapFragParams.p_AutoLearnHashTbl, 0, (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
 
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_AutoLearnHashTbl) - p_FmPcd->physicalMuramBase);
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_AutoLearnHashTbl) - p_FmPcd->physicalMuramBase);
 
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->autoLearnHashTblPtr, tmpReg32);
 
     tmpReg32 = 0;
     if (p_ManipParams->timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
-        tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES;
+    tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES;
     if (p_ManipParams->haltOnDuplicationFrag)
-        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
+    tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
     if (p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH)
     {
         i = 8;
-        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS;
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS;
     }
     else
-        i = 4;
+    i = 4;
 
     numOfSets = (uint8_t)((p_ManipParams->maxNumFramesInProcess * 2) / i);
     LOG2(numOfSets, log2Num);
@@ -2461,8 +3103,8 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
 
     for (j=0; j<p_ManipParams->maxNumFramesInProcess*2; j++)
-        if (((j / i)  % 2)== 0)
-            WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->fragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
+    if (((j / i) % 2)== 0)
+    WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->capwapFragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
 
     tmpReg32 = 0x00008000;
     tmpReg32 |= (uint32_t)poolId << 16;
@@ -2470,28 +3112,28 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc23SetIndexes, 0x80008000);
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc4SetIndexesAndExtendedStatsTblPtr, 0x80000000);
 
-    p_Manip->fragParams.maxNumFramesInProcess = p_ManipParams->maxNumFramesInProcess;
+    p_Manip->capwapFragParams.maxNumFramesInProcess = p_ManipParams->maxNumFramesInProcess;
 
-    p_Manip->fragParams.sgBpid =  poolId;
+    p_Manip->capwapFragParams.sgBpid = poolId;
 
-    p_Manip->fragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
-    p_Manip->fragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
-    p_Manip->fragParams.bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    p_Manip->capwapFragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
+    p_Manip->capwapFragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
+    p_Manip->capwapFragParams.bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
 
     tmpReg32 = 0;
-    tmpReg32 |= (((uint32_t)1<<p_Manip->fragParams.bitFor1Micro) * p_ManipParams->timeoutThresholdForReassmProcess);
+    tmpReg32 |= (((uint32_t)1<<p_Manip->capwapFragParams.bitFor1Micro) * p_ManipParams->timeoutThresholdForReassmProcess);
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->expirationDelay, tmpReg32);
 
     return E_OK;
 }
 
-static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
-                                   t_FmPcdManip                 *p_Manip,
-                                   t_FmPcd                      *p_FmPcd,
-                                   uint8_t                      poolId)
+static t_Error CapwapFragmentation(t_CapwapFragmentationParams *p_ManipParams,
+        t_FmPcdManip *p_Manip,
+        t_FmPcd *p_FmPcd,
+        uint8_t poolId)
 {
-    t_AdOfTypeContLookup    *p_Ad;
-    uint32_t                tmpReg32 = 0;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t tmpReg32 = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
@@ -2500,12 +3142,12 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     p_Manip->frag = TRUE;
 
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  FM_PCD_CC_AD_ENTRY_SIZE,
-                                                  FM_PCD_CC_AD_TABLE_ALIGN);
+            FM_PCD_CC_AD_ENTRY_SIZE,
+            FM_PCD_CC_AD_TABLE_ALIGN);
     if (!p_Manip->h_Frag)
-         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP fragmentation table descriptor"));
+    RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP fragmentation table descriptor"));
 
-    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    IOMemSet32(p_Manip->h_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
@@ -2513,7 +3155,7 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
 
     if (p_ManipParams->headerOptionsCompr)
-        tmpReg32 |= FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
+    tmpReg32 |= FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
     tmpReg32 |= ((uint32_t)poolId << 8);
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
@@ -2522,39 +3164,292 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
     p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
-    p_Manip->fragParams.sgBpid = poolId;
+    p_Manip->capwapFragParams.sgBpid = poolId;
+
+    return E_OK;
+}
+
+static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd)
+{
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    UNUSED(p_FmPcd);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_INDEXED_STATS;
+    if (p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
+    tmpReg32 |= (uint32_t)0x16 << 16;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return E_OK;
+}
+
+static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    t_FmPcdManipHdrInsrtByTemplateParams *p_InsrtByTemplate = &p_ManipParams->u.byTemplate;
+    uint8_t tmpReg8 = 0xff;
+    t_AdOfTypeContLookup *p_Ad;
+    bool ipModify = FALSE;
+    uint32_t tmpReg32 = 0, tmpRegNia = 0;
+    uint16_t tmpReg16 = 0;
+    t_Error err = E_OK;
+    uint8_t extraAddedBytes = 0, blockSize = 0, extraAddedBytesAlignedToBlockSize = 0, log2Num = 0;
+    uint8_t *p_Template = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_NULL_POINTER);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if (p_Manip->insrt)
+    {
+        if ((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
+                (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
+
+        if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
+
+        if (p_InsrtByTemplate->size > 128)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
+
+        if (p_InsrtByTemplate->size)
+        {
+            p_Manip->p_Template = (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                    p_InsrtByTemplate->size,
+                    FM_PCD_CC_AD_TABLE_ALIGN);
+            if(!p_Manip->p_Template)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
+            tmpReg32 |= (uint32_t)p_InsrtByTemplate->size << 24;
+            *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;
+        }
+
+        tmpReg32 = 0;
+
+        p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
+
+        if (!p_Template)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+
+        memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
+
+        if (p_InsrtByTemplate->modifyOuterIp)
+        {
+            ipModify = TRUE;
+
+            tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
+
+            if((tmpReg8 & 0xf0) == 0x40)
+            tmpReg8 = 4;
+            else if((tmpReg8 & 0xf0) == 0x60)
+            tmpReg8 = 6;
+            else
+            tmpReg8 = 0xff;
+
+            if (tmpReg8 != 0xff)
+            {
+                if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
+                if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
+                {
+
+                    if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
+                    extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
+                    blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
+                    extraAddedBytesAlignedToBlockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize;
+                    /*IP header template - IP totalLength -
+                     (1 byte) extraByteForIp = headerTemplateSize - ipOffset + insertedBytesAfterThisStage ,
+                     in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
+                     second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
+                }
+                if (blockSize)
+                {
+                    if (!POWER_OF_2(blockSize))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
+                }
+
+            }
+            if (tmpReg8 == 4)
+            {
+                if ((IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
+
+                if (blockSize)
+                blockSize -= 1;
+
+                if ((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize; // IPV6 - in AD instead of SEQ IND
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes);// for IPV6 decrement additional 40 bytes of IPV6 heade size
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP] = 0x00;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
+
+                /*IP header template - relevant only for ipv4 CheckSum = 0*/
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP] = 0x00;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + 1] = 0x00;
+
+                /*UDP checksum has to be 0*/
+                if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                {
+                    if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+
+                }
+
+                if (p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
+
+                tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
+            }
+            else if (tmpReg8 == 6)
+            {
+                /*TODO - add check for maximum value of blockSize;*/
+                if (blockSize)
+                LOG2(blockSize, log2Num);
+                tmpRegNia |= (uint32_t)log2Num << 24;
+
+                // for IPV6 decrement additional 40 bytes of IPV6 heade size - because IPV6 header size is not included in payloadLength
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes - 40);
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
+                if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                {
+                    if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+                    if (p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_NEXT_HEADER_OFFSET_FROM_IP] != 0x88)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("OUr suppport is only IPv6/UDPLite"));
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP + 1] = 0x08;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+                }
+            }
+            else
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("IP version supported only IPV4"));
+        }
+
+        tmpReg32 = tmpReg16 = tmpReg8 = 0;
+        /*TODO - check it*/
+        if (p_InsrtByTemplate->modifyOuterVlan)
+        {
+            if (p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"));
+
+            memcpy(&tmpReg16, &p_Template[VLAN_TAG_FIELD_OFFSET_FROM_ETH], 2*(sizeof(uint8_t)));
+            if ((tmpReg16 != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "));
+
+            memcpy(&tmpReg8, &p_Template[14],1*(sizeof(uint8_t)));
+            tmpReg8 &= 0x1f;
+            tmpReg8 |= (uint8_t)(p_InsrtByTemplate->modifyOuterVlanParams.vpri << 5);
+
+            p_Template[14] = tmpReg8;
+        }
+
+        Mem2IOCpy32(p_Manip->p_Template, p_Template, p_InsrtByTemplate->size);
+
+        XX_Free(p_Template);
+    }
+
+    tmpReg32 = 0;
+    if (p_Manip->h_Frag)
+    {
+        tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
+        tmpReg32 |= (uint32_t)p_Manip->sizeForFragmentation << 16;
+    }
+    else
+    tmpReg32 = 0xffff0000;
+
+    if (ipModify)
+    tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
+    else
+    tmpReg32 |= (uint32_t)0x0000ff00;
+
+    tmpReg32 |= (uint32_t)HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+
+    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    *(uint32_t *)&p_Ad->ccAdBase = tmpRegNia;
+
+    return err;
+}
+
+static t_Error CheckStatsParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdStatsParams *p_StatsParams)
+{
+
+    switch (p_StatsParams->type)
+    {
+        case (e_FM_PCD_STATS_PER_FLOWID):
+        p_Manip->opcode = HMAN_OC_CAPWAP_INDEXED_STATS;
+        p_Manip->muramAllocate = TRUE;
+        break;
+        default:
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported statistics type"));
+    }
 
     return E_OK;
 }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
-static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, bool ipv4)
+static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, e_NetHeaderType hdr)
 {
     t_AdOfTypeContLookup *p_Ad;
-    t_FmPcd              *p_FmPcd   = (t_FmPcd *)p_Manip->h_FmPcd;
-    uint32_t             tmpReg32;
-    t_Error              err = E_OK;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+    uint32_t tmpReg32;
+    t_Error err = E_OK;
 
-    /* Creates the IP Reassembly Parameters table. It contains parameters that are specific to either the IPv4 reassembly
+    /* Creates the Reassembly Parameters table. It contains parameters that are specific to either the IPv4 reassembly
      function or to the IPv6 reassembly function. If both IPv4 reassembly and IPv6 reassembly are required, then
      two separate IP Reassembly Parameter tables are required.*/
-    if ((err = CreateIpReassTable(p_Manip, ipv4)) != E_OK)
+    if ((err = CreateReassTable(p_Manip, hdr)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    /* Sets the first Ad register (ccAdBase) - Action Descriptor Type and Pointer to the IP Reassembly Parameters Table offset from MURAM*/
+    /* Sets the first Ad register (ccAdBase) - Action Descriptor Type and Pointer to the Reassembly Parameters Table offset from MURAM*/
     tmpReg32 = 0;
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
 
     /* Gets the required Action descriptor table pointer */
-    if (ipv4)
+    switch (hdr)
     {
-        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv4Ad;
-        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_Ipv4ReassTbl) - (p_FmPcd->physicalMuramBase));
-    }
-    else
-    {
-        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv6Ad;
-        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_Ipv6ReassTbl) - (p_FmPcd->physicalMuramBase));
+        case HEADER_TYPE_IPv4:
+            p_Ad = (t_AdOfTypeContLookup *)p_Manip->reassmParams.ip.h_Ipv4Ad;
+            tmpReg32 |= (uint32_t)(XX_VirtToPhys(
+                    p_Manip->reassmParams.ip.p_Ipv4ReassTbl)
+                    - (p_FmPcd->physicalMuramBase));
+            break;
+        case HEADER_TYPE_IPv6:
+            p_Ad = (t_AdOfTypeContLookup *)p_Manip->reassmParams.ip.h_Ipv6Ad;
+            tmpReg32 |= (uint32_t)(XX_VirtToPhys(
+                    p_Manip->reassmParams.ip.p_Ipv6ReassTbl)
+                    - (p_FmPcd->physicalMuramBase));
+            break;
+        case HEADER_TYPE_CAPWAP:
+            p_Ad = (t_AdOfTypeContLookup *)p_Manip->reassmParams.capwap.h_Ad;
+            tmpReg32 |= (uint32_t)(XX_VirtToPhys(
+                    p_Manip->reassmParams.capwap.p_ReassTbl)
+                    - (p_FmPcd->physicalMuramBase));
+            break;
+        default:
+            break;
     }
 
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
@@ -2563,21 +3458,33 @@ static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, bool ipv4)
     /* mark the Scatter/Gather table offset to be set later on when the port will be known */
     p_Manip->updateParams = (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK);
 
+    if ((hdr == HEADER_TYPE_IPv6) || (hdr == HEADER_TYPE_IPv4))
+    {
 #if (DPAA_VERSION == 10)
-    tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.sgBpid << 8);
-    WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
+        tmpReg32 = (uint32_t)(p_Manip->reassmParams.sgBpid << 8);
+        WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
 #endif /* (DPAA_VERSION == 10) */
 #if (DPAA_VERSION >= 11)
-    if (p_Manip->ipReassmParams.nonConsistentSpFqid != 0)
-    {
-        tmpReg32 = FM_PCD_AD_NCSPFQIDM_MASK | (uint32_t)(p_Manip->ipReassmParams.nonConsistentSpFqid);
-        WRITE_UINT32(p_Ad->gmask, tmpReg32);
+        if (p_Manip->reassmParams.ip.nonConsistentSpFqid != 0)
+        {
+            tmpReg32 = FM_PCD_AD_NCSPFQIDM_MASK
+                    | (uint32_t)(p_Manip->reassmParams.ip.nonConsistentSpFqid);
+            WRITE_UINT32(p_Ad->gmask, tmpReg32);
+        }
+#endif /* (DPAA_VERSION >= 11) */
+        /* Sets the third Ad register (pcAndOffsets)- IP Reassemble Operation Code*/
+        tmpReg32 = 0;
+        tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
     }
+#if (DPAA_VERSION >= 11)
+    else
+        if (hdr == HEADER_TYPE_CAPWAP)
+        {
+            tmpReg32 = 0;
+            tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_REASSEMBLY;
+        }
 #endif /* (DPAA_VERSION >= 11) */
 
-    /* Sets the third Ad register (pcAndOffsets)- IP Reassemble Operation Code*/
-    tmpReg32 = 0;
-    tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
     p_Manip->reassm = TRUE;
@@ -2590,20 +3497,20 @@ static t_Error SetIpv4ReassmManip(t_FmPcdManip *p_Manip)
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
 
     /* Allocation if IPv4 Action descriptor */
-    p_Manip->ipReassmParams.h_Ipv4Ad =
-        (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
-                                 p_Manip->ipReassmParams.dataMemId,
-                                 FM_PCD_CC_AD_TABLE_ALIGN);
-    if (!p_Manip->ipReassmParams.h_Ipv4Ad)
+    p_Manip->reassmParams.ip.h_Ipv4Ad = (t_Handle)XX_MallocSmart(
+            FM_PCD_CC_AD_ENTRY_SIZE, p_Manip->reassmParams.dataMemId,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->reassmParams.ip.h_Ipv4Ad)
     {
         ReleaseManipHandler(p_Manip, p_FmPcd);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv4 table descriptor"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Allocation of IPv4 table descriptor"));
     }
 
-    memset(p_Manip->ipReassmParams.h_Ipv4Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+    memset(p_Manip->reassmParams.ip.h_Ipv4Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
-    return FillReassmManipParams(p_Manip, TRUE);
+    return FillReassmManipParams(p_Manip, HEADER_TYPE_IPv4);
 }
 
 static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
@@ -2611,74 +3518,90 @@ static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
 
     /* Allocation if IPv6 Action descriptor */
-     p_Manip->ipReassmParams.h_Ipv6Ad =
-        (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
-                                 p_Manip->ipReassmParams.dataMemId,
-                                 FM_PCD_CC_AD_TABLE_ALIGN);
-     if (!p_Manip->ipReassmParams.h_Ipv6Ad)
-     {
+    p_Manip->reassmParams.ip.h_Ipv6Ad = (t_Handle)XX_MallocSmart(
+            FM_PCD_CC_AD_ENTRY_SIZE, p_Manip->reassmParams.dataMemId,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->reassmParams.ip.h_Ipv6Ad)
+    {
         ReleaseManipHandler(p_Manip, p_FmPcd);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv6 table descriptor"));
-     }
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Allocation of IPv6 table descriptor"));
+    }
 
-    memset(p_Manip->ipReassmParams.h_Ipv6Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+    memset(p_Manip->reassmParams.ip.h_Ipv6Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
-    return FillReassmManipParams(p_Manip, FALSE);
+    return FillReassmManipParams(p_Manip, HEADER_TYPE_IPv6);
 }
 
-static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
-                            t_FmPcdManip                *p_Manip)
+static t_Error IpReassembly(t_FmPcdManipReassemParams *p_ManipReassmParams,
+                            t_FmPcdManip *p_Manip)
 {
-    uint32_t                    maxSetNumber = 10000;
-    t_FmPcdManipReassemIpParams reassmManipParams = p_ManipReassmParams->u.ipReassem;
-    t_Error                     res;
+    uint32_t maxSetNumber = 10000;
+    t_FmPcdManipReassemIpParams reassmManipParams =
+            p_ManipReassmParams->u.ipReassem;
+    t_Error res;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(((t_FmPcd *)p_Manip->h_FmPcd)->h_Hc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((t_FmPcd *)p_Manip->h_FmPcd)->h_Hc,
+                              E_INVALID_HANDLE);
 
     /* Check validation of user's parameter.*/
-    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000) ||
-        (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("timeoutThresholdForReassmProcess should be 1msec - 8sec"));
+    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000)
+            || (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("timeoutThresholdForReassmProcess should be 1msec - 8sec"));
     /* It is recommended that the total number of entries in this table (number of sets * number of ways)
-       will be twice the number of frames that are expected to be reassembled simultaneously.*/
-    if (reassmManipParams.maxNumFramesInProcess >
-        (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"));
-
-    if ((p_ManipReassmParams->hdr == HEADER_TYPE_IPv6) &&
-        (reassmManipParams.minFragSize[1] < 256))
+     will be twice the number of frames that are expected to be reassembled simultaneously.*/
+    if (reassmManipParams.maxNumFramesInProcess
+            > (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"));
+
+    if ((p_ManipReassmParams->hdr == HEADER_TYPE_IPv6)
+            && (reassmManipParams.minFragSize[1] < 256))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("minFragSize[1] must be >= 256"));
 
     /* Saves user's reassembly manipulation parameters */
-    p_Manip->ipReassmParams.relativeSchemeId[0] = reassmManipParams.relativeSchemeId[0];
-    p_Manip->ipReassmParams.relativeSchemeId[1] = reassmManipParams.relativeSchemeId[1];
-    p_Manip->ipReassmParams.numOfFramesPerHashEntry[0] = reassmManipParams.numOfFramesPerHashEntry[0];
-    p_Manip->ipReassmParams.numOfFramesPerHashEntry[1] = reassmManipParams.numOfFramesPerHashEntry[1];
-    p_Manip->ipReassmParams.minFragSize[0] = reassmManipParams.minFragSize[0];
-    p_Manip->ipReassmParams.minFragSize[1] = reassmManipParams.minFragSize[1];
-    p_Manip->ipReassmParams.maxNumFramesInProcess = reassmManipParams.maxNumFramesInProcess;
-    p_Manip->ipReassmParams.timeOutMode = reassmManipParams.timeOutMode;
-    p_Manip->ipReassmParams.fqidForTimeOutFrames = reassmManipParams.fqidForTimeOutFrames;
-    p_Manip->ipReassmParams.timeoutThresholdForReassmProcess = reassmManipParams.timeoutThresholdForReassmProcess;
-    p_Manip->ipReassmParams.dataMemId = reassmManipParams.dataMemId;
-    p_Manip->ipReassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
+    p_Manip->reassmParams.ip.relativeSchemeId[0] =
+            reassmManipParams.relativeSchemeId[0];
+    p_Manip->reassmParams.ip.relativeSchemeId[1] =
+            reassmManipParams.relativeSchemeId[1];
+    p_Manip->reassmParams.ip.numOfFramesPerHashEntry[0] =
+            reassmManipParams.numOfFramesPerHashEntry[0];
+    p_Manip->reassmParams.ip.numOfFramesPerHashEntry[1] =
+            reassmManipParams.numOfFramesPerHashEntry[1];
+    p_Manip->reassmParams.ip.minFragSize[0] = reassmManipParams.minFragSize[0];
+    p_Manip->reassmParams.ip.minFragSize[1] = reassmManipParams.minFragSize[1];
+    p_Manip->reassmParams.maxNumFramesInProcess =
+            reassmManipParams.maxNumFramesInProcess;
+    p_Manip->reassmParams.timeOutMode = reassmManipParams.timeOutMode;
+    p_Manip->reassmParams.fqidForTimeOutFrames =
+            reassmManipParams.fqidForTimeOutFrames;
+    p_Manip->reassmParams.timeoutThresholdForReassmProcess =
+            reassmManipParams.timeoutThresholdForReassmProcess;
+    p_Manip->reassmParams.dataMemId = reassmManipParams.dataMemId;
+    p_Manip->reassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
 #if (DPAA_VERSION == 10)
-    p_Manip->ipReassmParams.sgBpid = reassmManipParams.sgBpid;
+    p_Manip->reassmParams.sgBpid = reassmManipParams.sgBpid;
 #endif /* (DPAA_VERSION == 10) */
 #if (DPAA_VERSION >= 11)
     if (reassmManipParams.nonConsistentSpFqid != 0)
     {
-        p_Manip->ipReassmParams.nonConsistentSpFqid = reassmManipParams.nonConsistentSpFqid;
+        p_Manip->reassmParams.ip.nonConsistentSpFqid =
+                reassmManipParams.nonConsistentSpFqid;
     }
 #endif /* (DPAA_VERSION >= 11) */
 
     /* Creates and initializes the IP Reassembly common parameter table */
-    CreateIpReassCommonTable(p_Manip);
+    CreateReassCommonTable(p_Manip);
 
     /* Creation of IPv4 reassembly manipulation */
-    if ((p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6) || (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4))
+    if ((p_Manip->reassmParams.hdr == HEADER_TYPE_IPv6)
+            || (p_Manip->reassmParams.hdr == HEADER_TYPE_IPv4))
     {
         res = SetIpv4ReassmManip(p_Manip);
         if (res != E_OK)
@@ -2686,7 +3609,7 @@ static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
     }
 
     /* Creation of IPv6 reassembly manipulation */
-    if (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6)
+    if (p_Manip->reassmParams.hdr == HEADER_TYPE_IPv6)
     {
         res = SetIpv6ReassmManip(p_Manip);
         if (res != E_OK)
@@ -2696,21 +3619,30 @@ static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
     return E_OK;
 }
 
-static void setReassmSchemeParams(t_FmPcd* p_FmPcd, t_FmPcdKgSchemeParams *p_Scheme, t_Handle h_CcTree, bool ipv4, uint8_t groupId)
+static void setIpReassmSchemeParams(t_FmPcd* p_FmPcd,
+                                    t_FmPcdKgSchemeParams *p_Scheme,
+                                    t_Handle h_CcTree, bool ipv4,
+                                    uint8_t groupId)
 {
-    uint32_t    j;
-    uint8_t     res;
+    uint32_t j;
+    uint8_t res;
 
     /* Configures scheme's network environment parameters */
     p_Scheme->netEnvParams.numOfDistinctionUnits = 2;
     if (ipv4)
-        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv4, FALSE, 0);
+        res = FmPcdNetEnvGetUnitId(
+                p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv),
+                HEADER_TYPE_IPv4, FALSE, 0);
     else
-        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv6, FALSE, 0);
+        res = FmPcdNetEnvGetUnitId(
+                p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv),
+                HEADER_TYPE_IPv6, FALSE, 0);
     ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
     p_Scheme->netEnvParams.unitIds[0] = res;
 
-    res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0);
+    res = FmPcdNetEnvGetUnitId(
+            p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv),
+            HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0);
     ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
     p_Scheme->netEnvParams.unitIds[1] = res;
 
@@ -2724,455 +3656,610 @@ static void setReassmSchemeParams(t_FmPcd* p_FmPcd, t_FmPcdKgSchemeParams *p_Sch
     if (ipv4 == TRUE)
     {
         p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 4;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv4 ;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv4;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_IPv4;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.hdr = HEADER_TYPE_IPv4;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.ignoreProtocolValidation = FALSE;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.size = 2;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.offset = 4;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr =
+                HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv4 =
+                NET_HEADER_FIELD_IPv4_DST_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr =
+                HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv4 =
+                NET_HEADER_FIELD_IPv4_SRC_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr =
+                HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fullField.ipv4 =
+                NET_HEADER_FIELD_IPv4_PROTO;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.hdr =
+                HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FROM_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.ignoreProtocolValidation =
+                FALSE;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.size =
+                2;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.offset =
+                4;
     }
     else /* IPv6 */
     {
         p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 3;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv6 ;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_DST_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv6;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_SRC_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.size  = 4;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.offset = 4;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.ignoreProtocolValidation = TRUE;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr =
+                HEADER_TYPE_IPv6;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv6 =
+                NET_HEADER_FIELD_IPv6_DST_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr =
+                HEADER_TYPE_IPv6;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv6 =
+                NET_HEADER_FIELD_IPv6_SRC_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr =
+                HEADER_TYPE_USER_DEFINED_SHIM2;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FROM_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.size =
+                4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.offset =
+                4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.ignoreProtocolValidation =
+                TRUE;
     }
 
     p_Scheme->keyExtractAndHashParams.privateDflt0 = 0x01020304;
     p_Scheme->keyExtractAndHashParams.privateDflt1 = 0x11121314;
-    p_Scheme->keyExtractAndHashParams.numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
-    for (j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
+    p_Scheme->keyExtractAndHashParams.numOfUsedDflts =
+            FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+    for (j = 0; j < FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
     {
-        p_Scheme->keyExtractAndHashParams.dflts[j].type = (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
-        p_Scheme->keyExtractAndHashParams.dflts[j].dfltSelect = e_FM_PCD_KG_DFLT_GBL_0;
+        p_Scheme->keyExtractAndHashParams.dflts[j].type =
+                (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
+        p_Scheme->keyExtractAndHashParams.dflts[j].dfltSelect =
+                e_FM_PCD_KG_DFLT_GBL_0;
     }
 }
 
-static t_Error IpReassemblyStats(t_FmPcdManip *p_Manip, t_FmPcdManipReassemIpStats *p_Stats)
+static t_Error IpReassemblyStats(t_FmPcdManip *p_Manip,
+                                 t_FmPcdManipReassemIpStats *p_Stats)
 {
     ASSERT_COND(p_Manip);
     ASSERT_COND(p_Stats);
-    ASSERT_COND(p_Manip->ipReassmParams.p_IpReassCommonTbl);
-
-    p_Stats->timeout                = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalTimeOutCounter);
-    p_Stats->rfdPoolBusy            = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalRfdPoolBusyCounter);
-    p_Stats->internalBufferBusy     = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalInternalBufferBusy);
-    p_Stats->externalBufferBusy     = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalExternalBufferBusy);
-    p_Stats->sgFragments            = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalSgFragmentCounter);
-    p_Stats->dmaSemaphoreDepletion  = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalDmaSemaphoreDepletionCounter);
+    ASSERT_COND(p_Manip->reassmParams.p_ReassCommonTbl);
+
+    p_Stats->timeout =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalTimeOutCounter);
+    p_Stats->rfdPoolBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalRfdPoolBusyCounter);
+    p_Stats->internalBufferBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalInternalBufferBusy);
+    p_Stats->externalBufferBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalExternalBufferBusy);
+    p_Stats->sgFragments =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalSgFragmentCounter);
+    p_Stats->dmaSemaphoreDepletion =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalDmaSemaphoreDepletionCounter);
 #if (DPAA_VERSION >= 11)
-    p_Stats->nonConsistentSp        = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalNCSPCounter);
+    p_Stats->nonConsistentSp =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalNCSPCounter);
 #endif /* (DPAA_VERSION >= 11) */
 
-    if (p_Manip->ipReassmParams.p_Ipv4ReassTbl)
+    if (p_Manip->reassmParams.ip.p_Ipv4ReassTbl)
     {
-        p_Stats->specificHdrStatistics[0].successfullyReassembled = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalSuccessfullyReasmFramesCounter);
-        p_Stats->specificHdrStatistics[0].validFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalValidFragmentCounter);
-        p_Stats->specificHdrStatistics[0].processedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalProcessedFragCounter);
-        p_Stats->specificHdrStatistics[0].malformedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalMalformdFragCounter);
-        p_Stats->specificHdrStatistics[0].autoLearnBusy = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalSetBusyCounter);
-        p_Stats->specificHdrStatistics[0].discardedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalDiscardedFragsCounter);
-        p_Stats->specificHdrStatistics[0].moreThan16Fragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalMoreThan16FramesCounter);
+        p_Stats->specificHdrStatistics[0].successfullyReassembled =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalSuccessfullyReasmFramesCounter);
+        p_Stats->specificHdrStatistics[0].validFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalValidFragmentCounter);
+        p_Stats->specificHdrStatistics[0].processedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalProcessedFragCounter);
+        p_Stats->specificHdrStatistics[0].malformedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalMalformdFragCounter);
+        p_Stats->specificHdrStatistics[0].autoLearnBusy =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalSetBusyCounter);
+        p_Stats->specificHdrStatistics[0].discardedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalDiscardedFragsCounter);
+        p_Stats->specificHdrStatistics[0].moreThan16Fragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalMoreThan16FramesCounter);
     }
-    if (p_Manip->ipReassmParams.p_Ipv6ReassTbl)
+    if (p_Manip->reassmParams.ip.p_Ipv6ReassTbl)
     {
-        p_Stats->specificHdrStatistics[1].successfullyReassembled = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalSuccessfullyReasmFramesCounter);
-        p_Stats->specificHdrStatistics[1].validFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalValidFragmentCounter);
-        p_Stats->specificHdrStatistics[1].processedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalProcessedFragCounter);
-        p_Stats->specificHdrStatistics[1].malformedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalMalformdFragCounter);
-        p_Stats->specificHdrStatistics[1].autoLearnBusy = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalSetBusyCounter);
-        p_Stats->specificHdrStatistics[1].discardedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalDiscardedFragsCounter);
-        p_Stats->specificHdrStatistics[1].moreThan16Fragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalMoreThan16FramesCounter);
+        p_Stats->specificHdrStatistics[1].successfullyReassembled =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalSuccessfullyReasmFramesCounter);
+        p_Stats->specificHdrStatistics[1].validFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalValidFragmentCounter);
+        p_Stats->specificHdrStatistics[1].processedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalProcessedFragCounter);
+        p_Stats->specificHdrStatistics[1].malformedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalMalformdFragCounter);
+        p_Stats->specificHdrStatistics[1].autoLearnBusy =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalSetBusyCounter);
+        p_Stats->specificHdrStatistics[1].discardedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalDiscardedFragsCounter);
+        p_Stats->specificHdrStatistics[1].moreThan16Fragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalMoreThan16FramesCounter);
     }
     return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
-static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd)
+static t_Error IpFragmentationStats(t_FmPcdManip *p_Manip,
+                                    t_FmPcdManipFragIpStats *p_Stats)
 {
-    t_AdOfTypeContLookup    *p_Ad;
-    uint32_t                tmpReg32 = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-
-    UNUSED(p_FmPcd);
+    t_AdOfTypeContLookup *p_Ad;
 
-    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    ASSERT_COND(p_Manip);
+    ASSERT_COND(p_Stats);
+    ASSERT_COND(p_Manip->h_Ad);
+    ASSERT_COND(p_Manip->fragParams.p_Frag);
 
-    tmpReg32 = 0;
-    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_INDEXED_STATS;
-    if (p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
-        tmpReg32 |= (uint32_t)0x16 << 16;
-    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
-    tmpReg32 = 0;
-    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+    p_Stats->totalFrames = GET_UINT32(p_Ad->gmask);
+    p_Stats->fragmentedFrames = GET_UINT32(p_Manip->fragParams.p_Frag->ccAdBase)
+            & 0x00ffffff;
+    p_Stats->generatedFragments =
+            GET_UINT32(p_Manip->fragParams.p_Frag->matchTblPtr);
 
     return E_OK;
 }
 
-static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams  *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,
+                               t_FmPcdManip *p_Manip)
 {
-    t_FmPcdManipHdrInsrtByTemplateParams   *p_InsrtByTemplate = &p_ManipParams->u.byTemplate;
-    uint8_t                             tmpReg8 = 0xff;
-    t_AdOfTypeContLookup                *p_Ad;
-    bool                                ipModify = FALSE;
-    uint32_t                            tmpReg32 = 0, tmpRegNia = 0;
-    uint16_t                            tmpReg16 = 0;
-    t_Error                             err = E_OK;
-    uint8_t                             extraAddedBytes = 0, blockSize = 0, extraAddedBytesAlignedToBlockSize = 0, log2Num = 0;
-    uint8_t                             *p_Template = NULL;
+    uint32_t pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
+    t_FmPcd *p_FmPcd;
+#if (DPAA_VERSION == 10)
+    t_Error err = E_OK;
+#endif /* (DPAA_VERSION == 10) */
 
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams->sizeForFragmentation != 0xFFFF,
+                              E_INVALID_VALUE);
 
-    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if (p_Manip->insrt)
-    {
-        if ((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
-             (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
-             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
+    p_FmPcd = p_Manip->h_FmPcd;
+    /* Allocation of fragmentation Action Descriptor */
+    p_Manip->fragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(
+            p_FmPcd->h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->fragParams.p_Frag)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Fragmentation table descriptor"));
+    IOMemSet32(p_Manip->fragParams.p_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
-         if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
-             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
+    /* Prepare the third Ad register (pcAndOffsets)- OperationCode */
+    pcAndOffsetsReg = (uint32_t)HMAN_OC_IP_FRAGMENTATION;
 
-         if (p_InsrtByTemplate->size > 128)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
+    /* Prepare the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
+    ccAdBaseReg = FM_PCD_AD_CONT_LOOKUP_TYPE;
+    ccAdBaseReg |= (p_ManipParams->dontFragAction
+            << FM_PCD_MANIP_IP_FRAG_DF_SHIFT);
 
-         if (p_InsrtByTemplate->size)
-         {
-             p_Manip->p_Template = (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                             p_InsrtByTemplate->size,
-                                             FM_PCD_CC_AD_TABLE_ALIGN);
-             if(!p_Manip->p_Template)
-                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
 
-             tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
-             tmpReg32 |= (uint32_t)p_InsrtByTemplate->size << 24;
-             *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;
-         }
+    /* Set Scatter/Gather BPid */
+    if (p_ManipParams->sgBpidEn)
+    {
+        ccAdBaseReg |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
+        pcAndOffsetsReg |= ((p_ManipParams->sgBpid
+                << FM_PCD_MANIP_IP_FRAG_SG_BDID_SHIFT)
+                & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
+    }
 
-         tmpReg32 = 0;
+    /* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
+    gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr))
+            - p_FmPcd->physicalMuramBase);
+#if (DPAA_VERSION == 10)
+    gmaskReg |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
+#else
+    gmaskReg |= (0xFF) << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
+#endif /* (DPAA_VERSION == 10) */
 
-        p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
+    /* Set all Ad registers */
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->pcAndOffsets, pcAndOffsetsReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->ccAdBase, ccAdBaseReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->gmask, gmaskReg);
 
-        if (!p_Template)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+    /* Saves user's fragmentation manipulation parameters */
+    p_Manip->frag = TRUE;
+    p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
 
-        memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
+#if (DPAA_VERSION == 10)
+    p_Manip->fragParams.scratchBpid = p_ManipParams->scratchBpid;
 
+    /* scratch buffer pool initialization */
+    if ((err = FmPcdFragHcScratchPoolFill((t_Handle)p_FmPcd, p_ManipParams->scratchBpid)) != E_OK)
+    {
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_Frag);
+        p_Manip->fragParams.p_Frag = NULL;
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+#endif /* (DPAA_VERSION == 10) */
 
-         if (p_InsrtByTemplate->modifyOuterIp)
-         {
-             ipModify = TRUE;
+    return E_OK;
+}
 
-             tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
+static t_Error IPManip(t_FmPcdManip *p_Manip)
+{
+    t_Error err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t tmpReg32 = 0, tmpRegNia = 0;
 
-             if((tmpReg8 & 0xf0) == 0x40)
-                 tmpReg8 = 4;
-             else if((tmpReg8 & 0xf0) == 0x60)
-                 tmpReg8 = 6;
-             else
-                 tmpReg8 = 0xff;
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    p_FmPcd = p_Manip->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-             if (tmpReg8 != 0xff)
-             {
-                if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
-                if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
-                 {
-
-                     if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
-                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
-                     extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
-                     blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
-                     extraAddedBytesAlignedToBlockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize;
-                     /*IP header template - IP totalLength -
-                     (1 byte) extraByteForIp = headerTemplateSize - ipOffset + insertedBytesAfterThisStage ,
-                     in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
-                     second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
-                 }
-                 if (blockSize)
-                 {
-                     if (!POWER_OF_2(blockSize))
-                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
-                 }
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
-             }
-             if (tmpReg8 == 4)
-             {
-                 if ((IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
+    tmpReg32 = FM_PCD_MANIP_IP_NO_FRAGMENTATION;
+    if (p_Manip->frag == TRUE)
+    {
+        tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_Frag)
+                - (p_FmPcd->physicalMuramBase));
+        tmpReg32 = (uint32_t)p_Manip->sizeForFragmentation
+                << FM_PCD_MANIP_IP_MTU_SHIFT;
+    }
 
+    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32 |= HMAN_OC_IP_MANIP;
 
-                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
+#if (DPAA_VERSION >= 11)
+    tmpRegNia |= FM_PCD_MANIP_IP_CNIA;
+#endif /* (DPAA_VERSION >= 11) */
 
-                 if (blockSize)
-                     blockSize -= 1;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+    WRITE_UINT32(p_Ad->ccAdBase, tmpRegNia);
+    WRITE_UINT32(p_Ad->gmask, 0);
+    /* Total frame counter - MUST be initialized to zero.*/
 
-                 if ((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
+    return err;
+}
 
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;// IPV6 - in AD instead of SEQ IND
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes);// for IPV6 decrement additional 40 bytes of IPV6 heade size
+static t_Error UpdateInitIpFrag(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                                t_Handle h_FmPort, t_FmPcdManip *p_Manip,
+                                t_Handle h_Ad, bool validate)
+{
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
 
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP] = 0x00;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_IP_FRAGMENTATION),
+                              E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
 
+    UNUSED(h_FmPcd);
+    UNUSED(h_Ad);
+    UNUSED(h_PcdParams);
+    UNUSED(validate);
+    UNUSED(p_Manip);
 
+    fmPortGetSetCcParams.setCcParams.type = 0;
+    fmPortGetSetCcParams.getCcParams.type = MANIP_EXTRA_SPACE;
+    if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-                 /*IP header template - relevant only for ipv4 CheckSum = 0*/
-                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP] = 0x00;
-                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + 1] = 0x00;
+    if (!fmPortGetSetCcParams.getCcParams.internalBufferOffset)
+        DBG(WARNING, ("manipExtraSpace must be larger than '0'"));
 
+    return E_OK;
+}
 
-                 /*UDP checksum has to be 0*/
-                 if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
-                 {
-                     if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
-                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+static t_Error IPSecManip(t_FmPcdManipParams *p_ManipParams,
+                          t_FmPcdManip *p_Manip)
+{
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPcdManipSpecialOffloadIPSecParams *p_IPSecParams;
+    t_Error err = E_OK;
+    uint32_t tmpReg32 = 0;
 
-                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
-                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams, E_INVALID_HANDLE);
 
-                 }
+    p_IPSecParams = &p_ManipParams->u.specialOffload.u.ipsec;
 
-                 if (p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
-                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
+    SANITY_CHECK_RETURN_ERROR(
+            !p_IPSecParams->variableIpHdrLen || p_IPSecParams->decryption,
+            E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            !p_IPSecParams->variableIpVersion || !p_IPSecParams->decryption,
+            E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            !p_IPSecParams->variableIpVersion || p_IPSecParams->outerIPHdrLen,
+            E_INVALID_VALUE);
 
-                 tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
-             }
-             else if (tmpReg8 == 6)
-             {
-                /*TODO - add check for maximum value of blockSize;*/
-                 if (blockSize)
-                    LOG2(blockSize, log2Num);
-                 tmpRegNia |= (uint32_t)log2Num << 24;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
-                // for IPV6 decrement additional 40 bytes of IPV6 heade size - because IPV6 header size is not included in payloadLength
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes - 40);
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
-               if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
-               {
-                 if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
-                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
-                if (p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_NEXT_HEADER_OFFSET_FROM_IP] != 0x88)
-                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("OUr suppport is only IPv6/UDPLite"));
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP] = 0x00;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP + 1] = 0x08;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP] = 0x00;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
-               }
-             }
-             else
-                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("IP version supported only IPV4"));
-         }
-
-         tmpReg32 = tmpReg16 = tmpReg8 = 0;
-         /*TODO - check it*/
-         if (p_InsrtByTemplate->modifyOuterVlan)
-         {
-             if (p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
-                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"));
-
-             memcpy(&tmpReg16, &p_Template[VLAN_TAG_FIELD_OFFSET_FROM_ETH], 2*(sizeof(uint8_t)));
-             if ((tmpReg16  != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
-                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "));
-
-             memcpy(&tmpReg8, &p_Template[14],1*(sizeof(uint8_t)));
-             tmpReg8 &= 0x1f;
-             tmpReg8 |= (uint8_t)(p_InsrtByTemplate->modifyOuterVlanParams.vpri << 5);
-
-             p_Template[14] = tmpReg8;
-         }
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32 |= (p_IPSecParams->decryption) ? FM_PCD_MANIP_IPSEC_DEC : 0;
+    tmpReg32 |= (p_IPSecParams->ecnCopy) ? FM_PCD_MANIP_IPSEC_ECN_EN : 0;
+    tmpReg32 |= (p_IPSecParams->dscpCopy) ? FM_PCD_MANIP_IPSEC_DSCP_EN : 0;
+    tmpReg32 |=
+            (p_IPSecParams->variableIpHdrLen) ? FM_PCD_MANIP_IPSEC_VIPL_EN : 0;
+    tmpReg32 |=
+            (p_IPSecParams->variableIpVersion) ? FM_PCD_MANIP_IPSEC_VIPV_EN : 0;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
-        Mem2IOCpy32(p_Manip->p_Template, p_Template, p_InsrtByTemplate->size);
+    tmpReg32 = HMAN_OC_IPSEC_MANIP;
+    tmpReg32 |= p_IPSecParams->outerIPHdrLen
+            << FM_PCD_MANIP_IPSEC_IP_HDR_LEN_SHIFT;
+    if (p_ManipParams->h_NextManip)
+    {
+        WRITE_UINT32(
+                p_Ad->matchTblPtr,
+                (uint32_t)(XX_VirtToPhys(((t_FmPcdManip *)p_ManipParams->h_NextManip)->h_Ad)- (((t_FmPcd *)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4);
 
-        XX_Free(p_Template);
-    }
+        tmpReg32 |= FM_PCD_MANIP_IPSEC_NADEN;
+    }WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
-    tmpReg32 = 0;
-    if (p_Manip->h_Frag)
+    return err;
+}
+
+static t_Error SetCapwapReassmManip(t_FmPcdManip *p_Manip)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+
+    /* Allocation if CAPWAP Action descriptor */
+    p_Manip->reassmParams.capwap.h_Ad = (t_Handle)XX_MallocSmart(
+            FM_PCD_CC_AD_ENTRY_SIZE, p_Manip->reassmParams.dataMemId,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->reassmParams.capwap.h_Ad)
     {
-        tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
-        tmpReg32  |= (uint32_t)p_Manip->sizeForFragmentation << 16;
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Allocation of CAPWAP table descriptor"));
     }
-    else
-          tmpReg32 = 0xffff0000;
 
-    if (ipModify)
-        tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
-    else
-        tmpReg32 |= (uint32_t)0x0000ff00;
+    memset(p_Manip->reassmParams.capwap.h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
-    tmpReg32 |= (uint32_t)HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
-    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+    /* Fill reassembly manipulation parameter in the Reassembly Action Descriptor */
+    return FillReassmManipParams(p_Manip, HEADER_TYPE_CAPWAP);
+}
 
-    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    *(uint32_t *)&p_Ad->ccAdBase = tmpRegNia;
+static void setCapwapReassmSchemeParams(t_FmPcd* p_FmPcd,
+                                        t_FmPcdKgSchemeParams *p_Scheme,
+                                        t_Handle h_CcTree, uint8_t groupId)
+{
+    uint32_t j;
+    uint8_t res;
 
-    return err;
+    /* Configures scheme's network environment parameters */
+    p_Scheme->netEnvParams.numOfDistinctionUnits = 1;
+    res = FmPcdNetEnvGetUnitId(
+            p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv),
+            HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0);
+    ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    p_Scheme->netEnvParams.unitIds[0] = res;
+
+    /* Configures scheme's next engine parameters*/
+    p_Scheme->nextEngine = e_FM_PCD_CC;
+    p_Scheme->kgNextEngineParams.cc.h_CcTree = h_CcTree;
+    p_Scheme->kgNextEngineParams.cc.grpId = groupId;
+    p_Scheme->useHash = TRUE;
+
+    /* Configures scheme's key*/
+    p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 2;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].type =
+            e_FM_PCD_EXTRACT_NON_HDR;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].extractNonHdr.src =
+            e_FM_PCD_EXTRACT_FROM_PARSE_RESULT;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].extractNonHdr.action =
+            e_FM_PCD_ACTION_NONE;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].extractNonHdr.offset = 20;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].extractNonHdr.size = 4;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].type =
+            e_FM_PCD_EXTRACT_NON_HDR;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].extractNonHdr.src =
+            e_FM_PCD_EXTRACT_FROM_DFLT_VALUE;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].extractNonHdr.action =
+            e_FM_PCD_ACTION_NONE;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].extractNonHdr.offset = 0;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].extractNonHdr.size = 1;
+
+    p_Scheme->keyExtractAndHashParams.privateDflt0 = 0x0;
+    p_Scheme->keyExtractAndHashParams.privateDflt1 = 0x0;
+    p_Scheme->keyExtractAndHashParams.numOfUsedDflts = 1;
+    p_Scheme->keyExtractAndHashParams.dflts[0].type = e_FM_PCD_KG_GENERIC_NOT_FROM_DATA;
+    p_Scheme->keyExtractAndHashParams.dflts[0].dfltSelect = e_FM_PCD_KG_DFLT_PRIVATE_0;
 }
-#endif /* FM_CAPWAP_SUPPORT */
 
-static t_Error IpFragmentationStats(t_FmPcdManip *p_Manip, t_FmPcdManipFragIpStats *p_Stats)
+#if (DPAA_VERSION >= 11)
+static t_Error CapwapReassemblyStats(t_FmPcdManip *p_Manip,
+                                     t_FmPcdManipReassemCapwapStats *p_Stats)
 {
-    t_AdOfTypeContLookup    *p_Ad;
-
     ASSERT_COND(p_Manip);
     ASSERT_COND(p_Stats);
-    ASSERT_COND(p_Manip->h_Ad);
-    ASSERT_COND(p_Manip->ipFragParams.p_Frag);
+    ASSERT_COND(p_Manip->reassmParams.p_ReassCommonTbl);
+
+    p_Stats->timeout =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalTimeOutCounter);
+    p_Stats->rfdPoolBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalRfdPoolBusyCounter);
+    p_Stats->internalBufferBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalInternalBufferBusy);
+    p_Stats->externalBufferBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalExternalBufferBusy);
+    p_Stats->sgFragments =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalSgFragmentCounter);
+    p_Stats->dmaSemaphoreDepletion =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalDmaSemaphoreDepletionCounter);
+    p_Stats->exceedMaxReassemblyFrameLen =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalNCSPCounter);
+
+    p_Stats->successfullyReassembled =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalSuccessfullyReasmFramesCounter);
+    p_Stats->validFragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalValidFragmentCounter);
+    p_Stats->processedFragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalProcessedFragCounter);
+    p_Stats->malformedFragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalMalformdFragCounter);
+    p_Stats->autoLearnBusy =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalSetBusyCounter);
+    p_Stats->discardedFragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalDiscardedFragsCounter);
+    p_Stats->moreThan16Fragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalMoreThan16FramesCounter);
 
-    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    return E_OK;
+}
 
-    p_Stats->totalFrames = GET_UINT32(p_Ad->gmask);
-    p_Stats->fragmentedFrames = GET_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase) & 0x00ffffff;
-    p_Stats->generatedFragments = GET_UINT32(p_Manip->ipFragParams.p_Frag->matchTblPtr);
+static t_Error CapwapReassembly(t_FmPcdManipReassemParams *p_ManipReassmParams,
+                                t_FmPcdManip *p_Manip)
+{
+    uint32_t maxSetNumber = 10000;
+    t_FmPcdManipReassemCapwapParams reassmManipParams =
+            p_ManipReassmParams->u.capwapReassem;
+    t_Error res;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((t_FmPcd *)p_Manip->h_FmPcd)->h_Hc,
+                              E_INVALID_HANDLE);
+
+    /* Check validation of user's parameter.*/
+    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000)
+            || (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("timeoutThresholdForReassmProcess should be 1msec - 8sec"));
+    /* It is recommended that the total number of entries in this table (number of sets * number of ways)
+     will be twice the number of frames that are expected to be reassembled simultaneously.*/
+    if (reassmManipParams.maxNumFramesInProcess
+            > (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"));
+
+    /* Saves user's reassembly manipulation parameters */
+    p_Manip->reassmParams.capwap.relativeSchemeId =
+            reassmManipParams.relativeSchemeId;
+    p_Manip->reassmParams.capwap.numOfFramesPerHashEntry =
+            reassmManipParams.numOfFramesPerHashEntry;
+    p_Manip->reassmParams.capwap.maxRessembledsSize =
+            reassmManipParams.maxReassembledFrameLength;
+    p_Manip->reassmParams.maxNumFramesInProcess =
+            reassmManipParams.maxNumFramesInProcess;
+    p_Manip->reassmParams.timeOutMode = reassmManipParams.timeOutMode;
+    p_Manip->reassmParams.fqidForTimeOutFrames =
+            reassmManipParams.fqidForTimeOutFrames;
+    p_Manip->reassmParams.timeoutThresholdForReassmProcess =
+            reassmManipParams.timeoutThresholdForReassmProcess;
+    p_Manip->reassmParams.dataMemId = reassmManipParams.dataMemId;
+    p_Manip->reassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
+
+    /* Creates and initializes the Reassembly common parameter table */
+    CreateReassCommonTable(p_Manip);
+
+    res = SetCapwapReassmManip(p_Manip);
+    if (res != E_OK)
+        return res;
 
     return E_OK;
 }
 
-static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdManip *p_Manip)
+static t_Error CapwapFragmentation(t_FmPcdManipFragCapwapParams *p_ManipParams,
+                                   t_FmPcdManip *p_Manip)
 {
-    uint32_t    pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
-    t_FmPcd     *p_FmPcd;
-#if (DPAA_VERSION == 10)
-    t_Error     err = E_OK;
-#endif /* (DPAA_VERSION == 10) */
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams->sizeForFragmentation != 0xFFFF, E_INVALID_VALUE);
+    t_FmPcd *p_FmPcd;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
+    uint32_t tmpReg32 = 0, tmpRegNia = 0;
 
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams->sizeForFragmentation != 0xFFFF,
+                              E_INVALID_VALUE);
     p_FmPcd = p_Manip->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
     /* Allocation of fragmentation Action Descriptor */
-    p_Manip->ipFragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                                             FM_PCD_CC_AD_ENTRY_SIZE,
-                                                                             FM_PCD_CC_AD_TABLE_ALIGN);
-    if (!p_Manip->ipFragParams.p_Frag)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Fragmentation table descriptor"));
-    IOMemSet32( p_Manip->ipFragParams.p_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    p_Manip->fragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(
+            p_FmPcd->h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->fragParams.p_Frag)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Fragmentation table descriptor"));
+    IOMemSet32(p_Manip->fragParams.p_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Prepare the third Ad register (pcAndOffsets)- OperationCode */
-    pcAndOffsetsReg = (uint32_t)HMAN_OC_IP_FRAGMENTATION;
+    pcAndOffsetsReg = (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
 
     /* Prepare the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
     ccAdBaseReg = FM_PCD_AD_CONT_LOOKUP_TYPE;
-    ccAdBaseReg |= (p_ManipParams->dontFragAction << FM_PCD_MANIP_IP_FRAG_DF_SHIFT);
-
+    ccAdBaseReg |=
+            (p_ManipParams->compressModeEn) ? FM_PCD_MANIP_CAPWAP_FRAG_COMPRESS_EN :
+                    0;
 
     /* Set Scatter/Gather BPid */
     if (p_ManipParams->sgBpidEn)
     {
-         ccAdBaseReg     |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
-         pcAndOffsetsReg |= ((p_ManipParams->sgBpid << FM_PCD_MANIP_IP_FRAG_SG_BDID_SHIFT) & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
+        ccAdBaseReg |= FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_EN;
+        pcAndOffsetsReg |= ((p_ManipParams->sgBpid
+                << FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_SHIFT)
+                & FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_MASK);
     }
 
     /* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
-    gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr)) - p_FmPcd->physicalMuramBase);
-#if (DPAA_VERSION == 10)
-    gmaskReg |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
-#else
+    gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->capwapFrameIdAddr))
+            - p_FmPcd->physicalMuramBase);
     gmaskReg |= (0xFF) << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
-#endif /* (DPAA_VERSION == 10) */
 
     /* Set all Ad registers */
-    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->pcAndOffsets, pcAndOffsetsReg);
-    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase, ccAdBaseReg);
-    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->gmask, gmaskReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->pcAndOffsets, pcAndOffsetsReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->ccAdBase, ccAdBaseReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->gmask, gmaskReg);
 
     /* Saves user's fragmentation manipulation parameters */
     p_Manip->frag = TRUE;
     p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
 
-#if (DPAA_VERSION == 10)
-    p_Manip->ipFragParams.scratchBpid = p_ManipParams->scratchBpid;
-
-    /* scratch buffer pool initialization */
-    if ((err = FmPcdFragHcScratchPoolFill((t_Handle)p_FmPcd, p_ManipParams->scratchBpid)) != E_OK)
-    {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
-        p_Manip->ipFragParams.p_Frag = NULL;
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-#endif /* (DPAA_VERSION == 10) */
-
-    return E_OK;
-}
-
-static t_Error IPManip(t_FmPcdManip *p_Manip)
-{
-    t_Error                     err = E_OK;
-    t_FmPcd                     *p_FmPcd;
-    t_AdOfTypeContLookup        *p_Ad;
-    uint32_t                    tmpReg32 = 0, tmpRegNia = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    p_FmPcd = p_Manip->h_FmPcd;
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
-
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
-    tmpReg32 = FM_PCD_MANIP_IP_NO_FRAGMENTATION;
-    if (p_Manip->frag == TRUE)
-    {
-        tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->ipFragParams.p_Frag) - (p_FmPcd->physicalMuramBase));
-        tmpReg32  = (uint32_t)p_Manip->sizeForFragmentation << FM_PCD_MANIP_IP_MTU_SHIFT;
-    }
+    tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_Frag)
+            - (p_FmPcd->physicalMuramBase));
+    tmpReg32 = (uint32_t)p_Manip->sizeForFragmentation
+            << FM_PCD_MANIP_CAPWAP_FRAG_CHECK_MTU_SHIFT;
 
     tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    tmpReg32  |= HMAN_OC_IP_MANIP;
+    tmpReg32 |= HMAN_OC_CAPWAP_FRAG_CHECK;
 
-#if (DPAA_VERSION >= 11)
-    tmpRegNia |= FM_PCD_MANIP_IP_CNIA;
-#endif /* (DPAA_VERSION >= 11) */
+    tmpRegNia |= FM_PCD_MANIP_CAPWAP_FRAG_CHECK_CNIA;
 
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
     WRITE_UINT32(p_Ad->ccAdBase, tmpRegNia);
-    WRITE_UINT32(p_Ad->gmask, 0); /* Total frame counter - MUST be initialized to zero.*/
+    WRITE_UINT32(p_Ad->gmask, 0);
+    /* Total frame counter - MUST be initialized to zero.*/
 
-    return err;
+    return E_OK;
 }
 
-static t_Error UpdateInitIpFrag(t_Handle       h_FmPcd,
-                                t_Handle       h_PcdParams,
-                                t_Handle       h_FmPort,
-                                t_FmPcdManip   *p_Manip,
-                                t_Handle       h_Ad,
-                                bool           validate)
+static t_Error UpdateInitCapwapFrag(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                                    t_Handle h_FmPort, t_FmPcdManip *p_Manip,
+                                    t_Handle h_Ad, bool validate)
 {
-    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
-    t_Error                     err;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_IP_FRAGMENTATION), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION),
+                              E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
 
@@ -3181,86 +4268,59 @@ static t_Error UpdateInitIpFrag(t_Handle       h_FmPcd,
     UNUSED(h_PcdParams);
     UNUSED(validate);
     UNUSED(p_Manip);
- 
+
     fmPortGetSetCcParams.setCcParams.type = 0;
     fmPortGetSetCcParams.getCcParams.type = MANIP_EXTRA_SPACE;
     if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
- 
+
     if (!fmPortGetSetCcParams.getCcParams.internalBufferOffset)
         DBG(WARNING, ("manipExtraSpace must be larger than '0'"));
- 
+
     return E_OK;
 }
 
-static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
-                          t_FmPcdManip          *p_Manip)
+static t_Error CapwapManip(t_FmPcdManipParams *p_ManipParams,
+                           t_FmPcdManip *p_Manip)
 {
-    t_AdOfTypeContLookup                    *p_Ad;
-    t_FmPcdManipSpecialOffloadIPSecParams   *p_IPSecParams;
-    t_Error                                 err = E_OK;
-    uint32_t                                tmpReg32 = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_INVALID_HANDLE);
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPcdManipSpecialOffloadCapwapParams *p_Params;
+    t_Error err = E_OK;
+    uint32_t tmpReg32 = 0;
 
-    p_IPSecParams = &p_ManipParams->u.specialOffload.u.ipsec;
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams, E_INVALID_HANDLE);
 
-    SANITY_CHECK_RETURN_ERROR(!p_IPSecParams->variableIpHdrLen ||
-                              p_IPSecParams->decryption, E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(!p_IPSecParams->variableIpVersion ||
-                              !p_IPSecParams->decryption, E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(!p_IPSecParams->variableIpVersion ||
-                              p_IPSecParams->outerIPHdrLen, E_INVALID_VALUE);
+    p_Params = &p_ManipParams->u.specialOffload.u.capwap;
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    tmpReg32 |= (p_IPSecParams->decryption)?FM_PCD_MANIP_IPSEC_DEC:0;
-    tmpReg32 |= (p_IPSecParams->ecnCopy)?FM_PCD_MANIP_IPSEC_ECN_EN:0;
-    tmpReg32 |= (p_IPSecParams->dscpCopy)?FM_PCD_MANIP_IPSEC_DSCP_EN:0;
-    tmpReg32 |= (p_IPSecParams->variableIpHdrLen)?FM_PCD_MANIP_IPSEC_VIPL_EN:0;
-    tmpReg32 |= (p_IPSecParams->variableIpVersion)?FM_PCD_MANIP_IPSEC_VIPV_EN:0;
+    tmpReg32 |= (p_Params->dtls) ? FM_PCD_MANIP_CAPWAP_DTLS : 0;
+    /* TODO - add 'qosSrc' */
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
-    tmpReg32 = HMAN_OC_IPSEC_MANIP;
-    tmpReg32 |= p_IPSecParams->outerIPHdrLen << FM_PCD_MANIP_IPSEC_IP_HDR_LEN_SHIFT;
+    tmpReg32 = HMAN_OC_CAPWAP_MANIP;
     if (p_ManipParams->h_NextManip)
     {
-        WRITE_UINT32(p_Ad->matchTblPtr,
-                    (uint32_t)(XX_VirtToPhys(((t_FmPcdManip *)p_ManipParams->h_NextManip)->h_Ad)-
-                               (((t_FmPcd *)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4);
+        WRITE_UINT32(
+                p_Ad->matchTblPtr,
+                (uint32_t)(XX_VirtToPhys(((t_FmPcdManip *)p_ManipParams->h_NextManip)->h_Ad)- (((t_FmPcd *)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4);
 
-        tmpReg32 |= FM_PCD_MANIP_IPSEC_NADEN;
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_NADEN;
     }
+
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
     return err;
 }
+#endif /* (DPAA_VERSION >= 11) */
 
-#ifdef FM_CAPWAP_SUPPORT
-static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsParams *p_StatsParams)
-{
-
-    switch (p_StatsParams->type)
-    {
-        case (e_FM_PCD_STATS_PER_FLOWID):
-            p_Manip->opcode = HMAN_OC_CAPWAP_INDEXED_STATS;
-            p_Manip->muramAllocate = TRUE;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported statistics type"));
-    }
-
-    return E_OK;
-}
-#endif /* FM_CAPWAP_SUPPORT */
-
-static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool stats)
+static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params,
+                                    bool stats)
 {
-    t_FmPcdManip                *p_Manip;
-    t_Error                     err;
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip *p_Manip;
+    t_Error err;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     p_Manip = (t_FmPcdManip*)XX_Malloc(sizeof(t_FmPcdManip));
     if (!p_Manip)
@@ -3271,20 +4331,22 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
     memset(p_Manip, 0, sizeof(t_FmPcdManip));
 
     p_Manip->type = ((t_FmPcdManipParams *)p_Params)->type;
-    memcpy((uint8_t*)&p_Manip->manipParams, p_Params, sizeof(p_Manip->manipParams));
+    memcpy((uint8_t*)&p_Manip->manipParams, p_Params,
+           sizeof(p_Manip->manipParams));
 
     if (!stats)
-        err = CheckManipParamsAndSetType(p_Manip, (t_FmPcdManipParams *)p_Params);
-#ifdef FM_CAPWAP_SUPPORT
+        err = CheckManipParamsAndSetType(p_Manip,
+                                         (t_FmPcdManipParams *)p_Params);
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     else
-        err = CheckStatsParamsAndSetType(p_Manip, (t_FmPcdStatsParams *)p_Params);
-#else
+    err = CheckStatsParamsAndSetType(p_Manip, (t_FmPcdStatsParams *)p_Params);
+#else /* not (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     else
     {
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Statistics node!"));
         return NULL;
     }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     if (err)
     {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("INVALID HEADER MANIPULATION TYPE"));
@@ -3293,37 +4355,38 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
         return NULL;
     }
 
-    if (p_Manip->opcode != HMAN_OC_IP_REASSEMBLY)
+    if ((p_Manip->opcode != HMAN_OC_IP_REASSEMBLY) && (p_Manip->opcode != HMAN_OC_CAPWAP_REASSEMBLY))
     {
-        /* In Case of IP reassembly manipulation the IPv4/IPv6 reassembly action descriptor will
-           be defines later on */
+        /* In Case of reassembly manipulation the reassembly action descriptor will
+         be defines later on */
         if (p_Manip->muramAllocate)
         {
-            p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                        FM_PCD_CC_AD_ENTRY_SIZE,
-                                                        FM_PCD_CC_AD_TABLE_ALIGN);
-             if (!p_Manip->h_Ad)
-             {
+            p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(
+                    p_FmPcd->h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE,
+                    FM_PCD_CC_AD_TABLE_ALIGN);
+            if (!p_Manip->h_Ad)
+            {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
                 XX_Free(p_Manip);
                 return NULL;
-             }
+            }
 
-            IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+            IOMemSet32(p_Manip->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
         }
         else
         {
-            p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-             if (!p_Manip->h_Ad)
-             {
+            p_Manip->h_Ad = (t_Handle)XX_Malloc(
+                    FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+            if (!p_Manip->h_Ad)
+            {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
                 XX_Free(p_Manip);
                 return NULL;
-             }
+            }
 
-            memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+            memset(p_Manip->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
         }
     }
 
@@ -3332,29 +4395,32 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
     return p_Manip;
 }
 
-static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_CrntMdfManip,
-                                                       t_List            *h_NodesLst)
+static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(
+        t_FmPcdManip *p_CrntMdfManip, t_List *h_NodesLst)
 {
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfManip = NULL;
-    t_List                  *p_Pos;
-    int                     i = 0;
-    t_Handle                p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
-    t_CcNodeInformation     ccNodeInfo;
+    t_CcNodeInformation *p_CcNodeInformation;
+    t_FmPcdCcNode *p_NodePtrOnCurrentMdfManip = NULL;
+    t_List *p_Pos;
+    int i = 0;
+    t_Handle p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
+    t_CcNodeInformation ccNodeInfo;
 
     LIST_FOR_EACH(p_Pos, &p_CrntMdfManip->nodesLst)
     {
         p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        p_NodePtrOnCurrentMdfManip = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
+        p_NodePtrOnCurrentMdfManip =
+                (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
 
         ASSERT_COND(p_NodePtrOnCurrentMdfManip);
 
         /* Search in the previous node which exact index points on this current modified node for getting AD */
         for (i = 0; i < p_NodePtrOnCurrentMdfManip->numOfKeys + 1; i++)
         {
-            if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
             {
-                if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip == (t_Handle)p_CrntMdfManip)
+                if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip
+                        == (t_Handle)p_CrntMdfManip)
                 {
                     if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj)
                         p_AdTablePtOnCrntCurrentMdfNode =
@@ -3374,36 +4440,35 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_Crnt
     }
 }
 
-static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd, t_FmPcd *p_FmPcd)
+static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd,
+                      t_FmPcd *p_FmPcd)
 {
     t_Error err;
 
-   /* Copy the HMTD */
+    /* Copy the HMTD */
     IO2IOCpy32(p_Dest, (uint8_t*)p_Src, 16);
     /* Replace the HMCT table pointer  */
-    WRITE_UINT32(((t_Hmtd *)p_Dest)->hmcdBasePtr,
-              (uint32_t)(XX_VirtToPhys(p_Hmcd) - ((t_FmPcd*)p_FmPcd)->physicalMuramBase));
+    WRITE_UINT32(
+            ((t_Hmtd *)p_Dest)->hmcdBasePtr,
+            (uint32_t)(XX_VirtToPhys(p_Hmcd) - ((t_FmPcd*)p_FmPcd)->physicalMuramBase));
     /* Call Host Command to replace HMTD by a new HMTD */
-    err = FmHcPcdCcDoDynamicChange(p_FmPcd->h_Hc,
-                                (uint32_t)(XX_VirtToPhys(p_Src) - p_FmPcd->physicalMuramBase),
-                                (uint32_t)(XX_VirtToPhys(p_Dest) - p_FmPcd->physicalMuramBase));
+    err = FmHcPcdCcDoDynamicChange(
+            p_FmPcd->h_Hc,
+            (uint32_t)(XX_VirtToPhys(p_Src) - p_FmPcd->physicalMuramBase),
+            (uint32_t)(XX_VirtToPhys(p_Dest) - p_FmPcd->physicalMuramBase));
     if (err)
         REPORT_ERROR(MINOR, err, ("Failed in dynamic manip change, continued to the rest of the owners."));
 }
 
-static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
-                                    t_Handle h_PcdParams,
-                                    t_Handle h_FmPort,
-                                    t_Handle h_Manip,
-                                    t_Handle h_Ad,
-                                    bool     validate,
-                                    int      level,
+static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                                    t_Handle h_FmPort, t_Handle h_Manip,
+                                    t_Handle h_Ad, bool validate, int level,
                                     t_Handle h_FmTree)
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Error      err = E_OK;
+    t_Error err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
 
     UNUSED(level);
     UNUSED(h_FmPcd);
@@ -3411,30 +4476,45 @@ static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
 
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
-            break;
-#ifdef FM_CAPWAP_SUPPORT
+        err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort,
+                p_Manip,
+                h_Ad,
+                validate);
+        break;
         case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if (!p_Manip->h_Frag)
-                break;
+        if (!p_Manip->h_Frag)
+        break;
         case (HMAN_OC_CAPWAP_FRAGMENTATION):
-            err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
-            break;
+        err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
+        break;
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if (p_Manip->h_Frag)
-                err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
-            break;
+        if (p_Manip->h_Frag)
+        err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
+        break;
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
-            break;
-#endif /* FM_CAPWAP_SUPPORT */
+        err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         case (HMAN_OC_IP_REASSEMBLY):
-            err = UpdateInitIpReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
+            err = UpdateInitReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad,
+                                  validate);
             break;
         case (HMAN_OC_IP_FRAGMENTATION):
-            err = UpdateInitIpFrag(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
+            err = UpdateInitIpFrag(h_FmPcd, h_PcdParams, h_FmPort, p_Manip,
+                                   h_Ad, validate);
+            break;
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+            err = UpdateInitCapwapFrag(h_FmPcd, h_PcdParams, h_FmPort, p_Manip,
+                                       h_Ad, validate);
+            break;
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            err = UpdateInitReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad,
+                                  validate);
             break;
+#endif /* (DPAA_VERSION >= 11) */
         default:
             return E_OK;
     }
@@ -3442,34 +4522,42 @@ static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
     return err;
 }
 
-static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree)
+static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad,
+                                      bool validate, int level,
+                                      t_Handle h_FmTree)
 {
 
-    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Error         err = E_OK;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error err = E_OK;
 
     UNUSED(level);
 
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("modify node with this type of manipulation  is not suppported"));
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
 
-           if (p_Manip->h_Frag)
-           {
-               if (!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
-                   !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
-                   !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation requires manipulation be updated previously in SetPcd function"));
-           }
-           break;
-#ifdef FM_CAPWAP_SUPPORT
+        if (p_Manip->h_Frag)
+        {
+            if (!(p_Manip->shadowUpdateParams & NUM_OF_TASKS)
+                    && !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)
+                    && !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_STATE,
+                    ("modify node with this type of manipulation requires manipulation be updated previously in SetPcd function"));
+        }
+        break;
         case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if (p_Manip->h_Frag)
-                err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
-            break;
-#endif /* FM_CAPWAP_SUPPORT */
+        if (p_Manip->h_Frag)
+        err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         default:
             return E_OK;
     }
@@ -3481,46 +4569,26 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
 
-t_Error FmPcdManipUpdate(t_Handle h_FmPcd,
-                         t_Handle h_PcdParams,
-                         t_Handle h_FmPort,
-                         t_Handle h_Manip,
-                         t_Handle h_Ad,
-                         bool     validate,
-                         int      level,
-                         t_Handle h_FmTree,
-                         bool    modify)
+t_Error FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                         t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad,
+                         bool validate, int level, t_Handle h_FmTree,
+                         bool modify)
 {
     t_Error err;
 
     if (!modify)
-        err = FmPcdManipInitUpdate(h_FmPcd, h_PcdParams, h_FmPort, h_Manip, h_Ad, validate, level, h_FmTree);
+        err = FmPcdManipInitUpdate(h_FmPcd, h_PcdParams, h_FmPort, h_Manip,
+                                   h_Ad, validate, level, h_FmTree);
     else
         err = FmPcdManipModifyUpdate(h_Manip, h_Ad, validate, level, h_FmTree);
 
     return err;
 }
 
-uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
-{
-    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
-
-    ASSERT_COND(h_Manip);
-
-    switch (p_Manip->opcode)
-    {
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            return UPDATE_NIA_ENQ_WITHOUT_DMA;
-        default:
-            return 0;
-    }
-}
-
 void FmPcdManipUpdateOwner(t_Handle h_Manip, bool add)
 {
 
-    uint32_t            intFlags;
+    uint32_t intFlags;
 
     intFlags = XX_LockIntrSpinlock(((t_FmPcdManip *)h_Manip)->h_Spinlock);
     if (add)
@@ -3542,19 +4610,22 @@ t_List *FmPcdManipGetNodeLstPointedOnThisManip(t_Handle h_Manip)
 t_List *FmPcdManipGetSpinlock(t_Handle h_Manip)
 {
     ASSERT_COND(h_Manip);
-   return ((t_FmPcdManip *)h_Manip)->h_Spinlock;
+    return ((t_FmPcdManip *)h_Manip)->h_Spinlock;
 }
 
-t_Error FmPcdManipCheckParamsForCcNextEngine(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, uint32_t *requiredAction)
+t_Error FmPcdManipCheckParamsForCcNextEngine(
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,
+        uint32_t *requiredAction)
 {
-    t_FmPcdManip             *p_Manip;
-    t_Error                   err;
-    bool                     pointFromCc = TRUE;
-
+    t_FmPcdManip *p_Manip;
+    t_Error err = E_OK;
+    bool pointFromCc = TRUE;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip,
+                              E_NULL_POINTER);
 
+    UNUSED(err);
     p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
     *requiredAction = 0;
 
@@ -3562,48 +4633,84 @@ t_Error FmPcdManipCheckParamsForCcNextEngine(t_FmPcdCcNextEngineParams *p_FmPcdC
     {
         switch (p_Manip->opcode)
         {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
             case (HMAN_OC_CAPWAP_INDEXED_STATS):
-                if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
-                if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
-                   p_Manip->cnia = TRUE;
+            if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_STATE,
+                    ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+            if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+            p_Manip->cnia = TRUE;
             case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-                *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
             case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
-                p_Manip->ownerTmp++;
-                break;
+            p_Manip->ownerTmp++;
+            break;
             case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) &&
-                    !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
-                p_Manip->ownerTmp++;
-                break;
+            if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                    && !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_STATE,
+                    ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
+            p_Manip->ownerTmp++;
+            break;
             case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
-                    (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
-                err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip, FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
-                if (err)
-                    RETURN_ERROR(MAJOR, err, NO_MSG);
-                *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
-                break;
+            if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)
+                    && (FmPcdCcGetParseCode(
+                                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
+                            != CC_PC_GENERIC_IC_HASH_INDEXED))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_STATE,
+                    ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
+            err =
+            UpdateManipIc(
+                    p_FmPcdCcNextEngineParams->h_Manip,
+                    FmPcdCcGetOffset(
+                            p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
+            if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+            break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
             case (HMAN_OC_IP_FRAGMENTATION):
             case (HMAN_OC_IP_REASSEMBLY):
+#if (DPAA_VERSION >= 11)
+            case (HMAN_OC_CAPWAP_REASSEMBLY):
+            case (HMAN_OC_CAPWAP_FRAGMENTATION):
+#endif /* (DPAA_VERSION >= 11) */
                 if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_STATE,
+                            ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
                 p_Manip->ownerTmp++;
                 break;
             case (HMAN_OC_IPSEC_MANIP):
+#if (DPAA_VERSION >= 11)
+            case (HMAN_OC_CAPWAP_MANIP):
+#endif /* (DPAA_VERSION >= 11) */
                 p_Manip->ownerTmp++;
                 break;
             case (HMAN_OC):
-                if (( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE_NEXT(p_Manip))
-                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't have a cascaded manipulation when and Next Engine is CC"));
+                if ((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC)
+                        && MANIP_IS_CASCADE_NEXT(p_Manip))
+                    RETURN_ERROR(
+                            MINOR,
+                            E_INVALID_STATE,
+                            ("Can't have a cascaded manipulation when and Next Engine is CC"));
                 if (!MANIP_IS_FIRST(p_Manip) && pointFromCc)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_Manip is already used and may not be shared (no sharing of non-head manip nodes)"));
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_STATE,
+                            ("h_Manip is already used and may not be shared (no sharing of non-head manip nodes)"));
                 break;
             default:
-                RETURN_ERROR(MAJOR, E_INVALID_STATE,("invalid type of header manipulation for this state"));
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_STATE,
+                        ("invalid type of header manipulation for this state"));
         }
         p_Manip = p_Manip->h_NextManip;
         pointFromCc = FALSE;
@@ -3612,30 +4719,39 @@ t_Error FmPcdManipCheckParamsForCcNextEngine(t_FmPcdCcNextEngineParams *p_FmPcdC
 }
 
 
-t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcdCcNode)
+t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip,
+                                              t_Handle h_FmPcdCcNode)
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Error         err = E_OK;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNode, E_INVALID_HANDLE);
 
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
-            break;
+        if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
+        break;
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if (p_Manip->h_Frag)
-            {
-                if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"));
-                err = UpdateManipIc(h_Manip, FmPcdCcGetOffset(h_FmPcdCcNode));
-                if (err)
-                    RETURN_ERROR(MAJOR, err, NO_MSG);
-            }
-            break;
+        if (p_Manip->h_Frag)
+        {
+            if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"));
+            err = UpdateManipIc(h_Manip, FmPcdCcGetOffset(h_FmPcdCcNode));
+            if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         default:
             break;
     }
@@ -3643,13 +4759,11 @@ t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcd
     return err;
 }
 
-void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
-                                   t_FmPcdCcNextEngineParams    *p_CcNextEngineParams,
-                                   t_Handle                     p_Ad,
-                                   t_Handle                     *p_AdNewPtr)
+void FmPcdManipUpdateAdResultForCc(
+        t_Handle h_Manip, t_FmPcdCcNextEngineParams *p_CcNextEngineParams,
+        t_Handle p_Ad, t_Handle *p_AdNewPtr)
 {
-    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
-
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
 
     /* This routine creates a Manip AD and can return in "p_AdNewPtr"
      * either the new descriptor or NULL if it writes the Manip AD into p_AD (into the match table) */
@@ -3665,22 +4779,42 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
      * p_Ad ( the AD in the match table) and set p_AdNew = NULL. */
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            *p_AdNewPtr = p_Manip->h_Ad;
-            break;
+        *p_AdNewPtr = p_Manip->h_Ad;
+        break;
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+        WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,
+                ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
+        WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,
+                ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
+        WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,
+                ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
+        *p_AdNewPtr = NULL;
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         case (HMAN_OC_IPSEC_MANIP):
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_MANIP):
+#endif /* (DPAA_VERSION >= 11) */
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
         case (HMAN_OC_IP_FRAGMENTATION):
-            if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_DONE) &&
-                (!p_CcNextEngineParams->params.enqueueParams.overrideFqid))
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+#endif /* (DPAA_VERSION >= 11) */
+            if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_DONE)
+                    && (!p_CcNextEngineParams->params.enqueueParams.overrideFqid))
             {
-                memcpy((uint8_t *)p_Ad, (uint8_t *)p_Manip->h_Ad, sizeof(t_AdOfTypeContLookup));
+                memcpy((uint8_t *)p_Ad, (uint8_t *)p_Manip->h_Ad,
+                       sizeof(t_AdOfTypeContLookup));
 #if (DPAA_VERSION >= 11)
-                WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,
-                             GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) & ~FM_PCD_MANIP_IP_CNIA);
+                WRITE_UINT32(
+                        ((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,
+                        GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) & ~FM_PCD_MANIP_IP_CNIA);
 #endif /* (DPAA_VERSION >= 11) */
                 *p_AdNewPtr = NULL;
             }
@@ -3690,30 +4824,32 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
         case (HMAN_OC_IP_REASSEMBLY):
             if (FmPcdManipIpReassmIsIpv6Hdr(p_Manip))
             {
-                if (!p_Manip->ipReassmParams.ipv6Assigned)
+                if (!p_Manip->reassmParams.ip.ipv6Assigned)
                 {
-                    *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv6Ad;
-                    p_Manip->ipReassmParams.ipv6Assigned = TRUE;
+                    *p_AdNewPtr = p_Manip->reassmParams.ip.h_Ipv6Ad;
+                    p_Manip->reassmParams.ip.ipv6Assigned = TRUE;
                     FmPcdManipUpdateOwner(h_Manip, FALSE);
                 }
                 else
                 {
-                    *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv4Ad;
-                    p_Manip->ipReassmParams.ipv6Assigned = FALSE;
+                    *p_AdNewPtr = p_Manip->reassmParams.ip.h_Ipv4Ad;
+                    p_Manip->reassmParams.ip.ipv6Assigned = FALSE;
                 }
             }
             else
-                *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv4Ad;
-            memcpy((uint8_t *)p_Ad, (uint8_t *)*p_AdNewPtr, sizeof(t_AdOfTypeContLookup));
+                *p_AdNewPtr = p_Manip->reassmParams.ip.h_Ipv4Ad;
+            memcpy((uint8_t *)p_Ad, (uint8_t *)*p_AdNewPtr,
+                   sizeof(t_AdOfTypeContLookup));
             *p_AdNewPtr = NULL;
             break;
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-        case (HMAN_OC_CAPWAP_FRAGMENTATION):
-            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
-            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
-            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            *p_AdNewPtr = p_Manip->reassmParams.capwap.h_Ad;
+            memcpy((uint8_t *)p_Ad, (uint8_t *)*p_AdNewPtr,
+                   sizeof(t_AdOfTypeContLookup));
             *p_AdNewPtr = NULL;
             break;
+#endif /* (DPAA_VERSION >= 11) */
         case (HMAN_OC):
             /* Allocate and initialize HMTD */
             *p_AdNewPtr = p_Manip->h_Ad;
@@ -3723,9 +4859,11 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
     }
 }
 
-void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNewPtr, uint32_t adTableOffset)
+void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad,
+                                       t_Handle *p_AdNewPtr,
+                                       uint32_t adTableOffset)
 {
-    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
 
     /* This routine creates a Manip AD and can return in "p_AdNewPtr"
      * either the new descriptor or NULL if it writes the Manip AD into p_AD (into the match table) */
@@ -3735,25 +4873,36 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
 
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,   ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,  ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->gmask,         ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->gmask);
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      (GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) | adTableOffset));
-            *p_AdNewPtr = NULL;
-            break;
-
+        WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,
+                ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
+        WRITE_UINT32(
+                ((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,
+                ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
+        WRITE_UINT32(
+                ((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,
+                ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
+        WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->gmask,
+                ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->gmask);
+        WRITE_UINT32(
+                ((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,
+                (GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) | adTableOffset));
+        *p_AdNewPtr = NULL;
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         case (HMAN_OC):
             /* Initialize HMTD within the match table*/
-            IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
-            /* copy the existing HMTD */ /* ask Alla - memcpy??? */
+            IOMemSet32(p_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+            /* copy the existing HMTD *//* ask Alla - memcpy??? */
             memcpy((uint8_t*)p_Ad, p_Manip->h_Ad, sizeof(t_Hmtd));
             /* update NADEN to be "1"*/
-            WRITE_UINT16(((t_Hmtd *)p_Ad)->cfg,
-                         (uint16_t)(GET_UINT16(((t_Hmtd *)p_Ad)->cfg) | HMTD_CFG_NEXT_AD_EN));
+            WRITE_UINT16(
+                    ((t_Hmtd *)p_Ad)->cfg,
+                    (uint16_t)(GET_UINT16(((t_Hmtd *)p_Ad)->cfg) | HMTD_CFG_NEXT_AD_EN));
             /* update next action descriptor */
-            WRITE_UINT16(((t_Hmtd *)p_Ad)->nextAdIdx, (uint16_t)(adTableOffset >> 4));
+            WRITE_UINT16(((t_Hmtd *)p_Ad)->nextAdIdx,
+                         (uint16_t)(adTableOffset >> 4));
             /* mark that Manip's HMTD is not used */
             *p_AdNewPtr = NULL;
             break;
@@ -3763,30 +4912,32 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
     }
 }
 
-t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint8_t groupId)
+t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv,
+                                      t_Handle h_CcTree, t_Handle h_Manip,
+                                      bool isIpv4, uint8_t groupId)
 {
-    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_FmPcdKgSchemeParams   *p_SchemeParams = NULL;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdKgSchemeParams *p_SchemeParams = NULL;
 
     ASSERT_COND(p_FmPcd);
     ASSERT_COND(h_NetEnv);
     ASSERT_COND(p_Manip);
 
     /* scheme was already build, no need to check for IPv6 */
-    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+    if (p_Manip->reassmParams.ip.h_Ipv4Scheme)
         return E_OK;
 
     p_SchemeParams = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
     if (!p_SchemeParams)
-       RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation failed for scheme"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Memory allocation failed for scheme"));
 
     /* Configures the IPv4 or IPv6 scheme*/
     memset(p_SchemeParams, 0, sizeof(t_FmPcdKgSchemeParams));
     p_SchemeParams->netEnvParams.h_NetEnv = h_NetEnv;
-    p_SchemeParams->id.relativeSchemeId =
-        (uint8_t)((isIpv4 == TRUE) ?
-                  p_Manip->ipReassmParams.relativeSchemeId[0] :
-                  p_Manip->ipReassmParams.relativeSchemeId[1]);
+    p_SchemeParams->id.relativeSchemeId = (uint8_t)(
+            (isIpv4 == TRUE) ? p_Manip->reassmParams.ip.relativeSchemeId[0] :
+                    p_Manip->reassmParams.ip.relativeSchemeId[1]);
     p_SchemeParams->schemeCounter.update = TRUE;
 #if (DPAA_VERSION >= 11)
     p_SchemeParams->alwaysDirect = TRUE;
@@ -3796,13 +4947,15 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Han
     p_SchemeParams->baseFqid = 0xFFFFFF; /*TODO- baseFqid*/
 #endif /* (DPAA_VERSION >= 11) */
 
-    setReassmSchemeParams(p_FmPcd, p_SchemeParams, h_CcTree, isIpv4, groupId);
+    setIpReassmSchemeParams(p_FmPcd, p_SchemeParams, h_CcTree, isIpv4, groupId);
 
     /* Sets the new scheme */
     if (isIpv4)
-        p_Manip->ipReassmParams.h_Ipv4Scheme = FM_PCD_KgSchemeSet(p_FmPcd, p_SchemeParams);
+        p_Manip->reassmParams.ip.h_Ipv4Scheme = FM_PCD_KgSchemeSet(
+                p_FmPcd, p_SchemeParams);
     else
-        p_Manip->ipReassmParams.h_Ipv6Scheme = FM_PCD_KgSchemeSet(p_FmPcd, p_SchemeParams);
+        p_Manip->reassmParams.ip.h_Ipv6Scheme = FM_PCD_KgSchemeSet(
+                p_FmPcd, p_SchemeParams);
 
     XX_Free(p_SchemeParams);
 
@@ -3811,29 +4964,78 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Han
 
 t_Error FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip)
 {
-    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
 
     ASSERT_COND(p_Manip);
 
-    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
-        FM_PCD_KgSchemeDelete(p_Manip->ipReassmParams.h_Ipv4Scheme);
+    if (p_Manip->reassmParams.ip.h_Ipv4Scheme)
+        FM_PCD_KgSchemeDelete(p_Manip->reassmParams.ip.h_Ipv4Scheme);
 
-    if (p_Manip->ipReassmParams.h_Ipv6Scheme)
-        FM_PCD_KgSchemeDelete(p_Manip->ipReassmParams.h_Ipv6Scheme);
+    if (p_Manip->reassmParams.ip.h_Ipv6Scheme)
+        FM_PCD_KgSchemeDelete(p_Manip->reassmParams.ip.h_Ipv6Scheme);
 
     return E_OK;
 }
 
 bool FmPcdManipIpReassmIsIpv6Hdr(t_Handle h_Manip)
 {
-    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+
+    return (p_Manip->reassmParams.hdr == HEADER_TYPE_IPv6);
+}
+
+t_Error FmPcdManipBuildCapwapReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv,
+                                          t_Handle h_CcTree, t_Handle h_Manip,
+                                          uint8_t groupId)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdKgSchemeParams *p_SchemeParams = NULL;
+
+    ASSERT_COND(p_FmPcd);
+    ASSERT_COND(h_NetEnv);
+    ASSERT_COND(p_Manip);
+
+    /* scheme was already build, no need to check for IPv6 */
+    if (p_Manip->reassmParams.capwap.h_Scheme)
+        return E_OK;
+
+    p_SchemeParams = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
+    if (!p_SchemeParams)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Memory allocation failed for scheme"));
+
+    memset(p_SchemeParams, 0, sizeof(t_FmPcdKgSchemeParams));
+    p_SchemeParams->netEnvParams.h_NetEnv = h_NetEnv;
+    p_SchemeParams->id.relativeSchemeId =
+            (uint8_t)p_Manip->reassmParams.capwap.relativeSchemeId;
+    p_SchemeParams->schemeCounter.update = TRUE;
+    p_SchemeParams->bypassFqidGeneration = TRUE;
+
+    setCapwapReassmSchemeParams(p_FmPcd, p_SchemeParams, h_CcTree, groupId);
+
+    p_Manip->reassmParams.capwap.h_Scheme = FM_PCD_KgSchemeSet(p_FmPcd,
+                                                               p_SchemeParams);
+
+    XX_Free(p_SchemeParams);
+
+    return E_OK;
+}
+
+t_Error FmPcdManipDeleteCapwapReassmSchemes(t_Handle h_Manip)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
 
     ASSERT_COND(p_Manip);
 
-    return (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6);
+    if (p_Manip->reassmParams.capwap.h_Scheme)
+        FM_PCD_KgSchemeDelete(p_Manip->reassmParams.capwap.h_Scheme);
+
+    return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 t_Handle FmPcdManipApplSpecificBuild(void)
 {
     t_FmPcdManip *p_Manip;
@@ -3850,18 +5052,18 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     p_Manip->muramAllocate = FALSE;
 
     p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-     if (!p_Manip->h_Ad)
-     {
+    if (!p_Manip->h_Ad)
+    {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
         XX_Free(p_Manip);
         return NULL;
-     }
+    }
 
-    memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    memset(p_Manip->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
 
     /*treatFdStatusFieldsAsErrors = TRUE hardcoded - assumption its always come after CAAM*/
     /*Application specific = type of flowId index, move internal frame header from data to IC,
-    SEC errors check*/
+     SEC errors check*/
     if (MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE)!= E_OK)
     {
         XX_Free(p_Manip->h_Ad);
@@ -3878,33 +5080,37 @@ bool FmPcdManipIsCapwapApplSpecific(t_Handle h_Manip)
 
     return (bool)((p_Manip->opcode == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST) ? TRUE : FALSE);
 }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 /*********************** End of inter-module routines ************************/
 
-
 /****************************************/
 /*       API Init unit functions        */
 /****************************************/
 
-t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams)
+t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd,
+                             t_FmPcdManipParams *p_ManipParams)
 {
-    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdManip    *p_Manip;
-    t_Error         err;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip *p_Manip;
+    t_Error err;
 
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
-    SANITY_CHECK_RETURN_VALUE(p_ManipParams,E_INVALID_HANDLE,NULL);
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_ManipParams, E_INVALID_HANDLE, NULL);
 
-    p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
+    p_Manip = ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
     if (!p_Manip)
         return NULL;
 
-    if (((p_Manip->opcode == HMAN_OC_IP_REASSEMBLY) ||
-         (p_Manip->opcode == HMAN_OC_IP_FRAGMENTATION) ||
-         (p_Manip->opcode == HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX) ||
-         (p_Manip->opcode == HMAN_OC) ||
-         (p_Manip->opcode == HMAN_OC_IPSEC_MANIP)) &&
-        (!FmPcdIsAdvancedOffloadSupported(p_FmPcd)))
+    if (((p_Manip->opcode == HMAN_OC_IP_REASSEMBLY)
+            || (p_Manip->opcode == HMAN_OC_IP_FRAGMENTATION)
+            || (p_Manip->opcode == HMAN_OC)
+            || (p_Manip->opcode == HMAN_OC_IPSEC_MANIP)
+#if (DPAA_VERSION >= 11)
+            || (p_Manip->opcode == HMAN_OC_CAPWAP_MANIP)
+            || (p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION)
+            || (p_Manip->opcode == HMAN_OC_CAPWAP_REASSEMBLY)
+#endif /* (DPAA_VERSION >= 11) */
+            ) && (!FmPcdIsAdvancedOffloadSupported(p_FmPcd)))
     {
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Advanced-offload must be enabled"));
         XX_Free(p_Manip);
@@ -3917,8 +5123,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
         ReleaseManipHandler(p_Manip, p_FmPcd);
         XX_Free(p_Manip);
         return NULL;
-    }
-    INIT_LIST(&p_Manip->nodesLst);
+    }INIT_LIST(&p_Manip->nodesLst);
 
     switch (p_Manip->opcode)
     {
@@ -3926,26 +5131,40 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
             /* IpReassembly */
             err = IpReassembly(&p_ManipParams->u.reassem, p_Manip);
             break;
-       case (HMAN_OC_IP_FRAGMENTATION):
+        case (HMAN_OC_IP_FRAGMENTATION):
             /* IpFragmentation */
-            err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip);
+            err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag, p_Manip);
             if (err)
                 break;
             err = IPManip(p_Manip);
             break;
-        case (HMAN_OC_IPSEC_MANIP) :
+        case (HMAN_OC_IPSEC_MANIP):
             err = IPSecManip(p_ManipParams, p_Manip);
             break;
-#ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            /* CapwapReassembly */
+            err = CapwapReassembly(&p_ManipParams->u.reassem, p_Manip);
+            break;
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+            /* CapwapFragmentation */
+            err = CapwapFragmentation(&p_ManipParams->u.frag.u.capwapFrag,
+                                      p_Manip);
+            break;
+        case (HMAN_OC_CAPWAP_MANIP):
+            err = CapwapManip(p_ManipParams, p_Manip);
+            break;
+#endif /* (DPAA_VERSION >= 11) */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+            case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
             /* HmanType1 */
             err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->u.hdr.rmvParams, p_Manip);
             break;
-        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+            case (HMAN_OC_CAPWAP_FRAGMENTATION):
             err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.u.capwapFragParams,
-                                      p_Manip,
-                                      p_FmPcd,
-                                      p_ManipParams->fragOrReasmParams.sgBpid);
+                    p_Manip,
+                    p_FmPcd,
+                    p_ManipParams->fragOrReasmParams.sgBpid);
             if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -3954,16 +5173,16 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
             if (p_Manip->insrt)
-                p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+            case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
             err = InsrtHdrByTempl(&p_ManipParams->u.hdr.insrtParams, p_Manip, p_FmPcd);
             break;
-        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            case (HMAN_OC_CAPWAP_REASSEMBLY):
             err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.u.capwapReasmParams,
-                                   p_Manip,
-                                   p_FmPcd,
-                                   p_ManipParams->fragOrReasmParams.sgBpid);
+                    p_Manip,
+                    p_FmPcd,
+                    p_ManipParams->fragOrReasmParams.sgBpid);
             if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -3972,21 +5191,21 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
             if (p_Manip->rmv)
-                p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+            case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             /*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
             err = CapwapRmvDtlsHdr(p_FmPcd, p_Manip);
             break;
-#endif /* FM_CAPWAP_SUPPORT */
-       case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             /*Application Specific type 1*/
             err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE);
             break;
-       case (HMAN_OC):
-           /* New Manip */
-           err = CreateManipActionNew(p_Manip, p_ManipParams);
-           break;
-       default:
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
+        case (HMAN_OC):
+            /* New Manip */
+            err = CreateManipActionNew(p_Manip, p_ManipParams);
+            break;
+        default:
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
             ReleaseManipHandler(p_Manip, p_FmPcd);
             XX_Free(p_Manip);
@@ -4014,27 +5233,31 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     return p_Manip;
 }
 
-t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipParams)
+t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip,
+                                t_FmPcdManipParams *p_ManipParams)
 {
-    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_Manip, *p_FirstManip;
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)(p_Manip->h_FmPcd);
-    t_Error                     err;
-    uint8_t                     *p_WholeHmct = NULL, *p_ShadowHmct = NULL, *p_Hmtd = NULL;
-    t_List                      lstOfNodeshichPointsOnCrntMdfManip, *p_Pos;
-    t_CcNodeInformation         *p_CcNodeInfo;
-    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_INVALID_HANDLE);
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip, *p_FirstManip;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)(p_Manip->h_FmPcd);
+    t_Error err;
+    uint8_t *p_WholeHmct = NULL, *p_ShadowHmct = NULL, *p_Hmtd = NULL;
+    t_List lstOfNodeshichPointsOnCrntMdfManip, *p_Pos;
+    t_CcNodeInformation *p_CcNodeInfo;
+    SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams, E_INVALID_HANDLE);
 
     INIT_LIST(&lstOfNodeshichPointsOnCrntMdfManip);
 
-    if ((p_ManipParams->type != e_FM_PCD_MANIP_HDR) ||
-        (p_Manip->type != e_FM_PCD_MANIP_HDR))
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("FM_PCD_ManipNodeReplace Functionality supported only for Header Manipulation."));
+    if ((p_ManipParams->type != e_FM_PCD_MANIP_HDR)
+            || (p_Manip->type != e_FM_PCD_MANIP_HDR))
+        RETURN_ERROR(
+                MINOR,
+                E_NOT_SUPPORTED,
+                ("FM_PCD_ManipNodeReplace Functionality supported only for Header Manipulation."));
 
     ASSERT_COND(p_Manip->opcode == HMAN_OC);
     ASSERT_COND(p_Manip->manipParams.h_NextManip == p_Manip->h_NextManip);
-    memcpy((uint8_t*)&p_Manip->manipParams, p_ManipParams, sizeof(p_Manip->manipParams));
+    memcpy((uint8_t*)&p_Manip->manipParams, p_ManipParams,
+           sizeof(p_Manip->manipParams));
     p_Manip->manipParams.h_NextManip = p_Manip->h_NextManip;
 
     /* The replacement of the HdrManip depends on the node type.*/
@@ -4076,20 +5299,24 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
 
     p_ShadowHmct = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow, 16);
 
-    p_FirstManip = (t_FmPcdManip*)GetManipInfo(p_Manip, e_MANIP_HANDLER_TABLE_OWNER);
+    p_FirstManip = (t_FmPcdManip*)GetManipInfo(p_Manip,
+                                               e_MANIP_HANDLER_TABLE_OWNER);
     ASSERT_COND(p_FirstManip);
 
     if (!LIST_IsEmpty(&p_FirstManip->nodesLst))
-        UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(p_FirstManip, &lstOfNodeshichPointsOnCrntMdfManip);
+        UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(
+                p_FirstManip, &lstOfNodeshichPointsOnCrntMdfManip);
 
     p_Hmtd = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMTD);
     ASSERT_COND(p_Hmtd);
-    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_ShadowHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
+    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_ShadowHmct,
+              ((t_FmPcd*)(p_Manip->h_FmPcd)));
 
     LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
-        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_ShadowHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
+        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode,
+                  p_ShadowHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
     }
 
     p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);
@@ -4105,15 +5332,16 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
 
     p_Hmtd = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMTD);
     ASSERT_COND(p_Hmtd);
-    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_WholeHmct,((t_FmPcd*)p_Manip->h_FmPcd));
+    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_WholeHmct,
+              ((t_FmPcd*)p_Manip->h_FmPcd));
 
     /* If LIST > 0, create a list of p_Ad's that point to the HMCT. Join also t_HMTD to this list.
      * For each p_Hmct (from list+fixed):
-     * call Host Command to replace HMTD by a new one */
-    LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
+     * call Host Command to replace HMTD by a new one */LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
-        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_WholeHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
+        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode,
+                  p_WholeHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
     }
 
 
@@ -4124,17 +5352,20 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
     /* unlock shadow */
     RELEASE_LOCK(p_FmPcd->shadowLock);
 
-   return E_OK;
+    return E_OK;
 }
 
 t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
 {
-    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_ManipNode;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_ManipNode;
 
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
 
     if (p_Manip->owner)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
 
     if (p_Manip->h_NextManip)
     {
@@ -4142,14 +5373,16 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
         FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
     }
 
-    if (p_Manip->p_Hmct && (MANIP_IS_UNIFIED_FIRST(p_Manip) || !MANIP_IS_UNIFIED(p_Manip)))
-        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_Hmct);
+    if (p_Manip->p_Hmct
+            && (MANIP_IS_UNIFIED_FIRST(p_Manip) || !MANIP_IS_UNIFIED(p_Manip)))
+        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram,
+                         p_Manip->p_Hmct);
 
     if (p_Manip->h_Spinlock)
-     {
-         XX_FreeSpinlock(p_Manip->h_Spinlock);
-         p_Manip->h_Spinlock = NULL;
-     }
+    {
+        XX_FreeSpinlock(p_Manip->h_Spinlock);
+        p_Manip->h_Spinlock = NULL;
+    }
 
     ReleaseManipHandler(p_Manip, p_Manip->h_FmPcd);
 
@@ -4158,9 +5391,10 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
     return E_OK;
 }
 
-t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmPcdManipStats)
+t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode,
+                                  t_FmPcdManipStats *p_FmPcdManipStats)
 {
-    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_ManipNode;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_ManipNode;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdManipStats, E_NULL_POINTER);
@@ -4168,51 +5402,59 @@ t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmP
     switch (p_Manip->opcode)
     {
         case (HMAN_OC_IP_REASSEMBLY):
-            return IpReassemblyStats(p_Manip, &p_FmPcdManipStats->u.reassem.u.ipReassem);
-       case (HMAN_OC_IP_FRAGMENTATION):
-            return IpFragmentationStats(p_Manip, &p_FmPcdManipStats->u.frag.u.ipFrag);
-       default:
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no statistics to this type of manip"));
+            return IpReassemblyStats(p_Manip,
+                                     &p_FmPcdManipStats->u.reassem.u.ipReassem);
+        case (HMAN_OC_IP_FRAGMENTATION):
+            return IpFragmentationStats(p_Manip,
+                                        &p_FmPcdManipStats->u.frag.u.ipFrag);
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            return CapwapReassemblyStats(
+                    p_Manip, &p_FmPcdManipStats->u.reassem.u.capwapReassem);
+#endif /* (DPAA_VERSION >= 11) */
+        default:
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                         ("no statistics to this type of manip"));
     }
 
     return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsParams)
 {
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdManip                *p_Manip;
-    t_Error                     err;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip *p_Manip;
+    t_Error err;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
     SANITY_CHECK_RETURN_VALUE(p_StatsParams,E_INVALID_HANDLE,NULL);
 
-    p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_StatsParams, TRUE);
+    p_Manip = ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_StatsParams, TRUE);
     if (!p_Manip)
-        return NULL;
+    return NULL;
 
-     switch (p_Manip->opcode)
-     {
+    switch (p_Manip->opcode)
+    {
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            /* Indexed statistics */
-            err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
-            break;
+        /* Indexed statistics */
+        err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
+        break;
         default:
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED Statistics type"));
-            ReleaseManipHandler(p_Manip, p_FmPcd);
-            XX_Free(p_Manip);
-            return NULL;
-     }
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED Statistics type"));
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        XX_Free(p_Manip);
+        return NULL;
+    }
 
-     if (err)
-     {
-         REPORT_ERROR(MAJOR, err, NO_MSG);
-         ReleaseManipHandler(p_Manip, p_FmPcd);
-         XX_Free(p_Manip);
-         return NULL;
-     }
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        XX_Free(p_Manip);
+        return NULL;
+    }
 
-     return p_Manip;
+    return p_Manip;
 }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
index f770c0f..2827578 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
@@ -52,19 +52,27 @@
 
 #define NUM_OF_SCRATCH_POOL_BUFFERS             1000 /*TODO - Change it!!*/
 
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 #define HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR                      0x2e
 #define HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER              0x31
+#define HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX     0x2f
+#define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
+#define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 /* dummy */
+#define HMAN_OC_CAPWAP_INDEXED_STATS                            0x32 /* dummy */
 #define HMAN_OC_CAPWAP_FRAGMENTATION                            0x33
+#else
+#define HMAN_OC_CAPWAP_MANIP                                    0x2F
+#define HMAN_OC_CAPWAP_FRAG_CHECK                               0x2E
+#define HMAN_OC_CAPWAP_FRAGMENTATION                            0x33
+#define HMAN_OC_CAPWAP_REASSEMBLY                               0x30
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 #define HMAN_OC_IP_MANIP                                        0x34
 #define HMAN_OC_IP_FRAGMENTATION                                0x74
 #define HMAN_OC_IP_REASSEMBLY                                   0xB4
 #define HMAN_OC_IPSEC_MANIP                                     0xF4
-#define HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX     0x2f
-#define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
-#define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 /* dummy */
-#define HMAN_OC_CAPWAP_INDEXED_STATS                            0x32 /* dummy */
 #define HMAN_OC                                                 0x35
 
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 #define HMAN_RMV_HDR                               0x80000000
 #define HMAN_INSRT_INT_FRM_HDR                     0x40000000
 
@@ -98,28 +106,44 @@
 #define FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE               4
 #define FM_PCD_MANIP_INDEXED_STATS_CNIA                     0x20000000
 #define FM_PCD_MANIP_INDEXED_STATS_DPD                      0x10000000
-
-#define FM_PCD_MANIP_IP_REASM_TABLE_SIZE                    0x40
-#define FM_PCD_MANIP_IP_REASM_TABLE_ALIGN                   8
-
-#define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE       64
-#define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN      8
-#define FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES       0x80000000
-#define FM_PCD_MANIP_IP_REASM_COUPLING_ENABLE               0x40000000
-#define FM_PCD_MANIP_IP_REASM_COUPLING_MASK                 0xFF000000
-#define FM_PCD_MANIP_IP_REASM_COUPLING_SHIFT                24
-#define FM_PCD_MANIP_IP_REASM_LIODN_MASK                    0x0000003F
-#define FM_PCD_MANIP_IP_REASM_LIODN_SHIFT                   56
-#define FM_PCD_MANIP_IP_REASM_ELIODN_MASK                   0x000003c0
-#define FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT                  38
-#define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_MASK    0x000000FF
-#define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_SHIFT   24
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
+
+#if (DPAA_VERSION >= 11)
+#define FM_PCD_MANIP_CAPWAP_DTLS                            0x00040000
+#define FM_PCD_MANIP_CAPWAP_NADEN                           0x20000000
+
+#define FM_PCD_MANIP_CAPWAP_FRAG_CHECK_MTU_SHIFT            16
+#define FM_PCD_MANIP_CAPWAP_FRAG_CHECK_NO_FRAGMENTATION     0xFFFF0000
+#define FM_PCD_MANIP_CAPWAP_FRAG_CHECK_CNIA                 0x20000000
+
+#define FM_PCD_MANIP_CAPWAP_FRAG_COMPRESS_EN                0x04000000
+#define FM_PCD_MANIP_CAPWAP_FRAG_SCRATCH_BPID               24
+#define FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_EN                 0x08000000
+#define FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_MASK               0xFF000000
+#define FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_SHIFT              24
+#endif /* (DPAA_VERSION >= 11) */
+
+#define FM_PCD_MANIP_REASM_TABLE_SIZE                    0x40
+#define FM_PCD_MANIP_REASM_TABLE_ALIGN                   8
+
+#define FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_SIZE       64
+#define FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_ALIGN      8
+#define FM_PCD_MANIP_REASM_TIME_OUT_BETWEEN_FRAMES       0x80000000
+#define FM_PCD_MANIP_REASM_COUPLING_ENABLE               0x40000000
+#define FM_PCD_MANIP_REASM_COUPLING_MASK                 0xFF000000
+#define FM_PCD_MANIP_REASM_COUPLING_SHIFT                24
+#define FM_PCD_MANIP_REASM_LIODN_MASK                    0x0000003F
+#define FM_PCD_MANIP_REASM_LIODN_SHIFT                   56
+#define FM_PCD_MANIP_REASM_ELIODN_MASK                   0x000003c0
+#define FM_PCD_MANIP_REASM_ELIODN_SHIFT                  38
+#define FM_PCD_MANIP_REASM_COMMON_INT_BUFFER_IDX_MASK    0x000000FF
+#define FM_PCD_MANIP_REASM_COMMON_INT_BUFFER_IDX_SHIFT   24
+#define FM_PCD_MANIP_REASM_TIMEOUT_THREAD_THRESH        1024
 
 #define FM_PCD_MANIP_IP_MTU_SHIFT                           16
 #define FM_PCD_MANIP_IP_NO_FRAGMENTATION                    0xFFFF0000
 #define FM_PCD_MANIP_IP_CNIA                                0x20000000
 
-#define FM_PCD_MANIP_IP_REASSM_TIMEOUT_THREAD_THRESH        1024
 #define FM_PCD_MANIP_IP_FRAG_DF_SHIFT                       28
 #define FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID                   24
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN                     0x08000000
@@ -149,6 +173,13 @@
 #define HMCD_OPCODE_TCP_UDP_UPDATE              0x0E
 #define HMCD_OPCODE_TCP_UDP_CHECKSUM            0x14
 #define HMCD_OPCODE_REPLACE_IP                  0x12
+#define HMCD_OPCODE_RMV_TILL                    0x15
+#define HMCD_OPCODE_UDP_INSRT                   0x16
+#define HMCD_OPCODE_IP_INSRT                    0x17
+#define HMCD_OPCODE_CAPWAP_RMV                  0x18
+#define HMCD_OPCODE_CAPWAP_INSRT                0x18
+
+#define HMCD_LAST                               0x00800000
 
 #define HMCD_DSCP_VALUES                        64
 
@@ -157,8 +188,17 @@
 #define HMCD_PARAM_SIZE                         4
 #define HMCD_IPV4_ADDR_SIZE                     4
 #define HMCD_IPV6_ADDR_SIZE                     0x10
+#define HMCD_L4_HDR_SIZE                        8
+
+#define HMCD_CAPWAP_INSRT                       0x00010000
+#define HMCD_INSRT_UDP_LITE                     0x00010000
+#define HMCD_IP_ID_MASK                         0x0000FFFF
+#define HMCD_IP_SIZE_MASK                       0x0000FF00
+#define HMCD_IP_SIZE_SHIFT                      8
+#define HMCD_IP_LAST_PID_MASK                   0x000000FF
+#define HMCD_IP_OR_QOS                          0x00010000
+#define HMCD_IP_L4_CS_CALC                      0x00040000
 
-#define HMCD_LAST                               0x00800000
 
 #define HMCD_OC_SHIFT                           24
 
@@ -271,6 +311,7 @@ typedef enum e_ManipInfo {
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 typedef _Packed struct t_CapwapReasmPram {
     volatile uint32_t mode;
     volatile uint32_t autoLearnHashTblPtr;
@@ -296,17 +337,18 @@ typedef _Packed struct t_CapwapReasmPram {
     volatile uint32_t externalBufferBusy;
     volatile uint32_t reserved1[4];
 } _PackedType t_CapwapReasmPram;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
-typedef _Packed struct t_IpReassTbl {
+typedef _Packed struct t_ReassTbl {
     volatile uint16_t waysNumAndSetSize;
     volatile uint16_t autoLearnHashKeyMask;
-    volatile uint32_t ipReassCommonPrmTblPtr;
+    volatile uint32_t reassCommonPrmTblPtr;
     volatile uint32_t liodnAlAndAutoLearnHashTblPtrHi;
     volatile uint32_t autoLearnHashTblPtrLow;
     volatile uint32_t liodnSlAndAutoLearnSetLockTblPtrHi;
     volatile uint32_t autoLearnSetLockTblPtrLow;
-    volatile uint16_t minFragSize;
-    volatile uint16_t reserved1;
+    volatile uint16_t minFragSize; /* Not relevant for CAPWAP*/
+    volatile uint16_t maxReassemblySize; /* Only relevant for CAPWAP*/
     volatile uint32_t totalSuccessfullyReasmFramesCounter;
     volatile uint32_t totalValidFragmentCounter;
     volatile uint32_t totalProcessedFragCounter;
@@ -315,9 +357,9 @@ typedef _Packed struct t_IpReassTbl {
     volatile uint32_t totalDiscardedFragsCounter;
     volatile uint32_t totalMoreThan16FramesCounter;
     volatile uint32_t reserved2[2];
-} _PackedType t_IpReassTbl;
+} _PackedType t_ReassTbl;
 
-typedef _Packed struct t_IpReassCommonTbl {
+typedef _Packed struct t_ReassCommonTbl {
     volatile uint32_t timeoutModeAndFqid;
     volatile uint32_t reassFrmDescIndexPoolTblPtr;
     volatile uint32_t liodnAndReassFrmDescPoolPtrHi;
@@ -334,7 +376,7 @@ typedef _Packed struct t_IpReassCommonTbl {
     volatile uint32_t totalDmaSemaphoreDepletionCounter;
     volatile uint32_t totalNCSPCounter;
     volatile uint32_t discardMask;
-} _PackedType t_IpReassCommonTbl;
+} _PackedType t_ReassCommonTbl;
 
 typedef _Packed struct t_Hmtd {
     volatile uint16_t   cfg;
@@ -355,6 +397,7 @@ typedef _Packed struct t_Hmtd {
 /***********************************************************************/
 /*  Driver's internal structures                                       */
 /***********************************************************************/
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 typedef struct
 {
     t_Handle p_AutoLearnHashTbl;
@@ -371,7 +414,8 @@ typedef struct
     uint32_t fqidForTimeOutFrames;
     uint32_t timeoutRoutineRequestTime;
     uint32_t bitFor1Micro;
-} t_FragParams;
+} t_CapwapFragParams;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
 typedef struct
 {
@@ -379,21 +423,12 @@ typedef struct
 #if (DPAA_VERSION == 10)
     uint8_t                 scratchBpid;
 #endif /* (DPAA_VERSION == 10) */
-} t_IpFragParams;
+} t_FragParams;
 
-typedef struct t_IpReassmParams
+typedef struct t_ReassmParams
 {
-    t_Handle                        h_Ipv4Ad;
-    t_Handle                        h_Ipv6Ad;
-    bool                            ipv6Assigned;
     e_NetHeaderType                 hdr; /* Header selection */
-    t_IpReassCommonTbl              *p_IpReassCommonTbl;
-    t_IpReassTbl                    *p_Ipv4ReassTbl;
-    t_IpReassTbl                    *p_Ipv6ReassTbl;
-    uintptr_t                       ipv4AutoLearnHashTblAddr;
-    uintptr_t                       ipv6AutoLearnHashTblAddr;
-    uintptr_t                       ipv4AutoLearnSetLockTblAddr;
-    uintptr_t                       ipv6AutoLearnSetLockTblAddr;
+    t_ReassCommonTbl              	*p_ReassCommonTbl;
     uintptr_t                       reassFrmDescrIndxPoolTblAddr;
     uintptr_t                       reassFrmDescrPoolTblAddr;
     uintptr_t                       timeOutTblAddr;
@@ -406,14 +441,36 @@ typedef struct t_IpReassmParams
     uint32_t                        fqidForTimeOutFrames;
     e_FmPcdManipReassemTimeOutMode  timeOutMode;
     uint32_t                        timeoutThresholdForReassmProcess;
-    uint16_t                        minFragSize[2];
-    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
-    uint8_t                         relativeSchemeId[2];
-    t_Handle                        h_Ipv4Scheme;
-    t_Handle                        h_Ipv6Scheme;
-    uint32_t                        nonConsistentSpFqid;
-} t_IpReassmParams;
-
+    union {
+	struct {
+		t_Handle                h_Ipv4Ad;
+	    t_Handle                h_Ipv6Ad;
+	    bool                    ipv6Assigned;
+	    t_ReassTbl				*p_Ipv4ReassTbl;
+	    t_ReassTbl              *p_Ipv6ReassTbl;
+	    uintptr_t               ipv4AutoLearnHashTblAddr;
+	    uintptr_t               ipv6AutoLearnHashTblAddr;
+	    uintptr_t               ipv4AutoLearnSetLockTblAddr;
+	    uintptr_t               ipv6AutoLearnSetLockTblAddr;
+	    uint16_t                        minFragSize[2];
+	    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
+	    uint8_t                         relativeSchemeId[2];
+	    t_Handle                        h_Ipv4Scheme;
+	    t_Handle                        h_Ipv6Scheme;
+	    uint32_t                        nonConsistentSpFqid;
+	} ip;
+	struct {
+		t_Handle                h_Ad;
+	    t_ReassTbl				*p_ReassTbl;
+	    uintptr_t               autoLearnHashTblAddr;
+	    uintptr_t               autoLearnSetLockTblAddr;
+	    uint16_t                maxRessembledsSize;
+	    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
+	    uint8_t                 relativeSchemeId;
+	    t_Handle                h_Scheme;
+	} capwap;
+    };
+} t_ReassmParams;
 
 typedef struct{
     e_FmPcdManipType        type;
@@ -437,17 +494,19 @@ typedef struct{
     e_ManipUnifiedPosition  unifiedPosition;
     /* end HdrManip */
     uint8_t                 *p_Template;
-    t_Handle                h_Frag;
-    bool                    frag;
-    bool                    reassm;
-    uint16_t                sizeForFragmentation;
     uint8_t                 owner;
     uint32_t                updateParams;
     uint32_t                shadowUpdateParams;
-    t_FragParams            fragParams;
+    bool                    frag;
+    bool                    reassm;
+    uint16_t                sizeForFragmentation;
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+    t_Handle                h_Frag;
+    t_CapwapFragParams      capwapFragParams;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     union {
-        t_IpReassmParams    ipReassmParams;
-        t_IpFragParams      ipFragParams;
+        t_ReassmParams    	reassmParams;
+        t_FragParams      	fragParams;
     };
     uint8_t                 icOffset;
     uint16_t                ownerTmp;
@@ -456,7 +515,6 @@ typedef struct{
     t_Handle                h_FmPcd;
     t_List                  nodesLst;
     t_Handle                h_Spinlock;
-
 } t_FmPcdManip;
 
 typedef struct t_FmPcdCcSavedManipParams
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
index ae87a36..379e984 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
@@ -561,20 +561,20 @@ uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType
     return FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS;
 }
 
-t_Error FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
+t_Error FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_ReasmCommonPramTbl)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcIpReassmTimeoutParams  ccIpReassmTimeoutParams = {0};
+    t_FmPcdCcReassmTimeoutParams    ccReassmTimeoutParams = {0};
     uint8_t                         result;
     t_Error                         err = E_OK;
 
     ASSERT_COND(p_FmPcd);
-    ASSERT_COND(h_IpReasmCommonPramTbl);
+    ASSERT_COND(h_ReasmCommonPramTbl);
 
-    ccIpReassmTimeoutParams.iprcpt   = (uint32_t)(XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
-    ccIpReassmTimeoutParams.activate = FALSE; /*Disable Timeout Task*/
+    ccReassmTimeoutParams.iprcpt   = (uint32_t)(XX_VirtToPhys(h_ReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccReassmTimeoutParams.activate = FALSE; /*Disable Timeout Task*/
 
-    if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
+    if ((err = FmHcPcdCcTimeoutReassm(p_FmPcd->h_Hc, &ccReassmTimeoutParams, &result)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     switch (result)
@@ -997,6 +997,15 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     }
     IOMemSet32(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr), 0,  4);
 
+    /* CAPWAP Frame-Id used for fragmentation */
+    p_FmPcd->capwapFrameIdAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, 2, 4));
+    if (!p_FmPcd->capwapFrameIdAddr)
+    {
+        FM_PCD_Free(p_FmPcd);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CAPWAP Frame-Id"));
+    }
+    IOMemSet32(UINT_TO_PTR(p_FmPcd->capwapFrameIdAddr), 0,  2);
+
     XX_Free(p_FmPcd->p_FmPcdDriverParam);
     p_FmPcd->p_FmPcdDriverParam = NULL;
 
@@ -1013,6 +1022,9 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     if (p_FmPcd->ipv6FrameIdAddr)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr));
 
+    if (p_FmPcd->capwapFrameIdAddr)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_FmPcd->capwapFrameIdAddr));
+
     if (p_FmPcd->enabled)
         FM_PCD_Disable(p_FmPcd);
 
@@ -1351,17 +1363,16 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM1;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
             }
-#ifdef FM_CAPWAP_SUPPORT
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
             /* UDP_LITE  */
             if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_LITE)
             {
-                /* IPSec UDP encapsulation is currently set to use SHIM1 */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_UDP_LITE;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_UDP;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_UDP;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
             }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
 
             /* IP FRAG  */
             if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
@@ -1369,7 +1380,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             {
                 /* If IPv4+Frag, we need to set 2 units - SHIM 2 and IPv4. We first set SHIM2, and than check if
                  * IPv4 exists. If so we don't need to set an extra unit
-                 * We consider as "having IPv4" any IPv4 without interchangeable headers
+                 * We consider as "having IPv4" any IPv4 without interchangable headers
                  * but including any options.  */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv4;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV4_FRAG_1;
@@ -1389,7 +1400,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             {
                 /* If IPv6+Frag, we need to set 2 units - SHIM 2 and IPv6. We first set SHIM2, and than check if
                  * IPv4 exists. If so we don't need to set an extra unit
-                 * We consider as "having IPv6" any IPv6 without interchangeable headers
+                 * We consider as "having IPv6" any IPv6 without interchangable headers
                  * but including any options.  */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv6;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV6_FRAG_1;
@@ -1404,6 +1415,18 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
                 }
             }
+#if (DPAA_VERSION >= 11)
+            /* CAPWAP FRAG  */
+            if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_CAPWAP) &&
+                (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == CAPWAP_FRAG_1))
+            {
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_CAPWAP;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = CAPWAP_FRAG_1;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
+            }
+#endif /* (DPAA_VERSION >= 11) */
         }
     }
 
@@ -1541,7 +1564,7 @@ t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd)
         DBG(WARNING, ("FM in guest-mode without IPC, can't validate firmware revision."));
         revInfo.packageRev = IP_OFFLOAD_PACKAGE_NUMBER;
     }
-    if (revInfo.packageRev != IP_OFFLOAD_PACKAGE_NUMBER)
+    if (!IS_OFFLOAD_PACKAGE(revInfo.packageRev))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Fman ctrl code package"));
 
     if (!p_FmPcd->h_Hc)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
index ca0fb81..138145f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
@@ -371,6 +371,7 @@ typedef struct {
     t_FmPcdIdExceptionCallback  *f_FmPcdIndexedException;
     t_Handle                    h_App;
     uintptr_t                   ipv6FrameIdAddr;
+    uintptr_t                   capwapFrameIdAddr;
     bool                        advancedOffloadSupport;
 
     t_FmPcdDriverParam          *p_FmPcdDriverParam;
@@ -396,6 +397,8 @@ uint8_t     FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeader
 
 t_Error     FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint8_t groupId);
 t_Error     FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip);
+t_Error     FmPcdManipBuildCapwapReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, uint8_t groupId);
+t_Error     FmPcdManipDeleteCapwapReassmSchemes(t_Handle h_Manip);
 bool        FmPcdManipIpReassmIsIpv6Hdr(t_Handle h_Manip);
 
 t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c
index 1666865..73f3b223 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c
@@ -125,10 +125,10 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     uint32_t            *p_LoadTarget = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode,
                                                              FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
     struct fman_prs_regs *PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
-#ifdef FM_CAPWAP_SUPPORT
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
     uint8_t             swPrsPatch[] = SW_PRS_UDP_LITE_PATCH;
 #else
-    uint8_t             swPrsPatch[] = SW_PRS_IP_FRAG_PATCH;
+    uint8_t             swPrsPatch[] = SW_PRS_OFFLOAD_PATCH;
 #endif /* FM_CAPWAP_SUPPORT */
     uint32_t            i;
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.h
index 3e5974c5..5afad31 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.h
@@ -35,30 +35,59 @@
  @File          fm_prs.h
 
  @Description   FM Parser private header
-*//***************************************************************************/
+ *//***************************************************************************/
 #ifndef __FM_PRS_H
 #define __FM_PRS_H
 
 #include "std_ext.h"
 
-
 /***********************************************************************/
 /*          SW parser IP_FRAG patch                                    */
 /***********************************************************************/
 
-
-#ifdef FM_CAPWAP_SUPPORT
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
 #define SW_PRS_UDP_LITE_PATCH   \
 {\
-    0x31,0x92,0x50,0x29,0x00,0x88,0x08,0x16,0x00,0x00, \
-    0x00,0x01,0x00,0x05,0x00,0x81,0x1C,0x0B,0x00,0x01, \
-    0x1B,0xFF,                                    \
+        0x31,0x52,0x00,0xDA,0xFC,0x00,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x50,0x2C,0x40,0x00,0x31,0x92,0x50,0x2C, \
+        0x00,0x88,0x18,0x2F,0x00,0x01,0x1B,0xFE,0x18,0x71, \
+        0x02,0x1F,0x00,0x08,0x00,0x83,0x02,0x1F,0x00,0x20, \
+        0x28,0x1B,0x00,0x05,0x29,0x1F,0x30,0xD0,0x60,0x4F, \
+        0x00,0x07,0x00,0x05,0x00,0x00,0xC3,0x8F,0x00,0x52, \
+        0x00,0x01,0x07,0x01,0x60,0x3B,0x00,0x00,0x30,0xD0, \
+        0x00,0xDA,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00, \
+        0x40,0x4C,0x00,0x00,0x02,0x8F,0x00,0x00,0x30,0xF2, \
+        0x00,0x06,0x18,0x5D,0x00,0x00,0x9F,0xFF,0x30,0xF2, \
+        0x00,0x06,0x29,0x1E,0x07,0x08,0x30,0xD0,0x00,0x52, \
+        0x00,0x08,0x28,0x1A,0x60,0x37,0x00,0x00,0x30,0xF2, \
+        0x18,0x5D,0x06,0x00,0x29,0x1E,0x30,0xF2,0x2F,0x0E, \
+        0x30,0x72,0x00,0x00,0x9B,0x8F,0x00,0x06,0x2F,0x0E, \
+        0x32,0xF1,0x32,0xB0,0x00,0x4F,0x00,0x57,0x00,0x28, \
+        0x00,0x00,0x97,0x9E,0x00,0x4E,0x30,0x72,0x00,0x06, \
+        0x2F,0x0E,0x32,0xC1,0x32,0xF0,0x00,0x4A,0x00,0x80, \
+        0x00,0x02,0x00,0x00,0x97,0x9E,0x40,0x7E,0x00,0x08, \
+        0x08,0x16,0x00,0x54,0x00,0x01,0x1B,0xFE,0x00,0x00, \
+        0x9F,0x9E,0x40,0xB3,0x00,0x00,0x02,0x1F,0x00,0x08, \
+        0x28,0x1B,0x30,0x73,0x29,0x1F,0x30,0xD0,0x60,0x9F, \
+        0x00,0x07,0x00,0x05,0x00,0x00,0xC3,0x8F,0x00,0x52, \
+        0x00,0x01,0x07,0x01,0x60,0x8B,0x00,0x00,0x30,0xD0, \
+        0x00,0xDA,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00, \
+        0x40,0x9C,0x00,0x00,0x02,0x8F,0x00,0x00,0x30,0xF2, \
+        0x00,0x06,0x18,0xAD,0x00,0x00,0x9F,0xFF,0x30,0xF2, \
+        0x00,0x06,0x29,0x1E,0x07,0x08,0x30,0xD0,0x00,0x52, \
+        0x00,0x08,0x28,0x1A,0x60,0x87,0x00,0x00,0x30,0xF2, \
+        0x18,0xAD,0x06,0x00,0x29,0x1E,0x30,0xF2,0x50,0xB3, \
+        0xFF,0xFF,0x18,0xB8,0x08,0x16,0x00,0x54,0x00,0x01, \
+        0x1B,0xFE,0x18,0xC5,0x32,0xF1,0x28,0x5D,0x32,0xF1, \
+        0x00,0x55,0x00,0x08,0x28,0x5F,0x00,0x00,0x8F,0x9F, \
+        0x29,0x33,0x08,0x16,0x00,0x49,0x00,0x01,0x1B,0xFF, \
+        0x00,0x01,0x1B,0xFF    \
 }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
 
 #if (DPAA_VERSION == 10)
 /* Version: 106.1.9 */
-#define SW_PRS_IP_FRAG_PATCH                           \
+#define SW_PRS_OFFLOAD_PATCH                           \
 {                                                      \
     0x31,0x52,0x00,0xDA,0x0A,0x00,0x00,0x00,0x00,0x00, \
     0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
@@ -106,63 +135,114 @@
 
 #else
 /* version: 106.3.13 */
-#define SW_PRS_IP_FRAG_PATCH                           \
+#define SW_PRS_OFFLOAD_PATCH                           \
 {                                                      \
     0x31,0x52,0x00,0xDA,0x0E,0x4F,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x52,0xF6,0x08,0x4B,0x31,0x53,0x00,0xFB, \
+    0x00,0x00,0x51,0xF6,0x08,0x4B,0x31,0x53,0x00,0xFB, \
     0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x2B, \
     0x33,0xF1,0x00,0xFB,0x00,0xDF,0x00,0x00,0x00,0x00, \
     0x00,0x00,0x28,0x7F,0x31,0x52,0x00,0xDA,0x0A,0x00, \
-    0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x00,0x00,0x00, \
-    0x00,0x01,0x1B,0xFE,0x00,0x00,0x99,0x00,0x53,0x09, \
-    0x00,0x00,0x00,0x00,0x9F,0x98,0x53,0x09,0x00,0x00, \
-    0x1B,0x24,0x09,0x5F,0x00,0x20,0x00,0x00,0x09,0x4F, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x00,0x00,0x00, \
+    0x00,0x01,0x1B,0xFE,0x00,0x00,0x99,0x00,0x52,0x09, \
+    0x00,0x00,0x00,0x00,0x9F,0x98,0x52,0x09,0x00,0x00, \
+    0x1A,0x24,0x09,0x5F,0x00,0x20,0x00,0x00,0x09,0x4F, \
     0x00,0x20,0x00,0x00,0x34,0xB7,0x00,0xF9,0x00,0x00, \
     0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97,0x31,0xB3, \
     0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01,0x00,0x00, \
     0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03,0x00,0x02, \
     0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x0E,0x4F,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x53,0x3C,0x04,0x4B,0x31,0x53,0x00,0xFB, \
-    0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x2B, \
-    0x33,0xF1,0x00,0xFB,0x00,0xDF,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x28,0x7F,0x31,0x52,0x00,0xDA,0x06,0x00, \
-    0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x46,0x00,0x00, \
-    0x00,0x01,0x1B,0xFE,0x31,0x52,0x00,0xDA,0x00,0x40, \
-    0x00,0x00,0x00,0x00,0x00,0x00,0x53,0xAC,0x00,0x00, \
-    0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x5C,0x00,0x00, \
-    0x30,0x7E,0x43,0x5C,0x00,0x3C,0x1B,0x74,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F, \
-    0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x1B,0x55,0x30,0x7E,0x53,0x90, \
-    0x00,0x2B,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81, \
-    0x00,0x00,0x87,0x8F,0x28,0x23,0x06,0x00,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
-    0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
-    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
-    0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0xA7,0x00,0x00, \
-    0x06,0x29,0x00,0x00,0x83,0x8F,0x28,0x23,0x06,0x00, \
-    0x06,0x29,0x32,0xC1,0x00,0x55,0x00,0x28,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x1B,0xF1,0x00,0x00, \
-    0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x43,0x30,0x7E,0x43,0xD6,0x00,0x2C,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x87,0x8F, \
-    0x28,0x23,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
+    0x31,0x52,0x00,0xDA,0xFC,0x00,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x52,0x32,0x40,0x00,0x31,0x92,0x52,0x32, \
+    0x00,0x88,0x1A,0x35,0x08,0x05,0x00,0x00,0x1A,0x79, \
+    0x02,0x1F,0x00,0x08,0x00,0x83,0x02,0x1F,0x00,0x20, \
+    0x28,0x1B,0x00,0x05,0x29,0x1F,0x30,0xD0,0x62,0x55, \
+    0x00,0x07,0x00,0x05,0x00,0x00,0xC3,0x8F,0x00,0x52, \
+    0x00,0x01,0x07,0x01,0x62,0x41,0x00,0x00,0x30,0xD0, \
+    0x00,0xDA,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x42,0x52,0x00,0x00,0x02,0x8F,0x00,0x00,0x30,0xF2, \
+    0x00,0x06,0x1A,0x63,0x00,0x00,0x9F,0xFF,0x30,0xF2, \
+    0x00,0x06,0x29,0x1E,0x07,0x08,0x30,0xD0,0x00,0x52, \
+    0x00,0x08,0x28,0x1A,0x62,0x3D,0x00,0x00,0x30,0xF2, \
+    0x1A,0x63,0x06,0x00,0x29,0x1E,0x30,0xF2,0x29,0x0E, \
+    0x30,0x72,0x00,0x00,0x9B,0x8F,0x00,0x06,0x29,0x0E, \
+    0x32,0xF1,0x32,0xB0,0x00,0x4F,0x00,0x57,0x00,0x28, \
+    0x00,0x00,0x97,0x9E,0x00,0x4E,0x30,0x72,0x00,0x06, \
+    0x29,0x0E,0x08,0x05,0x00,0x01,0x31,0x52,0x00,0xDA, \
+    0x0E,0x4F,0x00,0x00,0x00,0x00,0x00,0x00,0x52,0x8F, \
+    0x04,0x4B,0x31,0x53,0x00,0xFB,0xFF,0xF0,0x00,0x00, \
+    0x00,0x00,0x00,0x00,0x29,0x2B,0x33,0xF1,0x00,0xFB, \
+    0x00,0xDF,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F, \
+    0x31,0x52,0x00,0xDA,0x06,0x00,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x42,0x99,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x31,0x52,0x00,0xDA,0x00,0x40,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x52,0xFD,0x00,0x00,0x00,0x00,0x9B,0x8F, \
+    0x28,0x01,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43, \
+    0x30,0x00,0x42,0xAF,0x00,0x00,0x30,0x00,0x42,0xAF, \
+    0x00,0x3C,0x1A,0xC7,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x81,0x00,0x00,0x83,0x8F,0x28,0x01,0x06,0x00, \
     0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
     0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
     0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
-    0x1B,0xB3,0x09,0x5F,0x00,0x20,0x00,0x00,0x09,0x4F, \
-    0x00,0x20,0x00,0x00,0x34,0xB7,0x00,0xF9,0x00,0x00, \
-    0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97,0x31,0xB3, \
-    0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01,0x00,0x00, \
-    0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03,0x00,0x02, \
-    0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01,0x1B,0xFE, \
+    0x1A,0xA8,0x30,0x00,0x42,0xE5,0x00,0x2B,0x00,0x00, \
+    0x9B,0x8E,0x42,0xD3,0x00,0x00,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x43,0x1A,0xE4,0x06,0x29,0x00,0x00, \
+    0x83,0x8F,0x28,0x23,0x06,0x00,0x06,0x29,0x32,0xC1, \
+    0x00,0x55,0x00,0x28,0x00,0x00,0x83,0x8E,0x00,0x50, \
+    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
+    0x1A,0xFC,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81, \
+    0x00,0x00,0x87,0x8F,0x28,0x23,0x06,0x00,0x32,0x11, \
+    0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
+    0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x42, \
+    0x00,0x00,0x9B,0x8F,0x28,0x01,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x43,0x30,0x00,0x43,0x27,0x00,0x2C, \
+    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
+    0x87,0x8F,0x28,0x23,0x06,0x00,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x28,0x01, \
+    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x1B,0x04,0x09,0x5F,0x00,0x20,0x00,0x00, \
+    0x09,0x4F,0x00,0x20,0x00,0x00,0x34,0xB7,0x00,0xF9, \
+    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97, \
+    0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03, \
+    0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE,0x32,0xF1, \
+    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x02,0x30,0x50, \
+    0x53,0x99,0x00,0x01,0x00,0x00,0x97,0x9E,0x43,0x52, \
+    0x00,0x08,0x08,0x16,0x00,0x54,0x00,0x01,0x1B,0xFE, \
+    0x00,0x00,0x9F,0x9E,0x43,0x87,0x00,0x00,0x02,0x1F, \
+    0x00,0x08,0x28,0x1B,0x30,0x73,0x29,0x1F,0x30,0xD0, \
+    0x63,0x73,0x00,0x07,0x00,0x05,0x00,0x00,0xC3,0x8F, \
+    0x00,0x52,0x00,0x01,0x07,0x01,0x63,0x5F,0x00,0x00, \
+    0x30,0xD0,0x00,0xDA,0x00,0x01,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x70,0x00,0x00,0x02,0x8F,0x00,0x00, \
+    0x30,0xF2,0x00,0x06,0x1B,0x81,0x00,0x00,0x9F,0xFF, \
+    0x30,0xF2,0x00,0x06,0x29,0x1E,0x07,0x08,0x30,0xD0, \
+    0x00,0x52,0x00,0x08,0x28,0x1A,0x63,0x5B,0x00,0x00, \
+    0x30,0xF2,0x1B,0x81,0x06,0x00,0x29,0x1E,0x30,0xF2, \
+    0x53,0x87,0xFF,0xFF,0x1B,0x8C,0x08,0x16,0x00,0x54, \
+    0x00,0x01,0x1B,0xFE,0x1B,0x99,0x32,0xF1,0x28,0x5D, \
+    0x32,0xF1,0x00,0x55,0x00,0x08,0x28,0x5F,0x00,0x00, \
+    0x8F,0x9F,0x29,0x33,0x08,0x16,0x00,0x49,0x00,0x01, \
+    0x1B,0xFF,0x00,0x01,0x1B,0xFF,0x08,0x07,0x00,0x02, \
+    0x00,0x00,0x8D,0x80,0x53,0xA5,0x00,0x01,0x30,0x71, \
+    0x00,0x55,0x00,0x01,0x28,0x0F,0x00,0x00,0x8D,0x00, \
+    0x53,0xAD,0x00,0x01,0x30,0x71,0x00,0x55,0x00,0x01, \
+    0x28,0x0F,0x00,0x00,0x83,0x8E,0x53,0xC2,0x00,0x00, \
+    0x00,0x00,0x86,0x08,0x30,0x71,0x00,0x7B,0x03,0xC2, \
+    0x33,0xB4,0x00,0xDA,0xFF,0xFF,0x00,0x0F,0x00,0x00, \
+    0x00,0x00,0x00,0x00,0x86,0x09,0x01,0x03,0x00,0x7D, \
+    0x03,0xC2,0x1B,0xCB,0x33,0xD1,0x00,0xF9,0x00,0x10, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7B,0x00,0x01, \
+    0x1B,0xFF,0x00,0x00,0x8C,0x00,0x53,0xEC,0x00,0x01, \
+    0x34,0xF5,0x00,0xFB,0xFF,0xFF,0x00,0x7F,0x00,0x00, \
+    0x00,0x00,0x2A,0x9F,0x00,0x00,0x93,0x8F,0x28,0x49, \
+    0x00,0x00,0x97,0x8F,0x28,0x4B,0x34,0x61,0x28,0x4D, \
+    0x34,0x71,0x28,0x4F,0x34,0xB7,0x00,0xF9,0x00,0x00, \
+    0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97,0x00,0x03, \
+    0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFF,0x00,0x01, \
+    0x1B,0xFF, \
 }
 #endif /* (DPAA_VERSION == 10) */
 
@@ -189,5 +269,4 @@
 #define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
     bitMask = 0x80000000>>prsPortId
 
-
 #endif /* __FM_PRS_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index f948972..78ecab5 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -35,7 +35,7 @@
  @File          fm_port.c
 
  @Description   FM driver routines implementation.
-*//***************************************************************************/
+ *//***************************************************************************/
 #include "error_ext.h"
 #include "std_ext.h"
 #include "string_ext.h"
@@ -56,15 +56,19 @@ static t_Error FmPortConfigAutoResForDeepSleepSupport1(t_FmPort *p_FmPort);
 static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 {
     t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
-    struct fman_port_cfg    *p_DfltConfig = &p_Params->dfltCfg;
-    t_Error             ans = E_OK;
-    uint32_t            unusedMask;
+    struct fman_port_cfg *p_DfltConfig = &p_Params->dfltCfg;
+    t_Error ans = E_OK;
+    uint32_t unusedMask;
 
     if (p_FmPort->imEn)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth > 2)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for IM 10G can't be larger than 2"));
+            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                    > 2)
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("fifoDeqPipelineDepth for IM 10G can't be larger than 2"));
 
         if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
             return ERROR_CODE(ans);
@@ -74,29 +78,39 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx only                            */
         /****************************************/
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-            (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         {
             /* external buffer pools */
             if (!p_Params->extBufPools.numOfPoolsUsed)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
 
             if (FmSpCheckBufPoolsParams(&p_Params->extBufPools,
                                         p_Params->p_BackupBmPools,
-                                        &p_Params->bufPoolDepletion)!= E_OK)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+                                        &p_Params->bufPoolDepletion) != E_OK)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
             /* Check that part of IC that needs copying is small enough to enter start margin */
-            if (p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
+            if (p_Params->intContext.size
+                    && (p_Params->intContext.size
+                            + p_Params->intContext.extBufOffset
+                            > p_Params->bufMargins.startMargins))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                             ("intContext.size is larger than start margins"));
 
-            if ((p_Params->liodnOffset != DPAA_LIODN_DONT_OVERRIDE) &&
-                (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
+            if ((p_Params->liodnOffset != DPAA_LIODN_DONT_OVERRIDE)
+                    && (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK))
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
 
 #ifdef FM_NO_BACKUP_POOLS
-    if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
-        if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+            if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
+            if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("BackupBmPools"));
 #endif /* FM_NO_BACKUP_POOLS */
         }
@@ -107,37 +121,50 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         else
         {
             if (p_Params->deqSubPortal >= FM_MAX_NUM_OF_SUB_PORTALS)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", FM_MAX_NUM_OF_SUB_PORTALS));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        (" deqSubPortal has to be in the range of 0 - %d", FM_MAX_NUM_OF_SUB_PORTALS));
 
             /* to protect HW internal-context from overwrite */
-            if ((p_Params->intContext.size) &&
-                (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
-
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
-                (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            if ((p_Params->intContext.size)
+                    && (p_Params->intContext.intContextOffset
+                            < MIN_TX_INT_OFFSET))
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
+
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
                     /* in O/H DEFAULT_notSupported indicates that it is not supported and should not be checked */
-                    || (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth != DEFAULT_notSupported))
+                    || (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                            != DEFAULT_notSupported))
             {
                 /* Check that not larger than 8 */
-                if ((!p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth) ||
-                    ( p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth > MAX_FIFO_PIPELINE_DEPTH))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
+                if ((!p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth)
+                        || (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                                > MAX_FIFO_PIPELINE_DEPTH))
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_VALUE,
+                            ("fifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
             }
         }
 
         /****************************************/
         /*   Rx Or Offline Parsing              */
         /****************************************/
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-            (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         {
             if (!p_Params->dfltFqid)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                             ("dfltFqid must be between 1 and 2^24-1"));
 #if defined(FM_CAPWAP_SUPPORT) && defined(FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004)
             if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace % 16)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.manipExtraSpace has to be devidable by 16"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.manipExtraSpace has to be devidable by 16"));
 #endif /* defined(FM_CAPWAP_SUPPORT) && ... */
         }
 
@@ -147,46 +174,72 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /* common BMI registers values */
         /* Check that Queue Id is not larger than 2^24, and is not 0 */
         if ((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("errFqid must be between 1 and 2^24-1"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("errFqid must be between 1 and 2^24-1"));
         if (p_Params->dfltFqid & ~0x00FFFFFF)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("dfltFqid must be between 1 and 2^24-1"));
     }
 
     /****************************************/
     /*   Rx only                            */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         if (p_DfltConfig->rx_pri_elevation % BMI_FIFO_UNITS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if ((p_DfltConfig->rx_pri_elevation < BMI_FIFO_UNITS) || (p_DfltConfig->rx_pri_elevation > MAX_PORT_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if ((p_DfltConfig->rx_pri_elevation < BMI_FIFO_UNITS)
+                || (p_DfltConfig->rx_pri_elevation > MAX_PORT_FIFO_SIZE))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("rxFifoPriElevationLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
         if (p_DfltConfig->rx_fifo_thr % BMI_FIFO_UNITS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
-        if ((p_DfltConfig->rx_fifo_thr < BMI_FIFO_UNITS) ||(p_DfltConfig->rx_fifo_thr > MAX_PORT_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
+        if ((p_DfltConfig->rx_fifo_thr < BMI_FIFO_UNITS)
+                || (p_DfltConfig->rx_fifo_thr > MAX_PORT_FIFO_SIZE))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("rxFifoThreshold has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
 
         /* Check that not larger than 16 */
         if (p_DfltConfig->rx_cut_end_bytes > FRAME_END_DATA_SIZE)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
 
-        if (FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
+        if (FmSpCheckBufMargins(&p_Params->bufMargins) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
         /* extra FIFO size (allowed only to Rx ports) */
-        if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
-
-        if (p_Params->bufPoolDepletion.poolsGrpModeEnable &&
-           !p_Params->bufPoolDepletion.numOfPools)
-              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can not be 0 when poolsGrpModeEnable=TRUE"));
+        if (p_Params->setSizeOfFifo
+                && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
+
+        if (p_Params->bufPoolDepletion.poolsGrpModeEnable
+                && !p_Params->bufPoolDepletion.numOfPools)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("bufPoolDepletion.numOfPools can not be 0 when poolsGrpModeEnable=TRUE"));
 #ifdef FM_CSI_CFED_LIMIT
         if (p_FmPort->fmRevInfo.majorRev == 4)
         {
             /* Check that not larger than 16 */
             if (p_DfltConfig->rx_cut_end_bytes + p_DfltConfig->checksum_bytes_ignore > FRAME_END_DATA_SIZE)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
         }
 #endif /* FM_CSI_CFED_LIMIT */
     }
@@ -195,43 +248,64 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /*   Non Rx ports                       */
     /****************************************/
     /* extra FIFO size (allowed only to Rx ports) */
-    else if (p_FmPort->fifoBufs.extra)
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No fifoBufs.extra for non Rx ports"));
+    else
+        if (p_FmPort->fifoBufs.extra)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         (" No fifoBufs.extra for non Rx ports"));
 
     /****************************************/
     /*   Tx only                            */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
         if (p_DfltConfig->tx_fifo_min_level % BMI_FIFO_UNITS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
         if (p_DfltConfig->tx_fifo_min_level > (MAX_PORT_FIFO_SIZE - 256))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", (MAX_PORT_FIFO_SIZE - 256)));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("txFifoMinFillLevel has to be in the range of 0 - %d", (MAX_PORT_FIFO_SIZE - 256)));
         if (p_DfltConfig->tx_fifo_low_comf_level % BMI_FIFO_UNITS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if ((p_DfltConfig->tx_fifo_low_comf_level < BMI_FIFO_UNITS) || (p_DfltConfig->tx_fifo_low_comf_level > MAX_PORT_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if ((p_DfltConfig->tx_fifo_low_comf_level < BMI_FIFO_UNITS)
+                || (p_DfltConfig->tx_fifo_low_comf_level > MAX_PORT_FIFO_SIZE))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("txFifoLowComfLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_TX)
-            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth > 2)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
+            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                    > 2)
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
     }
 
     /****************************************/
     /*   Non Tx Ports                       */
     /****************************************/
     /* If discard override was selected , no frames may be discarded. */
-    else if (p_DfltConfig->discard_override && p_Params->errorsToDiscard)
-        RETURN_ERROR(MAJOR, E_CONFLICT,
-                     ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
+    else
+        if (p_DfltConfig->discard_override && p_Params->errorsToDiscard)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_CONFLICT,
+                    ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
 
     /****************************************/
     /*   Rx and Offline parsing             */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             unusedMask = BMI_STATUS_OP_MASK_UNUSED;
@@ -240,39 +314,43 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
         /* Check that no common bits with BMI_STATUS_MASK_UNUSED */
         if (p_Params->errorsToDiscard & unusedMask)
-            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("errorsToDiscard contains undefined bits"));
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION,
+                         ("errorsToDiscard contains undefined bits"));
     }
 
     /****************************************/
     /*   Offline Ports                      */
     /****************************************/
 #ifdef FM_OP_OPEN_DMA_MIN_LIMIT
-    if ((p_FmPort->fmRevInfo.majorRev >= 6) &&
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
-        p_Params->setNumOfOpenDmas &&
-        (p_FmPort->openDmas.num < MIN_NUM_OF_OP_DMAS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Offline port, openDmas.num can't be smaller than %d", MIN_NUM_OF_OP_DMAS));
+    if ((p_FmPort->fmRevInfo.majorRev >= 6)
+            && (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            && p_Params->setNumOfOpenDmas
+            && (p_FmPort->openDmas.num < MIN_NUM_OF_OP_DMAS))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For Offline port, openDmas.num can't be smaller than %d", MIN_NUM_OF_OP_DMAS));
 #endif /* FM_OP_OPEN_DMA_MIN_LIMIT */
 
     /****************************************/
     /*   Offline & HC Ports                 */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
     {
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
         if ((p_FmPort->fmRevInfo.majorRev < 6) &&
-            (p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore != DEFAULT_notSupported))
-                 /* this is an indication that user called config for this mode which is not supported in this integration */
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("cheksumLastBytesIgnore is available for Rx & Tx ports only"));
+                (p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore != DEFAULT_notSupported))
+        /* this is an indication that user called config for this mode which is not supported in this integration */
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("cheksumLastBytesIgnore is available for Rx & Tx ports only"));
 #endif /* !FM_FRAME_END_PARAMS_FOR_OP */
 
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
         if ((!((p_FmPort->fmRevInfo.majorRev == 4) ||
-               (p_FmPort->fmRevInfo.majorRev >= 6))) &&
-            (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth != DEFAULT_notSupported))
-                /* this is an indication that user called config for this mode which is not supported in this integration */
-                RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
+                                (p_FmPort->fmRevInfo.majorRev >= 6))) &&
+                (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth != DEFAULT_notSupported))
+        /* this is an indication that user called config for this mode which is not supported in this integration */
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
     }
 
@@ -280,32 +358,56 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /*   All ports                          */
     /****************************************/
     /* Check that not larger than 16 */
-    if ((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) &&
-        ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
-
-    if (FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
+    if ((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+            && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
+
+    if (FmSpCheckIntContextParams(&p_Params->intContext) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
     /* common BMI registers values */
-    if (p_Params->setNumOfTasks && ((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS)))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
-    if (p_Params->setNumOfTasks && (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
-    if (p_Params->setNumOfOpenDmas && ((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS)))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
-    if (p_Params->setNumOfOpenDmas && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    if (p_Params->setSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > MAX_PORT_FIFO_SIZE)))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+    if (p_Params->setNumOfTasks
+            && ((!p_FmPort->tasks.num)
+                    || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
+    if (p_Params->setNumOfTasks
+            && (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
+    if (p_Params->setNumOfOpenDmas
+            && ((!p_FmPort->openDmas.num)
+                    || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
+    if (p_Params->setNumOfOpenDmas
+            && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
+    if (p_Params->setSizeOfFifo
+            && (!p_FmPort->fifoBufs.num
+                    || (p_FmPort->fifoBufs.num > MAX_PORT_FIFO_SIZE)))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("fifoBufs.num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
     if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_FmPort->fmRevInfo.majorRev == 4)
-        if (p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
-            /* this is an indication that user called config for this mode which is not supported in this integration */
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("deqPrefetchOption"));
+    if (p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
+    /* this is an indication that user called config for this mode which is not supported in this integration */
+    RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("deqPrefetchOption"));
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     return E_OK;
@@ -313,92 +415,105 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
 static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 {
-    uint32_t    minFifoSizeRequired = 0, optFifoSizeForB2B = 0;
+    uint32_t minFifoSizeRequired = 0, optFifoSizeForB2B = 0;
 
     /*************************/
     /*    TX PORTS           */
     /*************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
-        minFifoSizeRequired = (uint32_t)
-            (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + (3*BMI_FIFO_UNITS));
+        minFifoSizeRequired =
+                (uint32_t)(ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS)
+                        + (3 * BMI_FIFO_UNITS));
         if (!p_FmPort->imEn)
-            minFifoSizeRequired += p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth * BMI_FIFO_UNITS;
+            minFifoSizeRequired +=
+                    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                            * BMI_FIFO_UNITS;
 
         optFifoSizeForB2B = minFifoSizeRequired;
 
         /* Add some margin for back-to-back capability to improve performance,
-           allows the hardware to pipeline new frame dma while the previous
-           frame not yet transmitted. */
+         allows the hardware to pipeline new frame dma while the previous
+         frame not yet transmitted. */
         if (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
-            optFifoSizeForB2B += 3*BMI_FIFO_UNITS;
+            optFifoSizeForB2B += 3 * BMI_FIFO_UNITS;
         else
-            optFifoSizeForB2B += 2*BMI_FIFO_UNITS;
+            optFifoSizeForB2B += 2 * BMI_FIFO_UNITS;
     }
 
     /*************************/
     /*    RX IM PORTS        */
     /*************************/
-    else if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-              (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
-             p_FmPort->imEn)
-    {
-        optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)
-            (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + (4*BMI_FIFO_UNITS));
-    }
-
-    /*************************/
-    /*    RX non-IM PORTS    */
-    /*************************/
-    else if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-              (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
-             !p_FmPort->imEn)
-    {
-        if (p_FmPort->fmRevInfo.majorRev == 4)
+    else
+        if (((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                && p_FmPort->imEn)
         {
-            if (p_FmPort->rxPoolsParams.numOfPools == 1)
-                minFifoSizeRequired = 8*BMI_FIFO_UNITS;
-            else
-                minFifoSizeRequired = (uint32_t)
-                    (ROUND_UP(p_FmPort->rxPoolsParams.secondLargestBufSize, BMI_FIFO_UNITS) + (7*BMI_FIFO_UNITS));
+            optFifoSizeForB2B =
+                    minFifoSizeRequired =
+                            (uint32_t)(ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS)
+                                    + (4 * BMI_FIFO_UNITS));
         }
+
+        /*************************/
+        /*    RX non-IM PORTS    */
+        /*************************/
         else
-        {
+            if (((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                    && !p_FmPort->imEn)
+            {
+                if (p_FmPort->fmRevInfo.majorRev == 4)
+                {
+                    if (p_FmPort->rxPoolsParams.numOfPools == 1)
+                        minFifoSizeRequired = 8 * BMI_FIFO_UNITS;
+                    else
+                        minFifoSizeRequired =
+                                (uint32_t)(ROUND_UP(p_FmPort->rxPoolsParams.secondLargestBufSize, BMI_FIFO_UNITS)
+                                        + (7 * BMI_FIFO_UNITS));
+                }
+                else
+                {
 #if (DPAA_VERSION >= 11)
-            minFifoSizeRequired = (uint32_t)
-                (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + (5*BMI_FIFO_UNITS));
-                /* 4 according to spec + 1 for FOF>0 */
+                    minFifoSizeRequired =
+                            (uint32_t)(ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS)
+                                    + (5 * BMI_FIFO_UNITS));
+                    /* 4 according to spec + 1 for FOF>0 */
 #else
-            minFifoSizeRequired = (uint32_t)
-                (ROUND_UP(MIN(p_FmPort->maxFrameLength, p_FmPort->rxPoolsParams.largestBufSize), BMI_FIFO_UNITS)
-                 + (7*BMI_FIFO_UNITS));
+                    minFifoSizeRequired = (uint32_t)
+                    (ROUND_UP(MIN(p_FmPort->maxFrameLength, p_FmPort->rxPoolsParams.largestBufSize), BMI_FIFO_UNITS)
+                            + (7*BMI_FIFO_UNITS));
 #endif /* (DPAA_VERSION >= 11) */
-        }
+                }
 
-        optFifoSizeForB2B = minFifoSizeRequired;
+                optFifoSizeForB2B = minFifoSizeRequired;
 
-        /* Add some margin for back-to-back capability to improve performance,
-           allows the hardware to pipeline new frame dma while the previous
-           frame not yet transmitted. */
-        if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-            optFifoSizeForB2B += 8*BMI_FIFO_UNITS;
-        else
-            optFifoSizeForB2B += 3*BMI_FIFO_UNITS;
-    }
+                /* Add some margin for back-to-back capability to improve performance,
+                 allows the hardware to pipeline new frame dma while the previous
+                 frame not yet transmitted. */
+                if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+                    optFifoSizeForB2B += 8 * BMI_FIFO_UNITS;
+                else
+                    optFifoSizeForB2B += 3 * BMI_FIFO_UNITS;
+            }
 
-    /* For O/H ports, check fifo size and update if necessary */
-    else if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-             (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-    {
+            /* For O/H ports, check fifo size and update if necessary */
+            else
+                if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+                        || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+                {
 #if (DPAA_VERSION >= 11)
-        optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)
-            (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + ((p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth + 5) * BMI_FIFO_UNITS));
-            /* 4 according to spec + 1 for FOF>0 */
+                    optFifoSizeForB2B =
+                            minFifoSizeRequired =
+                                    (uint32_t)(ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS)
+                                            + ((p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                                                    + 5) * BMI_FIFO_UNITS));
+                    /* 4 according to spec + 1 for FOF>0 */
 #else
-        optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)((p_FmPort->tasks.num + 2) * BMI_FIFO_UNITS);
+                    optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)((p_FmPort->tasks.num + 2) * BMI_FIFO_UNITS);
 #endif /* (DPAA_VERSION >= 11) */
-    }
+                }
 
     ASSERT_COND(minFifoSizeRequired > 0);
     ASSERT_COND(optFifoSizeForB2B >= minFifoSizeRequired);
@@ -407,7 +522,7 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
     if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
         DBG(INFO, ("FIFO size should be enlarged to %d bytes", minFifoSizeRequired));
     else if (p_FmPort->fifoBufs.num < optFifoSizeForB2B)
-        DBG(INFO, ("For back-to-back frames processing, FIFO size may need to be enlarged to %d bytes", optFifoSizeForB2B));
+            DBG(INFO, ("For back-to-back frames processing, FIFO size may need to be enlarged to %d bytes", optFifoSizeForB2B));
 
 
     return E_OK;
@@ -424,31 +539,37 @@ static void FmPortDriverParamFree(t_FmPort *p_FmPort)
 
 static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 {
-    t_FmExtPools                *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
-    t_FmBufPoolDepletion        *p_BufPoolDepletion = &p_FmPort->p_FmPortDriverParam->bufPoolDepletion;
-    uint8_t                     orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-    uint16_t                    sizesArray[BM_MAX_NUM_OF_POOLS];
-    int                         i=0, j=0, err;
-    struct fman_port_bpools     bpools;
+    t_FmExtPools *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
+    t_FmBufPoolDepletion *p_BufPoolDepletion =
+            &p_FmPort->p_FmPortDriverParam->bufPoolDepletion;
+    uint8_t orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    uint16_t sizesArray[BM_MAX_NUM_OF_POOLS];
+    int i = 0, j = 0, err;
+    struct fman_port_bpools bpools;
 
     memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
     memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
     memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmExtPools));
 
-    FmSpSetBufPoolsInAscOrderOfBufSizes(p_ExtBufPools, orderedArray, sizesArray);
+    FmSpSetBufPoolsInAscOrderOfBufSizes(p_ExtBufPools, orderedArray,
+                                        sizesArray);
 
     /* Prepare flibs bpools structure */
     memset(&bpools, 0, sizeof(struct fman_port_bpools));
     bpools.count = p_ExtBufPools->numOfPoolsUsed;
     bpools.counters_enable = TRUE;
-    for (i=0; i<p_ExtBufPools->numOfPoolsUsed; i++)
+    for (i = 0; i < p_ExtBufPools->numOfPoolsUsed; i++)
     {
         bpools.bpool[i].bpid = orderedArray[i];
         bpools.bpool[i].size = sizesArray[orderedArray[i]];
-         /* functionality available only for some derivatives (limited by config) */
+        /* functionality available only for some derivatives (limited by config) */
         if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-            for (j=0; j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools; j++)
-                if (orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
+            for (j = 0;
+                    j
+                            < p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;
+                    j++)
+                if (orderedArray[i]
+                        == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
                 {
                     bpools.bpool[i].is_backup = TRUE;
                     break;
@@ -457,18 +578,20 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 
     /* save pools parameters for later use */
     p_FmPort->rxPoolsParams.numOfPools = p_ExtBufPools->numOfPoolsUsed;
-    p_FmPort->rxPoolsParams.largestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-1]];
-    p_FmPort->rxPoolsParams.secondLargestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-2]];
+    p_FmPort->rxPoolsParams.largestBufSize =
+            sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed - 1]];
+    p_FmPort->rxPoolsParams.secondLargestBufSize =
+            sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed - 2]];
 
     /* FMBM_RMPD reg. - pool depletion */
     if (p_BufPoolDepletion->poolsGrpModeEnable)
     {
         bpools.grp_bp_depleted_num = p_BufPoolDepletion->numOfPools;
-        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        for (i = 0; i < BM_MAX_NUM_OF_POOLS; i++)
         {
             if (p_BufPoolDepletion->poolsToConsider[i])
             {
-                for (j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                for (j = 0; j < p_ExtBufPools->numOfPoolsUsed; j++)
                 {
                     if (i == orderedArray[j])
                     {
@@ -482,14 +605,14 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 
     if (p_BufPoolDepletion->singlePoolModeEnable)
     {
-        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        for (i = 0; i < BM_MAX_NUM_OF_POOLS; i++)
         {
             if (p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
             {
-                for (j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                for (j = 0; j < p_ExtBufPools->numOfPoolsUsed; j++)
                 {
                     if (i == orderedArray[j])
-                     {
+                    {
                         bpools.bpool[j].single_bp_depleted = TRUE;
                         break;
                     }
@@ -500,10 +623,10 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 
 #if (DPAA_VERSION >= 11)
     /* fill QbbPEV */
-    if (p_BufPoolDepletion->poolsGrpModeEnable ||
-        p_BufPoolDepletion->singlePoolModeEnable)
+    if (p_BufPoolDepletion->poolsGrpModeEnable
+            || p_BufPoolDepletion->singlePoolModeEnable)
     {
-        for (i=0; i<FM_MAX_NUM_OF_PFC_PRIORITIES; i++)
+        for (i = 0; i < FM_MAX_NUM_OF_PFC_PRIORITIES; i++)
         {
             if (p_BufPoolDepletion->pfcPrioritiesEn[i] == TRUE)
             {
@@ -534,13 +657,12 @@ static t_Error ClearPerfCnts(t_FmPort *p_FmPort)
     return E_OK;
 }
 
-
 static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
 {
-    t_FmPortDriverParam     *p_DriverParams = p_FmPort->p_FmPortDriverParam;
+    t_FmPortDriverParam *p_DriverParams = p_FmPort->p_FmPortDriverParam;
     struct fman_port_params portParams;
-    uint32_t                tmpVal;
-    t_Error                 err;
+    uint32_t tmpVal;
+    t_Error err;
 
     /* Set up flibs parameters and issue init function */
 
@@ -552,17 +674,18 @@ static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
     portParams.dont_release_buf = p_DriverParams->dontReleaseBuf;
     switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             portParams.err_mask = (RX_ERRS_TO_ENQ & ~portParams.discard_mask);
             if (!p_FmPort->imEn)
             {
                 if (p_DriverParams->forwardReuseIntContext)
-                    p_DriverParams->dfltCfg.rx_fd_bits = (uint8_t)(BMI_PORT_RFNE_FRWD_RPD >> 24);
+                    p_DriverParams->dfltCfg.rx_fd_bits =
+                            (uint8_t)(BMI_PORT_RFNE_FRWD_RPD >> 24);
             }
             break;
 
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             portParams.err_mask = (OP_ERRS_TO_ENQ & ~portParams.discard_mask);
             break;
             break;
@@ -571,54 +694,65 @@ static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
             break;
     }
 
-    tmpVal = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
-                        (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
-                        (p_FmPort->internalBufferOffset/OFFSET_UNITS));
+    tmpVal =
+            (uint32_t)(
+                    (p_FmPort->internalBufferOffset % OFFSET_UNITS) ? (p_FmPort->internalBufferOffset
+                            / OFFSET_UNITS + 1) :
+                            (p_FmPort->internalBufferOffset / OFFSET_UNITS));
     p_FmPort->internalBufferOffset = (uint8_t)(tmpVal * OFFSET_UNITS);
-    p_DriverParams->dfltCfg.int_buf_start_margin = p_FmPort->internalBufferOffset;
-
-    p_DriverParams->dfltCfg.ext_buf_start_margin = p_DriverParams->bufMargins.startMargins;
-    p_DriverParams->dfltCfg.ext_buf_end_margin = p_DriverParams->bufMargins.endMargins;
-
-    p_DriverParams->dfltCfg.ic_ext_offset = p_DriverParams->intContext.extBufOffset;
-    p_DriverParams->dfltCfg.ic_int_offset = p_DriverParams->intContext.intContextOffset;
+    p_DriverParams->dfltCfg.int_buf_start_margin =
+            p_FmPort->internalBufferOffset;
+
+    p_DriverParams->dfltCfg.ext_buf_start_margin =
+            p_DriverParams->bufMargins.startMargins;
+    p_DriverParams->dfltCfg.ext_buf_end_margin =
+            p_DriverParams->bufMargins.endMargins;
+
+    p_DriverParams->dfltCfg.ic_ext_offset =
+            p_DriverParams->intContext.extBufOffset;
+    p_DriverParams->dfltCfg.ic_int_offset =
+            p_DriverParams->intContext.intContextOffset;
     p_DriverParams->dfltCfg.ic_size = p_DriverParams->intContext.size;
 
     p_DriverParams->dfltCfg.stats_counters_enable = TRUE;
     p_DriverParams->dfltCfg.perf_counters_enable = TRUE;
     p_DriverParams->dfltCfg.queue_counters_enable = TRUE;
 
-    p_DriverParams->dfltCfg.perf_cnt_params.task_val    = (uint8_t)p_FmPort->tasks.num;
+    p_DriverParams->dfltCfg.perf_cnt_params.task_val =
+            (uint8_t)p_FmPort->tasks.num;
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
-        p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
-        p_DriverParams->dfltCfg.perf_cnt_params.queue_val   = 0;
+    p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)p_DriverParams->dfltCfg.perf_cnt_params.queue_val = 0;
     else
-        p_DriverParams->dfltCfg.perf_cnt_params.queue_val   = 1;
-    p_DriverParams->dfltCfg.perf_cnt_params.dma_val     =(uint8_t) p_FmPort->openDmas.num;
-    p_DriverParams->dfltCfg.perf_cnt_params.fifo_val    = p_FmPort->fifoBufs.num;
-
-    if (0 != fman_port_init(&p_FmPort->port, &p_DriverParams->dfltCfg, &portParams))
+    p_DriverParams->dfltCfg.perf_cnt_params.queue_val = 1;
+    p_DriverParams->dfltCfg.perf_cnt_params.dma_val =
+            (uint8_t)p_FmPort->openDmas.num;
+    p_DriverParams->dfltCfg.perf_cnt_params.fifo_val = p_FmPort->fifoBufs.num;
+
+    if (0
+            != fman_port_init(&p_FmPort->port, &p_DriverParams->dfltCfg,
+                              &portParams))
         RETURN_ERROR(MAJOR, E_NO_DEVICE, ("fman_port_init"));
 
     if (p_FmPort->imEn && ((err = FmPortImInit(p_FmPort)) != E_OK))
         RETURN_ERROR(MAJOR, err, NO_MSG);
     else
     {
-    //  from QMIInit
-        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-            (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        //  from QMIInit
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+                && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         {
             if (p_DriverParams->deqPrefetchOption == e_FM_PORT_DEQ_NO_PREFETCH)
-                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, FALSE);
+                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId,
+                                               FALSE);
             else
-                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, TRUE);
+                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId,
+                                               TRUE);
         }
     }
     /* The code bellow is a trick so the FM will not release the buffer
-       to BM nor will try to enqueue the frame to QM */
-    if (((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
-         (p_FmPort->portType == e_FM_PORT_TYPE_TX)) &&
-        (!p_FmPort->imEn))
+     to BM nor will try to enqueue the frame to QM */
+    if (((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX)) && (!p_FmPort->imEn))
     {
         if (!p_DriverParams->dfltFqid && p_DriverParams->dontReleaseBuf)
         {
@@ -627,35 +761,35 @@ static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
              * buffers to BM regardless of fmbm_tfene
              */
             WRITE_UINT32(p_FmPort->port.bmi_regs->tx.fmbm_tcfqid, 0xFFFFFF);
-            WRITE_UINT32(p_FmPort->port.bmi_regs->tx.fmbm_tfene, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->tx.fmbm_tfene,
+                         NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
         }
     }
 
     return E_OK;
 }
 
-
 static bool CheckRxBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
 {
     UNUSED(p_FmPort);
 
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             return TRUE;
         default:
             return FALSE;
@@ -668,16 +802,16 @@ static bool CheckTxBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
 
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             return TRUE;
         default:
             return FALSE;
@@ -688,19 +822,19 @@ static bool CheckOhBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
 {
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             return TRUE;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
             if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
                 return FALSE;
             else
@@ -710,29 +844,28 @@ static bool CheckOhBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
     }
 }
 
-static t_Error BmiPortCheckAndGetCounterType(t_FmPort                      *p_FmPort,
-                                             e_FmPortCounters              counter,
-                                             enum fman_port_stats_counters *p_StatsType,
-                                             enum fman_port_perf_counters  *p_PerfType,
-                                             bool                          *p_IsStats)
+static t_Error BmiPortCheckAndGetCounterType(
+        t_FmPort *p_FmPort, e_FmPortCounters counter,
+        enum fman_port_stats_counters *p_StatsType,
+        enum fman_port_perf_counters *p_PerfType, bool *p_IsStats)
 {
-    volatile uint32_t   *p_Reg;
-    bool                isValid;
+    volatile uint32_t *p_Reg;
+    bool isValid;
 
     switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_Reg = &p_FmPort->port.bmi_regs->rx.fmbm_rstc;
             isValid = CheckRxBmiCounter(p_FmPort, counter);
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_Reg = &p_FmPort->port.bmi_regs->tx.fmbm_tstc;
             isValid = CheckTxBmiCounter(p_FmPort, counter);
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_Reg = &p_FmPort->port.bmi_regs->oh.fmbm_ostc;
             isValid = CheckOhBmiCounter(p_FmPort, counter);
             break;
@@ -742,101 +875,102 @@ static t_Error BmiPortCheckAndGetCounterType(t_FmPort                      *p_Fm
 
     if (!isValid)
         RETURN_ERROR(MINOR, E_INVALID_STATE,
-                ("Requested counter is not available for this port type"));
+                     ("Requested counter is not available for this port type"));
 
-     /* check that counters are enabled */
+    /* check that counters are enabled */
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             /* performance counters - may be read when disabled */
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
             if (!(GET_UINT32(*p_Reg) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                RETURN_ERROR(MINOR, E_INVALID_STATE,
+                             ("Requested counter was not enabled"));
             break;
-         default:
+        default:
             break;
     }
 
     /* Set counter */
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_CYCLE):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_CYCLE;
             *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_TASK_UTIL;
             break;
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_QUEUE_UTIL;
             *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_DMA_UTIL;
             *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_FIFO_UTIL;
             *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_RX_PAUSE;
             *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_FRAME;
             *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_DISCARD;
             *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_DEALLOC_BUF;
             *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_BAD_FRAME;
             *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_LARGE_FRAME;
             *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_OUT_OF_BUF;
             *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_FILTERED_FRAME;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_DMA_ERR;
             *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_WRED_DISCARD;
             *p_IsStats = TRUE;
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_LEN_ERR;
             *p_IsStats = TRUE;
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT;
             *p_IsStats = TRUE;
         default:
@@ -846,15 +980,19 @@ static t_Error BmiPortCheckAndGetCounterType(t_FmPort                      *p_Fm
     return E_OK;
 }
 
-
-static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
+static t_Error AdditionalPrsParams(t_FmPort *p_FmPort,
+                                   t_FmPcdPrsAdditionalHdrParams *p_HdrParams,
+                                   uint32_t *p_SoftSeqAttachReg)
 {
-    uint8_t                     hdrNum, Ipv4HdrNum;
-    u_FmPcdHdrPrsOpts           *p_prsOpts;
-    uint32_t                    tmpReg = *p_SoftSeqAttachReg, tmpPrsOffset;
+    uint8_t hdrNum, Ipv4HdrNum;
+    u_FmPcdHdrPrsOpts *p_prsOpts;
+    uint32_t tmpReg = *p_SoftSeqAttachReg, tmpPrsOffset;
 
-    if (IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("No additional parameters for private or special headers."));
+    if (IS_PRIVATE_HEADER(p_HdrParams->hdr)
+            || IS_SPECIAL_HEADER(p_HdrParams->hdr))
+        RETURN_ERROR(
+                MAJOR, E_NOT_SUPPORTED,
+                ("No additional parameters for private or special headers."));
 
     if (p_HdrParams->errDisable)
         tmpReg |= PRS_HDR_ERROR_DIS;
@@ -874,8 +1012,9 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
                 GET_PRS_HDR_NUM(Ipv4HdrNum, HEADER_TYPE_IPv4);
                 if (hdrNum < Ipv4HdrNum)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                        ("Header must be equal or higher than IPv4"));
-                tmpReg |= ((uint32_t)hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
+                                 ("Header must be equal or higher than IPv4"));
+                tmpReg |= ((uint32_t)hdrNum * PRS_HDR_ENTRY_SIZE)
+                        << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
                 break;
             case (HEADER_TYPE_PPPoE):
                 if (p_prsOpts->pppoePrsOptions.enableMTUCheck)
@@ -887,16 +1026,16 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
                 break;
             case (HEADER_TYPE_TCP):
                 if (p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
-                   tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
+                    tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
                 else
-                   tmpReg &= ~PRS_HDR_TCP_PAD_REMOVAL;
-               break;
+                    tmpReg &= ~PRS_HDR_TCP_PAD_REMOVAL;
+                break;
             case (HEADER_TYPE_UDP):
                 if (p_prsOpts->udpPrsOptions.padIgnoreChecksum)
-                   tmpReg |= PRS_HDR_UDP_PAD_REMOVAL;
+                    tmpReg |= PRS_HDR_UDP_PAD_REMOVAL;
                 else
-                   tmpReg &= ~PRS_HDR_UDP_PAD_REMOVAL;
-                 break;
+                    tmpReg &= ~PRS_HDR_UDP_PAD_REMOVAL;
+                break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header"));
         }
@@ -905,7 +1044,8 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     /* set software parsing (address is divided in 2 since parser uses 2 byte access. */
     if (p_HdrParams->swPrsEnable)
     {
-        tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
+        tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr,
+                                           p_HdrParams->indexPerHdr);
         if (tmpPrsOffset == ILLEGAL_BASE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
         tmpReg |= (PRS_HDR_SW_PRS_EN | tmpPrsOffset);
@@ -915,11 +1055,12 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     return E_OK;
 }
 
-static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+static uint32_t GetPortSchemeBindParams(
+        t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t                    walking1Mask = 0x80000000, tmp;
-    uint8_t                     idx = 0;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t walking1Mask = 0x80000000, tmp;
+    uint8_t idx = 0;
 
     p_SchemeBind->netEnvId = p_FmPort->netEnvId;
     p_SchemeBind->hardwarePortId = p_FmPort->hardwarePortId;
@@ -946,32 +1087,34 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
 
 static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 {
-    t_Error                             err = E_OK;
-    uint32_t                            tmpReg;
-    volatile uint32_t                   *p_BmiNia=NULL;
-    volatile uint32_t                   *p_BmiPrsNia=NULL;
-    volatile uint32_t                   *p_BmiPrsStartOffset=NULL;
-    volatile uint32_t                   *p_BmiInitPrsResult=NULL;
-    volatile uint32_t                   *p_BmiCcBase=NULL;
-    uint8_t                             hdrNum, L3HdrNum, greHdrNum;
-    int                                 i;
-    bool                                isEmptyClsPlanGrp;
-    uint32_t                            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
-    uint16_t                            absoluteProfileId;
-    uint8_t                             physicalSchemeId;
-    uint32_t                            ccTreePhysOffset;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error err = E_OK;
+    uint32_t tmpReg;
+    volatile uint32_t *p_BmiNia = NULL;
+    volatile uint32_t *p_BmiPrsNia = NULL;
+    volatile uint32_t *p_BmiPrsStartOffset = NULL;
+    volatile uint32_t *p_BmiInitPrsResult = NULL;
+    volatile uint32_t *p_BmiCcBase = NULL;
+    uint16_t hdrNum, L3HdrNum, greHdrNum;
+    int i;
+    bool isEmptyClsPlanGrp;
+    uint32_t tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint16_t absoluteProfileId;
+    uint8_t physicalSchemeId;
+    uint32_t ccTreePhysOffset;
+    t_FmPcdKgInterModuleBindPortToSchemes schemeBind;
 
     ASSERT_COND(p_FmPort);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independant mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     p_FmPort->netEnvId = FmPcdGetNetEnvId(p_PcdParams->h_NetEnv);
 
@@ -981,7 +1124,10 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     switch (p_PcdParams->pcdSupport)
     {
         case (e_FM_PORT_PCD_SUPPORT_NONE):
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_STATE,
+                    ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
         case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             break;
@@ -1021,15 +1167,15 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-#ifdef FM_CAPWAP_SUPPORT
         case (e_FM_PORT_PCD_SUPPORT_CC_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
+#ifdef FM_CAPWAP_SUPPORT
+            case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
+            case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
@@ -1040,15 +1186,24 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid pcdSupport"));
     }
 
-    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
-        (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams > FM_PCD_PRS_NUM_OF_HDRS))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Port parser numOfHdrsWithAdditionalParams may not exceed %d", FM_PCD_PRS_NUM_OF_HDRS));
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS)
+            && (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams
+                    > FM_PCD_PRS_NUM_OF_HDRS))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("Port parser numOfHdrsWithAdditionalParams may not exceed %d", FM_PCD_PRS_NUM_OF_HDRS));
 
     /* check that parameters exist for each and only each defined engine */
-    if ((!!(p_FmPort->pcdEngines & FM_PCD_PRS) != !!p_PcdParams->p_PrsParams) ||
-        (!!(p_FmPort->pcdEngines & FM_PCD_KG) != !!p_PcdParams->p_KgParams) ||
-        (!!(p_FmPort->pcdEngines & FM_PCD_CC) != !!p_PcdParams->p_CcParams))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
+    if ((!!(p_FmPort->pcdEngines & FM_PCD_PRS) != !!p_PcdParams->p_PrsParams)
+            || (!!(p_FmPort->pcdEngines & FM_PCD_KG)
+                    != !!p_PcdParams->p_KgParams)
+            || (!!(p_FmPort->pcdEngines & FM_PCD_CC)
+                    != !!p_PcdParams->p_CcParams))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("PCD initialization structure is not consistent with pcdSupport"));
 
     /* get PCD registers pointers */
     switch (p_FmPort->portType)
@@ -1061,7 +1216,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_BmiInitPrsResult = &p_FmPort->port.bmi_regs->rx.fmbm_rprai[0];
             p_BmiCcBase = &p_FmPort->port.bmi_regs->rx.fmbm_rccb;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
             p_BmiPrsNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofpne;
             p_BmiPrsStartOffset = &p_FmPort->port.bmi_regs->oh.fmbm_opso;
@@ -1075,11 +1230,9 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     /* set PCD port parameter */
     if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd,
-                              p_PcdParams,
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams,
                               p_PcdParams->p_CcParams->h_CcTree,
-                              &ccTreePhysOffset,
-                              p_FmPort);
+                              &ccTreePhysOffset, p_FmPort);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1090,7 +1243,10 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     if (p_FmPort->pcdEngines & FM_PCD_KG)
     {
         if (p_PcdParams->p_KgParams->numOfSchemes == 0)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at least one scheme must be bound. "));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("For ports using Keygen, at least one scheme must be bound. "));
 
         err = FmPcdKgSetOrBindToClsPlanGrp(p_FmPort->h_FmPcd,
                                            p_FmPort->hardwarePortId,
@@ -1098,10 +1254,11 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
                                            p_FmPort->optArray,
                                            &p_FmPort->clsPlanGrpId,
                                            &isEmptyClsPlanGrp);
-         if (err)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
+        if (err)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
 
-         p_FmPort->useClsPlan = !isEmptyClsPlanGrp;
+        p_FmPort->useClsPlan = !isEmptyClsPlanGrp;
 
         schemeBind.netEnvId = p_FmPort->netEnvId;
         schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
@@ -1109,18 +1266,22 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         schemeBind.useClsPlan = p_FmPort->useClsPlan;
 
         /* for each scheme */
-        for (i=0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+        for (i = 0; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
         {
             ASSERT_COND(p_PcdParams->p_KgParams->h_Schemes[i]);
-            physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_Schemes[i]);
+            physicalSchemeId = FmPcdKgGetSchemeId(
+                    p_PcdParams->p_KgParams->h_Schemes[i]);
             schemeBind.schemesIds[i] = physicalSchemeId;
             /* build vector */
-            p_FmPort->schemesPerPortVector |= 1 << (31 - (uint32_t)physicalSchemeId);
+            p_FmPort->schemesPerPortVector |= 1
+                    << (31 - (uint32_t)physicalSchemeId);
 #if (DPAA_VERSION >= 11)
             /*because of the state that VSPE is defined per port - all PCD path should be according to this requirement
              if !VSPE - in port, for relevant scheme VSPE can not be set*/
-            if (!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("VSPE is not at port level"));
+            if (!p_FmPort->vspe
+                    && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("VSPE is not at port level"));
 #endif /* (DPAA_VERSION >= 11) */
         }
 
@@ -1136,55 +1297,74 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     p_FmPort->savedBmiNia = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
 
     /* If policer is used directly after BMI or PRS */
-    if ((p_FmPort->pcdEngines & FM_PCD_PLCR) &&
-        ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
-         (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
+    if ((p_FmPort->pcdEngines & FM_PCD_PLCR)
+            && ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY)
+                    || (p_PcdParams->pcdSupport
+                            == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
     {
         if (!p_PcdParams->p_PlcrParams->h_Profile)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Profile should be initialized"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("Profile should be initialized"));
 
-        absoluteProfileId = (uint16_t)FmPcdPlcrProfileGetAbsoluteId(p_PcdParams->p_PlcrParams->h_Profile);
+        absoluteProfileId = (uint16_t)FmPcdPlcrProfileGetAbsoluteId(
+                p_PcdParams->p_PlcrParams->h_Profile);
 
         if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Private port profile not valid."));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("Private port profile not valid."));
 
         tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
 
         if (p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
             /* update BMI HPNIA */
             WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
-        else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
+        else
+            /* e_FM_PCD_SUPPORT_PLCR_ONLY */
             /* update BMI NIA */
             p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PLCR);
     }
 
-#ifdef FM_CAPWAP_SUPPORT
     /* if CC is used directly after BMI */
-    if ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_ONLY) ||
-        (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG) ||
-        (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR))
+    if ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_ONLY)
+#ifdef FM_CAPWAP_SUPPORT
+    || (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG)
+    || (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR)
+#endif /* FM_CAPWAP_SUPPORT */
+    )
     {
         if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("e_FM_PORT_PCD_SUPPORT_CC_xx available for offline parsing ports only"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_OPERATION,
+                    ("e_FM_PORT_PCD_SUPPORT_CC_xx available for offline parsing ports only"));
         p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
-         /* check that prs start offset == RIM[FOF] */
+        /* check that prs start offset == RIM[FOF] */
     }
-#endif /* FM_CAPWAP_SUPPORT */
 
     if (p_FmPort->pcdEngines & FM_PCD_PRS)
     {
         ASSERT_COND(p_PcdParams->p_PrsParams);
-        /* if PRS is used it is always first */
-        GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->firstPrsHdr);
-        if (hdrNum == ILLEGAL_HDR_NUM)
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+#if (DPAA_VERSION >= 11)
+        if (p_PcdParams->p_PrsParams->firstPrsHdr == HEADER_TYPE_CAPWAP)
+            hdrNum = OFFLOAD_CAPWAP_SW_PATCH_LABEL;
+        else
+        {
+#endif /* (DPAA_VERSION >= 11) */
+            /* if PRS is used it is always first */
+            GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->firstPrsHdr);
+            if (hdrNum == ILLEGAL_HDR_NUM)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+#if (DPAA_VERSION >= 11)
+        }
+#endif /* (DPAA_VERSION >= 11) */
         p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum));
         /* set after parser NIA */
         tmpReg = 0;
         switch (p_PcdParams->pcdSupport)
         {
             case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
-                WRITE_UINT32(*p_BmiPrsNia, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd));
+                WRITE_UINT32(*p_BmiPrsNia,
+                             GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd));
                 break;
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
@@ -1193,20 +1373,26 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
                 if (p_PcdParams->p_KgParams->directScheme)
                 {
-                    physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_DirectScheme);
+                    physicalSchemeId = FmPcdKgGetSchemeId(
+                            p_PcdParams->p_KgParams->h_DirectScheme);
                     /* check that this scheme was bound to this port */
-                    for (i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
-                        if (p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
+                    for (i = 0; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
+                        if (p_PcdParams->p_KgParams->h_DirectScheme
+                                == p_PcdParams->p_KgParams->h_Schemes[i])
                             break;
                     if (i == p_PcdParams->p_KgParams->numOfSchemes)
-                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Direct scheme is not one of the port selected schemes."));
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_INVALID_VALUE,
+                                ("Direct scheme is not one of the port selected schemes."));
                     tmpReg |= (uint32_t)(NIA_KG_DIRECT | physicalSchemeId);
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
                 break;
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
-                WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
+                WRITE_UINT32(*p_BmiPrsNia,
+                             (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 break;
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
                 break;
@@ -1215,7 +1401,8 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         }
 
         /* set start parsing offset */
-         WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset);
+        WRITE_UINT32(*p_BmiPrsStartOffset,
+                     p_PcdParams->p_PrsParams->parsingOffset);
 
         /************************************/
         /* Parser port parameters           */
@@ -1223,68 +1410,69 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         /* stop before configuring */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
         /* wait for parser to be in idle state */
-        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE)
+            ;
 
         /* set soft seq attachment register */
-        memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
+        memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS * sizeof(uint32_t));
 
         /* set protocol options */
-        for (i=0;p_FmPort->optArray[i];i++)
+        for (i = 0; p_FmPort->optArray[i]; i++)
             switch (p_FmPort->optArray[i])
             {
                 case (ETH_BROADCAST):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_ETH_BC_SHIFT;
                     break;
                 case (ETH_MULTICAST):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_ETH_MC_SHIFT;
                     break;
                 case (VLAN_STACKED):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
-                    tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_VLAN_STACKED_SHIFT;
                     break;
                 case (MPLS_STACKED):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_MPLS_STACKED_SHIFT;
                     break;
                 case (IPV4_BROADCAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_1_BC_SHIFT;
                     break;
                 case (IPV4_MULTICAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_1_MC_SHIFT;
                     break;
                 case (IPV4_UNICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_2_UC_SHIFT;
                     break;
                 case (IPV4_MULTICAST_BROADCAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
                     break;
                 case (IPV6_MULTICAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV6_1_MC_SHIFT;
                     break;
                 case (IPV6_UNICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV6_2_UC_SHIFT;
                     break;
                 case (IPV6_MULTICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV6_2_MC_SHIFT;
                     break;
             }
 
-        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd,
-                                  p_FmPort->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP))
+        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd, p_FmPort->netEnvId,
+                                  HEADER_TYPE_UDP_ENCAP_ESP))
         {
-            p_PcdParams->p_PrsParams->additionalParams
-                [p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].hdr = HEADER_TYPE_UDP;
-            p_PcdParams->p_PrsParams->additionalParams
-                [p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].swPrsEnable = TRUE;
+            p_PcdParams->p_PrsParams->additionalParams[p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].hdr =
+                    HEADER_TYPE_UDP;
+            p_PcdParams->p_PrsParams->additionalParams[p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].swPrsEnable =
+                    TRUE;
             p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams++;
         }
 
@@ -1306,15 +1494,21 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         tmpHxs[hdrNum] |= PRS_HDR_TCP_PAD_REMOVAL;
 
         /* config additional params for specific headers */
-        for (i=0; i<p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams; i++)
+        for (i = 0; i < p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams;
+                i++)
         {
-            GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->additionalParams[i].hdr);
-            if (hdrNum== ILLEGAL_HDR_NUM)
+            GET_PRS_HDR_NUM( hdrNum,
+                            p_PcdParams->p_PrsParams->additionalParams[i].hdr);
+            if (hdrNum == ILLEGAL_HDR_NUM)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
-            if (hdrNum==NO_HDR_NUM)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Private headers may not use additional parameters"));
-
-            err = AdditionalPrsParams(p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i], &tmpHxs[hdrNum]);
+            if (hdrNum == NO_HDR_NUM)
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("Private headers may not use additional parameters"));
+
+            err = AdditionalPrsParams(
+                    p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i],
+                    &tmpHxs[hdrNum]);
             if (err)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
         }
@@ -1322,41 +1516,45 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         /* Check if ip-reassembly port - need to update NIAs */
         if (p_FmPort->h_IpReassemblyManip)
         {
-           /* link to sw parser code for IP Frag - only if no other code is applied. */
+            /* link to sw parser code for IP Frag - only if no other code is applied. */
             GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv4_LABEL);
-            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
-            if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_LABEL);
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN
+                        | OFFLOAD_SW_PATCH_IPv4_LABEL);
         }
 
-        if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd) &&
-            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        if ((p_FmPort->h_IpReassemblyManip)
+                || (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd, p_FmPort->netEnvId,
+                                          HEADER_TYPE_UDP_LITE))
+                || (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd)
+                        && (p_FmPort->portType
+                                == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)))
         {
-            /* link to sw parser code for IP Frag - only if no other code is applied. */
             GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_LABEL);
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN
+                        | OFFLOAD_SW_PATCH_IPv6_LABEL);
         }
 
-#ifdef FM_CAPWAP_SUPPORT
-        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd,
-                                  p_FmPort->netEnvId, HEADER_TYPE_UDP_LITE))
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd, p_FmPort->netEnvId,
+                        HEADER_TYPE_UDP_LITE))
         {
-           /* link to sw parser code for udp lite - only if no other code is applied. */
-            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_USER_DEFINED_L4)
+            /* link to sw parser code for udp lite - only if no other code is applied. */
+            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | UDP_LITE_SW_PATCH_LABEL);
+            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | UDP_LITE_SW_PATCH_LABEL);
         }
-#endif /* FM_CAPWAP_SUPPORT */
-        for (i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+        for (i = 0; i < FM_PCD_PRS_NUM_OF_HDRS; i++)
         {
             /* For all header set LCV as taken from netEnv*/
-            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,
-                         FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
+            WRITE_UINT32(
+                    p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,
+                    FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
             /* set HXS register according to default+Additional params+protocol options */
-            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,  tmpHxs[i]);
+            WRITE_UINT32( p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,
+                         tmpHxs[i]);
         }
 
         /* set tpid. */
@@ -1364,37 +1562,40 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         if (p_PcdParams->p_PrsParams->setVlanTpid1)
         {
             tmpReg &= PRS_TPID2_MASK;
-            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1 << PRS_PCTPID_SHIFT;
+            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1
+                    << PRS_PCTPID_SHIFT;
         }
         if (p_PcdParams->p_PrsParams->setVlanTpid2)
         {
             tmpReg &= PRS_TPID1_MASK;
             tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid2;
-        }
-        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pctpid, tmpReg);
+        }WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pctpid, tmpReg);
 
         /* enable parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
 
         if (p_PcdParams->p_PrsParams->prsResultPrivateInfo)
-            p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
+            p_FmPort->privateInfo =
+                    p_PcdParams->p_PrsParams->prsResultPrivateInfo;
 
     } /* end parser */
     else
         p_FmPort->privateInfo = 0;
 
-    WRITE_UINT32(*p_BmiPrsStartOffset, GET_UINT32(*p_BmiPrsStartOffset) + p_FmPort->internalBufferOffset);
+    WRITE_UINT32(
+            *p_BmiPrsStartOffset,
+            GET_UINT32(*p_BmiPrsStartOffset) + p_FmPort->internalBufferOffset);
 
     /* set initial parser result - used for all engines */
-    for (i=0;i<FM_PORT_PRS_RESULT_NUM_OF_WORDS;i++)
+    for (i = 0; i < FM_PORT_PRS_RESULT_NUM_OF_WORDS; i++)
     {
         if (!i)
-            WRITE_UINT32(*(p_BmiInitPrsResult),
-                         (uint32_t)(((uint32_t)p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
-                                    | BMI_PRS_RESULT_HIGH));
+            WRITE_UINT32(
+                    *(p_BmiInitPrsResult),
+                    (uint32_t)(((uint32_t)p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT) | BMI_PRS_RESULT_HIGH));
         else
         {
-            if (i< FM_PORT_PRS_RESULT_NUM_OF_WORDS/2)
+            if (i < FM_PORT_PRS_RESULT_NUM_OF_WORDS / 2)
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_HIGH);
             else
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_LOW);
@@ -1406,20 +1607,22 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 
 static t_Error DeletePcd(t_FmPort *p_FmPort)
 {
-    t_Error                             err = E_OK;
-    volatile uint32_t                   *p_BmiNia=NULL;
-    volatile uint32_t                   *p_BmiPrsStartOffset = NULL;
+    t_Error err = E_OK;
+    volatile uint32_t *p_BmiNia = NULL;
+    volatile uint32_t *p_BmiPrsStartOffset = NULL;
 
     ASSERT_COND(p_FmPort);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independant mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!p_FmPort->pcdEngines)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("called for non PCD port"));
@@ -1440,9 +1643,10 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if ((GET_UINT32(*p_BmiNia) & GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME()) !=
-        GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("port has to be detached previousely"));
+    if ((GET_UINT32(*p_BmiNia) & GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
+            != GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("port has to be detached previousely"));
 
     /* "cut" PCD out of the port's flow - go to BMI */
     /* WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)); */
@@ -1454,21 +1658,25 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         /* stop parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
         /* wait for parser to be in idle state */
-        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE)
+            ;
     }
 
     if (p_FmPort->pcdEngines & FM_PCD_KG)
     {
-        t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+        t_FmPcdKgInterModuleBindPortToSchemes schemeBind;
 
         /* unbind all schemes */
-        p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
+        p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort,
+                                                                 &schemeBind);
 
         err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
-        err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
+        err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd,
+                                                    p_FmPort->hardwarePortId,
+                                                    p_FmPort->clsPlanGrpId);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
         p_FmPort->useClsPlan = FALSE;
@@ -1477,7 +1685,7 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
     if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         /* unbind - we need to get the treeId too */
-        err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd,  p_FmPort->ccTreeId);
+        err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd, p_FmPort->ccTreeId);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
@@ -1489,7 +1697,7 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
 
 static t_Error AttachPCD(t_FmPort *p_FmPort)
 {
-    volatile uint32_t                   *p_BmiNia=NULL;
+    volatile uint32_t *p_BmiNia = NULL;
 
     ASSERT_COND(p_FmPort);
 
@@ -1500,47 +1708,66 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
         p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
 
     /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK)
+            != GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
                      ("may be called only for ports in BMI-to-BMI state."));
 
     if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
+        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1,
+                                   p_FmPort->orFmanCtrl) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     if (p_FmPort->requiredAction & UPDATE_NIA_CMNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ocmne, p_FmPort->savedBmiCmne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ocmne,
+                         p_FmPort->savedBmiCmne);
         else
-            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rcmne, p_FmPort->savedBmiCmne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rcmne,
+                         p_FmPort->savedBmiCmne);
     }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen,
+                     p_FmPort->savedQmiPnen);
 
     if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene, p_FmPort->savedBmiFene);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene,
+                         p_FmPort->savedBmiFene);
         else
-            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene, p_FmPort->savedBmiFene);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene,
+                         p_FmPort->savedBmiFene);
     }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_FPNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne, p_FmPort->savedBmiFpne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne,
+                         p_FmPort->savedBmiFpne);
         else
-            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne, p_FmPort->savedBmiFpne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne,
+                         p_FmPort->savedBmiFpne);
+    }
+
+    if (p_FmPort->requiredAction & UPDATE_OFP_DPTE)
+    {
+        ASSERT_COND(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+
+        WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofp,
+                     p_FmPort->savedBmiOfp);
     }
 
     WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
     {
-        p_FmPort->origNonRxQmiRegsPndn = GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn);
-        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
+        p_FmPort->origNonRxQmiRegsPndn =
+                GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn);
+        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn,
+                     p_FmPort->savedNonRxQmiRegsPndn);
     }
 
     return E_OK;
@@ -1548,21 +1775,23 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
 
 static t_Error DetachPCD(t_FmPort *p_FmPort)
 {
-    volatile uint32_t                   *p_BmiNia=NULL;
+    volatile uint32_t *p_BmiNia = NULL;
 
     ASSERT_COND(p_FmPort);
 
     /* get PCD registers pointers */
     if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
-        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn, p_FmPort->origNonRxQmiRegsPndn);
+        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn,
+                     p_FmPort->origNonRxQmiRegsPndn);
 
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
     else
         p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
 
-    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) |
-                            GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
+    WRITE_UINT32(
+            *p_BmiNia,
+            (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
 
     if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
         FmPcdHcSync(p_FmPort->h_FmPcd);
@@ -1570,16 +1799,20 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene,
+                         NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
         else
-            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene,
+                         NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
     }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
-        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pnen,
+                     NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
 
     if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
+        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2,
+                                   p_FmPort->orFmanCtrl) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     p_FmPort->requiredAction = 0;
@@ -1587,23 +1820,23 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     return E_OK;
 }
 
-
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
 
 void FmPortSetMacsecLcv(t_Handle h_FmPort)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t           *p_BmiCfgReg = NULL;
-    uint32_t                    macsecEn = BMI_PORT_CFG_EN_MACSEC;
-    uint32_t                    lcv, walking1Mask = 0x80000000;
-    uint8_t                     cnt = 0;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiCfgReg = NULL;
+    uint32_t macsecEn = BMI_PORT_CFG_EN_MACSEC;
+    uint32_t lcv, walking1Mask = 0x80000000;
+    uint8_t cnt = 0;
 
     SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
     {
         REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Rx ports only"));
         return;
@@ -1611,7 +1844,9 @@ void FmPortSetMacsecLcv(t_Handle h_FmPort)
 
     p_BmiCfgReg = &p_FmPort->port.bmi_regs->rx.fmbm_rcfg;
     /* get LCV for MACSEC */
-    if ((p_FmPort->h_FmPcd) && ((lcv = FmPcdGetMacsecLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId))!= 0))
+    if ((p_FmPort->h_FmPcd)
+            && ((lcv = FmPcdGetMacsecLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId))
+                    != 0))
     {
         while (!(lcv & walking1Mask))
         {
@@ -1620,21 +1855,22 @@ void FmPortSetMacsecLcv(t_Handle h_FmPort)
         }
 
         macsecEn |= (uint32_t)cnt << BMI_PORT_CFG_MS_SEL_SHIFT;
-     }
+    }
 
-     WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | macsecEn);
+    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | macsecEn);
 }
 
 void FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t           *p_BmiCfgReg = NULL;
-    uint32_t                    tmpReg;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiCfgReg = NULL;
+    uint32_t tmpReg;
 
     SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
     {
         REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Tx ports only"));
         return;
@@ -1643,7 +1879,8 @@ void FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci)
     p_BmiCfgReg = &p_FmPort->port.bmi_regs->tx.fmbm_tfca;
     tmpReg = GET_UINT32(*p_BmiCfgReg) & ~BMI_CMD_ATTR_MACCMD_MASK;
     tmpReg |= BMI_CMD_ATTR_MACCMD_SECURED;
-    tmpReg |= (((uint32_t)dfltSci << BMI_CMD_ATTR_MACCMD_SC_SHIFT) & BMI_CMD_ATTR_MACCMD_SC_MASK);
+    tmpReg |= (((uint32_t)dfltSci << BMI_CMD_ATTR_MACCMD_SC_SHIFT)
+            & BMI_CMD_ATTR_MACCMD_SC_MASK);
 
     WRITE_UINT32(*p_BmiCfgReg, tmpReg);
 }
@@ -1664,10 +1901,11 @@ uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
 }
 
 #if (DPAA_VERSION >= 11)
-t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **p_Value)
+t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc,
+                         void **p_Value)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t            muramPageOffset;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t muramPageOffset;
 
     ASSERT_COND(p_FmPort);
     ASSERT_COND(p_Value);
@@ -1675,7 +1913,8 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
     if (p_FmPort->gprFunc != e_FM_PORT_GPR_EMPTY)
     {
         if (p_FmPort->gprFunc != gprFunc)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("gpr was assigned with different func"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("gpr was assigned with different func"));
     }
     else
     {
@@ -1683,25 +1922,30 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
         {
             case (e_FM_PORT_GPR_MURAM_PAGE):
                 p_FmPort->p_ParamsPage = FM_MURAM_AllocMem(p_FmPort->h_FmMuram,
-                                                           256,
-                                                           8);
+                                                           256, 8);
                 if (!p_FmPort->p_ParamsPage)
                     RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for page"));
 
                 IOMemSet32(p_FmPort->p_ParamsPage, 0, 256);
-                muramPageOffset = (uint32_t)(XX_VirtToPhys(p_FmPort->p_ParamsPage) -
-                                             p_FmPort->fmMuramPhysBaseAddr);
+                muramPageOffset =
+                        (uint32_t)(XX_VirtToPhys(p_FmPort->p_ParamsPage)
+                                - p_FmPort->fmMuramPhysBaseAddr);
                 switch (p_FmPort->portType)
                 {
                     case (e_FM_PORT_TYPE_RX_10G):
                     case (e_FM_PORT_TYPE_RX):
-                        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr, muramPageOffset);
+                        WRITE_UINT32(
+                                p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr,
+                                muramPageOffset);
                         break;
                     case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-                        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ogpr, muramPageOffset);
+                        WRITE_UINT32(
+                                p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ogpr,
+                                muramPageOffset);
                         break;
                     default:
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                     ("Invalid port type"));
                 }
                 break;
             default:
@@ -1723,29 +1967,33 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
 }
 #endif /* (DPAA_VERSION >= 11) */
 
-t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcParams)
+t_Error FmPortGetSetCcParams(t_Handle h_FmPort,
+                             t_FmPortGetSetCcParams *p_CcParams)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    int                 tmpInt;
-    volatile uint32_t   *p_BmiPrsStartOffset = NULL;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int tmpInt;
+    volatile uint32_t *p_BmiPrsStartOffset = NULL;
 
     /* this function called from Cc for pass and receive parameters port params between CC and PORT*/
 
-    if ((p_CcParams->getCcParams.type & OFFSET_OF_PR) &&
-        (p_FmPort->bufferOffsets.prsResultOffset != ILLEGAL_BASE))
+    if ((p_CcParams->getCcParams.type & OFFSET_OF_PR)
+            && (p_FmPort->bufferOffsets.prsResultOffset != ILLEGAL_BASE))
     {
-        p_CcParams->getCcParams.prOffset = (uint8_t)p_FmPort->bufferOffsets.prsResultOffset;
+        p_CcParams->getCcParams.prOffset =
+                (uint8_t)p_FmPort->bufferOffsets.prsResultOffset;
         p_CcParams->getCcParams.type &= ~OFFSET_OF_PR;
     }
     if (p_CcParams->getCcParams.type & HW_PORT_ID)
     {
-        p_CcParams->getCcParams.hardwarePortId = (uint8_t)p_FmPort->hardwarePortId;
+        p_CcParams->getCcParams.hardwarePortId =
+                (uint8_t)p_FmPort->hardwarePortId;
         p_CcParams->getCcParams.type &= ~HW_PORT_ID;
     }
-    if ((p_CcParams->getCcParams.type & OFFSET_OF_DATA) &&
-        (p_FmPort->bufferOffsets.dataOffset != ILLEGAL_BASE))
+    if ((p_CcParams->getCcParams.type & OFFSET_OF_DATA)
+            && (p_FmPort->bufferOffsets.dataOffset != ILLEGAL_BASE))
     {
-        p_CcParams->getCcParams.dataOffset = (uint16_t)p_FmPort->bufferOffsets.dataOffset;
+        p_CcParams->getCcParams.dataOffset =
+                (uint16_t)p_FmPort->bufferOffsets.dataOffset;
         p_CcParams->getCcParams.type &= ~OFFSET_OF_DATA;
     }
     if (p_CcParams->getCcParams.type & NUM_OF_TASKS)
@@ -1755,7 +2003,8 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     if (p_CcParams->getCcParams.type & NUM_OF_EXTRA_TASKS)
     {
-        p_CcParams->getCcParams.numOfExtraTasks = (uint8_t)p_FmPort->tasks.extra;
+        p_CcParams->getCcParams.numOfExtraTasks =
+                (uint8_t)p_FmPort->tasks.extra;
         p_CcParams->getCcParams.type &= ~NUM_OF_EXTRA_TASKS;
     }
     if (p_CcParams->getCcParams.type & FM_REV)
@@ -1768,103 +2017,117 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             p_CcParams->getCcParams.discardMask =
-                GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm);
+                    GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm);
         else
             p_CcParams->getCcParams.discardMask =
-                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm);
+                    GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm);
         p_CcParams->getCcParams.type &= ~DISCARD_MASK;
     }
     if (p_CcParams->getCcParams.type & MANIP_EXTRA_SPACE)
     {
-        p_CcParams->getCcParams.internalBufferOffset = p_FmPort->internalBufferOffset;
+        p_CcParams->getCcParams.internalBufferOffset =
+                p_FmPort->internalBufferOffset;
         p_CcParams->getCcParams.type &= ~MANIP_EXTRA_SPACE;
     }
     if (p_CcParams->getCcParams.type & GET_NIA_FPNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne);
+            p_CcParams->getCcParams.nia =
+                    GET_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne);
         else
-            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne);
+            p_CcParams->getCcParams.nia =
+                    GET_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne);
         p_CcParams->getCcParams.type &= ~GET_NIA_FPNE;
     }
     if (p_CcParams->getCcParams.type & GET_NIA_PNDN)
     {
         if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-        p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn);
+        p_CcParams->getCcParams.nia =
+                GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn);
         p_CcParams->getCcParams.type &= ~GET_NIA_PNDN;
     }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY) &&
-        !(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY))
+    if ((p_CcParams->setCcParams.type & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+            && !(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY))
     {
         p_FmPort->requiredAction |= UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         p_FmPort->orFmanCtrl = p_CcParams->setCcParams.orFmanCtrl;
     }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNEN) &&
-        !(p_FmPort->requiredAction & UPDATE_NIA_PNEN))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
+            && !(p_FmPort->requiredAction & UPDATE_NIA_PNEN))
     {
         p_FmPort->savedQmiPnen = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_PNEN;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
-    {
-       if (p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNEN was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
+        {
+            if (p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("PNEN was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNDN) &&
-        !(p_FmPort->requiredAction & UPDATE_NIA_PNDN))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
+            && !(p_FmPort->requiredAction & UPDATE_NIA_PNDN))
     {
         p_FmPort->savedNonRxQmiRegsPndn = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_PNDN;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
-    {
-        if (p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNDN was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
+        {
+            if (p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("PNDN was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FENE) &&
-        (p_CcParams->setCcParams.overwrite ||
-         !(p_FmPort->requiredAction & UPDATE_NIA_FENE)))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
+            && (p_CcParams->setCcParams.overwrite
+                    || !(p_FmPort->requiredAction & UPDATE_NIA_FENE)))
     {
         p_FmPort->savedBmiFene = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_FENE;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
-    {
-       if (p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFENE was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
+        {
+            if (p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
+                RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                             ("xFENE was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FPNE) &&
-        !(p_FmPort->requiredAction & UPDATE_NIA_FPNE))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
+            && !(p_FmPort->requiredAction & UPDATE_NIA_FPNE))
     {
         p_FmPort->savedBmiFpne = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_FPNE;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
-    {
-       if (p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFPNE was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
+        {
+            if (p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
+                RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                             ("xFPNE was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_CMNE) &&
-        !(p_FmPort->requiredAction & UPDATE_NIA_CMNE))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
+            && !(p_FmPort->requiredAction & UPDATE_NIA_CMNE))
     {
         p_FmPort->savedBmiCmne = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_CMNE;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
-    {
-       if (p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xCMNE was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
+        {
+            if (p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
+                RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                             ("xCMNE was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_PSO) &&
-        !(p_FmPort->requiredAction & UPDATE_PSO))
+    if ((p_CcParams->setCcParams.type & UPDATE_PSO)
+            && !(p_FmPort->requiredAction & UPDATE_PSO))
     {
         /* get PCD registers pointers */
         switch (p_FmPort->portType)
@@ -1881,36 +2144,53 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         }
 
         /* set start parsing offset */
-        tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)+ p_CcParams->setCcParams.psoSize;
-        if (tmpInt>0)
+        tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)
+                + p_CcParams->setCcParams.psoSize;
+        if (tmpInt > 0)
             WRITE_UINT32(*p_BmiPrsStartOffset, (uint32_t)tmpInt);
 
         p_FmPort->requiredAction |= UPDATE_PSO;
         p_FmPort->savedPrsStartOffset = p_CcParams->setCcParams.psoSize;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_PSO)
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_PSO)
+        {
+            if (p_FmPort->savedPrsStartOffset
+                    != p_CcParams->setCcParams.psoSize)
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("parser start offset was defoned previousley different"));
+        }
+
+    if ((p_CcParams->setCcParams.type & UPDATE_OFP_DPTE)
+            && !(p_FmPort->requiredAction & UPDATE_OFP_DPTE))
     {
-        if (p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser start offset was defoned previousley different"));
+        if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+        p_FmPort->savedBmiOfp = GET_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofp);
+        p_FmPort->savedBmiOfp &= ~BMI_FIFO_PIPELINE_DEPTH_MASK;
+        p_FmPort->savedBmiOfp |= p_CcParams->setCcParams.ofpDpde
+                << BMI_FIFO_PIPELINE_DEPTH_SHIFT;
+        p_FmPort->requiredAction |= UPDATE_OFP_DPTE;
     }
 
     return E_OK;
 }
 /*********************** End of inter-module routines ************************/
 
-
 /****************************************/
 /*       API Init unit functions        */
 /****************************************/
 
 t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 {
-    t_FmPort            *p_FmPort;
-    uintptr_t           baseAddr = p_FmPortParams->baseAddr;
-    uint32_t            tmpReg;
+    t_FmPort *p_FmPort;
+    uintptr_t baseAddr = p_FmPortParams->baseAddr;
+    uint32_t tmpReg;
 
     /* Allocate FM structure */
-    p_FmPort = (t_FmPort *) XX_Malloc(sizeof(t_FmPort));
+    p_FmPort = (t_FmPort *)XX_Malloc(sizeof(t_FmPort));
     if (!p_FmPort)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port driver structure"));
@@ -1919,7 +2199,8 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     memset(p_FmPort, 0, sizeof(t_FmPort));
 
     /* Allocate the FM driver's parameters structure */
-    p_FmPort->p_FmPortDriverParam = (t_FmPortDriverParam *)XX_Malloc(sizeof(t_FmPortDriverParam));
+    p_FmPort->p_FmPortDriverParam = (t_FmPortDriverParam *)XX_Malloc(
+            sizeof(t_FmPortDriverParam));
     if (!p_FmPort->p_FmPortDriverParam)
     {
         XX_Free(p_FmPort);
@@ -1929,46 +2210,51 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     memset(p_FmPort->p_FmPortDriverParam, 0, sizeof(t_FmPortDriverParam));
 
     /* Initialize FM port parameters which will be kept by the driver */
-    p_FmPort->portType      = p_FmPortParams->portType;
-    p_FmPort->portId        = p_FmPortParams->portId;
-    p_FmPort->pcdEngines    = FM_PCD_NONE;
-    p_FmPort->f_Exception   = p_FmPortParams->f_Exception;
-    p_FmPort->h_App         = p_FmPortParams->h_App;
-    p_FmPort->h_Fm          = p_FmPortParams->h_Fm;
+    p_FmPort->portType = p_FmPortParams->portType;
+    p_FmPort->portId = p_FmPortParams->portId;
+    p_FmPort->pcdEngines = FM_PCD_NONE;
+    p_FmPort->f_Exception = p_FmPortParams->f_Exception;
+    p_FmPort->h_App = p_FmPortParams->h_App;
+    p_FmPort->h_Fm = p_FmPortParams->h_Fm;
 
     /* get FM revision */
     FM_GetRevision(p_FmPort->h_Fm, &p_FmPort->fmRevInfo);
 
     /* calculate global portId number */
-    SW_PORT_ID_TO_HW_PORT_ID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
+    SW_PORT_ID_TO_HW_PORT_ID(p_FmPort->hardwarePortId, p_FmPort->portType,
+                             p_FmPortParams->portId);
 
     if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
-            (p_FmPortParams->portId != FM_OH_PORT_ID))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+                && (p_FmPortParams->portId != FM_OH_PORT_ID))
             DBG(WARNING,
-                ("Port ID %d is recommended for HC port. Overwriting HW defaults to be suitable for HC.",
-                 FM_OH_PORT_ID));
+                    ("Port ID %d is recommended for HC port. Overwriting HW defaults to be suitable for HC.",
+                            FM_OH_PORT_ID));
 
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
-            (p_FmPortParams->portId == FM_OH_PORT_ID))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+                && (p_FmPortParams->portId == FM_OH_PORT_ID))
             DBG(WARNING, ("Use non-zero portId for OP port due to insufficient resources on portId 0."));
     }
 
     /* Set up FM port parameters for initialization phase only */
 
     /* First, fill in flibs struct */
-    fman_port_defconfig(&p_FmPort->p_FmPortDriverParam->dfltCfg, (enum fman_port_type)p_FmPort->portType);
+    fman_port_defconfig(&p_FmPort->p_FmPortDriverParam->dfltCfg,
+                        (enum fman_port_type)p_FmPort->portType);
     /* Overwrite some integration specific parameters */
-    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_pri_elevation = DEFAULT_PORT_rxFifoPriElevationLevel;
-    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_fifo_thr = DEFAULT_PORT_rxFifoThreshold;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_pri_elevation =
+            DEFAULT_PORT_rxFifoPriElevationLevel;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_fifo_thr =
+            DEFAULT_PORT_rxFifoThreshold;
 
 #if defined(FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675) || defined(FM_ERROR_VSP_NO_MATCH_SW006)
     p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006675 = TRUE;
 #else
     p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006675 = FALSE;
 #endif
-    if ((p_FmPort->fmRevInfo.majorRev == 6) && (p_FmPort->fmRevInfo.minorRev == 0))
+    if ((p_FmPort->fmRevInfo.majorRev == 6)
+            && (p_FmPort->fmRevInfo.minorRev == 0))
         p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006320 = TRUE;
     else
         p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006320 = FALSE;
@@ -1977,14 +2263,16 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     if (p_FmPort->fmRevInfo.majorRev < 6)
     {
 #ifdef FM_NO_RESTRICT_ON_ACCESS_RSRC
-        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register = TRUE;
+        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register =
+                TRUE;
 #endif
         p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_rebm_has_sgd = FALSE;
         p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_tfne_has_features = FALSE;
     }
     else
     {
-        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register = FALSE;
+        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register =
+                FALSE;
         p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_rebm_has_sgd = TRUE;
         p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_tfne_has_features = TRUE;
     }
@@ -1994,246 +2282,304 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         p_FmPort->p_FmPortDriverParam->dfltCfg.qmi_deq_options_support = TRUE;
 
     /* Continue with other parameters */
-    p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
+    p_FmPort->p_FmPortDriverParam->baseAddr = baseAddr;
     /* set memory map pointers */
-    p_FmPort->p_FmPortQmiRegs     = (t_FmPortQmiRegs *)UINT_TO_PTR(baseAddr + QMI_PORT_REGS_OFFSET);
-    p_FmPort->p_FmPortBmiRegs     = (u_FmPortBmiRegs *)UINT_TO_PTR(baseAddr + BMI_PORT_REGS_OFFSET);
-    p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(baseAddr + PRS_PORT_REGS_OFFSET);
-
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize = DEFAULT_PORT_bufferPrefixContent_privDataSize;
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult= DEFAULT_PORT_bufferPrefixContent_passPrsResult;
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp= DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo
-                                                                    = DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign    = DEFAULT_PORT_bufferPrefixContent_dataAlign;
-/*    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = (e_FmDmaSwapOption)DEFAULT_PORT_dmaSwapData;
-    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = (e_FmDmaCacheOption)DEFAULT_PORT_dmaIntContextCacheAttr;
-    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = (e_FmDmaCacheOption)DEFAULT_PORT_dmaHeaderCacheAttr;
-    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = (e_FmDmaCacheOption)DEFAULT_PORT_dmaScatterGatherCacheAttr;
-    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
-*/    p_FmPort->p_FmPortDriverParam->liodnBase                        = p_FmPortParams->liodnBase;
-    p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore           = DEFAULT_PORT_cheksumLastBytesIgnore;
-
-    p_FmPort->maxFrameLength                                        = DEFAULT_PORT_maxFrameLength;
+    p_FmPort->p_FmPortQmiRegs =
+            (t_FmPortQmiRegs *)UINT_TO_PTR(baseAddr + QMI_PORT_REGS_OFFSET);
+    p_FmPort->p_FmPortBmiRegs =
+            (u_FmPortBmiRegs *)UINT_TO_PTR(baseAddr + BMI_PORT_REGS_OFFSET);
+    p_FmPort->p_FmPortPrsRegs =
+            (t_FmPortPrsRegs *)UINT_TO_PTR(baseAddr + PRS_PORT_REGS_OFFSET);
+
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize =
+            DEFAULT_PORT_bufferPrefixContent_privDataSize;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult =
+            DEFAULT_PORT_bufferPrefixContent_passPrsResult;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp =
+            DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo =
+            DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign =
+            DEFAULT_PORT_bufferPrefixContent_dataAlign;
+    /*    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = (e_FmDmaSwapOption)DEFAULT_PORT_dmaSwapData;
+     p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = (e_FmDmaCacheOption)DEFAULT_PORT_dmaIntContextCacheAttr;
+     p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = (e_FmDmaCacheOption)DEFAULT_PORT_dmaHeaderCacheAttr;
+     p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = (e_FmDmaCacheOption)DEFAULT_PORT_dmaScatterGatherCacheAttr;
+     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
+     */
+    p_FmPort->p_FmPortDriverParam->liodnBase = p_FmPortParams->liodnBase;
+    p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore =
+            DEFAULT_PORT_cheksumLastBytesIgnore;
+
+    p_FmPort->maxFrameLength = DEFAULT_PORT_maxFrameLength;
     /* resource distribution. */
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
     if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
     {
-        p_FmPort->fifoBufs.num                                      = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
-        p_FmPort->fifoBufs.extra                                    = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
-        p_FmPort->openDmas.num                                      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
-        p_FmPort->openDmas.extra                                    = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
-        p_FmPort->tasks.num                                         = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
-        p_FmPort->tasks.extra                                       = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+        p_FmPort->fifoBufs.num = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)
+                * BMI_FIFO_UNITS;
+        p_FmPort->fifoBufs.extra = DEFAULT_PORT_extraNumOfFifoBufs
+                * BMI_FIFO_UNITS;
+        p_FmPort->openDmas.num = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
+        p_FmPort->openDmas.extra =
+                DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+        p_FmPort->tasks.num = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+        p_FmPort->tasks.extra = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
     }
     else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
     {
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
-            (p_FmPortParams->portId != FM_OH_PORT_ID))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+                && (p_FmPortParams->portId != FM_OH_PORT_ID))
         {
             /* Overwrite HC defaults */
-            p_FmPort->fifoBufs.num      = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
-            p_FmPort->fifoBufs.extra    = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
-            p_FmPort->openDmas.num      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
-            p_FmPort->openDmas.extra    = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
-            p_FmPort->tasks.num         = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
-            p_FmPort->tasks.extra       = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+            p_FmPort->fifoBufs.num =
+                    DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)
+                            * BMI_FIFO_UNITS;
+            p_FmPort->fifoBufs.extra = DEFAULT_PORT_extraNumOfFifoBufs
+                    * BMI_FIFO_UNITS;
+            p_FmPort->openDmas.num =
+                    DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
+            p_FmPort->openDmas.extra =
+                    DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+            p_FmPort->tasks.num = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+            p_FmPort->tasks.extra =
+                    DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
         }
         else
         {
-            p_FmPort->fifoBufs.num                                      = 0;
-            p_FmPort->fifoBufs.extra                                    = 0;
-            p_FmPort->openDmas.num                                      = 0;
-            p_FmPort->openDmas.extra                                    = 0;
-            p_FmPort->tasks.num                                         = 0;
-            p_FmPort->tasks.extra                                       = 0;
+            p_FmPort->fifoBufs.num = 0;
+            p_FmPort->fifoBufs.extra = 0;
+            p_FmPort->openDmas.num = 0;
+            p_FmPort->openDmas.extra = 0;
+            p_FmPort->tasks.num = 0;
+            p_FmPort->tasks.extra = 0;
         }
     }
 
 #ifdef FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981
-    if ((p_FmPort->fmRevInfo.majorRev == 6) &&
-        (p_FmPort->fmRevInfo.minorRev == 0) &&
-        ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-         (p_FmPort->portType == e_FM_PORT_TYPE_TX)))
-        {
-            p_FmPort->openDmas.num = 16;
-            p_FmPort->openDmas.extra = 0;
-        }
+    if ((p_FmPort->fmRevInfo.majorRev == 6)
+            && (p_FmPort->fmRevInfo.minorRev == 0)
+            && ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_TX)))
+    {
+        p_FmPort->openDmas.num = 16;
+        p_FmPort->openDmas.extra = 0;
+    }
 #endif /* FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981 */
 
     /* Port type specific initialization: */
     switch (p_FmPort->portType)
     {
-    case (e_FM_PORT_TYPE_RX):
-    case (e_FM_PORT_TYPE_RX_10G):
-        /* Initialize FM port parameters for initialization phase only */
-        p_FmPort->p_FmPortDriverParam->cutBytesFromEnd              = DEFAULT_PORT_cutBytesFromEnd;
-        p_FmPort->p_FmPortDriverParam->enBufPoolDepletion           = FALSE;
-        p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
+        case (e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+            /* Initialize FM port parameters for initialization phase only */
+            p_FmPort->p_FmPortDriverParam->cutBytesFromEnd =
+                    DEFAULT_PORT_cutBytesFromEnd;
+            p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = FALSE;
+            p_FmPort->p_FmPortDriverParam->frmDiscardOverride =
+                    DEFAULT_PORT_frmDiscardOverride;
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-    {
-        p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = DEFAULT_PORT_rxFifoPriElevationLevel;
-        p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = DEFAULT_PORT_rxFifoThreshold;
-    }
-    else
+            if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
+            {
+                p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel =
+                        DEFAULT_PORT_rxFifoPriElevationLevel;
+                p_FmPort->p_FmPortDriverParam->rxFifoThreshold =
+                        DEFAULT_PORT_rxFifoThreshold;
+            }
+            else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
-    {
-        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfp);
-        p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = (((tmpReg & BMI_RX_FIFO_PRI_ELEVATION_MASK) >> BMI_RX_FIFO_PRI_ELEVATION_SHIFT) + 1) * BMI_FIFO_UNITS ;
-        p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = (((tmpReg  & BMI_RX_FIFO_THRESHOLD_MASK) >> BMI_RX_FIFO_THRESHOLD_SHIFT) + 1) * BMI_FIFO_UNITS;
-    }
+            {
+                tmpReg =
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfp);
+                p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel =
+                        (((tmpReg & BMI_RX_FIFO_PRI_ELEVATION_MASK)
+                                >> BMI_RX_FIFO_PRI_ELEVATION_SHIFT) + 1)
+                                * BMI_FIFO_UNITS;
+                p_FmPort->p_FmPortDriverParam->rxFifoThreshold = (((tmpReg
+                        & BMI_RX_FIFO_THRESHOLD_MASK)
+                        >> BMI_RX_FIFO_THRESHOLD_SHIFT) + 1) * BMI_FIFO_UNITS;
+            }
 
-        p_FmPort->p_FmPortDriverParam->bufMargins.endMargins        = DEFAULT_PORT_BufMargins_endMargins;
-        p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
-        p_FmPort->p_FmPortDriverParam->forwardReuseIntContext       = DEFAULT_PORT_forwardIntContextReuse;
+            p_FmPort->p_FmPortDriverParam->bufMargins.endMargins =
+                    DEFAULT_PORT_BufMargins_endMargins;
+            p_FmPort->p_FmPortDriverParam->errorsToDiscard =
+                    DEFAULT_PORT_errorsToDiscard;
+            p_FmPort->p_FmPortDriverParam->forwardReuseIntContext =
+                    DEFAULT_PORT_forwardIntContextReuse;
 #if (DPAA_VERSION >= 11)
-        p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
+            p_FmPort->p_FmPortDriverParam->noScatherGather =
+                    DEFAULT_PORT_noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
-        break;
+            break;
 
-    case (e_FM_PORT_TYPE_TX):
-        p_FmPort->p_FmPortDriverParam->dontReleaseBuf               = FALSE;
+        case (e_FM_PORT_TYPE_TX):
+            p_FmPort->p_FmPortDriverParam->dontReleaseBuf = FALSE;
 #ifdef FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
-        tmpReg = 0x00001013;
-        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp, tmpReg);
+            tmpReg = 0x00001013;
+            WRITE_UINT32( p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp,
+                         tmpReg);
 #endif /* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 */
-    case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX_10G):
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-        if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-        {
-            p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel       = DEFAULT_PORT_txFifoMinFillLevel;
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth                          =
-                (uint8_t)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
-                          DEFAULT_PORT_fifoDeqPipelineDepth_1G :
-                          DEFAULT_PORT_fifoDeqPipelineDepth_10G);
-            p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel       = DEFAULT_PORT_txFifoLowComfLevel;
-        }
-        else
+            if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
+            {
+                p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel =
+                        DEFAULT_PORT_txFifoMinFillLevel;
+                p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+                        (uint8_t)(
+                                (p_FmPort->portType == e_FM_PORT_TYPE_TX) ? DEFAULT_PORT_fifoDeqPipelineDepth_1G :
+                                        DEFAULT_PORT_fifoDeqPipelineDepth_10G);
+                p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel =
+                        DEFAULT_PORT_txFifoLowComfLevel;
+            }
+            else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
-        {
-            tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp);
-            p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel =
-                ((tmpReg & BMI_TX_FIFO_MIN_FILL_MASK) >> BMI_TX_FIFO_MIN_FILL_SHIFT) * BMI_FIFO_UNITS ;
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
-                (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK) >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
-            p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel =
-                (((tmpReg & BMI_TX_LOW_COMF_MASK) >> BMI_TX_LOW_COMF_SHIFT) + 1) * BMI_FIFO_UNITS;
-        }
+            {
+                tmpReg =
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp);
+                p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = ((tmpReg
+                        & BMI_TX_FIFO_MIN_FILL_MASK)
+                        >> BMI_TX_FIFO_MIN_FILL_SHIFT) * BMI_FIFO_UNITS;
+                p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+                        (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK)
+                                >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
+                p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = (((tmpReg
+                        & BMI_TX_LOW_COMF_MASK) >> BMI_TX_LOW_COMF_SHIFT) + 1)
+                        * BMI_FIFO_UNITS;
+            }
 
-        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
-        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
-        p_FmPort->p_FmPortDriverParam->deqHighPriority              =
-            (bool)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
-                   DEFAULT_PORT_deqHighPriority_1G :
-                   DEFAULT_PORT_deqHighPriority_10G);
-        p_FmPort->p_FmPortDriverParam->deqByteCnt                   =
-            (uint16_t)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
-                       DEFAULT_PORT_deqByteCnt_1G :
-                       DEFAULT_PORT_deqByteCnt_10G);
-        break;
-    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
+            p_FmPort->p_FmPortDriverParam->deqType = DEFAULT_PORT_deqType;
+            p_FmPort->p_FmPortDriverParam->deqPrefetchOption =
+                    DEFAULT_PORT_deqPrefetchOption;
+            p_FmPort->p_FmPortDriverParam->deqHighPriority =
+                    (bool)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ? DEFAULT_PORT_deqHighPriority_1G :
+                            DEFAULT_PORT_deqHighPriority_10G);
+            p_FmPort->p_FmPortDriverParam->deqByteCnt =
+                    (uint16_t)(
+                            (p_FmPort->portType == e_FM_PORT_TYPE_TX) ? DEFAULT_PORT_deqByteCnt_1G :
+                                    DEFAULT_PORT_deqByteCnt_10G);
+            break;
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_FmPort->p_FmPortDriverParam->errorsToDiscard =
+                    DEFAULT_PORT_errorsToDiscard;
 #if (DPAA_VERSION >= 11)
-        p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
+            p_FmPort->p_FmPortDriverParam->noScatherGather =
+                    DEFAULT_PORT_noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
-    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
-        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
-        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
-        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_FmPort->p_FmPortDriverParam->deqPrefetchOption =
+                    DEFAULT_PORT_deqPrefetchOption_HC;
+            p_FmPort->p_FmPortDriverParam->deqHighPriority =
+                    DEFAULT_PORT_deqHighPriority_1G;
+            p_FmPort->p_FmPortDriverParam->deqType = DEFAULT_PORT_deqType;
+            p_FmPort->p_FmPortDriverParam->deqByteCnt =
+                    DEFAULT_PORT_deqByteCnt_1G;
 
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-        p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
-    else
+            if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
+                p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+                        DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+            else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
-    {
-        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofp);
-        p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
-            (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK) >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
-            (p_FmPortParams->portId != FM_OH_PORT_ID))
-        {
-            /* Overwrite HC defaults */
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
-        }
-    }
+            {
+                tmpReg =
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofp);
+                p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+                        (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK)
+                                >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
+                if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+                        && (p_FmPortParams->portId != FM_OH_PORT_ID))
+                {
+                    /* Overwrite HC defaults */
+                    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+                            DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+                }
+            }
 
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
-        if (p_FmPort->fmRevInfo.majorRev < 6)
-            p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore   = DEFAULT_notSupported;
+            if (p_FmPort->fmRevInfo.majorRev < 6)
+            p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore = DEFAULT_notSupported;
 #endif /* !FM_FRAME_END_PARAMS_FOR_OP */
 
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
-    if (!((p_FmPort->fmRevInfo.majorRev == 4) ||
-          (p_FmPort->fmRevInfo.majorRev >= 6)))
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth                          = DEFAULT_notSupported;
+            if (!((p_FmPort->fmRevInfo.majorRev == 4) ||
+                            (p_FmPort->fmRevInfo.majorRev >= 6)))
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = DEFAULT_notSupported;
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
-        break;
+            break;
 
-    default:
-        XX_Free(p_FmPort->p_FmPortDriverParam);
-        XX_Free(p_FmPort);
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-        return NULL;
+        default:
+            XX_Free(p_FmPort->p_FmPortDriverParam);
+            XX_Free(p_FmPort);
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+            return NULL;
     }
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_FmPort->fmRevInfo.majorRev == 4)
-        p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
+    p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     p_FmPort->imEn = p_FmPortParams->independentModeEnable;
 
     if (p_FmPort->imEn)
     {
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
-            (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = DEFAULT_PORT_fifoDeqPipelineDepth_IM;
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+                    DEFAULT_PORT_fifoDeqPipelineDepth_IM;
         FmPortConfigIM(p_FmPort, p_FmPortParams);
     }
     else
     {
         switch (p_FmPort->portType)
         {
-        case (e_FM_PORT_TYPE_RX):
-        case (e_FM_PORT_TYPE_RX_10G):
-            /* Initialize FM port parameters for initialization phase only */
-            memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
-                   &p_FmPortParams->specificParams.rxParams.extBufPools,
-                   sizeof(t_FmExtPools));
-            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.rxParams.errFqid;
-            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
-            p_FmPort->p_FmPortDriverParam->liodnOffset                  = p_FmPortParams->specificParams.rxParams.liodnOffset;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_TX):
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
-            p_FmPort->p_FmPortDriverParam->deqSubPortal                 =
-                (uint8_t)(p_FmPortParams->specificParams.nonRxParams.qmChannel & QMI_DEQ_CFG_SUBPORTAL_MASK);
-            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.nonRxParams.dfltFqid;
-            break;
-        default:
-            XX_Free(p_FmPort->p_FmPortDriverParam);
-            XX_Free(p_FmPort);
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-            return NULL;
+            case (e_FM_PORT_TYPE_RX):
+            case (e_FM_PORT_TYPE_RX_10G):
+                /* Initialize FM port parameters for initialization phase only */
+                memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
+                       &p_FmPortParams->specificParams.rxParams.extBufPools,
+                       sizeof(t_FmExtPools));
+                p_FmPort->p_FmPortDriverParam->errFqid =
+                        p_FmPortParams->specificParams.rxParams.errFqid;
+                p_FmPort->p_FmPortDriverParam->dfltFqid =
+                        p_FmPortParams->specificParams.rxParams.dfltFqid;
+                p_FmPort->p_FmPortDriverParam->liodnOffset =
+                        p_FmPortParams->specificParams.rxParams.liodnOffset;
+                break;
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_TX):
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+                p_FmPort->p_FmPortDriverParam->errFqid =
+                        p_FmPortParams->specificParams.nonRxParams.errFqid;
+                p_FmPort->p_FmPortDriverParam->deqSubPortal =
+                        (uint8_t)(p_FmPortParams->specificParams.nonRxParams.qmChannel
+                                & QMI_DEQ_CFG_SUBPORTAL_MASK);
+                p_FmPort->p_FmPortDriverParam->dfltFqid =
+                        p_FmPortParams->specificParams.nonRxParams.dfltFqid;
+                break;
+            default:
+                XX_Free(p_FmPort->p_FmPortDriverParam);
+                XX_Free(p_FmPort);
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+                return NULL;
         }
     }
 
     memset(p_FmPort->name, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-    if (Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
-               FmGetId(p_FmPort->h_Fm),
-               ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
-                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)) ?
-                "OH" : (p_FmPort->portType == e_FM_PORT_TYPE_RX ?
-                        "1g-RX" : (p_FmPort->portType == e_FM_PORT_TYPE_TX ?
-                                   "1g-TX" : (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G ?
-                                              "10g-RX" : "10g-TX")))),
-               p_FmPort->portId) == 0)
+    if (Sprint(
+            p_FmPort->name,
+            "FM-%d-port-%s-%d",
+            FmGetId(p_FmPort->h_Fm),
+            ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)) ? "OH" :
+                    (p_FmPort->portType == e_FM_PORT_TYPE_RX ? "1g-RX" :
+                            (p_FmPort->portType == e_FM_PORT_TYPE_TX ? "1g-TX" :
+                                    (p_FmPort->portType
+                                            == e_FM_PORT_TYPE_RX_10G ? "10g-RX" :
+                                            "10g-TX")))),
+            p_FmPort->portId) == 0)
     {
         XX_Free(p_FmPort->p_FmPortDriverParam);
         XX_Free(p_FmPort);
@@ -2264,32 +2610,32 @@ t_FmPort *tx_port = 0;
  @Param[in]     h_FmPort - FM module descriptor
 
  @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
+ *//***************************************************************************/
 t_Error FM_PORT_Init(t_Handle h_FmPort)
 {
-    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPortDriverParam             *p_DriverParams;
-    t_Error                         errCode;
-    t_FmInterModulePortInitParams   fmParams;
-    t_FmRevisionInfo                revInfo;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortDriverParam *p_DriverParams;
+    t_Error errCode;
+    t_FmInterModulePortInitParams fmParams;
+    t_FmRevisionInfo revInfo;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    errCode = FmSpBuildBufferStructure(&p_FmPort->p_FmPortDriverParam->intContext,
-                                       &p_FmPort->p_FmPortDriverParam->bufferPrefixContent,
-                                       &p_FmPort->p_FmPortDriverParam->bufMargins,
-                                       &p_FmPort->bufferOffsets,
-                                       &p_FmPort->internalBufferOffset);
+    errCode = FmSpBuildBufferStructure(
+            &p_FmPort->p_FmPortDriverParam->intContext,
+            &p_FmPort->p_FmPortDriverParam->bufferPrefixContent,
+            &p_FmPort->p_FmPortDriverParam->bufMargins,
+            &p_FmPort->bufferOffsets, &p_FmPort->internalBufferOffset);
     if (errCode != E_OK)
         RETURN_ERROR(MAJOR, errCode, NO_MSG);
 #ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
     if ((p_FmPort->p_FmPortDriverParam->bcbWorkaround) &&
-           (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+            (p_FmPort->portType == e_FM_PORT_TYPE_RX))
     {
         p_FmPort->p_FmPortDriverParam->errorsToDiscard |= FM_PORT_FRM_ERR_PHYSICAL;
         if (!p_FmPort->fifoBufs.num)
-            p_FmPort->fifoBufs.num = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
+        p_FmPort->fifoBufs.num = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
         p_FmPort->fifoBufs.num += 4*KILOBYTE;
     }
 #endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
@@ -2304,38 +2650,38 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     FM_GetRevision(p_FmPort->h_Fm, &revInfo);
     p_FmPort->port.fm_rev_maj = revInfo.majorRev;
     p_FmPort->port.fm_rev_min = revInfo.minorRev;
-    p_FmPort->port.bmi_regs = (union fman_port_bmi_regs *)
-            UINT_TO_PTR(p_DriverParams->baseAddr + BMI_PORT_REGS_OFFSET);
-    p_FmPort->port.qmi_regs = (struct fman_port_qmi_regs *)
-            UINT_TO_PTR(p_DriverParams->baseAddr + QMI_PORT_REGS_OFFSET);
+    p_FmPort->port.bmi_regs =
+            (union fman_port_bmi_regs *)UINT_TO_PTR(p_DriverParams->baseAddr + BMI_PORT_REGS_OFFSET);
+    p_FmPort->port.qmi_regs =
+            (struct fman_port_qmi_regs *)UINT_TO_PTR(p_DriverParams->baseAddr + QMI_PORT_REGS_OFFSET);
     p_FmPort->port.ext_pools_num = (uint8_t)((revInfo.majorRev == 4) ? 4 : 8);
     p_FmPort->port.im_en = p_FmPort->imEn;
-    p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(p_DriverParams->baseAddr + PRS_PORT_REGS_OFFSET);
-
-    if  (((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-         (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-        && !p_FmPort->imEn)
-    {
-            /* Call the external Buffer routine which also checks fifo
-             size and updates it if necessary */
-            /* define external buffer pools and pool depletion*/
-            errCode = SetExtBufferPools(p_FmPort);
-            if (errCode)
-                RETURN_ERROR(MAJOR, errCode, NO_MSG);
-            /* check if the largest external buffer pool is large enough */
-            if (p_DriverParams->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_DriverParams->bufMargins.endMargins >
-                p_FmPort->rxPoolsParams.largestBufSize)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                             ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
-                              p_DriverParams->bufMargins.startMargins,
-                              p_DriverParams->bufMargins.endMargins,
-                              p_FmPort->rxPoolsParams.largestBufSize));
+    p_FmPort->p_FmPortPrsRegs =
+            (t_FmPortPrsRegs *)UINT_TO_PTR(p_DriverParams->baseAddr + PRS_PORT_REGS_OFFSET);
+
+    if (((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX)) && !p_FmPort->imEn)
+    {
+        /* Call the external Buffer routine which also checks fifo
+         size and updates it if necessary */
+        /* define external buffer pools and pool depletion*/
+        errCode = SetExtBufferPools(p_FmPort);
+        if (errCode)
+            RETURN_ERROR(MAJOR, errCode, NO_MSG);
+        /* check if the largest external buffer pool is large enough */
+        if (p_DriverParams->bufMargins.startMargins + MIN_EXT_BUF_SIZE
+                + p_DriverParams->bufMargins.endMargins
+                > p_FmPort->rxPoolsParams.largestBufSize)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)", p_DriverParams->bufMargins.startMargins, p_DriverParams->bufMargins.endMargins, p_FmPort->rxPoolsParams.largestBufSize));
     }
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
     {
         {
 #ifdef FM_NO_OP_OBSERVED_POOLS
-            t_FmRevisionInfo        revInfo;
+            t_FmRevisionInfo revInfo;
 
             FM_GetRevision(p_FmPort->h_Fm, &revInfo);
             if ((revInfo.majorRev == 4) && (p_DriverParams->enBufPoolDepletion))
@@ -2353,11 +2699,11 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     /* Call FM module routine for communicating parameters      */
     /************************************************************/
     memset(&fmParams, 0, sizeof(fmParams));
-    fmParams.hardwarePortId     = p_FmPort->hardwarePortId;
-    fmParams.portType           = (e_FmPortType)p_FmPort->portType;
-    fmParams.numOfTasks         = (uint8_t)p_FmPort->tasks.num;
-    fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
-    fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
+    fmParams.hardwarePortId = p_FmPort->hardwarePortId;
+    fmParams.portType = (e_FmPortType)p_FmPort->portType;
+    fmParams.numOfTasks = (uint8_t)p_FmPort->tasks.num;
+    fmParams.numOfExtraTasks = (uint8_t)p_FmPort->tasks.extra;
+    fmParams.numOfOpenDmas = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
 
     if (p_FmPort->fifoBufs.num)
@@ -2366,23 +2712,24 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
         if (errCode != E_OK)
             RETURN_ERROR(MAJOR, errCode, NO_MSG);
     }
-    fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
-    fmParams.extraSizeOfFifo    = p_FmPort->fifoBufs.extra;
-    fmParams.independentMode    = p_FmPort->imEn;
-    fmParams.liodnOffset        = p_DriverParams->liodnOffset;
-    fmParams.liodnBase          = p_DriverParams->liodnBase;
-    fmParams.deqPipelineDepth   = p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth;
-    fmParams.maxFrameLength     = p_FmPort->maxFrameLength;
+    fmParams.sizeOfFifo = p_FmPort->fifoBufs.num;
+    fmParams.extraSizeOfFifo = p_FmPort->fifoBufs.extra;
+    fmParams.independentMode = p_FmPort->imEn;
+    fmParams.liodnOffset = p_DriverParams->liodnOffset;
+    fmParams.liodnBase = p_DriverParams->liodnBase;
+    fmParams.deqPipelineDepth =
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth;
+    fmParams.maxFrameLength = p_FmPort->maxFrameLength;
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
     if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
     {
         if (!((p_FmPort->fmRevInfo.majorRev == 4) ||
-                (p_FmPort->fmRevInfo.majorRev >= 6)))
-            /* HC ports do not have fifoDeqPipelineDepth, but it is needed only
-             * for deq threshold calculation.
-             */
-            fmParams.deqPipelineDepth = 2;
+                        (p_FmPort->fmRevInfo.majorRev >= 6)))
+        /* HC ports do not have fifoDeqPipelineDepth, but it is needed only
+         * for deq threshold calculation.
+         */
+        fmParams.deqPipelineDepth = 2;
     }
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
 
@@ -2393,8 +2740,8 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
     /* get params for use in init */
     p_FmPort->fmMuramPhysBaseAddr =
-        (uint64_t)((uint64_t)(fmParams.fmMuramPhysBaseAddr.low) |
-                   ((uint64_t)(fmParams.fmMuramPhysBaseAddr.high) << 32));
+            (uint64_t)((uint64_t)(fmParams.fmMuramPhysBaseAddr.low)
+                    | ((uint64_t)(fmParams.fmMuramPhysBaseAddr.high) << 32));
     p_FmPort->h_FmMuram = FmGetMuramHandle(p_FmPort->h_Fm);
 
 #ifndef FM_NO_GUARANTEED_RESET_VALUES
@@ -2416,41 +2763,43 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     FmPortDriverParamFree(p_FmPort);
 
 #if (DPAA_VERSION >= 11)
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
     {
-        t_FmPcdCtrlParamsPage   *p_ParamsPage;
+        t_FmPcdCtrlParamsPage *p_ParamsPage;
 
-        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
+        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                         (void**)&p_ParamsPage);
         ASSERT_COND(p_ParamsPage);
 
         WRITE_UINT32(p_ParamsPage->misc, FM_CTL_PARAMS_PAGE_ALWAYS_ON);
 #ifdef FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         {
-            WRITE_UINT32(p_ParamsPage->misc,
-                         (GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OP_FIX_EN));
-            WRITE_UINT32(p_ParamsPage->discardMask,
-                         GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
+            WRITE_UINT32(
+                    p_ParamsPage->misc,
+                    (GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OP_FIX_EN));
+            WRITE_UINT32(
+                    p_ParamsPage->discardMask,
+                    GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
         }
 #endif /* FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675 */
 #ifdef FM_ERROR_VSP_NO_MATCH_SW006
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_ParamsPage->errorsDiscardMask,
-                         (GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm) |
-                          GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem)));
+            WRITE_UINT32(
+                    p_ParamsPage->errorsDiscardMask,
+                    (GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm) | GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem)));
         else
-            WRITE_UINT32(p_ParamsPage->errorsDiscardMask,
-                         (GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm) |
-                          GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem)));
+            WRITE_UINT32(
+                    p_ParamsPage->errorsDiscardMask,
+                    (GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm) | GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem)));
 #endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
     }
 #endif /* (DPAA_VERSION >= 11) */
 
     if (p_FmPort->deepSleepVars.autoResMaxSizes)
         FmPortConfigAutoResForDeepSleepSupport1(p_FmPort);
-
     return E_OK;
 }
 
@@ -2459,21 +2808,24 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
  @Description   Frees all resources that were assigned to FM module.
 
-                Calling this routine invalidates the descriptor.
+ Calling this routine invalidates the descriptor.
 
  @Param[in]     h_FmPort - FM module descriptor
 
  @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
+ *//***************************************************************************/
 t_Error FM_PORT_Free(t_Handle h_FmPort)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmInterModulePortFreeParams       fmParams;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmInterModulePortFreeParams fmParams;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     if (p_FmPort->pcdEngines)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
 
     if (p_FmPort->enabled)
     {
@@ -2511,7 +2863,6 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     return E_OK;
 }
 
-
 /*************************************************/
 /*       API Advanced Init unit functions        */
 /*************************************************/
@@ -2560,7 +2911,8 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.deq_high_pri = highPri;
@@ -2574,40 +2926,52 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("not available for Rx ports"));
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_type = (enum fman_port_deq_type)deqType;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_type =
+            (enum fman_port_deq_type)deqType;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption)
+t_Error FM_PORT_ConfigDeqPrefetchOption(
+        t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
-    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_prefetch_opt = (enum fman_port_deq_prefetch)deqPrefetchOption;
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("not available for Rx ports"));
+    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_prefetch_opt =
+            (enum fman_port_deq_prefetch)deqPrefetchOption;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_BackupBmPools)
+t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort,
+                                  t_FmBackupBmPools *p_BackupBmPools)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->p_BackupBmPools = (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
+    p_FmPort->p_FmPortDriverParam->p_BackupBmPools =
+            (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
     if (!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
-    memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmBackupBmPools));
+    memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools,
+           sizeof(t_FmBackupBmPools));
 
     return E_OK;
 }
@@ -2618,78 +2982,95 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.deq_byte_cnt = deqByteCnt;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmBufferPrefixContent *p_FmBufferPrefixContent)
+t_Error FM_PORT_ConfigBufferPrefixContent(
+        t_Handle h_FmPort, t_FmBufferPrefixContent *p_FmBufferPrefixContent)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent, p_FmBufferPrefixContent, sizeof(t_FmBufferPrefixContent));
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent,
+           p_FmBufferPrefixContent, sizeof(t_FmBufferPrefixContent));
     /* if dataAlign was not initialized by user, we return to driver's default */
     if (!p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign)
-        p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign = DEFAULT_PORT_bufferPrefixContent_dataAlign;
+        p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign =
+                DEFAULT_PORT_bufferPrefixContent_dataAlign;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t checksumLastBytesIgnore)
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort,
+                                             uint8_t checksumLastBytesIgnore)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.checksum_bytes_ignore = checksumLastBytesIgnore;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.checksum_bytes_ignore =
+            checksumLastBytesIgnore;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd)
+t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort,
+                                      uint8_t cutBytesFromEnd)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.rx_cut_end_bytes = cutBytesFromEnd;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_BufPoolDepletion)
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort,
+                                    t_FmBufPoolDepletion *p_BufPoolDepletion)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
-    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, p_BufPoolDepletion, sizeof(t_FmBufPoolDepletion));
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, p_BufPoolDepletion,
+           sizeof(t_FmBufPoolDepletion));
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion)
+t_Error FM_PORT_ConfigObservedPoolDepletion(
+        t_Handle h_FmPort,
+        t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
     if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for OP ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
     memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion,
@@ -2710,9 +3091,11 @@ t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools)
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for OP ports only"));
 
-    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmExtPools, sizeof(t_FmExtPools));
+    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmExtPools,
+           sizeof(t_FmExtPools));
 
     return E_OK;
 }
@@ -2723,8 +3106,10 @@ t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dontReleaseBuf = TRUE;
 
@@ -2749,38 +3134,44 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.sync_req = syncReq;
 
     return E_OK;
 }
 
-
 t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.discard_override = override;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort,
+                                      fmPortFrameErrSelect_t errs)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-                                                            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     p_FmPort->p_FmPortDriverParam->errorsToDiscard = errs;
 
@@ -2794,12 +3185,14 @@ t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.dma_swap_data = (enum fman_port_dma_swap)swapData;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.dma_swap_data =
+            (enum fman_port_dma_swap)swapData;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intContextCacheAttr)
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort,
+                                     e_FmDmaCacheOption intContextCacheAttr)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
@@ -2807,12 +3200,13 @@ t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intCo
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.dma_ic_stash_on =
-        (bool)(intContextCacheAttr == e_FM_DMA_STASH);
+            (bool)(intContextCacheAttr == e_FM_DMA_STASH);
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCacheAttr)
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort,
+                                 e_FmDmaCacheOption headerCacheAttr)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
@@ -2820,12 +3214,13 @@ t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCac
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.dma_header_stash_on =
-        (bool)(headerCacheAttr == e_FM_DMA_STASH);
+            (bool)(headerCacheAttr == e_FM_DMA_STASH);
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption scatterGatherCacheAttr)
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(
+        t_Handle h_FmPort, e_FmDmaCacheOption scatterGatherCacheAttr)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
@@ -2833,7 +3228,7 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.dma_sg_stash_on =
-        (bool)(scatterGatherCacheAttr == e_FM_DMA_STASH);
+            (bool)(scatterGatherCacheAttr == e_FM_DMA_STASH);
 
     return E_OK;
 }
@@ -2845,8 +3240,10 @@ t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.dma_write_optimize = optimize;
 
@@ -2870,15 +3267,18 @@ t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather)
 }
 #endif /* (DPAA_VERSION >= 11) */
 
-t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort,
+                                             bool forwardReuse)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
 
@@ -2915,48 +3315,60 @@ t_Error FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort)
 /*       Hidden-DEBUG Only API                      */
 /****************************************************/
 
-t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel)
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort,
+                                         uint32_t minFillLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_min_level = minFillLevel;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth)
+t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort,
+                                           uint8_t deqPipelineDepth)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Rx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("Not available for Rx ports"));
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for IM ports!"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("Not available for IM ports!"));
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = deqPipelineDepth;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+            deqPipelineDepth;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel)
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort,
+                                         uint32_t fifoLowComfLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Tx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_low_comf_level = fifoLowComfLevel;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_low_comf_level =
+            fifoLowComfLevel;
 
     return E_OK;
 }
@@ -2967,22 +3379,27 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.rx_fifo_thr = fifoThreshold;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel)
+t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort,
+                                              uint32_t priElevationLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.rx_pri_elevation = priElevationLevel;
 
@@ -2992,19 +3409,26 @@ t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priEle
 /*       API Run-time Control unit functions        */
 /****************************************************/
 
-t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas)
+t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort,
+                                 t_FmPortRsrc *p_NumOfOpenDmas)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     if ((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
+        RETURN_ERROR( MAJOR, E_INVALID_VALUE,
+                     ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
     if (p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfOpenDmas->num, (uint8_t*)&p_NumOfOpenDmas->extra, FALSE);
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
+    err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId,
+                             (uint8_t*)&p_NumOfOpenDmas->num,
+                             (uint8_t*)&p_NumOfOpenDmas->extra, FALSE);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -3015,8 +3439,8 @@ t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDma
 
 t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
@@ -3025,11 +3449,18 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
 
     if ((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
     if (p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
-
-    err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfTasks->num, (uint8_t*)&p_NumOfTasks->extra, FALSE);
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("NumOfTasks-extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
+
+    err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId,
+                          (uint8_t*)&p_NumOfTasks->num,
+                          (uint8_t*)&p_NumOfTasks->extra, FALSE);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -3040,25 +3471,35 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
 
 t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                             err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     if (!p_SizeOfFifo->num || (p_SizeOfFifo->num > MAX_PORT_FIFO_SIZE))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("SizeOfFifo-num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
     if (p_SizeOfFifo->num % BMI_FIFO_UNITS)
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be divisible by %d", BMI_FIFO_UNITS));
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("SizeOfFifo-num has to be divisible by %d", BMI_FIFO_UNITS));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* extra FIFO size (allowed only to Rx ports) */
-         if (p_SizeOfFifo->extra % BMI_FIFO_UNITS)
-              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-extra has to be divisible by %d", BMI_FIFO_UNITS));
+        if (p_SizeOfFifo->extra % BMI_FIFO_UNITS)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("SizeOfFifo-extra has to be divisible by %d", BMI_FIFO_UNITS));
     }
     else
         if (p_SizeOfFifo->extra)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No SizeOfFifo-extra for non Rx ports"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         (" No SizeOfFifo-extra for non Rx ports"));
 
     memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
 
@@ -3067,11 +3508,8 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    err = FmSetSizeOfFifo(p_FmPort->h_Fm,
-                          p_FmPort->hardwarePortId,
-                          &p_SizeOfFifo->num,
-                          &p_SizeOfFifo->extra,
-                          FALSE);
+    err = FmSetSizeOfFifo(p_FmPort->h_Fm, p_FmPort->hardwarePortId,
+                          &p_SizeOfFifo->num, &p_SizeOfFifo->extra, FALSE);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -3080,20 +3518,22 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
 
 uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              0);
 
     return p_FmPort->bufferOffsets.dataOffset;
 }
 
 uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              NULL);
 
     if (p_FmPort->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
         return NULL;
@@ -3103,10 +3543,11 @@ uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
 
 t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              NULL);
 
     if (p_FmPort->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
         return NULL;
@@ -3116,10 +3557,11 @@ t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
 
 uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              NULL);
 
     if (p_FmPort->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
         return NULL;
@@ -3129,10 +3571,11 @@ uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
 
 uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              NULL);
 
     if (p_FmPort->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
         return NULL;
@@ -3169,19 +3612,19 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
 
 t_Error FM_PORT_Enable(t_Handle h_FmPort)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
     int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     /* Used by FM_PORT_Free routine as indication
-       if to disable port. Thus set it to TRUE prior
-       to enabling itself. This way if part of enable
-       process fails there will be still things
-       to disable during Free. For example, if BMI
-       enable succeeded but QMI failed, still  BMI
-       needs to be disabled by Free. */
+     if to disable port. Thus set it to TRUE prior
+     to enabling itself. This way if part of enable
+     process fails there will be still things
+     to disable during Free. For example, if BMI
+     enable succeeded but QMI failed, still  BMI
+     needs to be disabled by Free. */
     p_FmPort->enabled = TRUE;
 
     if (p_FmPort->imEn)
@@ -3196,47 +3639,52 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
 
 t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint8_t             factor, countUnitBit;
-    uint16_t            baseGran;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint8_t factor, countUnitBit;
+    uint16_t baseGran;
     struct fman_port_rate_limiter params;
-    int                 err;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             baseGran = BMI_RATE_LIMIT_GRAN_TX;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             baseGran = BMI_RATE_LIMIT_GRAN_OP;
-           break;
+            break;
         default:
-           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Tx and Offline parsing ports only"));
     }
 
-    countUnitBit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm);  /* TimeStamp per nano seconds units */
+    countUnitBit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm); /* TimeStamp per nano seconds units */
     /* normally, we use 1 usec as the reference count */
     factor = 1;
     /* if ratelimit is too small for a 1usec factor, multiply the factor */
-    while (p_RateLimit->rateLimit < baseGran/factor)
+    while (p_RateLimit->rateLimit < baseGran / factor)
     {
-        if (countUnitBit==31)
+        if (countUnitBit == 31)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too small"));
 
         countUnitBit++;
         factor <<= 1;
     }
     /* if ratelimit is too large for a 1usec factor, it is also larger than max rate*/
-    if (p_RateLimit->rateLimit > ((uint32_t)baseGran * (1<<10) * (uint32_t)factor))
+    if (p_RateLimit->rateLimit
+            > ((uint32_t)baseGran * (1 << 10) * (uint32_t)factor))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too large"));
 
-    if (!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > BMI_RATE_LIMIT_MAX_BURST_SIZE))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("maxBurstSize must be between 1K and %dk", BMI_RATE_LIMIT_MAX_BURST_SIZE));
+    if (!p_RateLimit->maxBurstSize
+            || (p_RateLimit->maxBurstSize > BMI_RATE_LIMIT_MAX_BURST_SIZE))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("maxBurstSize must be between 1K and %dk", BMI_RATE_LIMIT_MAX_BURST_SIZE));
 
     params.count_1micro_bit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm);
     params.high_burst_size_gran = FALSE;
@@ -3248,25 +3696,31 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
     {
 #ifndef FM_NO_ADVANCED_RATE_LIMITER
 
-        if ((p_FmPort->fmRevInfo.majorRev == 4) || (p_FmPort->fmRevInfo.majorRev >= 6))
+        if ((p_FmPort->fmRevInfo.majorRev == 4)
+                || (p_FmPort->fmRevInfo.majorRev >= 6))
         {
             params.high_burst_size_gran = TRUE;
         }
         else
 #endif /* ! FM_NO_ADVANCED_RATE_LIMITER */
         {
-            if (p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDualRateLimitScaleDown"));
+            if (p_RateLimit->rateLimitDivider
+                    != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                             ("FM_PORT_ConfigDualRateLimitScaleDown"));
 
             if (p_RateLimit->maxBurstSize % 1000)
             {
-                p_RateLimit->maxBurstSize = (uint16_t)((p_RateLimit->maxBurstSize/1000)+1);
+                p_RateLimit->maxBurstSize =
+                        (uint16_t)((p_RateLimit->maxBurstSize / 1000) + 1);
                 DBG(WARNING, ("rateLimit.maxBurstSize rounded up to %d", (p_RateLimit->maxBurstSize/1000+1)*1000));
             }
             else
-                p_RateLimit->maxBurstSize = (uint16_t)(p_RateLimit->maxBurstSize/1000);
+                p_RateLimit->maxBurstSize = (uint16_t)(p_RateLimit->maxBurstSize
+                        / 1000);
         }
-        params.rate_factor = (enum fman_port_rate_limiter_scale_down)p_RateLimit->rateLimitDivider;
+        params.rate_factor =
+                (enum fman_port_rate_limiter_scale_down)p_RateLimit->rateLimitDivider;
         params.burst_size = p_RateLimit->maxBurstSize;
     }
 
@@ -3279,17 +3733,17 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 
 t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    int                 err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-       (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-       (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
-                ("available for Tx and Offline parsing ports only"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Tx and Offline parsing ports only"));
 
     err = fman_port_delete_rate_limiter(&p_FmPort->port);
     if (err != 0)
@@ -3297,37 +3751,43 @@ t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
     return E_OK;
 }
 
-t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio, uint8_t wq)
+t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio,
+                                                uint8_t wq)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t    tmpReg;
-    uint32_t    wqTmpReg;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t tmpReg;
+    uint32_t wqTmpReg;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX) && (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("PFC mapping is available for Tx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("PFC mapping is available for Tx ports only"));
 
     if (prio > 7)
-        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("PFC priority (%d) is out of range (0-7)", prio));
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE,
+                     ("PFC priority (%d) is out of range (0-7)", prio));
     if (wq > 7)
-        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("WQ (%d) is out of range (0-7)", wq));
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE,
+                     ("WQ (%d) is out of range (0-7)", wq));
 
     tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpfcm[0]);
-    tmpReg &= ~(0xf << ((7-prio)*4));
-    wqTmpReg = ((uint32_t)wq << ((7-prio)*4));
+    tmpReg &= ~(0xf << ((7 - prio) * 4));
+    wqTmpReg = ((uint32_t)wq << ((7 - prio) * 4));
     tmpReg |= wqTmpReg;
 
-    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpfcm[0], tmpReg);
+    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpfcm[0],
+                 tmpReg);
 
     return E_OK;
 }
 
 t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    int                     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -3340,8 +3800,8 @@ t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
 
 t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    int                     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -3352,70 +3812,78 @@ t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
     return E_OK;
 }
 
-t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt)
+t_Error FM_PORT_SetPerformanceCountersParams(
+        t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    struct fman_port_perf_cnt_params    params;
-    int                                 err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    struct fman_port_perf_cnt_params params;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     /* check parameters */
-    if (!p_FmPortPerformanceCnt->taskCompVal ||
-        (p_FmPortPerformanceCnt->taskCompVal > p_FmPort->tasks.num))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("taskCompVal (%d) has to be in the range of 1 - %d (current value)!",
-                      p_FmPortPerformanceCnt->taskCompVal,
-                      p_FmPort->tasks.num));
-    if (!p_FmPortPerformanceCnt->dmaCompVal ||
-        (p_FmPortPerformanceCnt->dmaCompVal > p_FmPort->openDmas.num))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("dmaCompVal (%d) has to be in the range of 1 - %d (current value)!",
-                      p_FmPortPerformanceCnt->dmaCompVal,
-                      p_FmPort->openDmas.num));
-    if (!p_FmPortPerformanceCnt->fifoCompVal ||
-        (p_FmPortPerformanceCnt->fifoCompVal > p_FmPort->fifoBufs.num))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("fifoCompVal (%d) has to be in the range of 256 - %d (current value)!",
-                      p_FmPortPerformanceCnt->fifoCompVal,
-                      p_FmPort->fifoBufs.num));
+    if (!p_FmPortPerformanceCnt->taskCompVal
+            || (p_FmPortPerformanceCnt->taskCompVal > p_FmPort->tasks.num))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("taskCompVal (%d) has to be in the range of 1 - %d (current value)!", p_FmPortPerformanceCnt->taskCompVal, p_FmPort->tasks.num));
+    if (!p_FmPortPerformanceCnt->dmaCompVal
+            || (p_FmPortPerformanceCnt->dmaCompVal > p_FmPort->openDmas.num))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("dmaCompVal (%d) has to be in the range of 1 - %d (current value)!", p_FmPortPerformanceCnt->dmaCompVal, p_FmPort->openDmas.num));
+    if (!p_FmPortPerformanceCnt->fifoCompVal
+            || (p_FmPortPerformanceCnt->fifoCompVal > p_FmPort->fifoBufs.num))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("fifoCompVal (%d) has to be in the range of 256 - %d (current value)!", p_FmPortPerformanceCnt->fifoCompVal, p_FmPort->fifoBufs.num));
     if (p_FmPortPerformanceCnt->fifoCompVal % BMI_FIFO_UNITS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("fifoCompVal (%d) has to be divisible by %d",
-                      p_FmPortPerformanceCnt->fifoCompVal,
-                      BMI_FIFO_UNITS));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("fifoCompVal (%d) has to be divisible by %d", p_FmPortPerformanceCnt->fifoCompVal, BMI_FIFO_UNITS));
 
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            if (!p_FmPortPerformanceCnt->queueCompVal ||
-                (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                             ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d",
-                              MAX_PERFORMANCE_RX_QUEUE_COMP));
+            if (!p_FmPortPerformanceCnt->queueCompVal
+                    || (p_FmPortPerformanceCnt->queueCompVal
+                            > MAX_PERFORMANCE_RX_QUEUE_COMP))
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d", MAX_PERFORMANCE_RX_QUEUE_COMP));
             break;
         case (e_FM_PORT_TYPE_TX_10G):
         case (e_FM_PORT_TYPE_TX):
-            if (!p_FmPortPerformanceCnt->queueCompVal ||
-                (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                             ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d",
-                              MAX_PERFORMANCE_TX_QUEUE_COMP));
+            if (!p_FmPortPerformanceCnt->queueCompVal
+                    || (p_FmPortPerformanceCnt->queueCompVal
+                            > MAX_PERFORMANCE_TX_QUEUE_COMP))
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d", MAX_PERFORMANCE_TX_QUEUE_COMP));
             break;
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             if (p_FmPortPerformanceCnt->queueCompVal)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("performanceCnt.queueCompVal is not relevant for H/O ports."));
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    params.task_val     = p_FmPortPerformanceCnt->taskCompVal;
-    params.queue_val    = p_FmPortPerformanceCnt->queueCompVal;
-    params.dma_val      = p_FmPortPerformanceCnt->dmaCompVal;
-    params.fifo_val     = p_FmPortPerformanceCnt->fifoCompVal;
+    params.task_val = p_FmPortPerformanceCnt->taskCompVal;
+    params.queue_val = p_FmPortPerformanceCnt->queueCompVal;
+    params.dma_val = p_FmPortPerformanceCnt->dmaCompVal;
+    params.fifo_val = p_FmPortPerformanceCnt->fifoCompVal;
 
     err = fman_port_set_perf_cnt_params(&p_FmPort->port, &params);
     if (err != 0)
@@ -3426,45 +3894,52 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
 
 t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPortPerformanceCnt  currParams, savedParams;
-    t_Error                 err;
-    bool                    underTest, failed = FALSE;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortPerformanceCnt currParams, savedParams;
+    t_Error err;
+    bool underTest, failed = FALSE;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     XX_Print("Analyzing Performance parameters for port (type %d, id%d)\n",
              p_FmPort->portType, p_FmPort->portId);
 
-    currParams.taskCompVal    = (uint8_t)p_FmPort->tasks.num;
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        currParams.queueCompVal   = 0;
+    currParams.taskCompVal = (uint8_t)p_FmPort->tasks.num;
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        currParams.queueCompVal = 0;
     else
-        currParams.queueCompVal   = 1;
-    currParams.dmaCompVal     =(uint8_t) p_FmPort->openDmas.num;
-    currParams.fifoCompVal    = p_FmPort->fifoBufs.num;
+        currParams.queueCompVal = 1;
+    currParams.dmaCompVal = (uint8_t)p_FmPort->openDmas.num;
+    currParams.fifoCompVal = p_FmPort->fifoBufs.num;
 
     FM_PORT_SetPerformanceCounters(p_FmPort, FALSE);
     ClearPerfCnts(p_FmPort);
-    if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams)) != E_OK)
+    if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams))
+            != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     FM_PORT_SetPerformanceCounters(p_FmPort, TRUE);
     XX_UDelay(1000000);
     FM_PORT_SetPerformanceCounters(p_FmPort, FALSE);
     if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL))
     {
-        XX_Print ("Max num of defined port tasks (%d) utilized - Please enlarge\n",p_FmPort->tasks.num);
+        XX_Print(
+                "Max num of defined port tasks (%d) utilized - Please enlarge\n",
+                p_FmPort->tasks.num);
         failed = TRUE;
     }
     if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL))
     {
-        XX_Print ("Max num of defined port openDmas (%d) utilized - Please enlarge\n",p_FmPort->openDmas.num);
+        XX_Print(
+                "Max num of defined port openDmas (%d) utilized - Please enlarge\n",
+                p_FmPort->openDmas.num);
         failed = TRUE;
     }
     if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
     {
-        XX_Print("Max size of defined port fifo (%d) utilized - Please enlarge\n",p_FmPort->fifoBufs.num);
+        XX_Print(
+                "Max size of defined port fifo (%d) utilized - Please enlarge\n",
+                p_FmPort->fifoBufs.num);
         failed = TRUE;
     }
     if (failed)
@@ -3484,7 +3959,8 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
             currParams.dmaCompVal--;
             underTest = TRUE;
         }
-        if ((currParams.fifoCompVal != BMI_FIFO_UNITS) && !savedParams.fifoCompVal)
+        if ((currParams.fifoCompVal != BMI_FIFO_UNITS)
+                && !savedParams.fifoCompVal)
         {
             currParams.fifoCompVal -= BMI_FIFO_UNITS;
             underTest = TRUE;
@@ -3493,29 +3969,35 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
             break;
 
         ClearPerfCnts(p_FmPort);
-        if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams)) != E_OK)
+        if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams))
+                != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
         FM_PORT_SetPerformanceCounters(p_FmPort, TRUE);
         XX_UDelay(1000000);
         FM_PORT_SetPerformanceCounters(p_FmPort, FALSE);
 
-        if (!savedParams.taskCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL))
-            savedParams.taskCompVal = (uint8_t)(currParams.taskCompVal+2);
-        if (!savedParams.dmaCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL))
-            savedParams.dmaCompVal = (uint8_t)(currParams.dmaCompVal+2);
-        if (!savedParams.fifoCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
-            savedParams.fifoCompVal = currParams.fifoCompVal+(2*BMI_FIFO_UNITS);
+        if (!savedParams.taskCompVal
+                && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL))
+            savedParams.taskCompVal = (uint8_t)(currParams.taskCompVal + 2);
+        if (!savedParams.dmaCompVal
+                && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL))
+            savedParams.dmaCompVal = (uint8_t)(currParams.dmaCompVal + 2);
+        if (!savedParams.fifoCompVal
+                && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
+            savedParams.fifoCompVal = currParams.fifoCompVal
+                    + (2 * BMI_FIFO_UNITS);
     }
 
     XX_Print("best vals: tasks %d, dmas %d, fifos %d\n",
-             savedParams.taskCompVal, savedParams.dmaCompVal, savedParams.fifoCompVal);
+             savedParams.taskCompVal, savedParams.dmaCompVal,
+             savedParams.fifoCompVal);
     return E_OK;
 }
 
 t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    int         err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -3528,9 +4010,9 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
 
 t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t       *p_ErrDiscard = NULL;
-    int                     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_ErrDiscard = NULL;
+    int err;
 
     UNUSED(p_ErrDiscard);
     err = fman_port_set_err_mask(&p_FmPort->port, (uint32_t)errs);
@@ -3540,40 +4022,49 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
 #ifdef FM_ERROR_VSP_NO_MATCH_SW006
     if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
-        t_FmPcdCtrlParamsPage   *p_ParamsPage;
+        t_FmPcdCtrlParamsPage *p_ParamsPage;
 
-        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
+        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                         (void**)&p_ParamsPage);
         ASSERT_COND(p_ParamsPage);
         switch (p_FmPort->portType)
         {
             case (e_FM_PORT_TYPE_RX_10G):
             case (e_FM_PORT_TYPE_RX):
-                p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
+                p_ErrDiscard =
+                        &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
                 break;
             case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-                p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
+                p_ErrDiscard =
+                        &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
                 break;
             default:
-               RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_OPERATION,
+                        ("available for Rx and offline parsing ports only"));
         }
-        WRITE_UINT32(p_ParamsPage->errorsDiscardMask, GET_UINT32(*p_ErrDiscard) | errs);
+        WRITE_UINT32(p_ParamsPage->errorsDiscardMask,
+                     GET_UINT32(*p_ErrDiscard) | errs);
     }
 #endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
 
     return E_OK;
 }
 
-t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable)
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId,
+                                   bool enable)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    int                     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_POOLS, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     err = fman_port_set_bpool_cnt_mode(&p_FmPort->port, poolId, enable);
     if (err != 0)
@@ -3583,32 +4074,32 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
 
 uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
 {
-    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
-    bool                            bmiCounter = FALSE;
-    enum fman_port_stats_counters   statsType;
-    enum fman_port_perf_counters    perfType;
-    enum fman_port_qmi_counters   queueType;
-    bool                            isStats;
-    t_Error                         errCode;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    bool bmiCounter = FALSE;
+    enum fman_port_stats_counters statsType;
+    enum fman_port_perf_counters perfType;
+    enum fman_port_qmi_counters queueType;
+    bool isStats;
+    t_Error errCode;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
             /* check that counter is available for the port type */
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE,
                         ("Requested counter is not available for Rx ports"));
                 return 0;
             }
             bmiCounter = FALSE;
-        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -3618,7 +4109,8 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
 
     if (bmiCounter)
     {
-        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType, &perfType, &isStats);
+        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType,
+                                                &perfType, &isStats);
         if (errCode != E_OK)
         {
             REPORT_ERROR(MINOR, errCode, NO_MSG);
@@ -3632,7 +4124,8 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     else /* QMI counter */
     {
         /* check that counters are enabled */
-        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc)
+                & QMI_PORT_CFG_EN_COUNTERS))
 
         {
             REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
@@ -3642,21 +4135,21 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
         /* Set counter */
         switch (counter)
         {
-           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 queueType = E_FMAN_PORT_ENQ_TOTAL;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 queueType = E_FMAN_PORT_DEQ_TOTAL;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 queueType = E_FMAN_PORT_DEQ_FROM_DFLT;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 queueType = E_FMAN_PORT_DEQ_CONFIRM;
-               break;
+                break;
             default:
-               REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
-               return 0;
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                return 0;
         }
 
         return fman_port_get_qmi_counter(&p_FmPort->port, queueType);
@@ -3665,29 +4158,32 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     return 0;
 }
 
-t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t value)
+t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter,
+                              uint32_t value)
 {
-    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
-    bool                            bmiCounter = FALSE;
-    enum fman_port_stats_counters   statsType;
-    enum fman_port_perf_counters    perfType;
-    enum fman_port_qmi_counters   queueType;
-    bool                            isStats;
-    t_Error                         errCode;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    bool bmiCounter = FALSE;
+    enum fman_port_stats_counters statsType;
+    enum fman_port_perf_counters perfType;
+    enum fman_port_qmi_counters queueType;
+    bool isStats;
+    t_Error errCode;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
             /* check that counter is available for the port type */
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
-        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                RETURN_ERROR(
+                        MINOR, E_INVALID_STATE,
+                        ("Requested counter is not available for Rx ports"));
+        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -3697,7 +4193,8 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
 
     if (bmiCounter)
     {
-        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType, &perfType, &isStats);
+        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType,
+                                                &perfType, &isStats);
         if (errCode != E_OK)
         {
             RETURN_ERROR(MINOR, errCode, NO_MSG);
@@ -3710,28 +4207,31 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     else /* QMI counter */
     {
         /* check that counters are enabled */
-        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc)
+                & QMI_PORT_CFG_EN_COUNTERS))
         {
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            RETURN_ERROR(MINOR, E_INVALID_STATE,
+                         ("Requested counter was not enabled"));
         }
 
         /* Set counter */
         switch (counter)
         {
-           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 queueType = E_FMAN_PORT_ENQ_TOTAL;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 queueType = E_FMAN_PORT_DEQ_TOTAL;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 queueType = E_FMAN_PORT_DEQ_FROM_DFLT;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 queueType = E_FMAN_PORT_DEQ_CONFIRM;
-               break;
+                break;
             default:
-               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                RETURN_ERROR(MINOR, E_INVALID_STATE,
+                             ("Requested counter is not available"));
         }
 
         fman_port_set_qmi_counter(&p_FmPort->port, queueType, value);
@@ -3740,15 +4240,15 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     return E_OK;
 }
 
-
 uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
         return 0;
@@ -3756,27 +4256,31 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
     return fman_port_get_bpool_counter(&p_FmPort->port, poolId);
 }
 
-t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_t value)
+t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId,
+                                      uint32_t value)
 {
-    t_FmPort        *p_FmPort = (t_FmPort *)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort *)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        RETURN_ERROR( MINOR, E_INVALID_STATE,
+                     ("Requested counter is not available for non-Rx ports"));
 
     fman_port_set_bpool_counter(&p_FmPort->port, poolId, value);
     return E_OK;
 }
 bool FM_PORT_IsStalled(t_Handle h_FmPort)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error     err;
-    bool        isStalled;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err;
+    bool isStalled;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, FALSE);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              FALSE);
 
     err = FmIsPortStalled(p_FmPort->h_Fm, p_FmPort->hardwarePortId, &isStalled);
     if (err != E_OK)
@@ -3789,7 +4293,7 @@ bool FM_PORT_IsStalled(t_Handle h_FmPort)
 
 t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -3805,18 +4309,19 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     if (l4Checksum)
-        err = fman_port_modify_rx_fd_bits(&p_FmPort->port,
-                                          (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
-                                          TRUE);
+        err = fman_port_modify_rx_fd_bits(
+                &p_FmPort->port, (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
+                TRUE);
     else
-        err = fman_port_modify_rx_fd_bits(&p_FmPort->port,
-                                          (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
-                                          FALSE);
+        err = fman_port_modify_rx_fd_bits(
+                &p_FmPort->port, (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
+                FALSE);
     if (err != 0)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_modify_rx_fd_bits"));
 
@@ -3830,86 +4335,91 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
 #if (DPAA_VERSION >= 11)
 t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err = E_OK;
-    volatile uint32_t           *p_BmiStorageProfileId = NULL, *p_BmiVspe = NULL;
-    uint32_t                    tmpReg = 0, tmp = 0;
-    uint16_t                    hwStoragePrflId;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
+    volatile uint32_t *p_BmiStorageProfileId = NULL, *p_BmiVspe = NULL;
+    uint32_t tmpReg = 0, tmp = 0;
+    uint16_t hwStoragePrflId;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->h_Fm, E_INVALID_HANDLE);
     /*for numOfProfiles = 0 don't call this function*/
     SANITY_CHECK_RETURN_ERROR(p_VSPParams->numOfProfiles, E_INVALID_VALUE);
     /*dfltRelativeId should be in the range of numOfProfiles*/
-    SANITY_CHECK_RETURN_ERROR(IN_RANGE(0, p_VSPParams->dfltRelativeId, (p_VSPParams->numOfProfiles - 1)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            IN_RANGE(0, p_VSPParams->dfltRelativeId, (p_VSPParams->numOfProfiles - 1)),
+            E_INVALID_VALUE);
     /*p_FmPort should be from Rx type or OP*/
-    SANITY_CHECK_RETURN_ERROR(((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-                               (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-                               (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)),
+            E_INVALID_VALUE);
     /*port should be disabled*/
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->enabled, E_INVALID_STATE);
     /*if its called for Rx port relevant Tx Port should be passed (initialized) too and it should be disabled*/
-    SANITY_CHECK_RETURN_ERROR(((p_VSPParams->h_FmTxPort &&
-                                !((t_FmPort *)(p_VSPParams->h_FmTxPort))->enabled) ||
-                               (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            ((p_VSPParams->h_FmTxPort && !((t_FmPort *)(p_VSPParams->h_FmTxPort))->enabled) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)),
+            E_INVALID_VALUE);
     /*should be called before SetPCD - this port should be without PCD*/
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->pcdEngines, E_INVALID_STATE);
 
     /*alloc window of VSPs for this port*/
-    err = FmVSPAllocForPort(p_FmPort->h_Fm,
-                            p_FmPort->portType,
-                            p_FmPort->portId,
-                            p_VSPParams->numOfProfiles);
+    err = FmVSPAllocForPort(p_FmPort->h_Fm, p_FmPort->portType,
+                            p_FmPort->portId, p_VSPParams->numOfProfiles);
     if (err != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*get absolute VSP ID for dfltRelative*/
-    err = FmVSPGetAbsoluteProfileId(p_FmPort->h_Fm,
-                                    p_FmPort->portType,
+    err = FmVSPGetAbsoluteProfileId(p_FmPort->h_Fm, p_FmPort->portType,
                                     p_FmPort->portId,
                                     p_VSPParams->dfltRelativeId,
                                     &hwStoragePrflId);
     if (err != E_OK)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*fill relevant registers for p_FmPort and relative TxPort in the case p_FmPort from Rx type*/
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            p_BmiStorageProfileId = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid);
-            p_BmiVspe = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfne);
+            p_BmiStorageProfileId =
+                    &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid);
+            p_BmiVspe =
+                    &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfne);
 
             tmpReg = GET_UINT32(*p_BmiStorageProfileId) & ~BMI_SP_ID_MASK;
-            tmpReg |= (uint32_t)hwStoragePrflId<<BMI_SP_ID_SHIFT;
+            tmpReg |= (uint32_t)hwStoragePrflId << BMI_SP_ID_SHIFT;
             WRITE_UINT32(*p_BmiStorageProfileId, tmpReg);
 
             tmpReg = GET_UINT32(*p_BmiVspe);
             WRITE_UINT32(*p_BmiVspe, tmpReg | BMI_SP_EN);
 
-            p_BmiStorageProfileId = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid;
+            p_BmiStorageProfileId =
+                    &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid;
             p_BmiVspe = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpp;
             hwStoragePrflId = p_VSPParams->dfltRelativeId;
             break;
 
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             tmpReg = NIA_ENG_BMI | NIA_BMI_AC_FETCH_ALL_FRAME;
-            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn,tmpReg);
+            WRITE_UINT32( p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn,
+                         tmpReg);
 
-            p_BmiStorageProfileId = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofqid;
+            p_BmiStorageProfileId =
+                    &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofqid;
             p_BmiVspe = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opp;
             tmp |= BMI_EBD_EN;
             break;
 
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     p_FmPort->vspe = TRUE;
     p_FmPort->dfltRelativeId = p_VSPParams->dfltRelativeId;
 
     tmpReg = GET_UINT32(*p_BmiStorageProfileId) & ~BMI_SP_ID_MASK;
-    tmpReg |= (uint32_t)hwStoragePrflId<<BMI_SP_ID_SHIFT;
+    tmpReg |= (uint32_t)hwStoragePrflId << BMI_SP_ID_SHIFT;
     WRITE_UINT32(*p_BmiStorageProfileId, tmpReg);
 
     tmpReg = GET_UINT32(*p_BmiVspe);
@@ -3920,21 +4430,22 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
 
 t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     if (numOfProfiles)
     {
-        err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
+        err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd,
+                                     p_FmPort->hardwarePortId, numOfProfiles);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
@@ -3948,13 +4459,13 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
 
 t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = FmPcdPlcrFreeProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
@@ -3962,24 +4473,26 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
     RELEASE_LOCK(p_FmPort->lock);
 
     if (err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
 
-t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
+t_Error FM_PORT_PcdKgModifyInitialScheme(t_Handle h_FmPort,
+                                         t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t       *p_BmiHpnia = NULL;
-    uint32_t                tmpReg;
-    uint8_t                 relativeSchemeId;
-    uint8_t                 physicalSchemeId;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiHpnia = NULL;
+    uint32_t tmpReg;
+    uint8_t relativeSchemeId;
+    uint8_t physicalSchemeId;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG,
+                              E_INVALID_STATE);
 
-    tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC)? NIA_KG_CC_EN:0);
+    tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC) ? NIA_KG_CC_EN : 0);
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_RX_10G):
@@ -3990,13 +4503,14 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
             p_BmiHpnia = &p_FmPort->port.bmi_regs->oh.fmbm_ofpne;
             break;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     /* if we want to change to direct scheme, we need to check that this scheme is valid */
@@ -4004,50 +4518,65 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     {
         physicalSchemeId = FmPcdKgGetSchemeId(p_FmPcdKgScheme->h_DirectScheme);
         /* check that this scheme is bound to this port */
-        if (!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
+        if (!(p_FmPort->schemesPerPortVector
+                & (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
         {
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with a scheme that is not bound to this port"));
+            RETURN_ERROR(
+                    MAJOR, E_INVALID_STATE,
+                    ("called with a scheme that is not bound to this port"));
         }
 
-        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd, physicalSchemeId);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd,
+                                                      physicalSchemeId);
         if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
         {
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE,
+                         ("called with invalid Scheme "));
         }
 
         if (!FmPcdKgIsSchemeValidSw(p_FmPcdKgScheme->h_DirectScheme))
         {
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("called with uninitialized Scheme "));
         }
 
-        WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg | NIA_KG_DIRECT | (uint32_t)physicalSchemeId);
+        WRITE_UINT32(
+                *p_BmiHpnia,
+                NIA_ENG_KG | tmpReg | NIA_KG_DIRECT | (uint32_t)physicalSchemeId);
     }
-    else /* change to indirect scheme */
+    else
+        /* change to indirect scheme */
         WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg);
     RELEASE_LOCK(p_FmPort->lock);
 
     return E_OK;
 }
 
-t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile)
+t_Error FM_PORT_PcdPlcrModifyInitialProfile(t_Handle h_FmPort,
+                                            t_Handle h_Profile)
 {
-    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t               *p_BmiNia;
-    volatile uint32_t               *p_BmiHpnia;
-    uint32_t                        tmpReg;
-    uint16_t                        absoluteProfileId = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiNia;
+    volatile uint32_t *p_BmiHpnia;
+    uint32_t tmpReg;
+    uint16_t absoluteProfileId = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PLCR , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PLCR,
+                              E_INVALID_STATE);
 
     /* check relevance of this routine  - only when policer is used
-    directly after BMI or Parser */
-    if ((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
+     directly after BMI or Parser */
+    if ((p_FmPort->pcdEngines & FM_PCD_KG)
+            || (p_FmPort->pcdEngines & FM_PCD_CC))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
 
     switch (p_FmPort->portType)
     {
@@ -4063,13 +4592,14 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
             tmpReg = 0;
             break;
         default:
-           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
@@ -4091,24 +4621,24 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
         tmpReg |= (GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK);
         /* update BMI NIA */
         WRITE_UINT32(*p_BmiNia, tmpReg);
-    }
-    RELEASE_LOCK(p_FmPort->lock);
+    }RELEASE_LOCK(p_FmPort->lock);
 
     return E_OK;
 }
 
-t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
+t_Error FM_PORT_PcdCcModifyTree(t_Handle h_FmPort, t_Handle h_CcTree)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                             err = E_OK;
-    volatile uint32_t                   *p_BmiCcBase=NULL;
-    volatile uint32_t                   *p_BmiNia=NULL;
-    uint32_t                            ccTreePhysOffset;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
+    volatile uint32_t *p_BmiCcBase = NULL;
+    volatile uint32_t *p_BmiNia = NULL;
+    uint32_t ccTreePhysOffset;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independent mode ports only"));
 
     /* get PCD registers pointers */
     switch (p_FmPort->portType)
@@ -4121,27 +4651,38 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
             p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
             break;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK)
+            != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("may be called only for ports in BMI-to-BMI state."));
 
     if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         if (p_FmPort->h_IpReassemblyManip)
         {
-            err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
-                                    h_CcTree,
-                                    NULL,
-                                    p_FmPort->h_IpReassemblyManip,
-                                    FALSE);
+            err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd, h_CcTree, NULL,
+                                    p_FmPort->h_IpReassemblyManip, FALSE);
             if (err != E_OK)
             {
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
+        else
+            if (p_FmPort->h_CapwapReassemblyManip)
+            {
+                err = FmPcdCcTreeAddCPR(p_FmPort->h_FmPcd, h_CcTree, NULL,
+                                        p_FmPort->h_CapwapReassemblyManip,
+                                        FALSE);
+                if (err != E_OK)
+                {
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+            }
         switch (p_FmPort->portType)
         {
             case (e_FM_PORT_TYPE_RX_10G):
@@ -4157,49 +4698,52 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 
         if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
         {
-             DBG(TRACE, ("FM Port Try Lock - BUSY"));
-             return ERROR_CODE(E_BUSY);
+            DBG(TRACE, ("FM Port Try Lock - BUSY"));
+            return ERROR_CODE(E_BUSY);
         }
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree, &ccTreePhysOffset, h_FmPort);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree,
+                              &ccTreePhysOffset, h_FmPort);
         if (err)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        }
-        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
+        }WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
 
         p_FmPort->ccTreeId = h_CcTree;
         RELEASE_LOCK(p_FmPort->lock);
     }
     else
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Coarse Classification not defined for this port."));
+        RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                     ("Coarse Classification not defined for this port."));
 
     return E_OK;
 }
 
 t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error         err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independent mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
-    if (p_FmPort->h_IpReassemblyTree)
+    if (p_FmPort->h_ReassemblyTree)
         p_FmPort->pcdEngines |= FM_PCD_CC;
 
     err = AttachPCD(h_FmPort);
@@ -4210,24 +4754,26 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
 
 t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error         err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independent mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = DetachPCD(h_FmPort);
@@ -4237,7 +4783,7 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if (p_FmPort->h_IpReassemblyTree)
+    if (p_FmPort->h_ReassemblyTree)
         p_FmPort->pcdEngines &= ~FM_PCD_CC;
     RELEASE_LOCK(p_FmPort->lock);
 
@@ -4246,28 +4792,30 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
 
 t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                 err = E_OK;
-    t_FmPortPcdParams       modifiedPcdParams, *p_PcdParams;
-    t_FmPcdCcTreeParams     *p_FmPcdCcTreeParams;
-    t_FmPortPcdCcParams     fmPortPcdCcParams;
-    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
+    t_FmPortPcdParams modifiedPcdParams, *p_PcdParams;
+    t_FmPcdCcTreeParams *p_FmPcdCcTreeParams;
+    t_FmPortPcdCcParams fmPortPcdCcParams;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independent mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
@@ -4275,76 +4823,112 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
     memcpy(&modifiedPcdParams, p_PcdParam, sizeof(t_FmPortPcdParams));
     p_PcdParams = &modifiedPcdParams;
-    if (p_PcdParams->h_IpReassemblyManip)
-    {
-        if ((p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG) &&
-            (p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC) &&
-            (p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR) &&
-            (p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR))
+    if ((p_PcdParams->h_IpReassemblyManip)
+#if (DPAA_VERSION >= 11)
+            || (p_PcdParams->h_CapwapReassemblyManip)
+#endif /* (DPAA_VERSION >= 11) */
+            )
+    {
+        if ((p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG)
+                && (p_PcdParams->pcdSupport
+                        != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC)
+                && (p_PcdParams->pcdSupport
+                        != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR)
+                && (p_PcdParams->pcdSupport
+                        != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR))
         {
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("pcdSupport must have KG for supporting IPR"));
+            RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                         ("pcdSupport must have KG for supporting Reassembly"));
         }
         p_FmPort->h_IpReassemblyManip = p_PcdParams->h_IpReassemblyManip;
+#if (DPAA_VERSION >= 11)
+        if ((p_PcdParams->h_IpReassemblyManip)
+                && (p_PcdParams->h_CapwapReassemblyManip))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("Either IP-R or CAPWAP-R is allowed"));
+        if ((p_PcdParams->h_CapwapReassemblyManip)
+                && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("CAPWAP-R is allowed only on offline-port"));
+        if (p_PcdParams->h_CapwapReassemblyManip)
+            p_FmPort->h_CapwapReassemblyManip =
+                    p_PcdParams->h_CapwapReassemblyManip;
+#endif /* (DPAA_VERSION >= 11) */
+
         if (!p_PcdParams->p_CcParams)
         {
-            if (!((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG) ||
-                  (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR)))
+            if (!((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG)
+                    || (p_PcdParams->pcdSupport
+                            == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR)))
             {
                 RELEASE_LOCK(p_FmPort->lock);
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("PCD initialization structure is not consistent with pcdSupport"));
             }
 
             /* No user-tree, need to build internal tree */
-            p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
+            p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(
+                    sizeof(t_FmPcdCcTreeParams));
             if (!p_FmPcdCcTreeParams)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
             memset(p_FmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
             p_FmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
-            p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
+            p_FmPort->h_ReassemblyTree = FM_PCD_CcRootBuild(
+                    p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
 
-            if (!p_FmPort->h_IpReassemblyTree)
+            if (!p_FmPort->h_ReassemblyTree)
             {
                 RELEASE_LOCK(p_FmPort->lock);
                 XX_Free(p_FmPcdCcTreeParams);
-                RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM_PCD_CcBuildTree for IPR failed"));
+                RETURN_ERROR( MAJOR, E_INVALID_HANDLE,
+                             ("FM_PCD_CcBuildTree for Reassembly failed"));
             }
             if (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG)
-                p_PcdParams->pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC;
+                p_PcdParams->pcdSupport =
+                        e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC;
             else
-                p_PcdParams->pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR;
+                p_PcdParams->pcdSupport =
+                        e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR;
 
             memset(&fmPortPcdCcParams, 0, sizeof(t_FmPortPcdCcParams));
-            fmPortPcdCcParams.h_CcTree = p_FmPort->h_IpReassemblyTree;
+            fmPortPcdCcParams.h_CcTree = p_FmPort->h_ReassemblyTree;
             p_PcdParams->p_CcParams = &fmPortPcdCcParams;
             XX_Free(p_FmPcdCcTreeParams);
         }
 
-        err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
-                                p_PcdParams->p_CcParams->h_CcTree,
-                                p_PcdParams->h_NetEnv,
-                                p_FmPort->h_IpReassemblyManip,
-                                TRUE);
+        if (p_FmPort->h_IpReassemblyManip)
+            err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
+                                    p_PcdParams->p_CcParams->h_CcTree,
+                                    p_PcdParams->h_NetEnv,
+                                    p_FmPort->h_IpReassemblyManip, TRUE);
+        else
+            if (p_FmPort->h_CapwapReassemblyManip)
+                err = FmPcdCcTreeAddCPR(p_FmPort->h_FmPcd,
+                                        p_PcdParams->p_CcParams->h_CcTree,
+                                        p_PcdParams->h_NetEnv,
+                                        p_FmPort->h_CapwapReassemblyManip,
+                                        TRUE);
         if (err != E_OK)
         {
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
-            }
-            RELEASE_LOCK(p_FmPort->lock);
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
+            }RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
     }
 
     if (!FmPcdLockTryLockAll(p_FmPort->h_FmPcd))
     {
-        if (p_FmPort->h_IpReassemblyTree)
+        if (p_FmPort->h_ReassemblyTree)
         {
-            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-            p_FmPort->h_IpReassemblyTree = NULL;
-        }
-        RELEASE_LOCK(p_FmPort->lock);
+            FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+            p_FmPort->h_ReassemblyTree = NULL;
+        }RELEASE_LOCK(p_FmPort->lock);
         DBG(TRACE, ("Try LockAll - BUSY"));
         return ERROR_CODE(E_BUSY);
     }
@@ -4352,27 +4936,28 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
     err = SetPcd(h_FmPort, p_PcdParams);
     if (err)
     {
-        if (p_FmPort->h_IpReassemblyTree)
+        if (p_FmPort->h_ReassemblyTree)
         {
-            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-            p_FmPort->h_IpReassemblyTree = NULL;
+            FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+            p_FmPort->h_ReassemblyTree = NULL;
         }
         FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
-        (p_PcdParams->p_PrsParams->includeInPrsStatistics))
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS)
+            && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
     {
-        err = FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+        err = FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd,
+                                              p_FmPort->hardwarePortId, TRUE);
         if (err)
         {
             DeletePcd(p_FmPort);
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
             }
             FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
             RELEASE_LOCK(p_FmPort->lock);
@@ -4391,36 +4976,53 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
         {
 #ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
             if ((p_FmPort->fmRevInfo.majorRev < 6) &&
-                (p_FmPort->pcdEngines & FM_PCD_KG))
+                    (p_FmPort->pcdEngines & FM_PCD_KG))
             {
                 int i;
                 for (i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
-                    /* The following function must be locked */
-                    FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
-                                          p_PcdParams->p_KgParams->h_Schemes[i],
-                                          UPDATE_KG_NIA_CC_WA,
-                                          0);
+                /* The following function must be locked */
+                FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
+                        p_PcdParams->p_KgParams->h_Schemes[i],
+                        UPDATE_KG_NIA_CC_WA,
+                        0);
             }
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
 
+#if (DPAA_VERSION >= 11)
+            {
+                t_FmPcdCtrlParamsPage *p_ParamsPage;
+
+                FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                                 (void**)&p_ParamsPage);
+                ASSERT_COND(p_ParamsPage);
+                WRITE_UINT32(p_ParamsPage->postBmiFetchNia,
+                             p_FmPort->savedBmiNia);
+                XX_Print("p_ParamsPage->postBmiFetchNia 0x%x\n",
+                         GET_UINT32(p_ParamsPage->postBmiFetchNia));
+            }
+#endif /* (DPAA_VERSION >= 11) */
+
             /* Set post-bmi-fetch nia */
             p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
-            p_FmPort->savedBmiNia |= (NIA_FM_CTL_AC_POST_BMI_FETCH | NIA_ENG_FM_CTL);
+            p_FmPort->savedBmiNia |= (NIA_FM_CTL_AC_POST_BMI_FETCH
+                    | NIA_ENG_FM_CTL);
 
             /* Set pre-bmi-fetch nia */
             fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
 #if (DPAA_VERSION >= 11)
-            fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_FULL_FRAME | NIA_ENG_FM_CTL);
+            fmPortGetSetCcParams.setCcParams.nia =
+                    (NIA_FM_CTL_AC_PRE_BMI_FETCH_FULL_FRAME | NIA_ENG_FM_CTL);
 #else
             fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER | NIA_ENG_FM_CTL);
 #endif /* (DPAA_VERSION >= 11) */
-            if ((err = FmPortGetSetCcParams(p_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            if ((err = FmPortGetSetCcParams(p_FmPort, &fmPortGetSetCcParams))
+                    != E_OK)
             {
                 DeletePcd(p_FmPort);
-                if (p_FmPort->h_IpReassemblyTree)
+                if (p_FmPort->h_ReassemblyTree)
                 {
-                    FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                    p_FmPort->h_IpReassemblyTree = NULL;
+                    FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                    p_FmPort->h_ReassemblyTree = NULL;
                 }
                 FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
                 RELEASE_LOCK(p_FmPort->lock);
@@ -4442,36 +5044,38 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 #endif /* (DPAA_VERSION == 10) */
         fmPortGetSetCcParams.getCcParams.type = GET_NIA_FPNE;
 #if (DPAA_VERSION == 10)
-        }
+    }
 #endif /* (DPAA_VERSION == 10) */
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                != E_OK)
         {
             DeletePcd(p_FmPort);
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
-            }
-            RELEASE_LOCK(p_FmPort->lock);
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
+            }RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 
         /* Set post-bmi-prepare-to-enq nia */
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FENE;
-        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_POST_BMI_ENQ | NIA_ENG_FM_CTL);
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_POST_BMI_ENQ
+                | NIA_ENG_FM_CTL);
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                != E_OK)
         {
             DeletePcd(p_FmPort);
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
-            }
-            RELEASE_LOCK(p_FmPort->lock);
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
+            }RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 
-        if (p_FmPort->h_IpReassemblyManip)
+        if ((p_FmPort->h_IpReassemblyManip)
+                || (p_FmPort->h_CapwapReassemblyManip))
         {
 #if (DPAA_VERSION == 10)
             if (p_FmPort->fmRevInfo.majorRev < 6)
@@ -4486,19 +5090,20 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 #endif /* (DPAA_VERSION == 10) */
             /* Set the ORR bit (for order-restoration) */
             fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FPNE;
-            fmPortGetSetCcParams.setCcParams.nia = fmPortGetSetCcParams.getCcParams.nia | NIA_ORDER_RESTOR;
+            fmPortGetSetCcParams.setCcParams.nia =
+                    fmPortGetSetCcParams.getCcParams.nia | NIA_ORDER_RESTOR;
 #if (DPAA_VERSION == 10)
-            }
+        }
 #endif /* (DPAA_VERSION == 10) */
-            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                    != E_OK)
             {
                 DeletePcd(p_FmPort);
-                if (p_FmPort->h_IpReassemblyTree)
+                if (p_FmPort->h_ReassemblyTree)
                 {
-                    FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                    p_FmPort->h_IpReassemblyTree = NULL;
-                }
-                RELEASE_LOCK(p_FmPort->lock);
+                    FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                    p_FmPort->h_ReassemblyTree = NULL;
+                }RELEASE_LOCK(p_FmPort->lock);
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
@@ -4508,46 +5113,55 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
 #if (DPAA_VERSION >= 11)
     {
-        t_FmPcdCtrlParamsPage   *p_ParamsPage;
+        t_FmPcdCtrlParamsPage *p_ParamsPage;
 
         memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_CMNE;
         if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd))
-            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
+            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP
+                    | NIA_ENG_FM_CTL;
         else
-            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_NO_IPACC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            fmPortGetSetCcParams.setCcParams.nia =
+                    NIA_FM_CTL_AC_NO_IPACC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                != E_OK)
         {
             DeletePcd(p_FmPort);
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
-            }
-            RELEASE_LOCK(p_FmPort->lock);
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
+            }RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
-         }
+        }
 
-        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
+        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                         (void**)&p_ParamsPage);
         ASSERT_COND(p_ParamsPage);
 
         if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd))
-            WRITE_UINT32(p_ParamsPage->misc, GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OFFLOAD_SUPPORT_EN);
+            WRITE_UINT32(
+                    p_ParamsPage->misc,
+                    GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OFFLOAD_SUPPORT_EN);
 
-        if (p_FmPort->h_IpReassemblyManip)
+        if ((p_FmPort->h_IpReassemblyManip)
+                || (p_FmPort->h_CapwapReassemblyManip))
         {
             if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-                WRITE_UINT32(p_ParamsPage->discardMask,
-                             GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
+                WRITE_UINT32(
+                        p_ParamsPage->discardMask,
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
             else
-                WRITE_UINT32(p_ParamsPage->discardMask,
-                             GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm));
+                WRITE_UINT32(
+                        p_ParamsPage->discardMask,
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm));
         }
 #ifdef FM_ERROR_VSP_NO_MATCH_SW006
         if (p_FmPort->vspe)
-            WRITE_UINT32(p_ParamsPage->misc,
-                         GET_UINT32(p_ParamsPage->misc) | (p_FmPort->dfltRelativeId & FM_CTL_PARAMS_PAGE_ERROR_VSP_MASK));
+            WRITE_UINT32(
+                    p_ParamsPage->misc,
+                    GET_UINT32(p_ParamsPage->misc) | (p_FmPort->dfltRelativeId & FM_CTL_PARAMS_PAGE_ERROR_VSP_MASK));
 #endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
     }
 #endif /* (DPAA_VERSION >= 11) */
@@ -4556,12 +5170,11 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
     if (err)
     {
         DeletePcd(p_FmPort);
-        if (p_FmPort->h_IpReassemblyTree)
+        if (p_FmPort->h_ReassemblyTree)
         {
-            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-            p_FmPort->h_IpReassemblyTree = NULL;
-        }
-        RELEASE_LOCK(p_FmPort->lock);
+            FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+            p_FmPort->h_ReassemblyTree = NULL;
+        }RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -4572,24 +5185,26 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
 t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
 {
-    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                                 err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independant mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = DetachPCD(h_FmPort);
@@ -4602,10 +5217,10 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
     FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
     /* we do it anyway, instead of checking if included */
-    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
-        p_FmPort->includeInPrsStatistics)
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS) && p_FmPort->includeInPrsStatistics)
     {
-        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
+        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd,
+                                        p_FmPort->hardwarePortId, FALSE);
         p_FmPort->includeInPrsStatistics = FALSE;
     }
 
@@ -4624,48 +5239,50 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if (p_FmPort->h_IpReassemblyTree)
+    if (p_FmPort->h_ReassemblyTree)
     {
-        err = FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+        err = FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
         if (err)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
-        p_FmPort->h_IpReassemblyTree = NULL;
-    }
-    RELEASE_LOCK(p_FmPort->lock);
+        p_FmPort->h_ReassemblyTree = NULL;
+    }RELEASE_LOCK(p_FmPort->lock);
 
     return err;
 }
 
-t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+t_Error FM_PORT_PcdKgBindSchemes(t_Handle h_FmPort,
+                                 t_FmPcdPortSchemesParams *p_PortScheme)
 {
-    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
-    t_Error                                 err = E_OK;
-    uint32_t                                tmpScmVec=0;
-    int                                     i;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes schemeBind;
+    t_Error err = E_OK;
+    uint32_t tmpScmVec = 0;
+    int i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG,
+                              E_INVALID_STATE);
 
     schemeBind.netEnvId = p_FmPort->netEnvId;
     schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
     schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
     schemeBind.useClsPlan = p_FmPort->useClsPlan;
-    for (i=0; i<schemeBind.numOfSchemes; i++)
+    for (i = 0; i < schemeBind.numOfSchemes; i++)
     {
-        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(p_PortScheme->h_Schemes[i]);
+        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(
+                p_PortScheme->h_Schemes[i]);
         /* build vector */
         tmpScmVec |= 1 << (31 - (uint32_t)schemeBind.schemesIds[i]);
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
@@ -4674,11 +5291,11 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
 
 #ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
     if ((FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd)) &&
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
-        (p_FmPort->fmRevInfo.majorRev < 6))
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
+            (p_FmPort->fmRevInfo.majorRev < 6))
     {
         for (i=0; i<p_PortScheme->numOfSchemes; i++)
-            FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PortScheme->h_Schemes[i], UPDATE_KG_NIA_CC_WA, 0);
+        FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PortScheme->h_Schemes[i], UPDATE_KG_NIA_CC_WA, 0);
     }
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
 
@@ -4687,32 +5304,35 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
     return err;
 }
 
-t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+t_Error FM_PORT_PcdKgUnbindSchemes(t_Handle h_FmPort,
+                                   t_FmPcdPortSchemesParams *p_PortScheme)
 {
-    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
-    t_Error                                 err = E_OK;
-    uint32_t                                tmpScmVec=0;
-    int                                     i;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes schemeBind;
+    t_Error err = E_OK;
+    uint32_t tmpScmVec = 0;
+    int i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG,
+                              E_INVALID_STATE);
 
     schemeBind.netEnvId = p_FmPort->netEnvId;
     schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
     schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
-    for (i=0; i<schemeBind.numOfSchemes; i++)
+    for (i = 0; i < schemeBind.numOfSchemes; i++)
     {
-        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(p_PortScheme->h_Schemes[i]);
+        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(
+                p_PortScheme->h_Schemes[i]);
         /* build vector */
         tmpScmVec |= 1 << (31 - (uint32_t)schemeBind.schemesIds[i]);
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
@@ -4723,44 +5343,50 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
     return err;
 }
 
-t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart)
+t_Error FM_PORT_PcdPrsModifyStartOffset(t_Handle h_FmPort,
+                                        t_FmPcdPrsStart *p_FmPcdPrsStart)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t   *p_BmiPrsStartOffset = NULL;
-    volatile uint32_t   *p_BmiNia = NULL;
-    uint32_t            tmpReg;
-    uint8_t             hdrNum;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiPrsStartOffset = NULL;
+    volatile uint32_t *p_BmiNia = NULL;
+    uint32_t tmpReg;
+    uint8_t hdrNum;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS,
+                              E_INVALID_STATE);
 
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+            p_BmiPrsStartOffset =
+                    &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+            p_BmiPrsStartOffset =
+                    &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             tmpReg = 0;
             break;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) !=
-        GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK)
+            != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("may be called only for ports in BMI-to-BMI state."));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     /* set the first header */
@@ -4770,12 +5396,14 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
     }
-    WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PRS | (uint32_t)hdrNum | tmpReg));
+
+    WRITE_UINT32(*p_BmiNia,
+                 (uint32_t)(NIA_ENG_PRS | (uint32_t)hdrNum | tmpReg));
 
     /* set start parsing offset */
-    WRITE_UINT32(*p_BmiPrsStartOffset,
-                 (uint32_t)(p_FmPcdPrsStart->parsingOffset +
-                            p_FmPort->internalBufferOffset));
+    WRITE_UINT32(
+            *p_BmiPrsStartOffset,
+            (uint32_t)(p_FmPcdPrsStart->parsingOffset + p_FmPort->internalBufferOffset));
     RELEASE_LOCK(p_FmPort->lock);
 
     return E_OK;
@@ -4784,11 +5412,11 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error             err = E_OK;
-    char                arr[20];
-    uint8_t             flag;
-    int                 i=0;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
+    char arr[20];
+    uint8_t flag;
+    int i=0;
 
     DECLARE_DUMP;
 
@@ -4801,40 +5429,40 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            strcpy(arr, "OFFLINE-PARSING");
-            flag = 0;
-            break;
+        strcpy(arr, "OFFLINE-PARSING");
+        flag = 0;
+        break;
         case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            strcpy(arr, "HOST-COMMAND");
-            flag = 0;
-            break;
+        strcpy(arr, "HOST-COMMAND");
+        flag = 0;
+        break;
         case (e_FM_PORT_TYPE_RX):
-            strcpy(arr, "RX");
-            flag = 1;
-            break;
+        strcpy(arr, "RX");
+        flag = 1;
+        break;
         case (e_FM_PORT_TYPE_RX_10G):
-            strcpy(arr, "RX-10G");
-            flag = 1;
-            break;
+        strcpy(arr, "RX-10G");
+        flag = 1;
+        break;
         case (e_FM_PORT_TYPE_TX):
-            strcpy(arr, "TX");
-            flag = 2;
-            break;
+        strcpy(arr, "TX");
+        flag = 2;
+        break;
         case (e_FM_PORT_TYPE_TX_10G):
-            strcpy(arr, "TX-10G");
-            flag = 2;
-            break;
+        strcpy(arr, "TX-10G");
+        flag = 2;
+        break;
         default:
-            return ERROR_CODE(E_INVALID_VALUE);
+        return ERROR_CODE(E_INVALID_VALUE);
     }
 
     DUMP_TITLE(NULL,
-               ("FMan-Port (%s #%d) registers:",
-                arr, p_FmPort->portId));
+            ("FMan-Port (%s #%d) registers:",
+                    arr, p_FmPort->portId));
 
     err = FmDumpPortRegs(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
     if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    RETURN_ERROR(MAJOR, err, NO_MSG);
 
     DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
 
@@ -4909,7 +5537,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ogpr);
         break;
-    case (1):
+        case (1):
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
@@ -4978,7 +5606,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rgpr);
         break;
-    case (2):
+        case (2):
 
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
@@ -5019,7 +5647,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tgpr);
         break;
 
-   default:
+        default:
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid flag"));
     }
 
@@ -5044,40 +5672,42 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
-t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort,
+                                  t_FmPortCongestionGrps *p_CongestionGrps)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint8_t             priorityTmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
-    uint8_t             mod, index;
-    uint32_t            i, grpsMap[FMAN_PORT_CG_MAP_NUM];
-    int                 err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint8_t priorityTmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
+    uint8_t mod, index;
+    uint32_t i, grpsMap[FMAN_PORT_CG_MAP_NUM];
+    int err;
 #if (DPAA_VERSION >= 11)
-    int                 j;
+    int j;
 #endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     /* un-necessary check of the indexes; probably will be needed in the future when there
-       will be more CGs available ....
-    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
-        if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("CG id!"));
-    */
+     will be more CGs available ....
+     for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+     if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
+     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("CG id!"));
+     */
 
 #ifdef FM_NO_OP_OBSERVED_CGS
     if ((p_FmPort->fmRevInfo.majorRev != 4) &&
-        (p_FmPort->fmRevInfo.majorRev < 6))
+            (p_FmPort->fmRevInfo.majorRev < 6))
     {
         if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-            (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+                (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
     }
     else
 #endif /* FM_NO_OP_OBSERVED_CGS */
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("Available for Rx & OP ports only"));
 
     /* Prepare groups map array */
     memset(grpsMap, 0, FMAN_PORT_CG_MAP_NUM * sizeof(uint32_t));
@@ -5091,60 +5721,64 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
             grpsMap[0] |= (uint32_t)(1 << mod);
     }
 
-    memset(&priorityTmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(uint8_t));
+    memset(&priorityTmpArray, 0,
+           FM_PORT_NUM_OF_CONGESTION_GRPS * sizeof(uint8_t));
 
-    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
     {
 #if (DPAA_VERSION >= 11)
-        for (j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
+        for (j = 0; j < FM_MAX_NUM_OF_PFC_PRIORITIES; j++)
             if (p_CongestionGrps->pfcPrioritiesEn[i][j])
-                priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j-1));
+                priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |=
+                        (0x01 << (FM_MAX_NUM_OF_PFC_PRIORITIES - j - 1));
 #endif /* (DPAA_VERSION >= 11) */
     }
 
 #if (DPAA_VERSION >= 11)
-    for (i=0; i<FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
+    for (i = 0; i < FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
     {
-            err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm,i,priorityTmpArray[i]);
-            if (err)
-                return err;
-     }
+        err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm, i,
+                                              priorityTmpArray[i]);
+        if (err)
+            return err;
+    }
 #endif /* (DPAA_VERSION >= 11) */
 
     err = fman_port_add_congestion_grps(&p_FmPort->port, grpsMap);
     if (err != 0)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_add_congestion_grps"));
 
-    return  E_OK;
+    return E_OK;
 }
 
-t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort,
+                                     t_FmPortCongestionGrps *p_CongestionGrps)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint8_t             mod, index;
-    uint32_t            i, grpsMap[FMAN_PORT_CG_MAP_NUM];
-    int                 err;
-
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint8_t mod, index;
+    uint32_t i, grpsMap[FMAN_PORT_CG_MAP_NUM];
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     {
 #ifdef FM_NO_OP_OBSERVED_CGS
-        t_FmRevisionInfo    revInfo;
+        t_FmRevisionInfo revInfo;
 
         FM_GetRevision(p_FmPort->h_Fm, &revInfo);
         if (revInfo.majorRev != 4)
         {
             if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-               (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+                    (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
         }
         else
 #endif /* FM_NO_OP_OBSERVED_CGS */
-        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-           (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-           (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+                && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+                && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                         ("Available for Rx & OP ports only"));
     }
 
     /* Prepare groups map array */
@@ -5160,28 +5794,33 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     }
 
 #if (DPAA_VERSION >= 11)
-    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
     {
-    t_Error err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm,
-        p_CongestionGrps->congestionGrpsToConsider[i], 0);
-    if (err)
-        return err;
+        t_Error err = FmSetCongestionGroupPFCpriority(
+                p_FmPort->h_Fm, p_CongestionGrps->congestionGrpsToConsider[i],
+                0);
+        if (err)
+            return err;
     }
 #endif /* (DPAA_VERSION >= 11) */
 
     err = fman_port_remove_congestion_grps(&p_FmPort->port, grpsMap);
     if (err != 0)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_remove_congestion_grps"));
-    return  E_OK;
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("fman_port_remove_congestion_grps"));
+    return E_OK;
 }
 
 #if (DPAA_VERSION >= 11)
-t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount)
+t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort,
+                                    uint32_t *p_Ipv4OptionsCount)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING),
+            E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_ParamsPage, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Ipv4OptionsCount, E_NULL_POINTER);
 
@@ -5191,11 +5830,14 @@ t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCo
 }
 #endif /* (DPAA_VERSION >= 11) */
 
-t_Error FM_PORT_ConfigDsarSupport(t_Handle h_FmPortRx, t_FmPortDsarTablesSizes *params)
+t_Error FM_PORT_ConfigDsarSupport(t_Handle h_FmPortRx,
+                                  t_FmPortDsarTablesSizes *params)
 {
-    t_FmPort *p_FmPort= (t_FmPort *)h_FmPortRx;
-    p_FmPort->deepSleepVars.autoResMaxSizes = XX_Malloc(sizeof(struct t_FmPortDsarTablesSizes));
-    memcpy(p_FmPort->deepSleepVars.autoResMaxSizes, params, sizeof(struct t_FmPortDsarTablesSizes));
+    t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;
+    p_FmPort->deepSleepVars.autoResMaxSizes = XX_Malloc(
+            sizeof(struct t_FmPortDsarTablesSizes));
+    memcpy(p_FmPort->deepSleepVars.autoResMaxSizes, params,
+           sizeof(struct t_FmPortDsarTablesSizes));
     return E_OK;
 }
 
@@ -5229,8 +5871,10 @@ static t_Error FmPortConfigAutoResForDeepSleepSupport1(t_FmPort *p_FmPort)
     //SNMP
     size = ROUND_UP(size,4);
     size += sizeof(t_DsarSnmpDescriptor);
-    size += sizeof(t_DsarSnmpIpv4AddrTblEntry) * params->maxNumOfSnmpIPV4Entries;
-    size += sizeof(t_DsarSnmpIpv6AddrTblEntry) * params->maxNumOfSnmpIPV6Entries;
+    size += sizeof(t_DsarSnmpIpv4AddrTblEntry)
+            * params->maxNumOfSnmpIPV4Entries;
+    size += sizeof(t_DsarSnmpIpv6AddrTblEntry)
+            * params->maxNumOfSnmpIPV6Entries;
     size += sizeof(t_OidsTblEntry) * params->maxNumOfSnmpOidEntries;
     size += params->maxNumOfSnmpOidChar;
     size += sizeof(t_DsarIcmpV6Statistics);
@@ -5249,16 +5893,20 @@ static t_Error FmPortConfigAutoResForDeepSleepSupport1(t_FmPort *p_FmPort)
     size += sizeof(t_ArStatistics);
 
     ArCommonDescPtr = FM_MURAM_AllocMem(p_FmPort->h_FmMuram, size, 0x10);
-    
-    param_page = XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr + GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr));
-    WRITE_UINT32(*param_page,
+
+    param_page =
+            XX_PhysToVirt(
+                    p_FmPort->fmMuramPhysBaseAddr
+                            + GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr));
+    WRITE_UINT32(
+            *param_page,
             (uint32_t)(XX_VirtToPhys(ArCommonDescPtr) - p_FmPort->fmMuramPhysBaseAddr));
     return E_OK;
 }
 
 t_FmPortDsarTablesSizes* FM_PORT_GetDsarTablesMaxSizes(t_Handle h_FmPortRx)
 {
-    t_FmPort *p_FmPort= (t_FmPort *)h_FmPortRx;
+    t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;
     return p_FmPort->deepSleepVars.autoResMaxSizes;
 }
 
@@ -5275,7 +5923,9 @@ struct arOffsets
     uint32_t filtTcp;
 };
 
-static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParams *params, t_FmPort *p_FmPort)
+static uint32_t AR_ComputeOffsets(struct arOffsets* of,
+                                  struct t_FmPortDsarParams *params,
+                                  t_FmPort *p_FmPort)
 {
     uint32_t size = sizeof(t_ArCommonDesc);
     // ARP
@@ -5284,7 +5934,8 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->arp = size;
         size += sizeof(t_DsarArpDescriptor);
-        size += sizeof(t_DsarArpBindingEntry) * params->p_AutoResArpInfo->tableSize;
+        size += sizeof(t_DsarArpBindingEntry)
+                * params->p_AutoResArpInfo->tableSize;
         size += sizeof(t_DsarArpStatistics);
     }
     // ICMPV4
@@ -5293,7 +5944,8 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->icmpv4 = size;
         size += sizeof(t_DsarIcmpV4Descriptor);
-        size += sizeof(t_DsarIcmpV4BindingEntry) * params->p_AutoResEchoIpv4Info->tableSize;
+        size += sizeof(t_DsarIcmpV4BindingEntry)
+                * params->p_AutoResEchoIpv4Info->tableSize;
         size += sizeof(t_DsarIcmpV4Statistics);
     }
     // ICMPV6
@@ -5302,7 +5954,8 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->icmpv6 = size;
         size += sizeof(t_DsarIcmpV6Descriptor);
-        size += sizeof(t_DsarIcmpV6BindingEntry) * params->p_AutoResEchoIpv6Info->tableSize;
+        size += sizeof(t_DsarIcmpV6BindingEntry)
+                * params->p_AutoResEchoIpv6Info->tableSize;
         size += sizeof(t_DsarIcmpV6Statistics);
     }
     // ND
@@ -5311,8 +5964,9 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->nd = size;
         size += sizeof(t_DsarNdDescriptor);
-        size += sizeof(t_DsarIcmpV6BindingEntry) *
-            (params->p_AutoResNdpInfo->tableSizeAssigned + params->p_AutoResNdpInfo->tableSizeTmp);
+        size += sizeof(t_DsarIcmpV6BindingEntry)
+                * (params->p_AutoResNdpInfo->tableSizeAssigned
+                        + params->p_AutoResNdpInfo->tableSizeTmp);
         size += sizeof(t_DsarIcmpV6Statistics);
     }
     // SNMP
@@ -5321,8 +5975,10 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->snmp = size;
         size += sizeof(t_DsarSnmpDescriptor);
-        size += sizeof(t_DsarSnmpIpv4AddrTblEntry) * params->p_AutoResSnmpInfo->numOfIpv4Addresses;
-        size += sizeof(t_DsarSnmpIpv6AddrTblEntry) * params->p_AutoResSnmpInfo->numOfIpv6Addresses;
+        size += sizeof(t_DsarSnmpIpv4AddrTblEntry)
+                * params->p_AutoResSnmpInfo->numOfIpv4Addresses;
+        size += sizeof(t_DsarSnmpIpv6AddrTblEntry)
+                * params->p_AutoResSnmpInfo->numOfIpv6Addresses;
         size += sizeof(t_OidsTblEntry) * params->p_AutoResSnmpInfo->oidsTblSize;
         size += p_FmPort->deepSleepVars.autoResMaxSizes->maxNumOfSnmpOidChar;
         size += sizeof(t_DsarIcmpV6Statistics);
@@ -5335,10 +5991,12 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size += params->p_AutoResFilteringInfo->ipProtTableSize;
         size = ROUND_UP(size,4);
         of->filtUdp = size;
-        size += params->p_AutoResFilteringInfo->udpPortsTableSize * sizeof(t_PortTblEntry);
+        size += params->p_AutoResFilteringInfo->udpPortsTableSize
+                * sizeof(t_PortTblEntry);
         size = ROUND_UP(size,4);
         of->filtTcp = size;
-        size += params->p_AutoResFilteringInfo->tcpPortsTableSize * sizeof(t_PortTblEntry);
+        size += params->p_AutoResFilteringInfo->tcpPortsTableSize
+                * sizeof(t_PortTblEntry);
     }
     // add here for more protocols
     // statistics
@@ -5354,101 +6012,167 @@ void PrsDisable(t_Handle p_FmPcd);
 int PrsIsEnabled(t_Handle p_FmPcd);
 t_Handle FM_PCD_GetHcPort(t_Handle h_FmPcd);
 
-static t_Error DsarCheckParams(t_FmPortDsarParams *params, t_FmPortDsarTablesSizes *sizes)
+static t_Error DsarCheckParams(t_FmPortDsarParams *params,
+                               t_FmPortDsarTablesSizes *sizes)
 {
     bool macInit = FALSE;
     uint8_t mac[6];
     int i;
-    
+
     // check table sizes
-    if (params->p_AutoResArpInfo && sizes->maxNumOfArpEntries < params->p_AutoResArpInfo->tableSize)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Arp table size exceeds the configured maximum size."));
-    if (params->p_AutoResEchoIpv4Info && sizes->maxNumOfEchoIpv4Entries < params->p_AutoResEchoIpv4Info->tableSize)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: EchoIpv4 table size exceeds the configured maximum size."));
-    if (params->p_AutoResNdpInfo && sizes->maxNumOfNdpEntries < params->p_AutoResNdpInfo->tableSizeAssigned + params->p_AutoResNdpInfo->tableSizeTmp)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: NDP table size exceeds the configured maximum size."));
-    if (params->p_AutoResEchoIpv6Info && sizes->maxNumOfEchoIpv6Entries < params->p_AutoResEchoIpv6Info->tableSize)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: EchoIpv6 table size exceeds the configured maximum size."));
-    if (params->p_AutoResSnmpInfo && sizes->maxNumOfSnmpOidEntries < params->p_AutoResSnmpInfo->oidsTblSize)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Snmp Oid table size exceeds the configured maximum size."));
-    if (params->p_AutoResSnmpInfo && sizes->maxNumOfSnmpIPV4Entries < params->p_AutoResSnmpInfo->numOfIpv4Addresses)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Snmp ipv4 table size exceeds the configured maximum size."));
-    if (params->p_AutoResSnmpInfo && sizes->maxNumOfSnmpIPV6Entries < params->p_AutoResSnmpInfo->numOfIpv6Addresses)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Snmp ipv6 table size exceeds the configured maximum size."));
+    if (params->p_AutoResArpInfo
+            && sizes->maxNumOfArpEntries < params->p_AutoResArpInfo->tableSize)
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("DSAR: Arp table size exceeds the configured maximum size."));
+    if (params->p_AutoResEchoIpv4Info
+            && sizes->maxNumOfEchoIpv4Entries
+                    < params->p_AutoResEchoIpv4Info->tableSize)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: EchoIpv4 table size exceeds the configured maximum size."));
+    if (params->p_AutoResNdpInfo
+            && sizes->maxNumOfNdpEntries
+                    < params->p_AutoResNdpInfo->tableSizeAssigned
+                            + params->p_AutoResNdpInfo->tableSizeTmp)
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("DSAR: NDP table size exceeds the configured maximum size."));
+    if (params->p_AutoResEchoIpv6Info
+            && sizes->maxNumOfEchoIpv6Entries
+                    < params->p_AutoResEchoIpv6Info->tableSize)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: EchoIpv6 table size exceeds the configured maximum size."));
+    if (params->p_AutoResSnmpInfo
+            && sizes->maxNumOfSnmpOidEntries
+                    < params->p_AutoResSnmpInfo->oidsTblSize)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: Snmp Oid table size exceeds the configured maximum size."));
+    if (params->p_AutoResSnmpInfo
+            && sizes->maxNumOfSnmpIPV4Entries
+                    < params->p_AutoResSnmpInfo->numOfIpv4Addresses)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: Snmp ipv4 table size exceeds the configured maximum size."));
+    if (params->p_AutoResSnmpInfo
+            && sizes->maxNumOfSnmpIPV6Entries
+                    < params->p_AutoResSnmpInfo->numOfIpv6Addresses)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: Snmp ipv6 table size exceeds the configured maximum size."));
     if (params->p_AutoResFilteringInfo)
     {
-        if (sizes->maxNumOfIpProtFiltering < params->p_AutoResFilteringInfo->ipProtTableSize)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: ip filter table size exceeds the configured maximum size."));
-        if (sizes->maxNumOfTcpPortFiltering < params->p_AutoResFilteringInfo->udpPortsTableSize)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: udp filter table size exceeds the configured maximum size."));
-        if (sizes->maxNumOfUdpPortFiltering < params->p_AutoResFilteringInfo->tcpPortsTableSize)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: tcp filter table size exceeds the configured maximum size."));
+        if (sizes->maxNumOfIpProtFiltering
+                < params->p_AutoResFilteringInfo->ipProtTableSize)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("DSAR: ip filter table size exceeds the configured maximum size."));
+        if (sizes->maxNumOfTcpPortFiltering
+                < params->p_AutoResFilteringInfo->udpPortsTableSize)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("DSAR: udp filter table size exceeds the configured maximum size."));
+        if (sizes->maxNumOfUdpPortFiltering
+                < params->p_AutoResFilteringInfo->tcpPortsTableSize)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("DSAR: tcp filter table size exceeds the configured maximum size."));
     }
     // check only 1 MAC address is configured (this is what ucode currently supports)
     if (params->p_AutoResArpInfo && params->p_AutoResArpInfo->tableSize)
     {
-	i = 0;
+        i = 0;
         if (!macInit)
-	{
+        {
             memcpy(mac, params->p_AutoResArpInfo->p_AutoResTable[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResArpInfo->tableSize; i++)
-	    if (memcmp(mac, params->p_AutoResArpInfo->p_AutoResTable[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+            i = 1;
+            macInit = TRUE;
+        }
+        for (; i < params->p_AutoResArpInfo->tableSize; i++)
+            if (memcmp(mac, params->p_AutoResArpInfo->p_AutoResTable[i].mac, 6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
-    if (params->p_AutoResEchoIpv4Info && params->p_AutoResEchoIpv4Info->tableSize)
+    if (params->p_AutoResEchoIpv4Info
+            && params->p_AutoResEchoIpv4Info->tableSize)
     {
-	i = 0;
+        i = 0;
         if (!macInit)
-	{
-            memcpy(mac, params->p_AutoResEchoIpv4Info->p_AutoResTable[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResEchoIpv4Info->tableSize; i++)
-	    if (memcmp(mac, params->p_AutoResEchoIpv4Info->p_AutoResTable[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+        {
+            memcpy(mac, params->p_AutoResEchoIpv4Info->p_AutoResTable[0].mac,
+                   6);
+            i = 1;
+            macInit = TRUE;
+        }
+        for (; i < params->p_AutoResEchoIpv4Info->tableSize; i++)
+            if (memcmp(mac,
+                       params->p_AutoResEchoIpv4Info->p_AutoResTable[i].mac, 6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
-    if (params->p_AutoResEchoIpv6Info && params->p_AutoResEchoIpv6Info->tableSize)
+    if (params->p_AutoResEchoIpv6Info
+            && params->p_AutoResEchoIpv6Info->tableSize)
     {
-	i = 0;
+        i = 0;
         if (!macInit)
-	{
-            memcpy(mac, params->p_AutoResEchoIpv6Info->p_AutoResTable[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResEchoIpv6Info->tableSize; i++)
-	    if (memcmp(mac, params->p_AutoResEchoIpv6Info->p_AutoResTable[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+        {
+            memcpy(mac, params->p_AutoResEchoIpv6Info->p_AutoResTable[0].mac,
+                   6);
+            i = 1;
+            macInit = TRUE;
+        }
+        for (; i < params->p_AutoResEchoIpv6Info->tableSize; i++)
+            if (memcmp(mac,
+                       params->p_AutoResEchoIpv6Info->p_AutoResTable[i].mac, 6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
     if (params->p_AutoResNdpInfo && params->p_AutoResNdpInfo->tableSizeAssigned)
     {
-	i = 0;
+        i = 0;
         if (!macInit)
-	{
-            memcpy(mac, params->p_AutoResNdpInfo->p_AutoResTableAssigned[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResNdpInfo->tableSizeAssigned; i++)
-	    if (memcmp(mac, params->p_AutoResNdpInfo->p_AutoResTableAssigned[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+        {
+            memcpy(mac, params->p_AutoResNdpInfo->p_AutoResTableAssigned[0].mac,
+                   6);
+            i = 1;
+            macInit = TRUE;
+        }
+        for (; i < params->p_AutoResNdpInfo->tableSizeAssigned; i++)
+            if (memcmp(mac,
+                       params->p_AutoResNdpInfo->p_AutoResTableAssigned[i].mac,
+                       6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
     if (params->p_AutoResNdpInfo && params->p_AutoResNdpInfo->tableSizeTmp)
     {
-	i = 0;
+        i = 0;
         if (!macInit)
-	{
+        {
             memcpy(mac, params->p_AutoResNdpInfo->p_AutoResTableTmp[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResNdpInfo->tableSizeTmp; i++)
-	    if (memcmp(mac, params->p_AutoResNdpInfo->p_AutoResTableTmp[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+            i = 1;
+            macInit = TRUE;
+        }
+        for (; i < params->p_AutoResNdpInfo->tableSizeTmp; i++)
+            if (memcmp(mac, params->p_AutoResNdpInfo->p_AutoResTableTmp[i].mac,
+                       6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
     return E_OK;
 }
@@ -5493,11 +6217,11 @@ void fm_clk_down(void)
 
 t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
 {
-    int i,j;
+    int i, j;
     t_Error err;
     uint32_t nia;
-    t_FmPort            *p_FmPort= (t_FmPort *)h_FmPortRx;
-    t_FmPort            *p_FmPortTx = (t_FmPort *)params->h_FmPortTx;
+    t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;
+    t_FmPort *p_FmPortTx = (t_FmPort *)params->h_FmPortTx;
     t_DsarArpDescriptor *ArpDescriptor;
     t_DsarIcmpV4Descriptor* ICMPV4Descriptor;
     t_DsarIcmpV6Descriptor* ICMPV6Descriptor;
@@ -5515,8 +6239,8 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
 
     err = DsarCheckParams(params, p_FmPort->deepSleepVars.autoResMaxSizes);
     if (err != E_OK)
-	return err;
-	
+        return err;
+
     p_FmPort->deepSleepVars.autoResOffsets = XX_Malloc(sizeof(struct arOffsets));
     of = (struct arOffsets *)p_FmPort->deepSleepVars.autoResOffsets;
     IOMemSet32(ArCommonDescPtr, 0, AR_ComputeOffsets(of, params, p_FmPort));
@@ -5533,7 +6257,7 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // ARP
     if (params->p_AutoResArpInfo)
     {
-	t_DsarArpBindingEntry* arp_bindings;
+        t_DsarArpBindingEntry* arp_bindings;
         ArpDescriptor = (t_DsarArpDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->arp);
         WRITE_UINT32(ArCommonDescPtr->p_ArpDescriptor, PTR_TO_UINT(ArpDescriptor) - fmMuramVirtBaseAddr);
         arp_bindings = (t_DsarArpBindingEntry*)(PTR_TO_UINT(ArpDescriptor) + sizeof(t_DsarArpDescriptor));
@@ -5563,7 +6287,7 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // ICMPV4
     if (params->p_AutoResEchoIpv4Info)
     {
-	t_DsarIcmpV4BindingEntry* icmpv4_bindings;
+        t_DsarIcmpV4BindingEntry* icmpv4_bindings;
         ICMPV4Descriptor = (t_DsarIcmpV4Descriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->icmpv4);
         WRITE_UINT32(ArCommonDescPtr->p_IcmpV4Descriptor, PTR_TO_UINT(ICMPV4Descriptor) - fmMuramVirtBaseAddr);
         icmpv4_bindings = (t_DsarIcmpV4BindingEntry*)(PTR_TO_UINT(ICMPV4Descriptor) + sizeof(t_DsarIcmpV4Descriptor));
@@ -5590,7 +6314,7 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // ICMPV6
     if (params->p_AutoResEchoIpv6Info)
     {
-	t_DsarIcmpV6BindingEntry* icmpv6_bindings;
+        t_DsarIcmpV6BindingEntry* icmpv6_bindings;
         ICMPV6Descriptor = (t_DsarIcmpV6Descriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->icmpv6);
         WRITE_UINT32(ArCommonDescPtr->p_IcmpV6Descriptor, PTR_TO_UINT(ICMPV6Descriptor) - fmMuramVirtBaseAddr);
         icmpv6_bindings = (t_DsarIcmpV6BindingEntry*)(PTR_TO_UINT(ICMPV6Descriptor) + sizeof(t_DsarIcmpV6Descriptor));
@@ -5618,7 +6342,7 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // ND
     if (params->p_AutoResNdpInfo)
     {
-	t_DsarIcmpV6BindingEntry* icmpv6_bindings;
+        t_DsarIcmpV6BindingEntry* icmpv6_bindings;
         NDDescriptor = (t_DsarNdDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->nd);
         WRITE_UINT32(ArCommonDescPtr->p_NdDescriptor, PTR_TO_UINT(NDDescriptor) - fmMuramVirtBaseAddr);
         icmpv6_bindings = (t_DsarIcmpV6BindingEntry*)(PTR_TO_UINT(NDDescriptor) + sizeof(t_DsarNdDescriptor));
@@ -5732,7 +6456,7 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
         charPointer = UINT_TO_PTR(ROUND_UP(PTR_TO_UINT(charPointer),4));
         WRITE_UINT32(SnmpDescriptor->p_Statistics, PTR_TO_UINT(charPointer) - fmMuramVirtBaseAddr);
     }
-    
+
     // filtering
     if (params->p_AutoResFilteringInfo)
     {
@@ -5860,7 +6584,7 @@ t_Error FM_PORT_EnterDsarFinal(t_Handle h_DsarRxPort, t_Handle h_DsarTxPort)
 		memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
 		fmGetSetParams.setParams.type = UPDATE_FPM_EXTC_CLEAR;
 		FmGetSetParams(p_FmPort->h_Fm, &fmGetSetParams);
-	}
+}
 
 	memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
 	fmGetSetParams.getParams.type = GET_FMFP_EXTC | GET_FM_NPI;
@@ -5907,7 +6631,7 @@ void FM_PORT_ExitDsar(t_Handle h_FmPortRx, t_Handle h_FmPortTx)
         XX_Free(p_FmPort->deepSleepVars.autoResOffsets);
         p_FmPort->deepSleepVars.autoResOffsets = 0;
     }
-    
+
     if (p_FmPort->deepSleepVars.dsarEnabledParser)
         PrsDisable(FmGetPcd(p_FmPort->h_Fm));
     WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->deepSleepVars.fmbm_rfpne);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
index 75f117f..fa69625 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
@@ -211,21 +211,28 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #define FM_OH_PORT_ID                               0
 
 /***********************************************************************/
-/*          SW parser IP-fragmentation labels (offsets)                */
+/*          SW parser OFFLOAD labels (offsets)                         */
 /***********************************************************************/
 #if (DPAA_VERSION == 10)
-#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x025
-#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x300
+#define OFFLOAD_SW_PATCH_IPv4_SIZE              0x025
+#define OFFLOAD_SW_PATCH_IPv4_LABEL             0x300
 #else
-#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x046
-#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x2E0
+#define OFFLOAD_SW_PATCH_IPv4_SIZE              0x046
+#define OFFLOAD_SW_PATCH_IPv4_LABEL             0x1E0
+#define OFFLOAD_CAPWAP_SW_PATCH_LABEL           0x39b
 #endif /* (DPAA_VERSION == 10) */
-#define IP_FRAG_SW_PATCH_IPv6_LABEL             \
-    (IP_FRAG_SW_PATCH_IPv4_LABEL + IP_FRAG_SW_PATCH_IPv4_SIZE)
+/* Will be used for:
+ * 1. identify fragments
+ * 2. if no fragment, will identify the fragmentable are
+ * 3. udp-lite
+ */
+#define OFFLOAD_SW_PATCH_IPv6_LABEL             \
+    (OFFLOAD_SW_PATCH_IPv4_LABEL + OFFLOAD_SW_PATCH_IPv4_SIZE)
 
-#ifdef FM_CAPWAP_SUPPORT
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
 #define UDP_LITE_SW_PATCH_LABEL                 0x2E0
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+
 
 /**************************************************************************//**
  @Description       Memory Mapped Registers
@@ -910,6 +917,7 @@ typedef struct {
     uint32_t                    savedBmiFene;
     uint32_t                    savedBmiFpne;
     uint32_t                    savedBmiCmne;
+    uint32_t                    savedBmiOfp;
     uint32_t                    savedNonRxQmiRegsPndn;
     uint32_t                    origNonRxQmiRegsPndn;
     int                         savedPrsStartOffset;
@@ -922,7 +930,8 @@ typedef struct {
     t_FmPortRxPoolsParams       rxPoolsParams;
 //    bool                        explicitUserSizeOfFifo;
     t_Handle                    h_IpReassemblyManip;
-    t_Handle                    h_IpReassemblyTree;
+    t_Handle                    h_CapwapReassemblyManip;
+    t_Handle                    h_ReassemblyTree;
     uint64_t                    fmMuramPhysBaseAddr;
 #if (DPAA_VERSION >= 11)
     bool                        vspe;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index 552a76b..550dd78 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -4981,37 +4981,43 @@ t_Error FM_GetSpecialOperationCoding(t_Handle               h_Fm,
 
     if (revInfo.packageRev == IP_OFFLOAD_PACKAGE_NUMBER)
     {
-        switch (spOper)
-        {
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP):
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
-                    *p_SpOperCoding = 5;
-                    break;
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP):
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
-                    *p_SpOperCoding = 6;
-                    break;
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_RPD):
-                    *p_SpOperCoding = 3;
-                    break;
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN):
-                    *p_SpOperCoding = 1;
-                    break;
-            case (FM_SP_OP_IPSEC|FM_SP_OP_RPD):
-                    *p_SpOperCoding = 4;
-                    break;
-            case (FM_SP_OP_IPSEC):
-                    *p_SpOperCoding = 2;
-                    break;
-            case (FM_SP_OP_DCL4C):
-                    *p_SpOperCoding = 7;
-                    break;
-            case (FM_SP_OP_CLEAR_RPD):
-                    *p_SpOperCoding = 8;
-                    break;
-            default:
-                RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
-        }
+    switch (spOper)
+    {
+        case (FM_SP_OP_CAPWAP_DTLS_DEC):
+                *p_SpOperCoding = 9;
+                break;
+        case (FM_SP_OP_CAPWAP_DTLS_ENC):
+                *p_SpOperCoding = 10;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP):
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
+                *p_SpOperCoding = 5;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP):
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
+                *p_SpOperCoding = 6;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_RPD):
+                *p_SpOperCoding = 3;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN):
+                *p_SpOperCoding = 1;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_RPD):
+                *p_SpOperCoding = 4;
+                break;
+        case (FM_SP_OP_IPSEC):
+                *p_SpOperCoding = 2;
+                break;
+        case (FM_SP_OP_DCL4C):
+                *p_SpOperCoding = 7;
+                break;
+        case (FM_SP_OP_CLEAR_RPD):
+                *p_SpOperCoding = 8;
+                break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+    }
     }
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
index 7343d6f..b736dcc 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
@@ -51,6 +51,10 @@
 #define CLS_PLAN_NUM_PER_GRP                        8
 
 #define IP_OFFLOAD_PACKAGE_NUMBER                   106
+#define CAPWAP_OFFLOAD_PACKAGE_NUMBER               108
+#define IS_OFFLOAD_PACKAGE(num) ((num == IP_OFFLOAD_PACKAGE_NUMBER) || (num == CAPWAP_OFFLOAD_PACKAGE_NUMBER))
+
+
 
 
 /**************************************************************************//**
@@ -165,7 +169,9 @@ typedef _Packed struct t_FmPcdCtrlParamsPage {
     volatile uint32_t misc;
     volatile uint32_t errorsDiscardMask;
     volatile uint32_t discardMask;
-    volatile uint8_t  reserved3[180];
+    volatile uint8_t  reserved3[4];
+    volatile uint32_t postBmiFetchNia;
+    volatile uint8_t  reserved4[172];
 } _PackedType t_FmPcdCtrlParamsPage;
 
 
@@ -188,11 +194,11 @@ typedef struct t_FmPcdCcFragScratchPoolCmdParams {
     uint8_t     bufferPoolId;
 } t_FmPcdCcFragScratchPoolCmdParams;
 
-typedef struct t_FmPcdCcIpReassmTimeoutParams {
+typedef struct t_FmPcdCcReassmTimeoutParams {
     bool        activate;
     uint8_t     tsbs;
     uint32_t    iprcpt;
-} t_FmPcdCcIpReassmTimeoutParams;
+} t_FmPcdCcReassmTimeoutParams;
 
 typedef struct {
     uint8_t             baseEntry;
@@ -251,6 +257,7 @@ typedef struct {
     uint32_t        nia;
     t_FmFmanCtrl    orFmanCtrl;
     bool            overwrite;
+    uint8_t         ofpDpde;
 } t_SetCcParams;
 
 typedef struct {
@@ -326,6 +333,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_PSO                              0x40000000
 #define UPDATE_NIA_PNDN                         0x20000000
 #define UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY      0x10000000
+#define UPDATE_OFP_DPTE                         0x08000000
 #define UPDATE_NIA_FENE                         0x04000000
 #define UPDATE_NIA_CMNE                         0x02000000
 #define UPDATE_NIA_FPNE                         0x01000000
@@ -341,7 +349,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_KG_NIA_CC_WA                     0x10000000
 #define UPDATE_KG_OPT_MODE                      0x08000000
 #define UPDATE_KG_NIA                           0x04000000
-#define UPDATE_CC_SHADOW_CLEAR					0x02000000
+#define UPDATE_CC_SHADOW_CLEAR                    0x02000000
 /* @} */
 
 #define UPDATE_FPM_BRKC_SLP                     0x80000000
@@ -772,7 +780,8 @@ t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdC
 uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
 t_Handle    FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree);
 void        FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams);
-t_Error     FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_NetEnv, t_Handle h_IpReassemblyManip, bool schemes);
+t_Error     FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_NetEnv, t_Handle h_ReassemblyManip, bool schemes);
+t_Error     FmPcdCcTreeAddCPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_NetEnv, t_Handle h_ReassemblyManip, bool schemes);
 t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_CcTree,  uint32_t  *p_Offset,t_Handle h_FmPort);
 t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h
index 099a238..492aa8a 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h
@@ -63,7 +63,7 @@ t_Error     FmHcPcdKgSetScheme(t_Handle                   h_FmHc,
 t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
 t_Error     FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams );
 t_Error     FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams);
-t_Error     FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams *p_CcIpReassmTimeoutParams, uint8_t *p_Result);
+t_Error     FmHcPcdCcTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcReassmTimeoutParams *p_CcReassmTimeoutParams, uint8_t *p_Result);
 t_Error     FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set);
 t_Error     FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t clsPlanGrpId);
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
index a45682f..a1a96ae 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
@@ -236,6 +236,8 @@ typedef uint32_t fmSpecialOperations_t;                 /**< typedef for definin
 #define  FM_SP_OP_DCL4C                     0x08000000  /**< Set the DCL4C bit */
 #define  FM_SP_OP_CHECK_SEC_ERRORS          0x04000000  /**< Check SEC errors */
 #define  FM_SP_OP_CLEAR_RPD                 0x02000000  /**< Clear the RPD bit */
+#define  FM_SP_OP_CAPWAP_DTLS_ENC           0x01000000  /**< activate features that related to CAPWAP-DTLS post Encryption */
+#define  FM_SP_OP_CAPWAP_DTLS_DEC           0x00800000  /**< activate features that related to CAPWAP-DTLS post Decryption */
 /* @} */
 
 /**************************************************************************//**
@@ -310,19 +312,19 @@ typedef enum e_FmExceptions {
  @Description   Enum for defining port DMA swap mode
 *//***************************************************************************/
 typedef enum e_FmDmaSwapOption {
-    e_FM_DMA_NO_SWP = FMAN_DMA_NO_SWP, 			/**< No swap, transfer data as is.*/
-    e_FM_DMA_SWP_PPC_LE = FMAN_DMA_SWP_PPC_LE, 	/**< The transferred data should be swapped
-                                    			in PowerPc Little Endian mode. */
-    e_FM_DMA_SWP_BE = FMAN_DMA_SWP_BE 			/**< The transferred data should be swapped
-                                    			in Big Endian mode */
+    e_FM_DMA_NO_SWP = FMAN_DMA_NO_SWP,          /**< No swap, transfer data as is.*/
+    e_FM_DMA_SWP_PPC_LE = FMAN_DMA_SWP_PPC_LE,  /**< The transferred data should be swapped
+                                                in PowerPc Little Endian mode. */
+    e_FM_DMA_SWP_BE = FMAN_DMA_SWP_BE           /**< The transferred data should be swapped
+                                                in Big Endian mode */
 } e_FmDmaSwapOption;
 
 /**************************************************************************//**
  @Description   Enum for defining port DMA cache attributes
 *//***************************************************************************/
 typedef enum e_FmDmaCacheOption {
-    e_FM_DMA_NO_STASH = FMAN_DMA_NO_STASH,     	/**< Cacheable, no Allocate (No Stashing) */
-    e_FM_DMA_STASH = FMAN_DMA_STASH         	/**< Cacheable and Allocate (Stashing on) */
+    e_FM_DMA_NO_STASH = FMAN_DMA_NO_STASH,      /**< Cacheable, no Allocate (No Stashing) */
+    e_FM_DMA_STASH = FMAN_DMA_STASH             /**< Cacheable and Allocate (Stashing on) */
 } e_FmDmaCacheOption;
 
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
index 83cf237..3961a37 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
@@ -839,6 +839,16 @@ typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
                                                      environment with IPV6 header and IPV6_FRAG_1 option;
                                                      in case where fragment found, the fragment-extension offset
                                                      may be found at 'shim2' (in parser-result). */
+#if (DPAA_VERSION >= 11)
+typedef protocolOpt_t   capwapProtocolOpt_t;      /**< CAPWAP protocol options. */
+#define CAPWAP_FRAG_1               0x00000008  /**< CAPWAP reassembly option.
+                                                     CAPWAP Reassembly manipulation requires network
+                                                     environment with CAPWAP header and CAPWAP_FRAG_1 option;
+                                                     in case where fragment found, the fragment-extension offset
+                                                     may be found at 'shim2' (in parser-result). */
+#endif /* (DPAA_VERSION >= 11) */
+
+
 /* @} */
 
 #define FM_PCD_MANIP_MAX_HDR_SIZE               256
@@ -1137,11 +1147,42 @@ typedef enum e_FmPcdManipHdrInsrtSpecificL2 {
     e_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
 } e_FmPcdManipHdrInsrtSpecificL2;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS mapping mode
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE'
+                User should instruct the port to read the parser-result
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrQosMappingMode {
+    e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE = 0,   /**< No mapping, QoS field will not be changed */
+    e_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS, /**< QoS field will be overwritten by the last byte in the parser-result. */
+} e_FmPcdManipHdrQosMappingMode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS source
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_SRC_NONE'
+                User should left room for the parser-result on input/output buffer
+                and instruct the port to read/write the parser-result to the buffer (RPD should be set)
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrQosSrc {
+    e_FM_PCD_MANIP_HDR_QOS_SRC_NONE = 0,        /**< TODO */
+    e_FM_PCD_MANIP_HDR_QOS_SRC_USER_DEFINED,    /**< QoS will be taken from the last byte in the parser-result. */
+} e_FmPcdManipHdrQosSrc;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of header insertion
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrInsrtByHdrType {
-    e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2         /**< Specific L2 fields insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2,        /**< Specific L2 fields insertion */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_MANIP_INSRT_BY_HDR_IP,                 /**< IP insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,                /**< UDP insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE,             /**< UDP lite insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP                 /**< CAPWAP insertion */
+#endif /* (DPAA_VERSION >= 11) */
 } e_FmPcdManipHdrInsrtByHdrType;
 
 /**************************************************************************//**
@@ -1164,9 +1205,12 @@ typedef enum e_FmPcdManipHdrCustomIpReplace {
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrRmvByHdrType {
     e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0,      /**< Specific L2 fields removal */
-#ifdef FM_CAPWAP_SUPPORT
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP,                  /**< CAPWAP removal */
+#endif /* (DPAA_VERSION >= 11) */
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
     e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
 } e_FmPcdManipHdrRmvByHdrType;
 
 /**************************************************************************//**
@@ -1242,7 +1286,10 @@ typedef enum e_FmPcdManipDontFragAction {
  @Description   Enumeration type for selecting type of special offload manipulation
 *//***************************************************************************/
 typedef enum e_FmPcdManipSpecialOffloadType {
-    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC    /**< IPSec offload manipulation */
+    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC,    /**< IPSec offload manipulation */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP    /**< CAPWAP offload manipulation */
+#endif /* (DPAA_VERSION >= 11) */
 } e_FmPcdManipSpecialOffloadType;
 
 
@@ -1255,6 +1302,9 @@ typedef union u_FmPcdHdrProtocolOpt {
     mplsProtocolOpt_t   mplsOpt;    /**< MPLS options */
     ipv4ProtocolOpt_t   ipv4Opt;    /**< IPv4 options */
     ipv6ProtocolOpt_t   ipv6Opt;    /**< IPv6 options */
+#if (DPAA_VERSION >= 11)
+    capwapProtocolOpt_t capwapOpt;  /**< CAPWAP options */
+#endif /* (DPAA_VERSION >= 11) */
 } u_FmPcdHdrProtocolOpt;
 
 /**************************************************************************//**
@@ -1330,7 +1380,7 @@ typedef union u_FmPcdHdrProtocolOpt {
                         NET_HEADER_FIELD_UDP_PORT_SRC
                         NET_HEADER_FIELD_UDP_PORT_DST
 
-                    HEADER_TYPE_UDP_LITE: - relevant only if FM_CAPWAP_SUPPORT define
+                    HEADER_TYPE_UDP_LITE:
                         NET_HEADER_FIELD_UDP_LITE_PORT_SRC
                         NET_HEADER_FIELD_UDP_LITE_PORT_DST
 
@@ -2177,13 +2227,16 @@ typedef struct t_FmPcdManipFragOrReasmParams {
 typedef struct t_FmPcdManipHdrRmvByHdrParams {
     e_FmPcdManipHdrRmvByHdrType         type;           /**< Selection of header removal location */
     union {
-#ifdef FM_CAPWAP_SUPPORT
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
         struct {
             bool                        include;        /**< If FALSE, remove until the specified header (not including the header);
                                                              If TRUE, remove also the specified header. */
             t_FmManipHdrInfo            hdrInfo;
         } fromStartByHdr;                               /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
 #endif /* FM_CAPWAP_SUPPORT */
+#if (DPAA_VERSION >= 11)
+        t_FmManipHdrInfo                hdrInfo;        /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* (DPAA_VERSION >= 11) */
         e_FmPcdManipHdrRmvSpecificL2    specificL2;     /**< Relevant when type = e_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
                                                              Defines which L2 headers to remove. */
     } u;
@@ -2298,6 +2351,84 @@ typedef struct t_FmPcdManipSpecialOffloadIPSecParams {
                                                      corresponding SA. */
 } t_FmPcdManipSpecialOffloadIPSecParams;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP fragmentation manipulation
+
+ Restrictions:
+     - Maximum number of fragments per frame is 16.
+     - Transmit confirmation is not supported.
+     - Fragmentation nodes must be set as the last PCD action (i.e. the
+       corresponding CC node key must have next engine set to e_FM_PCD_DONE).
+     - Only BMan buffers shall be used for frames to be fragmented.
+     - NOTE: The following comment is relevant only for FMAN v3 devices: IPF
+       does not support VSP. Therefore, on the same port where we have IPF we
+       cannot support VSP.
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragCapwapParams {
+    uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
+                                                             CAPWAP fragmentation will be executed.*/
+    bool                        sgBpidEn;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                             received frame's buffer. */
+    uint8_t                     sgBpid;                 /**< Scatter/Gather buffer pool id;
+                                                             This parameters is relevant when 'sgBpidEn=TRUE';
+                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                             of this pool need to be allocated in the same memory area as the received buffers.
+                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                             mutual to all these sources. */
+    bool                        compressModeEn;         /**< CAPWAP Header Options Compress Enable mode;
+                                                             When this mode is enabled then only the first fragment include the CAPWAP header options
+                                                             field (if user provides it in the input frame) and all other fragments exclude the CAPWAP
+                                                             options field (CAPWAP header is updated accordingly).*/
+} t_FmPcdManipFragCapwapParams;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP reassembly manipulation.
+
+ Restrictions:
+    - Application must define one scheme to catch the reassembled frames.
+    - Maximum number of fragments per frame is 16.
+
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemCapwapParams {
+    uint8_t                         relativeSchemeId;    /**< Partition relative scheme id;
+                                                                 NOTE: this id must be smaller than the user schemes id to ensure that the reassembly scheme will be first match;
+                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
+    uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        maxReassembledFrameLength;/**< The maximum CAPWAP reassembled frame length in bytes;
+                                                                   If maxReassembledFrameLength == 0, any successful reassembled frame length is
+                                                                   considered as a valid length;
+                                                                   if maxReassembledFrameLength > 0, a successful reassembled frame which its length
+                                                                   exceeds this value is considered as an error frame (FD status[CRE] bit is set). */
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
+                                                            /**< Number of frames per hash entry needed for reassembly process */
+    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by reassembly in the same time;
+                                                                 Must be power of 2;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process;
+                                                                 Recommended value for this field is 0; in this way timed-out frames will be discarded */
+    uint32_t                        timeoutThresholdForReassmProcess;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} t_FmPcdManipReassemCapwapParams;
+
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipSpecialOffloadCapwapParams {
+    bool                    dtls;   /**< TRUE if continue to SEC DTLS encryption */
+    e_FmPcdManipHdrQosSrc   qosSrc; /**< TODO */
+} t_FmPcdManipSpecialOffloadCapwapParams;
+
+#endif /* (DPAA_VERSION >= 11) */
+
+
 /**************************************************************************//**
  @Description   Parameters for defining special offload manipulation
 *//***************************************************************************/
@@ -2307,10 +2438,23 @@ typedef struct t_FmPcdManipSpecialOffloadParams {
     {
         t_FmPcdManipSpecialOffloadIPSecParams   ipsec;      /**< Parameters for IPSec; Relevant when
                                                                  type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipSpecialOffloadCapwapParams  capwap;     /**< Parameters for CAPWAP; Relevant when
+                                                                 type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } t_FmPcdManipSpecialOffloadParams;
 
 /**************************************************************************//**
+ @Description   Parameters for defining insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrt {
+    uint8_t size;           /**< size of inserted section */
+    uint8_t *p_Data;        /**< data to be inserted */
+} t_FmPcdManipHdrInsrt;
+
+
+/**************************************************************************//**
  @Description   Parameters for defining generic removal manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipHdrRmvGenericParams {
@@ -2452,6 +2596,20 @@ typedef struct t_FmPcdManipHdrInsrtSpecificL2Params {
     uint8_t                         *p_Data;        /**< data to be inserted */
 } t_FmPcdManipHdrInsrtSpecificL2Params;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining IP insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtIpParams {
+    bool    calcL4Checksum; /**< Calculate L4 checksum. */
+    e_FmPcdManipHdrQosMappingMode   mappingMode; /**< TODO */
+    uint8_t lastPidOffset;     /**< the offset of the last Protocol within
+                                 the inserted header */
+    uint16_t  id;           /**< 16 bit New IP ID */
+    t_FmPcdManipHdrInsrt insrt; /**< size and data to be inserted. */
+} t_FmPcdManipHdrInsrtIpParams;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Parameters for defining header insertion manipulation by header type
 *//***************************************************************************/
@@ -2459,9 +2617,15 @@ typedef struct t_FmPcdManipHdrInsrtByHdrParams {
     e_FmPcdManipHdrInsrtByHdrType               type;   /**< Selects manipulation type */
     union {
 
-       t_FmPcdManipHdrInsrtSpecificL2Params     specificL2Params;
-                                                        /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
-                                                             Selects which L2 headers to remove */
+        t_FmPcdManipHdrInsrtSpecificL2Params    specificL2Params;
+                                                             /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
+                                                              Selects which L2 headers to insert */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipHdrInsrtIpParams             ipParams;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
+        t_FmPcdManipHdrInsrt                    insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE, or
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } t_FmPcdManipHdrInsrtByHdrParams;
 
@@ -2521,6 +2685,10 @@ typedef struct t_FmPcdManipHdrParams {
 typedef struct t_FmPcdManipFragParams {
     e_NetHeaderType                     hdr;          /**< Header selection */
     union {
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipFragCapwapParams    capwapFrag;   /**< Parameters for defining CAPWAP fragmentation,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
         t_FmPcdManipFragIpParams        ipFrag;       /**< Parameters for defining IP fragmentation,
                                                            relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
     } u;
@@ -2532,12 +2700,16 @@ typedef struct t_FmPcdManipFragParams {
 typedef struct t_FmPcdManipReassemParams {
     e_NetHeaderType                     hdr;          /**< Header selection */
     union {
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipReassemCapwapParams capwapReassem;  /**< Parameters for defining CAPWAP reassembly,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+
         t_FmPcdManipReassemIpParams     ipReassem;    /**< Parameters for defining IP reassembly,
                                                            relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
     } u;
 } t_FmPcdManipReassemParams;
 
-
 /**************************************************************************//**
  @Description   Parameters for defining a manipulation node
 *//***************************************************************************/
@@ -2601,12 +2773,55 @@ typedef struct t_FmPcdManipFragIpStats {
     uint32_t    generatedFragments;     /**< Number of fragments that were generated */
 } t_FmPcdManipFragIpStats;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP reassembly statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemCapwapStats {
+    uint32_t    timeout;                    /**< Counts the number of timeout occurrences */
+    uint32_t    rfdPoolBusy;                /**< Counts the number of failed attempts to allocate
+                                                 a Reassembly Frame Descriptor */
+    uint32_t    internalBufferBusy;         /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t    externalBufferBusy;         /**< Counts the number of times external buffer busy occurred */
+    uint32_t    sgFragments;                /**< Counts the number of Scatter/Gather fragments */
+    uint32_t    dmaSemaphoreDepletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
+    uint32_t    validFragments;             /**< Counts the total number of valid fragments that
+                                                 have been processed for all frames */
+    uint32_t    processedFragments;         /**< Counts the number of processed fragments
+                                                 (valid and error fragments) for all frames */
+    uint32_t    malformedFragments;         /**< Counts the number of malformed fragments processed for all frames */
+    uint32_t    autoLearnBusy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                 to access an Reassembly Automatic Learning Hash set */
+    uint32_t    discardedFragments;         /**< Counts the number of fragments discarded by the reassembly process */
+    uint32_t    moreThan16Fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                 exceeds 16 */
+    uint32_t    exceedMaxReassemblyFrameLen;/**< ounts the number of times that a successful reassembled frame
+                                                 length exceeds MaxReassembledFrameLength value */
+} t_FmPcdManipReassemCapwapStats;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP fragmentation statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragCapwapStats {
+    uint32_t    totalFrames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmentedFrames;       /**< Number of frames that were fragmented */
+    uint32_t    generatedFragments;     /**< Number of fragments that were generated */
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    uint8_t     sgAllocationFailure;    /**< Number of allocation failure of s/g buffers */
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+} t_FmPcdManipFragCapwapStats;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Structure for retrieving reassembly statistics
 *//***************************************************************************/
 typedef struct t_FmPcdManipReassemStats {
     union {
         t_FmPcdManipReassemIpStats  ipReassem;  /**< Structure for IP reassembly statistics */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipReassemCapwapStats  capwapReassem;  /**< Structure for CAPWAP reassembly statistics */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } t_FmPcdManipReassemStats;
 
@@ -2616,6 +2831,9 @@ typedef struct t_FmPcdManipReassemStats {
 typedef struct t_FmPcdManipFragStats {
     union {
         t_FmPcdManipFragIpStats     ipFrag;     /**< Structure for IP fragmentation statistics */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipFragCapwapStats capwapFrag; /**< Structure for CAPWAP fragmentation statistics */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } t_FmPcdManipFragStats;
 
@@ -2938,7 +3156,7 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode);
                 When configuring nextEngine = e_FM_PCD_CC, note that
                 p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
                 from the currently changed table.
- 
+
 *//***************************************************************************/
 t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                  h_CcNode,
                                               t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
@@ -2999,7 +3217,7 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
                 When configuring nextEngine = e_FM_PCD_CC, note that
                 p_FmPcdCcNextEngineParams->ccParams.h_CcNode must be different
                 from the currently changed table.
- 
+
 *//***************************************************************************/
 t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle                  h_CcNode,
                                           uint16_t                  keyIndex,
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
index c342873..fda908a 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
@@ -45,6 +45,7 @@
 #include "fm_ext.h"
 #include "net_ext.h"
 
+
 /**************************************************************************//**
 
  @Group         FM_grp Frame Manager API
@@ -100,8 +101,8 @@ typedef enum e_FmPortPcdSupport {
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
-#ifdef FM_CAPWAP_SUPPORT
     , e_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
+#ifdef FM_CAPWAP_SUPPORT
     , e_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
     , e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
 #endif /* FM_CAPWAP_SUPPORT */
@@ -434,6 +435,7 @@ typedef struct t_FmPortPerformanceCnt {
     uint32_t    fifoCompVal;            /**< Fifo compare value (in bytes) */
 } t_FmPortPerformanceCnt;
 
+
 /**************************************************************************//**
  @Description   A structure for defining the sizes of the Deep Sleep
                 the Auto Response tables
@@ -448,7 +450,7 @@ typedef struct t_FmPortDsarTablesSizes
     uint16_t   maxNumOfSnmpIPV6Entries;
     uint16_t   maxNumOfSnmpOidEntries;
     uint16_t   maxNumOfSnmpOidChar; /* total amount of character needed for the snmp table */
-    
+
     uint16_t   maxNumOfIpProtFiltering;
     uint16_t   maxNumOfTcpPortFiltering;
     uint16_t   maxNumOfUdpPortFiltering;
@@ -1361,9 +1363,9 @@ typedef struct t_FmPortDsarNdpInfo
     t_FmPortDsarNdpEntry  *p_AutoResTableTmp;      /* This list refer to temp IP addresses.
                                                              Note that all temp IP adresses must be from the same multicast group.
                                                              This will be checked and if not operation will fail. */
-    
+
     bool                  enableConflictDetection; /* when TRUE Conflict Detection will be checked and wake the host if needed */
-    
+
 } t_FmPortDsarNdpInfo;
 
 /**************************************************************************//**
@@ -1386,7 +1388,7 @@ typedef struct t_FmPortDsarEchoIpv6Info
 
 /**************************************************************************//**
 @Description    Deep Sleep Auto Response SNMP OIDs table entry
-                 
+
 *//***************************************************************************/
 typedef struct {
 	uint16_t     oidSize;
@@ -1573,7 +1575,7 @@ typedef struct t_FmPortDsarStats
  @Description   Return statistics for Deep Sleep Auto Response
 
  @Param[in]     h_FmPortRx - FM PORT module descriptor
- @Param[out]	stats - structure containing the statistics counters
+ @Param[out]    stats - structure containing the statistics counters
 
  @Return        E_OK on success; Error code otherwise.
 *//***************************************************************************/
@@ -2229,7 +2231,10 @@ typedef struct t_FmPortPcdParams {
                                                      or if any flow uses a KG scheme were policer
                                                      profile is not generated
                                                      ('bypassPlcrProfileGeneration selected'). */
-    t_Handle                h_IpReassemblyManip;/**< IP Reassembly manipulation */
+    t_Handle                h_IpReassemblyManip;    /**< IP Reassembly manipulation */
+#if (DPAA_VERSION >= 11)
+    t_Handle                h_CapwapReassemblyManip;/**< CAPWAP Reassembly manipulation */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmPortPcdParams;
 
 /**************************************************************************//**
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
index 346132b..97a333e 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
@@ -232,7 +232,7 @@ typedef enum
 #define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
 #define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
 #define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
-#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000240          /**< Number of bytes saved for patches */
+#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000440          /**< Number of bytes saved for patches */
 #define FM_PCD_SW_PRS_SIZE              0x00000800          /**< Total size of SW parser area */
 
 /* RTC defines */
diff --git a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
index 45402e8..daa3345 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -451,6 +451,14 @@ typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options.
 #define IOC_IPV6_FRAG_1                 0x00000004   /**< IPV6 reassembly option.
                                                           IPV6 Reassembly manipulation requires network
                                                           environment with IPV6 header and IPV6_FRAG_1 option  */
+#if (DPAA_VERSION >= 11)
+typedef ioc_protocol_opt_t   ioc_capwap_protocol_opt_t;      /**< CAPWAP protocol options. */
+#define CAPWAP_FRAG_1               0x00000008  /**< CAPWAP reassembly option.
+                                                     CAPWAP Reassembly manipulation requires network
+                                                     environment with CAPWAP header and CAPWAP_FRAG_1 option;
+                                                     in case where fragment found, the fragment-extension offset
+                                                     may be found at 'shim2' (in parser-result). */
+#endif /* (DPAA_VERSION >= 11) */
 
 /* @} */
 
@@ -749,11 +757,42 @@ typedef enum ioc_fm_pcd_manip_hdr_insrt_specific_l2 {
     e_IOC_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
 } ioc_fm_pcd_manip_hdr_insrt_specific_l2;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS mapping mode
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE'
+                User should instruct the port to read the parser-result
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_qos_mapping_mode {
+    e_IOC_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE = 0, /**< No mapping, QoS field will not be changed */
+    e_IOC_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS, /**< QoS field will be overwritten by the last byte in the parser-result. */
+} ioc_fm_pcd_manip_hdr_qos_mapping_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS source
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_SRC_NONE'
+                User should left room for the parser-result on input/output buffer
+                and instruct the port to read/write the parser-result to the buffer (RPD should be set)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_qos_src {
+    e_IOC_FM_PCD_MANIP_HDR_QOS_SRC_NONE = 0, /**< TODO */
+    e_IOC_FM_PCD_MANIP_HDR_QOS_SRC_USER_DEFINED, /**< QoS will be taken from the last byte in the parser-result. */
+} ioc_fm_pcd_manip_hdr_qos_src;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of header insertion
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_manip_hdr_insrt_by_hdr_type {
-    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2         /**< Specific L2 fields insertion */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2,         /**< Specific L2 fields insertion */
+#if (DPAA_VERSION >= 11)
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_IP,                 /**< IP insertion */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_UDP,                /**< UDP insertion */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE,             /**< UDP lite insertion */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP                 /**< CAPWAP insertion */
+#endif /* (DPAA_VERSION >= 11) */
 } ioc_fm_pcd_manip_hdr_insrt_by_hdr_type;
 
 /**************************************************************************//**
@@ -775,10 +814,13 @@ typedef enum ioc_fm_pcd_manip_hdr_custom_ip_replace {
  @Description   Enumeration type for selecting type of header removal
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_manip_hdr_rmv_by_hdr_type {
-    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0       /**< Specific L2 fields removal */
-#ifdef FM_CAPWAP_SUPPORT
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0,       /**< Specific L2 fields removal */
+#if (DPAA_VERSION >= 11)
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP,                  /**< CAPWAP removal */
+#endif /* (DPAA_VERSION >= 11) */
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
     e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
 } ioc_fm_pcd_manip_hdr_rmv_by_hdr_type;
 
 /**************************************************************************//**
@@ -853,7 +895,10 @@ typedef enum ioc_fm_pcd_manip_dont_frag_action {
  @Description   Enumeration type for selecting type of special offload manipulation
 *//***************************************************************************/
 typedef enum ioc_fm_pcd_manip_special_offload_type {
-    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC    /**< IPSec offload manipulation */
+    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC,    /**< IPSec offload manipulation */
+#if (DPAA_VERSION >= 11)
+    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP    /**< CAPWAP offload manipulation */
+#endif /* (DPAA_VERSION >= 11) */
 } ioc_fm_pcd_manip_special_offload_type;
 
 /**************************************************************************//**
@@ -866,6 +911,9 @@ typedef union ioc_fm_pcd_hdr_protocol_opt_u {
     ioc_mpls_protocol_opt_t   mpls_opt;    /**< MPLS options */
     ioc_ipv4_protocol_opt_t   ipv4_opt;    /**< IPv4 options */
     ioc_ipv6_protocol_opt_t   ipv6_opt;    /**< IPv6 options */
+#if (DPAA_VERSION >= 11)
+    ioc_capwap_protocol_opt_t capwap_opt;  /**< CAPWAP options */
+#endif /* (DPAA_VERSION >= 11) */
 } ioc_fm_pcd_hdr_protocol_opt_u;
 
 /**************************************************************************//**
@@ -1638,7 +1686,6 @@ typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
     uint8_t    *p_key;          /**< Pointer to the key to remove */
 } ioc_fm_pcd_hash_table_remove_key_params_t;
 
-#ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
  @Description   Parameters for selecting a location for requested manipulation
 *//***************************************************************************/
@@ -1648,7 +1695,6 @@ typedef struct ioc_fm_manip_hdr_info_t {
     bool                                by_field;       /**< TRUE if the location of manipulation is according to some field in the specific header*/
     ioc_fm_pcd_fields_u                 full_field;     /**< Relevant only when by_field = TRUE: Extract field */
 } ioc_fm_manip_hdr_info_t;
-#endif /* FM_CAPWAP_SUPPORT */
 
 /**************************************************************************//**
  @Description   Parameters for defining header removal by header type
@@ -1656,13 +1702,16 @@ typedef struct ioc_fm_manip_hdr_info_t {
 typedef struct ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t {
     ioc_fm_pcd_manip_hdr_rmv_by_hdr_type        type;  /**< Selection of header removal location */
     union {
-#ifdef FM_CAPWAP_SUPPORT
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
         struct {
             bool                                include;/**< If FALSE, remove until the specified header (not including the header);
                                                              If TRUE, remove also the specified header. */
             ioc_fm_manip_hdr_info_t             hdr_info;
         } from_start_by_hdr;                           /**< Relevant when type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
 #endif /* FM_CAPWAP_SUPPORT */
+#if (DPAA_VERSION >= 11)
+        ioc_fm_manip_hdr_info_t                hdr_info;        /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* (DPAA_VERSION >= 11) */
         ioc_fm_pcd_manip_hdr_rmv_specific_l2    specific_l2;/**< Relevant when type = e_IOC_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
                                                                  Defines which L2 headers to remove. */
     } u;
@@ -1753,6 +1802,83 @@ typedef struct ioc_fm_pcd_manip_special_offload_ipsec_params_t {
                                                  corresponding SA. */
 } ioc_fm_pcd_manip_special_offload_ipsec_params_t;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP fragmentation manipulation
+
+ Restrictions:
+     - Maximum number of fragments per frame is 16.
+     - Transmit confirmation is not supported.
+     - Fragmentation nodes must be set as the last PCD action (i.e. the
+       corresponding CC node key must have next engine set to e_FM_PCD_DONE).
+     - Only BMan buffers shall be used for frames to be fragmented.
+     - NOTE: The following comment is relevant only for FMAN v3 devices: IPF
+       does not support VSP. Therefore, on the same port where we have IPF we
+       cannot support VSP.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_capwap_params_t {
+    uint16_t                    size_for_fragmentation;   /**< If length of the frame is greater than this value,
+                                                             CAPWAP fragmentation will be executed.*/
+    bool                        sg_bpid_en;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                             received frame's buffer. */
+    uint8_t                     sg_bpid;                 /**< Scatter/Gather buffer pool id;
+                                                             This parameters is relevant when 'sgBpidEn=TRUE';
+                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                             of this pool need to be allocated in the same memory area as the received buffers.
+                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                             mutual to all these sources. */
+    bool                        compress_mode_en;         /**< CAPWAP Header Options Compress Enable mode;
+                                                             When this mode is enabled then only the first fragment include the CAPWAP header options
+                                                             field (if user provides it in the input frame) and all other fragments exclude the CAPWAP
+                                                             options field (CAPWAP header is updated accordingly).*/
+} ioc_fm_pcd_manip_frag_capwap_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP reassembly manipulation.
+
+ Restrictions:
+    - Application must define one scheme to catch the reassembled frames.
+    - Maximum number of fragments per frame is 16.
+
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_capwap_params_t {
+    uint8_t                         relative_scheme_id;    /**< Partition relative scheme id;
+                                                                 NOTE: this id must be smaller than the user schemes id to ensure that the reassembly scheme will be first match;
+                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
+    uint8_t                         data_mem_id;              /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        data_liodn_offset;        /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        max_reassembled_frame_length;/**< The maximum CAPWAP reassembled frame length in bytes;
+                                                                   If maxReassembledFrameLength == 0, any successful reassembled frame length is
+                                                                   considered as a valid length;
+                                                                   if maxReassembledFrameLength > 0, a successful reassembled frame which its length
+                                                                   exceeds this value is considered as an error frame (FD status[CRE] bit is set). */
+    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry;
+                                                            /**< Number of frames per hash entry needed for reassembly process */
+    uint16_t                        max_num_frames_in_process;  /**< Number of frames which can be processed by reassembly in the same time;
+                                                                 Must be power of 2;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
+    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqid_for_time_out_frames;   /**< FQID in which time out frames will enqueue during Time Out Process;
+                                                                 Recommended value for this field is 0; in this way timed-out frames will be discarded */
+    uint32_t                        timeout_threshold_for_reassm_process;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} ioc_fm_pcd_manip_reassem_capwap_params_t;
+
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_capwap_params_t {
+    bool                    dtls;   /**< TRUE if continue to SEC DTLS encryption */
+    ioc_fm_pcd_manip_hdr_qos_src   qos_src; /**< TODO */
+} ioc_fm_pcd_manip_special_offload_capwap_params_t;
+
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Parameters for defining special offload manipulation
 *//***************************************************************************/
@@ -1762,6 +1888,11 @@ typedef struct ioc_fm_pcd_manip_special_offload_params_t {
     {
         ioc_fm_pcd_manip_special_offload_ipsec_params_t ipsec;      /**< Parameters for IPSec; Relevant when
                                                                          type = e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
+
+#if (DPAA_VERSION >= 11)
+        ioc_fm_pcd_manip_special_offload_capwap_params_t  capwap;     /**< Parameters for CAPWAP; Relevant when
+                                                                type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_fm_pcd_manip_special_offload_params_t;
 
@@ -1775,6 +1906,14 @@ typedef struct ioc_fm_pcd_manip_hdr_rmv_generic_params_t {
 } ioc_fm_pcd_manip_hdr_rmv_generic_params_t;
 
 /**************************************************************************//**
+ @Description   Parameters for defining insertion manipulation
+*//***************************************************************************/
+typedef struct fm_pcd_manip_hdr_insrt_t {
+    uint8_t size;           /**< size of inserted section */
+    uint8_t *p_data;        /**< data to be inserted */
+} fm_pcd_manip_hdr_insrt_t;
+
+/**************************************************************************//**
  @Description   Parameters for defining generic insertion manipulation
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_hdr_insrt_generic_params_t {
@@ -1909,6 +2048,20 @@ typedef struct ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
     uint8_t                                *p_data;         /**< data to be inserted */
 } ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining IP insertion manipulation
+*//***************************************************************************/
+typedef struct fm_pcd_manip_hdr_insrt_ip_params_t {
+    bool    calc_l4_checksum; /**< Calculate L4 checksum. */
+    ioc_fm_pcd_manip_hdr_qos_mapping_mode   mapping_mode; /**< TODO */
+    uint8_t last_pid_offset;     /**< the offset of the last Protocol within
+                                 the inserted header */
+    uint16_t  id;           /**< 16 bit New IP ID */
+    fm_pcd_manip_hdr_insrt_t insrt; /**< size and data to be inserted. */
+} fm_pcd_manip_hdr_insrt_ip_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Parameters for defining header insertion manipulation by header type
 *//***************************************************************************/
@@ -1918,6 +2071,12 @@ typedef struct ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
        ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t  specific_l2_params;
                                                             /**< Used when type = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
                                                                  Selects which L2 headers to remove */
+#if (DPAA_VERSION >= 11)
+        fm_pcd_manip_hdr_insrt_ip_params_t          ip_params;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
+        fm_pcd_manip_hdr_insrt_t                    insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE, or
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t;
 
@@ -1979,6 +2138,10 @@ typedef struct ioc_fm_pcd_manip_hdr_params_t {
 typedef struct ioc_fm_pcd_manip_frag_params_t {
     ioc_net_header_type                     hdr;            /**< Header selection */
     union {
+#if (DPAA_VERSION >= 11)
+        ioc_fm_pcd_manip_frag_capwap_params_t    capwap_frag;   /**< Parameters for defining CAPWAP fragmentation,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
         ioc_fm_pcd_manip_frag_ip_params_t   ip_frag;        /**< Parameters for defining IP fragmentation,
                                                                  relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
     } u;
@@ -1990,6 +2153,10 @@ typedef struct ioc_fm_pcd_manip_frag_params_t {
 typedef struct ioc_fm_pcd_manip_reassem_params_t {
     ioc_net_header_type                         hdr;        /**< Header selection */
     union {
+#if (DPAA_VERSION >= 11)
+        ioc_fm_pcd_manip_reassem_capwap_params_t capwap_reassem;  /**< Parameters for defining CAPWAP reassembly,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
         ioc_fm_pcd_manip_reassem_ip_params_t    ip_reassem; /**< Parameters for defining IP reassembly,
                                                                  relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
     } u;
@@ -2058,12 +2225,55 @@ typedef struct ioc_fm_pcd_manip_frag_ip_stats_t {
     uint32_t    generated_fragments;     /**< Number of fragments that were generated */
 } ioc_fm_pcd_manip_frag_ip_stats_t;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP reassembly statistics
+*//***************************************************************************/
+typedef struct fm_pcd_manip_reassem_capwap_stats_t {
+    uint32_t    timeout;                    /**< Counts the number of timeout occurrences */
+    uint32_t    rfd_pool_busy;                /**< Counts the number of failed attempts to allocate
+                                                 a Reassembly Frame Descriptor */
+    uint32_t    internal_buffer_busy;         /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t    external_buffer_busy;         /**< Counts the number of times external buffer busy occurred */
+    uint32_t    sg_fragments;                /**< Counts the number of Scatter/Gather fragments */
+    uint32_t    dma_semaphore_depletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    uint32_t    successfully_reassembled;    /**< Counts the number of successfully reassembled frames */
+    uint32_t    valid_fragments;             /**< Counts the total number of valid fragments that
+                                                 have been processed for all frames */
+    uint32_t    processed_fragments;         /**< Counts the number of processed fragments
+                                                 (valid and error fragments) for all frames */
+    uint32_t    malformed_fragments;         /**< Counts the number of malformed fragments processed for all frames */
+    uint32_t    autoLearn_busy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                 to access an Reassembly Automatic Learning Hash set */
+    uint32_t    discarded_fragments;         /**< Counts the number of fragments discarded by the reassembly process */
+    uint32_t    more_than16fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                 exceeds 16 */
+    uint32_t    exceed_max_reassembly_frame_len;/**< ounts the number of times that a successful reassembled frame
+                                                 length exceeds MaxReassembledFrameLength value */
+} fm_pcd_manip_reassem_capwap_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP fragmentation statistics
+*//***************************************************************************/
+typedef struct fm_pcd_manip_frag_capwap_stats_t {
+    uint32_t    total_frames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmented_frames;       /**< Number of frames that were fragmented */
+    uint32_t    generated_fragments;     /**< Number of fragments that were generated */
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    uint8_t     sg_allocation_failure;    /**< Number of allocation failure of s/g buffers */
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+} fm_pcd_manip_frag_capwap_stats_t;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Structure for retrieving reassembly statistics
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_reassem_stats_t {
     union {
         ioc_fm_pcd_manip_reassem_ip_stats_t  ip_reassem;  /**< Structure for IP reassembly statistics */
+#if (DPAA_VERSION >= 11)
+        fm_pcd_manip_reassem_capwap_stats_t  capwap_reassem;  /**< Structure for CAPWAP reassembly statistics */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_fm_pcd_manip_reassem_stats_t;
 
@@ -2073,6 +2283,9 @@ typedef struct ioc_fm_pcd_manip_reassem_stats_t {
 typedef struct ioc_fm_pcd_manip_frag_stats_t {
     union {
         ioc_fm_pcd_manip_frag_ip_stats_t     ip_frag;     /**< Structure for IP fragmentation statistics */
+#if (DPAA_VERSION >= 11)
+        fm_pcd_manip_frag_capwap_stats_t capwap_frag; /**< Structure for CAPWAP fragmentation statistics */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_fm_pcd_manip_frag_stats_t;
 
diff --git a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
index 8488845..dc7cc32 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -500,9 +500,11 @@ typedef struct ioc_fm_port_pcd_params_t {
     ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
     ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
     void                            *p_ip_reassembly_manip;/**< IP Reassembly manipulation */
+#if (DPAA_VERSION >= 11)
+    void                            *p_capwap_reassembly_manip;/**< CAPWAP Reassembly manipulation */
+#endif /* (DPAA_VERSION >= 11) */
 } ioc_fm_port_pcd_params_t;
 
-
 /**************************************************************************//**
  @Description   A structure for defining the Parser starting point
                 (Must match struct t_FmPcdPrsStart defined in fm_port_ext.h)
-- 
1.7.5.4

