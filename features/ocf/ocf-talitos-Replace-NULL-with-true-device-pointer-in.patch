From c6b7ee2e67f6b2407e7e738543b089c518cbf315 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Mon, 3 Dec 2012 15:20:30 +0800
Subject: [PATCH 4/5] ocf/talitos: Replace NULL with true device pointer in dma_map_single

After commit 46bab4e4 "powerpc: Use asm-generic/dma-mapping-common.h",
powerpc no longer allows passing NULL to the dev parameter of the DMA API.
The NULL parameter in dma_map_single() of talitos source code could
lead to kernel Oops when run benchmark test:
  Unable to handle kernel paging request for data at address 0x0000000c
  Faulting instruction address: 0xf1072900
  Oops: Kernel access of bad area, sig: 11 [#2]
  NIP [f1072900] talitos_process+0x498/0xdfc [talitos]
  LR [f107261c] talitos_process+0x1b4/0xdfc [talitos]
  Call Trace:
  [eeed7c20] [f107261c] talitos_process+0x1b4/0xdfc [talitos] (unreliable)
  [eeed7c90] [f105b138] crypto_invoke.isra.1+0x78/0x198 [ocf]
  [eeed7cc0] [f105bba8] crypto_dispatch+0x160/0x308 [ocf]
  [eeed7cf0] [f106ccc0] cryptodev_ioctl.isra.3+0x182c/0x2048 [cryptodev]
  [eeed7e80] [f106d4f8] cryptodev_unlocked_ioctl+0x1c/0x40 [cryptodev]
  [eeed7e90] [c016246c] do_vfs_ioctl+0xac/0x778
  [eeed7f00] [c0162bd8] sys_ioctl+0xa0/0x134
  [eeed7f40] [c0010690] ret_from_syscall+0x0/0x3c

Fix this problem by replacing the NULL parameter with true device pointer
in dma_map_single().

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 crypto/ocf/talitos/talitos.c |   36 ++++++++++++++++++++----------------
 1 files changed, 20 insertions(+), 16 deletions(-)

diff --git a/crypto/ocf/talitos/talitos.c b/crypto/ocf/talitos/talitos.c
index 7cdc89a..a0d4fbe 100644
--- a/crypto/ocf/talitos/talitos.c
+++ b/crypto/ocf/talitos/talitos.c
@@ -142,13 +142,16 @@
 const char talitos_driver_name[] = "Talitos OCF";
 const char talitos_driver_version[] = "0.2";
 
+/* Make this variable globally so as to use it in talitos_process */
+struct device *device = NULL;
+
 static int talitos_newsession(device_t dev, u_int32_t *sidp,
 								struct cryptoini *cri);
 static int talitos_freesession(device_t dev, u_int64_t tid);
 static int talitos_process(device_t dev, struct cryptop *crp, int hint);
 static void dump_talitos_status(struct talitos_softc *sc);
-static int talitos_submit(struct talitos_softc *sc, struct talitos_desc *td, 
-								int chsel);
+static int talitos_submit(struct device *dev, struct talitos_softc *sc,
+				struct talitos_desc *td, int chsel);
 static void talitos_doneprocessing(struct talitos_softc *sc);
 static void talitos_init_device(struct talitos_softc *sc);
 static void talitos_reset_device_master(struct talitos_softc *sc);
@@ -474,13 +477,14 @@ talitos_freesession(device_t dev, u_int64_t tid)
  */
 static int 
 talitos_submit(
+	struct device *dev,
 	struct talitos_softc *sc,
 	struct talitos_desc *td,
 	int chsel)
 {
 	u_int32_t v;
 
-	v = dma_map_single(NULL, td, sizeof(*td), DMA_TO_DEVICE);
+	v = dma_map_single(dev, td, sizeof(*td), DMA_TO_DEVICE);
 	talitos_write(sc->sc_base_addr + 
 		chsel*TALITOS_CH_OFFSET + TALITOS_CH_FF, 0);
 	talitos_write(sc->sc_base_addr + 
@@ -664,13 +668,13 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			err = EINVAL;
 			goto errout;
 		}
-		td->ptr[in_fifo].ptr = dma_map_single(NULL, skb->data, 
+		td->ptr[in_fifo].ptr = dma_map_single(device, skb->data, 
 			skb->len, DMA_TO_DEVICE);
 		td->ptr[in_fifo].len = skb->len;
-		td->ptr[out_fifo].ptr = dma_map_single(NULL, skb->data, 
+		td->ptr[out_fifo].ptr = dma_map_single(device, skb->data, 
 			skb->len, DMA_TO_DEVICE);
 		td->ptr[out_fifo].len = skb->len;
-		td->ptr[hmac_data].ptr = dma_map_single(NULL, skb->data,
+		td->ptr[hmac_data].ptr = dma_map_single(device, skb->data,
 			skb->len, DMA_TO_DEVICE);
 	} else if (crp->crp_flags & CRYPTO_F_IOV) {
 		/* using IOV buffers */
@@ -681,20 +685,20 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			err = EINVAL;
 			goto errout;
 		}
-		td->ptr[in_fifo].ptr = dma_map_single(NULL,
+		td->ptr[in_fifo].ptr = dma_map_single(device,
 			uiop->uio_iov->iov_base, crp->crp_ilen, DMA_TO_DEVICE);
 		td->ptr[in_fifo].len = crp->crp_ilen;
 		/* crp_olen is never set; always use crp_ilen */
-		td->ptr[out_fifo].ptr = dma_map_single(NULL,
+		td->ptr[out_fifo].ptr = dma_map_single(device,
 			uiop->uio_iov->iov_base,
 			crp->crp_ilen, DMA_TO_DEVICE);
 		td->ptr[out_fifo].len = crp->crp_ilen;
 	} else {
 		/* using contig buffers */
-		td->ptr[in_fifo].ptr = dma_map_single(NULL,
+		td->ptr[in_fifo].ptr = dma_map_single(device,
 			crp->crp_buf, crp->crp_ilen, DMA_TO_DEVICE);
 		td->ptr[in_fifo].len = crp->crp_ilen;
-		td->ptr[out_fifo].ptr = dma_map_single(NULL,
+		td->ptr[out_fifo].ptr = dma_map_single(device,
 			crp->crp_buf, crp->crp_ilen, DMA_TO_DEVICE);
 		td->ptr[out_fifo].len = crp->crp_ilen;
 	}
@@ -759,7 +763,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 				    enccrd->crd_inject, ivsize, iv);
 			}
 		}
-		td->ptr[cipher_iv].ptr = dma_map_single(NULL, iv, ivsize, 
+		td->ptr[cipher_iv].ptr = dma_map_single(device, iv, ivsize, 
 			DMA_TO_DEVICE);
 		td->ptr[cipher_iv].len = ivsize;
 		/*
@@ -803,7 +807,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			 * crypt data is the difference in the skips.
 			 */
 			/* ipsec only for now */
-			td->ptr[hmac_key].ptr = dma_map_single(NULL, 
+			td->ptr[hmac_key].ptr = dma_map_single(device, 
 				ses->ses_hmac, ses->ses_hmac_len, DMA_TO_DEVICE);
 			td->ptr[hmac_key].len = ses->ses_hmac_len;
 			td->ptr[in_fifo].ptr  += enccrd->crd_skip;
@@ -856,7 +860,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 
 		if ((maccrd->crd_alg == CRYPTO_MD5_HMAC) ||
 		   (maccrd->crd_alg == CRYPTO_SHA1_HMAC)) {
-			td->ptr[hmac_key].ptr = dma_map_single(NULL, 
+			td->ptr[hmac_key].ptr = dma_map_single(device, 
 				ses->ses_hmac, ses->ses_hmac_len, 
 				DMA_TO_DEVICE);
 			td->ptr[hmac_key].len = ses->ses_hmac_len;
@@ -864,13 +868,13 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 	} 
 	else {
 		/* using process key (session data has duplicate) */
-		td->ptr[cipher_key].ptr = dma_map_single(NULL, 
+		td->ptr[cipher_key].ptr = dma_map_single(device, 
 			enccrd->crd_key, (enccrd->crd_klen + 7) / 8, 
 			DMA_TO_DEVICE);
 		td->ptr[cipher_key].len = (enccrd->crd_klen + 7) / 8;
 	}
 	/* descriptor complete - GO! */
-	return talitos_submit(sc, td, chsel);
+	return talitos_submit(device, sc, td, chsel);
 
 errout:
 	if (err != ERESTART) {
@@ -1081,7 +1085,7 @@ static int talitos_probe(struct platform_device *pdev)
 	struct talitos_softc *sc = NULL;
 	struct resource *r;
 #ifdef CONFIG_PPC
-	struct device *device = &pdev->dev;
+	device = &pdev->dev;
 	struct device_node *np = pdev->dev.of_node;
 	const unsigned int *prop;
 	int err;
-- 
1.7.0

