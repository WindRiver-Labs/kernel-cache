From 80bdff3398647c6d81069750a2065b7bb0903489 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Tue, 19 Oct 2010 17:04:55 +0800
Subject: [PATCH] crypto: cryptosoft: Make it SMP safe

When running the following command on fsl_p1020:

$ openssl speed -evp des3 -engine cryptodev -elapsed -multi 10

The system will hang without any kernel calltrace:

engine "cryptodev" set.
You have chosen to measure elapsed time instead of user CPU time.
Forked child 0
+DT:des-ede3-cbc:3:16
Forked child 1
Forked child 2
Forked child 3
Forked child 4
+DT:des-ede3-cbc:3:16
Forked child 5
Forked child 6
Forked child 7
+DT:des-ede3-cbc:3:16
+DT:des-ede3-cbc:3:16
+DT:des-ede3-cbc:3:16
+DT:des-ede3-cbc:3:16
+DT:des-ede3-cbc:3:16
+DT:des-ede3-cbc:3:16
Forked child 8
Forked child 9
+DT:des-ede3-cbc:3:16
+DT:des-ede3-cbc:3:16
+R:5372:des-ede3-cbc:3.000000
[snip]
+DT:des-ede3-cbc:3:1024
+R:6367:des-ede3-cbc:3.000000
+DT:des-ede3-cbc:3:2048
+R:8078:des-ede3-cbc:3.000000

The above hang can be interrupted by CTRL+C. After reverting some of the
talito related patches, the following calltrace is generated:

Oops: Exception in kernel mode, sig: 11 [#1]
Unable to handle kernel paging request for data at address 0x00000008
Faulting instruction address: *0xc0299168*
PREEMPT SMP NR_CPUS=2 LTT NESTING LEVEL : 0
P1020 RDB
last sysfs file: /sys/kernel/uevent_seqnum
Modules linked in: x_tables ip_tables libcrc32c crc32c ipv6 sctp binfmt_misc [last unloaded: scsi_wait_scan]
NIP: de5e7374 LR: c029a18c CTR: de5e7374
REGS: ddeb9b80 TRAP: 0700   Not tainted  (2.6.34.6-WR4.0.0.0_standard)
MSR: 00029000 <EE,ME,CE>  CR: 44244a42  XER: 00000000
TASK = dee15400[1086] 'openssl' THREAD: ddeb8000 CPU: 1
GPR00: de5e7374 ddeb9c30 dee15400 00000000 deccd900 00000018 00000001 008fe000
GPR08: c071bed4 de5e7340 ddeb8000 00008000 24244a48 10081b9c c065d86c ddeb8040
GPR16: c057cb94 ddeb8000 00000000 c075b3ac c0658478 c075b3b0 c075b3b4 c0757960
GPR24: c057cb44 c0757c1c c074e440 c0760000 ddeb9d48 dddea814 00000005 ddeb9c30
NIP [de5e7374] 0xde5e7374
LR [c029a18c] swcr_newsession+0x368/0xa60
Call Trace:
[ddeb9c30] [c029a408] swcr_newsession+0x5e4/0xa60 (unreliable)
[ddeb9c90] [c0292da0] crypto_newsession+0x12c/0x36c
[ddeb9cd0] [c02974a4] cryptodev_ioctl+0xc68/0x20b8
[ddeb9e60] [c029892c] cryptodev_unlocked_ioctl+0x38/0x50
[ddeb9e70] [c0141dc8] vfs_ioctl+0x4c/0xf8
[ddeb9e90] [c0142064] do_vfs_ioctl+0x90/0x760
[ddeb9f00] [c01427c8] sys_ioctl+0x94/0x124
[ddeb9f40] [c00121ec] ret_from_syscall+0x0/0x4
Instruction dump:
XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
Oops: Kernel access of bad area, sig: 11 [#2]
PREEMPT SMP NR_CPUS=2 LTT NESTING LEVEL : 0
P1020 RDB
last sysfs file: /sys/kernel/uevent_seqnum
Modules linked in: x_tables ip_tables libcrc32c crc32c ipv6 sctp binfmt_misc [last unloaded: scsi_wait_scan]
NIP: c0299168 LR: c02990d8 CTR: c054f3e8
REGS: dcf23b10 TRAP: 0300   Tainted: G      D     (2.6.34.6-WR4.0.0.0_standard)
MSR: 00029000 <EE,ME,CE>  CR: 4d242a42  XER: 20000000
DEAR: 00000008, ESR: 00000000
TASK = ded14600[1090] 'openssl' THREAD: dcf22000 CPU: 0
GPR00: 00000007 dcf23bc0 ded14600 dfa5f300 c012c37c 00000010 00000001 008ee000
GPR08: c071bed4 00000000 00000004 00000002 2d242a48 10081b9c 1ff91d00 10079bb0
GPR16: bfbe5c88 bfbe5bc0 10079bb0 1005bc00 dddeaeb4 00000000 00000000 de5e7340
GPR24: dfa5f660 deb688d0 c0760000 dfa5f180 deb688c0 dfa5f640 00000400 dcf23bc0
NIP [c0299168] swcr_process_req+0x824/0xef0
LR [c02990d8] swcr_process_req+0x794/0xef0
Call Trace:
[dcf23bc0] [c02990d8] swcr_process_req+0x794/0xef0 (unreliable)
[dcf23c50] [c0299950] swcr_process+0x11c/0x254
[dcf23c70] [c029389c] crypto_invoke+0x78/0x19c
[dcf23ca0] [c0294424] crypto_dispatch+0x1a8/0x320
[dcf23cd0] [c0298174] cryptodev_ioctl+0x1938/0x20b8
[dcf23e60] [c029892c] cryptodev_unlocked_ioctl+0x38/0x50
[dcf23e70] [c0141dc8] vfs_ioctl+0x4c/0xf8
[dcf23e90] [c0142064] do_vfs_ioctl+0x90/0x760
[dcf23f00] [c01427c8] sys_ioctl+0x94/0x124
[dcf23f40] [c00121ec] ret_from_syscall+0x0/0x4
Instruction dump:
7ec6b378 807b002c 7f07c378 809b0030 4bffc405 813c01a0 93c90018 9309001c
93290024 93290020 807c01a0 81230010 <80090008> 7c0903a6 4e800421 7c7e1b78
BUG: using smp_processor_id() in preemptible [00000000] code: openssl/1090
caller is die+0xd8/0x23c
Call Trace:
[dcf23a30] [c00084d0] show_stack+0x68/0x1d8 (unreliable)
[dcf23a80] [c055205c] dump_stack+0x2c/0x44
[dcf23a90] [c02e0bc8] debug_smp_processor_id+0xd0/0xf8
[dcf23ab0] [c000f560] die+0xd8/0x23c
[dcf23ae0] [c0017d00] bad_page_fault+0x90/0xe0
[dcf23b00] [c00126b8] handle_page_fault+0x7c/0x80
[dcf23bc0] [c02990d8] swcr_process_req+0x794/0xef0
[dcf23c50] [c0299950] swcr_process+0x11c/0x254
[dcf23c70] [c029389c] crypto_invoke+0x78/0x19c
[dcf23ca0] [c0294424] crypto_dispatch+0x1a8/0x320
[dcf23cd0] [c0298174] cryptodev_ioctl+0x1938/0x20b8
[dcf23e60] [c029892c] cryptodev_unlocked_ioctl+0x38/0x50
[dcf23e70] [c0141dc8] vfs_ioctl+0x4c/0xf8
[dcf23e90] [c0142064] do_vfs_ioctl+0x90/0x760
[dcf23f00] [c01427c8] sys_ioctl+0x94/0x124
[dcf23f40] [c00121ec] ret_from_syscall+0x0/0x4
---[ end trace 697555e14015ddc4 ]---
BUG: using smp_processor_id() in preemptible [00000000] code: openssl/1086
caller is die+0xd8/0x23c
Call Trace:
[ddeb99a0] [c00084d0] show_stack+0x68/0x1d8 (unreliable)
[ddeb99f0] [c055205c] dump_stack+0x2c/0x44
[ddeb9a00] [c02e0bc8] debug_smp_processor_id+0xd0/0xf8
[ddeb9a20] [c000f560] die+0xd8/0x23c
[ddeb9a50] [c000f98c] _exception+0xd0/0x1f4
[ddeb9b50] [c054d988] program_check_exception+0x2d4/0x67c
[ddeb9b70] [c0012818] ret_from_except_full+0x0/0x4c
[ddeb9c30] [c029a408] swcr_newsession+0x5e4/0xa60
[ddeb9c90] [c0292da0] crypto_newsession+0x12c/0x36c
[ddeb9cd0] [c02974a4] cryptodev_ioctl+0xc68/0x20b8
[ddeb9e60] [c029892c] cryptodev_unlocked_ioctl+0x38/0x50
[ddeb9e70] [c0141dc8] vfs_ioctl+0x4c/0xf8
[ddeb9e90] [c0142064] do_vfs_ioctl+0x90/0x760
[ddeb9f00] [c01427c8] sys_ioctl+0x94/0x124
[ddeb9f40] [c00121ec] ret_from_syscall+0x0/0x4
---[ end trace 697555e14015ddc5 ]---
Unable to handle kernel paging request for data at address 0x0000002c
Faulting instruction address: 0xc0298eb4
Oops: Kernel access of bad area, sig: 11 [#3]
PREEMPT SMP NR_CPUS=2 LTT NESTING LEVEL : 0
P1020 RDB
last sysfs file: /sys/kernel/uevent_seqnum
Modules linked in: x_tables ip_tables libcrc32c crc32c ipv6 sctp binfmt_misc [last unloaded: scsi_wait_scan]
NIP: c0298eb4 LR: c02989d8 CTR: 00000010
REGS: ddf63b10 TRAP: 0300   Tainted: G      D     (2.6.34.6-WR4.0.0.0_standard)
MSR: 00029000 <EE,ME,CE>  CR: 4d242a42  XER: 20000000
DEAR: 0000002c, ESR: 00000000
TASK = dee16200[1083] 'openssl' THREAD: ddf62000 CPU: 0
GPR00: 00000010 ddf63bc0 dee16200 deb696d0 00000000 00000000 c075b2d8 00000400
GPR08: de717358 00000000 00000000 00000400 2d242a88 10081b9c 1ff91d00 10079bb0
GPR16: bfbe5c88 bfbe5bc0 10079bb0 1005bc00 de717334 00000000 de717360 00000001
GPR24: deccda80 deb696d0 c0760000 dfa5f940 deb696c0 dfa5f100 00000400 ddf63bc0
NIP [c0298eb4] swcr_process_req+0x570/0xef0
LR [c02989d8] swcr_process_req+0x94/0xef0
Call Trace:
[ddf63bc0] [c02989d8] swcr_process_req+0x94/0xef0 (unreliable)
[ddf63c50] [c0299950] swcr_process+0x11c/0x254
[ddf63c70] [c029389c] crypto_invoke+0x78/0x19c
[ddf63ca0] [c0294424] crypto_dispatch+0x1a8/0x320
[ddf63cd0] [c0298174] cryptodev_ioctl+0x1938/0x20b8
[ddf63e60] [c029892c] cryptodev_unlocked_ioctl+0x38/0x50
[ddf63e70] [c0141dc8] vfs_ioctl+0x4c/0xf8
[ddf63e90] [c0142064] do_vfs_ioctl+0x90/0x760
[ddf63f00] [c01427c8] sys_ioctl+0x94/0x124
[ddf63f40] [c00121ec] ret_from_syscall+0x0/0x4
Instruction dump:
81380008 3c60c066 3c80c066 8129002c 3884d424 7fc6f378 80e90014 38a002fd
3863d4f4 482b9381 4bfffc2c 81380008 <8169002c> 800b0010 5400073e 68000004
BUG: using smp_processor_id() in preemptible [00000000] code: openssl/1083
caller is die+0xd8/0x23c
Call Trace:
[ddf63a30] [c00084d0] show_stack+0x68/0x1d8 (unreliable)
[ddf63a80] [c055205c] dump_stack+0x2c/0x44
[ddf63a90] [c02e0bc8] debug_smp_processor_id+0xd0/0xf8
[ddf63ab0] [c000f560] die+0xd8/0x23c
[ddf63ae0] [c0017d00] bad_page_fault+0x90/0xe0
[ddf63b00] [c00126b8] handle_page_fault+0x7c/0x80
[ddf63bc0] [c02989d8] swcr_process_req+0x94/0xef0
[ddf63c50] [c0299950] swcr_process+0x11c/0x254
[ddf63c70] [c029389c] crypto_invoke+0x78/0x19c
[ddf63ca0] [c0294424] crypto_dispatch+0x1a8/0x320
[ddf63cd0] [c0298174] cryptodev_ioctl+0x1938/0x20b8
[ddf63e60] [c029892c] cryptodev_unlocked_ioctl+0x38/0x50
[ddf63e70] [c0141dc8] vfs_ioctl+0x4c/0xf8
[ddf63e90] [c0142064] do_vfs_ioctl+0x90/0x760
[ddf63f00] [c01427c8] sys_ioctl+0x94/0x124
[ddf63f40] [c00121ec] ret_from_syscall+0x0/0x4
---[ end trace 697555e14015ddc6 ]---

With the help of the calltrace, we found in swcr_process_req() and
swcr_newsession(), the memory alloc() and free() are not protected from
different cpus, so, add spin locks for swcr_process_req() and
swcr_newsession() to protect them.

With this patch, no hang and no calltrace left.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 crypto/ocf/cryptosoft.c |   37 +++++++++++++++++++++++++++++++++++++
 1 files changed, 37 insertions(+), 0 deletions(-)

diff --git a/crypto/ocf/cryptosoft.c b/crypto/ocf/cryptosoft.c
index e732b3b..8ecc6af 100644
--- a/crypto/ocf/cryptosoft.c
+++ b/crypto/ocf/cryptosoft.c
@@ -286,10 +286,15 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 	int error;
 	char *algo;
 	int mode;
+	static DEFINE_SPINLOCK(session_lock);
+	unsigned long flags;
+
+	spin_lock_irqsave(&session_lock, flags);
 
 	dprintk("%s()\n", __FUNCTION__);
 	if (sid == NULL || cri == NULL) {
 		dprintk("%s,%d - EINVAL\n", __FILE__, __LINE__);
+		spin_unlock_irqrestore(&session_lock, flags);
 		return EINVAL;
 	}
 
@@ -315,6 +320,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			else
 				swcr_sesnum /= 2;
 			dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
+			spin_unlock_irqrestore(&session_lock, flags);
 			return ENOBUFS;
 		}
 		memset(swd, 0, swcr_sesnum * sizeof(struct swcr_data *));
@@ -338,6 +344,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		if (*swd == NULL) {
 			swcr_freesession(NULL, i);
 			dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
+			spin_unlock_irqrestore(&session_lock, flags);
 			return ENOBUFS;
 		}
 		memset(*swd, 0, sizeof(struct swcr_data));
@@ -346,6 +353,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 				cri->cri_alg>=sizeof(crypto_details)/sizeof(crypto_details[0])){
 			printk("cryptosoft: Unknown algorithm 0x%x\n", cri->cri_alg);
 			swcr_freesession(NULL, i);
+			spin_unlock_irqrestore(&session_lock, flags);
 			return EINVAL;
 		}
 
@@ -353,6 +361,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		if (!algo || !*algo) {
 			printk("cryptosoft: Unsupported algorithm 0x%x\n", cri->cri_alg);
 			swcr_freesession(NULL, i);
+			spin_unlock_irqrestore(&session_lock, flags);
 			return EINVAL;
 		}
 
@@ -370,6 +379,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		}
 
 		if ((*swd)->sw_type & SW_TYPE_BLKCIPHER) {
+			spin_unlock_irqrestore(&session_lock, flags);
 			dprintk("%s crypto_alloc_*blkcipher(%s, 0x%x)\n", __FUNCTION__,
 					algo, mode);
 
@@ -384,10 +394,12 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 				(*swd)->sw_tfm = crypto_blkcipher_tfm(
 						crypto_alloc_blkcipher(algo, 0, CRYPTO_ALG_ASYNC));
 			}
+			spin_lock_irqsave(&session_lock, flags);
 			if (!(*swd)->sw_tfm) {
 				dprintk("cryptosoft: crypto_alloc_blkcipher failed(%s, 0x%x)\n",
 						algo,mode);
 				swcr_freesession(NULL, i);
+				spin_unlock_irqrestore(&session_lock, flags);
 				return EINVAL;
 			}
 
@@ -420,9 +432,11 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 				printk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n", error,
 						(*swd)->sw_tfm->crt_flags);
 				swcr_freesession(NULL, i);
+				spin_unlock_irqrestore(&session_lock, flags);
 				return error;
 			}
 		} else if ((*swd)->sw_type & (SW_TYPE_HMAC | SW_TYPE_HASH)) {
+			spin_unlock_irqrestore(&session_lock, flags);
 			dprintk("%s crypto_alloc_*hash(%s, 0x%x)\n", __FUNCTION__,
 					algo, mode);
 
@@ -438,10 +452,12 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 						crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC));
 			}
 
+			spin_lock_irqsave(&session_lock, flags);
 			if (!(*swd)->sw_tfm) {
 				dprintk("cryptosoft: crypto_alloc_hash failed(%s,0x%x)\n",
 						algo, mode);
 				swcr_freesession(NULL, i);
+				spin_unlock_irqrestore(&session_lock, flags);
 				return EINVAL;
 			}
 
@@ -451,6 +467,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			if ((*swd)->u.hmac.sw_key == NULL) {
 				swcr_freesession(NULL, i);
 				dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
+				spin_unlock_irqrestore(&session_lock, flags);
 				return ENOBUFS;
 			}
 			memcpy((*swd)->u.hmac.sw_key, cri->cri_key, (*swd)->u.hmac.sw_klen);
@@ -464,29 +481,35 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 						crypto_hash_cast((*swd)->sw_tfm));
 			}
 		} else if ((*swd)->sw_type & SW_TYPE_COMP) {
+			spin_unlock_irqrestore(&session_lock, flags);
 			(*swd)->sw_tfm = crypto_comp_tfm(
 					crypto_alloc_comp(algo, 0, CRYPTO_ALG_ASYNC));
+			spin_lock_irqsave(&session_lock, flags);
 			if (!(*swd)->sw_tfm) {
 				dprintk("cryptosoft: crypto_alloc_comp failed(%s,0x%x)\n",
 						algo, mode);
 				swcr_freesession(NULL, i);
+				spin_unlock_irqrestore(&session_lock, flags);
 				return EINVAL;
 			}
 			(*swd)->u.sw_comp_buf = kmalloc(CRYPTO_MAX_DATA_LEN, SLAB_ATOMIC);
 			if ((*swd)->u.sw_comp_buf == NULL) {
 				swcr_freesession(NULL, i);
 				dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
+				spin_unlock_irqrestore(&session_lock, flags);
 				return ENOBUFS;
 			}
 		} else {
 			printk("cryptosoft: Unhandled sw_type %d\n", (*swd)->sw_type);
 			swcr_freesession(NULL, i);
+			spin_unlock_irqrestore(&session_lock, flags);
 			return EINVAL;
 		}
 
 		cri = cri->cri_next;
 		swd = &((*swd)->sw_next);
 	}
+	spin_unlock_irqrestore(&session_lock, flags);
 	return 0;
 }
 
@@ -605,6 +628,8 @@ static void swcr_process_req(struct swcr_req *req)
 	struct sk_buff *skb = (struct sk_buff *) crp->crp_buf;
 	struct uio *uiop = (struct uio *) crp->crp_buf;
 	int sg_num, sg_len, skip;
+	static DEFINE_SPINLOCK(crypto_req_lock);
+	unsigned long flags;
 
 	dprintk("%s()\n", __FUNCTION__);
 
@@ -718,11 +743,14 @@ static void swcr_process_req(struct swcr_req *req)
 			goto done;
 		}
 
+		spin_lock_irqsave(&crypto_req_lock, flags);
+
 		req->crypto_req =
 				ahash_request_alloc(__crypto_ahash_cast(sw->sw_tfm),GFP_KERNEL);
 		if (!req->crypto_req) {
 			crp->crp_etype = ENOMEM;
 			dprintk("%s,%d: ENOMEM ahash_request_alloc", __FILE__, __LINE__);
+			spin_unlock_irqrestore(&crypto_req_lock, flags);
 			goto done;
 		}
 
@@ -739,14 +767,18 @@ static void swcr_process_req(struct swcr_req *req)
 		switch (ret) {
 		case -EINPROGRESS:
 		case -EBUSY:
+			spin_unlock_irqrestore(&crypto_req_lock, flags);
 			return;
 		default:
 		case 0:
 			dprintk("hash OP %s %d\n", ret ? "failed" : "success", ret);
 			crp->crp_etype = ret;
 			ahash_request_free(req->crypto_req);
+			spin_unlock_irqrestore(&crypto_req_lock, flags);
 			goto done;
 		}
+
+		spin_unlock_irqrestore(&crypto_req_lock, flags);
 		} break;
 #endif /* HAVE_AHASH */
 
@@ -772,12 +804,14 @@ static void swcr_process_req(struct swcr_req *req)
 			goto done;
 		}
 
+		spin_lock_irqsave(&crypto_req_lock, flags);
 		req->crypto_req = ablkcipher_request_alloc(
 				__crypto_ablkcipher_cast(sw->sw_tfm), GFP_KERNEL);
 		if (!req->crypto_req) {
 			crp->crp_etype = ENOMEM;
 			dprintk("%s,%d: ENOMEM ablkcipher_request_alloc",
 					__FILE__, __LINE__);
+			spin_unlock_irqrestore(&crypto_req_lock, flags);
 			goto done;
 		}
 
@@ -839,14 +873,17 @@ static void swcr_process_req(struct swcr_req *req)
 		switch (ret) {
 		case -EINPROGRESS:
 		case -EBUSY:
+			spin_unlock_irqrestore(&crypto_req_lock, flags);
 			return;
 		default:
 		case 0:
 			dprintk("crypto OP %s %d\n", ret ? "failed" : "success", ret);
 			crp->crp_etype = ret;
 			ablkcipher_request_free(req->crypto_req);
+			spin_unlock_irqrestore(&crypto_req_lock, flags);
 			goto done;
 		}
+		spin_unlock_irqrestore(&crypto_req_lock, flags);
 		} break;
 #endif /* HAVE_ABLKCIPHER */
 
-- 
1.6.5.2

