From 87c9fa754de695d368490054d4f2a6e44270f34e Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 18 Oct 2011 14:09:33 +0800
Subject: [PATCH] ocf/talitos: Workaround for SEC generate AE interrupt when run md5/sha1 benchmark program

The below benchmark program makes SEC triggers an Address
Error interrupt or kernel Oops:
# ./cryptotest -va md5 1 1024
crid = 3000000
alg = md5
session = 0x0
device = talitos0
count = 1, size = 1024
cleartext:
0000: 68 38 30 61 73 36 65 73 33 39 75 62 21 6e 35 34
0010: 6a 31 6f 37 36 74 65 35 61 33 74 38 73 34 62 35
0020: 6f 6e 74 32 68 6f 33 31 34 39 75 34 32 68 35 30
0030: 39 69 34 61 74 6e 75 68 36 33 62 39 38 61 61 6f
cryptotest: line 465:ioctl(CIOCCRYPT): Input/output error
# ./cryptotest -va md5 1 64
Unable to handle kernel paging request for data at address 0x00000004
Faulting instruction address: 0xc00d18fc
Oops: Kernel access of bad area, sig: 11 [#1]
PREEMPT 8 68 38 65 33 73SMP NR_CPUS=2  LTT NESTING LEVEL : 0
MPC8572 DS
NIP [c00d18fc] vma_prio_tree_remove+0x118/0x130
LR [c00de52c] __remove_shared_vm_struct+0x60/0x90
Call Trace:
[ef115de0] [c141c0b8] 0xc141c0b8 (unreliable)
[ef115e00] [c00de52c] __remove_shared_vm_struct+0x60/0x90
[ef115e10] [c00de59c] unlink_file_vma+0x40/0x5c
[ef115e30] [c00dbde8] free_pgtables+0x60/0xbc
[ef115e50] [c00de238] exit_mmap+0x124/0x1b4
[ef115e80] [c0044c1c] mmput+0x58/0x120
[ef115e90] [c0049948] exit_mm+0x148/0x168
[ef115ec0] [c004baac] do_exit+0x5d8/0x6b0
[ef115f10] [c004bbcc] do_group_exit+0x48/0xa8
[ef115f30] [c004bc40] sys_exit_group+0x14/0x28
[ef115f40] [c0010ef0] ret_from_syscall+0x0/0x4
---
 crypto/ocf/talitos/talitos.c |   18 ++++++++++++++++++
 1 files changed, 18 insertions(+), 0 deletions(-)

diff --git a/crypto/ocf/talitos/talitos.c b/crypto/ocf/talitos/talitos.c
index 0088382..4bf5928 100644
--- a/crypto/ocf/talitos/talitos.c
+++ b/crypto/ocf/talitos/talitos.c
@@ -137,6 +137,8 @@
 #include "talitos_dev.h"
 #include "talitos_soft.h"
 
+#define MDEU_UPSET_THRESHOLD 32
+
 #define read_random(p,l) get_random_bytes(p,l)
 
 const char talitos_driver_name[] = "Talitos OCF";
@@ -841,6 +843,14 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 		switch (maccrd->crd_alg) {
 			case	CRYPTO_MD5:	
 				td->hdr |= TALITOS_MODE0_MDEU_MD5;
+				/* 
+				 * MDEU is unhappy when the len of out_fifo is bigger
+				 * than 32 bytes, as the output of MD5 is 128 bits, we
+				 * restrict out_fifo len to 32 bytes so as to make MDEU
+				 * don't generate error interrupt.
+				 */ 
+				if (td->ptr[out_fifo].len > MDEU_UPSET_THRESHOLD)
+					td->ptr[out_fifo].len = MDEU_UPSET_THRESHOLD;
 				DPRINTF("MD5  ses %d ch %d len %d\n",
 					(u32)TALITOS_SESSION(crp->crp_sid), 
 					chsel, td->ptr[in_fifo].len);
@@ -850,6 +860,14 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 				break;
 			case	CRYPTO_SHA1:	
 				td->hdr |= TALITOS_MODE0_MDEU_SHA1;
+				/* 
+				 * MDEU is unhappy when the len of out_fifo is bigger
+				 * than 32 bytes, as the output of SHA1 is 160 bits, we
+				 * restrict out_fifo len to 32 bytes so as to make MDEU
+				 * don't generate error interrupt.
+				 */
+				if (td->ptr[out_fifo].len > MDEU_UPSET_THRESHOLD)
+					td->ptr[out_fifo].len = MDEU_UPSET_THRESHOLD;
 				DPRINTF("SHA1 ses %d ch %d len %d\n",
 					(u32)TALITOS_SESSION(crp->crp_sid), 
 					chsel, td->ptr[in_fifo].len);
-- 
1.7.0.4

