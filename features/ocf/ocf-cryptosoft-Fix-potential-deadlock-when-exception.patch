From 7ae56459decd7f5079d6cdba1d9802bca86be591 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Wed, 5 Dec 2012 17:47:32 +0800
Subject: [PATCH] ocf/cryptosoft: Fix potential deadlock when exceptions happen in swcr_newsession

commit "ocf: Make ocf session and cselist operation SMP safe" introduces
session_lock spinlock to make swcr_newsession/swcr_freesession functions
SMP safe, but the position of some spin_unlock_irqrestore() operation is
not correct in swcr_newsession() when the exceptional cases happen, such
as kmalloc() failed. Since swcr_freesession() use the same spinlock to
protect the critical section and spin_unlock_irqrestore() is called after
swcr_freesession() in swcr_newsession(), this would make the kernel deadlock
when the exception cases happen.

Fix this problem by placing the spin_unlock_irqrestore() before swcr_newsession()
in swcr_freesession().

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 crypto/ocf/cryptosoft.c |   20 ++++++++++----------
 1 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/crypto/ocf/cryptosoft.c b/crypto/ocf/cryptosoft.c
index b8f87cc..075e08c 100644
--- a/crypto/ocf/cryptosoft.c
+++ b/crypto/ocf/cryptosoft.c
@@ -400,9 +400,9 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		*swd = (struct swcr_data *) kmalloc(sizeof(struct swcr_data),
 				SLAB_ATOMIC);
 		if (*swd == NULL) {
+			spin_unlock_irqrestore(&session_lock, flags);
 			swcr_freesession(NULL, i);
 			dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
-			spin_unlock_irqrestore(&session_lock, flags);
 			return ENOBUFS;
 		}
 		memset(*swd, 0, sizeof(struct swcr_data));
@@ -410,16 +410,16 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		if (cri->cri_alg < 0 ||
 				cri->cri_alg>=sizeof(crypto_details)/sizeof(crypto_details[0])){
 			printk("cryptosoft: Unknown algorithm 0x%x\n", cri->cri_alg);
-			swcr_freesession(NULL, i);
 			spin_unlock_irqrestore(&session_lock, flags);
+			swcr_freesession(NULL, i);
 			return EINVAL;
 		}
 
 		algo = crypto_details[cri->cri_alg].alg_name;
 		if (!algo || !*algo) {
 			printk("cryptosoft: Unsupported algorithm 0x%x\n", cri->cri_alg);
-			swcr_freesession(NULL, i);
 			spin_unlock_irqrestore(&session_lock, flags);
+			swcr_freesession(NULL, i);
 			return EINVAL;
 		}
 
@@ -465,8 +465,8 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 						algo,mode);
 				err = IS_ERR((*swd)->sw_tfm) ? -(PTR_ERR((*swd)->sw_tfm)) : EINVAL;
 				(*swd)->sw_tfm = NULL; /* ensure NULL */
-				swcr_freesession(NULL, i);
 				spin_unlock_irqrestore(&session_lock, flags);
+				swcr_freesession(NULL, i);
 				return err;
 			}
 
@@ -498,8 +498,8 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			if (error) {
 				printk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n", error,
 						(*swd)->sw_tfm->crt_flags);
-				swcr_freesession(NULL, i);
 				spin_unlock_irqrestore(&session_lock, flags);
+				swcr_freesession(NULL, i);
 				return error;
 			}
 		} else if ((*swd)->sw_type & (SW_TYPE_HMAC | SW_TYPE_HASH)) {
@@ -526,8 +526,8 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			if (!(*swd)->sw_tfm) {
 				dprintk("cryptosoft: crypto_alloc_hash failed(%s,0x%x)\n",
 						algo, mode);
-				swcr_freesession(NULL, i);
 				spin_unlock_irqrestore(&session_lock, flags);
+				swcr_freesession(NULL, i);
 				return EINVAL;
 			}
 
@@ -535,9 +535,9 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			(*swd)->u.hmac.sw_key = (char *)kmalloc((*swd)->u.hmac.sw_klen,
 					SLAB_ATOMIC);
 			if ((*swd)->u.hmac.sw_key == NULL) {
+				spin_unlock_irqrestore(&session_lock, flags);
 				swcr_freesession(NULL, i);
 				dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
-				spin_unlock_irqrestore(&session_lock, flags);
 				return ENOBUFS;
 			}
 			memcpy((*swd)->u.hmac.sw_key, cri->cri_key, (*swd)->u.hmac.sw_klen);
@@ -558,21 +558,21 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			if (!(*swd)->sw_tfm) {
 				dprintk("cryptosoft: crypto_alloc_comp failed(%s,0x%x)\n",
 						algo, mode);
-				swcr_freesession(NULL, i);
 				spin_unlock_irqrestore(&session_lock, flags);
+				swcr_freesession(NULL, i);
 				return EINVAL;
 			}
 			(*swd)->u.sw_comp_buf = kmalloc(CRYPTO_MAX_DATA_LEN, SLAB_ATOMIC);
 			if ((*swd)->u.sw_comp_buf == NULL) {
+				spin_unlock_irqrestore(&session_lock, flags);
 				swcr_freesession(NULL, i);
 				dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
-				spin_unlock_irqrestore(&session_lock, flags);
 				return ENOBUFS;
 			}
 		} else {
 			printk("cryptosoft: Unhandled sw_type %d\n", (*swd)->sw_type);
-			swcr_freesession(NULL, i);
 			spin_unlock_irqrestore(&session_lock, flags);
+			swcr_freesession(NULL, i);
 			return EINVAL;
 		}
 
-- 
1.7.0

