From e2d5e9246fe649038081ada60d1d307e4aa43f7b Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Tue, 16 Feb 2016 10:47:05 +0200
Subject: [PATCH 518/752] fmd: add LS1043 support

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/freescale/sdk_fman/Kconfig    |  11 +-
 .../freescale/sdk_fman/Peripherals/FM/MAC/Makefile |   3 +
 .../Peripherals/FM/MACSEC/fm_macsec_master.c       |   4 +-
 .../freescale/sdk_fman/Peripherals/FM/Pcd/Makefile |   3 +
 .../freescale/sdk_fman/Peripherals/FM/Pcd/fm_cc.c  | 103 +--
 .../sdk_fman/Peripherals/FM/Pcd/fm_manip.c         |  61 +-
 .../sdk_fman/Peripherals/FM/Pcd/fm_manip.h         |   2 +
 .../freescale/sdk_fman/Peripherals/FM/Pcd/fm_prs.c |  10 +-
 .../freescale/sdk_fman/Peripherals/FM/fm.c         |   4 +
 .../net/ethernet/freescale/sdk_fman/etc/memcpy.c   |  19 +
 .../sdk_fman/inc/Peripherals/fm_pcd_ext.h          |   6 +-
 .../net/ethernet/freescale/sdk_fman/inc/core_ext.h |   8 +-
 .../freescale/sdk_fman/inc/cores/arm_ext.h         |  55 ++
 .../ethernet/freescale/sdk_fman/inc/error_ext.h    |   2 +-
 .../freescale/sdk_fman/inc/etc/memcpy_ext.h        |  34 +
 .../freescale/sdk_fman/inc/flib/common/general.h   |   3 +-
 .../inc/integrations/LS1043/dpaa_integration_ext.h | 291 +++++++
 .../sdk_fman/inc/integrations/LS1043/part_ext.h    |  64 ++
 .../inc/integrations/LS1043/part_integration_ext.h | 185 +++++
 .../ethernet/freescale/sdk_fman/inc/types_ext.h    |  42 -
 .../ethernet/freescale/sdk_fman/ls1043_dflags.h    |  56 ++
 .../net/ethernet/freescale/sdk_fman/ncsw_config.mk |   6 +
 .../freescale/sdk_fman/src/inc/types_linux.h       |   8 +
 .../freescale/sdk_fman/src/wrapper/lnxwrp_fm.c     |  70 +-
 .../sdk_fman/src/wrapper/lnxwrp_fm_port.c          | 161 +++-
 .../sdk_fman/src/wrapper/lnxwrp_ioctls_fm.c        |  19 +-
 .../sdk_fman/src/wrapper/lnxwrp_ioctls_fm_compat.c |   2 +
 .../ethernet/freescale/sdk_fman/src/xx/Makefile    |   9 +-
 .../freescale/sdk_fman/src/xx/xx_arm_linux.c       | 905 +++++++++++++++++++++
 .../ethernet/freescale/sdk_fman/src/xx/xx_linux.c  |  37 +-
 30 files changed, 1982 insertions(+), 201 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/sdk_fman/inc/cores/arm_ext.h
 create mode 100644 drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/dpaa_integration_ext.h
 create mode 100644 drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/part_ext.h
 create mode 100644 drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/part_integration_ext.h
 create mode 100644 drivers/net/ethernet/freescale/sdk_fman/ls1043_dflags.h
 create mode 100644 drivers/net/ethernet/freescale/sdk_fman/src/xx/xx_arm_linux.c

diff --git a/drivers/net/ethernet/freescale/sdk_fman/Kconfig b/drivers/net/ethernet/freescale/sdk_fman/Kconfig
index 914f9d2..81da9bf 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Kconfig
+++ b/drivers/net/ethernet/freescale/sdk_fman/Kconfig
@@ -2,7 +2,7 @@ menu "Frame Manager support"
 
 menuconfig FSL_SDK_FMAN
 	bool "Freescale Frame Manager (datapath) support - SDK driver"
-	depends on FSL_SOC && FSL_BMAN && FSL_QMAN
+	depends on (FSL_SOC || ARM64) && FSL_BMAN && FSL_QMAN
 	default y
 	---help---
 		If unsure, say Y.
@@ -21,6 +21,13 @@ choice
 	depends on FSL_SDK_FMAN
 	prompt "Processor Type"
 
+config FMAN_ARM
+	bool "LS1043"
+	depends on ARM64
+	---help---
+	  Choose "LS1043" for the ARM platforms:
+	  LS1043
+
 config FMAN_P3040_P4080_P5020
 	bool "P3040 P4080 5020"
 
@@ -100,7 +107,7 @@ config FSL_FM_RX_EXTRA_HEADROOM
 
 config FMAN_PFC
 	bool "FMan PFC support (EXPERIMENTAL)"
-	depends on ( FMAN_V3H || FMAN_V3L ) && FSL_SDK_FMAN
+	depends on ( FMAN_V3H || FMAN_V3L || FMAN_ARM) && FSL_SDK_FMAN
 	default n
 	---help---
 	  This option enables PFC support on FMan v3 ports.
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/MAC/Makefile b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/MAC/Makefile
index 823f6ad..f6b090da 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/MAC/Makefile
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/MAC/Makefile
@@ -22,4 +22,7 @@ endif
 ifeq ($(CONFIG_FMAN_V3L),y)
 fsl-ncsw-MAC-objs       +=  memac.o memac_mii_acc.o fman_memac_mii_acc.o
 endif
+ifeq ($(CONFIG_FMAN_ARM),y)
+fsl-ncsw-MAC-objs       +=  memac.o memac_mii_acc.o fman_memac_mii_acc.o
+endif
 
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/MACSEC/fm_macsec_master.c b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/MACSEC/fm_macsec_master.c
index 79260c8..623612a 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/MACSEC/fm_macsec_master.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/MACSEC/fm_macsec_master.c
@@ -715,7 +715,7 @@ t_Error FmMacsecCreateRxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, ma
     WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
     WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsanpn, DEFAULT_initNextPn);
     WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsalpn, lowestPn);
-    Mem2IOCpy32((void*)p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsak, key, sizeof(macsecSAKey_t));
+    MemCpy8((void*)p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsak, key, sizeof(macsecSAKey_t));
 
     tmpReg |= RX_SACFG_ACTIVE;
     tmpReg |= ((an << RX_SACFG_AN_SHIFT) & RX_SACFG_AN_MASK);
@@ -740,7 +740,7 @@ t_Error FmMacsecCreateTxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, ma
 
     WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
     WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsanpn, DEFAULT_initNextPn);
-    Mem2IOCpy32((void*)p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsak, key, sizeof(macsecSAKey_t));
+    MemCpy8((void*)p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsak, key, sizeof(macsecSAKey_t));
 
     tmpReg |= TX_SACFG_ACTIVE;
     WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsacs, tmpReg);
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/Makefile b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/Makefile
index 880c0e1..62fbd73 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/Makefile
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/Makefile
@@ -20,4 +20,7 @@ endif
 ifeq ($(CONFIG_FMAN_V3L),y)
 fsl-ncsw-Pcd-objs       += fm_replic.o
 endif
+ifeq ($(CONFIG_FMAN_ARM),y)
+fsl-ncsw-Pcd-objs	+= fm_replic.o
+endif
 
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_cc.c
index 51df898..b0e045b 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_cc.c
@@ -165,7 +165,7 @@ static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics ADs"));
             return NULL;
         }
-        IOMemSet32(p_StatsObj->h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+        MemSet8(p_StatsObj->h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
         p_StatsObj->h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(
                 h_FmMuram, p_CcNode->countersArraySize,
@@ -177,7 +177,7 @@ static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics counters"));
             return NULL;
         }
-        IOMemSet32(p_StatsObj->h_StatsCounters, 0, p_CcNode->countersArraySize);
+        MemSet8(p_StatsObj->h_StatsCounters, 0, p_CcNode->countersArraySize);
     }
 
     return p_StatsObj;
@@ -195,7 +195,7 @@ static void PutStatsObj(t_FmPcdCcNode *p_CcNode, t_FmPcdStatsObj *p_StatsObj)
     if (p_CcNode->maxNumOfKeys)
     {
         /* Nullify counters */
-        IOMemSet32(p_StatsObj->h_StatsCounters, 0, p_CcNode->countersArraySize);
+        MemSet8(p_StatsObj->h_StatsCounters, 0, p_CcNode->countersArraySize);
 
         EnqueueStatsObj(&p_CcNode->availableStatsLst, p_StatsObj);
     }
@@ -367,8 +367,8 @@ static void FillAdOfTypeContLookup(t_Handle h_Ad,
         tmpReg32 |= p_Node->parseCode;
         WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
 
-        Mem2IOCpy32((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask,
-                        CC_GLBL_MASK_SIZE);
+        MemCpy8((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask,
+                    CC_GLBL_MASK_SIZE);
     }
 }
 
@@ -396,7 +396,7 @@ static t_Error AllocAndFillAdForContLookupManip(t_Handle h_CcNode)
             RETURN_ERROR(MAJOR, E_NO_MEMORY,
                          ("MURAM allocation for CC action descriptor"));
 
-        IOMemSet32(p_CcNode->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+        MemSet8(p_CcNode->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
         FillAdOfTypeContLookup(p_CcNode->h_Ad, NULL, p_CcNode->h_FmPcd,
                                p_CcNode, NULL, NULL);
@@ -1005,11 +1005,11 @@ static t_Error DoDynamicChange(
 			else
 				keySize = p_CcNode->ccKeySizeAccExtraction;
 
-			IO2IOCpy32(p_AdditionalParams->p_KeysMatchTableOld,
+			MemCpy8(p_AdditionalParams->p_KeysMatchTableOld,
 					   p_AdditionalParams->p_KeysMatchTableNew,
 					   p_CcNode->maxNumOfKeys * keySize * sizeof(uint8_t));
 
-			IO2IOCpy32(
+			MemCpy8(
 					p_AdditionalParams->p_AdTableOld,
 					p_AdditionalParams->p_AdTableNew,
 					(uint32_t)((p_CcNode->maxNumOfKeys + 1)
@@ -1032,8 +1032,8 @@ static t_Error DoDynamicChange(
 			/* HC to copy from the new Ad (old updated structures) to current Ad (uses shadow structures) */
 			err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst,
 								  p_AdditionalParams, useShadowStructs);
-                        if (err)
-                            RETURN_ERROR(MAJOR, err, NO_MSG);
+			if (err)
+				RETURN_ERROR(MAJOR, err, NO_MSG);
 		}
     }
 
@@ -2515,12 +2515,12 @@ static t_Error BuildNewNodeCommonPart(
                          ("MURAM allocation for CC node key match table"));
         }
 
-        IOMemSet32(
+        MemSet8(
                 (uint8_t*)p_AdditionalInfo->p_AdTableNew,
                 0,
                 (uint32_t)((p_AdditionalInfo->numOfKeys + 1)
                         * FM_PCD_CC_AD_ENTRY_SIZE));
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0,
+        MemSet8((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0,
                    *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
     }
     else
@@ -2542,12 +2542,12 @@ static t_Error BuildNewNodeCommonPart(
         p_AdditionalInfo->p_AdTableNew =
                 PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, p_CcNode->keysMatchTableMaxSize);
 
-        IOMemSet32(
+        MemSet8(
                 (uint8_t*)p_AdditionalInfo->p_AdTableNew,
                 0,
                 (uint32_t)((p_CcNode->maxNumOfKeys + 1)
                         * FM_PCD_CC_AD_ENTRY_SIZE));
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0,
+        MemSet8((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0,
                    (*size) * sizeof(uint8_t) * (p_CcNode->maxNumOfKeys));
     }
 
@@ -2685,7 +2685,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
             p_KeysMatchTableNewTmp =
                     PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size*sizeof(uint8_t));
 
-            Mem2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key,
+            MemCpy8((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key,
                         p_CcNode->userSizeOfExtraction);
 
             /* Update mask for the received new key */
@@ -2693,7 +2693,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
             {
                 if (p_KeyParams->p_Mask)
                 {
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                    MemCpy8(PTR_MOVE(p_KeysMatchTableNewTmp,
                             p_CcNode->ccKeySizeAccExtraction),
                                 p_KeyParams->p_Mask,
                                 p_CcNode->userSizeOfExtraction);
@@ -2701,13 +2701,13 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
                 else
                     if (p_CcNode->ccKeySizeAccExtraction > 4)
                     {
-                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                        MemSet8(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
                                    0xff, p_CcNode->userSizeOfExtraction);
                     }
                     else
                     {
-                        Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                        MemCpy8(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
                                     p_CcNode->p_GlblMask,
                                     p_CcNode->userSizeOfExtraction);
@@ -2723,7 +2723,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
             /* Copy existing action descriptors to the newly allocated Ad table */
             p_AdTableOldTmp =
                     PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
-            IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,
+            MemCpy8(p_AdTableNewTmp, p_AdTableOldTmp,
                        FM_PCD_CC_AD_ENTRY_SIZE);
 
             /* Copy existing keys and their masks to the newly allocated keys match table */
@@ -2736,7 +2736,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
             {
                 if (prvLclMask)
                 {
-                    IO2IOCpy32(
+                    MemCpy8(
                             PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
                             PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
                             p_CcNode->ccKeySizeAccExtraction);
@@ -2749,13 +2749,13 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
 
                     if (p_CcNode->ccKeySizeAccExtraction > 4)
                     {
-                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                        MemSet8(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
                                    0xff, p_CcNode->userSizeOfExtraction);
                     }
                     else
                     {
-                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                        MemCpy8(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
                                    p_CcNode->p_GlblMask,
                                    p_CcNode->userSizeOfExtraction);
@@ -2763,7 +2763,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
                 }
             }
 
-            IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
+            MemCpy8(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
                        p_CcNode->ccKeySizeAccExtraction);
 
             i++;
@@ -2775,7 +2775,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
             PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
     p_AdTableOldTmp =
             PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i * FM_PCD_CC_AD_ENTRY_SIZE);
-    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+    MemCpy8(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     if (!LIST_IsEmpty(&p_CcNode->ccTreesLst))
     {
@@ -2888,13 +2888,13 @@ static t_Error BuildNewNodeRemoveKey(
                 PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
         p_AdTableOldTmp =
                 PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
-        IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+        MemCpy8(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
         p_KeysMatchTableOldTmp =
                 PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j * size * sizeof(uint8_t));
         p_KeysMatchTableNewTmp =
                 PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i * size * sizeof(uint8_t));
-        IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
+        MemCpy8(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
                    size * sizeof(uint8_t));
     }
 
@@ -2902,7 +2902,7 @@ static t_Error BuildNewNodeRemoveKey(
             PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
     p_AdTableOldTmp =
             PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
-    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+    MemCpy8(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
             == e_FM_PCD_CC)
@@ -2976,7 +2976,7 @@ static t_Error BuildNewNodeModifyKey(
         p_AdTableOldTmp =
                 PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
 
-        IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+        MemCpy8(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
         if (j == keyIndex)
         {
@@ -3019,22 +3019,22 @@ static t_Error BuildNewNodeModifyKey(
             p_KeysMatchTableNewTmp =
                     PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
 
-            Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key,
+            MemCpy8(p_KeysMatchTableNewTmp, p_Key,
                         p_CcNode->userSizeOfExtraction);
 
             if (p_CcNode->lclMask)
             {
                 if (p_Mask)
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                    MemCpy8(PTR_MOVE(p_KeysMatchTableNewTmp,
                             p_CcNode->ccKeySizeAccExtraction),
                                 p_Mask, p_CcNode->userSizeOfExtraction);
                 else
                     if (p_CcNode->ccKeySizeAccExtraction > 4)
-                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                        MemSet8(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
                                    0xff, p_CcNode->userSizeOfExtraction);
                     else
-                        Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                        MemCpy8(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
                                     p_CcNode->p_GlblMask,
                                     p_CcNode->userSizeOfExtraction);
@@ -3050,7 +3050,7 @@ static t_Error BuildNewNodeModifyKey(
             if (p_CcNode->lclMask)
             {
                 if (prvLclMask)
-                    IO2IOCpy32(
+                    MemCpy8(
                             PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
                             PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
                             p_CcNode->userSizeOfExtraction);
@@ -3061,17 +3061,17 @@ static t_Error BuildNewNodeModifyKey(
                                      i * (int)p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
 
                     if (p_CcNode->ccKeySizeAccExtraction > 4)
-                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                        MemSet8(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
                                    0xff, p_CcNode->userSizeOfExtraction);
                     else
-                        IO2IOCpy32(
+                        MemCpy8(
                                 PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
                                 p_CcNode->p_GlblMask,
                                 p_CcNode->userSizeOfExtraction);
                 }
             }
-            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
+            MemCpy8((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
                        p_CcNode->ccKeySizeAccExtraction);
         }
     }
@@ -3080,7 +3080,7 @@ static t_Error BuildNewNodeModifyKey(
             PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
     p_AdTableOldTmp = PTR_MOVE(p_CcNode->h_AdTable, i * FM_PCD_CC_AD_ENTRY_SIZE);
 
-    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+    MemCpy8(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     return E_OK;
 }
@@ -3203,7 +3203,7 @@ static t_Error BuildNewNodeModifyNextEngine(
     if (!p_Ad)
         RETURN_ERROR(MAJOR, E_NO_MEMORY,
                      ("MURAM allocation for CC node action descriptor"));
-    IOMemSet32((uint8_t *)p_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+    MemSet8((uint8_t *)p_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* If statistics were not enabled before, but requested now -  Allocate a statistics
      object that holds statistics AD and counters. */
@@ -3568,7 +3568,7 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(
         h_NewAd = GetNewAd(p_CcNode, FALSE);
         if (!h_NewAd)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-        IOMemSet32(h_NewAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+        MemSet8(h_NewAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
         h_OrigAd = p_CcNode->h_Ad;
         BuildNewAd(h_NewAd, p_FmPcdModifyCcKeyAdditionalParams, p_CcNode,
@@ -4054,6 +4054,7 @@ static t_Error IcHashIndexedCheckParams(t_Handle h_FmPcd,
     }
 
     *isKeyTblAlloc = FALSE;
+    cpu_to_be16s(&glblMask);
     memcpy(PTR_MOVE(p_CcNode->p_GlblMask, 2), &glblMask, 2);
 
     return E_OK;
@@ -4251,7 +4252,7 @@ static t_Error AllocStatsObjs(t_FmPcdCcNode *p_CcNode)
             RETURN_ERROR(MAJOR, E_NO_MEMORY,
                          ("MURAM allocation for statistics ADs"));
         }
-        IOMemSet32(h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+        MemSet8(h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
         /* Allocate statistics counters from MURAM */
         h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(
@@ -4265,7 +4266,7 @@ static t_Error AllocStatsObjs(t_FmPcdCcNode *p_CcNode)
             RETURN_ERROR(MAJOR, E_NO_MEMORY,
                          ("MURAM allocation for statistics counters"));
         }
-        IOMemSet32(h_StatsCounters, 0, p_CcNode->countersArraySize);
+        MemSet8(h_StatsCounters, 0, p_CcNode->countersArraySize);
 
         p_StatsObj->h_StatsAd = h_StatsAd;
         p_StatsObj->h_StatsCounters = h_StatsCounters;
@@ -4668,11 +4669,14 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode,
             /* Initialize using value received from the user */
             for (tmp = 0; tmp < p_CcNode->numOfStatsFLRs; tmp++)
             {
+                uint16_t flr =
+                         cpu_to_be16(p_CcNodeParam->keysParams.frameLengthRanges[tmp]);
+
                 h_StatsFLRs =
                         PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
 
-                Mem2IOCpy32(h_StatsFLRs,
-                            &(p_CcNodeParam->keysParams.frameLengthRanges[tmp]),
+                MemCpy8(h_StatsFLRs,
+                            &flr,
                             FM_PCD_CC_STATS_FLR_SIZE);
             }
             break;
@@ -4694,7 +4698,7 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode,
             RETURN_ERROR(MAJOR, E_NO_MEMORY,
                          ("MURAM allocation for CC node key match table"));
         }
-        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable, 0, matchTableSize);
+        MemSet8((uint8_t *)p_CcNode->h_KeysMatchTable, 0, matchTableSize);
     }
 
     /* Allocate action descriptors table */
@@ -4706,7 +4710,7 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode,
         RETURN_ERROR(MAJOR, E_NO_MEMORY,
                      ("MURAM allocation for CC node action descriptors table"));
     }
-    IOMemSet32((uint8_t *)p_CcNode->h_AdTable, 0, adTableSize);
+    MemSet8((uint8_t *)p_CcNode->h_AdTable, 0, adTableSize);
 
     p_KeysMatchTblTmp = p_CcNode->h_KeysMatchTable;
     p_AdTableTmp = p_CcNode->h_AdTable;
@@ -4719,20 +4723,20 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode,
         if (p_KeysMatchTblTmp)
         {
             /* Copy the key */
-            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key,
+            MemCpy8((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key,
                         p_CcNode->sizeOfExtraction);
 
             /* Copy the key mask or initialize it to 0xFF..F */
             if (p_CcNode->lclMask && p_KeyParams->p_Mask)
             {
-                Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp,
+                MemCpy8(PTR_MOVE(p_KeysMatchTblTmp,
                         p_CcNode->ccKeySizeAccExtraction), /* User's size of extraction rounded up to a valid matching table entry size */
                             p_KeyParams->p_Mask, p_CcNode->sizeOfExtraction); /* Exact size of extraction as received from the user */
             }
             else
                 if (p_CcNode->lclMask)
                 {
-                    IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
+                    MemSet8(PTR_MOVE(p_KeysMatchTblTmp,
                             p_CcNode->ccKeySizeAccExtraction), /* User's size of extraction rounded up to a valid matching table entry size */
                                0xff, p_CcNode->sizeOfExtraction); /* Exact size of extraction as received from the user */
                 }
@@ -6174,7 +6178,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd,
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Tree"));
         return NULL;
     }
-    IOMemSet32(
+    MemSet8(
             UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr), 0,
             (uint32_t)(FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE));
 
@@ -7079,6 +7083,7 @@ t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_CcNodeBucketHandle, E_NULL_POINTER);
 
     memcpy(&glblMask, PTR_MOVE(p_CcNode->p_GlblMask, 2), 2);
+    be16_to_cpus(&glblMask);
 
     crc64 = crc64_init();
     crc64 = crc64_compute(p_Key, keySize, crc64);
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_manip.c
index e980320..113777e 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_manip.c
@@ -182,6 +182,7 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams,
                         switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
                         {
                             case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
+                            case (e_FM_PCD_MANIP_HDR_INSRT_PPPOE):
                                 dataSize +=
                                         p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
                                 break;
@@ -472,6 +473,9 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
                             case (e_FM_PCD_MANIP_HDR_RMV_MPLS):
                                 hmcdOpt = HMCD_RMV_L2_MPLS;
                                 break;
+                            case (e_FM_PCD_MANIP_HDR_RMV_PPPOE):
+                                hmcdOpt = HMCD_RMV_L2_PPPOE;
+                                break;
                             default:
                                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
                         }
@@ -556,8 +560,8 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
                 p_LocalData = (uint32_t*)p_UsrData;
 
             /* initialize data and advance pointer to next command */
-            for (i = 0; i < size / 4; i++, p_TmpHmct += HMCD_BASIC_SIZE / 4)
-                WRITE_UINT32(*p_TmpHmct, *(p_LocalData+i));
+            MemCpy8(p_TmpHmct, p_LocalData, size);
+            p_TmpHmct += size / sizeof(uint32_t);
 
             if (remain)
                 XX_Free(p_LocalData);
@@ -585,6 +589,9 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
                                 else
                                     hmcdOpt = HMCD_INSRT_L2_MPLS;
                                 break;
+                            case (e_FM_PCD_MANIP_HDR_INSRT_PPPOE):
+                                hmcdOpt = HMCD_INSRT_L2_PPPOE;
+                                break;
                             default:
                                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
                         }
@@ -601,7 +608,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
                                 (uint8_t)p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
 
                         ASSERT_COND(p_TmpData);
-                        Mem2IOCpy32(
+                        MemCpy8(
                                 p_TmpData,
                                 p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.p_Data,
                                 size);
@@ -654,7 +661,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
                         WRITE_UINT8(*p_TmpHmct, p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.lastDstOffset);
                         p_TmpHmct += HMCD_PARAM_SIZE / 4;
 
-                        Mem2IOCpy32(
+                        MemCpy8(
                                 p_TmpHmct,
                                 p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.p_Data,
                                 p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size);
@@ -675,7 +682,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
 
                         p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
-                        Mem2IOCpy32(
+                        MemCpy8(
                                 p_TmpHmct,
                                 p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.p_Data,
                                 p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size);
@@ -695,7 +702,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
 
                         p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
-                        Mem2IOCpy32(
+                        MemCpy8(
                                 p_TmpHmct,
                                 p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.p_Data,
                                 p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size);
@@ -989,7 +996,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
                 size =
                         p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
                 ASSERT_COND(p_TmpData);
-                Mem2IOCpy32(
+                MemCpy8(
                         p_TmpData,
                         p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdr,
                         size);
@@ -1738,7 +1745,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle h_FmPcd,
             if (!p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer index pool table"));
 
-            IOMemSet32(p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl, 0, (uint32_t)(size + 1));
+            MemSet8(p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl, 0, (uint32_t)(size + 1));
 
             for ( i = 0; i < size; i++)
             WRITE_UINT8(*(uint8_t *)PTR_MOVE(p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl, i), (uint8_t)(i+1));
@@ -1756,7 +1763,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle h_FmPcd,
             if (!p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer pool table"));
 
-            IOMemSet32(p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl, 0, (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
+            MemSet8(p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl, 0, (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
 
             tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl) - p_FmPcd->physicalMuramBase);
 
@@ -1772,7 +1779,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle h_FmPcd,
             if (!p_Manip->capwapFragParams.p_TimeOutTbl)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly timeout table"));
 
-            IOMemSet32(p_Manip->capwapFragParams.p_TimeOutTbl, 0, (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
+            MemSet8(p_Manip->capwapFragParams.p_TimeOutTbl, 0, (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
 
             tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_TimeOutTbl) - p_FmPcd->physicalMuramBase);
             WRITE_UINT32(p_ReassmTbl->timeOutTblPtr, tmpReg32);
@@ -1922,7 +1929,7 @@ static t_Error CreateReassCommonTable(t_FmPcdManip *p_Manip)
         RETURN_ERROR(MAJOR, E_NO_MEMORY,
                      ("MURAM alloc for Reassembly common parameters table"));
 
-    IOMemSet32(p_Manip->reassmParams.p_ReassCommonTbl, 0,
+    MemSet8(p_Manip->reassmParams.p_ReassCommonTbl, 0,
                FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_SIZE);
 
     /* Setting the TimeOut Mode.*/
@@ -1950,7 +1957,7 @@ static t_Error CreateReassCommonTable(t_FmPcdManip *p_Manip)
                 MAJOR, E_NO_MEMORY,
                 ("MURAM alloc for Reassembly frame descriptor indexes pool"));
 
-    IOMemSet32(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr),
+    MemSet8(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr),
                0, (uint32_t)(size * 2));
 
     /* The entries in IP Reassembly Frame Descriptor Indexes Pool contains indexes starting with 1 up to
@@ -1977,7 +1984,7 @@ static t_Error CreateReassCommonTable(t_FmPcdManip *p_Manip)
     if (!p_Manip->reassmParams.reassFrmDescrPoolTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
 
-    IOMemSet32(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrPoolTblAddr), 0,
+    MemSet8(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrPoolTblAddr), 0,
                (uint32_t)(size * 64));
 
     /* Sets the Reassembly Frame Descriptors Pool and liodn offset*/
@@ -2005,7 +2012,7 @@ static t_Error CreateReassCommonTable(t_FmPcdManip *p_Manip)
         RETURN_ERROR(MAJOR, E_NO_MEMORY,
                      ("MURAM alloc for Reassembly timeout table"));
 
-    IOMemSet32(UINT_TO_PTR(p_Manip->reassmParams.timeOutTblAddr), 0,
+    MemSet8(UINT_TO_PTR(p_Manip->reassmParams.timeOutTblAddr), 0,
                (uint16_t)(size * 8));
 
     /* Sets the TimeOut table offset from MURAM */
@@ -2144,7 +2151,7 @@ static t_Error CreateReassTable(t_FmPcdManip *p_Manip, e_NetHeaderType hdr)
         *p_ReassTbl = NULL;
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
-    IOMemSet32(UINT_TO_PTR(*p_AutoLearnHashTblAddr), 0, autoLearnHashTblSize);
+    MemSet8(UINT_TO_PTR(*p_AutoLearnHashTblAddr), 0, autoLearnHashTblSize);
 
     /* Sets the Reassembly Automatic Learning Hash Table and liodn offset */
     tmpReg64 = ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
@@ -2171,7 +2178,7 @@ static t_Error CreateReassTable(t_FmPcdManip *p_Manip, e_NetHeaderType hdr)
         *p_AutoLearnHashTblAddr = 0;
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
-    IOMemSet32(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr), 0, (numOfSets * 4));
+    MemSet8(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr), 0, (numOfSets * 4));
 
     /* sets Set Lock table pointer and liodn offset*/
     tmpReg64 = ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
@@ -2266,7 +2273,7 @@ static t_Error UpdateInitReasm(t_Handle h_FmPcd, t_Handle h_PcdParams,
                 RETURN_ERROR(
                         MAJOR, E_NO_MEMORY,
                         ("MURAM alloc for Reassembly internal buffers pool"));
-            IOMemSet32(
+            MemSet8(
                     UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolAddr),
                     0, (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS));
 
@@ -2961,7 +2968,7 @@ static t_Error UpdateIndxStats(t_Handle h_FmPcd,
         if (!p_Manip->p_StatsTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation indexed statistics table"));
 
-        IOMemSet32(p_Manip->p_StatsTbl, 0, (uint32_t)(p_Manip->owner * 4));
+        MemSet8(p_Manip->p_StatsTbl, 0, (uint32_t)(p_Manip->owner * 4));
 
         tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->p_StatsTbl) - p_FmPcd->physicalMuramBase);
 
@@ -3122,7 +3129,7 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
     if (!p_Manip->h_Frag)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc CAPWAP reassembly parameters table"));
 
-    IOMemSet32(p_Manip->h_Frag, 0, FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
+    MemSet8(p_Manip->h_Frag, 0, FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
 
     p_Table = (t_CapwapReasmPram *)p_Manip->h_Frag;
 
@@ -3134,7 +3141,7 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
     if (!p_Manip->capwapFragParams.p_AutoLearnHashTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
 
-    IOMemSet32(p_Manip->capwapFragParams.p_AutoLearnHashTbl, 0, (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
+    MemSet8(p_Manip->capwapFragParams.p_AutoLearnHashTbl, 0, (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
 
     tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_AutoLearnHashTbl) - p_FmPcd->physicalMuramBase);
 
@@ -3204,7 +3211,7 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams *p_ManipParams,
     if (!p_Manip->h_Frag)
     RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP fragmentation table descriptor"));
 
-    IOMemSet32(p_Manip->h_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+    MemSet8(p_Manip->h_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
@@ -3422,7 +3429,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams *p_ManipParams, t_FmPc
             p_Template[14] = tmpReg8;
         }
 
-        Mem2IOCpy32(p_Manip->p_Template, p_Template, p_InsrtByTemplate->size);
+        MemCpy8(p_Manip->p_Template, p_Template, p_InsrtByTemplate->size);
 
         XX_Free(p_Template);
     }
@@ -3899,7 +3906,7 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,
     if (!p_Manip->fragParams.p_Frag)
         RETURN_ERROR(MAJOR, E_NO_MEMORY,
                      ("MURAM alloc for Fragmentation table descriptor"));
-    IOMemSet32(p_Manip->fragParams.p_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+    MemSet8(p_Manip->fragParams.p_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Prepare the third Ad register (pcAndOffsets)- OperationCode */
     pcAndOffsetsReg = (uint32_t)HMAN_OC_IP_FRAGMENTATION;
@@ -4288,7 +4295,7 @@ static t_Error CapwapFragmentation(t_FmPcdManipFragCapwapParams *p_ManipParams,
     if (!p_Manip->fragParams.p_Frag)
         RETURN_ERROR(MAJOR, E_NO_MEMORY,
                      ("MURAM alloc for Fragmentation table descriptor"));
-    IOMemSet32(p_Manip->fragParams.p_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+    MemSet8(p_Manip->fragParams.p_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Prepare the third Ad register (pcAndOffsets)- OperationCode */
     pcAndOffsetsReg = (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
@@ -4464,7 +4471,7 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params,
                 return NULL;
             }
 
-            IOMemSet32(p_Manip->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+            MemSet8(p_Manip->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
         }
         else
         {
@@ -4538,7 +4545,7 @@ static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd,
     t_Error err;
 
     /* Copy the HMTD */
-    IO2IOCpy32(p_Dest, (uint8_t*)p_Src, 16);
+    MemCpy8(p_Dest, (uint8_t*)p_Src, 16);
     /* Replace the HMCT table pointer  */
     WRITE_UINT32(
             ((t_Hmtd *)p_Dest)->hmcdBasePtr,
@@ -4975,7 +4982,7 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad,
 #endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         case (HMAN_OC):
             /* Initialize HMTD within the match table*/
-            IOMemSet32(p_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+            MemSet8(p_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
             /* copy the existing HMTD *//* ask Alla - memcpy??? */
             memcpy((uint8_t*)p_Ad, p_Manip->h_Ad, sizeof(t_Hmtd));
             /* update NADEN to be "1"*/
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_manip.h
index ebafd63..853bb83 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_manip.h
@@ -222,9 +222,11 @@
 #define HMCD_RMV_L2_STACKED_QTAGS               1
 #define HMCD_RMV_L2_ETHERNET_AND_MPLS           2
 #define HMCD_RMV_L2_MPLS                        3
+#define HMCD_RMV_L2_PPPOE                        4
 
 #define HMCD_INSRT_L2_MPLS                      0
 #define HMCD_INSRT_N_UPDATE_L2_MPLS             1
+#define HMCD_INSRT_L2_PPPOE                     2
 #define HMCD_INSRT_L2_SIZE_SHIFT                24
 
 #define HMCD_L2_MODE_SHIFT                      16
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_prs.c
index da2fccf..a21b104 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/Pcd/fm_prs.c
@@ -160,8 +160,8 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
         FmEnableRamsEcc(p_FmPcd->h_Fm);
 
     /* load sw parser Ip-Frag patch */
-    for (i=0; i<DIV_CEIL(sizeof(swPrsPatch),4); i++)
-        WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
+    for (i=0; i<DIV_CEIL(sizeof(swPrsPatch), 4); i++)
+        WRITE_UINT32(p_LoadTarget[i], GET_UINT32(p_TmpCode[i]));
 
     XX_FreeSmart(p_TmpCode);
 
@@ -387,8 +387,10 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 
     /* load sw parser code */
     p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;
-    for(i=0; i<DIV_CEIL(p_SwPrs->size,4); i++)
-        WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
+
+    for(i=0; i<DIV_CEIL(p_SwPrs->size, 4); i++)
+        WRITE_UINT32(p_LoadTarget[i], GET_UINT32(p_TmpCode[i]));
+
     p_FmPcd->p_FmPcdPrs->p_CurrSwPrs =
         p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + ROUND_UP(p_SwPrs->size,4);
 
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c
index 71ef3a22..f5040c7 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c
@@ -47,7 +47,9 @@
 #include "fm_common.h"
 #include "fm_ipc.h"
 #include "fm.h"
+#ifndef CONFIG_ARM64
 #include <linux/fsl/svr.h>
+#endif
 #include "fsl_fman.h"
 
 
@@ -3530,6 +3532,7 @@ t_Error FM_Init(t_Handle h_Fm)
         if ((err = FwNotResetErratumBugzilla6173WA(p_Fm)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 #else  /* not FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
+#ifndef CONFIG_FMAN_ARM
         {
             u32 svr = mfspr(SPRN_SVR);
 
@@ -3547,6 +3550,7 @@ t_Error FM_Init(t_Handle h_Fm)
                 XX_UDelay(100);
             }
         }
+#endif
         if (fman_is_qmi_halt_not_busy_state(p_Fm->p_FmQmiRegs))
         {
             fman_resume(p_Fm->p_FmFpmRegs);
diff --git a/drivers/net/ethernet/freescale/sdk_fman/etc/memcpy.c b/drivers/net/ethernet/freescale/sdk_fman/etc/memcpy.c
index 02973e5..fa203ec 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/etc/memcpy.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/etc/memcpy.c
@@ -36,6 +36,25 @@
 #include "xx_ext.h"
 #include "memcpy_ext.h"
 
+void * MemCpy8(void* pDst, void* pSrc, uint32_t size)
+{
+    int i;
+
+    for(i = 0; i < size; ++i)
+        *(((uint8_t*)(pDst)) + i) = *(((uint8_t*)(pSrc)) + i);
+
+    return pDst;
+}
+
+void * MemSet8(void* pDst, int c, uint32_t size)
+{
+    int i;
+
+    for(i = 0; i < size; ++i)
+        *(((uint8_t*)(pDst)) + i) = (uint8_t)(c);
+
+    return pDst;
+}
 
 void * MemCpy32(void* pDst,void* pSrc, uint32_t size)
 {
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/Peripherals/fm_pcd_ext.h
index a9e4a24..8d1c3d8 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/Peripherals/fm_pcd_ext.h
@@ -1121,7 +1121,8 @@ typedef enum e_FmPcdManipHdrRmvSpecificL2 {
     e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS,           /**< stacked QTags */
     e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS,       /**< MPLS and Ethernet/802.3 MAC header until
                                                          the header which follows the MPLS header */
-    e_FM_PCD_MANIP_HDR_RMV_MPLS                     /**< Remove MPLS header (Unlimited MPLS labels) */
+    e_FM_PCD_MANIP_HDR_RMV_MPLS,                     /**< Remove MPLS header (Unlimited MPLS labels) */
+    e_FM_PCD_MANIP_HDR_RMV_PPPOE                     /**< Remove the PPPoE header and PPP protocol field. */
 } e_FmPcdManipHdrRmvSpecificL2;
 
 /**************************************************************************//**
@@ -1146,7 +1147,8 @@ typedef enum e_FmPcdManipHdrFieldUpdateVlan {
  @Description   Enumeration type for selecting specific L2 header insertion
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrInsrtSpecificL2 {
-    e_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
+    e_FM_PCD_MANIP_HDR_INSRT_MPLS,                   /**< Insert MPLS header (Unlimited MPLS labels) */
+    e_FM_PCD_MANIP_HDR_INSRT_PPPOE                   /**< Insert PPPOE */
 } e_FmPcdManipHdrInsrtSpecificL2;
 
 #if (DPAA_VERSION >= 11)
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/core_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/core_ext.h
index 42174cf..ec89a6d 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/inc/core_ext.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/core_ext.h
@@ -43,7 +43,10 @@
 #ifndef __CORE_EXT_H
 #define __CORE_EXT_H
 
-
+#ifdef CONFIG_FMAN_ARM
+#include "arm_ext.h"
+#include <linux/smp.h>
+#else
 #ifdef NCSW_PPC_CORE
 #include "ppc_ext.h"
 #elif defined(NCSW_VXWORKS)
@@ -60,6 +63,8 @@
 #error "Must define the core cache-line size!"
 #endif /* !CORE_CACHELINE_SIZE */
 
+#endif /* CONFIG_FMAN_ARM */
+
 
 /**************************************************************************//**
  @Function      CORE_GetId
@@ -83,4 +88,3 @@ void CORE_MemoryBarrier(void);
 #define fsl_mem_core_barrier() CORE_MemoryBarrier()
 
 #endif /* __CORE_EXT_H */
-
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/cores/arm_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/cores/arm_ext.h
new file mode 100644
index 0000000..e63444a
--- /dev/null
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/cores/arm_ext.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/**************************************************************************//**
+ @File          arm_ext.h
+
+ @Description   Core API for ARM cores
+
+                These routines must be implemented by each specific PowerPC
+                core driver.
+*//***************************************************************************/
+#ifndef __ARM_EXT_H
+#define __ARM_EXT_H
+
+#include "part_ext.h"
+
+
+#define CORE_IS_LITTLE_ENDIAN
+
+static __inline__ void CORE_MemoryBarrier(void)
+{
+	mb();
+}
+
+#endif /* __PPC_EXT_H */
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/error_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/error_ext.h
index 71f9398..2a5ad67 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/inc/error_ext.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/error_ext.h
@@ -327,7 +327,7 @@ int ERROR_DYNAMIC_LEVEL = ERROR_GLOBAL_LEVEL;
 #endif /* !ERROR_DYNAMIC_LEVEL */
 
 #define PRINT_FORMAT        "[CPU%02d, %s:%d %s]"
-#define PRINT_FMT_PARAMS    CORE_GetId(), __FILE__, __LINE__, __FUNCTION__
+#define PRINT_FMT_PARAMS    raw_smp_processor_id(), __FILE__, __LINE__, __FUNCTION__
 
 #if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
 /* No debug/error/event messages at all */
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/etc/memcpy_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/etc/memcpy_ext.h
index cc5bb72..1b3a2fa 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/inc/etc/memcpy_ext.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/etc/memcpy_ext.h
@@ -167,6 +167,40 @@ void * MemSet64(void* pDst, uint8_t val, uint32_t size);
 *//***************************************************************************/
 void MemDisp(uint8_t *addr, int size);
 
+/**************************************************************************//**
+ @Function      MemCpy8
+
+ @Description   Trivial copy one memory buffer into another byte by byte
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     pSrc    - The address of the source buffer.
+ @Param[in]     size    - The number of bytes that will be copied from pSrc to pDst.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non-null parameters as source & destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemCpy8(void* pDst,void* pSrc, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemSet8
+
+ @Description   Sets all bytes of a memory buffer to a specific value byte by byte.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     c       - Value to set destination bytes to.
+ @Param[in]     size    - The number of bytes that will be set to val.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemSet8(void* pDst, int c, uint32_t size);
+
 /** @} */ /* end of mem_cpy group */
 /** @} */ /* end of etc_id group */
 
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/flib/common/general.h b/drivers/net/ethernet/freescale/sdk_fman/inc/flib/common/general.h
index 8150e01..b3f516f 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/inc/flib/common/general.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/flib/common/general.h
@@ -41,9 +41,10 @@
 
 extern uint32_t get_mac_addr_crc(uint64_t _addr);
 
-
+#ifndef CONFIG_FMAN_ARM
 #define iowrite32be(val, addr)  WRITE_UINT32(*addr, val)
 #define ioread32be(addr)        GET_UINT32(*addr)
+#endif
 
 #define ether_crc(len, addr)    get_mac_addr_crc(*(uint64_t *)(addr)>>16)
 
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/dpaa_integration_ext.h
new file mode 100644
index 0000000..5a8f358
--- /dev/null
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/dpaa_integration_ext.h
@@ -0,0 +1,291 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          dpaa_integration_ext.h
+
+ @Description   T4240 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_EXT_H
+#define __DPAA_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+
+
+#define DPAA_VERSION    11
+
+/**************************************************************************//**
+ @Description   DPAA SW Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL3,
+    e_DPAA_SWPORTAL4,
+    e_DPAA_SWPORTAL5,
+    e_DPAA_SWPORTAL6,
+    e_DPAA_SWPORTAL7,
+    e_DPAA_SWPORTAL8,
+    e_DPAA_SWPORTAL9,
+    e_DPAA_SWPORTAL10,
+    e_DPAA_SWPORTAL11,
+    e_DPAA_SWPORTAL12,
+    e_DPAA_SWPORTAL13,
+    e_DPAA_SWPORTAL14,
+    e_DPAA_SWPORTAL15,
+    e_DPAA_SWPORTAL16,
+    e_DPAA_SWPORTAL17,
+    e_DPAA_SWPORTAL18,
+    e_DPAA_SWPORTAL19,
+    e_DPAA_SWPORTAL20,
+    e_DPAA_SWPORTAL21,
+    e_DPAA_SWPORTAL22,
+    e_DPAA_SWPORTAL23,
+    e_DPAA_SWPORTAL24,
+    e_DPAA_SWPORTAL_DUMMY_LAST
+} e_DpaaSwPortal;
+
+/**************************************************************************//**
+ @Description   DPAA Direct Connect Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_DCPORTAL0 = 0,
+    e_DPAA_DCPORTAL1,
+    e_DPAA_DCPORTAL2,
+    e_DPAA_DCPORTAL_DUMMY_LAST
+} e_DpaaDcPortal;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
+#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
+
+/*****************************************************************************
+ QMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QM_MAX_NUM_OF_POOL_CHANNELS     15      /**< Total number of channels, dedicated and pool */
+#define QM_MAX_NUM_OF_WQ                8       /**< Number of work queues per channel */
+#define QM_MAX_NUM_OF_CGS               256     /**< Congestion groups number */
+#define QM_MAX_NUM_OF_FQIDS             (16 * MEGABYTE)
+                                                /**< FQIDs range - 24 bits */
+
+/**************************************************************************//**
+ @Description   Work Queue Channel assignments in QMan.
+*//***************************************************************************/
+typedef enum
+{
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0x0,              /**< Dedicated channels serviced by software portals 0 to 24 */
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+    e_QM_FQ_CHANNEL_SWPORTAL3,
+    e_QM_FQ_CHANNEL_SWPORTAL4,
+    e_QM_FQ_CHANNEL_SWPORTAL5,
+    e_QM_FQ_CHANNEL_SWPORTAL6,
+    e_QM_FQ_CHANNEL_SWPORTAL7,
+    e_QM_FQ_CHANNEL_SWPORTAL8,
+    e_QM_FQ_CHANNEL_SWPORTAL9,
+    e_QM_FQ_CHANNEL_SWPORTAL10,
+    e_QM_FQ_CHANNEL_SWPORTAL11,
+    e_QM_FQ_CHANNEL_SWPORTAL12,
+    e_QM_FQ_CHANNEL_SWPORTAL13,
+    e_QM_FQ_CHANNEL_SWPORTAL14,
+    e_QM_FQ_CHANNEL_SWPORTAL15,
+    e_QM_FQ_CHANNEL_SWPORTAL16,
+    e_QM_FQ_CHANNEL_SWPORTAL17,
+    e_QM_FQ_CHANNEL_SWPORTAL18,
+    e_QM_FQ_CHANNEL_SWPORTAL19,
+    e_QM_FQ_CHANNEL_SWPORTAL20,
+    e_QM_FQ_CHANNEL_SWPORTAL21,
+    e_QM_FQ_CHANNEL_SWPORTAL22,
+    e_QM_FQ_CHANNEL_SWPORTAL23,
+    e_QM_FQ_CHANNEL_SWPORTAL24,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x401,               /**< Pool channels that can be serviced by any of the software portals */
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+    e_QM_FQ_CHANNEL_POOL4,
+    e_QM_FQ_CHANNEL_POOL5,
+    e_QM_FQ_CHANNEL_POOL6,
+    e_QM_FQ_CHANNEL_POOL7,
+    e_QM_FQ_CHANNEL_POOL8,
+    e_QM_FQ_CHANNEL_POOL9,
+    e_QM_FQ_CHANNEL_POOL10,
+    e_QM_FQ_CHANNEL_POOL11,
+    e_QM_FQ_CHANNEL_POOL12,
+    e_QM_FQ_CHANNEL_POOL13,
+    e_QM_FQ_CHANNEL_POOL14,
+    e_QM_FQ_CHANNEL_POOL15,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x800,           /**< Dedicated channels serviced by Direct Connect Portal 0:
+                                                      connected to FMan 0; assigned in incrementing order to
+                                                      each sub-portal (SP) in the portal */
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+    e_QM_FQ_CHANNEL_FMAN0_SP7,
+    e_QM_FQ_CHANNEL_FMAN0_SP8,
+    e_QM_FQ_CHANNEL_FMAN0_SP9,
+    e_QM_FQ_CHANNEL_FMAN0_SP10,
+    e_QM_FQ_CHANNEL_FMAN0_SP11,
+    e_QM_FQ_CHANNEL_FMAN0_SP12,
+    e_QM_FQ_CHANNEL_FMAN0_SP13,
+    e_QM_FQ_CHANNEL_FMAN0_SP14,
+    e_QM_FQ_CHANNEL_FMAN0_SP15,
+
+    e_QM_FQ_CHANNEL_RMAN_SP0 = 0x820,            /**< Dedicated channels serviced by Direct Connect Portal 1: connected to RMan */
+    e_QM_FQ_CHANNEL_RMAN_SP1,
+
+    e_QM_FQ_CHANNEL_CAAM = 0x840                 /**< Dedicated channel serviced by Direct Connect Portal 2:
+                                                      connected to SEC */
+} e_QmFQChannel;
+
+/*****************************************************************************
+ BMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
+
+/*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SEC_NUM_OF_DECOS            3
+#define SEC_ALL_DECOS_MASK          0x00000003
+
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          2
+
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_MACS       6
+#define FM_MAX_NUM_OF_10G_MACS      2
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_OH_PORTS      6
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS)
+
+#define FM_MAX_NUM_OF_1G_TX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_TX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS + FM_MAX_NUM_OF_1G_TX_PORTS)
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            4           /**< Number of external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               16
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
+
+#define FM_VSP_MAX_NUM_OF_ENTRIES               64
+#define FM_MAX_NUM_OF_PFC_PRIORITIES            8
+
+/* RAMs defines */
+#define FM_MURAM_SIZE                   (384 * KILOBYTE)
+#define FM_IRAM_SIZE(major, minor)      (64 * KILOBYTE)
+#define FM_NUM_OF_CTRL                  4
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
+#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000600          /**< Number of bytes saved for patches */
+#define FM_PCD_SW_PRS_SIZE              0x00000800          /**< Total size of SW parser area */
+
+/* RTC defines */
+#define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   3                   /**< RTC number of periodic pulses */
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2                   /**< RTC number of external triggers */
+
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            64
+#define QMI_DEF_TNUMS_THRESH            32
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            83
+#define DMA_THRESH_MAX_BUF              127
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            128
+#define BMI_MAX_NUM_OF_DMAS             84
+
+#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 16
+
+#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
+
+/* Unique T4240 */
+#define FM_OP_OPEN_DMA_MIN_LIMIT
+#define FM_NO_RESTRICT_ON_ACCESS_RSRC
+#define FM_NO_OP_OBSERVED_POOLS
+#define FM_FRAME_END_PARAMS_FOR_OP
+#define FM_DEQ_PIPELINE_PARAMS_FOR_OP
+#define FM_QMI_NO_SINGLE_ECC_EXCEPTION
+
+#define FM_NO_GUARANTEED_RESET_VALUES
+
+/* FM errata */
+#define FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
+#define FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
+#define FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
+#define FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675
+#define FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981
+
+#define FM_BCB_ERRATA_BMI_SW001
+#define FM_LEN_CHECK_ERRATA_FMAN_SW002
+#define FM_AID_MODE_NO_TNUM_SW005 /* refer to pdm TKT068794 - only support of port_id on aid */
+#define FM_ERROR_VSP_NO_MATCH_SW006 /* refer to pdm TKT174304 - no match between errorQ and VSP */
+
+/*****************************************************************************
+ RMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define RM_MAX_NUM_OF_IB        4           /**< Number of inbound blocks */
+#define RM_NUM_OF_IBCU          8           /**< NUmber of classification units in an inbound block */
+
+/* RMan erratas */
+#define RM_ERRONEOUS_ACK_ERRATA_RMAN_A006756
+
+/*****************************************************************************
+ FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define NUM_OF_RX_SC                16
+#define NUM_OF_TX_SC                16
+
+#define NUM_OF_SA_PER_RX_SC         2
+#define NUM_OF_SA_PER_TX_SC         2
+
+#endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/part_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/part_ext.h
new file mode 100644
index 0000000..4787e19
--- /dev/null
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/part_ext.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          part_ext.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_EXT_H
+#define __PART_EXT_H
+
+#include "std_ext.h"
+#include "part_integration_ext.h"
+
+#if !(defined(LS1043))
+#error "unable to proceed without chip-definition"
+#endif
+
+
+/**************************************************************************//*
+ @Description   Part data structure - must be contained in any integration
+                data structure.
+*//***************************************************************************/
+typedef struct t_Part
+{
+    uintptr_t   (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+                /**< Returns the address of the module's memory map base. */
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uintptr_t baseAddress);
+                /**< Returns the module's ID according to its memory map base. */
+} t_Part;
+
+
+#endif /* __PART_EXT_H */
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/part_integration_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/part_integration_ext.h
new file mode 100644
index 0000000..85ba2a4
--- /dev/null
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/integrations/LS1043/part_integration_ext.h
@@ -0,0 +1,185 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          part_integration_ext.h
+
+ @Description   T4240 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_EXT_H
+#define __PART_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+#include "ddr_std_ext.h"
+#include "enet_ext.h"
+#include "dpaa_integration_ext.h"
+
+
+/**************************************************************************//**
+ @Group         T4240_chip_id T4240 Application Programming Interface
+
+ @Description   T4240 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define INTG_MAX_NUM_OF_CORES   4
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_DUART_1 = 0,
+    e_MODULE_ID_DUART_2,
+    e_MODULE_ID_DUART_3,
+    e_MODULE_ID_DUART_4,
+    e_MODULE_ID_LAW,
+    e_MODULE_ID_IFC,
+    e_MODULE_ID_PAMU,
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+    e_MODULE_ID_QM_CE_PORTAL_0,
+    e_MODULE_ID_QM_CI_PORTAL_0,
+    e_MODULE_ID_QM_CE_PORTAL_1,
+    e_MODULE_ID_QM_CI_PORTAL_1,
+    e_MODULE_ID_QM_CE_PORTAL_2,
+    e_MODULE_ID_QM_CI_PORTAL_2,
+    e_MODULE_ID_QM_CE_PORTAL_3,
+    e_MODULE_ID_QM_CI_PORTAL_3,
+    e_MODULE_ID_QM_CE_PORTAL_4,
+    e_MODULE_ID_QM_CI_PORTAL_4,
+    e_MODULE_ID_QM_CE_PORTAL_5,
+    e_MODULE_ID_QM_CI_PORTAL_5,
+    e_MODULE_ID_QM_CE_PORTAL_6,
+    e_MODULE_ID_QM_CI_PORTAL_6,
+    e_MODULE_ID_QM_CE_PORTAL_7,
+    e_MODULE_ID_QM_CI_PORTAL_7,
+    e_MODULE_ID_QM_CE_PORTAL_8,
+    e_MODULE_ID_QM_CI_PORTAL_8,
+    e_MODULE_ID_QM_CE_PORTAL_9,
+    e_MODULE_ID_QM_CI_PORTAL_9,
+    e_MODULE_ID_BM_CE_PORTAL_0,
+    e_MODULE_ID_BM_CI_PORTAL_0,
+    e_MODULE_ID_BM_CE_PORTAL_1,
+    e_MODULE_ID_BM_CI_PORTAL_1,
+    e_MODULE_ID_BM_CE_PORTAL_2,
+    e_MODULE_ID_BM_CI_PORTAL_2,
+    e_MODULE_ID_BM_CE_PORTAL_3,
+    e_MODULE_ID_BM_CI_PORTAL_3,
+    e_MODULE_ID_BM_CE_PORTAL_4,
+    e_MODULE_ID_BM_CI_PORTAL_4,
+    e_MODULE_ID_BM_CE_PORTAL_5,
+    e_MODULE_ID_BM_CI_PORTAL_5,
+    e_MODULE_ID_BM_CE_PORTAL_6,
+    e_MODULE_ID_BM_CI_PORTAL_6,
+    e_MODULE_ID_BM_CE_PORTAL_7,
+    e_MODULE_ID_BM_CI_PORTAL_7,
+    e_MODULE_ID_BM_CE_PORTAL_8,
+    e_MODULE_ID_BM_CI_PORTAL_8,
+    e_MODULE_ID_BM_CE_PORTAL_9,
+    e_MODULE_ID_BM_CI_PORTAL_9,
+    e_MODULE_ID_FM,                 /**< Frame manager module */
+    e_MODULE_ID_FM_RTC,             /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM_MURAM,           /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM_BMI,             /**< FM BMI block */
+    e_MODULE_ID_FM_QMI,             /**< FM QMI block */
+    e_MODULE_ID_FM_PARSER,          /**< FM parser block */
+    e_MODULE_ID_FM_PORT_HO1,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO2,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO3,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO4,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO5,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO6,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO7,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_1GRx1,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx2,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx3,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx4,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx5,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx6,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_10GRx1,     /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_10GRx2,     /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx1,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx2,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx3,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx4,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx5,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx6,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_10GTx1,     /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_10GTx2,     /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM_PLCR,            /**< FM Policer */
+    e_MODULE_ID_FM_KG,              /**< FM Keygen */
+    e_MODULE_ID_FM_DMA,             /**< FM DMA */
+    e_MODULE_ID_FM_FPM,             /**< FM FPM */
+    e_MODULE_ID_FM_IRAM,            /**< FM Instruction-RAM */
+    e_MODULE_ID_FM_1GMDIO,          /**< FM 1G MDIO MAC */
+    e_MODULE_ID_FM_10GMDIO,         /**< FM 10G MDIO */
+    e_MODULE_ID_FM_PRS_IRAM,        /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM_1GMAC1,          /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM_1GMAC2,          /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM_1GMAC3,          /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM_1GMAC4,          /**< FM 1G MAC #4 */
+    e_MODULE_ID_FM_1GMAC5,          /**< FM 1G MAC #5 */
+    e_MODULE_ID_FM_1GMAC6,          /**< FM 1G MAC #6 */
+    e_MODULE_ID_FM_10GMAC1,         /**< FM 10G MAC */
+    e_MODULE_ID_FM_10GMAC2,         /**< FM 10G MAC */
+
+    e_MODULE_ID_SEC_GEN,            /**< SEC 4.0 General registers      */
+    e_MODULE_ID_SEC_QI,             /**< SEC 4.0 QI registers           */
+    e_MODULE_ID_SEC_JQ0,            /**< SEC 4.0 JQ-0 registers         */
+    e_MODULE_ID_SEC_JQ1,            /**< SEC 4.0 JQ-1 registers         */
+    e_MODULE_ID_SEC_JQ2,            /**< SEC 4.0 JQ-2 registers         */
+    e_MODULE_ID_SEC_JQ3,            /**< SEC 4.0 JQ-3 registers         */
+    e_MODULE_ID_SEC_RTIC,           /**< SEC 4.0 RTIC registers         */
+    e_MODULE_ID_SEC_DECO0_CCB0,     /**< SEC 4.0 DECO-0/CCB-0 registers */
+    e_MODULE_ID_SEC_DECO1_CCB1,     /**< SEC 4.0 DECO-1/CCB-1 registers */
+    e_MODULE_ID_SEC_DECO2_CCB2,     /**< SEC 4.0 DECO-2/CCB-2 registers */
+    e_MODULE_ID_SEC_DECO3_CCB3,     /**< SEC 4.0 DECO-3/CCB-3 registers */
+    e_MODULE_ID_SEC_DECO4_CCB4,     /**< SEC 4.0 DECO-4/CCB-4 registers */
+
+    e_MODULE_ID_PIC,                /**< PIC */
+    e_MODULE_ID_GPIO,               /**< GPIO */
+    e_MODULE_ID_SERDES,             /**< SERDES */
+    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
+    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
+
+    e_MODULE_ID_SRIO_PORTS,         /**< RapidIO controller */
+
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+
+#endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/types_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/types_ext.h
index fd900e2..8c87edb 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/inc/types_ext.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/types_ext.h
@@ -59,46 +59,4 @@
 #include "types_dflt.h"
 #endif /* defined (__ROCOO__) */
 
-static __inline__ void TypesChecker(void)
-{
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-     _Packed struct strct {
-        __volatile__ int vi;
-    } _PackedType;
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
-    size_t          size = 0;
-    bool            tr = TRUE, fls = FALSE;
-    struct strct    *p_Struct = NULL;
-    physAddress_t   addr = 0x100;
-
-    tr          = fls;
-    p_Struct    = p_Struct;
-    size++;
-    if (tr) size++;
-
-    WRITE_UINT8(*((uint8_t*)((size_t)(addr))),
-                 GET_UINT8(*((uint8_t*)((size_t)(addr)))));
-
-    WRITE_UINT8(*((uint8_t*)((size_t)(UINT8_MAX))),
-                 GET_UINT8(*((uint8_t*)((size_t)(UINT8_MAX)))));
-    WRITE_UINT16(*((uint16_t*)((size_t)(UINT16_MAX))),
-                 GET_UINT16(*((uint16_t*)((size_t)(UINT16_MAX)))));
-    WRITE_UINT32(*((uint32_t*)((size_t)(UINT32_MAX))),
-                 GET_UINT32(*((uint32_t*)((size_t)(UINT32_MAX)))));
-    WRITE_UINT64(*((uint64_t*)((size_t)(UINT64_MAX))),
-                 GET_UINT64(*((uint64_t*)((size_t)(UINT64_MAX)))));
-    WRITE_UINT8(*((uint8_t*)((size_t)(INT8_MAX))),
-                 GET_UINT8(*((uint8_t*)((size_t)(INT8_MIN)))));
-    WRITE_UINT16(*((uint16_t*)((size_t)(INT16_MAX))),
-                 GET_UINT16(*((uint16_t*)((size_t)(INT16_MIN)))));
-    WRITE_UINT32(*((uint32_t*)((size_t)(INT32_MAX))),
-                 GET_UINT32(*((uint32_t*)((size_t)(INT32_MIN)))));
-    WRITE_UINT64(*((uint64_t*)((size_t)(INT64_MAX))),
-                 GET_UINT64(*((uint64_t*)((size_t)(INT64_MIN)))));
-}
-
 #endif /* __TYPES_EXT_H */
diff --git a/drivers/net/ethernet/freescale/sdk_fman/ls1043_dflags.h b/drivers/net/ethernet/freescale/sdk_fman/ls1043_dflags.h
new file mode 100644
index 0000000..c3a5a62
--- /dev/null
+++ b/drivers/net/ethernet/freescale/sdk_fman/ls1043_dflags.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __dflags_h
+#define __dflags_h
+
+
+#define NCSW_LINUX
+
+#define LS1043
+
+#define DEBUG_ERRORS        1
+
+#if defined(DEBUG)
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_INFO
+
+#define DEBUG_XX_MALLOC
+#define DEBUG_MEM_LEAKS
+
+#else
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* (DEBUG) */
+
+#define REPORT_EVENTS       1
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+
+#endif /* __dflags_h */
diff --git a/drivers/net/ethernet/freescale/sdk_fman/ncsw_config.mk b/drivers/net/ethernet/freescale/sdk_fman/ncsw_config.mk
index b1fde53..586f9c7 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/ncsw_config.mk
+++ b/drivers/net/ethernet/freescale/sdk_fman/ncsw_config.mk
@@ -17,6 +17,9 @@ endif
 ifdef CONFIG_FMAN_V3L
 ccflags-y +=-include $(FMAN)/fmanv3l_dflags.h
 endif
+ifdef CONFIG_FMAN_ARM
+ccflags-y +=-include $(FMAN)/ls1043_dflags.h
+endif
 
 ccflags-y += -I$(DRV_DPA)/
 ccflags-y += -I$(FMAN)/inc
@@ -37,6 +40,9 @@ endif
 ifdef CONFIG_FMAN_V3L
 ccflags-y += -I$(FMAN)/inc/integrations/FMANV3L
 endif
+ifdef CONFIG_FMAN_ARM
+ccflags-y += -I$(FMAN)/inc/integrations/LS1043
+endif
 
 ccflags-y += -I$(FMAN)/src/inc
 ccflags-y += -I$(FMAN)/src/inc/system
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/inc/types_linux.h b/drivers/net/ethernet/freescale/sdk_fman/src/inc/types_linux.h
index ac15d66..201ad69 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/src/inc/types_linux.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/inc/types_linux.h
@@ -45,6 +45,7 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <asm/io.h>
+#include <linux/delay.h>
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
     #error "This kernel is probably not supported!!!"
@@ -91,6 +92,13 @@ typedef  phys_addr_t physAddress_t;
 /************************/
 /* memory access macros */
 /************************/
+#ifdef CONFIG_FMAN_ARM
+#define in_be16(a)		__be16_to_cpu(__raw_readw(a))
+#define in_be32(a)		__be32_to_cpu(__raw_readl(a))
+#define out_be16(a, v)		__raw_writew(__cpu_to_be16(v), a)
+#define out_be32(a, v)		__raw_writel(__cpu_to_be32(v), a)
+#endif
+
 #define GET_UINT8(arg)              *(volatile uint8_t *)(&(arg))
 #define GET_UINT16(arg)             in_be16(&(arg))//*(volatile uint16_t*)(&(arg))
 #define GET_UINT32(arg)             in_be32(&(arg))//*(volatile uint32_t*)(&(arg))
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
index 135e5bb..f21d2fd 100755
--- a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
@@ -59,8 +59,10 @@
 #include <asm/uaccess.h>
 #include <asm/errno.h>
 #include <linux/fsl/qe.h>        /* For struct qe_firmware */
+#ifndef CONFIG_FMAN_ARM
 #include <sysdev/fsl_soc.h>
 #include <linux/fsl/guts.h>
+#endif
 #include <linux/stat.h>	   /* For file access mask */
 #include <linux/skbuff.h>
 #include <linux/proc_fs.h>
@@ -504,6 +506,7 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
     struct resource     res;
     const uint32_t      *uint32_prop;
     int                 _errno=0, lenp;
+    uint32_t            tmp_prop;
 
     fm_node = of_node_get(of_dev->dev.of_node);
 
@@ -512,19 +515,22 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
         return NULL;
     }
+    tmp_prop = be32_to_cpu(*uint32_prop);
+
     if (WARN_ON(lenp != sizeof(uint32_t)))
         return NULL;
-    if (*uint32_prop > INTG_MAX_NUM_OF_FM) {
+
+    if (tmp_prop > INTG_MAX_NUM_OF_FM) {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
         return NULL;
     }
-    p_LnxWrpFmDev = CreateFmDev(*uint32_prop);
+    p_LnxWrpFmDev = CreateFmDev(tmp_prop);
     if (!p_LnxWrpFmDev) {
         REPORT_ERROR(MAJOR, E_NULL_POINTER, NO_MSG);
         return NULL;
     }
     p_LnxWrpFmDev->dev = &of_dev->dev;
-    p_LnxWrpFmDev->id = *uint32_prop;
+    p_LnxWrpFmDev->id = tmp_prop;
 
     /* Get the FM interrupt */
     p_LnxWrpFmDev->irq = of_irq_to_resource(fm_node, 0, NULL);
@@ -535,13 +541,11 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
 
     /* Get the FM error interrupt */
     p_LnxWrpFmDev->err_irq = of_irq_to_resource(fm_node, 1, NULL);
-    /* TODO - un-comment it once there will be err_irq in the DTS */
-#if 0
+
     if (unlikely(p_LnxWrpFmDev->err_irq == /*NO_IRQ*/0)) {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_irq_to_resource() = %d", NO_IRQ));
         return NULL;
     }
-#endif /* 0 */
 
     /* Get the FM address */
     _errno = of_address_to_resource(fm_node, 0, &res);
@@ -560,10 +564,11 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, clock-frequency) failed", fm_node->full_name));
         return NULL;
     }
+    tmp_prop = be32_to_cpu(*uint32_prop);
+
     if (WARN_ON(lenp != sizeof(uint32_t)))
         return NULL;
-    p_LnxWrpFmDev->fmDevSettings.param.fmClkFreq = (*uint32_prop + 500000)/1000000; /* In MHz, rounded */
-
+    p_LnxWrpFmDev->fmDevSettings.param.fmClkFreq = (tmp_prop + 500000)/1000000; /* In MHz, rounded */
     /* Get the MURAM base address and size */
     memset(&name, 0, sizeof(struct of_device_id));
     if (WARN_ON(strlen("muram") >= sizeof(name.name)))
@@ -583,6 +588,8 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
             p_LnxWrpFmDev->fmMuramBaseAddr = 0;
             p_LnxWrpFmDev->fmMuramPhysBaseAddr = res.start;
             p_LnxWrpFmDev->fmMuramMemSize = res.end + 1 - res.start;
+
+#ifndef CONFIG_FMAN_ARM
             {
                uint32_t svr;
                 svr = mfspr(SPRN_SVR);
@@ -590,6 +597,7 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
                 if ((svr & ~SVR_VER_IGNORE_MASK) >= SVR_B4860_REV2_VALUE)
                     p_LnxWrpFmDev->fmMuramMemSize = 0x80000;
             }
+#endif
         }
     }
 
@@ -706,6 +714,7 @@ struct device_node *GetFmAdvArgsDevTreeNode (uint8_t fmIndx)
     struct device_node  *dev_node;
     const uint32_t      *uint32_prop;
     int                 lenp;
+    uint32_t            tmp_prop;
 
     for_each_compatible_node(dev_node, NULL, "fsl,fman-extended-args") {
         uint32_prop = (uint32_t *)of_get_property(dev_node, "cell-index", &lenp);
@@ -715,13 +724,14 @@ struct device_node *GetFmAdvArgsDevTreeNode (uint8_t fmIndx)
                           dev_node->full_name));
             return NULL;
         }
+        tmp_prop = be32_to_cpu(*uint32_prop);
         if (WARN_ON(lenp != sizeof(uint32_t)))
             return NULL;
-        if (*uint32_prop > INTG_MAX_NUM_OF_FM) {
+        if (tmp_prop > INTG_MAX_NUM_OF_FM) {
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
             return NULL;
         }
-        if (fmIndx == *uint32_prop)
+        if (fmIndx == tmp_prop)
             return dev_node;
     }
 
@@ -735,6 +745,7 @@ static t_Error CheckNConfigFmAdvArgs (t_LnxWrpFmDev *p_LnxWrpFmDev)
     const uint32_t      *uint32_prop;
     const char          *str_prop;
     int                 lenp;
+    uint32_t            tmp_prop;
 
     dev_node = GetFmAdvArgsDevTreeNode(p_LnxWrpFmDev->id);
     if (!dev_node) /* no advance parameters for FMan */
@@ -754,22 +765,24 @@ static t_Error CheckNConfigFmAdvArgs (t_LnxWrpFmDev *p_LnxWrpFmDev)
 	uint32_prop = (uint32_t *)of_get_property(dev_node,
 						"total-fifo-size", &lenp);
 	if (uint32_prop) {
+		tmp_prop = be32_to_cpu(*uint32_prop);
 		if (WARN_ON(lenp != sizeof(uint32_t)))
 			RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
 
 		if (FM_ConfigTotalFifoSize(p_LnxWrpFmDev->h_Dev,
-				*uint32_prop) != E_OK)
+				tmp_prop) != E_OK)
 			RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
 	}
 
     uint32_prop = (uint32_t *)of_get_property(dev_node, "tnum-aging-period",
 	&lenp);
-    if (uint32_prop) {
-    	if (WARN_ON(lenp != sizeof(uint32_t)))
-            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+	if (uint32_prop) {
+		tmp_prop = be32_to_cpu(*uint32_prop);
+		if (WARN_ON(lenp != sizeof(uint32_t)))
+			RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
 
         err = FM_ConfigTnumAgingPeriod(p_LnxWrpFmDev->h_Dev,
-            (uint16_t)uint32_prop[0]/*tnumAgingPeriod*/);
+            (uint16_t)tmp_prop/*tnumAgingPeriod*/);
 
         if (err != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
@@ -894,6 +907,7 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     return FillRestFmInfo(p_LnxWrpFmDev);
 }
 
+#ifndef CONFIG_FMAN_ARM
 /*
  * Table for matching compatible strings, for device tree
  * guts node, for QorIQ SOCs.
@@ -926,6 +940,7 @@ static unsigned int get_rcwsr(int regnum)
 
 	return ioread32be(&guts_regs->rcwsr[regnum]);
 }
+#endif
 
 static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 {
@@ -946,15 +961,26 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code = NULL;
     } else {
         p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code =
-            (void *) fw + fw->microcode[0].code_offset;
+            (void *) fw + be32_to_cpu(fw->microcode[0].code_offset);
         p_LnxWrpFmDev->fmDevSettings.param.firmware.size =
-            sizeof(u32) * fw->microcode[0].count;
+            sizeof(u32) * be32_to_cpu(fw->microcode[0].count);
         DBG(INFO, ("Loading fman-controller code version %d.%d.%d",
                    fw->microcode[0].major,
                    fw->microcode[0].minor,
                    fw->microcode[0].revision));
     }
 
+#ifdef CONFIG_FMAN_ARM
+	{ /* endianness adjustments: byteswap the ucode retrieved from the f/w blob */
+		int i;
+		int usz = p_LnxWrpFmDev->fmDevSettings.param.firmware.size;
+		void * p_Code = p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code;
+
+		for(i=0; i < usz / 4; ++i)
+			((u32 *)p_Code)[i] = be32_to_cpu(((u32 *)p_Code)[i]);
+	}
+#endif
+
     p_LnxWrpFmDev->fmDevSettings.param.h_FmMuram = p_LnxWrpFmDev->h_MuramDev;
 
 #if (DPAA_VERSION >= 11)
@@ -965,6 +991,9 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     }
 #endif
 
+#ifdef CONFIG_FMAN_ARM
+    p_LnxWrpFmDev->fmDevSettings.param.fmMacClkRatio = 1;
+#else
     if(p_LnxWrpFmDev->fmDevSettings.param.fmId == 0)
         p_LnxWrpFmDev->fmDevSettings.param.fmMacClkRatio =
             !!(get_rcwsr(4) & 0x2); /* RCW[FM_MAC_RAT0] */
@@ -980,6 +1009,7 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         if ((svr & SVR_DEVICE_ID_MASK) == SVR_T4_DEVICE_ID)
             p_LnxWrpFmDev->fmDevSettings.param.fmMacClkRatio = 1;
     }
+#endif /* CONFIG_FMAN_ARM */
 
     if ((p_LnxWrpFmDev->h_Dev = FM_Config(&p_LnxWrpFmDev->fmDevSettings.param)) == NULL)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM"));
@@ -1197,7 +1227,6 @@ static int fm_soc_suspend(struct device *dev)
 	{
 #ifdef CONFIG_FSL_QORIQ_PM
 		device_set_wakeup_enable(p_LnxWrpFmDev->dev, 1);
-// TODO: 		fsl_set_power_except(dev->of_node?);
 #endif
 		err = FM_PORT_EnterDsarFinal(p_LnxWrpFmDev->h_DsarRxPort,
 			p_LnxWrpFmDev->h_DsarTxPort);
@@ -1214,7 +1243,6 @@ static int fm_soc_resume(struct device *dev)
 	if (p_LnxWrpFmDev->h_DsarRxPort)
 	{
 #ifdef CONFIG_FSL_QORIQ_PM
-// TODO		fsl_set_power_except(dev->of_node?);
 		device_set_wakeup_enable(p_LnxWrpFmDev->dev, 0);
 #endif
 		FM_PORT_ExitDsar(p_LnxWrpFmDev->h_DsarRxPort,
@@ -1380,8 +1408,8 @@ void fm_port_get_buff_layout_ext_params(struct fm_port *port, struct fm_port_par
        if (WARN_ON(lenp != sizeof(uint32_t)*2))
             return;
 
-        params->manip_extra_space = (uint8_t)uint32_prop[0];
-        params->data_align        = (uint16_t)uint32_prop[1];
+        params->manip_extra_space = (uint8_t)be32_to_cpu(uint32_prop[0]);
+        params->data_align        = (uint16_t)be32_to_cpu(uint32_prop[1]);
     }
 
     of_node_put(port_node);
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm_port.c
index 2cba7a5..56b0b40 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm_port.c
@@ -51,7 +51,10 @@
 #include <linux/cdev.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#ifndef CONFIG_FMAN_ARM
 #include <linux/fsl/svr.h>
+#endif
+#include <linux/io.h>
 
 #include "sprint_ext.h"
 #include "fm_common.h"
@@ -82,8 +85,10 @@ do {\
 	} \
 } while (0)
 
+#ifndef CONFIG_FMAN_ARM
 #define IS_T1023_T1024	(SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1024 || \
 			SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1023)
+#endif
 
 static volatile int hcFrmRcv/* = 0 */;
 static spinlock_t lock;
@@ -96,6 +101,31 @@ static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal *portal,
 	t_LnxWrpFmDev *p_LnxWrpFmDev = ((t_FmTestFq *) fq)->h_Arg;
 	unsigned long flags;
 
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+{
+	/* extract the HC frame address */
+	uint64_t hcf_va = XX_PhysToVirt(((struct qm_fd *)&dq->fd)->addr);
+	int hcf_l = ((struct qm_fd *)&dq->fd)->length20;
+	int i;
+
+	/* 32b byteswap of all data in the HC Frame */
+	for(i = 0; i < hcf_l / 4; ++i)
+		((uint32_t *)(hcf_va))[i] =
+			___constant_swab32(((uint32_t *)(hcf_va))[i]);
+}
+{
+	/* byteswap FD's 40bit address field LE to BE*/
+	uint8_t t;
+
+	t = ((uint8_t*)&dq->fd)[6];
+	((uint8_t*)&dq->fd)[6] = ((uint8_t*)&dq->fd)[5];
+	((uint8_t*)&dq->fd)[5] = ((uint8_t*)&dq->fd)[4];
+	((uint8_t*)&dq->fd)[4] = ((uint8_t*)&dq->fd)[3];
+	((uint8_t*)&dq->fd)[3] = ((uint8_t*)&dq->fd)[7];
+	((uint8_t*)&dq->fd)[7] = t;
+}
+
+#endif
 	FM_PCD_HcTxConf(p_LnxWrpFmDev->h_PcdDev, (t_DpaaFD *)&dq->fd);
 	spin_lock_irqsave(&lock, flags);
 	hcFrmRcv--;
@@ -207,6 +237,31 @@ static t_Error QmEnqueueCB(t_Handle h_Arg, void *p_Fd)
 	hcFrmRcv++;
 	spin_unlock_irqrestore(&lock, flags);
 
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+{
+	/* byteswap FD's 40bit address field */
+	uint8_t t;
+
+	t = ((uint8_t*)p_Fd)[7];
+	((uint8_t*)p_Fd)[7] = ((uint8_t*)p_Fd)[3];
+	((uint8_t*)p_Fd)[3] = ((uint8_t*)p_Fd)[4];
+	((uint8_t*)p_Fd)[4] = ((uint8_t*)p_Fd)[5];
+	((uint8_t*)p_Fd)[5] = ((uint8_t*)p_Fd)[6];
+	((uint8_t*)p_Fd)[6] = t;
+}
+{
+	/* extract the HC frame address */
+	uint64_t hcf_va = XX_PhysToVirt(((struct qm_fd *) p_Fd)->addr);
+	int hcf_l = ((struct qm_fd *)p_Fd)->length20;
+	int i;
+
+	/* 32b byteswap of all data in the HC Frame */
+	for(i = 0; i < hcf_l / 4; ++i)
+		((uint32_t *)(hcf_va))[i] =
+			___constant_swab32(((uint32_t *)(hcf_va))[i]);
+}
+#endif
+
 	_errno = qman_enqueue(p_LnxWrpFmDev->hc_tx_fq, (struct qm_fd *) p_Fd,
 			      0);
 	if (_errno)
@@ -236,6 +291,8 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 	struct resource res;
 	const uint32_t *uint32_prop;
 	int _errno = 0, lenp;
+	uint32_t tmp_prop;
+
 #ifdef CONFIG_FMAN_P1023
 	static unsigned char have_oh_port/* = 0 */;
 #endif
@@ -266,10 +323,11 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 			      port_node->full_name));
 		return NULL;
 	}
+	tmp_prop = be32_to_cpu(*uint32_prop);
 	if (WARN_ON(lenp != sizeof(uint32_t)))
 		return NULL;
 	if (of_device_is_compatible(port_node, "fsl,fman-port-oh")) {
-		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_OH_PORTS)) {
+		if (unlikely(tmp_prop >= FM_MAX_NUM_OF_OH_PORTS)) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
 				     ("of_get_property(%s, cell-index) failed",
 				      port_node->full_name));
@@ -285,7 +343,7 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 #else
 		/* Here it is hardcoded the use of the OH port 1
 		   (with cell-index 0) */
-		if (*uint32_prop == 0) {
+		if (tmp_prop == 0) {
 #endif
 			p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
 			p_LnxWrpFmPortDev->id = 0;
@@ -297,12 +355,12 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 				e_FM_PORT_TYPE_OH_HOST_COMMAND;
 		} else {
 			p_LnxWrpFmPortDev =
-				&p_LnxWrpFmDev->opPorts[*uint32_prop - 1];
-			p_LnxWrpFmPortDev->id = *uint32_prop - 1;
+				&p_LnxWrpFmDev->opPorts[tmp_prop - 1];
+			p_LnxWrpFmPortDev->id = tmp_prop- 1;
 			p_LnxWrpFmPortDev->settings.param.portType =
 				e_FM_PORT_TYPE_OH_OFFLINE_PARSING;
 		}
-		p_LnxWrpFmPortDev->settings.param.portId = *uint32_prop;
+		p_LnxWrpFmPortDev->settings.param.portId = tmp_prop;
 
 		uint32_prop =
 			(uint32_t *) of_get_property(port_node,
@@ -316,22 +374,23 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 					" for OH port.\n");
 			return NULL;
 		}
+		tmp_prop = be32_to_cpu(*uint32_prop);
 		if (WARN_ON(lenp != sizeof(uint32_t)))
 			return NULL;
-		p_LnxWrpFmPortDev->txCh = *uint32_prop;
+		p_LnxWrpFmPortDev->txCh = tmp_prop;
 
 		p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.
 			qmChannel = p_LnxWrpFmPortDev->txCh;
 	} else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-tx")) {
-		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_1G_TX_PORTS)) {
+		if (unlikely(tmp_prop >= FM_MAX_NUM_OF_1G_TX_PORTS)) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
 					("of_get_property(%s, cell-index) failed",
 					 port_node->full_name));
 			return NULL;
 		}
-		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop];
+		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[tmp_prop];
 
-		p_LnxWrpFmPortDev->id = *uint32_prop;
+		p_LnxWrpFmPortDev->id = tmp_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
 			p_LnxWrpFmPortDev->id;
 		p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_TX;
@@ -343,25 +402,28 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 					("missing fsl,qman-channel-id"));
 			return NULL;
 		}
+		tmp_prop = be32_to_cpu(*uint32_prop);
 		if (WARN_ON(lenp != sizeof(uint32_t)))
 			return NULL;
-		p_LnxWrpFmPortDev->txCh = *uint32_prop;
+		p_LnxWrpFmPortDev->txCh = tmp_prop;
 		p_LnxWrpFmPortDev->
 			settings.param.specificParams.nonRxParams.qmChannel =
 			p_LnxWrpFmPortDev->txCh;
 	} else if (of_device_is_compatible(port_node, "fsl,fman-port-10g-tx")) {
-		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_10G_TX_PORTS)) {
+		if (unlikely(tmp_prop>= FM_MAX_NUM_OF_10G_TX_PORTS)) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
 					("of_get_property(%s, cell-index) failed",
 					 port_node->full_name));
 			return NULL;
 		}
-		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop +
+		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[tmp_prop +
 			FM_MAX_NUM_OF_1G_TX_PORTS];
+#ifndef CONFIG_FMAN_ARM
 		if (IS_T1023_T1024)
 			p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop];
+#endif
 
-		p_LnxWrpFmPortDev->id = *uint32_prop;
+		p_LnxWrpFmPortDev->id = tmp_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
 			p_LnxWrpFmPortDev->id;
 		p_LnxWrpFmPortDev->settings.param.portType =
@@ -373,40 +435,43 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 					("missing fsl,qman-channel-id"));
 			return NULL;
 		}
+		tmp_prop = be32_to_cpu(*uint32_prop);
 		if (WARN_ON(lenp != sizeof(uint32_t)))
 			return NULL;
-		p_LnxWrpFmPortDev->txCh = *uint32_prop;
+		p_LnxWrpFmPortDev->txCh = tmp_prop;
 		p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.
 			qmChannel = p_LnxWrpFmPortDev->txCh;
 	} else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-rx")) {
-		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_1G_RX_PORTS)) {
+		if (unlikely(tmp_prop >= FM_MAX_NUM_OF_1G_RX_PORTS)) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
 					("of_get_property(%s, cell-index) failed",
 					 port_node->full_name));
 			return NULL;
 		}
-		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop];
+		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[tmp_prop];
 
-		p_LnxWrpFmPortDev->id = *uint32_prop;
+		p_LnxWrpFmPortDev->id = tmp_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
 			p_LnxWrpFmPortDev->id;
 		p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_RX;
 		if (p_LnxWrpFmDev->pcdActive)
 			p_LnxWrpFmPortDev->defPcd = p_LnxWrpFmDev->defPcd;
 	} else if (of_device_is_compatible(port_node, "fsl,fman-port-10g-rx")) {
-		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_10G_RX_PORTS)) {
+		if (unlikely(tmp_prop >= FM_MAX_NUM_OF_10G_RX_PORTS)) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
 					("of_get_property(%s, cell-index) failed",
 					 port_node->full_name));
 			return NULL;
 		}
-		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop +
+		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[tmp_prop +
 			FM_MAX_NUM_OF_1G_RX_PORTS];
 
+#ifndef CONFIG_FMAN_ARM
 		if (IS_T1023_T1024)
 			p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop];
+#endif
 
-		p_LnxWrpFmPortDev->id = *uint32_prop;
+		p_LnxWrpFmPortDev->id = tmp_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
 			p_LnxWrpFmPortDev->id;
 		p_LnxWrpFmPortDev->settings.param.portType =
@@ -454,6 +519,7 @@ struct device_node * GetFmPortAdvArgsDevTreeNode (struct device_node *fm_node,
     const uint32_t      *uint32_prop;
     int                 lenp;
     char                *portTypeString;
+    uint32_t            tmp_prop;
 
     switch(portType) {
         case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
@@ -483,9 +549,10 @@ struct device_node * GetFmPortAdvArgsDevTreeNode (struct device_node *fm_node,
                           port_node->full_name));
             return NULL;
         }
+        tmp_prop = be32_to_cpu(*uint32_prop);
         if (WARN_ON(lenp != sizeof(uint32_t)))
             return NULL;
-    	if ((portId == *uint32_prop) &&
+    	if ((portId == tmp_prop) &&
     	    (of_device_is_compatible(port_node, portTypeString))) {
             return port_node;
     	}
@@ -543,8 +610,8 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
     	if (WARN_ON(lenp != sizeof(uint32_t)*2))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
 
-        portRsrc.num   = uint32_prop[0];
-        portRsrc.extra = uint32_prop[1];
+        portRsrc.num   = be32_to_cpu(uint32_prop[0]);
+        portRsrc.extra = be32_to_cpu(uint32_prop[1]);
 
         if ((err = FM_PORT_ConfigNumOfTasks(p_LnxWrpFmPortDev->h_Dev,
                                             &portRsrc)) != E_OK)
@@ -556,8 +623,8 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
     	if (WARN_ON(lenp != sizeof(uint32_t)*2))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
 
-        portRsrc.num   = uint32_prop[0];
-        portRsrc.extra = uint32_prop[1];
+        portRsrc.num   = be32_to_cpu(uint32_prop[0]);
+        portRsrc.extra = be32_to_cpu(uint32_prop[1]);
 
         if ((err = FM_PORT_ConfigNumOfOpenDmas(p_LnxWrpFmPortDev->h_Dev,
                                             &portRsrc)) != E_OK)
@@ -569,8 +636,8 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
     	if (WARN_ON(lenp != sizeof(uint32_t)*2))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
 
-        portRsrc.num   = uint32_prop[0];
-        portRsrc.extra = uint32_prop[1];
+        portRsrc.num   = be32_to_cpu(uint32_prop[0]);
+        portRsrc.extra = be32_to_cpu(uint32_prop[1]);
 
         if ((err = FM_PORT_ConfigSizeOfFifo(p_LnxWrpFmPortDev->h_Dev,
                                             &portRsrc)) != E_OK)
@@ -582,7 +649,7 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
     	if (WARN_ON(lenp != sizeof(uint32_t)))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
         if ((err = FM_PORT_ConfigErrorsToDiscard(p_LnxWrpFmPortDev->h_Dev,
-                                                 uint32_prop[0])) != E_OK)
+                                                 be32_to_cpu(uint32_prop[0]))) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -602,33 +669,34 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         memset(&p_LnxWrpFmPortDev->dsar_table_sizes, 0, sizeof(struct auto_res_tables_sizes));
 
         p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_arp_entries        =
-		(uint16_t)uint32_prop[0];
+		(uint16_t)be32_to_cpu(uint32_prop[0]);
         p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_echo_ipv4_entries  =
-		(uint16_t)uint32_prop[1];
+		(uint16_t)be32_to_cpu(uint32_prop[1]);
         p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_ndp_entries        =
-		(uint16_t)uint32_prop[2];
+		(uint16_t)be32_to_cpu(uint32_prop[2]);
         p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_echo_ipv6_entries  =
-		(uint16_t)uint32_prop[3];
+		(uint16_t)be32_to_cpu(uint32_prop[3]);
         p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_snmp_ipv4_entries   =
-		(uint16_t)uint32_prop[4];
+		(uint16_t)be32_to_cpu(uint32_prop[4]);
         p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_snmp_ipv6_entries   =
-		(uint16_t)uint32_prop[5];
+		(uint16_t)be32_to_cpu(uint32_prop[5]);
         p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_snmp_oid_entries   =
-		(uint16_t)uint32_prop[6];
+		(uint16_t)be32_to_cpu(uint32_prop[6]);
         p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_snmp_char          =
-	(uint16_t)uint32_prop[7];
-        uint32_prop = (uint32_t *)of_get_property(port_node,
+		(uint16_t)be32_to_cpu(uint32_prop[7]);
+
+	uint32_prop = (uint32_t *)of_get_property(port_node,
 		"ar-filters-sizes", &lenp);
         if (uint32_prop) {
         	if (WARN_ON(lenp != sizeof(uint32_t)*3))
                 RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
          
             p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_ip_prot_filtering  =
-		(uint16_t)uint32_prop[0];
+		(uint16_t)be32_to_cpu(uint32_prop[0]);
             p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_tcp_port_filtering =
-		(uint16_t)uint32_prop[1];
+		(uint16_t)be32_to_cpu(uint32_prop[1]);
             p_LnxWrpFmPortDev->dsar_table_sizes.max_num_of_udp_port_filtering =
-		(uint16_t)uint32_prop[2];
+		(uint16_t)be32_to_cpu(uint32_prop[2]);
         }
         
         if ((err = FM_PORT_ConfigDsarSupport(p_LnxWrpFmPortDev->h_Dev,
@@ -682,8 +750,8 @@ static t_Error CheckNSetFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         memset(&portVSPAllocParams, 0, sizeof(portVSPAllocParams));
         memset(&fmVspParams, 0, sizeof(fmVspParams));
 
-        portVSPAllocParams.numOfProfiles = (uint8_t)uint32_prop[0];
-        portVSPAllocParams.dfltRelativeId = (uint8_t)uint32_prop[1];
+        portVSPAllocParams.numOfProfiles = (uint8_t)be32_to_cpu(uint32_prop[0]);
+        portVSPAllocParams.dfltRelativeId = (uint8_t)be32_to_cpu(uint32_prop[1]);
         fmVspParams.h_Fm = p_LnxWrpFmDev->h_Dev;
 
         fmVspParams.portParams.portType = p_LnxWrpFmPortDev->settings.param.portType;
@@ -694,7 +762,9 @@ static t_Error CheckNSetFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         {
             portId = fmVspParams.portParams.portId;
             if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G){
+#ifndef CONFIG_FMAN_ARM
 		if (!(IS_T1023_T1024))
+#endif
                     portId += FM_MAX_NUM_OF_1G_RX_PORTS;
 	    }
 	    portVSPAllocParams.h_FmTxPort =
@@ -814,6 +884,7 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 	}
 #endif  /* !FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
+#ifndef CONFIG_FMAN_ARM
 #ifdef FM_BCB_ERRATA_BMI_SW001
 /* Configure BCB workaround on Rx ports, only for B4860 rev1 */
 #define SVR_SECURITY_MASK    0x00080000
@@ -833,7 +904,7 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 			FM_PORT_ConfigBCBWorkaround(p_LnxWrpFmPortDev->h_Dev);
 	}
 #endif /* FM_BCB_ERRATA_BMI_SW001 */
-
+#endif /* CONFIG_FMAN_ARM */
 /* Call the driver's advanced configuration routines, if requested:
    Compare the function pointer of each entry to the available routines,
    and invoke the matching routine with proper casting of arguments. */
@@ -1270,6 +1341,7 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 		p_LnxWrpFmPortDev->minor =
 			p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_RX_PORTS +
 			DEV_FM_RX_PORTS_MINOR_BASE;
+#ifndef CONFIG_FMAN_ARM
 		if (IS_T1023_T1024) {
 			Sprint(p_LnxWrpFmPortDev->name, "%s-port-rx%d",
 				p_LnxWrpFmDev->name,
@@ -1278,6 +1350,7 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 				p_LnxWrpFmPortDev->id +
 				DEV_FM_RX_PORTS_MINOR_BASE;
 		}
+#endif
 	} else if (p_LnxWrpFmPortDev->settings.param.portType ==
 		 e_FM_PORT_TYPE_TX) {
 		Sprint(p_LnxWrpFmPortDev->name, "%s-port-tx%d",
@@ -1292,6 +1365,7 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 		p_LnxWrpFmPortDev->minor =
 			p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_TX_PORTS +
 			DEV_FM_TX_PORTS_MINOR_BASE;
+#ifndef CONFIG_FMAN_ARM
 		if (IS_T1023_T1024) {
 			Sprint(p_LnxWrpFmPortDev->name, "%s-port-tx%d",
 				p_LnxWrpFmDev->name,
@@ -1300,6 +1374,7 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 				p_LnxWrpFmPortDev->id +
 				DEV_FM_TX_PORTS_MINOR_BASE;
 		}
+#endif
 	} else if (p_LnxWrpFmPortDev->settings.param.portType ==
 		 e_FM_PORT_TYPE_OH_HOST_COMMAND) {
 		Sprint(p_LnxWrpFmPortDev->name, "%s-port-oh%d",
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_ioctls_fm.c
index 2476dfa..181ea19 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_ioctls_fm.c
@@ -59,8 +59,10 @@
 #include <linux/of_platform.h>
 #include <asm/uaccess.h>
 #include <asm/errno.h>
+#ifndef CONFIG_FMAN_ARM
 #include <sysdev/fsl_soc.h>
 #include <linux/fsl/svr.h>
+#endif
 
 #if defined(CONFIG_COMPAT)
 #include <linux/compat.h>
@@ -72,8 +74,10 @@
 #include "fm_port_ioctls.h"
 #include "fm_vsp_ext.h"
 
+#ifndef CONFIG_FMAN_ARM
 #define IS_T1023_T1024	(SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1024 || \
 			SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1023)
+#endif
 
 #define __ERR_MODULE__  MODULE_FM
 
@@ -345,10 +349,16 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_from_hdr_t) == sizeof(t_FmPcdFromHdr));
     ASSERT_COND(sizeof(ioc_fm_pcd_from_field_t) == sizeof(t_FmPcdFromField));
     ASSERT_COND(sizeof(ioc_fm_pcd_distinction_unit_t) == sizeof(t_FmPcdDistinctionUnit));
+
+#if defined(CONFIG_FMAN_ARM)
+    /* different alignment */
+    ASSERT_COND(sizeof(ioc_fm_pcd_net_env_params_t) == sizeof(t_FmPcdNetEnvParams) + sizeof(void *) + 4);
+#else
 #if !defined(CONFIG_COMPAT)
     /* different alignment */
     ASSERT_COND(sizeof(ioc_fm_pcd_net_env_params_t) == sizeof(t_FmPcdNetEnvParams) + sizeof(void *));
 #endif
+#endif
     ASSERT_COND(sizeof(ioc_fm_pcd_extract_entry_t) == sizeof(t_FmPcdExtractEntry));
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_extract_mask_t) == sizeof(t_FmPcdKgExtractMask));
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_extract_dflt_t) == sizeof(t_FmPcdKgExtractDflt));
@@ -403,6 +413,9 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     /*ioc_fm_pcd_cc_node_modify_key_params_t : private */
     /*ioc_fm_manip_hdr_info_t : private */
     /*ioc_fm_pcd_hash_table_set_t : private */
+#ifdef CONFIG_FMAN_ARM
+#warning "ls1043 temporary remove size validation"
+#else
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_ip_params_t) == sizeof(t_FmPcdManipFragIpParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_ip_params_t) == sizeof(t_FmPcdManipReassemIpParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_special_offload_ipsec_params_t) == sizeof(t_FmPcdManipSpecialOffloadIPSecParams));
@@ -433,7 +446,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_scheme_select_t) == sizeof(t_FmPcdKgSchemeSelect));
     ASSERT_COND(sizeof(ioc_fm_pcd_port_schemes_params_t) == sizeof(t_FmPcdPortSchemesParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_prs_start_t) == sizeof(t_FmPcdPrsStart));
-
+#endif
     return;
 }
 
@@ -1531,9 +1544,13 @@ Status: feature not supported
 
                     case (e_IOC_FM_PORT_TYPE_RX_10G):
                         if (port_params->port_id < FM_MAX_NUM_OF_10G_RX_PORTS) {
+#ifndef CONFIG_FMAN_ARM
                             if (IS_T1023_T1024) {
                                 h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id].h_Dev;
                             } else {
+#else
+                            {
+#endif
                                 h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
                             }
                             break;
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
index 1de4886..659676b 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -53,7 +53,9 @@
 #include <linux/ioport.h>
 #include <asm/uaccess.h>
 #include <asm/errno.h>
+#ifndef CONFIG_FMAN_ARM
 #include <sysdev/fsl_soc.h>
+#endif
 
 #include "part_ext.h"
 #include "fm_ioctls.h"
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/xx/Makefile b/drivers/net/ethernet/freescale/sdk_fman/src/xx/Makefile
index 1545c8b..90aa941 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/src/xx/Makefile
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/xx/Makefile
@@ -7,5 +7,12 @@ ccflags-y           += -DVERSION=\"\"
 include $(srctree)/drivers/net/ethernet/freescale/sdk_fman/ncsw_config.mk
 
 obj-y		+= fsl-ncsw-xx.o
-fsl-ncsw-xx-objs	:=   xx_linux.o udivdi3.o \
+
+ifneq ($(CONFIG_FMAN_ARM),y)
+fsl-ncsw-xx-objs	:=  xx_linux.o udivdi3.o \
+				module_strings.o
+else
+fsl-ncsw-xx-objs	:= xx_arm_linux.o udivdi3.o \
 				module_strings.o
+endif
+
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/xx/xx_arm_linux.c b/drivers/net/ethernet/freescale/sdk_fman/src/xx/xx_arm_linux.c
new file mode 100644
index 0000000..dd3e376
--- /dev/null
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/xx/xx_arm_linux.c
@@ -0,0 +1,905 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_arm_linux.c
+
+ @Description   XX routines implementation for Linux.
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/smp.h>
+#include <linux/of.h>
+#include <linux/irqdomain.h>
+
+#include <linux/workqueue.h>
+
+#ifdef BIGPHYSAREA_ENABLE
+#include <linux/bigphysarea.h>
+#endif /* BIGPHYSAREA_ENABLE */
+
+//#include <sysdev/fsl_soc.h>
+#include <asm/pgtable.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/atomic.h>
+#include <asm/string.h>
+#include <asm/byteorder.h>
+#include <asm/page.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "list_ext.h"
+#include "mm_ext.h"
+#include "sys_io_ext.h"
+#include "xx.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+#ifdef BIGPHYSAREA_ENABLE
+#define MAX_ALLOCATION_SIZE     128 * 1024 /* Maximum size allocated with kmalloc is 128K */
+
+
+/* TODO: large allocations => use big phys area */
+/******************************************************************************
+ * routine:     get_nr_pages
+ *
+ * description:
+ *     calculates the number of memory pages for a given size (in bytes)
+ *
+ * arguments:
+ *     size       - the number of bytes
+ *
+ * return code:
+ *     The number of pages
+ *
+ *****************************************************************************/
+static __inline__ uint32_t get_nr_pages (uint32_t size)
+{
+    return (uint32_t)((size >> PAGE_SHIFT) + (size & PAGE_SHIFT ? 1 : 0));
+}
+
+static bool in_big_phys_area (uint32_t addr)
+{
+    uint32_t base, size;
+
+    bigphysarea_get_details (&base, &size);
+    return ((addr >= base) && (addr < base + size));
+}
+#endif /* BIGPHYSAREA_ENABLE */
+
+void * xx_Malloc(uint32_t n)
+{
+    void        *a;
+    uint32_t    flags;
+
+    flags = XX_DisableAllIntr();
+#ifdef BIGPHYSAREA_ENABLE
+    if (n >= MAX_ALLOCATION_SIZE)
+        a = (void*)bigphysarea_alloc_pages(get_nr_pages(n), 0, GFP_ATOMIC);
+    else
+#endif /* BIGPHYSAREA_ENABLE */
+    a = (void *)kmalloc((uint32_t)n, GFP_ATOMIC);
+    if (!a)
+        XX_Print("No memory for XX_Malloc\n");
+    XX_RestoreAllIntr(flags);
+
+    return a;
+}
+
+void xx_Free(void *p)
+{
+#ifdef BIGPHYSAREA_ENABLE
+    if (in_big_phys_area ((uint32_t)p))
+        bigphysarea_free_pages(p);
+    else
+#endif /* BIGPHYSAREA_ENABLE */
+    kfree(p);
+}
+
+void XX_Exit(int status)
+{
+    WARN(1, "\n\nFMD: fatal error, driver can't go on!!!\n\n");
+}
+
+#define BUF_SIZE    512
+void XX_Print(char *str, ...)
+{
+    va_list args;
+#ifdef CONFIG_SMP
+    char buf[BUF_SIZE];
+#endif /* CONFIG_SMP */
+
+    va_start(args, str);
+#ifdef CONFIG_SMP
+    if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
+        printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
+    printk(KERN_CRIT "cpu %d: %s",  raw_smp_processor_id(), buf);
+#else
+    vprintk(str, args);
+#endif /* CONFIG_SMP */
+    va_end(args);
+}
+
+void XX_Fprint(void *file, char *str, ...)
+{
+    va_list args;
+#ifdef CONFIG_SMP
+    char buf[BUF_SIZE];
+#endif /* CONFIG_SMP */
+
+    va_start(args, str);
+#ifdef CONFIG_SMP
+    if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
+        printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
+    printk (KERN_CRIT "cpu %d: %s", smp_processor_id(), buf);
+
+#else
+    vprintk(str, args);
+#endif /* CONFIG_SMP */
+    va_end(args);
+}
+
+#ifdef DEBUG_XX_MALLOC
+typedef void (*t_ffn)(void *);
+typedef struct {
+    t_ffn       f_free;
+    void        *mem;
+    char        *fname;
+    int         fline;
+    uint32_t    size;
+    t_List      node;
+} t_MemDebug;
+#define MEMDBG_OBJECT(p_List) LIST_OBJECT(p_List, t_MemDebug, node)
+
+LIST(memDbgLst);
+
+
+void * XX_MallocDebug(uint32_t size, char *fname, int line)
+{
+    void       *mem;
+    t_MemDebug *p_MemDbg;
+
+    p_MemDbg = (t_MemDebug *)xx_Malloc(sizeof(t_MemDebug));
+    if (p_MemDbg == NULL)
+        return NULL;
+
+    mem = xx_Malloc(size);
+    if (mem == NULL)
+    {
+        XX_Free(p_MemDbg);
+        return NULL;
+    }
+
+    INIT_LIST(&p_MemDbg->node);
+    p_MemDbg->f_free = xx_Free;
+    p_MemDbg->mem    = mem;
+    p_MemDbg->fname  = fname;
+    p_MemDbg->fline  = line;
+    p_MemDbg->size   = size+sizeof(t_MemDebug);
+    LIST_AddToTail(&p_MemDbg->node, &memDbgLst);
+
+    return mem;
+}
+
+void * XX_MallocSmartDebug(uint32_t size,
+                           int      memPartitionId,
+                           uint32_t align,
+                           char     *fname,
+                           int      line)
+{
+    void       *mem;
+    t_MemDebug *p_MemDbg;
+
+    p_MemDbg = (t_MemDebug *)XX_Malloc(sizeof(t_MemDebug));
+    if (p_MemDbg == NULL)
+        return NULL;
+
+    mem = xx_MallocSmart((uint32_t)size, memPartitionId, align);
+    if (mem == NULL)
+    {
+        XX_Free(p_MemDbg);
+        return NULL;
+    }
+
+    INIT_LIST(&p_MemDbg->node);
+    p_MemDbg->f_free = xx_FreeSmart;
+    p_MemDbg->mem    = mem;
+    p_MemDbg->fname  = fname;
+    p_MemDbg->fline  = line;
+    p_MemDbg->size   = size+sizeof(t_MemDebug);
+    LIST_AddToTail(&p_MemDbg->node, &memDbgLst);
+
+    return mem;
+}
+
+static void debug_free(void *mem)
+{
+    t_List      *p_MemDbgLh = NULL;
+    t_MemDebug  *p_MemDbg;
+    bool        found = FALSE;
+
+    if (LIST_IsEmpty(&memDbgLst))
+    {
+        REPORT_ERROR(MAJOR, E_ALREADY_FREE, ("Unbalanced free (0x%08x)", mem));
+        return;
+    }
+
+    LIST_FOR_EACH(p_MemDbgLh, &memDbgLst)
+    {
+        p_MemDbg = MEMDBG_OBJECT(p_MemDbgLh);
+        if (p_MemDbg->mem == mem)
+        {
+            found = TRUE;
+            break;
+        }
+    }
+
+    if (!found)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_FOUND,
+                     ("Attempt to free unallocated address (0x%08x)",mem));
+        dump_stack();
+        return;
+    }
+
+    LIST_Del(p_MemDbgLh);
+    p_MemDbg->f_free(mem);
+    p_MemDbg->f_free(p_MemDbg);
+}
+
+void XX_FreeSmart(void *p)
+{
+    debug_free(p);
+}
+
+
+void XX_Free(void *p)
+{
+    debug_free(p);
+}
+
+#else /* not DEBUG_XX_MALLOC */
+void * XX_Malloc(uint32_t size)
+{
+    return xx_Malloc(size);
+}
+
+void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
+{
+    return xx_MallocSmart(size,memPartitionId, alignment);
+}
+
+void XX_FreeSmart(void *p)
+{
+    xx_FreeSmart(p);
+}
+
+
+void XX_Free(void *p)
+{
+    xx_Free(p);
+}
+#endif /* not DEBUG_XX_MALLOC */
+
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+void XX_EventById(uint32_t event, t_Handle appId, uint16_t flags, char *msg)
+{
+    e_Event eventCode = (e_Event)event;
+
+    UNUSED(eventCode);
+    UNUSED(appId);
+    UNUSED(flags);
+    UNUSED(msg);
+}
+#endif /* (defined(REPORT_EVENTS) && ... */
+
+
+uint32_t XX_DisableAllIntr(void)
+{
+    unsigned long flags;
+
+#ifdef local_irq_save_nort
+    local_irq_save_nort(flags);
+#else
+    local_irq_save(flags);
+#endif
+
+    return (uint32_t)flags;
+}
+
+void XX_RestoreAllIntr(uint32_t flags)
+{
+#ifdef local_irq_restore_nort
+    local_irq_restore_nort((unsigned long)flags);
+#else
+    local_irq_restore((unsigned long)flags);
+#endif
+}
+
+t_Error XX_Call( uint32_t qid, t_Error (* f)(t_Handle), t_Handle id, t_Handle appId, uint16_t flags )
+{
+    UNUSED(qid);
+    UNUSED(appId);
+    UNUSED(flags);
+
+    return f(id);
+}
+
+int XX_IsICacheEnable(void)
+{
+    return TRUE;
+}
+
+int XX_IsDCacheEnable(void)
+{
+    return TRUE;
+}
+
+
+typedef struct {
+    t_Isr       *f_Isr;
+    t_Handle    handle;
+} t_InterruptHandler;
+
+
+t_Handle interruptHandlers[0x00010000];
+
+static irqreturn_t LinuxInterruptHandler (int irq, void *dev_id)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+    return IRQ_HANDLED;
+}
+
+t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle)
+{
+    const char *device;
+    t_InterruptHandler *p_IntrHndl;
+
+    device = GetDeviceName(irq);
+    if (device == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Interrupt source - %d", irq));
+
+    p_IntrHndl = (t_InterruptHandler *)XX_Malloc(sizeof(t_InterruptHandler));
+    if (p_IntrHndl == NULL)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    p_IntrHndl->f_Isr = f_Isr;
+    p_IntrHndl->handle = handle;
+    interruptHandlers[irq] = p_IntrHndl;
+
+    if (request_irq(GetDeviceIrqNum(irq), LinuxInterruptHandler, 0, device, p_IntrHndl) < 0)
+        RETURN_ERROR(MAJOR, E_BUSY, ("Can't get IRQ %s\n", device));
+    disable_irq(GetDeviceIrqNum(irq));
+
+    return E_OK;
+}
+
+t_Error XX_FreeIntr(int irq)
+{
+    t_InterruptHandler *p_IntrHndl = interruptHandlers[irq];
+    free_irq(GetDeviceIrqNum(irq), p_IntrHndl);
+    XX_Free(p_IntrHndl);
+    interruptHandlers[irq] = 0;
+    return E_OK;
+}
+
+t_Error XX_EnableIntr(int irq)
+{
+    enable_irq(GetDeviceIrqNum(irq));
+    return E_OK;
+}
+
+t_Error XX_DisableIntr(int irq)
+{
+    disable_irq(GetDeviceIrqNum(irq));
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                       Tasklet Service Routines                            */
+/*****************************************************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+typedef struct
+{
+    t_Handle            h_Data;
+    void                (*f_Callback) (void *);
+    struct delayed_work dwork;
+} t_Tasklet;
+
+static void GenericTaskletCallback(struct work_struct *p_Work)
+{
+    t_Tasklet *p_Task = container_of(p_Work, t_Tasklet, dwork.work);
+
+    p_Task->f_Callback(p_Task->h_Data);
+}
+#endif    /* LINUX_VERSION_CODE */
+
+
+t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    struct work_struct *p_Task;
+    p_Task = (struct work_struct *)XX_Malloc(sizeof(struct work_struct));
+    INIT_WORK(p_Task, routine, data);
+#else
+    t_Tasklet *p_Task = (t_Tasklet *)XX_Malloc(sizeof(t_Tasklet));
+    p_Task->h_Data = data;
+    p_Task->f_Callback = routine;
+    INIT_DELAYED_WORK(&p_Task->dwork, GenericTaskletCallback);
+#endif    /* LINUX_VERSION_CODE */
+
+    return (t_TaskletHandle)p_Task;
+}
+
+
+void XX_FreeTasklet (t_TaskletHandle h_Tasklet)
+{
+    if (h_Tasklet)
+        XX_Free(h_Tasklet);
+}
+
+int XX_ScheduleTask(t_TaskletHandle h_Tasklet, int immediate)
+{
+    int ans;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    if (immediate)
+        ans = schedule_work(h_Tasklet);
+    else
+        ans = schedule_delayed_work(h_Tasklet, 1);
+#else
+    if (immediate)
+        ans = schedule_delayed_work(&((t_Tasklet *)h_Tasklet)->dwork, 0);
+    else
+        ans = schedule_delayed_work(&((t_Tasklet *)h_Tasklet)->dwork, HZ);
+#endif /* LINUX_VERSION_CODE */
+
+    return ans;
+}
+
+void XX_FlushScheduledTasks(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    flush_scheduled_tasks();
+#else
+    flush_scheduled_work();
+#endif    /* LINUX_VERSION_CODE */
+}
+
+int XX_TaskletIsQueued(t_TaskletHandle h_Tasklet)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    return (int)(((struct work_struct *)h_Tasklet)->pending);
+#else
+    return (int)delayed_work_pending(&((t_Tasklet *)h_Tasklet)->dwork);
+#endif    /* LINUX_VERSION_CODE */
+}
+
+void XX_SetTaskletData(t_TaskletHandle h_Tasklet, t_Handle data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    ((struct tq_struct *)h_Tasklet)->data = data;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    ((struct work_struct *)h_Tasklet)->data = data;
+#else
+    ((t_Tasklet *)h_Tasklet)->h_Data = data;
+#endif    /* LINUX_VERSION_CODE */
+}
+
+t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    return (t_Handle)(((struct work_struct *)h_Tasklet)->data);
+#else
+    return ((t_Tasklet *)h_Tasklet)->h_Data;
+#endif    /* LINUX_VERSION_CODE */
+}
+
+
+/*****************************************************************************/
+/*                         Spinlock Service Routines                         */
+/*****************************************************************************/
+
+t_Handle XX_InitSpinlock(void)
+{
+    spinlock_t *p_Spinlock = (spinlock_t *)XX_Malloc(sizeof(spinlock_t));
+    if (!p_Spinlock)
+        return NULL;
+
+    spin_lock_init(p_Spinlock);
+
+    return (t_Handle)p_Spinlock;
+}
+
+void XX_FreeSpinlock(t_Handle h_Spinlock)
+{
+    if (h_Spinlock)
+        XX_Free(h_Spinlock);
+}
+
+void XX_LockSpinlock(t_Handle h_Spinlock)
+{
+    spin_lock((spinlock_t *)h_Spinlock);
+}
+
+void XX_UnlockSpinlock(t_Handle h_Spinlock)
+{
+    spin_unlock((spinlock_t *)h_Spinlock);
+}
+
+uint32_t XX_LockIntrSpinlock(t_Handle h_Spinlock)
+{
+    unsigned long intrFlags;
+    spin_lock_irqsave((spinlock_t *)h_Spinlock, intrFlags);
+    return intrFlags;
+}
+
+void XX_UnlockIntrSpinlock(t_Handle h_Spinlock, uint32_t intrFlags)
+{
+     spin_unlock_irqrestore((spinlock_t *)h_Spinlock, (unsigned long)intrFlags);
+}
+
+
+/*****************************************************************************/
+/*                        Timers Service Routines                            */
+/*****************************************************************************/
+/* The time now is in mili sec. resolution */
+uint32_t XX_CurrentTime(void)
+{
+    return (jiffies*1000)/HZ;
+}
+
+
+t_Handle XX_CreateTimer(void)
+{
+    struct timer_list *p_Timer = (struct timer_list *)XX_Malloc(sizeof(struct timer_list));
+    if (p_Timer)
+    {
+        memset(p_Timer, 0, sizeof(struct timer_list));
+        init_timer(p_Timer);
+    }
+    return (t_Handle)p_Timer;
+}
+
+void XX_FreeTimer(t_Handle h_Timer)
+{
+    if (h_Timer)
+        XX_Free(h_Timer);
+}
+
+void XX_StartTimer(t_Handle h_Timer,
+                   uint32_t msecs,
+                   bool     periodic,
+                   void     (*f_TimerExpired)(t_Handle),
+                   t_Handle h_Arg)
+{
+    int                 tmp_jiffies = (msecs*HZ)/1000;
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    SANITY_CHECK_RETURN((periodic == FALSE), E_NOT_SUPPORTED);
+
+    p_Timer->function = (void (*)(unsigned long))f_TimerExpired;
+    p_Timer->data = (unsigned long)h_Arg;
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    p_Timer->expires = (jiffies + tmp_jiffies);
+
+    add_timer((struct timer_list *)h_Timer);
+}
+
+void XX_SetTimerData(t_Handle h_Timer, t_Handle data)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    p_Timer->data = (unsigned long)data;
+}
+
+t_Handle XX_GetTimerData(t_Handle h_Timer)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    return (t_Handle)p_Timer->data;
+}
+
+uint32_t   XX_GetExpirationTime(t_Handle h_Timer)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    return (uint32_t)p_Timer->expires;
+}
+
+void XX_StopTimer(t_Handle h_Timer)
+{
+    del_timer((struct timer_list *)h_Timer);
+}
+
+void XX_ModTimer(t_Handle h_Timer, uint32_t msecs)
+{
+    int tmp_jiffies = (msecs*HZ)/1000;
+
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    mod_timer((struct timer_list *)h_Timer, jiffies + tmp_jiffies);
+}
+
+int XX_TimerIsActive(t_Handle h_Timer)
+{
+  return timer_pending((struct timer_list *)h_Timer);
+}
+
+uint32_t XX_Sleep(uint32_t msecs)
+{
+    int tmp_jiffies = (msecs*HZ)/1000;
+
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    return schedule_timeout(tmp_jiffies);
+}
+
+/*BEWARE!!!!! UDelay routine is BUSY WAITTING!!!!!*/
+void XX_UDelay(uint32_t usecs)
+{
+    udelay(usecs);
+}
+
+/* TODO: verify that these are correct */
+#define MSG_BODY_SIZE       512
+typedef t_Error (t_MsgHandler) (t_Handle h_Mod, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+typedef void (t_MsgCompletionCB) (t_Handle h_Arg, uint8_t msgBody[MSG_BODY_SIZE]);
+t_Error XX_SendMessage(char                 *p_DestAddr,
+                       uint32_t             msgId,
+                       uint8_t              msgBody[MSG_BODY_SIZE],
+                       t_MsgCompletionCB    *f_CompletionCB,
+                       t_Handle             h_CBArg);
+
+typedef struct {
+    char            *p_Addr;
+    t_MsgHandler    *f_MsgHandlerCB;
+    t_Handle        h_Mod;
+    t_List          node;
+} t_MsgHndlr;
+#define MSG_HNDLR_OBJECT(ptr)  LIST_OBJECT(ptr, t_MsgHndlr, node)
+
+LIST(msgHndlrList);
+
+static void EnqueueMsgHndlr(t_MsgHndlr *p_MsgHndlr)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_MsgHndlr->node, &msgHndlrList);
+    XX_RestoreAllIntr(intFlags);
+}
+/* TODO: add this for multi-platform support
+static t_MsgHndlr * DequeueMsgHndlr(void)
+{
+    t_MsgHndlr *p_MsgHndlr = NULL;
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&msgHndlrList))
+    {
+        p_MsgHndlr = MSG_HNDLR_OBJECT(msgHndlrList.p_Next);
+        LIST_DelAndInit(&p_MsgHndlr->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_MsgHndlr;
+}
+*/
+static t_MsgHndlr * FindMsgHndlr(char *p_Addr)
+{
+    t_MsgHndlr  *p_MsgHndlr;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &msgHndlrList)
+    {
+        p_MsgHndlr = MSG_HNDLR_OBJECT(p_Pos);
+        if (strstr(p_MsgHndlr->p_Addr, p_Addr))
+            return p_MsgHndlr;
+    }
+
+    return NULL;
+}
+
+t_Error XX_RegisterMessageHandler   (char *p_Addr, t_MsgHandler *f_MsgHandlerCB, t_Handle h_Mod)
+{
+    t_MsgHndlr  *p_MsgHndlr;
+    uint32_t    len;
+
+    p_MsgHndlr = (t_MsgHndlr*)XX_Malloc(sizeof(t_MsgHndlr));
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("message handler object!!!"));
+    memset(p_MsgHndlr, 0, sizeof(t_MsgHndlr));
+
+    len = strlen(p_Addr);
+    p_MsgHndlr->p_Addr = (char*)XX_Malloc(len+1);
+    strncpy(p_MsgHndlr->p_Addr,p_Addr, (uint32_t)(len+1));
+
+    p_MsgHndlr->f_MsgHandlerCB = f_MsgHandlerCB;
+    p_MsgHndlr->h_Mod = h_Mod;
+    INIT_LIST(&p_MsgHndlr->node);
+    EnqueueMsgHndlr(p_MsgHndlr);
+
+    return E_OK;
+}
+
+t_Error XX_UnregisterMessageHandler (char *p_Addr)
+{
+    t_MsgHndlr *p_MsgHndlr = FindMsgHndlr(p_Addr);
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    LIST_Del(&p_MsgHndlr->node);
+    XX_Free(p_MsgHndlr->p_Addr);
+    XX_Free(p_MsgHndlr);
+
+    return E_OK;
+}
+
+t_Error XX_SendMessage(char                 *p_DestAddr,
+                       uint32_t             msgId,
+                       uint8_t              msgBody[MSG_BODY_SIZE],
+                       t_MsgCompletionCB    *f_CompletionCB,
+                       t_Handle             h_CBArg)
+{
+    t_Error     ans;
+    t_MsgHndlr  *p_MsgHndlr = FindMsgHndlr(p_DestAddr);
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    ans = p_MsgHndlr->f_MsgHandlerCB(p_MsgHndlr->h_Mod, msgId, msgBody);
+
+    if (f_CompletionCB)
+        f_CompletionCB(h_CBArg, msgBody);
+
+    return ans;
+}
+
+t_Error XX_IpcRegisterMsgHandler(char                   addr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                                 t_IpcMsgHandler        *f_MsgHandler,
+                                 t_Handle               h_Module,
+                                 uint32_t               replyLength)
+{
+    UNUSED(addr);UNUSED(f_MsgHandler);UNUSED(h_Module);UNUSED(replyLength);
+    return E_OK;
+}
+
+t_Error XX_IpcUnregisterMsgHandler(char addr[XX_IPC_MAX_ADDR_NAME_LENGTH])
+{
+    UNUSED(addr);
+    return E_OK;
+}
+
+
+t_Error XX_IpcSendMessage(t_Handle           h_Session,
+                          uint8_t            *p_Msg,
+                          uint32_t           msgLength,
+                          uint8_t            *p_Reply,
+                          uint32_t           *p_ReplyLength,
+                          t_IpcMsgCompletion *f_Completion,
+                          t_Handle           h_Arg)
+{
+    UNUSED(h_Session); UNUSED(p_Msg); UNUSED(msgLength); UNUSED(p_Reply);
+    UNUSED(p_ReplyLength); UNUSED(f_Completion); UNUSED(h_Arg);
+    return E_OK;
+}
+
+t_Handle XX_IpcInitSession(char destAddr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                           char srcAddr[XX_IPC_MAX_ADDR_NAME_LENGTH])
+{
+    UNUSED(destAddr); UNUSED(srcAddr);
+    return E_OK;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+int GetDeviceIrqNum(int irq)
+{
+    struct device_node  *iPar;
+    struct irq_domain   *irqHost;
+    uint32_t            hwIrq;
+
+    /* Get the interrupt controller */
+    iPar = of_find_node_by_name(NULL, "mpic");
+    hwIrq = 0;
+
+    ASSERT_COND(iPar != NULL);
+    /* Get the irq host */
+    irqHost = irq_find_host(iPar);
+    of_node_put(iPar);
+
+    /* Create irq mapping */
+    return irq_create_mapping(irqHost, hwIrq);
+}
+#else
+#error "kernel not supported!!!"
+#endif    /* LINUX_VERSION_CODE */
+
+void * XX_PhysToVirt(physAddress_t addr)
+{
+    return UINT_TO_PTR(SYS_PhysToVirt((uint64_t)addr));
+}
+
+physAddress_t XX_VirtToPhys(void * addr)
+{
+    return (physAddress_t)SYS_VirtToPhys(PTR_TO_UINT(addr));
+}
+
+void * xx_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
+{
+    uintptr_t   *returnCode, tmp;
+
+    if (alignment < sizeof(uintptr_t))
+        alignment = sizeof(uintptr_t);
+    size += alignment + sizeof(returnCode);
+    tmp = (uintptr_t)xx_Malloc(size);
+    if (tmp == 0)
+        return NULL;
+    returnCode = (uintptr_t*)((tmp + alignment + sizeof(returnCode)) & ~((uintptr_t)alignment - 1));
+    *(returnCode - 1) = tmp;
+
+    return (void*)returnCode;
+}
+
+void xx_FreeSmart(void *p)
+{
+    xx_Free((void*)(*((uintptr_t *)(p) - 1)));
+}
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/xx/xx_linux.c b/drivers/net/ethernet/freescale/sdk_fman/src/xx/xx_linux.c
index d5c639a..992757d 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/src/xx/xx_linux.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/xx/xx_linux.c
@@ -62,6 +62,9 @@
 #include <linux/proc_fs.h>
 #include <linux/smp.h>
 #include <linux/of.h>
+#ifdef CONFIG_FMAN_ARM
+#include <linux/irqdomain.h>
+#endif
 
 #include <linux/workqueue.h>
 
@@ -69,7 +72,9 @@
 #include <linux/bigphysarea.h>
 #endif /* BIGPHYSAREA_ENABLE */
 
+#ifndef CONFIG_FMAN_ARM
 #include <sysdev/fsl_soc.h>
+#endif
 #include <asm/pgtable.h>
 #include <asm/irq.h>
 #include <asm/bitops.h>
@@ -168,7 +173,7 @@ void XX_Print(char *str, ...)
 #ifdef CONFIG_SMP
     if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
         printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
-    printk(KERN_CRIT "cpu%d/%d: %s", get_hard_smp_processor_id(raw_smp_processor_id()), raw_smp_processor_id(), buf);
+    printk(KERN_CRIT "cpu%d/%d: %s", raw_smp_processor_id(), NR_CPUS, buf);
 #else
     vprintk(str, args);
 #endif /* CONFIG_SMP */
@@ -186,7 +191,7 @@ void XX_Fprint(void *file, char *str, ...)
 #ifdef CONFIG_SMP
     if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
         printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
-    printk (KERN_CRIT "cpu%d/%d: %s",hard_smp_processor_id(), smp_processor_id(), buf);
+    printk (KERN_CRIT "cpu%d/%d: %s", raw_smp_processor_id(), NR_CPUS, buf);
 
 #else
     vprintk(str, args);
@@ -400,10 +405,36 @@ typedef struct {
 
 t_Handle interruptHandlers[0x00010000];
 
+#ifdef CONFIG_FMAN_ARM
+static irqreturn_t LinuxInterruptHandler (int irq, void *dev_id)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+    return IRQ_HANDLED;
+}
+#endif
 
 t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle)
 {
-/* not used */
+#ifdef CONFIG_FMAN_ARM
+    const char *device;
+    t_InterruptHandler *p_IntrHndl;
+
+    device = GetDeviceName(irq);
+    if (device == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Interrupt source - %d", irq));
+
+    p_IntrHndl = (t_InterruptHandler *)XX_Malloc(sizeof(t_InterruptHandler));
+    if (p_IntrHndl == NULL)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    p_IntrHndl->f_Isr = f_Isr;
+    p_IntrHndl->handle = handle;
+    interruptHandlers[irq] = p_IntrHndl;
+
+    if (request_irq(GetDeviceIrqNum(irq), LinuxInterruptHandler, 0, device, p_IntrHndl) < 0)
+        RETURN_ERROR(MAJOR, E_BUSY, ("Can't get IRQ %s\n", device));
+    disable_irq(GetDeviceIrqNum(irq));
+#endif
     return E_OK;
 }
 
-- 
2.9.3

