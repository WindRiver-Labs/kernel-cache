From 5d7199e119d49d35f543d934ef8a79d0aa09afb9 Mon Sep 17 00:00:00 2001
From: Bogdan Purcareata <bogdan.purcareata@nxp.com>
Date: Wed, 21 Sep 2016 10:07:25 +0000
Subject: [PATCH 389/508] staging: fsl-dpaa2: ethernet: Use new firmware ABI

- update DPNI FLIB
- use new dpni attributes and options
- use new dpni_set_offload for RX/TX L3/L4 checksumming
- use dpni_set_buffer_layout
- use dpni_get/set_queue for configuring flows
- use dpni_set_taildrop
- use dpni_get_port_mac_addr for setting ether addr
  (untested, expecting bootloader support)
- use new dpni_add_fs_entry + filter frames support
- use new dpni statistics in ethtool
- add sysfs knob to reset firmware statistics

Signed-off-by: Alex Marginean <alexandru.marginean@nxp.com>
Signed-off-by: Bogdan Purcareata <bogdan.purcareata@nxp.com>
[Original patch taken from SDK-V2.0-1703]
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 .../staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.c |   32 +
 .../staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.h |    1 +
 drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c     |  361 +++---
 drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h     |   22 +-
 drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c |  104 +-
 drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h      |  893 ++++---------
 drivers/staging/fsl-dpaa2/ethernet/dpni.c          |  787 +++--------
 drivers/staging/fsl-dpaa2/ethernet/dpni.h          | 1408 ++++++++------------
 8 files changed, 1303 insertions(+), 2305 deletions(-)

diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.c b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.c
index c397983..b889984 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.c
@@ -229,6 +229,26 @@ static const struct file_operations dpaa2_dbg_reset_ops = {
 	.write = dpaa2_dbg_reset_write,
 };
 
+static ssize_t dpaa2_dbg_reset_mc_write(struct file *file,
+		const char __user *buf, size_t count, loff_t *offset)
+{
+	struct dpaa2_eth_priv *priv = file->private_data;
+	int err;
+
+	err = dpni_reset_statistics(priv->mc_io, 0, priv->mc_token);
+	if (err)
+		netdev_err(priv->net_dev, "dpni_reset_statistics() failed %d\n",
+				err);
+
+	return count;
+}
+
+static const struct file_operations dpaa2_dbg_reset_mc_ops = {
+	.open = simple_open,
+	.write = dpaa2_dbg_reset_mc_write,
+};
+
+
 void dpaa2_dbg_add(struct dpaa2_eth_priv *priv)
 {
 	if (!dpaa2_dbg_root)
@@ -278,8 +298,19 @@ void dpaa2_dbg_add(struct dpaa2_eth_priv *priv)
 		goto err_reset_stats;
 	}
 
+	/* reset MC stats */
+	priv->dbg.reset_mc_stats = debugfs_create_file("reset_mc_stats",
+						S_IWUSR, priv->dbg.dir, priv,
+						&dpaa2_dbg_reset_mc_ops);
+	if (!priv->dbg.reset_mc_stats) {
+		netdev_err(priv->net_dev, "debugfs_create_file() failed\n");
+		goto err_reset_mc_stats;
+	}
+
 	return;
 
+err_reset_mc_stats:
+	debugfs_remove(priv->dbg.reset_stats);
 err_reset_stats:
 	debugfs_remove(priv->dbg.ch_stats);
 err_ch_stats:
@@ -292,6 +323,7 @@ err_cpu_stats:
 
 void dpaa2_dbg_remove(struct dpaa2_eth_priv *priv)
 {
+	debugfs_remove(priv->dbg.reset_mc_stats);
 	debugfs_remove(priv->dbg.reset_stats);
 	debugfs_remove(priv->dbg.fq_stats);
 	debugfs_remove(priv->dbg.ch_stats);
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.h b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.h
index 7ba706c..b01342d 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth-debugfs.h
@@ -43,6 +43,7 @@ struct dpaa2_debugfs {
 	struct dentry *ch_stats;
 	struct dentry *cpu_stats;
 	struct dentry *reset_stats;
+	struct dentry *reset_mc_stats;
 };
 
 #ifdef CONFIG_FSL_DPAA2_ETH_DEBUGFS
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
index 0093e97..ed5b03b 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
@@ -633,7 +633,8 @@ static int dpaa2_eth_tx(struct sk_buff *skb, struct net_device *net_dev)
 	struct dpaa2_fd fd;
 	struct rtnl_link_stats64 *percpu_stats;
 	struct dpaa2_eth_drv_stats *percpu_extras;
-	u16 queue_mapping, flow_id;
+	struct dpaa2_eth_fq fq;
+	u16 queue_mapping;
 	int err, i;
 
 	percpu_stats = this_cpu_ptr(priv->percpu_stats);
@@ -683,11 +684,15 @@ static int dpaa2_eth_tx(struct sk_buff *skb, struct net_device *net_dev)
 	/* TxConf FQ selection primarily based on cpu affinity; this is
 	 * non-migratable context, so it's safe to call smp_processor_id().
 	 */
-	queue_mapping = smp_processor_id() % priv->dpni_attrs.max_senders;
-	flow_id = priv->fq[queue_mapping].flowid;
+	queue_mapping = smp_processor_id() % priv->dpni_attrs.num_queues;
+	fq = priv->fq[queue_mapping];
 	for (i = 0; i < (DPAA2_ETH_MAX_TX_QUEUES << 1); i++) {
 		err = dpaa2_io_service_enqueue_qd(NULL, priv->tx_qdid, 0,
-						  flow_id, &fd);
+				fq.tx_qdbin, &fd);
+		/* TODO: This doesn't work. Check on simulator.
+		 * err = dpaa2_io_service_enqueue_fq(NULL,
+		 *			priv->fq[0].fqid_tx, &fd);
+		 */
 		if (err != -EBUSY)
 			break;
 	}
@@ -740,19 +745,19 @@ static int set_rx_csum(struct dpaa2_eth_priv *priv, bool enable)
 {
 	int err;
 
-	err = dpni_set_l3_chksum_validation(priv->mc_io, 0, priv->mc_token,
-					    enable);
+	err = dpni_set_offload(priv->mc_io, 0, priv->mc_token,
+					    DPNI_OFF_RX_L3_CSUM, enable);
 	if (err) {
 		netdev_err(priv->net_dev,
-			   "dpni_set_l3_chksum_validation() failed\n");
+			   "dpni_set_offload() DPNI_OFF_RX_L3_CSUM failed\n");
 		return err;
 	}
 
-	err = dpni_set_l4_chksum_validation(priv->mc_io, 0, priv->mc_token,
-					    enable);
+	err = dpni_set_offload(priv->mc_io, 0, priv->mc_token,
+					    DPNI_OFF_RX_L4_CSUM, enable);
 	if (err) {
 		netdev_err(priv->net_dev,
-			   "dpni_set_l4_chksum_validation failed\n");
+			   "dpni_set_offload() DPNI_OFF_RX_L4_CSUM failed\n");
 		return err;
 	}
 
@@ -761,29 +766,22 @@ static int set_rx_csum(struct dpaa2_eth_priv *priv, bool enable)
 
 static int set_tx_csum(struct dpaa2_eth_priv *priv, bool enable)
 {
-	struct dpaa2_eth_fq *fq;
-	struct dpni_tx_flow_cfg tx_flow_cfg;
 	int err;
-	int i;
 
-	memset(&tx_flow_cfg, 0, sizeof(tx_flow_cfg));
-	tx_flow_cfg.options = DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN |
-			      DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN;
-	tx_flow_cfg.l3_chksum_gen = enable;
-	tx_flow_cfg.l4_chksum_gen = enable;
-
-	for (i = 0; i < priv->num_fqs; i++) {
-		fq = &priv->fq[i];
-		if (fq->type != DPAA2_TX_CONF_FQ)
-			continue;
+	err = dpni_set_offload(priv->mc_io, 0, priv->mc_token,
+					    DPNI_OFF_TX_L3_CSUM, enable);
+	if (err) {
+		netdev_err(priv->net_dev,
+			   "dpni_set_offload() DPNI_OFF_RX_L3_CSUM failed\n");
+		return err;
+	}
 
-		/* The Tx flowid is kept in the corresponding TxConf FQ. */
-		err = dpni_set_tx_flow(priv->mc_io, 0, priv->mc_token,
-				       &fq->flowid, &tx_flow_cfg);
-		if (err) {
-			netdev_err(priv->net_dev, "dpni_set_tx_flow failed\n");
-			return err;
-		}
+	err = dpni_set_offload(priv->mc_io, 0, priv->mc_token,
+					    DPNI_OFF_TX_L4_CSUM, enable);
+	if (err) {
+		netdev_err(priv->net_dev,
+			   "dpni_set_offload() DPNI_OFF_RX_L4_CSUM failed\n");
+		return err;
 	}
 
 	return 0;
@@ -1202,15 +1200,13 @@ static int dpaa2_eth_init(struct net_device *net_dev)
 	/* Capabilities listing */
 	supported |= IFF_LIVE_ADDR_CHANGE | IFF_PROMISC | IFF_ALLMULTI;
 
-	if (options & DPNI_OPT_UNICAST_FILTER)
-		supported |= IFF_UNICAST_FLT;
-	else
+	if (options & DPNI_OPT_NO_MAC_FILTER) {
 		not_supported |= IFF_UNICAST_FLT;
-
-	if (options & DPNI_OPT_MULTICAST_FILTER)
-		supported |= IFF_MULTICAST;
-	else
 		not_supported |= IFF_MULTICAST;
+	} else {
+		supported |= IFF_UNICAST_FLT;
+		supported |= IFF_MULTICAST;
+	}
 
 	net_dev->priv_flags |= supported;
 	net_dev->priv_flags &= ~not_supported;
@@ -1233,7 +1229,7 @@ static int dpaa2_eth_set_addr(struct net_device *net_dev, void *addr)
 
 	err = eth_mac_addr(net_dev, addr);
 	if (err < 0) {
-		dev_err(dev, "eth_mac_addr() failed with error %d\n", err);
+		dev_err(dev, "eth_mac_addr() failed (%d)\n", err);
 		return err;
 	}
 
@@ -1339,34 +1335,29 @@ static void dpaa2_eth_set_rx_mode(struct net_device *net_dev)
 	struct dpaa2_eth_priv *priv = netdev_priv(net_dev);
 	int uc_count = netdev_uc_count(net_dev);
 	int mc_count = netdev_mc_count(net_dev);
-	u8 max_uc = priv->dpni_attrs.max_unicast_filters;
-	u8 max_mc = priv->dpni_attrs.max_multicast_filters;
+	u8 max_mac = priv->dpni_attrs.mac_filter_entries;
 	u32 options = priv->dpni_attrs.options;
 	u16 mc_token = priv->mc_token;
 	struct fsl_mc_io *mc_io = priv->mc_io;
 	int err;
 
 	/* Basic sanity checks; these probably indicate a misconfiguration */
-	if (!(options & DPNI_OPT_UNICAST_FILTER) && max_uc != 0)
-		netdev_info(net_dev,
-			    "max_unicast_filters=%d, DPNI_OPT_UNICAST_FILTER option must be enabled\n",
-			    max_uc);
-	if (!(options & DPNI_OPT_MULTICAST_FILTER) && max_mc != 0)
+	if (options & DPNI_OPT_NO_MAC_FILTER && max_mac != 0)
 		netdev_info(net_dev,
-			    "max_multicast_filters=%d, DPNI_OPT_MULTICAST_FILTER option must be enabled\n",
-			    max_mc);
+			    "mac_filter_entries=%d, DPNI_OPT_NO_MAC_FILTER option must be disabled\n",
+			    max_mac);
 
 	/* Force promiscuous if the uc or mc counts exceed our capabilities. */
-	if (uc_count > max_uc) {
+	if (uc_count > max_mac) {
 		netdev_info(net_dev,
 			    "Unicast addr count reached %d, max allowed is %d; forcing promisc\n",
-			    uc_count, max_uc);
+			    uc_count, max_mac);
 		goto force_promisc;
 	}
-	if (mc_count > max_mc) {
+	if (mc_count + uc_count > max_mac) {
 		netdev_info(net_dev,
-			    "Multicast addr count reached %d, max allowed is %d; forcing promisc\n",
-			    mc_count, max_mc);
+			    "Unicast + Multicast addr count reached %d, max allowed is %d; forcing promisc\n",
+			    uc_count + mc_count, max_mac);
 		goto force_mc_promisc;
 	}
 
@@ -1785,18 +1776,15 @@ static void setup_fqs(struct dpaa2_eth_priv *priv)
 {
 	int i;
 
-	/* We have one TxConf FQ per Tx flow */
-	for (i = 0; i < priv->dpni_attrs.max_senders; i++) {
-		priv->fq[priv->num_fqs].type = DPAA2_TX_CONF_FQ;
-		priv->fq[priv->num_fqs].consume = dpaa2_eth_tx_conf;
-		priv->fq[priv->num_fqs++].flowid = DPNI_NEW_FLOW_ID;
-	}
-
-	/* The number of Rx queues (Rx distribution width) may be different from
-	 * the number of cores.
+	/* We have one TxConf FQ per Tx flow.
+	 * Number of Rx and Tx queues are the same.
 	 * We only support one traffic class for now.
 	 */
 	for (i = 0; i < dpaa2_eth_queue_count(priv); i++) {
+		priv->fq[priv->num_fqs].type = DPAA2_TX_CONF_FQ;
+		priv->fq[priv->num_fqs].consume = dpaa2_eth_tx_conf;
+		priv->fq[priv->num_fqs++].flowid = (u16)i;
+
 		priv->fq[priv->num_fqs].type = DPAA2_RX_FQ;
 		priv->fq[priv->num_fqs].consume = dpaa2_eth_rx;
 		priv->fq[priv->num_fqs++].flowid = (u16)i;
@@ -1881,7 +1869,6 @@ static int setup_dpni(struct fsl_mc_device *ls_dev)
 	struct device *dev = &ls_dev->dev;
 	struct dpaa2_eth_priv *priv;
 	struct net_device *net_dev;
-	void *dma_mem;
 	int err;
 
 	net_dev = dev_get_drvdata(dev);
@@ -1905,47 +1892,19 @@ static int setup_dpni(struct fsl_mc_device *ls_dev)
 		goto err_reset;
 	}
 
-	/* Map a memory region which will be used by MC to pass us an
-	 * attribute structure
-	 */
-	dma_mem = kzalloc(DPAA2_EXT_CFG_SIZE, GFP_DMA | GFP_KERNEL);
-	if (!dma_mem)
-		goto err_alloc;
-
-	priv->dpni_attrs.ext_cfg_iova = dma_map_single(dev, dma_mem,
-						       DPAA2_EXT_CFG_SIZE,
-						       DMA_FROM_DEVICE);
-	if (dma_mapping_error(dev, priv->dpni_attrs.ext_cfg_iova)) {
-		dev_err(dev, "dma mapping for dpni_ext_cfg failed\n");
-		goto err_dma_map;
-	}
-
 	err = dpni_get_attributes(priv->mc_io, 0, priv->mc_token,
 				  &priv->dpni_attrs);
 
-	/* We'll check the return code after unmapping, as we need to
-	 * do this anyway
-	 */
-	dma_unmap_single(dev, priv->dpni_attrs.ext_cfg_iova,
-			 DPAA2_EXT_CFG_SIZE, DMA_FROM_DEVICE);
-
 	if (err) {
 		dev_err(dev, "dpni_get_attributes() failed (err=%d)\n", err);
 		goto err_get_attr;
 	}
 
-	memset(&priv->dpni_ext_cfg, 0, sizeof(priv->dpni_ext_cfg));
-	err = dpni_extract_extended_cfg(&priv->dpni_ext_cfg, dma_mem);
-	if (err) {
-		dev_err(dev, "dpni_extract_extended_cfg() failed\n");
-		goto err_extract;
-	}
-
 	/* Configure our buffers' layout */
 	priv->buf_layout.options = DPNI_BUF_LAYOUT_OPT_PARSER_RESULT |
-				   DPNI_BUF_LAYOUT_OPT_FRAME_STATUS |
-				   DPNI_BUF_LAYOUT_OPT_PRIVATE_DATA_SIZE |
-				   DPNI_BUF_LAYOUT_OPT_DATA_ALIGN;
+					DPNI_BUF_LAYOUT_OPT_FRAME_STATUS |
+					DPNI_BUF_LAYOUT_OPT_PRIVATE_DATA_SIZE |
+					DPNI_BUF_LAYOUT_OPT_DATA_ALIGN;
 	priv->buf_layout.pass_parser_result = true;
 	priv->buf_layout.pass_frame_status = true;
 	priv->buf_layout.private_data_size = DPAA2_ETH_SWA_SIZE;
@@ -1953,38 +1912,47 @@ static int setup_dpni(struct fsl_mc_device *ls_dev)
 	priv->buf_layout.data_align = DPAA2_ETH_RX_BUF_ALIGN;
 
 	/* rx buffer */
-	err = dpni_set_rx_buffer_layout(priv->mc_io, 0, priv->mc_token,
-					&priv->buf_layout);
+	err = dpni_set_buffer_layout(priv->mc_io, 0, priv->mc_token,
+				DPNI_QUEUE_RX, &priv->buf_layout);
 	if (err) {
-		dev_err(dev, "dpni_set_rx_buffer_layout() failed");
+		dev_err(dev,
+		"dpni_set_buffer_layout() DPNI_QUEUE_RX failed (%d)\n",
+		err);
 		goto err_buf_layout;
 	}
+
 	/* tx buffer: remove Rx-only options */
 	priv->buf_layout.options &= ~(DPNI_BUF_LAYOUT_OPT_DATA_ALIGN |
-				      DPNI_BUF_LAYOUT_OPT_PARSER_RESULT);
-	err = dpni_set_tx_buffer_layout(priv->mc_io, 0, priv->mc_token,
-					&priv->buf_layout);
+					DPNI_BUF_LAYOUT_OPT_PARSER_RESULT);
+	err = dpni_set_buffer_layout(priv->mc_io, 0, priv->mc_token,
+				DPNI_QUEUE_TX, &priv->buf_layout);
 	if (err) {
-		dev_err(dev, "dpni_set_tx_buffer_layout() failed");
+		dev_err(dev,
+		"dpni_set_buffer_layout() DPNI_QUEUE_TX failed (%d)\n",
+		err);
 		goto err_buf_layout;
 	}
+
 	/* tx-confirm: same options as tx */
 	priv->buf_layout.options &= ~DPNI_BUF_LAYOUT_OPT_PRIVATE_DATA_SIZE;
 	priv->buf_layout.options |= DPNI_BUF_LAYOUT_OPT_TIMESTAMP;
 	priv->buf_layout.pass_timestamp = 1;
-	err = dpni_set_tx_conf_buffer_layout(priv->mc_io, 0, priv->mc_token,
-					     &priv->buf_layout);
+	err = dpni_set_buffer_layout(priv->mc_io, 0, priv->mc_token,
+				DPNI_QUEUE_TX_CONFIRM, &priv->buf_layout);
 	if (err) {
-		dev_err(dev, "dpni_set_tx_conf_buffer_layout() failed");
+		dev_err(dev,
+		"dpni_set_buffer_layout() DPNI_QUEUE_TX_CONFIRM failed (%d)\n",
+		err);
 		goto err_buf_layout;
 	}
+
 	/* Now that we've set our tx buffer layout, retrieve the minimum
 	 * required tx data offset.
 	 */
 	err = dpni_get_tx_data_offset(priv->mc_io, 0, priv->mc_token,
 				      &priv->tx_data_offset);
 	if (err) {
-		dev_err(dev, "dpni_get_tx_data_offset() failed\n");
+		dev_err(dev, "dpni_get_tx_data_offset() failed (%d)\n", err);
 		goto err_data_offset;
 	}
 
@@ -1997,22 +1965,16 @@ static int setup_dpni(struct fsl_mc_device *ls_dev)
 
 	/* allocate classification rule space */
 	priv->cls_rule = kzalloc(sizeof(*priv->cls_rule) *
-				 DPAA2_CLASSIFIER_ENTRY_COUNT, GFP_KERNEL);
+				 dpaa2_eth_fs_count(priv), GFP_KERNEL);
 	if (!priv->cls_rule)
 		goto err_cls_rule;
 
-	kfree(dma_mem);
-
 	return 0;
 
 err_cls_rule:
 err_data_offset:
 err_buf_layout:
-err_extract:
 err_get_attr:
-err_dma_map:
-	kfree(dma_mem);
-err_alloc:
 err_reset:
 	dpni_close(priv->mc_io, 0, priv->mc_token);
 err_open:
@@ -2035,33 +1997,40 @@ static int setup_rx_flow(struct dpaa2_eth_priv *priv,
 			 struct dpaa2_eth_fq *fq)
 {
 	struct device *dev = priv->net_dev->dev.parent;
-	struct dpni_queue_attr rx_queue_attr;
-	struct dpni_queue_cfg queue_cfg;
+	struct dpni_queue q = { { 0 } };
+	struct dpni_queue_id qid;
+	u8 q_opt = DPNI_QUEUE_OPT_USER_CTX | DPNI_QUEUE_OPT_DEST;
+	struct dpni_taildrop td;
 	int err;
 
-	memset(&queue_cfg, 0, sizeof(queue_cfg));
-	queue_cfg.options = DPNI_QUEUE_OPT_USER_CTX | DPNI_QUEUE_OPT_DEST |
-			    DPNI_QUEUE_OPT_TAILDROP_THRESHOLD;
-	queue_cfg.dest_cfg.dest_type = DPNI_DEST_DPCON;
-	queue_cfg.dest_cfg.priority = 1;
-	queue_cfg.user_ctx = (u64)fq;
-	queue_cfg.dest_cfg.dest_id = fq->channel->dpcon_id;
-	queue_cfg.tail_drop_threshold = DPAA2_ETH_TAILDROP_THRESH;
-	err = dpni_set_rx_flow(priv->mc_io, 0, priv->mc_token, 0, fq->flowid,
-			       &queue_cfg);
+	err = dpni_get_queue(priv->mc_io, 0, priv->mc_token,
+				     DPNI_QUEUE_RX, 0, fq->flowid, &q, &qid);
+	if (err) {
+		dev_err(dev, "dpni_get_queue() failed (%d)\n", err);
+		return err;
+	}
+
+	fq->fqid = qid.fqid;
+
+	q.destination.id = fq->channel->dpcon_id;
+	q.destination.type = DPNI_DEST_DPCON;
+	q.destination.priority = 1;
+	q.user_context = (u64)fq;
+	err = dpni_set_queue(priv->mc_io, 0, priv->mc_token,
+				     DPNI_QUEUE_RX, 0, fq->flowid, q_opt, &q);
 	if (err) {
-		dev_err(dev, "dpni_set_rx_flow() failed\n");
+		dev_err(dev, "dpni_set_queue() failed (%d)\n", err);
 		return err;
 	}
 
-	/* Get the actual FQID that was assigned by MC */
-	err = dpni_get_rx_flow(priv->mc_io, 0, priv->mc_token, 0, fq->flowid,
-			       &rx_queue_attr);
+	td.enable = 1;
+	td.threshold = DPAA2_ETH_TAILDROP_THRESH;
+	err = dpni_set_taildrop(priv->mc_io, 0, priv->mc_token, DPNI_CP_QUEUE,
+			DPNI_QUEUE_RX, 0, fq->flowid, &td);
 	if (err) {
-		dev_err(dev, "dpni_get_rx_flow() failed\n");
+		dev_err(dev, "dpni_set_taildrop() failed (%d)\n", err);
 		return err;
 	}
-	fq->fqid = rx_queue_attr.fqid;
 
 	return 0;
 }
@@ -2070,45 +2039,40 @@ static int setup_tx_flow(struct dpaa2_eth_priv *priv,
 			 struct dpaa2_eth_fq *fq)
 {
 	struct device *dev = priv->net_dev->dev.parent;
-	struct dpni_tx_flow_cfg tx_flow_cfg;
-	struct dpni_tx_conf_cfg tx_conf_cfg;
-	struct dpni_tx_conf_attr tx_conf_attr;
+	struct dpni_queue q = { { 0 } };
+	struct dpni_queue_id qid;
+	u8 q_opt = DPNI_QUEUE_OPT_USER_CTX | DPNI_QUEUE_OPT_DEST;
 	int err;
 
-	memset(&tx_flow_cfg, 0, sizeof(tx_flow_cfg));
-	tx_flow_cfg.options = DPNI_TX_FLOW_OPT_TX_CONF_ERROR;
-	tx_flow_cfg.use_common_tx_conf_queue = 0;
-	err = dpni_set_tx_flow(priv->mc_io, 0, priv->mc_token,
-			       &fq->flowid, &tx_flow_cfg);
+	err = dpni_get_queue(priv->mc_io, 0, priv->mc_token,
+				     DPNI_QUEUE_TX, 0, fq->flowid, &q, &qid);
 	if (err) {
-		dev_err(dev, "dpni_set_tx_flow() failed\n");
+		dev_err(dev, "dpni_get_queue() failed (%d)\n", err);
 		return err;
 	}
 
-	tx_conf_cfg.errors_only = 0;
-	tx_conf_cfg.queue_cfg.options = DPNI_QUEUE_OPT_USER_CTX |
-					DPNI_QUEUE_OPT_DEST;
-	tx_conf_cfg.queue_cfg.user_ctx = (u64)fq;
-	tx_conf_cfg.queue_cfg.dest_cfg.dest_type = DPNI_DEST_DPCON;
-	tx_conf_cfg.queue_cfg.dest_cfg.dest_id = fq->channel->dpcon_id;
-	tx_conf_cfg.queue_cfg.dest_cfg.priority = 0;
+	fq->tx_qdbin = qid.qdbin;
 
-	err = dpni_set_tx_conf(priv->mc_io, 0, priv->mc_token, fq->flowid,
-			       &tx_conf_cfg);
+	err = dpni_get_queue(priv->mc_io, 0, priv->mc_token,
+			DPNI_QUEUE_TX_CONFIRM, 0, fq->flowid, &q, &qid);
 	if (err) {
-		dev_err(dev, "dpni_set_tx_conf() failed\n");
+		dev_err(dev, "dpni_get_queue() failed (%d)\n", err);
 		return err;
 	}
 
-	err = dpni_get_tx_conf(priv->mc_io, 0, priv->mc_token, fq->flowid,
-			       &tx_conf_attr);
+	fq->fqid = qid.fqid;
+
+	q.destination.id = fq->channel->dpcon_id;
+	q.destination.type = DPNI_DEST_DPCON;
+	q.destination.priority = 0;
+	q.user_context = (u64)fq;
+	err = dpni_set_queue(priv->mc_io, 0, priv->mc_token,
+			DPNI_QUEUE_TX_CONFIRM, 0, fq->flowid, q_opt, &q);
 	if (err) {
-		dev_err(dev, "dpni_get_tx_conf() failed\n");
+		dev_err(dev, "dpni_get_queue() failed (%d)\n", err);
 		return err;
 	}
 
-	fq->fqid = tx_conf_attr.queue_attr.fqid;
-
 	return 0;
 }
 
@@ -2116,32 +2080,31 @@ static int setup_tx_flow(struct dpaa2_eth_priv *priv,
 static int setup_rx_err_flow(struct dpaa2_eth_priv *priv,
 			     struct dpaa2_eth_fq *fq)
 {
-	struct dpni_queue_attr queue_attr;
-	struct dpni_queue_cfg queue_cfg;
+	struct device *dev = priv->net_dev->dev.parent;
+	struct dpni_queue q = { { 0 } };
+	struct dpni_queue_id qid;
+	u8 q_opt = DPNI_QUEUE_OPT_USER_CTX | DPNI_QUEUE_OPT_DEST;
 	int err;
 
-	/* Configure the Rx error queue to generate CDANs,
-	 * just like the Rx queues
-	 */
-	queue_cfg.options = DPNI_QUEUE_OPT_USER_CTX | DPNI_QUEUE_OPT_DEST;
-	queue_cfg.dest_cfg.dest_type = DPNI_DEST_DPCON;
-	queue_cfg.dest_cfg.priority = 1;
-	queue_cfg.user_ctx = (u64)fq;
-	queue_cfg.dest_cfg.dest_id = fq->channel->dpcon_id;
-	err = dpni_set_rx_err_queue(priv->mc_io, 0, priv->mc_token, &queue_cfg);
+	err = dpni_get_queue(priv->mc_io, 0, priv->mc_token,
+			DPNI_QUEUE_RX_ERR, 0, 0, &q, &qid);
 	if (err) {
-		netdev_err(priv->net_dev, "dpni_set_rx_err_queue() failed\n");
+		dev_err(dev, "dpni_get_queue() failed (%d)\n", err);
 		return err;
 	}
 
-	/* Get the FQID */
-	err = dpni_get_rx_err_queue(priv->mc_io, 0, priv->mc_token,
-				    &queue_attr);
+	fq->fqid = qid.fqid;
+
+	q.destination.id = fq->channel->dpcon_id;
+	q.destination.type = DPNI_DEST_DPCON;
+	q.destination.priority = 1;
+	q.user_context = (u64)fq;
+	err = dpni_set_queue(priv->mc_io, 0, priv->mc_token,
+			DPNI_QUEUE_RX_ERR, 0, 0, q_opt, &q);
 	if (err) {
-		netdev_err(priv->net_dev, "dpni_get_rx_err_queue() failed\n");
+		dev_err(dev, "dpni_set_queue() failed (%d)\n", err);
 		return err;
 	}
-	fq->fqid = queue_attr.fqid;
 
 	return 0;
 }
@@ -2236,7 +2199,7 @@ int set_hash(struct dpaa2_eth_priv *priv)
 
 	err = dpni_prepare_key_cfg(&cls_cfg, dma_mem);
 	if (err) {
-		dev_err(dev, "dpni_prepare_key_cfg error %d", err);
+		dev_err(dev, "dpni_prepare_key_cfg() failed (%d)", err);
 		return err;
 	}
 
@@ -2265,7 +2228,7 @@ int set_hash(struct dpaa2_eth_priv *priv)
 			 DPAA2_CLASSIFIER_DMA_SIZE, DMA_TO_DEVICE);
 	kfree(dma_mem);
 	if (err) {
-		dev_err(dev, "dpni_set_rx_tc_dist() error %d\n", err);
+		dev_err(dev, "dpni_set_rx_tc_dist() failed (%d)\n", err);
 		return err;
 	}
 
@@ -2323,7 +2286,7 @@ static int bind_dpni(struct dpaa2_eth_priv *priv)
 	err = dpni_set_errors_behavior(priv->mc_io, 0, priv->mc_token,
 				       &err_cfg);
 	if (err) {
-		dev_err(dev, "dpni_set_errors_behavior failed\n");
+		dev_err(dev, "dpni_set_errors_behavior() failed (%d)\n", err);
 		return err;
 	}
 
@@ -2349,7 +2312,8 @@ static int bind_dpni(struct dpaa2_eth_priv *priv)
 			return err;
 	}
 
-	err = dpni_get_qdid(priv->mc_io, 0, priv->mc_token, &priv->tx_qdid);
+	err = dpni_get_qdid(priv->mc_io, 0, priv->mc_token, DPNI_QUEUE_TX,
+				     &priv->tx_qdid);
 	if (err) {
 		dev_err(dev, "dpni_get_qdid() failed\n");
 		return err;
@@ -2399,31 +2363,53 @@ static int netdev_init(struct net_device *net_dev)
 	int err;
 	struct device *dev = net_dev->dev.parent;
 	struct dpaa2_eth_priv *priv = netdev_priv(net_dev);
-	u8 mac_addr[ETH_ALEN];
+	u8 mac_addr[ETH_ALEN], dpni_mac_addr[ETH_ALEN];
 	u8 bcast_addr[ETH_ALEN];
 
 	net_dev->netdev_ops = &dpaa2_eth_ops;
 
-	/* If the DPNI attributes contain an all-0 mac_addr,
-	 * set a random hardware address
-	 */
+	/* Get firmware address, if any */
+	err = dpni_get_port_mac_addr(priv->mc_io, 0, priv->mc_token, mac_addr);
+	if (err) {
+		dev_err(dev, "dpni_get_port_mac_addr() failed (%d)\n", err);
+		return err;
+	}
+
+	/* Get DPNI atttributes address, if any */
 	err = dpni_get_primary_mac_addr(priv->mc_io, 0, priv->mc_token,
-					mac_addr);
+					dpni_mac_addr);
 	if (err) {
-		dev_err(dev, "dpni_get_primary_mac_addr() failed (%d)", err);
+		dev_err(dev, "dpni_get_primary_mac_addr() failed (%d)\n", err);
 		return err;
 	}
-	if (is_zero_ether_addr(mac_addr)) {
+
+	/* First check if firmware has any address configured by bootloader */
+	if (!is_zero_ether_addr(mac_addr)) {
+		/* If the DPMAC addr != the DPNI addr, update it */
+		if (!ether_addr_equal(mac_addr, dpni_mac_addr)) {
+			err = dpni_set_primary_mac_addr(priv->mc_io, 0,
+						     priv->mc_token, mac_addr);
+			if (err) {
+				dev_err(dev,
+				"dpni_set_primary_mac_addr() failed (%d)\n",
+				err);
+				return err;
+			}
+		}
+		memcpy(net_dev->dev_addr, mac_addr, net_dev->addr_len);
+	} else if (is_zero_ether_addr(dpni_mac_addr)) {
 		/* Fills in net_dev->dev_addr, as required by
 		 * register_netdevice()
 		 */
 		eth_hw_addr_random(net_dev);
 		/* Make the user aware, without cluttering the boot log */
-		pr_info_once(KBUILD_MODNAME " device(s) have all-zero hwaddr, replaced with random");
-		err = dpni_set_primary_mac_addr(priv->mc_io, 0, priv->mc_token,
-						net_dev->dev_addr);
+		pr_info_once(KBUILD_MODNAME
+			" device(s) have zero hwaddr, replaced with random");
+		err = dpni_set_primary_mac_addr(priv->mc_io, 0,
+					     priv->mc_token, net_dev->dev_addr);
 		if (err) {
-			dev_err(dev, "dpni_set_primary_mac_addr(): %d\n", err);
+			dev_err(dev,
+			"dpni_set_primary_mac_addr() failed  (%d)\n", err);
 			return err;
 		}
 		/* Override NET_ADDR_RANDOM set by eth_hw_addr_random(); for all
@@ -2432,11 +2418,12 @@ static int netdev_init(struct net_device *net_dev)
 		 * register_netdevice() to properly fill up net_dev->perm_addr.
 		 */
 		net_dev->addr_assign_type = NET_ADDR_PERM;
+	/* If DPMAC address is non-zero, use that one */
 	} else {
 		/* NET_ADDR_PERM is default, all we have to do is
 		 * fill in the device addr.
 		 */
-		memcpy(net_dev->dev_addr, mac_addr, net_dev->addr_len);
+		memcpy(net_dev->dev_addr, dpni_mac_addr, net_dev->addr_len);
 	}
 
 	/* Explicitly add the broadcast address to the MAC filtering table;
@@ -2457,7 +2444,7 @@ static int netdev_init(struct net_device *net_dev)
 	/* Our .ndo_init will be called herein */
 	err = register_netdev(net_dev);
 	if (err < 0) {
-		dev_err(dev, "register_netdev() = %d\n", err);
+		dev_err(dev, "register_netdev() failed (%d)\n", err);
 		return err;
 	}
 
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h
index bdcdbd6..3bd5937 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h
@@ -255,6 +255,7 @@ struct dpaa2_eth_priv;
 
 struct dpaa2_eth_fq {
 	u32 fqid;
+	u32 tx_qdbin;
 	u16 flowid;
 	int target_cpu;
 	struct dpaa2_eth_channel *channel;
@@ -305,7 +306,6 @@ struct dpaa2_eth_priv {
 
 	int dpni_id;
 	struct dpni_attr dpni_attrs;
-	struct dpni_extended_cfg dpni_ext_cfg;
 	/* Insofar as the MC is concerned, we're using one layout on all 3 types
 	 * of buffers (Rx, Tx, Tx-Conf).
 	 */
@@ -356,18 +356,16 @@ struct dpaa2_eth_priv {
 };
 
 #define dpaa2_eth_hash_enabled(priv)	\
-	((priv)->dpni_attrs.options & DPNI_OPT_DIST_HASH)
+	((priv)->dpni_attrs.num_queues > 1)
 
 #define dpaa2_eth_fs_enabled(priv)	\
-	((priv)->dpni_attrs.options & DPNI_OPT_DIST_FS)
+	(!((priv)->dpni_attrs.options & DPNI_OPT_NO_FS))
 
 #define dpaa2_eth_fs_mask_enabled(priv)	\
-	((priv)->dpni_attrs.options & DPNI_OPT_FS_MASK_SUPPORT)
+	((priv)->dpni_attrs.options & DPNI_OPT_HAS_KEY_MASKING)
 
-#define DPAA2_CLASSIFIER_ENTRY_COUNT 16
-
-/* Required by struct dpni_attr::ext_cfg_iova */
-#define DPAA2_EXT_CFG_SIZE	256
+#define dpaa2_eth_fs_count(priv)	\
+	((priv)->dpni_attrs.fs_entries)
 
 /* size of DMA memory used to pass configuration to classifier, in bytes */
 #define DPAA2_CLASSIFIER_DMA_SIZE 256
@@ -376,10 +374,7 @@ extern const struct ethtool_ops dpaa2_ethtool_ops;
 
 static int dpaa2_eth_queue_count(struct dpaa2_eth_priv *priv)
 {
-	if (!dpaa2_eth_hash_enabled(priv))
-		return 1;
-
-	return priv->dpni_ext_cfg.tc_cfg[0].max_dist;
+	return priv->dpni_attrs.num_queues;
 }
 
 static inline int dpaa2_eth_max_channels(struct dpaa2_eth_priv *priv)
@@ -388,8 +383,7 @@ static inline int dpaa2_eth_max_channels(struct dpaa2_eth_priv *priv)
 	 * to accommodate both the Rx distribution size
 	 * and the max number of Tx confirmation queues
 	 */
-	return max_t(int, dpaa2_eth_queue_count(priv),
-		     priv->dpni_attrs.max_senders);
+	return dpaa2_eth_queue_count(priv);
 }
 
 void check_cls_support(struct dpaa2_eth_priv *priv);
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c
index 1d792cd..ff03a01 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-ethtool.c
@@ -32,22 +32,25 @@
 #include "dpni.h"	/* DPNI_LINK_OPT_* */
 #include "dpaa2-eth.h"
 
-/* To be kept in sync with 'enum dpni_counter' */
+/* To be kept in sync with dpni_statistics */
 char dpaa2_ethtool_stats[][ETH_GSTRING_LEN] = {
 	"rx frames",
 	"rx bytes",
-	/* rx frames filtered/policed */
-	"rx filtered frames",
-	/* rx frames dropped with errors */
-	"rx discarded frames",
 	"rx mcast frames",
 	"rx mcast bytes",
 	"rx bcast frames",
 	"rx bcast bytes",
 	"tx frames",
 	"tx bytes",
-	/* tx frames dropped with errors */
+	"tx mcast frames",
+	"tx mcast bytes",
+	"tx bcast frames",
+	"tx bcast bytes",
+	"rx filtered frames",
+	"rx discarded frames",
+	"rx nobuffer discards",
 	"tx discarded frames",
+	"tx confirmed frames",
 };
 
 #define DPAA2_ETH_NUM_STATS	ARRAY_SIZE(dpaa2_ethtool_stats)
@@ -195,8 +198,9 @@ static void dpaa2_eth_get_ethtool_stats(struct net_device *net_dev,
 					struct ethtool_stats *stats,
 					u64 *data)
 {
-	int i; /* Current index in the data array */
+	int i = 0; /* Current index in the data array */
 	int j, k, err;
+	union dpni_statistics dpni_stats;
 
 #ifdef CONFIG_FSL_QBMAN_DEBUG
 	u32 fcnt, bcnt;
@@ -214,12 +218,40 @@ static void dpaa2_eth_get_ethtool_stats(struct net_device *net_dev,
 	       sizeof(u64) * (DPAA2_ETH_NUM_STATS + DPAA2_ETH_NUM_EXTRA_STATS));
 
 	/* Print standard counters, from DPNI statistics */
-	for (i = 0; i < DPAA2_ETH_NUM_STATS; i++) {
-		err = dpni_get_counter(priv->mc_io, 0, priv->mc_token, i,
-				       data + i);
+	for (j = 0; j <= 2; j++) {
+		err = dpni_get_statistics(priv->mc_io, 0, priv->mc_token,
+					     j, &dpni_stats);
 		if (err != 0)
-			netdev_warn(net_dev, "Err %d getting DPNI counter %d",
-				    err, i);
+			netdev_warn(net_dev, "Err %d getting DPNI stats page %d",
+				    err, j);
+
+		switch (j) {
+		case 0:
+		*(data + i++) = dpni_stats.page_0.ingress_all_frames;
+		*(data + i++) = dpni_stats.page_0.ingress_all_bytes;
+		*(data + i++) = dpni_stats.page_0.ingress_multicast_frames;
+		*(data + i++) = dpni_stats.page_0.ingress_multicast_bytes;
+		*(data + i++) = dpni_stats.page_0.ingress_broadcast_frames;
+		*(data + i++) = dpni_stats.page_0.ingress_broadcast_bytes;
+		break;
+		case 1:
+		*(data + i++) = dpni_stats.page_1.egress_all_frames;
+		*(data + i++) = dpni_stats.page_1.egress_all_bytes;
+		*(data + i++) = dpni_stats.page_1.egress_multicast_frames;
+		*(data + i++) = dpni_stats.page_1.egress_multicast_bytes;
+		*(data + i++) = dpni_stats.page_1.egress_broadcast_frames;
+		*(data + i++) = dpni_stats.page_1.egress_broadcast_bytes;
+		break;
+		case 2:
+		*(data + i++) = dpni_stats.page_2.ingress_filtered_frames;
+		*(data + i++) = dpni_stats.page_2.ingress_discarded_frames;
+		*(data + i++) = dpni_stats.page_2.ingress_nobuffer_discards;
+		*(data + i++) = dpni_stats.page_2.egress_discarded_frames;
+		*(data + i++) = dpni_stats.page_2.egress_confirmed_frames;
+		break;
+		default:
+		break;
+		}
 	}
 
 	/* Print per-cpu extra stats */
@@ -260,6 +292,7 @@ static void dpaa2_eth_get_ethtool_stats(struct net_device *net_dev,
 			bcnt_rx_total += bcnt;
 		}
 	}
+
 	*(data + i++) = fcnt_rx_total;
 	*(data + i++) = bcnt_rx_total;
 	*(data + i++) = fcnt_tx_total;
@@ -304,37 +337,36 @@ void check_cls_support(struct dpaa2_eth_priv *priv)
 	struct device *dev = priv->net_dev->dev.parent;
 
 	if (dpaa2_eth_hash_enabled(priv)) {
-		if (priv->dpni_attrs.max_dist_key_size < key_size) {
-			dev_dbg(dev, "max_dist_key_size = %d, expected %d. Hashing and steering are disabled\n",
-				priv->dpni_attrs.max_dist_key_size,
+		if (priv->dpni_attrs.fs_key_size < key_size) {
+			dev_info(dev, "max_dist_key_size = %d, expected %d. Hashing and steering are disabled\n",
+				priv->dpni_attrs.fs_key_size,
 				key_size);
-			goto disable_cls;
+			goto disable_fs;
 		}
 		if (priv->num_hash_fields > DPKG_MAX_NUM_OF_EXTRACTS) {
-			dev_dbg(dev, "Too many key fields (max = %d). Hashing and steering are disabled\n",
+			dev_info(dev, "Too many key fields (max = %d). Hashing and steering are disabled\n",
 				DPKG_MAX_NUM_OF_EXTRACTS);
-			goto disable_cls;
+			goto disable_fs;
 		}
 	}
 
 	if (dpaa2_eth_fs_enabled(priv)) {
 		if (!dpaa2_eth_hash_enabled(priv)) {
-			dev_dbg(dev, "DPNI_OPT_DIST_HASH option missing. Steering is disabled\n");
-			goto disable_cls;
+			dev_info(dev, "Insufficient queues. Steering is disabled\n");
+			goto disable_fs;
 		}
+
 		if (!dpaa2_eth_fs_mask_enabled(priv)) {
-			dev_dbg(dev, "Key masks not supported. Steering is disabled\n");
+			dev_info(dev, "Key masks not supported. Steering is disabled\n");
 			goto disable_fs;
 		}
 	}
 
 	return;
 
-disable_cls:
-	priv->dpni_attrs.options &= ~DPNI_OPT_DIST_HASH;
 disable_fs:
-	priv->dpni_attrs.options &= ~(DPNI_OPT_DIST_FS |
-				      DPNI_OPT_FS_MASK_SUPPORT);
+	priv->dpni_attrs.options |= DPNI_OPT_NO_FS;
+	priv->dpni_attrs.options &= ~DPNI_OPT_HAS_KEY_MASKING;
 }
 
 static int prep_l4_rule(struct dpaa2_eth_priv *priv,
@@ -558,8 +590,9 @@ static int do_cls(struct net_device *net_dev,
 {
 	struct dpaa2_eth_priv *priv = netdev_priv(net_dev);
 	struct device *dev = net_dev->dev.parent;
-	const int rule_cnt = DPAA2_CLASSIFIER_ENTRY_COUNT;
+	const int rule_cnt = dpaa2_eth_fs_count(priv);
 	struct dpni_rule_cfg rule_cfg;
+	struct dpni_fs_action_cfg fs_act = { 0 };
 	void *dma_mem;
 	int err = 0;
 
@@ -592,13 +625,17 @@ static int do_cls(struct net_device *net_dev,
 
 	rule_cfg.mask_iova = rule_cfg.key_iova + rule_cfg.key_size;
 
-	/* No way to control rule order in firmware */
+	if (fs->ring_cookie == RX_CLS_FLOW_DISC)
+		fs_act.options |= DPNI_FS_OPT_DISCARD;
+	else
+		fs_act.flow_id = fs->ring_cookie;
+
 	if (add)
-		err = dpni_add_fs_entry(priv->mc_io, 0, priv->mc_token, 0,
-					&rule_cfg, (u16)fs->ring_cookie);
+		err = dpni_add_fs_entry(priv->mc_io, 0, priv->mc_token,
+				0, fs->location, &rule_cfg, &fs_act);
 	else
-		err = dpni_remove_fs_entry(priv->mc_io, 0, priv->mc_token, 0,
-					   &rule_cfg);
+		err = dpni_remove_fs_entry(priv->mc_io, 0, priv->mc_token,
+				0, &rule_cfg);
 
 	dma_unmap_single(dev, rule_cfg.key_iova,
 			 rule_cfg.key_size * 2, DMA_TO_DEVICE);
@@ -607,8 +644,7 @@ static int do_cls(struct net_device *net_dev,
 		goto err_free_mem;
 	}
 
-	priv->cls_rule[fs->location].fs = *fs;
-	priv->cls_rule[fs->location].in_use = true;
+	return 0;
 
 err_free_mem:
 	kfree(dma_mem);
@@ -671,7 +707,7 @@ static int dpaa2_eth_get_rxnfc(struct net_device *net_dev,
 			       struct ethtool_rxnfc *rxnfc, u32 *rule_locs)
 {
 	struct dpaa2_eth_priv *priv = netdev_priv(net_dev);
-	const int rule_cnt = DPAA2_CLASSIFIER_ENTRY_COUNT;
+	const int rule_cnt = dpaa2_eth_fs_count(priv);
 	int i, j;
 
 	switch (rxnfc->cmd) {
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h b/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h
index c0f8af0..a03968e 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -33,197 +33,112 @@
 #define _FSL_DPNI_CMD_H
 
 /* DPNI Version */
-#define DPNI_VER_MAJOR				6
+#define DPNI_VER_MAJOR				7
 #define DPNI_VER_MINOR				0
+#define DPNI_CMD_BASE_VERSION			1
+#define DPNI_CMD_ID_OFFSET			4
 
 /* Command IDs */
-#define DPNI_CMDID_OPEN				0x801
-#define DPNI_CMDID_CLOSE			0x800
-#define DPNI_CMDID_CREATE			0x901
-#define DPNI_CMDID_DESTROY			0x900
-
-#define DPNI_CMDID_ENABLE			0x002
-#define DPNI_CMDID_DISABLE			0x003
-#define DPNI_CMDID_GET_ATTR			0x004
-#define DPNI_CMDID_RESET			0x005
-#define DPNI_CMDID_IS_ENABLED			0x006
-
-#define DPNI_CMDID_SET_IRQ			0x010
-#define DPNI_CMDID_GET_IRQ			0x011
-#define DPNI_CMDID_SET_IRQ_ENABLE		0x012
-#define DPNI_CMDID_GET_IRQ_ENABLE		0x013
-#define DPNI_CMDID_SET_IRQ_MASK			0x014
-#define DPNI_CMDID_GET_IRQ_MASK			0x015
-#define DPNI_CMDID_GET_IRQ_STATUS		0x016
-#define DPNI_CMDID_CLEAR_IRQ_STATUS		0x017
-
-#define DPNI_CMDID_SET_POOLS			0x200
-#define DPNI_CMDID_GET_RX_BUFFER_LAYOUT		0x201
-#define DPNI_CMDID_SET_RX_BUFFER_LAYOUT		0x202
-#define DPNI_CMDID_GET_TX_BUFFER_LAYOUT		0x203
-#define DPNI_CMDID_SET_TX_BUFFER_LAYOUT		0x204
-#define DPNI_CMDID_SET_TX_CONF_BUFFER_LAYOUT	0x205
-#define DPNI_CMDID_GET_TX_CONF_BUFFER_LAYOUT	0x206
-#define DPNI_CMDID_SET_L3_CHKSUM_VALIDATION	0x207
-#define DPNI_CMDID_GET_L3_CHKSUM_VALIDATION	0x208
-#define DPNI_CMDID_SET_L4_CHKSUM_VALIDATION	0x209
-#define DPNI_CMDID_GET_L4_CHKSUM_VALIDATION	0x20A
-#define DPNI_CMDID_SET_ERRORS_BEHAVIOR		0x20B
-#define DPNI_CMDID_SET_TX_CONF_REVOKE		0x20C
-
-#define DPNI_CMDID_GET_QDID			0x210
-#define DPNI_CMDID_GET_SP_INFO			0x211
-#define DPNI_CMDID_GET_TX_DATA_OFFSET		0x212
-#define DPNI_CMDID_GET_COUNTER			0x213
-#define DPNI_CMDID_SET_COUNTER			0x214
-#define DPNI_CMDID_GET_LINK_STATE		0x215
-#define DPNI_CMDID_SET_MAX_FRAME_LENGTH		0x216
-#define DPNI_CMDID_GET_MAX_FRAME_LENGTH		0x217
-#define DPNI_CMDID_SET_MTU			0x218
-#define DPNI_CMDID_GET_MTU			0x219
-#define DPNI_CMDID_SET_LINK_CFG			0x21A
-#define DPNI_CMDID_SET_TX_SHAPING		0x21B
-
-#define DPNI_CMDID_SET_MCAST_PROMISC		0x220
-#define DPNI_CMDID_GET_MCAST_PROMISC		0x221
-#define DPNI_CMDID_SET_UNICAST_PROMISC		0x222
-#define DPNI_CMDID_GET_UNICAST_PROMISC		0x223
-#define DPNI_CMDID_SET_PRIM_MAC			0x224
-#define DPNI_CMDID_GET_PRIM_MAC			0x225
-#define DPNI_CMDID_ADD_MAC_ADDR			0x226
-#define DPNI_CMDID_REMOVE_MAC_ADDR		0x227
-#define DPNI_CMDID_CLR_MAC_FILTERS		0x228
-
-#define DPNI_CMDID_SET_VLAN_FILTERS		0x230
-#define DPNI_CMDID_ADD_VLAN_ID			0x231
-#define DPNI_CMDID_REMOVE_VLAN_ID		0x232
-#define DPNI_CMDID_CLR_VLAN_FILTERS		0x233
-
-#define DPNI_CMDID_SET_RX_TC_DIST		0x235
-#define DPNI_CMDID_SET_TX_FLOW			0x236
-#define DPNI_CMDID_GET_TX_FLOW			0x237
-#define DPNI_CMDID_SET_RX_FLOW			0x238
-#define DPNI_CMDID_GET_RX_FLOW			0x239
-#define DPNI_CMDID_SET_RX_ERR_QUEUE		0x23A
-#define DPNI_CMDID_GET_RX_ERR_QUEUE		0x23B
-
-#define DPNI_CMDID_SET_RX_TC_POLICING		0x23E
-#define DPNI_CMDID_SET_RX_TC_EARLY_DROP		0x23F
-
-#define DPNI_CMDID_SET_QOS_TBL			0x240
-#define DPNI_CMDID_ADD_QOS_ENT			0x241
-#define DPNI_CMDID_REMOVE_QOS_ENT		0x242
-#define DPNI_CMDID_CLR_QOS_TBL			0x243
-#define DPNI_CMDID_ADD_FS_ENT			0x244
-#define DPNI_CMDID_REMOVE_FS_ENT		0x245
-#define DPNI_CMDID_CLR_FS_ENT			0x246
-#define DPNI_CMDID_SET_VLAN_INSERTION		0x247
-#define DPNI_CMDID_SET_VLAN_REMOVAL		0x248
-#define DPNI_CMDID_SET_IPR			0x249
-#define DPNI_CMDID_SET_IPF			0x24A
-
-#define DPNI_CMDID_SET_TX_SELECTION			0x250
-#define DPNI_CMDID_GET_RX_TC_POLICING		0x251
-#define DPNI_CMDID_GET_RX_TC_EARLY_DROP		0x252
-#define DPNI_CMDID_SET_RX_TC_CONGESTION_NOTIFICATION 0x253
-#define DPNI_CMDID_GET_RX_TC_CONGESTION_NOTIFICATION 0x254
-#define DPNI_CMDID_SET_TX_TC_CONGESTION_NOTIFICATION 0x255
-#define DPNI_CMDID_GET_TX_TC_CONGESTION_NOTIFICATION 0x256
-#define DPNI_CMDID_SET_TX_CONF						0x257
-#define DPNI_CMDID_GET_TX_CONF						0x258
-#define DPNI_CMDID_SET_TX_CONF_CONGESTION_NOTIFICATION 0x259
-#define DPNI_CMDID_GET_TX_CONF_CONGESTION_NOTIFICATION 0x25A
-#define DPNI_CMDID_SET_TX_TC_EARLY_DROP				0x25B
-#define DPNI_CMDID_GET_TX_TC_EARLY_DROP				0x25C
+#define DPNI_CMDID_OPEN                              ((0x801 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_CLOSE                             ((0x800 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_CREATE                            ((0x901 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_DESTROY                           ((0x981 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_API_VERSION                   ((0xa01 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_ENABLE                            ((0x002 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_DISABLE                           ((0x003 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_ATTR                          ((0x004 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_RESET                             ((0x005 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_IS_ENABLED                        ((0x006 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_SET_IRQ                           ((0x010 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_IRQ                           ((0x011 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_IRQ_ENABLE                    ((0x012 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_IRQ_ENABLE                    ((0x013 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_IRQ_MASK                      ((0x014 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_IRQ_MASK                      ((0x015 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_IRQ_STATUS                    ((0x016 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_CLEAR_IRQ_STATUS                  ((0x017 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_SET_POOLS                         ((0x200 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_ERRORS_BEHAVIOR               ((0x20B << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_GET_QDID                          ((0x210 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_SP_INFO                       ((0x211 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_TX_DATA_OFFSET                ((0x212 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_LINK_STATE                    ((0x215 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_MAX_FRAME_LENGTH              ((0x216 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_MAX_FRAME_LENGTH              ((0x217 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_LINK_CFG                      ((0x21A << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_TX_SHAPING                    ((0x21B << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_SET_MCAST_PROMISC                 ((0x220 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_MCAST_PROMISC                 ((0x221 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_UNICAST_PROMISC               ((0x222 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_UNICAST_PROMISC               ((0x223 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_PRIM_MAC                      ((0x224 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_PRIM_MAC                      ((0x225 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_ADD_MAC_ADDR                      ((0x226 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_REMOVE_MAC_ADDR                   ((0x227 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_CLR_MAC_FILTERS                   ((0x228 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_ENABLE_VLAN_FILTER                ((0x230 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_ADD_VLAN_ID                       ((0x231 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_REMOVE_VLAN_ID                    ((0x232 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_CLR_VLAN_FILTERS                  ((0x233 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_SET_RX_TC_DIST                    ((0x235 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_SET_RX_TC_POLICING                ((0x23E << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_SET_QOS_TBL                       ((0x240 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_ADD_QOS_ENT                       ((0x241 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_REMOVE_QOS_ENT                    ((0x242 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_CLR_QOS_TBL                       ((0x243 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_ADD_FS_ENT                        ((0x244 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_REMOVE_FS_ENT                     ((0x245 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_CLR_FS_ENT                        ((0x246 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_SET_TX_PRIORITIES                 ((0x250 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_RX_TC_POLICING                ((0x251 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_GET_STATISTICS                    ((0x25D << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_RESET_STATISTICS                  ((0x25E << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_QUEUE                         ((0x25F << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_QUEUE                         ((0x260 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_TAILDROP                      ((0x261 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_TAILDROP                      ((0x262 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_GET_PORT_MAC_ADDR                 ((0x263 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_GET_BUFFER_LAYOUT                 ((0x264 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_BUFFER_LAYOUT                 ((0x265 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+
+#define DPNI_CMDID_SET_TX_CONFIRMATION_MODE          ((0x266 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_CONGESTION_NOTIFICATION       ((0x267 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_CONGESTION_NOTIFICATION       ((0x268 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_EARLY_DROP                    ((0x269 << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_EARLY_DROP                    ((0x26A << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_GET_OFFLOAD                       ((0x26B << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
+#define DPNI_CMDID_SET_OFFLOAD                       ((0x26C << DPNI_CMD_ID_OFFSET) | DPNI_CMD_BASE_VERSION)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_OPEN(cmd, dpni_id) \
 	MC_CMD_OP(cmd,	 0,	0,	32,	int,	dpni_id)
 
-#define DPNI_PREP_EXTENDED_CFG(ext, cfg) \
-do { \
-	MC_PREP_OP(ext, 0, 0,   16, uint16_t, cfg->tc_cfg[0].max_dist); \
-	MC_PREP_OP(ext, 0, 16,  16, uint16_t, cfg->tc_cfg[0].max_fs_entries); \
-	MC_PREP_OP(ext, 0, 32,  16, uint16_t, cfg->tc_cfg[1].max_dist); \
-	MC_PREP_OP(ext, 0, 48,  16, uint16_t, cfg->tc_cfg[1].max_fs_entries); \
-	MC_PREP_OP(ext, 1, 0,   16, uint16_t, cfg->tc_cfg[2].max_dist); \
-	MC_PREP_OP(ext, 1, 16,  16, uint16_t, cfg->tc_cfg[2].max_fs_entries); \
-	MC_PREP_OP(ext, 1, 32,  16, uint16_t, cfg->tc_cfg[3].max_dist); \
-	MC_PREP_OP(ext, 1, 48,  16, uint16_t, cfg->tc_cfg[3].max_fs_entries); \
-	MC_PREP_OP(ext, 2, 0,   16, uint16_t, cfg->tc_cfg[4].max_dist); \
-	MC_PREP_OP(ext, 2, 16,  16, uint16_t, cfg->tc_cfg[4].max_fs_entries); \
-	MC_PREP_OP(ext, 2, 32,  16, uint16_t, cfg->tc_cfg[5].max_dist); \
-	MC_PREP_OP(ext, 2, 48,  16, uint16_t, cfg->tc_cfg[5].max_fs_entries); \
-	MC_PREP_OP(ext, 3, 0,   16, uint16_t, cfg->tc_cfg[6].max_dist); \
-	MC_PREP_OP(ext, 3, 16,  16, uint16_t, cfg->tc_cfg[6].max_fs_entries); \
-	MC_PREP_OP(ext, 3, 32,  16, uint16_t, cfg->tc_cfg[7].max_dist); \
-	MC_PREP_OP(ext, 3, 48,  16, uint16_t, cfg->tc_cfg[7].max_fs_entries); \
-	MC_PREP_OP(ext, 4, 0,   16, uint16_t, \
-		   cfg->ipr_cfg.max_open_frames_ipv4); \
-	MC_PREP_OP(ext, 4, 16,  16, uint16_t, \
-		   cfg->ipr_cfg.max_open_frames_ipv6); \
-	MC_PREP_OP(ext, 4, 32,  16, uint16_t, \
-		   cfg->ipr_cfg.max_reass_frm_size); \
-	MC_PREP_OP(ext, 5, 0,   16, uint16_t, \
-		   cfg->ipr_cfg.min_frag_size_ipv4); \
-	MC_PREP_OP(ext, 5, 16,  16, uint16_t, \
-		   cfg->ipr_cfg.min_frag_size_ipv6); \
-} while (0)
-
-#define DPNI_EXT_EXTENDED_CFG(ext, cfg) \
-do { \
-	MC_EXT_OP(ext, 0, 0,   16, uint16_t, cfg->tc_cfg[0].max_dist); \
-	MC_EXT_OP(ext, 0, 16,  16, uint16_t, cfg->tc_cfg[0].max_fs_entries); \
-	MC_EXT_OP(ext, 0, 32,  16, uint16_t, cfg->tc_cfg[1].max_dist); \
-	MC_EXT_OP(ext, 0, 48,  16, uint16_t, cfg->tc_cfg[1].max_fs_entries); \
-	MC_EXT_OP(ext, 1, 0,   16, uint16_t, cfg->tc_cfg[2].max_dist); \
-	MC_EXT_OP(ext, 1, 16,  16, uint16_t, cfg->tc_cfg[2].max_fs_entries); \
-	MC_EXT_OP(ext, 1, 32,  16, uint16_t, cfg->tc_cfg[3].max_dist); \
-	MC_EXT_OP(ext, 1, 48,  16, uint16_t, cfg->tc_cfg[3].max_fs_entries); \
-	MC_EXT_OP(ext, 2, 0,   16, uint16_t, cfg->tc_cfg[4].max_dist); \
-	MC_EXT_OP(ext, 2, 16,  16, uint16_t, cfg->tc_cfg[4].max_fs_entries); \
-	MC_EXT_OP(ext, 2, 32,  16, uint16_t, cfg->tc_cfg[5].max_dist); \
-	MC_EXT_OP(ext, 2, 48,  16, uint16_t, cfg->tc_cfg[5].max_fs_entries); \
-	MC_EXT_OP(ext, 3, 0,   16, uint16_t, cfg->tc_cfg[6].max_dist); \
-	MC_EXT_OP(ext, 3, 16,  16, uint16_t, cfg->tc_cfg[6].max_fs_entries); \
-	MC_EXT_OP(ext, 3, 32,  16, uint16_t, cfg->tc_cfg[7].max_dist); \
-	MC_EXT_OP(ext, 3, 48,  16, uint16_t, cfg->tc_cfg[7].max_fs_entries); \
-	MC_EXT_OP(ext, 4, 0,   16, uint16_t, \
-		  cfg->ipr_cfg.max_open_frames_ipv4); \
-	MC_EXT_OP(ext, 4, 16,  16, uint16_t, \
-		  cfg->ipr_cfg.max_open_frames_ipv6); \
-	MC_EXT_OP(ext, 4, 32,  16, uint16_t, \
-		  cfg->ipr_cfg.max_reass_frm_size); \
-	MC_EXT_OP(ext, 5, 0,   16, uint16_t, \
-		  cfg->ipr_cfg.min_frag_size_ipv4); \
-	MC_EXT_OP(ext, 5, 16,  16, uint16_t, \
-		  cfg->ipr_cfg.min_frag_size_ipv6); \
-} while (0)
-
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_CREATE(cmd, cfg) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,	8,  uint8_t,  cfg->adv.max_tcs); \
-	MC_CMD_OP(cmd, 0, 8,	8,  uint8_t,  cfg->adv.max_senders); \
-	MC_CMD_OP(cmd, 0, 16,	8,  uint8_t,  cfg->mac_addr[5]); \
-	MC_CMD_OP(cmd, 0, 24,	8,  uint8_t,  cfg->mac_addr[4]); \
-	MC_CMD_OP(cmd, 0, 32,	8,  uint8_t,  cfg->mac_addr[3]); \
-	MC_CMD_OP(cmd, 0, 40,	8,  uint8_t,  cfg->mac_addr[2]); \
-	MC_CMD_OP(cmd, 0, 48,	8,  uint8_t,  cfg->mac_addr[1]); \
-	MC_CMD_OP(cmd, 0, 56,	8,  uint8_t,  cfg->mac_addr[0]); \
-	MC_CMD_OP(cmd, 1, 0,	32, uint32_t, cfg->adv.options); \
-	MC_CMD_OP(cmd, 2, 0,	8,  uint8_t,  cfg->adv.max_unicast_filters); \
-	MC_CMD_OP(cmd, 2, 8,	8,  uint8_t,  cfg->adv.max_multicast_filters); \
-	MC_CMD_OP(cmd, 2, 16,	8,  uint8_t,  cfg->adv.max_vlan_filters); \
-	MC_CMD_OP(cmd, 2, 24,	8,  uint8_t,  cfg->adv.max_qos_entries); \
-	MC_CMD_OP(cmd, 2, 32,	8,  uint8_t,  cfg->adv.max_qos_key_size); \
-	MC_CMD_OP(cmd, 2, 48,	8,  uint8_t,  cfg->adv.max_dist_key_size); \
-	MC_CMD_OP(cmd, 2, 56,	8,  enum net_prot, cfg->adv.start_hdr); \
-	MC_CMD_OP(cmd, 4, 48,	8,  uint8_t, cfg->adv.max_policers); \
-	MC_CMD_OP(cmd, 4, 56,	8,  uint8_t, cfg->adv.max_congestion_ctrl); \
-	MC_CMD_OP(cmd, 5, 0,	64, uint64_t, cfg->adv.ext_cfg_iova); \
+	MC_CMD_OP(cmd, 0,  0, 32, uint32_t,  (cfg)->options); \
+	MC_CMD_OP(cmd, 0, 32,  8,  uint8_t,  (cfg)->num_queues); \
+	MC_CMD_OP(cmd, 0, 40,  8,  uint8_t,  (cfg)->num_tcs); \
+	MC_CMD_OP(cmd, 0, 48,  8,  uint8_t,  (cfg)->mac_filter_entries); \
+	MC_CMD_OP(cmd, 1,  0,  8,  uint8_t,  (cfg)->vlan_filter_entries); \
+	MC_CMD_OP(cmd, 1, 16,  8,  uint8_t,  (cfg)->qos_entries); \
+	MC_CMD_OP(cmd, 1, 32, 16, uint16_t,  (cfg)->fs_entries); \
 } while (0)
 
+
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_POOLS(cmd, cfg) \
 do { \
@@ -328,28 +243,20 @@ do { \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index);\
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_ATTR(cmd, attr) \
-	MC_CMD_OP(cmd, 6, 0,  64, uint64_t, attr->ext_cfg_iova)
+/* DPNI_CMD_GET_ATTR is not used, no input parameters */
 
-/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_ATTR(cmd, attr) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, int,	    attr->id);\
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  attr->max_tcs); \
-	MC_RSP_OP(cmd, 0, 40, 8,  uint8_t,  attr->max_senders); \
-	MC_RSP_OP(cmd, 0, 48, 8,  enum net_prot, attr->start_hdr); \
-	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, attr->options); \
-	MC_RSP_OP(cmd, 2, 0,  8,  uint8_t,  attr->max_unicast_filters); \
-	MC_RSP_OP(cmd, 2, 8,  8,  uint8_t,  attr->max_multicast_filters);\
-	MC_RSP_OP(cmd, 2, 16, 8,  uint8_t,  attr->max_vlan_filters); \
-	MC_RSP_OP(cmd, 2, 24, 8,  uint8_t,  attr->max_qos_entries); \
-	MC_RSP_OP(cmd, 2, 32, 8,  uint8_t,  attr->max_qos_key_size); \
-	MC_RSP_OP(cmd, 2, 40, 8,  uint8_t,  attr->max_dist_key_size); \
-	MC_RSP_OP(cmd, 4, 48, 8,  uint8_t, attr->max_policers); \
-	MC_RSP_OP(cmd, 4, 56, 8,  uint8_t, attr->max_congestion_ctrl); \
-	MC_RSP_OP(cmd, 5, 32, 16, uint16_t, attr->version.major);\
-	MC_RSP_OP(cmd, 5, 48, 16, uint16_t, attr->version.minor);\
+	MC_RSP_OP(cmd, 0,  0, 32, uint32_t, (attr)->options); \
+	MC_RSP_OP(cmd, 0, 32,  8, uint8_t,  (attr)->num_queues); \
+	MC_RSP_OP(cmd, 0, 40,  8, uint8_t,  (attr)->num_tcs); \
+	MC_RSP_OP(cmd, 0, 48,  8, uint8_t,  (attr)->mac_filter_entries); \
+	MC_RSP_OP(cmd, 1,  0,  8, uint8_t, (attr)->vlan_filter_entries); \
+	MC_RSP_OP(cmd, 1, 16,  8, uint8_t,  (attr)->qos_entries); \
+	MC_RSP_OP(cmd, 1, 32, 16, uint16_t, (attr)->fs_entries); \
+	MC_RSP_OP(cmd, 2,  0,  8, uint8_t,  (attr)->qos_key_size); \
+	MC_RSP_OP(cmd, 2,  8,  8, uint8_t,  (attr)->fs_key_size); \
+	MC_RSP_OP(cmd, 2, 16, 16, uint16_t, (attr)->wriop_version); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -360,96 +267,49 @@ do { \
 	MC_CMD_OP(cmd, 0, 36, 1,  int,      cfg->set_frame_annotation); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_RX_BUFFER_LAYOUT(cmd, layout) \
+#define DPNI_CMD_GET_BUFFER_LAYOUT(cmd, qtype) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_RSP_OP(cmd, 1, 0,  1,  int,	    layout->pass_timestamp); \
-	MC_RSP_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_RSP_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_RSP_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, qtype); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_RX_BUFFER_LAYOUT(cmd, layout) \
+#define DPNI_RSP_GET_BUFFER_LAYOUT(cmd, layout) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, layout->options); \
-	MC_CMD_OP(cmd, 1, 0,  1,  int,	    layout->pass_timestamp); \
-	MC_CMD_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_CMD_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
+	MC_RSP_OP(cmd, 0, 48,  1, char, (layout)->pass_timestamp); \
+	MC_RSP_OP(cmd, 0, 49,  1, char, (layout)->pass_parser_result); \
+	MC_RSP_OP(cmd, 0, 50,  1, char, (layout)->pass_frame_status); \
+	MC_RSP_OP(cmd, 1,  0, 16, uint16_t, (layout)->private_data_size); \
+	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, (layout)->data_align); \
+	MC_RSP_OP(cmd, 1, 32, 16, uint16_t, (layout)->data_head_room); \
+	MC_RSP_OP(cmd, 1, 48, 16, uint16_t, (layout)->data_tail_room); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_TX_BUFFER_LAYOUT(cmd, layout) \
+#define DPNI_CMD_SET_BUFFER_LAYOUT(cmd, qtype, layout) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_RSP_OP(cmd, 1, 0,  1,  int,      layout->pass_timestamp); \
-	MC_RSP_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_RSP_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_RSP_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, qtype); \
+	MC_CMD_OP(cmd, 0, 32, 16, uint16_t, (layout)->options); \
+	MC_CMD_OP(cmd, 0, 48,  1, char, (layout)->pass_timestamp); \
+	MC_CMD_OP(cmd, 0, 49,  1, char, (layout)->pass_parser_result); \
+	MC_CMD_OP(cmd, 0, 50,  1, char, (layout)->pass_frame_status); \
+	MC_CMD_OP(cmd, 1,  0, 16, uint16_t, (layout)->private_data_size); \
+	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, (layout)->data_align); \
+	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, (layout)->data_head_room); \
+	MC_CMD_OP(cmd, 1, 48, 16, uint16_t, (layout)->data_tail_room); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_BUFFER_LAYOUT(cmd, layout) \
+#define DPNI_CMD_SET_OFFLOAD(cmd, type, config) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, layout->options); \
-	MC_CMD_OP(cmd, 1, 0,  1,  int,	    layout->pass_timestamp); \
-	MC_CMD_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_CMD_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
+	MC_CMD_OP(cmd, 0, 24,  8, enum dpni_offload, type); \
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, config); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_TX_CONF_BUFFER_LAYOUT(cmd, layout) \
-do { \
-	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_RSP_OP(cmd, 1, 0,  1,  int,      layout->pass_timestamp); \
-	MC_RSP_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_RSP_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_RSP_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
-} while (0)
+#define DPNI_CMD_GET_OFFLOAD(cmd, type) \
+	MC_CMD_OP(cmd, 0, 24,  8, enum dpni_offload, type)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_CONF_BUFFER_LAYOUT(cmd, layout) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
-	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, layout->data_align); \
-	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, layout->options); \
-	MC_CMD_OP(cmd, 1, 0,  1,  int,	    layout->pass_timestamp); \
-	MC_CMD_OP(cmd, 1, 1,  1,  int,	    layout->pass_parser_result); \
-	MC_CMD_OP(cmd, 1, 2,  1,  int,	    layout->pass_frame_status); \
-	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, layout->data_head_room); \
-	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, layout->data_tail_room); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_L3_CHKSUM_VALIDATION(cmd, en) \
-	MC_CMD_OP(cmd, 0, 0,  1,  int,	    en)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_L3_CHKSUM_VALIDATION(cmd, en) \
-	MC_RSP_OP(cmd, 0, 0,  1,  int,	    en)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_L4_CHKSUM_VALIDATION(cmd, en) \
-	MC_CMD_OP(cmd, 0, 0,  1,  int,	    en)
+#define DPNI_RSP_GET_OFFLOAD(cmd, config) \
+	MC_RSP_OP(cmd, 0, 32, 32, uint32_t, config)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_L4_CHKSUM_VALIDATION(cmd, en) \
-	MC_RSP_OP(cmd, 0, 0,  1,  int,	    en)
+#define DPNI_CMD_GET_QDID(cmd, qtype) \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, qtype)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_QDID(cmd, qdid) \
@@ -466,19 +326,20 @@ do { \
 #define DPNI_RSP_GET_TX_DATA_OFFSET(cmd, data_offset) \
 	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, data_offset)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_COUNTER(cmd, counter) \
-	MC_CMD_OP(cmd, 0, 0,  16, enum dpni_counter, counter)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_COUNTER(cmd, value) \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, value)
+#define DPNI_CMD_GET_STATISTICS(cmd, page) \
+do { \
+	MC_CMD_OP(cmd, 0, 0, 8, uint8_t, page); \
+} while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_COUNTER(cmd, counter, value) \
+#define DPNI_RSP_GET_STATISTICS(cmd, stat) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  16, enum dpni_counter, counter); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, value); \
+	MC_RSP_OP(cmd, 0, 0, 64, uint64_t, (stat)->raw.counter[0]); \
+	MC_RSP_OP(cmd, 1, 0, 64, uint64_t, (stat)->raw.counter[1]); \
+	MC_RSP_OP(cmd, 2, 0, 64, uint64_t, (stat)->raw.counter[2]); \
+	MC_RSP_OP(cmd, 3, 0, 64, uint64_t, (stat)->raw.counter[3]); \
+	MC_RSP_OP(cmd, 4, 0, 64, uint64_t, (stat)->raw.counter[4]); \
+	MC_RSP_OP(cmd, 5, 0, 64, uint64_t, (stat)->raw.counter[5]); \
+	MC_RSP_OP(cmd, 6, 0, 64, uint64_t, (stat)->raw.counter[6]); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -512,14 +373,6 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, max_frame_length)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_MTU(cmd, mtu) \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, mtu)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_MTU(cmd, mtu) \
-	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, mtu)
-
-/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_MULTICAST_PROMISC(cmd, en) \
 	MC_CMD_OP(cmd, 0, 0,  1,  int,      en)
 
@@ -557,6 +410,16 @@ do { \
 	MC_RSP_OP(cmd, 0, 56, 8,  uint8_t,  mac_addr[0]); \
 } while (0)
 
+#define DPNI_RSP_GET_PORT_MAC_ADDR(cmd, mac_addr) \
+do { \
+	MC_RSP_OP(cmd, 0, 16, 8,  uint8_t,  mac_addr[5]); \
+	MC_RSP_OP(cmd, 0, 24, 8,  uint8_t,  mac_addr[4]); \
+	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  mac_addr[3]); \
+	MC_RSP_OP(cmd, 0, 40, 8,  uint8_t,  mac_addr[2]); \
+	MC_RSP_OP(cmd, 0, 48, 8,  uint8_t,  mac_addr[1]); \
+	MC_RSP_OP(cmd, 0, 56, 8,  uint8_t,  mac_addr[0]); \
+} while (0)
+
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_ADD_MAC_ADDR(cmd, mac_addr) \
 do { \
@@ -587,7 +450,7 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_VLAN_FILTERS(cmd, en) \
+#define DPNI_CMD_ENABLE_VLAN_FILTER(cmd, en) \
 	MC_CMD_OP(cmd, 0, 0,  1,  int,	    en)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -599,32 +462,32 @@ do { \
 	MC_CMD_OP(cmd, 0, 32, 16, uint16_t, vlan_id)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_SELECTION(cmd, cfg) \
+#define DPNI_CMD_SET_TX_PRIORITIES(cmd, cfg) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  16,  uint16_t, cfg->tc_sched[0].delta_bandwidth);\
+	MC_CMD_OP(cmd, 0, 0,  16,  uint16_t, (cfg)->tc_sched[0].delta_bandwidth);\
 	MC_CMD_OP(cmd, 0, 16,  4,  enum dpni_tx_schedule_mode, \
-				cfg->tc_sched[0].mode); \
-	MC_CMD_OP(cmd, 0, 32, 16,  uint16_t, cfg->tc_sched[1].delta_bandwidth);\
+				(cfg)->tc_sched[0].mode); \
+	MC_CMD_OP(cmd, 0, 32, 16,  uint16_t, (cfg)->tc_sched[1].delta_bandwidth);\
 	MC_CMD_OP(cmd, 0, 48, 4,  enum dpni_tx_schedule_mode, \
-				cfg->tc_sched[1].mode); \
-	MC_CMD_OP(cmd, 1, 0,  16,  uint16_t, cfg->tc_sched[2].delta_bandwidth);\
+				(cfg)->tc_sched[1].mode); \
+	MC_CMD_OP(cmd, 1, 0,  16,  uint16_t, (cfg)->tc_sched[2].delta_bandwidth);\
 	MC_CMD_OP(cmd, 1, 16,  4,  enum dpni_tx_schedule_mode, \
-				cfg->tc_sched[2].mode); \
-	MC_CMD_OP(cmd, 1, 32, 16,  uint16_t, cfg->tc_sched[3].delta_bandwidth);\
+				(cfg)->tc_sched[2].mode); \
+	MC_CMD_OP(cmd, 1, 32, 16,  uint16_t, (cfg)->tc_sched[3].delta_bandwidth);\
 	MC_CMD_OP(cmd, 1, 48, 4,  enum dpni_tx_schedule_mode, \
-				cfg->tc_sched[3].mode); \
-	MC_CMD_OP(cmd, 2, 0,  16,  uint16_t, cfg->tc_sched[4].delta_bandwidth);\
+				(cfg)->tc_sched[3].mode); \
+	MC_CMD_OP(cmd, 2, 0,  16,  uint16_t, (cfg)->tc_sched[4].delta_bandwidth);\
 	MC_CMD_OP(cmd, 2, 16,  4,  enum dpni_tx_schedule_mode, \
-				cfg->tc_sched[4].mode); \
-	MC_CMD_OP(cmd, 2, 32, 16,  uint16_t, cfg->tc_sched[5].delta_bandwidth);\
+				(cfg)->tc_sched[4].mode); \
+	MC_CMD_OP(cmd, 2, 32, 16,  uint16_t, (cfg)->tc_sched[5].delta_bandwidth);\
 	MC_CMD_OP(cmd, 2, 48, 4,  enum dpni_tx_schedule_mode, \
-				cfg->tc_sched[5].mode); \
-	MC_CMD_OP(cmd, 3, 0,  16,  uint16_t, cfg->tc_sched[6].delta_bandwidth);\
+				(cfg)->tc_sched[5].mode); \
+	MC_CMD_OP(cmd, 3, 0,  16,  uint16_t, (cfg)->tc_sched[6].delta_bandwidth);\
 	MC_CMD_OP(cmd, 3, 16,  4,  enum dpni_tx_schedule_mode, \
-				cfg->tc_sched[6].mode); \
-	MC_CMD_OP(cmd, 3, 32, 16,  uint16_t, cfg->tc_sched[7].delta_bandwidth);\
+				(cfg)->tc_sched[6].mode); \
+	MC_CMD_OP(cmd, 3, 32, 16,  uint16_t, (cfg)->tc_sched[7].delta_bandwidth);\
 	MC_CMD_OP(cmd, 3, 48, 4,  enum dpni_tx_schedule_mode, \
-				cfg->tc_sched[7].mode); \
+				(cfg)->tc_sched[7].mode); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -639,122 +502,42 @@ do { \
 	MC_CMD_OP(cmd, 6, 0,  64, uint64_t, cfg->key_cfg_iova); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_FLOW(cmd, flow_id, cfg) \
-do { \
-	MC_CMD_OP(cmd, 0, 43, 1,  int,	    cfg->l3_chksum_gen);\
-	MC_CMD_OP(cmd, 0, 44, 1,  int,	    cfg->l4_chksum_gen);\
-	MC_CMD_OP(cmd, 0, 45, 1,  int,	    cfg->use_common_tx_conf_queue);\
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id);\
-	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->options);\
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_SET_TX_FLOW(cmd, flow_id) \
-	MC_RSP_OP(cmd, 0, 48, 16, uint16_t, flow_id)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_TX_FLOW(cmd, flow_id) \
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_TX_FLOW(cmd, attr) \
-do { \
-	MC_RSP_OP(cmd, 0, 43, 1,  int,	    attr->l3_chksum_gen);\
-	MC_RSP_OP(cmd, 0, 44, 1,  int,	    attr->l4_chksum_gen);\
-	MC_RSP_OP(cmd, 0, 45, 1,  int,	    attr->use_common_tx_conf_queue);\
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_RX_FLOW(cmd, tc_id, flow_id, cfg) \
+#define DPNI_CMD_GET_QUEUE(cmd, qtype, tc, index) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->dest_cfg.dest_id); \
-	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  cfg->dest_cfg.priority);\
-	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, cfg->dest_cfg.dest_type);\
-	MC_CMD_OP(cmd, 0, 42, 1,  int,      cfg->order_preservation_en);\
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->user_ctx); \
-	MC_CMD_OP(cmd, 2, 16, 8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 2, 32, 32, uint32_t, cfg->options); \
-	MC_CMD_OP(cmd, 3, 0,  4,  enum dpni_flc_type, cfg->flc_cfg.flc_type); \
-	MC_CMD_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
-		cfg->flc_cfg.frame_data_size);\
-	MC_CMD_OP(cmd, 3, 8,  4,  enum dpni_stash_size, \
-		cfg->flc_cfg.flow_context_size);\
-	MC_CMD_OP(cmd, 3, 32, 32, uint32_t, cfg->flc_cfg.options);\
-	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->flc_cfg.flow_context);\
-	MC_CMD_OP(cmd, 5, 0,  32, uint32_t, cfg->tail_drop_threshold); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, qtype); \
+	MC_CMD_OP(cmd, 0,  8,  8,  uint8_t, tc); \
+	MC_CMD_OP(cmd, 0, 16,  8,  uint8_t, index); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_RX_FLOW(cmd, tc_id, flow_id) \
+#define DPNI_RSP_GET_QUEUE(cmd, queue, queue_id) \
 do { \
-	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
+	MC_RSP_OP(cmd, 1,  0, 32, uint32_t, (queue)->destination.id); \
+	MC_RSP_OP(cmd, 1, 48,  8, uint8_t, (queue)->destination.priority); \
+	MC_RSP_OP(cmd, 1, 56,  4, enum dpni_dest, (queue)->destination.type); \
+	MC_RSP_OP(cmd, 1, 62,  1, char, (queue)->flc.stash_control); \
+	MC_RSP_OP(cmd, 1, 63,  1, char, (queue)->destination.hold_active); \
+	MC_RSP_OP(cmd, 2,  0, 64, uint64_t, (queue)->flc.value); \
+	MC_RSP_OP(cmd, 3,  0, 64, uint64_t, (queue)->user_context); \
+	MC_RSP_OP(cmd, 4,  0, 32, uint32_t, (queue_id)->fqid); \
+	MC_RSP_OP(cmd, 4, 32, 16, uint16_t, (queue_id)->qdbin); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_RX_FLOW(cmd, attr) \
+#define DPNI_CMD_SET_QUEUE(cmd, qtype, tc, index, options, queue) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, int,      attr->dest_cfg.dest_id); \
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  attr->dest_cfg.priority);\
-	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, attr->dest_cfg.dest_type); \
-	MC_RSP_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->user_ctx); \
-	MC_RSP_OP(cmd, 2, 0,  32, uint32_t, attr->tail_drop_threshold); \
-	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, attr->fqid); \
-	MC_RSP_OP(cmd, 3, 0,  4,  enum dpni_flc_type, attr->flc_cfg.flc_type); \
-	MC_RSP_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
-		attr->flc_cfg.frame_data_size);\
-	MC_RSP_OP(cmd, 3, 8,  4,  enum dpni_stash_size, \
-		attr->flc_cfg.flow_context_size);\
-	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->flc_cfg.options);\
-	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, attr->flc_cfg.flow_context);\
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, qtype); \
+	MC_CMD_OP(cmd, 0,  8,  8,  uint8_t, tc); \
+	MC_CMD_OP(cmd, 0, 16,  8,  uint8_t, index); \
+	MC_CMD_OP(cmd, 0, 24,  8,  uint8_t, options); \
+	MC_CMD_OP(cmd, 1,  0, 32, uint32_t, (queue)->destination.id); \
+	MC_CMD_OP(cmd, 1, 48,  8, uint8_t, (queue)->destination.priority); \
+	MC_CMD_OP(cmd, 1, 56,  4, enum dpni_dest, (queue)->destination.type); \
+	MC_CMD_OP(cmd, 1, 62,  1, char, (queue)->flc.stash_control); \
+	MC_CMD_OP(cmd, 1, 63,  1, char, (queue)->destination.hold_active); \
+	MC_CMD_OP(cmd, 2,  0, 64, uint64_t, (queue)->flc.value); \
+	MC_CMD_OP(cmd, 3,  0, 64, uint64_t, (queue)->user_context); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_RX_ERR_QUEUE(cmd, cfg) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->dest_cfg.dest_id); \
-	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  cfg->dest_cfg.priority);\
-	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, cfg->dest_cfg.dest_type);\
-	MC_CMD_OP(cmd, 0, 42, 1,  int,      cfg->order_preservation_en);\
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->user_ctx); \
-	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->options); \
-	MC_CMD_OP(cmd, 2, 32, 32, uint32_t, cfg->tail_drop_threshold); \
-	MC_CMD_OP(cmd, 3, 0,  4,  enum dpni_flc_type, cfg->flc_cfg.flc_type); \
-	MC_CMD_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
-		cfg->flc_cfg.frame_data_size);\
-	MC_CMD_OP(cmd, 3, 8,  4,  enum dpni_stash_size, \
-		cfg->flc_cfg.flow_context_size);\
-	MC_CMD_OP(cmd, 3, 32, 32, uint32_t, cfg->flc_cfg.options);\
-	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->flc_cfg.flow_context);\
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_RX_ERR_QUEUE(cmd, attr) \
-do { \
-	MC_RSP_OP(cmd, 0, 0,  32, int,      attr->dest_cfg.dest_id); \
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  attr->dest_cfg.priority);\
-	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, attr->dest_cfg.dest_type);\
-	MC_RSP_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->user_ctx); \
-	MC_RSP_OP(cmd, 2, 0,  32, uint32_t, attr->tail_drop_threshold); \
-	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, attr->fqid); \
-	MC_RSP_OP(cmd, 3, 0,  4,  enum dpni_flc_type, attr->flc_cfg.flc_type); \
-	MC_RSP_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
-		attr->flc_cfg.frame_data_size);\
-	MC_RSP_OP(cmd, 3, 8,  4,  enum dpni_stash_size, \
-		attr->flc_cfg.flow_context_size);\
-	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->flc_cfg.options);\
-	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, attr->flc_cfg.flow_context);\
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_CONF_REVOKE(cmd, revoke) \
-	MC_CMD_OP(cmd, 0, 0,  1,  int,      revoke)
-
-/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_QOS_TABLE(cmd, cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  cfg->default_tc); \
@@ -763,10 +546,11 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_ADD_QOS_ENTRY(cmd, cfg, tc_id) \
+#define DPNI_CMD_ADD_QOS_ENTRY(cmd, cfg, tc_id, index) \
 do { \
 	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  tc_id); \
 	MC_CMD_OP(cmd, 0, 24, 8,  uint8_t,  cfg->key_size); \
+	MC_CMD_OP(cmd, 0, 32, 16, uint16_t, index); \
 	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->key_iova); \
 	MC_CMD_OP(cmd, 2, 0,  64, uint64_t, cfg->mask_iova); \
 } while (0)
@@ -780,13 +564,16 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_ADD_FS_ENTRY(cmd, tc_id, cfg, flow_id) \
+#define DPNI_CMD_ADD_FS_ENTRY(cmd, cfg, tc_id, index, action) \
 do { \
+	MC_CMD_OP(cmd, 0,  0, 16, uint16_t, (action)->options); \
 	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
-	MC_CMD_OP(cmd, 0, 24, 8,  uint8_t,  cfg->key_size); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->key_iova); \
-	MC_CMD_OP(cmd, 2, 0,  64, uint64_t, cfg->mask_iova); \
+	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, (action)->flow_id); \
+	MC_CMD_OP(cmd, 0, 24, 8,  uint8_t,  (cfg)->key_size); \
+	MC_CMD_OP(cmd, 0, 32, 16, uint16_t, index); \
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, (cfg)->key_iova); \
+	MC_CMD_OP(cmd, 2, 0,  64, uint64_t, (cfg)->mask_iova); \
+	MC_CMD_OP(cmd, 3, 0, 64, uint64_t, (action)->flc); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -803,22 +590,6 @@ do { \
 	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  tc_id)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_VLAN_INSERTION(cmd, en) \
-	MC_CMD_OP(cmd, 0, 0,  1,  int,	    en)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_VLAN_REMOVAL(cmd, en) \
-	MC_CMD_OP(cmd, 0, 0,  1,  int,	    en)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_IPR(cmd, en) \
-	MC_CMD_OP(cmd, 0, 0,  1,  int,	    en)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_IPF(cmd, en) \
-	MC_CMD_OP(cmd, 0, 0,  1,  int,	    en)
-
-/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_RX_TC_POLICING(cmd, tc_id, cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  4, enum dpni_policer_mode, cfg->mode); \
@@ -852,207 +623,115 @@ do { \
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_PREP_EARLY_DROP(ext, cfg) \
 do { \
-	MC_PREP_OP(ext, 0, 0,  2, enum dpni_early_drop_mode, cfg->mode); \
+	MC_PREP_OP(ext, 0, 0,  2, enum dpni_early_drop_mode, (cfg)->mode); \
 	MC_PREP_OP(ext, 0, 2,  2, \
-		  enum dpni_congestion_unit, cfg->units); \
-	MC_PREP_OP(ext, 0, 32, 32, uint32_t, cfg->tail_drop_threshold); \
-	MC_PREP_OP(ext, 1, 0,  8,  uint8_t,  cfg->green.drop_probability); \
-	MC_PREP_OP(ext, 2, 0,  64, uint64_t, cfg->green.max_threshold); \
-	MC_PREP_OP(ext, 3, 0,  64, uint64_t, cfg->green.min_threshold); \
-	MC_PREP_OP(ext, 5, 0,  8,  uint8_t,  cfg->yellow.drop_probability);\
-	MC_PREP_OP(ext, 6, 0,  64, uint64_t, cfg->yellow.max_threshold); \
-	MC_PREP_OP(ext, 7, 0,  64, uint64_t, cfg->yellow.min_threshold); \
-	MC_PREP_OP(ext, 9, 0,  8,  uint8_t,  cfg->red.drop_probability); \
-	MC_PREP_OP(ext, 10, 0,  64, uint64_t, cfg->red.max_threshold); \
-	MC_PREP_OP(ext, 11, 0,  64, uint64_t, cfg->red.min_threshold); \
+		  enum dpni_congestion_unit, (cfg)->units); \
+	MC_PREP_OP(ext, 0, 32, 32, uint32_t, (cfg)->tail_drop_threshold); \
+	MC_PREP_OP(ext, 1, 0,  8,  uint8_t,  (cfg)->green.drop_probability); \
+	MC_PREP_OP(ext, 2, 0,  64, uint64_t, (cfg)->green.max_threshold); \
+	MC_PREP_OP(ext, 3, 0,  64, uint64_t, (cfg)->green.min_threshold); \
+	MC_PREP_OP(ext, 5, 0,  8,  uint8_t,  (cfg)->yellow.drop_probability);\
+	MC_PREP_OP(ext, 6, 0,  64, uint64_t, (cfg)->yellow.max_threshold); \
+	MC_PREP_OP(ext, 7, 0,  64, uint64_t, (cfg)->yellow.min_threshold); \
+	MC_PREP_OP(ext, 9, 0,  8,  uint8_t,  (cfg)->red.drop_probability); \
+	MC_PREP_OP(ext, 10, 0,  64, uint64_t, (cfg)->red.max_threshold); \
+	MC_PREP_OP(ext, 11, 0,  64, uint64_t, (cfg)->red.min_threshold); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_EXT_EARLY_DROP(ext, cfg) \
 do { \
-	MC_EXT_OP(ext, 0, 0,  2, enum dpni_early_drop_mode, cfg->mode); \
+	MC_EXT_OP(ext, 0, 0,  2, enum dpni_early_drop_mode, (cfg)->mode); \
 	MC_EXT_OP(ext, 0, 2,  2, \
-		  enum dpni_congestion_unit, cfg->units); \
-	MC_EXT_OP(ext, 0, 32, 32, uint32_t, cfg->tail_drop_threshold); \
-	MC_EXT_OP(ext, 1, 0,  8,  uint8_t,  cfg->green.drop_probability); \
-	MC_EXT_OP(ext, 2, 0,  64, uint64_t, cfg->green.max_threshold); \
-	MC_EXT_OP(ext, 3, 0,  64, uint64_t, cfg->green.min_threshold); \
-	MC_EXT_OP(ext, 5, 0,  8,  uint8_t,  cfg->yellow.drop_probability);\
-	MC_EXT_OP(ext, 6, 0,  64, uint64_t, cfg->yellow.max_threshold); \
-	MC_EXT_OP(ext, 7, 0,  64, uint64_t, cfg->yellow.min_threshold); \
-	MC_EXT_OP(ext, 9, 0,  8,  uint8_t,  cfg->red.drop_probability); \
-	MC_EXT_OP(ext, 10, 0,  64, uint64_t, cfg->red.max_threshold); \
-	MC_EXT_OP(ext, 11, 0,  64, uint64_t, cfg->red.min_threshold); \
+		  enum dpni_congestion_unit, (cfg)->units); \
+	MC_EXT_OP(ext, 0, 32, 32, uint32_t, (cfg)->tail_drop_threshold); \
+	MC_EXT_OP(ext, 1, 0,  8,  uint8_t,  (cfg)->green.drop_probability); \
+	MC_EXT_OP(ext, 2, 0,  64, uint64_t, (cfg)->green.max_threshold); \
+	MC_EXT_OP(ext, 3, 0,  64, uint64_t, (cfg)->green.min_threshold); \
+	MC_EXT_OP(ext, 5, 0,  8,  uint8_t,  (cfg)->yellow.drop_probability);\
+	MC_EXT_OP(ext, 6, 0,  64, uint64_t, (cfg)->yellow.max_threshold); \
+	MC_EXT_OP(ext, 7, 0,  64, uint64_t, (cfg)->yellow.min_threshold); \
+	MC_EXT_OP(ext, 9, 0,  8,  uint8_t,  (cfg)->red.drop_probability); \
+	MC_EXT_OP(ext, 10, 0,  64, uint64_t, (cfg)->red.max_threshold); \
+	MC_EXT_OP(ext, 11, 0,  64, uint64_t, (cfg)->red.min_threshold); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_RX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova) \
+#define DPNI_CMD_SET_EARLY_DROP(cmd, qtype, tc, early_drop_iova) \
 do { \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, early_drop_iova); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, qtype); \
+	MC_CMD_OP(cmd, 0,  8,  8, uint8_t, tc); \
+	MC_CMD_OP(cmd, 1,  0, 64, uint64_t, early_drop_iova); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_RX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova) \
+#define DPNI_CMD_GET_EARLY_DROP(cmd, qtype, tc, early_drop_iova) \
 do { \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, early_drop_iova); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, qtype); \
+	MC_CMD_OP(cmd, 0,  8,  8, uint8_t, tc); \
+	MC_CMD_OP(cmd, 1,  0, 64, uint64_t, early_drop_iova); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova) \
+#define DPNI_CMD_GET_TAILDROP(cmd, cp, q_type, tc, q_index) \
 do { \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, early_drop_iova); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_congestion_point, cp); \
+	MC_CMD_OP(cmd, 0,  8,  8, enum dpni_queue_type, q_type); \
+	MC_CMD_OP(cmd, 0, 16,  8, uint8_t, tc); \
+	MC_CMD_OP(cmd, 0, 24,  8, uint8_t, q_index); \
 } while (0)
 
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_TX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova) \
+#define DPNI_RSP_GET_TAILDROP(cmd, taildrop) \
 do { \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, early_drop_iova); \
+	MC_RSP_OP(cmd, 1,  0,  1, char, (taildrop)->enable); \
+	MC_RSP_OP(cmd, 1, 16,  8, enum dpni_congestion_unit, (taildrop)->units); \
+	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, (taildrop)->threshold); \
 } while (0)
 
-#define DPNI_CMD_SET_RX_TC_CONGESTION_NOTIFICATION(cmd, tc_id, cfg) \
+#define DPNI_CMD_SET_TAILDROP(cmd, cp, q_type, tc, q_index, taildrop) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
-	MC_CMD_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
-	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
-	MC_CMD_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
-	MC_CMD_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
-	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
-	MC_CMD_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
-	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_congestion_point, cp); \
+	MC_CMD_OP(cmd, 0,  8,  8, enum dpni_queue_type, q_type); \
+	MC_CMD_OP(cmd, 0, 16,  8, uint8_t, tc); \
+	MC_CMD_OP(cmd, 0, 24,  8, uint8_t, q_index); \
+	MC_CMD_OP(cmd, 1,  0,  1, char, (taildrop)->enable); \
+	MC_CMD_OP(cmd, 1, 16,  8, enum dpni_congestion_unit, (taildrop)->units); \
+	MC_CMD_OP(cmd, 1, 32, 32, uint32_t, (taildrop)->threshold); \
 } while (0)
 
-#define DPNI_CMD_GET_RX_TC_CONGESTION_NOTIFICATION(cmd, tc_id) \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id)
+#define DPNI_CMD_SET_TX_CONFIRMATION_MODE(cmd, mode) \
+	MC_CMD_OP(cmd, 0, 32, 8, enum dpni_confirmation_mode, mode)
 
-#define DPNI_RSP_GET_RX_TC_CONGESTION_NOTIFICATION(cmd, cfg) \
+#define DPNI_CMD_SET_CONGESTION_NOTIFICATION(cmd, qtype, tc, cfg) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
-	MC_RSP_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
-	MC_RSP_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
-	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
-	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
-	MC_RSP_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
-	MC_RSP_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
-	MC_RSP_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
-	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, qtype); \
+	MC_CMD_OP(cmd, 0,  8,  8, uint8_t, tc); \
+	MC_CMD_OP(cmd, 1,  0, 32, uint32_t, (cfg)->dest_cfg.dest_id); \
+	MC_CMD_OP(cmd, 1,  0, 16, uint16_t, (cfg)->notification_mode); \
+	MC_CMD_OP(cmd, 1, 48,  8, uint8_t, (cfg)->dest_cfg.priority); \
+	MC_CMD_OP(cmd, 1, 56,  4, enum dpni_dest, (cfg)->dest_cfg.dest_type); \
+	MC_CMD_OP(cmd, 1, 60,  2, enum dpni_congestion_unit, (cfg)->units); \
+	MC_CMD_OP(cmd, 2,  0, 64, uint64_t, (cfg)->message_iova); \
+	MC_CMD_OP(cmd, 3,  0, 64, uint64_t, (cfg)->message_ctx); \
+	MC_CMD_OP(cmd, 4,  0, 32, uint32_t, (cfg)->threshold_entry); \
+	MC_CMD_OP(cmd, 4, 32, 32, uint32_t, (cfg)->threshold_exit); \
 } while (0)
 
-#define DPNI_CMD_SET_TX_TC_CONGESTION_NOTIFICATION(cmd, tc_id, cfg) \
+#define DPNI_CMD_GET_CONGESTION_NOTIFICATION(cmd, qtype, tc) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
-	MC_CMD_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
-	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
-	MC_CMD_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
-	MC_CMD_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
-	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
-	MC_CMD_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
-	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+	MC_CMD_OP(cmd, 0,  0,  8, enum dpni_queue_type, qtype); \
+	MC_CMD_OP(cmd, 0,  8,  8, uint8_t, tc); \
 } while (0)
 
-#define DPNI_CMD_GET_TX_TC_CONGESTION_NOTIFICATION(cmd, tc_id) \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id)
-
-#define DPNI_RSP_GET_TX_TC_CONGESTION_NOTIFICATION(cmd, cfg) \
-do { \
-	MC_RSP_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
-	MC_RSP_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
-	MC_RSP_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
-	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
-	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
-	MC_RSP_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
-	MC_RSP_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
-	MC_RSP_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
-	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
-} while (0)
-
-#define DPNI_CMD_SET_TX_CONF(cmd, flow_id, cfg) \
-do { \
-	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t, cfg->queue_cfg.dest_cfg.priority); \
-	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, \
-		cfg->queue_cfg.dest_cfg.dest_type); \
-	MC_CMD_OP(cmd, 0, 42, 1,  int, cfg->errors_only); \
-	MC_CMD_OP(cmd, 0, 46, 1,  int, cfg->queue_cfg.order_preservation_en); \
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->queue_cfg.user_ctx); \
-	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->queue_cfg.options); \
-	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->queue_cfg.dest_cfg.dest_id); \
-	MC_CMD_OP(cmd, 3, 0,  32, uint32_t, \
-		cfg->queue_cfg.tail_drop_threshold); \
-	MC_CMD_OP(cmd, 4, 0,  4,  enum dpni_flc_type, \
-		cfg->queue_cfg.flc_cfg.flc_type); \
-	MC_CMD_OP(cmd, 4, 4,  4,  enum dpni_stash_size, \
-		cfg->queue_cfg.flc_cfg.frame_data_size); \
-	MC_CMD_OP(cmd, 4, 8,  4,  enum dpni_stash_size, \
-		cfg->queue_cfg.flc_cfg.flow_context_size); \
-	MC_CMD_OP(cmd, 4, 32, 32, uint32_t, cfg->queue_cfg.flc_cfg.options); \
-	MC_CMD_OP(cmd, 5, 0,  64, uint64_t, \
-		cfg->queue_cfg.flc_cfg.flow_context); \
-} while (0)
-
-#define DPNI_CMD_GET_TX_CONF(cmd, flow_id) \
-		MC_CMD_OP(cmd, 0, 48, 16, uint16_t,  flow_id)
-
-#define DPNI_RSP_GET_TX_CONF(cmd, attr) \
-do { \
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t, \
-		  attr->queue_attr.dest_cfg.priority); \
-	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, \
-		attr->queue_attr.dest_cfg.dest_type); \
-	MC_RSP_OP(cmd, 0, 42, 1,  int, attr->errors_only); \
-	MC_RSP_OP(cmd, 0, 46, 1,  int, \
-		  attr->queue_attr.order_preservation_en); \
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->queue_attr.user_ctx); \
-	MC_RSP_OP(cmd, 2, 32, 32, int,	attr->queue_attr.dest_cfg.dest_id); \
-	MC_RSP_OP(cmd, 3, 0,  32, uint32_t, \
-		attr->queue_attr.tail_drop_threshold); \
-	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->queue_attr.fqid); \
-	MC_RSP_OP(cmd, 4, 0,  4,  enum dpni_flc_type, \
-		attr->queue_attr.flc_cfg.flc_type); \
-	MC_RSP_OP(cmd, 4, 4,  4,  enum dpni_stash_size, \
-		attr->queue_attr.flc_cfg.frame_data_size); \
-	MC_RSP_OP(cmd, 4, 8,  4,  enum dpni_stash_size, \
-		attr->queue_attr.flc_cfg.flow_context_size); \
-	MC_RSP_OP(cmd, 4, 32, 32, uint32_t, attr->queue_attr.flc_cfg.options); \
-	MC_RSP_OP(cmd, 5, 0,  64, uint64_t, \
-		attr->queue_attr.flc_cfg.flow_context); \
-} while (0)
-
-#define DPNI_CMD_SET_TX_CONF_CONGESTION_NOTIFICATION(cmd, flow_id, cfg) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
-	MC_CMD_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
-	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
-	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
-	MC_CMD_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
-	MC_CMD_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
-	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
-	MC_CMD_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
-	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
-} while (0)
-
-#define DPNI_CMD_GET_TX_CONF_CONGESTION_NOTIFICATION(cmd, flow_id) \
-	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id)
-
-#define DPNI_RSP_GET_TX_CONF_CONGESTION_NOTIFICATION(cmd, cfg) \
+#define DPNI_RSP_GET_CONGESTION_NOTIFICATION(cmd, cfg) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
-	MC_RSP_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
-	MC_RSP_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
-	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
-	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
-	MC_RSP_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
-	MC_RSP_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
-	MC_RSP_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
-	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+	MC_RSP_OP(cmd, 1,  0, 32, uint32_t, (cfg)->dest_cfg.dest_id); \
+	MC_RSP_OP(cmd, 1,  0, 16, uint16_t, (cfg)->notification_mode); \
+	MC_RSP_OP(cmd, 1, 48,  8, uint8_t, (cfg)->dest_cfg.priority); \
+	MC_RSP_OP(cmd, 1, 56,  4, enum dpni_dest, (cfg)->dest_cfg.dest_type); \
+	MC_RSP_OP(cmd, 1, 60,  2, enum dpni_congestion_unit, (cfg)->units); \
+	MC_RSP_OP(cmd, 2,  0, 64, uint64_t, (cfg)->message_iova); \
+	MC_RSP_OP(cmd, 3,  0, 64, uint64_t, (cfg)->message_ctx); \
+	MC_RSP_OP(cmd, 4,  0, 32, uint32_t, (cfg)->threshold_entry); \
+	MC_RSP_OP(cmd, 4, 32, 32, uint32_t, (cfg)->threshold_exit); \
 } while (0)
 
 #endif /* _FSL_DPNI_CMD_H */
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpni.c b/drivers/staging/fsl-dpaa2/ethernet/dpni.c
index c228ce5..849480f 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpni.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpni.c
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -115,26 +115,6 @@ int dpni_prepare_key_cfg(const struct dpkg_profile_cfg *cfg,
 	return 0;
 }
 
-int dpni_prepare_extended_cfg(const struct dpni_extended_cfg	*cfg,
-			      uint8_t			*ext_cfg_buf)
-{
-	uint64_t *ext_params = (uint64_t *)ext_cfg_buf;
-
-	DPNI_PREP_EXTENDED_CFG(ext_params, cfg);
-
-	return 0;
-}
-
-int dpni_extract_extended_cfg(struct dpni_extended_cfg	*cfg,
-			      const uint8_t		*ext_cfg_buf)
-{
-	const uint64_t *ext_params = (const uint64_t *)ext_cfg_buf;
-
-	DPNI_EXT_EXTENDED_CFG(ext_params, cfg);
-
-	return 0;
-}
-
 int dpni_open(struct fsl_mc_io *mc_io,
 	      uint32_t cmd_flags,
 	      int dpni_id,
@@ -155,7 +135,7 @@ int dpni_open(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*token = get_mc_cmd_hdr_token(cmd.header);
 
 	return 0;
 }
@@ -175,10 +155,11 @@ int dpni_close(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_create(struct fsl_mc_io *mc_io,
-		uint32_t cmd_flags,
-		const struct dpni_cfg *cfg,
-		uint16_t *token)
+int dpni_create(struct fsl_mc_io	*mc_io,
+		uint16_t	dprc_token,
+		uint32_t	cmd_flags,
+		const struct dpni_cfg	*cfg,
+		uint32_t	*object_id)
 {
 	struct mc_command cmd = { 0 };
 	int err;
@@ -186,7 +167,7 @@ int dpni_create(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_CREATE,
 					  cmd_flags,
-					  0);
+					  dprc_token);
 	DPNI_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -195,22 +176,24 @@ int dpni_create(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*object_id = get_mc_cmd_create_object_id(&cmd);
 
 	return 0;
 }
 
-int dpni_destroy(struct fsl_mc_io *mc_io,
-		 uint32_t cmd_flags,
-		 uint16_t token)
+int dpni_destroy(struct fsl_mc_io	*mc_io,
+		uint16_t	dprc_token,
+		uint32_t	cmd_flags,
+		uint32_t	object_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_DESTROY,
 					  cmd_flags,
-					  token);
-
+					  dprc_token);
+	/* set object id to destroy */
+	cmd.params[0] = mc_enc(0, sizeof(object_id), object_id);
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
@@ -488,7 +471,6 @@ int dpni_get_attributes(struct fsl_mc_io *mc_io,
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_ATTR,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_GET_ATTR(cmd, attr);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -518,18 +500,20 @@ int dpni_set_errors_behavior(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_rx_buffer_layout(struct fsl_mc_io *mc_io,
+int dpni_get_buffer_layout(struct fsl_mc_io *mc_io,
 			      uint32_t cmd_flags,
 			      uint16_t token,
+			      enum dpni_queue_type qtype,
 			      struct dpni_buffer_layout *layout)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_BUFFER_LAYOUT,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_BUFFER_LAYOUT,
 					  cmd_flags,
 					  token);
+	DPNI_CMD_GET_BUFFER_LAYOUT(cmd, qtype);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -537,163 +521,61 @@ int dpni_get_rx_buffer_layout(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPNI_RSP_GET_RX_BUFFER_LAYOUT(cmd, layout);
+	DPNI_RSP_GET_BUFFER_LAYOUT(cmd, layout);
 
 	return 0;
 }
 
-int dpni_set_rx_buffer_layout(struct fsl_mc_io *mc_io,
+int dpni_set_buffer_layout(struct fsl_mc_io *mc_io,
 			      uint32_t cmd_flags,
 			      uint16_t token,
+			      enum dpni_queue_type qtype,
 			      const struct dpni_buffer_layout *layout)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_BUFFER_LAYOUT,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_BUFFER_LAYOUT,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_RX_BUFFER_LAYOUT(cmd, layout);
+	DPNI_CMD_SET_BUFFER_LAYOUT(cmd, qtype, layout);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_tx_buffer_layout(struct fsl_mc_io *mc_io,
-			      uint32_t cmd_flags,
-			      uint16_t token,
-			      struct dpni_buffer_layout *layout)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_BUFFER_LAYOUT,
-					  cmd_flags,
-					  token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_TX_BUFFER_LAYOUT(cmd, layout);
-
-	return 0;
-}
-
-int dpni_set_tx_buffer_layout(struct fsl_mc_io *mc_io,
-			      uint32_t cmd_flags,
-			      uint16_t token,
-			      const struct dpni_buffer_layout *layout)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_BUFFER_LAYOUT,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_TX_BUFFER_LAYOUT(cmd, layout);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
-				   uint32_t cmd_flags,
-				   uint16_t token,
-				   struct dpni_buffer_layout *layout)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_CONF_BUFFER_LAYOUT,
-					  cmd_flags,
-					  token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_TX_CONF_BUFFER_LAYOUT(cmd, layout);
-
-	return 0;
-}
-
-int dpni_set_tx_conf_buffer_layout(struct fsl_mc_io *mc_io,
-				   uint32_t cmd_flags,
-				   uint16_t token,
-				   const struct dpni_buffer_layout *layout)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF_BUFFER_LAYOUT,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_TX_CONF_BUFFER_LAYOUT(cmd, layout);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_get_l3_chksum_validation(struct fsl_mc_io *mc_io,
-				  uint32_t cmd_flags,
-				  uint16_t token,
-				  int *en)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_L3_CHKSUM_VALIDATION,
-					  cmd_flags,
-					  token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_L3_CHKSUM_VALIDATION(cmd, *en);
-
-	return 0;
-}
-
-int dpni_set_l3_chksum_validation(struct fsl_mc_io *mc_io,
-				  uint32_t cmd_flags,
-				  uint16_t token,
-				  int en)
+int dpni_set_offload(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		     enum dpni_offload type,
+		     uint32_t config)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_L3_CHKSUM_VALIDATION,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_OFFLOAD,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_L3_CHKSUM_VALIDATION(cmd, en);
+	DPNI_CMD_SET_OFFLOAD(cmd, type, config);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_l4_chksum_validation(struct fsl_mc_io *mc_io,
-				  uint32_t cmd_flags,
-				  uint16_t token,
-				  int *en)
+int dpni_get_offload(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		     enum dpni_offload type,
+		     uint32_t *config)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_L4_CHKSUM_VALIDATION,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_OFFLOAD,
 					  cmd_flags,
 					  token);
+	DPNI_CMD_GET_OFFLOAD(cmd, type);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -701,31 +583,15 @@ int dpni_get_l4_chksum_validation(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	DPNI_RSP_GET_L4_CHKSUM_VALIDATION(cmd, *en);
+	DPNI_RSP_GET_OFFLOAD(cmd, *config);
 
 	return 0;
 }
 
-int dpni_set_l4_chksum_validation(struct fsl_mc_io *mc_io,
-				  uint32_t cmd_flags,
-				  uint16_t token,
-				  int en)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_L4_CHKSUM_VALIDATION,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_L4_CHKSUM_VALIDATION(cmd, en);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
 int dpni_get_qdid(struct fsl_mc_io *mc_io,
 		  uint32_t cmd_flags,
 		  uint16_t token,
+		  enum dpni_queue_type qtype,
 		  uint16_t *qdid)
 {
 	struct mc_command cmd = { 0 };
@@ -735,6 +601,7 @@ int dpni_get_qdid(struct fsl_mc_io *mc_io,
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_QDID,
 					  cmd_flags,
 					  token);
+	DPNI_CMD_GET_QDID(cmd, qtype);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -795,50 +662,6 @@ int dpni_get_tx_data_offset(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpni_get_counter(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     enum dpni_counter counter,
-		     uint64_t *value)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_COUNTER,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_GET_COUNTER(cmd, counter);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_COUNTER(cmd, *value);
-
-	return 0;
-}
-
-int dpni_set_counter(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     enum dpni_counter counter,
-		     uint64_t value)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_COUNTER,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_COUNTER(cmd, counter, value);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
 int dpni_set_link_cfg(struct fsl_mc_io *mc_io,
 		      uint32_t cmd_flags,
 		      uint16_t token,
@@ -938,47 +761,6 @@ int dpni_get_max_frame_length(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpni_set_mtu(struct fsl_mc_io *mc_io,
-		 uint32_t cmd_flags,
-		 uint16_t token,
-		 uint16_t mtu)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_MTU,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_MTU(cmd, mtu);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_get_mtu(struct fsl_mc_io *mc_io,
-		 uint32_t cmd_flags,
-		 uint16_t token,
-		 uint16_t *mtu)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_MTU,
-					  cmd_flags,
-					  token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_MTU(cmd, *mtu);
-
-	return 0;
-}
-
 int dpni_set_multicast_promisc(struct fsl_mc_io *mc_io,
 			       uint32_t cmd_flags,
 			       uint16_t token,
@@ -1154,7 +936,31 @@ int dpni_clear_mac_filters(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_vlan_filters(struct fsl_mc_io *mc_io,
+int dpni_get_port_mac_addr(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
+			   uint16_t token,
+			   uint8_t mac_addr[6])
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_PORT_MAC_ADDR,
+					  cmd_flags,
+					  token);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPNI_RSP_GET_PORT_MAC_ADDR(cmd, mac_addr);
+
+	return 0;
+}
+
+int dpni_enable_vlan_filter(struct fsl_mc_io *mc_io,
 			  uint32_t cmd_flags,
 			  uint16_t token,
 			  int en)
@@ -1162,10 +968,10 @@ int dpni_set_vlan_filters(struct fsl_mc_io *mc_io,
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_VLAN_FILTERS,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_ENABLE_VLAN_FILTER,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_VLAN_FILTERS(cmd, en);
+	DPNI_CMD_ENABLE_VLAN_FILTER(cmd, en);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -1220,18 +1026,18 @@ int dpni_clear_vlan_filters(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_tx_selection(struct fsl_mc_io			*mc_io,
+int dpni_set_tx_priorities(struct fsl_mc_io			*mc_io,
 			  uint32_t				cmd_flags,
 			  uint16_t				token,
-			  const struct dpni_tx_selection_cfg	*cfg)
+			  const struct dpni_tx_priorities_cfg	*cfg)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_SELECTION,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_PRIORITIES,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_TX_SELECTION(cmd, cfg);
+	DPNI_CMD_SET_TX_PRIORITIES(cmd, cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -1255,156 +1061,18 @@ int dpni_set_rx_tc_dist(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_tx_flow(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     uint16_t *flow_id,
-		     const struct dpni_tx_flow_cfg *cfg)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_FLOW,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_TX_FLOW(cmd, *flow_id, cfg);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_SET_TX_FLOW(cmd, *flow_id);
-
-	return 0;
-}
-
-int dpni_get_tx_flow(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     uint16_t flow_id,
-		     struct dpni_tx_flow_attr *attr)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_FLOW,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_GET_TX_FLOW(cmd, flow_id);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_TX_FLOW(cmd, attr);
-
-	return 0;
-}
-
-int dpni_set_rx_flow(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     uint8_t tc_id,
-		     uint16_t flow_id,
-		     const struct dpni_queue_cfg *cfg)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_FLOW,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_RX_FLOW(cmd, tc_id, flow_id, cfg);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_get_rx_flow(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     uint8_t tc_id,
-		     uint16_t flow_id,
-		     struct dpni_queue_attr *attr)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_FLOW,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_GET_RX_FLOW(cmd, tc_id, flow_id);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_RX_FLOW(cmd, attr);
-
-	return 0;
-}
-
-int dpni_set_rx_err_queue(struct fsl_mc_io *mc_io,
-			  uint32_t cmd_flags,
-			  uint16_t token,
-			  const struct dpni_queue_cfg *cfg)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_ERR_QUEUE,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_RX_ERR_QUEUE(cmd, cfg);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_get_rx_err_queue(struct fsl_mc_io *mc_io,
-			  uint32_t cmd_flags,
-			  uint16_t token,
-			  struct dpni_queue_attr *attr)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_ERR_QUEUE,
-					  cmd_flags,
-					  token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_RX_ERR_QUEUE(cmd, attr);
-
-	return 0;
-}
-
-int dpni_set_tx_conf_revoke(struct fsl_mc_io	*mc_io,
+int dpni_set_tx_confirmation_mode(struct fsl_mc_io	*mc_io,
 			    uint32_t		cmd_flags,
 			    uint16_t		token,
-			    int		revoke)
+			    enum dpni_confirmation_mode mode)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF_REVOKE,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONFIRMATION_MODE,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_TX_CONF_REVOKE(cmd, revoke);
+	DPNI_CMD_SET_TX_CONFIRMATION_MODE(cmd, mode);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -1431,7 +1099,8 @@ int dpni_add_qos_entry(struct fsl_mc_io *mc_io,
 		       uint32_t cmd_flags,
 		       uint16_t token,
 		       const struct dpni_rule_cfg *cfg,
-		       uint8_t tc_id)
+		       uint8_t tc_id,
+			   uint16_t index)
 {
 	struct mc_command cmd = { 0 };
 
@@ -1439,7 +1108,7 @@ int dpni_add_qos_entry(struct fsl_mc_io *mc_io,
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_ADD_QOS_ENT,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_ADD_QOS_ENTRY(cmd, cfg, tc_id);
+	DPNI_CMD_ADD_QOS_ENTRY(cmd, cfg, tc_id, index);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -1481,8 +1150,9 @@ int dpni_add_fs_entry(struct fsl_mc_io *mc_io,
 		      uint32_t cmd_flags,
 		      uint16_t token,
 		      uint8_t tc_id,
+			  uint16_t index,
 		      const struct dpni_rule_cfg *cfg,
-		      uint16_t flow_id)
+		      const struct dpni_fs_action_cfg *action)
 {
 	struct mc_command cmd = { 0 };
 
@@ -1490,7 +1160,7 @@ int dpni_add_fs_entry(struct fsl_mc_io *mc_io,
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_ADD_FS_ENT,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_ADD_FS_ENTRY(cmd, tc_id, cfg, flow_id);
+	DPNI_CMD_ADD_FS_ENTRY(cmd, cfg, tc_id, index, action);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
@@ -1531,72 +1201,6 @@ int dpni_clear_fs_entries(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_vlan_insertion(struct fsl_mc_io *mc_io,
-			    uint32_t cmd_flags,
-			    uint16_t token,
-			    int en)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_VLAN_INSERTION,
-					  cmd_flags, token);
-	DPNI_CMD_SET_VLAN_INSERTION(cmd, en);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_set_vlan_removal(struct fsl_mc_io *mc_io,
-			  uint32_t cmd_flags,
-			  uint16_t token,
-			  int en)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_VLAN_REMOVAL,
-					  cmd_flags, token);
-	DPNI_CMD_SET_VLAN_REMOVAL(cmd, en);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_set_ipr(struct fsl_mc_io *mc_io,
-		 uint32_t cmd_flags,
-		 uint16_t token,
-		 int en)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_IPR,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_IPR(cmd, en);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_set_ipf(struct fsl_mc_io *mc_io,
-		 uint32_t cmd_flags,
-		 uint16_t token,
-		 int en)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_IPF,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_IPF(cmd, en);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
 int dpni_set_rx_tc_policing(struct fsl_mc_io	*mc_io,
 			    uint32_t		cmd_flags,
 			    uint16_t		token,
@@ -1656,81 +1260,48 @@ void dpni_extract_early_drop(struct dpni_early_drop_cfg *cfg,
 	DPNI_EXT_EARLY_DROP(ext_params, cfg);
 }
 
-int dpni_set_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
-			      uint32_t		cmd_flags,
-			      uint16_t		token,
-			      uint8_t		tc_id,
-			      uint64_t		early_drop_iova)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_RX_TC_EARLY_DROP,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_RX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_get_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
-			      uint32_t		cmd_flags,
-			      uint16_t		token,
-			      uint8_t		tc_id,
-			      uint64_t		early_drop_iova)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_TC_EARLY_DROP,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_GET_RX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_set_tx_tc_early_drop(struct fsl_mc_io	*mc_io,
+int dpni_set_early_drop(struct fsl_mc_io	*mc_io,
 			      uint32_t		cmd_flags,
 			      uint16_t		token,
+			enum dpni_queue_type	qtype,
 			      uint8_t		tc_id,
 			      uint64_t		early_drop_iova)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_TC_EARLY_DROP,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_EARLY_DROP,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_TX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova);
+	DPNI_CMD_SET_EARLY_DROP(cmd, qtype, tc_id, early_drop_iova);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_tx_tc_early_drop(struct fsl_mc_io	*mc_io,
+int dpni_get_early_drop(struct fsl_mc_io	*mc_io,
 			      uint32_t		cmd_flags,
 			      uint16_t		token,
+			enum dpni_queue_type	qtype,
 			      uint8_t		tc_id,
 			      uint64_t		early_drop_iova)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_TC_EARLY_DROP,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_EARLY_DROP,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_GET_TX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova);
+	DPNI_CMD_GET_EARLY_DROP(cmd, qtype, tc_id, early_drop_iova);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+int dpni_set_congestion_notification(struct fsl_mc_io	*mc_io,
 					   uint32_t		cmd_flags,
 					   uint16_t		token,
+				     enum dpni_queue_type qtype,
 					   uint8_t		tc_id,
 			const struct dpni_congestion_notification_cfg *cfg)
 {
@@ -1738,18 +1309,19 @@ int dpni_set_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(
-			DPNI_CMDID_SET_RX_TC_CONGESTION_NOTIFICATION,
+			DPNI_CMDID_SET_CONGESTION_NOTIFICATION,
 			cmd_flags,
 			token);
-	DPNI_CMD_SET_RX_TC_CONGESTION_NOTIFICATION(cmd, tc_id, cfg);
+	DPNI_CMD_SET_CONGESTION_NOTIFICATION(cmd, qtype, tc_id, cfg);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+int dpni_get_congestion_notification(struct fsl_mc_io	*mc_io,
 					   uint32_t		cmd_flags,
 					   uint16_t		token,
+				     enum dpni_queue_type qtype,
 					   uint8_t		tc_id,
 				struct dpni_congestion_notification_cfg *cfg)
 {
@@ -1758,150 +1330,179 @@ int dpni_get_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(
-			DPNI_CMDID_GET_RX_TC_CONGESTION_NOTIFICATION,
+			DPNI_CMDID_GET_CONGESTION_NOTIFICATION,
 			cmd_flags,
 			token);
-	DPNI_CMD_GET_RX_TC_CONGESTION_NOTIFICATION(cmd, tc_id);
+	DPNI_CMD_GET_CONGESTION_NOTIFICATION(cmd, qtype, tc_id);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
 	if (err)
 		return err;
 
-	DPNI_RSP_GET_RX_TC_CONGESTION_NOTIFICATION(cmd, cfg);
+	DPNI_RSP_GET_CONGESTION_NOTIFICATION(cmd, cfg);
 
 	return 0;
 }
 
-int dpni_set_tx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
-					   uint32_t		cmd_flags,
-					   uint16_t		token,
-					   uint8_t		tc_id,
-			const struct dpni_congestion_notification_cfg *cfg)
+int dpni_get_api_version(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
+			   uint16_t *major_ver,
+			   uint16_t *minor_ver)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_API_VERSION,
+					cmd_flags,
+					0);
+
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	get_mc_cmd_object_api_ver(&cmd, major_ver, minor_ver);
+
+	return 0;
+}
+
+int dpni_set_queue(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		   enum dpni_queue_type qtype,
+			 uint8_t tc,
+			 uint8_t index,
+		   uint8_t options,
+		     const struct dpni_queue *queue)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(
-			DPNI_CMDID_SET_TX_TC_CONGESTION_NOTIFICATION,
-			cmd_flags,
-			token);
-	DPNI_CMD_SET_TX_TC_CONGESTION_NOTIFICATION(cmd, tc_id, cfg);
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_QUEUE,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_QUEUE(cmd, qtype, tc, index, options, queue);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_tx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
-					   uint32_t		cmd_flags,
-					   uint16_t		token,
-					   uint8_t		tc_id,
-				struct dpni_congestion_notification_cfg *cfg)
+int dpni_get_queue(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		   enum dpni_queue_type qtype,
+			 uint8_t tc,
+			 uint8_t index,
+		   struct dpni_queue *queue,
+		   struct dpni_queue_id *qid)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(
-			DPNI_CMDID_GET_TX_TC_CONGESTION_NOTIFICATION,
-			cmd_flags,
-			token);
-	DPNI_CMD_GET_TX_TC_CONGESTION_NOTIFICATION(cmd, tc_id);
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_QUEUE,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_GET_QUEUE(cmd, qtype, tc, index);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
 	if (err)
 		return err;
 
-	DPNI_RSP_GET_TX_TC_CONGESTION_NOTIFICATION(cmd, cfg);
+	/* retrieve response parameters */
+	DPNI_RSP_GET_QUEUE(cmd, queue, qid);
 
 	return 0;
 }
 
-int dpni_set_tx_conf(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     uint16_t		flow_id,
-		     const struct dpni_tx_conf_cfg	*cfg)
+int dpni_get_statistics(struct fsl_mc_io *mc_io,
+			uint32_t cmd_flags,
+			uint16_t token,
+			uint8_t page,
+			union dpni_statistics *stat)
 {
 	struct mc_command cmd = { 0 };
+	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_STATISTICS,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_SET_TX_CONF(cmd, flow_id, cfg);
+	DPNI_CMD_GET_STATISTICS(cmd, page);
 
 	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPNI_RSP_GET_STATISTICS(cmd, stat);
+
+	return 0;
 }
 
-int dpni_get_tx_conf(struct fsl_mc_io		*mc_io,
-		     uint32_t			cmd_flags,
-		     uint16_t			token,
-		     uint16_t			flow_id,
-		     struct dpni_tx_conf_attr	*attr)
+int dpni_reset_statistics(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token)
 {
 	struct mc_command cmd = { 0 };
-	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_CONF,
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_RESET_STATISTICS,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_GET_TX_CONF(cmd, flow_id);
 
 	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	DPNI_RSP_GET_TX_CONF(cmd, attr);
-
-	return 0;
+	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_tx_conf_congestion_notification(struct fsl_mc_io	*mc_io,
-					     uint32_t		cmd_flags,
-					     uint16_t		token,
-					     uint16_t		flow_id,
-			 const struct dpni_congestion_notification_cfg *cfg)
+int dpni_set_taildrop(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+			 enum dpni_congestion_point cg_point,
+			 enum dpni_queue_type q_type,
+			 uint8_t tc,
+			 uint8_t q_index,
+			 struct dpni_taildrop *taildrop)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(
-			DPNI_CMDID_SET_TX_CONF_CONGESTION_NOTIFICATION,
-			cmd_flags,
-			token);
-	DPNI_CMD_SET_TX_CONF_CONGESTION_NOTIFICATION(cmd, flow_id, cfg);
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TAILDROP,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_TAILDROP(cmd, cg_point, q_type, tc, q_index, taildrop);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_get_tx_conf_congestion_notification(struct fsl_mc_io	*mc_io,
-					     uint32_t		cmd_flags,
-					     uint16_t		token,
-					     uint16_t		flow_id,
-				 struct dpni_congestion_notification_cfg *cfg)
+int dpni_get_taildrop(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+			 enum dpni_congestion_point cg_point,
+			 enum dpni_queue_type q_type,
+			 uint8_t tc,
+			 uint8_t q_index,
+			 struct dpni_taildrop *taildrop)
 {
 	struct mc_command cmd = { 0 };
 	int err;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(
-				DPNI_CMDID_GET_TX_CONF_CONGESTION_NOTIFICATION,
-				cmd_flags,
-				token);
-	DPNI_CMD_GET_TX_CONF_CONGESTION_NOTIFICATION(cmd, flow_id);
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TAILDROP,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_GET_TAILDROP(cmd, cg_point, q_type, tc, q_index);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
 	if (err)
 		return err;
 
-	DPNI_RSP_GET_TX_CONF_CONGESTION_NOTIFICATION(cmd, cfg);
+	/* retrieve response parameters */
+	DPNI_RSP_GET_TAILDROP(cmd, taildrop);
 
 	return 0;
 }
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpni.h b/drivers/staging/fsl-dpaa2/ethernet/dpni.h
index fca426d..3767d31 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpni.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpni.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -57,19 +57,53 @@ struct fsl_mc_io;
 #define DPNI_MAX_SP				2
 
 /**
- * All traffic classes considered; see dpni_set_rx_flow()
+ * All traffic classes considered; see dpni_set_queue()
  */
 #define DPNI_ALL_TCS				(uint8_t)(-1)
 /**
- * All flows within traffic class considered; see dpni_set_rx_flow()
+ * All flows within traffic class considered; see dpni_set_queue()
  */
 #define DPNI_ALL_TC_FLOWS			(uint16_t)(-1)
 /**
- * Generate new flow ID; see dpni_set_tx_flow()
+ * Generate new flow ID; see dpni_set_queue()
  */
 #define DPNI_NEW_FLOW_ID			(uint16_t)(-1)
-/* use for common tx-conf queue; see dpni_set_tx_conf_<x>() */
-#define DPNI_COMMON_TX_CONF			(uint16_t)(-1)
+/**
+ * Tx traffic is always released to a buffer pool on transmit, there are no
+ * resources allocated to have the frames confirmed back to the source after
+ * transmission.
+ */
+#define DPNI_OPT_TX_FRM_RELEASE			0x000001
+/**
+ * Disables support for MAC address filtering for addresses other than primary
+ * MAC address. This affects both unicast and multicast. Promiscuous mode can
+ * still be enabled/disabled for both unicast and multicast. If promiscuous mode
+ * is disabled, only traffic matching the primary MAC address will be accepted.
+ */
+#define DPNI_OPT_NO_MAC_FILTER			0x000002
+/**
+ * Allocate policers for this DPNI. They can be used to rate-limit traffic per
+ * traffic class (TC) basis.
+ */
+#define DPNI_OPT_HAS_POLICING			0x000004
+/**
+ * Congestion can be managed in several ways, allowing the buffer pool to
+ * deplete on ingress, taildrop on each queue or use congestion groups for sets
+ * of queues. If set, it configures a single congestion groups across all TCs.
+ * If reset, a congestion group is allocated for each TC. Only relevant if the
+ * DPNI has multiple traffic classes.
+ */
+#define DPNI_OPT_SHARED_CONGESTION		0x000008
+/**
+ * Enables TCAM for Flow Steering and QoS look-ups. If not specified, all
+ * look-ups are exact match. Note that TCAM is not available on LS1088 and its
+ * variants. Setting this bit on these SoCs will trigger an error.
+ */
+#define DPNI_OPT_HAS_KEY_MASKING		0x000010
+/**
+ * Disables the flow steering table.
+ */
+#define DPNI_OPT_NO_FS					0x000020
 
 /**
  * dpni_open() - Open a control session for the specified object
@@ -108,123 +142,6 @@ int dpni_close(struct fsl_mc_io	*mc_io,
 	       uint32_t		cmd_flags,
 	       uint16_t		token);
 
-/* DPNI configuration options */
-
-/**
- * Allow different distribution key profiles for different traffic classes;
- * if not set, a single key profile is assumed
- */
-#define DPNI_OPT_ALLOW_DIST_KEY_PER_TC		0x00000001
-
-/**
- * Disable all non-error transmit confirmation; error frames are reported
- * back to a common Tx error queue
- */
-#define DPNI_OPT_TX_CONF_DISABLED		0x00000002
-
-/**
- * Disable per-sender private Tx confirmation/error queue
- */
-#define DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED	0x00000004
-
-/**
- * Support distribution based on hashed key;
- * allows statistical distribution over receive queues in a traffic class
- */
-#define DPNI_OPT_DIST_HASH			0x00000010
-
-/**
- * DEPRECATED - if this flag is selected and and all new 'max_fs_entries' are
- * '0' then backward compatibility is preserved;
- * Support distribution based on flow steering;
- * allows explicit control of distribution over receive queues in a traffic
- * class
- */
-#define DPNI_OPT_DIST_FS			0x00000020
-
-/**
- * Unicast filtering support
- */
-#define DPNI_OPT_UNICAST_FILTER			0x00000080
-/**
- * Multicast filtering support
- */
-#define DPNI_OPT_MULTICAST_FILTER		0x00000100
-/**
- * VLAN filtering support
- */
-#define DPNI_OPT_VLAN_FILTER			0x00000200
-/**
- * Support IP reassembly on received packets
- */
-#define DPNI_OPT_IPR				0x00000800
-/**
- * Support IP fragmentation on transmitted packets
- */
-#define DPNI_OPT_IPF				0x00001000
-/**
- * VLAN manipulation support
- */
-#define DPNI_OPT_VLAN_MANIPULATION		0x00010000
-/**
- * Support masking of QoS lookup keys
- */
-#define DPNI_OPT_QOS_MASK_SUPPORT		0x00020000
-/**
- * Support masking of Flow Steering lookup keys
- */
-#define DPNI_OPT_FS_MASK_SUPPORT		0x00040000
-
-/**
- * struct dpni_extended_cfg - Structure representing extended DPNI configuration
- * @tc_cfg: TCs configuration
- * @ipr_cfg: IP reassembly configuration
- */
-struct dpni_extended_cfg {
-	/**
-	 * struct tc_cfg - TC configuration
-	 * @max_dist: Maximum distribution size for Rx traffic class;
-	 *	supported values: 1,2,3,4,6,7,8,12,14,16,24,28,32,48,56,64,96,
-	 *	112,128,192,224,256,384,448,512,768,896,1024;
-	 *	value '0' will be treated as '1'.
-	 *	other unsupported values will be round down to the nearest
-	 *	supported value.
-	 * @max_fs_entries: Maximum FS entries for Rx traffic class;
-	 *	'0' means no support for this TC;
-	 */
-	struct {
-		uint16_t	max_dist;
-		uint16_t	max_fs_entries;
-	} tc_cfg[DPNI_MAX_TC];
-	/**
-	 * struct ipr_cfg - Structure representing IP reassembly configuration
-	 * @max_reass_frm_size: Maximum size of the reassembled frame
-	 * @min_frag_size_ipv4: Minimum fragment size of IPv4 fragments
-	 * @min_frag_size_ipv6: Minimum fragment size of IPv6 fragments
-	 * @max_open_frames_ipv4: Maximum concurrent IPv4 packets in reassembly
-	 *		process
-	 * @max_open_frames_ipv6: Maximum concurrent IPv6 packets in reassembly
-	 *		process
-	 */
-	struct {
-		uint16_t max_reass_frm_size;
-		uint16_t min_frag_size_ipv4;
-		uint16_t min_frag_size_ipv6;
-		uint16_t max_open_frames_ipv4;
-		uint16_t max_open_frames_ipv6;
-	} ipr_cfg;
-};
-
-/**
- * dpni_prepare_extended_cfg() - function prepare extended parameters
- * @cfg: extended structure
- * @ext_cfg_buf: Zeroed 256 bytes of memory before mapping it to DMA
- *
- * This function has to be called before dpni_create()
- */
-int dpni_prepare_extended_cfg(const struct dpni_extended_cfg	*cfg,
-			      uint8_t			*ext_cfg_buf);
-
 /**
  * struct dpni_cfg - Structure representing DPNI configuration
  * @mac_addr: Primary MAC address
@@ -232,62 +149,71 @@ int dpni_prepare_extended_cfg(const struct dpni_extended_cfg	*cfg,
  *		use this structure to change default settings
  */
 struct dpni_cfg {
-	uint8_t mac_addr[6];
-	/**
-	 * struct adv - Advanced parameters
-	 * @options: Mask of available options; use 'DPNI_OPT_<X>' values
-	 * @start_hdr: Selects the packet starting header for parsing;
-	 *		'NET_PROT_NONE' is treated as default: 'NET_PROT_ETH'
-	 * @max_senders: Maximum number of different senders; used as the number
-	 *		of dedicated Tx flows; Non-power-of-2 values are rounded
-	 *		up to the next power-of-2 value as hardware demands it;
-	 *		'0' will be treated as '1'
-	 * @max_tcs: Maximum number of traffic classes (for both Tx and Rx);
-	 *		'0' will e treated as '1'
-	 * @max_unicast_filters: Maximum number of unicast filters;
-	 *			'0' is treated	as '16'
-	 * @max_multicast_filters: Maximum number of multicast filters;
-	 *			'0' is treated as '64'
-	 * @max_qos_entries: if 'max_tcs > 1', declares the maximum entries in
-	 *			the QoS	table; '0' is treated as '64'
-	 * @max_qos_key_size: Maximum key size for the QoS look-up;
-	 *			'0' is treated as '24' which is enough for IPv4
-	 *			5-tuple
-	 * @max_dist_key_size: Maximum key size for the distribution;
-	 *		'0' is treated as '24' which is enough for IPv4 5-tuple
-	 * @max_policers: Maximum number of policers;
-	 *		should be between '0' and max_tcs
-	 * @max_congestion_ctrl: Maximum number of congestion control groups
-	 *		(CGs); covers early drop and congestion notification
-	 *		requirements;
-	 *		should be between '0' and ('max_tcs' + 'max_senders')
-	 * @ext_cfg_iova: I/O virtual address of 256 bytes DMA-able memory
-	 *		filled with the extended configuration by calling
-	 *		dpni_prepare_extended_cfg()
-	 */
-	struct {
-		uint32_t	options;
-		enum net_prot	start_hdr;
-		uint8_t		max_senders;
-		uint8_t		max_tcs;
-		uint8_t		max_unicast_filters;
-		uint8_t		max_multicast_filters;
-		uint8_t		max_vlan_filters;
-		uint8_t		max_qos_entries;
-		uint8_t		max_qos_key_size;
-		uint8_t		max_dist_key_size;
-		uint8_t		max_policers;
-		uint8_t		max_congestion_ctrl;
-		uint64_t	ext_cfg_iova;
-	} adv;
+/**
+ * @options: Any combination of the following options:
+ *	DPNI_OPT_TX_FRM_RELEASE
+ *	DPNI_OPT_NO_MAC_FILTER
+ *	DPNI_OPT_HAS_POLICING
+ *	DPNI_OPT_SHARED_CONGESTION
+ *	DPNI_OPT_HAS_KEY_MASKING
+ *	DPNI_OPT_NO_FS
+ * @fs_entries: Number of entries in the flow steering table.
+ *	This table is used to select the ingress queue for ingress traffic,
+ *	targeting a GPP core or another. In addition it can	be used to
+ *	discard traffic that matches the set rule. It is either an exact
+ *	match table or a TCAM table, depending on DPNI_OPT_ HAS_KEY_MASKING
+ *	bit in OPTIONS field. This field is ignored if DPNI_OPT_NO_FS bit is
+ *	set in OPTIONS field. Otherwise, value 0 defaults to 64.
+ *	Maximum supported value is 1024.
+ *	Note that the total number of entries is limited on the SoC to as
+ *	low as 512 entries if TCAM is used.
+ * @vlan_filter_entries: Number of entries in the VLAN address filtering
+ *	table. This is an exact match table used to filter ingress traffic
+ *	based on VLAN IDs. Value 0 disables VLAN filtering.
+ *	Maximum supported value is 16.
+ * @mac_filter_entries: Number of entries in the MAC address filtering
+ *	table. This is an exact match table and allows both unicast and
+ *	multicast entries. The primary MAC address of the network interface
+ *	is not part of this table, this contains only entries in addition to
+ *	it. This field is ignored if DPNI_OPT_ NO_MAC_FILTER is set in
+ *	OPTIONS field. Otherwise, value 0 defaults to 80. Maximum supported
+ *	value is 80.
+ * @num_queues: Number of Tx and Rx queues used for traffic distribution.
+ *	This is orthogonal to QoS and is only used to distribute traffic to
+ *	multiple GPP cores. This configuration affects the number of Tx
+ *	queues (logical FQs, all associated
+ *	with a single CEETM queue), Rx queues and Tx confirmation queues,
+ *	if applicable. Value 0 defaults to one queue. Maximum supported
+ *	value is 8.
+ * @num_tcs: Number of traffic classes (TCs), reserved for the DPNI. TCs can
+ *	have different priority levels for the purpose of Tx scheduling (see
+ *	DPNI_SET_TX_SELECTION), different BPs (DPNI_ SET_POOLS), policers.
+ *	There are dedicated QM queues for traffic classes (including class
+ *	queues on Tx). Value 0 defaults to one TC. Maximum supported value
+ *	is 8.
+ * @qos_entries: Number of entries in the QoS classification table. This
+ *	table is used to select the TC for ingress traffic. It is either an
+ *	exact match or a TCAM table, depending on DPNI_OPT_ HAS_KEY_MASKING
+ *	bit in OPTIONS field. This field is ignored if the DPNI has a single
+ *	TC. Otherwise, a value of 0 defaults to 64. Maximum supported value
+ *	is 64.
+ */
+	uint32_t options;
+	uint16_t fs_entries;
+	uint8_t  vlan_filter_entries;
+	uint8_t  mac_filter_entries;
+	uint8_t  num_queues;
+	uint8_t  num_tcs;
+	uint8_t  qos_entries;
 };
 
 /**
  * dpni_create() - Create the DPNI object
  * @mc_io:	Pointer to MC portal's I/O object
+ * @dprc_token:	Parent container token; '0' for default container
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
- * @token:	Returned token; use in subsequent API calls
+ * @obj_id: returned object id
  *
  * Create the DPNI object, allocate required resources and
  * perform required initialization.
@@ -295,31 +221,39 @@ struct dpni_cfg {
  * The object can be created either by declaring it in the
  * DPL file, or by calling this function.
  *
- * This function returns a unique authentication token,
- * associated with the specific object ID and the specific MC
- * portal; this token must be used in all subsequent calls to
- * this specific object. For objects that are created using the
- * DPL file, call dpni_open() function to get an authentication
- * token first.
+ * The function accepts an authentication token of a parent
+ * container that this object should be assigned to. The token
+ * can be '0' so the object will be assigned to the default container.
+ * The newly created object can be opened with the returned
+ * object id and using the container's associated tokens and MC portals.
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpni_create(struct fsl_mc_io	*mc_io,
-		uint32_t		cmd_flags,
+		uint16_t	dprc_token,
+		uint32_t	cmd_flags,
 		const struct dpni_cfg	*cfg,
-		uint16_t		*token);
+		uint32_t	*obj_id);
 
 /**
  * dpni_destroy() - Destroy the DPNI object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @dprc_token: Parent container token; '0' for default container
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
+ * @object_id:	The object id; it must be a valid id within the container that
+ * created this object;
+ *
+ * The function accepts the authentication token of the parent container that
+ * created the object (not the one that currently owns the object). The object
+ * is searched within parent using the provided 'object_id'.
+ * All tokens to the object must be closed before calling destroy.
  *
  * Return:	'0' on Success; error code otherwise.
  */
 int dpni_destroy(struct fsl_mc_io	*mc_io,
-		 uint32_t		cmd_flags,
-		 uint16_t		token);
+		uint16_t	dprc_token,
+		uint32_t	cmd_flags,
+		uint32_t	object_id);
 
 /**
  * struct dpni_pools_cfg - Structure representing buffer pools configuration
@@ -585,49 +519,40 @@ int dpni_clear_irq_status(struct fsl_mc_io	*mc_io,
 
 /**
  * struct dpni_attr - Structure representing DPNI attributes
- * @id: DPNI object ID
- * @version: DPNI version
- * @start_hdr: Indicates the packet starting header for parsing
- * @options: Mask of available options; reflects the value as was given in
- *		object's creation
- * @max_senders: Maximum number of different senders; used as the number
- *		of dedicated Tx flows;
- * @max_tcs: Maximum number of traffic classes (for both Tx and Rx)
- * @max_unicast_filters: Maximum number of unicast filters
- * @max_multicast_filters: Maximum number of multicast filters
- * @max_vlan_filters: Maximum number of VLAN filters
- * @max_qos_entries: if 'max_tcs > 1', declares the maximum entries in QoS table
- * @max_qos_key_size: Maximum key size for the QoS look-up
- * @max_dist_key_size: Maximum key size for the distribution look-up
- * @max_policers: Maximum number of policers;
- * @max_congestion_ctrl: Maximum number of congestion control groups (CGs);
- * @ext_cfg_iova: I/O virtual address of 256 bytes DMA-able memory;
- *	call dpni_extract_extended_cfg() to extract the extended configuration
+ * @options: Any combination of the following options:
+ *		DPNI_OPT_TX_FRM_RELEASE
+ *		DPNI_OPT_NO_MAC_FILTER
+ *		DPNI_OPT_HAS_POLICING
+ *		DPNI_OPT_SHARED_CONGESTION
+ *		DPNI_OPT_HAS_KEY_MASKING
+ *		DPNI_OPT_NO_FS
+ * @num_queues: Number of Tx and Rx queues used for traffic distribution.
+ * @num_tcs: Number of traffic classes (TCs), reserved for the DPNI.
+ * @mac_filter_entries: Number of entries in the MAC address filtering
+ *		table.
+ * @vlan_filter_entries: Number of entries in the VLAN address filtering
+ *		table.
+ * @qos_entries: Number of entries in the QoS classification table.
+ * @fs_entries: Number of entries in the flow steering table.
+ * @qos_key_size: Size, in bytes, of the QoS look-up key. Defining a key larger
+ *		than this when adding QoS entries will result in an error.
+ * @fs_key_size: Size, in bytes, of the flow steering look-up key. Defining a
+ *		key larger than this when composing the hash + FS key will
+ *		result in an error.
+ * @wriop_version: Version of WRIOP HW block.  The 3 version values are stored
+ *		on 6, 5, 5 bits respectively.
  */
 struct dpni_attr {
-	int		id;
-	/**
-	 * struct version - DPNI version
-	 * @major: DPNI major version
-	 * @minor: DPNI minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
-	enum net_prot	start_hdr;
-	uint32_t	options;
-	uint8_t		max_senders;
-	uint8_t		max_tcs;
-	uint8_t		max_unicast_filters;
-	uint8_t		max_multicast_filters;
-	uint8_t		max_vlan_filters;
-	uint8_t		max_qos_entries;
-	uint8_t		max_qos_key_size;
-	uint8_t		max_dist_key_size;
-	uint8_t		max_policers;
-	uint8_t		max_congestion_ctrl;
-	uint64_t	ext_cfg_iova;
+	uint32_t options;
+	uint8_t  num_queues;
+	uint8_t  num_tcs;
+	uint8_t  mac_filter_entries;
+	uint8_t  vlan_filter_entries;
+	uint8_t  qos_entries;
+	uint16_t fs_entries;
+	uint8_t  qos_key_size;
+	uint8_t  fs_key_size;
+	uint16_t wriop_version;
 };
 
 /**
@@ -645,16 +570,6 @@ int dpni_get_attributes(struct fsl_mc_io	*mc_io,
 			struct dpni_attr	*attr);
 
 /**
- * dpni_extract_extended_cfg() - extract the extended parameters
- * @cfg: extended structure
- * @ext_cfg_buf: 256 bytes of DMA-able memory
- *
- * This function has to be called after dpni_get_attributes()
- */
-int dpni_extract_extended_cfg(struct dpni_extended_cfg	*cfg,
-			      const uint8_t		*ext_cfg_buf);
-
-/**
  * DPNI errors
  */
 
@@ -782,68 +697,20 @@ struct dpni_buffer_layout {
 };
 
 /**
- * dpni_get_rx_buffer_layout() - Retrieve Rx buffer layout attributes.
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @layout:	Returns buffer layout attributes
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_rx_buffer_layout(struct fsl_mc_io		*mc_io,
-			      uint32_t			cmd_flags,
-			      uint16_t			token,
-			      struct dpni_buffer_layout	*layout);
-
-/**
- * dpni_set_rx_buffer_layout() - Set Rx buffer layout configuration.
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @layout:	Buffer layout configuration
- *
- * Return:	'0' on Success; Error code otherwise.
- *
- * @warning	Allowed only when DPNI is disabled
- */
-int dpni_set_rx_buffer_layout(struct fsl_mc_io			*mc_io,
-			      uint32_t				cmd_flags,
-			      uint16_t				token,
-			      const struct dpni_buffer_layout	*layout);
-
-/**
- * dpni_get_tx_buffer_layout() - Retrieve Tx buffer layout attributes.
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @layout:	Returns buffer layout attributes
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_tx_buffer_layout(struct fsl_mc_io		*mc_io,
-			      uint32_t			cmd_flags,
-			      uint16_t			token,
-			      struct dpni_buffer_layout	*layout);
-
-/**
- * dpni_set_tx_buffer_layout() - Set Tx buffer layout configuration.
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @layout:	Buffer layout configuration
- *
- * Return:	'0' on Success; Error code otherwise.
- *
- * @warning	Allowed only when DPNI is disabled
- */
-int dpni_set_tx_buffer_layout(struct fsl_mc_io			*mc_io,
-			      uint32_t				cmd_flags,
-			      uint16_t				token,
-			      const struct dpni_buffer_layout	*layout);
+ * enum dpni_queue_type - Identifies a type of queue targeted by the command
+ * @DPNI_QUEUE_RX: Rx queue
+ * @DPNI_QUEUE_TX: Tx queue
+ * @DPNI_QUEUE_TX_CONFIRM: Tx confirmation queue
+ * @DPNI_QUEUE_RX_ERR: Rx error queue
+ */enum dpni_queue_type {
+	DPNI_QUEUE_RX,
+	DPNI_QUEUE_TX,
+	DPNI_QUEUE_TX_CONFIRM,
+	DPNI_QUEUE_RX_ERR,
+};
 
 /**
- * dpni_get_tx_conf_buffer_layout() - Retrieve Tx confirmation buffer layout
- *				attributes.
+ * dpni_get_rx_buffer_layout() - Retrieve Rx buffer layout attributes.
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
@@ -851,14 +718,14 @@ int dpni_set_tx_buffer_layout(struct fsl_mc_io			*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io		*mc_io,
+int dpni_get_buffer_layout(struct fsl_mc_io			*mc_io,
 				   uint32_t			cmd_flags,
 				   uint16_t			token,
+				   enum dpni_queue_type		qtype,
 				   struct dpni_buffer_layout	*layout);
 
 /**
- * dpni_set_tx_conf_buffer_layout() - Set Tx confirmation buffer layout
- *					configuration.
+ * dpni_set_rx_buffer_layout() - Set Rx buffer layout configuration.
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
@@ -868,66 +735,65 @@ int dpni_get_tx_conf_buffer_layout(struct fsl_mc_io		*mc_io,
  *
  * @warning	Allowed only when DPNI is disabled
  */
-int dpni_set_tx_conf_buffer_layout(struct fsl_mc_io		   *mc_io,
+int dpni_set_buffer_layout(struct fsl_mc_io			   *mc_io,
 				   uint32_t			   cmd_flags,
 				   uint16_t			   token,
+				   enum dpni_queue_type		   qtype,
 				   const struct dpni_buffer_layout *layout);
 
 /**
- * dpni_set_l3_chksum_validation() - Enable/disable L3 checksum validation
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @en:		Set to '1' to enable; '0' to disable
- *
- * Return:	'0' on Success; Error code otherwise.
+ * enum dpni_offload - Identifies a type of offload targeted by the command
+ * @DPNI_OFF_RX_L3_CSUM: Rx L3 checksum validation
+ * @DPNI_OFF_RX_L4_CSUM: Rx L4 checksum validation
+ * @DPNI_OFF_TX_L3_CSUM: Tx L3 checksum generation
+ * @DPNI_OFF_TX_L4_CSUM: Tx L4 checksum generation
  */
-int dpni_set_l3_chksum_validation(struct fsl_mc_io	*mc_io,
-				  uint32_t		cmd_flags,
-				  uint16_t		token,
-				  int			en);
+enum dpni_offload {
+	DPNI_OFF_RX_L3_CSUM,
+	DPNI_OFF_RX_L4_CSUM,
+	DPNI_OFF_TX_L3_CSUM,
+	DPNI_OFF_TX_L4_CSUM,
+};
 
 /**
- * dpni_get_l3_chksum_validation() - Get L3 checksum validation mode
+ * dpni_set_offload() - Set DPNI offload configuration.
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @en:		Returns '1' if enabled; '0' otherwise
+ * @type:	Type of DPNI offload
+ * @config:	Offload configuration.
+ *			For checksum offloads, non-zero value enables
+ *			the offload.
  *
  * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_l3_chksum_validation(struct fsl_mc_io	*mc_io,
-				  uint32_t		cmd_flags,
-				  uint16_t		token,
-				  int			*en);
-
-/**
- * dpni_set_l4_chksum_validation() - Enable/disable L4 checksum validation
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @en:		Set to '1' to enable; '0' to disable
  *
- * Return:	'0' on Success; Error code otherwise.
+ * @warning	Allowed only when DPNI is disabled
  */
-int dpni_set_l4_chksum_validation(struct fsl_mc_io	*mc_io,
-				  uint32_t		cmd_flags,
-				  uint16_t		token,
-				  int			en);
+int dpni_set_offload(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		     enum dpni_offload type,
+		     uint32_t config);
 
 /**
- * dpni_get_l4_chksum_validation() - Get L4 checksum validation mode
+ * dpni_get_offload() - Get DPNI offload configuration.
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @en:		Returns '1' if enabled; '0' otherwise
+ * @type:	Type of DPNI offload
+ * @config:	Offload configuration.
+ *			For checksum offloads, a value of 1 indicates that the
+ *			offload is enabled.
  *
  * Return:	'0' on Success; Error code otherwise.
+ *
+ * @warning	Allowed only when DPNI is disabled
  */
-int dpni_get_l4_chksum_validation(struct fsl_mc_io	*mc_io,
-				  uint32_t		cmd_flags,
-				  uint16_t		token,
-				  int			*en);
+int dpni_get_offload(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		     enum dpni_offload type,
+		     uint32_t *config);
 
 /**
  * dpni_get_qdid() - Get the Queuing Destination ID (QDID) that should be used
@@ -935,6 +801,8 @@ int dpni_get_l4_chksum_validation(struct fsl_mc_io	*mc_io,
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
+ * @qtype:	Type of queue to get QDID for.  For applications lookig to
+ *		transmit traffic this should be set to DPNI_QUEUE_TX.
  * @qdid:	Returned virtual QDID value that should be used as an argument
  *			in all enqueue operations
  *
@@ -943,6 +811,7 @@ int dpni_get_l4_chksum_validation(struct fsl_mc_io	*mc_io,
 int dpni_get_qdid(struct fsl_mc_io	*mc_io,
 		  uint32_t		cmd_flags,
 		  uint16_t		token,
+		  enum dpni_queue_type	qtype,
 		  uint16_t		*qdid);
 
 /**
@@ -984,67 +853,73 @@ int dpni_get_tx_data_offset(struct fsl_mc_io	*mc_io,
 			    uint16_t		token,
 			    uint16_t		*data_offset);
 
-/**
- * enum dpni_counter - DPNI counter types
- * @DPNI_CNT_ING_FRAME: Counts ingress frames
- * @DPNI_CNT_ING_BYTE: Counts ingress bytes
- * @DPNI_CNT_ING_FRAME_DROP: Counts ingress frames dropped due to explicit
- *		'drop' setting
- * @DPNI_CNT_ING_FRAME_DISCARD: Counts ingress frames discarded due to errors
- * @DPNI_CNT_ING_MCAST_FRAME: Counts ingress multicast frames
- * @DPNI_CNT_ING_MCAST_BYTE: Counts ingress multicast bytes
- * @DPNI_CNT_ING_BCAST_FRAME: Counts ingress broadcast frames
- * @DPNI_CNT_ING_BCAST_BYTES: Counts ingress broadcast bytes
- * @DPNI_CNT_EGR_FRAME: Counts egress frames
- * @DPNI_CNT_EGR_BYTE: Counts egress bytes
- * @DPNI_CNT_EGR_FRAME_DISCARD: Counts egress frames discarded due to errors
- */
-enum dpni_counter {
-	DPNI_CNT_ING_FRAME = 0x0,
-	DPNI_CNT_ING_BYTE = 0x1,
-	DPNI_CNT_ING_FRAME_DROP = 0x2,
-	DPNI_CNT_ING_FRAME_DISCARD = 0x3,
-	DPNI_CNT_ING_MCAST_FRAME = 0x4,
-	DPNI_CNT_ING_MCAST_BYTE = 0x5,
-	DPNI_CNT_ING_BCAST_FRAME = 0x6,
-	DPNI_CNT_ING_BCAST_BYTES = 0x7,
-	DPNI_CNT_EGR_FRAME = 0x8,
-	DPNI_CNT_EGR_BYTE = 0x9,
-	DPNI_CNT_EGR_FRAME_DISCARD = 0xa
-};
-
-/**
- * dpni_get_counter() - Read a specific DPNI counter
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @counter:	The requested counter
- * @value:	Returned counter's current value
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_counter(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     enum dpni_counter	counter,
-		     uint64_t		*value);
+#define DPNI_STATISTICS_CNT		7
 
-/**
- * dpni_set_counter() - Set (or clear) a specific DPNI counter
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @counter:	The requested counter
- * @value:	New counter value; typically pass '0' for resetting
- *			the counter.
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_counter(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     enum dpni_counter	counter,
-		     uint64_t		value);
+union dpni_statistics {
+	/**
+	 * struct page_0 - Page_0 statistics structure
+	 * @ingress_all_frames: Ingress frame count
+	 * @ingress_all_bytes: Ingress byte count
+	 * @ingress_multicast_frames: Ingress multicast frame count
+	 * @ingress_multicast_bytes: Ingress multicast byte count
+	 * @ingress_broadcast_frames: Ingress broadcast frame count
+	 * @ingress_broadcast_bytes: Ingress broadcast byte count
+	 */
+	struct {
+		uint64_t ingress_all_frames;
+		uint64_t ingress_all_bytes;
+		uint64_t ingress_multicast_frames;
+		uint64_t ingress_multicast_bytes;
+		uint64_t ingress_broadcast_frames;
+		uint64_t ingress_broadcast_bytes;
+	} page_0;
+	/**
+	 * struct page_1 - Page_1 statistics structure
+	 * @egress_all_frames: Egress frame count
+	 * @egress_all_bytes: Egress byte count
+	 * @egress_multicast_frames: Egress multicast frame count
+	 * @egress_multicast_bytes: Egress multicast byte count
+	 * @egress_broadcast_frames: Egress broadcast frame count
+	 * @egress_broadcast_bytes: Egress broadcast byte count
+	 */
+	struct {
+		uint64_t egress_all_frames;
+		uint64_t egress_all_bytes;
+		uint64_t egress_multicast_frames;
+		uint64_t egress_multicast_bytes;
+		uint64_t egress_broadcast_frames;
+		uint64_t egress_broadcast_bytes;
+	} page_1;
+	/**
+	 * struct page_2 - Page_2 statistics structure
+	 * @ingress_filtered_frames: Ingress filtered frame count
+	 * @ingress_discarded_frames: Ingress discarded frame count
+	 * @ingress_nobuffer_discards: Ingress discarded frame count
+	 *				due to lack of buffers
+	 * @egress_discarded_frames: Egress discarded frame count
+	 * @egress_confirmed_frames: Egress confirmed frame count
+	 */
+	struct {
+		uint64_t ingress_filtered_frames;
+		uint64_t ingress_discarded_frames;
+		uint64_t ingress_nobuffer_discards;
+		uint64_t egress_discarded_frames;
+		uint64_t egress_confirmed_frames;
+	} page_2;
+	/**
+	 * struct raw - raw statistics structure
+	 * @counter0:
+	 * @counter1:
+	 * @counter2:
+	 * @counter3:
+	 * @counter4:
+	 * @counter5:
+	 * @counter6: Reserved
+	 */
+	struct {
+		uint64_t counter[DPNI_STATISTICS_CNT];
+	} raw;
+};
 
 /**
  * Enable auto-negotiation
@@ -1330,7 +1205,24 @@ int dpni_clear_mac_filters(struct fsl_mc_io	*mc_io,
 			   int			multicast);
 
 /**
- * dpni_set_vlan_filters() - Enable/disable VLAN filtering mode
+ * dpni_get_port_mac_addr() - Retrieve MAC address associated to the physical
+ *		port the DPNI is attached to
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @mac_addr:	MAC address of the physical port, if any, otherwise 0
+ *
+ * The primary MAC address is not cleared by this operation.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpni_get_port_mac_addr(struct fsl_mc_io	*mc_io,
+			   uint32_t		cmd_flags,
+			   uint16_t		token,
+			   uint8_t		mac_addr[6]);
+
+/**
+ * dpni_enable_vlan_filter() - Enable/disable VLAN filtering mode
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
@@ -1338,7 +1230,7 @@ int dpni_clear_mac_filters(struct fsl_mc_io	*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_vlan_filters(struct fsl_mc_io	*mc_io,
+int dpni_enable_vlan_filter(struct fsl_mc_io	*mc_io,
 			  uint32_t		cmd_flags,
 			  uint16_t		token,
 			  int			en);
@@ -1406,16 +1298,16 @@ struct dpni_tx_schedule_cfg {
 };
 
 /**
- * struct dpni_tx_selection_cfg - Structure representing transmission
- *	selection configuration
+ * struct dpni_tx_priorities_cfg - Structure representing transmission
+ *	priorities for DPNI TCs
  * @tc_sched: an array of traffic-classes
  */
-struct dpni_tx_selection_cfg {
+struct dpni_tx_priorities_cfg {
 	struct dpni_tx_schedule_cfg tc_sched[DPNI_MAX_TC];
 };
 
 /**
- * dpni_set_tx_selection() - Set transmission selection configuration
+ * dpni_set_tx_priorities() - Set transmission TC priority configuration
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
@@ -1425,10 +1317,10 @@ struct dpni_tx_selection_cfg {
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_tx_selection(struct fsl_mc_io			*mc_io,
+int dpni_set_tx_priorities(struct fsl_mc_io			*mc_io,
 			  uint32_t				cmd_flags,
 			  uint16_t				token,
-			  const struct dpni_tx_selection_cfg	*cfg);
+			  const struct dpni_tx_priorities_cfg	*cfg);
 
 /**
  * enum dpni_dist_mode - DPNI distribution mode
@@ -1703,10 +1595,11 @@ void dpni_extract_early_drop(struct dpni_early_drop_cfg *cfg,
 			     const uint8_t *early_drop_buf);
 
 /**
- * dpni_set_rx_tc_early_drop() - Set Rx traffic class early-drop configuration
+ * dpni_set_early_drop() - Set traffic class early-drop configuration
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
+ * @qtype:	Type of queue - only Rx and Tx types are supported
  * @tc_id:	Traffic class selection (0-7)
  * @early_drop_iova:  I/O virtual address of 256 bytes DMA-able memory filled
  *	with the early-drop configuration by calling dpni_prepare_early_drop()
@@ -1716,9 +1609,10 @@ void dpni_extract_early_drop(struct dpni_early_drop_cfg *cfg,
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpni_set_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
+int dpni_set_early_drop(struct fsl_mc_io	*mc_io,
 			      uint32_t		cmd_flags,
 			      uint16_t		token,
+			      enum dpni_queue_type  qtype,
 			      uint8_t		tc_id,
 			      uint64_t		early_drop_iova);
 
@@ -1727,6 +1621,7 @@ int dpni_set_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
+ * @qtype:	Type of queue - only Rx and Tx types are supported
  * @tc_id:	Traffic class selection (0-7)
  * @early_drop_iova:  I/O virtual address of 256 bytes DMA-able memory
  *
@@ -1735,48 +1630,10 @@ int dpni_set_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpni_get_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
-			      uint32_t		cmd_flags,
-			      uint16_t		token,
-			      uint8_t		tc_id,
-			      uint64_t		early_drop_iova);
-
-/**
- * dpni_set_tx_tc_early_drop() - Set Tx traffic class early-drop configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @tc_id:	Traffic class selection (0-7)
- * @early_drop_iova:  I/O virtual address of 256 bytes DMA-able memory filled
- *	with the early-drop configuration by calling dpni_prepare_early_drop()
- *
- * warning: Before calling this function, call dpni_prepare_early_drop() to
- *			prepare the early_drop_iova parameter
- *
- * Return:	'0' on Success; error code otherwise.
- */
-int dpni_set_tx_tc_early_drop(struct fsl_mc_io	*mc_io,
-			      uint32_t		cmd_flags,
-			      uint16_t		token,
-			      uint8_t		tc_id,
-			      uint64_t		early_drop_iova);
-
-/**
- * dpni_get_tx_tc_early_drop() - Get Tx traffic class early-drop configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @tc_id:	Traffic class selection (0-7)
- * @early_drop_iova:  I/O virtual address of 256 bytes DMA-able memory
- *
- * warning: After calling this function, call dpni_extract_early_drop() to
- *	get the early drop configuration
- *
- * Return:	'0' on Success; error code otherwise.
- */
-int dpni_get_tx_tc_early_drop(struct fsl_mc_io	*mc_io,
+int dpni_get_early_drop(struct fsl_mc_io	*mc_io,
 			      uint32_t		cmd_flags,
 			      uint16_t		token,
+			      enum dpni_queue_type qtype,
 			      uint8_t		tc_id,
 			      uint64_t		early_drop_iova);
 
@@ -1860,7 +1717,7 @@ struct dpni_dest_cfg {
  *	must be 16B aligned; valid only if 'DPNI_CONG_OPT_WRITE_MEM_<X>' is
  *	contained in 'options'
  * @dest_cfg: CSCN can be send to either DPIO or DPCON WQ channel
- * @options: Mask of available options; use 'DPNI_CONG_OPT_<X>' values
+ * @notification_mode: Mask of available options; use 'DPNI_CONG_OPT_<X>' values
  */
 
 struct dpni_congestion_notification_cfg {
@@ -1870,23 +1727,25 @@ struct dpni_congestion_notification_cfg {
 	uint64_t	message_ctx;
 	uint64_t	message_iova;
 	struct dpni_dest_cfg dest_cfg;
-	uint16_t	options;
+	uint16_t	notification_mode;
 };
 
 /**
- * dpni_set_rx_tc_congestion_notification() - Set Rx traffic class congestion
+ * dpni_set_rx_tc_congestion_notification() - Set traffic class congestion
  *	notification configuration
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
+ * @qtype:	Type of queue - Rx, Tx and Tx confirm types are supported
  * @tc_id:	Traffic class selection (0-7)
  * @cfg:	congestion notification configuration
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpni_set_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+int dpni_set_congestion_notification(struct fsl_mc_io		*mc_io,
 					   uint32_t		cmd_flags,
 					   uint16_t		token,
+					   enum dpni_queue_type	qtype,
 					   uint8_t		tc_id,
 			const struct dpni_congestion_notification_cfg *cfg);
 
@@ -1896,48 +1755,16 @@ int dpni_set_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
+ * @qtype:	Type of queue - Rx, Tx and Tx confirm types are supported
  * @tc_id:	Traffic class selection (0-7)
  * @cfg:	congestion notification configuration
  *
  * Return:	'0' on Success; error code otherwise.
  */
-int dpni_get_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
-					   uint32_t		cmd_flags,
-					   uint16_t		token,
-					   uint8_t		tc_id,
-				struct dpni_congestion_notification_cfg *cfg);
-
-/**
- * dpni_set_tx_tc_congestion_notification() - Set Tx traffic class congestion
- *	notification configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @tc_id:	Traffic class selection (0-7)
- * @cfg:	congestion notification configuration
- *
- * Return:	'0' on Success; error code otherwise.
- */
-int dpni_set_tx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
-					   uint32_t		cmd_flags,
-					   uint16_t		token,
-					   uint8_t		tc_id,
-			const struct dpni_congestion_notification_cfg *cfg);
-
-/**
- * dpni_get_tx_tc_congestion_notification() - Get Tx traffic class congestion
- *	notification configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @tc_id:	Traffic class selection (0-7)
- * @cfg:	congestion notification configuration
- *
- * Return:	'0' on Success; error code otherwise.
- */
-int dpni_get_tx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+int dpni_get_congestion_notification(struct fsl_mc_io		*mc_io,
 					   uint32_t		cmd_flags,
 					   uint16_t		token,
+					   enum dpni_queue_type	qtype,
 					   uint8_t		tc_id,
 				struct dpni_congestion_notification_cfg *cfg);
 
@@ -1996,287 +1823,74 @@ struct dpni_flc_cfg {
 };
 
 /**
- * DPNI queue modification options
- */
-
-/**
- * Select to modify the user's context associated with the queue
- */
-#define DPNI_QUEUE_OPT_USER_CTX		0x00000001
-/**
- * Select to modify the queue's destination
- */
-#define DPNI_QUEUE_OPT_DEST		0x00000002
-/** Select to modify the flow-context parameters;
- * not applicable for Tx-conf/Err queues as the FD comes from the user
- */
-#define DPNI_QUEUE_OPT_FLC		0x00000004
-/**
- * Select to modify the queue's order preservation
- */
-#define DPNI_QUEUE_OPT_ORDER_PRESERVATION 0x00000008
-/* Select to modify the queue's tail-drop threshold */
-#define DPNI_QUEUE_OPT_TAILDROP_THRESHOLD 0x00000010
-
-/**
- * struct dpni_queue_cfg - Structure representing queue configuration
- * @options: Flags representing the suggested modifications to the queue;
- *		Use any combination of 'DPNI_QUEUE_OPT_<X>' flags
- * @user_ctx: User context value provided in the frame descriptor of each
- *		dequeued frame; valid only if 'DPNI_QUEUE_OPT_USER_CTX'
- *		is contained in 'options'
- * @dest_cfg: Queue destination parameters;
- *		valid only if 'DPNI_QUEUE_OPT_DEST' is contained in 'options'
- * @flc_cfg: Flow context configuration; in case the TC's distribution
- *		is either NONE or HASH the FLC's settings of flow#0 are used.
- *		in the case of FS (flow-steering) the flow's FLC settings
- *		are used.
- *		valid only if 'DPNI_QUEUE_OPT_FLC' is contained in 'options'
- * @order_preservation_en: enable/disable order preservation;
- *		valid only if 'DPNI_QUEUE_OPT_ORDER_PRESERVATION' is contained
- *		in 'options'
- * @tail_drop_threshold: set the queue's tail drop threshold in bytes;
- *		'0' value disable the threshold; maximum value is 0xE000000;
- *		valid only if 'DPNI_QUEUE_OPT_TAILDROP_THRESHOLD' is contained
- *		in 'options'
- */
-struct dpni_queue_cfg {
-	uint32_t		options;
-	uint64_t		user_ctx;
-	struct dpni_dest_cfg	dest_cfg;
-	struct dpni_flc_cfg	flc_cfg;
-	int			order_preservation_en;
-	uint32_t		tail_drop_threshold;
-};
-
-/**
- * struct dpni_queue_attr - Structure representing queue attributes
- * @user_ctx: User context value provided in the frame descriptor of each
- *	dequeued frame
- * @dest_cfg: Queue destination configuration
- * @flc_cfg: Flow context configuration
- * @order_preservation_en: enable/disable order preservation
- * @tail_drop_threshold: queue's tail drop threshold in bytes;
- * @fqid: Virtual fqid value to be used for dequeue operations
- */
-struct dpni_queue_attr {
-	uint64_t		user_ctx;
-	struct dpni_dest_cfg	dest_cfg;
-	struct dpni_flc_cfg	flc_cfg;
-	int			order_preservation_en;
-	uint32_t		tail_drop_threshold;
-
-	uint32_t		fqid;
-};
-
-/**
- * DPNI Tx flow modification options
- */
-
-/**
- * Select to modify the settings for dedicate Tx confirmation/error
+ * struct dpni_queue - Queue structure
+ * @user_context: User data, presented to the user along with any frames from
+ *				this queue. Not relevant for Tx queues.
+ */
+struct dpni_queue {
+/**
+ * struct destination - Destination structure
+ * @id: ID of the destination, only relevant if DEST_TYPE is > 0.
+ *		Identifies either a DPIO or a DPCON object. Not relevant for
+ *		Tx queues.
+ * @type: May be one of the following:
+ *	0 - No destination, queue can be manually queried, but will not
+ *		push traffic or notifications to a DPIO;
+ *	1 - The destination is a DPIO. When traffic becomes available in
+ *		the queue a FQDAN (FQ data available notification) will be
+ *		generated to selected DPIO;
+ *	2 - The destination is a DPCON. The queue is associated with a
+ *		DPCON object for the purpose of scheduling between multiple
+ *		queues. The DPCON may be independently configured to
+ *		generate notifications. Not relevant for Tx queues.
+ * @hold_active: Hold active, maintains a queue scheduled for longer
+ *		in a DPIO during dequeue to reduce spread of traffic.
+ *		Only relevant if queues are not affined to a single DPIO.
  */
-#define DPNI_TX_FLOW_OPT_TX_CONF_ERROR	0x00000001
-/**
- * Select to modify the L3 checksum generation setting
- */
-#define DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN	0x00000010
-/**
- * Select to modify the L4 checksum generation setting
- */
-#define DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN	0x00000020
-
-/**
- * struct dpni_tx_flow_cfg - Structure representing Tx flow configuration
- * @options: Flags representing the suggested modifications to the Tx flow;
- *	Use any combination 'DPNI_TX_FLOW_OPT_<X>' flags
- * @use_common_tx_conf_queue: Set to '1' to use the common (default) Tx
- *	confirmation and error queue; Set to '0' to use the private
- *	Tx confirmation and error queue; valid only if
- *	'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' wasn't set at DPNI creation
- *	and 'DPNI_TX_FLOW_OPT_TX_CONF_ERROR' is contained in 'options'
- * @l3_chksum_gen: Set to '1' to enable L3 checksum generation; '0' to disable;
- *	valid only if 'DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN' is contained in 'options'
- * @l4_chksum_gen: Set to '1' to enable L4 checksum generation; '0' to disable;
- *	valid only if 'DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN' is contained in 'options'
- */
-struct dpni_tx_flow_cfg {
-	uint32_t	options;
-	int		use_common_tx_conf_queue;
-	int		l3_chksum_gen;
-	int		l4_chksum_gen;
+	struct {
+		uint16_t id;
+		enum dpni_dest type;
+		char hold_active;
+		uint8_t priority;
+	} destination;
+	uint64_t user_context;
+	struct {
+		uint64_t value;
+		char stash_control;
+	} flc;
 };
 
 /**
- * dpni_set_tx_flow() - Set Tx flow configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @flow_id:	Provides (or returns) the sender's flow ID;
- *	for each new sender set (*flow_id) to 'DPNI_NEW_FLOW_ID' to generate
- *	a new flow_id;	this ID should be used as the QDBIN argument
- *	in enqueue operations
- * @cfg:	Tx flow configuration
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_tx_flow(struct fsl_mc_io			*mc_io,
-		     uint32_t				cmd_flags,
-		     uint16_t				token,
-		     uint16_t				*flow_id,
-		     const struct dpni_tx_flow_cfg	*cfg);
-
-/**
- * struct dpni_tx_flow_attr - Structure representing Tx flow attributes
- * @use_common_tx_conf_queue: '1' if using common (default) Tx confirmation and
- *	error queue; '0' if using private Tx confirmation and error queue
- * @l3_chksum_gen: '1' if L3 checksum generation is enabled; '0' if disabled
- * @l4_chksum_gen: '1' if L4 checksum generation is enabled; '0' if disabled
+ * struct dpni_queue_id - Queue identification, used for enqueue commands
+ *				or queue control
+ * @fqid: FQID used for enqueueing to and/or configuration of this specific FQ
+ * @qdbin: Queueing bin, used to enqueue using QDID, DQBIN, QPRI. Only relevant
+ *		for Tx queues.
  */
-struct dpni_tx_flow_attr {
-	int	use_common_tx_conf_queue;
-	int	l3_chksum_gen;
-	int	l4_chksum_gen;
+struct dpni_queue_id {
+	uint32_t fqid;
+	uint16_t qdbin;
 };
 
 /**
- * dpni_get_tx_flow() - Get Tx flow attributes
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @flow_id:	The sender's flow ID, as returned by the
- *	dpni_set_tx_flow() function
- * @attr:	Returned Tx flow attributes
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_tx_flow(struct fsl_mc_io		*mc_io,
-		     uint32_t			cmd_flags,
-		     uint16_t			token,
-		     uint16_t			flow_id,
-		     struct dpni_tx_flow_attr	*attr);
-
-/**
- * struct dpni_tx_conf_cfg - Structure representing Tx conf configuration
- * @errors_only: Set to '1' to report back only error frames;
- *	Set to '0' to confirm transmission/error for all transmitted frames;
- * @queue_cfg: Queue configuration
- */
-struct dpni_tx_conf_cfg {
-	int			errors_only;
-	struct dpni_queue_cfg	queue_cfg;
+ * enum dpni_confirmation_mode - Defines DPNI options supported for Tx
+ * confirmation
+ * @DPNI_CONF_AFFINE: For each Tx queue set associated with a sender there is
+ * an affine Tx Confirmation queue
+ * @DPNI_CONF_SINGLE: All Tx queues are associated with a single Tx
+ * confirmation queue
+ * @DPNI_CONF_DISABLE: Tx frames are not confirmed.  This must be associated
+ * with proper FD set-up to have buffers release to a Buffer Pool, otherwise
+ * buffers will be leaked
+ */
+enum dpni_confirmation_mode {
+	DPNI_CONF_AFFINE,
+	DPNI_CONF_SINGLE,
+	DPNI_CONF_DISABLE,
 };
 
 /**
- * dpni_set_tx_conf() - Set Tx confirmation and error queue configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @flow_id:	The sender's flow ID, as returned by the
- *	dpni_set_tx_flow() function;
- *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
- * @cfg:	Queue configuration
- *
- * If either 'DPNI_OPT_TX_CONF_DISABLED' or
- * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
- * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
- * i.e. only serve the common tx-conf-err queue;
- * if 'DPNI_OPT_TX_CONF_DISABLED' was selected, only error frames are reported
- * back - successfully transmitted frames are not confirmed. Otherwise, all
- * transmitted frames are sent for confirmation.
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_tx_conf(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     uint16_t		flow_id,
-		     const struct dpni_tx_conf_cfg	*cfg);
-
-/**
- * struct dpni_tx_conf_attr - Structure representing Tx conf attributes
- * @errors_only: '1' if only error frames are reported back; '0' if all
- *		transmitted frames are confirmed
- * @queue_attr: Queue attributes
- */
-struct dpni_tx_conf_attr {
-	int			errors_only;
-	struct dpni_queue_attr	queue_attr;
-};
-
-/**
- * dpni_get_tx_conf() - Get Tx confirmation and error queue attributes
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @flow_id:	The sender's flow ID, as returned by the
- *	dpni_set_tx_flow() function;
- *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
- * @attr:	Returned tx-conf attributes
- *
- * If either 'DPNI_OPT_TX_CONF_DISABLED' or
- * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
- * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
- * i.e. only serve the common tx-conf-err queue;
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_tx_conf(struct fsl_mc_io	*mc_io,
-		     uint32_t		cmd_flags,
-		     uint16_t		token,
-		     uint16_t		flow_id,
-		     struct dpni_tx_conf_attr	*attr);
-
-/**
- * dpni_set_tx_conf_congestion_notification() - Set Tx conf congestion
- *	notification configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @flow_id:	The sender's flow ID, as returned by the
- *	dpni_set_tx_flow() function;
- *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
- * @cfg:	congestion notification configuration
- *
- * If either 'DPNI_OPT_TX_CONF_DISABLED' or
- * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
- * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
- * i.e. only serve the common tx-conf-err queue;
- *
- * Return:	'0' on Success; error code otherwise.
- */
-int dpni_set_tx_conf_congestion_notification(struct fsl_mc_io	*mc_io,
-					     uint32_t		cmd_flags,
-					     uint16_t		token,
-					     uint16_t		flow_id,
-			const struct dpni_congestion_notification_cfg *cfg);
-
-/**
- * dpni_get_tx_conf_congestion_notification() - Get Tx conf congestion
- *	notification configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @flow_id:	The sender's flow ID, as returned by the
- *	dpni_set_tx_flow() function;
- *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
- * @cfg:	congestion notification
- *
- * If either 'DPNI_OPT_TX_CONF_DISABLED' or
- * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
- * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
- * i.e. only serve the common tx-conf-err queue;
- *
- * Return:	'0' on Success; error code otherwise.
- */
-int dpni_get_tx_conf_congestion_notification(struct fsl_mc_io	*mc_io,
-					     uint32_t		cmd_flags,
-					     uint16_t		token,
-					     uint16_t		flow_id,
-				struct dpni_congestion_notification_cfg *cfg);
-
-/**
- * dpni_set_tx_conf_revoke() - Tx confirmation revocation
+ * dpni_set_tx_confirmation_mode() - Tx confirmation mode
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
@@ -2284,87 +1898,17 @@ int dpni_get_tx_conf_congestion_notification(struct fsl_mc_io	*mc_io,
  *
  * This function is useful only when 'DPNI_OPT_TX_CONF_DISABLED' is not
  * selected at DPNI creation.
- * Calling this function with 'revoke' set to '1' disables all transmit
+ * Calling this function with 'mode' set to '1' disables all transmit
  * confirmation (including the private confirmation queues), regardless of
  * previous settings; Note that in this case, Tx error frames are still
  * enqueued to the general transmit errors queue.
- * Calling this function with 'revoke' set to '0' restores the previous
- * settings for both general and private transmit confirmation.
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_set_tx_conf_revoke(struct fsl_mc_io		*mc_io,
+int dpni_set_tx_confirmation_mode(struct fsl_mc_io	*mc_io,
 			    uint32_t			cmd_flags,
 			    uint16_t			token,
-			    int			revoke);
-
-/**
- * dpni_set_rx_flow() - Set Rx flow configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @tc_id:	Traffic class selection (0-7);
- *			use 'DPNI_ALL_TCS' to set all TCs and all flows
- * @flow_id:	Rx flow id within the traffic class; use
- *			'DPNI_ALL_TC_FLOWS' to set all flows within
- *			this tc_id; ignored if tc_id is set to
- *			'DPNI_ALL_TCS';
- * @cfg:	Rx flow configuration
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_rx_flow(struct fsl_mc_io			*mc_io,
-		     uint32_t				cmd_flags,
-		     uint16_t				token,
-		     uint8_t				tc_id,
-		     uint16_t				flow_id,
-		     const struct dpni_queue_cfg	*cfg);
-
-/**
- * dpni_get_rx_flow() -	Get Rx flow attributes
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @tc_id:	Traffic class selection (0-7)
- * @flow_id:	Rx flow id within the traffic class
- * @attr:	Returned Rx flow attributes
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_rx_flow(struct fsl_mc_io		*mc_io,
-		     uint32_t			cmd_flags,
-		     uint16_t			token,
-		     uint8_t			tc_id,
-		     uint16_t			flow_id,
-		     struct dpni_queue_attr	*attr);
-
-/**
- * dpni_set_rx_err_queue() - Set Rx error queue configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @cfg:	Queue configuration
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_rx_err_queue(struct fsl_mc_io		*mc_io,
-			  uint32_t			cmd_flags,
-			  uint16_t			token,
-			  const struct dpni_queue_cfg	*cfg);
-
-/**
- * dpni_get_rx_err_queue() - Get Rx error queue attributes
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @attr:	Returned Queue attributes
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_rx_err_queue(struct fsl_mc_io		*mc_io,
-			  uint32_t			cmd_flags,
-			  uint16_t			token,
-			  struct dpni_queue_attr	*attr);
+			    enum dpni_confirmation_mode mode);
 
 /**
  * struct dpni_qos_tbl_cfg - Structure representing QOS table configuration
@@ -2420,6 +1964,9 @@ struct dpni_rule_cfg {
  * @token:	Token of DPNI object
  * @cfg:	QoS rule to add
  * @tc_id:	Traffic class selection (0-7)
+ * @index: Location in the QoS table where to insert the entry. Only relevant
+ *	if MASKING is enabled for QoS classification on this DPNI, it is
+ *	ignored for exact match.
  *
  * Return:	'0' on Success; Error code otherwise.
  */
@@ -2427,7 +1974,8 @@ int dpni_add_qos_entry(struct fsl_mc_io		*mc_io,
 		       uint32_t			cmd_flags,
 		       uint16_t				token,
 		       const struct dpni_rule_cfg	*cfg,
-		       uint8_t				tc_id);
+			   uint8_t tc_id,
+			   uint16_t index);
 
 /**
  * dpni_remove_qos_entry() - Remove QoS mapping entry
@@ -2458,6 +2006,16 @@ int dpni_clear_qos_table(struct fsl_mc_io	*mc_io,
 			 uint32_t		cmd_flags,
 			 uint16_t		token);
 
+#define DPNI_FS_OPT_DISCARD		0x1
+#define DPNI_FS_OPT_SET_FLC		0x2
+#define DPNI_FS_OPT_SET_STASH_CONTROL	0x4
+
+struct dpni_fs_action_cfg {
+	uint64_t flc;
+	uint16_t flow_id;
+	uint16_t options;
+};
+
 /**
  * dpni_add_fs_entry() - Add Flow Steering entry for a specific traffic class
  *			(to select a flow ID)
@@ -2465,18 +2023,21 @@ int dpni_clear_qos_table(struct fsl_mc_io	*mc_io,
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
+ * @index: Location in the QoS table where to insert the entry. Only relevant
+ *	if MASKING is enabled for QoS classification on this DPNI, it is
+ *	ignored for exact match.
  * @cfg:	Flow steering rule to add
- * @flow_id:	Flow id selection (must be smaller than the
- *			distribution size of the traffic class)
+ * @action:	Action to be taken as result of a classification hit
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpni_add_fs_entry(struct fsl_mc_io			*mc_io,
+int dpni_add_fs_entry(struct fsl_mc_io *mc_io,
 		      uint32_t				cmd_flags,
 		      uint16_t				token,
-		      uint8_t				tc_id,
+			  uint8_t				tc_id,
+			  uint16_t				index,
 		      const struct dpni_rule_cfg	*cfg,
-		      uint16_t				flow_id);
+		      const struct dpni_fs_action_cfg	*action);
 
 /**
  * dpni_remove_fs_entry() - Remove Flow Steering entry from a specific
@@ -2511,71 +2072,178 @@ int dpni_clear_fs_entries(struct fsl_mc_io	*mc_io,
 			  uint8_t		tc_id);
 
 /**
- * dpni_set_vlan_insertion() - Enable/disable VLAN insertion for egress frames
+ * dpni_get_api_version() - Get Data Path Network Interface API version
+ * @mc_io:  Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @major_ver:	Major version of data path network interface API
+ * @minor_ver:	Minor version of data path network interface API
+ *
+ * Return:  '0' on Success; Error code otherwise.
+ */
+int dpni_get_api_version(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
+			   uint16_t *major_ver,
+			   uint16_t *minor_ver);
+
+/**
+ * Set User Context
+ */
+#define DPNI_QUEUE_OPT_USER_CTX		0x00000001
+#define DPNI_QUEUE_OPT_DEST		0x00000002
+#define DPNI_QUEUE_OPT_FLC		0x00000004
+#define DPNI_QUEUE_OPT_HOLD_ACTIVE	0x00000008
+
+/**
+ * dpni_set_queue() - Set queue parameters
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @en:		Set to '1' to enable; '0' to disable
+ * @qtype:	Type of queue - all queue types are supported, although
+ *		the command is ignored for Tx
+ * @tc:		Traffic class, in range 0 to NUM_TCS - 1
+ * @index:	Selects the specific queue out of the set allocated for the
+ *		same TC. Value must be in range 0 to NUM_QUEUES - 1
+ * @options:	A combination of DPNI_QUEUE_OPT_ values that control what
+ *			configuration options are set on the queue
+ * @queue:	Queue structure
  *
- * Requires that the 'DPNI_OPT_VLAN_MANIPULATION' option is set
- * at DPNI creation.
- *
- * Return:	'0' on Success; Error code otherwise.
+ * Return:  '0' on Success; Error code otherwise.
  */
-int dpni_set_vlan_insertion(struct fsl_mc_io	*mc_io,
-			    uint32_t		cmd_flags,
-			    uint16_t		token,
-			    int		en);
+int dpni_set_queue(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+		     enum dpni_queue_type qtype,
+			 uint8_t tc,
+			 uint8_t index,
+		     uint8_t options,
+		     const struct dpni_queue *queue);
 
 /**
- * dpni_set_vlan_removal() - Enable/disable VLAN removal for ingress frames
+ * dpni_get_queue() - Get queue parameters
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @en:		Set to '1' to enable; '0' to disable
+ * @qtype:	Type of queue - all queue types are supported
+ * @tc:		Traffic class, in range 0 to NUM_TCS - 1
+ * @index:	Selects the specific queue out of the set allocated for the
+ *		same TC. Value must be in range 0 to NUM_QUEUES - 1
+ * @queue:	Queue configuration structure
+ * @qid:	Queue identification
  *
- * Requires that the 'DPNI_OPT_VLAN_MANIPULATION' option is set
- * at DPNI creation.
- *
- * Return:	'0' on Success; Error code otherwise.
+ * Return:  '0' on Success; Error code otherwise.
  */
-int dpni_set_vlan_removal(struct fsl_mc_io	*mc_io,
-			  uint32_t		cmd_flags,
-			  uint16_t		token,
-			  int			en);
+int dpni_get_queue(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+			 enum dpni_queue_type qtype,
+			 uint8_t tc,
+			 uint8_t index,
+			 struct dpni_queue *queue,
+			 struct dpni_queue_id *qid);
 
 /**
- * dpni_set_ipr() - Enable/disable IP reassembly of ingress frames
+ * dpni_get_statistics() - Get DPNI statistics
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @en:		Set to '1' to enable; '0' to disable
+ * @page:	Selects the statistics page to retrieve, see
+ *		DPNI_GET_STATISTICS output. Pages are numbered 0 to 2.
+ * @stat:	Structure containing the statistics
  *
- * Requires that the 'DPNI_OPT_IPR' option is set at DPNI creation.
+ * Return:  '0' on Success; Error code otherwise.
+ */
+int dpni_get_statistics(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+			 uint8_t page,
+			 union dpni_statistics *stat);
+
+/**
+ * dpni_reset_statistics() - Clears DPNI statistics
+ * @mc_io:		Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:		Token of DPNI object
  *
- * Return:	'0' on Success; Error code otherwise.
+ * Return:  '0' on Success; Error code otherwise.
  */
-int dpni_set_ipr(struct fsl_mc_io	*mc_io,
-		 uint32_t		cmd_flags,
-		 uint16_t		token,
-		 int			en);
+int dpni_reset_statistics(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token);
 
 /**
- * dpni_set_ipf() - Enable/disable IP fragmentation of egress frames
+ * enum dpni_congestion_point - Structure representing congestion point
+ * @DPNI_CP_QUEUE: Set taildrop per queue, identified by QUEUE_TYPE, TC and
+ *		QUEUE_INDEX
+ * @DPNI_CP_GROUP: Set taildrop per queue group. Depending on options used to
+ *		define the DPNI this can be either per TC (default) or per
+ *		interface (DPNI_OPT_SHARED_CONGESTION set at DPNI create).
+ *		QUEUE_INDEX is ignored if this type is used.
+ */
+enum dpni_congestion_point {
+	DPNI_CP_QUEUE,
+	DPNI_CP_GROUP,
+};
+
+/**
+ * struct dpni_taildrop - Structure representing the taildrop
+ * @enable:	Indicates whether the taildrop is active or not.
+ * @units:	Indicates the unit of THRESHOLD. Queue taildrop only supports
+ *		byte units, this field is ignored and assumed = 0 if
+ *		CONGESTION_POINT is 0.
+ * @threshold:	Threshold value, in units identified by UNITS field. Value 0
+ *		cannot be used as a valid taildrop threshold, THRESHOLD must
+ *		be > 0 if the taildrop is enabled.
+ */
+struct dpni_taildrop {
+	char enable;
+	enum dpni_congestion_unit units;
+	uint32_t threshold;
+};
+
+/**
+ * dpni_set_taildrop() - Set taildrop per queue or TC
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @en:		Set to '1' to enable; '0' to disable
+ * @cg_point:	Congestion point
+ * @q_type:
+ * @tc:		Traffic class to apply this taildrop to
+ * @q_index:	Index of the queue if the DPNI supports multiple queues for
+ *		traffic distribution. Ignored if CONGESTION_POINT is not 0.
+ * @taildrop:	Taildrop structure
  *
- * Requires that the 'DPNI_OPT_IPF' option is set at DPNI
- * creation. Fragmentation is performed according to MTU value
- * set by dpni_set_mtu() function
+ * Return:  '0' on Success; Error code otherwise.
+ */
+int dpni_set_taildrop(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+			 enum dpni_congestion_point cg_point,
+			 enum dpni_queue_type q_type,
+			 uint8_t tc,
+			 uint8_t q_index,
+			 struct dpni_taildrop *taildrop);
+
+/**
+ * dpni_get_taildrop() - Get taildrop information
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @cg_point:	Congestion point
+ * @q_type:
+ * @tc:		Traffic class to apply this taildrop to
+ * @q_index:	Index of the queue if the DPNI supports multiple queues for
+ *		traffic distribution. Ignored if CONGESTION_POINT is not 0.
+ * @taildrop:	Taildrop structure
  *
- * Return:	'0' on Success; Error code otherwise.
+ * Return:  '0' on Success; Error code otherwise.
  */
-int dpni_set_ipf(struct fsl_mc_io	*mc_io,
-		 uint32_t		cmd_flags,
-		 uint16_t		token,
-		 int			en);
+int dpni_get_taildrop(struct fsl_mc_io *mc_io,
+		     uint32_t cmd_flags,
+		     uint16_t token,
+			 enum dpni_congestion_point cg_point,
+			 enum dpni_queue_type q_type,
+			 uint8_t tc,
+			 uint8_t q_index,
+			 struct dpni_taildrop *taildrop);
 
 #endif /* __FSL_DPNI_H */
-- 
1.7.5.4

