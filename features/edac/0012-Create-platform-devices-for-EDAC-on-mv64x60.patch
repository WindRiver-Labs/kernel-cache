From 398d8bb7bc8e79ec3c53807b9022c6e8aa09fa04 Mon Sep 17 00:00:00 2001
From: Rob Woolley <rob.woolley@windriver.com>
Date: Sat, 8 Nov 2008 13:20:19 -0500
Subject: [PATCH] Create platform devices for EDAC on mv64x60

This patch borrows the idea from Dave Jiang, author of mv64x60_edac.c.
The original patch header is quoted below, and it has not merged into
mainline kernel.

-->-->-->-->
"Creating platform devices (memory controller, sram error registers, cpu
error registers, PCI error registers) for Error Detection and Correction
(EDAC) driver.

The platform devices allow the mv64x60 EDAC driver to detect errors from
the memory controller (ECC erorrs), SRAM controller, CPU data path error
registers, and PCI error registers. The errors are reported to syslog.
Software ECC scrubbing is provided. These replace the mv64x60 error handlers
in the ppc branch. They are being moved to EDAC subsystem in order to
centralize error reporting.

The error reporting can be triggered via interrupts from the mv64x60 bridge
chip or via polling mechanism provided by the EDAC core code.

Signed-off-by: Dave Jiang <djiang at mvista.com>
Acked-by: Dale Farnsworth <dale at farnsworth.org>"
-->-->-->-->

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
Reviewed-by: Rob Woolley <rob.woolley@windriver.com>
---
 arch/powerpc/sysdev/mv64x60_dev.c |   83 +++++++++++++++++++++++++++++++++++++
 1 files changed, 83 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/sysdev/mv64x60_dev.c b/arch/powerpc/sysdev/mv64x60_dev.c
index 32e0ad0..f5079c6 100644
--- a/arch/powerpc/sysdev/mv64x60_dev.c
+++ b/arch/powerpc/sysdev/mv64x60_dev.c
@@ -16,6 +16,7 @@
 #include <linux/mv643xx.h>
 #include <linux/platform_device.h>
 #include <linux/of_platform.h>
+#include <linux/io.h>
 
 #include <asm/prom.h>
 
@@ -431,6 +432,43 @@ error:
 	return err;
 }
 
+static int __init mv64x60_edac_device_setup(struct device_node *np,
+					    int id,
+					    int num_addr,
+					    char *pdev_name)
+{
+	struct resource *r;
+	struct platform_device *pdev;
+	int i, ret;
+
+	/* all EDAC device nodes have one extra IRQ resource */
+	r = kzalloc((num_addr + 1) * sizeof(*r), GFP_KERNEL);
+	if (!r)
+		return -ENOMEM;
+
+	for (i = 0; i < num_addr; i++) {
+		ret = of_address_to_resource(np, i, &r[i]);
+		if (ret) {
+			kfree(r);
+			return ret;
+		}
+	}
+
+	ret = of_irq_to_resource(np, 0, &r[num_addr]);
+	if (ret == NO_IRQ) {
+		kfree(r);
+		return -ENXIO;
+	}
+
+	pdev = platform_device_register_simple(pdev_name, id, r, num_addr + 1);
+
+	kfree(r);
+	if (IS_ERR(pdev))
+		return PTR_ERR(pdev);
+
+	return 0;
+}
+
 static int __init mv64x60_device_setup(void)
 {
 	struct device_node *np, *np2;
@@ -494,6 +532,51 @@ static int __init mv64x60_device_setup(void)
 	for_each_compatible_node(np, NULL, "marvell,mv64360")
 		of_platform_bus_probe(np, of_mv64x60_devices, NULL);
 
+	id = 0;
+	for_each_compatible_node(np, NULL, "marvell,mv64360-mem-ctrl")
+		if ((err = mv64x60_edac_device_setup(np, id++, 1,
+						  "mv64x60_mc_err")))
+			printk(KERN_ERR "Failed to initialize MV64x60 "
+					"MC %s: error %d.\n",
+					np->full_name, err);
+
+
+	id = 0;
+	for_each_compatible_node(np, NULL, "marvell,mv64360-cpu-error")
+		if ((err = mv64x60_edac_device_setup(np, id++, 2,
+						  "mv64x60_cpu_err")))
+			printk(KERN_ERR "Failed to initialize MV64x60 "
+					"CPU %s: error %d.\n",
+					np->full_name, err);
+
+	id = 0;
+	for_each_compatible_node(np, NULL, "marvell,mv64360-sram-ctrl")
+		if ((err = mv64x60_edac_device_setup(np, id++, 1,
+						  "mv64x60_sram_err")))
+			printk(KERN_ERR "Failed to initialize MV64x60 "
+					"SRAM %s: error %d.\n",
+					np->full_name, err);
+
+#ifdef CONFIG_PCI
+	id = 0;
+	for_each_compatible_node(np, NULL, "marvell,mv64360-pci0-error") {
+		if ((err = mv64x60_edac_device_setup(np, id++, 2,
+						  "mv64x60_pci0_err")))
+			printk(KERN_ERR "Failed to initialize MV64x60 "
+					"PCI0 %s: error %d.\n",
+					np->full_name, err);
+	}
+
+	id = 0;
+	for_each_compatible_node(np, NULL, "marvell,mv64360-pci1-error") {
+		if ((err = mv64x60_edac_device_setup(np, id++, 2,
+						  "mv64x60_pci1_err")))
+			printk(KERN_ERR "Failed to initialize MV64x60 "
+					"PCI1 %s: error %d.\n",
+					np->full_name, err);
+	}
+#endif
+
 	return 0;
 }
 arch_initcall(mv64x60_device_setup);
-- 
1.6.0.90.g436ed

