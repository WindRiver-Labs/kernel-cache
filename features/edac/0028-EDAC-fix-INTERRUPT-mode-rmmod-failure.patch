From 510346a55e921b731e3123161d38814a72748564 Mon Sep 17 00:00:00 2001
From: Harry Ciao <qingtao.cao@windriver.com>
Date: Wed, 7 Jan 2009 16:03:19 +0800
Subject: [PATCH] EDAC: fix INTERRUPT mode rmmod failure

edac_device_ctl_info, edac_pci_ctl_info & mem_ctl_info structures all have
a member of delayed_work, which would be initialized and set up in POLL mode.
Likewise, these delayed works should be removed in POLL mode only. That is
to say, if EDAC works in INTERRUPT mode, there is no need to tear them down,
since they are not used at all.

Otherwise, they would make system hung. With the help of Magic SysRq we
could see that "rmmod" process hangs when deleting the timer in a delayed
work that has never been properly initialized:

telnet> send brk
(input "p" key)
SysRq : Show Regs
...
NIP [c003308c] lock_timer_base+0x30/0xa8
LR [c0033128] try_to_del_timer_sync+0x24/0xac
Call Trace:
[df365da0] [c036b70c] wait_for_common+0xd8/0x218 (unreliable)
[df365dc0] [c0033128] try_to_del_timer_sync+0x24/0xac
[df365de0] [c0034000] del_timer_sync+0x28/0x44
[df365df0] [e515de94] edac_device_workq_teardown+0x1c/0x70 [edac_core]
[df365e00] [e515dfbc] edac_device_del_device+0xd4/0x14c [edac_core]
[df365e20] [e518c484] mv64x60_dma_err_remove+0x34/0x74 [mv64x60_edac]
[df365e30] [c0212da4] platform_drv_remove+0x20/0x30
[df365e40] [c02116d4] __device_release_driver+0xa0/0xe8
...

edac_device_workq_teardown() should be bypassed in INTERRUPT mode. A further
investigation reveals that the delayed work in edac_pci_ctl_info and
mem_ctl_info bear the same problem too, they should be fixed in the same way.

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
---
 drivers/edac/edac_device.c |    5 +++--
 drivers/edac/edac_mc.c     |    4 +++-
 drivers/edac/edac_pci.c    |    3 ++-
 3 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index c82ebaf..a7bf5b7 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -612,12 +612,13 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 	mutex_unlock(&device_ctls_mutex);
 
 	/* clear workq processing on this instance */
-	edac_device_workq_teardown(edac_dev);
+	if (edac_dev->edac_check)
+		edac_device_workq_teardown(edac_dev);
 
 	/* Tear down the sysfs entries for this instance */
 	edac_device_remove_sysfs(edac_dev);
 
-	edac_printk(KERN_INFO, EDAC_MC,
+	edac_printk(KERN_INFO, EDAC_DEBUG,
 		"Removed device %d for %s %s: DEV %s\n",
 		edac_dev->dev_idx,
 		edac_dev->mod_name, edac_dev->ctl_name, edac_dev_name(edac_dev));
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index d09effc..6c6e91d 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -579,7 +579,9 @@ struct mem_ctl_info *edac_mc_del_mc(struct device *dev)
 	mutex_unlock(&mem_ctls_mutex);
 
 	/* flush workq processes and remove sysfs */
-	edac_mc_workq_teardown(mci);
+	if (mci->edac_check)
+		edac_mc_workq_teardown(mci);
+
 	edac_remove_sysfs_mci_device(mci);
 
 	edac_printk(KERN_INFO, EDAC_MC,
diff --git a/drivers/edac/edac_pci.c b/drivers/edac/edac_pci.c
index 893f378..412572c 100644
--- a/drivers/edac/edac_pci.c
+++ b/drivers/edac/edac_pci.c
@@ -426,7 +426,8 @@ struct edac_pci_ctl_info *edac_pci_del_device(struct device *dev)
 	mutex_unlock(&edac_pci_ctls_mutex);
 
 	/* stop the workq timer */
-	edac_pci_workq_teardown(pci);
+	if (pci->edac_check)
+		edac_pci_workq_teardown(pci);
 
 	edac_printk(KERN_INFO, EDAC_PCI,
 		"Removed device %d for %s %s: DEV %s\n",
-- 
1.6.0.3

