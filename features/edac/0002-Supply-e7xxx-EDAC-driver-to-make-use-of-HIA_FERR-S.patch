From cfa3c4551ffb254a494fd9323996f86537a8c1fb Mon Sep 17 00:00:00 2001
From: qingtao.cao@windriver.com <qingtao.cao@windriver.com>
Date: Tue, 4 Nov 2008 19:39:17 +0800
Subject: [PATCH] Supply e7xxx EDAC driver to make use of HIA_FERR & SYSBUS_FERR on MCH.
 Related PCI Configuration Registers would be monitored by EDAC and user
 could get each of their error counters via sysfs.

---
 drivers/edac/e7xxx_edac.c    |  198 ++++++++++++++++++++++++++++++++++++++++++
 drivers/edac/edac_core.h     |    2 +
 drivers/edac/edac_mc_sysfs.c |   14 +++
 3 files changed, 214 insertions(+), 0 deletions(-)

diff --git a/drivers/edac/e7xxx_edac.c b/drivers/edac/e7xxx_edac.c
index 929f0fd..d7f1478 100644
--- a/drivers/edac/e7xxx_edac.c
+++ b/drivers/edac/e7xxx_edac.c
@@ -76,6 +76,52 @@
 /* E7501 Device ID */
 #define PCI_DEVICE_ID_INTEL_E7501_HIA			0x2541
 
+/*************************************************************
+ *        South Bridge Registers HI_A (Device 0, Function 1) *       
+ *************************************************************/
+#define E7501_South_Bridge_HIA_PCICMD		0x04
+#define E7501_South_Bridge_HIA_HIA_FERR		0x50
+#define E7501_South_Bridge_HIA_HIA_NERR		0x52
+#define E7501_South_Bridge_HIA_SERRCMD_HIA	0x5C
+#define E7501_South_Bridge_HIA_SYSBUS_FERR	0x60
+#define E7501_South_Bridge_HIA_SYSBUS_NERR	0x62
+#define E7501_South_Bridge_HIA_SERRCMD_SYSBUS	0x6C
+#define E7501_South_Bridge_HIA_SERRCMD_DRAM	0x8C
+
+/*************************************************************
+ * 		E7501 HIA_FERR/NERR Definitions		     *
+ *************************************************************/
+#define E7501_HIA_FERR_TargetAbort	(1 << 6)
+#define E7501_HIA_FERR_DataParityErr	(1 << 4)
+#define E7501_HIA_FERR_AddrCmdParityErr	(1)
+#define E7501_HIA_FERR_MASK	(E7501_HIA_FERR_TargetAbort | \
+				E7501_HIA_FERR_DataParityErr | \
+				E7501_HIA_FERR_AddrCmdParityErr)
+
+#define E7501_HIA_SERRCMD_MASK	E7501_HIA_FERR_MASK
+
+/*************************************************************
+ * 		E7501 SYSBUS_FERR/NERR Definitions	     *
+ *************************************************************/
+#define E7501_SYSBUS_FERR_BINIT		(1 << 7)
+#define E7501_SYSBUS_FERR_XERR		(1 << 6)
+#define E7501_SYSBUS_FERR_NDLOCK	(1 << 5)
+#define E7501_SYSBUS_FERR_SBATOM	(1 << 4)
+#define E7501_SYSBUS_FERR_SBDPAR	(1 << 3)
+#define E7501_SYSBUS_FERR_SBAGL		(1 << 2)
+#define E7501_SYSBUS_FERR_SBDGL		(1 << 1)
+#define E7501_SYSBUS_FERR_SBRPAR	(1)
+#define E7501_SYSBUS_FERR_MASK	(E7501_SYSBUS_FERR_BINIT | \
+				E7501_SYSBUS_FERR_XERR | \
+				E7501_SYSBUS_FERR_NDLOCK | \
+				E7501_SYSBUS_FERR_SBATOM | \
+				E7501_SYSBUS_FERR_SBDPAR | \
+				E7501_SYSBUS_FERR_SBAGL | \
+				E7501_SYSBUS_FERR_SBDGL | \
+				E7501_SYSBUS_FERR_SBRPAR)
+
+#define E7501_SYSBUS_SERRCMD_MASK	E7501_SYSBUS_FERR_MASK
+
 #define E7XXX_NR_CSROWS		8	/* number of csrows */
 #define E7XXX_NR_DIMMS		8	/* FIXME - is this correct? */
 
@@ -160,6 +206,10 @@ struct e7xxx_error_info {
 	u32 dram_celog_add;
 	u16 dram_celog_syndrome;
 	u32 dram_uelog_add;
+	u8 hia_ferr;
+	u8 hia_nerr;
+	u8 sysbus_ferr;
+	u8 sysbus_nerr;
 };
 
 static struct edac_pci_ctl_info *e7xxx_pci;
@@ -299,6 +349,60 @@ static void process_ue_no_info(struct mem_ctl_info *mci)
 	edac_mc_handle_ue_no_info(mci, "e7xxx UE log register overflow");
 }
 
+#define HUB_ERR_MSG_NUM		7
+static char *hub_message[HUB_ERR_MSG_NUM] = {
+	[0] = "Address or Command Parity", 
+	[1] = NULL,	/* reserved */
+	[2] = NULL,	/* reserved */
+	[3] = NULL,	/* reserved */
+	[4] = "Data Parity", 
+	[5] = NULL,	/* reserved */
+	[6] = "Target Abort"
+};
+
+static void process_hub_error(struct mem_ctl_info *mci,
+			      struct e7xxx_error_info *info)
+{
+	int i;
+	u8 error = info->hia_ferr | info->hia_nerr;
+	
+	for (i = 0; i < HUB_ERR_MSG_NUM; i++) {
+		if (!hub_message[i])
+			continue;
+
+		if (error & (1 << i))
+			edac_mc_printk(mci, KERN_WARNING, "Error Hub Interface: %s\n",
+				hub_message[i]);
+	}
+}
+
+#define SYSBUS_ERR_MSG_NUM	8
+static char *sysbus_message[SYSBUS_ERR_MSG_NUM] = {
+	[0] = "Addr or Request Parity",
+	[1] = "Data Strobe Glitch",
+	[2] = "Addr Strobe Glitch",
+	[3] = "Data Parity",
+	[4] = "Addr Above TOM",
+	[5] = "Non DRAM Lock Error",
+	[6] = "MCERR", 
+	[7] = "BINIT"
+};
+
+static void process_sysbus_error(struct mem_ctl_info *mci,
+				 struct e7xxx_error_info *info)
+{
+	int i;
+	u8 error = info->sysbus_ferr | info->sysbus_nerr;
+
+	mci->sysbus_err_count++;
+
+	for (i = 0; i < SYSBUS_ERR_MSG_NUM; i++) {
+		if (error & (1 << i))		
+			edac_mc_printk(mci, KERN_WARNING, "Error System Bus: %s\n",
+				       sysbus_message[i]);
+	}
+}
+
 static void e7xxx_get_error_info(struct mem_ctl_info *mci,
 				 struct e7xxx_error_info *info)
 {
@@ -308,6 +412,16 @@ static void e7xxx_get_error_info(struct mem_ctl_info *mci,
 	pci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_FERR, &info->dram_ferr);
 	pci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_NERR, &info->dram_nerr);
 
+	pci_read_config_byte(pvt->bridge_ck, E7501_South_Bridge_HIA_HIA_FERR, 
+			     &info->hia_ferr);
+	pci_read_config_byte(pvt->bridge_ck, E7501_South_Bridge_HIA_HIA_NERR, 
+			     &info->hia_nerr);
+
+	pci_read_config_byte(pvt->bridge_ck, E7501_South_Bridge_HIA_SYSBUS_FERR, 
+			     &info->sysbus_ferr);
+	pci_read_config_byte(pvt->bridge_ck, E7501_South_Bridge_HIA_SYSBUS_NERR, 
+			     &info->sysbus_nerr);
+
 	if ((info->dram_ferr & 1) || (info->dram_nerr & 1)) {
 		pci_read_config_dword(pvt->bridge_ck, E7XXX_DRAM_CELOG_ADD,
 				&info->dram_celog_add);
@@ -325,6 +439,26 @@ static void e7xxx_get_error_info(struct mem_ctl_info *mci,
 
 	if (info->dram_nerr & 3)
 		pci_write_bits8(pvt->bridge_ck, E7XXX_DRAM_NERR, 0x03, 0x03);
+
+	if (info->hia_ferr & E7501_HIA_FERR_MASK)
+		pci_write_config_byte(pvt->bridge_ck, 
+				      E7501_South_Bridge_HIA_HIA_FERR, 
+				      E7501_HIA_FERR_MASK);
+
+	if (info->hia_nerr & E7501_HIA_FERR_MASK)
+		pci_write_config_byte(pvt->bridge_ck, 
+				      E7501_South_Bridge_HIA_HIA_NERR,
+				      E7501_HIA_FERR_MASK);
+
+	if (info->sysbus_ferr & E7501_SYSBUS_FERR_MASK)
+		pci_write_config_byte(pvt->bridge_ck, 
+				      E7501_South_Bridge_HIA_SYSBUS_FERR, 
+				      E7501_SYSBUS_FERR_MASK);
+
+	if (info->sysbus_nerr & E7501_SYSBUS_FERR_MASK)
+		pci_write_config_byte(pvt->bridge_ck, 
+				      E7501_South_Bridge_HIA_SYSBUS_NERR,
+				      E7501_SYSBUS_FERR_MASK);
 }
 
 static int e7xxx_process_error_info(struct mem_ctl_info *mci,
@@ -372,6 +506,22 @@ static int e7xxx_process_error_info(struct mem_ctl_info *mci,
 		}
 	}
 
+	if ((info->hia_ferr & E7501_HIA_FERR_MASK) || 
+	    (info->hia_nerr & E7501_HIA_FERR_MASK)) {
+		error_found = 1;
+
+		if (handle_errors) 
+			process_hub_error(mci, info);
+	}
+
+	if ((info->sysbus_ferr & E7501_SYSBUS_FERR_MASK) || 
+	    (info->sysbus_nerr & E7501_SYSBUS_FERR_MASK)) {
+		error_found = 1;
+
+		if (handle_errors)
+			process_sysbus_error(mci, info);
+	}
+
 	return error_found;
 }
 
@@ -554,6 +704,51 @@ static void e7xxx_handle_nmi(void)
 			dev_info->check(dev_info->edac_dev);		
 }
 
+static void e7xxx_D0F1_init(struct pci_dev *dev)
+{
+	u8 byte;
+	u16 word;
+
+	/* clear up all FERR/NERR registers */
+        pci_read_config_byte(dev, E7XXX_DRAM_FERR, &byte);
+        pci_write_config_byte(dev, E7XXX_DRAM_FERR, byte);
+
+        pci_read_config_byte(dev, E7XXX_DRAM_NERR, &byte);
+        pci_write_config_byte(dev, E7XXX_DRAM_NERR, byte);
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_HIA_FERR, &byte);
+        pci_write_config_byte(dev, E7501_South_Bridge_HIA_HIA_FERR, byte);
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_HIA_NERR, &byte);
+        pci_write_config_byte(dev, E7501_South_Bridge_HIA_HIA_NERR, byte);
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_SYSBUS_FERR, &byte);
+        pci_write_config_byte(dev, E7501_South_Bridge_HIA_SYSBUS_FERR, byte);
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_SYSBUS_NERR, &byte);
+        pci_write_config_byte(dev, E7501_South_Bridge_HIA_SYSBUS_NERR, byte);
+
+	/* setup SERR enable bit only in INT mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		return;
+
+	pci_read_config_word(dev, E7501_South_Bridge_HIA_PCICMD, &word);
+	word |= 1 << 8; /* SERR */
+	pci_write_config_word(dev, E7501_South_Bridge_HIA_PCICMD, word);
+
+	pci_read_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_DRAM, &byte);
+	byte |=  1 | 1 << 1; /* single-bit & multi-bit error detection */
+	pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_DRAM, byte);
+
+	pci_read_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_HIA, &byte);
+	byte |= E7501_HIA_SERRCMD_MASK;
+	pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_HIA, byte);
+
+	pci_read_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_SYSBUS, &byte);
+	byte |= E7501_SYSBUS_SERRCMD_MASK;
+	pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_SYSBUS, byte);
+}
+
 static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 {
 	u16 pci_data;
@@ -621,6 +816,9 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 	/* clear any pending errors, or initial state bits */
 	e7xxx_get_error_info(mci, &discard);
 
+	/* initialize error detection on D0F1 device */
+	e7xxx_D0F1_init(pvt->bridge_ck);
+
 	/* Here we assume that we will never see multiple instances of this
 	 * type of memory controller.  The ID is therefore hardcoded to 0.
 	 */
diff --git a/drivers/edac/edac_core.h b/drivers/edac/edac_core.h
index 4b55ec6..6756335 100644
--- a/drivers/edac/edac_core.h
+++ b/drivers/edac/edac_core.h
@@ -395,6 +395,8 @@ struct mem_ctl_info {
 	u32 ue_count;		/* Total Uncorrectable Errors for this MC */
 	u32 ce_count;		/* Total Correctable Errors for this MC */
 	unsigned long start_time;	/* mci load start time (in jiffies) */
+	u32 hub_err_count;	/* Hub Error */
+	u32 sysbus_err_count;	/* All types of Sysbus Error */
 
 	/* this stuff is for safe removal of mc devices from global list while
 	 * NMI handlers may be traversing list
diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c
index ad218fe..542aa98 100644
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@ -544,6 +544,16 @@ static ssize_t mci_size_mb_show(struct mem_ctl_info *mci, char *data)
 	return sprintf(data, "%u\n", PAGES_TO_MiB(total_pages));
 }
 
+static ssize_t mci_hub_err_count_show(struct mem_ctl_info *mci, char *data)
+{
+        return sprintf(data, "%d\n", mci->hub_err_count);
+}
+
+static ssize_t mci_sysbus_err_count_show(struct mem_ctl_info *mci, char *data)
+{
+        return sprintf(data, "%d\n", mci->sysbus_err_count);
+}
+
 #define to_mci(k) container_of(k, struct mem_ctl_info, edac_mci_kobj)
 #define to_mcidev_attr(a) container_of(a,struct mcidev_sysfs_attribute,attr)
 
@@ -596,6 +606,8 @@ MCIDEV_ATTR(ue_noinfo_count, S_IRUGO, mci_ue_noinfo_show, NULL);
 MCIDEV_ATTR(ce_noinfo_count, S_IRUGO, mci_ce_noinfo_show, NULL);
 MCIDEV_ATTR(ue_count, S_IRUGO, mci_ue_count_show, NULL);
 MCIDEV_ATTR(ce_count, S_IRUGO, mci_ce_count_show, NULL);
+MCIDEV_ATTR(hub_err_count, S_IRUGO, mci_hub_err_count_show, NULL);
+MCIDEV_ATTR(sysbus_err_count, S_IRUGO, mci_sysbus_err_count_show, NULL);
 
 /* memory scrubber attribute file */
 MCIDEV_ATTR(sdram_scrub_rate, S_IRUGO | S_IWUSR, mci_sdram_scrub_rate_show,
@@ -611,6 +623,8 @@ static struct mcidev_sysfs_attribute *mci_attr[] = {
 	&mci_attr_ue_count,
 	&mci_attr_ce_count,
 	&mci_attr_sdram_scrub_rate,
+	&mci_attr_hub_err_count,
+	&mci_attr_sysbus_err_count,
 	NULL
 };
 
-- 
1.6.0.90.g436ed

