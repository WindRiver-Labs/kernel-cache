From e4a6ce986f83f10f7b2d68c213fb1b8e518aa83e Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Sat, 8 Nov 2008 17:57:06 -0500
Subject: [PATCH] EDAC: Add e7xxx chipset support for vMC

Add EDAC vMC wrapper calls and a vMC sensor mappings for e7xxx
chipsets.  This vMC integration is enabled by the CONFIG_EDAC_VMC
kernel configuration.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 drivers/edac/e7xxx_edac.c     |  211 ++++++++++++++++++++++++++++++++++++++++-
 drivers/edac/e7xxx_edac_vmc.h |  108 +++++++++++++++++++++
 2 files changed, 318 insertions(+), 1 deletions(-)
 create mode 100644 drivers/edac/e7xxx_edac_vmc.h

diff --git a/drivers/edac/e7xxx_edac.c b/drivers/edac/e7xxx_edac.c
index 855c6e0..f2d5753 100644
--- a/drivers/edac/e7xxx_edac.c
+++ b/drivers/edac/e7xxx_edac.c
@@ -36,6 +36,12 @@
 #include <linux/spinlock.h>
 #include "edac_core.h"
 
+#ifdef CONFIG_EDAC_VMC
+#include <linux/string.h>
+#include "edac_vmc.h"
+#include "e7xxx_edac_vmc.h"
+#endif
+
 #define	E7XXX_REVISION " Ver: 2.0.2 " __DATE__
 #define	EDAC_MOD_STR	"e7xxx_edac"
 
@@ -333,6 +339,10 @@ static void e7501_hiX_err_check(struct edac_device_ctl_info *edac_dev)
 	struct e7xxx_dev_info *dev_info = edac_dev->pvt_info;
 	u8 ferr = 0, nerr = 0;
 
+#ifdef CONFIG_EDAC_VMC
+	int sensor_id = -1;
+#endif
+
 	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, &ferr);
 	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, &nerr);
 	ferr &= E7501_HI_FERR_MASK;
@@ -340,6 +350,32 @@ static void e7501_hiX_err_check(struct edac_device_ctl_info *edac_dev)
 	if (!ferr && !nerr ) 
 		return;
 
+#ifdef CONFIG_EDAC_VMC
+	/* determine which sensor to report to */
+	switch (dev_info->err_dev) {
+		case PCI_DEVICE_ID_INTEL_E7501_HIB_ERROR_REPORT:
+			sensor_id = HIB_FLT;
+			break;
+
+		case PCI_DEVICE_ID_INTEL_E7501_HIC_ERROR_REPORT:
+			sensor_id = HIC_FLT;
+			break;
+
+		case PCI_DEVICE_ID_INTEL_E7501_HID_ERROR_REPORT:
+			sensor_id = HID_FLT;
+			break;
+		default:
+			break;
+	}
+
+	if ( sensor_id >= 0 ) {
+		/* report fault to vMC */
+		vmc_report_fault(sensor_id, e7xxx_vmc_lun, SENSOR_ACTION_INC, 1, 2,
+				 "FERR", ferr,
+				 "NERR", nerr);
+	}
+#endif
+
 	/* only reset the bits we are interested in */
 	if (ferr)
 		pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, ferr);
@@ -434,6 +470,14 @@ static void process_ce(struct mem_ctl_info *mci, struct e7xxx_error_info *info)
 	int channel;
 
 	debugf3("%s()\n", __func__);
+
+#ifdef CONFIG_EDAC_VMC
+	/* report fault to vMC */
+	vmc_report_fault(CECC_FLT, e7xxx_vmc_lun, SENSOR_ACTION_INC, 1, 2,
+			 "DRAM_CELOG_ADDRESS", info->dram_celog_add,
+			 "DRAM_CELOG_SYNDROME", info->dram_celog_syndrome);
+#endif
+
 	/* read the error address */
 	error_1b = info->dram_celog_add;
 	/* FIXME - should use PAGE_SHIFT */
@@ -450,6 +494,11 @@ static void process_ce(struct mem_ctl_info *mci, struct e7xxx_error_info *info)
 static void process_ce_no_info(struct mem_ctl_info *mci)
 {
 	debugf3("%s()\n", __func__);
+
+#ifdef CONFIG_EDAC_VMC
+	vmc_report_fault(CECC_FLT, e7xxx_vmc_lun, SENSOR_ACTION_INC, 1, 0);
+#endif
+
 	edac_mc_handle_ce_no_info(mci, "e7xxx CE log register overflow");
 }
 
@@ -459,6 +508,15 @@ static void process_ue(struct mem_ctl_info *mci, struct e7xxx_error_info *info)
 	int row;
 
 	debugf3("%s()\n", __func__);
+
+#ifdef CONFIG_EDAC_VMC
+	/* report fault to vMC */
+	vmc_report_fault(UECC_FLT, e7xxx_vmc_lun,
+			 SENSOR_ACTION_SET,
+			 TH_GEN_UPPER_NON_RECOVERABLE, 1,
+			 "DRAM_UELOG_ADDRESS", info->dram_uelog_add);
+#endif
+
 	/* read the error address */
 	error_2b = info->dram_uelog_add;
 	/* FIXME - should use PAGE_SHIFT */
@@ -470,6 +528,13 @@ static void process_ue(struct mem_ctl_info *mci, struct e7xxx_error_info *info)
 static void process_ue_no_info(struct mem_ctl_info *mci)
 {
 	debugf3("%s()\n", __func__);
+
+#ifdef CONFIG_EDAC_VMC
+	/* report fault to vMC */
+	vmc_report_fault(UECC_FLT, e7xxx_vmc_lun, SENSOR_ACTION_SET,
+			 TH_GEN_UPPER_NON_RECOVERABLE, 0);
+#endif
+
 	edac_mc_handle_ue_no_info(mci, "e7xxx UE log register overflow");
 }
 
@@ -489,7 +554,10 @@ static void process_hub_error(struct mem_ctl_info *mci,
 {
 	int i;
 	u8 error = info->hia_ferr | info->hia_nerr;
-	
+#ifdef CONFIG_EDAC_VMC
+	int sensor_id = -1;
+#endif
+
 	for (i = 0; i < HUB_ERR_MSG_NUM; i++) {
 		if (!hub_message[i])
 			continue;
@@ -498,6 +566,25 @@ static void process_hub_error(struct mem_ctl_info *mci,
 			edac_mc_printk(mci, KERN_WARNING, "Error Hub Interface: %s\n",
 				hub_message[i]);
 	}
+
+#ifdef CONFIG_EDAC_VMC
+	/* determine which sensor to report to */
+	if ( error & (1 << 0) )
+		sensor_id = HUB_ADDR_CMD_PAR_FLT;
+	else if ( error & (1 << 4) )
+		sensor_id = HUB_DATA_PAR_FLT;
+	else if ( error & (1 << 6) )
+		sensor_id = HUB_TARGET_ABORT_FLT;
+
+	if (sensor_id >= 0) {
+		/* report fault to vMC */
+		vmc_report_fault(sensor_id, e7xxx_vmc_lun, SENSOR_ACTION_SET,
+				 TH_GEN_UPPER_NON_RECOVERABLE, 2,
+				 "HIA_FERR", info->hia_ferr & E7501_HIA_FERR_MASK,
+				 "HIA_NERR", info->hia_nerr & E7501_HIA_FERR_MASK);
+	}
+#endif
+
 }
 
 #define SYSBUS_ERR_MSG_NUM	8
@@ -517,6 +604,9 @@ static void process_sysbus_error(struct mem_ctl_info *mci,
 {
 	int i;
 	u8 error = info->sysbus_ferr | info->sysbus_nerr;
+#ifdef CONFIG_EDAC_VMC
+	int sensor_id= -1;
+#endif
 
 	mci->sysbus_err_count++;
 
@@ -525,6 +615,34 @@ static void process_sysbus_error(struct mem_ctl_info *mci,
 			edac_mc_printk(mci, KERN_WARNING, "Error System Bus: %s\n",
 				       sysbus_message[i]);
 	}
+
+#ifdef CONFIG_EDAC_VMC
+	/* determine which sensor to report to */
+	if ( error & (1 << 0) )
+		sensor_id = SYSBUS_ADD_REQ_PAR_FLT;
+	else if ( error & (1 << 1) )
+		sensor_id = SYSBUS_DSTROBE_FLT;
+	else if ( error & (1 << 2) )
+		sensor_id = SYSBUS_ASTROBE_FLT;
+	else if ( error & (1 << 3) )
+		sensor_id = SYSBUS_DATA_PAR_FLT;
+	else if ( error & (1 << 4) )
+		sensor_id = SYSBUS_ADDR_TOM_FLT;
+	else if ( error & (1 << 5) )
+		sensor_id = SYSBUS_NONDRAM_LOCK_FLT;
+	else if ( error & (1 << 6) )
+		sensor_id = SYSBUS_MCERR_FLT;
+	else if ( error & (1 << 7) )
+		sensor_id = SYSBUS_BINIT_FLT;
+
+	if (sensor_id >= 0) {
+		/* report fault to vMC */
+		vmc_report_fault(sensor_id, e7xxx_vmc_lun, SENSOR_ACTION_SET,
+				 TH_GEN_UPPER_NON_RECOVERABLE, 2,
+				 "SYSBUS_FERR", info->sysbus_ferr,
+				 "SYSBUS_NERR", info->sysbus_nerr);
+	}
+#endif
 }
 
 static void e7xxx_get_error_info(struct mem_ctl_info *mci,
@@ -907,6 +1025,84 @@ static void e7501_D0F1_exit(struct pci_dev *dev)
 	}
 }
 
+#ifdef CONFIG_EDAC_VMC
+static int init_vmc_sensors(void)
+{
+	int rc;
+
+	struct vmc_sensor_params_s uecc_flt_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_MEMORY,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = GEN_THRESHOLD_TBL,
+		.threshold_mask = DEFAULT_READ_SET_THRES_MASK,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	struct vmc_sensor_params_s cecc_flt_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_MEMORY,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = CECC_THRESHOLD_TBL,
+		.threshold_mask = READ_THRES_MASK_UPPER_CRITICAL,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	/* Assign a vMC LUN to this chipset */
+	e7xxx_vmc_lun = vmc_assign_lun();
+
+	/* Sensors with non-default parameters */
+	rc  = vmc_sensor_init(UECC_FLT, e7xxx_sensor_map, e7xxx_sensor_names,
+			      e7xxx_vmc_lun, &uecc_flt_params);
+	rc |= vmc_sensor_init(CECC_FLT, e7xxx_sensor_map, e7xxx_sensor_names,
+			      e7xxx_vmc_lun, &cecc_flt_params);
+
+#define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id), e7xxx_sensor_map,	\
+						e7xxx_sensor_names,	\
+						e7xxx_vmc_lun, NULL)
+	/* Sensors with default parameters: */
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_ADD_REQ_PAR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_DSTROBE_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_ASTROBE_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_DATA_PAR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_ADDR_TOM_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_NONDRAM_LOCK_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_MCERR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(SYSBUS_BINIT_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HUB_ADDR_CMD_PAR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HUB_DATA_PAR_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HUB_TARGET_ABORT_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HIB_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HIC_FLT);
+	rc |= INIT_SENSOR_DEFAULT(HID_FLT);
+#undef INIT_SENSOR_DEFAULT
+
+	return rc;
+}
+
+static void uninit_vmc_sensors(void)
+{
+	vmc_sensor_uninit(UECC_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(CECC_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_ADD_REQ_PAR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_DSTROBE_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_ASTROBE_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_DATA_PAR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_ADDR_TOM_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_NONDRAM_LOCK_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_MCERR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(SYSBUS_BINIT_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HUB_ADDR_CMD_PAR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HUB_DATA_PAR_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HUB_TARGET_ABORT_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HIB_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HIC_FLT, e7xxx_vmc_lun);
+	vmc_sensor_uninit(HID_FLT, e7xxx_vmc_lun);
+}
+
+#endif /* CONFIG_EDAC_VMC */
+
+
 static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 {
 	u16 pci_data;
@@ -918,6 +1114,14 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 
 	debugf0("%s(): mci\n", __func__);
 
+#ifdef CONFIG_EDAC_VMC
+	/* Initialize vMC Sensors */
+	if (init_vmc_sensors()) {
+		e7xxx_printk(KERN_ERR, "failed to initialize one or more " \
+				       "vMC sensors\n");
+	}
+#endif
+
 	pci_read_config_dword(pdev, E7XXX_DRC, &drc);
 
 	drc_chan = dual_channel_active(drc, dev_idx);
@@ -1058,6 +1262,11 @@ static void __devexit e7xxx_remove_one(struct pci_dev *pdev)
 
 	debugf0("%s()\n", __func__);
 
+#ifdef CONFIG_EDAC_VMC
+	/* Uninitialize vMC sensors */
+	uninit_vmc_sensors();
+#endif
+
 	if (e7xxx_pci)
 		edac_pci_release_generic_ctl(e7xxx_pci);
 
diff --git a/drivers/edac/e7xxx_edac_vmc.h b/drivers/edac/e7xxx_edac_vmc.h
new file mode 100644
index 0000000..26ec240
--- /dev/null
+++ b/drivers/edac/e7xxx_edac_vmc.h
@@ -0,0 +1,108 @@
+/*
+ * e7xxx_edac_vmc.h, vMC sensor maps for e7xxx EDAC driver
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Author: Matt Wagantall <matthew.wagantall@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _E7XXX_EDAC_VMC_H_
+#define _E7XXX_EDAC_VMC_H_
+
+/* Assign sensor numbers.
+ *   Order is arbitrary */
+enum e7xxx_sensors {
+	/* Gerneral sensors: */
+	UECC_FLT = 0,
+	CECC_FLT,
+
+	SYSBUS_ADD_REQ_PAR_FLT,
+	SYSBUS_DSTROBE_FLT,
+	SYSBUS_ASTROBE_FLT,
+	SYSBUS_DATA_PAR_FLT,
+	SYSBUS_ADDR_TOM_FLT,
+	SYSBUS_NONDRAM_LOCK_FLT,
+	SYSBUS_MCERR_FLT,
+	SYSBUS_BINIT_FLT,
+
+	HUB_ADDR_CMD_PAR_FLT,
+	HUB_DATA_PAR_FLT,
+	HUB_TARGET_ABORT_FLT,
+
+	HIB_FLT,
+	HIC_FLT,
+	HID_FLT
+};
+
+/* Assign sensor names.
+ * macro usage: name_sensor( name ),
+ *   Order does not matter here */
+#define name_sensor(x) [(x)] = #x
+static const char *e7xxx_sensor_names[] = {
+	name_sensor(UECC_FLT),
+	name_sensor(CECC_FLT),
+
+	name_sensor(SYSBUS_ADD_REQ_PAR_FLT),
+	name_sensor(SYSBUS_DSTROBE_FLT),
+	name_sensor(SYSBUS_ASTROBE_FLT),
+	name_sensor(SYSBUS_DATA_PAR_FLT),
+	name_sensor(SYSBUS_ADDR_TOM_FLT),
+	name_sensor(SYSBUS_NONDRAM_LOCK_FLT),
+	name_sensor(SYSBUS_MCERR_FLT),
+	name_sensor(SYSBUS_BINIT_FLT),
+
+	name_sensor(HUB_ADDR_CMD_PAR_FLT),
+	name_sensor(HUB_DATA_PAR_FLT),
+	name_sensor(HUB_TARGET_ABORT_FLT),
+
+	name_sensor(HIB_FLT),
+	name_sensor(HIC_FLT),
+	name_sensor(HID_FLT)
+};
+
+/* Map sensors to vMC IPMI entities.
+ * macro usage: map_sensor(sensor, entity type, entity instance),
+ *   Order does not matter here */
+#define map_sensor(x, y, z) [(x)] = (((y) << 8) | (z))
+static const int e7xxx_sensor_map[] = {
+	/* General sensors: */
+	map_sensor(UECC_FLT,		IPMI_ENTITY_ID_MEMORY_DEVICE,	0x00),
+	map_sensor(CECC_FLT,		IPMI_ENTITY_ID_MEMORY_DEVICE,	0x00),
+
+	map_sensor(SYSBUS_ADD_REQ_PAR_FLT, IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_DSTROBE_FLT,	IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_ASTROBE_FLT,	IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_DATA_PAR_FLT, IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_ADDR_TOM_FLT, IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_NONDRAM_LOCK_FLT, IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_MCERR_FLT,	IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+	map_sensor(SYSBUS_BINIT_FLT,	IPMI_ENTITY_ID_SYSTEM_BUS,	0x00),
+
+	map_sensor(HUB_ADDR_CMD_PAR_FLT,IPMI_ENTITY_ID_PCI_BUS,		0x00),
+	map_sensor(HUB_DATA_PAR_FLT,	IPMI_ENTITY_ID_PCI_BUS,		0x00),
+	map_sensor(HUB_TARGET_ABORT_FLT,IPMI_ENTITY_ID_PCI_BUS,		0x00),
+
+	map_sensor(HIB_FLT,		IPMI_ENTITY_ID_PCI_BUS,		0x01),
+	map_sensor(HIC_FLT,		IPMI_ENTITY_ID_PCI_BUS,		0x02),
+	map_sensor(HID_FLT,		IPMI_ENTITY_ID_PCI_BUS,		0x03),
+
+
+};
+
+/* e7xxx vMC IPMI LUN number */
+static int e7xxx_vmc_lun;
+
+#endif	/* _E7XXX_EDAC_VMC_H_ */
-- 
1.6.0.3

