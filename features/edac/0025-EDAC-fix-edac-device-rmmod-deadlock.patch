From 2b4ee47ea8b1ef5e6c20028370ec538d8d4af427 Mon Sep 17 00:00:00 2001
From: Harry Ciao <qingtao.cao@windriver.com>
Date: Thu, 4 Dec 2008 13:36:52 +0800
Subject: [PATCH] EDAC: fix edac device rmmod deadlock

The work of an edac device has to be completed before the whole edac_dev
structure being removed. flush_cpu_workqueue() is used to wait for all works
in edac_poller's workqueue to be processed, by inserting a wq_barrier into
the tail of the workqueue, then sleeping on the completion of this wq_barrier,
expecting edac_poller to run wq_barrier.work to wake it up.

Works of all current edac devices share the same callback function of
edac_device_workq_function(), which would grab the mutex of device_ctls_mutex
before it checks the device. This is exactly where edac_poller and rmmod
would have a great chance to deadlock each other - on one hand rmmod would
sleep on the completion of a wq_barrier, holding device_ctls_mutex; on the
other hand edac_poller would be blocked on the same mutex when it's running
any one of works of existing edac evices(Note, this edac_dev.work is likely
to be totally irrelevant to the one that is being removed right now)and never
would have a chance to run the work of above wq_barrier to wake rmmod up.

That's why edac_device_workq_teardown() should be moved outside of the critical
region of device_ctls_mutex. Moreover, an edac_dev.work should bail out
immediately if it is being removed.

Signed-off-by: Harry Ciao<qingtao.cao@windriver.com>
---
 drivers/edac/edac_device.c |   12 +++++++++---
 1 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 5fcd3d8..4041e91 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -394,6 +394,12 @@ static void edac_device_workq_function(struct work_struct *work_req)
 
 	mutex_lock(&device_ctls_mutex);
 
+	/* If we are being removed, bail out immediately */
+	if (edac_dev->op_state == OP_OFFLINE) {
+		mutex_unlock(&device_ctls_mutex);
+		return;
+	}
+
 	/* Only poll controllers that are running polled and have a check */
 	if ((edac_dev->op_state == OP_RUNNING_POLL) &&
 		(edac_dev->edac_check != NULL)) {
@@ -585,14 +591,14 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 	/* mark this instance as OFFLINE */
 	edac_dev->op_state = OP_OFFLINE;
 
-	/* clear workq processing on this instance */
-	edac_device_workq_teardown(edac_dev);
-
 	/* deregister from global list */
 	del_edac_device_from_global_list(edac_dev);
 
 	mutex_unlock(&device_ctls_mutex);
 
+	/* clear workq processing on this instance */
+	edac_device_workq_teardown(edac_dev);
+
 	/* Tear down the sysfs entries for this instance */
 	edac_device_remove_sysfs(edac_dev);
 
-- 
1.6.0.2.GIT

