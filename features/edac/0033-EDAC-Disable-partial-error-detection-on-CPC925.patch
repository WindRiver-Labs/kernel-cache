From 935d7a0338f22ab70f092cef0dde358a9a719e58 Mon Sep 17 00:00:00 2001
From: Harry Ciao <qingtao.cao@windriver.com>
Date: Thu, 5 Feb 2009 18:03:10 +0800
Subject: [PATCH] EDAC: Disable partial error detection on CPC925

According to CPC925 Bridge and Memory Controller User Manual P294,
only bits 22 and 23 in the Link Configuration and Control register
can be set for CPC925, because it has only two byte lanes.

Also, no matter the HT_EOC, HT_OVERFLOW and HT_PROTOCOL enable bits in
Error Handling register set or not, the EOC/OVF/Protocol error
flag bits in Link Error register would always be set and couldn't
be cleared by software, so temporarily we have to not enable nor
check these three error detections.

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
---
 drivers/edac/cpc925_edac.c |   18 +++++++++++-------
 drivers/edac/cpc925_edac.h |   12 +++++++++++-
 2 files changed, 22 insertions(+), 8 deletions(-)

diff --git a/drivers/edac/cpc925_edac.c b/drivers/edac/cpc925_edac.c
index d330af7..a4bfc26 100644
--- a/drivers/edac/cpc925_edac.c
+++ b/drivers/edac/cpc925_edac.c
@@ -168,17 +168,13 @@ static void _cpu_exit(struct edac_device_ctl_info *edac_dev)
 static void _ht_init(struct edac_device_ctl_info *edac_dev)
 {
 	struct cpc925_pdata *pdata = edac_dev->pvt_info;
-	*(volatile u32*)(pdata->vbase + CPC925_HT_ERR_ENUM) |=
-		HT_SERR | HT_CRC | HT_RESPONSE |
-		HT_EOC | HT_OVERFLOW | HT_PROTOCOL;
+	*(volatile u32*)(pdata->vbase + CPC925_HT_ERR_ENUM) |= HT_ERR_ENABLE;
 }
 
 static void _ht_exit(struct edac_device_ctl_info *edac_dev)
 {
 	struct cpc925_pdata *pdata = edac_dev->pvt_info;
-	*(volatile u32*)(pdata->vbase + CPC925_HT_ERR_ENUM) &=
-		~(HT_SERR | HT_CRC | HT_RESPONSE |
-		HT_EOC | HT_OVERFLOW | HT_PROTOCOL);
+	*(volatile u32*)(pdata->vbase + CPC925_HT_ERR_ENUM) &= ~HT_ERR_ENABLE;
 }
 
 static void _dram_dump_regs(const void * const base, const u32 check_value)
@@ -348,8 +344,16 @@ static int _ht_check(struct edac_device_ctl_info *edac_dev)
 	error_enum = CPC925_REG32BE_READ(base, CPC925_HT_ERR_ENUM);
 	link_error = CPC925_REG32BE_READ(base, CPC925_HT_LINK_FREQ);
 
+	/*
+	 * FIXME:
+	 * The error indicators of EOC/OVF/Protocol in Link Error register
+	 * would always be set and couldn't be cleared by software, no
+	 * matter if the HT_EOC, HT_OVERFLOW and HT_PROTOCOL enable bits
+	 * in Error Handling register being set or not. Temporarily we do
+	 * not enable nor check these three error detection bits.
+	 */
 	if(!((bridge_ctrl & HT_SERR) || (link_cfg_ctl & HT_LINK_CTL_ERR) ||
-		(error_enum & HT_ERR_ENUM_ERR) || (link_error & HT_LINK_ERR))) {
+		(error_enum & HT_ERR_ENUM_ERR) /*|| (link_error & HT_LINK_ERR)*/)) {
 		return 0;
 	}
 
diff --git a/drivers/edac/cpc925_edac.h b/drivers/edac/cpc925_edac.h
index a66adaf..10ff4bb 100644
--- a/drivers/edac/cpc925_edac.h
+++ b/drivers/edac/cpc925_edac.h
@@ -47,6 +47,14 @@
 #define CPC925_HT_LINK_CFG_CTL	0x00070110
 #define CPC925_HT_LINK_FREQ	0x00070120
 
+/*
+ * FIXME:
+ * The error indicators of EOC/OVF/Protocol in Link Error register
+ * would always be set and couldn't be cleared by software, no
+ * matter if the HT_EOC, HT_OVERFLOW and HT_PROTOCOL enable bits
+ * in Error Handling register being set or not. Temporarily we do
+ * not enable nor check these three error detection bits.
+ */
 enum cpc925_ht_bits {
 	HT_SERR		= BIT(0),
 	HT_CRC		= BIT(1),
@@ -54,8 +62,10 @@ enum cpc925_ht_bits {
 	HT_EOC		= BIT(3),
 	HT_OVERFLOW	= BIT(4),
 	HT_PROTOCOL	= BIT(5),
+	HT_ERR_ENABLE	= (HT_SERR | HT_CRC | HT_RESPONSE /* |
+			   HT_EOC | HT_OVERFLOW | HT_PROTOCOL */),
 	HT_SBRESET	= BIT(9),
-	HT_CRC_ERR	= (BIT(20) | BIT(21) | BIT(22) | BIT(23)),
+	HT_CRC_ERR	= (BIT(22) | BIT(23)),
 	HT_LINK_FAIL	= BIT(27),
 	HT_LINK_CTL_ERR	= (HT_CRC_ERR | HT_LINK_FAIL),
 	HT_RESPONSE_ERR	= BIT(6),
-- 
1.6.0.3

