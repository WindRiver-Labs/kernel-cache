From ef5311cd526256c71ea7f86d11af232cff5e6a09 Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Sat, 8 Nov 2008 17:57:04 -0500
Subject: [PATCH] EDAC: Add vMC API wrapper functions

Implement a framework for vMC sensor creation and fault reporting
from EDAC.  Calls to these wrapper functions must be added to
EDAC chipset drivers in order to report fault events to the vMC.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 drivers/edac/Kconfig       |    9 ++
 drivers/edac/Makefile      |    4 +
 drivers/edac/edac_module.c |   13 ++-
 drivers/edac/edac_vmc.c    |  241 ++++++++++++++++++++++++++++++++++++++++++++
 drivers/edac/edac_vmc.h    |  158 +++++++++++++++++++++++++++++
 5 files changed, 423 insertions(+), 2 deletions(-)
 create mode 100644 drivers/edac/edac_vmc.c
 create mode 100644 drivers/edac/edac_vmc.h

diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index 14261c3..f56abf5 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -32,6 +32,15 @@ if EDAC
 
 comment "Reporting subsystems"
 
+config EDAC_VMC
+	bool "vMC Integration"
+	default n
+	depends on IPMI_VMC
+	help
+	  This enables vMC API calls within EDAC drivers to report fault
+	  events to the IPMI vMC (Virtual Management Controller).
+	  If unsure, select 'N'.
+
 config EDAC_DEBUG
 	bool "Debugging"
 	help
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index 99c714c..cd46ce3 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -17,6 +17,10 @@ ifdef CONFIG_PCI
 edac_core-objs	+= edac_pci.o edac_pci_sysfs.o
 endif
 
+ifdef CONFIG_EDAC_VMC
+edac_core-objs	+= edac_vmc.o
+endif
+
 obj-$(CONFIG_EDAC_AMD76X)		+= amd76x_edac.o
 obj-$(CONFIG_EDAC_I5000)		+= i5000_edac.o
 obj-$(CONFIG_EDAC_I5100)		+= i5100_edac.o
diff --git a/drivers/edac/edac_module.c b/drivers/edac/edac_module.c
index 1768d4d..506072e 100644
--- a/drivers/edac/edac_module.c
+++ b/drivers/edac/edac_module.c
@@ -12,10 +12,13 @@
  */
 #include <linux/edac.h>
 
-#include "edac_core.h"
-#include "edac_module.h"
+#ifdef CONFIG_EDAC_VMC
+#include <linux/vmc.h>
+#endif
 
 #define EDAC_VERSION "Ver: 2.1.0 " __DATE__
+#include "edac_core.h"
+#include "edac_module.h"
 
 #ifdef CONFIG_EDAC_DEBUG
 /* Values of 0 to 4 will generate output */
@@ -144,6 +147,12 @@ static int __init edac_init(void)
 
 	edac_printk(KERN_INFO, EDAC_MC, EDAC_VERSION "\n");
 
+#ifdef CONFIG_EDAC_VMC
+	/* Make sure vmc module is loaded or compiled in */
+	err = vMC_kick();
+	if (err < 0)
+		goto error;
+#endif
 	/*
 	 * Harvest and clear any boot/initialization PCI parity errors
 	 *
diff --git a/drivers/edac/edac_vmc.c b/drivers/edac/edac_vmc.c
new file mode 100644
index 0000000..cc8e659
--- /dev/null
+++ b/drivers/edac/edac_vmc.c
@@ -0,0 +1,241 @@
+/*
+ * edac_vmc.c, EDAC wrapper routines for the vMC API
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Author: Matt Wagantall <matthew.wagantall@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+#include <linux/vmc.h>
+#include "edac_vmc.h"
+
+/* Number of vMC LUNs.  Each chipset registers sensors on a different LUN */
+DEFINE_SPINLOCK(num_luns_lock);
+static int vmc_num_luns;
+
+/* Return a unique vMC LUN number for a sensor.
+ *   No two EDAC chipsets may be on the same LUN since their sensor IDs
+ *   would overlap.  Each EDAC chipset driver should request exactly
+ *   one LUN number and use it for all its sensors. */
+unsigned char vmc_assign_lun(void)
+{
+	unsigned char retval;
+
+	spin_lock(&num_luns_lock);
+	retval = vmc_num_luns++;
+	spin_unlock(&num_luns_lock);
+
+	return retval;
+}
+EXPORT_SYMBOL(vmc_assign_lun);
+
+/* Initialize a single fault detection vMC Sensor Data Records (SDR).
+ * See edac_vmc.h for usage */
+int vmc_sensor_init(int sensor_id, const int *sensor_map,
+		     const char *sensor_names[], int sensor_lun,
+		     struct vmc_sensor_params_s *sensor_params)
+{
+	int rc = -1;
+	vMC_ipmi_sensor_ident_t sensor_ident;
+	vMC_ipmi_sdr_t *vmc_sdr;
+	struct vmc_sensor_params_s default_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_CRITICAL_INTERRUPT,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = GEN_THRESHOLD_TBL,
+		.threshold_mask = DEFAULT_READ_SET_THRES_MASK,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	/* Specify sensor */
+	sensor_ident.sensor_mc = EDAC_VMC_MC;
+	sensor_ident.sensor_lun = sensor_lun;
+	sensor_ident.sensor_num = sensor_id;
+
+	// use default paramaters if none are specified
+	if (!sensor_params)
+		sensor_params = &default_params;
+
+	vmc_sdr = (*vMC_alloc_sdr_record)(EDAC_VMC_MC, IPMI_SDR_FULL_TYPE, &rc);
+	if (rc != VMC_NO_ERROR) {
+		fprintk("edac_init_vmc_sdr could not allocate vMC SDR (%d)\n",
+			rc);
+		rc = vMC_device_sdr_delete(&sensor_ident);
+		return rc;
+	}
+	if (vmc_sdr == NULL) {
+		fprintk("edac_init_vmc_sdr failed\n");
+		return rc;
+	}
+
+
+	/* Populate IPMI SDR Header (see IPMI 1.5 specification) */
+	vmc_sdr->sdr_hdr.record_length = sizeof(struct vMC_ipmi_sdr_full_s);
+	vmc_sdr->sdr_hdr.record_type = 0x1;
+
+	/* Populate IPMI SDR Body (see IPMI 1.5 specification) */
+	vmc_sdr->sdr_body.sdr_full.id_type = 0;
+	vmc_sdr->sdr_body.sdr_full.id = (EDAC_VMC_MC & 0xfe) >> 1;
+	vmc_sdr->sdr_body.sdr_full.sensor_owner_lun = 0;
+	vmc_sdr->sdr_body.sdr_full.lun_channel = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_number = sensor_id;
+	vmc_sdr->sdr_body.sdr_full.entity_ID = get_sensor_entity(sensor_map, sensor_id);
+	vmc_sdr->sdr_body.sdr_full.entity_instance_num = get_sensor_entity_instance(sensor_map, sensor_id);
+	vmc_sdr->sdr_body.sdr_full.entity_instance_type = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_scanning_enabled = 1;
+	vmc_sdr->sdr_body.sdr_full.event_generation_enabled = 1;
+	vmc_sdr->sdr_body.sdr_full.type_init_required = 1;
+	vmc_sdr->sdr_body.sdr_full.init_hysteresis = 0;
+	vmc_sdr->sdr_body.sdr_full.threshold_init_required = 1;
+	vmc_sdr->sdr_body.sdr_full.init_event_messages = 1;
+	vmc_sdr->sdr_body.sdr_full.init_scanning = 1;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_event_msg_control = ENTIRE_SENSOR_ONLY;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_threshold_access = THRESHOLDS_READABLE_SETTABLE;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_hysteresis_support = NO_HYSTERESIS;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_auto_rearm = 0;
+	vmc_sdr->sdr_body.sdr_full.sens_capable_ignore = 0;
+	vmc_sdr->sdr_body.sdr_full.event_reading_type_code = sensor_params->event_reading_type;
+	vmc_sdr->sdr_body.sdr_full.assertion_event_mask = DEFAULT_ASSERTION_EVENT_MASK;
+	vmc_sdr->sdr_body.sdr_full.deassertion_event_mask = DEFAULT_DEASSERTION_EVENT_MASK;
+	vmc_sdr->sdr_body.sdr_full.read_thres_mask = sensor_params->threshold_mask;
+	vmc_sdr->sdr_body.sdr_full.set_thres_mask = sensor_params->threshold_mask;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_1_rate_unit = sensor_params->leak_rate;
+	vmc_sdr->sdr_body.sdr_full.thresholds[UPPER_NON_RECOVERABLE] = sensor_params->thresholds[UPPER_NON_RECOVERABLE];
+	vmc_sdr->sdr_body.sdr_full.thresholds[UPPER_CRITICAL] = sensor_params->thresholds[UPPER_CRITICAL];
+	vmc_sdr->sdr_body.sdr_full.thresholds[UPPER_NON_CRITICAL] = sensor_params->thresholds[UPPER_NON_CRITICAL];
+	vmc_sdr->sdr_body.sdr_full.thresholds[LOWER_NON_RECOVERABLE] = sensor_params->thresholds[LOWER_NON_RECOVERABLE];
+	vmc_sdr->sdr_body.sdr_full.thresholds[LOWER_CRITICAL] = sensor_params->thresholds[LOWER_CRITICAL];
+	vmc_sdr->sdr_body.sdr_full.thresholds[LOWER_NON_CRITICAL] = sensor_params->thresholds[LOWER_NON_CRITICAL];
+	vmc_sdr->sdr_body.sdr_full.sensor_type = sensor_params->sensor_type;
+	strcpy(vmc_sdr->sdr_body.sdr_full.id_string, sensor_names[sensor_id]);
+	vmc_sdr->sdr_body.sdr_full.M_ls8bits = 1;
+	vmc_sdr->sdr_body.sdr_full.id_string_num_bytes = strlen(vmc_sdr->sdr_body.sdr_full.id_string);
+	vmc_sdr->sdr_body.sdr_full.id_string_type_code = 0x3;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_1_percentage = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_1_modifier_unit = MODIFIER_NONE;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_1_raw_data_format = FORMAT_UNSIGNED;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_2_base_unit = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_units_3_modifier_unit = 0;
+	vmc_sdr->sdr_body.sdr_full.positive_hysteresis = 0;
+	vmc_sdr->sdr_body.sdr_full.negative_hysteresis = 0;
+	vmc_sdr->sdr_body.sdr_full.M_ms2bits = 0;
+	vmc_sdr->sdr_body.sdr_full.B_ls8bits = 0;
+	vmc_sdr->sdr_body.sdr_full.B_ms2bits = 0;
+	vmc_sdr->sdr_body.sdr_full.nominal_reading = 0;
+	vmc_sdr->sdr_body.sdr_full.normal_maximum = 0;
+	vmc_sdr->sdr_body.sdr_full.normal_minimum = 0;
+	vmc_sdr->sdr_body.sdr_full.sensor_maximum_reading = 255;
+	vmc_sdr->sdr_body.sdr_full.sensor_minimum_reading = 0;
+	vmc_sdr->sdr_body.sdr_full.bmc_enable = 1;
+	vmc_sdr->sdr_body.sdr_full.ipmb_upper_non_recoverable_enable = 1;
+	vmc_sdr->sdr_body.sdr_full.ipmb_lower_non_recoverable_enable = 1;
+	vmc_sdr->sdr_body.sdr_full.containment_enable = sensor_params->containment_enable;
+
+	/* Send SDR to vMC core */
+	rc = vMC_device_sdr_add(vmc_sdr);
+	if (rc != VMC_NO_ERROR) {
+		fprintk("vmc_sensor_init could not add vMC SDR for %d %s\n",
+			rc, sensor_names[sensor_id]);
+		vMC_device_sdr_delete(&sensor_ident);
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(vmc_sensor_init);
+
+/* Report a fault to vMC
+ * See edac_vmc.h for usage */
+int vmc_report_fault(int sensor_id, int sensor_lun, int action, int value, int num_regs, ...)
+{
+	int i, result, rc;
+	va_list argptr;
+	vMC_ipmi_sel_record_t *sel_record;
+	vMC_ipmi_sensor_ident_t sensor_ident;
+	fault_record_t *extended_data;
+	int sensor_value = 0;
+
+	if (num_regs > MAX_FAULT_RECORD_SIZE) {
+		rc = 1;
+		goto error;
+	}
+
+	/* Allocate vMC SEL record */
+	sel_record = vMC_alloc_sel_record(sizeof(fault_record_t), 0, &result);
+	if (result != VMC_NO_ERROR) {
+		rc = 1;
+		goto error;
+	}
+
+	/* Threshold sensor event */
+	sel_record->event_type = 0x01;
+	sel_record->sel_event_data.event_data[0] = 0x01;
+
+	/* Record fault type */
+	extended_data = (fault_record_t *) sel_record->extended_event_data;
+	extended_data->fault_type = 0; /* currently unused */
+
+	/* Store register names and values in SEL record */
+	va_start(argptr,num_regs);
+	for (i = 0; i < num_regs; ++i) {
+		strncpy(extended_data->fault_record_data[i].reg_name,
+			va_arg(argptr, char *), MAX_REG_NAME_SIZE);
+		extended_data->fault_record_data[i].data = va_arg(argptr, int);
+	}
+
+	/* Specify sensor */
+	sensor_ident.sensor_mc = EDAC_VMC_MC;
+	sensor_ident.sensor_lun = sensor_lun;
+	sensor_ident.sensor_num = sensor_id;
+
+	/* Increment sensor value */
+	if (action == SENSOR_ACTION_INC) {
+		if (vMC_sensor_get_value (&sensor_ident, &sensor_value) == VMC_NO_ERROR) {
+			if (sensor_value < (TH_GEN_UPPER_NON_RECOVERABLE-1)) {
+				rc = vMC_sensor_increment_value(&sensor_ident, value, sel_record);
+			}	/* else don't do anything since we would our unrecoverable case */
+		}
+	}
+	/* ...or set sensor value (action == SENSOR_ACTION_SET) */
+	else {
+		if (vMC_sensor_set_value(&sensor_ident, value, sel_record)) {
+			rc = 1;
+			goto error;
+		}
+	}
+
+	/* return success */
+	rc = 0;
+error:
+	return rc;
+
+}
+EXPORT_SYMBOL(vmc_report_fault);
+
+/* Uninitialize a vMC sensor
+ * See edav_vmc.h for usage */
+void vmc_sensor_uninit(int sensor_id, int sensor_lun)
+{
+	vMC_ipmi_sensor_ident_t sensor_ident;
+
+	/* Specify sensor */
+	sensor_ident.sensor_mc = EDAC_VMC_MC;
+	sensor_ident.sensor_lun = sensor_lun;
+	sensor_ident.sensor_num = sensor_id;
+
+	/* Request vMC core remove SDR */
+	vMC_device_sdr_delete(&sensor_ident);
+}
+EXPORT_SYMBOL(vmc_sensor_uninit);
diff --git a/drivers/edac/edac_vmc.h b/drivers/edac/edac_vmc.h
new file mode 100644
index 0000000..852f6c8
--- /dev/null
+++ b/drivers/edac/edac_vmc.h
@@ -0,0 +1,158 @@
+/*
+ * edac_vmc.h, EDAC vMC API wrapper header file
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Author: Matt Wagantall <matthew.wagantall@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _EDAC_VMC_H_
+#define _EDAC_VMC_H_
+
+#include <linux/vmc.h>
+#include <linux/ipmi_bits.h>
+
+/* vMC MC sensors belong to */
+#define EDAC_VMC_MC				0x00
+
+/* general sensor threshold values */
+#define TH_GEN_UPPER_NON_RECOVERABLE		255
+#define TH_GEN_UPPER_CRITICAL			120
+#define TH_GEN_UPPER_NON_CRITICAL		60
+#define TH_GEN_LOWER_NON_RECOVERABLE		255
+#define TH_GEN_LOWER_CRITICAL			10
+#define TH_GEN_LOWER_NON_CRITICAL		5
+#define GEN_THRESHOLD_TBL	{	TH_GEN_UPPER_NON_RECOVERABLE,	\
+					TH_GEN_UPPER_CRITICAL,	\
+					TH_GEN_UPPER_NON_CRITICAL,	\
+					TH_GEN_LOWER_NON_RECOVERABLE,	\
+					TH_GEN_LOWER_CRITICAL,	\
+					TH_GEN_LOWER_NON_CRITICAL	}
+
+/* CECC sensor threshold values */
+#define TH_CECC_UPPER_NON_RECOVERABLE		255
+#define TH_CECC_UPPER_CRITICAL			10
+#define TH_CECC_UPPER_NON_CRITICAL		2
+#define TH_CECC_LOWER_NON_RECOVERABLE		255
+#define TH_CECC_LOWER_CRITICAL			10
+#define TH_CECC_LOWER_NON_CRITICAL		2
+#define CECC_THRESHOLD_TBL 	{	TH_CECC_UPPER_NON_RECOVERABLE,	\
+					TH_CECC_UPPER_CRITICAL,		\
+					TH_CECC_UPPER_NON_CRITICAL,	\
+					TH_CECC_LOWER_NON_RECOVERABLE,	\
+					TH_CECC_LOWER_CRITICAL,		\
+					TH_CECC_LOWER_NON_CRITICAL	}
+
+/* CRC sensor threshold values */
+#define TH_CRC_UPPER_NON_RECOVERABLE		255
+#define TH_CRC_UPPER_CRITICAL			10
+#define TH_CRC_UPPER_NON_CRITICAL		2
+#define TH_CRC_LOWER_NON_RECOVERABLE		255
+#define TH_CRC_LOWER_CRITICAL			10
+#define TH_CRC_LOWER_NON_CRITICAL		2
+#define CRC_THRESHOLD_TBL	{	TH_CRC_UPPER_NON_RECOVERABLE,	\
+					TH_CRC_UPPER_CRITICAL,		\
+					TH_CRC_UPPER_NON_CRITICAL,	\
+					TH_CRC_LOWER_NON_RECOVERABLE,	\
+					TH_CRC_LOWER_CRITICAL,		\
+					TH_CRC_LOWER_NON_CRITICAL	}
+
+/* Default sensor threshold read and set mask */
+#define DEFAULT_READ_SET_THRES_MASK \
+			READ_THRES_MASK_LOWER_NON_CRITICAL \
+			| READ_THRES_MASK_LOWER_CRITICAL \
+			| READ_THRES_MASK_LOWER_NON_RECOVERABLE \
+			| READ_THRES_MASK_UPPER_NON_CRITICAL \
+			| READ_THRES_MASK_UPPER_CRITICAL \
+			| READ_THRES_MASK_UPPER_NON_RECOVERABLE
+
+/* Faults can either increment a sensor or set it to a specific value */
+#define SENSOR_ACTION_INC	1
+#define SENSOR_ACTION_SET	0
+
+/* Convenient KERN_INFO level debug print macro */
+#define fprintk(format, arg...) printk(KERN_INFO "%s:%d " format \
+				       "\n" , __func__, __LINE__, ## arg)
+
+/* Sensor-Entity Map Queries */
+#define get_sensor_entity(x, y) ((char)(x)[(y)] >> 8)
+#define get_sensor_entity_instance(x, y) ((x)[(y)] & 0x0F)
+
+
+/*
+ * Data-type Definitions:
+ */
+
+/* sensor-specific contiguration struct used by vmc_sensor_init */
+struct vmc_sensor_params_s {
+	unsigned char sensor_type;
+	unsigned char event_reading_type;
+	unsigned char thresholds[6];
+	uint16_t threshold_mask;
+	int leak_rate;
+	unsigned char containment_enable:1;
+};
+
+
+/*
+ * Function Prototypes:
+ */
+
+/* Return a unique vMC LUN number a sensor.
+ *  No two EDAC chipsets may be on the same LUN since their sensor IDs
+ *   would overlap.  Each EDAC chipset driver should request exactly
+ *   one LUN number and use it for all its sensors. */
+unsigned char vmc_assign_lun(void);
+
+
+/* Initialize a vMC sensor given it's sensor ID, LUN, sensor-entity map,
+ * name table, and an optional pointer to configuration parameters.
+ * If sensor_params is a NULL pointer, the following defaults are assumed:
+ *   sensor type = IPMI_SENSOR_TYPE_CRITICAL_INTERRUPT
+ *   event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD
+ *   thresholds = GEN_THRESHOLD_TBL,
+ *   threashold_mask = DEFAULT_READ_SET_THRESH_MASK
+ *   leak_rate = RATE_MINUTE,
+ *   containment_enable = false
+ *
+ * Sensor IDs are statically assigned in *_edac_vmc.h chipset header files
+ *
+ * Returns 0 if successful */
+int vmc_sensor_init(int sensor_id, const int *sensor_map, const char *sensor_names[],
+			   int sensor_lun, struct vmc_sensor_params_s *sensor_params);
+
+
+/* Report a fault to a vMC sensor given an action, value, and a list of
+ * registers names and their contents.
+ *   Arguments:
+ *      action: increment or set (SENSOR_ACTION_INC or SENSOR_ACTION_SET)
+ *      value: increment-by or set-to (0-255)
+ *      num_regs: number of register name-value pairs to follow
+ *      (...) : register names and value (ex ."reg1_name", reg1_value,
+ *               "reg2_name", reg2_value, ...)
+ *
+ * Sensor IDs are statically assigned in *_edac_vmc.h chipset header files
+ *
+ * Returns 0 if successful */
+int vmc_report_fault(int sensor_id, int sensor_lun, int action, int value,
+			    int num_regs, ...);
+
+
+/* Uninitialize a vMC sensor given its sensor ID and sensor LUN.
+ * Sensor IDs are statically assigned in *_edac_vmc.h chipset header files */
+void vmc_sensor_uninit(int sensor_id, int sensor_lun);
+
+#endif	/* _EDAC_VMC_H_ */
-- 
1.6.0.90.g436ed

