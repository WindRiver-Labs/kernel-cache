From 23e74e633ee621e19621d9307f3a4388fc526c76 Mon Sep 17 00:00:00 2001
From: Rob Woolley <rob.woolley@windriver.com>
Date: Sat, 8 Nov 2008 13:20:24 -0500
Subject: [PATCH] EDAC driver for the DMA Controller on mv64x60 chipset

Adds the EDAC driver for the DMA Controller on mv64x60 chipset.

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
Reviewed-by: Rob Woolley <rob.woolley@windriver.com>
---
 arch/powerpc/boot/dts/prpmc2800.dts |    7 ++
 arch/powerpc/sysdev/mv64x60_dev.c   |    8 ++
 drivers/edac/mv64x60_edac.c         |  169 +++++++++++++++++++++++++++++++++++
 drivers/edac/mv64x60_edac.h         |   39 ++++++++
 4 files changed, 223 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/boot/dts/prpmc2800.dts b/arch/powerpc/boot/dts/prpmc2800.dts
index 03aab9b..8011dda 100644
--- a/arch/powerpc/boot/dts/prpmc2800.dts
+++ b/arch/powerpc/boot/dts/prpmc2800.dts
@@ -321,6 +321,13 @@
 			interrupts = <14>;
 			interrupt-parent = <&PIC>;
 		};
+
+		dma-ctrl@8c0 {
+			compatible = "marvell,mv64x60-dma-ctrl";
+			reg = <0x8c0 0x10>;
+			interrupts = <2>;
+			interrupt-parent = <&PIC>;
+		};
 	};
 
 	chosen {
diff --git a/arch/powerpc/sysdev/mv64x60_dev.c b/arch/powerpc/sysdev/mv64x60_dev.c
index 383f474..d2b15f6 100644
--- a/arch/powerpc/sysdev/mv64x60_dev.c
+++ b/arch/powerpc/sysdev/mv64x60_dev.c
@@ -601,6 +601,14 @@ static int __init mv64x60_device_setup(void)
 					"ethernet controller %s: error %d.\n",
 					np->full_name, err);
 
+	id = 0;
+	for_each_compatible_node(np, NULL, "marvell,mv64x60-dma-ctrl")
+		if ((err = mv64x60_edac_device_setup(np, id++, 1,
+					"mv64x60_dma_err")))
+			printk(KERN_ERR "Failed to initialize MV64x60 "
+					"DMA controller %s: error %d.\n",
+					np->full_name, err);
+
 	return 0;
 }
 arch_initcall(mv64x60_device_setup);
diff --git a/drivers/edac/mv64x60_edac.c b/drivers/edac/mv64x60_edac.c
index 7f600bd..89bd098 100644
--- a/drivers/edac/mv64x60_edac.c
+++ b/drivers/edac/mv64x60_edac.c
@@ -1330,6 +1330,169 @@ static struct platform_driver mv64x60_eth_err_driver = {
 	}
 };
 
+/*********************** DMA err device ****************************/
+static void mv64x60_dma_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct mv64x60_dma_pdata *pdata = edac_dev->pvt_info;
+	u32 cause;
+
+	cause = in_le32(pdata->dma_vbase + MV64X60_DMA_INTR_CAUSE);
+	if (!cause)
+		return;
+
+	printk(KERN_ERR "Error on DMA interface\n");
+	printk(KERN_ERR "Cause register: 0x%08x\n", cause);
+	printk(KERN_ERR "Address : 0x%08x\n",
+	       	in_le32(pdata->dma_vbase + MV64X60_DMA_INTR_ERR_ADDR));
+	printk(KERN_ERR "Internal error select : 0x%08x\n",
+	       	in_le32(pdata->dma_vbase + MV64X60_DMA_INTR_ERR_SELECT) &
+			MV64X60_DMA_INTR_ERR_SELECT_MASK);
+	out_le32(pdata->dma_vbase + MV64X60_DMA_INTR_CAUSE, 0);
+
+	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+}
+
+static irqreturn_t mv64x60_dma_isr(int irq, void *dev_id)
+{
+	struct edac_device_ctl_info *edac_dev = dev_id;
+	struct mv64x60_dma_pdata *pdata = edac_dev->pvt_info;
+	u32 cause;
+
+	cause = in_le32(pdata->dma_vbase + MV64X60_ETH_INTR_CAUSE);
+	if (!cause)
+		return IRQ_NONE;
+
+	mv64x60_dma_check(edac_dev);
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit mv64x60_dma_err_probe(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev;
+	struct resource *r;
+	struct mv64x60_dma_pdata *pdata;
+	int res = 0;
+
+	if (!devres_open_group(&pdev->dev, mv64x60_dma_err_probe, GFP_KERNEL))
+		return -ENOMEM;
+
+	edac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),
+					      "dma", 1, NULL, 0, 0, 
+					      NULL, 0, edac_dev_idx);
+	if (!edac_dev) {
+		devres_release_group(&pdev->dev, mv64x60_dma_err_probe);
+		return -ENOMEM;
+	}
+
+	pdata = edac_dev->pvt_info;
+	pdata->name = pdev->name;
+	pdata->irq = NO_IRQ;
+	edac_dev->dev = &pdev->dev;
+	platform_set_drvdata(pdev, edac_dev);
+	edac_dev->dev_name = pdev->dev.bus_id;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		printk(KERN_ERR "%s: Unable to get resource for "
+		       "DMA err regs\n", __func__);
+		res = -ENOENT;
+		goto err;
+	}
+
+	if (!devm_request_mem_region(&pdev->dev,
+				     r->start,
+				     r->end - r->start + 1,
+				     pdata->name)) {
+		printk(KERN_ERR "%s: Error while requesting mem region\n",
+		       __func__);
+		res = -EBUSY;
+		goto err;
+	}
+
+	pdata->dma_vbase = devm_ioremap(&pdev->dev,
+					   r->start,
+					   r->end - r->start + 1);
+
+	if (!pdata->dma_vbase) {
+		printk(KERN_ERR "%s: Unable to setup DMA err regs\n", 
+		       __func__);
+		res = -ENOMEM;
+		goto err;
+	}
+
+	/* setup DMA err registers */
+	out_le32(pdata->dma_vbase + MV64X60_DMA_INTR_CAUSE, 0);
+	out_le32(pdata->dma_vbase + MV64X60_DMA_INTR_MASK, 0);
+	out_le32(pdata->dma_vbase + MV64X60_DMA_INTR_MASK, 
+		 MV64X60_DMA_INTR_MASK_VALUE);
+
+	edac_dev->mod_name = EDAC_MOD_STR;
+	edac_dev->ctl_name = pdata->name;
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		edac_dev->edac_check = mv64x60_dma_check;
+
+	pdata->edac_idx = edac_dev_idx++;
+
+	if (edac_device_add_device(edac_dev) > 0) {
+		debugf3("%s(): failed edac_device_add_device()\n", __func__);
+		goto err;
+	}
+
+	if (edac_op_state == EDAC_OPSTATE_INT) {
+		pdata->irq = platform_get_irq(pdev, 0);
+		res = devm_request_irq(&pdev->dev,
+				       pdata->irq,
+				       mv64x60_dma_isr,
+				       IRQF_DISABLED,
+				       "[EDAC] DMA Err",
+				       edac_dev);
+		if (res < 0) {
+			printk(KERN_ERR
+			       "%s: Unable to request irq %d for MV64x60 "
+			       "DMA err\n", __func__, pdata->irq);
+			res = -ENODEV;
+			goto err2;
+		}
+
+		printk(KERN_INFO EDAC_MOD_STR
+		       " acquired irq %d for DMA err\n", pdata->irq);
+	}
+
+	devres_remove_group(&pdev->dev, mv64x60_dma_err_probe);
+
+	/* get this far and it's successful */
+	debugf3("%s(): success\n", __func__);
+
+	return 0;
+
+err2:
+	edac_device_del_device(&pdev->dev);
+err:
+	devres_release_group(&pdev->dev, mv64x60_dma_err_probe);
+	edac_device_free_ctl_info(edac_dev);
+	return res;
+}
+
+static int mv64x60_dma_err_remove(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev = platform_get_drvdata(pdev);
+
+	debugf0("%s()\n", __func__);
+
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(edac_dev);
+	return 0;
+}
+
+static struct platform_driver mv64x60_dma_err_driver = {
+	.probe = mv64x60_dma_err_probe,
+	.remove = mv64x60_dma_err_remove,
+	.driver = {
+		   .name = "mv64x60_dma_err",
+	}
+};
+
 static int __init mv64x60_edac_init(void)
 {
 	int ret = 0;
@@ -1380,12 +1543,18 @@ static int __init mv64x60_edac_init(void)
 		printk(KERN_WARNING EDAC_MOD_STR
 			"Ethernet err failed to register\n");
 
+	ret = platform_driver_register(&mv64x60_dma_err_driver);
+	if (ret)
+		printk(KERN_WARNING EDAC_MOD_STR
+			"DMA err failed to register\n");
+
 	return ret;
 }
 module_init(mv64x60_edac_init);
 
 static void __exit mv64x60_edac_exit(void)
 {
+	platform_driver_unregister(&mv64x60_dma_err_driver);
 	platform_driver_unregister(&mv64x60_eth_err_driver);
 	platform_driver_unregister(&mv64x60_comm_err_driver);
 	platform_driver_unregister(&mv64x60_device_err_driver);
diff --git a/drivers/edac/mv64x60_edac.h b/drivers/edac/mv64x60_edac.h
index 6de96df..5c89fc6 100644
--- a/drivers/edac/mv64x60_edac.h
+++ b/drivers/edac/mv64x60_edac.h
@@ -191,6 +191,38 @@ struct mv64x60_pci_pdata {
 /* only bits[8:0] of the EUIAER are accessible */
 #define MV64X60_ETH_INTERNAL_ADDR_ERR_MASK	0x000001ff
 
+/* DMA Interrupts Registers */
+#define MV64X60_DMA_INTR_CAUSE		0x00	/* 0x08c0 */
+#define MV64X60_DMA_INTR_MASK		0x04	/* 0x08c4 */
+#define MV64X60_DMA_INTR_ERR_ADDR	0x08	/* 0x08c8 */
+#define MV64X60_DMA_INTR_ERR_SELECT	0x0c	/* 0x08cc */
+
+#define MV64X60_DMA_INTR_MASK_Channel0_Comp		0x01
+#define MV64X60_DMA_INTR_MASK_Channel0_AddrMiss		0x02
+#define MV64X60_DMA_INTR_MASK_Channel0_AccProt		0x04
+#define MV64X60_DMA_INTR_MASK_Channel0_WrProt		0x08
+#define MV64X60_DMA_INTR_MASK_Channel0_Own		0x10
+						     /* 0x20, reserved */
+						     /* 0x40, reserved */
+						     /* 0x80, reserved */
+
+#define MV64X60_DMA_INTR_MASK_Channel0_VALUE	(MV64X60_DMA_INTR_MASK_Channel0_AddrMiss | \
+						MV64X60_DMA_INTR_MASK_Channel0_AccProt | \
+						MV64X60_DMA_INTR_MASK_Channel0_WrProt | \
+						MV64X60_DMA_INTR_MASK_Channel0_Own)
+
+#define MV64X60_DMA_INTR_MASK_Channel1_VALUE	(MV64X60_DMA_INTR_MASK_Channel0_VALUE << 8)
+#define MV64X60_DMA_INTR_MASK_Channel2_VALUE	(MV64X60_DMA_INTR_MASK_Channel1_VALUE << 8)
+#define MV64X60_DMA_INTR_MASK_Channel3_VALUE	(MV64X60_DMA_INTR_MASK_Channel2_VALUE << 8)
+
+#define MV64X60_DMA_INTR_MASK_VALUE	(MV64X60_DMA_INTR_MASK_Channel0_VALUE | \
+					MV64X60_DMA_INTR_MASK_Channel1_VALUE | \
+					MV64X60_DMA_INTR_MASK_Channel2_VALUE | \
+					MV64X60_DMA_INTR_MASK_Channel3_VALUE)
+
+/* bits[31:5] of DMA Interrupt Error Select Register are reserved */
+#define MV64X60_DMA_INTR_ERR_SELECT_MASK	0x0000001f
+
 struct mv64x60_mc_pdata {
 	void __iomem *mc_vbase;
 	int total_mem;
@@ -234,4 +266,11 @@ struct mv64x60_eth_pdata {
         int edac_idx;
 };
 
+struct mv64x60_dma_pdata {
+        void __iomem *dma_vbase;
+        const char *name;
+        int irq;
+        int edac_idx;
+};
+
 #endif
-- 
1.6.0.90.g436ed

