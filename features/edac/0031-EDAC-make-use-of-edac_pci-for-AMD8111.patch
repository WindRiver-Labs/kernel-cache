From 82b70ed14a99727320eba0dcf0ee8f12192f3324 Mon Sep 17 00:00:00 2001
From: Harry Ciao <qingtao.cao@windriver.com>
Date: Wed, 4 Feb 2009 16:02:39 +0800
Subject: [PATCH] EDAC: make use of edac_pci for AMD8111

Introduce a new data structure, amd8111_pci_info, as the private structure
for the PCI Controller on AMD8111 chipset, which is better represented by
edac_pci_ctl_info structure, rather than that of edac_device_ctl_info.
So that this PCI Controller could be grouped with other PCI-X Controllers
on AMD8131 chipset on Maple platform, and all their EDAC sysfs interfaces
would be under /sys/devices/system/edac/pci/ directory.

Also, original PCI device ID table and PCI driver have to be split into two
parts now, because they would have different set of probe/remove functions,
although they would behave very similarly. Separating general EDAC devices
from EDAC PCI controllers could achieve better scalability - it would be
easy to add or remove other EDAC devices.

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
---
 drivers/edac/amd8111_edac.c |  210 +++++++++++++++++++++++++++++++++----------
 drivers/edac/amd8111_edac.h |   11 +++
 2 files changed, 175 insertions(+), 46 deletions(-)

diff --git a/drivers/edac/amd8111_edac.c b/drivers/edac/amd8111_edac.c
index 4432810..246b646 100644
--- a/drivers/edac/amd8111_edac.c
+++ b/drivers/edac/amd8111_edac.c
@@ -41,9 +41,12 @@
 #define AMD8111_EDAC_REVISION	" Ver: 1.0.0 " __DATE__
 #define AMD8111_EDAC_MOD_STR	"amd8111_edac"
 
-enum amd8111_bridges {
+enum amd8111_edac_devs {
+	LPC_BRIDGE = 0,
+};
+
+enum amd8111_edac_pcis {
 	PCI_BRIDGE = 0,
-	LPC_BRIDGE,
 };
 
 #ifdef CONFIG_EDAC_VMC
@@ -100,15 +103,15 @@ static void uninit_vmc_sensors(void)
 #endif /* CONFIG_EDAC_VMC */
 
 /*
- * device-specific methods for amd8111 PCI Bridge device
+ * device-specific methods for amd8111 PCI Bridge Controller
  *
  * Error Reporting and Handling for amd8111 chipset could be found
  * in its datasheet 3.1.2 section, P37
  */
-static void amd8111_pci_bridge_init(struct amd8111_dev_info *dev_info)
+static void amd8111_pci_bridge_init(struct amd8111_pci_info *pci_info)
 {
 	u32 val32;
-	struct pci_dev *dev = dev_info->dev;
+	struct pci_dev *dev = pci_info->dev;
 
 	/* First clear error detection flags on the host interface */
 
@@ -212,10 +215,10 @@ static void amd8111_pci_bridge_init(struct amd8111_dev_info *dev_info)
 #endif
 }
 
-static void amd8111_pci_bridge_exit(struct amd8111_dev_info *dev_info)
+static void amd8111_pci_bridge_exit(struct amd8111_pci_info *pci_info)
 {
 	u32 val32;
-	struct pci_dev *dev = dev_info->dev;
+	struct pci_dev *dev = pci_info->dev;
 
 	if (edac_op_state == EDAC_OPSTATE_POLL) {
 		/* Disable System Error reporting */
@@ -270,10 +273,10 @@ static void amd8111_pci_bridge_exit(struct amd8111_dev_info *dev_info)
 #endif
 }
 
-static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
+static void amd8111_pci_bridge_check(struct edac_pci_ctl_info *edac_dev)
 {
-	struct amd8111_dev_info *dev_info = edac_dev->pvt_info;
-	struct pci_dev *dev = dev_info->dev;
+	struct amd8111_pci_info *pci_info = edac_dev->pvt_info;
+	struct pci_dev *dev = pci_info->dev;
 	u32 val32;
 
 	/* Check out PCI Bridge Status and Command Register */
@@ -283,7 +286,7 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 	}
 	if (val32 & PCI_STSCMD_CLEAR_MASK) {
 		printk(KERN_INFO "Error(s) in PCI bridge status and command"
-			"register on device %s\n", dev_info->ctl_name);
+			"register on device %s\n", pci_info->ctl_name);
 		printk(KERN_INFO "SSE: %d, RMA: %d, RTA: %d\n",
 			(val32 & PCI_STSCMD_SSE) != 0,
 			(val32 & PCI_STSCMD_RMA) != 0,
@@ -301,7 +304,7 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 			return;
 		}
 
-		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+		edac_pci_handle_npe(edac_dev, edac_dev->ctl_name);
 	}
 
 	/* Check out HyperTransport Link Control Register */
@@ -311,7 +314,7 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 	}
 	if (val32 & HT_LINK_LKFAIL) {
 		printk(KERN_INFO "Error(s) in hypertransport link control"
-			"register on device %s\n", dev_info->ctl_name);
+			"register on device %s\n", pci_info->ctl_name);
 		printk(KERN_INFO "LKFAIL: %d\n",
 			(val32 & HT_LINK_LKFAIL) != 0);
 
@@ -325,7 +328,7 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 			return;
 		}
 
-		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+		edac_pci_handle_npe(edac_dev, edac_dev->ctl_name);
 	}
 
 	/* Check out PCI Interrupt and Bridge Control Register */
@@ -335,7 +338,7 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 	}
 	if (val32 & PCI_INTBRG_CTRL_DTSTAT) {
 		printk(KERN_INFO "Error(s) in PCI interrupt and bridge control"
-			"register on device %s\n", dev_info->ctl_name);
+			"register on device %s\n", pci_info->ctl_name);
 		printk(KERN_INFO "DTSTAT: %d\n",
 			(val32 & PCI_INTBRG_CTRL_DTSTAT) != 0);
 #ifdef CONFIG_EDAC_VMC
@@ -348,7 +351,7 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 			return;
 		}
 
-		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+		edac_pci_handle_npe(edac_dev, edac_dev->ctl_name);
 	}
 
 	/* Check out PCI Bridge Memory Base-Limit Register */
@@ -358,7 +361,7 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 	}
 	if (val32 & MEM_LIMIT_CLEAR_MASK) {
 		printk(KERN_INFO "Error(s) in mem limit register on %s device\n",
-			dev_info->ctl_name);
+			pci_info->ctl_name);
 		printk(KERN_INFO "DPE: %d, RSE: %d, RMA: %d\n"
 			"RTA: %d, STA: %d, MDPE: %d\n",
 			(val32 & MEM_LIMIT_DPE)  != 0,
@@ -384,7 +387,7 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 			return;
 		}
 
-		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+		edac_pci_handle_npe(edac_dev, edac_dev->ctl_name);
 	}
 }
 
@@ -457,8 +460,10 @@ static void amd8111_lpc_bridge_init(struct amd8111_dev_info *dev_info)
 
 static void amd8111_lpc_bridge_exit(struct amd8111_dev_info *dev_info)
 {
+#ifdef CONFIG_MAPLE_NMI
 	u8 val8;
 	struct pci_dev *dev = dev_info->dev;
+#endif
 
 	if (port61_res)
 		release_region(PORT61, 1);
@@ -526,21 +531,27 @@ static void amd8111_lpc_bridge_check(struct edac_device_ctl_info *edac_dev)
 
 static int device_added;
 
+/* General devices represented by edac_device_ctl_info */
 static struct amd8111_dev_info amd8111_devices[] = {
-	[PCI_BRIDGE] = {
-		.err_dev = PCI_DEVICE_ID_AMD_8111_PCI,
-		.ctl_name = "AMD8111_PCI",
-		.init = amd8111_pci_bridge_init,
-		.exit = amd8111_pci_bridge_exit,
-		.check = amd8111_pci_bridge_check,
-		},
 	[LPC_BRIDGE] = {
 		.err_dev = PCI_DEVICE_ID_AMD_8111_LPC,
-		.ctl_name = "AMD8111_LPC",
+		.ctl_name = "lpc",
 		.init = amd8111_lpc_bridge_init,
 		.exit = amd8111_lpc_bridge_exit,
 		.check = amd8111_lpc_bridge_check,
-		},
+	},
+	{0},
+};
+
+/* PCI controllers represented by edac_pci_ctl_info */
+static struct amd8111_pci_info amd8111_pcis[] = {
+	[PCI_BRIDGE] = {
+		.err_dev = PCI_DEVICE_ID_AMD_8111_PCI,
+		.ctl_name = "AMD8111_PCI_Controller",
+		.init = amd8111_pci_bridge_init,
+		.exit = amd8111_pci_bridge_exit,
+		.check = amd8111_pci_bridge_check,
+	},
 	{0},
 };
 
@@ -552,10 +563,15 @@ static struct amd8111_dev_info amd8111_devices[] = {
 static void amd8111_handle_nmi(void)
 {
 	struct amd8111_dev_info *dev_info;
+	struct amd8111_pci_info *pci_info;
 
 	for (dev_info = amd8111_devices; dev_info->err_dev; dev_info++)
 		if (dev_info->check)
 			dev_info->check(dev_info->edac_dev);
+
+	for (pci_info = amd8111_pcis; pci_info->err_dev; pci_info++)
+		if (pci_info->check)
+			pci_info->check(pci_info->edac_dev);
 }
 
 /*
@@ -700,7 +716,7 @@ static int amd8111_NMI_global_enable(void)
 }
 #endif /* CONFIG_MAPLE_NMI */
 
-static int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
+static int amd8111_dev_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	struct amd8111_dev_info *dev_info = &amd8111_devices[id->driver_data];
 
@@ -758,7 +774,7 @@ static int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		dev_info->init(dev_info);
 
 	if (edac_device_add_device(dev_info->edac_dev) > 0) {
-		printk(KERN_ERR "failed edac_device_add_device() for %s\n",
+		printk(KERN_ERR "failed to add edac_dev for %s\n",
 			dev_info->ctl_name);
 		edac_device_free_ctl_info(dev_info->edac_dev);
 		return -ENODEV;
@@ -766,7 +782,7 @@ static int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
 
 	device_added++;
 
-	printk(KERN_INFO "added one device on AMD8111 "
+	printk(KERN_INFO "added one edac_dev on AMD8111 "
 		"vendor %x, device %x, name %s\n",
 		PCI_VENDOR_ID_AMD, dev_info->err_dev,
 		dev_info->ctl_name);
@@ -774,7 +790,7 @@ static int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	return 0;
 }
 
-static void amd8111_remove(struct pci_dev *dev)
+static void amd8111_dev_remove(struct pci_dev *dev)
 {
 	struct amd8111_dev_info *dev_info;
 
@@ -798,15 +814,90 @@ static void amd8111_remove(struct pci_dev *dev)
 	device_added--;
 }
 
-static const struct pci_device_id amd8111_edac_pci_tbl[] = {
-	{
-	PCI_VEND_DEV(AMD, 8111_PCI),
-	PCI_ANY_ID,		/* subvendor */
-	PCI_ANY_ID,		/* subdevice */
-	0,			/* class */
-	0,			/* class_mark */
-	PCI_BRIDGE,		/* driver private data */
-	},
+static int amd8111_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	struct amd8111_pci_info *pci_info = &amd8111_pcis[id->driver_data];
+
+	pci_info->dev = pci_get_device(PCI_VENDOR_ID_AMD, pci_info->err_dev, NULL);
+
+	if (!pci_info->dev) {
+		printk(KERN_ERR "EDAC device not found:"
+			"vendor %x, device %x, name %s\n",
+			PCI_VENDOR_ID_AMD, pci_info->err_dev,
+			pci_info->ctl_name);
+		return -ENODEV;
+	}
+
+	if (pci_enable_device(pci_info->dev)) {
+		pci_dev_put(pci_info->dev);
+		printk(KERN_ERR "failed to enable:"
+			"vendor %x, device %x, name %s\n",
+			PCI_VENDOR_ID_AMD, pci_info->err_dev,
+			pci_info->ctl_name);
+		return -ENODEV;
+	}
+
+	/*
+	 * we do not allocate extra private structure for
+	 * edac_pci_ctl_info, but make use of existing
+	 * one instead.
+	*/
+	pci_info->edac_idx = edac_pci_alloc_index();
+	pci_info->edac_dev = edac_pci_alloc_ctl_info(0, pci_info->ctl_name);
+	if (!pci_info->edac_dev)
+		return -ENOMEM;
+
+	pci_info->edac_dev->pvt_info = pci_info;
+	pci_info->edac_dev->dev = &pci_info->dev->dev;
+	pci_info->edac_dev->mod_name = AMD8111_EDAC_MOD_STR;
+	pci_info->edac_dev->ctl_name = pci_info->ctl_name;
+	pci_info->edac_dev->dev_name = pci_info->dev->dev.bus_id;
+
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		pci_info->edac_dev->edac_check = pci_info->check;
+
+	if (pci_info->init)
+		pci_info->init(pci_info);
+
+	if (edac_pci_add_device(pci_info->edac_dev, pci_info->edac_idx) > 0) {
+		printk(KERN_ERR "failed to add edac_pci for %s\n",
+			pci_info->ctl_name);
+		edac_pci_free_ctl_info(pci_info->edac_dev);
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "added one edac_pci on AMD8111 "
+		"vendor %x, device %x, name %s\n",
+		PCI_VENDOR_ID_AMD, pci_info->err_dev,
+		pci_info->ctl_name);
+
+	return 0;
+}
+
+static void amd8111_pci_remove(struct pci_dev *dev)
+{
+	struct amd8111_pci_info *pci_info;
+
+	for (pci_info = amd8111_pcis; pci_info->err_dev; pci_info++)
+		if (pci_info->dev->device == dev->device)
+			break;
+
+	if (!pci_info->err_dev)	/* should never happen */
+		return;
+
+	if (pci_info->edac_dev) {
+		edac_pci_del_device(pci_info->edac_dev->dev);
+		edac_pci_free_ctl_info(pci_info->edac_dev);
+	}
+
+	if (pci_info->exit)
+		pci_info->exit(pci_info);
+
+	pci_dev_put(pci_info->dev);
+}
+
+/* PCI Device ID talbe for general EDAC device */
+static const struct pci_device_id amd8111_edac_dev_tbl[] = {
 	{
 	PCI_VEND_DEV(AMD, 8111_LPC),
 	PCI_ANY_ID,		/* subvendor */
@@ -817,17 +908,40 @@ static const struct pci_device_id amd8111_edac_pci_tbl[] = {
 	},
 	{ 0,0,0,0,0,0,0 }	/* table is NULL-terminated */
 };
+MODULE_DEVICE_TABLE(pci, amd8111_edac_dev_tbl);
+
+static struct pci_driver amd8111_edac_dev_driver = {
+	.name = "AMD8111_EDAC_DEV",
+	.probe = amd8111_dev_probe,
+	.remove = amd8111_dev_remove,
+	.id_table = amd8111_edac_dev_tbl,
+};
+
+/* PCI Device ID table for EDAC PCI controller */
+static const struct pci_device_id amd8111_edac_pci_tbl[] = {
+        {
+        PCI_VEND_DEV(AMD, 8111_PCI),
+        PCI_ANY_ID,             /* subvendor */
+        PCI_ANY_ID,             /* subdevice */
+        0,                      /* class */
+        0,                      /* class_mark */
+        PCI_BRIDGE,             /* driver private data */
+        },
+        { 0,0,0,0,0,0,0 }       /* table is NULL-terminated */
+};
 MODULE_DEVICE_TABLE(pci, amd8111_edac_pci_tbl);
 
-static struct pci_driver amd8111_edac_driver = {
-	.name = AMD8111_EDAC_MOD_STR,
-	.probe = amd8111_probe,
-	.remove = amd8111_remove,
+static struct pci_driver amd8111_edac_pci_driver = {
+	.name = "AMD8111_EDAC_PCI",
+	.probe = amd8111_pci_probe,
+	.remove = amd8111_pci_remove,
 	.id_table = amd8111_edac_pci_tbl,
 };
 
 static int __init amd8111_edac_init(void)
 {
+	int val;
+
 	opstate_init();
 
 #ifdef CONFIG_EDAC_VMC
@@ -837,7 +951,10 @@ static int __init amd8111_edac_init(void)
 			"vMC sensors\n");
 #endif
 
-	return pci_register_driver(&amd8111_edac_driver);
+	val = pci_register_driver(&amd8111_edac_dev_driver);
+	val |= pci_register_driver(&amd8111_edac_pci_driver);
+
+	return val;
 }
 
 static void __exit amd8111_edac_exit(void)
@@ -847,7 +964,8 @@ static void __exit amd8111_edac_exit(void)
 	uninit_vmc_sensors();
 #endif
 
-	pci_unregister_driver(&amd8111_edac_driver);
+	pci_unregister_driver(&amd8111_edac_pci_driver);
+	pci_unregister_driver(&amd8111_edac_dev_driver);
 }
 
 
diff --git a/drivers/edac/amd8111_edac.h b/drivers/edac/amd8111_edac.h
index 5dfd3e0..bf2455b 100644
--- a/drivers/edac/amd8111_edac.h
+++ b/drivers/edac/amd8111_edac.h
@@ -152,5 +152,16 @@ struct amd8111_dev_info {
 	void (*check)(struct edac_device_ctl_info *edac_dev);
 };
 
+struct amd8111_pci_info {
+	u16 err_dev;	/* PCI Device ID */
+	struct pci_dev *dev;
+	int edac_idx;	/* pci index */
+	const char *ctl_name;
+	struct edac_pci_ctl_info *edac_dev;
+	void (*init)(struct amd8111_pci_info *dev_info);
+	void (*exit)(struct amd8111_pci_info *dev_info);
+	void (*check)(struct edac_pci_ctl_info *edac_dev);
+};
+
 #endif /* _AMD8111_EDAC_H_ */
 
-- 
1.6.0.3

