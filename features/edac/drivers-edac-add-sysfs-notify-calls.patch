From b3d38be0dbf4191ebfdb845c02d5767349c0adf0 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Mon, 18 Aug 2008 15:26:17 +0800
Subject: [PATCH] drivers edac add sysfs notify calls

Add sysfs notify calls for counters.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
---
 drivers/edac/edac_device.c       |    6 ++++++
 drivers/edac/edac_device_sysfs.c |   14 ++++++++++++++
 drivers/edac/edac_mc.c           |   12 ++++++++++++
 drivers/edac/edac_mc_sysfs.c     |   27 +++++++++++++++++++++++++++
 drivers/edac/edac_module.h       |    8 ++++++++
 5 files changed, 67 insertions(+), 0 deletions(-)

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 5fcd3d8..eef466e 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -659,6 +659,9 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 	instance->counters.ce_count++;
 	edac_dev->counters.ce_count++;
 
+	/* perform sysfs notify */
+	edac_device_sysfs_notify_ce_count(edac_dev);
+
 	if (edac_device_get_log_ce(edac_dev))
 		edac_device_printk(edac_dev, KERN_WARNING,
 				"CE: %s instance: %s block: %s '%s'\n",
@@ -705,6 +708,9 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 	instance->counters.ue_count++;
 	edac_dev->counters.ue_count++;
 
+	/* perform sysfs notify */
+	edac_device_sysfs_notify_ue_count(edac_dev);
+
 	if (edac_device_get_log_ue(edac_dev))
 		edac_device_printk(edac_dev, KERN_EMERG,
 				"UE: %s instance: %s block: %s '%s'\n",
diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 5376457..62c982c 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -400,6 +400,20 @@ static struct instance_attribute *device_instance_attr[] = {
 	NULL,
 };
 
+/* sysfs notify call for the ce_count and ue_count */
+void edac_device_sysfs_notify_ce_count(struct edac_device_ctl_info *edac_dev)
+{
+        sysfs_notify(&edac_dev->kobj, NULL,
+                        (char *) attr_instance_ce_count.attr.name);
+}
+
+void edac_device_sysfs_notify_ue_count(struct edac_device_ctl_info *edac_dev)
+{
+        sysfs_notify(&edac_dev->kobj, NULL,
+                        (char *) attr_instance_ue_count.attr.name);
+}
+
+
 /* The 'ktype' for each edac_dev 'instance' */
 static struct kobj_type ktype_instance_ctrl = {
 	.release = edac_device_ctrl_instance_release,
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index d110392..1c4c5e5 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -684,6 +684,9 @@ void edac_mc_handle_ce(struct mem_ctl_info *mci,
 	mci->csrows[row].ce_count++;
 	mci->csrows[row].channels[channel].ce_count++;
 
+	/* perform poll notify operation */
+	edac_mc_sysfs_notify_ce_count(mci);
+
 	if (mci->scrub_mode & SCRUB_SW_SRC) {
 		/*
 		 * Some MC's can remap memory so that it is still available
@@ -712,6 +715,9 @@ void edac_mc_handle_ce_no_info(struct mem_ctl_info *mci, const char *msg)
 
 	mci->ce_noinfo_count++;
 	mci->ce_count++;
+
+	/* perform poll notify operation */
+	edac_mc_sysfs_notify_ce_noinfo_count(mci);
 }
 EXPORT_SYMBOL_GPL(edac_mc_handle_ce_no_info);
 
@@ -765,6 +771,9 @@ void edac_mc_handle_ue(struct mem_ctl_info *mci,
 
 	mci->ue_count++;
 	mci->csrows[row].ue_count++;
+
+	/* perform poll notify operation */
+	edac_mc_sysfs_notify_ue_count(mci);
 }
 EXPORT_SYMBOL_GPL(edac_mc_handle_ue);
 
@@ -778,6 +787,9 @@ void edac_mc_handle_ue_no_info(struct mem_ctl_info *mci, const char *msg)
 			"UE - no information available: %s\n", msg);
 	mci->ue_noinfo_count++;
 	mci->ue_count++;
+
+	/* perform poll notify operation */
+	edac_mc_sysfs_notify_ue_noinfo_count(mci);
 }
 EXPORT_SYMBOL_GPL(edac_mc_handle_ue_no_info);
 
diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c
index ad218fe..06f5e20 100644
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@ -614,6 +614,33 @@ static struct mcidev_sysfs_attribute *mci_attr[] = {
 	NULL
 };
 
+/*
+ * function for the edac_mc code to call, which in turn will
+ * perform a sysfs_notify call for the respective counter
+ */
+void edac_mc_sysfs_notify_ce_count(struct mem_ctl_info *mci)
+{
+	sysfs_notify(&mci->edac_mci_kobj, NULL,
+			(char *) mci_attr_ce_count.attr.name);
+}
+
+void edac_mc_sysfs_notify_ue_count(struct mem_ctl_info *mci)
+{
+	sysfs_notify(&mci->edac_mci_kobj, NULL,
+			(char *) mci_attr_ue_count.attr.name);
+}
+
+void edac_mc_sysfs_notify_ce_noinfo_count(struct mem_ctl_info *mci)
+{
+	sysfs_notify(&mci->edac_mci_kobj, NULL,
+			(char *) mci_attr_ce_noinfo_count.attr.name);
+}
+
+void edac_mc_sysfs_notify_ue_noinfo_count(struct mem_ctl_info *mci)
+{
+	sysfs_notify(&mci->edac_mci_kobj, NULL,
+			(char *) mci_attr_ue_noinfo_count.attr.name);
+}
 
 /*
  * Release of a MC controlling instance
diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 233d479..b8386df 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -27,6 +27,10 @@ extern int edac_mc_register_sysfs_main_kobj(struct mem_ctl_info *mci);
 extern void edac_mc_unregister_sysfs_main_kobj(struct mem_ctl_info *mci);
 extern int edac_create_sysfs_mci_device(struct mem_ctl_info *mci);
 extern void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci);
+extern void edac_mc_sysfs_notify_ce_count(struct mem_ctl_info *mci);
+extern void edac_mc_sysfs_notify_ue_count(struct mem_ctl_info *mci);
+extern void edac_mc_sysfs_notify_ce_noinfo_count(struct mem_ctl_info *mci);
+extern void edac_mc_sysfs_notify_ue_noinfo_count(struct mem_ctl_info *mci);
 extern int edac_get_log_ue(void);
 extern int edac_get_log_ce(void);
 extern int edac_get_panic_on_ue(void);
@@ -42,6 +46,10 @@ extern void edac_device_unregister_sysfs_main_kobj(
 				struct edac_device_ctl_info *edac_dev);
 extern int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev);
+extern void edac_device_sysfs_notify_ce_count(
+				struct edac_device_ctl_info *edac_dev);
+extern void edac_device_sysfs_notify_ue_count(
+				struct edac_device_ctl_info *edac_dev);
 extern struct sysdev_class *edac_get_edac_class(void);
 
 /* edac core workqueue: single CPU mode */
-- 
1.5.5.1

