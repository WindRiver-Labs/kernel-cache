From 7d654950c922c79cf37b98f1d5402e79eef9b5b6 Mon Sep 17 00:00:00 2001
From: qingtao.cao@windriver.com <qingtao.cao@windriver.com>
Date: Tue, 4 Nov 2008 19:39:18 +0800
Subject: [PATCH] EDAC: add HI_FERR for 3 Hub Interface to e7xxx driver

Supply e7xxx EDAC driver with three more PCI Configuration Registers of
HIB_FERR, HIC_FERR and HID_FERR for Hub Interfaces of D2F1, D3F1, D4F1
respectively. These registers could be checked by polling or via NMI handler,
and user could get each of their error counters via sysfs.
---
 drivers/edac/e7xxx_edac.c |  124 +++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 124 insertions(+), 0 deletions(-)

diff --git a/drivers/edac/e7xxx_edac.c b/drivers/edac/e7xxx_edac.c
index d7f1478..53e04a8 100644
--- a/drivers/edac/e7xxx_edac.c
+++ b/drivers/edac/e7xxx_edac.c
@@ -75,6 +75,9 @@
 
 /* E7501 Device ID */
 #define PCI_DEVICE_ID_INTEL_E7501_HIA			0x2541
+#define PCI_DEVICE_ID_INTEL_E7501_HIB_ERROR_REPORT	0x2544
+#define PCI_DEVICE_ID_INTEL_E7501_HIC_ERROR_REPORT	0x2546
+#define PCI_DEVICE_ID_INTEL_E7501_HID_ERROR_REPORT	0x2548
 
 /*************************************************************
  *        South Bridge Registers HI_A (Device 0, Function 1) *       
@@ -122,6 +125,36 @@
 
 #define E7501_SYSBUS_SERRCMD_MASK	E7501_SYSBUS_FERR_MASK
 
+/*************************************************************
+ *	E7501 PCI Bridges Registers 			     *
+ *	  HI_B ERROR REPORTING (Device 2, Function 1) 	     *       
+ *        HI_C ERROR REPORTING (Device 3, Function 1) 	     *       
+ *        HI_D ERROR REPORTING (Device 4, Function 1) 	     *       
+ *************************************************************/
+#define E7501_HI_ERROR_REPORT_PCICMD		0x04
+#define E7501_HI_ERROR_REPORT_FERR		0x80
+#define E7501_HI_ERROR_REPORT_NERR		0x82
+#define E7501_HI_ERROR_REPORT_SERRCMD		0xA0
+
+/*************************************************************
+ *	E7501 Hub Interface SERRCMD Definitions	     	     *
+ *************************************************************/
+#define E7501_HI_SERRCMD_MasterAbort	(1 << 5)
+#define E7501_HI_SERRCMD_TargetAbort	(1 << 4)
+#define E7501_HI_SERRCMD_CEHeaderAddr	(1 << 3)
+#define E7501_HI_SERRCMD_CEDataTrans	(1 << 2)
+#define E7501_HI_SERRCMD_UEHeaderAddr	(1 << 1)
+#define E7501_HI_SERRCMD_UEDataTrans	(1)
+#define E7501_HI_SERRCMD_MASK	(E7501_HI_SERRCMD_MasterAbort | \
+				E7501_HI_SERRCMD_TargetAbort | \
+				E7501_HI_SERRCMD_CEHeaderAddr | \
+				E7501_HI_SERRCMD_CEDataTrans | \
+				E7501_HI_SERRCMD_UEHeaderAddr | \
+				E7501_HI_SERRCMD_UEDataTrans)
+
+/* bit6 is a global flag if MCH received any SERR from HI */
+#define E7501_HI_FERR_MASK (E7501_HI_SERRCMD_MASK | (1 << 6))
+
 #define E7XXX_NR_CSROWS		8	/* number of csrows */
 #define E7XXX_NR_DIMMS		8	/* FIXME - is this correct? */
 
@@ -246,6 +279,76 @@ static struct e7xxx_dev_info e7205_devs[] = {
         {0},	/* Terminated by NULL */
 };
 
+static void e7501_hiX_err_init(struct e7xxx_dev_info *dev_info)
+{
+	u16 word;
+	u8 byte;
+
+	/* clear HI_FERR and HI_NERR */
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, &byte);
+	pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, byte);
+
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, &byte);
+	pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, byte);
+
+	/* only enable SERR in INT mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		return;
+
+	pci_read_config_word(dev_info->dev, E7501_HI_ERROR_REPORT_PCICMD, &word);
+	word |=  1 << 8; /* SERR global enable */
+	pci_write_config_word(dev_info->dev, E7501_HI_ERROR_REPORT_PCICMD, word);
+
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_SERRCMD, &byte);
+	byte |= E7501_HI_SERRCMD_MASK;
+	pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_SERRCMD, byte);
+}
+
+static void e7501_hiX_err_exit(struct e7xxx_dev_info *dev_info)
+{
+	u16 word;
+	u8 byte;
+
+	/* only need to clear SERR in "INT" mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		return;
+
+	pci_read_config_word(dev_info->dev, E7501_HI_ERROR_REPORT_PCICMD, &word);
+	if (word & (1 << 8)) { /* clear SERR */
+		word &= ~(1 << 8);
+		pci_write_config_word(dev_info->dev, 
+				      E7501_HI_ERROR_REPORT_PCICMD, word);
+	}
+
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_SERRCMD, &byte);
+	if (byte & E7501_HI_SERRCMD_MASK) {
+		byte &= ~E7501_HI_SERRCMD_MASK;
+		pci_write_config_byte(dev_info->dev, 
+				      E7501_HI_ERROR_REPORT_SERRCMD, byte);
+	}
+}
+
+static void e7501_hiX_err_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct e7xxx_dev_info *dev_info = edac_dev->pvt_info;
+	u8 ferr = 0, nerr = 0;
+
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, &ferr);
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, &nerr);
+	ferr &= E7501_HI_FERR_MASK;
+	nerr &= E7501_HI_FERR_MASK;
+	if (!ferr && !nerr ) 
+		return;
+
+	/* only reset the bits we are interested in */
+	if (ferr)
+		pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, ferr);
+	if (nerr)
+		pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, nerr);
+
+	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+}
+
 static struct e7xxx_dev_info e7501_devs[] = {
 	/* The first element must be the memory controller device */
 	{
@@ -253,6 +356,27 @@ static struct e7xxx_dev_info e7501_devs[] = {
 		.ctl_name = "E7501 Host RASUM Controller"
 	},
 	/* All the rest devices on e7501 chipset should go here */
+	{
+		.err_dev = PCI_DEVICE_ID_INTEL_E7501_HIB_ERROR_REPORT,
+		.ctl_name = "hib",
+		.init = e7501_hiX_err_init,
+		.exit = e7501_hiX_err_exit,
+		.check = e7501_hiX_err_check,
+	},
+	{
+		.err_dev = PCI_DEVICE_ID_INTEL_E7501_HIC_ERROR_REPORT,
+		.ctl_name = "hic",
+		.init = e7501_hiX_err_init,
+		.exit = e7501_hiX_err_exit,
+		.check = e7501_hiX_err_check,
+	},      
+	{
+		.err_dev = PCI_DEVICE_ID_INTEL_E7501_HID_ERROR_REPORT,
+		.ctl_name = "hid",
+		.init = e7501_hiX_err_init,
+		.exit = e7501_hiX_err_exit,
+		.check = e7501_hiX_err_check,
+	}, 
 	{0},	/* Terminated by NULL */
 };
 
-- 
1.6.0.90.g436ed

