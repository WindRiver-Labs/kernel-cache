From 55d715dee7498636aa2f3c67b7a9fdf23276ce6a Mon Sep 17 00:00:00 2001
From: qingtao.cao@windriver.com <qingtao.cao@windriver.com>
Date: Tue, 4 Nov 2008 19:39:16 +0800
Subject: [PATCH] EDAC: framework to add other devices to e7xxx driver

Implement a framework to facilitate adding extra new devices to EDAC.
With the help of it, only device-specific initialization and checking
routines and interrupt handler are needed, plus one data structure to
glue them together.
---
 arch/x86/kernel/traps_32.c |   27 +++++
 drivers/edac/e7xxx_edac.c  |  227 ++++++++++++++++++++++++++++++++++++++++----
 2 files changed, 234 insertions(+), 20 deletions(-)

diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index 28c413d..cb58dde 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -747,6 +747,14 @@ io_check_error(unsigned char reason, struct pt_regs *regs)
 	outb(reason, 0x61);
 }
 
+#ifdef CONFIG_EDAC
+void (*edac_handle_nmi)(void) = NULL;
+EXPORT_SYMBOL(edac_handle_nmi);
+
+DEFINE_SPINLOCK(edac_nmi_lock);
+EXPORT_SYMBOL(edac_nmi_lock);
+#endif
+
 static notrace __kprobes void
 unknown_nmi_error(unsigned char reason, struct pt_regs *regs)
 {
@@ -762,6 +770,25 @@ unknown_nmi_error(unsigned char reason, struct pt_regs *regs)
 		return;
 	}
 #endif
+
+#ifdef CONFIG_EDAC
+	if (edac_handler_set()) {
+		/*
+ 		 * this NMI instance might have preempted EDAC module's 
+ 		 * init or exit routine when setting up edac_handle_nmi 
+ 		 * on the same cpu, and we can't block here.
+ 		 */ 
+		if (spin_trylock(&edac_nmi_lock)) {
+			if (edac_handle_nmi) {
+				edac_handle_nmi();
+				spin_unlock(&edac_nmi_lock);
+				return;
+			}
+			spin_unlock(&edac_nmi_lock);
+		}
+	}
+#endif
+
 	printk(KERN_EMERG
 		"Uhhuh. NMI received for unknown reason %02x on CPU %d.\n",
 			reason, smp_processor_id());
diff --git a/drivers/edac/e7xxx_edac.c b/drivers/edac/e7xxx_edac.c
index c7d11cc..929f0fd 100644
--- a/drivers/edac/e7xxx_edac.c
+++ b/drivers/edac/e7xxx_edac.c
@@ -18,6 +18,11 @@
  *	That One Guy (Some other place)
  *	Wang Zhenyu (intel.com)
  *
+ * Additions for the HIA_FERR, SYSBUS_FERR for E7501 D0F1 device,
+ * HIB, HIC, HID for E7501 D2F1, D3F1, D4F1 devices respectively.
+ * added by Cao Qingtao <qingtao.cao@windriver.com>,
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
  * $Id: edac_e7xxx.c,v 1.5.2.9 2005/10/05 00:43:44 dsp_llnl Exp $
  *
  */
@@ -28,6 +33,7 @@
 #include <linux/pci_ids.h>
 #include <linux/slab.h>
 #include <linux/edac.h>
+#include <linux/spinlock.h>
 #include "edac_core.h"
 
 #define	E7XXX_REVISION " Ver: 2.0.2 " __DATE__
@@ -59,10 +65,6 @@
 #define PCI_DEVICE_ID_INTEL_7501_0	0x254c
 #endif				/* PCI_DEVICE_ID_INTEL_7501_0 */
 
-#ifndef PCI_DEVICE_ID_INTEL_7501_1_ERR
-#define PCI_DEVICE_ID_INTEL_7501_1_ERR	0x2541
-#endif				/* PCI_DEVICE_ID_INTEL_7501_1_ERR */
-
 #ifndef PCI_DEVICE_ID_INTEL_7505_0
 #define PCI_DEVICE_ID_INTEL_7505_0	0x2550
 #endif				/* PCI_DEVICE_ID_INTEL_7505_0 */
@@ -71,6 +73,9 @@
 #define PCI_DEVICE_ID_INTEL_7505_1_ERR	0x2551
 #endif				/* PCI_DEVICE_ID_INTEL_7505_1_ERR */
 
+/* E7501 Device ID */
+#define PCI_DEVICE_ID_INTEL_E7501_HIA			0x2541
+
 #define E7XXX_NR_CSROWS		8	/* number of csrows */
 #define E7XXX_NR_DIMMS		8	/* FIXME - is this correct? */
 
@@ -123,6 +128,7 @@ enum e7xxx_chips {
 	E7205,
 };
 
+/* attributes for Intel MCH D0F0 itself */
 struct e7xxx_pvt {
 	struct pci_dev *bridge_ck;
 	u32 tolm;
@@ -131,11 +137,23 @@ struct e7xxx_pvt {
 	const struct e7xxx_dev_info *dev_info;
 };
 
+/* 
+ * attributes for a common device,
+ * this private structure would be connected to relevant
+ * edac_device_ctl_info by its pvt_info pointer.
+ */
 struct e7xxx_dev_info {
-	u16 err_dev;
+	u16 err_dev; /* PCI Device ID */
 	const char *ctl_name;
+	int edac_idx; /* device index */
+	struct pci_dev *dev;
+	struct edac_device_ctl_info *edac_dev;
+	void (*init)(struct e7xxx_dev_info *dev_info);
+	void (*exit)(struct e7xxx_dev_info *dev_info);
+	void (*check)(struct edac_device_ctl_info *edac_dev);
 };
 
+/* attributes for Intel MCH D0F1 device */
 struct e7xxx_error_info {
 	u8 dram_ferr;
 	u8 dram_nerr;
@@ -145,20 +163,55 @@ struct e7xxx_error_info {
 };
 
 static struct edac_pci_ctl_info *e7xxx_pci;
+static struct e7xxx_dev_info *e7xxx_device;
+static int edac_dev_idx = 0;
+
+static struct e7xxx_dev_info e7500_devs[] = {
+	/* The first element must be the memory controller device */
+	{
+                .err_dev = PCI_DEVICE_ID_INTEL_7500_1_ERR,
+                .ctl_name = "E7500"
+	},
+	/* All the rest devices on e7500 chipset should go here */
+	{0},	/* Terminated by NULL */
+};
+
+static struct e7xxx_dev_info e7505_devs[] = {
+	/* The first element must be the memory controller device */
+        {
+                .err_dev = PCI_DEVICE_ID_INTEL_7505_1_ERR,
+                .ctl_name = "E7505"
+        },
+	/* All the rest devices on e7505 chipset should go here */
+        {0},	/* Terminated by NULL */
+};
 
-static const struct e7xxx_dev_info e7xxx_devs[] = {
-	[E7500] = {
-		.err_dev = PCI_DEVICE_ID_INTEL_7500_1_ERR,
-		.ctl_name = "E7500"},
-	[E7501] = {
-		.err_dev = PCI_DEVICE_ID_INTEL_7501_1_ERR,
-		.ctl_name = "E7501"},
-	[E7505] = {
-		.err_dev = PCI_DEVICE_ID_INTEL_7505_1_ERR,
-		.ctl_name = "E7505"},
-	[E7205] = {
-		.err_dev = PCI_DEVICE_ID_INTEL_7205_1_ERR,
-		.ctl_name = "E7205"},
+static struct e7xxx_dev_info e7205_devs[] = {
+	/* The first element must be the memory controller device */
+        {
+                .err_dev = PCI_DEVICE_ID_INTEL_7205_1_ERR,
+                .ctl_name = "E7205"
+        },
+	/* All the rest devices on e7205 chipset should go here */
+        {0},	/* Terminated by NULL */
+};
+
+static struct e7xxx_dev_info e7501_devs[] = {
+	/* The first element must be the memory controller device */
+	{
+		.err_dev = PCI_DEVICE_ID_INTEL_E7501_HIA,
+		.ctl_name = "E7501 Host RASUM Controller"
+	},
+	/* All the rest devices on e7501 chipset should go here */
+	{0},	/* Terminated by NULL */
+};
+
+/* all edac devices on a e7xxx chipset */
+static const struct e7xxx_dev_info *e7xxx_devs[] = {
+        [E7500] = e7500_devs,
+        [E7501] = e7501_devs,
+        [E7505] = e7505_devs,
+        [E7205] = e7205_devs,
 };
 
 /* FIXME - is this valid for both SECDED and S4ECD4ED? */
@@ -403,6 +456,104 @@ static void e7xxx_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,
 	}
 }
 
+extern void (*edac_handle_nmi)(void);
+extern spinlock_t edac_nmi_lock;
+static void e7xxx_handle_nmi(void);
+
+static void e7xxx_add_edac_devices(void)
+{
+	struct e7xxx_dev_info *dev_info;
+	int device_added = 0;	
+
+	/* 
+ 	 * Start at 1 to skip the memory controller device
+ 	 * e7xxx_device has been setup pointing to the array of 
+ 	 * e7xxx_dev_info structure for the current e7xxx chipset
+ 	 * in e7xxx_probe1().
+ 	 */
+	for (dev_info = &e7xxx_device[1]; dev_info->err_dev; dev_info++) {
+		/* sanity check */
+		if (!dev_info->check)
+			continue;
+
+		dev_info->dev = pci_get_device(PCI_VENDOR_ID_INTEL, 
+					       dev_info->err_dev, NULL); 
+		if (!dev_info->dev) {
+			e7xxx_printk(KERN_INFO, "error reporting device not found:"
+				"vendor %x device 0x%x name %s\n",
+				PCI_VENDOR_ID_INTEL, dev_info->err_dev, 
+				dev_info->ctl_name);
+			continue;
+		}
+
+		if (pci_enable_device(dev_info->dev)) {
+			pci_dev_put(dev_info->dev);
+			e7xxx_printk(KERN_ERR, "failed to enable:"
+				"vendor %x device 0x%x name %s\n",
+	                 	PCI_VENDOR_ID_INTEL, dev_info->err_dev, 
+				dev_info->ctl_name);
+			continue;
+		}
+
+		/*
+ 		 * we do not allocate extra private structure for 
+ 		 * edac_device_ctl_info, but make use of existing 
+ 		 * e7xxx_device instead. 
+ 		 */
+		dev_info->edac_dev = 
+		edac_device_alloc_ctl_info(0, dev_info->ctl_name, 1,
+	    				   NULL, 0, 0, 
+					   NULL, 0, edac_dev_idx);
+		if (!dev_info->edac_dev)
+			break;	/* pointless to continue when -ENOMEM */
+
+		dev_info->edac_dev->pvt_info = dev_info;
+		dev_info->edac_dev->dev = &dev_info->dev->dev;
+		dev_info->edac_dev->mod_name = EDAC_MOD_STR;
+		dev_info->edac_dev->ctl_name = dev_info->ctl_name;
+		dev_info->edac_dev->dev_name = dev_info->dev->dev.bus_id;
+
+		if (edac_op_state == EDAC_OPSTATE_POLL)
+			dev_info->edac_dev->edac_check = dev_info->check;
+		else if ((edac_op_state == EDAC_OPSTATE_INT) && (!device_added)) {
+			unsigned long flags;
+			spin_lock_irqsave(&edac_nmi_lock, flags);
+			edac_handle_nmi = e7xxx_handle_nmi;
+			spin_unlock_irqrestore(&edac_nmi_lock, flags);
+		}
+					
+		if (dev_info->init)
+			dev_info->init(dev_info);
+
+		if (edac_device_add_device(dev_info->edac_dev) > 0) {
+			debugf0("%s(): failed edac_device_add_device()"
+				"for %s\n", __func__, dev_info->ctl_name);
+			edac_device_free_ctl_info(dev_info->edac_dev);
+			continue;
+		}
+
+		dev_info->edac_idx = edac_dev_idx++;
+		device_added++;
+	}
+
+	debugf0("%s(): added %d devices on E7501\n", __func__, device_added);
+}
+
+/*
+ * e7xxx NMI handler
+ *
+ * traverse all devices of a e7xxx chipset to claim current NMI instance.
+ */
+static void e7xxx_handle_nmi(void)
+{
+	struct e7xxx_dev_info *dev_info;
+
+	/* start at 1 to skip memory controller device */
+	for (dev_info = &e7xxx_device[1]; dev_info->err_dev; dev_info++)
+		if (dev_info->check)
+			dev_info->check(dev_info->edac_dev);		
+}
+
 static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 {
 	u16 pci_data;
@@ -432,14 +583,19 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 	mci->dev = &pdev->dev;
 	debugf3("%s(): init pvt\n", __func__);
 	pvt = (struct e7xxx_pvt *)mci->pvt_info;
-	pvt->dev_info = &e7xxx_devs[dev_idx];
+	e7xxx_device = (struct e7xxx_dev_info *)e7xxx_devs[dev_idx];
+	/* 
+ 	 * memory controller device is the first element 
+ 	 * in the e7xxx_device array.
+ 	 */
+	pvt->dev_info = (struct e7xxx_dev_info *)(e7xxx_device + 0);
 	pvt->bridge_ck = pci_get_device(PCI_VENDOR_ID_INTEL,
 					pvt->dev_info->err_dev, pvt->bridge_ck);
 
 	if (!pvt->bridge_ck) {
 		e7xxx_printk(KERN_ERR, "error reporting device not found:"
 			"vendor %x device 0x%x (broken BIOS?)\n",
-			PCI_VENDOR_ID_INTEL, e7xxx_devs[dev_idx].err_dev);
+			PCI_VENDOR_ID_INTEL, pvt->dev_info->err_dev);
 		goto fail0;
 	}
 
@@ -484,6 +640,9 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 			__func__);
 	}
 
+	/* adding all the rest devices on a e7xxx chipset */
+	e7xxx_add_edac_devices();
+
 	/* get this far and it's successful */
 	debugf3("%s(): success\n", __func__);
 	return 0;
@@ -508,6 +667,31 @@ static int __devinit e7xxx_init_one(struct pci_dev *pdev,
 		-EIO : e7xxx_probe1(pdev, ent->driver_data);
 }
 
+static void __devexit e7xxx_del_edac_devices(void)
+{
+	struct e7xxx_dev_info *dev_info;
+	unsigned long flags;
+
+	/* start at 1 to skip memory controller device  */
+	for (dev_info = &e7xxx_device[1]; dev_info->err_dev; dev_info++) {
+		if (dev_info->edac_dev) {
+			edac_device_del_device(dev_info->edac_dev->dev);
+			edac_device_free_ctl_info(dev_info->edac_dev);
+		}
+
+		if (dev_info->dev) {
+			if (dev_info->exit)
+				dev_info->exit(dev_info);
+			pci_dev_put(dev_info->dev);
+		}
+
+		spin_lock_irqsave(&edac_nmi_lock, flags);
+		if ((edac_handle_nmi) && (edac_op_state == EDAC_OPSTATE_INT))
+			edac_handle_nmi = NULL;
+		spin_unlock_irqrestore(&edac_nmi_lock, flags);
+	}
+}
+
 static void __devexit e7xxx_remove_one(struct pci_dev *pdev)
 {
 	struct mem_ctl_info *mci;
@@ -524,6 +708,9 @@ static void __devexit e7xxx_remove_one(struct pci_dev *pdev)
 	pvt = (struct e7xxx_pvt *)mci->pvt_info;
 	pci_dev_put(pvt->bridge_ck);
 	edac_mc_free(mci);
+
+	if (e7xxx_device)
+		e7xxx_del_edac_devices();
 }
 
 static const struct pci_device_id e7xxx_pci_tbl[] __devinitdata = {
-- 
1.6.0.90.g436ed

