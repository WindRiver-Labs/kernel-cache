From df02fb6319c43d8f2d2c8ad7dc8906b48a9ab46d Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Wed, 28 Apr 2010 02:49:09 -0700
Subject: [PATCH 1/4] EDAC: Add sysfs notify calls for counters

sysfs_notify is called to send out an event when an error occurs
and the error counter is increased.

Signed-off-by: Jason HU <yongqi.hu@windriver.com>
---
 drivers/edac/edac_device.c       |    6 ++++++
 drivers/edac/edac_device_sysfs.c |   14 ++++++++++++++
 drivers/edac/edac_mc.c           |    9 +++++++++
 drivers/edac/edac_mc_sysfs.c     |   27 +++++++++++++++++++++++++++
 drivers/edac/edac_module.h       |    8 ++++++++
 5 files changed, 64 insertions(+), 0 deletions(-)

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index d5e13c9..395f640 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -676,6 +676,9 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 	instance->counters.ce_count++;
 	edac_dev->counters.ce_count++;
 
+	/* perform sysfs notify */
+	edac_device_sysfs_notify_ce_count(edac_dev);
+
 	if (edac_device_get_log_ce(edac_dev))
 		edac_device_printk(edac_dev, KERN_WARNING,
 				"CE: %s instance: %s block: %s '%s'\n",
@@ -722,6 +725,9 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 	instance->counters.ue_count++;
 	edac_dev->counters.ue_count++;
 
+	/* perform sysfs notify */
+	edac_device_sysfs_notify_ue_count(edac_dev);
+
 	if (edac_device_get_log_ue(edac_dev))
 		edac_device_printk(edac_dev, KERN_EMERG,
 				"UE: %s instance: %s block: %s '%s'\n",
diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 0709681..b259ea2 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -401,6 +401,20 @@ static struct instance_attribute *device_instance_attr[] = {
 	NULL,
 };
 
+/* sysfs notify call for the ce_count and ue_count */
+void edac_device_sysfs_notify_ce_count(struct edac_device_ctl_info *edac_dev)
+{
+        sysfs_notify(&edac_dev->kobj, NULL,
+                        (char *) attr_instance_ce_count.attr.name);
+}
+
+void edac_device_sysfs_notify_ue_count(struct edac_device_ctl_info *edac_dev)
+{
+        sysfs_notify(&edac_dev->kobj, NULL,
+                        (char *) attr_instance_ue_count.attr.name);
+}
+
+
 /* The 'ktype' for each edac_dev 'instance' */
 static struct kobj_type ktype_instance_ctrl = {
 	.release = edac_device_ctrl_instance_release,
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index 3630308..227502b 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -706,6 +706,9 @@ void edac_mc_handle_ce(struct mem_ctl_info *mci,
 	mci->csrows[row].ce_count++;
 	mci->csrows[row].channels[channel].ce_count++;
 
+	/* perform poll notify operation */
+	edac_mc_sysfs_notify_ce_count(mci);
+
 	if (mci->scrub_mode & SCRUB_SW_SRC) {
 		/*
 		 * Some MC's can remap memory so that it is still available
@@ -787,6 +790,9 @@ void edac_mc_handle_ue(struct mem_ctl_info *mci,
 
 	mci->ue_count++;
 	mci->csrows[row].ue_count++;
+
+	/* perform poll notify operation */
+	edac_mc_sysfs_notify_ue_count(mci);
 }
 EXPORT_SYMBOL_GPL(edac_mc_handle_ue);
 
@@ -800,6 +806,9 @@ void edac_mc_handle_ue_no_info(struct mem_ctl_info *mci, const char *msg)
 			"UE - no information available: %s\n", msg);
 	mci->ue_noinfo_count++;
 	mci->ue_count++;
+
+	/* perform poll notify operation */
+	edac_mc_sysfs_notify_ue_noinfo_count(mci);
 }
 EXPORT_SYMBOL_GPL(edac_mc_handle_ue_no_info);
 
diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c
index 1d358ae..aadd817 100644
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@ -617,6 +617,33 @@ static struct mcidev_sysfs_attribute *mci_attr[] = {
 	NULL
 };
 
+/*
+ * function for the edac_mc code to call, which in turn will
+ * perform a sysfs_notify call for the respective counter
+ */
+void edac_mc_sysfs_notify_ce_count(struct mem_ctl_info *mci)
+{
+	sysfs_notify(&mci->edac_mci_kobj, NULL,
+			(char *) mci_attr_ce_count.attr.name);
+}
+
+void edac_mc_sysfs_notify_ue_count(struct mem_ctl_info *mci)
+{
+	sysfs_notify(&mci->edac_mci_kobj, NULL,
+			(char *) mci_attr_ue_count.attr.name);
+}
+
+void edac_mc_sysfs_notify_ce_noinfo_count(struct mem_ctl_info *mci)
+{
+	sysfs_notify(&mci->edac_mci_kobj, NULL,
+			(char *) mci_attr_ce_noinfo_count.attr.name);
+}
+
+void edac_mc_sysfs_notify_ue_noinfo_count(struct mem_ctl_info *mci)
+{
+	sysfs_notify(&mci->edac_mci_kobj, NULL,
+			(char *) mci_attr_ue_noinfo_count.attr.name);
+}
 
 /*
  * Release of a MC controlling instance
diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 233d479..b8386df 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -27,6 +27,10 @@ extern int edac_mc_register_sysfs_main_kobj(struct mem_ctl_info *mci);
 extern void edac_mc_unregister_sysfs_main_kobj(struct mem_ctl_info *mci);
 extern int edac_create_sysfs_mci_device(struct mem_ctl_info *mci);
 extern void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci);
+extern void edac_mc_sysfs_notify_ce_count(struct mem_ctl_info *mci);
+extern void edac_mc_sysfs_notify_ue_count(struct mem_ctl_info *mci);
+extern void edac_mc_sysfs_notify_ce_noinfo_count(struct mem_ctl_info *mci);
+extern void edac_mc_sysfs_notify_ue_noinfo_count(struct mem_ctl_info *mci);
 extern int edac_get_log_ue(void);
 extern int edac_get_log_ce(void);
 extern int edac_get_panic_on_ue(void);
@@ -42,6 +46,10 @@ extern void edac_device_unregister_sysfs_main_kobj(
 				struct edac_device_ctl_info *edac_dev);
 extern int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev);
+extern void edac_device_sysfs_notify_ce_count(
+				struct edac_device_ctl_info *edac_dev);
+extern void edac_device_sysfs_notify_ue_count(
+				struct edac_device_ctl_info *edac_dev);
 extern struct sysdev_class *edac_get_edac_class(void);
 
 /* edac core workqueue: single CPU mode */
-- 
1.6.5.2

