From 77103fcba46d4c944391e3f039e952ae2038ab3c Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Wed, 28 Apr 2010 02:49:10 -0700
Subject: [PATCH 2/4] EDAC: Improvement for common parts

The following modification was added to EDAC common parts:

1. Support was added in core EDAC so that it hands out device
   indexes instead of having each driver create its own index
   variable. This was problematic when there are more than one
   EDAC drivers.

2. Compiler warnings are issued if a fixed-size string is
   passed to edac_device_alloc_ctl_info().
   edac_device_alloc_ctl_info() name input parameters are
   made const to avoid it since the function has no need to
   modify these values.

3. Add interrupt as a valid operational state in addition to
   NMI and poll mode.

Signed-off-by: Jason HU <yongqi.hu@windriver.com>
---
 drivers/edac/edac_core.h   |    7 ++++---
 drivers/edac/edac_device.c |    4 ++--
 drivers/edac/edac_mc.c     |   13 +++++++++++++
 include/linux/edac.h       |    1 +
 4 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/drivers/edac/edac_core.h b/drivers/edac/edac_core.h
index 001b2e7..c7b99b4 100644
--- a/drivers/edac/edac_core.h
+++ b/drivers/edac/edac_core.h
@@ -650,13 +650,13 @@ struct edac_device_ctl_info {
 
 /*
  * The alloc() and free() functions for the 'edac_device' control info
- * structure. A MC driver will allocate one of these for each edac_device
+ * structure. A driver will allocate one of these for each edac_device
  * it is going to control/register with the EDAC CORE.
  */
 extern struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 		unsigned sizeof_private,
-		char *edac_device_name, unsigned nr_instances,
-		char *edac_block_name, unsigned nr_blocks,
+		const char *edac_device_name, unsigned nr_instances,
+		const char *edac_block_name, unsigned nr_blocks,
 		unsigned offset_value,
 		struct edac_dev_sysfs_block_attribute *block_attributes,
 		unsigned nr_attribs,
@@ -801,6 +801,7 @@ static inline void pci_write_bits32(struct pci_dev *pdev, int offset,
 
 extern struct mem_ctl_info *edac_mc_alloc(unsigned sz_pvt, unsigned nr_csrows,
 					  unsigned nr_chans, int edac_index);
+extern int edac_mc_alloc_index(void);
 extern int edac_mc_add_mc(struct mem_ctl_info *mci);
 extern void edac_mc_free(struct mem_ctl_info *mci);
 extern struct mem_ctl_info *edac_mc_find(int idx);
diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 395f640..4422638 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -67,8 +67,8 @@ static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
  */
 struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	unsigned sz_private,
-	char *edac_device_name, unsigned nr_instances,
-	char *edac_block_name, unsigned nr_blocks,
+	const char *edac_device_name, unsigned nr_instances,
+	const char *edac_block_name, unsigned nr_blocks,
 	unsigned offset_value,		/* zero, 1, or other based offset */
 	struct edac_dev_sysfs_block_attribute *attrib_spec, unsigned nr_attrib,
 	int device_index)
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index 227502b..8e1037b 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -37,6 +37,7 @@
 /* lock to memory controller's control array */
 static DEFINE_MUTEX(mem_ctls_mutex);
 static LIST_HEAD(mc_devices);
+static atomic_t mc_indexes = ATOMIC_INIT(0);
 
 #ifdef CONFIG_EDAC_DEBUG
 
@@ -480,6 +481,18 @@ struct mem_ctl_info *edac_mc_find(int idx)
 }
 EXPORT_SYMBOL(edac_mc_find);
 
+/*
+ * edac_mc_alloc_index: Allocate a unique MC index number
+ *
+ * Return:
+ *	allocated index number
+ */
+int edac_mc_alloc_index(void)
+{
+	return atomic_inc_return(&mc_indexes) - 1;
+}
+EXPORT_SYMBOL_GPL(edac_mc_alloc_index);
+
 /**
  * edac_mc_add_mc: Insert the 'mci' structure into the mci global list and
  *                 create sysfs entries associated with mci structure
diff --git a/include/linux/edac.h b/include/linux/edac.h
index 7cf92e8..8be109d 100644
--- a/include/linux/edac.h
+++ b/include/linux/edac.h
@@ -31,6 +31,7 @@ static inline void opstate_init(void)
 	switch (edac_op_state) {
 	case EDAC_OPSTATE_POLL:
 	case EDAC_OPSTATE_NMI:
+	case EDAC_OPSTATE_INT:
 		break;
 	default:
 		edac_op_state = EDAC_OPSTATE_POLL;
-- 
1.6.5.2

