From e5b8497ba7a6c7934a4e7e126d6e4959e0def16c Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Mon, 18 Aug 2008 15:46:19 +0800
Subject: [PATCH] drivers edac test device
 From:	Doug Thompson <dougthompson@xmission.com>

Signed-off-by:	Doug Thompson <dougthompson@xmission.com>
Integrated-by: Yongli he   <yongli.he@windriver.com>
---
 drivers/edac/Kconfig            |    5 +
 drivers/edac/Makefile           |    1 +
 drivers/edac/edac_mc.c          |   11 +-
 drivers/edac/edac_module.c      |    7 +-
 drivers/edac/test_device_edac.c |  471 +++++++++++++++++++++++++++++++++++++++
 5 files changed, 492 insertions(+), 3 deletions(-)
 create mode 100644 drivers/edac/test_device_edac.c

diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index 7108e30..c999684 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -51,6 +51,11 @@ config EDAC_MM_EDAC
 	  occurred so that a particular failing memory module can be
 	  replaced.  If unsure, select 'Y'.
 
+config EDAC_TEST_DEVICE
+	tristate "Test EDAC_DEVICE"
+	depends on EDAC_MM_EDAC && X86 && PCI
+	help
+	  Testing module for edac_device operation
 
 config EDAC_AMD76X
 	tristate "AMD 76x (760, 762, 768)"
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index a1aa892..2ae3582 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -33,4 +33,5 @@ obj-$(CONFIG_EDAC_PASEMI)		+= pasemi_edac.o
 obj-$(CONFIG_EDAC_MPC85XX)		+= mpc85xx_edac.o
 obj-$(CONFIG_EDAC_MV64X60)		+= mv64x60_edac.o
 obj-$(CONFIG_EDAC_CELL)			+= cell_edac.o
+obj-$(CONFIG_EDAC_TEST_DEVICE)		+= test_device_edac.o
 
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index 1c4c5e5..513f1ae 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -263,6 +263,8 @@ static void edac_mc_workq_function(struct work_struct *work_req)
 	struct delayed_work *d_work = (struct delayed_work *)work_req;
 	struct mem_ctl_info *mci = to_edac_mem_ctl_work(d_work);
 
+	debugf3("%s(mci-%d)\n", __func__, mci->mc_idx);
+
 	mutex_lock(&mem_ctls_mutex);
 
 	/* if this control struct has movd to offline state, we are done */
@@ -293,7 +295,7 @@ static void edac_mc_workq_function(struct work_struct *work_req)
  */
 static void edac_mc_workq_setup(struct mem_ctl_info *mci, unsigned msec)
 {
-	debugf0("%s()\n", __func__);
+	debugf0("%s() mci-%d\n", __func__, mci->mc_idx);
 
 	/* if this instance is not in the POLL state, then simply return */
 	if (mci->op_state != OP_RUNNING_POLL)
@@ -315,6 +317,8 @@ static void edac_mc_workq_teardown(struct mem_ctl_info *mci)
 {
 	int status;
 
+	debugf0("%s() mci-%d\n", __func__, mci->mc_idx);
+
 	status = cancel_delayed_work(&mci->work);
 	if (status == 0) {
 		debugf0("%s() not canceled, flush the queue\n",
@@ -567,6 +571,11 @@ struct mem_ctl_info *edac_mc_del_mc(struct device *dev)
 		"Removed device %d for %s %s: DEV %s\n", mci->mc_idx,
 		mci->mod_name, mci->ctl_name, edac_dev_name(mci));
 
+	if (list_empty(&mc_devices))
+		debugf0("%s() mc_devices list is now EMPTY\n",__func__);
+	else
+		debugf0("%s() mc_devices list is NOT EMPTY\n",__func__);
+
 	return mci;
 }
 EXPORT_SYMBOL_GPL(edac_mc_del_mc);
diff --git a/drivers/edac/edac_module.c b/drivers/edac/edac_module.c
index 7e1374a..1768d4d 100644
--- a/drivers/edac/edac_module.c
+++ b/drivers/edac/edac_module.c
@@ -151,7 +151,7 @@ static int __init edac_init(void)
 	 *      module initialization.  We should also do an initial clear
 	 *      of each newly hotplugged device.
 	 */
-	edac_pci_clear_parity_errors();
+	//edac_pci_clear_parity_errors();
 
 	/*
 	 * perform the registration of the /sys/devices/system/edac class object
@@ -196,12 +196,15 @@ error:
  */
 static void __exit edac_exit(void)
 {
-	debugf0("%s()\n", __func__);
+	debugf0("%s() exit started\n", __func__);
+
 
 	/* tear down the various subsystems */
 	edac_workqueue_teardown();
 	edac_sysfs_teardown_mc_kset();
 	edac_unregister_sysfs_edac_name();
+
+	debugf0("%s() exit completed\n", __func__);
 }
 
 /*
diff --git a/drivers/edac/test_device_edac.c b/drivers/edac/test_device_edac.c
new file mode 100644
index 0000000..3afe4dd
--- /dev/null
+++ b/drivers/edac/test_device_edac.c
@@ -0,0 +1,471 @@
+/*
+ * (C) 2007 SoftwareBitMaker (www.softwarebitmaker.com)
+ *
+ * This file may be distributed under the terms of the
+ * GNU General Public License.
+ *
+ * Written by Douglas Thompson <dougthompson@xmission.com>
+ * www.softwarebitmaker.com
+ *
+ * Test driver to test the 'edac_device' APIs, etc
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/ctype.h>
+#include <linux/io.h>
+
+#include <asm/edac.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+#define TEST_REVISION	" Ver: 1.0.0 " __DATE__
+#define	EDAC_MOD_STR	"test_device"
+
+
+
+
+struct test_device_pvt {
+	struct edac_device_ctl_info *edac_dev;
+
+	/* spinlock to protect access to Inject Registers and data */
+};
+
+/* The test device structure */
+struct test_device_struct {
+	char *test_device_name;
+
+	/* Dynamicly set values */
+	struct platform_device *test_platform_device;
+	struct edac_device_ctl_info *edac_dev;
+};
+
+#define	to_test_device_struct(x)  \
+	container_of((x), struct test_device_struct, test_device)
+
+/* Need a platform device for the test device */
+static struct test_device_struct test_device_tbl = {
+	.test_device_name = "test-device",
+};
+
+
+static ssize_t test_bits(struct edac_device_ctl_info *edac_dev,
+					const char *buffer, size_t count)
+{
+	unsigned long value;
+
+	/* convert the value and mask to just 2 bits */
+	value = simple_strtoul(buffer, NULL, 0) & 0x3;
+
+	return count;
+}
+
+/* Controller level sysfs attributes for test device
+ */
+static struct edac_dev_sysfs_attribute test_device_sysfs_attributes[] = {
+	{
+		.attr = { .name = "test_bits",
+			.mode = (S_IRUGO | S_IWUSR) },
+		.show = NULL,
+		.store = test_bits
+	},
+
+	/* End of list */
+	{
+		.attr = { .name = NULL }
+	}
+};
+
+/* Tag indexes for the various test device block attributes into the
+ * 'test_device_block_attributes' array below
+ */
+enum test_device_attrib_indexes {
+	ENTRY_0 = 0,
+	ENTRY_1,
+	ENTRY_2,
+	ENTRY_3,
+	ENTRY_4,
+	TEST_BLOCK_ATTRIBUTE_COUNT
+};
+
+/*
+ * test_device_set_sysfs_attributes
+ *
+ *	setup the top level set of sysfs attributes for the test device
+ */
+static void test_device_set_sysfs_attributes(
+				struct edac_device_ctl_info *edac_dev)
+{
+	edac_dev->sysfs_attributes = test_device_sysfs_attributes;
+}
+
+#define	to_block(x)  \
+	container_of((x), struct edac_device_block, kobj)
+
+/*
+ * The block attribute 'show' function, re-used for all the block attributes
+ */
+static ssize_t test_block_bits_attribute_show(struct kobject *kobj,
+					struct attribute *attr, char *buffer)
+{
+	ssize_t len;
+	struct edac_dev_sysfs_block_attribute *block_attrib;
+
+	block_attrib = (struct edac_dev_sysfs_block_attribute *) attr;
+
+	len = snprintf(buffer, PAGE_SIZE, "%u\n", block_attrib->value);
+
+	return len;
+}
+
+/*
+ * The block attribute, used to signal a 'clear counters' operation
+ */
+static ssize_t test_block_bits_attribute_store(struct kobject *kobj,
+					struct attribute *attr,
+					const char *buffer, size_t count)
+{
+	struct edac_dev_sysfs_block_attribute *block_attribs;
+	struct edac_device_block *block;
+
+	block = to_block(kobj);
+
+	block_attribs = block->block_attributes;
+
+	/* clear counters */
+	block_attribs[ENTRY_0].value = 0;
+	block_attribs[ENTRY_1].value = 0;
+	block_attribs[ENTRY_2].value = 0;
+	block_attribs[ENTRY_3].value = 0;
+
+	return count;
+}
+
+
+/*
+ * block attributes array
+ */
+static struct edac_dev_sysfs_block_attribute test_device_block_attributes[] = {
+	[ENTRY_0] = {
+		.attr = { .name = "test-block-bits-0", .mode = (S_IRUGO) },
+		.show = test_block_bits_attribute_show,
+		.store = NULL
+	},
+	[ENTRY_1] = {
+		.attr = { .name = "test-block-bits-1", .mode = (S_IRUGO) },
+		.show = test_block_bits_attribute_show,
+		.store = NULL
+	},
+	[ENTRY_2] = {
+		.attr = { .name = "test-block-bits-2", .mode = (S_IRUGO) },
+		.show = test_block_bits_attribute_show,
+		.store = NULL
+	},
+	[ENTRY_3] = {
+		.attr = { .name = "test-block-bits-3", .mode = (S_IRUGO) },
+		.show = test_block_bits_attribute_show,
+		.store = NULL
+	},
+	[ENTRY_4] = {
+		.attr = { .name = "reset-counters", .mode = (S_IRUGO | S_IWUSR) },
+		.show = NULL,
+		.store = test_block_bits_attribute_store
+	}
+};
+
+/*
+ * test check function
+ */
+static  void test_edac_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct edac_dev_sysfs_block_attribute *block_attribs;
+
+
+	/* get pointer to the array of block attributes */
+	block_attribs = edac_dev->instances[0].blocks[0].block_attributes;
+
+	debugf0("%s() counting secs\n", __func__);
+
+	/* bump an error count */
+	block_attribs[ENTRY_0].value++;
+	if (block_attribs[ENTRY_0].value == 10) {
+		block_attribs[ENTRY_0].value = 0;
+		block_attribs[ENTRY_1].value++;
+
+		debugf0("%s() counting 10 secs\n", __func__);
+
+		/* Every ten seconds "generate a CE" */
+		edac_device_handle_ce(edac_dev,
+					0,
+					0,
+					"Test 'generated' CE Event");
+
+		if (block_attribs[ENTRY_1].value == 10) {
+			block_attribs[ENTRY_1].value = 0;
+			block_attribs[ENTRY_2].value++;
+
+			if (block_attribs[ENTRY_2].value == 10) {
+				block_attribs[ENTRY_2].value = 0;
+				block_attribs[ENTRY_3].value++;
+			}
+		}
+	}
+}
+
+#define NUM_INSTANCES	1
+#define NUM_BLOCKS	1
+
+/*
+ * test_device_probe
+ *
+ *	Perform the probing and setup of the software for the
+ */
+static int test_device_probe(struct test_device_struct *test_dev,
+			struct edac_device_ctl_info **p_edac_dev)
+{
+	struct edac_device_ctl_info *edac_dev;
+	struct test_device_pvt *test_device_pvt;
+	unsigned sz_pvt;
+
+	debugf1("######### Enter %s ########\n", __func__);
+
+	sz_pvt = sizeof(struct test_device_pvt);
+	edac_dev = edac_device_alloc_ctl_info(
+			sz_pvt,		/* size of private area */
+			"test-instance", NUM_INSTANCES,
+			"test-block",	NUM_BLOCKS,
+			0,		/* block offset starts with 0 */
+			test_device_block_attributes,
+			TEST_BLOCK_ATTRIBUTE_COUNT,
+			0);		/* device index */
+
+	if (edac_dev == NULL)
+		return -ENODEV;
+
+	/* point to private area, and cross link private to container */
+	test_device_pvt = edac_dev->pvt_info;
+	test_device_pvt->edac_dev = edac_dev;
+
+	/* link our edac_dev to the real 'device dev' */
+	edac_dev->dev = &test_dev->test_platform_device->dev;
+
+	edac_dev->mod_name = EDAC_MOD_STR;
+	edac_dev->ctl_name = test_dev->test_device_name;
+	edac_dev->dev_name = "TEST-DEVICE";
+
+	/* Interrupt driven, no polling */
+	edac_dev->edac_check = test_edac_check;
+
+	/* Go setup for our own attribute to control things */
+	test_device_set_sysfs_attributes(edac_dev);
+
+	/* add and finalize this device's control structure */
+	if (edac_device_add_device(edac_dev) > 0) {
+		debugf3("%s(): failed edac_device_add_device(0)\n", __func__);
+		goto err_add_device_fail;
+	}
+
+	/* return the edac_dev to caller */
+	if (p_edac_dev)
+		*p_edac_dev = edac_dev;
+
+	debugf1("######### Success Exit %s ########\n", __func__);
+
+	return 0;
+
+	/* error teardown stack */
+err_add_device_fail:
+	edac_device_free_ctl_info(edac_dev);
+	return -ENODEV;
+}
+
+/*
+ * test_device_register_me
+ *
+ *	register the test_device device for EDAC operation
+ */
+static int test_device_register_me(void)
+{
+	int err;
+	char nameBuf[24];
+	struct test_device_struct *test_dev;
+	struct platform_device *test_device;
+	struct edac_device_ctl_info *edac_dev;
+
+	debugf0("%s()\n", __func__);
+
+	/* form this test instance device name */
+	snprintf(nameBuf, sizeof(nameBuf)-1, "test_device");
+
+	/* Allocate a platform device for this set of cache */
+	test_device = platform_device_alloc(nameBuf, -1);
+	if (test_device) {
+		err = platform_device_add(test_device);
+		if (err < 0) {
+			debugf0("%s() platform_device_add() failed err=%d\n",
+					__func__, err);
+			goto platform_fail;
+		}
+
+		/* save the new 'test device device' into our test_dev */
+		test_dev = &test_device_tbl;
+		test_dev->test_platform_device = test_device;
+
+		/* probe the test device */
+		err = test_device_probe(test_dev, &edac_dev);
+		if (err < 0) {
+			debugf0("%s() test_device_probe() failed err=%d\n",
+				__func__, err);
+			goto probe_fail;
+		}
+	}
+
+	return 0;
+
+	/* Error unwind stack */
+probe_fail:
+	platform_device_unregister(test_device);
+
+platform_fail:
+
+	return err;
+}
+
+/*
+ * test_device_unregister_me
+ *
+ *	tear down function
+ */
+static void test_device_unregister_me(void)
+{
+	struct edac_device_ctl_info *edac_dev;
+	struct test_device_struct *test_dev;
+
+	debugf3("%s()\n", __func__);
+
+	test_dev = &test_device_tbl;
+	edac_dev = test_dev->edac_dev;
+
+	/* Unregister and delete the device control structure from EDAC core
+	 */
+	edac_dev = edac_device_del_device(&test_dev->test_platform_device->dev);
+	if (edac_dev)
+		edac_device_free_ctl_info(edac_dev);
+
+	/* unregister the cache platform device */
+	platform_device_unregister(test_dev->test_platform_device);
+}
+
+
+/* Start various methods for platform bus */
+
+/* Platform Device model methods and structure */
+static int test_device_platform_probe(struct platform_device *pdev)
+{
+	debugf0("%s()\n", __func__ );
+	return 0;
+}
+
+static int test_device_platform_remove(struct platform_device *pdev)
+{
+	debugf0("%s()\n", __func__ );
+	return 0;
+}
+
+static void test_device_platform_shutdown(struct platform_device *pdev)
+{
+	debugf0("%s()\n", __func__ );
+}
+
+static int test_device_platform_suspend(struct platform_device *pdev,
+				pm_message_t state)
+{
+	debugf0("%s()\n", __func__ );
+	return 0;
+}
+
+static int test_device_platform_resume(struct platform_device *pdev)
+{
+	debugf0("%s()\n", __func__ );
+	return 0;
+}
+
+
+/* Driver structure for the test device driver */
+static struct platform_driver test_device_driver = {
+	.probe          = test_device_platform_probe,
+	.remove         = test_device_platform_remove,
+	.shutdown       = test_device_platform_shutdown,
+	.suspend        = test_device_platform_suspend,
+	.resume         = test_device_platform_resume,
+	.driver = {
+		.owner  = THIS_MODULE,
+		.name   = EDAC_MOD_STR,
+	},
+};
+
+
+/*
+ * test_device_init
+ *
+ *	Module entry point to be invoked when the module is loaded
+ *	create a 'virtual' platform to place our test device
+ *	then create the test device
+ */
+static int __init test_device_init(void)
+{
+	int err;
+
+	debugf0("%s()\n", __func__);
+
+	/* Register this driver with the driver core. */
+	err = platform_driver_register(&test_device_driver);
+	if (err < 0)
+		goto platform_reg_fail;
+
+	/* Register this module's devices */
+	err = test_device_register_me();
+	if (err < 0)
+		goto device_reg_fail;
+
+	return 0;
+
+
+device_reg_fail:
+	platform_driver_unregister(&test_device_driver);
+platform_reg_fail:
+	return err;
+}
+
+/*
+ * test_device_exit
+ *
+ *	Module exit point which is called when the module is removed
+ */
+static void test_device_exit(void)
+{
+	debugf3("%s()\n", __func__);
+
+	/* unregister the devices on this 'virtual' platform */
+	test_device_unregister_me();
+
+	/* unregister the 'virtual' platform */
+	platform_driver_unregister(&test_device_driver);
+}
+
+/**********************************************************************/
+
+/* Specify the module entry and exit points */
+module_init(test_device_init);
+module_exit(test_device_exit);
+
+/* Module attribute information */
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Doug Thompson <dougthompson@xmission.com>");
+MODULE_DESCRIPTION("Test Driver for EDAC_DEVICE APIs");
-- 
1.5.5.1

