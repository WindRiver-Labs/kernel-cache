From 2eb19ce872e1ecc9c65507a4698997c06facc78c Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Sat, 8 Nov 2008 17:57:08 -0500
Subject: [PATCH] EDAC: Add amd8131 chipset support for vMC

Add EDAC vMC wrapper calls and a vMC sensor mappings for amd8131 Maple
chipsets.  This vMC integration is enabled by the CONFIG_EDAC_VMC
kernel configuration.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 drivers/edac/amd8131_edac.c     |  403 +++++++++++++++++++++++++++++++++------
 drivers/edac/amd8131_edac.h     |   84 ++++++---
 drivers/edac/amd8131_edac_vmc.h |  169 ++++++++++++++++
 3 files changed, 570 insertions(+), 86 deletions(-)
 create mode 100644 drivers/edac/amd8131_edac_vmc.h

diff --git a/drivers/edac/amd8131_edac.c b/drivers/edac/amd8131_edac.c
index c544bd8..af1b4b0 100644
--- a/drivers/edac/amd8131_edac.c
+++ b/drivers/edac/amd8131_edac.c
@@ -33,9 +33,15 @@
 #include "edac_module.h"
 #include "amd8131_edac.h"
 
-#define AMD8131_EDAC_REVISION	" Ver: 1.0.0 " __DATE__
+#ifdef CONFIG_EDAC_VMC
+#include "edac_vmc.h"
+#include "amd8131_edac_vmc.h"
+#endif
+
+#define AMD8131_EDAC_REVISION	" Ver: 1.1.0 " __DATE__
 #define AMD8131_EDAC_MOD_STR	"amd8131_edac"
 
+static int edac_pci_idx;
 static char * const bridge_str[] = {
 	[NORTH_A] = "NORTH A",
 	[NORTH_B] = "NORTH B",
@@ -44,98 +50,221 @@ static char * const bridge_str[] = {
 	[NO_BRIDGE] = "NO BRIDGE",
 };
 
+/* Support up to two AMD8131 chipsets on a platform */
 static struct amd8131_dev_info amd8131_devices[] = {
 	{
 	.inst = NORTH_A,
 	.devfn = DEVFN_PCIX_BRIDGE_NORTH_A,
-	.ctl_name = "NORTH_A",
+	.ctl_name = "AMD8131_PCIX_NORTH_A",
 	},
 	{
 	.inst = NORTH_B,
 	.devfn = DEVFN_PCIX_BRIDGE_NORTH_B,
-	.ctl_name = "NORTH_B",
+	.ctl_name = "AMD8131_PCIX_NORTH_B",
 	},
 	{
 	.inst = SOUTH_A,
 	.devfn = DEVFN_PCIX_BRIDGE_SOUTH_A,
-	.ctl_name = "SOUTH_A",
+	.ctl_name = "AMD8131_PCIX_SOUTH_A",
 	},
 	{
 	.inst = SOUTH_B,
 	.devfn = DEVFN_PCIX_BRIDGE_SOUTH_B,
-	.ctl_name = "SOUTH_B",
+	.ctl_name = "AMD8131_PCIX_SOUTH_B",
 	},
 	{.inst = NO_BRIDGE,},
 };
 
-
-static void amd8131_apic_init(struct amd8131_dev_info *dev_info)
+static void amd8131_pcix_init(struct amd8131_dev_info *dev_info)
 {
 	u32 val32;
+	struct pci_dev *dev = dev_info->dev;
+
+	/*
+	 * First clear error detection flags.
+	 */
+	if (pci_read_config_dword(dev, REG_MEM_LIM, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 |= MEM_LIMIT_MASK;
+	if (pci_write_config_dword(dev, REG_MEM_LIM, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	/* Clear Discard Timer Timedout flag */
+	if (pci_read_config_dword(dev, REG_INT_CTLR, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 |= INT_CTLR_DTS;
+	if (pci_write_config_dword(dev, REG_INT_CTLR, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	/* Clear CRC Error flag on link side A */
+	if (pci_read_config_dword(dev, REG_LNK_CTRL_A, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 |= LNK_CTRL_CRCERR_A;
+	if (pci_write_config_dword(dev, REG_LNK_CTRL_A, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	/* Clear CRC Error flag on link side B */
+	if (pci_read_config_dword(dev, REG_LNK_CTRL_B, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 |= LNK_CTRL_CRCERR_B;
+	if (pci_write_config_dword(dev, REG_LNK_CTRL_B, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	/*
+	 * Then enable all error detections.
+	 *
+	 * Setup Discard Timer Sync Flood Enable, System Error Enable
+	 * and Parity Error Enable.
+	 */
+	if (pci_read_config_dword(dev, REG_INT_CTLR, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 |= INT_CTLR_PERR | INT_CTLR_SERR | INT_CTLR_DTSE;
+	if (pci_write_config_dword(dev, REG_INT_CTLR, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	/*
+ 	 * Enable overall SERR Error detection.
+	 * Note, many other error detections are controlled by this bit.
+	 */
+	if (pci_read_config_dword(dev, REG_STS_CMD, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 |= STS_CMD_SERREN;
+	if (pci_write_config_dword(dev, REG_STS_CMD, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+ 	 /* Setup CRC Flood Enable for link side A */
+	if (pci_read_config_dword(dev, REG_LNK_CTRL_A, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 |= LNK_CTRL_CRCFEN;
+	if (pci_write_config_dword(dev, REG_LNK_CTRL_A, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
 
-	/* ask for SERR and PERR errors */
-	if (pci_read_config_dword(dev_info->dev, REG_INT_CTLR, &val32)) {
+	/* Setup CRC Flood Enable for link side B */
+	if (pci_read_config_dword(dev, REG_LNK_CTRL_B, &val32)) {
 		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
-	val32 |= INT_CTLR_PERR | INT_CTLR_SERR;
-	if (pci_write_config_dword(dev_info->dev, REG_INT_CTLR, val32)) {
+	val32 |= LNK_CTRL_CRCFEN;
+	if (pci_write_config_dword(dev, REG_LNK_CTRL_B, val32)) {
 		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
 
-	/* ask to generate an NMI if this is the operational state */
+	/* enable HT NMI messages generation on errors */
 	if (EDAC_OPSTATE_NMI == edac_op_state) {
-		if (pci_read_config_dword(dev_info->dev, REG_MISC_II, &val32)) {
+		if (pci_read_config_dword(dev, REG_MISC_II, &val32)) {
 			printk(KERN_ERR "PCI Access Error\n");
 			return;
 		}
 		val32 |= MISC_II_NMI;
-		if (pci_write_config_dword(dev_info->dev, REG_MISC_II, val32))
+		if (pci_write_config_dword(dev, REG_MISC_II, val32))
 			printk(KERN_ERR "PCI Access Error\n");
 	}
 }
 
-static void amd8131_apic_exit(struct amd8131_dev_info *dev_info)
+static void amd8131_pcix_exit(struct amd8131_dev_info *dev_info)
 {
 	u32 val32;
+	struct pci_dev *dev = dev_info->dev;
 
-	/* stop asking for SERR and PERR errors */
-	if (pci_read_config_dword(dev_info->dev, REG_INT_CTLR, &val32)) {
-		printk (KERN_ERR "PCI Access Error\n");
+	/* Disable SERR, PERR and DTSE Error detection */
+	if (pci_read_config_dword(dev, REG_INT_CTLR, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
-	val32 &= ~(INT_CTLR_PERR | INT_CTLR_SERR);
-	if (pci_write_config_dword(dev_info->dev, REG_INT_CTLR, val32)) {
-		printk (KERN_ERR "PCI Access Error\n");
+	val32 &= ~(INT_CTLR_PERR | INT_CTLR_SERR | INT_CTLR_DTSE);
+	if (pci_write_config_dword(dev, REG_INT_CTLR, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
 
-	/* stop asking to generate an NMI; doesn't hurt even
-	 * if EDAC is not in NMI opstate */
-	if (pci_read_config_dword(dev_info->dev, REG_MISC_II, &val32)) {
+	/* Disable HT NMI messages on errors*/
+	if (EDAC_OPSTATE_NMI == edac_op_state) {
+		if (pci_read_config_dword(dev, REG_MISC_II, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 &= ~MISC_II_NMI;
+		if (pci_write_config_dword(dev, REG_MISC_II, val32))
+			printk(KERN_ERR "PCI Access Error\n");
+	}
+
+	/* Disable overall System Error detection */
+	if (pci_read_config_dword(dev, REG_STS_CMD, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 &= ~STS_CMD_SERREN;
+	if (pci_write_config_dword(dev, REG_STS_CMD, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	/* Disable CRC Sync Flood on link side A */
+	if (pci_read_config_dword(dev, REG_LNK_CTRL_A, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 &= ~LNK_CTRL_CRCFEN;
+	if (pci_write_config_dword(dev, REG_LNK_CTRL_A, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	/* Disable CRC Sync Flood on link side B */
+	if (pci_read_config_dword(dev, REG_LNK_CTRL_B, &val32)) { /* 0xc8 */
 		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
-	val32 &= ~MISC_II_NMI;
-	if (pci_write_config_dword(dev_info->dev, REG_MISC_II, val32))
+	val32 &= ~LNK_CTRL_CRCFEN;
+	if (pci_write_config_dword(dev, REG_LNK_CTRL_B, val32)) {
 		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
 }
 
-static void amd8131_apic_check(struct edac_device_ctl_info *edac_dev)
+static void amd8131_pcix_check(struct edac_pci_ctl_info *edac_dev)
 {
 	struct amd8131_dev_info *dev_info = edac_dev->pvt_info;
 	struct pci_dev *dev = dev_info->dev;
 	u32 val32;
 
+	/* Check PCI-X Bridge Memory Base-Limit Register for errors */
 	if (pci_read_config_dword(dev, REG_MEM_LIM, &val32)) {
 		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
-
 	if (val32 & MEM_LIMIT_MASK) {
-		printk(KERN_INFO "Error(s) in mem limit register on %s bridge\n",
-			dev_info->ctl_name);
+		printk(KERN_INFO "Error(s) in mem limit register "
+			"on %s bridge\n", dev_info->ctl_name);
 		printk(KERN_INFO "DPE: %d, RSE: %d, RMA: %d\n"
 			"RTA: %d, STA: %d, MDPE: %d\n",
 			val32 & MEM_LIMIT_DPE,
@@ -145,36 +274,177 @@ static void amd8131_apic_check(struct edac_device_ctl_info *edac_dev)
 			val32 & MEM_LIMIT_STA,
 			val32 & MEM_LIMIT_MDPE);
 
+#ifdef CONFIG_EDAC_VMC
+		/* Report faults to vMC */
+		REPORT_FAULT(MEM_LIMIT_DPE, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_RSE, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_RMA, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_RTA, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_STA, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_MDPE, REG_MEM_LIM, val32, dev_info->inst);
+#endif
+
 		val32 |= MEM_LIMIT_MASK;
 		if (pci_write_config_dword(dev, REG_MEM_LIM, val32)) {
 			printk(KERN_ERR "PCI Access Error\n");
 			return;
 		}
 
-		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+		edac_pci_handle_npe(edac_dev, edac_dev->ctl_name);
+	}
+
+	/* Check if Discard Timer timed out */
+	if (pci_read_config_dword(dev, REG_INT_CTLR, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	if (val32 & INT_CTLR_DTS) {
+		printk(KERN_INFO "Error(s) in interrupt and control register "
+			"on %s bridge\n", dev_info->ctl_name);
+		printk(KERN_INFO "DTS: %d\n", val32 & INT_CTLR_DTS);
+
+		val32 |= INT_CTLR_DTS;
+		if (pci_write_config_dword(dev, REG_INT_CTLR, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		edac_pci_handle_npe(edac_dev, edac_dev->ctl_name);
+	}
+
+	/* Check if CRC error happens on link side A */
+	if (pci_read_config_dword(dev, REG_LNK_CTRL_A, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	if (val32 & LNK_CTRL_CRCERR_A) {
+		printk(KERN_INFO "Error(s) in link conf and control register "
+			"on %s bridge\n", dev_info->ctl_name);
+		printk(KERN_INFO "CRCERR: %d\n", val32 & LNK_CTRL_CRCERR_A);
+
+		val32 |= LNK_CTRL_CRCERR_A;
+		if (pci_write_config_dword(dev, REG_LNK_CTRL_A, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		edac_pci_handle_npe(edac_dev, edac_dev->ctl_name);
+	}
+
+	/* Check if CRC error happens on link side B */
+	if (pci_read_config_dword(dev, REG_LNK_CTRL_B, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	if (val32 & LNK_CTRL_CRCERR_B) {
+		printk(KERN_INFO "Error(s) in link conf and control register "
+			"on %s bridge\n", dev_info->ctl_name);
+		printk(KERN_INFO "CRCERR: %d\n", val32 & LNK_CTRL_CRCERR_B);
+
+		val32 |= LNK_CTRL_CRCERR_B;
+		if (pci_write_config_dword(dev, REG_LNK_CTRL_B, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		edac_pci_handle_npe(edac_dev, edac_dev->ctl_name);
 	}
 }
 
 static struct amd8131_info amd8131_chipset = {
 	.err_dev = PCI_DEVICE_ID_AMD_8131_APIC,
 	.devices = amd8131_devices,
-	.init = amd8131_apic_init,
-	.exit = amd8131_apic_exit,
-	.check = amd8131_apic_check,
+	.init = amd8131_pcix_init,
+	.exit = amd8131_pcix_exit,
+	.check = amd8131_pcix_check,
 };
 
 
+#ifdef CONFIG_EDAC_VMC
+static int init_vmc_sensors(void)
+{
+	int rc;
+
+	/* Assign a vMC LUN to this chipset */
+	amd8131_vmc_lun = vmc_assign_lun();
+
+#define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id), amd8131_sensor_map, \
+						amd8131_sensor_names,	\
+						amd8131_vmc_lun, NULL)
+	/* Sensors with default parameters: */
+	rc  = INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_MDPE);
+
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_MDPE);
+
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_MDPE);
+
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_MDPE);
+#undef INIT_SENSOR_DEFAULT
+
+	return rc;
+}
+
+static void uninit_vmc_sensors(void)
+{
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_DPE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_RSE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_RMA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_RTA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_STA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_MDPE, amd8131_vmc_lun);
+
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_DPE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_RSE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_RMA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_RTA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_STA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_MDPE, amd8131_vmc_lun);
+
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_DPE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_RSE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_RMA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_RTA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_STA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_MDPE, amd8131_vmc_lun);
+
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_DPE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_RSE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_RMA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_RTA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_STA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_MDPE, amd8131_vmc_lun);
+}
+#endif /* CONFIG_EDAC_VMC */
+
 /*
- * There are 4 instances of one type of PCI device that share the same
- * PCI Device ID, so amd8131_probe() would be called by kernel 4 times,
- * with different address of pci_dev for each of them each time.
+ * There are 4 PCIX Bridges on ATCA-6101 that share the same PCI Device ID,
+ * so amd8131_probe() would be called by kernel 4 times, with different
+ * address of pci_dev for each of them each time.
  */
 static int amd8131_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	struct amd8131_dev_info *dev_info;
 
 	debugf0("EDAC devfn = 0x%x (%d)\n",dev->devfn,dev->devfn);
-	for (dev_info = amd8131_chipset.devices; dev_info->inst != NO_BRIDGE; dev_info++)
+	for (dev_info = amd8131_chipset.devices; dev_info->inst != NO_BRIDGE;
+		dev_info++)
 		if (dev_info->devfn == dev->devfn)
 			break;
 
@@ -196,18 +466,13 @@ static int amd8131_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		return -ENODEV;
 	}
 
-	printk("EDAC %s-%s:%d\n",__FILE__,__FUNCTION__,__LINE__);
 	/*
 	 * we do not allocate extra private structure for
-	 * edac_device_ctl_info, but make use of existing
+	 * edac_pci_ctl_info, but make use of existing
 	 * one instead.
-	*/
-
-	dev_info->edac_idx = edac_device_alloc_index();
-	dev_info->edac_dev =
-		edac_device_alloc_ctl_info(0, dev_info->ctl_name, 1,
-					   NULL, 0, 0,
-					   NULL, 0, dev_info->edac_idx);
+	 */
+	dev_info->edac_idx = edac_pci_idx++;
+	dev_info->edac_dev = edac_pci_alloc_ctl_info(0, dev_info->ctl_name);
 	if (!dev_info->edac_dev)
 		return -ENOMEM;
 
@@ -220,25 +485,26 @@ static int amd8131_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	/* FIXME: so far we only support POLL mode */
 	if (edac_op_state == EDAC_OPSTATE_POLL)
 		dev_info->edac_dev->edac_check = amd8131_chipset.check;
-	else if ((edac_op_state == EDAC_OPSTATE_INT)) {
-		dev_info->irq = dev_info->dev->irq;
+	/*
+	 * Note:
+	 * According to AMD8131 data sheet 4.5.7 section, only a partial
+	 * of all error detections could generate NMI HT messages, so use
+	 * NMI mode at sacrifice that not all error detections would be
+	 * made use of.
+	 */
+	else if ((edac_op_state == EDAC_OPSTATE_NMI)) {
 		/*
-		 * instantiate EDAC NMI handler, or
-		 * register interrupt handler
-		 *
-		 * request_irq(dev_info->irq, amd8131_chipset.isr,
-				IRQF_DISABLED, "[EDAC] dev_info->ctl_name",
-				dev_info->edac_dev);
+		 * FIXME: register EDAC NMI handler into kernel
 		 */
 	}
 
 	if (amd8131_chipset.init)
 		amd8131_chipset.init(dev_info);
 
-	if (edac_device_add_device(dev_info->edac_dev) > 0) {
-		printk(KERN_ERR "failed edac_device_add_device() for %s\n",
+	if (edac_pci_add_device(dev_info->edac_dev, dev_info->edac_idx) > 0) {
+		printk(KERN_ERR "failed edac_pci_add_device() for %s\n",
 			dev_info->ctl_name);
-		edac_device_free_ctl_info(dev_info->edac_dev);
+		edac_pci_free_ctl_info(dev_info->edac_dev);
 		return -ENODEV;
 	}
 
@@ -254,7 +520,8 @@ static void amd8131_remove(struct pci_dev *dev)
 {
 	struct amd8131_dev_info *dev_info;
 
-	for (dev_info = amd8131_chipset.devices; dev_info->inst != NO_BRIDGE; dev_info++)
+	for (dev_info = amd8131_chipset.devices; dev_info->inst != NO_BRIDGE;
+		dev_info++)
 		if (dev_info->devfn == dev->devfn)
 			break;
 
@@ -262,8 +529,8 @@ static void amd8131_remove(struct pci_dev *dev)
 		return;
 
 	if (dev_info->edac_dev) {
-		edac_device_del_device(dev_info->edac_dev->dev);
-		edac_device_free_ctl_info(dev_info->edac_dev);
+		edac_pci_del_device(dev_info->edac_dev->dev);
+		edac_pci_free_ctl_info(dev_info->edac_dev);
 	}
 
 	if (amd8131_chipset.exit)
@@ -274,7 +541,7 @@ static void amd8131_remove(struct pci_dev *dev)
 
 static const struct pci_device_id amd8131_edac_pci_tbl[] = {
 	{
-	PCI_VEND_DEV(AMD, 8131_APIC),
+	PCI_VEND_DEV(AMD, 8131_BRIDGE),
 	PCI_ANY_ID,		/* subvendor */
 	PCI_ANY_ID,		/* subdevice */
 	0,			/* class */
@@ -296,11 +563,23 @@ static int __init amd8131_edac_init(void)
 {
 	opstate_init();
 
+#ifdef CONFIG_EDAC_VMC
+        /* Initialize vMC sensors */
+	if (init_vmc_sensors())
+		printk(KERN_ERR "failed to initialize one or more "
+				"vMC sensors\n");
+#endif
+
 	return pci_register_driver(&amd8131_edac_driver);
 }
 
 static void __exit amd8131_edac_exit(void)
 {
+#ifdef CONFIG_EDAC_VMC
+	/* Uninitialize vMC sensors */
+	uninit_vmc_sensors();
+#endif
+
 	pci_unregister_driver(&amd8131_edac_driver);
 }
 
diff --git a/drivers/edac/amd8131_edac.h b/drivers/edac/amd8131_edac.h
index 46a35e8..c05f158 100644
--- a/drivers/edac/amd8131_edac.h
+++ b/drivers/edac/amd8131_edac.h
@@ -25,24 +25,35 @@
 #ifndef _AMD8131_EDAC_H_
 #define _AMD8131_EDAC_H_
 
-#define DEVFN_PCIX_BRIDGE_NORTH_A	(8+1)
-#define DEVFN_PCIX_BRIDGE_NORTH_B	(16+1)
-#define DEVFN_PCIX_BRIDGE_SOUTH_A	(24+1)
-#define DEVFN_PCIX_BRIDGE_SOUTH_B	(32+1)
+#define DEVFN_PCIX_BRIDGE_NORTH_A	8
+#define DEVFN_PCIX_BRIDGE_NORTH_B	16
+#define DEVFN_PCIX_BRIDGE_SOUTH_A	24
+#define DEVFN_PCIX_BRIDGE_SOUTH_B	32
 
-#define REG_MEM_LIM	0x1c
-#define REG_INT_CTLR	0x3c
-#define REG_MISC_II	0x44
-
-enum int_ctlr_bits {
-	INT_CTLR_PERR = BIT(16),
-	INT_CTLR_SERR = BIT(17)
+/************************************************************
+ *	PCI-X Bridge Status and Command Register, DevA:0x04
+ ************************************************************/
+#define REG_STS_CMD	0x04
+enum sts_cmd_bits {
+	STS_CMD_SSE	= BIT(30),
+	STS_CMD_SERREN	= BIT(8)
 };
 
-enum misc_ii_bits {
-	MISC_II_NMI = BIT(0)
+/************************************************************
+ *	PCI-X Bridge Interrupt and Bridge Control Register,
+ ************************************************************/
+#define REG_INT_CTLR	0x3c
+enum int_ctlr_bits {
+	INT_CTLR_DTSE	= BIT(27),
+	INT_CTLR_DTS	= BIT(26),
+	INT_CTLR_SERR	= BIT(17),
+	INT_CTLR_PERR	= BIT(16)
 };
 
+/************************************************************
+ *	PCI-X Bridge Memory Base-Limit Register, DevA:0x1C
+ ************************************************************/
+#define REG_MEM_LIM	0x1c
 enum mem_limit_bits {
 	MEM_LIMIT_DPE 	= BIT(31),
 	MEM_LIMIT_RSE 	= BIT(30),
@@ -54,6 +65,31 @@ enum mem_limit_bits {
 				MEM_LIMIT_RTA|MEM_LIMIT_STA|MEM_LIMIT_MDPE
 };
 
+/************************************************************
+ *	Link Configuration And Control Register, side A
+ ************************************************************/
+#define REG_LNK_CTRL_A	0xc4
+
+/************************************************************
+ *	Link Configuration And Control Register, side B
+ ************************************************************/
+#define REG_LNK_CTRL_B  0xc8
+
+enum lnk_ctrl_bits {
+	LNK_CTRL_CRCERR_A	= BIT(9),
+	LNK_CTRL_CRCERR_B	= BIT(8),
+	LNK_CTRL_CRCFEN		= BIT(1)
+};
+
+/************************************************************
+ *	PCI-X Miscellaneous II Register, Dev[B,A]:0x44
+ ************************************************************/
+#define REG_MISC_II	0x44
+
+enum misc_ii_bits {
+	MISC_II_NMI	= BIT(0),
+};
+
 enum pcix_bridge_inst {
 	NORTH_A = 0,
 	NORTH_B = 1,
@@ -66,27 +102,27 @@ struct amd8131_dev_info {
 	int devfn;
 	enum pcix_bridge_inst inst;
 	struct pci_dev *dev;
-	int edac_idx;	/* device index */
-	int irq;
+	int edac_idx;	/* pci device index */
 	char *ctl_name;
-	struct edac_device_ctl_info *edac_dev;
+	struct edac_pci_ctl_info *edac_dev;
 };
 
 /*
- * There are 4 instances of one type of PCI Device on AMD8131 chipset,
- * D1F1, D2F1, D3F1, D4F1, which have the same PCI Device ID and could
- * be discrimated by their pci_dev->devfn.
- * They share the same set of init/check/exit methods, and their private
- * structures are collected in the devices[] array.
+ * AMD8131 chipset has two pairs of PCIX Bridge and related IOAPIC
+ * Controler, and ATCA-6101 has two AMD8131 chipsets, so there are
+ * four PCIX Bridges on ATCA-6101 altogether.
+ *
+ * These PCIX Bridges share the same PCI Device ID and are all of
+ * Function Zero, they could be discrimated by their pci_dev->devfn.
+ * They share the same set of init/check/exit methods, and their
+ * private structures are collected in the devices[] array.
  */
 struct amd8131_info {
 	u16 err_dev;	/* PCI Device ID for AMD8131 APIC*/
 	struct amd8131_dev_info *devices;
 	void (*init)(struct amd8131_dev_info *dev_info);
 	void (*exit)(struct amd8131_dev_info *dev_info);
-	void (*check)(struct edac_device_ctl_info *edac_dev);
-	/*FIXME: do we need register interrupt handler for a PCI device ?*/
-	/* irqreturn_t (*isr)(int irq, void *edac_dev); */
+	void (*check)(struct edac_pci_ctl_info *edac_dev);
 };
 
 #endif /* _AMD8131_EDAC_H_ */
diff --git a/drivers/edac/amd8131_edac_vmc.h b/drivers/edac/amd8131_edac_vmc.h
new file mode 100644
index 0000000..dd626d9
--- /dev/null
+++ b/drivers/edac/amd8131_edac_vmc.h
@@ -0,0 +1,169 @@
+/*
+ * amd8131_edac_vmc.h, vMC sensor maps for AMD8131 EDAC driver
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors: Benjamin Walsh (benjamin.walsh@windriver.com)
+ *          Matt Wagantall (matthew.wagantall@windriver.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _AMD8131_EDAC_VMC_H_
+#define _AMD8131_EDAC_VMC_H_
+
+#include "edac_vmc.h"
+#include "amd8131_edac.h"
+
+/* Assign sensor numbers.
+ *   Order is arbitrary */
+enum amd8131_sensors {
+	VMC_NORTH_A_MEM_LIMIT_DPE = 0,
+	VMC_NORTH_A_MEM_LIMIT_RSE,
+	VMC_NORTH_A_MEM_LIMIT_RMA,
+	VMC_NORTH_A_MEM_LIMIT_RTA,
+	VMC_NORTH_A_MEM_LIMIT_STA,
+	VMC_NORTH_A_MEM_LIMIT_MDPE,
+
+	VMC_NORTH_B_MEM_LIMIT_DPE,
+	VMC_NORTH_B_MEM_LIMIT_RSE,
+	VMC_NORTH_B_MEM_LIMIT_RMA,
+	VMC_NORTH_B_MEM_LIMIT_RTA,
+	VMC_NORTH_B_MEM_LIMIT_STA,
+	VMC_NORTH_B_MEM_LIMIT_MDPE,
+
+	VMC_SOUTH_A_MEM_LIMIT_DPE,
+	VMC_SOUTH_A_MEM_LIMIT_RSE,
+	VMC_SOUTH_A_MEM_LIMIT_RMA,
+	VMC_SOUTH_A_MEM_LIMIT_RTA,
+	VMC_SOUTH_A_MEM_LIMIT_STA,
+	VMC_SOUTH_A_MEM_LIMIT_MDPE,
+
+	VMC_SOUTH_B_MEM_LIMIT_DPE,
+	VMC_SOUTH_B_MEM_LIMIT_RSE,
+	VMC_SOUTH_B_MEM_LIMIT_RMA,
+	VMC_SOUTH_B_MEM_LIMIT_RTA,
+	VMC_SOUTH_B_MEM_LIMIT_STA,
+	VMC_SOUTH_B_MEM_LIMIT_MDPE
+};
+
+/* Assign sensor names.
+ * macro usage: name_sensor( name ),
+ *   Order does not matter here */
+#define name_sensor(x) [(x)] = #x
+static const char *amd8131_sensor_names[] = {
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_DPE),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_RSE),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_RMA),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_RTA),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_STA),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_MDPE),
+
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_DPE),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_RSE),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_RMA),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_RTA),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_STA),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_MDPE),
+
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_DPE),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_RSE),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_RMA),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_RTA),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_STA),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_MDPE),
+
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_DPE),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_RSE),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_RMA),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_RTA),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_STA),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_MDPE),
+};
+
+/* Map sensors to vMC IPMI entities.
+ * macro usage: map_sensor(sensor, entity type, entity instance),
+ *   Order does not matter here */
+#define map_sensor(sensor, entity, entity_id) \
+	[(sensor)] = (((entity) << 8) | (entity_id))
+static const int amd8131_sensor_map[] = {
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS, 0),
+
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS, 1),
+
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS, 2),
+
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS, 3)
+};
+
+/* put here instead of C file to modularize with vMC */
+static int amd8131_vmc_lun;
+
+#define REPORT_FAULT(bits, reg_name, reg_value, bridge)			\
+	do {								\
+		if(reg_value & bits) {					\
+			switch(bridge) {				\
+			case NORTH_A:					\
+				vmc_report_fault(VMC_NORTH_A_##bits,	\
+						amd8131_vmc_lun,		\
+						SENSOR_ACTION_INC, 1,	\
+						1, #reg_name, reg_value);\
+			break;						\
+			case NORTH_B:					\
+				vmc_report_fault(VMC_NORTH_B_##bits,	\
+						amd8131_vmc_lun,		\
+						SENSOR_ACTION_INC, 1,	\
+						1, #reg_name, reg_value);\
+			break;						\
+			case SOUTH_A:					\
+					vmc_report_fault(VMC_SOUTH_A_##bits,	\
+						amd8131_vmc_lun,		\
+						SENSOR_ACTION_INC, 1,	\
+						1, #reg_name, reg_value);\
+			break;						\
+			case SOUTH_B:					\
+				vmc_report_fault(VMC_SOUTH_B_##bits,	\
+						amd8131_vmc_lun,		\
+						SENSOR_ACTION_INC, 1,	\
+						1, #reg_name, reg_value);\
+			break;						\
+			default:					\
+			break;						\
+			}						\
+		}							\
+	}								\
+	while ((0))
+
+#endif	/* _AMD8131_EDAC_VMC_H_ */
+
-- 
1.6.0.3

