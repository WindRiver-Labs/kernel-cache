From e9a9cdbe06a5d4c75c9c6253d16c0395ec84063a Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Sat, 8 Nov 2008 17:57:08 -0500
Subject: [PATCH] EDAC: Add amd8131 chipset support for vMC

Add EDAC vMC wrapper calls and a vMC sensor mappings for amd8131 Maple
chipsets.  This vMC integration is enabled by the CONFIG_EDAC_VMC
kernel configuration.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 drivers/edac/amd8131_edac.c     |  107 ++++++++++++++++++++++++-
 drivers/edac/amd8131_edac_vmc.h |  169 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 275 insertions(+), 1 deletions(-)
 create mode 100644 drivers/edac/amd8131_edac_vmc.h

diff --git a/drivers/edac/amd8131_edac.c b/drivers/edac/amd8131_edac.c
index e78c653..4627605 100644
--- a/drivers/edac/amd8131_edac.c
+++ b/drivers/edac/amd8131_edac.c
@@ -33,7 +33,12 @@
 #include "edac_module.h"
 #include "amd8131_edac.h"
 
-#define AMD8131_EDAC_REVISION	" Ver: 1.0.0 " __DATE__
+#ifdef CONFIG_EDAC_VMC
+#include "edac_vmc.h"
+#include "amd8131_edac_vmc.h"
+#endif
+
+#define AMD8131_EDAC_REVISION	" Ver: 1.1.0 " __DATE__
 #define AMD8131_EDAC_MOD_STR	"amd8131_edac"
 
 static char * const bridge_str[] = {
@@ -69,6 +74,83 @@ static struct amd8131_dev_info amd8131_devices[] = {
 };
 
 
+#ifdef CONFIG_EDAC_VMC
+static int init_vmc_sensors(void)
+{
+	int rc;
+
+	/* Assign a vMC LUN to this chipset */
+	amd8131_vmc_lun = vmc_assign_lun();
+
+#define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id), amd8131_sensor_map,	\
+						amd8131_sensor_names,	\
+						amd8131_vmc_lun, NULL)
+	/* Sensors with default parameters: */
+	rc  = INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_A_MEM_LIMIT_MDPE);
+
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_NORTH_B_MEM_LIMIT_MDPE);
+
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_A_MEM_LIMIT_MDPE);
+
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SOUTH_B_MEM_LIMIT_MDPE);
+#undef INIT_SENSOR_DEFAULT
+
+	return rc;
+}
+
+static void uninit_vmc_sensors(void)
+{
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_DPE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_RSE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_RMA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_RTA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_STA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_A_MEM_LIMIT_MDPE, amd8131_vmc_lun);
+
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_DPE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_RSE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_RMA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_RTA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_STA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_NORTH_B_MEM_LIMIT_MDPE, amd8131_vmc_lun);
+
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_DPE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_RSE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_RMA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_RTA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_STA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_A_MEM_LIMIT_MDPE, amd8131_vmc_lun);
+
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_DPE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_RSE, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_RMA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_RTA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_STA, amd8131_vmc_lun);
+	vmc_sensor_uninit(VMC_SOUTH_B_MEM_LIMIT_MDPE, amd8131_vmc_lun);
+}
+#endif /* CONFIG_EDAC_VMC */
+
+
 /*
  * FIXME: FHDD PCI3_init() would try to setup PMC device for PCI3
  * as well, why? (PCI_DEVICE_ID_MOTOROLA_HARRIER)
@@ -149,6 +231,16 @@ static void amd8131_apic_check(struct edac_device_ctl_info *edac_dev)
 			val32 & MEM_LIMIT_STA,
 			val32 & MEM_LIMIT_MDPE);
 
+#ifdef CONFIG_EDAC_VMC
+		/* Report faults to vMC */
+		REPORT_FAULT(MEM_LIMIT_DPE, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_RSE, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_RMA, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_RTA, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_STA, REG_MEM_LIM, val32, dev_info->inst);
+		REPORT_FAULT(MEM_LIMIT_MDPE, REG_MEM_LIM, val32, dev_info->inst);
+#endif
+
 		val32 |= MEM_LIMIT_MASK;
 		if (pci_write_config_dword(dev, REG_MEM_LIM, val32)) {
 			printk(KERN_ERR "PCI Access Error\n");
@@ -246,6 +338,14 @@ static int amd8131_probe(struct pci_dev *dev, const struct pci_device_id *id)
 
 	dev_info->edac_idx = maple_edac_dev_idx++;
 
+#ifdef CONFIG_EDAC_VMC
+        /* Initialize vMC sensors */
+	if (init_vmc_sensors()) {
+		printk(KERN_ERR "failed to initialize one or more " \
+				"vMC sensors\n");
+	}
+#endif
+
 	printk(KERN_INFO "added one device on AMD8131 "
 		"vendor %x, device %x, devfn %x, name %s\n",
 		PCI_VENDOR_ID_AMD, amd8131_chipset.err_dev,
@@ -258,6 +358,11 @@ static void amd8131_remove(struct pci_dev *dev)
 {
 	struct amd8131_dev_info *dev_info;
 
+#ifdef CONFIG_EDAC_VMC
+	/* Uninitialize vMC sensors */
+	uninit_vmc_sensors();
+#endif
+
 	for (dev_info = amd8131_chipset.devices; dev_info->inst != NO_BRIDGE; dev_info++)
 		if (dev_info->devfn == dev->devfn)
 			break;
diff --git a/drivers/edac/amd8131_edac_vmc.h b/drivers/edac/amd8131_edac_vmc.h
new file mode 100644
index 0000000..dd626d9
--- /dev/null
+++ b/drivers/edac/amd8131_edac_vmc.h
@@ -0,0 +1,169 @@
+/*
+ * amd8131_edac_vmc.h, vMC sensor maps for AMD8131 EDAC driver
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors: Benjamin Walsh (benjamin.walsh@windriver.com)
+ *          Matt Wagantall (matthew.wagantall@windriver.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _AMD8131_EDAC_VMC_H_
+#define _AMD8131_EDAC_VMC_H_
+
+#include "edac_vmc.h"
+#include "amd8131_edac.h"
+
+/* Assign sensor numbers.
+ *   Order is arbitrary */
+enum amd8131_sensors {
+	VMC_NORTH_A_MEM_LIMIT_DPE = 0,
+	VMC_NORTH_A_MEM_LIMIT_RSE,
+	VMC_NORTH_A_MEM_LIMIT_RMA,
+	VMC_NORTH_A_MEM_LIMIT_RTA,
+	VMC_NORTH_A_MEM_LIMIT_STA,
+	VMC_NORTH_A_MEM_LIMIT_MDPE,
+
+	VMC_NORTH_B_MEM_LIMIT_DPE,
+	VMC_NORTH_B_MEM_LIMIT_RSE,
+	VMC_NORTH_B_MEM_LIMIT_RMA,
+	VMC_NORTH_B_MEM_LIMIT_RTA,
+	VMC_NORTH_B_MEM_LIMIT_STA,
+	VMC_NORTH_B_MEM_LIMIT_MDPE,
+
+	VMC_SOUTH_A_MEM_LIMIT_DPE,
+	VMC_SOUTH_A_MEM_LIMIT_RSE,
+	VMC_SOUTH_A_MEM_LIMIT_RMA,
+	VMC_SOUTH_A_MEM_LIMIT_RTA,
+	VMC_SOUTH_A_MEM_LIMIT_STA,
+	VMC_SOUTH_A_MEM_LIMIT_MDPE,
+
+	VMC_SOUTH_B_MEM_LIMIT_DPE,
+	VMC_SOUTH_B_MEM_LIMIT_RSE,
+	VMC_SOUTH_B_MEM_LIMIT_RMA,
+	VMC_SOUTH_B_MEM_LIMIT_RTA,
+	VMC_SOUTH_B_MEM_LIMIT_STA,
+	VMC_SOUTH_B_MEM_LIMIT_MDPE
+};
+
+/* Assign sensor names.
+ * macro usage: name_sensor( name ),
+ *   Order does not matter here */
+#define name_sensor(x) [(x)] = #x
+static const char *amd8131_sensor_names[] = {
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_DPE),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_RSE),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_RMA),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_RTA),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_STA),
+	name_sensor(VMC_NORTH_A_MEM_LIMIT_MDPE),
+
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_DPE),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_RSE),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_RMA),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_RTA),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_STA),
+	name_sensor(VMC_NORTH_B_MEM_LIMIT_MDPE),
+
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_DPE),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_RSE),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_RMA),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_RTA),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_STA),
+	name_sensor(VMC_SOUTH_A_MEM_LIMIT_MDPE),
+
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_DPE),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_RSE),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_RMA),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_RTA),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_STA),
+	name_sensor(VMC_SOUTH_B_MEM_LIMIT_MDPE),
+};
+
+/* Map sensors to vMC IPMI entities.
+ * macro usage: map_sensor(sensor, entity type, entity instance),
+ *   Order does not matter here */
+#define map_sensor(sensor, entity, entity_id) \
+	[(sensor)] = (((entity) << 8) | (entity_id))
+static const int amd8131_sensor_map[] = {
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  0),
+	map_sensor(VMC_NORTH_A_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS, 0),
+
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  1),
+	map_sensor(VMC_NORTH_B_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS, 1),
+
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  2),
+	map_sensor(VMC_SOUTH_A_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS, 2),
+
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_EXPRESS_BUS,  3),
+	map_sensor(VMC_SOUTH_B_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_EXPRESS_BUS, 3)
+};
+
+/* put here instead of C file to modularize with vMC */
+static int amd8131_vmc_lun;
+
+#define REPORT_FAULT(bits, reg_name, reg_value, bridge)			\
+	do {								\
+		if(reg_value & bits) {					\
+			switch(bridge) {				\
+			case NORTH_A:					\
+				vmc_report_fault(VMC_NORTH_A_##bits,	\
+						amd8131_vmc_lun,		\
+						SENSOR_ACTION_INC, 1,	\
+						1, #reg_name, reg_value);\
+			break;						\
+			case NORTH_B:					\
+				vmc_report_fault(VMC_NORTH_B_##bits,	\
+						amd8131_vmc_lun,		\
+						SENSOR_ACTION_INC, 1,	\
+						1, #reg_name, reg_value);\
+			break;						\
+			case SOUTH_A:					\
+					vmc_report_fault(VMC_SOUTH_A_##bits,	\
+						amd8131_vmc_lun,		\
+						SENSOR_ACTION_INC, 1,	\
+						1, #reg_name, reg_value);\
+			break;						\
+			case SOUTH_B:					\
+				vmc_report_fault(VMC_SOUTH_B_##bits,	\
+						amd8131_vmc_lun,		\
+						SENSOR_ACTION_INC, 1,	\
+						1, #reg_name, reg_value);\
+			break;						\
+			default:					\
+			break;						\
+			}						\
+		}							\
+	}								\
+	while ((0))
+
+#endif	/* _AMD8131_EDAC_VMC_H_ */
+
-- 
1.6.0.90.g436ed

