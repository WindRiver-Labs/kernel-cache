From 5143d3e263aac399b9e538b857bc9fd91a96b223 Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Sat, 8 Nov 2008 17:57:07 -0500
Subject: [PATCH] EDAC: Add amd8111 chipset support for vMC

Add EDAC vMC wrapper calls and a vMC sensor mappings for amd8111 Maple
chipsets.  This vMC integration is enabled by the CONFIG_EDAC_VMC
kernel configuration.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 drivers/edac/amd8111_edac.c     |   74 ++++++++++++++++++++++++++++++++++
 drivers/edac/amd8111_edac_vmc.h |   83 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 157 insertions(+), 0 deletions(-)
 create mode 100644 drivers/edac/amd8111_edac_vmc.h

diff --git a/drivers/edac/amd8111_edac.c b/drivers/edac/amd8111_edac.c
index 4e9ac4b..796d17f 100644
--- a/drivers/edac/amd8111_edac.c
+++ b/drivers/edac/amd8111_edac.c
@@ -33,6 +33,11 @@
 #include "edac_module.h"
 #include "amd8111_edac.h"
 
+#ifdef CONFIG_EDAC_VMC
+#include "edac_vmc.h"
+#include "amd8111_edac_vmc.h"
+#endif
+
 #define AMD8111_EDAC_REVISION	" Ver: 1.0.0 " __DATE__
 #define AMD8111_EDAC_MOD_STR	"amd8111_edac"
 
@@ -41,6 +46,46 @@ enum amd8111_bridges {
 	LPC_BRIDGE,
 };
 
+#ifdef CONFIG_EDAC_VMC
+static int init_vmc_sensors(void)
+{
+	int rc;
+
+	/* Assign a vMC LUN to this chipset */
+	amd8111_vmc_lun = vmc_assign_lun();
+
+#define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id), amd8111_sensor_map, \
+						amd8111_sensor_names,	  \
+						amd8111_vmc_lun, NULL)
+	/* Sensors with default parameters: */
+	rc  = INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_MDPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_IO_CTRL_1_LPC_ERR);
+#undef INIT_SENSOR_DEFAULT
+
+	return rc;
+}
+
+
+static void uninit_vmc_sensors(void)
+{
+	vmc_sensor_uninit(VMC_MEM_LIMIT_DPE, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_RSE, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_RMA, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_RTA, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_STA, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_MDPE, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_IO_CTRL_1_LPC_ERR, amd8111_vmc_lun);
+}
+
+
+#endif /* CONFIG_EDAC_VMC */
+
+
 /* device-specific methods for amd8111 PCI Bridge device */
 static void amd8111_pci_bridge_init(struct amd8111_dev_info *dev_info)
 {
@@ -114,6 +159,17 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 			(val32 & MEM_LIMIT_RTA)  != 0,
 			(val32 & MEM_LIMIT_STA)  != 0,
 			(val32 & MEM_LIMIT_MDPE) != 0);
+
+#ifdef CONFIG_EDAC_VMC
+		/* Report faults to vMC */
+		REPORT_FAULT(MEM_LIMIT_DPE, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_RSE, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_RMA, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_RTA, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_STA, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_MDPE, REG_MEM_LIM, val32);
+#endif	/* CONFIG_EDAC_VMC */
+
 		val32 |= MEM_LIMIT_MASK;
 		if (pci_write_config_dword(dev, REG_MEM_LIM, val32)) {
 			printk(KERN_ERR "PCI Access Error\n");
@@ -177,6 +233,11 @@ static void amd8111_lpc_bridge_check(struct edac_device_ctl_info *edac_dev)
 		printk(KERN_INFO "Error(s) in IO control register on %s device\n",
 			dev_info->ctl_name);
 		printk(KERN_INFO "LPC ERR: %d\n", (val8 & IO_CTRL_1_LPC_ERR) != 0);
+
+#ifdef CONFIG_EDAC_VMC
+		REPORT_FAULT(IO_CTRL_1_LPC_ERR, REG_MEM_LIM, val8);
+#endif	/* CONFIG_EDAC_VMC */
+
 		val8 |= IO_CTRL_1_LPC_ERR;
 		if(pci_write_config_byte(dev, REG_IO_CTRL_1, val8)) {
 			printk(KERN_ERR "PCI Access Error\n");
@@ -273,6 +334,14 @@ static int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
 
 	dev_info->edac_idx = maple_edac_dev_idx++;
 
+#ifdef CONFIG_EDAC_VMC
+        /* Initialize vMC sensors */
+	if (init_vmc_sensors()) {
+		printk(KERN_ERR "failed to initialize one or more " \
+				"vMC sensors\n");
+	}
+#endif
+
 	printk(KERN_INFO "added one device on AMD8111 "
 		"vendor %x, device %x, name %s\n",
 		PCI_VENDOR_ID_AMD, dev_info->err_dev,
@@ -285,6 +354,11 @@ static void amd8111_remove(struct pci_dev *dev)
 {
 	struct amd8111_dev_info *dev_info;
 
+#ifdef CONFIG_EDAC_VMC
+	/* Uninitialize vMC sensors */
+	uninit_vmc_sensors();
+#endif
+
 	for (dev_info = amd8111_devices; dev_info->err_dev; dev_info++)
 		if (dev_info->dev->device == dev->device)
 			break;
diff --git a/drivers/edac/amd8111_edac_vmc.h b/drivers/edac/amd8111_edac_vmc.h
new file mode 100644
index 0000000..758c247
--- /dev/null
+++ b/drivers/edac/amd8111_edac_vmc.h
@@ -0,0 +1,83 @@
+/*
+ * amd8111_edac_vmc.h, vMC sensor maps for AMD8111 EDAC driver
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors: Benjamin Walsh (benjamin.walsh@windriver.com)
+ *          Matt Wagantall (matthew.wagantall@windriver.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _AMD8111_EDAC_VMC_H_
+#define _AMD8111_EDAC_VMC_H_
+
+#include "edac_vmc.h"
+
+/* Assign sensor numbers.
+ *   Order is arbitrary */
+enum amd8111_sensors {
+	VMC_MEM_LIMIT_DPE = 0,
+	VMC_MEM_LIMIT_RSE,
+	VMC_MEM_LIMIT_RMA,
+	VMC_MEM_LIMIT_RTA,
+	VMC_MEM_LIMIT_STA,
+	VMC_MEM_LIMIT_MDPE,
+	VMC_IO_CTRL_1_LPC_ERR
+};
+
+/* Assign sensor names.
+ * macro usage: name_sensor( name ),
+ *   Order does not matter here */
+#define name_sensor(x) [(x)] = #x
+static const char *amd8111_sensor_names[] = {
+	name_sensor(VMC_MEM_LIMIT_DPE),
+	name_sensor(VMC_MEM_LIMIT_RSE),
+	name_sensor(VMC_MEM_LIMIT_RMA),
+	name_sensor(VMC_MEM_LIMIT_RTA),
+	name_sensor(VMC_MEM_LIMIT_STA),
+	name_sensor(VMC_MEM_LIMIT_MDPE),
+	name_sensor(VMC_IO_CTRL_1_LPC_ERR)
+};
+
+/* Map sensors to vMC IPMI entities.
+ * macro usage: map_sensor(sensor, entity type, entity instance),
+ *   Order does not matter here */
+#define map_sensor(sensor, entity, entity_inst) \
+	[(sensor)] = (((entity) << 8) | (entity_inst))
+static const int amd8111_sensor_map[] = {
+	map_sensor(VMC_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_IO_CTRL_1_LPC_ERR, IPMI_ENTITY_ID_PCI_BUS, 1)
+};
+
+/* put here instead of C file to modularize with vMC */
+static int amd8111_vmc_lun;
+
+#define REPORT_FAULT(bits, reg_name, reg_value) \
+	do { \
+		if(reg_value & bits) { \
+			vmc_report_fault(VMC_##bits, amd8111_vmc_lun,	\
+					 SENSOR_ACTION_INC, 1, 1,	\
+					 #reg_name, reg_value );	\
+		}							\
+	}								\
+	while ((0))
+
+#endif	/* _AMD8111_EDAC_VMC_H_ */
+
-- 
1.6.0.90.g436ed

