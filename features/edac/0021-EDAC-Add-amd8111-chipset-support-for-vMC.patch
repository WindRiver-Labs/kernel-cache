From 7308166f9b688710ac3ddb315af3790afa1cbdd8 Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Sat, 8 Nov 2008 17:57:07 -0500
Subject: [PATCH] EDAC: Add amd8111 chipset support for vMC

Add EDAC vMC wrapper calls and a vMC sensor mappings for amd8111 Maple
chipsets.  This vMC integration is enabled by the CONFIG_EDAC_VMC
kernel configuration.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 drivers/edac/amd8111_edac.c     |  602 +++++++++++++++++++++++++++++++++++----
 drivers/edac/amd8111_edac.h     |  128 +++++++--
 drivers/edac/amd8111_edac_vmc.h |   83 ++++++
 3 files changed, 739 insertions(+), 74 deletions(-)
 create mode 100644 drivers/edac/amd8111_edac_vmc.h

diff --git a/drivers/edac/amd8111_edac.c b/drivers/edac/amd8111_edac.c
index 85e53a8..6a6a41b 100644
--- a/drivers/edac/amd8111_edac.c
+++ b/drivers/edac/amd8111_edac.c
@@ -33,6 +33,11 @@
 #include "edac_module.h"
 #include "amd8111_edac.h"
 
+#ifdef CONFIG_EDAC_VMC
+#include "edac_vmc.h"
+#include "amd8111_edac_vmc.h"
+#endif
+
 #define AMD8111_EDAC_REVISION	" Ver: 1.0.0 " __DATE__
 #define AMD8111_EDAC_MOD_STR	"amd8111_edac"
 
@@ -41,46 +46,214 @@ enum amd8111_bridges {
 	LPC_BRIDGE,
 };
 
-/* device-specific methods for amd8111 PCI Bridge device */
+#ifdef CONFIG_EDAC_VMC
+static int init_vmc_sensors(void)
+{
+	int rc;
+
+	/* Assign a vMC LUN to this chipset */
+	amd8111_vmc_lun = vmc_assign_lun();
+
+#define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id), amd8111_sensor_map, \
+						amd8111_sensor_names,	  \
+						amd8111_vmc_lun, NULL)
+	/* Sensors with default parameters: */
+	rc  = INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_DPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_RSE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_RMA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_RTA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_STA);
+	rc |= INIT_SENSOR_DEFAULT(VMC_MEM_LIMIT_MDPE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_IO_CTRL_1_LPC_ERR);
+#undef INIT_SENSOR_DEFAULT
+
+	return rc;
+}
+
+
+static void uninit_vmc_sensors(void)
+{
+	vmc_sensor_uninit(VMC_MEM_LIMIT_DPE, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_RSE, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_RMA, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_RTA, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_STA, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_MEM_LIMIT_MDPE, amd8111_vmc_lun);
+	vmc_sensor_uninit(VMC_IO_CTRL_1_LPC_ERR, amd8111_vmc_lun);
+}
+
+
+#endif /* CONFIG_EDAC_VMC */
+
+/*
+ * device-specific methods for amd8111 PCI Bridge device
+ *
+ * Error Reporting and Handling for amd8111 chipset could be found
+ * in its datasheet 3.1.2 section, P37
+ */
 static void amd8111_pci_bridge_init(struct amd8111_dev_info *dev_info)
 {
 	u32 val32;
+	struct pci_dev *dev = dev_info->dev;
+
+	/* First clear error detection flags on the host interface */
 
-	/* First clear all fault on the secondary interface */
-	if (pci_read_config_dword(dev_info->dev, REG_MEM_LIM, &val32)) {
+	/* Clear SSE/SMA/STA flags in the global status register*/
+	if (pci_read_config_dword(dev, REG_PCI_STSCMD, &val32)) {
 		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
-
-	if (val32 & MEM_LIMIT_MASK) {
-		if (pci_write_config_dword(dev_info->dev,
-						REG_MEM_LIM, val32)) {
+	if (val32 & PCI_STSCMD_CLEAR_MASK)
+		if (pci_write_config_dword(dev, REG_PCI_STSCMD, val32)) {
 			printk(KERN_ERR "PCI Access Error\n");
 			return;
 		}
+
+	/* Clear CRC and Link Fail flags in HyperTransport Link Control reg. */
+	if (pci_read_config_dword(dev, REG_HT_LINK, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
 	}
+	if (val32 & HT_LINK_CLEAR_MASK)
+		if (pci_write_config_dword(dev, REG_HT_LINK, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
 
-	if (pci_read_config_dword(dev_info->dev, REG_INT_CTLR, &val32)) {
+	/* Second clear all fault on the secondary interface */
+
+	/* Clear error flags in the memory-base limit reg. */
+	if (pci_read_config_dword(dev, REG_MEM_LIM, &val32)) {
 		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
-	val32 |= INT_CTLR_PERR | INT_CTLR_SERR;
-	if (pci_write_config_dword(dev_info->dev, REG_INT_CTLR, val32))
+	if (val32 & MEM_LIMIT_CLEAR_MASK)
+		if (pci_write_config_dword(dev, REG_MEM_LIM, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+	/* Clear Discard Timer Expired flag in the Interrupt/Bridge Control reg. */
+	if (pci_read_config_dword(dev, REG_PCI_INTBRG_CTRL, &val32)) {
 		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	if (val32 & PCI_INTBRG_CTRL_CLEAR_MASK)
+		if (pci_write_config_dword(dev, REG_PCI_INTBRG_CTRL, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+	/* Last enable error detections */
+	if (edac_op_state == EDAC_OPSTATE_POLL) {
+		/* Enable System Error reporting in global status register */
+		if (pci_read_config_dword(dev, REG_PCI_STSCMD, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 |= PCI_STSCMD_SERREN;
+		if (pci_write_config_dword(dev, REG_PCI_STSCMD, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+		/* Enable CRC Sync flood packets to HyperTransport Link */
+		if (pci_read_config_dword(dev, REG_HT_LINK, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 |= HT_LINK_CRCFEN;
+		if (pci_write_config_dword(dev, REG_HT_LINK, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+		/* Enable System Error reporting and etc in Interrupt control reg. */
+		if (pci_read_config_dword(dev, REG_PCI_INTBRG_CTRL, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 |= PCI_INTBRG_CTRL_POLL_MASK;
+		if (pci_write_config_dword(dev, REG_PCI_INTBRG_CTRL, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+	}
+#ifdef CONFIG_MAPLE_NMI
+	else if (edac_op_state == EDAC_OPSTATE_NMI) {
+		/*
+		 * DevB:0x40[NMIONERR] would be setup separantly,
+		 * we only need to setup DevA:0x3C[PEREN] here.
+		 */
+		if (pci_read_config_dword(dev, REG_PCI_INTBRG_CTRL, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 |= PCI_INTBRG_CTRL_PEREN;
+		if (pci_write_config_dword(dev, REG_PCI_INTBRG_CTRL, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+	}
+#endif
 }
 
 static void amd8111_pci_bridge_exit(struct amd8111_dev_info *dev_info)
 {
 	u32 val32;
+	struct pci_dev *dev = dev_info->dev;
 
-	if (pci_read_config_dword(dev_info->dev, REG_INT_CTLR, &val32)) {
-		printk(KERN_ERR "PCI Access Error\n");
-		return;
-	}
-	val32 &= ~(INT_CTLR_PERR | INT_CTLR_SERR);
-	if (pci_write_config_dword(dev_info->dev, REG_INT_CTLR, val32))
-		printk(KERN_ERR "PCI Access Error\n");
+	if (edac_op_state == EDAC_OPSTATE_POLL) {
+		/* Disable System Error reporting */
+		if (pci_read_config_dword(dev, REG_PCI_STSCMD, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 &= ~PCI_STSCMD_SERREN;
+		if (pci_write_config_dword(dev, REG_PCI_STSCMD, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+		/* Disable CRC flood packets */
+		if (pci_read_config_dword(dev, REG_HT_LINK, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 &= ~HT_LINK_CRCFEN;
+		if (pci_write_config_dword(dev, REG_HT_LINK, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
 
+		/* Disable DTSERREN/MARSP/SERREN in interrupt control register */
+		if (pci_read_config_dword(dev, REG_PCI_INTBRG_CTRL, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 &= ~PCI_INTBRG_CTRL_POLL_MASK;
+		if (pci_write_config_dword(dev, REG_PCI_INTBRG_CTRL, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+	}
+#ifdef CONFIG_MAPLE_NMI
+	else if (edac_op_state == EDAC_OPSTATE_NMI) {
+		/*
+		 * DevB:0x40[NMIONERR] would be cleared separantly,
+		 * we only need to clear DevA:0x3C[PEREN] here.
+		 */
+		if (pci_read_config_dword(dev, REG_PCI_INTBRG_CTRL, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 &= ~PCI_INTBRG_CTRL_PEREN;
+		if (pci_write_config_dword(dev, REG_PCI_INTBRG_CTRL, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+	}
+#endif
 }
 
 static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
@@ -89,12 +262,74 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 	struct pci_dev *dev = dev_info->dev;
 	u32 val32;
 
-	if (pci_read_config_dword(dev, REG_MEM_LIM, &val32)) {
+	/* Check out PCI Bridge Status and Command Register */
+	if (pci_read_config_dword(dev, REG_PCI_STSCMD, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	if (val32 & PCI_STSCMD_CLEAR_MASK) {
+		printk(KERN_INFO "Error(s) in PCI bridge status and command"
+			"register on device %s\n", dev_info->ctl_name);
+		printk(KERN_INFO "SSE: %d, RMA: %d, RTA: %d\n",
+			(val32 & PCI_STSCMD_SSE) != 0,
+			(val32 & PCI_STSCMD_RMA) != 0,
+			(val32 & PCI_STSCMD_RTA) != 0);
+
+		val32 |= PCI_STSCMD_CLEAR_MASK;
+		if (pci_write_config_dword(dev, REG_PCI_STSCMD, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+	}
+
+	/* Check out HyperTransport Link Control Register */
+	if (pci_read_config_dword(dev, REG_HT_LINK, &val32)) {
 		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
+	if (val32 & HT_LINK_LKFAIL) {
+		printk(KERN_INFO "Error(s) in hypertransport link control"
+			"register on device %s\n", dev_info->ctl_name);
+		printk(KERN_INFO "LKFAIL: %d\n",
+			(val32 & HT_LINK_LKFAIL) != 0);
+
+		val32 |= HT_LINK_LKFAIL;
+		if (pci_write_config_dword(dev, REG_HT_LINK, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
 
-	if (val32 & MEM_LIMIT_MASK) {
+		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+	}
+
+	/* Check out PCI Interrupt and Bridge Control Register */
+	if (pci_read_config_dword(dev, REG_PCI_INTBRG_CTRL, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	if (val32 & PCI_INTBRG_CTRL_DTSTAT) {
+		printk(KERN_INFO "Error(s) in PCI interrupt and bridge control"
+			"register on device %s\n", dev_info->ctl_name);
+		printk(KERN_INFO "DTSTAT: %d\n",
+			(val32 & PCI_INTBRG_CTRL_DTSTAT) != 0);
+
+		val32 |= PCI_INTBRG_CTRL_DTSTAT;
+		if (pci_write_config_dword(dev, REG_PCI_INTBRG_CTRL, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+	}
+
+	/* Check out PCI Bridge Memory Base-Limit Register */
+	if (pci_read_config_dword(dev, REG_MEM_LIM, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	if (val32 & MEM_LIMIT_CLEAR_MASK) {
 		printk(KERN_INFO "Error(s) in mem limit register on %s device\n",
 			dev_info->ctl_name);
 		printk(KERN_INFO "DPE: %d, RSE: %d, RMA: %d\n"
@@ -105,7 +340,18 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 			(val32 & MEM_LIMIT_RTA)  != 0,
 			(val32 & MEM_LIMIT_STA)  != 0,
 			(val32 & MEM_LIMIT_MDPE) != 0);
-		val32 |= MEM_LIMIT_MASK;
+
+#ifdef CONFIG_EDAC_VMC
+		/* Report faults to vMC */
+		REPORT_FAULT(MEM_LIMIT_DPE, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_RSE, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_RMA, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_RTA, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_STA, REG_MEM_LIM, val32);
+		REPORT_FAULT(MEM_LIMIT_MDPE, REG_MEM_LIM, val32);
+#endif	/* CONFIG_EDAC_VMC */
+
+		val32 |= MEM_LIMIT_CLEAR_MASK;
 		if (pci_write_config_dword(dev, REG_MEM_LIM, val32)) {
 			printk(KERN_ERR "PCI Access Error\n");
 			return;
@@ -115,41 +361,95 @@ static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
 	}
 }
 
+static struct resource *port61_res;
+static int port61_broken;
+
 /* device-specific methods for amd8111 LPC Bridge device */
 static void amd8111_lpc_bridge_init(struct amd8111_dev_info *dev_info)
 {
 	u8 val8;
+	struct pci_dev *dev = dev_info->dev;
 
-	/* ask to generate an NMI only in NMI mode */
-	if (edac_op_state == EDAC_OPSTATE_POLL)
-		return;
+	/*
+	 * First clear PORT61[SERR, IOCHK] if necessary.
+	 *
+	 * PORT61[SERR, IOCHK] could be NMI sources as well, we place them
+	 * here despite the fact that they belong to fixed I/O space
+	 * rather than DevB.
+	 */
+	port61_res = request_region(PORT61, 1, AMD8111_EDAC_MOD_STR);
+	if (!port61_res)
+		printk(KERN_INFO "%s: failed to request port I/O region "
+			"start %d, len %d\n", __func__, PORT61, 1);
+
+	val8 = __do_inb(PORT61);
+	if (val8 == 0xff) { /* buggy port */
+		printk(KERN_INFO "%s: port %d is buggy, "
+			"not supported by hardware?\n", __func__, PORT61);
+		port61_broken = 1;
+		if (port61_res) {
+			release_region(PORT61, 1);
+			port61_res = NULL;
+		}
+	} else {
+		u8 out8 = 0;
+		if (val8 & PORT_61_SERR)
+			out8 = PORT_61_CLRSERR;
+		if (val8 & PORT_61_IOCHK)
+			out8 |= PORT_61_CLRIOCHK;
+		if (out8 > 0)
+			__do_outb(out8, PORT61);
+	}
 
-	if (pci_read_config_byte(dev_info->dev, REG_IO_CTRL_1, &val8)) {
+	/* Second clear error flags on LPC bridge */
+	if (pci_read_config_byte(dev, REG_IO_CTRL_1, &val8)) {
 		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
-	val8 |= IO_CTRL_1_NMI;
-	if (pci_write_config_byte(dev_info->dev, REG_IO_CTRL_1, val8))
-		printk(KERN_ERR "PCI Access Error\n");
+	if (val8 & IO_CTRL_1_CLEAR_MASK)
+		if (pci_write_config_byte(dev, REG_IO_CTRL_1, val8)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+#ifdef CONFIG_MAPLE_NMI
+	if (edac_op_state == EDAC_OPSTATE_NMI) {
+		/* Enable NMI generation on errors */
+		if (pci_read_config_byte(dev, REG_IO_CTRL_1, &val8)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val8 |= IO_CTRL_1_NMIONERR;
+		if (pci_write_config_byte(dev, REG_IO_CTRL_1, val8)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+	}
+#endif
 }
 
 static void amd8111_lpc_bridge_exit(struct amd8111_dev_info *dev_info)
 {
 	u8 val8;
+	struct pci_dev *dev = dev_info->dev;
 
-	/* stop asking for NMI only in INT mode */
-	if (edac_op_state == EDAC_OPSTATE_POLL)
-		return;
+	if (port61_res)
+		release_region(PORT61, 1);
 
-	/* stop asking to generate an NMI; doesn't hurt even
-	 * if EDAC is not in NMI opstate */
-	if (pci_read_config_byte(dev_info->dev, REG_IO_CTRL_1, &val8)) {
-		printk(KERN_ERR "PCI Access Error\n");
-		return;
+#ifdef CONFIG_MAPLE_NMI
+	if (edac_op_state == EDAC_OPSTATE_NMI) {
+		/* Disable NMI generation on errors */
+		if (pci_read_config_byte(dev, REG_IO_CTRL_1, &val8)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val8 &= ~IO_CTRL_1_NMIONERR;
+		if (pci_write_config_byte(dev, REG_IO_CTRL_1, val8)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
 	}
-	val8 &= ~IO_CTRL_1_NMI;
-	if (pci_write_config_byte(dev_info->dev, REG_IO_CTRL_1, val8))
-		printk(KERN_ERR "PCI Access Error\n");
+#endif
 }
 
 static void amd8111_lpc_bridge_check(struct edac_device_ctl_info *edac_dev)
@@ -158,25 +458,46 @@ static void amd8111_lpc_bridge_check(struct edac_device_ctl_info *edac_dev)
 	struct pci_dev *dev = dev_info->dev;
 	u8 val8;
 
-	if (pci_read_config_byte(dev, REG_MEM_LIM, &val8)) {
+	if (pci_read_config_byte(dev, REG_IO_CTRL_1, &val8)) {
 		printk(KERN_ERR "PCI Access Error\n");
 		return;
 	}
-
-	if (val8 & IO_CTRL_1_MASK) {
+	if (val8 & IO_CTRL_1_CLEAR_MASK) {
 		printk(KERN_INFO "Error(s) in IO control register on %s device\n",
 			dev_info->ctl_name);
-		printk(KERN_INFO "LPC ERR: %d\n", (val8 & IO_CTRL_1_LPC_ERR) != 0);
-		val8 |= IO_CTRL_1_LPC_ERR;
-		if(pci_write_config_byte(dev, REG_IO_CTRL_1, val8)) {
+		printk(KERN_INFO "LPC ERR: %d, PW2LPC: %d\n",
+			(val8 & IO_CTRL_1_LPC_ERR) != 0,
+			(val8 & IO_CTRL_1_PW2LPC) != 0);
+
+#ifdef CONFIG_EDAC_VMC
+		REPORT_FAULT(IO_CTRL_1_LPC_ERR, REG_IO_CTRL_1, val8);
+#endif	/* CONFIG_EDAC_VMC */
+
+		val8 |= IO_CTRL_1_CLEAR_MASK;
+		if (pci_write_config_byte(dev, REG_IO_CTRL_1, val8)) {
 			printk(KERN_ERR "PCI Access Error\n");
 			return;
 		}
 
 		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
 	}
+
+	if (port61_broken == 0) {
+		u8 out8 = 0;
+		val8 = __do_inb(PORT61);
+		if (val8 & PORT_61_SERR)
+			out8 = PORT_61_CLRSERR;
+		if (val8 & PORT_61_IOCHK)
+			out8 |= PORT_61_CLRIOCHK;
+		if (out8 > 0) {
+			__do_outb(out8, PORT61);
+			edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+		}
+	}
 }
 
+static int device_added;
+
 static struct amd8111_dev_info amd8111_devices[] = {
 	[PCI_BRIDGE] = {
 		.err_dev = PCI_DEVICE_ID_AMD_8111_PCI,
@@ -195,6 +516,162 @@ static struct amd8111_dev_info amd8111_devices[] = {
 	{0},
 };
 
+#ifdef CONFIG_MAPLE_NMI
+
+/*
+ * AMD8111 NMI handler - check DevA and DevB to claim any possible NMI instance
+ */
+static void amd8111_handle_nmi(void)
+{
+	struct amd8111_dev_info *dev_info;
+
+	for (dev_info = amd8111_devices; dev_info->err_dev; dev_info++)
+		if (dev_info->check)
+			dev_info->check(dev_info->edac_dev);
+}
+
+/*
+ * According to AMD8111 datasheet 3.4.2.4 section, P45, NMI is controlled
+ * by following equation:
+ *
+ * NMI = ~PORT70[NMIDIS] &
+ * 	(PM48[NMI_NOW]
+ *	| ~PM48[NMI2SMI_EN] &
+ *	(PORT61[SERR] & ~PORT61[CLRSERR]
+ *	| PORT61[IOCHK] & ~PORT61[CLRIOCHK]
+ *	| DevB:0x40[NMIONERR] & [status bits described in section 3.1.2]
+ *	| DevA:0x1C[MDPE] & DevA:0x3C[PEREN]));
+ *
+ * We only need to turn off PORT70[NMIDIS] and PM48[NMI2SMI_EN] here,
+ * and leave the device-related NMI enablement in device-specific methods.
+ *
+ * PM48 register is within the 256-byte System Management I/O Mapped
+ * registers, whose start address is specified by DevB:3x58[PMBASE], and
+ * accessing this I/O region is controlled by DevB:3x41[PMIOEN].
+ */
+static int amd8111_NMI_global_enable(void)
+{
+	u8 val8;
+	u16 val16;
+	u32 val32, mapbase;
+	struct pci_dev *dev = NULL;
+	void __iomem *mmio_vbase;
+
+	/*
+	 * PORT70[NMIDIS] is write-only, and global NMI disablement status
+	 * could be read from DevB:0x41[NMIDIS], so we need to clear
+	 * PORT70[NMIDIS] only when DevB:0x41[NMIDIS] is read 1.
+	 */
+
+	/* 1.1 read from DevB:0x41[NMIDIS] */
+	dev = pci_get_device(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_LPC, NULL);
+	if (!dev) {
+		printk(KERN_ERR "%s: AMD8111 NMI control device not found: "
+			"vendor %x, device %x\n", __func__,
+			PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_LPC);
+		return -ENODEV;
+	}
+
+	if (pci_enable_device(dev)) {
+		pci_dev_put(dev);
+		printk(KERN_ERR "%s: failed to enable: "
+			"vendor %x, device %x\n", __func__,
+			PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_LPC);
+		return -ENODEV;
+	}
+
+	if (pci_read_config_byte(dev, REG_IO_CTRL_2, &val8)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return -EIO;
+	}
+	if (val8 & IO_CTRL_2_NMIDIS) {
+		printk(KERN_INFO "%s: global NMI disable is set "
+			"we need to clear PORT70[NMIDIS]\n", __func__);
+		/*
+		 * 1.2 clear PORT70[NMIDIS]
+		 * Note: port 70~77 has already been requested
+		 */
+		val8 = __do_inb(RTC70);
+		val8 &= ~RTC_70_NMIDIS;
+		__do_outb(val8, RTC70);
+
+		/* 1.3 verify DevB:0x41[NMIDIS] */
+		if (pci_read_config_byte(dev, REG_IO_CTRL_2, &val8) == 0)
+			printk(KERN_INFO "%s: after clear PORT70[NMIDIS], "
+				"DevB:0x41[NMIDIS] is %d\n", __func__,
+				(val8 & IO_CTRL_2_NMIDIS) != 0);
+		else
+			printk(KERN_ERR "PCI Access Error\n");
+	} else
+		printk(KERN_INFO "%s: global NMI is enabled, no need to "
+				"clear PORT70[NMIDIS]\n", __func__);
+	pci_dev_put(dev);
+
+	/* 2.1 map System Management I/O space */
+	dev = pci_get_device(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_SMBUS, NULL);
+	if (!dev) {
+		printk(KERN_ERR "%s: AMD8111 NMI control device not found: "
+			"vendor %x, device %x\n", __func__,
+			PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_SMBUS);
+		return -ENODEV;
+	}
+
+	if (pci_enable_device(dev)) {
+		pci_dev_put(dev);
+		printk(KERN_ERR "%s: failed to enable: "
+			"vendor %x, device %x\n", __func__,
+			PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_SMBUS);
+		return -ENODEV;
+	}
+
+	if (pci_read_config_dword(dev, REG_SYSMAN_IO_SPACE, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return -EIO;
+	}
+	mapbase = val32 & SYSMAN_IO_SPACE_PMBASE;
+	if (!request_mem_region(mapbase, AMD8111_SYSMAN_IO_SIZE,
+				"amd8111_PMxx")) {
+		pci_dev_put(dev);
+		printk(KERN_ERR "%s: failed to request region\n", __func__);
+		return -EBUSY;
+	}
+
+	mmio_vbase = ioremap(mapbase, AMD8111_SYSMAN_IO_SIZE);
+	if (!mmio_vbase) {
+		printk(KERN_ERR "%s: failed to ioremap region: "
+			"address 0x%x, len 0x%x\n", __func__,
+			mapbase, AMD8111_SYSMAN_IO_SIZE);
+		pci_dev_put(dev);
+		return -ENOMEM;
+	}
+
+	/* 2.2 enable System Management I/O space */
+	if (pci_read_config_byte(dev, REG_GEN_CONFIG_2, &val8)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return -EIO;
+	}
+	val8 |= GEN_CONFIG_2_PMIOEN;
+	if (pci_write_config_byte(dev, REG_GEN_CONFIG_2, val8)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return -EIO;
+	}
+
+	/* 2.3 clear PM48[NMI2SMI_EN] if necessary */
+	val16 = in_le16(mmio_vbase + IO_TCO_CTRL_1);
+	if (val16 & IO_TCO_CTRL_1_NMI2SMI_EN) {
+		val16 &= ~IO_TCO_CTRL_1_NMI2SMI_EN;
+		out_le16(mmio_vbase + IO_TCO_CTRL_1, val16);
+	}
+
+	pci_dev_put(dev);
+
+	iounmap(mmio_vbase);
+	release_mem_region(mapbase, AMD8111_SYSMAN_IO_SIZE);
+
+	return 0;
+}
+#endif /* CONFIG_MAPLE_NMI */
+
 static int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	struct amd8111_dev_info *dev_info = &amd8111_devices[id->driver_data];
@@ -237,21 +714,18 @@ static int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	dev_info->edac_dev->ctl_name = dev_info->ctl_name;
 	dev_info->edac_dev->dev_name = dev_info->dev->dev.bus_id;
 
-	/* FIXME: so far we only support POLL mode */
 	if (edac_op_state == EDAC_OPSTATE_POLL)
 		dev_info->edac_dev->edac_check = dev_info->check;
-	else if ((edac_op_state == EDAC_OPSTATE_INT)) {
-		dev_info->irq = dev_info->dev->irq;
+#ifdef CONFIG_MAPLE_NMI
+	else if ((edac_op_state == EDAC_OPSTATE_NMI) && (device_added == 0)) {
 		/*
-		 * instantiate EDAC NMI handler, or
-		 * register interrupt handler
-		 *
-		 * request_irq(dev_info->irq, dev_info->isr,
-				IRQF_DISABLED, "[EDAC] dev_info->ctl_name",
-				dev_info->edac_dev);
+		 * FIXME: install amd8111_handle_nmi() to maple NMI handler
+		 * first, then enable global NMI generation.
 		 */
-	}
 
+		amd8111_NMI_global_enable();
+	}
+#endif
 	if (dev_info->init)
 		dev_info->init(dev_info);
 
@@ -262,6 +736,8 @@ static int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		return -ENODEV;
 	}
 
+	device_added++;
+
 	printk(KERN_INFO "added one device on AMD8111 "
 		"vendor %x, device %x, name %s\n",
 		PCI_VENDOR_ID_AMD, dev_info->err_dev,
@@ -290,6 +766,8 @@ static void amd8111_remove(struct pci_dev *dev)
 		dev_info->exit(dev_info);
 
 	pci_dev_put(dev_info->dev);
+
+	device_added--;
 }
 
 static const struct pci_device_id amd8111_edac_pci_tbl[] = {
@@ -324,11 +802,23 @@ static int __init amd8111_edac_init(void)
 {
 	opstate_init();
 
+#ifdef CONFIG_EDAC_VMC
+        /* Initialize vMC sensors */
+	if (init_vmc_sensors())
+		printk(KERN_ERR	"failed to initialize one or more "
+			"vMC sensors\n");
+#endif
+
 	return pci_register_driver(&amd8111_edac_driver);
 }
 
 static void __exit amd8111_edac_exit(void)
 {
+#ifdef CONFIG_EDAC_VMC
+	/* Uninitialize vMC sensors */
+	uninit_vmc_sensors();
+#endif
+
 	pci_unregister_driver(&amd8111_edac_driver);
 }
 
@@ -340,3 +830,7 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Wind River (http://windriver.com) Benjamin Walsh\n");
 MODULE_DESCRIPTION("AMD8111 hypertransport chip EDAC kernel module");
 
+#ifdef CONFIG_MAPLE_NMI
+module_param(edac_op_state, int, 0644);
+MODULE_PARM_DESC(edac_op_state, "EDAC Error Reporting state: 0=Poll, 1=NMI");
+#endif
diff --git a/drivers/edac/amd8111_edac.h b/drivers/edac/amd8111_edac.h
index 98da95c..5dfd3e0 100644
--- a/drivers/edac/amd8111_edac.h
+++ b/drivers/edac/amd8111_edac.h
@@ -24,44 +24,132 @@
 #ifndef _AMD8111_EDAC_H_
 #define _AMD8111_EDAC_H_
 
-#define REG_MEM_LIM	0x1c
-#define REG_INT_CTLR	0x3c
-#define REG_IO_CTRL_1	0x40
+/************************************************************
+ *	PCI Bridge Status and Command Register, DevA:0x04
+ ************************************************************/
+#define REG_PCI_STSCMD	0x04
+enum pci_stscmd_bits {
+	PCI_STSCMD_SSE		= BIT(30),
+	PCI_STSCMD_RMA		= BIT(29),
+	PCI_STSCMD_RTA		= BIT(28),
+	PCI_STSCMD_SERREN	= BIT(8),
+	PCI_STSCMD_CLEAR_MASK	= (PCI_STSCMD_SSE |
+				   PCI_STSCMD_RMA |
+				   PCI_STSCMD_RTA)
+};
 
-enum int_ctlr_bits {
-	INT_CTLR_PERR = BIT(16),
-	INT_CTLR_SERR = BIT(17)
+/************************************************************
+ *	PCI Bridge Memory Base-Limit Register, DevA:0x1c
+ ************************************************************/
+#define REG_MEM_LIM     0x1c
+enum mem_limit_bits {
+	MEM_LIMIT_DPE   = BIT(31),
+	MEM_LIMIT_RSE   = BIT(30),
+	MEM_LIMIT_RMA   = BIT(29),
+	MEM_LIMIT_RTA   = BIT(28),
+	MEM_LIMIT_STA   = BIT(27),
+	MEM_LIMIT_MDPE  = BIT(24),
+	MEM_LIMIT_CLEAR_MASK  = (MEM_LIMIT_DPE |
+				 MEM_LIMIT_RSE |
+				 MEM_LIMIT_RMA |
+				 MEM_LIMIT_RTA |
+				 MEM_LIMIT_STA |
+				 MEM_LIMIT_MDPE)
 };
 
+/************************************************************
+ *	HyperTransport Link Control Register, DevA:0xc4
+ ************************************************************/
+#define REG_HT_LINK	0xc4
+enum ht_link_bits {
+	HT_LINK_LKFAIL	= BIT(4),
+	HT_LINK_CRCFEN	= BIT(1),
+	HT_LINK_CLEAR_MASK = (HT_LINK_LKFAIL)
+};
+
+/************************************************************
+ *	PCI Bridge Interrupt and Bridge Control, DevA:0x3c
+ ************************************************************/
+#define REG_PCI_INTBRG_CTRL	0x3c
+enum pci_intbrg_ctrl_bits {
+	PCI_INTBRG_CTRL_DTSERREN	= BIT(27),
+	PCI_INTBRG_CTRL_DTSTAT		= BIT(26),
+	PCI_INTBRG_CTRL_MARSP		= BIT(21),
+	PCI_INTBRG_CTRL_SERREN		= BIT(17),
+	PCI_INTBRG_CTRL_PEREN		= BIT(16),
+	PCI_INTBRG_CTRL_CLEAR_MASK	= (PCI_INTBRG_CTRL_DTSTAT),
+	PCI_INTBRG_CTRL_POLL_MASK	= (PCI_INTBRG_CTRL_DTSERREN |
+					   PCI_INTBRG_CTRL_MARSP |
+					   PCI_INTBRG_CTRL_SERREN)
+};
+
+/************************************************************
+ *		I/O Control 1 Register, DevB:0x40
+ ************************************************************/
+#define REG_IO_CTRL_1 0x40
 enum io_ctrl_1_bits {
-	IO_CTRL_1_NMI 		= BIT(7),
+	IO_CTRL_1_NMIONERR	= BIT(7),
 	IO_CTRL_1_LPC_ERR	= BIT(6),
-	IO_CTRL_1_MASK		= IO_CTRL_1_LPC_ERR
+	IO_CTRL_1_PW2LPC	= BIT(1),
+	IO_CTRL_1_CLEAR_MASK	= (IO_CTRL_1_LPC_ERR | IO_CTRL_1_PW2LPC)
 };
 
-enum mem_limit_bits {
-	MEM_LIMIT_DPE 	= BIT(31),
-	MEM_LIMIT_RSE 	= BIT(30),
-	MEM_LIMIT_RMA 	= BIT(29),
-	MEM_LIMIT_RTA 	= BIT(28),
-	MEM_LIMIT_STA	= BIT(27),
-	MEM_LIMIT_MDPE	= BIT(24),
-	MEM_LIMIT_MASK	= (MEM_LIMIT_DPE|MEM_LIMIT_RSE|MEM_LIMIT_RMA|
-				MEM_LIMIT_RTA|MEM_LIMIT_STA|MEM_LIMIT_MDPE)
+#define PORT61	0x61
+enum port_61_bits {
+	PORT_61_SERR		= BIT(7),
+	PORT_61_IOCHK		= BIT(6),
+	PORT_61_CLRIOCHK	= BIT(3),
+	PORT_61_CLRSERR		= BIT(2),
+};
+
+#ifdef CONFIG_MAPLE_NMI
+#define REG_IO_CTRL_2 0x41
+enum io_ctrl_2_bits {
+	IO_CTRL_2_NMIDIS	= BIT(1),
+};
+
+/************************************************************
+ *	System Management Configuration Registers, DevB:3xXX
+ ************************************************************/
+#define REG_GEN_CONFIG_2 0x41
+enum gen_config_2_bits {
+	GEN_CONFIG_2_PMIOEN	= BIT(7),
+};
+
+#define REG_SYSMAN_IO_SPACE 0x58
+enum sysman_io_space_bits {
+	SYSMAN_IO_SPACE_PMBASE = (BIT(15) | BIT(14) | BIT(13) |
+				BIT(12) | BIT(11) | BIT(10) |
+				BIT(9) | BIT(8)),
+};
+
+/************************************************************
+ *	System Management I/O Space, PMxx
+ ************************************************************/
+#define AMD8111_SYSMAN_IO_SIZE 256
+#define IO_TCO_CTRL_1 0x48
+enum io_tco_ctrl_1_bits {
+	IO_TCO_CTRL_1_NMI2SMI_EN	= BIT(9),
+};
+
+/************************************************************
+ *	 Real-Time Clock Port I/O
+ ************************************************************/
+#define RTC70	0x70
+enum rtc_70_bits {
+	RTC_70_NMIDIS		= BIT(7),
 };
+#endif /* CONFIG_MAPLE_NMI */
 
 struct amd8111_dev_info {
 	u16 err_dev;	/* PCI Device ID */
 	struct pci_dev *dev;
 	int edac_idx;	/* device index */
-	int irq;
 	const char *ctl_name;
 	struct edac_device_ctl_info *edac_dev;
 	void (*init)(struct amd8111_dev_info *dev_info);
 	void (*exit)(struct amd8111_dev_info *dev_info);
 	void (*check)(struct edac_device_ctl_info *edac_dev);
-	/*FIXME: do we need register interrupt handler for a PCI device ?*/
-	/* irqreturn_t (*isr)(int irq, void *edac_dev); */
 };
 
 #endif /* _AMD8111_EDAC_H_ */
diff --git a/drivers/edac/amd8111_edac_vmc.h b/drivers/edac/amd8111_edac_vmc.h
new file mode 100644
index 0000000..758c247
--- /dev/null
+++ b/drivers/edac/amd8111_edac_vmc.h
@@ -0,0 +1,83 @@
+/*
+ * amd8111_edac_vmc.h, vMC sensor maps for AMD8111 EDAC driver
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors: Benjamin Walsh (benjamin.walsh@windriver.com)
+ *          Matt Wagantall (matthew.wagantall@windriver.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _AMD8111_EDAC_VMC_H_
+#define _AMD8111_EDAC_VMC_H_
+
+#include "edac_vmc.h"
+
+/* Assign sensor numbers.
+ *   Order is arbitrary */
+enum amd8111_sensors {
+	VMC_MEM_LIMIT_DPE = 0,
+	VMC_MEM_LIMIT_RSE,
+	VMC_MEM_LIMIT_RMA,
+	VMC_MEM_LIMIT_RTA,
+	VMC_MEM_LIMIT_STA,
+	VMC_MEM_LIMIT_MDPE,
+	VMC_IO_CTRL_1_LPC_ERR
+};
+
+/* Assign sensor names.
+ * macro usage: name_sensor( name ),
+ *   Order does not matter here */
+#define name_sensor(x) [(x)] = #x
+static const char *amd8111_sensor_names[] = {
+	name_sensor(VMC_MEM_LIMIT_DPE),
+	name_sensor(VMC_MEM_LIMIT_RSE),
+	name_sensor(VMC_MEM_LIMIT_RMA),
+	name_sensor(VMC_MEM_LIMIT_RTA),
+	name_sensor(VMC_MEM_LIMIT_STA),
+	name_sensor(VMC_MEM_LIMIT_MDPE),
+	name_sensor(VMC_IO_CTRL_1_LPC_ERR)
+};
+
+/* Map sensors to vMC IPMI entities.
+ * macro usage: map_sensor(sensor, entity type, entity instance),
+ *   Order does not matter here */
+#define map_sensor(sensor, entity, entity_inst) \
+	[(sensor)] = (((entity) << 8) | (entity_inst))
+static const int amd8111_sensor_map[] = {
+	map_sensor(VMC_MEM_LIMIT_DPE, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_RSE, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_RMA, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_RTA, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_STA, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_MEM_LIMIT_MDPE, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_IO_CTRL_1_LPC_ERR, IPMI_ENTITY_ID_PCI_BUS, 1)
+};
+
+/* put here instead of C file to modularize with vMC */
+static int amd8111_vmc_lun;
+
+#define REPORT_FAULT(bits, reg_name, reg_value) \
+	do { \
+		if(reg_value & bits) { \
+			vmc_report_fault(VMC_##bits, amd8111_vmc_lun,	\
+					 SENSOR_ACTION_INC, 1, 1,	\
+					 #reg_name, reg_value );	\
+		}							\
+	}								\
+	while ((0))
+
+#endif	/* _AMD8111_EDAC_VMC_H_ */
+
-- 
1.6.0.3

