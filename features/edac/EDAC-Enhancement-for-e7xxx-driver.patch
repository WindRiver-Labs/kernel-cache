From 7a7eb4eb64ce2fedaf81523635e299b6f4d9ff02 Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Wed, 28 Apr 2010 02:49:11 -0700
Subject: [PATCH] EDAC: Enhancement for e7xxx driver

The following was implemented for e7xxx EDAC driver:

1. Implement a framework to facilitate adding extra new devices
   to EDAC. With the help of it, only device-specific
   initialization and checking routines and interrupt handler
   are needed, plus one data structure to glue them together.

2. Supply e7xxx EDAC driver to make use of HIA_FERR & SYSBUS_FERR
   on MCH. Related PCI Configuration Registers would be monitored
   by EDAC and user could get each of their error counters via
   sysfs.

3. Supply e7xxx EDAC driver with three more PCI Configuration
   Registers of HIB_FERR, HIC_FERR and HID_FERR for Hub
   Interfaces of D2F1, D3F1, D4F1 respectively. These registers
   could be checked by polling or via NMI handler, and user could
   get each of their error counters via sysfs.

Signed-off-by: Jason HU <yongqi.hu@windriver.com>
---
 arch/x86/kernel/traps.c      |   31 +++
 drivers/edac/e7xxx_edac.c    |  587 ++++++++++++++++++++++++++++++++++++++++--
 drivers/edac/edac_core.h     |    2 +
 drivers/edac/edac_mc_sysfs.c |   14 +
 4 files changed, 614 insertions(+), 20 deletions(-)

diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index 94b604b..204b756 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -359,6 +359,16 @@ io_check_error(unsigned char reason, struct pt_regs *regs)
 	outb(reason, 0x61);
 }
 
+#ifdef CONFIG_X86_32
+#ifdef CONFIG_EDAC
+void (*edac_handle_nmi)(void) = NULL;
+EXPORT_SYMBOL(edac_handle_nmi);
+
+DEFINE_SPINLOCK(edac_nmi_lock);
+EXPORT_SYMBOL(edac_nmi_lock);
+#endif
+#endif
+
 static notrace __kprobes void
 unknown_nmi_error(unsigned char reason, struct pt_regs *regs)
 {
@@ -375,6 +385,27 @@ unknown_nmi_error(unsigned char reason, struct pt_regs *regs)
 		return;
 	}
 #endif
+
+#ifdef CONFIG_X86_32
+#ifdef CONFIG_EDAC
+	if (edac_handler_set()) {
+		/*
+ 		 * this NMI instance might have preempted EDAC module's 
+ 		 * init or exit routine when setting up edac_handle_nmi 
+ 		 * on the same cpu, and we can't block here.
+ 		 */ 
+		if (spin_trylock(&edac_nmi_lock)) {
+			if (edac_handle_nmi) {
+				edac_handle_nmi();
+				spin_unlock(&edac_nmi_lock);
+				return;
+			}
+			spin_unlock(&edac_nmi_lock);
+		}
+	}
+#endif
+#endif
+
 	printk(KERN_EMERG
 		"Uhhuh. NMI received for unknown reason %02x on CPU %d.\n",
 			reason, smp_processor_id());
diff --git a/drivers/edac/e7xxx_edac.c b/drivers/edac/e7xxx_edac.c
index 1731d72..d4c3167 100644
--- a/drivers/edac/e7xxx_edac.c
+++ b/drivers/edac/e7xxx_edac.c
@@ -18,6 +18,11 @@
  *	That One Guy (Some other place)
  *	Wang Zhenyu (intel.com)
  *
+ * Additions for the HIA_FERR, SYSBUS_FERR for E7501 D0F1 device,
+ * HIB, HIC, HID for E7501 D2F1, D3F1, D4F1 devices respectively.
+ * added by Cao Qingtao <qingtao.cao@windriver.com>,
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
  * $Id: edac_e7xxx.c,v 1.5.2.9 2005/10/05 00:43:44 dsp_llnl Exp $
  *
  */
@@ -27,6 +32,7 @@
 #include <linux/pci.h>
 #include <linux/pci_ids.h>
 #include <linux/edac.h>
+#include <linux/spinlock.h>
 #include "edac_core.h"
 
 #define	E7XXX_REVISION " Ver: 2.0.2 " __DATE__
@@ -58,10 +64,6 @@
 #define PCI_DEVICE_ID_INTEL_7501_0	0x254c
 #endif				/* PCI_DEVICE_ID_INTEL_7501_0 */
 
-#ifndef PCI_DEVICE_ID_INTEL_7501_1_ERR
-#define PCI_DEVICE_ID_INTEL_7501_1_ERR	0x2541
-#endif				/* PCI_DEVICE_ID_INTEL_7501_1_ERR */
-
 #ifndef PCI_DEVICE_ID_INTEL_7505_0
 #define PCI_DEVICE_ID_INTEL_7505_0	0x2550
 #endif				/* PCI_DEVICE_ID_INTEL_7505_0 */
@@ -70,6 +72,88 @@
 #define PCI_DEVICE_ID_INTEL_7505_1_ERR	0x2551
 #endif				/* PCI_DEVICE_ID_INTEL_7505_1_ERR */
 
+/* E7501 Device ID */
+#define PCI_DEVICE_ID_INTEL_E7501_HIA			0x2541
+#define PCI_DEVICE_ID_INTEL_E7501_HIB_ERROR_REPORT	0x2544
+#define PCI_DEVICE_ID_INTEL_E7501_HIC_ERROR_REPORT	0x2546
+#define PCI_DEVICE_ID_INTEL_E7501_HID_ERROR_REPORT	0x2548
+
+/*************************************************************
+ *        South Bridge Registers HI_A (Device 0, Function 1) *       
+ *************************************************************/
+#define E7501_South_Bridge_HIA_PCICMD		0x04
+#define E7501_South_Bridge_HIA_HIA_FERR		0x50
+#define E7501_South_Bridge_HIA_HIA_NERR		0x52
+#define E7501_South_Bridge_HIA_SERRCMD_HIA	0x5C
+#define E7501_South_Bridge_HIA_SYSBUS_FERR	0x60
+#define E7501_South_Bridge_HIA_SYSBUS_NERR	0x62
+#define E7501_South_Bridge_HIA_SERRCMD_SYSBUS	0x6C
+#define E7501_South_Bridge_HIA_SERRCMD_DRAM	0x8C
+
+/*************************************************************
+ * 		E7501 HIA_FERR/NERR Definitions		     *
+ *************************************************************/
+#define E7501_HIA_FERR_TargetAbort	(1 << 6)
+#define E7501_HIA_FERR_DataParityErr	(1 << 4)
+#define E7501_HIA_FERR_AddrCmdParityErr	(1)
+#define E7501_HIA_FERR_MASK	(E7501_HIA_FERR_TargetAbort | \
+				E7501_HIA_FERR_DataParityErr | \
+				E7501_HIA_FERR_AddrCmdParityErr)
+
+#define E7501_HIA_SERRCMD_MASK	E7501_HIA_FERR_MASK
+
+/*************************************************************
+ * 		E7501 SYSBUS_FERR/NERR Definitions	     *
+ *************************************************************/
+#define E7501_SYSBUS_FERR_BINIT		(1 << 7)
+#define E7501_SYSBUS_FERR_XERR		(1 << 6)
+#define E7501_SYSBUS_FERR_NDLOCK	(1 << 5)
+#define E7501_SYSBUS_FERR_SBATOM	(1 << 4)
+#define E7501_SYSBUS_FERR_SBDPAR	(1 << 3)
+#define E7501_SYSBUS_FERR_SBAGL		(1 << 2)
+#define E7501_SYSBUS_FERR_SBDGL		(1 << 1)
+#define E7501_SYSBUS_FERR_SBRPAR	(1)
+#define E7501_SYSBUS_FERR_MASK	(E7501_SYSBUS_FERR_BINIT | \
+				E7501_SYSBUS_FERR_XERR | \
+				E7501_SYSBUS_FERR_NDLOCK | \
+				E7501_SYSBUS_FERR_SBATOM | \
+				E7501_SYSBUS_FERR_SBDPAR | \
+				E7501_SYSBUS_FERR_SBAGL | \
+				E7501_SYSBUS_FERR_SBDGL | \
+				E7501_SYSBUS_FERR_SBRPAR)
+
+#define E7501_SYSBUS_SERRCMD_MASK	E7501_SYSBUS_FERR_MASK
+
+/*************************************************************
+ *	E7501 PCI Bridges Registers 			     *
+ *	  HI_B ERROR REPORTING (Device 2, Function 1) 	     *       
+ *        HI_C ERROR REPORTING (Device 3, Function 1) 	     *       
+ *        HI_D ERROR REPORTING (Device 4, Function 1) 	     *       
+ *************************************************************/
+#define E7501_HI_ERROR_REPORT_PCICMD		0x04
+#define E7501_HI_ERROR_REPORT_FERR		0x80
+#define E7501_HI_ERROR_REPORT_NERR		0x82
+#define E7501_HI_ERROR_REPORT_SERRCMD		0xA0
+
+/*************************************************************
+ *	E7501 Hub Interface SERRCMD Definitions	     	     *
+ *************************************************************/
+#define E7501_HI_SERRCMD_MasterAbort	(1 << 5)
+#define E7501_HI_SERRCMD_TargetAbort	(1 << 4)
+#define E7501_HI_SERRCMD_CEHeaderAddr	(1 << 3)
+#define E7501_HI_SERRCMD_CEDataTrans	(1 << 2)
+#define E7501_HI_SERRCMD_UEHeaderAddr	(1 << 1)
+#define E7501_HI_SERRCMD_UEDataTrans	(1)
+#define E7501_HI_SERRCMD_MASK	(E7501_HI_SERRCMD_MasterAbort | \
+				E7501_HI_SERRCMD_TargetAbort | \
+				E7501_HI_SERRCMD_CEHeaderAddr | \
+				E7501_HI_SERRCMD_CEDataTrans | \
+				E7501_HI_SERRCMD_UEHeaderAddr | \
+				E7501_HI_SERRCMD_UEDataTrans)
+
+/* bit6 is a global flag if MCH received any SERR from HI */
+#define E7501_HI_FERR_MASK (E7501_HI_SERRCMD_MASK | (1 << 6))
+
 #define E7XXX_NR_CSROWS		8	/* number of csrows */
 #define E7XXX_NR_DIMMS		8	/* FIXME - is this correct? */
 
@@ -122,6 +206,7 @@ enum e7xxx_chips {
 	E7205,
 };
 
+/* attributes for Intel MCH D0F0 itself */
 struct e7xxx_pvt {
 	struct pci_dev *bridge_ck;
 	u32 tolm;
@@ -130,34 +215,174 @@ struct e7xxx_pvt {
 	const struct e7xxx_dev_info *dev_info;
 };
 
+/* 
+ * attributes for a common device,
+ * this private structure would be connected to relevant
+ * edac_device_ctl_info by its pvt_info pointer.
+ */
 struct e7xxx_dev_info {
-	u16 err_dev;
+	u16 err_dev; /* PCI Device ID */
 	const char *ctl_name;
+	int edac_idx; /* device index */
+	struct pci_dev *dev;
+	struct edac_device_ctl_info *edac_dev;
+	void (*init)(struct e7xxx_dev_info *dev_info);
+	void (*exit)(struct e7xxx_dev_info *dev_info);
+	void (*check)(struct edac_device_ctl_info *edac_dev);
 };
 
+/* attributes for Intel MCH D0F1 device */
 struct e7xxx_error_info {
 	u8 dram_ferr;
 	u8 dram_nerr;
 	u32 dram_celog_add;
 	u16 dram_celog_syndrome;
 	u32 dram_uelog_add;
+	u8 hia_ferr;
+	u8 hia_nerr;
+	u8 sysbus_ferr;
+	u8 sysbus_nerr;
 };
 
 static struct edac_pci_ctl_info *e7xxx_pci;
+static struct e7xxx_dev_info *e7xxx_device;
+
+static struct e7xxx_dev_info e7500_devs[] = {
+	/* The first element must be the memory controller device */
+	{
+                .err_dev = PCI_DEVICE_ID_INTEL_7500_1_ERR,
+                .ctl_name = "E7500"
+	},
+	/* All the rest devices on e7500 chipset should go here */
+	{0},	/* Terminated by NULL */
+};
+
+static struct e7xxx_dev_info e7505_devs[] = {
+	/* The first element must be the memory controller device */
+        {
+                .err_dev = PCI_DEVICE_ID_INTEL_7505_1_ERR,
+                .ctl_name = "E7505"
+        },
+	/* All the rest devices on e7505 chipset should go here */
+        {0},	/* Terminated by NULL */
+};
+
+static struct e7xxx_dev_info e7205_devs[] = {
+	/* The first element must be the memory controller device */
+        {
+                .err_dev = PCI_DEVICE_ID_INTEL_7205_1_ERR,
+                .ctl_name = "E7205"
+        },
+	/* All the rest devices on e7205 chipset should go here */
+        {0},	/* Terminated by NULL */
+};
+
+static void e7501_hiX_err_init(struct e7xxx_dev_info *dev_info)
+{
+	u16 word;
+	u8 byte;
+
+	/* clear HI_FERR and HI_NERR */
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, &byte);
+	pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, byte);
+
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, &byte);
+	pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, byte);
+
+	/* only enable SERR in INT mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		return;
+
+	pci_read_config_word(dev_info->dev, E7501_HI_ERROR_REPORT_PCICMD, &word);
+	word |=  1 << 8; /* SERR global enable */
+	pci_write_config_word(dev_info->dev, E7501_HI_ERROR_REPORT_PCICMD, word);
+
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_SERRCMD, &byte);
+	byte |= E7501_HI_SERRCMD_MASK;
+	pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_SERRCMD, byte);
+}
+
+static void e7501_hiX_err_exit(struct e7xxx_dev_info *dev_info)
+{
+	u16 word;
+	u8 byte;
+
+	/* only need to clear SERR in "INT" mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		return;
+
+	pci_read_config_word(dev_info->dev, E7501_HI_ERROR_REPORT_PCICMD, &word);
+	if (word & (1 << 8)) { /* clear SERR */
+		word &= ~(1 << 8);
+		pci_write_config_word(dev_info->dev, 
+				      E7501_HI_ERROR_REPORT_PCICMD, word);
+	}
+
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_SERRCMD, &byte);
+	if (byte & E7501_HI_SERRCMD_MASK) {
+		byte &= ~E7501_HI_SERRCMD_MASK;
+		pci_write_config_byte(dev_info->dev, 
+				      E7501_HI_ERROR_REPORT_SERRCMD, byte);
+	}
+}
+
+static void e7501_hiX_err_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct e7xxx_dev_info *dev_info = edac_dev->pvt_info;
+	u8 ferr = 0, nerr = 0;
+
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, &ferr);
+	pci_read_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, &nerr);
+	ferr &= E7501_HI_FERR_MASK;
+	nerr &= E7501_HI_FERR_MASK;
+	if (!ferr && !nerr ) 
+		return;
+
+	/* only reset the bits we are interested in */
+	if (ferr)
+		pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_FERR, ferr);
+	if (nerr)
+		pci_write_config_byte(dev_info->dev, E7501_HI_ERROR_REPORT_NERR, nerr);
 
-static const struct e7xxx_dev_info e7xxx_devs[] = {
-	[E7500] = {
-		.err_dev = PCI_DEVICE_ID_INTEL_7500_1_ERR,
-		.ctl_name = "E7500"},
-	[E7501] = {
-		.err_dev = PCI_DEVICE_ID_INTEL_7501_1_ERR,
-		.ctl_name = "E7501"},
-	[E7505] = {
-		.err_dev = PCI_DEVICE_ID_INTEL_7505_1_ERR,
-		.ctl_name = "E7505"},
-	[E7205] = {
-		.err_dev = PCI_DEVICE_ID_INTEL_7205_1_ERR,
-		.ctl_name = "E7205"},
+	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+}
+static struct e7xxx_dev_info e7501_devs[] = {
+	/* The first element must be the memory controller device */
+	{
+		.err_dev = PCI_DEVICE_ID_INTEL_E7501_HIA,
+		.ctl_name = "E7501 Host RASUM Controller"
+	},
+	/* All the rest devices on e7501 chipset should go here */
+	{
+		.err_dev = PCI_DEVICE_ID_INTEL_E7501_HIB_ERROR_REPORT,
+		.ctl_name = "hib",
+		.init = e7501_hiX_err_init,
+		.exit = e7501_hiX_err_exit,
+		.check = e7501_hiX_err_check,
+	},
+	{
+		.err_dev = PCI_DEVICE_ID_INTEL_E7501_HIC_ERROR_REPORT,
+		.ctl_name = "hic",
+		.init = e7501_hiX_err_init,
+		.exit = e7501_hiX_err_exit,
+		.check = e7501_hiX_err_check,
+	},      
+	{
+		.err_dev = PCI_DEVICE_ID_INTEL_E7501_HID_ERROR_REPORT,
+		.ctl_name = "hid",
+		.init = e7501_hiX_err_init,
+		.exit = e7501_hiX_err_exit,
+		.check = e7501_hiX_err_check,
+	}, 
+	{0},	/* Terminated by NULL */
+};
+
+/* all edac devices on a e7xxx chipset */
+static struct e7xxx_dev_info *e7xxx_devs[] = {
+        [E7500] = e7500_devs,
+        [E7501] = e7501_devs,
+        [E7505] = e7505_devs,
+        [E7205] = e7205_devs,
 };
 
 /* FIXME - is this valid for both SECDED and S4ECD4ED? */
@@ -244,6 +469,62 @@ static void process_ue_no_info(struct mem_ctl_info *mci)
 	debugf3("%s()\n", __func__);
 	edac_mc_handle_ue_no_info(mci, "e7xxx UE log register overflow");
 }
+#define HUB_ERR_MSG_NUM		7
+static char *hub_message[HUB_ERR_MSG_NUM] = {
+	[0] = "Address or Command Parity", 
+	[1] = NULL,	/* reserved */
+	[2] = NULL,	/* reserved */
+	[3] = NULL,	/* reserved */
+	[4] = "Data Parity", 
+	[5] = NULL,	/* reserved */
+	[6] = "Target Abort"
+};
+
+static void process_hub_error(struct mem_ctl_info *mci,
+			      struct e7xxx_error_info *info)
+{
+	int i;
+	u8 error = info->hia_ferr | info->hia_nerr;
+
+	for (i = 0; i < HUB_ERR_MSG_NUM; i++) {
+		if (!hub_message[i])
+			continue;
+
+		if (error & (1 << i))
+			edac_mc_printk(mci, KERN_WARNING, "Error Hub Interface: %s\n",
+				hub_message[i]);
+	}
+
+
+}
+
+#define SYSBUS_ERR_MSG_NUM	8
+static char *sysbus_message[SYSBUS_ERR_MSG_NUM] = {
+	[0] = "Addr or Request Parity",
+	[1] = "Data Strobe Glitch",
+	[2] = "Addr Strobe Glitch",
+	[3] = "Data Parity",
+	[4] = "Addr Above TOM",
+	[5] = "Non DRAM Lock Error",
+	[6] = "MCERR", 
+	[7] = "BINIT"
+};
+
+static void process_sysbus_error(struct mem_ctl_info *mci,
+				 struct e7xxx_error_info *info)
+{
+	int i;
+	u8 error = info->sysbus_ferr | info->sysbus_nerr;
+
+	mci->sysbus_err_count++;
+
+	for (i = 0; i < SYSBUS_ERR_MSG_NUM; i++) {
+		if (error & (1 << i))		
+			edac_mc_printk(mci, KERN_WARNING, "Error System Bus: %s\n",
+				       sysbus_message[i]);
+	}
+
+}
 
 static void e7xxx_get_error_info(struct mem_ctl_info *mci,
 				 struct e7xxx_error_info *info)
@@ -254,6 +535,16 @@ static void e7xxx_get_error_info(struct mem_ctl_info *mci,
 	pci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_FERR, &info->dram_ferr);
 	pci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_NERR, &info->dram_nerr);
 
+	pci_read_config_byte(pvt->bridge_ck, E7501_South_Bridge_HIA_HIA_FERR, 
+			     &info->hia_ferr);
+	pci_read_config_byte(pvt->bridge_ck, E7501_South_Bridge_HIA_HIA_NERR, 
+			     &info->hia_nerr);
+
+	pci_read_config_byte(pvt->bridge_ck, E7501_South_Bridge_HIA_SYSBUS_FERR, 
+			     &info->sysbus_ferr);
+	pci_read_config_byte(pvt->bridge_ck, E7501_South_Bridge_HIA_SYSBUS_NERR, 
+			     &info->sysbus_nerr);
+
 	if ((info->dram_ferr & 1) || (info->dram_nerr & 1)) {
 		pci_read_config_dword(pvt->bridge_ck, E7XXX_DRAM_CELOG_ADD,
 				&info->dram_celog_add);
@@ -271,6 +562,26 @@ static void e7xxx_get_error_info(struct mem_ctl_info *mci,
 
 	if (info->dram_nerr & 3)
 		pci_write_bits8(pvt->bridge_ck, E7XXX_DRAM_NERR, 0x03, 0x03);
+
+	if (info->hia_ferr & E7501_HIA_FERR_MASK)
+		pci_write_config_byte(pvt->bridge_ck, 
+				      E7501_South_Bridge_HIA_HIA_FERR, 
+				      E7501_HIA_FERR_MASK);
+
+	if (info->hia_nerr & E7501_HIA_FERR_MASK)
+		pci_write_config_byte(pvt->bridge_ck, 
+				      E7501_South_Bridge_HIA_HIA_NERR,
+				      E7501_HIA_FERR_MASK);
+
+	if (info->sysbus_ferr & E7501_SYSBUS_FERR_MASK)
+		pci_write_config_byte(pvt->bridge_ck, 
+				      E7501_South_Bridge_HIA_SYSBUS_FERR, 
+				      E7501_SYSBUS_FERR_MASK);
+
+	if (info->sysbus_nerr & E7501_SYSBUS_FERR_MASK)
+		pci_write_config_byte(pvt->bridge_ck, 
+				      E7501_South_Bridge_HIA_SYSBUS_NERR,
+				      E7501_SYSBUS_FERR_MASK);
 }
 
 static int e7xxx_process_error_info(struct mem_ctl_info *mci,
@@ -318,6 +629,22 @@ static int e7xxx_process_error_info(struct mem_ctl_info *mci,
 		}
 	}
 
+	if ((info->hia_ferr & E7501_HIA_FERR_MASK) || 
+	    (info->hia_nerr & E7501_HIA_FERR_MASK)) {
+		error_found = 1;
+
+		if (handle_errors) 
+			process_hub_error(mci, info);
+	}
+
+	if ((info->sysbus_ferr & E7501_SYSBUS_FERR_MASK) || 
+	    (info->sysbus_nerr & E7501_SYSBUS_FERR_MASK)) {
+		error_found = 1;
+
+		if (handle_errors)
+			process_sysbus_error(mci, info);
+	}
+
 	return error_found;
 }
 
@@ -402,6 +729,183 @@ static void e7xxx_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,
 	}
 }
 
+extern void (*edac_handle_nmi)(void);
+extern spinlock_t edac_nmi_lock;
+static void e7xxx_handle_nmi(void);
+static int device_added = 0;	
+
+static void e7xxx_add_edac_devices(void)
+{
+	struct e7xxx_dev_info *dev_info;
+
+	/* 
+ 	 * Start at 1 to skip the memory controller device
+ 	 * e7xxx_device has been setup pointing to the array of 
+ 	 * e7xxx_dev_info structure for the current e7xxx chipset
+ 	 * in e7xxx_probe1().
+ 	 */
+	for (dev_info = &e7xxx_device[1]; dev_info->err_dev; dev_info++) {
+		/* sanity check */
+		if (!dev_info->check)
+			continue;
+
+		dev_info->dev = pci_get_device(PCI_VENDOR_ID_INTEL, 
+					       dev_info->err_dev, NULL); 
+		if (!dev_info->dev) {
+			e7xxx_printk(KERN_INFO, "error reporting device not found:"
+				"vendor %x device 0x%x name %s\n",
+				PCI_VENDOR_ID_INTEL, dev_info->err_dev, 
+				dev_info->ctl_name);
+			continue;
+		}
+
+		if (pci_enable_device(dev_info->dev)) {
+			pci_dev_put(dev_info->dev);
+			e7xxx_printk(KERN_ERR, "failed to enable:"
+				"vendor %x device 0x%x name %s\n",
+	                 	PCI_VENDOR_ID_INTEL, dev_info->err_dev, 
+				dev_info->ctl_name);
+			continue;
+		}
+
+		/*
+ 		 * we do not allocate extra private structure for 
+ 		 * edac_device_ctl_info, but make use of existing 
+ 		 * e7xxx_device instead. 
+ 		 */
+		dev_info->edac_idx = edac_device_alloc_index();
+		dev_info->edac_dev = 
+		edac_device_alloc_ctl_info(0, dev_info->ctl_name, 1,
+	    				   NULL, 0, 0, 
+					   NULL, 0, dev_info->edac_idx);
+		if (!dev_info->edac_dev)
+			break;	/* pointless to continue when -ENOMEM */
+
+		dev_info->edac_dev->pvt_info = dev_info;
+		dev_info->edac_dev->dev = &dev_info->dev->dev;
+		dev_info->edac_dev->mod_name = EDAC_MOD_STR;
+		dev_info->edac_dev->ctl_name = dev_info->ctl_name;
+		dev_info->edac_dev->dev_name = dev_name(&(dev_info->dev->dev));
+
+		if (edac_op_state == EDAC_OPSTATE_POLL)
+			dev_info->edac_dev->edac_check = dev_info->check;
+		else if ((edac_op_state == EDAC_OPSTATE_NMI) &&
+						(!device_added)) {
+			unsigned long flags;
+			spin_lock_irqsave(&edac_nmi_lock, flags);
+			edac_handle_nmi = e7xxx_handle_nmi;
+			spin_unlock_irqrestore(&edac_nmi_lock, flags);
+		}
+					
+		if (dev_info->init)
+			dev_info->init(dev_info);
+
+		if (edac_device_add_device(dev_info->edac_dev) > 0) {
+			debugf0("%s(): failed edac_device_add_device()"
+				"for %s\n", __func__, dev_info->ctl_name);
+			edac_device_free_ctl_info(dev_info->edac_dev);
+			continue;
+		}
+
+		device_added++;
+	}
+
+	debugf0("%s(): added %d devices on E7501\n", __func__, device_added);
+}
+
+/*
+ * e7xxx NMI handler
+ *
+ * traverse all devices of a e7xxx chipset to claim current NMI instance.
+ */
+static void e7xxx_handle_nmi(void)
+{
+	struct e7xxx_dev_info *dev_info;
+
+	/* start at 1 to skip memory controller device */
+	for (dev_info = &e7xxx_device[1]; dev_info->err_dev; dev_info++)
+		if (dev_info->check)
+			dev_info->check(dev_info->edac_dev);		
+}
+
+static void e7xxx_D0F1_init(struct pci_dev *dev)
+{
+	u8 byte;
+	u16 word;
+
+	/* clear up all FERR/NERR registers */
+        pci_read_config_byte(dev, E7XXX_DRAM_FERR, &byte);
+        pci_write_config_byte(dev, E7XXX_DRAM_FERR, byte);
+
+        pci_read_config_byte(dev, E7XXX_DRAM_NERR, &byte);
+        pci_write_config_byte(dev, E7XXX_DRAM_NERR, byte);
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_HIA_FERR, &byte);
+        pci_write_config_byte(dev, E7501_South_Bridge_HIA_HIA_FERR, byte);
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_HIA_NERR, &byte);
+        pci_write_config_byte(dev, E7501_South_Bridge_HIA_HIA_NERR, byte);
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_SYSBUS_FERR, &byte);
+        pci_write_config_byte(dev, E7501_South_Bridge_HIA_SYSBUS_FERR, byte);
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_SYSBUS_NERR, &byte);
+        pci_write_config_byte(dev, E7501_South_Bridge_HIA_SYSBUS_NERR, byte);
+
+	/* setup SERR enable bit only in INT mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		return;
+
+	pci_read_config_word(dev, E7501_South_Bridge_HIA_PCICMD, &word);
+	word |= 1 << 8; /* SERR */
+	pci_write_config_word(dev, E7501_South_Bridge_HIA_PCICMD, word);
+
+	pci_read_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_DRAM, &byte);
+	byte |=  1 | (1 << 1); /* single-bit & multi-bit error detection */
+	pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_DRAM, byte);
+
+	pci_read_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_HIA, &byte);
+	byte |= E7501_HIA_SERRCMD_MASK;
+	pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_HIA, byte);
+
+	pci_read_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_SYSBUS, &byte);
+	byte |= E7501_SYSBUS_SERRCMD_MASK;
+	pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_SYSBUS, byte);
+}
+
+static void e7501_D0F1_exit(struct pci_dev *dev)
+{
+	u8 byte;
+	u16 word;
+
+	/* SERR enabled only in INT mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		return;
+
+        pci_read_config_word(dev, E7501_South_Bridge_HIA_PCICMD, &word);
+	if (word & (1 << 8)) { /* SERR */
+        	word &= ~(1 << 8);
+	        pci_write_config_word(dev, E7501_South_Bridge_HIA_PCICMD, word);
+	}
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_DRAM, &byte);
+	if (byte & (1 | (1 << 1))) { /* single-bit & multi-bit error detection */
+        	byte &= ~(1 | (1 << 1)); 
+        	pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_DRAM, byte);
+	}
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_HIA, &byte);
+	if (byte & E7501_HIA_SERRCMD_MASK) {
+	        byte &= ~E7501_HIA_SERRCMD_MASK;
+	        pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_HIA, byte);
+	}
+
+        pci_read_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_SYSBUS, &byte);
+	if (byte & E7501_SYSBUS_SERRCMD_MASK) {
+	        byte &= ~E7501_SYSBUS_SERRCMD_MASK;
+	        pci_write_config_byte(dev, E7501_South_Bridge_HIA_SERRCMD_SYSBUS, byte);
+	}
+}
 static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 {
 	u16 pci_data;
@@ -431,14 +935,19 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 	mci->dev = &pdev->dev;
 	debugf3("%s(): init pvt\n", __func__);
 	pvt = (struct e7xxx_pvt *)mci->pvt_info;
-	pvt->dev_info = &e7xxx_devs[dev_idx];
+	e7xxx_device = e7xxx_devs[dev_idx];
+	/* 
+ 	 * memory controller device is the first element 
+ 	 * in the e7xxx_device array.
+ 	 */
+	pvt->dev_info = e7xxx_device;
 	pvt->bridge_ck = pci_get_device(PCI_VENDOR_ID_INTEL,
 					pvt->dev_info->err_dev, pvt->bridge_ck);
 
 	if (!pvt->bridge_ck) {
 		e7xxx_printk(KERN_ERR, "error reporting device not found:"
 			"vendor %x device 0x%x (broken BIOS?)\n",
-			PCI_VENDOR_ID_INTEL, e7xxx_devs[dev_idx].err_dev);
+			PCI_VENDOR_ID_INTEL, pvt->dev_info->err_dev);
 		goto fail0;
 	}
 
@@ -464,6 +973,9 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 	/* clear any pending errors, or initial state bits */
 	e7xxx_get_error_info(mci, &discard);
 
+	/* initialize error detection on D0F1 device */
+	e7xxx_D0F1_init(pvt->bridge_ck);
+
 	/* Here we assume that we will never see multiple instances of this
 	 * type of memory controller.  The ID is therefore hardcoded to 0.
 	 */
@@ -483,6 +995,9 @@ static int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)
 			__func__);
 	}
 
+	/* adding all the rest devices on a e7xxx chipset */
+	e7xxx_add_edac_devices();
+
 	/* get this far and it's successful */
 	debugf3("%s(): success\n", __func__);
 	return 0;
@@ -507,6 +1022,34 @@ static int __devinit e7xxx_init_one(struct pci_dev *pdev,
 		-EIO : e7xxx_probe1(pdev, ent->driver_data);
 }
 
+static void __devexit e7xxx_del_edac_devices(void)
+{
+	struct e7xxx_dev_info *dev_info;
+
+	if ((edac_op_state == EDAC_OPSTATE_NMI) && device_added) {
+		unsigned long flags;
+		spin_lock_irqsave(&edac_nmi_lock, flags);
+		if (edac_handle_nmi)
+			edac_handle_nmi = NULL;
+		spin_unlock_irqrestore(&edac_nmi_lock, flags);
+	}
+
+	/* start at 1 to skip memory controller device  */
+	for (dev_info = &e7xxx_device[1]; dev_info->err_dev; dev_info++) {
+		if (dev_info->edac_dev) {
+			edac_device_del_device(dev_info->edac_dev->dev);
+			edac_device_free_ctl_info(dev_info->edac_dev);
+		}
+
+		if (dev_info->dev) {
+			if (dev_info->exit)
+				dev_info->exit(dev_info);
+			pci_dev_put(dev_info->dev);
+		}
+		device_added--;
+	}
+}
+
 static void __devexit e7xxx_remove_one(struct pci_dev *pdev)
 {
 	struct mem_ctl_info *mci;
@@ -521,8 +1064,12 @@ static void __devexit e7xxx_remove_one(struct pci_dev *pdev)
 		return;
 
 	pvt = (struct e7xxx_pvt *)mci->pvt_info;
+	e7501_D0F1_exit(pvt->bridge_ck);
 	pci_dev_put(pvt->bridge_ck);
 	edac_mc_free(mci);
+
+	if (e7xxx_device)
+		e7xxx_del_edac_devices();
 }
 
 static const struct pci_device_id e7xxx_pci_tbl[] __devinitdata = {
diff --git a/drivers/edac/edac_core.h b/drivers/edac/edac_core.h
index c7b99b4..295c317 100644
--- a/drivers/edac/edac_core.h
+++ b/drivers/edac/edac_core.h
@@ -414,6 +414,8 @@ struct mem_ctl_info {
 	u32 ue_count;		/* Total Uncorrectable Errors for this MC */
 	u32 ce_count;		/* Total Correctable Errors for this MC */
 	unsigned long start_time;	/* mci load start time (in jiffies) */
+	u32 hub_err_count;	/* Hub Error */
+	u32 sysbus_err_count;	/* All types of Sysbus Error */
 
 	/* this stuff is for safe removal of mc devices from global list while
 	 * NMI handlers may be traversing list
diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c
index aadd817..b881b8b 100644
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@ -547,6 +547,16 @@ static ssize_t mci_size_mb_show(struct mem_ctl_info *mci, char *data)
 	return sprintf(data, "%u\n", PAGES_TO_MiB(total_pages));
 }
 
+static ssize_t mci_hub_err_count_show(struct mem_ctl_info *mci, char *data)
+{
+        return sprintf(data, "%d\n", mci->hub_err_count);
+}
+
+static ssize_t mci_sysbus_err_count_show(struct mem_ctl_info *mci, char *data)
+{
+        return sprintf(data, "%d\n", mci->sysbus_err_count);
+}
+
 #define to_mci(k) container_of(k, struct mem_ctl_info, edac_mci_kobj)
 #define to_mcidev_attr(a) container_of(a,struct mcidev_sysfs_attribute,attr)
 
@@ -599,6 +609,8 @@ MCIDEV_ATTR(ue_noinfo_count, S_IRUGO, mci_ue_noinfo_show, NULL);
 MCIDEV_ATTR(ce_noinfo_count, S_IRUGO, mci_ce_noinfo_show, NULL);
 MCIDEV_ATTR(ue_count, S_IRUGO, mci_ue_count_show, NULL);
 MCIDEV_ATTR(ce_count, S_IRUGO, mci_ce_count_show, NULL);
+MCIDEV_ATTR(hub_err_count, S_IRUGO, mci_hub_err_count_show, NULL);
+MCIDEV_ATTR(sysbus_err_count, S_IRUGO, mci_sysbus_err_count_show, NULL);
 
 /* memory scrubber attribute file */
 MCIDEV_ATTR(sdram_scrub_rate, S_IRUGO | S_IWUSR, mci_sdram_scrub_rate_show,
@@ -614,6 +626,8 @@ static struct mcidev_sysfs_attribute *mci_attr[] = {
 	&mci_attr_ue_count,
 	&mci_attr_ce_count,
 	&mci_attr_sdram_scrub_rate,
+	&mci_attr_hub_err_count,
+	&mci_attr_sysbus_err_count,
 	NULL
 };
 
-- 
1.6.5.2

