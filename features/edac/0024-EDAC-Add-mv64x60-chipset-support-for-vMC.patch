From 50072c95759c21df5b15d0e5d0d7828076ad697f Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Wed, 17 Dec 2008 11:59:10 -0500
Subject: [PATCH] EDAC: Add mv64x60 chipset support for vMC

Add EDAC vMC wrapper calls and a vMC sensor mappings for mv64x60
chipsets.  This vMC integration is enabled by the CONFIG_EDAC_VMC
kernel configuration.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 drivers/edac/mv64x60_edac.c     |  205 ++++++++++++++++++++++++++++++++++++++-
 drivers/edac/mv64x60_edac_vmc.h |   82 ++++++++++++++++
 2 files changed, 284 insertions(+), 3 deletions(-)
 create mode 100644 drivers/edac/mv64x60_edac_vmc.h

diff --git a/drivers/edac/mv64x60_edac.c b/drivers/edac/mv64x60_edac.c
index 89bd098..e99a49d 100644
--- a/drivers/edac/mv64x60_edac.c
+++ b/drivers/edac/mv64x60_edac.c
@@ -25,11 +25,88 @@
 #include "edac_module.h"
 #include "mv64x60_edac.h"
 
+#ifdef CONFIG_EDAC_VMC
+	#include "edac_vmc.h"
+	#include "mv64x60_edac_vmc.h"
+#endif
+
 static const char *mv64x60_ctl_name = "MV64x60";
 static int edac_dev_idx;
 static int edac_pci_idx;
 static int edac_mc_idx;
 
+#ifdef CONFIG_EDAC_VMC
+static int init_vmc_sensors(void)
+{
+	int rc;
+
+	struct vmc_sensor_params_s uecc_flt_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_MEMORY,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = GEN_THRESHOLD_TBL,
+		.threshold_mask = DEFAULT_READ_SET_THRES_MASK,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	struct vmc_sensor_params_s cecc_flt_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_MEMORY,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = CECC_THRESHOLD_TBL,
+		.threshold_mask = READ_THRES_MASK_UPPER_CRITICAL,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	/* Assign a vMC LUN to this chipset */
+	mv64x60_vmc_lun = vmc_assign_lun();
+
+	/* Sensors with non-default parameters */
+	rc  = vmc_sensor_init(VMC_DRAM_UE, mv64x60_sensor_map,
+			      mv64x60_sensor_names,
+			      mv64x60_vmc_lun, &uecc_flt_params);
+	rc |= vmc_sensor_init(VMC_DRAM_CE, mv64x60_sensor_map,
+			      mv64x60_sensor_names,
+			      mv64x60_vmc_lun, &cecc_flt_params);
+
+
+#define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id),			\
+						mv64x60_sensor_map,	\
+						mv64x60_sensor_names,	\
+						mv64x60_vmc_lun, NULL)
+	/* Sensors with default parameters: */
+	rc |= INIT_SENSOR_DEFAULT(VMC_PCI_PARITY);
+	rc |= INIT_SENSOR_DEFAULT(VMC_PCI_NON_PARITY);
+	rc |= INIT_SENSOR_DEFAULT(VMC_SRAM);
+	rc |= INIT_SENSOR_DEFAULT(VMC_CPU);
+	rc |= INIT_SENSOR_DEFAULT(VMC_DEVICE);
+	rc |= INIT_SENSOR_DEFAULT(VMC_COMM);
+	rc |= INIT_SENSOR_DEFAULT(VMC_ETH);
+	rc |= INIT_SENSOR_DEFAULT(VMC_DMA);
+
+#undef INIT_SENSOR_DEFAULT
+
+	return rc;
+}
+
+static void uninit_vmc_sensors(void)
+{
+	vmc_sensor_uninit(VMC_DRAM_UE, mv64x60_vmc_lun);
+	vmc_sensor_uninit(VMC_DRAM_CE, mv64x60_vmc_lun);
+	vmc_sensor_uninit(VMC_PCI_PARITY, mv64x60_vmc_lun);
+	vmc_sensor_uninit(VMC_PCI_NON_PARITY, mv64x60_vmc_lun);
+	vmc_sensor_uninit(VMC_SRAM, mv64x60_vmc_lun);
+	vmc_sensor_uninit(VMC_CPU, mv64x60_vmc_lun);
+	vmc_sensor_uninit(VMC_DEVICE, mv64x60_vmc_lun);
+	vmc_sensor_uninit(VMC_COMM, mv64x60_vmc_lun);
+	vmc_sensor_uninit(VMC_ETH, mv64x60_vmc_lun);
+	vmc_sensor_uninit(VMC_DMA, mv64x60_vmc_lun);
+}
+
+#endif /* CONFIG_EDAC_VMC */
+
+
+
 /*********************** PCI err device **********************************/
 #ifdef CONFIG_PCI
 static void mv64x60_pci_check(struct edac_pci_ctl_info *pci)
@@ -51,8 +128,25 @@ static void mv64x60_pci_check(struct edac_pci_ctl_info *pci)
 	       in_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_ATTR));
 	printk(KERN_ERR "Command: 0x%08x\n",
 	       in_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_CMD));
-	out_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_CAUSE, ~cause);
 
+#ifdef CONFIG_EDAC_VMC
+	{
+	int error_type =
+		cause & MV64X60_PCI_PE_MASK ? VMC_PCI_PARITY : VMC_PCI_NON_PARITY;
+	vmc_report_fault(error_type, mv64x60_vmc_lun, SENSOR_ACTION_INC, 1, 5,
+		"cause", cause,
+		"address low",
+		in_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_ADDR_LO),
+		"address high",
+		in_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_ADDR_HI),
+		"attribute",
+		in_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_ATTR),
+		"command",
+		in_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_CMD));
+	}
+#endif
+
+	out_le32(pdata->pci_vbase + MV64X60_PCI_ERROR_CAUSE, ~cause);
 	if (cause & MV64X60_PCI_PE_MASK)
 		edac_pci_handle_pe(pci, pci->ctl_name);
 
@@ -263,8 +357,23 @@ static void mv64x60_sram_check(struct edac_device_ctl_info *edac_dev)
 	       in_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_DATA_HI));
 	printk(KERN_ERR "Parity: 0x%08x\n",
 	       in_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_PARITY));
-	out_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_CAUSE, 0);
 
+#ifdef CONFIG_EDAC_VMC
+	vmc_report_fault(VMC_SRAM, mv64x60_vmc_lun, SENSOR_ACTION_INC, 1, 6,
+		"cause", cause,
+		"address low",
+		in_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_ADDR_LO),
+		"address high",
+		in_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_ADDR_HI),
+		"data low",
+		in_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_DATA_LO),
+		"data high",
+		in_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_DATA_HI),
+		"parity",
+		in_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_PARITY));
+#endif
+
+	out_le32(pdata->sram_vbase + MV64X60_SRAM_ERR_CAUSE, 0);
 	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
 }
 
@@ -430,8 +539,23 @@ static void mv64x60_cpu_check(struct edac_device_ctl_info *edac_dev)
 	       in_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_DATA_HI));
 	printk(KERN_ERR "Parity: 0x%08x\n",
 	       in_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_PARITY));
-	out_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_CAUSE, 0);
 
+#ifdef CONFIG_EDAC_VMC
+	vmc_report_fault(VMC_CPU, mv64x60_vmc_lun, SENSOR_ACTION_INC, 1, 6,
+		"cause", cause,
+		"address low",
+		in_le32(pdata->cpu_vbase + MV64x60_CPU_ERR_ADDR_LO),
+		"address high",
+		in_le32(pdata->cpu_vbase + MV64x60_CPU_ERR_ADDR_HI),
+		"data low",
+		in_le32(pdata->cpu_vbase + MV64x60_CPU_ERR_DATA_LO),
+		"data high",
+		in_le32(pdata->cpu_vbase + MV64x60_CPU_ERR_DATA_HI),
+		"parity",
+		in_le32(pdata->cpu_vbase + MV64x60_CPU_ERR_PARITY));
+#endif
+
+	out_le32(pdata->cpu_vbase[1] + MV64x60_CPU_ERR_CAUSE, 0);
 	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
 }
 
@@ -630,6 +754,28 @@ static void mv64x60_mc_check(struct mem_ctl_info *mci)
 		edac_mc_handle_ue(mci, err_addr >> PAGE_SHIFT,
 				  err_addr & PAGE_MASK, 0, mci->ctl_name);
 
+#ifdef CONFIG_EDAC_VMC
+	{
+	int sensor, action, value;
+
+	if (reg & 0x1) {
+		sensor = VMC_DRAM_UE;
+		action = SENSOR_ACTION_SET;
+		value = TH_GEN_UPPER_NON_RECOVERABLE;
+	} else {
+		sensor = VMC_DRAM_CE;
+		action = SENSOR_ACTION_INC;
+		value = 1;
+	}
+
+	vmc_report_fault(sensor, mv64x60_vmc_lun, sensor, value, 4,
+		"error address", err_addr,
+		"SDRAM ECC", sdram_ecc,
+		"COMP ECC", comp_ecc,
+		"syndrome", syndrome);
+	}
+#endif
+
 	/* clear the error */
 	out_le32(pdata->mc_vbase + MV64X60_SDRAM_ERR_ADDR, 0);
 }
@@ -864,6 +1010,18 @@ static void mv64x60_device_check(struct edac_device_ctl_info *edac_dev)
 	  		MV64X60_DEV_INTR_ERR_PAR_MASK);
 	out_le32(pdata->device_vbase + MV64X60_DEV_INTR_CAUSE, 0);
 
+#ifdef CONFIG_EDAC_VMC
+	vmc_report_fault(VMC_DEVICE, mv64x60_vmc_lun, SENSOR_ACTION_INC, 1, 4,
+		"cause", cause,
+		"address",
+		in_le32(pdata->device_vbase + MV64X60_DEV_INTR_ERR_ADDR),
+		"data",
+		in_le32(pdata->device_vbase + MV64X60_DEV_INTR_ERR_DATA),
+		"parity",
+		in_le32(pdata->device_vbase + MV64X60_DEV_INTR_ERR_PAR) &
+			MV64X60_DEV_INTR_ERR_PAR_MASK);
+#endif
+
 	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
 }
 
@@ -1023,6 +1181,13 @@ static void mv64x60_comm_check(struct edac_device_ctl_info *edac_dev)
 	       	in_le32(pdata->comm_vbase + MV64X60_COMM_INTR_ERR_ADDR));
 	out_le32(pdata->comm_vbase + MV64X60_DEV_INTR_CAUSE, 0);
 
+#ifdef CONFIG_EDAC_VMC
+	vmc_report_fault(VMC_COMM, mv64x60_vmc_lun, SENSOR_ACTION_INC, 1, 2,
+		"cause", cause,
+		"address",
+		in_le32(pdata->comm_vbase + MV64X60_COMM_INTR_ERR_ADDR));
+#endif
+
 	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
 }
 
@@ -1186,6 +1351,16 @@ static void mv64x60_eth_check(struct edac_device_ctl_info *edac_dev)
 			MV64X60_ETH_INTERNAL_ADDR_ERR_MASK);
 	out_le32(pdata->eth_vbase + MV64X60_ETH_INTR_CAUSE, 0);
 
+#ifdef CONFIG_EDAC_VMC
+	vmc_report_fault(VMC_ETH, mv64x60_vmc_lun, SENSOR_ACTION_INC, 1, 3,
+		"cause", cause,
+		"address",
+		in_le32(pdata->eth_vbase + MV64X60_ETH_INTR_ERR_ADDR),
+		"internal error",
+		in_le32(pdata->eth_vbase + MV64X60_ETH_INTERNAL_ADDR_ERR) &
+			MV64X60_ETH_INTERNAL_ADDR_ERR_MASK);
+#endif
+
 	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
 }
 
@@ -1349,6 +1524,16 @@ static void mv64x60_dma_check(struct edac_device_ctl_info *edac_dev)
 			MV64X60_DMA_INTR_ERR_SELECT_MASK);
 	out_le32(pdata->dma_vbase + MV64X60_DMA_INTR_CAUSE, 0);
 
+#ifdef CONFIG_EDAC_VMC
+	vmc_report_fault(VMC_DMA, mv64x60_vmc_lun, SENSOR_ACTION_INC, 1, 3,
+		"cause", cause,
+		"address",
+		in_le32(pdata->dma_vbase + MV64X60_DMA_INTR_ERR_ADDR),
+		"internal error select",
+		in_le32(pdata->dma_vbase + MV64X60_DMA_INTR_ERR_SELECT) &
+			MV64X60_DMA_INTR_ERR_SELECT_MASK);
+#endif
+
 	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
 }
 
@@ -1500,6 +1685,14 @@ static int __init mv64x60_edac_init(void)
 	printk(KERN_INFO "Marvell MV64x60 EDAC driver " MV64x60_REVISION "\n");
 	printk(KERN_INFO "\t(C) 2006-2007 MontaVista Software\n");
 
+#ifdef CONFIG_EDAC_VMC
+	/* Initialize vMC Sensors */
+	if (init_vmc_sensors()) {
+		printk(KERN_ERR "failed to initialize one or more " \
+				"vMC sensors\n");
+	}
+#endif	/* CONFIG_EDAC_VMC */
+
 	opstate_init();
 
 	ret = platform_driver_register(&mv64x60_mc_err_driver);
@@ -1554,6 +1747,12 @@ module_init(mv64x60_edac_init);
 
 static void __exit mv64x60_edac_exit(void)
 {
+
+#ifdef CONFIG_EDAC_VMC
+	/* Uninitialize vMC sensors */
+	uninit_vmc_sensors();
+#endif
+
 	platform_driver_unregister(&mv64x60_dma_err_driver);
 	platform_driver_unregister(&mv64x60_eth_err_driver);
 	platform_driver_unregister(&mv64x60_comm_err_driver);
diff --git a/drivers/edac/mv64x60_edac_vmc.h b/drivers/edac/mv64x60_edac_vmc.h
new file mode 100644
index 0000000..a457636
--- /dev/null
+++ b/drivers/edac/mv64x60_edac_vmc.h
@@ -0,0 +1,82 @@
+/*
+ * mv64x60_edac_vmc.h, vMC sensor maps for MV64X60 EDAC driver
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Author: Benjamin Walsh (benjamin.walsh@windriver.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _MV64X60_EDAC_VMC_H_
+#define _MV64X60_EDAC_VMC_H_
+
+#include "edac_vmc.h"
+#include "mv64x60_edac.h"
+
+/* Assign sensor numbers.
+ *   Order is arbitrary */
+enum mv64x60_sensors {
+	VMC_PCI_PARITY = 0,
+	VMC_PCI_NON_PARITY,
+	VMC_SRAM,
+	VMC_CPU,
+	VMC_DRAM_CE,
+	VMC_DRAM_UE,
+	VMC_DEVICE,
+	VMC_COMM,
+	VMC_ETH,
+	VMC_DMA
+};
+
+/* Assign sensor names.
+ * macro usage: name_sensor( name ),
+ *   Order does not matter here */
+#define name_sensor(x) [x] = #x
+static const char *mv64x60_sensor_names[] = {
+	name_sensor(VMC_PCI_PARITY),
+	name_sensor(VMC_PCI_NON_PARITY),
+	name_sensor(VMC_SRAM),
+	name_sensor(VMC_CPU),
+	name_sensor(VMC_DRAM_CE),
+	name_sensor(VMC_DRAM_UE),
+	name_sensor(VMC_DEVICE),
+	name_sensor(VMC_COMM),
+	name_sensor(VMC_ETH),
+	name_sensor(VMC_DMA)
+};
+
+/* Map sensors to vMC IPMI entities.
+ * macro usage: map_sensor(sensor, entity type, entity instance),
+ *   Order does not matter here */
+#define map_sensor(sensor, type, phys_id) \
+	[(sensor)] = (((type) << 8) | (phys_id))
+static const int mv64x60_sensor_map[] = {
+	map_sensor(VMC_PCI_PARITY, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_PCI_NON_PARITY, IPMI_ENTITY_ID_PCI_BUS, 0),
+	map_sensor(VMC_SRAM, IPMI_ENTITY_ID_MEMORY_DEVICE, 0),
+	map_sensor(VMC_CPU, IPMI_ENTITY_ID_PROCESSOR, 0),
+	map_sensor(VMC_DRAM_CE, IPMI_ENTITY_ID_MEMORY_DEVICE, 1),
+	map_sensor(VMC_DRAM_UE, IPMI_ENTITY_ID_MEMORY_DEVICE, 1),
+	map_sensor(VMC_DEVICE, IPMI_ENTITY_ID_OTHER, 0),
+	map_sensor(VMC_COMM, IPMI_ENTITY_ID_OTHER, 1),
+	map_sensor(VMC_ETH, IPMI_ENTITY_ID_OTHER, 2),
+	map_sensor(VMC_DMA, IPMI_ENTITY_ID_OTHER, 3)
+};
+
+/* put here instead of C file to modularize with vMC */
+static int mv64x60_vmc_lun;
+
+#endif	/* _MV64X60_EDAC_VMC_H_ */
+
-- 
1.6.0.3

