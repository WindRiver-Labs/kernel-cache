From 0ed0649cf2ec5b54e73fdc96b8635271077fc06b Mon Sep 17 00:00:00 2001
From: Rob Woolley <rob.woolley@windriver.com>
Date: Sat, 8 Nov 2008 13:20:23 -0500
Subject: [PATCH] EDAC driver for the Ethernet Controller on mv64x60 chipset

Adds the EDAC driver for the Ethernet Controller on mv64x60 chipset.

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
Reviewed-by: Rob Woolley <rob.woolley@windriver.com>
---
 arch/powerpc/boot/dts/prpmc2800.dts |    7 ++
 arch/powerpc/sysdev/mv64x60_dev.c   |    8 ++
 drivers/edac/mv64x60_edac.c         |  169 +++++++++++++++++++++++++++++++++++
 drivers/edac/mv64x60_edac.h         |   30 ++++++
 4 files changed, 214 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/boot/dts/prpmc2800.dts b/arch/powerpc/boot/dts/prpmc2800.dts
index 7611880..03aab9b 100644
--- a/arch/powerpc/boot/dts/prpmc2800.dts
+++ b/arch/powerpc/boot/dts/prpmc2800.dts
@@ -314,6 +314,13 @@
 			interrupts = <15>;
 			interrupt-parent = <&PIC>;
 		};
+
+		eth-ctrl@f2080 {
+			compatible = "marvell,mv64x60-eth-ctrl";
+			reg = <0x2080 0x1c>;
+			interrupts = <14>;
+			interrupt-parent = <&PIC>;
+		};
 	};
 
 	chosen {
diff --git a/arch/powerpc/sysdev/mv64x60_dev.c b/arch/powerpc/sysdev/mv64x60_dev.c
index ec09f24..383f474 100644
--- a/arch/powerpc/sysdev/mv64x60_dev.c
+++ b/arch/powerpc/sysdev/mv64x60_dev.c
@@ -593,6 +593,14 @@ static int __init mv64x60_device_setup(void)
 					"commnication controller %s: error %d.\n",
 					np->full_name, err);
 
+	id = 0;
+	for_each_compatible_node(np, NULL, "marvell,mv64x60-eth-ctrl")
+		if ((err = mv64x60_edac_device_setup(np, id++, 1,
+					"mv64x60_eth_err")))
+			printk(KERN_ERR "Failed to initialize MV64x60 "
+					"ethernet controller %s: error %d.\n",
+					np->full_name, err);
+
 	return 0;
 }
 arch_initcall(mv64x60_device_setup);
diff --git a/drivers/edac/mv64x60_edac.c b/drivers/edac/mv64x60_edac.c
index 1b854c5..7f600bd 100644
--- a/drivers/edac/mv64x60_edac.c
+++ b/drivers/edac/mv64x60_edac.c
@@ -1167,6 +1167,169 @@ static struct platform_driver mv64x60_comm_err_driver = {
 	}
 };
 
+/*********************** Ethernet err device ****************************/
+static void mv64x60_eth_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct mv64x60_eth_pdata *pdata = edac_dev->pvt_info;
+	u32 cause;
+
+	cause = in_le32(pdata->eth_vbase + MV64X60_ETH_INTR_CAUSE);
+	if (!cause)
+		return;
+
+	printk(KERN_ERR "Error on Ethernet interface\n");
+	printk(KERN_ERR "Cause register: 0x%08x\n", cause);
+	printk(KERN_ERR "Address : 0x%08x\n",
+	       	in_le32(pdata->eth_vbase + MV64X60_ETH_INTR_ERR_ADDR));
+	printk(KERN_ERR "Internal address error : 0x%08x\n",
+	       	in_le32(pdata->eth_vbase + MV64X60_ETH_INTERNAL_ADDR_ERR) &
+			MV64X60_ETH_INTERNAL_ADDR_ERR_MASK);
+	out_le32(pdata->eth_vbase + MV64X60_ETH_INTR_CAUSE, 0);
+
+	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+}
+
+static irqreturn_t mv64x60_eth_isr(int irq, void *dev_id)
+{
+	struct edac_device_ctl_info *edac_dev = dev_id;
+	struct mv64x60_eth_pdata *pdata = edac_dev->pvt_info;
+	u32 cause;
+
+	cause = in_le32(pdata->eth_vbase + MV64X60_ETH_INTR_CAUSE);
+	if (!cause)
+		return IRQ_NONE;
+
+	mv64x60_eth_check(edac_dev);
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit mv64x60_eth_err_probe(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev;
+	struct resource *r;
+	struct mv64x60_eth_pdata *pdata;
+	int res = 0;
+
+	if (!devres_open_group(&pdev->dev, mv64x60_eth_err_probe, GFP_KERNEL))
+		return -ENOMEM;
+
+	edac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),
+					      "eth", 1, NULL, 0, 0, 
+					      NULL, 0, edac_dev_idx);
+	if (!edac_dev) {
+		devres_release_group(&pdev->dev, mv64x60_eth_err_probe);
+		return -ENOMEM;
+	}
+
+	pdata = edac_dev->pvt_info;
+	pdata->name = pdev->name;
+	pdata->irq = NO_IRQ;
+	edac_dev->dev = &pdev->dev;
+	platform_set_drvdata(pdev, edac_dev);
+	edac_dev->dev_name = pdev->dev.bus_id;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		printk(KERN_ERR "%s: Unable to get resource for "
+		       "ethernet err regs\n", __func__);
+		res = -ENOENT;
+		goto err;
+	}
+
+	if (!devm_request_mem_region(&pdev->dev,
+				     r->start,
+				     r->end - r->start + 1,
+				     pdata->name)) {
+		printk(KERN_ERR "%s: Error while requesting mem region\n",
+		       __func__);
+		res = -EBUSY;
+		goto err;
+	}
+
+	pdata->eth_vbase = devm_ioremap(&pdev->dev,
+					   r->start,
+					   r->end - r->start + 1);
+
+	if (!pdata->eth_vbase) {
+		printk(KERN_ERR "%s: Unable to setup Ethernet err regs\n", 
+		       __func__);
+		res = -ENOMEM;
+		goto err;
+	}
+
+	/* setup Ethernet err registers */
+	out_le32(pdata->eth_vbase + MV64X60_ETH_INTR_CAUSE, 0);
+	out_le32(pdata->eth_vbase + MV64X60_ETH_INTR_MASK, 0);
+	out_le32(pdata->eth_vbase + MV64X60_ETH_INTR_MASK, 
+		 MV64X60_ETH_INTR_MASK_VALUE);
+
+	edac_dev->mod_name = EDAC_MOD_STR;
+	edac_dev->ctl_name = pdata->name;
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		edac_dev->edac_check = mv64x60_eth_check;
+
+	pdata->edac_idx = edac_dev_idx++;
+
+	if (edac_device_add_device(edac_dev) > 0) {
+		debugf3("%s(): failed edac_device_add_device()\n", __func__);
+		goto err;
+	}
+
+	if (edac_op_state == EDAC_OPSTATE_INT) {
+		pdata->irq = platform_get_irq(pdev, 0);
+		res = devm_request_irq(&pdev->dev,
+				       pdata->irq,
+				       mv64x60_eth_isr,
+				       IRQF_DISABLED,
+				       "[EDAC] Eth Err",
+				       edac_dev);
+		if (res < 0) {
+			printk(KERN_ERR
+			       "%s: Unable to request irq %d for MV64x60 "
+			       "ethernet err\n", __func__, pdata->irq);
+			res = -ENODEV;
+			goto err2;
+		}
+
+		printk(KERN_INFO EDAC_MOD_STR
+		       " acquired irq %d for ethernet err\n", pdata->irq);
+	}
+
+	devres_remove_group(&pdev->dev, mv64x60_eth_err_probe);
+
+	/* get this far and it's successful */
+	debugf3("%s(): success\n", __func__);
+
+	return 0;
+
+err2:
+	edac_device_del_device(&pdev->dev);
+err:
+	devres_release_group(&pdev->dev, mv64x60_eth_err_probe);
+	edac_device_free_ctl_info(edac_dev);
+	return res;
+}
+
+static int mv64x60_eth_err_remove(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev = platform_get_drvdata(pdev);
+
+	debugf0("%s()\n", __func__);
+
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(edac_dev);
+	return 0;
+}
+
+static struct platform_driver mv64x60_eth_err_driver = {
+	.probe = mv64x60_eth_err_probe,
+	.remove = mv64x60_eth_err_remove,
+	.driver = {
+		   .name = "mv64x60_eth_err",
+	}
+};
+
 static int __init mv64x60_edac_init(void)
 {
 	int ret = 0;
@@ -1212,12 +1375,18 @@ static int __init mv64x60_edac_init(void)
 		printk(KERN_WARNING EDAC_MOD_STR
 			"Communication err failed to register\n");
 
+	ret = platform_driver_register(&mv64x60_eth_err_driver);
+	if (ret)
+		printk(KERN_WARNING EDAC_MOD_STR
+			"Ethernet err failed to register\n");
+
 	return ret;
 }
 module_init(mv64x60_edac_init);
 
 static void __exit mv64x60_edac_exit(void)
 {
+	platform_driver_unregister(&mv64x60_eth_err_driver);
 	platform_driver_unregister(&mv64x60_comm_err_driver);
 	platform_driver_unregister(&mv64x60_device_err_driver);
 #ifdef CONFIG_PCI
diff --git a/drivers/edac/mv64x60_edac.h b/drivers/edac/mv64x60_edac.h
index 7d2d18d..6de96df 100644
--- a/drivers/edac/mv64x60_edac.h
+++ b/drivers/edac/mv64x60_edac.h
@@ -168,6 +168,29 @@ struct mv64x60_pci_pdata {
 					MV64X60_COMM_INTR_MASK_S1AccProt | \
 					MV64X60_COMM_INTR_MASK_S1WrProt)
 
+/* Ethernet Interrupts Registers */
+#define MV64X60_ETH_INTR_CAUSE		0x00 	/* 0x2080 */
+#define MV64X60_ETH_INTR_MASK		0x04	/* 0x2084 */
+#define MV64X60_ETH_INTR_ERR_ADDR	0x14	/* 0x2094 */
+#define MV64X60_ETH_INTERNAL_ADDR_ERR	0x18	/* 0x2098 */
+
+#define MV64X60_ETH_INTR_MASK_EtherIntSum		0x0001
+#define MV64X60_ETH_INTR_MASK_Parity			0x0002
+#define MV64X60_ETH_INTR_MASK_AddressViolation		0x0004
+#define MV64X60_ETH_INTR_MASK_AddressNoMatch		0x0008
+#define MV64X60_ETH_INTR_MASK_SMIdone			0x0010
+#define MV64X60_ETH_INTR_MASK_Count_wa			0x0020
+						     /* 0x0040, reserved */
+#define MV64X60_ETH_INTR_MASK_Internal_addr_error	0x0080
+
+#define MV64X60_ETH_INTR_MASK_VALUE	(MV64X60_ETH_INTR_MASK_Parity | \
+					MV64X60_ETH_INTR_MASK_AddressViolation | \
+					MV64X60_ETH_INTR_MASK_AddressNoMatch | \
+					MV64X60_ETH_INTR_MASK_Internal_addr_error)
+
+/* only bits[8:0] of the EUIAER are accessible */
+#define MV64X60_ETH_INTERNAL_ADDR_ERR_MASK	0x000001ff
+
 struct mv64x60_mc_pdata {
 	void __iomem *mc_vbase;
 	int total_mem;
@@ -204,4 +227,11 @@ struct mv64x60_comm_pdata {
         int edac_idx;
 };
 
+struct mv64x60_eth_pdata {
+        void __iomem *eth_vbase;
+	const char *name;
+        int irq;
+        int edac_idx;
+};
+
 #endif
-- 
1.6.0.90.g436ed

