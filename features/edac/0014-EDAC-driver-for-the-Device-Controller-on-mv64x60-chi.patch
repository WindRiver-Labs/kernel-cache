From 2997a8997ffdc1cfdcc271d34673f93aa8b7ff96 Mon Sep 17 00:00:00 2001
From: Rob Woolley <rob.woolley@windriver.com>
Date: Sat, 8 Nov 2008 13:20:21 -0500
Subject: [PATCH] EDAC driver for the Device Controller on mv64x60 chipset

Adds a DTS entry for the device controller as well as the necessary EDAC
device routines to the mv64x60 chip EDAC driver.

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
[rob.woolley@windriver.com: Added description for patch header]
Reviewed-by: Rob Woolley <rob.woolley@windriver.com>
---
 arch/powerpc/boot/dts/prpmc2800.dts |    7 ++
 arch/powerpc/sysdev/mv64x60_dev.c   |    8 ++
 drivers/edac/mv64x60_edac.c         |  185 +++++++++++++++++++++++++++++++++--
 drivers/edac/mv64x60_edac.h         |   36 +++++++
 4 files changed, 227 insertions(+), 9 deletions(-)

diff --git a/arch/powerpc/boot/dts/prpmc2800.dts b/arch/powerpc/boot/dts/prpmc2800.dts
index 7791b01..f68678e 100644
--- a/arch/powerpc/boot/dts/prpmc2800.dts
+++ b/arch/powerpc/boot/dts/prpmc2800.dts
@@ -300,6 +300,13 @@
 			interrupts = <17>;
 			interrupt-parent = <&PIC>;
 		};
+
+                device-ctrl@4d0 {
+                        compatible = "marvell,mv64x60-device-ctrl";
+                        reg = <0x4d0 0x14>;
+                        interrupts = <1>;
+                        interrupt-parent = <&PIC>;
+                };
 	};
 
 	chosen {
diff --git a/arch/powerpc/sysdev/mv64x60_dev.c b/arch/powerpc/sysdev/mv64x60_dev.c
index f5079c6..f23c382 100644
--- a/arch/powerpc/sysdev/mv64x60_dev.c
+++ b/arch/powerpc/sysdev/mv64x60_dev.c
@@ -577,6 +577,14 @@ static int __init mv64x60_device_setup(void)
 	}
 #endif
 
+	id = 0;
+	for_each_compatible_node(np, NULL, "marvell,mv64x60-device-ctrl")
+		if ((err = mv64x60_edac_device_setup(np, id++, 1,
+					"mv64x60_device_err")))
+			printk(KERN_ERR "Failed to initialize MV64x60 "
+					"device controller %s: error %d.\n",
+					np->full_name, err);
+
 	return 0;
 }
 arch_initcall(mv64x60_device_setup);
diff --git a/drivers/edac/mv64x60_edac.c b/drivers/edac/mv64x60_edac.c
index 14922dd..5107580 100644
--- a/drivers/edac/mv64x60_edac.c
+++ b/drivers/edac/mv64x60_edac.c
@@ -8,6 +8,10 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  *
+ * Additions for the Device, Communication, Ethernet and DMA Controllers,
+ * added by Cao Qingtao <qingtao.cao@windriver.com>,
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
  */
 
 #include <linux/module.h>
@@ -839,21 +843,178 @@ static struct platform_driver mv64x60_mc_err_driver = {
 	}
 };
 
+/*********************** Device err device **********************************/
+static void mv64x60_device_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct mv64x60_device_pdata *pdata = edac_dev->pvt_info;
+	u32 cause;
+
+	cause = in_le32(pdata->device_vbase + MV64X60_DEV_INTR_CAUSE);
+	if (!cause)
+		return;
+
+	printk(KERN_ERR "Error on device bus interface\n");
+	printk(KERN_ERR "Cause register: 0x%08x\n", cause);
+	printk(KERN_ERR "Address : 0x%08x\n",
+		in_le32(pdata->device_vbase + MV64X60_DEV_INTR_ERR_ADDR));
+	printk(KERN_ERR "Data : 0x%08x\n",
+	       	in_le32(pdata->device_vbase + MV64X60_DEV_INTR_ERR_DATA));
+	printk(KERN_ERR "Parity: 0x%08x\n",
+		in_le32(pdata->device_vbase + MV64X60_DEV_INTR_ERR_PAR) & 
+	  		MV64X60_DEV_INTR_ERR_PAR_MASK);
+	out_le32(pdata->device_vbase + MV64X60_DEV_INTR_CAUSE, 0);
+
+	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+}
+
+static irqreturn_t mv64x60_device_isr(int irq, void *dev_id)
+{
+	struct edac_device_ctl_info *edac_dev = dev_id;
+	struct mv64x60_device_pdata *pdata = edac_dev->pvt_info;
+	u32 cause;
+
+	cause = in_le32(pdata->device_vbase + MV64X60_DEV_INTR_CAUSE);
+	if (!cause)
+		return IRQ_NONE;
+
+	mv64x60_device_check(edac_dev);
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit mv64x60_device_err_probe(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev;
+	struct resource *r;
+	struct mv64x60_device_pdata *pdata;
+	int res = 0;
+
+	if (!devres_open_group(&pdev->dev, mv64x60_device_err_probe, GFP_KERNEL))
+		return -ENOMEM;
+
+	edac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),
+					      "dev", 1, NULL, 0, 0, NULL, 0,
+					      edac_dev_idx);
+	if (!edac_dev) {
+		devres_release_group(&pdev->dev, mv64x60_device_err_probe);
+		return -ENOMEM;
+	}
+
+	pdata = edac_dev->pvt_info;
+	pdata->name = pdev->name;
+	pdata->irq = NO_IRQ;
+	edac_dev->dev = &pdev->dev;
+	platform_set_drvdata(pdev, edac_dev);
+	edac_dev->dev_name = pdev->dev.bus_id;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		printk(KERN_ERR "%s: Unable to get resource for "
+		       "device err regs\n", __func__);
+		res = -ENOENT;
+		goto err;
+	}
+
+	if (!devm_request_mem_region(&pdev->dev,
+				     r->start,
+				     r->end - r->start + 1,
+				     pdata->name)) {
+		printk(KERN_ERR "%s: Error while requesting mem region\n",
+		       __func__);
+		res = -EBUSY;
+		goto err;
+	}
+
+	pdata->device_vbase = devm_ioremap(&pdev->dev,
+					   r->start,
+					   r->end - r->start + 1);
+
+	if (!pdata->device_vbase) {
+		printk(KERN_ERR "%s: Unable to setup device err regs\n", __func__);
+		res = -ENOMEM;
+		goto err;
+	}
+
+	/* setup Device err registers */
+	out_le32(pdata->device_vbase + MV64X60_DEV_INTR_CAUSE, 0);
+	out_le32(pdata->device_vbase + MV64X60_DEV_INTR_MASK, 0);
+	out_le32(pdata->device_vbase + MV64X60_DEV_INTR_MASK, 
+		 MV64X60_DEV_INTR_MASK_VALUE);
+
+	edac_dev->mod_name = EDAC_MOD_STR;
+	edac_dev->ctl_name = pdata->name;
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		edac_dev->edac_check = mv64x60_device_check;
+
+	pdata->edac_idx = edac_dev_idx++;
+
+	if (edac_device_add_device(edac_dev) > 0) {
+		debugf3("%s(): failed edac_device_add_device()\n", __func__);
+		goto err;
+	}
+
+	if (edac_op_state == EDAC_OPSTATE_INT) {
+		pdata->irq = platform_get_irq(pdev, 0);
+		res = devm_request_irq(&pdev->dev,
+				       pdata->irq,
+				       mv64x60_device_isr,
+				       IRQF_DISABLED,
+				       "[EDAC] Dev Err",
+				       edac_dev);
+		if (res < 0) {
+			printk(KERN_ERR
+			       "%s: Unable to request irq %d for MV64x60 "
+			       "device err\n", __func__, pdata->irq);
+			res = -ENODEV;
+			goto err2;
+		}
+
+		printk(KERN_INFO EDAC_MOD_STR
+		       " acquired irq %d for device err\n", pdata->irq);
+	}
+
+	devres_remove_group(&pdev->dev, mv64x60_device_err_probe);
+
+	/* get this far and it's successful */
+	debugf3("%s(): success\n", __func__);
+
+	return 0;
+
+err2:
+	edac_device_del_device(&pdev->dev);
+err:
+	devres_release_group(&pdev->dev, mv64x60_device_err_probe);
+	edac_device_free_ctl_info(edac_dev);
+	return res;
+}
+
+static int mv64x60_device_err_remove(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev = platform_get_drvdata(pdev);
+
+	debugf0("%s()\n", __func__);
+
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(edac_dev);
+	return 0;
+}
+
+static struct platform_driver mv64x60_device_err_driver = {
+	.probe = mv64x60_device_err_probe,
+	.remove = mv64x60_device_err_remove,
+	.driver = {
+		   .name = "mv64x60_device_err",
+	}
+};
+
 static int __init mv64x60_edac_init(void)
 {
 	int ret = 0;
 
 	printk(KERN_INFO "Marvell MV64x60 EDAC driver " MV64x60_REVISION "\n");
 	printk(KERN_INFO "\t(C) 2006-2007 MontaVista Software\n");
-	/* make sure error reporting method is sane */
-	switch (edac_op_state) {
-	case EDAC_OPSTATE_POLL:
-	case EDAC_OPSTATE_INT:
-		break;
-	default:
-		edac_op_state = EDAC_OPSTATE_INT;
-		break;
-	}
+
+	opstate_init();
 
 	ret = platform_driver_register(&mv64x60_mc_err_driver);
 	if (ret)
@@ -881,12 +1042,18 @@ static int __init mv64x60_edac_init(void)
 			"PCI1 err failed to register\n");
 #endif
 
+	ret = platform_driver_register(&mv64x60_device_err_driver);
+	if (ret)
+		printk(KERN_WARNING EDAC_MOD_STR
+			"Device err failed to register\n");
+
 	return ret;
 }
 module_init(mv64x60_edac_init);
 
 static void __exit mv64x60_edac_exit(void)
 {
+	platform_driver_unregister(&mv64x60_device_err_driver);
 #ifdef CONFIG_PCI
 	platform_driver_unregister(&mv64x60_pci0_err_driver);
 	platform_driver_unregister(&mv64x60_pci1_err_driver);
diff --git a/drivers/edac/mv64x60_edac.h b/drivers/edac/mv64x60_edac.h
index 587a86c..370a7b5 100644
--- a/drivers/edac/mv64x60_edac.h
+++ b/drivers/edac/mv64x60_edac.h
@@ -8,6 +8,11 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  *
+ * Additions for the defs and private structures for Device, 
+ * Communication, Ethernet and DMA Controllers,
+ * added by Cao Qingtao <qingtao.cao@windriver.com>,
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
  */
 #ifndef _MV64X60_EDAC_H_
 #define _MV64X60_EDAC_H_
@@ -120,6 +125,30 @@ struct mv64x60_pci_pdata {
 
 #endif				/* CONFIG_PCI */
 
+/* Device Interrupts Registers */
+#define MV64X60_DEV_INTR_CAUSE		0x00	/* 0x04d0 */
+#define MV64X60_DEV_INTR_MASK		0x04	/* 0x04d4 */
+#define MV64X60_DEV_INTR_ERR_ADDR	0x08	/* 0x04d8 */
+#define MV64X60_DEV_INTR_ERR_DATA	0x0c	/* 0x04dc */
+#define MV64X60_DEV_INTR_ERR_PAR	0x0e	/* 0x04e0 */
+
+#define MV64X60_DEV_INTR_MASK_DBurstErr	0x00000001
+#define MV64X60_DEV_INTR_MASK_DRdyErr	0x00000002
+#define MV64X60_DEV_INTR_MASK_PErr0	0x00000004
+#define MV64X60_DEV_INTR_MASK_PErr1	0x00000008
+#define MV64X60_DEV_INTR_MASK_PErr2	0x00000010
+#define MV64X60_DEV_INTR_MASK_PErr3	0x00000020
+
+#define MV64X60_DEV_INTR_MASK_VALUE	(MV64X60_DEV_INTR_MASK_DBurstErr | \
+					MV64X60_DEV_INTR_MASK_DRdyErr | \
+					MV64X60_DEV_INTR_MASK_PErr0 | \
+					MV64X60_DEV_INTR_MASK_PErr1 | \
+					MV64X60_DEV_INTR_MASK_PErr2 | \
+					MV64X60_DEV_INTR_MASK_PErr3)
+
+/* only bits[3:0] of the Device Error Parity Register are accessible */
+#define MV64X60_DEV_INTR_ERR_PAR_MASK	0x0000000f
+
 struct mv64x60_mc_pdata {
 	void __iomem *mc_vbase;
 	int total_mem;
@@ -142,4 +171,11 @@ struct mv64x60_sram_pdata {
 	int edac_idx;
 };
 
+struct mv64x60_device_pdata {
+        void __iomem *device_vbase;
+        const char *name;
+        int irq;
+        int edac_idx;
+};
+
 #endif
-- 
1.6.0.90.g436ed

