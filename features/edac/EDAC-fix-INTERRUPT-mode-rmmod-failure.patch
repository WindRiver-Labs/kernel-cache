From 21330d5976b254c3a51691e962d88f75f3b29330 Mon Sep 17 00:00:00 2001
From: Jason HU <yongqi.hu@windriver.com>
Date: Wed, 28 Apr 2010 02:49:12 -0700
Subject: [PATCH 4/4] EDAC: fix INTERRUPT mode rmmod failure

edac_device_ctl_info, edac_pci_ctl_info & mem_ctl_info structures all have
a member of delayed_work, which would be initialized and set up in POLL mode.
Likewise, these delayed works should be removed in POLL mode only. That is
to say, if EDAC works in INTERRUPT mode, there is no need to tear them down,
since they are not used at all.

Otherwise, they would make system hung. With the help of Magic SysRq we
could see that "rmmod" process hangs when deleting the timer in a delayed
work that has never been properly initialized:

telnet> send brk
(input "p" key)
SysRq : Show Regs
...
NIP [c003308c] lock_timer_base+0x30/0xa8
LR [c0033128] try_to_del_timer_sync+0x24/0xac
Call Trace:
[df365da0] [c036b70c] wait_for_common+0xd8/0x218 (unreliable)
[df365dc0] [c0033128] try_to_del_timer_sync+0x24/0xac
[df365de0] [c0034000] del_timer_sync+0x28/0x44
[df365df0] [e515de94] edac_device_workq_teardown+0x1c/0x70 [edac_core]
[df365e00] [e515dfbc] edac_device_del_device+0xd4/0x14c [edac_core]
[df365e20] [e518c484] mv64x60_dma_err_remove+0x34/0x74 [mv64x60_edac]
[df365e30] [c0212da4] platform_drv_remove+0x20/0x30
[df365e40] [c02116d4] __device_release_driver+0xa0/0xe8
...

edac_device_workq_teardown() should be bypassed in INTERRUPT mode. A further
investigation reveals that the delayed work in edac_pci_ctl_info and
mem_ctl_info bear the same problem too, they should be fixed in the same way.

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
Signed-off-by: Jason HU <yongqi.hu@windriver.com>
---
 drivers/edac/edac_device.c |    5 +++--
 drivers/edac/edac_mc.c     |    4 +++-
 drivers/edac/edac_pci.c    |    3 ++-
 3 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 4422638..259c4c8 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -608,12 +608,13 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 	mutex_unlock(&device_ctls_mutex);
 
 	/* clear workq processing on this instance */
-	edac_device_workq_teardown(edac_dev);
+	if (edac_dev->edac_check)
+		edac_device_workq_teardown(edac_dev);
 
 	/* Tear down the sysfs entries for this instance */
 	edac_device_remove_sysfs(edac_dev);
 
-	edac_printk(KERN_INFO, EDAC_MC,
+	edac_printk(KERN_INFO, EDAC_DEBUG,
 		"Removed device %d for %s %s: DEV %s\n",
 		edac_dev->dev_idx,
 		edac_dev->mod_name, edac_dev->ctl_name, edac_dev_name(edac_dev));
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index 8e1037b..3793fcd 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -595,7 +595,9 @@ struct mem_ctl_info *edac_mc_del_mc(struct device *dev)
 	mutex_unlock(&mem_ctls_mutex);
 
 	/* flush workq processes and remove sysfs */
-	edac_mc_workq_teardown(mci);
+	if (mci->edac_check)
+		edac_mc_workq_teardown(mci);
+
 	edac_remove_sysfs_mci_device(mci);
 
 	edac_printk(KERN_INFO, EDAC_MC,
diff --git a/drivers/edac/edac_pci.c b/drivers/edac/edac_pci.c
index efb5d56..5315e09 100644
--- a/drivers/edac/edac_pci.c
+++ b/drivers/edac/edac_pci.c
@@ -423,7 +423,8 @@ struct edac_pci_ctl_info *edac_pci_del_device(struct device *dev)
 	mutex_unlock(&edac_pci_ctls_mutex);
 
 	/* stop the workq timer */
-	edac_pci_workq_teardown(pci);
+	if (pci->edac_check)
+		edac_pci_workq_teardown(pci);
 
 	edac_printk(KERN_INFO, EDAC_PCI,
 		"Removed device %d for %s %s: DEV %s\n",
-- 
1.6.5.2

