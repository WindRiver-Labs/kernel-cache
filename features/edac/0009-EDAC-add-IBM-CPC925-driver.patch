From 321c6ad31cb8967de1e4ba736b371deea627fb0b Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Fri, 7 Nov 2008 14:23:52 -0500
Subject: [PATCH] EDAC: add IBM CPC925 driver

Add EDAC driver for IBM CPC925 chipset.
---
 drivers/edac/Kconfig       |    7 +
 drivers/edac/Makefile      |    1 +
 drivers/edac/cpc925_edac.c |  470 ++++++++++++++++++++++++++++++++++++++++++++
 drivers/edac/cpc925_edac.h |  126 ++++++++++++
 4 files changed, 604 insertions(+), 0 deletions(-)
 create mode 100644 drivers/edac/cpc925_edac.c
 create mode 100644 drivers/edac/cpc925_edac.h

diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index f19c302..e607b02 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -177,6 +177,13 @@ config EDAC_IBM_CPC925
 	tristate "IBM CPC925 Memory Controller (PPC970FX)"
 	depends on EDAC_MAPLE
 
+config EDAC_IBM_CPC925
+	tristate "IBM CPC925 Memory Controller (PPC970FX)"
+	depends on EDAC_MAPLE
+	help
+	  Support for error detection and correction on the
+	  IBM CPC925 memory controller (PPC970FX, Maple boards).
+
 config EDAC_AMD8131
 	tristate "AMD8131 HyperTransport PCI-X tunnel"
 	depends on PCI
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index a851ef1..d0e9845 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_EDAC_MPC85XX)		+= mpc85xx_edac.o
 obj-$(CONFIG_EDAC_MV64X60)		+= mv64x60_edac.o
 obj-$(CONFIG_EDAC_CELL)			+= cell_edac.o
 obj-$(CONFIG_EDAC_TEST_DEVICE)		+= test_device_edac.o
+obj-$(CONFIG_EDAC_IBM_CPC925)		+= cpc925_edac.o
 obj-$(CONFIG_EDAC_AMD8131)		+= amd8131_edac.o
 obj-$(CONFIG_EDAC_AMD8111)		+= amd8111_edac.o
 
diff --git a/drivers/edac/cpc925_edac.c b/drivers/edac/cpc925_edac.c
new file mode 100644
index 0000000..7cbe8a9
--- /dev/null
+++ b/drivers/edac/cpc925_edac.c
@@ -0,0 +1,470 @@
+/*
+ * cpc925_edac.c, IBM CPC925 Bridge and Memory controller EDAC kernel module
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors:	Benjamin Walsh <benjamin.walsh@windriver.com>
+ * 		Cao Qingtao <qingtao.cao@windriver.com>
+ * 		Hu Yongqi <yongqi.hu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/edac.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+#include "cpc925_edac.h"
+
+#define EDAC_CPC925_INT_SUPPORT 0	/* FIXME - turn off for now */
+
+#define TO_VOID_FUNCTOR(x) (void(*)(struct edac_device_ctl_info *edac_dev))(x)
+
+static void _dram_uecc_init(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIMASK) |=
+		PROCINT_LUECC_MASK | PROCINT_UUECC_MASK;
+	*(volatile u32*)(pdata->vbase + CPC925_MEMCTRL_MCCR) |=
+		DRAM_ECC_EN;
+}
+
+static void _dram_uecc_exit(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIMASK) &=
+		~(PROCINT_LUECC_MASK | PROCINT_UUECC_MASK);
+	*(volatile u32*)(pdata->vbase + CPC925_MEMCTRL_MCCR) &=
+		~(DRAM_ECC_EN);
+}
+
+static void _dram_cecc_init(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIMASK) |=
+		PROCINT_LCECC_MASK | PROCINT_UCECC_MASK;
+	*(volatile u32*)(pdata->vbase + CPC925_MEMCTRL_MCCR) |=
+		DRAM_ECC_EN;
+}
+
+static void _dram_cecc_exit(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIMASK) &=
+		~(PROCINT_LCECC_MASK | PROCINT_UCECC_MASK);
+	*(volatile u32*)(pdata->vbase + CPC925_MEMCTRL_MCCR) &=
+		~(DRAM_ECC_EN);
+}
+
+static void _cpu_init(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIMASK) |=
+		PROCINT_CPU_MASK;
+}
+
+static void _cpu_exit(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIMASK) &=
+		~(PROCINT_CPU_MASK);
+}
+
+static void _ht_init(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	*(volatile u32*)(pdata->vbase + CPC925_HT_ERR_ENUM) |=
+		HT_SERR | HT_CRC | HT_RESPONSE |
+		HT_EOC | HT_OVERFLOW | HT_PROTOCOL;
+}
+
+static void _ht_exit(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	*(volatile u32*)(pdata->vbase + CPC925_HT_ERR_ENUM) &=
+		~(HT_SERR | HT_CRC | HT_RESPONSE |
+		HT_EOC | HT_OVERFLOW | HT_PROTOCOL);
+}
+
+static void _dram_dump_regs(const void * const base, const u32 check_value)
+{
+	printk(KERN_INFO "MCK Reason          0x%08x\n", check_value);
+	printk(KERN_INFO "MCK Mask            0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_PROCINT_APIMASK));
+	printk(KERN_INFO "Mem Scrub Ctl       0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MSCR));
+	printk(KERN_INFO "Mem Scrub Rge Start 0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MSRSR));
+	printk(KERN_INFO "Mem Scrub Rge End   0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MSRER));
+	printk(KERN_INFO "Mem Scrub Pattern   0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MSPR));
+	printk(KERN_INFO "Mem Chk Ctrl        0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MCCR));
+	printk(KERN_INFO "Mem Chk Rge End     0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MCRER));
+	printk(KERN_INFO "Address             0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MEAR));
+	printk(KERN_INFO "Syndrome            0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MESR));
+}
+
+static int _dram_uecc_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	void *base = pdata->vbase;
+	u32 check_value;
+
+	check_value = CPC925_REG32BE_READ(base, CPC925_PROCINT_APIEXCP);
+	if(!check_value)
+		return 0;
+
+	if(!(check_value & (PROCINT_LUECC_MASK | PROCINT_UUECC_MASK))) {
+		return 0;
+	}
+	printk(KERN_INFO "DRAM UECC Fault\n"
+			 "DRAM UECC register dump:\n");
+	_dram_dump_regs(base, check_value);
+
+	/* Clear the fault */
+	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIEXCP) &=
+			~(PROCINT_LUECC_MASK | PROCINT_UUECC_MASK);
+
+	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+	return 1;
+}
+
+static int _dram_cecc_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	void *base = pdata->vbase;
+	u32 check_value;
+
+	check_value = CPC925_REG32BE_READ(base, CPC925_PROCINT_APIEXCP);
+	if(!check_value)
+		return 0;
+
+	if(!(check_value & (PROCINT_LCECC_MASK | PROCINT_UCECC_MASK))) {
+		return 0;
+	}
+	printk(KERN_INFO "DRAM CECC Fault\n"
+			 "DRAM CECC register dump:\n");
+	_dram_dump_regs(base, check_value);
+
+	/* Clear the fault */
+	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIEXCP) &=
+			~(PROCINT_LCECC_MASK | PROCINT_UCECC_MASK);
+
+	edac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);
+	return 1;
+}
+
+static int _cpu_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	void *base = pdata->vbase;
+	u32 check_value;
+
+	check_value = CPC925_REG32BE_READ(base, CPC925_PROCINT_APIEXCP);
+	if(!check_value)
+		return 0;
+
+	if(!(check_value & PROCINT_CPU_MASK)) {
+		return 0;
+	}
+	printk(KERN_INFO "Processor Interface Fault\n"
+			 "Processor Interface register dump:\n");
+	printk(KERN_INFO "MCK Reason          0x%08x\n", check_value);
+	printk(KERN_INFO "MCK Mask            0x%08x\n",
+		CPC925_REG32BE_READ(base, CPC925_PROCINT_APIMASK));
+
+	/* Clear the fault */
+	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIEXCP) &=
+				~(PROCINT_CPU_MASK);
+
+	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+	return 1;
+}
+
+static int _ht_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct cpc925_pdata *pdata = edac_dev->pvt_info;
+	void *base = pdata->vbase;
+	u32 bridge_ctrl, link_cfg_ctl, error_enum, link_error;
+
+	bridge_ctrl = CPC925_REG32BE_READ(base, CPC925_HT_BRIDGE_CTRL);
+	link_cfg_ctl = CPC925_REG32BE_READ(base, CPC925_HT_LINK_CFG_CTL);
+	error_enum = CPC925_REG32BE_READ(base, CPC925_HT_ERR_ENUM);
+	link_error = CPC925_REG32BE_READ(base, CPC925_HT_LINK_FREQ);
+
+	if(!((bridge_ctrl & HT_SERR) || (link_cfg_ctl & HT_LINK_CTL_ERR) ||
+		(error_enum & HT_ERR_ENUM_ERR) || (link_error & HT_LINK_ERR))) {
+		return 0;
+	}
+
+	printk(KERN_INFO "HT Fault\n"
+			 "HT register dump:\n");
+	printk(KERN_INFO "Bridge Control         0x%08x\n", bridge_ctrl);
+	printk(KERN_INFO "Link Config Control    0x%08x\n", link_cfg_ctl);
+	printk(KERN_INFO "Error Enumeration      0x%08x\n", error_enum);
+	printk(KERN_INFO "Link Error             0x%08x\n", link_error);
+
+	if (bridge_ctrl & HT_SERR) {
+		*(volatile u32*)(base + CPC925_HT_BRIDGE_CTRL) |= HT_SERR;
+	}
+	if (error_enum & HT_CHAIN_ERR) {
+		*(volatile u32*)(base + CPC925_HT_BRIDGE_CTRL) |= HT_SBRESET;
+	}
+	if (error_enum & HT_RESPONSE_ERR) {
+		*(volatile u32*)(base + CPC925_HT_ERR_ENUM) &= ~HT_RESPONSE_ERR;
+	}
+	if(link_cfg_ctl & HT_CRC_ERR) {
+		*(volatile u32*)(base + CPC925_HT_LINK_CFG_CTL) |= HT_CRC_ERR;
+	}
+	if(link_cfg_ctl & HT_LINK_FAIL) {
+		*(volatile u32*)(base + CPC925_HT_LINK_CFG_CTL) &=
+					~HT_LINK_FAIL;
+	}
+	if(link_error & HT_LINK_ERR) {
+		*(volatile u32*)(base + CPC925_HT_LINK_FREQ) &= ~HT_LINK_ERR;
+	}
+
+	edac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);
+	return 1;
+}
+
+static int _check_all(struct edac_device_ctl_info *edac_dev)
+{
+	int found_fault = 0;
+
+	if(_dram_uecc_check(edac_dev)) {
+		found_fault = 1;
+	}
+	if(_dram_cecc_check(edac_dev)) {
+		found_fault = 1;
+	}
+	if(_cpu_check(edac_dev)) {
+		found_fault = 1;
+	}
+	if(_ht_check(edac_dev)) {
+		found_fault = 1;
+	}
+
+	return found_fault;
+}
+
+static void _init_all(struct edac_device_ctl_info *edac_dev)
+{
+	_dram_cecc_init(edac_dev);
+	_dram_uecc_init(edac_dev);
+	_cpu_init(edac_dev);
+	_ht_init(edac_dev);
+}
+
+static void _exit_all(struct edac_device_ctl_info *edac_dev)
+{
+	_dram_cecc_exit(edac_dev);
+	_dram_uecc_exit(edac_dev);
+	_cpu_exit(edac_dev);
+	_ht_exit(edac_dev);
+}
+
+#if EDAC_CPC925_INT_SUPPORT
+static irqreturn_t _isr(int irq, void *dev_id)
+{
+	struct edac_device_ctl_info *edac_dev =
+		(struct edac_device_ctl_info *)dev_id;
+
+	if(_check_all(edac_dev)) {
+		return IRQ_HANDLED;
+	} else {
+		return IRQ_NONE;
+	}
+}
+#endif
+
+static int __devinit cpc925_probe(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev;
+	struct cpc925_pdata *pdata;
+	struct resource *r;
+	int res = 0;
+
+	debugf0("%s(): potential platform device found!\n", __func__);
+
+	if (!devres_open_group(&pdev->dev, cpc925_probe, GFP_KERNEL))
+		return -ENOMEM;
+
+	edac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),
+					      "cpc925", 1, NULL, 0, 0, NULL, 0,
+					      maple_edac_dev_idx);
+	if (!edac_dev) {
+		devres_release_group(&pdev->dev, cpc925_probe);
+		return -ENOMEM;
+	}
+
+	pdata = edac_dev->pvt_info;
+	pdata->name = pdev->name;
+	pdata->irq = NO_IRQ;
+	edac_dev->dev = &pdev->dev;
+	platform_set_drvdata(pdev, edac_dev);
+	edac_dev->dev_name = pdev->dev.bus_id;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		printk(KERN_ERR "%s: Unable to get resource for "
+		       "CPC925\n", __func__);
+		res = -ENOENT;
+		goto err;
+	}
+
+	if (!devm_request_mem_region(&pdev->dev,
+				     r->start,
+				     r->end - r->start + 1,
+				     pdata->name)) {
+		printk(KERN_ERR "%s: Error while request mem region\n",
+		       __func__);
+		res = -EBUSY;
+		goto err;
+	}
+
+	pdata->vbase = devm_ioremap(&pdev->dev,
+				    r->start,
+				    r->end - r->start + 1);
+	if (!pdata->vbase) {
+		printk(KERN_ERR "%s: Unable to setup CPC925\n",
+		       __func__);
+		res = -ENOMEM;
+		goto err;
+	}
+
+	_init_all(edac_dev);
+
+	edac_dev->mod_name = CPC925_EDAC_MOD_STR;
+	edac_dev->ctl_name = pdata->name;
+
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		edac_dev->edac_check = TO_VOID_FUNCTOR(_check_all);
+
+	pdata->edac_idx = maple_edac_dev_idx++;
+
+	if (edac_device_add_device(edac_dev) > 0) {
+		debugf3("%s(): failed edac_device_add_device()\n", __func__);
+		goto err;
+	}
+
+/*
+ * So far there is no "interrupt" attribute in the host bridge DTB node,
+ * if we ever need on IRQ number, we could manually set it up in
+ * maple_cpc925_edac_setup().
+ */
+#if EDAC_CPC925_INT_SUPPORT
+	if (edac_op_state == EDAC_OPSTATE_INT) {
+		pdata->irq = platform_get_irq(pdev, 0);
+		res = devm_request_irq(&pdev->dev,
+				       pdata->irq,
+				       _isr,
+				       IRQF_DISABLED,
+				       "[EDAC] CPC925",
+				       edac_dev);
+		if (res < 0) {
+			printk(KERN_ERR
+			       "%s: Unable to request irq %d for "
+			       "CPC925 EDAC\n", __func__, pdata->irq);
+			res = -ENODEV;
+			goto err2;
+		}
+
+		printk(KERN_INFO CPC925_EDAC_MOD_STR
+			" acquired irq %d for CPC925 EDAC\n",
+		       pdata->irq);
+	}
+#endif
+	devres_remove_group(&pdev->dev, cpc925_probe);
+
+	/* get this far and it's successful */
+	debugf0("%s(): success\n", __func__);
+
+	return 0;
+
+
+#if EDAC_CPC925_INT_SUPPORT
+err2:
+#endif
+	edac_device_del_device(&pdev->dev);
+err:
+	devres_release_group(&pdev->dev, cpc925_probe);
+	edac_device_free_ctl_info(edac_dev);
+	return res;
+}
+
+static int cpc925_remove(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev = platform_get_drvdata(pdev);
+
+	debugf0("%s()\n", __func__);
+
+	_exit_all(edac_dev);
+
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(edac_dev);
+
+	return 0;
+}
+
+static struct platform_driver cpc925_edac_driver = {
+	.probe = cpc925_probe,
+	.remove = cpc925_remove,
+	.driver = {
+		   .name = "cpc925_edac",
+	}
+};
+
+static int __init cpc925_edac_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "IBM CPC925 EDAC driver " CPC925_EDAC_REVISION "\n");
+	printk(KERN_INFO "\t(C) 2008 Wind River Systems, Inc\n");
+
+	opstate_init();
+
+	ret = platform_driver_register(&cpc925_edac_driver);
+	if (ret) {
+		printk(KERN_WARNING CPC925_EDAC_MOD_STR
+			"CPC925 failed to register\n");
+	}
+
+	return ret;
+}
+module_init(cpc925_edac_init);
+
+static void __exit cpc925_edac_exit(void)
+{
+	platform_driver_unregister(&cpc925_edac_driver);
+}
+module_exit(cpc925_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Wind River (http://windriver.com) Benjamin Walsh");
+MODULE_DESCRIPTION("IBM CPC925 Bridge and MC EDAC kernel module");
+
+module_param(edac_op_state, int, 0444);
+MODULE_PARM_DESC(edac_op_state,
+		 "EDAC Error Reporting state: 0=Poll, 2=Interrupt");
diff --git a/drivers/edac/cpc925_edac.h b/drivers/edac/cpc925_edac.h
new file mode 100644
index 0000000..43a63cd
--- /dev/null
+++ b/drivers/edac/cpc925_edac.h
@@ -0,0 +1,126 @@
+/*
+ * cpc925_edac.h, EDAC defs for IBM CPC925 bridge and memory controller chip
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors:	Benjamin Walsh <benjamin.walsh@windriver.com>
+ * 		Cao Qingtao <qingtao.cao@windriver.com>
+ * 		Hu Yongqi <yongqi.hu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _CPC925_EDAC_H_
+#define _CPC925_EDAC_H_
+
+#include "maple_edac.h"
+
+#define CPC925_EDAC_REVISION	" Ver: 1.0.0 " __DATE__
+#define CPC925_EDAC_MOD_STR	"cpc925_edac"
+
+#define cpc925_printk(level, fmt, arg...) \
+	edac_printk(level, "CPC925", fmt, ##arg)
+
+#define cpc925_mc_printk(mci, level, fmt, arg...) \
+	edac_mc_chipset_printk(mci, level, "CPC925", fmt, ##arg)
+
+#define CPC925_REG32BE_READ(base,offset)	\
+	be32_to_cpu(*(volatile u32 *)(base + offset))
+
+#define CPC925_PHYS_BASE	0xf8000000
+#define CPC925_PHYS_SIZE	0x01000000
+
+/* config and status register */
+#define CPC925_HT_ERR_ENUM	0x00070140
+
+/* status registers */
+#define CPC925_HT_BRIDGE_CTRL	0x00070300
+#define CPC925_HT_LINK_CFG_CTL	0x00070110
+#define CPC925_HT_LINK_FREQ	0x00070120
+
+enum cpc925_ht_bits {
+	HT_SERR		= BIT(0),
+	HT_CRC		= BIT(1),
+	HT_RESPONSE	= BIT(2),
+	HT_EOC		= BIT(3),
+	HT_OVERFLOW	= BIT(4),
+	HT_PROTOCOL	= BIT(5),
+	HT_SBRESET	= BIT(9),
+	HT_CRC_ERR	= (BIT(20) | BIT(21) | BIT(22) | BIT(23)),
+	HT_LINK_FAIL	= BIT(27),
+	HT_LINK_CTL_ERR	= (HT_CRC_ERR | HT_LINK_FAIL),
+	HT_RESPONSE_ERR	= BIT(6),
+	HT_CHAIN_ERR	= BIT(7),
+	HT_ERR_ENUM_ERR	= (HT_RESPONSE_ERR | HT_CHAIN_ERR),
+	HT_EOC_ERR	= BIT(17),
+	HT_OVERFLOW_ERR	= BIT(18),
+	HT_PROTOCOL_ERR	= BIT(19),
+	HT_LINK_ERR	= (HT_EOC_ERR | HT_OVERFLOW_ERR | HT_PROTOCOL_ERR)
+};
+
+#define CPC925_PROCINT_APIMASK	0x00030070
+#define CPC925_PROCINT_APIEXCP	0x00030060
+
+enum cpc925_procint_bits {
+	PROCINT_DART		= BIT(0),
+	PROCINT_ADDR0_HS	= BIT(1),
+	PROCINT_ADDR1_HS	= BIT(2),
+	PROCINT_SNOOP		= BIT(3),
+	PROCINT_DERR		= BIT(4),
+	PROCINT_ADDR0_MASK	= BIT(5),
+	PROCINT_ADDR1_MASK	= BIT(6),
+	PROCINT_LUECC_MASK	= BIT(8),
+	PROCINT_LCECC_MASK	= BIT(9),
+	PROCINT_UUECC_MASK	= BIT(10),
+	PROCINT_UCECC_MASK	= BIT(11),
+
+	/* masks */
+	PROCINT_CPU_MASK	= (PROCINT_DART |
+				PROCINT_ADDR0_HS | PROCINT_ADDR1_HS |
+				PROCINT_SNOOP | PROCINT_DERR |
+				PROCINT_ADDR0_MASK | PROCINT_ADDR1_MASK),
+};
+
+/* config and status register */
+#define CPC925_MEMCTRL_MCCR	0x00002440
+
+/* status registers */
+#define CPC925_MEMCTRL_MSCR	0x00002400
+#define CPC925_MEMCTRL_MSRSR	0x00002410
+#define CPC925_MEMCTRL_MSRER	0x00002420
+#define CPC925_MEMCTRL_MSPR	0x00002430
+#define CPC925_MEMCTRL_MCRER	0x00002450
+#define CPC925_MEMCTRL_MEAR	0x00002460
+#define CPC925_MEMCTRL_MESR	0x00002470
+
+enum cpc925_dram_bits {
+	DRAM_ECC_EN	= BIT(0)
+};
+
+/*
+ * There are supposed to be two more other EDAC devices for MAPLE_HT and
+ * MAPLE_PROCESSOR_INTERFACE. However, due to there is only one DTB node
+ * for the whole CPC925 Control Space in the DTB tree generated by firmware,
+ * we can't split between them but use one base address to access registers
+ * on all of them.
+ */
+struct cpc925_pdata {
+	void __iomem *vbase;
+	int total_mem;
+	const char *name;
+	int irq;
+	int edac_idx;
+};
+
+#endif
-- 
1.6.0.3

