From 4248a6d41af39d6c411843d2cd5b958750037db7 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Fri, 7 Nov 2008 14:22:27 -0500
Subject: [PATCH] EDAC: add AMD8131 driver

Add EDAC driver for AMD8131 chipset.
---
 drivers/edac/Kconfig        |    7 +
 drivers/edac/Makefile       |    1 +
 drivers/edac/amd8131_edac.c |  317 +++++++++++++++++++++++++++++++++++++++++++
 drivers/edac/amd8131_edac.h |   95 +++++++++++++
 4 files changed, 420 insertions(+), 0 deletions(-)
 create mode 100644 drivers/edac/amd8131_edac.c
 create mode 100644 drivers/edac/amd8131_edac.h

diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index e5909df..f749668 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -178,6 +178,13 @@ config EDAC_MAPLE
 	help
 	  Global variables for Maple board
 
+config EDAC_AMD8131
+	tristate "AMD8131 HyperTransport PCI-X tunnel"
+	depends on PCI && EDAC_MAPLE
+	help
+	  Support for error detection and correction on the
+	  AMD8131 HT PCI-X tunnel chip.
+
 config EDAC_AMD8111
 	tristate "AMD8111 HyperTransport I/O Hub"
 	depends on PCI && EDAC_MAPLE
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index bb7c5cc..81be0b3 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -35,5 +35,6 @@ obj-$(CONFIG_EDAC_MV64X60)		+= mv64x60_edac.o
 obj-$(CONFIG_EDAC_CELL)			+= cell_edac.o
 obj-$(CONFIG_EDAC_TEST_DEVICE)		+= test_device_edac.o
 obj-$(CONFIG_EDAC_MAPLE)		+= maple_edac.o
+obj-$(CONFIG_EDAC_AMD8131)		+= amd8131_edac.o
 obj-$(CONFIG_EDAC_AMD8111)		+= amd8111_edac.o
 
diff --git a/drivers/edac/amd8131_edac.c b/drivers/edac/amd8131_edac.c
new file mode 100644
index 0000000..e78c653
--- /dev/null
+++ b/drivers/edac/amd8131_edac.c
@@ -0,0 +1,317 @@
+/*
+ * amd8131_edac.c, AMD8131 hypertransport chip EDAC kernel module
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors:	Benjamin Walsh <benjamin.walsh@windriver.com>
+ * 		Cao Qingtao <qingtao.cao@windriver.com>
+ * 		Hu Yongqi <yongqi.hu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
+#include <linux/edac.h>
+#include <linux/pci_ids.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+#include "amd8131_edac.h"
+
+#define AMD8131_EDAC_REVISION	" Ver: 1.0.0 " __DATE__
+#define AMD8131_EDAC_MOD_STR	"amd8131_edac"
+
+static char * const bridge_str[] = {
+	[NORTH_A] = "NORTH A",
+	[NORTH_B] = "NORTH B",
+	[SOUTH_A] = "SOUTH A",
+	[SOUTH_B] = "SOUTH B",
+	[NO_BRIDGE] = "NO BRIDGE",
+};
+
+static struct amd8131_dev_info amd8131_devices[] = {
+	{
+	.inst = NORTH_A,
+	.devfn = DEVFN_PCIX_BRIDGE_NORTH_A,
+	.ctl_name = "NORTH_A",
+	},
+	{
+	.inst = NORTH_B,
+	.devfn = DEVFN_PCIX_BRIDGE_NORTH_B,
+	.ctl_name = "NORTH_B",
+	},
+	{
+	.inst = SOUTH_A,
+	.devfn = DEVFN_PCIX_BRIDGE_SOUTH_A,
+	.ctl_name = "SOUTH_A",
+	},
+	{
+	.inst = SOUTH_B,
+	.devfn = DEVFN_PCIX_BRIDGE_SOUTH_B,
+	.ctl_name = "SOUTH_B",
+	},
+	{.inst = NO_BRIDGE,},
+};
+
+
+/*
+ * FIXME: FHDD PCI3_init() would try to setup PMC device for PCI3
+ * as well, why? (PCI_DEVICE_ID_MOTOROLA_HARRIER)
+ */
+static void amd8131_apic_init(struct amd8131_dev_info *dev_info)
+{
+	u32 val32;
+
+	/* ask for SERR and PERR errors */
+	if (pci_read_config_dword(dev_info->dev, REG_INT_CTLR, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 |= INT_CTLR_PERR | INT_CTLR_SERR;
+	if (pci_write_config_dword(dev_info->dev, REG_INT_CTLR, val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	/* ask to generate an NMI if this is the operational state */
+	if (EDAC_OPSTATE_NMI == edac_op_state) {
+		if (pci_read_config_dword(dev_info->dev, REG_MISC_II, &val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+		val32 |= MISC_II_NMI;
+		if (pci_write_config_dword(dev_info->dev, REG_MISC_II, val32))
+			printk(KERN_ERR "PCI Access Error\n");
+	}
+}
+
+static void amd8131_apic_exit(struct amd8131_dev_info *dev_info)
+{
+	u32 val32;
+
+	/* stop asking for SERR and PERR errors */
+	if (pci_read_config_dword(dev_info->dev, REG_INT_CTLR, &val32)) {
+		printk (KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 &= ~(INT_CTLR_PERR | INT_CTLR_SERR);
+	if (pci_write_config_dword(dev_info->dev, REG_INT_CTLR, val32)) {
+		printk (KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	/* stop asking to generate an NMI; doesn't hurt even
+	 * if EDAC is not in NMI opstate */
+	if (pci_read_config_dword(dev_info->dev, REG_MISC_II, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 &= ~MISC_II_NMI;
+	if (pci_write_config_dword(dev_info->dev, REG_MISC_II, val32))
+		printk(KERN_ERR "PCI Access Error\n");
+}
+
+static void amd8131_apic_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct amd8131_dev_info *dev_info = edac_dev->pvt_info;
+	struct pci_dev *dev = dev_info->dev;
+	u32 val32;
+
+	if (pci_read_config_dword(dev, REG_MEM_LIM, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	if (val32 & MEM_LIMIT_MASK) {
+		printk(KERN_INFO "Error(s) in mem limit register on %s bridge\n",
+			dev_info->ctl_name);
+		printk(KERN_INFO "DPE: %d, RSE: %d, RMA: %d\n"
+			"RTA: %d, STA: %d, MDPE: %d\n",
+			val32 & MEM_LIMIT_DPE,
+			val32 & MEM_LIMIT_RSE,
+			val32 & MEM_LIMIT_RMA,
+			val32 & MEM_LIMIT_RTA,
+			val32 & MEM_LIMIT_STA,
+			val32 & MEM_LIMIT_MDPE);
+
+		val32 |= MEM_LIMIT_MASK;
+		if (pci_write_config_dword(dev, REG_MEM_LIM, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+	}
+}
+
+static struct amd8131_info amd8131_chipset = {
+	.err_dev = PCI_DEVICE_ID_AMD_8131_APIC,
+	.devices = amd8131_devices,
+	.init = amd8131_apic_init,
+	.exit = amd8131_apic_exit,
+	.check = amd8131_apic_check,
+};
+
+
+/*
+ * There are 4 instances of one type of PCI device that share the same
+ * PCI Device ID, so amd8131_probe() would be called by kernel 4 times,
+ * with different address of pci_dev for each of them each time.
+ */
+static int amd8131_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	struct amd8131_dev_info *dev_info;
+
+	debugf0("EDAC devfn = 0x%x (%d)\n",dev->devfn,dev->devfn);
+	for (dev_info = amd8131_chipset.devices; dev_info->inst != NO_BRIDGE; dev_info++)
+		if (dev_info->devfn == dev->devfn)
+			break;
+
+	if (dev_info->inst == NO_BRIDGE) /* should never happen */
+		return -ENODEV;
+
+	/*
+	 * We can't call pci_get_device() as we are used to do because
+	 * there are 4 of them but pci_dev_get() instead.
+	 */
+	dev_info->dev = pci_dev_get(dev);
+
+	if (pci_enable_device(dev_info->dev)) {
+		pci_dev_put(dev_info->dev);
+		printk(KERN_ERR "failed to enable:"
+			"vendor %x, device %x, devfn %x, name %s\n",
+			PCI_VENDOR_ID_AMD, amd8131_chipset.err_dev,
+			dev_info->devfn, dev_info->ctl_name);
+		return -ENODEV;
+	}
+
+	printk("EDAC %s-%s:%d\n",__FILE__,__FUNCTION__,__LINE__);
+	/*
+	 * we do not allocate extra private structure for
+	 * edac_device_ctl_info, but make use of existing
+	 * one instead.
+	*/
+	dev_info->edac_dev =
+		edac_device_alloc_ctl_info(0, dev_info->ctl_name, 1,
+					   NULL, 0, 0,
+					   NULL, 0, maple_edac_dev_idx);
+	if (!dev_info->edac_dev)
+		return -ENOMEM;
+
+	dev_info->edac_dev->pvt_info = dev_info;
+	dev_info->edac_dev->dev = &dev_info->dev->dev;
+	dev_info->edac_dev->mod_name = AMD8131_EDAC_MOD_STR;
+	dev_info->edac_dev->ctl_name = dev_info->ctl_name;
+	dev_info->edac_dev->dev_name = dev_info->dev->dev.bus_id;
+
+	/* FIXME: so far we only support POLL mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		dev_info->edac_dev->edac_check = amd8131_chipset.check;
+	else if ((edac_op_state == EDAC_OPSTATE_INT)) {
+		dev_info->irq = dev_info->dev->irq;
+		/*
+		 * instantiate EDAC NMI handler, or
+		 * register interrupt handler
+		 *
+		 * request_irq(dev_info->irq, amd8131_chipset.isr,
+				IRQF_DISABLED, "[EDAC] dev_info->ctl_name",
+				dev_info->edac_dev);
+		 */
+	}
+
+	if (amd8131_chipset.init)
+		amd8131_chipset.init(dev_info);
+
+	if (edac_device_add_device(dev_info->edac_dev) > 0) {
+		printk(KERN_ERR "failed edac_device_add_device() for %s\n",
+			dev_info->ctl_name);
+		edac_device_free_ctl_info(dev_info->edac_dev);
+		return -ENODEV;
+	}
+
+	dev_info->edac_idx = maple_edac_dev_idx++;
+
+	printk(KERN_INFO "added one device on AMD8131 "
+		"vendor %x, device %x, devfn %x, name %s\n",
+		PCI_VENDOR_ID_AMD, amd8131_chipset.err_dev,
+		dev_info->devfn, dev_info->ctl_name);
+
+	return 0;
+}
+
+static void amd8131_remove(struct pci_dev *dev)
+{
+	struct amd8131_dev_info *dev_info;
+
+	for (dev_info = amd8131_chipset.devices; dev_info->inst != NO_BRIDGE; dev_info++)
+		if (dev_info->devfn == dev->devfn)
+			break;
+
+	if (dev_info->inst == NO_BRIDGE) /* should never happen */
+		return;
+
+	if (dev_info->edac_dev) {
+		edac_device_del_device(dev_info->edac_dev->dev);
+		edac_device_free_ctl_info(dev_info->edac_dev);
+	}
+
+	if (amd8131_chipset.exit)
+		amd8131_chipset.exit(dev_info);
+
+	pci_dev_put(dev_info->dev);
+}
+
+static const struct pci_device_id amd8131_edac_pci_tbl[] = {
+	{
+	PCI_VEND_DEV(AMD, 8131_APIC),
+	PCI_ANY_ID,		/* subvendor */
+	PCI_ANY_ID,		/* subdevice */
+	0,			/* class */
+	0,			/* class_mark */
+	0			/* driver private data - unused for now */
+	},
+	{ 0,0,0,0,0,0,0 }	/* table is NULL-terminated */
+};
+MODULE_DEVICE_TABLE(pci, amd8131_edac_pci_tbl);
+
+static struct pci_driver amd8131_edac_driver = {
+	.name = AMD8131_EDAC_MOD_STR,
+	.probe = amd8131_probe,
+	.remove = amd8131_remove,
+	.id_table = amd8131_edac_pci_tbl,
+};
+
+static int __init amd8131_edac_init(void)
+{
+	opstate_init();
+
+	return pci_register_driver(&amd8131_edac_driver);
+}
+
+static void __exit amd8131_edac_exit(void)
+{
+	pci_unregister_driver(&amd8131_edac_driver);
+}
+
+module_init(amd8131_edac_init);
+module_exit(amd8131_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Wind River (http://windriver.com) Benjamin Walsh\n");
+MODULE_DESCRIPTION("AMD8131 hypertransport chip EDAC kernel module");
+
diff --git a/drivers/edac/amd8131_edac.h b/drivers/edac/amd8131_edac.h
new file mode 100644
index 0000000..f8e9cef
--- /dev/null
+++ b/drivers/edac/amd8131_edac.h
@@ -0,0 +1,95 @@
+/*
+ * amd8131_edac.h, EDAC defs for AMD8131 hypertransport chip
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors:	Benjamin Walsh <benjamin.walsh@windriver.com>
+ * 		Cao Qingtao <qingtao.cao@windriver.com>
+ * 		Hu Yongqi <yongqi.hu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+
+#ifndef _AMD8131_EDAC_H_
+#define _AMD8131_EDAC_H_
+
+#include "maple_edac.h"
+
+#define DEVFN_PCIX_BRIDGE_NORTH_A	(8+1)
+#define DEVFN_PCIX_BRIDGE_NORTH_B	(16+1)
+#define DEVFN_PCIX_BRIDGE_SOUTH_A	(24+1)
+#define DEVFN_PCIX_BRIDGE_SOUTH_B	(32+1)
+
+#define REG_MEM_LIM	0x1c
+#define REG_INT_CTLR	0x3c
+#define REG_MISC_II	0x44
+
+enum int_ctlr_bits {
+	INT_CTLR_PERR = BIT(16),
+	INT_CTLR_SERR = BIT(17)
+};
+
+enum misc_ii_bits {
+	MISC_II_NMI = BIT(0)
+};
+
+enum mem_limit_bits {
+	MEM_LIMIT_DPE 	= BIT(31),
+	MEM_LIMIT_RSE 	= BIT(30),
+	MEM_LIMIT_RMA 	= BIT(29),
+	MEM_LIMIT_RTA 	= BIT(28),
+	MEM_LIMIT_STA	= BIT(27),
+	MEM_LIMIT_MDPE	= BIT(24),
+	MEM_LIMIT_MASK	= MEM_LIMIT_DPE|MEM_LIMIT_RSE|MEM_LIMIT_RMA|
+				MEM_LIMIT_RTA|MEM_LIMIT_STA|MEM_LIMIT_MDPE
+};
+
+enum pcix_bridge_inst {
+	NORTH_A = 0,
+	NORTH_B = 1,
+	SOUTH_A = 2,
+	SOUTH_B = 3,
+	NO_BRIDGE = 4
+};
+
+struct amd8131_dev_info {
+	int devfn;
+	enum pcix_bridge_inst inst;
+	struct pci_dev *dev;
+	int edac_idx;	/* device index */
+	int irq;
+	char *ctl_name;
+	struct edac_device_ctl_info *edac_dev;
+};
+
+/*
+ * There are 4 instances of one type of PCI Device on AMD8131 chipset,
+ * D1F1, D2F1, D3F1, D4F1, which have the same PCI Device ID and could
+ * be discrimated by their pci_dev->devfn.
+ * They share the same set of init/check/exit methods, and their private
+ * structures are collected in the devices[] array.
+ */
+struct amd8131_info {
+	u16 err_dev;	/* PCI Device ID for AMD8131 APIC*/
+	struct amd8131_dev_info *devices;
+	void (*init)(struct amd8131_dev_info *dev_info);
+	void (*exit)(struct amd8131_dev_info *dev_info);
+	void (*check)(struct edac_device_ctl_info *edac_dev);
+	/*FIXME: do we need register interrupt handler for a PCI device ?*/
+	/* irqreturn_t (*isr)(int irq, void *edac_dev); */
+};
+
+#endif /* _AMD8131_EDAC_H_ */
+
-- 
1.5.5.1

