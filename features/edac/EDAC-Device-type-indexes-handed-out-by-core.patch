From 3862a076578c934223b58704015a8a06c4c2f35d Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 13 Nov 2008 14:24:07 -0500
Subject: [PATCH] EDAC - Device type indexes handed out by core

Added support in core EDAC so that it hands out device
indexes instead of having each driver create its own
index variable. This was problematic with the Maple
(6101) since it has three EDAC drivers, and they had
to coordinate these indexes, causing the drivers to
be dependent on the Maple board, when the devices
could really be used on other boards.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 drivers/edac/edac_core.h   |    5 ++++-
 drivers/edac/edac_device.c |   15 +++++++++++++++
 drivers/edac/edac_mc.c     |   15 +++++++++++++++
 drivers/edac/edac_pci.c    |   15 +++++++++++++++
 4 files changed, 49 insertions(+), 1 deletions(-)

diff --git a/drivers/edac/edac_core.h b/drivers/edac/edac_core.h
index 7c7af16..56d394b 100644
--- a/drivers/edac/edac_core.h
+++ b/drivers/edac/edac_core.h
@@ -631,7 +631,7 @@ struct edac_device_ctl_info {
 
 /*
  * The alloc() and free() functions for the 'edac_device' control info
- * structure. A MC driver will allocate one of these for each edac_device
+ * structure. A driver will allocate one of these for each edac_device
  * it is going to control/register with the EDAC CORE.
  */
 extern struct edac_device_ctl_info *edac_device_alloc_ctl_info(
@@ -774,6 +774,7 @@ static inline void pci_write_bits32(struct pci_dev *pdev, int offset,
 
 extern struct mem_ctl_info *edac_mc_alloc(unsigned sz_pvt, unsigned nr_csrows,
 					  unsigned nr_chans, int edac_index);
+extern int edac_mc_alloc_index(void);
 extern int edac_mc_add_mc(struct mem_ctl_info *mci);
 extern void edac_mc_free(struct mem_ctl_info *mci);
 extern struct mem_ctl_info *edac_mc_find(int idx);
@@ -813,6 +814,7 @@ extern void edac_mc_handle_fbd_ce(struct mem_ctl_info *mci, unsigned int csrow,
 /*
  * edac_device APIs
  */
+extern int edac_device_alloc_index(void);
 extern int edac_device_add_device(struct edac_device_ctl_info *edac_dev);
 extern struct edac_device_ctl_info *edac_device_del_device(struct device *dev);
 extern void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
@@ -831,6 +833,7 @@ extern void edac_pci_free_ctl_info(struct edac_pci_ctl_info *pci);
 extern void edac_pci_reset_delay_period(struct edac_pci_ctl_info *pci,
 				unsigned long value);
 
+extern int edac_pci_alloc_index(void);
 extern int edac_pci_add_device(struct edac_pci_ctl_info *pci, int edac_idx);
 extern struct edac_pci_ctl_info *edac_pci_del_device(struct device *dev);
 
diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 5fcd3d8..372813d 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -28,6 +28,7 @@
 #include <linux/workqueue.h>
 #include <asm/uaccess.h>
 #include <asm/page.h>
+#include <asm/atomic.h>
 
 #include "edac_core.h"
 #include "edac_module.h"
@@ -37,6 +38,7 @@
  */
 static DEFINE_MUTEX(device_ctls_mutex);
 static LIST_HEAD(edac_device_list);
+static atomic_t device_indexes = ATOMIC_INIT(0);
 
 #ifdef CONFIG_EDAC_DEBUG
 static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
@@ -485,6 +487,19 @@ void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 }
 
 /**
+ * edac_device_alloc_index: Allocate a unique device index number
+ *
+ * Return:
+ *	allocated index number
+ *
+ */
+int edac_device_alloc_index(void)
+{
+	return (atomic_inc_return(&device_indexes) - 1);
+}
+EXPORT_SYMBOL(edac_device_alloc_index);
+
+/**
  * edac_device_add_device: Insert the 'edac_dev' structure into the
  * edac_device global list and create sysfs entries associated with
  * edac_device structure.
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index d110392..d86d789 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -31,12 +31,14 @@
 #include <asm/uaccess.h>
 #include <asm/page.h>
 #include <asm/edac.h>
+#include <asm/atomic.h>
 #include "edac_core.h"
 #include "edac_module.h"
 
 /* lock to memory controller's control array */
 static DEFINE_MUTEX(mem_ctls_mutex);
 static LIST_HEAD(mc_devices);
+static atomic_t mc_indexes = ATOMIC_INIT(0);
 
 #ifdef CONFIG_EDAC_DEBUG
 
@@ -459,6 +461,19 @@ struct mem_ctl_info *edac_mc_find(int idx)
 EXPORT_SYMBOL(edac_mc_find);
 
 /**
+ * edac_mc_alloc_index: Allocate a unique MC index number
+ *
+ * Return:
+ *	allocated index number
+ *
+ */
+int edac_mc_alloc_index(void)
+{
+	return (atomic_inc_return(&mc_indexes) - 1);
+}
+EXPORT_SYMBOL(edac_mc_alloc_index);
+
+/**
  * edac_mc_add_mc: Insert the 'mci' structure into the mci global list and
  *                 create sysfs entries associated with mci structure
  * @mci: pointer to the mci structure to be added to the list
diff --git a/drivers/edac/edac_pci.c b/drivers/edac/edac_pci.c
index 22ec9d5..893f378 100644
--- a/drivers/edac/edac_pci.c
+++ b/drivers/edac/edac_pci.c
@@ -24,12 +24,14 @@
 #include <linux/workqueue.h>
 #include <asm/uaccess.h>
 #include <asm/page.h>
+#include <asm/atomic.h>
 
 #include "edac_core.h"
 #include "edac_module.h"
 
 static DEFINE_MUTEX(edac_pci_ctls_mutex);
 static LIST_HEAD(edac_pci_list);
+static atomic_t pci_indexes = ATOMIC_INIT(0);
 
 /*
  * edac_pci_alloc_ctl_info
@@ -317,6 +319,19 @@ void edac_pci_reset_delay_period(struct edac_pci_ctl_info *pci,
 }
 EXPORT_SYMBOL_GPL(edac_pci_reset_delay_period);
 
+/**
+ * edac_pci_alloc_index: Allocate a unique PCI index number
+ *
+ * Return:
+ *	allocated index number
+ *
+ */
+int edac_pci_alloc_index(void)
+{
+	return (atomic_inc_return(&pci_indexes) - 1);
+}
+EXPORT_SYMBOL(edac_pci_alloc_index);
+
 /*
  * edac_pci_add_device: Insert the 'edac_dev' structure into the
  * edac_pci global list and create sysfs entries associated with
-- 
1.6.0.3

