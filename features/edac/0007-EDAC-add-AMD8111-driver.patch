From b98aa16e53f772ab869c02a0cba69d68b1604070 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Fri, 7 Nov 2008 14:22:05 -0500
Subject: [PATCH] EDAC: add AMD8111 driver

Add EDAC driver for AMD8111 chipset.
---
 drivers/edac/Kconfig        |    7 +
 drivers/edac/Makefile       |    1 +
 drivers/edac/amd8111_edac.c |  343 +++++++++++++++++++++++++++++++++++++++++++
 drivers/edac/amd8111_edac.h |   70 +++++++++
 include/linux/pci_ids.h     |    1 +
 5 files changed, 422 insertions(+), 0 deletions(-)
 create mode 100644 drivers/edac/amd8111_edac.c
 create mode 100644 drivers/edac/amd8111_edac.h

diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index 451e24e..e5909df 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -178,4 +178,11 @@ config EDAC_MAPLE
 	help
 	  Global variables for Maple board
 
+config EDAC_AMD8111
+	tristate "AMD8111 HyperTransport I/O Hub"
+	depends on PCI && EDAC_MAPLE
+	help
+	  Support for error detection and correction on the
+	  AMD8111 HT I/O Hub chip.
+
 endif # EDAC
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index 374f9df..bb7c5cc 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -35,4 +35,5 @@ obj-$(CONFIG_EDAC_MV64X60)		+= mv64x60_edac.o
 obj-$(CONFIG_EDAC_CELL)			+= cell_edac.o
 obj-$(CONFIG_EDAC_TEST_DEVICE)		+= test_device_edac.o
 obj-$(CONFIG_EDAC_MAPLE)		+= maple_edac.o
+obj-$(CONFIG_EDAC_AMD8111)		+= amd8111_edac.o
 
diff --git a/drivers/edac/amd8111_edac.c b/drivers/edac/amd8111_edac.c
new file mode 100644
index 0000000..29d3f0c
--- /dev/null
+++ b/drivers/edac/amd8111_edac.c
@@ -0,0 +1,343 @@
+/*
+ * amd8111_edac.c, AMD8111 Hyper Transport chip EDAC kernel module
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors:	Benjamin Walsh <benjamin.walsh@windriver.com>
+ * 		Cao Qingtao <qingtao.cao@windriver.com>
+ * 		Hu Yongqi <yongqi.hu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
+#include <linux/edac.h>
+#include <linux/pci_ids.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+#include "amd8111_edac.h"
+
+#define AMD8111_EDAC_REVISION	" Ver: 1.0.0 " __DATE__
+#define AMD8111_EDAC_MOD_STR	"amd8111_edac"
+
+enum amd8111_bridges {
+	PCI_BRIDGE = 0,
+	LPC_BRIDGE,
+};
+
+/* device-specific methods for amd8111 PCI Bridge device */
+static void amd8111_pci_bridge_init(struct amd8111_dev_info *dev_info)
+{
+	u32 val32;
+
+	/* First clear all fault on the secondary interface */
+	if (pci_read_config_dword(dev_info->dev, REG_MEM_LIM, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	if (val32 & MEM_LIMIT_MASK) {
+		if (pci_write_config_dword(dev_info->dev,
+						REG_MEM_LIM, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+	}
+
+	if (pci_read_config_dword(dev_info->dev, REG_INT_CTLR, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 |= INT_CTLR_PERR | INT_CTLR_SERR;
+	if (pci_write_config_dword(dev_info->dev, REG_INT_CTLR, val32))
+		printk(KERN_ERR "PCI Access Error\n");
+}
+
+static void amd8111_pci_bridge_exit(struct amd8111_dev_info *dev_info)
+{
+	u32 val32;
+
+	if (pci_read_config_dword(dev_info->dev, REG_INT_CTLR, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val32 &= ~(INT_CTLR_PERR | INT_CTLR_SERR);
+	if (pci_write_config_dword(dev_info->dev, REG_INT_CTLR, val32))
+		printk(KERN_ERR "PCI Access Error\n");
+
+}
+
+static void amd8111_pci_bridge_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct amd8111_dev_info *dev_info = edac_dev->pvt_info;
+	struct pci_dev *dev = dev_info->dev;
+	u32 val32;
+
+	if (pci_read_config_dword(dev, REG_MEM_LIM, &val32)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	if (val32 & MEM_LIMIT_MASK) {
+		printk(KERN_INFO "Error(s) in mem limit register on %s device\n",
+			dev_info->ctl_name);
+		printk(KERN_INFO "DPE: %d, RSE: %d, RMA: %d\n"
+			"RTA: %d, STA: %d, MDPE: %d\n",
+			(val32 & MEM_LIMIT_DPE)  != 0,
+			(val32 & MEM_LIMIT_RSE)  != 0,
+			(val32 & MEM_LIMIT_RMA)  != 0,
+			(val32 & MEM_LIMIT_RTA)  != 0,
+			(val32 & MEM_LIMIT_STA)  != 0,
+			(val32 & MEM_LIMIT_MDPE) != 0);
+		val32 |= MEM_LIMIT_MASK;
+		if (pci_write_config_dword(dev, REG_MEM_LIM, val32)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+	}
+}
+
+/* device-specific methods for amd8111 LPC Bridge device */
+static void amd8111_lpc_bridge_init(struct amd8111_dev_info *dev_info)
+{
+	u8 val8;
+
+	/* ask to generate an NMI only in NMI mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		return;
+
+	if (pci_read_config_byte(dev_info->dev, REG_IO_CTRL_1, &val8)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val8 |= IO_CTRL_1_NMI;
+	if (pci_write_config_byte(dev_info->dev, REG_IO_CTRL_1, val8))
+		printk(KERN_ERR "PCI Access Error\n");
+}
+
+static void amd8111_lpc_bridge_exit(struct amd8111_dev_info *dev_info)
+{
+	u8 val8;
+
+	/* stop asking for NMI only in INT mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		return;
+
+	/* stop asking to generate an NMI; doesn't hurt even
+	 * if EDAC is not in NMI opstate */
+	if (pci_read_config_byte(dev_info->dev, REG_IO_CTRL_1, &val8)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+	val8 &= ~IO_CTRL_1_NMI;
+	if (pci_write_config_byte(dev_info->dev, REG_IO_CTRL_1, val8))
+		printk(KERN_ERR "PCI Access Error\n");
+}
+
+static void amd8111_lpc_bridge_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct amd8111_dev_info *dev_info = edac_dev->pvt_info;
+	struct pci_dev *dev = dev_info->dev;
+	u8 val8;
+
+	if (pci_read_config_byte(dev, REG_MEM_LIM, &val8)) {
+		printk(KERN_ERR "PCI Access Error\n");
+		return;
+	}
+
+	if (val8 & IO_CTRL_1_MASK) {
+		printk(KERN_INFO "Error(s) in IO control register on %s device\n",
+			dev_info->ctl_name);
+		printk(KERN_INFO "LPC ERR: %d\n", (val8 & IO_CTRL_1_LPC_ERR) != 0);
+		val8 |= IO_CTRL_1_LPC_ERR;
+		if(pci_write_config_byte(dev, REG_IO_CTRL_1, val8)) {
+			printk(KERN_ERR "PCI Access Error\n");
+			return;
+		}
+
+		edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+	}
+}
+
+static struct amd8111_dev_info amd8111_devices[] = {
+	[PCI_BRIDGE] = {
+		.err_dev = PCI_DEVICE_ID_AMD_8111_PCI,
+		.ctl_name = "AMD8111_PCI",
+		.init = amd8111_pci_bridge_init,
+		.exit = amd8111_pci_bridge_exit,
+		.check = amd8111_pci_bridge_check,
+		},
+	[LPC_BRIDGE] = {
+		.err_dev = PCI_DEVICE_ID_AMD_8111_LPC,
+		.ctl_name = "AMD8111_LPC",
+		.init = amd8111_lpc_bridge_init,
+		.exit = amd8111_lpc_bridge_exit,
+		.check = amd8111_lpc_bridge_check,
+		},
+	{0},
+};
+
+static int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	struct amd8111_dev_info *dev_info = &amd8111_devices[id->driver_data];
+
+	dev_info->dev = pci_get_device(PCI_VENDOR_ID_AMD, dev_info->err_dev, NULL);
+
+	if (!dev_info->dev) {
+		printk(KERN_ERR "EDAC device not found:"
+			"vendor %x, device %x, name %s\n",
+			PCI_VENDOR_ID_AMD, dev_info->err_dev,
+			dev_info->ctl_name);
+		return -ENODEV;
+	}
+
+	if (pci_enable_device(dev_info->dev)) {
+		pci_dev_put(dev_info->dev);
+		printk(KERN_ERR "failed to enable:"
+			"vendor %x, device %x, name %s\n",
+			PCI_VENDOR_ID_AMD, dev_info->err_dev,
+			dev_info->ctl_name);
+		return -ENODEV;
+	}
+
+	/*
+	 * we do not allocate extra private structure for
+	 * edac_device_ctl_info, but make use of existing
+	 * one instead.
+	*/
+	dev_info->edac_dev =
+		edac_device_alloc_ctl_info(0, dev_info->ctl_name, 1,
+					   NULL, 0, 0,
+					   NULL, 0, maple_edac_dev_idx);
+	if (!dev_info->edac_dev)
+		return -ENOMEM;
+
+	dev_info->edac_dev->pvt_info = dev_info;
+	dev_info->edac_dev->dev = &dev_info->dev->dev;
+	dev_info->edac_dev->mod_name = AMD8111_EDAC_MOD_STR;
+	dev_info->edac_dev->ctl_name = dev_info->ctl_name;
+	dev_info->edac_dev->dev_name = dev_info->dev->dev.bus_id;
+
+	/* FIXME: so far we only support POLL mode */
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		dev_info->edac_dev->edac_check = dev_info->check;
+	else if ((edac_op_state == EDAC_OPSTATE_INT)) {
+		dev_info->irq = dev_info->dev->irq;
+		/*
+		 * instantiate EDAC NMI handler, or
+		 * register interrupt handler
+		 *
+		 * request_irq(dev_info->irq, dev_info->isr,
+				IRQF_DISABLED, "[EDAC] dev_info->ctl_name",
+				dev_info->edac_dev);
+		 */
+	}
+
+	if (dev_info->init)
+		dev_info->init(dev_info);
+
+	if (edac_device_add_device(dev_info->edac_dev) > 0) {
+		printk(KERN_ERR "failed edac_device_add_device() for %s\n",
+			dev_info->ctl_name);
+		edac_device_free_ctl_info(dev_info->edac_dev);
+		return -ENODEV;
+	}
+
+	dev_info->edac_idx = maple_edac_dev_idx++;
+
+	printk(KERN_INFO "added one device on AMD8111 "
+		"vendor %x, device %x, name %s\n",
+		PCI_VENDOR_ID_AMD, dev_info->err_dev,
+		dev_info->ctl_name);
+
+	return 0;
+}
+
+static void amd8111_remove(struct pci_dev *dev)
+{
+	struct amd8111_dev_info *dev_info;
+
+	for (dev_info = amd8111_devices; dev_info->err_dev; dev_info++)
+		if (dev_info->dev->device == dev->device)
+			break;
+
+	if (!dev_info->err_dev)	/* should never happen */
+		return;
+
+	if (dev_info->edac_dev) {
+		edac_device_del_device(dev_info->edac_dev->dev);
+		edac_device_free_ctl_info(dev_info->edac_dev);
+	}
+
+	if (dev_info->exit)
+		dev_info->exit(dev_info);
+
+	pci_dev_put(dev_info->dev);
+}
+
+static const struct pci_device_id amd8111_edac_pci_tbl[] = {
+	{
+	PCI_VEND_DEV(AMD, 8111_PCI),
+	PCI_ANY_ID,		/* subvendor */
+	PCI_ANY_ID,		/* subdevice */
+	0,			/* class */
+	0,			/* class_mark */
+	PCI_BRIDGE,		/* driver private data */
+	},
+	{
+	PCI_VEND_DEV(AMD, 8111_LPC),
+	PCI_ANY_ID,		/* subvendor */
+	PCI_ANY_ID,		/* subdevice */
+	0,			/* class */
+	0,			/* class_mark */
+	LPC_BRIDGE,		/* driver private data */
+	},
+	{ 0,0,0,0,0,0,0 }	/* table is NULL-terminated */
+};
+MODULE_DEVICE_TABLE(pci, amd8111_edac_pci_tbl);
+
+static struct pci_driver amd8111_edac_driver = {
+	.name = AMD8111_EDAC_MOD_STR,
+	.probe = amd8111_probe,
+	.remove = amd8111_remove,
+	.id_table = amd8111_edac_pci_tbl,
+};
+
+static int __init amd8111_edac_init(void)
+{
+	opstate_init();
+
+	return pci_register_driver(&amd8111_edac_driver);
+}
+
+static void __exit amd8111_edac_exit(void)
+{
+	pci_unregister_driver(&amd8111_edac_driver);
+}
+
+
+module_init(amd8111_edac_init);
+module_exit(amd8111_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Wind River (http://windriver.com) Benjamin Walsh\n");
+MODULE_DESCRIPTION("AMD8111 hypertransport chip EDAC kernel module");
+
diff --git a/drivers/edac/amd8111_edac.h b/drivers/edac/amd8111_edac.h
new file mode 100644
index 0000000..4331c99
--- /dev/null
+++ b/drivers/edac/amd8111_edac.h
@@ -0,0 +1,70 @@
+/*
+ * amd8111_edac.h, EDAC defs for AMD8111 hypertransport chip
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors:	Benjamin Walsh <benjamin.walsh@windriver.com>
+ * 		Cao Qingtao <qingtao.cao@windriver.com>
+ * 		Hu Yongqi <yongqi.hu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _AMD8111_EDAC_H_
+#define _AMD8111_EDAC_H_
+
+#include "maple_edac.h"
+
+#define REG_MEM_LIM	0x1c
+#define REG_INT_CTLR	0x3c
+#define REG_IO_CTRL_1	0x40
+
+enum int_ctlr_bits {
+	INT_CTLR_PERR = BIT(16),
+	INT_CTLR_SERR = BIT(17)
+};
+
+enum io_ctrl_1_bits {
+	IO_CTRL_1_NMI 		= BIT(7),
+	IO_CTRL_1_LPC_ERR	= BIT(6),
+	IO_CTRL_1_MASK		= IO_CTRL_1_LPC_ERR
+};
+
+enum mem_limit_bits {
+	MEM_LIMIT_DPE 	= BIT(31),
+	MEM_LIMIT_RSE 	= BIT(30),
+	MEM_LIMIT_RMA 	= BIT(29),
+	MEM_LIMIT_RTA 	= BIT(28),
+	MEM_LIMIT_STA	= BIT(27),
+	MEM_LIMIT_MDPE	= BIT(24),
+	MEM_LIMIT_MASK	= (MEM_LIMIT_DPE|MEM_LIMIT_RSE|MEM_LIMIT_RMA|
+				MEM_LIMIT_RTA|MEM_LIMIT_STA|MEM_LIMIT_MDPE)
+};
+
+struct amd8111_dev_info {
+	u16 err_dev;	/* PCI Device ID */
+	struct pci_dev *dev;
+	int edac_idx;	/* device index */
+	int irq;
+	const char *ctl_name;
+	struct edac_device_ctl_info *edac_dev;
+	void (*init)(struct amd8111_dev_info *dev_info);
+	void (*exit)(struct amd8111_dev_info *dev_info);
+	void (*check)(struct edac_device_ctl_info *edac_dev);
+	/*FIXME: do we need register interrupt handler for a PCI device ?*/
+	/* irqreturn_t (*isr)(int irq, void *edac_dev); */
+};
+
+#endif /* _AMD8111_EDAC_H_ */
+
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index f1624b3..1263082 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -516,6 +516,7 @@
 #define PCI_DEVICE_ID_AMD_OPUS_7443	0x7443
 #define PCI_DEVICE_ID_AMD_VIPER_7443	0x7443
 #define PCI_DEVICE_ID_AMD_OPUS_7445	0x7445
+#define PCI_DEVICE_ID_AMD_8111_PCI	0x7460
 #define PCI_DEVICE_ID_AMD_8111_LPC	0x7468
 #define PCI_DEVICE_ID_AMD_8111_IDE	0x7469
 #define PCI_DEVICE_ID_AMD_8111_SMBUS2	0x746a
-- 
1.6.0.3

