From 1d507c3b1855a3cbc3b1da9235433db43252c1d9 Mon Sep 17 00:00:00 2001
From: Matt Wagantall <matthew.wagantall@windriver.com>
Date: Sat, 8 Nov 2008 17:57:09 -0500
Subject: [PATCH] EDAC: Add cpc925 chipset support for vMC

Add EDAC vMC wrapper calls and a vMC sensor mappings for cpc925 Maple
chipsets.  This vMC integration is enabled by the CONFIG_EDAC_VMC
kernel configuration.

Signed-off-by: Matt Wagantall <matthew.wagantall@windriver.com>
---
 drivers/edac/cpc925_edac.c     |  157 ++++++++++++++++++++++++++++++++++++++++
 drivers/edac/cpc925_edac_vmc.h |  100 +++++++++++++++++++++++++
 2 files changed, 257 insertions(+), 0 deletions(-)
 create mode 100644 drivers/edac/cpc925_edac_vmc.h

diff --git a/drivers/edac/cpc925_edac.c b/drivers/edac/cpc925_edac.c
index 7cbe8a9..61b9a1d 100644
--- a/drivers/edac/cpc925_edac.c
+++ b/drivers/edac/cpc925_edac.c
@@ -32,10 +32,87 @@
 #include "edac_module.h"
 #include "cpc925_edac.h"
 
+#ifdef CONFIG_EDAC_VMC
+#include "edac_vmc.h"
+#include "cpc925_edac_vmc.h"
+#endif
+
+
 #define EDAC_CPC925_INT_SUPPORT 0	/* FIXME - turn off for now */
 
 #define TO_VOID_FUNCTOR(x) (void(*)(struct edac_device_ctl_info *edac_dev))(x)
 
+#ifdef CONFIG_EDAC_VMC
+static int init_vmc_sensors(void)
+{
+	int rc;
+
+	struct vmc_sensor_params_s uecc_flt_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_MEMORY,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = GEN_THRESHOLD_TBL,
+		.threshold_mask = DEFAULT_READ_SET_THRES_MASK,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	struct vmc_sensor_params_s cecc_flt_params = {
+		.sensor_type = IPMI_SENSOR_TYPE_MEMORY,
+		.event_reading_type = IPMI_EVENT_READING_TYPE_THRESHOLD,
+		.thresholds = CECC_THRESHOLD_TBL,
+		.threshold_mask = READ_THRES_MASK_UPPER_CRITICAL,
+		.leak_rate = RATE_MINUTE,
+		.containment_enable = false
+	};
+
+	/* Assign a vMC LUN to this chipset */
+	cpc925_vmc_lun = vmc_assign_lun();
+
+	/* Sensors with non-default parameters */
+	rc  = vmc_sensor_init(VMC_DRAM_UECC_FLT, cpc925_sensor_map, cpc925_sensor_names,
+			      cpc925_vmc_lun, &uecc_flt_params);
+	rc |= vmc_sensor_init(VMC_DRAM_CECC_FLT, cpc925_sensor_map, cpc925_sensor_names,
+			      cpc925_vmc_lun, &cecc_flt_params);
+
+
+#define INIT_SENSOR_DEFAULT(id) vmc_sensor_init((id), cpc925_sensor_map,	\
+						cpc925_sensor_names,	\
+						cpc925_vmc_lun, NULL)
+	/* Sensors with default parameters: */
+	rc |= INIT_SENSOR_DEFAULT(VMC_PROCINT_DART);
+	rc |= INIT_SENSOR_DEFAULT(VMC_PROCINT_ADDR0_HS);
+	rc |= INIT_SENSOR_DEFAULT(VMC_PROCINT_ADDR1_HS);
+	rc |= INIT_SENSOR_DEFAULT(VMC_PROCINT_SNOOP);
+	rc |= INIT_SENSOR_DEFAULT(VMC_PROCINT_DERR);
+	rc |= INIT_SENSOR_DEFAULT(VMC_PROCINT_ADDR0_MASK);
+	rc |= INIT_SENSOR_DEFAULT(VMC_PROCINT_ADDR1_MASK);
+
+	rc |= INIT_SENSOR_DEFAULT(VMC_HT_FLT);
+
+#undef INIT_SENSOR_DEFAULT
+
+	return rc;
+}
+
+static void uninit_vmc_sensors(void)
+{
+	vmc_sensor_uninit(VMC_DRAM_UECC_FLT, cpc925_vmc_lun);
+	vmc_sensor_uninit(VMC_DRAM_CECC_FLT, cpc925_vmc_lun);
+
+	vmc_sensor_uninit(VMC_PROCINT_DART, cpc925_vmc_lun);
+	vmc_sensor_uninit(VMC_PROCINT_ADDR0_HS, cpc925_vmc_lun);
+	vmc_sensor_uninit(VMC_PROCINT_ADDR1_HS, cpc925_vmc_lun);
+	vmc_sensor_uninit(VMC_PROCINT_SNOOP, cpc925_vmc_lun);
+	vmc_sensor_uninit(VMC_PROCINT_DERR, cpc925_vmc_lun);
+	vmc_sensor_uninit(VMC_PROCINT_ADDR0_MASK, cpc925_vmc_lun);
+	vmc_sensor_uninit(VMC_PROCINT_ADDR1_MASK, cpc925_vmc_lun);
+
+	vmc_sensor_uninit(VMC_HT_FLT, cpc925_vmc_lun);
+}
+
+#endif /* CONFIG_EDAC_VMC */
+
+
 static void _dram_uecc_init(struct edac_device_ctl_info *edac_dev)
 {
 	struct cpc925_pdata *pdata = edac_dev->pvt_info;
@@ -125,6 +202,37 @@ static void _dram_dump_regs(const void * const base, const u32 check_value)
 		CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MESR));
 }
 
+#ifdef CONFIG_EDAC_VMC
+static void dram_vmc_report(int sensor, int recoverable, const void * const base,
+			    const u32 check_value)
+{
+	int action;
+	int value;
+
+	if (recoverable) {
+		action = SENSOR_ACTION_INC;
+		value = 1;
+	}
+	else {
+		action = SENSOR_ACTION_SET;
+		value = TH_GEN_UPPER_NON_RECOVERABLE;
+	}
+
+	/* report fault to vMC */
+	vmc_report_fault(sensor, cpc925_vmc_lun, action, value, 10,
+			 "MCK Reason", check_value,
+			 "MCK Mask", CPC925_REG32BE_READ(base, CPC925_PROCINT_APIMASK),
+			 "Mem Scrub Ctl", CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MSCR),
+			 "Mem Scrub Rge Start", CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MSRSR),
+			 "Mem Scrub Rge End", CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MSRER),
+			 "Mem Scrub Pattern", CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MSPR),
+			 "Mem Chk Ctrl", CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MCCR),
+			 "Mem Chk Rge End", CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MCRER),
+			 "Address", CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MEAR),
+			 "Syndrome", CPC925_REG32BE_READ(base, CPC925_MEMCTRL_MESR));
+}
+#endif /* CONFIG_EDAC_VMC */
+
 static int _dram_uecc_check(struct edac_device_ctl_info *edac_dev)
 {
 	struct cpc925_pdata *pdata = edac_dev->pvt_info;
@@ -142,6 +250,10 @@ static int _dram_uecc_check(struct edac_device_ctl_info *edac_dev)
 			 "DRAM UECC register dump:\n");
 	_dram_dump_regs(base, check_value);
 
+#ifdef CONFIG_EDAC_VMC
+	dram_vmc_report(VMC_DRAM_UECC_FLT, false, base, check_value);
+#endif
+
 	/* Clear the fault */
 	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIEXCP) &=
 			~(PROCINT_LUECC_MASK | PROCINT_UUECC_MASK);
@@ -167,6 +279,10 @@ static int _dram_cecc_check(struct edac_device_ctl_info *edac_dev)
 			 "DRAM CECC register dump:\n");
 	_dram_dump_regs(base, check_value);
 
+#ifdef CONFIG_EDAC_VMC
+	dram_vmc_report(VMC_DRAM_CECC_FLT, true, base, check_value);
+#endif
+
 	/* Clear the fault */
 	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIEXCP) &=
 			~(PROCINT_LCECC_MASK | PROCINT_UCECC_MASK);
@@ -194,6 +310,23 @@ static int _cpu_check(struct edac_device_ctl_info *edac_dev)
 	printk(KERN_INFO "MCK Mask            0x%08x\n",
 		CPC925_REG32BE_READ(base, CPC925_PROCINT_APIMASK));
 
+#ifdef CONFIG_EDAC_VMC
+	{
+	char reg1_name[] = "MCK Reason";
+	char reg2_name[] = "MCK Mask";
+	u32 mck_mask = CPC925_REG32BE_READ(base, CPC925_PROCINT_APIMASK);
+
+	/* Report faults to vMC */
+	REPORT_FAULT_2REG(PROCINT_DART, reg1_name, check_value, reg2_name, mck_mask);
+	REPORT_FAULT_2REG(PROCINT_ADDR0_HS, reg1_name, check_value, reg2_name, mck_mask);
+	REPORT_FAULT_2REG(PROCINT_ADDR1_HS, reg1_name, check_value, reg2_name, mck_mask);
+	REPORT_FAULT_2REG(PROCINT_SNOOP, reg1_name, check_value, reg2_name, mck_mask);
+	REPORT_FAULT_2REG(PROCINT_DERR, reg1_name, check_value, reg2_name, mck_mask);
+	REPORT_FAULT_2REG(PROCINT_ADDR0_MASK, reg1_name, check_value, reg2_name, mck_mask);
+	REPORT_FAULT_2REG(PROCINT_ADDR1_MASK, reg1_name, check_value, reg2_name, mck_mask);
+	}
+#endif
+
 	/* Clear the fault */
 	*(volatile u32*)(pdata->vbase + CPC925_PROCINT_APIEXCP) &=
 				~(PROCINT_CPU_MASK);
@@ -225,6 +358,16 @@ static int _ht_check(struct edac_device_ctl_info *edac_dev)
 	printk(KERN_INFO "Error Enumeration      0x%08x\n", error_enum);
 	printk(KERN_INFO "Link Error             0x%08x\n", link_error);
 
+#ifdef CONFIG_EDAC_VMC
+	/* Report faults to vMC */
+	vmc_report_fault(VMC_HT_FLT, cpc925_vmc_lun,
+			 SENSOR_ACTION_INC, 1, 4,
+			 "Bridge Control", bridge_ctrl,
+			 "Link Config Control", link_cfg_ctl,
+			 "Error Enumeration", error_enum,
+			 "Link Error", link_error);
+#endif
+
 	if (bridge_ctrl & HT_SERR) {
 		*(volatile u32*)(base + CPC925_HT_BRIDGE_CTRL) |= HT_SERR;
 	}
@@ -398,6 +541,15 @@ static int __devinit cpc925_probe(struct platform_device *pdev)
 #endif
 	devres_remove_group(&pdev->dev, cpc925_probe);
 
+
+#ifdef CONFIG_EDAC_VMC
+	/* Initialize vMC Sensors */
+	if (init_vmc_sensors()) {
+		printk(KERN_ERR "failed to initialize one or more " \
+				"vMC sensors\n");
+	}
+#endif	/* CONFIG_EDAC_VMC */
+
 	/* get this far and it's successful */
 	debugf0("%s(): success\n", __func__);
 
@@ -425,6 +577,11 @@ static int cpc925_remove(struct platform_device *pdev)
 	edac_device_del_device(&pdev->dev);
 	edac_device_free_ctl_info(edac_dev);
 
+#ifdef CONFIG_EDAC_VMC
+	/* Uninitialize vMC sensors */
+	uninit_vmc_sensors();
+#endif
+
 	return 0;
 }
 
diff --git a/drivers/edac/cpc925_edac_vmc.h b/drivers/edac/cpc925_edac_vmc.h
new file mode 100644
index 0000000..b82ac33
--- /dev/null
+++ b/drivers/edac/cpc925_edac_vmc.h
@@ -0,0 +1,100 @@
+/*
+ * cpc925_edac_vmc.h, vMC sensor maps for CPC925 EDAC driver
+ *
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors: Benjamin Walsh (benjamin.walsh@windriver.com)
+ *          Matt Wagantall (matthew.wagantall@windriver.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _CPC925_EDAC_VMC_H_
+#define _CPC925_EDAC_VMC_H_
+
+#include "edac_vmc.h"
+#include "cpc925_edac.h"
+
+/* Assign sensor numbers.
+ *   Order is arbitrary */
+enum cpc925_sensors {
+	VMC_DRAM_UECC_FLT = 0,
+	VMC_DRAM_CECC_FLT,
+
+	VMC_PROCINT_DART,
+	VMC_PROCINT_ADDR0_HS,
+	VMC_PROCINT_ADDR1_HS,
+	VMC_PROCINT_SNOOP,
+	VMC_PROCINT_DERR,
+	VMC_PROCINT_ADDR0_MASK,
+	VMC_PROCINT_ADDR1_MASK,
+
+	VMC_HT_FLT,
+};
+
+/* Assign sensor names.
+ * macro usage: name_sensor( name ),
+ *   Order does not matter here */
+#define name_sensor(x) [(x)] = #x
+static const char *cpc925_sensor_names[] = {
+	name_sensor(VMC_DRAM_UECC_FLT),
+	name_sensor(VMC_DRAM_CECC_FLT),
+
+	name_sensor(VMC_PROCINT_DART),
+	name_sensor(VMC_PROCINT_ADDR0_HS),
+	name_sensor(VMC_PROCINT_ADDR1_HS),
+	name_sensor(VMC_PROCINT_SNOOP),
+	name_sensor(VMC_PROCINT_DERR),
+	name_sensor(VMC_PROCINT_ADDR0_MASK),
+	name_sensor(VMC_PROCINT_ADDR1_MASK),
+
+	name_sensor(VMC_HT_FLT),
+};
+
+/* Map sensors to vMC IPMI entities.
+ * macro usage: map_sensor(sensor, entity type, entity instance),
+ *   Order does not matter here */
+#define map_sensor(sensor, entity, entity_inst) \
+	[(sensor)] = (((entity) << 8) | (entity_inst))
+static const int cpc925_sensor_map[] = {
+	map_sensor(VMC_DRAM_UECC_FLT, IPMI_ENTITY_ID_MEMORY_DEVICE, 0),
+	map_sensor(VMC_DRAM_CECC_FLT, IPMI_ENTITY_ID_MEMORY_DEVICE, 0),
+
+	map_sensor(VMC_PROCINT_DART, IPMI_ENTITY_ID_PROCESSOR, 0),
+	map_sensor(VMC_PROCINT_ADDR0_HS, IPMI_ENTITY_ID_PROCESSOR, 0),
+	map_sensor(VMC_PROCINT_ADDR1_HS, IPMI_ENTITY_ID_PROCESSOR, 0),
+	map_sensor(VMC_PROCINT_SNOOP, IPMI_ENTITY_ID_PROCESSOR, 0),
+	map_sensor(VMC_PROCINT_DERR, IPMI_ENTITY_ID_PROCESSOR, 0),
+	map_sensor(VMC_PROCINT_ADDR0_MASK, IPMI_ENTITY_ID_PROCESSOR, 0),
+	map_sensor(VMC_PROCINT_ADDR1_MASK, IPMI_ENTITY_ID_PROCESSOR, 0),
+
+	map_sensor(VMC_HT_FLT, IPMI_ENTITY_ID_PCI_BUS, 0),
+};
+
+/* put here instead of C file to modularize with vMC */
+static int cpc925_vmc_lun;
+
+#define REPORT_FAULT_2REG(bits, reg1_name, reg1_val, reg2_name, reg2_val)\
+	do {								\
+		if(reg1_val & bits) {					\
+			vmc_report_fault(VMC_##bits, cpc925_vmc_lun,	\
+						SENSOR_ACTION_INC, 1, 2,\
+						reg1_name, reg1_val,	\
+						reg2_name, reg2_val);	\
+		}							\
+	}								\
+	while ((0))
+
+#endif	/* _CPC925_EDAC_VMC_H_ */
+
-- 
1.6.0.90.g436ed

