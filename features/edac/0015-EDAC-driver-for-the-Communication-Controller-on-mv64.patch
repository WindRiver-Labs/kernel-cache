From 3b62ca1191948f11fc54395efdfdef56bb5e5fb3 Mon Sep 17 00:00:00 2001
From: Rob Woolley <rob.woolley@windriver.com>
Date: Sat, 8 Nov 2008 13:20:22 -0500
Subject: [PATCH] EDAC driver for the Communication Controller on mv64x60 chipset

Adds the EDAC driver for the Communication Controller on mv64x60 chipset.

Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
Reviewed-by: Rob Woolley <rob.woolley@windriver.com>
---
 arch/powerpc/boot/dts/prpmc2800.dts |    7 ++
 arch/powerpc/sysdev/mv64x60_dev.c   |    8 ++
 drivers/edac/mv64x60_edac.c         |  166 +++++++++++++++++++++++++++++++++++
 drivers/edac/mv64x60_edac.h         |   26 ++++++
 4 files changed, 207 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/boot/dts/prpmc2800.dts b/arch/powerpc/boot/dts/prpmc2800.dts
index f68678e..7611880 100644
--- a/arch/powerpc/boot/dts/prpmc2800.dts
+++ b/arch/powerpc/boot/dts/prpmc2800.dts
@@ -307,6 +307,13 @@
                         interrupts = <1>;
                         interrupt-parent = <&PIC>;
                 };
+		
+		comm-ctrl@f310 {
+			compatible = "marvell,mv64x60-comm-ctrl";
+			reg = <0xf310 0x0c>;
+			interrupts = <15>;
+			interrupt-parent = <&PIC>;
+		};
 	};
 
 	chosen {
diff --git a/arch/powerpc/sysdev/mv64x60_dev.c b/arch/powerpc/sysdev/mv64x60_dev.c
index f23c382..ec09f24 100644
--- a/arch/powerpc/sysdev/mv64x60_dev.c
+++ b/arch/powerpc/sysdev/mv64x60_dev.c
@@ -585,6 +585,14 @@ static int __init mv64x60_device_setup(void)
 					"device controller %s: error %d.\n",
 					np->full_name, err);
 
+	id = 0;
+	for_each_compatible_node(np, NULL, "marvell,mv64x60-comm-ctrl")
+		if ((err = mv64x60_edac_device_setup(np, id++, 1,
+					"mv64x60_comm_err")))
+			printk(KERN_ERR "Failed to initialize MV64x60 "
+					"commnication controller %s: error %d.\n",
+					np->full_name, err);
+
 	return 0;
 }
 arch_initcall(mv64x60_device_setup);
diff --git a/drivers/edac/mv64x60_edac.c b/drivers/edac/mv64x60_edac.c
index 5107580..1b854c5 100644
--- a/drivers/edac/mv64x60_edac.c
+++ b/drivers/edac/mv64x60_edac.c
@@ -1007,6 +1007,166 @@ static struct platform_driver mv64x60_device_err_driver = {
 	}
 };
 
+/*********************** Communicatioin err device *************************/
+static void mv64x60_comm_check(struct edac_device_ctl_info *edac_dev)
+{
+	struct mv64x60_comm_pdata *pdata = edac_dev->pvt_info;
+	u32 cause;
+
+	cause = in_le32(pdata->comm_vbase + MV64X60_COMM_INTR_CAUSE);
+	if (!cause)
+		return;
+
+	printk(KERN_ERR "Error on communication interface\n");
+	printk(KERN_ERR "Cause register: 0x%08x\n", cause);
+	printk(KERN_ERR "Address : 0x%08x\n",
+	       	in_le32(pdata->comm_vbase + MV64X60_COMM_INTR_ERR_ADDR));
+	out_le32(pdata->comm_vbase + MV64X60_DEV_INTR_CAUSE, 0);
+
+	edac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);
+}
+
+static irqreturn_t mv64x60_comm_isr(int irq, void *dev_id)
+{
+	struct edac_device_ctl_info *edac_dev = dev_id;
+	struct mv64x60_comm_pdata *pdata = edac_dev->pvt_info;
+	u32 cause;
+
+	cause = in_le32(pdata->comm_vbase + MV64X60_COMM_INTR_CAUSE);
+	if (!cause)
+		return IRQ_NONE;
+
+	mv64x60_comm_check(edac_dev);
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit mv64x60_comm_err_probe(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev;
+	struct resource *r;
+	struct mv64x60_comm_pdata *pdata;
+	int res = 0;
+
+	if (!devres_open_group(&pdev->dev, mv64x60_comm_err_probe, GFP_KERNEL))
+		return -ENOMEM;
+
+	edac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),
+					      "comm", 1, NULL, 0, 0, 
+					      NULL, 0, edac_dev_idx);
+	if (!edac_dev) {
+		devres_release_group(&pdev->dev, mv64x60_comm_err_probe);
+		return -ENOMEM;
+	}
+
+	pdata = edac_dev->pvt_info;
+	pdata->name = pdev->name;
+	pdata->irq = NO_IRQ;
+	edac_dev->dev = &pdev->dev;
+	platform_set_drvdata(pdev, edac_dev);
+	edac_dev->dev_name = pdev->dev.bus_id;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		printk(KERN_ERR "%s: Unable to get resource for "
+		       "communication err regs\n", __func__);
+		res = -ENOENT;
+		goto err;
+	}
+
+	if (!devm_request_mem_region(&pdev->dev,
+				     r->start,
+				     r->end - r->start + 1,
+				     pdata->name)) {
+		printk(KERN_ERR "%s: Error while requesting mem region\n",
+		       __func__);
+		res = -EBUSY;
+		goto err;
+	}
+
+	pdata->comm_vbase = devm_ioremap(&pdev->dev,
+					   r->start,
+					   r->end - r->start + 1);
+
+	if (!pdata->comm_vbase) {
+		printk(KERN_ERR "%s: Unable to setup communication err regs\n", 
+		       __func__);
+		res = -ENOMEM;
+		goto err;
+	}
+
+	/* setup Communication err registers */
+	out_le32(pdata->comm_vbase + MV64X60_COMM_INTR_CAUSE, 0);
+	out_le32(pdata->comm_vbase + MV64X60_COMM_INTR_MASK, 0);
+	out_le32(pdata->comm_vbase + MV64X60_COMM_INTR_MASK, 
+		 MV64X60_COMM_INTR_MASK_VALUE);
+
+	edac_dev->mod_name = EDAC_MOD_STR;
+	edac_dev->ctl_name = pdata->name;
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		edac_dev->edac_check = mv64x60_comm_check;
+
+	pdata->edac_idx = edac_dev_idx++;
+
+	if (edac_device_add_device(edac_dev) > 0) {
+		debugf3("%s(): failed edac_device_add_device()\n", __func__);
+		goto err;
+	}
+
+	if (edac_op_state == EDAC_OPSTATE_INT) {
+		pdata->irq = platform_get_irq(pdev, 0);
+		res = devm_request_irq(&pdev->dev,
+				       pdata->irq,
+				       mv64x60_comm_isr,
+				       IRQF_DISABLED,
+				       "[EDAC] Comm Err",
+				       edac_dev);
+		if (res < 0) {
+			printk(KERN_ERR
+			       "%s: Unable to request irq %d for MV64x60 "
+			       "communication err\n", __func__, pdata->irq);
+			res = -ENODEV;
+			goto err2;
+		}
+
+		printk(KERN_INFO EDAC_MOD_STR
+		       " acquired irq %d for communication err\n", pdata->irq);
+	}
+
+	devres_remove_group(&pdev->dev, mv64x60_comm_err_probe);
+
+	/* get this far and it's successful */
+	debugf3("%s(): success\n", __func__);
+
+	return 0;
+
+err2:
+	edac_device_del_device(&pdev->dev);
+err:
+	devres_release_group(&pdev->dev, mv64x60_comm_err_probe);
+	edac_device_free_ctl_info(edac_dev);
+	return res;
+}
+
+static int mv64x60_comm_err_remove(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *edac_dev = platform_get_drvdata(pdev);
+
+	debugf0("%s()\n", __func__);
+
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(edac_dev);
+	return 0;
+}
+
+static struct platform_driver mv64x60_comm_err_driver = {
+	.probe = mv64x60_comm_err_probe,
+	.remove = mv64x60_comm_err_remove,
+	.driver = {
+		   .name = "mv64x60_comm_err",
+	}
+};
+
 static int __init mv64x60_edac_init(void)
 {
 	int ret = 0;
@@ -1047,12 +1207,18 @@ static int __init mv64x60_edac_init(void)
 		printk(KERN_WARNING EDAC_MOD_STR
 			"Device err failed to register\n");
 
+	ret = platform_driver_register(&mv64x60_comm_err_driver);
+	if (ret)
+		printk(KERN_WARNING EDAC_MOD_STR
+			"Communication err failed to register\n");
+
 	return ret;
 }
 module_init(mv64x60_edac_init);
 
 static void __exit mv64x60_edac_exit(void)
 {
+	platform_driver_unregister(&mv64x60_comm_err_driver);
 	platform_driver_unregister(&mv64x60_device_err_driver);
 #ifdef CONFIG_PCI
 	platform_driver_unregister(&mv64x60_pci0_err_driver);
diff --git a/drivers/edac/mv64x60_edac.h b/drivers/edac/mv64x60_edac.h
index 370a7b5..7d2d18d 100644
--- a/drivers/edac/mv64x60_edac.h
+++ b/drivers/edac/mv64x60_edac.h
@@ -149,6 +149,25 @@ struct mv64x60_pci_pdata {
 /* only bits[3:0] of the Device Error Parity Register are accessible */
 #define MV64X60_DEV_INTR_ERR_PAR_MASK	0x0000000f
 
+/* Communication Interrupts Registers */
+#define MV64X60_COMM_INTR_CAUSE		0x00	/* 0xf310 */
+#define MV64X60_COMM_INTR_MASK		0x04	/* 0xf314 */
+#define MV64X60_COMM_INTR_ERR_ADDR	0x08	/* 0xf318 */
+
+#define MV64X60_COMM_INTR_MASK_S0AddrMiss	0x00010000
+#define MV64X60_COMM_INTR_MASK_S0AccProt	0x00020000
+#define MV64X60_COMM_INTR_MASK_S0WrProt		0x00040000
+#define MV64X60_COMM_INTR_MASK_S1AddrMiss	0x01000000
+#define MV64X60_COMM_INTR_MASK_S1AccProt	0x02000000
+#define MV64X60_COMM_INTR_MASK_S1WrProt		0x04000000
+
+#define MV64X60_COMM_INTR_MASK_VALUE	(MV64X60_COMM_INTR_MASK_S0AddrMiss | \
+					MV64X60_COMM_INTR_MASK_S0AccProt | \
+					MV64X60_COMM_INTR_MASK_S0WrProt | \
+					MV64X60_COMM_INTR_MASK_S1AddrMiss | \
+					MV64X60_COMM_INTR_MASK_S1AccProt | \
+					MV64X60_COMM_INTR_MASK_S1WrProt)
+
 struct mv64x60_mc_pdata {
 	void __iomem *mc_vbase;
 	int total_mem;
@@ -178,4 +197,11 @@ struct mv64x60_device_pdata {
         int edac_idx;
 };
 
+struct mv64x60_comm_pdata {
+        void __iomem *comm_vbase;
+        const char *name;
+        int irq;
+        int edac_idx;
+};
+
 #endif
-- 
1.6.0.90.g436ed

