From 63297ccde4c94ca608c375380f53345c3b0e60a5 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Sun, 31 Oct 2010 18:17:28 -0700
Subject: [PATCH] powerpc32: Fixes the irqtrace support

The commit "powerpc: Add irqtrace support for 32-bit powerpc" added
irqtrace support for 32-bit powerpc, but it also has broken the handling
of the processor exceptions, a problem of such has been observed is:
ptrace(PTRACE_SINGLESTEP,...) failed on amcc_kilauea_405ex board.

"The single-step request is actually several operations batched into
one. A PTRACE_SINGLESTEP request will execute a single instruction in
the child task, then stop the child and notify the parent with a
SIGTRAP."[1]

The observed phenomenon of the failure is: after sending
PTRACE_SINGLESTEP request to the child, the parent wait for the SIGTRAP
signal to check if the child is stopped, but the parent wait there and
never get the SIGTRAP signal.

	if (fork() == 0) {
		/* child */
		ptrace(PTRACE_TRACEME, 0, NULL, NULL);
		execl("child-program", ...);
	} else {
		/* parent */
		wait(&status);		--> hang here
		...
		ptrace(PTRACE_SINGLESTEP, child, NULL, NULL);
		...
	}

Normally, after sending out the SINGLESTEP request, one instruction of
the child will be executed and when it completes, DebugException()[2]
should handles it and at last send the SIGTRAP signal out:

void __kprobes native_DebugException(struct pt_regs *regs, unsigned long debug_status)
{
        current->thread.dbsr = debug_status;

        if (debug_status & DBSR_BT) {
                [snip]
        } else if (debug_status & DBSR_IC) {    /* Instruction complete */
                [snip]
                if (notify_die(DIE_SSTEP, "single_step", regs, 5,
                               5, SIGTRAP) == NOTIFY_STOP) {
                        return;
                }
                [snip]
                _exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);
        }
        [snip]
}

The observation of "ps -eo stat,command" shows the child process is really
woken up, so, the debug_status should be wrong and DebugException() never go to
the (debug_status & DBSR_IC) branch.

And another observation via testing shows this problem only happen when
compiling the kernel with CONFIG_IRQSOFF_TRACER=y, So, the low-level
support of IRQSOFF_TRACER: IRQFLAGS has been investigated and at last we
found the following piece of source code has overridden the debug_status
argument of DebugException() and introduced the problem:

1. debug_status is passed via the r4 register by the high-level exception handler

arch/powerpc/kernel/head_40x.S:

	/* 0x2000 - Debug Exception */
	START_EXCEPTION(0x2000, DebugTrap)
	[snip]
        /* continue normal handling for a critical exception... */
2:      mfspr   r4,SPRN_DBSR
        addi    r3,r1,STACK_FRAME_OVERHEAD
        EXC_XFER_TEMPLATE(DebugException, 0x2002, \
                (MSR_KERNEL & ~(MSR_ME|MSR_DE|MSR_CE)), \
                NOCOPY, crit_transfer_to_handler, ret_from_crit_exc)

$ objdump -S -d vmlinux

void __kprobes native_DebugException(struct pt_regs *regs, unsigned long debug_status)
{
        current->thread.dbsr = debug_status;
c000d808:       90 82 02 3c     stw     r4,572(r2)

2. but the irqtrace support has overridden the r4 register

arch/powerpc/kernel/entry_32.S:

	.globl transfer_to_handler_cont
transfer_to_handler_cont:
3:
	[snip]
	mflr	r9
	lwz	r11,0(r9)		/* virtual address of handler */
	lwz	r9,4(r9)		/* where to go when done */
 #ifdef CONFIG_TRACE_IRQFLAGS
	[snip]
	bl	trace_hardirqs_off
	[snip]
	lwz	r4,GPR4(r1)		/*** Here override the r4 register ***/
	[snip]
1:	mtctr	r11
	mtlr	r9
	bctr				/* jump to handler */
 #else /* CONFIG_TRACE_IRQFLAGS */
	mtspr	SPRN_SRR0,r11
	mtspr	SPRN_SRR1,r10
	mtlr	r9
	SYNC
	RFI				/* jump to handler, enable MMU */
 #endif /* CONFIG_TRACE_IRQFLAGS */

As we can see above, "lwz     r4,GPR4(r1)" overrides the content in the
r4 register which is passed to the DebugException() by the high-level
exception handler(installed in arch/power/kernel/head_*.S) and make the
DebugException() has no opportunity to response the "Instruction
Complete" and as a result, no SIGTRAP signal will be sent to the parent,
and the parent wait there all the time, then, the failure.

The original idea of the above "lwz     r4,GPR4(r1)" is protect the r4
register from being changed by trace_hardirqs_off(), but the value
stored in GPR4(r1) is not the one passed by the high-level exception
handler, it is the register of the old thread who is interrupted by the
exceptions.

So, here, to protect the arguments passed by the high-level handlers to
the low-level handlers, the related registers must be saved in another
place and restored later explicitly, such registers currently used in
arch/powerpc/kernel/head*.S only include r3, r4 and r5.

For System Call exception, the arguments passed to the system call
functions are exactly the ones saved in the stack, so restore them from
the stack is right, but to protect the registers for all of the
exceptions, the registers also need to be saved. And for system call,
the system call number register(r0) and the other potential argument
registers also should be protected, so, at last, we need to protect r0,
r3-r8.

To protect them, several specific purpose registers are available as the
temp registers for interrupt handling, including SPRG0-7, but since
SPRG3 is used for the current thread_info pointer, only SPRG0-2,SPRG4-7
can be used, but since r9 and r11 registers can be protected in the
stack as before, so they are enough to protect r0, r3-r8.

----
[1] http://mikecvet.wordpress.com/2010/08/14/ptrace-tutorial/
[2] arch/powerpc/kernel/traps.c
[3] arch/powerpc/kernel/entry_32.S

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/powerpc/kernel/entry_32.S |   24 +++++++++++++++---------
 1 files changed, 15 insertions(+), 9 deletions(-)

diff --git a/arch/powerpc/kernel/entry_32.S b/arch/powerpc/kernel/entry_32.S
index 88d3fe4..863d72c 100644
--- a/arch/powerpc/kernel/entry_32.S
+++ b/arch/powerpc/kernel/entry_32.S
@@ -241,17 +241,23 @@ reenable_mmu:				/* re-enable mmu so we can */
 	 */
 	stw	r9,8(r1)
 	stw	r11,12(r1)
-	stw	r3,ORIG_GPR3(r1)
+	mtsprg	0,r0
+	mtsprg	4,r4
+	mtsprg	5,r5
+	mtsprg	6,r6
+	mtsprg	7,r7
+	mtsprg	1,r8
+	mtsprg	2,r3
 	bl	trace_hardirqs_off
-	lwz	r0,GPR0(r1)
-	lwz	r3,ORIG_GPR3(r1)
-	lwz	r4,GPR4(r1)
-	lwz	r5,GPR5(r1)
-	lwz	r6,GPR6(r1)
-	lwz	r7,GPR7(r1)
-	lwz	r8,GPR8(r1)
-	lwz	r9,8(r1)
 	lwz	r11,12(r1)
+	lwz	r9,8(r1)
+	mfsprg	r3,2
+	mfsprg	r8,1
+	mfsprg	r7,7
+	mfsprg	r6,6
+	mfsprg	r5,5
+	mfsprg	r4,4
+	mfsprg	r0,0
 1:	mtctr	r11
 	mtlr	r9
 	bctr				/* jump to handler */
-- 
1.6.5.2

