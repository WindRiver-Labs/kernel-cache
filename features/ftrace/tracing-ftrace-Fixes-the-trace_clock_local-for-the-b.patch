From ed9a98cf428492dcb908935cd103a0b28799151d Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Mon, 20 Sep 2010 15:24:56 +0800
Subject: [PATCH 4/8] tracing/ftrace: Fixes the trace_clock_local() for the boards who use the jiffies based sched_clock()

This patch fixes the selftest failure of the irqsoff, preemptoff,
preemptirqsoff and wakeup tracers:

Testing tracer nop: PASSED
Testing tracer sched_switch: PASSED
Testing tracer function: PASSED
Testing tracer irqsoff: .. no entries found .. FAILED!
Testing tracer preemptoff: .. no entries found ..FAILED!
Testing tracer preemptirqsoff: .. no entries found ..FAILED!
Testing tracer wakeup: .. no entries found ..FAILED!
Testing tracer function_graph: PASSED

By default, Ftrace uses the jiffies based sched_clock() to get the
timestamp if there is no architecture specific one. but the resolution
of this default sched_clock() is very bad: only ~ms. which is useless
for the tracers, expecially for the above latency tracers(irqsoff,
preemptoff, preemptirqsoff), and even make the selftest of these tracers
fail:

To explain the cause, we only use irqsoff as an example.

In trace_selftest_startup_irqsoff(), we only sleep for 100us, so, the
delta of the timestamp gotten by sched_clock() is 0, then, in
check_critical_timing(), the report_latency() will return 0 for the
delta(0) is always smaller than tracing_thresh or equal to
tracing_max_latency. and then, there is no opportunity to do
update_max_tr_single(), then, no entry is the max_tr's buffer, the count
is 0, and selftest failure.

A quick fix is sleep for more than 10ms(in the HZ is 100) in
trace_selftest_startup_irqsoff() to ensure the data can be recorded in
the max_tr's buffer but this doesn't help to fix the useless timestamp
information of the tracers, so, a real fix is use a high resolution
trace_clock_local().

There is such a patch from http://patchwork.linux-mips.org/patch/1104/,
but that one is not suitable for SMP and it is R4K timer specific.

Another choice is the trace-clock-32-to-64 contributed by Lttng, it is
architecture independent and it has been considered for SMP. So, this
patch uses it.

BTW, the following building error on omap is fixed by adding the missing
<linux/percpu.h>.

Without this fix, there will be building errors:

In file included from arch/arm/include/asm/trace-clock.h:2,
                 from include/linux/trace-clock.h:14,
                 from kernel/trace/trace-clock-cyc2ns.c:14:
arch/arm/plat-omap/include/plat/trace-clock.h:71: error: expected declaration specifiers or '...' before 'pm_save_count'
arch/arm/plat-omap/include/plat/trace-clock.h:71: warning: data definition has no type or storage class
arch/arm/plat-omap/include/plat/trace-clock.h:71: warning: type defaults to 'int' in declaration of 'DECLARE_PER_CPU'
arch/arm/plat-omap/include/plat/trace-clock.h:77: error: expected declaration specifiers or '...' before 'fast_clock_ready'
arch/arm/plat-omap/include/plat/trace-clock.h:77: warning: data definition has no type or storage class
arch/arm/plat-omap/include/plat/trace-clock.h:77: warning: type defaults to 'int' in declaration of 'DECLARE_PER_CPU'
arch/arm/plat-omap/include/plat/trace-clock.h:77: error: conflicting types for 'DECLARE_PER_CPU'
arch/arm/plat-omap/include/plat/trace-clock.h:71: note: previous declaration of 'DECLARE_PER_CPU' was here
In file included from arch/arm/include/asm/trace-clock.h:2,
                 from include/linux/trace-clock.h:14,
                 from kernel/trace/trace-clock-cyc2ns.c:14:
arch/arm/plat-omap/include/plat/trace-clock.h: In function 'trace_clock_read64':
arch/arm/plat-omap/include/plat/trace-clock.h:130: error: implicit declaration of function 'per_cpu'
arch/arm/plat-omap/include/plat/trace-clock.h:130: error: 'pm_save_count' undeclared (first use in this function)
arch/arm/plat-omap/include/plat/trace-clock.h:130: error: (Each undeclared identifier is reported only once
arch/arm/plat-omap/include/plat/trace-clock.h:130: error: for each function it appears in.)
arch/arm/plat-omap/include/plat/trace-clock.h:130: error: implicit declaration of function 'smp_processor_id'
arch/arm/plat-omap/include/plat/trace-clock.h:130: error: lvalue required as unary '&' operand
remake[5]: *** [kernel/trace/trace-clock-cyc2ns.o] Error 1
remake[4]: *** [kernel/trace] Error 2
Makefile:895: *** [kernel] Error 2
remake[2]: *** [sub-make] Error 2
remake[1]: *** [linux.compile] Error 2
make: *** [linux.compile] Error 2

Notes:

   o check_res_of_trace_clock() must be finished before the register of
   latency tracers(device_initcall) to ensure the high resolution trace
   clocks are available for them.

   o we must ensure the low-level clocks have been initialized before
   our check_res_of_trace_clock(), so, we put them in early_initcall(),

   o we must release the trace clock explicitly when want to switch
   Ftrace to Lttng with the same kernel:
      $ echo nop > /path/to/debug/tracing/current_tracer

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/arm/mach-omap2/trace-clock.c             |    2 +-
 arch/arm/plat-omap/include/plat/trace-clock.h |    1 +
 include/linux/trace_clock.h                   |    5 +
 kernel/trace/ftrace.c                         |    2 +
 kernel/trace/trace.c                          |    9 ++
 kernel/trace/trace_clock.c                    |  104 ++++++++++++++++++++++++-
 6 files changed, 121 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-omap2/trace-clock.c b/arch/arm/mach-omap2/trace-clock.c
index 31e50b4..2000a91 100644
--- a/arch/arm/mach-omap2/trace-clock.c
+++ b/arch/arm/mach-omap2/trace-clock.c
@@ -706,4 +706,4 @@ static __init int init_trace_clock(void)
 				  CPUFREQ_TRANSITION_NOTIFIER);
 	return 0;
 }
-__initcall(init_trace_clock);
+early_initcall(init_trace_clock);
diff --git a/arch/arm/plat-omap/include/plat/trace-clock.h b/arch/arm/plat-omap/include/plat/trace-clock.h
index a3a9e4b..c4b1ccd 100644
--- a/arch/arm/plat-omap/include/plat/trace-clock.h
+++ b/arch/arm/plat-omap/include/plat/trace-clock.h
@@ -9,6 +9,7 @@
 
 #include <linux/clk.h>
 #include <linux/timer.h>
+#include <linux/percpu.h>
 #include <plat/clock.h>
 
 /*
diff --git a/include/linux/trace_clock.h b/include/linux/trace_clock.h
index 7a81303..e1e501b 100644
--- a/include/linux/trace_clock.h
+++ b/include/linux/trace_clock.h
@@ -12,8 +12,13 @@
 #include <linux/compiler.h>
 #include <linux/types.h>
 
+typedef unsigned long long (*trace_clock_t)(void);
+
 extern u64 notrace trace_clock_local(void);
 extern u64 notrace trace_clock(void);
 extern u64 notrace trace_clock_global(void);
 
+extern void notrace register_trace_clock(void);
+extern void notrace unregister_trace_clock(void);
+
 #endif /* _LINUX_TRACE_CLOCK_H */
diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index ee79207..f78744a 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -3101,6 +3101,7 @@ int register_ftrace_function(struct ftrace_ops *ops)
 	mutex_lock(&ftrace_lock);
 
 	ret = __register_ftrace_function(ops);
+	register_trace_clock();
 	ftrace_startup(0);
 
 	mutex_unlock(&ftrace_lock);
@@ -3120,6 +3121,7 @@ int unregister_ftrace_function(struct ftrace_ops *ops)
 	mutex_lock(&ftrace_lock);
 	ret = __unregister_ftrace_function(ops);
 	ftrace_shutdown(0);
+	unregister_trace_clock();
 	mutex_unlock(&ftrace_lock);
 
 	return ret;
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index b738f8e..1244f6b 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -2711,6 +2711,14 @@ tracing_ctrl_write(struct file *filp, const char __user *ubuf,
 	return cnt;
 }
 
+static int tracing_ctrl_release(struct inode *inode, struct file *file)
+{
+	/* Release the trace clock when the debugfs is umounted */
+	unregister_trace_clock();
+
+	return 0;
+}
+
 static ssize_t
 tracing_set_trace_read(struct file *filp, char __user *ubuf,
 		       size_t cnt, loff_t *ppos)
@@ -3542,6 +3550,7 @@ static const struct file_operations tracing_ctrl_fops = {
 	.open		= tracing_open_generic,
 	.read		= tracing_ctrl_read,
 	.write		= tracing_ctrl_write,
+	.release	= tracing_ctrl_release,
 };
 
 static const struct file_operations set_tracer_fops = {
diff --git a/kernel/trace/trace_clock.c b/kernel/trace/trace_clock.c
index 9d589d8..1fb5aaf 100644
--- a/kernel/trace/trace_clock.c
+++ b/kernel/trace/trace_clock.c
@@ -20,9 +20,13 @@
 #include <linux/sched.h>
 #include <linux/ktime.h>
 #include <linux/trace_clock.h>
+#include <linux/trace-clock.h>
+#include <linux/delay.h>
 
 #include "trace.h"
 
+trace_clock_t ftrace_trace_clock __read_mostly = sched_clock;
+
 /*
  * trace_clock_local(): the simplest and least coherent tracing clock.
  *
@@ -40,7 +44,7 @@ u64 notrace trace_clock_local(void)
 	 * CPUs, nor across CPU idle events.
 	 */
 	resched = ftrace_preempt_disable();
-	clock = sched_clock();
+	clock = ftrace_trace_clock();
 	ftrace_preempt_enable(resched);
 
 	return clock;
@@ -114,3 +118,101 @@ u64 notrace trace_clock_global(void)
 
 	return now;
 }
+
+/*
+ * If the trace clock can distinguish 1us' delta, we consider
+ * it has high resolution
+ */
+
+#define DELAY_US 1
+
+static bool trace_clock_get_hres(trace_clock_t func)
+{
+	unsigned long long flags;
+	u64 t1, t2, delta;
+
+	/* func() return nanosecs */
+	t1 = func();
+	raw_local_irq_save(flags);
+	udelay(DELAY_US);
+	raw_local_irq_restore(flags);
+	t2 = func();
+
+	delta = t2 - t1;
+
+	if (delta > 0)
+		return 1;
+
+	return 0;
+}
+
+static bool trace_clock_registered __read_mostly;
+static bool sched_clock_has_hres __read_mostly;
+static bool trace_clock_read64_ns_has_hres __read_mostly;
+
+void notrace register_trace_clock(void)
+{
+	if (trace_clock_registered)
+		return;
+	/*
+	 * If there is a high resolution sched_clock(), no need to
+	 * register another one.
+	 */
+	if (sched_clock_has_hres)
+		return;
+
+	if (trace_clock_read64_ns_has_hres) {
+		get_trace_clock();
+		ftrace_trace_clock = trace_clock_read64_ns;
+		trace_clock_registered = 1;
+	}
+}
+
+void notrace unregister_trace_clock(void)
+{
+	if (trace_clock_registered) {
+		trace_clock_registered = 0;
+		ftrace_trace_clock = sched_clock;
+		put_trace_clock();
+	}
+}
+
+static int __init check_res_of_trace_clock(void)
+{
+	int has_hres;
+
+	pr_info("%s: sched_clock() ", __func__);
+	if (trace_clock_get_hres(sched_clock)) {
+		pr_cont("high resolution\n");
+		sched_clock_has_hres = 1;
+	} else {
+		pr_cont("low resolution\n");
+
+		get_trace_clock();
+		pr_info("%s: trace_clock_read64_ns() ", __func__);
+		if (trace_clock_get_hres(trace_clock_read64_ns)) {
+			pr_cont("has high resolution\n");
+			trace_clock_read64_ns_has_hres = 1;
+		} else
+			pr_cont("has low resolution\n");
+		put_trace_clock();
+	}
+
+	has_hres = sched_clock_has_hres | trace_clock_read64_ns_has_hres;
+	WARN(!has_hres, "No available high resolution trace clock\n");
+
+	return 0;
+}
+
+/*
+ * Note: check_res_of_trace_clock() must be called to initialize the
+ * trace_clock_read64_ns_has_hres before the register of irqsoff,
+ * preemptoff, preemptirqsoff and wakeup tracers, otherwise, the
+ * selftest of them will fail.
+ *
+ * The low-level clocks must be initialized before us, in
+ * early_initcall(), otherwise, the kernel may hang after decompressing
+ * the kernel.
+ */
+
+arch_initcall(check_res_of_trace_clock);
-- 
1.7.2.1

