From 4bdd593c0a91938d0ded4d3aefdcc8510f2321dd Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 30 Sep 2010 03:26:17 -0700
Subject: [PATCH 2/4] tracing/trace-clock: add trace_clock_read64_ns() for all of the tracers

Before, {register, unregister}_trace_clock() has only been called in
{register, unregister}_ftrace_function(). Since {register,
unregister}_ftrace_function() are not called for all of the tracers, the
other tracers will not benefit from trace_clock_read64_ns().

As we know, all of the tracers should be enabled/disabled by
tracing_{start, stop}, so, calling {register, unregister}_trace_clock()
in tracing_{start, stop} will make all of the tracers uses
trace_clock_read64_ns().

Notice of revision:

trace_clock: bind trace clock register/unregister with tracing_enabled

The original design of using generic trace clock in Ftrace is binding
it with the operation of the tracing/tracing_enabled interface:
generic trace clock should be registered/unregistered while echoing
1/0 to tracing/tracing_enabled respectively. The currrent
implementation is:

kernel/trace/trace.c:tracing/tracing_enabled: tracing_ctrl_write()

$ echo 1 > tracing/tracing_enabled:

	tracing_ctrl_write()
		--> tracing_start();
			--> register_trace_clock();

$ echo 0 > tracing/tracing_enabled:

	tracing_ctrl_write()
		--> tracing_stop();
			--> unregister_trace_clock();

But because tracing_{start, stop} are not always called
correspondingly while echoing 1/0 to tracing/tracing_enabled, for
example, they are called while dumping the trace result:

kernel/trace/trace.c:tracing_open():__tracing_open()

	/* stop the trace while dumping */
        tracing_stop();
	...
	tracing_start();

In such case, the trace clock is registered but not released, then,
Lttng will not be able to get the trace clock and will fail.

This fixes it via moving {register, unregister}_tracing_clock() to
tracing_ctrl_write() and call them while setting tracing_enabled:

$ echo 1 > tracing/tracing_enabled:

	tracing_ctrl_write()
		--> register_trace_clock();
		--> tracing_start();

$ echo 0 > tracing/tracing_enabled:

	tracing_ctrl_write()
		--> tracing_stop();
		--> unregister_trace_clock();

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 kernel/trace/ftrace.c |    2 --
 kernel/trace/trace.c  |    2 ++
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index 1c98155..b194a29 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -3110,7 +3110,6 @@ int register_ftrace_function(struct ftrace_ops *ops)
 	mutex_lock(&ftrace_lock);
 
 	ret = __register_ftrace_function(ops);
-	register_trace_clock();
 	ftrace_startup(0);
 
 	mutex_unlock(&ftrace_lock);
@@ -3130,7 +3129,6 @@ int unregister_ftrace_function(struct ftrace_ops *ops)
 	mutex_lock(&ftrace_lock);
 	ret = __unregister_ftrace_function(ops);
 	ftrace_shutdown(0);
-	unregister_trace_clock();
 	mutex_unlock(&ftrace_lock);
 
 	return ret;
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 75fe4a0..99d5885 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -2702,6 +2702,7 @@ tracing_ctrl_write(struct file *filp, const char __user *ubuf,
 	if (tracer_enabled ^ val) {
 		if (val) {
 			tracer_enabled = 1;
+			register_trace_clock();
 			if (current_trace->start)
 				current_trace->start(tr);
 			tracing_start();
@@ -2710,6 +2711,7 @@ tracing_ctrl_write(struct file *filp, const char __user *ubuf,
 			tracing_stop();
 			if (current_trace->stop)
 				current_trace->stop(tr);
+			unregister_trace_clock();
 		}
 	}
 	mutex_unlock(&trace_types_lock);
-- 
1.7.0.4

