From 909c9b0d0dc54677824ac13ef27bccdb774f3a1d Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 2 Sep 2010 03:52:28 -0700
Subject: [PATCH 2/2] tracing/ftrace: MIPS: Fixup of the support for SMP

To flush the icaches on the other cpus, the irqs of the cpus should be
enabled to accept the ipi interrupts. otherwise, the icaches on the
other cpus may not be flushed and even make the system hang: the current
cpu may wait for the other cpus to flush their icaches, but the other
cpus can not response for the irqs are disabled.

To fix this problem, this patch delays the icache flushing operation
after the irqs are enabled.

Benefit from this fix, the system performance will be improved for
currently, we only need to flush the whole icache one time at the end
instead of flush thousands of entries individually.

A 'side effect' is, from now on, any user of ftrace_modify_code() in
MIPS should flush the icache itself.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/kernel/ftrace.c |   55 ++++++++++++++++++++++++++++++++++++--------
 1 files changed, 45 insertions(+), 10 deletions(-)

diff --git a/arch/mips/kernel/ftrace.c b/arch/mips/kernel/ftrace.c
index 5a84a1f..5d21901 100644
--- a/arch/mips/kernel/ftrace.c
+++ b/arch/mips/kernel/ftrace.c
@@ -69,6 +69,45 @@ static inline void ftrace_dyn_arch_init_insns(void)
 #endif
 }
 
+#define FTRACE_CALL_IP ((unsigned long)(&ftrace_call))
+
+#ifdef CONFIG_FUNCTION_GRAPH_TRACER
+extern void ftrace_graph_call(void);
+#define FTRACE_GRAPH_CALL_IP	((unsigned long)(&ftrace_graph_call))
+#endif
+
+static inline void flush_icache_from(unsigned long start)
+{
+	flush_icache_range(start, start + 8);
+}
+
+int ftrace_arch_code_modify_post_process(void *data)
+{
+	int *command = data;
+
+	if (*command & FTRACE_UPDATE_TRACE_FUNC)
+		flush_icache_from(FTRACE_CALL_IP);
+#ifdef CONFIG_FUNCTION_GRAPH_TRACER
+	else if ((*command & FTRACE_START_FUNC_RET)
+		|| (*command & FTRACE_STOP_FUNC_RET))
+		flush_icache_from(FTRACE_GRAPH_CALL_IP);
+#endif
+	else
+		__flush_cache_all();
+
+	return 0;
+}
+
+int ftrace_arch_module_modify_post_process(void)
+{
+	__flush_cache_all();
+	return 0;
+}
+
+/*
+ * In MIPS, ftrace_modify_code() doesn't flush the icache, If use it,
+ * please flush the icache yourself.
+ */
 static int ftrace_modify_code(unsigned long ip, unsigned int new_code)
 {
 	int faulted;
@@ -79,8 +118,6 @@ static int ftrace_modify_code(unsigned long ip, unsigned int new_code)
 	if (unlikely(faulted))
 		return -EFAULT;
 
-	flush_icache_range(ip, ip + 8);
-
 	return 0;
 }
 
@@ -138,8 +175,6 @@ int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)
 	return ftrace_modify_code(ip, new);
 }
 
-#define FTRACE_CALL_IP ((unsigned long)(&ftrace_call))
-
 int ftrace_update_ftrace_func(ftrace_func_t func)
 {
 	unsigned int new;
@@ -154,12 +189,15 @@ int __init ftrace_dyn_arch_init(void *data)
 	/* Encode the instructions when booting */
 	ftrace_dyn_arch_init_insns();
 
-	/* Remove "b ftrace_stub" to ensure ftrace_caller() is executed */
-	ftrace_modify_code(MCOUNT_ADDR, INSN_NOP);
-
 	/* The return code is retured via data */
 	*(unsigned long *)data = 0;
 
+	/* Remove "b ftrace_stub" to ensure ftrace_caller() is executed */
+	ftrace_modify_code(MCOUNT_ADDR, INSN_NOP);
+	/* To flush the icache in SMP, the irq should be enabled */
+	local_irq_enable();
+	flush_icache_from(MCOUNT_ADDR);
+
 	return 0;
 }
 #endif	/* CONFIG_DYNAMIC_FTRACE */
@@ -168,9 +206,6 @@ int __init ftrace_dyn_arch_init(void *data)
 
 #ifdef CONFIG_DYNAMIC_FTRACE
 
-extern void ftrace_graph_call(void);
-#define FTRACE_GRAPH_CALL_IP	((unsigned long)(&ftrace_graph_call))
-
 int ftrace_enable_ftrace_graph_caller(void)
 {
 	return ftrace_modify_code(FTRACE_GRAPH_CALL_IP,
-- 
1.6.5.2

