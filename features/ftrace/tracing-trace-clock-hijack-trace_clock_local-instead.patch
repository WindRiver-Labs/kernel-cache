From ad62baff45b4571a6265b40886c1642929492b19 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 30 Sep 2010 03:26:19 -0700
Subject: [PATCH 4/4] tracing/trace-clock: hijack trace_clock_local() instead of sched_clock()

Like trace_clock_local(), trace_clock_read64() also disabled the
preemption, so, just hijack trace_clock_local() instead of
sched_clock(), this removes the duplicated preemption disabling and also
ensures the trace-clock-32-to-64 work with function_graph tracer.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 kernel/trace/trace_clock.c |   17 +++++++++++------
 1 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/kernel/trace/trace_clock.c b/kernel/trace/trace_clock.c
index 11efc61..4fe84e0 100644
--- a/kernel/trace/trace_clock.c
+++ b/kernel/trace/trace_clock.c
@@ -25,15 +25,13 @@
 
 #include "trace.h"
 
-trace_clock_t ftrace_trace_clock __read_mostly = sched_clock;
-
 /*
  * trace_clock_local(): the simplest and least coherent tracing clock.
  *
  * Useful for tracing that does not cross to other CPUs nor
  * does it go through idle events.
  */
-u64 notrace trace_clock_local(void)
+u64 notrace orig_trace_clock_local(void)
 {
 	u64 clock;
 	int resched;
@@ -44,12 +42,19 @@ u64 notrace trace_clock_local(void)
 	 * CPUs, nor across CPU idle events.
 	 */
 	resched = ftrace_preempt_disable();
-	clock = ftrace_trace_clock();
+	clock = sched_clock();
 	ftrace_preempt_enable(resched);
 
 	return clock;
 }
 
+trace_clock_t ftrace_trace_clock __read_mostly = orig_trace_clock_local;
+
+u64 notrace trace_clock_local(void)
+{
+	return ftrace_trace_clock();
+}
+
 /*
  * trace_clock(): 'inbetween' trace clock. Not completely serialized,
  * but not completely incorrect when crossing CPUs either.
@@ -192,7 +197,7 @@ void notrace unregister_trace_clock(void)
 	trace_clock_lock();
 	if (trace_clock_registered) {
 		trace_clock_registered = 0;
-		ftrace_trace_clock = sched_clock;
+		ftrace_trace_clock = orig_trace_clock_local;
 		put_trace_clock();
 	}
 	trace_clock_unlock();
@@ -203,7 +208,7 @@ static int __init check_res_of_trace_clock(void)
 	int has_hres;
 
 	pr_info("%s: sched_clock() ", __func__);
-	if (trace_clock_get_hres(sched_clock)) {
+	if (trace_clock_get_hres(orig_trace_clock_local)) {
 		pr_cont("high resolution\n");
 		sched_clock_has_hres = 1;
 	} else {
-- 
1.6.5.2

