From e33e90377d1e52f7a3994193cb6b668a9c1ed58c Mon Sep 17 00:00:00 2001
From: Hui Wang <Hui.Wang@windriver.com>
Date: Wed, 13 Apr 2011 10:20:49 +0800
Subject: [PATCH 1/4] gpu/pvr: SGX-KM Initial SGX driver integration for kernel

referred to: 0fd2d775 of git://gitorious.org/pandroid/kernel-omap.git

This is the first version of SGX driver integration to ensure UI
boot-up. Power management and hwmod modifications will be added
as patches.

Signed-off-by: Hemant Hariyani <hemanthariyani@ti.com>

[Only keep two parts, 1) Makefile and Kconfig, 2) pvr/display
directory, because except pvr/display, all other source files will be
replaced by ones in the Ti Graphics_SDK.4.03.00.01. For files in the
pvr/display, they are for OMAP4 SGX540 Virtual Display functions and
are not in the Graphics_SDK package yet.]

Integrated-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/gpu/Makefile                            |    2 +
 drivers/gpu/pvr/Kconfig                         |   90 ++
 drivers/gpu/pvr/Makefile                        |  143 ++
 drivers/gpu/pvr/display/omap_display.c          | 1087 +++++++++++++++
 drivers/gpu/pvr/display/omap_display.h          |  109 ++
 drivers/gpu/pvr/display/omap_sgx_displayclass.c | 1641 +++++++++++++++++++++++
 drivers/gpu/pvr/display/omap_sgx_displayclass.h |  123 ++
 drivers/video/Kconfig                           |    2 +
 8 files changed, 3197 insertions(+), 0 deletions(-)
 create mode 100644 drivers/gpu/pvr/Kconfig
 create mode 100644 drivers/gpu/pvr/Makefile
 create mode 100644 drivers/gpu/pvr/display/omap_display.c
 create mode 100644 drivers/gpu/pvr/display/omap_display.h
 create mode 100644 drivers/gpu/pvr/display/omap_sgx_displayclass.c
 create mode 100644 drivers/gpu/pvr/display/omap_sgx_displayclass.h

diff --git a/drivers/gpu/Makefile b/drivers/gpu/Makefile
index 30879df..8dc1123 100644
--- a/drivers/gpu/Makefile
+++ b/drivers/gpu/Makefile
@@ -1 +1,3 @@
 obj-y			+= drm/ vga/
+obj-y			+= pvr/
+
diff --git a/drivers/gpu/pvr/Kconfig b/drivers/gpu/pvr/Kconfig
new file mode 100644
index 0000000..8479735
--- /dev/null
+++ b/drivers/gpu/pvr/Kconfig
@@ -0,0 +1,90 @@
+config SGX540
+	tristate "PowerVR SGX"
+	depends on ARCH_OMAP4
+	---help---
+	  Support for the PowerVR SGX 3D core.
+
+config SGX530
+	tristate "PowerVR SGX"
+	depends on ARCH_OMAP3
+	---help---
+	  Support for the PowerVR SGX 3D core.
+
+config VIRTUAL_DISPLAY_SUPPORT
+	tristate "Virtual display support"
+	depends on SGX540
+	---help---
+	  Support for showing one framebuffer split in 2 displays at the same
+	  time. Each display will show a part of the framebuffer by updating
+	  the corresponding overlay on each display. This feature requires
+	  2 framebuffers so CONFIG_FB_OMAP2_NUM_FBS must be 2 and each
+	  framebuffer must be initialized correctly.
+	  The current implementation supports only panels of the same X and Y
+	  resolutions and both panels must have the same bits per pixel values.
+	  This feature is EXPERIMENTAL and might not be stable if power
+	  management is added at the moment.
+	  It is important to give enough memory to FB0 to allow at least
+	  one buffer with twice the height of a normal single display buffer,
+	  so if the panel needs 864x480x4 bytes for one single display buffer
+	  you must give twice the size which is 864x960x4 with the bootargs
+	  omapfb.vram='0:4M'. To enable double buffering you need to give
+	  864x960x4x2 bytes for two buffers, the bootargs should have
+	  omapfb.vram='0:8M'. Since FB1 must also be initialized properly be
+	  sure to left enough memory for one single buffer (864x480x4 bytes).
+	  The bootarg 'vram' must have the FB0 and FB1 memory requirements
+	  combined. Example:
+	  If you want FB0 with 4M (no double buffering) and FB1 with 2M, the
+	  bootargs must have the following:
+	  vram='6M' omapfb.vram='0:4M,1:2M'
+
+choice
+	prompt "SGX revision"
+	depends on SGX530
+	default SGX_REV125
+
+config SGX_REV121
+       bool "Revision 1.2.1 - Omap 3430"
+
+config SGX_REV125
+	bool "Revision 1.2.5 - Omap 3630"
+
+endchoice
+
+choice
+	prompt "SGX revision"
+	depends on SGX540
+	default SGX_REV120
+
+config SGX_REV110
+       bool "Revision 1.1.0 - Omap 4430 ES1"
+
+config SGX_REV120
+       bool "Revision 1.2.0 - Omap 4430 ES2"
+
+endchoice
+
+choice
+	prompt "PowerVR build type"
+	depends on SGX530
+	default SGX_530_BUILD_RELEASE
+
+config SGX_530_BUILD_RELEASE
+       bool "SGX530 RELEASE"
+
+config SGX_530_BUILD_DEBUG
+       bool "SGX530 DEBUG"
+
+endchoice
+
+choice
+	prompt "PowerVR build type"
+	depends on SGX540
+	default SGX_540_BUILD_RELEASE
+
+config SGX_540_BUILD_RELEASE
+       bool "SGX540 RELEASE"
+
+config SGX_540_BUILD_DEBUG
+       bool "SGX540 DEBUG"
+
+endchoice
diff --git a/drivers/gpu/pvr/Makefile b/drivers/gpu/pvr/Makefile
new file mode 100644
index 0000000..3039c15
--- /dev/null
+++ b/drivers/gpu/pvr/Makefile
@@ -0,0 +1,143 @@
+#
+ccflags-y = -DLINUX -D__linux__ -Idrivers/gpu/pvr \
+	-DANDROID \
+	-DPVR_BUILD_DIR="\"omap_sgx_android\"" \
+	-DSGX_DYNAMIC_TIMING_INFO \
+	-DSYS_CUSTOM_POWERLOCK_WRAP \
+	-DSERVICES4 \
+	-DSUPPORT_SRVINIT \
+	-DSUPPORT_PERCONTEXT_PB \
+	-DTRANSFER_QUEUE \
+	-DSYS_USING_INTERRUPTS \
+	-DPVR_SECURE_HANDLES \
+	-DPVR_SECURE_FD_EXPORT \
+	-DLDM_PLATFORM \
+	-DSUPPORT_SGX_HWPERF \
+	-DSUPPORT_MEMINFO_IDS \
+	-DDISPLAY_CONTROLLER=omaplfb \
+	-DSYS_SGX_ACTIVE_POWER_LATENCY_MS=1 \
+	-DPVR_BUILD_DATE="" \
+	-DSUPPORT_SGX \
+	-DCLIENT_DRIVER_DEFAULT_WAIT_RETRIES=50 \
+	-DPVR_LINUX_TIMERS_USING_WORKQUEUES \
+	-DFLIP_TECHNIQUE_OVERLAY \
+	-DPVR_LINUX_USING_WORKQUEUES \
+	-DSUPPORT_ANDROID_PLATFORM \
+	-DPVR_LINUX_MISR_USING_PRIVATE_WORKQUEUE \
+	-DSYS_CUSTOM_POWERLOCK_WRAP \
+	-DSUPPORT_SGX_NEW_STATUS_VALS \
+	-DPVRSRV_MODNAME="\"pvrsrvkm"\"
+
+ccflags-$(CONFIG_SGX540) +=  -Idrivers/gpu/pvr/omap4  -Idrivers/gpu/pvr/sgx \
+	-DNO_OMAP_TIMER \
+	-DSGX_CLK_CORE_DIV5 \
+	-DSGX540 -DSUPPORT_SGX540
+
+ccflags-$(CONFIG_SGX_REV110) += -DSGX_CORE_REV=110
+ccflags-$(CONFIG_SGX_REV120) += -DSGX_CORE_REV=120
+
+ccflags-$(CONFIG_SGX530) +=  -Idrivers/gpu/pvr/omap3  -Idrivers/gpu/pvr/sgx \
+	-DSGX530 -DSUPPORT_SGX530
+
+ccflags-$(CONFIG_SGX_REV125) += -DSGX_CORE_REV=125
+ccflags-$(CONFIG_SGX_REV121) += -DSGX_CORE_REV=121
+
+ccflags-$(CONFIG_SGX_530_BUILD_RELEASE) += \
+	-DPVR_BUILD_TYPE="\"release\"" \
+	-DRELEASE \
+	-DSUPPORT_ACTIVE_POWER_MANAGEMENT \
+	-DSGX_EARLYSUSPEND \
+	-DSUPPORT_HW_RECOVERY \
+	-DSUPPORT_SGX_LOW_LATENCY_SCHEDULING
+
+ccflags-$(CONFIG_SGX_530_BUILD_DEBUG) += \
+	-DPVR_BUILD_TYPE="\"debug\""  -DDEBUG \
+	-DDEBUG_LINUX_MEMORY_ALLOCATIONS \
+	-DDEBUG_LINUX_MEM_AREAS \
+	-DDEBUG_LINUX_MMAP_AREAS \
+	-DDEBUG_BRIDGE_KM \
+	-DPVRSRV_USSE_EDM_STATUS_DEBUG \
+	-DPVRSRV_DUMP_MK_TRACE \
+	-DDEBUG_LOG_PATH_TRUNCATE="\"eurasia_km\""
+
+ccflags-$(CONFIG_SGX_540_BUILD_RELEASE) += \
+	-DPVR_BUILD_TYPE="\"release\"" \
+	-DRELEASE \
+	-DSUPPORT_ACTIVE_POWER_MANAGEMENT \
+	-DSUPPORT_SGX_LOW_LATENCY_SCHEDULING
+
+ccflags-$(CONFIG_SGX_540_BUILD_DEBUG) += \
+	-DPVR_BUILD_TYPE="\"debug\""  -DDEBUG \
+	-DSUPPORT_ACTIVE_POWER_MANAGEMENT \
+	-DDEBUG_LINUX_MEMORY_ALLOCATIONS \
+	-DDEBUG_LINUX_MEM_AREAS \
+	-DDEBUG_LINUX_MMAP_AREAS \
+	-DDEBUG_BRIDGE_KM \
+	-DPVRSRV_USSE_EDM_STATUS_DEBUG \
+	-DPVRSRV_DUMP_MK_TRACE \
+	-DDEBUG_LOG_PATH_TRUNCATE="\"eurasia_km\""
+
+pvr_common-y := \
+	osfunc.o \
+	mutils.o \
+	mmap.o \
+	module.o \
+	pdump.o \
+	proc.o \
+	pvr_bridge_k.o \
+	pvr_debug.o \
+	mm.o \
+	mutex.o \
+	event.o \
+	osperproc.o \
+	buffer_manager.o \
+	devicemem.o \
+	deviceclass.o \
+	handle.o \
+	hash.o \
+	metrics.o \
+	pvrsrv.o \
+	queue.o \
+	ra.o \
+	resman.o \
+	power.o \
+	mem.o \
+	pdump_common.o \
+	bridged_support.o \
+	bridged_pvr_bridge.o \
+	perproc.o \
+	lists.o \
+	mem_debug.o \
+	osfunc_common.o
+
+pvr540-$(CONFIG_SGX540) := \
+	omap4/sysconfig.o \
+	omap4/sysutils.o
+
+pvr530-$(CONFIG_SGX530) := \
+	omap3/sysconfig.o \
+	omap3/sysutils.o
+
+sgx-y :=  \
+	sgx/bridged_sgx_bridge.o \
+	sgx/sgxinit.o \
+	sgx/sgxpower.o \
+	sgx/sgxreset.o \
+	sgx/sgxutils.o \
+	sgx/sgxkick.o \
+	sgx/sgxtransfer.o \
+	sgx/mmu.o \
+	sgx/pb.o
+
+sgx_displayclass-y := \
+	display/omap_sgx_displayclass.o \
+	display/omap_display.o
+
+omaplfb-y := \
+	omaplfb/omaplfb_displayclass.o \
+	omaplfb/omaplfb_linux.o
+
+obj-$(CONFIG_SGX540) := pvr_common.o sgx.o omaplfb.o pvr540.o
+obj-$(CONFIG_SGX530) := pvr_common.o sgx.o omaplfb.o pvr530.o
+obj-$(CONFIG_VIRTUAL_DISPLAY_SUPPORT) := pvr_common.o sgx.o \
+	sgx_displayclass.o pvr540.o
diff --git a/drivers/gpu/pvr/display/omap_display.c b/drivers/gpu/pvr/display/omap_display.c
new file mode 100644
index 0000000..1f13075
--- /dev/null
+++ b/drivers/gpu/pvr/display/omap_display.c
@@ -0,0 +1,1087 @@
+/*
+ * drivers/gpu/pvr/display/omap_display.c
+ *
+ * Copyright (C) 2010 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fb.h>
+
+#include <plat/vrfb.h>
+#include <plat/display.h>
+
+/* Workaround for DEBUG macro clash in framebuffer */
+#ifdef RELEASE
+#include <../drivers/video/omap2/omapfb/omapfb.h>
+#undef DEBUG
+#else
+#undef DEBUG
+#include <../drivers/video/omap2/omapfb/omapfb.h>
+#endif
+
+#define OMAP_DISP_DRV_NAME "omap_display"
+#define OMAP_DISP_FRAMEBUFFER_COUNT num_registered_fb
+
+#define OMAP_DISP_PAGE_MASK (PAGE_SIZE - 1)
+#define OMAP_DISP_PAGE_TRUNCATE (~OMAP_DISP_PAGE_MASK)
+#define OMAP_DISP_PAGE_ROUND_UP(x) \
+	(((x)+OMAP_DISP_PAGE_MASK) & OMAP_DISP_PAGE_TRUNCATE)
+
+#define OMAP_DISP_IRQ_TIMEOUT 500
+
+#ifdef DEBUG
+#define DBG_PRINT(format, ...) printk(KERN_DEBUG OMAP_DISP_DRV_NAME \
+	" (%s %i): " format "\n", __func__, __LINE__, ## __VA_ARGS__)
+#define WRN_PRINT(format, ...) printk(KERN_WARNING OMAP_DISP_DRV_NAME \
+	" (%s %i): " format "\n", __func__, __LINE__, ## __VA_ARGS__)
+#define ERR_PRINT(format, ...) printk(KERN_ERR OMAP_DISP_DRV_NAME \
+	" (%s %i): " format "\n", __func__, __LINE__, ## __VA_ARGS__)
+#else
+#define DBG_PRINT(format, ...)
+#define WRN_PRINT(format, ...)
+#define ERR_PRINT(format, ...)
+#endif
+
+#include "omap_display.h"
+
+/* List for the available displays */
+static struct omap_display_device *omap_display_list;
+static unsigned int omap_display_number;
+
+/* Forward declarations */
+static struct omap_display_buffer *create_main_buffer(
+	struct omap_display_device *display);
+static int display_destroy_buffer(struct omap_display_buffer *buffer);
+
+static int open_display(struct omap_display_device *display,
+	enum omap_display_feature features)
+{
+	int i;
+
+	DBG_PRINT("Opening display '%s'", display->name);
+
+	/* TODO: Support horizontal orientation */
+	if (features & ORIENTATION_HORIZONTAL) {
+		DBG_PRINT("Horizontal orientation is not supported yet , "
+			"falling back to vertical orientation");
+		features = ORIENTATION_VERTICAL;
+	}
+
+	display->features = features;
+	display->reference_count++;
+	for (i = 0; i < display->overlay_managers_count; i++)
+		omap_dss_get_device(display->overlay_managers[i]->device);
+
+	/* If the main buffer doesn't exist create it */
+	if (!display->main_buffer) {
+		DBG_PRINT("Main buffer doesn't exist for display '%s', create"
+			" one", display->name);
+		display->main_buffer = create_main_buffer(display);
+		if (!display->main_buffer) {
+			ERR_PRINT("Failed to create main buffer for '%s'",
+				display->name);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int close_display(struct omap_display_device *display)
+{
+	int err;
+	int i;
+
+	/* TODO: Is it the same thing to close a virtual and single display? */
+	DBG_PRINT("Closing display '%s'", display->name);
+
+	display->reference_count--;
+	for (i = 0; i < display->overlay_managers_count; i++)
+		omap_dss_put_device(display->overlay_managers[i]->device);
+
+	if (display->flip_chain) {
+		err = display->destroy_flip_chain(display);
+		display->flip_chain = 0;
+		if (err)
+			WRN_PRINT("An error happened when destroying flip "
+				"chain for '%s'", display->name);
+	}
+
+	return 0;
+}
+
+static int get_max_buffers(struct omap_display_device *display)
+{
+	/* TODO: If TILER is wanted to be used how do you calculate this? */
+	int fb_idx;
+	switch (display->id) {
+	case OMAP_DISPID_PRIMARY:
+		fb_idx = 0;
+		break;
+	case OMAP_DISPID_SECONDARY:
+		fb_idx = 1;
+		break;
+	case OMAP_DISPID_TERTIARY:
+		fb_idx = 2;
+		break;
+	case OMAP_DISPID_VIRTUAL:
+		fb_idx = 0;
+		break;
+	case OMAP_DISPID_BADSTATE:
+	default:
+		ERR_PRINT("Unknown display id %i", display->id);
+		BUG();
+	}
+
+	/* Use the framebuffer memory */
+	if (fb_idx >= 0 && fb_idx < num_registered_fb) {
+		struct fb_info *framebuffer = registered_fb[fb_idx];
+		unsigned long buffer_size;
+
+		/* Single buffer size */
+		buffer_size = display->width * display->height *
+			display->bytes_per_pixel;
+		/* Page align the buffer size, round up to the page size */
+		buffer_size = OMAP_DISP_PAGE_ROUND_UP(buffer_size);
+
+		return (int) (framebuffer->fix.smem_len / buffer_size);
+	} else {
+		ERR_PRINT("Framebuffer %i doesn't exist for display '%s'",
+			fb_idx, display->name);
+		return 0;
+	}
+}
+
+static int create_flip_chain(struct omap_display_device *display,
+	unsigned int buffer_count)
+{
+	int fb_idx;
+
+	/* TODO: What about TILER buffers */
+	if (buffer_count <= 1) {
+		ERR_PRINT("Flip chains with %i buffers not supported",
+			buffer_count);
+		return 1;
+	} else if (buffer_count > display->buffers_available) {
+		ERR_PRINT("Requesting %i buffers when there is %i available"
+			" for '%s'", buffer_count, display->buffers_available,
+			display->name);
+		return 1;
+	} else if (display->flip_chain) {
+		ERR_PRINT("Flip chain already exists for '%s'", display->name);
+		return 1;
+	}
+
+	/* Create the flip chain with the framebuffer memory */
+	switch (display->id) {
+	case OMAP_DISPID_PRIMARY:
+		fb_idx = 0;
+		break;
+	case OMAP_DISPID_SECONDARY:
+		fb_idx = 1;
+		break;
+	case OMAP_DISPID_TERTIARY:
+		fb_idx = 2;
+		break;
+	case OMAP_DISPID_VIRTUAL:
+		fb_idx = 0;
+		break;
+	case OMAP_DISPID_BADSTATE:
+	default:
+		ERR_PRINT("Unknown display id %i", display->id);
+		BUG();
+	}
+
+	/* Use the framebuffer memory */
+	if (fb_idx >= 0 && fb_idx < num_registered_fb) {
+		struct fb_info *framebuffer = registered_fb[fb_idx];
+		unsigned long buffer_size;
+		struct omap_display_flip_chain *flip_chain;
+		int i;
+
+		if (!framebuffer || !framebuffer->fix.smem_start ||
+			!framebuffer->screen_base) {
+			ERR_PRINT("Framebuffer %i doesn't seem to be "
+				"initialized", fb_idx);
+			return 1;
+		}
+
+		/*
+		 * Check if there is enough memory in the fb for the requested
+		 * buffers
+		 */
+		buffer_size = display->width * display->height *
+			display->bytes_per_pixel;
+		/* Page align the buffer size, round up to the page size */
+		buffer_size = OMAP_DISP_PAGE_ROUND_UP(buffer_size);
+
+		if (buffer_size * buffer_count > framebuffer->fix.smem_len) {
+			ERR_PRINT("Not enough memory to allocate %i buffers "
+				"(%lu bytes each), memory available %lu for "
+				"display '%s'", buffer_count, buffer_size,
+				(unsigned long)framebuffer->fix.smem_len,
+				display->name);
+			return 1;
+		}
+
+		flip_chain = kzalloc(sizeof(*flip_chain), GFP_KERNEL);
+
+		if (!flip_chain) {
+			ERR_PRINT("Out of memory");
+			return 1;
+		}
+
+		for (i = 0; i < buffer_count; i++) {
+			struct omap_display_buffer *buffer;
+
+			/*
+			 * Reuse the main buffer as the first buffer in the
+			 * flip chain
+			 */
+			if (i == 0) {
+				buffer = display->main_buffer;
+				flip_chain->buffers[i] = buffer;
+				DBG_PRINT("Flip chain buffer %i has address "
+					"%lx for display '%s'", i,
+					buffer->physical_addr, display->name);
+				continue;
+			}
+
+			buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
+
+			if (!buffer) {
+				/*
+				 * FIXME: If one buffer allocation fails,
+				 * deallocate flip chain and buffers
+				 */
+				ERR_PRINT("Out of memory");
+				return 1;
+			}
+
+			buffer->physical_addr = framebuffer->fix.smem_start +
+				(buffer_size * i);
+			buffer->virtual_addr =
+				(unsigned long) framebuffer->screen_base +
+				(buffer_size * i);
+			buffer->size = buffer_size;
+			buffer->display = display;
+			flip_chain->buffers[i] = buffer;
+
+			DBG_PRINT("Flip chain buffer %i has address %lx for"
+				" display '%s'", i, buffer->physical_addr,
+				display->name);
+		}
+
+		display->flip_chain = flip_chain;
+		return 0;
+	} else {
+		ERR_PRINT("Framebuffer %i doesn't exist for display '%s'",
+			fb_idx, display->name);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int destroy_flip_chain(struct omap_display_device *display)
+{
+	int i;
+	int err;
+
+	if (!display->flip_chain) {
+		DBG_PRINT("No flip chain to destroy for '%s'", display->name);
+		return 0;
+	}
+
+	for (i = 0; i < display->flip_chain->buffer_count; i++) {
+		struct omap_display_buffer *buffer =
+			display->flip_chain->buffers[i];
+		/* If buffer is main buffer don't touch it */
+		if (display->main_buffer == buffer)
+			continue;
+
+		err = display_destroy_buffer(buffer);
+		if (err) {
+			ERR_PRINT("Error destroying buffer in flip chain for"
+			" '%s'", display->name);
+			return 1;
+		}
+	}
+
+	DBG_PRINT("Destroying flip chain for '%s'", display->name);
+	kfree(display->flip_chain);
+	display->flip_chain = 0;
+
+	return 0;
+}
+
+static int rotate_display(struct omap_display_device *display,
+	unsigned int rotation)
+{
+	ERR_PRINT("Not supported yet");
+	return 1;
+}
+
+static int display_destroy_buffer(struct omap_display_buffer *buffer)
+{
+	kfree(buffer);
+	return 0;
+}
+
+static int present_buffer_virtual(struct omap_display_buffer *buffer)
+{
+	/*
+	 * TODO: Support for ORIENTATION_VERTICAL is in place,
+	 * ORIENTATION_HORIZONTAL is missing
+	 */
+	struct omap_display_device *display_virtual = buffer->display;
+	struct omap_display_device *display_primary;
+	struct omap_display_device *display_secondary;
+	struct omap_display_buffer temp_buffer;
+	unsigned int buffer_offset;
+
+	if (display_virtual->id != OMAP_DISPID_VIRTUAL) {
+		ERR_PRINT("Not a virtual display");
+		BUG();
+	}
+
+	display_primary = omap_display_get(OMAP_DISPID_PRIMARY);
+	display_secondary = omap_display_get(OMAP_DISPID_SECONDARY);
+	/*
+	 * Calculate offset without page alignment round up otherwise second
+	 * display may see incorrect data
+	 */
+	buffer_offset = display_primary->height * display_virtual->byte_stride;
+
+	/* The first buffer will be the base */
+	temp_buffer.physical_addr = buffer->physical_addr;
+	temp_buffer.virtual_addr = buffer->virtual_addr;
+	temp_buffer.size = buffer->size >> 1;
+
+	if (display_virtual->features & ORIENTATION_INVERT) {
+		/* Secondary display has the base */
+		temp_buffer.display = display_secondary;
+		display_secondary->present_buffer(&temp_buffer);
+	} else {
+		/* Primary display has the base */
+		temp_buffer.display = display_primary;
+		display_primary->present_buffer(&temp_buffer);
+	}
+
+	/* Remaining display will show the rest */
+	temp_buffer.physical_addr = buffer->physical_addr + buffer_offset;
+	temp_buffer.virtual_addr = buffer->virtual_addr + buffer_offset;
+
+	if (display_virtual->features & ORIENTATION_INVERT) {
+		temp_buffer.display = display_primary;
+		display_primary->present_buffer(&temp_buffer);
+	} else {
+		temp_buffer.display = display_secondary;
+		display_secondary->present_buffer(&temp_buffer);
+	}
+
+	return 0;
+}
+
+static int present_buffer(struct omap_display_buffer *buffer)
+{
+	struct omap_display_device *display = buffer->display;
+	int fb_idx;
+
+	switch (display->id) {
+	case OMAP_DISPID_PRIMARY:
+		fb_idx = 0;
+		break;
+	case OMAP_DISPID_SECONDARY:
+		fb_idx = 1;
+		break;
+	case OMAP_DISPID_TERTIARY:
+		fb_idx = 2;
+		break;
+	case OMAP_DISPID_VIRTUAL:
+	case OMAP_DISPID_BADSTATE:
+	default:
+		ERR_PRINT("Unable to handle display %i", display->id);
+		BUG();
+	}
+
+	if (fb_idx >= 0 && fb_idx < num_registered_fb) {
+		struct fb_info *framebuffer = registered_fb[fb_idx];
+		struct omapfb_info *ofbi = FB2OFB(framebuffer);
+		struct omapfb2_device *fbdev = ofbi->fbdev;
+		struct omap_overlay *overlay;
+		struct omap_overlay_info overlay_info;
+		struct omap_dss_device *dss_device;
+		int i;
+
+		omapfb_lock(fbdev);
+
+		/* Get the overlays attached to the framebuffer */
+		for (i = 0; i < ofbi->num_overlays ; i++) {
+			overlay = ofbi->overlays[i];
+			overlay->get_overlay_info(overlay, &overlay_info);
+
+			/* If the overlay is not enabled don't update it */
+			if (!overlay_info.enabled)
+				continue;
+
+			overlay_info.paddr = buffer->physical_addr;
+			overlay_info.vaddr = (void *) buffer->virtual_addr;
+			overlay->set_overlay_info(overlay, &overlay_info);
+
+			if (overlay->manager) {
+				overlay->manager->apply(overlay->manager);
+				dss_device = overlay->manager->device;
+				/*
+				 * FIXME: Is the update really needed?
+				 * On 2.6.35 calling this code triggers a bug
+				 */
+#if 0
+				if (dss_device &&
+					dss_device->driver->update) {
+					dss_device->driver->update(
+						dss_device,
+						0, 0,
+						overlay_info.width,
+						overlay_info.height);
+				}
+#endif
+			}
+		}
+
+		omapfb_unlock(fbdev);
+	} else {
+		ERR_PRINT("Framebuffer %i doesn't exist for display '%s'",
+			fb_idx, display->name);
+		return 1;
+	}
+
+	return 0;
+}
+
+static u32 get_dss_irq(struct omap_dss_device *dss_device)
+{
+	u32 irq;
+
+	if (dss_device->type == OMAP_DISPLAY_TYPE_VENC)
+		irq = DISPC_IRQ_EVSYNC_ODD;
+	else if (dss_device->type == OMAP_DISPLAY_TYPE_HDMI)
+		irq = DISPC_IRQ_EVSYNC_EVEN;
+	else if (dss_device->type == OMAP_DISPLAY_TYPE_DSI)
+		if (!strcmp(dss_device->name, "lcd"))
+			irq = DISPC_IRQ_FRAMEDONE;
+		else
+			irq = DISPC_IRQ_FRAMEDONE2;
+	else
+		if (!strcmp(dss_device->name, "lcd"))
+			irq = DISPC_IRQ_VSYNC;
+		else
+			irq = DISPC_IRQ_VSYNC2;
+
+	return irq;
+}
+
+static int present_buffer_sync(struct omap_display_buffer *buffer)
+{
+	/* TODO: Cloning may tear with this implementation */
+	int err = 0;
+	struct omap_display_device *display = buffer->display;
+
+	err = display->sync(display);
+	err |= display->present_buffer(buffer);
+
+	return err;
+}
+
+static int present_buffer_sync_virtual(struct omap_display_buffer *buffer)
+{
+	void display_irq_wait_1(void *data, u32 mask)
+	{
+		struct omap_display_sync_item *sync_item =
+			(struct omap_display_sync_item *) data;
+
+		if (sync_item->invalidate)
+			return;
+
+		/* IRQ happened, present immediately */
+		sync_item->invalidate = 1;
+		sync_item->buffer->display->present_buffer(sync_item->buffer);
+		complete(sync_item->task);
+	}
+
+	void display_irq_wait_2(void *data, u32 mask)
+	{
+		struct omap_display_sync_item *sync_item =
+			(struct omap_display_sync_item *) data;
+
+		if (sync_item->invalidate)
+			return;
+
+		/* IRQ happened, present immediately */
+		sync_item->invalidate = 1;
+		sync_item->buffer->display->present_buffer(sync_item->buffer);
+		complete(sync_item->task);
+	}
+
+	/*
+	 * TODO: Support for ORIENTATION_VERTICAL is in place,
+	 * ORIENTATION_HORIZONTAL is missing. Some code can be reduced here,
+	 * it will be simplified in the future.
+	 */
+	struct omap_display_device *display_virtual = buffer->display;
+	struct omap_display_device *display_primary;
+	struct omap_display_device *display_secondary;
+	struct omap_display_buffer temp_buffer_top;
+	struct omap_display_buffer temp_buffer_bottom;
+	struct omap_display_sync_item sync_item_primary;
+	struct omap_display_sync_item sync_item_secondary;
+	DECLARE_COMPLETION_ONSTACK(completion_primary);
+	DECLARE_COMPLETION_ONSTACK(completion_secondary);
+	unsigned int buffer_offset;
+
+	if (display_virtual->id != OMAP_DISPID_VIRTUAL) {
+		ERR_PRINT("Not a virtual display");
+		BUG();
+	}
+
+	display_primary = omap_display_get(OMAP_DISPID_PRIMARY);
+	display_secondary = omap_display_get(OMAP_DISPID_SECONDARY);
+	/*
+	 * Calculate offset without page alignment round up otherwise second
+	 * display may see incorrect data
+	 */
+	buffer_offset = display_primary->height * display_virtual->byte_stride;
+
+	/* The first buffer will be the top */
+	temp_buffer_top.physical_addr = buffer->physical_addr;
+	temp_buffer_top.virtual_addr = buffer->virtual_addr;
+	temp_buffer_top.size = buffer->size >> 1;
+	/* Then the bottom */
+	temp_buffer_bottom.physical_addr = buffer->physical_addr +
+		buffer_offset;
+	temp_buffer_bottom.virtual_addr = buffer->virtual_addr + buffer_offset;
+	temp_buffer_bottom.size = buffer->size >> 1;
+
+	if (display_virtual->features & ORIENTATION_INVERT) {
+		/* Secondary display has the base */
+		temp_buffer_top.display = display_secondary;
+		temp_buffer_bottom.display = display_primary;
+		sync_item_primary.buffer = &temp_buffer_bottom;
+		sync_item_secondary.buffer = &temp_buffer_top;
+
+	} else {
+		/* Primary display has the base */
+		temp_buffer_top.display = display_primary;
+		temp_buffer_bottom.display = display_secondary;
+		sync_item_primary.buffer = &temp_buffer_top;
+		sync_item_secondary.buffer = &temp_buffer_bottom;
+	}
+
+	sync_item_primary.task = &completion_primary;
+	sync_item_secondary.task = &completion_secondary;
+	sync_item_primary.invalidate = 0;
+	sync_item_secondary.invalidate = 0;
+
+	/* Register an ISR per display with its corresponding IRQ */
+	omap_dispc_register_isr(display_irq_wait_1, &sync_item_primary,
+		get_dss_irq(display_primary->overlay_managers[0]->device));
+
+	omap_dispc_register_isr(display_irq_wait_2, &sync_item_secondary,
+		get_dss_irq(display_secondary->overlay_managers[0]->device));
+
+	/* Wait until each display sync and present */
+	wait_for_completion_interruptible_timeout(&completion_primary,
+			OMAP_DISP_IRQ_TIMEOUT);
+	wait_for_completion_interruptible_timeout(&completion_secondary,
+			OMAP_DISP_IRQ_TIMEOUT);
+
+	/* Unregister ISRs */
+	omap_dispc_unregister_isr(display_irq_wait_1, &sync_item_primary,
+		get_dss_irq(display_primary->overlay_managers[0]->device));
+
+	omap_dispc_unregister_isr(display_irq_wait_2, &sync_item_secondary,
+		get_dss_irq(display_secondary->overlay_managers[0]->device));
+
+	return 0;
+}
+
+static int display_sync(struct omap_display_device *display)
+{
+	/* TODO: Synchronize properly with multiple managers */
+	struct omap_overlay_manager *manager =
+		display->overlay_managers[0];
+	if (!manager) {
+		ERR_PRINT("Unable to synchronize with '%s'", display->name);
+		return 1;
+	}
+	manager->wait_for_vsync(manager);
+	return 0;
+}
+
+static int display_sync_virtual(struct omap_display_device *display_virtual)
+{
+	void display_irq_wait(void *data, u32 mask)
+	{
+		complete((struct completion *)data);
+	}
+
+	/*
+	 * Return as soon as one display generates an IRQ
+	 */
+	struct omap_display_device *display_primary;
+	struct omap_display_device *display_secondary;
+	u32 irq_primary;
+	u32 irq_secondary;
+	u32 irq_mask;
+	DECLARE_COMPLETION_ONSTACK(completion);
+
+	if (display_virtual->id != OMAP_DISPID_VIRTUAL) {
+		ERR_PRINT("Not a virtual display");
+		BUG();
+	}
+
+	display_primary = omap_display_get(OMAP_DISPID_PRIMARY);
+	display_secondary = omap_display_get(OMAP_DISPID_SECONDARY);
+
+	irq_primary = get_dss_irq(
+		display_primary->overlay_managers[0]->device);
+
+	irq_secondary = get_dss_irq(
+		display_secondary->overlay_managers[0]->device);
+
+	irq_mask = irq_primary | irq_secondary;
+
+	/* Register an ISR with both IRQs and wait, then unregister */
+	omap_dispc_register_isr(display_irq_wait, &completion, irq_mask);
+
+	wait_for_completion_interruptible_timeout(&completion,
+		OMAP_DISP_IRQ_TIMEOUT);
+
+	omap_dispc_unregister_isr(display_irq_wait, &completion, irq_mask);
+
+	return 0;
+}
+
+static struct omap_display_buffer *create_main_buffer(
+	struct omap_display_device *display)
+{
+	int fb_idx;
+	switch (display->id) {
+	case OMAP_DISPID_PRIMARY:
+		fb_idx = 0;
+		break;
+	case OMAP_DISPID_SECONDARY:
+		fb_idx = 1;
+		break;
+	case OMAP_DISPID_TERTIARY:
+		fb_idx = 2;
+		break;
+	case OMAP_DISPID_VIRTUAL:
+		/* Use fb0 for virtual display */
+		fb_idx = 0;
+		break;
+	case OMAP_DISPID_BADSTATE:
+	default:
+		ERR_PRINT("Unknown display id %i", display->id);
+		BUG();
+	}
+
+	/* Use the framebuffer memory */
+	if (fb_idx >= 0 && fb_idx < num_registered_fb) {
+		struct fb_info *framebuffer = registered_fb[fb_idx];
+		unsigned long buffer_size;
+		struct omap_display_buffer *buffer;
+
+		if (!framebuffer || !framebuffer->fix.smem_start ||
+			!framebuffer->screen_base) {
+			ERR_PRINT("Framebuffer %i doesn't seem to be "
+				"initialized", fb_idx);
+			return NULL;
+		}
+
+		/*
+		 * Check if there is enough memory in the fb for the
+		 * main buffer
+		 */
+		buffer_size = display->width * display->height *
+			display->bytes_per_pixel;
+		/* Page align the buffer size */
+		buffer_size = OMAP_DISP_PAGE_ROUND_UP(buffer_size);
+
+		if (buffer_size > framebuffer->fix.smem_len) {
+			ERR_PRINT("Main buffer needs %lu bytes while the "
+				"framebuffer %i has only %lu bytes for display"
+				" '%s'", buffer_size, fb_idx,
+				(unsigned long)framebuffer->fix.smem_len,
+				display->name);
+			return NULL;
+		}
+
+		buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
+
+		if (!buffer) {
+			ERR_PRINT("Out of memory");
+			return NULL;
+		}
+
+		/* Use base addresses reported by the framebuffer */
+		buffer->physical_addr = framebuffer->fix.smem_start;
+		buffer->virtual_addr =
+			(unsigned long) framebuffer->screen_base;
+		buffer->size = buffer_size;
+		buffer->display = display;
+
+		DBG_PRINT("Created main buffer %lx for display '%s'",
+			buffer->physical_addr, display->name);
+
+		return buffer;
+	} else {
+		ERR_PRINT("Framebuffer %i doesn't exist for display '%s'",
+			fb_idx, display->name);
+		return NULL;
+	}
+}
+
+static int populate_display_info(struct omap_display_device *display,
+	struct omap_overlay_manager *overlay_manager)
+{
+	struct omap_dss_device *dss_device = overlay_manager->device;
+	u16 xres;
+	u16 yres;
+	int i;
+
+	if (!strcmp(dss_device->name, "lcd")) {
+		display->id = OMAP_DISPID_PRIMARY;
+		display->name = "primary";
+	} else if (!strcmp(dss_device->name, "lcd2")) {
+		display->id = OMAP_DISPID_SECONDARY;
+		display->name = "secondary";
+	} else if (!strcmp(dss_device->name, "hdmi")) {
+		display->id = OMAP_DISPID_TERTIARY;
+		display->name = "tertiary";
+	} else {
+		ERR_PRINT("Display id '%s' not supported", dss_device->name);
+		return 1;
+	}
+
+	dss_device->driver->get_resolution(dss_device, &xres, &yres);
+	if (xres == 0 || yres == 0) {
+		ERR_PRINT("Unable to handle display '%s' with width %i "
+		"and height %i", dss_device->name, xres, yres);
+		return 1;
+	}
+
+	display->width = xres;
+	display->height = yres;
+
+	display->bits_per_pixel =
+		dss_device->driver->get_recommended_bpp(dss_device);
+	switch (display->bits_per_pixel) {
+	case 16:
+		/*
+		 * TODO: Asume RGB_565, maybe need to double check in
+		 * the DSS if this is true
+		 */
+		display->pixel_format = RGB_565;
+		display->bytes_per_pixel = 2;
+		break;
+	case 24: /* 24 bits are encapsulated with 32 bits */
+	case 32:
+		/*
+		 * TODO: Asume ARGB_8888, maybe need to double check in
+		 * the DSS if this is true
+		 */
+		display->pixel_format = ARGB_8888;
+		display->bytes_per_pixel = 4;
+		break;
+	default:
+		ERR_PRINT("Unable to handle %i bpp", display->bits_per_pixel);
+		return 1;
+	}
+
+	display->byte_stride = display->bytes_per_pixel * display->width;
+	display->rotation = OMAP_DSS_ROT_0; /* Asume rotation 0 degrees */
+	display->main_buffer = 0;
+	display->flip_chain = 0;
+
+	/* Add the manager to the list */
+	for (i = 0; i < OMAP_DISP_MAX_MANAGERS; i++)
+		display->overlay_managers[i] = 0;
+
+	display->overlay_managers[0] = overlay_manager;
+	display->overlay_managers_count = 1;
+
+	/* Assign function pointers for display operations */
+	display->open = open_display;
+	display->close = close_display;
+	display->create_flip_chain = create_flip_chain;
+	display->destroy_flip_chain = destroy_flip_chain;
+	display->rotate = rotate_display;
+	display->present_buffer = present_buffer;
+	display->sync = display_sync;
+	display->present_buffer_sync = present_buffer_sync;
+
+	display->main_buffer = create_main_buffer(display);
+	if (!display->main_buffer)
+		WRN_PRINT("Failed to create main buffer for '%s'",
+			display->name);
+
+	display->buffers_available = get_max_buffers(display);
+
+	/* Just print some display info */
+	DBG_PRINT("Found display '%s-%s' (%i,%i) %i bpp (%i bytes per pixel)"
+		" rotation %i", display->name, dss_device->name,
+		display->width, display->height, display->bits_per_pixel,
+		display->bytes_per_pixel, display->rotation);
+
+	return 0;
+}
+
+static int populate_virtual_display_info(struct omap_display_device *display)
+{
+	struct omap_display_device *display_primary ;
+	struct omap_display_device *display_secondary;
+	int i;
+
+	display->id = OMAP_DISPID_VIRTUAL;
+	display->name = "virtual";
+
+	display_primary = omap_display_get(OMAP_DISPID_PRIMARY);
+	display_secondary = omap_display_get(OMAP_DISPID_SECONDARY);
+
+	if (!display_primary) {
+		ERR_PRINT("Primary display doesn't exist");
+		return 1;
+	} else if (!display_secondary) {
+		ERR_PRINT("Secondary display doesn't exist");
+		return 1;
+	}
+
+	/* Combine primary and secondary display resolutions */
+	if (display_primary->width != display_secondary->width ||
+		display_primary->height != display_secondary->height) {
+		ERR_PRINT("Primary and seconday displays resolution are not"
+			" the same");
+		return 1;
+	}
+
+	/*
+	 * TODO: Here it is hardcoded the resolution asumming a vertical
+	 * virtual config, what about horizontal?
+	 */
+	display->width = display_primary->width;
+	display->height = display_primary->height * 2;
+
+	if (display_primary->bits_per_pixel !=
+		display_secondary->bits_per_pixel) {
+		ERR_PRINT("Primary and seconday displays format are"
+			" not the same");
+		return 1;
+	}
+
+	display->bits_per_pixel = display_primary->bits_per_pixel;
+	switch (display->bits_per_pixel) {
+	case 16:
+		/*
+		 * TODO: Asume RGB_565, maybe need to double check in
+		 * the DSS if this is true
+		 */
+		display->pixel_format = RGB_565;
+		display->bytes_per_pixel = 2;
+		break;
+	case 24: /* 24 bits are encapsulated with 32 bits */
+	case 32:
+		/*
+		 * TODO: Asume ARGB_8888, maybe need to double check in
+		 * the DSS if this is true
+		 */
+		display->pixel_format = ARGB_8888;
+		display->bytes_per_pixel = 4;
+		break;
+	default:
+		ERR_PRINT("Unable to handle %i bpp",
+			display->bits_per_pixel);
+		return 1;
+	}
+
+	/* TODO: Asumming a vertical virtual config too for stride */
+	display->byte_stride = display->bytes_per_pixel * display->width;
+	display->rotation = OMAP_DSS_ROT_0; /* Asume rotation 0 degrees */
+	display->main_buffer = 0;
+	display->flip_chain = 0;
+
+	/* Add the primary and secondary overlay managers */
+	for (i = 0; i < OMAP_DISP_MAX_MANAGERS; i++)
+		display->overlay_managers[i] = 0;
+
+	display->overlay_managers[0] = display_primary->overlay_managers[0];
+	display->overlay_managers[1] = display_secondary->overlay_managers[0];
+	display->overlay_managers_count = 2;
+
+	/* Assign function pointers for display operations */
+	display->open = open_display;
+	display->close = close_display;
+	display->create_flip_chain = create_flip_chain;
+	display->destroy_flip_chain = destroy_flip_chain;
+	display->rotate = rotate_display;
+	display->present_buffer = present_buffer_virtual;
+	display->sync = display_sync_virtual;
+	display->present_buffer_sync = present_buffer_sync_virtual;
+
+	display->main_buffer = create_main_buffer(display);
+	if (!display->main_buffer)
+		WRN_PRINT("Failed to create main buffer for '%s'",
+			display->name);
+
+	display->buffers_available = get_max_buffers(display);
+
+	/* Just print some display info */
+	DBG_PRINT("Found display '%s' (%i,%i) %i bpp (%i bytes per pixel)"
+		" rotation %i", display->name, display->width, display->height,
+		display->bits_per_pixel, display->bytes_per_pixel,
+		display->rotation);
+
+	return 0;
+}
+
+static int create_display_list(void)
+{
+	int i;
+	struct omap_display_device *display;
+
+	/* Query number of possible displays available first */
+	omap_display_number = omap_dss_get_num_overlay_managers();
+	/* For virtual display */
+	omap_display_number++;
+
+	/* Allocate custom display list */
+	omap_display_list = kzalloc(
+		sizeof(*display) * omap_display_number, GFP_KERNEL);
+
+	if (!omap_display_list) {
+		ERR_PRINT("Out of memory");
+		return 1;
+	}
+
+	/* Populate each display info */
+	for (i = 0; i < omap_display_number - 1; i++) {
+		struct omap_overlay_manager *overlay_manager =
+			omap_dss_get_overlay_manager(i);
+		display = &omap_display_list[i];
+		if (!overlay_manager->device) {
+			WRN_PRINT("Display '%s' doesn't have a dss device "
+				"attached to it, ignoring",
+				overlay_manager->name);
+			display->id = OMAP_DISPID_BADSTATE;
+			continue;
+		}
+		if (populate_display_info(display, overlay_manager)) {
+			ERR_PRINT("Error populating display %i info with "
+				"manager '%s'", i,
+				overlay_manager->device->name);
+			display->id = OMAP_DISPID_BADSTATE;
+			continue;
+		}
+	}
+
+	/* Populate virtual display */
+	display = &omap_display_list[omap_display_number - 1];
+	if (populate_virtual_display_info(display)) {
+		ERR_PRINT("Error populating virtual display info");
+		display->id = OMAP_DISPID_BADSTATE;
+	}
+
+	return 0;
+}
+
+struct omap_display_device *omap_display_get(enum omap_display_id id)
+{
+	int i;
+	struct omap_display_device *display;
+
+	if (id == OMAP_DISPID_BADSTATE) {
+		ERR_PRINT("Oops.. user must never request a bad display");
+		BUG();
+	}
+
+	for (i = 0; i < omap_display_number; i++) {
+		display = &omap_display_list[i];
+		if (display->id == id)
+			return display;
+	}
+
+	ERR_PRINT("Unknown display %i requested", id);
+	return 0;
+}
+EXPORT_SYMBOL(omap_display_get);
+
+int omap_display_count(void)
+{
+	return omap_display_number;
+}
+EXPORT_SYMBOL(omap_display_count);
+
+int omap_display_initialize(void)
+{
+	/*
+	 * TODO: Is there a better way to check if list is already created?
+	 */
+	if (!omap_display_list) {
+		DBG_PRINT("Initializing driver");
+		if (create_display_list()) {
+			ERR_PRINT("Error loading driver");
+			return 1;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(omap_display_initialize);
+
+int omap_display_deinitialize(void)
+{
+	int i;
+	int err = 0;
+	DBG_PRINT("Driver exiting");
+
+	for (i = 0; i < omap_display_number; i++) {
+		struct omap_display_device *display = &omap_display_list[i];
+
+		if (!display)
+			continue;
+
+		if (display->main_buffer) {
+			err = display_destroy_buffer(display->main_buffer);
+			display->main_buffer = 0;
+			if (err)
+				WRN_PRINT("An error happened when destroying "
+					"main buffer for '%s'", display->name);
+		}
+
+		err = display->close(display);
+
+		if (err)
+			ERR_PRINT("Unable to close display '%s'",
+				display->name);
+	}
+
+	kfree(omap_display_list);
+	omap_display_list = 0;
+
+	return err;
+}
+EXPORT_SYMBOL(omap_display_deinitialize);
+
diff --git a/drivers/gpu/pvr/display/omap_display.h b/drivers/gpu/pvr/display/omap_display.h
new file mode 100644
index 0000000..71b9dac
--- /dev/null
+++ b/drivers/gpu/pvr/display/omap_display.h
@@ -0,0 +1,109 @@
+/*
+ * drivers/gpu/pvr/display/omap_display.h
+ *
+ * Copyright (C) 2010 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <plat/vrfb.h>
+#include <plat/display.h>
+#include <linux/completion.h>
+
+#ifndef __OMAP_DISPLAY_H_
+#define __OMAP_DISPLAY_H_
+
+/* Max overlay managers for virtual display */
+#define OMAP_DISP_MAX_MANAGERS 2
+/* 3 for triple buffering, 4 for virtual display */
+#define OMAP_DISP_MAX_FLIPCHAIN_BUFFERS 4
+#define OMAP_DISP_NUM_DISPLAYS 4 /* lcd, 2lcd, tv, virtual */
+
+struct omap_display_device;
+
+/* On OMAP 4 we can only manage 3 displays at the same time + virtual */
+enum omap_display_id {
+	OMAP_DISPID_PRIMARY = 1 << 0,
+	OMAP_DISPID_SECONDARY = 1 << 1,
+	OMAP_DISPID_TERTIARY = 1 << 2,
+	OMAP_DISPID_VIRTUAL = 1 << 15, /* Multiple displays */
+	OMAP_DISPID_BADSTATE = 1 << 30, /* Used to say a display is unusable*/
+};
+
+enum omap_display_pixel_format {
+	RGB_565 = 0,
+	ARGB_8888  = 1,
+};
+
+/* Primary display location for virtual display */
+enum omap_display_feature {
+	ORIENTATION_VERTICAL = 1 << 0,
+	ORIENTATION_HORIZONTAL = 1 << 1,
+	ORIENTATION_INVERT = 1 << 2,
+};
+
+struct omap_display_buffer {
+	unsigned long physical_addr;
+	unsigned long virtual_addr;
+	unsigned long size;
+	struct omap_display_device *display;
+};
+
+struct omap_display_flip_chain {
+	int buffer_count;
+	struct omap_display_buffer *buffers[OMAP_DISP_MAX_FLIPCHAIN_BUFFERS];
+	struct omap_display_device *display;
+};
+
+struct omap_display_sync_item {
+	struct omap_display_buffer *buffer;
+	struct completion *task;
+	int invalidate;
+};
+
+struct omap_display_device {
+	char *name;
+	enum omap_display_id id;
+	enum omap_display_pixel_format pixel_format;
+	enum omap_display_feature features;
+	unsigned int width;
+	unsigned int height;
+	unsigned int bits_per_pixel;
+	unsigned int bytes_per_pixel;
+	unsigned int byte_stride;
+	enum omap_dss_rotation_angle rotation;
+	unsigned int reference_count;
+	unsigned int buffers_available;
+	struct omap_display_buffer *main_buffer;
+	struct omap_display_flip_chain *flip_chain;
+	struct omap_overlay_manager *overlay_managers[OMAP_DISP_MAX_MANAGERS];
+	unsigned int overlay_managers_count;
+	int (*open)(struct omap_display_device *display,
+		enum omap_display_feature features);
+	int (*close) (struct omap_display_device *display);
+	int (*create_flip_chain) (struct omap_display_device *display,
+		unsigned int buffer_count);
+	int (*destroy_flip_chain) (struct omap_display_device *display);
+	int (*rotate) (struct omap_display_device *display,
+		enum omap_dss_rotation_angle rotation);
+	int (*present_buffer) (struct omap_display_buffer *buffer);
+	int (*sync) (struct omap_display_device *display);
+	int (*present_buffer_sync) (struct omap_display_buffer *buffer);
+};
+
+int omap_display_initialize(void);
+int omap_display_deinitialize(void);
+int omap_display_count(void);
+struct omap_display_device *omap_display_get(enum omap_display_id id);
+
+#endif
diff --git a/drivers/gpu/pvr/display/omap_sgx_displayclass.c b/drivers/gpu/pvr/display/omap_sgx_displayclass.c
new file mode 100644
index 0000000..fce8f67
--- /dev/null
+++ b/drivers/gpu/pvr/display/omap_sgx_displayclass.c
@@ -0,0 +1,1641 @@
+/*************************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
+ *
+ *************************************************************************/
+
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/notifier.h>
+
+#if defined(LDM_PLATFORM)
+#include <linux/platform_device.h>
+#if defined(SGX_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+#endif
+
+#include "img_defs.h"
+#include "servicesext.h"
+#include "kerneldisplay.h"
+#include "omap_sgx_displayclass.h"
+#include "omap_display.h"
+
+/* XXX: Expect 2 framebuffers for virtual display */
+#if (CONFIG_FB_OMAP2_NUM_FBS < 2)
+#error "Virtual display is supported only with 2 or more framebuffers, \
+CONFIG_FB_OMAP2_NUM_FBS must be equal or greater than 2 \
+see CONFIG_FB_OMAP2_NUM_FBS for details in the kernel config"
+#endif
+
+#define OMAP_DC_CMD_COUNT		1
+#define MAX_BUFFERS_FLIPPING		4
+
+/* Pointer Display->Services */
+static PFN_DC_GET_PVRJTABLE pfnGetPVRJTable = NULL;
+
+/* Pointer to the display devices */
+static struct OMAP_DISP_DEVINFO *pDisplayDevices = NULL;
+static int display_devices_count = 0;
+
+static void display_sync_handler(struct work_struct *work);
+static enum OMAP_ERROR get_pvr_dc_jtable (char *szFunctionName,
+	PFN_DC_GET_PVRJTABLE *ppfnFuncTable);
+
+
+/*
+ * Swap to display buffer. This buffer refers to one inside the
+ * framebuffer memory.
+ * in: hDevice, hBuffer, ui32SwapInterval, hPrivateTag, ui32ClipRectCount,
+ * psClipRect
+ */
+static PVRSRV_ERROR SwapToDCBuffer(IMG_HANDLE hDevice,
+                                   IMG_HANDLE hBuffer,
+                                   IMG_UINT32 ui32SwapInterval,
+                                   IMG_HANDLE hPrivateTag,
+                                   IMG_UINT32 ui32ClipRectCount,
+                                   IMG_RECT *psClipRect)
+{
+	/* Nothing to do */
+	return PVRSRV_OK;
+}
+
+/*
+ * Set display destination rectangle.
+ * in: hDevice, hSwapChain, psRect
+ */
+static PVRSRV_ERROR SetDCDstRect(IMG_HANDLE hDevice,
+	IMG_HANDLE hSwapChain,
+	IMG_RECT *psRect)
+{
+	/* Nothing to do */
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+/*
+ * Set display source rectangle.
+ * in: hDevice, hSwapChain, psRect
+ */
+static PVRSRV_ERROR SetDCSrcRect(IMG_HANDLE hDevice,
+                                 IMG_HANDLE hSwapChain,
+                                 IMG_RECT *psRect)
+{
+	/* Nothing to do */
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+/*
+ * Set display destination colour key.
+ * in: hDevice, hSwapChain, ui32CKColour
+ */
+static PVRSRV_ERROR SetDCDstColourKey(IMG_HANDLE hDevice,
+                                      IMG_HANDLE hSwapChain,
+                                      IMG_UINT32 ui32CKColour)
+{
+	/* Nothing to do */
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+/*
+ * Set display source colour key.
+ * in: hDevice, hSwapChain, ui32CKColour
+ */
+static PVRSRV_ERROR SetDCSrcColourKey(IMG_HANDLE hDevice,
+                                      IMG_HANDLE hSwapChain,
+                                      IMG_UINT32 ui32CKColour)
+{
+	/* Nothing to do */
+	return PVRSRV_ERROR_NOT_SUPPORTED;
+}
+
+/*
+ * Closes the display.
+ * in: hDevice
+ */
+static PVRSRV_ERROR CloseDCDevice(IMG_HANDLE hDevice)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo =
+		(struct OMAP_DISP_DEVINFO*) hDevice;
+	struct omap_display_device *display = psDevInfo->display;
+
+	if(display->close(display))
+		WARNING_PRINTK("Unable to close properly display '%s'",
+			display->name);
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Flushes the sync queue present in the specified swap chain.
+ * in: psSwapChain
+ */
+static void FlushInternalSyncQueue(struct OMAP_DISP_SWAPCHAIN *psSwapChain)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo =
+		(struct OMAP_DISP_DEVINFO*) psSwapChain->pvDevInfo;
+	struct OMAP_DISP_FLIP_ITEM *psFlipItem;
+	struct omap_display_device *display = psDevInfo->display;
+	unsigned long            ulMaxIndex;
+	unsigned long            i;
+
+	psFlipItem = &psSwapChain->psFlipItems[psSwapChain->ulRemoveIndex];
+	ulMaxIndex = psSwapChain->ulBufferCount - 1;
+
+	DEBUG_PRINTK("Flushing sync queue on display %lu",
+		psDevInfo->ulDeviceID);
+	for(i = 0; i < psSwapChain->ulBufferCount; i++)
+	{
+		if (psFlipItem->bValid == OMAP_FALSE)
+			continue;
+
+		DEBUG_PRINTK("Flushing swap buffer index %lu",
+			psSwapChain->ulRemoveIndex);
+
+		/* Flip the buffer if it hasn't been flipped */
+		if(psFlipItem->bFlipped == OMAP_FALSE)
+		{
+			display->present_buffer(psFlipItem->display_buffer);
+		}
+
+		/* If the command didn't complete, assume it did */
+		if(psFlipItem->bCmdCompleted == OMAP_FALSE)
+		{
+			DEBUG_PRINTK("Calling command complete for swap "
+				"buffer index %lu",
+				psSwapChain->ulRemoveIndex);
+			psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(
+				(IMG_HANDLE)psFlipItem->hCmdComplete,
+				IMG_TRUE);
+		}
+
+		psSwapChain->ulRemoveIndex++;
+		if(psSwapChain->ulRemoveIndex > ulMaxIndex)
+			psSwapChain->ulRemoveIndex = 0;
+
+		/* Put the state of the buffer to be used again later */
+		psFlipItem->bFlipped = OMAP_FALSE;
+		psFlipItem->bCmdCompleted = OMAP_FALSE;
+		psFlipItem->bValid = OMAP_FALSE;
+		psFlipItem =
+			&psSwapChain->psFlipItems[psSwapChain->ulRemoveIndex];
+	}
+
+	psSwapChain->ulInsertIndex = 0;
+	psSwapChain->ulRemoveIndex = 0;
+}
+
+/*
+ * Sets the flush state of the specified display device
+ * at the swap chain level without blocking the call.
+ * in: psDevInfo, bFlushState
+ */
+static void SetFlushStateInternalNoLock(struct OMAP_DISP_DEVINFO* psDevInfo,
+                                        enum OMAP_BOOL bFlushState)
+{
+	struct OMAP_DISP_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
+
+	/* Nothing to do if there is no swap chain */
+	if (psSwapChain == NULL){
+		DEBUG_PRINTK("Swap chain is null, nothing to do for"
+			" display %lu", psDevInfo->ulDeviceID);
+		return;
+	}
+
+	if (bFlushState)
+	{
+		DEBUG_PRINTK("Desired flushState is true for display %lu",
+			psDevInfo->ulDeviceID);
+		if (psSwapChain->ulSetFlushStateRefCount == 0)
+		{
+			psSwapChain->bFlushCommands = OMAP_TRUE;
+			FlushInternalSyncQueue(psSwapChain);
+		}
+		psSwapChain->ulSetFlushStateRefCount++;
+	}
+	else
+	{
+		DEBUG_PRINTK("Desired flushState is false for display %lu",
+			psDevInfo->ulDeviceID);
+		if (psSwapChain->ulSetFlushStateRefCount != 0)
+		{
+			psSwapChain->ulSetFlushStateRefCount--;
+			if (psSwapChain->ulSetFlushStateRefCount == 0)
+			{
+				psSwapChain->bFlushCommands = OMAP_FALSE;
+			}
+		}
+	}
+}
+
+/*
+ * Sets the flush state of the specified display device
+ * at device level blocking the call if needed.
+ * in: psDevInfo, bFlushState
+ */
+static void SetFlushStateExternal(struct OMAP_DISP_DEVINFO* psDevInfo,
+                                  enum OMAP_BOOL bFlushState)
+{
+	DEBUG_PRINTK("Executing for display %lu",
+		psDevInfo->ulDeviceID);
+	mutex_lock(&psDevInfo->sSwapChainLockMutex);
+	if (psDevInfo->bFlushCommands != bFlushState)
+	{
+		psDevInfo->bFlushCommands = bFlushState;
+		SetFlushStateInternalNoLock(psDevInfo, bFlushState);
+	}
+	mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+}
+
+/*
+ * Opens the display.
+ * in: ui32DeviceID, phDevice
+ * out: psSystemBufferSyncData
+ */
+static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 ui32DeviceID,
+                                 IMG_HANDLE *phDevice,
+                                 PVRSRV_SYNC_DATA* psSystemBufferSyncData)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	struct omap_display_device *display;
+	int i;
+
+	psDevInfo = 0;
+	for(i = 0; i < display_devices_count; i++)
+	{
+		if(ui32DeviceID == (&pDisplayDevices[i])->ulDeviceID)
+		{
+			psDevInfo = &pDisplayDevices[i];
+			break;
+		}
+	}
+
+	if(!psDevInfo)
+	{
+		WARNING_PRINTK("Unable to identify display device with id %i",
+			(int)ui32DeviceID);
+		return OMAP_ERROR_INVALID_DEVICE;
+	}
+
+	psDevInfo->sSystemBuffer.psSyncData = psSystemBufferSyncData;
+	display = psDevInfo->display;
+
+	DEBUG_PRINTK("Opening display %lu '%s'",psDevInfo->ulDeviceID,
+		display->name);
+
+	/* TODO: Explain here why ORIENTATION_VERTICAL is used*/
+	if(display->open(display, ORIENTATION_VERTICAL | ORIENTATION_INVERT))
+		ERROR_PRINTK("Unable to open properly display '%s'",
+			psDevInfo->display->name);
+
+	display->present_buffer(display->main_buffer);
+
+	/* TODO: Turn on display here? */
+
+	*phDevice = (IMG_HANDLE)psDevInfo;
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Gets the available formats for the display.
+ * in: hDevice
+ * out: pui32NumFormats, psFormat
+ */
+static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
+                                  IMG_UINT32 *pui32NumFormats,
+                                  DISPLAY_FORMAT *psFormat)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	if(!hDevice || !pui32NumFormats)
+	{
+		ERROR_PRINTK("Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)hDevice;
+	*pui32NumFormats = 1;
+
+	if(psFormat)
+		psFormat[0] = psDevInfo->sDisplayFormat;
+	else
+		WARNING_PRINTK("Display format is null for"
+			" display %lu", psDevInfo->ulDeviceID);
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Gets the available dimensions for the display.
+ * in: hDevice, psFormat
+ * out: pui32NumDims, psDim
+ */
+static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice,
+                               DISPLAY_FORMAT *psFormat,
+                               IMG_UINT32 *pui32NumDims,
+                               DISPLAY_DIMS *psDim)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	if(!hDevice || !psFormat || !pui32NumDims)
+	{
+		ERROR_PRINTK("Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)hDevice;
+	*pui32NumDims = 1;
+
+	if(psDim)
+		psDim[0] = psDevInfo->sDisplayDim;
+	else
+		WARNING_PRINTK("Display dimensions are null for"
+			" display %lu", psDevInfo->ulDeviceID);
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Gets the display framebuffer physical address.
+ * in: hDevice
+ * out: phBuffer
+ */
+static PVRSRV_ERROR GetDCSystemBuffer(IMG_HANDLE hDevice, IMG_HANDLE *phBuffer)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+
+	if(!hDevice || !phBuffer)
+	{
+		ERROR_PRINTK("Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)hDevice;
+	*phBuffer = (IMG_HANDLE)&psDevInfo->sSystemBuffer;
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Gets the display general information.
+ * in: hDevice
+ * out: psDCInfo
+ */
+static PVRSRV_ERROR GetDCInfo(IMG_HANDLE hDevice, DISPLAY_INFO *psDCInfo)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+
+	if(!hDevice || !psDCInfo)
+	{
+		ERROR_PRINTK("Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)hDevice;
+	*psDCInfo = psDevInfo->sDisplayInfo;
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Gets the display framebuffer virtual address.
+ * in: hDevice
+ * out: ppsSysAddr, pui32ByteSize, ppvCpuVAddr, phOSMapInfo, pbIsContiguous
+ */
+static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
+                                    IMG_HANDLE        hBuffer,
+                                    IMG_SYS_PHYADDR   **ppsSysAddr,
+                                    IMG_UINT32        *pui32ByteSize,
+                                    IMG_VOID          **ppvCpuVAddr,
+                                    IMG_HANDLE        *phOSMapInfo,
+                                    IMG_BOOL          *pbIsContiguous,
+	                            IMG_UINT32        *pui32TilingStride)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	struct OMAP_DISP_BUFFER *psSystemBuffer;
+
+	if(!hDevice || !hBuffer || !ppsSysAddr || !pui32ByteSize )
+	{
+		ERROR_PRINTK("Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)hDevice;
+	psSystemBuffer = (struct OMAP_DISP_BUFFER *)hBuffer;
+	*ppsSysAddr = &psSystemBuffer->sSysAddr;
+	*pui32ByteSize = (IMG_UINT32)psDevInfo->sSystemBuffer.ulBufferSize;
+
+	if (ppvCpuVAddr)
+		*ppvCpuVAddr = psSystemBuffer->sCPUVAddr;
+
+	if (phOSMapInfo)
+		*phOSMapInfo = (IMG_HANDLE)0;
+
+	if (pbIsContiguous)
+		*pbIsContiguous = IMG_TRUE;
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Creates a swap chain. Called when a 3D application begins.
+ * in: hDevice, ui32Flags, ui32BufferCount, psDstSurfAttrib, psSrcSurfAttrib
+ * ui32OEMFlags
+ * out: phSwapChain, ppsSyncData, pui32SwapChainID
+ */
+static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
+                                      IMG_UINT32 ui32Flags,
+                                      DISPLAY_SURF_ATTRIBUTES *psDstSurfAttrib,
+                                      DISPLAY_SURF_ATTRIBUTES *psSrcSurfAttrib,
+                                      IMG_UINT32 ui32BufferCount,
+                                      PVRSRV_SYNC_DATA **ppsSyncData,
+                                      IMG_UINT32 ui32OEMFlags,
+                                      IMG_HANDLE *phSwapChain,
+                                      IMG_UINT32 *pui32SwapChainID)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	struct OMAP_DISP_SWAPCHAIN *psSwapChain;
+	struct OMAP_DISP_BUFFER *psBuffer;
+	struct OMAP_DISP_FLIP_ITEM *psFlipItems;
+	IMG_UINT32 i;
+	PVRSRV_ERROR eError;
+	IMG_UINT32 ui32BuffersToSkip;
+	struct omap_display_device *display;
+	int err;
+
+	if(!hDevice || !psDstSurfAttrib || !psSrcSurfAttrib ||
+		!ppsSyncData || !phSwapChain)
+	{
+		ERROR_PRINTK("Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)hDevice;
+
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChains == 0)
+	{
+		ERROR_PRINTK("Unable to operate with 0 MaxSwapChains for"
+			" display %lu", psDevInfo->ulDeviceID);
+		return PVRSRV_ERROR_NOT_SUPPORTED;
+	}
+
+	if(psDevInfo->psSwapChain != NULL)
+	{
+		ERROR_PRINTK("Swap chain already exists for"
+			" display %lu", psDevInfo->ulDeviceID);
+		return PVRSRV_ERROR_FLIP_CHAIN_EXISTS;
+	}
+
+	if(ui32BufferCount > psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers)
+	{
+		ERROR_PRINTK("Too many buffers. Trying to use %u buffers while"
+			" there is only %u available for display %lu",
+			(unsigned int)ui32BufferCount,
+			(unsigned int)psDevInfo->
+			sDisplayInfo.ui32MaxSwapChainBuffers,
+			psDevInfo->ulDeviceID);
+		return PVRSRV_ERROR_TOOMANYBUFFERS;
+	}
+
+	ui32BuffersToSkip = psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers -
+		ui32BufferCount;
+
+	if((psDstSurfAttrib->pixelformat !=
+		psDevInfo->sDisplayFormat.pixelformat) ||
+		(psDstSurfAttrib->sDims.ui32ByteStride !=
+		psDevInfo->sDisplayDim.ui32ByteStride) ||
+		(psDstSurfAttrib->sDims.ui32Width !=
+		psDevInfo->sDisplayDim.ui32Width) ||
+		(psDstSurfAttrib->sDims.ui32Height !=
+		psDevInfo->sDisplayDim.ui32Height))
+	{
+		ERROR_PRINTK("Destination surface attributes differ from the"
+			" current framebuffer for display %lu",
+			psDevInfo->ulDeviceID);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	if((psDstSurfAttrib->pixelformat !=
+		psSrcSurfAttrib->pixelformat) ||
+		(psDstSurfAttrib->sDims.ui32ByteStride !=
+		psSrcSurfAttrib->sDims.ui32ByteStride) ||
+		(psDstSurfAttrib->sDims.ui32Width !=
+		psSrcSurfAttrib->sDims.ui32Width) ||
+		(psDstSurfAttrib->sDims.ui32Height !=
+		psSrcSurfAttrib->sDims.ui32Height))
+	{
+		ERROR_PRINTK("Destination surface attributes differ from the"
+			" target destination surface for display %lu",
+			psDevInfo->ulDeviceID);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	/* Create the flip chain in display side */
+	display = psDevInfo->display;
+	/* TODO: What about TILER buffers? */
+	/*
+	 * Creating the flip chain with the maximum number of buffers
+	 * we will decide which ones will be used later
+	 */
+	err = display->create_flip_chain(
+		display, psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers);
+	if(err)
+	{
+		ERROR_PRINTK("Unable to create the flip chain for '%s' display"
+			" id %lu", display->name, psDevInfo->ulDeviceID);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	/* Allocate memory needed for the swap chain */
+	psSwapChain = (struct OMAP_DISP_SWAPCHAIN*) kmalloc(
+		sizeof(struct OMAP_DISP_SWAPCHAIN), GFP_KERNEL);
+	if(!psSwapChain)
+	{
+		ERROR_PRINTK("Out of memory to allocate swap chain for"
+			" display %lu", psDevInfo->ulDeviceID);
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
+	}
+
+	DEBUG_PRINTK("Creating swap chain for display %lu",
+		psDevInfo->ulDeviceID );
+
+	/* Allocate memory for the buffer abstraction structures */
+	psBuffer = (struct OMAP_DISP_BUFFER*) kmalloc(
+		sizeof(struct OMAP_DISP_BUFFER) * ui32BufferCount, GFP_KERNEL);
+	if(!psBuffer)
+	{
+		ERROR_PRINTK("Out of memory to allocate the buffer"
+			" abstraction structures for display %lu",
+			psDevInfo->ulDeviceID);
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto ErrorFreeSwapChain;
+	}
+
+	/* Allocate memory for the flip item abstraction structures */
+	psFlipItems = (struct OMAP_DISP_FLIP_ITEM *) kmalloc (
+		sizeof(struct OMAP_DISP_FLIP_ITEM) * ui32BufferCount,
+		GFP_KERNEL);
+	if (!psFlipItems)
+	{
+		ERROR_PRINTK("Out of memory to allocate the flip item"
+			" abstraction structures for display %lu",
+			psDevInfo->ulDeviceID);
+		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+		goto ErrorFreeBuffers;
+	}
+
+	/* Assign to the swap chain structure the initial data */
+	psSwapChain->ulBufferCount = (unsigned long)ui32BufferCount;
+	psSwapChain->psBuffer = psBuffer;
+	psSwapChain->psFlipItems = psFlipItems;
+	psSwapChain->ulInsertIndex = 0;
+	psSwapChain->ulRemoveIndex = 0;
+	psSwapChain->psPVRJTable = &psDevInfo->sPVRJTable;
+	psSwapChain->pvDevInfo = (void*)psDevInfo;
+
+	/*
+	 * Init the workqueue (single thread, freezable and real time)
+	 * and its own work for this display
+	 */
+	INIT_WORK(&psDevInfo->sync_display_work, display_sync_handler);
+	psDevInfo->sync_display_wq =
+		__create_workqueue("pvr_display_sync_wq", 1, 1, 1);
+
+	DEBUG_PRINTK("Swap chain will have %u buffers for display %lu",
+		(unsigned int)ui32BufferCount, psDevInfo->ulDeviceID);
+	/* Link the buffers available like a circular list */
+	for(i=0; i<ui32BufferCount-1; i++)
+	{
+		psBuffer[i].psNext = &psBuffer[i+1];
+	}
+	psBuffer[i].psNext = &psBuffer[0];
+
+	/* Initialize each buffer abstraction structure */
+	for(i=0; i<ui32BufferCount; i++)
+	{
+		/* Get the needed buffers from the display flip chain */
+		IMG_UINT32 ui32SwapBuffer = i + ui32BuffersToSkip;
+		struct omap_display_buffer * flip_buffer =
+			display->flip_chain->buffers[ui32SwapBuffer];
+		psBuffer[i].display_buffer = flip_buffer;
+		psBuffer[i].psSyncData = ppsSyncData[i];
+		psBuffer[i].sSysAddr.uiAddr = flip_buffer->physical_addr;
+		psBuffer[i].sCPUVAddr =
+			(IMG_CPU_VIRTADDR) flip_buffer->virtual_addr;
+		DEBUG_PRINTK("Display %lu buffer index %u has physical "
+			"address 0x%x",
+			psDevInfo->ulDeviceID,
+			(unsigned int)i,
+			(unsigned int)psBuffer[i].sSysAddr.uiAddr);
+	}
+
+	/* Initialize each flip item abstraction structure */
+	for(i=0; i<ui32BufferCount; i++)
+	{
+		psFlipItems[i].bValid = OMAP_FALSE;
+		psFlipItems[i].bFlipped = OMAP_FALSE;
+		psFlipItems[i].bCmdCompleted = OMAP_FALSE;
+		psFlipItems[i].display_buffer = 0;
+	}
+
+	mutex_lock(&psDevInfo->sSwapChainLockMutex);
+
+	psDevInfo->psSwapChain = psSwapChain;
+	psSwapChain->bFlushCommands = psDevInfo->bFlushCommands;
+	if (psSwapChain->bFlushCommands)
+		psSwapChain->ulSetFlushStateRefCount = 1;
+	else
+		psSwapChain->ulSetFlushStateRefCount = 0;
+
+	mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+
+	*phSwapChain = (IMG_HANDLE)psSwapChain;
+
+	return PVRSRV_OK;
+
+ErrorFreeBuffers:
+	kfree(psBuffer);
+ErrorFreeSwapChain:
+	kfree(psSwapChain);
+
+	return eError;
+}
+
+/*
+ * Destroy a swap chain. Called when a 3D application ends.
+ * in: hDevice, hSwapChain
+ */
+static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
+	IMG_HANDLE hSwapChain)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	struct OMAP_DISP_SWAPCHAIN *psSwapChain;
+	struct omap_display_device *display;
+	int err;
+
+	if(!hDevice || !hSwapChain)
+	{
+		ERROR_PRINTK("Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)hDevice;
+	psSwapChain = (struct OMAP_DISP_SWAPCHAIN*)hSwapChain;
+	display = psDevInfo->display;
+
+	if (psSwapChain != psDevInfo->psSwapChain)
+	{
+		ERROR_PRINTK("Swap chain handler differs from the one "
+			"present in the display device pointer");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	DEBUG_PRINTK("Destroying swap chain for display %lu",
+		psDevInfo->ulDeviceID);
+
+	mutex_lock(&psDevInfo->sSwapChainLockMutex);
+
+	FlushInternalSyncQueue(psSwapChain);
+	psDevInfo->psSwapChain = NULL;
+
+	/*
+	 * Present the buffer which is at the base of address of
+	 * the framebuffer
+	 */
+	display->present_buffer(display->main_buffer);
+
+	/* Destroy the flip chain in display side */
+	err = display->destroy_flip_chain(display);
+	if(err)
+	{
+		ERROR_PRINTK("Unable to destroy the flip chain for '%s' "
+			"display id %lu", display->name,
+			psDevInfo->ulDeviceID);
+	}
+
+	mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+
+	/* Destroy the workqueue */
+	flush_workqueue(psDevInfo->sync_display_wq);
+	destroy_workqueue(psDevInfo->sync_display_wq);
+
+	kfree(psSwapChain->psFlipItems);
+	kfree(psSwapChain->psBuffer);
+	kfree(psSwapChain);
+
+	return PVRSRV_OK;
+}
+
+
+/*
+ * Get display buffers. These are the buffers that can be allocated
+ * inside the framebuffer memory.
+ * in: hDevice, hSwapChain
+ * out: pui32BufferCount, phBuffer
+ */
+static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
+                                 IMG_HANDLE hSwapChain,
+                                 IMG_UINT32 *pui32BufferCount,
+                                 IMG_HANDLE *phBuffer)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	struct OMAP_DISP_SWAPCHAIN *psSwapChain;
+	unsigned long      i;
+
+	if(!hDevice || !hSwapChain || !pui32BufferCount || !phBuffer)
+	{
+		ERROR_PRINTK("Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)hDevice;
+	psSwapChain = (struct OMAP_DISP_SWAPCHAIN*)hSwapChain;
+	if (psSwapChain != psDevInfo->psSwapChain)
+	{
+		ERROR_PRINTK("Swap chain handler differs from the one "
+			"present in the display device %lu pointer",
+			psDevInfo->ulDeviceID);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+	*pui32BufferCount = (IMG_UINT32)psSwapChain->ulBufferCount;
+
+	for(i=0; i<psSwapChain->ulBufferCount; i++)
+		phBuffer[i] = (IMG_HANDLE)&psSwapChain->psBuffer[i];
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Sets the display state.
+ * in: ui32State, hDevice
+ */
+static IMG_VOID SetDCState(IMG_HANDLE hDevice, IMG_UINT32 ui32State)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo =
+		(struct OMAP_DISP_DEVINFO*) hDevice;
+
+	switch (ui32State)
+	{
+		case DC_STATE_FLUSH_COMMANDS:
+			DEBUG_PRINTK("Setting state to flush commands for"
+				" display %lu", psDevInfo->ulDeviceID);
+			SetFlushStateExternal(psDevInfo, OMAP_TRUE);
+			break;
+		case DC_STATE_NO_FLUSH_COMMANDS:
+			DEBUG_PRINTK("Setting state to not flush commands for"
+				" display %lu", psDevInfo->ulDeviceID);
+			SetFlushStateExternal(psDevInfo, OMAP_FALSE);
+			break;
+		default:
+			WARNING_PRINTK("Unknown command state %u for display"
+				" %lu", (unsigned int)ui32State,
+				psDevInfo->ulDeviceID);
+			break;
+	}
+}
+
+/*
+ * Swap to display system buffer. This buffer refers to the one which
+ * is that fits in the framebuffer memory.
+ * in: hDevice, hSwapChain
+ */
+static PVRSRV_ERROR SwapToDCSystem(IMG_HANDLE hDevice,
+                                   IMG_HANDLE hSwapChain)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	struct OMAP_DISP_SWAPCHAIN *psSwapChain;
+	struct omap_display_device *display;
+
+	if(!hDevice || !hSwapChain)
+	{
+		ERROR_PRINTK("Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)hDevice;
+	psSwapChain = (struct OMAP_DISP_SWAPCHAIN*)hSwapChain;
+	display = psDevInfo->display;
+
+	DEBUG_PRINTK("Executing for display %lu",
+		psDevInfo->ulDeviceID);
+
+	if (psSwapChain != psDevInfo->psSwapChain)
+	{
+		ERROR_PRINTK("Swap chain handler differs from the one "
+			"present in the display device %lu pointer",
+			psDevInfo->ulDeviceID);
+		return PVRSRV_ERROR_INVALID_PARAMS;
+	}
+
+	mutex_lock(&psDevInfo->sSwapChainLockMutex);
+
+	FlushInternalSyncQueue(psSwapChain);
+	display->present_buffer(display->main_buffer);
+
+	mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+
+	return PVRSRV_OK;
+}
+
+/*
+ * Handles the synchronization with the display
+ * in: work
+ */
+
+static void display_sync_handler(struct work_struct *work)
+{
+	/*
+	 * TODO: Since present_buffer_sync waits and then present, this
+	 * algorithm can be simplified further
+	 */
+	struct OMAP_DISP_DEVINFO *psDevInfo = container_of(work,
+		struct OMAP_DISP_DEVINFO, sync_display_work);
+	struct omap_display_device *display = psDevInfo->display;
+	struct OMAP_DISP_FLIP_ITEM *psFlipItem;
+	struct OMAP_DISP_SWAPCHAIN *psSwapChain;
+	unsigned long ulMaxIndex;
+
+	mutex_lock(&psDevInfo->sSwapChainLockMutex);
+
+	psSwapChain = psDevInfo->psSwapChain;
+	if (!psSwapChain || psSwapChain->bFlushCommands)
+		goto ExitUnlock;
+
+	psFlipItem = &psSwapChain->psFlipItems[psSwapChain->ulRemoveIndex];
+	ulMaxIndex = psSwapChain->ulBufferCount - 1;
+
+	/* Iterate through the flip items and flip them if necessary */
+	while(psFlipItem->bValid)
+	{
+		if(psFlipItem->bFlipped)
+		{
+			if(!psFlipItem->bCmdCompleted)
+			{
+				psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(
+					(IMG_HANDLE)psFlipItem->hCmdComplete,
+					IMG_TRUE);
+				psFlipItem->bCmdCompleted = OMAP_TRUE;
+			}
+
+			if(psFlipItem->ulSwapInterval == 0)
+			{
+				psSwapChain->ulRemoveIndex++;
+				if(psSwapChain->ulRemoveIndex > ulMaxIndex)
+					psSwapChain->ulRemoveIndex = 0;
+				psFlipItem->bCmdCompleted = OMAP_FALSE;
+				psFlipItem->bFlipped = OMAP_FALSE;
+				psFlipItem->bValid = OMAP_FALSE;
+			}
+			else
+			{
+				/*
+				 * Here the swap interval is not zero yet
+				 * we need to schedule another work until
+				 * it reaches zero
+				 */
+				display->sync(display);
+				psFlipItem->ulSwapInterval--;
+				queue_work(psDevInfo->sync_display_wq,
+					&psDevInfo->sync_display_work);
+				goto ExitUnlock;
+			}
+		}
+		else
+		{
+			display->present_buffer_sync(
+				psFlipItem->display_buffer);
+			/*
+			 * present_buffer_sync waits and then present, then
+			 * swap interval decreases here too.
+			 */
+			psFlipItem->ulSwapInterval--;
+			psFlipItem->bFlipped = OMAP_TRUE;
+			/*
+			 * If the flip has been presented here then we need
+			 * in the next sync execute the command complete,
+			 * schedule another work
+			 */
+			queue_work(psDevInfo->sync_display_wq,
+				&psDevInfo->sync_display_work);
+			goto ExitUnlock;
+		}
+		psFlipItem =
+			&psSwapChain->psFlipItems[psSwapChain->ulRemoveIndex];
+	}
+
+ExitUnlock:
+	mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+}
+
+/*
+ * Performs a flip. This function takes the necessary steps to present
+ * the buffer to be flipped in the display.
+ * in: hCmdCookie, ui32DataSize, pvData
+ */
+static IMG_BOOL ProcessFlip(IMG_HANDLE  hCmdCookie,
+                            IMG_UINT32  ui32DataSize,
+                            IMG_VOID   *pvData)
+{
+	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	struct OMAP_DISP_BUFFER *psBuffer;
+	struct OMAP_DISP_SWAPCHAIN *psSwapChain;
+	struct omap_display_device *display;
+#if defined(SYS_USING_INTERRUPTS)
+	struct OMAP_DISP_FLIP_ITEM* psFlipItem;
+#endif
+
+	if(!hCmdCookie || !pvData)
+	{
+		WARNING_PRINTK("Ignoring call with NULL parameters");
+		return IMG_FALSE;
+	}
+
+	psFlipCmd = (DISPLAYCLASS_FLIP_COMMAND*)pvData;
+
+	if (psFlipCmd == IMG_NULL ||
+		sizeof(DISPLAYCLASS_FLIP_COMMAND) != ui32DataSize)
+	{
+		WARNING_PRINTK("NULL command or command data size is wrong");
+		return IMG_FALSE;
+	}
+
+	psDevInfo = (struct OMAP_DISP_DEVINFO*)psFlipCmd->hExtDevice;
+	psBuffer = (struct OMAP_DISP_BUFFER*)psFlipCmd->hExtBuffer;
+	psSwapChain = (struct OMAP_DISP_SWAPCHAIN*) psFlipCmd->hExtSwapChain;
+	display = psDevInfo->display;
+
+	mutex_lock(&psDevInfo->sSwapChainLockMutex);
+
+	if (psDevInfo->bDeviceSuspended)
+	{
+		/* If is suspended then assume the commands are completed */
+		psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(
+			hCmdCookie, IMG_TRUE);
+		goto ExitTrueUnlock;
+	}
+
+#if defined(SYS_USING_INTERRUPTS)
+
+	if( psFlipCmd->ui32SwapInterval == 0 ||
+		psSwapChain->bFlushCommands == OMAP_TRUE)
+	{
+#endif
+		display->present_buffer(psBuffer->display_buffer);
+		psSwapChain->psPVRJTable->pfnPVRSRVCmdComplete(
+			hCmdCookie, IMG_TRUE);
+
+#if defined(SYS_USING_INTERRUPTS)
+		goto ExitTrueUnlock;
+	}
+
+	psFlipItem = &psSwapChain->psFlipItems[psSwapChain->ulInsertIndex];
+
+	if(psFlipItem->bValid == OMAP_FALSE)
+	{
+		unsigned long ulMaxIndex = psSwapChain->ulBufferCount - 1;
+
+		psFlipItem->bFlipped = OMAP_FALSE;
+
+		/*
+		 * The buffer is queued here, must be consumed by the workqueue
+		 */
+		psFlipItem->hCmdComplete = (OMAP_HANDLE)hCmdCookie;
+		psFlipItem->ulSwapInterval =
+			(unsigned long)psFlipCmd->ui32SwapInterval;
+		psFlipItem->sSysAddr = &psBuffer->sSysAddr;
+		psFlipItem->bValid = OMAP_TRUE;
+		psFlipItem->display_buffer = psBuffer->display_buffer;
+
+		psSwapChain->ulInsertIndex++;
+		if(psSwapChain->ulInsertIndex > ulMaxIndex)
+			psSwapChain->ulInsertIndex = 0;
+
+		/* Give work to the workqueue to sync with the display */
+		queue_work(psDevInfo->sync_display_wq,
+			&psDevInfo->sync_display_work);
+
+		goto ExitTrueUnlock;
+	}
+
+	mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+	return IMG_FALSE;
+#endif
+
+ExitTrueUnlock:
+	mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+	return IMG_TRUE;
+}
+
+#if defined(LDM_PLATFORM)
+
+/*
+ *  Function called when the driver must suspend
+ */
+static void DriverSuspend(void)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	int i;
+
+	if(!pDisplayDevices)
+		return;
+
+	for(i = 0; i < display_devices_count; i++)
+	{
+		psDevInfo = &pDisplayDevices[i];
+
+		mutex_lock(&psDevInfo->sSwapChainLockMutex);
+
+		if (psDevInfo->bDeviceSuspended)
+		{
+			mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+			continue;
+		}
+
+		psDevInfo->bDeviceSuspended = OMAP_TRUE;
+		SetFlushStateInternalNoLock(psDevInfo, OMAP_TRUE);
+
+		mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+	}
+}
+
+/*
+ *  Function called when the driver must resume
+ */
+static void DriverResume(void)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	int i;
+
+	if(!pDisplayDevices)
+		return;
+
+	for(i = 0; i < display_devices_count; i++)
+	{
+		psDevInfo = &pDisplayDevices[i];
+
+		mutex_lock(&psDevInfo->sSwapChainLockMutex);
+
+		if (!psDevInfo->bDeviceSuspended)
+		{
+			mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+			continue;
+		}
+
+		SetFlushStateInternalNoLock(psDevInfo, OMAP_FALSE);
+		psDevInfo->bDeviceSuspended = OMAP_FALSE;
+
+		mutex_unlock(&psDevInfo->sSwapChainLockMutex);
+	}
+}
+#endif /* defined(LDM_PLATFORM) */
+
+/*
+ * Frees the kernel framebuffer
+ * in: psDevInfo
+ */
+static void deinit_display_device(struct OMAP_DISP_DEVINFO *psDevInfo)
+{
+	/* TODO: Are we sure there is nothing to do here? */
+}
+
+/*
+ *  Deinitialization routine for the 3rd party display driver
+ */
+static enum OMAP_ERROR destroy_display_devices(void)
+{
+	struct OMAP_DISP_DEVINFO *psDevInfo;
+	PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable;
+	int i;
+
+	DEBUG_PRINTK("Deinitializing 3rd party display driver");
+
+	if(!pDisplayDevices)
+		return OMAP_OK;
+
+	for(i = 0; i < display_devices_count; i++)
+	{
+		psDevInfo = &pDisplayDevices[i];
+		if(!psDevInfo->display)
+			continue;
+
+		/* Remove the ProcessFlip command callback */
+		psJTable = &psDevInfo->sPVRJTable;
+
+		if(!psJTable)
+			continue;
+
+		if (psDevInfo->sPVRJTable.pfnPVRSRVRemoveCmdProcList(
+			psDevInfo->ulDeviceID,
+			OMAP_DC_CMD_COUNT) != PVRSRV_OK)
+		{
+			ERROR_PRINTK("Unable to remove callback for "
+				"ProcessFlip command for display %lu",
+				psDevInfo->ulDeviceID);
+			return OMAP_ERROR_GENERIC;
+		}
+
+		/* Remove the display device from services */
+		if (psJTable->pfnPVRSRVRemoveDCDevice(
+			psDevInfo->ulDeviceID) != PVRSRV_OK)
+		{
+			ERROR_PRINTK("Unable to remove the display %lu "
+				"from services", psDevInfo->ulDeviceID);
+			return OMAP_ERROR_GENERIC;
+		}
+
+		deinit_display_device(psDevInfo);
+	}
+
+	kfree(pDisplayDevices);
+
+	return OMAP_OK;
+}
+
+/*
+ * Extracts the framebuffer data from the kernel driver
+ * in: psDevInfo
+ */
+static enum OMAP_ERROR init_display_device(struct OMAP_DISP_DEVINFO *psDevInfo,
+	struct omap_display_device *display)
+{
+	int buffers_available = display->buffers_available;
+
+	/* Extract the needed data from the display struct */
+	DEBUG_PRINTK("Display '%s' id %i information:", display->name,
+		display->id);
+	DEBUG_PRINTK("*Width, height: %u,%u", display->width,
+		display->height);
+	DEBUG_PRINTK("*Rotation: %u", display->rotation);
+	DEBUG_PRINTK("*Stride: %u bytes", display->byte_stride);
+	DEBUG_PRINTK("*Buffers available: %u", buffers_available);
+	DEBUG_PRINTK("*Bytes per pixel: %u (%u bpp)",
+		display->bytes_per_pixel, display->bits_per_pixel);
+
+	if(display->bits_per_pixel == 16)
+	{
+		if(display->pixel_format == RGB_565)
+		{
+			DEBUG_PRINTK("*Format: RGB565");
+			psDevInfo->sDisplayFormat.pixelformat =
+				PVRSRV_PIXEL_FORMAT_RGB565;
+		}
+		else
+			WARNING_PRINTK("*Format: Unknown framebuffer"
+				"format");
+	}
+	else if(display->bits_per_pixel == 24 ||
+		display->bits_per_pixel == 32)
+	{
+		if(display->pixel_format == ARGB_8888)
+		{
+			DEBUG_PRINTK("*Format: ARGB8888");
+			psDevInfo->sDisplayFormat.pixelformat =
+				PVRSRV_PIXEL_FORMAT_ARGB8888;
+
+		}
+		else
+			WARNING_PRINTK("*Format: Unknown framebuffer"
+				"format");
+	}
+	else
+		WARNING_PRINTK("*Format: Unknown framebuffer format");
+
+	if(display->main_buffer)
+	{
+		DEBUG_PRINTK("*Bytes per buffer: %lu",
+			display->main_buffer->size);
+		DEBUG_PRINTK("*Main buffer physical address: 0x%lx",
+			display->main_buffer->physical_addr);
+		DEBUG_PRINTK("*Main buffer virtual address: 0x%lx",
+			display->main_buffer->virtual_addr);
+		DEBUG_PRINTK("*Main buffer size: %lu bytes",
+			display->main_buffer->size);
+	}
+	else
+	{
+		psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = 0;
+		ERROR_PRINTK("*No main buffer found for display '%s'",
+			display->name);
+		return OMAP_ERROR_INIT_FAILURE;
+	}
+
+	psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = buffers_available;
+	mutex_init(&psDevInfo->sSwapChainLockMutex);
+	psDevInfo->psSwapChain = 0;
+	psDevInfo->bFlushCommands = OMAP_FALSE;
+	psDevInfo->bDeviceSuspended = OMAP_FALSE;
+
+	if(psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers > 1)
+	{
+		if(MAX_BUFFERS_FLIPPING == 1)
+		{
+			DEBUG_PRINTK("Flipping support is possible"
+				" but you decided not to use it");
+		}
+
+		DEBUG_PRINTK("*Flipping support");
+		if(psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers >
+			MAX_BUFFERS_FLIPPING)
+		psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers =
+			MAX_BUFFERS_FLIPPING;
+	}
+	else
+	{
+		DEBUG_PRINTK("*Flipping not supported");
+	}
+
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers == 0)
+	{
+		psDevInfo->sDisplayInfo.ui32MaxSwapChains = 0;
+		psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 0;
+	}
+	else
+	{
+		psDevInfo->sDisplayInfo.ui32MaxSwapChains = 1;
+		psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 3;
+	}
+	psDevInfo->sDisplayInfo.ui32MinSwapInterval = 0;
+
+	/* Get the display and framebuffer needed info */
+	strncpy(psDevInfo->sDisplayInfo.szDisplayName,
+		DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
+
+	psDevInfo->sDisplayDim.ui32Width = display->width;
+	psDevInfo->sDisplayDim.ui32Height = display->height;
+	psDevInfo->sDisplayDim.ui32ByteStride = display->byte_stride;
+	psDevInfo->sSystemBuffer.sSysAddr.uiAddr =
+		display->main_buffer->physical_addr;
+	psDevInfo->sSystemBuffer.sCPUVAddr =
+		(IMG_CPU_VIRTADDR) display->main_buffer->virtual_addr;
+	psDevInfo->sSystemBuffer.ulBufferSize = display->main_buffer->size;
+	psDevInfo->display = display;
+
+	return OMAP_OK;
+}
+
+/*
+ *  Initialization routine for the 3rd party display driver
+ */
+static enum OMAP_ERROR create_display_devices(void)
+{
+	PFN_CMD_PROC pfnCmdProcList[OMAP_DC_CMD_COUNT];
+	IMG_UINT32 aui32SyncCountList[OMAP_DC_CMD_COUNT][2];
+	int i;
+	unsigned int bytes_to_alloc;
+
+	DEBUG_PRINTK("Initializing 3rd party display driver");
+
+	/* Init display abstraction layer */
+	omap_display_initialize();
+
+	/* Ask for the number of displays available */
+	/* TODO: allow more displays */
+	display_devices_count = 1; // omap_display_count();
+
+	DEBUG_PRINTK("Found %i displays", display_devices_count);
+
+	/*
+	 * Obtain the function pointer for the jump table from kernel
+	 * services to fill it with the function pointers that we want
+	 */
+	if(get_pvr_dc_jtable ("PVRGetDisplayClassJTable",
+		&pfnGetPVRJTable) != OMAP_OK)
+	{
+		ERROR_PRINTK("Unable to get the function to get the"
+			" jump table display->services");
+		return OMAP_ERROR_INIT_FAILURE;
+	}
+
+	/*
+	 * Allocate the display device structures, one per display available
+	 */
+	bytes_to_alloc =
+		sizeof(struct OMAP_DISP_DEVINFO) * display_devices_count;
+	pDisplayDevices = (struct OMAP_DISP_DEVINFO *) kmalloc(
+		bytes_to_alloc, GFP_KERNEL);
+	if(!pDisplayDevices)
+	{
+		pDisplayDevices = NULL;
+		ERROR_PRINTK("Out of memory");
+		return OMAP_ERROR_OUT_OF_MEMORY;
+	}
+	memset(pDisplayDevices, 0, bytes_to_alloc);
+
+	/*
+	 * Initialize each display device
+	 */
+	for(i = 0; i < display_devices_count; i++)
+	{
+		struct omap_display_device *display;
+		struct OMAP_DISP_DEVINFO * psDevInfo;
+		enum omap_display_id id;
+
+		psDevInfo = &pDisplayDevices[i];
+		psDevInfo->display = 0;
+
+		id = OMAP_DISPID_VIRTUAL;
+
+		/*
+		 * TODO: Modify this to allow primary, secondary,
+		 * not only virtual
+		 */
+#if 0
+		switch(i)
+		{
+			case 0:
+				id = OMAP_DISPID_PRIMARY;
+				break;
+			case 1:
+				id = OMAP_DISPID_SECONDARY;
+				break;
+			case 2:
+				id = OMAP_DISPID_TERTIARY;
+				break;
+			case 3:
+				id = OMAP_DISPID_VIRTUAL;
+				break;
+			default:
+				ERROR_PRINTK("Invalid display type %i", i);
+				BUG();
+		}
+
+#endif
+
+		display = omap_display_get(id);
+		if(!display)
+			continue;
+
+		if(init_display_device(psDevInfo, display) != OMAP_OK)
+		{
+			ERROR_PRINTK("Unable to initialize display '%s' type"
+				" %u", display->name, display->id);
+			continue;
+#if 0
+			kfree(pDisplayDevices);
+			pDisplayDevices = NULL;
+			return OMAP_ERROR_INIT_FAILURE;
+#endif
+		}
+
+		/*
+		 * Populate each display device structure
+		*/
+		if(!(*pfnGetPVRJTable)(&psDevInfo->sPVRJTable))
+		{
+			ERROR_PRINTK("Unable to get the jump table"
+				" display->services for display '%s'",
+				display->name);
+			return OMAP_ERROR_INIT_FAILURE;
+		}
+
+		/* Populate the function table that services will use */
+		psDevInfo->sDCJTable.ui32TableSize =
+			sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
+		psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
+		psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
+		psDevInfo->sDCJTable.pfnEnumDCFormats = EnumDCFormats;
+		psDevInfo->sDCJTable.pfnEnumDCDims = EnumDCDims;
+		psDevInfo->sDCJTable.pfnGetDCSystemBuffer = GetDCSystemBuffer;
+		psDevInfo->sDCJTable.pfnGetDCInfo = GetDCInfo;
+		psDevInfo->sDCJTable.pfnGetBufferAddr = GetDCBufferAddr;
+		psDevInfo->sDCJTable.pfnCreateDCSwapChain = CreateDCSwapChain;
+		psDevInfo->sDCJTable.pfnDestroyDCSwapChain =
+			DestroyDCSwapChain;
+		psDevInfo->sDCJTable.pfnSetDCDstRect = SetDCDstRect;
+		psDevInfo->sDCJTable.pfnSetDCSrcRect = SetDCSrcRect;
+		psDevInfo->sDCJTable.pfnSetDCDstColourKey = SetDCDstColourKey;
+		psDevInfo->sDCJTable.pfnSetDCSrcColourKey = SetDCSrcColourKey;
+		psDevInfo->sDCJTable.pfnGetDCBuffers = GetDCBuffers;
+		psDevInfo->sDCJTable.pfnSwapToDCBuffer = SwapToDCBuffer;
+		psDevInfo->sDCJTable.pfnSwapToDCSystem = SwapToDCSystem;
+		psDevInfo->sDCJTable.pfnSetDCState = SetDCState;
+
+		/* Register the display device */
+		if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterDCDevice(
+			&psDevInfo->sDCJTable,
+			(IMG_UINT32*) &psDevInfo->ulDeviceID) != PVRSRV_OK)
+		{
+			ERROR_PRINTK("Unable to register the jump table"
+				" services->display");
+			return OMAP_ERROR_DEVICE_REGISTER_FAILED;
+		}
+
+		DEBUG_PRINTK("Display '%s' registered with the GPU with"
+			" id %lu", display->name, psDevInfo->ulDeviceID);
+
+		/*
+		 * Register the ProcessFlip function to notify when a frame is
+		 * ready to be flipped
+		 */
+		pfnCmdProcList[DC_FLIP_COMMAND] = ProcessFlip;
+		aui32SyncCountList[DC_FLIP_COMMAND][0] = 0;
+		aui32SyncCountList[DC_FLIP_COMMAND][1] = 2;
+		if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList(
+			psDevInfo->ulDeviceID, &pfnCmdProcList[0],
+			aui32SyncCountList, OMAP_DC_CMD_COUNT) != PVRSRV_OK)
+		{
+			ERROR_PRINTK("Unable to register callback for "
+				"ProcessFlip command");
+			return OMAP_ERROR_CANT_REGISTER_CALLBACK;
+		}
+
+	}
+	return OMAP_OK;
+}
+
+/*
+ * Here we get the function pointer to get jump table from
+ * services using an external function.
+ * in: szFunctionName
+ * out: ppfnFuncTable
+ */
+static enum OMAP_ERROR get_pvr_dc_jtable (char *szFunctionName,
+	PFN_DC_GET_PVRJTABLE *ppfnFuncTable)
+{
+	if(strcmp("PVRGetDisplayClassJTable", szFunctionName) != 0)
+	{
+		ERROR_PRINTK("Unable to get function pointer for %s"
+			" from services", szFunctionName);
+		return OMAP_ERROR_INVALID_PARAMS;
+	}
+	*ppfnFuncTable = PVRGetDisplayClassJTable;
+
+	return OMAP_OK;
+}
+
+#if defined(LDM_PLATFORM)
+
+static volatile enum OMAP_BOOL bDeviceSuspended;
+
+/*
+ * Common suspend driver function
+ * in: psSwapChain, aPhyAddr
+ */
+static void CommonSuspend(void)
+{
+	if (bDeviceSuspended)
+	{
+		DEBUG_PRINTK("Driver is already suspended");
+		return;
+	}
+
+	DriverSuspend();
+	bDeviceSuspended = OMAP_TRUE;
+}
+
+#if defined(SGX_EARLYSUSPEND)
+
+static struct early_suspend driver_early_suspend;
+
+/*
+ * Android specific, driver is requested to be suspended
+ * in: ea_event
+ */
+static void DriverSuspend_Entry(struct early_suspend *ea_event)
+{
+	DEBUG_PRINTK("Requested driver suspend");
+	CommonSuspend();
+}
+
+/*
+ * Android specific, driver is requested to be suspended
+ * in: ea_event
+ */
+static void DriverResume_Entry(struct early_suspend *ea_event)
+{
+	DEBUG_PRINTK("Requested driver resume");
+	DriverResume();
+	bDeviceSuspended = OMAP_FALSE;
+}
+
+static struct platform_driver omap_sgx_dc_driver = {
+	.driver = {
+		.name = DRVNAME,
+	}
+};
+
+#else /* defined(SGX_EARLYSUSPEND) */
+
+/*
+ * Function called when the driver is requested to be suspended
+ * in: pDevice, state
+ */
+static int DriverSuspend_Entry(struct platform_device unref__ *pDevice,
+	pm_message_t unref__ state)
+{
+	DEBUG_PRINTK("Requested driver suspend");
+	CommonSuspend();
+	return 0;
+}
+
+/*
+ * Function called when the driver is requested to resume
+ * in: pDevice
+ */
+static int DriverResume_Entry(struct platform_device unref__ *pDevice)
+{
+	DEBUG_PRINTK("Requested driver resume");
+	DriverResume();
+	bDeviceSuspended = OMAP_FALSE;
+	return 0;
+}
+
+/*
+ * Function called when the driver is requested to shutdown
+ * in: pDevice
+ */
+static IMG_VOID DriverShutdown_Entry(
+	struct platform_device unref__ *pDevice)
+{
+	DEBUG_PRINTK("Requested driver shutdown");
+	CommonSuspend();
+}
+
+static struct platform_driver omap_sgx_dc_driver = {
+	.driver = {
+		.name = DRVNAME,
+	},
+	.suspend = DriverSuspend_Entry,
+	.resume	= DriverResume_Entry,
+	.shutdown = DriverShutdown_Entry,
+};
+
+#endif /* defined(SGX_EARLYSUSPEND) */
+
+#endif /* defined(LDM_PLATFORM) */
+
+/*
+ * Driver init function
+ */
+static int __init omap_sgx_dc_init(void)
+{
+	if(create_display_devices() != OMAP_OK)
+	{
+		WARNING_PRINTK("Driver init failed");
+		return -ENODEV;
+	}
+
+#if defined(LDM_PLATFORM)
+	DEBUG_PRINTK("Registering platform driver");
+	if (platform_driver_register(&omap_sgx_dc_driver))
+	{
+		WARNING_PRINTK("Unable to register platform driver");
+		if(destroy_display_devices() != OMAP_OK)
+			WARNING_PRINTK("Driver cleanup failed\n");
+		return -ENODEV;
+	}
+
+#if defined(SGX_EARLYSUSPEND)
+	driver_early_suspend.suspend = DriverSuspend_Entry;
+        driver_early_suspend.resume = DriverResume_Entry;
+        driver_early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB;
+        register_early_suspend(&driver_early_suspend);
+	DEBUG_PRINTK("Registered early suspend support");
+#endif
+
+#endif
+	return 0;
+}
+
+/*
+ * Driver exit function
+ */
+static IMG_VOID __exit omap_sgx_dc_deinit(IMG_VOID)
+{
+#if defined(LDM_PLATFORM)
+	DEBUG_PRINTK("Removing platform driver");
+	platform_driver_unregister(&omap_sgx_dc_driver);
+#if defined(SGX_EARLYSUSPEND)
+        unregister_early_suspend(&driver_early_suspend);
+#endif
+#endif
+	if(destroy_display_devices() != OMAP_OK)
+		WARNING_PRINTK("Driver cleanup failed");
+}
+
+MODULE_SUPPORTED_DEVICE(DEVNAME);
+late_initcall(omap_sgx_dc_init);
+module_exit(omap_sgx_dc_deinit);
diff --git a/drivers/gpu/pvr/display/omap_sgx_displayclass.h b/drivers/gpu/pvr/display/omap_sgx_displayclass.h
new file mode 100644
index 0000000..e97c4ad
--- /dev/null
+++ b/drivers/gpu/pvr/display/omap_sgx_displayclass.h
@@ -0,0 +1,123 @@
+/*************************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
+ *
+ *************************************************************************/
+
+#ifndef __OMAP_SGX_DISPLAYCLASS_H__
+#define __OMAP_SGX_DISPLAYCLASS_H__
+
+extern IMG_BOOL PVRGetDisplayClassJTable(
+	PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable);
+
+typedef void * OMAP_HANDLE;
+
+enum OMAP_BOOL
+{
+	OMAP_FALSE = 0,
+	OMAP_TRUE = 1,
+};
+
+struct OMAP_DISP_BUFFER
+{
+	unsigned long ulBufferSize;
+	IMG_SYS_PHYADDR sSysAddr;
+	IMG_CPU_VIRTADDR sCPUVAddr;
+	PVRSRV_SYNC_DATA *psSyncData;
+	struct OMAP_DISP_BUFFER *psNext;
+	struct omap_display_buffer *display_buffer;
+};
+
+struct OMAP_DISP_FLIP_ITEM
+{
+	OMAP_HANDLE hCmdComplete;
+	unsigned long ulSwapInterval;
+	enum OMAP_BOOL bValid;
+	enum OMAP_BOOL bFlipped;
+	enum OMAP_BOOL bCmdCompleted;
+	IMG_SYS_PHYADDR *sSysAddr;
+	struct omap_display_buffer *display_buffer;
+};
+
+struct OMAP_DISP_SWAPCHAIN
+{
+	unsigned long ulBufferCount;
+	struct OMAP_DISP_BUFFER *psBuffer;
+	struct OMAP_DISP_FLIP_ITEM *psFlipItems;
+	unsigned long ulInsertIndex;
+	unsigned long ulRemoveIndex;
+	PVRSRV_DC_DISP2SRV_KMJTABLE *psPVRJTable;
+	enum OMAP_BOOL bFlushCommands;
+	unsigned long ulSetFlushStateRefCount;
+	enum OMAP_BOOL bBlanked;
+	spinlock_t *psSwapChainLock;
+	void *pvDevInfo;
+};
+
+struct OMAP_DISP_DEVINFO
+{
+	unsigned long ulDeviceID;
+	struct OMAP_DISP_BUFFER sSystemBuffer;
+	PVRSRV_DC_DISP2SRV_KMJTABLE sPVRJTable;
+	PVRSRV_DC_SRV2DISP_KMJTABLE sDCJTable;
+	struct OMAP_DISP_SWAPCHAIN *psSwapChain;
+	enum OMAP_BOOL bFlushCommands;
+	enum OMAP_BOOL bDeviceSuspended;
+	struct mutex sSwapChainLockMutex;
+	IMG_DEV_VIRTADDR sDisplayDevVAddr;
+	DISPLAY_INFO sDisplayInfo;
+	DISPLAY_FORMAT sDisplayFormat;
+	DISPLAY_DIMS sDisplayDim;
+	struct workqueue_struct *sync_display_wq;
+	struct work_struct sync_display_work;
+	PVRSRV_PIXEL_FORMAT ePixelFormat;
+	struct omap_display_device *display;
+};
+
+enum OMAP_ERROR
+{
+	OMAP_OK                             =  0,
+	OMAP_ERROR_GENERIC                  =  1,
+	OMAP_ERROR_OUT_OF_MEMORY            =  2,
+	OMAP_ERROR_TOO_FEW_BUFFERS          =  3,
+	OMAP_ERROR_INVALID_PARAMS           =  4,
+	OMAP_ERROR_INIT_FAILURE             =  5,
+	OMAP_ERROR_CANT_REGISTER_CALLBACK   =  6,
+	OMAP_ERROR_INVALID_DEVICE           =  7,
+	OMAP_ERROR_DEVICE_REGISTER_FAILED   =  8
+
+};
+
+#define DISPLAY_DEVICE_NAME "PowerVR OMAP Display Driver"
+#define	DRVNAME	"omap_sgx_displayclass"
+#define	DEVNAME	DRVNAME
+#define	DRIVER_PREFIX DRVNAME
+
+#define	DEBUG_PRINTK(format, ...) printk("DEBUG " DRIVER_PREFIX \
+	" (%s %i): " format "\n", __func__, __LINE__, ## __VA_ARGS__)
+#define	WARNING_PRINTK(format, ...) printk("WARNING " DRIVER_PREFIX \
+	" (%s %i): " format "\n", __func__, __LINE__, ## __VA_ARGS__)
+#define	ERROR_PRINTK(format, ...) printk("ERROR " DRIVER_PREFIX \
+	" (%s %i): " format "\n", __func__, __LINE__, ## __VA_ARGS__)
+
+#endif
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 6e16244..69052a6 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -14,6 +14,8 @@ source "drivers/gpu/vga/Kconfig"
 
 source "drivers/gpu/drm/Kconfig"
 
+source "drivers/gpu/pvr/Kconfig"
+
 config VGASTATE
        tristate
        default n
-- 
1.7.0.4

