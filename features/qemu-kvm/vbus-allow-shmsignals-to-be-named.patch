From d2a4a4fbea18fba123ffe62fdc8560c8b51889ea Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Tue, 13 Oct 2009 19:44:13 -0400
Subject: [PATCH 068/119] vbus: allow shmsignals to be named

This will allow the signals to be displayed to the end-user in some
meaningful way later in the series, such as for statistics, etc.

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 drivers/net/vbus-enet.c     |   43 ++++++++++++++++++++++++++++++++++---------
 drivers/vbus/bus-proxy.c    |    6 +++---
 drivers/vbus/pci-bridge.c   |    3 ++-
 include/linux/vbus_driver.h |    7 ++++---
 4 files changed, 43 insertions(+), 16 deletions(-)

diff --git a/drivers/net/vbus-enet.c b/drivers/net/vbus-enet.c
index 6fe2241..9d48674 100644
--- a/drivers/net/vbus-enet.c
+++ b/drivers/net/vbus-enet.c
@@ -101,14 +101,20 @@ napi_to_priv(struct napi_struct *napi)
 static int
 queue_init(struct vbus_enet_priv *priv,
 	   struct vbus_enet_queue *q,
+	   const char *name,
 	   int qid,
 	   size_t ringsize,
 	   void (*func)(struct ioq_notifier *))
 {
 	struct vbus_device_proxy *dev = priv->vdev;
 	int ret;
+	char _name[64];
 
-	ret = vbus_driver_ioq_alloc(dev, qid, 0, ringsize, &q->queue);
+	if (name)
+		snprintf(_name, sizeof(_name), "%s-%s", priv->dev->name, name);
+
+	ret = vbus_driver_ioq_alloc(dev, name ? _name : NULL, qid, 0,
+				    ringsize, &q->queue);
 	if (ret < 0)
 		panic("ioq_alloc failed: %d\n", ret);
 
@@ -396,7 +402,8 @@ tx_setup(struct vbus_enet_priv *priv)
 
 		priv->pmtd.pool = pool;
 
-		ret = dev->ops->shm(dev, shmid, 0, pool, poollen, 0, NULL, 0);
+		ret = dev->ops->shm(dev, NULL, shmid, 0, pool, poollen,
+				    0, NULL, 0);
 		BUG_ON(ret < 0);
 	}
 
@@ -1227,12 +1234,13 @@ vbus_enet_evq_negcap(struct vbus_enet_priv *priv, unsigned long count)
 
 		priv->evq.pool = pool;
 
-		ret = dev->ops->shm(dev, query.dpid, 0,
+		ret = dev->ops->shm(dev, NULL, query.dpid, 0,
 				    pool, poollen, 0, NULL, 0);
 		if (ret < 0)
 			return ret;
 
-		queue_init(priv, &priv->evq.veq, query.qid, count, evq_isr);
+		queue_init(priv, &priv->evq.veq, "evq",
+			   query.qid, count, evq_isr);
 
 		ret = ioq_iter_init(priv->evq.veq.queue,
 				    &iter, ioq_idxtype_valid, 0);
@@ -1302,7 +1310,7 @@ vbus_enet_l4ro_negcap(struct vbus_enet_priv *priv, unsigned long count)
 		/*
 		 * pre-mapped descriptor pool
 		 */
-		ret = dev->ops->shm(dev, query.dpid, 0,
+		ret = dev->ops->shm(dev, NULL, query.dpid, 0,
 				    pool, poollen, 0, NULL, 0);
 		if (ret < 0) {
 			printk(KERN_ERR "Error registering L4RO pool: %d\n",
@@ -1317,7 +1325,8 @@ vbus_enet_l4ro_negcap(struct vbus_enet_priv *priv, unsigned long count)
 		 * one MTU frame.  All we need to do is keep it populated
 		 * with free pages.
 		 */
-		queue_init(priv, &priv->l4ro.pageq, query.pqid, count, NULL);
+		queue_init(priv, &priv->l4ro.pageq, "pageq", query.pqid,
+			   count, NULL);
 
 		priv->l4ro.pool      = pool;
 		priv->l4ro.available = true;
@@ -1395,6 +1404,16 @@ vbus_enet_probe(struct vbus_device_proxy *vdev)
 	if (!dev)
 		return -ENOMEM;
 
+	/*
+	 * establish our device-name early so we can incorporate it into
+	 * the signal-path names, etc
+	 */
+	rtnl_lock();
+
+	ret = dev_alloc_name(dev, dev->name);
+	if (ret < 0)
+		goto out_free;
+
 	priv = netdev_priv(dev);
 
 	spin_lock_init(&priv->lock);
@@ -1416,8 +1435,10 @@ vbus_enet_probe(struct vbus_device_proxy *vdev)
 
 	skb_queue_head_init(&priv->tx.outstanding);
 
-	queue_init(priv, &priv->rxq, VENET_QUEUE_RX, rx_ringlen, rx_isr);
-	queue_init(priv, &priv->tx.veq, VENET_QUEUE_TX, tx_ringlen, tx_isr);
+	queue_init(priv, &priv->rxq, "rx", VENET_QUEUE_RX, rx_ringlen,
+		   rx_isr);
+	queue_init(priv, &priv->tx.veq, "tx", VENET_QUEUE_TX, tx_ringlen,
+		   tx_isr);
 
 	rx_setup(priv);
 	tx_setup(priv);
@@ -1453,18 +1474,22 @@ vbus_enet_probe(struct vbus_device_proxy *vdev)
 
 	dev->features |= NETIF_F_HIGHDMA;
 
-	ret = register_netdev(dev);
+	ret = register_netdevice(dev);
 	if (ret < 0) {
 		printk(KERN_INFO "VENET: error %i registering device \"%s\"\n",
 		       ret, dev->name);
 		goto out_free;
 	}
 
+	rtnl_unlock();
+
 	vdev->priv = priv;
 
 	return 0;
 
  out_free:
+	rtnl_unlock();
+
 	free_netdev(dev);
 
 	return ret;
diff --git a/drivers/vbus/bus-proxy.c b/drivers/vbus/bus-proxy.c
index 88cd904..5d34942 100644
--- a/drivers/vbus/bus-proxy.c
+++ b/drivers/vbus/bus-proxy.c
@@ -167,8 +167,8 @@ static struct ioq_ops vbus_driver_ioq_ops = {
 };
 
 
-int vbus_driver_ioq_alloc(struct vbus_device_proxy *dev, int id, int prio,
-			  size_t count, struct ioq **ioq)
+int vbus_driver_ioq_alloc(struct vbus_device_proxy *dev, const char *name,
+			  int id, int prio, size_t count, struct ioq **ioq)
 {
 	struct ioq           *_ioq;
 	struct ioq_ring_head *head = NULL;
@@ -188,7 +188,7 @@ int vbus_driver_ioq_alloc(struct vbus_device_proxy *dev, int id, int prio,
 	head->ver	= IOQ_RING_VER;
 	head->count     = count;
 
-	ret = dev->ops->shm(dev, id, prio, head, len,
+	ret = dev->ops->shm(dev, name, id, prio, head, len,
 			    &head->signal, &signal, 0);
 	if (ret < 0)
 		goto error;
diff --git a/drivers/vbus/pci-bridge.c b/drivers/vbus/pci-bridge.c
index 80718e6..fa77318 100644
--- a/drivers/vbus/pci-bridge.c
+++ b/drivers/vbus/pci-bridge.c
@@ -262,7 +262,8 @@ vbus_pci_device_close(struct vbus_device_proxy *vdev, int flags)
 }
 
 static int
-vbus_pci_device_shm(struct vbus_device_proxy *vdev, int id, int prio,
+vbus_pci_device_shm(struct vbus_device_proxy *vdev, const char *name,
+		    int id, int prio,
 		    void *ptr, size_t len,
 		    struct shm_signal_desc *sdesc, struct shm_signal **signal,
 		    int flags)
diff --git a/include/linux/vbus_driver.h b/include/linux/vbus_driver.h
index 9cfbf60..2b1dac4 100644
--- a/include/linux/vbus_driver.h
+++ b/include/linux/vbus_driver.h
@@ -34,7 +34,8 @@ struct vbus_driver;
 struct vbus_device_proxy_ops {
 	int (*open)(struct vbus_device_proxy *dev, int version, int flags);
 	int (*close)(struct vbus_device_proxy *dev, int flags);
-	int (*shm)(struct vbus_device_proxy *dev, int id, int prio,
+	int (*shm)(struct vbus_device_proxy *dev, const char *name,
+		   int id, int prio,
 		   void *ptr, size_t len,
 		   struct shm_signal_desc *sigdesc, struct shm_signal **signal,
 		   int flags);
@@ -74,7 +75,7 @@ void vbus_driver_unregister(struct vbus_driver *drv);
 /*
  * driver-side IOQ helper - allocates device-shm and maps an IOQ on it
  */
-int vbus_driver_ioq_alloc(struct vbus_device_proxy *dev, int id, int prio,
-			  size_t ringsize, struct ioq **ioq);
+int vbus_driver_ioq_alloc(struct vbus_device_proxy *dev, const char *name,
+			  int id, int prio, size_t ringsize, struct ioq **ioq);
 
 #endif /* _LINUX_VBUS_DRIVER_H */
-- 
1.6.5.2

