From 2cc4ed3a9b42e322b079f9f5149f09867de3dea2 Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Fri, 28 Aug 2009 13:31:31 -0400
Subject: [PATCH] KVM: cache xinterface memory-slots

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 virt/kvm/xinterface.c |   67 ++++++++++++++++++++++++++++++++++++------------
 1 files changed, 50 insertions(+), 17 deletions(-)

diff --git a/virt/kvm/xinterface.c b/virt/kvm/xinterface.c
index e39e713..14823a4 100644
--- a/virt/kvm/xinterface.c
+++ b/virt/kvm/xinterface.c
@@ -36,10 +36,11 @@
 #include "iodev.h"
 
 struct _xinterface {
-	struct kvm            *kvm;
-	struct task_struct    *task;
-	struct mm_struct      *mm;
-	struct kvm_xinterface  intf;
+	struct kvm             *kvm;
+	struct task_struct     *task;
+	struct mm_struct       *mm;
+	struct kvm_xinterface   intf;
+	struct kvm_memory_slot *slotcache[NR_CPUS];
 };
 
 struct _xvmap {
@@ -62,34 +63,55 @@ to_intf(struct kvm_xinterface *intf)
 	return container_of(intf, struct _xinterface, intf);
 }
 
+#define _gfn_to_hva(gfn, memslot) \
+	(memslot->userspace_addr + (gfn - memslot->base_gfn) * PAGE_SIZE)
+
 /* assumes slots_lock held for read */
 static unsigned long
 gpa_to_hva(struct _xinterface *_intf, unsigned long gpa)
 {
-	unsigned long addr;
+	int                     cpu     = get_cpu();
+	unsigned long           gfn     = gpa >> PAGE_SHIFT;
+	struct kvm_memory_slot *memslot = _intf->slotcache[cpu];
+	unsigned long           addr    = 0;
+
+	if (!memslot
+	    || gfn < memslot->base_gfn
+	    || gfn >= memslot->base_gfn + memslot->npages) {
+
+		if (memslot) {
+			atomic_dec(&memslot->refs);
+			_intf->slotcache[cpu] = NULL;
+		}
 
-	addr = gfn_to_hva(_intf->kvm, gpa >> PAGE_SHIFT);
-	if (kvm_is_error_hva(addr))
-		return 0;
+		memslot = gfn_to_memslot(_intf->kvm, gfn);
+		if (!memslot)
+			goto out;
+
+		atomic_inc(&memslot->refs);
+		_intf->slotcache[cpu] = memslot;
+	}
+
+	addr = _gfn_to_hva(gfn, memslot) + offset_in_page(gpa);
+
+out:
+	put_cpu();
 
-	return addr + offset_in_page(gpa);
+	return addr;
 }
 
 /*------------------------------------------------------------------------*/
 
-/* assumes slots_lock held for read */
 static void *
-_vmap(struct _xinterface *_intf, unsigned long gpa, unsigned long npages)
+_vmap(struct _xinterface *_intf, unsigned long addr, unsigned long offset,
+      unsigned long npages)
 {
 	struct task_struct *p = _intf->task;
 	struct mm_struct *mm = _intf->mm;
 	struct page **page_list;
 	void *ptr = NULL;
-	unsigned long addr;
 	int ret;
 
-	addr = gpa_to_hva(_intf, gpa);
-
 	if (npages > (PAGE_SIZE / sizeof(struct page *)))
 		return NULL;
 
@@ -107,7 +129,7 @@ _vmap(struct _xinterface *_intf, unsigned long gpa, unsigned long npages)
 	if (ptr)
 		mm->locked_vm += npages;
 
-	ptr = ptr + offset_in_page(gpa);
+	ptr = ptr + offset;
 
 out:
 	up_write(&mm->mmap_sem);
@@ -306,11 +328,12 @@ xinterface_vmap(struct kvm_xinterface *intf,
 	int                         ret = -EINVAL;
 	void                       *addr = NULL;
 	off_t                       offset = offset_in_page(gpa);
+	unsigned long               gfn = gpa >> PAGE_SHIFT;
 	unsigned long               npages;
 
 	mutex_lock(&kvm->slots_lock);
 
-	memslot = gfn_to_memslot(kvm, gpa >> PAGE_SHIFT);
+	memslot = gfn_to_memslot(kvm, gfn);
 	if (!memslot)
 		goto fail;
 
@@ -320,7 +343,7 @@ xinterface_vmap(struct kvm_xinterface *intf,
 
 	npages = PAGE_ALIGN(len + offset) >> PAGE_SHIFT;
 
-	addr = _vmap(_intf, gpa, npages);
+	addr = _vmap(_intf, _gfn_to_hva(gfn, memslot), offset, npages);
 	if (!addr) {
 		ret = -EFAULT;
 		goto fail;
@@ -524,6 +547,16 @@ static void
 xinterface_release(struct kvm_xinterface *intf)
 {
 	struct _xinterface *_intf = to_intf(intf);
+	int i;
+
+	for_each_possible_cpu(i) {
+		struct kvm_memory_slot *memslot = _intf->slotcache[i];
+
+		if (memslot) {
+			atomic_dec(&memslot->refs);
+			_intf->slotcache[i] = NULL;
+		}
+	}
 
 	mmput(_intf->mm);
 	put_task_struct(_intf->task);
-- 
1.7.4.1

