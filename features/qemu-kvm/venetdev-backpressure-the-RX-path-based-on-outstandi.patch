From f0a08dbe2e6c515e1b890d49458ddd0df77d0a7d Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Mon, 26 Oct 2009 14:32:24 -0400
Subject: [PATCH 074/119] venetdev: backpressure the RX path based on outstanding packets

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 kernel/vbus/devices/venet/device.c |   20 ++++++++++++++++----
 1 files changed, 16 insertions(+), 4 deletions(-)

diff --git a/kernel/vbus/devices/venet/device.c b/kernel/vbus/devices/venet/device.c
index 058830d..d49ba7f 100644
--- a/kernel/vbus/devices/venet/device.c
+++ b/kernel/vbus/devices/venet/device.c
@@ -593,10 +593,21 @@ venetdev_sg_import_zc(struct venetdev *priv,
 	struct scatterlist sgl[vsg->count];
 	struct scatterlist *sg;
 	struct _venetdev_skb *_skb;
+	int maxoutstanding = ioq_size(priv->vbus.rxq.queue);
 	int nr_addrs = 0;
 	int i;
 	int ret;
 
+	/*
+	 * We backpressure the queue (by sleeping) if we have too many
+	 * outstanding packets.   The backpressure if relieved as the
+	 * packets complete
+	 */
+	if (atomic_read(&priv->netif.rxq.outstanding) >= maxoutstanding) {
+		wait_event(priv->netif.rxq.wq,
+			   (atomic_read(&priv->netif.rxq.outstanding) < maxoutstanding));
+	}
+
 	venet_sg_iter_init(&iter, vsg, priv->vbus.ctx);
 
 	/* First import the header */
@@ -851,17 +862,18 @@ venetdev_skb_release(struct sk_buff *skb)
 
 	evq_send_txc(priv, _skb->cookie);
 
-	if (atomic_dec_and_test(&priv->netif.rxq.outstanding)) {
+	if (atomic_dec_and_test(&priv->netif.rxq.outstanding))
 		/*
 		 * We reset the 'completed' count once we successfully drain
 		 * the queue
 		 */
 		priv->netif.rxq.completed = 0;
-		if (waitqueue_active(&priv->netif.rxq.wq))
-			wake_up(&priv->netif.rxq.wq);
-	} else
+	else
 		priv->netif.rxq.completed++;
 
+	if (waitqueue_active(&priv->netif.rxq.wq))
+		wake_up(&priv->netif.rxq.wq);
+
 	/*
 	 * If txmitigation is disabled, or if we hit the txmitigation threshold,
 	 * we need to send a signal to drain the evq
-- 
1.6.5.2

