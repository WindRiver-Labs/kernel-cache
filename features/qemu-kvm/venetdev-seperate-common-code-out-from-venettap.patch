From 93aa1494ee5702ed1186a07ad47b663b9075b80c Mon Sep 17 00:00:00 2001
From: Patrick Mullaney <pmullaney@novell.com>
Date: Thu, 17 Sep 2009 11:34:57 -0400
Subject: [PATCH 040/119] venetdev: seperate common code out from venettap

Signed-off-by: Patrick Mullaney <pmullaney@novell.com>

[gmh: corrected checkpatch error in venetdev_out, and updated comment]

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 kernel/vbus/devices/venet/Kconfig       |    5 +
 kernel/vbus/devices/venet/Makefile      |    8 +-
 kernel/vbus/devices/venet/device.c      |  646 ++++++++-----------------------
 kernel/vbus/devices/venet/tap.c         |  290 ++++++++++++++
 kernel/vbus/devices/venet/venetdevice.h |  151 +++++++
 5 files changed, 621 insertions(+), 479 deletions(-)
 create mode 100644 kernel/vbus/devices/venet/tap.c
 create mode 100644 kernel/vbus/devices/venet/venetdevice.h

diff --git a/kernel/vbus/devices/venet/Kconfig b/kernel/vbus/devices/venet/Kconfig
index 64e4731..81a4db5 100644
--- a/kernel/vbus/devices/venet/Kconfig
+++ b/kernel/vbus/devices/venet/Kconfig
@@ -2,9 +2,14 @@
 # Virtual-Bus (VBus) configuration
 #
 
+config VBUS_VENETDEV
+       bool
+       default n
+
 config VBUS_VENETTAP
        tristate "Virtual-Bus Ethernet Tap Device"
        depends on VBUS_DEVICES
+       select VBUS_VENETDEV
        default n
        help
         Provides a virtual ethernet adapter to a vbus, which in turn
diff --git a/kernel/vbus/devices/venet/Makefile b/kernel/vbus/devices/venet/Makefile
index 2ea7d2a..185d825 100644
--- a/kernel/vbus/devices/venet/Makefile
+++ b/kernel/vbus/devices/venet/Makefile
@@ -1 +1,7 @@
-obj-$(CONFIG_VBUS_VENETTAP) += venet-tap.o
+venet-device-objs += device.o
+ifneq ($(CONFIG_VBUS_VENETTAP),n)
+venet-device-objs += tap.o
+endif
+
+obj-$(CONFIG_VBUS_VENETDEV) += venet-device.o
+
diff --git a/kernel/vbus/devices/venet/device.c b/kernel/vbus/devices/venet/device.c
index ee091c4..1f80315 100644
--- a/kernel/vbus/devices/venet/device.c
+++ b/kernel/vbus/devices/venet/device.c
@@ -1,5 +1,5 @@
 /*
- * venettap - A 802.x virtual network device based on the VBUS/IOQ interface
+ * venetdev - A 802.x virtual network device based on the VBUS/IOQ interface
  *
  * Copyright (C) 2009 Novell, Gregory Haskins <ghaskins@novell.com>
  *
@@ -21,10 +21,6 @@
  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/moduleparam.h>
-
 #include <linux/sched.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
@@ -46,7 +42,7 @@
 #include <linux/mmu_context.h>
 #include <linux/ktime.h>
 
-#include <linux/venet.h>
+#include "venetdevice.h"
 
 #include <linux/in6.h>
 #include <asm/checksum.h>
@@ -55,7 +51,7 @@ MODULE_AUTHOR("Gregory Haskins");
 MODULE_LICENSE("GPL");
 
 #undef PDEBUG             /* undef it, just in case */
-#ifdef VENETTAP_DEBUG
+#ifdef VENETDEV_DEBUG
 #  define PDEBUG(fmt, args...) printk(KERN_DEBUG "venet-tap: " fmt, ## args)
 #else
 #  define PDEBUG(fmt, args...) /* not debugging: nothing */
@@ -67,86 +63,12 @@ MODULE_PARM_DESC(maxcount, "maximum size for rx/tx ioq ring");
 
 #define PMTD_POOL_ID 100
 
-static void venettap_tx_isr(struct ioq_notifier *notifier);
-static int venettap_rx_thread(void *__priv);
-static int venettap_tx_thread(void *__priv);
-
-struct venettap_queue {
-	struct ioq              *queue;
-	struct ioq_notifier      notifier;
-};
-
-struct venettap;
-
-enum {
-	RX_SCHED,
-	TX_SCHED,
-	TX_NETIF_CONGESTED,
-	TX_IOQ_CONGESTED,
-};
-
-#define MAX_VSG_DESC_SIZE VSG_DESC_SIZE(MAX_SKB_FRAGS)
-
-struct venettap;
-
-struct venettap_rx_ops {
-	int (*decode)(struct venettap *priv, void *ptr, int len);
-	int (*import)(struct venettap *, struct sk_buff *, void *, int);
-};
-
-struct venettap {
-	spinlock_t                   lock;
-	unsigned char                hmac[ETH_ALEN]; /* host-mac */
-	unsigned char                cmac[ETH_ALEN]; /* client-mac */
-	struct task_struct          *rxthread;
-	struct task_struct          *txthread;
-	unsigned long                flags;
-
-	struct {
-		struct net_device           *dev;
-		struct net_device_stats      stats;
-		struct {
-			struct sk_buff_head  list;
-			size_t               len;
-			int                  irqdepth;
-		} txq;
-		int                          enabled:1;
-		int                          link:1;
-	} netif;
-
-	struct {
-		struct vbus_device           dev;
-		struct vbus_device_interface intf;
-		struct vbus_connection       conn;
-		struct vbus_memctx          *ctx;
-		struct venettap_queue        rxq;
-		struct venettap_queue        txq;
-		struct venettap_rx_ops      *rx_ops;
-		wait_queue_head_t            rx_empty;
-		struct {
-			char                 buf[MAX_VSG_DESC_SIZE];
-			size_t               len;
-			int                  enabled:1;
-		} sg;
-		struct {
-			struct vbus_shm     *shm;
-			int                  enabled:1;
-		} pmtd;
-		int                          connected:1;
-		int                          opened:1;
-		int                          link:1;
-	} vbus;
-
-	struct {
-		int                          thresh;
-		ktime_t                      expires;
-	} burst;
-	int                                  txmitigation;
-
-};
+static void venetdev_tx_isr(struct ioq_notifier *notifier);
+static int venetdev_rx_thread(void *__priv);
+static int venetdev_tx_thread(void *__priv);
 
 static int
-venettap_queue_init(struct venettap_queue *q,
+venetdev_queue_init(struct venetdev_queue *q,
 		    struct vbus_shm *shm,
 		    struct shm_signal *signal,
 		    void (*func)(struct ioq_notifier *))
@@ -173,7 +95,7 @@ venettap_queue_init(struct venettap_queue *q,
 }
 
 static void
-venettap_queue_release(struct venettap_queue *q)
+venetdev_queue_release(struct venetdev_queue *q)
 {
 	if (!q->queue)
 		return;
@@ -183,7 +105,7 @@ venettap_queue_release(struct venettap_queue *q)
 }
 
 static int
-venettap_pmtd_init(struct venettap *priv,
+venetdev_pmtd_init(struct venetdev *priv,
 		   struct vbus_shm *shm, struct shm_signal *signal)
 {
 	if (signal || !priv->vbus.pmtd.enabled)
@@ -199,7 +121,7 @@ venettap_pmtd_init(struct venettap *priv,
 
 /* Assumes priv->lock is held */
 static void
-venettap_txq_notify_inc(struct venettap *priv)
+venetdev_txq_notify_inc(struct venetdev *priv)
 {
 	priv->netif.txq.irqdepth++;
 	if (priv->netif.txq.irqdepth == 1 && priv->vbus.link)
@@ -208,7 +130,7 @@ venettap_txq_notify_inc(struct venettap *priv)
 
 /* Assumes priv->lock is held */
 static void
-venettap_txq_notify_dec(struct venettap *priv)
+venetdev_txq_notify_dec(struct venetdev *priv)
 {
 	BUG_ON(!priv->netif.txq.irqdepth);
 	priv->netif.txq.irqdepth--;
@@ -222,25 +144,10 @@ venettap_txq_notify_dec(struct venettap *priv)
  *----------------------------------------------------------------------
  */
 
-static struct venettap *conn_to_priv(struct vbus_connection *conn)
-{
-	return container_of(conn, struct venettap, vbus.conn);
-}
-
-static struct venettap *intf_to_priv(struct vbus_device_interface *intf)
-{
-	return container_of(intf, struct venettap, vbus.intf);
-}
-
-static struct venettap *vdev_to_priv(struct vbus_device *vdev)
-{
-	return container_of(vdev, struct venettap, vbus.dev);
-}
-
-static int
-venettap_netdev_open(struct net_device *dev)
+int
+venetdev_netdev_open(struct net_device *dev)
 {
-	struct venettap *priv = netdev_priv(dev);
+	struct venetdev *priv = netdev_priv(dev);
 	unsigned long flags;
 
 	BUG_ON(priv->netif.link);
@@ -259,10 +166,10 @@ venettap_netdev_open(struct net_device *dev)
 	 * core as the rx-thread) by virtue of the netif_rx() backlog mechanism.
 	 * However, this can be mitigated by the use of netif_rx_ni().
 	 */
-	priv->rxthread = kthread_create(venettap_rx_thread, priv,
+	priv->rxthread = kthread_create(venetdev_rx_thread, priv,
 					"%s-rx", priv->netif.dev->name);
 
-	priv->txthread = kthread_create(venettap_tx_thread, priv,
+	priv->txthread = kthread_create(venetdev_tx_thread, priv,
 					"%s-tx", priv->netif.dev->name);
 
 	spin_lock_irqsave(&priv->lock, flags);
@@ -277,10 +184,10 @@ venettap_netdev_open(struct net_device *dev)
 	return 0;
 }
 
-static int
-venettap_netdev_stop(struct net_device *dev)
+int
+venetdev_netdev_stop(struct net_device *dev)
 {
-	struct venettap *priv = netdev_priv(dev);
+	struct venetdev *priv = netdev_priv(dev);
 	unsigned long flags;
 	int needs_stop = false;
 
@@ -309,15 +216,15 @@ venettap_netdev_stop(struct net_device *dev)
 /*
  * Configuration changes (passed on by ifconfig)
  */
-static int
-venettap_netdev_config(struct net_device *dev, struct ifmap *map)
+int
+venetdev_netdev_config(struct net_device *dev, struct ifmap *map)
 {
 	if (dev->flags & IFF_UP) /* can't act on a running interface */
 		return -EBUSY;
 
 	/* Don't allow changing the I/O address */
 	if (map->base_addr != dev->base_addr) {
-		printk(KERN_WARNING "venettap: Can't change I/O address\n");
+		printk(KERN_WARNING "venetdev: Can't change I/O address\n");
 		return -EOPNOTSUPP;
 	}
 
@@ -325,8 +232,8 @@ venettap_netdev_config(struct net_device *dev, struct ifmap *map)
 	return 0;
 }
 
-static int
-venettap_change_mtu(struct net_device *dev, int new_mtu)
+int
+venetdev_change_mtu(struct net_device *dev, int new_mtu)
 {
 	dev->mtu = new_mtu;
 
@@ -341,7 +248,7 @@ venettap_change_mtu(struct net_device *dev, int new_mtu)
 
 /* assumes reference to priv->vbus.conn held */
 static int
-venettap_sg_decode(struct venettap *priv, void *ptr, int len)
+venetdev_sg_decode(struct venetdev *priv, void *ptr, int len)
 {
 	struct venet_sg *vsg = (struct venet_sg *)priv->vbus.sg.buf;
 	int ret;
@@ -413,12 +320,12 @@ venettap_sg_decode(struct venettap *priv, void *ptr, int len)
 }
 
 /*
- * venettap_sg_import - import an skb in scatter-gather mode
+ * venetdev_sg_import - import an skb in scatter-gather mode
  *
  * assumes reference to priv->vbus.conn held
  */
 static int
-venettap_sg_import(struct venettap *priv, struct sk_buff *skb,
+venetdev_sg_import(struct venetdev *priv, struct sk_buff *skb,
 		   void *ptr, int len)
 {
 	struct venet_sg *vsg = (struct venet_sg *)priv->vbus.sg.buf;
@@ -492,9 +399,9 @@ venettap_sg_import(struct venettap *priv, struct sk_buff *skb,
 	return 0;
 }
 
-static struct venettap_rx_ops venettap_sg_rx_ops = {
-	.decode = venettap_sg_decode,
-	.import = venettap_sg_import,
+static struct venetdev_rx_ops venetdev_sg_rx_ops = {
+	.decode = venetdev_sg_decode,
+	.import = venetdev_sg_import,
 };
 
 /*
@@ -505,7 +412,7 @@ static struct venettap_rx_ops venettap_sg_rx_ops = {
 
 /* assumes reference to priv->vbus.conn held */
 static int
-venettap_flat_decode(struct venettap *priv, void *ptr, int len)
+venetdev_flat_decode(struct venetdev *priv, void *ptr, int len)
 {
 	size_t maxlen = priv->netif.dev->mtu + ETH_HLEN;
 
@@ -521,12 +428,12 @@ venettap_flat_decode(struct venettap *priv, void *ptr, int len)
 }
 
 /*
- * venettap_rx_flat - import an skb in non scatter-gather mode
+ * venetdev_rx_flat - import an skb in non scatter-gather mode
  *
  * assumes reference to priv->vbus.conn held
  */
 static int
-venettap_flat_import(struct venettap *priv, struct sk_buff *skb,
+venetdev_flat_import(struct venetdev *priv, struct sk_buff *skb,
 		     void *ptr, int len)
 {
 	struct vbus_memctx *ctx = priv->vbus.ctx;
@@ -541,16 +448,30 @@ venettap_flat_import(struct venettap *priv, struct sk_buff *skb,
 	return 0;
 }
 
-static struct venettap_rx_ops venettap_flat_rx_ops = {
-	.decode = venettap_flat_decode,
-	.import = venettap_flat_import,
+static struct venetdev_rx_ops venetdev_flat_rx_ops = {
+	.decode = venetdev_flat_decode,
+	.import = venetdev_flat_import,
 };
 
 /*
+ * default out to netif_rx_ni.
+ */
+
+static int
+venetdev_out(struct venetdev *priv, struct sk_buff *skb)
+{
+	/* Pass the buffer up to the stack */
+	skb->dev      = priv->netif.dev;
+	skb->protocol = eth_type_trans(skb, priv->netif.dev);
+
+	return netif_rx_ni(skb);
+}
+
+/*
  * The poll implementation.
  */
 static int
-venettap_rx(struct venettap *priv)
+venetdev_rx(struct venetdev *priv)
 {
 	struct ioq                 *ioq;
 	struct vbus_memctx         *ctx;
@@ -560,7 +481,7 @@ venettap_rx(struct venettap *priv)
 	int                         ret;
 	unsigned long               flags;
 	struct vbus_connection     *conn;
-	struct venettap_rx_ops     *rx_ops;
+	struct venetdev_rx_ops     *rx_ops;
 
 	PDEBUG("polling...\n");
 
@@ -636,11 +557,7 @@ venettap_rx(struct venettap *priv)
 		priv->netif.stats.rx_packets++;
 		priv->netif.stats.rx_bytes += len;
 
-		/* Pass the buffer up to the stack */
-		skb->dev      = priv->netif.dev;
-		skb->protocol = eth_type_trans(skb, priv->netif.dev);
-
-		netif_rx_ni(skb);
+		priv->netif.out(priv, skb);
 next:
 		dirty = 1;
 
@@ -675,9 +592,9 @@ next:
 	return 0;
 }
 
-static int venettap_rx_thread(void *__priv)
+static int venetdev_rx_thread(void *__priv)
 {
-	struct venettap *priv = __priv;
+	struct venetdev *priv = __priv;
 	struct vbus_memctx *ctx = priv->vbus.ctx;
 	struct mm_struct *mm = NULL;
 
@@ -701,7 +618,7 @@ static int venettap_rx_thread(void *__priv)
 		if (kthread_should_stop())
 			break;
 
-		venettap_rx(priv);
+		venetdev_rx(priv);
 	}
 
 	if (mm) {
@@ -714,7 +631,7 @@ static int venettap_rx_thread(void *__priv)
 
 /* assumes priv->lock is held */
 static void
-venettap_check_netif_congestion(struct venettap *priv)
+venetdev_check_netif_congestion(struct venetdev *priv)
 {
 	struct ioq *ioq = priv->vbus.txq.queue;
 
@@ -722,7 +639,7 @@ venettap_check_netif_congestion(struct venettap *priv)
 	    && priv->netif.txq.len < ioq_remain(ioq, ioq_idxtype_inuse)
 	    && test_and_clear_bit(TX_NETIF_CONGESTED, &priv->flags)) {
 		PDEBUG("NETIF congestion cleared\n");
-		venettap_txq_notify_dec(priv);
+		venetdev_txq_notify_dec(priv);
 
 		if (priv->netif.link)
 			netif_wake_queue(priv->netif.dev);
@@ -730,7 +647,7 @@ venettap_check_netif_congestion(struct venettap *priv)
 }
 
 static int
-venettap_tx(struct venettap *priv)
+venetdev_tx(struct venetdev *priv)
 {
 	struct sk_buff             *skb;
 	struct ioq_iterator         iter;
@@ -817,10 +734,10 @@ venettap_tx(struct venettap *priv)
 	} else if (!test_and_set_bit(TX_IOQ_CONGESTED, &priv->flags)) {
 		PDEBUG("congested with %d packets still queued\n",
 		       priv->netif.txq.len);
-		venettap_txq_notify_inc(priv);
+		venetdev_txq_notify_inc(priv);
 	}
 
-	venettap_check_netif_congestion(priv);
+	venetdev_check_netif_congestion(priv);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
@@ -829,9 +746,9 @@ venettap_tx(struct venettap *priv)
 	return npackets;
 }
 
-static int venettap_tx_thread(void *__priv)
+static int venetdev_tx_thread(void *__priv)
 {
-	struct venettap *priv = __priv;
+	struct venetdev *priv = __priv;
 	struct vbus_memctx *ctx = priv->vbus.ctx;
 	struct mm_struct *mm = NULL;
 
@@ -862,7 +779,7 @@ static int venettap_tx_thread(void *__priv)
 		if (kthread_should_stop())
 			break;
 
-		venettap_tx(priv);
+		venetdev_tx(priv);
 	}
 
 	if (mm) {
@@ -874,7 +791,7 @@ static int venettap_tx_thread(void *__priv)
 }
 
 static void
-venettap_deferred_tx(struct venettap *priv)
+venetdev_deferred_tx(struct venetdev *priv)
 {
 	PDEBUG("wake up txthread\n");
 	wake_up_process(priv->txthread);
@@ -882,7 +799,7 @@ venettap_deferred_tx(struct venettap *priv)
 
 /* assumes priv->lock is held */
 static void
-venettap_apply_backpressure(struct venettap *priv)
+venetdev_apply_backpressure(struct venetdev *priv)
 {
 	PDEBUG("backpressure\n");
 
@@ -891,7 +808,7 @@ venettap_apply_backpressure(struct venettap *priv)
 		 * We must flow-control the kernel by disabling the queue
 		 */
 		netif_stop_queue(priv->netif.dev);
-		venettap_txq_notify_inc(priv);
+		venetdev_txq_notify_inc(priv);
 	}
 }
 
@@ -906,10 +823,10 @@ venettap_apply_backpressure(struct venettap *priv)
  * the netif flow control is still managed by the actual consumer,
  * thereby avoiding the creation of an extra servo-loop to the equation.
  */
-static int
-venettap_netdev_tx(struct sk_buff *skb, struct net_device *dev)
+int
+venetdev_netdev_tx(struct sk_buff *skb, struct net_device *dev)
 {
-	struct venettap *priv = netdev_priv(dev);
+	struct venetdev *priv = netdev_priv(dev);
 	struct ioq      *ioq = NULL;
 	unsigned long    flags;
 
@@ -934,16 +851,16 @@ venettap_netdev_tx(struct sk_buff *skb, struct net_device *dev)
 	set_bit(TX_SCHED, &priv->flags);
 
 	if (priv->netif.txq.len >= ioq_remain(ioq, ioq_idxtype_inuse))
-		venettap_apply_backpressure(priv);
+		venetdev_apply_backpressure(priv);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	venettap_deferred_tx(priv);
+	venetdev_deferred_tx(priv);
 
 	return NETDEV_TX_OK;
 
 flowcontrol:
-	venettap_apply_backpressure(priv);
+	venetdev_apply_backpressure(priv);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
@@ -953,8 +870,8 @@ flowcontrol:
 /*
  * Ioctl commands
  */
-static int
-venettap_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+int
+venetdev_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	PDEBUG("ioctl\n");
 	return 0;
@@ -964,34 +881,25 @@ venettap_netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
  * Return statistics to the caller
  */
 struct net_device_stats *
-venettap_netdev_stats(struct net_device *dev)
+venetdev_netdev_stats(struct net_device *dev)
 {
-	struct venettap *priv = netdev_priv(dev);
+	struct venetdev *priv = netdev_priv(dev);
 	return &priv->netif.stats;
 }
 
-static void
-venettap_netdev_unregister(struct venettap *priv)
-{
-	if (priv->netif.enabled) {
-		venettap_netdev_stop(priv->netif.dev);
-		unregister_netdev(priv->netif.dev);
-	}
-}
-
 /*
  * receive interrupt-service-routine - called whenever the vbus-driver signals
  * our IOQ to indicate more inbound packets are ready.
  */
 static void
-venettap_rx_isr(struct ioq_notifier *notifier)
+venetdev_rx_isr(struct ioq_notifier *notifier)
 {
-	struct venettap *priv;
+	struct venetdev *priv;
 	unsigned long flags;
 	ktime_t now;
 	int direct = 0;
 
-	priv = container_of(notifier, struct venettap, vbus.rxq.notifier);
+	priv = container_of(notifier, struct venetdev, vbus.rxq.notifier);
 
 	spin_lock_irqsave(&priv->lock, flags);
 
@@ -1031,7 +939,7 @@ venettap_rx_isr(struct ioq_notifier *notifier)
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	if (direct)
-		venettap_rx(priv);
+		venetdev_rx(priv);
 }
 
 /*
@@ -1039,12 +947,12 @@ venettap_rx_isr(struct ioq_notifier *notifier)
  * our IOQ to indicate there is more room in the TX queue
  */
 static void
-venettap_tx_isr(struct ioq_notifier *notifier)
+venetdev_tx_isr(struct ioq_notifier *notifier)
 {
-	struct venettap *priv;
+	struct venetdev *priv;
 	unsigned long flags;
 
-	priv = container_of(notifier, struct venettap, vbus.txq.notifier);
+	priv = container_of(notifier, struct venetdev, vbus.txq.notifier);
 
 	spin_lock_irqsave(&priv->lock, flags);
 
@@ -1052,19 +960,19 @@ venettap_tx_isr(struct ioq_notifier *notifier)
 	    && !ioq_full(priv->vbus.txq.queue, ioq_idxtype_inuse)
 	    && test_and_clear_bit(TX_IOQ_CONGESTED, &priv->flags)) {
 		PDEBUG("IOQ congestion cleared\n");
-		venettap_txq_notify_dec(priv);
+		venetdev_txq_notify_dec(priv);
 
 		if (priv->netif.link)
 			wake_up_process(priv->txthread);
 	}
 
-	venettap_check_netif_congestion(priv);
+	venetdev_check_netif_congestion(priv);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 }
 
 static int
-venettap_vlink_up(struct venettap *priv)
+venetdev_vlink_up(struct venetdev *priv)
 {
 	int ret = 0;
 	unsigned long flags;
@@ -1086,7 +994,7 @@ venettap_vlink_up(struct venettap *priv)
 	if (priv->netif.link)
 		netif_carrier_on(priv->netif.dev);
 
-	venettap_check_netif_congestion(priv);
+	venetdev_check_netif_congestion(priv);
 
 	ioq_notify_enable(priv->vbus.rxq.queue, 0);
 
@@ -1096,8 +1004,8 @@ out:
 }
 
 /* Assumes priv->lock held */
-static int
-_venettap_vlink_down(struct venettap *priv)
+int
+_venetdev_vlink_down(struct venetdev *priv)
 {
 	struct sk_buff *skb;
 
@@ -1125,20 +1033,20 @@ _venettap_vlink_down(struct venettap *priv)
 }
 
 static int
-venettap_vlink_down(struct venettap *priv)
+venetdev_vlink_down(struct venetdev *priv)
 {
 	unsigned long flags;
 	int ret;
 
 	spin_lock_irqsave(&priv->lock, flags);
-	ret = _venettap_vlink_down(priv);
+	ret = _venetdev_vlink_down(priv);
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	return ret;
 }
 
 static int
-venettap_macquery(struct venettap *priv, void *data, unsigned long len)
+venetdev_macquery(struct venetdev *priv, void *data, unsigned long len)
 {
 	struct vbus_memctx *ctx = priv->vbus.ctx;
 	int ret;
@@ -1154,7 +1062,7 @@ venettap_macquery(struct venettap *priv, void *data, unsigned long len)
 }
 
 static u32
-venettap_negcap_sg(struct venettap *priv, u32 requested)
+venetdev_negcap_sg(struct venetdev *priv, u32 requested)
 {
 	u32 available = VENET_CAP_SG|VENET_CAP_TSO4|VENET_CAP_TSO6
 		|VENET_CAP_ECN|VENET_CAP_PMTD;
@@ -1164,7 +1072,7 @@ venettap_negcap_sg(struct venettap *priv, u32 requested)
 
 	if (ret & VENET_CAP_SG) {
 		priv->vbus.sg.enabled = true;
-		priv->vbus.rx_ops = &venettap_sg_rx_ops;
+		priv->vbus.rx_ops = &venetdev_sg_rx_ops;
 	}
 
 	if (ret & VENET_CAP_PMTD)
@@ -1183,7 +1091,7 @@ venettap_negcap_sg(struct venettap *priv, u32 requested)
  * ascertain the lowest-common-denominator of features to enable
  */
 static int
-venettap_negcap(struct venettap *priv, void *data, unsigned long len)
+venetdev_negcap(struct venetdev *priv, void *data, unsigned long len)
 {
 	struct vbus_memctx *ctx = priv->vbus.ctx;
 	struct venet_capabilities caps;
@@ -1201,7 +1109,7 @@ venettap_negcap(struct venettap *priv, void *data, unsigned long len)
 
 	switch (caps.gid) {
 	case VENET_CAP_GROUP_SG:
-		caps.bits = venettap_negcap_sg(priv, caps.bits);
+		caps.bits = venetdev_negcap_sg(priv, caps.bits);
 		break;
 	default:
 		caps.bits = 0;
@@ -1224,7 +1132,7 @@ venettap_negcap(struct venettap *priv, void *data, unsigned long len)
  * are a different size than the new MTU
  */
 static int
-venettap_flushrx(struct venettap *priv)
+venetdev_flushrx(struct venetdev *priv)
 {
 	struct ioq_iterator         iter;
 	struct ioq                 *ioq = NULL;
@@ -1260,7 +1168,7 @@ venettap_flushrx(struct venettap *priv)
 	if (!test_and_set_bit(TX_IOQ_CONGESTED, &priv->flags)) {
 		PDEBUG("congested with %d packets still queued\n",
 		       priv->netif.txq.len);
-		venettap_txq_notify_inc(priv);
+		venetdev_txq_notify_inc(priv);
 	}
 
 	/*
@@ -1272,41 +1180,65 @@ venettap_flushrx(struct venettap *priv)
 	 * connector design
 	 */
 
-	venettap_check_netif_congestion(priv);
+	venetdev_check_netif_congestion(priv);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	return 0;
 }
 
+
+void venetdev_init(struct venetdev *device, struct net_device *dev)
+{
+	device->vbus.rx_ops      = &venetdev_flat_rx_ops;
+	init_waitqueue_head(&device->vbus.rx_empty);
+	device->burst.thresh     = 0; /* microseconds, 0 = disabled */
+
+	/*
+	 * netif init
+	 */
+	skb_queue_head_init(&device->netif.txq.list);
+	device->netif.txq.len = 0;
+
+	device->netif.dev = dev;
+	device->netif.out = venetdev_out;
+
+	ether_setup(dev); /* assign some of the fields */
+
+	memcpy(dev->dev_addr, device->hmac, ETH_ALEN);
+
+	dev->features |= NETIF_F_HIGHDMA;
+
+}
+
 /*
  * This is called whenever a driver wants to perform a synchronous
  * "function call" to our device.  It is similar to the notion of
  * an ioctl().  The parameters are part of the ABI between the device
  * and driver.
  */
-static int
-venettap_vlink_call(struct vbus_connection *conn,
+int
+venetdev_vlink_call(struct vbus_connection *conn,
 		    unsigned long func,
 		    void *data,
 		    unsigned long len,
 		    unsigned long flags)
 {
-	struct venettap *priv = conn_to_priv(conn);
+	struct venetdev *priv = conn_to_priv(conn);
 
 	PDEBUG("call -> %d with %p/%d\n", func, data, len);
 
 	switch (func) {
 	case VENET_FUNC_LINKUP:
-		return venettap_vlink_up(priv);
+		return venetdev_vlink_up(priv);
 	case VENET_FUNC_LINKDOWN:
-		return venettap_vlink_down(priv);
+		return venetdev_vlink_down(priv);
 	case VENET_FUNC_MACQUERY:
-		return venettap_macquery(priv, data, len);
+		return venetdev_macquery(priv, data, len);
 	case VENET_FUNC_NEGCAP:
-		return venettap_negcap(priv, data, len);
+		return venetdev_negcap(priv, data, len);
 	case VENET_FUNC_FLUSHRX:
-		return venettap_flushrx(priv);
+		return venetdev_flushrx(priv);
 	case VENET_FUNC_PMTDQUERY:
 		return PMTD_POOL_ID;
 	default:
@@ -1324,26 +1256,26 @@ venettap_vlink_call(struct vbus_connection *conn,
  * The device should take a reference to the IOQ via ioq_get() and hold it
  * until the connection is released.
  */
-static int
-venettap_vlink_shm(struct vbus_connection *conn,
+int
+venetdev_vlink_shm(struct vbus_connection *conn,
 		   unsigned long id,
 		   struct vbus_shm *shm,
 		   struct shm_signal *signal,
 		   unsigned long flags)
 {
-	struct venettap *priv = conn_to_priv(conn);
+	struct venetdev *priv = conn_to_priv(conn);
 
 	PDEBUG("queue -> %p/%d attached\n", ioq, id);
 
 	switch (id) {
 	case VENET_QUEUE_RX:
-		return venettap_queue_init(&priv->vbus.txq, shm, signal,
-					   venettap_tx_isr);
+		return venetdev_queue_init(&priv->vbus.txq, shm, signal,
+					   venetdev_tx_isr);
 	case VENET_QUEUE_TX:
-		return venettap_queue_init(&priv->vbus.rxq, shm, signal,
-					   venettap_rx_isr);
+		return venetdev_queue_init(&priv->vbus.rxq, shm, signal,
+					   venetdev_rx_isr);
 	case PMTD_POOL_ID:
-		return venettap_pmtd_init(priv, shm, signal);
+		return venetdev_pmtd_init(priv, shm, signal);
 	default:
 		return -EINVAL;
 	}
@@ -1351,10 +1283,10 @@ venettap_vlink_shm(struct vbus_connection *conn,
 	return 0;
 }
 
-static void
-venettap_vlink_close(struct vbus_connection *conn)
+void
+venetdev_vlink_close(struct vbus_connection *conn)
 {
-	struct venettap *priv = conn_to_priv(conn);
+	struct venetdev *priv = conn_to_priv(conn);
 	DEFINE_WAIT(wait);
 	unsigned long flags;
 
@@ -1371,7 +1303,7 @@ venettap_vlink_close(struct vbus_connection *conn)
 	spin_lock_irqsave(&priv->lock, flags);
 
 	priv->vbus.opened = false;
-	_venettap_vlink_down(priv);
+	_venetdev_vlink_down(priv);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 }
@@ -1379,21 +1311,21 @@ venettap_vlink_close(struct vbus_connection *conn)
 /*
  * This is called whenever the driver closes all references to our device
  */
-static void
-venettap_vlink_release(struct vbus_connection *conn)
+void
+venetdev_vlink_release(struct vbus_connection *conn)
 {
-	struct venettap *priv = conn_to_priv(conn);
+	struct venetdev *priv = conn_to_priv(conn);
 
 	PDEBUG("connection released\n");
 
-	venettap_queue_release(&priv->vbus.rxq);
-	venettap_queue_release(&priv->vbus.txq);
+	venetdev_queue_release(&priv->vbus.rxq);
+	venetdev_queue_release(&priv->vbus.txq);
 	vbus_memctx_put(priv->vbus.ctx);
 
 	kobject_put(priv->vbus.dev.kobj);
 
 	priv->vbus.sg.enabled = false;
-	priv->vbus.rx_ops = &venettap_flat_rx_ops;
+	priv->vbus.rx_ops = &venetdev_flat_rx_ops;
 	priv->vbus.sg.len = 0;
 
 	if (priv->vbus.pmtd.shm)
@@ -1402,145 +1334,6 @@ venettap_vlink_release(struct vbus_connection *conn)
 	priv->vbus.pmtd.enabled = false;
 }
 
-static struct vbus_connection_ops venettap_vbus_link_ops = {
-	.call    = venettap_vlink_call,
-	.shm     = venettap_vlink_shm,
-	.close   = venettap_vlink_close,
-	.release = venettap_vlink_release,
-};
-
-/*
- * This is called whenever a driver wants to open our device_interface
- * for communication.  The connection is represented by a
- * vbus_connection object.  It is up to the implementation to decide
- * if it allows more than one connection at a time.  This simple example
- * does not.
- */
-static int
-venettap_intf_connect(struct vbus_device_interface *intf,
-		   struct vbus_memctx *ctx,
-		   int version,
-		   struct vbus_connection **conn)
-{
-	struct venettap *priv = intf_to_priv(intf);
-	unsigned long flags;
-
-	PDEBUG("connect\n");
-
-	if (version != VENET_VERSION)
-		return -EINVAL;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	/*
-	 * We only allow one connection to this device
-	 */
-	if (priv->vbus.opened) {
-		spin_unlock_irqrestore(&priv->lock, flags);
-		return -EBUSY;
-	}
-
-	kobject_get(intf->dev->kobj);
-
-	vbus_connection_init(&priv->vbus.conn, &venettap_vbus_link_ops);
-
-	priv->vbus.opened = true;
-	priv->vbus.ctx = ctx;
-
-	vbus_memctx_get(ctx);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	*conn = &priv->vbus.conn;
-
-	return 0;
-}
-
-static void
-venettap_intf_release(struct vbus_device_interface *intf)
-{
-	kobject_put(intf->dev->kobj);
-}
-
-static struct vbus_device_interface_ops venettap_device_interface_ops = {
-	.connect = venettap_intf_connect,
-	.release = venettap_intf_release,
-};
-
-/*
- * This is called whenever the admin creates a symbolic link between
- * a bus in /config/vbus/buses and our device.  It represents a bus
- * connection.  Your device can chose to allow more than one bus to
- * connect, or it can restrict it to one bus.  It can also choose to
- * register one or more device_interfaces on each bus that it
- * successfully connects to.
- *
- * This example device only registers a single interface
- */
-static int
-venettap_device_bus_connect(struct vbus_device *dev, struct vbus *vbus)
-{
-	struct venettap *priv = vdev_to_priv(dev);
-	struct vbus_device_interface *intf = &priv->vbus.intf;
-
-	/* We only allow one bus to connect */
-	if (priv->vbus.connected)
-		return -EBUSY;
-
-	kobject_get(dev->kobj);
-
-	intf->name = "default";
-	intf->type = VENET_TYPE;
-	intf->ops = &venettap_device_interface_ops;
-
-	priv->vbus.connected = true;
-
-	/*
-	 * Our example only registers one interface.  If you need
-	 * more, simply call interface_register() multiple times
-	 */
-	return vbus_device_interface_register(dev, vbus, intf);
-}
-
-/*
- * This is called whenever the admin removes the symbolic link between
- * a bus in /config/vbus/buses and our device.
- */
-static int
-venettap_device_bus_disconnect(struct vbus_device *dev, struct vbus *vbus)
-{
-	struct venettap *priv = vdev_to_priv(dev);
-	struct vbus_device_interface *intf = &priv->vbus.intf;
-
-	if (!priv->vbus.connected)
-		return -EINVAL;
-
-	vbus_device_interface_unregister(intf);
-
-	priv->vbus.connected = false;
-	kobject_put(dev->kobj);
-
-	return 0;
-}
-
-static void
-venettap_device_release(struct vbus_device *dev)
-{
-	struct venettap *priv = vdev_to_priv(dev);
-
-	venettap_netdev_unregister(priv);
-	free_netdev(priv->netif.dev);
-}
-
-
-static struct vbus_device_ops venettap_device_ops = {
-	.bus_connect = venettap_device_bus_connect,
-	.bus_disconnect = venettap_device_bus_disconnect,
-	.release = venettap_device_release,
-};
-
-#define VENETTAP_TYPE "venet-tap"
-
 /*
  * Interface attributes show up as files under
  * /sys/vbus/devices/$devid
@@ -1549,12 +1342,12 @@ static ssize_t
 host_mac_show(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	 char *buf)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 
 	return sysfs_format_mac(buf, priv->hmac, ETH_ALEN);
 }
 
-static struct vbus_device_attribute attr_hmac =
+struct vbus_device_attribute attr_hmac =
 	__ATTR_RO(host_mac);
 
 
@@ -1562,7 +1355,7 @@ static ssize_t
 cmac_store(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	      const char *buf, size_t count)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 	const char *pbuf = buf;
 	unsigned int uc;
 	int i;
@@ -1594,19 +1387,19 @@ static ssize_t
 client_mac_show(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	 char *buf)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 
 	return sysfs_format_mac(buf, priv->cmac, ETH_ALEN);
 }
 
-static struct vbus_device_attribute attr_cmac =
+struct vbus_device_attribute attr_cmac =
 	__ATTR(client_mac, S_IRUGO | S_IWUSR, client_mac_show, cmac_store);
 
 static ssize_t
 enabled_show(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	 char *buf)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%d\n", priv->netif.enabled);
 }
@@ -1615,7 +1408,7 @@ static ssize_t
 enabled_store(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	      const char *buf, size_t count)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 	int enabled = -1;
 	int ret = 0;
 
@@ -1629,7 +1422,7 @@ enabled_store(struct vbus_device *dev, struct vbus_device_attribute *attr,
 		ret = register_netdev(priv->netif.dev);
 
 	if (!enabled && priv->netif.enabled)
-		venettap_netdev_unregister(priv);
+		venetdev_netdev_unregister(priv);
 
 	if (ret < 0)
 		return ret;
@@ -1639,14 +1432,14 @@ enabled_store(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	return count;
 }
 
-static struct vbus_device_attribute attr_enabled =
+struct vbus_device_attribute attr_enabled =
 	__ATTR(enabled, S_IRUGO | S_IWUSR, enabled_show, enabled_store);
 
 static ssize_t
 burstthresh_show(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	      char *buf)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%d\n", priv->burst.thresh);
 }
@@ -1655,7 +1448,7 @@ static ssize_t
 burstthresh_store(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	       const char *buf, size_t count)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 	int val = -1;
 
 	if (count > 0)
@@ -1667,14 +1460,14 @@ burstthresh_store(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	return count;
 }
 
-static struct vbus_device_attribute attr_burstthresh =
+struct vbus_device_attribute attr_burstthresh =
 	__ATTR(burstthresh, S_IRUGO | S_IWUSR, burstthresh_show, burstthresh_store);
 
 static ssize_t
 txmitigation_show(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	      char *buf)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%d\n", priv->txmitigation);
 }
@@ -1683,7 +1476,7 @@ static ssize_t
 txmitigation_store(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	       const char *buf, size_t count)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 	int val = -1;
 
 	if (count > 0)
@@ -1695,14 +1488,14 @@ txmitigation_store(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	return count;
 }
 
-static struct vbus_device_attribute attr_txmitigation =
+struct vbus_device_attribute attr_txmitigation =
 	__ATTR(txmitigation, S_IRUGO | S_IWUSR, txmitigation_show, txmitigation_store);
 
-static ssize_t
+ssize_t
 ifname_show(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	   char *buf)
 {
-	struct venettap *priv = vdev_to_priv(dev);
+	struct venetdev *priv = vdev_to_priv(dev);
 
 	if (!priv->netif.enabled)
 		return sprintf(buf, "<disabled>\n");
@@ -1710,109 +1503,6 @@ ifname_show(struct vbus_device *dev, struct vbus_device_attribute *attr,
 	return snprintf(buf, PAGE_SIZE, "%s\n", priv->netif.dev->name);
 }
 
-static struct vbus_device_attribute attr_ifname =
+struct vbus_device_attribute attr_ifname =
 	__ATTR_RO(ifname);
 
-static struct attribute *attrs[] = {
-	&attr_hmac.attr,
-	&attr_cmac.attr,
-	&attr_enabled.attr,
-	&attr_burstthresh.attr,
-	&attr_txmitigation.attr,
-	&attr_ifname.attr,
-	NULL,
-};
-
-static struct attribute_group venettap_attr_group = {
-	.attrs = attrs,
-};
-
-static struct net_device_ops venettap_netdev_ops = {
-	.ndo_open        = venettap_netdev_open,
-	.ndo_stop        = venettap_netdev_stop,
-	.ndo_set_config  = venettap_netdev_config,
-	.ndo_change_mtu  = venettap_change_mtu,
-	.ndo_start_xmit  = venettap_netdev_tx,
-	.ndo_do_ioctl    = venettap_netdev_ioctl,
-	.ndo_get_stats   = venettap_netdev_stats,
-};
-
-/*
- * This is called whenever the admin instantiates our devclass via
- * "mkdir /config/vbus/devices/$(inst)/venet-tap"
- */
-static int
-venettap_device_create(struct vbus_devclass *dc,
-		       struct vbus_device **vdev)
-{
-	struct net_device *dev;
-	struct venettap *priv;
-	struct vbus_device *_vdev;
-
-	dev = alloc_etherdev(sizeof(struct venettap));
-	if (!dev)
-		return -ENOMEM;
-
-	priv = netdev_priv(dev);
-	memset(priv, 0, sizeof(*priv));
-
-	spin_lock_init(&priv->lock);
-	random_ether_addr(priv->hmac);
-	random_ether_addr(priv->cmac);
-
-	/*
-	 * vbus init
-	 */
-	_vdev = &priv->vbus.dev;
-
-	_vdev->type            = VENETTAP_TYPE;
-	_vdev->ops             = &venettap_device_ops;
-	_vdev->attrs           = &venettap_attr_group;
-
-	priv->vbus.rx_ops      = &venettap_flat_rx_ops;
-	init_waitqueue_head(&priv->vbus.rx_empty);
-	priv->burst.thresh     = 0; /* microseconds, 0 = disabled */
-	priv->txmitigation     = 10; /* nr-packets, 0 = disabled */
-
-	/*
-	 * netif init
-	 */
-	skb_queue_head_init(&priv->netif.txq.list);
-	priv->netif.txq.len = 0;
-
-	priv->netif.dev = dev;
-
-	ether_setup(dev); /* assign some of the fields */
-
-	dev->netdev_ops = &venettap_netdev_ops;
-	memcpy(dev->dev_addr, priv->hmac, ETH_ALEN);
-
-	dev->features |= NETIF_F_HIGHDMA;
-
-	*vdev = _vdev;
-
-	return 0;
-}
-
-static struct vbus_devclass_ops venettap_devclass_ops = {
-	.create = venettap_device_create,
-};
-
-static struct vbus_devclass venettap_devclass = {
-	.name = VENETTAP_TYPE,
-	.ops = &venettap_devclass_ops,
-	.owner = THIS_MODULE,
-};
-
-static int __init venettap_init(void)
-{
-	return vbus_devclass_register(&venettap_devclass);
-}
-
-static void __exit venettap_cleanup(void)
-{
-	vbus_devclass_unregister(&venettap_devclass);
-}
-
-module_init(venettap_init);
-module_exit(venettap_cleanup);
diff --git a/kernel/vbus/devices/venet/tap.c b/kernel/vbus/devices/venet/tap.c
new file mode 100644
index 0000000..44b8827
--- /dev/null
+++ b/kernel/vbus/devices/venet/tap.c
@@ -0,0 +1,290 @@
+/*
+ * venettap - A 802.x virtual network device based on the VBUS/IOQ interface
+ *
+ * Copyright (C) 2009 Novell, Gregory Haskins <ghaskins@novell.com>
+ *
+ * Derived from the SNULL example from the book "Linux Device Drivers" by
+ * Alessandro Rubini, Jonathan Corbet, and Greg Kroah-Hartman, published
+ * by O'Reilly & Associates.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+
+#include <linux/in.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/ioq.h>
+#include <linux/vbus.h>
+#include <linux/freezer.h>
+#include <linux/kthread.h>
+#include <linux/ktime.h>
+
+#include "venetdevice.h"
+
+#include <linux/in6.h>
+#include <asm/checksum.h>
+
+MODULE_AUTHOR("Gregory Haskins");
+MODULE_LICENSE("GPL");
+
+#undef PDEBUG             /* undef it, just in case */
+#ifdef VENETTAP_DEBUG
+#  define PDEBUG(fmt, args...) printk(KERN_DEBUG "venet-tap: " fmt, ## args)
+#else
+#  define PDEBUG(fmt, args...) /* not debugging: nothing */
+#endif
+
+static struct vbus_connection_ops venettap_vbus_link_ops = {
+	.call    = venetdev_vlink_call,
+	.shm     = venetdev_vlink_shm,
+	.close   = venetdev_vlink_close,
+	.release = venetdev_vlink_release,
+};
+
+/*
+ * This is called whenever a driver wants to open our device_interface
+ * for communication.  The connection is represented by a
+ * vbus_connection object.  It is up to the implementation to decide
+ * if it allows more than one connection at a time.  This simple example
+ * does not.
+ */
+
+static int
+venettap_intf_connect(struct vbus_device_interface *intf,
+		   struct vbus_memctx *ctx,
+		   int version,
+		   struct vbus_connection **conn)
+{
+	struct venetdev *priv = intf_to_priv(intf);
+	unsigned long flags;
+
+	PDEBUG("connect\n");
+
+	if (version != VENET_VERSION)
+		return -EINVAL;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	/*
+	 * We only allow one connection to this device
+	 */
+	if (priv->vbus.opened) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return -EBUSY;
+	}
+
+	kobject_get(intf->dev->kobj);
+
+	vbus_connection_init(&priv->vbus.conn, &venettap_vbus_link_ops);
+
+	priv->vbus.opened = true;
+	priv->vbus.ctx = ctx;
+
+	vbus_memctx_get(ctx);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	*conn = &priv->vbus.conn;
+
+	return 0;
+}
+
+static void
+venettap_intf_release(struct vbus_device_interface *intf)
+{
+	kobject_put(intf->dev->kobj);
+}
+
+static struct vbus_device_interface_ops venettap_device_interface_ops = {
+	.connect = venettap_intf_connect,
+	.release = venettap_intf_release,
+};
+
+/*
+ * This is called whenever the admin creates a symbolic link between
+ * a bus in /config/vbus/buses and our device.  It represents a bus
+ * connection.  Your device can chose to allow more than one bus to
+ * connect, or it can restrict it to one bus.  It can also choose to
+ * register one or more device_interfaces on each bus that it
+ * successfully connects to.
+ *
+ * This example device only registers a single interface
+ */
+static int
+venettap_device_bus_connect(struct vbus_device *dev, struct vbus *vbus)
+{
+	struct venetdev *priv = vdev_to_priv(dev);
+	struct vbus_device_interface *intf = &priv->vbus.intf;
+
+	/* We only allow one bus to connect */
+	if (priv->vbus.connected)
+		return -EBUSY;
+
+	kobject_get(dev->kobj);
+
+	intf->name = "default";
+	intf->type = VENET_TYPE;
+	intf->ops = &venettap_device_interface_ops;
+
+	priv->vbus.connected = true;
+
+	/*
+	 * Our example only registers one interface.  If you need
+	 * more, simply call interface_register() multiple times
+	 */
+	return vbus_device_interface_register(dev, vbus, intf);
+}
+
+/*
+ * This is called whenever the admin removes the symbolic link between
+ * a bus in /config/vbus/buses and our device.
+ */
+static int
+venettap_device_bus_disconnect(struct vbus_device *dev, struct vbus *vbus)
+{
+	struct venetdev *priv = vdev_to_priv(dev);
+	struct vbus_device_interface *intf = &priv->vbus.intf;
+
+	if (!priv->vbus.connected)
+		return -EINVAL;
+
+	vbus_device_interface_unregister(intf);
+
+	priv->vbus.connected = false;
+	kobject_put(dev->kobj);
+
+	return 0;
+}
+
+static void
+venettap_device_release(struct vbus_device *dev)
+{
+	struct venetdev *priv = vdev_to_priv(dev);
+
+	venetdev_netdev_unregister(priv);
+	free_netdev(priv->netif.dev);
+}
+
+
+static struct vbus_device_ops venettap_device_ops = {
+	.bus_connect = venettap_device_bus_connect,
+	.bus_disconnect = venettap_device_bus_disconnect,
+	.release = venettap_device_release,
+};
+
+#define VENETTAP_TYPE "venet-tap"
+
+static struct attribute *attrs[] = {
+	&attr_hmac.attr,
+	&attr_cmac.attr,
+	&attr_enabled.attr,
+	&attr_burstthresh.attr,
+	&attr_txmitigation.attr,
+	&attr_ifname.attr,
+	NULL,
+};
+
+static struct attribute_group venettap_attr_group = {
+	.attrs = attrs,
+};
+
+static struct net_device_ops venettap_netdev_ops = {
+	.ndo_open        = venetdev_netdev_open,
+	.ndo_stop        = venetdev_netdev_stop,
+	.ndo_set_config  = venetdev_netdev_config,
+	.ndo_change_mtu  = venetdev_change_mtu,
+	.ndo_start_xmit  = venetdev_netdev_tx,
+	.ndo_do_ioctl    = venetdev_netdev_ioctl,
+	.ndo_get_stats   = venetdev_netdev_stats,
+};
+
+/*
+ * This is called whenever the admin instantiates our devclass via
+ * "mkdir /config/vbus/devices/$(inst)/venet-tap"
+ */
+static int
+venettap_device_create(struct vbus_devclass *dc,
+		       struct vbus_device **vdev)
+{
+	struct net_device *dev;
+	struct venetdev *priv;
+	struct vbus_device *_vdev;
+
+	dev = alloc_etherdev(sizeof(struct venetdev));
+	if (!dev)
+		return -ENOMEM;
+
+	priv = netdev_priv(dev);
+	memset(priv, 0, sizeof(*priv));
+
+	spin_lock_init(&priv->lock);
+	random_ether_addr(priv->hmac);
+	random_ether_addr(priv->cmac);
+
+	/*
+	 * vbus init
+	 */
+	_vdev = &priv->vbus.dev;
+
+	_vdev->type            = VENETTAP_TYPE;
+	_vdev->ops             = &venettap_device_ops;
+	_vdev->attrs           = &venettap_attr_group;
+
+	venetdev_init(priv, dev);
+
+	dev->netdev_ops = &venettap_netdev_ops;
+
+	*vdev = _vdev;
+
+	return 0;
+}
+
+static struct vbus_devclass_ops venettap_devclass_ops = {
+	.create = venettap_device_create,
+};
+
+static struct vbus_devclass venettap_devclass = {
+	.name = VENETTAP_TYPE,
+	.ops = &venettap_devclass_ops,
+	.owner = THIS_MODULE,
+};
+
+static int __init venettap_init(void)
+{
+	return vbus_devclass_register(&venettap_devclass);
+}
+
+static void __exit venettap_cleanup(void)
+{
+	vbus_devclass_unregister(&venettap_devclass);
+}
+
+module_init(venettap_init);
+module_exit(venettap_cleanup);
+
diff --git a/kernel/vbus/devices/venet/venetdevice.h b/kernel/vbus/devices/venet/venetdevice.h
new file mode 100644
index 0000000..2a32e5a
--- /dev/null
+++ b/kernel/vbus/devices/venet/venetdevice.h
@@ -0,0 +1,151 @@
+
+/*
+ * Copyright 2009 Novell.  All Rights Reserved.
+ *
+ * Virtual-Ethernet adapter
+ *
+ * Author:
+ *      Gregory Haskins <ghaskins@novell.com>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _LINUX_VENETDEVICE_H
+#define _LINUX_VENETDEVICE_H
+
+#include <linux/venet.h>
+
+struct venetdev_queue {
+	struct ioq              *queue;
+	struct ioq_notifier      notifier;
+};
+
+struct venetdev;
+
+struct venetdev_rx_ops {
+	int (*decode)(struct venetdev *priv, void *ptr, int len);
+	int (*import)(struct venetdev *, struct sk_buff *, void *, int);
+};
+
+#define MAX_VSG_DESC_SIZE VSG_DESC_SIZE(MAX_SKB_FRAGS)
+
+enum {
+	RX_SCHED,
+	TX_SCHED,
+	TX_NETIF_CONGESTED,
+	TX_IOQ_CONGESTED,
+};
+
+struct venetdev {
+	spinlock_t                   lock;
+	unsigned char                hmac[ETH_ALEN]; /* host-mac */
+	unsigned char                cmac[ETH_ALEN]; /* client-mac */
+	struct task_struct          *rxthread;
+	struct task_struct          *txthread;
+	unsigned long                flags;
+
+	struct {
+		struct net_device           *dev;
+		struct net_device_stats      stats;
+		int (*out)(struct venetdev *, struct sk_buff *);
+		struct {
+			struct sk_buff_head  list;
+			size_t               len;
+			int                  irqdepth;
+		} txq;
+		int                          enabled:1;
+		int                          link:1;
+	} netif;
+
+	struct {
+		struct vbus_device           dev;
+		struct vbus_device_interface intf;
+		struct vbus_connection       conn;
+		struct vbus_memctx          *ctx;
+		struct venetdev_queue        rxq;
+		struct venetdev_queue        txq;
+		struct venetdev_rx_ops      *rx_ops;
+		wait_queue_head_t            rx_empty;
+		struct {
+			char                 buf[MAX_VSG_DESC_SIZE];
+			size_t               len;
+			int                  enabled:1;
+		} sg;
+		struct {
+			struct vbus_shm     *shm;
+			int                  enabled:1;
+		} pmtd;
+		int                          connected:1;
+		int                          opened:1;
+		int                          link:1;
+	} vbus;
+
+	struct {
+		int                          thresh;
+		ktime_t                      expires;
+	} burst;
+	int                                  txmitigation;
+
+};
+
+static inline struct venetdev *conn_to_priv(struct vbus_connection *conn)
+{
+	return container_of(conn, struct venetdev, vbus.conn);
+}
+
+static inline struct venetdev *intf_to_priv(struct vbus_device_interface *intf)
+{
+	return container_of(intf, struct venetdev, vbus.intf);
+}
+
+static inline struct venetdev *vdev_to_priv(struct vbus_device *vdev)
+{
+	return container_of(vdev, struct venetdev, vbus.dev);
+}
+
+int venetdev_netdev_open(struct net_device *dev);
+int venetdev_netdev_stop(struct net_device *dev);
+int venetdev_netdev_config(struct net_device *dev, struct ifmap *map);
+int venetdev_change_mtu(struct net_device *dev, int new_mtu);
+int venetdev_netdev_tx(struct sk_buff *skb, struct net_device *dev);
+int venetdev_netdev_ioctl(struct net_device *dev, struct ifreq *rq,
+						   int cmd);
+struct net_device_stats *venetdev_netdev_stats(struct net_device *dev);
+
+static inline void venetdev_netdev_unregister(struct venetdev *priv)
+{
+	if (priv->netif.enabled) {
+		venetdev_netdev_stop(priv->netif.dev);
+		unregister_netdev(priv->netif.dev);
+	}
+}
+
+int venetdev_vlink_call(struct vbus_connection *conn,
+		    unsigned long func, void *data, unsigned long len,
+		    unsigned long flags);
+int venetdev_vlink_shm(struct vbus_connection *conn,
+		   unsigned long id, struct vbus_shm *shm,
+		   struct shm_signal *signal, unsigned long flags);
+void  venetdev_vlink_release(struct vbus_connection *conn);
+void  venetdev_vlink_close(struct vbus_connection *conn);
+void venetdev_init(struct venetdev *vdev, struct net_device *dev);
+
+extern struct vbus_device_attribute attr_cmac;
+extern struct vbus_device_attribute attr_hmac;
+extern struct vbus_device_attribute attr_enabled;
+extern struct vbus_device_attribute attr_burstthresh;
+extern struct vbus_device_attribute attr_ifname;
+extern struct vbus_device_attribute attr_txmitigation;
+
+#endif
-- 
1.6.5.2

