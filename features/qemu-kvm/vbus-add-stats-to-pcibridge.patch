From 4b11a1f715ed180da1812d06bca3a794a19b5200 Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Tue, 29 Sep 2009 11:32:19 -0400
Subject: [PATCH 058/119] vbus: add stats to pcibridge

These stats will show up in $debugfs-mount-point/pci-to-vbus-bridge

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 drivers/vbus/pci-bridge.c |   77 +++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 77 insertions(+), 0 deletions(-)

diff --git a/drivers/vbus/pci-bridge.c b/drivers/vbus/pci-bridge.c
index f0ed51a..81f7cdd 100644
--- a/drivers/vbus/pci-bridge.c
+++ b/drivers/vbus/pci-bridge.c
@@ -22,6 +22,8 @@
 #include <linux/pci.h>
 #include <linux/mm.h>
 #include <linux/workqueue.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
 #include <linux/ioq.h>
 #include <linux/interrupt.h>
 #include <linux/vbus_driver.h>
@@ -42,6 +44,16 @@ struct vbus_pci {
 	struct vbus_pci_signals  *signals;
 	int                       irq;
 	int                       enabled:1;
+	struct {
+		struct dentry    *fs;
+		int               events;
+		int               qnotify;
+		int               qinject;
+		int               notify;
+		int               inject;
+		int               bridgecalls;
+		int               buscalls;
+	} stats;
 };
 
 static struct vbus_pci vbus_pci;
@@ -82,6 +94,8 @@ vbus_pci_bridgecall(unsigned long nr, void *data, unsigned long len)
 
 	spin_unlock_irqrestore(&vbus_pci.lock, flags);
 
+	vbus_pci.stats.bridgecalls++;
+
 	return ret;
 }
 
@@ -105,6 +119,8 @@ vbus_pci_buscall(unsigned long nr, void *data, unsigned long len)
 
 	preempt_enable();
 
+	vbus_pci.stats.buscalls++;
+
 	return ret;
 }
 
@@ -136,6 +152,10 @@ struct _signal {
 	u32                handle;
 	struct rb_node     node;
 	struct list_head   list;
+	struct {
+		int        notify;
+		int        inject;
+	} stats;
 };
 
 static struct _signal *
@@ -149,6 +169,8 @@ _signal_inject(struct shm_signal *signal)
 {
 	struct _signal *_signal = to_signal(signal);
 
+	vbus_pci.stats.inject++;
+	_signal->stats.inject++;
 	iowrite32(_signal->handle, &vbus_pci.signals->shmsignal);
 
 	return 0;
@@ -432,6 +454,8 @@ event_shmsignal(struct vbus_pci_handle_event *event)
 {
 	struct _signal *_signal = (struct _signal *)event->handle;
 
+	vbus_pci.stats.notify++;
+	_signal->stats.notify++;
 	_shm_signal_wakeup(&_signal->signal);
 }
 
@@ -571,6 +595,8 @@ eventq_wakeup(struct ioq_notifier *notifier)
 		/* Advance the in-use head */
 		ret = ioq_iter_pop(&iter, 0);
 		BUG_ON(ret < 0);
+
+		vbus_pci.stats.events++;
 	}
 
 	/* And let the south side know that we changed the queue */
@@ -585,6 +611,7 @@ static struct ioq_notifier eventq_notifier = {
 irqreturn_t
 eventq_intr(int irq, void *dev)
 {
+	vbus_pci.stats.qnotify++;
 	_shm_signal_wakeup(vbus_pci.eventq.signal);
 
 	return IRQ_HANDLED;
@@ -597,6 +624,8 @@ eventq_intr(int irq, void *dev)
 static int
 eventq_signal_inject(struct shm_signal *signal)
 {
+	vbus_pci.stats.qinject++;
+
 	/* The eventq uses the special-case handle=0 */
 	iowrite32(0, &vbus_pci.signals->eventq);
 
@@ -635,6 +664,11 @@ static struct ioq_ops eventq_ioq_ops = {
 static void
 vbus_pci_release(void)
 {
+#ifdef CONFIG_DEBUG_FS
+	if (vbus_pci.stats.fs)
+		debugfs_remove(vbus_pci.stats.fs);
+#endif
+
 	if (vbus_pci.irq > 0)
 		free_irq(vbus_pci.irq, NULL);
 
@@ -714,6 +748,39 @@ _ioq_init(size_t ringsize, struct ioq *ioq, struct ioq_ops *ops)
 	return 0;
 }
 
+#ifdef CONFIG_DEBUG_FS
+static int _debugfs_seq_show(struct seq_file *m, void *p)
+{
+#define P(F) \
+	seq_printf(m, "  .%-30s: %d\n", #F, (int)vbus_pci.stats.F)
+
+	P(events);
+	P(qnotify);
+	P(qinject);
+	P(notify);
+	P(inject);
+	P(bridgecalls);
+	P(buscalls);
+
+#undef P
+
+	return 0;
+}
+
+static int _debugfs_fops_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, _debugfs_seq_show, inode->i_private);
+}
+
+static const struct file_operations stat_fops = {
+	.open		= _debugfs_fops_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+#endif
+
 static int __devinit
 vbus_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
@@ -824,6 +891,16 @@ vbus_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto out_fail;
 	}
 
+#ifdef CONFIG_DEBUG_FS
+	vbus_pci.stats.fs = debugfs_create_file(VBUS_PCI_NAME, S_IRUGO,
+						NULL, NULL, &stat_fops);
+	if (IS_ERR(vbus_pci.stats.fs)) {
+		ret = PTR_ERR(vbus_pci.stats.fs);
+		printk(KERN_ERR "VBUS_PCI: error creating stats-fs: %d\n", ret);
+		goto out_fail;
+	}
+#endif
+
 	vbus_pci.enabled = true;
 
 	printk(KERN_INFO "Virtual-Bus: Copyright (c) 2009, " \
-- 
1.6.5.2

