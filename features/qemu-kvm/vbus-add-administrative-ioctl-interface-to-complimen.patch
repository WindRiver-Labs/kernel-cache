From 93eef2b9d6377e7e4b119622dfe60e7494e80c34 Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Thu, 5 Nov 2009 09:35:17 -0500
Subject: [PATCH 080/119] vbus: add administrative ioctl interface to compliment configfs

This creates a new /dev/vbus-admin inode for controlling some
rudimentary elements of a virtual-bus configuration.  The idea
is that this inode can be assigned to a particular gid, and that
gid would then be authorized to create/manage vbus containers.

This buys us two things over the existing configfs interface:

1) Non-root users may now be granted rights to create vbus containers

2) The containers have a lifetime associated with the creator (i.e.
   auto-cleanup)

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 include/linux/vbus_admin.h |   58 +++++++++
 kernel/vbus/Makefile       |    2 +-
 kernel/vbus/config-ioctl.c |  282 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 341 insertions(+), 1 deletions(-)
 create mode 100644 include/linux/vbus_admin.h
 create mode 100644 kernel/vbus/config-ioctl.c

diff --git a/include/linux/vbus_admin.h b/include/linux/vbus_admin.h
new file mode 100644
index 0000000..febd3eb
--- /dev/null
+++ b/include/linux/vbus_admin.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2009 Novell.  All Rights Reserved.
+ *
+ * Virtual-Bus Administrative Interface
+ *
+ * Author:
+ *      Gregory Haskins <ghaskins@novell.com>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _LINUX_VBUS_ADMIN_H
+#define _LINUX_VBUS_ADMIN_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#define VBUS_ADMIN_MAGIC 0xdf39ab56
+#define VBUS_ADMIN_VERSION 1
+
+struct vbus_admin_negotiate {
+	__u32 magic;
+	__u32 version;
+	__u64 capabilities;
+};
+
+struct vbus_admin_userbuf {
+	__u64 ptr;
+	__u32 len;
+};
+
+struct vbus_admin_dev_create {
+	__u32                     flags;     /* in */
+	__u64                     type;      /* char* in */
+	struct vbus_admin_userbuf name;      /* char* out */
+	__u8                      pad[36];
+};
+
+#define VBUS_ADMIN_IOCTL_MAGIC 'V'
+
+#define VBUS_ADMIN_NEGOTIATE \
+  _IOWR(VBUS_ADMIN_IOCTL_MAGIC, 0x00, struct vbus_admin_negotiate)
+#define VBUS_ADMIN_DEV_CREATE \
+  _IOW(VBUS_ADMIN_IOCTL_MAGIC, 0x01, struct vbus_admin_dev_create)
+
+
+#endif /* _LINUX_VBUS_ADMIN_H */
diff --git a/kernel/vbus/Makefile b/kernel/vbus/Makefile
index 65ff938..b6939fb 100644
--- a/kernel/vbus/Makefile
+++ b/kernel/vbus/Makefile
@@ -1,5 +1,5 @@
 obj-$(CONFIG_VBUS) += core.o devclass.o config-fs.o attribute.o map.o client.o
-obj-$(CONFIG_VBUS) += shm-ioq.o
+obj-$(CONFIG_VBUS) += shm-ioq.o config-ioctl.o
 
 obj-y += devices/
 obj-y += connectors/
diff --git a/kernel/vbus/config-ioctl.c b/kernel/vbus/config-ioctl.c
new file mode 100644
index 0000000..307fec9
--- /dev/null
+++ b/kernel/vbus/config-ioctl.c
@@ -0,0 +1,282 @@
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/random.h>
+#include <linux/vbus.h>
+#include <linux/vbus_admin.h>
+
+#include "vbus.h"
+
+#define MAX_BUS_NAME 256
+#define MAX_DEV_NAME (MAX_BUS_NAME + 256)
+
+struct vbus_admin {
+	struct mutex lock;
+	struct vbus *bus;
+	unsigned char name[MAX_BUS_NAME];
+	struct list_head devs;
+	unsigned long devindex;
+};
+
+struct _device {
+	unsigned char         name[MAX_DEV_NAME];
+	struct vbus_devshell *ds;
+	struct list_head      list;
+};
+
+#define remain(buf, pos) (sizeof(buf) - (pos - buf))
+
+static int
+vbus_admin_chardev_open(struct inode *inode, struct file *filp)
+{
+	struct vbus *vbus = task_vbus_get(current);
+	struct vbus_admin *vadmin;
+	unsigned char uuid[16];
+	unsigned char *buf;
+	int i;
+	int ret;
+
+	if (vbus) {
+		vbus_put(vbus);
+		return -EEXIST;
+	}
+
+	vadmin = kzalloc(sizeof(*vadmin), GFP_KERNEL);
+	if (!vadmin)
+		return -ENOMEM;
+
+	mutex_init(&vadmin->lock);
+	INIT_LIST_HEAD(&vadmin->devs);
+
+	buf = vadmin->name;
+
+	generate_random_uuid(uuid);
+
+	buf += scnprintf(buf, remain(vadmin->name, buf),
+			 "%s-%d-", current->comm, current->pid);
+
+	for (i = 0; i < 16; i++) {
+		buf += scnprintf(buf, remain(vadmin->name, buf),
+				"%02x", uuid[i]);
+		if (i == 3 || i == 5 || i == 7 || i == 9)
+			buf += strlcpy(buf, "-", remain(vadmin->name, buf));
+	}
+
+	ret = vbus_create(vadmin->name, &vbus);
+	if (ret < 0)
+		goto fail;
+
+	ret = vbus_associate(vbus, current);
+	if (ret < 0)
+		goto fail;
+
+	rcu_assign_pointer(current->vbus, vbus);
+
+	vadmin->bus = vbus;
+	filp->private_data = vadmin;
+
+	return 0;
+
+fail:
+	if (vbus)
+		vbus_put(vbus);
+
+	kfree(vadmin);
+
+	return ret;
+}
+
+static int
+_negotiate_ioctl(struct vbus_admin *vadmin, struct vbus_admin_negotiate *args)
+{
+	if (args->magic != VBUS_ADMIN_MAGIC)
+		return -EINVAL;
+
+	if (args->version != VBUS_ADMIN_VERSION)
+		return -EINVAL;
+
+	/*
+	 * We have no extended capabilities yet, so we dont care if they set
+	 * any option bits.  Just clear them all.
+	 */
+	args->capabilities = 0;
+
+	return 0;
+}
+
+static int
+_dev_create_ioctl(struct vbus_admin *vadmin,
+		  struct vbus_admin_dev_create *args)
+{
+	struct vbus_devclass *dc;
+	struct vbus_devshell *ds = NULL;
+	struct vbus_device *dev = NULL;
+	struct _device *_dev = NULL;
+	char type[128];
+	int ret;
+	size_t namelen;
+
+	if (strnlen_user((void *)args->type, sizeof(type)) > sizeof(type))
+		return -EINVAL;
+
+	ret = strncpy_from_user(type, (void *)args->type, sizeof(type));
+	if (ret < 0)
+		return ret;
+
+	dc = vbus_devclass_find(type);
+	if (!dc)
+		return -ENOENT;
+
+	ret = dc->ops->create(dc, &dev);
+	if (ret < 0)
+		goto out;
+
+	_dev = kzalloc(sizeof(*_dev), GFP_KERNEL);
+	if (!_dev) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mutex_lock(&vadmin->lock);
+
+	namelen = snprintf(_dev->name, sizeof(_dev->name), "%s-%s-%ld",
+			   vadmin->name, type, vadmin->devindex++);
+
+	if (args->name.ptr) {
+
+		if (args->name.len <= namelen) {
+			args->name.len = namelen+1;
+			ret = -EINVAL;
+			goto out;
+		}
+
+		if (!access_ok(VERIFY_WRITE, args->name.ptr, namelen)) {
+			ret = -EFAULT;
+			goto out;
+		}
+	}
+
+	ret = vbus_devshell_create(_dev->name, &ds);
+	if (ret < 0)
+		goto out;
+
+	_dev->ds  = ds;
+	ds->dev   = dev;
+	ds->dc    = dc;
+	dev->kobj = &ds->kobj;
+
+	ret = vbus_devshell_type_set(ds);
+	if (ret < 0)
+		goto out;
+
+	ret = dev->ops->bus_connect(dev, vadmin->bus);
+	if (ret < 0)
+		goto out;
+
+	list_add_tail(&_dev->list, &vadmin->devs);
+
+	if (args->name.ptr) {
+		ret = copy_to_user((void *)args->name.ptr, _dev->name,
+				   namelen+1);
+		if (ret) {
+			ret = -EFAULT;
+			goto out;
+		}
+
+		args->name.len = namelen;
+	}
+
+	mutex_unlock(&vadmin->lock);
+
+	return 0;
+
+out:
+	mutex_unlock(&vadmin->lock);
+
+	if (ds)
+		kobject_put(&ds->kobj);
+	else if (dev)
+		dev->ops->release(dev);
+
+	if (dc)
+		vbus_devclass_put(dc);
+
+	return ret;
+}
+
+static ssize_t
+vbus_admin_chardev_ioctl(struct file *filp, unsigned int ioctl,
+			 unsigned long arg)
+{
+	struct vbus_admin *vadmin = filp->private_data;
+
+	switch (ioctl) {
+	case VBUS_ADMIN_NEGOTIATE:
+		return _negotiate_ioctl(vadmin,
+					(struct vbus_admin_negotiate *)arg);
+	case VBUS_ADMIN_DEV_CREATE:
+		return _dev_create_ioctl(vadmin,
+					(struct vbus_admin_dev_create *)arg);
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+vbus_admin_chardev_release(struct inode *inode, struct file *filp)
+{
+	struct vbus_admin *vadmin = filp->private_data;
+	struct _device *_dev, *tmp;
+
+	/* Unlink and release each created device */
+	list_for_each_entry_safe(_dev, tmp, &vadmin->devs, list) {
+		struct vbus_devshell *ds = _dev->ds;
+		struct vbus_device *dev = ds->dev;
+
+		dev->ops->bus_disconnect(dev, vadmin->bus);
+		kobject_put(&ds->kobj);
+
+		if (ds->dc)
+			vbus_devclass_put(ds->dc);
+
+		list_del(&_dev->list);
+		kfree(_dev);
+	}
+
+	vbus_put(vadmin->bus);
+	kfree(vadmin);
+
+	return 0;
+}
+
+static const struct file_operations vbus_admin_chardev_ops = {
+	.open           = vbus_admin_chardev_open,
+	.unlocked_ioctl = vbus_admin_chardev_ioctl,
+	.compat_ioctl   = vbus_admin_chardev_ioctl,
+	.release        = vbus_admin_chardev_release,
+};
+
+static struct miscdevice vbus_admin_chardev = {
+	MISC_DYNAMIC_MINOR,
+	"vbus-admin",
+	&vbus_admin_chardev_ops,
+};
+
+static int __init
+vbus_admin_init(void)
+{
+	return misc_register(&vbus_admin_chardev);
+}
+
+static void __exit
+vbus_admin_cleanup(void)
+{
+	misc_deregister(&vbus_admin_chardev);
+}
+
+module_init(vbus_admin_init);
+module_exit(vbus_admin_cleanup);
-- 
1.6.5.2

