From 7c59a70ced119c51eac9088640e2c71d5cf83fd5 Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Thu, 13 Aug 2009 22:43:23 -0400
Subject: [PATCH 018/119] alacrityvm: incorporate review feedback

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
Integrated-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 MAINTAINERS                 |   31 +++++++++++++++
 drivers/net/vbus-enet.c     |   91 +++++++++++++++++++++----------------------
 drivers/vbus/pci-bridge.c   |   11 ++++-
 include/linux/vbus_device.h |   12 ++++-
 include/linux/vbus_kvm.h    |    1 -
 include/linux/vbus_pci.h    |    1 +
 kernel/vbus/kvm.c           |    1 +
 lib/Kconfig                 |    6 +-
 lib/ioq.c                   |    2 +-
 9 files changed, 99 insertions(+), 57 deletions(-)

diff --git a/MAINTAINERS b/MAINTAINERS
index 8f7d77e..c3cde3e 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -2994,6 +2994,12 @@ L:	linux-mips@linux-mips.org
 S:	Maintained
 F:	drivers/serial/ioc3_serial.c
 
+IOQ LIBRARY
+M:	Gregory Haskins <ghaskins@novell.com>
+S:	Maintained
+F:	include/linux/ioq.h
+F:	lib/ioq.c
+
 IP MASQUERADING
 M:	Juanjo Ciarlante <jjciarla@raiz.uncu.edu.ar>
 S:	Maintained
@@ -5051,6 +5057,16 @@ M:	Len Brown <lenb@kernel.org>
 L:	sfi-devel@simplefirmware.org
 W:	http://simplefirmware.org/
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-sfi-2.6.git
+
+SHM-SIGNAL LIBRARY
+M:	Gregory Haskins <ghaskins@novell.com>
+S:	Maintained
+F:	include/linux/shm_signal.h
+F:	lib/shm_signal.c
+
+SHPC HOTPLUG DRIVER
+M:	Kristen Carlson Accardi <kristen.c.accardi@intel.com>
+L:	linux-pci@vger.kernel.org
 S:	Supported
 F:	arch/x86/kernel/*sfi*
 F:	drivers/sfi/
@@ -5985,6 +6001,21 @@ S:	Maintained
 F:	Documentation/fb/uvesafb.txt
 F:	drivers/video/uvesafb.*
 
+VBUS
+M:	Gregory Haskins <ghaskins@novell.com>
+S:	Maintained
+F:	Documentation/vbus.txt
+F:	include/linux/vbus*
+F:	drivers/vbus/*
+F:	kernel/vbus/*
+
+VBUS ETHERNET DRIVER
+M:	Gregory Haskins <ghaskins@novell.com>
+S:	Maintained
+W:	http://developer.novell.com/wiki/index.php/AlacrityVM
+F:	include/linux/venet.h
+F:	drivers/net/vbus-enet.c
+
 VFAT/FAT/MSDOS FILESYSTEM
 M:	OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
 S:	Maintained
diff --git a/drivers/net/vbus-enet.c b/drivers/net/vbus-enet.c
index 7220f43..91c47a9 100644
--- a/drivers/net/vbus-enet.c
+++ b/drivers/net/vbus-enet.c
@@ -60,13 +60,7 @@ struct vbus_enet_priv {
 	struct vbus_enet_queue     rxq;
 	struct vbus_enet_queue     txq;
 	struct tasklet_struct      txtask;
-	struct {
-		int                sg:1;
-		int                tso:1;
-		int                ufo:1;
-		int                tso6:1;
-		int                ecn:1;
-	} flags;
+	bool                       sg;
 };
 
 static void vbus_enet_tx_reap(struct vbus_enet_priv *priv, int force);
@@ -212,7 +206,7 @@ tx_setup(struct vbus_enet_priv *priv)
 	int i;
 	int ret;
 
-	if (!priv->flags.sg)
+	if (!priv->sg)
 		/*
 		 * There is nothing to do for a ring that is not using
 		 * scatter-gather
@@ -258,7 +252,7 @@ tx_teardown(struct vbus_enet_priv *priv)
 	/* forcefully free all outstanding transmissions */
 	vbus_enet_tx_reap(priv, 1);
 
-	if (!priv->flags.sg)
+	if (!priv->sg)
 		/*
 		 * There is nothing else to do for a ring that is not using
 		 * scatter-gather
@@ -494,7 +488,7 @@ vbus_enet_tx_start(struct sk_buff *skb, struct net_device *dev)
 	BUG_ON(ret < 0);
 	BUG_ON(iter.desc->sown);
 
-	if (priv->flags.sg) {
+	if (priv->sg) {
 		struct venet_sg *vsg = (struct venet_sg *)iter.desc->cookie;
 		struct scatterlist sgl[MAX_SKB_FRAGS+1];
 		struct scatterlist *sg;
@@ -612,7 +606,7 @@ vbus_enet_tx_reap(struct vbus_enet_priv *priv, int force)
 	while (iter.desc->valid && (!iter.desc->sown || force)) {
 		struct sk_buff *skb;
 
-		if (priv->flags.sg) {
+		if (priv->sg) {
 			struct venet_sg *vsg;
 
 			vsg = (struct venet_sg *)iter.desc->cookie;
@@ -702,15 +696,17 @@ tx_isr(struct ioq_notifier *notifier)
 static int
 vbus_enet_negcap(struct vbus_enet_priv *priv)
 {
-	int ret;
+	struct net_device *dev = priv->dev;
 	struct venet_capabilities caps;
+	int ret;
 
 	memset(&caps, 0, sizeof(caps));
 
 	if (sg_enabled) {
 		caps.gid = VENET_CAP_GROUP_SG;
 		caps.bits |= (VENET_CAP_SG|VENET_CAP_TSO4|VENET_CAP_TSO6
-			      |VENET_CAP_ECN|VENET_CAP_UFO);
+			      |VENET_CAP_ECN);
+		/* note: exclude UFO for now due to stack bug */
 	}
 
 	ret = devcall(priv, VENET_FUNC_NEGCAP, &caps, sizeof(caps));
@@ -718,34 +714,49 @@ vbus_enet_negcap(struct vbus_enet_priv *priv)
 		return ret;
 
 	if (caps.bits & VENET_CAP_SG) {
-		priv->flags.sg = true;
+		priv->sg = true;
+
+		dev->features |= NETIF_F_SG|NETIF_F_HW_CSUM|NETIF_F_FRAGLIST;
 
 		if (caps.bits & VENET_CAP_TSO4)
-			priv->flags.tso = true;
-		if (caps.bits & VENET_CAP_TSO6)
-			priv->flags.tso6 = true;
+			dev->features |= NETIF_F_TSO;
 		if (caps.bits & VENET_CAP_UFO)
-			priv->flags.ufo = true;
+			dev->features |= NETIF_F_UFO;
+		if (caps.bits & VENET_CAP_TSO6)
+			dev->features |= NETIF_F_TSO6;
 		if (caps.bits & VENET_CAP_ECN)
-			priv->flags.ecn = true;
-
-		dev_info(&priv->dev->dev, "Detected GSO features %s%s%s%s\n",
-			 priv->flags.tso  ? "t" : "-",
-			 priv->flags.tso6 ? "T" : "-",
-			 priv->flags.ufo  ? "u" : "-",
-			 priv->flags.ecn  ? "e" : "-");
+			dev->features |= NETIF_F_TSO_ECN;
 	}
 
 	return 0;
 }
 
+static int vbus_enet_set_tx_csum(struct net_device *dev, u32 data)
+{
+	struct vbus_enet_priv *priv = netdev_priv(dev);
+
+	if (data && !priv->sg)
+		return -ENOSYS;
+
+	return ethtool_op_set_tx_hw_csum(dev, data);
+}
+
+static struct ethtool_ops vbus_enet_ethtool_ops = {
+	.set_tx_csum = vbus_enet_set_tx_csum,
+	.set_sg      = ethtool_op_set_sg,
+	.set_tso     = ethtool_op_set_tso,
+	.get_link    = ethtool_op_get_link,
+};
+
 static const struct net_device_ops vbus_enet_netdev_ops = {
-	.ndo_open          = vbus_enet_open,
-	.ndo_stop          = vbus_enet_stop,
-	.ndo_set_config    = vbus_enet_config,
-	.ndo_start_xmit    = vbus_enet_tx_start,
-	.ndo_change_mtu	   = vbus_enet_change_mtu,
-	.ndo_tx_timeout    = vbus_enet_timeout,
+	.ndo_open            = vbus_enet_open,
+	.ndo_stop            = vbus_enet_stop,
+	.ndo_set_config      = vbus_enet_config,
+	.ndo_start_xmit      = vbus_enet_tx_start,
+	.ndo_change_mtu	     = vbus_enet_change_mtu,
+	.ndo_tx_timeout      = vbus_enet_timeout,
+	.ndo_set_mac_address = eth_mac_addr,
+	.ndo_validate_addr   = eth_validate_addr,
 };
 
 /*
@@ -796,6 +807,8 @@ vbus_enet_probe(struct vbus_device_proxy *vdev)
 
 	dev->netdev_ops     = &vbus_enet_netdev_ops;
 	dev->watchdog_timeo = 5 * HZ;
+	SET_ETHTOOL_OPS(dev, &vbus_enet_ethtool_ops);
+	SET_NETDEV_DEV(dev, &vdev->dev);
 
 	netif_napi_add(dev, &priv->napi, vbus_enet_poll, 128);
 
@@ -809,22 +822,6 @@ vbus_enet_probe(struct vbus_device_proxy *vdev)
 
 	dev->features |= NETIF_F_HIGHDMA;
 
-	if (priv->flags.sg) {
-		dev->features |= NETIF_F_SG|NETIF_F_HW_CSUM|NETIF_F_FRAGLIST;
-
-		if (priv->flags.tso)
-			dev->features |= NETIF_F_TSO;
-
-		if (priv->flags.ufo)
-			dev->features |= NETIF_F_UFO;
-
-		if (priv->flags.tso6)
-			dev->features |= NETIF_F_TSO6;
-
-		if (priv->flags.ecn)
-			dev->features |= NETIF_F_TSO_ECN;
-	}
-
 	ret = register_netdev(dev);
 	if (ret < 0) {
 		printk(KERN_INFO "VENET: error %i registering device \"%s\"\n",
diff --git a/drivers/vbus/pci-bridge.c b/drivers/vbus/pci-bridge.c
index df93292..b21a9a3 100644
--- a/drivers/vbus/pci-bridge.c
+++ b/drivers/vbus/pci-bridge.c
@@ -630,7 +630,7 @@ vbus_pci_open(void)
 {
 	struct vbus_pci_negotiate params = {
 		.magic        = VBUS_PCI_ABI_MAGIC,
-		.version      = VBUS_PCI_ABI_VERSION,
+		.version      = VBUS_PCI_HC_VERSION,
 		.capabilities = 0,
 	};
 
@@ -693,6 +693,13 @@ vbus_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (vbus_pci.enabled)
 		return -EEXIST; /* we only support one bridge per kernel */
 
+	if (pdev->revision != VBUS_PCI_ABI_VERSION) {
+		printk(KERN_DEBUG "VBUS_PCI: expected ABI version %d, got %d\n",
+		       VBUS_PCI_ABI_VERSION,
+		       pdev->revision);
+		return -ENODEV;
+	}
+
 	vbus_pci.dev = pdev;
 
 	ret = pci_enable_device(pdev);
@@ -719,7 +726,7 @@ vbus_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	ret = vbus_pci_open();
 	if (ret < 0) {
-		printk(KERN_ERR "VBUS_PCI: Could not register with host: %d\n",
+		printk(KERN_DEBUG "VBUS_PCI: Could not register with host: %d\n",
 		       ret);
 		goto out_fail;
 	}
diff --git a/include/linux/vbus_device.h b/include/linux/vbus_device.h
index e45ab60..45dc104 100644
--- a/include/linux/vbus_device.h
+++ b/include/linux/vbus_device.h
@@ -282,9 +282,14 @@ struct vbus_memctx_ops {
 	void (*release)(struct vbus_memctx *ctx);
 };
 
+enum vbus_memctx_flag_bits {
+	VBUS_MEMCTX_ATOMIC,
+};
+
 struct vbus_memctx {
 	struct kref kref;
 	struct vbus_memctx_ops *ops;
+	unsigned long flags;
 };
 
 static inline void
@@ -295,9 +300,10 @@ vbus_memctx_init(struct vbus_memctx *ctx, struct vbus_memctx_ops *ops)
 	ctx->ops = ops;
 }
 
-#define VBUS_MEMCTX_INIT(_ops) {                                   \
-        .kref = { .refcount = ATOMIC_INIT(1), },         	   \
-	.ops = _ops,                                               \
+#define VBUS_MEMCTX_INIT(_ops) {			\
+	.kref = { .refcount = ATOMIC_INIT(1), },	\
+	.ops = _ops,					\
+	.flags = 0,					\
 }
 
 static inline void
diff --git a/include/linux/vbus_kvm.h b/include/linux/vbus_kvm.h
index 56e429d..1abc8d3 100644
--- a/include/linux/vbus_kvm.h
+++ b/include/linux/vbus_kvm.h
@@ -25,7 +25,6 @@
 
 #include <linux/ioctl.h>
 #include <linux/types.h>
-#include <linux/vbus_client.h>
 #include <linux/vbus_pci.h>
 
 #define VBUS_KVM_ABI_MAGIC 0x34f0ab23
diff --git a/include/linux/vbus_pci.h b/include/linux/vbus_pci.h
index 3177b40..e18ff59 100644
--- a/include/linux/vbus_pci.h
+++ b/include/linux/vbus_pci.h
@@ -28,6 +28,7 @@
 
 #define VBUS_PCI_ABI_MAGIC 0xbf53eef5
 #define VBUS_PCI_ABI_VERSION 1
+#define VBUS_PCI_HC_VERSION 1
 
 enum {
 	VBUS_PCI_HC_NEGOTIATE,
diff --git a/kernel/vbus/kvm.c b/kernel/vbus/kvm.c
index 5d5fd0e..3ac4433 100644
--- a/kernel/vbus/kvm.c
+++ b/kernel/vbus/kvm.c
@@ -12,6 +12,7 @@
 
 #include <linux/vbus.h>
 #include <linux/vbus_kvm.h>
+#include <linux/vbus_client.h>
 
 #include "vbus.h"
 
diff --git a/lib/Kconfig b/lib/Kconfig
index 1130486..5823d5d 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -211,7 +211,7 @@ config LRU_CACHE
 	tristate
 
 config SHM_SIGNAL
-	boolean "SHM Signal - Generic shared-memory signaling mechanism"
+	tristate "SHM Signal - Generic shared-memory signaling mechanism"
 	select EVENTFD
 	default n
 	help
@@ -221,13 +221,13 @@ config SHM_SIGNAL
 	 If unsure, say N
 
 config IOQ
-	boolean "IO-Queue library - Generic shared-memory queue"
+	tristate "IO-Queue library - Generic shared-memory queue"
 	select SHM_SIGNAL
 	default n
 	help
 	 IOQ is a generic shared-memory-queue mechanism that happens to be
 	 friendly to virtualization boundaries. It can be used in a variety
-	 of ways, though its intended purpose is to become the low-level
+	 of ways, though its intended purpose is to become a low-level
 	 communication path for paravirtualized drivers.
 
 	 If unsure, say N
diff --git a/lib/ioq.c b/lib/ioq.c
index 7699230..af3090f 100644
--- a/lib/ioq.c
+++ b/lib/ioq.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 Novell.  All Rights Reserved.
+ * Copyright 2009 Novell.  All Rights Reserved.
  *
  * See include/linux/ioq.h for documentation
  *
-- 
1.6.5.2

