From af34a440d5f19dcced5040a5d7ca1854daab2118 Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Thu, 8 Oct 2009 12:40:34 -0400
Subject: [PATCH 063/119] venetdev: support non-linear SKBs

Some transports will inject non-linear SKBs, so lets try to support them.

Note that this still requires that the SKB conforms to the MTU.

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 kernel/vbus/devices/venet/device.c |   46 ++++++++++++++++++++++++++++++++++-
 1 files changed, 44 insertions(+), 2 deletions(-)

diff --git a/kernel/vbus/devices/venet/device.c b/kernel/vbus/devices/venet/device.c
index 698eb60..1eb2306 100644
--- a/kernel/vbus/devices/venet/device.c
+++ b/kernel/vbus/devices/venet/device.c
@@ -1074,6 +1074,43 @@ venetdev_check_netif_congestion(struct venetdev *priv)
 }
 
 static int
+nonlinear_copy_to(struct vbus_memctx *ctx, void *dst, struct sk_buff *skb)
+{
+	struct scatterlist sgl[MAX_SKB_FRAGS+1];
+	struct scatterlist *sg;
+	int count, maxcount = ARRAY_SIZE(sgl);
+	int bytes = 0;
+	int i;
+	int ret;
+
+	sg_init_table(sgl, maxcount);
+
+	count = skb_to_sgvec(skb, sgl, 0, skb->len);
+	BUG_ON(count > maxcount);
+
+	/* linearize the payload directly into the queue */
+	for_each_sg(sgl, sg, count, i) {
+		size_t len = sg->length;
+		void *src  = sg_virt(sg);
+
+		ret = ctx->ops->copy_to(ctx, dst, src, len);
+		if (ret)
+			break;
+
+		dst += len;
+		bytes += len;
+	}
+
+	return skb->len - bytes;
+}
+
+static int
+linear_copy_to(struct vbus_memctx *ctx, void *dst, struct sk_buff *skb)
+{
+	return ctx->ops->copy_to(ctx, dst, skb->data, skb->len);
+}
+
+static int
 venetdev_tx(struct venetdev *priv)
 {
 	struct sk_buff             *skb;
@@ -1125,8 +1162,13 @@ venetdev_tx(struct venetdev *priv)
 		PDEBUG("tx-thread: sending %d bytes\n", skb->len);
 
 		if (skb->len <= iter.desc->len) {
-			ret = ctx->ops->copy_to(ctx, (void *)iter.desc->ptr,
-					       skb->data, skb->len);
+			void *dst = (void *)iter.desc->ptr;
+
+			if (!skb_shinfo(skb)->nr_frags)
+				ret = linear_copy_to(ctx, dst, skb);
+			else
+				ret = nonlinear_copy_to(ctx, dst, skb);
+
 			if (!ret) {
 				iter.desc->len = skb->len;
 
-- 
1.6.5.2

