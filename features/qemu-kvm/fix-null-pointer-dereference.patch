From a948532783652ac3549574771322fb01f025cc20 Mon Sep 17 00:00:00 2001
From: Gleb Natapov <gleb@redhat.com>
Date: Sun, 17 Oct 2010 21:32:45 +0800
Subject: [PATCH] fix null pointer dereference

There is a bug in KVM that can be used to crash a host on Intel
machines. If emulator is tricked into emulating mov to/from DR instruction
it causes NULL pointer dereference on VMX since kvm_x86_ops->(set|get)_dr
are not initialized. Recently this is not exploitable from guest
userspace, but malicious guest kernel can trigger it easily.

rhev-h-2.2 BZ: 570533
RHEL5.5 BZ: 570531
RHEL5.6 BZ: 570532

Bugzilla: 570531
Acked-by: Zachary Amsden <zamsden@redhat.com>
Acked-by: Paolo Bonzini <pbonzini@redhat.com>
Acked-by: Juan Quintela <quintela@redhat.com>

Upstream status: embargoed.

Signed-off-by: Gleb Natapov <gleb@redhat.com>
Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
---
 arch/x86/kvm/x86.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index ab864dc..b52e825 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -3325,6 +3325,9 @@ int emulate_clts(struct kvm_vcpu *vcpu)
 
 int emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long *dest)
 {
+	if (!kvm_x86_ops->get_dr)
+		return X86EMUL_UNHANDLEABLE;
+
 	return kvm_x86_ops->get_dr(ctxt->vcpu, dr, dest);
 }
 
@@ -3332,6 +3335,9 @@ int emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr, unsigned long value)
 {
 	unsigned long mask = (ctxt->mode == X86EMUL_MODE_PROT64) ? ~0ULL : ~0U;
 
+	if (!kvm_x86_ops->set_dr)
+		return X86EMUL_UNHANDLEABLE;
+
 	return kvm_x86_ops->set_dr(ctxt->vcpu, dr, value & mask);
 }
 
-- 
1.6.5.2

