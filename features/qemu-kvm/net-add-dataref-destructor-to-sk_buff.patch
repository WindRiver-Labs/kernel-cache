From c843f9bf8776843393c2a7cb19becf2603e5945c Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Tue, 22 Sep 2009 23:22:23 -0400
Subject: [PATCH 047/119] net: add dataref destructor to sk_buff

The skb->destructor field is reportedly unreliable, yet we need this
notion for zero-copy support.  Therefore, we add a distinct ->release()
method for the shinfo structure which is closely tied to the underlying
page resources we want to protect.

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 include/linux/skbuff.h |    2 ++
 net/core/skbuff.c      |   11 +++++++++++
 2 files changed, 13 insertions(+), 0 deletions(-)

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 124f90c..518d46d 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -201,6 +201,8 @@ struct skb_shared_info {
 	/* Intermediate layers must ensure that destructor_arg
 	 * remains valid until skb destructor */
 	void *		destructor_arg;
+	void *          priv;
+	void           (*release)(struct sk_buff *skb);
 };
 
 /* We divide dataref into two halves.  The higher 16 bits hold references
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 93c4e06..01cf26a 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -219,6 +219,7 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 	shinfo->tx_flags.flags = 0;
 	skb_frag_list_init(skb);
 	memset(&shinfo->hwtstamps, 0, sizeof(shinfo->hwtstamps));
+	shinfo->release = NULL;
 
 	if (fclone) {
 		struct sk_buff *child = skb + 1;
@@ -350,6 +351,13 @@ static void skb_release_data(struct sk_buff *skb)
 		if (skb_has_frags(skb))
 			skb_drop_fraglist(skb);
 
+		if (skb_shinfo(skb)->release) {
+			skb_shinfo(skb)->release(skb);
+
+			skb_shinfo(skb)->release = NULL;
+			skb_shinfo(skb)->priv = NULL;
+		}
+
 		kfree(skb->head);
 	}
 }
@@ -517,6 +525,8 @@ int skb_recycle_check(struct sk_buff *skb, int skb_size)
 	shinfo->tx_flags.flags = 0;
 	skb_frag_list_init(skb);
 	memset(&shinfo->hwtstamps, 0, sizeof(shinfo->hwtstamps));
+	shinfo->release = NULL;
+	shinfo->priv = NULL;
 
 	memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb->data = skb->head + NET_SKB_PAD;
@@ -859,6 +869,7 @@ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,
 	skb->hdr_len  = 0;
 	skb->nohdr    = 0;
 	atomic_set(&skb_shinfo(skb)->dataref, 1);
+	skb_shinfo(skb)->release = NULL;
 	return 0;
 
 nodata:
-- 
1.6.5.2

