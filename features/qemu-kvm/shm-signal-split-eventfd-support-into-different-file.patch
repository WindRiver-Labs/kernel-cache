From 829a47b5bb7158c22684f361cb85f6372bd87d17 Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Mon, 23 Nov 2009 13:39:37 -0500
Subject: [PATCH 090/119] shm-signal: split eventfd support into different file

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 include/linux/shm_signal.h         |   12 ---
 include/linux/shm_signal_eventfd.h |   37 +++++++++
 kernel/vbus/connectors/kvm.c       |    2 +
 lib/Makefile                       |    1 +
 lib/shm_signal.c                   |  121 -----------------------------
 lib/shm_signal_eventfd.c           |  149 ++++++++++++++++++++++++++++++++++++
 6 files changed, 189 insertions(+), 133 deletions(-)
 create mode 100644 include/linux/shm_signal_eventfd.h
 create mode 100644 lib/shm_signal_eventfd.c

diff --git a/include/linux/shm_signal.h b/include/linux/shm_signal.h
index f31513b..b5a197b 100644
--- a/include/linux/shm_signal.h
+++ b/include/linux/shm_signal.h
@@ -57,7 +57,6 @@ struct shm_signal_desc {
 #ifdef __KERNEL__
 
 #include <linux/kref.h>
-#include <linux/eventfd.h>
 #include <linux/wait.h>
 #include <linux/poll.h>
 #include <linux/file.h>
@@ -188,17 +187,6 @@ int shm_signal_disable(struct shm_signal *s, int flags);
  **/
 int shm_signal_inject(struct shm_signal *s, int flags);
 
-/**
- * shm_signal_eventfd_bind() - Bind an eventfd to a SHM_SIGNAL
- * @s:        SHM_SIGNAL context
- *
- * Binds an eventfd to the shm_signal such that any signal to the eventfd
- * will trigger a notifier->signal() callback on the shm_signal.
- *
- **/
-int shm_signal_eventfd_bindfd(struct shm_signal *signal, int fd);
-int shm_signal_eventfd_bindfile(struct shm_signal *signal, struct file *file);
-
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_SHM_SIGNAL_H */
diff --git a/include/linux/shm_signal_eventfd.h b/include/linux/shm_signal_eventfd.h
new file mode 100644
index 0000000..a940b02
--- /dev/null
+++ b/include/linux/shm_signal_eventfd.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2009 Novell.  All Rights Reserved.
+ *
+ * Author:
+ *      Gregory Haskins <ghaskins@novell.com>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef _LINUX_SHM_SIGNAL_EVENTFD_H
+#define _LINUX_SHM_SIGNAL_EVENTFD_H
+
+#include <linux/shm_signal.h>
+
+/**
+ * shm_signal_eventfd_bind() - Bind an eventfd to a SHM_SIGNAL
+ * @s:        SHM_SIGNAL context
+ *
+ * Binds an eventfd to the shm_signal such that any signal to the eventfd
+ * will trigger a notifier->signal() callback on the shm_signal.
+ *
+ **/
+int shm_signal_eventfd_bindfd(struct shm_signal *signal, int fd);
+int shm_signal_eventfd_bindfile(struct shm_signal *signal, struct file *file);
+
+#endif /* _LINUX_SHM_SIGNAL_EVENTFD_H */
diff --git a/kernel/vbus/connectors/kvm.c b/kernel/vbus/connectors/kvm.c
index e0cee4b..54e650f 100644
--- a/kernel/vbus/connectors/kvm.c
+++ b/kernel/vbus/connectors/kvm.c
@@ -10,6 +10,8 @@
 #include <linux/module.h>
 #include <linux/kvm_host.h>
 #include <linux/kvm_xinterface.h>
+#include <linux/shm_signal_eventfd.h>
+#include <linux/eventfd.h>
 
 #include <linux/vbus.h>
 #include <linux/vbus_kvm.h>
diff --git a/lib/Makefile b/lib/Makefile
index d7448db..2d7cab6 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -83,6 +83,7 @@ obj-$(CONFIG_TEXTSEARCH_FSM) += ts_fsm.o
 obj-$(CONFIG_SMP) += percpu_counter.o
 obj-$(CONFIG_AUDIT_GENERIC) += audit.o
 obj-$(CONFIG_SHM_SIGNAL) += shm_signal.o
+obj-$(CONFIG_SHM_SIGNAL) += shm_signal_eventfd.o
 obj-$(CONFIG_IOQ) += ioq.o
 
 obj-$(CONFIG_SWIOTLB) += swiotlb.o
diff --git a/lib/shm_signal.c b/lib/shm_signal.c
index 552f601..5f20aa0 100644
--- a/lib/shm_signal.c
+++ b/lib/shm_signal.c
@@ -196,124 +196,3 @@ void shm_signal_init(struct shm_signal *s, enum shm_signal_locality locale,
 }
 EXPORT_SYMBOL_GPL(shm_signal_init);
 
-/*
- * ---------------------------------------------
- * eventfd interface
- *
- * Allows a shm_signal to be triggered using a pair of eventfds
- * ---------------------------------------------
- */
-
-struct _eventfd_signal {
-	struct eventfd_ctx            *eventfd;
-	struct shm_signal             *signal;
-	poll_table                     pt;
-	wait_queue_head_t             *wqh;
-	wait_queue_t                   wait;
-	struct work_struct             shutdown;
-};
-
-static void
-eventfd_signal_shutdown(struct work_struct *work)
-{
-	struct _eventfd_signal *_signal;
-
-	_signal = container_of(work, struct _eventfd_signal, shutdown);
-
-	shm_signal_put(_signal->signal);
-	eventfd_ctx_put(_signal->eventfd);
-	kfree(_signal);
-}
-
-/*
- * Called with wqh->lock held and interrupts disabled
- */
-static int
-eventfd_signal_wakeup(wait_queue_t *wait, unsigned mode, int sync, void *key)
-{
-	struct _eventfd_signal *_signal;
-	unsigned long flags = (unsigned long)key;
-
-	_signal = container_of(wait, struct _eventfd_signal, wait);
-
-	if (flags & POLLIN)
-		/* An event has been signaled */
-		_shm_signal_wakeup(_signal->signal);
-
-	if (flags & POLLHUP) {
-		/* The eventfd is closing, detach.. */
-		__remove_wait_queue(_signal->wqh, &_signal->wait);
-		schedule_work(&_signal->shutdown);
-	}
-
-	return 0;
-}
-
-static void
-eventfd_signal_ptable(struct file *file, wait_queue_head_t *wqh, poll_table *pt)
-{
-	struct _eventfd_signal *_signal;
-
-	_signal = container_of(pt, struct _eventfd_signal, pt);
-
-	_signal->wqh = wqh;
-	add_wait_queue(wqh, &_signal->wait);
-}
-
-int shm_signal_eventfd_bindfile(struct shm_signal *signal, struct file *file)
-{
-	struct _eventfd_signal *_signal;
-	struct eventfd_ctx *eventfd = NULL;
-	int ret = -EINVAL;
-
-	_signal = kzalloc(sizeof(*_signal), GFP_KERNEL);
-	if (!_signal)
-		return -ENOMEM;
-
-	eventfd = eventfd_ctx_fileget(file);
-	if (IS_ERR(eventfd)) {
-		ret = PTR_ERR(eventfd);
-		goto fail;
-	}
-
-	_signal->eventfd = eventfd;
-	_signal->signal  = signal;
-	INIT_WORK(&_signal->shutdown, eventfd_signal_shutdown);
-
-	init_waitqueue_func_entry(&_signal->wait, eventfd_signal_wakeup);
-	init_poll_funcptr(&_signal->pt, eventfd_signal_ptable);
-
-	file->f_op->poll(file, &_signal->pt);
-
-	return 0;
-
-fail:
-	if (eventfd && !IS_ERR(eventfd))
-		eventfd_ctx_put(eventfd);
-
-	kfree(_signal);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(shm_signal_eventfd_bindfile);
-
-int shm_signal_eventfd_bindfd(struct shm_signal *signal, int fd)
-{
-	struct file *file = NULL;
-	int ret = -EINVAL;
-
-	file = eventfd_fget(fd);
-	if (IS_ERR(file)) {
-		ret = PTR_ERR(file);
-		goto out;
-	}
-
-	ret = shm_signal_eventfd_bindfile(signal, file);
-
-out:
-	if (file && !IS_ERR(file))
-		fput(file);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(shm_signal_eventfd_bindfd);
diff --git a/lib/shm_signal_eventfd.c b/lib/shm_signal_eventfd.c
new file mode 100644
index 0000000..acfba46
--- /dev/null
+++ b/lib/shm_signal_eventfd.c
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2009 Novell.  All Rights Reserved.
+ *
+ * See include/linux/shm_signal.h for documentation
+ *
+ * Author:
+ *      Gregory Haskins <ghaskins@novell.com>
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/shm_signal.h>
+#include <linux/workqueue.h>
+#include <linux/eventfd.h>
+
+/*
+ * ---------------------------------------------
+ * eventfd interface
+ *
+ * Allows a shm_signal to be triggered using a pair of eventfds
+ * ---------------------------------------------
+ */
+
+struct _eventfd_signal {
+	struct eventfd_ctx            *eventfd;
+	struct shm_signal             *signal;
+	poll_table                     pt;
+	wait_queue_head_t             *wqh;
+	wait_queue_t                   wait;
+	struct work_struct             shutdown;
+};
+
+static void
+eventfd_signal_shutdown(struct work_struct *work)
+{
+	struct _eventfd_signal *_signal;
+
+	_signal = container_of(work, struct _eventfd_signal, shutdown);
+
+	shm_signal_put(_signal->signal);
+	eventfd_ctx_put(_signal->eventfd);
+	kfree(_signal);
+}
+
+/*
+ * Called with wqh->lock held and interrupts disabled
+ */
+static int
+eventfd_signal_wakeup(wait_queue_t *wait, unsigned mode, int sync, void *key)
+{
+	struct _eventfd_signal *_signal;
+	unsigned long flags = (unsigned long)key;
+
+	_signal = container_of(wait, struct _eventfd_signal, wait);
+
+	if (flags & POLLIN)
+		/* An event has been signaled */
+		_shm_signal_wakeup(_signal->signal);
+
+	if (flags & POLLHUP) {
+		/* The eventfd is closing, detach.. */
+		__remove_wait_queue(_signal->wqh, &_signal->wait);
+		schedule_work(&_signal->shutdown);
+	}
+
+	return 0;
+}
+
+static void
+eventfd_signal_ptable(struct file *file, wait_queue_head_t *wqh, poll_table *pt)
+{
+	struct _eventfd_signal *_signal;
+
+	_signal = container_of(pt, struct _eventfd_signal, pt);
+
+	_signal->wqh = wqh;
+	add_wait_queue(wqh, &_signal->wait);
+}
+
+int shm_signal_eventfd_bindfile(struct shm_signal *signal, struct file *file)
+{
+	struct _eventfd_signal *_signal;
+	struct eventfd_ctx *eventfd = NULL;
+	int ret = -EINVAL;
+
+	_signal = kzalloc(sizeof(*_signal), GFP_KERNEL);
+	if (!_signal)
+		return -ENOMEM;
+
+	eventfd = eventfd_ctx_fileget(file);
+	if (IS_ERR(eventfd)) {
+		ret = PTR_ERR(eventfd);
+		goto fail;
+	}
+
+	_signal->eventfd = eventfd;
+	_signal->signal  = signal;
+	INIT_WORK(&_signal->shutdown, eventfd_signal_shutdown);
+
+	init_waitqueue_func_entry(&_signal->wait, eventfd_signal_wakeup);
+	init_poll_funcptr(&_signal->pt, eventfd_signal_ptable);
+
+	file->f_op->poll(file, &_signal->pt);
+
+	return 0;
+
+fail:
+	if (eventfd && !IS_ERR(eventfd))
+		eventfd_ctx_put(eventfd);
+
+	kfree(_signal);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(shm_signal_eventfd_bindfile);
+
+int shm_signal_eventfd_bindfd(struct shm_signal *signal, int fd)
+{
+	struct file *file = NULL;
+	int ret = -EINVAL;
+
+	file = eventfd_fget(fd);
+	if (IS_ERR(file)) {
+		ret = PTR_ERR(file);
+		goto out;
+	}
+
+	ret = shm_signal_eventfd_bindfile(signal, file);
+
+out:
+	if (file && !IS_ERR(file))
+		fput(file);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(shm_signal_eventfd_bindfd);
-- 
1.6.5.2

