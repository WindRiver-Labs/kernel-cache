From fa2ab934c7271ff4e957b66b99e32e4f3f22e041 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:28:19 -0400
Subject: [PATCH 340/391] arm-trace-clock-update-clocksource

arm trace clock update clocksource

* Differs from omap tree *

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/arm/mach-omap2/trace-clock.c             |   12 +++++++-----
 arch/arm/plat-omap/common.c                   |    5 +++++
 arch/arm/plat-omap/include/plat/clock.h       |    2 ++
 arch/arm/plat-omap/include/plat/trace-clock.h |    4 +---
 4 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/arch/arm/mach-omap2/trace-clock.c b/arch/arm/mach-omap2/trace-clock.c
index 558248c..154bf40 100644
--- a/arch/arm/mach-omap2/trace-clock.c
+++ b/arch/arm/mach-omap2/trace-clock.c
@@ -12,11 +12,12 @@
 #include <linux/timer.h>
 #include <linux/spinlock.h>
 #include <linux/init.h>
-#include <plat/dmtimer.h>
+#include <plat/clock.h>
 #include <plat/trace-clock.h>
 
-/* Need direct access to the clock from kernel/time/timekeeping.c */
-extern struct clocksource *clock;
+/* depends on CONFIG_OMAP_32K_TIMER */
+/* Need direct access to the clock from arch/arm/mach-omap2/timer-gp.c */
+static struct clocksource *clock;
 
 /* 32KHz counter count save upon PM sleep */
 static u32 saved_32k_count;
@@ -149,7 +150,7 @@ void _start_trace_clock(void)
 	 */
 	ref_time = saved_trace_clock;
 	local_irq_save(flags);
-	count_32k = clocksource_read(clock);
+	count_32k = clock->read(clock);
 	prev_time = trace_clock_read64();
 	/*
 	 * Delta done on 32-bits, then casted to u64. Must guarantee
@@ -190,7 +191,7 @@ void _start_trace_clock(void)
 
 void _stop_trace_clock(void)
 {
-	saved_32k_count = clocksource_read(clock);
+	saved_32k_count = clock->read(clock);
 	saved_trace_clock = trace_clock_read64();
 	del_timer_sync(&clear_ccnt_ms_timer);
 	put_synthetic_tsc();
@@ -244,6 +245,7 @@ static __init int init_trace_clock(void)
 {
 	u64 rem;
 
+	clock = get_clocksource_32k();
 	clear_ccnt_interval = __iter_div_u64_rem(HZ * (1ULL << 30),
 				cpu_hz, &rem);
 	printk(KERN_INFO "LTTng will clear ccnt top bit every %u jiffies.\n",
diff --git a/arch/arm/plat-omap/common.c b/arch/arm/plat-omap/common.c
index f12f0e3..d23b624 100644
--- a/arch/arm/plat-omap/common.c
+++ b/arch/arm/plat-omap/common.c
@@ -167,6 +167,11 @@ static struct clocksource clocksource_32k = {
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
+struct clocksource *get_clocksource_32k(void)
+{
+	return &clocksource_32k;
+}
+
 /*
  * Returns current time from boot in nsecs. It's OK for this to wrap
  * around for now, as it's just a relative time stamp.
diff --git a/arch/arm/plat-omap/include/plat/clock.h b/arch/arm/plat-omap/include/plat/clock.h
index 34f7fa9..7b7caae 100644
--- a/arch/arm/plat-omap/include/plat/clock.h
+++ b/arch/arm/plat-omap/include/plat/clock.h
@@ -188,6 +188,8 @@ extern const struct clkops clkops_null;
 
 extern struct clk dummy_ck;
 
+struct clocksource *get_clocksource_32k(void);
+
 /* Clock flags */
 #define ENABLE_REG_32BIT	(1 << 0)	/* Use 32-bit access */
 #define CLOCK_IDLE_CONTROL	(1 << 1)
diff --git a/arch/arm/plat-omap/include/plat/trace-clock.h b/arch/arm/plat-omap/include/plat/trace-clock.h
index 3c868f8..344938d 100644
--- a/arch/arm/plat-omap/include/plat/trace-clock.h
+++ b/arch/arm/plat-omap/include/plat/trace-clock.h
@@ -8,8 +8,7 @@
 #define _ASM_ARM_TRACE_CLOCK_OMAP3_H
 
 #include <linux/clk.h>
-#include <asm/system.h>
-#include <plat/dmtimer.h>
+#include <plat/clock.h>
 
 /*
  * Number of hardware clock bits. The higher order bits are expected to be 0.
@@ -35,7 +34,6 @@
 
 extern u64 trace_clock_read_synthetic_tsc(void);
 extern void _trace_clock_write_synthetic_tsc(u64 value);
-extern struct omap_dm_timer *trace_clock_timer;
 extern unsigned long long cpu_hz;
 
 /*
-- 
1.6.5.2

