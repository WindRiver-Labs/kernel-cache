From c8ada877f121343876e2670336ee8df476733940 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Wed, 18 May 2011 18:41:34 -0400
Subject: [PATCH 046/248] lttng-instrumentation/lttng-instrumentation-timer

LTTng instrumentation - timer

Instrument timer activity (timer set, expired, current time updates) to keep
information about the "real time" flow within the kernel. It can be used by a
trace analysis tool to synchronize information coming from various sources, e.g.
to merge traces with system logs.

Those tracepoints are used by LTTng.

About the performance impact of tracepoints (which is comparable to markers),
even without immediate values optimizations, tests done by Hideo Aoki on ia64
show no regression. His test case was using hackbench on a kernel where
scheduler instrumentation (about 5 events in code scheduler code) was added.
See the "Tracepoints" patch header for performance result detail.

Note : do_setitimer instrumentation could potentially be done with a more
generic system call instrumentation.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: Frederic Weisbecker <fweisbec@gmail.com>
CC: "David S. Miller" <davem@davemloft.net>
CC: Masami Hiramatsu <mhiramat@redhat.com>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>
---
 include/trace/events/timer.h |    6 +++---
 include/trace/timer.h        |   24 ++++++++++++++++++++++++
 kernel/itimer.c              |    7 +++++++
 kernel/time/timekeeping.c    |   11 +++++++++++
 kernel/timer.c               |   10 +++++++++-
 5 files changed, 54 insertions(+), 4 deletions(-)
 create mode 100644 include/trace/timer.h

diff --git a/include/trace/events/timer.h b/include/trace/events/timer.h
index 425bcfe..f3b763e 100644
--- a/include/trace/events/timer.h
+++ b/include/trace/events/timer.h
@@ -1,8 +1,8 @@
 #undef TRACE_SYSTEM
 #define TRACE_SYSTEM timer
 
-#if !defined(_TRACE_TIMER_H) || defined(TRACE_HEADER_MULTI_READ)
-#define _TRACE_TIMER_H
+#if !defined(_TRACE_EVENTS_TIMER_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_EVENTS_TIMER_H
 
 #include <linux/tracepoint.h>
 #include <linux/hrtimer.h>
@@ -323,7 +323,7 @@ TRACE_EVENT(itimer_expire,
 		  (int) __entry->pid, (unsigned long long)__entry->now)
 );
 
-#endif /*  _TRACE_TIMER_H */
+#endif /*  _TRACE_EVENTS_TIMER_H */
 
 /* This part must be outside protection */
 #include <trace/define_trace.h>
diff --git a/include/trace/timer.h b/include/trace/timer.h
new file mode 100644
index 0000000..9b2a852
--- /dev/null
+++ b/include/trace/timer.h
@@ -0,0 +1,24 @@
+#ifndef _TRACE_TIMER_H
+#define _TRACE_TIMER_H
+
+#include <linux/tracepoint.h>
+
+DECLARE_TRACE(timer_itimer_expired,
+	TP_PROTO(struct signal_struct *sig),
+		TP_ARGS(sig));
+DECLARE_TRACE(timer_itimer_set,
+	TP_PROTO(int which, struct itimerval *value),
+		TP_ARGS(which, value));
+DECLARE_TRACE(timer_set,
+	TP_PROTO(struct timer_list *timer),
+		TP_ARGS(timer));
+/*
+ * xtime_lock is taken when kernel_timer_update_time tracepoint is reached.
+ */
+DECLARE_TRACE(timer_update_time,
+	TP_PROTO(struct timespec *_xtime, struct timespec *_wall_to_monotonic),
+		TP_ARGS(_xtime, _wall_to_monotonic));
+DECLARE_TRACE(timer_timeout,
+	TP_PROTO(struct task_struct *p),
+		TP_ARGS(p));
+#endif
diff --git a/kernel/itimer.c b/kernel/itimer.c
index 8d262b4..8e3266e 100644
--- a/kernel/itimer.c
+++ b/kernel/itimer.c
@@ -13,9 +13,13 @@
 #include <linux/posix-timers.h>
 #include <linux/hrtimer.h>
 #include <trace/events/timer.h>
+#include <trace/timer.h>
 
 #include <asm/uaccess.h>
 
+DEFINE_TRACE(timer_itimer_expired);
+DEFINE_TRACE(timer_itimer_set);
+
 /**
  * itimer_get_remtime - get remaining time for the timer
  *
@@ -124,6 +128,7 @@ enum hrtimer_restart it_real_fn(struct hrtimer *timer)
 		container_of(timer, struct signal_struct, real_timer);
 
 	trace_itimer_expire(ITIMER_REAL, sig->leader_pid, 0);
+	trace_timer_itimer_expired(sig);
 	kill_pid_info(SIGALRM, SEND_SIG_PRIV, sig->leader_pid);
 
 	return HRTIMER_NORESTART;
@@ -200,6 +205,8 @@ int do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue)
 	    !timeval_valid(&value->it_interval))
 		return -EINVAL;
 
+	trace_timer_itimer_set(which, value);
+
 	switch (which) {
 	case ITIMER_REAL:
 again:
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index d66b213..ac05643 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -21,6 +21,12 @@
 #include <linux/tick.h>
 #include <linux/stop_machine.h>
 
+#include <trace/timer.h>
+
+#include <trace/events/timer.h>
+DEFINE_TRACE(timer_update_time);
+
+
 /* Structure holding internal timekeeping values. */
 struct timekeeper {
 	/* Current clocksource used for timekeeping. */
@@ -1221,8 +1227,13 @@ struct timespec get_monotonic_coarse(void)
  */
 void do_timer(unsigned long ticks)
 {
+	struct timespec curtime, wtom;
+
 	jiffies_64 += ticks;
 	update_wall_time();
+	curtime = __current_kernel_time();
+	wtom = wall_to_monotonic;
+	trace_timer_update_time(&curtime, &wtom);
 	calc_global_load(ticks);
 }
 
diff --git a/kernel/timer.c b/kernel/timer.c
index a297ffc..9dcf6c2 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -40,12 +40,14 @@
 #include <linux/irq_work.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
+#include <trace/timer.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 #include <asm/div64.h>
 #include <asm/timex.h>
 #include <asm/io.h>
+#include <asm/irq_regs.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/timer.h>
@@ -54,6 +56,9 @@ u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;
 
 EXPORT_SYMBOL(jiffies_64);
 
+DEFINE_TRACE(timer_set);
+DEFINE_TRACE(timer_timeout);
+
 /*
  * per-CPU timer vector definitions:
  */
@@ -366,6 +371,7 @@ static void internal_add_timer(struct tvec_base *base, struct timer_list *timer)
 		i = (expires >> (TVR_BITS + 3 * TVN_BITS)) & TVN_MASK;
 		vec = base->tv5.vec + i;
 	}
+	trace_timer_set(timer);
 	/*
 	 * Timers are FIFO:
 	 */
@@ -1452,7 +1458,9 @@ SYSCALL_DEFINE0(getegid)
 
 static void process_timeout(unsigned long __data)
 {
-	wake_up_process((struct task_struct *)__data);
+	struct task_struct *task = (struct task_struct *)__data;
+	trace_timer_timeout(task);
+	wake_up_process(task);
 }
 
 /**
-- 
1.7.0.4

