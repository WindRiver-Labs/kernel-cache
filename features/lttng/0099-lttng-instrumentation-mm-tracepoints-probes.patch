From 504a90a8c450de640f6f01593528a2984e21924a Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 2 Oct 2008 14:36:23 -0400
Subject: [PATCH] lttng-instrumentation-mm-tracepoints-probes

LTTng instrumentation mm tracepoint probes

Create a module which declares mm tracepoint probes, using markers.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Alexander Viro <viro@zeniv.linux.org.uk>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Masami Hiramatsu <mhiramat@redhat.com>
---
 include/linux/swapops.h |    8 +++
 ltt/probes/Makefile     |    2 +-
 ltt/probes/mm-trace.c   |  112 +++++++++++++++++++++++++++++++++++++++++++++++
 mm/swapfile.c           |    1 +
 4 files changed, 122 insertions(+), 1 deletions(-)
 create mode 100644 ltt/probes/mm-trace.c

diff --git a/include/linux/swapops.h b/include/linux/swapops.h
index 6ec39ab..fb40dac 100644
--- a/include/linux/swapops.h
+++ b/include/linux/swapops.h
@@ -76,6 +76,14 @@ static inline pte_t swp_entry_to_pte(swp_entry_t entry)
 	return __swp_entry_to_pte(arch_entry);
 }
 
+static inline swp_entry_t page_swp_entry(struct page *page)
+{
+	swp_entry_t entry;
+	VM_BUG_ON(!PageSwapCache(page));
+	entry.val = page_private(page);
+	return entry;
+}
+
 #ifdef CONFIG_MIGRATION
 static inline swp_entry_t make_migration_entry(struct page *page, int write)
 {
diff --git a/ltt/probes/Makefile b/ltt/probes/Makefile
index e85675a..1bb06b0 100644
--- a/ltt/probes/Makefile
+++ b/ltt/probes/Makefile
@@ -1,3 +1,3 @@
 # LTTng tracing probes
 
-obj-$(CONFIG_LTT_TRACEPROBES)	+= kernel-trace.o
+obj-$(CONFIG_LTT_TRACEPROBES)	+= kernel-trace.o mm-trace.o
diff --git a/ltt/probes/mm-trace.c b/ltt/probes/mm-trace.c
new file mode 100644
index 0000000..866f388
--- /dev/null
+++ b/ltt/probes/mm-trace.c
@@ -0,0 +1,112 @@
+/*
+ * ltt/probes/mm-trace.c
+ *
+ * MM tracepoint probes.
+ */
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
+#include <linux/swapops.h>
+#include <trace/page_alloc.h>
+#include <trace/filemap.h>
+#include <trace/swap.h>
+#include <trace/memory.h>
+#include <trace/hugetlb.h>
+
+void probe_wait_on_page_start(struct page *page, int bit_nr)
+{
+	trace_mark_tp(mm_wait_on_page_start, wait_on_page_start,
+		probe_wait_on_page_start, "pfn %lu bit_nr %d",
+		page_to_pfn(page), bit_nr);
+}
+
+void probe_wait_on_page_end(struct page *page, int bit_nr)
+{
+	trace_mark_tp(mm_wait_on_page_end, wait_on_page_end,
+		probe_wait_on_page_end, "pfn %lu bit_nr %d",
+		page_to_pfn(page), bit_nr);
+}
+
+void probe_hugetlb_page_free(struct page *page)
+{
+	trace_mark_tp(mm_huge_page_free, hugetlb_page_free,
+		probe_hugetlb_page_free, "pfn %lu", page_to_pfn(page));
+}
+
+void probe_hugetlb_page_alloc(struct page *page)
+{
+	if (page)
+		trace_mark_tp(mm_huge_page_alloc, hugetlb_page_alloc,
+			probe_hugetlb_page_alloc, "pfn %lu", page_to_pfn(page));
+}
+
+void probe_memory_handle_fault_entry(struct mm_struct *mm,
+	struct vm_area_struct *vma, unsigned long address, int write_access)
+{
+	trace_mark_tp(mm_handle_fault_entry, memory_handle_fault_entry,
+		probe_memory_handle_fault_entry,
+		"address %lu ip #p%ld write_access %d",
+		address, KSTK_EIP(current), write_access);
+}
+
+void probe_memory_handle_fault_exit(int res)
+{
+	trace_mark_tp(mm_handle_fault_exit, memory_handle_fault_exit,
+		probe_memory_handle_fault_exit, "res %d", res);
+}
+
+void probe_page_free(struct page *page, unsigned int order)
+{
+	trace_mark_tp(mm_page_free, page_free,
+		probe_page_free, "order %u pfn %lu", order, page_to_pfn(page));
+}
+
+void probe_page_alloc(struct page *page, unsigned int order)
+{
+	if (page)
+		trace_mark_tp(mm_page_alloc, page_alloc,
+			probe_page_alloc, "order %u pfn %lu", order,
+			page_to_pfn(page));
+}
+
+#ifdef CONFIG_SWAP
+void probe_swap_in(struct page *page, swp_entry_t entry)
+{
+	trace_mark_tp(mm_swap_in, swap_in, probe_swap_in,
+		"pfn %lu filp %p offset %lu",
+		page_to_pfn(page),
+		get_swap_info_struct(swp_type(entry))->swap_file,
+		swp_offset(entry));
+}
+
+void probe_swap_out(struct page *page)
+{
+	trace_mark_tp(mm_swap_out, swap_out, probe_swap_out,
+		"pfn %lu filp %p offset %lu",
+		page_to_pfn(page),
+		get_swap_info_struct(swp_type(
+			page_swp_entry(page)))->swap_file,
+		swp_offset(page_swp_entry(page)));
+}
+
+void probe_swap_file_close(struct file *file)
+{
+	trace_mark_tp(mm_swap_file_close, swap_file_close,
+		probe_swap_file_close, "filp %p", file);
+}
+
+void probe_swap_file_open(struct file *file, char *filename)
+{
+	trace_mark_tp(mm_swap_file_open, swap_file_open,
+		probe_swap_file_open, "filp %p filename %s",
+		file, filename);
+}
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("MM Tracepoint Probes");
diff --git a/mm/swapfile.c b/mm/swapfile.c
index 5dc052c..c9e7c95 100644
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@ -1800,6 +1800,7 @@ get_swap_info_struct(unsigned type)
 {
 	return &swap_info[type];
 }
+EXPORT_SYMBOL_GPL(get_swap_info_struct);
 
 /*
  * swap_lock prevents swap_map being freed. Don't grab an extra
-- 
1.5.5.1

