From e51463f18b2c7ffeb8b24624c9b05961cdd00fc6 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:28:42 -0400
Subject: [PATCH 386/391] lttng-trace-clock-sh-code-rework

lttng trace clock sh code rework

LTTng trace clock definitions for SuperH were broken for the new Kernels.
The patch reviews this code using the clocksource API to handle trace clock.
For example, on ST Kernels the TMU channel 1 continues to be used as
clocksource and all works fine for LTT (tested on SH4 STM platforms based).
Concerning the TMU frequency, it comes from the module_clk clock available on
ST platforms.
This support was only tested on ST platforms and it is turned-on for
CPU_SH4 configurations. Other effort and tests are necessary to verify
it on other SH architectures.

From: Giuseppe Cavallaro <peppe.cavallaro@st.com>
Signed-off-by: Giuseppe Cavallaro <peppe.cavallaro@st.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
---
 arch/sh/Kconfig                   |    4 +-
 arch/sh/include/asm/trace-clock.h |   19 +++++--------
 arch/sh/kernel/Makefile           |    1 +
 arch/sh/kernel/trace-clock.c      |   55 +++++++++++++++++++++++++++++++++++++
 4 files changed, 65 insertions(+), 14 deletions(-)
 create mode 100644 arch/sh/kernel/trace-clock.c

diff --git a/arch/sh/Kconfig b/arch/sh/Kconfig
index 4274bbc..14eb666 100644
--- a/arch/sh/Kconfig
+++ b/arch/sh/Kconfig
@@ -12,8 +12,6 @@ config SUPERH
 	select HAVE_IDE
 	select HAVE_LMB
 	select HAVE_OPROFILE
-	select HAVE_TRACE_CLOCK
-	select HAVE_TRACE_CLOCK_32_TO_64
 	select HAVE_GENERIC_DMA_COHERENT
 	select HAVE_ARCH_TRACEHOOK
 	select HAVE_DMA_API_DEBUG
@@ -217,6 +215,8 @@ config CPU_SH4
 	select CPU_HAS_FPU if !CPU_SH4AL_DSP
 	select SYS_SUPPORTS_TMU
 	select SYS_SUPPORTS_HUGETLBFS if MMU
+	select HAVE_TRACE_CLOCK
+	select HAVE_TRACE_CLOCK_32_TO_64
 
 config CPU_SH4A
 	bool
diff --git a/arch/sh/include/asm/trace-clock.h b/arch/sh/include/asm/trace-clock.h
index 7dfa042..2e90aba 100644
--- a/arch/sh/include/asm/trace-clock.h
+++ b/arch/sh/include/asm/trace-clock.h
@@ -8,7 +8,7 @@
 #ifndef _ASM_SH_TRACE_CLOCK_H
 #define _ASM_SH_TRACE_CLOCK_H
 
-#include <linux/timer.h>
+#include <linux/clocksource.h>
 #include <asm/clock.h>
 
 /*
@@ -24,10 +24,14 @@
 #define TC_EXPECTED_INTERRUPT_LATENCY	30
 
 extern u64 trace_clock_read_synthetic_tsc(void);
+extern u64 sh_get_clock_frequency(void);
+extern u32 sh_read_timer_count(void);
+extern void get_synthetic_tsc(void);
+extern void put_synthetic_tsc(void);
 
 static inline u32 trace_clock_read32(void)
 {
-	return get_cycles();
+	return sh_read_timer_count();
 }
 
 static inline u64 trace_clock_read64(void)
@@ -37,13 +41,7 @@ static inline u64 trace_clock_read64(void)
 
 static inline u64 trace_clock_frequency(void)
 {
-	u64 rate;
-	struct clk *tmu1_clk;
-
-	tmu1_clk = clk_get(NULL, "tmu1_clk");
-	rate = clk_get_rate(tmu1_clk);
-
-	return rate;
+	return sh_get_clock_frequency();
 }
 
 static inline u32 trace_clock_freq_scale(void)
@@ -51,9 +49,6 @@ static inline u32 trace_clock_freq_scale(void)
 	return 1;
 }
 
-extern void get_synthetic_tsc(void);
-extern void put_synthetic_tsc(void);
-
 static inline void get_trace_clock(void)
 {
 	get_synthetic_tsc();
diff --git a/arch/sh/kernel/Makefile b/arch/sh/kernel/Makefile
index 02fd3ae..509838d 100644
--- a/arch/sh/kernel/Makefile
+++ b/arch/sh/kernel/Makefile
@@ -42,5 +42,6 @@ obj-$(CONFIG_PERF_EVENTS)	+= perf_event.o perf_callchain.o
 
 obj-$(CONFIG_HAVE_HW_BREAKPOINT)		+= hw_breakpoint.o
 obj-$(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST)	+= localtimer.o
+obj-$(CONFIG_HAVE_TRACE_CLOCK)  += trace-clock.o
 
 EXTRA_CFLAGS += -Werror
diff --git a/arch/sh/kernel/trace-clock.c b/arch/sh/kernel/trace-clock.c
new file mode 100644
index 0000000..0c5509b
--- /dev/null
+++ b/arch/sh/kernel/trace-clock.c
@@ -0,0 +1,55 @@
+/*
+ * arch/sh/kernel/trace-clock.c
+ *
+ * Trace clock for SuperH.
+ *
+ * Copyright (C) 2010  STMicroelectronics Ltd
+ *
+ * Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+ * Note: currently only tested and supported on SH4 CPU
+ * (TODO: tests on other SuperH architectures).
+ */
+
+#include <linux/module.h>
+#include <linux/clocksource.h>
+#include <asm/clock.h>
+
+static struct clocksource *clksrc;
+
+/* In case of the TMU, for SH4 architectures, it returns
+ * the value of timer counter register (TCNT). */
+u32 sh_read_timer_count(void)
+{
+	u32 value = 0;
+
+	if (likely(clksrc))
+		value = (u32) clksrc->read(clksrc);
+
+	return value;
+}
+
+/* Get the clock rate for the timer (e.g. TMU for SH4) */
+u64 sh_get_clock_frequency(void)
+{
+	u64 rate = 0;
+	struct clk *clk;
+
+	clk = clk_get(NULL, "module_clk");
+	if (likely(clk))
+		rate = clk_get_rate(clk) / 4;
+
+	return rate;
+}
+
+/* Get the clock source needed to read the timer counter.
+ * For example a TMU channel for SH4 architectures. */
+static __init int init_sh_clocksource(void)
+{
+	clksrc = clocksource_get_next();
+	if (unlikely(!clksrc))
+		pr_err("%s: no clocksource found\n", __func__);
+
+	return 0;
+}
+early_initcall(init_sh_clocksource);
-- 
1.6.5.2

