From 7566fd98e74055d3a23f150a72f8b9cf360f3372 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:28:03 -0400
Subject: [PATCH 312/391] lttng-fix-rcu-teardown

LTTng fix RCU teardown

The teardown of the trace/channel data structures should only be done after all
RCU channel list readers have reached a quiescent state.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-channels.h |    3 ---
 include/linux/ltt-relay.h    |    6 ++++--
 ltt/ltt-ascii.c              |    2 +-
 ltt/ltt-relay-alloc.c        |   21 +++++++++++----------
 ltt/ltt-relay-lockless.c     |   18 ++++++------------
 ltt/ltt-tracer.c             |    4 ++--
 6 files changed, 24 insertions(+), 30 deletions(-)

diff --git a/include/linux/ltt-channels.h b/include/linux/ltt-channels.h
index 51fe931..4d5bd81 100644
--- a/include/linux/ltt-channels.h
+++ b/include/linux/ltt-channels.h
@@ -17,8 +17,6 @@
 
 #define EVENTS_PER_CHANNEL	65536
 
-struct ltt_trace;
-
 struct ltt_chan {
 	struct ltt_chan_alloc a;		/* Parent. First field. */
 	int overwrite:1;
@@ -29,7 +27,6 @@ struct ltt_chan {
 						 * bits used to represent the
 						 * subbuffer index.
 						 */
-	struct ltt_trace *trace;
 	unsigned long switch_timer_interval;
 };
 
diff --git a/include/linux/ltt-relay.h b/include/linux/ltt-relay.h
index 9a01e14..ad26e9f 100644
--- a/include/linux/ltt-relay.h
+++ b/include/linux/ltt-relay.h
@@ -32,6 +32,8 @@
 #define RCHAN_SB_CLEAR_NOREF(x)	\
 	(x = (struct chanbuf_page *)((unsigned long)(x) & ~RCHAN_NOREF_FLAG))
 
+struct ltt_trace;
+
 struct chanbuf_page {
 	void *virt;			/* page virtual address (cached) */
 	struct page *page;		/* pointer to page structure */
@@ -73,14 +75,14 @@ struct ltt_chan_alloc {
 	unsigned long n_sb;		/* Number of sub-buffers */
 	struct dentry *parent;		/* Associated parent dentry */
 	struct dentry *ascii_dentry;	/* Text output dentry */
-	struct rcu_head rcu_cb;		/* RCU callback for buf removal */
+	struct ltt_trace *trace;	/* Associated trace */
 	char filename[NAME_MAX];	/* Filename for channel files */
 };
 
 int ltt_chanbuf_alloc_create(struct ltt_chanbuf_alloc *buf,
 			     struct ltt_chan_alloc *chan, int cpu);
 void ltt_chanbuf_alloc_free(struct ltt_chanbuf_alloc *buf);
-int ltt_chan_alloc_init(struct ltt_chan_alloc *chan,
+int ltt_chan_alloc_init(struct ltt_chan_alloc *chan, struct ltt_trace *trace,
 			const char *base_filename,
 			struct dentry *parent, size_t sb_size,
 			size_t n_sb, int extra_reader_sb, int overwrite);
diff --git a/ltt/ltt-ascii.c b/ltt/ltt-ascii.c
index 4014b5f..9df4625 100644
--- a/ltt/ltt-ascii.c
+++ b/ltt/ltt-ascii.c
@@ -512,7 +512,7 @@ int ltt_ascii_create(struct ltt_chan *chan)
 
 	dentry = debugfs_create_file(chan->a.filename,
 				     S_IRUSR | S_IRGRP,
-				     chan->trace->dentry.ascii_root,
+				     chan->a.trace->dentry.ascii_root,
 				     chan, &ltt_ascii_fops);
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
diff --git a/ltt/ltt-relay-alloc.c b/ltt/ltt-relay-alloc.c
index 66a04f0..d29069f 100644
--- a/ltt/ltt-relay-alloc.c
+++ b/ltt/ltt-relay-alloc.c
@@ -256,6 +256,8 @@ void ltt_chan_for_each_channel(void (*cb) (struct ltt_chanbuf *buf), int cpu,
 
 /**
  * ltt_chan_create - create a new relay channel
+ * @chan: channel
+ * @trace: trace
  * @base_filename: base name of files to create
  * @parent: dentry of parent directory, %NULL for root directory
  * @sb_size: size of sub-buffers (> PAGE_SIZE, power of 2)
@@ -270,7 +272,7 @@ void ltt_chan_for_each_channel(void (*cb) (struct ltt_chanbuf *buf), int cpu,
  * base_filename_0...base_filename_N-1.  File permissions will
  * be %S_IRUSR.
  */
-int ltt_chan_alloc_init(struct ltt_chan_alloc *chan,
+int ltt_chan_alloc_init(struct ltt_chan_alloc *chan, struct ltt_trace *trace,
 			const char *base_filename,
 			struct dentry *parent, size_t sb_size,
 			size_t n_sb, int extra_reader_sb, int overwrite)
@@ -293,16 +295,17 @@ int ltt_chan_alloc_init(struct ltt_chan_alloc *chan,
 	WARN_ON_ONCE(hweight32(sb_size) != 1);
 	WARN_ON(hweight32(n_sb) != 1);
 
+	chan->trace = trace;
 	chan->buf_size = n_sb * sb_size;
 	chan->sb_size = sb_size;
 	chan->sb_size_order = get_count_order(sb_size);
 	chan->n_sb_order = get_count_order(n_sb);
 	chan->extra_reader_sb = extra_reader_sb;
-
 	chan->n_sb = n_sb;
 	chan->parent = parent;
 	strlcpy(chan->filename, base_filename, NAME_MAX);
 	kref_init(&chan->kref);
+	kref_get(&chan->trace->kref);
 
 	/* Allocating the child structure */
 	chan->buf = alloc_percpu(struct ltt_chanbuf);
@@ -336,13 +339,6 @@ free_chan:
 	return -ENOMEM;
 }
 
-void ltt_chan_alloc_free_rcu(struct rcu_head *head)
-{
-	struct ltt_chan_alloc *chana =
-		container_of(head, struct ltt_chan_alloc, rcu_cb);
-	free_percpu(chana->buf);
-}
-
 /**
  * ltt_chan_alloc_free - destroy the channel
  * @chan: the channel
@@ -364,7 +360,12 @@ void ltt_chan_alloc_free(struct ltt_chan_alloc *chan)
 	}
 	list_del_rcu(&chan->list);
 	mutex_unlock(&ltt_relay_alloc_mutex);
-	call_rcu(&chan->rcu_cb, ltt_chan_alloc_free_rcu);
+	/* Delay channel free for RCU channel list, protected by
+	 * RCU sched. */
+	synchronize_sched();
+	free_percpu(chan->buf);
+	kref_put(&chan->trace->kref, ltt_release_trace);
+	wake_up_interruptible(&chan->trace->kref_wq);
 }
 
 /**
diff --git a/ltt/ltt-relay-lockless.c b/ltt/ltt-relay-lockless.c
index d05d9b4..2edeae1 100644
--- a/ltt/ltt-relay-lockless.c
+++ b/ltt/ltt-relay-lockless.c
@@ -50,6 +50,7 @@
 #include <linux/stat.h>
 #include <linux/cpu.h>
 #include <linux/idle.h>
+#include <linux/delay.h>
 #include <asm/atomic.h>
 #include <asm/local.h>
 #include <linux/notifier.h>
@@ -88,7 +89,7 @@ void ltt_buffer_begin(struct ltt_chanbuf *buf, u64 tsc, unsigned int subbuf_idx)
 	header->cycle_count_begin = tsc;
 	header->lost_size = 0xFFFFFFFF; /* for debugging */
 	header->buf_size = chan->a.sb_size;
-	ltt_write_trace_header(chan->trace, header);
+	ltt_write_trace_header(chan->a.trace, header);
 }
 
 /*
@@ -123,9 +124,6 @@ void ltt_chanbuf_free(struct kref *kref)
 #endif
 	kfree(buf->commit_count);
 
-	kref_put(&chan->trace->kref, ltt_release_trace);
-	wake_up_interruptible(&chan->trace->kref_wq);
-
 	ltt_chanbuf_alloc_free(&buf->a);
 }
 
@@ -139,7 +137,7 @@ int ltt_chanbuf_create(struct ltt_chanbuf *buf, struct ltt_chan_alloc *chana,
 		       int cpu)
 {
 	struct ltt_chan *chan = container_of(chana, struct ltt_chan, a);
-	struct ltt_trace *trace = chan->trace;
+	struct ltt_trace *trace = chana->trace;
 	unsigned int j, n_sb;
 	int ret;
 
@@ -172,7 +170,6 @@ int ltt_chanbuf_create(struct ltt_chanbuf *buf, struct ltt_chan_alloc *chana,
 	}
 #endif
 
-	kref_get(&chan->trace->kref);
 	local_set(&buf->offset, ltt_sb_header_size());
 	atomic_long_set(&buf->consumed, 0);
 	atomic_long_set(&buf->active_readers, 0);
@@ -205,8 +202,6 @@ int ltt_chanbuf_create(struct ltt_chanbuf *buf, struct ltt_chan_alloc *chana,
 
 	/* Error handling */
 free_init:
-	kref_put(&chan->trace->kref, ltt_release_trace);
-	wake_up_interruptible(&chan->trace->kref_wq);
 #ifdef CONFIG_LTT_VMCORE
 	kfree(buf->commit_seq);
 free_commit:
@@ -237,10 +232,9 @@ int ltt_chan_create(const char *base_filename,
 	int ret;
 
 	chan->overwrite = overwrite;
-	chan->trace = trace;
 
-	ret = ltt_chan_alloc_init(&chan->a, base_filename, parent, sb_size,
-				  n_sb, overwrite, overwrite);
+	ret = ltt_chan_alloc_init(&chan->a, trace, base_filename, parent,
+				  sb_size, n_sb, overwrite, overwrite);
 	if (ret)
 		goto error;
 
@@ -670,7 +664,7 @@ void ltt_relay_print_errors(struct ltt_chanbuf *buf, struct ltt_chan *chan,
 static
 void ltt_relay_print_buffer_errors(struct ltt_chan *chan, unsigned int cpu)
 {
-	struct ltt_trace *trace = chan->trace;
+	struct ltt_trace *trace = chan->a.trace;
 	struct ltt_chanbuf *buf = per_cpu_ptr(chan->a.buf, cpu);
 
 	if (local_read(&buf->events_lost))
diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index 657013a..179256f 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -1077,7 +1077,7 @@ void ltt_channels_trace_start_timer(struct ltt_chan *channels,
 
 	for (i = 0; i < nr_channels; i++) {
 		struct ltt_chan *chan = &channels[i];
-		chan->trace->ops->start_switch_timer(chan);
+		chan->a.trace->ops->start_switch_timer(chan);
 	}
 }
 
@@ -1092,7 +1092,7 @@ void ltt_channels_trace_stop_timer(struct ltt_chan *channels,
 
 	for (i = 0; i < nr_channels; i++) {
 		struct ltt_chan *chan = &channels[i];
-		chan->trace->ops->stop_switch_timer(chan);
+		chan->a.trace->ops->stop_switch_timer(chan);
 	}
 }
 
-- 
1.6.5.2

