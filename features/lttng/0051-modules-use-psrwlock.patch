From cc61b162be92e5df6e31420ce659cc926d74031f Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 2 Oct 2008 14:36:08 -0400
Subject: [PATCH] modules-use-psrwlock

Module use priority sifting rwlock

I got mad at the modules_mutex. Killed it by using the preemptable reader-writer
lock implementation. We can now have multiple readers, even nested ones. Makes
the use of module list much saner.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 kernel/module.c |   62 ++++++++++++++++++++++++++++--------------------------
 1 files changed, 32 insertions(+), 30 deletions(-)

diff --git a/kernel/module.c b/kernel/module.c
index c8b8ba1..3209979 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -40,8 +40,8 @@
 #include <linux/stop_machine.h>
 #include <linux/device.h>
 #include <linux/string.h>
-#include <linux/mutex.h>
 #include <linux/unwind.h>
+#include <linux/psrwlock.h>
 #include <asm/uaccess.h>
 #include <asm/cacheflush.h>
 #include <linux/license.h>
@@ -61,10 +61,10 @@
 /* If this is set, the section belongs in the init part of the module */
 #define INIT_OFFSET_MASK (1UL << (BITS_PER_LONG-1))
 
-/* List of modules, protected by module_mutex or preempt_disable
+/* List of modules, protected by preemptable module_psrwlock or preempt_disable
  * (add/delete uses stop_machine). Sorted by ascending list node address.
  */
-static DEFINE_MUTEX(module_mutex);
+static DEFINE_PSRWLOCK(module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 static LIST_HEAD(modules);
 
 /* Waiting for a module to finish initializing? */
@@ -327,7 +327,7 @@ static unsigned long find_symbol(const char *name,
 	return -ENOENT;
 }
 
-/* Search for module by name: must hold module_mutex. */
+/* Search for module by name: must hold module_psrwlock. */
 static struct module *find_module(const char *name)
 {
 	struct module *mod;
@@ -707,8 +707,8 @@ static void free_module(struct module *mod);
 
 static void wait_for_zero_refcount(struct module *mod)
 {
-	/* Since we might sleep for some time, release the mutex first */
-	mutex_unlock(&module_mutex);
+	/* Since we might sleep for some time, release the psrwlock first */
+	pswrite_unlock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 	for (;;) {
 		DEBUGP("Looking at refcount...\n");
 		set_current_state(TASK_UNINTERRUPTIBLE);
@@ -717,7 +717,7 @@ static void wait_for_zero_refcount(struct module *mod)
 		schedule();
 	}
 	current->state = TASK_RUNNING;
-	mutex_lock(&module_mutex);
+	pswrite_lock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 }
 
 asmlinkage long
@@ -734,7 +734,8 @@ sys_delete_module(const char __user *name_user, unsigned int flags)
 		return -EFAULT;
 	name[MODULE_NAME_LEN-1] = '\0';
 
-	if (mutex_lock_interruptible(&module_mutex) != 0)
+	if (pswrite_lock_interruptible(&module_psrwlock,
+			PSRW_PRIO_P, PSR_PTHREAD) != 0)
 		return -EINTR;
 
 	mod = find_module(name);
@@ -780,20 +781,20 @@ sys_delete_module(const char __user *name_user, unsigned int flags)
 	if (!forced && module_refcount(mod) != 0)
 		wait_for_zero_refcount(mod);
 
-	mutex_unlock(&module_mutex);
+	pswrite_unlock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 	/* Final destruction now noone is using it. */
 	if (mod->exit != NULL)
 		mod->exit();
 	blocking_notifier_call_chain(&module_notify_list,
 				     MODULE_STATE_GOING, mod);
-	mutex_lock(&module_mutex);
+	pswrite_lock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 	/* Store the name of the last unloaded module for diagnostic purposes */
 	strlcpy(last_unloaded_module, mod->name, sizeof(last_unloaded_module));
 	unregister_dynamic_debug_module(mod->name);
 	free_module(mod);
 
  out:
-	mutex_unlock(&module_mutex);
+	pswrite_unlock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 	return ret;
 }
 
@@ -1028,7 +1029,7 @@ static inline int same_magic(const char *amagic, const char *bmagic,
 #endif /* CONFIG_MODVERSIONS */
 
 /* Resolve a symbol for this module.  I.e. if we find one, record usage.
-   Must be holding module_mutex. */
+   Must be holding module_psrwlock. */
 static unsigned long resolve_symbol(Elf_Shdr *sechdrs,
 				    unsigned int versindex,
 				    const char *name,
@@ -1440,7 +1441,7 @@ static int __unlink_module(void *_mod)
 	return 0;
 }
 
-/* Free a module, remove from lists, etc (must hold module_mutex). */
+/* Free a module, remove from lists, etc (must hold module_psrwlock). */
 static void free_module(struct module *mod)
 {
 	/* Delete from various lists */
@@ -2339,18 +2340,19 @@ sys_init_module(void __user *umod,
 		return -EPERM;
 
 	/* Only one module load at a time, please */
-	if (mutex_lock_interruptible(&module_mutex) != 0)
+	if (pswrite_lock_interruptible(&module_psrwlock,
+			PSRW_PRIO_P, PSR_PTHREAD) != 0)
 		return -EINTR;
 
 	/* Do all the hard work */
 	mod = load_module(umod, len, uargs);
 	if (IS_ERR(mod)) {
-		mutex_unlock(&module_mutex);
+		pswrite_unlock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 		return PTR_ERR(mod);
 	}
 
 	/* Drop lock so they can recurse */
-	mutex_unlock(&module_mutex);
+	pswrite_unlock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 
 	blocking_notifier_call_chain(&module_notify_list,
 			MODULE_STATE_COMING, mod);
@@ -2366,9 +2368,9 @@ sys_init_module(void __user *umod,
 		module_put(mod);
 		blocking_notifier_call_chain(&module_notify_list,
 					     MODULE_STATE_GOING, mod);
-		mutex_lock(&module_mutex);
+		pswrite_lock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 		free_module(mod);
-		mutex_unlock(&module_mutex);
+		pswrite_unlock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 		wake_up(&module_wq);
 		return ret;
 	}
@@ -2385,7 +2387,7 @@ sys_init_module(void __user *umod,
 	mod->state = MODULE_STATE_LIVE;
 	wake_up(&module_wq);
 
-	mutex_lock(&module_mutex);
+	pswrite_lock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 	/* Drop initial reference. */
 	module_put(mod);
 	unwind_remove_table(mod->unwind_info, 1);
@@ -2393,7 +2395,7 @@ sys_init_module(void __user *umod,
 	mod->module_init = NULL;
 	mod->init_size = 0;
 	mod->init_text_size = 0;
-	mutex_unlock(&module_mutex);
+	pswrite_unlock(&module_psrwlock, PSRW_PRIO_P, PSR_PTHREAD);
 
 	return 0;
 }
@@ -2599,7 +2601,7 @@ unsigned long module_kallsyms_lookup_name(const char *name)
 /* Called by the /proc file system to return a list of modules. */
 static void *m_start(struct seq_file *m, loff_t *pos)
 {
-	mutex_lock(&module_mutex);
+	psread_lock(&module_psrwlock);
 	return seq_sorted_list_start(&modules, pos);
 }
 
@@ -2610,7 +2612,7 @@ static void *m_next(struct seq_file *m, void *p, loff_t *pos)
 
 static void m_stop(struct seq_file *m, void *p)
 {
-	mutex_unlock(&module_mutex);
+	psread_unlock(&module_psrwlock);
 }
 
 static char *module_flags(struct module *mod, char *buf)
@@ -2778,12 +2780,12 @@ void module_update_markers(void)
 {
 	struct module *mod;
 
-	mutex_lock(&module_mutex);
+	psread_lock(&module_psrwlock);
 	list_for_each_entry(mod, &modules, list)
 		if (!mod->taints)
 			marker_update_probe_range(mod->markers,
 				mod->markers + mod->num_markers);
-	mutex_unlock(&module_mutex);
+	psread_unlock(&module_psrwlock);
 }
 
 /*
@@ -2795,7 +2797,7 @@ int module_get_iter_markers(struct marker_iter *iter)
 	struct module *iter_mod;
 	int found = 0;
 
-	mutex_lock(&module_mutex);
+	psread_lock(&module_psrwlock);
 	list_for_each_entry(iter_mod, &modules, list) {
 		if (!iter_mod->taints) {
 			/*
@@ -2814,7 +2816,7 @@ int module_get_iter_markers(struct marker_iter *iter)
 			}
 		}
 	}
-	mutex_unlock(&module_mutex);
+	psread_unlock(&module_psrwlock);
 	return found;
 }
 #endif
@@ -2824,12 +2826,12 @@ void module_update_tracepoints(void)
 {
 	struct module *mod;
 
-	mutex_lock(&module_mutex);
+	psread_lock(&module_psrwlock);
 	list_for_each_entry(mod, &modules, list)
 		if (!mod->taints)
 			tracepoint_update_probe_range(mod->tracepoints,
 				mod->tracepoints + mod->num_tracepoints);
-	mutex_unlock(&module_mutex);
+	psread_unlock(&module_psrwlock);
 }
 
 /*
@@ -2841,7 +2843,7 @@ int module_get_iter_tracepoints(struct tracepoint_iter *iter)
 	struct module *iter_mod;
 	int found = 0;
 
-	mutex_lock(&module_mutex);
+	psread_lock(&module_psrwlock);
 	list_for_each_entry(iter_mod, &modules, list) {
 		if (!iter_mod->taints) {
 			/*
@@ -2861,7 +2863,7 @@ int module_get_iter_tracepoints(struct tracepoint_iter *iter)
 			}
 		}
 	}
-	mutex_unlock(&module_mutex);
+	psread_unlock(&module_psrwlock);
 	return found;
 }
 #endif
-- 
1.5.5.1

