From 938628e2ea5bb84f87a304c432c105a790ea62b1 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Thu, 10 May 2012 11:27:21 -0700
Subject: [PATCH 093/248] lttng-instrumentation/lttng-instrumentation-s390

LTTng - s390 instrumentation

Changelog :
- added syscall entry/exit instrumentation.
- 2.6.37: large update (style changes in mainline). Added
  space_switch_exception.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/s390/kernel/ptrace.c   |    6 ++++++
 arch/s390/kernel/sys_s390.c |    5 +++++
 arch/s390/kernel/traps.c    |   39 ++++++++++++++++++++++++++++++++-------
 arch/s390/mm/fault.c        |   10 ++++++++++
 4 files changed, 53 insertions(+), 7 deletions(-)

diff --git a/arch/s390/kernel/ptrace.c b/arch/s390/kernel/ptrace.c
index 02f300f..f4191d9 100644
--- a/arch/s390/kernel/ptrace.c
+++ b/arch/s390/kernel/ptrace.c
@@ -46,6 +46,9 @@ enum s390_regset {
 	REGSET_GENERAL_EXTENDED,
 };
 
+DEFINE_TRACE(syscall_entry);
+DEFINE_TRACE(syscall_exit);
+
 void update_per_regs(struct task_struct *task)
 {
 	struct pt_regs *regs = task_pt_regs(task);
@@ -721,6 +724,7 @@ asmlinkage long do_syscall_trace_enter(struct pt_regs *regs)
 	/* Do the secure computing check first. */
 	secure_computing(regs->gprs[2]);
 
+	trace_syscall_entry(regs, regs->gprs[2]);
 	/*
 	 * The sysc_tracesys code in entry.S stored the system
 	 * call number to gprs[2].
@@ -750,6 +754,8 @@ asmlinkage long do_syscall_trace_enter(struct pt_regs *regs)
 
 asmlinkage void do_syscall_trace_exit(struct pt_regs *regs)
 {
+	trace_syscall_exit(regs->gprs[2]);
+
 	audit_syscall_exit(regs);
 
 	if (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))
diff --git a/arch/s390/kernel/sys_s390.c b/arch/s390/kernel/sys_s390.c
index 78ea194..65ccadf 100644
--- a/arch/s390/kernel/sys_s390.c
+++ b/arch/s390/kernel/sys_s390.c
@@ -29,9 +29,12 @@
 #include <linux/personality.h>
 #include <linux/unistd.h>
 #include <linux/ipc.h>
+#include <trace/ipc.h>
 #include <asm/uaccess.h>
 #include "entry.h"
 
+DEFINE_TRACE(ipc_call);
+
 /*
  * Perform the mmap() system call. Linux for S/390 isn't able to handle more
  * than 5 system call parameters, so this system call uses a memory block
@@ -65,6 +68,8 @@ out:
 SYSCALL_DEFINE5(s390_ipc, uint, call, int, first, unsigned long, second,
 		unsigned long, third, void __user *, ptr)
 {
+        trace_ipc_call(call, first);
+
 	if (call >> 16)
 		return -EINVAL;
 	/* The s390 sys_ipc variant has only five parameters instead of six
diff --git a/arch/s390/kernel/traps.c b/arch/s390/kernel/traps.c
index 77cdf42..1101fd8 100644
--- a/arch/s390/kernel/traps.c
+++ b/arch/s390/kernel/traps.c
@@ -5,6 +5,7 @@
  *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
  *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com),
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/kernel/traps.c"
  *    Copyright (C) 1991, 1992 Linus Torvalds
@@ -33,6 +34,7 @@
 #include <linux/kprobes.h>
 #include <linux/bug.h>
 #include <linux/utsname.h>
+#include <trace/trap.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <linux/atomic.h>
@@ -60,6 +62,12 @@ static int kstack_depth_to_print = 20;
 #endif /* CONFIG_64BIT */
 
 /*
+ * Also used in fault.c.
+ */
+DEFINE_TRACE(trap_entry);
+DEFINE_TRACE(trap_exit);
+
+/*
  * For show_trace we have tree different stack to consider:
  *   - the panic stack which is used if the kernel stack has overflown
  *   - the asynchronous interrupt stack (cpu related)
@@ -302,6 +310,8 @@ static void __kprobes do_trap(struct pt_regs *regs,
 		       regs->int_code, si_signo) == NOTIFY_STOP)
 		return;
 
+	trace_trap_entry(regs, pgm_int_code & 0xffff);
+
         if (regs->psw.mask & PSW_MASK_PSTATE) {
 		info.si_signo = si_signo;
 		info.si_errno = 0;
@@ -318,11 +328,14 @@ static void __kprobes do_trap(struct pt_regs *regs,
 			enum bug_trap_type btt;
 
 			btt = report_bug(regs->psw.addr & PSW_ADDR_INSN, regs);
-			if (btt == BUG_TRAP_TYPE_WARN)
+			if (btt == BUG_TRAP_TYPE_WARN) {
+				trace_trap_exit();
 				return;
+			}
 			die(regs, str);
 		}
         }
+	trace_trap_exit();
 }
 
 void __kprobes do_per_trap(struct pt_regs *regs)
@@ -412,9 +425,11 @@ static void __kprobes illegal_op(struct pt_regs *regs)
 
 	location = get_psw_address(regs);
 
+	trace_trap_entry(regs, pgm_int_code & 0xffff);
+
 	if (regs->psw.mask & PSW_MASK_PSTATE) {
 		if (get_user(*((__u16 *) opcode), (__u16 __user *) location))
-			return;
+			goto end;
 		if (*((__u16 *) opcode) == S390_BREAKPOINT_U16) {
 			if (current->ptrace) {
 				info.si_signo = SIGTRAP;
@@ -427,24 +442,24 @@ static void __kprobes illegal_op(struct pt_regs *regs)
 #ifdef CONFIG_MATHEMU
 		} else if (opcode[0] == 0xb3) {
 			if (get_user(*((__u16 *) (opcode+2)), location+1))
-				return;
+				goto end;
 			signal = math_emu_b3(opcode, regs);
                 } else if (opcode[0] == 0xed) {
 			if (get_user(*((__u32 *) (opcode+2)),
 				     (__u32 __user *)(location+1)))
-				return;
+				goto end;
 			signal = math_emu_ed(opcode, regs);
 		} else if (*((__u16 *) opcode) == 0xb299) {
 			if (get_user(*((__u16 *) (opcode+2)), location+1))
-				return;
+				goto end;
 			signal = math_emu_srnm(opcode, regs);
 		} else if (*((__u16 *) opcode) == 0xb29c) {
 			if (get_user(*((__u16 *) (opcode+2)), location+1))
-				return;
+				goto end;
 			signal = math_emu_stfpc(opcode, regs);
 		} else if (*((__u16 *) opcode) == 0xb29d) {
 			if (get_user(*((__u16 *) (opcode+2)), location+1))
-				return;
+				goto end;
 			signal = math_emu_lfpc(opcode, regs);
 #endif
 		} else
@@ -468,6 +483,8 @@ static void __kprobes illegal_op(struct pt_regs *regs)
 #endif
 	if (signal)
 		do_trap(regs, signal, ILL_ILLOPC, "illegal operation");
+end:
+	trace_trap_exit();
 }
 
 
@@ -480,6 +497,8 @@ void specification_exception(struct pt_regs *regs)
 
 	location = (__u16 __user *) get_psw_address(regs);
 
+	trace_trap_entry(regs, pgm_int_code & 0xffff);
+
         if (regs->psw.mask & PSW_MASK_PSTATE) {
 		get_user(*((__u16 *) opcode), location);
 		switch (opcode[0]) {
@@ -516,6 +535,7 @@ void specification_exception(struct pt_regs *regs)
 		do_fp_trap(regs, current->thread.fp_regs.fpc);
 	else if (signal)
 		do_trap(regs, signal, ILL_ILLOPN, "specification exception");
+	trace_trap_exit();
 }
 #else
 DO_ERROR_INFO(specification_exception, SIGILL, ILL_ILLOPN,
@@ -529,6 +549,8 @@ static void data_exception(struct pt_regs *regs)
 
 	location = get_psw_address(regs);
 
+	trace_trap_entry(regs, pgm_int_code & 0xffff);
+
 	if (MACHINE_HAS_IEEE)
 		asm volatile("stfpc %0" : "=m" (current->thread.fp_regs.fpc));
 
@@ -595,15 +617,18 @@ static void data_exception(struct pt_regs *regs)
 		do_fp_trap(regs, current->thread.fp_regs.fpc);
 	else if (signal)
 		do_trap(regs, signal, ILL_ILLOPN, "data exception");
+	trace_trap_exit();
 }
 
 static void space_switch_exception(struct pt_regs *regs)
 {
+	trace_trap_entry(regs, pgm_int_code & 0xffff);
 	/* Set user psw back to home space mode. */
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		regs->psw.mask |= PSW_ASC_HOME;
 	/* Send SIGILL. */
 	do_trap(regs, SIGILL, ILL_PRVOPC, "space switch event");
+	trace_trap_exit();
 }
 
 void __kprobes kernel_stack_overflow(struct pt_regs * regs)
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index 46ef3fd..1a7125e 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -5,6 +5,7 @@
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Hartmut Penner (hp@de.ibm.com)
  *               Ulrich Weigand (uweigand@de.ibm.com)
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/mm/fault.c"
  *    Copyright (C) 1995  Linus Torvalds
@@ -31,6 +32,7 @@
 #include <linux/kprobes.h>
 #include <linux/uaccess.h>
 #include <linux/hugetlb.h>
+#include <trace/fault.h>
 #include <asm/asm-offsets.h>
 #include <asm/pgtable.h>
 #include <asm/irq.h>
@@ -38,6 +40,11 @@
 #include <asm/facility.h>
 #include "../kernel/entry.h"
 
+DEFINE_TRACE(page_fault_entry);
+DEFINE_TRACE(page_fault_exit);
+DEFINE_TRACE(page_fault_nosem_entry);
+DEFINE_TRACE(page_fault_nosem_exit);
+
 #ifndef CONFIG_64BIT
 #define __FAIL_ADDR_MASK 0x7ffff000
 #define __SUBCODE_MASK 0x0200
@@ -225,7 +232,10 @@ static noinline void do_fault_error(struct pt_regs *regs, int fault)
 			/* User mode accesses just cause a SIGSEGV */
 			si_code = (fault == VM_FAULT_BADMAP) ?
 				SEGV_MAPERR : SEGV_ACCERR;
+			trace_page_fault_nosem_entry(regs, int_code & 0xffff,
+						     trans_exc_code);
 			do_sigsegv(regs, si_code);
+			trace_page_fault_nosem_exit();
 			return;
 		}
 	case VM_FAULT_BADCONTEXT:
-- 
1.7.0.4

