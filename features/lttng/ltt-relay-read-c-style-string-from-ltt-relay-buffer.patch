From 83fe41a09e8f1a89d0bc1e2991b58808fc3294f3 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:57 -0400
Subject: [PATCH 190/391] ltt-relay-read-c-style-string-from-ltt-relay-buffer

ltt relay read c style string from ltt relay buffer

C-style string which is written to ltt-relay buffer is not in
continuous memory region, we implement ltt_relay_read_cstr()
read it.

Update by Mathieu Desnoyers :

if orig_offset is >= buf->chan->alloc_size, this mask will make
the return offset - orig_offset; return a huge value. It's not expected
isn't it ?

That should be :

offset &= buf->chan->alloc_size - 1;
orig_offset = offset;

instead. This assumes the read will never cross subbuffers, which is
ensured by the WARN_ON below.

Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-relay.h |    3 +++
 ltt/ltt-relay-alloc.c     |   45 +++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 48 insertions(+), 0 deletions(-)

diff --git a/include/linux/ltt-relay.h b/include/linux/ltt-relay.h
index 480a7a0..4bea043 100644
--- a/include/linux/ltt-relay.h
+++ b/include/linux/ltt-relay.h
@@ -151,6 +151,9 @@ extern void _ltt_relay_write(struct rchan_buf *buf, size_t offset,
 extern int ltt_relay_read(struct rchan_buf *buf, size_t offset,
 	void *dest, size_t len);
 
+extern int ltt_relay_read_cstr(struct rchan_buf *buf, size_t offset,
+	void *dest, size_t len);
+
 extern struct buf_page *ltt_relay_read_get_page(struct rchan_buf *buf,
 	size_t offset);
 
diff --git a/ltt/ltt-relay-alloc.c b/ltt/ltt-relay-alloc.c
index 3c45897..d404ca4 100644
--- a/ltt/ltt-relay-alloc.c
+++ b/ltt/ltt-relay-alloc.c
@@ -574,6 +574,51 @@ int ltt_relay_read(struct rchan_buf *buf, size_t offset,
 EXPORT_SYMBOL_GPL(ltt_relay_read);
 
 /**
+ * ltt_relay_read_cstr - read a C-style string from ltt_relay_buffer.
+ * @buf : buffer
+ * @offset : offset within the buffer
+ * @dest : destination address
+ * @len : destination's length
+ *
+ * return string's length
+ */
+int ltt_relay_read_cstr(struct rchan_buf *buf, size_t offset,
+		void *dest, size_t len)
+{
+	struct buf_page *page;
+	ssize_t pagecpy, pagelen, strpagelen, orig_offset;
+	char *str;
+
+	offset &= buf->chan->alloc_size - 1;
+	orig_offset = offset;
+	page = buf->rpage;
+	for (;;) {
+		page = ltt_relay_cache_page(buf, &buf->rpage, page, offset);
+		str = (char *)page->virt + (offset & ~PAGE_MASK);
+		pagelen = PAGE_SIZE - (offset & ~PAGE_MASK);
+		strpagelen = strnlen(str, pagelen);
+		if (len) {
+			pagecpy = min_t(size_t, len, strpagelen);
+			memcpy(dest, str, pagecpy);
+			len -= pagecpy;
+			dest += pagecpy;
+		}
+		offset += strpagelen;
+		if (strpagelen < pagelen)
+			break;
+		/*
+		 * Underlying layer should never ask for reads across
+		 * subbuffers.
+		 */
+		WARN_ON(offset >= buf->chan->alloc_size);
+	}
+	if (len)
+		((char *)dest)[0] = 0;
+	return offset - orig_offset;
+}
+EXPORT_SYMBOL_GPL(ltt_relay_read_cstr);
+
+/**
  * ltt_relay_read_get_page - Get a whole page to read from
  * @buf : buffer
  * @offset : offset within the buffer
-- 
1.6.5.2

