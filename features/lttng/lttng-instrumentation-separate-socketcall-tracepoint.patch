From c463db192616f9898b33f7817c66aa4e15a802a6 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:47 -0400
Subject: [PATCH 170/391] lttng-instrumentation-separate-socketcall-tracepoint

Now lttng trace only sys_socket_call for sys_socket, sys_bind and others.
But on some arch(for ex, ia64) which lacks of sys_socket_call, we can't get
those syscall traced.

This patch add separate socketcall tracers to sys_socket, sys_bind, etc.
So people who using ia64(and other arch without sys_socket_call) can trace
each socket calls.

Another benefit is that we can get detail information for those socket calls
now.(we can see only arg1 before this patch)

Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/trace/socket.h |   65 ++++++++++++++++++++++++++++++++++++++++++-----
 net/socket.c           |   63 ++++++++++++++++++++++++++++++++++------------
 2 files changed, 104 insertions(+), 24 deletions(-)

diff --git a/include/trace/socket.h b/include/trace/socket.h
index 228b5a7..4e8a324 100644
--- a/include/trace/socket.h
+++ b/include/trace/socket.h
@@ -4,21 +4,72 @@
 #include <net/sock.h>
 #include <linux/tracepoint.h>
 
+DECLARE_TRACE(socket_create,
+	TP_PROTO(int family, int type, int protocol, struct socket *sock,
+	int ret),
+	TP_ARGS(family, type, protocol, sock, ret));
+
+DECLARE_TRACE(socket_bind,
+	TP_PROTO(int fd, struct sockaddr __user *umyaddr, int addrlen, int ret),
+	TP_ARGS(fd, umyaddr, addrlen, ret));
+
+DECLARE_TRACE(socket_connect,
+	TP_PROTO(int fd, struct sockaddr __user *uservaddr, int addrlen,
+	int ret),
+	TP_ARGS(fd, uservaddr, addrlen, ret));
+
+DECLARE_TRACE(socket_listen,
+	TP_PROTO(int fd, int backlog, int ret),
+	TP_ARGS(fd, backlog, ret));
+
+DECLARE_TRACE(socket_accept,
+	TP_PROTO(int fd, struct sockaddr __user *upeer_sockaddr,
+	int __user *upeer_addrlen, int flags, int ret),
+	TP_ARGS(fd, upeer_sockaddr, upeer_addrlen, flags, ret));
+
+DECLARE_TRACE(socket_getsockname,
+	TP_PROTO(int fd, struct sockaddr __user *usockaddr,
+	int __user *usockaddr_len, int ret),
+	TP_ARGS(fd, usockaddr, usockaddr_len, ret));
+
+DECLARE_TRACE(socket_getpeername,
+	TP_PROTO(int fd, struct sockaddr __user *usockaddr,
+	int __user *usockaddr_len, int ret),
+	TP_ARGS(fd, usockaddr, usockaddr_len, ret));
+
+DECLARE_TRACE(socket_socketpair,
+	TP_PROTO(int family, int type, int protocol, int __user *usockvec,
+	int ret),
+	TP_ARGS(family, type, protocol, usockvec, ret));
+
 DECLARE_TRACE(socket_sendmsg,
 	TP_PROTO(struct socket *sock, struct msghdr *msg, size_t size, int ret),
 	TP_ARGS(sock, msg, size, ret));
+
 DECLARE_TRACE(socket_recvmsg,
-	TP_PROTO(struct socket *sock, struct msghdr *msg, size_t size, int flags,
-		int ret),
+	TP_PROTO(struct socket *sock, struct msghdr *msg, size_t size,
+		int flags, int ret),
 	TP_ARGS(sock, msg, size, flags, ret));
-DECLARE_TRACE(socket_create,
-	TP_PROTO(struct socket *sock, int fd),
-	TP_ARGS(sock, fd));
+
+DECLARE_TRACE(socket_setsockopt,
+	TP_PROTO(int fd, int level, int optname, char __user *optval,
+	int optlen, int ret),
+	TP_ARGS(fd, level, optname, optval, optlen, ret));
+
+DECLARE_TRACE(socket_getsockopt,
+	TP_PROTO(int fd, int level, int optname, char __user *optval,
+	int __user *optlen, int ret),
+	TP_ARGS(fd, level, optname, optval, optlen, ret));
+
+DECLARE_TRACE(socket_shutdown,
+	TP_PROTO(int fd, int how, int ret),
+	TP_ARGS(fd, how, ret));
+
 /*
  * socket_call
  *
- * TODO : This tracepoint should be expanded to cover each element of the
- * switch in sys_socketcall().
+ * We also trace socket_call so we can know which syscall is used by user
+ * (socket_call or sock_send...)
  */
 DECLARE_TRACE(socket_call,
 	TP_PROTO(int call, unsigned long a0),
diff --git a/net/socket.c b/net/socket.c
index 77bf612..741373d 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -164,9 +164,19 @@ static const struct net_proto_family *net_families[NPROTO] __read_mostly;
 
 static DEFINE_PER_CPU(int, sockets_in_use) = 0;
 
+DEFINE_TRACE(socket_create);
+DEFINE_TRACE(socket_bind);
+DEFINE_TRACE(socket_connect);
+DEFINE_TRACE(socket_listen);
+DEFINE_TRACE(socket_accept);
+DEFINE_TRACE(socket_getsockname);
+DEFINE_TRACE(socket_getpeername);
+DEFINE_TRACE(socket_socketpair);
 DEFINE_TRACE(socket_sendmsg);
 DEFINE_TRACE(socket_recvmsg);
-DEFINE_TRACE(socket_create);
+DEFINE_TRACE(socket_setsockopt);
+DEFINE_TRACE(socket_getsockopt);
+DEFINE_TRACE(socket_shutdown);
 DEFINE_TRACE(socket_call);
 
 /*
@@ -1313,8 +1323,10 @@ SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
 	BUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);
 
 	flags = type & ~SOCK_TYPE_MASK;
-	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
-		return -EINVAL;
+	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK)) {
+		retval = -EINVAL;
+		goto out;
+	}
 	type &= SOCK_TYPE_MASK;
 
 	if (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))
@@ -1328,13 +1340,12 @@ SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
 	if (retval < 0)
 		goto out_release;
 
-	trace_socket_create(sock, retval);
-out:
-	/* It may be already another descriptor 8) Not kernel problem. */
-	return retval;
-
+	goto out;
 out_release:
 	sock_release(sock);
+out:
+	trace_socket_create(family, type, protocol, sock, retval);
+	/* It may be already another descriptor 8) Not kernel problem. */
 	return retval;
 }
 
@@ -1351,8 +1362,10 @@ SYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,
 	int flags;
 
 	flags = type & ~SOCK_TYPE_MASK;
-	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
-		return -EINVAL;
+	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK)) {
+		err = -EINVAL;
+		goto out;
+	}
 	type &= SOCK_TYPE_MASK;
 
 	if (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))
@@ -1401,17 +1414,18 @@ SYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,
 	if (!err)
 		err = put_user(fd2, &usockvec[1]);
 	if (!err)
-		return 0;
+		goto out;
 
 	sys_close(fd2);
 	sys_close(fd1);
-	return err;
+	goto out;
 
 out_release_both:
 	sock_release(sock2);
 out_release_1:
 	sock_release(sock1);
 out:
+	trace_socket_socketpair(family, type, protocol, usockvec, err);
 	return err;
 }
 
@@ -1443,6 +1457,7 @@ SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)
 		}
 		fput_light(sock->file, fput_needed);
 	}
+	trace_socket_bind(fd, umyaddr, addrlen, err);
 	return err;
 }
 
@@ -1470,6 +1485,7 @@ SYSCALL_DEFINE2(listen, int, fd, int, backlog)
 
 		fput_light(sock->file, fput_needed);
 	}
+	trace_socket_listen(fd, backlog, err);
 	return err;
 }
 
@@ -1493,8 +1509,10 @@ SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,
 	int err, len, newfd, fput_needed;
 	struct sockaddr_storage address;
 
-	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
-		return -EINVAL;
+	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK)) {
+		err = -EINVAL;
+		goto out;
+	}
 
 	if (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))
 		flags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;
@@ -1551,6 +1569,7 @@ SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,
 out_put:
 	fput_light(sock->file, fput_needed);
 out:
+	trace_socket_accept(fd, upeer_sockaddr, upeer_addrlen, flags, err);
 	return err;
 out_fd:
 	fput(newfile);
@@ -1600,6 +1619,7 @@ SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
 out_put:
 	fput_light(sock->file, fput_needed);
 out:
+	trace_socket_connect(fd, uservaddr, addrlen, err);
 	return err;
 }
 
@@ -1631,6 +1651,7 @@ SYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,
 out_put:
 	fput_light(sock->file, fput_needed);
 out:
+	trace_socket_getsockname(fd, usockaddr, usockaddr_len, err);
 	return err;
 }
 
@@ -1651,7 +1672,7 @@ SYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,
 		err = security_socket_getpeername(sock);
 		if (err) {
 			fput_light(sock->file, fput_needed);
-			return err;
+			goto out;
 		}
 
 		err =
@@ -1662,6 +1683,8 @@ SYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,
 						usockaddr_len);
 		fput_light(sock->file, fput_needed);
 	}
+out:
+	trace_socket_getpeername(fd, usockaddr, usockaddr_len, err);
 	return err;
 }
 
@@ -1788,8 +1811,10 @@ SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,
 	int err, fput_needed;
 	struct socket *sock;
 
-	if (optlen < 0)
-		return -EINVAL;
+	if (optlen < 0) {
+		err = -EINVAL;
+		goto out;
+	}
 
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (sock != NULL) {
@@ -1808,6 +1833,8 @@ SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,
 out_put:
 		fput_light(sock->file, fput_needed);
 	}
+out:
+	trace_socket_setsockopt(fd, level, optname, optval, optlen, err);
 	return err;
 }
 
@@ -1839,6 +1866,7 @@ SYSCALL_DEFINE5(getsockopt, int, fd, int, level, int, optname,
 out_put:
 		fput_light(sock->file, fput_needed);
 	}
+	trace_socket_getsockopt(fd, level, optname, optval, optlen, err);
 	return err;
 }
 
@@ -1858,6 +1886,7 @@ SYSCALL_DEFINE2(shutdown, int, fd, int, how)
 			err = sock->ops->shutdown(sock, how);
 		fput_light(sock->file, fput_needed);
 	}
+	trace_socket_shutdown(fd, how, err);
 	return err;
 }
 
-- 
1.6.5.2

