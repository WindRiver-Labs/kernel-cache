From 506195217eb0ebd68520a7f018a5cdbbb160ffcb Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:28:08 -0400
Subject: [PATCH 324/391] lttng-variable-size-sb-support

lttng variable size sb support

* support variable-sized subbuffers
* count "data_size" instead of "lost_size" in sb header.
* Change trace format to 2.5.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-tracer.h |   24 +++++++++++++-----------
 ltt/ltt-ascii.c            |    8 +++++---
 ltt/ltt-relay-lockless.c   |    7 ++++---
 ltt/ltt-relay-lockless.h   |   17 +++++++++++++----
 ltt/ltt-relay-vfs.c        |   27 ++++++++++++++++-----------
 5 files changed, 51 insertions(+), 32 deletions(-)

diff --git a/include/linux/ltt-tracer.h b/include/linux/ltt-tracer.h
index 2b19b4c..e141b85 100644
--- a/include/linux/ltt-tracer.h
+++ b/include/linux/ltt-tracer.h
@@ -281,8 +281,8 @@ struct ltt_subbuffer_header {
 					 * used all along the trace.
 					 */
 	uint32_t freq_scale;		/* Frequency scaling (divisor) */
-	uint32_t lost_size;		/* Size unused at end of subbuffer */
-	uint32_t buf_size;		/* Size of this subbuffer */
+	uint32_t data_size;		/* Size of data in subbuffer */
+	uint32_t sb_size;		/* Subbuffer size (include padding) */
 	uint32_t events_lost;		/*
 					 * Events lost in this subbuffer since
 					 * the beginning of the trace.
@@ -534,7 +534,7 @@ size_t ltt_read_event_header(struct ltt_chanbuf_alloc *bufa, long buf_offset,
 #define LTT_DEFAULT_N_SUBBUFS_HIGH	2
 #define LTT_TRACER_MAGIC_NUMBER		0x00D6B7ED
 #define LTT_TRACER_VERSION_MAJOR	2
-#define LTT_TRACER_VERSION_MINOR	4
+#define LTT_TRACER_VERSION_MINOR	5
 
 /**
  * ltt_write_trace_header - Write trace header
@@ -702,14 +702,16 @@ static __inline__ void ltt_dump_idt_table(void *call_data)
 
 /* Relay IOCTL */
 
-/* Get the next sub buffer that can be read. */
-#define RELAY_GET_SUBBUF		_IOR(0xF5, 0x00, __u32)
-/* Release the oldest reserved (by "get") sub buffer. */
-#define RELAY_PUT_SUBBUF		_IOW(0xF5, 0x01, __u32)
-/* returns the number of sub buffers in the per cpu channel. */
-#define RELAY_GET_N_SUBBUFS		_IOR(0xF5, 0x02, __u32)
-/* returns the size of the sub buffers. */
-#define RELAY_GET_SUBBUF_SIZE		_IOR(0xF5, 0x03, __u32)
+/* Get the next sub-buffer that can be read. */
+#define RELAY_GET_SB			_IOR(0xF5, 0x00, __u32)
+/* Release the oldest reserved (by "get") sub-buffer. */
+#define RELAY_PUT_SB			_IOW(0xF5, 0x01, __u32)
+/* returns the number of sub-buffers in the per cpu channel. */
+#define RELAY_GET_N_SB			_IOR(0xF5, 0x02, __u32)
+/* returns the size of the current sub-buffer. */
+#define RELAY_GET_SB_SIZE		_IOR(0xF5, 0x03, __u32)
+/* returns the maximum size for sub-buffers. */
+#define RELAY_GET_MAX_SB_SIZE		_IOR(0xF5, 0x04, __u32)
 
 #endif /* CONFIG_LTT */
 
diff --git a/ltt/ltt-ascii.c b/ltt/ltt-ascii.c
index 9df4625..eeb7033 100644
--- a/ltt/ltt-ascii.c
+++ b/ltt/ltt-ascii.c
@@ -87,15 +87,17 @@ struct ltt_relay_iter {
 	int nr_refs;
 };
 
+/*
+ * offset of 0 in subbuffer means "subbuf size" (filled subbuffer).
+ */
 static int is_subbuffer_offset_end(struct ltt_relay_cpu_iter *citer,
 				   long offset)
 {
 	struct ltt_chan *chan = container_of(citer->buf->a.chan,
 					     struct ltt_chan, a);
-	long sub_offset = SUBBUF_OFFSET(offset, chan);
+	long sub_offset = SUBBUF_OFFSET(offset - 1, chan) + 1;
 
-	return (sub_offset + citer->header->lost_size
-		>= citer->buf->a.chan->sb_size);
+	return (sub_offset <= citer->header->data_size);
 }
 
 static u64 calculate_tsc(u64 pre_tsc, u64 read_tsc, unsigned int rflags)
diff --git a/ltt/ltt-relay-lockless.c b/ltt/ltt-relay-lockless.c
index d1ff928..2bfa6b8 100644
--- a/ltt/ltt-relay-lockless.c
+++ b/ltt/ltt-relay-lockless.c
@@ -87,8 +87,7 @@ void ltt_buffer_begin(struct ltt_chanbuf *buf, u64 tsc, unsigned int subbuf_idx)
 				subbuf_idx * chan->a.sb_size);
 
 	header->cycle_count_begin = tsc;
-	header->lost_size = 0xFFFFFFFF; /* for debugging */
-	header->buf_size = chan->a.sb_size;
+	header->data_size = 0xFFFFFFFF; /* for debugging */
 	ltt_write_trace_header(chan->a.trace, header);
 }
 
@@ -105,8 +104,10 @@ void ltt_buffer_end(struct ltt_chanbuf *buf, u64 tsc, unsigned int offset,
 		(struct ltt_subbuffer_header *)
 			ltt_relay_offset_address(&buf->a,
 				subbuf_idx * chan->a.sb_size);
+	u32 data_size = SUBBUF_OFFSET(offset - 1, chan) + 1;
 
-	header->lost_size = SUBBUF_OFFSET((chan->a.sb_size - offset), chan);
+	header->data_size = data_size;
+	header->sb_size = PAGE_ALIGN(data_size);
 	header->cycle_count_end = tsc;
 	header->events_lost = local_read(&buf->events_lost);
 	header->subbuf_corrupt = local_read(&buf->corrupted_subbuffers);
diff --git a/ltt/ltt-relay-lockless.h b/ltt/ltt-relay-lockless.h
index e47b406..dae9023 100644
--- a/ltt/ltt-relay-lockless.h
+++ b/ltt/ltt-relay-lockless.h
@@ -314,6 +314,15 @@ int ltt_poll_deliver(struct ltt_chanbuf *buf, struct ltt_chan *chan)
 
 }
 
+static __inline__
+u32 get_read_sb_size(struct ltt_chanbuf *buf)
+{
+	struct ltt_subbuffer_header *header =
+		(struct ltt_subbuffer_header *)
+			ltt_relay_read_offset_address(&buf->a, 0);
+	return header->sb_size;
+}
+
 /*
  * returns 0 if reserve ok, or 1 if the slow path must be taken.
  */
@@ -434,9 +443,9 @@ void ltt_force_switch(struct ltt_chanbuf *buf, enum force_switch_mode mode)
 
 /*
  * for flight recording. must be called after relay_commit.
- * This function decrements de subbuffer's lost_size each time the commit count
- * reaches back the reserve offset (module subbuffer size). It is useful for
- * crash dump.
+ * This function increments the subbuffer's commit_seq counter each time the
+ * commit count reaches back the reserve offset (module subbuffer size). It is
+ * useful for crash dump.
  */
 #ifdef CONFIG_LTT_VMCORE
 static __inline__
@@ -525,7 +534,7 @@ void ltt_commit_slot(struct ltt_chanbuf *buf, struct ltt_chan *chan,
 
 	ltt_check_deliver(buf, chan, offset_end - 1, commit_count, endidx);
 	/*
-	 * Update lost_size for each commit. It's needed only for extracting
+	 * Update data_size for each commit. It's needed only for extracting
 	 * ltt buffers from vmcore, after crash.
 	 */
 	ltt_write_commit_counter(buf, chan, endidx, buf_offset,
diff --git a/ltt/ltt-relay-vfs.c b/ltt/ltt-relay-vfs.c
index daa6e74..3036ae1 100644
--- a/ltt/ltt-relay-vfs.c
+++ b/ltt/ltt-relay-vfs.c
@@ -109,15 +109,17 @@ static unsigned int ltt_poll(struct file *filp, poll_table *wait)
  *
  *	This ioctl implements three commands necessary for a minimal
  *	producer/consumer implementation :
- *	RELAY_GET_SUBBUF
- *		Get the next sub buffer that can be read. It never blocks.
- *	RELAY_PUT_SUBBUF
+ *	RELAY_GET_SB
+ *		Get the next sub-buffer that can be read. It never blocks.
+ *	RELAY_PUT_SB
  *		Release the currently read sub-buffer. Parameter is the last
  *		put subbuffer (returned by GET_SUBBUF).
- *	RELAY_GET_N_BUBBUFS
- *		returns the number of sub buffers in the per cpu channel.
- *	RELAY_GET_SUBBUF_SIZE
- *		returns the size of the sub buffers.
+ *	RELAY_GET_N_SB
+ *		returns the number of sub-buffers in the per cpu channel.
+ *	RELAY_GET_SB_SIZE
+ *		returns the size of the current sub-buffer.
+ *	RELAY_GET_MAX_SB_SIZE
+ *		returns the maximum size for sub-buffers.
  */
 static
 int ltt_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
@@ -127,7 +129,7 @@ int ltt_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
 	u32 __user *argp = (u32 __user *)arg;
 
 	switch (cmd) {
-	case RELAY_GET_SUBBUF:
+	case RELAY_GET_SB:
 	{
 		unsigned long consumed;
 		int ret;
@@ -139,7 +141,7 @@ int ltt_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
 			return put_user((u32)consumed, argp);
 		break;
 	}
-	case RELAY_PUT_SUBBUF:
+	case RELAY_PUT_SB:
 	{
 		u32 uconsumed_old;
 		int ret;
@@ -157,10 +159,13 @@ int ltt_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
 			return ret;
 		break;
 	}
-	case RELAY_GET_N_SUBBUFS:
+	case RELAY_GET_N_SB:
 		return put_user((u32)buf->a.chan->n_sb, argp);
 		break;
-	case RELAY_GET_SUBBUF_SIZE:
+	case RELAY_GET_SB_SIZE:
+		return put_user(get_read_sb_size(buf), argp);
+		break;
+	case RELAY_GET_MAX_SB_SIZE:
 		return put_user((u32)buf->a.chan->sb_size, argp);
 		break;
 	default:
-- 
1.6.5.2

