From 52533d706a680d7e756e064452167bd6f01ba6a2 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:25:53 -0400
Subject: [PATCH 077/391] immediate-values/sparc64-immedate-values

commit f2b14974b823a9cd9b6f5c0d423945caa15de8a2
Author: David S. Miller <davem@davemloft.net>
Date:   Tue May 13 04:29:30 2008 -0700

We can only do byte sized values currently.

In order to support even 16-bit immediates we would need a 2
instruction sequence.

I believe that can be made to work with a suitable breakpoint or some
other kind of special patching sequence, but that isn't attempted
here.

[Mathieu]

Use _ASM_PTR and _ASM_UAPTR 32/64 bits compatibility macros.

Use "unsigned long" type to encode pointers, with uaxword on sparc64 and uaword
on sparc32.

Disable immediate values on gcc < 4.0.0, because it seems to have problem with
passing pointers as "i" inline asm constraint.

Relicense header to dual BSD / GPL v2 license.
Relicense C file to dual LGPL v2.1 / GPL v2 license.

Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/sparc/Kconfig                 |    1 +
 arch/sparc/Makefile                |    4 ++
 arch/sparc/include/asm/immediate.h |   48 ++++++++++++++++++++++++++++++
 arch/sparc/kernel/Makefile         |    1 +
 arch/sparc/kernel/immediate.c      |   57 ++++++++++++++++++++++++++++++++++++
 5 files changed, 111 insertions(+), 0 deletions(-)
 create mode 100644 arch/sparc/include/asm/immediate.h
 create mode 100644 arch/sparc/kernel/immediate.c

diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig
index be57fe3..e555449 100644
--- a/arch/sparc/Kconfig
+++ b/arch/sparc/Kconfig
@@ -56,6 +56,7 @@ config SPARC64
 	select HAVE_PERF_EVENTS
 	select PERF_USE_VMALLOC
 	select HAVE_TRACE_CLOCK
+	select HAVE_IMMEDIATE
 
 config ARCH_DEFCONFIG
 	string
diff --git a/arch/sparc/Makefile b/arch/sparc/Makefile
index a5e2bb9..334ad3f 100644
--- a/arch/sparc/Makefile
+++ b/arch/sparc/Makefile
@@ -55,6 +55,10 @@ KBUILD_CFLAGS += -m64 -pipe -mno-fpu -mcpu=ultrasparc -mcmodel=medlow   \
 KBUILD_CFLAGS += $(call cc-option,-mtune=ultrasparc3)
 KBUILD_AFLAGS += -m64 -mcpu=ultrasparc -Wa,--undeclared-regs
 
+# gcc 3.x has problems with passing symbol+offset in
+# asm "i" constraint.
+export USE_IMMEDIATE := $(call cc-ifversion, -ge, 0400, $(CONFIG_IMMEDIATE))
+
 ifeq ($(CONFIG_MCOUNT),y)
   KBUILD_CFLAGS += -pg
 endif
diff --git a/arch/sparc/include/asm/immediate.h b/arch/sparc/include/asm/immediate.h
new file mode 100644
index 0000000..ada9e95
--- /dev/null
+++ b/arch/sparc/include/asm/immediate.h
@@ -0,0 +1,48 @@
+#ifndef _ASM_SPARC_IMMEDIATE_H
+#define _ASM_SPARC_IMMEDIATE_H
+
+#include <asm/asm.h>
+
+/*
+ * Immediate values. Sparc64 architecture optimizations.
+ *
+ * (C) Copyright 2009 David Miller <davem@davemloft.net>
+ * (C) Copyright 2009 Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ *
+ * Dual BSD/GPL v2 license.
+ */
+
+struct __imv {
+	unsigned long var;
+	unsigned long imv;
+	unsigned char size;
+} __attribute__ ((packed));
+
+#define imv_read(name)							\
+	({								\
+		__typeof__(name##__imv) value;				\
+		BUILD_BUG_ON(sizeof(value) > 8);			\
+		switch (sizeof(value)) {				\
+		case 1:							\
+			asm(".section __imv,\"aw\",@progbits\n\t"	\
+					_ASM_UAPTR " %c1, 1f\n\t"	\
+					".byte 1\n\t"			\
+					".previous\n\t"			\
+					"1: mov 0, %0\n\t"		\
+				: "=r" (value)				\
+				: "i" (&name##__imv));			\
+			break;						\
+		case 2:							\
+		case 4:							\
+		case 8:	value = name##__imv;				\
+			break;						\
+		};							\
+		value;							\
+	})
+
+#define imv_cond(name)	imv_read(name)
+#define imv_cond_end()
+
+extern int arch_imv_update(const struct __imv *imv, int early);
+
+#endif /* _ASM_SPARC_IMMEDIATE_H */
diff --git a/arch/sparc/kernel/Makefile b/arch/sparc/kernel/Makefile
index 0c2dc1f..b1a389e 100644
--- a/arch/sparc/kernel/Makefile
+++ b/arch/sparc/kernel/Makefile
@@ -104,6 +104,7 @@ obj-$(CONFIG_SPARC64_PCI)    += pci_sun4v.o pci_sun4v_asm.o pci_fire.o
 obj-$(CONFIG_PCI_MSI)        += pci_msi.o
 
 obj-$(CONFIG_COMPAT)         += sys32.o sys_sparc32.o signal32.o
+obj-$(USE_IMMEDIATE)         += immediate.o
 
 # sparc64 cpufreq
 obj-$(CONFIG_US3_FREQ)  += us3_cpufreq.o
diff --git a/arch/sparc/kernel/immediate.c b/arch/sparc/kernel/immediate.c
new file mode 100644
index 0000000..8dfcf2d
--- /dev/null
+++ b/arch/sparc/kernel/immediate.c
@@ -0,0 +1,57 @@
+/*
+ * Immediate values. Sparc64 architecture optimizations.
+ *
+ * (C) Copyright 2009 David Miller <davem@davemloft.net>
+ * (C) Copyright 2009 Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ *
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/immediate.h>
+#include <linux/string.h>
+#include <linux/kprobes.h>
+
+#include <asm/system.h>
+
+int arch_imv_update(const struct __imv *imv, int early)
+{
+	unsigned long imv_vaddr = imv->imv;
+	unsigned long var_vaddr = imv->var;
+	u32 insn, *ip = (u32 *) imv_vaddr;
+
+	insn = *ip;
+
+#ifdef CONFIG_KPROBES
+	switch (imv->size) {
+	case 1:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (unlikely(!early &&
+		     (insn == BREAKPOINT_INSTRUCTION ||
+		      insn == BREAKPOINT_INSTRUCTION_2))) {
+		printk(KERN_WARNING "Immediate value in conflict with kprobe. "
+				    "Variable at %p, "
+				    "instruction at %p, size %u\n",
+				    ip, (void *)var_vaddr, imv->size);
+		return -EBUSY;
+	}
+#endif
+
+	switch (imv->size) {
+	case 1:
+		if ((insn & 0x1fff) == *(uint8_t *)var_vaddr)
+			return 0;
+		insn &= ~0x00001fff;
+		insn |= (u32) (*(uint8_t *)var_vaddr);
+		break;
+	default:
+		return -EINVAL;
+	}
+	*ip = insn;
+	flushi(ip);
+	return 0;
+}
-- 
1.6.5.2

