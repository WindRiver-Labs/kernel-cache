From a79e21c82fad296375239f314658ba3b9c69a1c7 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:25:27 -0400
Subject: [PATCH 033/390] lttng-core/lttng-optimize-write-to-page-function-remove-some-memcpy-calls

lttng-optimize-write-to-page-function-remove-some-memcpy-calls

Zhaolei :
> Hello, Mathieu
>
> Why not use instructions generated by gcc instead of memcpy on arch without
> 64bit write as:
> case 4: *(u32 *)dest = *(const u32 *)src;
>   break;
> case 8: *(u64 *)dest = *(const u64 *)src;
>   break;
>
> IMHO, even on arch without 64bit write, memcpy is more complex.

#include <inttypes.h>

char dest[100];
char src[100];

typedef uint64_t u64;
typedef uint32_t u32;

void gcc_u64(void)
{
        asm("/* begin */");
        *(u64 *)dest = *(const u64 *)src;
        asm("/* end */");
}


        movl    src, %eax
        movl    src+4, %edx
        movl    %eax, dest
        movl    %edx, dest+4


void twice_u32(void)
{
        asm("/* begin */");
        ((u32 *)dest)[0] = ((const u32 *)src)[0];
        ((u32 *)dest)[1] = ((const u32 *)src)[1];
        asm("/* end */");
}
        movl    src, %eax
        movl    %eax, dest
        movl    src+4, %eax
        movl    %eax, dest+4

gcc seems to do a better register scheduler than my code, so I think
it's not so bad. I will take your proposal.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Zhaolei <zhaolei@cn.fujitsu.com>
---
 include/linux/ltt-relay.h |   21 ++++++++++++---------
 1 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/include/linux/ltt-relay.h b/include/linux/ltt-relay.h
index 3b917ae..279103f 100644
--- a/include/linux/ltt-relay.h
+++ b/include/linux/ltt-relay.h
@@ -215,13 +215,16 @@ static inline void ltt_relay_do_copy(void *dest, const void *src, size_t len)
 	case 4:
 		*(u32 *)dest = *(const u32 *)src;
 		break;
-#if (BITS_PER_LONG == 64)
 	case 8:
 		*(u64 *)dest = *(const u64 *)src;
 		break;
-#endif
 	default:
-		memcpy(dest, src, len);
+		/*
+		 * What we really want here is an inline memcpy, but we don't
+		 * have constants, so gcc generally uses a function call.
+		 */
+		for (; len > 0; len--)
+			*(u8 *)dest++ = *(const u8 *)src++;
 	}
 }
 #else
@@ -256,19 +259,19 @@ static inline void ltt_relay_do_copy(void *dest, const void *src, size_t len)
 			goto memcpy_fallback;
 		*(u32 *)dest = *(const u32 *)src;
 		break;
-#if (BITS_PER_LONG == 64)
 	case 8:
 		if (unlikely(!addr_aligned(dest, src, 8)))
 			goto memcpy_fallback;
 		*(u64 *)dest = *(const u64 *)src;
 		break;
-#endif
 	default:
-		goto memcpy_fallback;
+		/*
+		 * What we really want here is an inline memcpy, but we don't
+		 * have constants, so gcc generally uses a function call.
+		 */
+		for (; len > 0; len--)
+			*(u8 *)dest++ = *(const u8 *)src++;
 	}
-	return;
-memcpy_fallback:
-	memcpy(dest, src, len);
 }
 #endif
 
-- 
1.6.5.2

