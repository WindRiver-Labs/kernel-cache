From 1d189b851d241a2adf3210c0ff2ce013178adc66 Mon Sep 17 00:00:00 2001
From: Vu Tran <vu.tran@windriver.com>
Date: Wed, 5 Nov 2008 18:53:17 -0500
Subject: [PATCH] sparc64 lttng hooks

Add SPARC64 LTTng hooks and supporting functions.

Signed-off-by: Vu Tran <vu.tran@windriver.com>
Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 arch/sparc64/Makefile           |    1 +
 arch/sparc64/kernel/process.c   |    4 ++++
 arch/sparc64/kernel/ptrace.c    |    6 ++++++
 arch/sparc64/kernel/sys_sparc.c |    3 +++
 arch/sparc64/kernel/syscalls.S  |   10 +++++-----
 arch/sparc64/kernel/time.c      |    5 +++++
 arch/sparc64/kernel/traps.c     |   17 +++++++++++++++++
 7 files changed, 41 insertions(+), 5 deletions(-)

diff --git a/arch/sparc64/Makefile b/arch/sparc64/Makefile
index 5fae04e..61be374 100644
--- a/arch/sparc64/Makefile
+++ b/arch/sparc64/Makefile
@@ -15,16 +15,17 @@ CPPFLAGS_vmlinux.lds += -m64 -Usparc
 
 LDFLAGS		:= -m elf64_sparc
 
 KBUILD_CFLAGS += -m64 -pipe -mno-fpu -mcpu=ultrasparc -mcmodel=medlow \
 	-ffixed-g4 -ffixed-g5 -fcall-used-g7 -Wno-sign-compare \
 	-Wa,--undeclared-regs
 KBUILD_CFLAGS += $(call cc-option,-mtune=ultrasparc3)
 KBUILD_AFLAGS += -m64 -mcpu=ultrasparc -Wa,--undeclared-regs
+export USE_IMMEDIATE := $(CONFIG_IMMEDIATE)
 
 # gcc 3.x has problems with passing symbol+offset in
 # asm "i" constraint.
 export USE_IMMEDIATE := $(call cc-ifversion, -ge, 0400, $(CONFIG_IMMEDIATE))
 
 ifeq ($(CONFIG_MCOUNT),y)
   KBUILD_CFLAGS += -pg
 endif
diff --git a/arch/sparc64/kernel/process.c b/arch/sparc64/kernel/process.c
index 15f4178..6b6970e 100644
--- a/arch/sparc64/kernel/process.c
+++ b/arch/sparc64/kernel/process.c
@@ -25,16 +25,17 @@
 #include <linux/reboot.h>
 #include <linux/delay.h>
 #include <linux/compat.h>
 #include <linux/tick.h>
 #include <linux/init.h>
 #include <linux/cpu.h>
 #include <linux/elfcore.h>
 #include <linux/sysrq.h>
+#include <trace/sched.h>
 
 #include <asm/oplib.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <asm/page.h>
 #include <asm/pgalloc.h>
 #include <asm/pgtable.h>
 #include <asm/processor.h>
@@ -706,16 +707,19 @@ pid_t kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 			     "mov %3, %%g1\n\t"
 			     "t 0x6d\n\t"	   /* Linux/Sparc exit(). */
 			     /* Notreached by child. */
 			     "1:" :
 			     "=r" (retval) :
 			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED),
 			     "i" (__NR_exit),  "r" (fn), "r" (arg) :
 			     "g1", "g2", "g3", "o0", "o1", "memory", "cc");
+
+	trace_sched_kthread_create(fn, retval);
+
 	return retval;
 }
 
 typedef struct {
 	union {
 		unsigned int	pr_regs[32];
 		unsigned long	pr_dregs[16];
 	} pr_fr;
diff --git a/arch/sparc64/kernel/ptrace.c b/arch/sparc64/kernel/ptrace.c
index 10306e4..47e9895 100644
--- a/arch/sparc64/kernel/ptrace.c
+++ b/arch/sparc64/kernel/ptrace.c
@@ -21,16 +21,17 @@
 #include <linux/security.h>
 #include <linux/seccomp.h>
 #include <linux/audit.h>
 #include <linux/signal.h>
 #include <linux/regset.h>
 #include <linux/tracehook.h>
 #include <linux/compat.h>
 #include <linux/elf.h>
+#include <trace/syscall.h>
 
 #include <asm/asi.h>
 #include <asm/pgtable.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/psrcompat.h>
 #include <asm/visasm.h>
 #include <asm/spitfire.h>
@@ -1049,16 +1050,21 @@ long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 
 	return ret;
 }
 
 asmlinkage int syscall_trace(struct pt_regs *regs, int syscall_exit_p)
 {
 	int ret = 0;
 
+	if (!syscall_exit_p)
+		trace_syscall_entry(regs, (int)regs->u_regs[UREG_G1]);
+	else
+		trace_syscall_exit(regs->u_regs[UREG_I0]);
+
 	/* do the secure computing check first */
 	secure_computing(regs->u_regs[UREG_G1]);
 
 	if (unlikely(current->audit_context) && syscall_exit_p) {
 		unsigned long tstate = regs->tstate;
 		int result = AUDITSC_SUCCESS;
 
 		if (unlikely(tstate & (TSTATE_XCARRY | TSTATE_ICARRY)))
diff --git a/arch/sparc64/kernel/sys_sparc.c b/arch/sparc64/kernel/sys_sparc.c
index 39749e3..3712088 100644
--- a/arch/sparc64/kernel/sys_sparc.c
+++ b/arch/sparc64/kernel/sys_sparc.c
@@ -18,16 +18,17 @@
 #include <linux/mman.h>
 #include <linux/utsname.h>
 #include <linux/smp.h>
 #include <linux/slab.h>
 #include <linux/syscalls.h>
 #include <linux/ipc.h>
 #include <linux/personality.h>
 #include <linux/random.h>
+#include <trace/ipc.h>
 
 #include <asm/uaccess.h>
 #include <asm/utrap.h>
 #include <asm/perfctr.h>
 #include <asm/unistd.h>
 
 #include "entry.h"
 #include "systbls.h"
@@ -433,16 +434,18 @@ out:
  * This is really horribly ugly.
  */
 
 asmlinkage long sys_ipc(unsigned int call, int first, unsigned long second,
 			unsigned long third, void __user *ptr, long fifth)
 {
 	long err;
 
+	trace_ipc_call(call, first);
+
 	/* No need for backward compatibility. We can start fresh... */
 	if (call <= SEMCTL) {
 		switch (call) {
 		case SEMOP:
 			err = sys_semtimedop(first, ptr,
 					     (unsigned)second, NULL);
 			goto out;
 		case SEMTIMEDOP:
diff --git a/arch/sparc64/kernel/syscalls.S b/arch/sparc64/kernel/syscalls.S
index a2f2427..ba7eafb 100644
--- a/arch/sparc64/kernel/syscalls.S
+++ b/arch/sparc64/kernel/syscalls.S
@@ -57,17 +57,17 @@ sys_rt_sigreturn:
 sys32_rt_sigreturn:
 	add	%sp, PTREGS_OFF, %o0
 	call	do_rt_sigreturn32
 	 add	%o7, 1f-.-4, %o7
 	nop
 #endif
 	.align	32
 1:	ldx	[%g6 + TI_FLAGS], %l5
-	andcc	%l5, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
+	andcc	%l5, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
 	be,pt	%icc, rtrap
 	 nop
 	add	%sp, PTREGS_OFF, %o0
 	call	syscall_trace
 	 mov	1, %o1
 	ba,pt	%xcc, rtrap
 	 nop
 
@@ -196,17 +196,17 @@ linux_sparc_syscall32:
 	sll	%g1, 2, %l4				! IEU0	Group
 	srl	%i4, 0, %o4				! IEU1
 	lduw	[%l7 + %l4], %l7			! Load
 	srl	%i1, 0, %o1				! IEU0	Group
 	ldx	[%g6 + TI_FLAGS], %l0		! Load
 
 	srl	%i5, 0, %o5				! IEU1
 	srl	%i2, 0, %o2				! IEU0	Group
-	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
+	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
 	bne,pn	%icc, linux_syscall_trace32		! CTI
 	 mov	%i0, %l5				! IEU1
 	call	%l7					! CTI	Group brk forced
 	 srl	%i3, 0, %o3				! IEU0
 	ba,a,pt	%xcc, 3f
 
 	/* Linux native system calls enter here... */
 	.align	32
@@ -219,17 +219,17 @@ linux_sparc_syscall:
 	sll	%g1, 2, %l4				! IEU0	Group
 	mov	%i1, %o1				! IEU1
 	lduw	[%l7 + %l4], %l7			! Load
 4:	mov	%i2, %o2				! IEU0	Group
 	ldx	[%g6 + TI_FLAGS], %l0		! Load
 
 	mov	%i3, %o3				! IEU1
 	mov	%i4, %o4				! IEU0	Group
-	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
+	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
 	bne,pn	%icc, linux_syscall_trace		! CTI	Group
 	 mov	%i0, %l5				! IEU0
 2:	call	%l7					! CTI	Group brk forced
 	 mov	%i5, %o5				! IEU0
 	nop
 
 3:	stx	%o0, [%sp + PTREGS_OFF + PT_V9_I0]
 ret_sys_call:
@@ -243,32 +243,32 @@ ret_sys_call:
 	 * was invoked.
 	 */
 	ldub	[%g6 + TI_SYS_NOERROR], %l2
 	brnz,a,pn %l2, 80f
 	 stb	%g0, [%g6 + TI_SYS_NOERROR]
 
 	cmp	%o0, -ERESTART_RESTARTBLOCK
 	bgeu,pn	%xcc, 1f
-	 andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %l6
+	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %l6
 80:
 	/* System call success, clear Carry condition code. */
 	andn	%g3, %g2, %g3
 	stx	%g3, [%sp + PTREGS_OFF + PT_V9_TSTATE]	
 	bne,pn	%icc, linux_syscall_trace2
 	 add	%l1, 0x4, %l2			! npc = npc+4
 	stx	%l1, [%sp + PTREGS_OFF + PT_V9_TPC]
 	ba,pt	%xcc, rtrap
 	 stx	%l2, [%sp + PTREGS_OFF + PT_V9_TNPC]
 
 1:
 	/* System call failure, set Carry condition code.
 	 * Also, get abs(errno) to return to the process.
 	 */
-	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %l6	
+	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %l6	
 	sub	%g0, %o0, %o0
 	or	%g3, %g2, %g3
 	stx	%o0, [%sp + PTREGS_OFF + PT_V9_I0]
 	stx	%g3, [%sp + PTREGS_OFF + PT_V9_TSTATE]
 	bne,pn	%icc, linux_syscall_trace2
 	 add	%l1, 0x4, %l2			! npc = npc+4
 	stx	%l1, [%sp + PTREGS_OFF + PT_V9_TPC]
 
diff --git a/arch/sparc64/kernel/time.c b/arch/sparc64/kernel/time.c
index 4a2eb8f..af70cab 100644
--- a/arch/sparc64/kernel/time.c
+++ b/arch/sparc64/kernel/time.c
@@ -29,16 +29,17 @@
 #include <linux/cpufreq.h>
 #include <linux/percpu.h>
 #include <linux/miscdevice.h>
 #include <linux/rtc.h>
 #include <linux/kernel_stat.h>
 #include <linux/clockchips.h>
 #include <linux/clocksource.h>
 #include <linux/of_device.h>
+#include <trace/trap.h>
 
 #include <asm/oplib.h>
 #include <asm/mostek.h>
 #include <asm/timer.h>
 #include <asm/irq.h>
 #include <asm/io.h>
 #include <asm/prom.h>
 #include <asm/starfire.h>
@@ -969,16 +970,18 @@ static DEFINE_PER_CPU(struct clock_event_device, sparc64_events);
 
 void timer_interrupt(int irq, struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
 	unsigned long tick_mask = tick_ops->softint_mask;
 	int cpu = smp_processor_id();
 	struct clock_event_device *evt = &per_cpu(sparc64_events, cpu);
 
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
+
 	clear_softint(tick_mask);
 
 	irq_enter();
 
 	kstat_this_cpu.irqs[0]++;
 
 	if (unlikely(!evt->event_handler)) {
 		printk(KERN_WARNING
@@ -991,16 +994,18 @@ void timer_interrupt(int irq, struct pt_regs *regs)
 	if (sparc64_timer.hook != NULL)
 		(sparc64_timer.hook) (sparc64_timer.hook_data);
 	spin_unlock(sparc64_timer.lock);
 #endif
 
 	irq_exit();
 
 	set_irq_regs(old_regs);
+
+	trace_trap_exit();
 }
 
 void __devinit setup_sparc64_timer(void)
 {
 	struct clock_event_device *sevt;
 	unsigned long pstate;
 
 	/* Guarantee that the following sequences execute
diff --git a/arch/sparc64/kernel/traps.c b/arch/sparc64/kernel/traps.c
index c824df1..b21a3b5 100644
--- a/arch/sparc64/kernel/traps.c
+++ b/arch/sparc64/kernel/traps.c
@@ -12,16 +12,17 @@
 #include <linux/sched.h>
 #include <linux/linkage.h>
 #include <linux/kernel.h>
 #include <linux/signal.h>
 #include <linux/smp.h>
 #include <linux/mm.h>
 #include <linux/init.h>
 #include <linux/kdebug.h>
+#include <trace/trap.h>
 
 #include <asm/smp.h>
 #include <asm/delay.h>
 #include <asm/system.h>
 #include <asm/ptrace.h>
 #include <asm/oplib.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -185,17 +186,19 @@ void sun4v_insn_access_exception(struct pt_regs *regs, unsigned long addr, unsig
 		regs->tpc &= 0xffffffff;
 		regs->tnpc &= 0xffffffff;
 	}
 	info.si_signo = SIGSEGV;
 	info.si_errno = 0;
 	info.si_code = SEGV_MAPERR;
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGSEGV, &info, current);
+	trace_trap_exit();
 }
 
 void sun4v_insn_access_exception_tl1(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
 {
 	if (notify_die(DIE_TRAP_TL1, "instruction access exception tl1", regs,
 		       0, 0x8, SIGTRAP) == NOTIFY_STOP)
 		return;
 
@@ -272,17 +275,19 @@ void sun4v_data_access_exception(struct pt_regs *regs, unsigned long addr, unsig
 		regs->tpc &= 0xffffffff;
 		regs->tnpc &= 0xffffffff;
 	}
 	info.si_signo = SIGSEGV;
 	info.si_errno = 0;
 	info.si_code = SEGV_MAPERR;
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGSEGV, &info, current);
+	trace_trap_exit();
 }
 
 void sun4v_data_access_exception_tl1(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
 {
 	if (notify_die(DIE_TRAP_TL1, "data access exception tl1", regs,
 		       0, 0x8, SIGTRAP) == NOTIFY_STOP)
 		return;
 
@@ -2029,17 +2034,19 @@ void do_tof(struct pt_regs *regs)
 		regs->tpc &= 0xffffffff;
 		regs->tnpc &= 0xffffffff;
 	}
 	info.si_signo = SIGEMT;
 	info.si_errno = 0;
 	info.si_code = EMT_TAGOVF;
 	info.si_addr = (void __user *)regs->tpc;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGEMT, &info, current);
+	trace_trap_exit();
 }
 
 void do_div0(struct pt_regs *regs)
 {
 	siginfo_t info;
 
 	if (notify_die(DIE_TRAP, "integer division by zero", regs,
 		       0, 0x28, SIGFPE) == NOTIFY_STOP)
@@ -2051,17 +2058,19 @@ void do_div0(struct pt_regs *regs)
 		regs->tpc &= 0xffffffff;
 		regs->tnpc &= 0xffffffff;
 	}
 	info.si_signo = SIGFPE;
 	info.si_errno = 0;
 	info.si_code = FPE_INTDIV;
 	info.si_addr = (void __user *)regs->tpc;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGFPE, &info, current);
+	trace_trap_exit();
 }
 
 static void instruction_dump(unsigned int *pc)
 {
 	int i;
 
 	if ((((unsigned long) pc) & 3))
 		return;
@@ -2263,17 +2272,19 @@ void do_illegal_instruction(struct pt_regs *regs)
 			}
 		}
 	}
 	info.si_signo = SIGILL;
 	info.si_errno = 0;
 	info.si_code = ILL_ILLOPC;
 	info.si_addr = (void __user *)pc;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGILL, &info, current);
+	trace_trap_exit();
 }
 
 extern void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn);
 
 void mem_address_unaligned(struct pt_regs *regs, unsigned long sfar, unsigned long sfsr)
 {
 	siginfo_t info;
 
@@ -2285,17 +2296,19 @@ void mem_address_unaligned(struct pt_regs *regs, unsigned long sfar, unsigned lo
 		kernel_unaligned_trap(regs, *((unsigned int *)regs->tpc));
 		return;
 	}
 	info.si_signo = SIGBUS;
 	info.si_errno = 0;
 	info.si_code = BUS_ADRALN;
 	info.si_addr = (void __user *)sfar;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGBUS, &info, current);
+	trace_trap_exit();
 }
 
 void sun4v_do_mna(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
 {
 	siginfo_t info;
 
 	if (notify_die(DIE_TRAP, "memory address unaligned", regs,
 		       0, 0x34, SIGSEGV) == NOTIFY_STOP)
@@ -2305,17 +2318,19 @@ void sun4v_do_mna(struct pt_regs *regs, unsigned long addr, unsigned long type_c
 		kernel_unaligned_trap(regs, *((unsigned int *)regs->tpc));
 		return;
 	}
 	info.si_signo = SIGBUS;
 	info.si_errno = 0;
 	info.si_code = BUS_ADRALN;
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGBUS, &info, current);
+	trace_trap_exit();
 }
 
 void do_privop(struct pt_regs *regs)
 {
 	siginfo_t info;
 
 	if (notify_die(DIE_TRAP, "privileged operation", regs,
 		       0, 0x11, SIGILL) == NOTIFY_STOP)
@@ -2325,17 +2340,19 @@ void do_privop(struct pt_regs *regs)
 		regs->tpc &= 0xffffffff;
 		regs->tnpc &= 0xffffffff;
 	}
 	info.si_signo = SIGILL;
 	info.si_errno = 0;
 	info.si_code = ILL_PRVOPC;
 	info.si_addr = (void __user *)regs->tpc;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGILL, &info, current);
+	trace_trap_exit();
 }
 
 void do_privact(struct pt_regs *regs)
 {
 	do_privop(regs);
 }
 
 /* Trap level 1 stuff or other traps we should never see... */
-- 
1.5.5.1

