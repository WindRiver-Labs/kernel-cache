From 1d189b851d241a2adf3210c0ff2ce013178adc66 Mon Sep 17 00:00:00 2001
From: Vu Tran <vu.tran@windriver.com>
Date: Wed, 5 Nov 2008 18:53:17 -0500
Subject: [PATCH] sparc64 lttng hooks

Add SPARC64 LTTng hooks and supporting functions.

Signed-off-by: Vu Tran <vu.tran@windriver.com>
Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 arch/sparc64/Makefile           |    1 +
 arch/sparc64/kernel/process.c   |    4 ++++
 arch/sparc64/kernel/ptrace.c    |    6 ++++++
 arch/sparc64/kernel/sys_sparc.c |    3 +++
 arch/sparc64/kernel/syscalls.S  |   10 +++++-----
 arch/sparc64/kernel/time.c      |    5 +++++
 arch/sparc64/kernel/traps.c     |   17 +++++++++++++++++
 7 files changed, 41 insertions(+), 5 deletions(-)

diff --git a/arch/sparc64/Makefile b/arch/sparc64/Makefile
index 5fae04e..61be374 100644
--- a/arch/sparc64/Makefile
+++ b/arch/sparc64/Makefile
@@ -20,6 +20,7 @@ KBUILD_CFLAGS += -m64 -pipe -mno-fpu -mcpu=ultrasparc -mcmodel=medlow \
 	-Wa,--undeclared-regs
 KBUILD_CFLAGS += $(call cc-option,-mtune=ultrasparc3)
 KBUILD_AFLAGS += -m64 -mcpu=ultrasparc -Wa,--undeclared-regs
+export USE_IMMEDIATE := $(CONFIG_IMMEDIATE)
 
 # gcc 3.x has problems with passing symbol+offset in
 # asm "i" constraint.
diff --git a/arch/sparc64/kernel/process.c b/arch/sparc64/kernel/process.c
index 15f4178..6b6970e 100644
--- a/arch/sparc64/kernel/process.c
+++ b/arch/sparc64/kernel/process.c
@@ -30,6 +30,7 @@
 #include <linux/cpu.h>
 #include <linux/elfcore.h>
 #include <linux/sysrq.h>
+#include <trace/sched.h>
 
 #include <asm/oplib.h>
 #include <asm/uaccess.h>
@@ -711,6 +712,9 @@ pid_t kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 			     "i" (__NR_clone), "r" (flags | CLONE_VM | CLONE_UNTRACED),
 			     "i" (__NR_exit),  "r" (fn), "r" (arg) :
 			     "g1", "g2", "g3", "o0", "o1", "memory", "cc");
+
+	trace_sched_kthread_create(fn, retval);
+
 	return retval;
 }
 
diff --git a/arch/sparc64/kernel/ptrace.c b/arch/sparc64/kernel/ptrace.c
index 2df5b9b..c67b41d 100644
--- a/arch/sparc64/kernel/ptrace.c
+++ b/arch/sparc64/kernel/ptrace.c
@@ -26,6 +26,7 @@
 #include <linux/tracehook.h>
 #include <linux/compat.h>
 #include <linux/elf.h>
+#include <trace/syscall.h>
 
 #include <asm/asi.h>
 #include <asm/pgtable.h>
@@ -1054,6 +1055,11 @@ asmlinkage int syscall_trace(struct pt_regs *regs, int syscall_exit_p)
 {
 	int ret = 0;
 
+	if (!syscall_exit_p)
+		trace_syscall_entry(regs, (int)regs->u_regs[UREG_G1]);
+	else
+		trace_syscall_exit(regs->u_regs[UREG_I0]);
+
 	/* do the secure computing check first */
 	secure_computing(regs->u_regs[UREG_G1]);
 
diff --git a/arch/sparc64/kernel/sys_sparc.c b/arch/sparc64/kernel/sys_sparc.c
index c412615..7b3b28c 100644
--- a/arch/sparc64/kernel/sys_sparc.c
+++ b/arch/sparc64/kernel/sys_sparc.c
@@ -23,6 +23,7 @@
 #include <linux/ipc.h>
 #include <linux/personality.h>
 #include <linux/random.h>
+#include <trace/ipc.h>
 
 #include <asm/uaccess.h>
 #include <asm/utrap.h>
@@ -442,6 +443,8 @@ asmlinkage long sys_ipc(unsigned int call, int first, unsigned long second,
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
+	trace_ipc_call(call, first);
+
 	if (call <= SEMCTL) {
 		switch (call) {
 		case SEMOP:
diff --git a/arch/sparc64/kernel/syscalls.S b/arch/sparc64/kernel/syscalls.S
index 618804c..262c5fe 100644
--- a/arch/sparc64/kernel/syscalls.S
+++ b/arch/sparc64/kernel/syscalls.S
@@ -62,7 +62,7 @@ sys32_rt_sigreturn:
 #endif
 	.align	32
 1:	ldx	[%g6 + TI_FLAGS], %l5
-	andcc	%l5, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
+	andcc	%l5, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
 	be,pt	%icc, rtrap
 	 nop
 	add	%sp, PTREGS_OFF, %o0
@@ -205,7 +205,7 @@ linux_sparc_syscall32:
 
 	srl	%i5, 0, %o5				! IEU1
 	srl	%i2, 0, %o2				! IEU0	Group
-	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
+	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
 	bne,pn	%icc, linux_syscall_trace32		! CTI
 	 mov	%i0, %l5				! IEU1
 	call	%l7					! CTI	Group brk forced
@@ -228,7 +228,7 @@ linux_sparc_syscall:
 
 	mov	%i3, %o3				! IEU1
 	mov	%i4, %o4				! IEU0	Group
-	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
+	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %g0
 	bne,pn	%icc, linux_syscall_trace		! CTI	Group
 	 mov	%i0, %l5				! IEU0
 2:	call	%l7					! CTI	Group brk forced
@@ -253,7 +253,7 @@ ret_sys_call:
 
 	cmp	%o0, -ERESTART_RESTARTBLOCK
 	bgeu,pn	%xcc, 1f
-	 andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %l6
+	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %l6
 80:
 	/* System call success, clear Carry condition code. */
 	andn	%g3, %g2, %g3
@@ -268,7 +268,7 @@ ret_sys_call:
 	/* System call failure, set Carry condition code.
 	 * Also, get abs(errno) to return to the process.
 	 */
-	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %l6	
+	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_KERNEL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT), %l6	
 	sub	%g0, %o0, %o0
 	or	%g3, %g2, %g3
 	stx	%o0, [%sp + PTREGS_OFF + PT_V9_I0]
diff --git a/arch/sparc64/kernel/time.c b/arch/sparc64/kernel/time.c
index 4a2eb8f..af70cab 100644
--- a/arch/sparc64/kernel/time.c
+++ b/arch/sparc64/kernel/time.c
@@ -34,6 +34,7 @@
 #include <linux/clockchips.h>
 #include <linux/clocksource.h>
 #include <linux/of_device.h>
+#include <trace/trap.h>
 
 #include <asm/oplib.h>
 #include <asm/mostek.h>
@@ -974,6 +975,8 @@ void timer_interrupt(int irq, struct pt_regs *regs)
 	int cpu = smp_processor_id();
 	struct clock_event_device *evt = &per_cpu(sparc64_events, cpu);
 
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
+
 	clear_softint(tick_mask);
 
 	irq_enter();
@@ -996,6 +999,8 @@ void timer_interrupt(int irq, struct pt_regs *regs)
 	irq_exit();
 
 	set_irq_regs(old_regs);
+
+	trace_trap_exit();
 }
 
 void __devinit setup_sparc64_timer(void)
diff --git a/arch/sparc64/kernel/traps.c b/arch/sparc64/kernel/traps.c
index eb19724..6f18ca2 100644
--- a/arch/sparc64/kernel/traps.c
+++ b/arch/sparc64/kernel/traps.c
@@ -17,6 +17,7 @@
 #include <linux/mm.h>
 #include <linux/init.h>
 #include <linux/kdebug.h>
+#include <trace/trap.h>
 
 #include <asm/smp.h>
 #include <asm/delay.h>
@@ -190,7 +191,9 @@ void sun4v_insn_access_exception(struct pt_regs *regs, unsigned long addr, unsig
 	info.si_code = SEGV_MAPERR;
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGSEGV, &info, current);
+	trace_trap_exit();
 }
 
 void sun4v_insn_access_exception_tl1(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
@@ -292,7 +295,9 @@ void sun4v_data_access_exception(struct pt_regs *regs, unsigned long addr, unsig
 	info.si_code = SEGV_MAPERR;
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGSEGV, &info, current);
+	trace_trap_exit();
 }
 
 void sun4v_data_access_exception_tl1(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
@@ -2049,7 +2054,9 @@ void do_tof(struct pt_regs *regs)
 	info.si_code = EMT_TAGOVF;
 	info.si_addr = (void __user *)regs->tpc;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGEMT, &info, current);
+	trace_trap_exit();
 }
 
 void do_div0(struct pt_regs *regs)
@@ -2071,7 +2078,9 @@ void do_div0(struct pt_regs *regs)
 	info.si_code = FPE_INTDIV;
 	info.si_addr = (void __user *)regs->tpc;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGFPE, &info, current);
+	trace_trap_exit();
 }
 
 static void instruction_dump(unsigned int *pc)
@@ -2283,7 +2292,9 @@ void do_illegal_instruction(struct pt_regs *regs)
 	info.si_code = ILL_ILLOPC;
 	info.si_addr = (void __user *)pc;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGILL, &info, current);
+	trace_trap_exit();
 }
 
 extern void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn);
@@ -2305,7 +2316,9 @@ void mem_address_unaligned(struct pt_regs *regs, unsigned long sfar, unsigned lo
 	info.si_code = BUS_ADRALN;
 	info.si_addr = (void __user *)sfar;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGBUS, &info, current);
+	trace_trap_exit();
 }
 
 void sun4v_do_mna(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
@@ -2325,7 +2338,9 @@ void sun4v_do_mna(struct pt_regs *regs, unsigned long addr, unsigned long type_c
 	info.si_code = BUS_ADRALN;
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGBUS, &info, current);
+	trace_trap_exit();
 }
 
 void do_privop(struct pt_regs *regs)
@@ -2345,7 +2360,9 @@ void do_privop(struct pt_regs *regs)
 	info.si_code = ILL_PRVOPC;
 	info.si_addr = (void __user *)regs->tpc;
 	info.si_trapno = 0;
+	trace_trap_entry(regs, pt_regs_trap_type(regs));
 	force_sig_info(SIGILL, &info, current);
+	trace_trap_exit();
 }
 
 void do_privact(struct pt_regs *regs)
