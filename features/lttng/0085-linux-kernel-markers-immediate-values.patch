From 17a8ff8bef2ddf85ecb5aa233fe3f665bdf2e1a6 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 2 Oct 2008 14:36:19 -0400
Subject: [PATCH] linux-kernel-markers-immediate-values

Linux Kernel Markers - Use Immediate Values

Make markers use immediate values.

Changelog :
- Use imv_* instead of immediate_*.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 Documentation/markers.txt |   17 +++++++++++++----
 include/linux/marker.h    |   16 ++++++++++++----
 kernel/marker.c           |   12 ++++++++----
 ltt/ltt-marker-control.c  |    4 ++--
 4 files changed, 35 insertions(+), 14 deletions(-)

diff --git a/Documentation/markers.txt b/Documentation/markers.txt
index 089f613..59580b7 100644
--- a/Documentation/markers.txt
+++ b/Documentation/markers.txt
@@ -15,10 +15,12 @@ provide at runtime. A marker can be "on" (a probe is connected to it) or "off"
 (no probe is attached). When a marker is "off" it has no effect, except for
 adding a tiny time penalty (checking a condition for a branch) and space
 penalty (adding a few bytes for the function call at the end of the
-instrumented function and adds a data structure in a separate section).  When a
-marker is "on", the function you provide is called each time the marker is
-executed, in the execution context of the caller. When the function provided
-ends its execution, it returns to the caller (continuing from the marker site).
+instrumented function and adds a data structure in a separate section). The
+immediate values are used to minimize the impact on data cache, encoding the
+condition in the instruction stream. When a marker is "on", the function you
+provide is called each time the marker is executed, in the execution context of
+the caller. When the function provided ends its execution, it returns to the
+caller (continuing from the marker site).
 
 You can put markers at important locations in the code. Markers are
 lightweight hooks that can pass an arbitrary number of parameters,
@@ -71,6 +73,13 @@ a printk warning which identifies the inconsistency:
 "Format mismatch for probe probe_name (format), marker (format)"
 
 
+* Optimization for a given architecture
+
+To force use of a non-optimized version of the markers, _trace_mark() should be
+used. It takes the same parameters as the normal markers, but it does not use
+the immediate values based on code patching.
+
+
 * Probe / marker example
 
 See the example provided in samples/markers/src
diff --git a/include/linux/marker.h b/include/linux/marker.h
index b50070f..a8c7730 100644
--- a/include/linux/marker.h
+++ b/include/linux/marker.h
@@ -12,6 +12,7 @@
  * See the file COPYING for more details.
  */
 
+#include <linux/immediate.h>
 #include <linux/types.h>
 
 struct module;
@@ -42,7 +43,7 @@ struct marker {
 	const char *format;	/* Marker format string, describing the
 				 * variable argument list.
 				 */
-	char state;		/* Marker state. */
+	DEFINE_IMV(char, state);/* Immediate value state. */
 	char ptype;		/* probe type : 0 : single, 1 : multi */
 				/* Probe wrapper */
 	void (*call)(const struct marker *mdata, void *call_private, ...);
@@ -74,9 +75,16 @@ struct marker {
 		0, 0, marker_probe_cb,					\
 		{ __mark_empty_function, NULL}, NULL, NULL, NULL };	\
 		__mark_check_format(format, ## args);			\
-		if (unlikely(__mark_##name.state)) {			\
-			(*__mark_##name.call)				\
-				(&__mark_##name, call_private, ## args);\
+		if (!generic) {						\
+			if (unlikely(imv_read(__mark_##name.state)))	\
+				(*__mark_##name.call)			\
+					(&__mark_##name, call_private,	\
+					## args);			\
+		} else {						\
+			if (unlikely(_imv_read(__mark_##name.state)))	\
+				(*__mark_##name.call)			\
+					(&__mark_##name, call_private,	\
+					## args);			\
 		}							\
 	} while (0)
 
diff --git a/kernel/marker.c b/kernel/marker.c
index cb63e5e..4890a57 100644
--- a/kernel/marker.c
+++ b/kernel/marker.c
@@ -24,6 +24,7 @@
 #include <linux/marker.h>
 #include <linux/err.h>
 #include <linux/slab.h>
+#include <linux/immediate.h>
 
 extern struct marker __start___markers[];
 extern struct marker __stop___markers[];
@@ -552,7 +553,7 @@ static int set_marker(struct marker_entry **entry, struct marker *elem,
 	smp_wmb();
 	elem->ptype = (*entry)->ptype;
 
-	if (elem->tp_name && (active ^ elem->state)) {
+	if (elem->tp_name && (active ^ _imv_read(elem->state))) {
 		WARN_ON(!elem->tp_cb);
 		/*
 		 * It is ok to directly call the probe registration because type
@@ -565,7 +566,7 @@ static int set_marker(struct marker_entry **entry, struct marker *elem,
 			ret = tracepoint_probe_unregister(elem->tp_name,
 				elem->tp_cb);
 	}
-	elem->state = active;
+	elem->state__imv = active;
 
 	return ret;
 }
@@ -581,7 +582,7 @@ static void disable_marker(struct marker *elem)
 	int ret;
 
 	/* leave "call" as is. It is known statically. */
-	if (elem->tp_name && elem->state) {
+	if (elem->tp_name && _imv_read(elem->state)) {
 		WARN_ON(!elem->tp_cb);
 		/*
 		 * It is ok to directly call the probe registration because type
@@ -590,7 +591,7 @@ static void disable_marker(struct marker *elem)
 		ret = tracepoint_probe_unregister(elem->tp_name, elem->tp_cb);
 		WARN_ON(ret);
 	}
-	elem->state = 0;
+	elem->state__imv = 0;
 	elem->single.func = __mark_empty_function;
 	/* Update the function before setting the ptype */
 	smp_wmb();
@@ -654,6 +655,9 @@ static void marker_update_probes(void)
 	marker_update_probe_range(__start___markers, __stop___markers);
 	/* Markers in modules. */
 	module_update_markers();
+	/* Update immediate values */
+	core_imv_update();
+	module_imv_update();
 }
 
 /**
diff --git a/ltt/ltt-marker-control.c b/ltt/ltt-marker-control.c
index 8868b83..04e38c0 100644
--- a/ltt/ltt-marker-control.c
+++ b/ltt/ltt-marker-control.c
@@ -606,7 +606,7 @@ void ltt_dump_marker_state(struct ltt_trace_struct *trace)
 	marker_iter_reset(&iter);
 	marker_iter_start(&iter);
 	for (; iter.marker != NULL; marker_iter_next(&iter)) {
-		if (!iter.marker->state)
+		if (!_imv_read(iter.marker->state))
 			continue;
 		probe = &default_probe;
 		//list_for_each_entry_reverse(probe, &probes_registered_list,
@@ -800,7 +800,7 @@ static int s_show(struct seq_file *m, void *p)
 	seq_printf(m, "marker: %s format: \"%s\" state: %d "
 		"call: 0x%p probe %s : 0x%p\n",
 		iter->marker->name, iter->marker->format,
-		iter->marker->state,
+		_imv_read(iter->marker->state),
 		iter->marker->call,
 		iter->marker->ptype ? "multi" : "single",
 		iter->marker->ptype ?
-- 
1.5.5.1

