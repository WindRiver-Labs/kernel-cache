From da21c310918852ae323aa43a2d8562fd37d68d8d Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:28:19 -0400
Subject: [PATCH 341/391] omap-trace-clock-support-pm

omap : trace clock support pm

Support power management for omap trace clock.

- Updated for 2.6.32-rc8 kernel.
- Fix trace pm suspend exit (was a 2nd entry).

* Differs from omap tree *

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/arm/mach-omap2/pm34xx.c |   33 ++++++++++++++++++++++++++++++++-
 1 files changed, 32 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ea0000b..1759ee9 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -28,6 +28,7 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <trace/pm.h>
 
 #include <plat/sram.h>
 #include <plat/clockdomain.h>
@@ -42,6 +43,8 @@
 
 #include <asm/tlbflush.h>
 
+#include <asm/trace-clock.h>
+
 #include "cm.h"
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
@@ -68,6 +71,11 @@ struct power_state {
 	struct list_head node;
 };
 
+DEFINE_TRACE(pm_idle_entry);
+DEFINE_TRACE(pm_idle_exit);
+DEFINE_TRACE(pm_suspend_entry);
+DEFINE_TRACE(pm_suspend_exit);
+
 static LIST_HEAD(pwrst_list);
 
 static void (*_omap_sram_idle)(u32 *addr, int save_state);
@@ -538,8 +546,27 @@ static void omap3_pm_idle(void)
 	if (omap_irq_pending() || need_resched())
 		goto out;
 
+	trace_pm_idle_entry();
+	/*
+	 * Should only be stopped when the CPU is stopping the ccnt
+	 * counter in idle. sleep_while_idle seems to disable
+	 * the ccnt clock (as of 2.6.32-rc8).
+	 */
+	stop_trace_clock();
+
 	omap_sram_idle();
 
+	/*
+	 * Restarting the trace clock should ideally be done much sooner. When
+	 * we arrive here, there are already some interrupt handlers which have
+	 * run before us, using potentially wrong timestamps. This leads
+	 * to problems when restarting the clock (and synchronizing on the 32k
+	 * clock) if the cycle counter was still active.
+	 * start_track_clock must ensure that timestamps never ever go backward.
+	 */
+	start_trace_clock();
+	trace_pm_idle_exit();
+
 out:
 	local_fiq_enable();
 	local_irq_enable();
@@ -592,7 +619,11 @@ static int omap3_pm_suspend(void)
 	omap_uart_prepare_suspend();
 	omap3_intc_suspend();
 
-	omap_sram_idle();
+	trace_pm_suspend_entry();
+	stop_trace_clock();
+  	omap_sram_idle();
+	start_trace_clock();
+	trace_pm_suspend_exit();
 
 restore:
 	/* Restore next_pwrsts */
-- 
1.6.5.2

