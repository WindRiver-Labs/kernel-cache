From cf640c73c6344d1cabc5ed34f58c46a9c6838975 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:55 -0400
Subject: [PATCH 186/390] ltt-channels-make-marker-entry-permanent-for-trace-session

ltt channels make marker entry permanent for trace session

Text output need a permanent struct for permanent eID as long as a trace session
lives. This patch keeps marker_entry alive as long as a trace session exists.
Will be useful for th ltt-ascii bin-to-ascii converter.

Edited by Mathieu Desnoyers.

locking is insured by lock_markers().

struct marker_entry is permanent for the duration of active tracing
sessions. That means : as long as a struct marker_entry channel and
event IDs can be seen by an active tracing session, it stays valid until
all tracing sessions end.

From: Lai Jiangshan <laijs@cn.fujitsu.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-channels.h |    1 +
 kernel/marker.c              |   46 +++++++++++++++++++++++++++++++++--------
 ltt/ltt-channels.c           |   14 ++++++++++++
 3 files changed, 52 insertions(+), 9 deletions(-)

diff --git a/include/linux/ltt-channels.h b/include/linux/ltt-channels.h
index 8ebb0c5..0475d76 100644
--- a/include/linux/ltt-channels.h
+++ b/include/linux/ltt-channels.h
@@ -84,6 +84,7 @@ int ltt_channels_set_default(const char *name,
 			     unsigned int subbuf_cnt);
 const char *ltt_channels_get_name_from_index(unsigned int index);
 int ltt_channels_get_index_from_name(const char *name);
+int ltt_channels_trace_ref(void);
 struct ltt_channel_struct *ltt_channels_trace_alloc(unsigned int *nr_channels,
 						    int overwrite,
 						    int active);
diff --git a/kernel/marker.c b/kernel/marker.c
index 715c26d..861af5e 100644
--- a/kernel/marker.c
+++ b/kernel/marker.c
@@ -19,6 +19,7 @@
 #include <linux/mutex.h>
 #include <linux/types.h>
 #include <linux/jhash.h>
+#include <linux/hash.h>
 #include <linux/list.h>
 #include <linux/rcupdate.h>
 #include <linux/marker.h>
@@ -56,6 +57,7 @@ void unlock_markers(void)
 #define MARKER_HASH_BITS 6
 #define MARKER_TABLE_SIZE (1 << MARKER_HASH_BITS)
 static struct hlist_head marker_table[MARKER_TABLE_SIZE];
+static struct hlist_head id_table[MARKER_TABLE_SIZE];
 
 /*
  * Note about RCU :
@@ -67,6 +69,7 @@ static struct hlist_head marker_table[MARKER_TABLE_SIZE];
  */
 struct marker_entry {
 	struct hlist_node hlist;
+	struct hlist_node id_list;
 	char *format;
 	char *name;
 			/* Probe wrapper */
@@ -452,9 +455,10 @@ static struct marker_entry *add_marker(const char *channel, const char *name,
 
 /*
  * Remove the marker from the marker hash table. Must be called with mutex_lock
- * held.
+ * held. Parameter "registered" indicates if the channel registration has been
+ * performed.
  */
-static int remove_marker(const char *channel, const char *name)
+static int remove_marker(const char *channel, const char *name, int registered)
 {
 	struct hlist_head *head;
 	struct hlist_node *node;
@@ -477,11 +481,18 @@ static int remove_marker(const char *channel, const char *name)
 		return -ENOENT;
 	if (e->single.func != __mark_empty_function)
 		return -EBUSY;
+
+	if (registered && ltt_channels_trace_ref())
+		return 0;
+
 	hlist_del(&e->hlist);
+	hlist_del(&e->id_list);
+	if (registered) {
+		ret = ltt_channels_unregister(e->channel);
+		WARN_ON(ret);
+	}
 	if (e->format_allocated)
 		kfree(e->format);
-	ret = ltt_channels_unregister(e->channel);
-	WARN_ON(ret);
 	/* Make sure the call_rcu has been executed */
 	if (e->rcu_pending)
 		rcu_barrier_sched();
@@ -737,6 +748,9 @@ int marker_probe_register(const char *channel, const char *name,
 		if (ret < 0)
 			goto error_unregister_channel;
 		entry->event_id = ret;
+		hlist_add_head(&entry->id_list, id_table + hash_32(
+				(entry->channel_id << 16) | entry->event_id,
+				MARKER_HASH_BITS));
 		ret = 0;
 		trace_mark(metadata, core_marker_id,
 			   "channel %s name %s event_id %hu "
@@ -789,7 +803,7 @@ error_unregister_channel:
 	ret_err = ltt_channels_unregister(channel);
 	WARN_ON(ret_err);
 error_remove_marker:
-	ret_err = remove_marker(channel, name);
+	ret_err = remove_marker(channel, name, 0);
 	WARN_ON(ret_err);
 end:
 	mutex_unlock(&markers_mutex);
@@ -839,7 +853,7 @@ int marker_probe_unregister(const char *channel, const char *name,
 	/* write rcu_pending before calling the RCU callback */
 	smp_wmb();
 	call_rcu_sched(&entry->rcu, free_old_closure);
-	remove_marker(channel, name);	/* Ignore busy error message */
+	remove_marker(channel, name, 1);	/* Ignore busy error message */
 	ret = 0;
 end:
 	mutex_unlock(&markers_mutex);
@@ -926,7 +940,7 @@ int marker_probe_unregister_private_data(marker_probe_func *probe,
 	smp_wmb();
 	call_rcu_sched(&entry->rcu, free_old_closure);
 	/* Ignore busy error message */
-	remove_marker(channel, name);
+	remove_marker(channel, name, 1);
 end:
 	mutex_unlock(&markers_mutex);
 	kfree(channel);
@@ -996,12 +1010,16 @@ void markers_compact_event_ids(void)
 	struct marker_entry *entry;
 	unsigned int i;
 	struct hlist_head *head;
-	struct hlist_node *node;
+	struct hlist_node *node, *next;
 	int ret;
 
 	for (i = 0; i < MARKER_TABLE_SIZE; i++) {
 		head = &marker_table[i];
-		hlist_for_each_entry(entry, node, head, hlist) {
+		hlist_for_each_entry_safe(entry, node, next, head, hlist) {
+			if (!entry->refcount) {
+				remove_marker(entry->channel, entry->name, 1);
+				continue;
+			}
 			ret = ltt_channels_get_index_from_name(entry->channel);
 			WARN_ON(ret < 0);
 			entry->channel_id = ret;
@@ -1011,6 +1029,16 @@ void markers_compact_event_ids(void)
 			entry->event_id = ret;
 		}
 	}
+
+	memset(id_table, 0, sizeof(id_table));
+	for (i = 0; i < MARKER_TABLE_SIZE; i++) {
+		head = &marker_table[i];
+		hlist_for_each_entry(entry, node, head, hlist) {
+			hlist_add_head(&entry->id_list, id_table + hash_32(
+					(entry->channel_id << 16)
+					| entry->event_id, MARKER_HASH_BITS));
+		}
+	}
 }
 
 #ifdef CONFIG_MODULES
diff --git a/ltt/ltt-channels.c b/ltt/ltt-channels.c
index 4ef5b31..4c4bfbc 100644
--- a/ltt/ltt-channels.c
+++ b/ltt/ltt-channels.c
@@ -30,6 +30,7 @@ static LIST_HEAD(ltt_channels);
  * more trace channels are allocated.
  */
 static unsigned int free_index;
+/* index_kref is protected by both ltt_channel_mutex and lock_markers */
 static struct kref index_kref;	/* Keeps track of allocated trace channels */
 
 static struct ltt_channel_setting *lookup_channel(const char *name)
@@ -82,6 +83,17 @@ static void release_trace_channel(struct kref *kref)
 		release_channel_setting(&iter->kref);
 }
 
+/*
+ * ltt_channel_trace_ref :  Is there an existing trace session ?
+ *
+ * Must be called with lock_markers() held.
+ */
+int ltt_channels_trace_ref(void)
+{
+	return !!atomic_read(&index_kref.refcount);
+}
+EXPORT_SYMBOL_GPL(ltt_channels_trace_ref);
+
 /**
  * ltt_channels_register - Register a trace channel.
  * @name: channel name
@@ -237,6 +249,7 @@ struct ltt_channel_struct *ltt_channels_trace_alloc(unsigned int *nr_channels,
 	struct ltt_channel_struct *channel = NULL;
 	struct ltt_channel_setting *iter;
 
+	lock_markers();
 	mutex_lock(&ltt_channel_mutex);
 	if (!free_index)
 		goto end;
@@ -260,6 +273,7 @@ struct ltt_channel_struct *ltt_channels_trace_alloc(unsigned int *nr_channels,
 	}
 end:
 	mutex_unlock(&ltt_channel_mutex);
+	unlock_markers();
 	return channel;
 }
 EXPORT_SYMBOL_GPL(ltt_channels_trace_alloc);
-- 
1.6.5.2

