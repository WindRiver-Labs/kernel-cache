From b493424d244c0c2904fb1fbd0d7c7a405e4592c3 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:25:59 -0400
Subject: [PATCH 085/391] lttng-instrumentation/lttng-instrumentation-tasklets

LTTng instrumentation tasklets

tasklet entry and exit events.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: Frederic Weisbecker <fweisbec@gmail.com>
CC: Jason Baron <jbaron@redhat.com>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: Thomas Gleixner <tglx@linutronix.de>
CC: Russell King <rmk+lkml@arm.linux.org.uk>
CC: Masami Hiramatsu <mhiramat@redhat.com>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>
---
 include/trace/irq.h |   13 +++++++++++++
 kernel/softirq.c    |    9 +++++++++
 2 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/include/trace/irq.h b/include/trace/irq.h
index d71ed34..21881c7 100644
--- a/include/trace/irq.h
+++ b/include/trace/irq.h
@@ -14,4 +14,17 @@ DECLARE_TRACE(irq_exit,
 	TP_PROTO(irqreturn_t retval),
 		TP_ARGS(retval));
 
+DECLARE_TRACE(irq_tasklet_low_entry,
+	TP_PROTO(struct tasklet_struct *t),
+		TP_ARGS(t));
+DECLARE_TRACE(irq_tasklet_low_exit,
+	TP_PROTO(struct tasklet_struct *t),
+		TP_ARGS(t));
+DECLARE_TRACE(irq_tasklet_high_entry,
+	TP_PROTO(struct tasklet_struct *t),
+		TP_ARGS(t));
+DECLARE_TRACE(irq_tasklet_high_exit,
+	TP_PROTO(struct tasklet_struct *t),
+		TP_ARGS(t));
+
 #endif
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 7c1a67e..0965b2f 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -61,6 +61,11 @@ char *softirq_to_name[NR_SOFTIRQS] = {
 	"TASKLET", "SCHED", "HRTIMER",	"RCU"
 };
 
+DEFINE_TRACE(irq_tasklet_high_entry);
+DEFINE_TRACE(irq_tasklet_high_exit);
+DEFINE_TRACE(irq_tasklet_low_entry);
+DEFINE_TRACE(irq_tasklet_low_exit);
+
 /*
  * we cannot loop indefinitely here to avoid userspace starvation,
  * but we also don't want to introduce a worst case 1/HZ latency
@@ -415,7 +420,9 @@ static void tasklet_action(struct softirq_action *a)
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+				trace_irq_tasklet_low_entry(t);
 				t->func(t->data);
+				trace_irq_tasklet_low_exit(t);
 				tasklet_unlock(t);
 				continue;
 			}
@@ -450,7 +457,9 @@ static void tasklet_hi_action(struct softirq_action *a)
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+				trace_irq_tasklet_high_entry(t);
 				t->func(t->data);
+				trace_irq_tasklet_high_exit(t);
 				tasklet_unlock(t);
 				continue;
 			}
-- 
1.6.5.2

