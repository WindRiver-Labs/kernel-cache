From a4b126d822ff376126268745717452b8fb4bbc12 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Thu, 10 May 2012 13:49:24 -0700
Subject: [PATCH 162/248] omap-trace-clock-support-pm

omap : trace clock support pm

Support power management for omap trace clock.

- Updated for 2.6.32-rc8 kernel.
- Fix trace pm suspend exit (was a 2nd entry).

* Differs from omap tree *

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/arm/mach-omap2/pm34xx.c |   33 ++++++++++++++++++++++++++++++++-
 1 files changed, 32 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 703bd10..703211c 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -29,10 +29,13 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <trace/events/power.h>
+#include <trace/pm.h>
 
 #include <asm/suspend.h>
 #include <asm/system_misc.h>
 
+#include <asm/trace-clock.h>
+
 #include <plat/sram.h>
 #include "clockdomain.h"
 #include "powerdomain.h"
@@ -63,6 +66,11 @@ struct power_state {
 	struct list_head node;
 };
 
+DEFINE_TRACE(pm_idle_entry);
+DEFINE_TRACE(pm_idle_exit);
+DEFINE_TRACE(pm_suspend_entry);
+DEFINE_TRACE(pm_suspend_exit);
+
 static LIST_HEAD(pwrst_list);
 
 static int (*_omap_save_secure_sram)(u32 *addr);
@@ -403,11 +411,30 @@ static void omap3_pm_idle(void)
 	trace_power_start(POWER_CSTATE, 1, smp_processor_id());
 	trace_cpu_idle(1, smp_processor_id());
 
+	trace_pm_idle_entry();
+	/*
+	 * Should only be stopped when the CPU is stopping the ccnt
+	 * counter in idle. sleep_while_idle seems to disable
+	 * the ccnt clock (as of 2.6.32-rc8).
+	 */
+	stop_trace_clock();
+
 	omap_sram_idle();
 
 	trace_power_end(smp_processor_id());
 	trace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());
 
+	/*
+	 * Restarting the trace clock should ideally be done much sooner. When
+	 * we arrive here, there are already some interrupt handlers which have
+	 * run before us, using potentially wrong timestamps. This leads
+	 * to problems when restarting the clock (and synchronizing on the 32k
+	 * clock) if the cycle counter was still active.
+	 * start_track_clock must ensure that timestamps never ever go backward.
+	 */
+	start_trace_clock();
+	trace_pm_idle_exit();
+
 out:
 	local_fiq_enable();
 }
@@ -431,7 +458,11 @@ static int omap3_pm_suspend(void)
 
 	omap3_intc_suspend();
 
-	omap_sram_idle();
+	trace_pm_suspend_entry();
+	stop_trace_clock();
+  	omap_sram_idle();
+	start_trace_clock();
+	trace_pm_suspend_exit();
 
 restore:
 	/* Restore next_pwrsts */
-- 
1.7.0.4

