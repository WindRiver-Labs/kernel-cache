From d3eff69194c99f3fee0898a1f74c7a10197ed8d4 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:27:59 -0400
Subject: [PATCH 304/391] lttng-relay-idle-flush

LTTng relay idle flush

Flush buffers before going to idle if periodic flush is enabled.
Use a RCU list for the channel list, because we have to read it often.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-relay.h |    4 +++-
 ltt/ltt-relay-alloc.c     |   26 ++++++++++++++++++--------
 ltt/ltt-relay-lockless.c  |   34 +++++++++++++++++++++++++++++++---
 3 files changed, 52 insertions(+), 12 deletions(-)

diff --git a/include/linux/ltt-relay.h b/include/linux/ltt-relay.h
index 30e4485..9a01e14 100644
--- a/include/linux/ltt-relay.h
+++ b/include/linux/ltt-relay.h
@@ -73,6 +73,7 @@ struct ltt_chan_alloc {
 	unsigned long n_sb;		/* Number of sub-buffers */
 	struct dentry *parent;		/* Associated parent dentry */
 	struct dentry *ascii_dentry;	/* Text output dentry */
+	struct rcu_head rcu_cb;		/* RCU callback for buf removal */
 	char filename[NAME_MAX];	/* Filename for channel files */
 };
 
@@ -88,7 +89,8 @@ int ltt_chanbuf_create_file(const char *filename, struct dentry *parent,
 			    int mode, struct ltt_chanbuf *buf);
 int ltt_chanbuf_remove_file(struct ltt_chanbuf *buf);
 
-void ltt_chan_for_each_channel(void (*cb) (struct ltt_chanbuf *buf), int cpu);
+void ltt_chan_for_each_channel(void (*cb) (struct ltt_chanbuf *buf), int cpu,
+			       int sleepable);
 
 extern void _ltt_relay_write(struct ltt_chanbuf_alloc *bufa,
 			     size_t offset, const void *src, size_t len,
diff --git a/ltt/ltt-relay-alloc.c b/ltt/ltt-relay-alloc.c
index d50cc72..66a04f0 100644
--- a/ltt/ltt-relay-alloc.c
+++ b/ltt/ltt-relay-alloc.c
@@ -17,9 +17,11 @@
 #include <linux/cpu.h>
 #include <linux/bitops.h>
 #include <linux/ltt-tracer.h>
+#include <linux/rculist.h>
 
 #include "ltt-relay-select.h"	/* for cpu hotplug */
 
+/* Protect list and channel structures (alloc/free) for sleepable operations */
 static DEFINE_MUTEX(ltt_relay_alloc_mutex);
 /* list of open channels, for cpu hotplug. */
 static LIST_HEAD(ltt_relay_channels);
@@ -211,7 +213,7 @@ int __cpuinit ltt_relay_hotcpu_callback(struct notifier_block *nb,
 	case CPU_UP_PREPARE:
 	case CPU_UP_PREPARE_FROZEN:
 		mutex_lock(&ltt_relay_alloc_mutex);
-		list_for_each_entry(chan, &ltt_relay_channels, a.list) {
+		list_for_each_entry_rcu(chan, &ltt_relay_channels, a.list) {
 			struct ltt_chanbuf *buf = per_cpu_ptr(chan->a.buf, cpu);
 
 			ret = ltt_chanbuf_create(buf, &chan->a, cpu);
@@ -235,12 +237,13 @@ int __cpuinit ltt_relay_hotcpu_callback(struct notifier_block *nb,
 	return NOTIFY_OK;
 }
 
-void ltt_chan_for_each_channel(void (*cb) (struct ltt_chanbuf *buf), int cpu)
+void ltt_chan_for_each_channel(void (*cb) (struct ltt_chanbuf *buf), int cpu,
+			       int sleepable)
 {
 	struct ltt_chan *chan;
 
-	mutex_lock(&ltt_relay_alloc_mutex);
-	list_for_each_entry(chan, &ltt_relay_channels, a.list) {
+	rcu_read_lock();
+	list_for_each_entry_rcu(chan, &ltt_relay_channels, a.list) {
 		struct ltt_chanbuf *buf;
 
 		if (!chan->active)
@@ -248,7 +251,7 @@ void ltt_chan_for_each_channel(void (*cb) (struct ltt_chanbuf *buf), int cpu)
 		buf = per_cpu_ptr(chan->a.buf, cpu);
 		cb(buf);
 	}
-	mutex_unlock(&ltt_relay_alloc_mutex);
+	rcu_read_unlock();
 }
 
 /**
@@ -312,7 +315,7 @@ int ltt_chan_alloc_init(struct ltt_chan_alloc *chan,
 		if (ret)
 			goto free_bufs;
 	}
-	list_add(&chan->list, &ltt_relay_channels);
+	list_add_rcu(&chan->list, &ltt_relay_channels);
 	mutex_unlock(&ltt_relay_alloc_mutex);
 
 	return 0;
@@ -333,6 +336,13 @@ free_chan:
 	return -ENOMEM;
 }
 
+void ltt_chan_alloc_free_rcu(struct rcu_head *head)
+{
+	struct ltt_chan_alloc *chana =
+		container_of(head, struct ltt_chan_alloc, rcu_cb);
+	free_percpu(chana->buf);
+}
+
 /**
  * ltt_chan_alloc_free - destroy the channel
  * @chan: the channel
@@ -352,9 +362,9 @@ void ltt_chan_alloc_free(struct ltt_chan_alloc *chan)
 		ltt_chanbuf_remove_file(buf);
 		kref_put(&buf->a.kref, ltt_chanbuf_free);
 	}
-	list_del(&chan->list);
+	list_del_rcu(&chan->list);
 	mutex_unlock(&ltt_relay_alloc_mutex);
-	free_percpu(chan->buf);
+	call_rcu(&chan->rcu_cb, ltt_chan_alloc_free_rcu);
 }
 
 /**
diff --git a/ltt/ltt-relay-lockless.c b/ltt/ltt-relay-lockless.c
index 259ab6c..dd3915e 100644
--- a/ltt/ltt-relay-lockless.c
+++ b/ltt/ltt-relay-lockless.c
@@ -49,8 +49,10 @@
 #include <linux/smp_lock.h>
 #include <linux/stat.h>
 #include <linux/cpu.h>
+#include <linux/idle.h>
 #include <asm/atomic.h>
 #include <asm/local.h>
+#include <linux/notifier.h>
 
 #include "ltt-relay-lockless.h"
 
@@ -513,6 +515,14 @@ void ltt_chan_stop_switch_timer(struct ltt_chan *chan)
 	put_online_cpus();
 }
 
+static void ltt_chanbuf_idle_switch(struct ltt_chanbuf *buf)
+{
+	struct ltt_chan *chan = container_of(buf->a.chan, struct ltt_chan, a);
+
+	if (chan->switch_timer_interval)
+		ltt_force_switch(buf, FORCE_ACTIVE);
+}
+
 static void ltt_chanbuf_switch(struct ltt_chanbuf *buf)
 {
 	ltt_force_switch(buf, FORCE_ACTIVE);
@@ -538,7 +548,8 @@ int ltt_chanbuf_hotcpu_callback(struct notifier_block *nb,
 	case CPU_DOWN_FAILED_FROZEN:
 	case CPU_ONLINE:
 	case CPU_ONLINE_FROZEN:
-		ltt_chan_for_each_channel(ltt_chanbuf_start_switch_timer, cpu);
+		ltt_chan_for_each_channel(ltt_chanbuf_start_switch_timer,
+					  cpu, 1);
 		return NOTIFY_OK;
 
 	case CPU_DOWN_PREPARE:
@@ -547,7 +558,8 @@ int ltt_chanbuf_hotcpu_callback(struct notifier_block *nb,
 		 * Performs an IPI to delete the timer locally on the target
 		 * CPU.
 		 */
-		ltt_chan_for_each_channel(ltt_chanbuf_stop_switch_timer, cpu);
+		ltt_chan_for_each_channel(ltt_chanbuf_stop_switch_timer,
+					  cpu, 1);
 		return NOTIFY_OK;
 
 	case CPU_DEAD:
@@ -558,7 +570,7 @@ int ltt_chanbuf_hotcpu_callback(struct notifier_block *nb,
 		 * CPU stopped running completely. Ensures that all data
 		 * from that remote CPU is flushed.
 		 */
-		ltt_chan_for_each_channel(ltt_chanbuf_switch, cpu);
+		ltt_chan_for_each_channel(ltt_chanbuf_switch, cpu, 0);
 		return NOTIFY_OK;
 
 	default:
@@ -566,6 +578,20 @@ int ltt_chanbuf_hotcpu_callback(struct notifier_block *nb,
 	}
 }
 
+static int pm_idle_entry_callback(struct notifier_block *self,
+				  unsigned long val, void *data)
+{
+	if (val == IDLE_START)
+		ltt_chan_for_each_channel(ltt_chanbuf_idle_switch,
+					  smp_processor_id(), 0);
+	return 0;
+}
+
+struct notifier_block pm_idle_entry_notifier = {
+	.notifier_call = pm_idle_entry_callback,
+	.priority = ~0U,	/* smallest prio, run after tracing events */
+};
+
 static
 void ltt_relay_print_written(struct ltt_chan *chan, long cons_off,
 			     unsigned int cpu)
@@ -1297,6 +1323,7 @@ static int __init ltt_relay_init(void)
 
 	ltt_transport_register(&ltt_relay_transport);
 	register_cpu_notifier(&fn_ltt_chanbuf_hotcpu_callback);
+	register_idle_notifier(&pm_idle_entry_notifier);
 
 	return 0;
 }
@@ -1305,6 +1332,7 @@ static void __exit ltt_relay_exit(void)
 {
 	printk(KERN_INFO "LTT : ltt-relay exit\n");
 
+	unregister_idle_notifier(&pm_idle_entry_notifier);
 	unregister_cpu_notifier(&fn_ltt_chanbuf_hotcpu_callback);
 	ltt_transport_unregister(&ltt_relay_transport);
 }
-- 
1.6.5.2

