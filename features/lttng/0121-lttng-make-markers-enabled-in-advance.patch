From 2e508585cb62eba80ca6a631bfacc48541df6891 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Wed, 18 May 2011 18:42:09 -0400
Subject: [PATCH 121/248] lttng-make-markers-enabled-in-advance

Hi Mathieu,

Sorry for the later, i'm a little busy these days.

v3 -> v4 changes:
- export _is_marker_present and _is_marker_enabled
- hold markers_mutex around _is_marker_present and _is_marker_enabled
- fix a typo

This patch makes marker enabled in advance.
IOW, even if the marker isn't present for the moment,
you can still enable it for future use.
As soon as the marker is inserted into kernel, tracing
work can be started immediately.

Here is an example for using the user interface:
This patch assumes the marker control patch is applied.
[root@localhost markers]# cd /mnt/debugfs/ltt/markers
[root@localhost markers]# mkdir fs
[root@localhost markers]# cd fs/
[root@localhost fs]# mkdir close
[root@localhost fs]# cd close/
[root@localhost close]# echo 1 > enable
[root@localhost close]# cat enable
2
[root@localhost close]# cat info
Marker Pre-enabled
[root@localhost close]# modprobe fs-trace
[root@localhost close]# cat enable
1
[root@localhost close]# cat info
Location: fs_trace
format: "fd %u"
state: 1
event_id: 0
call: 0xc0468192
probe single : 0xc0520ed8

You can also remove a marker directory by "rmdir" if there
is no actual marker backed and isn't enabled in advance.
A channel directory can be remove if there are not any marker
directories in it.

Signed-off-by: Gui Jianfeng <guijianfeng@cn.fujitsu.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/marker.h |    3 ++
 kernel/marker.c        |   75 +++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 74 insertions(+), 4 deletions(-)

diff --git a/include/linux/marker.h b/include/linux/marker.h
index 2d78113..d185235 100644
--- a/include/linux/marker.h
+++ b/include/linux/marker.h
@@ -260,6 +260,9 @@ extern void marker_iter_stop(struct marker_iter *iter);
 extern void marker_iter_reset(struct marker_iter *iter);
 extern int marker_get_iter_range(struct marker **marker, struct marker *begin,
 	struct marker *end);
+extern int _is_marker_enabled(const char *channel, const char *name);
 extern int is_marker_enabled(const char *channel, const char *name);
+extern int _is_marker_present(const char *channel, const char *name);
+extern int is_marker_present(const char *channel, const char *name);
 
 #endif
diff --git a/kernel/marker.c b/kernel/marker.c
index 93ffa8e..bb35db2 100644
--- a/kernel/marker.c
+++ b/kernel/marker.c
@@ -653,22 +653,89 @@ static void disable_marker(struct marker *elem)
 }
 
 /*
- * is_marker_enabled - Check if a marker is enabled
+ * _is_marker_present - Check if a marker is present in kernel must be called
+ *                      with markers_mutex held.
+ * @channel: channel name
+ * @name: marker name
+ *
+ * Returns 1 if the marker is present, 0 if not.
+ */
+int _is_marker_present(const char *channel, const char *name)
+{
+	int ret;
+	struct marker_iter iter;
+
+	ret = 0;
+
+	marker_iter_reset(&iter);
+	marker_iter_start(&iter);
+	for (; iter.marker != NULL; marker_iter_next(&iter)) {
+		if (!strcmp(iter.marker->channel, channel) &&
+		    !strcmp(iter.marker->name, name)) {
+			ret = 1;
+			goto end;
+		}
+	}
+end:
+	marker_iter_stop(&iter);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(_is_marker_present);
+
+/*
+ * is_marker_present - the wrapper of _is_marker_present
+ * @channel: channel name
+ * @name: marker name
+ *
+ * Returns 1 if the marker is present, 0 if not.
+ */
+int is_marker_present(const char *channel, const char *name)
+{
+	int ret;
+
+	lock_markers();
+	ret = _is_marker_present(channel, name);
+	unlock_markers();
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(is_marker_present);
+
+/*
+ * _is_marker_enabled - Check if a marker is enabled, must be called with
+ *                      markers_mutex held.
  * @channel: channel name
  * @name: marker name
  *
  * Returns 1 if the marker is enabled, 0 if disabled.
  */
-int is_marker_enabled(const char *channel, const char *name)
+int _is_marker_enabled(const char *channel, const char *name)
 {
 	struct marker_entry *entry;
 
-	mutex_lock(&markers_mutex);
 	entry = get_marker(channel, name);
-	mutex_unlock(&markers_mutex);
 
 	return entry && !!entry->refcount;
 }
+EXPORT_SYMBOL_GPL(_is_marker_enabled);
+
+/*
+ * is_marker_enabled - the wrapper of _is_marker_enabled
+ * @channel: channel name
+ * @name: marker name
+ *
+ * Returns 1 if the marker is enabled, 0 if disabled.
+ */
+int is_marker_enabled(const char *channel, const char *name)
+{
+	int ret;
+
+	lock_markers();
+	ret = _is_marker_enabled(channel, name);
+	unlock_markers();
+
+	return ret;
+}
 EXPORT_SYMBOL_GPL(is_marker_enabled);
 
 /**
-- 
1.7.0.4

