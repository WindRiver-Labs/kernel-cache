From 0d4b0712e5e0b4dee2e6925abe35442e693592cf Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Tue, 12 Aug 2008 10:33:01 -0400
Subject: [PATCH] lttng-netlink-control

LTTng - Netlink control

Control of tracing behavior from user-space through a netlink socket.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/netlink.h |    1 +
 ltt/ltt-control.c       |  127 +++++++++++++++++++++++++++++++++++++++++++++++
 ltt/ltt-control.h       |   30 +++++++++++
 3 files changed, 158 insertions(+), 0 deletions(-)
 create mode 100644 ltt/ltt-control.c
 create mode 100644 ltt/ltt-control.h

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 9ff1b54..359da5d 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -24,6 +24,7 @@
 /* leave room for NETLINK_DM (DM Events) */
 #define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
 #define NETLINK_ECRYPTFS	19
+#define NETLINK_LTT		31 	/* Linux Trace Toolkit FIXME */
 
 #define MAX_LINKS 32		
 
diff --git a/ltt/ltt-control.c b/ltt/ltt-control.c
new file mode 100644
index 0000000..2fa3b24
--- /dev/null
+++ b/ltt/ltt-control.c
@@ -0,0 +1,127 @@
+/*
+ * LTT control module over a netlink socket.
+ *
+ * Inspired from Relay Apps, by Tom Zanussi and iptables
+ *
+ * Copyright 2005 -
+ * 	Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ltt-tracer.h>
+#include <linux/netlink.h>
+#include <linux/inet.h>
+#include <linux/ip.h>
+#include <linux/security.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <net/sock.h>
+#include "ltt-control.h"
+
+#define LTTCTLM_BASE	0x10
+#define LTTCTLM_CONTROL	(LTTCTLM_BASE + 1)	/* LTT control message */
+
+static struct sock *socket;
+
+void ltt_control_input(struct sk_buff *skb)
+{
+	struct nlmsghdr *nlh = NULL;
+	u8 *payload = NULL;
+	lttctl_peer_msg_t *msg;
+	int err;
+	u32 rlen;
+
+	printk(KERN_DEBUG "ltt-control ltt_control_input\n");
+
+	while (skb->len >= NLMSG_SPACE(0)) {
+		nlh = nlmsg_hdr(skb);
+		if (nlh->nlmsg_len < sizeof(*nlh)
+				|| skb->len < nlh->nlmsg_len) {
+			printk(KERN_ALERT "Invalid netlink message (LTT)\n");
+			return;
+		}
+		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+		if (rlen > skb->len)
+			rlen = skb->len;
+		if (security_netlink_recv(skb, CAP_SYS_PTRACE)) {
+			netlink_ack(skb, nlh, EPERM);
+			goto next;
+		}
+		/* process netlink message pointed by skb->data */
+		err = EINVAL;
+		payload = NLMSG_DATA(nlh);
+		/*
+		 * process netlink message with header pointed by
+		 * nlh and payload pointed by payload
+		 */
+		if (nlh->nlmsg_len !=
+				sizeof(lttctl_peer_msg_t) +
+				sizeof(struct nlmsghdr)) {
+			printk(KERN_ALERT
+				"ltt-control bad message length %d vs. %zu\n",
+				nlh->nlmsg_len, sizeof(lttctl_peer_msg_t) +
+				sizeof(struct nlmsghdr));
+			netlink_ack(skb, nlh, EINVAL);
+			goto next;
+		}
+		msg = (lttctl_peer_msg_t *)payload;
+
+		switch (msg->op) {
+		case OP_CREATE:
+			err = ltt_control(LTT_CONTROL_CREATE_TRACE,
+					msg->trace_name,
+					msg->trace_type, msg->args);
+			break;
+		case OP_DESTROY:
+			err = ltt_control(LTT_CONTROL_DESTROY_TRACE,
+					msg->trace_name,
+					msg->trace_type, msg->args);
+			break;
+		case OP_START:
+			err = ltt_control(LTT_CONTROL_START,
+					msg->trace_name,
+					msg->trace_type, msg->args);
+			break;
+		case OP_STOP:
+			err = ltt_control(LTT_CONTROL_STOP,
+					msg->trace_name,
+					msg->trace_type, msg->args);
+			break;
+		default:
+			err = EBADRQC;
+			printk(KERN_INFO "ltt-control invalid operation\n");
+		}
+		netlink_ack(skb, nlh, err);
+next:
+		skb_pull(skb, rlen);
+	}
+}
+
+
+static int ltt_control_init(void)
+{
+	printk(KERN_INFO "ltt-control init\n");
+
+	socket = netlink_kernel_create(&init_net, NETLINK_LTT, 1,
+			ltt_control_input, NULL, THIS_MODULE);
+	if (socket == NULL)
+		return -EPERM;
+	else
+		return 0;
+}
+
+static void ltt_control_exit(void)
+{
+	printk(KERN_INFO "ltt-control exit\n");
+	sock_release(socket->sk_socket);
+}
+
+
+module_init(ltt_control_init)
+module_exit(ltt_control_exit)
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("Linux Trace Toolkit Controller");
+
diff --git a/ltt/ltt-control.h b/ltt/ltt-control.h
new file mode 100644
index 0000000..ac9bac4
--- /dev/null
+++ b/ltt/ltt-control.h
@@ -0,0 +1,30 @@
+/*
+ * LTT control module over a netlink socket.
+ *
+ * Inspired from Relay Apps, by Tom Zanussi and iptables
+ *
+ * Copyright 2005 -
+ * 	Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ */
+
+#ifndef _LTT_CONTROL_H
+#define _LTT_CONTROL_H
+
+enum trace_op {
+	OP_CREATE,
+	OP_DESTROY,
+	OP_START,
+	OP_STOP,
+	OP_ALIGN,
+	OP_NONE
+};
+
+typedef struct lttctl_peer_msg {
+	char trace_name[NAME_MAX];
+	char trace_type[NAME_MAX];
+	enum trace_op op;
+	union ltt_control_args args;
+} lttctl_peer_msg_t;
+
+#endif /* _LTT_CONTROL_H */
+
-- 
1.5.5.1

