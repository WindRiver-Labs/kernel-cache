From 794caf2ab8d1438d414ee6e0f72d8234e4a95746 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 2 Oct 2008 14:36:35 -0400
Subject: [PATCH] lttng-instrumentation-sh

LTTng - instrumentation SH

Partial SH64 instrumentation.

Changelog:
- fix do_fork instrumentation

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/sh/kernel/process_32.c |    7 +++++--
 arch/sh/kernel/process_64.c |    7 +++++--
 arch/sh/kernel/ptrace_32.c  |    5 +++++
 arch/sh/kernel/sys_sh.c     |    2 ++
 arch/sh/kernel/traps_32.c   |    8 +++++++-
 arch/sh/mm/fault_32.c       |   12 ++++++++++++
 6 files changed, 36 insertions(+), 5 deletions(-)

diff --git a/arch/sh/kernel/process_32.c b/arch/sh/kernel/process_32.c
index 3326a45..c271d50 100644
--- a/arch/sh/kernel/process_32.c
+++ b/arch/sh/kernel/process_32.c
@@ -161,6 +161,7 @@ __asm__(".align 5\n"
 /* Don't use this in BL=1(cli).  Or else, CPU resets! */
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
+	int pid;
 	struct pt_regs regs;
 
 	memset(&regs, 0, sizeof(regs));
@@ -171,8 +172,10 @@ int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 	regs.sr = (1 << 30);
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0,
-		       &regs, 0, NULL, NULL);
+	pid = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0,
+		&regs, 0, NULL, NULL);
+	trace_mark(kernel_arch_kthread_create, "pid %d fn %p", pid, fn);
+	return pid;
 }
 
 /*
diff --git a/arch/sh/kernel/process_64.c b/arch/sh/kernel/process_64.c
index b9dbd2d..7c1bd52 100644
--- a/arch/sh/kernel/process_64.c
+++ b/arch/sh/kernel/process_64.c
@@ -394,6 +394,7 @@ ATTRIB_NORET void kernel_thread_helper(void *arg, int (*fn)(void *))
  */
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
+	int pid;
 	struct pt_regs regs;
 
 	memset(&regs, 0, sizeof(regs));
@@ -403,8 +404,10 @@ int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 	regs.pc = (unsigned long)kernel_thread_helper;
 	regs.sr = (1 << 30);
 
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0,
-		       &regs, 0, NULL, NULL);
+	pid = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0,
+		&regs, 0, NULL, NULL);
+	trace_mark(kernel_arch_kthread_create, "pid %d fn %p", pid, fn);
+	return pid;
 }
 
 /*
diff --git a/arch/sh/kernel/ptrace_32.c b/arch/sh/kernel/ptrace_32.c
index 035cb30..36f23c7 100644
--- a/arch/sh/kernel/ptrace_32.c
+++ b/arch/sh/kernel/ptrace_32.c
@@ -232,6 +232,9 @@ asmlinkage long do_syscall_trace_enter(struct pt_regs *regs)
 {
 	long ret = 0;
 
+	trace_mark(kernel_arch_syscall_entry, "syscall_id %d ip #p%ld",
+		regs->regs[3], instruction_pointer(regs));
+
 	secure_computing(regs->regs[0]);
 
 	if (test_thread_flag(TIF_SYSCALL_TRACE) &&
@@ -255,6 +258,8 @@ asmlinkage void do_syscall_trace_leave(struct pt_regs *regs)
 {
 	int step;
 
+	trace_mark(kernel_arch_syscall_exit, MARK_NOARGS);
+
 	if (unlikely(current->audit_context))
 		audit_syscall_exit(AUDITSC_RESULT(regs->regs[0]),
 				   regs->regs[0]);
diff --git a/arch/sh/kernel/sys_sh.c b/arch/sh/kernel/sys_sh.c
index 9061b86..0305747 100644
--- a/arch/sh/kernel/sys_sh.c
+++ b/arch/sh/kernel/sys_sh.c
@@ -170,6 +170,8 @@ asmlinkage int sys_ipc(uint call, int first, int second,
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
+	trace_mark(kernel_arch_ipc_call, "call %u first %d", call, first);
+
 	if (call <= SEMTIMEDOP)
 		switch (call) {
 		case SEMOP:
diff --git a/arch/sh/kernel/traps_32.c b/arch/sh/kernel/traps_32.c
index 511a942..5b8c217 100644
--- a/arch/sh/kernel/traps_32.c
+++ b/arch/sh/kernel/traps_32.c
@@ -545,6 +545,9 @@ asmlinkage void do_address_error(struct pt_regs *regs,
 	lookup_exception_vector(error_code);
 #endif
 
+	trace_mark(kernel_arch_trap_entry, "trap_id %lu ip #p%ld",
+		(error_code >> 5), instruction_pointer(regs));
+
 	oldfs = get_fs();
 
 	if (user_mode(regs)) {
@@ -572,8 +575,10 @@ asmlinkage void do_address_error(struct pt_regs *regs,
 					      &user_mem_access);
 		set_fs(oldfs);
 
-		if (tmp==0)
+		if (!tmp) {
+			trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 			return; /* sorted */
+		}
 uspace_segv:
 		printk(KERN_NOTICE "Sending SIGBUS to \"%s\" due to unaligned "
 		       "access (PC %lx PR %lx)\n", current->comm, regs->pc,
@@ -601,6 +606,7 @@ uspace_segv:
 		handle_unaligned_access(instruction, regs, &user_mem_access);
 		set_fs(oldfs);
 	}
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 }
 
 #ifdef CONFIG_SH_DSP
diff --git a/arch/sh/mm/fault_32.c b/arch/sh/mm/fault_32.c
index 0c776fd..78447fb 100644
--- a/arch/sh/mm/fault_32.c
+++ b/arch/sh/mm/fault_32.c
@@ -92,6 +92,14 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
 
 	mm = tsk->mm;
 
+	trace_mark(kernel_arch_trap_entry, "trap_id %ld ip #p%ld",
+		({
+			unsigned long trapnr;
+			asm volatile("stc	r2_bank,%0": "=r" (trapnr));
+			trapnr;
+		}) >> 5,
+		instruction_pointer(regs));
+
 	/*
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
@@ -144,6 +152,7 @@ survive:
 		tsk->min_flt++;
 
 	up_read(&mm->mmap_sem);
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 	return;
 
 /*
@@ -160,6 +169,7 @@ bad_area_nosemaphore:
 		info.si_code = si_code;
 		info.si_addr = (void *) address;
 		force_sig_info(SIGSEGV, &info, tsk);
+		trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 		return;
 	}
 
@@ -240,6 +250,8 @@ do_sigbus:
 	/* Kernel mode? Handle exceptions or die */
 	if (!user_mode(regs))
 		goto no_context;
+
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 }
 
 #ifdef CONFIG_SH_STORE_QUEUES
-- 
1.5.5.1

