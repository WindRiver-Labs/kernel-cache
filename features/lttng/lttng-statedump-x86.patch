From b830435d69746859c4bc499ffee1588bdb64277c Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Tue, 15 Jul 2008 15:19:29 -0400
Subject: [PATCH] auto_msg: importing lttng-statedump-x86.patch

This is an automatic import of patch lttng-statedump-x86.patch, no headers were
detected and a default message was constructed
---
 arch/x86/Kconfig             |    1 +
 arch/x86/kernel/syscall_64.c |   17 +++++++++++++++++
 arch/x86/kernel/traps_32.c   |   33 +++++++++++++++++++++++++++++++++
 arch/x86/kernel/traps_64.c   |   16 ++++++++++++++++
 include/asm-x86/desc_defs.h  |   13 +++++++++++++
 include/linux/ltt-tracer.h   |   15 +++++++++++++++
 kernel/softirq.c             |   16 ++++++++++++++++
 ltt/Kconfig                  |    3 +++
 ltt/ltt-statedump.c          |    3 +++
 9 files changed, 117 insertions(+), 0 deletions(-)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index c56df5b..6db7e3a 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -28,6 +28,7 @@ config X86
 	select HAVE_IMMEDIATE
 	select HAVE_LTT_CLOCK
 	select HAVE_LTT_UNSTABLE_TSC
+	select HAVE_LTT_DUMP_TABLES
 
 config ARCH_DEFCONFIG
 	string
diff --git a/arch/x86/kernel/syscall_64.c b/arch/x86/kernel/syscall_64.c
index 170d43c..97cf8d9 100644
--- a/arch/x86/kernel/syscall_64.c
+++ b/arch/x86/kernel/syscall_64.c
@@ -1,8 +1,11 @@
 /* System call table for x86-64. */
 
 #include <linux/linkage.h>
+#include <linux/module.h>
 #include <linux/sys.h>
 #include <linux/cache.h>
+#include <linux/marker.h>
+#include <linux/kallsyms.h>
 #include <asm/asm-offsets.h>
 
 #define __NO_STUBS
@@ -27,3 +30,17 @@ const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
 	[0 ... __NR_syscall_max] = &sys_ni_syscall,
 #include <asm/unistd_64.h>
 };
+
+void ltt_dump_sys_call_table(void *call_data)
+{
+	int i;
+	char namebuf[KSYM_NAME_LEN];
+
+	for (i = 0; i < __NR_syscall_max + 1; i++) {
+		sprint_symbol(namebuf, (unsigned long)sys_call_table[i]);
+		__trace_mark(0, statedump_sys_call_table, call_data,
+			"id %d address %p symbol %s",
+			i, (void*)sys_call_table[i], namebuf);
+	}
+}
+EXPORT_SYMBOL_GPL(ltt_dump_sys_call_table);
diff --git a/arch/x86/kernel/traps_32.c b/arch/x86/kernel/traps_32.c
index bd7e4a8..bd2ef85 100644
--- a/arch/x86/kernel/traps_32.c
+++ b/arch/x86/kernel/traps_32.c
@@ -58,6 +58,7 @@
 #include <asm/nmi.h>
 #include <asm/smp.h>
 #include <asm/io.h>
+#include <asm/unistd.h>
 
 #include "mach_traps.h"
 
@@ -71,6 +72,9 @@ asmlinkage int system_call(void);
 /* Do we ignore FPU interrupts ? */
 char ignore_fpu_irq;
 
+extern unsigned long sys_call_table[];
+extern unsigned long syscall_table_size;
+
 /*
  * The IDT has to be page-aligned to simplify the Pentium
  * F0 0F bug workaround.. We have a special link segment
@@ -99,6 +103,21 @@ asmlinkage void alignment_check(void);
 asmlinkage void spurious_interrupt_bug(void);
 asmlinkage void machine_check(void);
 
+void ltt_dump_idt_table(void *call_data)
+{
+	int i;
+	char namebuf[KSYM_NAME_LEN];
+
+	for (i = 0; i < IDT_ENTRIES; i++) {
+		unsigned long address = desc_offset(&idt_table[i]);
+		sprint_symbol(namebuf, address);
+		__trace_mark(0, statedump_idt_table, call_data,
+			"irq %d address %p symbol %s",
+			i, (void *)address, namebuf);
+	}
+}
+EXPORT_SYMBOL_GPL(ltt_dump_idt_table);
+
 int kstack_depth_to_print = 24;
 static unsigned int code_bytes = 64;
 
@@ -1164,6 +1183,20 @@ unsigned long patch_espfix_desc(unsigned long uesp, unsigned long kesp)
 	return new_kesp;
 }
 
+void ltt_dump_sys_call_table(void *call_data)
+{
+	int i;
+	char namebuf[KSYM_NAME_LEN];
+
+	for (i = 0; i < NR_syscalls; i++) {
+		sprint_symbol(namebuf, sys_call_table[i]);
+		__trace_mark(0, statedump_sys_call_table, call_data,
+			"id %d address %p symbol %s",
+			i, (void*)sys_call_table[i], namebuf);
+	}
+}
+EXPORT_SYMBOL_GPL(ltt_dump_sys_call_table);
+
 /*
  * 'math_state_restore()' saves the current math information in the
  * old math state array, and gets the new ones from the current task
diff --git a/arch/x86/kernel/traps_64.c b/arch/x86/kernel/traps_64.c
index f98b8d4..cc20d34 100644
--- a/arch/x86/kernel/traps_64.c
+++ b/arch/x86/kernel/traps_64.c
@@ -32,6 +32,7 @@
 #include <linux/bug.h>
 #include <linux/kdebug.h>
 #include <linux/utsname.h>
+#include <linux/marker.h>
 
 #include <mach_traps.h>
 
@@ -1138,6 +1139,21 @@ asmlinkage void __attribute__((weak)) mce_threshold_interrupt(void)
 {
 }
 
+void ltt_dump_idt_table(void *call_data)
+{
+	int i;
+	char namebuf[KSYM_NAME_LEN];
+
+	for (i = 0; i < IDT_ENTRIES; i++) {
+		unsigned long address = gate_offset(&idt_table[i]);
+		sprint_symbol(namebuf, address);
+		__trace_mark(0, statedump_idt_table, call_data,
+			"irq %d address %p symbol %s",
+			i, (void *)address, namebuf);
+	}
+}
+EXPORT_SYMBOL_GPL(ltt_dump_idt_table);
+
 /*
  *  'math_state_restore()' saves the current math information in the
  * old math state array, and gets the new ones from the current task
diff --git a/include/asm-x86/desc_defs.h b/include/asm-x86/desc_defs.h
index eccb4ea..5cbd109 100644
--- a/include/asm-x86/desc_defs.h
+++ b/include/asm-x86/desc_defs.h
@@ -75,10 +75,23 @@ struct ldttss_desc64 {
 typedef struct gate_struct64 gate_desc;
 typedef struct ldttss_desc64 ldt_desc;
 typedef struct ldttss_desc64 tss_desc;
+
+static inline unsigned long gate_offset(gate_desc *gate)
+{
+	return ((unsigned long)gate->offset_low & 0xFFFF)
+			| (((unsigned long)gate->offset_middle & 0xFFFF) << 16)
+			| ((unsigned long)gate->offset_high << 32);
+}
 #else
 typedef struct desc_struct gate_desc;
 typedef struct desc_struct ldt_desc;
 typedef struct desc_struct tss_desc;
+
+static inline unsigned long desc_offset(gate_desc *gate)
+{
+	return ((unsigned long)gate->a & 0xFFFF)
+			| ((unsigned long)gate->b & 0xFFFF0000);
+}
 #endif
 
 struct desc_ptr {
diff --git a/include/linux/ltt-tracer.h b/include/linux/ltt-tracer.h
index 826b775..1c7a5a3 100644
--- a/include/linux/ltt-tracer.h
+++ b/include/linux/ltt-tracer.h
@@ -816,6 +816,21 @@ void ltt_unlock_traces(void);
 
 extern void ltt_dump_swap_files(void *call_data);
 
+extern void ltt_dump_softirq_vec(void *call_data);
+
+#ifdef CONFIG_HAVE_LTT_DUMP_TABLES
+extern void ltt_dump_sys_call_table(void *call_data);
+extern void ltt_dump_idt_table(void *call_data);
+#else
+static inline void ltt_dump_sys_call_table(void *call_data)
+{
+}
+
+static inline void ltt_dump_idt_table(void *call_data)
+{
+}
+#endif
+
 /* Relay IOCTL */
 
 /* Get the next sub buffer that can be read. */
diff --git a/kernel/softirq.c b/kernel/softirq.c
index a41ec11..56a84ec 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -20,6 +20,8 @@
 #include <linux/kthread.h>
 #include <linux/rcupdate.h>
 #include <linux/smp.h>
+#include <linux/marker.h>
+#include <linux/kallsyms.h>
 #include <linux/tick.h>
 #include "irq-trace.h"
 
@@ -49,6 +51,20 @@ EXPORT_SYMBOL(irq_stat);
 
 static struct softirq_action softirq_vec[32] __cacheline_aligned_in_smp;
 
+void ltt_dump_softirq_vec(void *call_data)
+{
+	int i;
+	char namebuf[KSYM_NAME_LEN];
+
+	for (i = 0; i < 32; i++) {
+		sprint_symbol(namebuf, (unsigned long)softirq_vec[i].action);
+		__trace_mark(0, statedump_softirq_vec, call_data,
+			"id %d address %p symbol %s",
+			i, softirq_vec[i].action, namebuf);
+	}
+}
+EXPORT_SYMBOL_GPL(ltt_dump_softirq_vec);
+
 static DEFINE_PER_CPU(struct task_struct *, ksoftirqd);
 
 /*
diff --git a/ltt/Kconfig b/ltt/Kconfig
index 9f12343..afcd4da 100644
--- a/ltt/Kconfig
+++ b/ltt/Kconfig
@@ -17,6 +17,9 @@ config HAVE_LTT_SYNTHETIC_TSC
 	default y if (!HAVE_LTT_CLOCK)
 	default n if HAVE_LTT_CLOCK
 
+config HAVE_LTT_DUMP_TABLES
+	def_bool n
+
 config LTT
 	bool "Linux Trace Toolkit Instrumentation Support"
 	depends on EXPERIMENTAL
diff --git a/ltt/ltt-statedump.c b/ltt/ltt-statedump.c
index c168e5b..0a57b77 100644
--- a/ltt/ltt-statedump.c
+++ b/ltt/ltt-statedump.c
@@ -329,6 +329,9 @@ static int do_ltt_statedump(struct ltt_probe_private_data *call_data)
 	list_interrupts(call_data);
 	ltt_enumerate_network_ip_interface(call_data);
 	ltt_dump_swap_files(call_data);
+	ltt_dump_sys_call_table(call_data);
+	ltt_dump_softirq_vec(call_data);
+	ltt_dump_idt_table(call_data);
 
 	/*
 	 * Fire off a work queue on each CPU. Their sole purpose in life
-- 
1.5.5.1

