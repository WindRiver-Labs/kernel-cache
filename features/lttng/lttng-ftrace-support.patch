From ca6d1c123e25dba7742727da1c483118bdc83772 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:41 -0400
Subject: [PATCH 157/391] lttng-ftrace-support

LTTng ftrace support

Add support for dynamically enabling function tracing between two
tracepoint/markers and export function entry events through LTTng.

Two modes are supported :
- Per-cpu "tap" (ftrace_cpu_start/ftrace_cpu_stop) will enable the tap for a
  given CPU on which the probes has been called.
- System-wide "tap" (ftrace_system_start/ftrace_system_stop) will enable tracing
  on every CPU as soon as a single CPU hits the start probe. It is left active
  until the same CPU hits the "stop" probe. Uses per-cpu boolean and global
  reference counting to make sure we detect when _at least_ one CPU is
  interested in opening the tap.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Steven Rostedt <rostedt@goodmis.org>
CC: akpm@linux-foundation.org
CC: Ingo Molnar <mingo@elte.hu>
CC: Peter Zijlstra <peterz@infradead.org>
CC: Masami Hiramatsu <mhiramat@redhat.com>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: Hideo AOKI <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
---
 ltt/Kconfig      |   12 ++++
 ltt/Makefile     |    1 +
 ltt/ltt-ftrace.c |  152 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 165 insertions(+), 0 deletions(-)
 create mode 100644 ltt/ltt-ftrace.c

diff --git a/ltt/Kconfig b/ltt/Kconfig
index bf41114..c0cc79f 100644
--- a/ltt/Kconfig
+++ b/ltt/Kconfig
@@ -176,4 +176,16 @@ config LTT_STATEDUMP
 	  This module saves the state of the running kernel at trace start
 	  into the trace buffers along with the ongoing tracing information.
 
+config LTT_FTRACE
+	bool "Linux Trace Toolkit Ftrace Support"
+	depends on LTT_TRACER
+	depends on LTT_TRACE_CONTROL=y
+	depends on FTRACE
+	default y
+	help
+	  Integration of function entry trace with LTTng. Connect the
+	  ftrace_cpu_start and ftrace_cpu_stop probes to markers to start/stop
+	  function tracing while a trace is being taken. Typically used when the
+	  surroundings of a problem has been identified in a prior trace.
+
 endif # LTT
diff --git a/ltt/Makefile b/ltt/Makefile
index ef63ce5..c9fb7fc 100644
--- a/ltt/Makefile
+++ b/ltt/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_LTT_USERSPACE_EVENT)	+= ltt-userspace-event.o
 obj-$(CONFIG_LTT_FILTER)		+= ltt-filter.o
 obj-$(CONFIG_LTT_KPROBES)		+= ltt-kprobes.o
 obj-$(CONFIG_LTT_TRACEPROBES)		+= probes/
+obj-$(CONFIG_LTT_FTRACE)		+= ltt-ftrace.o
diff --git a/ltt/ltt-ftrace.c b/ltt/ltt-ftrace.c
new file mode 100644
index 0000000..7bef53e
--- /dev/null
+++ b/ltt/ltt-ftrace.c
@@ -0,0 +1,152 @@
+/*
+ * (C) Copyright	2008 -
+ * 		Mathieu Desnoyers (mathieu.desnoyers@polymtl.ca)
+ *
+ * LTTng Ftrace integration module.
+ *
+ * Per-cpu "tap" (ftrace_cpu_start/ftrace_cpu_stop) will enable the tap for a
+ * given CPU on which the probes has been called.
+ *
+ * System-wide "tap" (ftrace_system_start/ftrace_system_stop) will enable
+ * tracing on every CPU as soon as a single CPU hits the start probe. It is left
+ * active until the same CPU hits the "stop" probe. Uses per-cpu boolean and
+ * global reference counting to make sure we detect when _at least_ one CPU is
+ * interested in opening the tap.
+ *
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/ftrace.h>
+#include <linux/ltt-tracer.h>
+#include <linux/marker.h>
+#include <asm/atomic.h>
+
+/* per-cpu function tracing activation */
+static DEFINE_PER_CPU(int, tracing_cpu);
+
+/* system-wide function tracing activation */
+static DEFINE_PER_CPU(int, system_tracing_cpu);
+static atomic_t system_trace_refcount __read_mostly;
+
+
+static notrace void
+ltt_tracer_call(unsigned long ip, unsigned long parent_ip)
+{
+	int cpu = raw_smp_processor_id();
+	if (likely(!per_cpu(tracing_cpu, cpu)
+			&& !atomic_read(&system_trace_refcount)))
+		return;
+	trace_mark(ftrace_entry, "ip 0x%lX parent_ip 0x%lX", ip, parent_ip);
+}
+
+static struct ftrace_ops trace_ops __read_mostly =
+{
+	.func = ltt_tracer_call,
+};
+
+static notrace void ftrace_cpu_start(void *probe_data, void *call_data,
+	const char *fmt, va_list *args)
+{
+	int cpu = raw_smp_processor_id();
+	per_cpu(tracing_cpu, cpu) = 1;
+}
+
+struct ltt_available_probe ftrace_cpu_start_probe = {
+	.name = "ftrace_cpu_start",
+	.format = NULL,
+	.probe_func = ftrace_cpu_start,
+};
+
+static notrace void ftrace_cpu_stop(void *probe_data, void *call_data,
+	const char *fmt, va_list *args)
+{
+	int cpu = raw_smp_processor_id();
+	per_cpu(tracing_cpu, cpu) = 0;
+}
+
+struct ltt_available_probe ftrace_cpu_stop_probe = {
+	.name = "ftrace_cpu_stop",
+	.format = NULL,
+	.probe_func = ftrace_cpu_stop,
+};
+
+static notrace void ftrace_system_start(void *probe_data, void *call_data,
+	const char *fmt, va_list *args)
+{
+	int cpu = raw_smp_processor_id();
+	int value = xchg(&per_cpu(system_tracing_cpu, cpu), 1);
+	if (!value)
+		atomic_inc(&system_trace_refcount);
+}
+
+struct ltt_available_probe ftrace_system_start_probe = {
+	.name = "ftrace_system_start",
+	.format = NULL,
+	.probe_func = ftrace_system_start,
+};
+
+static notrace void ftrace_system_stop(void *probe_data, void *call_data,
+	const char *fmt, va_list *args)
+{
+	int cpu = raw_smp_processor_id();
+	int value = xchg(&per_cpu(system_tracing_cpu, cpu), 0);
+	if (value)
+		atomic_dec(&system_trace_refcount);
+}
+
+struct ltt_available_probe ftrace_system_stop_probe = {
+	.name = "ftrace_system_stop",
+	.format = NULL,
+	.probe_func = ftrace_system_stop,
+};
+
+static int __init ltt_ftrace_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "LTT : ltt-ftrace init\n");
+	register_ftrace_function(&trace_ops);
+	ret = ltt_probe_register(&ftrace_cpu_start_probe);
+	BUG_ON(ret);
+	ret = ltt_probe_register(&ftrace_cpu_stop_probe);
+	BUG_ON(ret);
+	ret = ltt_probe_register(&ftrace_system_start_probe);
+	BUG_ON(ret);
+	ret = ltt_probe_register(&ftrace_system_stop_probe);
+	BUG_ON(ret);
+
+	/*
+	 * Keep a refcount on ourselves, because ftrace forbids freeing
+	 * trace_ops.
+	 */
+	/* __module_get(THIS_MODULE); */
+
+	return 0;
+}
+module_init(ltt_ftrace_init);
+
+#if 0
+/* create file operation to activate/deactivate these probes.
+ */
+static void __exit ltt_ftrace_exit(void)
+{
+	int ret;
+
+	printk(KERN_INFO "LTT : ltt-ftrace exit\n");
+	ret = ltt_probe_unregister(&ftrace_system_stop_probe);
+	BUG_ON(ret);
+	ret = ltt_probe_unregister(&ftrace_system_start_probe);
+	BUG_ON(ret);
+	ret = ltt_probe_unregister(&ftrace_cpu_stop_probe);
+	BUG_ON(ret);
+	ret = ltt_probe_unregister(&ftrace_cpu_start_probe);
+	BUG_ON(ret);
+	unregister_ftrace_function(&trace_ops);
+}
+module_exit(ltt_ftrace_exit);
+#endif //0
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("Linux Trace Toolkit Ftrace");
-- 
1.6.5.2

