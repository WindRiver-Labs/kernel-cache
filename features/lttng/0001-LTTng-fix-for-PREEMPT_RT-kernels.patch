From 231fc25a04285e828f070ae9fd75672e55eac4c6 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Tue, 15 Jul 2008 15:19:08 -0400
Subject: [PATCH] LTTng fix for PREEMPT_RT kernels

Fix BUG in RT preempt kernel caused by spinlocks taken within preempt disable
region.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/ltt-tracer.c |   16 ++++++++++++++++
 1 files changed, 16 insertions(+), 0 deletions(-)

diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index 6d5b8b0..f67044e 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -243,11 +243,27 @@ static void trace_async_wakeup(struct ltt_trace_struct *trace)
 static void async_wakeup(unsigned long data)
 {
 	struct ltt_trace_struct *trace;
+
+	/*
+	 * PREEMPT_RT does not allow spinlocks to be taken within preempt
+	 * disable sections (spinlock taken in wake_up). However, mainline won't
+	 * allow mutex to be taken in interrupt context. Ugly.
+	 * A proper way to do this would be to turn the timer into a
+	 * periodically woken up thread, but it adds to the footprint.
+	 */
+#ifndef CONFIG_PREEMPT_RT
 	preempt_disable();
+#else
+	ltt_lock_traces();
+#endif
 	list_for_each_entry_rcu(trace, &ltt_traces.head, list) {
 		trace_async_wakeup(trace);
 	}
+#ifndef CONFIG_PREEMPT_RT
 	preempt_enable();
+#else
+	ltt_unlock_traces();
+#endif
 
 	del_timer(&ltt_async_wakeup_timer);
 	ltt_async_wakeup_timer.expires = jiffies + LTT_PERCPU_TIMER_INTERVAL;
-- 
1.5.5.1

