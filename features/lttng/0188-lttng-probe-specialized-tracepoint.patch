From a6e386d016b9ff087e13af6f566a4a70891914a8 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 30 Oct 2008 23:27:27 -0400
Subject: [PATCH] lttng-probe-specialized-tracepoint

LTTng probes specialized tracepoints

tracing tbench runs gives those top event counts :

(~7 sec run)

kernel_arch_syscall_exit :   4570630
kernel_arch_syscall_entry :  4570589
kernel_timer_set :           2276276
kernel_softirq_entry :       1446470
kernel_softirq_exit :        1446469
kernel_sched_schedule :      1362552
kernel_sched_try_wakeup :    1140044
mm_page_alloc :              1033063
mm_page_free :                927878

All other events are much lower :
fs_write :                     20575

This patch creates specialized probes to accelerate tbench high-rate
events.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/probes/Makefile              |    2 +
 ltt/probes/kernel-trace.c        |  182 ++++++++++++++++++++++++++++++++------
 ltt/probes/ltt-type-serializer.c |   89 ++++++++++++++++++
 ltt/probes/ltt-type-serializer.h |   65 ++++++++++++++
 ltt/probes/mm-trace.c            |   87 +++++++++++++++---
 ltt/probes/syscall-trace.c       |   40 +++++++--
 ltt/probes/trap-trace.c          |   42 +++++++--
 7 files changed, 449 insertions(+), 58 deletions(-)
 create mode 100644 ltt/probes/ltt-type-serializer.c
 create mode 100644 ltt/probes/ltt-type-serializer.h

diff --git a/ltt/probes/Makefile b/ltt/probes/Makefile
index 83e3b58..068cee8 100644
--- a/ltt/probes/Makefile
+++ b/ltt/probes/Makefile
@@ -11,6 +11,8 @@ CFLAGS_REMOVE_syscall-trace.o = -pg
 CFLAGS_REMOVE_trap-trace.o = -pg
 endif
 
+obj-$(CONFIG_LTT_TRACEPROBES)	+= ltt-type-serializer.o
+
 obj-$(CONFIG_LTT_TRACEPROBES)	+= kernel-trace.o mm-trace.o fs-trace.o \
 				ipc-trace.o lockdep-trace.o rcu-trace.o \
 				syscall-trace.o trap-trace.o
diff --git a/ltt/probes/kernel-trace.c b/ltt/probes/kernel-trace.c
index b0e0f16..18b3004 100644
--- a/ltt/probes/kernel-trace.c
+++ b/ltt/probes/kernel-trace.c
@@ -6,50 +6,131 @@
 
 #include <linux/module.h>
 #include <linux/irq.h>
+#include <linux/ltt-tracer.h>
 #include <trace/irq.h>
 #include <trace/sched.h>
 #include <trace/timer.h>
 #include <trace/kernel.h>
 
-void probe_irq_entry(unsigned int id, struct pt_regs *regs)
+#include "ltt-type-serializer.h"
+
+/*
+ * FIXME :
+ * currently, the specialized tracepoint probes cannot call into other marker
+ * probes, such as ftrace enable/disable. Given we want them to be as fast as
+ * possible, it might not be so bad to lose this flexibility. But that means
+ * such probes would have to connect to tracepoints on their own.
+ */
+
+/* kernel_irq_entry specialized tracepoint probe */
+
+void probe_irq_entry(unsigned int id, struct pt_regs *regs);
+
+DEFINE_MARKER_TP(kernel_irq_entry, irq_entry, probe_irq_entry,
+	"irq_id %u kernel_mode %u ip %lu");
+
+notrace void probe_irq_entry(unsigned int id, struct pt_regs *regs)
 {
-	if (!regs)
+	struct marker *marker;
+	struct serialize_int_int_long data;
+
+	if (unlikely(!regs))
 		regs = get_irq_regs();
+	data.f1 = id;
+	if (likely(regs)) {
+		data.f2 = !user_mode(regs);
+		data.f3 = instruction_pointer(regs);
+	} else {
+		data.f2 = 1;
+		data.f3 = 0UL;
+	}
 
-	trace_mark_tp(kernel_irq_entry, irq_entry, probe_irq_entry,
-		"irq_id %u kernel_mode %u ip %lu",
-		id, (regs)?(!user_mode(regs)):(1),
-		(regs)?instruction_pointer(regs):0UL);
+	marker = &GET_MARKER(kernel_irq_entry);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
 }
 
-void probe_irq_exit(irqreturn_t retval)
+/* kernel_irq_exit specialized tracepoint probe */
+
+void probe_irq_exit(irqreturn_t retval);
+
+DEFINE_MARKER_TP(kernel_irq_exit, irq_exit, probe_irq_exit,
+	"handled #1u%u");
+
+notrace void probe_irq_exit(irqreturn_t retval)
 {
-	trace_mark_tp(kernel_irq_exit, irq_exit, probe_irq_exit,
-		"handled #1u%u", IRQ_RETVAL(retval));
+	struct marker *marker;
+	unsigned char data;
+
+	data = IRQ_RETVAL(retval);
+
+	marker = &GET_MARKER(kernel_irq_exit);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
 }
 
+/* kernel_softirq_entry specialized tracepoint probe */
+
 void probe_irq_softirq_entry(struct softirq_action *h,
+	struct softirq_action *softirq_vec);
+
+DEFINE_MARKER_TP(kernel_softirq_entry, irq_softirq_entry,
+	probe_irq_softirq_entry, "softirq_id %lu");
+
+notrace void probe_irq_softirq_entry(struct softirq_action *h,
 	struct softirq_action *softirq_vec)
 {
-	trace_mark_tp(kernel_softirq_entry, irq_softirq_entry,
-		probe_irq_softirq_entry, "softirq_id %lu",
-		((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h));
+	struct marker *marker;
+	unsigned long data;
+
+	data = ((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h);
+
+	marker = &GET_MARKER(kernel_softirq_entry);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
 }
 
+/* kernel_softirq_exit specialized tracepoint probe */
+
 void probe_irq_softirq_exit(struct softirq_action *h,
+	struct softirq_action *softirq_vec);
+
+DEFINE_MARKER_TP(kernel_softirq_exit, irq_softirq_exit,
+	probe_irq_softirq_exit, "softirq_id %lu");
+
+notrace void probe_irq_softirq_exit(struct softirq_action *h,
 	struct softirq_action *softirq_vec)
 {
-	trace_mark_tp(kernel_softirq_exit, irq_softirq_exit,
-		probe_irq_softirq_exit, "softirq_id %lu",
-		((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h));
+	struct marker *marker;
+	unsigned long data;
+
+	data = ((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h);
+
+	marker = &GET_MARKER(kernel_softirq_exit);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
 }
 
-void probe_irq_softirq_raise(unsigned int nr)
+/* kernel_softirq_raise specialized tracepoint probe */
+
+void probe_irq_softirq_raise(unsigned int nr);
+
+DEFINE_MARKER_TP(kernel_softirq_raise, irq_softirq_raise,
+	probe_irq_softirq_raise, "softirq_id %u");
+
+notrace void probe_irq_softirq_raise(unsigned int nr)
 {
-	trace_mark_tp(kernel_softirq_raise, irq_softirq_raise,
-		probe_irq_softirq_raise, "softirq_id %u", nr);
+	struct marker *marker;
+	unsigned int data;
+
+	data = nr;
+
+	marker = &GET_MARKER(kernel_softirq_raise);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, sizeof(data), sizeof(data));
 }
 
+/* Standard probes */
 void probe_irq_tasklet_low_entry(struct tasklet_struct *t)
 {
 	trace_mark_tp(kernel_tasklet_low_entry, irq_tasklet_low_entry,
@@ -97,11 +178,25 @@ void probe_sched_wait_task(struct rq *rq, struct task_struct *p)
 		p->pid, p->state);
 }
 
-void probe_sched_wakeup(struct rq *rq, struct task_struct *p)
+/* kernel_sched_try_wakeup specialized tracepoint probe */
+
+void probe_sched_wakeup(struct rq *rq, struct task_struct *p);
+
+DEFINE_MARKER_TP(kernel_sched_try_wakeup, sched_wakeup,
+	probe_sched_wakeup, "pid %d cpu_id %u state %ld");
+
+notrace void probe_sched_wakeup(struct rq *rq, struct task_struct *p)
 {
-	trace_mark_tp(kernel_sched_try_wakeup, sched_wakeup,
-		probe_sched_wakeup, "pid %d state %ld cpu_id %u",
-		p->pid, p->state, task_cpu(p));
+	struct marker *marker;
+	struct serialize_int_int_long data;
+
+	data.f1 = p->pid;
+	data.f2 = task_cpu(p);
+	data.f3 = p->state;
+
+	marker = &GET_MARKER(kernel_sched_try_wakeup);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
 }
 
 void probe_sched_wakeup_new(struct rq *rq, struct task_struct *p)
@@ -111,12 +206,27 @@ void probe_sched_wakeup_new(struct rq *rq, struct task_struct *p)
 		p->pid, p->state, task_cpu(p));
 }
 
+/* kernel_sched_schedule specialized tracepoint probe */
+
 void probe_sched_switch(struct rq *rq, struct task_struct *prev,
+		struct task_struct *next);
+
+DEFINE_MARKER_TP(kernel_sched_schedule, sched_switch, probe_sched_switch,
+	"prev_pid %d next_pid %d prev_state %ld");
+
+notrace void probe_sched_switch(struct rq *rq, struct task_struct *prev,
 		struct task_struct *next)
 {
-	trace_mark_tp(kernel_sched_schedule, sched_switch, probe_sched_switch,
-		"prev_pid %d next_pid %d prev_state %ld",
-		prev->pid, next->pid, prev->state);
+	struct marker *marker;
+	struct serialize_int_int_long data;
+
+	data.f1 = prev->pid;
+	data.f2 = next->pid;
+	data.f3 = prev->state;
+
+	marker = &GET_MARKER(kernel_sched_schedule);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
 }
 
 void probe_sched_migrate_task(struct rq *rq, struct task_struct *p,
@@ -187,11 +297,25 @@ void probe_timer_itimer_set(int which, struct itimerval *value)
 		value->it_value.tv_usec);
 }
 
-void probe_timer_set(struct timer_list *timer)
+/* kernel_timer_set specialized tracepoint probe */
+
+void probe_timer_set(struct timer_list *timer);
+
+DEFINE_MARKER_TP(kernel_timer_set, timer_set, probe_timer_set,
+	"expires %lu function %p data %lu");
+
+notrace void probe_timer_set(struct timer_list *timer)
 {
-	trace_mark_tp(kernel_timer_set, timer_set,
-		probe_timer_set, "expires %lu function %p data %lu",
-		timer->expires, timer->function, timer->data);
+	struct marker *marker;
+	struct serialize_long_long_long data;
+
+	data.f1 = timer->expires;
+	data.f2 = (unsigned long)timer->function;
+	data.f3 = timer->data;
+
+	marker = &GET_MARKER(kernel_timer_set);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
 }
 
 void probe_timer_update_time(struct timespec *_xtime,
diff --git a/ltt/probes/ltt-type-serializer.c b/ltt/probes/ltt-type-serializer.c
new file mode 100644
index 0000000..1f93181
--- /dev/null
+++ b/ltt/probes/ltt-type-serializer.c
@@ -0,0 +1,89 @@
+/**
+ * ltt-type-serializer.c
+ *
+ * LTTng specialized type serializer.
+ *
+ * Copyright Mathieu Desnoyers, 2008.
+ */
+#include <linux/module.h>
+#include "ltt-type-serializer.h"
+
+notrace void _ltt_specialized_trace(void *probe_data,
+		void *serialize_private, unsigned int data_size,
+		unsigned int largest_align)
+{
+	int ret;
+	struct ltt_active_marker *pdata;
+	uint16_t eID;
+	size_t slot_size;
+	int channel_index;
+	struct ltt_channel_struct *channel;
+	struct ltt_trace_struct *trace;
+	struct rchan_buf *buf;
+	void *transport_data;
+	uint64_t tsc;
+	long buf_offset;
+	int cpu;
+	unsigned int rflags;
+
+	/*
+	 * If we get here, it's probably because we have useful work to do.
+	 */
+	if (unlikely(ltt_traces.num_active_traces == 0))
+		return;
+
+	rcu_read_lock_sched_notrace();
+	cpu = smp_processor_id();
+	__get_cpu_var(ltt_nesting)++;
+
+	pdata = (struct ltt_active_marker *)probe_data;
+	eID = pdata->id;
+	channel_index = pdata->channel;
+
+	/* Iterate on each trace */
+	list_for_each_entry_rcu(trace, &ltt_traces.head, list) {
+		if (unlikely(!trace->active))
+			continue;
+		if (unlikely(!ltt_run_filter(trace, eID)))
+			continue;
+#ifdef CONFIG_LTT_DEBUG_EVENT_SIZE
+		rflags = LTT_RFLAG_ID_SIZE;
+#else
+		if (unlikely(eID >= LTT_FREE_EVENTS))
+			rflags = LTT_RFLAG_ID;
+		else
+			rflags = 0;
+#endif
+		channel = ltt_get_channel_from_index(trace, channel_index);
+		/* reserve space : header and data */
+		ret = ltt_reserve_slot(trace, channel, &transport_data,
+					data_size, &slot_size, &buf_offset,
+					&tsc, &rflags,
+					largest_align, cpu);
+		if (unlikely(ret < 0))
+			continue; /* buffer full */
+
+		/* FIXME : could probably encapsulate transport better. */
+		buf = ((struct rchan *)channel->trans_channel_data)->buf[cpu];
+		/* Out-of-order write : header and data */
+		buf_offset = ltt_write_event_header(trace,
+					channel, buf, buf_offset,
+					eID, data_size, tsc, rflags);
+		if (data_size) {
+			buf_offset += ltt_align(buf_offset, largest_align);
+			ltt_relay_write(buf, buf_offset, serialize_private,
+				data_size);
+			buf_offset += data_size;
+		}
+		/* Out-of-order commit */
+		ltt_commit_slot(channel, &transport_data, buf_offset,
+				slot_size);
+	}
+	__get_cpu_var(ltt_nesting)--;
+	rcu_read_unlock_sched_notrace();
+}
+EXPORT_SYMBOL_GPL(_ltt_specialized_trace);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("LTT type serializer");
diff --git a/ltt/probes/ltt-type-serializer.h b/ltt/probes/ltt-type-serializer.h
new file mode 100644
index 0000000..9d59726
--- /dev/null
+++ b/ltt/probes/ltt-type-serializer.h
@@ -0,0 +1,65 @@
+#ifndef _LTT_TYPE_SERIALIZER_H
+#define _LTT_TYPE_SERIALIZER_H
+
+#include <linux/ltt-tracer.h>
+
+/*
+ * largest_align must be non-zero, equal to the minimum between the largest type
+ * and sizeof(void *).
+ */
+extern void _ltt_specialized_trace(void *probe_data,
+		void *serialize_private, unsigned int data_size,
+		unsigned int largest_align);
+
+/*
+ * Statically check that 0 < largest_align < sizeof(void *) to make sure it is
+ * dumb-proof. It will make sure 0 is changed into 1 and unsigned long long is
+ * changed into sizeof(void *) on 32-bit architectures.
+ */
+static inline void ltt_specialized_trace(void *probe_data,
+		void *serialize_private, unsigned int data_size,
+		unsigned int largest_align)
+{
+	largest_align = min_t(unsigned int, largest_align, sizeof(void *));
+	largest_align = max_t(unsigned int, largest_align, 1);
+	_ltt_specialized_trace(probe_data, serialize_private, data_size,
+		largest_align);
+}
+
+/*
+ * Type serializer definitions.
+ */
+
+/*
+ * Return size of structure without end-of-structure padding.
+ */
+#define serialize_sizeof(type)	offsetof(typeof(type), end_field)
+
+struct serialize_long_int {
+	unsigned long f1;
+	unsigned int f2;
+	unsigned char end_field[0];
+} LTT_ALIGN;
+
+struct serialize_int_int_long {
+	unsigned int f1;
+	unsigned int f2;
+	unsigned long f3;
+	unsigned char end_field[0];
+} LTT_ALIGN;
+
+struct serialize_long_long_long {
+	unsigned long f1;
+	unsigned long f2;
+	unsigned long f3;
+	unsigned char end_field[0];
+} LTT_ALIGN;
+
+struct serialize_long_long_int {
+	unsigned long f1;
+	unsigned long f2;
+	unsigned int f3;
+	unsigned char end_field[0];
+} LTT_ALIGN;
+
+#endif /* _LTT_TYPE_SERIALIZER_H */
diff --git a/ltt/probes/mm-trace.c b/ltt/probes/mm-trace.c
index 866f388..077e429 100644
--- a/ltt/probes/mm-trace.c
+++ b/ltt/probes/mm-trace.c
@@ -17,6 +17,8 @@
 #include <trace/memory.h>
 #include <trace/hugetlb.h>
 
+#include "ltt-type-serializer.h"
+
 void probe_wait_on_page_start(struct page *page, int bit_nr)
 {
 	trace_mark_tp(mm_wait_on_page_start, wait_on_page_start,
@@ -44,33 +46,88 @@ void probe_hugetlb_page_alloc(struct page *page)
 			probe_hugetlb_page_alloc, "pfn %lu", page_to_pfn(page));
 }
 
+/* mm_handle_fault_entry specialized tracepoint probe */
+
 void probe_memory_handle_fault_entry(struct mm_struct *mm,
+	struct vm_area_struct *vma, unsigned long address, int write_access);
+
+DEFINE_MARKER_TP(mm_handle_fault_entry, memory_handle_fault_entry,
+	probe_memory_handle_fault_entry,
+	"address %lu ip #p%ld write_access %d");
+
+notrace void probe_memory_handle_fault_entry(struct mm_struct *mm,
 	struct vm_area_struct *vma, unsigned long address, int write_access)
 {
-	trace_mark_tp(mm_handle_fault_entry, memory_handle_fault_entry,
-		probe_memory_handle_fault_entry,
-		"address %lu ip #p%ld write_access %d",
-		address, KSTK_EIP(current), write_access);
+	struct marker *marker;
+	struct serialize_long_long_int data;
+
+	data.f1 = address;
+	data.f2 = KSTK_EIP(current);
+	data.f3 = write_access;
+
+	marker = &GET_MARKER(mm_handle_fault_entry);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
 }
 
-void probe_memory_handle_fault_exit(int res)
+/* mm_handle_fault_exit specialized tracepoint probe */
+
+void probe_memory_handle_fault_exit(int res);
+
+DEFINE_MARKER_TP(mm_handle_fault_exit, memory_handle_fault_exit,
+	probe_memory_handle_fault_exit,
+	"res %d");
+
+notrace void probe_memory_handle_fault_exit(int res)
 {
-	trace_mark_tp(mm_handle_fault_exit, memory_handle_fault_exit,
-		probe_memory_handle_fault_exit, "res %d", res);
+	struct marker *marker;
+
+	marker = &GET_MARKER(mm_handle_fault_exit);
+	ltt_specialized_trace(marker->single.probe_private,
+		&res, sizeof(res), sizeof(res));
 }
 
-void probe_page_free(struct page *page, unsigned int order)
+/* mm_page_free specialized tracepoint probe */
+
+void probe_page_free(struct page *page, unsigned int order);
+
+DEFINE_MARKER_TP(mm_page_free, page_free, probe_page_free,
+	"pfn %lu order %u");
+
+notrace void probe_page_free(struct page *page, unsigned int order)
 {
-	trace_mark_tp(mm_page_free, page_free,
-		probe_page_free, "order %u pfn %lu", order, page_to_pfn(page));
+	struct marker *marker;
+	struct serialize_long_int data;
+
+	data.f1 = page_to_pfn(page);
+	data.f2 = order;
+
+	marker = &GET_MARKER(mm_page_free);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
 }
 
-void probe_page_alloc(struct page *page, unsigned int order)
+/* mm_page_alloc specialized tracepoint probe */
+
+void probe_page_alloc(struct page *page, unsigned int order);
+
+DEFINE_MARKER_TP(mm_page_alloc, page_alloc, probe_page_alloc,
+	"pfn %lu order %u");
+
+notrace void probe_page_alloc(struct page *page, unsigned int order)
 {
-	if (page)
-		trace_mark_tp(mm_page_alloc, page_alloc,
-			probe_page_alloc, "order %u pfn %lu", order,
-			page_to_pfn(page));
+	struct marker *marker;
+	struct serialize_long_int data;
+
+	if (unlikely(!page))
+		return;
+
+	data.f1 = page_to_pfn(page);
+	data.f2 = order;
+
+	marker = &GET_MARKER(mm_page_alloc);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
 }
 
 #ifdef CONFIG_SWAP
diff --git a/ltt/probes/syscall-trace.c b/ltt/probes/syscall-trace.c
index fbb12f2..a793ad4 100644
--- a/ltt/probes/syscall-trace.c
+++ b/ltt/probes/syscall-trace.c
@@ -7,17 +7,43 @@
 #include <linux/module.h>
 #include <trace/syscall.h>
 
-void probe_syscall_entry(struct pt_regs *regs, long id)
+#include "ltt-type-serializer.h"
+
+
+/* kernel_syscall_entry specialized tracepoint probe */
+
+void probe_syscall_entry(struct pt_regs *regs, long id);
+
+DEFINE_MARKER_TP(kernel_syscall_entry, syscall_entry,
+	probe_syscall_entry, "ip #p%ld syscall_id %d");
+
+notrace void probe_syscall_entry(struct pt_regs *regs, long id)
 {
-	trace_mark_tp(kernel_syscall_entry, syscall_entry,
-		probe_syscall_entry, "ip #p%ld syscall_id %d",
-		instruction_pointer(regs), (int)id);
+	struct marker *marker;
+	struct serialize_long_int data;
+
+	data.f1 = instruction_pointer(regs);
+	data.f2 = (int)id;
+
+	marker = &GET_MARKER(kernel_syscall_entry);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
 }
 
-void probe_syscall_exit(long ret)
+/* kernel_syscall_exit specialized tracepoint probe */
+
+void probe_syscall_exit(long ret);
+
+DEFINE_MARKER_TP(kernel_syscall_exit, syscall_exit,
+	probe_syscall_exit, "ret %ld");
+
+notrace void probe_syscall_exit(long ret)
 {
-	trace_mark_tp(kernel_syscall_exit, syscall_exit,
-		probe_syscall_exit, "ret %ld", ret);
+	struct marker *marker;
+
+	marker = &GET_MARKER(kernel_syscall_exit);
+	ltt_specialized_trace(marker->single.probe_private,
+		&ret, sizeof(ret), sizeof(ret));
 }
 
 MODULE_LICENSE("GPL");
diff --git a/ltt/probes/trap-trace.c b/ltt/probes/trap-trace.c
index 8261607..76489cd 100644
--- a/ltt/probes/trap-trace.c
+++ b/ltt/probes/trap-trace.c
@@ -7,17 +7,45 @@
 #include <linux/module.h>
 #include <trace/trap.h>
 
-void probe_trap_entry(struct pt_regs *regs, long id)
+#include "ltt-type-serializer.h"
+
+/* kernel_trap_entry specialized tracepoint probe */
+
+void probe_trap_entry(struct pt_regs *regs, long id);
+
+DEFINE_MARKER_TP(kernel_trap_entry, trap_entry,
+	probe_trap_entry, "ip #p%ld trap_id %d");
+
+notrace void probe_trap_entry(struct pt_regs *regs, long id)
 {
-	trace_mark_tp(kernel_trap_entry, trap_entry,
-		probe_trap_entry, "ip #p%ld trap_id %d",
-		instruction_pointer(regs), (int)id);
+	struct marker *marker;
+	struct serialize_long_int data;
+
+	if (likely(regs))
+		data.f1 = instruction_pointer(regs);
+	else
+		data.f1 = 0UL;
+	data.f2 = (unsigned int)id;
+
+	marker = &GET_MARKER(kernel_trap_entry);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
 }
 
-void probe_trap_exit(void)
+/* kernel_syscall_exit specialized tracepoint probe */
+
+void probe_trap_exit(void);
+
+DEFINE_MARKER_TP(kernel_trap_exit, trap_exit,
+	probe_trap_exit, MARK_NOARGS);
+
+notrace void probe_trap_exit(void)
 {
-	trace_mark_tp(kernel_trap_exit, trap_exit,
-		probe_trap_exit, MARK_NOARGS);
+	struct marker *marker;
+
+	marker = &GET_MARKER(kernel_trap_exit);
+	ltt_specialized_trace(marker->single.probe_private,
+		NULL, 0, 0);
 }
 
 MODULE_LICENSE("GPL");
-- 
1.5.5.1

