From 5f9fc8ba7fa742b3342a19afe5bac418afcf1177 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:27:46 -0400
Subject: [PATCH 277/391] lttng-check-min-sb-size-page-size

LTTng check min subbuffer size page size

The mininum size of a subbuffer (not just buffer) must be at least a page.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-relay.h |    3 ---
 ltt/ltt-relay-alloc.c     |   16 ++++++++++++----
 ltt/ltt-tracer.c          |    4 ++++
 3 files changed, 16 insertions(+), 7 deletions(-)

diff --git a/include/linux/ltt-relay.h b/include/linux/ltt-relay.h
index 337c039..b79e586 100644
--- a/include/linux/ltt-relay.h
+++ b/include/linux/ltt-relay.h
@@ -25,9 +25,6 @@
 #include <linux/mm.h>
 #include <linux/ltt-core.h>
 
-/* Needs a _much_ better name... */
-#define FIX_SIZE(x) ((((x) - 1) & PAGE_MASK) + PAGE_SIZE)
-
 /* Use lowest pointer bit to show the sub-buffer has no reference. */
 #define RCHAN_NOREF_FLAG	0x1UL
 
diff --git a/ltt/ltt-relay-alloc.c b/ltt/ltt-relay-alloc.c
index ef9f78e..43a8171 100644
--- a/ltt/ltt-relay-alloc.c
+++ b/ltt/ltt-relay-alloc.c
@@ -39,7 +39,6 @@ static int relay_alloc_buf(struct rchan_buf *buf, size_t *size,
 	struct page **pages;
 	void **virt;
 
-	*size = PAGE_ALIGN(*size);
 	n_pages = *size >> PAGE_SHIFT;
 	n_pages_per_sb = n_pages >> get_count_order(n_subbufs);
 	if (extra_reader_sb)
@@ -421,8 +420,8 @@ static int __cpuinit relay_hotcpu_callback(struct notifier_block *nb,
  *	ltt_relay_open - create a new relay channel
  *	@base_filename: base name of files to create
  *	@parent: dentry of parent directory, %NULL for root directory
- *	@subbuf_size: size of sub-buffers
- *	@n_subbufs: number of sub-buffers
+ *	@subbuf_size: size of sub-buffers (> PAGE_SIZE, power of 2)
+ *	@n_subbufs: number of sub-buffers (power of 2)
  *	@cb: client callback functions
  *	@private_data: user-defined data
  *	@extra_reader_sb: allocate an extra subbuffer for the reader
@@ -454,11 +453,20 @@ struct rchan *ltt_relay_open(const char *base_filename,
 	if (!chan)
 		return NULL;
 
+	/* Check that the subbuffer size is larger than a page. */
+	WARN_ON_ONCE(subbuf_size < PAGE_SIZE);
+
+	/*
+	 * Make sure the number of subbuffers and subbuffer size are power of 2.
+	 */
+	WARN_ON_ONCE(hweight32(subbuf_size) != 1);
+	WARN_ON(hweight32(n_subbufs) != 1);
+
 	chan->version = LTT_RELAY_CHANNEL_VERSION;
 	chan->n_subbufs = n_subbufs;
 	chan->subbuf_size = subbuf_size;
 	chan->subbuf_size_order = get_count_order(subbuf_size);
-	chan->alloc_size = FIX_SIZE(subbuf_size * n_subbufs);
+	chan->alloc_size = subbuf_size * n_subbufs;
 	chan->parent = parent;
 	chan->private_data = private_data;
 	chan->extra_reader_sb = extra_reader_sb;
diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index 2bf5219..81cc4dd 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -512,6 +512,10 @@ EXPORT_SYMBOL_GPL(ltt_release_trace);
 static inline void prepare_chan_size_num(unsigned int *subbuf_size,
 					 unsigned int *n_subbufs)
 {
+	/* Make sure the subbuffer size is larger than a page */
+	*subbuf_size = max_t(unsigned int, *subbuf_size, PAGE_SIZE);
+
+	/* round to next power of 2 */
 	*subbuf_size = 1 << get_count_order(*subbuf_size);
 	*n_subbufs = 1 << get_count_order(*n_subbufs);
 
-- 
1.6.5.2

