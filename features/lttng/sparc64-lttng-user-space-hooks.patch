From e797c78897bdbc02502750b47934debbb6488bbe Mon Sep 17 00:00:00 2001
From: Vu Tran <vu.tran@windriver.com>
Date: Wed, 5 Nov 2008 18:53:18 -0500
Subject: [PATCH] sparc64 lttng user space hooks

Add SPARC64 LTTng user space hooks.

Signed-off-by: Vu Tran <vu.tran@windriver.com>
Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 arch/sparc/include/asm/thread_info_64.h |    2 ++
 arch/sparc64/Kconfig                    |    1 +
 arch/sparc64/kernel/signal.c            |   14 ++++++++++++++
 include/linux/sched.h                   |   10 ++++++++++
 4 files changed, 27 insertions(+), 0 deletions(-)

diff --git a/arch/sparc/include/asm/thread_info_64.h b/arch/sparc/include/asm/thread_info_64.h
index 28522eb..ca9c5a4 100644
--- a/arch/sparc/include/asm/thread_info_64.h
+++ b/arch/sparc/include/asm/thread_info_64.h
@@ -229,6 +229,7 @@ register struct thread_info *current_thread_info_reg asm("g6");
 #define TIF_KERNEL_TRACE	8	/* kernel trace active */
 #define TIF_SECCOMP		9	/* secure computing */
 #define TIF_SYSCALL_AUDIT	10	/* syscall auditing active */
+#define TIF_MARKER_PENDING	11	/* marker update pending */
 /* flag bit 11 is available */
 /* NOTE: Thread flags >= 12 should be ones we have no interest
  *       in using in assembly, else we can't use the mask as
@@ -248,6 +249,7 @@ register struct thread_info *current_thread_info_reg asm("g6");
 #define _TIF_KERNEL_TRACE	(1<<TIF_KERNEL_TRACE)
 #define _TIF_SECCOMP		(1<<TIF_SECCOMP)
 #define _TIF_SYSCALL_AUDIT	(1<<TIF_SYSCALL_AUDIT)
+#define _TIF_MARKER_PENDING	(1 << TIF_MARKER_PENDING)
 #define _TIF_ABI_PENDING	(1<<TIF_ABI_PENDING)
 #define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
 
diff --git a/arch/sparc64/Kconfig b/arch/sparc64/Kconfig
index c5a0dcd..0132857 100644
--- a/arch/sparc64/Kconfig
+++ b/arch/sparc64/Kconfig
@@ -17,6 +17,7 @@ config SPARC64
 	select HAVE_GET_CYCLES
 	select HAVE_LMB
 	select HAVE_SYSCALL_WRAPPERS
+	select HAVE_MARKERS_ABI
 	select HAVE_ARCH_KGDB
 	select USE_GENERIC_SMP_HELPERS if SMP
 	select HAVE_ARCH_TRACEHOOK
diff --git a/arch/sparc64/kernel/signal.c b/arch/sparc64/kernel/signal.c
index ec82d76..56d9fd5 100644
--- a/arch/sparc64/kernel/signal.c
+++ b/arch/sparc64/kernel/signal.c
@@ -614,4 +614,18 @@ void do_notify_resume(struct pt_regs *regs, unsigned long orig_i0, unsigned long
 		clear_thread_flag(TIF_NOTIFY_RESUME);
 		tracehook_notify_resume(regs);
 	}
+#ifdef CONFIG_MARKERS_USERSPACE
+	/* Pending marker update ? */
+	if (thread_info_flags & _TIF_MARKER_PENDING) {
+		/*
+		 * marker_update_process can sleep because it writes to
+		 * userspace and because it takes a mutex. While locking could
+		 * be changed to a non-blocking scheme, it is good do do not
+		 * fail on userspace page faults.
+		 */
+		local_irq_enable();
+		marker_update_process();
+		local_irq_disable();
+	}
+#endif
 }
diff --git a/include/linux/sched.h b/include/linux/sched.h
index f972de1..0038cfe 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1322,6 +1322,16 @@ struct task_struct {
         void (*proc_destruct)(void *proc);
 #endif
 
+#ifdef CONFIG_MARKERS_USERSPACE
+	/*
+	 * user_markers and user_markers_sequence updates are protected
+	 * by the per process user_markers_mutex nested in the markers_mutex.
+	 * Taking one of these mutexes is enough to insure coherent read.
+	 */
+	struct mutex user_markers_mutex;
+	struct hlist_head user_markers;
+	unsigned long user_markers_sequence;
+#endif
 };
 
 /*
