From 7fd0676624c4dae06309887112f0183000775855 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Tue, 12 Aug 2008 10:32:40 -0400
Subject: [PATCH] lttng-instrumentation-lockdep

LTTng instrumentation lockdep tracepoints

lockdep_hardirqs_off
lockdep_hardirqs_on
lockdep_lock_acquire
lockdep_lock_release
lockdep_softirqs_off
lockdep_softirqs_on

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/trace/lockdep.h |   32 ++++++++++++++++++++++++++++++++
 kernel/lockdep.c        |   13 +++++++++++++
 2 files changed, 45 insertions(+), 0 deletions(-)
 create mode 100644 include/trace/lockdep.h

diff --git a/include/trace/lockdep.h b/include/trace/lockdep.h
new file mode 100644
index 0000000..4c8d806
--- /dev/null
+++ b/include/trace/lockdep.h
@@ -0,0 +1,32 @@
+#ifndef _TRACE_LOCKDEP_H
+#define _TRACE_LOCKDEP_H
+
+#include <linux/tracepoint.h>
+
+/*
+ * lockdep tracing must be very careful with respect to reentrancy.
+ *
+ * It should not use immediate values for activation because it involves
+ * traps called when the code patching is done.
+ */
+DEFINE_TRACE(lockdep_hardirqs_on,
+	TPPROTO(void *retaddr),
+		TPARGS(retaddr));
+DEFINE_TRACE(lockdep_hardirqs_off,
+	TPPROTO(void *retaddr),
+		TPARGS(retaddr));
+DEFINE_TRACE(lockdep_softirqs_on,
+	TPPROTO(void *retaddr),
+		TPARGS(retaddr));
+DEFINE_TRACE(lockdep_softirqs_off,
+	TPPROTO(void *retaddr),
+		TPARGS(retaddr));
+DEFINE_TRACE(lockdep_lock_acquire,
+	TPPROTO(unsigned long retaddr, unsigned int subclass,
+			struct lockdep_map *lock, int trylock),
+		TPARGS(retaddr, subclass, lock, trylock));
+DEFINE_TRACE(lockdep_lock_release,
+	TPPROTO(unsigned long retaddr, struct lockdep_map *lock, int nested),
+		TPARGS(retaddr, lock, nested));
+
+#endif
diff --git a/kernel/lockdep.c b/kernel/lockdep.c
index d38a643..d27197c 100644
--- a/kernel/lockdep.c
+++ b/kernel/lockdep.c
@@ -40,6 +40,7 @@
 #include <linux/utsname.h>
 #include <linux/hash.h>
 #include <linux/ftrace.h>
+#include <trace/lockdep.h>
 
 #include <asm/sections.h>
 
@@ -2062,6 +2063,8 @@ void trace_hardirqs_on_caller(unsigned long a0)
 
 	time_hardirqs_on(CALLER_ADDR0, a0);
 
+	_trace_lockdep_hardirqs_on(__builtin_return_address(0));
+
 	if (unlikely(!debug_locks || current->lockdep_recursion))
 		return;
 
@@ -2116,6 +2119,8 @@ void trace_hardirqs_off_caller(unsigned long a0)
 
 	time_hardirqs_off(CALLER_ADDR0, a0);
 
+	_trace_lockdep_hardirqs_off(__builtin_return_address(0));
+
 	if (unlikely(!debug_locks || current->lockdep_recursion))
 		return;
 
@@ -2148,6 +2153,8 @@ void trace_softirqs_on(unsigned long ip)
 {
 	struct task_struct *curr = current;
 
+	_trace_lockdep_softirqs_on(__builtin_return_address(0));
+
 	if (unlikely(!debug_locks))
 		return;
 
@@ -2182,6 +2189,8 @@ void trace_softirqs_off(unsigned long ip)
 {
 	struct task_struct *curr = current;
 
+	_trace_lockdep_softirqs_off(__builtin_return_address(0));
+
 	if (unlikely(!debug_locks))
 		return;
 
@@ -2414,6 +2423,8 @@ static int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,
 	int chain_head = 0;
 	u64 chain_key;
 
+	_trace_lockdep_lock_acquire(ip, subclass, lock, trylock);
+
 	if (!prove_locking)
 		check = 1;
 
@@ -2687,6 +2698,8 @@ __lock_release(struct lockdep_map *lock, int nested, unsigned long ip)
 {
 	struct task_struct *curr = current;
 
+	_trace_lockdep_lock_release(ip, lock, nested);
+
 	if (!check_unlock(curr, lock, ip))
 		return;
 
-- 
1.5.5.1

