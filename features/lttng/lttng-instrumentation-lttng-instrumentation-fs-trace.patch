From 173ef00430e365f3efc15400cb929c58f1aa882a Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:07 -0400
Subject: [PATCH 100/390] lttng-instrumentation/lttng-instrumentation-fs-tracepoints-probes

LTTng instrumentation FS tracepoint probes

Create a module which declares FS tracepoint probes, using markers.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Alexander Viro <viro@zeniv.linux.org.uk>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Masami Hiramatsu <mhiramat@redhat.com>
---
 ltt/probes/Makefile   |    3 +-
 ltt/probes/fs-trace.c |  129 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 131 insertions(+), 1 deletions(-)
 create mode 100644 ltt/probes/fs-trace.c

diff --git a/ltt/probes/Makefile b/ltt/probes/Makefile
index 9f5876e..4c925fa 100644
--- a/ltt/probes/Makefile
+++ b/ltt/probes/Makefile
@@ -3,9 +3,10 @@
 ifdef CONFIG_FTRACE
 CFLAGS_REMOVE_kernel-trace.o = -pg
 CFLAGS_REMOVE_mm-trace.o = -pg
+CFLAGS_REMOVE_fs-trace.o = -pg
 endif
 
-obj-$(CONFIG_LTT_TRACEPROBES)	+= kernel-trace.o mm-trace.o
+obj-$(CONFIG_LTT_TRACEPROBES)	+= kernel-trace.o mm-trace.o fs-trace.o
 
 ifeq ($(CONFIG_NET),y)
 ifdef CONFIG_FTRACE
diff --git a/ltt/probes/fs-trace.c b/ltt/probes/fs-trace.c
new file mode 100644
index 0000000..fa63ae6
--- /dev/null
+++ b/ltt/probes/fs-trace.c
@@ -0,0 +1,129 @@
+/*
+ * ltt/probes/fs-trace.c
+ *
+ * FS tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/buffer_head.h>
+#include <trace/fs.h>
+
+void probe_fs_buffer_wait_start(struct buffer_head *bh)
+{
+	trace_mark_tp(fs_buffer_wait_start, fs_buffer_wait_start,
+		probe_fs_buffer_wait_start, "bh %p", bh);
+}
+
+void probe_fs_buffer_wait_end(struct buffer_head *bh)
+{
+	trace_mark_tp(fs_buffer_wait_end, fs_buffer_wait_end,
+		probe_fs_buffer_wait_end, "bh %p", bh);
+}
+
+void probe_fs_exec(char *filename)
+{
+	trace_mark_tp(fs_exec, fs_exec, probe_fs_exec, "filename %s", filename);
+}
+
+void probe_fs_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	trace_mark_tp(fs_ioctl, fs_ioctl, probe_fs_ioctl,
+		"fd %u cmd %u arg %lu", fd, cmd, arg);
+}
+
+void probe_fs_open(int fd, char *filename)
+{
+	trace_mark_tp(fs_open, fs_open, probe_fs_open,
+		"fd %d filename %s", fd, filename);
+}
+
+void probe_fs_close(unsigned int fd)
+{
+	trace_mark_tp(fs_close, fs_close, probe_fs_close, "fd %u", fd);
+}
+
+void probe_fs_lseek(unsigned int fd, long offset, unsigned int origin)
+{
+	trace_mark_tp(fs_lseek, fs_lseek, probe_fs_lseek,
+		"fd %u offset %ld origin %u", fd, offset, origin);
+}
+
+void probe_fs_llseek(unsigned int fd, loff_t offset, unsigned int origin)
+{
+	trace_mark_tp(fs_llseek, fs_llseek, probe_fs_llseek,
+		"fd %u offset %lld origin %u", fd,
+		(long long)offset, origin);
+}
+
+void probe_fs_read(unsigned int fd, char __user *buf, size_t count,
+		ssize_t ret)
+{
+	trace_mark_tp(fs_read, fs_read, probe_fs_read,
+		"fd %u count %zu", fd, count);
+}
+
+void probe_fs_write(unsigned int fd, const char __user *buf,
+		size_t count, ssize_t ret)
+{
+	trace_mark_tp(fs_write, fs_write, probe_fs_write,
+		"fd %u count %zu", fd, count);
+}
+
+void probe_fs_pread64(unsigned int fd, char __user *buf, size_t count,
+		loff_t pos, ssize_t ret)
+{
+	trace_mark_tp(fs_pread64, fs_pread64, probe_fs_pread64,
+		"fd %u count %zu pos %llu",
+		fd, count, (unsigned long long)pos);
+}
+
+void probe_fs_pwrite64(unsigned int fd, const char __user *buf,
+		size_t count, loff_t pos, ssize_t ret)
+{
+	trace_mark_tp(fs_pwrite64, fs_pwrite64, probe_fs_pwrite64,
+		"fd %u count %zu pos %llu",
+		fd, count, (unsigned long long)pos);
+}
+
+void probe_fs_readv(unsigned long fd, const struct iovec __user *vec,
+		unsigned long vlen, ssize_t ret)
+{
+	trace_mark_tp(fs_readv, fs_readv, probe_fs_readv,
+		"fd %lu vlen %lu", fd, vlen);
+}
+
+void probe_fs_writev(unsigned long fd, const struct iovec __user *vec,
+		unsigned long vlen, ssize_t ret)
+{
+	trace_mark_tp(fs_writev, fs_writev, probe_fs_writev,
+		"fd %lu vlen %lu", fd, vlen);
+}
+
+void probe_fs_select(int fd, struct timespec *end_time)
+{
+	struct timespec tmptime;
+
+	if (end_time) {
+		tmptime = *end_time;
+	} else {
+		tmptime.tv_sec = -1L;
+		tmptime.tv_nsec = -1L;
+	}
+
+	trace_mark_tp(fs_select, fs_select, probe_fs_select,
+		"fd %d end_time_sec %ld end_time_nsec %ld", fd,
+			tmptime.tv_sec, tmptime.tv_nsec);
+}
+
+void probe_fs_poll(int fd)
+{
+	trace_mark_tp(fs_pollfd, fs_poll, probe_fs_poll,
+		"fd %d", fd);
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("FS Tracepoint Probes");
-- 
1.6.5.2

