From e45d07e3c016f8e9fc178431f2adb0436403fa29 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Wed, 30 May 2012 11:05:14 -0700
Subject: [PATCH 089/248] lttng-instrumentation/lttng-instrumentation-powerpc

LTTng instrumentation Powerpc

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/powerpc/kernel/misc_32.S   |    2 +-
 arch/powerpc/kernel/misc_64.S   |    2 +-
 arch/powerpc/kernel/process.c   |   14 ++++++++++++++
 arch/powerpc/kernel/ptrace.c    |    8 ++++++++
 arch/powerpc/kernel/sys_ppc32.c |    4 +++-
 arch/powerpc/kernel/time.c      |    3 +++
 arch/powerpc/kernel/traps.c     |   14 ++++++++++++++
 arch/powerpc/mm/fault.c         |    6 ++++++
 8 files changed, 50 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/kernel/misc_32.S b/arch/powerpc/kernel/misc_32.S
index 7cd07b4..c2f853d 100644
--- a/arch/powerpc/kernel/misc_32.S
+++ b/arch/powerpc/kernel/misc_32.S
@@ -667,7 +667,7 @@ _GLOBAL(abs)
  * Create a kernel thread
  *   kernel_thread(fn, arg, flags)
  */
-_GLOBAL(kernel_thread)
+_GLOBAL(original_kernel_thread)
 	stwu	r1,-16(r1)
 	stw	r30,8(r1)
 	stw	r31,12(r1)
diff --git a/arch/powerpc/kernel/misc_64.S b/arch/powerpc/kernel/misc_64.S
index 616921e..b3d376b 100644
--- a/arch/powerpc/kernel/misc_64.S
+++ b/arch/powerpc/kernel/misc_64.S
@@ -415,7 +415,7 @@ _GLOBAL(scom970_write)
  * Create a kernel thread
  *   kernel_thread(fn, arg, flags)
  */
-_GLOBAL(kernel_thread)
+_GLOBAL(original_kernel_thread)
 	std	r29,-24(r1)
 	std	r30,-16(r1)
 	stdu	r1,-STACK_FRAME_OVERHEAD(r1)
diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c
index 4937c96..7e16b78 100644
--- a/arch/powerpc/kernel/process.c
+++ b/arch/powerpc/kernel/process.c
@@ -38,6 +38,7 @@
 #include <linux/personality.h>
 #include <linux/random.h>
 #include <linux/hw_breakpoint.h>
+#include <trace/sched.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -57,6 +58,8 @@
 #include <linux/kprobes.h>
 #include <linux/kdebug.h>
 
+DEFINE_TRACE(sched_kthread_create);
+
 extern unsigned long _get_SP(void);
 
 #ifndef CONFIG_SMP
@@ -689,6 +692,17 @@ void show_regs(struct pt_regs * regs)
 		show_instructions(regs);
 }
 
+long original_kernel_thread(int (*fn) (void *), void *arg, unsigned long flags);
+
+long kernel_thread(int (fn) (void *), void *arg, unsigned long flags)
+{
+	long retval;
+
+	retval = original_kernel_thread(fn, arg, flags);
+	trace_sched_kthread_create(fn, retval);
+	return retval;
+}
+
 void exit_thread(void)
 {
 	discard_lazy_cpu_state();
diff --git a/arch/powerpc/kernel/ptrace.c b/arch/powerpc/kernel/ptrace.c
index 8d8e028..cebef62 100644
--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@ -32,6 +32,7 @@
 #include <trace/syscall.h>
 #include <linux/hw_breakpoint.h>
 #include <linux/perf_event.h>
+#include <trace/syscall.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -41,6 +42,9 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/syscalls.h>
 
+DEFINE_TRACE(syscall_entry);
+DEFINE_TRACE(syscall_exit);
+
 /*
  * The parameter save area on the stack is used to store arguments being passed
  * to callee function and is located at fixed offset from stack pointer.
@@ -1710,6 +1714,8 @@ long do_syscall_trace_enter(struct pt_regs *regs)
 {
 	long ret = 0;
 
+	trace_syscall_entry(regs, regs->gpr[0]);
+
 	secure_computing(regs->gpr[0]);
 
 	if (test_thread_flag(TIF_SYSCALL_TRACE) &&
@@ -1746,6 +1752,8 @@ void do_syscall_trace_leave(struct pt_regs *regs)
 {
 	int step;
 
+	trace_syscall_exit(regs->result);
+
 	audit_syscall_exit(regs);
 
 	if (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))
diff --git a/arch/powerpc/kernel/sys_ppc32.c b/arch/powerpc/kernel/sys_ppc32.c
index 81c5706..ba3b3f8 100644
--- a/arch/powerpc/kernel/sys_ppc32.c
+++ b/arch/powerpc/kernel/sys_ppc32.c
@@ -41,6 +41,7 @@
 #include <linux/elf.h>
 #include <linux/ipc.h>
 #include <linux/slab.h>
+#include <trace/ipc.h>
 
 #include <asm/ptrace.h>
 #include <asm/types.h>
@@ -52,7 +53,6 @@
 #include <asm/syscalls.h>
 #include <asm/switch_to.h>
 
-
 asmlinkage long ppc32_select(u32 n, compat_ulong_t __user *inp,
 		compat_ulong_t __user *outp, compat_ulong_t __user *exp,
 		compat_uptr_t tvp_x)
@@ -80,6 +80,8 @@ long compat_sys_ipc(u32 call, u32 first, u32 second, u32 third, compat_uptr_t pt
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
+	trace_ipc_call(call, first);
+
 	switch (call) {
 
 	case SEMTIMEDOP:
diff --git a/arch/powerpc/kernel/time.c b/arch/powerpc/kernel/time.c
index 730e69c..5f91659 100644
--- a/arch/powerpc/kernel/time.c
+++ b/arch/powerpc/kernel/time.c
@@ -496,6 +496,8 @@ void timer_interrupt(struct pt_regs * regs)
 
 	__get_cpu_var(irq_stat).timer_irqs++;
 
+	trace_trap_entry(regs, regs->trap);
+
 #if defined(CONFIG_PPC32) && defined(CONFIG_PMAC)
 	if (atomic_read(&ppc_n_lost_interrupts) != 0)
 		do_IRQ(regs);
@@ -532,6 +534,7 @@ void timer_interrupt(struct pt_regs * regs)
 	set_irq_regs(old_regs);
 
 	trace_timer_interrupt_exit(regs);
+	trace_trap_exit();
 }
 
 #ifdef CONFIG_SUSPEND
diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index 83b0cac..f621587 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -36,6 +36,7 @@
 #include <linux/debugfs.h>
 #include <linux/ratelimit.h>
 #include <linux/ltt-core.h>
+#include <trace/trap.h>
 
 #include <asm/emulated_ops.h>
 #include <asm/pgtable.h>
@@ -80,6 +81,12 @@ EXPORT_SYMBOL(__debugger_fault_handler);
 #endif
 
 /*
+ * Also used in time.c and fault.c.
+ */
+DEFINE_TRACE(trap_entry);
+DEFINE_TRACE(trap_exit);
+
+/*
  * Trap & Exception support
  */
 
@@ -256,11 +263,14 @@ void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)
 	if (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))
 		local_irq_enable();
 
+	trace_trap_entry(regs, regs->trap);
+
 	memset(&info, 0, sizeof(info));
 	info.si_signo = signr;
 	info.si_code = code;
 	info.si_addr = (void __user *) addr;
 	force_sig_info(signr, &info, current);
+	trace_trap_exit();
 }
 
 #ifdef CONFIG_PPC64
@@ -1167,7 +1177,9 @@ void performance_monitor_exception(struct pt_regs *regs)
 {
 	__get_cpu_var(irq_stat).pmu_irqs++;
 
+	trace_trap_entry(regs, regs->trap);
 	perf_irq(regs);
+	trace_trap_exit();
 }
 
 #ifdef CONFIG_8xx
@@ -1386,11 +1398,13 @@ void altivec_assist_exception(struct pt_regs *regs)
 		/* got an error reading the instruction */
 		_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);
 	} else {
+		trace_trap_entry(regs, regs->trap);
 		/* didn't recognize the instruction */
 		/* XXX quick hack for now: set the non-Java bit in the VSCR */
 		printk_ratelimited(KERN_ERR "Unrecognized altivec instruction "
 				   "in %s at %lx\n", current->comm, regs->nip);
 		current->thread.vscr.u[3] |= 0x10000;
+		trace_trap_exit();
 	}
 }
 #endif /* CONFIG_ALTIVEC */
diff --git a/arch/powerpc/mm/fault.c b/arch/powerpc/mm/fault.c
index 08ffcf5..2c1256e 100644
--- a/arch/powerpc/mm/fault.c
+++ b/arch/powerpc/mm/fault.c
@@ -32,6 +32,7 @@
 #include <linux/perf_event.h>
 #include <linux/magic.h>
 #include <linux/ratelimit.h>
+#include <trace/fault.h>
 
 #include <asm/firmware.h>
 #include <asm/page.h>
@@ -46,6 +47,9 @@
 
 #include "icswx.h"
 
+DEFINE_TRACE(page_fault_entry);
+DEFINE_TRACE(page_fault_exit);
+
 #ifdef CONFIG_KPROBES
 static inline int notify_page_fault(struct pt_regs *regs)
 {
@@ -417,7 +421,9 @@ good_area:
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
+	trace_page_fault_entry(regs, regs->trap, mm, vma, address, is_write);
 	fault = handle_mm_fault(mm, vma, address, flags);
+	trace_page_fault_exit(ret);
 	if (unlikely(fault & (VM_FAULT_RETRY|VM_FAULT_ERROR))) {
 		int rc = mm_fault_error(regs, address, fault);
 		if (rc >= MM_FAULT_RETURN)
-- 
1.7.9.7

