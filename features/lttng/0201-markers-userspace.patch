From a7e19bedc8a4bb1859e0edbd13cb0971fdff0c8b Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 30 Oct 2008 23:27:35 -0400
Subject: [PATCH] markers-userspace

This patch has been updated to apply cleanly over a 2.6.26-rc9 kernel.

Signed-off-by: Benjamin Poirier <benjamin.poirier@polymtl.ca>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 fs/compat.c                 |    1 +
 fs/exec.c                   |    2 +
 fs/proc/base.c              |  133 +++++++++++++++++++++++
 include/linux/init_task.h   |   11 ++
 include/linux/marker.h      |   12 ++
 include/linux/sched.h       |   10 ++
 include/linux/syscalls.h    |    4 +
 include/linux/user_marker.h |   17 +++
 init/Kconfig                |   13 +++
 kernel/exit.c               |    2 +
 kernel/fork.c               |   51 +++++++++
 kernel/marker.c             |  251 ++++++++++++++++++++++++++++++++++++++++++-
 kernel/sys_ni.c             |    3 +
 13 files changed, 509 insertions(+), 1 deletions(-)
 create mode 100644 include/linux/user_marker.h

diff --git a/fs/compat.c b/fs/compat.c
index a6b9ee8..b464fb9 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -1405,6 +1405,7 @@ int compat_do_execve(char * filename,
 	if (retval < 0)
 		goto out;
 
+	exit_user_markers(current);
 	retval = search_binary_handler(bprm, regs);
 	if (retval >= 0) {
 		trace_fs_exec(filename);
diff --git a/fs/exec.c b/fs/exec.c
index f2a8756..75b53fe 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1225,6 +1225,7 @@ int search_binary_handler(struct linux_binprm *bprm,struct pt_regs *regs)
 			if (!try_module_get(fmt->module))
 				continue;
 			read_unlock(&binfmt_lock);
+			/* Le changement d'image se fait par cet appel */
 			retval = fn(bprm, regs);
 			/*
 			 * Restore the depth counter to its starting value
@@ -1346,6 +1347,7 @@ int do_execve(char * filename,
 		goto out;
 
 	current->flags &= ~PF_KTHREAD;
+	exit_user_markers(current);
 	retval = search_binary_handler(bprm,regs);
 	if (retval >= 0) {
 		trace_fs_exec(filename);
diff --git a/fs/proc/base.c b/fs/proc/base.c
index b89e06c..2e26906 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -79,6 +79,8 @@
 #include <linux/oom.h>
 #include <linux/elf.h>
 #include <linux/pid_namespace.h>
+#include <linux/user_marker.h>
+#include <linux/marker.h>
 #include "internal.h"
 
 /* NOTE:
@@ -1056,6 +1058,134 @@ static const struct file_operations proc_oom_adjust_operations = {
 	.write		= oom_adjust_write,
 };
 
+#ifdef CONFIG_MARKERS_USERSPACE
+struct markers_seq_data {
+	struct task_struct *task;
+	unsigned long version;
+};
+
+static void *markers_start(struct seq_file *m, loff_t *pos)
+{
+	struct hlist_node *retval, *n;
+	loff_t local_pos = *pos;
+	struct markers_seq_data *data = m->private;
+
+	mutex_lock(&data->task->user_markers_mutex);
+	retval = NULL;
+	if (data->task->user_markers_sequence != data->version) {
+		retval = ERR_PTR(-EAGAIN);
+		goto out;
+	}
+
+	hlist_for_each(n, &data->task->user_markers) {
+		if (local_pos-- == 0) {
+			retval = n;
+			goto out;
+		}
+	}
+
+out:
+	mutex_unlock(&data->task->user_markers_mutex);
+	return retval;
+}
+
+static void *markers_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	struct hlist_node *retval, *n = v;
+	struct markers_seq_data *data = m->private;
+
+	retval = NULL;
+	mutex_lock(&data->task->user_markers_mutex);
+	if (data->task->user_markers_sequence != data->version) {
+		retval = ERR_PTR(-EAGAIN);
+		goto out;
+	} else
+		data->version = data->task->user_markers_sequence;
+
+	if (n->next) {
+		++*pos;
+		retval = n->next;
+	}
+
+out:
+	mutex_unlock(&data->task->user_markers_mutex);
+	return NULL;
+}
+
+static void markers_stop(struct seq_file *m, void *v)
+{
+}
+
+static int markers_show(struct seq_file *m, void *v)
+{
+	struct markers_seq_data *data = m->private;
+	struct user_marker *umark;
+	int retval;
+
+	retval = 0;
+	mutex_lock(&data->task->user_markers_mutex);
+	if (data->task->user_markers_sequence != data->version) {
+		retval = -EAGAIN;
+		mutex_unlock(&data->task->user_markers_mutex);
+		goto out;
+	}
+
+	umark = hlist_entry((struct hlist_node *)v, struct user_marker, hlist);
+	seq_printf(m, "marker: %s format: \"%s\" address: %p",
+		umark->name, umark->format, umark->state);
+	mutex_unlock(&data->task->user_markers_mutex);
+	seq_printf(m, " enabled: %d\n", is_marker_enabled(umark->name));
+out:
+	return retval;
+}
+
+static const struct seq_operations markers_seq_op = {
+	.start = markers_start,
+	.next = markers_next,
+	.stop = markers_stop,
+	.show = markers_show,
+};
+
+static int markers_open(struct inode *inode, struct file *file)
+{
+	int retval;
+	struct markers_seq_data *data;
+	struct seq_file *seq;
+
+	data = kmalloc(sizeof(struct markers_seq_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	retval = seq_open(file, &markers_seq_op);
+	if (!retval) {
+		data->task = get_proc_task(file->f_dentry->d_inode);
+		data->version = data->task->user_markers_sequence;
+
+		seq = file->private_data;
+		seq->private = data;
+	} else
+		kfree(data);
+
+	return retval;
+}
+
+static int markers_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+
+	kfree(seq->private);
+
+	return seq_release(inode, file);
+}
+
+static const struct file_operations proc_markers_operations = {
+	.open		= markers_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= markers_release,
+};
+#endif /* CONFIG_MARKERS_USERSPACE */
+
 #ifdef CONFIG_AUDITSYSCALL
 #define TMPBUFLEN 21
 static ssize_t proc_loginuid_read(struct file * file, char __user * buf,
@@ -2533,6 +2663,9 @@ static const struct pid_entry tgid_base_stuff[] = {
 #ifdef CONFIG_INTERPEAK
 	INF("vr",         S_IRUSR, vr),
 #endif
+#ifdef CONFIG_MARKERS_USERSPACE
+	REG("markers", S_IRUSR, markers),
+#endif
 };
 
 static int proc_tgid_base_readdir(struct file * filp,
diff --git a/include/linux/init_task.h b/include/linux/init_task.h
index 021d8e7..bc4f907 100644
--- a/include/linux/init_task.h
+++ b/include/linux/init_task.h
@@ -113,6 +113,16 @@ extern struct group_info init_groups;
 # define CAP_INIT_BSET  CAP_INIT_EFF_SET
 #endif
 
+#ifdef CONFIG_MARKERS_USERSPACE
+#define INIT_MARKERS_USERSPACE(tsk)					\
+	.user_markers_mutex =						\
+		__MUTEX_INITIALIZER(tsk.user_markers_mutex),		\
+	.user_markers = HLIST_HEAD_INIT,				\
+	.user_markers_sequence = 0,
+#else
+#define INIT_MARKERS_USERSPACE(tsk)
+#endif
+
 /*
  *  INIT_TASK is used to set up the first task table, touch at
  * your own risk!. Base=0, limit=0x1fffff (=2MB)
@@ -176,6 +186,7 @@ extern struct group_info init_groups;
 		[PIDTYPE_SID]  = INIT_PID_LINK(PIDTYPE_SID),		\
 	},								\
 	.dirties = INIT_PROP_LOCAL_SINGLE(dirties),			\
+	INIT_MARKERS_USERSPACE(tsk)					\
 	INIT_IDS							\
 	INIT_TRACE_IRQFLAGS						\
 	INIT_LOCKDEP							\
diff --git a/include/linux/marker.h b/include/linux/marker.h
index cff031b..190e34b 100644
--- a/include/linux/marker.h
+++ b/include/linux/marker.h
@@ -16,6 +16,7 @@
 #include <linux/types.h>
 
 struct module;
+struct task_struct;
 struct marker;
 
 /**
@@ -233,4 +234,15 @@ extern void marker_iter_reset(struct marker_iter *iter);
 extern int marker_get_iter_range(struct marker **marker, struct marker *begin,
 	struct marker *end);
 
+extern void marker_update_process(void);
+extern int is_marker_enabled(const char *name);
+
+#ifdef CONFIG_MARKERS_USERSPACE
+extern void exit_user_markers(struct task_struct *p);
+#else
+static inline void exit_user_markers(struct task_struct *p)
+{
+}
+#endif
+
 #endif
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 89816dd..a761d66 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1026,6 +1026,16 @@ struct sched_rt_entity {
 	/* rq "owned" by this entity/group: */
 	struct rt_rq		*my_q;
 #endif
+#ifdef CONFIG_MARKERS_USERSPACE
+	/*
+	 * user_markers and user_markers_sequence updates are protected
+	 * by the per process user_markers_mutex nested in the markers_mutex.
+	 * Taking one of these mutexes is enough to insure coherent read.
+	 */
+	struct mutex user_markers_mutex;
+	struct hlist_head user_markers;
+	unsigned long user_markers_sequence;
+#endif
 };
 
 struct task_struct {
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index f54aa38..a4ca3b0 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -678,6 +678,7 @@ asmlinkage long sys_timerfd_gettime(int ufd, struct itimerspec __user *otmr);
 asmlinkage long sys_eventfd(unsigned int count);
 asmlinkage long sys_eventfd2(unsigned int count, int flags);
 asmlinkage long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);
+
 asmlinkage long sys_old_readdir(unsigned int, struct old_linux_dirent __user *, unsigned int);
 asmlinkage long sys_pselect6(int, fd_set __user *, fd_set __user *,
 			     fd_set __user *, struct timespec __user *,
@@ -687,6 +688,9 @@ asmlinkage long sys_ppoll(struct pollfd __user *, unsigned int,
 			  size_t);
 asmlinkage long sys_pipe2(int __user *, int);
 asmlinkage long sys_pipe(int __user *);
+asmlinkage long sys_marker(char __user *name, char __user *format,
+			   char __user *state, int reg);
+asmlinkage long sys_trace(int type, uint16_t id, char __user *ubuf);
 
 int kernel_execve(const char *filename, char *const argv[], char *const envp[]);
 
diff --git a/include/linux/user_marker.h b/include/linux/user_marker.h
new file mode 100644
index 0000000..050f49f
--- /dev/null
+++ b/include/linux/user_marker.h
@@ -0,0 +1,17 @@
+#ifndef _LINUX_USER_MARKER_H
+#define _LINUX_USER_MARKER_H
+
+#include <linux/list.h>
+
+
+#define MAX_USER_MARKER_NAME_LEN	128
+#define MAX_USER_MARKER_FORMAT_LEN	128
+
+struct user_marker {
+	struct hlist_node hlist;
+	char __user *state;
+	char name[MAX_USER_MARKER_NAME_LEN];
+	char format[MAX_USER_MARKER_FORMAT_LEN];
+};
+
+#endif
diff --git a/init/Kconfig b/init/Kconfig
index edba392..182303f 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -873,6 +873,19 @@ config MARKERS
 
 source "arch/Kconfig"
 
+config MARKERS_USERSPACE
+	bool "Activate userspace markers ABI"
+	depends on MARKERS
+	depends on HAVE_MARKERS_ABI
+	help
+	  Allow userspace to register markers through sys_marker. Allows
+	  system-wide userspace library tracing, early boot (init) tracing. List
+	  of markers available through /proc/PID/markers. Activation through
+	  /proc/ltt.
+
+config HAVE_MARKERS_ABI
+	def_bool n
+
 source "ltt/Kconfig"
 
 config PROC_PAGE_MONITOR
diff --git a/kernel/exit.c b/kernel/exit.c
index f0b032d..c17d0b4 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -1132,6 +1132,8 @@ NORET_TYPE void do_exit(long code)
 	if (tsk->splice_pipe)
 		__free_pipe_info(tsk->splice_pipe);
 
+	exit_user_markers(tsk);
+
 	preempt_disable();
 	/* causes final put_task_struct in finish_task_switch(). */
 	tsk->state = TASK_DEAD;
diff --git a/kernel/fork.c b/kernel/fork.c
index 0249a98..c039204 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -59,6 +59,7 @@
 #include <linux/proc_fs.h>
 #include <linux/blkdev.h>
 #include <linux/memrlimitcgroup.h>
+#include <linux/user_marker.h>
 #include <trace/sched.h>
 
 #include <asm/pgtable.h>
@@ -1187,6 +1188,46 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 	cgroup_fork_callbacks(p);
 	cgroup_callbacks_done = 1;
 
+#ifdef CONFIG_MARKERS_USERSPACE
+	mutex_init(&p->user_markers_mutex);
+	if (strcmp(p->comm, "testprog") == 0)
+		printk(KERN_DEBUG "initializing process and hlist\n");
+	INIT_HLIST_HEAD(&p->user_markers);
+	p->user_markers_sequence = 0;
+
+	if (!(clone_flags & CLONE_THREAD)) {
+		struct user_marker *cur_umark, *new_umark;
+		struct hlist_node *pos;
+
+		mutex_lock(&current->group_leader->user_markers_mutex);
+		/* Markers list is kept in thread group leaders, only
+		 * copy it if this new process is one */
+		if (strcmp(p->comm, "testprog") == 0)
+			printk(KERN_DEBUG "copying hlist\n");
+		hlist_for_each_entry(cur_umark, pos,
+			&current->group_leader->user_markers, hlist) {
+			new_umark = kmalloc(sizeof(struct user_marker),
+				GFP_KERNEL);
+			if (!new_umark) {
+				retval = -ENOMEM;
+				/*
+				 * We can fail without removing our
+				 * entry from the thread group list
+				 * because we are the thread group
+				 * leader.
+				 */
+				mutex_unlock(
+				&current->group_leader->user_markers_mutex);
+				goto bad_fork_no_mem;
+			}
+			memcpy(new_umark, cur_umark,
+				sizeof(struct user_marker));
+			hlist_add_head(&new_umark->hlist, &p->user_markers);
+		}
+		mutex_unlock(&current->group_leader->user_markers_mutex);
+	}
+#endif
+
 	/* Need tasklist lock for parent etc handling! */
 	write_lock_irq(&tasklist_lock);
 
@@ -1214,6 +1255,13 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 	else
 		clear_tsk_thread_flag(p, TIF_KERNEL_TRACE);
 
+#ifdef CONFIG_MARKERS_USERSPACE
+	if (test_thread_flag(TIF_MARKER_PENDING))
+		set_tsk_thread_flag(p, TIF_MARKER_PENDING);
+	else
+		clear_tsk_thread_flag(p, TIF_MARKER_PENDING);
+#endif
+
 	/* CLONE_PARENT re-uses the old parent */
 	if (clone_flags & (CLONE_PARENT|CLONE_THREAD))
 		p->real_parent = current->real_parent;
@@ -1289,6 +1337,9 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 bad_fork_free_pid:
 	if (pid != &init_struct_pid)
 		free_pid(pid);
+#ifdef CONFIG_MARKERS_USERSPACE
+bad_fork_no_mem:
+#endif
 bad_fork_cleanup_io:
 	put_io_context(p->io_context);
 bad_fork_cleanup_namespaces:
diff --git a/kernel/marker.c b/kernel/marker.c
index 799c475..a9d1865 100644
--- a/kernel/marker.c
+++ b/kernel/marker.c
@@ -25,6 +25,9 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/immediate.h>
+#include <linux/sched.h>
+#include <linux/uaccess.h>
+#include <linux/user_marker.h>
 
 #define MARKER_NOTIFY_PRIO 1
 
@@ -72,6 +75,14 @@ struct marker_entry {
 	char name[0];	/* Contains name'\0'format'\0' */
 };
 
+#ifdef CONFIG_MARKERS_USERSPACE
+static void marker_update_processes(void);
+#else
+static void marker_update_processes(void)
+{
+}
+#endif
+
 /**
  * __mark_empty_function - Empty probe callback
  * @probe_private: probe private data
@@ -545,7 +556,7 @@ static int set_marker(struct marker_entry *entry, struct marker *elem,
 		if (active) {
 			/*
 			 * try_module_get should always succeed because we hold
-			 * lock_module() to get the tp_cb address.
+			 * markers_mutex to get the tp_cb address.
 			 */
 			ret = try_module_get(__module_text_address(
 				(unsigned long)elem->tp_cb));
@@ -663,6 +674,7 @@ static void marker_update_probes(void)
 	/* Update immediate values */
 	core_imv_update();
 	module_imv_update();
+	marker_update_processes();
 }
 
 /**
@@ -972,6 +984,243 @@ void marker_iter_reset(struct marker_iter *iter)
 }
 EXPORT_SYMBOL_GPL(marker_iter_reset);
 
+#ifdef CONFIG_MARKERS_USERSPACE
+/*
+ * must be called with current->user_markers_mutex held
+ */
+static void free_user_marker(char __user *state, struct hlist_head *head)
+{
+	struct user_marker *umark;
+	struct hlist_node *pos, *n;
+
+	hlist_for_each_entry_safe(umark, pos, n, head, hlist) {
+		if (umark->state == state) {
+			hlist_del(&umark->hlist);
+			kfree(umark);
+		}
+	}
+}
+
+asmlinkage long sys_marker(char __user *name, char __user *format,
+		char __user *state, int reg)
+{
+	struct user_marker *umark;
+	long len;
+	struct marker_entry *entry;
+	int ret = 0;
+
+	printk(KERN_DEBUG "Program %s %s marker [%p, %p]\n",
+		current->comm, reg ? "registers" : "unregisters",
+		name, state);
+	if (reg) {
+		umark = kmalloc(sizeof(struct user_marker), GFP_KERNEL);
+		umark->name[MAX_USER_MARKER_NAME_LEN - 1] = '\0';
+		umark->format[MAX_USER_MARKER_FORMAT_LEN - 1] = '\0';
+		umark->state = state;
+		len = strncpy_from_user(umark->name, name,
+			MAX_USER_MARKER_NAME_LEN - 1);
+		if (len < 0) {
+			ret = -EFAULT;
+			goto error;
+		}
+		len = strncpy_from_user(umark->format, format,
+			MAX_USER_MARKER_FORMAT_LEN - 1);
+		if (len < 0) {
+			ret = -EFAULT;
+			goto error;
+		}
+		printk(KERN_DEBUG "Marker name : %s, format : %s", umark->name,
+			umark->format);
+		mutex_lock(&markers_mutex);
+		entry = get_marker(umark->name);
+		if (entry) {
+			if (entry->format &&
+				strcmp(entry->format, umark->format) != 0) {
+				printk(" error, wrong format in process %s",
+					current->comm);
+				ret = -EPERM;
+				goto error_unlock;
+			}
+			printk(" %s", !!entry->refcount
+					? "enabled" : "disabled");
+			if (put_user(!!entry->refcount, state)) {
+				ret = -EFAULT;
+				goto error_unlock;
+			}
+			printk("\n");
+		} else {
+			printk(" disabled\n");
+			if (put_user(0, umark->state)) {
+				printk(KERN_WARNING
+					"Marker in %s caused a fault\n",
+					current->comm);
+				goto error_unlock;
+			}
+		}
+		mutex_lock(&current->group_leader->user_markers_mutex);
+		hlist_add_head(&umark->hlist,
+			&current->group_leader->user_markers);
+		current->group_leader->user_markers_sequence++;
+		mutex_unlock(&current->group_leader->user_markers_mutex);
+		mutex_unlock(&markers_mutex);
+	} else {
+		mutex_lock(&current->group_leader->user_markers_mutex);
+		free_user_marker(state,
+			&current->group_leader->user_markers);
+		current->group_leader->user_markers_sequence++;
+		mutex_unlock(&current->group_leader->user_markers_mutex);
+	}
+	goto end;
+error_unlock:
+	mutex_unlock(&markers_mutex);
+error:
+	kfree(umark);
+end:
+	return ret;
+}
+
+/*
+ * Types :
+ * string : 0
+ */
+asmlinkage long sys_trace(int type, uint16_t id,
+		char __user *ubuf)
+{
+	long ret = -EPERM;
+	char *page;
+	int len;
+
+	switch (type) {
+	case 0:	/* String */
+		ret = -ENOMEM;
+		page = (char *)__get_free_page(GFP_TEMPORARY);
+		if (!page)
+			goto string_out;
+		len = strncpy_from_user(page, ubuf, PAGE_SIZE);
+		if (len < 0) {
+			ret = -EFAULT;
+			goto string_err;
+		}
+		trace_mark(userspace_string, "string %s", page);
+string_err:
+		free_page((unsigned long) page);
+string_out:
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+static void marker_update_processes(void)
+{
+	struct task_struct *g, *t;
+
+	/*
+	 * markers_mutex is taken to protect the p->user_markers read.
+	 */
+	mutex_lock(&markers_mutex);
+	read_lock(&tasklist_lock);
+	for_each_process(g) {
+		WARN_ON(!thread_group_leader(g));
+		if (hlist_empty(&g->user_markers))
+			continue;
+		if (strcmp(g->comm, "testprog") == 0)
+			printk(KERN_DEBUG "set update pending for testprog\n");
+		t = g;
+		do {
+			/* TODO : implement this thread flag in each arch. */
+			set_tsk_thread_flag(t, TIF_MARKER_PENDING);
+		} while ((t = next_thread(t)) != g);
+	}
+	read_unlock(&tasklist_lock);
+	mutex_unlock(&markers_mutex);
+}
+
+/*
+ * Update current process.
+ * Note that we have to wait a whole scheduler period before we are sure that
+ * every running userspace threads have their markers updated.
+ * (synchronize_sched() can be used to insure this).
+ */
+void marker_update_process(void)
+{
+	struct user_marker *umark;
+	struct hlist_node *pos;
+	struct marker_entry *entry;
+
+	mutex_lock(&markers_mutex);
+	mutex_lock(&current->group_leader->user_markers_mutex);
+	if (strcmp(current->comm, "testprog") == 0)
+		printk(KERN_DEBUG "do update pending for testprog\n");
+	hlist_for_each_entry(umark, pos,
+			&current->group_leader->user_markers, hlist) {
+		printk(KERN_DEBUG "Updating marker %s in %s\n",
+			umark->name, current->comm);
+		entry = get_marker(umark->name);
+		if (entry) {
+			if (entry->format &&
+				strcmp(entry->format, umark->format) != 0) {
+				printk(KERN_WARNING
+					" error, wrong format in process %s\n",
+					current->comm);
+				break;
+			}
+			if (put_user(!!entry->refcount, umark->state)) {
+				printk(KERN_WARNING
+					"Marker in %s caused a fault\n",
+					current->comm);
+				break;
+			}
+		} else {
+			if (put_user(0, umark->state)) {
+				printk(KERN_WARNING
+					"Marker in %s caused a fault\n",
+					current->comm);
+				break;
+			}
+		}
+	}
+	clear_thread_flag(TIF_MARKER_PENDING);
+	mutex_unlock(&current->group_leader->user_markers_mutex);
+	mutex_unlock(&markers_mutex);
+}
+
+/*
+ * Called at process exit and upon do_execve().
+ * We assume that when the leader exits, no more references can be done to the
+ * leader structure by the other threads.
+ */
+void exit_user_markers(struct task_struct *p)
+{
+	struct user_marker *umark;
+	struct hlist_node *pos, *n;
+
+	if (thread_group_leader(p)) {
+		mutex_lock(&markers_mutex);
+		mutex_lock(&p->user_markers_mutex);
+		hlist_for_each_entry_safe(umark, pos, n, &p->user_markers,
+			hlist)
+		    kfree(umark);
+		INIT_HLIST_HEAD(&p->user_markers);
+		p->user_markers_sequence++;
+		mutex_unlock(&p->user_markers_mutex);
+		mutex_unlock(&markers_mutex);
+	}
+}
+
+int is_marker_enabled(const char *name)
+{
+	struct marker_entry *entry;
+
+	mutex_lock(&markers_mutex);
+	entry = get_marker(name);
+	mutex_unlock(&markers_mutex);
+
+	return entry && !!entry->refcount;
+}
+#endif
+
 int marker_module_notify(struct notifier_block *self,
 			 unsigned long val, void *data)
 {
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index d7b7b45..2fba5eb 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -169,3 +169,6 @@ cond_syscall(compat_sys_timerfd_settime);
 cond_syscall(compat_sys_timerfd_gettime);
 cond_syscall(sys_eventfd);
 cond_syscall(sys_eventfd2);
+
+cond_syscall(sys_marker);
+cond_syscall(sys_trace);
-- 
1.6.0.3

