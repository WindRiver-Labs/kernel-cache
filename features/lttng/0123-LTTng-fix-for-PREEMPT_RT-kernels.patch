From 205a52ad4f23f60dc585894b678d4b3fd42cebe3 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Tue, 12 Aug 2008 10:32:59 -0400
Subject: [PATCH] LTTng-fix-for-PREEMPT_RT-kernels

LTTng fix for PREEMPT_RT kernels

Fix BUG in RT preempt kernel caused by spinlocks taken within preempt disable
region.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/ltt-tracer.c |   16 ++++++++++++++++
 1 files changed, 16 insertions(+), 0 deletions(-)

diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index 5263973..e91778f 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -243,11 +243,27 @@ static void trace_async_wakeup(struct ltt_trace_struct *trace)
 static void async_wakeup(unsigned long data)
 {
 	struct ltt_trace_struct *trace;
+
+	/*
+	 * PREEMPT_RT does not allow spinlocks to be taken within preempt
+	 * disable sections (spinlock taken in wake_up). However, mainline won't
+	 * allow mutex to be taken in interrupt context. Ugly.
+	 * A proper way to do this would be to turn the timer into a
+	 * periodically woken up thread, but it adds to the footprint.
+	 */
+#ifndef CONFIG_PREEMPT_RT
 	rcu_read_lock_sched();
+#else
+	ltt_lock_traces();
+#endif
 	list_for_each_entry_rcu(trace, &ltt_traces.head, list) {
 		trace_async_wakeup(trace);
 	}
+#ifndef CONFIG_PREEMPT_RT
 	rcu_read_unlock_sched();
+#else
+	ltt_unlock_traces();
+#endif
 
 	del_timer(&ltt_async_wakeup_timer);
 	ltt_async_wakeup_timer.expires = jiffies + LTT_PERCPU_TIMER_INTERVAL;
-- 
1.5.5.1

