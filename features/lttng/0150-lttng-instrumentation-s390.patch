From 14b5457ee22e70856e6c6b120f642bdce1083dad Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 2 Oct 2008 01:44:16 -0400
Subject: [PATCH] lttng-instrumentation-s390

LTTng - s390 instrumentation

Changelog :
- added syscall entry/exit instrumentation.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/s390/kernel/entry.S    |   10 ++++++++--
 arch/s390/kernel/entry64.S  |   10 ++++++++--
 arch/s390/kernel/ptrace.c   |    6 ++++++
 arch/s390/kernel/sys_s390.c |    2 ++
 arch/s390/kernel/traps.c    |   17 +++++++++++++++++
 arch/s390/mm/fault.c        |    6 ++++++
 6 files changed, 47 insertions(+), 4 deletions(-)

diff --git a/arch/s390/kernel/entry.S b/arch/s390/kernel/entry.S
index 708cf9c..0bcb339 100644
--- a/arch/s390/kernel/entry.S
+++ b/arch/s390/kernel/entry.S
@@ -271,8 +271,10 @@ sysc_do_svc:
 sysc_nr_ok:
 	mvc	SP_ARGS(4,%r15),SP_R7(%r15)
 sysc_do_restart:
+	l	%r8,__TI_flags+3(%r9)
+	n	%r8,BASED(.Lc_tif_syscall_trace_or_audit_or_kernel_trace)
+	ltr	%r8,%r8
 	l	%r8,BASED(.Lsysc_table)
-	tm	__TI_flags+3(%r9),(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT)
 	l	%r8,0(%r7,%r8)	  # get system call addr.
 	bnz	BASED(sysc_tracesys)
 	basr	%r14,%r8	  # call sys_xxxx
@@ -399,7 +401,9 @@ sysc_tracego:
 	basr	%r14,%r8		# call sys_xxx
 	st	%r2,SP_R2(%r15)		# store return value
 sysc_tracenogo:
-	tm	__TI_flags+3(%r9),(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT)
+	l	%r8,__TI_flags+3(%r9)
+	n	%r8,BASED(.Lc_tif_syscall_trace_or_audit_or_kernel_trace)
+	ltr	%r8,%r8
 	bz	BASED(sysc_return)
 	l	%r1,BASED(.Ltrace)
 	la	%r2,SP_PTREGS(%r15)	# load pt_regs
@@ -1059,6 +1063,8 @@ cleanup_io_leave_insn:
 .L0x030:	.short	0x030
 .L0x038:	.short	0x038
 .Lc_1:		.long	1
+.Lc_tif_syscall_trace_or_audit_or_kernel_trace:
+		.long	_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT|_TIF_KERNEL_TRACE
 
 /*
  * Symbol constants
diff --git a/arch/s390/kernel/entry64.S b/arch/s390/kernel/entry64.S
index fee1017..0a3fa15 100644
--- a/arch/s390/kernel/entry64.S
+++ b/arch/s390/kernel/entry64.S
@@ -264,7 +264,9 @@ sysc_do_restart:
 	larl	%r10,sys_call_table_emu  # use 31 bit emulation system calls
 sysc_noemu:
 #endif
-	tm	__TI_flags+7(%r9),(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT)
+	l	%r8,__TI_flags+7(%r9)
+	n	%r8,BASED(.Lc_tif_syscall_trace_or_audit_or_kernel_trace)
+	ltr	%r8,%r8
 	lgf	%r8,0(%r7,%r10) # load address of system call routine
 	jnz	sysc_tracesys
 	basr	%r14,%r8	# call sys_xxxx
@@ -388,7 +390,9 @@ sysc_tracego:
 	basr	%r14,%r8		# call sys_xxx
 	stg	%r2,SP_R2(%r15)		# store return value
 sysc_tracenogo:
-	tm	__TI_flags+7(%r9),(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT)
+	l	%r8,__TI_flags+7(%r9)
+	n	%r8,BASED(.Lc_tif_syscall_trace_or_audit_or_kernel_trace)
+	ltr	%r8,%r8
 	jz	sysc_return
 	la	%r2,SP_PTREGS(%r15)	# load pt_regs
 	la	%r3,1
@@ -1049,6 +1053,8 @@ cleanup_io_leave_insn:
 		.align	4
 .Lconst:
 .Lnr_syscalls:	.long	NR_syscalls
+.Lc_tif_syscall_trace_or_audit_or_kernel_trace:
+		.long	_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT|_TIF_KERNEL_TRACE
 .L0x0130:	.short	0x130
 .L0x0140:	.short	0x140
 .L0x0150:	.short	0x150
diff --git a/arch/s390/kernel/ptrace.c b/arch/s390/kernel/ptrace.c
index c8b0828..808b443 100644
--- a/arch/s390/kernel/ptrace.c
+++ b/arch/s390/kernel/ptrace.c
@@ -642,6 +642,12 @@ long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
 asmlinkage void
 syscall_trace(struct pt_regs *regs, int entryexit)
 {
+	if (!entryexit)
+		trace_mark(kernel_arch_syscall_entry, "syscall_id %d ip #p%ld",
+			(int)regs->gprs[2], instruction_pointer(regs));
+	else
+		trace_mark(kernel_arch_syscall_exit, "ret %ld", regs->gprs[2]);
+
 	if (unlikely(current->audit_context) && entryexit)
 		audit_syscall_exit(AUDITSC_RESULT(regs->gprs[2]), regs->gprs[2]);
 
diff --git a/arch/s390/kernel/sys_s390.c b/arch/s390/kernel/sys_s390.c
index 5fdb799..fe8ea0f 100644
--- a/arch/s390/kernel/sys_s390.c
+++ b/arch/s390/kernel/sys_s390.c
@@ -133,6 +133,8 @@ asmlinkage long sys_ipc(uint call, int first, unsigned long second,
         struct ipc_kludge tmp;
 	int ret;
 
+        trace_mark(ipc_call, "call %u first %d", call, first);
+
         switch (call) {
         case SEMOP:
 		return sys_semtimedop(first, (struct sembuf __user *)ptr,
diff --git a/arch/s390/kernel/traps.c b/arch/s390/kernel/traps.c
index 4584d81..0b95dec 100644
--- a/arch/s390/kernel/traps.c
+++ b/arch/s390/kernel/traps.c
@@ -5,6 +5,7 @@
  *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
  *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com),
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/kernel/traps.c"
  *    Copyright (C) 1991, 1992 Linus Torvalds
@@ -347,6 +348,9 @@ static void __kprobes inline do_trap(long interruption_code, int signr,
 				interruption_code, signr) == NOTIFY_STOP)
 		return;
 
+	trace_mark(kernel_arch_trap_entry, "trap_id %ld ip #p%lu",
+		interruption_code & 0xffff, instruction_pointer(regs));
+
         if (regs->psw.mask & PSW_MASK_PSTATE) {
                 struct task_struct *tsk = current;
 
@@ -367,6 +371,7 @@ static void __kprobes inline do_trap(long interruption_code, int signr,
 			die(str, regs, interruption_code);
 		}
         }
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 }
 
 static inline void __user *get_check_address(struct pt_regs *regs)
@@ -477,6 +482,9 @@ static void illegal_op(struct pt_regs * regs, long interruption_code)
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
+	trace_mark(kernel_arch_trap_entry, "trap_id %ld ip #p%lu",
+		interruption_code & 0xffff, instruction_pointer(regs));
+
 	if (regs->psw.mask & PSW_MASK_PSTATE) {
 		if (get_user(*((__u16 *) opcode), (__u16 __user *) location))
 			return;
@@ -541,6 +549,7 @@ static void illegal_op(struct pt_regs * regs, long interruption_code)
 		do_trap(interruption_code, signal,
 			"illegal operation", regs, &info);
 	}
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 }
 
 
@@ -561,6 +570,9 @@ specification_exception(struct pt_regs * regs, long interruption_code)
         if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
+	trace_mark(kernel_arch_trap_entry, "trap_id %ld ip #p%lu",
+		interruption_code & 0xffff, instruction_pointer(regs));
+
         if (regs->psw.mask & PSW_MASK_PSTATE) {
 		get_user(*((__u16 *) opcode), location);
 		switch (opcode[0]) {
@@ -605,6 +617,7 @@ specification_exception(struct pt_regs * regs, long interruption_code)
 		do_trap(interruption_code, signal, 
 			"specification exception", regs, &info);
 	}
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 }
 #else
 DO_ERROR_INFO(SIGILL, "specification exception", specification_exception,
@@ -625,6 +638,9 @@ static void data_exception(struct pt_regs * regs, long interruption_code)
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
+	trace_mark(kernel_arch_trap_entry, "trap_id %ld ip #p%lu",
+		interruption_code & 0xffff, instruction_pointer(regs));
+
 	if (MACHINE_HAS_IEEE)
 		asm volatile("stfpc %0" : "=m" (current->thread.fp_regs.fpc));
 
@@ -699,6 +715,7 @@ static void data_exception(struct pt_regs * regs, long interruption_code)
 		do_trap(interruption_code, signal, 
 			"data exception", regs, &info);
 	}
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 }
 
 static void space_switch_exception(struct pt_regs * regs, long int_code)
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index 4d53720..2cc20bb 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -5,6 +5,7 @@
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Hartmut Penner (hp@de.ibm.com)
  *               Ulrich Weigand (uweigand@de.ibm.com)
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/mm/fault.c"
  *    Copyright (C) 1995  Linus Torvalds
@@ -169,6 +170,7 @@ static void do_no_context(struct pt_regs *regs, unsigned long error_code,
 	fixup = search_exception_tables(regs->psw.addr & __FIXUP_MASK);
 	if (fixup) {
 		regs->psw.addr = fixup->fixup | PSW_ADDR_AMODE;
+		trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 		return;
 	}
 
@@ -329,6 +331,9 @@ do_exception(struct pt_regs *regs, unsigned long error_code, int write)
 	 */
 	local_irq_enable();
 
+	trace_mark(kernel_arch_trap_entry, "trap_id %ld ip #p%lu",
+		error_code & 0xffff, instruction_pointer(regs));
+
 	down_read(&mm->mmap_sem);
 
 	si_code = SEGV_MAPERR;
@@ -412,6 +417,7 @@ bad_area:
 		tsk->thread.prot_addr = address;
 		tsk->thread.trap_no = error_code;
 		do_sigsegv(regs, error_code, si_code, address);
+		trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 		return;
 	}
 
-- 
1.5.5.1

