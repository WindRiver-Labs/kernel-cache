From 5e752ed355246424e22fd8392c92a356bc8cc397 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:59 -0400
Subject: [PATCH 194/391] ltt-per-cpu-periodical-switch

ltt per cpu periodical switch

per channel
per-cpu timer
variable frequency
activation/deactivation protected by trace mutex.
Useful for ascii dump and network streaming.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-channels.h |   16 ++++++++-
 ltt/ltt-channels.c           |   43 ++++++++++++++++++++++-
 ltt/ltt-relay-locked.c       |   78 +++++++++++++++++++++++++++++++++++++++++
 ltt/ltt-relay.c              |   79 +++++++++++++++++++++++++++++++++++++++++-
 ltt/ltt-tracer.c             |    5 ++-
 5 files changed, 217 insertions(+), 4 deletions(-)

diff --git a/include/linux/ltt-channels.h b/include/linux/ltt-channels.h
index 0475d76..4ecc41c 100644
--- a/include/linux/ltt-channels.h
+++ b/include/linux/ltt-channels.h
@@ -5,11 +5,14 @@
  * Copyright (C) 2008 Mathieu Desnoyers (mathieu.desnoyers@polymtl.ca)
  *
  * Dynamic tracer channel allocation.
+
+ * Dual LGPL v2.1/GPL v2 license.
  */
 
 #include <linux/limits.h>
 #include <linux/kref.h>
 #include <linux/list.h>
+#include <linux/timer.h>
 
 #define EVENTS_PER_CHANNEL	65536
 
@@ -48,6 +51,7 @@ struct ltt_channel_struct {
 	struct ltt_channel_buf_access_ops *buf_access_ops;
 	unsigned int subbuf_size;
 	unsigned int subbuf_cnt;
+	unsigned long switch_timer_interval;
 	const char *channel_name;
 } ____cacheline_aligned;
 
@@ -65,6 +69,8 @@ struct ltt_channel_buf_access_ops {
 	int (*put_subbuf)(struct rchan_buf *buf, unsigned long consumed);
 	unsigned long (*get_n_subbufs)(struct rchan_buf *buf);
 	unsigned long (*get_subbuf_size)(struct rchan_buf *buf);
+	void (*start_switch_timer)(struct ltt_channel_struct *ltt_channel);
+	void (*stop_switch_timer)(struct ltt_channel_struct *ltt_channel);
 };
 
 struct ltt_channel_setting {
@@ -88,7 +94,15 @@ int ltt_channels_trace_ref(void);
 struct ltt_channel_struct *ltt_channels_trace_alloc(unsigned int *nr_channels,
 						    int overwrite,
 						    int active);
-void ltt_channels_trace_free(struct ltt_channel_struct *channels);
+void ltt_channels_trace_free(struct ltt_channel_struct *channels,
+	unsigned int nr_channels);
+void ltt_channels_trace_set_timer(struct ltt_channel_struct *channel,
+				  unsigned long interval);
+void ltt_channels_trace_start_timer(struct ltt_channel_struct *channels,
+	unsigned int nr_channels);
+void ltt_channels_trace_stop_timer(struct ltt_channel_struct *channels,
+	unsigned int nr_channels);
+
 int _ltt_channels_get_event_id(const char *channel, const char *name);
 int ltt_channels_get_event_id(const char *channel, const char *name);
 
diff --git a/ltt/ltt-channels.c b/ltt/ltt-channels.c
index 4c4bfbc..4227c0f 100644
--- a/ltt/ltt-channels.c
+++ b/ltt/ltt-channels.c
@@ -270,6 +270,7 @@ struct ltt_channel_struct *ltt_channels_trace_alloc(unsigned int *nr_channels,
 		channel[iter->index].overwrite = overwrite;
 		channel[iter->index].active = active;
 		channel[iter->index].channel_name = iter->name;
+		channel[iter->index].switch_timer_interval = 0;
 	}
 end:
 	mutex_unlock(&ltt_channel_mutex);
@@ -285,7 +286,8 @@ EXPORT_SYMBOL_GPL(ltt_channels_trace_alloc);
  * Called with trace lock held. The actual channel buffers must be freed before
  * this function is called.
  */
-void ltt_channels_trace_free(struct ltt_channel_struct *channels)
+void ltt_channels_trace_free(struct ltt_channel_struct *channels,
+		unsigned int nr_channels)
 {
 	lock_markers();
 	mutex_lock(&ltt_channel_mutex);
@@ -297,6 +299,45 @@ void ltt_channels_trace_free(struct ltt_channel_struct *channels)
 EXPORT_SYMBOL_GPL(ltt_channels_trace_free);
 
 /**
+ * ltt_channels_trace_set_timer - set switch timer
+ * @channel: channel
+ * @interval: interval of timer interrupt, in jiffies. 0 inhibits timer.
+ */
+
+void ltt_channels_trace_set_timer(struct ltt_channel_struct *channel,
+	unsigned long interval)
+{
+	channel->switch_timer_interval = interval;
+}
+EXPORT_SYMBOL_GPL(ltt_channels_trace_set_timer);
+
+/*
+ * called with trace lock held.
+ */
+void ltt_channels_trace_start_timer(struct ltt_channel_struct *channels,
+	unsigned int nr_channels)
+{
+	int i;
+
+	for (i = 0; i < nr_channels; i++)
+		channels[i].buf_access_ops->start_switch_timer(&channels[i]);
+}
+EXPORT_SYMBOL_GPL(ltt_channels_trace_start_timer);
+
+/*
+ * called with trace lock held.
+ */
+void ltt_channels_trace_stop_timer(struct ltt_channel_struct *channels,
+	unsigned int nr_channels)
+{
+	int i;
+
+	for (i = 0; i < nr_channels; i++)
+		channels[i].buf_access_ops->stop_switch_timer(&channels[i]);
+}
+EXPORT_SYMBOL_GPL(ltt_channels_trace_stop_timer);
+
+/**
  * _ltt_channels_get_event_id - get next event ID for a marker
  * @channel: channel name
  * @name: event name
diff --git a/ltt/ltt-relay-locked.c b/ltt/ltt-relay-locked.c
index 4fbf0b0..7e92ac9 100644
--- a/ltt/ltt-relay-locked.c
+++ b/ltt/ltt-relay-locked.c
@@ -84,6 +84,9 @@ struct ltt_channel_buf_struct {
 	int wakeup_readers;		/* Boolean : wakeup readers waiting ? */
 	wait_queue_head_t read_wait;	/* reader wait queue */
 	unsigned int finalized;		/* buffer has been finalized */
+	struct timer_list switch_timer;	/* timer for periodical switch */
+	unsigned long switch_timer_interval;	/* in jiffies. 0 unset */
+	struct rchan_buf *rbuf;		/* Pointer to rchan_buf */
 } ____cacheline_aligned;
 
 static const struct file_operations ltt_file_operations;
@@ -384,6 +387,78 @@ static unsigned long get_subbuf_size(struct rchan_buf *buf)
 	return buf->chan->subbuf_size;
 }
 
+static void switch_buffer(unsigned long data)
+{
+	struct ltt_channel_buf_struct *ltt_buf =
+		(struct ltt_channel_buf_struct *)data;
+	struct rchan_buf *buf = ltt_buf->rbuf;
+
+	if (buf)
+		ltt_force_switch(buf, FORCE_ACTIVE);
+
+	ltt_buf->switch_timer.expires += ltt_buf->switch_timer_interval;
+	add_timer_on(&ltt_buf->switch_timer, smp_processor_id());
+}
+
+static void start_switch_timer(struct ltt_channel_struct *ltt_channel)
+{
+	struct rchan *rchan = ltt_channel->trans_channel_data;
+	int cpu;
+
+	if (!ltt_channel->switch_timer_interval)
+		return;
+
+	// TODO : hotplug
+	for_each_online_cpu(cpu) {
+		struct ltt_channel_buf_struct *ltt_buf;
+		struct rchan_buf *buf;
+
+		buf = rchan->buf[cpu];
+		ltt_buf = buf->chan_private;
+		buf->random_access = 1;
+		ltt_buf->switch_timer_interval =
+			ltt_channel->switch_timer_interval;
+		init_timer(&ltt_buf->switch_timer);
+		ltt_buf->switch_timer.function = switch_buffer;
+		ltt_buf->switch_timer.expires = jiffies +
+					ltt_buf->switch_timer_interval;
+		ltt_buf->switch_timer.data = (unsigned long)ltt_buf;
+		add_timer_on(&ltt_buf->switch_timer, cpu);
+	}
+}
+
+/*
+ * Cannot use del_timer_sync with add_timer_on, so use an IPI to locally
+ * delete the timer.
+ */
+static void stop_switch_timer_ipi(void *info)
+{
+	struct ltt_channel_buf_struct *ltt_buf =
+		(struct ltt_channel_buf_struct *)info;
+
+	del_timer(&ltt_buf->switch_timer);
+}
+
+static void stop_switch_timer(struct ltt_channel_struct *ltt_channel)
+{
+	struct rchan *rchan = ltt_channel->trans_channel_data;
+	int cpu;
+
+	if (!ltt_channel->switch_timer_interval)
+		return;
+
+	// TODO : hotplug
+	for_each_online_cpu(cpu) {
+		struct ltt_channel_buf_struct *ltt_buf;
+		struct rchan_buf *buf;
+
+		buf = rchan->buf[cpu];
+		ltt_buf = buf->chan_private;
+		smp_call_function(stop_switch_timer_ipi, ltt_buf, 1);
+		buf->random_access = 0;
+	}
+}
+
 static struct ltt_channel_buf_access_ops ltt_channel_buf_accessor = {
 	.get_offset   = get_offset,
 	.get_consumed = get_consumed,
@@ -393,6 +468,8 @@ static struct ltt_channel_buf_access_ops ltt_channel_buf_accessor = {
 	.get_subbuf_size = get_subbuf_size,
 	.open = _ltt_open,
 	.release = _ltt_release,
+	.start_switch_timer = start_switch_timer,
+	.stop_switch_timer = stop_switch_timer,
 };
 
 /**
@@ -805,6 +882,7 @@ static int ltt_relay_create_buffer(struct ltt_trace_struct *trace,
 	ltt_buffer_begin_callback(buf, trace->start_tsc, 0);
 	ltt_buf->commit_count[0] += ltt_subbuffer_header_size();
 	ltt_buf->lock = (raw_spinlock_t)__RAW_SPIN_LOCK_UNLOCKED;
+	ltt_buf->rbuf = buf;
 
 	return 0;
 }
diff --git a/ltt/ltt-relay.c b/ltt/ltt-relay.c
index 65779ba..98b1758 100644
--- a/ltt/ltt-relay.c
+++ b/ltt/ltt-relay.c
@@ -91,6 +91,9 @@ struct ltt_channel_buf_struct {
 	atomic_t wakeup_readers;	/* Boolean : wakeup readers waiting ? */
 	wait_queue_head_t read_wait;	/* reader wait queue */
 	unsigned int finalized;		/* buffer has been finalized */
+	struct timer_list switch_timer;	/* timer for periodical switch */
+	unsigned long switch_timer_interval;	/* in jiffies. 0 unset */
+	struct rchan_buf *rbuf;		/* Pointer to rchan_buf */
 } ____cacheline_aligned;
 
 static const struct file_operations ltt_file_operations;
@@ -385,6 +388,78 @@ static unsigned long get_subbuf_size(struct rchan_buf *buf)
 	return buf->chan->subbuf_size;
 }
 
+static void switch_buffer(unsigned long data)
+{
+	struct ltt_channel_buf_struct *ltt_buf =
+		(struct ltt_channel_buf_struct *)data;
+	struct rchan_buf *buf = ltt_buf->rbuf;
+
+	if (buf)
+		ltt_force_switch(buf, FORCE_ACTIVE);
+
+	ltt_buf->switch_timer.expires += ltt_buf->switch_timer_interval;
+	add_timer_on(&ltt_buf->switch_timer, smp_processor_id());
+}
+
+static void start_switch_timer(struct ltt_channel_struct *ltt_channel)
+{
+	struct rchan *rchan = ltt_channel->trans_channel_data;
+	int cpu;
+
+	if (!ltt_channel->switch_timer_interval)
+		return;
+
+	// TODO : hotplug
+	for_each_online_cpu(cpu) {
+		struct ltt_channel_buf_struct *ltt_buf;
+		struct rchan_buf *buf;
+
+		buf = rchan->buf[cpu];
+		ltt_buf = buf->chan_private;
+		buf->random_access = 1;
+		ltt_buf->switch_timer_interval =
+			ltt_channel->switch_timer_interval;
+		init_timer(&ltt_buf->switch_timer);
+		ltt_buf->switch_timer.function = switch_buffer;
+		ltt_buf->switch_timer.expires = jiffies +
+					ltt_buf->switch_timer_interval;
+		ltt_buf->switch_timer.data = (unsigned long)ltt_buf;
+		add_timer_on(&ltt_buf->switch_timer, cpu);
+	}
+}
+
+/*
+ * Cannot use del_timer_sync with add_timer_on, so use an IPI to locally
+ * delete the timer.
+ */
+static void stop_switch_timer_ipi(void *info)
+{
+	struct ltt_channel_buf_struct *ltt_buf =
+		(struct ltt_channel_buf_struct *)info;
+
+	del_timer(&ltt_buf->switch_timer);
+}
+
+static void stop_switch_timer(struct ltt_channel_struct *ltt_channel)
+{
+	struct rchan *rchan = ltt_channel->trans_channel_data;
+	int cpu;
+
+	if (!ltt_channel->switch_timer_interval)
+		return;
+
+	// TODO : hotplug
+	for_each_online_cpu(cpu) {
+		struct ltt_channel_buf_struct *ltt_buf;
+		struct rchan_buf *buf;
+
+		buf = rchan->buf[cpu];
+		ltt_buf = buf->chan_private;
+		smp_call_function(stop_switch_timer_ipi, ltt_buf, 1);
+		buf->random_access = 0;
+	}
+}
+
 static struct ltt_channel_buf_access_ops ltt_channel_buf_accessor = {
 	.get_offset   = get_offset,
 	.get_consumed = get_consumed,
@@ -394,9 +469,10 @@ static struct ltt_channel_buf_access_ops ltt_channel_buf_accessor = {
 	.get_subbuf_size = get_subbuf_size,
 	.open = _ltt_open,
 	.release = _ltt_release,
+	.start_switch_timer = start_switch_timer,
+	.stop_switch_timer = stop_switch_timer,
 };
 
-
 /**
  *	ltt_open - open file op for ltt files
  *	@inode: opened inode
@@ -819,6 +895,7 @@ static int ltt_relay_create_buffer(struct ltt_trace_struct *trace,
 	local_set(&ltt_buf->events_lost, 0);
 	local_set(&ltt_buf->corrupted_subbuffers, 0);
 	ltt_buf->finalized = 0;
+	ltt_buf->rbuf = buf;
 
 	return 0;
 }
diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index d5ae09a..5b260fc 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -455,7 +455,7 @@ void ltt_release_trace(struct kref *kref)
 {
 	struct ltt_trace_struct *trace = container_of(kref,
 			struct ltt_trace_struct, kref);
-	ltt_channels_trace_free(trace->channels);
+	ltt_channels_trace_free(trace->channels, trace->nr_channels);
 	kfree(trace);
 }
 EXPORT_SYMBOL_GPL(ltt_release_trace);
@@ -1006,6 +1006,7 @@ static int _ltt_trace_start(struct ltt_trace_struct *trace)
 		printk(KERN_ERR "LTT : Can't lock filter module.\n");
 		goto get_ltt_run_filter_error;
 	}
+	ltt_channels_trace_start_timer(trace->channels, trace->nr_channels);
 	trace->active = 1;
 	/* Read by trace points without protection : be careful */
 	ltt_traces.num_active_traces++;
@@ -1072,6 +1073,8 @@ static int _ltt_trace_stop(struct ltt_trace_struct *trace)
 		printk(KERN_INFO "LTT : Tracing not active for trace %s\n",
 				trace->trace_name);
 	if (trace->active) {
+		ltt_channels_trace_stop_timer(trace->channels,
+			trace->nr_channels);
 		trace->active = 0;
 		ltt_traces.num_active_traces--;
 		synchronize_sched(); /* Wait for each tracing to be finished */
-- 
1.6.5.2

