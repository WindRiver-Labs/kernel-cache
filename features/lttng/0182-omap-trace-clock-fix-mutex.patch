From 91ae49e35ab0df046ed521dea17d4e9c523f3d68 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:53 -0400
Subject: [PATCH 182/391] omap-trace-clock-fix-mutex

omap trace clock fix mutex

This is just a quick note to let you know that I think that the mutex in
kernel/trace/trace-clock-32-to-64.c might be incorrect or at least
incorrectly used.

I get these warnings with CONFIG_DEBUG_SPINLOCK_SLEEP, looks like irqs
are disabled when the mutex is locked/unlocked.

[  174.994348] BUG: sleeping function called from invalid context at
kernel/mutex.c:207
[  175.002283] in_atomic(): 1, irqs_disabled(): 0, pid: 1678, name:
lttctl
[  175.009058] INFO: lockdep is turned off.
[  175.013055] [<c0030628>] (dump_stack+0x0/0x14) from [<c004db20>]
(__might_sleep+0x108/0x128)
[  175.021661] [<c004da18>] (__might_sleep+0x0/0x128) from [<c0275158>]
(mutex_lock_nested+0x28/0x2dc)
[  175.030908]  r4:c0885810
[  175.033472] [<c0275130>] (mutex_lock_nested+0x0/0x2dc) from
[<c008e1e0>] (get_synthetic_tsc+0x1c/0xa4)
[  175.042963] [<c008e1c4>] (get_synthetic_tsc+0x0/0xa4) from
[<c003e7b4>] (_start_trace_clock+0x108/0x16c)
[  175.052667]  r5:00000000 r4:00577f46
[  175.056299] [<c003e6ac>] (_start_trace_clock+0x0/0x16c) from
[<c003e848>] (get_trace_clock+0x30/0x44)
[  175.065668] [<c003e818>] (get_trace_clock+0x0/0x44) from [<c014b69c>]
(ltt_trace_alloc+0x60/0x3ac)
[  175.074854] [<c014b63c>] (ltt_trace_alloc+0x0/0x3ac) from
[<c014e954>] (alloc_write+0xe8/0x128)
[  175.083734] [<c014e86c>] (alloc_write+0x0/0x128) from [<c00b6b14>]
(vfs_write+0xbc/0x14c)
[  175.092065]  r6:c4f1df70 r5:4000c2c8 r4:c4e4f9a0
[  175.096765] [<c00b6a58>] (vfs_write+0x0/0x14c) from [<c00b72d8>]
(sys_write+0x48/0xfc)
[  175.104822]  r7:00000001 r6:c4e4f9a0 r5:00000000 r4:00000000
[  175.110615] [<c00b7290>] (sys_write+0x0/0xfc) from [<c002c8e0>]
(ret_fast_syscall+0x0/0x2c)

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/arm/mach-omap2/trace-clock.c |   15 ++++++++-------
 1 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/arch/arm/mach-omap2/trace-clock.c b/arch/arm/mach-omap2/trace-clock.c
index 74b5d0a..b565503 100644
--- a/arch/arm/mach-omap2/trace-clock.c
+++ b/arch/arm/mach-omap2/trace-clock.c
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/clocksource.h>
 #include <linux/timer.h>
+#include <linux/mutex.h>
 #include <mach/dmtimer.h>
 #include <mach/trace-clock.h>
 
@@ -33,7 +34,7 @@ static DEFINE_TIMER(clear_ccnt_ms_timer, clear_ccnt_ms, 0, 0);
  */
 #define CLEAR_CCNT_INTERVAL	(cpu_hz / 4)
 
-static DEFINE_SPINLOCK(trace_clock_lock);
+static DEFINE_MUTEX(trace_clock_lock);
 static int trace_clock_refcount;
 
 /*
@@ -180,32 +181,32 @@ void _stop_trace_clock(void)
 
 void start_trace_clock(void)
 {
-	spin_lock(&trace_clock_lock);
+	mutex_lock(&trace_clock_lock);
 	if (!trace_clock_refcount)
 		goto end;
 	_start_trace_clock();
 end:
-	spin_unlock(&trace_clock_lock);
+	mutex_unlock(&trace_clock_lock);
 }
 
 void stop_trace_clock(void)
 {
-	spin_lock(&trace_clock_lock);
+	mutex_lock(&trace_clock_lock);
 	if (!trace_clock_refcount)
 		goto end;
 	_stop_trace_clock();
 end:
-	spin_unlock(&trace_clock_lock);
+	mutex_unlock(&trace_clock_lock);
 }
 
 void get_trace_clock(void)
 {
-	spin_lock(&trace_clock_lock);
+	mutex_lock(&trace_clock_lock);
 	if (trace_clock_refcount++)
 		goto end;
 	_start_trace_clock();
 end:
-	spin_unlock(&trace_clock_lock);
+	mutex_unlock(&trace_clock_lock);
 }
 EXPORT_SYMBOL_GPL(get_trace_clock);
 
-- 
1.6.5.2

