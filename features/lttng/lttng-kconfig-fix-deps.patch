From 76c73d904f73f58da5e4907a8a88948b8c3d809f Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:27:27 -0400
Subject: [PATCH 246/391] lttng-kconfig-fix-deps

LTTng kconfig fix deps

Fix dependencies when LTTng is built as a module.

e.g. :


ltt/built-in.o: In function `ltt_relay_destroy_buffer':
ltt-relay-lockless.c:(.text+0xcdf): undefined reference to
+`ltt_release_transport'
ltt-relay-lockless.c:(.text+0xe41): undefined reference to `ltt_release_trace'
ltt/built-in.o: In function `ltt_kprobe_handler_pre':
ltt-kprobes.c:(.text+0x2c62): undefined reference to `_ltt_specialized_trace'
ltt/built-in.o: In function `ltt_relay_init':
ltt-relay-lockless.c:(.init.text+0x10): undefined reference to
+`ltt_transport_register'
ltt/built-in.o: In function `ltt_relay_exit':
ltt-relay-lockless.c:(.exit.text+0x11): undefined reference to
+`ltt_transport_unregister'
make: *** [.tmp_vmlinux1] Error 1


Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-tracer.h |   11 ++++-------
 include/linux/vmalloc.h    |    2 +-
 ltt/Kconfig                |   25 +++++++++++++------------
 ltt/Makefile               |   16 +++++++++++++---
 ltt/ltt-kprobes.c          |    6 ++++++
 ltt/ltt-statedump.c        |   35 ++++++++++++++++++++++++++++++++++-
 6 files changed, 71 insertions(+), 24 deletions(-)

diff --git a/include/linux/ltt-tracer.h b/include/linux/ltt-tracer.h
index 855e805..56afad6 100644
--- a/include/linux/ltt-tracer.h
+++ b/include/linux/ltt-tracer.h
@@ -656,13 +656,10 @@ extern void ltt_dump_marker_state(struct ltt_trace_struct *trace);
 void ltt_lock_traces(void);
 void ltt_unlock_traces(void);
 
-#ifdef CONFIG_LTT_KPROBES
-extern void ltt_dump_kprobes_table(void *call_data);
-#else
-static __inline__ void ltt_dump_kprobes_table(void *call_data)
-{
-}
-#endif
+extern void ltt_statedump_register_kprobes_dump(
+	void (*callback)(void *call_data));
+extern void ltt_statedump_unregister_kprobes_dump(
+	void (*callback)(void *call_data));
 
 extern void ltt_dump_softirq_vec(void *call_data);
 
diff --git a/include/linux/vmalloc.h b/include/linux/vmalloc.h
index 227c2a5..abc3687 100644
--- a/include/linux/vmalloc.h
+++ b/include/linux/vmalloc.h
@@ -67,7 +67,7 @@ extern void vunmap(const void *addr);
 
 extern int remap_vmalloc_range(struct vm_area_struct *vma, void *addr,
 							unsigned long pgoff);
-void vmalloc_sync_all(void);
+extern void vmalloc_sync_all(void);
  
 /*
  *	Lowlevel-APIs (not for driver use!)
diff --git a/ltt/Kconfig b/ltt/Kconfig
index 7e59a87..dc85246 100644
--- a/ltt/Kconfig
+++ b/ltt/Kconfig
@@ -170,11 +170,23 @@ config LTT_VMCORE
 
 	  Special crash extension should be used to extract ltt buffers.
 
+config LTT_STATEDUMP
+	tristate "Linux Trace Toolkit State Dump"
+	depends on LTT_TRACER
+	default m
+	help
+	  If you enable this option, the Linux Trace Toolkit State Dump will
+	  be either built in the kernel or as module.
+
+	  This module saves the state of the running kernel at trace start
+	  into the trace buffers along with the ongoing tracing information.
+
 config LTT_KPROBES
-	bool "Linux Trace Toolkit Kprobes Support"
+	tristate "Linux Trace Toolkit Kprobes Support"
 	depends on HAVE_KPROBES
 	depends on LTT_TRACE_CONTROL
 	depends on LTT_FAST_SERIALIZE
+	depends on LTT_STATEDUMP
 	select KPROBES
 	select KALLSYMS
 	default y
@@ -185,17 +197,6 @@ config LTT_KPROBES
 	    ltt/kprobes/disable
 	    ltt/kprobes/list
 
-config LTT_STATEDUMP
-	tristate "Linux Trace Toolkit State Dump"
-	depends on LTT_TRACER
-	default m
-	help
-	  If you enable this option, the Linux Trace Toolkit State Dump will
-	  be either built in the kernel or as module.
-
-	  This module saves the state of the running kernel at trace start
-	  into the trace buffers along with the ongoing tracing information.
-
 config LTT_FTRACE
 	bool "Linux Trace Toolkit Function Tracer Support"
 	depends on LTT_SERIALIZE
diff --git a/ltt/Makefile b/ltt/Makefile
index 3f59d70..cc6fa92 100644
--- a/ltt/Makefile
+++ b/ltt/Makefile
@@ -6,9 +6,19 @@ obj-$(CONFIG_MARKERS)			+= ltt-channels.o
 obj-$(CONFIG_LTT)			+= ltt-core.o
 obj-$(CONFIG_LTT_TRACER)		+= ltt-tracer.o
 obj-$(CONFIG_LTT_TRACE_CONTROL)		+= ltt-marker-control.o
-obj-$(CONFIG_LTT_RELAY_LOCKLESS)	+= ltt-relay-lockless.o
-obj-$(CONFIG_LTT_RELAY_IRQOFF)		+= ltt-relay-irqoff.o
-obj-$(CONFIG_LTT_RELAY_LOCKED)		+= ltt-relay-locked.o
+
+ifdef CONFIG_LTT_RELAY_LOCKLESS
+obj-$(CONFIG_LTT_TRACER)		+= ltt-relay-lockless.o
+endif
+
+ifdef CONFIG_LTT_RELAY_IRQOFF
+obj-$(CONFIG_LTT_TRACER)		+= ltt-relay-irqoff.o
+endif
+
+ifdef CONFIG_LTT_RELAY_LOCKED
+obj-$(CONFIG_LTT_TRACER)		+= ltt-relay-locked.o
+endif
+
 obj-$(CONFIG_LTT_RELAY_ALLOC)		+= ltt-relay-alloc.o
 obj-$(CONFIG_LTT_SERIALIZE)		+= ltt-serialize.o
 obj-$(CONFIG_LTT_STATEDUMP)		+= ltt-statedump.o
diff --git a/ltt/ltt-kprobes.c b/ltt/ltt-kprobes.c
index 11c8f58..d29289d 100644
--- a/ltt/ltt-kprobes.c
+++ b/ltt/ltt-kprobes.c
@@ -375,6 +375,10 @@ static const struct file_operations ltt_kprobes_list = {
 	.release = ltt_kprobes_list_release,
 };
 
+/*
+ * kprobes table dump. Callback invoked by ltt-statedump. ltt-statedump must
+ * take a reference to this module before calling this callback.
+ */
 void ltt_dump_kprobes_table(void *call_data)
 {
 	struct kprobe_entry *e;
@@ -445,6 +449,7 @@ static int __init ltt_kprobes_init(void)
 		ret = -ENOMEM;
 		goto err_no_list;
 	}
+	ltt_statedump_register_kprobes_dump(ltt_dump_kprobes_table);
 
 	mutex_unlock(&ltt_kprobes_mutex);
 	return ret;
@@ -467,6 +472,7 @@ static void __exit ltt_kprobes_exit(void)
 	printk(KERN_INFO "LTT : ltt-kprobes exit\n");
 	mutex_lock(&ltt_kprobes_mutex);
 	module_exit = 1;
+	ltt_statedump_unregister_kprobes_dump(ltt_dump_kprobes_table);
 	debugfs_remove(ltt_kprobes_list_dentry);
 	debugfs_remove(ltt_kprobes_disable_dentry);
 	debugfs_remove(ltt_kprobes_enable_dentry);
diff --git a/ltt/ltt-statedump.c b/ltt/ltt-statedump.c
index dca527d..e5100e3 100644
--- a/ltt/ltt-statedump.c
+++ b/ltt/ltt-statedump.c
@@ -31,6 +31,7 @@
 #include <linux/marker.h>
 #include <linux/fdtable.h>
 #include <linux/swap.h>
+#include <linux/mutex.h>
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 #include <linux/irq.h>
@@ -42,6 +43,13 @@ static atomic_t kernel_threads_to_run;
 static struct delayed_work cpu_work[NR_CPUS];
 static struct task_struct *work_wake_task;
 
+static void empty_cb(void *call_data)
+{
+}
+
+static DEFINE_MUTEX(statedump_cb_mutex);
+static void (*ltt_dump_kprobes_table_cb)(void *call_data) = empty_cb;
+
 enum lttng_thread_type {
 	LTTNG_USER_THREAD = 0,
 	LTTNG_KERNEL_THREAD = 1,
@@ -325,6 +333,22 @@ ltt_enumerate_process_states(struct ltt_probe_private_data *call_data)
 	return 0;
 }
 
+void ltt_statedump_register_kprobes_dump(void (*callback)(void *call_data))
+{
+	mutex_lock(&statedump_cb_mutex);
+	ltt_dump_kprobes_table_cb = callback;
+	mutex_unlock(&statedump_cb_mutex);
+}
+EXPORT_SYMBOL_GPL(ltt_statedump_register_kprobes_dump);
+
+void ltt_statedump_unregister_kprobes_dump(void (*callback)(void *call_data))
+{
+	mutex_lock(&statedump_cb_mutex);
+	ltt_dump_kprobes_table_cb = empty_cb;
+	mutex_unlock(&statedump_cb_mutex);
+}
+EXPORT_SYMBOL_GPL(ltt_statedump_unregister_kprobes_dump);
+
 void ltt_statedump_work_func(struct work_struct *work)
 {
 	if (atomic_dec_and_test(&kernel_threads_to_run)) {
@@ -336,6 +360,7 @@ void ltt_statedump_work_func(struct work_struct *work)
 static int do_ltt_statedump(struct ltt_probe_private_data *call_data)
 {
 	int cpu;
+	struct module *cb_owner;
 
 	printk(KERN_DEBUG "LTT state dump thread start\n");
 	ltt_enumerate_process_states(call_data);
@@ -345,11 +370,19 @@ static int do_ltt_statedump(struct ltt_probe_private_data *call_data)
 	list_interrupts(call_data);
 	ltt_enumerate_network_ip_interface(call_data);
 	ltt_dump_swap_files(call_data);
-	ltt_dump_kprobes_table(call_data);
 	ltt_dump_sys_call_table(call_data);
 	ltt_dump_softirq_vec(call_data);
 	ltt_dump_idt_table(call_data);
 
+	mutex_lock(&statedump_cb_mutex);
+
+	cb_owner = __module_address((unsigned long)ltt_dump_kprobes_table_cb);
+	__module_get(cb_owner);
+	ltt_dump_kprobes_table_cb(call_data);
+	module_put(cb_owner);
+
+	mutex_unlock(&statedump_cb_mutex);
+
 	/*
 	 * Fire off a work queue on each CPU. Their sole purpose in life
 	 * is to guarantee that each CPU has been in a state where is was in
-- 
1.6.5.2

