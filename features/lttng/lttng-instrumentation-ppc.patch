From e43a7df6a27d253fba80da16a466e4b08b53960e Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Tue, 15 Jul 2008 14:57:44 -0400
Subject: [PATCH] LTTng instrumentation PPC

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/ppc/kernel/misc.S  |    2 +-
 arch/ppc/kernel/time.c  |    4 ++++
 arch/ppc/kernel/traps.c |    3 +++
 arch/ppc/mm/fault.c     |    3 +++
 4 files changed, 11 insertions(+), 1 deletions(-)

diff --git a/arch/ppc/kernel/misc.S b/arch/ppc/kernel/misc.S
index d5e0dfc..fe8a89c 100644
--- a/arch/ppc/kernel/misc.S
+++ b/arch/ppc/kernel/misc.S
@@ -826,7 +826,7 @@ _GLOBAL(_get_SP)
  * Create a kernel thread
  *   kernel_thread(fn, arg, flags)
  */
-_GLOBAL(kernel_thread)
+_GLOBAL(original_kernel_thread)
 	stwu	r1,-16(r1)
 	stw	r30,8(r1)
 	stw	r31,12(r1)
diff --git a/arch/ppc/kernel/time.c b/arch/ppc/kernel/time.c
index 92393f1..75be984 100644
--- a/arch/ppc/kernel/time.c
+++ b/arch/ppc/kernel/time.c
@@ -178,7 +178,10 @@ void timer_interrupt(struct pt_regs * regs)
 	if (atomic_read(&ppc_n_lost_interrupts) != 0)
 		do_IRQ(regs);
 
+	trace_mark(kernel_arch_trap_entry, "trap_id %ld ip #p%ld",
+		regs->trap, instruction_pointer(regs));
 	old_regs = set_irq_regs(regs);
+
 	irq_enter();
 
 	while ((next_dec = tb_ticks_per_jiffy - tb_delta(&jiffy_stamp)) <= 0) {
@@ -238,6 +241,7 @@ void timer_interrupt(struct pt_regs * regs)
 
 	irq_exit();
 	set_irq_regs(old_regs);
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 }
 
 /*
diff --git a/arch/ppc/kernel/traps.c b/arch/ppc/kernel/traps.c
index a467a42..d7e8e22 100644
--- a/arch/ppc/kernel/traps.c
+++ b/arch/ppc/kernel/traps.c
@@ -108,11 +108,14 @@ void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)
 		debugger(regs);
 		die("Exception in kernel mode", regs, signr);
 	}
+	trace_mark(kernel_arch_trap_entry, "trap_id %ld ip #p%ld", regs->trap,
+		instruction_pointer(regs));
 	info.si_signo = signr;
 	info.si_errno = 0;
 	info.si_code = code;
 	info.si_addr = (void __user *) addr;
 	force_sig_info(signr, &info, current);
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 
 	/*
 	 * Init gets no signals that it doesn't have a handler for.
diff --git a/arch/ppc/mm/fault.c b/arch/ppc/mm/fault.c
index a51fd3e..1821d64 100644
--- a/arch/ppc/mm/fault.c
+++ b/arch/ppc/mm/fault.c
@@ -251,7 +251,10 @@ good_area:
 	 * the fault.
 	 */
  survive:
+	trace_mark(kernel_arch_trap_entry, "trap_id %ld ip #p%ld",
+		regs->trap, instruction_pointer(regs));
 	fault = handle_mm_fault(mm, vma, address, is_write);
+	trace_mark(kernel_arch_trap_exit, MARK_NOARGS);
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
-- 
1.5.5.1

