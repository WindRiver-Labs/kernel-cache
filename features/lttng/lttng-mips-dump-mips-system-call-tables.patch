From 85f31ee846ea44b98e8bce048e3c840289c9a9e6 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:28:41 -0400
Subject: [PATCH 384/391] lttng-mips-dump-mips-system-call-tables

The 64-bit kernel may support all three ABIs, so we iterate the
sys_call_tables of all of enabled ABIs.

[Mathieu: Coding style cleanup]

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
---
 arch/mips/Kconfig              |    1 +
 arch/mips/kernel/scall64-64.S  |    3 +-
 arch/mips/kernel/scall64-n32.S |    2 +
 arch/mips/kernel/scall64-o32.S |    8 ++--
 arch/mips/kernel/syscall.c     |   65 ++++++++++++++++++++++++++++++++++++++++
 5 files changed, 74 insertions(+), 5 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 1352253..ade04a8 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -11,6 +11,7 @@ config MIPS
 	select HAVE_FTRACE_MCOUNT_RECORD
 	select HAVE_FUNCTION_GRAPH_TRACER
 	select RTC_LIB if !MACH_LOONGSON
+	select HAVE_LTT_DUMP_TABLES
 
 mainmenu "Linux/MIPS Kernel Configuration"
 
diff --git a/arch/mips/kernel/scall64-64.S b/arch/mips/kernel/scall64-64.S
index 47c2f52..4068d06 100644
--- a/arch/mips/kernel/scall64-64.S
+++ b/arch/mips/kernel/scall64-64.S
@@ -125,7 +125,8 @@ illegal_syscall:
 	END(handle_sys64)
 
 	.align	3
-sys_call_table:
+	.type	sys_call_table,@object
+EXPORT(sys_call_table)
 	PTR	sys_read			/* 5000 */
 	PTR	sys_write
 	PTR	sys_open
diff --git a/arch/mips/kernel/scall64-n32.S b/arch/mips/kernel/scall64-n32.S
index 1a7628d..13e6564 100644
--- a/arch/mips/kernel/scall64-n32.S
+++ b/arch/mips/kernel/scall64-n32.S
@@ -119,6 +119,8 @@ not_n32_scall:
 
 	END(handle_sysn32)
 
+	.align	3
+	.type	sysn32_call_table,@object
 EXPORT(sysn32_call_table)
 	PTR	sys_read			/* 6000 */
 	PTR	sys_write
diff --git a/arch/mips/kernel/scall64-o32.S b/arch/mips/kernel/scall64-o32.S
index bfaf04d..a981be2 100644
--- a/arch/mips/kernel/scall64-o32.S
+++ b/arch/mips/kernel/scall64-o32.S
@@ -53,7 +53,7 @@ NESTED(handle_sys, PT_SIZE, sp)
 	sll	a3, a3, 0
 
 	dsll	t0, v0, 3		# offset into table
-	ld	t2, (sys_call_table - (__NR_O32_Linux * 8))(t0)
+	ld	t2, (syso32_call_table - (__NR_O32_Linux * 8))(t0)
 
 	sd	a3, PT_R26(sp)		# save a3 for syscall restarting
 
@@ -179,7 +179,7 @@ LEAF(sys32_syscall)
 	beqz	t0, einval		# do not recurse
 	dsll	t1, t0, 3
 	beqz	v0, einval
-	ld	t2, sys_call_table(t1)		# syscall routine
+	ld	t2, syso32_call_table(t1)	# syscall routine
 
 	move	a0, a1			# shift argument registers
 	move	a1, a2
@@ -201,8 +201,8 @@ einval:	li	v0, -ENOSYS
 	END(sys32_syscall)
 
 	.align	3
-	.type	sys_call_table,@object
-sys_call_table:
+	.type	syso32_call_table,@object
+EXPORT(syso32_call_table)
 	PTR	sys32_syscall			/* 4000 */
 	PTR	sys_exit
 	PTR	sys_fork
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index d0e29b6..3edeb8a 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -29,6 +29,7 @@
 #include <linux/ipc.h>
 #include <linux/uaccess.h>
 #include <linux/slab.h>
+#include <linux/kallsyms.h>
 #include <trace/ipc.h>
 
 #include <asm/asm.h>
@@ -416,3 +417,67 @@ int kernel_execve(const char *filename, char *const argv[], char *const envp[])
 
 	return -__v0;
 }
+
+void ltt_dump_sys_call_table(void *call_data)
+{
+	int i;
+	char namebuf[KSYM_NAME_LEN];
+
+#ifdef CONFIG_32BIT
+	for (i = 0; i < __NR_O32_Linux_syscalls; i++) {
+		extern struct {
+			unsigned long ptr;
+			long j;
+		} sys_call_table[];
+
+		sprint_symbol(namebuf, sys_call_table[i].ptr);
+		__trace_mark(0, syscall_state, sys_call_table, call_data,
+			     "id %d address %p symbol %s",
+			     i + __NR_O32_Linux, (void *)sys_call_table[i].ptr,
+			     namebuf);
+	}
+#endif
+#ifdef CONFIG_64BIT
+# ifdef CONFIG_MIPS32_O32
+	for (i = 0; i < __NR_O32_Linux_syscalls; i++) {
+		extern unsigned long syso32_call_table[];
+
+		sprint_symbol(namebuf, syso32_call_table[i]);
+		__trace_mark(0, syscall_state, sys_call_table, call_data,
+			     "id %d address %p symbol %s",
+			     i + __NR_O32_Linux, (void *)syso32_call_table[i],
+			     namebuf);
+	}
+# endif
+
+	for (i = 0; i < __NR_64_Linux_syscalls; i++) {
+		extern unsigned long sys_call_table[];
+
+		sprint_symbol(namebuf, sys_call_table[i]);
+		__trace_mark(0, syscall_state, sys_call_table, call_data,
+			     "id %d address %p symbol %s",
+			     i + __NR_64_Linux, (void *)sys_call_table[i],
+			     namebuf);
+	}
+
+# ifdef CONFIG_MIPS32_N32
+	for (i = 0; i < __NR_N32_Linux_syscalls; i++) {
+		extern unsigned long sysn32_call_table[];
+
+		sprint_symbol(namebuf, sysn32_call_table[i]);
+		__trace_mark(0, syscall_state, sys_call_table, call_data,
+			     "id %d address %p symbol %s",
+			     i + __NR_N32_Linux, (void *)sysn32_call_table[i],
+			     namebuf);
+	}
+# endif
+#endif
+}
+EXPORT_SYMBOL_GPL(ltt_dump_sys_call_table);
+
+void ltt_dump_idt_table(void *call_data)
+{
+	/* No IDT information yet.  */
+	return;
+}
+EXPORT_SYMBOL_GPL(ltt_dump_idt_table);
-- 
1.6.5.2

