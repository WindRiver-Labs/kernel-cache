From dc810e8e9bc58c7b0e15232a6012789523f63f0d Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:28:37 -0400
Subject: [PATCH 375/391] lttng-kref-fix

lttng kref fix

Fix handling of concurrent trace session teardown with lttd opening a dentry.
We have to wait for all users of the dentry to be gone (after we removed the
dentry) before we can delete the channel structures.

Problem mostly visible when spawning lttd daemons close to trace teardown
(saving flight recorder channels to disk). An easy way to trigger the bug is to
start/stop flight recorder traces in loop while running hackbench in loops on a
SMP system.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
---
 include/linux/ltt-relay.h  |    1 +
 include/linux/ltt-tracer.h |    1 +
 ltt/ltt-relay-alloc.c      |   30 +++++++++++++++++++++++++++++-
 ltt/ltt-relay-lockless.c   |   10 +++++++++-
 ltt/ltt-relay-lockless.h   |    1 +
 ltt/ltt-tracer.c           |   12 ++++++++----
 6 files changed, 49 insertions(+), 6 deletions(-)

diff --git a/include/linux/ltt-relay.h b/include/linux/ltt-relay.h
index 82ac8a7..4ec2bb5 100644
--- a/include/linux/ltt-relay.h
+++ b/include/linux/ltt-relay.h
@@ -84,6 +84,7 @@ int ltt_chan_alloc_init(struct ltt_chan_alloc *chan, struct ltt_trace *trace,
 			struct dentry *parent, size_t sb_size,
 			size_t n_sb, int extra_reader_sb, int overwrite);
 void ltt_chan_alloc_free(struct ltt_chan_alloc *chan);
+void ltt_chan_alloc_remove_files(struct ltt_chan_alloc *chan);
 int ltt_chanbuf_create_file(const char *filename, struct dentry *parent,
 			    int mode, struct ltt_chanbuf *buf);
 int ltt_chanbuf_remove_file(struct ltt_chanbuf *buf);
diff --git a/include/linux/ltt-tracer.h b/include/linux/ltt-tracer.h
index b3f4e38..aa4a108 100644
--- a/include/linux/ltt-tracer.h
+++ b/include/linux/ltt-tracer.h
@@ -166,6 +166,7 @@ struct ltt_trace_ops {
 			       struct ltt_trace *trace);
 	void (*finish_channel) (struct ltt_chan *chan);
 	void (*remove_channel) (struct kref *kref);
+	void (*remove_channel_files) (struct ltt_chan *chan);
 	void (*user_errors) (struct ltt_trace *trace, unsigned int index,
 			     size_t data_size, struct user_dbg_data *dbg,
 			     int cpu);
diff --git a/ltt/ltt-relay-alloc.c b/ltt/ltt-relay-alloc.c
index dfef18b..3bd2eb2 100644
--- a/ltt/ltt-relay-alloc.c
+++ b/ltt/ltt-relay-alloc.c
@@ -337,6 +337,35 @@ free_chan:
 }
 
 /**
+ * ltt_chan_alloc_remove_files - remove channel files.
+ * @chan: the channel
+ *
+ * Remove all channel files and wait for dentry use counts to become zero.
+ */
+void ltt_chan_alloc_remove_files(struct ltt_chan_alloc *chan)
+{
+	unsigned int i;
+	struct dentry *dentry;
+
+	for_each_possible_cpu(i) {
+		struct ltt_chanbuf *buf = per_cpu_ptr(chan->buf, i);
+
+		if (!buf->a.allocated)
+			continue;
+		dentry = dget(buf->a.dentry);
+		ltt_chanbuf_remove_file(buf);
+		/* TODO: wait / wakeup instead */
+		/*
+		 * Wait for every reference to the dentry to be gone,
+		 * except us.
+		 */
+		while (atomic_read(&dentry->d_count) != 1)
+			cpu_relax();
+		dput(dentry);
+	}
+}
+
+/**
  * ltt_chan_alloc_free - destroy the channel
  * @chan: the channel
  *
@@ -351,7 +380,6 @@ void ltt_chan_alloc_free(struct ltt_chan_alloc *chan)
 
 		if (!buf->a.allocated)
 			continue;
-		ltt_chanbuf_remove_file(buf);
 		ltt_chanbuf_free(buf);
 	}
 	free_percpu(chan->buf);
diff --git a/ltt/ltt-relay-lockless.c b/ltt/ltt-relay-lockless.c
index 0d1c064..09584b6 100644
--- a/ltt/ltt-relay-lockless.c
+++ b/ltt/ltt-relay-lockless.c
@@ -218,11 +218,18 @@ free_chanbuf:
 	return ret;
 }
 
+void ltt_chan_remove_files(struct ltt_chan *chan)
+{
+	ltt_ascii_remove(chan);
+	ltt_chan_alloc_remove_files(&chan->a);
+}
+EXPORT_SYMBOL_GPL(ltt_chan_remove_files);
+
+
 void ltt_chan_free(struct kref *kref)
 {
 	struct ltt_chan *chan = container_of(kref, struct ltt_chan, a.kref);
 
-	ltt_ascii_remove(chan);
 	ltt_chan_alloc_free(&chan->a);
 }
 EXPORT_SYMBOL_GPL(ltt_chan_free);
@@ -1316,6 +1323,7 @@ static struct ltt_transport ltt_relay_transport = {
 		.create_channel = ltt_chan_create,
 		.finish_channel = ltt_relay_finish_channel,
 		.remove_channel = ltt_chan_free,
+		.remove_channel_files = ltt_chan_remove_files,
 		.wakeup_channel = ltt_relay_async_wakeup_chan,
 		.user_blocking = ltt_relay_user_blocking,
 		.user_errors = ltt_relay_print_user_errors,
diff --git a/ltt/ltt-relay-lockless.h b/ltt/ltt-relay-lockless.h
index dae9023..e2d29c8 100644
--- a/ltt/ltt-relay-lockless.h
+++ b/ltt/ltt-relay-lockless.h
@@ -171,6 +171,7 @@ extern int ltt_chan_create(const char *base_filename, struct ltt_chan *chan,
 			   struct dentry *parent, size_t sb_size, size_t n_sb,
 			   int overwrite, struct ltt_trace *trace);
 extern void ltt_chan_free(struct kref *kref);
+extern void ltt_chan_remove_files(struct ltt_chan *chan);
 
 /* Buffer access operations */
 
diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index 5a587fe..80e9533 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -909,9 +909,11 @@ int ltt_trace_alloc(const char *trace_name)
 
 create_channel_error:
 	for (chan--; chan >= 0; chan--) {
-		if (trace->channels[chan].active)
-			kref_put(&trace->channels[chan].a.kref,
-				 trace->ops->remove_channel);
+		if (trace->channels[chan].active) {
+			struct ltt_chan *chanp = &trace->channels[chan];
+			trace->ops->remove_channel_files(chanp);
+			kref_put(&chanp->a.kref, trace->ops->remove_channel);
+		}
 	}
 	trace->ops->remove_dirs(trace);
 
@@ -1013,9 +1015,11 @@ static void __ltt_trace_destroy(struct ltt_trace *trace)
 
 	for (i = 0; i < trace->nr_channels; i++) {
 		chan = &trace->channels[i];
-		if (chan->active)
+		if (chan->active) {
+			trace->ops->remove_channel_files(chan);
 			kref_put(&chan->a.kref,
 				 trace->ops->remove_channel);
+		}
 	}
 
 	/*
-- 
1.6.5.2

