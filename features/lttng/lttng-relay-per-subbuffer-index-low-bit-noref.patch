From a1acad28609f27d332935de3b79530ee81399b37 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:27:42 -0400
Subject: [PATCH 269/391] lttng-relay-per-subbuffer-index-low-bit-noref

lttng relay per subbuffer index low bit for NOREF

Add low bit of the subbuffer index to indicate that the subbuffer is being used.
the bit is set when _not_ used, bit is cleared if a reference is taken.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-relay.h |   94 ++++++++++++++++++++++++++++++++++++++++++++-
 ltt/ltt-relay-alloc.c     |   81 +++++++++++++++++++++++++++++---------
 2 files changed, 154 insertions(+), 21 deletions(-)

diff --git a/include/linux/ltt-relay.h b/include/linux/ltt-relay.h
index d73e87e..337c039 100644
--- a/include/linux/ltt-relay.h
+++ b/include/linux/ltt-relay.h
@@ -28,6 +28,15 @@
 /* Needs a _much_ better name... */
 #define FIX_SIZE(x) ((((x) - 1) & PAGE_MASK) + PAGE_SIZE)
 
+/* Use lowest pointer bit to show the sub-buffer has no reference. */
+#define RCHAN_NOREF_FLAG	0x1UL
+
+#define RCHAN_SB_IS_NOREF(x)	((unsigned long)(x) & RCHAN_NOREF_FLAG)
+#define RCHAN_SB_SET_NOREF(x)	\
+	(x = (struct rchan_page *)((unsigned long)(x) | RCHAN_NOREF_FLAG))
+#define RCHAN_SB_CLEAR_NOREF(x)	\
+	(x = (struct rchan_page *)((unsigned long)(x) & ~RCHAN_NOREF_FLAG))
+
 /*
  * Tracks changes to rchan/rchan_buf structs
  */
@@ -249,19 +258,100 @@ static __inline__ int ltt_relay_write(struct rchan_buf *buf, size_t offset,
 {
 	size_t sbidx, index;
 	ssize_t pagecpy;
+	struct rchan_page *rpages;
 
 	offset &= buf->chan->alloc_size - 1;
 	sbidx = offset >> buf->chan->subbuf_size_order;
 	index = (offset & (buf->chan->subbuf_size - 1)) >> PAGE_SHIFT;
 	pagecpy = min_t(size_t, len, (- offset) & ~PAGE_MASK);
-	ltt_relay_do_copy(buf->rchan_wsb[sbidx].pages[index].virt
-				+ (offset & ~PAGE_MASK), src, pagecpy);
+	rpages = buf->rchan_wsb[sbidx].pages;
+	WARN_ON_ONCE(RCHAN_SB_IS_NOREF(rpages));
+	ltt_relay_do_copy(rpages[index].virt + (offset & ~PAGE_MASK),
+			  src, pagecpy);
 
 	if (unlikely(len != pagecpy))
 		_ltt_relay_write(buf, offset, src, len, pagecpy);
 	return len;
 }
 
+/**
+ * ltt_clear_noref_flag - Clear the noref subbuffer flag, for writer.
+ */
+static __inline__ void ltt_clear_noref_flag(struct rchan *rchan,
+					    struct rchan_buf *buf,
+					    long idx)
+{
+	struct rchan_page *sb_pages, *new_sb_pages;
+
+	sb_pages = buf->rchan_wsb[idx].pages;
+	for (;;) {
+		if (!RCHAN_SB_IS_NOREF(sb_pages))
+			return;	/* Already writing to this buffer */
+		new_sb_pages = sb_pages;
+		RCHAN_SB_CLEAR_NOREF(new_sb_pages);
+		new_sb_pages = cmpxchg(&buf->rchan_wsb[idx].pages,
+			sb_pages, new_sb_pages);
+		if (likely(new_sb_pages == sb_pages))
+			break;
+		sb_pages = new_sb_pages;
+	}
+}
+
+/**
+ * ltt_set_noref_flag - Set the noref subbuffer flag, for writer.
+ */
+static __inline__ void ltt_set_noref_flag(struct rchan *rchan,
+					  struct rchan_buf *buf,
+					  long idx)
+{
+	struct rchan_page *sb_pages, *new_sb_pages;
+
+	sb_pages = buf->rchan_wsb[idx].pages;
+	for (;;) {
+		if (RCHAN_SB_IS_NOREF(sb_pages))
+			return;	/* Already set */
+		new_sb_pages = sb_pages;
+		RCHAN_SB_SET_NOREF(new_sb_pages);
+		new_sb_pages = cmpxchg(&buf->rchan_wsb[idx].pages,
+			sb_pages, new_sb_pages);
+		if (likely(new_sb_pages == sb_pages))
+			break;
+		sb_pages = new_sb_pages;
+	}
+}
+
+/**
+ * update_read_sb_index - Read-side subbuffer index update.
+ */
+static __inline__ int update_read_sb_index(struct rchan_buf *buf,
+					   long consumed_idx)
+{
+	struct rchan_page *old_wpage, *new_wpage;
+
+	if (unlikely(buf->chan->extra_reader_sb)) {
+		/*
+		 * Exchange the target writer subbuffer with our own unused
+		 * subbuffer.
+		 */
+		old_wpage = buf->rchan_wsb[consumed_idx].pages;
+		if (unlikely(!RCHAN_SB_IS_NOREF(old_wpage)))
+			return -EAGAIN;
+		WARN_ON_ONCE(!RCHAN_SB_IS_NOREF(buf->rchan_rsb.pages));
+		new_wpage = cmpxchg(&buf->rchan_wsb[consumed_idx].pages,
+				old_wpage,
+				buf->rchan_rsb.pages);
+		if (unlikely(old_wpage != new_wpage))
+			return -EAGAIN;
+		buf->rchan_rsb.pages = new_wpage;
+		RCHAN_SB_CLEAR_NOREF(buf->rchan_rsb.pages);
+	} else {
+		/* No page exchange, use the writer page directly */
+		buf->rchan_rsb.pages = buf->rchan_wsb[consumed_idx].pages;
+		RCHAN_SB_CLEAR_NOREF(buf->rchan_rsb.pages);
+	}
+	return 0;
+}
+
 /*
  * CONFIG_LTT_RELAY kernel API, ltt/ltt-relay-alloc.c
  */
diff --git a/ltt/ltt-relay-alloc.c b/ltt/ltt-relay-alloc.c
index afda3c0..ae00c20 100644
--- a/ltt/ltt-relay-alloc.c
+++ b/ltt/ltt-relay-alloc.c
@@ -126,8 +126,10 @@ static int relay_alloc_buf(struct rchan_buf *buf, size_t *size,
 	return 0;
 
 free_rchan_wsb:
-	for (i = 0; i < n_subbufs; i++)
+	for (i = 0; i < n_subbufs; i++) {
+		RCHAN_SB_CLEAR_NOREF(buf->rchan_wsb[i].pages);
 		kfree(buf->rchan_wsb[i].pages);
+	}
 	kfree(buf->rchan_wsb);
 depopulate:
 	/*
@@ -207,10 +209,14 @@ static void relay_destroy_buf(struct rchan_buf *buf)
 	long i;
 
 	/* Destroy index */
-	if (chan->extra_reader_sb)
+	if (chan->extra_reader_sb) {
+		RCHAN_SB_CLEAR_NOREF(buf->rchan_rsb.pages);
 		kfree(buf->rchan_rsb.pages);
-	for (i = 0; i < chan->n_subbufs; i++)
+	}
+	for (i = 0; i < chan->n_subbufs; i++) {
+		RCHAN_SB_CLEAR_NOREF(buf->rchan_wsb[i].pages);
 		kfree(buf->rchan_wsb[i].pages);
+	}
 	kfree(buf->rchan_wsb);
 
 	/* Destroy pages */
@@ -519,6 +525,7 @@ void _ltt_relay_write(struct rchan_buf *buf, size_t offset,
 	const void *src, size_t len, ssize_t pagecpy)
 {
 	size_t sbidx, index;
+	struct rchan_page *rpages;
 
 	do {
 		len -= pagecpy;
@@ -534,8 +541,10 @@ void _ltt_relay_write(struct rchan_buf *buf, size_t offset,
 		WARN_ON(offset >= buf->chan->alloc_size);
 
 		pagecpy = min_t(size_t, len, PAGE_SIZE - (offset & ~PAGE_MASK));
-		ltt_relay_do_copy(buf->rchan_wsb[sbidx].pages[index].virt
-				+ (offset & ~PAGE_MASK), src, pagecpy);
+		rpages = buf->rchan_wsb[sbidx].pages;
+		WARN_ON_ONCE(RCHAN_SB_IS_NOREF(rpages));
+		ltt_relay_do_copy(rpages[index].virt + (offset & ~PAGE_MASK),
+				  src, pagecpy);
 	} while (unlikely(len != pagecpy));
 }
 EXPORT_SYMBOL_GPL(_ltt_relay_write);
@@ -546,23 +555,27 @@ EXPORT_SYMBOL_GPL(_ltt_relay_write);
  * @offset : offset within the buffer
  * @dest : destination address
  * @len : length to write
+ *
+ * Should be protected by get_subbuf/put_subbuf.
  */
 int ltt_relay_read(struct rchan_buf *buf, size_t offset,
 	void *dest, size_t len)
 {
-	size_t sbidx, index;
+	size_t index;
 	ssize_t pagecpy, orig_len;
+	struct rchan_page *rpages;
 
 	orig_len = len;
 	offset &= buf->chan->alloc_size - 1;
-	sbidx = offset >> buf->chan->subbuf_size_order;
 	index = (offset & (buf->chan->subbuf_size - 1)) >> PAGE_SHIFT;
 	if (unlikely(!len))
 		return 0;
 	for (;;) {
 		pagecpy = min_t(size_t, len, PAGE_SIZE - (offset & ~PAGE_MASK));
-		memcpy(dest, buf->rchan_wsb[sbidx].pages[index].virt
-			+ (offset & ~PAGE_MASK), pagecpy);
+		rpages = buf->rchan_rsb.pages;
+		WARN_ON_ONCE(RCHAN_SB_IS_NOREF(rpages));
+		memcpy(dest, rpages[index].virt + (offset & ~PAGE_MASK),
+		       pagecpy);
 		len -= pagecpy;
 		if (likely(!len))
 			break;
@@ -573,7 +586,6 @@ int ltt_relay_read(struct rchan_buf *buf, size_t offset,
 		 * Underlying layer should never ask for reads across
 		 * subbuffers.
 		 */
-		WARN_ON(sbidx != offset >> buf->chan->subbuf_size_order);
 		WARN_ON(offset >= buf->chan->alloc_size);
 	}
 	return orig_len;
@@ -588,21 +600,23 @@ EXPORT_SYMBOL_GPL(ltt_relay_read);
  * @len : destination's length
  *
  * return string's length
+ * Should be protected by get_subbuf/put_subbuf.
  */
 int ltt_relay_read_cstr(struct rchan_buf *buf, size_t offset,
 		void *dest, size_t len)
 {
-	size_t sbidx, index;
+	size_t index;
 	ssize_t pagecpy, pagelen, strpagelen, orig_offset;
 	char *str;
+	struct rchan_page *rpages;
 
 	offset &= buf->chan->alloc_size - 1;
-	sbidx = offset >> buf->chan->subbuf_size_order;
 	index = (offset & (buf->chan->subbuf_size - 1)) >> PAGE_SHIFT;
 	orig_offset = offset;
 	for (;;) {
-		str = (char *)buf->rchan_wsb[sbidx].pages[index].virt
-				+ (offset & ~PAGE_MASK);
+		rpages = buf->rchan_rsb.pages;
+		WARN_ON_ONCE(RCHAN_SB_IS_NOREF(rpages));
+		str = (char *)rpages[index].virt + (offset & ~PAGE_MASK);
 		pagelen = PAGE_SIZE - (offset & ~PAGE_MASK);
 		strpagelen = strnlen(str, pagelen);
 		if (len) {
@@ -619,7 +633,6 @@ int ltt_relay_read_cstr(struct rchan_buf *buf, size_t offset,
 		 * Underlying layer should never ask for reads across
 		 * subbuffers.
 		 */
-		WARN_ON(sbidx != offset >> buf->chan->subbuf_size_order);
 		WARN_ON(offset >= buf->chan->alloc_size);
 	}
 	if (len)
@@ -632,19 +645,46 @@ EXPORT_SYMBOL_GPL(ltt_relay_read_cstr);
  * ltt_relay_read_get_page - Get a whole page to read from
  * @buf : buffer
  * @offset : offset within the buffer
+ *
+ * Should be protected by get_subbuf/put_subbuf.
  */
 struct page *ltt_relay_read_get_page(struct rchan_buf *buf, size_t offset)
 {
-	size_t sbidx, index;
+	size_t index;
+	struct rchan_page *rpages;
 
 	offset &= buf->chan->alloc_size - 1;
-	sbidx = offset >> buf->chan->subbuf_size_order;
 	index = (offset & (buf->chan->subbuf_size - 1)) >> PAGE_SHIFT;
-	return buf->rchan_wsb[sbidx].pages[index].page;
+	rpages = buf->rchan_rsb.pages;
+	WARN_ON_ONCE(RCHAN_SB_IS_NOREF(rpages));
+	return rpages[index].page;
 }
 EXPORT_SYMBOL_GPL(ltt_relay_read_get_page);
 
 /**
+ * ltt_relay_read_offset_address - get address of a location within the buffer
+ * @buf : buffer
+ * @offset : offset within the buffer.
+ *
+ * Return the address where a given offset is located (for read).
+ * Should be used to get the current subbuffer header pointer. Given we know
+ * it's never on a page boundary, it's safe to write directly to this address,
+ * as long as the write is never bigger than a page size.
+ */
+void *ltt_relay_read_offset_address(struct rchan_buf *buf, size_t offset)
+{
+	size_t index;
+	struct rchan_page *rpages;
+
+	offset &= buf->chan->alloc_size - 1;
+	index = (offset & (buf->chan->subbuf_size - 1)) >> PAGE_SHIFT;
+	rpages = buf->rchan_rsb.pages;
+	WARN_ON_ONCE(RCHAN_SB_IS_NOREF(rpages));
+	return rpages[index].virt + (offset & ~PAGE_MASK);
+}
+EXPORT_SYMBOL_GPL(ltt_relay_read_offset_address);
+
+/**
  * ltt_relay_offset_address - get address of a location within the buffer
  * @buf : buffer
  * @offset : offset within the buffer.
@@ -657,11 +697,14 @@ EXPORT_SYMBOL_GPL(ltt_relay_read_get_page);
 void *ltt_relay_offset_address(struct rchan_buf *buf, size_t offset)
 {
 	size_t sbidx, index;
+	struct rchan_page *rpages;
 
 	offset &= buf->chan->alloc_size - 1;
 	sbidx = offset >> buf->chan->subbuf_size_order;
 	index = (offset & (buf->chan->subbuf_size - 1)) >> PAGE_SHIFT;
-	return buf->rchan_wsb[sbidx].pages[index].virt + (offset & ~PAGE_MASK);
+	rpages = buf->rchan_wsb[sbidx].pages;
+	WARN_ON_ONCE(RCHAN_SB_IS_NOREF(rpages));
+	return rpages[index].virt + (offset & ~PAGE_MASK);
 }
 EXPORT_SYMBOL_GPL(ltt_relay_offset_address);
 
-- 
1.6.5.2

