From 5ea6b4af07eb411821b60bf7a9d7b87c14cba351 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Tue, 15 Jul 2008 15:19:06 -0400
Subject: [PATCH] LTTng - Fix RCU list iteration

In ltt_exit() the ltt_traces_sem is taken and list_for_each_entry_rcu is
> used.
>
> (There is another problem with the code I mention above. It's also
> appear to modify the list inside _ltt_trace_destroy, but your not doing
> a "safe" list traversal. So it should be list_for_each_entry_safe_rcu)
>

This point is good, will fix.

Thanks to Daniel Walker (dwalker@mvista.com) for pointing this out.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/ltt-tracer.c |   15 +++++++++++++--
 1 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index eb73534..6d5b8b0 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -842,11 +842,22 @@ EXPORT_SYMBOL_GPL(ltt_filter_control);
 static void __exit ltt_exit(void)
 {
 	struct ltt_trace_struct *trace;
+	struct list_head *pos, *n;
+	struct list_head tmp;
 
 	ltt_lock_traces();
-	/* Stop each trace and destroy it */
-	list_for_each_entry_rcu(trace, &ltt_traces.head, list) {
+	/* Stop each trace, currently being read by RCU read-side */
+	list_for_each_entry_rcu(trace, &ltt_traces.head, list)
 		_ltt_trace_stop(trace);
+	tmp = ltt_traces.head;
+	/* empty the original list head */
+	INIT_LIST_HEAD(&ltt_traces.head);
+	/* Wait for quiescent state. Readers have preemption disabled. */
+	synchronize_sched();
+	/* Safe iteration is now permitted. It does not have to be RCU-safe
+	 * because no readers are left. */
+	list_for_each_safe(pos, n, &ltt_traces.head) {
+		trace = container_of(pos, struct ltt_trace_struct, list);
 		/* _ltt_trace_destroy does a synchronize_sched() */
 		_ltt_trace_destroy(trace);
 		__ltt_trace_destroy(trace);
-- 
1.5.5.1

