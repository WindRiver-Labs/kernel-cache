From 4bc399aab571e4a17450a9ff121d330d95ee2488 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:27:01 -0400
Subject: [PATCH 198/391] markers-control-fix-same-name-marker-handling

marker control: fix same name marker handling

This patch enables same-name marker handling in debugfs.
The cached marker pointer is removed, and by looking up for
each time instead.
If there are two markers with the same channel name, marker name
and format pair, for example, channel:fs, name:close, format:"fd %u"
in fs_trace and and marker_example respectively. you can get the
following message when you read "info" file in debugfs.

[root@localhost close]# cat info
Location: fs_trace
format: "fd %u"
state: 0
event_id: 0
call: 0xc0468167
probe single : 0xc0466ed8

Location: marker_example
format: "fd %u"
state: 0
event_id: 0
call: 0xc0468167
probe single : 0xc0466ed8

Location indicates where this marker locates.

and enable them all by issuing the following command:

[root@localhost close]# echo 1 > enable

Mathieu :
Use snprintf to make sure we never overflow the buffer len.

Signed-off-by: Gui Jianfeng <guijianfeng@cn.fujitsu.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/ltt-trace-control.c |  140 +++++++++++++++++++++++++++++++---------------
 1 files changed, 94 insertions(+), 46 deletions(-)

diff --git a/ltt/ltt-trace-control.c b/ltt/ltt-trace-control.c
index f3249da..00257fa 100644
--- a/ltt/ltt-trace-control.c
+++ b/ltt/ltt-trace-control.c
@@ -22,6 +22,7 @@
 #include <linux/ltt-tracer.h>
 #include <linux/notifier.h>
 #include <linux/jiffies.h>
+#include <linux/marker.h>
 
 #define LTT_CONTROL_DIR "control"
 #define MARKERS_CONTROL_DIR "markers"
@@ -757,26 +758,29 @@ static const struct file_operations ltt_destroy_trace_operations = {
 	.write = destroy_trace_write,
 };
 
-static int marker_enable_open(struct inode *inode, struct file *filp)
-{
-	filp->private_data = inode->i_private;
-	return 0;
-}
-
 static ssize_t marker_enable_read(struct file *filp, char __user *ubuf,
 			    size_t cnt, loff_t *ppos)
 {
-	struct marker *marker;
 	char *buf;
+	const char *channel, *marker;
 	int len;
 
-	marker = (struct marker *)filp->private_data;
-	buf = kmalloc(1024, GFP_KERNEL);
+	marker = filp->f_dentry->d_parent->d_name.name;
+	channel = filp->f_dentry->d_parent->d_parent->d_name.name;
 
-	len = sprintf(buf, "%d\n", _imv_read(marker->state));
+	len = 0;
+	buf = (char *)__get_free_page(GFP_KERNEL);
 
+	if (is_marker_enabled(channel, marker))
+		len = snprintf(buf, PAGE_SIZE, "%d\n", 1);
+	else
+		len = snprintf(buf, PAGE_SIZE, "%d\n", 0);
+	if (len >= PAGE_SIZE) {
+		len = PAGE_SIZE;
+		buf[PAGE_SIZE] = '\0';
+	}
 	len = simple_read_from_buffer(ubuf, cnt, ppos, buf, len);
-	kfree(buf);
+	free_page((unsigned long)buf);
 
 	return len;
 }
@@ -787,9 +791,11 @@ static ssize_t marker_enable_write(struct file *filp, const char __user *ubuf,
 	char buf[NAME_MAX];
 	int buf_size;
 	int err = 0;
-	struct marker *marker;
+	const char *channel, *marker;
+
+	marker = filp->f_dentry->d_parent->d_name.name;
+	channel = filp->f_dentry->d_parent->d_parent->d_name.name;
 
-	marker = (struct marker *)filp->private_data;
 	buf_size = min(cnt, sizeof(buf) - 1);
 	err = copy_from_user(buf, ubuf, buf_size);
 	if (err)
@@ -801,16 +807,14 @@ static ssize_t marker_enable_write(struct file *filp, const char __user *ubuf,
 	case 'Y':
 	case 'y':
 	case '1':
-		err = ltt_marker_connect(marker->channel, marker->name,
-					 "default");
+		err = ltt_marker_connect(channel, marker, "default");
 		if (err)
 			return err;
 		break;
 	case 'N':
 	case 'n':
 	case '0':
-		err = ltt_marker_disconnect(marker->channel, marker->name,
-					    "default");
+		err = ltt_marker_disconnect(channel, marker, "default");
 		if (err)
 			return err;
 		break;
@@ -822,44 +826,66 @@ static ssize_t marker_enable_write(struct file *filp, const char __user *ubuf,
 }
 
 static const struct file_operations enable_fops = {
-	.open = marker_enable_open,
 	.read = marker_enable_read,
 	.write = marker_enable_write,
 };
 
-static int marker_info_open(struct inode *inode, struct file *filp)
-{
-	filp->private_data = inode->i_private;
-	return 0;
-}
-
+/*
+ * In practice, the output size should never be larger than 4096 kB. If it
+ * ever happens, the output will simply be truncated.
+ */
 static ssize_t marker_info_read(struct file *filp, char __user *ubuf,
 			    size_t cnt, loff_t *ppos)
 {
-	struct marker *marker;
 	char *buf;
+	const char *channel, *marker;
 	int len;
+	struct marker_iter iter;
+
+	marker = filp->f_dentry->d_parent->d_name.name;
+	channel = filp->f_dentry->d_parent->d_parent->d_name.name;
+
+	len = 0;
+	buf = (char *)__get_free_page(GFP_KERNEL);
 
-	marker = (struct marker *)filp->private_data;
-	buf = kmalloc(1024, GFP_KERNEL);
+	marker_iter_reset(&iter);
+	marker_iter_start(&iter);
+	for (; iter.marker != NULL; marker_iter_next(&iter)) {
+		if (!strcmp(iter.marker->channel, channel) &&
+		    !strcmp(iter.marker->name, marker))
+			len += snprintf(buf + len, PAGE_SIZE - len,
+				       "Location: %s\n"
+				       "format: \"%s\"\nstate: %d\n"
+				       "event_id: %hu\n"
+				       "call: 0x%p\n"
+				       "probe %s : 0x%p\n\n",
+				       iter.module ? iter.module->name :
+				       "Core Kernel",
+				       iter.marker->format,
+				       _imv_read(iter.marker->state),
+				       iter.marker->event_id,
+				       iter.marker->call,
+				       iter.marker->ptype ?
+				       "multi" : "single", iter.marker->ptype ?
+				       (void *)iter.marker->multi :
+				       (void *)iter.marker->single.func);
+			if (len >= PAGE_SIZE)
+				break;
+	}
+	marker_iter_stop(&iter);
 
-	len = sprintf(buf, "format: \"%s\"\nstate: %d\n"
-		      "event_id: %hu\n"
-		      "call: 0x%p\n"
-		      "probe %s : 0x%p\n",
-		      marker->format, _imv_read(marker->state),
-		      marker->event_id, marker->call, marker->ptype ?
-		      "multi" : "single", marker->ptype ?
-		      (void *)marker->multi : (void *)marker->single.func);
+	if (len >= PAGE_SIZE) {
+		len = PAGE_SIZE;
+		buf[PAGE_SIZE] = '\0';
+	}
 
 	len = simple_read_from_buffer(ubuf, cnt, ppos, buf, len);
-	kfree(buf);
+	free_page((unsigned long)buf);
 
 	return len;
 }
 
 static const struct file_operations info_fops = {
-	.open = marker_info_open,
 	.read = marker_info_read,
 };
 
@@ -896,7 +922,7 @@ static int build_marker_file(struct marker *marker)
 	enable_d = dir_lookup(marker_d, "enable");
 	if (!enable_d) {
 		enable_d = debugfs_create_file("enable", 0644, marker_d,
-						marker, &enable_fops);
+						NULL, &enable_fops);
 		if (IS_ERR(enable_d) || !enable_d) {
 			printk(KERN_ERR
 			       "%s: create file of %s failed\n",
@@ -909,7 +935,7 @@ static int build_marker_file(struct marker *marker)
 	info_d = dir_lookup(marker_d, "info");
 	if (!info_d) {
 		info_d = debugfs_create_file("info", 0444, marker_d,
-						marker, &info_fops);
+						NULL, &info_fops);
 		if (IS_ERR(info_d) || !info_d) {
 			printk(KERN_ERR
 			       "%s: create file of %s failed\n",
@@ -948,26 +974,47 @@ err_build_fail:
 	return err;
 }
 
-static int remove_marker_control_dir(struct marker *marker)
+static int remove_marker_control_dir(struct module *mod, struct marker *marker)
 {
 	struct dentry *channel_d, *marker_d;
+	const char *channel, *name;
+	int count;
+	struct marker_iter iter;
+
+	count = 0;
 
 	channel_d = dir_lookup(markers_control_dir, marker->channel);
 	if (!channel_d)
 		return -ENOENT;
+	channel = channel_d->d_name.name;
 
 	marker_d = dir_lookup(channel_d, marker->name);
 	if (!marker_d)
 		return -ENOENT;
+	name = marker_d->d_name.name;
+
+	marker_iter_reset(&iter);
+	marker_iter_start(&iter);
+	for (; iter.marker != NULL; marker_iter_next(&iter)) {
+		if (!strcmp(iter.marker->channel, channel) &&
+		    !strcmp(iter.marker->name, name) && mod != iter.module)
+			count++;
+	}
+
+	if (count > 0)
+		goto end;
 
 	debugfs_remove_recursive(marker_d);
 	if (list_empty(&channel_d->d_subdirs))
 		debugfs_remove(channel_d);
 
+end:
+	marker_iter_stop(&iter);
 	return 0;
 }
 
-static void cleanup_control_dir(struct marker *begin, struct marker *end)
+static void cleanup_control_dir(struct module *mod, struct marker *begin,
+				struct marker *end)
 {
 	struct marker *iter;
 
@@ -975,12 +1022,13 @@ static void cleanup_control_dir(struct marker *begin, struct marker *end)
 		return;
 
 	for (iter = begin; iter < end; iter++)
-		remove_marker_control_dir(iter);
+		remove_marker_control_dir(mod, iter);
 
 	return;
 }
 
-static void build_control_dir(struct marker *begin, struct marker *end)
+static void build_control_dir(struct module *mod, struct marker *begin,
+			      struct marker *end)
 {
 	struct marker *iter;
 	int err;
@@ -997,7 +1045,7 @@ static void build_control_dir(struct marker *begin, struct marker *end)
 
 	return;
 err_build_fail:
-	cleanup_control_dir(begin, end);
+	cleanup_control_dir(mod, begin, end);
 }
 
 static int module_notify(struct notifier_block *self,
@@ -1007,11 +1055,11 @@ static int module_notify(struct notifier_block *self,
 
 	switch (val) {
 	case MODULE_STATE_COMING:
-		build_control_dir(mod->markers,
+		build_control_dir(mod, mod->markers,
 				  mod->markers + mod->num_markers);
 		break;
 	case MODULE_STATE_GOING:
-		cleanup_control_dir(mod->markers,
+		cleanup_control_dir(mod, mod->markers,
 				    mod->markers + mod->num_markers);
 		break;
 	}
-- 
1.6.5.2

