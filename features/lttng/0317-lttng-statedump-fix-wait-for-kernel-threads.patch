From c168d43f2003a1803ce53f0b09f5e6fe00323623 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:28:05 -0400
Subject: [PATCH 317/391] lttng-statedump-fix-wait-for-kernel-threads

lttng statedump fix wait for kernel threads

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/ltt-statedump.c |   23 +++++++++++++----------
 1 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/ltt/ltt-statedump.c b/ltt/ltt-statedump.c
index 426d13d..3ea0905 100644
--- a/ltt/ltt-statedump.c
+++ b/ltt/ltt-statedump.c
@@ -31,6 +31,7 @@
 #include <linux/marker.h>
 #include <linux/fdtable.h>
 #include <linux/swap.h>
+#include <linux/wait.h>
 #include <linux/mutex.h>
 
 #ifdef CONFIG_GENERIC_HARDIRQS
@@ -39,9 +40,12 @@
 
 #define NB_PROC_CHUNK 20
 
-static atomic_t kernel_threads_to_run;
+/*
+ * Protected by the trace lock.
+ */
 static struct delayed_work cpu_work[NR_CPUS];
-static struct task_struct *work_wake_task;
+static DECLARE_WAIT_QUEUE_HEAD(statedump_wq);
+static atomic_t kernel_threads_to_run;
 
 static void empty_cb(void *call_data)
 {
@@ -348,10 +352,9 @@ EXPORT_SYMBOL_GPL(ltt_statedump_unregister_kprobes_dump);
 
 void ltt_statedump_work_func(struct work_struct *work)
 {
-	if (atomic_dec_and_test(&kernel_threads_to_run)) {
+	if (atomic_dec_and_test(&kernel_threads_to_run))
 		/* If we are the last thread, wake up do_ltt_statedump */
-		wake_up_process(work_wake_task);
-	}
+		wake_up(&statedump_wq);
 }
 
 static int do_ltt_statedump(struct ltt_probe_private_data *call_data)
@@ -387,16 +390,13 @@ static int do_ltt_statedump(struct ltt_probe_private_data *call_data)
 	 */
 	get_online_cpus();
 	atomic_set(&kernel_threads_to_run, num_online_cpus());
-	work_wake_task = current;
-	__set_current_state(TASK_UNINTERRUPTIBLE);
 	for_each_online_cpu(cpu) {
 		INIT_DELAYED_WORK(&cpu_work[cpu], ltt_statedump_work_func);
 		schedule_delayed_work_on(cpu, &cpu_work[cpu], 0);
 	}
-	put_online_cpus();
 	/* Wait for all threads to run */
-	schedule();
-	BUG_ON(atomic_read(&kernel_threads_to_run) != 0);
+	__wait_event(statedump_wq, (atomic_read(&kernel_threads_to_run) != 0));
+	put_online_cpus();
 	/* Our work is done */
 	printk(KERN_DEBUG "LTT state dump end\n");
 	__trace_mark(0, global_state, statedump_end,
@@ -404,6 +404,9 @@ static int do_ltt_statedump(struct ltt_probe_private_data *call_data)
 	return 0;
 }
 
+/*
+ * Called with trace lock held.
+ */
 int ltt_statedump_start(struct ltt_trace *trace)
 {
 	struct ltt_probe_private_data call_data;
-- 
1.6.5.2

