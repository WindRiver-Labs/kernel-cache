From e60a04430e1bff43da61766fed8e9286977189ac Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 2 Oct 2008 01:43:35 -0400
Subject: [PATCH] LTTng-fix-for-PREEMPT_RT-kernels

LTTng fix for PREEMPT_RT kernels

Fix BUG in RT preempt kernel caused by spinlocks taken within preempt disable
region.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/ltt-tracer.c |   16 ++++++++++++++++
 1 files changed, 16 insertions(+), 0 deletions(-)

diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index 1645717..ea49a25 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -246,11 +246,27 @@ static void trace_async_wakeup(struct ltt_trace_struct *trace)
 static void async_wakeup(unsigned long data)
 {
 	struct ltt_trace_struct *trace;
+
+	/*
+	 * PREEMPT_RT does not allow spinlocks to be taken within preempt
+	 * disable sections (spinlock taken in wake_up). However, mainline won't
+	 * allow mutex to be taken in interrupt context. Ugly.
+	 * A proper way to do this would be to turn the timer into a
+	 * periodically woken up thread, but it adds to the footprint.
+	 */
+#ifndef CONFIG_PREEMPT_RT
 	rcu_read_lock_sched();
+#else
+	ltt_lock_traces();
+#endif
 	list_for_each_entry_rcu(trace, &ltt_traces.head, list) {
 		trace_async_wakeup(trace);
 	}
+#ifndef CONFIG_PREEMPT_RT
 	rcu_read_unlock_sched();
+#else
+	ltt_unlock_traces();
+#endif
 
 	mod_timer(&ltt_async_wakeup_timer, jiffies + LTT_PERCPU_TIMER_INTERVAL);
 }
-- 
1.5.5.1

