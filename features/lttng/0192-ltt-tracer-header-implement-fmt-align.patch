From 91babf491d78464ec6985dc33bc2ed06d58f66ff Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:58 -0400
Subject: [PATCH 192/391] ltt-tracer-header-implement-fmt-align

ltt-tracer-header : implement fmt align

we need know the align for accessing the binary data from
event. (skip the padding data, calculate offset). Needed for ascii text output.

Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-core.h |    9 +++++++
 ltt/ltt-serialize.c      |   61 ++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 70 insertions(+), 0 deletions(-)

diff --git a/include/linux/ltt-core.h b/include/linux/ltt-core.h
index 7995b7b..2e58eee 100644
--- a/include/linux/ltt-core.h
+++ b/include/linux/ltt-core.h
@@ -65,6 +65,8 @@ static inline int ltt_get_alignment(void)
 	return sizeof(void *);
 }
 
+extern unsigned int ltt_fmt_largest_align(size_t align_drift, const char *fmt);
+
 #else
 
 static inline unsigned int ltt_align(size_t align_drift,
@@ -79,6 +81,13 @@ static inline int ltt_get_alignment(void)
 {
 	return 0;
 }
+
+static inline unsigned int ltt_fmt_largest_align(size_t align_drift,
+		const char *fmt)
+{
+	return 0;
+}
+
 #endif /* defined(CONFIG_LTT) && defined(CONFIG_LTT_ALIGNMENT) */
 
 #endif /* LTT_CORE_H */
diff --git a/ltt/ltt-serialize.c b/ltt/ltt-serialize.c
index 2042fec..e0057b9 100644
--- a/ltt/ltt-serialize.c
+++ b/ltt/ltt-serialize.c
@@ -695,6 +695,67 @@ size_t ltt_serialize_printf(struct rchan_buf *buf, unsigned long buf_offset,
 }
 EXPORT_SYMBOL_GPL(ltt_serialize_printf);
 
+#ifdef CONFIG_LTT_ALIGNMENT
+
+unsigned int ltt_fmt_largest_align(size_t align_drift, const char *fmt)
+{
+	char trace_size = 0, c_size = 0;
+	enum ltt_type trace_type = LTT_TYPE_NONE, c_type = LTT_TYPE_NONE;
+	unsigned long attributes = 0;
+	int largest_align = 1;
+
+	for (; *fmt ; ++fmt) {
+		switch (*fmt) {
+		case '#':
+			/* tracetypes (#) */
+			++fmt;			/* skip first '#' */
+			if (*fmt == '#')	/* Escaped ## */
+				break;
+			attributes = 0;
+			fmt = parse_trace_type(fmt, &trace_size, &trace_type,
+				&attributes);
+
+			largest_align = max_t(int, largest_align, trace_size);
+			if (largest_align >= ltt_get_alignment())
+				goto exit;
+			break;
+		case '%':
+			/* c types (%) */
+			++fmt;			/* skip first '%' */
+			if (*fmt == '%')	/* Escaped %% */
+				break;
+			fmt = parse_c_type(fmt, &c_size, &c_type, NULL);
+			/*
+			 * Output c types if no trace types has been
+			 * specified.
+			 */
+			if (!trace_size)
+				trace_size = c_size;
+			if (trace_type == LTT_TYPE_NONE)
+				trace_type = c_type;
+			if (c_type == LTT_TYPE_STRING)
+				trace_type = LTT_TYPE_STRING;
+
+			largest_align = max_t(int, largest_align, trace_size);
+			if (largest_align >= ltt_get_alignment())
+				goto exit;
+
+			trace_size = 0;
+			c_size = 0;
+			trace_type = LTT_TYPE_NONE;
+			c_size = LTT_TYPE_NONE;
+			break;
+		}
+	}
+
+exit:
+	largest_align = min_t(int, largest_align, ltt_get_alignment());
+	return (largest_align - align_drift) & (largest_align - 1);
+}
+EXPORT_SYMBOL_GPL(ltt_fmt_largest_align);
+
+#endif
+
 /*
  * Calculate data size
  * Assume that the padding for alignment starts at a sizeof(void *) address.
-- 
1.6.5.2

