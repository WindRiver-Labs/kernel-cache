From d2679630c5d86c3e6e1423d27f7941b8f7eb0dd8 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:57 -0400
Subject: [PATCH 191/390] ltt-serialize-introduce-ltt-serialize-printf

ltt serialize introduce ltt_serialize_printf()

Introduce ltt_serialize_printf() for format binary data which is in
ltt-relay buffer to human readable text string.

Mathieu :
Edit to fix off-by-one and comments.

Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-tracer.h |    4 ++
 ltt/ltt-serialize.c        |  126 +++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 128 insertions(+), 2 deletions(-)

diff --git a/include/linux/ltt-tracer.h b/include/linux/ltt-tracer.h
index d13b358..7769cce 100644
--- a/include/linux/ltt-tracer.h
+++ b/include/linux/ltt-tracer.h
@@ -120,6 +120,10 @@ extern void ltt_vtrace(const struct marker *mdata, void *probe_data,
 extern void ltt_trace(const struct marker *mdata, void *probe_data,
 	void *call_data, const char *fmt, ...);
 
+size_t ltt_serialize_printf(struct rchan_buf *buf,
+		unsigned long buf_offset, size_t *msg_size,
+		char *output, size_t outlen, const char *fmt);
+
 /*
  * Unique ID assigned to each registered probe.
  */
diff --git a/ltt/ltt-serialize.c b/ltt/ltt-serialize.c
index ab40e80..2042fec 100644
--- a/ltt/ltt-serialize.c
+++ b/ltt/ltt-serialize.c
@@ -227,7 +227,7 @@ parse_end:
  * %n not supported.
  */
 static inline const char *parse_c_type(const char *fmt,
-		char *c_size, enum ltt_type *c_type)
+		char *c_size, enum ltt_type *c_type, char *outfmt)
 {
 	int qualifier;		/* 'h', 'l', or 'L' for integer fields */
 				/* 'z' support added 23/7/1999 S.H.    */
@@ -259,6 +259,13 @@ repeat:
 		}
 	}
 
+	if (outfmt) {
+		if (qualifier != -1)
+			*outfmt++ = (char)qualifier;
+		*outfmt++ = *fmt;
+		*outfmt = 0;
+	}
+
 	switch (*fmt) {
 	case 'c':
 		*c_type = LTT_TYPE_UNSIGNED_INT;
@@ -502,7 +509,7 @@ notrace size_t ltt_serialize_data(struct rchan_buf *buf, size_t buf_offset,
 			++fmt;			/* skip first '%' */
 			if (*fmt == '%')	/* Escaped %% */
 				break;
-			fmt = parse_c_type(fmt, &c_size, &c_type);
+			fmt = parse_c_type(fmt, &c_size, &c_type, NULL);
 			/*
 			 * Output c types if no trace types has been
 			 * specified.
@@ -573,6 +580,121 @@ static inline uint64_t unserialize_base_type(struct rchan_buf *buf,
 	return 0;
 }
 
+static int serialize_printf_data(struct rchan_buf *buf, size_t *ppos,
+		char trace_size, enum ltt_type trace_type,
+		char c_size, enum ltt_type c_type,
+		char *output, ssize_t outlen, const char *outfmt)
+{
+	u64 value;
+	outlen = outlen < 0 ? 0 : outlen;
+
+	if (trace_type == LTT_TYPE_STRING) {
+		size_t len = ltt_relay_read_cstr(buf, *ppos, output, outlen);
+		*ppos += len + 1;
+		return len;
+	}
+
+	value = unserialize_base_type(buf, ppos, trace_size, trace_type);
+
+	if (c_size == 8)
+		return snprintf(output, outlen, outfmt, value);
+	else
+		return snprintf(output, outlen, outfmt, (unsigned int)value);
+}
+
+/**
+ * ltt_serialize_printf - Format a string and place it in a buffer
+ * @buf: The ltt-relay buffer that store binary data
+ * @buf_offset: binary data's offset in @buf (should be masked to use as offset)
+ * @msg_size: return message's length
+ * @output: The buffer to place the result into
+ * @outlen: The size of the buffer, including the trailing '\0'
+ * @fmt: The format string to use
+ *
+ * The return value is the number of characters which would
+ * be generated for the given input, excluding the trailing
+ * '\0', as per ISO C99. If the return is greater than or equal to @outlen,
+ * the resulting string is truncated.
+ */
+size_t ltt_serialize_printf(struct rchan_buf *buf, unsigned long buf_offset,
+		size_t *msg_size, char *output, size_t outlen, const char *fmt)
+{
+	char trace_size = 0, c_size = 0;	/*
+						 * 0 (unset), 1, 2, 4, 8 bytes.
+						 */
+	enum ltt_type trace_type = LTT_TYPE_NONE, c_type = LTT_TYPE_NONE;
+	unsigned long attributes = 0;
+	char outfmt[4] = "%";
+	size_t outpos = 0;
+	size_t len;
+	unsigned long msgpos = buf_offset;
+
+	for (; *fmt ; ++fmt) {
+		switch (*fmt) {
+		case '#':
+			/* tracetypes (#) */
+			++fmt;			/* skip first '#' */
+			if (*fmt == '#') {	/* Escaped ## */
+				if (outpos < outlen)
+					output[outpos] = '#';
+				outpos++;
+				break;
+			}
+			attributes = 0;
+			fmt = parse_trace_type(fmt, &trace_size, &trace_type,
+				&attributes);
+			break;
+		case '%':
+			/* c types (%) */
+			++fmt;			/* skip first '%' */
+			if (*fmt == '%') {	/* Escaped %% */
+				if (outpos < outlen)
+					output[outpos] = '%';
+				outpos++;
+				break;
+			}
+			fmt = parse_c_type(fmt, &c_size, &c_type, outfmt + 1);
+			/*
+			 * Output c types if no trace types has been
+			 * specified.
+			 */
+			if (!trace_size)
+				trace_size = c_size;
+			if (trace_type == LTT_TYPE_NONE)
+				trace_type = c_type;
+			if (c_type == LTT_TYPE_STRING)
+				trace_type = LTT_TYPE_STRING;
+
+			/* perform trace printf */
+			len = serialize_printf_data(buf, &msgpos, trace_size,
+					trace_type, c_size, c_type,
+					output + outpos, outlen - outpos,
+					outfmt);
+			outpos += len;
+			trace_size = 0;
+			c_size = 0;
+			trace_type = LTT_TYPE_NONE;
+			c_size = LTT_TYPE_NONE;
+			attributes = 0;
+			break;
+		default:
+			if (outpos < outlen)
+				output[outpos] = *fmt;
+			outpos++;
+			break;
+		}
+	}
+	if (msg_size)
+		*msg_size = (size_t)(msgpos - buf_offset);
+	/*
+	 * Make sure we end output with terminating \0 when truncated.
+	 */
+	if (outpos >= outlen + 1)
+		output[outlen] = '\0';
+	return outpos;
+}
+EXPORT_SYMBOL_GPL(ltt_serialize_printf);
+
 /*
  * Calculate data size
  * Assume that the padding for alignment starts at a sizeof(void *) address.
-- 
1.6.5.2

