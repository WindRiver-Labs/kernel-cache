From c206a5937c1607bcee09b9e0fb9d9c58f6bed382 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:36 -0400
Subject: [PATCH 147/391] lttng-instrumentation/lttng-instrumentation-s390

LTTng - s390 instrumentation

Changelog :
- added syscall entry/exit instrumentation.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 arch/s390/kernel/ptrace.c   |    5 +++++
 arch/s390/kernel/sys_s390.c |    5 +++++
 arch/s390/kernel/traps.c    |   20 ++++++++++++++++++++
 arch/s390/mm/fault.c        |   14 ++++++++++++++
 4 files changed, 44 insertions(+), 0 deletions(-)

diff --git a/arch/s390/kernel/ptrace.c b/arch/s390/kernel/ptrace.c
index 9f654da..935bb34 100644
--- a/arch/s390/kernel/ptrace.c
+++ b/arch/s390/kernel/ptrace.c
@@ -60,6 +60,9 @@ enum s390_regset {
 	REGSET_GENERAL_EXTENDED,
 };
 
+DEFINE_TRACE(syscall_entry);
+DEFINE_TRACE(syscall_exit);
+
 static void
 FixPerRegisters(struct task_struct *task)
 {
@@ -645,6 +648,7 @@ asmlinkage long do_syscall_trace_enter(struct pt_regs *regs)
 	/* Do the secure computing check first. */
 	secure_computing(regs->gprs[2]);
 
+	trace_syscall_entry(regs, regs->gprs[2]);
 	/*
 	 * The sysc_tracesys code in entry.S stored the system
 	 * call number to gprs[2].
@@ -675,6 +679,7 @@ asmlinkage long do_syscall_trace_enter(struct pt_regs *regs)
 
 asmlinkage void do_syscall_trace_exit(struct pt_regs *regs)
 {
+	trace_syscall_exit(regs->gprs[2]);
 	if (unlikely(current->audit_context))
 		audit_syscall_exit(AUDITSC_RESULT(regs->gprs[2]),
 				   regs->gprs[2]);
diff --git a/arch/s390/kernel/sys_s390.c b/arch/s390/kernel/sys_s390.c
index 7b6b0f8..b324c44 100644
--- a/arch/s390/kernel/sys_s390.c
+++ b/arch/s390/kernel/sys_s390.c
@@ -29,9 +29,12 @@
 #include <linux/personality.h>
 #include <linux/unistd.h>
 #include <linux/ipc.h>
+#include <trace/ipc.h>
 #include <asm/uaccess.h>
 #include "entry.h"
 
+DEFINE_TRACE(ipc_call);
+
 /*
  * Perform the mmap() system call. Linux for S/390 isn't able to handle more
  * than 5 system call parameters, so this system call uses a memory block
@@ -70,6 +73,8 @@ SYSCALL_DEFINE5(s390_ipc, uint, call, int, first, unsigned long, second,
         struct ipc_kludge tmp;
 	int ret;
 
+        trace_ipc_call(call, first);
+
         switch (call) {
         case SEMOP:
 		return sys_semtimedop(first, (struct sembuf __user *)ptr,
diff --git a/arch/s390/kernel/traps.c b/arch/s390/kernel/traps.c
index 6e7ad63..a5adc96 100644
--- a/arch/s390/kernel/traps.c
+++ b/arch/s390/kernel/traps.c
@@ -5,6 +5,7 @@
  *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
  *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com),
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/kernel/traps.c"
  *    Copyright (C) 1991, 1992 Linus Torvalds
@@ -33,6 +34,7 @@
 #include <linux/kprobes.h>
 #include <linux/bug.h>
 #include <linux/utsname.h>
+#include <trace/trap.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -71,6 +73,12 @@ static int kstack_depth_to_print = 20;
 #endif /* CONFIG_64BIT */
 
 /*
+ * Also used in fault.c.
+ */
+DEFINE_TRACE(trap_entry);
+DEFINE_TRACE(trap_exit);
+
+/*
  * For show_trace we have tree different stack to consider:
  *   - the panic stack which is used if the kernel stack has overflown
  *   - the asynchronous interrupt stack (cpu related)
@@ -349,6 +357,8 @@ static void __kprobes inline do_trap(long interruption_code, int signr,
 				interruption_code, signr) == NOTIFY_STOP)
 		return;
 
+	trace_trap_entry(regs, interruption_code & 0xffff);
+
         if (regs->psw.mask & PSW_MASK_PSTATE) {
                 struct task_struct *tsk = current;
 
@@ -369,6 +379,7 @@ static void __kprobes inline do_trap(long interruption_code, int signr,
 			die(str, regs, interruption_code);
 		}
         }
+	trace_trap_exit();
 }
 
 static inline void __user *get_check_address(struct pt_regs *regs)
@@ -479,6 +490,8 @@ static void illegal_op(struct pt_regs * regs, long interruption_code)
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
+	trace_trap_entry(regs, interruption_code & 0xffff);
+
 	if (regs->psw.mask & PSW_MASK_PSTATE) {
 		if (get_user(*((__u16 *) opcode), (__u16 __user *) location))
 			return;
@@ -543,6 +556,7 @@ static void illegal_op(struct pt_regs * regs, long interruption_code)
 		do_trap(interruption_code, signal,
 			"illegal operation", regs, &info);
 	}
+	trace_trap_exit();
 }
 
 
@@ -563,6 +577,8 @@ specification_exception(struct pt_regs * regs, long interruption_code)
         if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
+	trace_trap_entry(regs, interruption_code & 0xffff);
+
         if (regs->psw.mask & PSW_MASK_PSTATE) {
 		get_user(*((__u16 *) opcode), location);
 		switch (opcode[0]) {
@@ -607,6 +623,7 @@ specification_exception(struct pt_regs * regs, long interruption_code)
 		do_trap(interruption_code, signal, 
 			"specification exception", regs, &info);
 	}
+	trace_trap_exit();
 }
 #else
 DO_ERROR_INFO(SIGILL, "specification exception", specification_exception,
@@ -627,6 +644,8 @@ static void data_exception(struct pt_regs * regs, long interruption_code)
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
+	trace_trap_entry(regs, interruption_code & 0xffff);
+
 	if (MACHINE_HAS_IEEE)
 		asm volatile("stfpc %0" : "=m" (current->thread.fp_regs.fpc));
 
@@ -701,6 +720,7 @@ static void data_exception(struct pt_regs * regs, long interruption_code)
 		do_trap(interruption_code, signal, 
 			"data exception", regs, &info);
 	}
+	trace_trap_exit();
 }
 
 static void space_switch_exception(struct pt_regs * regs, long int_code)
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index 3040d7c..a26a662 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -5,6 +5,7 @@
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Hartmut Penner (hp@de.ibm.com)
  *               Ulrich Weigand (uweigand@de.ibm.com)
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/mm/fault.c"
  *    Copyright (C) 1995  Linus Torvalds
@@ -31,6 +32,7 @@
 #include <linux/uaccess.h>
 #include <linux/hugetlb.h>
 #include <asm/asm-offsets.h>
+#include <trace/fault.h>
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/s390_ext.h>
@@ -56,6 +58,12 @@ extern int sysctl_userprocess_debug;
 #define VM_FAULT_BADMAP		0x020000
 #define VM_FAULT_BADACCESS	0x040000
 
+DEFINE_TRACE(page_fault_entry);
+DEFINE_TRACE(page_fault_exit);
+DEFINE_TRACE(page_fault_nosem_entry);
+DEFINE_TRACE(page_fault_nosem_exit);
+
+
 static inline int notify_page_fault(struct pt_regs *regs)
 {
 	int ret = 0;
@@ -254,7 +262,10 @@ static noinline void do_fault_error(struct pt_regs *regs, long int_code,
 			/* User mode accesses just cause a SIGSEGV */
 			si_code = (fault == VM_FAULT_BADMAP) ?
 				SEGV_MAPERR : SEGV_ACCERR;
+			trace_page_fault_nosem_entry(regs, int_code & 0xffff,
+						     trans_exc_code);
 			do_sigsegv(regs, int_code, si_code, trans_exc_code);
+			trace_page_fault_nosem_exit();
 			return;
 		}
 	case VM_FAULT_BADCONTEXT:
@@ -346,8 +357,11 @@ static inline int do_exception(struct pt_regs *regs, int access,
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
+	trace_page_fault_entry(regs, error_code & 0xffff, mm, vma, address,
+			       write);
 	fault = handle_mm_fault(mm, vma, address,
 				(access == VM_WRITE) ? FAULT_FLAG_WRITE : 0);
+	trace_page_fault_exit(fault);
 	if (unlikely(fault & VM_FAULT_ERROR))
 		goto out_up;
 
-- 
1.6.5.2

