From 85154412f6a6564b22efddd7e403e204749ae0b1 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:27:00 -0400
Subject: [PATCH 196/390] lttng-ascii

---
 include/linux/ltt-tracer.h |    3 +
 ltt/Kconfig                |   10 +
 ltt/Makefile               |    1 +
 ltt/ltt-ascii.c            |  487 ++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 501 insertions(+), 0 deletions(-)
 create mode 100644 ltt/ltt-ascii.c

diff --git a/include/linux/ltt-tracer.h b/include/linux/ltt-tracer.h
index c1f0757..e2de520 100644
--- a/include/linux/ltt-tracer.h
+++ b/include/linux/ltt-tracer.h
@@ -218,6 +218,7 @@ struct ltt_trace_struct {
 	struct ltt_channel_setting *settings;
 	struct {
 		struct dentry			*trace_root;
+		struct dentry			*ascii_root;
 	} dentry;
 	struct rchan_callbacks callbacks;
 	struct kref kref; /* Each channel has a kref of the trace struct */
@@ -640,6 +641,8 @@ static inline void ltt_commit_slot(
 
 #define LTT_FLIGHT_PREFIX	"flight-"
 
+#define LTT_ASCII			"ascii"
+
 /* Tracer properties */
 #define LTT_DEFAULT_SUBBUF_SIZE_LOW	65536
 #define LTT_DEFAULT_N_SUBBUFS_LOW	2
diff --git a/ltt/Kconfig b/ltt/Kconfig
index 809dfd5..e3e4c62 100644
--- a/ltt/Kconfig
+++ b/ltt/Kconfig
@@ -201,4 +201,14 @@ config LTT_FTRACE
 	  function tracing while a trace is being taken. Typically used when the
 	  surroundings of a problem has been identified in a prior trace.
 
+config LTT_ASCII
+	bool "Linux Trace Toolkit Ascii Output (work in progress)"
+	depends on LTT_TRACER
+	depends on LTT_RELAY_ALLOC
+	depends on LTT_SERIALIZE
+	default n
+	help
+	  Output trace data in a text-formatted ascii file, presented in
+	  /mnt/debugfs/ltt/ascii/<trace name>.
+
 endif # LTT
diff --git a/ltt/Makefile b/ltt/Makefile
index 29d9c90..97a38e9 100644
--- a/ltt/Makefile
+++ b/ltt/Makefile
@@ -18,3 +18,4 @@ obj-$(CONFIG_LTT_FILTER)		+= ltt-filter.o
 obj-$(CONFIG_LTT_KPROBES)		+= ltt-kprobes.o
 obj-$(CONFIG_LTT_TRACEPROBES)		+= probes/
 obj-$(CONFIG_LTT_FTRACE)		+= ltt-ftrace.o
+obj-$(CONFIG_LTT_ASCII)			+= ltt-ascii.o
diff --git a/ltt/ltt-ascii.c b/ltt/ltt-ascii.c
new file mode 100644
index 0000000..09fa1e4
--- /dev/null
+++ b/ltt/ltt-ascii.c
@@ -0,0 +1,487 @@
+/*
+ * LTT ascii binary buffer to ascii converter.
+ *
+ * Copyright       2008 - 2009   Lai Jiangshan (laijs@cn.fujitsu.com)
+ * Copyright       2009 -        Mathieu Desnoyers mathieu.desnoyers@polymtl.ca
+ *
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+/*
+ * TODO :
+ * This file is work-in-progress. It should be adapted to the new internal API
+ * for readers. The algorithm is :
+ *
+ * sleep (for polling mode) or wait on a reader wait queue.
+ * wait for all buffers to be ready for read
+ * when ready, get subbuf (for all subbuffers)
+ * merge sort reads by timestamp
+ *  a read is done with get_offset/get_consumed to know
+ *    - Where to read
+ *    - If buffer is empty
+ *    - If buffer has reached EOF
+ * put subbuf when read ends for a subbuf
+ * while buffers are not both finalized and empty.
+ *
+ * struct ltt_relay_cpu_iter and struct ltt_relay_iter should be adapted
+ * to work on buffer "consumed/write" offsets rather than a single "offset"
+ * variable.
+ *
+ * The new debugfs file "switch_timer" receives a timer period as parameter
+ * (e.g. echo 100 > switch_timer) to activate the timer per channel. This can
+ * also be accessed through the internal API _before the trace session starts_.
+ * This timer will insure that we periodically have subbuffers to read, and
+ * therefore that the merge-sort does not wait endlessly for a subbuffer.
+ */
+
+#include <linux/module.h>
+#include <linux/ltt-tracer.h>
+#include <linux/ltt-relay.h>
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/cpu.h>
+#include <linux/fs.h>
+
+struct dentry *ltt_ascii_dir_dentry;
+EXPORT_SYMBOL_GPL(ltt_ascii_dir_dentry);
+
+/* TODO : offset high bits, no disable., use API */
+
+struct ltt_relay_cpu_iter {
+	/* cpu buffer information */
+	struct rchan_buf *buf;
+	size_t start_offset;
+	size_t eof_offset;
+
+	/* current event information */
+	struct ltt_subbuffer_header *header;
+	size_t offset;
+	u64 tsc;
+	u32 data_size;
+	u16 chID; /* channel ID, const */
+	u16 eID;
+};
+
+static u64 calculate_tsc(u64 pre_tsc, u64 read_tsc, unsigned int rflags)
+{
+	u64 new_tsc = read_tsc;
+
+	if (rflags != LTT_RFLAG_ID_SIZE_TSC) {
+		BUG_ON(read_tsc >> LTT_TSC_BITS);
+
+		new_tsc = (pre_tsc & ~LTT_TSC_MASK) + read_tsc;
+		if (read_tsc < (pre_tsc & LTT_TSC_MASK))
+			new_tsc += 1UL << LTT_TSC_BITS;
+	}
+
+	return new_tsc;
+}
+
+static inline size_t calculate_offset(size_t offset, u16 chID, u16 eID)
+{
+	const char *fmt;
+
+	if (!ltt_get_alignment())
+		return offset;
+
+	fmt = marker_get_fmt_form_id(chID, eID);
+	BUG_ON(!fmt);
+
+	return offset + ltt_fmt_largest_align(offset, fmt);
+}
+
+static void update_new_event(struct ltt_relay_cpu_iter *citer)
+{
+	u64 read_tsc;
+	unsigned int rflags;
+
+	citer->offset = ltt_read_event_header(citer->buf, citer->offset,
+			&read_tsc, &citer->data_size, &citer->eID, &rflags);
+
+	citer->offset = calculate_offset(citer->offset, citer->chID,
+			citer->eID);
+	citer->tsc = calculate_tsc(citer->tsc, read_tsc, rflags);
+}
+
+static void update_event_size(struct ltt_relay_cpu_iter *citer)
+{
+	char output[1];
+	const char *fmt;
+
+	if (citer->data_size != INT_MAX)
+		return;
+
+	fmt = marker_get_fmt_form_id(citer->chID, citer->eID);
+	BUG_ON(!fmt);
+	ltt_serialize_printf(citer->buf, citer->offset, &citer->data_size,
+			output, 0, fmt);
+}
+
+/* Is @value in the region [@left, @right) in a circular buffer */
+static int is_in_region(size_t value, size_t left, size_t right, size_t len)
+{
+	if (right < left)
+		right += len;
+	if (value < left)
+		value += len;
+	return value < right;
+}
+
+static void update_cpu_iter(struct ltt_relay_cpu_iter *citer, size_t old_offset)
+{
+	size_t len = citer->buf->chan->alloc_size;
+	size_t eof_offset = BUFFER_OFFSET(citer->eof_offset, citer->buf->chan);
+
+	if (is_in_region(eof_offset, old_offset, citer->offset, len)) {
+		citer->header = NULL;
+	} else {
+		update_new_event(citer);
+		update_event_size(citer);
+
+		if (is_in_region(eof_offset, old_offset,
+				citer->offset + citer->data_size, len))
+			citer->header = NULL;
+	}
+}
+
+static void start_new_subbuffer(struct ltt_relay_cpu_iter *citer, size_t offset)
+{
+	int index = SUBBUF_INDEX(offset, citer->buf->chan);
+	size_t head_offset = index << citer->buf->chan->subbuf_size_order;
+
+	citer->header = ltt_relay_offset_address(citer->buf, head_offset);
+	citer->offset = head_offset + ltt_subbuffer_header_size();
+	citer->tsc = citer->header->cycle_count_begin;
+}
+
+static void ltt_relay_advance_cpu_iter(struct ltt_relay_cpu_iter *citer)
+{
+	size_t old_offset = citer->offset, new_offset = citer->offset;
+	size_t sub_offset = SUBBUF_OFFSET(old_offset, citer->buf->chan);
+
+	new_offset += citer->data_size;
+
+	/* find that whether we read all data in this subbuffer */
+	if (sub_offset + citer->data_size + citer->header->lost_size
+			>= citer->buf->chan->subbuf_size) {
+		new_offset += citer->header->lost_size;
+		start_new_subbuffer(citer, new_offset);
+	} else {
+		citer->offset = new_offset + ltt_align(new_offset,
+				sizeof(struct ltt_event_header));
+	}
+
+	update_cpu_iter(citer, old_offset);
+}
+
+static void ltt_relay_reset_cpu_iter(struct ltt_relay_cpu_iter *citer)
+{
+	start_new_subbuffer(citer, citer->start_offset);
+	update_cpu_iter(citer, citer->start_offset);
+}
+
+static int cpu_iter_eof(struct ltt_relay_cpu_iter *citer)
+{
+	return !citer->header;
+}
+
+struct ltt_relay_iter {
+	struct ltt_relay_cpu_iter iter_cpu[NR_CPUS];
+	struct ltt_channel_struct *ltt_channel;
+	loff_t pos;
+	int cpu;
+};
+
+static int ltt_relay_iter_eof(struct ltt_relay_iter *iter)
+{
+	return iter->cpu < 0;
+}
+
+static void ltt_relay_advance_iter(struct ltt_relay_iter *iter)
+{
+	int i;
+	struct ltt_relay_cpu_iter *curr, *min = NULL;
+	iter->cpu = -1;
+
+	/*
+	 * find the event with the minimum tsc.
+	 * TODO: use min-heep for 4096CPUS
+	 */
+	for_each_possible_cpu(i) {
+		curr = &iter->iter_cpu[i];
+
+		if (!curr->buf)
+			continue;
+
+		if (cpu_iter_eof(curr) || cpu_iter_empty(curr))
+			continue;
+
+		if (!min || curr->tsc < min->tsc) {
+			min = curr;
+			iter->cpu = i;
+		}
+	}
+
+	/* update cpu_iter for next ltt_relay_advance_iter() */
+	if (min)
+		ltt_relay_advance_cpu_iter(min);
+
+	/* increase pos */
+	iter->pos++;
+}
+
+static void ltt_relay_start_iter(struct ltt_relay_iter *iter)
+{
+	BUG_ON(iter->pos != -1);
+
+	/* TODO: use min-heep for 4096CPUS */
+	ltt_relay_advance_iter(iter);
+}
+
+static void *ascii_next(struct seq_file *m, void *v, loff_t *ppos)
+{
+	struct ltt_relay_iter *iter = m->private;
+
+	BUG_ON(iter->pos != *ppos || v != iter);
+
+	ltt_relay_advance_iter(iter);
+	(*ppos)++;
+
+	return ltt_relay_iter_eof(iter) ? NULL : iter;
+}
+
+/*
+ * Restart iterator at the beginning of the current subbuffer.
+ */
+static void ltt_relay_reset_iter(struct ltt_relay_iter *iter)
+{
+	int i;
+
+	for_each_possible_cpu(i) {
+		if (iter->iter_cpu[i].buf)
+			ltt_relay_reset_cpu_iter(&iter->iter_cpu[i]);
+	}
+
+	ltt_relay_start_iter(iter);
+}
+
+static void *ascii_start(struct seq_file *m, loff_t *ppos)
+{
+	loff_t pos = *ppos;
+	struct ltt_relay_iter *iter = m->private;
+
+
+	if (pos != iter->pos) {
+		/* restart when read backward */
+		if (pos < iter->pos)
+			iter->pos = -1;
+
+		if (iter->pos < 0)
+			ltt_relay_reset_iter(iter);
+
+		while (!ltt_relay_iter_eof(iter) && iter->pos < pos)
+			ltt_relay_advance_iter(iter);
+	}
+
+	return ltt_relay_iter_eof(iter) ? NULL : iter;
+}
+
+static void ascii_stop(struct seq_file *m, void *v)
+{
+	/* do nothing */
+}
+
+static int seq_serialize(struct seq_file *m, struct rchan_buf *buf,
+		size_t buf_offset, const char *fmt, size_t *data_size)
+{
+	int len;
+
+	if (m->count < m->size) {
+		len = ltt_serialize_printf(buf, buf_offset, data_size,
+				m->buf + m->count, m->size - m->count, fmt);
+		if (m->count + len < m->size) {
+			m->count += len;
+			return 0;
+		}
+	}
+
+	m->count = m->size;
+	return -1;
+}
+
+static int ascii_show(struct seq_file *m, void *v)
+{
+	struct ltt_relay_iter *iter = v;
+	struct ltt_relay_cpu_iter *citer = &iter->iter_cpu[iter->cpu];
+	const char *name;
+	const char *fmt;
+	unsigned long long tsc = citer->tsc;
+	size_t *data_size;
+	data_size = citer->data_size == INT_MAX ? &citer->data_size : NULL;
+
+	name = marker_get_name_form_id(citer->chID, citer->eID);
+	fmt = marker_get_fmt_form_id(citer->chID, citer->eID);
+
+	if (!name || !fmt)
+		return 0;
+
+	seq_printf(m, "%16.16s: %2d %20.20llu ", name, iter->cpu, tsc);
+	seq_serialize(m, citer->buf, citer->offset, fmt, data_size);
+	seq_puts(m, "\n");
+
+	return 0;
+}
+
+static struct seq_operations ascii_seq_ops = {
+	.start		= ascii_start,
+	.next		= ascii_next,
+	.stop		= ascii_stop,
+	.show		= ascii_show,
+};
+
+#define get_value(ltt_chan, value, cpu)			\
+	ltt_chan->buf_access_ops->get_##value(ltt_chan->buf, cpu)
+
+/* FIXME : cpu hotplug support */
+static int ltt_relay_iter_get_channel(struct ltt_relay_iter *iter,
+		struct ltt_channel_struct *ltt_channel)
+{
+	int i;
+	struct rchan *chan = ltt_channel->trans_channel_data;
+	u16 chID = ltt_channels_get_index_from_name(ltt_channel->channel_name);
+
+	/* we don't need lock relay_channels_mutex */
+	for_each_possible_cpu(i) {
+		iter->iter_cpu[i].buf = chan->buf[i];
+		if (iter->iter_cpu[i].buf)
+			ltt_channel->buf_access_ops->open(ltt_channel->buf, i);
+		iter->iter_cpu[i].chID = chID;
+	}
+/*
+	for_each_possible_cpu(i) {
+		if (!iter->iter_cpu[i].buf)
+			continue;
+		iter->iter_cpu[i].start_offset = SUBBUF_TRUNC(
+				get_value(ltt_channel, consumed, i),
+				iter->iter_cpu[i].buf->chan);
+		iter->iter_cpu[i].eof_offset =
+				get_value(ltt_channel, offset, i);
+	}
+*/
+	return 0;
+}
+
+static int ltt_relay_iter_put_channel(struct ltt_relay_iter *iter)
+{
+	int i;
+
+	for_each_possible_cpu(i) {
+		if (iter->iter_cpu[i].buf)
+			ltt_channel->buf_access_ops->release(ltt_channel->buf,
+							     i);
+	}
+	return 0;
+}
+
+static int ltt_relay_ascii_open(struct inode *inode, struct file *file)
+{
+	int ret;
+	struct ltt_channel_struct *ltt_channel = inode->i_private;
+	struct ltt_relay_iter *iter = kmalloc(sizeof(*iter), GFP_KERNEL);
+	if (!iter)
+		return -ENOMEM;
+
+	iter->ltt_channel = ltt_channel;
+	iter->pos = -1;
+	ltt_relay_iter_get_channel(iter, ltt_channel);
+
+	ret = seq_open(file, &ascii_seq_ops);
+	if (ret) {
+		ltt_relay_iter_put_channel(iter);
+		kfree(iter);
+		return ret;
+	}
+	((struct seq_file *)file->private_data)->private = iter;
+
+	return 0;
+}
+
+static int ltt_relay_ascii_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq = file->private_data;
+	struct ltt_relay_iter *iter = seq->private;
+	ltt_relay_iter_put_channel(iter);
+	kfree(iter);
+	return 0;
+}
+
+static struct file_operations ltt_ascii_fops =
+{
+	.read = seq_read,
+	.open = ltt_relay_ascii_open,
+	.release = ltt_relay_ascii_release,
+	.owner = THIS_MODULE,
+};
+
+struct dentry *ltt_ascii_create(struct ltt_trace_struct *trace,
+		struct ltt_channel_struct *ltt_channel)
+{
+	struct dentry *entry = debugfs_create_file(ltt_channel->channel_name,
+			S_IRUSR | S_IRGRP, trace->dentry.ascii_root,
+			ltt_channel,
+			&ltt_ascii_fops);
+
+	if (entry)
+		ltt_relay_get_chan(ltt_channel->trans_channel_data);
+
+	return entry;
+}
+EXPORT_SYMBOL_GPL(ltt_ascii_create);
+
+void ltt_ascii_remove(struct ltt_channel_struct *ltt_channel,
+		struct dentry *ascii)
+{
+	if (ascii) {
+		debugfs_remove(ascii);
+		ltt_relay_put_chan(ltt_channel->trans_channel_data);
+	}
+}
+EXPORT_SYMBOL_GPL(ltt_ascii_remove);
+
+int ltt_ascii_create_dir(struct ltt_trace_struct *new_trace)
+{
+	new_trace->dentry.ascii_root = debugfs_create_dir(new_trace->trace_name,
+		ltt_ascii_dir_dentry);
+	if (!new_trace->dentry.ascii_root)
+		return -EEXIST;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ltt_ascii_create_dir);
+
+void ltt_ascii_remove_dir(struct ltt_trace_struct *trace)
+{
+	debugfs_remove(trace->dentry.ascii_root);
+}
+EXPORT_SYMBOL_GPL(ltt_ascii_remove_dir);
+
+static __init int ltt_ascii_init(void)
+{
+	ltt_ascii_dir_dentry = debugfs_create_dir(LTT_ASCII, get_ltt_root());
+
+	return ltt_ascii_dir_dentry ? 0 : -EFAULT;
+}
+
+static __exit void ltt_ascii_exit(void)
+{
+	debugfs_remove(ltt_ascii_dir_dentry);
+}
+
+module_init(ltt_ascii_init);
+module_exit(ltt_ascii_exit);
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Lai Jiangshan@FNST and Mathieu Desnoyers");
+MODULE_DESCRIPTION("Linux Trace Toolkit Next Generation Ascii Converter");
-- 
1.6.5.2

