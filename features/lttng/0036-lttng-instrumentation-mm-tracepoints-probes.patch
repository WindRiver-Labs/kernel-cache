From 8830ea4832df482a46f44cb9932c2050a830cd27 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Tue, 12 Aug 2008 10:32:23 -0400
Subject: [PATCH] lttng-instrumentation-mm-tracepoints-probes

LTTng instrumentation mm tracepoint probes

Create a module which declares mm tracepoint probes, using markers.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Alexander Viro <viro@zeniv.linux.org.uk>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Masami Hiramatsu <mhiramat@redhat.com>
---
 include/linux/swapops.h |    8 +++
 mm/Makefile             |    1 +
 mm/mm-trace.c           |  161 +++++++++++++++++++++++++++++++++++++++++++++++
 mm/swapfile.c           |    1 +
 4 files changed, 171 insertions(+), 0 deletions(-)
 create mode 100644 mm/mm-trace.c

diff --git a/include/linux/swapops.h b/include/linux/swapops.h
index 6ec39ab..fb40dac 100644
--- a/include/linux/swapops.h
+++ b/include/linux/swapops.h
@@ -76,6 +76,14 @@ static inline pte_t swp_entry_to_pte(swp_entry_t entry)
 	return __swp_entry_to_pte(arch_entry);
 }
 
+static inline swp_entry_t page_swp_entry(struct page *page)
+{
+	swp_entry_t entry;
+	VM_BUG_ON(!PageSwapCache(page));
+	entry.val = page_private(page);
+	return entry;
+}
+
 #ifdef CONFIG_MIGRATION
 static inline swp_entry_t make_migration_entry(struct page *page, int write)
 {
diff --git a/mm/Makefile b/mm/Makefile
index da4ccf0..5ddbd85 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -34,4 +34,5 @@ obj-$(CONFIG_MIGRATION) += migrate.o
 obj-$(CONFIG_SMP) += allocpercpu.o
 obj-$(CONFIG_QUICKLIST) += quicklist.o
 obj-$(CONFIG_CGROUP_MEM_RES_CTLR) += memcontrol.o
+obj-$(CONFIG_TRACEPROBES) += mm-trace.o
 
diff --git a/mm/mm-trace.c b/mm/mm-trace.c
new file mode 100644
index 0000000..1ba5130
--- /dev/null
+++ b/mm/mm-trace.c
@@ -0,0 +1,161 @@
+/*
+ * mm/mm-trace.c
+ *
+ * MM tracepoint probes.
+ */
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
+#include <linux/swapops.h>
+#include <trace/page_alloc.h>
+#include <trace/filemap.h>
+#include <trace/swap.h>
+#include <trace/memory.h>
+#include <trace/hugetlb.h>
+
+static void probe_wait_on_page_start(struct page *page, int bit_nr)
+{
+	trace_mark(mm_wait_on_page_start, "pfn %lu bit_nr %d",
+		page_to_pfn(page), bit_nr);
+}
+
+static void probe_wait_on_page_end(struct page *page, int bit_nr)
+{
+	trace_mark(mm_wait_on_page_end, "pfn %lu bit_nr %d",
+		page_to_pfn(page), bit_nr);
+}
+
+static void probe_hugetlb_page_free(struct page *page)
+{
+	trace_mark(mm_huge_page_free, "pfn %lu", page_to_pfn(page));
+}
+
+static void probe_hugetlb_page_alloc(struct page *page)
+{
+	if (page)
+		trace_mark(mm_huge_page_alloc, "pfn %lu", page_to_pfn(page));
+}
+
+static void probe_memory_handle_fault_entry(struct mm_struct *mm,
+	struct vm_area_struct *vma, unsigned long address, int write_access)
+{
+	trace_mark(mm_handle_fault_entry,
+		"address %lu ip #p%ld write_access %d",
+		address, KSTK_EIP(current), write_access);
+}
+
+static void probe_memory_handle_fault_exit(int res)
+{
+	trace_mark(mm_handle_fault_exit, "res %d", res);
+}
+
+static void probe_page_free(struct page *page, unsigned int order)
+{
+	trace_mark(mm_page_free, "order %u pfn %lu", order, page_to_pfn(page));
+}
+
+static void probe_page_alloc(struct page *page, unsigned int order)
+{
+	if (page)
+		trace_mark(mm_page_alloc, "order %u pfn %lu", order,
+			page_to_pfn(page));
+}
+
+#ifdef CONFIG_SWAP
+static void probe_swap_in(struct page *page, swp_entry_t entry)
+{
+	trace_mark(mm_swap_in, "pfn %lu filp %p offset %lu",
+		page_to_pfn(page),
+		get_swap_info_struct(swp_type(entry))->swap_file,
+		swp_offset(entry));
+}
+
+static void probe_swap_out(struct page *page)
+{
+	trace_mark(mm_swap_out, "pfn %lu filp %p offset %lu",
+		page_to_pfn(page),
+		get_swap_info_struct(swp_type(
+			page_swp_entry(page)))->swap_file,
+		swp_offset(page_swp_entry(page)));
+}
+
+static void probe_swap_file_close(struct file *file)
+{
+	trace_mark(mm_swap_file_close, "filp %p", file);
+}
+
+static void probe_swap_file_open(struct file *file, char *filename)
+{
+	trace_mark(mm_swap_file_open, "filp %p filename %s",
+		file, filename);
+}
+#endif
+
+int __init mm_trace_init(void)
+{
+	int ret;
+
+	ret = register_trace_wait_on_page_start(probe_wait_on_page_start);
+	WARN_ON(ret);
+	ret = register_trace_wait_on_page_end(probe_wait_on_page_end);
+	WARN_ON(ret);
+	ret = register_trace_hugetlb_page_free(probe_hugetlb_page_free);
+	WARN_ON(ret);
+	ret = register_trace_hugetlb_page_alloc(probe_hugetlb_page_alloc);
+	WARN_ON(ret);
+	ret = register_trace_memory_handle_fault_entry(
+		probe_memory_handle_fault_entry);
+	WARN_ON(ret);
+	ret = register_trace_memory_handle_fault_exit(
+		probe_memory_handle_fault_exit);
+	WARN_ON(ret);
+	ret = register_trace_page_free(probe_page_free);
+	WARN_ON(ret);
+	ret = register_trace_page_alloc(probe_page_alloc);
+	WARN_ON(ret);
+#ifdef CONFIG_SWAP
+	ret = register_trace_swap_in(probe_swap_in);
+	WARN_ON(ret);
+	ret = register_trace_swap_out(probe_swap_out);
+	WARN_ON(ret);
+	ret = register_trace_swap_file_close(probe_swap_file_close);
+	WARN_ON(ret);
+	ret = register_trace_swap_file_open(probe_swap_file_open);
+	WARN_ON(ret);
+#endif
+
+	return 0;
+}
+
+module_init(mm_trace_init);
+
+void __exit mm_trace_exit(void)
+{
+#ifdef CONFIG_SWAP
+	unregister_trace_swap_file_open(probe_swap_file_open);
+	unregister_trace_swap_file_close(probe_swap_file_close);
+	unregister_trace_swap_out(probe_swap_out);
+	unregister_trace_swap_in(probe_swap_in);
+#endif
+	unregister_trace_page_alloc(probe_page_alloc);
+	unregister_trace_page_free(probe_page_free);
+	unregister_trace_memory_handle_fault_exit(
+		probe_memory_handle_fault_exit);
+	unregister_trace_memory_handle_fault_entry(
+		probe_memory_handle_fault_entry);
+	unregister_trace_hugetlb_page_alloc(probe_hugetlb_page_alloc);
+	unregister_trace_hugetlb_page_free(probe_hugetlb_page_free);
+	unregister_trace_wait_on_page_end(probe_wait_on_page_end);
+	unregister_trace_wait_on_page_start(probe_wait_on_page_start);
+	tracepoint_synchronize_unregister();
+}
+
+module_exit(mm_trace_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("MM Tracepoint Probes");
diff --git a/mm/swapfile.c b/mm/swapfile.c
index 5dc052c..c9e7c95 100644
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@ -1800,6 +1800,7 @@ get_swap_info_struct(unsigned type)
 {
 	return &swap_info[type];
 }
+EXPORT_SYMBOL_GPL(get_swap_info_struct);
 
 /*
  * swap_lock prevents swap_map being freed. Don't grab an extra
-- 
1.5.5.1

