From d65049b6fa74a4912b460260d5d43a33dd3523b0 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:27:22 -0400
Subject: [PATCH 235/390] lttng-vmcore-fix-locked

LTTng vmcore fix locked

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/ltt-relay-locked.c |   22 ++++++++++++++--
 ltt/ltt-relay-locked.h |   65 ++++++++++++++++++++++++-----------------------
 2 files changed, 52 insertions(+), 35 deletions(-)

diff --git a/ltt/ltt-relay-locked.c b/ltt/ltt-relay-locked.c
index 0d14e77..d8d752c 100644
--- a/ltt/ltt-relay-locked.c
+++ b/ltt/ltt-relay-locked.c
@@ -796,6 +796,19 @@ static int ltt_relay_create_buffer(struct ltt_trace_struct *trace,
 		kfree(ltt_buf);
 		return -ENOMEM;
 	}
+
+#ifdef CONFIG_LTT_VMCORE
+	ltt_buf->commit_seq =
+		kzalloc_node(ALIGN(sizeof(ltt_buf->commit_seq) * n_subbufs,
+				   1 << INTERNODE_CACHE_SHIFT),
+			GFP_KERNEL, cpu_to_node(cpu));
+	if (!ltt_buf->commit_seq) {
+		kfree(ltt_buf->commit_count);
+		kfree(ltt_buf);
+		return -ENOMEM;
+	}
+#endif
+
 	buf->chan_private = ltt_buf;
 
 	kref_get(&trace->kref);
@@ -822,6 +835,9 @@ static void ltt_relay_destroy_buffer(struct ltt_channel_struct *ltt_chan,
 	kref_put(&ltt_chan->trace->ltt_transport_kref,
 		ltt_release_transport);
 	ltt_relay_print_buffer_errors(ltt_chan, cpu);
+#ifdef CONFIG_LTT_VMCORE
+	kfree(ltt_buf->commit_seq);
+#endif
 	kfree(ltt_buf->commit_count);
 	kfree(ltt_buf);
 	kref_put(&trace->kref, ltt_release_trace);
@@ -1173,7 +1189,7 @@ static void ltt_reserve_switch_old_subbuf(
 			>> ltt_channel->n_subbufs_order)
 			- ((offsets->commit_count - rchan->subbuf_size)
 			   & ltt_channel->commit_count_mask) == 0))
-		ltt_deliver(buf, oldidx, NULL);
+		ltt_deliver(buf, oldidx, offsets->commit_count);
 }
 
 /*
@@ -1199,7 +1215,7 @@ static void ltt_reserve_switch_new_subbuf(
 			>> ltt_channel->n_subbufs_order)
 			- ((offsets->commit_count - rchan->subbuf_size)
 			   & ltt_channel->commit_count_mask) == 0))
-		ltt_deliver(buf, beginidx, NULL);
+		ltt_deliver(buf, beginidx, offsets->commit_count);
 }
 
 /*
@@ -1238,7 +1254,7 @@ static void ltt_reserve_end_switch_current(
 			>> ltt_channel->n_subbufs_order)
 			- ((offsets->commit_count - rchan->subbuf_size)
 			   & ltt_channel->commit_count_mask) == 0))
-		ltt_deliver(buf, endidx, NULL);
+		ltt_deliver(buf, endidx, offsets->commit_count);
 }
 
 /*
diff --git a/ltt/ltt-relay-locked.h b/ltt/ltt-relay-locked.h
index 30baef7..7e0221d 100644
--- a/ltt/ltt-relay-locked.h
+++ b/ltt/ltt-relay-locked.h
@@ -73,6 +73,9 @@ struct ltt_channel_buf_struct {
 	unsigned long irqflags;		/* IRQ flags saved by reserve */
 	raw_spinlock_t lock;		/* Spinlock protecting buffer */
 	/* End of first 32 bytes cacheline */
+#ifdef CONFIG_LTT_VMCORE
+	long *commit_seq;		/* Consecutive commits */
+#endif
 	unsigned long last_tsc;		/*
 					 * Last timestamp written in the buffer.
 					 */
@@ -147,11 +150,15 @@ static __inline__ int last_tsc_overflow(struct ltt_channel_buf_struct *ltt_buf,
 }
 #endif
 
-static __inline__ void ltt_deliver(struct rchan_buf *buf, unsigned int subbuf_idx,
-		void *subbuf)
+static __inline__ void ltt_deliver(struct rchan_buf *buf,
+		unsigned int subbuf_idx,
+		long commit_count)
 {
 	struct ltt_channel_buf_struct *ltt_buf = buf->chan_private;
 
+#ifdef CONFIG_LTT_VMCORE
+	ltt_buf->commit_seq[subbuf_idx] = commit_count;
+#endif
 	ltt_buf->wakeup_readers = 1;
 }
 
@@ -284,37 +291,28 @@ static __inline__ void ltt_force_switch(struct rchan_buf *buf,
  */
 #ifdef CONFIG_LTT_VMCORE
 static __inline__ void ltt_write_commit_counter(struct rchan_buf *buf,
-		long buf_offset, size_t slot_size)
+		struct ltt_channel_buf_struct *ltt_buf,
+		long idx, long buf_offset, long commit_count, size_t data_size)
 {
-	struct ltt_channel_buf_struct *ltt_buf = buf->chan_private;
-	struct ltt_subbuffer_header *header;
-	long offset, subbuf_idx, commit_count;
-	uint32_t lost_old, lost_new;
-
-	subbuf_idx = SUBBUF_INDEX(buf_offset - 1, buf->chan);
-	offset = buf_offset + slot_size;
-	header = (struct ltt_subbuffer_header *)
-			ltt_relay_offset_address(buf,
-				subbuf_idx * buf->chan->subbuf_size);
-	for (;;) {
-		lost_old = header->lost_size;
-		commit_count = ltt_buf->commit_count[subbuf_idx];
-		/* SUBBUF_OFFSET includes commit_count_mask */
-		if (likely(!SUBBUF_OFFSET(offset - commit_count, buf->chan))) {
-			lost_new = (uint32_t)buf->chan->subbuf_size
-				   - SUBBUF_OFFSET(commit_count, buf->chan);
-			lost_old = cmpxchg_local(&header->lost_size, lost_old,
-							lost_new);
-			if (likely(lost_old <= lost_new))
-				break;
-		} else {
-			break;
-		}
-	}
+	long offset;
+
+	offset = buf_offset + data_size;
+
+	/*
+	 * SUBBUF_OFFSET includes commit_count_mask. We can simply
+	 * compare the offsets within the subbuffer without caring about
+	 * buffer full/empty mismatch because offset is never zero here
+	 * (subbuffer header and event headers have non-zero length).
+	 */
+	if (unlikely(SUBBUF_OFFSET(offset - commit_count, buf->chan)))
+		return;
+
+	ltt_buf->commit_seq[idx] = commit_count;
 }
 #else
 static __inline__ void ltt_write_commit_counter(struct rchan_buf *buf,
-		long buf_offset, size_t slot_size)
+		struct ltt_channel_buf_struct *ltt_buf,
+		long idx, long buf_offset, long commit_count, size_t data_size)
 {
 }
 #endif
@@ -328,11 +326,13 @@ static __inline__ void ltt_write_commit_counter(struct rchan_buf *buf,
  * @ltt_channel : channel structure
  * @transport_data: transport-specific data
  * @buf_offset : offset following the event header.
+ * @data_size : size of the event data.
  * @slot_size : size of the reserved slot.
  */
 static __inline__ void ltt_commit_slot(
 		struct ltt_channel_struct *ltt_channel,
-		void **transport_data, long buf_offset, size_t slot_size)
+		void **transport_data, long buf_offset,
+		size_t data_size, size_t slot_size)
 {
 	struct rchan_buf *buf = *transport_data;
 	struct ltt_channel_buf_struct *ltt_buf = buf->chan_private;
@@ -348,12 +348,13 @@ static __inline__ void ltt_commit_slot(
 			>> ltt_channel->n_subbufs_order)
 			- ((commit_count - rchan->subbuf_size)
 			   & ltt_channel->commit_count_mask) == 0))
-		ltt_deliver(buf, endidx, NULL);
+		ltt_deliver(buf, endidx, commit_count);
 	/*
 	 * Update lost_size for each commit. It's needed only for extracting
 	 * ltt buffers from vmcore, after crash.
 	 */
-	ltt_write_commit_counter(buf, buf_offset, slot_size);
+	ltt_write_commit_counter(buf, ltt_buf, endidx,
+				 buf_offset, commit_count, data_size);
 	__raw_spin_unlock(&ltt_buf->lock);
 	raw_local_irq_restore(ltt_buf->irqflags);
 }
-- 
1.6.5.2

