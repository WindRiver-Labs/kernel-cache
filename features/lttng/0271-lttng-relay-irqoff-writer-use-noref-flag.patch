From a81c0a300b08e9d9512ba45c3d6a134a2301179c Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:27:43 -0400
Subject: [PATCH 271/391] lttng-relay-irqoff-writer-use-noref-flag

LTTng relay irqoff use noref flag

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/ltt-relay-irqoff.c |   27 ++++++++++++++++++++++++---
 ltt/ltt-relay-irqoff.h |   35 +++++++++++++++++++++++++----------
 2 files changed, 49 insertions(+), 13 deletions(-)

diff --git a/ltt/ltt-relay-irqoff.c b/ltt/ltt-relay-irqoff.c
index 8abf61d..fcd755d 100644
--- a/ltt/ltt-relay-irqoff.c
+++ b/ltt/ltt-relay-irqoff.c
@@ -307,6 +307,11 @@ static int get_subbuf(struct rchan_buf *buf, unsigned long *consumed)
 	   == 0) {
 		return -EAGAIN;
 	}
+
+	/* No page exchange, use the writer page directly */
+	buf->rchan_rsb.pages = buf->rchan_wsb[consumed_idx].pages;
+	RCHAN_SB_CLEAR_NOREF(buf->rchan_rsb.pages);
+
 	*consumed = consumed_old;
 	return 0;
 }
@@ -320,6 +325,7 @@ static int put_subbuf(struct rchan_buf *buf, unsigned long consumed)
 
 	consumed_old = consumed;
 	consumed_new = SUBBUF_ALIGN(consumed_old, buf->chan);
+	RCHAN_SB_SET_NOREF(buf->rchan_rsb.pages);
 
 	spin_lock(&ltt_buf->full_lock);
 	if (atomic_long_cmpxchg(&ltt_buf->consumed, consumed_old,
@@ -871,6 +877,7 @@ static int ltt_relay_create_buffer(struct ltt_trace_struct *trace,
 	init_waitqueue_head(&ltt_buf->read_wait);
 	spin_lock_init(&ltt_buf->full_lock);
 
+	RCHAN_SB_CLEAR_NOREF(buf->rchan_wsb[0].pages);
 	ltt_buffer_begin(buf, trace->start_tsc, 0);
 	/* atomic_add made on local variable on data that belongs to
 	 * various CPUs : ok because tracing not started (for this cpu). */
@@ -1398,16 +1405,22 @@ void ltt_force_switch_irqoff_slow(struct rchan_buf *buf,
 	/*
 	 * Push the reader if necessary
 	 */
-	if (mode == FORCE_ACTIVE)
+	if (mode == FORCE_ACTIVE) {
 		ltt_reserve_push_reader(ltt_channel, ltt_buf, rchan,
 					buf, &offsets);
+		ltt_clear_noref_flag(rchan, buf, SUBBUF_INDEX(offsets.end - 1,
+							      rchan));
+	}
 
 	/*
 	 * Switch old subbuffer if needed.
 	 */
-	if (offsets.end_switch_old)
+	if (offsets.end_switch_old) {
+		ltt_clear_noref_flag(rchan, buf, SUBBUF_INDEX(offsets.old - 1,
+							      rchan));
 		ltt_reserve_switch_old_subbuf(ltt_channel, ltt_buf, rchan, buf,
 			&offsets, &tsc);
+	}
 
 	/*
 	 * Populate new subbuffer.
@@ -1586,11 +1599,19 @@ int ltt_reserve_slot_irqoff_slow(struct ltt_trace_struct *trace,
 	ltt_reserve_push_reader(ltt_channel, ltt_buf, rchan, buf, &offsets);
 
 	/*
+	 * Clear noref flag for this subbuffer.
+	 */
+	ltt_clear_noref_flag(rchan, buf, SUBBUF_INDEX(offsets.end - 1, rchan));
+
+	/*
 	 * Switch old subbuffer if needed.
 	 */
-	if (unlikely(offsets.end_switch_old))
+	if (unlikely(offsets.end_switch_old)) {
+		ltt_clear_noref_flag(rchan, buf, SUBBUF_INDEX(offsets.old - 1,
+							      rchan));
 		ltt_reserve_switch_old_subbuf(ltt_channel, ltt_buf, rchan, buf,
 			&offsets, tsc);
+	}
 
 	/*
 	 * Populate new subbuffer.
diff --git a/ltt/ltt-relay-irqoff.h b/ltt/ltt-relay-irqoff.h
index 4e45d7f..97fbb32 100644
--- a/ltt/ltt-relay-irqoff.h
+++ b/ltt/ltt-relay-irqoff.h
@@ -161,6 +161,20 @@ static __inline__ int last_tsc_overflow(struct ltt_channel_buf_struct *ltt_buf,
 #endif
 
 #ifdef CONFIG_LTT_VMCORE
+static __inline__ void ltt_vmcore_check_deliver(
+		struct ltt_channel_buf_struct *ltt_buf,
+		long commit_count, long idx)
+{
+	local_set(&ltt_buf->commit_seq[idx], commit_count);
+}
+#else
+static __inline__ void ltt_vmcore_check_deliver(
+		struct ltt_channel_buf_struct *ltt_buf,
+		long commit_count, long idx)
+{
+}
+#endif
+
 static __inline__ void ltt_check_deliver(struct ltt_channel_struct *ltt_channel,
 		struct ltt_channel_buf_struct *ltt_buf,
 		struct rchan *rchan,
@@ -172,18 +186,14 @@ static __inline__ void ltt_check_deliver(struct ltt_channel_struct *ltt_channel,
 			>> ltt_channel->n_subbufs_order)
 			- ((commit_count - rchan->subbuf_size)
 			   & ltt_channel->commit_count_mask) == 0)) {
-		local_set(&ltt_buf->commit_seq[idx], commit_count);
+		/*
+		 * Set noref flag for this subbuffer.
+		 */
+		ltt_set_noref_flag(rchan, buf, idx);
+		ltt_vmcore_check_deliver(ltt_buf, commit_count, idx);
 	}
 }
-#else
-static __inline__ void ltt_check_deliver(struct ltt_channel_struct *ltt_channel,
-		struct ltt_channel_buf_struct *ltt_buf,
-		struct rchan *rchan,
-		struct rchan_buf *buf,
-		long offset, long commit_count, long idx)
-{
-}
-#endif
+
 
 static __inline__ int ltt_poll_deliver(struct ltt_channel_struct *ltt_channel,
 		struct ltt_channel_buf_struct *ltt_buf,
@@ -321,6 +331,11 @@ static __inline__ int ltt_reserve_slot(struct ltt_trace_struct *trace,
 	 */
 	save_last_tsc(ltt_buf, *tsc);
 
+	/*
+	 * Clear noref flag for this subbuffer.
+	 */
+	ltt_clear_noref_flag(rchan, buf, SUBBUF_INDEX(o_end - 1, rchan));
+
 	*buf_offset = o_begin + before_hdr_pad;
 	return 0;
 slow_path:
-- 
1.6.5.2

