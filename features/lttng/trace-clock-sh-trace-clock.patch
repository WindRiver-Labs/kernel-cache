From 21d7c241dfc2d8d2068c9a24a9872e099937c15b Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:25:15 -0400
Subject: [PATCH 015/391] trace-clock/sh-trace-clock

LTTng timestamp sh

This patch adds the timestamping mechanism in the trace-clock.h arch header
file. The new timestamp functions use the TMU channel 1.

This code only works if the TMU channel 1 is initialized during the kernel boot.

Big fat warning(TM) from Mathieu Desnoyers :

This patch seems to assume TMU channel 1 is setup at boot. Is it always true on
all SuperH boards ? Is there some Kconfig selection that should be done here ?
Make sure this patch does not break get_cycles on SuperH before merging.

Second warning:
Hopefully, new 2.6.33 ifdefs are deprecated by the lttng implementation.

Includes:
sh: fixed a wrong header path into the architecture timex file
renamed trace_clock_get_timestamp<XX> as trace_clock_read<XX>

From: Giuseppe Cavallaro <peppe.cavallaro@st.com>
Signed-off-by: Giuseppe Cavallaro <peppe.cavallaro@st.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Paul Mundt <lethal@linux-sh.org>
CC: linux-sh@vger.kernel.org
---
 arch/sh/Kconfig                   |    2 +
 arch/sh/include/asm/timex.h       |   15 +++++++++
 arch/sh/include/asm/trace-clock.h |   58 +++++++++++++++++++++++++++++++++++++
 3 files changed, 75 insertions(+), 0 deletions(-)
 create mode 100644 arch/sh/include/asm/trace-clock.h

diff --git a/arch/sh/Kconfig b/arch/sh/Kconfig
index 8d90564..4274bbc 100644
--- a/arch/sh/Kconfig
+++ b/arch/sh/Kconfig
@@ -12,6 +12,8 @@ config SUPERH
 	select HAVE_IDE
 	select HAVE_LMB
 	select HAVE_OPROFILE
+	select HAVE_TRACE_CLOCK
+	select HAVE_TRACE_CLOCK_32_TO_64
 	select HAVE_GENERIC_DMA_COHERENT
 	select HAVE_ARCH_TRACEHOOK
 	select HAVE_DMA_API_DEBUG
diff --git a/arch/sh/include/asm/timex.h b/arch/sh/include/asm/timex.h
index 18bf06d..5249bee 100644
--- a/arch/sh/include/asm/timex.h
+++ b/arch/sh/include/asm/timex.h
@@ -12,6 +12,8 @@
  * can be used for accurately setting CLOCK_TICK_RATE, otherwise we
  * simply fall back on the i8253 PIT value.
  */
+
+#if 0
 #ifdef CONFIG_SH_PCLK_FREQ
 #define CLOCK_TICK_RATE		(CONFIG_SH_PCLK_FREQ / 4) /* Underlying HZ */
 #else
@@ -19,5 +21,18 @@
 #endif
 
 #include <asm-generic/timex.h>
+#endif //0
+
+#include <linux/io.h>
+#include <cpu/timer.h>
+
+#define CLOCK_TICK_RATE               (HZ * 100000UL)
+
+typedef unsigned long long cycles_t;
+
+static __inline__ cycles_t get_cycles (void)
+{
+	return 0xffffffff - ctrl_inl(TMU1_TCNT);
+}
 
 #endif /* __ASM_SH_TIMEX_H */
diff --git a/arch/sh/include/asm/trace-clock.h b/arch/sh/include/asm/trace-clock.h
new file mode 100644
index 0000000..d892179
--- /dev/null
+++ b/arch/sh/include/asm/trace-clock.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2007,2008 Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *                         Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ *
+ * Trace clock definitions for SuperH.
+ */
+
+#ifndef _ASM_SH_TRACE_CLOCK_H
+#define _ASM_SH_TRACE_CLOCK_H
+
+#include <linux/timer.h>
+#include <asm/clock.h>
+
+extern u64 trace_clock_read_synthetic_tsc(void);
+
+static inline u32 trace_clock_get_read32(void)
+{
+	return get_cycles();
+}
+
+static inline u64 trace_clock_get_read64(void)
+{
+	return trace_clock_read_synthetic_tsc();
+}
+
+static inline u64 trace_clock_frequency(void)
+{
+	u64 rate;
+	struct clk *tmu1_clk;
+
+	tmu1_clk = clk_get(NULL, "tmu1_clk");
+	rate = clk_get_rate(tmu1_clk);
+
+	return rate;
+}
+
+static inline u32 trace_clock_freq_scale(void)
+{
+	return 1;
+}
+
+extern void get_synthetic_tsc(void);
+extern void put_synthetic_tsc(void);
+
+static inline void get_trace_clock(void)
+{
+	get_synthetic_tsc();
+}
+
+static inline void put_trace_clock(void)
+{
+	put_synthetic_tsc();
+}
+
+static inline void set_trace_clock_is_sync(int state)
+{
+}
+#endif /* _ASM_SH_TRACE_CLOCK_H */
-- 
1.6.5.2

