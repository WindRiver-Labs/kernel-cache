From cc06b2a6c3f743fd883c7f6f40e3d75901a5cb67 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:25:35 -0400
Subject: [PATCH 048/391] LTTng-fix-for-PREEMPT_RT-kernels

LTTng fix for PREEMPT_RT kernels

Fix BUG in RT preempt kernel caused by spinlocks taken within preempt disable
region.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 ltt/ltt-tracer.c |   16 ++++++++++++++++
 1 files changed, 16 insertions(+), 0 deletions(-)

diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index 92c4d4f..e9c926d 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -376,11 +376,27 @@ static void trace_async_wakeup(struct ltt_trace_struct *trace)
 static void async_wakeup(unsigned long data)
 {
 	struct ltt_trace_struct *trace;
+
+	/*
+	 * PREEMPT_RT does not allow spinlocks to be taken within preempt
+	 * disable sections (spinlock taken in wake_up). However, mainline won't
+	 * allow mutex to be taken in interrupt context. Ugly.
+	 * A proper way to do this would be to turn the timer into a
+	 * periodically woken up thread, but it adds to the footprint.
+	 */
+#ifndef CONFIG_PREEMPT_RT
 	rcu_read_lock_sched();
+#else
+	ltt_lock_traces();
+#endif
 	list_for_each_entry_rcu(trace, &ltt_traces.head, list) {
 		trace_async_wakeup(trace);
 	}
+#ifndef CONFIG_PREEMPT_RT
 	rcu_read_unlock_sched();
+#else
+	ltt_unlock_traces();
+#endif
 
 	mod_timer(&ltt_async_wakeup_timer, jiffies + LTT_PERCPU_TIMER_INTERVAL);
 }
-- 
1.6.5.2

