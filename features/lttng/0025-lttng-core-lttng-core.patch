From 16e41a41e92adea87d59af9d219fbf7a48788348 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:25:22 -0400
Subject: [PATCH 025/391] lttng-core/lttng-core

LTTng - core data structures

Home of the traces data structures. Needs to be built into the kernel.

LTT heartbeat is a module specialized into firing periodical interrupts to
record events in traces (so cycle counter rollover can be detected) and to
update the 64 bits "synthetic TSC" (extended from the CPU 32 bits TSC on MIPS).
Also needs to be built into the kernel.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 MAINTAINERS    |    7 ++++
 ltt/ltt-core.c |  101 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 108 insertions(+), 0 deletions(-)
 create mode 100644 ltt/ltt-core.c

diff --git a/MAINTAINERS b/MAINTAINERS
index d329b05..ae22bdd 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -3476,6 +3476,13 @@ L:	lm-sensors@lm-sensors.org
 S:	Maintained
 F:	drivers/hwmon/lm73.c
 
+LINUX TRACE TOOLKIT NEXT GENERATION
+P:	Mathieu Desnoyers
+M:	mathieu.desnoyers@polymtl.ca
+L:	ltt-dev@lttng.org
+W:	http://ltt.polymtl.ca
+S:	Maintained
+
 LM83 HARDWARE MONITOR DRIVER
 M:	Jean Delvare <khali@linux-fr.org>
 L:	lm-sensors@lm-sensors.org
diff --git a/ltt/ltt-core.c b/ltt/ltt-core.c
new file mode 100644
index 0000000..37436b6
--- /dev/null
+++ b/ltt/ltt-core.c
@@ -0,0 +1,101 @@
+/*
+ * LTT core in-kernel infrastructure.
+ *
+ * Copyright 2006 - Mathieu Desnoyers mathieu.desnoyers@polymtl.ca
+ *
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/ltt-core.h>
+#include <linux/percpu.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/kref.h>
+
+/* Traces structures */
+struct ltt_traces ltt_traces = {
+	.setup_head = LIST_HEAD_INIT(ltt_traces.setup_head),
+	.head = LIST_HEAD_INIT(ltt_traces.head),
+};
+EXPORT_SYMBOL(ltt_traces);
+
+/* Traces list writer locking */
+static DEFINE_MUTEX(ltt_traces_mutex);
+
+/* root dentry mutex */
+static DEFINE_MUTEX(ltt_root_mutex);
+/* dentry of ltt's root dir */
+static struct dentry *ltt_root_dentry;
+static struct kref ltt_root_kref = {
+	.refcount = ATOMIC_INIT(0),
+};
+
+static void ltt_root_release(struct kref *ref)
+{
+	debugfs_remove(ltt_root_dentry);
+	ltt_root_dentry = NULL;
+}
+
+void put_ltt_root(void)
+{
+	mutex_lock(&ltt_root_mutex);
+	if (ltt_root_dentry)
+		kref_put(&ltt_root_kref, ltt_root_release);
+	mutex_unlock(&ltt_root_mutex);
+}
+EXPORT_SYMBOL_GPL(put_ltt_root);
+
+struct dentry *get_ltt_root(void)
+{
+	mutex_lock(&ltt_root_mutex);
+	if (!ltt_root_dentry) {
+		ltt_root_dentry = debugfs_create_dir(LTT_ROOT, NULL);
+		if (!ltt_root_dentry) {
+			printk(KERN_ERR "LTT : create ltt root dir failed\n");
+			goto out;
+		}
+		kref_init(&ltt_root_kref);
+		goto out;
+	}
+	kref_get(&ltt_root_kref);
+out:
+	mutex_unlock(&ltt_root_mutex);
+	return ltt_root_dentry;
+}
+EXPORT_SYMBOL_GPL(get_ltt_root);
+
+void ltt_lock_traces(void)
+{
+	mutex_lock(&ltt_traces_mutex);
+}
+EXPORT_SYMBOL_GPL(ltt_lock_traces);
+
+void ltt_unlock_traces(void)
+{
+	mutex_unlock(&ltt_traces_mutex);
+}
+EXPORT_SYMBOL_GPL(ltt_unlock_traces);
+
+DEFINE_PER_CPU(unsigned int, ltt_nesting);
+EXPORT_PER_CPU_SYMBOL(ltt_nesting);
+
+int ltt_run_filter_default(void *trace, uint16_t eID)
+{
+	return 1;
+}
+
+/* This function pointer is protected by a trace activation check */
+ltt_run_filter_functor ltt_run_filter = ltt_run_filter_default;
+EXPORT_SYMBOL_GPL(ltt_run_filter);
+
+void ltt_filter_register(ltt_run_filter_functor func)
+{
+	ltt_run_filter = func;
+}
+EXPORT_SYMBOL_GPL(ltt_filter_register);
+
+void ltt_filter_unregister(void)
+{
+	ltt_run_filter = ltt_run_filter_default;
+}
+EXPORT_SYMBOL_GPL(ltt_filter_unregister);
-- 
1.6.5.2

