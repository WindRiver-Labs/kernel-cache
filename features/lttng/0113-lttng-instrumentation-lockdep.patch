From ebd5c04d26493b333cfaaad2c967454d284808c1 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 2 Oct 2008 14:36:26 -0400
Subject: [PATCH] lttng-instrumentation-lockdep

LTTng instrumentation lockdep tracepoints

lockdep_hardirqs_off
lockdep_hardirqs_on
lockdep_lock_acquire
lockdep_lock_release
lockdep_softirqs_off
lockdep_softirqs_on

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/trace/lockdep.h |   33 +++++++++++++++++++++++++++++++++
 kernel/lockdep.c        |   14 ++++++++++++++
 2 files changed, 47 insertions(+), 0 deletions(-)
 create mode 100644 include/trace/lockdep.h

diff --git a/include/trace/lockdep.h b/include/trace/lockdep.h
new file mode 100644
index 0000000..fa486ed
--- /dev/null
+++ b/include/trace/lockdep.h
@@ -0,0 +1,33 @@
+#ifndef _TRACE_LOCKDEP_H
+#define _TRACE_LOCKDEP_H
+
+#include <linux/tracepoint.h>
+
+/*
+ * lockdep tracing must be very careful with respect to reentrancy.
+ *
+ * It should not use immediate values for activation because it involves
+ * traps called when the code patching is done.
+ */
+DEFINE_TRACE(lockdep_hardirqs_on,
+	TPPROTO(unsigned long retaddr),
+		TPARGS(retaddr));
+DEFINE_TRACE(lockdep_hardirqs_off,
+	TPPROTO(unsigned long retaddr),
+		TPARGS(retaddr));
+DEFINE_TRACE(lockdep_softirqs_on,
+	TPPROTO(unsigned long retaddr),
+		TPARGS(retaddr));
+DEFINE_TRACE(lockdep_softirqs_off,
+	TPPROTO(unsigned long retaddr),
+		TPARGS(retaddr));
+DEFINE_TRACE(lockdep_lock_acquire,
+	TPPROTO(unsigned long retaddr, unsigned int subclass,
+			struct lockdep_map *lock, int trylock, int read,
+			int hardirqs_off),
+		TPARGS(retaddr, subclass, lock, trylock, read, hardirqs_off));
+DEFINE_TRACE(lockdep_lock_release,
+	TPPROTO(unsigned long retaddr, struct lockdep_map *lock, int nested),
+		TPARGS(retaddr, lock, nested));
+
+#endif
diff --git a/kernel/lockdep.c b/kernel/lockdep.c
index dbda475..4f8093e 100644
--- a/kernel/lockdep.c
+++ b/kernel/lockdep.c
@@ -40,6 +40,7 @@
 #include <linux/utsname.h>
 #include <linux/hash.h>
 #include <linux/ftrace.h>
+#include <trace/lockdep.h>
 
 #include <asm/sections.h>
 
@@ -2176,6 +2177,8 @@ void trace_hardirqs_on_caller(unsigned long a0)
 
 	time_hardirqs_on(CALLER_ADDR0, a0);
 
+	_trace_lockdep_hardirqs_on(a0);
+
 	if (unlikely(!debug_locks || current->lockdep_recursion))
 		return;
 
@@ -2230,6 +2233,8 @@ void trace_hardirqs_off_caller(unsigned long a0)
 
 	time_hardirqs_off(CALLER_ADDR0, a0);
 
+	_trace_lockdep_hardirqs_off(a0);
+
 	if (unlikely(!debug_locks || current->lockdep_recursion))
 		return;
 
@@ -2262,6 +2267,8 @@ void trace_softirqs_on(unsigned long ip)
 {
 	struct task_struct *curr = current;
 
+	_trace_lockdep_softirqs_on(ip);
+
 	if (unlikely(!debug_locks))
 		return;
 
@@ -2296,6 +2303,8 @@ void trace_softirqs_off(unsigned long ip)
 {
 	struct task_struct *curr = current;
 
+	_trace_lockdep_softirqs_off(ip);
+
 	if (unlikely(!debug_locks))
 		return;
 
@@ -2528,6 +2537,9 @@ static int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,
 	int chain_head = 0;
 	u64 chain_key;
 
+	_trace_lockdep_lock_acquire(ip, subclass, lock, trylock, read,
+		hardirqs_off);
+
 	if (!prove_locking)
 		check = 1;
 
@@ -2852,6 +2864,8 @@ __lock_release(struct lockdep_map *lock, int nested, unsigned long ip)
 {
 	struct task_struct *curr = current;
 
+	_trace_lockdep_lock_release(ip, lock, nested);
+
 	if (!check_unlock(curr, lock, ip))
 		return;
 
-- 
1.5.5.1

