From ced876ec2934741d0732cedea52978b2c71cdccb Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Tue, 12 Aug 2008 10:32:21 -0400
Subject: [PATCH] lttng-instrumentation-kernel-tracepoints-probes

LTTng instrumentation kernel tracepoint probes

Create a module which declares kernel tracepoint probes, using markers.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Alexander Viro <viro@zeniv.linux.org.uk>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Masami Hiramatsu <mhiramat@redhat.com>
---
 kernel/Makefile       |    1 +
 kernel/kernel-trace.c |  348 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 349 insertions(+), 0 deletions(-)
 create mode 100644 kernel/kernel-trace.c

diff --git a/kernel/Makefile b/kernel/Makefile
index e02ab18..89c9f22 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -86,6 +86,7 @@ obj-$(CONFIG_TASK_DELAY_ACCT) += delayacct.o
 obj-$(CONFIG_TASKSTATS) += taskstats.o tsacct.o
 obj-$(CONFIG_MARKERS) += marker.o
 obj-$(CONFIG_TRACEPOINTS) += tracepoint.o
+obj-$(CONFIG_TRACEPROBES) += kernel-trace.o
 obj-$(CONFIG_LATENCYTOP) += latencytop.o
 obj-$(CONFIG_HAVE_GENERIC_DMA_COHERENT) += dma-coherent.o
 obj-$(CONFIG_FTRACE) += trace/
diff --git a/kernel/kernel-trace.c b/kernel/kernel-trace.c
new file mode 100644
index 0000000..5d0bb93
--- /dev/null
+++ b/kernel/kernel-trace.c
@@ -0,0 +1,348 @@
+/*
+ * kernel/kernel-trace.c
+ *
+ * kernel tracepoint probes.
+ */
+
+#include <linux/module.h>
+#include <trace/irq.h>
+#include <trace/sched.h>
+#include <trace/timer.h>
+#include <trace/kernel.h>
+
+static void probe_irq_entry(unsigned int id, struct pt_regs *regs)
+{
+	trace_mark(kernel_irq_entry,
+		"irq_id %u kernel_mode %u ip %lu",
+		id, (regs)?(!user_mode(regs)):(1),
+		(regs)?instruction_pointer(regs):0UL);
+}
+
+static void probe_irq_exit(irqreturn_t retval)
+{
+	trace_mark(kernel_irq_exit, "handled #1u%u", IRQ_RETVAL(retval));
+}
+
+static void probe_irq_softirq_entry(struct softirq_action *h,
+	struct softirq_action *softirq_vec)
+{
+	trace_mark(kernel_softirq_entry, "softirq_id %lu",
+		((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h));
+}
+
+static void probe_irq_softirq_exit(struct softirq_action *h,
+	struct softirq_action *softirq_vec)
+{
+	trace_mark(kernel_softirq_exit, "softirq_id %lu",
+		((unsigned long)h - (unsigned long)softirq_vec) / sizeof(*h));
+}
+
+static void probe_irq_softirq_raise(unsigned int nr)
+{
+	trace_mark(kernel_softirq_raise, "softirq_id %u", nr);
+}
+
+static void probe_irq_tasklet_low_entry(struct tasklet_struct *t)
+{
+	trace_mark(kernel_tasklet_low_entry, "func %p data %lu",
+		t->func, t->data);
+}
+
+static void probe_irq_tasklet_low_exit(struct tasklet_struct *t)
+{
+	trace_mark(kernel_tasklet_low_exit, "func %p data %lu",
+		t->func, t->data);
+}
+
+static void probe_irq_tasklet_high_entry(struct tasklet_struct *t)
+{
+	trace_mark(kernel_tasklet_high_entry, "func %p data %lu",
+		t->func, t->data);
+}
+
+static void probe_irq_tasklet_high_exit(struct tasklet_struct *t)
+{
+	trace_mark(kernel_tasklet_high_exit, "func %p data %lu",
+		t->func, t->data);
+}
+
+static void probe_sched_kthread_stop(struct task_struct *t)
+{
+	trace_mark(kernel_kthread_stop, "pid %d", t->pid);
+}
+
+static void probe_sched_kthread_stop_ret(int ret)
+{
+	trace_mark(kernel_kthread_stop_ret, "ret %d", ret);
+}
+
+static void probe_sched_wait_task(struct rq *rq, struct task_struct *p)
+{
+	trace_mark(kernel_sched_wait_task, "pid %d state %ld",
+		p->pid, p->state);
+}
+
+static void probe_sched_wakeup(struct rq *rq, struct task_struct *p)
+{
+	trace_mark(kernel_sched_try_wakeup, "pid %d state %ld",
+		p->pid, p->state);
+}
+
+static void probe_sched_wakeup_new(struct rq *rq, struct task_struct *p)
+{
+	trace_mark(kernel_sched_wakeup_new_task, "pid %d state %ld",
+		p->pid, p->state);
+}
+
+static void probe_sched_switch(struct rq *rq, struct task_struct *prev,
+		struct task_struct *next)
+{
+	trace_mark(kernel_sched_schedule,
+		"prev_pid %d next_pid %d prev_state %ld",
+		prev->pid, next->pid, prev->state);
+}
+
+static void probe_sched_migrate_task(struct rq *rq, struct task_struct *p,
+		int dest_cpu)
+{
+	trace_mark(kernel_sched_migrate_task, "pid %d state %ld dest_cpu %d",
+		p->pid, p->state, dest_cpu);
+}
+
+static void probe_sched_signal_send(int sig, struct task_struct *p)
+{
+	trace_mark(kernel_send_signal, "pid %d signal %d", p->pid, sig);
+}
+
+static void probe_sched_process_free(struct task_struct *p)
+{
+	trace_mark(kernel_process_free, "pid %d", p->pid);
+}
+
+static void probe_sched_process_exit(struct task_struct *p)
+{
+	trace_mark(kernel_process_exit, "pid %d", p->pid);
+}
+
+static void probe_sched_process_wait(struct pid *pid)
+{
+	trace_mark(kernel_process_wait, "pid %d", pid_nr(pid));
+}
+
+static void probe_sched_process_fork(struct task_struct *parent,
+		struct task_struct *child)
+{
+	trace_mark(kernel_process_fork,
+		"parent_pid %d child_pid %d child_tgid %d",
+		parent->pid, child->pid, child->tgid);
+}
+
+static void probe_timer_itimer_expired(struct signal_struct *sig)
+{
+	trace_mark(kernel_timer_itimer_expired, "pid %d",
+		pid_nr(sig->leader_pid));
+}
+
+static void probe_timer_itimer_set(int which, struct itimerval *value)
+{
+	trace_mark(kernel_timer_itimer_set,
+		"which %d interval_sec %ld interval_usec %ld "
+		"value_sec %ld value_usec %ld",
+		which,
+		value->it_interval.tv_sec,
+		value->it_interval.tv_usec,
+		value->it_value.tv_sec,
+		value->it_value.tv_usec);
+}
+
+static void probe_timer_set(struct timer_list *timer)
+{
+	trace_mark(kernel_timer_set, "expires %lu function %p data %lu",
+		timer->expires, timer->function, timer->data);
+}
+
+static void probe_timer_update_time(struct timespec *_xtime,
+		struct timespec *_wall_to_monotonic)
+{
+	trace_mark(kernel_timer_update_time,
+		"jiffies #8u%llu xtime_sec %ld xtime_nsec %ld "
+		"walltomonotonic_sec %ld walltomonotonic_nsec %ld",
+		(unsigned long long)jiffies_64, _xtime->tv_sec, _xtime->tv_nsec,
+		_wall_to_monotonic->tv_sec, _wall_to_monotonic->tv_nsec);
+}
+
+static void probe_timer_timeout(struct task_struct *p)
+{
+	trace_mark(kernel_timer_timeout, "pid %d", p->pid);
+}
+
+static void probe_kernel_printk(unsigned long retaddr)
+{
+	trace_mark(kernel_printk, "ip %lu", retaddr);
+}
+
+static void probe_kernel_vprintk(unsigned long retaddr, char *buf, int len)
+{
+	if (len > 0) {
+		unsigned int loglevel;
+		int mark_len;
+		char *mark_buf;
+		char saved_char;
+
+		if (buf[0] == '<' && buf[1] >= '0' &&
+		   buf[1] <= '7' && buf[2] == '>') {
+			loglevel = buf[1] - '0';
+			mark_buf = &buf[3];
+			mark_len = len - 3;
+		} else {
+			loglevel = default_message_loglevel;
+			mark_buf = buf;
+			mark_len = len;
+		}
+		if (mark_buf[mark_len - 1] == '\n')
+			mark_len--;
+		saved_char = mark_buf[mark_len];
+		mark_buf[mark_len] = '\0';
+		trace_mark(kernel_vprintk, "loglevel %c string %s ip %lu",
+			loglevel, mark_buf, retaddr);
+		mark_buf[mark_len] = saved_char;
+	}
+}
+
+static void probe_kernel_module_free(struct module *mod)
+{
+	trace_mark(kernel_module_free, "name %s", mod->name);
+}
+
+static void probe_kernel_module_load(struct module *mod)
+{
+	trace_mark(kernel_module_load, "name %s", mod->name);
+}
+
+int __init kernel_trace_init(void)
+{
+	int ret;
+
+	ret = register_trace_irq_entry(probe_irq_entry);
+	WARN_ON(ret);
+	ret = register_trace_irq_exit(probe_irq_exit);
+	WARN_ON(ret);
+	ret = register_trace_irq_softirq_entry(probe_irq_softirq_entry);
+	WARN_ON(ret);
+	ret = register_trace_irq_softirq_exit(probe_irq_softirq_exit);
+	WARN_ON(ret);
+	ret = register_trace_irq_softirq_raise(probe_irq_softirq_raise);
+	WARN_ON(ret);
+	ret = register_trace_irq_tasklet_low_entry(
+		probe_irq_tasklet_low_entry);
+	WARN_ON(ret);
+	ret = register_trace_irq_tasklet_low_exit(probe_irq_tasklet_low_exit);
+	WARN_ON(ret);
+	ret = register_trace_irq_tasklet_high_entry(
+		probe_irq_tasklet_high_entry);
+	WARN_ON(ret);
+	ret = register_trace_irq_tasklet_high_exit(
+		probe_irq_tasklet_high_exit);
+	WARN_ON(ret);
+
+	ret = register_trace_sched_kthread_stop(probe_sched_kthread_stop);
+	WARN_ON(ret);
+	ret = register_trace_sched_kthread_stop_ret(
+		probe_sched_kthread_stop_ret);
+	WARN_ON(ret);
+	ret = register_trace_sched_wait_task(probe_sched_wait_task);
+	WARN_ON(ret);
+	ret = register_trace_sched_wakeup(probe_sched_wakeup);
+	WARN_ON(ret);
+	ret = register_trace_sched_wakeup_new(
+		probe_sched_wakeup_new);
+	WARN_ON(ret);
+	ret = register_trace_sched_switch(probe_sched_switch);
+	WARN_ON(ret);
+	ret = register_trace_sched_migrate_task(probe_sched_migrate_task);
+	WARN_ON(ret);
+	ret = register_trace_sched_signal_send(probe_sched_signal_send);
+	WARN_ON(ret);
+	ret = register_trace_sched_process_free(probe_sched_process_free);
+	WARN_ON(ret);
+	ret = register_trace_sched_process_exit(probe_sched_process_exit);
+	WARN_ON(ret);
+	ret = register_trace_sched_process_wait(probe_sched_process_wait);
+	WARN_ON(ret);
+	ret = register_trace_sched_process_fork(probe_sched_process_fork);
+	WARN_ON(ret);
+
+	ret = register_trace_timer_itimer_expired(
+		probe_timer_itimer_expired);
+	WARN_ON(ret);
+	ret = register_trace_timer_itimer_set(probe_timer_itimer_set);
+	WARN_ON(ret);
+	ret = register_trace_timer_set(probe_timer_set);
+	WARN_ON(ret);
+	ret = register_trace_timer_update_time(probe_timer_update_time);
+	WARN_ON(ret);
+	ret = register_trace_timer_timeout(probe_timer_timeout);
+	WARN_ON(ret);
+
+	ret = register_trace_kernel_printk(probe_kernel_printk);
+	WARN_ON(ret);
+	ret = register_trace_kernel_vprintk(probe_kernel_vprintk);
+	WARN_ON(ret);
+	ret = register_trace_kernel_module_free(probe_kernel_module_free);
+	WARN_ON(ret);
+	ret = register_trace_kernel_module_load(probe_kernel_module_load);
+	WARN_ON(ret);
+
+	return 0;
+}
+
+module_init(kernel_trace_init);
+
+void __exit kernel_trace_exit(void)
+{
+	unregister_trace_kernel_module_load(probe_kernel_module_load);
+	unregister_trace_kernel_module_free(probe_kernel_module_free);
+	unregister_trace_kernel_vprintk(probe_kernel_vprintk);
+	unregister_trace_kernel_printk(probe_kernel_printk);
+
+	unregister_trace_timer_timeout(probe_timer_timeout);
+	unregister_trace_timer_update_time(probe_timer_update_time);
+	unregister_trace_timer_set(probe_timer_set);
+	unregister_trace_timer_itimer_set(probe_timer_itimer_set);
+	unregister_trace_timer_itimer_expired(
+		probe_timer_itimer_expired);
+
+	unregister_trace_sched_process_fork(probe_sched_process_fork);
+	unregister_trace_sched_process_wait(probe_sched_process_wait);
+	unregister_trace_sched_process_exit(probe_sched_process_exit);
+	unregister_trace_sched_process_free(probe_sched_process_free);
+	unregister_trace_sched_signal_send(probe_sched_signal_send);
+	unregister_trace_sched_migrate_task(probe_sched_migrate_task);
+	unregister_trace_sched_switch(probe_sched_switch);
+	unregister_trace_sched_wakeup_new(probe_sched_wakeup_new);
+	unregister_trace_sched_wakeup(probe_sched_wakeup);
+	unregister_trace_sched_wait_task(probe_sched_wait_task);
+	unregister_trace_sched_kthread_stop_ret(probe_sched_kthread_stop_ret);
+	unregister_trace_sched_kthread_stop(probe_sched_kthread_stop);
+
+	unregister_trace_irq_tasklet_high_exit(
+		probe_irq_tasklet_high_exit);
+	unregister_trace_irq_tasklet_high_entry(
+		probe_irq_tasklet_high_entry);
+	unregister_trace_irq_tasklet_low_exit(
+		probe_irq_tasklet_low_exit);
+	unregister_trace_irq_tasklet_low_entry(
+		probe_irq_tasklet_low_entry);
+	unregister_trace_irq_softirq_raise(probe_irq_softirq_raise);
+	unregister_trace_irq_softirq_exit(probe_irq_softirq_exit);
+	unregister_trace_irq_softirq_entry(probe_irq_softirq_entry);
+	unregister_trace_irq_exit(probe_irq_exit);
+	unregister_trace_irq_entry(probe_irq_entry);
+	tracepoint_synchronize_unregister();
+}
+
+module_exit(kernel_trace_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("kernel Tracepoint Probes");
-- 
1.5.5.1

