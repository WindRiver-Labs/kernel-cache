From 1980d963efbff93b73a6d05502e7c65b57997f72 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:25:27 -0400
Subject: [PATCH 034/391] lttng-core/lttng-optimize-write-to-page-function-cache-page-address

page_address is not fast in some systems,
we should cache it.

Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
---
 include/linux/ltt-relay.h |    4 ++--
 ltt/ltt-relay-alloc.c     |   10 +++++-----
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/include/linux/ltt-relay.h b/include/linux/ltt-relay.h
index 279103f..480a7a0 100644
--- a/include/linux/ltt-relay.h
+++ b/include/linux/ltt-relay.h
@@ -34,6 +34,7 @@ struct rchan_buf;
 
 struct buf_page {
 	struct page *page;
+	void *virt;		/* page address of the struct page */
 	size_t offset;		/* page offset in the buffer */
 	struct list_head list;	/* buffer linked list */
 };
@@ -286,8 +287,7 @@ static inline int ltt_relay_write(struct rchan_buf *buf, size_t offset,
 
 	page = ltt_relay_cache_page(buf, &buf->wpage, page, offset);
 	pagecpy = min_t(size_t, len, PAGE_SIZE - (offset & ~PAGE_MASK));
-	ltt_relay_do_copy(page_address(page->page)
-		+ (offset & ~PAGE_MASK), src, pagecpy);
+	ltt_relay_do_copy(page->virt + (offset & ~PAGE_MASK), src, pagecpy);
 
 	if (unlikely(len != pagecpy))
 		_ltt_relay_write(buf, offset, src, len, page, pagecpy);
diff --git a/ltt/ltt-relay-alloc.c b/ltt/ltt-relay-alloc.c
index 06ed3b0..3c45897 100644
--- a/ltt/ltt-relay-alloc.c
+++ b/ltt/ltt-relay-alloc.c
@@ -54,6 +54,7 @@ static int relay_alloc_buf(struct rchan_buf *buf, size_t *size)
 			goto depopulate;
 		}
 		list_add_tail(&buf_page->list, &buf->pages);
+		buf_page->virt = page_address(buf_page->page);
 		buf_page->offset = (size_t)i << PAGE_SHIFT;
 		set_page_private(buf_page->page, (unsigned long)buf_page);
 		if (i == 0) {
@@ -529,8 +530,8 @@ void _ltt_relay_write(struct rchan_buf *buf, size_t offset,
 
 		page = ltt_relay_cache_page(buf, &buf->wpage, page, offset);
 		pagecpy = min_t(size_t, len, PAGE_SIZE - (offset & ~PAGE_MASK));
-		ltt_relay_do_copy(page_address(page->page)
-			+ (offset & ~PAGE_MASK), src, pagecpy);
+		ltt_relay_do_copy(page->virt
+				+ (offset & ~PAGE_MASK), src, pagecpy);
 	} while (unlikely(len != pagecpy));
 }
 EXPORT_SYMBOL_GPL(_ltt_relay_write);
@@ -556,8 +557,7 @@ int ltt_relay_read(struct rchan_buf *buf, size_t offset,
 	for (;;) {
 		page = ltt_relay_cache_page(buf, &buf->rpage, page, offset);
 		pagecpy = min_t(size_t, len, PAGE_SIZE - (offset & ~PAGE_MASK));
-		memcpy(dest, page_address(page->page) + (offset & ~PAGE_MASK),
-			pagecpy);
+		memcpy(dest, page->virt + (offset & ~PAGE_MASK), pagecpy);
 		len -= pagecpy;
 		if (likely(!len))
 			break;
@@ -610,7 +610,7 @@ void *ltt_relay_offset_address(struct rchan_buf *buf, size_t offset)
 	if (offset < page->offset || offset >= page->offset + PAGE_SIZE)
 		buf->hpage[odd] = page = buf->wpage;
 	page = ltt_relay_cache_page(buf, &buf->hpage[odd], page, offset);
-	return page_address(page->page) + (offset & ~PAGE_MASK);
+	return page->virt + (offset & ~PAGE_MASK);
 }
 EXPORT_SYMBOL_GPL(ltt_relay_offset_address);
 
-- 
1.6.5.2

