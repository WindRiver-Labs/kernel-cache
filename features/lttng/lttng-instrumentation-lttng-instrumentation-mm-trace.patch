From b5d3a5d1583874300ac9360889389a68089b4fda Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:25:58 -0400
Subject: [PATCH 083/391] lttng-instrumentation/lttng-instrumentation-mm-tracepoints-probes

LTTng instrumentation mm tracepoint probes

Create a module which declares mm tracepoint probes, using markers.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Alexander Viro <viro@zeniv.linux.org.uk>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Masami Hiramatsu <mhiramat@redhat.com>
---
 include/linux/swap.h    |    1 +
 include/linux/swapops.h |    8 +++
 ltt/probes/Makefile     |    3 +-
 ltt/probes/mm-trace.c   |  129 +++++++++++++++++++++++++++++++++++++++++++++++
 mm/swapfile.c           |    7 +++
 5 files changed, 147 insertions(+), 1 deletions(-)
 create mode 100644 ltt/probes/mm-trace.c

diff --git a/include/linux/swap.h b/include/linux/swap.h
index 1f59d93..5517728 100644
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@ -327,6 +327,7 @@ extern int swap_type_of(dev_t, sector_t, struct block_device **);
 extern unsigned int count_swap_pages(int, int);
 extern sector_t map_swap_page(struct page *, struct block_device **);
 extern sector_t swapdev_block(int, pgoff_t);
+extern struct swap_info_struct *get_swap_info_struct(unsigned);
 extern int reuse_swap_page(struct page *);
 extern int try_to_free_swap(struct page *);
 struct backing_dev_info;
diff --git a/include/linux/swapops.h b/include/linux/swapops.h
index cd42e30..436a327 100644
--- a/include/linux/swapops.h
+++ b/include/linux/swapops.h
@@ -76,6 +76,14 @@ static inline pte_t swp_entry_to_pte(swp_entry_t entry)
 	return __swp_entry_to_pte(arch_entry);
 }
 
+static inline swp_entry_t page_swp_entry(struct page *page)
+{
+	swp_entry_t entry;
+	VM_BUG_ON(!PageSwapCache(page));
+	entry.val = page_private(page);
+	return entry;
+}
+
 #ifdef CONFIG_MIGRATION
 static inline swp_entry_t make_migration_entry(struct page *page, int write)
 {
diff --git a/ltt/probes/Makefile b/ltt/probes/Makefile
index 4ed52f4..ceed8cd 100644
--- a/ltt/probes/Makefile
+++ b/ltt/probes/Makefile
@@ -2,6 +2,7 @@
 
 ifdef CONFIG_FTRACE
 CFLAGS_REMOVE_kernel-trace.o = -pg
+CFLAGS_REMOVE_mm-trace.o = -pg
 endif
 
-obj-$(CONFIG_LTT_TRACEPROBES)	+= kernel-trace.o
+obj-$(CONFIG_LTT_TRACEPROBES)	+= kernel-trace.o mm-trace.o
diff --git a/ltt/probes/mm-trace.c b/ltt/probes/mm-trace.c
new file mode 100644
index 0000000..d0df48a
--- /dev/null
+++ b/ltt/probes/mm-trace.c
@@ -0,0 +1,129 @@
+/*
+ * ltt/probes/mm-trace.c
+ *
+ * MM tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+#include <linux/ltt-type-serializer.h>
+
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
+#include <linux/swapops.h>
+#include <trace/page_alloc.h>
+#include <trace/filemap.h>
+#include <trace/swap.h>
+#include <trace/hugetlb.h>
+
+void probe_wait_on_page_start(struct page *page, int bit_nr)
+{
+	trace_mark_tp(mm_wait_on_page_start, wait_on_page_start,
+		probe_wait_on_page_start, "pfn %lu bit_nr %d",
+		page_to_pfn(page), bit_nr);
+}
+
+void probe_wait_on_page_end(struct page *page, int bit_nr)
+{
+	trace_mark_tp(mm_wait_on_page_end, wait_on_page_end,
+		probe_wait_on_page_end, "pfn %lu bit_nr %d",
+		page_to_pfn(page), bit_nr);
+}
+
+void probe_hugetlb_page_free(struct page *page)
+{
+	trace_mark_tp(mm_huge_page_free, hugetlb_page_free,
+		probe_hugetlb_page_free, "pfn %lu", page_to_pfn(page));
+}
+
+void probe_hugetlb_page_alloc(struct page *page)
+{
+	if (page)
+		trace_mark_tp(mm_huge_page_alloc, hugetlb_page_alloc,
+			probe_hugetlb_page_alloc, "pfn %lu", page_to_pfn(page));
+}
+
+/* mm_page_free specialized tracepoint probe */
+
+void probe_page_free(struct page *page, unsigned int order);
+
+DEFINE_MARKER_TP(mm_page_free, page_free, probe_page_free,
+	"pfn %lu order %u");
+
+notrace void probe_page_free(struct page *page, unsigned int order)
+{
+	struct marker *marker;
+	struct serialize_long_int data;
+
+	data.f1 = page_to_pfn(page);
+	data.f2 = order;
+
+	marker = &GET_MARKER(mm_page_free);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+/* mm_page_alloc specialized tracepoint probe */
+
+void probe_page_alloc(struct page *page, unsigned int order);
+
+DEFINE_MARKER_TP(mm_page_alloc, page_alloc, probe_page_alloc,
+	"pfn %lu order %u");
+
+notrace void probe_page_alloc(struct page *page, unsigned int order)
+{
+	struct marker *marker;
+	struct serialize_long_int data;
+
+	if (unlikely(!page))
+		return;
+
+	data.f1 = page_to_pfn(page);
+	data.f2 = order;
+
+	marker = &GET_MARKER(mm_page_alloc);
+	ltt_specialized_trace(marker->single.probe_private,
+		&data, serialize_sizeof(data), sizeof(long));
+}
+
+#ifdef CONFIG_SWAP
+void probe_swap_in(struct page *page, swp_entry_t entry)
+{
+	trace_mark_tp(mm_swap_in, swap_in, probe_swap_in,
+		"pfn %lu filp %p offset %lu",
+		page_to_pfn(page),
+		get_swap_info_struct(swp_type(entry))->swap_file,
+		swp_offset(entry));
+}
+
+void probe_swap_out(struct page *page)
+{
+	trace_mark_tp(mm_swap_out, swap_out, probe_swap_out,
+		"pfn %lu filp %p offset %lu",
+		page_to_pfn(page),
+		get_swap_info_struct(swp_type(
+			page_swp_entry(page)))->swap_file,
+		swp_offset(page_swp_entry(page)));
+}
+
+void probe_swap_file_close(struct file *file)
+{
+	trace_mark_tp(mm_swap_file_close, swap_file_close,
+		probe_swap_file_close, "filp %p", file);
+}
+
+void probe_swap_file_open(struct file *file, char *filename)
+{
+	trace_mark_tp(mm_swap_file_open, swap_file_open,
+		probe_swap_file_open, "filp %p filename %s",
+		file, filename);
+}
+#endif
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("MM Tracepoint Probes");
diff --git a/mm/swapfile.c b/mm/swapfile.c
index 6cd0a8f..204e999 100644
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@ -2207,6 +2207,13 @@ int swap_duplicate(swp_entry_t entry)
 	return err;
 }
 
+struct swap_info_struct *
+get_swap_info_struct(unsigned type)
+{
+	return swap_info[type];
+}
+EXPORT_SYMBOL_GPL(get_swap_info_struct);
+
 /*
  * @entry: swap entry for which we allocate swap cache.
  *
-- 
1.6.5.2

