From b247cc4617ae45a625335a9f9b8700893c4cf7f2 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Fri, 9 Jan 2009 10:00:27 -0500
Subject: [PATCH] lttng-tracer-fix-exit

Hi Mathieu
When removing ltt-tracer module, OOPS happens.
Because "tmp = ltt_traces.head;" breaks the list.
This patch fix it.

Signed-off-by: Gui Jianfeng <guijianfeng@cn.fujitsu.com>
---
 ltt/ltt-tracer.c |    6 +-----
 1 files changed, 1 insertions(+), 5 deletions(-)

diff --git a/ltt/ltt-tracer.c b/ltt/ltt-tracer.c
index 9b5892a..ea339c2 100644
--- a/ltt/ltt-tracer.c
+++ b/ltt/ltt-tracer.c
@@ -1210,20 +1210,16 @@ static void __exit ltt_exit(void)
 {
 	struct ltt_trace_struct *trace;
 	struct list_head *pos, *n;
-	struct list_head tmp;
 
 	ltt_lock_traces();
 	/* Stop each trace, currently being read by RCU read-side */
 	list_for_each_entry_rcu(trace, &ltt_traces.head, list)
 		_ltt_trace_stop(trace);
-	tmp = ltt_traces.head;
-	/* empty the original list head */
-	INIT_LIST_HEAD(&ltt_traces.head);
 	/* Wait for quiescent state. Readers have preemption disabled. */
 	synchronize_sched();
 	/* Safe iteration is now permitted. It does not have to be RCU-safe
 	 * because no readers are left. */
-	list_for_each_safe(pos, n, &tmp) {
+	list_for_each_safe(pos, n, &ltt_traces.head) {
 		trace = container_of(pos, struct ltt_trace_struct, list);
 		/* _ltt_trace_destroy does a synchronize_sched() */
 		_ltt_trace_destroy(trace);
-- 
1.6.0.4

