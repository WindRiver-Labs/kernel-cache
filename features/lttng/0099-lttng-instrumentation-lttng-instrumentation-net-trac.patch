From b9e774a5264653aacf5915b79de34c3b629fcdd6 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 May 2010 19:26:07 -0400
Subject: [PATCH 099/391] lttng-instrumentation/lttng-instrumentation-net-tracepoints-probes

LTTng instrumentation net tracepoint probes

Create a module which declares net tracepoint probes, using markers.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Alexander Viro <viro@zeniv.linux.org.uk>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Masami Hiramatsu <mhiramat@redhat.com>
---
 ltt/probes/Makefile    |    7 ++
 ltt/probes/net-trace.c |  158 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 165 insertions(+), 0 deletions(-)
 create mode 100644 ltt/probes/net-trace.c

diff --git a/ltt/probes/Makefile b/ltt/probes/Makefile
index ceed8cd..9f5876e 100644
--- a/ltt/probes/Makefile
+++ b/ltt/probes/Makefile
@@ -6,3 +6,10 @@ CFLAGS_REMOVE_mm-trace.o = -pg
 endif
 
 obj-$(CONFIG_LTT_TRACEPROBES)	+= kernel-trace.o mm-trace.o
+
+ifeq ($(CONFIG_NET),y)
+ifdef CONFIG_FTRACE
+CFLAGS_REMOVE_net-trace.o = -pg
+endif
+obj-$(CONFIG_LTT_TRACEPROBES)	+= net-trace.o
+endif
diff --git a/ltt/probes/net-trace.c b/ltt/probes/net-trace.c
new file mode 100644
index 0000000..a7c94c6
--- /dev/null
+++ b/ltt/probes/net-trace.c
@@ -0,0 +1,158 @@
+/*
+ * ltt/probes/net-trace.c
+ *
+ * Net tracepoint probes.
+ *
+ * (C) Copyright 2009 - Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Dual LGPL v2.1/GPL v2 license.
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <trace/net.h>
+#include <trace/ipv4.h>
+#include <trace/ipv6.h>
+#include <trace/socket.h>
+
+void probe_net_dev_xmit(struct sk_buff *skb)
+{
+	trace_mark_tp(net_dev_xmit, net_dev_xmit,
+		probe_net_dev_xmit,
+		"skb %p protocol #2u%hu", skb, skb->protocol);
+}
+
+void probe_net_dev_receive(struct sk_buff *skb)
+{
+	trace_mark_tp(net_dev_receive, net_dev_receive,
+		probe_net_dev_receive, "skb %p protocol #2u%hu",
+		skb, skb->protocol);
+}
+
+void probe_ipv4_addr_add(struct in_ifaddr *ifa)
+{
+	trace_mark_tp(net_insert_ifa_ipv4, ipv4_addr_add,
+		probe_ipv4_addr_add, "label %s address #4u%u",
+		ifa->ifa_label, (unsigned int)ifa->ifa_address);
+}
+
+void probe_ipv4_addr_del(struct in_ifaddr *ifa)
+{
+	trace_mark_tp(net_del_ifa_ipv4, ipv4_addr_del,
+		probe_ipv4_addr_del, "label %s address #4u%u",
+		ifa->ifa_label, (unsigned int)ifa->ifa_address);
+}
+
+void probe_ipv6_addr_add(struct inet6_ifaddr *ifa)
+{
+	__u8 *addr = ifa->addr.s6_addr;
+
+	trace_mark_tp(net_insert_ifa_ipv6, ipv6_addr_add, probe_ipv6_addr_add,
+		"label %s "
+		"a15 #1x%c a14 #1x%c a13 #1x%c a12 #1x%c "
+		"a11 #1x%c a10 #1x%c a9 #1x%c a8 #1x%c "
+		"a7 #1x%c a6 #1x%c a5 #1x%c a4 #1x%c "
+		"a3 #1x%c a2 #1x%c a1 #1x%c a0 #1x%c",
+		ifa->idev->dev->name,
+		addr[15], addr[14], addr[13], addr[12],
+		addr[11], addr[10], addr[9], addr[8],
+		addr[7], addr[6], addr[5], addr[4],
+		addr[3], addr[2], addr[1], addr[0]);
+}
+
+void probe_ipv6_addr_del(struct inet6_ifaddr *ifa)
+{
+	__u8 *addr = ifa->addr.s6_addr;
+
+	trace_mark_tp(net_insert_ifa_ipv6, ipv6_addr_del, probe_ipv6_addr_del,
+		"label %s "
+		"a15 #1x%c a14 #1x%c a13 #1x%c a12 #1x%c "
+		"a11 #1x%c a10 #1x%c a9 #1x%c a8 #1x%c "
+		"a7 #1x%c a6 #1x%c a5 #1x%c a4 #1x%c "
+		"a3 #1x%c a2 #1x%c a1 #1x%c a0 #1x%c",
+		ifa->idev->dev->name,
+		addr[15], addr[14], addr[13], addr[12],
+		addr[11], addr[10], addr[9], addr[8],
+		addr[7], addr[6], addr[5], addr[4],
+		addr[3], addr[2], addr[1], addr[0]);
+}
+
+void probe_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+		size_t size, int ret)
+{
+	trace_mark_tp(net_socket_sendmsg, socket_sendmsg, probe_socket_sendmsg,
+		"sock %p family %d type %d protocol %d size %zu",
+		sock, sock->sk->sk_family, sock->sk->sk_type,
+		sock->sk->sk_protocol, size);
+}
+
+void probe_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+		size_t size, int flags, int ret)
+{
+	trace_mark_tp(net_socket_recvmsg, socket_recvmsg, probe_socket_recvmsg,
+		"sock %p family %d type %d protocol %d size %zu",
+		sock, sock->sk->sk_family, sock->sk->sk_type,
+		sock->sk->sk_protocol, size);
+}
+
+void probe_socket_create(struct socket *sock, int fd)
+{
+	trace_mark_tp(net_socket_create, socket_create, probe_socket_create,
+		"sock %p family %d type %d protocol %d fd %d",
+		sock, sock->sk->sk_family, sock->sk->sk_type,
+		sock->sk->sk_protocol, fd);
+}
+
+void probe_socket_call(int call, unsigned long a0)
+{
+	trace_mark_tp(net_socket_call, socket_call, probe_socket_call,
+		"call %d a0 %lu", call, a0);
+}
+
+#ifdef CONFIG_NETPOLL
+void probe_net_napi_schedule(struct napi_struct *n)
+{
+	trace_mark_tp(net_napi_schedule, net_napi_schedule,
+		probe_net_napi_schedule,
+		"napi_struct %p name %s",
+		n, n->dev->name);
+}
+
+void probe_net_napi_poll(struct napi_struct *n)
+{
+	trace_mark_tp(net_napi_poll, net_napi_poll, probe_net_napi_poll,
+		"napi_struct %p name %s",
+		n, n->dev->name);
+}
+
+void probe_net_napi_complete(struct napi_struct *n)
+{
+	trace_mark_tp(net_napi_complete, net_napi_complete,
+		probe_net_napi_complete,
+		"napi_struct %p name %s",
+		n, n->dev->name);
+}
+#else /* !CONFIG_NETPOLL */
+void probe_net_napi_schedule(struct napi_struct *n)
+{
+	trace_mark_tp(net_napi_schedule, net_napi_schedule,
+		probe_net_napi_schedule,
+		"napi_struct %p", n);
+}
+
+void probe_net_napi_poll(struct napi_struct *n)
+{
+	trace_mark_tp(net_napi_poll, net_napi_poll, probe_net_napi_poll,
+		"napi_struct %p", n);
+}
+
+void probe_net_napi_complete(struct napi_struct *n)
+{
+	trace_mark_tp(net_napi_complete, net_napi_complete,
+		probe_net_napi_complete,
+		"napi_struct %p", n);
+}
+#endif
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Mathieu Desnoyers");
+MODULE_DESCRIPTION("Net Tracepoint Probes");
-- 
1.6.5.2

