From b1cd8b01fac97af2510eed7205849bf88c5cc230 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Fri, 19 Oct 2012 11:43:17 +0800
Subject: [PATCH 7/8] drivers: staging: cdv: align ttm usage

Upstream commit 57de4ba9 [drm/ttm: simplify memory accounting for ttm
user v2] removed the tm_bo_extra_size and ttm_bo_size fields from the
ttm_bo_global struct as a simplification to ttm buffer object
handling. A helper function (ttm_bo_acc_size) was supplied instead.

The removed fields were used in calls to ttm_pl_size. These are now
replaced by ttm_bo_acc_size, and the static function ttm_pl_size has
been removed.

Upstream commit 3316497 [drm/ttm: remove userspace backed ttm object
support] removed the tm_bo_type_user enum, because the userspace
backed ttm object support as removed.

Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
Signed-off-by: Liang Li <liang.li@windriver.com>
---
 drivers/staging/cdv/imgv/psb_buffer.c             |   93 +++++++++------------
 drivers/staging/cdv/imgv/psb_ttm_placement_user.c |   68 +++------------
 2 files changed, 51 insertions(+), 110 deletions(-)

diff --git a/drivers/staging/cdv/imgv/psb_buffer.c b/drivers/staging/cdv/imgv/psb_buffer.c
index 263cd7c..36202ae 100644
--- a/drivers/staging/cdv/imgv/psb_buffer.c
+++ b/drivers/staging/cdv/imgv/psb_buffer.c
@@ -11,7 +11,7 @@
  * more details.
  *
  * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc., 
+ * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  *
  **************************************************************************/
@@ -19,6 +19,7 @@
  * Authors: Thomas Hellstrom <thomas-at-tungstengraphics.com>
  */
 #include "ttm/ttm_placement.h"
+#include "ttm/ttm_page_alloc.h"
 #include "ttm/ttm_execbuf_util.h"
 #include "psb_ttm_fence_api.h"
 #include <drm/drmP.h>
@@ -27,8 +28,8 @@
 
 #define DRM_MEM_TTM       26
 
-struct drm_psb_ttm_backend {
-	struct ttm_backend base;
+struct drm_psb_ttm_tt {
+	struct ttm_tt ttm;
 	struct page **pages;
 	unsigned int desired_tile_stride;
 	unsigned int hw_tile_stride;
@@ -119,7 +120,7 @@ static void psb_evict_mask(struct ttm_buffer_object *bo, struct ttm_placement* p
 	placement->placement = &cur_placement;
 	placement->num_busy_placement = 0;
 	placement->busy_placement = NULL;
-	
+
 	/* all buffers evicted to system memory */
 	/* return cur_placement | TTM_PL_FLAG_SYSTEM; */
 }
@@ -219,26 +220,13 @@ static int psb_move(struct ttm_buffer_object *bo,
 	return 0;
 }
 
-static int drm_psb_tbe_populate(struct ttm_backend *backend,
-				unsigned long num_pages,
-				struct page **pages,
-				struct page *dummy_read_page,
-				dma_addr_t *dma_addrs)
+static int drm_psb_tbe_unbind(struct ttm_tt *ttm)
 {
-	struct drm_psb_ttm_backend *psb_be =
-	    container_of(backend, struct drm_psb_ttm_backend, base);
-
-	psb_be->pages = pages;
-	return 0;
-}
-
-static int drm_psb_tbe_unbind(struct ttm_backend *backend)
-{
-	struct ttm_bo_device *bdev = backend->bdev;
+	struct ttm_bo_device *bdev = ttm->bdev;
 	struct drm_psb_private *dev_priv =
 	    container_of(bdev, struct drm_psb_private, bdev);
-	struct drm_psb_ttm_backend *psb_be =
-	    container_of(backend, struct drm_psb_ttm_backend, base);
+	struct drm_psb_ttm_tt *psb_be =
+	    container_of(ttm, struct drm_psb_ttm_tt, ttm);
 	struct psb_mmu_pd *pd = psb_mmu_get_default_pd(dev_priv->mmu);
 	/* struct ttm_mem_type_manager *man = &bdev->man[psb_be->mem_type]; */
 
@@ -253,28 +241,30 @@ static int drm_psb_tbe_unbind(struct ttm_backend *backend)
 	}
 
 	psb_mmu_remove_pages(pd, psb_be->offset,
-			     psb_be->num_pages,
+			     psb_be->ttm.num_pages,
 			     psb_be->desired_tile_stride,
 			     psb_be->hw_tile_stride);
 
 	return 0;
 }
 
-static int drm_psb_tbe_bind(struct ttm_backend *backend,
+static int drm_psb_tbe_bind(struct ttm_tt *ttm,
 			    struct ttm_mem_reg *bo_mem)
 {
-	struct ttm_bo_device *bdev = backend->bdev;
+	struct ttm_bo_device *bdev = ttm->bdev;
 	struct drm_psb_private *dev_priv =
 	    container_of(bdev, struct drm_psb_private, bdev);
-	struct drm_psb_ttm_backend *psb_be =
-	    container_of(backend, struct drm_psb_ttm_backend, base);
+	struct drm_psb_ttm_tt *psb_be =
+	    container_of(ttm, struct drm_psb_ttm_tt, ttm);
 	struct psb_mmu_pd *pd = psb_mmu_get_default_pd(dev_priv->mmu);
 	struct ttm_mem_type_manager *man = &bdev->man[bo_mem->mem_type];
 	int type;
 	int ret = 0;
 
 	psb_be->mem_type = bo_mem->mem_type;
-	psb_be->num_pages = bo_mem->num_pages;
+	/* psb_be->pages = ttm->pages; */
+	psb_be->ttm.num_pages = bo_mem->num_pages;
+	/* psb_be->num_pages = ttm->num_pages; */
 	psb_be->desired_tile_stride = 0;
 	psb_be->hw_tile_stride = 0;
 	psb_be->offset = (bo_mem->start << PAGE_SHIFT) +
@@ -290,13 +280,13 @@ static int drm_psb_tbe_bind(struct ttm_backend *backend,
 
 		ret = psb_gtt_insert_pages(dev_priv->pg, psb_be->pages,
 					   gatt_p_offset,
-					   psb_be->num_pages,
+					   psb_be->ttm.num_pages,
 					   psb_be->desired_tile_stride,
 					   psb_be->hw_tile_stride, type);
 	}
 
-	ret = psb_mmu_insert_pages(pd, psb_be->pages,
-				   psb_be->offset, psb_be->num_pages,
+	ret = psb_mmu_insert_pages(pd, psb_be->ttm.pages,
+				   psb_be->offset, psb_be->ttm.num_pages,
 				   psb_be->desired_tile_stride,
 				   psb_be->hw_tile_stride, type);
 	if (ret)
@@ -304,48 +294,43 @@ static int drm_psb_tbe_bind(struct ttm_backend *backend,
 
 	return 0;
 out_err:
-	drm_psb_tbe_unbind(backend);
+	drm_psb_tbe_unbind(ttm);
 	return ret;
 
 }
 
-static void drm_psb_tbe_clear(struct ttm_backend *backend)
+static void drm_psb_tbe_destroy(struct ttm_tt *ttm)
 {
-	struct drm_psb_ttm_backend *psb_be =
-	    container_of(backend, struct drm_psb_ttm_backend, base);
+	struct drm_psb_ttm_tt *psb_be =
+	    container_of(ttm, struct drm_psb_ttm_tt, ttm);
 
-	psb_be->pages = NULL;
-	return;
-}
-
-static void drm_psb_tbe_destroy(struct ttm_backend *backend)
-{
-	struct drm_psb_ttm_backend *psb_be =
-	    container_of(backend, struct drm_psb_ttm_backend, base);
-
-	if (backend)
+	if (ttm)
 		kfree(psb_be);
 }
 
 static struct ttm_backend_func psb_ttm_backend = {
-	.populate = drm_psb_tbe_populate,
-	.clear = drm_psb_tbe_clear,
 	.bind = drm_psb_tbe_bind,
 	.unbind = drm_psb_tbe_unbind,
 	.destroy = drm_psb_tbe_destroy,
 };
 
-static struct ttm_backend *drm_psb_tbe_init(struct ttm_bo_device *bdev)
+static struct ttm_tt  *drm_psb_tbe_ttm_create(struct ttm_bo_device *bdev,
+                                              unsigned long size, uint32_t page_flags,
+                                              struct page *dummy_read_page)
 {
-	struct drm_psb_ttm_backend *psb_be;
+	struct drm_psb_ttm_tt *psb_be;
 
 	psb_be = kzalloc(sizeof(*psb_be), GFP_KERNEL);
 	if (!psb_be)
 		return NULL;
-	psb_be->pages = NULL;
-	psb_be->base.func = &psb_ttm_backend;
-	psb_be->base.bdev = bdev;
-	return &psb_be->base;
+	psb_be->ttm.pages = NULL;
+	psb_be->ttm.func = &psb_ttm_backend;
+	psb_be->ttm.bdev = bdev;
+
+	if (ttm_tt_init(&psb_be->ttm, bdev, size, page_flags, dummy_read_page))
+		return NULL;
+
+	return &psb_be->ttm;
 }
 
 static int psb_ttm_io_mem_reserve(struct ttm_bo_device *bdev, struct ttm_mem_reg *mem)
@@ -426,7 +411,9 @@ struct ttm_bo_driver psb_ttm_bo_driver = {
 	.num_mem_type_prio = ARRAY_SIZE(psb_mem_prios),
 	.num_mem_busy_prio = ARRAY_SIZE(psb_busy_prios),
 */
-	.create_ttm_backend_entry = &drm_psb_tbe_init,
+	.ttm_tt_create = &drm_psb_tbe_ttm_create,
+	.ttm_tt_populate = &ttm_pool_populate,
+	.ttm_tt_unpopulate = &ttm_pool_unpopulate,
 	.invalidate_caches = &psb_invalidate_caches,
 	.init_mem_type = &psb_init_mem_type,
 	.evict_flags = &psb_evict_mask,
diff --git a/drivers/staging/cdv/imgv/psb_ttm_placement_user.c b/drivers/staging/cdv/imgv/psb_ttm_placement_user.c
index 7395901..0d8fa2d 100644
--- a/drivers/staging/cdv/imgv/psb_ttm_placement_user.c
+++ b/drivers/staging/cdv/imgv/psb_ttm_placement_user.c
@@ -34,8 +34,6 @@ struct ttm_bo_user_object {
 	struct ttm_buffer_object bo;
 };
 
-static size_t pl_bo_size;
-
 static uint32_t psb_busy_prios[] = {
 	TTM_PL_TT,
 	TTM_PL_PRIV0, /* CI */
@@ -46,19 +44,6 @@ static uint32_t psb_busy_prios[] = {
 
 const struct ttm_placement default_placement = {0, 0, 0, NULL, 5, psb_busy_prios};
 
-static size_t ttm_pl_size(struct ttm_bo_device *bdev, unsigned long num_pages)
-{
-	size_t page_array_size =
-	    (num_pages * sizeof(void *) + PAGE_SIZE - 1) & PAGE_MASK;
-
-	if (unlikely(pl_bo_size == 0)) {
-		pl_bo_size = bdev->glob->ttm_bo_extra_size +
-		    ttm_round_pot(sizeof(struct ttm_bo_user_object));
-	}
-
-	return bdev->glob->ttm_bo_size + 2 * page_array_size;
-}
-
 static struct ttm_bo_user_object *ttm_bo_user_lookup(struct ttm_object_file
 						     *tfile, uint32_t handle)
 {
@@ -102,7 +87,6 @@ static void ttm_bo_user_destroy(struct ttm_buffer_object *bo)
 	struct ttm_bo_user_object *user_bo =
 	    container_of(bo, struct ttm_bo_user_object, bo);
 
-	ttm_mem_global_free(bo->glob->mem_glob, bo->acc_size);
 	kfree(user_bo);
 }
 
@@ -152,47 +136,29 @@ static void ttm_pl_fill_rep(struct ttm_buffer_object *bo,
 	rep->sync_object_arg = (uint32_t) (unsigned long)bo->sync_obj_arg;
 }
 
-/* FIXME Copy from upstream TTM */
-static inline size_t ttm_bo_size(struct ttm_bo_global *glob,
-				 unsigned long num_pages)
-{
-	size_t page_array_size = (num_pages * sizeof(void *) + PAGE_SIZE - 1) &
-	    PAGE_MASK;
-
-	return glob->ttm_bo_size + 2 * page_array_size;
-}
-
 /* FIXME Copy from upstream TTM "ttm_bo_create", upstream TTM does not export this, so copy it here */
-static int ttm_bo_create_private(struct ttm_bo_device *bdev,
+int ttm_bo_create_private(struct ttm_bo_device *bdev,
 			unsigned long size,
 			enum ttm_bo_type type,
 			struct ttm_placement *placement,
 			uint32_t page_alignment,
 			unsigned long buffer_start,
 			bool interruptible,
-			struct file *persistant_swap_storage,
+			struct file *persistent_swap_storage,
 			struct ttm_buffer_object **p_bo)
 {
 	struct ttm_buffer_object *bo;
-	struct ttm_mem_global *mem_glob = bdev->glob->mem_glob;
+	size_t acc_size;
 	int ret;
 
-	size_t acc_size =
-	    ttm_bo_size(bdev->glob, (size + PAGE_SIZE - 1) >> PAGE_SHIFT);
-	ret = ttm_mem_global_alloc(mem_glob, acc_size, false, false);
-	if (unlikely(ret != 0))
-		return ret;
-
 	bo = kzalloc(sizeof(*bo), GFP_KERNEL);
-
-	if (unlikely(bo == NULL)) {
-		ttm_mem_global_free(mem_glob, acc_size);
+	if (unlikely(bo == NULL))
 		return -ENOMEM;
-	}
 
+	acc_size = ttm_bo_acc_size(bdev, size, sizeof(struct ttm_buffer_object));
 	ret = ttm_bo_init(bdev, bo, size, type, placement, page_alignment,
 				buffer_start, interruptible,
-				persistant_swap_storage, acc_size, NULL);
+				persistent_swap_storage, acc_size, NULL);
 	if (likely(ret == 0))
 		*p_bo = bo;
 
@@ -270,25 +236,18 @@ int ttm_pl_create_ioctl(struct ttm_object_file *tfile,
 	struct ttm_bo_user_object *user_bo;
 	uint32_t flags;
 	int ret = 0;
-	struct ttm_mem_global *mem_glob = bdev->glob->mem_glob;
 	struct ttm_placement placement = default_placement;
-	size_t acc_size =
-	    ttm_pl_size(bdev, (req->size + PAGE_SIZE - 1) >> PAGE_SHIFT);
-	ret = ttm_mem_global_alloc(mem_glob, acc_size, false, false);
-	if (unlikely(ret != 0))
-		return ret;
+	size_t acc_size = ttm_bo_acc_size(bdev, req->size, sizeof(struct ttm_bo_user_object));
 
 	flags = req->placement;
 	user_bo = kzalloc(sizeof(*user_bo), GFP_KERNEL);
 	if (unlikely(user_bo == NULL)) {
-		ttm_mem_global_free(mem_glob, acc_size);
 		return -ENOMEM;
 	}
 
 	bo = &user_bo->bo;
 	ret = ttm_read_lock(lock, true);
 	if (unlikely(ret != 0)) {
-		ttm_mem_global_free(mem_glob, acc_size);
 		kfree(user_bo);
 		return ret;
 	}
@@ -346,23 +305,18 @@ int ttm_pl_ub_create_ioctl(struct ttm_object_file *tfile,
 	struct ttm_bo_user_object *user_bo;
 	uint32_t flags;
 	int ret = 0;
-	struct ttm_mem_global *mem_glob = bdev->glob->mem_glob;
+
 	struct ttm_placement placement = default_placement;
-	size_t acc_size =
-	    ttm_pl_size(bdev, (req->size + PAGE_SIZE - 1) >> PAGE_SHIFT);
-	ret = ttm_mem_global_alloc(mem_glob, acc_size, false, false);
-	if (unlikely(ret != 0))
-		return ret;
+
+	size_t acc_size = ttm_bo_acc_size(bdev, req->size, sizeof(struct ttm_bo_user_object));
 
 	flags = req->placement;
 	user_bo = kzalloc(sizeof(*user_bo), GFP_KERNEL);
 	if (unlikely(user_bo == NULL)) {
-		ttm_mem_global_free(mem_glob, acc_size);
 		return -ENOMEM;
 	}
 	ret = ttm_read_lock(lock, true);
 	if (unlikely(ret != 0)) {
-		ttm_mem_global_free(mem_glob, acc_size);
 		kfree(user_bo);
 		return ret;
 	}
@@ -374,7 +328,7 @@ int ttm_pl_ub_create_ioctl(struct ttm_object_file *tfile,
 	ret = ttm_bo_init(bdev,
 					bo,
 					req->size,
-					ttm_bo_type_user,
+					ttm_bo_type_device,
 					&placement,
 					req->page_alignment,
 					req->user_address,
-- 
1.7.9.7

