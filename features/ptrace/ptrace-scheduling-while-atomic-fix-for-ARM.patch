From 69de91e5f4534539d978e36d2217fc60b4623f1e Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Mon, 25 Jun 2012 13:22:42 -0700
Subject: [PATCH 3/4] ptrace: scheduling while atomic fix for ARM

The issue at hand here is that the access_process_vm() calls
into get_user_pages which can sometimes call cond_resched().

If ptrace is servicing a breakpoint remove or planting a breakpoint,
a final call out to schedule() should not happen because the system
will be operating in the interrupt context already.

The example here is if ptrace is used to single step every line
of a forked child which exec'ed /bin/ls.  You can end
up with the many lines of errors printed by the kernel:

BUG: scheduling while atomic: ls/0x40000001/641

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
[Refreshed the context on v3.4 kernel]
Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/arm/kernel/ptrace.c |   27 ++++++++++++++++++++++-----
 1 file changed, 22 insertions(+), 5 deletions(-)

diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index 9952a82..f766b4e 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -74,6 +74,23 @@ static u32 *thumbGetNpc(u16 instr,	/* the current instruction */
 			struct task_struct *child,	/* pointer to task registers */
 			int *backToArm);
 
+static inline int ptrace_access_process_vm(struct task_struct *tsk,
+			unsigned long addr,
+			void *buf,
+			int len,
+			int write)
+{
+	if (!(preempt_count() & PREEMPT_ACTIVE)) {
+		int ret;
+		add_preempt_count(PREEMPT_ACTIVE);
+		ret = access_process_vm(tsk, addr, buf, len, write);
+		sub_preempt_count(PREEMPT_ACTIVE);
+		return ret;
+	}
+
+	return access_process_vm(tsk, addr, buf, len, write);
+}
+
 /*
  * does not yet catch signals sent when the child dies.
  * in exit.c or in signal.c.
@@ -257,7 +274,7 @@ read_u32(struct task_struct *task, unsigned long addr, u32 *res)
 {
 	int ret;
 
-	ret = access_process_vm(task, addr, res, sizeof(*res), 0);
+	ret = ptrace_access_process_vm(task, addr, res, sizeof(*res), 0);
 
 	return ret == sizeof(*res) ? 0 : -EIO;
 }
@@ -271,13 +288,13 @@ read_instr(struct task_struct *task, unsigned long addr, u32 *res,
 	if ((addr & 1) || is_thumb) {
 		u16 val;
 		pr_debug("%s: reading a THUMB instrution\n", __FUNCTION__);
-		ret = access_process_vm(task, addr & ~1, &val, sizeof(val), 0);
+		ret = ptrace_access_process_vm(task, addr & ~1, &val, sizeof(val), 0);
 		ret = ret == sizeof(val) ? 0 : -EIO;
 		*res = val;
 	} else {
 		u32 val;
 		pr_debug("%s: reading an ARM instrution\n", __FUNCTION__);
-		ret = access_process_vm(task, addr & ~3, &val, sizeof(val), 0);
+		ret = ptrace_access_process_vm(task, addr & ~3, &val, sizeof(val), 0);
 		ret = ret == sizeof(val) ? 0 : -EIO;
 		*res = val;
 	}
@@ -294,7 +311,7 @@ swap_insn(struct task_struct *task, unsigned long addr,
 	pr_debug("%s new insn 0x%x for addr 0x%lx, size %d\n",
 	       __FUNCTION__, *((int *)new_insn), addr, size);
 
-	ret = access_process_vm(task, addr, old_insn, size, 0);
+	ret = ptrace_access_process_vm(task, addr, old_insn, size, 0);
 
 	if (size == 2) {
 		short old, new;
@@ -311,7 +328,7 @@ swap_insn(struct task_struct *task, unsigned long addr,
 	}
 
 	if (ret == size)
-		ret = access_process_vm(task, addr, new_insn, size, 1);
+		ret = ptrace_access_process_vm(task, addr, new_insn, size, 1);
 	else
 		pr_debug("%s ERROR\n", __FUNCTION__);
 	return ret;
-- 
1.7.9.7

