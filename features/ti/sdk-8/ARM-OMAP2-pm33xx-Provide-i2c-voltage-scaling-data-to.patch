From df4804b2d21e64654d00985609556af9167f8635 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Thu, 28 Aug 2014 14:18:51 -0500
Subject: [PATCH 1106/1587] ARM: OMAP2: pm33xx: Provide i2c voltage scaling
 data to wkup_m3

Allow loading of a binary containing i2c scaling sequences to be
provided to the wkup_m3 firmware in order to properly scale voltage
rails on the PMIC during low power modes like DeepSleep0. Proper binary
format is determined by the FW in use.

PM Code expects firmware to have 0x0C57 present as the first two bytes
followed by one byte defining offset to sleep sequence followed by one
byte defining offset to wake sequence and then lastly both sequences.
Each sequence is a series of I2C transfers in the form:

u8 length | u8 chip address | u8 byte0/reg address | u8 byte1 | u8 byteN ..

The length indicates the number of bytes to transfer, including the
register address. The length of each transfer is limited by the I2C buffer
size of 32 bytes.

Based on previous work by Russ Dill.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 .../devicetree/bindings/arm/omap/amx3xx-pm.txt     |   10 +++
 arch/arm/mach-omap2/pm33xx.c                       |   70 +++++++++++++++++++-
 arch/arm/mach-omap2/pm33xx.h                       |    1 +
 3 files changed, 80 insertions(+), 1 deletions(-)

diff --git a/Documentation/devicetree/bindings/arm/omap/amx3xx-pm.txt b/Documentation/devicetree/bindings/arm/omap/amx3xx-pm.txt
index d67780f..1961c33 100644
--- a/Documentation/devicetree/bindings/arm/omap/amx3xx-pm.txt
+++ b/Documentation/devicetree/bindings/arm/omap/amx3xx-pm.txt
@@ -24,3 +24,13 @@ Example:
 		ti,needs-vtt-toggle;
 		ti,vtt-gpio-pin = <7>;
 	};
+
+Support for I2C PMIC Voltage Scaling
+==================================
+It is possible to pass the name of a binary file to laod to the CM3 firmware
+in order to provide I2C sequences for the CM3 to send out to the PMIC during
+low power mode entry.
+
+Optional Properties:
+-scale-data-fw:	Name of the firmware binary in /lib/firmware to copy to m3
+		aux data.
diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index 9171a80..9f1c670 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -67,6 +67,8 @@ static int retrigger_irq;
 #define RTC_REG_DDR_TYPE_DDR2_0		(0x00 << 16)
 #define RTC_REG_DDR_TYPE_DDR3_0		(0x01 << 16)
 
+#define WKUP_M3_SD_FW_MAGIC	0x570C
+
 #ifdef CONFIG_SUSPEND
 static void __iomem *scu_base, *gic_dist_base;
 static struct powerdomain *cefuse_pwrdm, *gfx_pwrdm, *per_pwrdm, *mpu_pwrdm;
@@ -76,6 +78,12 @@ static struct clockdomain *gfx_l4ls_clkdm;
 static struct am33xx_suspend_params susp_params;
 
 #ifdef CONFIG_CPU_PM
+struct wkup_m3_scale_data_header {
+	u16 magic;
+	u8 sleep_offset;
+	u8 wake_offset;
+} __packed;
+
 static void __iomem *am33xx_emif_base;
 static struct am33xx_pm_context *am33xx_pm;
 
@@ -106,7 +114,6 @@ int am33xx_do_sram_cpuidle(u32 wfi_flags, u32 m3_flags)
 		am33xx_pm->ipc.reg1 = IPC_CMD_IDLE;
 		am33xx_pm->ipc.reg2 = DS_IPC_DEFAULT;
 		am33xx_pm->ipc.reg3 = m3_flags;
-		am33xx_pm->ipc.reg5 = DS_IPC_DEFAULT;
 		wkup_m3_set_cmd(&am33xx_pm->ipc);
 		ret = wkup_m3_ping();
 		if (ret < 0)
@@ -386,6 +393,54 @@ static const struct platform_suspend_ops am33xx_pm_ops = {
 };
 #endif /* CONFIG_SUSPEND */
 
+static void am33xx_scale_data_fw_cb(const struct firmware *fw, void *context)
+{
+	unsigned long val, aux_base;
+	struct wkup_m3_scale_data_header hdr;
+
+	if (!fw) {
+		pr_info("PM: Voltage scale fw name given but file missing.\n");
+		return;
+	}
+
+	memcpy(&hdr, fw->data, sizeof(hdr));
+
+	if (hdr.magic != WKUP_M3_SD_FW_MAGIC) {
+		pr_info("PM: Voltage Scale Data binary does not appear valid.\n");
+		goto release_sd_fw;
+	}
+
+	aux_base = wkup_m3_copy_aux_data(fw->data + sizeof(hdr),
+					 fw->size - sizeof(hdr));
+
+	val = (aux_base + hdr.sleep_offset);
+	val |= ((aux_base + hdr.wake_offset) << 16);
+
+	am33xx_pm->ipc.reg5 = val;
+
+release_sd_fw:
+	release_firmware(fw);
+};
+
+static int __init
+am33xx_init_scale_data(struct device *dev, const char *sd_fw_name)
+{
+	int ret = 0;
+
+	/*
+	 * If no name is provided, user has already been warned, pm will
+	 * still work so return 0
+	 */
+	if (!sd_fw_name)
+		return ret;
+
+	ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+			sd_fw_name, dev, GFP_KERNEL, NULL,
+			am33xx_scale_data_fw_cb);
+
+	return ret;
+}
+
 static void am33xx_txev_handler(void)
 {
 	switch (am33xx_pm->state) {
@@ -407,6 +462,8 @@ static void am33xx_txev_handler(void)
 
 static void am33xx_m3_ready_cb(struct device *m3_dev)
 {
+	int ret;
+
 	am33xx_pm->ver = wkup_m3_fw_version_read();
 
 	if (am33xx_pm->ver == M3_VERSION_UNKNOWN ||
@@ -424,6 +481,10 @@ static void am33xx_m3_ready_cb(struct device *m3_dev)
 	else if (soc_is_am437x())
 		am437x_idle_init();
 
+	ret = am33xx_init_scale_data(m3_dev, am33xx_pm->sd_fw_name);
+	if (ret)
+		pr_err("PM: Cannot load voltage scaling data blob: %d\n", ret);
+
 #ifdef CONFIG_SUSPEND
 	suspend_set_ops(&am33xx_pm_ops);
 #endif /* CONFIG_SUSPEND */
@@ -682,7 +743,14 @@ int __init am33xx_pm_init(void)
 
 		if (of_find_property(np, "ti,set-io-isolation", NULL))
 			am33xx_pm->ipc.reg4 |= (1 << IO_ISOLATION_STAT_SHIFT);
+
+		ret = of_property_read_string(np, "ti,scale-data-fw",
+					      &am33xx_pm->sd_fw_name);
+		if (ret) {
+			pr_warn("PM: Voltage scaling data blob not provided from DT.\n");
+		};
 	}
+
 #endif /* CONFIG_CPU_PM */
 
 	(void) clkdm_for_each(omap_pm_clkdms_setup, NULL);
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
index 5f72190..f448484 100644
--- a/arch/arm/mach-omap2/pm33xx.h
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -35,6 +35,7 @@ struct am33xx_pm_context {
 	struct am33xx_pm_ops	*ops;
 	u8			state;
 	u32			ver;
+	const char		*sd_fw_name;
 };
 
 /*
-- 
1.7.5.4

