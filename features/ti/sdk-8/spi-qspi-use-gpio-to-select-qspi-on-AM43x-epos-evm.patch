From 67c6580802eaf5ac7a72a48275341c9ee358014b Mon Sep 17 00:00:00 2001
From: Sourav Poddar <sourav.poddar@ti.com>
Date: Wed, 7 Aug 2013 11:15:41 +0530
Subject: [PATCH 0640/1587] spi/qspi: use gpio to select qspi on AM43x epos
 evm

On AM43x epos evm, use of qspi and Nand is mutually exclusive. There is
a gpio present which is used to select between qspi and Nand.

As far as kernel is concerned, idea is to enable both qspi and nand
in dts, and able to use one of them based on user requirement.

The patch below makes use of the module parameter(enable_qspi) and expects
nand to use something similar(enable_nand) to get around this.

With this approach,
QSPI on J6: Works fine.
QSPI on AM43x-epos-evm "with" enable_qspi=1 in bootargs works fine
and qspi flash gets selected.
QSPI on AM43x-epos-evm "without" enable_qspi in bootargs prints a
message in the bootlog that "flash not recognised" as the flash does
not get selected.

This may not be the good solution, posting this to get some more feedbacks
on handling this out in a better way.

Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/spi/spi-ti-qspi.c |   20 +++++++++++++++++++-
 1 files changed, 19 insertions(+), 1 deletions(-)

diff --git a/drivers/spi/spi-ti-qspi.c b/drivers/spi/spi-ti-qspi.c
index 98e2d52..4b67554 100644
--- a/drivers/spi/spi-ti-qspi.c
+++ b/drivers/spi/spi-ti-qspi.c
@@ -31,9 +31,14 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/pinctrl/consumer.h>
-
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <linux/spi/spi.h>
 
+static int enable_qspi;
+module_param(enable_qspi, int, 0);
+MODULE_PARM_DESC(enable_qspi, "enable qspi on AM437x board");
+
 struct ti_qspi_regs {
 	u32 clkctrl;
 };
@@ -494,6 +499,19 @@ static int ti_qspi_probe(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	u32 max_freq;
 	int ret = 0, num_cs, irq;
+	int gpio;
+	enum of_gpio_flags flags;
+
+	if (enable_qspi) {
+		gpio = of_get_named_gpio_flags(np, "qspi-gpio", 0, &flags);
+		if (gpio_is_valid(gpio)) {
+			gpio_request(gpio, "qspi");
+			gpio_direction_output(gpio, flags);
+		} else {
+			dev_err(&pdev->dev, "GPIO not available to select qspi");
+			return 0;
+		}
+	}
 
 	master = spi_alloc_master(&pdev->dev, sizeof(*qspi));
 	if (!master)
-- 
1.7.5.4

