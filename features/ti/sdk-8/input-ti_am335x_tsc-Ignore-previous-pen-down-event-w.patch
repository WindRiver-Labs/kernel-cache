From db442fc028d93f365cc69115d8872f129516cc03 Mon Sep 17 00:00:00 2001
From: Franklin S Cooper Jr <fcooper@ti.com>
Date: Fri, 6 Feb 2015 10:08:52 -0600
Subject: [PATCH 1580/1587] input: ti_am335x_tsc: Ignore previous pen down
 event when pen up event occurs

Frequently when a pen up event is detected the previous pen down event
would be incorrect. From a userspace perspective you will see an abnormal
jump when comparing the pen down events to the one right before the pen up
event.

To avoid this issue delay sending a pen down event until the next touch
event has occured. If the current touch event is not a pen up event then
send the previously detected pen down values. If the current touch event is
a pen up then simply ignore the previous pen down value.

Signed-off-by: Franklin S Cooper Jr. <fcooper@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/input/touchscreen/ti_am335x_tsc.c |   22 +++++++++++++++++-----
 1 files changed, 17 insertions(+), 5 deletions(-)

diff --git a/drivers/input/touchscreen/ti_am335x_tsc.c b/drivers/input/touchscreen/ti_am335x_tsc.c
index 40f1fad..0ea0249 100644
--- a/drivers/input/touchscreen/ti_am335x_tsc.c
+++ b/drivers/input/touchscreen/ti_am335x_tsc.c
@@ -53,6 +53,8 @@ struct titsc {
 	u32			inp_xp, inp_xn, inp_yp, inp_yn;
 	u32			step_mask;
 	u32			charge_delay;
+	u32			prev_x, prev_y, prev_z;
+	bool			event_pending;
 };
 
 static unsigned int titsc_readl(struct titsc *ts, unsigned int reg)
@@ -276,6 +278,15 @@ static irqreturn_t titsc_irq(int irq, void *dev)
 		input_report_abs(input_dev, ABS_PRESSURE, 0);
 		input_sync(input_dev);
 		irqclr |= IRQENB_PENUP;
+		ts_dev->event_pending = false;
+	}
+	else if (ts_dev->event_pending == true) {
+		input_report_abs(input_dev, ABS_X, ts_dev->prev_x);
+		input_report_abs(input_dev, ABS_Y, ts_dev->prev_y);
+		input_report_abs(input_dev, ABS_PRESSURE, ts_dev->prev_z);
+		input_report_key(input_dev, BTN_TOUCH, 1);
+		input_sync(input_dev);
+		ts_dev->event_pending = false;
 	}
 
 	if (status & IRQENB_EOS)
@@ -302,11 +313,10 @@ static irqreturn_t titsc_irq(int irq, void *dev)
 			z = (z + 2047) >> 12;
 
 			if (z <= MAX_12BIT) {
-				input_report_abs(input_dev, ABS_X, x);
-				input_report_abs(input_dev, ABS_Y, y);
-				input_report_abs(input_dev, ABS_PRESSURE, z);
-				input_report_key(input_dev, BTN_TOUCH, 1);
-				input_sync(input_dev);
+				ts_dev->prev_x = x;
+				ts_dev->prev_y = y;
+				ts_dev->prev_z = z;
+				ts_dev->event_pending = true;
 			}
 		}
 		irqclr |= IRQENB_FIFO0THRES;
@@ -396,6 +406,7 @@ static int titsc_probe(struct platform_device *pdev)
 	ts_dev->mfd_tscadc = tscadc_dev;
 	ts_dev->input = input_dev;
 	ts_dev->irq = tscadc_dev->irq;
+	ts_dev->event_pending = false;
 
 	err = titsc_parse_dt(pdev, ts_dev);
 	if (err) {
@@ -472,6 +483,7 @@ static int titsc_suspend(struct device *dev)
 	struct ti_tscadc_dev *tscadc_dev;
 	unsigned int idle;
 
+	ts_dev->event_pending = false;
 	tscadc_dev = ti_tscadc_dev_get(to_platform_device(dev));
 	if (device_may_wakeup(tscadc_dev->dev)) {
 		idle = titsc_readl(ts_dev, REG_IRQENABLE);
-- 
1.7.5.4

