From 7abe48fa99d506cb66e80c0b9a85eb8d2918c9a4 Mon Sep 17 00:00:00 2001
From: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date: Mon, 29 Sep 2014 15:42:25 +0000
Subject: [PATCH 1248/1587] ASoC: davinci-mcasp: Save and restore the
 serializer registers on suspend

If the board is suspended to a deep sleep state McASP is going to loose it's
context. We also need to save and restore the configuration of the McASP
serializers.
Since the number of serializers depend on the SoC we need to allocate the
memory for them dynamically.

Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
Signed-off-by: Darren Etheridge <detheridge@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 sound/soc/davinci/davinci-mcasp.c |   14 ++++++++++++++
 1 files changed, 14 insertions(+), 0 deletions(-)

diff --git a/sound/soc/davinci/davinci-mcasp.c b/sound/soc/davinci/davinci-mcasp.c
index 01489d2..862bdf5 100644
--- a/sound/soc/davinci/davinci-mcasp.c
+++ b/sound/soc/davinci/davinci-mcasp.c
@@ -58,6 +58,7 @@ struct davinci_mcasp_context {
 	u32	txtdm;
 	u32	rfifoctl;
 	u32	wfifoctl;
+	u32	*xrsrctl;
 };
 
 struct davinci_mcasp {
@@ -882,6 +883,7 @@ static int davinci_mcasp_suspend(struct snd_soc_dai *dai)
 {
 	struct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);
 	struct davinci_mcasp_context *context = &mcasp->context;
+	int i;
 	u32 reg;
 
 	context->txfmtctl = mcasp_get_reg(mcasp, DAVINCI_MCASP_TXFMCTL_REG);
@@ -905,6 +907,9 @@ static int davinci_mcasp_suspend(struct snd_soc_dai *dai)
 		reg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;
 		context->rfifoctl = mcasp_get_reg(mcasp, reg);
 	}
+	for (i = 0; i < mcasp->num_serializer; i++)
+		context->xrsrctl[i] = mcasp_get_reg(mcasp,
+						DAVINCI_MCASP_XRSRCTL_REG(i));
 
 	return 0;
 }
@@ -913,6 +918,7 @@ static int davinci_mcasp_resume(struct snd_soc_dai *dai)
 {
 	struct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);
 	struct davinci_mcasp_context *context = &mcasp->context;
+	int i;
 	u32 reg;
 
 	mcasp_set_reg(mcasp, DAVINCI_MCASP_TXFMCTL_REG, context->txfmtctl);
@@ -936,6 +942,9 @@ static int davinci_mcasp_resume(struct snd_soc_dai *dai)
 		reg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;
 		mcasp_set_reg(mcasp, reg, context->rfifoctl);
 	}
+	for (i = 0; i < mcasp->num_serializer; i++)
+		mcasp_set_reg(mcasp, DAVINCI_MCASP_XRSRCTL_REG(i),
+			      context->xrsrctl[i]);
 
 	return 0;
 }
@@ -1254,6 +1263,11 @@ static int davinci_mcasp_probe(struct platform_device *pdev)
 	mcasp->op_mode = pdata->op_mode;
 	mcasp->tdm_slots = pdata->tdm_slots;
 	mcasp->num_serializer = pdata->num_serializer;
+#ifdef CONFIG_PM_SLEEP
+	mcasp->context.xrsrctl = devm_kzalloc(&pdev->dev,
+					sizeof(u32) * mcasp->num_serializer,
+					GFP_KERNEL);
+#endif
 	mcasp->serial_dir = pdata->serial_dir;
 	mcasp->version = pdata->version;
 	mcasp->txnumevt = pdata->txnumevt;
-- 
1.7.5.4

