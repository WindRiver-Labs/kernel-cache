From 43a4f4bded39ae3f5f0ba25cfc258369c82ff3b5 Mon Sep 17 00:00:00 2001
From: Tero Kristo <t-kristo@ti.com>
Date: Fri, 29 Aug 2014 10:04:14 +0300
Subject: [PATCH 1073/1587] clk: ti: change clock init to use generic
 of_clk_init

commit c08ee14cc6634457948bc5e26584697208baa02a upstream

Previously, the TI clock driver initialized all the clocks hierarchically
under each separate clock provider node. Now, each clock that requires
IO access will instead check their parent node to find out which IO range
to use.

This patch allows the TI clock driver to use a few new features provided
by the generic of_clk_init, and also allows registration of clock nodes
outside the clock hierarchy (for example, any external clocks.)

This patch also effectively reverts cf345a4e7213d0a662683591dcec6779832da67e
as the retry mechanism for clockdomain init is no longer needed.

Signed-off-by: Tero Kristo <t-kristo@ti.com>
Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
Cc: Jyri Sarha <jsarha@ti.com>
Tested-by: Jyri Sarha <jsarha@ti.com>
---
 arch/arm/mach-omap2/io.c         |   10 ++++-
 arch/arm/mach-omap2/prm_common.c |    1 -
 drivers/clk/ti/clk.c             |   31 ++++++++-------
 drivers/clk/ti/clockdomain.c     |   78 ++++++--------------------------------
 include/linux/clk/ti.h           |    2 +-
 5 files changed, 37 insertions(+), 85 deletions(-)

diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c
index 8291e31..1d420ff 100644
--- a/arch/arm/mach-omap2/io.c
+++ b/arch/arm/mach-omap2/io.c
@@ -745,8 +745,14 @@ int __init omap_clk_init(void)
 		return ret;
 
 	ret = of_prcm_init();
-	if (!ret)
-		ret = omap_clk_soc_init();
+	if (ret)
+		return ret;
+
+	of_clk_init(NULL);
+
+	ti_dt_clockdomains_setup();
+
+	ret = omap_clk_soc_init();
 
 	return ret;
 }
diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index ae29cc1..d243fdf 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -514,7 +514,6 @@ int __init of_prcm_module_init(struct of_device_id *match_table)
 		mem = of_iomap(np, 0);
 		clk_memmaps[prcm_memmap_index] = mem;
 		ti_dt_clk_init_provider(np, prcm_memmap_index);
-		ti_dt_clockdomains_setup(np);
 		prcm_memmap_index++;
 	}
 
diff --git a/drivers/clk/ti/clk.c b/drivers/clk/ti/clk.c
index b1a6f71..f7201d0 100644
--- a/drivers/clk/ti/clk.c
+++ b/drivers/clk/ti/clk.c
@@ -25,8 +25,8 @@
 #undef pr_fmt
 #define pr_fmt(fmt) "%s: " fmt, __func__
 
-static int ti_dt_clk_memmap_index;
 struct ti_clk_ll_ops *ti_clk_ll_ops;
+static struct device_node *clocks_node_ptr[CLK_MAX_MEMMAPS];
 
 /**
  * ti_dt_clocks_register - register DT alias clocks during boot
@@ -108,9 +108,21 @@ void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
 	struct clk_omap_reg *reg;
 	u32 val;
 	u32 tmp;
+	int i;
 
 	reg = (struct clk_omap_reg *)&tmp;
-	reg->index = ti_dt_clk_memmap_index;
+
+	for (i = 0; i < CLK_MAX_MEMMAPS; i++) {
+		if (clocks_node_ptr[i] == node->parent)
+			break;
+	}
+
+	if (i == CLK_MAX_MEMMAPS) {
+		pr_err("clk-provider not found for %s!\n", node->name);
+		return NULL;
+	}
+
+	reg->index = i;
 
 	if (of_property_read_u32_index(node, "reg", index, &val)) {
 		pr_err("%s must have reg[%d]!\n", node->name, index);
@@ -133,15 +145,10 @@ void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index)
  */
 void ti_dt_clk_init_provider(struct device_node *parent, int index)
 {
-	const struct of_device_id *match;
-	struct device_node *np;
 	struct device_node *clocks;
-	of_clk_init_cb_t clk_init_cb;
 	struct clk_init_item *retry;
 	struct clk_init_item *tmp;
 
-	ti_dt_clk_memmap_index = index;
-
 	/* get clocks for this parent */
 	clocks = of_get_child_by_name(parent, "clocks");
 	if (!clocks) {
@@ -149,14 +156,8 @@ void ti_dt_clk_init_provider(struct device_node *parent, int index)
 		return;
 	}
 
-	for_each_child_of_node(clocks, np) {
-		match = of_match_node(&__clk_of_table, np);
-		if (!match)
-			continue;
-		clk_init_cb = (of_clk_init_cb_t)match->data;
-		pr_debug("%s: initializing: %s\n", __func__, np->name);
-		clk_init_cb(np);
-	}
+	/* add clocks node info */
+	clocks_node_ptr[index] = clocks;
 
 	list_for_each_entry_safe(retry, tmp, &retry_list, link) {
 		pr_debug("retry-init: %s\n", retry->node->name);
diff --git a/drivers/clk/ti/clockdomain.c b/drivers/clk/ti/clockdomain.c
index 29fa543..4a1eb17 100644
--- a/drivers/clk/ti/clockdomain.c
+++ b/drivers/clk/ti/clockdomain.c
@@ -24,60 +24,27 @@
 #undef pr_fmt
 #define pr_fmt(fmt) "%s: " fmt, __func__
 
-struct clkdm_init_item {
-	struct device_node *node;
-	int index;
-	struct list_head link;
-};
-
-static LIST_HEAD(retry_list);
-
-static int of_ti_init_clk_clkdm(struct device_node *node, int index)
+static void __init of_ti_clockdomain_setup(struct device_node *node)
 {
 	struct clk *clk;
 	struct clk_hw *clk_hw;
-
-	clk = of_clk_get(node, index);
-
-	if (IS_ERR_OR_NULL(clk)) {
-		pr_debug("%s[%d] = %08x\n", node->name, index, (u32)clk);
-		return -EBUSY;
-	}
-
-	if (__clk_get_flags(clk) & CLK_IS_BASIC) {
-		pr_warn("can't setup clkdm for basic clk %s\n",
-			__clk_get_name(clk));
-		return -EINVAL;
-	}
-
-	clk_hw = __clk_get_hw(clk);
-	to_clk_hw_omap(clk_hw)->clkdm_name = node->name;
-	omap2_init_clk_clkdm(clk_hw);
-
-	return 0;
-}
-
-static void __init of_ti_clockdomain_setup(struct device_node *node)
-{
+	const char *clkdm_name = node->name;
 	int i;
 	int num_clks;
-	struct clkdm_init_item *retry;
-	int ret;
 
 	num_clks = of_count_phandle_with_args(node, "clocks", "#clock-cells");
 
 	for (i = 0; i < num_clks; i++) {
-		ret = of_ti_init_clk_clkdm(node, i);
-
-		if (ret == -EBUSY) {
-			retry = kzalloc(sizeof(*retry), GFP_KERNEL);
-			if (!retry)
-				return;
-			retry->node = node;
-			retry->index = i;
-			list_add(&retry->link, &retry_list);
+		clk = of_clk_get(node, i);
+		if (__clk_get_flags(clk) & CLK_IS_BASIC) {
+			pr_warn("can't setup clkdm for basic clk %s\n",
+				__clk_get_name(clk));
 			continue;
 		}
+
+		clk_hw = __clk_get_hw(clk);
+		to_clk_hw_omap(clk_hw)->clkdm_name = clkdm_name;
+		omap2_init_clk_clkdm(clk_hw);
 	}
 }
 
@@ -95,31 +62,10 @@ static struct of_device_id ti_clkdm_match_table[] __initdata = {
  * called after rest of the DT clock init has completed and all
  * clock nodes have been registered.
  */
-void __init ti_dt_clockdomains_setup(struct device_node *node)
+void __init ti_dt_clockdomains_setup(void)
 {
 	struct device_node *np;
-	struct device_node *clkdms;
-	struct clkdm_init_item *retry, *tmp;
-	int ret;
-
-	clkdms = of_get_child_by_name(node, "clockdomains");
-	if (!clkdms)
-		return;
-
-	list_for_each_entry_safe(retry, tmp, &retry_list, link) {
-		pr_debug("retry-init: %s [%d]\n", retry->node->name,
-			 retry->index);
-		ret = of_ti_init_clk_clkdm(retry->node, retry->index);
-		if (!ret) {
-			list_del(&retry->link);
-			kfree(retry);
-		}
-	}
-
-	for_each_child_of_node(clkdms, np) {
-		if (!of_match_node(ti_clkdm_match_table, np))
-			continue;
-
+	for_each_matching_node(np, ti_clkdm_match_table) {
 		of_ti_clockdomain_setup(np);
 	}
 }
diff --git a/include/linux/clk/ti.h b/include/linux/clk/ti.h
index 845f640..e8d8a35 100644
--- a/include/linux/clk/ti.h
+++ b/include/linux/clk/ti.h
@@ -292,7 +292,7 @@ void omap2xxx_clkt_vps_init(void);
 void __iomem *ti_clk_get_reg_addr(struct device_node *node, int index);
 void ti_dt_clocks_register(struct ti_dt_clk *oclks);
 void ti_dt_clk_init_provider(struct device_node *np, int index);
-void ti_dt_clockdomains_setup(struct device_node *node);
+void ti_dt_clockdomains_setup(void);
 int ti_clk_retry_init(struct device_node *node, struct clk_hw *hw,
 		      ti_of_clk_init_cb_t func);
 int of_ti_clk_autoidle_setup(struct device_node *node);
-- 
1.7.5.4

