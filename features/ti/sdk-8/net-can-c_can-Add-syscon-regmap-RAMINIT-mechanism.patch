From 6b7b2e6e1418ed97c6fe98adee562219595960a1 Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Fri, 15 Aug 2014 16:01:57 +0300
Subject: [PATCH 1000/1587] net: can: c_can: Add syscon/regmap RAMINIT
 mechanism

Some TI SoCs like DRA7 have a RAMINIT register specification
different from the other AMxx SoCs and as expected by the
existing driver.

To add more insanity, this register is shared with other
IPs like DSS, PCIe and PWM.

Provides a more generic mechanism to specify the RAMINIT
register location and START/DONE bit position and use the
syscon/regmap framework to access the register.

If syscon phandle is not provided in device tree, it falls back
to the old behaviour.

Signed-off-by: Roger Quadros <rogerq@ti.com>
Reviewed-by: Felipe Balbi <balbi@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 .../devicetree/bindings/net/can/c_can.txt          |    7 ++
 drivers/net/can/c_can/c_can.h                      |    4 +
 drivers/net/can/c_can/c_can_platform.c             |   69 ++++++++++++++++++++
 3 files changed, 80 insertions(+), 0 deletions(-)

diff --git a/Documentation/devicetree/bindings/net/can/c_can.txt b/Documentation/devicetree/bindings/net/can/c_can.txt
index 8f1ae81..2f69182 100644
--- a/Documentation/devicetree/bindings/net/can/c_can.txt
+++ b/Documentation/devicetree/bindings/net/can/c_can.txt
@@ -13,6 +13,13 @@ Optional properties:
 - ti,hwmods		: Must be "d_can<n>" or "c_can<n>", n being the
 			  instance number
 
+- syscon		: Handle to system control region that contains the
+			  RAMINIT register. If specified, the second memory resource
+			  in the reg property must index into the RAMINIT
+			  register within the syscon region
+- raminit-start-bit	: Bit posistion of START bit in the RAMINIT register
+- raminit-done-bit	: Bit position of DONE bit in the RAMINIT register
+
 Note: "ti,hwmods" field is used to fetch the base address and irq
 resources from TI, omap hwmod data base during device registration.
 Future plan is to migrate hwmod data base contents into device tree
diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index d2e1c21..896430c 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -170,6 +170,10 @@ struct c_can_priv {
 	u16 irqstatus;
 	enum c_can_dev_id type;
 	u32 __iomem *raminit_ctrlreg;
+	struct regmap *syscon;		/* Alternative raminit reg. access */
+	unsigned int raminit_idx;	/* register index within syscon */
+	u8 raminit_start_bit;	/* START bit position in raminit reg. */
+	u8 raminit_done_bit;	/* DONE bit position in raminit reg. */
 	unsigned int instance;
 	void (*raminit) (const struct c_can_priv *priv, bool enable);
 };
diff --git a/drivers/net/can/c_can/c_can_platform.c b/drivers/net/can/c_can/c_can_platform.c
index f4073b9..902fe20 100644
--- a/drivers/net/can/c_can/c_can_platform.c
+++ b/drivers/net/can/c_can/c_can_platform.c
@@ -32,6 +32,8 @@
 #include <linux/clk.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
 
 #include <linux/can/dev.h>
 
@@ -81,6 +83,22 @@ static void c_can_hw_raminit(const struct c_can_priv *priv, bool enable)
 	writel(val, priv->raminit_ctrlreg);
 }
 
+static void c_can_syscon_raminit(const struct c_can_priv *priv, bool enable)
+{
+	u32 mask;
+
+	if (IS_ERR(priv->syscon))
+		return;
+
+	mask = 1 << priv->raminit_start_bit;
+
+	if (enable)
+		regmap_update_bits(priv->syscon, priv->raminit_idx,
+				   mask, mask);
+	else
+		regmap_update_bits(priv->syscon, priv->raminit_idx, mask, 0);
+}
+
 static struct platform_device_id c_can_id_table[] = {
 	[BOSCH_C_CAN_PLATFORM] = {
 		.name = KBUILD_MODNAME,
@@ -116,6 +134,7 @@ static int c_can_plat_probe(struct platform_device *pdev)
 	struct resource *mem, *res;
 	int irq;
 	struct clk *clk;
+	struct device_node *np = pdev->dev.of_node;
 
 	if (pdev->dev.of_node) {
 		match = of_match_device(c_can_of_table, &pdev->dev);
@@ -188,6 +207,56 @@ static int c_can_plat_probe(struct platform_device *pdev)
 		priv->read_reg = c_can_plat_read_reg_aligned_to_16bit;
 		priv->write_reg = c_can_plat_write_reg_aligned_to_16bit;
 
+		/* Try if syscon property exists */
+		if (np)
+			priv->syscon = syscon_regmap_lookup_by_phandle(np,
+								       "syscon");
+		ret = -EINVAL;
+		if (!IS_ERR(priv->syscon)) {
+			u32 val;
+
+			res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+			if (!res) {
+				dev_err(&pdev->dev,
+					"missing memory resource 1\n");
+				goto exit_free_device;
+			}
+			priv->raminit_idx = res->start;
+
+			if (of_property_read_u32(np, "raminit-start-bit",
+						 &val)) {
+				dev_err(&pdev->dev,
+					"missing raminit-start-bit property\n");
+				goto exit_free_device;
+			}
+
+			if (val > 31) {
+				dev_err(&pdev->dev,
+					"invalid raminit-start-bit property\n");
+				goto exit_free_device;
+			}
+
+			priv->raminit_start_bit = val & 0x1f;
+
+			if (of_property_read_u32(np, "raminit-done-bit",
+						 &val)) {
+				dev_err(&pdev->dev,
+					"missing raminit-done-bit property\n");
+				goto exit_free_device;
+			}
+
+			if (val > 31) {
+				dev_err(&pdev->dev,
+					"invalid raminit-done-bit property\n");
+				goto exit_free_device;
+			}
+
+			priv->raminit_done_bit = val & 0x1f;
+			priv->raminit = c_can_syscon_raminit;
+			break;	/* skip the non syscon method */
+		}
+
+		/* non syscon method */
 		if (pdev->dev.of_node)
 			priv->instance = of_alias_get_id(pdev->dev.of_node, "d_can");
 		else
-- 
1.7.5.4

