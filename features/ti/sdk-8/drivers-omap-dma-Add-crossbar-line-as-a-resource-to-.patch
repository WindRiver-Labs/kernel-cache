From 568f5de81ccd78ba18a38243d5a54d764e5174e9 Mon Sep 17 00:00:00 2001
From: R Sricharan <r.sricharan@ti.com>
Date: Fri, 7 Mar 2014 17:46:11 +0530
Subject: [PATCH 1048/1587] drivers: omap-dma: Add crossbar line as a resource
 to omap_chan structure

In socs which have crossbar to route the peripheral dma request
line to the dma controller, only the peripheral crossbar request line
number is fixed and this is passed through the DT nodes. The dma request
channel to be used is allocated dynamically.

The total number of crossbar channels are registered during probe a
the dma request line free is mapped using the registered router's map function
during the device_alloc_chan_resource callback and freed with free_resource.
When a router is not registered, the dma request number is same as the
crossbar number.

Signed-off-by: R Sricharan <r.sricharan@ti.com>
Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/dma/omap-dma.c |   21 ++++++++++++++++-----
 1 files changed, 16 insertions(+), 5 deletions(-)

diff --git a/drivers/dma/omap-dma.c b/drivers/dma/omap-dma.c
index 5788ea1..2a86797 100644
--- a/drivers/dma/omap-dma.c
+++ b/drivers/dma/omap-dma.c
@@ -47,6 +47,7 @@ struct omap_chan {
 	struct dma_xbar_device *router;
 
 	unsigned dma_sig;
+	unsigned dma_xbar;
 	bool cyclic;
 	bool paused;
 
@@ -530,6 +531,11 @@ static int omap_dma_alloc_chan_resources(struct dma_chan *chan)
 	struct omap_chan *c = to_omap_dma_chan(chan);
 	int ret;
 
+	if (c->router)
+		c->dma_sig = c->router->ops->map(c->dma_xbar, c->router);
+	else
+		c->dma_sig = c->dma_xbar;
+
 	if (od->legacy) {
 		ret = omap_request_dma(c->dma_sig, "DMA engine",
 				       omap_dma_callback, c, &c->dma_ch);
@@ -539,7 +545,7 @@ static int omap_dma_alloc_chan_resources(struct dma_chan *chan)
 	}
 
 	dev_dbg(od->ddev.dev, "allocating channel %u for %u\n",
-		c->dma_ch, c->dma_sig);
+		c->dma_ch, c->dma_xbar);
 
 	if (ret >= 0) {
 		omap_dma_assign(od, c, c->dma_ch);
@@ -594,9 +600,14 @@ static void omap_dma_free_chan_resources(struct dma_chan *chan)
 	od->lch_map[c->dma_ch] = NULL;
 	vchan_free_chan_resources(&c->vc);
 
+	if (c->router) {
+		c->router->ops->unmap(c->dma_sig, c->router);
+		c->dma_sig = 0;
+	}
+
 	omap_free_dma(c->dma_ch);
 
-	dev_dbg(od->ddev.dev, "freeing channel for %u\n", c->dma_sig);
+	dev_dbg(od->ddev.dev, "freeing channel for %u\n", c->dma_xbar);
 }
 
 static size_t omap_dma_sg_size(struct omap_sg *sg)
@@ -1064,7 +1075,7 @@ static int omap_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 	return ret;
 }
 
-static int omap_dma_chan_init(struct omap_dmadev *od, int dma_sig)
+static int omap_dma_chan_init(struct omap_dmadev *od, int dma_xbar)
 {
 	struct omap_chan *c;
 
@@ -1073,7 +1084,7 @@ static int omap_dma_chan_init(struct omap_dmadev *od, int dma_sig)
 		return -ENOMEM;
 
 	c->reg_map = od->reg_map;
-	c->dma_sig = dma_sig;
+	c->dma_xbar = dma_xbar;
 	c->vc.desc_free = omap_dma_desc_free;
 	vchan_init(&c->vc, &od->ddev);
 	INIT_LIST_HEAD(&c->node);
@@ -1281,7 +1292,7 @@ bool omap_dma_filter_fn(struct dma_chan *chan, void *param)
 		struct omap_chan *c = to_omap_dma_chan(chan);
 		unsigned req = args->chan;
 
-		if (req == c->dma_sig) {
+		if (req == c->dma_xbar) {
 			c->router = args->router_data;
 			return true;
 		}
-- 
1.7.5.4

