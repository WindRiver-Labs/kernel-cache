From d1ece38a18c13e99e8e6cb4d58dff5c278a17676 Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Mon, 28 Apr 2014 10:49:43 +0000
Subject: [PATCH 0291/1587] dmaengine: edma: Make reading the position of
 active channels work

commit cdae05a0f0f7d15837dfd6f4200e8caea03c9cbf upstream

As Joel pointed out, edma_read_position() uses memcpy_fromio() to read
the parameter ram. That's not synchronized with the internal update as
it does a byte by byte copy. We need to do a 32bit read to get a
consistent value.

Further reading destination and source is pointless. In DEV_TO_MEM
transfers we are only interested in the destination, in MEM_TO_DEV we
care about the source. In MEM_TO_MEM it really does not matter which
one you read.

Simple solution: Remove the pointers, select dest/source via a bool
and return the read value.

Remove the export of this function while at it. The only potential
user is the dmaengine and that's always builtin.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Acked-by: Sekhar Nori <nsekhar@ti.com>
Signed-off-by: Joel Fernandes <joelf@ti.com>
Signed-off-by: Vinod Koul <vinod.koul@intel.com>
---
 arch/arm/common/edma.c             |   24 +++++++++---------------
 include/linux/platform_data/edma.h |    2 +-
 2 files changed, 10 insertions(+), 16 deletions(-)

diff --git a/arch/arm/common/edma.c b/arch/arm/common/edma.c
index 02daf9e..3ef06c4 100644
--- a/arch/arm/common/edma.c
+++ b/arch/arm/common/edma.c
@@ -994,29 +994,23 @@ void edma_set_dest(unsigned slot, dma_addr_t dest_port,
 EXPORT_SYMBOL(edma_set_dest);
 
 /**
- * edma_get_position - returns the current transfer points
+ * edma_get_position - returns the current transfer point
  * @slot: parameter RAM slot being examined
- * @src: pointer to source port position
- * @dst: pointer to destination port position
+ * @dst:  true selects the dest position, false the source
  *
- * Returns current source and destination addresses for a particular
- * parameter RAM slot.  Its channel should not be active when this is called.
+ * Returns the position of the current active slot
  */
-void edma_get_position(unsigned slot, dma_addr_t *src, dma_addr_t *dst)
+dma_addr_t edma_get_position(unsigned slot, bool dst)
 {
-	struct edmacc_param temp;
-	unsigned ctlr;
+	u32 offs, ctlr = EDMA_CTLR(slot);
 
-	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	edma_read_slot(EDMA_CTLR_CHAN(ctlr, slot), &temp);
-	if (src != NULL)
-		*src = temp.src;
-	if (dst != NULL)
-		*dst = temp.dst;
+	offs = PARM_OFFSET(slot);
+	offs += dst ? PARM_DST : PARM_SRC;
+
+	return edma_read(ctlr, offs);
 }
-EXPORT_SYMBOL(edma_get_position);
 
 /**
  * edma_set_src_index - configure DMA source address indexing
diff --git a/include/linux/platform_data/edma.h b/include/linux/platform_data/edma.h
index 923f8a3..12f134b 100644
--- a/include/linux/platform_data/edma.h
+++ b/include/linux/platform_data/edma.h
@@ -130,7 +130,7 @@ void edma_set_src(unsigned slot, dma_addr_t src_port,
 				enum address_mode mode, enum fifo_width);
 void edma_set_dest(unsigned slot, dma_addr_t dest_port,
 				 enum address_mode mode, enum fifo_width);
-void edma_get_position(unsigned slot, dma_addr_t *src, dma_addr_t *dst);
+dma_addr_t edma_get_position(unsigned slot, bool dst);
 void edma_set_src_index(unsigned slot, s16 src_bidx, s16 src_cidx);
 void edma_set_dest_index(unsigned slot, s16 dest_bidx, s16 dest_cidx);
 void edma_set_transfer_params(unsigned slot, u16 acnt, u16 bcnt, u16 ccnt,
-- 
1.7.5.4

