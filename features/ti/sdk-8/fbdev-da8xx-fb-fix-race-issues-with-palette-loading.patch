From eb8a8deb5ec2faf3e3b29fdaa3d83ca6e2333be6 Mon Sep 17 00:00:00 2001
From: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date: Thu, 16 Jan 2014 18:42:05 +0000
Subject: [PATCH 1582/1587] fbdev/da8xx-fb: fix race issues with palette
 loading

When the da8xx-fb sets up a new config, it first uses the DMA to load a
palette to the hardware and then sets up the DMA to send frame data.
This happens asynchronously, without locking, and causes race issues.
Furthermore, the whole DMA setup is not done if fbconsole is not
enabled.

This patch changes the palette loading to be synchronous, as it removes
any race issues and loading the palette should be a small operation. The
new function, lcd_load_palette, sets the DMA for palette loading, waits
for it to complete, and then sets up the DMA for frame data.

Also, the lcd_init function is changed to explicitly call
lcd_load_palette, so that everything is set up correctly without needing
fbconsole (or some other component) to activate the config.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Signed-off-by: Darren Etheridge <detheridge@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/video/da8xx-fb.c |   68 +++++++++++++++++++++++++++++++---------------
 1 files changed, 46 insertions(+), 22 deletions(-)

diff --git a/drivers/video/da8xx-fb.c b/drivers/video/da8xx-fb.c
index a1d74dd..115bb77 100644
--- a/drivers/video/da8xx-fb.c
+++ b/drivers/video/da8xx-fb.c
@@ -168,6 +168,9 @@ struct da8xx_fb_par {
 	int			vsync_timeout;
 	spinlock_t		lock_for_chan_update;
 
+	wait_queue_head_t	palette_wait;
+	int			palette_loaded_flag;
+
 	/*
 	 * LCDC has 2 ping pong DMA channels, channel 0
 	 * and channel 1.
@@ -357,6 +360,24 @@ static void lcd_blit(int load_mode, struct da8xx_fb_par *par)
 	lcd_enable_raster();
 }
 
+static void lcd_load_palette(struct da8xx_fb_par *par)
+{
+	int r;
+
+	par->palette_loaded_flag = 0;
+
+	lcd_blit(LOAD_PALETTE, par);
+
+	r = wait_event_interruptible_timeout(par->palette_wait,
+					       par->palette_loaded_flag != 0,
+					       msecs_to_jiffies(50));
+
+	if (r == 0)
+		pr_err("LCDC timeout when loading palette\n");
+
+	lcd_blit(LOAD_DATA, par);
+}
+
 /* Configure the Burst Size and fifo threhold of DMA */
 static int lcd_cfg_dma(int burst_size, int fifo_th)
 {
@@ -680,7 +701,7 @@ static int fb_setcolreg(unsigned regno, unsigned red, unsigned green,
 
 	/* Update the palette in the h/w as needed. */
 	if (update_hw)
-		lcd_blit(LOAD_PALETTE, par);
+		lcd_load_palette(par);
 
 	return 0;
 }
@@ -817,6 +838,8 @@ static int lcd_init(struct da8xx_fb_par *par, const struct lcd_ctrl_config *cfg,
 	if (ret < 0)
 		return ret;
 
+	lcd_load_palette(par);
+
 	/* Configure FDD */
 	lcdc_write((lcdc_read(LCD_RASTER_CTRL_REG) & 0xfff00fff) |
 		       (cfg->fdd << 12), LCD_RASTER_CTRL_REG);
@@ -848,8 +871,8 @@ static irqreturn_t lcdc_irq_handler_rev02(int irq, void *arg)
 		/* Disable PL completion interrupt */
 		lcdc_write(LCD_V2_PL_INT_ENA, LCD_INT_ENABLE_CLR_REG);
 
-		/* Setup and start data loading mode */
-		lcd_blit(LOAD_DATA, par);
+		par->palette_loaded_flag = 1;
+		wake_up_interruptible(&par->palette_wait);
 	} else {
 		lcdc_write(stat, LCD_MASKED_STAT_REG);
 
@@ -913,8 +936,8 @@ static irqreturn_t lcdc_irq_handler_rev01(int irq, void *arg)
 		reg_ras &= ~LCD_V1_PL_INT_ENA;
 		lcdc_write(reg_ras, LCD_RASTER_CTRL_REG);
 
-		/* Setup and start data loading mode */
-		lcd_blit(LOAD_DATA, par);
+		par->palette_loaded_flag = 1;
+		wake_up_interruptible(&par->palette_wait);
 	} else {
 		lcdc_write(stat, LCD_STAT_REG);
 
@@ -1460,6 +1483,18 @@ static int fb_probe(struct platform_device *device)
 		goto err_release_pl_mem;
 	}
 
+	if (lcd_revision == LCD_VERSION_1)
+		lcdc_irq_handler = lcdc_irq_handler_rev01;
+	else {
+		init_waitqueue_head(&frame_done_wq);
+		lcdc_irq_handler = lcdc_irq_handler_rev02;
+	}
+
+	ret = devm_request_irq(&device->dev, par->irq, lcdc_irq_handler, 0,
+			       DRIVER_NAME, par);
+	if (ret)
+		goto err_release_pl_mem;
+
 	da8xx_fb_var.grayscale =
 	    lcd_cfg->panel_shade == MONOCHROME ? 1 : 0;
 	da8xx_fb_var.bits_per_pixel = lcd_cfg->bpp;
@@ -1478,10 +1513,6 @@ static int fb_probe(struct platform_device *device)
 		goto err_release_pl_mem;
 	da8xx_fb_info->cmap.len = par->palette_sz;
 
-	/* initialize var_screeninfo */
-	da8xx_fb_var.activate = FB_ACTIVATE_FORCE;
-	fb_set_var(da8xx_fb_info, &da8xx_fb_var);
-
 	dev_set_drvdata(&device->dev, da8xx_fb_info);
 
 	/* initialize the vsync wait queue */
@@ -1490,6 +1521,12 @@ static int fb_probe(struct platform_device *device)
 	par->which_dma_channel_done = -1;
 	spin_lock_init(&par->lock_for_chan_update);
 
+	init_waitqueue_head(&par->palette_wait);
+
+	/* set var and par */
+	da8xx_fb_var.activate = FB_ACTIVATE_FORCE;
+	fb_set_var(da8xx_fb_info, &da8xx_fb_var);
+
 	/* Register the Frame Buffer  */
 	if (register_framebuffer(da8xx_fb_info) < 0) {
 		dev_err(&device->dev,
@@ -1506,22 +1543,9 @@ static int fb_probe(struct platform_device *device)
 	}
 #endif
 
-	if (lcd_revision == LCD_VERSION_1)
-		lcdc_irq_handler = lcdc_irq_handler_rev01;
-	else {
-		init_waitqueue_head(&frame_done_wq);
-		lcdc_irq_handler = lcdc_irq_handler_rev02;
-	}
-
-	ret = devm_request_irq(&device->dev, par->irq, lcdc_irq_handler, 0,
-			       DRIVER_NAME, par);
-	if (ret)
-		goto irq_freq;
 	return 0;
 
-irq_freq:
 #ifdef CONFIG_CPU_FREQ
-	lcd_da8xx_cpufreq_deregister(par);
 err_cpu_freq:
 #endif
 	unregister_framebuffer(da8xx_fb_info);
-- 
1.7.5.4

