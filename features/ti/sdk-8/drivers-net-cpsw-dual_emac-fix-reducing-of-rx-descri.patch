From 0954494c4533fe8e91586272a8d99b3e1e4462ee Mon Sep 17 00:00:00 2001
From: Mugunthan V N <mugunthanvnm@ti.com>
Date: Tue, 19 Aug 2014 21:29:49 +0530
Subject: [PATCH 1038/1587] drivers: net: cpsw: dual_emac: fix reducing of rx
 descriptor during ifdown

commit a0e2c822bf0a1095dc250b5875e39ac0662a5df6 upstream

In Dual EMAC, when both interface are up and while doing ifdown with heavy
traffic then skbs already processed by DMA from that slave emac has to be
requeued as still the other interface is up and running.

Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
---
 drivers/net/ethernet/ti/cpsw.c |   24 ++++++++++++++++++++++--
 1 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 9019720..291c6e1 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -700,8 +700,27 @@ static void cpsw_rx_handler(void *token, int len, int status)
 	cpsw_dual_emac_src_port_detect(status, priv, ndev, skb);
 
 	if (unlikely(status < 0) || unlikely(!netif_running(ndev))) {
-		/* the interface is going down, skbs are purged */
-		dev_kfree_skb_any(skb);
+		bool ndev_status = false;
+		struct cpsw_slave *slave = priv->slaves;
+		int n;
+
+		if (priv->data.dual_emac) {
+			/* In dual emac mode check for all interfaces */
+			for (n = priv->data.slaves; n; n--, slave++)
+				if (netif_running(slave->ndev))
+					ndev_status = true;
+		}
+
+		if (ndev_status) {
+			/* Though this interface is down, other interface is up
+			 * and running so requeue skb back to cpdma.
+			 */
+			new_skb = skb;
+			goto requeue;
+		} else {
+			/* the interface is going down, skbs are purged */
+			dev_kfree_skb_any(skb);
+		}
 		return;
 	}
 
@@ -718,6 +737,7 @@ static void cpsw_rx_handler(void *token, int len, int status)
 		new_skb = skb;
 	}
 
+requeue:
 	ret = cpdma_chan_submit(priv->rxch, new_skb, new_skb->data,
 			skb_tailroom(new_skb), 0);
 	if (WARN_ON(ret < 0))
-- 
1.7.5.4

