From 603a50803828a91babd486efe166fcd6ff9df38a Mon Sep 17 00:00:00 2001
From: Sundar Raman <sunds@ti.com>
Date: Mon, 11 Aug 2014 15:47:01 +0530
Subject: [PATCH 0979/1587] Input: atmel_mxt_ts: Add device tree support

Add device tree support for Atmel touch driver. All platform
specific data is now read from dts files and parsed inside the
driver.

Signed-off-by: Sundar Raman <sunds@ti.com>
Acked-by: Nishanth Menon <nm@ti.com>
[balbi@ti.com: add missing MODULE_DEVICE_TABLE]
Signed-off-by: Felipe Balbi <balbi@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/input/touchscreen/atmel_mxt_ts.c |  134 +++++++++++++++++++++++++++++-
 1 files changed, 130 insertions(+), 4 deletions(-)

diff --git a/drivers/input/touchscreen/atmel_mxt_ts.c b/drivers/input/touchscreen/atmel_mxt_ts.c
index 2e89606..69325a6 100644
--- a/drivers/input/touchscreen/atmel_mxt_ts.c
+++ b/drivers/input/touchscreen/atmel_mxt_ts.c
@@ -19,6 +19,8 @@
 #include <linux/input/mt.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 /* Version */
 #define MXT_VER_20		20
@@ -334,6 +336,105 @@ static void mxt_dump_message(struct device *dev,
 		message->reportid, 7, message->message);
 }
 
+static int mxt_of_get_platform_info(struct i2c_client *client,
+			     struct mxt_platform_data *pdata)
+
+{
+	int size, index = 0;
+	u32 val;
+	const __be32 *config_be;
+	u8 *config;
+	const char *pname;
+	struct device_node *node = client->dev.of_node;
+
+	config_be = of_get_property(node, "atmel,config", &size);
+	if (config_be && size) {
+		size /= sizeof(*config_be);
+		config = devm_kzalloc(&client->dev, size, GFP_KERNEL);
+		if (!config) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+
+		pdata->config = config;
+		pdata->config_length = size;
+
+		while (index < size) {
+			config[index] = be32_to_cpup(config_be + index) & 0xFF;
+			index++;
+		}
+	} else {
+		dev_dbg(&client->dev, "%s:no config data specified\n",
+			__func__);
+	}
+
+	pname = "atmel,x_line";
+	if (of_property_read_u32(node, pname, &pdata->x_line)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,y_line";
+	if (of_property_read_u32(node, pname, &pdata->y_line)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,x_size";
+	if (of_property_read_u32(node, pname, &pdata->x_size)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,y_size";
+	if (of_property_read_u32(node, pname, &pdata->y_size)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,blen";
+	if (of_property_read_u32(node, pname, &pdata->blen)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,threshold";
+	if (of_property_read_u32(node, pname, &pdata->threshold)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,voltage";
+	if (of_property_read_u32(node, pname, &pdata->voltage)) {
+		dev_err(&client->dev,
+			"%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	pname = "atmel,orient";
+	if (of_property_read_u32(node, pname, &val)) {
+		dev_err(&client->dev, "%s: Failed to read %s property\n",
+			__func__, pname);
+		return -EINVAL;
+	}
+
+	if (val > 0xFF) {
+		dev_err(&client->dev, "%s: Bad %s property value %d\n",
+			__func__, pname, val);
+		return -EINVAL;
+	}
+	pdata->orient = val & 0xFF;
+
+	return 0;
+}
+
 static int mxt_check_bootloader(struct i2c_client *client,
 				     unsigned int state)
 {
@@ -1126,17 +1227,41 @@ static void mxt_input_close(struct input_dev *dev)
 	mxt_stop(data);
 }
 
+static const struct of_device_id mxt_dt_ids[] = {
+	{ .compatible = "atmel,qt602240_ts", },
+	{ .compatible = "atmel,atmel_mxt_ts", },
+	{ .compatible = "atmel,mXT244", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, mxt_dt_ids);
+
 static int mxt_probe(struct i2c_client *client,
 		const struct i2c_device_id *id)
 {
-	const struct mxt_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct mxt_platform_data *pdata;
 	struct mxt_data *data;
 	struct input_dev *input_dev;
 	int error;
 	unsigned int num_mt_slots;
-
-	if (!pdata)
-		return -EINVAL;
+	const struct of_device_id *match;
+
+	match = of_match_device(of_match_ptr(mxt_dt_ids), &client->dev);
+	if (match) {
+		pdata = devm_kzalloc(&client->dev,
+					sizeof(struct mxt_platform_data),
+					GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+		error = mxt_of_get_platform_info(client, pdata);
+		if (error)
+			return error;
+	} else {
+		pdata = dev_get_platdata(&client->dev);
+		if (!pdata) {
+			dev_err(&client->dev, "Platform data not populated\n");
+			return -EINVAL;
+		}
+	}
 
 	data = devm_kzalloc(&client->dev, sizeof(struct mxt_data), GFP_KERNEL);
 	input_dev = input_allocate_device();
@@ -1323,6 +1448,7 @@ static struct i2c_driver mxt_driver = {
 		.name	= "atmel_mxt_ts",
 		.owner	= THIS_MODULE,
 		.pm	= &mxt_pm_ops,
+		.of_match_table = mxt_dt_ids,
 	},
 	.probe		= mxt_probe,
 	.remove		= mxt_remove,
-- 
1.7.5.4

