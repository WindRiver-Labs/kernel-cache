From 010cb066d0bb02ba2e9959d29752b488baaf1521 Mon Sep 17 00:00:00 2001
From: Nishanth Menon <nm@ti.com>
Date: Thu, 15 May 2014 13:33:45 -0500
Subject: [PATCH 0009/1587] PM / Voltagedomain: Add support for optimized
 voltage domains without ABB

Certain voltage domains such as core domain on OMAP5+ do not have
additional BodyBias voltage plane. However, these voltage domains do
have efuse encoded information for optimzed voltages.

So, define a new compatibility match for this.

Signed-off-by: Nishanth Menon <nm@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 .../bindings/power/voltdm/voltdm_omap.txt          |   16 +++++++++-
 drivers/power/voltdm/voltdm_omap.c                 |   34 +++++++++++++++-----
 2 files changed, 41 insertions(+), 9 deletions(-)

diff --git a/Documentation/devicetree/bindings/power/voltdm/voltdm_omap.txt b/Documentation/devicetree/bindings/power/voltdm/voltdm_omap.txt
index 33df151..cb1fb31 100644
--- a/Documentation/devicetree/bindings/power/voltdm/voltdm_omap.txt
+++ b/Documentation/devicetree/bindings/power/voltdm/voltdm_omap.txt
@@ -11,8 +11,11 @@ Required Properties:
 	"ti,omap-voltdm" - basic voltage domain controlling VDD and VBB
 	"ti,omap5-voltdm" - OMAP5+ optimized voltages in efuse(class0)VDD
 			    along with VBB
+	"ti,omap5-core-voltdm" - OMAP5+ optimized voltages in efuse(vlass0) VDD
+			    but no VBB.
 - vdd-supply: phandle to regulator controlling VDD supply
-- vbb-supply: phandle to regulator controlling Body Bias supply
+- vbb-supply: phandle to regulator controlling Body Bias supply (optional if
+  "ti,omap5-core-voltdm")
   (Usually Adaptive Body Bias regulator)
 - #voltdm-cells: shall be <0>
 - reg: Address and length of the efuse register set for the device (mandatory
@@ -44,3 +47,14 @@ voltdm_mpu: voltdm@4a003b20 {
 	1210000 0x8
 	>;
 };
+
+voltdm_core: voltdm@4a003d20 {
+	compatible = "ti,omap5-core-voltdm";
+	#voltdm-cells = <0>;
+	vdd-supply = <&smps4>;
+	reg = <0x4a003b20 0x4>;
+	ti,efuse-settings = <
+	/* uV   offset */
+	1060000 0x0
+	>;
+};
diff --git a/drivers/power/voltdm/voltdm_omap.c b/drivers/power/voltdm/voltdm_omap.c
index 9131235..339ec30 100644
--- a/drivers/power/voltdm/voltdm_omap.c
+++ b/drivers/power/voltdm/voltdm_omap.c
@@ -57,6 +57,7 @@ struct omap_voltdm_data {
 struct omap_voltdm_of_data {
 	const struct pm_voltdm_desc *desc;
 #define VOLTDM_EFUSE_CLASS0_OPTIMIZED_VOLTAGE	BIT(1)
+#define VOLTDM_HAS_NO_ABB			BIT(2)
 	const u8 flags;
 	const u32 efuse_voltage_mask;
 	const bool efuse_voltage_uv;
@@ -234,7 +235,7 @@ static int omap_voltdm_do_transition(struct device *dev,
 	do_abb_first = clk_notifier_flags == ABORT_RATE_CHANGE ||
 	    clk_notifier_flags == POST_RATE_CHANGE;
 
-	if (do_abb_first) {
+	if (do_abb_first && !IS_ERR(data->vbb_reg)) {
 		dev_dbg(dev, "vbb pre %duV[tol %duV]\n", uv, tol_uv);
 		ret = regulator_set_voltage_tol(data->vbb_reg, uv, tol_uv);
 		if (ret) {
@@ -256,7 +257,7 @@ static int omap_voltdm_do_transition(struct device *dev,
 		return ret;
 	}
 
-	if (!do_abb_first) {
+	if (!do_abb_first && !IS_ERR(data->vbb_reg)) {
 		dev_dbg(dev, "vbb post %duV[tol %duV]\n", uv, tol_uv);
 		ret = regulator_set_voltage_tol(data->vbb_reg, uv, tol_uv);
 		if (ret) {
@@ -301,6 +302,9 @@ static int omap_voltdm_latency(struct device *dev, void *voltdm_data,
 	tot_latency += ret;
 
 skip_vdd:
+	if (IS_ERR(data->vbb_reg))
+		goto skip_vbb;
+
 	ret = regulator_set_voltage_time(data->vbb_reg, min, max);
 	if (ret < 0) {
 		dev_dbg(dev, "vbb failed voltage latency: %d\n", ret);
@@ -380,11 +384,16 @@ static int omap_voltdm_get(struct device *voltdm_dev,
 		goto out_unreg;
 	}
 
-	data->vbb_reg = regulator_get(request_dev, "vbb");
-	if (IS_ERR(data->vbb_reg)) {
-		ret = PTR_ERR(data->vbb_reg);
-		dev_err(voltdm_dev, "Unable to get vbb regulator:%d\n", ret);
-		goto out_vdd_reg;
+	if (of_data->flags & VOLTDM_HAS_NO_ABB) {
+		data->vbb_reg = ERR_PTR(-ENODEV);
+	} else {
+		data->vbb_reg = regulator_get(request_dev, "vbb");
+		if (IS_ERR(data->vbb_reg)) {
+			ret = PTR_ERR(data->vbb_reg);
+			dev_err(voltdm_dev, "Unable to get vbb regulator:%d\n",
+				ret);
+			goto out_vdd_reg;
+		}
 	}
 
 	*voltdm_data = data;
@@ -419,7 +428,8 @@ static void omap_voltdm_put(struct device *voltdm_dev,
 	/* We dont expect voltdm layer to make mistakes.. but still */
 	BUG_ON(!data || !voltdm_dev || !request_dev);
 
-	regulator_put(data->vbb_reg);
+	if (!IS_ERR(data->vbb_reg))
+		regulator_put(data->vbb_reg);
 	regulator_put(data->vdd_reg);
 	regulator_unregister_supply_alias(request_dev, "vbb");
 	regulator_unregister_supply_alias(request_dev, "vdd");
@@ -450,9 +460,17 @@ static const struct omap_voltdm_of_data omap_omap5_of_data = {
 	.efuse_voltage_uv = false,
 };
 
+static const struct omap_voltdm_of_data omap_omap5core_of_data = {
+	.desc = &omap_voltdm_desc,
+	.flags = VOLTDM_EFUSE_CLASS0_OPTIMIZED_VOLTAGE | VOLTDM_HAS_NO_ABB,
+	.efuse_voltage_mask = 0xFFF,
+	.efuse_voltage_uv = false,
+};
+
 static const struct of_device_id omap_voltdm_of_match[] = {
 	{.compatible = "ti,omap-voltdm", .data = &omap_generic_of_data},
 	{.compatible = "ti,omap5-voltdm", .data = &omap_omap5_of_data},
+	{.compatible = "ti,omap5-core-voltdm", .data = &omap_omap5core_of_data},
 	{},
 };
 
-- 
1.7.5.4

