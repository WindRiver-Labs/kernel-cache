From cfcb74672dcb0e53d720604ee8a540e5a64197a2 Mon Sep 17 00:00:00 2001
From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Fri, 8 Nov 2013 14:53:35 +0000
Subject: [PATCH 0686/1587] ARM: omap: remove almost-const variables

commit ad0c381a8b3a15b8edfca0996729ea45692470ca upstream

dma_stride and dma_common_ch_start are only ever initialised to one
known value at initialisation, and are private to each of these files.
There's no point these being variables at all.

Acked-by: Tony Lindgren <tony@atomide.com>
Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
---
 arch/arm/mach-omap1/dma.c |   14 ++++----------
 arch/arm/mach-omap2/dma.c |   14 +++++---------
 2 files changed, 9 insertions(+), 19 deletions(-)

diff --git a/arch/arm/mach-omap1/dma.c b/arch/arm/mach-omap1/dma.c
index d292055..11f0b0e 100644
--- a/arch/arm/mach-omap1/dma.c
+++ b/arch/arm/mach-omap1/dma.c
@@ -36,8 +36,6 @@
 
 static u32 errata;
 static u32 enable_1510_mode;
-static u8 dma_stride;
-static enum omap_reg_offsets dma_common_ch_start, dma_common_ch_end;
 
 static u16 reg_map[] = {
 	[GCR]		= 0x400,
@@ -184,7 +182,7 @@ static inline void dma_write(u32 val, int reg, int lch)
 	u8  stride;
 	u32 offset;
 
-	stride = (reg >= dma_common_ch_start) ? dma_stride : 0;
+	stride = (reg >= CPC) ? OMAP1_DMA_STRIDE : 0;
 	offset = reg_map[reg] + (stride * lch);
 
 	__raw_writew(val, dma_base + offset);
@@ -200,7 +198,7 @@ static inline u32 dma_read(int reg, int lch)
 	u8 stride;
 	u32 offset, val;
 
-	stride = (reg >= dma_common_ch_start) ? dma_stride : 0;
+	stride = (reg >= CPC) ? OMAP1_DMA_STRIDE : 0;
 	offset = reg_map[reg] + (stride * lch);
 
 	val = __raw_readw(dma_base + offset);
@@ -216,9 +214,9 @@ static inline u32 dma_read(int reg, int lch)
 
 static void omap1_clear_lch_regs(int lch)
 {
-	int i = dma_common_ch_start;
+	int i;
 
-	for (; i <= dma_common_ch_end; i += 1)
+	for (i = CPC; i <= COLOR; i += 1)
 		dma_write(0, i, lch);
 }
 
@@ -380,10 +378,6 @@ static int __init omap1_system_dma_init(void)
 		goto exit_release_chan;
 	}
 
-	dma_stride		= OMAP1_DMA_STRIDE;
-	dma_common_ch_start	= CPC;
-	dma_common_ch_end	= COLOR;
-
 	dma_pdev = platform_device_register_full(&omap_dma_dev_info);
 	if (IS_ERR(dma_pdev)) {
 		ret = PTR_ERR(dma_pdev);
diff --git a/arch/arm/mach-omap2/dma.c b/arch/arm/mach-omap2/dma.c
index 4405b27..49fa816 100644
--- a/arch/arm/mach-omap2/dma.c
+++ b/arch/arm/mach-omap2/dma.c
@@ -38,11 +38,10 @@
 #define OMAP2_DMA_STRIDE	0x60
 
 static u32 errata;
-static u8 dma_stride;
 
 static struct omap_dma_dev_attr *d;
 
-static enum omap_reg_offsets dma_common_ch_start, dma_common_ch_end;
+static enum omap_reg_offsets dma_common_ch_end;
 
 static u16 reg_map[] = {
 	[REVISION]		= 0x00,
@@ -96,7 +95,7 @@ static inline void dma_write(u32 val, int reg, int lch)
 	u8  stride;
 	u32 offset;
 
-	stride = (reg >= dma_common_ch_start) ? dma_stride : 0;
+	stride = (reg >= CSDP) ? OMAP2_DMA_STRIDE : 0;
 	offset = reg_map[reg] + (stride * lch);
 	__raw_writel(val, dma_base + offset);
 }
@@ -106,7 +105,7 @@ static inline u32 dma_read(int reg, int lch)
 	u8 stride;
 	u32 offset, val;
 
-	stride = (reg >= dma_common_ch_start) ? dma_stride : 0;
+	stride = (reg >= CSDP) ? OMAP2_DMA_STRIDE : 0;
 	offset = reg_map[reg] + (stride * lch);
 	val = __raw_readl(dma_base + offset);
 	return val;
@@ -114,9 +113,9 @@ static inline u32 dma_read(int reg, int lch)
 
 static void omap2_clear_dma(int lch)
 {
-	int i = dma_common_ch_start;
+	int i;
 
-	for (; i <= dma_common_ch_end; i += 1)
+	for (i = CSDP; i <= dma_common_ch_end; i += 1)
 		dma_write(0, i, lch);
 }
 
@@ -219,9 +218,6 @@ static int __init omap2_system_dma_init_dev(struct omap_hwmod *oh, void *unused)
 	struct resource				*mem;
 	char					*name = "omap_dma_system";
 
-	dma_stride		= OMAP2_DMA_STRIDE;
-	dma_common_ch_start	= CSDP;
-
 	p = kzalloc(sizeof(struct omap_system_dma_plat_info), GFP_KERNEL);
 	if (!p) {
 		pr_err("%s: Unable to allocate pdata for %s:%s\n",
-- 
1.7.5.4

