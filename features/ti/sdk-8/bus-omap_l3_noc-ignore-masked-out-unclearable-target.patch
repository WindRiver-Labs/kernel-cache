From 3502525a8f750c74478f8c8c5476bd82028d891e Mon Sep 17 00:00:00 2001
From: Afzal Mohammed <afzal@ti.com>
Date: Fri, 25 Apr 2014 17:38:11 -0500
Subject: [PATCH 0314/1587] bus: omap_l3_noc: ignore masked out unclearable
 targets

commit 2100b595b756db29a0b71de49c3bf73ae76c679b upstream

Errors that cannot be cleared (determined by reading REGERR register)
are currently handled by masking it. Documentation states that REGERR
"Checks which application/debug error sources are active" - it does not
indicate that this is "interrupt status" - masked out status represented
eventually in the irq line to MPU.
For example:

Lets say module 0 bit 8(0x100) was unclearable, we do the mask it from
generating further errors. However in the following cases:
a) bit 9 of Module 0
OR
b) any bit of Module 1+
occur, the interrupt handler wrongly assumes that the raw interrupt
status of module 0 bit 8 is the root cause of the interrupt, and
returns. This causes unhandled interrupt and resultant infinite
interrupts.

Fix this scenario by storing the events we masked out and masking raw
status with masked ones before identifying and handling the error.

Reported-by: Vaibhav Hiremath <hvaibhav@ti.com>
Signed-off-by: Afzal Mohammed <afzal@ti.com>
Tested-by: Vaibhav Hiremath <hvaibhav@gmail.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
Signed-off-by: Nishanth Menon <nm@ti.com>
Tested-by: Sekhar Nori <nsekhar@ti.com>
---
 drivers/bus/omap_l3_noc.c |    9 +++++++++
 drivers/bus/omap_l3_noc.h |    4 ++++
 2 files changed, 13 insertions(+), 0 deletions(-)

diff --git a/drivers/bus/omap_l3_noc.c b/drivers/bus/omap_l3_noc.c
index 0691e6d..00e4fed 100644
--- a/drivers/bus/omap_l3_noc.c
+++ b/drivers/bus/omap_l3_noc.c
@@ -169,6 +169,9 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 		err_reg = readl_relaxed(base + flag_mux->offset +
 					L3_FLAGMUX_REGERR0 + (inttype << 3));
 
+		err_reg &= ~(inttype ? flag_mux->mask_app_bits :
+				flag_mux->mask_dbg_bits);
+
 		/* Get the corresponding error and analyse */
 		if (err_reg) {
 			/* Identify the source from control status register */
@@ -193,6 +196,12 @@ static irqreturn_t l3_interrupt_handler(int irq, void *_l3)
 				mask_val = readl_relaxed(mask_reg);
 				mask_val &= ~(1 << err_src);
 				writel_relaxed(mask_val, mask_reg);
+
+				/* Mark these bits as to be ignored */
+				if (inttype)
+					flag_mux->mask_app_bits |= 1 << err_src;
+				else
+					flag_mux->mask_dbg_bits |= 1 << err_src;
 			}
 
 			/* Error found so break the for loop */
diff --git a/drivers/bus/omap_l3_noc.h b/drivers/bus/omap_l3_noc.h
index ea2f51c..4e18307 100644
--- a/drivers/bus/omap_l3_noc.h
+++ b/drivers/bus/omap_l3_noc.h
@@ -66,11 +66,15 @@ struct l3_target_data {
  *		target data. unsupported ones are marked with
  *		L3_TARGET_NOT_SUPPORTED
  * @num_targ_data: number of entries in target data
+ * @mask_app_bits: ignore these from raw application irq status
+ * @mask_dbg_bits: ignore these from raw debug irq status
  */
 struct l3_flagmux_data {
 	u32 offset;
 	struct l3_target_data *l3_targ;
 	u8 num_targ_data;
+	u32 mask_app_bits;
+	u32 mask_dbg_bits;
 };
 
 
-- 
1.7.5.4

