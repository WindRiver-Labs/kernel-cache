From 4034df49fabaded412cebeddbca324b6f289290c Mon Sep 17 00:00:00 2001
From: Benoit Parrot <bparrot@ti.com>
Date: Thu, 20 Nov 2014 17:29:08 -0600
Subject: [PATCH 1453/1587] v4l: ti-vpe: vip: Invert clock via SMA_SW1 for
 falling edge

If the video port uses the pixel clock which is active at falling edge,
then it needs to be inverted inside control module so that, when the
clock reaches the VIP module, the data is valid at rising edge.

This is done by setting bits in the CTRL_CORE_SMA_SW1. This register is
accessed via syscon regmap. Parse the property "syscin-smasw"
from device tree and save the regmap. When configuring the pixel clock
polarity, set the clock inversion bits depending on the instance.

Changed the device tree private data from string to an integer.
This is easier to compare v/s comparing strings.

Signed-off-by: Nikhil Devshatwar <nikhil.nd@ti.com>
Signed-off-by: Benoit Parrot <bparrot@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/media/platform/ti-vpe/vip.c |   41 +++++++++++++++++++++++++++++-----
 drivers/media/platform/ti-vpe/vip.h |    6 +++++
 2 files changed, 41 insertions(+), 6 deletions(-)

diff --git a/drivers/media/platform/ti-vpe/vip.c b/drivers/media/platform/ti-vpe/vip.c
index a9bb5bf..dc519f8 100644
--- a/drivers/media/platform/ti-vpe/vip.c
+++ b/drivers/media/platform/ti-vpe/vip.c
@@ -27,6 +27,8 @@
 #include <linux/pm_runtime.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
 
 #include <linux/pinctrl/consumer.h>
 #include <linux/of_device.h>
@@ -509,7 +511,29 @@ static void vip_set_discrete_basic_mode(struct vip_port *port)
 
 static void vip_set_pclk_polarity(struct vip_port *port, int polarity)
 {
-	u32 val;
+	u32 val, ret, offset;
+
+	if (polarity == 0 && port->dev->syscon) {
+
+		/*
+		 * When the VIP parser is configured to so that the pixel clock
+		 * is to be sampled at falling edge, the pixel clock needs to be
+		 * inverted before it is given to the VIP module. This is done
+		 * by setting a bit in the CTRL_CORE_SMA_SW1 register.
+		 */
+
+		if (port->dev->instance_id == VIP_INSTANCE1)
+			offset = 0 + 2 * port->port_id + port->dev->slice_id;
+		else if (port->dev->instance_id == VIP_INSTANCE2)
+			offset = 4 + 2 * port->port_id + port->dev->slice_id;
+		else if (port->dev->instance_id == VIP_INSTANCE3)
+			offset = 10 - port->dev->slice_id;
+		else
+			BUG();
+
+		ret = regmap_update_bits(port->dev->syscon,
+			0, 1 << offset, 1 << offset);
+	}
 
 	if (port->port_id == 0 && port->dev->slice_id == VIP_SLICE1) {
 		val = read_vreg(port->dev, VIP1_PARSER_REG_OFFSET +
@@ -2516,6 +2540,7 @@ static int vip_of_probe(struct platform_device *pdev, struct vip_dev *dev)
 {
 	struct device_node *ep_node = NULL, *port, *remote_ep,
 			*sensor_node, *parent;
+	struct device_node *syscon_np;
 	struct v4l2_of_endpoint *endpoint;
 	struct v4l2_async_subdev *asd;
 	u32 regval = 0;
@@ -2523,6 +2548,10 @@ static int vip_of_probe(struct platform_device *pdev, struct vip_dev *dev)
 
 	parent = pdev->dev.of_node;
 
+	syscon_np = of_parse_phandle(pdev->dev.of_node, "syscon-smasw", 0);
+	dev->syscon = syscon_node_to_regmap(syscon_np);
+	of_node_put(syscon_np);
+
 	dev->config = kzalloc(sizeof(struct vip_config), GFP_KERNEL);
 	if (!dev->config)
 		return -ENOMEM;
@@ -2736,10 +2765,10 @@ static int vip_probe(struct platform_device *pdev)
 
 		INIT_LIST_HEAD(&dev->vip_bufs);
 
-		dev->vip_name = (const char *)of_dev_id->data;
+		dev->instance_id = (int)of_dev_id->data;
 
 		snprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),
-			"%s-%d", dev->vip_name, slice);
+			"%s%d-%d", VIP_MODULE_NAME, dev->instance_id, slice);
 		ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
 		if (ret)
 			goto err_runtime_get;
@@ -2810,15 +2839,15 @@ static int vip_remove(struct platform_device *pdev)
 #if defined(CONFIG_OF)
 static const struct of_device_id vip_of_match[] = {
 	{
-		.compatible = "ti,vip1", .data = "vip1",
+		.compatible = "ti,vip1", .data = (void *) VIP_INSTANCE1,
 	},
 
 	{
-		.compatible = "ti,vip2", .data = "vip2",
+		.compatible = "ti,vip2", .data = (void *) VIP_INSTANCE2,
 	},
 
 	{
-		.compatible = "ti,vip3", .data = "vip3",
+		.compatible = "ti,vip3", .data = (void *) VIP_INSTANCE3,
 	},
 	{},
 };
diff --git a/drivers/media/platform/ti-vpe/vip.h b/drivers/media/platform/ti-vpe/vip.h
index 3d66276..711c11a 100644
--- a/drivers/media/platform/ti-vpe/vip.h
+++ b/drivers/media/platform/ti-vpe/vip.h
@@ -32,6 +32,10 @@
 #include "vpdma.h"
 #include "vpdma_priv.h"
 
+#define VIP_INSTANCE1	1
+#define VIP_INSTANCE2	2
+#define VIP_INSTANCE3	3
+
 #define VIP_SLICE1	0
 #define VIP_SLICE2	1
 #define VIP_NUM_SLICES	2
@@ -114,6 +118,8 @@ struct vip_dev {
 	struct platform_device *pdev;
 	struct vip_shared	*shared;
 	struct resource		*res;
+	struct regmap		*syscon;
+	int			instance_id;
 	int			slice_id;
 	int			num_ports;	/* count of open ports */
 	struct mutex		mutex;
-- 
1.7.5.4

