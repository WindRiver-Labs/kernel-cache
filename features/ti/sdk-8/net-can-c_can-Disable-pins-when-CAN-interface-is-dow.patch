From 03e0650d262ad806cd10bdb43b8c9763913bcd2b Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Fri, 14 Nov 2014 19:04:42 +0200
Subject: [PATCH 1384/1587] net: can: c_can: Disable pins when CAN interface
 is down

DRA7 CAN IP suffers from a problem which causes it to be prevented
from fully turning OFF (i.e. stuck in transition) if the module was
disabled while there was traffic on the CAN_RX line.

To work around this issue we select the SLEEP pin state by default
on probe and use the DEFAULT pin state on CAN up and back to the
SLEEP pin state on CAN down.

Signed-off-by: Roger Quadros <rogerq@ti.com>
[nsekhar@ti.com: checkpatch and whitespace fixes]
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/net/can/c_can/c_can.c |   32 ++++++++++++++++++++++++++++++++
 drivers/net/can/c_can/c_can.h |    2 ++
 2 files changed, 34 insertions(+), 0 deletions(-)

diff --git a/drivers/net/can/c_can/c_can.c b/drivers/net/can/c_can/c_can.c
index 951bfed..d7e6ac3 100644
--- a/drivers/net/can/c_can/c_can.c
+++ b/drivers/net/can/c_can/c_can.c
@@ -35,6 +35,7 @@
 #include <linux/list.h>
 #include <linux/io.h>
 #include <linux/pm_runtime.h>
+#include <linux/pinctrl/consumer.h>
 
 #include <linux/can.h>
 #include <linux/can/dev.h>
@@ -685,6 +686,9 @@ static void c_can_start(struct net_device *dev)
 
 	/* enable status change, error and module interrupts */
 	c_can_enable_all_interrupts(priv, ENABLE_ALL_INTERRUPTS);
+
+	/* activate pins */
+	c_can_pinctrl_select_state(dev, PINCTRL_STATE_DEFAULT);
 }
 
 static void c_can_stop(struct net_device *dev)
@@ -696,6 +700,9 @@ static void c_can_stop(struct net_device *dev)
 
 	/* set the state as STOPPED */
 	priv->can.state = CAN_STATE_STOPPED;
+
+	/* deactivate pins */
+	c_can_pinctrl_select_state(dev, PINCTRL_STATE_SLEEP);
 }
 
 static int c_can_set_mode(struct net_device *dev, enum can_mode mode)
@@ -1284,6 +1291,15 @@ int register_c_can_dev(struct net_device *dev)
 	struct c_can_priv *priv = netdev_priv(dev);
 	int err;
 
+	priv->pinctrl = devm_pinctrl_get(dev->dev.parent);
+
+	/* Deactivate pins to prevent DRA7 DCAN IP from being
+	 * stuck in transition when module is disabled.
+	 * Pins are activated in c_can_start() and deactivated
+	 * in c_can_stop()
+	 */
+	c_can_pinctrl_select_state(dev, PINCTRL_STATE_SLEEP);
+
 	c_can_pm_runtime_enable(priv);
 
 	dev->flags |= IFF_ECHO;	/* we support local echo */
@@ -1309,6 +1325,22 @@ void unregister_c_can_dev(struct net_device *dev)
 }
 EXPORT_SYMBOL_GPL(unregister_c_can_dev);
 
+/* Selects the pinctrl state specified in the name. */
+void c_can_pinctrl_select_state(struct net_device *dev,
+				const char *name)
+{
+	struct c_can_priv *priv = netdev_priv(dev);
+
+	if (!IS_ERR(priv->pinctrl)) {
+		struct pinctrl_state *s;
+
+		s = pinctrl_lookup_state(priv->pinctrl, name);
+		if (!IS_ERR(s))
+			pinctrl_select_state(priv->pinctrl, s);
+	}
+}
+EXPORT_SYMBOL_GPL(c_can_pinctrl_select_state);
+
 MODULE_AUTHOR("Bhupesh Sharma <bhupesh.sharma@st.com>");
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("CAN bus driver for Bosch C_CAN controller");
diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index da723d8..27b9d28 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -192,12 +192,14 @@ struct c_can_priv {
 	enum c_can_dev_id type;
 	struct c_can_raminit raminit_sys;	/* RAMINIT via syscon regmap */
 	void (*raminit) (const struct c_can_priv *priv, bool enable);
+	struct pinctrl *pinctrl;
 };
 
 struct net_device *alloc_c_can_dev(void);
 void free_c_can_dev(struct net_device *dev);
 int register_c_can_dev(struct net_device *dev);
 void unregister_c_can_dev(struct net_device *dev);
+void c_can_pinctrl_select_state(struct net_device *dev, const char *name);
 
 #ifdef CONFIG_PM
 int c_can_power_up(struct net_device *dev);
-- 
1.7.5.4

