From a5816b8d9f8360d4c18206745e883ca4f11c3e09 Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Fri, 31 Oct 2014 11:26:27 -0500
Subject: [PATCH 1329/1587] rpmsg: rpc: fix unbalanced mutex locking during
 recovery

An user thread can be blocked while waiting for new response
messages. The thread is unblocked either when a new message is
available for the thread to read or when the remote processor
has crashed and the rpmsg-rpc device has been removed and
recreated as part of the recovery process.

The user thread currently fails to release a mutex lock it
held in the case of wakeup due to the latter event causing
the user process to never be closed properly or be killed.
Fix this unbalanced mutex locking so that the user process
can proceed to close or recover itself gracefully.

Signed-off-by: Suman Anna <s-anna@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/rpmsg/rpmsg_rpc.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/drivers/rpmsg/rpmsg_rpc.c b/drivers/rpmsg/rpmsg_rpc.c
index 3cff23d..0a7b582 100644
--- a/drivers/rpmsg/rpmsg_rpc.c
+++ b/drivers/rpmsg/rpmsg_rpc.c
@@ -731,6 +731,7 @@ static ssize_t rppc_read(struct file *filp, char __user *buf, size_t len,
 
 		/* make sure state is sane while we waited */
 		if (rpc->state != RPPC_STATE_CONNECTED) {
+			mutex_unlock(&rpc->lock);
 			ret = -EIO;
 			goto out;
 		}
@@ -738,9 +739,11 @@ static ssize_t rppc_read(struct file *filp, char __user *buf, size_t len,
 
 	skb = skb_dequeue(&rpc->queue);
 	if (WARN_ON(!skb)) {
+		mutex_unlock(&rpc->lock);
 		ret = -EIO;
 		goto out;
 	}
+
 	mutex_unlock(&rpc->lock);
 
 	packet = (struct rppc_packet *)skb->data;
-- 
1.7.5.4

