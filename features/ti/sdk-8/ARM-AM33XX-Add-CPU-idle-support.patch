From 9f52179d08dc73520a452b21832df2b90ee1e7c9 Mon Sep 17 00:00:00 2001
From: Russ Dill <russ.dill@ti.com>
Date: Fri, 25 Jul 2014 17:52:45 -0500
Subject: [PATCH 0944/1587] ARM: AM33XX: Add CPU idle support

This patch adds support for CPU idle on am335x. It has been tested with
Beaglebone Black, Beaglebone White, a PG1.x DDR2 am335x-evm and a PG2.x
DDR3 am335x-evm. The patchset supports putting the MPU PLL into bypass,
putting the MPU into retension mode, and putting the DDR into self
refresh.

The EMIF can bring the DDR out of self refresh when it needs to service
a DMA request. However, for maximum power savings on DDR3 systems, extra
steps need to be performed that the EMIF cannot reverse on its own.
Because of this, two separate sets of CPU idle states are provided, one
for DDR2 systems, and one for DDR3 systems. The DDR3 states do not
include self refresh alone as this actually increases power consumption.

It would be possible to increase DDR3 power savings if the am33xx CPU
idle code were able to detect if there were any potential EMIF users
before allowing deeper DDR3 states.

Signed-off-by: Russ Dill <russ.dill@ti.com>
Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 arch/arm/mach-omap2/Makefile      |    1 +
 arch/arm/mach-omap2/cpuidle33xx.c |  141 +++++++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/pm.h          |    6 ++
 arch/arm/mach-omap2/pm33xx.c      |   80 +++++++++++++++++----
 arch/arm/mach-omap2/pm33xx.h      |   17 +++++
 5 files changed, 231 insertions(+), 14 deletions(-)
 create mode 100644 arch/arm/mach-omap2/cpuidle33xx.c

diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index f8bcdb3..65784fa 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -108,6 +108,7 @@ AFLAGS_sleep43xx.o			:=-Wa,-march=armv7-a$(plus_sec)
 endif
 
 ifeq ($(CONFIG_CPU_IDLE),y)
+obj-$(CONFIG_SOC_AM33XX)                += cpuidle33xx.o
 obj-$(CONFIG_ARCH_OMAP3)                += cpuidle34xx.o
 obj-$(CONFIG_ARCH_OMAP4)                += cpuidle44xx.o
 endif
diff --git a/arch/arm/mach-omap2/cpuidle33xx.c b/arch/arm/mach-omap2/cpuidle33xx.c
new file mode 100644
index 0000000..e1c67fc
--- /dev/null
+++ b/arch/arm/mach-omap2/cpuidle33xx.c
@@ -0,0 +1,141 @@
+/*
+ * AM33XX CPU idle Routines
+ *
+ * Copyright (C) 2011-2013 Texas Instruments, Inc.
+ * Santosh Shilimkar <santosh.shilimkar@ti.com>
+ * Rajendra Nayak <rnayak@ti.com>
+ * Russ Dill <russ.dill@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/sched.h>
+#include <linux/cpuidle.h>
+#include <linux/cpu_pm.h>
+
+#include "common.h"
+#include "pm33xx.h"
+#include "powerdomain.h"
+
+#define AM33XX_FLAG_MPU_PLL		BIT(16)
+#define AM33XX_FLAG_SELF_REFRESH	BIT(17)
+#define AM33XX_FLAG_DISABLE_EMIF	BIT(18)
+
+static int am33xx_enter_idle(struct cpuidle_device *dev,
+			     struct cpuidle_driver *drv, int index)
+{
+	struct cpuidle_state *state;
+	u32 wfi_flags = 0;
+	u32 m3_flags = 0;
+
+	if (omap_irq_pending() || need_resched())
+		return index;
+
+	state = &drv->states[index];
+
+	if (state->flags & AM33XX_FLAG_SELF_REFRESH)
+		wfi_flags |= WFI_SELF_REFRESH;
+
+	if (state->flags & AM33XX_FLAG_DISABLE_EMIF)
+		wfi_flags |= WFI_DISABLE_EMIF;
+
+	if (state->flags & AM33XX_FLAG_MPU_PLL) {
+		wfi_flags |= WFI_WAKE_M3;
+		m3_flags = PWRDM_POWER_ON << M3_PARAM2_MPU_STATE_SHIFT |
+			MEM_BANK_RET_ST_OFF << M3_PARAM2_MPU_RAM_RET_SHIFT |
+			MEM_BANK_RET_ST_RET << M3_PARAM2_MPU_L1_RET_SHIFT |
+			MEM_BANK_RET_ST_RET << M3_PARAM2_MPU_L2_RET_SHIFT |
+			PWRDM_POWER_ON << M3_PARAM2_PER_STATE_SHIFT |
+			MPU_WAKE << M3_PARAM2_WAKE_SOURCES_SHIFT;
+	}
+
+	am33xx_do_sram_cpuidle(wfi_flags, m3_flags);
+
+	return index;
+}
+
+/* Power usage measured as a combination of CPU and DDR power rails */
+struct cpuidle_state am33xx_ddr2_states[] = {
+	{
+		.exit_latency = 72,
+		.target_residency = 150,
+		.power_usage = 625,
+		.flags = CPUIDLE_FLAG_TIME_VALID,
+		.enter = am33xx_enter_idle,
+		.name = "C0",
+		.desc = "WFI",
+	},
+	{
+		.exit_latency = 176,
+		.target_residency = 300,
+		.power_usage = 562,
+		.flags = CPUIDLE_FLAG_TIME_VALID | AM33XX_FLAG_MPU_PLL,
+		.enter = am33xx_enter_idle,
+		.name = "C1",
+		.desc = "Bypass MPU PLL",
+	},
+	{
+		.exit_latency = 390,
+		.target_residency = 500,
+		.power_usage = 529,
+		.flags = CPUIDLE_FLAG_TIME_VALID | AM33XX_FLAG_MPU_PLL |
+				AM33XX_FLAG_SELF_REFRESH,
+		.enter = am33xx_enter_idle,
+		.name = "C1+SR",
+		.desc = "Bypass MPU PLL + DDR SR",
+	},
+};
+
+struct cpuidle_state am33xx_ddr3_states[] = {
+	{
+		.exit_latency = 68,
+		.target_residency = 150,
+		.power_usage = 557,
+		.flags = CPUIDLE_FLAG_TIME_VALID,
+		.enter = am33xx_enter_idle,
+		.name = "C0",
+		.desc = "WFI",
+	},
+	{
+		.exit_latency = 130,
+		.target_residency = 200,
+		.power_usage = 497,
+		.flags = CPUIDLE_FLAG_TIME_VALID | AM33XX_FLAG_MPU_PLL,
+		.enter = am33xx_enter_idle,
+		.name = "C1",
+		.desc = "Bypass MPU PLL",
+	},
+};
+
+static struct cpuidle_driver am33xx_idle_driver = {
+	.name		= "am33xx_idle",
+	.owner		= THIS_MODULE,
+};
+
+/**
+ * am33xx_idle_init - Init routine for am33xx idle
+ *
+ * Registers the am33xx specific cpuidle driver to the cpuidle
+ * framework with the valid set of states.
+ */
+int am33xx_idle_init(bool ddr3)
+{
+	if (ddr3) {
+		BUILD_BUG_ON(ARRAY_SIZE(am33xx_ddr3_states) >
+					ARRAY_SIZE(am33xx_idle_driver.states));
+		memcpy(am33xx_idle_driver.states, am33xx_ddr3_states,
+		       sizeof(am33xx_ddr3_states));
+		am33xx_idle_driver.state_count =
+						ARRAY_SIZE(am33xx_ddr3_states);
+	} else {
+		BUILD_BUG_ON(ARRAY_SIZE(am33xx_ddr2_states) >
+					ARRAY_SIZE(am33xx_idle_driver.states));
+		memcpy(am33xx_idle_driver.states, am33xx_ddr2_states,
+		       sizeof(am33xx_ddr2_states));
+		am33xx_idle_driver.state_count =
+						ARRAY_SIZE(am33xx_ddr2_states);
+	}
+	return cpuidle_register(&am33xx_idle_driver, NULL);
+}
diff --git a/arch/arm/mach-omap2/pm.h b/arch/arm/mach-omap2/pm.h
index 31ccddb..447350e 100644
--- a/arch/arm/mach-omap2/pm.h
+++ b/arch/arm/mach-omap2/pm.h
@@ -21,9 +21,15 @@ extern u32 wakeup_timer_milliseconds;
 #endif
 
 #ifdef CONFIG_CPU_IDLE
+int __init am33xx_idle_init(bool ddr3);
 extern int __init omap3_idle_init(void);
 extern int __init omap4_idle_init(void);
 #else
+static inline int am33xx_idle_init(bool ddr3)
+{
+	return 0;
+}
+
 static inline int omap3_idle_init(void)
 {
 	return 0;
diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index fa867c5..6ed2fcfc 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -36,6 +36,7 @@
 #include <asm/system_misc.h>
 #include <asm/smp_scu.h>
 
+#include "control.h"
 #include "pm.h"
 #include "cm33xx.h"
 #include "pm33xx.h"
@@ -45,11 +46,15 @@
 #include "soc.h"
 #include "sram.h"
 
-static void __iomem *am33xx_emif_base, *scu_base;
+#ifdef CONFIG_SUSPEND
+static void __iomem *scu_base;
 static struct powerdomain *cefuse_pwrdm, *gfx_pwrdm, *per_pwrdm, *mpu_pwrdm;
 static struct clockdomain *gfx_l4ls_clkdm;
 static struct clockdomain *l3s_clkdm, *l4fw_clkdm, *clk_24mhz_clkdm;
+#endif /* CONFIG_SUSPEND */
 
+#ifdef CONFIG_CPU_PM
+static void __iomem *am33xx_emif_base;
 static struct am33xx_pm_context *am33xx_pm;
 
 static DECLARE_COMPLETION(am33xx_pm_sync);
@@ -58,6 +63,40 @@ static void (*am33xx_do_wfi_sram)(struct am33xx_suspend_params *);
 
 static struct am33xx_suspend_params susp_params;
 
+int am33xx_do_sram_cpuidle(u32 wfi_flags, u32 m3_flags)
+{
+	struct am33xx_suspend_params params;
+	int ret;
+
+	/* Start with the default flags */
+	memcpy(&params, &susp_params, sizeof(params));
+
+	/* Clear bits configurable through this call */
+	params.wfi_flags &= ~(WFI_SELF_REFRESH | WFI_WAKE_M3 | WFI_SAVE_EMIF |
+							WFI_DISABLE_EMIF);
+
+	/* Don't enter these states if the M3 isn't available */
+	if (am33xx_pm->state != M3_STATE_INITED)
+		wfi_flags &= ~WFI_WAKE_M3;
+
+	/* Set bits that have been passed */
+	params.wfi_flags |= wfi_flags;
+
+	if (wfi_flags & WFI_WAKE_M3) {
+		am33xx_pm->ipc.reg1 = IPC_CMD_IDLE;
+		am33xx_pm->ipc.reg2 = DS_IPC_DEFAULT;
+		am33xx_pm->ipc.reg3 = m3_flags;
+		am33xx_pm->ipc.reg5 = DS_IPC_DEFAULT;
+		wkup_m3_set_cmd(&am33xx_pm->ipc);
+		ret = wkup_m3_ping();
+		if (ret < 0)
+			return ret;
+	}
+
+	am33xx_do_wfi_sram(&params);
+	return 0;
+}
+
 #ifdef CONFIG_SUSPEND
 static int am33xx_do_sram_idle(unsigned long int arg)
 {
@@ -256,6 +295,8 @@ static void am33xx_m3_ready_cb(void)
 			am33xx_pm->ver);
 	}
 
+	am33xx_idle_init(susp_params.wfi_flags & WFI_MEM_TYPE_DDR3);
+
 #ifdef CONFIG_SUSPEND
 	suspend_set_ops(&am33xx_pm_ops);
 #endif /* CONFIG_SUSPEND */
@@ -291,6 +332,7 @@ static int __init am33xx_map_emif(void)
 	return 0;
 }
 
+#ifdef CONFIG_SUSPEND
 static int __init am43xx_map_scu(void)
 {
 	scu_base = ioremap(scu_a9_get_base(), SZ_256);
@@ -407,23 +449,21 @@ static struct am33xx_pm_ops am43xx_ops = {
 	.pre_suspend = am43xx_pre_suspend,
 	.post_suspend = am43xx_post_suspend,
 };
+#endif /* CONFIG_SUSPEND */
+#endif /* CONFIG_CPU_PM */
 
 int __init am33xx_pm_init(void)
 {
+#ifdef CONFIG_CPU_PM
 	int ret;
 	u32 temp;
 	struct device_node *np;
+#endif /* CONFIG_CPU_PM */
 
 	if (!soc_is_am33xx() && !soc_is_am43xx())
 		return -ENODEV;
 
-	gfx_pwrdm = pwrdm_lookup("gfx_pwrdm");
-	per_pwrdm = pwrdm_lookup("per_pwrdm");
-	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
-
-	if ((!gfx_pwrdm) || (!per_pwrdm) || (!mpu_pwrdm))
-		return -ENODEV;
-
+#ifdef CONFIG_CPU_PM
 	am33xx_pm = kzalloc(sizeof(*am33xx_pm), GFP_KERNEL);
 	if (!am33xx_pm) {
 		pr_err("Memory allocation failed\n");
@@ -431,6 +471,20 @@ int __init am33xx_pm_init(void)
 		return ret;
 	}
 
+	ret = am33xx_map_emif();
+	if (ret) {
+		pr_err("PM: Could not ioremap EMIF\n");
+		goto err;
+	}
+
+#ifdef CONFIG_SUSPEND
+	gfx_pwrdm = pwrdm_lookup("gfx_pwrdm");
+	per_pwrdm = pwrdm_lookup("per_pwrdm");
+	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
+
+	if ((!gfx_pwrdm) || (!per_pwrdm) || (!mpu_pwrdm))
+		return -ENODEV;
+
 	/*
 	 * Code paths for each SoC are nearly the same but set ops
 	 * handle differences during init, pre-suspend, and post-suspend
@@ -445,12 +499,7 @@ int __init am33xx_pm_init(void)
 
 	if (ret)
 		goto err;
-
-	ret = am33xx_map_emif();
-	if (ret) {
-		pr_err("PM: Could not ioremap EMIF\n");
-		goto err;
-	}
+#endif /* CONFIG_SUSPEND */
 
 	/* Determine Memory Type */
 	temp = readl(am33xx_emif_base + EMIF_SDRAM_CONFIG);
@@ -491,6 +540,7 @@ int __init am33xx_pm_init(void)
 		if (of_find_property(np, "ti,set-io-isolation", NULL))
 			am33xx_pm->ipc.reg4 |= (1 << IO_ISOLATION_STAT_SHIFT);
 	}
+#endif /* CONFIG_CPU_PM */
 
 	(void) clkdm_for_each(omap_pm_clkdms_setup, NULL);
 
@@ -501,6 +551,7 @@ int __init am33xx_pm_init(void)
 	else
 		pr_err("PM: Failed to get cefuse_pwrdm\n");
 
+#ifdef CONFIG_CPU_PM
 	am33xx_pm->state = M3_STATE_RESET;
 
 	wkup_m3_set_ops(&am33xx_wkup_m3_ops);
@@ -510,4 +561,5 @@ int __init am33xx_pm_init(void)
 err:
 	kfree(am33xx_pm);
 	return ret;
+#endif /* CONFIG_CPU_PM */
 }
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
index 919648f..daf38bb 100644
--- a/arch/arm/mach-omap2/pm33xx.h
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -50,10 +50,15 @@ struct am33xx_suspend_params {
 	void __iomem *cke_override_virt;
 };
 
+void wkup_m3_reset_data_pos(void);
+int wkup_m3_copy_data(const u8 *data, size_t size);
+int am33xx_do_sram_cpuidle(u32, u32);
+
 #endif /*__ASSEMBLER__ */
 
 #define	IPC_CMD_DS0			0x4
 #define	IPC_CMD_STANDBY			0xc
+#define	IPC_CMD_IDLE			0xd
 #define IPC_CMD_RESET			0xe
 #define DS_IPC_DEFAULT			0xffffffff
 #define M3_VERSION_UNKNOWN		0x0000ffff
@@ -107,4 +112,16 @@ struct am33xx_suspend_params {
 #define IO_ISOLATION_STAT_SHIFT (10)
 #define IO_ISOLATION_STAT_MASK  (0x1 << 10)
 
+#define MPU_WAKE		0x800
+
+#define MEM_BANK_RET_ST_OFF		0x0
+#define MEM_BANK_RET_ST_RET		0x1
+
+#define M3_PARAM2_MPU_STATE_SHIFT	0
+#define M3_PARAM2_MPU_RAM_RET_SHIFT	2
+#define M3_PARAM2_MPU_L1_RET_SHIFT	3
+#define M3_PARAM2_MPU_L2_RET_SHIFT	4
+#define M3_PARAM2_PER_STATE_SHIFT	7
+#define M3_PARAM2_WAKE_SOURCES_SHIFT	18
+
 #endif /* __ARCH_ARM_MACH_OMAP2_PM33XX_H */
-- 
1.7.5.4

