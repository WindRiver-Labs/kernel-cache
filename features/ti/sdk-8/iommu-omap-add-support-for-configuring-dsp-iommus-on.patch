From 3a7171e0cf5446a4819a575d3048b8d8c80c5ba2 Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Wed, 17 Jul 2013 19:12:34 -0500
Subject: [PATCH 1005/1587] iommu/omap: add support for configuring dsp iommus
 on DRA7xx

The DSP MMUs on DRA7xx SoC requires configuring an additional
MMU_CONFIG register present in the DSP_SYSTEM address space.
This setting dictates whether the DSP Core's MDMA and EDMA
traffic is routed through the respective MMU or not. Add the
support to the OMAP iommu driver so that the traffic is not
bypassed when enabling the MMU0.

The MMU_CONFIG register has two different bits for enabling
each of these two MMUs present in a DSP processor sub-system
on DRA7xx. An id field is added to the OMAP iommu object to
identify and enable each IOMMU. A proper value is assigned to
this field only when the DSP_SYSTEM address space is present.
Logic is added to ensure that this is checked only for DSP
MMUs on DRA7xx SoCs and ignored for all others.

TODO:
1. Evaluate if the MMU_CONFIG register programming needs to
   be done in the probe and release functions instead so that
   the DSP traffic always goes through the corresponding MMUs,
   irrespective of whether the actual MMU itself is enabled or
   not. It is currently not done since probe does not do any
   dynamic programming.
2. This common register space logic can probably be implemented
   using a syscon device for the shared DSP_SYSTEM space, but
   would still need identifying the index of the MMU for
   programming the syscon register.

Signed-off-by: Suman Anna <s-anna@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/iommu/omap-iommu.c  |   44 +++++++++++++++++++++++++++++++++++++++++++
 drivers/iommu/omap-iommu.h  |   15 ++++++++++++++
 drivers/iommu/omap-iommu2.c |   20 +++++++++++++++++++
 3 files changed, 79 insertions(+), 0 deletions(-)

diff --git a/drivers/iommu/omap-iommu.c b/drivers/iommu/omap-iommu.c
index a111ea9..867c832 100644
--- a/drivers/iommu/omap-iommu.c
+++ b/drivers/iommu/omap-iommu.c
@@ -927,6 +927,46 @@ static void omap_iommu_detach(struct omap_iommu *obj)
 	dev_dbg(obj->dev, "%s: %s\n", __func__, obj->name);
 }
 
+static int omap_iommu_dra7_get_dsp_system_cfg(struct platform_device *pdev,
+					      struct omap_iommu *obj,
+					      resource_size_t start)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *res;
+
+	if (!of_device_is_compatible(np, "ti,dra7-iommu"))
+		return 0;
+
+	/*
+	 * Assign the SYS_MMU enable MMU index for DRA7 DSP MMUs,
+	 * nothing to process for DRA7 IPU MMUs
+	 */
+	if (start == 0x40D01000 || start == 0x41501000)
+		obj->id = 0;
+	else if (start == 0x40D02000 || start == 0x41502000)
+		obj->id = 1;
+	else
+		return 0;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dsp_system");
+	if (res) {
+		/*
+		 * The DSP_SYSTEM space is common across two instances of MMU
+		 * and there is no common object for storing common data, so the
+		 * resource is deliberately not locked using request_mem_region
+		 */
+		obj->syscfgbase = devm_ioremap(obj->dev, res->start,
+					       resource_size(res));
+		if (!obj->syscfgbase)
+			return -ENOMEM;
+	} else {
+		dev_err(&pdev->dev, "dsp_system register space is missing\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 /*
  *	OMAP Device MMU(IOMMU) detection
  */
@@ -983,6 +1023,10 @@ static int omap_iommu_probe(struct platform_device *pdev)
 	if (IS_ERR(obj->regbase))
 		return PTR_ERR(obj->regbase);
 
+	err = omap_iommu_dra7_get_dsp_system_cfg(pdev, obj, res->start);
+	if (err)
+		return err;
+
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return -ENODEV;
diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index ea920c3..a0efe7b 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -30,6 +30,7 @@ struct omap_iommu {
 	const char	*name;
 	struct module	*owner;
 	void __iomem	*regbase;
+	void __iomem	*syscfgbase;
 	struct device	*dev;
 	void		*isr_priv;
 	struct iommu_domain *domain;
@@ -54,6 +55,7 @@ struct omap_iommu {
 	u32 da_end;
 
 	int has_bus_err_back;
+	u32 id;
 };
 
 struct cr_regs {
@@ -169,6 +171,19 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 #define MMU_GP_REG_BUS_ERR_BACK_EN	0x1
 
 /*
+ * DSP_SYSTEM registers (applicable only for DRA7xx DSP)
+ */
+#define DSP_SYS_REVISION	0x00
+#define DSP_SYS_HWINFO		0x04
+#define DSP_SYS_MMU_CONFIG	0x18
+
+/*
+ * DSP_SYSTEM registers bit definitions (applicable only for DRA7xx DSP)
+ */
+#define DSP_SYS_HWINFO_NUM_MASK	0xF
+#define DSP_SYS_MMU_EN_SHIFT	4
+
+/*
  * utilities for super page(16MB, 1MB, 64KB and 4KB)
  */
 
diff --git a/drivers/iommu/omap-iommu2.c b/drivers/iommu/omap-iommu2.c
index 5e1ea3b..570643d 100644
--- a/drivers/iommu/omap-iommu2.c
+++ b/drivers/iommu/omap-iommu2.c
@@ -62,6 +62,23 @@
 #define OMAP_IOMMU_ERR_TBLWALK_FAULT	(1 << 3)
 #define OMAP_IOMMU_ERR_MULTIHIT_FAULT	(1 << 4)
 
+static void dra7_cfg_dspsys_mmu(struct omap_iommu *obj, bool enable)
+{
+	u32 val, mask;
+
+	if (!obj->syscfgbase)
+		return;
+
+	val = __raw_readl(obj->syscfgbase + DSP_SYS_MMU_CONFIG);
+	mask = (1 << (obj->id * DSP_SYS_MMU_EN_SHIFT));
+	if (enable)
+		val |= mask;
+	else
+		val &= ~mask;
+
+	__raw_writel(val, obj->syscfgbase + DSP_SYS_MMU_CONFIG);
+}
+
 static void __iommu_set_twl(struct omap_iommu *obj, bool on)
 {
 	u32 l = iommu_read_reg(obj, MMU_CNTL);
@@ -98,6 +115,8 @@ static int omap2_iommu_enable(struct omap_iommu *obj)
 
 	iommu_write_reg(obj, pa, MMU_TTB);
 
+	dra7_cfg_dspsys_mmu(obj, true);
+
 	if (obj->has_bus_err_back)
 		iommu_write_reg(obj, MMU_GP_REG_BUS_ERR_BACK_EN, MMU_GP_REG);
 
@@ -112,6 +131,7 @@ static void omap2_iommu_disable(struct omap_iommu *obj)
 
 	l &= ~MMU_CNTL_MASK;
 	iommu_write_reg(obj, l, MMU_CNTL);
+	dra7_cfg_dspsys_mmu(obj, false);
 
 	dev_dbg(obj->dev, "%s is shutting down\n", obj->name);
 }
-- 
1.7.5.4

