From 349123fcf133a649873f6356db0b82e99664b7c2 Mon Sep 17 00:00:00 2001
From: George Cherian <george.cherian@ti.com>
Date: Tue, 16 Dec 2014 00:07:53 +0530
Subject: [PATCH 1549/1587] usb: dwc3: Add seperate dwc3_gadget object to
 support gadget release

With the current implementation it's impossible to release the gadget.
Add a separate dwc3_gadget object to dwc3 structure so that the same
can be freed during the gadget release.
This is in prepration to adapt dwc3 gadget driver to  drd library.
DRD library uses usb_del/add_gadget_udc while switching roles between
HOST and DEVICE modes. If the usb_gadget is not released during usb_del_gadget_udc,
the subsequent usb_add_gadget_udc would try to initialize an already initialized
kobject. To avoid this make sure we have an easily freeable object.

Signed-off-by: George Cherian <george.cherian@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/usb/dwc3/core.h   |    7 +++-
 drivers/usb/dwc3/ep0.c    |   31 ++++++++-----
 drivers/usb/dwc3/gadget.c |  107 +++++++++++++++++++++++++++++---------------
 drivers/usb/dwc3/gadget.h |    1 +
 4 files changed, 96 insertions(+), 50 deletions(-)

diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 3129fe3..d4e953c 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -592,6 +592,11 @@ struct dwc3_scratchpad_array {
 	__le64	dma_adr[DWC3_MAX_HIBER_SCRATCHBUFS];
 };
 
+struct dwc3_gadget {
+	struct usb_gadget gadget;
+	struct dwc3 *dwc;
+};
+
 /**
  * struct dwc3 - representation of our controller
  * @ctrl_req: usb control request which is used for ep0
@@ -678,7 +683,7 @@ struct dwc3 {
 	struct dwc3_event_buffer **ev_buffs;
 	struct dwc3_ep		*eps[DWC3_ENDPOINTS_NUM];
 
-	struct usb_gadget	gadget;
+	struct dwc3_gadget	*dwc_gadget;
 	struct usb_gadget_driver *gadget_driver;
 
 	struct usb_phy		*usb2_phy;
diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c
index dbf3d33..7b349ad 100644
--- a/drivers/usb/dwc3/ep0.c
+++ b/drivers/usb/dwc3/ep0.c
@@ -105,6 +105,7 @@ static int __dwc3_gadget_ep0_queue(struct dwc3_ep *dep,
 		struct dwc3_request *req)
 {
 	struct dwc3		*dwc = dep->dwc;
+	struct dwc3_gadget	*dwc_gadget = dwc->dwc_gadget;
 
 	req->request.actual	= 0;
 	req->request.status	= -EINPROGRESS;
@@ -148,7 +149,7 @@ static int __dwc3_gadget_ep0_queue(struct dwc3_ep *dep,
 
 		direction = !dwc->ep0_expect_in;
 		dwc->delayed_status = false;
-		usb_gadget_set_state(&dwc->gadget, USB_STATE_CONFIGURED);
+		usb_gadget_set_state(&dwc_gadget->gadget, USB_STATE_CONFIGURED);
 
 		if (dwc->ep0state == EP0_STATUS_PHASE)
 			__dwc3_ep0_do_control_status(dwc, dwc->eps[direction]);
@@ -384,6 +385,7 @@ static int dwc3_ep0_handle_feature(struct dwc3 *dwc,
 		struct usb_ctrlrequest *ctrl, int set)
 {
 	struct dwc3_ep		*dep;
+	struct dwc3_gadget	*dwc_gadget = dwc->dwc_gadget;
 	u32			recip;
 	u32			wValue;
 	u32			wIndex;
@@ -394,7 +396,7 @@ static int dwc3_ep0_handle_feature(struct dwc3 *dwc,
 	wValue = le16_to_cpu(ctrl->wValue);
 	wIndex = le16_to_cpu(ctrl->wIndex);
 	recip = ctrl->bRequestType & USB_RECIP_MASK;
-	state = dwc->gadget.state;
+	state = dwc_gadget->gadget.state;
 
 	switch (recip) {
 	case USB_RECIP_DEVICE:
@@ -493,7 +495,8 @@ static int dwc3_ep0_handle_feature(struct dwc3 *dwc,
 
 static int dwc3_ep0_set_address(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 {
-	enum usb_device_state state = dwc->gadget.state;
+	struct dwc3_gadget *dwc_gadget = dwc->dwc_gadget;
+	enum usb_device_state state = dwc_gadget->gadget.state;
 	u32 addr;
 	u32 reg;
 
@@ -514,26 +517,28 @@ static int dwc3_ep0_set_address(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 	dwc3_writel(dwc->regs, DWC3_DCFG, reg);
 
 	if (addr)
-		usb_gadget_set_state(&dwc->gadget, USB_STATE_ADDRESS);
+		usb_gadget_set_state(&dwc_gadget->gadget, USB_STATE_ADDRESS);
 	else
-		usb_gadget_set_state(&dwc->gadget, USB_STATE_DEFAULT);
+		usb_gadget_set_state(&dwc_gadget->gadget, USB_STATE_DEFAULT);
 
 	return 0;
 }
 
 static int dwc3_ep0_delegate_req(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 {
+	struct dwc3_gadget *dwc_gadget = dwc->dwc_gadget;
 	int ret;
 
 	spin_unlock(&dwc->lock);
-	ret = dwc->gadget_driver->setup(&dwc->gadget, ctrl);
+	ret = dwc->gadget_driver->setup(&dwc_gadget->gadget, ctrl);
 	spin_lock(&dwc->lock);
 	return ret;
 }
 
 static int dwc3_ep0_set_config(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 {
-	enum usb_device_state state = dwc->gadget.state;
+	struct dwc3_gadget *dwc_gadget = dwc->dwc_gadget;
+	enum usb_device_state state = dwc_gadget->gadget.state;
 	u32 cfg;
 	int ret;
 	u32 reg;
@@ -558,7 +563,7 @@ static int dwc3_ep0_set_config(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 			 * to change the state on the next usb_ep_queue()
 			 */
 			if (ret == 0)
-				usb_gadget_set_state(&dwc->gadget,
+				usb_gadget_set_state(&dwc_gadget->gadget,
 						USB_STATE_CONFIGURED);
 
 			/*
@@ -577,7 +582,7 @@ static int dwc3_ep0_set_config(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 	case USB_STATE_CONFIGURED:
 		ret = dwc3_ep0_delegate_req(dwc, ctrl);
 		if (!cfg && !ret)
-			usb_gadget_set_state(&dwc->gadget,
+			usb_gadget_set_state(&dwc_gadget->gadget,
 					USB_STATE_ADDRESS);
 		break;
 	default:
@@ -633,7 +638,8 @@ static void dwc3_ep0_set_sel_cmpl(struct usb_ep *ep, struct usb_request *req)
 static int dwc3_ep0_set_sel(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 {
 	struct dwc3_ep	*dep;
-	enum usb_device_state state = dwc->gadget.state;
+	struct dwc3_gadget *dwc_gadget = dwc->dwc_gadget;
+	enum usb_device_state state = dwc_gadget->gadget.state;
 	u16		wLength;
 	u16		wValue;
 
@@ -905,6 +911,7 @@ static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,
 		struct dwc3_ep *dep, struct dwc3_request *req)
 {
 	int			ret;
+	struct dwc3_gadget	*dwc_gadget = dwc->dwc_gadget;
 
 	req->direction = !!dep->number;
 
@@ -917,7 +924,7 @@ static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,
 		u32	transfer_size;
 		u32	maxpacket;
 
-		ret = usb_gadget_map_request(&dwc->gadget, &req->request,
+		ret = usb_gadget_map_request(&dwc_gadget->gadget, &req->request,
 				dep->number);
 		if (ret) {
 			dev_dbg(dwc->dev, "failed to map request\n");
@@ -940,7 +947,7 @@ static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,
 				dwc->ep0_bounce_addr, transfer_size,
 				DWC3_TRBCTL_CONTROL_DATA);
 	} else {
-		ret = usb_gadget_map_request(&dwc->gadget, &req->request,
+		ret = usb_gadget_map_request(&dwc_gadget->gadget, &req->request,
 				dep->number);
 		if (ret) {
 			dev_dbg(dwc->dev, "failed to map request\n");
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index df8696d..8c39071 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -217,6 +217,7 @@ void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,
 		int status)
 {
 	struct dwc3			*dwc = dep->dwc;
+	struct dwc3_gadget		*dwc_gadget = dwc->dwc_gadget;
 	int				i;
 
 	if (req->queued) {
@@ -244,7 +245,7 @@ void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,
 	if (dwc->ep0_bounced && dep->number == 0)
 		dwc->ep0_bounced = false;
 	else
-		usb_gadget_unmap_request(&dwc->gadget, &req->request,
+		usb_gadget_unmap_request(&dwc_gadget->gadget, &req->request,
 				req->direction);
 
 	dev_dbg(dwc->dev, "request %p from %s completed %d/%d ===> %d\n",
@@ -481,6 +482,7 @@ static int dwc3_gadget_set_ep_config(struct dwc3 *dwc, struct dwc3_ep *dep,
 		bool ignore)
 {
 	struct dwc3_gadget_ep_cmd_params params;
+	struct dwc3_gadget *dwc_gadget = dwc->dwc_gadget;
 
 	memset(&params, 0x00, sizeof(params));
 
@@ -488,7 +490,7 @@ static int dwc3_gadget_set_ep_config(struct dwc3 *dwc, struct dwc3_ep *dep,
 		| DWC3_DEPCFG_MAX_PACKET_SIZE(usb_endpoint_maxp(desc));
 
 	/* Burst size is only needed in SuperSpeed mode */
-	if (dwc->gadget.speed == USB_SPEED_SUPER) {
+	if (dwc_gadget->gadget.speed == USB_SPEED_SUPER) {
 		u32 burst = dep->endpoint.maxburst - 1;
 
 		params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
@@ -994,6 +996,7 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 	struct dwc3_gadget_ep_cmd_params params;
 	struct dwc3_request		*req;
 	struct dwc3			*dwc = dep->dwc;
+	struct dwc3_gadget		*dwc_gadget = dwc->dwc_gadget;
 	int				ret;
 	u32				cmd;
 
@@ -1046,7 +1049,7 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 		 * here and stop, unmap, free and del each of the linked
 		 * requests instead of what we do now.
 		 */
-		usb_gadget_unmap_request(&dwc->gadget, &req->request,
+		usb_gadget_unmap_request(&dwc_gadget->gadget, &req->request,
 				req->direction);
 		list_del(&req->list);
 		return ret;
@@ -1095,6 +1098,7 @@ static void dwc3_gadget_start_isoc(struct dwc3 *dwc,
 static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)
 {
 	struct dwc3		*dwc = dep->dwc;
+	struct dwc3_gadget	*dwc_gadget = dwc->dwc_gadget;
 	int			ret;
 
 	req->request.actual	= 0;
@@ -1114,7 +1118,7 @@ static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)
 	 * This will also avoid Host cancelling URBs due to too
 	 * many NAKs.
 	 */
-	ret = usb_gadget_map_request(&dwc->gadget, &req->request,
+	ret = usb_gadget_map_request(&dwc_gadget->gadget, &req->request,
 			dep->direction);
 	if (ret)
 		return ret;
@@ -1375,7 +1379,8 @@ static const struct usb_ep_ops dwc3_gadget_ep_ops = {
 
 static int dwc3_gadget_get_frame(struct usb_gadget *g)
 {
-	struct dwc3		*dwc = gadget_to_dwc(g);
+	struct dwc3_gadget *dwc_gadget = gadget_to_dwc_gadget(g);
+	struct dwc3 *dwc = dwc_gadget->dwc;
 	u32			reg;
 
 	reg = dwc3_readl(dwc->regs, DWC3_DSTS);
@@ -1384,7 +1389,8 @@ static int dwc3_gadget_get_frame(struct usb_gadget *g)
 
 static int dwc3_gadget_wakeup(struct usb_gadget *g)
 {
-	struct dwc3		*dwc = gadget_to_dwc(g);
+	struct dwc3_gadget *dwc_gadget = gadget_to_dwc_gadget(g);
+	struct dwc3 *dwc = dwc_gadget->dwc;
 
 	unsigned long		timeout;
 	unsigned long		flags;
@@ -1465,7 +1471,8 @@ out:
 static int dwc3_gadget_set_selfpowered(struct usb_gadget *g,
 		int is_selfpowered)
 {
-	struct dwc3		*dwc = gadget_to_dwc(g);
+	struct dwc3_gadget *dwc_gadget = gadget_to_dwc_gadget(g);
+	struct dwc3 *dwc = dwc_gadget->dwc;
 	unsigned long		flags;
 
 	spin_lock_irqsave(&dwc->lock, flags);
@@ -1531,7 +1538,8 @@ static int dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on, int suspend)
 
 static int dwc3_gadget_pullup(struct usb_gadget *g, int is_on)
 {
-	struct dwc3		*dwc = gadget_to_dwc(g);
+	struct dwc3_gadget *dwc_gadget = gadget_to_dwc_gadget(g);
+	struct dwc3 *dwc = dwc_gadget->dwc;
 	unsigned long		flags;
 	int			ret;
 
@@ -1574,7 +1582,8 @@ static irqreturn_t dwc3_thread_interrupt(int irq, void *_dwc);
 static int dwc3_gadget_start(struct usb_gadget *g,
 		struct usb_gadget_driver *driver)
 {
-	struct dwc3		*dwc = gadget_to_dwc(g);
+	struct dwc3_gadget *dwc_gadget = gadget_to_dwc_gadget(g);
+	struct dwc3 *dwc = dwc_gadget->dwc;
 	struct dwc3_ep		*dep;
 	unsigned long		flags;
 	int			ret = 0;
@@ -1594,7 +1603,7 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 
 	if (dwc->gadget_driver) {
 		dev_err(dwc->dev, "%s is already bound to %s\n",
-				dwc->gadget.name,
+				dwc_gadget->gadget.name,
 				dwc->gadget_driver->driver.name);
 		ret = -EBUSY;
 		goto err1;
@@ -1686,7 +1695,8 @@ err0:
 static int dwc3_gadget_stop(struct usb_gadget *g,
 		struct usb_gadget_driver *driver)
 {
-	struct dwc3		*dwc = gadget_to_dwc(g);
+	struct dwc3_gadget *dwc_gadget = gadget_to_dwc_gadget(g);
+	struct dwc3 *dwc = dwc_gadget->dwc;
 	unsigned long		flags;
 	int			irq;
 
@@ -1721,6 +1731,7 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 		u8 num, u32 direction)
 {
 	struct dwc3_ep			*dep;
+	struct dwc3_gadget		*dwc_gadget = dwc->dwc_gadget;
 	u8				i;
 
 	for (i = 0; i < num; i++) {
@@ -1750,7 +1761,7 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 			dep->endpoint.maxburst = 1;
 			dep->endpoint.ops = &dwc3_gadget_ep0_ops;
 			if (!epnum)
-				dwc->gadget.ep0 = &dep->endpoint;
+				dwc_gadget->gadget.ep0 = &dep->endpoint;
 		} else {
 			int		ret;
 
@@ -1758,7 +1769,7 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 			dep->endpoint.max_streams = 15;
 			dep->endpoint.ops = &dwc3_gadget_ep_ops;
 			list_add_tail(&dep->endpoint.ep_list,
-					&dwc->gadget.ep_list);
+					&dwc_gadget->gadget.ep_list);
 
 			ret = dwc3_alloc_trb_pool(dep);
 			if (ret)
@@ -1775,8 +1786,9 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 static int dwc3_gadget_init_endpoints(struct dwc3 *dwc)
 {
 	int				ret;
+	struct dwc3_gadget		*dwc_gadget = dwc->dwc_gadget;
 
-	INIT_LIST_HEAD(&dwc->gadget.ep_list);
+	INIT_LIST_HEAD(&dwc_gadget->gadget.ep_list);
 
 	ret = dwc3_gadget_init_hw_endpoints(dwc, dwc->num_out_eps, 0);
 	if (ret < 0) {
@@ -2078,27 +2090,33 @@ static void dwc3_endpoint_interrupt(struct dwc3 *dwc,
 
 static void dwc3_disconnect_gadget(struct dwc3 *dwc)
 {
+	struct dwc3_gadget *dwc_gadget = dwc->dwc_gadget;
+
 	if (dwc->gadget_driver && dwc->gadget_driver->disconnect) {
 		spin_unlock(&dwc->lock);
-		dwc->gadget_driver->disconnect(&dwc->gadget);
+		dwc->gadget_driver->disconnect(&dwc_gadget->gadget);
 		spin_lock(&dwc->lock);
 	}
 }
 
 static void dwc3_suspend_gadget(struct dwc3 *dwc)
 {
+	struct dwc3_gadget *dwc_gadget = dwc->dwc_gadget;
+
 	if (dwc->gadget_driver && dwc->gadget_driver->suspend) {
 		spin_unlock(&dwc->lock);
-		dwc->gadget_driver->suspend(&dwc->gadget);
+		dwc->gadget_driver->suspend(&dwc_gadget->gadget);
 		spin_lock(&dwc->lock);
 	}
 }
 
 static void dwc3_resume_gadget(struct dwc3 *dwc)
 {
+	struct dwc3_gadget *dwc_gadget = dwc->dwc_gadget;
+
 	if (dwc->gadget_driver && dwc->gadget_driver->resume) {
 		spin_unlock(&dwc->lock);
-		dwc->gadget_driver->resume(&dwc->gadget);
+		dwc->gadget_driver->resume(&dwc_gadget->gadget);
 		spin_lock(&dwc->lock);
 	}
 }
@@ -2192,6 +2210,7 @@ static void dwc3_clear_stall_all_ep(struct dwc3 *dwc)
 static void dwc3_gadget_disconnect_interrupt(struct dwc3 *dwc)
 {
 	int			reg;
+	struct dwc3_gadget	*dwc_gadget = dwc->dwc_gadget;
 
 	dev_vdbg(dwc->dev, "%s\n", __func__);
 
@@ -2205,13 +2224,14 @@ static void dwc3_gadget_disconnect_interrupt(struct dwc3 *dwc)
 	dwc3_disconnect_gadget(dwc);
 	dwc->start_config_issued = false;
 
-	dwc->gadget.speed = USB_SPEED_UNKNOWN;
+	dwc_gadget->gadget.speed = USB_SPEED_UNKNOWN;
 	dwc->setup_packet_pending = false;
 }
 
 static void dwc3_gadget_reset_interrupt(struct dwc3 *dwc)
 {
 	u32			reg;
+	struct dwc3_gadget	*dwc_gadget = dwc->dwc_gadget;
 
 	dev_vdbg(dwc->dev, "%s\n", __func__);
 
@@ -2247,9 +2267,9 @@ static void dwc3_gadget_reset_interrupt(struct dwc3 *dwc)
 	}
 
 	/* after reset -> Default State */
-	usb_gadget_set_state(&dwc->gadget, USB_STATE_DEFAULT);
+	usb_gadget_set_state(&dwc_gadget->gadget, USB_STATE_DEFAULT);
 
-	if (dwc->gadget.speed != USB_SPEED_UNKNOWN)
+	if (dwc_gadget->gadget.speed != USB_SPEED_UNKNOWN)
 		dwc3_disconnect_gadget(dwc);
 
 	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
@@ -2295,6 +2315,7 @@ static void dwc3_update_ram_clk_sel(struct dwc3 *dwc, u32 speed)
 static void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)
 {
 	struct dwc3_ep		*dep;
+	struct dwc3_gadget	*dwc_gadget = dwc->dwc_gadget;
 	int			ret;
 	u32			reg;
 	u8			speed;
@@ -2326,24 +2347,24 @@ static void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)
 			dwc3_gadget_reset_interrupt(dwc);
 
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);
-		dwc->gadget.ep0->maxpacket = 512;
-		dwc->gadget.speed = USB_SPEED_SUPER;
+		dwc_gadget->gadget.ep0->maxpacket = 512;
+		dwc_gadget->gadget.speed = USB_SPEED_SUPER;
 		break;
 	case DWC3_DCFG_HIGHSPEED:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);
-		dwc->gadget.ep0->maxpacket = 64;
-		dwc->gadget.speed = USB_SPEED_HIGH;
+		dwc_gadget->gadget.ep0->maxpacket = 64;
+		dwc_gadget->gadget.speed = USB_SPEED_HIGH;
 		break;
 	case DWC3_DCFG_FULLSPEED2:
 	case DWC3_DCFG_FULLSPEED1:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);
-		dwc->gadget.ep0->maxpacket = 64;
-		dwc->gadget.speed = USB_SPEED_FULL;
+		dwc_gadget->gadget.ep0->maxpacket = 64;
+		dwc_gadget->gadget.speed = USB_SPEED_FULL;
 		break;
 	case DWC3_DCFG_LOWSPEED:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(8);
-		dwc->gadget.ep0->maxpacket = 8;
-		dwc->gadget.speed = USB_SPEED_LOW;
+		dwc_gadget->gadget.ep0->maxpacket = 8;
+		dwc_gadget->gadget.speed = USB_SPEED_LOW;
 		break;
 	}
 
@@ -2396,6 +2417,8 @@ static void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)
 
 static void dwc3_gadget_wakeup_interrupt(struct dwc3 *dwc)
 {
+	struct dwc3_gadget		*dwc_gadget = dwc->dwc_gadget;
+
 	dev_vdbg(dwc->dev, "%s\n", __func__);
 
 	/*
@@ -2403,7 +2426,7 @@ static void dwc3_gadget_wakeup_interrupt(struct dwc3 *dwc)
 	 * implemented.
 	 */
 
-	dwc->gadget_driver->resume(&dwc->gadget);
+	dwc->gadget_driver->resume(&dwc_gadget->gadget);
 }
 
 static void dwc3_gadget_linksts_change_interrupt(struct dwc3 *dwc,
@@ -2716,6 +2739,7 @@ static irqreturn_t dwc3_interrupt(int irq, void *_dwc)
 int dwc3_gadget_init(struct dwc3 *dwc)
 {
 	int					ret;
+	struct dwc3_gadget			*dwc_gadget;
 
 	dwc->ctrl_req = dma_alloc_coherent(dwc->dev, sizeof(*dwc->ctrl_req),
 			&dwc->ctrl_req_addr, GFP_KERNEL);
@@ -2749,17 +2773,24 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 		goto err3;
 	}
 
-	dwc->gadget.ops			= &dwc3_gadget_ops;
-	dwc->gadget.max_speed		= USB_SPEED_SUPER;
-	dwc->gadget.speed		= USB_SPEED_UNKNOWN;
-	dwc->gadget.sg_supported	= true;
-	dwc->gadget.name		= "dwc3-gadget";
+	dwc_gadget = kzalloc(sizeof(*dwc_gadget), GFP_KERNEL);
+	if (!dwc_gadget) {
+		ret = -ENOMEM;
+		goto err3;
+	}
+
+	dwc_gadget->gadget.ops			= &dwc3_gadget_ops;
+	dwc_gadget->gadget.max_speed		= USB_SPEED_SUPER;
+	dwc_gadget->gadget.speed		= USB_SPEED_UNKNOWN;
+	dwc_gadget->gadget.sg_supported	= true;
+	dwc_gadget->gadget.name		= "dwc3-gadget";
+	dwc_gadget->dwc = dwc;
 
 	/*
 	 * Per databook, DWC3 needs buffer size to be aligned to MaxPacketSize
 	 * on ep out.
 	 */
-	dwc->gadget.quirk_ep_out_aligned_size = true;
+	dwc_gadget->gadget.quirk_ep_out_aligned_size = true;
 
 	/*
 	 * REVISIT: Here we should clear all pending IRQs to be
@@ -2770,7 +2801,7 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 	if (ret)
 		goto err4;
 
-	ret = usb_add_gadget_udc(dwc->dev, &dwc->gadget);
+	ret = usb_add_gadget_udc(dwc->dev, &dwc_gadget->gadget);
 	if (ret) {
 		dev_err(dwc->dev, "failed to register udc\n");
 		goto err4;
@@ -2802,7 +2833,9 @@ err0:
 
 void dwc3_gadget_exit(struct dwc3 *dwc)
 {
-	usb_del_gadget_udc(&dwc->gadget);
+	struct dwc3_gadget *dwc_gadget = dwc->dwc_gadget;
+
+	usb_del_gadget_udc(&dwc_gadget->gadget);
 
 	dwc3_gadget_free_endpoints(dwc);
 
diff --git a/drivers/usb/dwc3/gadget.h b/drivers/usb/dwc3/gadget.h
index 9b68577..1dfd938 100644
--- a/drivers/usb/dwc3/gadget.h
+++ b/drivers/usb/dwc3/gadget.h
@@ -26,6 +26,7 @@
 struct dwc3;
 #define to_dwc3_ep(ep)		(container_of(ep, struct dwc3_ep, endpoint))
 #define gadget_to_dwc(g)	(container_of(g, struct dwc3, gadget))
+#define gadget_to_dwc_gadget(g)	(container_of(g, struct dwc3_gadget, gadget))
 
 /* DEPCFG parameter 1 */
 #define DWC3_DEPCFG_INT_NUM(n)		((n) << 0)
-- 
1.7.5.4

