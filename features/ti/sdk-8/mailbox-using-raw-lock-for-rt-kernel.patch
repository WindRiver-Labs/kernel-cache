From 2496bd9a1e37a62f109fede27779026b8fbfb037 Mon Sep 17 00:00:00 2001
From: czou <cao.zou@windriver.com>
Date: Sun, 19 Apr 2015 18:10:32 +0800
Subject: [PATCH 1/2] mailbox: using raw lock for rt kernel

when cpu prepares into the idle state, irq will be disabled,
but for mailbox driver, it will call the spin_lock_irqsave,
it will cause the crash:
CPU: 0 PID: 0 Comm: swapper/0 Not tainted
[<c0017788>] (unwind_backtrace) from [<c0012d3c>] (show_stack+0x20/0x24)
[<c0012d3c>] (show_stack) from [<c07e9888>] (dump_stack+0x74/0xcc)
[<c07e9888>] (dump_stack) from [<c006fe40>] (__might_sleep+0xe4/0x154)
[<c006fe40>] (__might_sleep) from [<c07ef414>] (rt_spin_lock+0x30/0x3c)
[<c07ef414>] (rt_spin_lock) from [<c05c23d4>]
(mbox_send_message+0x3c/0x14c)
[<c05c23d4>] (mbox_send_message) from [<c05c7160>]
(wkup_m3_ping+0x30/0x90)
[<c05c7160>] (wkup_m3_ping) from [<c002eab0>]
(am33xx_do_sram_cpuidle+0x84/0xa8)
[<c002eab0>] (am33xx_do_sram_cpuidle) from [<c002eff0>]
(am33xx_enter_idle+0x80/0x88)
[<c002eff0>] (am33xx_enter_idle) from [<c058f038>]
(cpuidle_enter_state+0x4c/0xf8)
[<c058f038>] (cpuidle_enter_state) from [<c058f1b8>]
(cpuidle_idle_call+0xd4/0x298)
[<c058f1b8>] (cpuidle_idle_call) from [<c00101b4>]
(arch_cpu_idle+0x18/0x48)
[<c00101b4>] (arch_cpu_idle) from [<c0091768>]
(cpu_startup_entry+0x68/0x288)
[<c0091768>] (cpu_startup_entry) from [<c07e2f10>] (rest_init+0x80/0x98)
[<c07e2f10>] (rest_init) from [<c0b21b6c>] (start_kernel+0x338/0x39c)

Signed-off-by: czou <cao.zou@windriver.com>
---
 drivers/mailbox/mailbox.c          |   31 +++++++++++++------------------
 drivers/mailbox/omap-mailbox.c     |    4 ++--
 include/linux/mailbox_controller.h |    2 +-
 3 files changed, 16 insertions(+), 21 deletions(-)

diff --git a/drivers/mailbox/mailbox.c b/drivers/mailbox/mailbox.c
index 99c0d23..99749a6 100644
--- a/drivers/mailbox/mailbox.c
+++ b/drivers/mailbox/mailbox.c
@@ -30,13 +30,12 @@ static DEFINE_MUTEX(con_mutex);
 static int add_to_rbuf(struct mbox_chan *chan, void *mssg)
 {
 	int idx;
-	unsigned long flags;
 
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock(&chan->lock);
 
 	/* See if there is any space left */
 	if (chan->msg_count == MBOX_TX_QUEUE_LEN) {
-		spin_unlock_irqrestore(&chan->lock, flags);
+		raw_spin_unlock(&chan->lock);
 		return -ENOMEM;
 	}
 
@@ -49,7 +48,7 @@ static int add_to_rbuf(struct mbox_chan *chan, void *mssg)
 	else
 		chan->msg_free++;
 
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock(&chan->lock);
 
 	return idx;
 }
@@ -57,14 +56,13 @@ static int add_to_rbuf(struct mbox_chan *chan, void *mssg)
 static void msg_submit(struct mbox_chan *chan)
 {
 	unsigned count, idx;
-	unsigned long flags;
 	void *data;
 	int err;
 
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock(&chan->lock);
 
 	if (!chan->msg_count || chan->active_req) {
-		spin_unlock_irqrestore(&chan->lock, flags);
+		raw_spin_unlock(&chan->lock);
 		return;
 	}
 
@@ -84,18 +82,17 @@ static void msg_submit(struct mbox_chan *chan)
 		chan->msg_count--;
 	}
 
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock(&chan->lock);
 }
 
 static void tx_tick(struct mbox_chan *chan, int r)
 {
-	unsigned long flags;
 	void *mssg;
 
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock(&chan->lock);
 	mssg = chan->active_req;
 	chan->active_req = NULL;
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock(&chan->lock);
 
 	/* Submit next message */
 	msg_submit(chan);
@@ -300,7 +297,6 @@ struct mbox_chan *mbox_request_channel(struct mbox_client *cl, int index)
 	struct mbox_controller *mbox;
 	struct of_phandle_args spec;
 	struct mbox_chan *chan;
-	unsigned long flags;
 	int ret;
 
 	if (!dev || !dev->of_node) {
@@ -332,7 +328,7 @@ struct mbox_chan *mbox_request_channel(struct mbox_client *cl, int index)
 		return ERR_PTR(-EBUSY);
 	}
 
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock(&chan->lock);
 	chan->msg_free = 0;
 	chan->msg_count = 0;
 	chan->active_req = NULL;
@@ -342,7 +338,7 @@ struct mbox_chan *mbox_request_channel(struct mbox_client *cl, int index)
 	if (chan->txdone_method	== TXDONE_BY_POLL && cl->knows_txdone)
 		chan->txdone_method |= TXDONE_BY_ACK;
 
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock(&chan->lock);
 
 	ret = chan->mbox->ops->startup(chan);
 	if (ret) {
@@ -363,7 +359,6 @@ EXPORT_SYMBOL_GPL(mbox_request_channel);
  */
 void mbox_free_channel(struct mbox_chan *chan)
 {
-	unsigned long flags;
 
 	if (!chan || !chan->cl)
 		return;
@@ -371,14 +366,14 @@ void mbox_free_channel(struct mbox_chan *chan)
 	chan->mbox->ops->shutdown(chan);
 
 	/* The queued TX requests are simply aborted, no callbacks are made */
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock(&chan->lock);
 	chan->cl = NULL;
 	chan->active_req = NULL;
 	if (chan->txdone_method == (TXDONE_BY_POLL | TXDONE_BY_ACK))
 		chan->txdone_method = TXDONE_BY_POLL;
 
 	module_put(chan->mbox->dev->driver->owner);
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock(&chan->lock);
 }
 EXPORT_SYMBOL_GPL(mbox_free_channel);
 
@@ -427,7 +422,7 @@ int mbox_controller_register(struct mbox_controller *mbox)
 		chan->cl = NULL;
 		chan->mbox = mbox;
 		chan->txdone_method = txdone;
-		spin_lock_init(&chan->lock);
+		raw_spin_lock_init(&chan->lock);
 	}
 
 	if (!mbox->of_xlate)
diff --git a/drivers/mailbox/omap-mailbox.c b/drivers/mailbox/omap-mailbox.c
index 2a657e7..07d9b88 100644
--- a/drivers/mailbox/omap-mailbox.c
+++ b/drivers/mailbox/omap-mailbox.c
@@ -497,13 +497,13 @@ struct mbox_chan *omap_mbox_request_channel(struct mbox_client *cl,
 		return ERR_PTR(-ENOENT);
 
 	chan = mbox->chan;
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock_irqsave(&chan->lock, flags);
 	chan->msg_free = 0;
 	chan->msg_count = 0;
 	chan->active_req = NULL;
 	chan->cl = cl;
 	init_completion(&chan->tx_complete);
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock_irqrestore(&chan->lock, flags);
 
 	ret = chan->mbox->ops->startup(chan);
 	if (ret) {
diff --git a/include/linux/mailbox_controller.h b/include/linux/mailbox_controller.h
index 9f9f725..7ae131f 100644
--- a/include/linux/mailbox_controller.h
+++ b/include/linux/mailbox_controller.h
@@ -119,7 +119,7 @@ struct mbox_chan {
 	void *active_req;
 	unsigned msg_count, msg_free;
 	void *msg_data[MBOX_TX_QUEUE_LEN];
-	spinlock_t lock; /* Serialise access to the channel */
+	raw_spinlock_t lock; /* Serialise access to the channel */
 	void *con_priv;
 };
 
-- 
1.7.5.4

