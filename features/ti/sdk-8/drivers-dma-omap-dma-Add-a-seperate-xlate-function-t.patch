From 84609efb96e0dc0290bbe314b7fce11017d83a73 Mon Sep 17 00:00:00 2001
From: R Sricharan <r.sricharan@ti.com>
Date: Tue, 5 Aug 2014 17:11:25 +0530
Subject: [PATCH 1047/1587] drivers: dma: omap-dma: Add a seperate xlate
 function to get router data

Each dma-request channel can be connected to the dma-controller either
directly or through a crossbar router. In such cases request lines
should be routed to the dma-controller. Adding a xlate function
which would retrieve and store the router data associated with a particular
channel in the dma-channel specific structure. This is used to map/unmap
the dma request lines.

Signed-off-by: R Sricharan <r.sricharan@ti.com>
Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/dma/omap-dma.c |   47 ++++++++++++++++++++++++++++++++++++++++++++---
 1 files changed, 44 insertions(+), 3 deletions(-)

diff --git a/drivers/dma/omap-dma.c b/drivers/dma/omap-dma.c
index ba0cd93..5788ea1 100644
--- a/drivers/dma/omap-dma.c
+++ b/drivers/dma/omap-dma.c
@@ -44,6 +44,8 @@ struct omap_chan {
 	uint32_t ccr;
 
 	struct dma_slave_config	cfg;
+	struct dma_xbar_device *router;
+
 	unsigned dma_sig;
 	bool cyclic;
 	bool paused;
@@ -75,6 +77,11 @@ struct omap_desc {
 	struct omap_sg sg[0];
 };
 
+struct omap_dma_filter_args {
+	void *router_data;
+	unsigned chan;
+};
+
 enum {
 	CCR_FS			= BIT(5),
 	CCR_READ_PRIORITY	= BIT(6),
@@ -586,6 +593,7 @@ static void omap_dma_free_chan_resources(struct dma_chan *chan)
 	c->channel_base = NULL;
 	od->lch_map[c->dma_ch] = NULL;
 	vchan_free_chan_resources(&c->vc);
+
 	omap_free_dma(c->dma_ch);
 
 	dev_dbg(od->ddev.dev, "freeing channel for %u\n", c->dma_sig);
@@ -1105,6 +1113,34 @@ static int omap_dma_device_slave_caps(struct dma_chan *dchan,
 	return 0;
 }
 
+static struct dma_chan *of_omap_dma_xlate(struct of_phandle_args *dma_spec,
+						 struct of_dma *ofdma)
+{
+	int count = dma_spec->args_count;
+	struct of_dma_filter_info *info = ofdma->of_dma_data;
+	struct omap_dma_filter_args args;
+	struct dma_xbar_device *c = NULL;
+
+	if (!info || !info->filter_fn)
+		return NULL;
+
+	if ((count != 1) && (count != 2))
+		return NULL;
+
+	args.chan = dma_spec->args[0];
+	args.router_data = NULL;
+
+	if (count == 2) {
+		c = of_dma_get_router_data(dma_spec->args[1]);
+
+		if (c && c->ops && c->ops->map && c->ops->unmap)
+			args.router_data = c;
+	}
+
+	return dma_request_channel(info->dma_cap, info->filter_fn,
+			&args);
+}
+
 static int omap_dma_probe(struct platform_device *pdev)
 {
 	struct omap_dmadev *od;
@@ -1185,7 +1221,7 @@ static int omap_dma_probe(struct platform_device *pdev)
 
 		/* Device-tree DMA controller registration */
 		rc = of_dma_controller_register(pdev->dev.of_node,
-				of_dma_simple_xlate, &omap_dma_info);
+				of_omap_dma_xlate, &omap_dma_info);
 		if (rc) {
 			pr_warn("OMAP-DMA: failed to register DMA controller\n");
 			dma_async_device_unregister(&od->ddev);
@@ -1239,11 +1275,16 @@ static struct platform_driver omap_dma_driver = {
 
 bool omap_dma_filter_fn(struct dma_chan *chan, void *param)
 {
+	struct omap_dma_filter_args *args = param;
+
 	if (chan->device->dev->driver == &omap_dma_driver.driver) {
 		struct omap_chan *c = to_omap_dma_chan(chan);
-		unsigned req = *(unsigned *)param;
+		unsigned req = args->chan;
 
-		return req == c->dma_sig;
+		if (req == c->dma_sig) {
+			c->router = args->router_data;
+			return true;
+		}
 	}
 	return false;
 }
-- 
1.7.5.4

