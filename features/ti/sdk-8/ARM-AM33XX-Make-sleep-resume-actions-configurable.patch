From 19f6e5f66982315e41da4a27713cefa7bb2acf18 Mon Sep 17 00:00:00 2001
From: Russ Dill <russ.dill@ti.com>
Date: Wed, 6 Aug 2014 12:30:54 -0500
Subject: [PATCH 0943/1587] ARM: AM33XX: Make sleep/resume actions
 configurable

The sleep33xx assembly code currently executes a sequence of sleep
and resume actions for suspend and standby. In order to extend that
same code to support CPU idle, make the actions performed
configurable based on a set of passed in flags.

Signed-off-by: Russ Dill <russ.dill@ti.com>
Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 arch/arm/mach-omap2/pm33xx.c    |   26 ++++++++++++---
 arch/arm/mach-omap2/pm33xx.h    |   10 +++++-
 arch/arm/mach-omap2/sleep33xx.S |   66 +++++++++++++++++++++++++++++++++-----
 3 files changed, 86 insertions(+), 16 deletions(-)

diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index 30cb764..fa867c5 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -59,10 +59,9 @@ static void (*am33xx_do_wfi_sram)(struct am33xx_suspend_params *);
 static struct am33xx_suspend_params susp_params;
 
 #ifdef CONFIG_SUSPEND
-
-static int am33xx_do_sram_idle(long unsigned int unused)
+static int am33xx_do_sram_idle(unsigned long int arg)
 {
-	am33xx_do_wfi_sram(&susp_params);
+	am33xx_do_wfi_sram((struct am33xx_suspend_params *)arg);
 	return 0;
 }
 
@@ -77,7 +76,8 @@ static int am33xx_pm_suspend(unsigned int state)
 
 	am33xx_pm->ops->pre_suspend(state);
 
-	ret = cpu_suspend(0, am33xx_do_sram_idle);
+	ret = cpu_suspend((unsigned long int)&susp_params,
+			  am33xx_do_sram_idle);
 
 	/*
 	 * Because gfx_pwrdm is the only one under MPU control,
@@ -455,10 +455,24 @@ int __init am33xx_pm_init(void)
 	/* Determine Memory Type */
 	temp = readl(am33xx_emif_base + EMIF_SDRAM_CONFIG);
 	temp = (temp & SDRAM_TYPE_MASK) >> SDRAM_TYPE_SHIFT;
-	/* Parameters to pass to aseembly code */
+	/* Parameters to pass to assembly code */
+	susp_params.wfi_flags = 0;
 	susp_params.emif_addr_virt = am33xx_emif_base;
 	susp_params.dram_sync = am33xx_dram_sync;
-	susp_params.mem_type = temp;
+
+	switch (temp) {
+	case MEM_TYPE_DDR2:
+		susp_params.wfi_flags |= WFI_MEM_TYPE_DDR2;
+		break;
+	case MEM_TYPE_DDR3:
+		susp_params.wfi_flags |= WFI_MEM_TYPE_DDR3;
+		break;
+	}
+	susp_params.wfi_flags |= WFI_SELF_REFRESH;
+	susp_params.wfi_flags |= WFI_SAVE_EMIF;
+	susp_params.wfi_flags |= WFI_DISABLE_EMIF;
+	susp_params.wfi_flags |= WFI_WAKE_M3;
+
 	am33xx_pm->ipc.reg4 = temp & MEM_TYPE_MASK;
 
 	np = of_find_compatible_node(NULL, NULL, "ti,am3353-wkup-m3");
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
index ac146aa..919648f 100644
--- a/arch/arm/mach-omap2/pm33xx.h
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -44,7 +44,7 @@ struct am33xx_pm_context {
  */
 struct am33xx_suspend_params {
 	void __iomem *emif_addr_virt;
-	u32 mem_type;
+	u32 wfi_flags;
 	void __iomem *dram_sync;
 	void __iomem *l2_base_virt;
 	void __iomem *cke_override_virt;
@@ -84,6 +84,14 @@ struct am33xx_suspend_params {
 #define AM43XX_PRM_EMIF_CTRL_OFFSET	0x30
 
 #define MEM_TYPE_DDR2		2
+#define MEM_TYPE_DDR3		3
+
+#define WFI_MEM_TYPE_DDR2	(1 << 0)
+#define WFI_MEM_TYPE_DDR3	(1 << 1)
+#define WFI_SELF_REFRESH	(1 << 2)
+#define WFI_SAVE_EMIF		(1 << 3)
+#define WFI_WAKE_M3		(1 << 4)
+#define WFI_DISABLE_EMIF	(1 << 7)
 
 /*
  * 9-4 = VTT GPIO PIN (6 Bits)
diff --git a/arch/arm/mach-omap2/sleep33xx.S b/arch/arm/mach-omap2/sleep33xx.S
index 2d84c69..7631cd5 100644
--- a/arch/arm/mach-omap2/sleep33xx.S
+++ b/arch/arm/mach-omap2/sleep33xx.S
@@ -42,12 +42,12 @@
  * This routine is executed from internal RAM and expects some
  * parameters to be passed in r0 _strictly_ in following order:
  * 1) emif_addr_virt - ioremapped EMIF address
- * 2) mem_type - 2 -> DDR2, 3-> DDR3
+ * 2) wfi_flags - actions to perform
  * 3) dram_sync_word - uncached word in SDRAM
  *
  * The code loads these values taking r0 value as reference to
  * the array in registers starting from r0, i.e emif_addr_virt
- * goes to r1, mem_type goes to r2 and and so on. These are
+ * goes to r1, wfi_flags goes to r2 and and so on. These are
  * then saved into memory locations before proceeding with the
  * sleep sequence and hence registers r0, r1 etc can still be
  * used in the rest of the sleep code.
@@ -60,9 +60,13 @@ ENTRY(am33xx_do_wfi)
 
 	/* Save the values passed */
 	str	r1, emif_addr_virt
-	str	r2, mem_type
+	str	r2, wfi_flags
 	str	r3, dram_sync_word
 
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SELF_REFRESH
+	beq	skip_sr
+
 	/*
 	 * Flush all data from the L1 and L2 data cache before disabling
 	 * SCTLR.C bit.
@@ -86,9 +90,16 @@ ENTRY(am33xx_do_wfi)
 	ldr	r1, kernel_flush
 	blx	r1
 
-	/* Save EMIF configuration */
+	/* Need to load emif addr for context save and self refresh */
 	ldr	r0, emif_addr_virt
 	ldr	r1, [r0, #EMIF_SDRAM_REFRESH_CONTROL]
+
+	/* Only necessary if PER is losing context */
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SAVE_EMIF
+	beq	skip_save_emif
+
+	/* Save EMIF configuration */
 	str	r1, emif_ref_ctrl_val
 	ldr	r1, [r0, #EMIF_SDRAM_TIMING_1]
 	str	r1, emif_timing1_val
@@ -101,6 +112,7 @@ ENTRY(am33xx_do_wfi)
 	ldr	r1, [r0, #EMIF_DDR_PHY_CTRL_1]
 	str	r1, emif_rd_lat_val
 
+skip_save_emif:
 	/* Put SDRAM in self-refresh */
 	ldr	r1, [r0, #EMIF_POWER_MANAGEMENT_CONTROL]
 	bic	r1, r1, #EMIF_POWER_MGMT_SR_TIMER_MASK
@@ -116,6 +128,9 @@ ENTRY(am33xx_do_wfi)
 	ldr	r1, dram_sync_word	@ a dummy access to DDR as per spec
 	ldr	r2, [r1, #0]
 
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_DISABLE_EMIF
+	beq	skip_sr
 
 	/* Disable EMIF */
 	ldr	r1, virt_emif_clkctrl
@@ -130,6 +145,11 @@ wait_emif_disable:
 	cmp	r2, r3
 	bne	wait_emif_disable
 
+skip_sr:
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_WAKE_M3
+	beq	skip_m3
+
 	/*
 	 * For the MPU WFI to be registered as an interrupt
 	 * to WKUP_M3, MPU_CLKCTRL.MODULEMODE needs to be set
@@ -140,6 +160,7 @@ wait_emif_disable:
 	bic	r2, r2, #AM33XX_CM_CLKCTRL_MODULEMODE_DISABLE
 	str	r2, [r1]
 
+skip_m3:
 	/*
 	 * Execute an ISB instruction to ensure that all of the
 	 * CP15 register changes have been committed.
@@ -178,11 +199,20 @@ wait_emif_disable:
 	nop
 
 	/* We come here in case of an abort due to a late interrupt */
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_WAKE_M3
 
 	/* Set MPU_CLKCTRL.MODULEMODE back to ENABLE */
-	ldr	r1, virt_mpu_clkctrl
-	mov	r2, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
-	str	r2, [r1]
+	ldrne	r1, virt_mpu_clkctrl
+	movne	r2, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
+	strne	r2, [r1]
+
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SELF_REFRESH
+	beq	skip_reenable_emif
+
+	tst	r2, #WFI_DISABLE_EMIF
+	beq	skip_emif_enable
 
 	/* Re-enable EMIF */
 	ldr	r1, virt_emif_clkctrl
@@ -193,6 +223,7 @@ wait_emif_enable:
 	cmp	r2, r3
 	bne	wait_emif_enable
 
+skip_emif_enable:
 	/* Disable EMIF self-refresh */
 	ldr	r0, emif_addr_virt
 	ldr	r1, emif_pmcr_val
@@ -213,6 +244,7 @@ wait_emif_enable:
 	mcr	p15, 0, r0, c1, c0, 0
 	isb
 
+skip_reenable_emif:
 	/* Let the suspend code know about the abort */
 	mov	r0, #1
 	ldmfd	sp!, {r4 - r11, pc}	@ restore regs and return
@@ -223,6 +255,13 @@ ENTRY(am33xx_resume_offset)
 	.word . - am33xx_do_wfi
 
 ENTRY(am33xx_resume_from_deep_sleep)
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SELF_REFRESH
+	beq	skip_reenable_emif1
+
+	tst	r2, #WFI_DISABLE_EMIF
+	beq	skip_emif_enable1
+
 	/* Re-enable EMIF */
 	ldr	r0, phys_emif_clkctrl
 	mov	r1, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
@@ -232,8 +271,14 @@ wait_emif_enable1:
 	cmp	r1, r2
 	bne	wait_emif_enable1
 
-	/* Config EMIF Timings */
+skip_emif_enable1:
 	ldr	r0, emif_phys_addr
+
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SAVE_EMIF
+	beq	skip_restore_emif
+
+	/* Config EMIF Timings */
 	ldr	r1, emif_rd_lat_val
 	str	r1, [r0, #EMIF_DDR_PHY_CTRL_1]
 	str	r1, [r0, #EMIF_DDR_PHY_CTRL_1_SHDW]
@@ -252,6 +297,8 @@ wait_emif_enable1:
 
 	ldr	r1, emif_pmcr_shdw_val
 	str	r1, [r0, #EMIF_POWER_MANAGEMENT_CTRL_SHDW]
+
+skip_restore_emif:
 	/*
 	 * Toggle EMIF to exit refresh mode:
 	 * if EMIF lost context, PWR_MGT_CTRL is currently 0, writing disable
@@ -285,6 +332,7 @@ wait_emif_enable1:
 	tst	r1, #EMIF_STATUS_READY
 	beq	1b
 
+skip_reenable_emif1:
 	/* We are back. Branch to the common CPU resume routine */
 	mov	r0, #0
 	ldr	pc, resume_addr
@@ -316,7 +364,7 @@ module_disabled_val:
 /* DDR related defines */
 dram_sync_word:
 	.word	0xDEADBEEF
-mem_type:
+wfi_flags:
 	.word	0xDEADBEEF
 emif_addr_virt:
 	.word	0xDEADBEEF
-- 
1.7.5.4

