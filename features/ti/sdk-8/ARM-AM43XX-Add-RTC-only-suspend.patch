From 43dccd6083e1268d8e3921d639cc4ab213a6903e Mon Sep 17 00:00:00 2001
From: Tero Kristo <t-kristo@ti.com>
Date: Tue, 26 Aug 2014 11:13:38 +0530
Subject: [PATCH 1097/1587] ARM: AM43XX: Add RTC-only suspend

During RTC-only suspend, power is lost to the wkup domain, so we need to save
and restore the state of that domain. We also need to store some information
within the RTC registers so that u-boot can do the right thing at powerup.

The state is entered by getting the RTC to bring the pmic_power_en line low,
which will instruct the PMIC to disable the appropriate power rails after
putting DDR into self-refresh mode. To bring pmic_power_en low, we need to get
an ALARM2 event. Since we are running from SRAM at that point, it means
calculating what the next second is (via ASM) and programming that into the
RTC.

Signed-off-by: Tero Kristo <t-kristo@ti.com>
[j-keerthy@ti.com] Rework and ported to 3.14
Signed-off-by: Keerthy <j-keerthy@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 arch/arm/mach-omap2/iomap.h     |    7 ++
 arch/arm/mach-omap2/pm.h        |    2 +
 arch/arm/mach-omap2/pm33xx.c    |  169 +++++++++++++++++++++++++++++++++++++--
 arch/arm/mach-omap2/pm33xx.h    |    7 ++
 arch/arm/mach-omap2/sleep43xx.S |   45 +++++++++--
 5 files changed, 218 insertions(+), 12 deletions(-)

diff --git a/arch/arm/mach-omap2/iomap.h b/arch/arm/mach-omap2/iomap.h
index cce2b65..4032739 100644
--- a/arch/arm/mach-omap2/iomap.h
+++ b/arch/arm/mach-omap2/iomap.h
@@ -119,6 +119,13 @@
 #define L4_WK_AM33XX_SIZE	SZ_4M   /* 1MB of 128MB used, want 1MB sect */
 
 /*
+ * ----------------------------------------------------------------------------
+ * AM43XX specific IO mapping
+ * ----------------------------------------------------------------------------
+ */
+#define AM43XX_GIC_DIST_BASE	0x48241000
+
+/*
  * Need to look at the Size 4M for L4.
  * VPOM3430 was not working for Int controller
  */
diff --git a/arch/arm/mach-omap2/pm.h b/arch/arm/mach-omap2/pm.h
index 1f9c211..234b8a0 100644
--- a/arch/arm/mach-omap2/pm.h
+++ b/arch/arm/mach-omap2/pm.h
@@ -49,6 +49,8 @@ static inline int omap4_idle_init(void)
 
 extern void *omap3_secure_ram_storage;
 extern void omap3_pm_off_mode_enable(int);
+extern void am33xx_enable_rtc_only_mode(int);
+extern int am33xx_get_rtc_only_mode(void);
 extern void omap_sram_idle(void);
 extern int omap_pm_clkdms_setup(struct clockdomain *clkdm, void *unused);
 
diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index 85d2b15..282c70c 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -29,6 +29,12 @@
 #include <linux/ti_emif.h>
 #include <linux/omap-mailbox.h>
 #include <linux/sizes.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/gpio-omap.h>
+#include <linux/platform_data/wkup_m3.h>
+#include <linux/rtc.h>
 
 #include <asm/suspend.h>
 #include <asm/proc-fns.h>
@@ -45,13 +51,30 @@
 #include "powerdomain.h"
 #include "soc.h"
 #include "sram.h"
+#include "omap_hwmod.h"
+#include "iomap.h"
+
+static struct rtc_device *omap_rtc;
+static struct omap_hwmod *rtc_oh;
+static struct pinctrl_dev *pmx_dev;
+static u32 rtc_magic_val;
+static int retrigger_irq;
+
+#define RTC_SCRATCH_RESUME_REG         0
+#define RTC_SCRATCH_MAGIC_REG          1
+
+#define RTC_REG_BOOT_MAGIC		0x8cd0 /* RTC */
+#define RTC_REG_DDR_TYPE_DDR2_0		(0x00 << 16)
+#define RTC_REG_DDR_TYPE_DDR3_0		(0x01 << 16)
 
 #ifdef CONFIG_SUSPEND
-static void __iomem *scu_base;
+static void __iomem *scu_base, *gic_dist_base;
 static struct powerdomain *cefuse_pwrdm, *gfx_pwrdm, *per_pwrdm, *mpu_pwrdm;
 static struct clockdomain *gfx_l4ls_clkdm;
 #endif /* CONFIG_SUSPEND */
 
+static struct am33xx_suspend_params susp_params;
+
 #ifdef CONFIG_CPU_PM
 static void __iomem *am33xx_emif_base;
 static struct am33xx_pm_context *am33xx_pm;
@@ -60,8 +83,6 @@ static DECLARE_COMPLETION(am33xx_pm_sync);
 
 static void (*am33xx_do_wfi_sram)(struct am33xx_suspend_params *);
 
-static struct am33xx_suspend_params susp_params;
-
 int am33xx_do_sram_cpuidle(u32 wfi_flags, u32 m3_flags)
 {
 	struct am33xx_suspend_params params;
@@ -103,10 +124,87 @@ static int am33xx_do_sram_idle(unsigned long int arg)
 	return 0;
 }
 
+static struct wkup_m3_wakeup_src rtc_wakeups[] = {
+	{.irq_nr = 0, .src = "Unknown"},
+	{.irq_nr = 0, .src = "Unknown"},
+	{.irq_nr = 108, .src = "RTC Alarm"},
+	{.irq_nr = 0, .src = "Ext wakeup"},
+};
+
+struct wkup_m3_wakeup_src rtc_wake_src(void)
+{
+	u32 i;
+
+	i = __raw_readl(susp_params.rtc_base + 0x98) >> 17;
+	retrigger_irq = rtc_wakeups[i].irq_nr;
+
+	return rtc_wakeups[i];
+}
+
+static void common_save_context(void)
+{
+	omap2_gpio_prepare_for_idle(1);
+	pinmux_save_context(pmx_dev, "am33xx_pmx_per");
+	clks_save_context();
+	pwrdms_save_context();
+	omap_hwmods_save_context();
+	clkdm_save_context();
+}
+
+static void common_restore_context(void)
+{
+	clks_restore_context();
+	pwrdms_restore_context();
+	clkdm_restore_context();
+	omap_hwmods_restore_context();
+	pinmux_restore_context(pmx_dev, "am33xx_pmx_per");
+	wkup_m3_set_rtc_only_mode();
+	pwrdms_lost_power();
+	omap2_gpio_resume_after_idle();
+	omap_sram_reset();
+}
+
+static void am33xx_save_context(void)
+{
+	common_save_context();
+	omap_intc_save_context();
+	am33xx_control_save_context();
+}
+
+static void am33xx_restore_context(void)
+{
+	common_restore_context();
+	am33xx_control_restore_context();
+	omap_intc_restore_context();
+	am33xx_push_sram_idle();
+}
+
+static void am43xx_save_context(void)
+{
+	common_save_context();
+	am43xx_control_save_context();
+}
+
+static void am43xx_restore_context(void)
+{
+	common_restore_context();
+	am43xx_control_restore_context();
+	am43xx_push_sram_idle();
+}
+
+int am33xx_rtc_only_idle(long unsigned int unused)
+{
+	rtc_write_scratch(omap_rtc, RTC_SCRATCH_MAGIC_REG, rtc_magic_val);
+	omap_rtc_power_off_program();
+	am33xx_do_wfi_sram(&susp_params);
+	return 0;
+}
+
 static int am33xx_pm_suspend(unsigned int state)
 {
 	int i, ret = 0;
 	int status = 0;
+	int rtc_only_idle = 0;
 	struct wkup_m3_wakeup_src wakeup_src = {.irq_nr = 0,
 						.src = "Unknown",};
 
@@ -114,8 +212,21 @@ static int am33xx_pm_suspend(unsigned int state)
 
 	am33xx_pm->ops->pre_suspend(state);
 
-	ret = cpu_suspend((unsigned long int)&susp_params,
-			  am33xx_do_sram_idle);
+	if (state == PM_SUSPEND_MEM && enable_off_mode)
+		rtc_only_idle = 1;
+
+	if (rtc_only_idle) {
+		omap_hwmod_enable(rtc_oh);
+		am33xx_pm->ops->save_context();
+		susp_params.wfi_flags |= WFI_RTC_ONLY;
+		ret = cpu_suspend((long unsigned int) &susp_params,
+							am33xx_rtc_only_idle);
+		susp_params.wfi_flags &= ~WFI_RTC_ONLY;
+		if (!ret)
+			am33xx_pm->ops->restore_context();
+	} else
+		ret = cpu_suspend((long unsigned int) &susp_params,
+				  am33xx_do_sram_idle);
 
 	/*
 	 * Because gfx_pwrdm is the only one under MPU control,
@@ -154,7 +265,12 @@ static int am33xx_pm_suspend(unsigned int state)
 			ret = -1;
 		}
 		/* print the wakeup reason */
-		wkup_m3_wake_src(&wakeup_src);
+		if (rtc_only_idle) {
+			wakeup_src = rtc_wake_src();
+			omap_hwmod_idle(rtc_oh);
+		} else {
+			wkup_m3_wake_src(&wakeup_src);
+		}
 
 		pr_info("PM: Wakeup source %s\n", wakeup_src.src);
 	}
@@ -240,6 +356,10 @@ static int am33xx_pm_begin(suspend_state_t state)
 static void am33xx_pm_end(void)
 {
 	am33xx_m3_state_machine_reset();
+
+	if (retrigger_irq)
+		writel_relaxed(1 << (retrigger_irq & 31),
+			       gic_dist_base + 0x200 + retrigger_irq / 32 * 4);
 }
 
 static int am33xx_pm_valid(suspend_state_t state)
@@ -349,6 +469,15 @@ static int __init am43xx_map_scu(void)
 	return 0;
 }
 
+static int __init am43xx_map_gic(void)
+{
+	gic_dist_base = ioremap(AM43XX_GIC_DIST_BASE, SZ_4K);
+
+	if (!gic_dist_base)
+		return -ENOMEM;
+
+	return 0;
+}
 
 static int am33xx_suspend_init(void)
 {
@@ -386,6 +515,12 @@ static int am43xx_suspend_init(void)
 			return ret;
 	}
 
+	ret = am43xx_map_gic();
+	if (ret) {
+		pr_err("PM: Could not ioremap GIC\n");
+		return ret;
+	}
+
 	susp_params.l2_base_virt = omap4_get_l2cache_base();
 
 	if (!susp_params.l2_base_virt) {
@@ -440,12 +575,16 @@ static struct am33xx_pm_ops am33xx_ops = {
 	.init = am33xx_suspend_init,
 	.pre_suspend = am33xx_pre_suspend,
 	.post_suspend = am33xx_post_suspend,
+	.save_context = am33xx_save_context,
+	.restore_context = am33xx_restore_context,
 };
 
 static struct am33xx_pm_ops am43xx_ops = {
 	.init = am43xx_suspend_init,
 	.pre_suspend = am43xx_pre_suspend,
 	.post_suspend = am43xx_post_suspend,
+	.save_context = am43xx_save_context,
+	.restore_context = am43xx_restore_context,
 };
 #endif /* CONFIG_SUSPEND */
 #endif /* CONFIG_CPU_PM */
@@ -493,6 +632,8 @@ int __init am33xx_pm_init(void)
 	else if (soc_is_am43xx())
 		am33xx_pm->ops = &am43xx_ops;
 
+	rtc_magic_val = RTC_REG_BOOT_MAGIC;
+
 	ret = am33xx_pm->ops->init();
 
 	if (ret)
@@ -506,6 +647,7 @@ int __init am33xx_pm_init(void)
 	susp_params.wfi_flags = 0;
 	susp_params.emif_addr_virt = am33xx_emif_base;
 	susp_params.dram_sync = am33xx_dram_sync;
+	susp_params.rtc_base = omap_rtc_get_base_addr();
 
 	switch (temp) {
 	case MEM_TYPE_DDR2:
@@ -527,6 +669,7 @@ int __init am33xx_pm_init(void)
 		if (of_find_property(np, "ti,needs-vtt-toggle", NULL) &&
 		    (!(of_property_read_u32(np, "ti,vtt-gpio-pin",
 							&temp)))) {
+			rtc_magic_val |= RTC_REG_DDR_TYPE_DDR3_0;
 			if (temp >= 0 && temp <= 31)
 				am33xx_pm->ipc.reg4 |=
 					((1 << VTT_STAT_SHIFT) |
@@ -549,11 +692,25 @@ int __init am33xx_pm_init(void)
 	else
 		pr_err("PM: Failed to get cefuse_pwrdm\n");
 
+	rtc_oh = omap_hwmod_lookup("rtc");
+	if (!rtc_oh) {
+		pr_err("PM: could not locate rtc hwmod\n");
+		ret = -ENOENT;
+		goto err;
+	}
+
 #ifdef CONFIG_CPU_PM
 	am33xx_pm->state = M3_STATE_RESET;
 
 	wkup_m3_set_ops(&am33xx_wkup_m3_ops);
 
+	pmx_dev = get_pinctrl_dev_from_devname("44e10800.pinmux");
+	omap_rtc = rtc_class_open("rtc0");
+
+	rtc_write_scratch(omap_rtc, RTC_SCRATCH_MAGIC_REG, 0);
+	rtc_write_scratch(omap_rtc, RTC_SCRATCH_RESUME_REG,
+			  virt_to_phys(cpu_resume));
+
 	return 0;
 
 err:
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
index daf38bb..d3714de 100644
--- a/arch/arm/mach-omap2/pm33xx.h
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -24,6 +24,8 @@ struct am33xx_pm_ops {
 	int (*init)(void);
 	void (*pre_suspend)(unsigned int state);
 	void (*post_suspend)(unsigned int state);
+	void (*save_context)(void);
+	void (*restore_context)(void);
 };
 
 struct am33xx_pm_context {
@@ -48,14 +50,18 @@ struct am33xx_suspend_params {
 	void __iomem *dram_sync;
 	void __iomem *l2_base_virt;
 	void __iomem *cke_override_virt;
+	void __iomem *rtc_base;
 };
 
 void wkup_m3_reset_data_pos(void);
 int wkup_m3_copy_data(const u8 *data, size_t size);
 int am33xx_do_sram_cpuidle(u32, u32);
+void omap_rtc_power_off_program(void);
+void __iomem *omap_rtc_get_base_addr(void);
 
 #endif /*__ASSEMBLER__ */
 
+#define IPC_CMD_RTC_ONLY		0x1
 #define	IPC_CMD_DS0			0x4
 #define	IPC_CMD_STANDBY			0xc
 #define	IPC_CMD_IDLE			0xd
@@ -97,6 +103,7 @@ int am33xx_do_sram_cpuidle(u32, u32);
 #define WFI_SAVE_EMIF		(1 << 3)
 #define WFI_WAKE_M3		(1 << 4)
 #define WFI_DISABLE_EMIF	(1 << 7)
+#define WFI_RTC_ONLY		(1 << 8)
 
 /*
  * 9-4 = VTT GPIO PIN (6 Bits)
diff --git a/arch/arm/mach-omap2/sleep43xx.S b/arch/arm/mach-omap2/sleep43xx.S
index 15fa9e2..a1cf8fb 100644
--- a/arch/arm/mach-omap2/sleep43xx.S
+++ b/arch/arm/mach-omap2/sleep43xx.S
@@ -50,6 +50,10 @@
 #define AM43XX_CM_CLKSTCTRL_CLKTRCTRL_SW_SLEEP		0x1
 #define AM43XX_CM_CLKSTCTRL_CLKTRCTRL_HW_AUTO		0x3
 
+#define RTC_SECONDS_REG					0x0
+#define RTC_PMIC_REG					0x98
+#define RTC_PMIC_POWER_EN				(1 << 16)
+
 	.text
 	.align 3
 
@@ -57,13 +61,15 @@
  * This routine is executed from internal RAM and expects some
  * parameters to be passed in r0 _strictly_ in following order:
  * 1) emif_addr_virt - ioremapped EMIF address
- * 2) mem_type - 2 -> DDR2, 3-> DDR3
+ * 2) wfi_flags - 2 -> DDR2, 3-> DDR3
  * 3) dram_sync_word - uncached word in SDRAM
  * 4) l2_virt_base - L2CC ioremapped address for AM437x
+ * 5) cke_override_virt - CKE override virtual address
+ * 6) rtc_base_addr - ioremapped RTC base address
  *
  * The code loads these values taking r0 value as reference to
  * the array in registers starting from r0, i.e emif_addr_virt
- * goes to r1, mem_type goes to r2 and and so on. These are
+ * goes to r1, wfi_flags goes to r2 and and so on. These are
  * then saved into memory locations before proceeding with the
  * sleep sequence and hence registers r0, r1 etc can still be
  * used in the rest of the sleep code.
@@ -72,14 +78,15 @@
 ENTRY(am43xx_do_wfi)
 	stmfd	sp!, {r4 - r11, lr}	@ save registers on stack
 
-	ldm	r0, {r1-r5}		@ gather values passed
+	ldm	r0, {r1-r6}		@ gather values passed
 
 	/* Save the values passed */
 	str	r1, emif_addr_virt
-	str	r2, mem_type
+	str	r2, wfi_flags
 	str	r3, dram_sync_word
 	str	r4, l2_base_virt
 	str	r5, cke_override_virt
+	str	r6, rtc_base_addr
 
 	ldr	r0, emif_addr_virt
 	/* Save EMIF configuration */
@@ -244,6 +251,29 @@ wait_emif_disable:
 	mov    r1, #0
 	str    r1, [r2]
 
+	ldr	r1, wfi_flags
+	tst	r1, #WFI_RTC_ONLY
+	beq	am43xx_deep_sleep_suspend
+
+	ldr	r1, rtc_base_addr
+	ldr	r0, [r1, #RTC_PMIC_REG]
+	orr	r0, r0, #RTC_PMIC_POWER_EN
+	str	r0, [r1, #RTC_PMIC_REG]
+	ldr	r0, [r1, #RTC_PMIC_REG]
+	/* Wait for 2 seconds to lose power */
+	mov	r3, #2
+	ldr	r2, [r1, #RTC_SECONDS_REG]
+rtc_loop:
+	ldr	r0, [r1, #RTC_SECONDS_REG]
+	cmp	r0, r2
+	beq	rtc_loop
+	mov	r2, r0
+	subs	r3, r3, #1
+	bne	rtc_loop
+
+	b	re_enable_emif
+
+am43xx_deep_sleep_suspend:
 	/*
 	 * For the MPU WFI to be registered as an interrupt
 	 * to WKUP_M3, MPU_CLKCTRL.MODULEMODE needs to be set
@@ -305,6 +335,7 @@ wait_emif_disable:
 	mov	r2, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
 	str	r2, [r1]
 
+re_enable_emif:
 	/* Re-enable EMIF */
 	ldr	r1, am43xx_virt_emif_clkctrl
 	mov	r2, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
@@ -516,6 +547,10 @@ ddr_start:
 	.word	PAGE_OFFSET
 emif_phys_addr:
 	.word	AM33XX_EMIF_BASE
+wfi_flags:
+	.word	0
+rtc_base_addr:
+	.word	(0xdeadbeef)
 
 cke_override_virt:
 	.word	0xDEADBEEF
@@ -558,8 +593,6 @@ l2_smc3:
 /* DDR related defines */
 dram_sync_word:
 	.word	0xDEADBEEF
-mem_type:
-	.word	0xDEADBEEF
 l2_base_virt:
 	.word	0xDEADBEEF
 emif_addr_virt:
-- 
1.7.5.4

