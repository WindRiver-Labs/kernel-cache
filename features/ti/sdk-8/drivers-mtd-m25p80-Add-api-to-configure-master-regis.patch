From 622c0d42a776da4af9ac998d63aacb3287630173 Mon Sep 17 00:00:00 2001
From: Sourav Poddar <sourav.poddar@ti.com>
Date: Thu, 5 Dec 2013 10:08:33 +0530
Subject: [PATCH 0639/1587] drivers: mtd: m25p80: Add api to configure master
 register.

These can be used to fill information needed to configure
master controller registers. Also do a memory mapped read, if
qspi controller supports memory mapped mode.

Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/mtd/devices/m25p80.c |   39 +++++++++++++++++++++++++++++++++++++++
 1 files changed, 39 insertions(+), 0 deletions(-)

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 524dab3..e1bbf75 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -110,6 +110,7 @@ struct m25p {
 	u8			read_opcode;
 	u8			program_opcode;
 	u8			*command;
+	void __iomem            *mem_addr;
 	enum read_type		flash_read;
 };
 
@@ -505,6 +506,24 @@ static inline unsigned int m25p80_rx_nbits(const struct m25p *flash)
 }
 
 /*
+ * This API can be used to transfer flash information to
+ * SPI controller which needs some of its registers to get
+ * configured on flash.
+ */
+static void m25p80_fill_flash_information(struct m25p *flash)
+{
+	struct spi_master *master = flash->spi->master;
+	u8 info[4];
+
+	info[0] = flash->read_opcode;
+	info[1] = flash->program_opcode;
+	info[2] = flash->addr_width;
+	info[3] = m25p80_dummy_cycles_read(flash);
+
+	master->configure_from_slave(flash->spi, info);
+}
+
+/*
  * Read an address range from the flash chip.  The address range
  * may be any size provided it is within the physical boundaries.
  */
@@ -512,6 +531,8 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 	size_t *retlen, u_char *buf)
 {
 	struct m25p *flash = mtd_to_m25p(mtd);
+	struct spi_master *master = flash->spi->master;
+
 	struct spi_transfer t[2];
 	struct spi_message m;
 	uint8_t opcode;
@@ -520,6 +541,20 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 	pr_debug("%s: %s from 0x%08x, len %zd\n", dev_name(&flash->spi->dev),
 			__func__, (u32)from, len);
 
+	if (master->mmap) {
+		mutex_lock(&flash->lock);
+		if (wait_till_ready(flash)) {
+			/* REVISIT status return?? */
+			mutex_unlock(&flash->lock);
+			return 1;
+		}
+		flash->mem_addr = master->get_buf(master);
+		memcpy(buf, flash->mem_addr + from, len);
+		master->put_buf(master);
+		*retlen = len;
+		goto out;
+	}
+
 	spi_message_init(&m);
 	memset(t, 0, (sizeof t));
 
@@ -556,6 +591,7 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 
 	*retlen = m.actual_length - m25p_cmdsz(flash) - dummy;
 
+out:
 	mutex_unlock(&flash->lock);
 
 	return 0;
@@ -1297,6 +1333,9 @@ static int m25p_probe(struct spi_device *spi)
 		flash->addr_width = 3;
 	}
 
+	if (spi->master->configure_from_slave)
+		m25p80_fill_flash_information(flash);
+
 	dev_info(&spi->dev, "%s (%lld Kbytes)\n", id->name,
 			(long long)flash->mtd.size >> 10);
 
-- 
1.7.5.4

