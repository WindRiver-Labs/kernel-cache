From cc8829aecf5c91b07ac4440fa8d93d88f2c300e2 Mon Sep 17 00:00:00 2001
From: R Sricharan <r.sricharan@ti.com>
Date: Fri, 7 Mar 2014 17:46:12 +0530
Subject: [PATCH 1049/1587] drivers: dma: Add dma crossbar driver

DRA7XX dma controller IP's are preceded by a crossbar which
routes the dma requests from the peripherals to the dma
request input lines of the appropriate dma controller.
With this the dma controller's available request lines
are shared between the peripherals.

The driver maintains a list of free dma request lines and
allocates one during the map callback which is invoked as
a part the dma engine driver's device_alloc_chan_resources
callback. The allocated request line is freed during the
device_free_chan_resources.

Signed-off-by: R Sricharan <r.sricharan@ti.com>
Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 .../devicetree/bindings/arm/omap/dma-crossbar.txt  |   51 +++++
 drivers/dma/Kconfig                                |    7 +
 drivers/dma/Makefile                               |    1 +
 drivers/dma/omap-dma-xbar.c                        |  223 ++++++++++++++++++++
 drivers/dma/omap-dma-xbar.h                        |   34 +++
 drivers/dma/omap-dma.c                             |    1 +
 6 files changed, 317 insertions(+), 0 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/arm/omap/dma-crossbar.txt
 create mode 100644 drivers/dma/omap-dma-xbar.c
 create mode 100644 drivers/dma/omap-dma-xbar.h

diff --git a/Documentation/devicetree/bindings/arm/omap/dma-crossbar.txt b/Documentation/devicetree/bindings/arm/omap/dma-crossbar.txt
new file mode 100644
index 0000000..f63a6b6
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/omap/dma-crossbar.txt
@@ -0,0 +1,51 @@
+Some socs have a crossbar ip which muxes the dma requests
+from the peripherals to the dma request input lines of the
+appropriate dma controller. With this the dma controller's
+available request lines are shared between the peripherals
+
+Required properties:
+- compatible : Should be "ti,dma-crossbar"
+- reg: Base address and the size of the crossbar registers.
+- ti,dma-reqs: Total number of dma request lines available at dma controller.
+- ti,reg-size: Size of a individual register in bytes. Every individual
+	    register is assumed to be of same size. Valid sizes are 1, 2, 4.
+- ti,dmas-reserved: List of the reserved dma lines that are not muxed using
+		 crossbar. These dma lines are reserved in the soc,
+		 so crossbar bar driver should not consider them as free
+		 lines. This is a table of dma request-number and a count of
+		 reserved values from that number.
+
+Optional properties:
+- ti,dma-safe-map: integer which maps to a safe configuration to use
+  when the dma request line is unused (when not provided, default is 0)
+
+Examples:
+		crossbar_dma: crossbar@4a020000 {
+			compatible = "ti,dma-crossbar";
+			reg = <0x4a002b78 0x100>;
+			ti,dma-reqs = <160>;
+			ti,reg-size = <2>;
+			ti,dmas-reserved = < 2, 5,
+					     10, 2 >;
+		};
+
+Consumer:
+=========
+See Documentation/devicetree/bindings/dma/dma.txt for further details.
+
+A dma request line consumer on an SoC using dma crossbar will use:
+	dmas = <&dma-controller-node crossbar_req_no  &dma-crossbar-node>
+Crossbar no should be in between 0 to that described by "ti,dma-reqs".
+
+Example:
+	device_x@4809c000 {
+		...
+		/*
+		 * sdma is p-handle to dma controller node.
+		 * dmacb is p-handle to dma crossbar node.
+		 * Crossbar 61, 62 are used for tx, rx respectively.
+		 */
+		dmas = <&sdma 61 &dmacb>, <&sdma 62 &dmacb>;
+		dma-names = "tx", "rx";
+		...
+	};
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 605b016..f3dc2c7 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -401,4 +401,11 @@ config DMATEST
 config DMA_ENGINE_RAID
 	bool
 
+config OMAP_DMA_CROSSBAR
+	bool
+	depends on DMA_OMAP
+	help
+	  This enables the dma crossbar ip support to dynamically map the
+	  peripheral dma request lines to the dma controller's input.
+
 endif
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index a029d0f4..d84190e 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -44,3 +44,4 @@ obj-$(CONFIG_DMA_JZ4740) += dma-jz4740.o
 obj-$(CONFIG_TI_CPPI41) += cppi41.o
 obj-$(CONFIG_K3_DMA) += k3dma.o
 obj-$(CONFIG_MOXART_DMA) += moxart-dma.o
+obj-$(CONFIG_OMAP_DMA_CROSSBAR) += omap-dma-xbar.o
diff --git a/drivers/dma/omap-dma-xbar.c b/drivers/dma/omap-dma-xbar.c
new file mode 100644
index 0000000..8512915
--- /dev/null
+++ b/drivers/dma/omap-dma-xbar.c
@@ -0,0 +1,223 @@
+/*
+ *  Copyright (C) 2014 Texas Instruments Incorporated - http://www.ti.com
+ *  Author: Sricharan R <r.sricharan@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_dma.h>
+#include <linux/module.h>
+
+#include "omap-dma-xbar.h"
+
+#define DMASIGNAL_FREE		-1
+#define DMASIGNAL_RESERVED	-2
+
+static struct platform_device *pd_xbar;
+
+static void dma_xbar_writeb(int dma_sig, int dma_xbar,
+			    struct dma_xbar_device *xbar)
+{
+	writeb(dma_xbar, xbar->dma_xbar_base + xbar->reg_offs[dma_sig]);
+}
+
+static void dma_xbar_writew(int dma_sig, int dma_xbar,
+			    struct dma_xbar_device *xbar)
+{
+	writew(dma_xbar, xbar->dma_xbar_base + xbar->reg_offs[dma_sig]);
+}
+
+static void dma_xbar_writel(int dma_sig, int dma_xbar,
+			    struct dma_xbar_device *xbar)
+{
+	writel(dma_xbar, xbar->dma_xbar_base + xbar->reg_offs[dma_sig]);
+}
+
+static uint32_t dma_xbar_map(uint32_t dma_xbar, struct dma_xbar_device *xbar)
+{
+	int i;
+
+	for (i = 1; i < xbar->dma_max; i++) {
+		if (xbar->dma_map[i] == DMASIGNAL_FREE) {
+			xbar->dma_map[i] = dma_xbar;
+			xbar->write(i - 1, dma_xbar, xbar);
+			return i;
+		}
+	}
+	return -ENODEV;
+}
+
+static void dma_xbar_unmap(uint32_t dma_sig, struct dma_xbar_device *xbar)
+{
+	xbar->dma_map[dma_sig] = DMASIGNAL_FREE;
+	xbar->write(dma_sig - 1, xbar->safe_map, xbar);
+}
+
+const struct xbar_ops dma_xbar_ops = {
+	.map = dma_xbar_map,
+	.unmap = dma_xbar_unmap,
+};
+
+static int omap_dma_xbar_probe(struct platform_device *pdev)
+{
+	int i, j, reserved = 0;
+	const __be32 *dmar;
+	uint max, size, entry, range;
+	struct resource *res;
+	struct dma_xbar_device *xbar;
+
+	pd_xbar = pdev;
+
+	xbar = devm_kzalloc(&pdev->dev, sizeof(*xbar), GFP_KERNEL);
+	if (!xbar)
+		return -ENOMEM;
+
+	xbar->ops = &dma_xbar_ops;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xbar->dma_xbar_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(xbar->dma_xbar_base))
+		return PTR_ERR(xbar->dma_xbar_base);
+
+	of_property_read_u32(pdev->dev.of_node, "ti,dma-reqs", &max);
+	if (!max) {
+		pr_err("missing 'ti,dma-irqs' property\n");
+		return -EINVAL;
+	}
+
+	xbar->dma_map = devm_kzalloc(&pdev->dev, max * sizeof(int), GFP_KERNEL);
+	if (!xbar->dma_map)
+		return -ENOMEM;
+
+	xbar->dma_max = max;
+
+	for (i = 0; i < max; i++)
+		xbar->dma_map[i] = DMASIGNAL_FREE;
+
+	/* Get and mark reserved dma req lines */
+	dmar = of_get_property(pdev->dev.of_node, "ti,dmas-reserved", &size);
+	if (dmar) {
+		size /= sizeof(__be32);
+
+		for (i = 0; i < size; i++) {
+			of_property_read_u32_index(pdev->dev.of_node,
+						   "ti,dmas-reserved",
+						   i++, &entry);
+			of_property_read_u32_index(pdev->dev.of_node,
+						   "ti,dmas-reserved",
+						   i, &range);
+			if ((entry + range > max) ||
+			    ((entry + range) <= entry)) {
+				pr_err("Invalid reserved entry\n");
+				return -ENODEV;
+			}
+
+			for (j = entry; j <= range; j++)
+				xbar->dma_map[j] = DMASIGNAL_RESERVED;
+
+			/* For a single entry */
+			if (!range)
+				xbar->dma_map[entry] = DMASIGNAL_RESERVED;
+		}
+	}
+
+	xbar->reg_offs = devm_kzalloc(&pdev->dev, max * sizeof(int),
+				      GFP_KERNEL);
+	if (!xbar->reg_offs)
+		return -ENOMEM;
+
+	of_property_read_u32(pdev->dev.of_node, "ti,reg-size", &size);
+
+	switch (size) {
+	case 1:
+		xbar->write = dma_xbar_writeb;
+		break;
+	case 2:
+		xbar->write = dma_xbar_writew;
+		break;
+	case 4:
+		xbar->write = dma_xbar_writel;
+		break;
+	default:
+		pr_err("Invalid reg-size property\n");
+		return -ENODEV;
+		break;
+	}
+
+	/*
+	 * Register offsets are not linear because of the
+	 * reserved lines. so find and store the offsets once.
+	 */
+	for (i = 0; i < max; i++) {
+		if (xbar->dma_map[i] == DMASIGNAL_RESERVED)
+			continue;
+
+		xbar->reg_offs[i] = reserved;
+		reserved += size;
+	}
+
+	of_property_read_u32(pdev->dev.of_node, "ti,dma-safe-map",
+			     &xbar->safe_map);
+	/* Initialize the crossbar with safe map to start with */
+	for (i = 0; i < max; i++) {
+		if (xbar->dma_map[i] == DMASIGNAL_RESERVED)
+			continue;
+
+		xbar->write(i, xbar->safe_map, xbar);
+	}
+
+	if (of_dma_router_register(pdev->dev.of_node, xbar))
+		return -ENODEV;
+
+	dev_info(&pdev->dev, "OMAP DMA Crossbar driver\n");
+
+	return 0;
+}
+
+static int omap_dma_xbar_remove(struct platform_device *pdev)
+{
+	if (pdev->dev.of_node)
+		of_dma_router_free(pdev->dev.of_node);
+
+	return 0;
+}
+
+static const struct of_device_id dma_xbar_match[] = {
+	{ .compatible = "ti,dma-crossbar" },
+	{},
+};
+
+static struct platform_driver omap_dma_xbar_driver = {
+	.probe	= omap_dma_xbar_probe,
+	.remove	= omap_dma_xbar_remove,
+	.driver = {
+		.name = "omap-dma-xbar",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(dma_xbar_match),
+	},
+};
+
+int omap_dmaxbar_init(void)
+{
+	return platform_driver_register(&omap_dma_xbar_driver);
+}
+arch_initcall(omap_dmaxbar_init);
+
+static void __exit omap_dmaxbar_exit(void)
+{
+	platform_driver_unregister(&omap_dma_xbar_driver);
+}
+module_exit(omap_dmaxbar_exit);
+
+MODULE_DESCRIPTION("OMAP DMA XBAR");
+MODULE_AUTHOR("Sricharan R");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/omap-dma-xbar.h b/drivers/dma/omap-dma-xbar.h
new file mode 100644
index 0000000..0ff9179
--- /dev/null
+++ b/drivers/dma/omap-dma-xbar.h
@@ -0,0 +1,34 @@
+/*
+ *  Copyright (C) 2014 Texas Instruments Incorporated - http://www.ti.com
+ *  Author: Sricharan R <r.sricharan@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/*
+ * struct dma_xbar_device: dma crossbar device description
+ * @safe_map: safe default value to initialize the crossbar
+ * @dma_max: maximum number of dma request lines available at dma controller
+ * @dma_map: array of dma request lines to crossbar number mapping
+ * @dma_xbar_bas: dma crossbar base address
+ * @reg_offs: offsets for each dma request number
+ * @write: function to write in to the dma crossbar
+ * @xbar_ops: pointer to xbar_ops for map and unmap.
+ */
+struct dma_xbar_device {
+	uint safe_map;
+	uint dma_max;
+	uint *dma_map;
+	void __iomem *dma_xbar_base;
+	int *reg_offs;
+	void (*write)(int, int, struct dma_xbar_device *);
+	const struct xbar_ops *ops;
+};
+
+struct xbar_ops {
+	uint32_t (*map)(uint32_t, struct dma_xbar_device *);
+	void (*unmap)(uint32_t,  struct dma_xbar_device *);
+};
diff --git a/drivers/dma/omap-dma.c b/drivers/dma/omap-dma.c
index 2a86797..0437fb8 100644
--- a/drivers/dma/omap-dma.c
+++ b/drivers/dma/omap-dma.c
@@ -21,6 +21,7 @@
 #include <linux/of_device.h>
 
 #include "virt-dma.h"
+#include "omap-dma-xbar.h"
 
 struct omap_dmadev {
 	struct dma_device ddev;
-- 
1.7.5.4

