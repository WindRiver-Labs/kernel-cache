From dc0fd2d4d8f565e5de4f46869eccd86c20215c75 Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Fri, 7 Nov 2014 11:17:13 -0600
Subject: [PATCH 1333/1587] rpmsg: rpc: maintain a reference device pointer
 per open fd

The remote processor recovery process includes the deletion and
recreation of an rpmsg-rpc device. The representative rppc_device
structure is retained and reused if there are any open applications
using the exposed character device. The underlying device pointer
for a rppc_device is though deleted and recreated and is asynchronous
to any of the operations on the exposed character device. A reference
to this device pointer is to be maintained therefore for each open
application so that it can be used during regular fops and until the
file descriptor is closed instead of referencing the rppc_device's
dev pointer, which can become NULL at any point due to a recovery
process. The actual memory of the rppc_device's dev pointer deleted
in the driver's .remove() is freed when all the open applications
have closed either gracefully or forcefully. Any new applications
after a recovery will leverage a newly created device pointer.

Signed-off-by: Suman Anna <s-anna@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/rpmsg/rpmsg_rpc.c          |    3 +++
 drivers/rpmsg/rpmsg_rpc_internal.h |    2 ++
 2 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/drivers/rpmsg/rpmsg_rpc.c b/drivers/rpmsg/rpmsg_rpc.c
index c7a2983..ff47b58 100644
--- a/drivers/rpmsg/rpmsg_rpc.c
+++ b/drivers/rpmsg/rpmsg_rpc.c
@@ -570,10 +570,12 @@ static int rppc_open(struct inode *inode, struct file *filp)
 	rpc->state = RPPC_STATE_DISCONNECTED;
 	rpc->rppcdev = rppcdev;
 
+	rpc->dev = get_device(rppcdev->dev);
 	rpc->ept = rpmsg_create_ept(rppcdev->rpdev, rppc_cb, rpc,
 								RPMSG_ADDR_ANY);
 	if (!rpc->ept) {
 		dev_err(rppcdev->dev, "create ept failed\n");
+		put_device(rpc->dev);
 		kfree(rpc);
 		return -ENOMEM;
 	}
@@ -633,6 +635,7 @@ static int rppc_release(struct inode *inode, struct file *filp)
 	if (list_empty(&rppcdev->instances))
 		dev_dbg(rppcdev->dev, "all instances have been removed!\n");
 
+	put_device(rpc->dev);
 	kfree(rpc);
 	return 0;
 }
diff --git a/drivers/rpmsg/rpmsg_rpc_internal.h b/drivers/rpmsg/rpmsg_rpc_internal.h
index 765e0c8..40b7758 100644
--- a/drivers/rpmsg/rpmsg_rpc_internal.h
+++ b/drivers/rpmsg/rpmsg_rpc_internal.h
@@ -90,6 +90,7 @@ struct rppc_device {
  * struct rppc_instance - The per-instance data structure (per user)
  * @list: list node
  * @rppcdev: the rppc device (remote server instance) handle
+ * @dev: local device reference pointer of the rppc device
  * @queue: queue of buffers waiting to be read by the user
  * @lock: mutex for protecting instance variables
  * @readq: wait queue of blocked user threads waiting to read data
@@ -110,6 +111,7 @@ struct rppc_device {
 struct rppc_instance {
 	struct list_head list;
 	struct rppc_device *rppcdev;
+	struct device *dev;
 	struct sk_buff_head queue;
 	struct mutex lock;
 	wait_queue_head_t readq;
-- 
1.7.5.4

