From cc168415a22ffbc2af3b886360e90bcbe219572a Mon Sep 17 00:00:00 2001
From: Benoit Parrot <bparrot@ti.com>
Date: Mon, 10 Nov 2014 12:14:19 -0600
Subject: [PATCH 1328/1587] media: ti-vpe: vip: Fix format enumeration to
 match sensor capabilities

Format enumeration was based on a static/private format table.
Until CSC is enabled the format enumerated must match the sensor capability only.

Signed-off-by: Benoit Parrot <bparrot@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/media/platform/ti-vpe/vip.c |  233 ++++++++++++++++++++++++++++-------
 drivers/media/platform/ti-vpe/vip.h |   34 ++++--
 2 files changed, 213 insertions(+), 54 deletions(-)

diff --git a/drivers/media/platform/ti-vpe/vip.c b/drivers/media/platform/ti-vpe/vip.c
index 7c3c292..648427f 100644
--- a/drivers/media/platform/ti-vpe/vip.c
+++ b/drivers/media/platform/ti-vpe/vip.c
@@ -122,18 +122,11 @@ static struct vip_srce_info srce_info[5] = {
 	},
 };
 
-struct vip_fmt {
-	char	*name;			/* Human-readable name */
-	u32	fourcc;			/* The standard format identifier */
-	enum v4l2_colorspace colorspace;/* Colorspace: YPE_YUV or YPE_RGB */
-	u8	coplanar;		/* set for unpacked Luma and Chroma */
-	const struct vpdma_data_format *vpdma_fmt[VIP_MAX_PLANES];
-};
-
 static struct vip_fmt vip_formats[] = {
 	{
 		.name		= "YUV 444 co-planar",
 		.fourcc		= V4L2_PIX_FMT_NV24,
+		.code		= V4L2_MBUS_FMT_YDYUYDYV8_1X16,
 		.colorspace	= V4L2_COLORSPACE_SMPTE170M,
 		.coplanar	= 1,
 		.vpdma_fmt	= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_Y444],
@@ -143,6 +136,7 @@ static struct vip_fmt vip_formats[] = {
 	{
 		.name		= "YUV 422 co-planar",
 		.fourcc		= V4L2_PIX_FMT_NV16,
+		.code		= V4L2_MBUS_FMT_YDYUYDYV8_1X16,
 		.colorspace	= V4L2_COLORSPACE_SMPTE170M,
 		.coplanar	= 1,
 		.vpdma_fmt	= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_Y422],
@@ -152,6 +146,7 @@ static struct vip_fmt vip_formats[] = {
 	{
 		.name		= "YUV 420 co-planar",
 		.fourcc		= V4L2_PIX_FMT_NV12,
+		.code		= V4L2_MBUS_FMT_YDYUYDYV8_1X16,
 		.colorspace	= V4L2_COLORSPACE_SMPTE170M,
 		.coplanar	= 1,
 		.vpdma_fmt	= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_Y420],
@@ -161,6 +156,7 @@ static struct vip_fmt vip_formats[] = {
 	{
 		.name		= "UYVY 422 packed",
 		.fourcc		= V4L2_PIX_FMT_UYVY,
+		.code		= V4L2_MBUS_FMT_UYVY8_2X8,
 		.colorspace	= V4L2_COLORSPACE_SMPTE170M,
 		.coplanar	= 0,
 		.vpdma_fmt	= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_CY422],
@@ -169,14 +165,16 @@ static struct vip_fmt vip_formats[] = {
 	{
 		.name		= "YUYV 422 packed",
 		.fourcc		= V4L2_PIX_FMT_YUYV,
+		.code		= V4L2_MBUS_FMT_YUYV8_2X8,
 		.colorspace	= V4L2_COLORSPACE_SMPTE170M,
 		.coplanar	= 0,
 		.vpdma_fmt	= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_YC422],
 				  },
 	},
 	{
-		.name		= "YUYV 422 packed",
+		.name		= "VYUY 422 packed",
 		.fourcc		= V4L2_PIX_FMT_VYUY,
+		.code		= V4L2_MBUS_FMT_VYUY8_2X8,
 		.colorspace	= V4L2_COLORSPACE_SMPTE170M,
 		.coplanar	= 0,
 		.vpdma_fmt	= { &vpdma_yuv_fmts[VPDMA_DATA_FMT_YC422],
@@ -185,6 +183,7 @@ static struct vip_fmt vip_formats[] = {
 	{
 		.name		= "RGB888 packed",
 		.fourcc		= V4L2_PIX_FMT_RGB24,
+		.code		= V4L2_MBUS_FMT_RGB888_1X24,
 		.colorspace	= V4L2_COLORSPACE_SRGB,
 		.coplanar	= 0,
 		.vpdma_fmt	= { &vpdma_rgb_fmts[VPDMA_DATA_FMT_RGB24],
@@ -193,6 +192,7 @@ static struct vip_fmt vip_formats[] = {
 	{
 		.name		= "ARGB888 packed",
 		.fourcc		= V4L2_PIX_FMT_RGB32,
+		.code		= V4L2_MBUS_FMT_ARGB8888_1X32,
 		.colorspace	= V4L2_COLORSPACE_SRGB,
 		.coplanar	= 0,
 		.vpdma_fmt	= { &vpdma_rgb_fmts[VPDMA_DATA_FMT_ARGB32],
@@ -200,16 +200,60 @@ static struct vip_fmt vip_formats[] = {
 	},
 };
 
+/*  Print Four-character-code (FOURCC) */
+static char *fourcc_to_str(u32 fmt)
+{
+	static char code[5];
+	code[0] = (unsigned char)(fmt & 0xff);
+	code[1] = (unsigned char)((fmt>>8) & 0xff);
+	code[2] = (unsigned char)((fmt>>16) & 0xff);
+	code[3] = (unsigned char)((fmt>>24) & 0xff);
+	code[4] = '\0';
+
+	return code;
+}
+
 /*
  * Find our format description corresponding to the passed v4l2_format
  */
-static struct vip_fmt *find_format(u32 pixelformat)
+#ifdef DISABLED_FOR_NOW
+static struct vip_fmt *find_format_by_pix(u32 pixelformat)
+{
+	struct vip_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(vip_formats); k++) {
+		fmt = &vip_formats[k];
+		if (fmt->fourcc == pixelformat)
+			return fmt;
+	}
+
+	return NULL;
+}
+#endif
+
+static struct vip_fmt *find_format_by_code(u32 code)
 {
 	struct vip_fmt *fmt;
 	unsigned int k;
 
 	for (k = 0; k < ARRAY_SIZE(vip_formats); k++) {
 		fmt = &vip_formats[k];
+		if (fmt->code == code)
+			return fmt;
+	}
+
+	return NULL;
+}
+
+static struct vip_fmt *find_active_format_by_pix(struct vip_dev *dev,
+						 u32 pixelformat)
+{
+	struct vip_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < dev->num_active_fmt; k++) {
+		fmt = dev->active_fmt[k];
 		if (fmt->fourcc == pixelformat)
 			return fmt;
 	}
@@ -217,6 +261,21 @@ static struct vip_fmt *find_format(u32 pixelformat)
 	return NULL;
 }
 
+static struct vip_fmt *find_active_format_by_code(struct vip_dev *dev,
+						 u32 code)
+{
+	struct vip_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < dev->num_active_fmt; k++) {
+		fmt = dev->active_fmt[k];
+		if (fmt->code == code)
+			return fmt;
+	}
+
+	return NULL;
+}
+
 static LIST_HEAD(vip_shared_list);
 
 static inline struct vip_dev *notifier_to_vip_dev(struct v4l2_async_notifier *n)
@@ -1198,16 +1257,22 @@ static int vip_enuminput(struct file *file, void *priv,
 static int vip_enum_fmt_vid_cap(struct file *file, void *priv,
 				struct v4l2_fmtdesc *f)
 {
+	struct vip_stream *stream = file2stream(file);
+	struct vip_dev *dev = stream->port->dev;
 	struct vip_fmt *fmt;
 
-	if (f->index >= ARRAY_SIZE(vip_formats))
+	vip_dbg(3, dev, "enum_fmt index:%d\n", f->index);
+	if (f->index >= dev->num_active_fmt)
 		return -EINVAL;
 
-	fmt = &vip_formats[f->index];
+	fmt = dev->active_fmt[f->index];
 
 	strncpy(f->description, fmt->name, sizeof(f->description) - 1);
 	f->pixelformat = fmt->fourcc;
 
+	vip_dbg(3, dev, "enum_fmt fourcc:%s description:%s\n",
+		fourcc_to_str(f->pixelformat), f->description);
+
 	return 0;
 }
 
@@ -1224,7 +1289,7 @@ static int vip_enum_framesizes(struct file *file, void *priv,
 	struct vip_fmt *fmt;
 	int ret;
 
-	fmt = find_format(f->pixel_format);
+	fmt = find_active_format_by_pix(dev, f->pixel_format);
 	if (!fmt)
 		return -EINVAL;
 
@@ -1247,7 +1312,7 @@ static int vip_enum_frameintervals(struct file *file, void *priv,
 	if (f->index)
 		return -EINVAL;
 
-	fmt = find_format(f->pixel_format);
+	fmt = find_active_format_by_pix(dev, f->pixel_format);
 	if (!fmt)
 		return -EINVAL;
 
@@ -1296,38 +1361,13 @@ static int vip_s_parm(struct file *file, void *priv,
 	return 0;
 }
 
-static int vip_g_fmt_vid_cap(struct file *file, void *priv,
-			     struct v4l2_format *f)
-{
-	struct vip_stream *stream = file2stream(file);
-	struct vip_port *port = stream->port;
-	struct vip_dev *dev = stream->port->dev;
-	struct v4l2_mbus_framefmt mbus_fmt;
-	int ret;
-
-	f->fmt.pix.width	= stream->width;
-	f->fmt.pix.height	= stream->height;
-	f->fmt.pix.pixelformat	= port->fmt->fourcc;
-	f->fmt.pix.field	= stream->sup_field;
-	f->fmt.pix.colorspace	= port->fmt->colorspace;
-	f->fmt.pix.bytesperline	= stream->bytesperline;
-	f->fmt.pix.sizeimage	= stream->sizeimage;
-
-	ret = v4l2_subdev_call(dev->sensor, video, g_mbus_fmt, &mbus_fmt);
-	if (ret)
-		vip_dbg(1, dev, "g_mbus_fmt failed in subdev\n");
-
-	f->fmt.pix.field = mbus_fmt.field;
-
-	return 0;
-}
-
 static int vip_try_fmt_vid_cap(struct file *file, void *priv,
 			       struct v4l2_format *f)
 {
 	struct vip_stream *stream = file2stream(file);
 	struct vip_dev *dev = stream->port->dev;
-	struct vip_fmt *fmt = find_format(f->fmt.pix.pixelformat);
+	struct vip_fmt *fmt = find_active_format_by_pix(dev,
+							f->fmt.pix.pixelformat);
 	enum v4l2_field field;
 	int depth;
 
@@ -1366,6 +1406,75 @@ static int vip_try_fmt_vid_cap(struct file *file, void *priv,
 	return 0;
 }
 
+static int vip_g_fmt_vid_cap(struct file *file, void *priv,
+			     struct v4l2_format *f)
+{
+	struct vip_stream *stream = file2stream(file);
+	struct vip_port *port = stream->port;
+	struct vip_dev *dev = stream->port->dev;
+	struct v4l2_mbus_framefmt mbus_fmt;
+	struct vip_fmt *fmt;
+	struct v4l2_format try_f;
+	int ret;
+
+	/* Use last known values or defaults */
+	f->fmt.pix.width	= stream->width;
+	f->fmt.pix.height	= stream->height;
+	f->fmt.pix.pixelformat	= port->fmt->fourcc;
+	f->fmt.pix.field	= stream->sup_field;
+	f->fmt.pix.colorspace	= port->fmt->colorspace;
+	f->fmt.pix.bytesperline	= stream->bytesperline;
+	f->fmt.pix.sizeimage	= stream->sizeimage;
+
+	/* Check with the subdevice */
+	ret = v4l2_subdev_call(dev->sensor, video, g_mbus_fmt, &mbus_fmt);
+	if (ret)
+		vip_dbg(1, dev, "g_mbus_fmt failed in subdev\n");
+
+	fmt = find_active_format_by_code(dev, mbus_fmt.code);
+	if (!fmt) {
+		vip_err(dev,
+			"mbus_code (0x%08x) invalid.\n",
+			mbus_fmt.code);
+		return -EINVAL;
+	}
+
+	/*
+	 * Run a try_fmt call to properly calculate
+	 * the sizeimage and bytesperline values
+	 * in case the defaults were not accurate.
+	 */
+	try_f = *f;
+	try_f.fmt.pix.pixelformat = fmt->fourcc;
+	try_f.fmt.pix.width = mbus_fmt.width;
+	try_f.fmt.pix.height = mbus_fmt.height;
+	try_f.fmt.pix.field = mbus_fmt.field;
+	try_f.fmt.pix.colorspace = mbus_fmt.colorspace;
+
+	ret = vip_try_fmt_vid_cap(file, priv, &try_f);
+	if (ret)
+		return ret;
+
+	/*
+	 * Since everything looks correct update
+	 * the local copy as well to make sure we are consistent
+	 */
+	*f = try_f;
+	stream->width = f->fmt.pix.width;
+	stream->height = f->fmt.pix.height;
+	port->fmt->fourcc = f->fmt.pix.pixelformat;
+	stream->sup_field = f->fmt.pix.field;
+	port->fmt->colorspace = f->fmt.pix.colorspace;
+	stream->bytesperline = f->fmt.pix.bytesperline;
+	stream->sizeimage = f->fmt.pix.sizeimage;
+
+	vip_dbg(3, dev, "g_fmt fourcc:%s size: %dx%d\n",
+		fourcc_to_str(f->fmt.pix.pixelformat),
+		f->fmt.pix.width, f->fmt.pix.height);
+
+	return 0;
+}
+
 /*
  * Set the registers that are modified when the video format changes.
  */
@@ -1405,7 +1514,8 @@ int vip_s_fmt_vid_cap(struct file *file, void *priv,
 		return -EBUSY;
 	}
 
-	port->fmt		= find_format(f->fmt.pix.pixelformat);
+	port->fmt		= find_active_format_by_pix(dev,
+					f->fmt.pix.pixelformat);
 	stream->width		= f->fmt.pix.width;
 	stream->height		= f->fmt.pix.height;
 	port->fmt->colorspace	= f->fmt.pix.colorspace;
@@ -1855,7 +1965,7 @@ static int vip_init_port(struct vip_port *port)
 	if (ret)
 		goto done;
 
-	port->fmt = &vip_formats[5];
+	port->fmt = port->dev->active_fmt[0];
 	port->src_colorspace = port->fmt->colorspace;
 	port->c_rect.left = 0;
 	port->c_rect.top = 0;
@@ -2157,6 +2267,39 @@ static int vip_runtime_get(struct platform_device *pdev)
 	return r < 0 ? r : 0;
 }
 
+static int get_subdev_active_format(struct vip_dev *dev,
+				    struct v4l2_subdev *subdev)
+{
+	struct vip_fmt *fmt;
+	enum v4l2_mbus_pixelcode code;
+	int ret = 0;
+	unsigned int k;
+
+	/* first find how many formats to allocate the correct size */
+	dev->num_active_fmt = 0;
+	for (k = 0;
+	     (ret != -EINVAL) && (dev->num_active_fmt < VIP_MAX_ACTIVE_FMT);
+	     k++) {
+		ret = v4l2_subdev_call(subdev, video, enum_mbus_fmt, k, &code);
+		if (ret == 0) {
+			fmt = find_format_by_code(code);
+			if (fmt) {
+				dev->active_fmt[dev->num_active_fmt] = fmt;
+				dev->num_active_fmt++;
+			}
+		}
+	}
+
+	if (dev->num_active_fmt == 0) {
+
+		vip_err(dev, "No suitable format reported by subdev %s\n",
+			subdev->name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int vip_async_bound(struct v4l2_async_notifier *notifier,
 			struct v4l2_subdev *subdev,
 			struct v4l2_async_subdev *asd)
@@ -2168,6 +2311,9 @@ static int vip_async_bound(struct v4l2_async_notifier *notifier,
 	if (idx > dev->config->asd_sizes)
 		return -EINVAL;
 
+	if (get_subdev_active_format(dev, subdev))
+		return 0;
+
 	if (dev->sensor) {
 		if (asd < dev->sensor->asd) {
 			/* Notified of a subdev earlier in the array */
@@ -2185,6 +2331,7 @@ static int vip_async_bound(struct v4l2_async_notifier *notifier,
 	dev->endpoint = &dev->config->endpoints[idx];
 	vip_info(dev, "Using sensor %s for capture\n",
 		 subdev->name);
+
 	return 0;
 }
 
diff --git a/drivers/media/platform/ti-vpe/vip.h b/drivers/media/platform/ti-vpe/vip.h
index d50bcc4..4cf39c3 100644
--- a/drivers/media/platform/ti-vpe/vip.h
+++ b/drivers/media/platform/ti-vpe/vip.h
@@ -47,7 +47,8 @@
 #define VIP_CAP_STREAMS_PER_PORT	16
 #define VIP_VBI_STREAMS_PER_PORT	16
 
-#define VIP_MAX_SUBDEV	5
+#define VIP_MAX_SUBDEV			5
+#define VIP_MAX_ACTIVE_FMT		10
 
 /* buffer for one video frame */
 struct vip_buffer {
@@ -58,6 +59,25 @@ struct vip_buffer {
 };
 
 /*
+ * struct vip_fmt - VIP media bus format information
+ * @name: V4L2 format description
+ * @fourcc: V4L2 pixel format FCC identifier
+ * @code: V4L2 media bus format code
+ * @colorspace: V4L2 colorspace identifier
+ * @coplanar: 1 if unpacked Luma and Chroma, 0 otherwise (packed/interleaved)
+ * @vpdma_fmt: VPDMA data format per plane.
+ */
+struct vip_fmt {
+	char	*name;
+	u32	fourcc;
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+	u8	coplanar;
+	const struct vpdma_data_format *vpdma_fmt[VIP_MAX_PLANES];
+};
+
+
+/*
  * The vip_shared structure contains data that is shared by both
  * the VIP1 and VIP2 slices.
  */
@@ -88,6 +108,8 @@ struct vip_dev {
 	struct vip_config	*config;
 	struct v4l2_subdev	*sensor;
 	struct v4l2_of_endpoint *endpoint;
+	struct vip_fmt		*active_fmt[VIP_MAX_ACTIVE_FMT];
+	int			num_active_fmt;
 	struct v4l2_device	v4l2_dev;
 	struct platform_device *pdev;
 	struct vip_shared	*shared;
@@ -109,16 +131,6 @@ struct vip_dev {
 	struct vb2_alloc_ctx	*alloc_ctx;
 	struct vip_port		*ports[VIP_NUM_PORTS];
 
-	int			mux_gpio;
-	int			mux1_sel0_gpio;
-	int			mux1_sel1_gpio;
-	int			mux2_sel0_gpio;
-	int			mux2_sel1_gpio;
-	int			cam_fpd_mux_s0_gpio;
-	int			vin2_s0_gpio;
-	int			ov_pwdn_gpio;
-
-	struct video_device	*early_vdev;
 	const char		*vip_name;
 };
 
-- 
1.7.5.4

