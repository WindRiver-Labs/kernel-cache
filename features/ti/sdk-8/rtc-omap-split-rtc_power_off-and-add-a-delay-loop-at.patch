From 9f3d286d262161162578ac56917137dc6110e452 Mon Sep 17 00:00:00 2001
From: Tero Kristo <t-kristo@ti.com>
Date: Tue, 26 Aug 2014 11:13:16 +0530
Subject: [PATCH 1079/1587] rtc: omap: split rtc_power_off and add a delay
 loop at end

rtc_power_off is now split into two separate functions, which of one can
be called externally to program the power-off delays (needed for RTC-only
mode.) The actual power-off functionality is also changed to add a delay
loop of 1 second at the end to give the RTC-PMIC functionality time to
kick in.

Signed-off-by: Tero Kristo <t-kristo@ti.com>
[j-keerthy@ti.com] ported to 3.14
Signed-off-by: Keerthy <j-keerthy@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 drivers/rtc/rtc-omap.c |   33 +++++++++++++++++++++++----------
 1 files changed, 23 insertions(+), 10 deletions(-)

diff --git a/drivers/rtc/rtc-omap.c b/drivers/rtc/rtc-omap.c
index c4f5e4f..8b358ad 100644
--- a/drivers/rtc/rtc-omap.c
+++ b/drivers/rtc/rtc-omap.c
@@ -349,30 +349,26 @@ static int omap_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	return 0;
 }
 
+void __iomem *omap_rtc_get_base_addr(void)
+{
+	return rtc_base;
+}
+
 /*
  * rtc_power_off: Set the pmic power off sequence. The RTC generates
  * pmic_pwr_enable control, which can be used to control an external
  * PMIC.
  */
-static void rtc_power_off(void)
+void omap_rtc_power_off_program(void)
 {
 	u32 val;
 	struct rtc_time tm;
 	unsigned long time;
 	int seconds;
 
-	/* Make sure alarm2 interrupt is disabled */
-	val = readl(rtc_base + OMAP_RTC_INTERRUPTS_REG);
-	val &= ~OMAP_RTC_INTERRUPTS_IT_ALARM2;
-	writel(val, rtc_base + OMAP_RTC_INTERRUPTS_REG);
-
 	/* Clear any existing ALARM2 event */
 	writel(OMAP_RTC_STATUS_ALARM2, rtc_base + OMAP_RTC_STATUS_REG);
 
-	/* Set PMIC power enable */
-	val = readl(rtc_base + OMAP_RTC_PMIC_REG);
-	writel(val | OMAP_RTC_PMIC_POWER_EN_EN, rtc_base + OMAP_RTC_PMIC_REG);
-
 	pr_info("System will go to power_off state in approx. %d second\n",
 		SHUTDOWN_TIME_SEC);
 
@@ -420,6 +416,23 @@ again:
 	       rtc_base + OMAP_RTC_INTERRUPTS_REG);
 }
 
+static void rtc_power_off(void)
+{
+	u32 val;
+
+	omap_rtc_power_off_program();
+
+	/* Set PMIC power enable */
+	val = readl(rtc_base + OMAP_RTC_PMIC_REG);
+	writel(val | OMAP_RTC_PMIC_POWER_EN_EN, rtc_base + OMAP_RTC_PMIC_REG);
+
+	/* Wait 1 second for power-off, if we are still alive, bail out */
+	for (val = 0; val < 1000; val++)
+		udelay(1000);
+
+	pr_err("rtc_power_off failed, bailing out.\n");
+}
+
 static struct rtc_class_ops omap_rtc_ops = {
 	.read_time	= omap_rtc_read_time,
 	.set_time	= omap_rtc_set_time,
-- 
1.7.5.4

