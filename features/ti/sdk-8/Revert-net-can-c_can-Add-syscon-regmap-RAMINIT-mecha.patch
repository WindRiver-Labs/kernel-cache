From 172aa07e4f296333e46e9c87162ed9b780f32f68 Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Fri, 14 Nov 2014 19:04:29 +0200
Subject: [PATCH 1372/1587] Revert "net: can: c_can: Add syscon/regmap RAMINIT
 mechanism"

This reverts commit 0acc490b085d799e2888ef7e4879f4c02e6ac9a6.
This makes it easier to apply some upstream commits and
the newer version of this patch.

Signed-off-by: Roger Quadros <rogerq@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from
ti-sdk-am335x-evm-08.00.00.00-Linux-x86-Install.bin]
Signed-off-by: Cao Zou <cao.zou@windriver.com>
---
 .../devicetree/bindings/net/can/c_can.txt          |    7 --
 drivers/net/can/c_can/c_can.h                      |    4 -
 drivers/net/can/c_can/c_can_platform.c             |   69 --------------------
 3 files changed, 0 insertions(+), 80 deletions(-)

diff --git a/Documentation/devicetree/bindings/net/can/c_can.txt b/Documentation/devicetree/bindings/net/can/c_can.txt
index 2f69182..8f1ae81 100644
--- a/Documentation/devicetree/bindings/net/can/c_can.txt
+++ b/Documentation/devicetree/bindings/net/can/c_can.txt
@@ -13,13 +13,6 @@ Optional properties:
 - ti,hwmods		: Must be "d_can<n>" or "c_can<n>", n being the
 			  instance number
 
-- syscon		: Handle to system control region that contains the
-			  RAMINIT register. If specified, the second memory resource
-			  in the reg property must index into the RAMINIT
-			  register within the syscon region
-- raminit-start-bit	: Bit posistion of START bit in the RAMINIT register
-- raminit-done-bit	: Bit position of DONE bit in the RAMINIT register
-
 Note: "ti,hwmods" field is used to fetch the base address and irq
 resources from TI, omap hwmod data base during device registration.
 Future plan is to migrate hwmod data base contents into device tree
diff --git a/drivers/net/can/c_can/c_can.h b/drivers/net/can/c_can/c_can.h
index 896430c..d2e1c21 100644
--- a/drivers/net/can/c_can/c_can.h
+++ b/drivers/net/can/c_can/c_can.h
@@ -170,10 +170,6 @@ struct c_can_priv {
 	u16 irqstatus;
 	enum c_can_dev_id type;
 	u32 __iomem *raminit_ctrlreg;
-	struct regmap *syscon;		/* Alternative raminit reg. access */
-	unsigned int raminit_idx;	/* register index within syscon */
-	u8 raminit_start_bit;	/* START bit position in raminit reg. */
-	u8 raminit_done_bit;	/* DONE bit position in raminit reg. */
 	unsigned int instance;
 	void (*raminit) (const struct c_can_priv *priv, bool enable);
 };
diff --git a/drivers/net/can/c_can/c_can_platform.c b/drivers/net/can/c_can/c_can_platform.c
index a71ae21..88f2267 100644
--- a/drivers/net/can/c_can/c_can_platform.c
+++ b/drivers/net/can/c_can/c_can_platform.c
@@ -32,8 +32,6 @@
 #include <linux/clk.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
-#include <linux/mfd/syscon.h>
-#include <linux/regmap.h>
 #include <linux/pinctrl/consumer.h>
 
 #include <linux/can/dev.h>
@@ -84,22 +82,6 @@ static void c_can_hw_raminit(const struct c_can_priv *priv, bool enable)
 	writel(val, priv->raminit_ctrlreg);
 }
 
-static void c_can_syscon_raminit(const struct c_can_priv *priv, bool enable)
-{
-	u32 mask;
-
-	if (IS_ERR(priv->syscon))
-		return;
-
-	mask = 1 << priv->raminit_start_bit;
-
-	if (enable)
-		regmap_update_bits(priv->syscon, priv->raminit_idx,
-				   mask, mask);
-	else
-		regmap_update_bits(priv->syscon, priv->raminit_idx, mask, 0);
-}
-
 static struct platform_device_id c_can_id_table[] = {
 	[BOSCH_C_CAN_PLATFORM] = {
 		.name = KBUILD_MODNAME,
@@ -135,7 +117,6 @@ static int c_can_plat_probe(struct platform_device *pdev)
 	struct resource *mem, *res;
 	int irq;
 	struct clk *clk;
-	struct device_node *np = pdev->dev.of_node;
 
 	if (pdev->dev.of_node) {
 		match = of_match_device(c_can_of_table, &pdev->dev);
@@ -208,56 +189,6 @@ static int c_can_plat_probe(struct platform_device *pdev)
 		priv->read_reg = c_can_plat_read_reg_aligned_to_16bit;
 		priv->write_reg = c_can_plat_write_reg_aligned_to_16bit;
 
-		/* Try if syscon property exists */
-		if (np)
-			priv->syscon = syscon_regmap_lookup_by_phandle(np,
-								       "syscon");
-		ret = -EINVAL;
-		if (!IS_ERR(priv->syscon)) {
-			u32 val;
-
-			res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-			if (!res) {
-				dev_err(&pdev->dev,
-					"missing memory resource 1\n");
-				goto exit_free_device;
-			}
-			priv->raminit_idx = res->start;
-
-			if (of_property_read_u32(np, "raminit-start-bit",
-						 &val)) {
-				dev_err(&pdev->dev,
-					"missing raminit-start-bit property\n");
-				goto exit_free_device;
-			}
-
-			if (val > 31) {
-				dev_err(&pdev->dev,
-					"invalid raminit-start-bit property\n");
-				goto exit_free_device;
-			}
-
-			priv->raminit_start_bit = val & 0x1f;
-
-			if (of_property_read_u32(np, "raminit-done-bit",
-						 &val)) {
-				dev_err(&pdev->dev,
-					"missing raminit-done-bit property\n");
-				goto exit_free_device;
-			}
-
-			if (val > 31) {
-				dev_err(&pdev->dev,
-					"invalid raminit-done-bit property\n");
-				goto exit_free_device;
-			}
-
-			priv->raminit_done_bit = val & 0x1f;
-			priv->raminit = c_can_syscon_raminit;
-			break;	/* skip the non syscon method */
-		}
-
-		/* non syscon method */
 		if (pdev->dev.of_node)
 			priv->instance = of_alias_get_id(pdev->dev.of_node, "d_can");
 		else
-- 
1.7.5.4

