From b7ece3c5cb9d545e766f2f22749143a9e85f93d5 Mon Sep 17 00:00:00 2001
From: Yang Wei <Wei.Yang@windriver.com>
Date: Fri, 26 Apr 2013 15:08:13 +0800
Subject: [PATCH] sched-dl: cpudl_set do nothing if idx is invalid

Taken from https://github.com/jlelli/sched-deadline.git:sched-dl-V7
commit e198ff46022a806dbaa9208fbdc2247266da1d11

cpudl_set can be called from rq_offline_dl to remove a cpu from
the cpudl heap. If the cpu has no -dl task running there is nothing
to do, just exit.

Signed-off-by: Juri Lelli <juri.lelli@gmail.com>

Introduced this patch to fix the following call trace when doing
stress testing of CPU hotplug via some test cases of LTP.

Unable to handle kernel paging request for data at address 0x7eb5a16c
Faulting instruction address: 0xc008f7dc
Oops: Kernel access of bad area, sig: 11 [#1]
PREEMPT SMP NR_CPUS=2 LTT NESTING LEVEL : 0
P1022 DS
Modules linked in: loop jbd2 ext4
NIP: c008f7dc LR: c008f77c CTR: c008cd04
REGS: ebd43b60 TRAP: 0300   Not tainted  (3.4.34-WR5.0.1.3_standard)
MSR: 00021000 <CE,ME>  CR: 82888682  XER: 20000000
DEAR: 7eb5a16c, ESR: 00800000
TASK = ee7dbc80[3052] 'cpuhotplug02.sh' THREAD: ebd42000 CPU: 0
GPR00: ffffffff ebd43c10 ee7dbc80 00021000 ffffffff 00000000 7eb5a160 fffffffa
GPR08: c0a85ea0 c0a85ea0 00000000 00000001 42882682 100f46b8 ecdbc740 00000001
GPR16: 00000002 00000000 c0a85d60 00000002 c0a5a8b0 00000000 c0a0a230 ee85a000
GPR24: c09f9a80 c1b7da80 ffffffff 00000000 00000000 00021000 00000000 c0a85ea0
NIP [c008f7dc] cpudl_set+0xbc/0x268
LR [c008f77c] cpudl_set+0x5c/0x268
Call Trace:
[ebd43c10] [c008f77c] cpudl_set+0x5c/0x268 (unreliable)
[ebd43c30] [c008cda4] rq_offline_dl+0xa0/0xb0
[ebd43c40] [c0078fc4] rq_attach_root+0x98/0x264
[ebd43c60] [c007addc] cpu_attach_domain+0x158/0x270
[ebd43ca0] [c0081468] build_sched_domains+0x894/0xad0
[ebd43d10] [c0081920] partition_sched_domains+0x1f0/0x2c4
[ebd43d60] [c00c00a8] cpuset_update_active_cpus+0x290/0x2a4
[ebd43de0] [c0081a40] cpuset_cpu_active+0x4c/0x94
[ebd43df0] [c071ae40] notifier_call_chain+0x70/0xc0
[ebd43e20] [c0072a18] __raw_notifier_call_chain+0x1c/0x2c
[ebd43e30] [c004514c] __cpu_notify+0x40/0x64
[ebd43e40] [c072d554] _cpu_up+0xec/0x134
[ebd43e70] [c072d618] cpu_up+0x7c/0x9c
[ebd43e80] [c05f3354] store_online+0x84/0x980
[ebd43ea0] [c03d8b50] dev_attr_store+0x38/0x48
[ebd43eb0] [c01d8314] sysfs_write_file+0x104/0x1a4
[ebd43ee0] [c016e418] vfs_write+0xb4/0x178
[ebd43f00] [c016e7e8] sys_write+0x5c/0x138
[ebd43f40] [c0010d04] ret_from_syscall+0x0/0x3c
    Exception: c01 at 0xff11858
    LR = 0xfeb50fc
[minor patch context modifications to sched-dl-v5]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 kernel/sched/cpudl.c |    9 +++++++++
 1 files changed, 9 insertions(+), 0 deletions(-)

diff --git a/kernel/sched/cpudl.c b/kernel/sched/cpudl.c
index 564017e..668d46e 100644
--- a/kernel/sched/cpudl.c
+++ b/kernel/sched/cpudl.c
@@ -143,6 +143,15 @@ void cpudl_set(struct cpudl *cp, int cpu, u64 dl, int is_valid)
 	old_idx = cp->cpu_to_idx[cpu];
 	if (!is_valid) {
 		/* remove item */
+		if (old_idx == IDX_INVALID) {
+			/* 
+			 * Nothing to remove if old_idx was invalid.
+			 * This could happen if a rq_offline_dl is
+			 * called for a CPU without -dl tasks running.
+			 */
+			goto out;
+		}
+ 		new_cpu = cp->elements[cp->size - 1].cpu;
 		new_cpu = cp->elements[cp->size - 1].cpu;
 		cp->elements[old_idx].dl = cp->elements[cp->size - 1].dl;
 		cp->elements[old_idx].cpu = new_cpu;
-- 
1.7.5.4

