From 2b7199a726256419aa83bbf25d89e06121e6c4d4 Mon Sep 17 00:00:00 2001
From: fupan li <fupan.li@windriver.com>
Date: Mon, 28 Oct 2013 10:21:58 +0800
Subject: [PATCH 01/13] serial/8250: Add support for HSUART controllers on
 Intel Baytrail platform

Intel Baytrail has two HSUART controllers which can be PCI or ACPI enumerated.
This patch is picked from meta-baytrail of YP BSP. It can be accessed from
https://s3-us-west-2.amazonaws.com/isg-downloads/betav2/index.html

Signed-off-by: Chang, Rebecca Swee Fun <rebecca.swee.fun.chang@intel.com>
Signed-off-by: fupan li <fupan.li@windriver.com>
---
 drivers/tty/serial/8250/8250.h     |   5 +
 drivers/tty/serial/8250/8250_pci.c | 191 +++++++++++++++++++++++++++++++++++++
 2 files changed, 196 insertions(+)

diff --git a/drivers/tty/serial/8250/8250.h b/drivers/tty/serial/8250/8250.h
index 1ebf853..16914dd 100644
--- a/drivers/tty/serial/8250/8250.h
+++ b/drivers/tty/serial/8250/8250.h
@@ -88,6 +88,11 @@ struct serial8250_config {
 #define SERIAL8250_SHARE_IRQS 0
 #endif
 
+#define PCI_DEVICE_ID_INTEL_BYT_UART1  0x0f0a
+#define PCI_DEVICE_ID_INTEL_BYT_UART2  0x0f0c
+#define LPSS_UART_BYTE_CNT             0x818
+#define LPSS_UART_OVRFLW_INTR_STAT     0x820
+
 static inline int serial_in(struct uart_8250_port *up, int offset)
 {
 	return up->port.serial_in(&up->port, offset);
diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c
index c52948b..914b18f 100644
--- a/drivers/tty/serial/8250/8250_pci.c
+++ b/drivers/tty/serial/8250/8250_pci.c
@@ -1324,6 +1324,134 @@ ce4100_serial_setup(struct serial_private *priv,
 	return ret;
 }
 
+static bool lpss_dma_filter(struct dma_chan *chan, void *param)
+{
+	return chan->chan_id == *(int*)param;
+}
+
+#define PCI_DEVICE_ID_INTEL_HSW_UART1	0x9c63
+#define PCI_DEVICE_ID_INTEL_HSW_UART2	0x9c64
+
+#define LPSS_PRV_CLK			0x800
+#define LPSS_PRV_CLK_EN			(1 << 0)
+#define LPSS_PRV_CLK_M_VAL_SHIFT	1
+#define LPSS_PRV_CLK_N_VAL_SHIFT	16
+#define LPSS_PRV_CLK_UPDATE		(1 << 31)
+
+#define LPSS_HSUART_GENERAL_REG		0x808
+#define LPSS_GENERAL_DIS_RTS_N_OVERRIDE	(1 << 3)
+
+static void
+lpss_set_termios(struct uart_port *p, struct ktermios *termios,
+		   struct ktermios *old)
+{
+	struct uart_8250_port *up =
+		container_of(p, struct uart_8250_port, port);
+	unsigned int baud = tty_termios_baud_rate(termios);
+	unsigned int m = 6912;
+	unsigned int n = 15625;
+	u32 reg;
+
+	/*
+	 * For baud rates 1000000, 2000000 and 4000000 the dividers must be
+	 * adjusted.
+	 */
+	if (baud == 1000000 || baud == 2000000 || baud == 4000000) {
+		m = 64;
+		n = 100;
+
+		p->uartclk = 64000000;
+	} else if (baud == 3000000){
+                m = 48;
+                n = 100;
+
+                p->uartclk = 48000000;
+	} else {
+		p->uartclk = 44236800;
+	}
+
+	/* Reset the clock */
+	reg = (m << LPSS_PRV_CLK_M_VAL_SHIFT) | (n << LPSS_PRV_CLK_N_VAL_SHIFT);
+	writel(reg, p->membase + LPSS_PRV_CLK);
+	reg |= LPSS_PRV_CLK_EN | LPSS_PRV_CLK_UPDATE;
+	writel(reg, p->membase + LPSS_PRV_CLK);
+
+	/* For BYT, hs-uart is capable of auto flow control */
+	up->capabilities |= UART_CAP_AFE;
+
+	/*
+	 * If auto-handshake mechanism is not enabled,
+	 * disable rts_n override
+	 */
+	reg = readl(p->membase + LPSS_HSUART_GENERAL_REG);
+	reg &= ~LPSS_GENERAL_DIS_RTS_N_OVERRIDE;
+	if (termios->c_cflag & CRTSCTS)
+		reg |= LPSS_GENERAL_DIS_RTS_N_OVERRIDE;
+	writel(reg, p->membase + LPSS_HSUART_GENERAL_REG);
+
+	serial8250_do_set_termios(p, termios, old);
+}
+
+static int
+lpss_serial_setup(struct serial_private *priv,
+		const struct pciserial_board *board,
+		struct uart_8250_port *port, int idx)
+{
+	struct uart_8250_dma *dma;
+	int ret;
+
+	dma = devm_kzalloc(port->port.dev, sizeof(*dma), GFP_KERNEL);
+	if (!dma)
+		return -ENOMEM;
+
+	switch (priv->dev->device) {
+	case PCI_DEVICE_ID_INTEL_BYT_UART1:
+		dma->rx_chan_id = 3;
+		dma->rxconf.slave_id = dma->rx_chan_id;
+		dma->tx_chan_id = 2;
+		dma->txconf.slave_id = dma->tx_chan_id;
+		break;
+	case PCI_DEVICE_ID_INTEL_BYT_UART2:
+		dma->rx_chan_id = 5;
+		dma->rxconf.slave_id = dma->rx_chan_id;
+		dma->tx_chan_id = 4;
+		dma->txconf.slave_id = dma->tx_chan_id;
+		break;
+	case PCI_DEVICE_ID_INTEL_HSW_UART1:
+		dma->rx_chan_id = 5;
+		dma->rxconf.slave_id = 21;
+		dma->tx_chan_id = 4;
+		dma->txconf.slave_id = 20;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dma->rxconf.direction = DMA_DEV_TO_MEM;
+	dma->rxconf.src_addr_width = 1;
+	dma->rxconf.src_maxburst = 16;
+
+	dma->txconf.direction = DMA_MEM_TO_DEV;
+	dma->txconf.dst_addr_width = 1;
+	dma->rxconf.dst_maxburst = 16;
+
+	dma->fn = lpss_dma_filter;
+	dma->rx_param = &dma->rx_chan_id;
+	dma->tx_param = &dma->tx_chan_id;
+
+	ret = pci_default_setup(priv, board, port, idx);
+	port->port.iotype = UPIO_MEM;
+	port->port.type = PORT_16550A;
+	port->port.flags = (port->port.flags | UPF_FIXED_PORT | UPF_FIXED_TYPE);
+	port->port.set_termios = lpss_set_termios;
+	port->port.fifosize = 64;
+	port->tx_loadsz = 64;
+	port->dma = dma;
+	port->port.dev->id = priv->dev->device;
+
+	return ret;
+}
+
 static int
 pci_omegapci_setup(struct serial_private *priv,
 		      const struct pciserial_board *board,
@@ -1661,6 +1789,35 @@ static struct pci_serial_quirk pci_serial_quirks[] __refdata = {
 		.subdevice	= PCI_ANY_ID,
 		.setup		= kt_serial_setup,
 	},
+	{
+		.vendor		= PCI_VENDOR_ID_INTEL,
+		.device		= PCI_DEVICE_ID_INTEL_BYT_UART1,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.setup		= lpss_serial_setup,
+	},
+
+	{
+		.vendor		= PCI_VENDOR_ID_INTEL,
+		.device		= PCI_DEVICE_ID_INTEL_BYT_UART2,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.setup		= lpss_serial_setup,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_INTEL,
+		.device		= PCI_DEVICE_ID_INTEL_HSW_UART1,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.setup		= lpss_serial_setup,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_INTEL,
+		.device		= PCI_DEVICE_ID_INTEL_HSW_UART2,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.setup		= pci_default_setup,
+	},
 	/*
 	 * ITE
 	 */
@@ -2448,6 +2605,8 @@ enum pci_board_num_t {
 	pbn_ADDIDATA_PCIe_4_3906250,
 	pbn_ADDIDATA_PCIe_8_3906250,
 	pbn_ce4100_1_115200,
+	pbn_byt,
+	pbn_hsw,
 	pbn_omegapci,
 	pbn_NETMOS9900_2s_115200,
 	pbn_brcm_trumanage,
@@ -3184,6 +3343,20 @@ static struct pciserial_board pci_boards[] = {
 		.base_baud	= 921600,
 		.reg_shift      = 2,
 	},
+	[pbn_byt] = {
+		.flags		= FL_BASE0,
+		.num_ports	= 1,
+		.base_baud	= 2764800,
+		.uart_offset	= 0x80,
+		.reg_shift      = 2,
+	},
+	[pbn_hsw] = {
+		.flags		= FL_BASE0,
+		.num_ports	= 1,
+		.base_baud	= 6250000,
+		.uart_offset	= 0x80,
+		.reg_shift      = 2,
+	},
 	[pbn_omegapci] = {
 		.flags		= FL_BASE0,
 		.num_ports	= 8,
@@ -4842,6 +5015,24 @@ static struct pci_device_id serial_pci_tbl[] = {
 		PCI_ANY_ID,  PCI_ANY_ID, 0, 0,
 		pbn_ce4100_1_115200 },
 
+	/* Intel BYT */
+	{	PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BYT_UART1,
+		PCI_ANY_ID,  PCI_ANY_ID,
+		PCI_CLASS_COMMUNICATION_SERIAL << 8, 0xff0000,
+		pbn_byt },
+	{	PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BYT_UART2,
+		PCI_ANY_ID,  PCI_ANY_ID,
+		PCI_CLASS_COMMUNICATION_SERIAL << 8, 0xff0000,
+		pbn_byt },
+	/* Intel Haswell-ULT */
+	{	PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_HSW_UART1,
+		PCI_ANY_ID,  PCI_ANY_ID,
+		PCI_CLASS_COMMUNICATION_SERIAL << 8, 0xff0000,
+		pbn_hsw },
+	{	PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_HSW_UART2,
+		PCI_ANY_ID,  PCI_ANY_ID,
+		PCI_CLASS_COMMUNICATION_SERIAL << 8, 0xff0000,
+		pbn_hsw },
 	/*
 	 * Cronyx Omega PCI
 	 */
-- 
1.8.4.93.g57e4c17

