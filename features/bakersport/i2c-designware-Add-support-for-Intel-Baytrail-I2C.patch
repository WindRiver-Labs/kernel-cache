From e97b01bc42943b47e19434188bf6a43987d97a7c Mon Sep 17 00:00:00 2001
From: fupan li <fupan.li@windriver.com>
Date: Mon, 28 Oct 2013 14:44:44 +0800
Subject: [PATCH 05/13] i2c-designware: Add support for Intel Baytrail I2C

Intel Baytrail has 7 I2C controllers which can be PCI
or ACPI enumerated.
This patch is picked from meta-baytrail of YP BSP. It can be accessed from
https://s3-us-west-2.amazonaws.com/isg-downloads/betav2/index.html

Signed-off-by: Chang, Rebecca Swee Fun <rebecca.swee.fun.chang@intel.com>
Signed-off-by: fupan li <fupan.li@windriver.com>
---
 drivers/i2c/busses/i2c-designware-core.h   |   1 +
 drivers/i2c/busses/i2c-designware-pcidrv.c | 149 +++++++++++++++++++++++++++++
 2 files changed, 150 insertions(+)

diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index e8a7565..6fc4da8 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -34,6 +34,7 @@
 #define DW_IC_CON_RESTART_EN		0x20
 #define DW_IC_CON_SLAVE_DISABLE		0x40
 
+#define DW_IC_TAR_10BITADDR_MASTER     0x1000
 
 /**
  * struct dw_i2c_dev - private i2c-designware data
diff --git a/drivers/i2c/busses/i2c-designware-pcidrv.c b/drivers/i2c/busses/i2c-designware-pcidrv.c
index f6ed06c..149431d 100644
--- a/drivers/i2c/busses/i2c-designware-pcidrv.c
+++ b/drivers/i2c/busses/i2c-designware-pcidrv.c
@@ -41,8 +41,14 @@
 #include <linux/pm_runtime.h>
 #include "i2c-designware-core.h"
 
+#include <asm/processor.h>
+
 #define DRIVER_NAME "i2c-designware-pci"
 
+static bool force_std_mode;
+module_param(force_std_mode, bool, 0);
+MODULE_PARM_DESC(force_std_mode, "Force standard mode (100 kHz)");
+
 enum dw_pci_ctl_id_t {
 	moorestown_0,
 	moorestown_1,
@@ -54,6 +60,14 @@ enum dw_pci_ctl_id_t {
 	medfield_3,
 	medfield_4,
 	medfield_5,
+
+	byt_0,
+	byt_1,
+	byt_2,
+	byt_3,
+	byt_4,
+	byt_5,
+	byt_6,
 };
 
 struct dw_pci_controller {
@@ -62,12 +76,22 @@ struct dw_pci_controller {
 	u32 tx_fifo_depth;
 	u32 rx_fifo_depth;
 	u32 clk_khz;
+	u32 ss_hcnt;
+	u32 ss_lcnt;
+	u32 fs_hcnt;
+	u32 fs_lcnt;
+	u32 ss_sda;
+	u32 fs_sda;
 };
 
 #define INTEL_MID_STD_CFG  (DW_IC_CON_MASTER |			\
 				DW_IC_CON_SLAVE_DISABLE |	\
 				DW_IC_CON_RESTART_EN)
 
+#define INTEL_BYT_STD_CFG  (DW_IC_CON_MASTER |         \
+				DW_IC_CON_SLAVE_DISABLE |       \
+				DW_IC_CON_RESTART_EN)
+
 static struct  dw_pci_controller  dw_pci_controllers[] = {
 	[moorestown_0] = {
 		.bus_num     = 0,
@@ -132,6 +156,97 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
 	},
+	[byt_0] = {
+		.bus_num     = -1, //allocate the bus id dynamically
+		.bus_cfg   = INTEL_BYT_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 100000,
+		.ss_hcnt        = 0x200,
+		.ss_lcnt        = 0x200,
+		.fs_hcnt        = 0x55,
+		.fs_lcnt        = 0x99,
+		.ss_sda         = 0x6,
+		.fs_sda         = 0x6,
+	},
+	[byt_1] = {
+		.bus_num     = -1,
+		.bus_cfg   = INTEL_BYT_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 100000,
+		.ss_hcnt        = 0x200,
+		.ss_lcnt        = 0x200,
+		.fs_hcnt        = 0x55,
+		.fs_lcnt        = 0x99,
+		.ss_sda         = 0x6,
+		.fs_sda         = 0x6,
+	},
+	[byt_2] = {
+		.bus_num     = -1,
+		.bus_cfg   = INTEL_BYT_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 100000,
+		.ss_hcnt        = 0x200,
+		.ss_lcnt        = 0x200,
+		.fs_hcnt        = 0x55,
+		.fs_lcnt        = 0x99,
+		.ss_sda         = 0x6,
+		.fs_sda         = 0x6,
+	},
+	[byt_3] = {
+		.bus_num     = -1,
+		.bus_cfg   = INTEL_BYT_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 100000,
+		.ss_hcnt        = 0x200,
+		.ss_lcnt        = 0x200,
+		.fs_hcnt        = 0x55,
+		.fs_lcnt        = 0x99,
+		.ss_sda         = 0x6,
+		.fs_sda         = 0x6,
+	},
+	[byt_4] = {
+		.bus_num     = -1,
+		.bus_cfg   = INTEL_BYT_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 100000,
+		.ss_hcnt        = 0x200,
+		.ss_lcnt        = 0x200,
+		.fs_hcnt        = 0x55,
+		.fs_lcnt        = 0x99,
+		.ss_sda         = 0x6,
+		.fs_sda         = 0x6,
+	},
+	[byt_5] = {
+		.bus_num     = -1,
+		.bus_cfg   = INTEL_BYT_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 100000,
+		.ss_hcnt        = 0x200,
+		.ss_lcnt        = 0x200,
+		.fs_hcnt        = 0x55,
+		.fs_lcnt        = 0x99,
+		.ss_sda         = 0x6,
+		.fs_sda         = 0x6,
+	},
+	[byt_6] = {
+		.bus_num     = -1,
+		.bus_cfg   = INTEL_BYT_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 100000,
+		.ss_hcnt        = 0x200,
+		.ss_lcnt        = 0x200,
+		.fs_hcnt        = 0x55,
+		.fs_lcnt        = 0x99,
+		.ss_sda         = 0x6,
+		.fs_sda         = 0x6,
+	},
 };
 static struct i2c_algorithm i2c_dw_algo = {
 	.master_xfer	= i2c_dw_xfer,
@@ -213,6 +328,7 @@ static int i2c_dw_pci_probe(struct pci_dev *pdev,
 	struct dw_i2c_dev *dev;
 	struct i2c_adapter *adap;
 	int r;
+	u32 mode;
 	struct  dw_pci_controller *controller;
 
 	if (id->driver_data >= ARRAY_SIZE(dw_pci_controllers)) {
@@ -249,11 +365,36 @@ static int i2c_dw_pci_probe(struct pci_dev *pdev,
 	dev->dev = &pdev->dev;
 	dev->functionality =
 		I2C_FUNC_I2C |
+		I2C_FUNC_10BIT_ADDR |
 		I2C_FUNC_SMBUS_BYTE |
 		I2C_FUNC_SMBUS_BYTE_DATA |
 		I2C_FUNC_SMBUS_WORD_DATA |
 		I2C_FUNC_SMBUS_I2C_BLOCK;
+
+	/*
+	 * BYT A0: Override base clock, hcnt and lcnt default settings
+	 */
+	if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL && boot_cpu_data.x86 == 0x6 &&
+		boot_cpu_data.x86_model == 0x37 && boot_cpu_data.x86_mask < 2) {
+		controller->clk_khz = 133000;
+		controller->ss_hcnt = 0x28f;
+		controller->ss_lcnt = 0x2ba;
+		controller->fs_hcnt = 0x71;
+		controller->fs_lcnt = 0xce;
+	}
+
+	dev->ss_hcnt = controller->ss_hcnt;
+	dev->ss_lcnt = controller->ss_lcnt;
+	dev->fs_hcnt = controller->fs_hcnt;
+	dev->fs_lcnt = controller->fs_lcnt;
+	mode = controller->bus_cfg & (DW_IC_CON_SPEED_STD | DW_IC_CON_SPEED_FAST);
+	if (force_std_mode && !(mode & DW_IC_CON_SPEED_STD)){
+		controller->bus_cfg &= ~mode;
+		controller->bus_cfg |= DW_IC_CON_SPEED_STD;
+	}
+
 	dev->master_cfg =  controller->bus_cfg;
+	dev->sda_hold_time = (dev->master_cfg & DW_IC_CON_SPEED_FAST) ? controller->fs_sda : controller->ss_sda;
 
 	pci_set_drvdata(pdev, dev);
 
@@ -321,6 +462,14 @@ static DEFINE_PCI_DEVICE_TABLE(i2_designware_pci_ids) = {
 	{ PCI_VDEVICE(INTEL, 0x082C), medfield_0 },
 	{ PCI_VDEVICE(INTEL, 0x082D), medfield_1 },
 	{ PCI_VDEVICE(INTEL, 0x082E), medfield_2 },
+	/* BYT */
+	{ PCI_VDEVICE(INTEL, 0x0F41), byt_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F42), byt_1 },
+	{ PCI_VDEVICE(INTEL, 0x0F43), byt_2 },
+	{ PCI_VDEVICE(INTEL, 0x0F44), byt_3 },
+	{ PCI_VDEVICE(INTEL, 0x0F45), byt_4 },
+	{ PCI_VDEVICE(INTEL, 0x0F46), byt_5 },
+	{ PCI_VDEVICE(INTEL, 0x0F47), byt_6 },
 	{ 0,}
 };
 MODULE_DEVICE_TABLE(pci, i2_designware_pci_ids);
-- 
1.8.4.93.g57e4c17

