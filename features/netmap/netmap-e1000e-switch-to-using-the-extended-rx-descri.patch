From 8c5957bf319feebe13ae08f3453b8b01c184f521 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Fri, 1 Nov 2013 10:41:59 -0400
Subject: [PATCH] netmap: e1000e: switch to using the extended rx descriptors

commit 5f450212f281272f4ef81d96b79bf68cebdbc210 [e1000e: convert
driver to use extended descriptors] switched e1000e to using extended
rx descriptors so we need to do the same thing for e1000e netmap
support. Without this change you can poll netmap all you want, you
will never be notified of received packets. This matches closely with
netmap support for igb which already uses extended descriptors.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>

diff --git a/drivers/staging/netmap/if_e1000e_netmap.h b/drivers/staging/netmap/if_e1000e_netmap.h
index 232d39b..a7cdf73 100644
--- a/drivers/staging/netmap/if_e1000e_netmap.h
+++ b/drivers/staging/netmap/if_e1000e_netmap.h
@@ -42,8 +42,6 @@
 #include "netmap_kern.h"
 #define SOFTC_T	e1000_adapter
 
-#define E1000_RX_DESC(R, i)		E1000_GET_DESC(R, i, e1000_rx_desc)
-
 static bool e1000e_has_link(struct e1000_adapter *adapter);
 
 /*
@@ -221,12 +219,15 @@ e1000_netmap_rxsync(struct ifnet *ifp, u_int ring_nr, int do_lock)
 	j = netmap_idx_n2k(kring, l);
 	if (netmap_no_pendintr || force_update) {
 		for (n = 0; ; n++) {
-			struct e1000_rx_desc *curr = E1000_RX_DESC(*rxr, l);
-			uint32_t staterr = le32toh(curr->status);
+			union e1000_rx_desc_extended *curr =
+				E1000_RX_DESC_EXT(*rxr, l);
+			uint32_t staterr =
+				le32_to_cpu(curr->wb.upper.status_error);
 
 			if ((staterr & E1000_RXD_STAT_DD) == 0)
 				break;
-			ring->slot[j].len = le16toh(curr->length) - strip_crc;
+			ring->slot[j].len =
+				le16_to_cpu(curr->wb.upper.length) - strip_crc;
 			j = (j == lim) ? 0 : j + 1;
 			l = (l == lim) ? 0 : l + 1;
 		}
@@ -250,7 +251,8 @@ e1000_netmap_rxsync(struct ifnet *ifp, u_int ring_nr, int do_lock)
 		l = netmap_idx_k2n(kring, j); /* NIC ring index */
 		for (n = 0; j != k; n++) {
 			struct netmap_slot *slot = &ring->slot[j];
-			struct e1000_rx_desc *curr = E1000_RX_DESC(*rxr, j);
+			union e1000_rx_desc_extended *curr =
+				E1000_RX_DESC_EXT(*rxr, j);
 			uint64_t paddr;
 			void *addr = PNMB(slot, &paddr);
 
@@ -261,10 +263,10 @@ e1000_netmap_rxsync(struct ifnet *ifp, u_int ring_nr, int do_lock)
 			}
 			if (slot->flags & NS_BUF_CHANGED) {
 				// netmap_reload_map(pdev, DMA_TO_DEVICE, old_paddr, addr)
-				curr->buffer_addr = htole64(paddr);
+				curr->read.buffer_addr = cpu_to_le64(paddr);
 				slot->flags &= ~NS_BUF_CHANGED;
 			}
-			curr->status = 0;
+			curr->wb.upper.status_error &= cpu_to_le32(~0xFF);
 			j = (j == lim) ? 0 : j + 1;
 			l = (l == lim) ? 0 : l + 1;
 		}
@@ -322,7 +324,8 @@ static int e1000e_netmap_init_buffers(struct SOFTC_T *adapter)
 			D("rx buf %d was set", i);
 		bi->skb = NULL; // XXX leak if set
 		// netmap_load_map(...)
-		E1000_RX_DESC(*rxr, i)->buffer_addr = htole64(paddr);
+		E1000_RX_DESC_EXT(*rxr, i)->read.buffer_addr =
+			cpu_to_le64(paddr);
 	}
 	rxr->next_to_use = 0;
 	/* preserve buffers already made available to clients */
-- 
1.8.4.1

