From d8a8f079a67bfb0f863c7ec5bfb14ccbd239f9e0 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Fri, 1 Nov 2013 10:42:00 -0400
Subject: [PATCH] netmap: e1000e: always set read buffer address

There is a bug in the upstream netmap source for e1000e which only
sets the read buffer address if the netmap buffer has changed. If you
run netmap pktgen's RX/TX test you will notice that considerably more
packets are being received then sent. This seems to indicate that junk
is being read. As well when TX side of the pktgen test is terminated
the RX side continues reading as if more packets are arriving, which
we know is not the case. Looking at the igb netmap source you can see
that the buffer address is being set outside of the check for
NS_BUF_CHANGED so here we are mimicking that change which corrects the
issues described above.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>

diff --git a/drivers/staging/netmap/if_e1000e_netmap.h b/drivers/staging/netmap/if_e1000e_netmap.h
index a7cdf73..396262f 100644
--- a/drivers/staging/netmap/if_e1000e_netmap.h
+++ b/drivers/staging/netmap/if_e1000e_netmap.h
@@ -263,9 +263,9 @@ e1000_netmap_rxsync(struct ifnet *ifp, u_int ring_nr, int do_lock)
 			}
 			if (slot->flags & NS_BUF_CHANGED) {
 				// netmap_reload_map(pdev, DMA_TO_DEVICE, old_paddr, addr)
-				curr->read.buffer_addr = cpu_to_le64(paddr);
 				slot->flags &= ~NS_BUF_CHANGED;
 			}
+			curr->read.buffer_addr = cpu_to_le64(paddr);
 			curr->wb.upper.status_error &= cpu_to_le32(~0xFF);
 			j = (j == lim) ? 0 : j + 1;
 			l = (l == lim) ? 0 : l + 1;
-- 
1.8.4.1

