From 996cffa5080f4988bbfcc35e3c762fe3d32fb7ec Mon Sep 17 00:00:00 2001
From: Vu Tran <vu.tran@windriver.com>
Date: Fri, 11 Oct 2013 13:53:04 -0400
Subject: [PATCH] netmap: to wait until the link is up

The time for the link to be up varies between NIC types. So when netmap
app enables netmap (through ioctl), it needs to wait for the link to
be up.  If netmap app starts traffic before the link is up then it will
cause the driver to keep resetting the link.  So it's good to wait until
the link is up.

Signed-off-by: Vu Tran <vu.tran@windriver.com>
---
 drivers/staging/netmap/if_e1000_netmap.h  |  5 +++++
 drivers/staging/netmap/if_e1000e_netmap.h |  7 +++++++
 drivers/staging/netmap/if_igb_netmap.h    |  5 +++++
 drivers/staging/netmap/netmap_kern.h      | 14 ++++++++++++++
 4 files changed, 31 insertions(+)

diff --git a/drivers/staging/netmap/if_e1000_netmap.h b/drivers/staging/netmap/if_e1000_netmap.h
index 2baac46..d7506dc 100644
--- a/drivers/staging/netmap/if_e1000_netmap.h
+++ b/drivers/staging/netmap/if_e1000_netmap.h
@@ -76,6 +76,11 @@ e1000_netmap_reg(struct ifnet *ifp, int onoff)
 	e1000_up(adapter);
 	//rtnl_unlock(); // XXX do we need it ?
 	clear_bit(__E1000_RESETTING, &adapter->flags);
+
+	/* Look like the link takes a bit of time to become ready.
+	   So make sure the link is up within a period of time */
+	NETMAP_WAIT_FOR_LINK((onoff && !e1000_has_link(adapter)), ifp->if_xname);
+
 	return (error);
 }
 
diff --git a/drivers/staging/netmap/if_e1000e_netmap.h b/drivers/staging/netmap/if_e1000e_netmap.h
index ff26c70..232d39b 100644
--- a/drivers/staging/netmap/if_e1000e_netmap.h
+++ b/drivers/staging/netmap/if_e1000e_netmap.h
@@ -44,6 +44,8 @@
 
 #define E1000_RX_DESC(R, i)		E1000_GET_DESC(R, i, e1000_rx_desc)
 
+static bool e1000e_has_link(struct e1000_adapter *adapter);
+
 /*
  * Register/unregister, similar to e1000_reinit_safe()
  */
@@ -82,6 +84,11 @@ e1000_netmap_reg(struct ifnet *ifp, int onoff)
 	e1000e_up(adapter);
 	//rtnl_unlock(); // XXX do we need it ?
 	clear_bit(__E1000_RESETTING, &adapter->state);
+
+	/* Look like the link takes a bit of time to become ready.
+	   So make sure the link is up within a period of time */
+	NETMAP_WAIT_FOR_LINK((onoff && !e1000e_has_link(adapter)), ifp->if_xname);
+
 	return (error);
 }
 
diff --git a/drivers/staging/netmap/if_igb_netmap.h b/drivers/staging/netmap/if_igb_netmap.h
index 8326281..fce0ac0 100644
--- a/drivers/staging/netmap/if_igb_netmap.h
+++ b/drivers/staging/netmap/if_igb_netmap.h
@@ -91,6 +91,11 @@ igb_netmap_reg(struct ifnet *ifp, int onoff)
 	igb_up(adapter);
 	//rtnl_unlock(); // XXX do we need it ?
 	clear_bit(__IGB_RESETTING, &adapter->state);
+
+	/* Look like the link takes a bit of time to become ready.
+	   So make sure the link is up within a period of time */
+	NETMAP_WAIT_FOR_LINK((onoff && !igb_has_link(adapter)), ifp->if_xname);
+
 	return (error);
 }
 
diff --git a/drivers/staging/netmap/netmap_kern.h b/drivers/staging/netmap/netmap_kern.h
index ea92f37..b521261 100644
--- a/drivers/staging/netmap/netmap_kern.h
+++ b/drivers/staging/netmap/netmap_kern.h
@@ -447,6 +447,20 @@ PNMB(struct netmap_slot *slot, uint64_t *pp)
 	return ret;
 }
 
+#define NETMAP_WAIT_FOR_LINK(is_link_up, ifname) \
+	{ \
+		int time_to_exit = 0; \
+		while ((is_link_up)) { \
+			/* wait for 30 seconds = 1500 x 20ms */ \
+			msleep(20); \
+			if (++time_to_exit >= 1500) { \
+				D("Interface %s is not up for a while now... please check the cable!", \
+						((ifname) == NULL) ? "<unknown>" : (ifname)); \
+				return EINVAL; \
+			} \
+		} \
+	}
+
 /* default functions to handle rx/tx interrupts */
 int netmap_rx_irq(struct ifnet *, int, int *);
 #define netmap_tx_irq(_n, _q) netmap_rx_irq(_n, _q, NULL)
-- 
1.8.4

