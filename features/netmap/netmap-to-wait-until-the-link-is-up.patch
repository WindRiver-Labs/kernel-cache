From 7578d679fccfc4d219e6336f267bc3b4d5f057ae Mon Sep 17 00:00:00 2001
From: Vu Tran <vu.tran@windriver.com>
Date: Fri, 11 Oct 2013 13:53:04 -0400
Subject: [PATCH] netmap: to wait until the link is up

The time for the link to be up varies between NIC types. So when netmap
app enables netmap (through ioctl), it needs to wait for the link to
be up.  If netmap app starts traffic before the link is up then it will
cause the driver to keep resetting the link.  So it's good to wait until
the link is up.

Signed-off-by: Vu Tran <vu.tran@windriver.com>
Signed-off-by: Rahat Mahbub <rahat.mahbub@windriver.com>
[PG: 3.10 ---> 3.14 carry forward.]
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/staging/netmap/LINUX/if_e1000_netmap.h b/drivers/staging/netmap/LINUX/if_e1000_netmap.h
index d6ae336fae48..c25d7ad79e0f 100644
--- a/drivers/staging/netmap/LINUX/if_e1000_netmap.h
+++ b/drivers/staging/netmap/LINUX/if_e1000_netmap.h
@@ -70,6 +70,11 @@ e1000_netmap_reg(struct netmap_adapter *na, int onoff)
 
 	rtnl_unlock();
 	clear_bit(__E1000_RESETTING, &adapter->flags);
+
+	/* Look like the link takes a bit of time to become ready.
+	   So make sure the link is up within a period of time */
+	NETMAP_WAIT_FOR_LINK((onoff && !e1000_has_link(adapter)), ifp->if_xname);
+
 	return (0);
 }
 
diff --git a/drivers/staging/netmap/LINUX/if_e1000e_netmap.h b/drivers/staging/netmap/LINUX/if_e1000e_netmap.h
index 6fd4b5a17a98..954f977de3d9 100644
--- a/drivers/staging/netmap/LINUX/if_e1000e_netmap.h
+++ b/drivers/staging/netmap/LINUX/if_e1000e_netmap.h
@@ -78,7 +78,7 @@ char netmap_e1000e_driver_name[] = "e1000e" NETMAP_LINUX_DRIVER_SUFFIX;
 #define nm_e1000e_down(_a)	e1000e_down(_a)
 #endif
 
-
+static bool e1000e_has_link(struct e1000_adapter *adapter);
 /*
  * Register/unregister. We are already under netmap lock.
  */
@@ -111,6 +111,11 @@ e1000_netmap_reg(struct netmap_adapter *na, int onoff)
 	rtnl_unlock();
 
 	clear_bit(__E1000_RESETTING, &adapter->state);
+
+	/* Look like the link takes a bit of time to become ready.
+	   So make sure the link is up within a period of time */
+	NETMAP_WAIT_FOR_LINK((onoff && !e1000e_has_link(adapter)), ifp->if_xname);
+
 	return (0);
 }
 
diff --git a/drivers/staging/netmap/LINUX/if_igb_netmap.h b/drivers/staging/netmap/LINUX/if_igb_netmap.h
index c1b08a3af1f6..bfb1eaf2455d 100644
--- a/drivers/staging/netmap/LINUX/if_igb_netmap.h
+++ b/drivers/staging/netmap/LINUX/if_igb_netmap.h
@@ -90,6 +90,11 @@ igb_netmap_reg(struct netmap_adapter *na, int onoff)
 	rtnl_unlock();
 
 	clear_bit(__IGB_RESETTING, &adapter->state);
+
+	/* Look like the link takes a bit of time to become ready.
+	   So make sure the link is up within a period of time */
+	NETMAP_WAIT_FOR_LINK((onoff && !igb_has_link(adapter)), ifp->if_xname);
+
 	return (0);
 }
 
diff --git a/drivers/staging/netmap/sys/dev/netmap/netmap_kern.h b/drivers/staging/netmap/sys/dev/netmap/netmap_kern.h
index 38352b6b9c9a..24352a507fef 100644
--- a/drivers/staging/netmap/sys/dev/netmap/netmap_kern.h
+++ b/drivers/staging/netmap/sys/dev/netmap/netmap_kern.h
@@ -891,6 +891,20 @@ struct netmap_slot *netmap_reset(struct netmap_adapter *na,
 	enum txrx tx, u_int n, u_int new_cur);
 int netmap_ring_reinit(struct netmap_kring *);
 
+#define NETMAP_WAIT_FOR_LINK(is_link_up, ifname) \
+	{ \
+		int time_to_exit = 0; \
+		while ((is_link_up)) { \
+			/* wait for 30 seconds = 1500 x 20ms */ \
+			msleep(20); \
+			if (++time_to_exit >= 1500) { \
+				D("Interface %s is not up for a while now... please check the cable!", \
+						((ifname) == NULL) ? "<unknown>" : (ifname)); \
+				return EINVAL; \
+			} \
+		} \
+	}
+
 /* default functions to handle rx/tx interrupts */
 int netmap_rx_irq(struct ifnet *, u_int, u_int *);
 #define netmap_tx_irq(_n, _q) netmap_rx_irq(_n, _q, NULL)
-- 
2.1.2

