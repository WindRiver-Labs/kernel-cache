From 8d58b6869613c45985b1ea4bebf89dce854f1589 Mon Sep 17 00:00:00 2001
From: Vu Tran <vu.tran@windriver.com>
Date: Fri, 11 Oct 2013 13:53:04 -0400
Subject: [PATCH] netmap: to wait until the link is up

The time for the link to be up varies between NIC types. So when netmap
app enables netmap (through ioctl), it needs to wait for the link to
be up.  If netmap app starts traffic before the link is up then it will
cause the driver to keep resetting the link.  So it's good to wait until
the link is up.

Signed-off-by: Vu Tran <vu.tran@windriver.com>
Signed-off-by: Rahat Mahbub <rahat.mahbub@windriver.com>

diff --git a/drivers/staging/netmap/LINUX/if_e1000_netmap.h b/drivers/staging/netmap/LINUX/if_e1000_netmap.h
index 43d073c..c31e0bd 100644
--- a/drivers/staging/netmap/LINUX/if_e1000_netmap.h
+++ b/drivers/staging/netmap/LINUX/if_e1000_netmap.h
@@ -68,6 +68,11 @@ e1000_netmap_reg(struct netmap_adapter *na, int onoff)
 
 	rtnl_unlock();
 	clear_bit(__E1000_RESETTING, &adapter->flags);
+
+	/* Look like the link takes a bit of time to become ready.
+	   So make sure the link is up within a period of time */
+	NETMAP_WAIT_FOR_LINK((onoff && !e1000_has_link(adapter)), ifp->if_xname);
+
 	return (0);
 }
 
diff --git a/drivers/staging/netmap/LINUX/if_e1000e_netmap.h b/drivers/staging/netmap/LINUX/if_e1000e_netmap.h
index 85b2bda..26e1181 100644
--- a/drivers/staging/netmap/LINUX/if_e1000e_netmap.h
+++ b/drivers/staging/netmap/LINUX/if_e1000e_netmap.h
@@ -69,7 +69,7 @@
 #define	NM_RD_TX_HEAD()		readl(adapter->hw.hw_addr + txr->head)
 #endif /* < 3.4.0 */
 
-
+static bool e1000e_has_link(struct e1000_adapter *adapter);
 /*
  * Register/unregister. We are already under netmap lock.
  */
@@ -102,6 +102,11 @@ e1000_netmap_reg(struct netmap_adapter *na, int onoff)
 	rtnl_unlock();
 
 	clear_bit(__E1000_RESETTING, &adapter->state);
+
+	/* Look like the link takes a bit of time to become ready.
+	   So make sure the link is up within a period of time */
+	NETMAP_WAIT_FOR_LINK((onoff && !e1000e_has_link(adapter)), ifp->if_xname);
+
 	return (0);
 }
 
diff --git a/drivers/staging/netmap/LINUX/if_igb_netmap.h b/drivers/staging/netmap/LINUX/if_igb_netmap.h
index dc3e326..25b866c 100644
--- a/drivers/staging/netmap/LINUX/if_igb_netmap.h
+++ b/drivers/staging/netmap/LINUX/if_igb_netmap.h
@@ -88,6 +88,11 @@ igb_netmap_reg(struct netmap_adapter *na, int onoff)
 	rtnl_unlock();
 
 	clear_bit(__IGB_RESETTING, &adapter->state);
+	
+	/* Look like the link takes a bit of time to become ready.
+	   So make sure the link is up within a period of time */
+	NETMAP_WAIT_FOR_LINK((onoff && !igb_has_link(adapter)), ifp->if_xname);
+
 	return (0);
 }
 
diff --git a/drivers/staging/netmap/sys/dev/netmap/netmap_kern.h b/drivers/staging/netmap/sys/dev/netmap/netmap_kern.h
index d22fcfc..c7482cb 100644
--- a/drivers/staging/netmap/sys/dev/netmap/netmap_kern.h
+++ b/drivers/staging/netmap/sys/dev/netmap/netmap_kern.h
@@ -762,6 +762,20 @@ struct netmap_slot *netmap_reset(struct netmap_adapter *na,
 	enum txrx tx, u_int n, u_int new_cur);
 int netmap_ring_reinit(struct netmap_kring *);
 
+#define NETMAP_WAIT_FOR_LINK(is_link_up, ifname) \
+	{ \
+		int time_to_exit = 0; \
+		while ((is_link_up)) { \
+			/* wait for 30 seconds = 1500 x 20ms */ \
+			msleep(20); \
+			if (++time_to_exit >= 1500) { \
+				D("Interface %s is not up for a while now... please check the cable!", \
+						((ifname) == NULL) ? "<unknown>" : (ifname)); \
+				return EINVAL; \
+			} \
+		} \
+	}
+
 /* default functions to handle rx/tx interrupts */
 int netmap_rx_irq(struct ifnet *, u_int, u_int *);
 #define netmap_tx_irq(_n, _q) netmap_rx_irq(_n, _q, NULL)
-- 
1.8.2.3

