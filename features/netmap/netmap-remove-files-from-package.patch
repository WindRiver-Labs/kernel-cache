From 53d895650c93db87712c23bf505a291014baf1eb Mon Sep 17 00:00:00 2001
From: Rahat Mahbub <rahat.mahbub@windriver.com>
Date: Mon, 14 Apr 2014 17:42:02 -0400
Subject: [PATCH] netmap: remove files from package

We only need the files required to build netmap and the following drivers:

   ixgbe    (Intel 10GigE)
   igb      (Intel 1GigE)
   e1000e   (Intel 1GigE)
   e1000    (Intel 1GigE)

Any other files related to FreeBSD support or other drivers are removed
by this patch.

Signed-off-by: Rahat Mahbub <rahat.mahbub@windriver.com>
[PG: update removal to match prev. baseline commit]
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/staging/netmap/LINUX/Makefile b/drivers/staging/netmap/LINUX/Makefile
deleted file mode 100644
index e7b49c842e5e..000000000000
--- a/drivers/staging/netmap/LINUX/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-all: netmap drivers
-
-netmap drivers: netmap.mak
-
--include netmap.mak
-
-COMPAT_ARGS=$(if $(KSRC),--kernel-dir=$(KSRC),)\
-	    $(if $(SRC),--kernel-sources=$(SRC),)\
-	    $(if $(NODRIVERS),--no-drivers)
-
-netmap.mak:
-	@echo 'The new way to build netmap is to run the provided configure script first,'
-	@echo 'followed by make.'
-	@echo 'We run configure for you now, with compatible arguments, and restart make.'
-	@echo 'Please run configure again if this is not what you want.'
-	./configure $(COMPAT_ARGS)
diff --git a/drivers/staging/netmap/LINUX/archlinux/PKGBUILD b/drivers/staging/netmap/LINUX/archlinux/PKGBUILD
deleted file mode 100644
index 11b51bf3a0a1..000000000000
--- a/drivers/staging/netmap/LINUX/archlinux/PKGBUILD
+++ /dev/null
@@ -1,113 +0,0 @@
-# See http://wiki.archlinux.org/index.php/VCS_PKGBUILD_Guidelines
-# for more information on packaging from GIT sources.
-
-# Maintainer: Vincenzo Maffione <v.maffione@gmail.com>
-pkgname=netmap
-pkgver=3.16
-pkgrel=1
-pkgdesc="Netmap is a framework for high speed network packet I/O."
-arch=('any')
-url="http://info.iet.unipi.it/~luigi/netmap"
-license=('BSD')
-groups=()
-depends=('linux' 'glibc')
-makedepends=('git' 'sed' 'gzip' 'linux-headers' 'abs' 'pacman')
-provides=()
-conflicts=()
-replaces=()
-backup=()
-options=()
-install="netmap.install"
-source=("netmap.install")
-noextract=()
-md5sums=("047aa5adec4c52ddbf86d12dbf300f71")
-
-_gitroot="https://v.maffione@code.google.com/p/netmap/"
-_gitname="netmap"
-
-build() {
-    # Download the latest netmap code from the public repository
-    cd "$srcdir"
-    msg "Connecting to GIT server...."
-    if [[ -d "$_gitname" ]]; then
-        cd "$_gitname" && git pull origin
-        msg "The local files are updated."
-    else
-        git clone "$_gitroot" "$_gitname"
-        cd "$srcdir/$_gitname"
-        git branch next origin/next
-        git checkout next
-    fi
-    msg "GIT checkout done or server timeout"
-
-    # Download kernel sources using ABS, checking that the version is the
-    # same as the running kernel
-    msg "Downloading kernel sources..."
-    mkdir -p $srcdir/abs
-    cd $srcdir/abs
-    ABSROOT=. abs core/linux
-    cd $srcdir/abs/core/linux
-    grep "pkgver[ ]*=" PKGBUILD > .ksver
-    KSVER=$(sed 's|pkgver[ ]*=[ ]*||g' .ksver)
-    rm .ksver
-    RKVER=$(uname -r | sed 's|-.*||g')
-    if [ "$KSVER" != "$RKVER" ]; then
-        msg "Kernel sources version ($KSVER) differs from running kernel version ($RKVER): Cannot continue"
-        return 1
-    fi
-    KMAJVER=$(echo "$KSVER" | sed 's|\.[0-9]\+$||g')
-    makepkg --nobuild
-    msg "Kernel sources are ready"
-
-    # Build the netmap kernel module and all modified drivers, using the
-    # kernel sources downloaded in the previous steps to copy the NIC
-    # drivers. Note however that the kernel modules are built against the
-    # running kernel, and not against the downloaded sources.
-    msg "Starting to build netmap"
-    cd "$srcdir/$_gitname/LINUX"
-    unset SRC
-    unset KSRC
-    unset NODRIVERS
-    make SRC=$srcdir/abs/core/linux/src/linux-$KMAJVER || return 1
-    # Build pkt-gen and vale-ctl
-    cd "$srcdir/$_gitname/examples"
-    make clean  # amend for existing .o
-    make pkt-gen vale-ctl || return 1
-    msg "Build complete"
-}
-
-package() {
-    # Compute the version numbers of the running kernel
-    KVER1=$(uname -r)
-    KVER2=$(uname -r | sed 's/\.[0-9]\+-[0-9]\+//')
-
-    # Install the netmap module into the extramodules-VERSION directory
-    mkdir -p "$pkgdir/lib/modules/extramodules-${KVER2}"
-    cp "$srcdir/$_gitname/LINUX/netmap_lin.ko" "$pkgdir/lib/modules/extramodules-${KVER2}"
-
-    # Install pkt-gen and valectl into /usr/bin
-    mkdir -p "$pkgdir/usr/bin"
-    cp "$srcdir/$_gitname/examples/pkt-gen" "$pkgdir/usr/bin"
-    cp "$srcdir/$_gitname/examples/vale-ctl" "$pkgdir/usr/bin"
-
-    # Install the netmap public headers
-    mkdir -p "$pkgdir/usr/include/net"
-    cp "$srcdir/$_gitname/sys/net/netmap.h" "$srcdir/$_gitname/sys/net/netmap_user.h" "$pkgdir/usr/include/net"
-
-    # Install the netmap man page
-    mkdir -p "$pkgdir/usr/share/man/man4"
-    cp "$srcdir/$_gitname/share/man/man4/netmap.4" "$pkgdir/usr/share/man/man4"
-    gzip "$pkgdir/usr/share/man/man4/netmap.4"
-
-    #Find and install the modified NIC drivers
-    cd "$srcdir/$_gitname/LINUX"
-    DRIVERS=$(find . -name "*.ko" -and ! -name "netmap_lin.ko")
-    if [ -n "$DRIVERS" ]; then
-        mkdir -p "$pkgdir/lib/modules/extramodules-${KVER2}/netmap-drivers"
-        cp --parent $DRIVERS "$pkgdir/lib/modules/extramodules-${KVER2}/netmap-drivers"
-        cd "$pkgdir/lib/modules/extramodules-${KVER2}/netmap-drivers"
-        find . -name "*.ko" -exec sh -c "mv {} \$(echo {} | sed 's|\.ko|_netmap\.ko|g')" \;
-    fi
-}
-
-# vim:set ts=2 sw=2 et:
diff --git a/drivers/staging/netmap/LINUX/archlinux/netmap.install b/drivers/staging/netmap/LINUX/archlinux/netmap.install
deleted file mode 100644
index d8951c29f863..000000000000
--- a/drivers/staging/netmap/LINUX/archlinux/netmap.install
+++ /dev/null
@@ -1,20 +0,0 @@
-post_common() {
-    depmod -a
-}
-
-## arg 1:  the new package version
-post_install() {
-    post_common
-}
-
-## arg 1:  the new package version
-## arg 2:  the old package version
-post_upgrade() {
-    post_common
-}
-
-## arg 1:  the old package version
-post_remove() {
-    post_common
-}
-
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--e1000--20620--99999 b/drivers/staging/netmap/LINUX/final-patches/diff--e1000--20620--99999
deleted file mode 100644
index b719da757e6e..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--e1000--20620--99999
+++ /dev/null
@@ -1,104 +0,0 @@
-diff --git a/e1000/e1000_main.c b/e1000/e1000_main.c
-index bcd192c..5de7009 100644
---- a/e1000/e1000_main.c
-+++ b/e1000/e1000_main.c
-@@ -213,6 +213,10 @@ static int debug = NETIF_MSG_DRV | NETIF_MSG_PROBE;
- module_param(debug, int, 0);
- MODULE_PARM_DESC(debug, "Debug level (0=none,...,16=all)");
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_e1000_netmap.h>
-+#endif
-+
- /**
-  * e1000_init_module - Driver Registration Routine
-  *
-@@ -375,6 +379,10 @@ static void e1000_configure(struct e1000_adapter *adapter)
- 	e1000_configure_tx(adapter);
- 	e1000_setup_rctl(adapter);
- 	e1000_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	if (e1000_netmap_init_buffers(adapter))
-+		return;
-+#endif /* DEV_NETMAP */
- 	/* call E1000_DESC_UNUSED which always leaves
- 	 * at least 1 descriptor unused to make sure
- 	 * next_to_use != next_to_clean */
-@@ -402,6 +410,10 @@ int e1000_up(struct e1000_adapter *adapter)
- 
- 	netif_wake_queue(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* fire a link change interrupt to start the watchdog */
- 	ew32(ICS, E1000_ICS_LSC);
- 	return 0;
-@@ -485,6 +497,10 @@ void e1000_down(struct e1000_adapter *adapter)
- 	ew32(RCTL, rctl & ~E1000_RCTL_EN);
- 	/* flush and sleep below */
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	netif_tx_disable(netdev);
- 
- 	/* disable transmits in the hardware */
-@@ -1035,6 +1051,10 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
- 	adapter->wol = adapter->eeprom_wol;
- 	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
- 
-+#ifdef DEV_NETMAP
-+	e1000_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	/* print bus type/speed/width info */
- 	DPRINTK(PROBE, INFO, "(PCI%s:%s:%s) ",
- 		((hw->bus_type == e1000_bus_type_pcix) ? "-X" : ""),
-@@ -1113,6 +1133,10 @@ static void __devexit e1000_remove(struct pci_dev *pdev)
- 
- 	kfree(adapter->tx_ring);
- 	kfree(adapter->rx_ring);
-+	
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
- 
- 	iounmap(hw->hw_addr);
- 	if (hw->flash_address)
-@@ -1291,6 +1315,10 @@ static int e1000_open(struct net_device *netdev)
- 
- 	netif_start_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif
-+
- 	/* fire a link status change interrupt to start the watchdog */
- 	ew32(ICS, E1000_ICS_LSC);
- 
-@@ -3429,6 +3457,10 @@ static bool e1000_clean_tx_irq(struct e1000_adapter *adapter,
- 	unsigned int count = 0;
- 	unsigned int total_tx_bytes=0, total_tx_packets=0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(netdev, 0))
-+		return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->buffer_info[i].next_to_watch;
- 	eop_desc = E1000_TX_DESC(*tx_ring, eop);
-@@ -3795,6 +3827,11 @@ static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
- 	bool cleaned = false;
- 	unsigned int total_rx_bytes=0, total_rx_packets=0;
- 
-+#ifdef DEV_NETMAP
-+	ND("calling netmap_rx_irq");
-+	if (netmap_rx_irq(netdev, 0, work_done))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = E1000_RX_DESC(*rx_ring, i);
- 	buffer_info = &rx_ring->buffer_info[i];
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--20620--20623 b/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--20620--20623
deleted file mode 100644
index 4c7ebf0d4dc7..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--20620--20623
+++ /dev/null
@@ -1,91 +0,0 @@
-diff --git a/e1000e/netdev.c b/e1000e/netdev.c
-index fad8f9e..50f74e2 100644
---- a/e1000e/netdev.c
-+++ b/e1000e/netdev.c
-@@ -87,6 +87,10 @@ static int e1000_desc_unused(struct e1000_ring *ring)
- 	return ring->count + ring->next_to_clean - ring->next_to_use - 1;
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_e1000e_netmap.h>
-+#endif
-+
- /**
-  * e1000_receive_skb - helper function to handle Rx indications
-  * @adapter: board private structure
-@@ -446,6 +450,10 @@ static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
- 	bool cleaned = 0;
- 	unsigned int total_rx_bytes = 0, total_rx_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(netdev, 0, work_done))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = E1000_RX_DESC(*rx_ring, i);
- 	buffer_info = &rx_ring->buffer_info[i];
-@@ -624,6 +632,10 @@ static bool e1000_clean_tx_irq(struct e1000_adapter *adapter)
- 	unsigned int count = 0;
- 	unsigned int total_tx_bytes = 0, total_tx_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(netdev, 0))
-+		return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->buffer_info[i].next_to_watch;
- 	eop_desc = E1000_TX_DESC(*tx_ring, eop);
-@@ -2632,6 +2644,10 @@ static void e1000_configure(struct e1000_adapter *adapter)
- 	e1000_configure_tx(adapter);
- 	e1000_setup_rctl(adapter);
- 	e1000_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	if (e1000e_netmap_init_buffers(adapter))
-+		return;
-+#endif /* DEV_NETMAP */
- 	adapter->alloc_rx_buf(adapter, e1000_desc_unused(adapter->rx_ring));
- }
- 
-@@ -2892,6 +2908,10 @@ void e1000e_down(struct e1000_adapter *adapter)
- 
- 	netif_stop_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	/* disable transmits in the hardware */
- 	tctl = er32(TCTL);
- 	tctl &= ~E1000_TCTL_EN;
-@@ -3174,6 +3194,10 @@ static int e1000_open(struct net_device *netdev)
- 
- 	netif_start_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* fire a link status change interrupt to start the watchdog */
- 	ew32(ICS, E1000_ICS_LSC);
- 
-@@ -5227,6 +5251,9 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
- 	if (err)
- 		goto err_register;
- 
-+#ifdef DEV_NETMAP
-+	e1000_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-@@ -5300,6 +5327,10 @@ static void __devexit e1000_remove(struct pci_dev *pdev)
- 	kfree(adapter->tx_ring);
- 	kfree(adapter->rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	iounmap(adapter->hw.hw_addr);
- 	if (adapter->hw.flash_address)
- 		iounmap(adapter->hw.flash_address);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--20623--30100 b/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--20623--30100
deleted file mode 100644
index e7754deab57a..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--20623--30100
+++ /dev/null
@@ -1,91 +0,0 @@
-diff --git a/e1000e/netdev.c b/e1000e/netdev.c
-index 57a7e41..d8bc988 100644
---- a/e1000e/netdev.c
-+++ b/e1000e/netdev.c
-@@ -435,6 +435,10 @@ static int e1000_desc_unused(struct e1000_ring *ring)
- 	return ring->count + ring->next_to_clean - ring->next_to_use - 1;
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_e1000e_netmap.h>
-+#endif
-+
- /**
-  * e1000_receive_skb - helper function to handle Rx indications
-  * @adapter: board private structure
-@@ -763,6 +767,10 @@ static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
- 	bool cleaned = 0;
- 	unsigned int total_rx_bytes = 0, total_rx_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(netdev, 0, work_done))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = E1000_RX_DESC(*rx_ring, i);
- 	buffer_info = &rx_ring->buffer_info[i];
-@@ -977,6 +985,10 @@ static bool e1000_clean_tx_irq(struct e1000_adapter *adapter)
- 	unsigned int count = 0;
- 	unsigned int total_tx_bytes = 0, total_tx_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(netdev, 0))
-+		return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->buffer_info[i].next_to_watch;
- 	eop_desc = E1000_TX_DESC(*tx_ring, eop);
-@@ -3001,6 +3013,10 @@ static void e1000_configure(struct e1000_adapter *adapter)
- 	e1000_configure_tx(adapter);
- 	e1000_setup_rctl(adapter);
- 	e1000_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	if (e1000e_netmap_init_buffers(adapter))
-+		return;
-+#endif /* DEV_NETMAP */
- 	adapter->alloc_rx_buf(adapter, e1000_desc_unused(adapter->rx_ring));
- }
- 
-@@ -3240,6 +3256,10 @@ void e1000e_down(struct e1000_adapter *adapter)
- 
- 	netif_stop_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	/* disable transmits in the hardware */
- 	tctl = er32(TCTL);
- 	tctl &= ~E1000_TCTL_EN;
-@@ -3532,6 +3552,10 @@ static int e1000_open(struct net_device *netdev)
- 
- 	netif_start_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	adapter->idle_check = true;
- 	pm_runtime_put(&pdev->dev);
- 
-@@ -5716,6 +5740,9 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
- 	if (err)
- 		goto err_register;
- 
-+#ifdef DEV_NETMAP
-+	e1000_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-@@ -5813,6 +5840,10 @@ static void __devexit e1000_remove(struct pci_dev *pdev)
- 	kfree(adapter->tx_ring);
- 	kfree(adapter->rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	iounmap(adapter->hw.hw_addr);
- 	if (adapter->hw.flash_address)
- 		iounmap(adapter->hw.flash_address);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30100--30400 b/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30100--30400
deleted file mode 100644
index 5032d88a45e0..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30100--30400
+++ /dev/null
@@ -1,91 +0,0 @@
-diff --git a/e1000e/netdev.c b/e1000e/netdev.c
-index 2198e61..caf2767 100644
---- a/e1000e/netdev.c
-+++ b/e1000e/netdev.c
-@@ -452,6 +452,10 @@ static int e1000_desc_unused(struct e1000_ring *ring)
- 	return ring->count + ring->next_to_clean - ring->next_to_use - 1;
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_e1000e_netmap.h>
-+#endif
-+
- /**
-  * e1000_receive_skb - helper function to handle Rx indications
-  * @adapter: board private structure
-@@ -849,6 +853,10 @@ static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
- 	bool cleaned = 0;
- 	unsigned int total_rx_bytes = 0, total_rx_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(netdev, 0, work_done))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = E1000_RX_DESC(*rx_ring, i);
- 	buffer_info = &rx_ring->buffer_info[i];
-@@ -1066,6 +1074,10 @@ static bool e1000_clean_tx_irq(struct e1000_adapter *adapter)
- 	unsigned int count = 0;
- 	unsigned int total_tx_bytes = 0, total_tx_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(netdev, 0))
-+		return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->buffer_info[i].next_to_watch;
- 	eop_desc = E1000_TX_DESC(*tx_ring, eop);
-@@ -3177,6 +3189,10 @@ static void e1000_configure(struct e1000_adapter *adapter)
- 	e1000_configure_tx(adapter);
- 	e1000_setup_rctl(adapter);
- 	e1000_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	if (e1000e_netmap_init_buffers(adapter))
-+		return;
-+#endif /* DEV_NETMAP */
- 	adapter->alloc_rx_buf(adapter, e1000_desc_unused(adapter->rx_ring),
- 			      GFP_KERNEL);
- }
-@@ -3468,6 +3484,10 @@ void e1000e_down(struct e1000_adapter *adapter)
- 
- 	netif_stop_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	/* disable transmits in the hardware */
- 	tctl = er32(TCTL);
- 	tctl &= ~E1000_TCTL_EN;
-@@ -3755,6 +3775,10 @@ static int e1000_open(struct net_device *netdev)
- 
- 	netif_start_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	adapter->idle_check = true;
- 	pm_runtime_put(&pdev->dev);
- 
-@@ -6147,6 +6171,9 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
- 	if (err)
- 		goto err_register;
- 
-+#ifdef DEV_NETMAP
-+	e1000_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-@@ -6234,6 +6261,10 @@ static void __devexit e1000_remove(struct pci_dev *pdev)
- 	kfree(adapter->tx_ring);
- 	kfree(adapter->rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	iounmap(adapter->hw.hw_addr);
- 	if (adapter->hw.flash_address)
- 		iounmap(adapter->hw.flash_address);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30400--30900 b/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30400--30900
deleted file mode 100644
index 0c6de76fece5..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30400--30900
+++ /dev/null
@@ -1,91 +0,0 @@
-diff --git a/e1000e/netdev.c b/e1000e/netdev.c
-index 9520a6a..f6f2df6 100644
---- a/e1000e/netdev.c
-+++ b/e1000e/netdev.c
-@@ -467,6 +467,10 @@ static int e1000_desc_unused(struct e1000_ring *ring)
- 	return ring->count + ring->next_to_clean - ring->next_to_use - 1;
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_e1000e_netmap.h>
-+#endif
-+
- /**
-  * e1000_receive_skb - helper function to handle Rx indications
-  * @adapter: board private structure
-@@ -875,6 +879,10 @@ static bool e1000_clean_rx_irq(struct e1000_ring *rx_ring, int *work_done,
- 	bool cleaned = false;
- 	unsigned int total_rx_bytes = 0, total_rx_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(netdev, 0, work_done))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = E1000_RX_DESC_EXT(*rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -1129,6 +1137,10 @@ static bool e1000_clean_tx_irq(struct e1000_ring *tx_ring)
- 	unsigned int total_tx_bytes = 0, total_tx_packets = 0;
- 	unsigned int bytes_compl = 0, pkts_compl = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(netdev, 0))
-+		return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->buffer_info[i].next_to_watch;
- 	eop_desc = E1000_TX_DESC(*tx_ring, eop);
-@@ -3358,6 +3370,10 @@ static void e1000_configure(struct e1000_adapter *adapter)
- 		e1000e_setup_rss_hash(adapter);
- 	e1000_setup_rctl(adapter);
- 	e1000_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	if (e1000e_netmap_init_buffers(adapter))
-+		return;
-+#endif /* DEV_NETMAP */
- 	adapter->alloc_rx_buf(rx_ring, e1000_desc_unused(rx_ring), GFP_KERNEL);
- }
- 
-@@ -3657,6 +3673,10 @@ void e1000e_down(struct e1000_adapter *adapter)
- 
- 	netif_stop_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	/* disable transmits in the hardware */
- 	tctl = er32(TCTL);
- 	tctl &= ~E1000_TCTL_EN;
-@@ -3946,6 +3966,10 @@ static int e1000_open(struct net_device *netdev)
- 	adapter->tx_hang_recheck = false;
- 	netif_start_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	adapter->idle_check = true;
- 	pm_runtime_put(&pdev->dev);
- 
-@@ -6417,6 +6441,9 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
- 	if (err)
- 		goto err_register;
- 
-+#ifdef DEV_NETMAP
-+	e1000_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-@@ -6504,6 +6531,10 @@ static void __devexit e1000_remove(struct pci_dev *pdev)
- 	kfree(adapter->tx_ring);
- 	kfree(adapter->rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	iounmap(adapter->hw.hw_addr);
- 	if (adapter->hw.flash_address)
- 		iounmap(adapter->hw.flash_address);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30900--30f00 b/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30900--30f00
deleted file mode 100644
index 3156ba398adf..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30900--30f00
+++ /dev/null
@@ -1,91 +0,0 @@
-diff --git a/e1000e/netdev.c b/e1000e/netdev.c
-index 7e615e2..f9d8a88 100644
---- a/e1000e/netdev.c
-+++ b/e1000e/netdev.c
-@@ -473,6 +473,10 @@ static int e1000_desc_unused(struct e1000_ring *ring)
- 	return ring->count + ring->next_to_clean - ring->next_to_use - 1;
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_e1000e_netmap.h>
-+#endif
-+
- /**
-  * e1000e_systim_to_hwtstamp - convert system time value to hw time stamp
-  * @adapter: board private structure
-@@ -914,6 +918,10 @@ static bool e1000_clean_rx_irq(struct e1000_ring *rx_ring, int *work_done,
- 	bool cleaned = false;
- 	unsigned int total_rx_bytes = 0, total_rx_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(netdev, 0, work_done))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = E1000_RX_DESC_EXT(*rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -1203,6 +1211,10 @@ static bool e1000_clean_tx_irq(struct e1000_ring *tx_ring)
- 	unsigned int total_tx_bytes = 0, total_tx_packets = 0;
- 	unsigned int bytes_compl = 0, pkts_compl = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(netdev, 0))
-+		return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->buffer_info[i].next_to_watch;
- 	eop_desc = E1000_TX_DESC(*tx_ring, eop);
-@@ -3685,6 +3697,10 @@ static void e1000_configure(struct e1000_adapter *adapter)
- 		e1000e_setup_rss_hash(adapter);
- 	e1000_setup_rctl(adapter);
- 	e1000_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	if (e1000e_netmap_init_buffers(adapter))
-+		return;
-+#endif /* DEV_NETMAP */
- 	adapter->alloc_rx_buf(rx_ring, e1000_desc_unused(rx_ring), GFP_KERNEL);
- }
- 
-@@ -3988,6 +4004,10 @@ void e1000e_down(struct e1000_adapter *adapter)
- 
- 	netif_stop_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	/* disable transmits in the hardware */
- 	tctl = er32(TCTL);
- 	tctl &= ~E1000_TCTL_EN;
-@@ -4307,6 +4327,10 @@ static int e1000_open(struct net_device *netdev)
- 	adapter->tx_hang_recheck = false;
- 	netif_start_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	adapter->idle_check = true;
- 	hw->mac.get_link_status = true;
- 	pm_runtime_put(&pdev->dev);
-@@ -6768,6 +6792,9 @@ static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	if (err)
- 		goto err_register;
- 
-+#ifdef DEV_NETMAP
-+	e1000_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-@@ -6866,6 +6893,10 @@ static void e1000_remove(struct pci_dev *pdev)
- 	kfree(adapter->tx_ring);
- 	kfree(adapter->rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	iounmap(adapter->hw.hw_addr);
- 	if (adapter->hw.flash_address)
- 		iounmap(adapter->hw.flash_address);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30f00--99999 b/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30f00--99999
deleted file mode 100644
index 4bfd840b4202..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--e1000e--30f00--99999
+++ /dev/null
@@ -1,91 +0,0 @@
-diff --git a/e1000e/netdev.c b/e1000e/netdev.c
-index 3e69386..e55355b 100644
---- a/e1000e/netdev.c
-+++ b/e1000e/netdev.c
-@@ -463,6 +463,10 @@ static int e1000_desc_unused(struct e1000_ring *ring)
- 	return ring->count + ring->next_to_clean - ring->next_to_use - 1;
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_e1000e_netmap.h>
-+#endif
-+
- /**
-  * e1000e_systim_to_hwtstamp - convert system time value to hw time stamp
-  * @adapter: board private structure
-@@ -903,6 +907,10 @@ static bool e1000_clean_rx_irq(struct e1000_ring *rx_ring, int *work_done,
- 	bool cleaned = false;
- 	unsigned int total_rx_bytes = 0, total_rx_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(netdev, 0, work_done))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = E1000_RX_DESC_EXT(*rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -1191,6 +1199,10 @@ static bool e1000_clean_tx_irq(struct e1000_ring *tx_ring)
- 	unsigned int total_tx_bytes = 0, total_tx_packets = 0;
- 	unsigned int bytes_compl = 0, pkts_compl = 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(netdev, 0))
-+		return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->buffer_info[i].next_to_watch;
- 	eop_desc = E1000_TX_DESC(*tx_ring, eop);
-@@ -3692,6 +3704,10 @@ static void e1000_configure(struct e1000_adapter *adapter)
- 		e1000e_setup_rss_hash(adapter);
- 	e1000_setup_rctl(adapter);
- 	e1000_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	if (e1000e_netmap_init_buffers(adapter))
-+		return;
-+#endif /* DEV_NETMAP */
- 	adapter->alloc_rx_buf(rx_ring, e1000_desc_unused(rx_ring), GFP_KERNEL);
- }
- 
-@@ -4027,6 +4043,10 @@ void e1000e_down(struct e1000_adapter *adapter, bool reset)
- 
- 	netif_stop_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	/* disable transmits in the hardware */
- 	tctl = er32(TCTL);
- 	tctl &= ~E1000_TCTL_EN;
-@@ -4349,6 +4369,10 @@ static int e1000_open(struct net_device *netdev)
- 	adapter->tx_hang_recheck = false;
- 	netif_start_queue(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	hw->mac.get_link_status = true;
- 	pm_runtime_put(&pdev->dev);
- 
-@@ -6911,6 +6935,9 @@ static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	if (err)
- 		goto err_register;
- 
-+#ifdef DEV_NETMAP
-+	e1000_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-@@ -7006,6 +7033,10 @@ static void e1000_remove(struct pci_dev *pdev)
- 	kfree(adapter->tx_ring);
- 	kfree(adapter->rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	iounmap(adapter->hw.hw_addr);
- 	if (adapter->hw.flash_address)
- 		iounmap(adapter->hw.flash_address);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--forcedeth.c--20626--99999 b/drivers/staging/netmap/LINUX/final-patches/diff--forcedeth.c--20626--99999
deleted file mode 100644
index e9723a2aaeb8..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--forcedeth.c--20626--99999
+++ /dev/null
@@ -1,76 +0,0 @@
-diff --git a/forcedeth.c b/forcedeth.c
-index 9c0b1ba..b081d6b 100644
---- a/forcedeth.c
-+++ b/forcedeth.c
-@@ -1865,12 +1865,25 @@ static void nv_init_tx(struct net_device *dev)
- 	}
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/* we need a few forward declarations */
-+static void nv_drain_rxtx(struct net_device *dev);
-+static int nv_init_ring(struct net_device *dev);
-+#include <forcedeth_netmap.h>
-+#endif
-+
- static int nv_init_ring(struct net_device *dev)
- {
- 	struct fe_priv *np = netdev_priv(dev);
- 
- 	nv_init_tx(dev);
- 	nv_init_rx(dev);
-+#ifdef DEV_NETMAP
-+	forcedeth_netmap_tx_init(np);
-+	if (forcedeth_netmap_rx_init(np))
-+		return 0; /* success */
-+#endif /* DEV_NETMAP */
-+
- 
- 	if (!nv_optimized(np))
- 		return nv_alloc_rx(dev);
-@@ -3386,6 +3399,11 @@ static irqreturn_t nv_nic_irq_tx(int foo, void *data)
- 	int i;
- 	unsigned long flags;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(dev, 0))
-+		return IRQ_HANDLED;
-+#endif /* DEV_NETMAP */
-+
- 	for (i = 0;; i++) {
- 		events = readl(base + NvRegMSIXIrqStatus) & NVREG_IRQ_TX_ALL;
- 		writel(NVREG_IRQ_TX_ALL, base + NvRegMSIXIrqStatus);
-@@ -3497,6 +3515,11 @@ static irqreturn_t nv_nic_irq_rx(int foo, void *data)
- 	int i;
- 	unsigned long flags;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(dev, 0, &i))
-+		return IRQ_HANDLED;
-+#endif /* DEV_NETMAP */
-+
- 	for (i = 0;; i++) {
- 		events = readl(base + NvRegMSIXIrqStatus) & NVREG_IRQ_RX_ALL;
- 		writel(NVREG_IRQ_RX_ALL, base + NvRegMSIXIrqStatus);
-@@ -5645,6 +5668,10 @@ static int __devinit nv_probe(struct pci_dev *pci_dev, const struct pci_device_i
- 		goto out_error;
- 	}
- 
-+#ifdef DEV_NETMAP
-+	forcedeth_netmap_attach(np);
-+#endif /* DEV_NETMAP */
-+
- 	netif_carrier_off(dev);
- 
- 	dev_info(&pci_dev->dev, "ifname %s, PHY OUI 0x%x @ %d, addr %pM\n",
-@@ -5728,6 +5755,10 @@ static void __devexit nv_remove(struct pci_dev *pci_dev)
- 
- 	unregister_netdev(dev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(dev);
-+#endif /* DEV_NETMAP */
-+
- 	nv_restore_mac_addr(pci_dev);
- 
- 	/* restore any phy related changes */
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--igb--20621--20623 b/drivers/staging/netmap/LINUX/final-patches/diff--igb--20621--20623
deleted file mode 100644
index a942890f0bf0..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--igb--20621--20623
+++ /dev/null
@@ -1,115 +0,0 @@
-diff --git a/igb/igb_main.c b/igb/igb_main.c
-index c881347..9a8b012 100644
---- a/igb/igb_main.c
-+++ b/igb/igb_main.c
-@@ -226,6 +226,10 @@ char *igb_get_hw_dev_name(struct e1000_hw *hw)
- 	return adapter->netdev->name;
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_igb_netmap.h>
-+#endif
-+
- /**
-  * igb_get_time_str - format current NIC and system time as string
-  */
-@@ -1144,6 +1148,10 @@ int igb_up(struct igb_adapter *adapter)
- 
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -1167,6 +1175,10 @@ void igb_down(struct igb_adapter *adapter)
- 	wr32(E1000_RCTL, rctl & ~E1000_RCTL_EN);
- 	/* flush and sleep below */
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	netif_tx_stop_all_queues(netdev);
- 
- 	/* disable transmits in the hardware */
-@@ -1614,6 +1626,10 @@ static int __devinit igb_probe(struct pci_dev *pdev,
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-+#ifdef DEV_NETMAP
-+	igb_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- #ifdef CONFIG_IGB_DCA
- 	if (dca_add_requester(&pdev->dev) == 0) {
- 		adapter->flags |= IGB_FLAG_DCA_ENABLED;
-@@ -1699,6 +1715,10 @@ static void __devexit igb_remove(struct pci_dev *pdev)
- 		wr32(E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_MODE_DISABLE);
- 	}
- #endif
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 
- 	/* Release control of h/w to f/w.  If f/w is AMT enabled, this
- 	 * would have already happened in close and is redundant. */
-@@ -2018,6 +2038,10 @@ static int igb_open(struct net_device *netdev)
- 
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -2196,6 +2220,9 @@ void igb_configure_tx_ring(struct igb_adapter *adapter,
- 
- 	txdctl |= E1000_TXDCTL_QUEUE_ENABLE;
- 	wr32(E1000_TXDCTL(reg_idx), txdctl);
-+#ifdef DEV_NETMAP
-+	igb_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- /**
-@@ -4905,6 +4932,11 @@ static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)
- 	unsigned int i, eop, count = 0;
- 	bool cleaned = false;
- 
-+#ifdef DEV_NETMAP
-+        if (netmap_tx_irq(netdev, tx_ring->queue_index))
-+                return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
-+
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->buffer_info[i].next_to_watch;
- 	eop_desc = E1000_TX_DESC_ADV(*tx_ring, eop);
-@@ -5109,6 +5141,11 @@ static bool igb_clean_rx_irq_adv(struct igb_q_vector *q_vector,
- 	u16 length;
- 	u16 vlan_tag;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(netdev, rx_ring->queue_index, work_done))
-+		return 1;
-+#endif /* DEV_NETMAP */
-+
- 	i = rx_ring->next_to_clean;
- 	buffer_info = &rx_ring->buffer_info[i];
- 	rx_desc = E1000_RX_DESC_ADV(*rx_ring, i);
-@@ -5236,6 +5273,10 @@ void igb_alloc_rx_buffers_adv(struct igb_ring *rx_ring, int cleaned_count)
- 	unsigned int i;
- 	int bufsz;
- 
-+#ifdef DEV_NETMAP
-+	if (igb_netmap_configure_rx_ring(rx_ring))
-+                return;
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_use;
- 	buffer_info = &rx_ring->buffer_info[i];
- 
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--igb--20623--30200 b/drivers/staging/netmap/LINUX/final-patches/diff--igb--20623--30200
deleted file mode 100644
index d9236b8849a8..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--igb--20623--30200
+++ /dev/null
@@ -1,115 +0,0 @@
-diff --git a/igb/igb_main.c b/igb/igb_main.c
-index cea37e0..70777e4 100644
---- a/igb/igb_main.c
-+++ b/igb/igb_main.c
-@@ -201,6 +201,10 @@ MODULE_DESCRIPTION("Intel(R) Gigabit Ethernet Network Driver");
- MODULE_LICENSE("GPL");
- MODULE_VERSION(DRV_VERSION);
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_igb_netmap.h>
-+#endif
-+
- struct igb_reg_info {
- 	u32 ofs;
- 	char *name;
-@@ -1478,6 +1482,10 @@ int igb_up(struct igb_adapter *adapter)
- 
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -1501,6 +1509,10 @@ void igb_down(struct igb_adapter *adapter)
- 	wr32(E1000_RCTL, rctl & ~E1000_RCTL_EN);
- 	/* flush and sleep below */
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	netif_tx_stop_all_queues(netdev);
- 
- 	/* disable transmits in the hardware */
-@@ -1963,6 +1975,10 @@ static int __devinit igb_probe(struct pci_dev *pdev,
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-+#ifdef DEV_NETMAP
-+	igb_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- #ifdef CONFIG_IGB_DCA
- 	if (dca_add_requester(&pdev->dev) == 0) {
- 		adapter->flags |= IGB_FLAG_DCA_ENABLED;
-@@ -2072,6 +2088,10 @@ static void __devexit igb_remove(struct pci_dev *pdev)
- 		dev_info(&pdev->dev, "IOV Disabled\n");
- 	}
- #endif
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 
- 	iounmap(hw->hw_addr);
- 	if (hw->flash_address)
-@@ -2366,6 +2386,10 @@ static int igb_open(struct net_device *netdev)
- 
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -2545,6 +2569,9 @@ void igb_configure_tx_ring(struct igb_adapter *adapter,
- 
- 	txdctl |= E1000_TXDCTL_QUEUE_ENABLE;
- 	wr32(E1000_TXDCTL(reg_idx), txdctl);
-+#ifdef DEV_NETMAP
-+	igb_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- /**
-@@ -5338,6 +5365,11 @@ static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)
- 	unsigned int i, eop, count = 0;
- 	bool cleaned = false;
- 
-+#ifdef DEV_NETMAP
-+        if (netmap_tx_irq(netdev, tx_ring->queue_index))
-+                return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
-+
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->buffer_info[i].next_to_watch;
- 	eop_desc = E1000_TX_DESC_ADV(*tx_ring, eop);
-@@ -5540,6 +5572,11 @@ static bool igb_clean_rx_irq_adv(struct igb_q_vector *q_vector,
- 	u16 length;
- 	u16 vlan_tag;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(netdev, rx_ring->queue_index, work_done))
-+		return 1;
-+#endif /* DEV_NETMAP */
-+
- 	i = rx_ring->next_to_clean;
- 	buffer_info = &rx_ring->buffer_info[i];
- 	rx_desc = E1000_RX_DESC_ADV(*rx_ring, i);
-@@ -5668,6 +5705,10 @@ void igb_alloc_rx_buffers_adv(struct igb_ring *rx_ring, int cleaned_count)
- 	unsigned int i;
- 	int bufsz;
- 
-+#ifdef DEV_NETMAP
-+	if (igb_netmap_configure_rx_ring(rx_ring))
-+                return;
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_use;
- 	buffer_info = &rx_ring->buffer_info[i];
- 
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30200--30300 b/drivers/staging/netmap/LINUX/final-patches/diff--igb--30200--30300
deleted file mode 100644
index b4993b12e60c..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30200--30300
+++ /dev/null
@@ -1,136 +0,0 @@
-diff --git a/igb/igb_main.c b/igb/igb_main.c
-index ced5444..b7c6cb4 100644
---- a/igb/igb_main.c
-+++ b/igb/igb_main.c
-@@ -225,6 +225,10 @@ MODULE_DESCRIPTION("Intel(R) Gigabit Ethernet Network Driver");
- MODULE_LICENSE("GPL");
- MODULE_VERSION(DRV_VERSION);
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_igb_netmap.h>
-+#endif
-+
- struct igb_reg_info {
- 	u32 ofs;
- 	char *name;
-@@ -1551,6 +1555,10 @@ int igb_up(struct igb_adapter *adapter)
- 
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -1584,6 +1592,10 @@ void igb_down(struct igb_adapter *adapter)
- 	wrfl();
- 	msleep(10);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	for (i = 0; i < adapter->num_q_vectors; i++)
- 		napi_disable(&(adapter->q_vector[i]->napi));
- 
-@@ -2073,6 +2085,10 @@ static int __devinit igb_probe(struct pci_dev *pdev,
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-+#ifdef DEV_NETMAP
-+	igb_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- #ifdef CONFIG_IGB_DCA
- 	if (dca_add_requester(&pdev->dev) == 0) {
- 		adapter->flags |= IGB_FLAG_DCA_ENABLED;
-@@ -2199,6 +2215,10 @@ static void __devexit igb_remove(struct pci_dev *pdev)
- 		dev_info(&pdev->dev, "IOV Disabled\n");
- 	}
- #endif
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 
- 	iounmap(hw->hw_addr);
- 	if (hw->flash_address)
-@@ -2529,6 +2549,10 @@ static int igb_open(struct net_device *netdev)
- 
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -2711,6 +2735,9 @@ void igb_configure_tx_ring(struct igb_adapter *adapter,
- 
- 	txdctl |= E1000_TXDCTL_QUEUE_ENABLE;
- 	wr32(E1000_TXDCTL(reg_idx), txdctl);
-+#ifdef DEV_NETMAP
-+	igb_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- /**
-@@ -3088,6 +3115,19 @@ void igb_configure_rx_ring(struct igb_adapter *adapter,
- 	/* Only set Drop Enable if we are supporting multiple queues */
- 	if (adapter->vfs_allocated_count || adapter->num_rx_queues > 1)
- 		srrctl |= E1000_SRRCTL_DROP_EN;
-+#ifdef DEV_NETMAP
-+	{
-+		/* The driver uses split buffers, which are not
-+		 * supported in native netmap mode */
-+		struct ifnet *ifp = adapter->netdev;
-+		struct netmap_adapter *na = NA(ifp);
-+		if (nm_native_on(na)) {
-+			srrctl &= ~(7 << 25); /* clear descriptor type */
-+			srrctl |= E1000_SRRCTL_DESCTYPE_ADV_ONEBUF;
-+			/* XXX we should set tail here */
-+		}
-+	}
-+#endif
- 
- 	wr32(E1000_SRRCTL(reg_idx), srrctl);
- 
-@@ -5705,6 +5745,10 @@ static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)
- 
- 	if (test_bit(__IGB_DOWN, &adapter->state))
- 		return true;
-+#ifdef DEV_NETMAP
-+        if (netmap_tx_irq(tx_ring->netdev, tx_ring->queue_index))
-+                return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IGB_TX_DESC(tx_ring, i);
-@@ -5980,6 +6024,12 @@ static bool igb_clean_rx_irq(struct igb_q_vector *q_vector, int budget)
- 	u16 cleaned_count = igb_desc_unused(rx_ring);
- 	u16 i = rx_ring->next_to_clean;
- 
-+#ifdef DEV_NETMAP
-+	int dummy = 1; // select rx irq handling
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &dummy))
-+		return 1;
-+#endif /* DEV_NETMAP */
-+
- 	rx_desc = IGB_RX_DESC(rx_ring, i);
- 
- 	while (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {
-@@ -6170,6 +6220,11 @@ void igb_alloc_rx_buffers(struct igb_ring *rx_ring, u16 cleaned_count)
- 	struct igb_rx_buffer *bi;
- 	u16 i = rx_ring->next_to_use;
- 
-+#ifdef DEV_NETMAP
-+	if (igb_netmap_configure_rx_ring(rx_ring))
-+                return;
-+#endif /* DEV_NETMAP */
-+
- 	rx_desc = IGB_RX_DESC(rx_ring, i);
- 	bi = &rx_ring->rx_buffer_info[i];
- 	i -= rx_ring->count;
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30300--30800 b/drivers/staging/netmap/LINUX/final-patches/diff--igb--30300--30800
deleted file mode 100644
index 885d9b2dece6..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30300--30800
+++ /dev/null
@@ -1,136 +0,0 @@
-diff --git a/igb/igb_main.c b/igb/igb_main.c
-index 94be6c3..e549e7b 100644
---- a/igb/igb_main.c
-+++ b/igb/igb_main.c
-@@ -236,6 +236,10 @@ MODULE_DESCRIPTION("Intel(R) Gigabit Ethernet Network Driver");
- MODULE_LICENSE("GPL");
- MODULE_VERSION(DRV_VERSION);
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_igb_netmap.h>
-+#endif
-+
- struct igb_reg_info {
- 	u32 ofs;
- 	char *name;
-@@ -1557,6 +1561,10 @@ int igb_up(struct igb_adapter *adapter)
- 
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -1590,6 +1598,10 @@ void igb_down(struct igb_adapter *adapter)
- 	wrfl();
- 	msleep(10);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	for (i = 0; i < adapter->num_q_vectors; i++)
- 		napi_disable(&(adapter->q_vector[i]->napi));
- 
-@@ -2081,6 +2093,10 @@ static int __devinit igb_probe(struct pci_dev *pdev,
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-+#ifdef DEV_NETMAP
-+	igb_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- #ifdef CONFIG_IGB_DCA
- 	if (dca_add_requester(&pdev->dev) == 0) {
- 		adapter->flags |= IGB_FLAG_DCA_ENABLED;
-@@ -2211,6 +2227,10 @@ static void __devexit igb_remove(struct pci_dev *pdev)
- 		dev_info(&pdev->dev, "IOV Disabled\n");
- 	}
- #endif
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 
- 	iounmap(hw->hw_addr);
- 	if (hw->flash_address)
-@@ -2547,6 +2567,10 @@ static int __igb_open(struct net_device *netdev, bool resuming)
- 
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	if (!resuming)
- 		pm_runtime_put(&pdev->dev);
- 
-@@ -2750,6 +2774,9 @@ void igb_configure_tx_ring(struct igb_adapter *adapter,
- 
- 	txdctl |= E1000_TXDCTL_QUEUE_ENABLE;
- 	wr32(E1000_TXDCTL(reg_idx), txdctl);
-+#ifdef DEV_NETMAP
-+	igb_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- /**
-@@ -3127,6 +3154,19 @@ void igb_configure_rx_ring(struct igb_adapter *adapter,
- 	/* Only set Drop Enable if we are supporting multiple queues */
- 	if (adapter->vfs_allocated_count || adapter->num_rx_queues > 1)
- 		srrctl |= E1000_SRRCTL_DROP_EN;
-+#ifdef DEV_NETMAP
-+	{
-+		/* The driver uses split buffers, which are not
-+		 * supported in native netmap mode */
-+		struct ifnet *ifp = adapter->netdev;
-+		struct netmap_adapter *na = NA(ifp);
-+		if (nm_native_on(na)) {
-+			srrctl &= ~(7 << 25); /* clear descriptor type */
-+			srrctl |= E1000_SRRCTL_DESCTYPE_ADV_ONEBUF;
-+			/* XXX we should set tail here */
-+		}
-+	}
-+#endif
- 
- 	wr32(E1000_SRRCTL(reg_idx), srrctl);
- 
-@@ -5753,6 +5793,10 @@ static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)
- 
- 	if (test_bit(__IGB_DOWN, &adapter->state))
- 		return true;
-+#ifdef DEV_NETMAP
-+        if (netmap_tx_irq(tx_ring->netdev, tx_ring->queue_index))
-+                return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IGB_TX_DESC(tx_ring, i);
-@@ -6030,6 +6074,12 @@ static bool igb_clean_rx_irq(struct igb_q_vector *q_vector, int budget)
- 	u16 cleaned_count = igb_desc_unused(rx_ring);
- 	u16 i = rx_ring->next_to_clean;
- 
-+#ifdef DEV_NETMAP
-+	int dummy = 1; // select rx irq handling
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &dummy))
-+		return 1;
-+#endif /* DEV_NETMAP */
-+
- 	rx_desc = IGB_RX_DESC(rx_ring, i);
- 
- 	while (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {
-@@ -6220,6 +6270,11 @@ void igb_alloc_rx_buffers(struct igb_ring *rx_ring, u16 cleaned_count)
- 	struct igb_rx_buffer *bi;
- 	u16 i = rx_ring->next_to_use;
- 
-+#ifdef DEV_NETMAP
-+	if (igb_netmap_configure_rx_ring(rx_ring))
-+                return;
-+#endif /* DEV_NETMAP */
-+
- 	rx_desc = IGB_RX_DESC(rx_ring, i);
- 	bi = &rx_ring->rx_buffer_info[i];
- 	i -= rx_ring->count;
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30800--30b00 b/drivers/staging/netmap/LINUX/final-patches/diff--igb--30800--30b00
deleted file mode 100644
index a457d6420122..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30800--30b00
+++ /dev/null
@@ -1,114 +0,0 @@
-diff --git a/igb/igb_main.c b/igb/igb_main.c
-index 31cfe2e..8439bc6 100644
---- a/igb/igb_main.c
-+++ b/igb/igb_main.c
-@@ -247,6 +247,10 @@ static int debug = -1;
- module_param(debug, int, 0);
- MODULE_PARM_DESC(debug, "Debug level (0=none,...,16=all)");
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_igb_netmap.h>
-+#endif
-+
- struct igb_reg_info {
- 	u32 ofs;
- 	char *name;
-@@ -1520,6 +1524,10 @@ int igb_up(struct igb_adapter *adapter)
- 
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -1553,6 +1561,10 @@ void igb_down(struct igb_adapter *adapter)
- 	wrfl();
- 	msleep(10);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	for (i = 0; i < adapter->num_q_vectors; i++)
- 		napi_disable(&(adapter->q_vector[i]->napi));
- 
-@@ -2127,6 +2139,10 @@ static int igb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-+#ifdef DEV_NETMAP
-+	igb_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- #ifdef CONFIG_IGB_DCA
- 	if (dca_add_requester(&pdev->dev) == 0) {
- 		adapter->flags |= IGB_FLAG_DCA_ENABLED;
-@@ -2233,6 +2249,10 @@ static void igb_remove(struct pci_dev *pdev)
- 		wr32(E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_MODE_DISABLE);
- 	}
- #endif
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 
- 	/* Release control of h/w to f/w.  If f/w is AMT enabled, this
- 	 * would have already happened in close and is redundant. */
-@@ -2553,6 +2573,10 @@ static int __igb_open(struct net_device *netdev, bool resuming)
- 
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	if (!resuming)
- 		pm_runtime_put(&pdev->dev);
- 
-@@ -2746,6 +2770,9 @@ void igb_configure_tx_ring(struct igb_adapter *adapter,
- 
- 	txdctl |= E1000_TXDCTL_QUEUE_ENABLE;
- 	wr32(E1000_TXDCTL(reg_idx), txdctl);
-+#ifdef DEV_NETMAP
-+	igb_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- /**
-@@ -5690,6 +5717,10 @@ static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)
- 
- 	if (test_bit(__IGB_DOWN, &adapter->state))
- 		return true;
-+#ifdef DEV_NETMAP
-+        if (netmap_tx_irq(tx_ring->netdev, tx_ring->queue_index))
-+                return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IGB_TX_DESC(tx_ring, i);
-@@ -6349,6 +6380,10 @@ static bool igb_clean_rx_irq(struct igb_q_vector *q_vector, const int budget)
- 	unsigned int total_bytes = 0, total_packets = 0;
- 	u16 cleaned_count = igb_desc_unused(rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &total_packets))
-+		return true;
-+#endif /* DEV_NETMAP */
- 	do {
- 		union e1000_adv_rx_desc *rx_desc;
- 
-@@ -6461,6 +6496,11 @@ void igb_alloc_rx_buffers(struct igb_ring *rx_ring, u16 cleaned_count)
- 	struct igb_rx_buffer *bi;
- 	u16 i = rx_ring->next_to_use;
- 
-+#ifdef DEV_NETMAP
-+	if (igb_netmap_configure_rx_ring(rx_ring))
-+		return;
-+#endif /* DEV_NETMAP */
-+
- 	/* nothing to do */
- 	if (!cleaned_count)
- 		return;
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30b00--30f00 b/drivers/staging/netmap/LINUX/final-patches/diff--igb--30b00--30f00
deleted file mode 100644
index 6b9e4a2b2cbf..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30b00--30f00
+++ /dev/null
@@ -1,113 +0,0 @@
-diff --git a/igb/igb_main.c b/igb/igb_main.c
-index c1d72c0..9815796 100644
---- a/igb/igb_main.c
-+++ b/igb/igb_main.c
-@@ -255,6 +255,10 @@ static int debug = -1;
- module_param(debug, int, 0);
- MODULE_PARM_DESC(debug, "Debug level (0=none,...,16=all)");
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_igb_netmap.h>
-+#endif
-+
- struct igb_reg_info {
- 	u32 ofs;
- 	char *name;
-@@ -1633,6 +1637,10 @@ int igb_up(struct igb_adapter *adapter)
- 
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -1674,6 +1682,9 @@ void igb_down(struct igb_adapter *adapter)
- 		napi_disable(&(adapter->q_vector[i]->napi));
- 	}
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
- 
- 	del_timer_sync(&adapter->watchdog_timer);
- 	del_timer_sync(&adapter->phy_info_timer);
-@@ -2295,6 +2306,10 @@ static int igb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-+#ifdef DEV_NETMAP
-+	igb_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- #ifdef CONFIG_IGB_DCA
- 	if (dca_add_requester(&pdev->dev) == 0) {
- 		adapter->flags |= IGB_FLAG_DCA_ENABLED;
-@@ -2536,6 +2551,10 @@ static void igb_remove(struct pci_dev *pdev)
- 		wr32(E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_MODE_DISABLE);
- 	}
- #endif
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 
- 	/* Release control of h/w to f/w.  If f/w is AMT enabled, this
- 	 * would have already happened in close and is redundant.
-@@ -2814,6 +2833,10 @@ static int __igb_open(struct net_device *netdev, bool resuming)
- 
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	if (!resuming)
- 		pm_runtime_put(&pdev->dev);
- 
-@@ -3007,6 +3030,9 @@ void igb_configure_tx_ring(struct igb_adapter *adapter,
- 
- 	txdctl |= E1000_TXDCTL_QUEUE_ENABLE;
- 	wr32(E1000_TXDCTL(reg_idx), txdctl);
-+#ifdef DEV_NETMAP
-+	igb_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- /**
-@@ -5991,6 +6017,10 @@ static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)
- 
- 	if (test_bit(__IGB_DOWN, &adapter->state))
- 		return true;
-+#ifdef DEV_NETMAP
-+        if (netmap_tx_irq(tx_ring->netdev, tx_ring->queue_index))
-+                return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IGB_TX_DESC(tx_ring, i);
-@@ -6650,6 +6680,10 @@ static bool igb_clean_rx_irq(struct igb_q_vector *q_vector, const int budget)
- 	unsigned int total_bytes = 0, total_packets = 0;
- 	u16 cleaned_count = igb_desc_unused(rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &total_packets))
-+		return true;
-+#endif /* DEV_NETMAP */
- 	do {
- 		union e1000_adv_rx_desc *rx_desc;
- 
-@@ -6767,6 +6801,11 @@ void igb_alloc_rx_buffers(struct igb_ring *rx_ring, u16 cleaned_count)
- 	struct igb_rx_buffer *bi;
- 	u16 i = rx_ring->next_to_use;
- 
-+#ifdef DEV_NETMAP
-+	if (igb_netmap_configure_rx_ring(rx_ring))
-+		return;
-+#endif /* DEV_NETMAP */
-+
- 	/* nothing to do */
- 	if (!cleaned_count)
- 		return;
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30f00--99999 b/drivers/staging/netmap/LINUX/final-patches/diff--igb--30f00--99999
deleted file mode 100644
index 4fcc0209d2b8..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--igb--30f00--99999
+++ /dev/null
@@ -1,113 +0,0 @@
-diff --git a/igb/igb_main.c b/igb/igb_main.c
-index 16430a8..8d0c29d 100644
---- a/igb/igb_main.c
-+++ b/igb/igb_main.c
-@@ -257,6 +257,10 @@ static int debug = -1;
- module_param(debug, int, 0);
- MODULE_PARM_DESC(debug, "Debug level (0=none,...,16=all)");
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_igb_netmap.h>
-+#endif
-+
- struct igb_reg_info {
- 	u32 ofs;
- 	char *name;
-@@ -1751,6 +1755,10 @@ int igb_up(struct igb_adapter *adapter)
- 
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif /* DEV_NETMAP */
-+
- 	/* start the watchdog. */
- 	hw->mac.get_link_status = 1;
- 	schedule_work(&adapter->watchdog_task);
-@@ -1798,6 +1806,9 @@ void igb_down(struct igb_adapter *adapter)
- 		napi_disable(&(adapter->q_vector[i]->napi));
- 	}
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
- 
- 	del_timer_sync(&adapter->watchdog_timer);
- 	del_timer_sync(&adapter->phy_info_timer);
-@@ -2540,6 +2551,10 @@ static int igb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	/* carrier off reporting is important to ethtool even BEFORE open */
- 	netif_carrier_off(netdev);
- 
-+#ifdef DEV_NETMAP
-+	igb_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- #ifdef CONFIG_IGB_DCA
- 	if (dca_add_requester(&pdev->dev) == 0) {
- 		adapter->flags |= IGB_FLAG_DCA_ENABLED;
-@@ -2805,6 +2820,10 @@ static void igb_remove(struct pci_dev *pdev)
- 		wr32(E1000_DCA_CTRL, E1000_DCA_CTRL_DCA_MODE_DISABLE);
- 	}
- #endif
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- 
- 	/* Release control of h/w to f/w.  If f/w is AMT enabled, this
- 	 * would have already happened in close and is redundant.
-@@ -3083,6 +3102,10 @@ static int __igb_open(struct net_device *netdev, bool resuming)
- 
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(netdev);
-+#endif /* DEV_NETMAP */
-+
- 	if (!resuming)
- 		pm_runtime_put(&pdev->dev);
- 
-@@ -3276,6 +3299,9 @@ void igb_configure_tx_ring(struct igb_adapter *adapter,
- 
- 	txdctl |= E1000_TXDCTL_QUEUE_ENABLE;
- 	wr32(E1000_TXDCTL(reg_idx), txdctl);
-+#ifdef DEV_NETMAP
-+	igb_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- /**
-@@ -6321,6 +6347,10 @@ static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)
- 
- 	if (test_bit(__IGB_DOWN, &adapter->state))
- 		return true;
-+#ifdef DEV_NETMAP
-+        if (netmap_tx_irq(tx_ring->netdev, tx_ring->queue_index))
-+                return 1; /* cleaned ok */
-+#endif /* DEV_NETMAP */
- 
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IGB_TX_DESC(tx_ring, i);
-@@ -6984,6 +7014,10 @@ static bool igb_clean_rx_irq(struct igb_q_vector *q_vector, const int budget)
- 	unsigned int total_bytes = 0, total_packets = 0;
- 	u16 cleaned_count = igb_desc_unused(rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &total_packets))
-+		return true;
-+#endif /* DEV_NETMAP */
- 	while (likely(total_packets < budget)) {
- 		union e1000_adv_rx_desc *rx_desc;
- 
-@@ -7101,6 +7135,11 @@ void igb_alloc_rx_buffers(struct igb_ring *rx_ring, u16 cleaned_count)
- 	struct igb_rx_buffer *bi;
- 	u16 i = rx_ring->next_to_use;
- 
-+#ifdef DEV_NETMAP
-+	if (igb_netmap_configure_rx_ring(rx_ring))
-+		return;
-+#endif /* DEV_NETMAP */
-+
- 	/* nothing to do */
- 	if (!cleaned_count)
- 		return;
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20620--20622 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20620--20622
deleted file mode 100644
index 121247ba177d..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20620--20622
+++ /dev/null
@@ -1,126 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index a456578..188b961 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -337,6 +337,16 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	unsigned int i, eop, count = 0;
- 	unsigned int total_bytes = 0, total_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	* In netmap mode, all the work is done in the context
-+	* of the client thread. Interrupt handlers only wake up
-+	* clients, which may be sleeping on individual rings
-+	* or on a global resource for all rings.
-+	*/
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->tx_buffer_info[i].next_to_watch;
- 	eop_desc = IXGBE_TX_DESC_ADV(*tx_ring, eop);
-@@ -778,6 +788,14 @@ static bool ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- 	int ddp_bytes = 0;
- #endif /* IXGBE_FCOE */
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	* Same as the txeof routine: only wakeup clients on intr.
-+	*/
-+	if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, work_done))
-+		return true; /* no more interrupts */
-+#endif /* DEV_NETMAP */
-+
- 	i = rx_ring->next_to_clean;
- 	rx_desc = IXGBE_RX_DESC_ADV(*rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -1008,6 +1026,24 @@ static void ixgbe_configure_msix(struct ixgbe_adapter *adapter)
- 	IXGBE_WRITE_REG(&adapter->hw, IXGBE_EIAC, mask);
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
-+
-+
- enum latency_range {
- 	lowest_latency = 0,
- 	low_latency = 1,
-@@ -1044,7 +1080,6 @@ static u8 ixgbe_update_itr(struct ixgbe_adapter *adapter,
- 	if (packets == 0)
- 		goto update_itr_done;
- 
--
- 	/* simple throttlerate management
- 	 *    0-20MB/s lowest (100000 ints/s)
- 	 *   20-100MB/s low   (20000 ints/s)
-@@ -2568,6 +2603,12 @@ static void ixgbe_configure(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_configure_tx(adapter);
- 	ixgbe_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	for (i = 0; i < adapter->num_rx_queues; i++)
-+		ixgbe_netmap_configure_rx_ring(adapter,
-+			adapter->rx_ring[i].reg_idx);
-+	return;
-+#endif /* DEV_NETMAP */
- 	for (i = 0; i < adapter->num_rx_queues; i++)
- 		ixgbe_alloc_rx_buffers(adapter, &adapter->rx_ring[i],
- 		                       (adapter->rx_ring[i].count - 1));
-@@ -2753,6 +2794,11 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 		txdctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(j));
- 		txdctl |= IXGBE_TXDCTL_ENABLE;
- 		IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(j), txdctl);
-+
-+#ifdef DEV_NETMAP // XXX i and j are the same ?
-+		ixgbe_netmap_configure_tx_ring(adapter, j);
-+#endif /* DEV_NETMAP */
-+
- 	}
- 
- 	for (i = 0; i < num_rx_rings; i++) {
-@@ -2835,6 +2881,10 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -3040,6 +3090,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 	del_timer_sync(&adapter->watchdog_timer);
- 	cancel_work_sync(&adapter->watchdog_task);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	if (adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE ||
- 	    adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
- 		cancel_work_sync(&adapter->fdir_reinit_task);
-@@ -4290,6 +4344,9 @@ static int ixgbe_open(struct net_device *netdev)
- 		goto err_up;
- 
- 	netif_tx_start_all_queues(netdev);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
- 
- 	return 0;
- 
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20622--20623 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20622--20623
deleted file mode 100644
index 2766723e66d5..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20622--20623
+++ /dev/null
@@ -1,125 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index 6c00ee4..6b3e27a 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -400,6 +400,16 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	unsigned int i, eop, count = 0;
- 	unsigned int total_bytes = 0, total_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	* In netmap mode, all the work is done in the context
-+	* of the client thread. Interrupt handlers only wake up
-+	* clients, which may be sleeping on individual rings
-+	* or on a global resource for all rings.
-+	*/
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->tx_buffer_info[i].next_to_watch;
- 	eop_desc = IXGBE_TX_DESC_ADV(*tx_ring, eop);
-@@ -845,6 +855,14 @@ static bool ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- 	int ddp_bytes = 0;
- #endif /* IXGBE_FCOE */
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	* Same as the txeof routine: only wakeup clients on intr.
-+	*/
-+	if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, work_done))
-+		return true; /* no more interrupts */
-+#endif /* DEV_NETMAP */
-+
- 	i = rx_ring->next_to_clean;
- 	rx_desc = IXGBE_RX_DESC_ADV(*rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -1103,6 +1121,24 @@ static void ixgbe_configure_msix(struct ixgbe_adapter *adapter)
- 	IXGBE_WRITE_REG(&adapter->hw, IXGBE_EIAC, mask);
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
-+
-+
- enum latency_range {
- 	lowest_latency = 0,
- 	low_latency = 1,
-@@ -1139,7 +1175,6 @@ static u8 ixgbe_update_itr(struct ixgbe_adapter *adapter,
- 	if (packets == 0)
- 		goto update_itr_done;
- 
--
- 	/* simple throttlerate management
- 	 *    0-20MB/s lowest (100000 ints/s)
- 	 *   20-100MB/s low   (20000 ints/s)
-@@ -2738,6 +2773,12 @@ static void ixgbe_configure(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_configure_tx(adapter);
- 	ixgbe_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	for (i = 0; i < adapter->num_rx_queues; i++)
-+		ixgbe_netmap_configure_rx_ring(adapter,
-+			adapter->rx_ring[i]->reg_idx);
-+	return;
-+#endif /* DEV_NETMAP */
- 	for (i = 0; i < adapter->num_rx_queues; i++)
- 		ixgbe_alloc_rx_buffers(adapter, adapter->rx_ring[i],
- 		                       (adapter->rx_ring[i]->count - 1));
-@@ -2955,6 +2996,10 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 				DPRINTK(DRV, ERR, "Could not enable "
- 				        "Tx Queue %d\n", j);
- 		}
-+#ifdef DEV_NETMAP // XXX i and j are the same ?
-+		ixgbe_netmap_configure_tx_ring(adapter, j);
-+#endif /* DEV_NETMAP */
-+
- 	}
- 
- 	for (i = 0; i < num_rx_rings; i++) {
-@@ -3041,6 +3086,10 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -3284,6 +3333,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 	del_timer_sync(&adapter->watchdog_timer);
- 	cancel_work_sync(&adapter->watchdog_task);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	if (adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE ||
- 	    adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
- 		cancel_work_sync(&adapter->fdir_reinit_task);
-@@ -4641,6 +4694,9 @@ static int ixgbe_open(struct net_device *netdev)
- 		goto err_up;
- 
- 	netif_tx_start_all_queues(netdev);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
- 
- 	return 0;
- 
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20623--20625 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20623--20625
deleted file mode 100644
index c0b763c0d674..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20623--20625
+++ /dev/null
@@ -1,116 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index 74d9b6d..af73def 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -214,6 +214,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -741,6 +757,16 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	unsigned int i, eop, count = 0;
- 	unsigned int total_bytes = 0, total_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->tx_buffer_info[i].next_to_watch;
- 	eop_desc = IXGBE_TX_DESC_ADV(*tx_ring, eop);
-@@ -1187,6 +1213,13 @@ static bool ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- 	int ddp_bytes = 0;
- #endif /* IXGBE_FCOE */
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, work_done))
-+		return true; /* no more interrupts */
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = IXGBE_RX_DESC_ADV(*rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -3159,6 +3192,12 @@ static void ixgbe_configure(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_configure_tx(adapter);
- 	ixgbe_configure_rx(adapter);
-+#ifdef DEV_NETMAP
-+	for (i = 0; i < adapter->num_rx_queues; i++)
-+		ixgbe_netmap_configure_rx_ring(adapter,
-+			adapter->rx_ring[i]->reg_idx);
-+	return;
-+#endif /* DEV_NETMAP */
- 	for (i = 0; i < adapter->num_rx_queues; i++)
- 		ixgbe_alloc_rx_buffers(adapter, adapter->rx_ring[i],
- 		                       (adapter->rx_ring[i]->count - 1));
-@@ -3390,6 +3429,10 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 				DPRINTK(DRV, ERR, "Could not enable "
- 				        "Tx Queue %d\n", j);
- 		}
-+#ifdef DEV_NETMAP // XXX i and j are the same ?
-+		ixgbe_netmap_configure_tx_ring(adapter, j);
-+#endif /* DEV_NETMAP */
-+
- 	}
- 
- 	for (i = 0; i < num_rx_rings; i++) {
-@@ -3476,6 +3519,10 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -3718,6 +3765,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	if (adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE ||
- 	    adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
- 		cancel_work_sync(&adapter->fdir_reinit_task);
-@@ -6833,6 +6884,11 @@ static int __devinit ixgbe_probe(struct pci_dev *pdev,
- 
- 	dev_info(&pdev->dev, "Intel(R) 10 Gigabit Network Connection\n");
- 	cards_found++;
-+
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20625--20626 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20625--20626
deleted file mode 100644
index 7d74b408f248..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20625--20626
+++ /dev/null
@@ -1,113 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index eee0b29..39a59ba 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -214,6 +214,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -740,6 +756,16 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	unsigned int i, eop, count = 0;
- 	unsigned int total_bytes = 0, total_packets = 0;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->tx_buffer_info[i].next_to_watch;
- 	eop_desc = IXGBE_TX_DESC_ADV(tx_ring, eop);
-@@ -1185,6 +1211,13 @@ static bool ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- 	int ddp_bytes = 0;
- #endif /* IXGBE_FCOE */
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, work_done))
-+		return true; /* no more interrupts */
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -2519,6 +2552,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -2833,6 +2869,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(adapter, ring, IXGBE_DESC_UNUSED(ring));
- }
- 
-@@ -3614,6 +3654,10 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -3863,6 +3907,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	/* Cleanup the affinity_hint CPU mask memory and callback */
- 	for (i = 0; i < num_q_vectors; i++) {
- 		struct ixgbe_q_vector *q_vector = adapter->q_vector[i];
-@@ -7048,6 +7096,11 @@ static int __devinit ixgbe_probe(struct pci_dev *pdev,
- 
- 	e_dev_info("Intel(R) 10 Gigabit Network Connection\n");
- 	cards_found++;
-+
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20626--30000 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20626--30000
deleted file mode 100644
index cf8c681a976f..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--20626--30000
+++ /dev/null
@@ -1,113 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index 30f9ccf..60c0252 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -221,6 +221,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -826,6 +842,16 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	unsigned int total_bytes = 0, total_packets = 0;
- 	u16 i, eop, count = 0;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->tx_buffer_info[i].next_to_watch;
- 	eop_desc = IXGBE_TX_DESC_ADV(tx_ring, eop);
-@@ -1308,6 +1334,13 @@ static void ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- 	u16 cleaned_count = 0;
- 	bool pkt_is_rsc = false;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, work_done))
-+		return;
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -2730,6 +2763,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -3094,6 +3130,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(ring, IXGBE_DESC_UNUSED(ring));
- }
- 
-@@ -3882,6 +3922,10 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4121,6 +4165,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	/* Cleanup the affinity_hint CPU mask memory and callback */
- 	for (i = 0; i < num_q_vectors; i++) {
- 		struct ixgbe_q_vector *q_vector = adapter->q_vector[i];
-@@ -7450,6 +7498,11 @@ static int __devinit ixgbe_probe(struct pci_dev *pdev,
- 
- 	e_dev_info("Intel(R) 10 Gigabit Network Connection\n");
- 	cards_found++;
-+
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30000--30100 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30000--30100
deleted file mode 100644
index be2ba86cdaec..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30000--30100
+++ /dev/null
@@ -1,113 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index 08e8e25..8070930 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -247,6 +247,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -864,6 +880,16 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	unsigned int total_bytes = 0, total_packets = 0;
- 	u16 i, eop, count = 0;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->tx_buffer_info[i].next_to_watch;
- 	eop_desc = IXGBE_TX_DESC_ADV(tx_ring, eop);
-@@ -1348,6 +1374,13 @@ static void ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- 	u16 cleaned_count = 0;
- 	bool pkt_is_rsc = false;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, work_done))
-+		return;
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -2808,6 +2841,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -3183,6 +3219,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(ring, IXGBE_DESC_UNUSED(ring));
- }
- 
-@@ -3976,6 +4016,10 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4212,6 +4256,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	adapter->flags2 &= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
- 			     IXGBE_FLAG2_RESET_REQUESTED);
- 	adapter->flags &= ~IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -7683,6 +7731,11 @@ static int __devinit ixgbe_probe(struct pci_dev *pdev,
- 
- 	e_dev_info("Intel(R) 10 Gigabit Network Connection\n");
- 	cards_found++;
-+
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30100--30200 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30100--30200
deleted file mode 100644
index 47a830e7e4e6..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30100--30200
+++ /dev/null
@@ -1,114 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index e1fcc95..1aab0df 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -249,6 +249,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -801,6 +817,17 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	unsigned int total_bytes = 0, total_packets = 0;
- 	u16 i, eop, count = 0;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
-+
- 	i = tx_ring->next_to_clean;
- 	eop = tx_ring->tx_buffer_info[i].next_to_watch;
- 	eop_desc = IXGBE_TX_DESC_ADV(tx_ring, eop);
-@@ -1303,6 +1330,13 @@ static void ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- 	u16 cleaned_count = 0;
- 	bool pkt_is_rsc = false;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, work_done))
-+		return;
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -2676,6 +2710,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -3039,6 +3076,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
- }
- 
-@@ -3873,6 +3914,10 @@ static int ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4126,6 +4171,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	adapter->flags2 &= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
- 			     IXGBE_FLAG2_RESET_REQUESTED);
- 	adapter->flags &= ~IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -7696,6 +7745,11 @@ static int __devinit ixgbe_probe(struct pci_dev *pdev,
- 
- 	e_dev_info("Intel(R) 10 Gigabit Network Connection\n");
- 	cards_found++;
-+
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30200--30400 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30200--30400
deleted file mode 100644
index 57cee3bd82b3..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30200--30400
+++ /dev/null
@@ -1,115 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index 8ef92d1..6a37803 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -188,6 +188,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -745,6 +761,17 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	unsigned int budget = q_vector->tx.work_limit;
- 	u16 i = tx_ring->next_to_clean;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return true; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
-+
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IXGBE_TX_DESC_ADV(tx_ring, i);
- 
-@@ -1253,6 +1280,14 @@ static bool ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- 	u16 cleaned_count = 0;
- 	bool pkt_is_rsc = false;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	int dummy;
-+	if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, &dummy))
-+		return true;
-+#endif /* DEV_NETMAP */
- 	i = rx_ring->next_to_clean;
- 	rx_desc = IXGBE_RX_DESC_ADV(rx_ring, i);
- 	staterr = le32_to_cpu(rx_desc->wb.upper.status_error);
-@@ -2420,6 +2455,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -2783,6 +2821,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
- }
- 
-@@ -3757,6 +3799,10 @@ static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4007,6 +4053,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	adapter->flags2 &= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
- 			     IXGBE_FLAG2_RESET_REQUESTED);
- 	adapter->flags &= ~IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -7710,6 +7760,11 @@ static int __devinit ixgbe_probe(struct pci_dev *pdev,
- 
- 	e_dev_info("Intel(R) 10 Gigabit Network Connection\n");
- 	cards_found++;
-+
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30400--30500 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30400--30500
deleted file mode 100644
index a8375afe67ee..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30400--30500
+++ /dev/null
@@ -1,124 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index 467948e..0aa1511 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -204,6 +204,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -749,6 +765,17 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	if (test_bit(__IXGBE_DOWN, &adapter->state))
- 		return true;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
-+
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IXGBE_TX_DESC(tx_ring, i);
- 	i -= tx_ring->count;
-@@ -1629,6 +1656,15 @@ static bool ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- #endif /* IXGBE_FCOE */
- 	u16 cleaned_count = ixgbe_desc_unused(rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * 	 Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	int dummy;
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &dummy))
-+		return true; /* no more interrupts */
-+#endif /* DEV_NETMAP */
-+
- 	do {
- 		struct ixgbe_rx_buffer *rx_buffer;
- 		union ixgbe_adv_rx_desc *rx_desc;
-@@ -2683,6 +2719,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -3032,6 +3071,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
- }
- 
-@@ -3986,6 +4029,10 @@ static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4249,6 +4296,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	adapter->flags2 &= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
- 			     IXGBE_FLAG2_RESET_REQUESTED);
- 	adapter->flags &= ~IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4764,6 +4815,7 @@ static int ixgbe_open(struct net_device *netdev)
- 
- 	ixgbe_up_complete(adapter);
- 
-+
- 	return 0;
- 
- err_req_irq:
-@@ -7152,6 +7204,11 @@ static int __devinit ixgbe_probe(struct pci_dev *pdev,
- 
- 	e_dev_info("%s\n", ixgbe_default_device_descr);
- 	cards_found++;
-+
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30500--30900 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30500--30900
deleted file mode 100644
index 4b3c77a3a4a4..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30500--30900
+++ /dev/null
@@ -1,123 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index e242104..02e1544 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -204,6 +204,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -764,6 +780,17 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	if (test_bit(__IXGBE_DOWN, &adapter->state))
- 		return true;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
-+
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IXGBE_TX_DESC(tx_ring, i);
- 	i -= tx_ring->count;
-@@ -1665,6 +1692,15 @@ static bool ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- #endif /* IXGBE_FCOE */
- 	u16 cleaned_count = ixgbe_desc_unused(rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * 	 Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	int dummy;
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &dummy))
-+		return true; /* no more interrupts */
-+#endif /* DEV_NETMAP */
-+
- 	do {
- 		struct ixgbe_rx_buffer *rx_buffer;
- 		union ixgbe_adv_rx_desc *rx_desc;
-@@ -2725,6 +2761,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -3102,6 +3141,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
- }
- 
-@@ -4051,6 +4094,10 @@ static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4315,6 +4362,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	adapter->flags2 &= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
- 			     IXGBE_FLAG2_RESET_REQUESTED);
- 	adapter->flags &= ~IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4827,6 +4878,7 @@ static int ixgbe_open(struct net_device *netdev)
- 
- 	ixgbe_up_complete(adapter);
- 
-+
- 	return 0;
- 
- err_req_irq:
-@@ -7358,6 +7410,10 @@ static int __devinit ixgbe_probe(struct pci_dev *pdev,
- 		e_err(probe, "failed to allocate sysfs resources\n");
- #endif /* CONFIG_IXGBE_HWMON */
- 
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30900--30a00 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30900--30a00
deleted file mode 100644
index f98a21a6cb2a..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30900--30a00
+++ /dev/null
@@ -1,134 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index 79f4a26..4b8a25b 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -202,6 +202,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -826,6 +842,17 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	if (test_bit(__IXGBE_DOWN, &adapter->state))
- 		return true;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
-+
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IXGBE_TX_DESC(tx_ring, i);
- 	i -= tx_ring->count;
-@@ -1860,6 +1887,15 @@ static bool ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- #endif /* IXGBE_FCOE */
- 	u16 cleaned_count = ixgbe_desc_unused(rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * 	 Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	int dummy;
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &dummy))
-+		return true; /* no more interrupts */
-+#endif /* DEV_NETMAP */
-+
- 	do {
- 		union ixgbe_adv_rx_desc *rx_desc;
- 		struct sk_buff *skb;
-@@ -2846,6 +2882,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -3207,6 +3246,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
- }
- 
-@@ -4155,6 +4198,10 @@ static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4402,6 +4449,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	adapter->flags2 &= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
- 			     IXGBE_FLAG2_RESET_REQUESTED);
- 	adapter->flags &= ~IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4976,6 +5027,7 @@ static int ixgbe_open(struct net_device *netdev)
- 
- 	ixgbe_up_complete(adapter);
- 
-+
- 	return 0;
- 
- err_set_queues:
-@@ -7619,6 +7671,10 @@ skip_sriov:
- 	ixgbe_dbg_adapter_init(adapter);
- #endif /* CONFIG_DEBUG_FS */
- 
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
-@@ -7653,6 +7709,10 @@ static void ixgbe_remove(struct pci_dev *pdev)
- 	struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
- 	struct net_device *netdev = adapter->netdev;
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(netdev);
-+#endif /* DEV_NETMAP */
-+
- #ifdef CONFIG_DEBUG_FS
- 	ixgbe_dbg_adapter_exit(adapter);
- #endif /*CONFIG_DEBUG_FS */
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30a00--30f00 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30a00--30f00
deleted file mode 100644
index 57451d79ca7c..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30a00--30f00
+++ /dev/null
@@ -1,123 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index d30fbdd..7418c57 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -248,6 +248,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -872,6 +888,17 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	if (test_bit(__IXGBE_DOWN, &adapter->state))
- 		return true;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
-+
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IXGBE_TX_DESC(tx_ring, i);
- 	i -= tx_ring->count;
-@@ -1906,6 +1933,15 @@ static bool ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- #endif /* IXGBE_FCOE */
- 	u16 cleaned_count = ixgbe_desc_unused(rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * 	 Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	int dummy;
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &dummy))
-+		return true; /* no more interrupts */
-+#endif /* DEV_NETMAP */
-+
- 	do {
- 		union ixgbe_adv_rx_desc *rx_desc;
- 		struct sk_buff *skb;
-@@ -2905,6 +2941,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -3266,6 +3305,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
- }
- 
-@@ -4216,6 +4259,10 @@ static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 	/* enable transmits */
- 	netif_tx_start_all_queues(adapter->netdev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4463,6 +4510,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	adapter->flags2 &= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
- 			     IXGBE_FLAG2_RESET_REQUESTED);
- 	adapter->flags &= ~IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -5037,6 +5088,7 @@ static int ixgbe_open(struct net_device *netdev)
- 
- 	ixgbe_up_complete(adapter);
- 
-+
- 	return 0;
- 
- err_set_queues:
-@@ -7658,6 +7710,10 @@ skip_sriov:
- 			IXGBE_LINK_SPEED_10GB_FULL | IXGBE_LINK_SPEED_1GB_FULL,
- 			true);
- 
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30f00--99999 b/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30f00--99999
deleted file mode 100644
index 0a3c4f513ac3..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--ixgbe--30f00--99999
+++ /dev/null
@@ -1,123 +0,0 @@
-diff --git a/ixgbe/ixgbe_main.c b/ixgbe/ixgbe_main.c
-index d62e7a2..cf73571 100644
---- a/ixgbe/ixgbe_main.c
-+++ b/ixgbe/ixgbe_main.c
-@@ -417,6 +417,22 @@ static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
- 	{}
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * The #ifdef DEV_NETMAP / #endif blocks in this file are meant to
-+ * be a reference on how to implement netmap support in a driver.
-+ * Additional comments are in ixgbe_netmap_linux.h .
-+ *
-+ * The code is originally developed on FreeBSD and in the interest
-+ * of maintainability we try to limit differences between the two systems.
-+ *
-+ * <ixgbe_netmap_linux.h> contains functions for netmap support
-+ * that extend the standard driver.
-+ * It also defines DEV_NETMAP so further conditional sections use
-+ * that instead of CONFIG_NETMAP
-+ */
-+#include <ixgbe_netmap_linux.h>
-+#endif
- 
- /*
-  * ixgbe_regdump - register printout routine
-@@ -1048,6 +1064,17 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
- 	if (test_bit(__IXGBE_DOWN, &adapter->state))
- 		return true;
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * In netmap mode, all the work is done in the context
-+	 * of the client thread. Interrupt handlers only wake up
-+	 * clients, which may be sleeping on individual rings
-+	 * or on a global resource for all rings.
-+	 */
-+	if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-+		return 1; /* seems to be ignored */
-+#endif /* DEV_NETMAP */
-+
- 	tx_buffer = &tx_ring->tx_buffer_info[i];
- 	tx_desc = IXGBE_TX_DESC(tx_ring, i);
- 	i -= tx_ring->count;
-@@ -2087,6 +2114,15 @@ static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
- #endif /* IXGBE_FCOE */
- 	u16 cleaned_count = ixgbe_desc_unused(rx_ring);
- 
-+#ifdef DEV_NETMAP
-+	/*
-+	 * 	 Same as the txeof routine: only wakeup clients on intr.
-+	 */
-+	int dummy;
-+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &dummy))
-+		return true; /* no more interrupts */
-+#endif /* DEV_NETMAP */
-+
- 	while (likely(total_rx_packets < budget)) {
- 		union ixgbe_adv_rx_desc *rx_desc;
- 		struct sk_buff *skb;
-@@ -3131,6 +3167,9 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
- 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
- 	if (!wait_loop)
- 		e_err(drv, "Could not enable Tx Queue %d\n", reg_idx);
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_configure_tx_ring(adapter, reg_idx);
-+#endif /* DEV_NETMAP */
- }
- 
- static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
-@@ -3496,6 +3535,10 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
- 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
- 
- 	ixgbe_rx_desc_queue_enable(adapter, ring);
-+#ifdef DEV_NETMAP
-+	if (ixgbe_netmap_configure_rx_ring(adapter, reg_idx))
-+		return;
-+#endif /* DEV_NETMAP */
- 	ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
- }
- 
-@@ -4698,6 +4741,10 @@ static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
- 			e_crit(drv, "Fan has stopped, replace the adapter\n");
- 	}
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(adapter->netdev);
-+#endif
-+
- 	/* bring the link up in the watchdog, this could race with our first
- 	 * link up interrupt but shouldn't be a problem */
- 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -4910,6 +4957,10 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
- 
- 	ixgbe_napi_disable_all(adapter);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(netdev);
-+#endif
-+
- 	adapter->flags2 &= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT |
- 			     IXGBE_FLAG2_RESET_REQUESTED);
- 	adapter->flags &= ~IXGBE_FLAG_NEED_LINK_UPDATE;
-@@ -5503,6 +5554,7 @@ static int ixgbe_open(struct net_device *netdev)
- 
- 	ixgbe_up_complete(adapter);
- 
-+
- 	return 0;
- 
- err_set_queues:
-@@ -8310,6 +8362,10 @@ skip_sriov:
- 			IXGBE_LINK_SPEED_10GB_FULL | IXGBE_LINK_SPEED_1GB_FULL,
- 			true);
- 
-+#ifdef DEV_NETMAP
-+	ixgbe_netmap_attach(adapter);
-+#endif /* DEV_NETMAP */
-+
- 	return 0;
- 
- err_register:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--20620--20625 b/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--20620--20625
deleted file mode 100644
index 213b72cc73d3..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--20620--20625
+++ /dev/null
@@ -1,117 +0,0 @@
-diff --git a/r8169.c b/r8169.c
-index 0fe2fc9..a2c83be 100644
---- a/r8169.c
-+++ b/r8169.c
-@@ -537,6 +537,10 @@ static int rtl8169_poll(struct napi_struct *napi, int budget);
- static const unsigned int rtl8169_rx_config =
- 	(RX_FIFO_THRESH << RxCfgFIFOShift) | (RX_DMA_BURST << RxCfgDMAShift);
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_re_netmap_linux.h>
-+#endif
-+
- static void mdio_write(void __iomem *ioaddr, int reg_addr, int value)
- {
- 	int i;
-@@ -3210,6 +3214,10 @@ rtl8169_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
- 
- 	device_set_wakeup_enable(&pdev->dev, tp->features & RTL_FEATURE_WOL);
- 
-+#ifdef DEV_NETMAP
-+	re_netmap_attach(tp);
-+#endif /* DEV_NETMAP */
-+
- out:
- 	return rc;
- 
-@@ -3236,6 +3244,10 @@ static void __devexit rtl8169_remove_one(struct pci_dev *pdev)
- 
- 	unregister_netdev(dev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(dev);
-+#endif /* DEV_NETMAP */
-+
- 	/* restore original MAC address */
- 	rtl_rar_set(tp, dev->perm_addr);
- 
-@@ -3291,6 +3303,10 @@ static int rtl8169_open(struct net_device *dev)
- 
- 	napi_enable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl_hw_start(dev);
- 
- 	rtl8169_request_timer(dev);
-@@ -3993,6 +4009,11 @@ err_out:
- static void rtl8169_rx_clear(struct rtl8169_private *tp)
- {
- 	unsigned int i;
-+#ifdef DEV_NETMAP
-+	re_netmap_tx_init(tp);
-+	if (re_netmap_rx_init(tp))
-+		return;
-+#endif /* DEV_NETMAP */
- 
- 	for (i = 0; i < NUM_RX_DESC; i++) {
- 		if (tp->Rx_skbuff[i]) {
-@@ -4112,11 +4133,19 @@ static void rtl8169_wait_for_quiescence(struct net_device *dev)
- 	/* Wait for any pending NAPI task to complete */
- 	napi_disable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl8169_irq_mask_and_ack(ioaddr);
- 
- 	tp->intr_mask = 0xffff;
- 	RTL_W16(IntrMask, tp->intr_event);
- 	napi_enable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
- }
- 
- static void rtl8169_reinit_task(struct work_struct *work)
-@@ -4372,6 +4401,11 @@ static void rtl8169_tx_interrupt(struct net_device *dev,
- {
- 	unsigned int dirty_tx, tx_left;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(dev, 0))
-+		return;
-+#endif /* DEV_NETMAP */
-+
- 	dirty_tx = tp->dirty_tx;
- 	smp_rmb();
- 	tx_left = tp->cur_tx - dirty_tx;
-@@ -4468,6 +4502,11 @@ static int rtl8169_rx_interrupt(struct net_device *dev,
- 	unsigned int cur_rx, rx_left;
- 	unsigned int delta, count;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(dev, 0, &count))
-+   		return count;
-+#endif /* DEV_NETMAP */
-+
- 	cur_rx = tp->cur_rx;
- 	rx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;
- 	rx_left = min(rx_left, budget);
-@@ -4687,7 +4726,12 @@ static void rtl8169_down(struct net_device *dev)
- 
- 	napi_disable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- core_down:
-+
- 	spin_lock_irq(&tp->lock);
- 
- 	rtl8169_asic_down(ioaddr);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--20625--20626 b/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--20625--20626
deleted file mode 100644
index abdc0c8db094..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--20625--20626
+++ /dev/null
@@ -1,115 +0,0 @@
-diff --git a/r8169.c b/r8169.c
-index 53b13de..745a59d 100644
---- a/r8169.c
-+++ b/r8169.c
-@@ -535,6 +535,10 @@ static int rtl8169_poll(struct napi_struct *napi, int budget);
- static const unsigned int rtl8169_rx_config =
- 	(RX_FIFO_THRESH << RxCfgFIFOShift) | (RX_DMA_BURST << RxCfgDMAShift);
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_re_netmap_linux.h>
-+#endif
-+
- static void mdio_write(void __iomem *ioaddr, int reg_addr, int value)
- {
- 	int i;
-@@ -3229,6 +3233,10 @@ rtl8169_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	if (pci_dev_run_wake(pdev))
- 		pm_runtime_put_noidle(&pdev->dev);
- 
-+#ifdef DEV_NETMAP
-+	re_netmap_attach(tp);
-+#endif /* DEV_NETMAP */
-+
- out:
- 	return rc;
- 
-@@ -3257,6 +3265,10 @@ static void __devexit rtl8169_remove_one(struct pci_dev *pdev)
- 	if (pci_dev_run_wake(pdev))
- 		pm_runtime_get_noresume(&pdev->dev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(dev);
-+#endif /* DEV_NETMAP */
-+
- 	/* restore original MAC address */
- 	rtl_rar_set(tp, dev->perm_addr);
- 
-@@ -3303,6 +3315,10 @@ static int rtl8169_open(struct net_device *dev)
- 
- 	napi_enable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl_hw_start(dev);
- 
- 	rtl8169_request_timer(dev);
-@@ -4018,6 +4034,11 @@ static inline void rtl8169_mark_as_last_descriptor(struct RxDesc *desc)
- static int rtl8169_rx_fill(struct rtl8169_private *tp)
- {
- 	unsigned int i;
-+#ifdef DEV_NETMAP
-+	re_netmap_tx_init(tp);
-+	if (re_netmap_rx_init(tp))
-+		return 0; // success
-+#endif /* DEV_NETMAP */
- 
- 	for (i = 0; i < NUM_RX_DESC; i++) {
- 		void *data;
-@@ -4119,11 +4140,19 @@ static void rtl8169_wait_for_quiescence(struct net_device *dev)
- 	/* Wait for any pending NAPI task to complete */
- 	napi_disable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl8169_irq_mask_and_ack(ioaddr);
- 
- 	tp->intr_mask = 0xffff;
- 	RTL_W16(IntrMask, tp->intr_event);
- 	napi_enable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
- }
- 
- static void rtl8169_reinit_task(struct work_struct *work)
-@@ -4395,6 +4424,11 @@ static void rtl8169_tx_interrupt(struct net_device *dev,
- {
- 	unsigned int dirty_tx, tx_left;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(dev, 0))
-+		return;
-+#endif /* DEV_NETMAP */
-+
- 	dirty_tx = tp->dirty_tx;
- 	smp_rmb();
- 	tx_left = tp->cur_tx - dirty_tx;
-@@ -4490,6 +4524,11 @@ static int rtl8169_rx_interrupt(struct net_device *dev,
- 	unsigned int count;
- 	int polling = (budget != ~(u32)0) ? 1 : 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(dev, 0, &count))
-+   		return count;
-+#endif /* DEV_NETMAP */
-+
- 	cur_rx = tp->cur_rx;
- 	rx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;
- 	rx_left = min(rx_left, budget);
-@@ -4691,6 +4730,10 @@ static void rtl8169_down(struct net_device *dev)
- 
- 	napi_disable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	spin_lock_irq(&tp->lock);
- 
- 	rtl8169_asic_down(ioaddr);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--20626--30200 b/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--20626--30200
deleted file mode 100644
index 2eb1e3611602..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--20626--30200
+++ /dev/null
@@ -1,114 +0,0 @@
-diff --git a/r8169.c b/r8169.c
-index 7ffdb80..6bae7e6 100644
---- a/r8169.c
-+++ b/r8169.c
-@@ -590,6 +590,10 @@ static int rtl8169_poll(struct napi_struct *napi, int budget);
- static const unsigned int rtl8169_rx_config =
- 	(RX_FIFO_THRESH << RxCfgFIFOShift) | (RX_DMA_BURST << RxCfgDMAShift);
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_re_netmap_linux.h>
-+#endif
-+
- static u32 ocp_read(struct rtl8169_private *tp, u8 mask, u16 reg)
- {
- 	void __iomem *ioaddr = tp->mmio_addr;
-@@ -3207,6 +3211,10 @@ rtl8169_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	if (pci_dev_run_wake(pdev))
- 		pm_runtime_put_noidle(&pdev->dev);
- 
-+#ifdef DEV_NETMAP
-+	re_netmap_attach(tp);
-+#endif /* DEV_NETMAP */
-+
- 	netif_carrier_off(dev);
- 
- out:
-@@ -3238,6 +3246,9 @@ static void __devexit rtl8169_remove_one(struct pci_dev *pdev)
- 	cancel_delayed_work_sync(&tp->task);
- 
- 	rtl_release_firmware(tp);
-+#ifdef DEV_NETMAP
-+	netmap_detach(dev);
-+#endif /* DEV_NETMAP */
- 
- 	unregister_netdev(dev);
- 
-@@ -3291,6 +3302,10 @@ static int rtl8169_open(struct net_device *dev)
- 
- 	napi_enable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl8169_init_phy(dev, tp);
- 
- 	/*
-@@ -4074,6 +4089,11 @@ static inline void rtl8169_mark_as_last_descriptor(struct RxDesc *desc)
- static int rtl8169_rx_fill(struct rtl8169_private *tp)
- {
- 	unsigned int i;
-+#ifdef DEV_NETMAP
-+	re_netmap_tx_init(tp);
-+	if (re_netmap_rx_init(tp))
-+		return 0; // success
-+#endif /* DEV_NETMAP */
- 
- 	for (i = 0; i < NUM_RX_DESC; i++) {
- 		void *data;
-@@ -4175,11 +4195,19 @@ static void rtl8169_wait_for_quiescence(struct net_device *dev)
- 	/* Wait for any pending NAPI task to complete */
- 	napi_disable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl8169_irq_mask_and_ack(ioaddr);
- 
- 	tp->intr_mask = 0xffff;
- 	RTL_W16(IntrMask, tp->intr_event);
- 	napi_enable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
- }
- 
- static void rtl8169_reinit_task(struct work_struct *work)
-@@ -4452,6 +4480,11 @@ static void rtl8169_tx_interrupt(struct net_device *dev,
- {
- 	unsigned int dirty_tx, tx_left;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(dev, 0))
-+		return;
-+#endif /* DEV_NETMAP */
-+
- 	dirty_tx = tp->dirty_tx;
- 	smp_rmb();
- 	tx_left = tp->cur_tx - dirty_tx;
-@@ -4547,6 +4580,11 @@ static int rtl8169_rx_interrupt(struct net_device *dev,
- 	unsigned int count;
- 	int polling = (budget != ~(u32)0) ? 1 : 0;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(dev, 0, &count))
-+   		return count;
-+#endif /* DEV_NETMAP */
-+
- 	cur_rx = tp->cur_rx;
- 	rx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;
- 	rx_left = min(rx_left, budget);
-@@ -4769,6 +4807,10 @@ static void rtl8169_down(struct net_device *dev)
- 
- 	napi_disable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	spin_lock_irq(&tp->lock);
- 
- 	rtl8169_asic_down(ioaddr);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--30200--30400 b/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--30200--30400
deleted file mode 100644
index 39d301ed163f..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--30200--30400
+++ /dev/null
@@ -1,114 +0,0 @@
-diff --git a/r8169.c b/r8169.c
-index c8f47f1..a41e878 100644
---- a/r8169.c
-+++ b/r8169.c
-@@ -787,6 +787,10 @@ static void rtl_tx_performance_tweak(struct pci_dev *pdev, u16 force)
- 	}
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_re_netmap_linux.h>
-+#endif
-+
- static u32 ocp_read(struct rtl8169_private *tp, u8 mask, u16 reg)
- {
- 	void __iomem *ioaddr = tp->mmio_addr;
-@@ -4167,6 +4171,10 @@ rtl8169_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	if (pci_dev_run_wake(pdev))
- 		pm_runtime_put_noidle(&pdev->dev);
- 
-+#ifdef DEV_NETMAP
-+	re_netmap_attach(tp);
-+#endif /* DEV_NETMAP */
-+
- 	netif_carrier_off(dev);
- 
- out:
-@@ -4201,6 +4209,9 @@ static void __devexit rtl8169_remove_one(struct pci_dev *pdev)
- 	unregister_netdev(dev);
- 
- 	rtl_release_firmware(tp);
-+#ifdef DEV_NETMAP
-+	netmap_detach(dev);
-+#endif /* DEV_NETMAP */
- 
- 	if (pci_dev_run_wake(pdev))
- 		pm_runtime_get_noresume(&pdev->dev);
-@@ -4298,6 +4309,10 @@ static int rtl8169_open(struct net_device *dev)
- 
- 	napi_enable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl8169_init_phy(dev, tp);
- 
- 	rtl8169_set_features(dev, dev->features);
-@@ -5252,6 +5267,11 @@ static inline void rtl8169_mark_as_last_descriptor(struct RxDesc *desc)
- static int rtl8169_rx_fill(struct rtl8169_private *tp)
- {
- 	unsigned int i;
-+#ifdef DEV_NETMAP
-+	re_netmap_tx_init(tp);
-+	if (re_netmap_rx_init(tp))
-+		return 0; // success
-+#endif /* DEV_NETMAP */
- 
- 	for (i = 0; i < NUM_RX_DESC; i++) {
- 		void *data;
-@@ -5348,11 +5368,19 @@ static void rtl8169_wait_for_quiescence(struct net_device *dev)
- 	/* Wait for any pending NAPI task to complete */
- 	napi_disable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl8169_irq_mask_and_ack(tp);
- 
- 	tp->intr_mask = 0xffff;
- 	RTL_W16(IntrMask, tp->intr_event);
- 	napi_enable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
- }
- 
- static void rtl8169_reinit_task(struct work_struct *work)
-@@ -5627,6 +5655,11 @@ static void rtl8169_tx_interrupt(struct net_device *dev,
- {
- 	unsigned int dirty_tx, tx_left;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(dev, 0))
-+		return;
-+#endif /* DEV_NETMAP */
-+
- 	dirty_tx = tp->dirty_tx;
- 	smp_rmb();
- 	tx_left = tp->cur_tx - dirty_tx;
-@@ -5714,6 +5747,11 @@ static int rtl8169_rx_interrupt(struct net_device *dev,
- 	unsigned int cur_rx, rx_left;
- 	unsigned int count;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(dev, 0, &count))
-+   		return count;
-+#endif /* DEV_NETMAP */
-+
- 	cur_rx = tp->cur_rx;
- 	rx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;
- 	rx_left = min(rx_left, budget);
-@@ -5920,6 +5958,10 @@ static void rtl8169_down(struct net_device *dev)
- 
- 	napi_disable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	spin_lock_irq(&tp->lock);
- 
- 	rtl8169_hw_reset(tp);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--30400--30500 b/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--30400--30500
deleted file mode 100644
index 3ebf32c09270..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--30400--30500
+++ /dev/null
@@ -1,165 +0,0 @@
-diff --git a/r8169.c b/r8169.c
-index ce6b44d..3412510 100644
---- a/r8169.c
-+++ b/r8169.c
-@@ -796,6 +796,10 @@ static void rtl_tx_performance_tweak(struct pci_dev *pdev, u16 force)
- 	}
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_re_netmap_linux.h>
-+#endif
-+
- static u32 ocp_read(struct rtl8169_private *tp, u8 mask, u16 reg)
- {
- 	void __iomem *ioaddr = tp->mmio_addr;
-@@ -4924,6 +4928,11 @@ static inline void rtl8169_mark_as_last_descriptor(struct RxDesc *desc)
- static int rtl8169_rx_fill(struct rtl8169_private *tp)
- {
- 	unsigned int i;
-+#ifdef DEV_NETMAP
-+	re_netmap_tx_init(tp);
-+	if (re_netmap_rx_init(tp))
-+		return 0; // success
-+#endif /* DEV_NETMAP */
- 
- 	for (i = 0; i < NUM_RX_DESC; i++) {
- 		void *data;
-@@ -5009,6 +5018,11 @@ static void rtl_reset_work(struct rtl8169_private *tp)
- 	int i;
- 
- 	napi_disable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	netif_stop_queue(dev);
- 	synchronize_sched();
- 
-@@ -5021,6 +5035,11 @@ static void rtl_reset_work(struct rtl8169_private *tp)
- 	rtl8169_init_ring_indexes(tp);
- 
- 	napi_enable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl_hw_start(dev);
- 	netif_wake_queue(dev);
- 	rtl8169_check_link_status(dev, tp, tp->mmio_addr);
-@@ -5264,6 +5283,12 @@ static void rtl_tx(struct net_device *dev, struct rtl8169_private *tp)
- 	unsigned int dirty_tx, tx_left;
- 	struct rtl_txc txc = { 0, 0 };
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(dev, 0))
-+		return;
-+#endif /* DEV_NETMAP */
-+
-+
- 	dirty_tx = tp->dirty_tx;
- 	smp_rmb();
- 	tx_left = tp->cur_tx - dirty_tx;
-@@ -5367,6 +5392,12 @@ static int rtl_rx(struct net_device *dev, struct rtl8169_private *tp, u32 budget
- 	unsigned int cur_rx, rx_left;
- 	unsigned int count;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(dev, 0, &count))
-+   		return count;
-+#endif /* DEV_NETMAP */
-+
-+
- 	cur_rx = tp->cur_rx;
- 	rx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;
- 	rx_left = min(rx_left, budget);
-@@ -5511,9 +5542,19 @@ static void rtl_slow_event_work(struct rtl8169_private *tp)
- 		__rtl8169_check_link_status(dev, tp, tp->mmio_addr, true);
- 
- 	napi_disable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl_irq_disable(tp);
- 
- 	napi_enable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	napi_schedule(&tp->napi);
- }
- 
-@@ -5603,6 +5644,11 @@ static void rtl8169_down(struct net_device *dev)
- 	del_timer_sync(&tp->timer);
- 
- 	napi_disable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	netif_stop_queue(dev);
- 
- 	rtl8169_hw_reset(tp);
-@@ -5707,6 +5753,10 @@ static int rtl_open(struct net_device *dev)
- 
- 	napi_enable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl8169_init_phy(dev, tp);
- 
- 	__rtl8169_set_features(dev, dev->features);
-@@ -5788,6 +5838,11 @@ static void rtl8169_net_suspend(struct net_device *dev)
- 
- 	rtl_lock_work(tp);
- 	napi_disable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	clear_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags);
- 	rtl_unlock_work(tp);
- 
-@@ -5816,6 +5871,11 @@ static void __rtl8169_resume(struct net_device *dev)
- 
- 	rtl_lock_work(tp);
- 	napi_enable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	set_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags);
- 	rtl_unlock_work(tp);
- 
-@@ -5970,6 +6030,10 @@ static void __devexit rtl_remove_one(struct pci_dev *pdev)
- 
- 	rtl_release_firmware(tp);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(dev);
-+#endif /* DEV_NETMAP */
-+
- 	if (pci_dev_run_wake(pdev))
- 		pm_runtime_get_noresume(&pdev->dev);
- 
-@@ -6282,6 +6346,9 @@ rtl_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	if (pci_dev_run_wake(pdev))
- 		pm_runtime_put_noidle(&pdev->dev);
- 
-+#ifdef DEV_NETMAP
-+	re_netmap_attach(tp);
-+#endif /* DEV_NETMAP */
- 	netif_carrier_off(dev);
- 
- out:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--30500--99999 b/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--30500--99999
deleted file mode 100644
index 5e6a1753e0fd..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--r8169.c--30500--99999
+++ /dev/null
@@ -1,145 +0,0 @@
-diff --git a/r8169.c b/r8169.c
-index d7a04e0..d711b9d 100644
---- a/r8169.c
-+++ b/r8169.c
-@@ -818,6 +818,10 @@ static void rtl_tx_performance_tweak(struct pci_dev *pdev, u16 force)
- 	}
- }
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <if_re_netmap_linux.h>
-+#endif
-+
- static u32 ocp_read(struct rtl8169_private *tp, u8 mask, u16 reg)
- {
- 	void __iomem *ioaddr = tp->mmio_addr;
-@@ -5304,6 +5308,11 @@ static inline void rtl8169_mark_as_last_descriptor(struct RxDesc *desc)
- static int rtl8169_rx_fill(struct rtl8169_private *tp)
- {
- 	unsigned int i;
-+#ifdef DEV_NETMAP
-+	re_netmap_tx_init(tp);
-+	if (re_netmap_rx_init(tp))
-+		return 0; // success
-+#endif /* DEV_NETMAP */
- 
- 	for (i = 0; i < NUM_RX_DESC; i++) {
- 		void *data;
-@@ -5389,6 +5398,11 @@ static void rtl_reset_work(struct rtl8169_private *tp)
- 	int i;
- 
- 	napi_disable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	netif_stop_queue(dev);
- 	synchronize_sched();
- 
-@@ -5401,6 +5415,11 @@ static void rtl_reset_work(struct rtl8169_private *tp)
- 	rtl8169_init_ring_indexes(tp);
- 
- 	napi_enable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl_hw_start(dev);
- 	netif_wake_queue(dev);
- 	rtl8169_check_link_status(dev, tp, tp->mmio_addr);
-@@ -5644,6 +5663,12 @@ static void rtl_tx(struct net_device *dev, struct rtl8169_private *tp)
- 	unsigned int dirty_tx, tx_left;
- 	struct rtl_txc txc = { 0, 0 };
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(dev, 0))
-+		return;
-+#endif /* DEV_NETMAP */
-+
-+
- 	dirty_tx = tp->dirty_tx;
- 	smp_rmb();
- 	tx_left = tp->cur_tx - dirty_tx;
-@@ -5747,6 +5772,12 @@ static int rtl_rx(struct net_device *dev, struct rtl8169_private *tp, u32 budget
- 	unsigned int cur_rx, rx_left;
- 	unsigned int count;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(dev, 0, &count))
-+   		return count;
-+#endif /* DEV_NETMAP */
-+
-+
- 	cur_rx = tp->cur_rx;
- 	rx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;
- 	rx_left = min(rx_left, budget);
-@@ -5979,6 +6010,11 @@ static void rtl8169_down(struct net_device *dev)
- 	del_timer_sync(&tp->timer);
- 
- 	napi_disable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	netif_stop_queue(dev);
- 
- 	rtl8169_hw_reset(tp);
-@@ -6083,6 +6119,10 @@ static int rtl_open(struct net_device *dev)
- 
- 	napi_enable(&tp->napi);
- 
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	rtl8169_init_phy(dev, tp);
- 
- 	__rtl8169_set_features(dev, dev->features);
-@@ -6164,6 +6204,11 @@ static void rtl8169_net_suspend(struct net_device *dev)
- 
- 	rtl_lock_work(tp);
- 	napi_disable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	clear_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags);
- 	rtl_unlock_work(tp);
- 
-@@ -6192,6 +6237,11 @@ static void __rtl8169_resume(struct net_device *dev)
- 
- 	rtl_lock_work(tp);
- 	napi_enable(&tp->napi);
-+
-+#ifdef DEV_NETMAP
-+	netmap_enable_all_rings(dev);
-+#endif /* DEV_NETMAP */
-+
- 	set_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags);
- 	rtl_unlock_work(tp);
- 
-@@ -6348,6 +6398,10 @@ static void __devexit rtl_remove_one(struct pci_dev *pdev)
- 
- 	rtl_release_firmware(tp);
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(dev);
-+#endif /* DEV_NETMAP */
-+
- 	if (pci_dev_run_wake(pdev))
- 		pm_runtime_get_noresume(&pdev->dev);
- 
-@@ -6661,6 +6715,9 @@ rtl_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
- 	if (pci_dev_run_wake(pdev))
- 		pm_runtime_put_noidle(&pdev->dev);
- 
-+#ifdef DEV_NETMAP
-+	re_netmap_attach(tp);
-+#endif /* DEV_NETMAP */
- 	netif_carrier_off(dev);
- 
- out:
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--20622--20625 b/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--20622--20625
deleted file mode 100644
index 7877f2a7f51e..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--20622--20625
+++ /dev/null
@@ -1,85 +0,0 @@
-diff --git a/virtio_net.c b/virtio_net.c
-index b0577dd..6516934 100644
---- a/virtio_net.c
-+++ b/virtio_net.c
-@@ -64,6 +64,10 @@ struct virtnet_info
- 	struct page *pages;
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <virtio_netmap.h>
-+#endif
-+
- struct skb_vnet_hdr {
- 	union {
- 		struct virtio_net_hdr hdr;
-@@ -121,6 +125,10 @@ static void skb_xmit_done(struct virtqueue *svq)
- 	/* Suppress further interrupts. */
- 	svq->vq_ops->disable_cb(svq);
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(vi->dev, 0))
-+		return;
-+#endif
- 	/* We were probably waiting for more output buffers. */
- 	netif_wake_queue(vi->dev);
- }
-@@ -470,7 +478,16 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
- 	struct virtnet_info *vi = container_of(napi, struct virtnet_info, napi);
- 	void *buf;
- 	unsigned int len, received = 0;
-+#ifdef DEV_NETMAP
-+	int work_done = 0;
- 
-+	if (netmap_rx_irq(vi->dev, 0, &work_done)) {
-+		napi_complete(napi);
-+		ND("called netmap_rx_irq");
-+
-+		return 1;
-+	}
-+#endif
- again:
- 	while (received < budget &&
- 	       (buf = vi->rvq->vq_ops->get_buf(vi->rvq, &len)) != NULL) {
-@@ -638,6 +655,10 @@ static int virtnet_open(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 
-+#ifdef DEV_NETMAP
-+	virtio_netmap_init_buffers(vi);
-+	netmap_enable_all_rings(dev);
-+#endif
- 	napi_enable(&vi->napi);
- 
- 	/* If all buffers were filled by other side before we napi_enabled, we
-@@ -700,6 +721,9 @@ static int virtnet_close(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif
- 	napi_disable(&vi->napi);
- 
- 	return 0;
-@@ -985,6 +1009,10 @@ static int virtnet_probe(struct virtio_device *vdev)
- 		goto unregister;
- 	}
- 
-+#ifdef DEV_NETMAP
-+	virtio_netmap_attach(vi);
-+#endif
-+
- 	vi->status = VIRTIO_NET_S_LINK_UP;
- 	virtnet_update_status(vi);
- 	netif_carrier_on(dev);
-@@ -1028,6 +1056,9 @@ static void __devexit virtnet_remove(struct virtio_device *vdev)
- {
- 	struct virtnet_info *vi = vdev->priv;
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(vi->dev);
-+#endif
- 	/* Stop all the virtqueues. */
- 	vdev->config->reset(vdev);
- 
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--20625--20626 b/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--20625--20626
deleted file mode 100644
index 5ad382fabe99..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--20625--20626
+++ /dev/null
@@ -1,85 +0,0 @@
-diff --git a/virtio_net.c b/virtio_net.c
-index b6d4028..a9be38d 100644
---- a/virtio_net.c
-+++ b/virtio_net.c
-@@ -67,6 +67,10 @@ struct virtnet_info {
- 	struct scatterlist tx_sg[MAX_SKB_FRAGS + 2];
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <virtio_netmap.h>
-+#endif
-+
- struct skb_vnet_hdr {
- 	union {
- 		struct virtio_net_hdr hdr;
-@@ -124,6 +128,10 @@ static void skb_xmit_done(struct virtqueue *svq)
- 	/* Suppress further interrupts. */
- 	virtqueue_disable_cb(svq);
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(vi->dev, 0))
-+		return;
-+#endif
- 	/* We were probably waiting for more output buffers. */
- 	netif_wake_queue(vi->dev);
- }
-@@ -467,7 +475,16 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
- 	struct virtnet_info *vi = container_of(napi, struct virtnet_info, napi);
- 	void *buf;
- 	unsigned int len, received = 0;
-+#ifdef DEV_NETMAP
-+	int work_done = 0;
- 
-+	if (netmap_rx_irq(vi->dev, 0, &work_done)) {
-+		napi_complete(napi);
-+		ND("called netmap_rx_irq");
-+
-+		return 1;
-+	}
-+#endif
- again:
- 	while (received < budget &&
- 	       (buf = virtqueue_get_buf(vi->rvq, &len)) != NULL) {
-@@ -638,6 +655,10 @@ static int virtnet_open(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 
-+#ifdef DEV_NETMAP
-+	virtio_netmap_init_buffers(vi);
-+	netmap_enable_all_rings(dev);
-+#endif
- 	napi_enable(&vi->napi);
- 
- 	/* If all buffers were filled by other side before we napi_enabled, we
-@@ -700,6 +721,9 @@ static int virtnet_close(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif
- 	napi_disable(&vi->napi);
- 
- 	return 0;
-@@ -986,6 +1010,10 @@ static int virtnet_probe(struct virtio_device *vdev)
- 		goto unregister;
- 	}
- 
-+#ifdef DEV_NETMAP
-+	virtio_netmap_attach(vi);
-+#endif
-+
- 	/* Assume link up if device can't report link status,
- 	   otherwise get link status from config. */
- 	if (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {
-@@ -1035,6 +1063,9 @@ static void __devexit virtnet_remove(struct virtio_device *vdev)
- {
- 	struct virtnet_info *vi = vdev->priv;
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(vi->dev);
-+#endif
- 	/* Stop all the virtqueues. */
- 	vdev->config->reset(vdev);
- 
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--20626--30300 b/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--20626--30300
deleted file mode 100644
index 758540085b99..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--20626--30300
+++ /dev/null
@@ -1,85 +0,0 @@
-diff --git a/virtio_net.c b/virtio_net.c
-index 82dba5a..f217797 100644
---- a/virtio_net.c
-+++ b/virtio_net.c
-@@ -67,6 +67,10 @@ struct virtnet_info {
- 	struct scatterlist tx_sg[MAX_SKB_FRAGS + 2];
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <virtio_netmap.h>
-+#endif
-+
- struct skb_vnet_hdr {
- 	union {
- 		struct virtio_net_hdr hdr;
-@@ -124,6 +128,10 @@ static void skb_xmit_done(struct virtqueue *svq)
- 	/* Suppress further interrupts. */
- 	virtqueue_disable_cb(svq);
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(vi->dev, 0))
-+		return;
-+#endif
- 	/* We were probably waiting for more output buffers. */
- 	netif_wake_queue(vi->dev);
- }
-@@ -481,7 +489,16 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
- 	struct virtnet_info *vi = container_of(napi, struct virtnet_info, napi);
- 	void *buf;
- 	unsigned int len, received = 0;
-+#ifdef DEV_NETMAP
-+	int work_done = 0;
- 
-+	if (netmap_rx_irq(vi->dev, 0, &work_done)) {
-+		napi_complete(napi);
-+		ND("called netmap_rx_irq");
-+
-+		return 1;
-+	}
-+#endif
- again:
- 	while (received < budget &&
- 	       (buf = virtqueue_get_buf(vi->rvq, &len)) != NULL) {
-@@ -652,6 +669,10 @@ static int virtnet_open(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 
-+#ifdef DEV_NETMAP
-+	virtio_netmap_init_buffers(vi);
-+	netmap_enable_all_rings(dev);
-+#endif
- 	virtnet_napi_enable(vi);
- 	return 0;
- }
-@@ -705,6 +726,9 @@ static int virtnet_close(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif
- 	napi_disable(&vi->napi);
- 
- 	return 0;
-@@ -991,6 +1015,10 @@ static int virtnet_probe(struct virtio_device *vdev)
- 		goto unregister;
- 	}
- 
-+#ifdef DEV_NETMAP
-+	virtio_netmap_attach(vi);
-+#endif
-+
- 	/* Assume link up if device can't report link status,
- 	   otherwise get link status from config. */
- 	if (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {
-@@ -1040,6 +1068,9 @@ static void __devexit virtnet_remove(struct virtio_device *vdev)
- {
- 	struct virtnet_info *vi = vdev->priv;
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(vi->dev);
-+#endif
- 	/* Stop all the virtqueues. */
- 	vdev->config->reset(vdev);
- 
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30300--30500 b/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30300--30500
deleted file mode 100644
index bbad3864f03c..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30300--30500
+++ /dev/null
@@ -1,90 +0,0 @@
-diff --git a/virtio_net.c b/virtio_net.c
-index 4880aa8..6329c3a 100644
---- a/virtio_net.c
-+++ b/virtio_net.c
-@@ -80,6 +80,10 @@ struct virtnet_info {
- 	struct scatterlist tx_sg[MAX_SKB_FRAGS + 2];
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <virtio_netmap.h>
-+#endif
-+
- struct skb_vnet_hdr {
- 	union {
- 		struct virtio_net_hdr hdr;
-@@ -137,6 +141,10 @@ static void skb_xmit_done(struct virtqueue *svq)
- 	/* Suppress further interrupts. */
- 	virtqueue_disable_cb(svq);
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(vi->dev, 0))
-+		return;
-+#endif
- 	/* We were probably waiting for more output buffers. */
- 	netif_wake_queue(vi->dev);
- }
-@@ -517,7 +525,16 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
- 	struct virtnet_info *vi = container_of(napi, struct virtnet_info, napi);
- 	void *buf;
- 	unsigned int len, received = 0;
-+#ifdef DEV_NETMAP
-+	int work_done = 0;
- 
-+	if (netmap_rx_irq(vi->dev, 0, &work_done)) {
-+		napi_complete(napi);
-+		ND("called netmap_rx_irq");
-+
-+		return 1;
-+	}
-+#endif
- again:
- 	while (received < budget &&
- 	       (buf = virtqueue_get_buf(vi->rvq, &len)) != NULL) {
-@@ -727,7 +744,15 @@ static void virtnet_netpoll(struct net_device *dev)
- static int virtnet_open(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
-+#ifdef DEV_NETMAP
-+	int ok = virtio_netmap_init_buffers(vi);
- 
-+	netmap_enable_all_rings(dev);
-+	if (ok) {
-+		virtnet_napi_enable(vi);
-+		return 0;
-+	}
-+#endif
- 	/* Make sure we have some buffers: if oom use wq. */
- 	if (!try_fill_recv(vi, GFP_KERNEL))
- 		queue_delayed_work(system_nrt_wq, &vi->refill, 0);
-@@ -785,6 +810,9 @@ static int virtnet_close(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif
- 	/* Make sure refill_work doesn't re-enable napi! */
- 	cancel_delayed_work_sync(&vi->refill);
- 	napi_disable(&vi->napi);
-@@ -1107,6 +1135,10 @@ static int virtnet_probe(struct virtio_device *vdev)
- 		goto unregister;
- 	}
- 
-+#ifdef DEV_NETMAP
-+	virtio_netmap_attach(vi);
-+#endif
-+
- 	/* Assume link up if device can't report link status,
- 	   otherwise get link status from config. */
- 	if (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {
-@@ -1170,6 +1202,9 @@ static void __devexit virtnet_remove(struct virtio_device *vdev)
- {
- 	struct virtnet_info *vi = vdev->priv;
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(vi->dev);
-+#endif
- 	unregister_netdev(vi->dev);
- 
- 	remove_vq_common(vi);
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30500--30800 b/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30500--30800
deleted file mode 100644
index 821a5039d163..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30500--30800
+++ /dev/null
@@ -1,90 +0,0 @@
-diff --git a/virtio_net.c b/virtio_net.c
-index f18149a..95e1580 100644
---- a/virtio_net.c
-+++ b/virtio_net.c
-@@ -90,6 +90,10 @@ struct virtnet_info {
- 	struct scatterlist tx_sg[MAX_SKB_FRAGS + 2];
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <virtio_netmap.h>
-+#endif
-+
- struct skb_vnet_hdr {
- 	union {
- 		struct virtio_net_hdr hdr;
-@@ -147,6 +151,10 @@ static void skb_xmit_done(struct virtqueue *svq)
- 	/* Suppress further interrupts. */
- 	virtqueue_disable_cb(svq);
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_tx_irq(vi->dev, 0))
-+		return;
-+#endif
- 	/* We were probably waiting for more output buffers. */
- 	netif_wake_queue(vi->dev);
- }
-@@ -529,7 +537,16 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
- 	struct virtnet_info *vi = container_of(napi, struct virtnet_info, napi);
- 	void *buf;
- 	unsigned int len, received = 0;
-+#ifdef DEV_NETMAP
-+	int work_done = 0;
- 
-+	if (netmap_rx_irq(vi->dev, 0, &work_done)) {
-+		napi_complete(napi);
-+		ND("called netmap_rx_irq");
-+
-+		return 1;
-+	}
-+#endif
- again:
- 	while (received < budget &&
- 	       (buf = virtqueue_get_buf(vi->rvq, &len)) != NULL) {
-@@ -742,6 +759,15 @@ static void virtnet_netpoll(struct net_device *dev)
- static int virtnet_open(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
-+#ifdef DEV_NETMAP
-+	int ok = virtio_netmap_init_buffers(vi);
-+
-+	netmap_enable_all_rings(dev);
-+	if (ok) {
-+		virtnet_napi_enable(vi);
-+		return 0;
-+	}
-+#endif
- 
- 	/* Make sure we have some buffers: if oom use wq. */
- 	if (!try_fill_recv(vi, GFP_KERNEL))
-@@ -810,6 +836,9 @@ static int virtnet_close(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 
-+#ifdef DEV_NETMAP
-+	netmap_disable_all_rings(dev);
-+#endif
- 	/* Make sure refill_work doesn't re-enable napi! */
- 	cancel_delayed_work_sync(&vi->refill);
- 	napi_disable(&vi->napi);
-@@ -1148,6 +1177,10 @@ static int virtnet_probe(struct virtio_device *vdev)
- 		goto unregister;
- 	}
- 
-+#ifdef DEV_NETMAP
-+	virtio_netmap_attach(vi);
-+#endif
-+
- 	/* Assume link up if device can't report link status,
- 	   otherwise get link status from config. */
- 	if (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {
-@@ -1211,6 +1244,9 @@ static void __devexit virtnet_remove(struct virtio_device *vdev)
- {
- 	struct virtnet_info *vi = vdev->priv;
- 
-+#ifdef DEV_NETMAP
-+	netmap_detach(vi->dev);
-+#endif
- 	/* Prevent config work handler from accessing the device. */
- 	mutex_lock(&vi->config_lock);
- 	vi->config_enable = false;
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30800--30b00 b/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30800--30b00
deleted file mode 100644
index c896f5df9f72..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30800--30b00
+++ /dev/null
@@ -1,91 +0,0 @@
-diff --git a/virtio_net.c b/virtio_net.c
-index 35c00c5..8aaaa7e 100644
---- a/virtio_net.c
-+++ b/virtio_net.c
-@@ -132,6 +132,10 @@ struct virtnet_info {
- 	struct notifier_block nb;
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <virtio_netmap.h>
-+#endif
-+
- struct skb_vnet_hdr {
- 	union {
- 		struct virtio_net_hdr hdr;
-@@ -211,6 +215,10 @@ static void skb_xmit_done(struct virtqueue *vq)
- 	/* Suppress further interrupts. */
- 	virtqueue_disable_cb(vq);
- 
-+#ifdef DEV_NETMAP
-+        if (netmap_tx_irq(vi->dev, vq2txq(vq)))
-+		return;
-+#endif
- 	/* We were probably waiting for more output buffers. */
- 	netif_wake_subqueue(vi->dev, vq2txq(vq));
- }
-@@ -603,7 +611,16 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
- 	struct virtnet_info *vi = rq->vq->vdev->priv;
- 	void *buf;
- 	unsigned int len, received = 0;
-+#ifdef DEV_NETMAP
-+        int work_done = 0;
- 
-+        if (netmap_rx_irq(vi->dev, vq2rxq(rq->vq), &work_done)) {
-+		napi_complete(napi);
-+		ND("called netmap_rx_irq");
-+
-+                return 1;
-+        }
-+#endif
- again:
- 	while (received < budget &&
- 	       (buf = virtqueue_get_buf(rq->vq, &len)) != NULL) {
-@@ -635,6 +652,16 @@ static int virtnet_open(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 	int i;
-+#ifdef DEV_NETMAP
-+        int ok = virtio_netmap_init_buffers(vi);
-+
-+        netmap_enable_all_rings(dev);
-+        if (ok) {
-+            for (i = 0; i < vi->max_queue_pairs; i++)
-+		virtnet_napi_enable(&vi->rq[i]);
-+            return 0;
-+        }
-+#endif
- 
- 	for (i = 0; i < vi->max_queue_pairs; i++) {
- 		/* Make sure we have some buffers: if oom use wq. */
-@@ -909,6 +936,9 @@ static int virtnet_close(struct net_device *dev)
- 	struct virtnet_info *vi = netdev_priv(dev);
- 	int i;
- 
-+#ifdef DEV_NETMAP
-+        netmap_disable_all_rings(dev);
-+#endif
- 	/* Make sure refill_work doesn't re-enable napi! */
- 	cancel_delayed_work_sync(&vi->refill);
- 
-@@ -1572,6 +1602,10 @@ static int virtnet_probe(struct virtio_device *vdev)
- 		goto free_recv_bufs;
- 	}
- 
-+#ifdef DEV_NETMAP
-+        virtio_netmap_attach(vi);
-+#endif
-+
- 	/* Assume link up if device can't report link status,
- 	   otherwise get link status from config. */
- 	if (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {
-@@ -1618,6 +1652,9 @@ static void virtnet_remove(struct virtio_device *vdev)
- {
- 	struct virtnet_info *vi = vdev->priv;
- 
-+#ifdef DEV_NETMAP
-+        netmap_detach(vi->dev);
-+#endif
- 	unregister_hotcpu_notifier(&vi->nb);
- 
- 	/* Prevent config work handler from accessing the device. */
diff --git a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30b00--99999 b/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30b00--99999
deleted file mode 100644
index f9f0fef4ebab..000000000000
--- a/drivers/staging/netmap/LINUX/final-patches/diff--virtio_net.c--30b00--99999
+++ /dev/null
@@ -1,91 +0,0 @@
-diff --git a/virtio_net.c b/virtio_net.c
-index 3d2a90a..ae899a4 100644
---- a/virtio_net.c
-+++ b/virtio_net.c
-@@ -131,6 +131,10 @@ struct virtnet_info {
- 	struct notifier_block nb;
- };
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <virtio_netmap.h>
-+#endif
-+
- struct skb_vnet_hdr {
- 	union {
- 		struct virtio_net_hdr hdr;
-@@ -210,6 +214,10 @@ static void skb_xmit_done(struct virtqueue *vq)
- 	/* Suppress further interrupts. */
- 	virtqueue_disable_cb(vq);
- 
-+#ifdef DEV_NETMAP
-+        if (netmap_tx_irq(vi->dev, vq2txq(vq)))
-+		return;
-+#endif
- 	/* We were probably waiting for more output buffers. */
- 	netif_wake_subqueue(vi->dev, vq2txq(vq));
- }
-@@ -603,7 +611,16 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
- 	struct virtnet_info *vi = rq->vq->vdev->priv;
- 	void *buf;
- 	unsigned int r, len, received = 0;
-+#ifdef DEV_NETMAP
-+        int work_done = 0;
- 
-+        if (netmap_rx_irq(vi->dev, vq2rxq(rq->vq), &work_done)) {
-+		napi_complete(napi);
-+		ND("called netmap_rx_irq");
-+
-+                return 1;
-+        }
-+#endif
- again:
- 	while (received < budget &&
- 	       (buf = virtqueue_get_buf(rq->vq, &len)) != NULL) {
-@@ -636,6 +653,16 @@ static int virtnet_open(struct net_device *dev)
- {
- 	struct virtnet_info *vi = netdev_priv(dev);
- 	int i;
-+#ifdef DEV_NETMAP
-+        int ok = virtio_netmap_init_buffers(vi);
-+
-+        netmap_enable_all_rings(dev);
-+        if (ok) {
-+            for (i = 0; i < vi->max_queue_pairs; i++)
-+		virtnet_napi_enable(&vi->rq[i]);
-+            return 0;
-+        }
-+#endif
- 
- 	for (i = 0; i < vi->max_queue_pairs; i++) {
- 		if (i < vi->curr_queue_pairs)
-@@ -927,6 +954,9 @@ static int virtnet_close(struct net_device *dev)
- 	struct virtnet_info *vi = netdev_priv(dev);
- 	int i;
- 
-+#ifdef DEV_NETMAP
-+        netmap_disable_all_rings(dev);
-+#endif
- 	/* Make sure refill_work doesn't re-enable napi! */
- 	cancel_delayed_work_sync(&vi->refill);
- 
-@@ -1592,6 +1622,10 @@ static int virtnet_probe(struct virtio_device *vdev)
- 		goto free_recv_bufs;
- 	}
- 
-+#ifdef DEV_NETMAP
-+        virtio_netmap_attach(vi);
-+#endif
-+
- 	/* Assume link up if device can't report link status,
- 	   otherwise get link status from config. */
- 	if (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {
-@@ -1638,6 +1672,9 @@ static void virtnet_remove(struct virtio_device *vdev)
- {
- 	struct virtnet_info *vi = vdev->priv;
- 
-+#ifdef DEV_NETMAP
-+        netmap_detach(vi->dev);
-+#endif
- 	unregister_hotcpu_notifier(&vi->nb);
- 
- 	/* Prevent config work handler from accessing the device. */
diff --git a/drivers/staging/netmap/LINUX/wip-patches/diff--mellanox--30300--30800 b/drivers/staging/netmap/LINUX/wip-patches/diff--mellanox--30300--30800
deleted file mode 100644
index 9cb61aa5dd0d..000000000000
--- a/drivers/staging/netmap/LINUX/wip-patches/diff--mellanox--30300--30800
+++ /dev/null
@@ -1,145 +0,0 @@
-diff -urp --exclude '*.o' --exclude '*.cmd' --exclude '*mod.c' drivers/net/ethernet/mellanox/mlx4/en_netdev.c ./mellanox/mlx4/en_netdev.c
---- drivers/net/ethernet/mellanox/mlx4/en_netdev.c	2012-09-11 20:50:55.982624673 -0700
-+++ ./mellanox/mlx4/en_netdev.c	2012-09-27 00:05:22.703523430 -0700
-@@ -48,6 +48,39 @@
- #include "mlx4_en.h"
- #include "en_port.h"
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * This driver is split in multiple small files.
-+ * The main device descriptor has type struct mlx4_en_priv *priv;
-+ * and we attach to the device in mlx4_en_init_netdev()
-+ * (do port numbers start from 1 ?)
-+ *
-+ * The reconfig routine is in mlx4_en_start_port() (also here)
-+ * which is called on a mlx4_en_restart() (watchdog), open and set-mtu.
-+ *
-+ *	priv->num_frags				??
-+ *	DS_SIZE					??
-+ *		apparently each rx desc is followed by frag.descriptors
-+ *		and the rx desc is rounded up to a power of 2.
-+ *
-+ *   Receive code is in en_rx.c
-+ *	priv->rx_ring_num			number of rx rings
-+ *	rxr = prov->rx_ring[ring_ind]		rx ring descriptor
-+ *	rxr->size				number of slots
-+ *	rxr->prod				producer
-+ *	   probably written into a mmio reg at *rxr->wqres.db.db
-+ *	   trimmed to 16 bits.
-+ *
-+ *	Rx init routine:
-+ *		mlx4_en_activate_rx_rings()
-+ *		  mlx4_en_init_rx_desc()
-+ *   Transmit code is in en_tx.c
-+ */
-+
-+#define NETMAP_MLX4_MAIN
-+#include <mlx4_netmap_linux.h>        /* extern stuff */
-+#endif /* CONFIG_NETMAP */
-+
- int mlx4_en_setup_tc(struct net_device *dev, u8 up)
- {
- 	if (up != MLX4_EN_NUM_UP)
-@@ -1042,6 +1075,9 @@ int mlx4_en_start_port(struct net_device
- 		/* Set initial ownership of all Tx TXBBs to SW (1) */
- 		for (j = 0; j < tx_ring->buf_size; j += STAMP_STRIDE)
- 			*((u32 *) (tx_ring->buf + j)) = 0xffffffff;
-+#ifdef DEV_NETMAP
-+		mlx4_netmap_tx_config(priv, i);
-+#endif /* DEV_NETMAP */
- 		++tx_index;
- 	}
- 
-@@ -1639,6 +1675,9 @@ int mlx4_en_init_netdev(struct mlx4_en_d
- 	en_warn(priv, "Using %d RX rings\n", prof->rx_ring_num);
- 
- 	queue_delayed_work(mdev->workqueue, &priv->stats_task, STATS_DELAY);
-+#ifdef DEV_NETMAP
-+	mlx4_netmap_attach(priv);
-+#endif /* DEV_NETMAP */
- 	return 0;
- 
- out:
---- drivers/net/ethernet/mellanox/mlx4/en_rx.c	2012-09-11 20:50:55.982624673 -0700
-+++ ./mellanox/mlx4/en_rx.c	2012-09-27 00:13:16.099550954 -0700
-@@ -41,6 +41,9 @@
- 
- #include "mlx4_en.h"
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <mlx4_netmap_linux.h>
-+#endif /* !DEV_NETMAP */
- 
- static int mlx4_en_alloc_frag(struct mlx4_en_priv *priv,
- 			      struct mlx4_en_rx_desc *rx_desc,
-@@ -365,9 +368,16 @@ int mlx4_en_activate_rx_rings(struct mlx
- 		ring = &priv->rx_ring[ring_ind];
- 
- 		ring->size_mask = ring->actual_size - 1;
-+#ifdef DEV_NETMAP
-+		if (nm_native_on(NA(priv->dev))) {
-+			int saved_cons = ring->cons;
-+			mlx4_en_free_rx_buf(priv, ring);
-+			ring->cons = saved_cons;
-+			mlx4_netmap_rx_config(priv, ring_ind);
-+		}
-+#endif /* DEV_NETMAP */
- 		mlx4_en_update_rx_prod_db(ring);
- 	}
--
- 	return 0;
- 
- err_buffers:
-@@ -402,6 +412,11 @@ void mlx4_en_destroy_rx_ring(struct mlx4
- void mlx4_en_deactivate_rx_ring(struct mlx4_en_priv *priv,
- 				struct mlx4_en_rx_ring *ring)
- {
-+#ifdef DEV_NETMAP
-+	if (nm_native_on(NA(priv->dev)))
-+		ND("netmap mode, rx buf already freed");
-+	else
-+#endif /* DEV_NETMAP */
- 	mlx4_en_free_rx_buf(priv, ring);
- 	if (ring->stride <= TXBB_SIZE)
- 		ring->buf -= TXBB_SIZE;
-@@ -718,6 +739,11 @@ int mlx4_en_poll_rx_cq(struct napi_struc
- 	struct mlx4_en_priv *priv = netdev_priv(dev);
- 	int done;
- 
-+#ifdef DEV_NETMAP
-+	if (netmap_rx_irq(cq->dev, cq->ring, &done)) {
-+		ND("rx_irq %d for netmap, budget %d done %d", cq->ring, budget, done);
-+	} else
-+#endif /* DEV_NETMAP */
- 	done = mlx4_en_process_rx_cq(dev, cq, budget);
- 
- 	/* If we used up all the quota - we're probably not done yet... */
---- drivers/net/ethernet/mellanox/mlx4/en_tx.c	2012-09-11 20:50:55.982624673 -0700
-+++ ./mellanox/mlx4/en_tx.c	2012-09-27 00:05:22.713523348 -0700
-@@ -55,6 +55,10 @@ MODULE_PARM_DESC(inline_thold, "threshol
- 
- static u32 hashrnd __read_mostly;
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <mlx4_netmap_linux.h>        /* extern stuff */
-+#endif /* CONFIG_NETMAP */
-+
- int mlx4_en_create_tx_ring(struct mlx4_en_priv *priv,
- 			   struct mlx4_en_tx_ring *ring, u32 size,
- 			   u16 stride)
-@@ -396,6 +400,13 @@ void mlx4_en_tx_irq(struct mlx4_cq *mcq)
- 
- 	if (!spin_trylock(&ring->comp_lock))
- 		return;
-+#ifdef DEV_NETMAP
-+	/* XXX should be integrated with appropriate lock_wrapper manner? */
-+	if (netmap_tx_irq(cq->dev, cq->ring)) {
-+		ND(5, "wakeup queue %d", cq->ring);
-+		spin_unlock(&ring->comp_lock);
-+		return;
-+	}
-+#endif /* DEV_NETMAP */
- 	mlx4_en_process_tx_cq(cq->dev, cq);
- 	mod_timer(&cq->timer, jiffies + 1);
- 	spin_unlock(&ring->comp_lock);
diff --git a/drivers/staging/netmap/LINUX/wip-patches/diff--mlx4--20630--30200 b/drivers/staging/netmap/LINUX/wip-patches/diff--mlx4--20630--30200
deleted file mode 100644
index 86383bb8f64a..000000000000
--- a/drivers/staging/netmap/LINUX/wip-patches/diff--mlx4--20630--30200
+++ /dev/null
@@ -1,163 +0,0 @@
-diff -urp --exclude '*.o' --exclude '*.cmd' --exclude '*mod.c' drivers/net/ethernet/mellanox/mlx4/en_netdev.c ./mellanox/mlx4/en_netdev.c
---- drivers/net/ethernet/mellanox/mlx4/en_netdev.c	2012-09-11 20:50:55.982624673 -0700
-+++ ./mlx4/en_netdev.c	2012-09-27 00:05:22.703523430 -0700
-@@ -48,6 +48,39 @@
- #include "mlx4_en.h"
- #include "en_port.h"
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+/*
-+ * This driver is split in multiple small files.
-+ * The main device descriptor has type struct mlx4_en_priv *priv;
-+ * and we attach to the device in mlx4_en_init_netdev()
-+ * (do port numbers start from 1 ?)
-+ *
-+ * The reconfig routine is in mlx4_en_start_port() (also here)
-+ * which is called on a mlx4_en_restart() (watchdog), open and set-mtu.
-+ *
-+ *	priv->num_frags				??
-+ *	DS_SIZE					??
-+ *		apparently each rx desc is followed by frag.descriptors
-+ *		and the rx desc is rounded up to a power of 2.
-+ *
-+ *   Receive code is in en_rx.c
-+ *	priv->rx_ring_num			number of rx rings
-+ *	rxr = prov->rx_ring[ring_ind]		rx ring descriptor
-+ *	rxr->size				number of slots
-+ *	rxr->prod				producer
-+ *	   probably written into a mmio reg at *rxr->wqres.db.db
-+ *	   trimmed to 16 bits.
-+ *
-+ *	Rx init routine:
-+ *		mlx4_en_activate_rx_rings()
-+ *		  mlx4_en_init_rx_desc()
-+ *   Transmit code is in en_tx.c
-+ */
-+
-+#define NETMAP_MLX4_MAIN
-+#include <mlx4_netmap_linux.h>        /* extern stuff */
-+#endif /* CONFIG_NETMAP */
-+
- int mlx4_en_setup_tc(struct net_device *dev, u8 up)
- {
- 	if (up != MLX4_EN_NUM_UP)
-@@ -1042,6 +1075,9 @@ int mlx4_en_start_port(struct net_device
- 		/* Set initial ownership of all Tx TXBBs to SW (1) */
- 		for (j = 0; j < tx_ring->buf_size; j += STAMP_STRIDE)
- 			*((u32 *) (tx_ring->buf + j)) = 0xffffffff;
-+#ifdef DEV_NETMAP
-+		mlx4_netmap_tx_config(priv, i);
-+#endif /* DEV_NETMAP */
- 		++tx_index;
- 	}
- 
-@@ -1639,6 +1675,9 @@ int mlx4_en_init_netdev(struct mlx4_en_d
- 	en_warn(priv, "Using %d RX rings\n", prof->rx_ring_num);
- 
- 	queue_delayed_work(mdev->workqueue, &priv->stats_task, STATS_DELAY);
-+#ifdef DEV_NETMAP
-+	mlx4_netmap_attach(priv);
-+#endif /* DEV_NETMAP */
- 	return 0;
- 
- out:
---- drivers/net/ethernet/mellanox/mlx4/en_rx.c	2012-09-11 20:50:55.982624673 -0700
-+++ ./mlx4/en_rx.c	2012-09-27 00:13:16.099550954 -0700
-@@ -41,6 +41,9 @@
- 
- #include "mlx4_en.h"
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <mlx4_netmap_linux.h>
-+#endif /* !DEV_NETMAP */
- 
- static int mlx4_en_alloc_frag(struct mlx4_en_priv *priv,
- 			      struct mlx4_en_rx_desc *rx_desc,
-@@ -365,9 +368,16 @@ int mlx4_en_activate_rx_rings(struct mlx
- 		ring = &priv->rx_ring[ring_ind];
- 
- 		ring->size_mask = ring->actual_size - 1;
-+#ifdef DEV_NETMAP
-+		if (nm_native_on(NA(priv->dev))) {
-+			int saved_cons = ring->cons;
-+			mlx4_en_free_rx_buf(priv, ring);
-+			ring->cons = saved_cons;
-+			mlx4_netmap_rx_config(priv, ring_ind);
-+		}
-+#endif /* DEV_NETMAP */
- 		mlx4_en_update_rx_prod_db(ring);
- 	}
--
- 	return 0;
- 
- err_buffers:
-@@ -402,6 +412,11 @@ void mlx4_en_destroy_rx_ring(struct mlx4
- void mlx4_en_deactivate_rx_ring(struct mlx4_en_priv *priv,
- 				struct mlx4_en_rx_ring *ring)
- {
-+#ifdef DEV_NETMAP
-+	if (nm_native_on(NA(priv->dev)))
-+		ND("netmap mode, rx buf already freed");
-+	else
-+#endif /* DEV_NETMAP */
- 	mlx4_en_free_rx_buf(priv, ring);
- 	if (ring->stride <= TXBB_SIZE)
- 		ring->buf -= TXBB_SIZE;
-@@ -692,6 +707,12 @@ out:
- 	wmb(); /* ensure HW sees CQ consumer before we post new buffers */
- 	ring->cons = mcq->cons_index;
- 	ring->prod += polled; /* Polled descriptors were realocated in place */
-+
-+	ND(5, "set_ci %d 0x%p val %d prod_db 0x%p val %d",
-+		cq->ring,
-+		mcq->set_ci_db, mcq->cons_index & 0xffffff,
-+		ring->wqres.db.db, ring->prod & 0xffff);
-+
- 	mlx4_en_update_rx_prod_db(ring);
- 	ring->csum_ok += csum_ok;
- 	ring->csum_none += csum_none;
-@@ -718,6 +739,13 @@ int mlx4_en_poll_rx_cq(struct napi_struc
- 	struct mlx4_en_priv *priv = netdev_priv(dev);
- 	int done;
- 
-+#ifdef DEV_NETMAP
-+        static int cnt = 0;
-+        ND(5,"XXXXXX-------XXXXXXXXXXX-------- poll-rx-cq %d count %d", (int)cq->ring, cnt++);
-+	if (netmap_rx_irq(cq->dev, cq->ring, &done)) {
-+		ND("rx_irq %d for netmap, budget %d done %d", cq->ring, budget, done);
-+	} else
-+#endif /* DEV_NETMAP */
- 	done = mlx4_en_process_rx_cq(dev, cq, budget);
- 
- 	/* If we used up all the quota - we're probably not done yet... */
---- drivers/net/ethernet/mellanox/mlx4/en_tx.c	2012-09-11 20:50:55.982624673 -0700
-+++ ./mlx4/en_tx.c	2012-09-27 00:05:22.713523348 -0700
-@@ -55,6 +55,10 @@ MODULE_PARM_DESC(inline_thold, "threshol
- 
- static u32 hashrnd __read_mostly;
- 
-+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-+#include <mlx4_netmap_linux.h>        /* extern stuff */
-+#endif /* CONFIG_NETMAP */
-+
- int mlx4_en_create_tx_ring(struct mlx4_en_priv *priv,
- 			   struct mlx4_en_tx_ring *ring, u32 size,
- 			   u16 stride)
-@@ -396,6 +400,17 @@ void mlx4_en_tx_irq(struct mlx4_cq *mcq)
- 
- 	if (!spin_trylock(&ring->comp_lock))
- 		return;
-+#ifdef DEV_NETMAP // XXX unlock and return should be in the 'if' branch
-+	static int cnt = 0;
-+	ND(5,"XXXXXX-------XXXXXXXXXXX-------- tx-irq %d count %d", (int)cq->ring, cnt++);
-+	if (netmap_tx_irq(cq->dev, cq->ring)) {
-+		ND(5, "wakeup queue %d", cq->ring);
-+	} else {
-+		RD(5, "XXXXXXXXX  tx_irq %d unexpected, ignoring", cq->ring);
-+	}
-+	spin_unlock(&ring->comp_lock);
-+	return;
-+#endif /* DEV_NETMAP */
- 	mlx4_en_process_tx_cq(cq->dev, cq);
- 	mod_timer(&cq->timer, jiffies + 1);
- 	spin_unlock(&ring->comp_lock);
diff --git a/drivers/staging/netmap/Makefile b/drivers/staging/netmap/Makefile
deleted file mode 100644
index ec5dab5cb091..000000000000
--- a/drivers/staging/netmap/Makefile
+++ /dev/null
@@ -1,30 +0,0 @@
-# $Id$
-# targets to build tarballs and diffs
-
-# build a distribution
-
-RELEASE_SRCS := ./sys/net ./sys/dev ./sys/modules ./examples
-RELEASE_SRCS += ./README* ./LINUX ./OSX
-RELEASE_EXCL := --exclude .svn --exclude examples/testmod
-RELEASE_EXCL += --exclude connlib\*
-RELEASE_EXCL += --exclude if_epair.diff
-#RELEASE_EXCL += --exclude \*-patches
-RELEASE_EXCL += --exclude \*bnx2x\* --exclude \*mellanox\* --exclude \*mlx4\*
-RELEASE_EXCL += --exclude OSX
-
-all:
-	@echo "What do you want to do ?"
-
-
-diff-head:
-	(cd ~/FreeBSD/head ; \
-	svn diff sys/conf sys/dev sbin/ifconfig ) > head-netmap.diff
-
-# XXX remember to patch sbin/ifconfig if not done yet
-diff-r8:
-	(cd ~/FreeBSD/RELENG_8 ; \
-	svn diff sys/conf sys/dev sbin/ifconfig ) > r8-netmap.diff
-
-release:
-	D=`date +%Y%m%d` && tar cvzf /tmp/$${D}-netmap.tgz \
-		-s'/^./netmap-release/' $(RELEASE_EXCL) $(RELEASE_SRCS)
diff --git a/drivers/staging/netmap/PORTING b/drivers/staging/netmap/PORTING
deleted file mode 100644
index 6ad13a71419a..000000000000
--- a/drivers/staging/netmap/PORTING
+++ /dev/null
@@ -1,131 +0,0 @@
-# $Id$
-
-Adding netmap support to network device drivers
-------------------------------------------------
-
-Netmap requires some small modifications to device drivers
-to support the new API. You will need to add small patches
-in 3-4 places in the original source, and implement typically
-5 new functions.
-
-Device driver patches
-------------------------
-+ in the initial part of the source, after the device-specific
-  headers and prototypes have been declared, add the following
-    <pre>
-	+#if defined(DEV_NETMAP) || defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
-	+#include <dev/netmap/if_re_netmap.h>
-	+#endif /* !DEV_NETMAP */
-    </pre>
-    The place is typically ... in FreeBSD, and
-    ... on Linux.
-
-    The header really contains the new functions that implement
-    the netmap API. Including them inline simplifies the building
-    as it does not require to insert additional dependencies in the
-    build system.
-
-    On FreeBSD DEV_NETMAP is sufficient to detect whether netmap extensions
-    should be compiled in, whereas CONFIG_NETMAP and CONFIG_NETMAP_MODULE
-    are the Linux equivalent.
-
-    If a driver is made of multiple source files, you will need to include
-    the additional header in all the (few) patched files, preferably using
-    a macro such as NETMAP_FOO_MAIN to indicate the file where the
-    new functions should be compiled in.
-
-+ near the end of the attach routine, once the ifnet/net_device structure
-  has been filled and initialized, add
-    <pre>
-	+#ifdef DEV_NETMAP
-	+	foo_netmap_attach(adapter);
-	+#endif /* DEV_NETMAP */
-    </pre>
-  The argument is either the ifnet or the private device descriptor.  
-  This is in foo_attach() on FreeBSD, and somewhere in the path of
-  XXX foo_open() in Linux
-
-+ near the code called on device removal, add
-    <pre>
-	+#ifdef DEV_NETMAP
-	+	netmap_detach(ifp);
-	+#endif /* DEV_NETMAP */
-    </pre>
-
-+ after the tx/rx rings have been initialized, add a patch like this:
-    <pre>
-	+#ifdef DEV_NETMAP
-	+	foo_netmap_config(priv);
-	+#endif /* DEV_NETMAP */
-    </pre>
-    The argument is typically the private device descriptor, or even
-    the struct ifnet/net_device.
-
-+ in the interrupt dispatch routines, something like
-    <pre>
-	+#ifdef DEV_NETMAP
-	+       int dummy;
-	+       if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, &dummy))
-	+               return true;
-	+#endif /* DEV_NETMAP */
-	...
-	+#ifdef DEV_NETMAP
-	+       if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
-	+               return true; /* seems to be ignored */
-	+#endif /* DEV_NETMAP */
-     </pre>
-     to skip the normal processing and instead wake up the process in
-     charge of doing I/O
-
-New functions
-----------------
-The new functions serve to register the netmap-enabled device driver,
-support the enable/disable of netmap mode, attach netmap buffers to the
-NIC rings, and finally implement the handlers (*_txsync(), *_rxsync())
-called by the system calls.
-
-* foo_netmap_attach()
-    This is a relatively mechanical function. The purpose is to fetch from
-    the device descriptor information on the number of rings and buffers,
-    the way locks are used, and invoke netmap_attach().
-
-* foo_netmap_config()
-    This function is in charge of (over)writing the NIC rings with
-    pointers to the netmap buffers. Although this is device dependent,
-    we can often ignore the locking issue and expect that the locking is
-    already taken care of by the caller.
-
-    foo_netmap_config() only needs to run if the card is in netmap mode.
-    A quick way to check is to call netmap_ring_init() on one of the rings,
-    if the function returns NULL we can immediately exit.
-    Otherwise, we should run a couple of nested loops (on the rings,
-    and then on the buffers) to fill the NIC descriptors with the
-    addresses of the (preallocated) netmap buffers.
-
-    For the TX rings this can even be a no-op because these rings are
-    typically uninitialized, and the pointers can be overridden in the
-    txsync() routine.
-
-    For the receive ring, the operation is more critical because the
-    buffers should be available by the time the NIC is enabled.
-
-    Note that the device driver typically maintains head and tail pointers
-    to indicate which buffers are used. It might be convenient to retain
-    these indexes because may of the support routines, watchdogs etc.
-    depends on their values.
-
-    We should note that, especially on the receive ring, there might be
-    an offset between the indexes used in the netmap ring and those used
-    in the NIC ring (which might even be non-contiguous).
-
-* foo_netmap_reg()
-    support entering/exiting of netmap mode. Typically, lock, stop the device,
-    set/clear the netmap flag, and restart the device.
-    An unfortunate side effect of stopping and restarting the device is that
-    in many drivers the link is reinitialized, causing long delays for the
-    speed negotiations and spanning tree setup.
-
-
-* foo_netmap_txsync()
-
-* foo_netmap_rxsync()
diff --git a/drivers/staging/netmap/README.images b/drivers/staging/netmap/README.images
deleted file mode 100644
index c4444ad0b0ec..000000000000
--- a/drivers/staging/netmap/README.images
+++ /dev/null
@@ -1,416 +0,0 @@
-	EXPERIMENTING WITH NETMAP, VALE AND FAST QEMU
-	---------------------------------------------
-
-To ease experiments with Netmap, the VALE switch and our Qemu enhancements
-we have prepared a couple of bootable images (linux and FreeBSD).
-You can find them on the netmap page
-
-	http://info.iet.unipi.it/~luigi/netmap/
-
-where you can also look at more recent versions of this file.
-
-Below are step-by-step instructions on experiments you can run
-with these images. The two main versions are
-
-	picobsd.hdd	-> FreeBSD HEAD (netmap + VALE)
-	tinycore.hdd	-> Linux (qemu + netmap + VALE)      
-
-Booting the image
------------------
-For all experiments you need to copy the image on a USB stick
-and boot a PC with it. Alternatively, you can use the image
-with VirtualBox, Qemu or other emulators, as an example
-
-    qemu-system-x86_64 -hda IMAGE_FILE -m 1G -machine accel=kvm ...
-
-(remove 'accel=kvm' if your host does not support kvm).
-The images do not install anything on the hard disk.
-
-Both systems have preloaded drivers for a number of network cards
-(including the intel 10 Gbit ones) with netmap extensions.
-The VALE switch is also available (it is part of the netmap module).
-ssh, scp and a few other utilities are also included.
-
-FreeBSD image:
-
-  + the OS boots directly in console mode, you can switch
-    between terminals with ALT-Fn.
-    The password for the 'root' account is 'setup'
-
-  + if you are connected to a network, you can use
-    	dhclient em0 # or other interface name
-    to obtain an IP address and external connectivity.
-
-Linux image:
-
-  + in addition to the netmap/VALE modules, the KVM kernel module
-    is also preloaded.
-
-  + the boot-loader gives you two main options (each with
-    a variant to delay boot in case you have slow devices):
-
-    + "Boot TinyCore"
-      boots in an X11 environment as user 'tc'.
-      You can create a few terminals using the icon at the
-      bottom. You can use "sudo -s" to get root access.
-      In case no suitable video card is available/detected,
-      it falls back to command line mode.
-
-    + "Boot Core (command line only)"
-      boots in console mode with virtual terminals.
-      You're automatically logged in as user 'tc'.
-      To log in the other terminals use the same username 
-      (no password required).
-
-  + The system should automatically recognize the existing ethernet
-    devices, and load the appropriate netmap-capable device drivers
-    when available.  Interfaces are configured through DHCP when possible.
-
-
-General test recommendations
-----------------------------
-NOTE: The tests outlined in the following sections can generate very high
-packet rates, and some hardware misconfiguration problems may prevent
-you from achieving maximum speed.
-Common problems are:
-
-+ slow link autonegotiation.
-  Our programs typically wait 2-4 seconds for
-  link negotiation to complete, but some NIC/switch combinations
-  are much slower. In this case you should increase the delay
-  (pkt-gen has the -w XX option for that) or possibly force
-  the link speed and duplex mode on both sides.
-
-  Check the link speed to make sure there are no nogotiation
-  problems, and that you see the expected speed.
-
-    ethtool IFNAME	# on linux
-    ifconfig IFNAME	# on FreeBSD
-
-+ ethernet flow control.
-  If the receiving port is slow (often the case in presence
-  of multicast/broadcast traffic, or also unicast if you are
-  sending to non-netmap receivers), it will generate ethernet
-  flow control frames that throttle down the sender.
-
-  We recommend to disable BOTH RX and TX ethernet flow control
-  on BOTH sender and receiver.
-  On Linux this can be done with ethtool:
-
-    ethtool -A IFNAME tx off rx off
-
-  whereas on FreeBSD there are device-specific sysctl
-
-	sysctl dev.ix.0.queue0.flow_control = 0
-
-+ CPU power saving.
-  The CPU governor on linux, or equivalent in FreeBSD, tend to
-  throttle down the clock rate reducing performance.
-  Unlike other similar systems, netmap does not have busy-wait
-  loops, so the CPU load is generally low and this can trigger
-  the clock slowdown.
-
-  Make sure that ALL CPUs run at maximum speed, possibly
-  disabling the dynamic frequency-scaling mechanisms.
-
-    cpufreq-set -gperformance	# on linux
-
-    sysctl dev.cpu.0.freq=3401	# on FreeBSD.
-
-+ wrong MAC address
-  netmap does not put the NIC in promiscuous mode, so unless the
-  application does it, the NIC will only receive broadcast traffic or
-  unicast directed to its own MAC address.
-
-
-STANDARD SOCKET TESTS
----------------------
-For most socket-based experiments you can use the "netperf" tool installed
-on the system (version 2.6.0). Be careful to use a matching version for
-the other netperf endpoint (e.g. netserver) when running tests between
-different machines.
-
-Interesting experiments are:
-
-    netperf -H x.y.z.w -tTCP_STREAM  # test TCP throughput
-    netperf -H x.y.z.w -tTCP_RR      # test latency
-    netperf -H x.y.z.w -tUDP_STREAM -- -m8  # test UDP throughput with short packets
-
-where x.y.z.w is the host running "netserver".
-
-
-RAW SOCKET AND TAP TESTS
-------------------------
-For experiments with raw sockets and tap devices you can use the l2
-utilities (l2open, l2send, l2recv) installed on the system.
-With these utilities you can send/receive custom network packets
-to/from raw sockets or tap file descriptors.
-
-The receiver can be run with one of the following commands
-
-    l2open -r IFNAME l2recv     # receive from a raw socket attached to IFNAME
-    l2open -t IFNAME l2recv     # receive from a file descriptor opened on the tap IFNAME
-
-The receiver process will wait indefinitely for the first packet
-and then keep receiving as long as packets keep coming. When the
-flow stops (after a 2 seconds timeout) the process terminates and
-prints the received packet rate and packet count.
-
-To run the sender in an easy way, you can use the script l2-send.sh
-in the home directory. This script defines several shell variables
-that can be manually changed to customize the test (see
-the comments in the script itself).
-
-As an example, you can test configurations with Virtual
-Machines attached to host tap devices bridged together.
-
-
-Tests using the Linux in-kernel pktgen
---------------------------------------
-To use the Linux in-kernel packet generator, you can use the
-script "linux-pktgen.sh" in the home directory.
-The pktgen creates a kernel thread for each hardware TX queue
-of a given NIC.
-
-By manually changing the script shell variable definitions you
-can change the test configuration (e.g. addresses in the generated
-packet). Please change the "NCPU" variable to match the number
-of CPUs on your machine. The script has an argument which
-specifies the number of NIC queues (i.e. kernel threads)
-to use minus one.
-
-For example:
-
-    ./linux-pktgen.sh 2  # Uses 3 NIC queues
-
-When the script terminates, it prints the per-queue rates and
-the total rate achieved.
-
-
-NETMAP AND VALE EXPERIMENTS
----------------------------
-
-For most experiments with netmap you can use the "pkt-gen" command
-(do not confuse it with the Linux in-kernel pktgen), which has a large
-number of options to send and receive traffic (also on TAP devices).
-
-pkt-gen normally generates UDP traffic for a specific IP address
-and using the brodadcast MAC address
-
-Netmap testing with network interfaces
---------------------------------------
-
-Remember that you need a netmap-capable driver in order to use
-netmap on a specific NIC. Currently supported drivers are e1000,
-e1000e, ixgbe, igb. For updated information please visit
-http://info.iet.unipi.it/~luigi/netmap/
-
-Before running pkt-gen, make sure that the link is up.
-
-Run pkt-gen on an interface called "IFNAME":
-
-    pkt-gen -i IFNAME -f tx  # run a pkt-gen sender
-    pkt-gen -i IFNAME -f rx  # run a pkt-gen receiver
-
-pkt-gen without arguments will show other options, e.g.
-  + -w sec	modifies the wait time for link negotioation
-  + -l len	modifies the packet size
-  + -d, -s	set the IP destination/source addresses and ports
-  + -D, -S	set the MAC destination/source addresses
-
-and more.
-
-Testing the VALE switch
-------------------------
-
-To use the VALE switch instead of physical ports you only need
-to change the interface name in the pkt-gen command.
-As an example, on a single machine, you can run senders and receivers
-on multiple ports of a VALE switch as follows (run the commands into
-separate terminals to see the output)
-
-    pkt-gen -ivale0:01 -ftx  # run a sender on the port 01 of the switch vale0
-    pkt-gen -ivale0:02 -frx  # receiver on the port 02 of same switch
-    pkt-gen -ivale0:03 -ftx  # another sender on the port 03
-
-The VALE switches and ports are created (and destroyed) on the fly.
-
-
-Transparent connection of physical ports to the VALE switch
------------------------------------------------------------
-
-It is also possible to use a network device as a port of a VALE
-switch. You can do this with the following command:
-
-    vale-ctl -h vale0:eth0  # attach interface "eth0" to the "vale0" switch
-
-To detach an interface from a bridge:
-
-    vale-ctl -d vale0:eth0  # detach interface "eth0" from the "vale0" switch
-
-These operations can be issued at any moment.
-
-
-Tests with our modified QEMU
-----------------------------
-
-The Linux image also contains our modified QEMU, with the VALE backend and
-the "e1000-paravirt" frontend (a paravirtualized e1000 emulation).
-
-After you have booted the image on a physical machine (so you can exploit
-KVM), you can boot the same image a second time (recursively) with QEMU.
-Therefore, you can run all the tests above also from within the virtual
-machine environment.
-
-To make VM testing easier, the home directory contains some
-some useful scripts to set up and launch VMs on the physical machine.
-
-+ "prep-taps.sh"
-  creates and sets up two permanent tap interfaces ("tap01" and "tap02")
-  and a Linux in-kernel bridge. The tap interfaces are then bridged
-  together on the same bridge. The bridge interface ("br0"), is given
-  the address 10.0.0.200/24.
-
-  This setup can be used to make two VMs communicate through the
-  host bridge, or to test the speed of a linux switch using
-  l2open
-
-+ "unprep-taps.sh"
-  undoes the above setup.
-
-+ "launch-qemu.sh"
-  can be used to run QEMU virtual machines. It takes four arguments:
-
-    + The first argument can be "qemu" or "kvm", depending on
-      whether we want to use the standard QEMU binary translation
-      or the hardware virtualization acceleration.
-
-    + The third argument can be "--tap", "--netuser" or "--vale",
-      and tells QEMU what network backend to use: a tap device,
-      the QEMU user networking (slirp), or a VALE switch port.
-
-    + When the third argument is "--tap" or "--vale", the fourth
-      argument specifies an index (e.g. "01", "02", etc..) which
-      tells QEMU what tap device or VALE port to use as backend.
-
-  You can manually modify the script to set the shell variables that
-  select the type of emulated device (e.g.  e1000, virtio-net-pci, ...)
-  and related options (ioeventfd, virtio vhost, e1000 mitigation, ....).
-
-  The default setup has an "e1000" device with interrupt mitigation
-  disabled.
-
-You can try the paravirtualized e1000 device ("e1000-paravirt")
-or the "virtio-net" device to get better performance. However, bear
-in mind that these paravirtualized devices don't have netmap support
-(whereas the standard e1000 does have netmap support).
-
-Examples:
-
-    # Run a kvm VM attached to the port 01 of a VALE switch
-    ./launch-qemu.sh kvm --vale 01
-
-    # Run a kvm VM attached to the port 02 of the same VALE switch
-    ./launch-qemu.sh kvm --vale 02
-
-    # Run a kvm VM attached to the tap called "tap01"
-    ./launch-qemu.sh kvm --tap 01
-
-    # Run a kvm VM attached to the tap called "tap02"
-    ./launch-qemu.sh kvm --tap 02
-
-
-Guest-to-guest tests
---------------------
-
-If you run two VMs attached to the same switch (which can be a Linux
-bridge or a VALE switch), you can run guest-to-guest experiments.
-
-All the tests reported in the previous sections are possible (normal
-sockets, raw sockets, pkt-gen, ...), indipendently of the backend used.
-
-In the following examples we assume that:
-
-    + Each VM has an ethernet interface called "eth0".
-
-    + The interface of the first VM is given the IP 10.0.0.1/24.
-
-    + The interface of the second VM is given the IP 10.0.0.2/24.
-
-    + The Linux bridge interface "br0" on the host is given the
-      IP 10.0.0.200/24.
-
-Examples:
-
-    [1] ### Test UDP short packets over traditional sockets ###
-        # On the guest 10.0.0.2 run
-            netserver
-        # on the guest 10.0.0.1 run
-            netperf -H10.0.0.2 -tUDP_STREAM -- -m8
-
-    [2] ### Test UDP short packets with pkt-gen ###
-        # On the guest 10.0.0.2 run
-            pkt-gen -ieth0 -frx
-        # On the guest 10.0.0.1 run
-            pkt-gen -ieth0 -ftx
-
-    [3] ### Test guest-to-guest latency ###
-        # On the guest 10.0.0.2 run
-            netserver
-        # On the guest 10.0.0.1 run
-            netperf -H10.0.0.2 -tTCP_RR
-
-Note that you can use pkt-gen into a VM only if the emulated ethernet
-device is supported by netmap. The default emulated device is
-"e1000", which has netmap support.  If you try to run pkt-gen on
-an unsupported device, pkt-gen will not work, reporting that it is
-unable to register the interface.
-
-
-Guest-to-host tests (follows from the previous section)
--------------------------------------------------------
-
-If you run only a VM on your host machine, you can measure the
-network performance between the VM and the host machine.  In this
-case the experiment setup depends on the backend you are using.
-
-With the tap backend, you can use the bridge interface "br0" as a
-communication endpoint. You can run normal/raw sockets experiments,
-but you cannot use pkt-gen on the "br0" interface, since the Linux
-bridge interface is not supported by netmap.
-
-Examples with the tap backend:
-
-    [1] ### Test TCP throughput over traditional sockets ###
-        # On the host run
-            netserver
-        # on the guest 10.0.0.1 run
-            netperf -H10.0.0.200 -tTCP_STREAM
-
-    [2] ### Test UDP short packets with pkt-gen and l2 ###
-        # On the host run
-            l2open -r br0 l2recv
-        # On the guest 10.0.0.1 run (xx:yy:zz:ww:uu:vv is the
-        # "br0" hardware address)
-            pkt-gen -ieth0 -ftx -d10.0.0.200:7777 -Dxx:yy:zz:ww:uu:vv
-
-
-With the VALE backend you can perform only UDP tests, since we don't have
-a netmap application which implements a TCP endpoint: pkt-gen generates
-UDP packets.
-As a communication endpoint on the host, you can use a virtual VALE port
-opened on the fly by a pkt-gen instance.
-
-Examples with the VALE backend:
-
-    [1] ### Test UDP short packets ###
-        # On the host run
-            pkt-gen -ivale0:99 -frx
-        # On the guest 10.0.0.1 run
-            pkt-gen -ieth0 -ftx
-
-    [2] ### Test UDP big packets (receiver on the guest) ###
-        # On the guest 10.0.0.1 run
-            pkt-gen -ieth0 -frx
-        # On the host run pkt-gen -ivale0:99 -ftx -l1460
-
diff --git a/drivers/staging/netmap/examples/GNUmakefile b/drivers/staging/netmap/examples/GNUmakefile
deleted file mode 100644
index e0a8e7c94967..000000000000
--- a/drivers/staging/netmap/examples/GNUmakefile
+++ /dev/null
@@ -1,58 +0,0 @@
-# For multiple programs using a single source file each,
-# we can just define 'progs' and create custom targets.
-PROGS	=	pkt-gen bridge vale-ctl
-#PROGS += pingd
-PROGS	+= test_select testmmap
-X86PROG = testlock testcsum
-LIBNETMAP =
-
-CLEANFILES = $(PROGS) $(X86PROGS) *.o
-
-SRCDIR ?= ..
-VPATH = $(SRCDIR)/examples
-
-NO_MAN=
-CFLAGS = -O2 -pipe
-CFLAGS += -Werror -Wall -Wunused-function
-CFLAGS += -I $(SRCDIR)/sys # -I/home/luigi/FreeBSD/head/sys -I../sys
-CFLAGS += -Wextra
-ifdef WITH_PCAP
-# do not use pcap by default, as it is not always available on linux
-LDLIBS += -lpcap
-else
-CFLAGS += -DNO_PCAP
-endif
-
-LDLIBS += -lpthread
-ifeq ($(shell uname),Linux)
-	LDLIBS += -lrt	# on linux
-endif
-#SRCS = pkt-gen.c
-
-PREFIX ?= /usr/local
-
-all: $(PROGS)
-
-all-x86: $(PROGS) $(X86PROGS)
-
-kern_test: testmod/kern_test.c
-
-pkt-gen: pkt-gen.o
-
-bridge: bridge.o
-
-vale-ctl: vale-ctl.o
-
-%-pic.o: %.c
-	$(CC) $(CFLAGS) -fpic -c $^ -o $@
-
-clean:
-	-@rm -rf $(CLEANFILES)
-
-testlock: testlock.c
-
-.PHONY: install
-install: $(PROGS:%=install-%)
-
-install-%:
-	install -D $* $(DESTDIR)/$(PREFIX)/bin/$*
diff --git a/drivers/staging/netmap/examples/Makefile b/drivers/staging/netmap/examples/Makefile
deleted file mode 100644
index f28afc73180b..000000000000
--- a/drivers/staging/netmap/examples/Makefile
+++ /dev/null
@@ -1,41 +0,0 @@
-# For multiple programs using a single source file each,
-# we can just define 'progs' and create custom targets.
-PROGS	=	pkt-gen bridge vale-ctl
-#PROGS += pingd
-PROGS	+= testlock test_select testmmap vale-ctl
-MORE_PROGS = kern_test
-
-CLEANFILES = $(PROGS) *.o
-NO_MAN=
-CFLAGS = -O2 -pipe
-CFLAGS += -Werror -Wall -Wunused-function
-CFLAGS += -I ../sys # -I/home/luigi/FreeBSD/head/sys -I../sys
-CFLAGS += -Wextra
-.ifdef WITH_PCAP
-LDFLAGS += -lpcap
-.else
-CFLAGS += -DNO_PCAP
-.endif
-
-LDFLAGS += -lpthread
-LDFLAGS += -lrt	# needed on linux, does not harm on BSD
-#SRCS = pkt-gen.c
-
-all: $(PROGS)
-
-kern_test: testmod/kern_test.c
-
-pkt-gen: pkt-gen.o
-	$(CC) $(CFLAGS) -o pkt-gen pkt-gen.o $(LDFLAGS)
-
-bridge: bridge.o
-	$(CC) $(CFLAGS) -o bridge bridge.o
-
-vale-ctl: vale-ctl.o
-	$(CC) $(CFLAGS) -o vale-ctl vale-ctl.o
-
-clean:
-	-@rm -rf $(CLEANFILES)
-
-testlock: testlock.c
-	$(CC) $(CFLAGS) -o testlock testlock.c -lpthread $(LDFLAGS)
diff --git a/drivers/staging/netmap/examples/README b/drivers/staging/netmap/examples/README
deleted file mode 100644
index 3aa04c45efbd..000000000000
--- a/drivers/staging/netmap/examples/README
+++ /dev/null
@@ -1,9 +0,0 @@
-$FreeBSD: head/tools/tools/netmap/README 227614 2011-11-17 12:17:39Z luigi $
-
-This directory contains examples that use netmap
-
-	pkt-gen		a packet sink/source using the netmap API
-
-	bridge		a two-port jumper wire, also using the native API
-
-	click*		various click examples
diff --git a/drivers/staging/netmap/examples/bridge.c b/drivers/staging/netmap/examples/bridge.c
deleted file mode 100644
index 98b2a1fa4108..000000000000
--- a/drivers/staging/netmap/examples/bridge.c
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * (C) 2011-2014 Luigi Rizzo, Matteo Landi
- *
- * BSD license
- *
- * A netmap client to bridge two network interfaces
- * (or one interface and the host stack).
- *
- * $FreeBSD: head/tools/tools/netmap/bridge.c 228975 2011-12-30 00:04:11Z uqs $
- */
-
-#include <stdio.h>
-#define NETMAP_WITH_LIBS
-#include <net/netmap_user.h>
-#include <sys/poll.h>
-
-int verbose = 0;
-
-static int do_abort = 0;
-static int zerocopy = 1; /* enable zerocopy if possible */
-
-static void
-sigint_h(int sig)
-{
-	(void)sig;	/* UNUSED */
-	do_abort = 1;
-	signal(SIGINT, SIG_DFL);
-}
-
-
-/*
- * how many packets on this set of queues ?
- */
-int
-pkt_queued(struct nm_desc *d, int tx)
-{
-        u_int i, tot = 0;
-
-        if (tx) {
-                for (i = d->first_tx_ring; i <= d->last_tx_ring; i++) {
-                        tot += nm_ring_space(NETMAP_TXRING(d->nifp, i));
-                }
-        } else {
-                for (i = d->first_rx_ring; i <= d->last_rx_ring; i++) {
-                        tot += nm_ring_space(NETMAP_RXRING(d->nifp, i));
-                }
-        }
-        return tot;
-}
-
-/*
- * move up to 'limit' pkts from rxring to txring swapping buffers.
- */
-static int
-process_rings(struct netmap_ring *rxring, struct netmap_ring *txring,
-	      u_int limit, const char *msg)
-{
-	u_int j, k, m = 0;
-
-	/* print a warning if any of the ring flags is set (e.g. NM_REINIT) */
-	if (rxring->flags || txring->flags)
-		D("%s rxflags %x txflags %x",
-			msg, rxring->flags, txring->flags);
-	j = rxring->cur; /* RX */
-	k = txring->cur; /* TX */
-	m = nm_ring_space(rxring);
-	if (m < limit)
-		limit = m;
-	m = nm_ring_space(txring);
-	if (m < limit)
-		limit = m;
-	m = limit;
-	while (limit-- > 0) {
-		struct netmap_slot *rs = &rxring->slot[j];
-		struct netmap_slot *ts = &txring->slot[k];
-
-		/* swap packets */
-		if (ts->buf_idx < 2 || rs->buf_idx < 2) {
-			D("wrong index rx[%d] = %d  -> tx[%d] = %d",
-				j, rs->buf_idx, k, ts->buf_idx);
-			sleep(2);
-		}
-		/* copy the packet length. */
-		if (rs->len > 2048) {
-			D("wrong len %d rx[%d] -> tx[%d]", rs->len, j, k);
-			rs->len = 0;
-		} else if (verbose > 1) {
-			D("%s send len %d rx[%d] -> tx[%d]", msg, rs->len, j, k);
-		}
-		ts->len = rs->len;
-		if (zerocopy) {
-			uint32_t pkt = ts->buf_idx;
-			ts->buf_idx = rs->buf_idx;
-			rs->buf_idx = pkt;
-			/* report the buffer change. */
-			ts->flags |= NS_BUF_CHANGED;
-			rs->flags |= NS_BUF_CHANGED;
-		} else {
-			char *rxbuf = NETMAP_BUF(rxring, rs->buf_idx);
-			char *txbuf = NETMAP_BUF(txring, ts->buf_idx);
-			nm_pkt_copy(rxbuf, txbuf, ts->len);
-		}
-		j = nm_ring_next(rxring, j);
-		k = nm_ring_next(txring, k);
-	}
-	rxring->head = rxring->cur = j;
-	txring->head = txring->cur = k;
-	if (verbose && m > 0)
-		D("%s sent %d packets to %p", msg, m, txring);
-
-	return (m);
-}
-
-/* move packts from src to destination */
-static int
-move(struct nm_desc *src, struct nm_desc *dst, u_int limit)
-{
-	struct netmap_ring *txring, *rxring;
-	u_int m = 0, si = src->first_rx_ring, di = dst->first_tx_ring;
-	const char *msg = (src->req.nr_ringid & NETMAP_SW_RING) ?
-		"host->net" : "net->host";
-
-	while (si <= src->last_rx_ring && di <= dst->last_tx_ring) {
-		rxring = NETMAP_RXRING(src->nifp, si);
-		txring = NETMAP_TXRING(dst->nifp, di);
-		ND("txring %p rxring %p", txring, rxring);
-		if (nm_ring_empty(rxring)) {
-			si++;
-			continue;
-		}
-		if (nm_ring_empty(txring)) {
-			di++;
-			continue;
-		}
-		m += process_rings(rxring, txring, limit, msg);
-	}
-
-	return (m);
-}
-
-
-static void
-usage(void)
-{
-	fprintf(stderr,
-	    "usage: bridge [-v] [-i ifa] [-i ifb] [-b burst] [-w wait_time] [iface]\n");
-	exit(1);
-}
-
-/*
- * bridge [-v] if1 [if2]
- *
- * If only one name, or the two interfaces are the same,
- * bridges userland and the adapter. Otherwise bridge
- * two intefaces.
- */
-int
-main(int argc, char **argv)
-{
-	struct pollfd pollfd[2];
-	int ch;
-	u_int burst = 1024, wait_link = 4;
-	struct nm_desc *pa = NULL, *pb = NULL;
-	char *ifa = NULL, *ifb = NULL;
-	char ifabuf[64] = { 0 };
-
-	fprintf(stderr, "%s built %s %s\n",
-		argv[0], __DATE__, __TIME__);
-
-	while ( (ch = getopt(argc, argv, "b:ci:vw:")) != -1) {
-		switch (ch) {
-		default:
-			D("bad option %c %s", ch, optarg);
-			usage();
-			break;
-		case 'b':	/* burst */
-			burst = atoi(optarg);
-			break;
-		case 'i':	/* interface */
-			if (ifa == NULL)
-				ifa = optarg;
-			else if (ifb == NULL)
-				ifb = optarg;
-			else
-				D("%s ignored, already have 2 interfaces",
-					optarg);
-			break;
-		case 'c':
-			zerocopy = 0; /* do not zerocopy */
-			break;
-		case 'v':
-			verbose++;
-			break;
-		case 'w':
-			wait_link = atoi(optarg);
-			break;
-		}
-
-	}
-
-	argc -= optind;
-	argv += optind;
-
-	if (argc > 1)
-		ifa = argv[1];
-	if (argc > 2)
-		ifb = argv[2];
-	if (argc > 3)
-		burst = atoi(argv[3]);
-	if (!ifb)
-		ifb = ifa;
-	if (!ifa) {
-		D("missing interface");
-		usage();
-	}
-	if (burst < 1 || burst > 8192) {
-		D("invalid burst %d, set to 1024", burst);
-		burst = 1024;
-	}
-	if (wait_link > 100) {
-		D("invalid wait_link %d, set to 4", wait_link);
-		wait_link = 4;
-	}
-	if (!strcmp(ifa, ifb)) {
-		D("same interface, endpoint 0 goes to host");
-		snprintf(ifabuf, sizeof(ifabuf) - 1, "%s^", ifa);
-		ifa = ifabuf;
-	} else {
-		/* two different interfaces. Take all rings on if1 */
-	}
-	pa = nm_open(ifa, NULL, 0, NULL);
-	if (pa == NULL) {
-		D("cannot open %s", ifa);
-		return (1);
-	}
-	// XXX use a single mmap ?
-	pb = nm_open(ifb, NULL, NM_OPEN_NO_MMAP, pa);
-	if (pb == NULL) {
-		D("cannot open %s", ifb);
-		nm_close(pa);
-		return (1);
-	}
-	zerocopy = zerocopy && (pa->mem == pb->mem);
-	D("------- zerocopy %ssupported", zerocopy ? "" : "NOT ");
-
-	/* setup poll(2) variables. */
-	memset(pollfd, 0, sizeof(pollfd));
-	pollfd[0].fd = pa->fd;
-	pollfd[1].fd = pb->fd;
-
-	D("Wait %d secs for link to come up...", wait_link);
-	sleep(wait_link);
-	D("Ready to go, %s 0x%x/%d <-> %s 0x%x/%d.",
-		pa->req.nr_name, pa->first_rx_ring, pa->req.nr_rx_rings,
-		pb->req.nr_name, pb->first_rx_ring, pb->req.nr_rx_rings);
-
-	/* main loop */
-	signal(SIGINT, sigint_h);
-	while (!do_abort) {
-		int n0, n1, ret;
-		pollfd[0].events = pollfd[1].events = 0;
-		pollfd[0].revents = pollfd[1].revents = 0;
-		n0 = pkt_queued(pa, 0);
-		n1 = pkt_queued(pb, 0);
-		if (n0)
-			pollfd[1].events |= POLLOUT;
-		else
-			pollfd[0].events |= POLLIN;
-		if (n1)
-			pollfd[0].events |= POLLOUT;
-		else
-			pollfd[1].events |= POLLIN;
-		ret = poll(pollfd, 2, 2500);
-		if (ret <= 0 || verbose)
-		    D("poll %s [0] ev %x %x rx %d@%d tx %d,"
-			     " [1] ev %x %x rx %d@%d tx %d",
-				ret <= 0 ? "timeout" : "ok",
-				pollfd[0].events,
-				pollfd[0].revents,
-				pkt_queued(pa, 0),
-				NETMAP_RXRING(pa->nifp, pa->cur_rx_ring)->cur,
-				pkt_queued(pa, 1),
-				pollfd[1].events,
-				pollfd[1].revents,
-				pkt_queued(pb, 0),
-				NETMAP_RXRING(pb->nifp, pb->cur_rx_ring)->cur,
-				pkt_queued(pb, 1)
-			);
-		if (ret < 0)
-			continue;
-		if (pollfd[0].revents & POLLERR) {
-			struct netmap_ring *rx = NETMAP_RXRING(pa->nifp, pa->cur_rx_ring);
-			D("error on fd0, rx [%d,%d,%d)",
-				rx->head, rx->cur, rx->tail);
-		}
-		if (pollfd[1].revents & POLLERR) {
-			struct netmap_ring *rx = NETMAP_RXRING(pb->nifp, pb->cur_rx_ring);
-			D("error on fd1, rx [%d,%d,%d)",
-				rx->head, rx->cur, rx->tail);
-		}
-		if (pollfd[0].revents & POLLOUT) {
-			move(pb, pa, burst);
-			// XXX we don't need the ioctl */
-			// ioctl(me[0].fd, NIOCTXSYNC, NULL);
-		}
-		if (pollfd[1].revents & POLLOUT) {
-			move(pa, pb, burst);
-			// XXX we don't need the ioctl */
-			// ioctl(me[1].fd, NIOCTXSYNC, NULL);
-		}
-	}
-	D("exiting");
-	nm_close(pb);
-	nm_close(pa);
-
-	return (0);
-}
diff --git a/drivers/staging/netmap/examples/click-test.cfg b/drivers/staging/netmap/examples/click-test.cfg
deleted file mode 100644
index d95ab4a6daa4..000000000000
--- a/drivers/staging/netmap/examples/click-test.cfg
+++ /dev/null
@@ -1,19 +0,0 @@
-//
-// $FreeBSD: head/tools/tools/netmap/click-test.cfg 227614 2011-11-17 12:17:39Z luigi $
-//
-// A sample test configuration for click
-//
-//
-// create a switch
-
-myswitch :: EtherSwitch;
-
-// two input devices
-
-c0 :: FromDevice(ix0, PROMISC true);
-c1 :: FromDevice(ix1, PROMISC true);
-
-// and now pass packets around
-
-c0[0] -> [0]sw[0] -> Queue(10000) -> ToDevice(ix0);
-c1[0] -> [1]sw[1] -> Queue(10000) -> ToDevice(ix1);
diff --git a/drivers/staging/netmap/examples/pkt-gen.c b/drivers/staging/netmap/examples/pkt-gen.c
deleted file mode 100644
index 1b23b799887b..000000000000
--- a/drivers/staging/netmap/examples/pkt-gen.c
+++ /dev/null
@@ -1,1939 +0,0 @@
-/*
- * Copyright (C) 2011-2014 Matteo Landi, Luigi Rizzo. All rights reserved.
- * Copyright (C) 2013-2014 Universita` di Pisa. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *   1. Redistributions of source code must retain the above copyright
- *      notice, this list of conditions and the following disclaimer.
- *   2. Redistributions in binary form must reproduce the above copyright
- *      notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * $FreeBSD: head/tools/tools/netmap/pkt-gen.c 231198 2012-02-08 11:43:29Z luigi $
- * $Id: pkt-gen.c 12346 2013-06-12 17:36:25Z luigi $
- *
- * Example program to show how to build a multithreaded packet
- * source/sink using the netmap device.
- *
- * In this example we create a programmable number of threads
- * to take care of all the queues of the interface used to
- * send or receive traffic.
- *
- */
-
-#define _GNU_SOURCE	/* for CPU_SET() */
-#include <stdio.h>
-#define NETMAP_WITH_LIBS
-#include <net/netmap_user.h>
-
-
-#include <ctype.h>	// isprint()
-#include <unistd.h>	// sysconf()
-#include <sys/poll.h>
-#include <arpa/inet.h>	/* ntohs */
-#include <sys/sysctl.h>	/* sysctl */
-#include <ifaddrs.h>	/* getifaddrs */
-#include <net/ethernet.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <netinet/udp.h>
-
-#include <pthread.h>
-
-#ifndef NO_PCAP
-#include <pcap/pcap.h>
-#endif
-
-#ifdef linux
-
-#define cpuset_t        cpu_set_t
-
-#define ifr_flagshigh  ifr_flags        /* only the low 16 bits here */
-#define IFF_PPROMISC   IFF_PROMISC      /* IFF_PPROMISC does not exist */
-#include <linux/ethtool.h>
-#include <linux/sockios.h>
-
-#define CLOCK_REALTIME_PRECISE CLOCK_REALTIME
-#include <netinet/ether.h>      /* ether_aton */
-#include <linux/if_packet.h>    /* sockaddr_ll */
-#endif  /* linux */
-
-#ifdef __FreeBSD__
-#include <sys/endian.h> /* le64toh */
-#include <machine/param.h>
-
-#include <pthread_np.h> /* pthread w/ affinity */
-#include <sys/cpuset.h> /* cpu_set */
-#include <net/if_dl.h>  /* LLADDR */
-#endif  /* __FreeBSD__ */
-
-#ifdef __APPLE__
-
-#define cpuset_t        uint64_t        // XXX
-static inline void CPU_ZERO(cpuset_t *p)
-{
-        *p = 0;
-}
-
-static inline void CPU_SET(uint32_t i, cpuset_t *p)
-{
-        *p |= 1<< (i & 0x3f);
-}
-
-#define pthread_setaffinity_np(a, b, c) ((void)a, 0)
-
-#define ifr_flagshigh  ifr_flags        // XXX
-#define IFF_PPROMISC   IFF_PROMISC
-#include <net/if_dl.h>  /* LLADDR */
-#define clock_gettime(a,b)      \
-        do {struct timespec t0 = {0,0}; *(b) = t0; } while (0)
-#endif  /* __APPLE__ */
-
-const char *default_payload="netmap pkt-gen DIRECT payload\n"
-	"http://info.iet.unipi.it/~luigi/netmap/ ";
-
-const char *indirect_payload="netmap pkt-gen indirect payload\n"
-	"http://info.iet.unipi.it/~luigi/netmap/ ";
-
-int verbose = 0;
-
-#define SKIP_PAYLOAD 1 /* do not check payload. XXX unused */
-
-
-#define VIRT_HDR_1	10	/* length of a base vnet-hdr */
-#define VIRT_HDR_2	12	/* length of the extenede vnet-hdr */
-#define VIRT_HDR_MAX	VIRT_HDR_2
-struct virt_header {
-	uint8_t fields[VIRT_HDR_MAX];
-};
-
-#define MAX_BODYSIZE	16384
-
-struct pkt {
-	struct virt_header vh;
-	struct ether_header eh;
-	struct ip ip;
-	struct udphdr udp;
-	uint8_t body[MAX_BODYSIZE];	// XXX hardwired
-} __attribute__((__packed__));
-
-struct ip_range {
-	char *name;
-	uint32_t start, end; /* same as struct in_addr */
-	uint16_t port0, port1;
-};
-
-struct mac_range {
-	char *name;
-	struct ether_addr start, end;
-};
-
-/* ifname can be netmap:foo-xxxx */
-#define MAX_IFNAMELEN	64	/* our buffer for ifname */
-//#define MAX_PKTSIZE	1536
-#define MAX_PKTSIZE	MAX_BODYSIZE	/* XXX: + IP_HDR + ETH_HDR */
-
-/* compact timestamp to fit into 60 byte packet. (enough to obtain RTT) */
-struct tstamp {
-	uint32_t sec;
-	uint32_t nsec;
-};
-
-/*
- * global arguments for all threads
- */
-
-struct glob_arg {
-	struct ip_range src_ip;
-	struct ip_range dst_ip;
-	struct mac_range dst_mac;
-	struct mac_range src_mac;
-	int pkt_size;
-	int burst;
-	int forever;
-	int npackets;	/* total packets to send */
-	int frags;	/* fragments per packet */
-	int nthreads;
-	int cpus;
-	int options;	/* testing */
-#define OPT_PREFETCH	1
-#define OPT_ACCESS	2
-#define OPT_COPY	4
-#define OPT_MEMCPY	8
-#define OPT_TS		16	/* add a timestamp */
-#define OPT_INDIRECT	32	/* use indirect buffers, tx only */
-#define OPT_DUMP	64	/* dump rx/tx traffic */
-#define OPT_MONITOR_TX  128
-#define OPT_MONITOR_RX  256
-	int dev_type;
-#ifndef NO_PCAP
-	pcap_t *p;
-#endif
-
-	int tx_rate;
-	struct timespec tx_period;
-
-	int affinity;
-	int main_fd;
-	struct nm_desc *nmd;
-	int report_interval;		/* milliseconds between prints */
-	void *(*td_body)(void *);
-	void *mmap_addr;
-	char ifname[MAX_IFNAMELEN];
-	char *nmr_config;
-	int dummy_send;
-	int virt_header;	/* send also the virt_header */
-	int extra_bufs;		/* goes in nr_arg3 */
-};
-enum dev_type { DEV_NONE, DEV_NETMAP, DEV_PCAP, DEV_TAP };
-
-
-/*
- * Arguments for a new thread. The same structure is used by
- * the source and the sink
- */
-struct targ {
-	struct glob_arg *g;
-	int used;
-	int completed;
-	int cancel;
-	int fd;
-	struct nm_desc *nmd;
-	volatile uint64_t count;
-	struct timespec tic, toc;
-	int me;
-	pthread_t thread;
-	int affinity;
-
-	struct pkt pkt;
-};
-
-
-/*
- * extract the extremes from a range of ipv4 addresses.
- * addr_lo[-addr_hi][:port_lo[-port_hi]]
- */
-static void
-extract_ip_range(struct ip_range *r)
-{
-	char *ap, *pp;
-	struct in_addr a;
-
-	if (verbose)
-		D("extract IP range from %s", r->name);
-	r->port0 = r->port1 = 0;
-	r->start = r->end = 0;
-
-	/* the first - splits start/end of range */
-	ap = index(r->name, '-');	/* do we have ports ? */
-	if (ap) {
-		*ap++ = '\0';
-	}
-	/* grab the initial values (mandatory) */
-	pp = index(r->name, ':');
-	if (pp) {
-		*pp++ = '\0';
-		r->port0 = r->port1 = strtol(pp, NULL, 0);
-	};
-	inet_aton(r->name, &a);
-	r->start = r->end = ntohl(a.s_addr);
-	if (ap) {
-		pp = index(ap, ':');
-		if (pp) {
-			*pp++ = '\0';
-			if (*pp)
-				r->port1 = strtol(pp, NULL, 0);
-		}
-		if (*ap) {
-			inet_aton(ap, &a);
-			r->end = ntohl(a.s_addr);
-		}
-	}
-	if (r->port0 > r->port1) {
-		uint16_t tmp = r->port0;
-		r->port0 = r->port1;
-		r->port1 = tmp;
-	}
-	if (r->start > r->end) {
-		uint32_t tmp = r->start;
-		r->start = r->end;
-		r->end = tmp;
-	}
-	{
-		struct in_addr a;
-		char buf1[16]; // one ip address
-
-		a.s_addr = htonl(r->end);
-		strncpy(buf1, inet_ntoa(a), sizeof(buf1));
-		a.s_addr = htonl(r->start);
-		if (1)
-		    D("range is %s:%d to %s:%d",
-			inet_ntoa(a), r->port0, buf1, r->port1);
-	}
-}
-
-static void
-extract_mac_range(struct mac_range *r)
-{
-	if (verbose)
-	    D("extract MAC range from %s", r->name);
-	bcopy(ether_aton(r->name), &r->start, 6);
-	bcopy(ether_aton(r->name), &r->end, 6);
-#if 0
-	bcopy(targ->src_mac, eh->ether_shost, 6);
-	p = index(targ->g->src_mac, '-');
-	if (p)
-		targ->src_mac_range = atoi(p+1);
-
-	bcopy(ether_aton(targ->g->dst_mac), targ->dst_mac, 6);
-	bcopy(targ->dst_mac, eh->ether_dhost, 6);
-	p = index(targ->g->dst_mac, '-');
-	if (p)
-		targ->dst_mac_range = atoi(p+1);
-#endif
-	if (verbose)
-		D("%s starts at %s", r->name, ether_ntoa(&r->start));
-}
-
-static struct targ *targs;
-static int global_nthreads;
-
-/* control-C handler */
-static void
-sigint_h(int sig)
-{
-	int i;
-
-	(void)sig;	/* UNUSED */
-	for (i = 0; i < global_nthreads; i++) {
-		targs[i].cancel = 1;
-	}
-	signal(SIGINT, SIG_DFL);
-}
-
-/* sysctl wrapper to return the number of active CPUs */
-static int
-system_ncpus(void)
-{
-	int ncpus;
-#if defined (__FreeBSD__)
-	int mib[2] = { CTL_HW, HW_NCPU };
-	size_t len = sizeof(mib);
-	sysctl(mib, 2, &ncpus, &len, NULL, 0);
-#elif defined(linux)
-	ncpus = sysconf(_SC_NPROCESSORS_ONLN);
-#else /* others */
-	ncpus = 1;
-#endif /* others */
-	return (ncpus);
-}
-
-#ifdef __linux__
-#define sockaddr_dl    sockaddr_ll
-#define sdl_family     sll_family
-#define AF_LINK        AF_PACKET
-#define LLADDR(s)      s->sll_addr;
-#include <linux/if_tun.h>
-#define TAP_CLONEDEV	"/dev/net/tun"
-#endif /* __linux__ */
-
-#ifdef __FreeBSD__
-#include <net/if_tun.h>
-#define TAP_CLONEDEV	"/dev/tap"
-#endif /* __FreeBSD */
-
-#ifdef __APPLE__
-// #warning TAP not supported on apple ?
-#include <net/if_utun.h>
-#define TAP_CLONEDEV	"/dev/tap"
-#endif /* __APPLE__ */
-
-
-/*
- * parse the vale configuration in conf and put it in nmr.
- * Return the flag set if necessary.
- * The configuration may consist of 0 to 4 numbers separated
- * by commas: #tx-slots,#rx-slots,#tx-rings,#rx-rings.
- * Missing numbers or zeroes stand for default values.
- * As an additional convenience, if exactly one number
- * is specified, then this is assigned to both #tx-slots and #rx-slots.
- * If there is no 4th number, then the 3rd is assigned to both #tx-rings
- * and #rx-rings.
- */
-int
-parse_nmr_config(const char* conf, struct nmreq *nmr)
-{
-	char *w, *tok;
-	int i, v;
-
-	nmr->nr_tx_rings = nmr->nr_rx_rings = 0;
-	nmr->nr_tx_slots = nmr->nr_rx_slots = 0;
-	if (conf == NULL || ! *conf)
-		return 0;
-	w = strdup(conf);
-	for (i = 0, tok = strtok(w, ","); tok; i++, tok = strtok(NULL, ",")) {
-		v = atoi(tok);
-		switch (i) {
-		case 0:
-			nmr->nr_tx_slots = nmr->nr_rx_slots = v;
-			break;
-		case 1:
-			nmr->nr_rx_slots = v;
-			break;
-		case 2:
-			nmr->nr_tx_rings = nmr->nr_rx_rings = v;
-			break;
-		case 3:
-			nmr->nr_rx_rings = v;
-			break;
-		default:
-			D("ignored config: %s", tok);
-			break;
-		}
-	}
-	D("txr %d txd %d rxr %d rxd %d",
-			nmr->nr_tx_rings, nmr->nr_tx_slots,
-			nmr->nr_rx_rings, nmr->nr_rx_slots);
-	free(w);
-	return (nmr->nr_tx_rings || nmr->nr_tx_slots ||
-                        nmr->nr_rx_rings || nmr->nr_rx_slots) ?
-		NM_OPEN_RING_CFG : 0;
-}
-
-
-/*
- * locate the src mac address for our interface, put it
- * into the user-supplied buffer. return 0 if ok, -1 on error.
- */
-static int
-source_hwaddr(const char *ifname, char *buf)
-{
-	struct ifaddrs *ifaphead, *ifap;
-	int l = sizeof(ifap->ifa_name);
-
-	if (getifaddrs(&ifaphead) != 0) {
-		D("getifaddrs %s failed", ifname);
-		return (-1);
-	}
-
-	for (ifap = ifaphead; ifap; ifap = ifap->ifa_next) {
-		struct sockaddr_dl *sdl =
-			(struct sockaddr_dl *)ifap->ifa_addr;
-		uint8_t *mac;
-
-		if (!sdl || sdl->sdl_family != AF_LINK)
-			continue;
-		if (strncmp(ifap->ifa_name, ifname, l) != 0)
-			continue;
-		mac = (uint8_t *)LLADDR(sdl);
-		sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",
-			mac[0], mac[1], mac[2],
-			mac[3], mac[4], mac[5]);
-		if (verbose)
-			D("source hwaddr %s", buf);
-		break;
-	}
-	freeifaddrs(ifaphead);
-	return ifap ? 0 : 1;
-}
-
-
-/* set the thread affinity. */
-static int
-setaffinity(pthread_t me, int i)
-{
-	cpuset_t cpumask;
-
-	if (i == -1)
-		return 0;
-
-	/* Set thread affinity affinity.*/
-	CPU_ZERO(&cpumask);
-	CPU_SET(i, &cpumask);
-
-	if (pthread_setaffinity_np(me, sizeof(cpuset_t), &cpumask) != 0) {
-		D("Unable to set affinity: %s", strerror(errno));
-		return 1;
-	}
-	return 0;
-}
-
-/* Compute the checksum of the given ip header. */
-static uint16_t
-checksum(const void *data, uint16_t len, uint32_t sum)
-{
-        const uint8_t *addr = data;
-	uint32_t i;
-
-        /* Checksum all the pairs of bytes first... */
-        for (i = 0; i < (len & ~1U); i += 2) {
-                sum += (u_int16_t)ntohs(*((u_int16_t *)(addr + i)));
-                if (sum > 0xFFFF)
-                        sum -= 0xFFFF;
-        }
-	/*
-	 * If there's a single byte left over, checksum it, too.
-	 * Network byte order is big-endian, so the remaining byte is
-	 * the high byte.
-	 */
-	if (i < len) {
-		sum += addr[i] << 8;
-		if (sum > 0xFFFF)
-			sum -= 0xFFFF;
-	}
-	return sum;
-}
-
-static u_int16_t
-wrapsum(u_int32_t sum)
-{
-	sum = ~sum & 0xFFFF;
-	return (htons(sum));
-}
-
-/* Check the payload of the packet for errors (use it for debug).
- * Look for consecutive ascii representations of the size of the packet.
- */
-static void
-dump_payload(char *p, int len, struct netmap_ring *ring, int cur)
-{
-	char buf[128];
-	int i, j, i0;
-
-	/* get the length in ASCII of the length of the packet. */
-
-	printf("ring %p cur %5d [buf %6d flags 0x%04x len %5d]\n",
-		ring, cur, ring->slot[cur].buf_idx,
-		ring->slot[cur].flags, len);
-	/* hexdump routine */
-	for (i = 0; i < len; ) {
-		memset(buf, sizeof(buf), ' ');
-		sprintf(buf, "%5d: ", i);
-		i0 = i;
-		for (j=0; j < 16 && i < len; i++, j++)
-			sprintf(buf+7+j*3, "%02x ", (uint8_t)(p[i]));
-		i = i0;
-		for (j=0; j < 16 && i < len; i++, j++)
-			sprintf(buf+7+j + 48, "%c",
-				isprint(p[i]) ? p[i] : '.');
-		printf("%s\n", buf);
-	}
-}
-
-/*
- * Fill a packet with some payload.
- * We create a UDP packet so the payload starts at
- *	14+20+8 = 42 bytes.
- */
-#ifdef __linux__
-#define uh_sport source
-#define uh_dport dest
-#define uh_ulen len
-#define uh_sum check
-#endif /* linux */
-
-/*
- * increment the addressed in the packet,
- * starting from the least significant field.
- *	DST_IP DST_PORT SRC_IP SRC_PORT
- */
-static void
-update_addresses(struct pkt *pkt, struct glob_arg *g)
-{
-	uint32_t a;
-	uint16_t p;
-	struct ip *ip = &pkt->ip;
-	struct udphdr *udp = &pkt->udp;
-
-    do {
-	p = ntohs(udp->uh_sport);
-	if (p < g->src_ip.port1) { /* just inc, no wrap */
-		udp->uh_sport = htons(p + 1);
-		break;
-	}
-	udp->uh_sport = htons(g->src_ip.port0);
-
-	a = ntohl(ip->ip_src.s_addr);
-	if (a < g->src_ip.end) { /* just inc, no wrap */
-		ip->ip_src.s_addr = htonl(a + 1);
-		break;
-	}
-	ip->ip_src.s_addr = htonl(g->src_ip.start);
-
-	udp->uh_sport = htons(g->src_ip.port0);
-	p = ntohs(udp->uh_dport);
-	if (p < g->dst_ip.port1) { /* just inc, no wrap */
-		udp->uh_dport = htons(p + 1);
-		break;
-	}
-	udp->uh_dport = htons(g->dst_ip.port0);
-
-	a = ntohl(ip->ip_dst.s_addr);
-	if (a < g->dst_ip.end) { /* just inc, no wrap */
-		ip->ip_dst.s_addr = htonl(a + 1);
-		break;
-	}
-	ip->ip_dst.s_addr = htonl(g->dst_ip.start);
-    } while (0);
-    // update checksum
-}
-
-/*
- * initialize one packet and prepare for the next one.
- * The copy could be done better instead of repeating it each time.
- */
-static void
-initialize_packet(struct targ *targ)
-{
-	struct pkt *pkt = &targ->pkt;
-	struct ether_header *eh;
-	struct ip *ip;
-	struct udphdr *udp;
-	uint16_t paylen = targ->g->pkt_size - sizeof(*eh) - sizeof(struct ip);
-	const char *payload = targ->g->options & OPT_INDIRECT ?
-		indirect_payload : default_payload;
-	int i, l0 = strlen(payload);
-
-	/* create a nice NUL-terminated string */
-	for (i = 0; i < paylen; i += l0) {
-		if (l0 > paylen - i)
-			l0 = paylen - i; // last round
-		bcopy(payload, pkt->body + i, l0);
-	}
-	pkt->body[i-1] = '\0';
-	ip = &pkt->ip;
-
-	/* prepare the headers */
-        ip->ip_v = IPVERSION;
-        ip->ip_hl = 5;
-        ip->ip_id = 0;
-        ip->ip_tos = IPTOS_LOWDELAY;
-	ip->ip_len = ntohs(targ->g->pkt_size - sizeof(*eh));
-        ip->ip_id = 0;
-        ip->ip_off = htons(IP_DF); /* Don't fragment */
-        ip->ip_ttl = IPDEFTTL;
-	ip->ip_p = IPPROTO_UDP;
-	ip->ip_dst.s_addr = htonl(targ->g->dst_ip.start);
-	ip->ip_src.s_addr = htonl(targ->g->src_ip.start);
-	ip->ip_sum = wrapsum(checksum(ip, sizeof(*ip), 0));
-
-
-	udp = &pkt->udp;
-        udp->uh_sport = htons(targ->g->src_ip.port0);
-        udp->uh_dport = htons(targ->g->dst_ip.port0);
-	udp->uh_ulen = htons(paylen);
-	/* Magic: taken from sbin/dhclient/packet.c */
-	udp->uh_sum = wrapsum(checksum(udp, sizeof(*udp),
-                    checksum(pkt->body,
-                        paylen - sizeof(*udp),
-                        checksum(&ip->ip_src, 2 * sizeof(ip->ip_src),
-                            IPPROTO_UDP + (u_int32_t)ntohs(udp->uh_ulen)
-                        )
-                    )
-                ));
-
-	eh = &pkt->eh;
-	bcopy(&targ->g->src_mac.start, eh->ether_shost, 6);
-	bcopy(&targ->g->dst_mac.start, eh->ether_dhost, 6);
-	eh->ether_type = htons(ETHERTYPE_IP);
-
-	bzero(&pkt->vh, sizeof(pkt->vh));
-	// dump_payload((void *)pkt, targ->g->pkt_size, NULL, 0);
-}
-
-
-
-/*
- * create and enqueue a batch of packets on a ring.
- * On the last one set NS_REPORT to tell the driver to generate
- * an interrupt when done.
- */
-static int
-send_packets(struct netmap_ring *ring, struct pkt *pkt, void *frame,
-		int size, struct glob_arg *g, u_int count, int options,
-		u_int nfrags)
-{
-	u_int n, sent, cur = ring->cur;
-	u_int fcnt;
-
-	n = nm_ring_space(ring);
-	if (n < count)
-		count = n;
-	if (count < nfrags) {
-		D("truncating packet, no room for frags %d %d",
-				count, nfrags);
-	}
-#if 0
-	if (options & (OPT_COPY | OPT_PREFETCH) ) {
-		for (sent = 0; sent < count; sent++) {
-			struct netmap_slot *slot = &ring->slot[cur];
-			char *p = NETMAP_BUF(ring, slot->buf_idx);
-
-			__builtin_prefetch(p);
-			cur = nm_ring_next(ring, cur);
-		}
-		cur = ring->cur;
-	}
-#endif
-	for (fcnt = nfrags, sent = 0; sent < count; sent++) {
-		struct netmap_slot *slot = &ring->slot[cur];
-		char *p = NETMAP_BUF(ring, slot->buf_idx);
-
-		slot->flags = 0;
-		if (options & OPT_INDIRECT) {
-			slot->flags |= NS_INDIRECT;
-			slot->ptr = (uint64_t)((uintptr_t)frame);
-		} else if (options & OPT_COPY) {
-			nm_pkt_copy(frame, p, size);
-			if (fcnt == nfrags)
-				update_addresses(pkt, g);
-		} else if (options & OPT_MEMCPY) {
-			memcpy(p, frame, size);
-			if (fcnt == nfrags)
-				update_addresses(pkt, g);
-		} else if (options & OPT_PREFETCH) {
-			__builtin_prefetch(p);
-		}
-		if (options & OPT_DUMP)
-			dump_payload(p, size, ring, cur);
-		slot->len = size;
-		if (--fcnt > 0)
-			slot->flags |= NS_MOREFRAG;
-		else
-			fcnt = nfrags;
-		if (sent == count - 1) {
-			slot->flags &= ~NS_MOREFRAG;
-			slot->flags |= NS_REPORT;
-		}
-		cur = nm_ring_next(ring, cur);
-	}
-	ring->head = ring->cur = cur;
-
-	return (sent);
-}
-
-/*
- * Send a packet, and wait for a response.
- * The payload (after UDP header, ofs 42) has a 4-byte sequence
- * followed by a struct timeval (or bintime?)
- */
-#define	PAY_OFS	42	/* where in the pkt... */
-
-static void *
-pinger_body(void *data)
-{
-	struct targ *targ = (struct targ *) data;
-	struct pollfd pfd = { .fd = targ->fd, .events = POLLIN };
-	struct netmap_if *nifp = targ->nmd->nifp;
-	int i, rx = 0, n = targ->g->npackets;
-	void *frame;
-	int size;
-	uint32_t sent = 0;
-	struct timespec ts, now, last_print;
-	uint32_t count = 0, min = 1000000000, av = 0;
-
-	frame = &targ->pkt;
-	frame += sizeof(targ->pkt.vh) - targ->g->virt_header;
-	size = targ->g->pkt_size + targ->g->virt_header;
-
-
-	if (targ->g->nthreads > 1) {
-		D("can only ping with 1 thread");
-		return NULL;
-	}
-
-	clock_gettime(CLOCK_REALTIME_PRECISE, &last_print);
-	now = last_print;
-	while (n == 0 || (int)sent < n) {
-		struct netmap_ring *ring = NETMAP_TXRING(nifp, 0);
-		struct netmap_slot *slot;
-		char *p;
-	    for (i = 0; i < 1; i++) { /* XXX why the loop for 1 pkt ? */
-		slot = &ring->slot[ring->cur];
-		slot->len = size;
-		p = NETMAP_BUF(ring, slot->buf_idx);
-
-		if (nm_ring_empty(ring)) {
-			D("-- ouch, cannot send");
-		} else {
-			struct tstamp *tp;
-			nm_pkt_copy(frame, p, size);
-			clock_gettime(CLOCK_REALTIME_PRECISE, &ts);
-			bcopy(&sent, p+42, sizeof(sent));
-			tp = (struct tstamp *)(p+46);
-			tp->sec = (uint32_t)ts.tv_sec;
-			tp->nsec = (uint32_t)ts.tv_nsec;
-			sent++;
-			ring->head = ring->cur = nm_ring_next(ring, ring->cur);
-		}
-	    }
-		/* should use a parameter to decide how often to send */
-		if (poll(&pfd, 1, 3000) <= 0) {
-			D("poll error/timeout on queue %d: %s", targ->me,
-				strerror(errno));
-			continue;
-		}
-		/* see what we got back */
-		for (i = targ->nmd->first_tx_ring;
-			i <= targ->nmd->last_tx_ring; i++) {
-			ring = NETMAP_RXRING(nifp, i);
-			while (!nm_ring_empty(ring)) {
-				uint32_t seq;
-				struct tstamp *tp;
-				slot = &ring->slot[ring->cur];
-				p = NETMAP_BUF(ring, slot->buf_idx);
-
-				clock_gettime(CLOCK_REALTIME_PRECISE, &now);
-				bcopy(p+42, &seq, sizeof(seq));
-				tp = (struct tstamp *)(p+46);
-				ts.tv_sec = (time_t)tp->sec;
-				ts.tv_nsec = (long)tp->nsec;
-				ts.tv_sec = now.tv_sec - ts.tv_sec;
-				ts.tv_nsec = now.tv_nsec - ts.tv_nsec;
-				if (ts.tv_nsec < 0) {
-					ts.tv_nsec += 1000000000;
-					ts.tv_sec--;
-				}
-				if (1) D("seq %d/%d delta %d.%09d", seq, sent,
-					(int)ts.tv_sec, (int)ts.tv_nsec);
-				if (ts.tv_nsec < (int)min)
-					min = ts.tv_nsec;
-				count ++;
-				av += ts.tv_nsec;
-				ring->head = ring->cur = nm_ring_next(ring, ring->cur);
-				rx++;
-			}
-		}
-		//D("tx %d rx %d", sent, rx);
-		//usleep(100000);
-		ts.tv_sec = now.tv_sec - last_print.tv_sec;
-		ts.tv_nsec = now.tv_nsec - last_print.tv_nsec;
-		if (ts.tv_nsec < 0) {
-			ts.tv_nsec += 1000000000;
-			ts.tv_sec--;
-		}
-		if (ts.tv_sec >= 1) {
-			D("count %d min %d av %d",
-				count, min, av/count);
-			count = 0;
-			av = 0;
-			min = 100000000;
-			last_print = now;
-		}
-	}
-	return NULL;
-}
-
-
-/*
- * reply to ping requests
- */
-static void *
-ponger_body(void *data)
-{
-	struct targ *targ = (struct targ *) data;
-	struct pollfd pfd = { .fd = targ->fd, .events = POLLIN };
-	struct netmap_if *nifp = targ->nmd->nifp;
-	struct netmap_ring *txring, *rxring;
-	int i, rx = 0, sent = 0, n = targ->g->npackets;
-
-	if (targ->g->nthreads > 1) {
-		D("can only reply ping with 1 thread");
-		return NULL;
-	}
-	D("understood ponger %d but don't know how to do it", n);
-	while (n == 0 || sent < n) {
-		uint32_t txcur, txavail;
-//#define BUSYWAIT
-#ifdef BUSYWAIT
-		ioctl(pfd.fd, NIOCRXSYNC, NULL);
-#else
-		if (poll(&pfd, 1, 1000) <= 0) {
-			D("poll error/timeout on queue %d: %s", targ->me,
-				strerror(errno));
-			continue;
-		}
-#endif
-		txring = NETMAP_TXRING(nifp, 0);
-		txcur = txring->cur;
-		txavail = nm_ring_space(txring);
-		/* see what we got back */
-		for (i = targ->nmd->first_rx_ring; i <= targ->nmd->last_rx_ring; i++) {
-			rxring = NETMAP_RXRING(nifp, i);
-			while (!nm_ring_empty(rxring)) {
-				uint16_t *spkt, *dpkt;
-				uint32_t cur = rxring->cur;
-				struct netmap_slot *slot = &rxring->slot[cur];
-				char *src, *dst;
-				src = NETMAP_BUF(rxring, slot->buf_idx);
-				//D("got pkt %p of size %d", src, slot->len);
-				rxring->head = rxring->cur = nm_ring_next(rxring, cur);
-				rx++;
-				if (txavail == 0)
-					continue;
-				dst = NETMAP_BUF(txring,
-				    txring->slot[txcur].buf_idx);
-				/* copy... */
-				dpkt = (uint16_t *)dst;
-				spkt = (uint16_t *)src;
-				nm_pkt_copy(src, dst, slot->len);
-				dpkt[0] = spkt[3];
-				dpkt[1] = spkt[4];
-				dpkt[2] = spkt[5];
-				dpkt[3] = spkt[0];
-				dpkt[4] = spkt[1];
-				dpkt[5] = spkt[2];
-				txring->slot[txcur].len = slot->len;
-				/* XXX swap src dst mac */
-				txcur = nm_ring_next(txring, txcur);
-				txavail--;
-				sent++;
-			}
-		}
-		txring->head = txring->cur = txcur;
-		targ->count = sent;
-#ifdef BUSYWAIT
-		ioctl(pfd.fd, NIOCTXSYNC, NULL);
-#endif
-		//D("tx %d rx %d", sent, rx);
-	}
-	return NULL;
-}
-
-static __inline int
-timespec_ge(const struct timespec *a, const struct timespec *b)
-{
-
-	if (a->tv_sec > b->tv_sec)
-		return (1);
-	if (a->tv_sec < b->tv_sec)
-		return (0);
-	if (a->tv_nsec >= b->tv_nsec)
-		return (1);
-	return (0);
-}
-
-static __inline struct timespec
-timeval2spec(const struct timeval *a)
-{
-	struct timespec ts = {
-		.tv_sec = a->tv_sec,
-		.tv_nsec = a->tv_usec * 1000
-	};
-	return ts;
-}
-
-static __inline struct timeval
-timespec2val(const struct timespec *a)
-{
-	struct timeval tv = {
-		.tv_sec = a->tv_sec,
-		.tv_usec = a->tv_nsec / 1000
-	};
-	return tv;
-}
-
-
-static __inline struct timespec
-timespec_add(struct timespec a, struct timespec b)
-{
-	struct timespec ret = { a.tv_sec + b.tv_sec, a.tv_nsec + b.tv_nsec };
-	if (ret.tv_nsec >= 1000000000) {
-		ret.tv_sec++;
-		ret.tv_nsec -= 1000000000;
-	}
-	return ret;
-}
-
-static __inline struct timespec
-timespec_sub(struct timespec a, struct timespec b)
-{
-	struct timespec ret = { a.tv_sec - b.tv_sec, a.tv_nsec - b.tv_nsec };
-	if (ret.tv_nsec < 0) {
-		ret.tv_sec--;
-		ret.tv_nsec += 1000000000;
-	}
-	return ret;
-}
-
-
-/*
- * wait until ts, either busy or sleeping if more than 1ms.
- * Return wakeup time.
- */
-static struct timespec
-wait_time(struct timespec ts)
-{
-	for (;;) {
-		struct timespec w, cur;
-		clock_gettime(CLOCK_REALTIME_PRECISE, &cur);
-		w = timespec_sub(ts, cur);
-		if (w.tv_sec < 0)
-			return cur;
-		else if (w.tv_sec > 0 || w.tv_nsec > 1000000)
-			poll(NULL, 0, 1);
-	}
-}
-
-static void *
-sender_body(void *data)
-{
-	struct targ *targ = (struct targ *) data;
-	struct pollfd pfd = { .fd = targ->fd, .events = POLLOUT };
-	struct netmap_if *nifp;
-	struct netmap_ring *txring;
-	int i, n = targ->g->npackets / targ->g->nthreads;
-	int64_t sent = 0;
-	int options = targ->g->options | OPT_COPY;
-	struct timespec nexttime = { 0, 0}; // XXX silence compiler
-	int rate_limit = targ->g->tx_rate;
-	struct pkt *pkt = &targ->pkt;
-	void *frame;
-	int size;
-
-	frame = pkt;
-	frame += sizeof(pkt->vh) - targ->g->virt_header;
-	size = targ->g->pkt_size + targ->g->virt_header;
-
-	D("start, fd %d main_fd %d", targ->fd, targ->g->main_fd);
-	if (setaffinity(targ->thread, targ->affinity))
-		goto quit;
-
-	/* main loop.*/
-	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->tic);
-	if (rate_limit) {
-		targ->tic = timespec_add(targ->tic, (struct timespec){2,0});
-		targ->tic.tv_nsec = 0;
-		wait_time(targ->tic);
-		nexttime = targ->tic;
-	}
-        if (targ->g->dev_type == DEV_TAP) {
-	    D("writing to file desc %d", targ->g->main_fd);
-
-	    for (i = 0; !targ->cancel && (n == 0 || sent < n); i++) {
-		if (write(targ->g->main_fd, frame, size) != -1)
-			sent++;
-		update_addresses(pkt, targ->g);
-		if (i > 10000) {
-			targ->count = sent;
-			i = 0;
-		}
-	    }
-#ifndef NO_PCAP
-    } else if (targ->g->dev_type == DEV_PCAP) {
-	    pcap_t *p = targ->g->p;
-
-	    for (i = 0; !targ->cancel && (n == 0 || sent < n); i++) {
-		if (pcap_inject(p, frame, size) != -1)
-			sent++;
-		update_addresses(pkt, targ->g);
-		if (i > 10000) {
-			targ->count = sent;
-			i = 0;
-		}
-	    }
-#endif /* NO_PCAP */
-    } else {
-	int tosend = 0;
-	int frags = targ->g->frags;
-
-        nifp = targ->nmd->nifp;
-	while (!targ->cancel && (n == 0 || sent < n)) {
-
-		if (rate_limit && tosend <= 0) {
-			tosend = targ->g->burst;
-			nexttime = timespec_add(nexttime, targ->g->tx_period);
-			wait_time(nexttime);
-		}
-
-		/*
-		 * wait for available room in the send queue(s)
-		 */
-		if (poll(&pfd, 1, 2000) <= 0) {
-			if (targ->cancel)
-				break;
-			D("poll error/timeout on queue %d: %s", targ->me,
-				strerror(errno));
-			// goto quit;
-		}
-		if (pfd.revents & POLLERR) {
-			D("poll error");
-			goto quit;
-		}
-		/*
-		 * scan our queues and send on those with room
-		 */
-		if (options & OPT_COPY && sent > 100000 && !(targ->g->options & OPT_COPY) ) {
-			D("drop copy");
-			options &= ~OPT_COPY;
-		}
-		for (i = targ->nmd->first_tx_ring; i <= targ->nmd->last_tx_ring; i++) {
-			int m, limit = rate_limit ?  tosend : targ->g->burst;
-			if (n > 0 && n - sent < limit)
-				limit = n - sent;
-			txring = NETMAP_TXRING(nifp, i);
-			if (nm_ring_empty(txring))
-				continue;
-			if (frags > 1)
-				limit = ((limit + frags - 1) / frags) * frags;
-
-			m = send_packets(txring, pkt, frame, size, targ->g,
-					 limit, options, frags);
-			ND("limit %d tail %d frags %d m %d",
-				limit, txring->tail, frags, m);
-			sent += m;
-			targ->count = sent;
-			if (rate_limit) {
-				tosend -= m;
-				if (tosend <= 0)
-					break;
-			}
-		}
-	}
-	/* flush any remaining packets */
-	ioctl(pfd.fd, NIOCTXSYNC, NULL);
-
-	/* final part: wait all the TX queues to be empty. */
-	for (i = targ->nmd->first_tx_ring; i <= targ->nmd->last_tx_ring; i++) {
-		txring = NETMAP_TXRING(nifp, i);
-		while (nm_tx_pending(txring)) {
-			ioctl(pfd.fd, NIOCTXSYNC, NULL);
-			usleep(1); /* wait 1 tick */
-		}
-	}
-    } /* end DEV_NETMAP */
-
-	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->toc);
-	targ->completed = 1;
-	targ->count = sent;
-
-quit:
-	/* reset the ``used`` flag. */
-	targ->used = 0;
-
-	return (NULL);
-}
-
-
-#ifndef NO_PCAP
-static void
-receive_pcap(u_char *user, const struct pcap_pkthdr * h,
-	const u_char * bytes)
-{
-	int *count = (int *)user;
-	(void)h;	/* UNUSED */
-	(void)bytes;	/* UNUSED */
-	(*count)++;
-}
-#endif /* !NO_PCAP */
-
-static int
-receive_packets(struct netmap_ring *ring, u_int limit, int dump)
-{
-	u_int cur, rx, n;
-
-	cur = ring->cur;
-	n = nm_ring_space(ring);
-	if (n < limit)
-		limit = n;
-	for (rx = 0; rx < limit; rx++) {
-		struct netmap_slot *slot = &ring->slot[cur];
-		char *p = NETMAP_BUF(ring, slot->buf_idx);
-
-		if (dump)
-			dump_payload(p, slot->len, ring, cur);
-
-		cur = nm_ring_next(ring, cur);
-	}
-	ring->head = ring->cur = cur;
-
-	return (rx);
-}
-
-static void *
-receiver_body(void *data)
-{
-	struct targ *targ = (struct targ *) data;
-	struct pollfd pfd = { .fd = targ->fd, .events = POLLIN };
-	struct netmap_if *nifp;
-	struct netmap_ring *rxring;
-	int i;
-	uint64_t received = 0;
-
-	if (setaffinity(targ->thread, targ->affinity))
-		goto quit;
-
-	D("reading from %s fd %d main_fd %d",
-		targ->g->ifname, targ->fd, targ->g->main_fd);
-	/* unbounded wait for the first packet. */
-	for (;!targ->cancel;) {
-		i = poll(&pfd, 1, 1000);
-		if (i > 0 && !(pfd.revents & POLLERR))
-			break;
-		RD(1, "waiting for initial packets, poll returns %d %d",
-			i, pfd.revents);
-	}
-	/* main loop, exit after 1s silence */
-	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->tic);
-    if (targ->g->dev_type == DEV_TAP) {
-	while (!targ->cancel) {
-		char buf[MAX_BODYSIZE];
-		/* XXX should we poll ? */
-		if (read(targ->g->main_fd, buf, sizeof(buf)) > 0)
-			targ->count++;
-	}
-#ifndef NO_PCAP
-    } else if (targ->g->dev_type == DEV_PCAP) {
-	while (!targ->cancel) {
-		/* XXX should we poll ? */
-		pcap_dispatch(targ->g->p, targ->g->burst, receive_pcap,
-			(u_char *)&targ->count);
-	}
-#endif /* !NO_PCAP */
-    } else {
-	int dump = targ->g->options & OPT_DUMP;
-
-        nifp = targ->nmd->nifp;
-	while (!targ->cancel) {
-		/* Once we started to receive packets, wait at most 1 seconds
-		   before quitting. */
-		if (poll(&pfd, 1, 1 * 1000) <= 0 && !targ->g->forever) {
-			clock_gettime(CLOCK_REALTIME_PRECISE, &targ->toc);
-			targ->toc.tv_sec -= 1; /* Subtract timeout time. */
-			goto out;
-		}
-
-		if (pfd.revents & POLLERR) {
-			D("poll err");
-			goto quit;
-		}
-
-		for (i = targ->nmd->first_rx_ring; i <= targ->nmd->last_rx_ring; i++) {
-			int m;
-
-			rxring = NETMAP_RXRING(nifp, i);
-			if (nm_ring_empty(rxring))
-				continue;
-
-			m = receive_packets(rxring, targ->g->burst, dump);
-			received += m;
-		}
-		targ->count = received;
-	}
-    }
-
-	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->toc);
-
-out:
-	targ->completed = 1;
-	targ->count = received;
-
-quit:
-	/* reset the ``used`` flag. */
-	targ->used = 0;
-
-	return (NULL);
-}
-
-/* very crude code to print a number in normalized form.
- * Caller has to make sure that the buffer is large enough.
- */
-static const char *
-norm(char *buf, double val)
-{
-	char *units[] = { "", "K", "M", "G", "T" };
-	u_int i;
-
-	for (i = 0; val >=1000 && i < sizeof(units)/sizeof(char *) - 1; i++)
-		val /= 1000;
-	sprintf(buf, "%.2f %s", val, units[i]);
-	return buf;
-}
-
-static void
-tx_output(uint64_t sent, int size, double delta)
-{
-	double bw, raw_bw, pps;
-	char b1[40], b2[80], b3[80];
-
-	printf("Sent %llu packets, %d bytes each, in %.2f seconds.\n",
-	       (unsigned long long)sent, size, delta);
-	if (delta == 0)
-		delta = 1e-6;
-	if (size < 60)		/* correct for min packet size */
-		size = 60;
-	pps = sent / delta;
-	bw = (8.0 * size * sent) / delta;
-	/* raw packets have4 bytes crc + 20 bytes framing */
-	raw_bw = (8.0 * (size + 24) * sent) / delta;
-
-	printf("Speed: %spps Bandwidth: %sbps (raw %sbps)\n",
-		norm(b1, pps), norm(b2, bw), norm(b3, raw_bw) );
-}
-
-
-static void
-rx_output(uint64_t received, double delta)
-{
-	double pps;
-	char b1[40];
-
-	printf("Received %llu packets, in %.2f seconds.\n",
-		(unsigned long long) received, delta);
-
-	if (delta == 0)
-		delta = 1e-6;
-	pps = received / delta;
-	printf("Speed: %spps\n", norm(b1, pps));
-}
-
-static void
-usage(void)
-{
-	const char *cmd = "pkt-gen";
-	fprintf(stderr,
-		"Usage:\n"
-		"%s arguments\n"
-		"\t-i interface		interface name\n"
-		"\t-f function		tx rx ping pong\n"
-		"\t-n count		number of iterations (can be 0)\n"
-		"\t-t pkts_to_send		also forces tx mode\n"
-		"\t-r pkts_to_receive	also forces rx mode\n"
-		"\t-l pkt_size		in bytes excluding CRC\n"
-		"\t-d dst_ip[:port[-dst_ip:port]]   single or range\n"
-		"\t-s src_ip[:port[-src_ip:port]]   single or range\n"
-		"\t-D dst-mac\n"
-		"\t-S src-mac\n"
-		"\t-a cpu_id		use setaffinity\n"
-		"\t-b burst size		testing, mostly\n"
-		"\t-c cores		cores to use\n"
-		"\t-p threads		processes/threads to use\n"
-		"\t-T report_ms		milliseconds between reports\n"
-		"\t-P			use libpcap instead of netmap\n"
-		"\t-w wait_for_link_time	in seconds\n"
-		"\t-R rate		in packets per second\n"
-		"\t-X			dump payload\n"
-		"\t-H len		add empty virtio-net-header with size 'len'\n"
-		"",
-		cmd);
-
-	exit(0);
-}
-
-static void
-start_threads(struct glob_arg *g)
-{
-	int i;
-
-	targs = calloc(g->nthreads, sizeof(*targs));
-	/*
-	 * Now create the desired number of threads, each one
-	 * using a single descriptor.
- 	 */
-	for (i = 0; i < g->nthreads; i++) {
-		struct targ *t = &targs[i];
-
-		bzero(t, sizeof(*t));
-		t->fd = -1; /* default, with pcap */
-		t->g = g;
-
-	    if (g->dev_type == DEV_NETMAP) {
-		struct nm_desc nmd = *g->nmd; /* copy, we overwrite ringid */
-		uint64_t nmd_flags = 0;
-		nmd.self = &nmd;
-
-		if (g->nthreads > 1) {
-			if (nmd.req.nr_flags != NR_REG_ALL_NIC) {
-				D("invalid nthreads mode %d", nmd.req.nr_flags);
-				continue;
-			}
-			nmd.req.nr_flags = NR_REG_ONE_NIC;
-			nmd.req.nr_ringid = i;
-		}
-		/* Only touch one of the rings (rx is already ok) */
-		if (g->td_body == receiver_body)
-			nmd_flags |= NETMAP_NO_TX_POLL;
-
-		/* register interface. Override ifname and ringid etc. */
-		if (g->options & OPT_MONITOR_TX)
-			nmd.req.nr_flags |= NR_MONITOR_TX;
-		if (g->options & OPT_MONITOR_RX)
-			nmd.req.nr_flags |= NR_MONITOR_RX;
-
-		t->nmd = nm_open(t->g->ifname, NULL, nmd_flags |
-			NM_OPEN_IFNAME | NM_OPEN_NO_MMAP, &nmd);
-		if (t->nmd == NULL) {
-			D("Unable to open %s: %s",
-				t->g->ifname, strerror(errno));
-			continue;
-		}
-		t->fd = t->nmd->fd;
-
-	    } else {
-		targs[i].fd = g->main_fd;
-	    }
-		t->used = 1;
-		t->me = i;
-		if (g->affinity >= 0) {
-			if (g->affinity < g->cpus)
-				t->affinity = g->affinity;
-			else
-				t->affinity = i % g->cpus;
-		} else {
-			t->affinity = -1;
-		}
-		/* default, init packets */
-		initialize_packet(t);
-
-		if (pthread_create(&t->thread, NULL, g->td_body, t) == -1) {
-			D("Unable to create thread %d: %s", i, strerror(errno));
-			t->used = 0;
-		}
-	}
-}
-
-static void
-main_thread(struct glob_arg *g)
-{
-	int i;
-
-	uint64_t prev = 0;
-	uint64_t count = 0;
-	double delta_t;
-	struct timeval tic, toc;
-
-	gettimeofday(&toc, NULL);
-	for (;;) {
-		struct timeval now, delta;
-		uint64_t pps, usec, my_count, npkts;
-		int done = 0;
-
-		delta.tv_sec = g->report_interval/1000;
-		delta.tv_usec = (g->report_interval%1000)*1000;
-		select(0, NULL, NULL, NULL, &delta);
-		gettimeofday(&now, NULL);
-		timersub(&now, &toc, &toc);
-		my_count = 0;
-		for (i = 0; i < g->nthreads; i++) {
-			my_count += targs[i].count;
-			if (targs[i].used == 0)
-				done++;
-		}
-		usec = toc.tv_sec* 1000000 + toc.tv_usec;
-		if (usec < 10000)
-			continue;
-		npkts = my_count - prev;
-		pps = (npkts*1000000 + usec/2) / usec;
-		D("%llu pps (%llu pkts in %llu usec)",
-			(unsigned long long)pps,
-			(unsigned long long)npkts,
-			(unsigned long long)usec);
-		prev = my_count;
-		toc = now;
-		if (done == g->nthreads)
-			break;
-	}
-
-	timerclear(&tic);
-	timerclear(&toc);
-	for (i = 0; i < g->nthreads; i++) {
-		struct timespec t_tic, t_toc;
-		/*
-		 * Join active threads, unregister interfaces and close
-		 * file descriptors.
-		 */
-		if (targs[i].used)
-			pthread_join(targs[i].thread, NULL);
-		close(targs[i].fd);
-
-		if (targs[i].completed == 0)
-			D("ouch, thread %d exited with error", i);
-
-		/*
-		 * Collect threads output and extract information about
-		 * how long it took to send all the packets.
-		 */
-		count += targs[i].count;
-		t_tic = timeval2spec(&tic);
-		t_toc = timeval2spec(&toc);
-		if (!timerisset(&tic) || timespec_ge(&targs[i].tic, &t_tic))
-			tic = timespec2val(&targs[i].tic);
-		if (!timerisset(&toc) || timespec_ge(&targs[i].toc, &t_toc))
-			toc = timespec2val(&targs[i].toc);
-	}
-
-	/* print output. */
-	timersub(&toc, &tic, &toc);
-	delta_t = toc.tv_sec + 1e-6* toc.tv_usec;
-	if (g->td_body == sender_body)
-		tx_output(count, g->pkt_size, delta_t);
-	else
-		rx_output(count, delta_t);
-
-	if (g->dev_type == DEV_NETMAP) {
-		munmap(g->nmd->mem, g->nmd->req.nr_memsize);
-		close(g->main_fd);
-	}
-}
-
-
-struct sf {
-	char *key;
-	void *f;
-};
-
-static struct sf func[] = {
-	{ "tx",	sender_body },
-	{ "rx",	receiver_body },
-	{ "ping",	pinger_body },
-	{ "pong",	ponger_body },
-	{ NULL, NULL }
-};
-
-static int
-tap_alloc(char *dev)
-{
-	struct ifreq ifr;
-	int fd, err;
-	char *clonedev = TAP_CLONEDEV;
-
-	(void)err;
-	(void)dev;
-	/* Arguments taken by the function:
-	 *
-	 * char *dev: the name of an interface (or '\0'). MUST have enough
-	 *   space to hold the interface name if '\0' is passed
-	 * int flags: interface flags (eg, IFF_TUN etc.)
-	 */
-
-#ifdef __FreeBSD__
-	if (dev[3]) { /* tapSomething */
-		static char buf[128];
-		snprintf(buf, sizeof(buf), "/dev/%s", dev);
-		clonedev = buf;
-	}
-#endif
-	/* open the device */
-	if( (fd = open(clonedev, O_RDWR)) < 0 ) {
-		return fd;
-	}
-	D("%s open successful", clonedev);
-
-	/* preparation of the struct ifr, of type "struct ifreq" */
-	memset(&ifr, 0, sizeof(ifr));
-
-#ifdef linux
-	ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
-
-	if (*dev) {
-		/* if a device name was specified, put it in the structure; otherwise,
-		* the kernel will try to allocate the "next" device of the
-		* specified type */
-		strncpy(ifr.ifr_name, dev, IFNAMSIZ);
-	}
-
-	/* try to create the device */
-	if( (err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0 ) {
-		D("failed to to a TUNSETIFF: %s", strerror(errno));
-		close(fd);
-		return err;
-	}
-
-	/* if the operation was successful, write back the name of the
-	* interface to the variable "dev", so the caller can know
-	* it. Note that the caller MUST reserve space in *dev (see calling
-	* code below) */
-	strcpy(dev, ifr.ifr_name);
-	D("new name is %s", dev);
-#endif /* linux */
-
-        /* this is the special file descriptor that the caller will use to talk
-         * with the virtual interface */
-        return fd;
-}
-
-int
-main(int arc, char **argv)
-{
-	int i;
-
-	struct glob_arg g;
-
-	int ch;
-	int wait_link = 2;
-	int devqueues = 1;	/* how many device queues */
-
-	bzero(&g, sizeof(g));
-
-	g.main_fd = -1;
-	g.td_body = receiver_body;
-	g.report_interval = 1000;	/* report interval */
-	g.affinity = -1;
-	/* ip addresses can also be a range x.x.x.x-x.x.x.y */
-	g.src_ip.name = "10.0.0.1";
-	g.dst_ip.name = "10.1.0.1";
-	g.dst_mac.name = "ff:ff:ff:ff:ff:ff";
-	g.src_mac.name = NULL;
-	g.pkt_size = 60;
-	g.burst = 512;		// default
-	g.nthreads = 1;
-	g.cpus = 1;
-	g.forever = 1;
-	g.tx_rate = 0;
-	g.frags = 1;
-	g.nmr_config = "";
-	g.virt_header = 0;
-
-	while ( (ch = getopt(arc, argv,
-			"a:f:F:n:i:Il:d:s:D:S:b:c:o:p:T:w:WvR:XC:H:e:m:")) != -1) {
-		struct sf *fn;
-
-		switch(ch) {
-		default:
-			D("bad option %c %s", ch, optarg);
-			usage();
-			break;
-
-		case 'n':
-			g.npackets = atoi(optarg);
-			break;
-
-		case 'F':
-			i = atoi(optarg);
-			if (i < 1 || i > 63) {
-				D("invalid frags %d [1..63], ignore", i);
-				break;
-			}
-			g.frags = i;
-			break;
-
-		case 'f':
-			for (fn = func; fn->key; fn++) {
-				if (!strcmp(fn->key, optarg))
-					break;
-			}
-			if (fn->key)
-				g.td_body = fn->f;
-			else
-				D("unrecognised function %s", optarg);
-			break;
-
-		case 'o':	/* data generation options */
-			g.options = atoi(optarg);
-			break;
-
-		case 'a':       /* force affinity */
-			g.affinity = atoi(optarg);
-			break;
-
-		case 'i':	/* interface */
-			/* a prefix of tap: netmap: or pcap: forces the mode.
-			 * otherwise we guess
-			 */
-			D("interface is %s", optarg);
-			if (strlen(optarg) > MAX_IFNAMELEN - 8) {
-				D("ifname too long %s", optarg);
-				break;
-			}
-			strcpy(g.ifname, optarg);
-			if (!strcmp(optarg, "null")) {
-				g.dev_type = DEV_NETMAP;
-				g.dummy_send = 1;
-			} else if (!strncmp(optarg, "tap:", 4)) {
-				g.dev_type = DEV_TAP;
-				strcpy(g.ifname, optarg + 4);
-			} else if (!strncmp(optarg, "pcap:", 5)) {
-				g.dev_type = DEV_PCAP;
-				strcpy(g.ifname, optarg + 5);
-			} else if (!strncmp(optarg, "netmap:", 7) ||
-				   !strncmp(optarg, "vale", 4)) {
-				g.dev_type = DEV_NETMAP;
-			} else if (!strncmp(optarg, "tap", 3)) {
-				g.dev_type = DEV_TAP;
-			} else { /* prepend netmap: */
-				g.dev_type = DEV_NETMAP;
-				sprintf(g.ifname, "netmap:%s", optarg);
-			}
-			break;
-
-		case 'I':
-			g.options |= OPT_INDIRECT;	/* XXX use indirect buffer */
-			break;
-
-		case 'l':	/* pkt_size */
-			g.pkt_size = atoi(optarg);
-			break;
-
-		case 'd':
-			g.dst_ip.name = optarg;
-			break;
-
-		case 's':
-			g.src_ip.name = optarg;
-			break;
-
-		case 'T':	/* report interval */
-			g.report_interval = atoi(optarg);
-			break;
-
-		case 'w':
-			wait_link = atoi(optarg);
-			break;
-
-		case 'W': /* XXX changed default */
-			g.forever = 0; /* do not exit rx even with no traffic */
-			break;
-
-		case 'b':	/* burst */
-			g.burst = atoi(optarg);
-			break;
-		case 'c':
-			g.cpus = atoi(optarg);
-			break;
-		case 'p':
-			g.nthreads = atoi(optarg);
-			break;
-
-		case 'D': /* destination mac */
-			g.dst_mac.name = optarg;
-			break;
-
-		case 'S': /* source mac */
-			g.src_mac.name = optarg;
-			break;
-		case 'v':
-			verbose++;
-			break;
-		case 'R':
-			g.tx_rate = atoi(optarg);
-			break;
-		case 'X':
-			g.options |= OPT_DUMP;
-			break;
-		case 'C':
-			g.nmr_config = strdup(optarg);
-			break;
-		case 'H':
-			g.virt_header = atoi(optarg);
-			break;
-		case 'e': /* extra bufs */
-			g.extra_bufs = atoi(optarg);
-			break;
-		case 'm':
-			if (strcmp(optarg, "tx") == 0) {
-				g.options |= OPT_MONITOR_TX;
-			} else if (strcmp(optarg, "rx") == 0) {
-				g.options |= OPT_MONITOR_RX;
-			} else {
-				D("unrecognized monitor mode %s", optarg);
-			}
-			break;
-		}
-	}
-
-	if (g.ifname == NULL) {
-		D("missing ifname");
-		usage();
-	}
-
-	i = system_ncpus();
-	if (g.cpus < 0 || g.cpus > i) {
-		D("%d cpus is too high, have only %d cpus", g.cpus, i);
-		usage();
-	}
-	if (g.cpus == 0)
-		g.cpus = i;
-
-	if (g.pkt_size < 16 || g.pkt_size > MAX_PKTSIZE) {
-		D("bad pktsize %d [16..%d]\n", g.pkt_size, MAX_PKTSIZE);
-		usage();
-	}
-
-	if (g.src_mac.name == NULL) {
-		static char mybuf[20] = "00:00:00:00:00:00";
-		/* retrieve source mac address. */
-		if (source_hwaddr(g.ifname, mybuf) == -1) {
-			D("Unable to retrieve source mac");
-			// continue, fail later
-		}
-		g.src_mac.name = mybuf;
-	}
-	/* extract address ranges */
-	extract_ip_range(&g.src_ip);
-	extract_ip_range(&g.dst_ip);
-	extract_mac_range(&g.src_mac);
-	extract_mac_range(&g.dst_mac);
-
-	if (g.src_ip.start != g.src_ip.end ||
-	    g.src_ip.port0 != g.src_ip.port1 ||
-	    g.dst_ip.start != g.dst_ip.end ||
-	    g.dst_ip.port0 != g.dst_ip.port1)
-		g.options |= OPT_COPY;
-
-	if (g.virt_header != 0 && g.virt_header != VIRT_HDR_1
-			&& g.virt_header != VIRT_HDR_2) {
-		D("bad virtio-net-header length");
-		usage();
-	}
-
-    if (g.dev_type == DEV_TAP) {
-	D("want to use tap %s", g.ifname);
-	g.main_fd = tap_alloc(g.ifname);
-	if (g.main_fd < 0) {
-		D("cannot open tap %s", g.ifname);
-		usage();
-	}
-#ifndef NO_PCAP
-    } else if (g.dev_type == DEV_PCAP) {
-	char pcap_errbuf[PCAP_ERRBUF_SIZE];
-
-	pcap_errbuf[0] = '\0'; // init the buffer
-	g.p = pcap_open_live(g.ifname, 256 /* XXX */, 1, 100, pcap_errbuf);
-	if (g.p == NULL) {
-		D("cannot open pcap on %s", g.ifname);
-		usage();
-	}
-	g.main_fd = pcap_fileno(g.p);
-	D("using pcap on %s fileno %d", g.ifname, g.main_fd);
-#endif /* !NO_PCAP */
-    } else if (g.dummy_send) { /* but DEV_NETMAP */
-	D("using a dummy send routine");
-    } else {
-	struct nmreq base_nmd;
-
-	bzero(&base_nmd, sizeof(base_nmd));
-
-	parse_nmr_config(g.nmr_config, &base_nmd);
-	if (g.extra_bufs) {
-		base_nmd.nr_arg3 = g.extra_bufs;
-	}
-
-	/*
-	 * Open the netmap device using nm_open().
-	 *
-	 * protocol stack and may cause a reset of the card,
-	 * which in turn may take some time for the PHY to
-	 * reconfigure. We do the open here to have time to reset.
-	 */
-	g.nmd = nm_open(g.ifname, &base_nmd, 0, NULL);
-	if (g.nmd == NULL) {
-		D("Unable to open %s: %s", g.ifname, strerror(errno));
-		goto out;
-	}
-	g.main_fd = g.nmd->fd;
-	D("mapped %dKB at %p", g.nmd->req.nr_memsize>>10, g.nmd->mem);
-
-	/* get num of queues in tx or rx */ 
-	if (g.td_body == sender_body)
-		devqueues = g.nmd->req.nr_tx_rings;
-	else 
-		devqueues = g.nmd->req.nr_rx_rings;
-
-	/* validate provided nthreads. */
-	if (g.nthreads < 1 || g.nthreads > devqueues) {
-		D("bad nthreads %d, have %d queues", g.nthreads, devqueues);
-		// continue, fail later
-	}
-
-	if (verbose) {
-		struct netmap_if *nifp = g.nmd->nifp;
-		struct nmreq *req = &g.nmd->req;
-
-		D("nifp at offset %d, %d tx %d rx region %d",
-		    req->nr_offset, req->nr_tx_rings, req->nr_rx_rings,
-		    req->nr_arg2);
-		for (i = 0; i <= req->nr_tx_rings; i++) {
-			struct netmap_ring *ring = NETMAP_TXRING(nifp, i);
-			D("   TX%d at 0x%p slots %d", i,
-			    (void *)((char *)ring - (char *)nifp), ring->num_slots);
-		}
-		for (i = 0; i <= req->nr_rx_rings; i++) {
-			struct netmap_ring *ring = NETMAP_RXRING(nifp, i);
-			D("   RX%d at 0x%p slots %d", i,
-			    (void *)((char *)ring - (char *)nifp), ring->num_slots);
-		}
-	}
-
-	/* Print some debug information. */
-	fprintf(stdout,
-		"%s %s: %d queues, %d threads and %d cpus.\n",
-		(g.td_body == sender_body) ? "Sending on" : "Receiving from",
-		g.ifname,
-		devqueues,
-		g.nthreads,
-		g.cpus);
-	if (g.td_body == sender_body) {
-		fprintf(stdout, "%s -> %s (%s -> %s)\n",
-			g.src_ip.name, g.dst_ip.name,
-			g.src_mac.name, g.dst_mac.name);
-	}
-
-out:
-	/* Exit if something went wrong. */
-	if (g.main_fd < 0) {
-		D("aborting");
-		usage();
-	}
-    }
-
-
-	if (g.options) {
-		D("--- SPECIAL OPTIONS:%s%s%s%s%s\n",
-			g.options & OPT_PREFETCH ? " prefetch" : "",
-			g.options & OPT_ACCESS ? " access" : "",
-			g.options & OPT_MEMCPY ? " memcpy" : "",
-			g.options & OPT_INDIRECT ? " indirect" : "",
-			g.options & OPT_COPY ? " copy" : "");
-	}
-
-	g.tx_period.tv_sec = g.tx_period.tv_nsec = 0;
-	if (g.tx_rate > 0) {
-		/* try to have at least something every second,
-		 * reducing the burst size to some 0.01s worth of data
-		 * (but no less than one full set of fragments)
-	 	 */
-		uint64_t x;
-		int lim = (g.tx_rate)/300;
-		if (g.burst > lim)
-			g.burst = lim;
-		if (g.burst < g.frags)
-			g.burst = g.frags;
-		x = ((uint64_t)1000000000 * (uint64_t)g.burst) / (uint64_t) g.tx_rate;
-		g.tx_period.tv_nsec = x;
-		g.tx_period.tv_sec = g.tx_period.tv_nsec / 1000000000;
-		g.tx_period.tv_nsec = g.tx_period.tv_nsec % 1000000000;
-	}
-	if (g.td_body == sender_body)
-	    D("Sending %d packets every  %ld.%09ld s",
-			g.burst, g.tx_period.tv_sec, g.tx_period.tv_nsec);
-	/* Wait for PHY reset. */
-	D("Wait %d secs for phy reset", wait_link);
-	sleep(wait_link);
-	D("Ready...");
-
-	/* Install ^C handler. */
-	global_nthreads = g.nthreads;
-	signal(SIGINT, sigint_h);
-
-	start_threads(&g);
-	main_thread(&g);
-	return 0;
-}
-
-/* end of file */
diff --git a/drivers/staging/netmap/examples/test_select.c b/drivers/staging/netmap/examples/test_select.c
deleted file mode 100644
index ed737c3b8736..000000000000
--- a/drivers/staging/netmap/examples/test_select.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * test minimum select time
- *
- *	./prog usec [method [duration]]
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/time.h>
-#include <poll.h>
-#include <inttypes.h>
-
-enum { M_SELECT =0 , M_POLL, M_USLEEP };
-static const char *names[] = { "select", "poll", "usleep" };
-int
-main(int argc, char *argv[])
-{
-	struct timeval ta, tb, prev;
-	int usec = 1, total = 0, method = M_SELECT;
-	uint32_t *vals = NULL;
-	uint32_t i, count = 0;
-#define LIM 1000000
-
-	if (argc > 1)
-		usec = atoi(argv[1]);
-	if (usec <= 0)
-		usec = 1;
-	else if (usec > 500000)
-		usec = 500000;
-	if (argc > 2) {
-		if (!strcmp(argv[2], "poll"))
-			method = M_POLL;
-		else if (!strcmp(argv[2], "usleep"))
-			method = M_USLEEP;
-	}
-	if (argc > 3)
-		total = atoi(argv[3]);
-	if (total < 1)
-		total = 1;
-	else if (total > 10)
-		total = 10;
-	fprintf(stderr, "testing %s for %dus over %ds\n",
-		names[method], usec, total);
-
-	gettimeofday(&ta, NULL);
-	prev = ta;
-	vals = calloc(LIM, sizeof(uint32_t));
-	for (;;) {
-		if (method == M_SELECT) {
-			struct timeval to = { 0, usec };
-			select(0, NULL, NULL, NULL, &to);
-		} else if (method == M_POLL) {
-			poll(NULL, 0, usec/1000);
-		} else {
-			usleep(usec);
-		}
-		gettimeofday(&tb, NULL);
-		timersub(&tb, &prev, &prev);
-		if (count < LIM)
-			vals[count] = prev.tv_usec;
-		count++;
-		prev = tb;
-		timersub(&tb, &ta, &tb);
-		if (tb.tv_sec > total)
-			break;
-	}
-	fprintf(stderr, "%dus actually took %dus\n",
-		usec, (int)(tb.tv_sec * 1000000 + tb.tv_usec) / count );
-	for (i = 0; i < count && i < LIM; i++)
-		fprintf(stdout, "%d\n", vals[i]);
-	return 0;
-}
diff --git a/drivers/staging/netmap/examples/testlock.c b/drivers/staging/netmap/examples/testlock.c
deleted file mode 100644
index 15904086d45b..000000000000
--- a/drivers/staging/netmap/examples/testlock.c
+++ /dev/null
@@ -1,1018 +0,0 @@
-/*
- * Copyright (C) 2012-2014 Luigi Rizzo. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *   1. Redistributions of source code must retain the above copyright
- *      notice, this list of conditions and the following disclaimer.
- *   2. Redistributions in binary form must reproduce the above copyright
- *      notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * $Id$
- *
- * Test program to study various ops and concurrency issues.
- * Create multiple threads, possibly bind to cpus, and run a workload.
- *
- * cc -O2 -Werror -Wall testlock.c -o testlock -lpthread
- *	you might need -lrt
- */
-
-#define _GNU_SOURCE	// setaffinity ?
-
-#include <inttypes.h>
-#include <sys/types.h>
-#include <pthread.h>	/* pthread_* */
-
-#if defined(__APPLE__)
-
-#include <net/if_var.h>
-#include <libkern/OSAtomic.h>
-#define atomic_add_int(p, n) OSAtomicAdd32(n, (int *)p)
-#define	atomic_cmpset_32(p, o, n)	OSAtomicCompareAndSwap32(o, n, (int *)p)
-
-#elif defined(linux)
-
-#define atomic_cmpset_32(p, o, n) __sync_bool_compare_and_swap(p, o, n)
-#include <sched.h>	// affinity
-#define HAVE_AFFINITY	1
-#define	cpuset_t	cpu_set_t
-
-#if defined(HAVE_GCC_ATOMICS)
-int atomic_add_int(volatile int *p, int v)
-{
-        return __sync_fetch_and_add(p, v);
-}
-#else
-inline
-uint32_t atomic_add_int(uint32_t *p, int v)
-{
-        __asm __volatile (
-        "       lock   xaddl   %0, %1 ;        "
-        : "+r" (v),                     /* 0 (result) */
-          "=m" (*p)                     /* 1 */
-        : "m" (*p));                    /* 2 */
-        return (v);
-}
-#endif
-
-#else /* FreeBSD */
-#include <sys/param.h>
-#include <machine/atomic.h>
-#include <pthread_np.h>	/* pthread w/ affinity */
-
-#if __FreeBSD_version > 500000
-#include <sys/cpuset.h>	/* cpu_set */
-#if __FreeBSD_version > 800000
-#define HAVE_AFFINITY
-#endif
-
-
-#else /* FreeBSD 4.x */
-int atomic_cmpset_32(volatile uint32_t *p, uint32_t old, uint32_t new)
-{
-	int ret = *p == old;
-	*p = new;
-	return ret;
-}
-
-#define PRIu64	"llu"
-#endif /* FreeBSD 4.x */
-
-#endif /* FreeBSD */
-
-#include <signal.h>	/* signal */
-#include <stdlib.h>
-#include <stdio.h>
-#include <poll.h>
-#include <inttypes.h>	/* PRI* macros */
-#include <string.h>	/* strcmp */
-#include <fcntl.h>	/* open */
-#include <unistd.h>	/* getopt */
-
-
-#include <sys/sysctl.h>	/* sysctl */
-#include <sys/time.h>	/* timersub */
-
-#define ONE_MILLION	1000000
-/* debug support */
-#define ND(format, ...)			
-#define D(format, ...)				\
-	fprintf(stderr, "%s [%d] " format "\n",	\
-	__FUNCTION__, __LINE__, ##__VA_ARGS__)
-
-int verbose = 0;
-
-#if 1//def MY_RDTSC
-/* Wrapper around `rdtsc' to take reliable timestamps flushing the pipeline */ 
-#define my_rdtsc(t)				\
-	do {					\
-		u_int __regs[4];		\
-						\
-		do_cpuid(0, __regs);		\
-		(t) = rdtsc();			\
-	} while (0)
-
-static __inline void
-do_cpuid(u_int ax, u_int *p)
-{
-	__asm __volatile("cpuid"
-			 : "=a" (p[0]), "=b" (p[1]), "=c" (p[2]), "=d" (p[3])
-			 :  "0" (ax) );
-}
-
-static __inline uint64_t
-rdtsc(void)
-{
-	uint64_t rv;
-
-	// XXX does not work on linux-64 bit
-	__asm __volatile("rdtscp" : "=A" (rv) : : "%rax");
-	return (rv);
-}
-#endif /* 1 */
-
-struct targ;
-
-/*** global arguments for all threads ***/
-struct glob_arg {
-	struct  {
-		uint32_t	ctr[1024];
-	} v __attribute__ ((aligned(256) ));
-	int64_t m_cycles;	/* total cycles */
-	int nthreads;
-	int cpus;
-	int privs;	// 1 if has IO privileges
-	int arg;	// microseconds in usleep
-	int nullfd;	// open(/dev/null)
-	char *test_name;
-	pthread_mutex_t mtx;
-	void (*fn)(struct targ *);
-	uint64_t scale;	// scaling factor
-	char *scale_name;	// scaling factor
-};
-
-/*
- * Arguments for a new thread.
- */
-struct targ {
-	struct glob_arg *g;
-	int		completed;
-	u_int		*glob_ctr;
-	uint64_t volatile count;
-	struct timeval	tic, toc;
-	int		me;
-	pthread_t	thread;
-	int		affinity;
-};
-
-
-static struct targ *ta;
-static int global_nthreads;
-
-/* control-C handler */
-static void
-sigint_h(int sig)
-{
-	int i;
-
-	(void)sig;	/* UNUSED */
-	for (i = 0; i < global_nthreads; i++) {
-		/* cancel active threads. */
-		if (ta[i].completed)
-			continue;
-		D("Cancelling thread #%d\n", i);
-		pthread_cancel(ta[i].thread);
-		ta[i].completed = 0;
-	}
-	signal(SIGINT, SIG_DFL);
-}
-
-
-/* sysctl wrapper to return the number of active CPUs */
-static int
-system_ncpus(void)
-{
-#ifdef linux
-	return sysconf(_SC_NPROCESSORS_ONLN);
-#else
-	int mib[2] = { CTL_HW, HW_NCPU}, ncpus;
-	size_t len = sizeof(mib);
-	sysctl(mib, len / sizeof(mib[0]), &ncpus, &len, NULL, 0);
-	D("system had %d cpus", ncpus);
-
-	return (ncpus);
-#endif
-}
-
-/*
- * try to get I/O privileges so we can execute cli/sti etc.
- */
-int
-getprivs(void)
-{
-	int fd = open("/dev/io", O_RDWR);
-	if (fd < 0) {
-		D("cannot open /dev/io, fd %d", fd);
-		return 0;
-	}
-	return 1;
-}
-
-/* set the thread affinity. */
-/* ARGSUSED */
-#ifdef HAVE_AFFINITY
-static int
-setaffinity(pthread_t me, int i)
-{
-	cpuset_t cpumask;
-
-	if (i == -1)
-		return 0;
-
-	/* Set thread affinity affinity.*/
-	CPU_ZERO(&cpumask);
-	CPU_SET(i, &cpumask);
-
-	if (pthread_setaffinity_np(me, sizeof(cpuset_t), &cpumask) != 0) {
-		D("Unable to set affinity");
-		return 1;
-	}
-	return 0;
-}
-#endif
-
-
-static void *
-td_body(void *data)
-{
-	struct targ *t = (struct targ *) data;
-
-#ifdef HAVE_AFFINITY
-	if (0 == setaffinity(t->thread, t->affinity))
-#endif
-	{
-		/* main loop.*/
-		D("testing %"PRIu64" cycles arg %d",
-			t->g->m_cycles, t->g->arg);
-		gettimeofday(&t->tic, NULL);
-		t->g->fn(t);
-		gettimeofday(&t->toc, NULL);
-	}
-	t->completed = 1;
-	return (NULL);
-}
-
-#include <sys/wait.h>
-
-void
-test_fork(struct targ *t)
-{
-	int arg = t->g->arg;
-	int m;
-	struct timeval tot = {0, 0};
-	struct timeval ta, tb;
-	char *p = NULL;
-	int sum = 0;
-	long int i;
-	int np=arg*1000000/4096;
-	p = malloc(arg*1000000);
-
-	D("memsize is %d MB", arg);
-
-	if (arg > 0) {
-		if (p == NULL)
-			D("malloc failed");
-		D("pages %d %s %s", np, arg & 1 ? "READ" : "",
-			arg & 2 ? "WRITE" : "");
-	}
-	for (m = 0; m < t->g->m_cycles; m++) {
-		int pid;
-		int st = 0;
-		if (arg & 1) for (i = 0; i < arg*1000000; i += 4096) {
-			sum += p[i];
-		}
-		if (arg & 2) for (i = 0; i < arg*1000000; i += 4096) {
-			p[i] = 3;
-		}
-		ta.tv_sec = sum;
-		gettimeofday(&ta, NULL);
-		pid = fork();
-		if (pid == 0)
-			exit(0);
-		gettimeofday(&tb, NULL);
-		if (waitpid(-1, &st, WNOHANG) > 0) // another try
-			waitpid(-1, &st, WNOHANG);
-
-		tot.tv_sec += (tb.tv_sec - ta.tv_sec);
-		tot.tv_usec += (tb.tv_usec - ta.tv_usec);
-		if (tot.tv_usec < 0) {
-			tot.tv_sec--;
-			tot.tv_usec += ONE_MILLION;
-		} else if (tot.tv_usec >= ONE_MILLION) {
-			tot.tv_sec++;
-			tot.tv_usec -= ONE_MILLION;
-		}
-		t->count++;
-	}
-	D("avg is %lu ns", (unsigned long)
-		((tot.tv_sec * ONE_MILLION + tot.tv_usec)*1000/t->count));
-	if (p)
-		free(p);
-}
-
-/*
- * select and poll:
- *	arg	fd	timeout
- *	>0	block	>0
- *	 0	block	0
- *		block	NULL (not implemented)
- *	< -2	ready	-arg
- *	-1	ready	0
- *	-2	ready	NULL / <0 for poll
- *
- * arg = -1 -> NULL timeout (select)
- */
-void
-test_sel(struct targ *t)
-{
-	int arg = t->g->arg;
-	// stdin is blocking on reads /dev/null or /dev/zero are not
-	int fd = (arg < 0) ? t->g->nullfd : 0;
-	fd_set r;
-	struct timeval t0 = { 0, arg};
-	struct timeval tcur, *tp = (arg == -2) ? NULL : &tcur;
-	int64_t m;
-
-	if (arg == -1)
-		t0.tv_usec = 0;
-	else if (arg < -2)
-		t0.tv_usec = -arg;
-
-	D("tp %p mode %s timeout %d", tp, arg < 0 ? "ready" : "block",
-		(int)t0.tv_usec);
-	for (m = 0; m < t->g->m_cycles; m++) {
-		int ret;
-		tcur = t0;
-		FD_ZERO(&r);
-		FD_SET(fd, &r);
-		ret = select(fd+1, &r, NULL, NULL, tp);
-		(void)ret;
-		ND("ret %d r %d w %d", ret,
-			FD_ISSET(fd, &r),
-			FD_ISSET(fd, &w));
-		t->count++;
-	}
-}
-
-void
-test_poll(struct targ *t)
-{
-	int arg = t->g->arg;
-	// stdin is blocking on reads /dev/null is not
-	int fd = (arg < 0) ? t->g->nullfd : 0;
-	int64_t m;
-	int ms;
-
-	if (arg == -1)
-		ms = 0;
-	else if (arg == -2)
-		ms = -1; /* blocking */
-	else if (arg < 0)
-		ms = -arg/1000;
-	else
-		ms = arg/1000;
-
-	D("mode %s timeout %d", arg < 0 ? "ready" : "block", ms);
-	for (m = 0; m < t->g->m_cycles; m++) {
-		struct pollfd x;
-		x.fd = fd;
-		x.events = POLLIN;
-		poll(&x, 1, ms);
-		t->count++;
-	}
-}
-
-void
-test_usleep(struct targ *t)
-{
-	int64_t m;
-	for (m = 0; m < t->g->m_cycles; m++) {
-		usleep(t->g->arg);
-		t->count++;
-	}
-}
-
-void
-test_cli(struct targ *t)
-{
-        int64_t m, i;
-	if (!t->g->privs) {	
-		D("%s", "privileged instructions not available");
-		return;
-	}
-        for (m = 0; m < t->g->m_cycles; m++) {
-		for (i = 0; i < ONE_MILLION; i++) {
-			__asm __volatile("cli;");
-			__asm __volatile("and %eax, %eax;");
-			__asm __volatile("sti;");
-			t->count++;
-		}
-        }
-}
-
-void
-test_nop(struct targ *t)
-{
-        int64_t m, i;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		for (i = 0; i < ONE_MILLION; i++) {
-			__asm __volatile("nop;");
-			__asm __volatile("nop; nop; nop; nop; nop;");
-			//__asm __volatile("nop; nop; nop; nop; nop;");
-			t->count++;
-		}
-	}
-}
-
-void
-test_rdtsc1(struct targ *t)
-{
-        int64_t m, i;
-	uint64_t v;
-	(void)v;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		for (i = 0; i < ONE_MILLION; i++) {
-                	my_rdtsc(v);
-			t->count++;
-		}
-        }
-}
-
-void
-test_rdtsc(struct targ *t)
-{
-        int64_t m, i;
-	volatile uint64_t v;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		for (i = 0; i < ONE_MILLION; i++) {
-                	v = rdtsc();
-			t->count++;
-		}
-        }
-	(void)v;
-}
-
-void
-test_add(struct targ *t)
-{
-        int64_t m, i;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		for (i = 0; i < ONE_MILLION; i++) {
-                	t->glob_ctr[0] ++;
-			t->count++;
-		}
-        }
-}
-
-void
-test_atomic_add(struct targ *t)
-{
-        int64_t m, i;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		for (i = 0; i < ONE_MILLION; i++) {
-                	atomic_add_int(t->glob_ctr, 1);
-			t->count++;
-		}
-        }
-}
-
-void
-test_atomic_cmpset(struct targ *t)
-{
-        int64_t m, i;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		for (i = 0; i < ONE_MILLION; i++) {
-		        atomic_cmpset_32(t->glob_ctr, m, i);
-			t->count++;
-		}
-        }
-}
-
-void
-test_pthread_mutex(struct targ *t)
-{
-        int64_t m, i;
-	pthread_mutex_t *mtx = &t->g->mtx;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		for (i = 0; i < ONE_MILLION; i++) {
-		        pthread_mutex_lock(mtx);
-			t->count++;
-		        pthread_mutex_unlock(mtx);
-		}
-        }
-}
-
-volatile int foo;
-
-void
-test_spinlock(struct targ *t)
-{
-        int64_t m, i;
-//	uint64_t min = 1000000, minp=1000000, max=0, maxp = 0, cur=0;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		for (i = 0; i < 100*ONE_MILLION; i++) {
-		        while (!atomic_cmpset_32(t->glob_ctr, 0, 1)) {
-			}
-			t->count++;
-		        atomic_cmpset_32(t->glob_ctr, 1, 0);
-		}
-        }
-}
-
-void
-test_time(struct targ *t)
-{
-        int64_t m;
-        for (m = 0; m < t->g->m_cycles; m++) {
-#ifndef __APPLE__
-		struct timespec ts;
-		clock_gettime(t->g->arg, &ts);
-#endif
-		t->count++;
-        }
-}
-
-void
-test_gettimeofday(struct targ *t)
-{
-        int64_t m;
-	struct timeval ts;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		gettimeofday(&ts, NULL);
-		t->count++;
-        }
-}
-
-/*
- * getppid is the simplest system call (getpid is cached by glibc
- * so it would not be a good test)
- */
-void
-test_getpid(struct targ *t)
-{
-        int64_t m;
-        for (m = 0; m < t->g->m_cycles; m++) {
-		getppid();
-		t->count++;
-        }
-}
-
-
-#define likely(x)	__builtin_expect(!!(x), 1)
-#define unlikely(x)	__builtin_expect(!!(x), 0)
-
-static void
-fast_bcopy(void *_src, void *_dst, int l)
-{
-	uint64_t *src = _src;
-	uint64_t *dst = _dst;
-	if (unlikely(l >= 1024)) {
-		bcopy(src, dst, l);
-		return;
-	}
-	for (; likely(l > 0); l-=64) {
-		*dst++ = *src++;
-		*dst++ = *src++;
-		*dst++ = *src++;
-		*dst++ = *src++;
-		*dst++ = *src++;
-		*dst++ = *src++;
-		*dst++ = *src++;
-		*dst++ = *src++;
-	}
-}
-
-static inline void
-asmcopy(void *dst, void *src, uint64_t l)
-{
-	(void)dst;
-	(void)src;
-	asm(
-	"\n\t"
-	"movq %0, %%rcx\n\t"
-	"addq $7, %%rcx\n\t"
-	"shrq $03, %%rcx\n\t"
-	"cld\n\t"
-	"movq %1, %%rdi\n\t"
-	"movq %2, %%rsi\n\t"
-	"repe movsq\n\t"
-/*	"movq %0, %%rcx\n\t"
-	"andq $0x7, %%rcx\n\t"
-	"repe movsb\n\t"
-*/
-	: /* out */
-	: "r" (l), "r" (dst), "r" (src) /* in */
-	: "%rcx", "%rsi", "%rdi" /* clobbered */
-	);
-
-}
-// XXX if you want to make sure there is no inlining...
-// static void (*fp)(void *_src, void *_dst, int l) = fast_bcopy;
-
-#define HU	0x3ffff
-static struct glob_arg huge[HU+1];
-
-void
-test_fastcopy(struct targ *t)
-{
-        int64_t m;
-	int len = t->g->arg;
-
-	if (len > (int)sizeof(struct glob_arg))
-		len = sizeof(struct glob_arg);
-	D("fast copying %d bytes", len);
-        for (m = 0; m < t->g->m_cycles; m++) {
-		fast_bcopy(t->g, (void *)&huge[m & HU], len);
-		t->count+=1;
-        }
-}
-
-void
-test_asmcopy(struct targ *t)
-{
-        int64_t m;
-	int len = t->g->arg;
-
-	if (len > (int)sizeof(struct glob_arg))
-		len = sizeof(struct glob_arg);
-	D("fast copying %d bytes", len);
-        for (m = 0; m < t->g->m_cycles; m++) {
-		asmcopy((void *)&huge[m & HU], t->g, len);
-		t->count+=1;
-        }
-}
-
-void
-test_bcopy(struct targ *t)
-{
-        int64_t m;
-	int len = t->g->arg;
-
-	if (len > (int)sizeof(struct glob_arg))
-		len = sizeof(struct glob_arg);
-	D("bcopying %d bytes", len);
-        for (m = 0; m < t->g->m_cycles; m++) {
-		bcopy(t->g, (void *)&huge[m & HU], len);
-		t->count+=1;
-        }
-}
-
-void
-test_builtin_memcpy(struct targ *t)
-{
-        int64_t m;
-	int len = t->g->arg;
-
-	if (len > (int)sizeof(struct glob_arg))
-		len = sizeof(struct glob_arg);
-	D("bcopying %d bytes", len);
-        for (m = 0; m < t->g->m_cycles; m++) {
-		__builtin_memcpy((void *)&huge[m & HU], t->g, len);
-		t->count+=1;
-        }
-}
-
-void
-test_memcpy(struct targ *t)
-{
-        int64_t m;
-	int len = t->g->arg;
-
-	if (len > (int)sizeof(struct glob_arg))
-		len = sizeof(struct glob_arg);
-	D("memcopying %d bytes", len);
-        for (m = 0; m < t->g->m_cycles; m++) {
-		memcpy((void *)&huge[m & HU], t->g, len);
-		t->count+=1;
-        }
-}
-
-#include <sys/ioctl.h>
-#include <sys/socket.h>	// OSX
-#include <net/if.h>
-#include <net/netmap.h>
-void
-test_netmap(struct targ *t)
-{
-	struct nmreq nmr;
-	int fd;
-        int64_t m, scale;
-
-	scale = t->g->m_cycles / 100;
-	fd = open("/dev/netmap", O_RDWR);
-	if (fd < 0) {
-		D("fail to open netmap, exit");
-		return;
-	}
-	bzero(&nmr, sizeof(nmr));
-        for (m = 0; m < t->g->m_cycles; m += scale) {
-		nmr.nr_version = 666;
-		nmr.nr_cmd = t->g->arg;
-		nmr.nr_offset = (uint32_t)scale;
-		ioctl(fd, NIOCGINFO, &nmr);
-		t->count += scale;
-        }
-	return;
-}
-
-struct entry {
-	void (*fn)(struct targ *);
-	char *name;
-	uint64_t scale;
-	uint64_t m_cycles;
-};
-struct entry tests[] = {
-	{ test_fork, "fork", 1, 1000 },
-	{ test_sel, "select", 1, 1000 },
-	{ test_poll, "poll", 1, 1000 },
-	{ test_usleep, "usleep", 1, 1000 },
-	{ test_time, "time", 1, 1000 },
-	{ test_gettimeofday, "gettimeofday", 1, 1000000 },
-	{ test_getpid, "getpid", 1, 1000000 },
-	{ test_bcopy, "bcopy", 1000, 100000000 },
-	{ test_builtin_memcpy, "__builtin_memcpy", 1000, 100000000 },
-	{ test_memcpy, "memcpy", 1000, 100000000 },
-	{ test_fastcopy, "fastcopy", 1000, 100000000 },
-	{ test_asmcopy, "asmcopy", 1000, 100000000 },
-	{ test_add, "add", ONE_MILLION, 100000000 },
-	{ test_nop, "nop", ONE_MILLION, 100000000 },
-	{ test_atomic_add, "atomic-add", ONE_MILLION, 100000000 },
-	{ test_cli, "cli", ONE_MILLION, 100000000 },
-	{ test_rdtsc, "rdtsc", ONE_MILLION, 100000000 },	// unserialized
-	{ test_rdtsc1, "rdtsc1", ONE_MILLION, 100000000 },	// serialized
-	{ test_atomic_cmpset, "cmpset", ONE_MILLION, 100000000 },
-	{ test_netmap, "netmap", 1000, 100000000 },
-	{ test_pthread_mutex, "mutex", 1000, 100000000 },
-	{ test_spinlock, "spinlock", 1000, 100000000 },
-	{ NULL, NULL, 0, 0 }
-};
-
-static void
-usage(void)
-{
-	const char *cmd = "test";
-	int i;
-
-	fprintf(stderr,
-		"Usage:\n"
-		"%s arguments\n"
-		"\t-m name		test name\n"
-		"\t-n cycles		(millions) of cycles\n"
-		"\t-l arg		bytes, usec, ... \n"
-		"\t-t threads		total threads\n"
-		"\t-c cores		cores to use\n"
-		"\t-a n			force affinity every n cores\n"
-		"\t-A n			cache contention every n bytes\n"
-		"\t-w report_ms		milliseconds between reports\n"
-		"",
-		cmd);
-	fprintf(stderr, "Available tests:\n");
-	for (i = 0; tests[i].name; i++) {
-		fprintf(stderr, "%12s\n", tests[i].name);
-	}
-
-	exit(0);
-}
-
-static int64_t
-getnum(const char *s)
-{
-	int64_t n;
-	char *e;
-
-	n = strtol(s, &e, 0);
-	switch (e ? *e : '\0')  {
-	case 'k':
-	case 'K':
-		return n*1000;
-	case 'm':
-	case 'M':
-		return n*1000*1000;
-	case 'g':
-	case 'G':
-		return n*1000*1000*1000;
-	case 't':
-	case 'T':
-		return n*1000*1000*1000*1000;
-	default:
-		return n;
-	}
-}
-
-struct glob_arg g;
-int
-main(int argc, char **argv)
-{
-	int i, ch, report_interval, affinity, align;
-
-	ND("g has size %d", (int)sizeof(g));
-	report_interval = 250;	/* ms */
-	affinity = 0;		/* no affinity */
-	align = 0;		/* global variable */
-
-	bzero(&g, sizeof(g));
-
-	g.privs = getprivs();
-	pthread_mutex_init(&g.mtx, NULL);
-	g.nthreads = 1;
-	g.cpus = 1;
-	g.m_cycles = 0;
-	g.nullfd = open("/dev/zero", O_RDWR);
-	D("nullfd is %d", g.nullfd);
-
-	while ( (ch = getopt(argc, argv, "A:a:m:n:w:c:t:vl:")) != -1) {
-		switch(ch) {
-		default:
-			D("bad option %c %s", ch, optarg);
-			usage();
-			break;
-		case 'A':	/* align */
-			align = atoi(optarg);
-			break;
-		case 'a':	/* force affinity */
-			affinity = atoi(optarg);
-			break;
-		case 'n':	/* cycles */
-			g.m_cycles = getnum(optarg);
-			break;
-		case 'w':	/* report interval */
-			report_interval = atoi(optarg);
-			break;
-		case 'c':
-			g.cpus = atoi(optarg);
-			break;
-		case 't':
-			g.nthreads = atoi(optarg);
-			break;
-		case 'm':
-			g.test_name = optarg;
-			break;
-		case 'l':
-			g.arg = getnum(optarg);
-			break;
-
-		case 'v':
-			verbose++;
-			break;
-		}
-	}
-	argc -= optind;
-	argv += optind;
-	if (!g.test_name && argc > 0)
-		g.test_name = argv[0];
-
-	if (g.test_name) {
-		for (i = 0; tests[i].name; i++) {
-			if (!strcmp(g.test_name, tests[i].name)) {
-				g.fn = tests[i].fn;
-				g.scale = tests[i].scale;
-				if (g.m_cycles == 0)
-					g.m_cycles = tests[i].m_cycles;
-				if (g.scale == ONE_MILLION)
-					g.scale_name = "M";
-				else if (g.scale == 1000)
-					g.scale_name = "K";
-				else {
-					g.scale = 1;
-					g.scale_name = "";
-				}
-				break;
-			}
-		}
-	}
-	if (!g.fn) {
-		D("%s", "missing/unknown test name");
-		usage();
-	}
-	i = system_ncpus();
-	if (g.cpus < 0 || g.cpus > i) {
-		D("%d cpus is too high, have only %d cpus", g.cpus, i);
-		usage();
-	}
-	if (g.cpus == 0)
-		g.cpus = i;
-	if (g.nthreads < 1) {
-		D("bad nthreads %d, using 1", g.nthreads);
-		g.nthreads = 1;
-	}
-	i = sizeof(g.v.ctr) / g.nthreads*sizeof(g.v.ctr[0]);
-	if (align < 0 || align > i) {
-		D("bad align %d, max is %d", align, i);
-		align = i;
-	}
-
-	/* Install ^C handler. */
-	global_nthreads = g.nthreads;
-	signal(SIGINT, sigint_h);
-
-	ta = calloc(g.nthreads, sizeof(*ta));
-	/*
-	 * Now create the desired number of threads, each one
-	 * using a single descriptor.
- 	 */
-	D("start %d threads on %d cores", g.nthreads, g.cpus);
-	for (i = 0; i < g.nthreads; i++) {
-		struct targ *t = &ta[i];
-		bzero(t, sizeof(*t));
-		t->g = &g;
-		t->me = i;
-		t->glob_ctr = &g.v.ctr[(i*align)/sizeof(g.v.ctr[0])];
-		D("thread %d ptr %p", i, t->glob_ctr);
-		t->affinity = affinity ? (affinity*i) % g.cpus : -1;
-		if (pthread_create(&t->thread, NULL, td_body, t) == -1) {
-			D("Unable to create thread %d", i);
-			t->completed = 1;
-		}
-	}
-	/* the main loop */
-
-    {
-	uint64_t my_count = 0, prev = 0;
-	uint64_t count = 0;
-	double delta_t;
-	struct timeval tic, toc;
-
-	gettimeofday(&toc, NULL);
-	for (;;) {
-		struct timeval now, delta;
-		uint64_t pps;
-		int done = 0;
-
-		delta.tv_sec = report_interval/1000;
-		delta.tv_usec = (report_interval%1000)*1000;
-		select(0, NULL, NULL, NULL, &delta);
-		gettimeofday(&now, NULL);
-		timersub(&now, &toc, &toc);
-		my_count = 0;
-		for (i = 0; i < g.nthreads; i++) {
-			my_count += ta[i].count;
-			if (ta[i].completed)
-				done++;
-		}
-		pps = toc.tv_sec* ONE_MILLION + toc.tv_usec;
-		if (pps < 10000)
-			continue;
-		pps = (my_count - prev)*ONE_MILLION / pps;
-		D("%" PRIu64 " %scycles/s scale %" PRIu64 " in %dus", pps/g.scale,
-			g.scale_name, g.scale, (int)(toc.tv_sec* ONE_MILLION + toc.tv_usec));
-		prev = my_count;
-		toc = now;
-		if (done == g.nthreads)
-			break;
-	}
-	D("total %" PRIu64 " cycles", prev);
-
-	timerclear(&tic);
-	timerclear(&toc);
-	for (i = 0; i < g.nthreads; i++) {
-		pthread_join(ta[i].thread, NULL);
-
-		if (ta[i].completed == 0)
-			continue;
-
-		/*
-		 * Collect threads o1utput and extract information about
-		 * how log it took to send all the packets.
-		 */
-		count += ta[i].count;
-		if (!timerisset(&tic) || timercmp(&ta[i].tic, &tic, <))
-			tic = ta[i].tic;
-		if (!timerisset(&toc) || timercmp(&ta[i].toc, &toc, >))
-			toc = ta[i].toc;
-	}
-
-	/* print output. */
-	timersub(&toc, &tic, &toc);
-	delta_t = toc.tv_sec + 1e-6* toc.tv_usec;
-	D("total %8.6f seconds", delta_t);
-    }
-
-	return (0);
-}
-/* end of file */
diff --git a/drivers/staging/netmap/examples/testmmap.c b/drivers/staging/netmap/examples/testmmap.c
deleted file mode 100644
index 601410ba03ea..000000000000
--- a/drivers/staging/netmap/examples/testmmap.c
+++ /dev/null
@@ -1,1111 +0,0 @@
-#define TEST_NETMAP
-
-#include <inttypes.h>
-#include <sys/param.h>	/* ULONG_MAX */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <sys/poll.h>
-#include <sys/wait.h>
-#include <sys/mman.h>	/* PROT_* */
-#include <fcntl.h>	/* O_RDWR */
-#include <pthread.h>
-#include <signal.h>
-
-
-#define MAX_VARS 100
-
-char *variables[MAX_VARS];
-int curr_var;
-
-#define VAR_FAILED ((void*)1)
-
-char *firstarg(char *buf)
-{
-	int v;
-	char *arg = strtok(buf, " \t\n");
-	char *ret;
-	if (!arg)
-		return NULL;
-	if (arg[0] != '$' && arg[0] != '?')
-		return arg;
-	v = atoi(arg+1);
-	if (v < 0 || v >= MAX_VARS)
-		return "";
-	ret = variables[v];
-	if (ret == NULL)
-		return "NULL";
-	if (ret == VAR_FAILED) {
-		printf("reading failed var, exit\n");
-		exit(1);
-	}
-	if (arg[0] == '?')
-		return ret;
-	ret = rindex(ret, '=') + 1;
-	return ret;
-}
-
-char *nextarg()
-{
-	return firstarg(NULL);
-}
-
-char *restofline()
-{
-	return strtok(NULL, "\n");
-}
-
-void resetvar(int v, char *b)
-{
-	if (variables[v] != VAR_FAILED)
-		free(variables[v]);
-	variables[v] = b;
-}
-
-#define outecho(format, args...) \
-	do {\
-		printf("%u:%lu: " format "\n", getpid(), (unsigned long) pthread_self(), ##args);\
-		fflush(stdout);\
-	} while (0)
-
-#define output(format, args...) \
-	do {\
-		resetvar(curr_var, (char*)malloc(1024));\
-		snprintf(variables[curr_var], 1024, format, ##args);\
-		outecho(format, ##args);\
-	} while (0)		
-
-#define output_err(ret, format, args...)\
-	do {\
-		if (ret < 0) {\
-			resetvar(curr_var, VAR_FAILED);\
-			outecho(format, ##args);\
-			outecho("error: %s", strerror(errno));\
-		} else {\
-			output(format, ##args);\
-		}\
-	} while (0)
-	
-struct chan {
-	FILE *out;
-	pid_t pid;
-	pthread_t tid;
-};
-
-int chan_search_free(struct chan* c[], int max)
-{
-	int i;
-
-	for (i = 0; i < max && c[i]; i++)
-		;
-
-	return i;
-}
-
-void chan_clear_all(struct chan *c[], int max)
-{
-	int i;
-
-	for (i = 0; i < max; i++) {
-		if (c[i]) {
-			fclose(c[i]->out);
-			free(c[i]);
-			c[i] = NULL;
-		}
-	}
-}
-
-int last_fd = -1;
-size_t last_memsize = 0;
-void* last_mmap_addr = NULL;
-char* last_access_addr = NULL;
-struct nmreq curr_nmr;
-char nmr_name[64];
-
-
-void do_open()
-{
-	last_fd = open("/dev/netmap", O_RDWR);
-	output_err(last_fd, "open(\"/dev/netmap\", O_RDWR)=%d", last_fd);
-}
-
-void do_close()
-{
-	int ret, fd;
-	char *arg = nextarg();
-	fd = arg ? atoi(arg) : last_fd;
-	ret = close(fd);
-	output_err(ret, "close(%d)=%d", fd, ret);
-}
-
-#ifdef TEST_NETMAP
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <ifaddrs.h>
-#include <net/netmap_user.h>
-
-void parse_nmr_config(char* w, struct nmreq *nmr)
-{
-	char *tok;
-	int i, v;
-
-	nmr->nr_tx_rings = nmr->nr_rx_rings = 0;
-	nmr->nr_tx_slots = nmr->nr_rx_slots = 0;
-	if (w == NULL || ! *w)
-		return;
-	for (i = 0, tok = strtok(w, ","); tok; i++, tok = strtok(NULL, ",")) {
-		v = atoi(tok);
-		switch (i) {
-		case 0:
-			nmr->nr_tx_slots = nmr->nr_rx_slots = v;
-			break;
-		case 1:
-			nmr->nr_rx_slots = v;
-			break;
-		case 2:
-			nmr->nr_tx_rings = nmr->nr_rx_rings = v;
-			break;
-		case 3:
-			nmr->nr_rx_rings = v;
-			break;
-		default:
-			break;
-		}
-	}
-}
-
-void do_getinfo()
-{
-	int ret;
-	char *arg, *name;
-	int fd;
-
-	bzero(&curr_nmr, sizeof(curr_nmr));
-	curr_nmr.nr_version = NETMAP_API;
-
-	name = nextarg();
-	if (name) {
-		strncpy(curr_nmr.nr_name, name, sizeof(curr_nmr.nr_name));
-	} else {
-		name = "any";
-	}
-
-	arg = nextarg();
-	if (!arg) {
-		fd = last_fd;
-		goto doit;
-	}
-	fd = atoi(arg);
-
-	arg = nextarg();
-	parse_nmr_config(arg, &curr_nmr);
-
-doit:
-	ret = ioctl(fd, NIOCGINFO, &curr_nmr);
-	last_memsize = curr_nmr.nr_memsize;
-	output_err(ret, "ioctl(%d, NIOCGINFO) for %s: region %d memsize=%zu",
-		fd, name, curr_nmr.nr_arg2, last_memsize);
-}
-
-
-void do_regif()
-{
-	int ret;
-	char *arg, *name;
-	int fd = last_fd;
-
-	name = nextarg();
-	if (!name) {
-		name = nmr_name;
-		goto doit;
-	}
-
-	bzero(&curr_nmr, sizeof(curr_nmr));
-	curr_nmr.nr_version = NETMAP_API;
-	strncpy(curr_nmr.nr_name, name, sizeof(curr_nmr.nr_name));
-
-	arg = nextarg();
-	if (!arg) {
-		goto doit;
-	}
-	fd = atoi(arg);
-
-	arg = nextarg();
-	parse_nmr_config(arg, &curr_nmr);
-
-doit:
-	ret = ioctl(fd, NIOCREGIF, &curr_nmr);
-	last_memsize = curr_nmr.nr_memsize;
-	output_err(ret, "ioctl(%d, NIOCREGIF) for %s: region %d memsize=%zu",
-		fd, name, curr_nmr.nr_arg2, last_memsize);
-}
-
-void
-do_txsync()
-{
-	char *arg = nextarg();
-	int fd = arg ? atoi(arg) : last_fd;
-	int ret = ioctl(fd, NIOCTXSYNC, NULL);
-	output_err(ret, "ioctl(%d, NIOCTXSYNC)=%d", fd, ret);
-}
-
-void
-do_rxsync()
-{
-	char *arg = nextarg();
-	int fd = arg ? atoi(arg) : last_fd;
-	int ret = ioctl(fd, NIOCRXSYNC, NULL);
-	output_err(ret, "ioctl(%d, NIOCRXSYNC)=%d", fd, ret);
-}
-#endif /* TEST_NETMAP */
-
-
-volatile char tmp1;
-void do_access()
-{
-	char *arg = nextarg();
-	char *p;
-	if (!arg) {
-		if (!last_access_addr) {
-			output("missing address");
-			return;
-		}
-		p = last_access_addr;
-	} else {
-		p = (char *)strtoul((void *)arg, NULL, 0);
-	}
-	last_access_addr = p + 4096;
-	tmp1 = *p;
-}
-
-void do_mmap()
-{
-	size_t memsize;
-	off_t off = 0;
-	int fd;
-	char *arg;
-
-	arg = nextarg();
-	if (!arg) {
-		memsize = last_memsize;
-		fd = last_fd;
-		goto doit;
-	}
-	memsize = atoi(arg);
-	arg = nextarg();
-	if (!arg) {
-		fd = last_fd;
-		goto doit;
-	}
-	fd = atoi(arg);
-	arg = nextarg();
-	if (arg) {
-		off = (off_t)atol(arg);
-	}
-doit:
-	last_mmap_addr = mmap(0, memsize,
-			PROT_WRITE | PROT_READ,
-			MAP_SHARED, fd, off);
-	if (last_access_addr == NULL)
-		last_access_addr = last_mmap_addr;
-	output_err(last_mmap_addr == MAP_FAILED ? -1 : 0,
-		"mmap(0, %zu, PROT_WRITE|PROT_READ, MAP_SHARED, %d, %jd)=%p",
-		memsize, fd, (intmax_t)off, last_mmap_addr);
-
-}
-
-void do_munmap()
-{
-	void *mmap_addr;
-	size_t memsize;
-	char *arg;
-	int ret;
-
-	arg = nextarg();
-	if (!arg) {
-		mmap_addr = last_mmap_addr;
-		memsize = last_memsize;
-		goto doit;
-	}
-	mmap_addr = (void*)strtoul(arg, NULL, 0);
-	arg = nextarg();
-	if (!arg) {
-		memsize = last_memsize;
-		goto doit;
-	}
-	memsize = (size_t)strtoul(arg, NULL, 0);
-doit:
-	ret = munmap(mmap_addr, memsize);
-	output_err(ret, "munmap(%p, %zu)=%d", mmap_addr, memsize, ret);
-}
-
-void do_poll()
-{
-	/* timeout fd fd... */
-	nfds_t nfds = 0, allocated_fds = 10, i;
-	struct pollfd *fds;
-	int timeout = 500; /* 1/2 second */
-	char *arg;
-	int ret;
-
-	arg = nextarg();
-	if (arg)
-		timeout = atoi(arg);
-	fds = malloc(allocated_fds * sizeof(struct pollfd));
-	if (fds == NULL) {
-		output_err(-1, "out of memory");
-		return;
-	}
-	while ( (arg = nextarg()) ) {
-		if (nfds >= allocated_fds) {
-			allocated_fds *= 2;
-			fds = realloc(fds, allocated_fds * sizeof(struct pollfd));
-			if (fds == NULL) {
-				output_err(-1, "out of memory");
-				return;
-			}
-		}
-		fds[nfds].fd = atoi(arg);
-		fds[nfds].events = POLLIN;
-		nfds++;
-	}
-	ret = poll(fds, nfds, timeout);
-	for (i = 0; i < nfds; i++) {
-		output("poll(%d)=%s%s%s%s%s", fds[i].fd, 
-			(fds[i].revents & POLLIN) ? "IN  " : "-   ",
-			(fds[i].revents & POLLOUT)? "OUT " : "-   ",
-			(fds[i].revents & POLLERR)? "ERR " : "-   ",
-			(fds[i].revents & POLLHUP)? "HUP " : "-   ",
-			(fds[i].revents & POLLNVAL)?"NVAL" : "-");
-
-	}
-	output_err(ret, "poll(...)=%d", ret);
-	free(fds);
-}
-
-
-void
-do_expr()
-{
-	unsigned long stack[11];
-	int top = 10;
-	char *arg;
-	int err = 0;
-
-	stack[10] = ULONG_MAX;
-	while ( (arg = nextarg()) ) {
-		errno = 0;
-		char *rest;
-		unsigned long n = strtoul(arg, &rest, 0);
-		if (!errno && rest != arg) {
-			if (top <= 0) {
-				err = -1;
-				break;
-			}
-			stack[--top] = n;
-			continue;
-		}
-		if (top <= 8) {
-			unsigned long n1 = stack[top++];
-			unsigned long n2 = stack[top++];
-			unsigned long r = 0;
-			switch (arg[0]) {
-			case '+':
-				r = n1 + n2;
-				break;
-			case '-':
-				r = n1 - n2;
-				break;
-			case '*':
-				r = n1 * n2;
-				break;
-			case '/':
-				if (n2)
-					r = n1 / n2;
-				else {
-					errno = EDOM;
-					err = -1;
-				}
-				break;
-			default:
-				err = -1;
-				break;
-			}
-			stack[--top] = r;
-			continue;
-		}
-		err = -1;
-		break;
-	}
-	output_err(err, "expr=%lu", stack[top]);
-}
-				
-			
-
-void
-do_echo()
-{
-	char *arg;
-	for (arg = nextarg(); arg; arg = nextarg()) {
-		printf("%s\n", arg);
-	}
-}
-
-void
-do_vars()
-{
-	int i;
-	for (i = 0; i < MAX_VARS; i++) {
-		const char *v = variables[i];
-		if (v == NULL)
-			continue;
-		printf("?%d\t%s\n", i, v == VAR_FAILED ?  "FAILED" : v);
-	}
-}
-
-
-struct cmd_def {
-	const char *name;
-	void (*f)(void);
-};
-
-int _find_command(const struct cmd_def *cmds, int ncmds, const char* cmd)
-{
-	int i;
-	for (i = 0; i < ncmds; i++) {
-		if (strcmp(cmds[i].name, cmd) == 0)
-			break;
-	}
-	return i;
-}
-
-typedef void (*nmr_arg_interp_fun)();
-
-#define nmr_arg_unexpected(n) \
-	printf("arg%d:      %d%s\n", n, curr_nmr.nr_arg ## n, \
-		(curr_nmr.nr_arg ## n ? "???" : ""))
-
-void
-nmr_arg_bdg_attach()
-{
-	uint16_t v = curr_nmr.nr_arg1;
-	printf("arg1:      %d [", v);
-	if (v == 0) {
-		printf("no host rings");
-	} else if (v == NETMAP_BDG_HOST) {
-		printf("BDG_HOST");
-	} else {
-		printf("???");
-	}
-	printf("]\n");
-	nmr_arg_unexpected(2);
-	nmr_arg_unexpected(3);
-}
-
-void
-nmr_arg_bdg_detach()
-{
-	nmr_arg_unexpected(1);
-	nmr_arg_unexpected(2);
-	nmr_arg_unexpected(3);
-}
-
-void
-nmr_arg_bdg_list()
-{
-}
-
-void
-nmr_arg_lookup_reg()
-{
-}
-
-void
-nmr_arg_vnet_hdr()
-{
-	printf("arg1:      %d [vnet hdr len]", curr_nmr.nr_arg1);
-	nmr_arg_unexpected(2);
-	nmr_arg_unexpected(3);
-}
-
-void
-nmr_arg_error()
-{
-	nmr_arg_unexpected(1);
-	nmr_arg_unexpected(2);
-	nmr_arg_unexpected(3);
-}
-
-void
-nmr_arg_extra()
-{
-	printf("arg1:      %d [%sextra rings]\n", curr_nmr.nr_arg1,
-		(curr_nmr.nr_arg1 ? "" : "no "));
-	printf("arg2:      %d [%s memory allocator]\n", curr_nmr.nr_arg2,
-		(curr_nmr.nr_arg2 == 0 ? "global" : "private"));
-	printf("arg3:      %d [%sextra buffers]\n", curr_nmr.nr_arg3,
-		(curr_nmr.nr_arg3 ? "" : "no "));
-}
-
-void
-do_nmr_dump()
-{
-	u_int ringid = curr_nmr.nr_ringid & NETMAP_RING_MASK;
-	nmr_arg_interp_fun arg_interp;
-
-	snprintf(nmr_name, IFNAMSIZ + 1, "%s", curr_nmr.nr_name);
-	nmr_name[IFNAMSIZ] = '\0';
-	printf("name:      %s\n", nmr_name);
-	printf("version:   %d\n", curr_nmr.nr_version);
-	printf("offset:    %d\n", curr_nmr.nr_offset);
-	printf("memsize:   %d [", curr_nmr.nr_memsize);
-	if (curr_nmr.nr_memsize < (1<<20)) {
-		printf("%d KiB", curr_nmr.nr_memsize >> 10);
-	} else {
-		printf("%d MiB", curr_nmr.nr_memsize >> 20);
-	}
-	printf("]\n");
-	printf("tx_slots:  %d\n", curr_nmr.nr_tx_slots);
-	printf("rx_slots:  %d\n", curr_nmr.nr_rx_slots);
-	printf("tx_rings:  %d\n", curr_nmr.nr_tx_rings);
-	printf("rx_rings:  %d\n", curr_nmr.nr_rx_rings);
-	printf("ringid:    %x [", curr_nmr.nr_ringid);
-	if (curr_nmr.nr_ringid & NETMAP_SW_RING) {
-		printf("host rings");
-	} else if (curr_nmr.nr_ringid & NETMAP_HW_RING) {
-		printf("hw ring %d", ringid);
-	} else {
-		printf("hw rings");
-	}
-	if (curr_nmr.nr_ringid & NETMAP_NO_TX_POLL) {
-		printf(", no tx poll");
-	}
-	printf(", region %d", curr_nmr.nr_arg2);
-	printf("]\n");
-	printf("cmd:       %d", curr_nmr.nr_cmd);
-	if (curr_nmr.nr_cmd) {
-		printf(" [");
-		switch (curr_nmr.nr_cmd) {
-		case NETMAP_BDG_ATTACH:
-			printf("BDG_ATTACH");
-			arg_interp = nmr_arg_bdg_attach;
-			break;
-		case NETMAP_BDG_DETACH:
-			printf("BDG_DETACH");
-			arg_interp = nmr_arg_bdg_detach;
-			break;
-		case NETMAP_BDG_LIST:
-			printf("BDG_LIST");
-			arg_interp = nmr_arg_bdg_list;
-			break;
-		case NETMAP_BDG_REGOPS:
-			printf("BDG_LOOKUP_REG");
-			arg_interp = nmr_arg_lookup_reg;
-			break;
-		case NETMAP_BDG_VNET_HDR:
-			printf("BDG_VNET_HDR");
-			arg_interp = nmr_arg_vnet_hdr;
-			break;
-		case NETMAP_BDG_NEWIF:
-			printf("BDG_NEWIF");
-			arg_interp = nmr_arg_error;
-			break;
-		case NETMAP_BDG_DELIF:
-			printf("BDG_DELIF");
-			arg_interp = nmr_arg_error;
-			break;
-		default:
-			printf("???");
-			arg_interp = nmr_arg_error;
-			break;
-		}
-		printf("]\n");
-	} else {
-		arg_interp = nmr_arg_extra;
-	}
-	printf("\n");
-	arg_interp();
-	printf("flags:     %x [", curr_nmr.nr_flags);
-	switch (curr_nmr.nr_flags & NR_REG_MASK) {
-	case NR_REG_DEFAULT:
-		printf("obey ringid");
-		break;
-	case NR_REG_ALL_NIC:
-		printf("ALL_NIC");
-		break;
-	case NR_REG_SW:
-		printf("SW");
-		break;
-	case NR_REG_NIC_SW:
-		printf("NIC_SW");
-		break;
-	case NR_REG_ONE_NIC:
-		printf("ONE_NIC(%d)", ringid);
-		break;
-	case NR_REG_PIPE_MASTER:
-		printf("PIPE_MASTER(%d)", ringid);
-		break;
-	case NR_REG_PIPE_SLAVE:
-		printf("PIPE_SLAVE(%d)", ringid);
-		break;
-	default:
-		printf("???");
-		break;
-	}
-	if (curr_nmr.nr_flags & NR_MONITOR_TX) {
-		printf(", MONITOR_TX");
-	}
-	if (curr_nmr.nr_flags & NR_MONITOR_RX) {
-		printf(", MONITOR_RX");
-	}
-	printf("]\n");
-	printf("spare2[0]: %x\n", curr_nmr.spare2[0]);
-}
-
-void
-do_nmr_reset()
-{
-	bzero(&curr_nmr, sizeof(curr_nmr));
-}
-
-void
-do_nmr_name()
-{
-	char *name = nextarg();
-	if (name) {
-		strncpy(curr_nmr.nr_name, name, IFNAMSIZ);
-	}
-	strncpy(nmr_name, curr_nmr.nr_name, IFNAMSIZ);
-	nmr_name[IFNAMSIZ] = '\0';
-	output("name=%s", nmr_name);
-}
-
-void
-do_nmr_ringid()
-{
-	char *arg;
-	uint16_t ringid = curr_nmr.nr_ringid;
-	int n;
-	for (n = 0, arg = nextarg(); arg; arg = nextarg(), n++) {
-		if (strcmp(arg, "hw-ring") == 0) {
-			ringid |= NETMAP_HW_RING; 	
-		} else if (strcmp(arg, "sw-ring") == 0) {
-			ringid |= NETMAP_SW_RING;
-		} else if (strcmp(arg, "no-tx-poll") == 0) {
-			ringid |= NETMAP_NO_TX_POLL;
-		} else if (strcmp(arg, "default") == 0) {
-			ringid = 0;
-		} else {
-			ringid &= ~NETMAP_RING_MASK;
-			ringid |= (atoi(arg) & NETMAP_RING_MASK);
-		}
-	}
-	if (n)
-		curr_nmr.nr_ringid = ringid;
-	output("ringid=%x", curr_nmr.nr_ringid);
-}
-
-void
-do_nmr_cmd()
-{
-	char *arg = nextarg();
-	if (arg == NULL)
-		goto out;
-
-	if (strcmp(arg, "bdg-attach") == 0) {
-		curr_nmr.nr_cmd = NETMAP_BDG_ATTACH;
-	} else if (strcmp(arg, "bdg-detach") == 0) {
-		curr_nmr.nr_cmd = NETMAP_BDG_DETACH;
-	} else if (strcmp(arg, "bdg-list") == 0) {
-		curr_nmr.nr_cmd = NETMAP_BDG_LIST;
-	} else if (strcmp(arg, "bdg-host") == 0) {
-		curr_nmr.nr_cmd = NETMAP_BDG_HOST;
-	} else if (strcmp(arg, "bdg-vnet-hdr") == 0) {
-		curr_nmr.nr_cmd = NETMAP_BDG_VNET_HDR;
-	} else if (strcmp(arg, "bdg-newif") == 0) {
-		curr_nmr.nr_cmd = NETMAP_BDG_NEWIF;
-	} else if (strcmp(arg, "bdg-delif") == 0) {
-		curr_nmr.nr_cmd = NETMAP_BDG_DELIF;
-	}
-out:
-	output("cmd=%x", curr_nmr.nr_cmd);
-}
-
-void
-do_nmr_flags()
-{
-	char *arg;
-	uint32_t flags = curr_nmr.nr_flags;
-	int n;
-	for (n = 0, arg = nextarg(); arg; arg = nextarg(), n++) {
-		if (strcmp(arg, "all-nic") == 0) {
-			flags &= ~NR_REG_MASK;
-			flags |= NR_REG_ALL_NIC;
-		} else if (strcmp(arg, "sw") == 0) {
-			flags &= ~NR_REG_MASK;
-			flags |= NR_REG_SW;
-		} else if (strcmp(arg, "nic-sw") == 0) {
-			flags &= ~NR_REG_MASK;
-			flags |= NR_REG_NIC_SW;
-		} else if (strcmp(arg, "pipe-master") == 0) {
-			flags &= ~NR_REG_MASK;
-			flags |= NR_REG_PIPE_MASTER;
-		} else if (strcmp(arg, "pipe-slave") == 0) {
-			flags &= ~NR_REG_MASK;
-			flags |= NR_REG_PIPE_SLAVE;
-		} else if (strcmp(arg, "monitor-tx") == 0) {
-			flags |= NR_MONITOR_TX;
-		} else if (strcmp(arg, "monitor-rx") == 0) {
-			flags |= NR_MONITOR_RX;
-		} else if (strcmp(arg, "default") == 0) {
-			flags = 0;
-		} 
-	}
-	if (n)
-		curr_nmr.nr_flags = flags;
-	output("flags=%x", curr_nmr.nr_flags);
-}
-
-struct cmd_def nmr_commands[] = {
-	{ "dump",	do_nmr_dump },
-	{ "reset",	do_nmr_reset },
-	{ "name",	do_nmr_name },
-	{ "ringid",	do_nmr_ringid },
-	{ "cmd",	do_nmr_cmd },
-	{ "flags",	do_nmr_flags },
-};
-
-const int N_NMR_CMDS = sizeof(nmr_commands) / sizeof(struct cmd_def);
-
-int
-find_nmr_command(const char *cmd)
-{
-	return _find_command(nmr_commands, N_NMR_CMDS, cmd);
-}
-
-#define nmr_arg_update(f) 				\
-	({						\
-		int __ret = 0;				\
-		if (strcmp(cmd, #f) == 0) {		\
-			char *arg = nextarg();		\
-			if (arg) {			\
-				curr_nmr.nr_##f = strtol(arg, NULL, 0); \
-			}				\
-			output(#f "=%d", curr_nmr.nr_##f);	\
-			__ret = 1;			\
-		} 					\
-		__ret;					\
-	})
-
-/* prepare the curr_nmr */
-void
-do_nmr()
-{
-	char *cmd = nextarg();
-	int i;
-
-	if (cmd == NULL) {
-		do_nmr_dump();
-		return;
-	}
-	if (cmd[0] == '.') {
-		cmd++;
-	} else {
-		i = find_nmr_command(cmd);
-		if (i < N_NMR_CMDS) {
-			nmr_commands[i].f();
-			return;
-		}
-	}
-	if (nmr_arg_update(version) ||
-	    nmr_arg_update(offset) ||
-	    nmr_arg_update(memsize) ||
-	    nmr_arg_update(tx_slots) ||
-	    nmr_arg_update(rx_slots) ||
-	    nmr_arg_update(tx_rings) ||
-	    nmr_arg_update(rx_rings) ||
-	    nmr_arg_update(ringid) ||
-	    nmr_arg_update(cmd) ||
-	    nmr_arg_update(arg1) ||
-	    nmr_arg_update(arg2) ||
-	    nmr_arg_update(arg3) ||
-	    nmr_arg_update(flags))
-		return;
-	output("unknown field: %s", cmd);
-}
-
-
-
-struct cmd_def commands[] = {
-	{ "open",	do_open,	},
-	{ "close", 	do_close,	},
-#ifdef TEST_NETMAP
-	{ "getinfo",	do_getinfo,	},
-	{ "regif",	do_regif,	},
-	{ "txsync",	do_txsync,	},
-	{ "rxsync",	do_rxsync,	},
-#endif /* TEST_NETMAP */
-	{ "mmap",	do_mmap,	},
-	{ "access",	do_access,	},
-	{ "munmap",	do_munmap,	},
-	{ "poll",	do_poll,	},
-	{ "expr",	do_expr,	},
-	{ "echo",	do_echo,	},
-	{ "vars",	do_vars,	},
-	{ "nmr",	do_nmr,		}
-};
-
-const int N_CMDS = sizeof(commands) / sizeof(struct cmd_def);
-
-int find_command(const char* cmd)
-{
-	return _find_command(commands, N_CMDS, cmd);
-}
-
-#define MAX_CHAN 10
-
-void prompt()
-{
-	if (isatty(STDIN_FILENO)) {
-		printf("> ");
-	}
-}
-
-struct chan *channels[MAX_CHAN];
-
-void*
-thread_cmd_loop(void *arg)
-{
-	char buf[1024];
-	FILE *in = (FILE*)arg;
-
-	while (fgets(buf, 1024, in)) {
-		char *cmd; 
-		int i;
-
-		cmd = firstarg(buf);
-		i = find_command(cmd);
-		if (i < N_CMDS) {
-			commands[i].f();
-			continue;
-		}
-		output("unknown cmd %s", cmd);
-	}
-	fclose(in);
-	return NULL;
-}
-
-void do_exit()
-{
-	output("quit");
-}
-
-void
-cmd_loop()
-{
-	char buf[1024];
-	int i;
-	struct chan *c;
-
-	bzero(channels, sizeof(*channels) * MAX_CHAN);
-
-	atexit(do_exit);
-
-	for (prompt(); fgets(buf, 1024, stdin); prompt()) {
-		char *cmd;
-		int slot;
-
-		cmd = firstarg(buf);
-		if (!cmd)
-			continue;
-		if (cmd[0] == '@') {
-			curr_var = atoi(cmd + 1);
-			if (curr_var < 0 || curr_var >= MAX_VARS)
-				curr_var = 0;
-			cmd = nextarg();
-			if (!cmd)
-				continue;
-		} else {
-			curr_var = 0;
-		}
-		
-		if (strcmp(cmd, "fork") == 0) {
-			int slot = chan_search_free(channels, MAX_CHAN);
-			struct chan *c = NULL;
-			pid_t pid;
-			int p1[2] = { -1, -1};
-
-			if (slot == MAX_CHAN) {
-				output("too many channels");
-				continue;
-			}
-			c = channels[slot] = (struct chan*)malloc(sizeof(struct chan));
-			if (c == NULL) {
-				output_err(-1, "malloc");
-				continue;
-			}
-			bzero(c, sizeof(*c));
-			if (pipe(p1) < 0) {
-				output_err(-1, "pipe");
-				goto clean1;
-			}
-			c->out = fdopen(p1[1], "w");
-			if (c->out == NULL) {
-				output_err(-1, "fdopen");
-				goto clean1;
-			}
-			pid = fork();
-			switch (pid) {
-			case -1:
-				output_err(-1, "fork");
-				goto clean1;
-			case 0:
-				fclose(stdin);
-				if (dup(p1[0]) < 0) {
-					output_err(-1, "dup");
-					exit(1);
-				}
-				close(p1[1]);
-				stdin = fdopen(0, "r");
-				chan_clear_all(channels, MAX_CHAN);
-				goto out;
-			default:
-				break;
-			}
-			c->pid = pid;
-			close(p1[0]);
-			output("fork()=%d slot=%d", pid, slot);
-			continue;
-		clean1:
-			if (c) {
-				fclose(c->out);
-			}
-			close(p1[0]);
-			close(p1[1]);
-			free(c);
-		out:
-			continue;
-		}
-		if (strcmp(cmd, "kill") == 0) {
-			int ret;
-
-			cmd = nextarg();
-			if (!cmd) {
-				output("missing slot");
-				continue;
-			}
-			slot = atoi(cmd);
-			if (slot < 0 || slot >= MAX_CHAN || !channels[slot]) {
-				output("invalid slot: %s", cmd);
-				continue;
-			}
-			c = channels[slot];
-			ret = kill(c->pid, SIGTERM);
-			output_err(ret, "kill(%d, SIGTERM)=%d", c->pid, ret);
-			if (ret != -1) {
-				wait(NULL);
-				fclose(c->out);
-				free(c);
-				channels[slot] = NULL;
-			}
-			continue;
-		}
-		if (strcmp(cmd, "thread") == 0) {
-			int slot = chan_search_free(channels, MAX_CHAN);
-			struct chan *c = NULL;
-			pthread_t tid;
-			int p1[2] = { -1, -1};
-			int ret;
-			FILE *in = NULL;
-			
-			if (slot == MAX_CHAN) {
-				output("too many channels");
-				continue;
-			}
-			c = channels[slot] = (struct chan*)malloc(sizeof(struct chan));
-			bzero(c, sizeof(*c));
-			if (pipe(p1) < 0) {
-				output_err(-1, "pipe");
-				goto clean2;
-			}
-			c->out = fdopen(p1[1], "w");
-			if (c->out == NULL) {
-				output_err(-1, "fdopen");
-				goto clean2;
-			}
-			in = fdopen(p1[0], "r");
-			if (in == NULL) {
-				output_err(-1, "fdopen");
-				goto clean2;
-			}
-			ret = pthread_create(&tid, NULL, thread_cmd_loop, in);
-			output_err(ret, "pthread_create() tid=%lu slot=%d", 
-				(unsigned long) tid, slot);
-			if (ret < 0)
-				goto clean2;
-			c->pid = getpid();
-			c->tid = tid;
-			continue;
-		clean2:
-			fclose(in);
-			fclose(c->out);
-			close(p1[0]);
-			close(p1[1]);
-			free(c);
-			continue;
-		}
-		if (strcmp(cmd, "cancel") == 0) {
-			int ret;
-
-			cmd = nextarg();
-			if (!cmd) {
-				output("missing slot");
-				continue;
-			}
-			slot = atoi(cmd);
-			if (slot < 0 || slot >= MAX_CHAN || !channels[slot]) {
-				output("invalid slot: %s", cmd);
-				continue;
-			}
-			c = channels[slot];
-			fclose(c->out);
-			ret = pthread_join(c->tid, NULL);
-			output_err(ret, "pthread_join(%lu)=%d", 
-				(unsigned long) c->tid, ret);
-			if (ret > 0) {
-				free(c);
-				channels[slot] = NULL;
-			}
-			continue;
-		}
-		i = find_command(cmd);
-		if (i < N_CMDS) {
-			commands[i].f();
-			continue;
-		}
-		slot = atoi(cmd);
-		if (slot < 0 || slot > MAX_CHAN || !channels[slot]) {
-			output("invalid cmd/slot: %s", cmd);
-			continue;
-		}
-		cmd = restofline();
-		if (!cmd) {
-			output("missing command");
-			continue;
-		}
-		fprintf(channels[slot]->out, "%s\n", cmd);
-		fflush(channels[slot]->out);
-		sleep(1);
-	}
-}
-
-int
-main(int argc, char **argv)
-{
-	(void) argc;
-	(void) argv;
-	cmd_loop();
-	return 0;
-}
diff --git a/drivers/staging/netmap/examples/vale-ctl.c b/drivers/staging/netmap/examples/vale-ctl.c
deleted file mode 100644
index c9e5f31b9206..000000000000
--- a/drivers/staging/netmap/examples/vale-ctl.c
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * Copyright (C) 2013-2014 Michio Honda. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *   1. Redistributions of source code must retain the above copyright
- *      notice, this list of conditions and the following disclaimer.
- *   2. Redistributions in binary form must reproduce the above copyright
- *      notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/* $FreeBSD$ */
-
-#include <errno.h>
-#include <stdio.h>
-#include <inttypes.h>	/* PRI* macros */
-#include <string.h>	/* strcmp */
-#include <fcntl.h>	/* open */
-#include <unistd.h>	/* close */
-#include <sys/ioctl.h>	/* ioctl */
-#include <sys/param.h>
-#include <sys/socket.h>	/* apple needs sockaddr */
-#include <net/if.h>	/* ifreq */
-#include <net/netmap.h>
-#include <net/netmap_user.h>
-#include <libgen.h>	/* basename */
-#include <stdlib.h>	/* atoi, free */
-
-/* debug support */
-#define ND(format, ...)	do {} while(0)
-#define D(format, ...)					\
-	fprintf(stderr, "%s [%d] " format "\n",		\
-	__FUNCTION__, __LINE__, ##__VA_ARGS__)
-
-/* XXX cut and paste from pkt-gen.c because I'm not sure whether this
- * program may include nm_util.h
- */
-void parse_nmr_config(const char* conf, struct nmreq *nmr)
-{
-	char *w, *tok;
-	int i, v;
-
-	nmr->nr_tx_rings = nmr->nr_rx_rings = 0;
-	nmr->nr_tx_slots = nmr->nr_rx_slots = 0;
-	if (conf == NULL || ! *conf)
-		return;
-	w = strdup(conf);
-	for (i = 0, tok = strtok(w, ","); tok; i++, tok = strtok(NULL, ",")) {
-		v = atoi(tok);
-		switch (i) {
-		case 0:
-			nmr->nr_tx_slots = nmr->nr_rx_slots = v;
-			break;
-		case 1:
-			nmr->nr_rx_slots = v;
-			break;
-		case 2:
-			nmr->nr_tx_rings = nmr->nr_rx_rings = v;
-			break;
-		case 3:
-			nmr->nr_rx_rings = v;
-			break;
-		default:
-			D("ignored config: %s", tok);
-			break;
-		}
-	}
-	D("txr %d txd %d rxr %d rxd %d",
-			nmr->nr_tx_rings, nmr->nr_tx_slots,
-			nmr->nr_rx_rings, nmr->nr_rx_slots);
-	free(w);
-}
-
-static int
-bdg_ctl(const char *name, int nr_cmd, int nr_arg, char *nmr_config)
-{
-	struct nmreq nmr;
-	int error = 0;
-	int fd = open("/dev/netmap", O_RDWR);
-
-	if (fd == -1) {
-		D("Unable to open /dev/netmap");
-		return -1;
-	}
-
-	bzero(&nmr, sizeof(nmr));
-	nmr.nr_version = NETMAP_API;
-	if (name != NULL) /* might be NULL */
-		strncpy(nmr.nr_name, name, sizeof(nmr.nr_name));
-	nmr.nr_cmd = nr_cmd;
-	parse_nmr_config(nmr_config, &nmr);
-
-	switch (nr_cmd) {
-	case NETMAP_BDG_DELIF:
-	case NETMAP_BDG_NEWIF:
-		error = ioctl(fd, NIOCREGIF, &nmr);
-		if (error == -1) {
-			ND("Unable to %s %s", nr_cmd == NETMAP_BDG_DELIF ? "delete":"create", name);
-			perror(name);
-		} else {
-			ND("Success to %s %s", nr_cmd == NETMAP_BDG_DELIF ? "delete":"create", name);
-		}
-		break;
-	case NETMAP_BDG_ATTACH:
-	case NETMAP_BDG_DETACH:
-		if (nr_arg && nr_arg != NETMAP_BDG_HOST)
-			nr_arg = 0;
-		nmr.nr_arg1 = nr_arg;
-		error = ioctl(fd, NIOCREGIF, &nmr);
-		if (error == -1) {
-			ND("Unable to %s %s to the bridge", nr_cmd ==
-			    NETMAP_BDG_DETACH?"detach":"attach", name);
-			perror(name);
-		} else
-			ND("Success to %s %s to the bridge", nr_cmd ==
-			    NETMAP_BDG_DETACH?"detach":"attach", name);
-		break;
-
-	case NETMAP_BDG_LIST:
-		if (strlen(nmr.nr_name)) { /* name to bridge/port info */
-			error = ioctl(fd, NIOCGINFO, &nmr);
-			if (error) {
-				ND("Unable to obtain info for %s", name);
-				perror(name);
-			} else
-				D("%s at bridge:%d port:%d", name, nmr.nr_arg1,
-				    nmr.nr_arg2);
-			break;
-		}
-
-		/* scan all the bridges and ports */
-		nmr.nr_arg1 = nmr.nr_arg2 = 0;
-		for (; !ioctl(fd, NIOCGINFO, &nmr); nmr.nr_arg2++) {
-			D("bridge:%d port:%d %s", nmr.nr_arg1, nmr.nr_arg2,
-			    nmr.nr_name);
-			nmr.nr_name[0] = '\0';
-		}
-
-		break;
-
-	default: /* GINFO */
-		nmr.nr_cmd = nmr.nr_arg1 = nmr.nr_arg2 = 0;
-		error = ioctl(fd, NIOCGINFO, &nmr);
-		if (error) {
-			ND("Unable to get if info for %s", name);
-			perror(name);
-		} else
-			D("%s: %d queues.", name, nmr.nr_rx_rings);
-		break;
-	}
-	close(fd);
-	return error;
-}
-
-int
-main(int argc, char *argv[])
-{
-	int ch, nr_cmd = 0, nr_arg = 0;
-	const char *command = basename(argv[0]);
-	char *name = NULL, *nmr_config = NULL;
-
-	if (argc > 3) {
-usage:
-		fprintf(stderr,
-			"Usage:\n"
-			"%s arguments\n"
-			"\t-g interface	interface name to get info\n"
-			"\t-d interface	interface name to be detached\n"
-			"\t-a interface	interface name to be attached\n"
-			"\t-h interface	interface name to be attached with the host stack\n"
-			"\t-n interface	interface name to be created\n"
-			"\t-r interface	interface name to be deleted\n"
-			"\t-l list all or specified bridge's interfaces (default)\n"
-			"\t-C string ring/slot setting of an interface creating by -n\n"
-			"", command);
-		return 0;
-	}
-
-	while ((ch = getopt(argc, argv, "d:a:h:g:l:n:r:C:")) != -1) {
-		name = optarg; /* default */
-		switch (ch) {
-		default:
-			fprintf(stderr, "bad option %c %s", ch, optarg);
-			goto usage;
-		case 'd':
-			nr_cmd = NETMAP_BDG_DETACH;
-			break;
-		case 'a':
-			nr_cmd = NETMAP_BDG_ATTACH;
-			break;
-		case 'h':
-			nr_cmd = NETMAP_BDG_ATTACH;
-			nr_arg = NETMAP_BDG_HOST;
-			break;
-		case 'n':
-			nr_cmd = NETMAP_BDG_NEWIF;
-			break;
-		case 'r':
-			nr_cmd = NETMAP_BDG_DELIF;
-			break;
-		case 'g':
-			nr_cmd = 0;
-			break;
-		case 'l':
-			nr_cmd = NETMAP_BDG_LIST;
-			if (optind < argc && argv[optind][0] == '-')
-				name = NULL;
-			break;
-		case 'C':
-			nmr_config = strdup(optarg);
-			break;
-		}
-		if (optind != argc) {
-			// fprintf(stderr, "optind %d argc %d\n", optind, argc);
-			goto usage;
-		}
-	}
-	if (argc == 1)
-		nr_cmd = NETMAP_BDG_LIST;
-	return bdg_ctl(name, nr_cmd, nr_arg, nmr_config) ? 1 : 0;
-}
diff --git a/drivers/staging/netmap/extra/bro-netmap.diff b/drivers/staging/netmap/extra/bro-netmap.diff
deleted file mode 100644
index 207e6412cd6b..000000000000
--- a/drivers/staging/netmap/extra/bro-netmap.diff
+++ /dev/null
@@ -1,95 +0,0 @@
-diff --git a/src/PktSrc.cc b/src/PktSrc.cc
-index 9d6bce6..e8f59dd 100644
---- a/src/PktSrc.cc
-+++ b/src/PktSrc.cc
-@@ -11,6 +11,26 @@
- #include "Net.h"
- #include "Sessions.h"
- 
-+#define HAVE_NETMAP
-+
-+#ifdef HAVE_NETMAP
-+
-+// Compile in netmap support. If the interface name starts with
-+// "netmap:" or "vale" we use a netmap fd instead of pcap, and bind
-+// one or all rings depending on NETMAP_RING_ID environment variable.
-+//
-+// For a test run  you can use the vale switch,
-+//	pkt-gen -i vale1:b -f tx -R ..rate_in_pps
-+// and launch bro like this
-+/*
-+
-+BROPATH=`./bro-path-dev` ./src/bro -i vale1:a -b -e 'global l=0; event p(){local s=net_stats(); local c=s$pkts_recvd;print c-l;l=c; schedule 1 sec {p()};} event bro_init(){event p();}'
-+
-+ */
-+#define NETMAP_WITH_LIBS
-+#include <net/netmap_user.h>
-+
-+#endif /* HAVE_NETMAP */
- 
- // ### This needs auto-confing.
- #ifdef HAVE_PCAP_INT_H
-@@ -75,7 +95,14 @@ int PktSrc::ExtractNextPacket()
- 		return 0;
- 		}
- 
-+#ifdef HAVE_NETMAP
-+	// in netmap mode call netmap equivalent of pcap_next()
-+	if (IS_NETMAP_DESC(pd))
-+		data = last_data = nm_nextpkt((struct nm_desc *)pd,
-+				(struct nm_pkthdr *)&hdr);
-+	else
-+#endif /* HAVE_NETMAP */
- 	data = last_data = pcap_next(pd, &hdr);
- 
- 	if ( data && (hdr.len == 0 || hdr.caplen == 0) )
- 		{
-@@ -407,6 +435,11 @@ void PktSrc::Close()
- 	{
- 	if ( pd )
- 		{
-+#ifdef HAVE_NETMAP
-+		if (IS_NETMAP_DESC(pd))
-+			nm_close((struct nm_desc *)pd);
-+		else
-+#endif /* HAVE_NETMAP */
- 		pcap_close(pd);
- 		pd = 0;
- 		closed = true;
-@@ -443,6 +476,14 @@ void PktSrc::Statistics(Stats* s)
- 	else
- 		{
- 		struct pcap_stat pstat;
-+#ifdef HAVE_NETMAP
-+		if (IS_NETMAP_DESC(pd))
-+			{
-+			s->dropped = stats.dropped;
-+			s->link = stats.received;
-+			}
-+		else
-+#endif /* HAVE_NETMAP */
- 		if ( pcap_stats(pd, &pstat) < 0 )
- 			{
- 			reporter->Error("problem getting packet filter statistics: %s",
-@@ -482,6 +523,21 @@ PktInterfaceSrc::PktInterfaceSrc(const char* arg_interface, const char* filter,
- 
- 	interface = copy_string(arg_interface);
- 
-+#ifdef HAVE_NETMAP
-+	pd = (pcap_t *)nm_open(interface, getenv("NETMAP_RING_ID"), 0, 0);
-+	// netmap interfaces are named netmap:* or vale*
-+	// If pd == 0 && errno == 0 "interface" is not a valid
-+	// netmap interface name, so we fall through to pcap
-+	if (pd || errno > 0)
-+		{
-+		if (pd)
-+			selectable_fd = NETMAP_FD(pd);
-+		else
-+			closed = true;
-+		return;
-+		}
-+#endif /* HAVE_NETMAP */
-+
- 	// Determine network and netmask.
- 	uint32 net;
- 	if ( pcap_lookupnet(interface, &net, &netmask, tmp_errbuf) < 0 )
diff --git a/drivers/staging/netmap/extra/libpcap-netmap.diff b/drivers/staging/netmap/extra/libpcap-netmap.diff
deleted file mode 100644
index cd6c38973f0b..000000000000
--- a/drivers/staging/netmap/extra/libpcap-netmap.diff
+++ /dev/null
@@ -1,389 +0,0 @@
-diff --git a/Makefile.in b/Makefile.in
-index 9995458..c670d66 100644
---- a/Makefile.in
-+++ b/Makefile.in
-@@ -83,7 +83,7 @@ YACC = @V_YACC@
- 	@rm -f $@
- 	$(CC) $(FULL_CFLAGS) -c $(srcdir)/$*.c
- 
--PSRC =	pcap-@V_PCAP@.c @USB_SRC@ @BT_SRC@ @CAN_SRC@ @NETFILTER_SRC@ @CANUSB_SRC@ @DBUS_SRC@
-+PSRC =	pcap-@V_PCAP@.c @USB_SRC@ @BT_SRC@ @CAN_SRC@ @NETFILTER_SRC@ @CANUSB_SRC@ @DBUS_SRC@ @NETMAP_SRC@
- FSRC =  fad-@V_FINDALLDEVS@.c
- SSRC =  @SSRC@
- CSRC =	pcap.c inet.c gencode.c optimize.c nametoaddr.c etherent.c \
-@@ -313,6 +313,7 @@ EXTRA_DIST = \
- 	pcap-namedb.h \
- 	pcap-netfilter-linux.c \
- 	pcap-netfilter-linux.h \
-+	pcap-netmap.c \
- 	pcap-nit.c \
- 	pcap-null.c \
- 	pcap-pf.c \
-diff --git a/config.h.in b/config.h.in
-index c6bc68e..09c8557 100644
---- a/config.h.in
-+++ b/config.h.in
-@@ -268,6 +268,9 @@
- /* target host supports netfilter sniffing */
- #undef PCAP_SUPPORT_NETFILTER
- 
-+/* target host supports netmap */
-+#undef PCAP_SUPPORT_NETMAP
-+
- /* target host supports USB sniffing */
- #undef PCAP_SUPPORT_USB
- 
-diff --git a/configure b/configure
-index be87668..a8d0cae 100755
---- a/configure
-+++ b/configure
-@@ -626,6 +626,8 @@ INSTALL_PROGRAM
- DBUS_SRC
- PCAP_SUPPORT_DBUS
- PKGCONFIG
-+NETMAP_SRC
-+PCAP_SUPPORT_NETMAP
- CAN_SRC
- PCAP_SUPPORT_CAN
- CANUSB_SRC
-@@ -747,6 +749,7 @@ enable_shared
- enable_bluetooth
- enable_canusb
- enable_can
-+enable_netmap
- enable_dbus
- '
-       ac_precious_vars='build_alias
-@@ -1385,6 +1388,8 @@ Optional Features:
-                           available]
-   --enable-can            enable CAN support [default=yes, if support
-                           available]
-+  --enable-netmap         enable netmap support [default=yes, if support
-+                          available]
-   --enable-dbus           enable D-Bus capture support [default=yes, if
-                           support available]
- 
-@@ -8148,6 +8153,39 @@ $as_echo "$as_me: no CAN sniffing support implemented for $host_os" >&6;}
- 
- fi
- 
-+# Check whether --enable-netmap was given.
-+if test "${enable_netmap+set}" = set; then :
-+  enableval=$enable_netmap;
-+else
-+  enable_netmap=yes
-+fi
-+
-+
-+if test "x$enable_netmap" != "xno" ; then
-+                case "$host_os" in
-+        *)
-+                ac_fn_c_check_header_compile "$LINENO" "net/netmap_user.h" "ac_cv_header_net_netmap_user_h" "#include <net/netmap_user.h>
-+
-+"
-+if test "x$ac_cv_header_net_netmap_user_h" = xyes; then :
-+
-+$as_echo "#define PCAP_SUPPORT_NETMAP 1" >>confdefs.h
-+
-+                        NETMAP_SRC=pcap-netmap.c
-+                        { $as_echo "$as_me:${as_lineno-$LINENO}: netmap is supported" >&5
-+$as_echo "$as_me: netmap is supported" >&6;}
-+else
-+  { $as_echo "$as_me:${as_lineno-$LINENO}: netmap is not supported" >&5
-+$as_echo "$as_me: netmap is not supported" >&6;}
-+fi
-+
-+
-+                ;;
-+        esac
-+
-+
-+fi
-+
- # Check whether --enable-dbus was given.
- if test "${enable_dbus+set}" = set; then :
-   enableval=$enable_dbus;
-diff --git a/configure.in b/configure.in
-index f0aa2c5..55464ba 100644
---- a/configure.in
-+++ b/configure.in
-@@ -1550,6 +1550,28 @@ if test "x$enable_can" != "xno" ; then
- 	AC_SUBST(CAN_SRC)
- fi
- 
-+AC_ARG_ENABLE([netmap],
-+[AC_HELP_STRING([--enable-netmap],[enable netmap support @<:@default=yes, if support available@:>@])],
-+    [],
-+    [enable_netmap=yes])
-+
-+if test "x$enable_netmap" != "xno" ; then
-+        dnl check for netmap support
-+        case "$host_os" in
-+        *)
-+                AC_CHECK_HEADER(net/netmap_user.h,
-+                        [ AC_DEFINE(PCAP_SUPPORT_NETMAP, 1, [target host supports netmap])
-+                        NETMAP_SRC=pcap-netmap.c
-+                        AC_MSG_NOTICE(netmap is supported)],
-+                        AC_MSG_NOTICE(netmap is not supported),
-+                        [#include <net/netmap_user.h>]
-+                   )
-+                ;;
-+        esac
-+        AC_SUBST(PCAP_SUPPORT_NETMAP)
-+        AC_SUBST(NETMAP_SRC)
-+fi
-+
- AC_ARG_ENABLE([dbus],
- [AC_HELP_STRING([--enable-dbus],[enable D-Bus capture support @<:@default=yes, if support available@:>@])],
-     [],
-diff --git a/inet.c b/inet.c
-index c699658..d132507 100644
---- a/inet.c
-+++ b/inet.c
-@@ -883,6 +883,10 @@ pcap_lookupnet(device, netp, maskp, errbuf)
- #ifdef PCAP_SUPPORT_USB
- 	    || strstr(device, "usbmon") != NULL
- #endif
-+#ifdef PCAP_SUPPORT_NETMAP
-+	    || !strncmp(device, "netmap:", 7)
-+	    || !strncmp(device, "vale", 4)
-+#endif
- #ifdef HAVE_SNF_API
- 	    || strstr(device, "snf") != NULL
- #endif
-diff --git a/pcap-netmap.c b/pcap-netmap.c
-new file mode 100644
-index 0000000..2568c2f
---- /dev/null
-+++ b/pcap-netmap.c
-@@ -0,0 +1,205 @@
-+/*
-+ * Copyright 2014 Universita` di Pisa
-+ *
-+ * packet filter subroutines for netmap
-+ */
-+
-+#ifdef HAVE_CONFIG_H
-+#include "config.h"
-+#endif
-+
-+#include <poll.h>
-+#include <ctype.h>
-+#include <errno.h>
-+#include <netdb.h>
-+#include <stdio.h>
-+#include <stdlib.h>
-+#include <string.h>
-+#include <unistd.h>
-+
-+#define NETMAP_WITH_LIBS
-+#include <net/netmap_user.h>
-+
-+#include "pcap-int.h"
-+
-+#if defined (linux)
-+/* On FreeBSD we use IFF_PPROMISC which is in ifr_flagshigh.
-+ * remap to IFF_PROMISC on linux
-+ */
-+#define IFF_PPROMISC	IFF_PROMISC
-+#define ifr_flagshigh	ifr_flags
-+#endif /* linux */
-+
-+struct pcap_netmap {
-+	struct nm_desc *d;	/* pointer returned by nm_open() */
-+	pcap_handler cb;	/* callback and argument */
-+	u_char *cb_arg;
-+	int must_clear_promisc;	/* flag */
-+	uint64_t rx_pkts;	/* count of packets received before the filter */
-+};
-+
-+static int
-+pcap_netmap_stats(pcap_t *p, struct pcap_stat *ps)
-+{
-+	struct pcap_netmap *pn = p->priv;
-+
-+	ps->ps_recv = pn->rx_pkts;
-+	ps->ps_drop = 0;
-+	ps->ps_ifdrop = 0;
-+	return 0;
-+}
-+
-+static void
-+pcap_netmap_filter(u_char *arg, struct pcap_pkthdr *h, const u_char *buf)
-+{
-+	pcap_t *p = (pcap_t *)arg;
-+	struct pcap_netmap *pn = p->priv;
-+
-+	++pn->rx_pkts;
-+	if (bpf_filter(p->fcode.bf_insns, buf, h->len, h->caplen))
-+		pn->cb(pn->cb_arg, h, buf);
-+}
-+
-+static int
-+pcap_netmap_dispatch(pcap_t *p, int cnt, pcap_handler cb, u_char *user)
-+{
-+	int ret;
-+	struct pcap_netmap *pn = p->priv;
-+	struct nm_desc *d = pn->d;
-+	struct pollfd pfd = { .fd = p->fd, .events = POLLIN, .revents = 0 };
-+
-+	pn->cb = cb;
-+	pn->cb_arg = user;
-+
-+	for (;;) {
-+		if (p->break_loop) {
-+			p->break_loop = 0;
-+			return PCAP_ERROR_BREAK;
-+		}
-+		/* nm_dispatch won't run forever */
-+		ret = nm_dispatch((void *)d, cnt, (void *)pcap_netmap_filter, (void *)p);
-+		if (ret != 0)
-+			break;
-+		poll(&pfd, 1, p->opt.timeout);
-+	}
-+	return ret;
-+}
-+
-+/* XXX need to check the NIOCTXSYNC/poll */
-+static int
-+pcap_netmap_inject(pcap_t *p, const void *buf, size_t size)
-+{
-+	struct nm_desc *d = ((struct pcap_netmap *)p->priv)->d;
-+
-+	return nm_inject(d, buf, size);
-+}
-+
-+static int
-+pcap_netmap_ioctl(pcap_t *p, u_long what, uint32_t *if_flags)
-+{
-+	struct pcap_netmap *pn = p->priv;
-+	struct nm_desc *d = pn->d;
-+	struct ifreq ifr;
-+	int error, fd = d->fd;
-+
-+#ifdef linux
-+	fd = socket(AF_INET, SOCK_DGRAM, 0);
-+	if (fd < 0) {
-+		fprintf(stderr, "Error: cannot get device control socket.\n");
-+		return -1;
-+	}
-+#endif /* linux */
-+	bzero(&ifr, sizeof(ifr));
-+	strncpy(ifr.ifr_name, d->req.nr_name, sizeof(ifr.ifr_name));
-+	switch (what) {
-+	case SIOCSIFFLAGS:
-+		ifr.ifr_flags = *if_flags;
-+		ifr.ifr_flagshigh = *if_flags >> 16;
-+		break;
-+	}
-+	error = ioctl(fd, what, &ifr);
-+	fprintf(stderr, "%s %s ioctl 0x%lx returns %d\n", __FUNCTION__,
-+		d->req.nr_name, what, error);
-+	if (error)
-+		return -1;
-+	switch (what) {
-+	case SIOCGIFFLAGS:
-+		*if_flags = ifr.ifr_flags | (ifr.ifr_flagshigh << 16);
-+	}
-+	return 0;
-+}
-+
-+static void
-+pcap_netmap_close(pcap_t *p)
-+{
-+	struct pcap_netmap *pn = p->priv;
-+	struct nm_desc *d = pn->d;
-+	uint32_t if_flags = 0;
-+
-+	if (pn->must_clear_promisc) {
-+		pcap_netmap_ioctl(p, SIOCGIFFLAGS, &if_flags); /* fetch flags */
-+		if (if_flags & IFF_PPROMISC) {
-+			if_flags &= ~IFF_PPROMISC;
-+			pcap_netmap_ioctl(p, SIOCSIFFLAGS, &if_flags);
-+		}
-+	}
-+	nm_close(d);
-+}
-+
-+static int
-+pcap_netmap_activate(pcap_t *p)
-+{
-+	struct pcap_netmap *pn = p->priv;
-+	struct nm_desc *d = nm_open(p->opt.source, NULL, 0, NULL);
-+	uint32_t if_flags = 0;
-+
-+	if (d == NULL) {
-+		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
-+			"netmap open: cannot access %s: %s\n",
-+			p->opt.source, pcap_strerror(errno));
-+		goto bad;
-+	}
-+	fprintf(stderr, "%s device %s priv %p fd %d ports %d..%d\n",
-+		__FUNCTION__, p->opt.source, d, d->fd, d->first_rx_ring, d->last_rx_ring);
-+	pn->d = d;
-+	p->fd = d->fd;
-+	if (p->opt.promisc && !(d->req.nr_ringid & NETMAP_SW_RING)) {
-+		pcap_netmap_ioctl(p, SIOCGIFFLAGS, &if_flags); /* fetch flags */
-+		if (!(if_flags & IFF_PPROMISC)) {
-+			pn->must_clear_promisc = 1;
-+			if_flags |= IFF_PPROMISC;
-+			pcap_netmap_ioctl(p, SIOCSIFFLAGS, &if_flags);
-+		}
-+	}
-+	p->linktype = DLT_EN10MB;
-+	p->selectable_fd = p->fd;
-+	p->read_op = pcap_netmap_dispatch;
-+	p->inject_op = pcap_netmap_inject,
-+	p->setfilter_op = install_bpf_program;
-+	p->setdirection_op = NULL;
-+	p->set_datalink_op = NULL;
-+	p->getnonblock_op = pcap_getnonblock_fd;
-+	p->setnonblock_op = pcap_setnonblock_fd;
-+	p->stats_op = pcap_netmap_stats;
-+	p->cleanup_op = pcap_netmap_close;
-+	return (0);
-+
-+    bad:
-+	pcap_cleanup_live_common(p);
-+	return (PCAP_ERROR);
-+}
-+
-+pcap_t *
-+pcap_netmap_create(const char *device, char *ebuf, int *is_ours)
-+{
-+	pcap_t *p;
-+
-+	*is_ours = (!strncmp(device, "netmap:", 7) || !strncmp(device, "vale", 4));
-+	if (! *is_ours)
-+		return NULL;
-+	p = pcap_create_common(device, ebuf, sizeof (struct pcap_netmap));
-+	if (p == NULL)
-+		return (NULL);
-+	p->activate_op = pcap_netmap_activate;
-+	return (p);
-+}
-diff --git a/pcap.c b/pcap.c
-index b2b5da6..beda714 100644
---- a/pcap.c
-+++ b/pcap.c
-@@ -104,6 +104,10 @@
- #include "pcap-dbus.h"
- #endif
- 
-+#ifdef PCAP_SUPPORT_NETMAP
-+pcap_t* pcap_netmap_create(const char *device, char *ebuf, int *is_ours);
-+#endif
-+
- int
- pcap_not_initialized(pcap_t *pcap _U_)
- {
-@@ -307,6 +311,9 @@ struct capture_source_type {
- 	int (*findalldevs_op)(pcap_if_t **, char *);
- 	pcap_t *(*create_op)(const char *, char *, int *);
- } capture_source_types[] = {
-+#ifdef PCAP_SUPPORT_NETMAP
-+	{ NULL, pcap_netmap_create },
-+#endif
- #ifdef HAVE_DAG_API
- 	{ dag_findalldevs, dag_create },
- #endif
diff --git a/drivers/staging/netmap/share/man/man4/netmap.4 b/drivers/staging/netmap/share/man/man4/netmap.4
deleted file mode 100644
index cd513a23f1bb..000000000000
--- a/drivers/staging/netmap/share/man/man4/netmap.4
+++ /dev/null
@@ -1,1075 +0,0 @@
-.\" Copyright (c) 2011-2014 Matteo Landi, Luigi Rizzo, Universita` di Pisa
-.\" All rights reserved.
-.\"
-.\" Redistribution and use in source and binary forms, with or without
-.\" modification, are permitted provided that the following conditions
-.\" are met:
-.\" 1. Redistributions of source code must retain the above copyright
-.\"    notice, this list of conditions and the following disclaimer.
-.\" 2. Redistributions in binary form must reproduce the above copyright
-.\"    notice, this list of conditions and the following disclaimer in the
-.\"    documentation and/or other materials provided with the distribution.
-.\"
-.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
-.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
-.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-.\" SUCH DAMAGE.
-.\"
-.\" This document is derived in part from the enet man page (enet.4)
-.\" distributed with 4.3BSD Unix.
-.\"
-.\" $FreeBSD: head/share/man/man4/netmap.4 228017 2011-11-27 06:55:57Z gjb $
-.\"
-.Dd February 13, 2014
-.Dt NETMAP 4
-.Os
-.Sh NAME
-.Nm netmap
-.Nd a framework for fast packet I/O
-.br
-.Nm VALE
-.Nd a fast VirtuAl Local Ethernet using the netmap API
-.br
-.Nm netmap pipes
-.Nd a shared memory packet transport channel
-.Sh SYNOPSIS
-.Cd device netmap
-.Sh DESCRIPTION
-.Nm
-is a framework for extremely fast and efficient packet I/O
-for both userspace and kernel clients.
-It runs on FreeBSD and Linux,
-and includes
-.Nm VALE ,
-a very fast and modular in-kernel software switch/dataplane,
-and
-.Nm netmap pipes ,
-a shared memory packet transport channel.
-All these are accessed interchangeably with the same API.
-.Pp
-.Nm , VALE
-and
-.Nm netmap pipes
-are at least one order of magnitude faster than
-standard OS mechanisms
-(sockets, bpf, tun/tap interfaces, native switches, pipes),
-reaching 14.88 million packets per second (Mpps)
-with much less than one core on a 10 Gbit NIC,
-about 20 Mpps per core for VALE ports,
-and over 100 Mpps for netmap pipes.
-.Pp
-Userspace clients can dynamically switch NICs into
-.Nm
-mode and send and receive raw packets through
-memory mapped buffers.
-Similarly,
-.Nm VALE
-switch instances and ports, and
-.Nm netmap pipes
-can be created dynamically,
-providing high speed packet I/O between processes,
-virtual machines, NICs and the host stack.
-.Pp
-.Nm
-suports both non-blocking I/O through
-.Xr ioctls() ,
-synchronization and blocking I/O through a file descriptor
-and standard OS mechanisms such as
-.Xr select 2 ,
-.Xr poll 2 ,
-.Xr epoll 2 ,
-.Xr kqueue 2 .
-.Nm VALE
-and
-.Nm netmap pipes
-are implemented by a single kernel module, which also emulates the
-.Nm
-API over standard drivers for devices without native
-.Nm
-support.
-For best performance,
-.Nm
-requires explicit support in device drivers.
-.Pp
-In the rest of this (long) manual page we document
-various aspects of the
-.Nm
-and
-.Nm VALE
-architecture, features and usage.
-.Pp
-.Sh ARCHITECTURE
-.Nm
-supports raw packet I/O through a
-.Em port ,
-which can be connected to a physical interface
-.Em ( NIC ) ,
-to the host stack,
-or to a
-.Nm VALE
-switch).
-Ports use preallocated circular queues of buffers
-.Em ( rings )
-residing in an mmapped region.
-There is one ring for each transmit/receive queue of a
-NIC or virtual port.
-An additional ring pair connects to the host stack.
-.Pp
-After binding a file descriptor to a port, a
-.Nm
-client can send or receive packets in batches through
-the rings, and possibly implement zero-copy forwarding
-between ports.
-.Pp
-All NICs operating in
-.Nm
-mode use the same memory region,
-accessible to all processes who own
-.Nm /dev/netmap
-file descriptors bound to NICs.
-Independent
-.Nm VALE
-and
-.Nm netmap pipe
-ports
-by default use separate memory regions,
-but can be independently configured to share memory.
-.Pp
-.Sh ENTERING AND EXITING NETMAP MODE
-The following section describes the system calls to create
-and control
-.Nm netmap 
-ports (including
-.Nm VALE
-and
-.Nm netmap pipe
-ports).
-Simpler, higher level functions are described in section
-.Xr LIBRARIES .
-.Pp
-Ports and rings are created and controlled through a file descriptor,
-created by opening a special device
-.Dl fd = open("/dev/netmap");
-and then bound to a specific port with an
-.Dl ioctl(fd, NIOCREGIF, (struct nmreq *)arg);
-.Pp
-.Nm
-has multiple modes of operation controlled by the
-.Vt struct nmreq
-argument.
-.Va arg.nr_name
-specifies the port name, as follows:
-.Bl -tag -width XXXX
-.It Dv OS network interface name (e.g. 'em0', 'eth1', ... )
-the data path of the NIC is disconnected from the host stack,
-and the file descriptor is bound to the NIC (one or all queues),
-or to the host stack;
-.It Dv valeXXX:YYY (arbitrary XXX and YYY)
-the file descriptor is bound to port YYY of a VALE switch called XXX,
-both dynamically created if necessary.
-The string cannot exceed IFNAMSIZ characters, and YYY cannot
-be the name of any existing OS network interface.
-.El
-.Pp
-On return,
-.Va arg
-indicates the size of the shared memory region,
-and the number, size and location of all the
-.Nm
-data structures, which can be accessed by mmapping the memory
-.Dl char *mem = mmap(0, arg.nr_memsize, fd);
-.Pp
-Non blocking I/O is done with special
-.Xr ioctl 2
-.Xr select 2
-and
-.Xr poll 2
-on the file descriptor permit blocking I/O.
-.Xr epoll 2
-and
-.Xr kqueue 2
-are not supported on
-.Nm
-file descriptors.
-.Pp
-While a NIC is in
-.Nm
-mode, the OS will still believe the interface is up and running.
-OS-generated packets for that NIC end up into a
-.Nm
-ring, and another ring is used to send packets into the OS network stack.
-A
-.Xr close 2
-on the file descriptor removes the binding,
-and returns the NIC to normal mode (reconnecting the data path
-to the host stack), or destroys the virtual port.
-.Pp
-.Sh DATA STRUCTURES
-The data structures in the mmapped memory region are detailed in
-.Xr sys/net/netmap.h ,
-which is the ultimate reference for the
-.Nm
-API. The main structures and fields are indicated below:
-.Bl -tag -width XXX
-.It Dv struct netmap_if (one per interface)
-.Bd -literal
-struct netmap_if {
-    ...
-    const uint32_t   ni_flags;      /* properties              */
-    ...
-    const uint32_t   ni_tx_rings;   /* NIC tx rings            */
-    const uint32_t   ni_rx_rings;   /* NIC rx rings            */
-    uint32_t         ni_bufs_head;  /* head of extra bufs list */
-    ...
-};
-.Ed
-.Pp
-Indicates the number of available rings
-.Pa ( struct netmap_rings )
-and their position in the mmapped region.
-The number of tx and rx rings
-.Pa ( ni_tx_rings , ni_rx_rings )
-normally depends on the hardware.
-NICs also have an extra tx/rx ring pair connected to the host stack.
-.Em NIOCREGIF
-can also request additional unbound buffers in the same memory space,
-to be used as temporary storage for packets.
-.Pa ni_bufs_head
-contains the index of the first of these free rings,
-which are connected in a list (the first uint32_t of each
-buffer being the index of the next buffer in the list).
-A 0 indicates the end of the list.
-.Pp
-.It Dv struct netmap_ring (one per ring)
-.Bd -literal
-struct netmap_ring {
-    ...
-    const uint32_t num_slots;   /* slots in each ring            */
-    const uint32_t nr_buf_size; /* size of each buffer           */
-    ...
-    uint32_t       head;        /* (u) first buf owned by user   */
-    uint32_t       cur;         /* (u) wakeup position           */
-    const uint32_t tail;        /* (k) first buf owned by kernel */
-    ...
-    uint32_t       flags;
-    struct timeval ts;          /* (k) time of last rxsync()     */
-    ...
-    struct netmap_slot slot[0]; /* array of slots                */
-}
-.Ed
-.Pp
-Implements transmit and receive rings, with read/write
-pointers, metadata and and an array of
-.Pa slots
-describing the buffers.
-.Pp
-.It Dv struct netmap_slot (one per buffer)
-.Bd -literal
-struct netmap_slot {
-    uint32_t buf_idx;           /* buffer index                 */
-    uint16_t len;               /* packet length                */
-    uint16_t flags;             /* buf changed, etc.            */
-    uint64_t ptr;               /* address for indirect buffers */
-};
-.Ed
-.Pp
-Describes a packet buffer, which normally is identified by
-an index and resides in the mmapped region.
-.It Dv packet buffers
-Fixed size (normally 2 KB) packet buffers allocated by the kernel.
-.El
-.Pp
-The offset of the
-.Pa struct netmap_if
-in the mmapped region is indicated by the
-.Pa nr_offset
-field in the structure returned by
-.Pa NIOCREGIF .
-From there, all other objects are reachable through
-relative references (offsets or indexes).
-Macros and functions in <net/netmap_user.h>
-help converting them into actual pointers:
-.Pp
-.Dl struct netmap_if  *nifp = NETMAP_IF(mem, arg.nr_offset);
-.Dl struct netmap_ring *txr = NETMAP_TXRING(nifp, ring_index);
-.Dl struct netmap_ring *rxr = NETMAP_RXRING(nifp, ring_index);
-.Pp
-.Dl char *buf = NETMAP_BUF(ring, buffer_index);
-.Sh RINGS, BUFFERS AND DATA I/O
-.Va Rings
-are circular queues of packets with three indexes/pointers
-.Va ( head , cur , tail ) ;
-one slot is always kept empty.
-The ring size
-.Va ( num_slots )
-should not be assumed to be a power of two.
-.br
-(NOTE: older versions of netmap used head/count format to indicate
-the content of a ring).
-.Pp
-.Va head
-is the first slot available to userspace;
-.br
-.Va cur
-is the wakeup point:
-select/poll will unblock when
-.Va tail
-passes
-.Va cur ;
-.br
-.Va tail
-is the first slot reserved to the kernel.
-.Pp
-Slot indexes MUST only move forward;
-for convenience, the function
-.Dl nm_ring_next(ring, index)
-returns the next index modulo the ring size.
-.Pp
-.Va head
-and
-.Va cur
-are only modified by the user program;
-.Va tail
-is only modified by the kernel.
-The kernel only reads/writes the
-.Vt struct netmap_ring
-slots and buffers
-during the execution of a netmap-related system call.
-The only exception are slots (and buffers) in the range
-.Va tail\  . . . head-1 ,
-that are explicitly assigned to the kernel.
-.Pp
-.Ss TRANSMIT RINGS
-On transmit rings, after a
-.Nm
-system call, slots in the range
-.Va head\  . . . tail-1
-are available for transmission.
-User code should fill the slots sequentially
-and advance
-.Va head
-and
-.Va cur
-past slots ready to transmit.
-.Va cur
-may be moved further ahead if the user code needs
-more slots before further transmissions (see
-.Sx SCATTER GATHER I/O ) .
-.Pp
-At the next NIOCTXSYNC/select()/poll(),
-slots up to
-.Va head-1
-are pushed to the port, and
-.Va tail
-may advance if further slots have become available.
-Below is an example of the evolution of a TX ring:
-.Pp
-.Bd -literal
-    after the syscall, slots between cur and tail are (a)vailable
-              head=cur   tail
-               |          |
-               v          v
-     TX  [.....aaaaaaaaaaa.............]
-
-    user creates new packets to (T)ransmit
-                head=cur tail
-                    |     |
-                    v     v
-     TX  [.....TTTTTaaaaaa.............]
-
-    NIOCTXSYNC/poll()/select() sends packets and reports new slots
-                head=cur      tail
-                    |          |
-                    v          v
-     TX  [..........aaaaaaaaaaa........]
-.Ed
-.Pp
-select() and poll() wlll block if there is no space in the ring, i.e.
-.Dl ring->cur == ring->tail
-and return when new slots have become available.
-.Pp
-High speed applications may want to amortize the cost of system calls
-by preparing as many packets as possible before issuing them.
-.Pp
-A transmit ring with pending transmissions has
-.Dl ring->head != ring->tail + 1 (modulo the ring size).
-The function
-.Va int nm_tx_pending(ring)
-implements this test.
-.Pp
-.Ss RECEIVE RINGS
-On receive rings, after a
-.Nm
-system call, the slots in the range
-.Va head\& . . . tail-1
-contain received packets.
-User code should process them and advance
-.Va head
-and
-.Va cur
-past slots it wants to return to the kernel.
-.Va cur
-may be moved further ahead if the user code wants to
-wait for more packets
-without returning all the previous slots to the kernel.
-.Pp
-At the next NIOCRXSYNC/select()/poll(),
-slots up to
-.Va head-1
-are returned to the kernel for further receives, and
-.Va tail
-may advance to report new incoming packets.
-.br
-Below is an example of the evolution of an RX ring:
-.Bd -literal
-    after the syscall, there are some (h)eld and some (R)eceived slots
-           head  cur     tail
-            |     |       |
-            v     v       v
-     RX  [..hhhhhhRRRRRRRR..........]
-
-    user advances head and cur, releasing some slots and holding others
-               head cur  tail
-                 |  |     |
-                 v  v     v
-     RX  [..*****hhhRRRRRR...........]
-
-    NICRXSYNC/poll()/select() recovers slots and reports new packets
-               head cur        tail
-                 |  |           |
-                 v  v           v
-     RX  [.......hhhRRRRRRRRRRRR....]
-.Ed
-.Pp
-.Sh SLOTS AND PACKET BUFFERS
-Normally, packets should be stored in the netmap-allocated buffers
-assigned to slots when ports are bound to a file descriptor.
-One packet is fully contained in a single buffer.
-.Pp
-The following flags affect slot and buffer processing:
-.Bl -tag -width XXX
-.It NS_BUF_CHANGED
-it MUST be used when the buf_idx in the slot is changed.
-This can be used to implement
-zero-copy forwarding, see
-.Sx ZERO-COPY FORWARDING .
-.Pp
-.It NS_REPORT
-reports when this buffer has been transmitted.
-Normally,
-.Nm
-notifies transmit completions in batches, hence signals
-can be delayed indefinitely. This flag helps detecting
-when packets have been send and a file descriptor can be closed.
-.It NS_FORWARD
-When a ring is in 'transparent' mode (see
-.Sx TRANSPARENT MODE ) ,
-packets marked with this flags are forwarded to the other endpoint
-at the next system call, thus restoring (in a selective way)
-the connection between a NIC and the host stack.
-.It NS_NO_LEARN
-tells the forwarding code that the SRC MAC address for this
-packet must not be used in the learning bridge code.
-.It NS_INDIRECT
-indicates that the packet's payload is in a user-supplied buffer,
-whose user virtual address is in the 'ptr' field of the slot.
-The size can reach 65535 bytes.
-.br
-This is only supported on the transmit ring of
-.Nm VALE
-ports, and it helps reducing data copies in the interconnection
-of virtual machines.
-.It NS_MOREFRAG
-indicates that the packet continues with subsequent buffers;
-the last buffer in a packet must have the flag clear.
-.El
-.Sh SCATTER GATHER I/O
-Packets can span multiple slots if the
-.Va NS_MOREFRAG
-flag is set in all but the last slot.
-The maximum length of a chain is 64 buffers.
-This is normally used with
-.Nm VALE
-ports when connecting virtual machines, as they generate large
-TSO segments that are not split unless they reach a physical device.
-.Pp
-NOTE: The length field always refers to the individual
-fragment; there is no place with the total length of a packet.
-.Pp
-On receive rings the macro
-.Va NS_RFRAGS(slot)
-indicates the remaining number of slots for this packet,
-including the current one.
-Slots with a value greater than 1 also have NS_MOREFRAG set.
-.Sh IOCTLS
-.Nm
-uses two ioctls (NIOCTXSYNC, NIOCRXSYNC)
-for non-blocking I/O. They take no argument.
-Two more ioctls (NIOCGINFO, NIOCREGIF) are used
-to query and configure ports, with the following argument:
-.Bd -literal
-struct nmreq {
-    char      nr_name[IFNAMSIZ]; /* (i) port name                  */
-    uint32_t  nr_version;        /* (i) API version                */
-    uint32_t  nr_offset;         /* (o) nifp offset in mmap region */
-    uint32_t  nr_memsize;        /* (o) size of the mmap region    */
-    uint32_t  nr_tx_slots;       /* (i/o) slots in tx rings        */
-    uint32_t  nr_rx_slots;       /* (i/o) slots in rx rings        */
-    uint16_t  nr_tx_rings;       /* (i/o) number of tx rings       */
-    uint16_t  nr_rx_rings;       /* (i/o) number of tx rings       */
-    uint16_t  nr_ringid;         /* (i/o) ring(s) we care about    */
-    uint16_t  nr_cmd;            /* (i) special command            */
-    uint16_t  nr_arg1;           /* (i/o) extra arguments          */
-    uint16_t  nr_arg2;           /* (i/o) extra arguments          */
-    uint32_t  nr_arg3;           /* (i/o) extra arguments          */
-    uint32_t  nr_flags           /* (i/o) open mode                */
-    ...
-};
-.Ed
-.Pp
-A file descriptor obtained through
-.Pa /dev/netmap
-also supports the ioctl supported by network devices, see
-.Xr netintro 4 .
-.Pp
-.Bl -tag -width XXXX
-.It Dv NIOCGINFO
-returns EINVAL if the named port does not support netmap.
-Otherwise, it returns 0 and (advisory) information
-about the port.
-Note that all the information below can change before the
-interface is actually put in netmap mode.
-.Pp
-.Bl -tag -width XX
-.It Pa nr_memsize
-indicates the size of the
-.Nm
-memory region. NICs in
-.Nm
-mode all share the same memory region,
-whereas
-.Nm VALE
-ports have independent regions for each port.
-.It Pa nr_tx_slots , nr_rx_slots
-indicate the size of transmit and receive rings.
-.It Pa nr_tx_rings , nr_rx_rings
-indicate the number of transmit
-and receive rings.
-Both ring number and sizes may be configured at runtime
-using interface-specific functions (e.g.
-.Xr ethtool
-).
-.El
-.It Dv NIOCREGIF
-binds the port named in
-.Va nr_name
-to the file descriptor. For a physical device this also switches it into
-.Nm
-mode, disconnecting
-it from the host stack.
-Multiple file descriptors can be bound to the same port,
-with proper synchronization left to the user.
-.Pp
-.Dv NIOCREGIF can also bind a file descriptor to one endpoint of a
-.Em netmap pipe ,
-consisting of two netmap ports with a crossover connection.
-A netmap pipe share the same memory space of the parent port,
-and is meant to enable configuration where a master process acts
-as a dispatcher towards slave processes.
-.Pp
-To enable this function, the
-.Pa nr_arg1
-field of the structure can be used as a hint to the kernel to
-indicate how many pipes we expect to use, and reserve extra space
-in the memory region.
-.Pp
-On return, it gives the same info as NIOCGINFO,
-with
-.Pa nr_ringid
-and
-.Pa nr_flags
-indicating the identity of the rings controlled through the file
-descriptor.
-.Pp
-.Va nr_flags
-.Va nr_ringid
-selects which rings are controlled through this file descriptor.
-Possible values of
-.Pa nr_flags
-are indicated below, together with the naming schemes
-that application libraries (such as the
-.Nm nm_open
-indicated below) can use to indicate the specific set of rings.
-In the example below, "netmap:foo" is any valid netmap port name.
-.Pp
-.Bl -tag -width XXXXX
-.It NR_REG_ALL_NIC                         "netmap:foo"
-(default) all hardware ring pairs
-.It NR_REG_SW_NIC           "netmap:foo^"
-the ``host rings'', connecting to the host stack.
-.It NR_RING_NIC_SW        "netmap:foo+
-all hardware rings and the host rings
-.It NR_REG_ONE_NIC       "netmap:foo-i"
-only the i-th hardware ring pair, where the number is in
-.Pa nr_ringid ;
-.It NR_REG_PIPE_MASTER  "netmap:foo{i"
-the master side of the netmap pipe whose identifier (i) is in
-.Pa nr_ringid ;
-.It NR_REG_PIPE_SLAVE   "netmap:foo}i"
-the slave side of the netmap pipe whose identifier (i) is in
-.Pa nr_ringid .
-.Pp
-The identifier of a pipe must be thought as part of the pipe name,
-and does not need to be sequential. On return the pipe
-will only have a single ring pair with index 0,
-irrespective of the value of i.
-.El
-.Pp
-By default, a
-.Xr poll 2
-or
-.Xr select 2
-call pushes out any pending packets on the transmit ring, even if
-no write events are specified.
-The feature can be disabled by or-ing
-.Va NETMAP_NO_TX_SYNC
-to the value written to
-.Va nr_ringid.
-When this feature is used,
-packets are transmitted only on
-.Va ioctl(NIOCTXSYNC)
-or select()/poll() are called with a write event (POLLOUT/wfdset) or a full ring.
-.Pp
-When registering a virtual interface that is dynamically created to a
-.Xr vale 4
-switch, we can specify the desired number of rings (1 by default,
-and currently up to 16) on it using nr_tx_rings and nr_rx_rings fields.
-.It Dv NIOCTXSYNC
-tells the hardware of new packets to transmit, and updates the
-number of slots available for transmission.
-.It Dv NIOCRXSYNC
-tells the hardware of consumed packets, and asks for newly available
-packets.
-.El
-.Sh SELECT, POLL, EPOLL, KQUEUE.
-.Xr select 2
-and
-.Xr poll 2
-on a
-.Nm
-file descriptor process rings as indicated in
-.Sx TRANSMIT RINGS
-and
-.Sx RECEIVE RINGS ,
-respectively when write (POLLOUT) and read (POLLIN) events are requested.
-Both block if no slots are available in the ring
-.Va ( ring->cur == ring->tail ) .
-Depending on the platform,
-.Xr epoll 2
-and
-.Xr kqueue 2
-are supported too.
-.Pp
-Packets in transmit rings are normally pushed out
-(and buffers reclaimed) even without
-requesting write events. Passing the NETMAP_NO_TX_SYNC flag to
-.Em NIOCREGIF
-disables this feature.
-By default, receive rings are processed only if read
-events are requested. Passing the NETMAP_DO_RX_SYNC flag to
-.Em NIOCREGIF updates receive rings even without read events.
-Note that on epoll and kqueue, NETMAP_NO_TX_SYNC and NETMAP_DO_RX_SYNC
-only have an effect when some event is posted for the file descriptor.
-.Sh LIBRARIES
-The
-.Nm
-API is supposed to be used directly, both because of its simplicity and
-for efficient integration with applications.
-.Pp
-For conveniency, the
-.Va <net/netmap_user.h>
-header provides a few macros and functions to ease creating
-a file descriptor and doing I/O with a
-.Nm
-port. These are loosely modeled after the
-.Xr pcap 3
-API, to ease porting of libpcap-based applications to
-.Nm .
-To use these extra functions, programs should
-.Dl #define NETMAP_WITH_LIBS
-before
-.Dl #include <net/netmap_user.h>
-.Pp
-The following functions are available:
-.Bl -tag -width XXXXX
-.It Va  struct nm_desc * nm_open(const char *ifname, const struct nmreq *req, uint64_t flags, const struct nm_desc *arg)
-similar to
-.Xr pcap_open ,
-binds a file descriptor to a port.
-.Bl -tag -width XX
-.It Va ifname
-is a port name, in the form "netmap:XXX" for a NIC and "valeXXX:YYY" for a
-.Nm VALE
-port.
-.It Va req
-provides the initial values for the argument to the NIOCREGIF ioctl.
-The nm_flags and nm_ringid values are overwritten by parsing
-ifname and flags, and other fields can be overridden through
-the other two arguments.
-.It Va arg
-points to a struct nm_desc containing arguments (e.g. from a previously
-open file descriptor) that should override the defaults.
-The fields are used as described below
-.It Va flags
-can be set to a combination of the following flags:
-.Va NETMAP_NO_TX_POLL ,
-.Va NETMAP_DO_RX_POLL
-(copied into nr_ringid);
-.Va NM_OPEN_NO_MMAP (if arg points to the same memory region,
-avoids the mmap and uses the values from it);
-.Va NM_OPEN_IFNAME (ignores ifname and uses the values in arg);
-.Va NM_OPEN_ARG1 ,
-.Va NM_OPEN_ARG2 ,
-.Va NM_OPEN_ARG3 (uses the fields from arg);
-.Va NM_OPEN_RING_CFG (uses the ring number and sizes from arg).
-.El
-.It Va int nm_close(struct nm_desc *d)
-closes the file descriptor, unmaps memory, frees resources.
-.It Va int nm_inject(struct nm_desc *d, const void *buf, size_t size)
-similar to pcap_inject(), pushes a packet to a ring, returns the size
-of the packet is successful, or 0 on error;
-.It Va int nm_dispatch(struct nm_desc *d, int cnt, nm_cb_t cb, u_char *arg)
-similar to pcap_dispatch(), applies a callback to incoming packets
-.It Va u_char * nm_nextpkt(struct nm_desc *d, struct nm_pkthdr *hdr)
-similar to pcap_next(), fetches the next packet
-.Pp
-.El
-.Sh SUPPORTED DEVICES
-.Nm
-natively supports the following devices:
-.Pp
-On FreeBSD:
-.Xr em 4 ,
-.Xr igb 4 ,
-.Xr ixgbe 4 ,
-.Xr lem 4 ,
-.Xr re 4 .
-.Pp
-On Linux
-.Xr e1000 4 ,
-.Xr e1000e 4 ,
-.Xr igb 4 ,
-.Xr ixgbe 4 ,
-.Xr mlx4 4 ,
-.Xr forcedeth 4 ,
-.Xr r8169 4 .
-.Pp
-NICs without native support can still be used in
-.Nm
-mode through emulation. Performance is inferior to native netmap
-mode but still significantly higher than sockets, and approaching
-that of in-kernel solutions such as Linux's
-.Xr pktgen .
-.Pp
-Emulation is also available for devices with native netmap support,
-which can be used for testing or performance comparison.
-The sysctl variable
-.Va dev.netmap.admode
-globally controls how netmap mode is implemented.
-.Sh SYSCTL VARIABLES AND MODULE PARAMETERS
-Some aspect of the operation of
-.Nm
-are controlled through sysctl variables on FreeBSD
-.Em ( dev.netmap.* )
-and module parameters on Linux
-.Em ( /sys/module/netmap_lin/parameters/* ) :
-.Pp
-.Bl -tag -width indent
-.It Va dev.netmap.admode: 0
-Controls the use of native or emulated adapter mode.
-0 uses the best available option, 1 forces native and
-fails if not available, 2 forces emulated hence never fails.
-.It Va dev.netmap.generic_ringsize: 1024
-Ring size used for emulated netmap mode
-.It Va dev.netmap.generic_mit: 100000
-Controls interrupt moderation for emulated mode
-.It Va dev.netmap.mmap_unreg: 0
-.It Va dev.netmap.fwd: 0
-Forces NS_FORWARD mode
-.It Va dev.netmap.flags: 0
-.It Va dev.netmap.txsync_retry: 2
-.It Va dev.netmap.no_pendintr: 1
-Forces recovery of transmit buffers on system calls
-.It Va dev.netmap.mitigate: 1
-Propagates interrupt mitigation to user processes
-.It Va dev.netmap.no_timestamp: 0
-Disables the update of the timestamp in the netmap ring
-.It Va dev.netmap.verbose: 0
-Verbose kernel messages
-.It Va dev.netmap.buf_num: 163840
-.It Va dev.netmap.buf_size: 2048
-.It Va dev.netmap.ring_num: 200
-.It Va dev.netmap.ring_size: 36864
-.It Va dev.netmap.if_num: 100
-.It Va dev.netmap.if_size: 1024
-Sizes and number of objects (netmap_if, netmap_ring, buffers)
-for the global memory region. The only parameter worth modifying is
-.Va dev.netmap.buf_num
-as it impacts the total amount of memory used by netmap.
-.It Va dev.netmap.buf_curr_num: 0
-.It Va dev.netmap.buf_curr_size: 0
-.It Va dev.netmap.ring_curr_num: 0
-.It Va dev.netmap.ring_curr_size: 0
-.It Va dev.netmap.if_curr_num: 0
-.It Va dev.netmap.if_curr_size: 0
-Actual values in use.
-.It Va dev.netmap.bridge_batch: 1024
-Batch size used when moving packets across a
-.Nm VALE
-switch. Values above 64 generally guarantee good
-performance.
-.El
-.Sh SYSTEM CALLS
-.Nm
-uses
-.Xr select 2 ,
-.Xr poll 2 ,
-.Xr epoll
-and
-.Xr kqueue
-to wake up processes when significant events occur, and
-.Xr mmap 2
-to map memory.
-.Xr ioctl 2
-is used to configure ports and
-.Nm VALE switches .
-.Pp
-Applications may need to create threads and bind them to
-specific cores to improve performance, using standard
-OS primitives, see
-.Xr pthread 3 .
-In particular,
-.Xr pthread_setaffinity_np 3
-may be of use.
-.Sh CAVEATS
-No matter how fast the CPU and OS are,
-achieving line rate on 10G and faster interfaces
-requires hardware with sufficient performance.
-Several NICs are unable to sustain line rate with
-small packet sizes. Insufficient PCIe or memory bandwidth
-can also cause reduced performance.
-.Pp
-Another frequent reason for low performance is the use
-of flow control on the link: a slow receiver can limit
-the transmit speed.
-Be sure to disable flow control when running high
-speed experiments.
-.Pp
-.Ss SPECIAL NIC FEATURES
-.Nm
-is orthogonal to some NIC features such as
-multiqueue, schedulers, packet filters.
-.Pp
-Multiple transmit and receive rings are supported natively
-and can be configured with ordinary OS tools,
-such as
-.Xr ethtool
-or
-device-specific sysctl variables.
-The same goes for Receive Packet Steering (RPS)
-and filtering of incoming traffic.
-.Pp
-.Nm
-.Em does not use
-features such as
-.Em checksum offloading , TCP segmentation offloading ,
-.Em encryption , VLAN encapsulation/decapsulation ,
-etc. .
-When using netmap to exchange packets with the host stack,
-make sure to disable these features.
-.Sh EXAMPLES
-.Ss TEST PROGRAMS
-.Nm
-comes with a few programs that can be used for testing or
-simple applications.
-See the
-.Va examples/
-directory in
-.Nm
-distributions, or
-.Va tools/tools/netmap/
-directory in FreeBSD distributions.
-.Pp
-.Xr pkt-gen
-is a general purpose traffic source/sink.
-.Pp
-As an example
-.Dl pkt-gen -i ix0 -f tx -l 60
-can generate an infinite stream of minimum size packets, and
-.Dl pkt-gen -i ix0 -f rx
-is a traffic sink.
-Both print traffic statistics, to help monitor
-how the system performs.
-.Pp
-.Xr pkt-gen
-has many options can be uses to set packet sizes, addresses,
-rates, and use multiple send/receive threads and cores.
-.Pp
-.Xr bridge
-is another test program which interconnects two
-.Nm
-ports. It can be used for transparent forwarding between
-interfaces, as in
-.Dl bridge -i ix0 -i ix1
-or even connect the NIC to the host stack using netmap
-.Dl bridge -i ix0 -i ix0
-.Ss USING THE NATIVE API
-The following code implements a traffic generator
-.Pp
-.Bd -literal -compact
-#include <net/netmap_user.h>
-...
-void sender(void)
-{
-    struct netmap_if *nifp;
-    struct netmap_ring *ring;
-    struct nmreq nmr;
-    struct pollfd fds;
-
-    fd = open("/dev/netmap", O_RDWR);
-    bzero(&nmr, sizeof(nmr));
-    strcpy(nmr.nr_name, "ix0");
-    nmr.nm_version = NETMAP_API;
-    ioctl(fd, NIOCREGIF, &nmr);
-    p = mmap(0, nmr.nr_memsize, fd);
-    nifp = NETMAP_IF(p, nmr.nr_offset);
-    ring = NETMAP_TXRING(nifp, 0);
-    fds.fd = fd;
-    fds.events = POLLOUT;
-    for (;;) {
-	poll(&fds, 1, -1);
-	while (!nm_ring_empty(ring)) {
-	    i = ring->cur;
-	    buf = NETMAP_BUF(ring, ring->slot[i].buf_index);
-	    ... prepare packet in buf ...
-	    ring->slot[i].len = ... packet length ...
-	    ring->head = ring->cur = nm_ring_next(ring, i);
-	}
-    }
-}
-.Ed
-.Ss HELPER FUNCTIONS
-A simple receiver can be implemented using the helper functions
-.Bd -literal -compact
-#define NETMAP_WITH_LIBS
-#include <net/netmap_user.h>
-...
-void receiver(void)
-{
-    struct nm_desc *d;
-    struct pollfd fds;
-    u_char *buf;
-    struct nm_pkthdr h;
-    ...
-    d = nm_open("netmap:ix0", NULL, 0, 0);
-    fds.fd = NETMAP_FD(d);
-    fds.events = POLLIN;
-    for (;;) {
-	poll(&fds, 1, -1);
-        while ( (buf = nm_nextpkt(d, &h)) )
-	    consume_pkt(buf, h->len);
-    }
-    nm_close(d);
-}
-.Ed
-.Ss ZERO-COPY FORWARDING
-Since physical interfaces share the same memory region,
-it is possible to do packet forwarding between ports
-swapping buffers. The buffer from the transmit ring is used
-to replenish the receive ring:
-.Bd -literal -compact
-    uint32_t tmp;
-    struct netmap_slot *src, *dst;
-    ...
-    src = &src_ring->slot[rxr->cur];
-    dst = &dst_ring->slot[txr->cur];
-    tmp = dst->buf_idx;
-    dst->buf_idx = src->buf_idx;
-    dst->len = src->len;
-    dst->flags = NS_BUF_CHANGED;
-    src->buf_idx = tmp;
-    src->flags = NS_BUF_CHANGED;
-    rxr->head = rxr->cur = nm_ring_next(rxr, rxr->cur);
-    txr->head = txr->cur = nm_ring_next(txr, txr->cur);
-    ...
-.Ed
-.Ss ACCESSING THE HOST STACK
-The host stack is for all practical purposes just a regular ring pair,
-which you can access with the netmap API (e.g. with
-.Dl nm_open("netmap:eth0^", ... ) ;
-All packets that the host would send to an interface in
-.Nm
-mode end up into the RX ring, whereas all packets queued to the
-TX ring are send up to the host stack.
-.Ss VALE SWITCH
-A simple way to test the performance of a
-.Nm VALE
-switch is to attach a sender and a receiver to it,
-e.g. running the following in two different terminals:
-.Dl pkt-gen -i vale1:a -f rx # receiver
-.Dl pkt-gen -i vale1:b -f tx # sender
-The same example can be used to test netmap pipes, by simply
-changing port names, e.g.
-.Dl pkt-gen -i vale:x{3 -f rx # receiver on the master side
-.Dl pkt-gen -i vale:x}3 -f tx # sender on the slave side
-.Pp
-The following command attaches an interface and the host stack
-to a switch:
-.Dl vale-ctl -h vale2:em0
-Other
-.Nm
-clients attached to the same switch can now communicate
-with the network card or the host.
-.Pp
-.Sh SEE ALSO
-.Pp
-http://info.iet.unipi.it/~luigi/netmap/
-.Pp
-Luigi Rizzo, Revisiting network I/O APIs: the netmap framework,
-Communications of the ACM, 55 (3), pp.45-51, March 2012
-.Pp
-Luigi Rizzo, netmap: a novel framework for fast packet I/O,
-Usenix ATC'12, June 2012, Boston
-.Pp
-Luigi Rizzo, Giuseppe Lettieri,
-VALE, a switched ethernet for virtual machines,
-ACM CoNEXT'12, December 2012, Nice
-.Pp
-Luigi Rizzo, Giuseppe Lettieri, Vincenzo Maffione,
-Speeding up packet I/O in virtual machines,
-ACM/IEEE ANCS'13, October 2013, San Jose
-.Sh AUTHORS
-.An -nosplit
-The
-.Nm
-framework has been originally designed and implemented at the
-Universita` di Pisa in 2011 by
-.An Luigi Rizzo ,
-and further extended with help from
-.An Matteo Landi ,
-.An Gaetano Catalli ,
-.An Giuseppe Lettieri ,
-.An Vincenzo Maffione .
-.Pp
-.Nm
-and
-.Nm VALE
-have been funded by the European Commission within FP7 Projects
-CHANGE (257422) and OPENLAB (287581).
diff --git a/drivers/staging/netmap/sys/dev/netmap/if_em_netmap.h b/drivers/staging/netmap/sys/dev/netmap/if_em_netmap.h
deleted file mode 100644
index 3e1205bedea4..000000000000
--- a/drivers/staging/netmap/sys/dev/netmap/if_em_netmap.h
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
- * Copyright (C) 2011-2014 Matteo Landi, Luigi Rizzo. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * $FreeBSD: head/sys/dev/netmap/if_em_netmap.h 238985 2012-08-02 11:59:43Z luigi $
- *
- * netmap support for: em.
- *
- * For more details on netmap support please see ixgbe_netmap.h
- */
-
-
-#include <net/netmap.h>
-#include <sys/selinfo.h>
-#include <vm/vm.h>
-#include <vm/pmap.h>    /* vtophys ? */
-#include <dev/netmap/netmap_kern.h>
-
-
-// XXX do we need to block/unblock the tasks ?
-static void
-em_netmap_block_tasks(struct adapter *adapter)
-{
-	if (adapter->msix > 1) { /* MSIX */
-		int i;
-		struct tx_ring *txr = adapter->tx_rings;
-		struct rx_ring *rxr = adapter->rx_rings;
-
-		for (i = 0; i < adapter->num_queues; i++, txr++, rxr++) {
-			taskqueue_block(txr->tq);
-			taskqueue_drain(txr->tq, &txr->tx_task);
-			taskqueue_block(rxr->tq);
-			taskqueue_drain(rxr->tq, &rxr->rx_task);
-		}
-	} else {	/* legacy */
-		taskqueue_block(adapter->tq);
-		taskqueue_drain(adapter->tq, &adapter->link_task);
-		taskqueue_drain(adapter->tq, &adapter->que_task);
-	}
-}
-
-
-static void
-em_netmap_unblock_tasks(struct adapter *adapter)
-{
-	if (adapter->msix > 1) {
-		struct tx_ring *txr = adapter->tx_rings;
-		struct rx_ring *rxr = adapter->rx_rings;
-		int i;
-
-		for (i = 0; i < adapter->num_queues; i++) {
-			taskqueue_unblock(txr->tq);
-			taskqueue_unblock(rxr->tq);
-		}
-	} else { /* legacy */
-		taskqueue_unblock(adapter->tq);
-	}
-}
-
-
-/*
- * Register/unregister. We are already under netmap lock.
- */
-static int
-em_netmap_reg(struct netmap_adapter *na, int onoff)
-{
-	struct ifnet *ifp = na->ifp;
-	struct adapter *adapter = ifp->if_softc;
-
-	EM_CORE_LOCK(adapter);
-	em_disable_intr(adapter);
-
-	/* Tell the stack that the interface is no longer active */
-	ifp->if_drv_flags &= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
-
-	em_netmap_block_tasks(adapter);
-	/* enable or disable flags and callbacks in na and ifp */
-	if (onoff) {
-		nm_set_native_flags(na);
-	} else {
-		nm_clear_native_flags(na);
-	}
-	em_init_locked(adapter);	/* also enable intr */
-	em_netmap_unblock_tasks(adapter);
-	EM_CORE_UNLOCK(adapter);
-	return (ifp->if_drv_flags & IFF_DRV_RUNNING ? 0 : 1);
-}
-
-
-/*
- * Reconcile kernel and user view of the transmit ring.
- */
-static int
-em_netmap_txsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = kring->rhead;
-	/* generate an interrupt approximately every half ring */
-	u_int report_frequency = kring->nkr_num_slots >> 1;
-
-	/* device-specific */
-	struct adapter *adapter = ifp->if_softc;
-	struct tx_ring *txr = &adapter->tx_rings[kring->ring_id];
-
-	bus_dmamap_sync(txr->txdma.dma_tag, txr->txdma.dma_map,
-			BUS_DMASYNC_POSTREAD);
-
-	/*
-	 * First part: process new packets to send.
-	 */
-
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {	/* we have new packets to send */
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			u_int len = slot->len;
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			/* device-specific */
-			struct e1000_tx_desc *curr = &txr->tx_base[nic_i];
-			struct em_buffer *txbuf = &txr->tx_buffers[nic_i];
-			int flags = (slot->flags & NS_REPORT ||
-				nic_i == 0 || nic_i == report_frequency) ?
-				E1000_TXD_CMD_RS : 0;
-
-			NM_CHECK_ADDR_LEN(na, addr, len);
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				curr->buffer_addr = htole64(paddr);
-				/* buffer has changed, reload map */
-				netmap_reload_map(na, txr->txtag, txbuf->map, addr);
-			}
-			slot->flags &= ~(NS_REPORT | NS_BUF_CHANGED);
-
-			/* Fill the slot in the NIC ring. */
-			curr->upper.data = 0;
-			curr->lower.data = htole32(adapter->txd_cmd | len |
-				(E1000_TXD_CMD_EOP | flags) );
-			bus_dmamap_sync(txr->txtag, txbuf->map,
-				BUS_DMASYNC_PREWRITE);
-
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-
-		/* synchronize the NIC ring */
-		bus_dmamap_sync(txr->txdma.dma_tag, txr->txdma.dma_map,
-			BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-
-		/* (re)start the tx unit up to slot nic_i (excluded) */
-		E1000_WRITE_REG(&adapter->hw, E1000_TDT(txr->me), nic_i);
-	}
-
-	/*
-	 * Second part: reclaim buffers for completed transmissions.
-	 */
-	if (flags & NAF_FORCE_RECLAIM || nm_kr_txempty(kring)) {
-		/* record completed transmissions using TDH */
-		nic_i = E1000_READ_REG(&adapter->hw, E1000_TDH(kring->ring_id));
-		if (nic_i >= kring->nkr_num_slots) { /* XXX can it happen ? */
-			D("TDH wrap %d", nic_i);
-			nic_i -= kring->nkr_num_slots;
-		}
-		if (nic_i != txr->next_to_clean) {
-			txr->next_to_clean = nic_i;
-			kring->nr_hwtail = nm_prev(netmap_idx_n2k(kring, nic_i), lim);
-		}
-	}
-
-	nm_txsync_finalize(kring);
-
-	return 0;
-}
-
-
-/*
- * Reconcile kernel and user view of the receive ring.
- */
-static int
-em_netmap_rxsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = nm_rxsync_prologue(kring);
-	int force_update = (flags & NAF_FORCE_READ) || kring->nr_kflags & NKR_PENDINTR;
-
-	/* device-specific */
-	struct adapter *adapter = ifp->if_softc;
-	struct rx_ring *rxr = &adapter->rx_rings[kring->ring_id];
-
-	if (head > lim)
-		return netmap_ring_reinit(kring);
-
-	/* XXX check sync modes */
-	bus_dmamap_sync(rxr->rxdma.dma_tag, rxr->rxdma.dma_map,
-			BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
-
-	/*
-	 * First part: import newly received packets.
-	 */
-	if (netmap_no_pendintr || force_update) {
-		uint16_t slot_flags = kring->nkr_slot_flags;
-
-		nic_i = rxr->next_to_check;
-		nm_i = netmap_idx_n2k(kring, nic_i);
-
-		for (n = 0; ; n++) { // XXX no need to count
-			struct e1000_rx_desc *curr = &rxr->rx_base[nic_i];
-			uint32_t staterr = le32toh(curr->status);
-
-			if ((staterr & E1000_RXD_STAT_DD) == 0)
-				break;
-			ring->slot[nm_i].len = le16toh(curr->length);
-			ring->slot[nm_i].flags = slot_flags;
-			bus_dmamap_sync(rxr->rxtag, rxr->rx_buffers[nic_i].map,
-				BUS_DMASYNC_POSTREAD);
-			nm_i = nm_next(nm_i, lim);
-			/* make sure next_to_refresh follows next_to_check */
-			rxr->next_to_refresh = nic_i;	// XXX
-			nic_i = nm_next(nic_i, lim);
-		}
-		if (n) { /* update the state variables */
-			rxr->next_to_check = nic_i;
-			kring->nr_hwtail = nm_i;
-		}
-		kring->nr_kflags &= ~NKR_PENDINTR;
-	}
-
-	/*
-	 * Second part: skip past packets that userspace has released.
-	 */
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			struct e1000_rx_desc *curr = &rxr->rx_base[nic_i];
-			struct em_buffer *rxbuf = &rxr->rx_buffers[nic_i];
-
-			if (addr == NETMAP_BUF_BASE(na)) /* bad buf */
-				goto ring_reset;
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				curr->buffer_addr = htole64(paddr);
-				netmap_reload_map(na, rxr->rxtag, rxbuf->map, addr);
-				slot->flags &= ~NS_BUF_CHANGED;
-			}
-			curr->status = 0;
-			bus_dmamap_sync(rxr->rxtag, rxbuf->map,
-			    BUS_DMASYNC_PREREAD);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-
-		bus_dmamap_sync(rxr->rxdma.dma_tag, rxr->rxdma.dma_map,
-		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-		/*
-		 * IMPORTANT: we must leave one free slot in the ring,
-		 * so move nic_i back by one unit
-		 */
-		nic_i = nm_prev(nic_i, lim);
-		E1000_WRITE_REG(&adapter->hw, E1000_RDT(rxr->me), nic_i);
-	}
-
-	/* tell userspace that there might be new packets */
-	nm_rxsync_finalize(kring);
-
-	return 0;
-
-ring_reset:
-	return netmap_ring_reinit(kring);
-}
-
-
-static void
-em_netmap_attach(struct adapter *adapter)
-{
-	struct netmap_adapter na;
-
-	bzero(&na, sizeof(na));
-
-	na.ifp = adapter->ifp;
-	na.na_flags = NAF_BDG_MAYSLEEP;
-	na.num_tx_desc = adapter->num_tx_desc;
-	na.num_rx_desc = adapter->num_rx_desc;
-	na.nm_txsync = em_netmap_txsync;
-	na.nm_rxsync = em_netmap_rxsync;
-	na.nm_register = em_netmap_reg;
-	na.num_tx_rings = na.num_rx_rings = adapter->num_queues;
-	netmap_attach(&na);
-}
-
-/* end of file */
diff --git a/drivers/staging/netmap/sys/dev/netmap/if_igb_netmap.h b/drivers/staging/netmap/sys/dev/netmap/if_igb_netmap.h
deleted file mode 100644
index 4edf95305e21..000000000000
--- a/drivers/staging/netmap/sys/dev/netmap/if_igb_netmap.h
+++ /dev/null
@@ -1,314 +0,0 @@
-/*
- * Copyright (C) 2011-2014 Universita` di Pisa. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * $FreeBSD: head/sys/dev/netmap/if_igb_netmap.h 256200 2013-10-09 17:32:52Z jfv $
- *
- * Netmap support for igb, partly contributed by Ahmed Kooli
- * For details on netmap support please see ixgbe_netmap.h
- */
-
-
-#include <net/netmap.h>
-#include <sys/selinfo.h>
-#include <vm/vm.h>
-#include <vm/pmap.h>    /* vtophys ? */
-#include <dev/netmap/netmap_kern.h>
-
-/*
- * Adaptation to different versions of the driver.
- */
-
-#ifndef IGB_MEDIA_RESET
-/* at the same time as IGB_MEDIA_RESET was defined, the
- * tx buffer descriptor was renamed, so use this to revert
- * back to the old name.
- */
-#define igb_tx_buf igb_tx_buffer
-#endif
-
-
-/*
- * Register/unregister. We are already under netmap lock.
- */
-static int
-igb_netmap_reg(struct netmap_adapter *na, int onoff)
-{
-	struct ifnet *ifp = na->ifp;
-	struct adapter *adapter = ifp->if_softc;
-
-	IGB_CORE_LOCK(adapter);
-	igb_disable_intr(adapter);
-
-	/* Tell the stack that the interface is no longer active */
-	ifp->if_drv_flags &= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
-
-	/* enable or disable flags and callbacks in na and ifp */
-	if (onoff) {
-		nm_set_native_flags(na);
-	} else {
-		nm_clear_native_flags(na);
-	}
-	igb_init_locked(adapter);	/* also enable intr */
-	IGB_CORE_UNLOCK(adapter);
-	return (ifp->if_drv_flags & IFF_DRV_RUNNING ? 0 : 1);
-}
-
-
-/*
- * Reconcile kernel and user view of the transmit ring.
- */
-static int
-igb_netmap_txsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = kring->rhead;
-	/* generate an interrupt approximately every half ring */
-	u_int report_frequency = kring->nkr_num_slots >> 1;
-
-	/* device-specific */
-	struct adapter *adapter = ifp->if_softc;
-	struct tx_ring *txr = &adapter->tx_rings[kring->ring_id];
-	/* 82575 needs the queue index added */
-	u32 olinfo_status =
-	    (adapter->hw.mac.type == e1000_82575) ? (txr->me << 4) : 0;
-
-	bus_dmamap_sync(txr->txdma.dma_tag, txr->txdma.dma_map,
-			BUS_DMASYNC_POSTREAD);
-
-	/*
-	 * First part: process new packets to send.
-	 */
-
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {	/* we have new packets to send */
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			u_int len = slot->len;
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			/* device-specific */
-			union e1000_adv_tx_desc *curr =
-			    (union e1000_adv_tx_desc *)&txr->tx_base[nic_i];
-			struct igb_tx_buf *txbuf = &txr->tx_buffers[nic_i];
-			int flags = (slot->flags & NS_REPORT ||
-				nic_i == 0 || nic_i == report_frequency) ?
-				E1000_ADVTXD_DCMD_RS : 0;
-
-			NM_CHECK_ADDR_LEN(na, addr, len);
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				netmap_reload_map(na, txr->txtag, txbuf->map, addr);
-			}
-			slot->flags &= ~(NS_REPORT | NS_BUF_CHANGED);
-
-			/* Fill the slot in the NIC ring. */
-			curr->read.buffer_addr = htole64(paddr);
-			// XXX check olinfo and cmd_type_len
-			curr->read.olinfo_status =
-			    htole32(olinfo_status |
-				(len<< E1000_ADVTXD_PAYLEN_SHIFT));
-			curr->read.cmd_type_len =
-			    htole32(len | E1000_ADVTXD_DTYP_DATA |
-			    E1000_ADVTXD_DCMD_IFCS |
-			    E1000_ADVTXD_DCMD_DEXT |
-			    E1000_ADVTXD_DCMD_EOP | flags);
-
-			/* make sure changes to the buffer are synced */
-			bus_dmamap_sync(txr->txtag, txbuf->map,
-				BUS_DMASYNC_PREWRITE);
-
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-
-		/* Set the watchdog XXX ? */
-		txr->queue_status = IGB_QUEUE_WORKING;
-		txr->watchdog_time = ticks;
-
-		/* synchronize the NIC ring */
-		bus_dmamap_sync(txr->txdma.dma_tag, txr->txdma.dma_map,
-			BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-
-		/* (re)start the tx unit up to slot nic_i (excluded) */
-		E1000_WRITE_REG(&adapter->hw, E1000_TDT(txr->me), nic_i);
-	}
-
-	/*
-	 * Second part: reclaim buffers for completed transmissions.
-	 */
-	if (flags & NAF_FORCE_RECLAIM || nm_kr_txempty(kring)) {
-		/* record completed transmissions using TDH */
-		nic_i = E1000_READ_REG(&adapter->hw, E1000_TDH(kring->ring_id));
-		if (nic_i >= kring->nkr_num_slots) { /* XXX can it happen ? */
-			D("TDH wrap %d", nic_i);
-			nic_i -= kring->nkr_num_slots;
-		}
-		txr->next_to_clean = nic_i;
-		kring->nr_hwtail = nm_prev(netmap_idx_n2k(kring, nic_i), lim);
-	}
-
-	nm_txsync_finalize(kring);
-
-	return 0;
-}
-
-
-/*
- * Reconcile kernel and user view of the receive ring.
- */
-static int
-igb_netmap_rxsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = nm_rxsync_prologue(kring);
-	int force_update = (flags & NAF_FORCE_READ) || kring->nr_kflags & NKR_PENDINTR;
-
-	/* device-specific */
-	struct adapter *adapter = ifp->if_softc;
-	struct rx_ring *rxr = &adapter->rx_rings[kring->ring_id];
-
-	if (head > lim)
-		return netmap_ring_reinit(kring);
-
-	/* XXX check sync modes */
-	bus_dmamap_sync(rxr->rxdma.dma_tag, rxr->rxdma.dma_map,
-			BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
-
-	/*
-	 * First part: import newly received packets.
-	 */
-	if (netmap_no_pendintr || force_update) {
-		uint16_t slot_flags = kring->nkr_slot_flags;
-
-		nic_i = rxr->next_to_check;
-		nm_i = netmap_idx_n2k(kring, nic_i);
-
-		for (n = 0; ; n++) {
-			union e1000_adv_rx_desc *curr = &rxr->rx_base[nic_i];
-			uint32_t staterr = le32toh(curr->wb.upper.status_error);
-
-			if ((staterr & E1000_RXD_STAT_DD) == 0)
-				break;
-			ring->slot[nm_i].len = le16toh(curr->wb.upper.length);
-			ring->slot[nm_i].flags = slot_flags;
-			bus_dmamap_sync(rxr->ptag,
-			    rxr->rx_buffers[nic_i].pmap, BUS_DMASYNC_POSTREAD);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		if (n) { /* update the state variables */
-			rxr->next_to_check = nic_i;
-			kring->nr_hwtail = nm_i;
-		}
-		kring->nr_kflags &= ~NKR_PENDINTR;
-	}
-
-	/*
-	 * Second part: skip past packets that userspace has released.
-	 */
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			union e1000_adv_rx_desc *curr = &rxr->rx_base[nic_i];
-			struct igb_rx_buf *rxbuf = &rxr->rx_buffers[nic_i];
-
-			if (addr == NETMAP_BUF_BASE(na)) /* bad buf */
-				goto ring_reset;
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				netmap_reload_map(na, rxr->ptag, rxbuf->pmap, addr);
-				slot->flags &= ~NS_BUF_CHANGED;
-			}
-			curr->wb.upper.status_error = 0;
-			curr->read.pkt_addr = htole64(paddr);
-			bus_dmamap_sync(rxr->ptag, rxbuf->pmap,
-			    BUS_DMASYNC_PREREAD);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-
-		bus_dmamap_sync(rxr->rxdma.dma_tag, rxr->rxdma.dma_map,
-		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-		/*
-		 * IMPORTANT: we must leave one free slot in the ring,
-		 * so move nic_i back by one unit
-		 */
-		nic_i = nm_prev(nic_i, lim);
-		E1000_WRITE_REG(&adapter->hw, E1000_RDT(rxr->me), nic_i);
-	}
-
-	/* tell userspace that there might be new packets */
-	nm_rxsync_finalize(kring);
-
-	return 0;
-
-ring_reset:
-	return netmap_ring_reinit(kring);
-}
-
-
-static void
-igb_netmap_attach(struct adapter *adapter)
-{
-	struct netmap_adapter na;
-
-	bzero(&na, sizeof(na));
-
-	na.ifp = adapter->ifp;
-	na.na_flags = NAF_BDG_MAYSLEEP;
-	na.num_tx_desc = adapter->num_tx_desc;
-	na.num_rx_desc = adapter->num_rx_desc;
-	na.nm_txsync = igb_netmap_txsync;
-	na.nm_rxsync = igb_netmap_rxsync;
-	na.nm_register = igb_netmap_reg;
-	na.num_tx_rings = na.num_rx_rings = adapter->num_queues;
-	netmap_attach(&na);
-}
-
-/* end of file */
diff --git a/drivers/staging/netmap/sys/dev/netmap/if_lem_netmap.h b/drivers/staging/netmap/sys/dev/netmap/if_lem_netmap.h
deleted file mode 100644
index 96f721156226..000000000000
--- a/drivers/staging/netmap/sys/dev/netmap/if_lem_netmap.h
+++ /dev/null
@@ -1,497 +0,0 @@
-/*
- * Copyright (C) 2011-2014 Matteo Landi, Luigi Rizzo. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-
-/*
- * $FreeBSD: head/sys/dev/netmap/if_lem_netmap.h 271849 2014-09-19 03:51:26Z glebius $
- *
- * netmap support for: lem
- *
- * For details on netmap support please see ixgbe_netmap.h
- */
-
-
-#include <net/netmap.h>
-#include <sys/selinfo.h>
-#include <vm/vm.h>
-#include <vm/pmap.h>    /* vtophys ? */
-#include <dev/netmap/netmap_kern.h>
-
-extern int netmap_adaptive_io;
-
-/*
- * Register/unregister. We are already under netmap lock.
- */
-static int
-lem_netmap_reg(struct netmap_adapter *na, int onoff)
-{
-	struct ifnet *ifp = na->ifp;
-	struct adapter *adapter = ifp->if_softc;
-
-	EM_CORE_LOCK(adapter);
-
-	lem_disable_intr(adapter);
-
-	/* Tell the stack that the interface is no longer active */
-	ifp->if_drv_flags &= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
-
-#ifndef EM_LEGACY_IRQ // XXX do we need this ?
-	taskqueue_block(adapter->tq);
-	taskqueue_drain(adapter->tq, &adapter->rxtx_task);
-	taskqueue_drain(adapter->tq, &adapter->link_task);
-#endif /* !EM_LEGCY_IRQ */
-
-	/* enable or disable flags and callbacks in na and ifp */
-	if (onoff) {
-		nm_set_native_flags(na);
-	} else {
-		nm_clear_native_flags(na);
-	}
-	lem_init_locked(adapter);	/* also enable intr */
-
-#ifndef EM_LEGACY_IRQ
-	taskqueue_unblock(adapter->tq); // XXX do we need this ?
-#endif /* !EM_LEGCY_IRQ */
-
-	EM_CORE_UNLOCK(adapter);
-
-	return (ifp->if_drv_flags & IFF_DRV_RUNNING ? 0 : 1);
-}
-
-
-/*
- * Reconcile kernel and user view of the transmit ring.
- */
-static int
-lem_netmap_txsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = kring->rhead;
-	/* generate an interrupt approximately every half ring */
-	u_int report_frequency = kring->nkr_num_slots >> 1;
-
-	/* device-specific */
-	struct adapter *adapter = ifp->if_softc;
-#ifdef NIC_PARAVIRT
-	struct paravirt_csb *csb = adapter->csb;
-	uint64_t *csbd = (uint64_t *)(csb + 1);
-#endif /* NIC_PARAVIRT */
-
-	bus_dmamap_sync(adapter->txdma.dma_tag, adapter->txdma.dma_map,
-			BUS_DMASYNC_POSTREAD);
-
-	/*
-	 * First part: process new packets to send.
-	 */
-
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {	/* we have new packets to send */
-#ifdef NIC_PARAVIRT
-		int do_kick = 0;
-		uint64_t t = 0; // timestamp
-		int n = head - nm_i;
-		if (n < 0)
-			n += lim + 1;
-		if (csb) {
-			t = rdtsc(); /* last timestamp */
-			csbd[16] += t - csbd[0]; /* total Wg */
-			csbd[17] += n;		/* Wg count */
-			csbd[0] = t;
-		}
-#endif /* NIC_PARAVIRT */
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		while (nm_i != head) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			u_int len = slot->len;
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			/* device-specific */
-			struct e1000_tx_desc *curr = &adapter->tx_desc_base[nic_i];
-			struct em_buffer *txbuf = &adapter->tx_buffer_area[nic_i];
-			int flags = (slot->flags & NS_REPORT ||
-				nic_i == 0 || nic_i == report_frequency) ?
-				E1000_TXD_CMD_RS : 0;
-
-			NM_CHECK_ADDR_LEN(na, addr, len);
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				curr->buffer_addr = htole64(paddr);
-				netmap_reload_map(na, adapter->txtag, txbuf->map, addr);
-			}
-			slot->flags &= ~(NS_REPORT | NS_BUF_CHANGED);
-
-			/* Fill the slot in the NIC ring. */
-			curr->upper.data = 0;
-			curr->lower.data = htole32(adapter->txd_cmd | len |
-				(E1000_TXD_CMD_EOP | flags) );
-			bus_dmamap_sync(adapter->txtag, txbuf->map,
-				BUS_DMASYNC_PREWRITE);
-
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-			// XXX might try an early kick
-		}
-		kring->nr_hwcur = head;
-
-		 /* synchronize the NIC ring */
-		bus_dmamap_sync(adapter->txdma.dma_tag, adapter->txdma.dma_map,
-			BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-
-#ifdef NIC_PARAVIRT
-		/* set unconditionally, then also kick if needed */
-		if (csb) {
-			t = rdtsc();
-			if (csb->host_need_txkick == 2) {
-				/* can compute an update of delta */
-				int64_t delta = t - csbd[3];
-				if (delta < 0)
-					delta = -delta;
-				if (csbd[8] == 0 || delta < csbd[8]) {
-					csbd[8] = delta;
-					csbd[9]++;
-				}
-				csbd[10]++;
-			}
-			csb->guest_tdt = nic_i;
-			csbd[18] += t - csbd[0]; // total wp
-			csbd[19] += n;
-		}
-		if (!csb || !csb->guest_csb_on || (csb->host_need_txkick & 1))
-			do_kick = 1;
-		if (do_kick)
-#endif /* NIC_PARAVIRT */
-		/* (re)start the tx unit up to slot nic_i (excluded) */
-		E1000_WRITE_REG(&adapter->hw, E1000_TDT(0), nic_i);
-#ifdef NIC_PARAVIRT
-		if (do_kick) {
-			uint64_t t1 = rdtsc();
-			csbd[20] += t1 - t; // total Np
-			csbd[21]++;
-		}
-#endif /* NIC_PARAVIRT */
-	}
-
-	/*
-	 * Second part: reclaim buffers for completed transmissions.
-	 */
-	if (ticks != kring->last_reclaim || flags & NAF_FORCE_RECLAIM || nm_kr_txempty(kring)) {
-		kring->last_reclaim = ticks;
-		/* record completed transmissions using TDH */
-#ifdef NIC_PARAVIRT
-		/* host updates tdh unconditionally, and we have
-		 * no side effects on reads, so we can read from there
-		 * instead of exiting.
-		 */
-		if (csb) {
-		    static int drain = 0, nodrain=0, good = 0, bad = 0, fail = 0;
-		    u_int x = adapter->next_tx_to_clean;
-		    csbd[19]++; // XXX count reclaims
-		    nic_i = csb->host_tdh;
-		    if (csb->guest_csb_on) {
-			if (nic_i == x) {
-			    bad++;
-		    	    csbd[24]++; // failed reclaims
-			    /* no progress, request kick and retry */
-			    csb->guest_need_txkick = 1;
-			    mb(); // XXX barrier
-		    	    nic_i = csb->host_tdh;
-			} else {
-			    good++;
-			}
-			if (nic_i != x) {
-			    csb->guest_need_txkick = 2;
-			    if (nic_i == csb->guest_tdt)
-				drain++;
-			    else
-				nodrain++;
-#if 1
-			if (netmap_adaptive_io) {
-			    /* new mechanism: last half ring (or so)
-			     * released one slot at a time.
-			     * This effectively makes the system spin.
-			     *
-			     * Take next_to_clean + 1 as a reference.
-			     * tdh must be ahead or equal
-			     * On entry, the logical order is
-			     *		x < tdh = nic_i
-			     * We first push tdh up to avoid wraps.
-			     * The limit is tdh-ll (half ring).
-			     * if tdh-256 < x we report x;
-			     * else we report tdh-256
-			     */
-			    u_int tdh = nic_i;
-			    u_int ll = csbd[15];
-			    u_int delta = lim/8;
-			    if (netmap_adaptive_io == 2 || ll > delta)
-				csbd[15] = ll = delta;
-			    else if (netmap_adaptive_io == 1 && ll > 1) {
-				csbd[15]--;
-			    }
-
-			    if (nic_i >= kring->nkr_num_slots) {
-				RD(5, "bad nic_i %d on input", nic_i);
-			    }
-			    x = nm_next(x, lim);
-			    if (tdh < x)
-				tdh += lim + 1;
-			    if (tdh <= x + ll) {
-				nic_i = x;
-				csbd[25]++; //report n + 1;
-			    } else {
-				tdh = nic_i;
-				if (tdh < ll)
-				    tdh += lim + 1;
-				nic_i = tdh - ll;
-				csbd[26]++; // report tdh - ll
-			    }
-			}
-#endif
-			} else {
-			    /* we stop, count whether we are idle or not */
-			    int bh_active = csb->host_need_txkick & 2 ? 4 : 0;
-			    csbd[27+ csb->host_need_txkick]++;
-			    if (netmap_adaptive_io == 1) {
-				if (bh_active && csbd[15] > 1)
-				    csbd[15]--;
-				else if (!bh_active && csbd[15] < lim/2)
-				    csbd[15]++;
-			    }
-			    bad--;
-			    fail++;
-			}
-		    }
-		    RD(1, "drain %d nodrain %d good %d retry %d fail %d",
-			drain, nodrain, good, bad, fail);
-		} else
-#endif /* !NIC_PARAVIRT */
-		nic_i = E1000_READ_REG(&adapter->hw, E1000_TDH(0));
-		if (nic_i >= kring->nkr_num_slots) { /* XXX can it happen ? */
-			D("TDH wrap %d", nic_i);
-			nic_i -= kring->nkr_num_slots;
-		}
-		adapter->next_tx_to_clean = nic_i;
-		kring->nr_hwtail = nm_prev(netmap_idx_n2k(kring, nic_i), lim);
-	}
-
-	nm_txsync_finalize(kring);
-
-	return 0;
-}
-
-
-/*
- * Reconcile kernel and user view of the receive ring.
- */
-static int
-lem_netmap_rxsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = nm_rxsync_prologue(kring);
-	int force_update = (flags & NAF_FORCE_READ) || kring->nr_kflags & NKR_PENDINTR;
-
-	/* device-specific */
-	struct adapter *adapter = ifp->if_softc;
-#ifdef NIC_PARAVIRT
-	struct paravirt_csb *csb = adapter->csb;
-	uint32_t csb_mode = csb && csb->guest_csb_on;
-	uint32_t do_host_rxkick = 0;
-#endif /* NIC_PARAVIRT */
-
-	if (head > lim)
-		return netmap_ring_reinit(kring);
-
-#ifdef NIC_PARAVIRT
-	if (csb_mode) {
-		force_update = 1;
-		csb->guest_need_rxkick = 0;
-	}
-#endif /* NIC_PARAVIRT */
-	/* XXX check sync modes */
-	bus_dmamap_sync(adapter->rxdma.dma_tag, adapter->rxdma.dma_map,
-			BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
-
-	/*
-	 * First part: import newly received packets.
-	 */
-	if (netmap_no_pendintr || force_update) {
-		uint16_t slot_flags = kring->nkr_slot_flags;
-
-		nic_i = adapter->next_rx_desc_to_check;
-		nm_i = netmap_idx_n2k(kring, nic_i);
-
-		for (n = 0; ; n++) {
-			struct e1000_rx_desc *curr = &adapter->rx_desc_base[nic_i];
-			uint32_t staterr = le32toh(curr->status);
-			int len;
-
-#ifdef NIC_PARAVIRT
-			if (csb_mode) {
-			    if ((staterr & E1000_RXD_STAT_DD) == 0) {
-				/* don't bother to retry if more than 1 pkt */
-				if (n > 1)
-				    break;
-				csb->guest_need_rxkick = 1;
-				wmb();
-				staterr = le32toh(curr->status);
-				if ((staterr & E1000_RXD_STAT_DD) == 0) {
-				    break;
-				} else { /* we are good */
-				   csb->guest_need_rxkick = 0;
-				}
-			    }
-			} else
-#endif /* NIC_PARAVIRT */
-			if ((staterr & E1000_RXD_STAT_DD) == 0)
-				break;
-			len = le16toh(curr->length) - 4; // CRC
-			if (len < 0) {
-				RD(5, "bogus pkt (%d) size %d nic idx %d", n, len, nic_i);
-				len = 0;
-			}
-			ring->slot[nm_i].len = len;
-			ring->slot[nm_i].flags = slot_flags;
-			bus_dmamap_sync(adapter->rxtag,
-				adapter->rx_buffer_area[nic_i].map,
-				BUS_DMASYNC_POSTREAD);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		if (n) { /* update the state variables */
-#ifdef NIC_PARAVIRT
-			if (csb_mode) {
-			    if (n > 1) {
-				/* leave one spare buffer so we avoid rxkicks */
-				nm_i = nm_prev(nm_i, lim);
-				nic_i = nm_prev(nic_i, lim);
-				n--;
-			    } else {
-				csb->guest_need_rxkick = 1;
-			    }
-			}
-#endif /* NIC_PARAVIRT */
-			ND("%d new packets at nic %d nm %d tail %d",
-				n,
-				adapter->next_rx_desc_to_check,
-				netmap_idx_n2k(kring, adapter->next_rx_desc_to_check),
-				kring->nr_hwtail);
-			adapter->next_rx_desc_to_check = nic_i;
-			// if_inc_counter(ifp, IFCOUNTER_IPACKETS, n);
-			kring->nr_hwtail = nm_i;
-		}
-		kring->nr_kflags &= ~NKR_PENDINTR;
-	}
-
-	/*
-	 * Second part: skip past packets that userspace has released.
-	 */
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			struct e1000_rx_desc *curr = &adapter->rx_desc_base[nic_i];
-			struct em_buffer *rxbuf = &adapter->rx_buffer_area[nic_i];
-
-			if (addr == NETMAP_BUF_BASE(na)) /* bad buf */
-				goto ring_reset;
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				curr->buffer_addr = htole64(paddr);
-				netmap_reload_map(na, adapter->rxtag, rxbuf->map, addr);
-				slot->flags &= ~NS_BUF_CHANGED;
-			}
-			curr->status = 0;
-			bus_dmamap_sync(adapter->rxtag, rxbuf->map,
-			    BUS_DMASYNC_PREREAD);
-#ifdef NIC_PARAVIRT
-			if (csb_mode && csb->host_rxkick_at == nic_i)
-				do_host_rxkick = 1;
-#endif /* NIC_PARAVIRT */
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-		bus_dmamap_sync(adapter->rxdma.dma_tag, adapter->rxdma.dma_map,
-		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-		/*
-		 * IMPORTANT: we must leave one free slot in the ring,
-		 * so move nic_i back by one unit
-		 */
-		nic_i = nm_prev(nic_i, lim);
-#ifdef NIC_PARAVIRT
-		/* set unconditionally, then also kick if needed */
-		if (csb)
-			csb->guest_rdt = nic_i;
-		if (!csb_mode || do_host_rxkick)
-#endif /* NIC_PARAVIRT */
-		E1000_WRITE_REG(&adapter->hw, E1000_RDT(0), nic_i);
-	}
-
-	/* tell userspace that there might be new packets */
-	nm_rxsync_finalize(kring);
-
-	return 0;
-
-ring_reset:
-	return netmap_ring_reinit(kring);
-}
-
-
-static void
-lem_netmap_attach(struct adapter *adapter)
-{
-	struct netmap_adapter na;
-
-	bzero(&na, sizeof(na));
-
-	na.ifp = adapter->ifp;
-	na.na_flags = NAF_BDG_MAYSLEEP;
-	na.num_tx_desc = adapter->num_tx_desc;
-	na.num_rx_desc = adapter->num_rx_desc;
-	na.nm_txsync = lem_netmap_txsync;
-	na.nm_rxsync = lem_netmap_rxsync;
-	na.nm_register = lem_netmap_reg;
-	na.num_tx_rings = na.num_rx_rings = 1;
-	netmap_attach(&na);
-}
-
-/* end of file */
diff --git a/drivers/staging/netmap/sys/dev/netmap/if_nfe_netmap.h b/drivers/staging/netmap/sys/dev/netmap/if_nfe_netmap.h
deleted file mode 100644
index 0b0645d0d8a6..000000000000
--- a/drivers/staging/netmap/sys/dev/netmap/if_nfe_netmap.h
+++ /dev/null
@@ -1,387 +0,0 @@
-/*
- * Copyright (C) 2011-2014 Luigi Rizzo. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * $FreeBSD: head/sys/dev/netmap/if_em_netmap.h 231881 2012-02-17 14:09:04Z luigi $
- *
- * netmap support for: nfe XXX not yet tested.
- *
- * For more details on netmap support please see ixgbe_netmap.h
- */
-
-
-#include <net/netmap.h>
-#include <sys/selinfo.h>
-#include <vm/vm.h>
-#include <vm/pmap.h>
-
-#include <dev/netmap/netmap_kern.h>
-
-
-static int
-nfe_netmap_init_buffers(struct nfe_softc *sc)
-{
-	struct netmap_adapter *na = NA(sc->nfe_ifp);
-	struct netmap_slot *slot;
-	int i, l, n, max_avail;
-	struct nfe_desc32 *desc32 = NULL;
-	struct nfe_desc64 *desc64 = NULL;
-	void *addr;
-	uint64_t paddr;
-
-	slot = netmap_reset(na, NR_TX, 0, 0);
-	if (!slot)
-		return 0; // not in native mode
-	// XXX init the tx ring
-	n = NFE_TX_RING_COUNT;
-	for (i = 0; i < n; i++) {
-		l = netmap_idx_n2k(&na->tx_rings[0], i);
-		addr = PNMB(na, slot + l, &paddr);
-		netmap_reload_map(sc->txq.tx_data_tag,
-		    sc->txq.data[l].tx_data_map, addr);
-		slot[l].flags = 0;
-		if (sc->nfe_flags & NFE_40BIT_ADDR) {
-			desc64 = &sc->txq.desc64[l];
-			desc64->physaddr[0] = htole32(NFE_ADDR_HI(paddr));
-			desc64->physaddr[1] = htole32(NFE_ADDR_LO(paddr));
-			desc64->vtag = 0;
-			desc64->length = htole16(0);
-			desc64->flags = htole16(0);
-		} else {
-			desc32 = &sc->txq.desc32[l];
-			desc32->physaddr = htole32(NFE_ADDR_LO(paddr));
-			desc32->length = htole16(0);
-			desc32->flags = htole16(0);
-		}
-	}
-
-	slot = netmap_reset(na, NR_RX, 0, 0);
-	// XXX init the rx ring
-	/*
-	 * preserve buffers still owned by the driver (and keep one empty).
-	 */
-	n = NFE_RX_RING_COUNT;
-	max_avail = n - 1 - nm_kr_rxspace(&na->rx_rings[0]);
-	for (i = 0; i < n; i++) {
-		uint16_t flags;
-		l = netmap_idx_n2k(&na->rx_rings[0], i);
-		addr = PNMB(na, slot + l, &paddr);
-		flags = (i < max_avail) ? NFE_RX_READY : 0;
-		if (sc->nfe_flags & NFE_40BIT_ADDR) {
-			desc64 = &sc->rxq.desc64[l];
-			desc64->physaddr[0] = htole32(NFE_ADDR_HI(paddr));
-			desc64->physaddr[1] = htole32(NFE_ADDR_LO(paddr));
-			desc64->vtag = 0;
-			desc64->length = htole16(NETMAP_BUF_SIZE);
-			desc64->flags = htole16(NFE_RX_READY);
-		} else {
-			desc32 = &sc->rxq.desc32[l];
-			desc32->physaddr = htole32(NFE_ADDR_LO(paddr));
-			desc32->length = htole16(NETMAP_BUF_SIZE);
-			desc32->flags = htole16(NFE_RX_READY);
-		}
-
-		netmap_reload_map(sc->rxq.rx_data_tag,
-		    sc->rxq.data[l].rx_data_map, addr);
-		bus_dmamap_sync(sc->rxq.rx_data_tag,
-		    sc->rxq.data[l].rx_data_map, BUS_DMASYNC_PREREAD);
-	}
-
-	return 1;
-}
-
-
-/*
- * Register/unregister. We are already under netmap lock.
- */
-static int
-nfe_netmap_reg(struct netmap_adapter *na, int onoff)
-{
-	struct ifnet *ifp = na->ifp;
-	struct nfe_softc *sc = ifp->if_softc;
-
-	NFE_LOCK(sc);
-	nfe_stop(ifp);	/* also clear IFF_DRV_RUNNING */
-	if (onoff) {
-		nm_set_native_flags(na);
-	} else {
-		nm_clear_native_flags(na);
-	}
-	nfe_init_locked(sc);	/* also enable intr */
-	NFE_UNLOCK(sc);
-	return (0);
-}
-
-
-/*
- * Reconcile kernel and user view of the transmit ring.
- */
-static int
-nfe_netmap_txsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = kring->rhead;
-	/* generate an interrupt approximately every half ring */
-	u_int report_frequency = kring->nkr_num_slots >> 1;
-
-	/* device-specific */
-	struct nfe_softc *sc = ifp->if_softc;
-	struct nfe_desc32 *desc32 = NULL;
-	struct nfe_desc64 *desc64 = NULL;
-
-	bus_dmamap_sync(sc->txq.tx_desc_tag, sc->txq.tx_desc_map,
-			BUS_DMASYNC_POSTREAD);
-
-	/*
-	 * First part: process new packets to send.
-	 */
-
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {	/* we have new packets to send */
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			/* slot is the current slot in the netmap ring */
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			u_int len = slot->len;
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			NM_CHECK_ADDR_LEN(addr, len);
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				netmap_reload_map(sc->txq.tx_data_tag,
-				    sc->txq.data[l].tx_data_map, addr);
-			}
-			slot->flags &= ~(NS_REPORT | NS_BUF_CHANGED);
-
-			if (sc->nfe_flags & NFE_40BIT_ADDR) {
-			    desc64 = &sc->txq.desc64[l];
-			    desc64->physaddr[0] = htole32(NFE_ADDR_HI(paddr));
-			    desc64->physaddr[1] = htole32(NFE_ADDR_LO(paddr));
-			    desc64->vtag = 0;
-			    desc64->length = htole16(len - 1);
-			    desc64->flags =
-				htole16(NFE_TX_VALID | NFE_TX_LASTFRAG_V2);
-			} else {
-			    desc32 = &sc->txq.desc32[l];
-			    desc32->physaddr = htole32(NFE_ADDR_LO(paddr));
-			    desc32->length = htole16(len - 1);
-			    desc32->flags =
-				htole16(NFE_TX_VALID | NFE_TX_LASTFRAG_V1);
-			}
-
-			bus_dmamap_sync(sc->txq.tx_data_tag,
-			    sc->txq.data[l].tx_data_map, BUS_DMASYNC_PREWRITE);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-		sc->txq.cur = nic_i;
-
-		bus_dmamap_sync(sc->txq.tx_desc_tag, sc->txq.tx_desc_map,
-			BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-
-		/* XXX something missing ? where is the last pkt marker ? */
-		NFE_WRITE(sc, NFE_RXTX_CTL, NFE_RXTX_KICKTX | sc->rxtxctl);
-	}
-
-	/*
-	 * Second part: reclaim buffers for completed transmissions.
-	 */
-	if (flags & NAF_FORCE_RECLAIM || nm_kr_txempty(kring)) {
-		u_int nic_cur = sc->txq.cur;
-		nic_i = sc->txq.next;
-		for (n = 0; nic_i != nic_cur; n++, NFE_INC(nic_i, NFE_TX_RING_COUNT)) {
-			uint16_t flags;
-			if (sc->nfe_flags & NFE_40BIT_ADDR) {
-				desc64 = &sc->txq.desc64[l];
-				flags = le16toh(desc64->flags);
-			} else {
-				desc32 = &sc->txq.desc32[l];
-				flags = le16toh(desc32->flags);
-			}
-			if (flags & NFE_TX_VALID)
-				break;
-		}
-		if (n > 0) {
-			sc->txq.next = nic_i;
-			kring->nr_hwtail = nm_prev(netmap_idx_n2k(kring, nic_i), lim);
-		}
-	}
-
-	nm_txsync_finalize(kring);
-
-	return 0;
-}
-
-
-/*
- * Reconcile kernel and user view of the receive ring.
- */
-static int
-nfe_netmap_rxsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = nm_rxsync_prologue(kring);
-	int force_update = (flags & NAF_FORCE_READ) || kring->nr_kflags & NKR_PENDINTR;
-
-	/* device-specific */
-	struct nfe_softc *sc = ifp->if_softc;
-	struct nfe_desc32 *desc32;
-	struct nfe_desc64 *desc64;
-
-	if (head > lim)
-		return netmap_ring_reinit(kring);
-
-	bus_dmamap_sync(sc->rxq.rx_desc_tag, sc->rxq.rx_desc_map,
-			BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
-
-	/*
-	 * First part: import newly received packets.
-	 */
-	if (netmap_no_pendintr || force_update) {
-		uint16_t flags, len;
-		uint16_t slot_flags = kring->nkr_slot_flags;
-
-		nic_i = sc->rxq.cur;
-		nm_i = netmap_idx_n2k(kring, nic_i);
-		for (n = 0; ; n++) {
-			if (sc->nfe_flags & NFE_40BIT_ADDR) {
-			    desc64 = &sc->rxq.desc64[sc->rxq.cur];
-			    flags = le16toh(desc64->flags);
-			    len = le16toh(desc64->length) & NFE_RX_LEN_MASK;
-			} else {
-			    desc32 = &sc->rxq.desc32[sc->rxq.cur];
-			    flags = le16toh(desc32->flags);
-			    len = le16toh(desc32->length) & NFE_RX_LEN_MASK;
-			}
-
-			if (flags & NFE_RX_READY)
-				break;
-
-			ring->slot[nm_i].len = len;
-			ring->slot[nm_i].flags = slot_flags;
-			bus_dmamap_sync(sc->rxq.rx_data_tag,
-				sc->rxq.data[nic_i].rx_data_map,
-				BUS_DMASYNC_POSTREAD);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		if (n) { /* update the state variables */
-			sc->rxq.cur = nic_i;
-			kring->nr_hwtail = nm_i;
-		}
-		kring->nr_kflags &= ~NKR_PENDINTR;
-	}
-
-	/*
-	 * Second part: skip past packets that userspace has released.
-	 */
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			if (addr == netmap_buffer_base) /* bad buf */
-				goto ring_reset;
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				netmap_reload_map(sc->rxq.rx_data_tag,
-				    sc->rxq.data[l].rx_data_map, addr);
-				slot->flags &= ~NS_BUF_CHANGED;
-			}
-			if (sc->nfe_flags & NFE_40BIT_ADDR) {
-				desc64 = &sc->rxq.desc64[nic_i];
-				desc64->physaddr[0] =
-				    htole32(NFE_ADDR_HI(paddr));
-				desc64->physaddr[1] =
-				    htole32(NFE_ADDR_LO(paddr));
-				desc64->length = htole16(NETMAP_BUF_SIZE);
-				desc64->flags = htole16(NFE_RX_READY);
-			} else {
-				desc32 = &sc->rxq.desc32[nic_i];
-				desc32->physaddr =
-				    htole32(NFE_ADDR_LO(paddr));
-				desc32->length = htole16(NETMAP_BUF_SIZE);
-				desc32->flags = htole16(NFE_RX_READY);
-			}
-
-			bus_dmamap_sync(sc->rxq.rx_data_tag,
-			    sc->rxq.data[nic_i].rx_data_map,
-			    BUS_DMASYNC_PREREAD);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-		bus_dmamap_sync(sc->rxq.rx_desc_tag, sc->rxq.rx_desc_map,
-		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-	}
-
-	/* tell userspace that there might be new packets */
-	nm_rxsync_finalize(kring);
-
-	return 0;
-
-ring_reset:
-	return netmap_ring_reinit(kring);
-}
-
-
-static void
-nfe_netmap_attach(struct nfe_softc *sc)
-{
-	struct netmap_adapter na;
-
-	bzero(&na, sizeof(na));
-
-	na.ifp = sc->nfe_ifp;
-	na.na_flags = NAF_BDG_MAYSLEEP;
-	na.num_tx_desc = NFE_TX_RING_COUNT;
-	na.num_rx_desc = NFE_RX_RING_COUNT;
-	na.nm_txsync = nfe_netmap_txsync;
-	na.nm_rxsync = nfe_netmap_rxsync;
-	na.nm_register = nfe_netmap_reg;
-	na.num_tx_rings = na.num_rx_rings = 1;
-	netmap_attach(&na, 1);
-}
-
-/* end of file */
diff --git a/drivers/staging/netmap/sys/dev/netmap/if_re_netmap.h b/drivers/staging/netmap/sys/dev/netmap/if_re_netmap.h
deleted file mode 100644
index 035c43f8c95e..000000000000
--- a/drivers/staging/netmap/sys/dev/netmap/if_re_netmap.h
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Copyright (C) 2011-2014 Luigi Rizzo. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * $FreeBSD: head/sys/dev/netmap/if_re_netmap.h 234225 2012-04-13 15:33:12Z luigi $
- *
- * netmap support for: re
- *
- * For more details on netmap support please see ixgbe_netmap.h
- */
-
-
-#include <net/netmap.h>
-#include <sys/selinfo.h>
-#include <vm/vm.h>
-#include <vm/pmap.h>    /* vtophys ? */
-#include <dev/netmap/netmap_kern.h>
-
-
-/*
- * Register/unregister. We are already under netmap lock.
- */
-static int
-re_netmap_reg(struct netmap_adapter *na, int onoff)
-{
-	struct ifnet *ifp = na->ifp;
-	struct rl_softc *adapter = ifp->if_softc;
-
-	RL_LOCK(adapter);
-	re_stop(adapter); /* also clears IFF_DRV_RUNNING */
-	if (onoff) {
-		nm_set_native_flags(na);
-	} else {
-		nm_clear_native_flags(na);
-	}
-	re_init_locked(adapter);	/* also enables intr */
-	RL_UNLOCK(adapter);
-	return (ifp->if_drv_flags & IFF_DRV_RUNNING ? 0 : 1);
-}
-
-
-/*
- * Reconcile kernel and user view of the transmit ring.
- */
-static int
-re_netmap_txsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = kring->rhead;
-
-	/* device-specific */
-	struct rl_softc *sc = ifp->if_softc;
-	struct rl_txdesc *txd = sc->rl_ldata.rl_tx_desc;
-
-	bus_dmamap_sync(sc->rl_ldata.rl_tx_list_tag,
-	    sc->rl_ldata.rl_tx_list_map,
-	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE); // XXX extra postwrite ?
-
-	/*
-	 * First part: process new packets to send.
-	 */
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {	/* we have new packets to send */
-		nic_i = sc->rl_ldata.rl_tx_prodidx;
-		// XXX or netmap_idx_k2n(kring, nm_i);
-
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			u_int len = slot->len;
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			/* device-specific */
-			struct rl_desc *desc = &sc->rl_ldata.rl_tx_list[nic_i];
-			int cmd = slot->len | RL_TDESC_CMD_EOF |
-				RL_TDESC_CMD_OWN | RL_TDESC_CMD_SOF ;
-
-			NM_CHECK_ADDR_LEN(na, addr, len);
-
-			if (nic_i == lim)	/* mark end of ring */
-				cmd |= RL_TDESC_CMD_EOR;
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				desc->rl_bufaddr_lo = htole32(RL_ADDR_LO(paddr));
-				desc->rl_bufaddr_hi = htole32(RL_ADDR_HI(paddr));
-				netmap_reload_map(na, sc->rl_ldata.rl_tx_mtag,
-					txd[nic_i].tx_dmamap, addr);
-			}
-			slot->flags &= ~(NS_REPORT | NS_BUF_CHANGED);
-
-			/* Fill the slot in the NIC ring. */
-			desc->rl_cmdstat = htole32(cmd);
-
-			/* make sure changes to the buffer are synced */
-			bus_dmamap_sync(sc->rl_ldata.rl_tx_mtag,
-				txd[nic_i].tx_dmamap,
-				BUS_DMASYNC_PREWRITE);
-
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		sc->rl_ldata.rl_tx_prodidx = nic_i;
-		kring->nr_hwcur = head;
-
-		/* synchronize the NIC ring */
-		bus_dmamap_sync(sc->rl_ldata.rl_tx_list_tag,
-			sc->rl_ldata.rl_tx_list_map,
-			BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
-
-		/* start ? */
-		CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START);
-	}
-
-	/*
-	 * Second part: reclaim buffers for completed transmissions.
-	 */
-	if (flags & NAF_FORCE_RECLAIM || nm_kr_txempty(kring)) {
-		nic_i = sc->rl_ldata.rl_tx_considx;
-		for (n = 0; nic_i != sc->rl_ldata.rl_tx_prodidx;
-		    n++, nic_i = RL_TX_DESC_NXT(sc, nic_i)) {
-			uint32_t cmdstat =
-				le32toh(sc->rl_ldata.rl_tx_list[nic_i].rl_cmdstat);
-			if (cmdstat & RL_TDESC_STAT_OWN)
-				break;
-		}
-		if (n > 0) {
-			sc->rl_ldata.rl_tx_considx = nic_i;
-			sc->rl_ldata.rl_tx_free += n;
-			kring->nr_hwtail = nm_prev(netmap_idx_n2k(kring, nic_i), lim);
-		}
-	}
-
-	nm_txsync_finalize(kring);
-
-	return 0;
-}
-
-
-/*
- * Reconcile kernel and user view of the receive ring.
- */
-static int
-re_netmap_rxsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = nm_rxsync_prologue(kring);
-	int force_update = (flags & NAF_FORCE_READ) || kring->nr_kflags & NKR_PENDINTR;
-
-	/* device-specific */
-	struct rl_softc *sc = ifp->if_softc;
-	struct rl_rxdesc *rxd = sc->rl_ldata.rl_rx_desc;
-
-	if (head > lim)
-		return netmap_ring_reinit(kring);
-
-	bus_dmamap_sync(sc->rl_ldata.rl_rx_list_tag,
-			sc->rl_ldata.rl_rx_list_map,
-			BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
-
-	/*
-	 * First part: import newly received packets.
-	 *
-	 * This device uses all the buffers in the ring, so we need
-	 * another termination condition in addition to RL_RDESC_STAT_OWN
-	 * cleared (all buffers could have it cleared). The easiest one
-	 * is to stop right before nm_hwcur.
-	 */
-	if (netmap_no_pendintr || force_update) {
-		uint16_t slot_flags = kring->nkr_slot_flags;
-		uint32_t stop_i = nm_prev(kring->nr_hwcur, lim);
-
-		nic_i = sc->rl_ldata.rl_rx_prodidx; /* next pkt to check */
-		nm_i = netmap_idx_n2k(kring, nic_i);
-
-		while (nm_i != stop_i) {
-			struct rl_desc *cur_rx = &sc->rl_ldata.rl_rx_list[nic_i];
-			uint32_t rxstat = le32toh(cur_rx->rl_cmdstat);
-			uint32_t total_len;
-
-			if ((rxstat & RL_RDESC_STAT_OWN) != 0)
-				break;
-			total_len = rxstat & sc->rl_rxlenmask;
-			/* XXX subtract crc */
-			total_len = (total_len < 4) ? 0 : total_len - 4;
-			ring->slot[nm_i].len = total_len;
-			ring->slot[nm_i].flags = slot_flags;
-			/*  sync was in re_newbuf() */
-			bus_dmamap_sync(sc->rl_ldata.rl_rx_mtag,
-			    rxd[nic_i].rx_dmamap, BUS_DMASYNC_POSTREAD);
-			// if_inc_counter(sc->rl_ifp, IFCOUNTER_IPACKETS, 1);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		sc->rl_ldata.rl_rx_prodidx = nic_i;
-		kring->nr_hwtail = nm_i;
-		kring->nr_kflags &= ~NKR_PENDINTR;
-	}
-
-	/*
-	 * Second part: skip past packets that userspace has released.
-	 */
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			struct rl_desc *desc = &sc->rl_ldata.rl_rx_list[nic_i];
-			int cmd = NETMAP_BUF_SIZE(na) | RL_RDESC_CMD_OWN;
-
-			if (addr == NETMAP_BUF_BASE(na)) /* bad buf */
-				goto ring_reset;
-
-			if (nic_i == lim)	/* mark end of ring */
-				cmd |= RL_RDESC_CMD_EOR;
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				desc->rl_bufaddr_lo = htole32(RL_ADDR_LO(paddr));
-				desc->rl_bufaddr_hi = htole32(RL_ADDR_HI(paddr));
-				netmap_reload_map(na, sc->rl_ldata.rl_rx_mtag,
-					rxd[nic_i].rx_dmamap, addr);
-				slot->flags &= ~NS_BUF_CHANGED;
-			}
-			desc->rl_cmdstat = htole32(cmd);
-			bus_dmamap_sync(sc->rl_ldata.rl_rx_mtag,
-			    rxd[nic_i].rx_dmamap,
-			    BUS_DMASYNC_PREREAD);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-
-		bus_dmamap_sync(sc->rl_ldata.rl_rx_list_tag,
-		    sc->rl_ldata.rl_rx_list_map,
-		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-	}
-
-	/* tell userspace that there might be new packets */
-	nm_rxsync_finalize(kring);
-
-	return 0;
-
-ring_reset:
-	return netmap_ring_reinit(kring);
-}
-
-
-/*
- * Additional routines to init the tx and rx rings.
- * In other drivers we do that inline in the main code.
- */
-static void
-re_netmap_tx_init(struct rl_softc *sc)
-{
-	struct rl_txdesc *txd;
-	struct rl_desc *desc;
-	int i, n;
-	struct netmap_adapter *na = NA(sc->rl_ifp);
-	struct netmap_slot *slot;
-
-	slot = netmap_reset(na, NR_TX, 0, 0);
-	/* slot is NULL if we are not in native netmap mode */
-	if (!slot)
-		return;
-	/* in netmap mode, overwrite addresses and maps */
-	txd = sc->rl_ldata.rl_tx_desc;
-	desc = sc->rl_ldata.rl_tx_list;
-	n = sc->rl_ldata.rl_tx_desc_cnt;
-
-	/* l points in the netmap ring, i points in the NIC ring */
-	for (i = 0; i < n; i++) {
-		uint64_t paddr;
-		int l = netmap_idx_n2k(&na->tx_rings[0], i);
-		void *addr = PNMB(na, slot + l, &paddr);
-
-		desc[i].rl_bufaddr_lo = htole32(RL_ADDR_LO(paddr));
-		desc[i].rl_bufaddr_hi = htole32(RL_ADDR_HI(paddr));
-		netmap_load_map(na, sc->rl_ldata.rl_tx_mtag,
-			txd[i].tx_dmamap, addr);
-	}
-}
-
-static void
-re_netmap_rx_init(struct rl_softc *sc)
-{
-	struct netmap_adapter *na = NA(sc->rl_ifp);
-	struct netmap_slot *slot = netmap_reset(na, NR_RX, 0, 0);
-	struct rl_desc *desc = sc->rl_ldata.rl_rx_list;
-	uint32_t cmdstat;
-	uint32_t nic_i, max_avail;
-	uint32_t const n = sc->rl_ldata.rl_rx_desc_cnt;
-
-	if (!slot)
-		return;
-	/*
-	 * Do not release the slots owned by userspace,
-	 * and also keep one empty.
-	 */
-	max_avail = n - 1 - nm_kr_rxspace(&na->rx_rings[0]);
-	for (nic_i = 0; nic_i < n; nic_i++) {
-		void *addr;
-		uint64_t paddr;
-		uint32_t nm_i = netmap_idx_n2k(&na->rx_rings[0], nic_i);
-
-		addr = PNMB(na, slot + nm_i, &paddr);
-
-		netmap_reload_map(na, sc->rl_ldata.rl_rx_mtag,
-		    sc->rl_ldata.rl_rx_desc[nic_i].rx_dmamap, addr);
-		bus_dmamap_sync(sc->rl_ldata.rl_rx_mtag,
-		    sc->rl_ldata.rl_rx_desc[nic_i].rx_dmamap, BUS_DMASYNC_PREREAD);
-		desc[nic_i].rl_bufaddr_lo = htole32(RL_ADDR_LO(paddr));
-		desc[nic_i].rl_bufaddr_hi = htole32(RL_ADDR_HI(paddr));
-		cmdstat = NETMAP_BUF_SIZE(na);
-		if (nic_i == n - 1) /* mark the end of ring */
-			cmdstat |= RL_RDESC_CMD_EOR;
-		if (nic_i < max_avail)
-			cmdstat |= RL_RDESC_CMD_OWN;
-		desc[nic_i].rl_cmdstat = htole32(cmdstat);
-	}
-}
-
-
-static void
-re_netmap_attach(struct rl_softc *sc)
-{
-	struct netmap_adapter na;
-
-	bzero(&na, sizeof(na));
-
-	na.ifp = sc->rl_ifp;
-	na.na_flags = NAF_BDG_MAYSLEEP;
-	na.num_tx_desc = sc->rl_ldata.rl_tx_desc_cnt;
-	na.num_rx_desc = sc->rl_ldata.rl_rx_desc_cnt;
-	na.nm_txsync = re_netmap_txsync;
-	na.nm_rxsync = re_netmap_rxsync;
-	na.nm_register = re_netmap_reg;
-	na.num_tx_rings = na.num_rx_rings = 1;
-	netmap_attach(&na);
-}
-
-/* end of file */
diff --git a/drivers/staging/netmap/sys/dev/netmap/if_vtnet_netmap.h b/drivers/staging/netmap/sys/dev/netmap/if_vtnet_netmap.h
deleted file mode 100644
index ff1615f591ca..000000000000
--- a/drivers/staging/netmap/sys/dev/netmap/if_vtnet_netmap.h
+++ /dev/null
@@ -1,434 +0,0 @@
-/*
- * Copyright (C) 2014 Vincenzo Maffione, Luigi Rizzo. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * $FreeBSD: head/sys/dev/netmap/if_vtnet_netmap.h 270097 2014-08-17 10:25:27Z luigi $
- */
-
-#include <net/netmap.h>
-#include <sys/selinfo.h>
-#include <vm/vm.h>
-#include <vm/pmap.h>    /* vtophys ? */
-#include <dev/netmap/netmap_kern.h>
-
-
-#define SOFTC_T	vtnet_softc
-
-/* Free all the unused buffer in all the RX virtqueues.
- * This function is called when entering and exiting netmap mode.
- * - buffers queued by the virtio driver return skbuf/mbuf pointer
- *   and need to be freed;
- * - buffers queued by netmap return the txq/rxq, and do not need work
- */
-static void
-vtnet_netmap_free_bufs(struct SOFTC_T* sc)
-{
-	int i, nmb = 0, n = 0, last;
-
-	for (i = 0; i < sc->vtnet_max_vq_pairs; i++) {
-		struct vtnet_rxq *rxq = &sc->vtnet_rxqs[i];
-		struct virtqueue *vq;
-		struct mbuf *m;
-		struct vtnet_txq *txq = &sc->vtnet_txqs[i];
-                struct vtnet_tx_header *txhdr;
-
-		last = 0;
-		vq = rxq->vtnrx_vq;
-		while ((m = virtqueue_drain(vq, &last)) != NULL) {
-			n++;
-			if (m != (void *)rxq)
-				m_freem(m);
-			else
-				nmb++;
-		}
-
-		last = 0;
-		vq = txq->vtntx_vq;
-		while ((txhdr = virtqueue_drain(vq, &last)) != NULL) {
-			n++;
-			if (txhdr != (void *)txq) {
-				m_freem(txhdr->vth_mbuf);
-				uma_zfree(vtnet_tx_header_zone, txhdr);
-			} else
-				nmb++;
-		}
-	}
-	D("freed %d mbufs, %d netmap bufs on %d queues",
-		n - nmb, nmb, i);
-}
-
-/* Register and unregister. */
-static int
-vtnet_netmap_reg(struct netmap_adapter *na, int onoff)
-{
-        struct ifnet *ifp = na->ifp;
-	struct SOFTC_T *sc = ifp->if_softc;
-
-	VTNET_CORE_LOCK(sc);
-	ifp->if_drv_flags &= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
-	/* enable or disable flags and callbacks in na and ifp */
-	if (onoff) {
-		nm_set_native_flags(na);
-	} else {
-		nm_clear_native_flags(na);
-	}
-	/* drain queues so netmap and native drivers
-	 * do not interfere with each other
-	 */
-	vtnet_netmap_free_bufs(sc);
-        vtnet_init_locked(sc);       /* also enable intr */
-        VTNET_CORE_UNLOCK(sc);
-        return (ifp->if_drv_flags & IFF_DRV_RUNNING ? 0 : 1);
-}
-
-
-/* Reconcile kernel and user view of the transmit ring. */
-static int
-vtnet_netmap_txsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-        struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int ring_nr = kring->ring_id;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = kring->rhead;
-
-	/* device-specific */
-	struct SOFTC_T *sc = ifp->if_softc;
-	struct vtnet_txq *txq = &sc->vtnet_txqs[ring_nr];
-	struct virtqueue *vq = txq->vtntx_vq;
-
-	/*
-	 * First part: process new packets to send.
-	 */
-	rmb();
-	
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {	/* we have new packets to send */
-		struct sglist *sg = txq->vtntx_sg;
-
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			/* we use an empty header here */
-			static struct virtio_net_hdr_mrg_rxbuf hdr;
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			u_int len = slot->len;
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-                        int err;
-
-			NM_CHECK_ADDR_LEN(na, addr, len);
-
-			slot->flags &= ~(NS_REPORT | NS_BUF_CHANGED);
-			/* Initialize the scatterlist, expose it to the hypervisor,
-			 * and kick the hypervisor (if necessary).
-			 */
-			sglist_reset(sg); // cheap
-			// if vtnet_hdr_size > 0 ...
-			err = sglist_append(sg, &hdr, sc->vtnet_hdr_size);
-			// XXX later, support multi segment
-			err = sglist_append_phys(sg, paddr, len);
-			/* use na as the cookie */
-                        err = virtqueue_enqueue(vq, txq, sg, sg->sg_nseg, 0);
-                        if (unlikely(err < 0)) {
-                                D("virtqueue_enqueue failed");
-                                break;
-                        }
-
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		/* Update hwcur depending on where we stopped. */
-		kring->nr_hwcur = nm_i; /* note we migth break early */
-
-		/* No more free TX slots? Ask the hypervisor for notifications,
-		 * possibly only when a considerable amount of work has been
-		 * done.
-		 */
-		ND(3,"sent %d packets, hwcur %d", n, nm_i);
-		virtqueue_disable_intr(vq);
-		virtqueue_notify(vq);
-	} else {
-		if (ring->head != ring->tail)
-		    ND(5, "pure notify ? head %d tail %d nused %d %d",
-			ring->head, ring->tail, virtqueue_nused(vq),
-			(virtqueue_dump(vq), 1));
-		virtqueue_notify(vq);
-		virtqueue_enable_intr(vq); // like postpone with 0
-	}
-
-	
-        /* Free used slots. We only consider our own used buffers, recognized
-	 * by the token we passed to virtqueue_add_outbuf.
-	 */
-        n = 0;
-        for (;;) {
-                struct vtnet_tx_header *txhdr = virtqueue_dequeue(vq, NULL);
-                if (txhdr == NULL)
-                        break;
-                if (likely(txhdr == (void *)txq)) {
-                        n++;
-			if (virtqueue_nused(vq) < 32) { // XXX slow release
-				break;
-			}
-		} else { /* leftover from previous transmission */
-			m_freem(txhdr->vth_mbuf);
-			uma_zfree(vtnet_tx_header_zone, txhdr);
-		}
-        }
-	if (n) {
-		kring->nr_hwtail += n;
-		if (kring->nr_hwtail > lim)
-			kring->nr_hwtail -= lim + 1;
-	}
-	if (nm_i != kring->nr_hwtail /* && vtnet_txq_below_threshold(txq) == 0*/) {
-		ND(3, "disable intr, hwcur %d", nm_i);
-		virtqueue_disable_intr(vq);
-	} else {
-		ND(3, "enable intr, hwcur %d", nm_i);
-		virtqueue_postpone_intr(vq, VQ_POSTPONE_SHORT);
-	}
-
-//out:
-	nm_txsync_finalize(kring);
-
-        return 0;
-}
-
-static int
-vtnet_refill_rxq(struct netmap_kring *kring, u_int nm_i, u_int head)
-{
-	struct netmap_adapter *na = kring->na;
-        struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int ring_nr = kring->ring_id;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int n;
-
-	/* device-specific */
-	struct SOFTC_T *sc = ifp->if_softc;
-	struct vtnet_rxq *rxq = &sc->vtnet_rxqs[ring_nr];
-	struct virtqueue *vq = rxq->vtnrx_vq;
-
-	/* use a local sglist, default might be short */
-	struct sglist_seg ss[2];
-	struct sglist sg = { ss, 0, 0, 2 };
-
-	for (n = 0; nm_i != head; n++) {
-		static struct virtio_net_hdr_mrg_rxbuf hdr;
-		struct netmap_slot *slot = &ring->slot[nm_i];
-		uint64_t paddr;
-		void *addr = PNMB(na, slot, &paddr);
-		int err = 0;
-
-		if (addr == NETMAP_BUF_BASE(na)) { /* bad buf */
-			if (netmap_ring_reinit(kring))
-				return -1;
-		}
-
-		slot->flags &= ~NS_BUF_CHANGED;
-		sglist_reset(&sg); // cheap
-		err = sglist_append(&sg, &hdr, sc->vtnet_hdr_size);
-		err = sglist_append_phys(&sg, paddr, NETMAP_BUF_SIZE(na));
-		/* writable for the host */
-		err = virtqueue_enqueue(vq, rxq, &sg, 0, sg.sg_nseg);
-		if (err < 0) {
-			D("virtqueue_enqueue failed");
-			break;
-		}
-		nm_i = nm_next(nm_i, lim);
-	}
-	return nm_i;
-}
-
-/* Reconcile kernel and user view of the receive ring. */
-static int
-vtnet_netmap_rxsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-        struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int ring_nr = kring->ring_id;
-	u_int nm_i;	/* index into the netmap ring */
-	// u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = nm_rxsync_prologue(kring);
-	int force_update = (flags & NAF_FORCE_READ) || kring->nr_kflags & NKR_PENDINTR;
-
-	/* device-specific */
-	struct SOFTC_T *sc = ifp->if_softc;
-	struct vtnet_rxq *rxq = &sc->vtnet_rxqs[ring_nr];
-	struct virtqueue *vq = rxq->vtnrx_vq;
-
-	/* XXX netif_carrier_ok ? */
-
-	if (head > lim)
-		return netmap_ring_reinit(kring);
-
-	rmb();
-	/*
-	 * First part: import newly received packets.
-	 * Only accept our
-	 * own buffers (matching the token). We should only get
-	 * matching buffers, because of vtnet_netmap_free_rx_unused_bufs()
-	 * and vtnet_netmap_init_buffers().
-	 */
-	if (netmap_no_pendintr || force_update) {
-		uint16_t slot_flags = kring->nkr_slot_flags;
-                struct netmap_adapter *token;
-
-                nm_i = kring->nr_hwtail;
-                n = 0;
-		for (;;) {
-			int len;
-                        token = virtqueue_dequeue(vq, &len);
-                        if (token == NULL)
-                                break;
-                        if (likely(token == (void *)rxq)) {
-                            ring->slot[nm_i].len = len;
-                            ring->slot[nm_i].flags = slot_flags;
-                            nm_i = nm_next(nm_i, lim);
-                            n++;
-                        } else {
-			    D("This should not happen");
-                        }
-		}
-		kring->nr_hwtail = nm_i;
-		kring->nr_kflags &= ~NKR_PENDINTR;
-	}
-        ND("[B] h %d c %d hwcur %d hwtail %d",
-		ring->head, ring->cur, kring->nr_hwcur,
-			      kring->nr_hwtail);
-
-	/*
-	 * Second part: skip past packets that userspace has released.
-	 */
-	nm_i = kring->nr_hwcur; /* netmap ring index */
-	if (nm_i != head) {
-		int err = vtnet_refill_rxq(kring, nm_i, head);
-		if (err < 0)
-			return 1;
-		kring->nr_hwcur = err;
-		virtqueue_notify(vq);
-		/* After draining the queue may need an intr from the hypervisor */
-        	vtnet_rxq_enable_intr(rxq);
-	}
-
-	/* tell userspace that there might be new packets. */
-	nm_rxsync_finalize(kring);
-
-        ND("[C] h %d c %d t %d hwcur %d hwtail %d",
-		ring->head, ring->cur, ring->tail,
-		kring->nr_hwcur, kring->nr_hwtail);
-
-	return 0;
-}
-
-
-/* Make RX virtqueues buffers pointing to netmap buffers. */
-static int
-vtnet_netmap_init_rx_buffers(struct SOFTC_T *sc)
-{
-	struct ifnet *ifp = sc->vtnet_ifp;
-	struct netmap_adapter* na = NA(ifp);
-	unsigned int r;
-
-	if (!nm_native_on(na))
-		return 0;
-	for (r = 0; r < na->num_rx_rings; r++) {
-                struct netmap_kring *kring = &na->rx_rings[r];
-		struct vtnet_rxq *rxq = &sc->vtnet_rxqs[r];
-		struct virtqueue *vq = rxq->vtnrx_vq;
-	        struct netmap_slot* slot;
-		int err = 0;
-
-		slot = netmap_reset(na, NR_RX, r, 0);
-		if (!slot) {
-			D("strange, null netmap ring %d", r);
-			return 0;
-		}
-		/* Add up to na>-num_rx_desc-1 buffers to this RX virtqueue.
-		 * It's important to leave one virtqueue slot free, otherwise
-		 * we can run into ring->cur/ring->tail wraparounds.
-		 */
-		err = vtnet_refill_rxq(kring, 0, na->num_rx_desc-1);
-		if (err < 0)
-			return 0;
-		virtqueue_notify(vq);
-	}
-
-	return 1;
-}
-
-/* Update the virtio-net device configurations. Number of queues can
- * change dinamically, by 'ethtool --set-channels $IFNAME combined $N'.
- * This is actually the only way virtio-net can currently enable
- * the multiqueue mode.
- * XXX note that we seem to lose packets if the netmap ring has more
- * slots than the queue
- */
-static int
-vtnet_netmap_config(struct netmap_adapter *na, u_int *txr, u_int *txd,
-						u_int *rxr, u_int *rxd)
-{
-	struct ifnet *ifp = na->ifp;
-	struct SOFTC_T *sc = ifp->if_softc;
-
-	*txr = *rxr = sc->vtnet_max_vq_pairs;
-	*rxd = 512; // sc->vtnet_rx_nmbufs;
-	*txd = *rxd; // XXX
-        D("vtnet config txq=%d, txd=%d rxq=%d, rxd=%d",
-					*txr, *txd, *rxr, *rxd);
-
-	return 0;
-}
-
-static void
-vtnet_netmap_attach(struct SOFTC_T *sc)
-{
-	struct netmap_adapter na;
-
-	bzero(&na, sizeof(na));
-
-	na.ifp = sc->vtnet_ifp;
-	na.num_tx_desc =  1024;// sc->vtnet_rx_nmbufs;
-	na.num_rx_desc =  1024; // sc->vtnet_rx_nmbufs;
-	na.nm_register = vtnet_netmap_reg;
-	na.nm_txsync = vtnet_netmap_txsync;
-	na.nm_rxsync = vtnet_netmap_rxsync;
-	na.nm_config = vtnet_netmap_config;
-	na.num_tx_rings = na.num_rx_rings = sc->vtnet_max_vq_pairs;
-	D("max rings %d", sc->vtnet_max_vq_pairs);
-	netmap_attach(&na);
-
-        D("virtio attached txq=%d, txd=%d rxq=%d, rxd=%d",
-			na.num_tx_rings, na.num_tx_desc,
-			na.num_tx_rings, na.num_rx_desc);
-}
-/* end of file */
diff --git a/drivers/staging/netmap/sys/dev/netmap/ixgbe_netmap.h b/drivers/staging/netmap/sys/dev/netmap/ixgbe_netmap.h
deleted file mode 100644
index 361f95020b49..000000000000
--- a/drivers/staging/netmap/sys/dev/netmap/ixgbe_netmap.h
+++ /dev/null
@@ -1,495 +0,0 @@
-/*
- * Copyright (C) 2011-2014 Matteo Landi, Luigi Rizzo. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/*
- * $FreeBSD: head/sys/dev/netmap/ixgbe_netmap.h 244514 2012-12-20 22:26:03Z luigi $
- *
- * netmap support for: ixgbe
- *
- * This file is meant to be a reference on how to implement
- * netmap support for a network driver.
- * This file contains code but only static or inline functions used
- * by a single driver. To avoid replication of code we just #include
- * it near the beginning of the standard driver.
- */
-
-
-#include <net/netmap.h>
-#include <sys/selinfo.h>
-/*
- * Some drivers may need the following headers. Others
- * already include them by default
-
-#include <vm/vm.h>
-#include <vm/pmap.h>
-
- */
-#include <dev/netmap/netmap_kern.h>
-
-
-/*
- * device-specific sysctl variables:
- *
- * ix_crcstrip: 0: keep CRC in rx frames (default), 1: strip it.
- *	During regular operations the CRC is stripped, but on some
- *	hardware reception of frames not multiple of 64 is slower,
- *	so using crcstrip=0 helps in benchmarks.
- *
- * ix_rx_miss, ix_rx_miss_bufs:
- *	count packets that might be missed due to lost interrupts.
- */
-SYSCTL_DECL(_dev_netmap);
-static int ix_rx_miss, ix_rx_miss_bufs, ix_crcstrip;
-SYSCTL_INT(_dev_netmap, OID_AUTO, ix_crcstrip,
-    CTLFLAG_RW, &ix_crcstrip, 0, "strip CRC on rx frames");
-SYSCTL_INT(_dev_netmap, OID_AUTO, ix_rx_miss,
-    CTLFLAG_RW, &ix_rx_miss, 0, "potentially missed rx intr");
-SYSCTL_INT(_dev_netmap, OID_AUTO, ix_rx_miss_bufs,
-    CTLFLAG_RW, &ix_rx_miss_bufs, 0, "potentially missed rx intr bufs");
-
-
-static void
-set_crcstrip(struct ixgbe_hw *hw, int onoff)
-{
-	/* crc stripping is set in two places:
-	 * IXGBE_HLREG0 (modified on init_locked and hw reset)
-	 * IXGBE_RDRXCTL (set by the original driver in
-	 *	ixgbe_setup_hw_rsc() called in init_locked.
-	 *	We disable the setting when netmap is compiled in).
-	 * We update the values here, but also in ixgbe.c because
-	 * init_locked sometimes is called outside our control.
-	 */
-	uint32_t hl, rxc;
-
-	hl = IXGBE_READ_REG(hw, IXGBE_HLREG0);
-	rxc = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);
-	if (netmap_verbose)
-		D("%s read  HLREG 0x%x rxc 0x%x",
-			onoff ? "enter" : "exit", hl, rxc);
-	/* hw requirements ... */
-	rxc &= ~IXGBE_RDRXCTL_RSCFRSTSIZE;
-	rxc |= IXGBE_RDRXCTL_RSCACKC;
-	if (onoff && !ix_crcstrip) {
-		/* keep the crc. Fast rx */
-		hl &= ~IXGBE_HLREG0_RXCRCSTRP;
-		rxc &= ~IXGBE_RDRXCTL_CRCSTRIP;
-	} else {
-		/* reset default mode */
-		hl |= IXGBE_HLREG0_RXCRCSTRP;
-		rxc |= IXGBE_RDRXCTL_CRCSTRIP;
-	}
-	if (netmap_verbose)
-		D("%s write HLREG 0x%x rxc 0x%x",
-			onoff ? "enter" : "exit", hl, rxc);
-	IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hl);
-	IXGBE_WRITE_REG(hw, IXGBE_RDRXCTL, rxc);
-}
-
-
-/*
- * Register/unregister. We are already under netmap lock.
- * Only called on the first register or the last unregister.
- */
-static int
-ixgbe_netmap_reg(struct netmap_adapter *na, int onoff)
-{
-	struct ifnet *ifp = na->ifp;
-	struct adapter *adapter = ifp->if_softc;
-
-	IXGBE_CORE_LOCK(adapter);
-	ixgbe_disable_intr(adapter); // XXX maybe ixgbe_stop ?
-
-	/* Tell the stack that the interface is no longer active */
-	ifp->if_drv_flags &= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
-
-	set_crcstrip(&adapter->hw, onoff);
-	/* enable or disable flags and callbacks in na and ifp */
-	if (onoff) {
-		nm_set_native_flags(na);
-	} else {
-		nm_clear_native_flags(na);
-	}
-	ixgbe_init_locked(adapter);	/* also enables intr */
-	set_crcstrip(&adapter->hw, onoff); // XXX why twice ?
-	IXGBE_CORE_UNLOCK(adapter);
-	return (ifp->if_drv_flags & IFF_DRV_RUNNING ? 0 : 1);
-}
-
-
-/*
- * Reconcile kernel and user view of the transmit ring.
- *
- * All information is in the kring.
- * Userspace wants to send packets up to the one before kring->rhead,
- * kernel knows kring->nr_hwcur is the first unsent packet.
- *
- * Here we push packets out (as many as possible), and possibly
- * reclaim buffers from previously completed transmission.
- *
- * The caller (netmap) guarantees that there is only one instance
- * running at any time. Any interference with other driver
- * methods should be handled by the individual drivers.
- */
-static int
-ixgbe_netmap_txsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = kring->rhead;
-	/*
-	 * interrupts on every tx packet are expensive so request
-	 * them every half ring, or where NS_REPORT is set
-	 */
-	u_int report_frequency = kring->nkr_num_slots >> 1;
-
-	/* device-specific */
-	struct adapter *adapter = ifp->if_softc;
-	struct tx_ring *txr = &adapter->tx_rings[kring->ring_id];
-	int reclaim_tx;
-
-	bus_dmamap_sync(txr->txdma.dma_tag, txr->txdma.dma_map,
-			BUS_DMASYNC_POSTREAD);
-
-	/*
-	 * First part: process new packets to send.
-	 * nm_i is the current index in the netmap ring,
-	 * nic_i is the corresponding index in the NIC ring.
-	 * The two numbers differ because upon a *_init() we reset
-	 * the NIC ring but leave the netmap ring unchanged.
-	 * For the transmit ring, we have
-	 *
-	 *		nm_i = kring->nr_hwcur
-	 *		nic_i = IXGBE_TDT (not tracked in the driver)
-	 * and
-	 * 		nm_i == (nic_i + kring->nkr_hwofs) % ring_size
-	 *
-	 * In this driver kring->nkr_hwofs >= 0, but for other
-	 * drivers it might be negative as well.
-	 */
-
-	/*
-	 * If we have packets to send (kring->nr_hwcur != kring->rhead)
-	 * iterate over the netmap ring, fetch length and update
-	 * the corresponding slot in the NIC ring. Some drivers also
-	 * need to update the buffer's physical address in the NIC slot
-	 * even NS_BUF_CHANGED is not set (PNMB computes the addresses).
-	 *
-	 * The netmap_reload_map() calls is especially expensive,
-	 * even when (as in this case) the tag is 0, so do only
-	 * when the buffer has actually changed.
-	 *
-	 * If possible do not set the report/intr bit on all slots,
-	 * but only a few times per ring or when NS_REPORT is set.
-	 *
-	 * Finally, on 10G and faster drivers, it might be useful
-	 * to prefetch the next slot and txr entry.
-	 */
-
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {	/* we have new packets to send */
-		nic_i = netmap_idx_k2n(kring, nm_i);
-
-		__builtin_prefetch(&ring->slot[nm_i]);
-		__builtin_prefetch(&txr->tx_buffers[nic_i]);
-
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			u_int len = slot->len;
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			/* device-specific */
-			union ixgbe_adv_tx_desc *curr = &txr->tx_base[nic_i];
-			struct ixgbe_tx_buf *txbuf = &txr->tx_buffers[nic_i];
-			int flags = (slot->flags & NS_REPORT ||
-				nic_i == 0 || nic_i == report_frequency) ?
-				IXGBE_TXD_CMD_RS : 0;
-
-			/* prefetch for next round */
-			__builtin_prefetch(&ring->slot[nm_i + 1]);
-			__builtin_prefetch(&txr->tx_buffers[nic_i + 1]);
-
-			NM_CHECK_ADDR_LEN(na, addr, len);
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				netmap_reload_map(na, txr->txtag, txbuf->map, addr);
-			}
-			slot->flags &= ~(NS_REPORT | NS_BUF_CHANGED);
-
-			/* Fill the slot in the NIC ring. */
-			/* Use legacy descriptor, they are faster? */
-			curr->read.buffer_addr = htole64(paddr);
-			curr->read.olinfo_status = 0;
-			curr->read.cmd_type_len = htole32(len | flags |
-				IXGBE_ADVTXD_DCMD_IFCS | IXGBE_TXD_CMD_EOP);
-
-			/* make sure changes to the buffer are synced */
-			bus_dmamap_sync(txr->txtag, txbuf->map,
-				BUS_DMASYNC_PREWRITE);
-
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-
-		/* synchronize the NIC ring */
-		bus_dmamap_sync(txr->txdma.dma_tag, txr->txdma.dma_map,
-			BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-
-		/* (re)start the tx unit up to slot nic_i (excluded) */
-		IXGBE_WRITE_REG(&adapter->hw, IXGBE_TDT(txr->me), nic_i);
-	}
-
-	/*
-	 * Second part: reclaim buffers for completed transmissions.
-	 * Because this is expensive (we read a NIC register etc.)
-	 * we only do it in specific cases (see below).
-	 */
-	if (flags & NAF_FORCE_RECLAIM) {
-		reclaim_tx = 1; /* forced reclaim */
-	} else if (!nm_kr_txempty(kring)) {
-		reclaim_tx = 0; /* have buffers, no reclaim */
-	} else {
-		/*
-		 * No buffers available. Locate previous slot with
-		 * REPORT_STATUS set.
-		 * If the slot has DD set, we can reclaim space,
-		 * otherwise wait for the next interrupt.
-		 * This enables interrupt moderation on the tx
-		 * side though it might reduce throughput.
-		 */
-		struct ixgbe_legacy_tx_desc *txd =
-		    (struct ixgbe_legacy_tx_desc *)txr->tx_base;
-
-		nic_i = txr->next_to_clean + report_frequency;
-		if (nic_i > lim)
-			nic_i -= lim + 1;
-		// round to the closest with dd set
-		nic_i = (nic_i < kring->nkr_num_slots / 4 ||
-			 nic_i >= kring->nkr_num_slots*3/4) ?
-			0 : report_frequency;
-		reclaim_tx = txd[nic_i].upper.fields.status & IXGBE_TXD_STAT_DD;	// XXX cpu_to_le32 ?
-	}
-	if (reclaim_tx) {
-		/*
-		 * Record completed transmissions.
-		 * We (re)use the driver's txr->next_to_clean to keep
-		 * track of the most recently completed transmission.
-		 *
-		 * The datasheet discourages the use of TDH to find
-		 * out the number of sent packets, but we only set
-		 * REPORT_STATUS in a few slots so TDH is the only
-		 * good way.
-		 */
-		nic_i = IXGBE_READ_REG(&adapter->hw, IXGBE_TDH(kring->ring_id));
-		if (nic_i >= kring->nkr_num_slots) { /* XXX can it happen ? */
-			D("TDH wrap %d", nic_i);
-			nic_i -= kring->nkr_num_slots;
-		}
-		if (nic_i != txr->next_to_clean) {
-			/* some tx completed, increment avail */
-			txr->next_to_clean = nic_i;
-			kring->nr_hwtail = nm_prev(netmap_idx_n2k(kring, nic_i), lim);
-		}
-	}
-
-	nm_txsync_finalize(kring);
-
-	return 0;
-}
-
-
-/*
- * Reconcile kernel and user view of the receive ring.
- * Same as for the txsync, this routine must be efficient.
- * The caller guarantees a single invocations, but races against
- * the rest of the driver should be handled here.
- *
- * On call, kring->rhead is the first packet that userspace wants
- * to keep, and kring->rcur is the wakeup point.
- * The kernel has previously reported packets up to kring->rtail.
- *
- * If (flags & NAF_FORCE_READ) also check for incoming packets irrespective
- * of whether or not we received an interrupt.
- */
-static int
-ixgbe_netmap_rxsync(struct netmap_kring *kring, int flags)
-{
-	struct netmap_adapter *na = kring->na;
-	struct ifnet *ifp = na->ifp;
-	struct netmap_ring *ring = kring->ring;
-	u_int nm_i;	/* index into the netmap ring */
-	u_int nic_i;	/* index into the NIC ring */
-	u_int n;
-	u_int const lim = kring->nkr_num_slots - 1;
-	u_int const head = nm_rxsync_prologue(kring);
-	int force_update = (flags & NAF_FORCE_READ) || kring->nr_kflags & NKR_PENDINTR;
-
-	/* device-specific */
-	struct adapter *adapter = ifp->if_softc;
-	struct rx_ring *rxr = &adapter->rx_rings[kring->ring_id];
-
-	if (head > lim)
-		return netmap_ring_reinit(kring);
-
-	/* XXX check sync modes */
-	bus_dmamap_sync(rxr->rxdma.dma_tag, rxr->rxdma.dma_map,
-			BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
-
-	/*
-	 * First part: import newly received packets.
-	 *
-	 * nm_i is the index of the next free slot in the netmap ring,
-	 * nic_i is the index of the next received packet in the NIC ring,
-	 * and they may differ in case if_init() has been called while
-	 * in netmap mode. For the receive ring we have
-	 *
-	 *	nic_i = rxr->next_to_check;
-	 *	nm_i = kring->nr_hwtail (previous)
-	 * and
-	 *	nm_i == (nic_i + kring->nkr_hwofs) % ring_size
-	 *
-	 * rxr->next_to_check is set to 0 on a ring reinit
-	 */
-	if (netmap_no_pendintr || force_update) {
-		int crclen = ix_crcstrip ? 0 : 4;
-		uint16_t slot_flags = kring->nkr_slot_flags;
-
-		nic_i = rxr->next_to_check; // or also k2n(kring->nr_hwtail)
-		nm_i = netmap_idx_n2k(kring, nic_i);
-
-		for (n = 0; ; n++) {
-			union ixgbe_adv_rx_desc *curr = &rxr->rx_base[nic_i];
-			uint32_t staterr = le32toh(curr->wb.upper.status_error);
-
-			if ((staterr & IXGBE_RXD_STAT_DD) == 0)
-				break;
-			ring->slot[nm_i].len = le16toh(curr->wb.upper.length) - crclen;
-			ring->slot[nm_i].flags = slot_flags;
-			bus_dmamap_sync(rxr->ptag,
-			    rxr->rx_buffers[nic_i].pmap, BUS_DMASYNC_POSTREAD);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		if (n) { /* update the state variables */
-			if (netmap_no_pendintr && !force_update) {
-				/* diagnostics */
-				ix_rx_miss ++;
-				ix_rx_miss_bufs += n;
-			}
-			rxr->next_to_check = nic_i;
-			kring->nr_hwtail = nm_i;
-		}
-		kring->nr_kflags &= ~NKR_PENDINTR;
-	}
-
-	/*
-	 * Second part: skip past packets that userspace has released.
-	 * (kring->nr_hwcur to kring->rhead excluded),
-	 * and make the buffers available for reception.
-	 * As usual nm_i is the index in the netmap ring,
-	 * nic_i is the index in the NIC ring, and
-	 * nm_i == (nic_i + kring->nkr_hwofs) % ring_size
-	 */
-	nm_i = kring->nr_hwcur;
-	if (nm_i != head) {
-		nic_i = netmap_idx_k2n(kring, nm_i);
-		for (n = 0; nm_i != head; n++) {
-			struct netmap_slot *slot = &ring->slot[nm_i];
-			uint64_t paddr;
-			void *addr = PNMB(na, slot, &paddr);
-
-			union ixgbe_adv_rx_desc *curr = &rxr->rx_base[nic_i];
-			struct ixgbe_rx_buf *rxbuf = &rxr->rx_buffers[nic_i];
-
-			if (addr == NETMAP_BUF_BASE(na)) /* bad buf */
-				goto ring_reset;
-
-			if (slot->flags & NS_BUF_CHANGED) {
-				/* buffer has changed, reload map */
-				netmap_reload_map(na, rxr->ptag, rxbuf->pmap, addr);
-				slot->flags &= ~NS_BUF_CHANGED;
-			}
-			curr->wb.upper.status_error = 0;
-			curr->read.pkt_addr = htole64(paddr);
-			bus_dmamap_sync(rxr->ptag, rxbuf->pmap,
-			    BUS_DMASYNC_PREREAD);
-			nm_i = nm_next(nm_i, lim);
-			nic_i = nm_next(nic_i, lim);
-		}
-		kring->nr_hwcur = head;
-
-		bus_dmamap_sync(rxr->rxdma.dma_tag, rxr->rxdma.dma_map,
-		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
-		/*
-		 * IMPORTANT: we must leave one free slot in the ring,
-		 * so move nic_i back by one unit
-		 */
-		nic_i = nm_prev(nic_i, lim);
-		IXGBE_WRITE_REG(&adapter->hw, IXGBE_RDT(rxr->me), nic_i);
-	}
-
-	/* tell userspace that there might be new packets */
-	nm_rxsync_finalize(kring);
-
-	return 0;
-
-ring_reset:
-	return netmap_ring_reinit(kring);
-}
-
-
-/*
- * The attach routine, called near the end of ixgbe_attach(),
- * fills the parameters for netmap_attach() and calls it.
- * It cannot fail, in the worst case (such as no memory)
- * netmap mode will be disabled and the driver will only
- * operate in standard mode.
- */
-static void
-ixgbe_netmap_attach(struct adapter *adapter)
-{
-	struct netmap_adapter na;
-
-	bzero(&na, sizeof(na));
-
-	na.ifp = adapter->ifp;
-	na.na_flags = NAF_BDG_MAYSLEEP;
-	na.num_tx_desc = adapter->num_tx_desc;
-	na.num_rx_desc = adapter->num_rx_desc;
-	na.nm_txsync = ixgbe_netmap_txsync;
-	na.nm_rxsync = ixgbe_netmap_rxsync;
-	na.nm_register = ixgbe_netmap_reg;
-	na.num_tx_rings = na.num_rx_rings = adapter->num_queues;
-	netmap_attach(&na);
-}
-
-/* end of file */
diff --git a/drivers/staging/netmap/sys/dev/netmap/netmap_freebsd.c b/drivers/staging/netmap/sys/dev/netmap/netmap_freebsd.c
deleted file mode 100644
index 8a2505577d98..000000000000
--- a/drivers/staging/netmap/sys/dev/netmap/netmap_freebsd.c
+++ /dev/null
@@ -1,833 +0,0 @@
-/*
- * Copyright (C) 2013-2014 Universita` di Pisa. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *   1. Redistributions of source code must retain the above copyright
- *      notice, this list of conditions and the following disclaimer.
- *   2. Redistributions in binary form must reproduce the above copyright
- *      notice, this list of conditions and the following disclaimer in the
- *      documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/* $FreeBSD$ */
-
-#include <sys/types.h>
-#include <sys/module.h>
-#include <sys/errno.h>
-#include <sys/param.h>  /* defines used in kernel.h */
-#include <sys/poll.h>  /* POLLIN, POLLOUT */
-#include <sys/kernel.h> /* types used in module initialization */
-#include <sys/conf.h>	/* DEV_MODULE */
-#include <sys/endian.h>
-
-#include <sys/rwlock.h>
-
-#include <vm/vm.h>      /* vtophys */
-#include <vm/pmap.h>    /* vtophys */
-#include <vm/vm_param.h>
-#include <vm/vm_object.h>
-#include <vm/vm_page.h>
-#include <vm/vm_pager.h>
-#include <vm/uma.h>
-
-
-#include <sys/malloc.h>
-#include <sys/socket.h> /* sockaddrs */
-#include <sys/selinfo.h>
-#include <net/if.h>
-#include <net/if_var.h>
-#include <net/if_types.h> /* IFT_ETHER */
-#include <net/ethernet.h> /* ether_ifdetach */
-#include <net/if_dl.h> /* LLADDR */
-#include <machine/bus.h>        /* bus_dmamap_* */
-#include <netinet/in.h>		/* in6_cksum_pseudo() */
-#include <machine/in_cksum.h>  /* in_pseudo(), in_cksum_hdr() */
-
-#include <net/netmap.h>
-#include <dev/netmap/netmap_kern.h>
-#include <dev/netmap/netmap_mem2.h>
-
-
-/* ======================== FREEBSD-SPECIFIC ROUTINES ================== */
-
-rawsum_t
-nm_csum_raw(uint8_t *data, size_t len, rawsum_t cur_sum)
-{
-	/* TODO XXX please use the FreeBSD implementation for this. */
-	uint16_t *words = (uint16_t *)data;
-	int nw = len / 2;
-	int i;
-
-	for (i = 0; i < nw; i++)
-		cur_sum += be16toh(words[i]);
-
-	if (len & 1)
-		cur_sum += (data[len-1] << 8);
-
-	return cur_sum;
-}
-
-/* Fold a raw checksum: 'cur_sum' is in host byte order, while the
- * return value is in network byte order.
- */
-uint16_t
-nm_csum_fold(rawsum_t cur_sum)
-{
-	/* TODO XXX please use the FreeBSD implementation for this. */
-	while (cur_sum >> 16)
-		cur_sum = (cur_sum & 0xFFFF) + (cur_sum >> 16);
-
-	return htobe16((~cur_sum) & 0xFFFF);
-}
-
-uint16_t nm_csum_ipv4(struct nm_iphdr *iph)
-{
-#if 0
-	return in_cksum_hdr((void *)iph);
-#else
-	return nm_csum_fold(nm_csum_raw((uint8_t*)iph, sizeof(struct nm_iphdr), 0));
-#endif
-}
-
-void
-nm_csum_tcpudp_ipv4(struct nm_iphdr *iph, void *data,
-					size_t datalen, uint16_t *check)
-{
-#ifdef INET
-	uint16_t pseudolen = datalen + iph->protocol;
-
-	/* Compute and insert the pseudo-header cheksum. */
-	*check = in_pseudo(iph->saddr, iph->daddr,
-				 htobe16(pseudolen));
-	/* Compute the checksum on TCP/UDP header + payload
-	 * (includes the pseudo-header).
-	 */
-	*check = nm_csum_fold(nm_csum_raw(data, datalen, 0));
-#else
-	static int notsupported = 0;
-	if (!notsupported) {
-		notsupported = 1;
-		D("inet4 segmentation not supported");
-	}
-#endif
-}
-
-void
-nm_csum_tcpudp_ipv6(struct nm_ipv6hdr *ip6h, void *data,
-					size_t datalen, uint16_t *check)
-{
-#ifdef INET6
-	*check = in6_cksum_pseudo((void*)ip6h, datalen, ip6h->nexthdr, 0);
-	*check = nm_csum_fold(nm_csum_raw(data, datalen, 0));
-#else
-	static int notsupported = 0;
-	if (!notsupported) {
-		notsupported = 1;
-		D("inet6 segmentation not supported");
-	}
-#endif
-}
-
-
-/*
- * Intercept the rx routine in the standard device driver.
- * Second argument is non-zero to intercept, 0 to restore
- */
-int
-netmap_catch_rx(struct netmap_adapter *na, int intercept)
-{
-	struct netmap_generic_adapter *gna = (struct netmap_generic_adapter *)na;
-	struct ifnet *ifp = na->ifp;
-
-	if (intercept) {
-		if (gna->save_if_input) {
-			D("cannot intercept again");
-			return EINVAL; /* already set */
-		}
-		gna->save_if_input = ifp->if_input;
-		ifp->if_input = generic_rx_handler;
-	} else {
-		if (!gna->save_if_input){
-			D("cannot restore");
-			return EINVAL;  /* not saved */
-		}
-		ifp->if_input = gna->save_if_input;
-		gna->save_if_input = NULL;
-	}
-
-	return 0;
-}
-
-
-/*
- * Intercept the packet steering routine in the tx path,
- * so that we can decide which queue is used for an mbuf.
- * Second argument is non-zero to intercept, 0 to restore.
- * On freebsd we just intercept if_transmit.
- */
-void
-netmap_catch_tx(struct netmap_generic_adapter *gna, int enable)
-{
-	struct netmap_adapter *na = &gna->up.up;
-	struct ifnet *ifp = na->ifp;
-
-	if (enable) {
-		na->if_transmit = ifp->if_transmit;
-		ifp->if_transmit = netmap_transmit;
-	} else {
-		ifp->if_transmit = na->if_transmit;
-	}
-}
-
-
-/*
- * Transmit routine used by generic_netmap_txsync(). Returns 0 on success
- * and non-zero on error (which may be packet drops or other errors).
- * addr and len identify the netmap buffer, m is the (preallocated)
- * mbuf to use for transmissions.
- *
- * We should add a reference to the mbuf so the m_freem() at the end
- * of the transmission does not consume resources.
- *
- * On FreeBSD, and on multiqueue cards, we can force the queue using
- *      if ((m->m_flags & M_FLOWID) != 0)
- *              i = m->m_pkthdr.flowid % adapter->num_queues;
- *      else
- *              i = curcpu % adapter->num_queues;
- *
- */
-int
-generic_xmit_frame(struct ifnet *ifp, struct mbuf *m,
-	void *addr, u_int len, u_int ring_nr)
-{
-	int ret;
-
-	/*
-	 * The mbuf should be a cluster from our special pool,
-	 * so we do not need to do an m_copyback but just copy
-	 * (and eventually, just reference the netmap buffer)
-	 */
-
-	if (GET_MBUF_REFCNT(m) != 1) {
-		D("invalid refcnt %d for %p",
-			GET_MBUF_REFCNT(m), m);
-		panic("in generic_xmit_frame");
-	}
-	// XXX the ext_size check is unnecessary if we link the netmap buf
-	if (m->m_ext.ext_size < len) {
-		RD(5, "size %d < len %d", m->m_ext.ext_size, len);
-		len = m->m_ext.ext_size;
-	}
-	if (0) { /* XXX seems to have negligible benefits */
-		m->m_ext.ext_buf = m->m_data = addr;
-	} else {
-		bcopy(addr, m->m_data, len);
-	}
-	m->m_len = m->m_pkthdr.len = len;
-	// inc refcount. All ours, we could skip the atomic
-	atomic_fetchadd_int(PNT_MBUF_REFCNT(m), 1);
-	m->m_flags |= M_FLOWID;
-	m->m_pkthdr.flowid = ring_nr;
-	m->m_pkthdr.rcvif = ifp; /* used for tx notification */
-	ret = NA(ifp)->if_transmit(ifp, m);
-	return ret;
-}
-
-
-#if __FreeBSD_version >= 1100005
-struct netmap_adapter *
-netmap_getna(if_t ifp)
-{
-	return (NA((struct ifnet *)ifp));
-}
-#endif /* __FreeBSD_version >= 1100005 */
-
-/*
- * The following two functions are empty until we have a generic
- * way to extract the info from the ifp
- */
-int
-generic_find_num_desc(struct ifnet *ifp, unsigned int *tx, unsigned int *rx)
-{
-	D("called, in tx %d rx %d", *tx, *rx);
-	return 0;
-}
-
-
-void
-generic_find_num_queues(struct ifnet *ifp, u_int *txq, u_int *rxq)
-{
-	D("called, in txq %d rxq %d", *txq, *rxq);
-	*txq = netmap_generic_rings;
-	*rxq = netmap_generic_rings;
-}
-
-
-void
-netmap_mitigation_init(struct nm_generic_mit *mit, int idx, struct netmap_adapter *na)
-{
-	ND("called");
-	mit->mit_pending = 0;
-	mit->mit_ring_idx = idx;
-	mit->mit_na = na;
-}
-
-
-void
-netmap_mitigation_start(struct nm_generic_mit *mit)
-{
-	ND("called");
-}
-
-
-void
-netmap_mitigation_restart(struct nm_generic_mit *mit)
-{
-	ND("called");
-}
-
-
-int
-netmap_mitigation_active(struct nm_generic_mit *mit)
-{
-	ND("called");
-	return 0;
-}
-
-
-void
-netmap_mitigation_cleanup(struct nm_generic_mit *mit)
-{
-	ND("called");
-}
-
-static int
-nm_vi_dummy(struct ifnet *ifp, u_long cmd, caddr_t addr)
-{
-	return EINVAL;
-}
-
-static void
-nm_vi_start(struct ifnet *ifp)
-{
-	panic("nm_vi_start() must not be called");
-}
-
-/*
- * Index manager of persistent virtual interfaces.
- * It is used to decide the lowest byte of the MAC address.
- * We use the same algorithm with management of bridge port index.
- */
-#define NM_VI_MAX	255
-static struct {
-	uint8_t index[NM_VI_MAX]; /* XXX just for a reasonable number */
-	uint8_t active;
-	struct mtx lock;
-} nm_vi_indices;
-
-void
-nm_vi_init_index(void)
-{
-	int i;
-	for (i = 0; i < NM_VI_MAX; i++)
-		nm_vi_indices.index[i] = i;
-	nm_vi_indices.active = 0;
-	mtx_init(&nm_vi_indices.lock, "nm_vi_indices_lock", NULL, MTX_DEF);
-}
-
-/* return -1 if no index available */
-static int
-nm_vi_get_index(void)
-{
-	int ret;
-
-	mtx_lock(&nm_vi_indices.lock);
-	ret = nm_vi_indices.active == NM_VI_MAX ? -1 :
-		nm_vi_indices.index[nm_vi_indices.active++];
-	mtx_unlock(&nm_vi_indices.lock);
-	return ret;
-}
-
-static void
-nm_vi_free_index(uint8_t val)
-{
-	int i, lim;
-
-	mtx_lock(&nm_vi_indices.lock);
-	lim = nm_vi_indices.active;
-	for (i = 0; i < lim; i++) {
-		if (nm_vi_indices.index[i] == val) {
-			/* swap index[lim-1] and j */
-			int tmp = nm_vi_indices.index[lim-1];
-			nm_vi_indices.index[lim-1] = val;
-			nm_vi_indices.index[i] = tmp;
-			nm_vi_indices.active--;
-			break;
-		}
-	}
-	if (lim == nm_vi_indices.active)
-		D("funny, index %u didn't found", val);
-	mtx_unlock(&nm_vi_indices.lock);
-}
-#undef NM_VI_MAX
-
-/*
- * Implementation of a netmap-capable virtual interface that
- * registered to the system.
- * It is based on if_tap.c and ip_fw_log.c in FreeBSD 9.
- *
- * Note: Linux sets refcount to 0 on allocation of net_device,
- * then increments it on registration to the system.
- * FreeBSD sets refcount to 1 on if_alloc(), and does not
- * increment this refcount on if_attach().
- */
-int
-nm_vi_persist(const char *name, struct ifnet **ret)
-{
-	struct ifnet *ifp;
-	u_short macaddr_hi;
-	uint32_t macaddr_mid;
-	u_char eaddr[6];
-	int unit = nm_vi_get_index(); /* just to decide MAC address */
-
-	if (unit < 0)
-		return EBUSY;
-	/*
-	 * We use the same MAC address generation method with tap
-	 * except for the highest octet is 00:be instead of 00:bd
-	 */
-	macaddr_hi = htons(0x00be); /* XXX tap + 1 */
-	macaddr_mid = (uint32_t) ticks;
-	bcopy(&macaddr_hi, eaddr, sizeof(short));
-	bcopy(&macaddr_mid, &eaddr[2], sizeof(uint32_t));
-	eaddr[5] = (uint8_t)unit;
-
-	ifp = if_alloc(IFT_ETHER);
-	if (ifp == NULL) {
-		D("if_alloc failed");
-		return ENOMEM;
-	}
-	if_initname(ifp, name, IF_DUNIT_NONE);
-	ifp->if_mtu = 65536;
-	ifp->if_flags = IFF_UP | IFF_SIMPLEX | IFF_MULTICAST;
-	ifp->if_init = (void *)nm_vi_dummy;
-	ifp->if_ioctl = nm_vi_dummy;
-	ifp->if_start = nm_vi_start;
-	ifp->if_mtu = ETHERMTU;
-	IFQ_SET_MAXLEN(&ifp->if_snd, ifqmaxlen);
-	ifp->if_capabilities |= IFCAP_LINKSTATE;
-	ifp->if_capenable |= IFCAP_LINKSTATE;
-
-	ether_ifattach(ifp, eaddr);
-	*ret = ifp;
-	return 0;
-}
-/* unregister from the system and drop the final refcount */
-void
-nm_vi_detach(struct ifnet *ifp)
-{
-	nm_vi_free_index(((char *)IF_LLADDR(ifp))[5]);
-	ether_ifdetach(ifp);
-	if_free(ifp);
-}
-
-/*
- * In order to track whether pages are still mapped, we hook into
- * the standard cdev_pager and intercept the constructor and
- * destructor.
- */
-
-struct netmap_vm_handle_t {
-	struct cdev 		*dev;
-	struct netmap_priv_d	*priv;
-};
-
-
-static int
-netmap_dev_pager_ctor(void *handle, vm_ooffset_t size, vm_prot_t prot,
-    vm_ooffset_t foff, struct ucred *cred, u_short *color)
-{
-	struct netmap_vm_handle_t *vmh = handle;
-
-	if (netmap_verbose)
-		D("handle %p size %jd prot %d foff %jd",
-			handle, (intmax_t)size, prot, (intmax_t)foff);
-	if (color)
-		*color = 0;
-	dev_ref(vmh->dev);
-	return 0;
-}
-
-
-static void
-netmap_dev_pager_dtor(void *handle)
-{
-	struct netmap_vm_handle_t *vmh = handle;
-	struct cdev *dev = vmh->dev;
-	struct netmap_priv_d *priv = vmh->priv;
-
-	if (netmap_verbose)
-		D("handle %p", handle);
-	netmap_dtor(priv);
-	free(vmh, M_DEVBUF);
-	dev_rel(dev);
-}
-
-
-static int
-netmap_dev_pager_fault(vm_object_t object, vm_ooffset_t offset,
-	int prot, vm_page_t *mres)
-{
-	struct netmap_vm_handle_t *vmh = object->handle;
-	struct netmap_priv_d *priv = vmh->priv;
-	struct netmap_adapter *na = priv->np_na;
-	vm_paddr_t paddr;
-	vm_page_t page;
-	vm_memattr_t memattr;
-	vm_pindex_t pidx;
-
-	ND("object %p offset %jd prot %d mres %p",
-			object, (intmax_t)offset, prot, mres);
-	memattr = object->memattr;
-	pidx = OFF_TO_IDX(offset);
-	paddr = netmap_mem_ofstophys(na->nm_mem, offset);
-	if (paddr == 0)
-		return VM_PAGER_FAIL;
-
-	if (((*mres)->flags & PG_FICTITIOUS) != 0) {
-		/*
-		 * If the passed in result page is a fake page, update it with
-		 * the new physical address.
-		 */
-		page = *mres;
-		vm_page_updatefake(page, paddr, memattr);
-	} else {
-		/*
-		 * Replace the passed in reqpage page with our own fake page and
-		 * free up the all of the original pages.
-		 */
-#ifndef VM_OBJECT_WUNLOCK	/* FreeBSD < 10.x */
-#define VM_OBJECT_WUNLOCK VM_OBJECT_UNLOCK
-#define VM_OBJECT_WLOCK	VM_OBJECT_LOCK
-#endif /* VM_OBJECT_WUNLOCK */
-
-		VM_OBJECT_WUNLOCK(object);
-		page = vm_page_getfake(paddr, memattr);
-		VM_OBJECT_WLOCK(object);
-		vm_page_lock(*mres);
-		vm_page_free(*mres);
-		vm_page_unlock(*mres);
-		*mres = page;
-		vm_page_insert(page, object, pidx);
-	}
-	page->valid = VM_PAGE_BITS_ALL;
-	return (VM_PAGER_OK);
-}
-
-
-static struct cdev_pager_ops netmap_cdev_pager_ops = {
-	.cdev_pg_ctor = netmap_dev_pager_ctor,
-	.cdev_pg_dtor = netmap_dev_pager_dtor,
-	.cdev_pg_fault = netmap_dev_pager_fault,
-};
-
-
-static int
-netmap_mmap_single(struct cdev *cdev, vm_ooffset_t *foff,
-	vm_size_t objsize,  vm_object_t *objp, int prot)
-{
-	int error;
-	struct netmap_vm_handle_t *vmh;
-	struct netmap_priv_d *priv;
-	vm_object_t obj;
-
-	if (netmap_verbose)
-		D("cdev %p foff %jd size %jd objp %p prot %d", cdev,
-		    (intmax_t )*foff, (intmax_t )objsize, objp, prot);
-
-	vmh = malloc(sizeof(struct netmap_vm_handle_t), M_DEVBUF,
-			      M_NOWAIT | M_ZERO);
-	if (vmh == NULL)
-		return ENOMEM;
-	vmh->dev = cdev;
-
-	NMG_LOCK();
-	error = devfs_get_cdevpriv((void**)&priv);
-	if (error)
-		goto err_unlock;
-	if (priv->np_nifp == NULL) {
-		error = EINVAL;
-		goto err_unlock;
-	}
-	vmh->priv = priv;
-	priv->np_refcount++;
-	NMG_UNLOCK();
-
-	obj = cdev_pager_allocate(vmh, OBJT_DEVICE,
-		&netmap_cdev_pager_ops, objsize, prot,
-		*foff, NULL);
-	if (obj == NULL) {
-		D("cdev_pager_allocate failed");
-		error = EINVAL;
-		goto err_deref;
-	}
-
-	*objp = obj;
-	return 0;
-
-err_deref:
-	NMG_LOCK();
-	priv->np_refcount--;
-err_unlock:
-	NMG_UNLOCK();
-// err:
-	free(vmh, M_DEVBUF);
-	return error;
-}
-
-
-// XXX can we remove this ?
-static int
-netmap_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
-{
-	if (netmap_verbose)
-		D("dev %p fflag 0x%x devtype %d td %p",
-			dev, fflag, devtype, td);
-	return 0;
-}
-
-
-static int
-netmap_open(struct cdev *dev, int oflags, int devtype, struct thread *td)
-{
-	struct netmap_priv_d *priv;
-	int error;
-
-	(void)dev;
-	(void)oflags;
-	(void)devtype;
-	(void)td;
-
-	// XXX wait or nowait ?
-	priv = malloc(sizeof(struct netmap_priv_d), M_DEVBUF,
-			      M_NOWAIT | M_ZERO);
-	if (priv == NULL)
-		return ENOMEM;
-
-	error = devfs_set_cdevpriv(priv, netmap_dtor);
-	if (error)
-	        return error;
-
-	priv->np_refcount = 1;
-
-	return 0;
-}
-
-/******************** kqueue support ****************/
-
-/*
- * The OS_selwakeup also needs to issue a KNOTE_UNLOCKED.
- * We use a non-zero argument to distinguish the call from the one
- * in kevent_scan() which instead also needs to run netmap_poll().
- * The knote uses a global mutex for the time being. We might
- * try to reuse the one in the si, but it is not allocated
- * permanently so it might be a bit tricky.
- *
- * The *kqfilter function registers one or another f_event
- * depending on read or write mode.
- * In the call to f_event() td_fpop is NULL so any child function
- * calling devfs_get_cdevpriv() would fail - and we need it in
- * netmap_poll(). As a workaround we store priv into kn->kn_hook
- * and pass it as first argument to netmap_poll(), which then
- * uses the failure to tell that we are called from f_event()
- * and do not need the selrecord().
- */
-
-
-void
-freebsd_selwakeup(struct nm_selinfo *si, int pri)
-{
-	if (netmap_verbose)
-		D("on knote %p", &si->si.si_note);
-	selwakeuppri(&si->si, pri);
-	/* use a non-zero hint to tell the notification from the
-	 * call done in kqueue_scan() which uses 0
-	 */
-	KNOTE_UNLOCKED(&si->si.si_note, 0x100 /* notification */);
-}
-
-static void
-netmap_knrdetach(struct knote *kn)
-{
-	struct netmap_priv_d *priv = (struct netmap_priv_d *)kn->kn_hook;
-	struct selinfo *si = &priv->np_rxsi->si;
-
-	D("remove selinfo %p", si);
-	knlist_remove(&si->si_note, kn, 0);
-}
-
-static void
-netmap_knwdetach(struct knote *kn)
-{
-	struct netmap_priv_d *priv = (struct netmap_priv_d *)kn->kn_hook;
-	struct selinfo *si = &priv->np_txsi->si;
-
-	D("remove selinfo %p", si);
-	knlist_remove(&si->si_note, kn, 0);
-}
-
-/*
- * callback from notifies (generated externally) and our
- * calls to kevent(). The former we just return 1 (ready)
- * since we do not know better.
- * In the latter we call netmap_poll and return 0/1 accordingly.
- */
-static int
-netmap_knrw(struct knote *kn, long hint, int events)
-{
-	struct netmap_priv_d *priv;
-	int revents;
-
-	if (hint != 0) {
-		ND(5, "call from notify");
-		return 1; /* assume we are ready */
-	}
-	priv = kn->kn_hook;
-	/* the notification may come from an external thread,
-	 * in which case we do not want to run the netmap_poll
-	 * This should be filtered above, but check just in case.
-	 */
-	if (curthread != priv->np_td) { /* should not happen */
-		RD(5, "curthread changed %p %p", curthread, priv->np_td);
-		return 1;
-	} else {
-		revents = netmap_poll((void *)priv, events, curthread);
-		return (events & revents) ? 1 : 0;
-	}
-}
-
-static int
-netmap_knread(struct knote *kn, long hint)
-{
-	return netmap_knrw(kn, hint, POLLIN);
-}
-
-static int
-netmap_knwrite(struct knote *kn, long hint)
-{
-	return netmap_knrw(kn, hint, POLLOUT);
-}
-
-static struct filterops netmap_rfiltops = {
-	.f_isfd = 1,
-	.f_detach = netmap_knrdetach,
-	.f_event = netmap_knread,
-};
-
-static struct filterops netmap_wfiltops = {
-	.f_isfd = 1,
-	.f_detach = netmap_knwdetach,
-	.f_event = netmap_knwrite,
-};
-
-
-/*
- * This is called when a thread invokes kevent() to record
- * a change in the configuration of the kqueue().
- * The 'priv' should be the same as in the netmap device.
- */
-static int
-netmap_kqfilter(struct cdev *dev, struct knote *kn)
-{
-	struct netmap_priv_d *priv;
-	int error;
-	struct netmap_adapter *na;
-	struct nm_selinfo *si;
-	int ev = kn->kn_filter;
-
-	if (ev != EVFILT_READ && ev != EVFILT_WRITE) {
-		D("bad filter request %d", ev);
-		return 1;
-	}
-	error = devfs_get_cdevpriv((void**)&priv);
-	if (error) {
-		D("device not yet setup");
-		return 1;
-	}
-	na = priv->np_na;
-	if (na == NULL) {
-		D("no netmap adapter for this file descriptor");
-		return 1;
-	}
-	/* the si is indicated in the priv */
-	si = (ev == EVFILT_WRITE) ? priv->np_txsi : priv->np_rxsi;
-	// XXX lock(priv) ?
-	kn->kn_fop = (ev == EVFILT_WRITE) ?
-		&netmap_wfiltops : &netmap_rfiltops;
-	kn->kn_hook = priv;
-	knlist_add(&si->si.si_note, kn, 1);
-	// XXX unlock(priv)
-	ND("register %p %s td %p priv %p kn %p np_nifp %p kn_fp/fpop %s",
-		na, na->ifp->if_xname, curthread, priv, kn,
-		priv->np_nifp,
-		kn->kn_fp == curthread->td_fpop ? "match" : "MISMATCH");
-	return 0;
-}
-
-struct cdevsw netmap_cdevsw = {
-	.d_version = D_VERSION,
-	.d_name = "netmap",
-	.d_open = netmap_open,
-	.d_mmap_single = netmap_mmap_single,
-	.d_ioctl = netmap_ioctl,
-	.d_poll = netmap_poll,
-	.d_kqfilter = netmap_kqfilter,
-	.d_close = netmap_close,
-};
-/*--- end of kqueue support ----*/
-
-/*
- * Kernel entry point.
- *
- * Initialize/finalize the module and return.
- *
- * Return 0 on success, errno on failure.
- */
-static int
-netmap_loader(__unused struct module *module, int event, __unused void *arg)
-{
-	int error = 0;
-
-	switch (event) {
-	case MOD_LOAD:
-		error = netmap_init();
-		break;
-
-	case MOD_UNLOAD:
-		netmap_fini();
-		break;
-
-	default:
-		error = EOPNOTSUPP;
-		break;
-	}
-
-	return (error);
-}
-
-
-DEV_MODULE(netmap, netmap_loader, NULL);
diff --git a/drivers/staging/netmap/sys/modules/netmap/Makefile b/drivers/staging/netmap/sys/modules/netmap/Makefile
deleted file mode 100644
index 8e5364bbe7a2..000000000000
--- a/drivers/staging/netmap/sys/modules/netmap/Makefile
+++ /dev/null
@@ -1,21 +0,0 @@
-# $FreeBSD$
-#
-# Compile netmap as a module, useful if you want a netmap bridge
-# or loadable drivers.
-
-.PATH: ${.CURDIR}/../../dev/netmap
-.PATH.h: ${.CURDIR}/../../net
-CFLAGS += -I${.CURDIR}/../../
-KMOD	= netmap
-SRCS	= device_if.h bus_if.h opt_netmap.h
-SRCS	+= netmap.c netmap.h netmap_kern.h
-SRCS	+= netmap_mem2.c netmap_mem2.h
-SRCS	+= netmap_generic.c
-SRCS	+= netmap_mbq.c netmap_mbq.h
-SRCS	+= netmap_vale.c
-SRCS	+= netmap_freebsd.c
-SRCS	+= netmap_offloadings.c
-SRCS	+= netmap_pipe.c
-SRCS	+= netmap_monitor.c
-
-.include <bsd.kmod.mk>
-- 
2.1.2

