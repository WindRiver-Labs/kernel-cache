From 54f4a7149c4d5f2c0cf5ac652a08bc4ad2d45bbe Mon Sep 17 00:00:00 2001
From: Vu Tran <vu.tran@windriver.com>
Date: Fri, 11 Oct 2013 13:53:00 -0400
Subject: [PATCH] netmap: initialization with intel igb driver

The files added in this commit were originally sourced from the netmap package:
  http://info.iet.unipi.it/~luigi/doc/20120813-netmap.tgz

patch file:
  LINUX/patches/diff--igb--30200--99999--ok

Integrate the initialization of netmap with the intel igb driver. This patch
can be applied to all kernel after 3.0.2.

Also the patch modifies the new path of the include
if_igb_netmap.h file.

Signed-off-by: Michel Thebeau <michel.thebeau@windriver.com>
Signed-off-by: Vu Tran <vu.tran@windriver.com>
---
 drivers/net/ethernet/intel/igb/igb_main.c | 30 ++++++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index 1fb180d..c2f0a8d 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -243,6 +243,10 @@ static int debug = -1;
 module_param(debug, int, 0);
 MODULE_PARM_DESC(debug, "Debug level (0=none,...,16=all)");
 
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#include <../drivers/staging/netmap/if_igb_netmap.h>
+#endif
+
 struct igb_reg_info {
 	u32 ofs;
 	char *name;
@@ -2115,6 +2119,10 @@ static int __devinit igb_probe(struct pci_dev *pdev,
 	/* carrier off reporting is important to ethtool even BEFORE open */
 	netif_carrier_off(netdev);
 
+#ifdef DEV_NETMAP
+	igb_netmap_attach(adapter);
+#endif /* DEV_NETMAP */
+
 #ifdef CONFIG_IGB_DCA
 	if (dca_add_requester(&pdev->dev) == 0) {
 		adapter->flags |= IGB_FLAG_DCA_ENABLED;
@@ -2245,6 +2253,10 @@ static void __devexit igb_remove(struct pci_dev *pdev)
 		dev_info(&pdev->dev, "IOV Disabled\n");
 	}
 #endif
+#ifdef DEV_NETMAP
+	netmap_detach(netdev);
+#endif /* DEV_NETMAP */
+
 
 	iounmap(hw->hw_addr);
 	if (hw->flash_address)
@@ -2784,6 +2796,9 @@ void igb_configure_tx_ring(struct igb_adapter *adapter,
 
 	txdctl |= E1000_TXDCTL_QUEUE_ENABLE;
 	wr32(E1000_TXDCTL(reg_idx), txdctl);
+#ifdef DEV_NETMAP
+	igb_netmap_configure_tx_ring(adapter, reg_idx);
+#endif /* DEV_NETMAP */
 }
 
 /**
@@ -5808,6 +5823,10 @@ static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)
 
 	if (test_bit(__IGB_DOWN, &adapter->state))
 		return true;
+#ifdef DEV_NETMAP
+        if (netmap_tx_irq(tx_ring->netdev, tx_ring->queue_index))
+                return 1; /* cleaned ok */
+#endif /* DEV_NETMAP */
 
 	tx_buffer = &tx_ring->tx_buffer_info[i];
 	tx_desc = IGB_TX_DESC(tx_ring, i);
@@ -6085,6 +6104,12 @@ static bool igb_clean_rx_irq(struct igb_q_vector *q_vector, int budget)
 	u16 cleaned_count = igb_desc_unused(rx_ring);
 	u16 i = rx_ring->next_to_clean;
 
+#ifdef DEV_NETMAP
+	int dummy = 1; // select rx irq handling
+	if (netmap_rx_irq(rx_ring->netdev, rx_ring->queue_index, &dummy))
+		return 1;
+#endif /* DEV_NETMAP */
+
 	rx_desc = IGB_RX_DESC(rx_ring, i);
 
 	while (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {
@@ -6276,6 +6301,11 @@ void igb_alloc_rx_buffers(struct igb_ring *rx_ring, u16 cleaned_count)
 	struct igb_rx_buffer *bi;
 	u16 i = rx_ring->next_to_use;
 
+#ifdef DEV_NETMAP
+	if (igb_netmap_configure_rx_ring(rx_ring))
+                return;
+#endif /* DEV_NETMAP */
+
 	rx_desc = IGB_RX_DESC(rx_ring, i);
 	bi = &rx_ring->rx_buffer_info[i];
 	i -= rx_ring->count;
-- 
1.8.4

