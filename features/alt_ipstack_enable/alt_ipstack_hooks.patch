From 84349f54678814e5ae597f70bd3b023396ec40ce Mon Sep 17 00:00:00 2001
From: Jonas Rendel <Jonas.Rendel@windriver.com>
Date: Fri, 12 Sep 2008 10:13:51 +0200
Subject: [PATCH] add alternate IP stack hooks

---
 arch/arm/include/asm/socket.h     |   14 ++++++
 arch/avr32/include/asm/socket.h   |   14 ++++++
 arch/ia64/include/asm/socket.h    |   15 +++++++
 arch/powerpc/include/asm/socket.h |   14 ++++++
 arch/s390/include/asm/socket.h    |   14 ++++++
 arch/sh/include/asm/socket.h      |   14 ++++++
 arch/sparc/include/asm/socket.h   |   14 ++++++
 arch/um/drivers/net_kern.c        |   38 +++++++++++++++++
 arch/um/drivers/net_user.c        |    7 +++
 arch/um/include/net_user.h        |    2 +-
 fs/Kconfig                        |   10 ++--
 fs/proc/base.c                    |   15 +++++++
 fs/proc/proc_net.c                |   10 ++++-
 fs/proc/proc_sysctl.c             |   22 ++++++++++
 include/asm-cris/socket.h         |   14 ++++++-
 include/asm-frv/socket.h          |   15 ++++++-
 include/asm-m32r/socket.h         |   13 ++++++
 include/asm-m68k/socket.h         |   13 ++++++
 include/asm-mips/socket.h         |   13 ++++++
 include/asm-parisc/socket.h       |   13 ++++++
 include/asm-x86/socket.h          |   14 ++++++
 include/asm-xtensa/socket.h       |   13 ++++++
 include/linux/fib_rules.h         |    9 ++++
 include/linux/if.h                |    9 ++++
 include/linux/if_addr.h           |    6 +++
 include/linux/if_arp.h            |    3 +
 include/linux/if_link.h           |    3 +
 include/linux/in.h                |    8 ++++
 include/linux/neighbour.h         |    9 ++++
 include/linux/net.h               |   13 ++++++
 include/linux/netdevice.h         |    5 ++
 include/linux/netlink.h           |    3 +
 include/linux/notifier.h          |    4 ++
 include/linux/proc_fs.h           |    3 +
 include/linux/rtnetlink.h         |   82 ++++++++++++++++++++++++++++++++++++-
 include/linux/sched.h             |    6 +++
 include/linux/semaphore.h         |    4 ++
 include/linux/socket.h            |   13 +++++-
 include/linux/sockios.h           |   49 ++++++++++++++++++++++
 include/net/rtnetlink.h           |    9 ++++
 include/net/sock.h                |    4 ++
 include/net/udp.h                 |    4 ++
 kernel/fork.c                     |   20 +++++++++-
 kernel/sched.c                    |    8 ++++
 kernel/semaphore.c                |   25 +++++++++++
 kernel/workqueue.c                |    3 +
 net/Kconfig                       |    4 +-
 net/Kconfig.ipfirewall            |    2 +
 net/Kconfig.ipipsec               |    2 +
 net/Kconfig.ipmcrypto             |    2 +
 net/core/datagram.c               |    6 +++
 net/core/dev.c                    |   66 ++++++++++++++++++++++++++++-
 net/core/net-sysfs.c              |   16 +++++++
 net/core/netpoll.c                |   28 +++++++++++++
 net/core/rtnetlink.c              |   66 +++++++++++++++++++++++++++++
 net/core/sock.c                   |   25 +++++++++++-
 net/netlink/af_netlink.c          |   11 +++++
 net/socket.c                      |    2 +
 net/sunrpc/svcsock.c              |   79 +++++++++++++++++++++++++++++++++--
 net/sunrpc/xprtsock.c             |   59 ++++++++++++++++++++++++++
 net/xfrm/Kconfig                  |    1 +
 61 files changed, 960 insertions(+), 22 deletions(-)
 create mode 100644 net/Kconfig.ipfirewall
 create mode 100644 net/Kconfig.ipipsec
 create mode 100644 net/Kconfig.ipmcrypto

diff --git a/arch/arm/include/asm/socket.h b/arch/arm/include/asm/socket.h
index 6817be9..46b42ed 100644
--- a/arch/arm/include/asm/socket.h
+++ b/arch/arm/include/asm/socket.h
@@ -54,4 +54,18 @@
 
 #define SO_MARK			36
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
+
 #endif /* _ASM_SOCKET_H */
diff --git a/arch/avr32/include/asm/socket.h b/arch/avr32/include/asm/socket.h
index 35863f2..010fc69 100644
--- a/arch/avr32/include/asm/socket.h
+++ b/arch/avr32/include/asm/socket.h
@@ -54,4 +54,18 @@
 
 #define SO_MARK			36
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
+
 #endif /* __ASM_AVR32_SOCKET_H */
diff --git a/arch/ia64/include/asm/socket.h b/arch/ia64/include/asm/socket.h
index d5ef0aa..3a5d145 100644
--- a/arch/ia64/include/asm/socket.h
+++ b/arch/ia64/include/asm/socket.h
@@ -63,4 +63,19 @@
 
 #define SO_MARK			36
 
+
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
+
 #endif /* _ASM_IA64_SOCKET_H */
diff --git a/arch/powerpc/include/asm/socket.h b/arch/powerpc/include/asm/socket.h
index f5a4e16..ec931c1 100644
--- a/arch/powerpc/include/asm/socket.h
+++ b/arch/powerpc/include/asm/socket.h
@@ -61,4 +61,18 @@
 
 #define SO_MARK			36
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
+
 #endif	/* _ASM_POWERPC_SOCKET_H */
diff --git a/arch/s390/include/asm/socket.h b/arch/s390/include/asm/socket.h
index c786ab6..b173a8c 100644
--- a/arch/s390/include/asm/socket.h
+++ b/arch/s390/include/asm/socket.h
@@ -62,4 +62,18 @@
 
 #define SO_MARK			36
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
+
 #endif /* _ASM_SOCKET_H */
diff --git a/arch/sh/include/asm/socket.h b/arch/sh/include/asm/socket.h
index 6d4bf65..28d6bad 100644
--- a/arch/sh/include/asm/socket.h
+++ b/arch/sh/include/asm/socket.h
@@ -54,4 +54,18 @@
 
 #define SO_MARK			36
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
+
 #endif /* __ASM_SH_SOCKET_H */
diff --git a/arch/sparc/include/asm/socket.h b/arch/sparc/include/asm/socket.h
index bf50d0c..4c3be80 100644
--- a/arch/sparc/include/asm/socket.h
+++ b/arch/sparc/include/asm/socket.h
@@ -55,4 +55,18 @@
 #define SO_SECURITY_ENCRYPTION_TRANSPORT	0x5002
 #define SO_SECURITY_ENCRYPTION_NETWORK		0x5004
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
+
 #endif /* _ASM_SOCKET_H */
diff --git a/arch/um/drivers/net_kern.c b/arch/um/drivers/net_kern.c
index 5b4ca8d..c19eaf4 100644
--- a/arch/um/drivers/net_kern.c
+++ b/arch/um/drivers/net_kern.c
@@ -31,6 +31,12 @@ static inline void set_ether_mac(struct net_device *dev, unsigned char *addr)
 
 #define DRIVER_NAME "uml-netdev"
 
+#ifdef CONFIG_INTERPEAK
+static int (*uml_net_get_addr)(struct net_device *dev,
+			       struct in_ifaddr *lin_ifa,
+			       int index);
+#endif
+
 static DEFINE_SPINLOCK(opened_lock);
 static LIST_HEAD(opened);
 
@@ -855,6 +861,24 @@ void iter_addresses(void *d, void (*cb)(unsigned char *, unsigned char *,
 					void *),
 		    void *arg)
 {
+#ifdef CONFIG_INTERPEAK
+	int index = 0;
+	struct net_device *dev = d;
+	struct in_ifaddr in;
+	unsigned char address[4], netmask[4];
+
+	while (uml_net_get_addr && uml_net_get_addr(dev, &in, index++) > 0) {
+		address[0] = in.ifa_address & 0xff;
+		address[1] = (in.ifa_address >> 8) & 0xff;
+		address[2] = (in.ifa_address >> 16) & 0xff;
+		address[3] = in.ifa_address >> 24;
+		netmask[0] = in.ifa_mask & 0xff;
+		netmask[1] = (in.ifa_mask >> 8) & 0xff;
+		netmask[2] = (in.ifa_mask >> 16) & 0xff;
+		netmask[3] = in.ifa_mask >> 24;
+		(*cb)(address, netmask, arg);
+	}
+#else
 	struct net_device *dev = d;
 	struct in_device *ip = dev->ip_ptr;
 	struct in_ifaddr *in;
@@ -868,10 +892,23 @@ void iter_addresses(void *d, void (*cb)(unsigned char *, unsigned char *,
 		(*cb)(address, netmask, arg);
 		in = in->ifa_next;
 	}
+#endif
 }
 
 int dev_netmask(void *d, void *m)
 {
+#ifdef CONFIG_INTERPEAK
+	struct net_device *dev = d;
+	struct in_ifaddr in;
+	int ret = 1;
+	__be32 *mask_out = m;
+
+	if (uml_net_get_addr && uml_net_get_addr(dev, &in, 0) > 0) {
+		*mask_out = in.ifa_mask;
+	}
+
+	return(ret);
+#else
 	struct net_device *dev = d;
 	struct in_device *ip = dev->ip_ptr;
 	struct in_ifaddr *in;
@@ -886,6 +923,7 @@ int dev_netmask(void *d, void *m)
 
 	*mask_out = in->ifa_mask;
 	return 0;
+#endif
 }
 
 void *get_output_buffer(int *len_out)
diff --git a/arch/um/drivers/net_user.c b/arch/um/drivers/net_user.c
index 9415dd9..1c6af50 100644
--- a/arch/um/drivers/net_user.c
+++ b/arch/um/drivers/net_user.c
@@ -246,6 +246,13 @@ void close_addr(unsigned char *addr, unsigned char *netmask, void *arg)
 	change(arg, "del", addr, netmask);
 }
 
+void dev_random_addr(int *addr)
+{
+	int rnd = rand();
+
+	memcpy(addr, &rnd, sizeof(int));
+}
+
 char *split_if_spec(char *str, ...)
 {
 	char **arg, *end;
diff --git a/arch/um/include/net_user.h b/arch/um/include/net_user.h
index 63bee15..e1b3e94 100644
--- a/arch/um/include/net_user.h
+++ b/arch/um/include/net_user.h
@@ -28,7 +28,7 @@ extern void ether_user_init(void *data, void *dev);
 extern void iter_addresses(void *d, void (*cb)(unsigned char *,
 					       unsigned char *, void *),
 			   void *arg);
-
+extern void dev_random_addr(int *addr);
 extern void *get_output_buffer(int *len_out);
 extern void free_output_buffer(void *buffer);
 
diff --git a/fs/Kconfig b/fs/Kconfig
index abccb5d..6455d89 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -1559,7 +1559,7 @@ if NETWORK_FILESYSTEMS
 
 config NFS_FS
 	tristate "NFS client support"
-	depends on INET
+	depends on INET || INTERPEAK
 	select LOCKD
 	select SUNRPC
 	select NFS_ACL_SUPPORT if NFS_V3_ACL
@@ -1635,7 +1635,7 @@ config NFS_V4
 
 config ROOT_NFS
 	bool "Root file system on NFS"
-	depends on NFS_FS=y && IP_PNP
+	depends on NFS_FS=y && IP_PNP && INET
 	help
 	  If you want your system to mount its root file system via NFS,
 	  choose Y here.  This is common practice for managing systems
@@ -1646,7 +1646,7 @@ config ROOT_NFS
 
 config NFSD
 	tristate "NFS server support"
-	depends on INET
+	depends on INET || INTERPEAK
 	select LOCKD
 	select SUNRPC
 	select EXPORTFS
@@ -1753,7 +1753,7 @@ config SUNRPC_GSS
 
 config SUNRPC_XPRT_RDMA
 	tristate
-	depends on SUNRPC && INFINIBAND && EXPERIMENTAL
+	depends on SUNRPC && INFINIBAND && EXPERIMENTAL && !INTERPEAK
 	default SUNRPC && INFINIBAND
 	help
 	  This option enables an RPC client transport capability that
@@ -1805,7 +1805,7 @@ config RPCSEC_GSS_SPKM3
 
 config SMB_FS
 	tristate "SMB file system support (OBSOLETE, please use CIFS)"
-	depends on INET
+	depends on INET || INTERPEAK
 	select NLS
 	help
 	  SMB (Server Message Block) is the protocol Windows for Workgroups
diff --git a/fs/proc/base.c b/fs/proc/base.c
index a28840b..9e86714 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -100,6 +100,11 @@ struct pid_entry {
 	union proc_op op;
 };
 
+#ifdef CONFIG_INTERPEAK
+static int proc_vr(struct task_struct*, char*);
+#endif
+
+
 #define NOD(NAME, MODE, IOP, FOP, OP) {			\
 	.name = (NAME),					\
 	.len  = sizeof(NAME) - 1,			\
@@ -530,6 +535,13 @@ static int proc_pid_syscall(struct task_struct *task, char *buffer)
 }
 #endif /* CONFIG_HAVE_ARCH_TRACEHOOK */
 
+#ifdef CONFIG_INTERPEAK
+static int proc_vr(struct task_struct *task, char *buffer)
+{
+	return sprintf(buffer, "%u", task->vr);
+}
+#endif
+
 /************************************************************************/
 /*                       Here the fs part begins                        */
 /************************************************************************/
@@ -2518,6 +2530,9 @@ static const struct pid_entry tgid_base_stuff[] = {
 #ifdef CONFIG_TASK_IO_ACCOUNTING
 	INF("io",	S_IRUGO, tgid_io_accounting),
 #endif
+#ifdef CONFIG_INTERPEAK
+	INF("vr",         S_IRUSR, vr),
+#endif
 };
 
 static int proc_tgid_base_readdir(struct file * filp,
diff --git a/fs/proc/proc_net.c b/fs/proc/proc_net.c
index 7bc296f..b7ab94c 100644
--- a/fs/proc/proc_net.c
+++ b/fs/proc/proc_net.c
@@ -188,7 +188,15 @@ void proc_net_remove(struct net *net, const char *name)
 {
 	remove_proc_entry(name, net->proc_net);
 }
-EXPORT_SYMBOL_GPL(proc_net_remove);
+EXPORT_SYMBOL(proc_net_remove);
+
+#ifdef CONFIG_INTERPEAK
+void do_proc_net_remove(struct net *net, const char *name)
+{
+	remove_proc_entry(name, net->proc_net);
+}
+EXPORT_SYMBOL(do_proc_net_remove);
+#endif
 
 static __net_init int proc_net_ns_init(struct net *net)
 {
diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c
index f9a8b89..425bc58 100644
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@ -100,6 +100,16 @@ static struct dentry *proc_sys_lookup(struct inode *dir, struct dentry *dentry,
 		for (h = sysctl_head_next(NULL); h; h = sysctl_head_next(h)) {
 			if (h->attached_to != table)
 				continue;
+#ifdef CONFIG_INTERPEAK
+			/* If table represents a VR bound directory then */
+			/* check if is bound to the callers VR           */
+			if (h->attached_to->child != NULL && h->attached_to->extra2 != NULL) {
+			  unsigned short *vr = (unsigned short*)h->attached_to->extra2;
+
+			  if (*vr != current->vr)
+			    continue;
+			}
+#endif
 			p = find_in_table(h->attached_by, name);
 			if (p)
 				break;
@@ -280,6 +290,18 @@ static int proc_sys_readdir(struct file *filp, void *dirent, filldir_t filldir)
 	for (h = sysctl_head_next(NULL); h; h = sysctl_head_next(h)) {
 		if (h->attached_to != table)
 			continue;
+#ifdef CONFIG_INTERPEAK
+		/* Check if table represents a VR bound directory. */
+		/* Then verify that it is bound to the callers VR. */
+
+		if (h->attached_to->child != NULL && h->attached_to->extra2 != NULL) {
+		  unsigned short *vr = (unsigned short*)h->attached_to->extra2;
+
+		  if (*vr != current->vr)
+		    continue;
+		}
+#endif /* CONFIG_INTERPEAK */
+
 		ret = scan(h, h->attached_by, &pos, filp, dirent, filldir);
 		if (ret) {
 			sysctl_head_finish(h);
diff --git a/include/asm-cris/socket.h b/include/asm-cris/socket.h
index 9df0ca8..489e3eb 100644
--- a/include/asm-cris/socket.h
+++ b/include/asm-cris/socket.h
@@ -56,6 +56,18 @@
 
 #define SO_MARK			36
 
-#endif /* _ASM_SOCKET_H */
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
 
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
 
+/* <<<<CONFIG INTERPEAK */
+
+#endif /* _ASM_SOCKET_H */
diff --git a/include/asm-frv/socket.h b/include/asm-frv/socket.h
index e51ca67..6ad0e67 100644
--- a/include/asm-frv/socket.h
+++ b/include/asm-frv/socket.h
@@ -54,5 +54,18 @@
 
 #define SO_MARK			36
 
-#endif /* _ASM_SOCKET_H */
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
 
+/* <<<<CONFIG INTERPEAK */
+
+#endif /* _ASM_SOCKET_H */
diff --git a/include/asm-m32r/socket.h b/include/asm-m32r/socket.h
index 9a0e200..126d417 100644
--- a/include/asm-m32r/socket.h
+++ b/include/asm-m32r/socket.h
@@ -54,4 +54,17 @@
 
 #define SO_MARK			36
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
 #endif /* _ASM_M32R_SOCKET_H */
diff --git a/include/asm-m68k/socket.h b/include/asm-m68k/socket.h
index dbc64e9..c1972b1 100644
--- a/include/asm-m68k/socket.h
+++ b/include/asm-m68k/socket.h
@@ -54,4 +54,17 @@
 
 #define SO_MARK			36
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
 #endif /* _ASM_SOCKET_H */
diff --git a/include/asm-mips/socket.h b/include/asm-mips/socket.h
index facc2d7..282df64 100644
--- a/include/asm-mips/socket.h
+++ b/include/asm-mips/socket.h
@@ -114,4 +114,17 @@ enum sock_type {
 
 #endif /* __KERNEL__ */
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
 #endif /* _ASM_SOCKET_H */
diff --git a/include/asm-parisc/socket.h b/include/asm-parisc/socket.h
index fba402c..78172dc 100644
--- a/include/asm-parisc/socket.h
+++ b/include/asm-parisc/socket.h
@@ -59,4 +59,17 @@
  */
 #define SOCK_NONBLOCK   0x40000000
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
 #endif /* _ASM_SOCKET_H */
diff --git a/include/asm-x86/socket.h b/include/asm-x86/socket.h
index 80af9c4..a8f4cb1 100644
--- a/include/asm-x86/socket.h
+++ b/include/asm-x86/socket.h
@@ -54,4 +54,18 @@
 
 #define SO_MARK			36
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+/* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
+
 #endif /* _ASM_SOCKET_H */
diff --git a/include/asm-xtensa/socket.h b/include/asm-xtensa/socket.h
index 6100682..7f0d5bd 100644
--- a/include/asm-xtensa/socket.h
+++ b/include/asm-xtensa/socket.h
@@ -65,4 +65,17 @@
 
 #define SO_MARK			36
 
+/* CONFIG INTERPEAK >>>>*/
+/***** SOL_SOCKET socket options supported only by IPNET: *****/
+ /* int; Set virtual router */
+#define SO_VR                0x1020
+
+/* int; Set permanent vr for calling process */
+#define SO_PERMVR            0x1030
+
+/* int; number of seconds an connection (with keep-alive
+ * active) must be idle before the first probe is sent */
+#define SO_PROBEDELAY        0x1021
+
+/* <<<<CONFIG INTERPEAK */
 #endif	/* _XTENSA_SOCKET_H */
diff --git a/include/linux/fib_rules.h b/include/linux/fib_rules.h
index 87b606b..a82d37e 100644
--- a/include/linux/fib_rules.h
+++ b/include/linux/fib_rules.h
@@ -47,6 +47,15 @@ enum
 	FRA_UNUSED8,
 	FRA_TABLE,	/* Extended table id */
 	FRA_FWMASK,	/* mask for netfilter mark */
+/* CONFIG INTERPEAK >>> */
+	FRA_PROTOCOL     = 32,
+	FRA_SCOPE,
+	FRA_PKTRULE,
+	FRA_PKTMASK,
+	FRA_EXTACT,
+	FRA_VR,
+	FRA_ID,
+/* <<< CONFIG INTERPEAK */
 	__FRA_MAX
 };
 
diff --git a/include/linux/if.h b/include/linux/if.h
index 5c9d1fa..ccbbf33 100644
--- a/include/linux/if.h
+++ b/include/linux/if.h
@@ -177,6 +177,15 @@ struct ifreq
 		char	ifru_newname[IFNAMSIZ];
 		void __user *	ifru_data;
 		struct	if_settings ifru_settings;
+		/* CONFIG INTERPEAK >>> */
+		/* IPNET extensions */
+		/* Assign the interface to a specific virtual router */
+		__u16   ifru_vr;
+		/* Get/set the cost of using this interface */
+		__u32   ifru_metric;
+		/* Get the public interface index */
+		__u32   ifru_ifindex;
+		/* <<< CONFIG INTERPEAK */
 	} ifr_ifru;
 };
 
diff --git a/include/linux/if_addr.h b/include/linux/if_addr.h
index 43f3bed..8548075 100644
--- a/include/linux/if_addr.h
+++ b/include/linux/if_addr.h
@@ -29,6 +29,12 @@ enum
 	IFA_ANYCAST,
 	IFA_CACHEINFO,
 	IFA_MULTICAST,
+/* CONFIG_INTERPEAK >>> */
+	IFA_VR = 32,
+	IFA_TABLE,
+	IFA_TABLE_NAME,
+	IFA_X_INFO,
+/* <<< CONFIG_INTERPEAK */
 	__IFA_MAX,
 };
 
diff --git a/include/linux/if_arp.h b/include/linux/if_arp.h
index 4d34018..dd25063 100644
--- a/include/linux/if_arp.h
+++ b/include/linux/if_arp.h
@@ -87,6 +87,9 @@
 #define ARPHRD_IEEE80211_PRISM 802	/* IEEE 802.11 + Prism2 header  */
 #define ARPHRD_IEEE80211_RADIOTAP 803	/* IEEE 802.11 + radiotap header */
 
+/* CONFIG INTERPEAK >>> */
+#define ARPHRD_MPLS_TUNNEL 131          /* MPLS tunnel interface        */
+/* <<< CONFIG INTERPEAK */
 #define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known */
 #define ARPHRD_NONE	  0xFFFE	/* zero header length */
 
diff --git a/include/linux/if_link.h b/include/linux/if_link.h
index 84c3492..0ef978f 100644
--- a/include/linux/if_link.h
+++ b/include/linux/if_link.h
@@ -79,6 +79,9 @@ enum
 	IFLA_LINKINFO,
 #define IFLA_LINKINFO IFLA_LINKINFO
 	IFLA_NET_NS_PID,
+/* CONFIG_INTERPEAK >>> */
+	IFLA_VR = 32,
+/* <<< CONFIG_INTERPEAK */
 	__IFLA_MAX
 };
 
diff --git a/include/linux/in.h b/include/linux/in.h
index 4065313..10d76ac 100644
--- a/include/linux/in.h
+++ b/include/linux/in.h
@@ -76,6 +76,14 @@ struct in_addr {
 #define IP_XFRM_POLICY	17
 #define IP_PASSSEC	18
 
+/* CONFIG INTERPEAK >>> */
+#define IP_DONTFRAG 22
+#define IP_UDP_X_CHKSUM 40
+#define IP_NEXTHOP 52
+#define IP_X_SENDERLINKADDR 100
+#define IP_X_VRID 101
+/* <<< CONFIG INTERPEAK */
+
 /* BSD compatibility */
 #define IP_RECVRETOPTS	IP_RETOPTS
 
diff --git a/include/linux/neighbour.h b/include/linux/neighbour.h
index bd3bbf6..ee5586a 100644
--- a/include/linux/neighbour.h
+++ b/include/linux/neighbour.h
@@ -21,6 +21,12 @@ enum
 	NDA_LLADDR,
 	NDA_CACHEINFO,
 	NDA_PROBES,
+	/* CONFIG INTERPEAK >>> */
+	NDA_VR = 32,
+	NDA_TABLE,
+	NDA_TABLE_NAME,
+	NDA_REALIFINDEX,
+	/* <<< CONFIG INTERPEAK */
 	__NDA_MAX
 };
 
@@ -32,6 +38,9 @@ enum
 
 #define NTF_PROXY	0x08	/* == ATF_PUBL */
 #define NTF_ROUTER	0x80
+/* CONFIG INTERPEAK >>>*/
+#define NTF_GRAT    0x10
+/* <<< CONFIG INTERPEAK */
 
 /*
  *	Neighbor Cache Entry States.
diff --git a/include/linux/net.h b/include/linux/net.h
index 6dc14a2..b17129d 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -58,6 +58,10 @@ typedef enum {
 #include <linux/wait.h>
 #include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
 
+#ifdef CONFIG_INTERPEAK
+#include <linux/fs.h>
+#endif
+
 struct poll_table_struct;
 struct pipe_inode_info;
 struct inode;
@@ -187,6 +191,15 @@ struct proto_ops {
 				      int offset, size_t size, int flags);
 	ssize_t 	(*splice_read)(struct socket *sock,  loff_t *ppos,
 				       struct pipe_inode_info *pipe, size_t len, unsigned int flags);
+#ifdef CONFIG_INTERPEAK
+       struct sk_buff * (*skb_recv_datagram)(struct sock *sk, unsigned flags,
+					     int noblock, int *err);
+       int              (*skb_tcp_data_recv)(struct sock *sk, read_descriptor_t *rdesc,
+					     int (*recv_actor)(read_descriptor_t *r,
+							       struct sk_buff *skb,
+							       unsigned int offset ,
+							       size_t len));
+#endif
 };
 
 struct net_proto_family {
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 488c56e..5650061 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -749,6 +749,11 @@ struct net_device
 	/* for setting kernel sock attribute on TCP connection setup */
 #define GSO_MAX_SIZE		65536
 	unsigned int		gso_max_size;
+
+#ifdef CONFIG_INTERPEAK
+    /* for mapping a net device to a certain VR */
+    __u16 vr;
+#endif
 };
 #define to_net_dev(d) container_of(d, struct net_device, dev)
 
diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 9ff1b54..c0497ff 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -168,6 +168,9 @@ struct netlink_skb_parms
 	__u32			loginuid;	/* Login (audit) uid */
 	__u32			sessionid;	/* Session id (audit) */
 	__u32			sid;		/* SELinux security id */
+#ifdef CONFIG_INTERPEAK
+	__u32                   vr;
+#endif
 };
 
 #define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))
diff --git a/include/linux/notifier.h b/include/linux/notifier.h
index da2698b..ee3ce3a 100644
--- a/include/linux/notifier.h
+++ b/include/linux/notifier.h
@@ -199,6 +199,10 @@ static inline int notifier_to_errno(int ret)
 #define NETDEV_FEAT_CHANGE	0x000B
 #define NETDEV_BONDING_FAILOVER 0x000C
 
+/* CONFIG INTERPEAK >>> */
+#define NETDEV_CHANGEFLAG	0x000D
+/* <<< CONFIG INTERPEAK */
+
 #define SYS_DOWN	0x0001	/* Notify of system down */
 #define SYS_RESTART	SYS_DOWN
 #define SYS_HALT	0x0002	/* Notify of system halt */
diff --git a/include/linux/proc_fs.h b/include/linux/proc_fs.h
index fb61850..0465c44 100644
--- a/include/linux/proc_fs.h
+++ b/include/linux/proc_fs.h
@@ -195,6 +195,9 @@ static inline struct proc_dir_entry *create_proc_read_entry(const char *name,
 extern struct proc_dir_entry *proc_net_fops_create(struct net *net,
 	const char *name, mode_t mode, const struct file_operations *fops);
 extern void proc_net_remove(struct net *net, const char *name);
+#ifdef CONFIG_INTERPEAK
+extern void do_proc_net_remove(struct net *net, const char *name);
+#endif
 extern struct proc_dir_entry *proc_net_mkdir(struct net *net, const char *name,
 	struct proc_dir_entry *parent);
 
diff --git a/include/linux/rtnetlink.h b/include/linux/rtnetlink.h
index ca643b1..6f5ea04 100644
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -107,6 +107,16 @@ enum {
 	RTM_GETADDRLABEL,
 #define RTM_GETADDRLABEL RTM_GETADDRLABEL
 
+    /* CONFIG INTERPEAK >>> */
+    RTM_NEWVR       = 100,
+#define RTM_NEWVR RTM_NEWVR
+    RTM_DELVR,
+#define RTM_DELVR RTM_DELVR
+    RTM_GETVR,
+#define RTM_GETVR RTM_GETVR
+    RTM_CHANGEVR,
+#define RTM_CHANGEVR RTM_CHANGEVR
+    /* <<< CONFIG INTERPEAK */
 	__RTM_MAX,
 #define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
 };
@@ -181,6 +191,10 @@ enum
 	RTN_THROW,		/* Not in this table		*/
 	RTN_NAT,		/* Translate this address	*/
 	RTN_XRESOLVE,		/* Use external resolver	*/
+	/* CONFIG INTERPEAK >>> */
+	RTN_PROXY = 32,              /* Proxy ARP route */
+	RTN_CLONE,              /* Cloning route */
+	/* <<< CONFIG INTERPEAK */
 	__RTN_MAX
 };
 
@@ -274,6 +288,19 @@ enum rtattr_type_t
 	RTA_SESSION, /* no longer used */
 	RTA_MP_ALGO, /* no longer used */
 	RTA_TABLE,
+
+	/* CONFIG INTERPEAK >>> */
+	/* unsigned long. Used for MPLS shortcut routes */
+	RTA_NH_PROTO = 32,
+	/* unsigned long. Used for MPLS shortcut routes */
+	RTA_NH_PROTO_DATA,
+	/* 6 * unsigned char. For storing MAC address in proxy arp routes */
+	RTA_PROXY_ARP_LLADDR,
+	/* unsigned long. Virtual router index. */
+	RTA_VR,
+	/* string (max 16 characters). Route table name */
+	RTA_TABLE_NAME,
+	/* <<< CONFIG INTERPEAK */
 	__RTA_MAX
 };
 
@@ -282,6 +309,13 @@ enum rtattr_type_t
 #define RTM_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct rtmsg))))
 #define RTM_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct rtmsg))
 
+/* CONFIG INTERPEAK >>> */
+
+/* Used as NH_PROTO specifier for MPLS shortcut routes */
+#define NH_PROTO_MPLS 0x8847
+
+/* <<< CONFIG INTERPEAK */
+
 /* RTM_MULTIPATH --- array of struct rtnexthop.
  *
  * "struct rtnexthop" describes all necessary nexthop information,
@@ -445,6 +479,9 @@ enum
 	PREFIX_UNSPEC,
 	PREFIX_ADDRESS,
 	PREFIX_CACHEINFO,
+    /* CONFIG_INTERPEAK >>> */
+    PREFIX_VR = 16,
+    /* <<< CONFIG_INTERPEAK */
 	__PREFIX_MAX
 };
 
@@ -537,6 +574,10 @@ enum
 #define RTMGRP_DECnet_IFADDR    0x1000
 #define RTMGRP_DECnet_ROUTE     0x4000
 
+/* CONFIG INTERPEAK >>> */
+#define RTMGRP_RTAB             RTNLGRP_RTAB
+/* <<< CONFIG INTERPEAK */
+
 #define RTMGRP_IPV6_PREFIX	0x20000
 #endif
 
@@ -575,7 +616,7 @@ enum rtnetlink_groups {
 #define RTNLGRP_DECnet_ROUTE	RTNLGRP_DECnet_ROUTE
 	RTNLGRP_DECnet_RULE,
 #define RTNLGRP_DECnet_RULE	RTNLGRP_DECnet_RULE
-	RTNLGRP_NOP4,
+	RTNLGRP_RTAB,
 	RTNLGRP_IPV6_PREFIX,
 #define RTNLGRP_IPV6_PREFIX	RTNLGRP_IPV6_PREFIX
 	RTNLGRP_IPV6_RULE,
@@ -598,6 +639,45 @@ struct tcamsg
 #define TCA_ACT_TAB 1 /* attr type must be >=1 */	
 #define TCAA_MAX 1
 
+/* CONFIG INTERPEAK >>> */
+/* VR attributes */
+struct vrmsg
+{
+    unsigned char vr_family;
+    unsigned char  __vr_pad1;
+    unsigned short __vr_pad2;
+    unsigned long vr_vr;
+};
+
+enum vrattr_type_t
+{
+    VR_UNSPEC,
+    VR_VR,
+    VR_IFNAME,
+    VR_TABLE,
+    VR_TABLE_NAME,
+    VR_IFNAMES,
+    VR_TABLES,
+    __VR_MAX
+};
+#define VR_MAX (__VR_MAX - 1)
+
+enum vrxattr_type_t
+{
+    VRX_UNSPEC,
+    VRX_IFNAME,
+    VRX_TABLE,
+    VRX_TABLE_NAME,
+    __VRX_MAX
+};
+
+#define VRX_MAX (__VRX_MAX - 1)
+#define VR_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct vrmsg))))
+#define VR_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct vrmsg))
+
+/* <<< CONFIG INTERPEAK */
+
+
 /* End of information exported to user level */
 
 #ifdef __KERNEL__
diff --git a/include/linux/sched.h b/include/linux/sched.h
index cfb0d87..e7405c6 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1301,6 +1301,12 @@ struct task_struct {
 	int latency_record_count;
 	struct latency_record latency_record[LT_SAVECOUNT];
 #endif
+#ifdef CONFIG_INTERPEAK
+	unsigned short  vr;  /* Virtual router */
+        void *proc;
+        void (*proc_destruct)(void *proc);
+#endif
+
 };
 
 /*
diff --git a/include/linux/semaphore.h b/include/linux/semaphore.h
index 7415839..c780676 100644
--- a/include/linux/semaphore.h
+++ b/include/linux/semaphore.h
@@ -44,6 +44,10 @@ extern int __must_check down_interruptible(struct semaphore *sem);
 extern int __must_check down_killable(struct semaphore *sem);
 extern int __must_check down_trylock(struct semaphore *sem);
 extern int __must_check down_timeout(struct semaphore *sem, long jiffies);
+
+#ifdef CONFIG_INTERPEAK
+extern int __must_check down_timeout_interruptible(struct semaphore *sem, long jiffies);
+#endif
 extern void up(struct semaphore *sem);
 
 #endif /* __LINUX_SEMAPHORE_H */
diff --git a/include/linux/socket.h b/include/linux/socket.h
index dc5086f..af309c9 100644
--- a/include/linux/socket.h
+++ b/include/linux/socket.h
@@ -190,7 +190,13 @@ struct ucred {
 #define AF_IUCV		32	/* IUCV sockets			*/
 #define AF_RXRPC	33	/* RxRPC sockets 		*/
 #define AF_ISDN		34	/* mISDN sockets 		*/
-#define AF_MAX		35	/* For now.. */
+
+/*  CONFIG INTERPEAK >>> */
+#define AF_IPROUTE      35      /* Interpeak Route sockets */
+#define AF_MPLS         36
+#define AF_LINK         37
+#define AF_MAX		38	/* For now.. */
+/* <<< CONFIG INTERPEAK */
 
 /* Protocol families, same as address families. */
 #define PF_UNSPEC	AF_UNSPEC
@@ -227,6 +233,11 @@ struct ucred {
 #define PF_IUCV		AF_IUCV
 #define PF_RXRPC	AF_RXRPC
 #define PF_ISDN		AF_ISDN
+/*  CONFIG INTERPEAK >>> */
+#define PF_IPROUTE      AF_IPROUTE
+#define PF_MPLS         AF_MPLS
+#define PF_LINK         AF_LINK
+/* <<< CONFIG INTERPEAK */
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
diff --git a/include/linux/sockios.h b/include/linux/sockios.h
index abef759..f4d7bf2 100644
--- a/include/linux/sockios.h
+++ b/include/linux/sockios.h
@@ -29,6 +29,55 @@
 #define SIOCDELRT	0x890C		/* delete routing table entry	*/
 #define SIOCRTMSG	0x890D		/* call to routing system	*/
 
+/*  CONFIG INTERPEAK >>> */
+
+/* Add virtual router (unsigned long) */
+#define SIOCADDVR             0x8986
+
+/* Delete virtual router (unsigned long) */
+#define SIOCDELVR             0x8987
+
+ /* Add a table to a virtual router (struct sioc_route_table) */
+#define SIOCADDTABLE      0x00d00001
+
+ /* Add a route table to a virtual router (struct sioc_route_table) */
+#define SIOCADDROUTETAB   0x00d00001
+
+ /* Delete a table from a virtual router (struct sioc_route_table) */
+#define SIOCDELTABLE      0x00d00002
+
+ /* Delete a route table to a virtual router (struct sioc_route_table) */
+#define SIOCDELROUTETAB   0x00d00002
+
+ /* Get/create a route table by name (struct sioc_route_table) */
+#define SIOCGETROUTETAB   0x00d00003
+
+ /* Set a name for a route table. (struct sioc_route_table) */
+#define SIOCSROUTETABNAME 0x00d00004
+
+ /* Mapps a route table name to VR and table ID (struct sioc_route_table) */
+#define SIOCGROUTETABNAME 0x00d00005
+
+ /* Get the virtual router index for an interface (struct ifreq) */
+#define SIOCGIFVR         0x00300001
+
+ /* Set an interface to a specific virtual router (struct ifreq) */
+#define SIOCSIFVR         0x00300002
+
+ /* Get a policy routing rule */
+#define SIOCGPRRULE       0x00f00001
+
+ /* Set a policy routing rule */
+#define SIOCSPRRULE       0x00f00002
+
+ /* Delete a policy routing rule */
+#define SIOCDPRRULE       0x00f00003
+
+ /* Enumerate policy routing rules */
+#define SIOCEPRRULE       0x00f00004
+
+/* <<< CONFIG INTERPEAK */
+
 /* Socket configuration controls. */
 #define SIOCGIFNAME	0x8910		/* get iface name		*/
 #define SIOCSIFLINK	0x8911		/* set iface channel		*/
diff --git a/include/net/rtnetlink.h b/include/net/rtnetlink.h
index 3c1895e..5766de5 100644
--- a/include/net/rtnetlink.h
+++ b/include/net/rtnetlink.h
@@ -12,8 +12,17 @@ extern int	__rtnl_register(int protocol, int msgtype,
 extern void	rtnl_register(int protocol, int msgtype,
 			      rtnl_doit_func, rtnl_dumpit_func);
 extern int	rtnl_unregister(int protocol, int msgtype);
+
 extern void	rtnl_unregister_all(int protocol);
 
+#ifdef CONFIG_INTERPEAK
+extern void	rtnl_do_register(int protocol, int msgtype,
+				 rtnl_doit_func, rtnl_dumpit_func);
+extern int	rtnl_do_unregister(int protocol, int msgtype);
+extern void	rtnl_do_unregister_all(int protocol);
+extern int      rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb);
+#endif /* CONFIG_INTERPEAK */
+
 static inline int rtnl_msg_family(struct nlmsghdr *nlh)
 {
 	if (nlmsg_len(nlh) >= sizeof(struct rtgenmsg))
diff --git a/include/net/sock.h b/include/net/sock.h
index 06c5259..3039f83 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -279,6 +279,10 @@ struct sock {
   	int			(*sk_backlog_rcv)(struct sock *sk,
 						  struct sk_buff *skb);  
 	void                    (*sk_destruct)(struct sock *sk);
+#ifdef CONFIG_INTERPEAK
+    /* for mapping a socket to a certain VR (SO_VR setting)*/
+    int              sk_vr;
+#endif
 };
 
 /*
diff --git a/include/net/udp.h b/include/net/udp.h
index addcdc6..c3196f9 100644
--- a/include/net/udp.h
+++ b/include/net/udp.h
@@ -179,7 +179,11 @@ DECLARE_SNMP_STAT(struct udp_mib, udplite_stats_in6);
 			UDP6_INC_STATS_BH(sock_net(sk), field, 0); \
 	} while (0);
 #else
+#ifdef CONFIG_INTERPEAK
+#define UDPX_INC_STATS_BH(sk, field)
+#else
 #define UDPX_INC_STATS_BH(sk, field) UDP_INC_STATS_BH(sock_net(sk), field, 0)
+#endif /* CONFIG_INTERPEAK */
 #endif
 
 /* /proc */
diff --git a/kernel/fork.c b/kernel/fork.c
index 7ce2ebe..8c2aa36 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -135,6 +135,10 @@ void free_task(struct task_struct *tsk)
 	prop_local_destroy_single(&tsk->dirties);
 	free_thread_info(tsk->stack);
 	rt_mutex_debug_task_free(tsk);
+#ifdef CONFIG_INTERPEAK
+    if (tsk->proc && tsk->proc_destruct)
+        tsk->proc_destruct(tsk->proc);
+#endif
 	free_task_struct(tsk);
 }
 EXPORT_SYMBOL(free_task);
@@ -162,6 +166,17 @@ void __put_task_struct(struct task_struct *tsk)
 #define arch_task_cache_init()
 #endif
 
+
+#ifdef CONFIG_INTERPEAK
+void do_put_task_struct(struct task_struct *tsk)
+{
+    __put_task_struct(tsk);
+}
+
+EXPORT_SYMBOL(do_put_task_struct);
+#endif
+
+
 void __init fork_init(unsigned long mempages)
 {
 #ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
@@ -232,7 +247,10 @@ static struct task_struct *dup_task_struct(struct task_struct *orig)
 		goto out;
 
 	setup_thread_stack(tsk, orig);
-
+#ifdef CONFIG_INTERPEAK
+    tsk->proc = NULL;
+    tsk->proc_destruct = NULL;
+#endif
 #ifdef CONFIG_CC_STACKPROTECTOR
 	tsk->stack_canary = get_random_int();
 #endif
diff --git a/kernel/sched.c b/kernel/sched.c
index 9a1ddb8..a11840d 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -4876,6 +4876,14 @@ int can_nice(const struct task_struct *p, const int nice)
 
 #ifdef __ARCH_WANT_SYS_NICE
 
+#ifdef CONFIG_INTERPEAK
+int do_set_cpus_allowed(struct task_struct *p, cpumask_t new_mask)
+{
+	return set_cpus_allowed(p, new_mask);
+}
+EXPORT_SYMBOL(do_set_cpus_allowed);
+#endif
+
 /*
  * sys_nice - change the priority of the current process.
  * @increment: priority increment
diff --git a/kernel/semaphore.c b/kernel/semaphore.c
index 94a62c0..fa2e1dd 100644
--- a/kernel/semaphore.c
+++ b/kernel/semaphore.c
@@ -168,6 +168,24 @@ int down_timeout(struct semaphore *sem, long jiffies)
 }
 EXPORT_SYMBOL(down_timeout);
 
+#ifdef CONFIG_INTERPEAK
+int down_timeout_interruptible(struct semaphore *sem, long jiffies)
+{
+	unsigned long flags;
+	int result = 0;
+
+	spin_lock_irqsave(&sem->lock, flags);
+	if (likely(sem->count > 0))
+		sem->count--;
+	else
+		result = __down_timeout(sem, jiffies);
+	spin_unlock_irqrestore(&sem->lock, flags);
+
+	return result;
+}
+EXPORT_SYMBOL(down_timeout_interruptible);
+#endif
+
 /**
  * up - release the semaphore
  * @sem: the semaphore to release
@@ -253,6 +271,13 @@ static noinline int __sched __down_timeout(struct semaphore *sem, long jiffies)
 	return __down_common(sem, TASK_UNINTERRUPTIBLE, jiffies);
 }
 
+#ifdef CONFIG_INTERPEAK
+static noinline int __sched __down_timeout_interruptible(struct semaphore *sem, long jiffies)
+{
+	return __down_common(sem, TASK_INTERRUPTIBLE, jiffies);
+}
+#endif
+
 static noinline void __sched __up(struct semaphore *sem)
 {
 	struct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 4048e92..9af7961 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -750,6 +750,9 @@ int current_is_keventd(void)
 	return ret;
 
 }
+#ifdef CONFIG_INTERPEAK
+EXPORT_SYMBOL(current_is_keventd);
+#endif
 
 static struct cpu_workqueue_struct *
 init_cpu_workqueue(struct workqueue_struct *wq, int cpu)
diff --git a/net/Kconfig b/net/Kconfig
index 7612cc8..0b8f9c1 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -36,9 +36,11 @@ source "net/packet/Kconfig"
 source "net/unix/Kconfig"
 source "net/xfrm/Kconfig"
 source "net/iucv/Kconfig"
+source "net/Kconfig.interpeak"
 
 config INET
-	bool "TCP/IP networking"
+	bool "Use native TCP/IP networking"
+	depends on !INTERPEAK
 	---help---
 	  These are the protocols used on the Internet and on most local
 	  Ethernets. It is highly recommended to say Y here (this will enlarge
diff --git a/net/Kconfig.ipfirewall b/net/Kconfig.ipfirewall
new file mode 100644
index 0000000..ff8c725
--- /dev/null
+++ b/net/Kconfig.ipfirewall
@@ -0,0 +1,2 @@
+#This file is empty when ipipsec has not been configured
+
diff --git a/net/Kconfig.ipipsec b/net/Kconfig.ipipsec
new file mode 100644
index 0000000..ff8c725
--- /dev/null
+++ b/net/Kconfig.ipipsec
@@ -0,0 +1,2 @@
+#This file is empty when ipipsec has not been configured
+
diff --git a/net/Kconfig.ipmcrypto b/net/Kconfig.ipmcrypto
new file mode 100644
index 0000000..31c2854
--- /dev/null
+++ b/net/Kconfig.ipmcrypto
@@ -0,0 +1,2 @@
+#This file is empty when ipmcrypto has not been configured
+
diff --git a/net/core/datagram.c b/net/core/datagram.c
index 52f577a..5f5c338 100644
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@ -156,6 +156,12 @@ struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
 	if (error)
 		goto no_packet;
 
+#ifdef CONFIG_INTERPEAK
+	if (sk && sk->sk_socket->ops->skb_recv_datagram
+	    && ((sk->sk_family == AF_INET) || (sk->sk_family == AF_INET6)))
+	  return sk->sk_socket->ops->skb_recv_datagram(sk, flags, *peeked, err);
+#endif
+
 	timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 
 	do {
diff --git a/net/core/dev.c b/net/core/dev.c
index 60c51f7..7765dfa 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -596,9 +596,13 @@ struct net_device *__dev_get_by_name(struct net *net, const char *name)
 	hlist_for_each(p, dev_name_hash(net, name)) {
 		struct net_device *dev
 			= hlist_entry(p, struct net_device, name_hlist);
-		if (!strncmp(dev->name, name, IFNAMSIZ))
+		if (!strncmp(dev->name, name, IFNAMSIZ)) {
+#ifdef CONFIG_INTERPEAK
+			if (dev->vr == current->vr)
+#endif
 			return dev;
 	}
+	}
 	return NULL;
 }
 
@@ -1296,8 +1300,11 @@ static inline void net_timestamp(struct sk_buff *skb)
  *	Support routine. Sends outgoing frames to any network
  *	taps currently in use.
  */
-
+#ifdef CONFIG_INTERPEAK
+void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev)
+#else
 static void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev)
+#endif
 {
 	struct packet_type *ptype;
 
@@ -1337,6 +1344,10 @@ static void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev)
 	}
 	rcu_read_unlock();
 }
+#ifdef CONFIG_INTERPEAK
+EXPORT_SYMBOL(dev_queue_xmit_nit);
+#endif
+
 
 
 static inline void __netif_reschedule(struct Qdisc *q)
@@ -2006,6 +2017,39 @@ static inline int deliver_skb(struct sk_buff *skb,
 	return pt_prev->func(skb, skb->dev, pt_prev, orig_dev);
 }
 
+#ifdef CONFIG_INTERPEAK
+void dev_ptype_pcap(struct sk_buff *skb, struct net_device *dev)
+{
+	struct packet_type *ptype;
+	__be16 type;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(ptype, &ptype_all, list) {
+		if (!ptype->dev || ptype->dev == skb->dev) {
+			if (skb->pkt_type != PACKET_OUTGOING ||
+			    (ptype->af_packet_priv == NULL ||
+			     (struct sock *)ptype->af_packet_priv !=
+			     skb->sk)) {
+				deliver_skb(skb, ptype, skb->dev);
+			}
+		}
+	}
+
+	if (skb->pkt_type != PACKET_OUTGOING) {
+		type = skb->protocol;
+		list_for_each_entry_rcu(ptype,
+					&ptype_base[ntohs(type)&15], list) {
+			if (!ptype->dev || ptype->dev == skb->dev) {
+				deliver_skb(skb, ptype, skb->dev);
+			}
+		}
+	}
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL(dev_ptype_pcap);
+#endif
+
+
 #if defined(CONFIG_BRIDGE) || defined (CONFIG_BRIDGE_MODULE)
 /* These hooks defined here for ATM */
 struct net_bridge;
@@ -2576,6 +2620,12 @@ static void dev_seq_printf_stats(struct seq_file *seq, struct net_device *dev)
 {
 	struct net_device_stats *stats = dev->get_stats(dev);
 
+#ifdef CONFIG_INTERPEAK
+  /* Only show interfaces that are in callers VR. */
+	if (dev->vr != current->vr)
+		return;
+#endif
+
 	seq_printf(seq, "%6s:%8lu %7lu %4lu %4lu %4lu %5lu %10lu %9lu "
 		   "%8lu %7lu %4lu %4lu %4lu %5lu %7lu %10lu\n",
 		   dev->name, stats->rx_bytes, stats->rx_packets,
@@ -3368,6 +3418,9 @@ int dev_change_flags(struct net_device *dev, unsigned flags)
 		int inc = (flags & IFF_PROMISC) ? +1 : -1;
 		dev->gflags ^= IFF_PROMISC;
 		dev_set_promiscuity(dev, inc);
+#ifdef CONFIG_INTERPEAK
+		raw_notifier_call_chain(&netdev_chain, NETDEV_CHANGEFLAG, dev);
+#endif
 	}
 
 	/* NOTE: order of synchronization of IFF_PROMISC and IFF_ALLMULTI
@@ -3779,6 +3832,9 @@ int dev_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 			return -EINVAL;
 	}
 }
+#ifdef CONFIG_INTERPEAK
+EXPORT_SYMBOL(dev_ioctl);
+#endif
 
 
 /**
@@ -3944,7 +4000,11 @@ int register_netdevice(struct net_device *dev)
 	hlist_for_each(p, head) {
 		struct net_device *d
 			= hlist_entry(p, struct net_device, name_hlist);
-		if (!strncmp(d->name, dev->name, IFNAMSIZ)) {
+		if (!strncmp(d->name, dev->name, IFNAMSIZ)
+#ifdef CONFIG_INTERPEAK
+		    && (d->vr == dev->vr)
+#endif
+		    ) {
 			ret = -EEXIST;
 			goto err_uninit;
 		}
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index c1f4e0d..1604f3b 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -442,6 +442,11 @@ void netdev_unregister_kobject(struct net_device * net)
 	kobject_get(&dev->kobj);
 	device_del(dev);
 }
+#ifdef CONFIG_INTERPEAK
+EXPORT_SYMBOL(netdev_unregister_kobject);
+#endif
+
+
 
 /* Create sysfs entries for network device. */
 int netdev_register_kobject(struct net_device *net)
@@ -454,6 +459,12 @@ int netdev_register_kobject(struct net_device *net)
 	dev->groups = groups;
 
 	BUILD_BUG_ON(BUS_ID_SIZE < IFNAMSIZ);
+
+#ifdef CONFIG_INTERPEAK
+	if (net->vr)
+		snprintf(dev->bus_id, BUS_ID_SIZE, "%s#%d", net->name, net->vr);
+	else
+#endif
 	strlcpy(dev->bus_id, net->name, BUS_ID_SIZE);
 
 #ifdef CONFIG_SYSFS
@@ -467,6 +478,11 @@ int netdev_register_kobject(struct net_device *net)
 
 	return device_add(dev);
 }
+#ifdef CONFIG_INTERPEAK
+EXPORT_SYMBOL(netdev_register_kobject);
+#endif
+
+
 
 int netdev_class_create_file(struct class_attribute *class_attr)
 {
diff --git a/net/core/netpoll.c b/net/core/netpoll.c
index 6c7af39..e1d5618 100644
--- a/net/core/netpoll.c
+++ b/net/core/netpoll.c
@@ -744,6 +744,33 @@ int netpoll_setup(struct netpoll *np)
 	}
 
 	if (!np->local_ip) {
+#ifdef CONFIG_INTERPEAK
+		struct ifreq       ifr;
+		struct sockaddr_in *sin;
+		struct socket      *sock;
+
+		if (sock_create_kern(AF_INET, SOCK_DGRAM,
+				     IPPROTO_UDP, &sock) < 0) {
+			printk(KERN_ERR "%s: Failed to create kern socket\n",
+			       np->name);
+			goto release;
+		}
+
+		strcpy(ifr.ifr_name, np->dev_name);
+
+		if (kernel_sock_ioctl(sock, SIOCGIFADDR, &ifr) < 0) {
+			printk(KERN_ERR "%s: Failed to get IP address for %s\n",
+			       np->name, np->dev_name);
+			sock_release(sock);
+			goto release;
+		}
+
+		sock_release(sock);
+
+		sin = &ifr.ifr_addr;
+
+		np->local_ip = ntohl(sin->sin_addr.s_addr);
+#else
 		rcu_read_lock();
 		in_dev = __in_dev_get_rcu(ndev);
 
@@ -757,6 +784,7 @@ int netpoll_setup(struct netpoll *np)
 
 		np->local_ip = ntohl(in_dev->ifa_list->ifa_local);
 		rcu_read_unlock();
+#endif
 		printk(KERN_INFO "%s: local IP %d.%d.%d.%d\n",
 		       np->name, HIPQUAD(np->local_ip));
 	}
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 71edb8b..0055383 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -191,6 +191,16 @@ void rtnl_register(int protocol, int msgtype,
 
 EXPORT_SYMBOL_GPL(rtnl_register);
 
+#ifdef CONFIG_INTERPEAK
+void rtnl_do_register(int protocol, int msgtype,
+		   rtnl_doit_func doit, rtnl_dumpit_func dumpit)
+{
+        return rtnl_register(protocol, msgtype, doit, dumpit);
+}
+
+EXPORT_SYMBOL(rtnl_do_register);
+#endif /* CONFIG_INTERPEAK */
+
 /**
  * rtnl_unregister - Unregister a rtnetlink message type
  * @protocol: Protocol family or PF_UNSPEC
@@ -216,6 +226,16 @@ int rtnl_unregister(int protocol, int msgtype)
 
 EXPORT_SYMBOL_GPL(rtnl_unregister);
 
+
+#ifdef CONFIG_INTERPEAK
+int rtnl_do_unregister(int protocol, int msgtype)
+{
+       return rtnl_unregister(protocol, msgtype);
+}
+
+EXPORT_SYMBOL(rtnl_do_unregister);
+#endif /* CONFIG_INTERPEAK */
+
 /**
  * rtnl_unregister_all - Unregister all rtnetlink message type of a protocol
  * @protocol : Protocol family or PF_UNSPEC
@@ -233,6 +253,15 @@ void rtnl_unregister_all(int protocol)
 
 EXPORT_SYMBOL_GPL(rtnl_unregister_all);
 
+#ifdef CONFIG_INTERPEAK
+void rtnl_do_unregister_all(int protocol)
+{
+  return rtnl_do_unregister_all(protocol);
+}
+
+EXPORT_SYMBOL(rtnl_do_unregister_all);
+#endif /* CONFIG_INTERPEAK */
+
 static LIST_HEAD(link_ops);
 
 /**
@@ -401,7 +430,12 @@ static const int rtm_min[RTM_NR_FAMILIES] =
 	[RTM_FAM(RTM_NEWLINK)]      = NLMSG_LENGTH(sizeof(struct ifinfomsg)),
 	[RTM_FAM(RTM_NEWADDR)]      = NLMSG_LENGTH(sizeof(struct ifaddrmsg)),
 	[RTM_FAM(RTM_NEWROUTE)]     = NLMSG_LENGTH(sizeof(struct rtmsg)),
+#ifdef CONFIG_INTERPEAK
+	[RTM_FAM(RTM_NEWNEIGH)]     = NLMSG_LENGTH(sizeof(struct ndmsg)),
+	[RTM_FAM(RTM_NEWRULE)]      = NLMSG_LENGTH(sizeof(struct rtmsg)),
+#else
 	[RTM_FAM(RTM_NEWRULE)]      = NLMSG_LENGTH(sizeof(struct fib_rule_hdr)),
+#endif /* CONFIG_INTERPEAK */
 	[RTM_FAM(RTM_NEWQDISC)]     = NLMSG_LENGTH(sizeof(struct tcmsg)),
 	[RTM_FAM(RTM_NEWTCLASS)]    = NLMSG_LENGTH(sizeof(struct tcmsg)),
 	[RTM_FAM(RTM_NEWTFILTER)]   = NLMSG_LENGTH(sizeof(struct tcmsg)),
@@ -415,7 +449,12 @@ static const int rta_max[RTM_NR_FAMILIES] =
 	[RTM_FAM(RTM_NEWLINK)]      = IFLA_MAX,
 	[RTM_FAM(RTM_NEWADDR)]      = IFA_MAX,
 	[RTM_FAM(RTM_NEWROUTE)]     = RTA_MAX,
+#ifdef CONFIG_INTERPEAK
+	[RTM_FAM(RTM_NEWNEIGH)]     = NDA_MAX,
+	[RTM_FAM(RTM_NEWRULE)]      = RTA_MAX,
+#else
 	[RTM_FAM(RTM_NEWRULE)]      = FRA_MAX,
+#endif /* CONFIG_INTERPEAK */
 	[RTM_FAM(RTM_NEWQDISC)]     = TCA_MAX,
 	[RTM_FAM(RTM_NEWTCLASS)]    = TCA_MAX,
 	[RTM_FAM(RTM_NEWTFILTER)]   = TCA_MAX,
@@ -447,6 +486,9 @@ int rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, unsigned group
 		err = netlink_unicast(rtnl, skb, pid, MSG_DONTWAIT);
 	return err;
 }
+#ifdef CONFIG_INTERPEAK
+EXPORT_SYMBOL(rtnetlink_send);
+#endif
 
 int rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid)
 {
@@ -670,6 +712,10 @@ static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
 			goto nla_put_failure;
 	}
 
+#ifdef CONFIG_INTERPEAK
+	NLA_PUT(skb, IFLA_VR, sizeof(dev->vr), &dev->vr);
+#endif
+
 	return nlmsg_end(skb, nlh);
 
 nla_put_failure:
@@ -688,6 +734,13 @@ static int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)
 	for_each_netdev(net, dev) {
 		if (idx < s_idx)
 			goto cont;
+
+#ifdef CONFIG_INTERPEAK
+		/* Only show interfaces that are in callers VR */
+		if ((NETLINK_CB(skb).vr >= 0)
+		    && (dev->vr != NETLINK_CB(skb).vr))
+		  goto cont;
+#endif
 		if (rtnl_fill_ifinfo(skb, dev, RTM_NEWLINK,
 				     NETLINK_CB(cb->skb).pid,
 				     cb->nlh->nlmsg_seq, 0, NLM_F_MULTI) <= 0)
@@ -1189,7 +1242,11 @@ errout:
 	return err;
 }
 
+#ifdef CONFIG_INTERPEAK
+int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)
+#else
 static int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)
+#endif /* CONFIG_INTERPEAK */
 {
 	int idx;
 	int s_idx = cb->family;
@@ -1213,6 +1270,10 @@ static int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)
 	return skb->len;
 }
 
+#ifdef CONFIG_INTERPEAK
+EXPORT_SYMBOL(rtnl_dump_all);
+#endif
+
 void rtmsg_ifinfo(int type, struct net_device *dev, unsigned change)
 {
 	struct net *net = dev_net(dev);
@@ -1230,6 +1291,11 @@ void rtmsg_ifinfo(int type, struct net_device *dev, unsigned change)
 		kfree_skb(skb);
 		goto errout;
 	}
+
+#ifdef CONFIG_INTERPEAK
+	NETLINK_CB(skb).vr = dev->vr;
+#endif
+
 	err = rtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_KERNEL);
 errout:
 	if (err < 0)
diff --git a/net/core/sock.c b/net/core/sock.c
index 91f8bbc..af3c8e6 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -445,6 +445,12 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 	struct linger ling;
 	int ret = 0;
 
+#ifdef CONFIG_INTERPEAK
+	if (sock->ops->setsockopt(sock, level, optname,
+				  optval, optlen) == 0)
+		return 0;
+#endif
+
 	/*
 	 *	Options without arguments
 	 */
@@ -633,7 +639,15 @@ set_rcvbuf:
 	case SO_SNDTIMEO:
 		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
 		break;
-
+#ifdef CONFIG_INTERPEAK
+	case SO_VR:
+	        sk->sk_vr = val;
+	        break;
+	case SO_PERMVR:
+		if (val > 0)
+		  current->vr = (unsigned short)val;
+		break;
+#endif
 	case SO_ATTACH_FILTER:
 		ret = -EINVAL;
 		if (optlen == sizeof(struct sock_fprog)) {
@@ -690,6 +704,12 @@ int sock_getsockopt(struct socket *sock, int level, int optname,
 	unsigned int lv = sizeof(int);
 	int len;
 
+#ifdef CONFIG_INTERPEAK
+	if (sock->ops->getsockopt(sock, level, optname,
+				  optval, optlen) == 0)
+	  return 0;
+#endif
+
 	if (get_user(len, optlen))
 		return -EFAULT;
 	if (len < 0)
@@ -1738,6 +1758,9 @@ void sock_init_data(struct socket *sock, struct sock *sk)
 
 	sk->sk_stamp = ktime_set(-1L, 0);
 
+#ifdef CONFIG_INTERPEAK
+	sk->sk_vr = current->vr;
+#endif
 	atomic_set(&sk->sk_refcnt, 1);
 	atomic_set(&sk->sk_drops, 0);
 }
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index b0eacc0..4379cd3 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -965,6 +965,10 @@ static inline int do_one_broadcast(struct sock *sk,
 	if (!net_eq(sock_net(sk), p->net))
 		goto out;
 
+#ifdef CONFIG_INTERPEAK
+	if ((sk->sk_vr > -1) && (sk->sk_vr != NETLINK_CB(p->skb).vr))
+		goto out;
+#endif
 	if (p->failure) {
 		netlink_overrun(sk);
 		goto out;
@@ -1250,6 +1254,9 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	NETLINK_CB(skb).dst_group = dst_group;
 	NETLINK_CB(skb).loginuid = audit_get_loginuid(current);
 	NETLINK_CB(skb).sessionid = audit_get_sessionid(current);
+#ifdef CONFIG_INTERPEAK
+	NETLINK_CB(skb).vr  = sk->sk_vr;
+#endif
 	security_task_getsecid(current, &(NETLINK_CB(skb).sid));
 	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));
 
@@ -1532,6 +1539,10 @@ static int netlink_dump(struct sock *sk)
 	if (!skb)
 		goto errout;
 
+#ifdef CONFIG_INTERPEAK
+	NETLINK_CB(skb).vr  = sk->sk_vr;
+#endif
+
 	mutex_lock(nlk->cb_mutex);
 
 	cb = nlk->cb;
diff --git a/net/socket.c b/net/socket.c
index 8ef8ba8..bdabb2a 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -895,6 +895,7 @@ static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)
 				err = br_ioctl_hook(net, cmd, argp);
 			mutex_unlock(&br_ioctl_mutex);
 			break;
+#ifndef CONFIG_INTERPEAK
 		case SIOCGIFVLAN:
 		case SIOCSIFVLAN:
 			err = -ENOPKG;
@@ -906,6 +907,7 @@ static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)
 				err = vlan_ioctl_hook(net, argp);
 			mutex_unlock(&vlan_ioctl_mutex);
 			break;
+#endif /* CONFIG_INTERPEAK */
 		case SIOCADDDLCI:
 		case SIOCDELDLCI:
 			err = -ENOPKG;
diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index 3e65719..fc6feb3 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -52,9 +52,14 @@
 
 #define RPCDBG_FACILITY	RPCDBG_SVCXPRT
 
-
+#ifdef CONFIG_INTERPEAK
+static struct svc_sock *svc_setup_socket(struct svc_serv *, struct socket *,
+					 unsigned short port, int *errp,
+					 int flags);
+#else
 static struct svc_sock *svc_setup_socket(struct svc_serv *, struct socket *,
 					 int *errp, int flags);
+#endif
 static void		svc_udp_data_ready(struct sock *, int);
 static int		svc_udp_recvfrom(struct svc_rqst *);
 static int		svc_udp_sendto(struct svc_rqst *);
@@ -333,14 +338,20 @@ static int svc_recvfrom(struct svc_rqst *rqstp, struct kvec *iov, int nr,
 static void svc_sock_setbufsize(struct socket *sock, unsigned int snd,
 				unsigned int rcv)
 {
-#if 0
+#ifdef CONFIG_INTERPEAK
+	/*
+	 * Necessary to use setsockopts to make ipnet
+	 * aware of the buffer sizes
+	 */
 	mm_segment_t	oldfs;
+
 	oldfs = get_fs(); set_fs(KERNEL_DS);
 	sock_setsockopt(sock, SOL_SOCKET, SO_SNDBUF,
 			(char*)&snd, sizeof(snd));
 	sock_setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
 			(char*)&rcv, sizeof(rcv));
-#else
+	set_fs(oldfs);
+#endif
 	/* sock_setsockopt limits use to sysctl_?mem_max,
 	 * which isn't acceptable.  Until that is made conditional
 	 * on not having CAP_SYS_RESOURCE or similar, we go direct...
@@ -351,7 +362,6 @@ static void svc_sock_setbufsize(struct socket *sock, unsigned int snd,
 	sock->sk->sk_rcvbuf = rcv * 2;
 	sock->sk->sk_userlocks |= SOCK_SNDBUF_LOCK|SOCK_RCVBUF_LOCK;
 	release_sock(sock->sk);
-#endif
 }
 /*
  * INET callback when data has been received on the socket.
@@ -434,6 +444,9 @@ static int svc_udp_recvfrom(struct svc_rqst *rqstp)
 	int		err, len;
 	struct msghdr msg = {
 		.msg_name = svc_addr(rqstp),
+#ifdef CONFIG_INTERPEAK
+		.msg_namelen = sizeof(struct sockaddr_storage),
+#endif
 		.msg_control = cmh,
 		.msg_controllen = sizeof(buffer),
 		.msg_flags = MSG_DONTWAIT,
@@ -763,8 +776,17 @@ static struct svc_xprt *svc_tcp_accept(struct svc_xprt *xprt)
 	 */
 	newsock->sk->sk_sndtimeo = HZ*30;
 
+#ifdef CONFIG_INTERPEAK
+	if (!(newsvsk =
+	      svc_setup_socket(serv,
+			       newsock,
+			       ntohs(((struct sockaddr_in*)sin)->sin_port),
+			       &err,
+			       (SVC_SOCK_ANONYMOUS | SVC_SOCK_TEMPORARY))))
+#else
 	if (!(newsvsk = svc_setup_socket(serv, newsock, &err,
 				 (SVC_SOCK_ANONYMOUS | SVC_SOCK_TEMPORARY))))
+#endif
 		goto failed;
 	svc_xprt_set_remote(&newsvsk->sk_xprt, sin, slen);
 	err = kernel_getsockname(newsock, sin, &slen);
@@ -884,7 +906,12 @@ static int svc_tcp_recvfrom(struct svc_rqst *rqstp)
 	pnum = 1;
 	while (vlen < len) {
 		vec[pnum].iov_base = page_address(rqstp->rq_pages[pnum]);
+#ifdef CONFIG_INTERPEAK
+		vec[pnum].iov_len =
+			vlen + PAGE_SIZE < len ? PAGE_SIZE : len - vlen;
+#else
 		vec[pnum].iov_len = PAGE_SIZE;
+#endif
 		pnum++;
 		vlen += PAGE_SIZE;
 	}
@@ -1107,14 +1134,40 @@ EXPORT_SYMBOL(svc_sock_update_bufs);
  * Initialize socket for RPC use and create svc_sock struct
  * XXX: May want to setsockopt SO_SNDBUF and SO_RCVBUF.
  */
+#ifdef CONFIG_INTERPEAK
+static struct svc_sock *svc_setup_socket(struct svc_serv *serv,
+						struct socket *sock,
+						unsigned short port,
+						int *errp, int flags)
+#else
 static struct svc_sock *svc_setup_socket(struct svc_serv *serv,
 						struct socket *sock,
 						int *errp, int flags)
+#endif
 {
 	struct svc_sock	*svsk;
 	struct sock	*inet;
 	int		pmap_register = !(flags & SVC_SOCK_ANONYMOUS);
 
+#ifdef CONFIG_INTERPEAK
+	if (port == 0) {
+	        size_t sz = sizeof(struct sockaddr_in);
+		struct sockaddr_in sin;
+
+		/* At least NFS lockd lets the stack decide the port to bind
+		   to. Need to get that port number */
+
+		*errp = sock->ops->getname(sock,
+					   (struct sockaddr *)&sin,
+					   &sz, 0);
+
+		if (*errp < 0)
+		  return NULL;
+
+		port = ntohs(sin.sin_port);
+	}
+#endif /* CONFIG_INTERPEAK */
+
 	dprintk("svc: svc_setup_socket %p\n", sock);
 	if (!(svsk = kzalloc(sizeof(*svsk), GFP_KERNEL))) {
 		*errp = -ENOMEM;
@@ -1125,9 +1178,12 @@ static struct svc_sock *svc_setup_socket(struct svc_serv *serv,
 
 	/* Register socket with portmapper */
 	if (*errp >= 0 && pmap_register)
+#ifdef CONFIG_INTERPEAK
+		*errp = svc_register(serv, inet->sk_protocol, port);
+#else
 		*errp = svc_register(serv, inet->sk_protocol,
 				     ntohs(inet_sk(inet)->sport));
-
+#endif
 	if (*errp < 0) {
 		kfree(svsk);
 		return NULL;
@@ -1171,7 +1227,11 @@ int svc_addsock(struct svc_serv *serv,
 	else if (so->state > SS_UNCONNECTED)
 		err = -EISCONN;
 	else {
+#ifdef CONFIG_INTERPEAK
+		svsk = svc_setup_socket(serv, so, 0, &err, SVC_SOCK_DEFAULTS);
+#else
 		svsk = svc_setup_socket(serv, so, &err, SVC_SOCK_DEFAULTS);
+#endif
 		if (svsk) {
 			struct sockaddr_storage addr;
 			struct sockaddr *sin = (struct sockaddr *)&addr;
@@ -1245,7 +1305,16 @@ static struct svc_xprt *svc_create_socket(struct svc_serv *serv,
 			goto bummer;
 	}
 
+#ifdef CONFIG_INTERPEAK
+	if ((svsk =
+	     svc_setup_socket(serv,
+			      sock,
+			      ntohs(((struct sockaddr_in*)sin)->sin_port),
+			      &error,
+			      flags)) != NULL) {
+#else
 	if ((svsk = svc_setup_socket(serv, sock, &error, flags)) != NULL) {
+#endif
 		svc_xprt_set_local(&svsk->sk_xprt, newsin, newlen);
 		return (struct svc_xprt *)svsk;
 	}
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 4486c59..afa3c5b 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -1096,7 +1096,17 @@ static void xs_tcp_data_ready(struct sock *sk, int bytes)
 	rd_desc.arg.data = xprt;
 	do {
 		rd_desc.count = 65536;
+#ifdef CONFIG_INTERPEAK
+		if (sk && sk->sk_socket->ops->skb_tcp_data_recv
+		    && ((sk->sk_family == AF_INET) || (sk->sk_family == AF_INET6)))
+		  read = sk->sk_socket->ops->skb_tcp_data_recv(sk,
+							       &rd_desc,
+							       xs_tcp_data_recv);
+		else
+		  read = 0;
+#else
 		read = tcp_read_sock(sk, &rd_desc, xs_tcp_data_recv);
+#endif
 	} while (read > 0);
 out:
 	read_unlock(&sk->sk_callback_lock);
@@ -1600,10 +1610,12 @@ static int xs_tcp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)
 
 		/* socket options */
 		sk->sk_userlocks |= SOCK_BINDPORT_LOCK;
+#ifndef CONFIG_INTERPEAK
 		sock_reset_flag(sk, SOCK_LINGER);
 		tcp_sk(sk)->linger2 = 0;
 		tcp_sk(sk)->nonagle |= TCP_NAGLE_OFF;
 
+#endif /* CONFIG_INTERPEAK */
 		xprt_clear_connected(xprt);
 
 		/* Reset to new socket */
@@ -1611,6 +1623,23 @@ static int xs_tcp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)
 		transport->inet = sk;
 
 		write_unlock_bh(&sk->sk_callback_lock);
+
+#ifdef CONFIG_INTERPEAK
+		{
+			struct linger l;
+
+			l.l_onoff  = 1;
+			l.l_linger = 0;
+
+			/* We need to set linger via a setsockopt */
+			(void)sock->ops->setsockopt(sock,
+						    SOL_SOCKET,
+						    SO_LINGER,
+						    (char*)&l,
+						    sizeof(l));
+		}
+#endif /* CONFIG_INTERPEAK */
+
 	}
 
 	/* Tell the socket layer to start connecting... */
@@ -1636,6 +1665,21 @@ static void xs_tcp_connect_worker4(struct work_struct *work)
 	if (xprt->shutdown || !xprt_bound(xprt))
 		goto out;
 
+#ifdef CONFIG_INTERPEAK
+	if (sock) {
+		/*
+		 * IPNET does not allow reuse of a previously connected +
+		 * disconnected socket, since this is a violation of the
+		 * tcp socket standard.
+		 * We need to close this socket and create a new one.
+		 */
+		sock_release(sock);
+
+		sock = NULL;
+		transport->inet = NULL;
+	}
+#endif /* CONFIG_INTERPEAK */
+
 	if (!sock) {
 		/* start from scratch */
 		if ((err = sock_create_kern(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock)) < 0) {
@@ -1696,6 +1740,21 @@ static void xs_tcp_connect_worker6(struct work_struct *work)
 	if (xprt->shutdown || !xprt_bound(xprt))
 		goto out;
 
+#ifdef CONFIG_INTERPEAK
+	if (sock) {
+		/*
+		 * IPNET does not allow reuse of a previously connected +
+		 * disconnected socket, since this is a violation of the
+		 * tcp socket standard.
+		 * We need to close this socket and create a new one.
+		 */
+		sock_release(sock);
+
+		sock = NULL;
+		transport->inet = NULL;
+	}
+#endif /* CONFIG_INTERPEAK */
+
 	if (!sock) {
 		/* start from scratch */
 		if ((err = sock_create_kern(PF_INET6, SOCK_STREAM, IPPROTO_TCP, &sock)) < 0) {
diff --git a/net/xfrm/Kconfig b/net/xfrm/Kconfig
index 6d08167..efa40f9 100644
--- a/net/xfrm/Kconfig
+++ b/net/xfrm/Kconfig
@@ -54,6 +54,7 @@ config XFRM_IPCOMP
 
 config NET_KEY
 	tristate "PF_KEY sockets"
+	depends on INET
 	select XFRM
 	---help---
 	  PF_KEYv2 socket family, compatible to KAME ones.
-- 
1.5.6

