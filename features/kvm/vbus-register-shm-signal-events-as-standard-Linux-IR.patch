From da17cec90a44cb0d6d9fe56edd1ee76a8a8556cb Mon Sep 17 00:00:00 2001
From: Gregory Haskins <ghaskins@novell.com>
Date: Tue, 13 Oct 2009 19:44:18 -0400
Subject: [PATCH 069/119] vbus: register shm-signal events as standard Linux IRQ vectors

This will allow us to view the vector statistics in a uniform way, as
well as pave the way for supporting irqbalance in the future.

The VBUS PCI-BRIDGE will present itself as an irqchip device to the
kernel proper.

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---
 drivers/vbus/Kconfig      |    4 +-
 drivers/vbus/pci-bridge.c |   91 +++++++++++++++++++++++++++++++++++---------
 2 files changed, 74 insertions(+), 21 deletions(-)

diff --git a/drivers/vbus/Kconfig b/drivers/vbus/Kconfig
index 08667aa..f51cba1 100644
--- a/drivers/vbus/Kconfig
+++ b/drivers/vbus/Kconfig
@@ -3,7 +3,7 @@
 #
 
 config VBUS_PROXY
-       tristate "Virtual-Bus support"
+       bool "Virtual-Bus support"
        select SHM_SIGNAL
        select IOQ
        default n
@@ -14,7 +14,7 @@ config VBUS_PROXY
 	on the backend, say Y.  If unsure, say N.
 
 config VBUS_PCIBRIDGE
-       tristate "PCI to Virtual-Bus bridge"
+       bool "PCI to Virtual-Bus bridge"
        depends on PCI
        depends on VBUS_PROXY
        select IOQ
diff --git a/drivers/vbus/pci-bridge.c b/drivers/vbus/pci-bridge.c
index fa77318..fcde495 100644
--- a/drivers/vbus/pci-bridge.c
+++ b/drivers/vbus/pci-bridge.c
@@ -147,15 +147,14 @@ _signal_init(struct shm_signal *signal, struct shm_signal_desc *desc,
  */
 
 struct _signal {
+	char               name[64];
 	struct vbus_pci   *pcivbus;
 	struct shm_signal  signal;
 	u32                handle;
 	struct rb_node     node;
 	struct list_head   list;
-	struct {
-		int        notify;
-		int        inject;
-	} stats;
+	int                irq;
+	struct irq_desc   *desc;
 };
 
 static struct _signal *
@@ -170,7 +169,6 @@ _signal_inject(struct shm_signal *signal)
 	struct _signal *_signal = to_signal(signal);
 
 	vbus_pci.stats.inject++;
-	_signal->stats.inject++;
 	iowrite32(_signal->handle, &vbus_pci.signals->shmsignal);
 
 	return 0;
@@ -236,6 +234,7 @@ vbus_pci_device_close(struct vbus_device_proxy *vdev, int flags)
 		_signal = list_first_entry(&dev->shms, struct _signal, list);
 
 		list_del(&_signal->list);
+		free_irq(_signal->irq, _signal);
 
 		spin_unlock_irqrestore(&vbus_pci.lock, iflags);
 		shm_signal_put(&_signal->signal);
@@ -261,6 +260,27 @@ vbus_pci_device_close(struct vbus_device_proxy *vdev, int flags)
 	return 0;
 }
 
+static void vbus_irq_chip_noop(unsigned int irq)
+{
+}
+
+static struct irq_chip vbus_irq_chip = {
+	.name		= "VBUS",
+	.mask		= vbus_irq_chip_noop,
+	.unmask		= vbus_irq_chip_noop,
+	.eoi		= vbus_irq_chip_noop,
+};
+
+irqreturn_t
+shm_signal_intr(int irq, void *dev)
+{
+	struct _signal *_signal = (struct _signal *)dev;
+
+	_shm_signal_wakeup(&_signal->signal);
+
+	return IRQ_HANDLED;
+}
+
 static int
 vbus_pci_device_shm(struct vbus_device_proxy *vdev, const char *name,
 		    int id, int prio,
@@ -315,24 +335,45 @@ vbus_pci_device_shm(struct vbus_device_proxy *vdev, const char *name,
 
 	ret = vbus_pci_buscall(VBUS_PCI_HC_DEVSHM,
 				 &params, sizeof(params));
-	if (ret < 0) {
-		if (_signal) {
-			/*
-			 * We held two references above, so we need to drop
-			 * both of them
-			 */
-			shm_signal_put(&_signal->signal);
-			shm_signal_put(&_signal->signal);
-		}
-
-		return ret;
-	}
+	if (ret < 0)
+		goto fail;
 
 	if (signal) {
+		int irq;
+
 		BUG_ON(ret < 0);
 
 		_signal->handle = ret;
 
+		irq = create_irq();
+		if (irq < 0) {
+			printk(KERN_ERR "Failed to create IRQ: %d\n", irq);
+			ret = -ENOSPC;
+			goto fail;
+		}
+
+		_signal->irq = irq;
+		_signal->desc = irq_to_desc(irq);
+
+		set_irq_chip_and_handler_name(irq,
+					      &vbus_irq_chip,
+					      handle_percpu_irq,
+					      "edge");
+
+		if (!name)
+			snprintf(_signal->name, sizeof(_signal->name),
+				"dev%lld-id%d", vdev->id, id);
+		else
+			snprintf(_signal->name, sizeof(_signal->name),
+				"%s", name);
+
+		ret = request_irq(irq, shm_signal_intr, 0,
+				  _signal->name, _signal);
+		if (ret) {
+			printk(KERN_ERR "Failed to request irq: %d\n", irq);
+			goto fail;
+		}
+
 		spin_lock_irqsave(&vbus_pci.lock, iflags);
 
 		list_add_tail(&_signal->list, &dev->shms);
@@ -344,6 +385,18 @@ vbus_pci_device_shm(struct vbus_device_proxy *vdev, const char *name,
 	}
 
 	return 0;
+
+fail:
+	if (_signal) {
+		/*
+		 * We held two references above, so we need to drop
+		 * both of them
+		 */
+		shm_signal_put(&_signal->signal);
+		shm_signal_put(&_signal->signal);
+	}
+
+	return ret;
 }
 
 static int
@@ -454,10 +507,10 @@ static void
 event_shmsignal(struct vbus_pci_handle_event *event)
 {
 	struct _signal *_signal = (struct _signal *)event->handle;
+	struct irq_desc *desc = _signal->desc;
 
 	vbus_pci.stats.notify++;
-	_signal->stats.notify++;
-	_shm_signal_wakeup(&_signal->signal);
+	desc->handle_irq(_signal->irq, desc);
 }
 
 static void
-- 
1.6.5.2

