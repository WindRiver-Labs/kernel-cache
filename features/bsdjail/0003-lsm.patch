From 8d8735b13fe1a6e8b2f0f6817a274c23dc675977 Mon Sep 17 00:00:00 2001
From: Bruce Ashfield <bruce@windriver.com>
Date: Mon, 24 Mar 2008 11:18:00 -0400
Subject: [PATCH] LSM glue

Insert bdsjail into lsm

Signed-off-by: Bruce Ashfield  <bruce.ashfield@windriver.com>
diff --git a/include/linux/security.h b/include/linux/security.h
index fa58779..cd93437 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1732,6 +1732,7 @@ int security_netlink_recv(struct sk_buff *skb, int cap);
 int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen);
 int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid);
 void security_release_secctx(char *secdata, u32 seclen);
+int security_task_lookup(struct task_struct *p);
 
 #else /* CONFIG_SECURITY */
 struct security_mnt_opts {
@@ -2304,11 +2305,6 @@ static inline void security_task_reparent_to_init(struct task_struct *p)
 
 static inline int security_task_lookup(struct task_struct *p)
 {
-	return security_ops->task_lookup(p);
-}
-
-static inline int security_task_lookup(struct task_struct *p)
-{
 	return 0;
 }
 
diff --git a/security/bsdjail.c b/security/bsdjail.c
index f824b9b..e5db589 100644
--- a/security/bsdjail.c
+++ b/security/bsdjail.c
@@ -1348,6 +1348,10 @@ static int __init bsdjail_init (void)
 
 static void __exit bsdjail_exit (void)
 {
+/* bva: in 2.6.24 the unregister options have been removed, they
+        either need to be reinstated or make the module a one way
+        process */
+#if 0
 	if (secondary) {
 		if (mod_unreg_security (MY_NAME, &bsdjail_security_ops))
 			printk (KERN_INFO "Failure unregistering BSD Jail "
@@ -1360,6 +1364,7 @@ static void __exit bsdjail_exit (void)
 	}
 
 	printk (KERN_INFO "BSD Jail module removed\n");
+#endif
 }
 
 security_initcall (bsdjail_init);
diff --git a/security/security.c b/security/security.c
index 3a4b4f5..7c4f784 100644
--- a/security/security.c
+++ b/security/security.c
@@ -127,6 +127,14 @@ int register_security(struct security_operations *ops)
 
 /* Security operations */
 
+int security_task_lookup(struct task_struct *p)
+{
+	if (security_ops && security_ops->task_lookup)
+		return security_ops->task_lookup(p);
+
+	return 0;
+}
+
 int security_ptrace_may_access(struct task_struct *child, unsigned int mode)
 {
 	return security_ops->ptrace_may_access(child, mode);
