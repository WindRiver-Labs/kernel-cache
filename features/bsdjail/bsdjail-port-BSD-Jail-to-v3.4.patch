From 74f7a34e2730afb899662c6a38c150a6446bfcda Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Mon, 11 Jun 2012 14:10:11 -0700
Subject: [PATCH 5/6] bsdjail: port BSD Jail to v3.4

Update BSD Jail to v3.4 kernel. some notable changes are:

  - Remove module unloading function since security module can't be
    unloaded
  - Restore path_lookup function in namei.c for bsdjail use
  - Since big change in struct vfsmount, include fs/mount.h for
    struct mount and update related functions, like is_jailroot_parent
  - Remove smp_lock.h
  - Update jail_capable to align with the latest declaration
  - Update jail_socket_unix_stream_connect to use struct sock as one
    parameter rather than struct socket
  - Update jail_inode_mknod to use umode_t as one parameter
  - Update jail_task_setrlimit to add struct task_struct parameter
  - Update jail_task_setscheduler to remove obsolete parameters
  - Add NIPQUAD definition

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 fs/namei.c            |    6 ++++
 include/linux/namei.h |    1 +
 security/bsdjail.c    |   75 +++++++++++++++++++++++++------------------------
 3 files changed, 46 insertions(+), 36 deletions(-)

diff --git a/fs/namei.c b/fs/namei.c
index de81292..bc3d325 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1789,6 +1789,12 @@ static int do_path_lookup(int dfd, const char *name,
 	return retval;
 }
 
+int path_lookup(const char *name, unsigned int flags,
+			struct nameidata *nd)
+{
+	return do_path_lookup(AT_FDCWD, name, flags, nd);
+}
+
 int kern_path_parent(const char *name, struct nameidata *nd)
 {
 	return do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, nd);
diff --git a/include/linux/namei.h b/include/linux/namei.h
index 99802c3..21ff218 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -79,6 +79,7 @@ extern int kern_path(const char *, unsigned, struct path *);
 extern struct dentry *kern_path_create(int, const char *, struct path *, int);
 extern struct dentry *user_path_create(int, const char __user *, struct path *, int);
 extern int kern_path_parent(const char *, struct nameidata *);
+extern int path_lookup(const char *, unsigned, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);
 
diff --git a/security/bsdjail.c b/security/bsdjail.c
index 178b1fa..85ee0ae 100644
--- a/security/bsdjail.c
+++ b/security/bsdjail.c
@@ -30,11 +30,14 @@
 #include <linux/inetdevice.h>
 #include <linux/seq_file.h>
 #include <linux/un.h>
-#include <linux/smp_lock.h>
 #include <linux/kref.h>
+#include <linux/shm.h>
+#include <linux/msg.h>
 #include <net/sock.h>
 #include <net/inet_sock.h>
 
+#include "../fs/mount.h"
+
 static int jail_debug = 0;
 module_param(jail_debug, uint, 0600);
 MODULE_PARM_DESC(jail_debug, "Print bsd jail debugging messages.\n");
@@ -100,6 +103,17 @@ struct jail_struct {
 
 #define jail_of(proc) (get_cred_security(__task_cred(proc)))
 
+/*
+ *      Display an IP address in readable format.
+ */
+
+#define NIPQUAD(addr) \
+	((unsigned char *)&addr)[0], \
+	((unsigned char *)&addr)[1], \
+	((unsigned char *)&addr)[2], \
+	((unsigned char *)&addr)[3]
+#define NIPQUAD_FMT "%u.%u.%u.%u"
+
 static void release_jail(struct kref *kref);
 
 /*
@@ -787,13 +801,13 @@ jail_socket_unix_may_send(struct socket *sock, struct socket *other)
 }
 
 static int
-jail_socket_unix_stream_connect(struct socket *sock,
-	      struct socket *other, struct sock *newsk)
+jail_socket_unix_stream_connect(struct sock *sock,
+	      struct sock *other, struct sock *newsk)
 {
 	struct jail_struct *tsec, *ssec;
 
 	tsec = jail_of(current);  /* jail of sending process */
-	ssec = get_sock_security(other->sk);  /* jail of receiver */
+	ssec = get_sock_security(other);  /* jail of receiver */
 
 	if (tsec != ssec)
 		return -EPERM;
@@ -827,16 +841,16 @@ jail_umount(struct vfsmount *mnt, int flags)
  *   load/unload modules
  */
 static int
-jail_capable(struct task_struct *tsk, const struct cred *cred,
+jail_capable(const struct cred *cred, struct user_namespace *ns,
 		int cap, int audit)
 {
 	int rc;
 
-	rc = cap_capable(tsk, cred, cap, audit);
+	rc = cap_capable(cred, ns, cap, audit);
 	if (rc)
 		return rc;
 
-	if (in_jail(tsk)) {
+	if (in_jail(current)) {
 		if (cap == CAP_SYS_NICE)
 			return -EPERM;
 		if (cap == CAP_NET_ADMIN)
@@ -847,7 +861,7 @@ jail_capable(struct task_struct *tsk, const struct cred *cred,
 			return -EPERM;
 	}
 
-	if (cap_is_fs_cap(cap) ? tsk->cred->fsuid == 0 : tsk->cred->euid == 0)
+	if (cap_is_fs_cap(cap) ? cred->fsuid == 0 : cred->euid == 0)
 		return 0;
 	return -EPERM;
 }
@@ -952,7 +966,7 @@ jail_bprm_set_creds(struct linux_binprm *bprm)
  */
 /* TODO: We may want to allow /dev/log, at least... */
 static int
-jail_inode_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+jail_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)
 {
 	if (!in_jail(current))
 		return 0;
@@ -991,8 +1005,10 @@ out:
  */
 static int
 is_jailroot_parent(struct dentry *candidate, struct dentry *root,
-	struct vfsmount *rootmnt)
+	struct vfsmount *mnt)
 {
+	struct mount *rootmnt = container_of(mnt, struct mount, mnt);
+
 	if (candidate == root)
 		return 0;
 
@@ -1006,10 +1022,10 @@ is_jailroot_parent(struct dentry *candidate, struct dentry *root,
 	 * the fs->root mount point. So we must check the parent dir of
 	 * the fs->root mount point.
 	 */
-	if (rootmnt->mnt_root == root && rootmnt->mnt_mountpoint!=root) {
+	if (mnt->mnt_root == root && rootmnt->mnt_mountpoint!=root) {
 		root = rootmnt->mnt_mountpoint;
-		rootmnt = rootmnt->mnt_parent;
-		return is_jailroot_parent(candidate, root, rootmnt);
+		mnt = &rootmnt->mnt_parent->mnt;
+		return is_jailroot_parent(candidate, root, mnt);
 	}
 
 	return 0;
@@ -1138,18 +1154,17 @@ jail_task_kill(struct task_struct *p, struct siginfo *info, int sig, u32 secid)
  * LSM hooks to limit jailed process' abilities to muck with resource
  * limits
  */
-static int jail_task_setrlimit (unsigned int resource, struct rlimit *new_rlim)
+static int jail_task_setrlimit (struct task_struct *tsk, unsigned int resource, struct rlimit *new_rlim)
 {
-	if (!in_jail(current))
+	if (!in_jail(tsk))
 		return 0;
 
 	return -EPERM;
 }
 
-static int jail_task_setscheduler (struct task_struct *p, int policy,
-				    struct sched_param *lp)
+static int jail_task_setscheduler (struct task_struct *p)
 {
-	if (!in_jail(current))
+	if (!in_jail(p))
 		return 0;
 
 	return -EPERM;
@@ -1304,6 +1319,7 @@ jail_sem_semop(struct sem_array *sma, struct sembuf *sops, unsigned nsops,
 }
 
 static struct security_operations bsdjail_security_ops = {
+	.name =				"bsdjail",
 	.ptrace_access_check =		jail_ptrace_access_check,
 	.capable =			jail_capable,
 
@@ -1362,9 +1378,12 @@ static struct security_operations bsdjail_security_ops = {
 	.sem_semop =			jail_sem_semop,
 };
 
-static int __init bsdjail_init (void)
+static __init int bsdjail_init(void)
 {
-	if (register_security (&bsdjail_security_ops)) {
+	if (!security_module_enable(&bsdjail_security_ops))
+		return 0;
+
+	if (register_security(&bsdjail_security_ops)) {
 		printk (KERN_INFO
 			"Failure registering BSD Jail module with the kernel\n");
 		return -EINVAL;
@@ -1374,23 +1393,7 @@ static int __init bsdjail_init (void)
 	return 0;
 }
 
-static void __exit bsdjail_exit (void)
-{
-     /* You cannot unload a LSM. This was removed in the 2.6.24
-	timeframe */
-#if 0
-	if (unregister_security (&bsdjail_security_ops)) {
-		printk (KERN_INFO "Failure unregistering BSD Jail "
-			"module with the kernel\n");
-		return;
-	}
-
-	printk (KERN_INFO "BSD Jail module removed\n");
-#endif
-}
-
 security_initcall (bsdjail_init);
-module_exit (bsdjail_exit);
 
 MODULE_DESCRIPTION("BSD Jail LSM.");
 MODULE_LICENSE("GPL");
-- 
1.7.9.7

