From 0c972cebb6281a5660a47e42c665a36d00404d7a Mon Sep 17 00:00:00 2001
From: Bruce Ashfield <bruce.ashfield@windriver.com>
Date: Wed, 3 Sep 2008 16:19:22 -0400
Subject: [PATCH] port BSD jail to 2.6.27

Update BSD jail to the 2.6/27 security environment. Some
notable changes in the newer mode are:

  - no secondary registration
  - cannot unregister a secondary module
  - inode -> d_entry is required for inode_permissions

Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 fs/proc/base.c           |    2 +-
 include/linux/security.h |    6 +--
 security/bsdjail.c       |  158 +++++++++++++++++++++++-----------------------
 security/commoncap.c     |    1 +
 security/security.c      |   10 +++
 5 files changed, 93 insertions(+), 84 deletions(-)

diff --git a/fs/proc/base.c b/fs/proc/base.c
index c859f6b..ef9b9e2 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -2733,7 +2733,7 @@ retry:
 			goto retry;
 		}
 		get_task_struct(iter.task);
-		if (security_task_lookup(task))
+		if (security_task_lookup(iter.task))
 			goto retry;
 	}
 	rcu_read_unlock();
diff --git a/include/linux/security.h b/include/linux/security.h
index fa58779..cd93437 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1732,6 +1732,7 @@ int security_netlink_recv(struct sk_buff *skb, int cap);
 int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen);
 int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid);
 void security_release_secctx(char *secdata, u32 seclen);
+int security_task_lookup(struct task_struct *p);
 
 #else /* CONFIG_SECURITY */
 struct security_mnt_opts {
@@ -2304,11 +2305,6 @@ static inline void security_task_reparent_to_init(struct task_struct *p)
 
 static inline int security_task_lookup(struct task_struct *p)
 {
-	return security_ops->task_lookup(p);
-}
-
-static inline int security_task_lookup(struct task_struct *p)
-{
 	return 0;
 }
 
diff --git a/security/bsdjail.c b/security/bsdjail.c
index 0d47889..d778ff6 100644
--- a/security/bsdjail.c
+++ b/security/bsdjail.c
@@ -39,8 +39,8 @@ static int jail_debug = 0;
 module_param(jail_debug, uint, 0600);
 MODULE_PARM_DESC(jail_debug, "Print bsd jail debugging messages.\n");
 
-#define DBG 0
-#define WARN 1
+#define BSDJAIL_DBG 0
+#define BSDJAIL_WARN 1
 #define bsdj_debug(how, fmt, arg... ) \
 	do { \
 		if ( how || jail_debug ) \
@@ -51,9 +51,6 @@ MODULE_PARM_DESC(jail_debug, "Print bsd jail debugging messages.\n");
 
 #define MY_NAME "bsdjail"
 
-/* flag to keep track of how we were registered */
-static int secondary = 0;
-
 /*
  * The task structure holding jail information.
  * Taskp->security points to one of these (or is null).
@@ -76,7 +73,7 @@ struct jail_struct {
 	int max_nrtask;		/* maximum number of tasks within this jail. */
 	int cur_nrtask;	/* current number of tasks within this jail. */
 	long maxtimeslice;      /* max timeslice in ms for procs in this jail */
-	long nice;      	/* nice level for processes in this jail */
+	long nice;		/* nice level for processes in this jail */
 	long max_data, max_memlock;  /* equivalent to RLIMIT_{DATA,MEMLOCK} */
 /* values for the jail_flags field */
 #define GOT_NETWORK 1    /* if not set, jail can use any valid net address */
@@ -158,7 +155,7 @@ static void jail_task_free_security(struct task_struct *task)
 		return;
 
 	if (!in_use(tsec)) {
-		/* 
+		/*
 		 * someone did 'echo -n x > /proc/<pid>/attr/exec' but
 		 * then forked before execing.  Nuke the old info.
 		 */
@@ -187,7 +184,7 @@ static inline int
 in_jail(struct task_struct *t)
 {
 	struct jail_struct *tsec = jail_of(t);
-	
+
 	if (tsec && in_use(tsec))
 		return 1;
 
@@ -215,7 +212,7 @@ setup_netaddress(struct jail_struct *tsec)
 		return;
 	tsec->realaddr = htonl((a<<24)|(b<<16)|(c<<8)|d);
 	set_got_network(tsec);
-	bsdj_debug(DBG, "Network set up (%s)\n", tsec->ip_addr_name);
+	bsdj_debug(BSDJAIL_DBG, "Network set up (%s)\n", tsec->ip_addr_name);
 }
 
 /* release_jail:
@@ -225,7 +222,7 @@ setup_netaddress(struct jail_struct *tsec)
 static void release_jail(struct kref *kref)
 {
 	struct jail_struct *tsec;
-	
+
 	tsec = container_of(kref,struct jail_struct,kref);
 	disable_jail(tsec);
 	free_jail(tsec);
@@ -250,7 +247,7 @@ int enable_jail(struct task_struct *tsk)
 	if (!tsec || !tsec->root_pathname)
 		goto out;
 
-	/* 
+	/*
 	 * USE_JAIL_NAMESPACE: could be useful, so that future mounts outside
 	 * the jail don't affect the jail.  But it's not necessary, and
 	 * requires exporting copy_namespace from fs/namespace.c
@@ -260,26 +257,26 @@ int enable_jail(struct task_struct *tsk)
 #define USE_JAIL_NAMESPACE
 	 */
 #ifdef USE_JAIL_NAMESPACE
-	bsdj_debug(DBG, "bsdjail: copying namespace.\n");
+	bsdj_debug(BSDJAIL_DBG, "bsdjail: copying namespace.\n");
 	retval = -EPERM;
 	if (copy_namespaces(CLONE_NEWNS, tsk))
 		goto out;
-	bsdj_debug(DBG, "bsdjail: copied namespace.\n");
+	bsdj_debug(BSDJAIL_DBG, "bsdjail: copied namespace.\n");
 #endif
 
 	/* find our new root directory */
-	bsdj_debug(DBG, "bsdjail: looking up %s\n", tsec->root_pathname);
+	bsdj_debug(BSDJAIL_DBG, "bsdjail: looking up %s\n", tsec->root_pathname);
 	retval = path_lookup(tsec->root_pathname, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &nd);
 	if (retval)
 		goto out;
 
-	bsdj_debug(DBG, "bsdjail: got %s, setting root to it\n", tsec->root_pathname);
+	bsdj_debug(BSDJAIL_DBG, "bsdjail: got %s, setting root to it\n", tsec->root_pathname);
 
 	/* and set the fsroot to it */
-	set_fs_root(tsk->fs, nd.mnt, nd.dentry);
-	set_fs_pwd(tsk->fs, nd.mnt, nd.dentry);
+	set_fs_root(tsk->fs, &nd.path);
+	set_fs_pwd(tsk->fs, &nd.path);
 
-	bsdj_debug(DBG, "bsdjail: root has been set.  Have fun.\n");
+	bsdj_debug(BSDJAIL_DBG, "bsdjail: root has been set.  Have fun.\n");
 
 	/* set up networking */
 	if (tsec->ip_addr_name)
@@ -301,9 +298,9 @@ int enable_jail(struct task_struct *tsk)
 		current->signal->rlim[RLIMIT_CPU].rlim_max = tsec->maxtimeslice;
 	}
 	/* success and end */
-	tsec->mnt = mntget(nd.mnt);
-	tsec->dentry = dget(nd.dentry);
-	path_release(&nd);
+	tsec->mnt = mntget(nd.path.mnt);
+	tsec->dentry = dget(nd.path.dentry);
+	path_put(&nd.path);
 	kref_init(&tsec->kref);
 	set_in_use(tsec);
 
@@ -333,7 +330,7 @@ jail_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
 
 	if (tsec && in_use(tsec))
 		return -EINVAL;  /* let them guess why */
-		
+
 	if (p != current || strcmp(name, "exec"))
 		return -EPERM;
 
@@ -456,23 +453,23 @@ static int print_jail_net_info(struct jail_struct *j, char *buf, int maxcnt)
 static int
 jail_getprocattr(struct task_struct *p, char *name, char **value)
 {
-	struct jail_struct *tsec;
 	int err = 0;
 #if 0 // XXX
+	struct jail_struct *tsec;
 
 	if (in_jail(current)) {
 		if (strcmp(name, "current")==0) {
 			/* provide network info */
-			err = print_jail_net_info(jail_of(current), value,
+			err = print_jail_net_info(jail_of(current), *value,
 				size);
 			return err;
 		}
 		return -EINVAL;  /* let them guess why */
 	}
-		
+
 	if (strcmp(name, "exec") == 0) {
 		/* Print usage some help */
-		err = snprintf(value, size,
+		err = snprintf(*value, size,
 			"Valid keywords:\n"
 			"root    <pathname>\n"
 			"ip      <ip4-addr>\n"
@@ -489,9 +486,9 @@ jail_getprocattr(struct task_struct *p, char *name, char **value)
 
 	tsec = jail_of(p);
 	if (!tsec || !in_use(tsec)) {
-		err = snprintf(value, size, "Not Jailed\n");
+		err = snprintf(*value, size, "Not Jailed\n");
 	} else {
-		err = snprintf(value, size,
+		err = snprintf(*value, size,
 			"Root: %s\nIP: %s\n"
 			"max_nrtask %d current nrtask %d max_timeslice %lu "
 			"nice %lu\n"
@@ -525,7 +522,7 @@ jail_file_send_sigiotask(struct task_struct *tsk, struct fown_struct *fown,
 	if (!in_jail(current))
 		return 0;
 
-        file = (struct file *)((long)fown - offsetof(struct file,f_owner));
+	file = (struct file *)((long)fown - offsetof(struct file,f_owner));
 	tsec = jail_of(tsk);
 	fsec = get_file_security(file);
 
@@ -581,17 +578,39 @@ static void free_inode_security(struct inode *inode)
 	set_inode_security(inode, NULL);
 }
 
-/* 
+/*
+ * LSM ptrace hook:
+ * process in jail may not ptrace process not in the same jail
+ */
+/* static int */
+/* jail_ptrace (struct task_struct *tracer, struct task_struct *tracee) */
+/* { */
+/* 	struct jail_struct *tsec = jail_of(tracer); */
+
+/* 	if (tsec && (tsec->jail_flags & IN_USE)) { */
+/* 		if (tsec == tracee->security) */
+/* 			return 0; */
+/* 		return -EPERM; */
+/* 	} */
+/* 	return 0; */
+/* } */
+
+/*
  * LSM ptrace hook:
  * process in jail may not ptrace process not in the same jail
  */
 static int
-jail_ptrace (struct task_struct *tracer, struct task_struct *tracee)
+jail_ptrace_may_access (struct task_struct *ctp, unsigned int mode)
 {
-	struct jail_struct *tsec = jail_of(tracer);
+	struct jail_struct *tsec = ctp->security;
+	int rc;
+
+	rc = cap_ptrace_may_access(ctp, mode);
+	if (rc != 0)
+		return rc;
 
 	if (tsec && in_use(tsec)) {
-		if (tsec == jail_of(tracee))
+		if (tsec == jail_of(current))
 			return 0;
 		return -EPERM;
 	}
@@ -639,9 +658,9 @@ jail_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
 		return 0;
 
 	if (sin_addr == loopbackaddr || !sin_addr) {
-		bsdj_debug(DBG, "Got a loopback or 0 address\n");
+		bsdj_debug(BSDJAIL_DBG, "Got a loopback or 0 address\n");
 		sin_addr = jailaddr;
-		bsdj_debug(DBG, "Converted to: %u.%u.%u.%u\n", 
+		bsdj_debug(BSDJAIL_DBG, "Converted to: %u.%u.%u.%u\n",
 			NIPQUAD(sin_addr));
 		return 0;
 	}
@@ -764,8 +783,8 @@ jail_socket_unix_stream_connect(struct socket *sock,
 }
 
 static int
-jail_mount(char * dev_name, struct nameidata *nd, char * type,
-                         unsigned long flags, void * data)
+jail_mount(char * dev_name, struct path *path, char * type,
+	   unsigned long flags, void * data)
 {
 	if (in_jail(current))
 		return -EPERM;
@@ -782,7 +801,7 @@ jail_umount(struct vfsmount *mnt, int flags)
 	return 0;
 }
 
-/* 
+/*
  * process in jail may not:
  *   use nice
  *   change network config
@@ -885,7 +904,7 @@ jail_bprm_alloc_security(struct linux_binprm *bprm)
 }
 
 /*
- * Process in jail may not create devices 
+ * Process in jail may not create devices
  * Thanks to Brad Spender for pointing out fifos should be allowed.
  */
 /* TODO: We may want to allow /dev/log, at least... */
@@ -939,7 +958,7 @@ jail_proc_inode_permission(struct inode *inode, int mask,
 				    struct nameidata *nd)
 {
 	struct jail_struct *tsec = jail_of(current);
-	struct dentry *dentry = nd->dentry;
+	struct dentry *dentry = nd->path.dentry;
 	unsigned pid;
 
 	pid = name_to_int(dentry);
@@ -1021,6 +1040,7 @@ static void jail_task_to_inode(struct task_struct *p, struct inode *inode)
 	set_inode_security(inode, tsec);
 }
 
+#if 0
 /*
  * inode_permission:
  * If we are trying to look into certain /proc files from in a jail, we
@@ -1031,21 +1051,12 @@ static void jail_task_to_inode(struct task_struct *p, struct inode *inode)
 static int
 jail_inode_permission(struct inode *inode, int mask,
 				    struct nameidata *nd)
+#else
+static int
+jail_inode_permission(struct inode *inode, int mask )
+#endif
 {
-	struct jail_struct *tsec = jail_of(current);
-
-	if (!tsec || !in_use(tsec))
-		return 0;
-
-	if (!nd)
-		return 0;
-
-	if (nd->dentry &&
-		strcmp(nd->dentry->d_sb->s_type->name, "proc")==0) {
-		return jail_proc_inode_permission(inode, mask, nd);
-
-	}
-
+#if 0
 	if (!(mask&MAY_EXEC))
 		return 0;
 	if (!inode || !S_ISDIR(inode->i_mode))
@@ -1058,7 +1069,7 @@ jail_inode_permission(struct inode *inode, int mask,
 				nd->dentry->d_name.name);
 		return -EPERM;
 	}
-
+#endif
 	return 0;
 }
 
@@ -1097,7 +1108,7 @@ jail_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
 
 /* This probably is not necessary - /proc does not support xattrs? */
 static int
-jail_inode_getxattr(struct dentry *dentry, char *name)
+jail_inode_getxattr(struct dentry *dentry, const char *name)
 {
 	return generic_procpid_check(dentry);
 }
@@ -1290,7 +1301,7 @@ jail_sem_semop(struct sem_array *sma, struct sembuf *sops, unsigned nsops,
 }
 
 static struct security_operations bsdjail_security_ops = {
-	.ptrace  =			jail_ptrace,
+	.ptrace_may_access =		jail_ptrace_may_access,
 	.capable =			jail_capable,
 
 	.task_kill =			jail_task_kill,
@@ -1314,7 +1325,7 @@ static struct security_operations bsdjail_security_ops = {
 	.socket_bind =			jail_socket_bind,
 	.socket_listen =		jail_socket_listen,
 	.socket_post_create =		jail_socket_post_create,
-        .unix_stream_connect =		jail_socket_unix_stream_connect,
+	.unix_stream_connect =		jail_socket_unix_stream_connect,
 	.unix_may_send =		jail_socket_unix_may_send,
 	.sk_free_security =		free_sock_security,
 
@@ -1349,19 +1360,10 @@ static struct security_operations bsdjail_security_ops = {
 
 static int __init bsdjail_init (void)
 {
-	int rc = 0;
-
 	if (register_security (&bsdjail_security_ops)) {
-		printk (KERN_INFO 
+		printk (KERN_INFO
 			"Failure registering BSD Jail module with the kernel\n");
-
-		rc = mod_reg_security(MY_NAME, &bsdjail_security_ops);
-		if (rc < 0) {
-			printk (KERN_INFO "Failure registering BSD Jail "
-				" module with primary security module.\n");
-			return -EINVAL;
-		}
-		secondary = 1;
+		return -EINVAL;
 	}
 	printk (KERN_INFO "BSD Jail module initialized.\n");
 
@@ -1370,18 +1372,18 @@ static int __init bsdjail_init (void)
 
 static void __exit bsdjail_exit (void)
 {
-	if (secondary) {
-		if (mod_unreg_security (MY_NAME, &bsdjail_security_ops))
-			printk (KERN_INFO "Failure unregistering BSD Jail "
-				" module with primary module.\n");
-	} else { 
-		if (unregister_security (&bsdjail_security_ops)) {
-			printk (KERN_INFO "Failure unregistering BSD Jail "
-				"module with the kernel\n");
-		}
+/* bva: in 2.6.24 the unregister options have been removed, they
+	either need to be reinstated or make the module a one way
+	process */
+#if 0
+	if (unregister_security (&bsdjail_security_ops)) {
+		printk (KERN_INFO "Failure unregistering BSD Jail "
+			"module with the kernel\n");
+		return;
 	}
 
 	printk (KERN_INFO "BSD Jail module removed\n");
+#endif
 }
 
 security_initcall (bsdjail_init);
diff --git a/security/commoncap.c b/security/commoncap.c
index e4c4b3f..4dbda24 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -72,6 +72,7 @@ int cap_ptrace_may_access(struct task_struct *child, unsigned int mode)
 		return 0;
 	return -EPERM;
 }
+EXPORT_SYMBOL(cap_ptrace_may_access);
 
 int cap_ptrace_traceme(struct task_struct *parent)
 {
diff --git a/security/security.c b/security/security.c
index 3a4b4f5..3db6714 100644
--- a/security/security.c
+++ b/security/security.c
@@ -124,6 +124,7 @@ int register_security(struct security_operations *ops)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(register_security);
 
 /* Security operations */
 
@@ -869,6 +870,15 @@ void security_release_secctx(char *secdata, u32 seclen)
 }
 EXPORT_SYMBOL(security_release_secctx);
 
+int security_task_lookup(struct task_struct *p)
+{
+	if (security_ops && security_ops->task_lookup)
+		return security_ops->task_lookup(p);
+
+	return 0;
+}
+EXPORT_SYMBOL(security_task_lookup);
+
 #ifdef CONFIG_SECURITY_NETWORK
 
 int security_unix_stream_connect(struct socket *sock, struct socket *other,
-- 
1.5.5.1

