From bbd5ea3bb6dbadaeabf760d2d92b44a0a96affaf Mon Sep 17 00:00:00 2001
From: Bruce Ashfield <bruce.ashfield@windriver.com>
Date: Wed, 3 Sep 2008 16:19:22 -0400
Subject: [PATCH] port BSD jail to 2.6.27

Update BSD jail to the 2.6/27 security environment. Some
notable changes in the newer mode are:

  - no secondary registration
  - cannot unregister a secondary module
  - inode -> d_entry is required for inode_permissions

Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 security/bsdjail.c   |  114 +++++++++++++++++++++++++++----------------------
 security/commoncap.c |    1 +
 security/security.c  |    1 +
 3 files changed, 65 insertions(+), 51 deletions(-)

diff --git a/security/bsdjail.c b/security/bsdjail.c
index e5db589..49dd5e5 100644
--- a/security/bsdjail.c
+++ b/security/bsdjail.c
@@ -37,8 +37,8 @@ static int jail_debug;
 module_param(jail_debug, int, 0);
 MODULE_PARM_DESC(jail_debug, "Print bsd jail debugging messages.\n");
 
-#define DBG 0
-#define WARN 1
+#define BSDJAIL_DBG 0
+#define BSDJAIL_WARN 1
 #define bsdj_debug(how, fmt, arg... ) \
 	do { \
 		if ( how || jail_debug ) \
@@ -49,9 +49,6 @@ MODULE_PARM_DESC(jail_debug, "Print bsd jail debugging messages.\n");
 
 #define MY_NAME "bsdjail"
 
-/* flag to keep track of how we were registered */
-static int secondary;
-
 /*
  * The task structure holding jail information.
  * Taskp->security points to one of these (or is null).
@@ -196,7 +193,7 @@ setup_netaddress(struct jail_struct *tsec)
 			return;
 		tsec->addr4 = htonl((a<<24) | (b<<16) | (c<<8) | d);
 		tsec->jail_flags |= GOT_IPV4;
-		bsdj_debug(DBG, "Network (ipv4) set up (%s)\n",
+		bsdj_debug(BSDJAIL_DBG, "Network (ipv4) set up (%s)\n",
 			tsec->ip4_addr_name);
 	}
 
@@ -216,7 +213,7 @@ setup_netaddress(struct jail_struct *tsec)
 			tsec->addr6.in6_u.u6_addr16[i] = htons(x[i]);
 		}
 		tsec->jail_flags |= GOT_IPV6;
-		bsdj_debug(DBG, "Network (ipv6) set up (%s)\n",
+		bsdj_debug(BSDJAIL_DBG, "Network (ipv6) set up (%s)\n",
 			tsec->ip6_addr_name);
 	}
 }
@@ -383,15 +380,16 @@ static int print_jail_net_info(struct jail_struct *j, char *buf, int maxcnt)
  * A process not in a jail gets hints on starting a jail.
  */
 static int
-jail_getprocattr(struct task_struct *p, char *name, void *value, size_t size)
+jail_getprocattr(struct task_struct *p, char *name, char **value)
 {
 	struct jail_struct *tsec;
 	int err = 0;
+	int size = strlen(*value);
 
 	if (in_jail(current)) {
 		if (strcmp(name, "current") == 0) {
 			/* provide network info */
-			err = print_jail_net_info(current->security, value,
+			err = print_jail_net_info(current->security, *value,
 				size);
 			return err;
 		}
@@ -400,7 +398,7 @@ jail_getprocattr(struct task_struct *p, char *name, void *value, size_t size)
 
 	if (strcmp(name, "exec") == 0) {
 		/* Print usage some help */
-		err = snprintf(value, size,
+		err = snprintf(*value, size,
 			"Valid keywords:\n"
 			"lock\n"
 			"ip      <ip4-addr>\n"
@@ -418,9 +416,9 @@ jail_getprocattr(struct task_struct *p, char *name, void *value, size_t size)
 
 	tsec = p->security;
 	if (!tsec || !(tsec->jail_flags & IN_USE)) {
-		err = snprintf(value, size, "Not Jailed\n");
+		err = snprintf(*value, size, "Not Jailed\n");
 	} else {
-		err = snprintf(value, size,
+		err = snprintf(*value, size,
 			"IPv4: %s\nIPv6: %s\n"
 			"max_nrtask %d current nrtask %d max_timeslice %lu "
 			"nice %lu\n"
@@ -509,13 +507,35 @@ static void free_inode_security(struct inode *inode)
  * LSM ptrace hook:
  * process in jail may not ptrace process not in the same jail
  */
+/* static int */
+/* jail_ptrace (struct task_struct *tracer, struct task_struct *tracee) */
+/* { */
+/* 	struct jail_struct *tsec = tracer->security; */
+
+/* 	if (tsec && (tsec->jail_flags & IN_USE)) { */
+/* 		if (tsec == tracee->security) */
+/* 			return 0; */
+/* 		return -EPERM; */
+/* 	} */
+/* 	return 0; */
+/* } */
+
+/*
+ * LSM ptrace hook:
+ * process in jail may not ptrace process not in the same jail
+ */
 static int
-jail_ptrace (struct task_struct *tracer, struct task_struct *tracee)
+jail_ptrace_may_access (struct task_struct *ctp, unsigned int mode)
 {
-	struct jail_struct *tsec = tracer->security;
+	struct jail_struct *tsec = ctp->security;
+	int rc;
+
+	rc = cap_ptrace_may_access(ctp, mode);
+	if (rc != 0)
+		return rc;
 
 	if (tsec && (tsec->jail_flags & IN_USE)) {
-		if (tsec == tracee->security)
+		if (tsec == current->security)
 			return 0;
 		return -EPERM;
 	}
@@ -549,9 +569,9 @@ static inline int jail_inet4_bind(struct socket *sock, struct sockaddr *address,
 		return 0;
 
 	if (sin_addr == loopbackaddr || !sin_addr) {
-		bsdj_debug(DBG, "Got a loopback or 0 address\n");
+		bsdj_debug(BSDJAIL_DBG, "Got a loopback or 0 address\n");
 		sin_addr = jailaddr;
-		bsdj_debug(DBG, "Converted to: %u.%u.%u.%u\n",
+		bsdj_debug(BSDJAIL_DBG, "Converted to: %u.%u.%u.%u\n",
 			NIPQUAD(sin_addr));
 		return 0;
 	}
@@ -651,7 +671,7 @@ jail_socket_create(int family, int type, int protocol, int kern)
 	return 0;
 }
 
-static void
+static int
 jail_socket_post_create(struct socket *sock, int family, int type,
 	int protocol, int kern)
 {
@@ -661,22 +681,24 @@ jail_socket_post_create(struct socket *sock, int family, int type,
 
 	if (!tsec || kern || !(tsec->jail_flags & IN_USE) ||
 			!(tsec->jail_flags & (GOT_IPV4 | GOT_IPV6)))
-		return;
+		return -1;
 
 	switch(family) {
 		case AF_INET:
 			inet = inet_sk(sock->sk);
 			inet->saddr = tsec->addr4;
+			return 0;
 			break;
 		case AF_INET6:
 			inet6 = inet6_sk(sock->sk);
 			ipv6_addr_copy(&inet6->saddr, &tsec->addr6);
+			return 0;
 			break;
 		default:
 			break;
 	};
 
-	return;
+	return -1;
 }
 
 static int
@@ -779,8 +801,8 @@ jail_socket_unix_stream_connect(struct socket *sock,
 }
 
 static int
-jail_mount(char * dev_name, struct nameidata *nd, char * type,
-                         unsigned long flags, void * data)
+jail_mount(char * dev_name, struct path *path, char * type,
+	   unsigned long flags, void * data)
 {
 	if (in_jail(current))
 		return -EPERM;
@@ -951,7 +973,7 @@ jail_proc_inode_permission(struct inode *inode, int mask,
 				    struct nameidata *nd)
 {
 	struct jail_struct *tsec = current->security;
-	struct dentry *dentry = nd->dentry;
+	struct dentry *dentry = nd->path.dentry;
 	unsigned pid;
 
 	pid = name_to_int(dentry);
@@ -999,6 +1021,7 @@ static void jail_task_to_inode(struct task_struct *p, struct inode *inode)
 	inode->i_security = tsec;
 }
 
+#if 0
 /*
  * inode_permission:
  * If we are trying to look into certain /proc files from in a jail, we
@@ -1007,7 +1030,12 @@ static void jail_task_to_inode(struct task_struct *p, struct inode *inode)
 static int
 jail_inode_permission(struct inode *inode, int mask,
 				    struct nameidata *nd)
+#else
+static int
+jail_inode_permission(struct inode *inode, int mask )
+#endif
 {
+#if 0
 	struct jail_struct *tsec = current->security;
 
 	if (!tsec || !(tsec->jail_flags & IN_USE))
@@ -1016,12 +1044,12 @@ jail_inode_permission(struct inode *inode, int mask,
 	if (!nd)
 		return 0;
 
-	if (nd->dentry &&
-		strcmp(nd->dentry->d_sb->s_type->name, "proc") == 0) {
+	if (nd->path.dentry &&
+		strcmp(nd->path.dentry->d_sb->s_type->name, "proc") == 0) {
 		return jail_proc_inode_permission(inode, mask, nd);
 
 	}
-
+#endif
 	return 0;
 }
 
@@ -1060,14 +1088,15 @@ jail_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
 
 /* This probably is not necessary - /proc does not support xattrs? */
 static int
-jail_inode_getxattr(struct dentry *dentry, char *name)
+jail_inode_getxattr(struct dentry *dentry, const char *name)
 {
 	return generic_procpid_check(dentry);
 }
 
 /* process in jail may not send signal to process not in the same jail */
 static int
-jail_task_kill(struct task_struct *p, struct siginfo *info, int sig)
+jail_task_kill(struct task_struct *p, struct siginfo *info, int sig,
+	       u32 secid)
 {
 	struct jail_struct *tsec = current->security;
 
@@ -1265,7 +1294,7 @@ jail_sysctl(struct ctl_table *table, int op)
 }
 
 static struct security_operations bsdjail_security_ops = {
-	.ptrace  =			jail_ptrace,
+	.ptrace_may_access =		jail_ptrace_may_access,
 	.capable =			jail_capable,
 
 	.task_kill =			jail_task_kill,
@@ -1327,19 +1356,10 @@ static struct security_operations bsdjail_security_ops = {
 
 static int __init bsdjail_init (void)
 {
-	int rc = 0;
-
 	if (register_security (&bsdjail_security_ops)) {
 		printk (KERN_INFO
 			"Failure registering BSD Jail module with the kernel\n");
-
-		rc = mod_reg_security(MY_NAME, &bsdjail_security_ops);
-		if (rc < 0) {
-			printk (KERN_INFO "Failure registering BSD Jail "
-				" module with primary security module.\n");
-			return -EINVAL;
-		}
-		secondary = 1;
+		return -EINVAL;
 	}
 	printk (KERN_INFO "BSD Jail module initialized.\n");
 
@@ -1348,19 +1368,11 @@ static int __init bsdjail_init (void)
 
 static void __exit bsdjail_exit (void)
 {
-/* bva: in 2.6.24 the unregister options have been removed, they
-        either need to be reinstated or make the module a one way
-        process */
 #if 0
-	if (secondary) {
-		if (mod_unreg_security (MY_NAME, &bsdjail_security_ops))
-			printk (KERN_INFO "Failure unregistering BSD Jail "
-				" module with primary module.\n");
-	} else {
-		if (unregister_security (&bsdjail_security_ops)) {
-			printk (KERN_INFO "Failure unregistering BSD Jail "
-				"module with the kernel\n");
-		}
+	if (unregister_security (&bsdjail_security_ops)) {
+		printk (KERN_INFO "Failure unregistering BSD Jail "
+			"module with the kernel\n");
+		return;
 	}
 
 	printk (KERN_INFO "BSD Jail module removed\n");
diff --git a/security/commoncap.c b/security/commoncap.c
index e4c4b3f..4dbda24 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -72,6 +72,7 @@ int cap_ptrace_may_access(struct task_struct *child, unsigned int mode)
 		return 0;
 	return -EPERM;
 }
+EXPORT_SYMBOL(cap_ptrace_may_access);
 
 int cap_ptrace_traceme(struct task_struct *parent)
 {
diff --git a/security/security.c b/security/security.c
index 7c4f784..83472af 100644
--- a/security/security.c
+++ b/security/security.c
@@ -124,6 +124,7 @@ int register_security(struct security_operations *ops)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(register_security);
 
 /* Security operations */
 
-- 
1.6.0.90.g436ed

