From 9f2c34ebb2c6de63d1a05282702f9e9ebfcbcca9 Mon Sep 17 00:00:00 2001
From: wurui <wurui@actions-semi.com>
Date: Mon, 7 Dec 2015 11:01:31 +0800
Subject: [PATCH 01/62] arm: owl: initial support Actions S500 SoC

commit 579a776decc870222c4353ab93913b5dc24605d0 from
https://github.com/xapp-le/kernel.git

Change-Id: Id5feb5381bf1186607a0530987f61dc5a3de17d3

[Meng:
for porting to kernel 4.1.21, modify as below:
1. add clks, gpt and timer@b0020600 node in actduino.dtsi
2. add clock-latency property in cpus node
3. add CPU2, CPU3 node in dts file
4. modify m25p80@0 node in dts file
5. add interrupts property in ethernet@b0310000 node
6. modify MACHINE_START(OWL, "gs705a")
7. modify clock intialization module
8. delete of_i2c_register_devices() in i2c probe()
9. modify pin configure interface
10. using CLOCKSOURCE_OF_DECLARE to initialize timer
]
Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 Documentation/devicetree/bindings/arm/actions.txt  |    7 +
 .../devicetree/bindings/gpio/gpio_actions.txt      |   39 +
 arch/arm/Kconfig                                   |   20 +
 arch/arm/Makefile                                  |    1 +
 arch/arm/boot/dts/Makefile                         |   33 +
 arch/arm/boot/dts/actduino.dtsi                    |  410 +++
 arch/arm/boot/dts/actduino_bubble_gum.dts          | 1246 +++++++
 arch/arm/boot/dts/actduino_bubble_gum_linux.dts    | 1243 +++++++
 arch/arm/boot/dts/actduino_bubble_gum_probatch.dts |  338 ++
 arch/arm/boot/dts/actduino_bubble_gum_sdboot.dts   | 1237 +++++++
 .../boot/dts/actduino_bubble_gum_sdboot_linux.dts  | 1237 +++++++
 arch/arm/boot/dts/actduino_lemaker_guitar.dts      | 1269 +++++++
 .../arm/boot/dts/actduino_lemaker_guitar_linux.dts | 1266 +++++++
 .../boot/dts/actduino_lemaker_guitar_probatch.dts  |  321 ++
 arch/arm/boot/dts/actduino_probatch.dtsi           |  349 ++
 arch/arm/boot/dts/actduino_s500_1080p.dts          | 1210 +++++++
 arch/arm/boot/dts/actduino_s500_720p.dts           | 1210 +++++++
 arch/arm/boot/dts/actduino_s500_lcd_1280x800.dts   | 1248 +++++++
 .../boot/dts/actduino_s500_lcd_1280x800_linux.dts  | 1249 +++++++
 .../boot/dts/actduino_s500_lcd_1280x800_sdboot.dts | 1249 +++++++
 .../actduino_s500_lcd_1280x800_sdboot_linux.dts    | 1249 +++++++
 .../boot/dts/actduino_s500_lcd_1280x800_uvc.dts    | 1250 +++++++
 arch/arm/boot/dts/actduino_s500_lcd_768x1024.dts   | 1247 +++++++
 .../boot/dts/actduino_s500_lcd_768x1024_linux.dts  | 1243 +++++++
 .../boot/dts/actduino_s500_lcd_768x1024_uvc.dts    | 1244 +++++++
 arch/arm/boot/dts/actduino_s500_probatch.dts       |  328 ++
 arch/arm/boot/dts/atm7059a.dtsi                    |  370 +++
 arch/arm/boot/dts/atm7059a_demo_86v.dts            | 1207 +++++++
 arch/arm/boot/dts/atm7059a_demo_86v_costdown.dts   | 1209 +++++++
 .../dts/atm7059a_demo_86v_costdown_wvga_dpi120.dts | 1209 +++++++
 .../dts/atm7059a_demo_86v_costdown_wvga_dpi160.dts | 1209 +++++++
 arch/arm/boot/dts/atm7059a_demo_86v_test.dts       | 1207 +++++++
 arch/arm/boot/dts/atm7059a_evb.dts                 | 1200 +++++++
 arch/arm/boot/dts/atm7059a_hr820ac_8723bs.dts      | 1198 +++++++
 arch/arm/boot/dts/atm7059a_hr820ac_ap6210.dts      | 1206 +++++++
 arch/arm/boot/dts/atm7059c_demo_86v_costdown.dts   | 1199 +++++++
 arch/arm/include/asm/cacheflush.h                  |   21 +
 arch/arm/include/asm/dma-mapping.h                 |   42 +-
 arch/arm/kernel/hw_breakpoint.c                    |   41 +-
 arch/arm/kernel/setup.c                            |    5 +
 arch/arm/kernel/sleep.S                            |   30 +
 arch/arm/kernel/smp_twd.c                          |   22 +-
 arch/arm/kernel/traps.c                            |    7 +
 arch/arm/mach-owl/Kconfig                          |  179 +
 arch/arm/mach-owl/Makefile                         |   19 +
 arch/arm/mach-owl/Makefile.boot                    |    4 +
 arch/arm/mach-owl/board-owl.c                      |  204 ++
 arch/arm/mach-owl/board-owl.h                      |   26 +
 arch/arm/mach-owl/bootafinfo-owl.c                 |  135 +
 arch/arm/mach-owl/bootdev-owl.c                    |  227 ++
 arch/arm/mach-owl/clock-owl.h                      |  472 +++
 arch/arm/mach-owl/clocktree-atm7059.c              | 3472 ++++++++++++++++++++
 arch/arm/mach-owl/clocktree-owl.c                  | 2094 ++++++++++++
 arch/arm/mach-owl/clocktree-owl.h                  |  178 +
 arch/arm/mach-owl/common-owl.c                     |  443 +++
 arch/arm/mach-owl/cpu-owl.c                        |  118 +
 arch/arm/mach-owl/debug-owl.c                      |  489 +++
 arch/arm/mach-owl/dump_stack-owl.c                 |  224 ++
 arch/arm/mach-owl/gpio-owl.c                       |  426 +++
 arch/arm/mach-owl/headsmp-owl.S                    |   83 +
 arch/arm/mach-owl/hotplug-owl.c                    | 1151 +++++++
 arch/arm/mach-owl/hotplug_base-owl.c               |  133 +
 arch/arm/mach-owl/i2c-owl.c                        | 1521 +++++++++
 arch/arm/mach-owl/include/mach/bootafinfo.h        |   24 +
 arch/arm/mach-owl/include/mach/bootdev.h           |   41 +
 .../arm/mach-owl/include/mach/chipid_reg-atm7039.h |   53 +
 arch/arm/mach-owl/include/mach/clkname.h           |  174 +
 arch/arm/mach-owl/include/mach/clkname_priv.h      |   11 +
 arch/arm/mach-owl/include/mach/clock-owl.h         |    7 +
 arch/arm/mach-owl/include/mach/cpu_map-owl.h       |   31 +
 arch/arm/mach-owl/include/mach/debug-macro.S       |   56 +
 arch/arm/mach-owl/include/mach/debug-owl.h         |   19 +
 arch/arm/mach-owl/include/mach/debug.h             |   21 +
 arch/arm/mach-owl/include/mach/display-owl.h       |  247 ++
 arch/arm/mach-owl/include/mach/dsi-owl.h           |   33 +
 arch/arm/mach-owl/include/mach/dss-owl.h           |  597 ++++
 arch/arm/mach-owl/include/mach/dss_user-owl.h      |   95 +
 arch/arm/mach-owl/include/mach/dvfs.h              |   24 +
 arch/arm/mach-owl/include/mach/entry-macro.S       |   85 +
 arch/arm/mach-owl/include/mach/gpio.h              |   41 +
 arch/arm/mach-owl/include/mach/hardware.h          |  134 +
 arch/arm/mach-owl/include/mach/hdmac-owl.h         |  189 ++
 arch/arm/mach-owl/include/mach/irqs.h              |  107 +
 arch/arm/mach-owl/include/mach/isp-owl.h           |  226 ++
 arch/arm/mach-owl/include/mach/iversion.h          |   29 +
 arch/arm/mach-owl/include/mach/kinfo.h             |   54 +
 arch/arm/mach-owl/include/mach/module-owl.h        |  207 ++
 arch/arm/mach-owl/include/mach/power.h             |  154 +
 arch/arm/mach-owl/include/mach/powergate.h         |   38 +
 arch/arm/mach-owl/include/mach/pwm-owl.h           |   14 +
 arch/arm/mach-owl/include/mach/regs_map-atm7039.h  | 2170 ++++++++++++
 arch/arm/mach-owl/include/mach/secure_storage.h    |   41 +
 arch/arm/mach-owl/include/mach/smp.h               |   41 +
 arch/arm/mach-owl/include/mach/spi-owl.h           |   61 +
 arch/arm/mach-owl/include/mach/storage_access.h    |   27 +
 arch/arm/mach-owl/include/mach/timex.h             |   20 +
 arch/arm/mach-owl/include/mach/uncompress.h        |   35 +
 arch/arm/mach-owl/isp_pwd-owl.c                    |  241 ++
 arch/arm/mach-owl/misc-owl.c                       |  134 +
 arch/arm/mach-owl/pinctrl-owl.c                    |  112 +
 arch/arm/mach-owl/pinctrl_common-owl.c             | 1196 +++++++
 arch/arm/mach-owl/pinctrl_common-owl.h             |   62 +
 arch/arm/mach-owl/pinctrl_data-atm7059.c           | 2892 ++++++++++++++++
 arch/arm/mach-owl/pinctrl_data-owl.h               |  147 +
 arch/arm/mach-owl/platsmp-owl.c                    |  223 ++
 arch/arm/mach-owl/pm-owl.c                         | 1004 ++++++
 arch/arm/mach-owl/powergate-owl.c                  |  518 +++
 arch/arm/mach-owl/processor-owl.c                  |  105 +
 arch/arm/mach-owl/secure_storage-owl.c             |  177 +
 arch/arm/mach-owl/serial-owl.c                     | 1802 ++++++++++
 arch/arm/mach-owl/sirq-owl.c                       |  282 ++
 arch/arm/mach-owl/sleep-owl.S                      |  533 +++
 arch/arm/mach-owl/swsusp-owl.S                     |  325 ++
 arch/arm/mach-owl/timer-owl.c                      |  156 +
 arch/arm/mach-owl/user_dump_stack.c                |   78 +
 arch/arm/mach-owl/version-owl.c                    |   99 +
 arch/arm/mm/dma-mapping.c                          |   13 +-
 arch/arm/mm/proc-macros.S                          |    2 +
 arch/arm/mm/proc-v7.S                              |    5 +-
 arch/arm/tools/mach-types                          |    1 +
 drivers/base/Kconfig                               |    2 +-
 drivers/base/dma-contiguous.c                      |    9 +-
 drivers/base/regmap/regmap-irq.c                   |   22 +-
 drivers/clk/clk.c                                  |   48 +
 drivers/staging/android/Kconfig                    |    2 +
 drivers/staging/android/Makefile                   |    1 +
 drivers/staging/android/ion/Kconfig                |    6 +
 drivers/staging/android/ion/Makefile               |    2 +-
 drivers/staging/android/ion/ion.c                  |  281 ++-
 drivers/staging/android/ion/ion.h                  |    9 +
 drivers/staging/android/ion/ion_cma_heap.c         |   62 +-
 drivers/staging/android/ion/ion_priv.h             |    5 +
 drivers/staging/android/ion/owl/Makefile           |    1 +
 drivers/staging/android/ion/owl/ion-owl.c          |  177 +
 drivers/staging/android/lowmem_killer.h            |   74 +
 drivers/staging/android/lowmemorykiller.c          |    8 +
 drivers/staging/android/switch/Kconfig             |   11 +
 drivers/staging/android/switch/Makefile            |    4 +
 drivers/staging/android/switch/switch.h            |   53 +
 drivers/staging/android/switch/switch_class.c      |  174 +
 drivers/staging/android/switch/switch_gpio.c       |  172 +
 drivers/staging/android/uapi/ion-owl.h             |   51 +
 drivers/staging/android/uapi/ion.h                 |   44 +
 include/asm-generic/dma-mapping-common.h           |   12 +
 include/linux/blkdev.h                             |   18 +-
 include/linux/clk-provider.h                       |    4 +
 include/linux/dma-contiguous.h                     |    2 +
 include/linux/dmaengine.h                          |    3 +
 include/linux/earlysuspend.h                       |   56 +
 include/linux/ion.h                                |   17 +
 include/linux/mmzone.h                             |   14 +
 include/linux/pinctrl/pinctrl.h                    |    2 +-
 include/trace/events/stand_hotplug.h               |   93 +
 include/uapi/linux/serial_core.h                   |    3 +
 kernel/power/Kconfig                               |   11 +
 kernel/power/Makefile                              |    2 +
 kernel/power/earlysuspend.c                        |  231 ++
 kernel/power/hibernate.c                           |    4 +
 kernel/power/main.c                                |   18 +-
 kernel/power/power.h                               |   10 +
 kernel/power/snapshot.c                            |   15 +
 kernel/power/suspend.c                             |    7 +-
 kernel/power/swap.c                                |    1 +
 kernel/reboot.c                                    |   23 +
 kernel/sched/core.c                                |    8 +
 mm/backing-dev.c                                   |    4 +-
 mm/page_alloc.c                                    |  117 +-
 167 files changed, 61755 insertions(+), 74 deletions(-)
 create mode 100755 Documentation/devicetree/bindings/arm/actions.txt
 create mode 100755 Documentation/devicetree/bindings/gpio/gpio_actions.txt
 mode change 100644 => 100755 arch/arm/Kconfig
 mode change 100644 => 100755 arch/arm/Makefile
 mode change 100644 => 100755 arch/arm/boot/dts/Makefile
 create mode 100755 arch/arm/boot/dts/actduino.dtsi
 create mode 100755 arch/arm/boot/dts/actduino_bubble_gum.dts
 create mode 100755 arch/arm/boot/dts/actduino_bubble_gum_linux.dts
 create mode 100755 arch/arm/boot/dts/actduino_bubble_gum_probatch.dts
 create mode 100755 arch/arm/boot/dts/actduino_bubble_gum_sdboot.dts
 create mode 100755 arch/arm/boot/dts/actduino_bubble_gum_sdboot_linux.dts
 create mode 100755 arch/arm/boot/dts/actduino_lemaker_guitar.dts
 create mode 100755 arch/arm/boot/dts/actduino_lemaker_guitar_linux.dts
 create mode 100755 arch/arm/boot/dts/actduino_lemaker_guitar_probatch.dts
 create mode 100755 arch/arm/boot/dts/actduino_probatch.dtsi
 create mode 100755 arch/arm/boot/dts/actduino_s500_1080p.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_720p.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_lcd_1280x800.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_lcd_1280x800_linux.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_lcd_1280x800_sdboot.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_lcd_1280x800_sdboot_linux.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_lcd_1280x800_uvc.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_lcd_768x1024.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_lcd_768x1024_linux.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_lcd_768x1024_uvc.dts
 create mode 100755 arch/arm/boot/dts/actduino_s500_probatch.dts
 create mode 100755 arch/arm/boot/dts/atm7059a.dtsi
 create mode 100755 arch/arm/boot/dts/atm7059a_demo_86v.dts
 create mode 100755 arch/arm/boot/dts/atm7059a_demo_86v_costdown.dts
 create mode 100755 arch/arm/boot/dts/atm7059a_demo_86v_costdown_wvga_dpi120.dts
 create mode 100755 arch/arm/boot/dts/atm7059a_demo_86v_costdown_wvga_dpi160.dts
 create mode 100755 arch/arm/boot/dts/atm7059a_demo_86v_test.dts
 create mode 100755 arch/arm/boot/dts/atm7059a_evb.dts
 create mode 100755 arch/arm/boot/dts/atm7059a_hr820ac_8723bs.dts
 create mode 100755 arch/arm/boot/dts/atm7059a_hr820ac_ap6210.dts
 create mode 100755 arch/arm/boot/dts/atm7059c_demo_86v_costdown.dts
 mode change 100644 => 100755 arch/arm/include/asm/cacheflush.h
 mode change 100644 => 100755 arch/arm/include/asm/dma-mapping.h
 mode change 100644 => 100755 arch/arm/kernel/hw_breakpoint.c
 mode change 100644 => 100755 arch/arm/kernel/setup.c
 mode change 100644 => 100755 arch/arm/kernel/sleep.S
 mode change 100644 => 100755 arch/arm/kernel/smp_twd.c
 mode change 100644 => 100755 arch/arm/kernel/traps.c
 create mode 100755 arch/arm/mach-owl/Kconfig
 create mode 100755 arch/arm/mach-owl/Makefile
 create mode 100755 arch/arm/mach-owl/Makefile.boot
 create mode 100755 arch/arm/mach-owl/board-owl.c
 create mode 100755 arch/arm/mach-owl/board-owl.h
 create mode 100755 arch/arm/mach-owl/bootafinfo-owl.c
 create mode 100755 arch/arm/mach-owl/bootdev-owl.c
 create mode 100755 arch/arm/mach-owl/clock-owl.h
 create mode 100755 arch/arm/mach-owl/clocktree-atm7059.c
 create mode 100755 arch/arm/mach-owl/clocktree-owl.c
 create mode 100755 arch/arm/mach-owl/clocktree-owl.h
 create mode 100755 arch/arm/mach-owl/common-owl.c
 create mode 100755 arch/arm/mach-owl/cpu-owl.c
 create mode 100755 arch/arm/mach-owl/debug-owl.c
 create mode 100755 arch/arm/mach-owl/dump_stack-owl.c
 create mode 100755 arch/arm/mach-owl/gpio-owl.c
 create mode 100755 arch/arm/mach-owl/headsmp-owl.S
 create mode 100755 arch/arm/mach-owl/hotplug-owl.c
 create mode 100755 arch/arm/mach-owl/hotplug_base-owl.c
 create mode 100755 arch/arm/mach-owl/i2c-owl.c
 create mode 100755 arch/arm/mach-owl/include/mach/bootafinfo.h
 create mode 100755 arch/arm/mach-owl/include/mach/bootdev.h
 create mode 100755 arch/arm/mach-owl/include/mach/chipid_reg-atm7039.h
 create mode 100755 arch/arm/mach-owl/include/mach/clkname.h
 create mode 100755 arch/arm/mach-owl/include/mach/clkname_priv.h
 create mode 100755 arch/arm/mach-owl/include/mach/clock-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/cpu_map-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/debug-macro.S
 create mode 100755 arch/arm/mach-owl/include/mach/debug-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/debug.h
 create mode 100755 arch/arm/mach-owl/include/mach/display-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/dsi-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/dss-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/dss_user-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/dvfs.h
 create mode 100755 arch/arm/mach-owl/include/mach/entry-macro.S
 create mode 100755 arch/arm/mach-owl/include/mach/gpio.h
 create mode 100755 arch/arm/mach-owl/include/mach/hardware.h
 create mode 100755 arch/arm/mach-owl/include/mach/hdmac-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/irqs.h
 create mode 100755 arch/arm/mach-owl/include/mach/isp-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/iversion.h
 create mode 100755 arch/arm/mach-owl/include/mach/kinfo.h
 create mode 100755 arch/arm/mach-owl/include/mach/module-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/power.h
 create mode 100755 arch/arm/mach-owl/include/mach/powergate.h
 create mode 100755 arch/arm/mach-owl/include/mach/pwm-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/regs_map-atm7039.h
 create mode 100755 arch/arm/mach-owl/include/mach/secure_storage.h
 create mode 100755 arch/arm/mach-owl/include/mach/smp.h
 create mode 100755 arch/arm/mach-owl/include/mach/spi-owl.h
 create mode 100755 arch/arm/mach-owl/include/mach/storage_access.h
 create mode 100755 arch/arm/mach-owl/include/mach/timex.h
 create mode 100755 arch/arm/mach-owl/include/mach/uncompress.h
 create mode 100755 arch/arm/mach-owl/isp_pwd-owl.c
 create mode 100755 arch/arm/mach-owl/misc-owl.c
 create mode 100755 arch/arm/mach-owl/pinctrl-owl.c
 create mode 100755 arch/arm/mach-owl/pinctrl_common-owl.c
 create mode 100755 arch/arm/mach-owl/pinctrl_common-owl.h
 create mode 100755 arch/arm/mach-owl/pinctrl_data-atm7059.c
 create mode 100755 arch/arm/mach-owl/pinctrl_data-owl.h
 create mode 100755 arch/arm/mach-owl/platsmp-owl.c
 create mode 100755 arch/arm/mach-owl/pm-owl.c
 create mode 100755 arch/arm/mach-owl/powergate-owl.c
 create mode 100755 arch/arm/mach-owl/processor-owl.c
 create mode 100755 arch/arm/mach-owl/secure_storage-owl.c
 create mode 100755 arch/arm/mach-owl/serial-owl.c
 create mode 100755 arch/arm/mach-owl/sirq-owl.c
 create mode 100755 arch/arm/mach-owl/sleep-owl.S
 create mode 100755 arch/arm/mach-owl/swsusp-owl.S
 create mode 100755 arch/arm/mach-owl/timer-owl.c
 create mode 100755 arch/arm/mach-owl/user_dump_stack.c
 create mode 100755 arch/arm/mach-owl/version-owl.c
 mode change 100644 => 100755 arch/arm/mm/dma-mapping.c
 mode change 100644 => 100755 arch/arm/mm/proc-macros.S
 mode change 100644 => 100755 arch/arm/mm/proc-v7.S
 mode change 100644 => 100755 arch/arm/tools/mach-types
 mode change 100644 => 100755 drivers/base/Kconfig
 mode change 100644 => 100755 drivers/base/dma-contiguous.c
 mode change 100644 => 100755 drivers/base/regmap/regmap-irq.c
 mode change 100644 => 100755 drivers/staging/android/Kconfig
 mode change 100644 => 100755 drivers/staging/android/Makefile
 mode change 100644 => 100755 drivers/staging/android/ion/Kconfig
 mode change 100644 => 100755 drivers/staging/android/ion/Makefile
 mode change 100644 => 100755 drivers/staging/android/ion/ion.c
 mode change 100644 => 100755 drivers/staging/android/ion/ion.h
 mode change 100644 => 100755 drivers/staging/android/ion/ion_cma_heap.c
 mode change 100644 => 100755 drivers/staging/android/ion/ion_priv.h
 create mode 100755 drivers/staging/android/ion/owl/Makefile
 create mode 100755 drivers/staging/android/ion/owl/ion-owl.c
 create mode 100755 drivers/staging/android/lowmem_killer.h
 mode change 100644 => 100755 drivers/staging/android/lowmemorykiller.c
 create mode 100755 drivers/staging/android/switch/Kconfig
 create mode 100755 drivers/staging/android/switch/Makefile
 create mode 100755 drivers/staging/android/switch/switch.h
 create mode 100755 drivers/staging/android/switch/switch_class.c
 create mode 100755 drivers/staging/android/switch/switch_gpio.c
 create mode 100755 drivers/staging/android/uapi/ion-owl.h
 mode change 100644 => 100755 drivers/staging/android/uapi/ion.h
 mode change 100644 => 100755 include/asm-generic/dma-mapping-common.h
 mode change 100644 => 100755 include/linux/blkdev.h
 mode change 100644 => 100755 include/linux/dma-contiguous.h
 create mode 100755 include/linux/earlysuspend.h
 mode change 100644 => 100755 include/linux/fs.h
 create mode 100755 include/linux/ion.h
 mode change 100644 => 100755 include/linux/mmzone.h
 mode change 100644 => 100755 include/linux/pinctrl/pinctrl.h
 create mode 100755 include/trace/events/stand_hotplug.h
 mode change 100644 => 100755 include/uapi/linux/serial_core.h
 mode change 100644 => 100755 kernel/power/Kconfig
 mode change 100644 => 100755 kernel/power/Makefile
 create mode 100755 kernel/power/earlysuspend.c
 mode change 100644 => 100755 kernel/power/hibernate.c
 mode change 100644 => 100755 kernel/power/main.c
 mode change 100644 => 100755 kernel/power/power.h
 mode change 100644 => 100755 kernel/power/snapshot.c
 mode change 100644 => 100755 kernel/power/suspend.c
 mode change 100644 => 100755 kernel/power/swap.c
 mode change 100644 => 100755 kernel/reboot.c
 mode change 100644 => 100755 kernel/sched/core.c
 mode change 100644 => 100755 mm/backing-dev.c
 mode change 100644 => 100755 mm/page_alloc.c

diff --git a/Documentation/devicetree/bindings/arm/actions.txt b/Documentation/devicetree/bindings/arm/actions.txt
new file mode 100755
index 0000000..06ced76
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/actions.txt
@@ -0,0 +1,7 @@
+Actions Arm-platform device tree bindings
+-------------------------------------------
+Boards with the s500 SoC shall have the following properties:
+
+Required root node property:
+
+compatible = "actions,s500", "actions,owl", "actions,atm7059a";
diff --git a/Documentation/devicetree/bindings/gpio/gpio_actions.txt b/Documentation/devicetree/bindings/gpio/gpio_actions.txt
new file mode 100755
index 0000000..32603b25
--- /dev/null
+++ b/Documentation/devicetree/bindings/gpio/gpio_actions.txt
@@ -0,0 +1,39 @@
+Actions SOC GPIO controller
+
+Required properties:
+- compatible : "actions,gl<chip-no>-gpio"
+- reg : Physical base address and length of the controller's registers.
+- interrupts : The interrupt outputs from the controller. For GL5203,
+  there should be 8 interrupts specified, 3 SIRQ & 5 GPIO interrupts.
+- #gpio-cells : Should be two. The first cell is the pin number and the
+  second cell is used to specify optional parameters:
+  - bit 0 specifies polarity (0 for normal, 1 for inverted)
+- gpio-controller : Marks the device node as a GPIO controller.
+- #interrupt-cells : Should be 2.
+  The first cell is the GPIO number, for GPIO<s><n>, N = (s - 'A') * 32 + n,
+  for GPIOB2, GPIO number is 34.
+  The second cell is used to specify flags:
+    bits[3:0] trigger type and level flags:
+      1 = low-to-high edge triggered.
+      2 = high-to-low edge triggered.
+      4 = active high level-sensitive.
+      8 = active low level-sensitive.
+      Valid combinations are 1, 2, 3, 4, 8.
+- interrupt-controller : Marks the device node as an interrupt controller.
+
+Example:
+
+gpio: gpio@b01b0000 {
+	compatible = "actions,atm7059a-gpio";
+	reg = < 0xb01b0000 0x40 >;
+	interrupts = <
+		0 36 0x04 /* GPIOA */
+		0 37 0x04 /* GPIOB */
+		0 38 0x04 /* GPIOC */
+		0 39 0x04 /* GPIOD */
+		0 40 0x04 /* GPIOE */ >;
+	#gpio-cells = <2>;
+	gpio-controller;
+	#interrupt-cells = <2>;
+	interrupt-controller;
+};
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
old mode 100644
new mode 100755
index 19f4cc6..0d10607
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -758,6 +758,24 @@ config ARCH_OMAP1
 	help
 	  Support for older TI OMAP1 (omap7xx, omap15xx or omap16xx)
 
+config ARCH_OWL
+	bool "Actions OWL Platform"
+	select CPU_V7
+	select GENERIC_CLOCKEVENTS
+	select ARCH_REQUIRE_GPIOLIB
+	select COMMON_CLK
+	select CLKDEV_LOOKUP
+	select ARM_GIC
+	select HAVE_SMP
+	select ARM_HAS_SG_CHAIN
+	select ARCH_HAS_OPP
+	select ARCH_HAS_CPUFREQ
+	select MIGHT_HAVE_CACHE_L2X0
+	select USB_GADGET_DUALSPEED
+	select PM_OPP if PM	
+	help
+	  Support for Actions OWL Platform
+
 endchoice
 
 menu "Multiple platform selection"
@@ -951,6 +969,8 @@ source "arch/arm/mach-w90x900/Kconfig"
 
 source "arch/arm/mach-zynq/Kconfig"
 
+source "arch/arm/mach-owl/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
old mode 100644
new mode 100755
index 46504d2..38ffa4d
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -214,6 +214,7 @@ machine-$(CONFIG_ARCH_VT8500)		+= vt8500
 machine-$(CONFIG_ARCH_W90X900)		+= w90x900
 machine-$(CONFIG_ARCH_ZYNQ)		+= zynq
 machine-$(CONFIG_PLAT_SPEAR)		+= spear
+machine-$(CONFIG_ARCH_OWL)		:= owl
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
old mode 100644
new mode 100755
index 992736b..33ddfa0
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -660,6 +660,39 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += \
 	mt6592-evb.dtb \
 	mt8127-moose.dtb \
 	mt8135-evbp1.dtb
+dtb-$(CONFIG_ARCH_OWL) += actduino_bubble_gum.dtb \
+	actduino_bubble_gum_sdboot.dtb \
+	actduino_s500_720p.dtb \
+	actduino_s500_1080p.dtb \
+	actduino_s500_lcd_1280x800.dtb \
+	actduino_s500_lcd_1280x800_uvc.dtb \
+	actduino_s500_lcd_768x1024.dtb \
+	actduino_s500_lcd_768x1024_uvc.dtb \
+	atm7059a_demo_86v.dtb \
+	atm7059a_demo_86v_costdown.dtb \
+	atm7059a_demo_86v_costdown_wvga_dpi120.dtb \
+	atm7059a_demo_86v_costdown_wvga_dpi160.dtb \
+	atm7059a_demo_86v_test.dtb \
+	atm7059a_evb.dtb \
+	atm7059a_hr820ac_8723bs.dtb \
+	atm7059a_hr820ac_ap6210.dtb \
+	atm7059c_demo_86v_costdown.dtb \
+	actduino_lemaker_guitar.dtb \
+	actduino_s500_lcd_1280x800_sdboot.dtb \
+	actduino_bubble_gum_linux.dtb \
+	actduino_bubble_gum_sdboot_linux.dtb \
+	actduino_s500_lcd_1280x800_linux.dtb \
+	actduino_s500_lcd_1280x800_sdboot_linux.dtb \
+	actduino_s500_lcd_768x1024_linux.dtb \
+	actduino_lemaker_guitar_linux.dtb \
+	actduino_bubble_gum_probatch.dtb \
+	actduino_s500_probatch.dtb \
+	actduino_lemaker_guitar_probatch.dtb
+	
+ifeq ($(CONFIG_ARCH_OWL),y)
+DTC_FLAGS = -R -4 -p 0x1000
+endif
+
 endif
 
 always		:= $(dtb-y)
diff --git a/arch/arm/boot/dts/actduino.dtsi b/arch/arm/boot/dts/actduino.dtsi
new file mode 100755
index 0000000..2c2b192
--- /dev/null
+++ b/arch/arm/boot/dts/actduino.dtsi
@@ -0,0 +1,410 @@
+/include/ "skeleton.dtsi"
+
+/ {
+	compatible = "actions,atm7059a";
+	interrupt-parent = <&intc>;
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+		serial5 = &uart5;
+		serial6 = &uart6;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		spi2 = &spi2;
+		spi3 = &spi3;
+		dcdc1 = &dcdc1;
+		dcdc2 = &dcdc2;
+		dcdc3 = &dcdc3;
+		dcdc4 = &dcdc4;
+		ldo1 = &ldo1;
+		ldo2 = &ldo2;
+		ldo3 = &ldo3;
+		ldo4 = &ldo4;
+		ldo5 = &ldo5;
+		ldo6 = &ldo6;
+		ldo7 = &ldo7;
+		ldo8 = &ldo8;
+		ldo9 = &ldo9;
+		ldo10 = &ldo10;
+		ldo11 = &ldo11;
+		switch1 = &switch1;
+		switch2 = &switch2;
+		isp0 = &isp0;
+		sdboot = &mmc0;
+		mmc0 = &mmc0;
+		mmc1 = &mmc1;
+		mmc2 = &mmc2;
+		usb0 = &usb0;
+		usb1 = &usb1;
+	};
+
+	cpus {
+		#size-cells = <0>;
+		#address-cells = <1>;
+
+		CPU0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x0>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x1>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x80000000>; /* 2GB */
+	};
+
+	/* look at binding Documentation/devicetree/bindings/arm/gic.txt */
+	intc: interrupt-controller@b0021000 {
+		compatible = "arm,cortex-a9-gic";
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		reg = < 0xb0021000 0x1000 >,
+		      < 0xb0020100 0x0100 >;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a9-pmu";
+		interrupts = <0 4 0x04
+							0 5 0x04
+							0 6 0x04
+							0 7 0x04>;
+		interrupt-affinity = <&CPU0>, <&CPU1>, <&CPU2>, <&CPU3>;
+	};
+
+	L2: cache-controller@b0022000 {
+		compatible = "arm,pl310-cache";
+		reg = < 0xb0022000 0x1000 >;
+		cache-unified;
+		cache-level = <2>;
+		interrupts = < 0 55 0x4 >;
+		arm,tag-latency = <3 3 2>;
+		arm,data-latency = <5 3 3>;
+	};
+
+	twd-watchdog@b0020600 {
+		compatible = "actions,atm7059-wdt";
+		reg = <0xb0020600 0x100>, <0xb0160000 0x20>;
+		interrupts = <1 14 0xf01>;
+		wd_type="soft";			//wd_type:"hard" and "soft"
+	};
+	
+	uart0: serial@b0120000 {
+		compatible = "actions,owl-uart", "actions,owl-uart-irc";
+		reg = <0xb0120000 0x2000>;
+		interrupts = < 0 29 0x4 >;
+	};
+
+	uart1: serial@b0122000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0122000 0x2000>;
+		interrupts = < 0 30 0x4 >;
+	};
+
+	uart2: serial@b0124000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0124000 0x2000>;
+		interrupts = < 0 31 0x4 >;
+	};
+
+	uart3: serial@b0126000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0126000 0x2000>;
+		interrupts = < 0 32 0x4 >;
+	};
+
+	uart4: serial@b0128000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0128000 0x2000>;
+		interrupts = < 0 33 0x4 >;
+	};
+
+	uart5: serial@b012a000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb012a000 0x2000>;
+		interrupts = < 0 34 0x4 >;
+	};
+
+	uart6: serial@b012c000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb012c000 0x2000>;
+		interrupts = < 0 35 0x4 >;
+	};
+
+	i2c0: i2c@b0170000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb0170000 0x4000>;
+		interrupts = < 0 25 0x4 >;
+	};
+
+	i2c1: i2c@b0174000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb0174000 0x4000>;
+		interrupts = < 0 26 0x4 >;
+	};
+
+	i2c2: i2c@b0178000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb0178000 0x4000>;
+		interrupts = < 0 27 0x4 >;
+	};
+
+	i2c3: i2c@b017c000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb017c000 0x4000>;
+		interrupts = < 0 28 0x4 >;
+	};
+
+	spi0: spi@b0200000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb0200000 0x4000>;
+		interrupts = < 0 19 0x4 >;
+	};
+
+	spi1: spi@b0204000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb0204000 0x4000>;
+		interrupts = < 0 20 0x4 >;
+	};
+
+	spi2: spi@b0208000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb0208000 0x4000>;
+		interrupts = < 0 21 0x4 >;
+	};
+
+	spi3: spi@b020c000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb020c000 0x4000>;
+		interrupts = < 0 22 0x4 >;
+	};
+
+	gpio: gpio@b01b0000 {
+		compatible = "actions,atm7059a-gpio";
+		reg = < 0xb01b0000 0x40 >;
+		interrupts = <
+			0 36 0x04 /* GPIOA */
+			0 37 0x04 /* GPIOB */
+			0 38 0x04 /* GPIOC */
+			0 39 0x04 /* GPIOD */
+			0 40 0x04 /* GPIOE */ >;
+		#gpio-cells = <2>;
+		gpio-controller;
+		#interrupt-cells = <2>;
+		interrupt-controller;
+	};
+
+	sirq: sirq@b01b0200 {
+		compatible = "actions,owl-sirq";
+		reg = < 0xb01b0200 0x4 >;
+		interrupts = <
+			0 13 0x04  /* SIRQ0 */
+			0 14 0x04  /* SIRQ1 */
+			0 15 0x04  /* SIRQ2 */ >;
+		#interrupt-cells = <2>;
+		interrupt-controller;
+	};
+
+	pwm: pwm@b01b0050 {
+		compatible = "actions,atm7059a-pwm";
+		reg = <0xb01b0050 0x10>;
+		#pwm-cells = <3>;
+	};
+
+	ethernet@b0310000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-ethernet";
+		reg = <0xb0310000 0x10000>;
+	};
+
+	mmc0: mmc@b0230000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-mmc";
+		reg = <0xb0230000 0x38>;
+	};
+
+	mmc1: mmc@b0234000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-mmc";
+		reg = <0xb0234000 0x38>;
+		interrupts = < 0 43 0x4 >;
+	};
+
+	mmc2: mmc@b0238000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-mmc";
+		reg = <0xb0238000 0x38>;
+		interrupts = < 0 44 0x4 >;
+	};
+
+	usb0: usb@b0600000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-usb-2.0-0";
+		reg = <0xb0600000 0x1000>;
+		interrupts = < 0 24 0x4 >;
+	};
+	
+	usb1: usb@b0700000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-usb-2.0-1";
+		reg = <0xb0700000 0x1000>;
+		interrupts = < 0 61 0x4 >;
+	};
+
+	usb@b0400000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,atm7059tc-usb";
+		reg = <0xb0400000 0xcd00>,
+			  <0xb040cd00 0x59>;
+		interrupts = < 0 23 0x4 >;
+	};
+    
+	isp0: isp@b0270000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "actions,owl-isp";
+		reg = <0xb0270000 0x400>,<0xb0160020 0x04>;
+		interrupts = < 0 12 0x4 >;
+	};
+
+	pinctrl@b01b0040 {
+		compatible = "actions,atm7059a-pinctrl";
+	};
+
+	lcd0@b02a0000 {
+		compatible = "actions,owl-lcd";
+		reg = <0xb02a0000 0x20c>;
+		interrupts = < 0 45 0x4 >;
+	};
+
+	dsi@b0220000 {
+		compatible = "actions,owl-dsi";
+		reg = <0xb0220000 0x8c>;
+		interrupts = < 0 51 0x4 >;
+	};
+
+  	backlight {
+		compatible = "actions,owl-pwm-backlight";
+	};
+	
+	gpu@b0300000 {
+		compatible = "actions,atm7039c-gpu";
+		reg = <0xb0300000 0x10000>;
+		interrupts = < 0 3 0x4 >;
+	};
+	
+	vde@b0280000{
+		compatible = "actions,atm7059a-vde";
+		reg = <0xb0280000 0x108>;
+		interrupts = < 0 50 0x4 >;
+	};
+    
+	vce@b0288000{
+		compatible = "actions,atm7059a-vce";
+		reg = <0xb0288000 0x94>;
+		interrupts = < 0 49 0x4 >;
+	};
+  
+	hdmi@b02c0000{
+		compatible = "actions,atm7059a-hdmi";
+		reg = <0xb02c0000 0x160>;
+	};
+	
+	hdmi_cec@b02c011c{
+		compatible = "actions,atm7059a-hdmi-cec";
+		reg = <0xb02c0000 0x160>;
+	};
+
+	cvbs@b02b0000{
+		compatible = "actions,atm7059a-cvbs";
+		reg = <0xb02b0000 0x80>;
+	};
+	
+	de@b02e0000 {
+		compatible = "actions,atm7059a-de";
+		reg = <0xb02e0000 0x100e>, <0xb0500108 0x4>;
+	};
+	
+	nand@b0210000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "actions,atm7059a-nand";
+		reg = <0xB0210000 0xb4>, <0xB0160000 0xfc>, <0xB01B0000 0x90>, <0xB0260000 0xd00>;
+		interrupts = < 0 41 0x4 >;
+	};
+
+	dma@b0260000 {
+		compatible = "actions,owl-dma";
+		reg = <0xb0260000 0xd00>;
+		interrupts = < 0 57 0x4 >, < 0 58 0x4 >, < 0 59 0x4 >, < 0 60 0x4 >;
+	};
+
+	thermal {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "actions,atm7059a-thermal";
+		reg = <0xb01b00e8 0x8>;
+	};
+
+	clks: cum@b0160000 {
+		compatible = "actions,s500-cum";
+		reg = <0xb0160000 0x8000>;
+		#clock-cells = <1>;
+	};
+
+	gpt: gpt@b0168000 {
+		compatible = "actions,s500-gpt";
+		reg = <0xb0168000 0x8000>;
+		interrupts = <0 11 4>;
+		clocks = <&clks 98>;
+		clock-names = "TIMER_CLK";
+	};	
+	
+	timer@b0020600 {
+		compatible = "arm,cortex-a9-twd-timer";
+		reg = <0xb0020600 0x20>;
+		interrupts = <1 13 0xf01>;
+		interrupt-parent = <&intc>;
+		clocks = <&clks 37>;
+	};	
+};
diff --git a/arch/arm/boot/dts/actduino_bubble_gum.dts b/arch/arm/boot/dts/actduino_bubble_gum.dts
new file mode 100755
index 0000000..8ebe5ae
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_bubble_gum.dts
@@ -0,0 +1,1246 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_2 {
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		spi0_state_default: spi0_default {
+			spi0_mfp {
+				actions,groups = "mfp1_2_0", "mfp1_4_3";
+				actions,function = "spi0";
+			};
+		};	
+
+		spi2_state_default: spi2_default {
+			spi2_mfp {
+				actions,groups = "mfp3_2";
+				actions,function = "spi2";
+			};
+		};		
+		
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+			
+			atc260x-pwm {
+				compatible = "actions,atc2603c-pwm";
+			};	
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				ir_ch = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				earphone_detect_gpios = <&gpio 35 0>;/*GPIOB4 0: high,1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				i2s_switch_gpio = <&gpio 33 0>; /* GPIOB1 1: high, route to 40Pin port, 0: low, route to audiojack */
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3300>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <1>;
+			rotate_degree = <90>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&spi2_state_default>;
+		status = "okay";
+		m25p80@0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "winbond,w25q16";
+			spi-cpha = <1>;
+			spi-cpol = <1>;
+			spi-max-frequency = <40000000>;
+			reg = <0>;
+			m25p,fast-read;
+		};
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+      
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 88 0>; /* GPIOC24 */
+
+		phy_addr = <3>;
+		address-bits = <48>;
+		//random-mac-address = "okay";
+		//local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "realtk,rtl8201";
+			reg = <0>;
+			interrupt-parent = <&sirq>;
+			interrupts = < 0 0x4 >;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*bubble gum 1.0 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "command";  /* only: "sirq", "gpio", or "command" */
+//		card_detect_gpios = <&gpio 125 0>; /*hr280ac GPIOD29 */  
+		interrupts = < 0 43 0x4 >;
+
+		status = "disabled";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+	
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0600000 {
+		vbus_otg_en_gpio = <&gpio 36 1>; /*GPIO B4*/
+		port0_host_plug_detect = <3>;
+		status = "disabled";
+	};
+	
+	usb@b0700000 {
+		vbus_otg_en_gpio = <&gpio 36 1>; /*GPIO B4*/
+		port1_host_plug_detect = <3>;
+		status = "disabled";
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 37 1>;  /* GPIOB5,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 81 0>; /* GPIOC15 */
+		/*reset-gpios = <&gpio 20 1>;*/ /*86v:GPIOA20*/
+
+		status = "disabled"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "disabled";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;	
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+	
+		
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 { 
+		status = "disabled";
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		hotplugable = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "auto";
+	};
+
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		bootable = <1>; 
+		bootrotate = <0>;  
+		hotplugable = <1>;
+		status="okay";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "hdmi";
+		xres=<1280>;
+		yres=<720>;
+		bpp=<4>;  
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 128 0>; /*bubble gum GPIOE0*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		no_bind_usb_port;
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_bubble_gum_linux.dts b/arch/arm/boot/dts/actduino_bubble_gum_linux.dts
new file mode 100755
index 0000000..3b364ae
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_bubble_gum_linux.dts
@@ -0,0 +1,1243 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <1>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_2 {
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		spi0_state_default: spi0_default {
+			spi0_mfp {
+				actions,groups = "mfp1_2_0", "mfp1_4_3";
+				actions,function = "spi0";
+			};
+		};	
+
+		spi2_state_default: spi2_default {
+			spi2_mfp {
+				actions,groups = "mfp3_2";
+				actions,function = "spi2";
+			};
+		};		
+		
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+			
+			atc260x-pwm {
+				compatible = "actions,atc2603c-pwm";
+			};	
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				ir_ch = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				earphone_detect_gpios = <&gpio 35 0>;/*GPIOB4 0: high,1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				i2s_switch_gpio = <&gpio 33 0>;  /* GPIOB1 1: high, route to 40Pin port, 0: low, route to audiojack */
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3300>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <1>;
+			rotate_degree = <90>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&spi2_state_default>;
+		status = "okay";
+		m25p80@0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "winbond,w25q16";
+			spi-cpha = <1>;
+			spi-cpol = <1>;
+			spi-max-frequency = <40000000>;
+			reg = <0>;
+			m25p,fast-read;
+		};
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+      
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 88 0>; /* GPIOC24 */
+
+		phy_addr = <3>;
+		address-bits = <48>;
+		//random-mac-address = "okay";
+		//local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "realtk,rtl8201";
+			reg = <0>;
+			interrupt-parent = <&sirq>;
+			interrupts = < 0 0x4 >;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*bubble gum 1.0 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "command";  /* only: "sirq", "gpio", or "command" */
+//		card_detect_gpios = <&gpio 125 0>; /*hr280ac GPIOD29 */  
+		interrupts = < 0 43 0x4 >;
+
+		status = "disabled";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+	
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0600000 {
+		vbus_otg_en_gpio = <&gpio 36 1>; /*GPIO B4*/
+		port0_host_plug_detect = <3>;
+		status = "disabled";
+	};
+	
+	usb@b0700000 {
+		vbus_otg_en_gpio = <&gpio 36 1>; /*GPIO B4*/
+		port1_host_plug_detect = <3>;
+		status = "disabled";
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 37 1>;  /* GPIOB5,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 81 0>; /* GPIOC15 */
+		/*reset-gpios = <&gpio 20 1>;*/ /*86v:GPIOA20*/
+
+		status = "disabled"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "disabled";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;	
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+	
+		
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 { 
+		status = "disabled";
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		hotplugable = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "auto";
+	};
+
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		bootable = <1>; 
+		bootrotate = <0>;  
+		hotplugable = <1>;
+		status="okay";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "hdmi";
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 128 0>; /*bubble gum GPIOE0*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		no_bind_usb_port;
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_bubble_gum_probatch.dts b/arch/arm/boot/dts/actduino_bubble_gum_probatch.dts
new file mode 100755
index 0000000..d6a94ff
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_bubble_gum_probatch.dts
@@ -0,0 +1,338 @@
+﻿/dts-v1/;
+
+/include/ "actduino_probatch.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+    
+
+	
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_2 {
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		status = "disabled";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";	/* reboot shutdown use it */
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		status = "disabled";
+	};
+
+	i2c@b0178000 {
+		status = "disabled";
+	};
+
+	i2c@b017c000 {
+		status = "disabled";
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	spi@b0208000 {
+		status = "okay";
+		m25p80@0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "winbond,w25q16";
+			spi-cpha = <1>;
+			spi-cpol = <1>;
+			spi-max-frequency = <40000000>;
+			reg = <0>;
+			m25p,fast-read;
+		};
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+	};
+
+	mmc@b0234000 {
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_bubble_gum_sdboot.dts b/arch/arm/boot/dts/actduino_bubble_gum_sdboot.dts
new file mode 100755
index 0000000..8bc39bc
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_bubble_gum_sdboot.dts
@@ -0,0 +1,1237 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+		stdout-path = &uart2;
+		linux,stdout-path = &uart2;
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			clock-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_2 {
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		spi0_state_default: spi0_default {
+			spi0_mfp {
+				actions,groups = "mfp1_2_0", "mfp1_4_3";
+				actions,function = "spi0";
+			};
+		};	
+
+		spi2_state_default: spi2_default {
+			spi2_mfp {
+				actions,groups = "mfp3_2";
+				actions,function = "spi2";
+			};
+		};		
+		
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+			
+			atc260x-pwm {
+				compatible = "actions,atc2603c-pwm";
+			};	
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				ir_ch = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				earphone_detect_gpios = <&gpio 35 0>;/*GPIOB4 0: high,1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				i2s_switch_gpio = <&gpio 33 0>; /* GPIOB1 1: high, route to 40Pin port, 0: low, route to audiojack */
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3300>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <1>;
+			rotate_degree = <90>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&spi2_state_default>;
+		status = "okay";
+		m25p80@0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "winbond,w25q32";
+			spi-cpha = <1>;
+			spi-cpol = <1>;
+			spi-max-frequency = <40000000>;
+			reg = <0>;
+			m25p,fast-read;
+		};
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+      
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 88 0>; /* GPIOC24 */
+
+		phy_addr = <3>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ]; /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		interrupts = < 0 0 0x4 >;
+		
+		phy0: ethernet-phy@0 {
+			compatible = "realtk,rtl8201";
+			reg = <0>;
+			interrupt-parent = <&sirq>;
+			interrupts = < 0 0x4 >;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*bubble gum 1.0 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "command";  /* only: "sirq", "gpio", or "command" */
+//		card_detect_gpios = <&gpio 125 0>; /*hr280ac GPIOD29 */  
+		interrupts = < 0 43 0x4 >;
+
+		status = "disabled";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "disable";
+	};
+	
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0600000 {
+		vbus_otg_en_gpio = <&gpio 36 1>; /*GPIO B4*/
+		port0_host_plug_detect = <1>;
+		status = "okay";
+	};
+	
+	usb@b0700000 {
+		vbus_otg_en_gpio = <&gpio 36 1>; /*GPIO B4*/
+		port1_host_plug_detect = <1>;
+		status = "okay";
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 37 1>;  /* GPIOB5,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 81 0>; /* GPIOC15 */
+		/*reset-gpios = <&gpio 20 1>;*/ /*86v:GPIOA20*/
+	
+		status = "disabled"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "disabled";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+	
+		
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 { 
+		status = "disabled";
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		hotplugable = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "auto";
+	};
+
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		bootable = <1>; 
+		bootrotate = <0>;  
+		hotplugable = <1>;
+		status="okay";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "hdmi";
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		status = "disabled";	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		no_bind_usb_port;
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_bubble_gum_sdboot_linux.dts b/arch/arm/boot/dts/actduino_bubble_gum_sdboot_linux.dts
new file mode 100755
index 0000000..14398a8
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_bubble_gum_sdboot_linux.dts
@@ -0,0 +1,1237 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+		stdout-path = &uart2;
+		linux,stdout-path = &uart2;
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			clock-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <1>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_2 {
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		spi0_state_default: spi0_default {
+			spi0_mfp {
+				actions,groups = "mfp1_2_0", "mfp1_4_3";
+				actions,function = "spi0";
+			};
+		};	
+
+		spi2_state_default: spi2_default {
+			spi2_mfp {
+				actions,groups = "mfp3_2";
+				actions,function = "spi2";
+			};
+		};		
+		
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+			
+			atc260x-pwm {
+				compatible = "actions,atc2603c-pwm";
+			};	
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				ir_ch = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				earphone_detect_gpios = <&gpio 35 0>;/*GPIOB4 0: high,1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				i2s_switch_gpio = <&gpio 33 0>; /* GPIOB1 1: high, route to 40Pin port, 0: low, route to audiojack */
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3300>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <1>;
+			rotate_degree = <90>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&spi2_state_default>;
+		status = "okay";
+		m25p80@0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "winbond,w25q32";
+			spi-cpha = <1>;
+			spi-cpol = <1>;
+			spi-max-frequency = <40000000>;
+			reg = <0>;
+			m25p,fast-read;
+		};
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+      
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 88 0>; /* GPIOC24 */
+
+		phy_addr = <3>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ]; /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		interrupts = < 0 0 0x4 >;
+		
+		phy0: ethernet-phy@0 {
+			compatible = "realtk,rtl8201";
+			reg = <0>;
+			interrupt-parent = <&sirq>;
+			interrupts = < 0 0x4 >;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*bubble gum 1.0 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "command";  /* only: "sirq", "gpio", or "command" */
+//		card_detect_gpios = <&gpio 125 0>; /*hr280ac GPIOD29 */  
+		interrupts = < 0 43 0x4 >;
+
+		status = "disabled";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "disable";
+	};
+	
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0600000 {
+		vbus_otg_en_gpio = <&gpio 36 1>; /*GPIO B4*/
+		port0_host_plug_detect = <1>;
+		status = "okay";
+	};
+	
+	usb@b0700000 {
+		vbus_otg_en_gpio = <&gpio 36 1>; /*GPIO B4*/
+		port1_host_plug_detect = <1>;
+		status = "okay";
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 37 1>;  /* GPIOB5,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 81 0>; /* GPIOC15 */
+		/*reset-gpios = <&gpio 20 1>;*/ /*86v:GPIOA20*/
+	
+		status = "disabled"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "disabled";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+	
+		
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 { 
+		status = "disabled";
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		hotplugable = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "auto";
+	};
+
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		bootable = <1>; 
+		hotplugable = <0>;
+		bootrotate = <0>;
+		status="okay";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "hdmi";
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		status = "disabled";	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		no_bind_usb_port;
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_lemaker_guitar.dts b/arch/arm/boot/dts/actduino_lemaker_guitar.dts
new file mode 100755
index 0000000..c6618c6
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_lemaker_guitar.dts
@@ -0,0 +1,1269 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+	
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <98>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+ 		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+			lcd_mux {
+				actions,groups = "mfp1_22_21";
+				actions,function = "lcd0";
+			};
+	  	};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+			
+			atc260x-pwm {
+				compatible = "actions,atc2603c-pwm";
+			};	
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+/*			atc260x-irkeypad{
+				size = <17>;
+				user_code = <65280>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <70 21 68 67 64 22 25 13 12 24 94 8 28 90 66 82 74>;
+				key_code = <103 108 105 106 353 2 3 4 5 6 7 8 9 10 522 11 523>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+*/
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				//speaker_en_gpios = <&gpio 126 1>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0xf 0xf >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <200>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <0>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <1>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <5>;
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    		//interrupt-parent = <&sirq>;
+    		//interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		hdmi_read_edid@30 {
+                        compatible = "actions,hdmi_read_edid";
+                        reg = <0x30>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 43 0>; /* GPIOB11 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 127 0>; /* GPIOD31 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 66 1>; /*86v S500 GPIOC2 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+		status = "okay";
+//		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+	usb@b0600000 { 
+		//vbus_otg_en_gpio = <&gpio 116 0>; /*GPIO D20*/ 
+		port0_host_plug_detect = <1>;
+		status = "okay";
+	}; 
+
+	usb@b0700000 { 
+		//vbus_otg_en_gpio = <&gpio 36 0>; /*GPIO B4*/
+		port1_host_plug_detect = <1>;
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 125 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 124 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 120 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 121 1>; /*:GPIOC16*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "disabled";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+
+
+			bf3703 = <1>;
+			bf3920 = <1>;
+									
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			
+			soc5140 = <1>;
+    	};
+    };
+
+lcd0: lcd0@b02a0000 {
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lvds_state_default>;
+		lcd_power_gpios = <&gpio 36 0>;    /*GPIOB4*/
+		lcd_reset_gpios = <&gpio 49 0>; /*GPIOB17*/
+		port_type = "lvds";
+		data_width = <0>;		/* 0:24bit ,1:18bit */
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <0>;
+		hsync_inversion = <0>;
+
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9523>;	/* last two bit: 3:8bit ,1:6bit */
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <5>;
+
+		
+		lcd_mode0:mode@1024x600p60 {
+			refresh = <60>;
+			xres = <1024>;
+			yres = <600>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <20000>;
+			left_margin = <56>;
+			right_margin = <60>;
+			upper_margin = <13>;
+			lower_margin = <18>;
+			hsync_len = <4>;
+			vsync_len = <4>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};	
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		hotplugable = <0>;
+		bootable = <1>; 
+		bootrotate = <3>;   
+		default_resolution = "auto";
+	};
+
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		bootable = <1>; 
+		bootrotate = <3>; 
+		hotplugable = <1>;
+		status="disabled";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "lcd";
+
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		//backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio  0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		wifi_bt_power_gpios = <&gpio 126 0>; /* 86v GPIOD30 */
+		bt_en_gpios = <&gpio 67 0>;/*GPIOC3, high active*/
+		wifi_en_gpios = <&gpio 62 0>; /* 86v GPIOB30 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <0>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <0>;
+      mc3236 =  <0>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <0>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <0>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <1>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_lemaker_guitar_linux.dts b/arch/arm/boot/dts/actduino_lemaker_guitar_linux.dts
new file mode 100755
index 0000000..cad1ffa
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_lemaker_guitar_linux.dts
@@ -0,0 +1,1266 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+	
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <98>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+ 		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+			lcd_mux {
+				actions,groups = "mfp1_22_21";
+				actions,function = "lcd0";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+			
+			atc260x-pwm {
+				compatible = "actions,atc2603c-pwm";
+			};	
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+/*			atc260x-irkeypad{
+				size = <17>;
+				user_code = <65280>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <70 21 68 67 64 22 25 13 12 24 94 8 28 90 66 82 74>;
+				key_code = <103 108 105 106 353 2 3 4 5 6 7 8 9 10 522 11 523>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+*/
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				//speaker_en_gpios = <&gpio 126 1>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0xf 0xf >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <200>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <0>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <1>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <5>;
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    		//interrupt-parent = <&sirq>;
+    		//interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		hdmi_read_edid@30 {
+                        compatible = "actions,hdmi_read_edid";
+                        reg = <0x30>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 43 0>; /* GPIOB11 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 127 0>; /* GPIOD31 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 66 1>; /*86v S500 GPIOC2 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+		status = "okay";
+//		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+	usb@b0600000 { 
+		//vbus_otg_en_gpio = <&gpio 116 0>; /*GPIO D20*/ 
+		port0_host_plug_detect = <1>;
+		status = "okay";
+	}; 
+	usb@b0700000 { 
+		//vbus_otg_en_gpio = <&gpio 36 0>; /*GPIO B4*/
+		port1_host_plug_detect = <1>;
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 125 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 124 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 120 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 121 1>; /*:GPIOC16*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+
+
+			bf3703 = <1>;
+			bf3920 = <1>;
+									
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			
+			soc5140 = <1>;
+    	};
+    };
+
+lcd0: lcd0@b02a0000 {
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lvds_state_default>;
+		lcd_power_gpios = <&gpio 36 0>;    /*GPIOB4*/
+		lcd_reset_gpios = <&gpio 49 0>; /*GPIOB17*/
+		port_type = "lvds";
+		data_width = <0>;		/* 0:24bit ,1:18bit */
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <0>;
+		hsync_inversion = <0>;
+
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9523>;	/* last two bit: 3:8bit ,1:6bit */
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <5>;
+
+		
+		lcd_mode0:mode@1024x600p60 {
+			refresh = <60>;
+			xres = <1024>;
+			yres = <600>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <20000>;
+			left_margin = <56>;
+			right_margin = <60>;
+			upper_margin = <13>;
+			lower_margin = <18>;
+			hsync_len = <4>;
+			vsync_len = <4>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};	
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		hotplugable = <0>;
+		bootable = <1>; 
+		bootrotate = <3>;   
+		default_resolution = "auto";
+	};
+	
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		bootable = <1>; 
+		bootrotate = <3>; 
+		hotplugable = <1>;
+		status="disabled";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "lcd";
+
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		//backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio  0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		wifi_bt_power_gpios = <&gpio 126 0>; /* 86v GPIOD30 */
+		bt_en_gpios = <&gpio 67 0>;/*GPIOC3, high active*/
+		wifi_en_gpios = <&gpio 62 0>; /* 86v GPIOB30 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <0>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <0>;
+      mc3236 =  <0>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <0>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <0>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <1>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_lemaker_guitar_probatch.dts b/arch/arm/boot/dts/actduino_lemaker_guitar_probatch.dts
new file mode 100755
index 0000000..6ece813
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_lemaker_guitar_probatch.dts
@@ -0,0 +1,321 @@
+﻿/dts-v1/;
+
+/include/ "actduino_probatch.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+    
+
+	
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+		status = "disabled";
+	};
+
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";	/* reboot shutdown use it */
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		status = "disabled";
+	};
+
+	i2c@b0178000 {
+		status = "disabled";
+	};
+
+	i2c@b017c000 {
+		status = "disabled";
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 66 1>; /*86v S500 GPIOC2 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+	};
+
+	mmc@b0234000 {
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_probatch.dtsi b/arch/arm/boot/dts/actduino_probatch.dtsi
new file mode 100755
index 0000000..e6acb24
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_probatch.dtsi
@@ -0,0 +1,349 @@
+/include/ "skeleton.dtsi"
+
+/ {
+	compatible = "actions,atm7059a";
+	interrupt-parent = <&intc>;
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+		serial5 = &uart5;
+		serial6 = &uart6;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		spi2 = &spi2;
+		spi3 = &spi3;
+		isp0 = &isp0;
+		sdboot = &mmc0;
+		mmc0 = &mmc0;
+		mmc1 = &mmc1;
+		mmc2 = &mmc2;
+		usb0 = &usb0;
+		usb1 = &usb1;
+	};
+
+	cpus {
+		#size-cells = <0>;
+		#address-cells = <1>;
+
+		CPU0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x0>;
+		};
+
+		CPU1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x1>;
+		};
+	};
+
+	/* look at binding Documentation/devicetree/bindings/arm/gic.txt */
+	intc: interrupt-controller@b0021000 {
+		compatible = "arm,cortex-a9-gic";
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		reg = < 0xb0021000 0x1000 >,
+		      < 0xb0020100 0x0100 >;
+	};
+
+        pmu {
+                compatible = "arm,cortex-a9-pmu";
+                interrupts = <0 4 0x04
+                              0 5 0x04
+                              0 6 0x04
+                              0 7 0x04>;
+        };
+
+	L2: cache-controller@b0022000 {
+		compatible = "arm,pl310-cache";
+		reg = < 0xb0022000 0x1000 >;
+		cache-unified;
+		cache-level = <2>;
+		interrupts = < 0 55 0x4 >;
+		arm,tag-latency = <3 3 2>;
+		arm,data-latency = <5 3 3>;
+	};
+
+	uart0: serial@b0120000 {
+		compatible = "actions,owl-uart", "actions,owl-uart-irc";
+		reg = <0xb0120000 0x2000>;
+		interrupts = < 0 29 0x4 >;
+	};
+
+	uart1: serial@b0122000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0122000 0x2000>;
+		interrupts = < 0 30 0x4 >;
+	};
+
+	uart2: serial@b0124000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0124000 0x2000>;
+		interrupts = < 0 31 0x4 >;
+	};
+
+	uart3: serial@b0126000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0126000 0x2000>;
+		interrupts = < 0 32 0x4 >;
+	};
+
+	uart4: serial@b0128000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0128000 0x2000>;
+		interrupts = < 0 33 0x4 >;
+	};
+
+	uart5: serial@b012a000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb012a000 0x2000>;
+		interrupts = < 0 34 0x4 >;
+	};
+
+	uart6: serial@b012c000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb012c000 0x2000>;
+		interrupts = < 0 35 0x4 >;
+	};
+
+	i2c0: i2c@b0170000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb0170000 0x4000>;
+		interrupts = < 0 25 0x4 >;
+	};
+
+	i2c1: i2c@b0174000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb0174000 0x4000>;
+		interrupts = < 0 26 0x4 >;
+	};
+
+	i2c2: i2c@b0178000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb0178000 0x4000>;
+		interrupts = < 0 27 0x4 >;
+	};
+
+	i2c3: i2c@b017c000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb017c000 0x4000>;
+		interrupts = < 0 28 0x4 >;
+	};
+
+	spi0: spi@b0200000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb0200000 0x4000>;
+		interrupts = < 0 19 0x4 >;
+	};
+
+	spi1: spi@b0204000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb0204000 0x4000>;
+		interrupts = < 0 20 0x4 >;
+	};
+
+	spi2: spi@b0208000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb0208000 0x4000>;
+		interrupts = < 0 21 0x4 >;
+	};
+
+	spi3: spi@b020c000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb020c000 0x4000>;
+		interrupts = < 0 22 0x4 >;
+	};
+
+	gpio: gpio@b01b0000 {
+		compatible = "actions,atm7059a-gpio";
+		reg = < 0xb01b0000 0x40 >;
+		interrupts = <
+			0 36 0x04 /* GPIOA */
+			0 37 0x04 /* GPIOB */
+			0 38 0x04 /* GPIOC */
+			0 39 0x04 /* GPIOD */
+			0 40 0x04 /* GPIOE */ >;
+		#gpio-cells = <2>;
+		gpio-controller;
+		#interrupt-cells = <2>;
+		interrupt-controller;
+	};
+
+	sirq: sirq@b01b0200 {
+		compatible = "actions,owl-sirq";
+		reg = < 0xb01b0200 0x4 >;
+		interrupts = <
+			0 13 0x04  /* SIRQ0 */
+			0 14 0x04  /* SIRQ1 */
+			0 15 0x04  /* SIRQ2 */ >;
+		#interrupt-cells = <2>;
+		interrupt-controller;
+	};
+
+	pwm: pwm@b01b0050 {
+		compatible = "actions,atm7059a-pwm";
+		reg = <0xb01b0050 0x10>;
+		#pwm-cells = <3>;
+	};
+
+	ethernet@b0310000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-ethernet";
+		reg = <0xb0310000 0x10000>;
+	};
+
+	mmc0: mmc@b0230000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-mmc";
+		reg = <0xb0230000 0x38>;
+	};
+
+	mmc1: mmc@b0234000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-mmc";
+		reg = <0xb0234000 0x38>;
+		interrupts = < 0 43 0x4 >;
+	};
+
+	mmc2: mmc@b0238000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-mmc";
+		reg = <0xb0238000 0x38>;
+		interrupts = < 0 44 0x4 >;
+	};
+
+	usb0: usb@b0600000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-usb-2.0-0";
+		reg = <0xb0600000 0x1000>;
+		interrupts = < 0 24 0x4 >;
+	};
+	
+	usb1: usb@b0700000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-usb-2.0-1";
+		reg = <0xb0700000 0x1000>;
+		interrupts = < 0 61 0x4 >;
+	};
+
+	usb@b0400000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,atm7059tc-usb";
+		reg = <0xb0400000 0xcd00>,
+			  <0xb040cd00 0x59>;
+		interrupts = < 0 23 0x4 >;
+	};
+    
+	isp0: isp@b0270000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "actions,owl-isp";
+		reg = <0xb0270000 0x400>,<0xb0160020 0x04>;
+		interrupts = < 0 12 0x4 >;
+	};
+
+	pinctrl@b01b0040 {
+		compatible = "actions,atm7059a-pinctrl";
+	};
+
+	lcd0@b02a0000 {
+		compatible = "actions,owl-lcd";
+		reg = <0xb02a0000 0x20c>;
+		interrupts = < 0 45 0x4 >;
+	};
+
+	dsi@b0220000 {
+		compatible = "actions,owl-dsi";
+		reg = <0xb0220000 0x8c>;
+		interrupts = < 0 51 0x4 >;
+	};
+
+  	backlight {
+		compatible = "actions,owl-pwm-backlight";
+	};
+	
+	gpu@b0300000 {
+		compatible = "actions,atm7039c-gpu";
+		reg = <0xb0300000 0x10000>;
+		interrupts = < 0 3 0x4 >;
+	};
+	
+	vde@b0280000{
+		compatible = "actions,atm7059a-vde";
+		reg = <0xb0280000 0x108>;
+		interrupts = < 0 50 0x4 >;
+	};
+    
+	vce@b0288000{
+		compatible = "actions,atm7059a-vce";
+		reg = <0xb0288000 0x94>;
+		interrupts = < 0 49 0x4 >;
+	};
+  
+	hdmi@b02c0000{
+		compatible = "actions,atm7059a-hdmi";
+		reg = <0xb02c0000 0x160>;
+	};
+	cvbs@b02b0000{
+		compatible = "actions,atm7059a-cvbs";
+		reg = <0xb02b0000 0x80>;
+	};
+	
+	de@b02e0000 {
+		compatible = "actions,atm7059a-de";
+		reg = <0xb02e0000 0x100e>, <0xb0500108 0x4>;
+	};
+	
+	nand@b0210000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "actions,atm7059a-nand";
+		reg = <0xB0210000 0xb4>, <0xB0160000 0xfc>, <0xB01B0000 0x90>, <0xB0260000 0xd00>;
+		interrupts = < 0 41 0x4 >;
+	};
+
+	dma@b0260000 {
+		compatible = "actions,owl-dma";
+		reg = <0xb0260000 0xd00>;
+		interrupts = < 0 57 0x4 >, < 0 58 0x4 >, < 0 59 0x4 >, < 0 60 0x4 >;
+	};
+
+	thermal {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "actions,atm7059a-thermal";
+		reg = <0xb01b00e8 0x8>;
+	};		
+};
diff --git a/arch/arm/boot/dts/actduino_s500_1080p.dts b/arch/arm/boot/dts/actduino_s500_1080p.dts
new file mode 100755
index 0000000..caede83
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_1080p.dts
@@ -0,0 +1,1210 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/				
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <1>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 1>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 1>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;					
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "hdmi";
+		xres=<1920>;
+		yres=<1080>;
+		bpp=<4>;		
+	  
+	};
+		
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 { 
+		status = "disabled";
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		hotplugable = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "1920x1080p-60";
+	};
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		status ="disabled";
+	};
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_720p.dts b/arch/arm/boot/dts/actduino_s500_720p.dts
new file mode 100755
index 0000000..c2cb89e
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_720p.dts
@@ -0,0 +1,1210 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/				
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <1>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 1>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 1>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;					
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "hdmi";
+		xres=<1280>;
+		yres=<720>;
+		bpp=<4>;		
+	  
+	};
+		
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 { 
+		status = "disabled";
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		hotplugable = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "1280x720p-60";
+	};
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		status ="disabled";
+	};
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_lcd_1280x800.dts b/arch/arm/boot/dts/actduino_s500_lcd_1280x800.dts
new file mode 100755
index 0000000..62e1d19
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_lcd_1280x800.dts
@@ -0,0 +1,1248 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0xf 0xf >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <850>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <0>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 1>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 1>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;					
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;	
+			soc5140 = <1>;
+    	};
+    };	
+	
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi_state_default>;
+		dsi_power_gpios = <&gpio 126 1>;    /*hr280ac GPIOD30*/
+		//dsi_reset_gpios = <&gpio 115 0>;   /*S500 GPIOD19*/	
+		port_type = "dsi";	 
+		data_width = <0>;
+		videomode-0 = <&dsi_mode>;
+		hw-set = <&dsi_reg>;
+
+		dsi_reg:val{													
+				dsi_ctrl =< 0x1340>;
+				dsi_size = <0x3200000>;
+				dsi_color = <0xff0000>;
+				dsi_rgbht0 = <0x7878>;
+				dsi_rgbht1 = <0x3e8>;
+				dsi_rgbvt0 = <0x1f0c32c>;
+				dsi_rgbvt1 =<0xa>;
+				dsi_pack_cfg = <0x0>;
+				dsi_pack_header =<0xf00>;
+				dsi_vedio_cfg = <0x30c>;
+				dsi_phy_t0 = <0xa5a>;
+				dsi_phy_t1 =<0x1b12>;
+				dsi_phy_t2 = <0x2f05>;
+				dsi_phy_ctrl = <0xfc94>;
+				dsi_pin_map = <0x688>;
+				cmu_dsipll_clk = <0x12902>;
+
+
+		};
+		
+		dsi_mode:mode@800x1280p60 {
+			refresh = <60>;
+			xres = <1280>;
+			yres = <800>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <15000>;
+			left_margin = <10>;
+			right_margin = <10>;
+			upper_margin = <3>;
+			lower_margin = <3>;
+			hsync_len = <30>;
+			vsync_len = <6>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "auto";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "dsi";
+	};
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		status ="disabled";
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <120>;
+		max_brightness = <450>;
+		dft_brightness = <300>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_lcd_1280x800_linux.dts b/arch/arm/boot/dts/actduino_s500_lcd_1280x800_linux.dts
new file mode 100755
index 0000000..569d3f8
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_lcd_1280x800_linux.dts
@@ -0,0 +1,1249 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <1>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0xf 0xf >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <850>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <0>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 1>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 1>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;					
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;	
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi_state_default>;
+		dsi_power_gpios = <&gpio 126 1>;    /*hr280ac GPIOD30*/
+		//dsi_reset_gpios = <&gpio 115 0>;   /*S500 GPIOD19*/	
+		port_type = "dsi";	 
+		data_width = <0>;
+		videomode-0 = <&dsi_mode>;
+		hw-set = <&dsi_reg>;
+
+		dsi_reg:val{													
+				dsi_ctrl =< 0x1340>;
+				dsi_size = <0x3200000>;
+				dsi_color = <0xff0000>;
+				dsi_rgbht0 = <0x7878>;
+				dsi_rgbht1 = <0x3e8>;
+				dsi_rgbvt0 = <0x1f0c32c>;
+				dsi_rgbvt1 =<0xa>;
+				dsi_pack_cfg = <0x0>;
+				dsi_pack_header =<0xf00>;
+				dsi_vedio_cfg = <0x30c>;
+				dsi_phy_t0 = <0xa5a>;
+				dsi_phy_t1 =<0x1b12>;
+				dsi_phy_t2 = <0x2f05>;
+				dsi_phy_ctrl = <0xfc94>;
+				dsi_pin_map = <0x688>;
+				cmu_dsipll_clk = <0x12601>;
+
+
+		};
+		
+		dsi_mode:mode@800x1280p60 {
+			refresh = <60>;
+			xres = <1280>;
+			yres = <800>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <15000>;
+			left_margin = <10>;
+			right_margin = <10>;
+			upper_margin = <3>;
+			lower_margin = <3>;
+			hsync_len = <30>;
+			vsync_len = <6>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "auto";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "dsi";
+	};
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		status ="disabled";
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <120>;
+		max_brightness = <450>;
+		dft_brightness = <300>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_lcd_1280x800_sdboot.dts b/arch/arm/boot/dts/actduino_s500_lcd_1280x800_sdboot.dts
new file mode 100755
index 0000000..8cc245e
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_lcd_1280x800_sdboot.dts
@@ -0,0 +1,1249 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0xf 0xf >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <850>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <0>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+//		status = "okay";
+		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 1>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 1>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;					
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;	
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi_state_default>;
+		dsi_power_gpios = <&gpio 126 1>;    /*hr280ac GPIOD30*/
+		//dsi_reset_gpios = <&gpio 115 0>;   /*S500 GPIOD19*/	
+		port_type = "dsi";	 
+		data_width = <0>;
+		videomode-0 = <&dsi_mode>;
+		hw-set = <&dsi_reg>;
+
+		dsi_reg:val{													
+				dsi_ctrl =< 0x1340>;
+				dsi_size = <0x3200000>;
+				dsi_color = <0xff0000>;
+				dsi_rgbht0 = <0x7878>;
+				dsi_rgbht1 = <0x3e8>;
+				dsi_rgbvt0 = <0x1f0c32c>;
+				dsi_rgbvt1 =<0xa>;
+				dsi_pack_cfg = <0x0>;
+				dsi_pack_header =<0xf00>;
+				dsi_vedio_cfg = <0x30c>;
+				dsi_phy_t0 = <0xa5a>;
+				dsi_phy_t1 =<0x1b12>;
+				dsi_phy_t2 = <0x2f05>;
+				dsi_phy_ctrl = <0xfc94>;
+				dsi_pin_map = <0x688>;
+				cmu_dsipll_clk = <0x12601>;
+
+
+		};
+		
+		dsi_mode:mode@800x1280p60 {
+			refresh = <60>;
+			xres = <1280>;
+			yres = <800>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <15000>;
+			left_margin = <10>;
+			right_margin = <10>;
+			upper_margin = <3>;
+			lower_margin = <3>;
+			hsync_len = <30>;
+			vsync_len = <6>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "auto";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "dsi";
+	};
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		status ="disabled";
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <120>;
+		max_brightness = <450>;
+		dft_brightness = <300>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_lcd_1280x800_sdboot_linux.dts b/arch/arm/boot/dts/actduino_s500_lcd_1280x800_sdboot_linux.dts
new file mode 100755
index 0000000..abf1890
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_lcd_1280x800_sdboot_linux.dts
@@ -0,0 +1,1249 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <1>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0xf 0xf >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <850>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <0>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+//		status = "okay";
+		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 1>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 1>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;					
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;	
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi_state_default>;
+		dsi_power_gpios = <&gpio 126 1>;    /*hr280ac GPIOD30*/
+		//dsi_reset_gpios = <&gpio 115 0>;   /*S500 GPIOD19*/	
+		port_type = "dsi";	 
+		data_width = <0>;
+		videomode-0 = <&dsi_mode>;
+		hw-set = <&dsi_reg>;
+
+		dsi_reg:val{													
+				dsi_ctrl =< 0x1340>;
+				dsi_size = <0x3200000>;
+				dsi_color = <0xff0000>;
+				dsi_rgbht0 = <0x7878>;
+				dsi_rgbht1 = <0x3e8>;
+				dsi_rgbvt0 = <0x1f0c32c>;
+				dsi_rgbvt1 =<0xa>;
+				dsi_pack_cfg = <0x0>;
+				dsi_pack_header =<0xf00>;
+				dsi_vedio_cfg = <0x30c>;
+				dsi_phy_t0 = <0xa5a>;
+				dsi_phy_t1 =<0x1b12>;
+				dsi_phy_t2 = <0x2f05>;
+				dsi_phy_ctrl = <0xfc94>;
+				dsi_pin_map = <0x688>;
+				cmu_dsipll_clk = <0x12601>;
+
+
+		};
+		
+		dsi_mode:mode@800x1280p60 {
+			refresh = <60>;
+			xres = <1280>;
+			yres = <800>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <15000>;
+			left_margin = <10>;
+			right_margin = <10>;
+			upper_margin = <3>;
+			lower_margin = <3>;
+			hsync_len = <30>;
+			vsync_len = <6>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "auto";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "dsi";
+	};
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		status ="disabled";
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <120>;
+		max_brightness = <450>;
+		dft_brightness = <300>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_lcd_1280x800_uvc.dts b/arch/arm/boot/dts/actduino_s500_lcd_1280x800_uvc.dts
new file mode 100755
index 0000000..b812f34
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_lcd_1280x800_uvc.dts
@@ -0,0 +1,1250 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0xf 0xf >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <2>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <850>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <0>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+//		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 0>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 0>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;					
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi_state_default>;
+		dsi_power_gpios = <&gpio 126 1>;    /*hr280ac GPIOD30*/
+		//dsi_reset_gpios = <&gpio 115 0>;   /*S500 GPIOD19*/	
+		port_type = "dsi";	 
+		data_width = <0>;
+		videomode-0 = <&dsi_mode>;
+		hw-set = <&dsi_reg>;
+
+		dsi_reg:val{													
+				dsi_ctrl =< 0x1340>;
+				dsi_size = <0x3200000>;
+				dsi_color = <0xff0000>;
+				dsi_rgbht0 = <0x7878>;
+				dsi_rgbht1 = <0x3e8>;
+				dsi_rgbvt0 = <0x1f0c32c>;
+				dsi_rgbvt1 =<0xa>;
+				dsi_pack_cfg = <0x0>;
+				dsi_pack_header =<0xf00>;
+				dsi_vedio_cfg = <0x30c>;
+				dsi_phy_t0 = <0xa5a>;
+				dsi_phy_t1 =<0x1b12>;
+				dsi_phy_t2 = <0x2f05>;
+				dsi_phy_ctrl = <0xfc94>;
+				dsi_pin_map = <0x688>;
+				cmu_dsipll_clk = <0x12601>;
+
+
+		};
+		
+		dsi_mode:mode@800x1280p60 {
+			refresh = <60>;
+			xres = <1280>;
+			yres = <800>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <15000>;
+			left_margin = <10>;
+			right_margin = <10>;
+			upper_margin = <3>;
+			lower_margin = <3>;
+			hsync_len = <30>;
+			vsync_len = <6>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		bootable = <1>; 
+		bootrotate = <0>;   
+		default_resolution = "auto";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "dsi";
+	};
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		status ="disabled";
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <120>;
+		max_brightness = <450>;
+		dft_brightness = <300>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_lcd_768x1024.dts b/arch/arm/boot/dts/actduino_s500_lcd_768x1024.dts
new file mode 100755
index 0000000..63678da
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_lcd_768x1024.dts
@@ -0,0 +1,1247 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <1>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/							
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 1>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 1>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;					
+			hi708 = <1>;
+			hi257 = <1>;	
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi_state_default>;
+		dsi_power_gpios = <&gpio 126 1>;    /*hr280ac GPIOD30*/
+		dsi_reset_gpios = <&gpio 115 0>;   /*S500 GPIOD19*/	
+		port_type = "dsi";	 
+		data_width = <1>;
+		videomode-0 = <&dsi_mode>;
+		hw-set = <&dsi_reg>;
+
+		dsi_reg:val{
+			dsi_ctrl = <4944>;
+			dsi_size = <67108864>;
+			dsi_color = <16711680>;
+			dsi_rgbht0 = <461700>;
+			dsi_rgbht1 = <1>;
+			dsi_rgbvt0 = <32588890>;
+			dsi_rgbvt1 = <51>;
+			dsi_pack_cfg = <0>;
+			dsi_pack_header = <2304>;
+			dsi_vedio_cfg = <778>;
+			dsi_phy_t0 = <4699>;
+			dsi_phy_t1 = <6923>;
+			dsi_phy_t2 = <12038>;
+			dsi_phy_ctrl = <64156>;
+			dsi_pin_map = <0x688>;
+			cmu_dsipll_clk = <0x12601>;
+		};
+		
+		dsi_mode:mode@800x1280p60 {
+			refresh = <60>;
+			xres = <768>;
+			yres = <1024>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <12195>;
+			left_margin = <150>;
+			right_margin = <150>;
+			upper_margin = <40>;
+			lower_margin = <40>;
+			hsync_len = <150>;
+			vsync_len = <10>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		bootable = <1>; 
+		bootrotate = <3>;   
+		default_resolution = "auto";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "dsi";
+	};
+	cvbs:cvbs@b02b0000{  
+		default_mode = "PAL";
+		status ="disabled";
+	};
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_lcd_768x1024_linux.dts b/arch/arm/boot/dts/actduino_s500_lcd_768x1024_linux.dts
new file mode 100755
index 0000000..452079a
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_lcd_768x1024_linux.dts
@@ -0,0 +1,1243 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <1>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <1>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/							
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 1>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 1>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;					
+			hi708 = <1>;
+			hi257 = <1>;	
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi_state_default>;
+		dsi_power_gpios = <&gpio 126 1>;    /*hr280ac GPIOD30*/
+		dsi_reset_gpios = <&gpio 115 0>;   /*S500 GPIOD19*/	
+		port_type = "dsi";	 
+		data_width = <1>;
+		videomode-0 = <&dsi_mode>;
+		hw-set = <&dsi_reg>;
+
+		dsi_reg:val{
+			dsi_ctrl = <4944>;
+			dsi_size = <67108864>;
+			dsi_color = <16711680>;
+			dsi_rgbht0 = <461700>;
+			dsi_rgbht1 = <1>;
+			dsi_rgbvt0 = <32588890>;
+			dsi_rgbvt1 = <51>;
+			dsi_pack_cfg = <0>;
+			dsi_pack_header = <2304>;
+			dsi_vedio_cfg = <778>;
+			dsi_phy_t0 = <4699>;
+			dsi_phy_t1 = <6923>;
+			dsi_phy_t2 = <12038>;
+			dsi_phy_ctrl = <64156>;
+			dsi_pin_map = <0x688>;
+			cmu_dsipll_clk = <0x12601>;
+		};
+		
+		dsi_mode:mode@800x1280p60 {
+			refresh = <60>;
+			xres = <768>;
+			yres = <1024>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <12195>;
+			left_margin = <150>;
+			right_margin = <150>;
+			upper_margin = <40>;
+			lower_margin = <40>;
+			hsync_len = <150>;
+			vsync_len = <10>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		bootable = <1>; 
+		bootrotate = <3>;   
+		default_resolution = "auto";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "dsi";
+	};
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_lcd_768x1024_uvc.dts b/arch/arm/boot/dts/actduino_s500_lcd_768x1024_uvc.dts
new file mode 100755
index 0000000..4dbcadf
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_lcd_768x1024_uvc.dts
@@ -0,0 +1,1244 @@
+﻿/dts-v1/;
+
+/include/ "actduino.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+
+		CPU2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x2>;
+			next-level-cache = <&L2>;
+		};
+
+		CPU3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <5>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270 400>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320 450>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN KEY_BACK>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                /* enable/disable ADC key function (okay or disabled) */
+			};
+			atc260x-irkeypad{
+				size = <28>;
+				user_code = <16448>;
+				protocol = <1>;
+				wk_code= <77>;
+				period = <140>;
+				ir_code = <77 67 21 28 11 14 16 17 13 26 69 66 12 1 2 3 4 5 6 7 8 9 0 68 83 18 30 31>;
+				key_code = <116 113 115 114 103 108 105 106 353 172 139 158 14 2 3 4 5 6 7 8 9 10 11 175 139 52 165 163>;
+				compatible = "actions,atc2603c-irkeypad";
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 0>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/	
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <1>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/							
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <300>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    	interrupt-parent = <&sirq>;
+    	interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-power-gpios = <&gpio 85 0>; /* GPIOC21 active  1:low  0:high*/		
+		phy-reset-gpios = <&gpio 84 0>; /* GPIOC20 active  1:low  0:high*/
+
+		phy_addr = <1>;
+		address-bits = <48>;
+		//random-mac-address = "okay";		/*okay:     disable:*/
+		//local-mac-address = [ 00 18 fe 66 66 66 ];   /* if random address is enable,the local address will be unuseful*/
+		max-frame-size = <1518>;
+
+		status = "okay";
+		compatible = "actions,owl-ethernet";
+		
+		phy0: ethernet-phy@0 {
+			compatible = "SR8201G,sr8201g";
+			reg = <0>;
+		};
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+//		status = "disabled";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+  usb@b0600000 { 
+     //vbus_otg_en_gpio = <&gpio 116 0>; /*GPIO D20*/ 
+     port0_host_plug_detect = <2>;
+		 status = "okay";
+   }; 
+   usb@b0700000 { 
+     vbus_otg_en_gpio =<&gpio 116 0>; /*GPIO D20*/ 
+		 status = "disabled";
+   };
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 78 1>;  /* GPIOC14,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 81 0>; /* GPIOC17 */
+		pwdn-front-gpios = <&gpio 79 0>; /* GPIOC15 */
+		reset-gpios = <&gpio 80 1>; /*:GPIOC16*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "okay";
+	};
+
+	sensor-detect {
+		compatible = "sensor_detect";
+		status = "okay";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			bf3703 = <1>;
+			bf3920 = <1>;				
+			hi708 = <1>;
+			hi257 = <1>;
+			ov2686 = <1>;
+			ov5640 = <1>;
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+		
+	lcd0: lcd0@b02a0000 {
+		status = "disabled";
+	};
+
+	dsi: dsi@b0220000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi_state_default>;
+		dsi_power_gpios = <&gpio 126 1>;    /*hr280ac GPIOD30*/
+		dsi_reset_gpios = <&gpio 115 0>;   /*S500 GPIOD19*/	
+		port_type = "dsi";	 
+		data_width = <1>;
+		videomode-0 = <&dsi_mode>;
+		hw-set = <&dsi_reg>;
+
+		dsi_reg:val{
+			dsi_ctrl = <4944>;
+			dsi_size = <67108864>;
+			dsi_color = <16711680>;
+			dsi_rgbht0 = <461700>;
+			dsi_rgbht1 = <1>;
+			dsi_rgbvt0 = <32588890>;
+			dsi_rgbvt1 = <51>;
+			dsi_pack_cfg = <0>;
+			dsi_pack_header = <2304>;
+			dsi_vedio_cfg = <778>;
+			dsi_phy_t0 = <4699>;
+			dsi_phy_t1 = <6923>;
+			dsi_phy_t2 = <12038>;
+			dsi_phy_ctrl = <64156>;
+			dsi_pin_map = <0x688>;
+			cmu_dsipll_clk = <0x12901>;
+		};
+		
+		dsi_mode:mode@800x1280p60 {
+			refresh = <60>;
+			xres = <768>;
+			yres = <1024>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <12195>;
+			left_margin = <150>;
+			right_margin = <150>;
+			upper_margin = <40>;
+			lower_margin = <40>;
+			hsync_len = <150>;
+			vsync_len = <10>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};
+
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+		bootable = <1>; 
+		bootrotate = <3>;   
+		default_resolution = "1080P60HZ";
+	};
+	
+	framebuffer {
+		compatible = "actions,framebuffer";  
+		def_display  = "dsi";
+	};
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 124 0>; /*S500 GPIOD28*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		//wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		//bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		//wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		//reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		//interrupt-parent = <&sirq>;
+		//interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/actduino_s500_probatch.dts b/arch/arm/boot/dts/actduino_s500_probatch.dts
new file mode 100755
index 0000000..acfc728
--- /dev/null
+++ b/arch/arm/boot/dts/actduino_s500_probatch.dts
@@ -0,0 +1,328 @@
+﻿/dts-v1/;
+
+/include/ "actduino_probatch.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <40>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <244>;
+			dma_heap_size = <128>;
+		};
+	};
+    
+
+	
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <3>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <2>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+		status = "disabled";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+		status = "disabled";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";	/* reboot shutdown use it */
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		status = "disabled";
+	};
+
+	i2c@b0178000 {
+		status = "disabled";
+	};
+
+	i2c@b017c000 {
+		status = "disabled";
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*86v S500 GPIOD21 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+	};
+
+	mmc@b0234000 {
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: unified ascii; 1:unified unicode; 2:nounified unicode; 3: nounified ascii*/
+		usb_hs_output_strength = <2>; /*defaut:2,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/atm7059a.dtsi b/arch/arm/boot/dts/atm7059a.dtsi
new file mode 100755
index 0000000..a996cbe
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059a.dtsi
@@ -0,0 +1,370 @@
+/include/ "skeleton.dtsi"
+
+/ {
+	compatible = "actions,atm7059a";
+	interrupt-parent = <&intc>;
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+		serial5 = &uart5;
+		serial6 = &uart6;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		spi2 = &spi2;
+		spi3 = &spi3;
+		dcdc1 = &dcdc1;
+		dcdc2 = &dcdc2;
+		dcdc3 = &dcdc3;
+		dcdc4 = &dcdc4;
+		ldo1 = &ldo1;
+		ldo2 = &ldo2;
+		ldo3 = &ldo3;
+		ldo4 = &ldo4;
+		ldo5 = &ldo5;
+		ldo6 = &ldo6;
+		ldo7 = &ldo7;
+		ldo8 = &ldo8;
+		ldo9 = &ldo9;
+		ldo10 = &ldo10;
+		ldo11 = &ldo11;
+		switch1 = &switch1;
+		switch2 = &switch2;
+		isp0 = &isp0;
+		sdboot = &mmc0;
+		mmc0 = &mmc0;
+		mmc1 = &mmc1;
+		mmc2 = &mmc2;
+		usb0 = &usb0;
+		usb1 = &usb1;
+	};
+
+	cpus {
+		#size-cells = <0>;
+		#address-cells = <1>;
+
+		CPU0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x0>;
+		};
+
+		CPU1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0x1>;
+		};
+	};
+
+	/* look at binding Documentation/devicetree/bindings/arm/gic.txt */
+	intc: interrupt-controller@b0021000 {
+		compatible = "arm,cortex-a9-gic";
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		reg = < 0xb0021000 0x1000 >,
+		      < 0xb0020100 0x0100 >;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a9-pmu";
+		interrupts = <0 4 0x04
+							0 5 0x04
+							0 6 0x04
+							0 7 0x04>;
+	};
+
+	L2: cache-controller@b0022000 {
+		compatible = "arm,pl310-cache";
+		reg = < 0xb0022000 0x1000 >;
+		cache-unified;
+		cache-level = <2>;
+		interrupts = < 0 55 0x4 >;
+		arm,tag-latency = <3 3 2>;
+		arm,data-latency = <5 3 3>;
+	};
+	
+	twd-watchdog@b0020600 {
+		compatible = "actions,atm7059-wdt";
+		reg = <0xb0020600 0x100>, <0xb0160000 0x20>;
+		interrupts = <1 14 0xf01>;
+		wd_type="soft";			//wd_type:"hard" and "soft"
+	};
+	
+	uart0: serial@b0120000 {
+		compatible = "actions,owl-uart", "actions,owl-uart-irc";
+		reg = <0xb0120000 0x2000>;
+		interrupts = < 0 29 0x4 >;
+	};
+
+	uart1: serial@b0122000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0122000 0x2000>;
+		interrupts = < 0 30 0x4 >;
+	};
+
+	uart2: serial@b0124000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0124000 0x2000>;
+		interrupts = < 0 31 0x4 >;
+	};
+
+	uart3: serial@b0126000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0126000 0x2000>;
+		interrupts = < 0 32 0x4 >;
+	};
+
+	uart4: serial@b0128000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb0128000 0x2000>;
+		interrupts = < 0 33 0x4 >;
+	};
+
+	uart5: serial@b012a000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb012a000 0x2000>;
+		interrupts = < 0 34 0x4 >;
+	};
+
+	uart6: serial@b012c000 {
+		compatible = "actions,owl-uart";
+		reg = <0xb012c000 0x2000>;
+		interrupts = < 0 35 0x4 >;
+	};
+
+	i2c0: i2c@b0170000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb0170000 0x4000>;
+		interrupts = < 0 25 0x4 >;
+	};
+
+	i2c1: i2c@b0174000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb0174000 0x4000>;
+		interrupts = < 0 26 0x4 >;
+	};
+
+	i2c2: i2c@b0178000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb0178000 0x4000>;
+		interrupts = < 0 27 0x4 >;
+	};
+
+	i2c3: i2c@b017c000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-i2c";
+		reg = <0xb017c000 0x4000>;
+		interrupts = < 0 28 0x4 >;
+	};
+
+	spi0: spi@b0200000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb0200000 0x4000>;
+		interrupts = < 0 19 0x4 >;
+	};
+
+	spi1: spi@b0204000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb0204000 0x4000>;
+		interrupts = < 0 20 0x4 >;
+	};
+
+	spi2: spi@b0208000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb0208000 0x4000>;
+		interrupts = < 0 21 0x4 >;
+	};
+
+	spi3: spi@b020c000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-spi";
+		reg = <0xb020c000 0x4000>;
+		interrupts = < 0 22 0x4 >;
+	};
+
+	gpio: gpio@b01b0000 {
+		compatible = "actions,atm7059a-gpio";
+		reg = < 0xb01b0000 0x40 >;
+		interrupts = <
+			0 36 0x04 /* GPIOA */
+			0 37 0x04 /* GPIOB */
+			0 38 0x04 /* GPIOC */
+			0 39 0x04 /* GPIOD */
+			0 40 0x04 /* GPIOE */ >;
+		#gpio-cells = <2>;
+		gpio-controller;
+		#interrupt-cells = <2>;
+		interrupt-controller;
+	};
+
+	sirq: sirq@b01b0200 {
+		compatible = "actions,owl-sirq";
+		reg = < 0xb01b0200 0x4 >;
+		interrupts = <
+			0 13 0x04  /* SIRQ0 */
+			0 14 0x04  /* SIRQ1 */
+			0 15 0x04  /* SIRQ2 */ >;
+		#interrupt-cells = <2>;
+		interrupt-controller;
+	};
+
+	pwm: pwm@b01b0050 {
+		compatible = "actions,atm7059a-pwm";
+		reg = <0xb01b0050 0x10>;
+		#pwm-cells = <3>;
+	};
+
+	ethernet@b0310000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-ethernet";
+		reg = <0xb0310000 0x10000>;
+		interrupts = < 0 0 0x4 >, < 0 13 0x4 >;
+	};
+
+	mmc0: mmc@b0230000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-mmc";
+		reg = <0xb0230000 0x38>;
+	};
+
+	mmc1: mmc@b0234000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-mmc";
+		reg = <0xb0234000 0x38>;
+		interrupts = < 0 43 0x4 >;
+	};
+
+	mmc2: mmc@b0238000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-mmc";
+		reg = <0xb0238000 0x38>;
+		interrupts = < 0 44 0x4 >;
+	};
+
+	usb0: usb@b0600000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-usb-2.0-0";
+		reg = <0xb0600000 0x1000>;
+		interrupts = < 0 24 0x4 >;
+	};
+	
+	usb1: usb@b0700000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,owl-usb-2.0-1";
+		reg = <0xb0700000 0x1000>;
+		interrupts = < 0 61 0x4 >;
+	};
+
+	usb@b0400000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,atm7059tc-usb";
+		reg = <0xb0400000 0xcd00>,
+			  <0xb040cd00 0x59>;
+		interrupts = < 0 23 0x4 >;
+	};
+    
+	isp0: isp@b0270000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "actions,owl-isp";
+		reg = <0xb0270000 0x400>,<0xb0160020 0x04>;
+		interrupts = < 0 12 0x4 >;
+	};
+
+	pinctrl@b01b0040 {
+		compatible = "actions,atm7059a-pinctrl";
+	};
+
+	lcd0@b02a0000 {
+		compatible = "actions,owl-lcd";
+		reg = <0xb02a0000 0x20c>;
+		interrupts = < 0 45 0x4 >;
+	};
+
+	dsi@b0220000 {
+		compatible = "actions,owl-dsi";
+		reg = <0xb0220000 0x8c>;
+		interrupts = < 0 51 0x4 >;
+	};
+
+  	backlight {
+		compatible = "actions,owl-pwm-backlight";
+	};
+	
+	gpu@b0300000 {
+		compatible = "actions,atm7039c-gpu";
+		reg = <0xb0300000 0x10000>;
+		interrupts = < 0 3 0x4 >;
+	};
+	
+	vde@b0280000{
+		compatible = "actions,atm7059a-vde";
+		reg = <0xb0280000 0x108>;
+		interrupts = < 0 50 0x4 >;
+	};
+    
+	vce@b0288000{
+		compatible = "actions,atm7059a-vce";
+		reg = <0xb0288000 0x94>;
+		interrupts = < 0 49 0x4 >;
+	};
+  
+	hdmi@b02c0000{
+		compatible = "actions,atm7059a-hdmi";
+		reg = <0xb02c0000 0x160>;
+	};
+	
+	de@b02e0000 {
+		compatible = "actions,atm7059a-de";
+		reg = <0xb02e0000 0x100e>, <0xb0500108 0x4>;
+	};
+	
+	nand@b0210000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "actions,atm7059a-nand";
+		reg = <0xB0210000 0xb4>, <0xB0160000 0xfc>, <0xB01B0000 0x90>, <0xB0260000 0xd00>;
+		interrupts = < 0 41 0x4 >;
+	};
+
+	dma@b0260000 {
+		compatible = "actions,owl-dma";
+		reg = <0xb0260000 0xd00>;
+		interrupts = < 0 57 0x4 >, < 0 58 0x4 >, < 0 59 0x4 >, < 0 60 0x4 >;
+	};
+
+	thermal {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "actions,atm7059a-thermal";
+		reg = <0xb01b00e8 0x8>;
+	};		
+};
diff --git a/arch/arm/boot/dts/atm7059a_demo_86v.dts b/arch/arm/boot/dts/atm7059a_demo_86v.dts
new file mode 100755
index 0000000..d191106
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059a_demo_86v.dts
@@ -0,0 +1,1207 @@
+﻿/dts-v1/;
+
+/include/ "atm7059a.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <24>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <144>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x30>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <2>;/*level 3*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 1>; /* GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xb4 0xb4 >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <1>; /*0:gpio, 1:irq, 2:adc*/				
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+				support_minicharger = < 1 >;						  /* 1:support minicharer  0:do not support minicharger */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <400>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 1400 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-state-mode = <0x1>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 32 0>; /* GPIOB0 */
+
+		address-bits = <48>;
+		local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+
+		phy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8041tl";
+			reg = <0>;
+		};
+	};
+
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 119 0>; /* GPIOD23 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+		status = "okay";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: fixed serial no in ascii format; 1: fixed serial no in unicode format; 2:non-fixed serial no in unicode format*/
+		usb_hs_output_strength = <3>; /*defaut:3,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 19 1>;  /* GPIOA19,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 87 0>; /* GPIOC23 */
+		reset-gpios = <&gpio 20 1>; /*86v:GPIOA20*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0329 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			siv121du = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";
+
+		/*never creat platform device*/
+		status = "disabled";
+
+		ovl_boot {
+			usage = "boot";
+			disp_dev = <&lcd0>;
+		};
+
+		ovl_extra {
+			usage = "extra";
+		};
+
+
+	};
+
+	lcd0: lcd0@b02a0000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&rgb_state_default>;
+		lcd_power_gpios = <&gpio 36 1>;    /* GPIOB4*/ 
+		port_type = "rgb";
+		data_width = <1>;
+
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <0>;
+		hsync_inversion = <0>;
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9521>;
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <5>;
+		lcd_mode0:mode@1024x600p60 {
+			refresh = <60>;
+			xres = <1024>;
+			yres = <600>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <20000>;
+			left_margin = <140>;
+			right_margin = <150>;
+			upper_margin = <10>;
+			lower_margin = <20>;
+			hsync_len = <10>;
+			vsync_len = <5>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+
+	};
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+		
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 16 0>; /* GPIOA16*/
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <100>;
+		max_brightness = <1000>;
+		dft_brightness = <700>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+   };
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/
+		wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <1>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/atm7059a_demo_86v_costdown.dts b/arch/arm/boot/dts/atm7059a_demo_86v_costdown.dts
new file mode 100755
index 0000000..5320583
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059a_demo_86v_costdown.dts
@@ -0,0 +1,1209 @@
+﻿/dts-v1/;
+
+/include/ "atm7059a.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <24>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <144>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x30>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <1>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <0>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 1>; /* GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xb4 0xb4 >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/		
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <1>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+				support_minicharger = < 1 >;						  /* 1:support minicharer  0:do not support minicharger */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <400>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 1400 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-state-mode = <0x1>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 32 0>; /* GPIOB0 */
+
+		address-bits = <48>;
+		local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+
+		phy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8041tl";
+			reg = <0>;
+		};
+	};
+
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "command";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 119 0>; /* GPIOD23 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+		status = "okay";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: fixed serial no in ascii format; 1: fixed serial no in unicode format; 2:non-fixed serial no in unicode format*/
+		usb_hs_output_strength = <3>; /*defaut:3,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 19 1>;  /* GPIOA19,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 87 0>; /* GPIOC23 */
+		reset-gpios = <&gpio 20 1>; /*86v:GPIOA20*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0329 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			siv121du = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";
+
+		/*never creat platform device*/
+		status = "disabled";
+
+		ovl_boot {
+			usage = "boot";
+			disp_dev = <&lcd0>;
+		};
+
+		ovl_extra {
+			usage = "extra";
+		};
+
+
+	};
+
+	lcd0: lcd0@b02a0000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&rgb_state_default>;
+		lcd_power_gpios = <&gpio 36 1>;    /* GPIOB4*/ 
+		lcd_reset_gpios = <&gpio 124 0>; /*GPIOD28*/
+		port_type = "rgb";
+		data_width = <1>;
+		lcdvcc-supply = <&switch1>;
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <0>;
+		hsync_inversion = <0>;
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9521>;
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <5>;
+		lcd_mode0:mode@1024x600p60 {
+			refresh = <60>;
+			xres = <1024>;
+			yres = <600>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <20000>;
+			left_margin = <140>;
+			right_margin = <150>;
+			upper_margin = <10>;
+			lower_margin = <20>;
+			hsync_len = <10>;
+			vsync_len = <5>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+
+	};
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+		
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 16 0>; /* GPIOA16*/
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <300>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+   };
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/
+		wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <1>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/atm7059a_demo_86v_costdown_wvga_dpi120.dts b/arch/arm/boot/dts/atm7059a_demo_86v_costdown_wvga_dpi120.dts
new file mode 100755
index 0000000..ff70861
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059a_demo_86v_costdown_wvga_dpi120.dts
@@ -0,0 +1,1209 @@
+﻿/dts-v1/;
+
+/include/ "atm7059a.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <24>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <144>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x30>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <1>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <0>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 1>; /* GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xb4 0xb4 >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/		
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <1>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/				
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+				support_minicharger = < 1 >;						  /* 1:support minicharer  0:do not support minicharger */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <400>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 1400 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-state-mode = <0x1>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <800>;
+			y_pixel = <480>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 32 0>; /* GPIOB0 */
+
+		address-bits = <48>;
+		local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+
+		phy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8041tl";
+			reg = <0>;
+		};
+	};
+
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "command";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 119 0>; /* GPIOD23 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+		status = "okay";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: fixed serial no in ascii format; 1: fixed serial no in unicode format; 2:non-fixed serial no in unicode format*/
+		usb_hs_output_strength = <3>; /*defaut:3,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 19 1>;  /* GPIOA19,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 87 0>; /* GPIOC23 */
+		pwdn-front-gpios = <&gpio 88 0>; /* GPIOC24 */
+		reset-gpios = <&gpio 20 1>; /*86v:GPIOA20*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0329 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			siv121du = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";
+
+		/*never creat platform device*/
+		status = "disabled";
+
+		ovl_boot {
+			usage = "boot";
+			disp_dev = <&lcd0>;
+		};
+
+		ovl_extra {
+			usage = "extra";
+		};
+
+
+	};
+
+	lcd0: lcd0@b02a0000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&rgb_state_default>;
+		lcd_power_gpios = <&gpio 36 1>;    /* GPIOB4*/ 
+		lcd_reset_gpios = <&gpio 124 0>; /*GPIOD28*/
+		port_type = "rgb";
+		data_width = <1>;
+		lcdvcc-supply = <&switch1>;
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <0>;
+		hsync_inversion = <0>;
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9521>;
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <5>;
+		lcd_mode0:mode@1024x600p60 {
+			refresh = <60>;
+			xres = <800>;
+			yres = <480>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <23333>;
+			left_margin = <160>;
+			right_margin = <160>;
+			upper_margin = <20>;
+			lower_margin = <25>;
+			hsync_len = <70>;
+			vsync_len = <60>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+
+	};
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+		
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 16 0>; /* GPIOA16*/
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+   };
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/
+		wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <1>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/atm7059a_demo_86v_costdown_wvga_dpi160.dts b/arch/arm/boot/dts/atm7059a_demo_86v_costdown_wvga_dpi160.dts
new file mode 100755
index 0000000..ff70861
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059a_demo_86v_costdown_wvga_dpi160.dts
@@ -0,0 +1,1209 @@
+﻿/dts-v1/;
+
+/include/ "atm7059a.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <24>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <144>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x30>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <1>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <0>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 1>; /* GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xb4 0xb4 >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/		
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <1>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/				
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+				support_minicharger = < 1 >;						  /* 1:support minicharer  0:do not support minicharger */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <400>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 1400 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-state-mode = <0x1>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <800>;
+			y_pixel = <480>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 32 0>; /* GPIOB0 */
+
+		address-bits = <48>;
+		local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+
+		phy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8041tl";
+			reg = <0>;
+		};
+	};
+
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "command";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 119 0>; /* GPIOD23 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+		status = "okay";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: fixed serial no in ascii format; 1: fixed serial no in unicode format; 2:non-fixed serial no in unicode format*/
+		usb_hs_output_strength = <3>; /*defaut:3,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 19 1>;  /* GPIOA19,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 87 0>; /* GPIOC23 */
+		pwdn-front-gpios = <&gpio 88 0>; /* GPIOC24 */
+		reset-gpios = <&gpio 20 1>; /*86v:GPIOA20*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0329 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			siv121du = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";
+
+		/*never creat platform device*/
+		status = "disabled";
+
+		ovl_boot {
+			usage = "boot";
+			disp_dev = <&lcd0>;
+		};
+
+		ovl_extra {
+			usage = "extra";
+		};
+
+
+	};
+
+	lcd0: lcd0@b02a0000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&rgb_state_default>;
+		lcd_power_gpios = <&gpio 36 1>;    /* GPIOB4*/ 
+		lcd_reset_gpios = <&gpio 124 0>; /*GPIOD28*/
+		port_type = "rgb";
+		data_width = <1>;
+		lcdvcc-supply = <&switch1>;
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <0>;
+		hsync_inversion = <0>;
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9521>;
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <5>;
+		lcd_mode0:mode@1024x600p60 {
+			refresh = <60>;
+			xres = <800>;
+			yres = <480>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <23333>;
+			left_margin = <160>;
+			right_margin = <160>;
+			upper_margin = <20>;
+			lower_margin = <25>;
+			hsync_len = <70>;
+			vsync_len = <60>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+
+	};
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+		
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 16 0>; /* GPIOA16*/
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+   };
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/
+		wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <1>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/atm7059a_demo_86v_test.dts b/arch/arm/boot/dts/atm7059a_demo_86v_test.dts
new file mode 100755
index 0000000..bbf06ee
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059a_demo_86v_test.dts
@@ -0,0 +1,1207 @@
+﻿/dts-v1/;
+
+/include/ "atm7059a.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <24>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <144>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x30>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <2>;/*level 3*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 1>; /* GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xb4 0xb4 >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <1>; /*0:gpio, 1:irq, 2:adc*/				
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+				support_minicharger = < 1 >;						  /* 1:support minicharer  0:do not support minicharger */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <400>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 1400 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-state-mode = <0x1>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 32 0>; /* GPIOB0 */
+
+		address-bits = <48>;
+		local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+
+		phy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8041tl";
+			reg = <0>;
+		};
+	};
+
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 119 0>; /* GPIOD23 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+		status = "okay";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: fixed serial no in ascii format; 1: fixed serial no in unicode format; 2:non-fixed serial no in unicode format*/
+		usb_hs_output_strength = <3>; /*defaut:3,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 19 1>;  /* GPIOA19,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 87 0>; /* GPIOC23 */
+		reset-gpios = <&gpio 20 1>; /*86v:GPIOA20*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0329 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			siv121du = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";
+
+		/*never creat platform device*/
+		status = "disabled";
+
+		ovl_boot {
+			usage = "boot";
+			disp_dev = <&lcd0>;
+		};
+
+		ovl_extra {
+			usage = "extra";
+		};
+
+
+	};
+
+	lcd0: lcd0@b02a0000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&rgb_state_default>;
+		lcd_power_gpios = <&gpio 36 1>;    /* GPIOB4*/ 
+		port_type = "rgb";
+		data_width = <1>;
+
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <0>;
+		hsync_inversion = <0>;
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9521>;
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <5>;
+		lcd_mode0:mode@1024x600p60 {
+			refresh = <60>;
+			xres = <1024>;
+			yres = <600>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <20000>;
+			left_margin = <140>;
+			right_margin = <150>;
+			upper_margin = <10>;
+			lower_margin = <20>;
+			hsync_len = <10>;
+			vsync_len = <5>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+
+	};
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+		
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 16 0>; /* GPIOA16*/
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <100>;
+		max_brightness = <1000>;
+		dft_brightness = <700>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+   };
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		wifi_bt_power_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		bt_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/
+		wifi_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <1>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/atm7059a_evb.dts b/arch/arm/boot/dts/atm7059a_evb.dts
new file mode 100755
index 0000000..82a32ee
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059a_evb.dts
@@ -0,0 +1,1200 @@
+﻿/dts-v1/;
+
+/include/ "atm7059a.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <24>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <144>;
+			dma_heap_size = <192>;
+		};
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;    /*SIRQ2*/
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				172
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "okay";                    /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 41 1>; /*hr280ac GPIOB9 0: high, 1: low*/
+				earphone_output_mode = <1>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/               
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/          
+				adc_level = <0>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/				
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <1>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+				support_minicharger = < 1 >;						  /* 1:support minicharer  0:do not support minicharger */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2800 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <400>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 1400 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-state-mode = <0x1>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+		
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+		  interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>,<0xb01b0000 0x254>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 32 0>; /* GPIOB0 */
+
+		address-bits = <48>;
+		local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+
+		phy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8041tl";
+			reg = <0>;
+		};
+	};
+
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "command";  /* only: "sirq", "gpio", or "command" */
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+		wl_bt_power_en_gpios = <&gpio 14 0>; /* 86v GPIOA14 */
+		wl_power_en_gpios = <&gpio 18 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+		/*self_card_detect;*/ /* sdio wifi driver detect card */
+
+//		status = "okay";
+		status = "disabled";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b0600000 {
+		vbus_otg_en_gpio = <&gpio 126 0>; /*GPIO D30*/
+		status = "disabled";
+	};
+	usb@b0700000 {
+		vbus_otg_en_gpio =<&gpio 125 0>; /*GPIO D29*/
+		status = "disabled";
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: fixed serial no in ascii format; 1: fixed serial no in unicode format; 2:non-fixed serial no in unicode format*/
+		usb_hs_output_strength = <3>; /*defaut:3,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect,0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 126 1>;  /* GPIOD30,  0: low active; 1: high active */ 
+		//idpin_gpio = <&gpio 63 1>;       /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 87 0>; /* GPIOC23 */
+		reset-gpios = <&gpio 127 1>; /*GPIOD31*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			siv121du = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+
+	framebuffer {
+		compatible = "actions,framebuffer";
+
+		/*never creat platform device*/
+		status = "disabled";
+
+		ovl_boot {
+			usage = "boot";
+			disp_dev = <&lcd0>;
+		};
+
+		ovl_extra {
+			usage = "extra";
+		};
+
+
+	};
+
+	lcd0: lcd0@b02a0000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&lvds_state_default>;
+		lcd_power_gpios = <&gpio 36 0>;    /*hr280ac GPIOB4*/ 
+		port_type = "lvds";
+		data_width = <1>;
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <0>;
+		hsync_inversion = <0>;
+		dclk_inversion = <1>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9521>;
+		lvds_alg_ctl0 = <0xc141a030>;
+		
+		lcd_mode0:mode@800x1280p60 {
+			refresh = <60>;
+			xres = <800>;
+			yres = <1280>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <15625>;
+			left_margin = <40>;
+			right_margin = <20>;
+			upper_margin = <33>;
+			lower_margin = <10>;
+			hsync_len = <12>;
+			vsync_len = <2>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+	};
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+		
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <1>;
+		bit_invert = <0>;
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 20 0>; /*hr280ac GPIOA20*/ 
+		pwms = <&pwm 0 50000 0>;
+		total_steps = <1024>;
+		min_brightness = <200>;
+		max_brightness = <800>;
+		dft_brightness = <600>;
+
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	bluetooth {
+		compatible = "realtek,bluetooth,rtl8723as_vt";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		bt_power_en_gpios = <&gpio 17 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+   };
+//   	wifi_bt_power_ctl {
+//		compatible = "wifi,bt,power,ctl";
+//		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+//		wifi_bt_power_gpios = <&gpio 126 0>, <&gpio 125 0>; /* evb wifi power control */
+//		//bt_en_gpios = <&gpio 22 0>;/*GPIOA22, high active*/
+//		//wifi_en_gpios = <&gpio 17 0>; /* hr280ac GPIOA17 */
+//	};
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/atm7059a_hr820ac_8723bs.dts b/arch/arm/boot/dts/atm7059a_hr820ac_8723bs.dts
new file mode 100755
index 0000000..7338c08
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059a_hr820ac_8723bs.dts
@@ -0,0 +1,1198 @@
+﻿/dts-v1/;
+
+/include/ "atm7059a.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <24>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <144>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <2>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;    /*SIRQ2*/
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 1>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <1>; /*0:gpio, 1:irq, 2:adc*/				
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <1>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+				support_minicharger = < 1 >;						  /* 1:support minicharer  0:do not support minicharger */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <400>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 1400 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-state-mode = <0x1>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <90>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 32 0>; /* GPIOB0 */
+
+		address-bits = <48>;
+		local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+
+		phy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8041tl";
+			reg = <0>;
+		};
+	};
+
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*hr280ac GPIOD23 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+		status = "okay";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: fixed serial no in ascii format; 1: fixed serial no in unicode format; 2:non-fixed serial no in unicode format*/
+		usb_hs_output_strength = <3>; /*defaut:3,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 19 1>;  /* GPIOA19,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 87 0>; /* GPIOC23 */
+		reset-gpios = <&gpio 20 1>; /*86v:GPIOA20*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			siv121du = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";
+
+		/*never creat platform device*/
+		status = "disabled";
+
+		ovl_boot {
+			usage = "boot";
+			disp_dev = <&lcd0>;
+		};
+
+		ovl_extra {
+			usage = "extra";
+		};
+
+
+	};
+
+	lcd0: lcd0@b02a0000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&lvds_state_default>;
+		lcd_power_gpios = <&gpio 36 1>;    /*hr280ac GPIOB4*/ 
+		port_type = "lvds";
+		data_width = <1>;
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <1>;
+		hsync_inversion = <1>;
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9521>;
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <7>;
+		lcd_mode0:mode@1280x800p60 {
+			refresh = <60>;
+			xres = <1280>;
+			yres = <800>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <13400>;
+			left_margin = <20>;
+			right_margin = <20>;
+			upper_margin = <10>;
+			lower_margin = <10>;
+			hsync_len = <30>;
+			vsync_len = <120>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+
+	};
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+		
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 16 0>; /*hr280ac GPIOA16*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <250>;
+		max_brightness = <1000>;
+		dft_brightness = <300>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		wifi_bt_power_gpios = <&gpio 116 0>; /* 86v GPIOA14 */
+		bt_en_gpios = <&gpio 22 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		wifi_en_gpios = <&gpio 17 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/atm7059a_hr820ac_ap6210.dts b/arch/arm/boot/dts/atm7059a_hr820ac_ap6210.dts
new file mode 100755
index 0000000..7f308b6
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059a_hr820ac_ap6210.dts
@@ -0,0 +1,1206 @@
+﻿/dts-v1/;
+
+/include/ "atm7059a.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <24>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <144>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x0>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <1>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <0>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;    
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low hr280ac GPIOA21 0*/
+				speaker_en_gpios = <&gpio 126 1>; /*hr280ac GPIOD(30) 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xaa 0xaa >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <1>; /*0:gpio, 1:irq, 2:adc*/				
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <1>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+				support_minicharger = < 1 >;						  /* 1:support minicharer  0:do not support minicharger */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2800 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <400>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 7730 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-state-mode = <0x1>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <90>;  /* 0 90 180 270 */
+    		interrupt-parent = <&sirq>;
+    		interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 32 0>; /* GPIOB0 */
+
+		address-bits = <48>;
+		local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+
+		phy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8041tl";
+			reg = <0>;
+		};
+	};
+
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "gpio";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 117 0>; /*hr280ac GPIOD23 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+
+		sd_vcc = "switch1";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+
+		status = "okay";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+
+		//gpios = <&gpio 23 0>; /* GPIOA19, 0: high, 1: low only when vbus-src is "gpio" */ /*M3305 Not use*/
+
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: fixed serial no in ascii format; 1: fixed serial no in unicode format; 2:non-fixed serial no in unicode format*/
+		usb_hs_output_strength = <3>; /*defaut:3,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 19 1>;  /* GPIOA19,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		//avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 87 0>; /* GPIOC23 */
+		reset-gpios = <&gpio 20 1>; /*86v:GPIOA20*/
+
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			siv121du = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";
+
+		/*never creat platform device*/
+		status = "disabled";
+
+		ovl_boot {
+			usage = "boot";
+			disp_dev = <&lcd0>;
+		};
+
+		ovl_extra {
+			usage = "extra";
+		};
+
+
+	};
+
+	lcd0: lcd0@b02a0000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&lvds_state_default>;
+		lcd_power_gpios = <&gpio 36 1>;    /*hr280ac GPIOB4*/ 
+		port_type = "lvds";
+		data_width = <1>;
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <1>;
+		hsync_inversion = <1>;
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9521>;
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <7>;
+		lcd_mode0:mode@1280x800p60 {
+			refresh = <60>;
+			xres = <1280>;
+			yres = <800>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <13400>;
+			left_margin = <20>;
+			right_margin = <20>;
+			upper_margin = <10>;
+			lower_margin = <10>;
+			hsync_len = <30>;
+			vsync_len = <120>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+
+	};
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+		
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 16 0>; /*hr280ac GPIOA16*/ 
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <10>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+	};
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		//bt_power_gpio = <&gpio 16 0>;/*GPIOA20, high active*/   /*BT_WAKE*/
+		wifi_bt_power_gpios = <&gpio 116 0>; /* 86v GPIOA14 */
+		bt_en_gpios = <&gpio 22 0>;/*GPIOA17, high active*/  /*M3305 A17 reset pin*/
+		wifi_en_gpios = <&gpio 17 0>; /*gpio_wl_reg_on = <&gpio 18 0>; */ /* 86v GPIOA18 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <2>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_core_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/atm7059c_demo_86v_costdown.dts b/arch/arm/boot/dts/atm7059c_demo_86v_costdown.dts
new file mode 100755
index 0000000..42fe5d1
--- /dev/null
+++ b/arch/arm/boot/dts/atm7059c_demo_86v_costdown.dts
@@ -0,0 +1,1199 @@
+﻿/dts-v1/;
+
+/include/ "atm7059a.dtsi"
+
+/ {
+	model = "Actions GS705A board";
+	compatible = "actions,gs705a", "actions,atm7059a";
+
+	/*default*/
+	chosen {
+		bootargs = "earlyprintk clk_ignore_unused selinux=0";
+	};
+
+	cpus {
+		CPU0: cpu@0 {
+			transition-latency = <61036>; /* two CLK32 periods */
+
+			cpuvdd-supply = <&dcdc1>;
+		};
+	};
+
+	reserved {
+		tiny {
+			fb_heap_size = <4>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <24>;
+			dma_heap_size = <128>;
+		};
+		normal {
+			fb_heap_size = <8>;
+			kinfo_heap_size = <1>;
+			carveout_heap_size = <144>;
+			dma_heap_size = <192>;
+		};
+	};
+	dual_logo {
+		value=<0x30>; /*dual_logo support,=0 disable, >0 enable; */
+	};
+    
+	pinctrl@b01b0040 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&state_default>;
+
+		state_default: pinctrl_default {
+		};
+
+		serial0_state_default: serial0_default{
+			serial_0{
+				actions,groups = "mfp2_2_0","mfp3_21_19";
+				actions,function = "uart0";
+			};
+		};
+
+		serial1_state_default: serial1_default{
+			serial_1{
+				actions,groups = "mfp2_13_11";
+				actions,function = "uart1";
+			};
+		};
+
+		serial2_state_default: serial2_default{
+			serial_2{
+				actions,groups = "mfp2_23","mfp2_22","uart2_dummy";
+				actions,function = "uart2";
+			};
+		};
+
+		serial3_state_default: serial3_default{
+			serial_3{
+				actions,groups = "mfp2_21","mfp2_20","uart3_dummy";
+				actions,function = "uart3";
+			};
+		};
+
+		serial4_state_default: serial4_default{
+			serial_4{
+				actions,groups = "uart4_dummy";
+				actions,function = "uart4";
+			};
+		};
+
+		serial5_state_default: serial5_default{
+			serial_5{
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";
+			};
+		};
+
+		serial6_state_default: serial6_default{
+			serial_6{
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "uart6";
+			};
+		};
+
+		nand_state_default: nand_default {
+			nand_mfp {
+				/*DNAND, D0-D7&RDB&RDBN:mfp3_3, ALE&CLE&CEB0&CEB1:mfp3_2, CEB2:mfp3_1_0_nand_ceb2, CEB3:mfp3_1_0_nand_ceb3*/
+				actions,groups = "nand_dummy", "mfp3_3", "mfp3_2", "mfp3_1_0_nand_ceb2", "mfp3_1_0_nand_ceb3";
+				actions,function = "nand";
+			};
+
+			nand_rdbn_ce0_ce2_pullup_disable {
+				actions,pins = "P_DNAND_RDBN";
+				actions,pull = <0>;	//disabled
+			};
+
+			nand_dqsn_pullup {
+				actions,pins = "P_DNAND_DQSN";
+				actions,pull = <2>;	//pull up
+			};
+			
+			nand_dqs_pulldown {
+				actions,pins = "P_DNAND_DQS";
+				actions,pull = <1>;	//pull down
+			};
+			nand_d0_d3_pulldown {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7";
+				actions,pull = <0>;	//disabled
+			};
+		};
+
+		ethernet_state_default: ethernet_default {
+			ethernet_smi { /* pins: MDC & MDIO */
+				actions,groups = "eth_smi_dummy";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txd01 {
+				actions,groups = "mfp0_18_16_eth_txd0", "mfp0_18_16_eth_txd1";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_txen_rxer {
+				actions,groups = "mfp0_15_13_rmii_txen", "mfp0_15_13_rmii_rxen";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_crs_dv {
+				actions,groups = "mfp0_22_20";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_rxd10 {
+				actions,groups = "mfp0_10_8_rmii_rxd1", "mfp0_10_8_rmii_rxd0";
+				actions,function = "eth_rmii";
+			};
+
+			ethernet_rmii_ref_clk {
+				actions,groups = "mfp0_7_6";
+				actions,function = "eth_rmii";
+			};
+		};
+
+		mmc_share_uart_state: mmc_share_uart {
+			sd0_mfp_cmd_clk {
+				actions,groups = "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_CMD";
+				actions,pull = <2>;
+			};	
+			
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+			
+			// 如果以后使用uart2请修改这个地方到uart2配置，现在默认是uart5
+			serial_5 {
+				actions,groups = "mfp2_19_17","mfp2_16_14";
+				actions,function = "uart5";   
+			};
+		};
+		mmc0_state_default: mmc0_default {
+			sd0_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_19_17", "mfp2_16_14", "mfp2_13_11", "mfp2_8_7", "mfp2_6_5";
+				actions,function = "sd0";
+			};
+
+			sd0_pull_d0_d3_cmd {
+				actions,pins = "P_SD0_D0", "P_SD0_D1", "P_SD0_D2", "P_SD0_D3", "P_SD0_CMD";
+				actions,pull = <2>;
+			};
+
+			sd0_pull_clk {
+				actions,pins = "P_SD0_CLK";
+				actions,pull = <0>;
+			};
+			
+			sd0_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_23_22","paddrv1_19_18","paddrv1_17_16";
+				actions,paddrv  = <1>; /*level 1，范围0~3*/ 			
+			};
+		};
+
+		mmc1_state_default: mmc1_default {
+			sd1_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp2_10_9", "mfp2_4_3", "sd1_dummy";
+				actions,function = "sd1";
+			};
+
+			sd1_pull_d0_d3_cmd {
+				actions,pins = "P_SD1_D0", "P_SD1_D1", "P_SD1_D2", "P_SD1_D3", "P_SD1_CMD";
+				actions,pull = <2>;
+			};
+			sd1_d0_d3_cmd_clk_paddrv  {
+				actions,groups  = "paddrv1_21_20","paddrv1_15_14","paddrv1_13_12";
+				actions,paddrv  = <1>; /*level 1，范围0~2*/ 			
+			};
+		};
+	
+		mmc2_state_default: mmc2_default {
+			sd2_mfp_d0_d3_cmd_clk {
+				actions,groups = "mfp3_3";
+				actions,function = "sd2";
+			};
+
+			sd2_pull_d0_d3_cmd {
+				actions,pins = "P_DNAND_D0","P_DNAND_D1","P_DNAND_D2","P_DNAND_D3","P_DNAND_D4","P_DNAND_D5","P_DNAND_D6","P_DNAND_D7","P_DNAND_RDBN";
+				actions,pull = <2>;
+			};
+
+		};
+
+		/* the format of isp state name: channel + pin + bus type(pin function) */
+		/* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+		isp0_state_csi_dvp: isp0_csi_dvp {
+			isp0_csi_dvp_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_23_22", "mfp3_15_14", "mfp3_13_12";
+				actions,function = "sens0";
+			};
+			sens0_clk_out_pdrv{
+				 actions,groups = "paddrv2_13_12";
+				 actions,paddrv = <0>;/*level 1 ,range :0~2*/
+			};
+		};
+
+		isp0_state_csi_mipi: isp0_csi_mipi {
+			isp0_csi_mipi_mfp {
+				actions,groups = "mfp3_29_28", "mfp3_15_14";
+				actions,function = "mipi_csi";
+			};
+			isp0_csi_mipi_clkout_mfp {
+				actions,groups = "mfp3_23_22";
+				actions,function = "sens0";
+			};
+		};
+
+		i2c0_state_default: i2c0_default {/* i2c0 use default pin	*/
+			i2c0_default_mfp {
+				actions,groups = "mfp3_18_16";
+				actions,function = "i2c0";
+			};
+
+			i2c0_default_paddrv {
+				actions,groups = "paddrv2_24_23";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_default_pull_up {
+				actions,pins = "P_I2C0_SCLK","P_I2C0_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+
+		i2c0_state_over_uart0: i2c0_over_uart0 {/* i2c0 use uart0 pin	*/
+			i2c0_over_uart0_mfp {
+				actions,groups = "mfp2_2_0", "mfp3_21_19";
+				actions,function = "i2c0";
+			};
+
+			i2c0_over_uart0_paddrv {
+				actions,groups = "paddrv2_31_30","paddrv2_29_28";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c0_over_uart0_pull_up {
+				actions,pins = "P_UART0_RX","P_UART0_TX";
+				actions,pull = <2>; /*pull up*/
+			};
+		};	
+
+		i2c1_state_default: i2c1_default {/* i2c1 use default pin	*/
+			i2c1_default_mfp {
+				actions,groups = "i2c1_dummy";
+				actions,function = "i2c1";
+			};
+
+			i2c1_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c1_default_pull_up {
+				actions,pins = "P_I2C1_SCLK","P_I2C1_SDATA";
+				actions,pull = <0>;	/*stay disabled*/
+			};
+		};
+
+		i2c2_state_default: i2c2_default {/* i2c2 use default pin*/
+			i2c2_default_mfp {
+				actions,groups = "i2c2_dummy";
+				actions,function = "i2c2";
+			};
+
+			i2c2_default_paddrv {
+				actions,groups = "paddrv2_22_21";
+				actions,paddrv = <0>;/*level 1*/
+			};
+
+			i2c2_default_pull_up {
+				actions,pins = "P_I2C2_SCLK","P_I2C2_SDATA";
+				actions,pull = <2>; /*pull up*/
+			};
+		};
+		
+		i2c3_state_over_spi0: i2c3_over_spi0 {/* i2c3 use spi0 pin	*/
+			i2c3_over_spi0_mfp {
+				actions,groups = "mfp1_4_3";
+				actions,function = "i2c3";
+			};
+
+			i2c3_over_spi0_paddrv {
+				actions,groups = "paddrv1_11_10";
+				actions,paddrv = <1>;/*level 1*/
+			};
+
+			i2c3_over_spi0_pull_up {
+				actions,pins = "P_SPI0_SCLK","P_SPI0_MOSI";
+				actions,pull = <0>; /*pull up*/
+			};
+		};				
+
+		pwm0_state_default: pwm0_default {
+			pwm0_mfp {
+				actions,groups = "mfp1_31_29_ks_in2";
+				actions,function = "pwm0";
+			};
+		};
+
+		pwm1_state_default: pwm1_default {
+			pwm1_mfp {
+				actions,groups = "mfp1_28_26_ks_in3";
+				actions,function = "pwm1";
+			};
+		};
+		pwm2_state_default: pwm2_default {
+			pwm2_mfp {
+				actions,groups = "mfp1_25_23";
+				actions,function = "pwm2";
+			};
+		};
+		pwm3_state_default: pwm3_default {
+			pwm3_mfp {
+				actions,groups = "mfp1_28_26_ks_out1";
+				actions,function = "pwm3";
+			};
+		};
+		lvds_state_default: lvds_default {
+			lvds_mux {
+				actions,groups = "mfp1_22_21", "mfp1_6_5", "mfp2_28_27";
+				actions,function = "lvds";
+			};
+		};
+		i2s0_state_default: i2s0_default {
+			i2s0_default_mfp {
+				actions,groups = "mfp0_2_1_i2s0", "mfp0_4_3", "mfp0_5";
+				actions,function = "i2s0";
+			};
+		};
+		rgb_state_default: rgb_default {
+			rgb_mux {
+				actions,groups = "mfp0_25_23","mfp1_16_14", "mfp1_22_21", "mfp1_13_12", "mfp1_11_10", "mfp1_6_5", "mfp2_30_29", "mfp2_28_27";
+				actions,function = "lcd0";
+			};
+		};
+		
+		dsi_state_default: dsi_default {
+			dsi_mux {
+				actions,groups = "mfp1_20_19", "mfp1_18_17", "mfp1_13_12", "mfp1_11_10", "mfp1_9_7", "mfp2_30_29";
+				actions,function = "dsi";
+			};
+		};
+	};
+
+	serial@b0120000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial0_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0122000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial1_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b0124000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial2_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	/*for BT*/
+	serial@b0126000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial3_state_default>;
+		actions,enable-dma-rx;
+		status = "okay";
+	};
+
+	serial@b0128000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial4_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	serial@b012a000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial5_state_default>;
+//		actions,enable-dma-rx;
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	serial@b012c000 {
+		clock-frequency = <48000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&serial6_state_default>;
+//		actions,enable-dma-rx;
+		status = "disabled";
+	};
+
+	i2c@b0170000 {
+		i2c_num = <0>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_state_default>;
+		#address-cells = <1>;
+		#size-cells = <0>;	
+		
+		/* atc2603c (5307) */
+		atc260x: atc2603c@65 {
+			compatible = "actions,atc2603c";
+			reg = <0x65>;
+			interrupt-parent = <&sirq>;
+			interrupts =< 2 0x4 >;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+
+			losc_32k_output_enable = <1>;    /* enable/disable output 32.768K clock via I2S_MCLK1 pin */
+			losc_32k_output_voltage = <18>;  /* select voltage scale of the 32.768K clock output, 18:1.8v, 31:3.1v */
+
+			pm {
+				compatible = "actions,atc2603c-pm";
+			};
+
+			onoff {
+				compatible = "actions,atc2603c-onoff";
+			};
+
+			rtc{
+				compatible = "actions,atc2603c-rtc";
+			};
+
+			atc260x_gpio: atc260x_gpio {
+				compatible = "actions,atc2603c-gpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			atc260x_sgpio: atc260x_sgpio {
+				compatible = "actions,atc2603c-sgpio";
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			atc260x-adckeypad{
+#define KEY_HOME				102
+#define KEY_MENU				139
+#define KEY_BACK				158
+#define KEY_VOLUMEDOWN				114
+#define KEY_VOLUMEUP				115
+				keymapsize = <4>;                   /* number of ADC key */
+				filter_dep = <3>;                   /* depth of the moving average filter (length of filter queue) */
+				variance = <10>;                    /* filter will not output until the difference between every two ADC samples in the filter queue goes below this value */
+				poll_interval =  <10>;              /* sample period, in ms */
+				left_adc_val =  <0 90 175 270>;     /* for key code translator, each value defines a lower bound of ADC value of a key */
+				right_adc_val = <30 120 220 320>;   /* for key code translator, each value defines a upper bound of ADC value of a key */
+				key_val = <KEY_HOME KEY_MENU KEY_VOLUMEUP KEY_VOLUMEDOWN>; /* for key code translator, each value defines the key_code of a key */
+				adc_channel_name = "AUX0";          /* the ADC channel used for sampling, valid names are REMCON AUX0 AUX1 AUX2 (AUX3) */
+				compatible = "actions,atc2603c-adckeypad";
+				status = "disabled";                /* enable/disable ADC key function (okay or disabled) */
+			};
+
+			/*the cfg params must be read	in the first installed ko,
+			 now snd-soc-atv5302.ko is first installed.
+			 1, earphone_detect_level use the third value of earphone_gpios
+			 2, commonly, we shouldn't change the value of speaker_gain and earphone_gain*/
+			
+			atc260x-audio{
+				compatible = "actions,atc2603c-audio";
+				status = "okay";
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&i2s0_state_default>;				
+				//earphone_detect_gpios = <&gpio 21 0>; /*0: high, 1: low GPIOA21 0*/
+				speaker_en_gpios = <&gpio 70 1>; /* GPIOC6 0: high, 1: low*/
+				earphone_output_mode = <0>; /*0: direct mode, 1: undirect mode*/
+				mic_num = <1>; /*just suport 1, 2*/
+				mic0_gain = < 0x7 0x7 >; /*<Lchannel,Rchannel> [0x0~0xF]*/
+				speaker_gain = < 0xb4 0xb4 >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				earphone_gain = < 0xbe 0xbe >; /*<Lchannel,Rchannel>[0x00~0xbebe]*/
+				mic_mode = <1>; /* 1: differential,  2: single end*/
+				earphone_detect_method = <2>; /*0:gpio, 1:irq, 2:adc*/		
+				adc_plugin_threshold = <900>; /*adc earphone detect plugin threshold value*/		
+				adc_level = <1>; /*adc plugin level, 1:high vol when plugin; 0:low vol when plug in*/
+			};
+
+			atc260x-hwmon{
+				compatible = "actions,atc2603c-hwmon";
+			};
+
+			atc260x-power{
+				compatible = "actions,atc2603c-power";
+				bl_on_usb_pc_max_charge_current = < 200 >;        /*mA,plug usb-pc,backlight is on*/
+				bl_off_usb_pc_max_charge_current = < 500 >;       /*mA,plug usb-pc,backlight is off*/
+				bl_on_usb_adp_max_charge_current = <400>;         /*mA,plug usb-adapter,backlight is on */
+				bl_off_usb_adp_max_charge_current = <800>;        /*mA,plug usb-adapter,backlight is off */
+				bl_on_wall_adp_max_charge_current = <400>;        /*mA,plug DCIN adapter,backlight is on*/
+				bl_off_wall_adp_max_charge_current = < 1400 >;    /*mA,plug DCIN adapter,backlight is off*/
+				bl_on_voltage_diff  = <350>;                      /*mV,different voltage between SYSPOWR and battery,backlight is on*/
+				bl_off_voltage_diff = <400>;                      /*mV,different voltage between SYSPOWR and battery,backlight is off*/
+				support_adaptor_type = <3>;                       /*1: DCIN  2: USB  3:DCIN+USB*/
+				boot_cap_threshold = <3>;                         /*3%,the lowest capacity permitted to boot*/ 
+				ext_dcdc_exist = <0>;                             /*1:exist external dcdc  0:do not exist external dcdc*/
+				pwms = <&pwm 3 2666 1>;                           /* 3--pwm3   2666ns--1/(24M/64)*1000000000-1   1- -active low*/
+				pwm-names = "ext_dcdc_pwm_ctl";                   /* pwm name */
+				ext_charger_exist = <0>;                          /* 1:exist external charger  0:do not exist external charger*/
+				charger_led_exist = <0>;                          /* 1:exist charger led 0:do not exist charger led */
+				support_minicharger = < 1 >;						  /* 1:support minicharer  0:do not support minicharger */
+			};
+
+			atc260x-cap-gauge{
+				compatible = "actions,atc2603c-cap-gauge";
+				capacity = < 2500 >;                              /*mAh, the full capacity of battery used*/
+				icm_available= < 1 >;							  /* 1:available 0:not available */ 
+				icm_ohm_val = < 20 >;                             /*mohm,just 20 or 10,for ICM detecting current*/
+				taper_voltage = < 4200 >;                         /*mV,the one close to the full capacity*/
+				taper_current = <400>; 
+				min_over_chg_protect_voltage = < 4275 >;				/*mA,the one close to the full capacity*/
+				terminal_voltage = <3450>;                        /*mV,the lowest voltage of battery permitted*/
+				suspend_current = < 1400 >;                       /* uA,the current of suspend*/
+				shutdown_current = < 50 >;                        /* uA,the current of shutdown*/
+				print_switch = <0>;                               /*0:open the switch of printing information 1:the opposite*/
+				log_switch = <0>;                                 /*0:open the switch of recording charging log 1:the opposite*/
+				
+				ocv_soc_00 = <3477 3534 3591 3624 3637 3649 3661 3667 3673 3677>;    	 /* capacity:from 1% to 10%*/
+				ocv_soc_10 = <3682 3685 3690 3693 3700 3706 3712 3716 3722 3728 >;	 /* capacity:from 11% to 20%*/
+				ocv_soc_20 = <3732 3736 3739 3744 3747 3751 3755 3758 3761 3765>;	 /* capacity:from 21% to 30%*/
+				ocv_soc_30 = <3768 3771 3775 3777 3782 3784 3788 3791 3793 3794 >;	 /* capacity:from 31% to 40%*/
+				ocv_soc_40 = <3800 3801 3804 3807 3812 3815 3819 3823 3825 3830>;	 /* capacity:from 41% to 50%*/
+				ocv_soc_50 = <3834 3838 3841 3845 3850 3854 3858 3864 3870 3874>;	 /* capacity:from 51% to 60%*/
+				ocv_soc_60 = <3880 3889 3895 3902 3908 3916 3926 3933 3940 3947>;	 /* capacity:from 61% to 70%*/
+				ocv_soc_70 = <3954 3961 3968 3972 3979 3985 3992 3997 4005 4012>;	 /* capacity:from 71% to 80%*/
+				ocv_soc_80 = <4019 4028 4036 4046 4054 4061 4068 4075 4084 4090>;	 /* capacity:from 81% to 90%*/
+				ocv_soc_90 = <4099 4107 4115 4126 4132 4141 4152 4160 4170 4180>;	 /* capacity:from 91% to 100%*/
+				
+			};
+
+			atc260x-backup{
+				compatible = "actions,atc2603c-backup";
+				status = "disabled";
+			};
+ 
+			vdd_gpu_dcdc: vdd-gpu-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc1","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-gpu-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 1 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250000>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			vdd_core_dcdc: vdd-core-dcdc {
+				compatible = "actions,atc2603c-ext-pwm-dcdc2","actions,atc2603c-ext-pwm-dcdc";
+				regulator-name = "vdd-core-dcdc";
+				regulator-min-microvolt  = <900000>;
+				regulator-max-microvolt = <1250000>;
+				regulator-always-on;
+				pwms = <&pwm 2 2666 0>;	// 1-pwm1   2666-1/(24M/64)*1000000-1   0 -active high
+				table_len = < 15 >;			//length of vdd_cpu_table & pwm_config_table
+				vdd_cpu_table = <900000 925000 950000 975000 1000000 1025000 1050000 1075000 1100000 1125000 1150000 1175000 1200000 1225000 1250001>;	//uV
+				pwm_config_table = <19 18 17 16 15 14 13 12 11 10 9 8 7 6 5>;	//the pwm period of 1.1v 1.2v 1.3v
+			};
+ 
+			dcdc1: dcdc1 {
+				compatible = "actions,atc2603c-dcdc1","actions,atc2603c-dcdc";
+				regulator-name = "dcdc1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-state-mode = <0x1>;
+				regulator-always-on;
+			};
+
+			dcdc2: dcdc2 {
+				compatible = "actions,atc2603c-dcdc2","actions,atc2603c-dcdc";
+				regulator-name = "dcdc2";
+				regulator-min-microvolt = <1300000>;
+				regulator-max-microvolt = <2200000>;
+				regulator-always-on;
+			};
+
+			dcdc3: dcdc3 {
+				compatible = "actions,atc2603c-dcdc3","actions,atc2603c-dcdc";
+				regulator-name = "dcdc3";
+				regulator-min-microvolt = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			dcdc4: dcdc4 {
+				status = "disabled";
+			};
+
+			dcdc5: dcdc5 {
+				status = "disabled";
+			};
+
+			ldo1: ldo1{
+				compatible = "actions,atc2603c-ldo1","actions,atc2603c-ldo";
+				regulator-name = "ldo1";
+				regulator-min-microvolt  = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-always-on;
+			};
+
+			ldo2: ldo2{
+				compatible = "actions,atc2603c-ldo2","actions,atc2603c-ldo";
+				regulator-name = "ldo2";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			ldo3: ldo3{
+				compatible = "actions,atc2603c-ldo3","actions,atc2603c-ldo";
+				regulator-name = "ldo3";
+				regulator-min-microvolt  = <1500000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-always-on;
+			};
+
+			ldo4: ldo4{
+				status = "disabled";
+			};
+
+			ldo5: ldo5{
+				compatible = "actions,atc2603c-ldo5","actions,atc2603c-ldo";
+				regulator-name = "ldo5";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo6: ldo6{
+				compatible = "actions,atc2603c-ldo6","actions,atc2603c-ldo";
+				regulator-name = "ldo6";
+				regulator-min-microvolt  = <700000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-always-on;
+			};
+
+			ldo7: ldo7{
+				compatible = "actions,atc2603c-ldo7","actions,atc2603c-ldo";
+				regulator-name = "ldo7";
+				regulator-min-microvolt  = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-suspend-off;
+			};
+
+			ldo8: ldo8{
+				compatible = "actions,atc2603c-ldo8","actions,atc2603c-ldo";
+				regulator-name = "ldo8";
+				regulator-min-microvolt  = <2300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			ldo9: ldo9{
+				status = "disabled";
+			};
+
+			ldo10: ldo10{
+				status = "disabled";
+			};
+
+			ldo11: ldo11{
+				compatible = "actions,atc2603c-ldo11","actions,atc2603c-ldo";
+				regulator-name = "ldo11";
+				regulator-min-microvolt  = <2600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			switch1:switch1{
+				compatible = "actions,atc2603c-switch1","actions,atc2603c-switch";
+				regulator-name = "switch1";
+				regulator-min-microvolt  = <3000000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			switch2:switch2{
+				status = "disabled";
+			};
+		};
+	};
+	
+	i2c@b0174000 {
+		i2c_num = <1>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_state_default>;
+			
+		ft5x06@38 {
+			compatible = "ft5x06";
+			reg = <0x38>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>; /*GPIOB(3) 0: high, 1: low*/
+			max_points = <10>;
+			x_pixel = <1280>;
+			y_pixel = <800>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <180>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+
+		gslX680@40 {
+			compatible = "gslX680";
+			reg = <0x40>;
+			tp_vcc = "ldo5";
+			reset_gpios = <&gpio 35 1>;/*GPIOB(3) 0: high, 1: low*/
+			x_pixel = <1024>;
+			y_pixel = <600>;
+			x_revert_en = <0>;
+			y_revert_en = <0>;
+			xy_swap_en = <0>;
+			rotate_degree = <270>;  /* 0 90 180 270 */
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			vol_range = <3100000 3110000>;
+		};
+	};
+
+	i2c@b0178000 {
+		i2c_num = <2>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2_state_default>;
+
+		bma222@18{
+			compatible = "bma222";
+			reg = <0x18>;
+			position = "-2";
+			calibration_table = <0 0 0>;
+		};
+
+		stk8313@22{		
+			compatible = "stk8313";
+			reg = <0x22>;
+			position = "1";
+			calibration_table = <0 0 0>;			
+		};
+
+		mc323x@4c{		
+			compatible = "mc323x";
+			reg = <0x4c>;
+			position = "-3";
+			calibration_table = <0 0 0>;			
+		};
+
+		mpu6515@68{
+			compatible = "owl-gyrosensor";
+			interrupt-parent = <&sirq>;
+			interrupts =< 1 0x4 >; /*SIRQ1*/
+			i2c_adapter_id = <2>;
+			MASTER_inv6515_position = "-1";
+			SECONDARY_ak8963c_position = "-2";
+		};
+		
+		mir3da@27{
+			compatible = "mir3da";
+			reg = <0x27>;
+			position = "-3";
+			calibration_table = <0 0 0>;
+		};
+	};
+
+	i2c@b017c000 {
+		i2c_num = <3>;
+		clock-frequency = <400000>;
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3_state_over_spi0>;
+		eg2801_eeprom@14 {
+                	compatible ="actions,eg2801_eeprom";
+			reg = <0x14>;
+                };
+
+                eg2801_ram@55 {
+                	compatible ="actions,eg2801_ram";
+                	reg = <0x55>;
+                };
+		
+		hdmi_read_edid@30 {
+			compatible = "actions,hdmi_read_edid";
+			reg = <0x30>;
+		};	
+	};
+
+	spi@b0200000 {
+		status = "disabled";
+	};
+
+	spi@b0204000 {
+		status = "disabled";
+	};
+	
+	gl5203-audio-i2s{
+		#address-cells = <1>;
+		#size-cells = <1>; 
+		compatible = "actions,owl-audio-i2s";
+		reg = <0xb0100000 0x34>;
+	};
+
+	spi@b0208000 {
+		status = "disabled";
+	};
+
+	spi@b020c000 {
+		status = "disabled";
+	};
+
+	gpio@b01b0000 {
+		status = "okay";
+	};
+
+	nand@b0210000 {
+		clock-source = "NANDPLL";
+		pinctrl-names = "default";
+		pinctrl-0 = <&nand_state_default>;
+		status = "okay";
+
+		reset_protect {
+			interrupt-parent = <&sirq>;
+			interrupts =< 0 0x4 >; /*SIRQ0*/
+			status = "disabled";
+		};
+	};
+
+	ethernet@b0310000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&ethernet_state_default>;
+
+		phy-mode = "rmii";
+		phy-handle = <&phy0>;
+		phy-reset-gpios = <&gpio 32 0>; /* GPIOB0 */
+
+		address-bits = <48>;
+		local-mac-address = [ 00 18 fe 66 66 66 ];
+		max-frame-size = <1518>;
+
+		status = "okay";
+
+		phy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8041tl";
+			reg = <0>;
+		};
+	};
+
+
+	mmc@b0230000 {
+		pinctrl-names = "default","share_uart2_5";
+		pinctrl-0 = <&mmc0_state_default>;
+		pinctrl-1 = <&mmc_share_uart_state>;
+
+		card_type = "memory";  /* only: "memory", "wifi", or "emmc" */
+		card_detect_mode = "command";  /* only: "sirq", "gpio", or "command" */
+		card_detect_gpios = <&gpio 119 0>; /* GPIOD23 */  
+		interrupts = < 0 42 0x4 >;
+
+		status = "okay";
+		sdio_uart_supported;
+	};
+
+	mmc@b0234000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_state_default>;
+		card_type = "wifi";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	mmc@b0238000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc2_state_default>;
+		card_type = "emmc";  /* only: "memory", "wifi", or "emmc" */
+		status = "okay";
+	};
+
+	usb@b02b8000 {
+		vbus-src = "gpio";  /* only: "gpio", "regulator", or "none" */
+		vbus-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		regulator-scope = <3300000 3500000>;  /* uV */
+		status = "disabled"; /* don't create platform-device */
+	};
+
+	usb@b0400000 {
+		usb_serialnumber_config = <1>; /* config serialnumber string format, 0: fixed serial no in ascii format; 1: fixed serial no in unicode format; 2:non-fixed serial no in unicode format*/
+		usb_hs_output_strength = <3>; /*defaut:3,range:0~7; 0:min,7:max;usb high speed(2.0)transmitter output strength*/
+		status = "okay";
+	};
+
+	monitor {
+		compatible = "actions,atm7059tc-usbmonitor";
+		detect_type = <3>; /* config what to detect, 0:DISABLE ; 1:DEVICE_ONLY; 2:HOST_ONLY; 3: HOST_AND_DEVICE*/
+		idpin_type   = <0>; /* 0:use ic's idpin;      1:soft idpin,##no support!##;       2:gpio idpin,use gpio to detect,need to add a "idpin_gpio" configuration */
+		vbus_type   = <2>; /* 0:use ic's vbuspin; 1:gpio vbus,##no support!## ;      2:use dc5v to detect vbus level*/
+		
+		/*vbus_otg_en_gpio is use to turn on/off otg vbus,it's different from vbus detect gpio;*/  
+		vbus_otg_en_gpios = <&gpio 120 1>;  /* GPIOD24,  0: low active; 1: high active */
+		//idpin_gpio = <&gpio 63 1>;   /*if idpin detect by gpio,config the gpio to GPIOB31, input,0: low active; 1: high active*/
+		status = "okay";
+	};
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+		avdd-regulator = "ldo1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "ldo7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */		
+		pwdn-rear-gpios = <&gpio 88 0>; /* GPIOC24 */
+		pwdn-front-gpios = <&gpio 87 0>; /* GPIOC23 */
+		reset-gpios = <&gpio 121 1>; /*86v: GPIOD25*/
+
+		status = "okay"; /* create platform-device */
+	};
+	
+	sensors: isp-sensor {
+		compatible = "sensor_common";
+		bus_type = "dvp";  /* dvp or mipi */
+		data_type = "yuv";  /* yuv or raw */
+		host = <&isp0>; /* only isp0 if there is one host, isp0 or isp1 if two hosts */
+		i2c_adapter = <&i2c2>; /* 0-3 begin from enabled ones */
+		channel = <0>; /* 0: use channel_0, 1: use channel_1 */
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&isp0_state_csi_dvp>;
+
+		status = "disabled";
+	};
+	sensor-detect {
+		compatible = "sensor_detect";
+		hot_plugin_enable = <0>; /* 1-enable, 0-disable */
+		sensor_detect_list {
+			gc0308 = <1>;  /* 1-detect this sensor, 0-don't detect */
+			gc0328 = <1>;
+			gc0329 = <1>;
+			gc0312 = <1>;
+			gc2035 = <1>;
+			gc2145 = <1>;
+			gc2155 = <1>;
+			
+			hi708 = <1>;
+			hi257 = <1>;
+			
+			ov2686 = <1>;
+			ov5640 = <1>;
+			
+			sp0718 = <1>;
+			sp0a19 = <1>;
+			sp2519 = <1>;
+			
+			siv121du = <1>;
+			soc5140 = <1>;
+    	};
+    };
+
+	
+	framebuffer {
+		compatible = "actions,framebuffer";
+
+		/*never creat platform device*/
+		status = "disabled";
+
+		ovl_boot {
+			usage = "boot";
+			disp_dev = <&lcd0>;
+		};
+
+		ovl_extra {
+			usage = "extra";
+		};
+
+
+	};
+
+	lcd0: lcd0@b02a0000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&rgb_state_default>;
+		lcd_power_gpios = <&gpio 36 1>;    /* GPIOB4*/ 
+		lcd_reset_gpios = <&gpio 40 0>; /*GPIOB8*/
+		port_type = "rgb";
+		data_width = <1>;
+		lcdvcc-supply = <&switch1>;
+		videomode-0 = <&lcd_mode0>;
+		vsync_inversion = <0>;
+		hsync_inversion = <0>;
+		dclk_inversion = <0>;
+		lde_inversion = <0>;
+		lvds_ctl = <0x000a9521>;
+		lvds_alg_ctl0 = <0xc141a030>;
+		lightness = <128>;
+		saturation = <7>;
+		contrast = <5>;
+		lcd_mode0:mode@1024x600p60 {
+			refresh = <60>;
+			xres = <1024>;
+			yres = <600>;
+			/*in pico second, 0.000 000 000 001s*/
+			pixclock = <20000>;
+			left_margin = <140>;
+			right_margin = <150>;
+			upper_margin = <10>;
+			lower_margin = <20>;
+			hsync_len = <10>;
+			vsync_len = <5>;
+			/*0: FB_VMODE_NONINTERLACED, 1:FB_VMODE_INTERLACED*/
+			vmode = <0>;
+		};
+
+	};
+
+	dsi: dsi@b0220000 {
+		status = "disabled";
+	};
+		
+	hdmi:hdmi@b02c0000{
+		hdcp_onoff = <0>;
+		channel_invert = <0>;
+		bit_invert = <0>;
+	};
+
+	pwm: pwm@b01b0050 {
+		pwm0 {
+			id = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm0_state_default>;
+		};
+		pwm1 {
+			id = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_state_default>;
+		};
+		pwm2 {
+			id = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_state_default>;
+		};
+		pwm3 {
+			id = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_state_default>;
+		};
+	};
+
+	backlight {
+		/*1.pwm num; 2. period in ns; */
+		/*3.plarity, 0: high active, 1: low active*/
+		backlight_en_gpios = <&gpio 118 0>; /* GPIOD22*/
+		pwms = <&pwm 0 50000 1>;
+		total_steps = <1024>;
+		min_brightness = <300>;
+		max_brightness = <1000>;
+		dft_brightness = <600>;
+		delay_bf_pwm  = <200>;
+		delay_af_pwm  = <10>;	
+   };
+	
+	
+	vibrator {
+		compatible = "actions,vibrator";
+		status = "disabled";
+	};
+	
+	wifi_bt_power_ctl {
+		compatible = "wifi,bt,power,ctl";
+		wifi_bt_power_gpios = <&gpio 39 0>; /* 86v GPIOB7 */
+		bt_en_gpios = <&gpio 90 0>;/*GPIOC26, high active*/
+		wifi_en_gpios = <&gpio 91 0>; /*gpio_wl_reg_on = <&gpio 91 0>; */ /* 86v GPIOC27 */
+	};
+
+	gsensor_detect {
+	  compatible = "owl-gsensor-detect";
+		i2c_adapter_id = <2>;
+	  gsensor_detect_list {
+			compatible = "gsensor_detect_list";
+      afa750 =  <0>;
+      bma220 =  <0>;
+      bma222 =  <1>;
+      bma250 =  <0>;
+      dmard10 = <0>;
+      kxtj9 =   <0>;
+      lis3dh =  <0>;
+      mc3210 =  <0>;
+      mc3230 =  <0>;
+      mc3232 =  <1>;
+      mc3236 =  <1>;
+      mma7660 = <0>;
+      mma8452 = <0>;
+      stk8312 = <0>;
+      stk8313 = <1>;
+	  };
+	};
+
+	ctp_detect {
+		compatible = "owl-ctp-detect";
+		i2c_adapter_id = <1>;
+		tp_vcc = "ldo5";
+		reset_gpios = <&gpio 35 1>;    /*GPIOB(3) 0: high, 1: low*/
+		interrupt-parent = <&sirq>;
+		interrupts =< 0 0x4 >; /*SIRQ0*/
+		vol_range = <3100000 3110000>;
+
+		ctp_detect_list {
+			compatible = "ctp_detect_list";
+			ICN83XX =  <0>;
+			GSLX6X0 =  <1>;
+			FT52-406 = <0>;
+			FT5606 =   <0>;
+			GT813 =    <0>;
+			AW5206 =   <0>;
+			AW5209 =   <0>;
+			CT36X =    <0>;
+			HL3X06 =   <0>;
+			ILITEK =   <0>;
+			ili2672 =  <0>;
+			ft5x06 =   <0>;
+			MT395 =    <0>;
+			NT1100X =  <0>;
+			SSD254X =  <0>;
+	   };
+	};
+   
+	gpu@b0300000 {
+		gpuvdd-supply = <&vdd_gpu_dcdc>;
+		normal_value = <1>;
+		status = "okay";
+	};
+	
+	vce@b0288000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+	
+	vde@b0280000{
+		corevdd-supply = <&vdd_gpu_dcdc>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm/include/asm/cacheflush.h b/arch/arm/include/asm/cacheflush.h
old mode 100644
new mode 100755
index 2d46862..60e708f
--- a/arch/arm/include/asm/cacheflush.h
+++ b/arch/arm/include/asm/cacheflush.h
@@ -94,6 +94,21 @@
  *	DMA Cache Coherency
  *	===================
  *
+ *	dma_inv_range(start, end)
+ *
+ *		Invalidate (discard) the specified virtual address range.
+ *		May not write back any entries.  If 'start' or 'end'
+ *		are not cache line aligned, those lines must be written
+ *		back.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ *
+ *	dma_clean_range(start, end)
+ *
+ *		Clean (write back) the specified virtual address range.
+ *		- start  - virtual start address
+ *		- end    - virtual end address
+ *
  *	dma_flush_range(start, end)
  *
  *		Clean and invalidate the specified virtual address range.
@@ -115,6 +130,8 @@ struct cpu_cache_fns {
 	void (*dma_map_area)(const void *, size_t, int);
 	void (*dma_unmap_area)(const void *, size_t, int);
 
+	void (*dma_inv_range)(const void *, const void *);
+	void (*dma_clean_range)(const void *, const void *);
 	void (*dma_flush_range)(const void *, const void *);
 };
 
@@ -142,6 +159,8 @@ extern struct cpu_cache_fns cpu_cache;
  */
 #define dmac_map_area			cpu_cache.dma_map_area
 #define dmac_unmap_area			cpu_cache.dma_unmap_area
+#define dmac_inv_range			cpu_cache.dma_inv_range
+#define dmac_clean_range		cpu_cache.dma_clean_range
 #define dmac_flush_range		cpu_cache.dma_flush_range
 
 #else
@@ -163,6 +182,8 @@ extern void __cpuc_flush_dcache_area(void *, size_t);
  */
 extern void dmac_map_area(const void *, size_t, int);
 extern void dmac_unmap_area(const void *, size_t, int);
+extern void dmac_inv_range(const void *, const void *);
+extern void dmac_clean_range(const void *, const void *);
 extern void dmac_flush_range(const void *, const void *);
 
 #endif
diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h
old mode 100644
new mode 100755
index b52101d..648a2bc
--- a/arch/arm/include/asm/dma-mapping.h
+++ b/arch/arm/include/asm/dma-mapping.h
@@ -176,21 +176,6 @@ static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 	return dma_addr == DMA_ERROR_CODE;
 }
 
-/*
- * Dummy noncoherent implementation.  We don't provide a dma_cache_sync
- * function so drivers using this API are highlighted with build warnings.
- */
-static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
-		dma_addr_t *handle, gfp_t gfp)
-{
-	return NULL;
-}
-
-static inline void dma_free_noncoherent(struct device *dev, size_t size,
-		void *cpu_addr, dma_addr_t handle)
-{
-}
-
 extern int dma_supported(struct device *dev, u64 mask);
 
 extern int arm_dma_set_mask(struct device *dev, u64 dma_mask);
@@ -254,6 +239,33 @@ static inline void dma_free_attrs(struct device *dev, size_t size,
 	ops->free(dev, size, cpu_addr, dma_handle, attrs);
 }
 
+/*
+ * Dummy noncoherent implementation.  We don't provide a dma_cache_sync
+ * function so drivers using this API are highlighted with build warnings.
+ */
+static inline void *dma_alloc_noncoherent(struct device *dev, size_t size,
+		dma_addr_t *handle, gfp_t gfp)
+{
+	/* add by actions */
+	/* 原生内核中这个API是没有实现的, 为了使ion_cma_heap能分到cached的buffer, 现在重新实现了这个API.
+	 * 原本arm dma-mapping.c中的arm_dma_alloc是不管DMA_ATTR_NON_CONSISTENT的,
+	 * 现在改为遇到DMA_ATTR_NON_CONSISTENT就分配cached, 但是atomic的分支没有改,
+	 * atomic时分配依然是uncached的(不影响ion,也没有违反这个API的定义,故不大改).
+	 * 请参考dma-mapping.c中__get_dma_pgprot的改动. */
+	DEFINE_DMA_ATTRS(attrs);
+	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+	return dma_alloc_attrs(dev, size, handle, gfp, &attrs);
+}
+
+static inline void dma_free_noncoherent(struct device *dev, size_t size,
+		void *cpu_addr, dma_addr_t handle)
+{
+	/* add by actions */
+	DEFINE_DMA_ATTRS(attrs);
+	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+	return dma_free_attrs(dev, size, cpu_addr, handle, &attrs);
+}
+
 /**
  * arm_dma_mmap - map a coherent DMA allocation into user space
  * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
diff --git a/arch/arm/kernel/hw_breakpoint.c b/arch/arm/kernel/hw_breakpoint.c
old mode 100644
new mode 100755
index dc7d0a9..0a7d532
--- a/arch/arm/kernel/hw_breakpoint.c
+++ b/arch/arm/kernel/hw_breakpoint.c
@@ -1024,9 +1024,19 @@ out_mdbgen:
 static int dbg_reset_notify(struct notifier_block *self,
 				      unsigned long action, void *cpu)
 {
-	if ((action & ~CPU_TASKS_FROZEN) == CPU_ONLINE)
+	if ((action & ~CPU_TASKS_FROZEN) == CPU_ONLINE) {
+		/*
+		 * We need to tread carefully here because DBGSWENABLE may be
+		 * driven low on this core and there isn't an architected way to
+		 * determine that.
+		 */
+		register_undef_hook(&debug_reg_hook);
+
 		smp_call_function_single((int)cpu, reset_ctrl_regs, NULL, 1);
 
+		unregister_undef_hook(&debug_reg_hook);
+	}
+
 	return NOTIFY_OK;
 }
 
@@ -1038,9 +1048,19 @@ static struct notifier_block dbg_reset_nb = {
 static int dbg_cpu_pm_notify(struct notifier_block *self, unsigned long action,
 			     void *v)
 {
-	if (action == CPU_PM_EXIT)
+	if (action == CPU_PM_EXIT) {
+		/*
+		 * We need to tread carefully here because DBGSWENABLE may be
+		 * driven low on this core and there isn't an architected way to
+		 * determine that.
+		 */
+		register_undef_hook(&debug_reg_hook);
+
 		reset_ctrl_regs(NULL);
 
+		unregister_undef_hook(&debug_reg_hook);
+	}
+
 	return NOTIFY_OK;
 }
 
@@ -1060,9 +1080,17 @@ static inline void pm_init(void)
 
 static int __init arch_hw_breakpoint_init(void)
 {
+	/*
+	 * We need to tread carefully here because DBGSWENABLE may be
+	 * driven low on this core and there isn't an architected way to
+	 * determine that.
+	 */
+	register_undef_hook(&debug_reg_hook);
+	
 	debug_arch = get_debug_arch();
 
 	if (!debug_arch_supported()) {
+		unregister_undef_hook(&debug_reg_hook);
 		pr_info("debug architecture 0x%x unsupported.\n", debug_arch);
 		return 0;
 	}
@@ -1074,14 +1102,7 @@ static int __init arch_hw_breakpoint_init(void)
 	core_num_wrps = get_num_wrps();
 
 	cpu_notifier_register_begin();
-
-	/*
-	 * We need to tread carefully here because DBGSWENABLE may be
-	 * driven low on this core and there isn't an architected way to
-	 * determine that.
-	 */
-	register_undef_hook(&debug_reg_hook);
-
+	
 	/*
 	 * Reset the breakpoint resources. We assume that a halting
 	 * debugger will leave the world in a nice state for us.
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
old mode 100644
new mode 100755
index 8cfd28a..ed20b30
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -153,6 +153,7 @@ static union { char c[4]; unsigned long l; } endian_test __initdata = { { 'l', '
 #define ENDIANNESS ((char)endian_test.l)
 
 DEFINE_PER_CPU(struct cpuinfo_arm, cpu_data);
+EXPORT_PER_CPU_SYMBOL(cpu_data);
 
 /*
  * Standard memory resources
@@ -1057,6 +1058,10 @@ static int c_show(struct seq_file *m, void *v)
 	int i, j;
 	u32 cpuid;
 
+	cpuid = is_smp() ? per_cpu(cpu_data, 0).cpuid : read_cpuid_id();
+	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
+		   ARM_cpu_name, cpuid & 15, elf_platform);
+		   
 	for_each_online_cpu(i) {
 		/*
 		 * glibc reads /proc/cpuinfo to determine the number of
diff --git a/arch/arm/kernel/sleep.S b/arch/arm/kernel/sleep.S
old mode 100644
new mode 100755
index 7d37bfc..a5b602a
--- a/arch/arm/kernel/sleep.S
+++ b/arch/arm/kernel/sleep.S
@@ -100,6 +100,36 @@ ENDPROC(cpu_suspend_abort)
 	.align	5
 	.pushsection	.idmap.text,"ax"
 ENTRY(cpu_resume_mmu)
+	mov	r8, #0
+	mcr	p15, 2, r8, c0, c0, 0
+	mrc	p15, 1, r8, c0, c0, 0
+
+	ldr	r1, =0x7fff
+	and	r2, r1, r0, lsr #13
+
+	ldr	r1, =0x3ff
+
+	and	r3, r1, r8, lsr #3	@ NumWays - 1
+	add	r2, r2, #1		@ NumSets
+
+	and	r8, r8, #0x7
+	add	r8, r8, #4	@ SetShift
+
+	clz	r1, r3		@ WayShift
+	add	r4, r3, #1	@ NumWays
+1:	sub	r2, r2, #1	@ NumSets--
+	mov	r3, r4		@ Temp = NumWays
+2:	subs	r3, r3, #1	@ Temp--
+	mov	r5, r3, lsl r1
+	mov	r6, r2, lsl r8
+	orr	r5, r5, r6	@ Reg = (Temp<<WayShift)|(NumSets<<SetShift)
+	mcr	p15, 0, r5, c7, c6, 2
+	bgt	2b
+	cmp	r2, #0
+	bgt	1b
+	dsb
+	isb
+
 	ldr	r3, =cpu_resume_after_mmu
 	instr_sync
 	mcr	p15, 0, r0, c1, c0, 0	@ turn on MMU, I-cache, etc
diff --git a/arch/arm/kernel/smp_twd.c b/arch/arm/kernel/smp_twd.c
old mode 100644
new mode 100755
index 172c6a05..62a2d88
--- a/arch/arm/kernel/smp_twd.c
+++ b/arch/arm/kernel/smp_twd.c
@@ -31,11 +31,14 @@ static void __iomem *twd_base;
 
 static struct clk *twd_clk;
 static unsigned long twd_timer_rate;
+static bool common_setup_called;
 static DEFINE_PER_CPU(bool, percpu_setup_called);
 
 static struct clock_event_device __percpu *twd_evt;
 static int twd_ppi;
 
+static void twd_get_clock(struct device_node *np);
+
 static void twd_set_mode(enum clock_event_mode mode,
 			struct clock_event_device *clk)
 {
@@ -284,7 +287,24 @@ static void twd_timer_setup(void)
 	}
 	per_cpu(percpu_setup_called, cpu) = true;
 
-	twd_calibrate_rate();
+	/*
+	 * This stuff only need to be done once for the entire TWD cluster
+	 * during the runtime of the system.
+	 */
+	if (!common_setup_called) {
+		/*
+		 * We use IS_ERR_OR_NULL() here, because if the clock stubs
+		 * are active we will get a valid clk reference which is
+		 * however NULL and will return the rate 0. In that case we
+		 * need to calibrate the rate instead.
+		 */
+		if (!IS_ERR_OR_NULL(twd_clk))
+			twd_timer_rate = clk_get_rate(twd_clk);
+		else
+			twd_calibrate_rate();
+
+		common_setup_called = true;
+	}
 
 	/*
 	 * The following is done once per CPU the first time .setup() is
diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c
old mode 100644
new mode 100755
index 3dce1a3..8c9c3ed
--- a/arch/arm/kernel/traps.c
+++ b/arch/arm/kernel/traps.c
@@ -234,12 +234,19 @@ void show_stack(struct task_struct *tsk, unsigned long *sp)
 #define S_ISA " ARM"
 #endif
 
+#ifdef CONFIG_MACH_OWL
+extern void owl_switch_jtag(void);
+#endif
+
 static int __die(const char *str, int err, struct pt_regs *regs)
 {
 	struct task_struct *tsk = current;
 	static int die_counter;
 	int ret;
 
+#ifdef CONFIG_MACH_OWL
+	owl_switch_jtag();
+#endif
 	pr_emerg("Internal error: %s: %x [#%d]" S_PREEMPT S_SMP S_ISA "\n",
 	         str, err, ++die_counter);
 
diff --git a/arch/arm/mach-owl/Kconfig b/arch/arm/mach-owl/Kconfig
new file mode 100755
index 0000000..4ffa728
--- /dev/null
+++ b/arch/arm/mach-owl/Kconfig
@@ -0,0 +1,179 @@
+comment "Owl configurations"
+	depends on ARCH_OWL
+
+choice
+	prompt "Owl Board Type"
+	depends on ARCH_OWL
+	default MACH_OWL
+
+config MACH_OWL
+	boolean "Actions owl board"
+	depends on ARCH_OWL
+	select ARCH_HAS_CPUFREQ
+	select ARCH_REQUIRE_GPIOLIB
+	select PINCTRL
+	select USE_OF
+	select NEON
+	select VFP
+	select ARM_GIC
+	select CPU_V7
+	select HAVE_ARM_SCU if SMP
+	select HAVE_ARM_TWD if SMP
+	select HAVE_SMP
+	select VIRT_TO_BUS
+	select OWL_CLOSE_PATCH
+        help
+          board configuration for actions gs703a fpga, evb, etc.
+
+endchoice
+
+config OWL_DEBUG_IRQ_STACK
+	boolean "Enable Actions irq stack debugger"
+	depends on ARCH_OWL
+	help
+	  Enable Actions irq stack debugger, say Y.  Otherwise, say N.
+	  
+config SERIAL_OWL
+	boolean "Enable Actions SoCs' UART Support"
+	depends on ARCH_OWL
+	select SERIAL_CORE
+	help
+	  If you have a ARM-based Actions SoC
+	  and you want to use serial ports, say Y.  Otherwise, say N.
+
+config SERIAL_OWL_CONSOLE
+	boolean "Enable Actions SoCs serial console"
+	depends on SERIAL_OWL
+	select SERIAL_CORE_CONSOLE
+	help
+	  If you have a ARM-based  Actions SoC
+	  and you want to use serial console, say Y. Otherwise, say N.
+
+config CONFIG_HOTPLUG_OWL
+	boolean "Enable cpu auto hotplug according to cpu loading"
+	depends on ARCH_OWL && CONFIG_HOTPLUG_CPU && CONFIG_ARM_OWL_CPUFREQ
+	help
+	  If you want to enable cpu auto hotplug according to cpu loading, 
+	  say Y. Otherwise, say N.
+	  
+config OWL_CONSOLE_KEEP_ON
+	boolean "Keep on Actions SoCs serial console"
+	depends on SERIAL_OWL_CONSOLE
+	help
+	  If you want to get more print from
+	  serial console for debug, say Y. Otherwise, say N.
+
+config GPIO_OWL
+	boolean "Enable Actions SoCs GPIO"
+	depends on GPIOLIB
+	help
+	  If you have a ARM-based  Actions SoC
+	  and you want to use GPIO, say Y. Otherwise, say N.
+
+config GPU_RESERVED_SIZE
+    int "Reserved memory for GPU (Mbytes)"
+	default "64"
+	depends on ARCH_OWL
+	help
+	  The default reserver value is 32M RAM. Change this if you know what you
+	  are doing.
+
+config ION_RESERVED_SIZE
+    int "Reserved memory for ION (Mbytes)"
+	default "64"
+	depends on ION || ION_OWL
+	help
+	  The default reserver value is 64M RAM. Change this if you know what you
+	  are doing.
+
+config FB_RESERVED_SIZE
+    int "Reserved memory for Framebuffer (Mbytes)"
+	default "32"
+	depends on ARCH_OWL
+	help
+	  The default reserver value is 32M RAM. Change this if you know what you
+	  are doing.
+
+config I2C_OWL
+	tristate "Actions Actions SOC I2C"
+	depends on ARCH_OWL
+	help
+	  Enable the use of the I2C bus controllers on the Actions SOC Verify
+	  If you don't know what to do here, say N.
+
+config I2C_OWL_BUS0
+	tristate "Actions SOC I2C0"
+	depends on I2C_OWL
+	help
+	  Enable the use of the I2C bus 0 controllers on the Actions SOC Verify
+	  If you don't know what to do here, say N.
+
+config I2C_OWL_BUS1
+	tristate "Actions SOC I2C1"
+	depends on I2C_OWL
+	help
+	  Enable the use of the I2C bus 1 controllers on the Actions SOC Verify
+	  If you don't know what to do here, say N.
+
+config I2C_OWL_BUS2
+	tristate "Actions SOC I2C2"
+	depends on I2C_OWL
+	help
+	  Enable the use of the I2C bus 2 controllers on the Actions SOC Verify
+	  If you don't know what to do here, say N.
+
+config I2C_OWL_BUS3
+        tristate "Actions SOC I2C3"
+        depends on I2C_OWL
+        help
+          Enable the use of the I2C bus 3 controllers on the Actions SOC Verify
+          If you don't know what to do here, say N.
+
+config PINCTRL_OWL
+	bool "Actions SOC pin controller driver"
+	depends on ARCH_OWL
+	select PINCTRL
+	select PINMUX
+	select PINCONF
+	help
+	  Pin controller driver for Actions SOC
+
+config ACTIONS_SOC_CAMERA
+	tristate "SoC camera support"
+	depends on VIDEO_V4L2 && HAS_DMA && I2C
+	select VIDEOBUF_GEN
+	select VIDEOBUF2_CORE
+	select VIDEOBUF_DMA_CONTIG
+	select VIDEOBUF2_DMA_CONTIG
+	help
+	  SoC Camera is a common API to several cameras, not connecting
+	  over a bus like PCI or USB. For example some i2c camera connected
+	  directly to the data bus of an SoC.
+
+config FB_ACTIONS
+	tristate "Actions framebuffer support"
+	depends on FB
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+	This enables support for the ACTIONS framebuffer in the kernel .
+
+config BACKLIGHT_ACTIONS
+	tristate "Actions backlight"
+	select BACKLIGHT_CLASS_DEVICE
+	select ACT_BACKLIGHT
+  ---help---
+	This enables support for the ACTIONS backlight in the kernel .
+
+config CPUFREQ_ACTIONS
+	bool "Actions cpufreq"
+	select CPU_FREQ
+	select CPU_FREQ_TABLE
+  help
+    This enables support for the ACTIONS cpufreq driver. Selecting
+    this will NOT enable coresponding Actions driver. It just helps
+    to select the necessary kernel configs for the out-kernel drivers.
+
+config OWL_CLOSE_PATCH
+	bool
diff --git a/arch/arm/mach-owl/Makefile b/arch/arm/mach-owl/Makefile
new file mode 100755
index 0000000..e487f66
--- /dev/null
+++ b/arch/arm/mach-owl/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the linux kernel.
+#
+# Common support
+obj-y := common-owl.o cpu-owl.o timer-owl.o serial-owl.o i2c-owl.o sirq-owl.o powergate-owl.o debug-owl.o secure_storage-owl.o \
+		bootdev-owl.o  dump_stack-owl.o clocktree-atm7059.o clocktree-owl.o \
+	    user_dump_stack.o
+#obj-y += version-owl.o
+obj-$(CONFIG_MACH_OWL) += board-owl.o
+obj-$(CONFIG_GPIO_OWL) += gpio-owl.o
+obj-$(CONFIG_PINCTRL_OWL) += pinctrl-owl.o pinctrl_common-owl.o pinctrl_data-atm7059.o
+obj-$(CONFIG_SMP) += platsmp-owl.o headsmp-owl.o hotplug_base-owl.o 
+obj-$(CONFIG_ACTIONS_SOC_CAMERA) += isp_pwd-owl.o
+obj-$(CONFIG_HIBERNATION) += swsusp-owl.o processor-owl.o
+obj-$(CONFIG_PM) += pm-owl.o sleep-owl.o
+obj-$(CONFIG_HOTPLUG_OWL) += hotplug-owl.o
+
+#obj-y += libcidop 
+
diff --git a/arch/arm/mach-owl/Makefile.boot b/arch/arm/mach-owl/Makefile.boot
new file mode 100755
index 0000000..ff0a4b5
--- /dev/null
+++ b/arch/arm/mach-owl/Makefile.boot
@@ -0,0 +1,4 @@
+   zreladdr-y	+= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
+
diff --git a/arch/arm/mach-owl/board-owl.c b/arch/arm/mach-owl/board-owl.c
new file mode 100755
index 0000000..83eb23f
--- /dev/null
+++ b/arch/arm/mach-owl/board-owl.c
@@ -0,0 +1,204 @@
+/*
+ * board-owl.c  --  Board support file for Actions gs703a
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/bootmem.h>
+#include <linux/memblock.h>
+#include <linux/spi/spi.h>
+//#include <linux/ion.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/i2c.h>
+#include <linux/of_platform.h>
+#include <linux/highmem.h>
+#include <asm/system_info.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/hdmac-owl.h>
+#include <mach/gpio.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+//#include <asm/hardware/gic.h>
+#include <asm/setup.h>
+
+#include "board-owl.h"
+
+void owl_switch_jtag(void)
+{
+    act_writel(act_readl(MFP_CTL1) & (~((0x7<<29) | (0x7<<26))), MFP_CTL1);
+    act_writel((act_readl(MFP_CTL2) & (~((0x3<<5) | (0x3<<7) | (0x7<<11) | (0x7<<17))))
+        | ((0x2<<5) | (0x3<<7) | (0x3<<11) | (0x3<<17)), MFP_CTL2);
+}
+
+
+#ifndef CONFIG_OF
+static struct resource owl_res_ethernet[] = {
+	{
+		.start = OWL_IRQ_ETHERNET,
+		.end = OWL_IRQ_ETHERNET,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device owl_ethernet_device = {
+	.name = "owl-ethernet",
+	.id = 0,
+	.resource = owl_res_ethernet,
+	.num_resources = ARRAY_SIZE(owl_res_ethernet),
+};
+#endif
+
+static struct resource owl_res_uart0[] = {
+	{
+		.start = UART0_BASE,
+		.end = UART0_BASE + 0xfff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = OWL_IRQ_UART0,
+		.end = OWL_IRQ_UART0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device owl_uart_device0 = {
+	.name = "owl-serial",
+	.id = 0,
+	.resource = owl_res_uart0,
+	.num_resources = ARRAY_SIZE(owl_res_uart0),
+};
+
+
+
+/************************************************/
+
+/************************************************/
+
+/************************/
+static struct platform_device owl_vout_device = {
+	.name   = "gl5201_vout",
+	.id		= 0,
+};
+/************************/
+
+
+static struct platform_device *owl_platform_devices[] __initdata = {
+#ifndef CONFIG_OF
+	&owl_ethernet_device,
+#endif
+	&owl_uart_device0,
+	&owl_vout_device,
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id owl_dt_match_table[] __initdata = {
+	{ .compatible = "simple-bus", },
+	{}
+};
+#endif /* CONFIG_OF */
+
+static void __init owl_board_init(void)
+{
+	int ret;
+
+	ret = platform_add_devices(owl_platform_devices,
+		ARRAY_SIZE(owl_platform_devices));
+	if (ret)
+		pr_warn("platform_add_devices() fail\n");
+
+#ifdef CONFIG_OF
+	ret = of_platform_populate(NULL, owl_dt_match_table, NULL, NULL);
+	if (ret)
+		pr_warn("of_platform_populate() fail\n");
+#endif
+
+	pr_info("%s()\n", __func__);
+}
+
+#ifdef CONFIG_OF
+static const char *owl_dt_match[] __initconst = {
+	"actions,atm7039c",
+	"actions,atm7059tc",
+	"actions,atm7059a",
+	NULL,
+};
+#endif
+
+extern void owl_powergate_earlyinit(void);
+
+void __init owl_check_revision(void)
+{
+	char *vddr = kmap_atomic(pfn_to_page(PFN_DOWN(0)));
+	memcpy(&system_serial_low, vddr+0x800, sizeof(system_serial_low));
+	memcpy(&system_serial_high, vddr+0x804, sizeof(system_serial_high));
+	kunmap_atomic(vddr);
+}
+
+void __init owl_init_early(void)
+{
+	owl_check_revision();
+
+	owl_powergate_earlyinit();
+}
+
+
+extern int owl_cpu_disable(unsigned int cpu);
+extern void owl_cpu_die(unsigned int cpu);
+extern int owl_cpu_kill(unsigned int cpu);
+extern void owl_smp_prepare_cpus(unsigned int max_cpus);
+extern void owl_smp_init_cpus(void);
+extern int owl_boot_secondary(unsigned int cpu, struct task_struct *idle);
+extern void owl_secondary_init(unsigned int cpu);
+
+static struct smp_operations owl_smp_ops =
+{
+#ifdef CONFIG_SMP
+    .smp_init_cpus = owl_smp_init_cpus,
+    .smp_prepare_cpus = owl_smp_prepare_cpus,
+    .smp_secondary_init = owl_secondary_init,
+    .smp_boot_secondary = owl_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_kill = owl_cpu_kill,
+	.cpu_die = owl_cpu_die,
+	.cpu_disable = owl_cpu_disable,
+#endif
+#endif
+};
+
+
+bool __init owl_smp_init(void)
+{
+    smp_set_ops(&owl_smp_ops);
+    return true;
+}
+
+extern void __init owl_timer_init(void);
+extern void gic_handle_irq(struct pt_regs *regs);
+
+MACHINE_START(OWL, "gs705a")
+#ifdef CONFIG_OF
+	.dt_compat	= owl_dt_match,
+#endif
+	.atag_offset	= 0x00000100,
+	.smp_init       = owl_smp_init,
+	.init_early	= owl_init_early,
+	.map_io		= owl_map_io,
+	.reserve	= owl_reserve,
+	.init_irq	= owl_init_irq,
+	.init_machine	= owl_board_init,
+MACHINE_END
diff --git a/arch/arm/mach-owl/board-owl.h b/arch/arm/mach-owl/board-owl.h
new file mode 100755
index 0000000..ea5cbcb
--- /dev/null
+++ b/arch/arm/mach-owl/board-owl.h
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/mach-owl/board-owl.h
+ *
+ * Copyright (C) 2013 Actions, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __MACH_BOARD_OWL_H
+#define __MACH_BOARD_OWL_H
+
+#include <linux/types.h>
+
+extern void __init owl_map_io(void);
+extern void __init owl_reserve(void);
+extern void __init owl_init_irq(void);
+
+#endif
diff --git a/arch/arm/mach-owl/bootafinfo-owl.c b/arch/arm/mach-owl/bootafinfo-owl.c
new file mode 100755
index 0000000..602f26b
--- /dev/null
+++ b/arch/arm/mach-owl/bootafinfo-owl.c
@@ -0,0 +1,135 @@
+/*
+ * arch/arm/mach-owl/bootafinfo.c
+ *
+ * bootadfi for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/module.h> 
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/bootmem.h>
+#include <linux/memblock.h>
+#include <asm/setup.h>
+#include <asm/memblock.h>
+#include <asm/idmap.h>
+#include <mach/bootafinfo.h>
+#include <mach/debug.h>
+
+static const unsigned int afinfo_buf_phys;
+extern int afinfo_buf_len;
+extern unsigned char *g_afinfo;
+
+unsigned char *owl_get_boot_afinfo(void)
+{
+    return g_afinfo;
+}
+EXPORT_SYMBOL_GPL(owl_get_boot_afinfo);
+
+int owl_get_boot_afinfo_len(void)
+{
+    return afinfo_buf_len;
+}
+EXPORT_SYMBOL_GPL(owl_get_boot_afinfo_len);
+
+void __init owl_boot_afinfo_init(void)
+{
+	if (!afinfo_buf_phys)
+		return;
+
+	printk("%s: g_afinfo 0x%p, afinfo_buf_phys 0x%x, len 0x%x\n", __FUNCTION__,
+        g_afinfo, afinfo_buf_phys, afinfo_buf_len);
+
+#if 0
+	afinfo_buf = alloc_bootmem_align(afinfo_buf_len, PAGE_SIZE);
+
+	printk("%s: afinfo_buf 0x%x, afinfo_buf_phys 0x%x, len %x\n", __FUNCTION__,
+        afinfo_buf, afinfo_buf_phys, afinfo_buf_len);
+
+	identity_mapping_add(swapper_pg_dir, afinfo_buf_phys, 
+            afinfo_buf_phys + PFN_ALIGN(afinfo_buf_len));
+	memcpy(afinfo_buf, afinfo_buf_phys, afinfo_buf_len);
+	identity_mapping_del(swapper_pg_dir, afinfo_buf_phys, 
+            afinfo_buf_phys + PFN_ALIGN(afinfo_buf_len));
+
+	if(afinfo_buf_phys >= PHYS_OFFSET)
+	    memblock_free(afinfo_buf_phys, afinfo_buf_len);
+#endif
+//    owl_dump_mem(afinfo_buf, afinfo_buf_len, 0, 1);
+}
+
+void __init owl_boot_afinfo_reserve(void)
+{
+	if (!afinfo_buf_phys)
+		return;
+#if 0
+	if(afinfo_buf_phys >= PHYS_OFFSET) {
+    	memblock_reserve(afinfo_buf_phys, afinfo_buf_len);
+		printk("memblock_reserve,0x%x:0x%x\n", afinfo_buf_phys, afinfo_buf_len);
+    }
+#endif
+}
+
+#if 0
+/* parse ATAG_BOOT_AFINFO*/
+static int __init parse_tag_boot_afinfo(const struct tag *tag)
+{
+    afinfo_buf_phys = tag->u.afinfo.afinfo_buf_start;
+    afinfo_buf_len = tag->u.afinfo.afinfo_buf_len;
+
+	printk("tag: boot_afinfo 0x%x, len %d\n", afinfo_buf_phys, afinfo_buf_len);
+
+	return 0;
+}
+__tagtable(ATAG_BOOT_AFINFO, parse_tag_boot_afinfo);
+#endif
+
+#if 1
+static int bootafinfo_proc_show(struct seq_file *m, void *v)
+{
+	int i;
+    if (g_afinfo)
+    {
+    	printk("afi len=%x:\n",afinfo_buf_len);
+        //owl_dump_mem(g_afinfo, afinfo_buf_len, 0, 1);        
+        for ( i = 0 ; i < afinfo_buf_len; i++ )
+        	seq_putc(m, (char)g_afinfo[i]);
+
+    }
+	else {
+		seq_printf(m, "##### we don't have afinfo.\n");
+	}
+	return 0;
+}
+
+static int bootafinfo_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, bootafinfo_proc_show, NULL);
+}
+
+static const struct file_operations bootafinfo_proc_fops = {
+	.open		= bootafinfo_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init proc_bootafinfo_init(void)
+{
+	proc_create("bootafinfo", 0, NULL, &bootafinfo_proc_fops);
+	return 0;
+}
+module_init(proc_bootafinfo_init);
+#endif
diff --git a/arch/arm/mach-owl/bootdev-owl.c b/arch/arm/mach-owl/bootdev-owl.c
new file mode 100755
index 0000000..833e8d93
--- /dev/null
+++ b/arch/arm/mach-owl/bootdev-owl.c
@@ -0,0 +1,227 @@
+/*
+ * arch/arm/mach-owl/bootdev-owl.c
+ *
+ * bootdev for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/module.h> 
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/vmalloc.h>
+#include <asm/setup.h>
+#include <mach/bootdev.h>
+
+#include <asm/uaccess.h>
+#include <asm/mach/map.h>
+
+//extern unsigned char *g_afinfo;
+static int g_boot_dev = 0;
+
+int owl_get_boot_dev(void)
+{
+    return g_boot_dev;
+}
+EXPORT_SYMBOL_GPL(owl_get_boot_dev);
+
+#if 0
+/* parse ATAG_BOOTDEV */
+static int __init parse_tag_boot_dev(const struct tag *tag)
+{
+	g_boot_dev = tag->u.boot_dev.boot_dev;
+
+	printk("tag: boot_dev %d\n", g_boot_dev);
+
+	return 0;
+}
+
+__tagtable(ATAG_BOOT_DEV, parse_tag_boot_dev);
+#endif
+
+static int bootdev_proc_show(struct seq_file *m, void *v)
+{
+    switch (g_boot_dev) {
+    case OWL_BOOTDEV_NAND:
+	    seq_printf(m, "nand\n");
+        break;
+    case OWL_BOOTDEV_SD0:
+	    seq_printf(m, "sd0\n");
+        break;
+    case OWL_BOOTDEV_SD1:
+	    seq_printf(m, "sd1\n");
+        break;
+    case OWL_BOOTDEV_SD2:
+	    seq_printf(m, "sd2\n");
+        break;
+    case OWL_BOOTDEV_SD02NAND:
+	    seq_printf(m, "sd02nand\n");
+        break; 
+    case OWL_BOOTDEV_SD02SD2:
+	    seq_printf(m, "sd02sd2\n");
+        break;  		
+    case OWL_BOOTDEV_NOR:
+	    seq_printf(m, "nor\n");
+        break;
+    default:
+	    seq_printf(m, "unkown\n");
+        break;
+    }
+	return 0;
+}
+
+static char *get_user_string(const char __user *user_buf, size_t user_len)
+{
+	char *buffer;
+
+	buffer = vmalloc(user_len + 1);
+	if (buffer == NULL)
+		return ERR_PTR(-ENOMEM);
+	if (copy_from_user(buffer, user_buf, user_len) != 0) {
+		vfree(buffer);
+		return ERR_PTR(-EFAULT);
+	}
+	/* got the string, now strip linefeed. */
+	if (buffer[user_len - 1] == '\n')
+		buffer[user_len - 1] = 0;
+	else
+		buffer[user_len] = 0;
+	return buffer;
+}
+
+
+static ssize_t bootdev_proc_write(struct file *file,
+		const char __user *buffer, size_t count, loff_t *ppos)
+{
+	char *buf, *str;
+    buf = get_user_string(buffer, count);
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);	
+	str = skip_spaces(buf);
+	if (!strcmp(str, "nand")) {
+        g_boot_dev = OWL_BOOTDEV_NAND;
+    } else if (!strcmp(str, "sd0")) {
+        g_boot_dev = OWL_BOOTDEV_SD0;
+    } else if (!strcmp(str, "sd1")) {
+        g_boot_dev = OWL_BOOTDEV_SD1;
+    } else if (!strcmp(str, "sd2")) {
+        g_boot_dev = OWL_BOOTDEV_SD2;
+    } else if (!strcmp(str, "sd02nand")) {
+        g_boot_dev = OWL_BOOTDEV_SD02NAND;
+    } else if (!strcmp(str, "sd02sd2")) {
+        g_boot_dev = OWL_BOOTDEV_SD02SD2;
+    } else if (!strcmp(str, "nor")) {
+        g_boot_dev = OWL_BOOTDEV_NOR;
+    } else {
+        pr_warning("invalid boot device name\n");
+    }
+
+	vfree(buf);
+	return count;
+}
+
+
+static int bootdev_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, bootdev_proc_show, NULL);
+}
+
+static const struct file_operations bootdev_proc_fops = {
+	.open		= bootdev_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+    .write		= bootdev_proc_write,
+};
+
+static int __init proc_bootdev_init(void)
+{
+	//g_boot_dev = g_afinfo[8];
+	printk("## boot_dev: 0x%x\n", g_boot_dev);
+	proc_create("bootdev", S_IRUGO | S_IWUSR, NULL, &bootdev_proc_fops);
+	return 0;
+}
+module_init(proc_bootdev_init);
+
+
+static int __init boot_dev_process(char *str)
+{
+	printk("boot_mode_process\n");
+	if (str == NULL || *str == '\0')
+		return 0;
+		
+	if (!strcmp(str, "nand")) {
+        g_boot_dev = OWL_BOOTDEV_NAND;
+    } else if (!strcmp(str, "sd0")) {
+        g_boot_dev = OWL_BOOTDEV_SD0;
+    } else if (!strcmp(str, "sd1")) {
+        g_boot_dev = OWL_BOOTDEV_SD1;
+    } else if (!strcmp(str, "sd2")) {
+        g_boot_dev = OWL_BOOTDEV_SD2;
+    } else if (!strcmp(str, "sd02nand")) {
+        g_boot_dev = OWL_BOOTDEV_SD02NAND;
+    } else if (!strcmp(str, "sd02sd2")) {
+        g_boot_dev = OWL_BOOTDEV_SD02SD2;
+    } else if (!strcmp(str, "nor")) {
+        g_boot_dev = OWL_BOOTDEV_NOR;
+    } else {
+        pr_warning("invalid boot device name\n");
+    }
+    
+	return 1;
+}
+__setup("boot_dev=", boot_dev_process);
+
+
+
+static  int boot_mode = OWL_BOOT_MODE_NORMAL;
+static int __init boot_mode_process(char *str)
+{
+	printk("boot_mode_process\n");
+	if (str == NULL || *str == '\0')
+		return 0;
+		
+	if (strcmp(str, "upgrade") == 0) {
+		printk("upgrade boot mode\n");
+		boot_mode = OWL_BOOT_MODE_UPGRADE;
+	}else if (strcmp(str, "charger") == 0) {
+		printk("minicharger boot mode\n");
+		boot_mode = OWL_BOOT_MODE_CHARGER;
+	}else if(strcmp(str, "recovery1") == 0 || strcmp(str, "recovery2") == 0 ){
+		printk("recovery boot mode\n");
+		boot_mode = OWL_BOOT_MODE_RECOVERY;
+	}else{
+		printk("Normal boot mode\n");
+		boot_mode = OWL_BOOT_MODE_NORMAL;
+	}	
+	printk("boot_mode=%d, str=%s\n", boot_mode, str);
+	return 1;
+}
+__setup("androidboot.mode=", boot_mode_process);
+
+/*return the mode
+	0:normal
+	1:produce
+	2:minicharge
+	4:recovery
+*/
+int owl_get_boot_mode(void)
+{
+	//printk("boot mode = %d\n", boot_mode);
+	return boot_mode;
+}
+EXPORT_SYMBOL_GPL(owl_get_boot_mode);
+
+
+
diff --git a/arch/arm/mach-owl/clock-owl.h b/arch/arm/mach-owl/clock-owl.h
new file mode 100755
index 0000000..4a48fbf
--- /dev/null
+++ b/arch/arm/mach-owl/clock-owl.h
@@ -0,0 +1,472 @@
+#ifndef CLOCK_OWL_H
+#define CLOCK_OWL_H
+
+enum owl_cmureg_no {
+	R_CMU_COREPLL,
+	R_CMU_DEVPLL,
+	R_CMU_DDRPLL,
+	R_CMU_NANDPLL,
+	R_CMU_DISPLAYPLL,
+	R_CMU_AUDIOPLL,
+	R_CMU_TVOUTPLL,
+	R_CMU_BUSCLK,
+	R_CMU_SENSORCLK,
+	R_CMU_LCDCLK,
+	R_CMU_DSICLK,
+	R_CMU_CSICLK,
+	R_CMU_DECLK,
+	R_CMU_BISPCLK,
+
+	R_CMU_BUSCLK1,
+	R_CMU_RESERVE2,
+
+	R_CMU_VDECLK,
+	R_CMU_VCECLK,
+
+	R_CMU_RESERVE3,
+
+	R_CMU_NANDCCLK,
+	R_CMU_SD0CLK,
+	R_CMU_SD1CLK,
+	R_CMU_SD2CLK,
+	R_CMU_UART0CLK,
+	R_CMU_UART1CLK,
+	R_CMU_UART2CLK,
+
+	R_CMU_PWM4CLK,
+	R_CMU_PWM5CLK,
+	R_CMU_PWM0CLK,
+	R_CMU_PWM1CLK,
+	R_CMU_PWM2CLK,
+	R_CMU_PWM3CLK,
+	R_CMU_USBPLL,
+	R_CMU_ETHERNETPLL,
+	R_CMU_CVBSPLL,
+
+	R_CMU_LENSCLK,
+	R_CMU_GPU3DCLK,
+
+	R_CMU_RESERVE6,
+
+	R_CMU_CORECTL,
+	R_CMU_DEVCLKEN0,
+	R_CMU_DEVCLKEN1,
+	R_CMU_DEVRST0,
+	R_CMU_DEVRST1,
+	R_CMU_UART3CLK,
+	R_CMU_UART4CLK,
+	R_CMU_UART5CLK,
+	R_CMU_UART6CLK,
+
+	R_CMU_RESERVE7,
+
+	R_CMU_SSCLK,
+	R_CMU_DIGTALDEBUG,
+	R_CMU_ANALOGDEBUG,
+	R_CMU_COREPLLDEBUG,
+	R_CMU_DEVPLLDEBUG,
+	R_CMU_DDRPLLDEBUG,
+	R_CMU_NANDPLLDEBUG,
+	R_CMU_DISPLAYPLLDEBUG,
+	R_CMU_TVOUTPLLDEBUG,
+
+	R_CMU_RESERVE8,
+
+	R_CMU_DEEPCOLORPLLDEBUG,
+	R_CMU_AUDIOPLL_ETHPLLDEBUG,
+	R_CMU_CVBSPLLDEBUG,
+	R_CMUMAX
+};
+
+
+enum owl_clock_e {
+	CLOCK__HOSC,
+	CLOCK__IC_32K,
+	CLOCK__COREPLL,
+	CLOCK__DEVPLL,
+	CLOCK__DDRPLL,
+	CLOCK__NANDPLL,
+	CLOCK__DISPLAYPLL,
+	CLOCK__AUDIOPLL,
+	CLOCK__TVOUTPLL,
+	CLOCK__DEEPCOLORPLL,
+	CLOCK__ETHERNETPLL,
+	CLOCK__CVBSPLL,
+	CLOCK__DEV_CLK,
+	CLOCK__DDR_CLK_0,
+	CLOCK__DDR_CLK_90,
+	CLOCK__DDR_CLK_180,
+	CLOCK__DDR_CLK_270,
+	CLOCK__DDR_CLK_CH0,
+	CLOCK__DDR_CLK_CH1,
+	CLOCK__DDR_CLK,
+	CLOCK__SPDIF_CLK,
+	CLOCK__HDMIA_CLK,
+	CLOCK__I2SRX_CLK,
+	CLOCK__I2STX_CLK,
+	CLOCK__PCM0_CLK,
+	CLOCK__PCM1_CLK,
+	CLOCK__CLK_CVBSX2,
+	CLOCK__CLK_CVBS,
+	CLOCK__CVBS_CLK108M,
+	CLOCK__CLK_PIXEL,
+	CLOCK__CLK_TMDS,
+	CLOCK__CLK_TMDS_PHY_P,
+	CLOCK__CLK_TMDS_PHY_N,
+	CLOCK__L2_NIC_CLK,
+	CLOCK__APBDBG_CLK,
+	CLOCK__L2_CLK,
+	CLOCK__ACP_CLK,
+	CLOCK__PERIPH_CLK,
+	CLOCK__NIC_DIV_CLK,
+	CLOCK__NIC_CLK,
+	CLOCK__AHBPREDIV_CLK,
+	CLOCK__H_CLK,
+	CLOCK__APB30_CLK,
+	CLOCK__APB20_CLK,
+	CLOCK__AHB_CLK,
+	CLOCK__CORE_CLK,
+	CLOCK__CPU_CLK,
+	CLOCK__SENSOR_CLKOUT0,
+	CLOCK__SENSOR_CLKOUT1,
+	CLOCK__LCD_CLK,
+	CLOCK__LVDS_CLK,
+	CLOCK__CKA_LCD_H,
+	CLOCK__LCD1_CLK,
+	CLOCK__LCD0_CLK,
+	CLOCK__DSI_HCLK,
+	CLOCK__DSI_HCLK90,
+	CLOCK__PRO_CLK,
+	CLOCK__PHY_CLK,
+	CLOCK__CSI_CLK,
+	CLOCK__DE1_CLK,
+	CLOCK__DE2_CLK,
+	CLOCK__BISP_CLK,
+	CLOCK__ISPBP_CLK,
+	CLOCK__IMG5_CLK,
+	CLOCK__VDE_CLK,
+	CLOCK__VCE_CLK,
+	CLOCK__NANDC_CLK,
+	CLOCK__ECC_CLK,
+	CLOCK__PRESD0_CLK,
+	CLOCK__PRESD1_CLK,
+	CLOCK__PRESD2_CLK,
+	CLOCK__SD0_CLK_2X,
+	CLOCK__SD1_CLK_2X,
+	CLOCK__SD2_CLK_2X,
+	CLOCK__SD0_CLK,
+	CLOCK__SD1_CLK,
+	CLOCK__SD2_CLK,
+	CLOCK__UART0_CLK,
+	CLOCK__UART1_CLK,
+	CLOCK__UART2_CLK,
+	CLOCK__UART3_CLK,
+	CLOCK__UART4_CLK,
+	CLOCK__UART5_CLK,
+	CLOCK__UART6_CLK,
+	CLOCK__PWM0_CLK,
+	CLOCK__PWM1_CLK,
+	CLOCK__PWM2_CLK,
+	CLOCK__PWM3_CLK,
+	CLOCK__PWM4_CLK,
+	CLOCK__PWM5_CLK,
+	CLOCK__RMII_REF_CLK,
+	CLOCK__I2C0_CLK,
+	CLOCK__I2C1_CLK,
+	CLOCK__I2C2_CLK,
+	CLOCK__I2C3_CLK,
+	CLOCK__25M_CLK,
+	CLOCK__LENS_CLK,
+	CLOCK__HDMI24M,
+	CLOCK__TIMER_CLK,
+	CLOCK__SS_CLK,
+	CLOCK__SPS_CLK,
+	CLOCK__IRC_CLK,
+	CLOCK__TV24M,
+	CLOCK__MIPI24M,
+	CLOCK__LENS24M,
+	CLOCK__GPU3D_SYSCLK,
+	CLOCK__GPU3D_HYDCLK,
+	CLOCK__GPU3D_NIC_MEMCLK,
+	CLOCK__GPU3D_CORECLK,
+	CLOCK__MAX
+};
+
+
+struct owl_clkreq {
+	int reg_no;
+	unsigned long *reg_hw;
+	unsigned long int mask;
+	int offset;
+};
+
+
+
+enum owl_divtype_e {
+	DIV_T_NATURE = 4,
+	DIV_T_EXP = 8,
+	DIV_T_EXP_D2,
+	DIV_T_TABLE = 16,
+	DIV_T_SEQ = 32,
+	DIV_T_SEQ_D2,
+	DIV_T_COMP = 64
+};
+
+struct owl_refertab {
+	int div[9];
+	int flac;
+};
+
+struct owl_seqtab {
+	int length;
+	int seq[9];
+};
+
+struct owl_section {
+	int type;
+	int range_from;
+	int range_to;
+	union {
+		struct owl_seqtab *seq;
+		struct owl_refertab *tab;
+	} ext;
+};
+
+struct owl_compdiv {
+	struct owl_section sections[2];
+};
+
+struct owl_div {
+	int type;
+	int range_from;
+	int range_to;
+	union {
+		struct owl_refertab *tab;
+		struct owl_seqtab *seq;
+		struct owl_compdiv *comp;
+	} ext;
+	struct owl_clkreq *reg;
+};
+
+
+
+enum owl_clocktype_e {
+	TYPE_STATIC, TYPE_PLL, TYPE_DYNAMIC
+};
+
+#define MAX_SRC_SEL 5
+
+struct owl_clocknode {
+	char name[32];
+	int id;
+	int type;
+
+	int source_av[MAX_SRC_SEL];
+	int source_lim;
+	int source_sel;
+	int putaway_enabled;
+	int putaway_sel;
+	int putaway_divsel;
+	int putback_divsel;
+
+	struct owl_clkreq *reg_srcsel;
+	int clock_en;
+
+	int multipler;
+	int divider;
+	int harddivider;
+	unsigned long frequency;
+	int changed;
+
+	struct owl_div *actdiv;
+	int divsel;
+
+	struct owl_clocknode *parent;
+	struct owl_clocknode *prev;
+	struct owl_clocknode *next;
+	struct owl_clocknode *sub;
+};
+
+
+
+
+
+enum owl_plltype_e {
+	PLL_T_STEP,
+	PLL_T_D4DYN,
+	PLL_T_FREQ
+};
+
+struct owl_pll {
+	int type;
+	int range_from;
+	int range_to;
+	union {
+		struct  {
+			int step;
+			int offset;
+		} step;
+		int freqtab[8];
+	} freq;
+	int sel;
+	int delay;
+	struct owl_clkreq *reg_pllen;
+	struct owl_clkreq *reg_pllfreq;
+	struct owl_clkreq *reg_plllock;
+};
+
+enum owl_pll_e {
+	PLL__COREPLL,
+	PLL__DEVPLL,
+	PLL__DDRPLL,
+	PLL__NANDPLL,
+	PLL__DISPLAYPLL,
+	PLL__AUDIOPLL,
+	PLL__TVOUTPLL,
+	PLL__DEEPCOLORPLL,
+	PLL__ETHERNETPLL,
+	PLL__CVBSPLL,
+	PLL__MAX
+};
+
+
+
+struct owl_cmumod {
+	char modname[32];
+	struct owl_clkreq *reg_devclken;
+	struct owl_clkreq *reg_devrst;
+};
+
+enum owl_cmumod_e {
+	MOD__ROOT,
+	MOD__GPU3D,
+	MOD__SHARESRAM,
+	MOD__HDCP2X,
+	MOD__VCE,
+	MOD__VDE,
+	MOD__PCM0,
+	MOD__SPDIF,
+	MOD__HDMIA,
+	MOD__I2SRX,
+	MOD__I2STX,
+	MOD__GPIO,
+	MOD__KEY,
+	MOD__LENS,
+	MOD__BISP,
+	MOD__CSI,
+	MOD__DSI,
+	MOD__LVDS,
+	MOD__LCD1,
+	MOD__LCD0,
+	MOD__DE,
+	MOD__SD2,
+	MOD__SD1,
+	MOD__SD0,
+	MOD__NANDC,
+	MOD__DDRCH0,
+	MOD__NOR,
+	MOD__DMAC,
+	MOD__DDRCH1,
+	MOD__I2C3,
+	MOD__I2C2,
+	MOD__TIMER,
+	MOD__PWM5,
+	MOD__PWM4,
+	MOD__PWM3,
+	MOD__PWM2,
+	MOD__PWM1,
+	MOD__PWM0,
+	MOD__ETHERNET,
+	MOD__UART5,
+	MOD__UART4,
+	MOD__UART3,
+	MOD__UART6,
+	MOD__PCM1,
+	MOD__I2C1,
+	MOD__I2C0,
+	MOD__SPI3,
+	MOD__SPI2,
+	MOD__SPI1,
+	MOD__SPI0,
+	MOD__IRC,
+	MOD__UART2,
+	MOD__UART1,
+	MOD__UART0,
+	MOD__HDMI,
+	MOD__SS,
+	MOD__TV24M,
+	MOD__CVBS_CLK108M,
+	MOD__TVOUT,
+	MOD__MAX_IN_CLK,
+
+	MOD__PERIPHRESET = MOD__MAX_IN_CLK,
+	MOD__NIC301,
+	MOD__AUDIO,
+	MOD__LCD,
+	MOD__DDR,
+	MOD__NORIF,
+	MOD__DBG3RESET,
+	MOD__DBG2RESET,
+	MOD__DBG1RESET,
+	MOD__DBG0RESET,
+	MOD__WD3RESET,
+	MOD__WD2RESET,
+	MOD__WD1RESET,
+	MOD__WD0RESET,
+	MOD__CHIPID,
+	MOD__USB3,
+	MOD__HDCP2Tx,
+	MOD__USB2_0,
+	MOD__USB2_1,
+	MOD__MAX
+};
+
+
+
+struct owl_clk_foo {
+	struct clk_hw hw;
+	int clock;
+};
+
+
+#define KILO	1000
+#define MEGA	(1000*KILO)
+
+#define PLLDELAY     50
+
+#define OWL_PLLDELAY(x)	((x)+(x)/4)
+#define OWL_COREPLL_DELAY		 OWL_PLLDELAY(120)
+#define OWL_DDRPLL_DELAY		 OWL_PLLDELAY(50)
+#define OWL_DEVPLL_DELAY		 OWL_PLLDELAY(22)
+#define OWL_NANDPLL_DELAY		 OWL_PLLDELAY(35)
+#define OWL_AUDIOPLL_DELAY		 OWL_PLLDELAY(80)
+#define OWL_DISPLAYPLL_DELAY	 OWL_PLLDELAY(45)
+#define OWL_TVOUTPLL_DELAY		 OWL_PLLDELAY(25)
+#define OWL_DEEPCOLORPLL_DELAY	 OWL_PLLDELAY(20)
+#define OWL_ETHERNETPLL_DELAY	 OWL_PLLDELAY(20)
+#define OWL_CVBSPLL_DELAY		 OWL_PLLDELAY(25)
+
+#define to_clk_foo(_hw)		container_of(_hw, struct owl_clk_foo, hw)
+#define to_clk_info(_hw)	container_of(_hw, struct owl_clk_info, hw)
+
+#define CMU_BITMAP(reg, _mask, _offset) \
+	{\
+		.reg_no = R_##reg, \
+		.reg_hw = (unsigned long *)reg, \
+		.mask = _mask, \
+		.offset = _offset,\
+	}
+
+int read_clkreg_val(struct owl_clkreq *reg);
+void write_clkreg_val(struct owl_clkreq *reg, int val);
+
+int owl_pllsub_set_putaway(int clock, int source);
+unsigned long owl_get_putaway_parent_rate(struct clk *clk);
+unsigned long owl_getparent_newrate(struct clk *clk);
+int owl_getdivider_index(struct clk *clk, int divexp);
+
+int owl_set_putaway_divsel(struct clk *clk, int tmp_divsel, int new_divsel);
+void owl_update_notify_newrate(struct clk *clk, unsigned long newrate);
+int owl_pll_in_change(void);
+
+#endif
diff --git a/arch/arm/mach-owl/clocktree-atm7059.c b/arch/arm/mach-owl/clocktree-atm7059.c
new file mode 100755
index 0000000..9d6e29d
--- /dev/null
+++ b/arch/arm/mach-owl/clocktree-atm7059.c
@@ -0,0 +1,3472 @@
+#include "clocktree-owl.h"
+
+static unsigned long rvregs[R_CMUMAX] = {
+    [R_CMU_COREPLL]                 =	0x00000064,
+    [R_CMU_DEVPLL]                  =	0x00001064,
+    [R_CMU_DDRPLL]                  =	0x00000019,
+    [R_CMU_NANDPLL]                 =	0x00000032,
+    [R_CMU_DISPLAYPLL]              =	0x00000064,
+    [R_CMU_AUDIOPLL]                =	0x10000001,
+    [R_CMU_TVOUTPLL]                =	0x00250000,
+    [R_CMU_BUSCLK]                  =	0x3df60012,
+    [R_CMU_SENSORCLK]               =	0x00000000,
+    [R_CMU_LCDCLK]                  =	0x00000100,
+    [R_CMU_DSICLK]                  =	0x00000000,
+    [R_CMU_CSICLK]                  =	0x00000000,
+    [R_CMU_DECLK]                   =	0x00000000,
+    [R_CMU_BISPCLK]                 =	0x00000000,
+    [R_CMU_VDECLK]                  =	0x00000000,
+    [R_CMU_VCECLK]                  =	0x00000000,
+    [R_CMU_NANDCCLK]                =	0x00000001,
+    [R_CMU_SD0CLK]                  =	0x00000000,
+    [R_CMU_SD1CLK]                  =	0x00000000,
+    [R_CMU_SD2CLK]                  =	0x00000000,
+    [R_CMU_UART0CLK]                =	0x00000000,
+    [R_CMU_UART1CLK]                =	0x00000000,
+    [R_CMU_UART2CLK]                =	0x00000000,
+    [R_CMU_PWM0CLK]                 =	0x00000000,
+    [R_CMU_PWM1CLK]                 =	0x00000000,
+    [R_CMU_PWM2CLK]                 =	0x00000000,
+    [R_CMU_PWM3CLK]                 =	0x00000000,
+    [R_CMU_ETHERNETPLL]             =	0x00000000,
+    [R_CMU_CVBSPLL]             =	0x00000000,
+    [R_CMU_LENSCLK]                 =	0x00000000,
+    [R_CMU_GPU3DCLK]                =	0x00000000,
+    [R_CMU_SSCLK]                   =	0x00000000,
+    [R_CMU_UART3CLK]                =	0x00000000,
+    [R_CMU_UART4CLK]                =	0x00000000,
+    [R_CMU_UART5CLK]                =	0x00000000,
+    [R_CMU_UART6CLK]                =	0x00000000,
+    [R_CMU_COREPLLDEBUG]            =	0x00000000,
+    [R_CMU_DEVPLLDEBUG]             =	0x00000000,
+    [R_CMU_DDRPLLDEBUG]             =	0x00000000,
+    [R_CMU_NANDPLLDEBUG]            =	0x00000000,
+    [R_CMU_DISPLAYPLLDEBUG]         =	0x00000000,
+    [R_CMU_TVOUTPLLDEBUG]           =	0x00000000,
+    [R_CMU_DEEPCOLORPLLDEBUG]       =	0x00000000,
+    [R_CMU_AUDIOPLL_ETHPLLDEBUG]    =	0x00000000,
+};
+
+static struct owl_clkreq busbit_DIVEN               = BITMAP(CMU_BUSCLK,                0x80000000, 31);
+
+static struct owl_clkreq divbit_SPDIF_CLK           = BITMAP(CMU_AUDIOPLL,              0xf0000000, 28);
+static struct owl_clkreq divbit_HDMIA_CLK           = BITMAP(CMU_AUDIOPLL,              0x0f000000, 24);
+static struct owl_clkreq divbit_I2SRX_CLK           = BITMAP(CMU_AUDIOPLL,              0x00f00000, 20);
+static struct owl_clkreq divbit_I2STX_CLK           = BITMAP(CMU_AUDIOPLL,              0x000f0000, 16);
+static struct owl_clkreq divbit_APBDBG_CLK          = BITMAP(CMU_BUSCLK,                0x1c000000, 26);
+static struct owl_clkreq divbit_ACP_CLK             = BITMAP(CMU_BUSCLK,                0x01800000, 23);
+static struct owl_clkreq divbit_PERIPH_CLK          = BITMAP(CMU_BUSCLK,                0x00700000, 20);
+static struct owl_clkreq divbit_NIC_DIV_CLK         = BITMAP(CMU_BUSCLK,                0x000c0000, 18);
+static struct owl_clkreq divbit_NIC_CLK             = BITMAP(CMU_BUSCLK,                0x00030000, 16);
+static struct owl_clkreq divbit_APB30_CLK           = BITMAP(CMU_BUSCLK,                0x0000c000, 14);
+static struct owl_clkreq divbit_APB20_CLK           = BITMAP(CMU_BUSCLK,                0x00000700, 8);
+static struct owl_clkreq divbit_AHBPREDIV_CLK       = BITMAP(CMU_BUSCLK1,               0x00003000, 12);
+static struct owl_clkreq divbit_H_CLK               = BITMAP(CMU_BUSCLK1,               0x0000000c, 2);
+static struct owl_clkreq divbit_SENSOR_CLKOUT1      = BITMAP(CMU_SENSORCLK,             0x00000f00, 8);
+static struct owl_clkreq divbit_SENSOR_CLKOUT0      = BITMAP(CMU_SENSORCLK,             0x0000000f, 0);
+static struct owl_clkreq divbit_LCD_CLK             = BITMAP(CMU_LCDCLK,                0x00000100, 8);
+static struct owl_clkreq divbit_LCD1_CLK            = BITMAP(CMU_LCDCLK,                0x000000f0, 4);
+static struct owl_clkreq divbit_LCD0_CLK            = BITMAP(CMU_LCDCLK,                0x0000000f, 0);
+static struct owl_clkreq divbit_PRO_CLK             = BITMAP(CMU_DSICLK,                0x00000030, 4);
+static struct owl_clkreq divbit_DSI_HCLK            = BITMAP(CMU_DSICLK,                0x00000003, 0);
+static struct owl_clkreq divbit_CSI_CLK             = BITMAP(CMU_CSICLK,                0x0000000f, 0);
+static struct owl_clkreq divbit_DE2_CLK             = BITMAP(CMU_DECLK,                 0x000000f0, 4);
+static struct owl_clkreq divbit_DE1_CLK             = BITMAP(CMU_DECLK,                 0x0000000f, 0);
+static struct owl_clkreq divbit_BISP_CLK            = BITMAP(CMU_BISPCLK,               0x0000000f, 0);
+static struct owl_clkreq divbit_VDE_CLK             = BITMAP(CMU_VDECLK,                0x00000007, 0);
+static struct owl_clkreq divbit_VCE_CLK             = BITMAP(CMU_VCECLK,                0x00000007, 0);
+static struct owl_clkreq divbit_ECC_CLK             = BITMAP(CMU_NANDCCLK,              0x00000070, 4);
+static struct owl_clkreq divbit_NANDC_CLK           = BITMAP(CMU_NANDCCLK,              0x00000007, 0);
+static struct owl_clkreq divbit_PRESD0_CLK          = BITMAP(CMU_SD0CLK,                0x0000001f, 0);
+static struct owl_clkreq divbit_SD0_CLK_2X          = BITMAP(CMU_SD0CLK,                0x00000100, 8);
+static struct owl_clkreq divbit_PRESD1_CLK          = BITMAP(CMU_SD1CLK,                0x0000001f, 0);
+static struct owl_clkreq divbit_SD1_CLK_2X          = BITMAP(CMU_SD1CLK,                0x00000100, 8);
+static struct owl_clkreq divbit_PRESD2_CLK          = BITMAP(CMU_SD2CLK,                0x0000001f, 0);
+static struct owl_clkreq divbit_SD2_CLK_2X          = BITMAP(CMU_SD2CLK,                0x00000100, 8);
+static struct owl_clkreq divbit_UART0_CLK           = BITMAP(CMU_UART0CLK,              0x000001ff, 0);
+static struct owl_clkreq divbit_UART1_CLK           = BITMAP(CMU_UART1CLK,              0x000001ff, 0);
+static struct owl_clkreq divbit_UART2_CLK           = BITMAP(CMU_UART2CLK,              0x000001ff, 0);
+static struct owl_clkreq divbit_PWM0_CLK            = BITMAP(CMU_PWM0CLK,               0x000003ff, 0);
+static struct owl_clkreq divbit_PWM1_CLK            = BITMAP(CMU_PWM1CLK,               0x000003ff, 0);
+static struct owl_clkreq divbit_PWM2_CLK            = BITMAP(CMU_PWM2CLK,               0x000003ff, 0);
+static struct owl_clkreq divbit_PWM3_CLK            = BITMAP(CMU_PWM3CLK,               0x000003ff, 0);
+static struct owl_clkreq divbit_PWM4_CLK            = BITMAP(CMU_PWM4CLK,               0x000003ff, 0);
+static struct owl_clkreq divbit_PWM5_CLK            = BITMAP(CMU_PWM5CLK,               0x000003ff, 0);
+static struct owl_clkreq divbit_RMII_REF_CLK        = BITMAP(CMU_ETHERNETPLL,           0x00000002, 1);
+static struct owl_clkreq divbit_LENS_CLK            = BITMAP(CMU_LENSCLK,               0x00000007, 0);
+static struct owl_clkreq divbit_GPU3D_SYSCLK        = BITMAP(CMU_GPU3DCLK,              0x07000000, 24);
+static struct owl_clkreq divbit_GPU3D_NIC_MEMCLK    = BITMAP(CMU_GPU3DCLK,              0x00070000, 16);
+static struct owl_clkreq divbit_GPU3D_HYDCLK        = BITMAP(CMU_GPU3DCLK,              0x00000700, 8);
+static struct owl_clkreq divbit_GPU3D_CORECLK       = BITMAP(CMU_GPU3DCLK,              0x00000007, 0);
+static struct owl_clkreq divbit_SS_CLK              = BITMAP(CMU_SSCLK,                 0x000003ff, 0);
+static struct owl_clkreq divbit_UART3_CLK           = BITMAP(CMU_UART3CLK,              0x000001ff, 0);
+static struct owl_clkreq divbit_UART4_CLK           = BITMAP(CMU_UART4CLK,              0x000001ff, 0);
+static struct owl_clkreq divbit_UART5_CLK           = BITMAP(CMU_UART5CLK,              0x000001ff, 0);
+static struct owl_clkreq divbit_UART6_CLK           = BITMAP(CMU_UART6CLK,              0x000001ff, 0);
+                                                                                        
+                                                                                        
+static struct owl_clkreq selbit_NIC_CLK             = BITMAP(CMU_BUSCLK,                0x00000070, 4);
+static struct owl_clkreq selbit_AHBPREDIV_CLK       = BITMAP(CMU_BUSCLK1,               0x00000700, 8);
+static struct owl_clkreq selbit_DEV_CLK             = BITMAP(CMU_DEVPLL,                0x00001000, 12);
+static struct owl_clkreq selbit_DDR_CLK_CH1         = BITMAP(CMU_DDRPLL,                0x00000600, 9);
+static struct owl_clkreq selbit_CORE_CLK            = BITMAP(CMU_BUSCLK,                0x00000003, 0);
+static struct owl_clkreq selbit_SENSOR_CLKOUT0      = BITMAP(CMU_SENSORCLK,             0x00000010, 4);
+static struct owl_clkreq selbit_SENSOR_CLKOUT1      = BITMAP(CMU_SENSORCLK,             0x00000010, 4);
+static struct owl_clkreq selbit_LCD_CLK             = BITMAP(CMU_LCDCLK,                0x00003000, 12);
+static struct owl_clkreq selbit_CSI_CLK             = BITMAP(CMU_CSICLK,                0x00000010, 4);
+static struct owl_clkreq selbit_IMG5_CLK            = BITMAP(CMU_DECLK,                 0x00020000, 17);
+static struct owl_clkreq selbit_DE1_CLK             = BITMAP(CMU_DECLK,                 0x00001000, 12);
+static struct owl_clkreq selbit_DE2_CLK             = BITMAP(CMU_DECLK,                 0x00001000, 12);
+static struct owl_clkreq selbit_BISP_CLK            = BITMAP(CMU_BISPCLK,               0x00000010, 4);
+static struct owl_clkreq selbit_VDE_CLK             = BITMAP(CMU_VDECLK,                0x00000030, 4);
+static struct owl_clkreq selbit_VCE_CLK             = BITMAP(CMU_VCECLK,                0x00000030, 4);
+static struct owl_clkreq selbit_NANDC_CLK           = BITMAP(CMU_NANDCCLK,              0x00000300, 8);
+static struct owl_clkreq selbit_ECC_CLK             = BITMAP(CMU_NANDCCLK,              0x00000300, 8);
+static struct owl_clkreq selbit_PRESD0_CLK          = BITMAP(CMU_SD0CLK,                0x00000200, 9);
+static struct owl_clkreq selbit_PRESD1_CLK          = BITMAP(CMU_SD1CLK,                0x00000200, 9);
+static struct owl_clkreq selbit_PRESD2_CLK          = BITMAP(CMU_SD2CLK,                0x00000200, 9);
+static struct owl_clkreq selbit_UART0_CLK           = BITMAP(CMU_UART0CLK,              0x00010000, 16);
+static struct owl_clkreq selbit_UART1_CLK           = BITMAP(CMU_UART1CLK,              0x00010000, 16);
+static struct owl_clkreq selbit_UART2_CLK           = BITMAP(CMU_UART2CLK,              0x00010000, 16);
+static struct owl_clkreq selbit_UART3_CLK           = BITMAP(CMU_UART3CLK,              0x00010000, 16);
+static struct owl_clkreq selbit_UART4_CLK           = BITMAP(CMU_UART4CLK,              0x00010000, 16);
+static struct owl_clkreq selbit_UART5_CLK           = BITMAP(CMU_UART5CLK,              0x00010000, 16);
+static struct owl_clkreq selbit_UART6_CLK           = BITMAP(CMU_UART6CLK,              0x00010000, 16);
+static struct owl_clkreq selbit_PWM0_CLK            = BITMAP(CMU_PWM0CLK,               0x00001000, 12);
+static struct owl_clkreq selbit_PWM1_CLK            = BITMAP(CMU_PWM1CLK,               0x00001000, 12);
+static struct owl_clkreq selbit_PWM2_CLK            = BITMAP(CMU_PWM2CLK,               0x00001000, 12);
+static struct owl_clkreq selbit_PWM3_CLK            = BITMAP(CMU_PWM3CLK,               0x00001000, 12);
+static struct owl_clkreq selbit_PWM4_CLK            = BITMAP(CMU_PWM4CLK,               0x00001000, 12);
+static struct owl_clkreq selbit_PWM5_CLK            = BITMAP(CMU_PWM5CLK,               0x00001000, 12);
+static struct owl_clkreq selbit_GPU3D_SYSCLK        = BITMAP(CMU_GPU3DCLK,              0x70000000, 28);
+static struct owl_clkreq selbit_GPU3D_NIC_MEMCLK    = BITMAP(CMU_GPU3DCLK,              0x00700000, 20);
+static struct owl_clkreq selbit_GPU3D_HYDCLK        = BITMAP(CMU_GPU3DCLK,              0x00007000, 12);
+static struct owl_clkreq selbit_GPU3D_CORECLK       = BITMAP(CMU_GPU3DCLK,              0x00000070, 4);
+                                                                                        
+                                                                                        
+static struct owl_clkreq pllbit_COREPLLEN           = BITMAP(CMU_COREPLL,               0x00000200, 9);
+static struct owl_clkreq pllbit_COREPLLFREQ         = BITMAP(CMU_COREPLL,               0x000000ff, 0);
+static struct owl_clkreq pllbit_DEVPLLEN            = BITMAP(CMU_DEVPLL,                0x00000100, 8);
+static struct owl_clkreq pllbit_DEVPLLFREQ          = BITMAP(CMU_DEVPLL,                0x0000007f, 0);
+static struct owl_clkreq pllbit_DDRPLLEN            = BITMAP(CMU_DDRPLL,                0x00000100, 8);
+static struct owl_clkreq pllbit_DDRPLLFREQ          = BITMAP(CMU_DDRPLL,                0x000000ff, 0);
+static struct owl_clkreq pllbit_NANDPLLEN           = BITMAP(CMU_NANDPLL,               0x00000100, 8);
+static struct owl_clkreq pllbit_NANDPLLFREQ         = BITMAP(CMU_NANDPLL,               0x0000007f, 0);
+static struct owl_clkreq pllbit_DISPLAYPLLEN        = BITMAP(CMU_DISPLAYPLL,            0x00000100, 8);
+static struct owl_clkreq pllbit_DISPALYPLLFREQ      = BITMAP(CMU_DISPLAYPLL,            0x000000ff, 0);
+static struct owl_clkreq pllbit_AUDIOPLLEN          = BITMAP(CMU_AUDIOPLL,              0x00000010, 4);
+static struct owl_clkreq pllbit_AUDIOPLLFREQ_SEL    = BITMAP(CMU_AUDIOPLL,              0x00000001, 0);
+static struct owl_clkreq pllbit_TVOUTPLLEN          = BITMAP(CMU_TVOUTPLL,              0x00000008, 3);
+static struct owl_clkreq pllbit_TVOUTPLLFREQ_SEL    = BITMAP(CMU_TVOUTPLL,              0x00070000, 16);
+static struct owl_clkreq pllbit_ENTRNETPLL_EN       = BITMAP(CMU_ETHERNETPLL,           0x00000001, 0);
+static struct owl_clkreq pllbit_CVBSPLL_EN       = BITMAP(CMU_CVBSPLL,           0x00000100, 8);
+static struct owl_clkreq pllbit_CVBSPLLREQ      = BITMAP(CMU_CVBSPLL,            0x000000ff, 0);
+static struct owl_clkreq pllbit_COREPLLLOCK         = BITMAP(CMU_COREPLLDEBUG,          0x00000800, 11);
+static struct owl_clkreq pllbit_DEVPLLLOCK          = BITMAP(CMU_DEVPLLDEBUG,           0x00000800, 11);
+static struct owl_clkreq pllbit_DDRPLLLOCK          = BITMAP(CMU_DDRPLLDEBUG,           0x80000000, 31);
+static struct owl_clkreq pllbit_NANDPLLLOCK         = BITMAP(CMU_NANDPLLDEBUG,          0x80000000, 31);
+static struct owl_clkreq pllbit_DISPLAYPLLLOCK      = BITMAP(CMU_DISPLAYPLLDEBUG,       0x80000000, 31);
+static struct owl_clkreq pllbit_TVOUTPLLLOCK        = BITMAP(CMU_TVOUTPLLDEBUG,         0x00004000, 14);
+static struct owl_clkreq pllbit_ETHERNETPLLLOCK     = BITMAP(CMU_AUDIOPLL_ETHPLLDEBUG,  0x00800000, 23);
+static struct owl_clkreq pllbit_AUDIOPLLLOCK        = BITMAP(CMU_AUDIOPLL_ETHPLLDEBUG,  0x00000200, 9);
+static struct owl_clkreq pllbit_CVBSPLLLOCK        = BITMAP(CMU_CVBSPLLDEBUG,  0x00000200, 9);
+
+
+static struct owl_clkreq enablebit_HOSC             = BITMAP(CMU_COREPLL,               0x00000100, 8);
+static struct owl_clkreq enablebit_MODULE_GPU3D     = BITMAP(CMU_DEVCLKEN0,             0x40000000, 30);
+static struct owl_clkreq enablebit_MODULE_SHARESRAM = BITMAP(CMU_DEVCLKEN0,             0x10000000, 28);
+static struct owl_clkreq enablebit_MODULE_HDCP2X    = BITMAP(CMU_DEVCLKEN0,             0x08000000, 27);
+static struct owl_clkreq enablebit_MODULE_VCE       = BITMAP(CMU_DEVCLKEN0,             0x04000000, 26);
+static struct owl_clkreq enablebit_MODULE_VDE       = BITMAP(CMU_DEVCLKEN0,             0x02000000, 25);
+static struct owl_clkreq enablebit_MODULE_PCM0      = BITMAP(CMU_DEVCLKEN0,             0x01000000, 24);
+static struct owl_clkreq enablebit_MODULE_SPDIF     = BITMAP(CMU_DEVCLKEN0,             0x00800000, 23);
+static struct owl_clkreq enablebit_MODULE_HDMIA     = BITMAP(CMU_DEVCLKEN0,             0x00400000, 22);
+static struct owl_clkreq enablebit_MODULE_I2SRX     = BITMAP(CMU_DEVCLKEN0,             0x00200000, 21);
+static struct owl_clkreq enablebit_MODULE_I2STX     = BITMAP(CMU_DEVCLKEN0,             0x00100000, 20);
+static struct owl_clkreq enablebit_MODULE_GPIO      = BITMAP(CMU_DEVCLKEN0,             0x00040000, 18);
+static struct owl_clkreq enablebit_MODULE_KEY       = BITMAP(CMU_DEVCLKEN0,             0x00020000, 17);
+static struct owl_clkreq enablebit_MODULE_LENS      = BITMAP(CMU_DEVCLKEN0,             0x00010000, 16);
+static struct owl_clkreq enablebit_MODULE_BISP      = BITMAP(CMU_DEVCLKEN0,             0x00004000, 14);
+static struct owl_clkreq enablebit_MODULE_CSI       = BITMAP(CMU_DEVCLKEN0,             0x00002000, 13);
+static struct owl_clkreq enablebit_MODULE_DSI       = BITMAP(CMU_DEVCLKEN0,             0x00001000, 12);
+static struct owl_clkreq enablebit_MODULE_LVDS      = BITMAP(CMU_DEVCLKEN0,             0x00000800, 11);
+static struct owl_clkreq enablebit_MODULE_LCD1      = BITMAP(CMU_DEVCLKEN0,             0x00000400, 10);
+static struct owl_clkreq enablebit_MODULE_LCD0      = BITMAP(CMU_DEVCLKEN0,             0x00000200, 9);
+static struct owl_clkreq enablebit_MODULE_DE        = BITMAP(CMU_DEVCLKEN0,             0x00000100, 8);
+static struct owl_clkreq enablebit_MODULE_SD2       = BITMAP(CMU_DEVCLKEN0,             0x00000080, 7);
+static struct owl_clkreq enablebit_MODULE_SD1       = BITMAP(CMU_DEVCLKEN0,             0x00000040, 6);
+static struct owl_clkreq enablebit_MODULE_SD0       = BITMAP(CMU_DEVCLKEN0,             0x00000020, 5);
+static struct owl_clkreq enablebit_MODULE_NANDC     = BITMAP(CMU_DEVCLKEN0,             0x00000010, 4);
+static struct owl_clkreq enablebit_MODULE_DDRCH0    = BITMAP(CMU_DEVCLKEN0,             0x00000008, 3);
+static struct owl_clkreq enablebit_MODULE_NOR       = BITMAP(CMU_DEVCLKEN0,             0x00000004, 2);
+static struct owl_clkreq enablebit_MODULE_DMAC      = BITMAP(CMU_DEVCLKEN0,             0x00000002, 1);
+static struct owl_clkreq enablebit_MODULE_DDRCH1    = BITMAP(CMU_DEVCLKEN0,             0x00000001, 0);
+static struct owl_clkreq enablebit_MODULE_I2C3      = BITMAP(CMU_DEVCLKEN1,             0x80000000, 31);
+static struct owl_clkreq enablebit_MODULE_I2C2      = BITMAP(CMU_DEVCLKEN1,             0x40000000, 30);
+static struct owl_clkreq enablebit_MODULE_TIMER     = BITMAP(CMU_DEVCLKEN1,             0x08000000, 27);
+static struct owl_clkreq enablebit_MODULE_PWM5      = BITMAP(CMU_DEVCLKEN0,             0x00000001, 0);
+static struct owl_clkreq enablebit_MODULE_PWM4      = BITMAP(CMU_DEVCLKEN0,             0x00000800, 11);
+static struct owl_clkreq enablebit_MODULE_PWM3      = BITMAP(CMU_DEVCLKEN1,             0x04000000, 26);
+static struct owl_clkreq enablebit_MODULE_PWM2      = BITMAP(CMU_DEVCLKEN1,             0x02000000, 25);
+static struct owl_clkreq enablebit_MODULE_PWM1      = BITMAP(CMU_DEVCLKEN1,             0x01000000, 24);
+static struct owl_clkreq enablebit_MODULE_PWM0      = BITMAP(CMU_DEVCLKEN1,             0x00800000, 23);
+static struct owl_clkreq enablebit_MODULE_ETHERNET  = BITMAP(CMU_DEVCLKEN1,             0x00400000, 22);
+static struct owl_clkreq enablebit_MODULE_UART5     = BITMAP(CMU_DEVCLKEN1,             0x00200000, 21);
+static struct owl_clkreq enablebit_MODULE_UART4     = BITMAP(CMU_DEVCLKEN1,             0x00100000, 20);
+static struct owl_clkreq enablebit_MODULE_UART3     = BITMAP(CMU_DEVCLKEN1,             0x00080000, 19);
+static struct owl_clkreq enablebit_MODULE_UART6     = BITMAP(CMU_DEVCLKEN1,             0x00040000, 18);
+static struct owl_clkreq enablebit_MODULE_PCM1      = BITMAP(CMU_DEVCLKEN1,             0x00010000, 16);
+static struct owl_clkreq enablebit_MODULE_I2C1      = BITMAP(CMU_DEVCLKEN1,             0x00008000, 15);
+static struct owl_clkreq enablebit_MODULE_I2C0      = BITMAP(CMU_DEVCLKEN1,             0x00004000, 14);
+static struct owl_clkreq enablebit_MODULE_SPI3      = BITMAP(CMU_DEVCLKEN1,             0x00002000, 13);
+static struct owl_clkreq enablebit_MODULE_SPI2      = BITMAP(CMU_DEVCLKEN1,             0x00001000, 12);
+static struct owl_clkreq enablebit_MODULE_SPI1      = BITMAP(CMU_DEVCLKEN1,             0x00000800, 11);
+static struct owl_clkreq enablebit_MODULE_SPI0      = BITMAP(CMU_DEVCLKEN1,             0x00000400, 10);
+static struct owl_clkreq enablebit_MODULE_IRC       = BITMAP(CMU_DEVCLKEN1,             0x00000200, 9);
+static struct owl_clkreq enablebit_MODULE_UART2     = BITMAP(CMU_DEVCLKEN1,             0x00000100, 8);
+static struct owl_clkreq enablebit_MODULE_UART1     = BITMAP(CMU_DEVCLKEN1,             0x00000080, 7);
+static struct owl_clkreq enablebit_MODULE_UART0     = BITMAP(CMU_DEVCLKEN1,             0x00000040, 6);
+static struct owl_clkreq enablebit_MODULE_HDMI      = BITMAP(CMU_DEVCLKEN1,             0x00000008, 3);
+static struct owl_clkreq enablebit_MODULE_SS        = BITMAP(CMU_DEVCLKEN1,             0x00000004, 2);
+static struct owl_clkreq enablebit_MODULE_TV24M     = BITMAP(CMU_TVOUTPLL,              0x00800000, 23);
+static struct owl_clkreq enablebit_MODULE_CVBS_CLK108M     = BITMAP(CMU_CVBSPLL,              0x00000200, 9);
+static struct owl_clkreq enablebit_MODULE_TVOUT     = BITMAP(CMU_DEVCLKEN1,             0x00000001, 0);
+
+static struct owl_clkreq resetbit_MODULE_PERIPHRESET       = BITMAP(CMU_DEVRST0,               0x08000000, 27);
+static struct owl_clkreq resetbit_MODULE_LENS              = BITMAP(CMU_DEVRST0,               0x04000000, 26);
+static struct owl_clkreq resetbit_MODULE_NIC301            = BITMAP(CMU_DEVRST0,               0x00800000, 23);
+static struct owl_clkreq resetbit_MODULE_GPU3D             = BITMAP(CMU_DEVRST0,               0x00400000, 22);
+static struct owl_clkreq resetbit_MODULE_VCE               = BITMAP(CMU_DEVRST0,               0x00100000, 20);
+static struct owl_clkreq resetbit_MODULE_VDE               = BITMAP(CMU_DEVRST0,               0x00080000, 19);
+static struct owl_clkreq resetbit_MODULE_PCM0              = BITMAP(CMU_DEVRST0,               0x00040000, 18);
+static struct owl_clkreq resetbit_MODULE_AUDIO             = BITMAP(CMU_DEVRST0,               0x00020000, 17);
+static struct owl_clkreq resetbit_MODULE_GPIO              = BITMAP(CMU_DEVRST0,               0x00008000, 15);
+static struct owl_clkreq resetbit_MODULE_KEY               = BITMAP(CMU_DEVRST0,               0x00004000, 14);
+static struct owl_clkreq resetbit_MODULE_BISP              = BITMAP(CMU_DEVRST0,               0x00001000, 12);
+static struct owl_clkreq resetbit_MODULE_CSI               = BITMAP(CMU_DEVRST0,               0x00000800, 11);
+static struct owl_clkreq resetbit_MODULE_DSI               = BITMAP(CMU_DEVRST0,               0x00000400, 10);
+static struct owl_clkreq resetbit_MODULE_SD2               = BITMAP(CMU_DEVRST0,               0x00000200, 9);
+static struct owl_clkreq resetbit_MODULE_LCD               = BITMAP(CMU_DEVRST0,               0x00000100, 8);
+static struct owl_clkreq resetbit_MODULE_DE                = BITMAP(CMU_DEVRST0,               0x00000080, 7);
+static struct owl_clkreq resetbit_MODULE_PCM1              = BITMAP(CMU_DEVRST0,               0x00000040, 6);
+static struct owl_clkreq resetbit_MODULE_SD1               = BITMAP(CMU_DEVRST0,               0x00000020, 5);
+static struct owl_clkreq resetbit_MODULE_SD0               = BITMAP(CMU_DEVRST0,               0x00000010, 4);
+static struct owl_clkreq resetbit_MODULE_NANDC             = BITMAP(CMU_DEVRST0,               0x00000008, 3);
+static struct owl_clkreq resetbit_MODULE_DDR               = BITMAP(CMU_DEVRST0,               0x00000004, 2);
+static struct owl_clkreq resetbit_MODULE_NORIF             = BITMAP(CMU_DEVRST0,               0x00000002, 1);
+static struct owl_clkreq resetbit_MODULE_DMAC              = BITMAP(CMU_DEVRST0,               0x00000001, 0);
+static struct owl_clkreq resetbit_MODULE_DBG3RESET         = BITMAP(CMU_DEVRST1,               0x80000000, 31);
+static struct owl_clkreq resetbit_MODULE_DBG2RESET         = BITMAP(CMU_DEVRST1,               0x40000000, 30);
+static struct owl_clkreq resetbit_MODULE_DBG1RESET         = BITMAP(CMU_DEVRST1,               0x20000000, 29);
+static struct owl_clkreq resetbit_MODULE_DBG0RESET         = BITMAP(CMU_DEVRST1,               0x10000000, 28);
+static struct owl_clkreq resetbit_MODULE_WD3RESET          = BITMAP(CMU_DEVRST1,               0x08000000, 27);
+static struct owl_clkreq resetbit_MODULE_WD2RESET          = BITMAP(CMU_DEVRST1,               0x04000000, 26);
+static struct owl_clkreq resetbit_MODULE_WD1RESET          = BITMAP(CMU_DEVRST1,               0x02000000, 25);
+static struct owl_clkreq resetbit_MODULE_WD0RESET          = BITMAP(CMU_DEVRST1,               0x01000000, 24);
+static struct owl_clkreq resetbit_MODULE_USB2_1            = BITMAP(CMU_DEVRST1,               0x00400000, 22);
+static struct owl_clkreq resetbit_MODULE_CHIPID            = BITMAP(CMU_DEVRST1,               0x00200000, 21);
+static struct owl_clkreq resetbit_MODULE_ETHERNET          = BITMAP(CMU_DEVRST1,               0x00100000, 20);
+static struct owl_clkreq resetbit_MODULE_I2C3              = BITMAP(CMU_DEVRST1,               0x00080000, 19);
+static struct owl_clkreq resetbit_MODULE_I2C2              = BITMAP(CMU_DEVRST1,               0x00040000, 18);
+static struct owl_clkreq resetbit_MODULE_UART5             = BITMAP(CMU_DEVRST1,               0x00020000, 17);
+static struct owl_clkreq resetbit_MODULE_UART4             = BITMAP(CMU_DEVRST1,               0x00010000, 16);
+static struct owl_clkreq resetbit_MODULE_UART3             = BITMAP(CMU_DEVRST1,               0x00008000, 15);
+static struct owl_clkreq resetbit_MODULE_USB3              = BITMAP(CMU_DEVRST1,               0x00004000, 14);
+static struct owl_clkreq resetbit_MODULE_I2C1              = BITMAP(CMU_DEVRST1,               0x00002000, 13);
+static struct owl_clkreq resetbit_MODULE_I2C0              = BITMAP(CMU_DEVRST1,               0x00001000, 12);
+static struct owl_clkreq resetbit_MODULE_SPI3              = BITMAP(CMU_DEVRST1,               0x00000800, 11);
+static struct owl_clkreq resetbit_MODULE_SPI2              = BITMAP(CMU_DEVRST1,               0x00000400, 10);
+static struct owl_clkreq resetbit_MODULE_SPI1              = BITMAP(CMU_DEVRST1,               0x00000200, 9);
+static struct owl_clkreq resetbit_MODULE_SPI0              = BITMAP(CMU_DEVRST1,               0x00000100, 8);
+static struct owl_clkreq resetbit_MODULE_UART2             = BITMAP(CMU_DEVRST1,               0x00000080, 7);
+static struct owl_clkreq resetbit_MODULE_UART1             = BITMAP(CMU_DEVRST1,               0x00000040, 6);
+static struct owl_clkreq resetbit_MODULE_UART0             = BITMAP(CMU_DEVRST1,               0x00000020, 5);
+static struct owl_clkreq resetbit_MODULE_UART6             = BITMAP(CMU_DEVRST1,               0x00000010, 4);
+static struct owl_clkreq resetbit_MODULE_HDCP2X              = BITMAP(CMU_DEVRST1,               0x00000008, 3);
+static struct owl_clkreq resetbit_MODULE_HDMI              = BITMAP(CMU_DEVRST1,               0x00000004, 2);
+static struct owl_clkreq resetbit_MODULE_TVOUT             = BITMAP(CMU_DEVRST1,               0x00000002, 1);
+static struct owl_clkreq resetbit_MODULE_USB2_0            = BITMAP(CMU_DEVRST1,               0x00000001, 0);
+
+
+static struct owl_clocknode clocks[CLOCK__MAX] = {
+	CLOCKNODE_ROOT(HOSC, FREQUENCY_24M),
+	CLOCKNODE_ROOT(IC_32K, FREQUENCY_32K),
+	PLLNODE(COREPLL, HOSC),
+	PLLNODE(DEVPLL, HOSC),
+	PLLNODE(DDRPLL, HOSC),
+	PLLNODE(NANDPLL, HOSC),
+	PLLNODE(DISPLAYPLL, HOSC),
+	PLLNODE(AUDIOPLL, HOSC),
+	PLLNODE(TVOUTPLL, HOSC),
+	CLOCKNODE_UNUSED(DEEPCOLORPLL),
+	PLLNODE(ETHERNETPLL, HOSC),
+	PLLNODE(CVBSPLL, HOSC),
+	CLOCKNODE_S2(DEV_CLK, HOSC, DEVPLL, 0),
+	CLOCKNODE_S1(DDR_CLK_0, DDRPLL),
+	CLOCKNODE_S1(DDR_CLK_90, DDRPLL),
+	CLOCKNODE_S1(DDR_CLK_180, DDRPLL),
+	CLOCKNODE_S1(DDR_CLK_270, DDRPLL),
+	CLOCKNODE_S1(DDR_CLK_CH0, DDR_CLK_0),
+	CLOCKNODE_S4(DDR_CLK_CH1, DDR_CLK_0, DDR_CLK_90, DDR_CLK_180, DDR_CLK_270, 0),
+	CLOCKNODE_S1(DDR_CLK, DDR_CLK_0),
+	CLOCKNODE_S1(SPDIF_CLK, AUDIOPLL),
+	CLOCKNODE_S1(HDMIA_CLK, AUDIOPLL),
+	CLOCKNODE_S1(I2SRX_CLK, AUDIOPLL),
+	CLOCKNODE_S1(I2STX_CLK, AUDIOPLL),
+	CLOCKNODE_S1(PCM0_CLK, AUDIOPLL),
+	CLOCKNODE_S1(PCM1_CLK, AUDIOPLL),
+	CLOCKNODE_UNUSED(CLK_CVBSX2),
+	CLOCKNODE_UNUSED(CLK_CVBS),
+	CLOCKNODE_S1(CVBS_CLK108M, HOSC),
+	CLOCKNODE_S1(CLK_PIXEL, TVOUTPLL),
+	CLOCKNODE_S1(CLK_TMDS, TVOUTPLL),
+	CLOCKNODE_S1(CLK_TMDS_PHY_P, CLK_TMDS),
+	CLOCKNODE_UNUSED(CLK_TMDS_PHY_N),
+	CLOCKNODE_S1(L2_NIC_CLK, CORE_CLK),
+	CLOCKNODE_S1(APBDBG_CLK, CPU_CLK),
+	CLOCKNODE_S1(L2_CLK, CPU_CLK),
+	CLOCKNODE_S1(ACP_CLK, CPU_CLK),
+	CLOCKNODE_S1(PERIPH_CLK, CPU_CLK),
+	CLOCKNODE_S1(NIC_DIV_CLK, NIC_CLK),
+	CLOCKNODE_S4(NIC_CLK, DEV_CLK, DISPLAYPLL, NANDPLL, DDRPLL, 0),
+	CLOCKNODE_S4(AHBPREDIV_CLK, DEV_CLK, DISPLAYPLL, NANDPLL, DDRPLL, 0),
+	CLOCKNODE_S1(H_CLK, AHBPREDIV_CLK),
+	CLOCKNODE_S1(APB30_CLK, NIC_CLK),
+	CLOCKNODE_S1(APB20_CLK, NIC_CLK),
+	CLOCKNODE_S1(AHB_CLK, H_CLK),
+	CLOCKNODE_S4(CORE_CLK, IC_32K, HOSC, COREPLL, VCE_CLK, 1),
+	CLOCKNODE_S1(CPU_CLK, CORE_CLK),
+	CLOCKNODE_S2(SENSOR_CLKOUT0, HOSC, ISPBP_CLK, 0),
+	CLOCKNODE_S2(SENSOR_CLKOUT1, HOSC, ISPBP_CLK, 0),
+	CLOCKNODE_S2(LCD_CLK, DISPLAYPLL, DEV_CLK, 0),
+	CLOCKNODE_S1(LVDS_CLK, DISPLAYPLL),
+	CLOCKNODE_S1(CKA_LCD_H, LVDS_CLK),
+	CLOCKNODE_S1(LCD1_CLK, LCD_CLK),
+	CLOCKNODE_S1(LCD0_CLK, LCD_CLK),
+	CLOCKNODE_S1(DSI_HCLK, DISPLAYPLL),
+	CLOCKNODE_S1(DSI_HCLK90, DSI_HCLK),
+	CLOCKNODE_S1(PRO_CLK, DSI_HCLK90),
+	CLOCKNODE_S1(PHY_CLK, DSI_HCLK90),
+	CLOCKNODE_S2(CSI_CLK, DISPLAYPLL, DEV_CLK, 0),
+	CLOCKNODE_S2(DE1_CLK, DISPLAYPLL, DEV_CLK, 0),
+	CLOCKNODE_S2(DE2_CLK, DISPLAYPLL, DEV_CLK, 0),
+	CLOCKNODE_S2(BISP_CLK, DISPLAYPLL, DEV_CLK, 0),
+	CLOCKNODE_S1(ISPBP_CLK, BISP_CLK),
+	CLOCKNODE_S2(IMG5_CLK, LCD1_CLK, LCD0_CLK, 0),
+	CLOCKNODE_S4(VDE_CLK, DEV_CLK, DISPLAYPLL, NANDPLL, DDRPLL, 0),
+	CLOCKNODE_S4(VCE_CLK, DEV_CLK, DISPLAYPLL, NANDPLL, DDRPLL, 0),
+	CLOCKNODE_S4(NANDC_CLK, NANDPLL, DISPLAYPLL, DEV_CLK, DDRPLL, 2),
+	CLOCKNODE_S4(ECC_CLK, NANDPLL, DISPLAYPLL, DEV_CLK, DDRPLL, 2),
+	CLOCKNODE_S2(PRESD0_CLK, DEV_CLK, NANDPLL, 0),
+	CLOCKNODE_S2(PRESD1_CLK, DEV_CLK, NANDPLL, 0),
+	CLOCKNODE_S2(PRESD2_CLK, DEV_CLK, NANDPLL, 0),
+	CLOCKNODE_S1(SD0_CLK_2X, PRESD0_CLK),
+	CLOCKNODE_S1(SD1_CLK_2X, PRESD1_CLK),
+	CLOCKNODE_S1(SD2_CLK_2X, PRESD2_CLK),
+	CLOCKNODE_S1(SD0_CLK, SD0_CLK_2X),
+	CLOCKNODE_S1(SD1_CLK, SD1_CLK_2X),
+	CLOCKNODE_S1(SD2_CLK, SD2_CLK_2X),
+	CLOCKNODE_S2(UART0_CLK, HOSC, DEVPLL, 0),
+	CLOCKNODE_S2(UART1_CLK, HOSC, DEVPLL, 0),
+	CLOCKNODE_S2(UART2_CLK, HOSC, DEVPLL, 0),
+	CLOCKNODE_S2(UART3_CLK, HOSC, DEVPLL, 0),
+	CLOCKNODE_S2(UART4_CLK, HOSC, DEVPLL, 0),
+	CLOCKNODE_S2(UART5_CLK, HOSC, DEVPLL, 0),
+	CLOCKNODE_S2(UART6_CLK, HOSC, DEVPLL, 0),
+	CLOCKNODE_S2(PWM0_CLK, IC_32K, HOSC, 0),
+	CLOCKNODE_S2(PWM1_CLK, IC_32K, HOSC, 0),
+	CLOCKNODE_S2(PWM2_CLK, IC_32K, HOSC, 0),
+	CLOCKNODE_S2(PWM3_CLK, IC_32K, HOSC, 0),
+	CLOCKNODE_S2(PWM4_CLK, IC_32K, HOSC, 0),
+	CLOCKNODE_S2(PWM5_CLK, IC_32K, HOSC, 0),
+	CLOCKNODE_S1(RMII_REF_CLK, ETHERNETPLL),
+	CLOCKNODE_S1(I2C0_CLK, ETHERNETPLL),
+	CLOCKNODE_S1(I2C1_CLK, ETHERNETPLL),
+	CLOCKNODE_S1(I2C2_CLK, ETHERNETPLL),
+	CLOCKNODE_S1(I2C3_CLK, ETHERNETPLL),
+	CLOCKNODE_S1(25M_CLK, ETHERNETPLL),
+	CLOCKNODE_S1(LENS_CLK, HOSC),
+	CLOCKNODE_S1(HDMI24M, HOSC),
+	CLOCKNODE_S1(TIMER_CLK, HOSC),
+	CLOCKNODE_S1(SS_CLK, HOSC),
+	CLOCKNODE_S1(SPS_CLK, HOSC),
+	CLOCKNODE_S1(IRC_CLK, HOSC),
+	CLOCKNODE_S1(TV24M, HOSC),
+	CLOCKNODE_S1(MIPI24M, HOSC),
+	CLOCKNODE_S1(LENS24M, HOSC),
+	CLOCKNODE_S5(GPU3D_SYSCLK, DEV_CLK, DISPLAYPLL, NANDPLL, DDRPLL, CVBSPLL, 0),
+	CLOCKNODE_S5(GPU3D_HYDCLK, DEV_CLK, DISPLAYPLL, NANDPLL, DDRPLL, CVBSPLL, 0),
+	CLOCKNODE_S5(GPU3D_NIC_MEMCLK, DEV_CLK, DISPLAYPLL, NANDPLL, DDRPLL, CVBSPLL, 0),
+	CLOCKNODE_S5(GPU3D_CORECLK, DEV_CLK, DISPLAYPLL, NANDPLL, DDRPLL, CVBSPLL, 0),
+};
+
+static struct owl_pll pllnode[PLL__MAX] = {
+    [PLL__COREPLL] = {
+        .type = PLL_T_STEP,
+        .range_from = 48/12,
+        .range_to = 1608/12,
+        .freq.step.step = 12 * MEGA,
+        .sel = -1,
+        .delay = OWL_COREPLL_DELAY,
+        .reg_pllen = &pllbit_COREPLLEN,
+        .reg_pllfreq = &pllbit_COREPLLFREQ,
+        .reg_plllock = &pllbit_COREPLLLOCK,
+    },
+    [PLL__DEVPLL] = {
+        .type = PLL_T_STEP,
+        .range_from = 48/6,
+        .range_to = 756/6,
+        .freq.step.step = 6 * MEGA,
+        .sel = -1,
+        .delay = OWL_DEVPLL_DELAY,
+        .reg_pllen = &pllbit_DEVPLLEN,
+        .reg_pllfreq = &pllbit_DEVPLLFREQ,
+        .reg_plllock = &pllbit_DEVPLLLOCK,
+    },
+    [PLL__DDRPLL] = {
+        .type = PLL_T_STEP,
+        .range_from = 12/12,
+        .range_to = 804/12,
+        .freq.step.step = 12 * MEGA,
+        .sel = -1,
+        .delay = OWL_DDRPLL_DELAY,
+        .reg_pllen = &pllbit_DDRPLLEN,
+        .reg_pllfreq = &pllbit_DDRPLLFREQ,
+        .reg_plllock = &pllbit_DDRPLLLOCK,
+    },
+    [PLL__NANDPLL] = {
+        .type = PLL_T_STEP,
+        .range_from = 12/6,
+        .range_to = 516/6,
+        .freq.step.step = 6 * MEGA,
+        .sel = -1,
+        .delay = OWL_NANDPLL_DELAY,
+        .reg_pllen = &pllbit_NANDPLLEN,
+        .reg_pllfreq = &pllbit_NANDPLLFREQ,
+        .reg_plllock = &pllbit_NANDPLLLOCK,
+    },
+    [PLL__DISPLAYPLL] = {
+        .type = PLL_T_STEP,
+        .range_from = 12/6,
+        .range_to = 756/6,
+        .freq.step.step = 6 * MEGA,
+        .sel = -1,
+        .delay = OWL_DISPLAYPLL_DELAY,
+        .reg_pllen = &pllbit_DISPLAYPLLEN,
+        .reg_pllfreq = &pllbit_DISPALYPLLFREQ,
+        .reg_plllock = &pllbit_DISPLAYPLLLOCK,
+    },
+
+    [PLL__AUDIOPLL] = {
+        .type = PLL_T_FREQ,
+        .range_from = 0,
+        .range_to = 1,
+        .freq.freqtab = {45158400, 49152*KILO},
+        .sel = -1,
+        .delay = OWL_AUDIOPLL_DELAY,
+        .reg_pllen = &pllbit_AUDIOPLLEN,
+        .reg_pllfreq = &pllbit_AUDIOPLLFREQ_SEL,
+        .reg_plllock = &pllbit_AUDIOPLLLOCK,
+    },
+    [PLL__TVOUTPLL] = {
+        .type = PLL_T_FREQ,
+        .range_from = 0,
+        .range_to = 7,
+        .freq.freqtab = {25200*KILO, 27*MEGA, 50400*KILO, 54*MEGA, 74250*KILO, 108*MEGA, 148500*KILO, 297*MEGA},
+        .sel = -1,
+        .delay = OWL_TVOUTPLL_DELAY,
+        .reg_pllen = &pllbit_TVOUTPLLEN,
+        .reg_pllfreq = &pllbit_TVOUTPLLFREQ_SEL,
+        .reg_plllock = &pllbit_TVOUTPLLLOCK,
+    },
+    [PLL__ETHERNETPLL] = {
+        .type = PLL_T_FREQ,
+        .range_from = 0,
+        .range_to = 0,
+        .freq.freqtab = {500 * MEGA},
+        .sel = -1,
+        .delay = OWL_ETHERNETPLL_DELAY,
+        .reg_pllen = &pllbit_ENTRNETPLL_EN,
+        .reg_plllock = &pllbit_ETHERNETPLLLOCK,
+    },
+    [PLL__CVBSPLL] = {
+        .type = PLL_T_STEP,
+        .range_from = (348/12)-2,
+        .range_to = (540/12)-2,
+        .freq.step.step = 12 * MEGA,
+        .freq.step.offset = 2,
+        .sel = -1,
+        .delay = OWL_CVBSPLL_DELAY,
+        .reg_pllen = &pllbit_CVBSPLL_EN,
+        .reg_pllfreq = &pllbit_CVBSPLLREQ,
+        .reg_plllock = &pllbit_CVBSPLLLOCK,
+    },
+};
+
+static struct owl_cmumod modnode[MOD__MAX] = {
+    [MOD__ROOT]         = {"CMUMOD_DEVCLKS",    NULL,                           NULL                        },
+    [MOD__GPU3D]        = {"CMUMOD_GPU3D",      &enablebit_MODULE_GPU3D,        &resetbit_MODULE_GPU3D      },
+    [MOD__SHARESRAM]    = {"CMUMOD_SHARESRAM",  &enablebit_MODULE_SHARESRAM,    NULL                        },
+    [MOD__HDCP2X]       = {"CMUMOD_HDCP2X",     &enablebit_MODULE_HDCP2X,       &resetbit_MODULE_HDCP2X                        },
+    [MOD__VCE]          = {"CMUMOD_VCE",        &enablebit_MODULE_VCE,          &resetbit_MODULE_VCE        },
+    [MOD__VDE]          = {"CMUMOD_VDE",        &enablebit_MODULE_VDE,          &resetbit_MODULE_VDE        },
+    [MOD__PCM0]         = {"CMUMOD_PCM0",       &enablebit_MODULE_PCM0,         &resetbit_MODULE_PCM0       },
+    [MOD__SPDIF]        = {"CMUMOD_SPDIF",      &enablebit_MODULE_SPDIF,        NULL                        },
+    [MOD__HDMIA]        = {"CMUMOD_HDMIA",      &enablebit_MODULE_HDMIA,        NULL                        },
+    [MOD__I2SRX]        = {"CMUMOD_I2SRX",      &enablebit_MODULE_I2SRX,        NULL                        },
+    [MOD__I2STX]        = {"CMUMOD_I2STX",      &enablebit_MODULE_I2STX,        NULL                        },
+    [MOD__GPIO]         = {"CMUMOD_GPIO",       &enablebit_MODULE_GPIO,         &resetbit_MODULE_GPIO       },
+    [MOD__KEY]          = {"CMUMOD_KEY",        &enablebit_MODULE_KEY,          &resetbit_MODULE_KEY        },
+    [MOD__LENS]         = {"CMUMOD_LENS",       &enablebit_MODULE_LENS,         &resetbit_MODULE_LENS       },
+    [MOD__BISP]         = {"CMUMOD_BISP",       &enablebit_MODULE_BISP,         &resetbit_MODULE_BISP       },
+    [MOD__CSI]          = {"CMUMOD_CSI",        &enablebit_MODULE_CSI,          &resetbit_MODULE_CSI        },
+    [MOD__DSI]          = {"CMUMOD_DSI",        &enablebit_MODULE_DSI,          &resetbit_MODULE_DSI        },
+    [MOD__LVDS]         = {"CMUMOD_LVDS",       &enablebit_MODULE_LVDS,         NULL                        },
+    [MOD__LCD1]         = {"CMUMOD_LCD1",       &enablebit_MODULE_LCD1,         NULL                        },
+    [MOD__LCD0]         = {"CMUMOD_LCD0",       &enablebit_MODULE_LCD0,         NULL                        },
+    [MOD__DE]           = {"CMUMOD_DE",         &enablebit_MODULE_DE,           &resetbit_MODULE_DE         },
+    [MOD__SD2]          = {"CMUMOD_SD2",        &enablebit_MODULE_SD2,          &resetbit_MODULE_SD2        },
+    [MOD__SD1]          = {"CMUMOD_SD1",        &enablebit_MODULE_SD1,          &resetbit_MODULE_SD1        },
+    [MOD__SD0]          = {"CMUMOD_SD0",        &enablebit_MODULE_SD0,          &resetbit_MODULE_SD0        },
+    [MOD__NANDC]        = {"CMUMOD_NANDC",      &enablebit_MODULE_NANDC,        &resetbit_MODULE_NANDC      },
+    [MOD__DDRCH0]       = {"CMUMOD_DDRCH0",     &enablebit_MODULE_DDRCH0,       NULL                        },
+    [MOD__NOR]          = {"CMUMOD_NOR",        &enablebit_MODULE_NOR,          NULL                        },
+    [MOD__DMAC]         = {"CMUMOD_DMAC",       &enablebit_MODULE_DMAC,         &resetbit_MODULE_DMAC       },
+    [MOD__DDRCH1]       = {"CMUMOD_DDRCH1",     &enablebit_MODULE_DDRCH1,       NULL                        },
+    [MOD__I2C3]         = {"CMUMOD_I2C3",       &enablebit_MODULE_I2C3,         &resetbit_MODULE_I2C3       },
+    [MOD__I2C2]         = {"CMUMOD_I2C2",       &enablebit_MODULE_I2C2,         &resetbit_MODULE_I2C2       },
+    [MOD__TIMER]        = {"CMUMOD_TIMER",      &enablebit_MODULE_TIMER,        NULL                        },
+    [MOD__PWM5]         = {"CMUMOD_PWM5",       &enablebit_MODULE_PWM5,         NULL                        },
+    [MOD__PWM4]         = {"CMUMOD_PWM4",       &enablebit_MODULE_PWM4,         NULL                        },
+    [MOD__PWM3]         = {"CMUMOD_PWM3",       &enablebit_MODULE_PWM3,         NULL                        },
+    [MOD__PWM2]         = {"CMUMOD_PWM2",       &enablebit_MODULE_PWM2,         NULL                        },
+    [MOD__PWM1]         = {"CMUMOD_PWM1",       &enablebit_MODULE_PWM1,         NULL                        },
+    [MOD__PWM0]         = {"CMUMOD_PWM0",       &enablebit_MODULE_PWM0,         NULL                        },
+    [MOD__ETHERNET]     = {"CMUMOD_ETHERNET",   &enablebit_MODULE_ETHERNET,     &resetbit_MODULE_ETHERNET   },
+    [MOD__UART5]        = {"CMUMOD_UART5",      &enablebit_MODULE_UART5,        &resetbit_MODULE_UART5      },
+    [MOD__UART4]        = {"CMUMOD_UART4",      &enablebit_MODULE_UART4,        &resetbit_MODULE_UART4      },
+    [MOD__UART3]        = {"CMUMOD_UART3",      &enablebit_MODULE_UART3,        &resetbit_MODULE_UART3      },
+    [MOD__UART6]        = {"CMUMOD_UART6",      &enablebit_MODULE_UART6,        &resetbit_MODULE_UART6      },
+    [MOD__PCM1]         = {"CMUMOD_PCM1",       &enablebit_MODULE_PCM1,         &resetbit_MODULE_PCM1       },
+    [MOD__I2C1]         = {"CMUMOD_I2C1",       &enablebit_MODULE_I2C1,         &resetbit_MODULE_I2C1       },
+    [MOD__I2C0]         = {"CMUMOD_I2C0",       &enablebit_MODULE_I2C0,         &resetbit_MODULE_I2C0       },
+    [MOD__SPI3]         = {"CMUMOD_SPI3",       &enablebit_MODULE_SPI3,         &resetbit_MODULE_SPI3       },
+    [MOD__SPI2]         = {"CMUMOD_SPI2",       &enablebit_MODULE_SPI2,         &resetbit_MODULE_SPI2       },
+    [MOD__SPI1]         = {"CMUMOD_SPI1",       &enablebit_MODULE_SPI1,         &resetbit_MODULE_SPI1       },
+    [MOD__SPI0]         = {"CMUMOD_SPI0",       &enablebit_MODULE_SPI0,         &resetbit_MODULE_SPI0       },
+    [MOD__IRC]          = {"CMUMOD_IRC",        &enablebit_MODULE_IRC,          NULL                        },
+    [MOD__UART2]        = {"CMUMOD_UART2",      &enablebit_MODULE_UART2,        &resetbit_MODULE_UART2      },
+    [MOD__UART1]        = {"CMUMOD_UART1",      &enablebit_MODULE_UART1,        &resetbit_MODULE_UART1      },
+    [MOD__UART0]        = {"CMUMOD_UART0",      &enablebit_MODULE_UART0,        &resetbit_MODULE_UART0      },
+    [MOD__HDMI]         = {"CMUMOD_HDMI",       &enablebit_MODULE_HDMI,         &resetbit_MODULE_HDMI       },
+    [MOD__SS]           = {"CMUMOD_SS",         &enablebit_MODULE_SS,           NULL                        },
+    [MOD__TV24M]        = {"CMUMOD_TV24M",      &enablebit_MODULE_TV24M,        NULL                        },
+    [MOD__CVBS_CLK108M]        = {"CMUMOD_CVBS_CLK108M",      &enablebit_MODULE_CVBS_CLK108M,        NULL                        },
+    [MOD__TVOUT]        = {"CMUMOD_TVOUT",      &enablebit_MODULE_TVOUT,                           &resetbit_MODULE_TVOUT                        },
+
+    [MOD__PERIPHRESET]  = {"CMUMOD_PERIPHRESET",NULL,                           &resetbit_MODULE_PERIPHRESET},
+    [MOD__NIC301]       = {"CMUMOD_NIC301",     NULL,                           &resetbit_MODULE_NIC301     },
+    [MOD__AUDIO]        = {"CMUMOD_AUDIO",      NULL,                           &resetbit_MODULE_AUDIO      },
+    [MOD__LCD]          = {"CMUMOD_LCD",        NULL,                           &resetbit_MODULE_LCD        },
+    [MOD__DDR]          = {"CMUMOD_DDR",        NULL,                           &resetbit_MODULE_DDR        },
+    [MOD__NORIF]        = {"CMUMOD_NORIF",      NULL,                           &resetbit_MODULE_NORIF      },
+    [MOD__DBG3RESET]    = {"CMUMOD_DBG3RESET",  NULL,                           &resetbit_MODULE_DBG3RESET  },
+    [MOD__DBG2RESET]    = {"CMUMOD_DBG2RESET",  NULL,                           &resetbit_MODULE_DBG2RESET  },
+    [MOD__DBG1RESET]    = {"CMUMOD_DBG1RESET",  NULL,                           &resetbit_MODULE_DBG1RESET  },
+    [MOD__DBG0RESET]    = {"CMUMOD_DBG0RESET",  NULL,                           &resetbit_MODULE_DBG0RESET  },
+    [MOD__WD3RESET]     = {"CMUMOD_WD3RESET",   NULL,                           &resetbit_MODULE_WD3RESET   },
+    [MOD__WD2RESET]     = {"CMUMOD_WD2RESET",   NULL,                           &resetbit_MODULE_WD2RESET   },
+    [MOD__WD1RESET]     = {"CMUMOD_WD1RESET",   NULL,                           &resetbit_MODULE_WD1RESET   },
+    [MOD__WD0RESET]     = {"CMUMOD_WD0RESET",   NULL,                           &resetbit_MODULE_WD0RESET   },
+    [MOD__CHIPID]       = {"CMUMOD_CHIPID",     NULL,                           &resetbit_MODULE_CHIPID     },
+    [MOD__USB3]         = {"CMUMOD_USB3",       NULL,                           &resetbit_MODULE_USB3       },
+    [MOD__USB2_0]       = {"CMUMOD_USB2_0",     NULL,                           &resetbit_MODULE_USB2_0     },
+    [MOD__USB2_1]       = {"CMUMOD_USB2_1",     NULL,                           &resetbit_MODULE_USB2_1     },
+};
+
+static struct owl_refertab T_lcd    = {{1, 7, -1}, 0};
+static struct owl_refertab T_dsipro = {{3 << 16 | 4, 4, -1}, 1};
+static struct owl_refertab T_sdx2   = {{1, 128, -1}, 0};
+static struct owl_refertab T_uart   = {{624, -1}, 0};
+static struct owl_refertab T_rmii   = {{4, 10, -1}, 0};
+static struct owl_refertab T_de    = {{1, 2<<16 | 3, 2, 2<<16 | 5, 3, 4, 6, 8, 12}, 1};
+static struct owl_refertab T_vde    = {{1, 2<<16 | 3, 2, 2<<16 | 5, 3, 4, 6, 8, -1}, 1};
+static struct owl_refertab T_vce    = {{1, 2<<16 | 3, 2, 2<<16 | 5, 3, 4, 6, 8, -1}, 1};
+static struct owl_refertab T_gpu    = {{1, 2<<16 | 3, 2, 2<<16 | 5, 3, 4, 6, 8, -1}, 1};
+
+static struct owl_seqtab S_default  = {9, {1, 2, 3, 4, 6, 8, 12, 16, 24} };
+
+static struct owl_compdiv C_dsipro = {
+    .sections[0] = {DIV_T_NATURE, 0, 1, {0} },
+    .sections[1] = {
+        .type = DIV_T_TABLE,
+        .range_from = 2,
+        .range_to = 3,
+        .ext = { .tab = &T_dsipro, },
+    },
+};
+
+
+static struct owl_compdiv C_uart = {
+    .sections[0] = {DIV_T_NATURE, 0, 312, {0} },
+    .sections[1] = {
+        .type = DIV_T_TABLE,
+        .range_from = 313,
+        .range_to = 313,
+        .ext = { .tab = &T_uart, },
+    },
+};
+
+
+static struct owl_div divider_SPDIF_CLK = {
+    .type = DIV_T_SEQ,
+    .range_from = 0,
+    .range_to = 8,
+    .ext = {.seq = &S_default,},
+    .reg = &divbit_SPDIF_CLK,
+};
+static struct owl_div divider_HDMIA_CLK = {
+    .type = DIV_T_SEQ,
+    .range_from = 0,
+    .range_to = 8,
+    .ext = {.seq = &S_default,},
+    .reg = &divbit_HDMIA_CLK,
+};
+static struct owl_div divider_I2SRX_CLK = {
+    .type = DIV_T_SEQ,
+    .range_from = 0,
+    .range_to = 8,
+    .ext = {.seq = &S_default,},
+    .reg = &divbit_I2SRX_CLK,
+};
+static struct owl_div divider_I2STX_CLK = {
+    .type = DIV_T_SEQ,
+    .range_from = 0,
+    .range_to = 8,
+    .ext = {.seq = &S_default,},
+    .reg = &divbit_I2STX_CLK,
+};
+static struct owl_div divider_APBDBG_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 1,
+    .range_to = 7,
+    .reg = &divbit_APBDBG_CLK,
+};
+static struct owl_div divider_ACP_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 1,
+    .range_to = 3,
+    .reg = &divbit_ACP_CLK,
+};
+static struct owl_div divider_PERIPH_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 1,
+    .range_to = 7,
+    .reg = &divbit_PERIPH_CLK,
+};
+static struct owl_div divider_NIC_DIV_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 1, /* reserve NIC_DIV_CLK divisor 1 */
+    .range_to = 3,
+    .reg = &divbit_NIC_DIV_CLK,
+};
+static struct owl_div divider_NIC_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 3,
+    .reg = &divbit_NIC_CLK,
+};
+static struct owl_div divider_AHBPREDIV_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 3,
+    .reg = &divbit_AHBPREDIV_CLK,
+};
+static struct owl_div divider_H_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 1,  /* reserve H_CLK divsor 1 */
+    .range_to = 3,
+    .reg = &divbit_H_CLK,
+};
+static struct owl_div divider_APB30_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 3,
+    .reg = &divbit_APB30_CLK,
+};
+static struct owl_div divider_APB20_CLK = {
+    .type = DIV_T_SEQ_D2,
+    .range_from = 0,
+    .range_to = 5,
+    .ext = {.seq = &S_default,},
+    .reg = &divbit_APB20_CLK,
+};
+static struct owl_div divider_SENSOR_CLKOUT0 = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 11,
+    .reg = &divbit_SENSOR_CLKOUT0,
+};
+static struct owl_div divider_SENSOR_CLKOUT1 = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 11,
+    .reg = &divbit_SENSOR_CLKOUT1,
+};
+static struct owl_div divider_LCD_CLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 1,
+    .ext = {.tab = &T_lcd,},
+    .reg = &divbit_LCD_CLK,
+};
+static struct owl_div divider_LCD1_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 11,
+    .reg = &divbit_LCD1_CLK,
+};
+static struct owl_div divider_LCD0_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 11,
+    .reg = &divbit_LCD0_CLK,
+};
+static struct owl_div divider_DSI_HCLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 3,
+    .reg = &divbit_DSI_HCLK,
+};
+static struct owl_div divider_PRO_CLK = {
+    .type = DIV_T_COMP,
+    .range_from = 0,
+    .range_to = 3,
+    .ext = {.comp = &C_dsipro,},
+    .reg = &divbit_PRO_CLK,
+};
+static struct owl_div divider_CSI_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 11,
+    .reg = &divbit_CSI_CLK,
+};
+static struct owl_div divider_DE1_CLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 8,
+    .ext = {.tab = &T_de,},
+    .reg = &divbit_DE1_CLK,
+};
+static struct owl_div divider_DE2_CLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 8,
+    .ext = {.tab = &T_de,},
+    .reg = &divbit_DE2_CLK,
+};
+static struct owl_div divider_BISP_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 11,
+    .reg = &divbit_BISP_CLK,
+};
+static struct owl_div divider_VDE_CLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 7,
+    .ext = {.tab = &T_vde,},
+    .reg = &divbit_VDE_CLK,
+};
+static struct owl_div divider_VCE_CLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 7,
+    .ext = {.tab = &T_vce,},
+    .reg = &divbit_VCE_CLK,
+};
+static struct owl_div divider_NANDC_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 7,
+    .reg = &divbit_NANDC_CLK,
+};
+static struct owl_div divider_ECC_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 7,
+    .reg = &divbit_ECC_CLK,
+};
+static struct owl_div divider_PRESD0_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 24,
+    .reg = &divbit_PRESD0_CLK,
+};
+static struct owl_div divider_PRESD1_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 24,
+    .reg = &divbit_PRESD1_CLK,
+};
+static struct owl_div divider_PRESD2_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 24,
+    .reg = &divbit_PRESD2_CLK,
+};
+static struct owl_div divider_SD0_CLK_2X = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 1,
+    .ext = {.tab = &T_sdx2,},
+    .reg = &divbit_SD0_CLK_2X,
+};
+static struct owl_div divider_SD1_CLK_2X = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 1,
+    .ext = {.tab = &T_sdx2,},
+    .reg = &divbit_SD1_CLK_2X,
+};
+static struct owl_div divider_SD2_CLK_2X = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 1,
+    .ext = {.tab = &T_sdx2,},
+    .reg = &divbit_SD2_CLK_2X,
+};
+static struct owl_div divider_UART0_CLK = {
+    .type = DIV_T_COMP,
+    .range_from = 0,
+    .range_to = 313,
+    .ext = {.comp = &C_uart,},
+    .reg = &divbit_UART0_CLK,
+};
+static struct owl_div divider_UART1_CLK = {
+    .type = DIV_T_COMP,
+    .range_from = 0,
+    .range_to = 313,
+    .ext = {.comp = &C_uart,},
+    .reg = &divbit_UART1_CLK,
+};
+static struct owl_div divider_UART2_CLK = {
+    .type = DIV_T_COMP,
+    .range_from = 0,
+    .range_to = 313,
+    .ext = {.comp = &C_uart,},
+    .reg = &divbit_UART2_CLK,
+};
+static struct owl_div divider_UART3_CLK = {
+    .type = DIV_T_COMP,
+    .range_from = 0,
+    .range_to = 313,
+    .ext = {.comp = &C_uart,},
+    .reg = &divbit_UART3_CLK,
+};
+static struct owl_div divider_UART4_CLK = {
+    .type = DIV_T_COMP,
+    .range_from = 0,
+    .range_to = 313,
+    .ext = {.comp = &C_uart,},
+    .reg = &divbit_UART4_CLK,
+};
+static struct owl_div divider_UART5_CLK = {
+    .type = DIV_T_COMP,
+    .range_from = 0,
+    .range_to = 313,
+    .ext = {.comp = &C_uart,},
+    .reg = &divbit_UART5_CLK,
+};
+static struct owl_div divider_UART6_CLK = {
+    .type = DIV_T_COMP,
+    .range_from = 0,
+    .range_to = 313,
+    .ext = {.comp = &C_uart,},
+    .reg = &divbit_UART6_CLK,
+};
+static struct owl_div divider_PWM0_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 1023,
+    .reg = &divbit_PWM0_CLK,
+};
+static struct owl_div divider_PWM1_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 1023,
+    .reg = &divbit_PWM1_CLK,
+};
+static struct owl_div divider_PWM2_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 1023,
+    .reg = &divbit_PWM2_CLK,
+};
+static struct owl_div divider_PWM3_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 1023,
+    .reg = &divbit_PWM3_CLK,
+};
+static struct owl_div divider_PWM4_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 1023,
+    .reg = &divbit_PWM4_CLK,
+};
+static struct owl_div divider_PWM5_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 1023,
+    .reg = &divbit_PWM5_CLK,
+};
+static struct owl_div divider_RMII_REF_CLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 1,
+    .ext = {.tab = &T_rmii,},
+    .reg = &divbit_RMII_REF_CLK,
+};
+static struct owl_div divider_LENS_CLK = {
+    .type = DIV_T_EXP_D2,
+    .range_from = 0,
+    .range_to = 7,
+    .reg = &divbit_LENS_CLK,
+};
+static struct owl_div divider_GPU3D_SYSCLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 7,
+    .ext = {.tab = &T_gpu,},
+    .reg = &divbit_GPU3D_SYSCLK,
+};
+static struct owl_div divider_GPU3D_HYDCLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 7,
+    .ext = {.tab = &T_gpu,},
+    .reg = &divbit_GPU3D_HYDCLK,
+};
+static struct owl_div divider_GPU3D_NIC_MEMCLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 7,
+    .ext = {.tab = &T_gpu,},
+    .reg = &divbit_GPU3D_NIC_MEMCLK,
+};
+static struct owl_div divider_GPU3D_CORECLK = {
+    .type = DIV_T_TABLE,
+    .range_from = 0,
+    .range_to = 7,
+    .ext = {.tab = &T_gpu,},
+    .reg = &divbit_GPU3D_CORECLK,
+};
+static struct owl_div divider_SS_CLK = {
+    .type = DIV_T_NATURE,
+    .range_from = 0,
+    .range_to = 1023,
+    .reg = &divbit_SS_CLK,
+};
+
+
+/*
+ * parent names init data for common clocks
+ */
+static const char *parent_names_COREPLL[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_DEVPLL[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_DDRPLL[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_NANDPLL[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_DISPLAYPLL[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_AUDIOPLL[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_TVOUTPLL[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_ETHERNETPLL[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_CVBSPLL[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_DEV_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__DEVPLL].name,
+};
+static const char *parent_names_DDR_CLK_0[] = {
+	clocks[CLOCK__DDRPLL].name,
+};
+static const char *parent_names_DDR_CLK_90[] = {
+	clocks[CLOCK__DDRPLL].name,
+};
+static const char *parent_names_DDR_CLK_180[] = {
+	clocks[CLOCK__DDRPLL].name,
+};
+static const char *parent_names_DDR_CLK_270[] = {
+	clocks[CLOCK__DDRPLL].name,
+};
+static const char *parent_names_DDR_CLK_CH0[] = {
+	clocks[CLOCK__DDR_CLK_0].name,
+};
+static const char *parent_names_DDR_CLK_CH1[] = {
+	clocks[CLOCK__DDR_CLK_0].name,
+	clocks[CLOCK__DDR_CLK_90].name,
+	clocks[CLOCK__DDR_CLK_180].name,
+	clocks[CLOCK__DDR_CLK_270].name,
+};
+static const char *parent_names_DDR_CLK[] = {
+	clocks[CLOCK__DDR_CLK_0].name,
+};
+static const char *parent_names_SPDIF_CLK[] = {
+	clocks[CLOCK__AUDIOPLL].name,
+};
+static const char *parent_names_HDMIA_CLK[] = {
+	clocks[CLOCK__AUDIOPLL].name,
+};
+static const char *parent_names_I2SRX_CLK[] = {
+	clocks[CLOCK__AUDIOPLL].name,
+};
+static const char *parent_names_I2STX_CLK[] = {
+	clocks[CLOCK__AUDIOPLL].name,
+};
+static const char *parent_names_PCM0_CLK[] = {
+	clocks[CLOCK__AUDIOPLL].name,
+};
+static const char *parent_names_PCM1_CLK[] = {
+	clocks[CLOCK__AUDIOPLL].name,
+};
+static const char *parent_names_CLK_PIXEL[] = {
+	clocks[CLOCK__TVOUTPLL].name,
+};
+static const char *parent_names_CLK_TMDS[] = {
+	clocks[CLOCK__TVOUTPLL].name,
+};
+static const char *parent_names_CLK_TMDS_PHY_P[] = {
+	clocks[CLOCK__CLK_TMDS].name,
+};
+static const char *parent_names_L2_NIC_CLK[] = {
+	clocks[CLOCK__CORE_CLK].name,
+};
+static const char *parent_names_APBDBG_CLK[] = {
+	clocks[CLOCK__CPU_CLK].name,
+};
+static const char *parent_names_L2_CLK[] = {
+	clocks[CLOCK__CPU_CLK].name,
+};
+static const char *parent_names_ACP_CLK[] = {
+	clocks[CLOCK__CPU_CLK].name,
+};
+static const char *parent_names_PERIPH_CLK[] = {
+	clocks[CLOCK__CPU_CLK].name,
+};
+static const char *parent_names_NIC_DIV_CLK[] = {
+	clocks[CLOCK__NIC_CLK].name,
+};
+static const char *parent_names_NIC_CLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DDRPLL].name,
+};
+static const char *parent_names_AHBPREDIV_CLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DDRPLL].name,
+};
+
+static const char *parent_names_H_CLK[] = {
+	clocks[CLOCK__AHBPREDIV_CLK].name,
+};
+static const char *parent_names_APB30_CLK[] = {
+	clocks[CLOCK__NIC_CLK].name,
+};
+static const char *parent_names_APB20_CLK[] = {
+	clocks[CLOCK__NIC_CLK].name,
+};
+static const char *parent_names_AHB_CLK[] = {
+	clocks[CLOCK__H_CLK].name,
+};
+static const char *parent_names_CORE_CLK[] = {
+	clocks[CLOCK__IC_32K].name,
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__COREPLL].name,
+	clocks[CLOCK__VCE_CLK].name,
+};
+static const char *parent_names_CPU_CLK[] = {
+	clocks[CLOCK__CORE_CLK].name,
+};
+static const char *parent_names_SENSOR_CLKOUT0[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__ISPBP_CLK].name,
+};
+static const char *parent_names_SENSOR_CLKOUT1[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__ISPBP_CLK].name,
+};
+static const char *parent_names_LCD_CLK[] = {
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__DEV_CLK].name,
+};
+static const char *parent_names_LVDS_CLK[] = {
+	clocks[CLOCK__DISPLAYPLL].name,
+};
+static const char *parent_names_CKA_LCD_H[] = {
+	clocks[CLOCK__LVDS_CLK].name,
+};
+static const char *parent_names_LCD1_CLK[] = {
+	clocks[CLOCK__LCD_CLK].name,
+};
+static const char *parent_names_LCD0_CLK[] = {
+	clocks[CLOCK__LCD_CLK].name,
+};
+static const char *parent_names_DSI_HCLK[] = {
+	clocks[CLOCK__DISPLAYPLL].name,
+};
+static const char *parent_names_DSI_HCLK90[] = {
+	clocks[CLOCK__DSI_HCLK].name,
+};
+static const char *parent_names_PRO_CLK[] = {
+	clocks[CLOCK__DSI_HCLK90].name,
+};
+static const char *parent_names_PHY_CLK[] = {
+	clocks[CLOCK__DSI_HCLK90].name,
+};
+static const char *parent_names_CSI_CLK[] = {
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__DEV_CLK].name,
+};
+static const char *parent_names_DE1_CLK[] = {
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__DEV_CLK].name,
+};
+static const char *parent_names_DE2_CLK[] = {
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__DEV_CLK].name,
+};
+static const char *parent_names_BISP_CLK[] = {
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__DEV_CLK].name,
+};
+static const char *parent_names_ISPBP_CLK[] = {
+	clocks[CLOCK__BISP_CLK].name,
+};
+static const char *parent_names_IMG5_CLK[] = {
+	clocks[CLOCK__LCD1_CLK].name,
+	clocks[CLOCK__LCD0_CLK].name,
+};
+static const char *parent_names_VDE_CLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DDRPLL].name,
+};
+static const char *parent_names_VCE_CLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DDRPLL].name,
+};
+static const char *parent_names_NANDC_CLK[] = {
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DDRPLL].name,
+};
+static const char *parent_names_ECC_CLK[] = {
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DDRPLL].name,
+};
+static const char *parent_names_PRESD0_CLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__NANDPLL].name,
+};
+static const char *parent_names_PRESD1_CLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__NANDPLL].name,
+};
+static const char *parent_names_PRESD2_CLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__NANDPLL].name,
+};
+static const char *parent_names_SD0_CLK_2X[] = {
+	clocks[CLOCK__PRESD0_CLK].name,
+};
+static const char *parent_names_SD1_CLK_2X[] = {
+	clocks[CLOCK__PRESD1_CLK].name,
+};
+static const char *parent_names_SD2_CLK_2X[] = {
+	clocks[CLOCK__PRESD2_CLK].name,
+};
+static const char *parent_names_SD0_CLK[] = {
+	clocks[CLOCK__SD0_CLK_2X].name,
+};
+static const char *parent_names_SD1_CLK[] = {
+	clocks[CLOCK__SD1_CLK_2X].name,
+};
+static const char *parent_names_SD2_CLK[] = {
+	clocks[CLOCK__SD2_CLK_2X].name,
+};
+static const char *parent_names_UART0_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__DEVPLL].name,
+};
+static const char *parent_names_UART1_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__DEVPLL].name,
+};
+static const char *parent_names_UART2_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__DEVPLL].name,
+};
+static const char *parent_names_UART3_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__DEVPLL].name,
+};
+static const char *parent_names_UART4_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__DEVPLL].name,
+};
+static const char *parent_names_UART5_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__DEVPLL].name,
+};
+static const char *parent_names_UART6_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+	clocks[CLOCK__DEVPLL].name,
+};
+static const char *parent_names_PWM0_CLK[] = {
+	clocks[CLOCK__IC_32K].name,
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_PWM1_CLK[] = {
+	clocks[CLOCK__IC_32K].name,
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_PWM2_CLK[] = {
+	clocks[CLOCK__IC_32K].name,
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_PWM3_CLK[] = {
+	clocks[CLOCK__IC_32K].name,
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_PWM4_CLK[] = {
+	clocks[CLOCK__IC_32K].name,
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_PWM5_CLK[] = {
+	clocks[CLOCK__IC_32K].name,
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_RMII_REF_CLK[] = {
+	clocks[CLOCK__ETHERNETPLL].name,
+};
+static const char *parent_names_I2C0_CLK[] = {
+	clocks[CLOCK__ETHERNETPLL].name,
+};
+static const char *parent_names_I2C1_CLK[] = {
+	clocks[CLOCK__ETHERNETPLL].name,
+};
+static const char *parent_names_I2C2_CLK[] = {
+	clocks[CLOCK__ETHERNETPLL].name,
+};
+static const char *parent_names_I2C3_CLK[] = {
+	clocks[CLOCK__ETHERNETPLL].name,
+};
+static const char *parent_names_25M_CLK[] = {
+	clocks[CLOCK__ETHERNETPLL].name,
+};
+static const char *parent_names_LENS_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_HDMI24M[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_TIMER_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_SS_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_SPS_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_IRC_CLK[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_TV24M[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_CVBS_CLK108M[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_MIPI24M[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_LENS24M[] = {
+	clocks[CLOCK__HOSC].name,
+};
+static const char *parent_names_GPU3D_SYSCLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DDRPLL].name,
+	clocks[CLOCK__CVBSPLL].name,
+};
+static const char *parent_names_GPU3D_HYDCLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DDRPLL].name,
+	clocks[CLOCK__CVBSPLL].name,
+};
+static const char *parent_names_GPU3D_NIC_MEMCLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DDRPLL].name,
+	clocks[CLOCK__CVBSPLL].name,
+};
+static const char *parent_names_GPU3D_CORECLK[] = {
+	clocks[CLOCK__DEV_CLK].name,
+	clocks[CLOCK__DISPLAYPLL].name,
+	clocks[CLOCK__NANDPLL].name,
+	clocks[CLOCK__DDRPLL].name,
+	clocks[CLOCK__CVBSPLL].name,
+};
+
+static const char *parent_name_CMUMOD_DEVCLKS[] = {
+	modnode[MOD__ROOT].modname,
+};
+
+static struct clk_onecell_data clk_data;
+
+/*
+ * common clk static init.
+ */
+static struct clk *owl_clks[CLOCK__MAX + MOD__MAX_IN_CLK];
+
+/*
+ * clock imp: "real" clocks
+ */
+static struct owl_clk_foo clk_foo_clocks[CLOCK__MAX] = {
+    [CLOCK__HOSC] = {
+        .clock = CLOCK__HOSC,
+    },
+    [CLOCK__IC_32K] = {
+        .clock = CLOCK__IC_32K,
+    },
+    [CLOCK__COREPLL] = {
+        .clock = CLOCK__COREPLL,
+    },
+    [CLOCK__DEVPLL] = {
+        .clock = CLOCK__DEVPLL,
+    },
+    [CLOCK__DDRPLL] = {
+        .clock = CLOCK__DDRPLL,
+    },
+    [CLOCK__NANDPLL] = {
+        .clock = CLOCK__NANDPLL,
+    },
+    [CLOCK__DISPLAYPLL] = {
+        .clock = CLOCK__DISPLAYPLL,
+    },
+    [CLOCK__AUDIOPLL] = {
+        .clock = CLOCK__AUDIOPLL,
+    },
+    [CLOCK__TVOUTPLL] = {
+        .clock = CLOCK__TVOUTPLL,
+    },
+    [CLOCK__ETHERNETPLL] = {
+        .clock = CLOCK__ETHERNETPLL,
+    },
+    [CLOCK__CVBSPLL] = {
+        .clock = CLOCK__CVBSPLL,
+    },
+    [CLOCK__DEV_CLK] = {
+        .clock = CLOCK__DEV_CLK,
+    },
+    [CLOCK__DDR_CLK_0] = {
+        .clock = CLOCK__DDR_CLK_0,
+    },
+    [CLOCK__DDR_CLK_90] = {
+        .clock = CLOCK__DDR_CLK_90,
+    },
+    [CLOCK__DDR_CLK_180] = {
+        .clock = CLOCK__DDR_CLK_180,
+    },
+    [CLOCK__DDR_CLK_270] = {
+        .clock = CLOCK__DDR_CLK_270,
+    },
+    [CLOCK__DDR_CLK_CH0] = {
+        .clock = CLOCK__DDR_CLK_CH0,
+    },
+    [CLOCK__DDR_CLK_CH1] = {
+        .clock = CLOCK__DDR_CLK_CH1,
+    },
+    [CLOCK__DDR_CLK] = {
+        .clock = CLOCK__DDR_CLK,
+    },
+    [CLOCK__SPDIF_CLK] = {
+        .clock = CLOCK__SPDIF_CLK,
+    },
+    [CLOCK__HDMIA_CLK] = {
+        .clock = CLOCK__HDMIA_CLK,
+    },
+    [CLOCK__I2SRX_CLK] = {
+        .clock = CLOCK__I2SRX_CLK,
+    },
+    [CLOCK__I2STX_CLK] = {
+        .clock = CLOCK__I2STX_CLK,
+    },
+    [CLOCK__PCM0_CLK] = {
+        .clock = CLOCK__PCM0_CLK,
+    },
+    [CLOCK__PCM1_CLK] = {
+        .clock = CLOCK__PCM1_CLK,
+    },
+    [CLOCK__CLK_PIXEL] = {
+        .clock = CLOCK__CLK_PIXEL,
+    },
+    [CLOCK__CLK_TMDS] = {
+        .clock = CLOCK__CLK_TMDS,
+    },
+    [CLOCK__CLK_TMDS_PHY_P] = {
+        .clock = CLOCK__CLK_TMDS_PHY_P,
+    },
+    [CLOCK__L2_NIC_CLK] = {
+        .clock = CLOCK__L2_NIC_CLK,
+    },
+    [CLOCK__APBDBG_CLK] = {
+        .clock = CLOCK__APBDBG_CLK,
+    },
+    [CLOCK__L2_CLK] = {
+        .clock = CLOCK__L2_CLK,
+    },
+    [CLOCK__ACP_CLK] = {
+        .clock = CLOCK__ACP_CLK,
+    },
+    [CLOCK__PERIPH_CLK] = {
+        .clock = CLOCK__PERIPH_CLK,
+    },
+    [CLOCK__NIC_DIV_CLK] = {
+        .clock = CLOCK__NIC_DIV_CLK,
+    },
+    [CLOCK__NIC_CLK] = {
+        .clock = CLOCK__NIC_CLK,
+    },
+    [CLOCK__AHBPREDIV_CLK] = {
+        .clock = CLOCK__AHBPREDIV_CLK,
+    },
+    [CLOCK__H_CLK] = {
+        .clock = CLOCK__H_CLK,
+    },
+    [CLOCK__APB30_CLK] = {
+        .clock = CLOCK__APB30_CLK,
+    },
+    [CLOCK__APB20_CLK] = {
+        .clock = CLOCK__APB20_CLK,
+    },
+    [CLOCK__AHB_CLK] = {
+        .clock = CLOCK__AHB_CLK,
+    },
+    [CLOCK__CORE_CLK] = {
+        .clock = CLOCK__CORE_CLK,
+    },
+    [CLOCK__CPU_CLK] = {
+        .clock = CLOCK__CPU_CLK,
+    },
+    [CLOCK__SENSOR_CLKOUT0] = {
+        .clock = CLOCK__SENSOR_CLKOUT0,
+    },
+    [CLOCK__SENSOR_CLKOUT1] = {
+        .clock = CLOCK__SENSOR_CLKOUT1,
+    },
+    [CLOCK__LCD_CLK] = {
+        .clock = CLOCK__LCD_CLK,
+    },
+    [CLOCK__LVDS_CLK] = {
+        .clock = CLOCK__LVDS_CLK,
+    },
+    [CLOCK__CKA_LCD_H] = {
+        .clock = CLOCK__CKA_LCD_H,
+    },
+    [CLOCK__LCD1_CLK] = {
+        .clock = CLOCK__LCD1_CLK,
+    },
+    [CLOCK__LCD0_CLK] = {
+        .clock = CLOCK__LCD0_CLK,
+    },
+    [CLOCK__DSI_HCLK] = {
+        .clock = CLOCK__DSI_HCLK,
+    },
+    [CLOCK__DSI_HCLK90] = {
+        .clock = CLOCK__DSI_HCLK90,
+    },
+    [CLOCK__PRO_CLK] = {
+        .clock = CLOCK__PRO_CLK,
+    },
+    [CLOCK__PHY_CLK] = {
+        .clock = CLOCK__PHY_CLK,
+    },
+    [CLOCK__CSI_CLK] = {
+        .clock = CLOCK__CSI_CLK,
+    },
+    [CLOCK__DE1_CLK] = {
+        .clock = CLOCK__DE1_CLK,
+    },
+    [CLOCK__DE2_CLK] = {
+        .clock = CLOCK__DE2_CLK,
+    },
+    [CLOCK__BISP_CLK] = {
+        .clock = CLOCK__BISP_CLK,
+    },
+    [CLOCK__ISPBP_CLK] = {
+        .clock = CLOCK__ISPBP_CLK,
+    },
+    [CLOCK__IMG5_CLK] = {
+        .clock = CLOCK__IMG5_CLK,
+    },
+    [CLOCK__VDE_CLK] = {
+        .clock = CLOCK__VDE_CLK,
+    },
+    [CLOCK__VCE_CLK] = {
+        .clock = CLOCK__VCE_CLK,
+    },
+    [CLOCK__NANDC_CLK] = {
+        .clock = CLOCK__NANDC_CLK,
+    },
+    [CLOCK__ECC_CLK] = {
+        .clock = CLOCK__ECC_CLK,
+    },
+    [CLOCK__PRESD0_CLK] = {
+        .clock = CLOCK__PRESD0_CLK,
+    },
+    [CLOCK__PRESD1_CLK] = {
+        .clock = CLOCK__PRESD1_CLK,
+    },
+    [CLOCK__PRESD2_CLK] = {
+        .clock = CLOCK__PRESD2_CLK,
+    },
+    [CLOCK__SD0_CLK_2X] = {
+        .clock = CLOCK__SD0_CLK_2X,
+    },
+    [CLOCK__SD1_CLK_2X] = {
+        .clock = CLOCK__SD1_CLK_2X,
+    },
+    [CLOCK__SD2_CLK_2X] = {
+        .clock = CLOCK__SD2_CLK_2X,
+    },
+    [CLOCK__SD0_CLK] = {
+        .clock = CLOCK__SD0_CLK,
+    },
+    [CLOCK__SD1_CLK] = {
+        .clock = CLOCK__SD1_CLK,
+    },
+    [CLOCK__SD2_CLK] = {
+        .clock = CLOCK__SD2_CLK,
+    },
+    [CLOCK__UART0_CLK] = {
+        .clock = CLOCK__UART0_CLK,
+    },
+    [CLOCK__UART1_CLK] = {
+        .clock = CLOCK__UART1_CLK,
+    },
+    [CLOCK__UART2_CLK] = {
+        .clock = CLOCK__UART2_CLK,
+    },
+    [CLOCK__UART3_CLK] = {
+        .clock = CLOCK__UART3_CLK,
+    },
+    [CLOCK__UART4_CLK] = {
+        .clock = CLOCK__UART4_CLK,
+    },
+    [CLOCK__UART5_CLK] = {
+        .clock = CLOCK__UART5_CLK,
+    },
+    [CLOCK__UART6_CLK] = {
+        .clock = CLOCK__UART6_CLK,
+    },
+    [CLOCK__PWM0_CLK] = {
+        .clock = CLOCK__PWM0_CLK,
+    },
+    [CLOCK__PWM1_CLK] = {
+        .clock = CLOCK__PWM1_CLK,
+    },
+    [CLOCK__PWM2_CLK] = {
+        .clock = CLOCK__PWM2_CLK,
+    },
+    [CLOCK__PWM3_CLK] = {
+        .clock = CLOCK__PWM3_CLK,
+    },
+    [CLOCK__PWM4_CLK] = {
+        .clock = CLOCK__PWM4_CLK,
+    },
+    [CLOCK__PWM5_CLK] = {
+        .clock = CLOCK__PWM5_CLK,
+    },
+    [CLOCK__RMII_REF_CLK] = {
+        .clock = CLOCK__RMII_REF_CLK,
+    },
+    [CLOCK__I2C0_CLK] = {
+        .clock = CLOCK__I2C0_CLK,
+    },
+    [CLOCK__I2C1_CLK] = {
+        .clock = CLOCK__I2C1_CLK,
+    },
+    [CLOCK__I2C2_CLK] = {
+        .clock = CLOCK__I2C2_CLK,
+    },
+    [CLOCK__I2C3_CLK] = {
+        .clock = CLOCK__I2C3_CLK,
+    },
+    [CLOCK__25M_CLK] = {
+        .clock = CLOCK__25M_CLK,
+    },
+    [CLOCK__LENS_CLK] = {
+        .clock = CLOCK__LENS_CLK,
+    },
+    [CLOCK__HDMI24M] = {
+        .clock = CLOCK__HDMI24M,
+    },
+    [CLOCK__TIMER_CLK] = {
+        .clock = CLOCK__TIMER_CLK,
+    },
+    [CLOCK__SS_CLK] = {
+        .clock = CLOCK__SS_CLK,
+    },
+    [CLOCK__SPS_CLK] = {
+        .clock = CLOCK__SPS_CLK,
+    },
+    [CLOCK__IRC_CLK] = {
+        .clock = CLOCK__IRC_CLK,
+    },
+    [CLOCK__TV24M] = {
+        .clock = CLOCK__TV24M,
+    },
+    [CLOCK__CVBS_CLK108M] = {
+        .clock = CLOCK__CVBS_CLK108M,
+    },
+    [CLOCK__MIPI24M] = {
+        .clock = CLOCK__MIPI24M,
+    },
+    [CLOCK__LENS24M] = {
+        .clock = CLOCK__LENS24M,
+    },
+    [CLOCK__GPU3D_SYSCLK] = {
+        .clock = CLOCK__GPU3D_SYSCLK,
+    },
+    [CLOCK__GPU3D_HYDCLK] = {
+        .clock = CLOCK__GPU3D_HYDCLK,
+    },
+    [CLOCK__GPU3D_NIC_MEMCLK] = {
+        .clock = CLOCK__GPU3D_NIC_MEMCLK,
+    },
+    [CLOCK__GPU3D_CORECLK] = {
+        .clock = CLOCK__GPU3D_CORECLK,
+    },
+};
+
+/*
+ * clock imp: module level clocks, treat as a "virtual" clock
+ */
+static struct  owl_clk_foo clk_foo_modules[MOD__MAX_IN_CLK] = {
+    [MOD__ROOT] = {
+        .clock = MOD__ROOT,
+    },
+    [MOD__GPU3D] = {
+        .clock = MOD__GPU3D,
+    },
+    [MOD__SHARESRAM] = {
+        .clock = MOD__SHARESRAM,
+    },
+    [MOD__HDCP2X] = {
+        .clock = MOD__HDCP2X,
+    },
+    [MOD__VCE] = {
+        .clock = MOD__VCE,
+    },
+    [MOD__VDE] = {
+        .clock = MOD__VDE,
+    },
+    [MOD__PCM0] = {
+        .clock = MOD__PCM0,
+    },
+    [MOD__SPDIF] = {
+        .clock = MOD__SPDIF,
+    },
+    [MOD__HDMIA] = {
+        .clock = MOD__HDMIA,
+    },
+    [MOD__I2SRX] = {
+        .clock = MOD__I2SRX,
+    },
+    [MOD__I2STX] = {
+        .clock = MOD__I2STX,
+    },
+    [MOD__GPIO] = {
+        .clock = MOD__GPIO,
+    },
+    [MOD__KEY] = {
+        .clock = MOD__KEY,
+    },
+    [MOD__LENS] = {
+        .clock = MOD__LENS,
+    },
+    [MOD__BISP] = {
+        .clock = MOD__BISP,
+    },
+    [MOD__CSI] = {
+        .clock = MOD__CSI,
+    },
+    [MOD__DSI] = {
+        .clock = MOD__DSI,
+    },
+    [MOD__LVDS] = {
+        .clock = MOD__LVDS,
+    },
+    [MOD__LCD1] = {
+        .clock = MOD__LCD1,
+    },
+    [MOD__LCD0] = {
+        .clock = MOD__LCD0,
+    },
+    [MOD__DE] = {
+        .clock = MOD__DE,
+    },
+    [MOD__SD2] = {
+        .clock = MOD__SD2,
+    },
+    [MOD__SD1] = {
+        .clock = MOD__SD1,
+    },
+    [MOD__SD0] = {
+        .clock = MOD__SD0,
+    },
+    [MOD__NANDC] = {
+        .clock = MOD__NANDC,
+    },
+    [MOD__DDRCH0] = {
+        .clock = MOD__DDRCH0,
+    },
+    [MOD__NOR] = {
+        .clock = MOD__NOR,
+    },
+    [MOD__DMAC] = {
+        .clock = MOD__DMAC,
+    },
+    [MOD__DDRCH1] = {
+        .clock = MOD__DDRCH1,
+    },
+    [MOD__I2C3] = {
+        .clock = MOD__I2C3,
+    },
+    [MOD__I2C2] = {
+        .clock = MOD__I2C2,
+    },
+    [MOD__TIMER] = {
+        .clock = MOD__TIMER,
+    },
+    [MOD__PWM5] = {
+        .clock = MOD__PWM5,
+    },
+    [MOD__PWM4] = {
+        .clock = MOD__PWM4,
+    },
+    [MOD__PWM3] = {
+        .clock = MOD__PWM3,
+    },
+    [MOD__PWM2] = {
+        .clock = MOD__PWM2,
+    },
+    [MOD__PWM1] = {
+        .clock = MOD__PWM1,
+    },
+    [MOD__PWM0] = {
+        .clock = MOD__PWM0,
+    },
+    [MOD__ETHERNET] = {
+        .clock = MOD__ETHERNET,
+    },
+    [MOD__UART5] = {
+        .clock = MOD__UART5,
+    },
+    [MOD__UART4] = {
+        .clock = MOD__UART4,
+    },
+    [MOD__UART3] = {
+        .clock = MOD__UART3,
+    },
+    [MOD__UART6] = {
+        .clock = MOD__UART6,
+    },
+    [MOD__PCM1] = {
+        .clock = MOD__PCM1,
+    },
+    [MOD__I2C1] = {
+        .clock = MOD__I2C1,
+    },
+    [MOD__I2C0] = {
+        .clock = MOD__I2C0,
+    },
+    [MOD__SPI3] = {
+        .clock = MOD__SPI3,
+    },
+    [MOD__SPI2] = {
+        .clock = MOD__SPI2,
+    },
+    [MOD__SPI1] = {
+        .clock = MOD__SPI1,
+    },
+    [MOD__SPI0] = {
+        .clock = MOD__SPI0,
+    },
+    [MOD__IRC] = {
+        .clock = MOD__IRC,
+    },
+    [MOD__UART2] = {
+        .clock = MOD__UART2,
+    },
+    [MOD__UART1] = {
+        .clock = MOD__UART1,
+    },
+    [MOD__UART0] = {
+        .clock = MOD__UART0,
+    },
+    [MOD__HDMI] = {
+        .clock = MOD__HDMI,
+    },
+    [MOD__SS] = {
+        .clock = MOD__SS,
+    },
+    [MOD__TV24M] = {
+        .clock = MOD__TV24M,
+    },
+    [MOD__CVBS_CLK108M] = {
+        .clock = MOD__CVBS_CLK108M,
+    },
+    [MOD__TVOUT] = {
+        .clock = MOD__TVOUT,
+    },
+};
+
+static int hoscops_enable(struct clk_hw *hw)
+{
+	write_clkreg_val(&enablebit_HOSC, 1);
+	return 0;
+}
+
+static void hoscops_disable(struct clk_hw *hw)
+{
+	write_clkreg_val(&enablebit_HOSC, 1);
+}
+
+static int  hoscops_is_enabled(struct clk_hw *hw)
+{
+	int ret;
+	ret = read_clkreg_val(&enablebit_HOSC);
+	return ret;
+}
+
+#define owl_to_clk_fixed_rate(_hw) container_of(_hw, struct owl_clk_info, hw)
+
+static unsigned long owl_clk_fixed_rate_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	return owl_to_clk_fixed_rate(hw)->fixed_rate;
+}
+
+static unsigned long owl_clk_fixed_rate_recalc_accuracy(struct clk_hw *hw,
+		unsigned long parent_accuracy)
+{
+	return owl_to_clk_fixed_rate(hw)->fixed_accuracy;
+}
+
+static struct clk_ops clk_ops_gate_hosc = {
+	.enable = hoscops_enable,
+	.disable = hoscops_disable,
+	.is_enabled = hoscops_is_enabled,
+	.recalc_rate = owl_clk_fixed_rate_recalc_rate,
+	.recalc_accuracy = owl_clk_fixed_rate_recalc_accuracy,
+};
+
+static struct clk_ops clk_ops_gate_ic32k = {
+	.recalc_rate = owl_clk_fixed_rate_recalc_rate,
+	.recalc_accuracy = owl_clk_fixed_rate_recalc_accuracy,
+};
+
+struct clk *owl_clk_register_fixed_rate_with_accuracy(struct device *dev,
+		const char *name, const char *parent_name, unsigned long flags, struct clk_ops *clk_ops,
+		unsigned long fixed_rate, unsigned long fixed_accuracy, u32 clk_id)
+{
+	struct owl_clk_info *info;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	/* allocate fixed-rate clock */
+	info = kzalloc(sizeof(struct owl_clk_info), GFP_KERNEL);
+	if (!info) {
+		pr_err("%s: could not allocate fixed clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = name;
+	init.ops = clk_ops;
+	init.flags = flags | CLK_IS_BASIC;
+	init.parent_names = (parent_name ? &parent_name: NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	/* struct clk_fixed_rate assignments */
+	info->fixed_rate = fixed_rate;
+	info->fixed_accuracy = fixed_accuracy;
+	info->hw.init = &init;
+	info->clock_id = clk_id;
+
+	/* register the clock */
+	clk = clk_register(dev, &info->hw);
+	if (IS_ERR(clk))
+		kfree(info);
+
+	return clk;
+}
+
+
+static struct clk *owl_clk_register_gate(struct device *dev, const char *name,
+		const char *parent_name, unsigned long flags, struct clk_ops *clk_ops,
+		void __iomem *reg, u8 bit_idx,
+		u8 clk_gate_flags, spinlock_t *lock, u32 clk_id)
+{
+	struct owl_clk_info *info;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	if (clk_gate_flags & CLK_GATE_HIWORD_MASK) {
+		if (bit_idx > 15) {
+			pr_err("gate bit exceeds LOWORD field\n");
+			return ERR_PTR(-EINVAL);
+		}
+	}
+
+	/* allocate the gate */
+	info = kzalloc(sizeof(struct owl_clk_info), GFP_KERNEL);
+	if (!info) {
+		pr_err("%s: could not allocate info clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = name;
+	init.ops = clk_ops;
+	init.flags = flags | CLK_IS_BASIC;
+	init.parent_names = (parent_name ? &parent_name: NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	/* struct clk_gate assignments */
+	info->reg = reg;
+	info->bit_idx = bit_idx;
+	info->flags = clk_gate_flags;
+	info->lock = lock;
+	info->hw.init = &init;
+	info->clock_id = clk_id;
+
+	clk = clk_register(dev, &info->hw);
+
+	if (IS_ERR(clk))
+		kfree(info);
+
+	return clk;
+}
+
+static struct clk *owl_clk_register_mux_table(struct device *dev, const char *name,
+		const char **parent_names, u8 num_parents, unsigned long flags, struct clk_ops *clk_ops,
+		void __iomem *reg, u8 shift, u32 mask,
+		u8 clk_mux_flags, u32 *table, spinlock_t *lock, u32 clk_id)
+{
+	struct owl_clk_info *info;
+	struct clk *clk;
+	struct clk_init_data init;
+	u8 width = 0;
+
+	if (clk_mux_flags & CLK_MUX_HIWORD_MASK) {
+		width = fls(mask) - ffs(mask) + 1;
+		if (width + shift > 16) {
+			pr_err("mux value exceeds LOWORD field\n");
+			return ERR_PTR(-EINVAL);
+		}
+	}
+
+	/* allocate the mux */
+	info = kzalloc(sizeof(struct owl_clk_info), GFP_KERNEL);
+	if (!info) {
+		pr_err("%s: could not allocate info clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = name;
+	if (clk_mux_flags & CLK_MUX_READ_ONLY)
+		init.ops = clk_ops;
+	else
+		init.ops = clk_ops;
+	init.flags = flags | CLK_IS_BASIC;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+
+	/* struct owl_clk_info assignments */
+	info->reg = reg;
+	info->shift = shift;
+	info->mask = mask;
+	info->flags = clk_mux_flags;
+	info->lock = lock;
+	info->table = table;
+	info->hw.init = &init;
+	info->clock_id = clk_id;
+
+	clk = clk_register(dev, &info->hw);
+
+	if (IS_ERR(clk))
+		kfree(info);
+
+	return clk;
+}
+
+static struct clk_lookup lookup_table[CLOCK__MAX + MOD__MAX_IN_CLK] = {
+    [CLOCK__HOSC] = {
+        .con_id = clocks[CLOCK__HOSC].name,
+    },
+    [CLOCK__IC_32K] = {
+        .con_id = clocks[CLOCK__IC_32K].name,
+    },
+    [CLOCK__COREPLL] = {
+        .con_id = clocks[CLOCK__COREPLL].name,
+    },
+    [CLOCK__DEVPLL] = {
+        .con_id = clocks[CLOCK__DEVPLL].name,
+    },
+    [CLOCK__DDRPLL] = {
+        .con_id = clocks[CLOCK__DDRPLL].name,
+    },
+    [CLOCK__NANDPLL] = {
+        .con_id = NULL, /* hide nandpll to ease debug work */
+    },
+    [CLOCK__DISPLAYPLL] = {
+        .con_id = clocks[CLOCK__DISPLAYPLL].name,
+    },
+    [CLOCK__AUDIOPLL] = {
+        .con_id = clocks[CLOCK__AUDIOPLL].name,
+    },
+    [CLOCK__TVOUTPLL] = {
+        .con_id = clocks[CLOCK__TVOUTPLL].name,
+    },
+    [CLOCK__ETHERNETPLL] = {
+        .con_id = clocks[CLOCK__ETHERNETPLL].name,
+    },
+    [CLOCK__CVBSPLL] = {
+        .con_id = clocks[CLOCK__CVBSPLL].name,
+    },
+    [CLOCK__DEV_CLK] = {
+        .con_id = clocks[CLOCK__DEV_CLK].name,
+    },
+    [CLOCK__DDR_CLK_0] = {
+        .con_id = clocks[CLOCK__DDR_CLK_0].name,
+    },
+    [CLOCK__DDR_CLK_90] = {
+        .con_id = clocks[CLOCK__DDR_CLK_90].name,
+    },
+    [CLOCK__DDR_CLK_180] = {
+        .con_id = clocks[CLOCK__DDR_CLK_180].name,
+    },
+    [CLOCK__DDR_CLK_270] = {
+        .con_id = clocks[CLOCK__DDR_CLK_270].name,
+    },
+    [CLOCK__DDR_CLK_CH0] = {
+        .con_id = clocks[CLOCK__DDR_CLK_CH0].name,
+    },
+    [CLOCK__DDR_CLK_CH1] = {
+        .con_id = clocks[CLOCK__DDR_CLK_CH1].name,
+    },
+    [CLOCK__DDR_CLK] = {
+        .con_id = clocks[CLOCK__DDR_CLK].name,
+    },
+    [CLOCK__SPDIF_CLK] = {
+        .con_id = clocks[CLOCK__SPDIF_CLK].name,
+    },
+    [CLOCK__HDMIA_CLK] = {
+        .con_id = clocks[CLOCK__HDMIA_CLK].name,
+    },
+    [CLOCK__I2SRX_CLK] = {
+        .con_id = clocks[CLOCK__I2SRX_CLK].name,
+    },
+    [CLOCK__I2STX_CLK] = {
+        .con_id = clocks[CLOCK__I2STX_CLK].name,
+    },
+    [CLOCK__PCM0_CLK] = {
+        .con_id = clocks[CLOCK__PCM0_CLK].name,
+    },
+    [CLOCK__PCM1_CLK] = {
+        .con_id = clocks[CLOCK__PCM1_CLK].name,
+    },
+    [CLOCK__CLK_PIXEL] = {
+        .con_id = clocks[CLOCK__CLK_PIXEL].name,
+    },
+    [CLOCK__CLK_TMDS] = {
+        .con_id = clocks[CLOCK__CLK_TMDS].name,
+    },
+    [CLOCK__CLK_TMDS_PHY_P] = {
+        .con_id = clocks[CLOCK__CLK_TMDS_PHY_P].name,
+    },
+    [CLOCK__L2_NIC_CLK] = {
+        .con_id = clocks[CLOCK__L2_NIC_CLK].name,
+    },
+    [CLOCK__APBDBG_CLK] = {
+        .con_id = clocks[CLOCK__APBDBG_CLK].name,
+    },
+    [CLOCK__L2_CLK] = {
+        .con_id = clocks[CLOCK__L2_CLK].name,
+    },
+    [CLOCK__ACP_CLK] = {
+        .con_id = clocks[CLOCK__ACP_CLK].name,
+    },
+    [CLOCK__PERIPH_CLK] = {
+        .con_id = clocks[CLOCK__PERIPH_CLK].name,
+    },
+    [CLOCK__NIC_DIV_CLK] = {
+        .con_id = clocks[CLOCK__NIC_DIV_CLK].name,
+    },
+    [CLOCK__NIC_CLK] = {
+        .con_id = clocks[CLOCK__NIC_CLK].name,
+    },
+    [CLOCK__AHBPREDIV_CLK] = {
+        .con_id = clocks[CLOCK__AHBPREDIV_CLK].name,
+    },
+    [CLOCK__H_CLK] = {
+        .con_id = clocks[CLOCK__H_CLK].name,
+    },
+    [CLOCK__APB30_CLK] = {
+        .con_id = clocks[CLOCK__APB30_CLK].name,
+    },
+    [CLOCK__APB20_CLK] = {
+        .con_id = clocks[CLOCK__APB20_CLK].name,
+    },
+    [CLOCK__AHB_CLK] = {
+        .con_id = clocks[CLOCK__AHB_CLK].name,
+    },
+    [CLOCK__CORE_CLK] = {
+        .con_id = clocks[CLOCK__CORE_CLK].name,
+    },
+    [CLOCK__CPU_CLK] = {
+        .con_id = clocks[CLOCK__CPU_CLK].name,
+    },
+    [CLOCK__SENSOR_CLKOUT0] = {
+        .con_id = clocks[CLOCK__SENSOR_CLKOUT0].name,
+    },
+    [CLOCK__SENSOR_CLKOUT1] = {
+        .con_id = clocks[CLOCK__SENSOR_CLKOUT1].name,
+    },
+    [CLOCK__LCD_CLK] = {
+        .con_id = clocks[CLOCK__LCD_CLK].name,
+    },
+    [CLOCK__LVDS_CLK] = {
+        .con_id = clocks[CLOCK__LVDS_CLK].name,
+    },
+    [CLOCK__CKA_LCD_H] = {
+        .con_id = clocks[CLOCK__CKA_LCD_H].name,
+    },
+    [CLOCK__LCD1_CLK] = {
+        .con_id = clocks[CLOCK__LCD1_CLK].name,
+    },
+    [CLOCK__LCD0_CLK] = {
+        .con_id = clocks[CLOCK__LCD0_CLK].name,
+    },
+    [CLOCK__DSI_HCLK] = {
+        .con_id = clocks[CLOCK__DSI_HCLK].name,
+    },
+    [CLOCK__DSI_HCLK90] = {
+        .con_id = clocks[CLOCK__DSI_HCLK90].name,
+    },
+    [CLOCK__PRO_CLK] = {
+        .con_id = clocks[CLOCK__PRO_CLK].name,
+    },
+    [CLOCK__PHY_CLK] = {
+        .con_id = clocks[CLOCK__PHY_CLK].name,
+    },
+    [CLOCK__CSI_CLK] = {
+        .con_id = clocks[CLOCK__CSI_CLK].name,
+    },
+    [CLOCK__DE1_CLK] = {
+        .con_id = clocks[CLOCK__DE1_CLK].name,
+    },
+    [CLOCK__DE2_CLK] = {
+        .con_id = clocks[CLOCK__DE2_CLK].name,
+    },
+    [CLOCK__BISP_CLK] = {
+        .con_id = clocks[CLOCK__BISP_CLK].name,
+    },
+    [CLOCK__ISPBP_CLK] = {
+        .con_id = clocks[CLOCK__ISPBP_CLK].name,
+    },
+    [CLOCK__IMG5_CLK] = {
+        .con_id = clocks[CLOCK__IMG5_CLK].name,
+    },
+    [CLOCK__VDE_CLK] = {
+        .con_id = clocks[CLOCK__VDE_CLK].name,
+    },
+    [CLOCK__VCE_CLK] = {
+        .con_id = clocks[CLOCK__VCE_CLK].name,
+    },
+    [CLOCK__NANDC_CLK] = {
+        .con_id = clocks[CLOCK__NANDC_CLK].name,
+    },
+    [CLOCK__ECC_CLK] = {
+        .con_id = clocks[CLOCK__ECC_CLK].name,
+    },
+    [CLOCK__PRESD0_CLK] = {
+        .con_id = clocks[CLOCK__PRESD0_CLK].name,
+    },
+    [CLOCK__PRESD1_CLK] = {
+        .con_id = clocks[CLOCK__PRESD1_CLK].name,
+    },
+    [CLOCK__PRESD2_CLK] = {
+        .con_id = clocks[CLOCK__PRESD2_CLK].name,
+    },
+    [CLOCK__SD0_CLK_2X] = {
+        .con_id = clocks[CLOCK__SD0_CLK_2X].name,
+    },
+    [CLOCK__SD1_CLK_2X] = {
+        .con_id = clocks[CLOCK__SD1_CLK_2X].name,
+    },
+    [CLOCK__SD2_CLK_2X] = {
+        .con_id = clocks[CLOCK__SD2_CLK_2X].name,
+    },
+    [CLOCK__SD0_CLK] = {
+        .con_id = clocks[CLOCK__SD0_CLK].name,
+    },
+    [CLOCK__SD1_CLK] = {
+        .con_id = clocks[CLOCK__SD1_CLK].name,
+    },
+    [CLOCK__SD2_CLK] = {
+        .con_id = clocks[CLOCK__SD2_CLK].name,
+    },
+    [CLOCK__UART0_CLK] = {
+        .con_id = clocks[CLOCK__UART0_CLK].name,
+    },
+    [CLOCK__UART1_CLK] = {
+        .con_id = clocks[CLOCK__UART1_CLK].name,
+    },
+    [CLOCK__UART2_CLK] = {
+        .con_id = clocks[CLOCK__UART2_CLK].name,
+    },
+    [CLOCK__UART3_CLK] = {
+        .con_id = clocks[CLOCK__UART3_CLK].name,
+    },
+    [CLOCK__UART4_CLK] = {
+        .con_id = clocks[CLOCK__UART4_CLK].name,
+    },
+    [CLOCK__UART5_CLK] = {
+        .con_id = clocks[CLOCK__UART5_CLK].name,
+    },
+    [CLOCK__UART6_CLK] = {
+        .con_id = clocks[CLOCK__UART6_CLK].name,
+    },
+    [CLOCK__PWM0_CLK] = {
+        .con_id = clocks[CLOCK__PWM0_CLK].name,
+    },
+    [CLOCK__PWM1_CLK] = {
+        .con_id = clocks[CLOCK__PWM1_CLK].name,
+    },
+    [CLOCK__PWM2_CLK] = {
+        .con_id = clocks[CLOCK__PWM2_CLK].name,
+    },
+    [CLOCK__PWM3_CLK] = {
+        .con_id = clocks[CLOCK__PWM3_CLK].name,
+    },
+    [CLOCK__PWM4_CLK] = {
+        .con_id = clocks[CLOCK__PWM4_CLK].name,
+    },
+    [CLOCK__PWM5_CLK] = {
+        .con_id = clocks[CLOCK__PWM5_CLK].name,
+    },
+    [CLOCK__RMII_REF_CLK] = {
+        .con_id = clocks[CLOCK__RMII_REF_CLK].name,
+    },
+    [CLOCK__I2C0_CLK] = {
+        .con_id = clocks[CLOCK__I2C0_CLK].name,
+    },
+    [CLOCK__I2C1_CLK] = {
+        .con_id = clocks[CLOCK__I2C1_CLK].name,
+    },
+    [CLOCK__I2C2_CLK] = {
+        .con_id = clocks[CLOCK__I2C2_CLK].name,
+    },
+    [CLOCK__I2C3_CLK] = {
+        .con_id = clocks[CLOCK__I2C3_CLK].name,
+    },
+    [CLOCK__25M_CLK] = {
+        .con_id = clocks[CLOCK__25M_CLK].name,
+    },
+    [CLOCK__LENS_CLK] = {
+        .con_id = clocks[CLOCK__LENS_CLK].name,
+    },
+    [CLOCK__HDMI24M] = {
+        .con_id = clocks[CLOCK__HDMI24M].name,
+    },
+    [CLOCK__TIMER_CLK] = {
+        .con_id = clocks[CLOCK__TIMER_CLK].name,
+    },
+    [CLOCK__SS_CLK] = {
+        .con_id = clocks[CLOCK__SS_CLK].name,
+    },
+    [CLOCK__SPS_CLK] = {
+        .con_id = clocks[CLOCK__SPS_CLK].name,
+    },
+    [CLOCK__IRC_CLK] = {
+        .con_id = clocks[CLOCK__IRC_CLK].name,
+    },
+    [CLOCK__TV24M] = {
+        .con_id = clocks[CLOCK__TV24M].name,
+    },
+    [CLOCK__CVBS_CLK108M] = {
+        .con_id = clocks[CLOCK__CVBS_CLK108M].name,
+    },
+    [CLOCK__MIPI24M] = {
+        .con_id = clocks[CLOCK__MIPI24M].name,
+    },
+    [CLOCK__LENS24M] = {
+        .con_id = clocks[CLOCK__LENS24M].name,
+    },
+    [CLOCK__GPU3D_SYSCLK] = {
+        .con_id = clocks[CLOCK__GPU3D_SYSCLK].name,
+    },
+    [CLOCK__GPU3D_HYDCLK] = {
+        .con_id = clocks[CLOCK__GPU3D_HYDCLK].name,
+    },
+    [CLOCK__GPU3D_NIC_MEMCLK] = {
+        .con_id = clocks[CLOCK__GPU3D_NIC_MEMCLK].name,
+    },
+    [CLOCK__GPU3D_CORECLK] = {
+        .con_id = clocks[CLOCK__GPU3D_CORECLK].name,
+    },
+    [CLOCK__MAX + MOD__ROOT] = {
+        .con_id = modnode[MOD__ROOT].modname,
+    },
+    [CLOCK__MAX + MOD__GPU3D] = {
+        .con_id = modnode[MOD__GPU3D].modname,
+    },
+    [CLOCK__MAX + MOD__SHARESRAM] = {
+        .con_id = modnode[MOD__SHARESRAM].modname,
+    },
+    [CLOCK__MAX + MOD__HDCP2X] = {
+        .con_id = modnode[MOD__HDCP2X].modname,
+    },
+    [CLOCK__MAX + MOD__VCE] = {
+        .con_id = modnode[MOD__VCE].modname,
+    },
+    [CLOCK__MAX + MOD__VDE] = {
+        .con_id = modnode[MOD__VDE].modname,
+    },
+    [CLOCK__MAX + MOD__PCM0] = {
+        .con_id = modnode[MOD__PCM0].modname,
+    },
+    [CLOCK__MAX + MOD__SPDIF] = {
+        .con_id = modnode[MOD__SPDIF].modname,
+    },
+    [CLOCK__MAX + MOD__HDMIA] = {
+        .con_id = modnode[MOD__HDMIA].modname,
+    },
+    [CLOCK__MAX + MOD__I2SRX] = {
+        .con_id = modnode[MOD__I2SRX].modname,
+    },
+    [CLOCK__MAX + MOD__I2STX] = {
+        .con_id = modnode[MOD__I2STX].modname,
+    },
+    [CLOCK__MAX + MOD__GPIO] = {
+        .con_id = modnode[MOD__GPIO].modname,
+    },
+    [CLOCK__MAX + MOD__KEY] = {
+        .con_id = modnode[MOD__KEY].modname,
+    },
+    [CLOCK__MAX + MOD__LENS] = {
+        .con_id = modnode[MOD__LENS].modname,
+    },
+    [CLOCK__MAX + MOD__BISP] = {
+        .con_id = modnode[MOD__BISP].modname,
+    },
+    [CLOCK__MAX + MOD__CSI] = {
+        .con_id = modnode[MOD__CSI].modname,
+    },
+    [CLOCK__MAX + MOD__DSI] = {
+        .con_id = modnode[MOD__DSI].modname,
+    },
+    [CLOCK__MAX + MOD__LVDS] = {
+        .con_id = modnode[MOD__LVDS].modname,
+    },
+    [CLOCK__MAX + MOD__LCD1] = {
+        .con_id = modnode[MOD__LCD1].modname,
+    },
+    [CLOCK__MAX + MOD__LCD0] = {
+        .con_id = modnode[MOD__LCD0].modname,
+    },
+    [CLOCK__MAX + MOD__DE] = {
+        .con_id = modnode[MOD__DE].modname,
+    },
+    [CLOCK__MAX + MOD__SD2] = {
+        .con_id = modnode[MOD__SD2].modname,
+    },
+    [CLOCK__MAX + MOD__SD1] = {
+        .con_id = modnode[MOD__SD1].modname,
+    },
+    [CLOCK__MAX + MOD__SD0] = {
+        .con_id = modnode[MOD__SD0].modname,
+    },
+    [CLOCK__MAX + MOD__NANDC] = {
+        .con_id = modnode[MOD__NANDC].modname,
+    },
+    [CLOCK__MAX + MOD__DDRCH0] = {
+        .con_id = modnode[MOD__DDRCH0].modname,
+    },
+    [CLOCK__MAX + MOD__NOR] = {
+        .con_id = modnode[MOD__NOR].modname,
+    },
+    [CLOCK__MAX + MOD__DMAC] = {
+        .con_id = modnode[MOD__DMAC].modname,
+    },
+    [CLOCK__MAX + MOD__DDRCH1] = {
+        .con_id = modnode[MOD__DDRCH1].modname,
+    },
+    [CLOCK__MAX + MOD__I2C3] = {
+        .con_id = modnode[MOD__I2C3].modname,
+    },
+    [CLOCK__MAX + MOD__I2C2] = {
+        .con_id = modnode[MOD__I2C2].modname,
+    },
+    [CLOCK__MAX + MOD__TIMER] = {
+        .con_id = modnode[MOD__TIMER].modname,
+    },
+    [CLOCK__MAX + MOD__PWM5] = {
+        .con_id = modnode[MOD__PWM5].modname,
+    },
+    [CLOCK__MAX + MOD__PWM4] = {
+        .con_id = modnode[MOD__PWM4].modname,
+    },
+    [CLOCK__MAX + MOD__PWM3] = {
+        .con_id = modnode[MOD__PWM3].modname,
+    },
+    [CLOCK__MAX + MOD__PWM2] = {
+        .con_id = modnode[MOD__PWM2].modname,
+    },
+    [CLOCK__MAX + MOD__PWM1] = {
+        .con_id = modnode[MOD__PWM1].modname,
+    },
+    [CLOCK__MAX + MOD__PWM0] = {
+        .con_id = modnode[MOD__PWM0].modname,
+    },
+    [CLOCK__MAX + MOD__ETHERNET] = {
+        .con_id = modnode[MOD__ETHERNET].modname,
+    },
+    [CLOCK__MAX + MOD__UART5] = {
+        .con_id = modnode[MOD__UART5].modname,
+    },
+    [CLOCK__MAX + MOD__UART4] = {
+        .con_id = modnode[MOD__UART4].modname,
+    },
+    [CLOCK__MAX + MOD__UART3] = {
+        .con_id = modnode[MOD__UART3].modname,
+    },
+    [CLOCK__MAX + MOD__UART6] = {
+        .con_id = modnode[MOD__UART6].modname,
+    },
+    [CLOCK__MAX + MOD__PCM1] = {
+        .con_id = modnode[MOD__PCM1].modname,
+    },
+    [CLOCK__MAX + MOD__I2C1] = {
+        .con_id = modnode[MOD__I2C1].modname,
+    },
+    [CLOCK__MAX + MOD__I2C0] = {
+        .con_id = modnode[MOD__I2C0].modname,
+    },
+    [CLOCK__MAX + MOD__SPI3] = {
+        .con_id = modnode[MOD__SPI3].modname,
+    },
+    [CLOCK__MAX + MOD__SPI2] = {
+        .con_id = modnode[MOD__SPI2].modname,
+    },
+    [CLOCK__MAX + MOD__SPI1] = {
+        .con_id = modnode[MOD__SPI1].modname,
+    },
+    [CLOCK__MAX + MOD__SPI0] = {
+        .con_id = modnode[MOD__SPI0].modname,
+    },
+    [CLOCK__MAX + MOD__IRC] = {
+        .con_id = modnode[MOD__IRC].modname,
+    },
+    [CLOCK__MAX + MOD__UART2] = {
+        .con_id = modnode[MOD__UART2].modname,
+    },
+    [CLOCK__MAX + MOD__UART1] = {
+        .con_id = modnode[MOD__UART1].modname,
+    },
+    [CLOCK__MAX + MOD__UART0] = {
+        .con_id = modnode[MOD__UART0].modname,
+    },
+    [CLOCK__MAX + MOD__HDMI] = {
+        .con_id = modnode[MOD__HDMI].modname,
+    },
+    [CLOCK__MAX + MOD__SS] = {
+        .con_id = modnode[MOD__SS].modname,
+    },
+    [CLOCK__MAX + MOD__TV24M] = {
+        .con_id = modnode[MOD__TV24M].modname,
+    },
+    [CLOCK__MAX + MOD__CVBS_CLK108M] = {
+        .con_id = modnode[MOD__CVBS_CLK108M].modname,
+    },
+    [CLOCK__MAX + MOD__TVOUT] = {
+        .con_id = modnode[MOD__TVOUT].modname,
+    },
+};
+
+static struct clocks_table clks_table = 
+{
+    .clocks = clocks,
+    .rvregs = rvregs,
+    .pllnode = pllnode,
+    .owl_clks = owl_clks,
+    .modnode = modnode,
+    .clk_foo_clocks = clk_foo_clocks,
+    .lookup_table = lookup_table,
+};
+
+struct clocks_table * atm7059_get_clocktree(void)
+{
+	return &clks_table;
+}
+
+void atm7059_init_clocktree(struct device_node *cum_node)
+{
+	int i;
+	int pll;
+	int frequency = 0;
+
+	clocks[CLOCK__L2_NIC_CLK].actdiv            = NULL;
+	clocks[CLOCK__L2_NIC_CLK].divider           = 1;
+	clocks[CLOCK__L2_NIC_CLK].harddivider       = 1;
+	clocks[CLOCK__L2_CLK].actdiv                = NULL;
+	clocks[CLOCK__L2_CLK].divider               = 1;
+	clocks[CLOCK__L2_CLK].harddivider           = 1;
+
+	clocks[CLOCK__CLK_PIXEL].actdiv             = NULL;
+	clocks[CLOCK__CLK_PIXEL].divider            = 1;
+	clocks[CLOCK__CLK_PIXEL].harddivider        = 1;
+	clocks[CLOCK__CLK_TMDS].actdiv              = NULL;
+	clocks[CLOCK__CLK_TMDS].divider             = 1;
+	clocks[CLOCK__CLK_TMDS].harddivider         = 1;
+	
+	clocks[CLOCK__PCM0_CLK].divider             = 2;
+	clocks[CLOCK__PCM1_CLK].divider             = 2;
+	clocks[CLOCK__PHY_CLK].divider              = 4;
+	clocks[CLOCK__SD0_CLK].divider              = 2;
+	clocks[CLOCK__SD1_CLK].divider              = 2;
+	clocks[CLOCK__SD2_CLK].divider              = 2;
+	clocks[CLOCK__I2C0_CLK].divider             = 5;
+	clocks[CLOCK__I2C1_CLK].divider             = 5;
+	clocks[CLOCK__I2C2_CLK].divider             = 5;
+	clocks[CLOCK__I2C3_CLK].divider             = 5;
+	clocks[CLOCK__25M_CLK].divider              = 20;
+	clocks[CLOCK__IRC_CLK].divider              = 120;
+	clocks[CLOCK__SPS_CLK].divider              = 12;
+                                    
+	clocks[CLOCK__PCM0_CLK].harddivider         = 2;
+	clocks[CLOCK__PCM1_CLK].harddivider         = 2;
+	clocks[CLOCK__PHY_CLK].harddivider          = 4;
+	clocks[CLOCK__SD0_CLK].harddivider          = 2;
+	clocks[CLOCK__SD1_CLK].harddivider          = 2;
+	clocks[CLOCK__SD2_CLK].harddivider          = 2;
+	clocks[CLOCK__I2C0_CLK].harddivider         = 5;
+	clocks[CLOCK__I2C1_CLK].harddivider         = 5;
+	clocks[CLOCK__I2C2_CLK].harddivider         = 5;
+	clocks[CLOCK__I2C3_CLK].harddivider         = 5;
+	clocks[CLOCK__25M_CLK].harddivider          = 20;
+	clocks[CLOCK__IRC_CLK].harddivider          = 120;
+	clocks[CLOCK__SPS_CLK].harddivider          = 12;
+
+	clocks[CLOCK__HOSC].harddivider             = 1;
+	clocks[CLOCK__IC_32K].harddivider           = 1;
+	clocks[CLOCK__DEV_CLK].harddivider          = 1;
+	clocks[CLOCK__DDR_CLK_0].harddivider        = 1;
+	clocks[CLOCK__DDR_CLK_90].harddivider       = 1;
+	clocks[CLOCK__DDR_CLK_180].harddivider      = 1;
+	clocks[CLOCK__DDR_CLK_270].harddivider      = 1;
+	clocks[CLOCK__DDR_CLK_CH0].harddivider      = 1;
+	clocks[CLOCK__DDR_CLK_CH1].harddivider      = 1;
+	clocks[CLOCK__DDR_CLK].harddivider          = 1;
+	clocks[CLOCK__CLK_TMDS_PHY_P].harddivider   = 1;
+	clocks[CLOCK__AHB_CLK].harddivider          = 1;
+	clocks[CLOCK__CORE_CLK].harddivider         = 1;
+	clocks[CLOCK__CPU_CLK].harddivider          = 1;
+	clocks[CLOCK__LVDS_CLK].harddivider         = 1;
+	clocks[CLOCK__CKA_LCD_H].harddivider        = 1;
+	clocks[CLOCK__ISPBP_CLK].harddivider        = 1;
+	clocks[CLOCK__IMG5_CLK].harddivider         = 1;
+	clocks[CLOCK__HDMI24M].harddivider          = 1;
+	clocks[CLOCK__TIMER_CLK].harddivider        = 1;
+	clocks[CLOCK__TV24M].harddivider            = 1;
+	clocks[CLOCK__CVBS_CLK108M].harddivider            = 1;
+	clocks[CLOCK__MIPI24M].harddivider          = 1;
+	clocks[CLOCK__LENS24M].harddivider          = 1;
+	clocks[CLOCK__DSI_HCLK90].harddivider       = 1;
+
+	clocks[CLOCK__COREPLL].harddivider          = 1;
+	clocks[CLOCK__DEVPLL].harddivider           = 1;
+	clocks[CLOCK__DDRPLL].harddivider           = 1;
+	clocks[CLOCK__NANDPLL].harddivider          = 1;
+	clocks[CLOCK__DISPLAYPLL].harddivider       = 1;
+	clocks[CLOCK__AUDIOPLL].harddivider         = 1;
+	clocks[CLOCK__TVOUTPLL].harddivider         = 1;
+	clocks[CLOCK__ETHERNETPLL].harddivider      = 1;
+	clocks[CLOCK__CVBSPLL].harddivider      = 1;
+
+	clocks[CLOCK__SPDIF_CLK].actdiv             = &divider_SPDIF_CLK;
+	clocks[CLOCK__HDMIA_CLK].actdiv             = &divider_HDMIA_CLK;
+	clocks[CLOCK__I2SRX_CLK].actdiv             = &divider_I2SRX_CLK;
+	clocks[CLOCK__I2STX_CLK].actdiv             = &divider_I2STX_CLK;
+	clocks[CLOCK__APBDBG_CLK].actdiv            = &divider_APBDBG_CLK;
+	clocks[CLOCK__ACP_CLK].actdiv               = &divider_ACP_CLK;
+	clocks[CLOCK__PERIPH_CLK].actdiv            = &divider_PERIPH_CLK;
+	clocks[CLOCK__NIC_DIV_CLK].actdiv           = &divider_NIC_DIV_CLK;
+	clocks[CLOCK__NIC_CLK].actdiv               = &divider_NIC_CLK;
+	clocks[CLOCK__AHBPREDIV_CLK].actdiv         = &divider_AHBPREDIV_CLK;
+	clocks[CLOCK__H_CLK].actdiv                 = &divider_H_CLK;
+	clocks[CLOCK__APB30_CLK].actdiv             = &divider_APB30_CLK;
+	clocks[CLOCK__APB20_CLK].actdiv             = &divider_APB20_CLK;
+	clocks[CLOCK__SENSOR_CLKOUT0].actdiv        = &divider_SENSOR_CLKOUT0;
+	clocks[CLOCK__SENSOR_CLKOUT1].actdiv        = &divider_SENSOR_CLKOUT1;
+	clocks[CLOCK__LCD_CLK].actdiv               = &divider_LCD_CLK;
+	clocks[CLOCK__LCD1_CLK].actdiv              = &divider_LCD1_CLK;
+	clocks[CLOCK__LCD0_CLK].actdiv              = &divider_LCD0_CLK;
+	clocks[CLOCK__DSI_HCLK].actdiv              = &divider_DSI_HCLK;
+	clocks[CLOCK__PRO_CLK].actdiv               = &divider_PRO_CLK;
+	clocks[CLOCK__CSI_CLK].actdiv               = &divider_CSI_CLK;
+	clocks[CLOCK__DE1_CLK].actdiv               = &divider_DE1_CLK;
+	clocks[CLOCK__DE2_CLK].actdiv               = &divider_DE2_CLK;
+	clocks[CLOCK__BISP_CLK].actdiv              = &divider_BISP_CLK;
+	clocks[CLOCK__VDE_CLK].actdiv               = &divider_VDE_CLK;
+	clocks[CLOCK__VCE_CLK].actdiv               = &divider_VCE_CLK;
+	clocks[CLOCK__NANDC_CLK].actdiv             = &divider_NANDC_CLK;
+	clocks[CLOCK__ECC_CLK].actdiv               = &divider_ECC_CLK;
+	clocks[CLOCK__PRESD0_CLK].actdiv            = &divider_PRESD0_CLK;
+	clocks[CLOCK__PRESD1_CLK].actdiv            = &divider_PRESD1_CLK;
+	clocks[CLOCK__PRESD2_CLK].actdiv            = &divider_PRESD2_CLK;
+	clocks[CLOCK__SD0_CLK_2X].actdiv            = &divider_SD0_CLK_2X;
+	clocks[CLOCK__SD1_CLK_2X].actdiv            = &divider_SD1_CLK_2X;
+	clocks[CLOCK__SD2_CLK_2X].actdiv            = &divider_SD2_CLK_2X;
+	clocks[CLOCK__UART0_CLK].actdiv             = &divider_UART0_CLK;
+	clocks[CLOCK__UART1_CLK].actdiv             = &divider_UART1_CLK;
+	clocks[CLOCK__UART2_CLK].actdiv             = &divider_UART2_CLK;
+	clocks[CLOCK__UART3_CLK].actdiv             = &divider_UART3_CLK;
+	clocks[CLOCK__UART4_CLK].actdiv             = &divider_UART4_CLK;
+	clocks[CLOCK__UART5_CLK].actdiv             = &divider_UART5_CLK;
+	clocks[CLOCK__UART6_CLK].actdiv             = &divider_UART6_CLK;
+	clocks[CLOCK__PWM0_CLK].actdiv              = &divider_PWM0_CLK;
+	clocks[CLOCK__PWM1_CLK].actdiv              = &divider_PWM1_CLK;
+	clocks[CLOCK__PWM2_CLK].actdiv              = &divider_PWM2_CLK;
+	clocks[CLOCK__PWM3_CLK].actdiv              = &divider_PWM3_CLK;
+	clocks[CLOCK__PWM4_CLK].actdiv              = &divider_PWM4_CLK;
+	clocks[CLOCK__PWM5_CLK].actdiv              = &divider_PWM5_CLK;
+	clocks[CLOCK__RMII_REF_CLK].actdiv          = &divider_RMII_REF_CLK;
+	clocks[CLOCK__LENS_CLK].actdiv              = &divider_LENS_CLK;
+	clocks[CLOCK__GPU3D_SYSCLK].actdiv          = &divider_GPU3D_SYSCLK;
+	clocks[CLOCK__GPU3D_HYDCLK].actdiv          = &divider_GPU3D_HYDCLK;
+	clocks[CLOCK__GPU3D_NIC_MEMCLK].actdiv      = &divider_GPU3D_NIC_MEMCLK;
+	clocks[CLOCK__GPU3D_CORECLK].actdiv         = &divider_GPU3D_CORECLK;
+	clocks[CLOCK__SS_CLK].actdiv                = &divider_SS_CLK;
+
+	for (i = 0; i < CLOCK__MAX; i++) {
+		/*
+		 * read pll frequency from cmu regs
+		 * TVOUTPLL must read before DEEPCOLORPLL
+		 */
+		if (clocks[i].type == TYPE_PLL) {
+			pll = i - CLOCK__COREPLL;
+			if (pllnode[pll].reg_pllfreq) {
+				pllnode[pll].sel = read_clkreg_val(pllnode[pll].reg_pllfreq);
+			} else
+				pllnode[pll].sel = 0;
+
+			switch (pllnode[pll].type) {
+			case PLL_T_D4DYN:
+				pllnode[pll].sel |= 4;
+			case PLL_T_STEP:
+				frequency = (pllnode[pll].sel+pllnode[pll].freq.step.offset) * pllnode[pll].freq.step.step;
+				break;
+			case PLL_T_FREQ:
+				frequency = pllnode[pll].freq.freqtab[pllnode[pll].sel];
+				break;
+			default:
+				break;
+			}
+			if (pll == PLL__TVOUTPLL && frequency > 4) {
+				pllnode[PLL__DEEPCOLORPLL].freq.step.step = frequency / 4;
+			}
+			clocks[i].frequency = frequency;
+		}
+
+		/*
+		 * read clock divider from cmu regs
+		 */
+		write_clkreg_val(&busbit_DIVEN, 0);
+		if (clocks[i].actdiv) {
+			clocks[i].divsel = read_clkreg_val(clocks[i].actdiv->reg);
+			clocks[i].divider = getdivider(clocks[i].actdiv, clocks[i].divsel);
+			if (clocks[i].divider < 0) {
+				clocks[i].divsel = getdivider_resetval(clocks[i].actdiv);
+				write_clkreg_val(clocks[i].actdiv->reg, clocks[i].divsel);
+				clocks[i].divider = getdivider(clocks[i].actdiv, clocks[i].divsel);
+			}
+
+			if (i == CLOCK__PRO_CLK && (clocks[i].divider & 0xffff0000)) {
+				clocks[i].multipler = 3;
+				clocks[i].divider = 4;
+			}
+		}
+		write_clkreg_val(&busbit_DIVEN, 1);
+
+		/*
+		 * read clock dependence legacy
+		 */
+		if (clocks[i].reg_srcsel) {
+			clocks[i].source_sel = read_clkreg_val(clocks[i].reg_srcsel);
+			/* of cause source_sel must < source_lim */
+			if (clocks[i].source_sel >= clocks[i].source_lim) {
+				printk("error: clock %s parent index error\n",
+					clocks[i].name);
+				clocks[i].source_sel = 0;
+			}
+		}
+
+		addclock(i);
+		if (clocks[i].type == TYPE_DYNAMIC) {
+			clocks[i].changed = 1;
+		}
+	}
+
+	owl_clks[CLOCK__HOSC] = owl_clk_register_fixed_rate_with_accuracy(NULL, clocks[CLOCK__HOSC].name, NULL, CLK_IS_ROOT,
+							&clk_ops_gate_hosc, FREQUENCY_24M, 0, CLOCK__HOSC);
+	owl_clks[CLOCK__IC_32K] = owl_clk_register_fixed_rate_with_accuracy(NULL, clocks[CLOCK__IC_32K].name, NULL, CLK_IS_ROOT,
+							&clk_ops_gate_ic32k, FREQUENCY_32K, 0, CLOCK__IC_32K);
+	owl_clks[CLOCK__COREPLL] = owl_clk_register_gate(NULL, clocks[CLOCK__COREPLL].name, parent_names_COREPLL[0], 0,
+							&clk_ops_corepll, NULL, 0, 0, NULL, CLOCK__COREPLL);
+	owl_clks[CLOCK__DEVPLL] = owl_clk_register_gate(NULL, clocks[CLOCK__DEVPLL].name, parent_names_DEVPLL[0], 0,
+							&clk_ops_pll, NULL, 0, 0, NULL, CLOCK__DEVPLL);
+	owl_clks[CLOCK__DDRPLL] = owl_clk_register_gate(NULL, clocks[CLOCK__DDRPLL].name, parent_names_DDRPLL[0], 0,
+							&clk_ops_pll, NULL, 0, 0, NULL, CLOCK__DDRPLL);
+	owl_clks[CLOCK__NANDPLL] = owl_clk_register_gate(NULL, clocks[CLOCK__NANDPLL].name, parent_names_NANDPLL[0], 0,
+							&clk_ops_pll, NULL, 0, 0, NULL, CLOCK__NANDPLL);
+	owl_clks[CLOCK__DISPLAYPLL] = owl_clk_register_gate(NULL, clocks[CLOCK__DISPLAYPLL].name, parent_names_DISPLAYPLL[0], 0,
+							&clk_ops_pll, NULL, 0, 0, NULL, CLOCK__DISPLAYPLL);
+	owl_clks[CLOCK__AUDIOPLL] = owl_clk_register_gate(NULL, clocks[CLOCK__AUDIOPLL].name, parent_names_AUDIOPLL[0], 0,
+							&clk_ops_pll, NULL, 0, 0, NULL, CLOCK__AUDIOPLL);
+	owl_clks[CLOCK__TVOUTPLL] = owl_clk_register_gate(NULL, clocks[CLOCK__TVOUTPLL].name, parent_names_TVOUTPLL[0], 0,
+							&clk_ops_pll, NULL, 0, 0, NULL, CLOCK__TVOUTPLL);
+	owl_clks[CLOCK__ETHERNETPLL] = owl_clk_register_gate(NULL, clocks[CLOCK__ETHERNETPLL].name, parent_names_ETHERNETPLL[0], 0,
+							&clk_ops_pll, NULL, 0, 0, NULL, CLOCK__ETHERNETPLL);
+	owl_clks[CLOCK__CVBSPLL] = owl_clk_register_gate(NULL, clocks[CLOCK__CVBSPLL].name, parent_names_CVBSPLL[0], 0,
+							&clk_ops_pll, NULL, 0, 0, NULL, CLOCK__CVBSPLL);
+	owl_clks[CLOCK__DEV_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__DEV_CLK].name, parent_names_DEV_CLK, 2, 0,
+							&clk_ops_direct_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__DEV_CLK);
+	owl_clks[CLOCK__DDR_CLK_0] = owl_clk_register_gate(NULL, clocks[CLOCK__DDR_CLK_0].name, parent_names_DDR_CLK_0[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__DDR_CLK_0);
+	owl_clks[CLOCK__DDR_CLK_90] = owl_clk_register_gate(NULL, clocks[CLOCK__DDR_CLK_90].name, parent_names_DDR_CLK_90[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__DDR_CLK_90);
+	owl_clks[CLOCK__DDR_CLK_180] = owl_clk_register_gate(NULL, clocks[CLOCK__DDR_CLK_180].name, parent_names_DDR_CLK_180[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__DDR_CLK_180);
+	owl_clks[CLOCK__DDR_CLK_270] = owl_clk_register_gate(NULL, clocks[CLOCK__DDR_CLK_270].name, parent_names_DDR_CLK_270[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__DDR_CLK_270);
+	owl_clks[CLOCK__DDR_CLK_CH0] = owl_clk_register_gate(NULL, clocks[CLOCK__DDR_CLK_CH0].name, parent_names_DDR_CLK_CH0[0], CLK_SET_RATE_PARENT,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__DDR_CLK_CH0);
+	owl_clks[CLOCK__DDR_CLK_CH1] = owl_clk_register_mux_table(NULL, clocks[CLOCK__DDR_CLK_CH1].name, parent_names_DDR_CLK_CH1, 4, CLK_SET_RATE_PARENT,
+							&clk_ops_direct_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__DDR_CLK_CH1);
+	owl_clks[CLOCK__DDR_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__DDR_CLK].name, parent_names_DDR_CLK[0], CLK_SET_RATE_PARENT,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__DDR_CLK);
+	owl_clks[CLOCK__SPDIF_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__SPDIF_CLK].name, parent_names_SPDIF_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__SPDIF_CLK);
+	owl_clks[CLOCK__HDMIA_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__HDMIA_CLK].name, parent_names_HDMIA_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__HDMIA_CLK);
+	owl_clks[CLOCK__I2SRX_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__I2SRX_CLK].name, parent_names_I2SRX_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__I2SRX_CLK);
+	owl_clks[CLOCK__I2STX_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__I2STX_CLK].name, parent_names_I2STX_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__I2STX_CLK);
+	owl_clks[CLOCK__PCM0_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__PCM0_CLK].name, parent_names_PCM0_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__PCM0_CLK);
+	owl_clks[CLOCK__PCM1_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__PCM1_CLK].name, parent_names_PCM1_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__PCM1_CLK);
+	owl_clks[CLOCK__CLK_PIXEL] = owl_clk_register_gate(NULL, clocks[CLOCK__CLK_PIXEL].name, parent_names_CLK_PIXEL[0], CLK_GET_RATE_NOCACHE,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__CLK_PIXEL);
+	owl_clks[CLOCK__CLK_TMDS] = owl_clk_register_gate(NULL, clocks[CLOCK__CLK_TMDS].name, parent_names_CLK_TMDS[0], CLK_GET_RATE_NOCACHE,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__CLK_TMDS);
+	owl_clks[CLOCK__CLK_TMDS_PHY_P] = owl_clk_register_gate(NULL, clocks[CLOCK__CLK_TMDS_PHY_P].name, parent_names_CLK_TMDS_PHY_P[0], CLK_SET_RATE_PARENT,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__CLK_TMDS_PHY_P);
+	owl_clks[CLOCK__CORE_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__CORE_CLK].name, parent_names_CORE_CLK, 4, 0,
+							&clk_ops_direct_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__CORE_CLK);
+	owl_clks[CLOCK__L2_NIC_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__L2_NIC_CLK].name, parent_names_L2_NIC_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__L2_NIC_CLK);
+	owl_clks[CLOCK__CPU_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__CPU_CLK].name, parent_names_CPU_CLK[0], CLK_SET_RATE_PARENT,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__CPU_CLK);
+	owl_clks[CLOCK__APBDBG_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__APBDBG_CLK].name, parent_names_APBDBG_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__APBDBG_CLK);
+	owl_clks[CLOCK__L2_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__L2_CLK].name, parent_names_L2_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__L2_CLK);
+	owl_clks[CLOCK__ACP_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__ACP_CLK].name, parent_names_ACP_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__ACP_CLK);
+	owl_clks[CLOCK__PERIPH_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__PERIPH_CLK].name, parent_names_PERIPH_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__PERIPH_CLK);
+	owl_clks[CLOCK__NIC_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__NIC_CLK].name, parent_names_NIC_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__NIC_CLK);
+	owl_clks[CLOCK__NIC_DIV_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__NIC_DIV_CLK].name, parent_names_NIC_DIV_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__NIC_DIV_CLK);
+	owl_clks[CLOCK__AHBPREDIV_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__AHBPREDIV_CLK].name, parent_names_AHBPREDIV_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__AHBPREDIV_CLK);
+	owl_clks[CLOCK__H_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__H_CLK].name, parent_names_H_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__H_CLK);
+	owl_clks[CLOCK__APB30_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__APB30_CLK].name, parent_names_APB30_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__APB30_CLK);
+	owl_clks[CLOCK__APB20_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__APB20_CLK].name, parent_names_APB20_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__APB20_CLK);
+	owl_clks[CLOCK__AHB_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__AHB_CLK].name, parent_names_AHB_CLK[0], CLK_SET_RATE_PARENT,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__AHB_CLK);
+	owl_clks[CLOCK__SENSOR_CLKOUT0] = owl_clk_register_mux_table(NULL, clocks[CLOCK__SENSOR_CLKOUT0].name, parent_names_SENSOR_CLKOUT0, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__SENSOR_CLKOUT0);
+	owl_clks[CLOCK__SENSOR_CLKOUT1] = owl_clk_register_mux_table(NULL, clocks[CLOCK__SENSOR_CLKOUT1].name, parent_names_SENSOR_CLKOUT1, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__SENSOR_CLKOUT1);
+	owl_clks[CLOCK__LCD_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__LCD_CLK].name, parent_names_LCD_CLK, 3, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__LCD_CLK);
+	owl_clks[CLOCK__LVDS_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__LVDS_CLK].name, parent_names_LVDS_CLK[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__LVDS_CLK);
+	owl_clks[CLOCK__CKA_LCD_H] = owl_clk_register_gate(NULL, clocks[CLOCK__CKA_LCD_H].name, parent_names_CKA_LCD_H[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__CKA_LCD_H);
+	owl_clks[CLOCK__LCD1_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__LCD1_CLK].name, parent_names_LCD1_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__LCD1_CLK);
+	owl_clks[CLOCK__LCD0_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__LCD0_CLK].name, parent_names_LCD0_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__LCD0_CLK);
+	owl_clks[CLOCK__DSI_HCLK] = owl_clk_register_gate(NULL, clocks[CLOCK__DSI_HCLK].name, parent_names_DSI_HCLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__DSI_HCLK);
+	owl_clks[CLOCK__DSI_HCLK90] = owl_clk_register_gate(NULL, clocks[CLOCK__DSI_HCLK90].name, parent_names_DSI_HCLK90[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__DSI_HCLK90);
+	owl_clks[CLOCK__PRO_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__PRO_CLK].name, parent_names_PRO_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__PRO_CLK);
+	owl_clks[CLOCK__PHY_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__PHY_CLK].name, parent_names_PHY_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__PHY_CLK);
+	owl_clks[CLOCK__CSI_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__CSI_CLK].name, parent_names_CSI_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__CSI_CLK);
+	owl_clks[CLOCK__DE1_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__DE1_CLK].name, parent_names_DE1_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__DE1_CLK);
+	owl_clks[CLOCK__DE2_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__DE2_CLK].name, parent_names_DE2_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__DE2_CLK);
+	owl_clks[CLOCK__BISP_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__BISP_CLK].name, parent_names_BISP_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__BISP_CLK);
+	owl_clks[CLOCK__ISPBP_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__ISPBP_CLK].name, parent_names_ISPBP_CLK[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__ISPBP_CLK);
+	owl_clks[CLOCK__IMG5_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__IMG5_CLK].name, parent_names_IMG5_CLK, 2, CLK_SET_RATE_PARENT,
+							&clk_ops_direct_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__IMG5_CLK);
+	owl_clks[CLOCK__VDE_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__VDE_CLK].name, parent_names_VDE_CLK, 4, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__VDE_CLK);
+	owl_clks[CLOCK__VCE_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__VCE_CLK].name, parent_names_VCE_CLK, 4, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__VCE_CLK);
+	owl_clks[CLOCK__NANDC_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__NANDC_CLK].name, parent_names_NANDC_CLK, 4, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__NANDC_CLK);
+	owl_clks[CLOCK__ECC_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__ECC_CLK].name, parent_names_ECC_CLK, 4, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__ECC_CLK);
+	owl_clks[CLOCK__PRESD0_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__PRESD0_CLK].name, parent_names_PRESD0_CLK, 2, 0,
+							&clk_ops_h_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__PRESD0_CLK);
+	owl_clks[CLOCK__PRESD1_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__PRESD1_CLK].name, parent_names_PRESD1_CLK, 2, 0,
+							&clk_ops_h_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__PRESD1_CLK);
+	owl_clks[CLOCK__PRESD2_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__PRESD2_CLK].name, parent_names_PRESD2_CLK, 2, 0,
+							&clk_ops_h_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__PRESD2_CLK);
+	owl_clks[CLOCK__SD0_CLK_2X] = owl_clk_register_gate(NULL, clocks[CLOCK__SD0_CLK_2X].name, parent_names_SD0_CLK_2X[0], CLK_SET_RATE_PARENT,
+							&clk_ops_b_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__SD0_CLK_2X);
+	owl_clks[CLOCK__SD1_CLK_2X] = owl_clk_register_gate(NULL, clocks[CLOCK__SD1_CLK_2X].name, parent_names_SD1_CLK_2X[0], CLK_SET_RATE_PARENT,
+							&clk_ops_b_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__SD1_CLK_2X);
+	owl_clks[CLOCK__SD2_CLK_2X] = owl_clk_register_gate(NULL, clocks[CLOCK__SD2_CLK_2X].name, parent_names_SD2_CLK_2X[0], CLK_SET_RATE_PARENT,
+							&clk_ops_b_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__SD2_CLK_2X);
+	owl_clks[CLOCK__SD0_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__SD0_CLK].name, parent_names_SD0_CLK[0], CLK_SET_RATE_PARENT,
+							&clk_ops_b_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__SD0_CLK);
+	owl_clks[CLOCK__SD1_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__SD1_CLK].name, parent_names_SD1_CLK[0], CLK_SET_RATE_PARENT,
+							&clk_ops_b_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__SD1_CLK);
+	owl_clks[CLOCK__SD2_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__SD2_CLK].name, parent_names_SD2_CLK[0], CLK_SET_RATE_PARENT,
+							&clk_ops_b_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__SD2_CLK);
+	owl_clks[CLOCK__UART0_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__UART0_CLK].name, parent_names_UART0_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__UART0_CLK);
+	owl_clks[CLOCK__UART1_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__UART1_CLK].name, parent_names_UART1_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__UART1_CLK);
+	owl_clks[CLOCK__UART2_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__UART2_CLK].name, parent_names_UART2_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__UART2_CLK);
+	owl_clks[CLOCK__UART3_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__UART3_CLK].name, parent_names_UART3_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__UART3_CLK);
+	owl_clks[CLOCK__UART4_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__UART4_CLK].name, parent_names_UART4_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__UART4_CLK);
+	owl_clks[CLOCK__UART5_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__UART5_CLK].name, parent_names_UART5_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__UART5_CLK);
+	owl_clks[CLOCK__UART6_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__UART6_CLK].name, parent_names_UART6_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__UART6_CLK);
+	owl_clks[CLOCK__PWM0_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__PWM0_CLK].name, parent_names_PWM0_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__PWM0_CLK);
+	owl_clks[CLOCK__PWM1_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__PWM1_CLK].name, parent_names_PWM1_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__PWM1_CLK);
+	owl_clks[CLOCK__PWM2_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__PWM2_CLK].name, parent_names_PWM2_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__PWM2_CLK);
+	owl_clks[CLOCK__PWM3_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__PWM3_CLK].name, parent_names_PWM3_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__PWM3_CLK);
+	owl_clks[CLOCK__PWM4_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__PWM4_CLK].name, parent_names_PWM4_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__PWM4_CLK);
+	owl_clks[CLOCK__PWM5_CLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__PWM5_CLK].name, parent_names_PWM5_CLK, 2, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__PWM5_CLK);
+	owl_clks[CLOCK__RMII_REF_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__RMII_REF_CLK].name, parent_names_RMII_REF_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__RMII_REF_CLK);
+	owl_clks[CLOCK__I2C0_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__I2C0_CLK].name, parent_names_I2C0_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__I2C0_CLK);
+	owl_clks[CLOCK__I2C1_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__I2C1_CLK].name, parent_names_I2C1_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__I2C1_CLK);
+	owl_clks[CLOCK__I2C2_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__I2C2_CLK].name, parent_names_I2C2_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__I2C2_CLK);
+	owl_clks[CLOCK__I2C3_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__I2C3_CLK].name, parent_names_I2C3_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__I2C3_CLK);
+	owl_clks[CLOCK__25M_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__25M_CLK].name, parent_names_25M_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__25M_CLK);
+	owl_clks[CLOCK__LENS_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__LENS_CLK].name, parent_names_LENS_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__LENS_CLK);
+	owl_clks[CLOCK__HDMI24M] = owl_clk_register_gate(NULL, clocks[CLOCK__HDMI24M].name, parent_names_HDMI24M[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__HDMI24M);
+	owl_clks[CLOCK__TIMER_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__TIMER_CLK].name, parent_names_TIMER_CLK[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__TIMER_CLK);
+	owl_clks[CLOCK__SS_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__SS_CLK].name, parent_names_SS_CLK[0], 0,
+							&clk_ops_m_divider_s_parent, NULL, 0, 0, NULL, CLOCK__SS_CLK);
+	owl_clks[CLOCK__SPS_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__SPS_CLK].name, parent_names_SPS_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__SPS_CLK);
+	owl_clks[CLOCK__IRC_CLK] = owl_clk_register_gate(NULL, clocks[CLOCK__IRC_CLK].name, parent_names_IRC_CLK[0], 0,
+							&clk_ops_s_divider_s_parent, NULL, 0, 0, NULL, CLOCK__IRC_CLK);
+	owl_clks[CLOCK__TV24M] = owl_clk_register_gate(NULL, clocks[CLOCK__TV24M].name, parent_names_TV24M[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__TV24M);
+	owl_clks[CLOCK__CVBS_CLK108M] = owl_clk_register_gate(NULL, clocks[CLOCK__CVBS_CLK108M].name, parent_names_CVBS_CLK108M[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__CVBS_CLK108M);
+	owl_clks[CLOCK__MIPI24M] = owl_clk_register_gate(NULL, clocks[CLOCK__MIPI24M].name, parent_names_MIPI24M[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__MIPI24M);
+	owl_clks[CLOCK__LENS24M] = owl_clk_register_gate(NULL, clocks[CLOCK__LENS24M].name, parent_names_LENS24M[0], 0,
+							&clk_ops_direct_s_parent, NULL, 0, 0, NULL, CLOCK__LENS24M);
+	owl_clks[CLOCK__GPU3D_SYSCLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__GPU3D_SYSCLK].name, parent_names_GPU3D_SYSCLK, 4, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__GPU3D_SYSCLK);
+	owl_clks[CLOCK__GPU3D_HYDCLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__GPU3D_HYDCLK].name, parent_names_GPU3D_HYDCLK, 4, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__GPU3D_HYDCLK);
+	owl_clks[CLOCK__GPU3D_NIC_MEMCLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__GPU3D_NIC_MEMCLK].name, parent_names_GPU3D_NIC_MEMCLK, 4, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__GPU3D_NIC_MEMCLK);
+	owl_clks[CLOCK__GPU3D_CORECLK] = owl_clk_register_mux_table(NULL, clocks[CLOCK__GPU3D_CORECLK].name, parent_names_GPU3D_CORECLK, 4, 0,
+							&clk_ops_m_divider_m_parent, NULL, 0, 0, 0, NULL, NULL, CLOCK__GPU3D_CORECLK);
+	owl_clks[CLOCK__MAX + MOD__ROOT] = owl_clk_register_gate(NULL, modnode[MOD__ROOT].modname, NULL, CLK_IS_ROOT,
+							&clk_ops_foo, NULL, 0, 0, NULL, MOD__ROOT);
+	owl_clks[CLOCK__MAX + MOD__GPU3D] = owl_clk_register_gate(NULL, modnode[MOD__GPU3D].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__GPU3D);
+	owl_clks[CLOCK__MAX + MOD__SHARESRAM] = owl_clk_register_gate(NULL, modnode[MOD__SHARESRAM].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SHARESRAM);
+	owl_clks[CLOCK__MAX + MOD__HDCP2X] = owl_clk_register_gate(NULL, modnode[MOD__HDCP2X].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__HDCP2X);
+	owl_clks[CLOCK__MAX + MOD__VCE] = owl_clk_register_gate(NULL, modnode[MOD__VCE].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__VCE);
+	owl_clks[CLOCK__MAX + MOD__VDE] = owl_clk_register_gate(NULL, modnode[MOD__VDE].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__VDE);
+	owl_clks[CLOCK__MAX + MOD__PCM0] = owl_clk_register_gate(NULL, modnode[MOD__PCM0].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__PCM0);
+	owl_clks[CLOCK__MAX + MOD__SPDIF] = owl_clk_register_gate(NULL, modnode[MOD__SPDIF].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SPDIF);
+	owl_clks[CLOCK__MAX + MOD__HDMIA] = owl_clk_register_gate(NULL, modnode[MOD__HDMIA].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__HDMIA);
+	owl_clks[CLOCK__MAX + MOD__I2SRX] = owl_clk_register_gate(NULL, modnode[MOD__I2SRX].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__I2SRX);
+	owl_clks[CLOCK__MAX + MOD__I2STX] = owl_clk_register_gate(NULL, modnode[MOD__I2STX].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__I2STX);
+	owl_clks[CLOCK__MAX + MOD__GPIO] = owl_clk_register_gate(NULL, modnode[MOD__GPIO].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__GPIO);
+	owl_clks[CLOCK__MAX + MOD__KEY] = owl_clk_register_gate(NULL, modnode[MOD__KEY].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__KEY);
+	owl_clks[CLOCK__MAX + MOD__LENS] = owl_clk_register_gate(NULL, modnode[MOD__LENS].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__LENS);
+	owl_clks[CLOCK__MAX + MOD__BISP] = owl_clk_register_gate(NULL, modnode[MOD__BISP].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__BISP);
+	owl_clks[CLOCK__MAX + MOD__CSI] = owl_clk_register_gate(NULL, modnode[MOD__CSI].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__CSI);
+	owl_clks[CLOCK__MAX + MOD__DSI] = owl_clk_register_gate(NULL, modnode[MOD__DSI].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__DSI);
+	owl_clks[CLOCK__MAX + MOD__LVDS] = owl_clk_register_gate(NULL, modnode[MOD__LVDS].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__LVDS);
+	owl_clks[CLOCK__MAX + MOD__LCD1] = owl_clk_register_gate(NULL, modnode[MOD__LCD1].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__LCD1);
+	owl_clks[CLOCK__MAX + MOD__LCD0] = owl_clk_register_gate(NULL, modnode[MOD__LCD0].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__LCD0);
+	owl_clks[CLOCK__MAX + MOD__DE] = owl_clk_register_gate(NULL, modnode[MOD__DE].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__DE);
+	owl_clks[CLOCK__MAX + MOD__SD2] = owl_clk_register_gate(NULL, modnode[MOD__SD2].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SD2);
+	owl_clks[CLOCK__MAX + MOD__SD1] = owl_clk_register_gate(NULL, modnode[MOD__SD1].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SD1);
+	owl_clks[CLOCK__MAX + MOD__SD0] = owl_clk_register_gate(NULL, modnode[MOD__SD0].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SD0);
+	owl_clks[CLOCK__MAX + MOD__NANDC] = owl_clk_register_gate(NULL, modnode[MOD__NANDC].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__NANDC);
+	owl_clks[CLOCK__MAX + MOD__DDRCH0] = owl_clk_register_gate(NULL, modnode[MOD__DDRCH0].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__DDRCH0);
+	owl_clks[CLOCK__MAX + MOD__NOR] = owl_clk_register_gate(NULL, modnode[MOD__NOR].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__NOR);
+	owl_clks[CLOCK__MAX + MOD__DMAC] = owl_clk_register_gate(NULL, modnode[MOD__DMAC].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__DMAC);
+	owl_clks[CLOCK__MAX + MOD__DDRCH1] = owl_clk_register_gate(NULL, modnode[MOD__DDRCH1].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__DDRCH1);
+	owl_clks[CLOCK__MAX + MOD__I2C3] = owl_clk_register_gate(NULL, modnode[MOD__I2C3].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__I2C3);
+	owl_clks[CLOCK__MAX + MOD__I2C2] = owl_clk_register_gate(NULL, modnode[MOD__I2C2].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__I2C2);
+	owl_clks[CLOCK__MAX + MOD__TIMER] = owl_clk_register_gate(NULL, modnode[MOD__TIMER].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__TIMER);
+	owl_clks[CLOCK__MAX + MOD__PWM5] = owl_clk_register_gate(NULL, modnode[MOD__PWM5].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__PWM5);
+	owl_clks[CLOCK__MAX + MOD__PWM4] = owl_clk_register_gate(NULL, modnode[MOD__PWM4].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__PWM4);
+	owl_clks[CLOCK__MAX + MOD__PWM3] = owl_clk_register_gate(NULL, modnode[MOD__PWM3].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__PWM3);
+	owl_clks[CLOCK__MAX + MOD__PWM2] = owl_clk_register_gate(NULL, modnode[MOD__PWM2].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__PWM2);
+	owl_clks[CLOCK__MAX + MOD__PWM1] = owl_clk_register_gate(NULL, modnode[MOD__PWM1].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__PWM1);
+	owl_clks[CLOCK__MAX + MOD__PWM0] = owl_clk_register_gate(NULL, modnode[MOD__PWM0].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__PWM0);
+	owl_clks[CLOCK__MAX + MOD__ETHERNET] = owl_clk_register_gate(NULL, modnode[MOD__ETHERNET].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__ETHERNET);
+	owl_clks[CLOCK__MAX + MOD__UART5] = owl_clk_register_gate(NULL, modnode[MOD__UART5].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__UART5);
+	owl_clks[CLOCK__MAX + MOD__UART4] = owl_clk_register_gate(NULL, modnode[MOD__UART4].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__UART4);
+	owl_clks[CLOCK__MAX + MOD__UART3] = owl_clk_register_gate(NULL, modnode[MOD__UART3].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__UART3);
+	owl_clks[CLOCK__MAX + MOD__UART6] = owl_clk_register_gate(NULL, modnode[MOD__UART6].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__UART6);
+	owl_clks[CLOCK__MAX + MOD__PCM1] = owl_clk_register_gate(NULL, modnode[MOD__PCM1].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__PCM1);
+	owl_clks[CLOCK__MAX + MOD__I2C1] = owl_clk_register_gate(NULL, modnode[MOD__I2C1].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__I2C1);
+	owl_clks[CLOCK__MAX + MOD__I2C0] = owl_clk_register_gate(NULL, modnode[MOD__I2C0].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__I2C0);
+	owl_clks[CLOCK__MAX + MOD__SPI3] = owl_clk_register_gate(NULL, modnode[MOD__SPI3].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SPI3);
+	owl_clks[CLOCK__MAX + MOD__SPI2] = owl_clk_register_gate(NULL, modnode[MOD__SPI2].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SPI2);
+	owl_clks[CLOCK__MAX + MOD__SPI1] = owl_clk_register_gate(NULL, modnode[MOD__SPI1].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SPI1);
+	owl_clks[CLOCK__MAX + MOD__SPI0] = owl_clk_register_gate(NULL, modnode[MOD__SPI0].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SPI0);
+	owl_clks[CLOCK__MAX + MOD__IRC] = owl_clk_register_gate(NULL, modnode[MOD__IRC].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__IRC);
+	owl_clks[CLOCK__MAX + MOD__UART2] = owl_clk_register_gate(NULL, modnode[MOD__UART2].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__UART2);
+	owl_clks[CLOCK__MAX + MOD__UART1] = owl_clk_register_gate(NULL, modnode[MOD__UART1].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__UART1);
+	owl_clks[CLOCK__MAX + MOD__UART0] = owl_clk_register_gate(NULL, modnode[MOD__UART0].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__UART0);
+	owl_clks[CLOCK__MAX + MOD__HDMI] = owl_clk_register_gate(NULL, modnode[MOD__HDMI].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__HDMI);
+	owl_clks[CLOCK__MAX + MOD__SS] = owl_clk_register_gate(NULL, modnode[MOD__SS].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__SS);
+	owl_clks[CLOCK__MAX + MOD__TV24M] = owl_clk_register_gate(NULL, modnode[MOD__TV24M].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__TV24M);
+	owl_clks[CLOCK__MAX + MOD__CVBS_CLK108M] = owl_clk_register_gate(NULL, modnode[MOD__CVBS_CLK108M].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__CVBS_CLK108M);
+	owl_clks[CLOCK__MAX + MOD__TVOUT] = owl_clk_register_gate(NULL, modnode[MOD__TVOUT].modname, parent_name_CMUMOD_DEVCLKS[0], 0,
+							&clk_ops_gate_module, NULL, 0, 0, NULL, MOD__TVOUT);
+
+	clk_data.clks = owl_clks;
+	clk_data.clk_num = ARRAY_SIZE(owl_clks);
+	of_clk_add_provider(cum_node, of_clk_src_onecell_get, &clk_data);
+
+	clk_foo_clocks[CLOCK__HOSC].hw.clk = owl_clks[CLOCK__HOSC];
+	clk_foo_clocks[CLOCK__IC_32K].hw.clk = owl_clks[CLOCK__IC_32K];
+	clk_foo_clocks[CLOCK__COREPLL].hw.clk = owl_clks[CLOCK__COREPLL];
+	clk_foo_clocks[CLOCK__DEVPLL].hw.clk = owl_clks[CLOCK__DEVPLL];
+	clk_foo_clocks[CLOCK__DDRPLL].hw.clk = owl_clks[CLOCK__DDRPLL];
+	clk_foo_clocks[CLOCK__NANDPLL].hw.clk = owl_clks[CLOCK__NANDPLL];
+	clk_foo_clocks[CLOCK__DISPLAYPLL].hw.clk = owl_clks[CLOCK__DISPLAYPLL];
+	clk_foo_clocks[CLOCK__AUDIOPLL].hw.clk = owl_clks[CLOCK__AUDIOPLL];
+	clk_foo_clocks[CLOCK__TVOUTPLL].hw.clk = owl_clks[CLOCK__TVOUTPLL];
+	clk_foo_clocks[CLOCK__ETHERNETPLL].hw.clk = owl_clks[CLOCK__ETHERNETPLL];
+	clk_foo_clocks[CLOCK__CVBSPLL].hw.clk = owl_clks[CLOCK__CVBSPLL];
+	clk_foo_clocks[CLOCK__DEV_CLK].hw.clk = owl_clks[CLOCK__DEV_CLK];
+	clk_foo_clocks[CLOCK__DDR_CLK_0].hw.clk = owl_clks[CLOCK__DDR_CLK_0];
+	clk_foo_clocks[CLOCK__DDR_CLK_90].hw.clk = owl_clks[CLOCK__DDR_CLK_90];
+	clk_foo_clocks[CLOCK__DDR_CLK_180].hw.clk = owl_clks[CLOCK__DDR_CLK_180];
+	clk_foo_clocks[CLOCK__DDR_CLK_270].hw.clk = owl_clks[CLOCK__DDR_CLK_270];
+	clk_foo_clocks[CLOCK__DDR_CLK_CH0].hw.clk = owl_clks[CLOCK__DDR_CLK_CH0];
+	clk_foo_clocks[CLOCK__DDR_CLK_CH1].hw.clk = owl_clks[CLOCK__DDR_CLK_CH1];
+	clk_foo_clocks[CLOCK__DDR_CLK].hw.clk = owl_clks[CLOCK__DDR_CLK];
+	clk_foo_clocks[CLOCK__SPDIF_CLK].hw.clk = owl_clks[CLOCK__SPDIF_CLK];
+	clk_foo_clocks[CLOCK__HDMIA_CLK].hw.clk = owl_clks[CLOCK__HDMIA_CLK];
+	clk_foo_clocks[CLOCK__I2SRX_CLK].hw.clk = owl_clks[CLOCK__I2SRX_CLK];
+	clk_foo_clocks[CLOCK__I2STX_CLK].hw.clk = owl_clks[CLOCK__I2STX_CLK];
+	clk_foo_clocks[CLOCK__PCM0_CLK].hw.clk = owl_clks[CLOCK__PCM0_CLK];
+	clk_foo_clocks[CLOCK__PCM1_CLK].hw.clk = owl_clks[CLOCK__PCM1_CLK];
+	clk_foo_clocks[CLOCK__CLK_PIXEL].hw.clk = owl_clks[CLOCK__CLK_PIXEL];
+	clk_foo_clocks[CLOCK__CLK_TMDS].hw.clk = owl_clks[CLOCK__CLK_TMDS];
+	clk_foo_clocks[CLOCK__CLK_TMDS_PHY_P].hw.clk = owl_clks[CLOCK__CLK_TMDS_PHY_P];
+	clk_foo_clocks[CLOCK__L2_NIC_CLK].hw.clk = owl_clks[CLOCK__L2_NIC_CLK];
+	clk_foo_clocks[CLOCK__APBDBG_CLK].hw.clk = owl_clks[CLOCK__APBDBG_CLK];
+	clk_foo_clocks[CLOCK__L2_CLK].hw.clk = owl_clks[CLOCK__L2_CLK];
+	clk_foo_clocks[CLOCK__ACP_CLK].hw.clk = owl_clks[CLOCK__ACP_CLK];
+	clk_foo_clocks[CLOCK__PERIPH_CLK].hw.clk = owl_clks[CLOCK__PERIPH_CLK];
+	clk_foo_clocks[CLOCK__NIC_DIV_CLK].hw.clk = owl_clks[CLOCK__NIC_DIV_CLK];
+	clk_foo_clocks[CLOCK__NIC_CLK].hw.clk = owl_clks[CLOCK__NIC_CLK];
+	clk_foo_clocks[CLOCK__AHBPREDIV_CLK].hw.clk = owl_clks[CLOCK__AHBPREDIV_CLK];
+	clk_foo_clocks[CLOCK__H_CLK].hw.clk = owl_clks[CLOCK__H_CLK];
+	clk_foo_clocks[CLOCK__APB30_CLK].hw.clk = owl_clks[CLOCK__APB30_CLK];
+	clk_foo_clocks[CLOCK__APB20_CLK].hw.clk = owl_clks[CLOCK__APB20_CLK];
+	clk_foo_clocks[CLOCK__AHB_CLK].hw.clk = owl_clks[CLOCK__AHB_CLK];
+	clk_foo_clocks[CLOCK__CORE_CLK].hw.clk = owl_clks[CLOCK__CORE_CLK];
+	clk_foo_clocks[CLOCK__CPU_CLK].hw.clk = owl_clks[CLOCK__CPU_CLK];
+	clk_foo_clocks[CLOCK__SENSOR_CLKOUT0].hw.clk = owl_clks[CLOCK__SENSOR_CLKOUT0];
+	clk_foo_clocks[CLOCK__SENSOR_CLKOUT1].hw.clk = owl_clks[CLOCK__SENSOR_CLKOUT1];
+	clk_foo_clocks[CLOCK__LCD_CLK].hw.clk = owl_clks[CLOCK__LCD_CLK];
+	clk_foo_clocks[CLOCK__LVDS_CLK].hw.clk = owl_clks[CLOCK__LVDS_CLK];
+	clk_foo_clocks[CLOCK__CKA_LCD_H].hw.clk = owl_clks[CLOCK__CKA_LCD_H];
+	clk_foo_clocks[CLOCK__LCD1_CLK].hw.clk = owl_clks[CLOCK__LCD1_CLK];
+	clk_foo_clocks[CLOCK__LCD0_CLK].hw.clk = owl_clks[CLOCK__LCD0_CLK];
+	clk_foo_clocks[CLOCK__DSI_HCLK].hw.clk = owl_clks[CLOCK__DSI_HCLK];
+	clk_foo_clocks[CLOCK__DSI_HCLK90].hw.clk = owl_clks[CLOCK__DSI_HCLK90];
+	clk_foo_clocks[CLOCK__PRO_CLK].hw.clk = owl_clks[CLOCK__PRO_CLK];
+	clk_foo_clocks[CLOCK__PHY_CLK].hw.clk = owl_clks[CLOCK__PHY_CLK];
+	clk_foo_clocks[CLOCK__CSI_CLK].hw.clk = owl_clks[CLOCK__CSI_CLK];
+	clk_foo_clocks[CLOCK__DE1_CLK].hw.clk = owl_clks[CLOCK__DE1_CLK];
+	clk_foo_clocks[CLOCK__DE2_CLK].hw.clk = owl_clks[CLOCK__DE2_CLK];
+	clk_foo_clocks[CLOCK__BISP_CLK].hw.clk = owl_clks[CLOCK__BISP_CLK];
+	clk_foo_clocks[CLOCK__ISPBP_CLK].hw.clk = owl_clks[CLOCK__ISPBP_CLK];
+	clk_foo_clocks[CLOCK__IMG5_CLK].hw.clk = owl_clks[CLOCK__IMG5_CLK];
+	clk_foo_clocks[CLOCK__VDE_CLK].hw.clk = owl_clks[CLOCK__VDE_CLK];
+	clk_foo_clocks[CLOCK__VCE_CLK].hw.clk = owl_clks[CLOCK__VCE_CLK];
+	clk_foo_clocks[CLOCK__NANDC_CLK].hw.clk = owl_clks[CLOCK__NANDC_CLK];
+	clk_foo_clocks[CLOCK__ECC_CLK].hw.clk = owl_clks[CLOCK__ECC_CLK];
+	clk_foo_clocks[CLOCK__PRESD0_CLK].hw.clk = owl_clks[CLOCK__PRESD0_CLK];
+	clk_foo_clocks[CLOCK__PRESD1_CLK].hw.clk = owl_clks[CLOCK__PRESD1_CLK];
+	clk_foo_clocks[CLOCK__PRESD2_CLK].hw.clk = owl_clks[CLOCK__PRESD2_CLK];
+	clk_foo_clocks[CLOCK__SD0_CLK_2X].hw.clk = owl_clks[CLOCK__SD0_CLK_2X];
+	clk_foo_clocks[CLOCK__SD1_CLK_2X].hw.clk = owl_clks[CLOCK__SD1_CLK_2X];
+	clk_foo_clocks[CLOCK__SD2_CLK_2X].hw.clk = owl_clks[CLOCK__SD2_CLK_2X];
+	clk_foo_clocks[CLOCK__SD0_CLK].hw.clk = owl_clks[CLOCK__SD0_CLK];
+	clk_foo_clocks[CLOCK__SD1_CLK].hw.clk = owl_clks[CLOCK__SD1_CLK];
+	clk_foo_clocks[CLOCK__SD2_CLK].hw.clk = owl_clks[CLOCK__SD2_CLK];
+	clk_foo_clocks[CLOCK__UART0_CLK].hw.clk = owl_clks[CLOCK__UART0_CLK];
+	clk_foo_clocks[CLOCK__UART1_CLK].hw.clk = owl_clks[CLOCK__UART1_CLK];
+	clk_foo_clocks[CLOCK__UART2_CLK].hw.clk = owl_clks[CLOCK__UART2_CLK];
+	clk_foo_clocks[CLOCK__UART3_CLK].hw.clk = owl_clks[CLOCK__UART3_CLK];
+	clk_foo_clocks[CLOCK__UART4_CLK].hw.clk = owl_clks[CLOCK__UART4_CLK];
+	clk_foo_clocks[CLOCK__UART5_CLK].hw.clk = owl_clks[CLOCK__UART5_CLK];
+	clk_foo_clocks[CLOCK__UART6_CLK].hw.clk = owl_clks[CLOCK__UART6_CLK];
+	clk_foo_clocks[CLOCK__PWM0_CLK].hw.clk = owl_clks[CLOCK__PWM0_CLK];
+	clk_foo_clocks[CLOCK__PWM1_CLK].hw.clk = owl_clks[CLOCK__PWM1_CLK];
+	clk_foo_clocks[CLOCK__PWM2_CLK].hw.clk = owl_clks[CLOCK__PWM2_CLK];
+	clk_foo_clocks[CLOCK__PWM3_CLK].hw.clk = owl_clks[CLOCK__PWM3_CLK];
+	clk_foo_clocks[CLOCK__PWM4_CLK].hw.clk = owl_clks[CLOCK__PWM4_CLK];
+	clk_foo_clocks[CLOCK__PWM5_CLK].hw.clk = owl_clks[CLOCK__PWM5_CLK];
+	clk_foo_clocks[CLOCK__RMII_REF_CLK].hw.clk = owl_clks[CLOCK__RMII_REF_CLK];
+	clk_foo_clocks[CLOCK__I2C0_CLK].hw.clk = owl_clks[CLOCK__I2C0_CLK];
+	clk_foo_clocks[CLOCK__I2C1_CLK].hw.clk = owl_clks[CLOCK__I2C1_CLK];
+	clk_foo_clocks[CLOCK__I2C2_CLK].hw.clk = owl_clks[CLOCK__I2C2_CLK];
+	clk_foo_clocks[CLOCK__I2C3_CLK].hw.clk = owl_clks[CLOCK__I2C3_CLK];
+	clk_foo_clocks[CLOCK__25M_CLK].hw.clk = owl_clks[CLOCK__25M_CLK];
+	clk_foo_clocks[CLOCK__LENS_CLK].hw.clk = owl_clks[CLOCK__LENS_CLK];
+	clk_foo_clocks[CLOCK__HDMI24M].hw.clk = owl_clks[CLOCK__HDMI24M];
+	clk_foo_clocks[CLOCK__TIMER_CLK].hw.clk = owl_clks[CLOCK__TIMER_CLK];
+	clk_foo_clocks[CLOCK__SS_CLK].hw.clk = owl_clks[CLOCK__SS_CLK];
+	clk_foo_clocks[CLOCK__SPS_CLK].hw.clk = owl_clks[CLOCK__SPS_CLK];
+	clk_foo_clocks[CLOCK__IRC_CLK].hw.clk = owl_clks[CLOCK__IRC_CLK];
+	clk_foo_clocks[CLOCK__TV24M].hw.clk = owl_clks[CLOCK__TV24M];
+	clk_foo_clocks[CLOCK__CVBS_CLK108M].hw.clk = owl_clks[CLOCK__CVBS_CLK108M];
+	clk_foo_clocks[CLOCK__MIPI24M].hw.clk = owl_clks[CLOCK__MIPI24M];
+	clk_foo_clocks[CLOCK__LENS24M].hw.clk = owl_clks[CLOCK__LENS24M];
+	clk_foo_clocks[CLOCK__GPU3D_SYSCLK].hw.clk = owl_clks[CLOCK__GPU3D_SYSCLK];
+	clk_foo_clocks[CLOCK__GPU3D_HYDCLK].hw.clk = owl_clks[CLOCK__GPU3D_HYDCLK];
+	clk_foo_clocks[CLOCK__GPU3D_NIC_MEMCLK].hw.clk = owl_clks[CLOCK__GPU3D_NIC_MEMCLK];
+	clk_foo_clocks[CLOCK__GPU3D_CORECLK].hw.clk = owl_clks[CLOCK__GPU3D_CORECLK];
+
+	clk_foo_modules[MOD__ROOT].hw.clk = owl_clks[CLOCK__MAX + MOD__ROOT];
+	clk_foo_modules[MOD__GPU3D].hw.clk = owl_clks[CLOCK__MAX + MOD__GPU3D];
+	clk_foo_modules[MOD__SHARESRAM].hw.clk = owl_clks[CLOCK__MAX + MOD__SHARESRAM];
+	clk_foo_modules[MOD__HDCP2X].hw.clk = owl_clks[CLOCK__MAX + MOD__HDCP2X];
+	clk_foo_modules[MOD__VCE].hw.clk = owl_clks[CLOCK__MAX + MOD__VCE];
+	clk_foo_modules[MOD__VDE].hw.clk = owl_clks[CLOCK__MAX + MOD__VDE];
+	clk_foo_modules[MOD__PCM0].hw.clk = owl_clks[CLOCK__MAX + MOD__PCM0];
+	clk_foo_modules[MOD__SPDIF].hw.clk = owl_clks[CLOCK__MAX + MOD__SPDIF];
+	clk_foo_modules[MOD__HDMIA].hw.clk = owl_clks[CLOCK__MAX + MOD__HDMIA];
+	clk_foo_modules[MOD__I2SRX].hw.clk = owl_clks[CLOCK__MAX + MOD__I2SRX];
+	clk_foo_modules[MOD__I2STX].hw.clk = owl_clks[CLOCK__MAX + MOD__I2STX];
+	clk_foo_modules[MOD__GPIO].hw.clk = owl_clks[CLOCK__MAX + MOD__GPIO];
+	clk_foo_modules[MOD__KEY].hw.clk = owl_clks[CLOCK__MAX + MOD__KEY];
+	clk_foo_modules[MOD__LENS].hw.clk = owl_clks[CLOCK__MAX + MOD__LENS];
+	clk_foo_modules[MOD__BISP].hw.clk = owl_clks[CLOCK__MAX + MOD__BISP];
+	clk_foo_modules[MOD__CSI].hw.clk = owl_clks[CLOCK__MAX + MOD__CSI];
+	clk_foo_modules[MOD__DSI].hw.clk = owl_clks[CLOCK__MAX + MOD__DSI];
+	clk_foo_modules[MOD__LVDS].hw.clk = owl_clks[CLOCK__MAX + MOD__LVDS];
+	clk_foo_modules[MOD__LCD1].hw.clk = owl_clks[CLOCK__MAX + MOD__LCD1];
+	clk_foo_modules[MOD__LCD0].hw.clk = owl_clks[CLOCK__MAX + MOD__LCD0];
+	clk_foo_modules[MOD__DE].hw.clk = owl_clks[CLOCK__MAX + MOD__DE];
+	clk_foo_modules[MOD__SD2].hw.clk = owl_clks[CLOCK__MAX + MOD__SD2];
+	clk_foo_modules[MOD__SD1].hw.clk = owl_clks[CLOCK__MAX + MOD__SD1];
+	clk_foo_modules[MOD__SD0].hw.clk = owl_clks[CLOCK__MAX + MOD__SD0];
+	clk_foo_modules[MOD__NANDC].hw.clk = owl_clks[CLOCK__MAX + MOD__NANDC];
+	clk_foo_modules[MOD__DDRCH0].hw.clk = owl_clks[CLOCK__MAX + MOD__DDRCH0];
+	clk_foo_modules[MOD__NOR].hw.clk = owl_clks[CLOCK__MAX + MOD__NOR];
+	clk_foo_modules[MOD__DMAC].hw.clk = owl_clks[CLOCK__MAX + MOD__DMAC];
+	clk_foo_modules[MOD__DDRCH1].hw.clk = owl_clks[CLOCK__MAX + MOD__DDRCH1];
+	clk_foo_modules[MOD__I2C3].hw.clk = owl_clks[CLOCK__MAX + MOD__I2C3];
+	clk_foo_modules[MOD__I2C2].hw.clk = owl_clks[CLOCK__MAX + MOD__I2C2];
+	clk_foo_modules[MOD__TIMER].hw.clk = owl_clks[CLOCK__MAX + MOD__TIMER];
+	clk_foo_modules[MOD__PWM5].hw.clk = owl_clks[CLOCK__MAX + MOD__PWM5];
+	clk_foo_modules[MOD__PWM4].hw.clk = owl_clks[CLOCK__MAX + MOD__PWM4];
+	clk_foo_modules[MOD__PWM3].hw.clk = owl_clks[CLOCK__MAX + MOD__PWM3];
+	clk_foo_modules[MOD__PWM2].hw.clk = owl_clks[CLOCK__MAX + MOD__PWM2];
+	clk_foo_modules[MOD__PWM1].hw.clk = owl_clks[CLOCK__MAX + MOD__PWM1];
+	clk_foo_modules[MOD__PWM0].hw.clk = owl_clks[CLOCK__MAX + MOD__PWM0];
+	clk_foo_modules[MOD__ETHERNET].hw.clk = owl_clks[CLOCK__MAX + MOD__ETHERNET];
+	clk_foo_modules[MOD__UART5].hw.clk = owl_clks[CLOCK__MAX + MOD__UART5];
+	clk_foo_modules[MOD__UART4].hw.clk = owl_clks[CLOCK__MAX + MOD__UART4];
+	clk_foo_modules[MOD__UART3].hw.clk = owl_clks[CLOCK__MAX + MOD__UART3];
+	clk_foo_modules[MOD__UART6].hw.clk = owl_clks[CLOCK__MAX + MOD__UART6];
+	clk_foo_modules[MOD__PCM1].hw.clk = owl_clks[CLOCK__MAX + MOD__PCM1];
+	clk_foo_modules[MOD__I2C1].hw.clk = owl_clks[CLOCK__MAX + MOD__I2C1];
+	clk_foo_modules[MOD__I2C0].hw.clk = owl_clks[CLOCK__MAX + MOD__I2C0];
+	clk_foo_modules[MOD__SPI3].hw.clk = owl_clks[CLOCK__MAX + MOD__SPI3];
+	clk_foo_modules[MOD__SPI2].hw.clk = owl_clks[CLOCK__MAX + MOD__SPI2];
+	clk_foo_modules[MOD__SPI1].hw.clk = owl_clks[CLOCK__MAX + MOD__SPI1];
+	clk_foo_modules[MOD__SPI0].hw.clk = owl_clks[CLOCK__MAX + MOD__SPI0];
+	clk_foo_modules[MOD__IRC].hw.clk = owl_clks[CLOCK__MAX + MOD__IRC];
+	clk_foo_modules[MOD__UART2].hw.clk = owl_clks[CLOCK__MAX + MOD__UART2];
+	clk_foo_modules[MOD__UART1].hw.clk = owl_clks[CLOCK__MAX + MOD__UART1];
+	clk_foo_modules[MOD__UART0].hw.clk = owl_clks[CLOCK__MAX + MOD__UART0];
+	clk_foo_modules[MOD__HDMI].hw.clk = owl_clks[CLOCK__MAX + MOD__HDMI];
+	clk_foo_modules[MOD__SS].hw.clk = owl_clks[CLOCK__MAX + MOD__SS];
+	clk_foo_modules[MOD__TV24M].hw.clk = owl_clks[CLOCK__MAX + MOD__TV24M];
+	clk_foo_modules[MOD__CVBS_CLK108M].hw.clk = owl_clks[CLOCK__MAX + MOD__CVBS_CLK108M];
+	clk_foo_modules[MOD__TVOUT].hw.clk = owl_clks[CLOCK__MAX + MOD__TVOUT];
+
+	lookup_table[CLOCK__HOSC].clk = owl_clks[CLOCK__HOSC];
+	lookup_table[CLOCK__IC_32K].clk = owl_clks[CLOCK__IC_32K];
+	lookup_table[CLOCK__COREPLL].clk = owl_clks[CLOCK__COREPLL];
+	lookup_table[CLOCK__DEVPLL].clk = owl_clks[CLOCK__DEVPLL];
+	lookup_table[CLOCK__DDRPLL].clk = owl_clks[CLOCK__DDRPLL];
+	lookup_table[CLOCK__NANDPLL].clk = owl_clks[CLOCK__NANDPLL];
+	lookup_table[CLOCK__DISPLAYPLL].clk = owl_clks[CLOCK__DISPLAYPLL];
+	lookup_table[CLOCK__AUDIOPLL].clk = owl_clks[CLOCK__AUDIOPLL];
+	lookup_table[CLOCK__TVOUTPLL].clk = owl_clks[CLOCK__TVOUTPLL];
+	lookup_table[CLOCK__ETHERNETPLL].clk = owl_clks[CLOCK__ETHERNETPLL];
+	lookup_table[CLOCK__CVBSPLL].clk = owl_clks[CLOCK__CVBSPLL];
+	lookup_table[CLOCK__DEV_CLK].clk = owl_clks[CLOCK__DEV_CLK];
+	lookup_table[CLOCK__DDR_CLK_0].clk = owl_clks[CLOCK__DDR_CLK_0];
+	lookup_table[CLOCK__DDR_CLK_90].clk = owl_clks[CLOCK__DDR_CLK_90];
+	lookup_table[CLOCK__DDR_CLK_180].clk = owl_clks[CLOCK__DDR_CLK_180];
+	lookup_table[CLOCK__DDR_CLK_270].clk = owl_clks[CLOCK__DDR_CLK_270];
+	lookup_table[CLOCK__DDR_CLK_CH0].clk = owl_clks[CLOCK__DDR_CLK_CH0];
+	lookup_table[CLOCK__DDR_CLK_CH1].clk = owl_clks[CLOCK__DDR_CLK_CH1];
+	lookup_table[CLOCK__DDR_CLK].clk = owl_clks[CLOCK__DDR_CLK];
+	lookup_table[CLOCK__SPDIF_CLK].clk = owl_clks[CLOCK__SPDIF_CLK];
+	lookup_table[CLOCK__HDMIA_CLK].clk = owl_clks[CLOCK__HDMIA_CLK];
+	lookup_table[CLOCK__I2SRX_CLK].clk = owl_clks[CLOCK__I2SRX_CLK];
+	lookup_table[CLOCK__I2STX_CLK].clk = owl_clks[CLOCK__I2STX_CLK];
+	lookup_table[CLOCK__PCM0_CLK].clk = owl_clks[CLOCK__PCM0_CLK];
+	lookup_table[CLOCK__PCM1_CLK].clk = owl_clks[CLOCK__PCM1_CLK];
+	lookup_table[CLOCK__CLK_PIXEL].clk = owl_clks[CLOCK__CLK_PIXEL];
+	lookup_table[CLOCK__CLK_TMDS].clk = owl_clks[CLOCK__CLK_TMDS];
+	lookup_table[CLOCK__CLK_TMDS_PHY_P].clk = owl_clks[CLOCK__CLK_TMDS_PHY_P];
+	lookup_table[CLOCK__L2_NIC_CLK].clk = owl_clks[CLOCK__L2_NIC_CLK];
+	lookup_table[CLOCK__APBDBG_CLK].clk = owl_clks[CLOCK__APBDBG_CLK];
+	lookup_table[CLOCK__L2_CLK].clk = owl_clks[CLOCK__L2_CLK];
+	lookup_table[CLOCK__ACP_CLK].clk = owl_clks[CLOCK__ACP_CLK];
+	lookup_table[CLOCK__PERIPH_CLK].clk = owl_clks[CLOCK__PERIPH_CLK];
+	lookup_table[CLOCK__NIC_DIV_CLK].clk = owl_clks[CLOCK__NIC_DIV_CLK];
+	lookup_table[CLOCK__NIC_CLK].clk = owl_clks[CLOCK__NIC_CLK];
+	lookup_table[CLOCK__AHBPREDIV_CLK].clk = owl_clks[CLOCK__AHBPREDIV_CLK];
+	lookup_table[CLOCK__H_CLK].clk = owl_clks[CLOCK__H_CLK];
+	lookup_table[CLOCK__APB30_CLK].clk = owl_clks[CLOCK__APB30_CLK];
+	lookup_table[CLOCK__APB20_CLK].clk = owl_clks[CLOCK__APB20_CLK];
+	lookup_table[CLOCK__AHB_CLK].clk = owl_clks[CLOCK__AHB_CLK];
+	lookup_table[CLOCK__CORE_CLK].clk = owl_clks[CLOCK__CORE_CLK];
+	lookup_table[CLOCK__CPU_CLK].clk = owl_clks[CLOCK__CPU_CLK];
+	lookup_table[CLOCK__SENSOR_CLKOUT0].clk = owl_clks[CLOCK__SENSOR_CLKOUT0];
+	lookup_table[CLOCK__SENSOR_CLKOUT1].clk = owl_clks[CLOCK__SENSOR_CLKOUT1];
+	lookup_table[CLOCK__LCD_CLK].clk = owl_clks[CLOCK__LCD_CLK];
+	lookup_table[CLOCK__LVDS_CLK].clk = owl_clks[CLOCK__LVDS_CLK];
+	lookup_table[CLOCK__CKA_LCD_H].clk = owl_clks[CLOCK__CKA_LCD_H];
+	lookup_table[CLOCK__LCD1_CLK].clk = owl_clks[CLOCK__LCD1_CLK];
+	lookup_table[CLOCK__LCD0_CLK].clk = owl_clks[CLOCK__LCD0_CLK];
+	lookup_table[CLOCK__DSI_HCLK].clk = owl_clks[CLOCK__DSI_HCLK];
+	lookup_table[CLOCK__DSI_HCLK90].clk = owl_clks[CLOCK__DSI_HCLK90];
+	lookup_table[CLOCK__PRO_CLK].clk = owl_clks[CLOCK__PRO_CLK];
+	lookup_table[CLOCK__PHY_CLK].clk = owl_clks[CLOCK__PHY_CLK];
+	lookup_table[CLOCK__CSI_CLK].clk = owl_clks[CLOCK__CSI_CLK];
+	lookup_table[CLOCK__DE1_CLK].clk = owl_clks[CLOCK__DE1_CLK];
+	lookup_table[CLOCK__DE2_CLK].clk = owl_clks[CLOCK__DE2_CLK];
+	lookup_table[CLOCK__BISP_CLK].clk = owl_clks[CLOCK__BISP_CLK];
+	lookup_table[CLOCK__ISPBP_CLK].clk = owl_clks[CLOCK__ISPBP_CLK];
+	lookup_table[CLOCK__IMG5_CLK].clk = owl_clks[CLOCK__IMG5_CLK];
+	lookup_table[CLOCK__VDE_CLK].clk = owl_clks[CLOCK__VDE_CLK];
+	lookup_table[CLOCK__VCE_CLK].clk = owl_clks[CLOCK__VCE_CLK];
+	lookup_table[CLOCK__NANDC_CLK].clk = owl_clks[CLOCK__NANDC_CLK];
+	lookup_table[CLOCK__ECC_CLK].clk = owl_clks[CLOCK__ECC_CLK];
+	lookup_table[CLOCK__PRESD0_CLK].clk = owl_clks[CLOCK__PRESD0_CLK];
+	lookup_table[CLOCK__PRESD1_CLK].clk = owl_clks[CLOCK__PRESD1_CLK];
+	lookup_table[CLOCK__PRESD2_CLK].clk = owl_clks[CLOCK__PRESD2_CLK];
+	lookup_table[CLOCK__SD0_CLK_2X].clk = owl_clks[CLOCK__SD0_CLK_2X];
+	lookup_table[CLOCK__SD1_CLK_2X].clk = owl_clks[CLOCK__SD1_CLK_2X];
+	lookup_table[CLOCK__SD2_CLK_2X].clk = owl_clks[CLOCK__SD2_CLK_2X];
+	lookup_table[CLOCK__SD0_CLK].clk = owl_clks[CLOCK__SD0_CLK];
+	lookup_table[CLOCK__SD1_CLK].clk = owl_clks[CLOCK__SD1_CLK];
+	lookup_table[CLOCK__SD2_CLK].clk = owl_clks[CLOCK__SD2_CLK];
+	lookup_table[CLOCK__UART0_CLK].clk = owl_clks[CLOCK__UART0_CLK];
+	lookup_table[CLOCK__UART1_CLK].clk = owl_clks[CLOCK__UART1_CLK];
+	lookup_table[CLOCK__UART2_CLK].clk = owl_clks[CLOCK__UART2_CLK];
+	lookup_table[CLOCK__UART3_CLK].clk = owl_clks[CLOCK__UART3_CLK];
+	lookup_table[CLOCK__UART4_CLK].clk = owl_clks[CLOCK__UART4_CLK];
+	lookup_table[CLOCK__UART5_CLK].clk = owl_clks[CLOCK__UART5_CLK];
+	lookup_table[CLOCK__UART6_CLK].clk = owl_clks[CLOCK__UART6_CLK];
+	lookup_table[CLOCK__PWM0_CLK].clk = owl_clks[CLOCK__PWM0_CLK];
+	lookup_table[CLOCK__PWM1_CLK].clk = owl_clks[CLOCK__PWM1_CLK];
+	lookup_table[CLOCK__PWM2_CLK].clk = owl_clks[CLOCK__PWM2_CLK];
+	lookup_table[CLOCK__PWM3_CLK].clk = owl_clks[CLOCK__PWM3_CLK];
+	lookup_table[CLOCK__PWM4_CLK].clk = owl_clks[CLOCK__PWM4_CLK];
+	lookup_table[CLOCK__PWM5_CLK].clk = owl_clks[CLOCK__PWM5_CLK];
+	lookup_table[CLOCK__RMII_REF_CLK].clk = owl_clks[CLOCK__RMII_REF_CLK];
+	lookup_table[CLOCK__I2C0_CLK].clk = owl_clks[CLOCK__I2C0_CLK];
+	lookup_table[CLOCK__I2C1_CLK].clk = owl_clks[CLOCK__I2C1_CLK];
+	lookup_table[CLOCK__I2C2_CLK].clk = owl_clks[CLOCK__I2C2_CLK];
+	lookup_table[CLOCK__I2C3_CLK].clk = owl_clks[CLOCK__I2C3_CLK];
+	lookup_table[CLOCK__25M_CLK].clk = owl_clks[CLOCK__25M_CLK];
+	lookup_table[CLOCK__LENS_CLK].clk = owl_clks[CLOCK__LENS_CLK];
+	lookup_table[CLOCK__HDMI24M].clk = owl_clks[CLOCK__HDMI24M];
+	lookup_table[CLOCK__TIMER_CLK].clk = owl_clks[CLOCK__TIMER_CLK];
+	lookup_table[CLOCK__SS_CLK].clk = owl_clks[CLOCK__SS_CLK];
+	lookup_table[CLOCK__SPS_CLK].clk = owl_clks[CLOCK__SPS_CLK];
+	lookup_table[CLOCK__IRC_CLK].clk = owl_clks[CLOCK__IRC_CLK];
+	lookup_table[CLOCK__TV24M].clk = owl_clks[CLOCK__TV24M];
+	lookup_table[CLOCK__CVBS_CLK108M].clk = owl_clks[CLOCK__CVBS_CLK108M];
+	lookup_table[CLOCK__MIPI24M].clk = owl_clks[CLOCK__MIPI24M];
+	lookup_table[CLOCK__LENS24M].clk = owl_clks[CLOCK__LENS24M];
+	lookup_table[CLOCK__GPU3D_SYSCLK].clk = owl_clks[CLOCK__GPU3D_SYSCLK];
+	lookup_table[CLOCK__GPU3D_HYDCLK].clk = owl_clks[CLOCK__GPU3D_HYDCLK];
+	lookup_table[CLOCK__GPU3D_NIC_MEMCLK].clk = owl_clks[CLOCK__GPU3D_NIC_MEMCLK];
+	lookup_table[CLOCK__GPU3D_CORECLK].clk = owl_clks[CLOCK__GPU3D_CORECLK];
+	lookup_table[CLOCK__MAX + MOD__ROOT].clk = owl_clks[CLOCK__MAX + MOD__ROOT];
+	lookup_table[CLOCK__MAX + MOD__GPU3D].clk = owl_clks[CLOCK__MAX + MOD__GPU3D];
+	lookup_table[CLOCK__MAX + MOD__SHARESRAM].clk = owl_clks[CLOCK__MAX + MOD__SHARESRAM];
+	lookup_table[CLOCK__MAX + MOD__HDCP2X].clk = owl_clks[CLOCK__MAX + MOD__HDCP2X];
+	lookup_table[CLOCK__MAX + MOD__VCE].clk = owl_clks[CLOCK__MAX + MOD__VCE];
+	lookup_table[CLOCK__MAX + MOD__VDE].clk = owl_clks[CLOCK__MAX + MOD__VDE];
+	lookup_table[CLOCK__MAX + MOD__PCM0].clk = owl_clks[CLOCK__MAX + MOD__PCM0];
+	lookup_table[CLOCK__MAX + MOD__SPDIF].clk = owl_clks[CLOCK__MAX + MOD__SPDIF];
+	lookup_table[CLOCK__MAX + MOD__HDMIA].clk = owl_clks[CLOCK__MAX + MOD__HDMIA];
+	lookup_table[CLOCK__MAX + MOD__I2SRX].clk = owl_clks[CLOCK__MAX + MOD__I2SRX];
+	lookup_table[CLOCK__MAX + MOD__I2STX].clk = owl_clks[CLOCK__MAX + MOD__I2STX];
+	lookup_table[CLOCK__MAX + MOD__GPIO].clk = owl_clks[CLOCK__MAX + MOD__GPIO];
+	lookup_table[CLOCK__MAX + MOD__KEY].clk = owl_clks[CLOCK__MAX + MOD__KEY];
+	lookup_table[CLOCK__MAX + MOD__LENS].clk = owl_clks[CLOCK__MAX + MOD__LENS];
+	lookup_table[CLOCK__MAX + MOD__BISP].clk = owl_clks[CLOCK__MAX + MOD__BISP];
+	lookup_table[CLOCK__MAX + MOD__CSI].clk = owl_clks[CLOCK__MAX + MOD__CSI];
+	lookup_table[CLOCK__MAX + MOD__DSI].clk = owl_clks[CLOCK__MAX + MOD__DSI];
+	lookup_table[CLOCK__MAX + MOD__LVDS].clk = owl_clks[CLOCK__MAX + MOD__LVDS];
+	lookup_table[CLOCK__MAX + MOD__LCD1].clk = owl_clks[CLOCK__MAX + MOD__LCD1];
+	lookup_table[CLOCK__MAX + MOD__LCD0].clk = owl_clks[CLOCK__MAX + MOD__LCD0];
+	lookup_table[CLOCK__MAX + MOD__DE].clk = owl_clks[CLOCK__MAX + MOD__DE];
+	lookup_table[CLOCK__MAX + MOD__SD2].clk = owl_clks[CLOCK__MAX + MOD__SD2];
+	lookup_table[CLOCK__MAX + MOD__SD1].clk = owl_clks[CLOCK__MAX + MOD__SD1];
+	lookup_table[CLOCK__MAX + MOD__SD0].clk = owl_clks[CLOCK__MAX + MOD__SD0];
+	lookup_table[CLOCK__MAX + MOD__NANDC].clk = owl_clks[CLOCK__MAX + MOD__NANDC];
+	lookup_table[CLOCK__MAX + MOD__DDRCH0].clk = owl_clks[CLOCK__MAX + MOD__DDRCH0];
+	lookup_table[CLOCK__MAX + MOD__NOR].clk = owl_clks[CLOCK__MAX + MOD__NOR];
+	lookup_table[CLOCK__MAX + MOD__DMAC].clk = owl_clks[CLOCK__MAX + MOD__DMAC];
+	lookup_table[CLOCK__MAX + MOD__DDRCH1].clk = owl_clks[CLOCK__MAX + MOD__DDRCH1];
+	lookup_table[CLOCK__MAX + MOD__I2C3].clk = owl_clks[CLOCK__MAX + MOD__I2C3];
+	lookup_table[CLOCK__MAX + MOD__I2C2].clk = owl_clks[CLOCK__MAX + MOD__I2C2];
+	lookup_table[CLOCK__MAX + MOD__TIMER].clk = owl_clks[CLOCK__MAX + MOD__TIMER];
+	lookup_table[CLOCK__MAX + MOD__PWM5].clk = owl_clks[CLOCK__MAX + MOD__PWM5];
+	lookup_table[CLOCK__MAX + MOD__PWM4].clk = owl_clks[CLOCK__MAX + MOD__PWM4];
+	lookup_table[CLOCK__MAX + MOD__PWM3].clk = owl_clks[CLOCK__MAX + MOD__PWM3];
+	lookup_table[CLOCK__MAX + MOD__PWM2].clk = owl_clks[CLOCK__MAX + MOD__PWM2];
+	lookup_table[CLOCK__MAX + MOD__PWM1].clk = owl_clks[CLOCK__MAX + MOD__PWM1];
+	lookup_table[CLOCK__MAX + MOD__PWM0].clk = owl_clks[CLOCK__MAX + MOD__PWM0];
+	lookup_table[CLOCK__MAX + MOD__ETHERNET].clk = owl_clks[CLOCK__MAX + MOD__ETHERNET];
+	lookup_table[CLOCK__MAX + MOD__UART5].clk = owl_clks[CLOCK__MAX + MOD__UART5];
+	lookup_table[CLOCK__MAX + MOD__UART4].clk = owl_clks[CLOCK__MAX + MOD__UART4];
+	lookup_table[CLOCK__MAX + MOD__UART3].clk = owl_clks[CLOCK__MAX + MOD__UART3];
+	lookup_table[CLOCK__MAX + MOD__UART6].clk = owl_clks[CLOCK__MAX + MOD__UART6];
+	lookup_table[CLOCK__MAX + MOD__PCM1].clk = owl_clks[CLOCK__MAX + MOD__PCM1];
+	lookup_table[CLOCK__MAX + MOD__I2C1].clk = owl_clks[CLOCK__MAX + MOD__I2C1];
+	lookup_table[CLOCK__MAX + MOD__I2C0].clk = owl_clks[CLOCK__MAX + MOD__I2C0];
+	lookup_table[CLOCK__MAX + MOD__SPI3].clk = owl_clks[CLOCK__MAX + MOD__SPI3];
+	lookup_table[CLOCK__MAX + MOD__SPI2].clk = owl_clks[CLOCK__MAX + MOD__SPI2];
+	lookup_table[CLOCK__MAX + MOD__SPI1].clk = owl_clks[CLOCK__MAX + MOD__SPI1];
+	lookup_table[CLOCK__MAX + MOD__SPI0].clk = owl_clks[CLOCK__MAX + MOD__SPI0];
+	lookup_table[CLOCK__MAX + MOD__IRC].clk = owl_clks[CLOCK__MAX + MOD__IRC];
+	lookup_table[CLOCK__MAX + MOD__UART2].clk = owl_clks[CLOCK__MAX + MOD__UART2];
+	lookup_table[CLOCK__MAX + MOD__UART1].clk = owl_clks[CLOCK__MAX + MOD__UART1];
+	lookup_table[CLOCK__MAX + MOD__UART0].clk = owl_clks[CLOCK__MAX + MOD__UART0];
+	lookup_table[CLOCK__MAX + MOD__HDMI].clk = owl_clks[CLOCK__MAX + MOD__HDMI];
+	lookup_table[CLOCK__MAX + MOD__SS].clk = owl_clks[CLOCK__MAX + MOD__SS];
+	lookup_table[CLOCK__MAX + MOD__TV24M].clk = owl_clks[CLOCK__MAX + MOD__TV24M];
+	lookup_table[CLOCK__MAX + MOD__CVBS_CLK108M].clk = owl_clks[CLOCK__MAX + MOD__CVBS_CLK108M];
+	lookup_table[CLOCK__MAX + MOD__TVOUT].clk = owl_clks[CLOCK__MAX + MOD__TVOUT];
+
+	owl_clk_config_recursion(CLOCK__LCD0_CLK, 1);
+	owl_clk_config_recursion(CLOCK__LCD1_CLK, 1);
+	owl_clk_config_recursion(CLOCK__IMG5_CLK, 1);
+	owl_clk_config_recursion(CLOCK__DSI_HCLK90, 1);
+	owl_clk_config_recursion(CLOCK__PRO_CLK, 1);
+	owl_clk_config_recursion(CLOCK__PHY_CLK, 1);
+	owl_clk_config_recursion(CLOCK__LCD_CLK, 2);
+	owl_clk_config_recursion(CLOCK__DSI_HCLK, 2);
+}
+
+void atm7059_prepare_clocktree(void)
+{
+    int i;
+
+	/* recover refer count from cmu registers */
+	clk_prepare(owl_clks[CLOCK__IC_32K]);
+	clk_enable(owl_clks[CLOCK__IC_32K]);
+
+	if (read_clkreg_val(&enablebit_HOSC) == 1) {
+		clk_prepare(owl_clks[CLOCK__HOSC]);
+		clk_enable(owl_clks[CLOCK__HOSC]);
+	}
+
+	if (__clk_is_enabled(owl_clks[CLOCK__HOSC])) {
+		for (i = 0; i < PLL__MAX; i++) {
+			if (pllnode[i].reg_pllen && read_clkreg_val(pllnode[i].reg_pllen) == 1) {
+				clk_prepare(owl_clks[CLOCK__HOSC]);
+				clk_enable(owl_clks[CLOCK__HOSC]);
+				clk_prepare(owl_clks[CLOCK__COREPLL + i]);
+				clk_enable(owl_clks[CLOCK__COREPLL + i]);
+			}
+		}
+	}
+
+	clk_prepare(owl_clks[CLOCK__MAX + MOD__ROOT]);
+	clk_enable(owl_clks[CLOCK__MAX + MOD__ROOT]);
+	for (i = 1; i < MOD__MAX_IN_CLK; i++) {
+		if (modnode[i].reg_devclken && read_clkreg_val(modnode[i].reg_devclken) == 1) {
+			clk_prepare(owl_clks[CLOCK__MAX + MOD__ROOT]);
+			clk_enable(owl_clks[CLOCK__MAX + MOD__ROOT]);
+			clk_prepare(owl_clks[CLOCK__MAX + i]);
+			clk_enable(owl_clks[CLOCK__MAX + i]);
+		}
+	}
+}
diff --git a/arch/arm/mach-owl/clocktree-owl.c b/arch/arm/mach-owl/clocktree-owl.c
new file mode 100755
index 0000000..abab0b1
--- /dev/null
+++ b/arch/arm/mach-owl/clocktree-owl.c
@@ -0,0 +1,2094 @@
+#include "clocktree-owl.h"
+#include <mach/module-owl.h>
+
+#if 1
+ #define COREPLL_CHANGE_MIDDLE_CLK CLOCK__HOSC
+ #define COREPLL_CHANGE_DELAY_DIV 25
+#else
+ #define COREPLL_CHANGE_MIDDLE_CLK CLOCK__VCE_CLK
+ #define COREPLL_CHANGE_DELAY_DIV 1
+#endif
+
+
+
+static unsigned long *rvregs;
+static struct owl_clocknode *clocks;
+static struct owl_pll *pllnode;
+static struct clk **owl_clks;
+static struct owl_cmumod *modnode;
+static struct owl_clk_foo *clk_foo_clocks;
+static struct clk_lookup *lookup_table;
+
+
+static DEFINE_SPINLOCK(cmureg_update_lock);
+unsigned long regs[R_CMUMAX];
+static spinlock_t cpu_lock;
+
+int read_clkreg_val(struct owl_clkreq *reg)
+{
+	regs[reg->reg_no] = act_readl((u32)reg->reg_hw);
+	return ((regs[reg->reg_no])&reg->mask)>>reg->offset;
+}
+EXPORT_SYMBOL(read_clkreg_val);
+
+void write_clkreg_val(struct owl_clkreq *reg, int val)
+{
+	unsigned long read_back;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cmureg_update_lock, flags);
+
+	regs[reg->reg_no] = act_readl((u32)reg->reg_hw);
+	regs[reg->reg_no] &= ~reg->mask;
+	regs[reg->reg_no] |= (val << reg->offset) & reg->mask;
+	act_writel(regs[reg->reg_no], (u32)reg->reg_hw);
+
+	read_back = act_readl((u32)reg->reg_hw);
+	if (read_back != regs[reg->reg_no]) {
+		printk(KERN_WARNING "%s/%d: CMUREG read back error\n", __FILE__, __LINE__);
+		act_writel(regs[reg->reg_no], (u32)reg->reg_hw);
+	}
+
+	spin_unlock_irqrestore(&cmureg_update_lock, flags);
+}
+EXPORT_SYMBOL(write_clkreg_val);
+
+int getdivider_resetval(struct owl_div *div)
+{
+	int reg_no;
+
+	reg_no = div->reg->reg_no;
+	return (rvregs[reg_no] & div->reg->mask) >> div->reg->offset;
+}
+
+int getdivider(struct owl_div *div, int n)
+{
+	int d;
+	struct owl_section  *owl_section;
+
+	d = -1;
+	if (n >= div->range_from && n <= div->range_to) {
+		if (div->type == DIV_T_COMP) {
+			if (n >= div->ext.comp->sections[0].range_from
+				&& n <= div->ext.comp->sections[0].range_to) {
+				owl_section = &div->ext.comp->sections[0];
+			} else {
+				owl_section = &div->ext.comp->sections[1];
+			}
+		} else {
+			owl_section = (struct owl_section *)div;
+		}
+
+		switch (owl_section->type) {
+		case DIV_T_NATURE:
+			d = n + 1;
+			break;
+		case DIV_T_EXP:
+			d = (1 << n);
+			break;
+		case DIV_T_EXP_D2:
+			d = (2 << n);
+			break;
+		case DIV_T_SEQ:
+			d = owl_section->ext.seq->seq[n];
+			break;
+		case DIV_T_SEQ_D2:
+			d = (owl_section->ext.seq->seq[n] << 1);
+			break;
+		case DIV_T_TABLE:
+			d = owl_section->ext.tab->div[n-owl_section->range_from];
+			break;
+		}
+	}
+
+	return d;
+}
+
+static int getdivider_ge(struct owl_div *div, int divexp)
+{
+	int i;
+	int d;
+	int r, m;
+	struct owl_section  *owl_section;
+
+	d = -1;
+
+	m = divexp >> 16;
+    divexp &= 0xffff;
+	if (div->type == DIV_T_COMP) {
+		owl_section = &div->ext.comp->sections[1];
+		d = getdivider(div, owl_section->range_from);
+		if ( (m == 0 && divexp < d) || (m != 0 && divexp < d * m) ) {
+			owl_section = &div->ext.comp->sections[0];
+		} else {
+			d = -1;
+		}
+	} else {
+		owl_section = (struct owl_section *)div;
+	}
+
+    if(owl_section->type != DIV_T_TABLE && m != 0)
+        divexp = (divexp / m) + 1;
+	switch (owl_section->type) {
+	case DIV_T_NATURE:
+		if (divexp < owl_section->range_from + 1) {
+			d = owl_section->range_from + 1;
+		} else if (divexp > owl_section->range_to + 1) {
+			break;
+		} else
+			d = divexp;
+		break;
+	case DIV_T_EXP_D2:
+		if (divexp < (2 << owl_section->range_from)) {
+			d = (2 << owl_section->range_from);
+		} else if (divexp > (2 << owl_section->range_to)) {
+			break;
+		} else {
+			d = 1;
+			r = divexp;
+			while (d < divexp) {
+				d <<= 1;
+			}
+		}
+		break;
+	case DIV_T_EXP:
+		if (divexp < (1 << owl_section->range_from)) {
+			d = (1 << owl_section->range_from);
+		} else if (divexp > (1 << owl_section->range_to)) {
+			break;
+		} else {
+			d = 1;
+			r = divexp;
+			while (d < divexp) {
+				d <<= 1;
+			}
+		}
+		break;
+	case DIV_T_SEQ_D2:
+		for (i = owl_section->range_to; i >= owl_section->range_from; i--) {
+			if (divexp > (owl_section->ext.seq->seq[i] << 1))
+				break;
+
+			d = (owl_section->ext.seq->seq[i] << 1);
+		}
+		break;
+	case DIV_T_SEQ:
+		for (i = owl_section->range_to; i >= owl_section->range_from; i--) {
+			if (divexp > owl_section->ext.seq->seq[i])
+				break;
+
+			d = owl_section->ext.seq->seq[i];
+		}
+		break;
+	case DIV_T_TABLE:
+		for (i = owl_section->range_to-owl_section->range_from; i >= 0; i--) {
+			r = (owl_section->ext.tab->div[i] & 0xffff0000) >> 16;
+			if(r != 0 && m != 0) {
+				if (divexp * r > (owl_section->ext.tab->div[i] & 0xffff) * m)
+					break;
+			} else if(r != 0 && m == 0) {
+				if (divexp * r > (owl_section->ext.tab->div[i] & 0xffff))
+					break;
+		    } else if(r == 0 && m != 0) {
+				if (divexp > (owl_section->ext.tab->div[i] & 0xffff) * m)
+					break;
+			} else {
+				if (divexp > owl_section->ext.tab->div[i])
+					break;
+			}
+			
+			d = owl_section->ext.tab->div[i];
+		}
+		break;
+	}
+	return d;
+}
+
+static int getdivider_index(struct owl_div *div, int divexp)
+{
+	int i;
+	int idx;
+	struct owl_section  *owl_section;
+
+	idx = -1;
+
+	if (div->type == DIV_T_COMP) {
+		int j = 0;
+		owl_section = &div->ext.comp->sections[1];
+loop:
+		i = getdivider(div, owl_section->range_from+j);
+		if (divexp == i) {
+			return owl_section->range_from + j;
+		}
+
+		if (i > 0 && (i & 0xffff0000)) {
+			j++;
+			if (owl_section->range_from + j <= owl_section->range_to) {
+				goto loop;
+			}
+		}
+		if (divexp < i) {
+			owl_section = &div->ext.comp->sections[0];
+		} else {
+			idx = -1;
+		}
+	} else {
+		owl_section = (struct owl_section *)div;
+	}
+
+	switch (owl_section->type) {
+	case DIV_T_NATURE:
+		if (divexp > owl_section->range_from && divexp <= owl_section->range_to + 1) {
+			idx = divexp - 1;
+		}
+		break;
+	case DIV_T_EXP_D2:
+		if (divexp & 1) {
+			break;
+		}
+		divexp >>= 1;
+	case DIV_T_EXP:
+		if (divexp >= (1 << owl_section->range_from) &&
+			divexp <= (1 << owl_section->range_to)) {
+			idx = owl_section->range_from;
+			i = (1 << idx);
+			while (i < divexp) {
+				i <<= 1;
+				idx++;
+			}
+			if (i != divexp) {
+				idx = -1;
+			}
+		}
+		break;
+	case DIV_T_SEQ_D2:
+		if (divexp & 1) {
+			break;
+		}
+		divexp >>= 1;
+	case DIV_T_SEQ:
+		for (i = owl_section->range_to; i >= owl_section->range_from; i--) {
+			if (divexp == owl_section->ext.seq->seq[i]) {
+				idx = i;
+				break;
+			}
+		}
+		break;
+	case DIV_T_TABLE:
+		for (i = owl_section->range_to - owl_section->range_from; i >= 0; i--) {
+			if (divexp == owl_section->ext.tab->div[i]) {
+				idx = owl_section->range_from + i;
+				break;
+			}
+		}
+		break;
+	}
+	return idx;
+}
+
+int addclock(int clock)
+{
+	struct owl_clocknode *node;
+	struct owl_clocknode *parent;
+
+	node = &clocks[clock];
+	if (node->id != clock) {
+		/* node index error */
+		return -1;
+	}
+
+	if (node->parent != NULL) {
+		return -1;
+	}
+
+	if (node->type != TYPE_STATIC
+		&& node->source_sel >= 0
+		&& node->source_sel < node->source_lim) {
+		parent = &clocks[node->source_av[node->source_sel]];
+		node->parent = parent;
+
+		if (parent->sub == NULL) {
+			node->prev = node;
+			node->next = NULL;
+			parent->sub = node;
+		} else {
+			node->prev = parent->sub->prev;
+			node->next = NULL;
+			parent->sub->prev->next = node;
+			parent->sub->prev = node;
+		}
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int removeclock(int clock)
+{
+	struct owl_clocknode *node;
+	struct owl_clocknode *parent;
+	struct owl_clocknode *p;
+
+	node = &clocks[clock];
+	if (node->parent == NULL) {
+		return -1;
+	}
+
+	parent = &clocks[node->source_av[node->source_sel]];
+	if (parent != node->parent) {
+		/* parent error */
+		return -1;
+	}
+
+	node->parent = NULL;
+
+	p = parent->sub;
+	while (p && p->id != clock) {
+		p = p->next;
+	}
+
+	if (p) {
+		if (parent->sub->prev != parent->sub) {
+			if (p->next) {
+				p->next->prev = p->prev;
+			} else {
+				parent->sub->prev = p->prev;
+			}
+			if (p->prev->next == p) {
+				p->prev->next = p->next;
+			}
+			if (p == parent->sub) {
+				parent->sub = p->next;
+			}
+			p->prev = p->next = NULL;
+		} else {
+			parent->sub = NULL;
+			p->prev = p->next = NULL;
+		}
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static void changeclock(int clock)
+{
+	struct owl_clocknode *node;
+	struct owl_clocknode *p;
+
+	node = &clocks[clock];
+	node->changed = 1;
+	p = node->sub;
+	while (p) {
+		changeclock(p->id);
+		p = p->next;
+	}
+}
+
+
+static int  sourcesel(int clock, int source)
+{
+	struct owl_clocknode *node;
+	int i;
+	int clocksync;
+	struct owl_clkreq *reg;
+
+	node = &clocks[clock];
+	for (i = 0; i < node->source_lim; i++) {
+		if (node->source_av[i] == source) {
+			removeclock(clock);
+			reg = node->reg_srcsel;
+			write_clkreg_val(reg, i);
+
+			node->source_sel = i;
+			addclock(clock);
+			changeclock(clock);
+
+			switch (clock) {
+			case CLOCK__DE1_CLK:
+				clocksync = CLOCK__DE2_CLK;
+				goto share_selbit_sync;
+			case CLOCK__DE2_CLK:
+				clocksync = CLOCK__DE1_CLK;
+				goto share_selbit_sync;
+			case CLOCK__SENSOR_CLKOUT0:
+				clocksync = CLOCK__SENSOR_CLKOUT1;
+				goto share_selbit_sync;
+			case CLOCK__SENSOR_CLKOUT1:
+				clocksync = CLOCK__SENSOR_CLKOUT0;
+				goto share_selbit_sync;
+			case CLOCK__NANDC_CLK:
+				clocksync = CLOCK__ECC_CLK;
+				goto share_selbit_sync;
+			case CLOCK__ECC_CLK:
+				clocksync = CLOCK__NANDC_CLK;
+				goto share_selbit_sync;
+			default:
+				break;
+			share_selbit_sync:
+				/* share_selbit_sync to clocks[clocksync] */
+				node = &clocks[clocksync];
+				removeclock(clocksync);
+				node->source_sel = i;
+				addclock(clocksync);
+				changeclock(clocksync);
+				break;
+			}
+
+			return 0;
+		}
+	}
+	return -1;
+}
+
+
+static void calcfrequency(int clock)
+{
+	struct owl_clocknode *node;
+	struct owl_clocknode *parent;
+	unsigned long parentfreq;
+
+	node = &clocks[clock];
+	if (node->changed) {
+		if (node->type == TYPE_PLL || node->type == TYPE_STATIC) {
+			node->changed = 0;
+			return;
+		}
+		parent = node->parent;
+		if (parent) {
+			if (parent->changed && parent->type == TYPE_DYNAMIC) {
+				calcfrequency(parent->id);
+			}
+			parentfreq = parent->frequency;
+			if (node->multipler) {
+				parentfreq *= node->multipler;
+			}
+			if (node->divider) {
+				parentfreq /= node->divider;
+			}
+
+			node->frequency = parentfreq;
+			node->changed = 0;
+		}
+	}
+}
+
+
+static void  pllsub_putaway(int pllclock)
+{
+	struct owl_clocknode *pll;
+	struct owl_clocknode *subnode;
+
+	if (pllclock >= CLOCK__COREPLL && pllclock <= CLOCK__ETHERNETPLL) {
+		pll = &clocks[pllclock];
+		if (pll->type != TYPE_PLL) {
+			return;
+		}
+
+		if (pllclock == CLOCK__DEVPLL) {
+			if (pll == clocks[CLOCK__DEV_CLK].parent) {
+				subnode = clocks[CLOCK__DEV_CLK].sub;
+				while (subnode != NULL) {
+					if (subnode->putaway_enabled && subnode->putaway_sel != subnode->source_sel) {
+						if (subnode->putaway_sel == -1)
+							subnode->putaway_sel = subnode->divsel;
+
+						if (subnode->putaway_divsel > subnode->divsel)
+							write_clkreg_val(subnode->actdiv->reg, subnode->putaway_sel);
+
+						write_clkreg_val(subnode->reg_srcsel, subnode->putaway_sel);
+
+						if (subnode->putaway_divsel < subnode->divsel)
+							write_clkreg_val(subnode->actdiv->reg, subnode->putaway_sel);
+
+						if (subnode->putback_divsel >= 0) {
+							subnode->divsel = subnode->putback_divsel;
+							subnode->putback_divsel = -1;
+							subnode->changed = 1;
+						}
+
+                        printk("putaway clock %s from %s to %s\n", subnode->name,
+                        	clocks[subnode->source_av[subnode->source_sel]].name,
+                        	clocks[subnode->source_av[subnode->putaway_sel]].name);
+					}
+
+					subnode = subnode->next;
+				}
+			}
+		}
+
+		switch (pllclock) {
+		case CLOCK__COREPLL:
+		case CLOCK__DEVPLL:
+		case CLOCK__DDRPLL:
+		case CLOCK__NANDPLL:
+		case CLOCK__DISPLAYPLL:
+			subnode = pll->sub;
+			while (subnode != NULL) {
+				if (subnode->putaway_enabled && subnode->putaway_sel != subnode->source_sel) {
+					if (subnode->putaway_sel == -1)
+						subnode->putaway_sel = subnode->divsel;
+
+					if (subnode->putaway_divsel > subnode->divsel)
+						write_clkreg_val(subnode->actdiv->reg, subnode->putaway_sel);
+							
+					write_clkreg_val(subnode->reg_srcsel, subnode->putaway_sel);
+
+					if (subnode->putaway_divsel < subnode->divsel)
+						write_clkreg_val(subnode->actdiv->reg, subnode->putaway_sel);
+
+					if (subnode->putback_divsel >= 0) {
+						subnode->divsel = subnode->putback_divsel;
+						subnode->putback_divsel = -1;
+						subnode->changed = 1;
+					}
+
+                    printk("putaway clock %s from %s to %s\n", subnode->name,
+                    	clocks[subnode->source_av[subnode->source_sel]].name,
+                    	clocks[subnode->source_av[subnode->putaway_sel]].name);
+				}
+
+				subnode = subnode->next;
+			}
+			break;
+
+		default:
+			break;
+		}
+	}
+}
+
+static void  pllsub_resume(int pllclock)
+{
+	struct owl_clocknode *pll;
+	struct owl_clocknode *subnode;
+
+	if (pllclock >= CLOCK__COREPLL && pllclock <= CLOCK__ETHERNETPLL) {
+		pll = &clocks[pllclock];
+		if (pll->type != TYPE_PLL) {
+			return;
+		}
+		switch (pllclock) {
+		case CLOCK__COREPLL:
+		case CLOCK__DEVPLL:
+		case CLOCK__DDRPLL:
+		case CLOCK__NANDPLL:
+		case CLOCK__DISPLAYPLL:
+			subnode = pll->sub;
+			while (subnode != NULL) {
+				if (subnode->putaway_enabled && subnode->putaway_sel != subnode->source_sel) {
+					if (subnode->divsel > subnode->putaway_divsel)
+						write_clkreg_val(subnode->actdiv->reg, subnode->divsel);
+							
+					write_clkreg_val(subnode->reg_srcsel, subnode->source_sel);
+
+					if (subnode->divsel < subnode->putaway_divsel)
+						write_clkreg_val(subnode->actdiv->reg, subnode->divsel);
+
+					subnode->putaway_divsel = -1;
+
+                    printk("restored clock %s from %s to %s\n", subnode->name,
+                    	clocks[subnode->source_av[subnode->putaway_sel]].name,
+                    	clocks[subnode->source_av[subnode->source_sel]].name);
+				}
+
+				subnode = subnode->next;
+			}
+			break;
+
+		default:
+			break;
+		}
+
+		if (pllclock == CLOCK__DEVPLL) {
+			if (pll == clocks[CLOCK__DEV_CLK].parent) {
+				subnode = clocks[CLOCK__DEV_CLK].sub;
+				while (subnode != NULL) {
+					if (subnode->putaway_enabled && subnode->putaway_sel != subnode->source_sel) {
+						if (subnode->divsel > subnode->putaway_divsel)
+							write_clkreg_val(subnode->actdiv->reg, subnode->divsel);
+							
+						write_clkreg_val(subnode->reg_srcsel, subnode->source_sel);
+
+						if (subnode->divsel < subnode->putaway_divsel)
+							write_clkreg_val(subnode->actdiv->reg, subnode->divsel);
+
+						subnode->putaway_divsel = -1;
+
+                        printk("restored clock %s from %s to %s\n", subnode->name,
+                        	clocks[subnode->source_av[subnode->putaway_sel]].name,
+                        	clocks[subnode->source_av[subnode->source_sel]].name);
+					}
+
+					subnode = subnode->next;
+				}
+			}
+		}
+	}
+}
+
+static int setpll(int clock, int freq)
+{
+	int pll;
+	int index;
+	struct owl_pll *node;
+
+	if (clock >= 0 && clock < CLOCK__MAX) {
+		if (clocks[clock].type == TYPE_PLL) {
+			pll = clock - CLOCK__COREPLL;
+			if (pll < 0 || pll >= PLL__MAX) {
+				goto fail;
+			}
+			node = &pllnode[pll];
+			switch (node->type) {
+			case PLL_T_STEP:
+			case PLL_T_D4DYN:
+				index = (freq / node->freq.step.step) - node->freq.step.offset;
+				if ((node->freq.step.step + node->freq.step.offset) * index != freq) {
+					goto fail;
+				}
+				if (index < node->range_from) {
+					goto fail;
+				}
+				if (index > node->range_to) {
+					goto fail;
+				}
+				node->sel = index;
+				break;
+			case PLL_T_FREQ:
+				for (index = node->range_from; index <= node->range_to; index++) {
+					if (node->freq.freqtab[index] == freq) {
+						goto found;
+					}
+				}
+				goto fail;
+
+				found:
+				node->sel = index;
+				break;
+			default:
+				break;
+			}
+			if (clocks[clock].frequency == freq) {
+				return 0;
+			}
+
+			if (node->reg_pllfreq) {
+				pllsub_putaway(clock);
+				write_clkreg_val(node->reg_pllfreq, node->sel);
+
+				if (node->delay == 0)
+					udelay(PLLDELAY);
+				else
+					udelay(node->delay);
+				pllsub_resume(clock);
+			}
+
+			clocks[clock].frequency = freq;
+			changeclock(clock);
+			if (pll == PLL__TVOUTPLL) {
+				pllnode[PLL__DEEPCOLORPLL].freq.step.step =  freq / 4;
+				clocks[CLOCK__DEEPCOLORPLL].frequency =
+					pllnode[PLL__DEEPCOLORPLL].freq.step.step
+					* pllnode[PLL__DEEPCOLORPLL].sel;
+				clocks[CLOCK__DEEPCOLORPLL].changed = 0;
+			}
+			return 0;
+		}
+	}
+fail:
+	return -1;
+}
+
+int setcorepll(int clock, int freq)
+{
+	int pll;
+	int index;
+	struct owl_pll *node;
+	struct owl_clocknode *core_clk;
+	int swap;
+	unsigned long flags;
+
+	if (clock == CLOCK__COREPLL) {
+		if (clocks[clock].frequency == freq) {
+			return 0;
+		}
+
+		pll = clock - CLOCK__COREPLL;
+		if (pll != 0) {
+			goto fail;
+		}
+		node = &pllnode[pll];
+
+		index = freq / node->freq.step.step;
+		if (node->freq.step.step * index != freq) {
+			goto fail;
+		}
+		if (index < node->range_from) {
+			goto fail;
+		}
+		if (index > node->range_to) {
+			index = node->range_to;
+			goto fail;
+		}
+		node->sel = index;
+
+		spin_lock_irqsave(&cpu_lock, flags);
+
+		core_clk = &clocks[CLOCK__CORE_CLK];
+		swap = 0;
+		if (core_clk->parent == &clocks[clock]) {
+			sourcesel(CLOCK__CORE_CLK, COREPLL_CHANGE_MIDDLE_CLK);
+			swap = 1;
+		}
+
+		if (node->reg_pllfreq) {
+			write_clkreg_val(node->reg_pllfreq, node->sel);
+			if (node->delay == 0)
+				udelay((PLLDELAY+COREPLL_CHANGE_DELAY_DIV-1)/COREPLL_CHANGE_DELAY_DIV);
+			else
+				udelay((node->delay+COREPLL_CHANGE_DELAY_DIV-1)/COREPLL_CHANGE_DELAY_DIV);
+		}
+
+		clocks[clock].frequency = freq;
+		changeclock(clock);
+
+		if (swap) {
+			sourcesel(CLOCK__CORE_CLK, CLOCK__COREPLL);
+		}
+
+		spin_unlock_irqrestore(&cpu_lock, flags);
+		return 0;
+	}
+fail:
+	return -1;
+}
+
+static int setdivider(int clock, int divider, int multipler)
+{
+	int sel;
+	int divexp;
+	int clocksync;
+	struct owl_clkreq *reg;
+
+	if (clock >= 0 && clock < CLOCK__MAX) {
+		if (clocks[clock].type == TYPE_DYNAMIC) {
+			if (clocks[clock].actdiv) {
+				if (multipler) {
+					divexp = multipler << 16 | divider;
+				} else {
+					divexp = divider;
+				}
+
+				sel = getdivider_index(clocks[clock].actdiv, divexp);
+				if (sel >= 0) {
+					clocks[clock].divider = divider;
+					clocks[clock].multipler = multipler;
+					clocks[clock].divsel = sel;
+
+					reg = clocks[clock].actdiv->reg;
+					write_clkreg_val(reg, sel);
+
+					changeclock(clock);
+
+					switch (clock) {
+					case CLOCK__CLK_TMDS:
+						clocksync = CLOCK__CLK_PIXEL;
+						goto share_divider_sync;
+					case CLOCK__CLK_PIXEL:
+						clocksync = CLOCK__CLK_TMDS;
+						goto share_divider_sync;
+					default:
+						break;
+					share_divider_sync:
+						clocks[clocksync].divider = divider;
+						clocks[clocksync].multipler = multipler;
+						clocks[clocksync].divsel = sel;
+						changeclock(clocksync);
+					}
+				} else {
+					return -1;
+				}
+			}
+		}
+		return 0;
+	}
+	return -1;
+}
+
+static int clocksel(int clock, int src)
+{
+	int ret;
+
+	if (clock >= 0 && clock < CLOCK__MAX && src >= 0 && src < CLOCK__MAX) {
+		ret = sourcesel(clock, src);
+		return ret;
+	}
+	return -1;
+}
+
+
+/*
+ * clk_ops function imp
+ */
+static unsigned long clkops_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	unsigned long rate;
+	int divider;
+	int multipler;
+	struct owl_div;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+	if (clock >= 0 && clock < CLOCK__MAX) {
+		if (clocks[clock].changed) {
+			calcfrequency(clock);
+		}
+
+		divider = clocks[clock].divider;
+		multipler = clocks[clock].multipler;
+		rate = parent_rate / divider;
+		if (multipler) {
+			rate *= multipler;
+		}
+		return rate;
+	}
+
+	/* fail */
+	return 0;
+}
+
+static long clkops_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate)
+{
+	static int pro_clk_divisor_3x[4] = {3, 4, 6, 12};
+	int index;
+	struct owl_div *div;
+	int divider;
+	int divexp, restnum, divnum, mulnum;
+	int multipler = 0;
+	int ret = -1;
+	int parent;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (clock >= 0 && clock < CLOCK__MAX && clocks[clock].type == TYPE_DYNAMIC) {
+		div = clocks[clock].actdiv;
+		if (!div)
+			goto error;
+
+		if (clocks[clock].changed) {
+			calcfrequency(clock);
+		}
+
+		if (!clocks[clock].parent)
+			goto error;
+
+		parent =  clocks[clock].parent->frequency;
+
+		if (clock == CLOCK__PRO_CLK)
+			goto pro_clk;
+
+		if (rate == 0) {
+			pr_err("ERROR: requesting clock rate 0Hz");
+			goto error;
+		}
+		divexp = parent / rate;
+		restnum = parent - (rate * divexp);
+		if(restnum != 0) {
+			divnum = parent / restnum;
+			if(restnum * divnum != parent)
+				goto other;
+			mulnum = rate / restnum;
+			if(restnum * mulnum != rate)
+				goto other;
+			divexp = mulnum << 16 | divnum;
+		} 
+other:
+		if ((divexp & 0xffff0000) == 0 && parent > divexp * (rate + 1))
+			divexp++;
+
+		divider = getdivider_ge(div, divexp);
+		if (divider > 0) {
+			if (divider & 0xffff0000) {
+				multipler = divider >> 16;
+				divider &= 0xffff;
+				return parent / divider * multipler;
+			}
+			return parent / divider;
+		} else {
+			ret = -1;
+			goto error;
+		}
+	}
+	parent = 0;
+pro_clk:
+	divexp = parent * 3 / rate;
+	if (parent * 3 > divexp * rate)
+		divexp++;
+
+	for (index = 0; index < 4; index++) {
+		if (pro_clk_divisor_3x[index] >= divexp)
+			break;
+	}
+	if (index < 4) {
+		divider = pro_clk_divisor_3x[index];
+		multipler = 3;
+		return parent * multipler / divider;
+	} else {
+		ret = -1;
+	}
+error:
+	if (ret < 0) {
+		ret = 0;
+	}
+	return ret;
+}
+
+static int  clkops_set_parent(struct clk_hw *hw, unsigned char index)
+{
+	int ret;
+	int clock;
+	int src;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (index < clocks[clock].source_lim) {
+		src = clocks[clock].source_av[index];
+		ret = clocksel(clock, src);
+		if (ret < 0) {
+			ret = -ENOENT;
+		}
+		return ret;
+	}
+	ret = -ENOENT;
+	return ret;
+}
+
+static unsigned char clkops_get_parent(struct clk_hw *hw)
+{
+	int ret = -1;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (clock >= 0 && clock < CLOCK__MAX) {
+		ret = clocks[clock].source_sel;
+	}
+	if (ret < 0) {
+		ret = -ENOENT;
+	}
+	return ret;
+}
+
+static int  clkops_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)
+{
+	int index;
+	struct owl_div *div;
+	int divider;
+	int multipler = 0;
+	int ret = -1;
+	int divexp, restnum, divnum, mulnum;
+	int parent;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (clock >= 0 && clock < CLOCK__MAX && clocks[clock].type == TYPE_DYNAMIC) {
+		div = clocks[clock].actdiv;
+		if (!div)
+			goto error;
+
+		if (clocks[clock].changed) {
+			calcfrequency(clock);
+		}
+		if (!clocks[clock].parent)
+			goto error;
+		parent =  clocks[clock].parent->frequency;
+		if (rate == 0) {
+			pr_err("ERROR: requesting clock rate 0Hz");
+			goto error;
+		}
+		divexp = parent / rate;
+		restnum = parent - (rate * divexp);
+		if(restnum != 0) {
+			divnum = parent / restnum;
+			if(restnum * divnum != parent)
+				goto divint;
+			mulnum = rate / restnum;
+			if(restnum * mulnum != rate)
+				goto divint;
+			divexp = mulnum << 16 | divnum;
+		}
+divint:
+
+		index = getdivider_index(div, divexp);
+		if (index >= 0) {
+			divider = getdivider(div, index);
+			if (divider <= 0)
+				goto error;
+
+			if (divider > 0 && (divider & 0xffff0000)) {
+				multipler = divider >> 16;
+				divider &= 0xffff;
+			}
+			ret = setdivider(clock, divider, multipler);
+			if (ret == 0) {
+				calcfrequency(clock);
+			}
+		}
+	}
+error:
+	if (ret < 0) {
+		ret = -ENOENT;
+	}
+	return ret;
+}
+
+static long parent_round_rate(int clock, unsigned long rate, unsigned long *best_parent)
+{
+	struct clk *parent;
+	int index;
+	long l;
+
+	index = clocks[clock].source_av[clocks[clock].source_sel];
+	parent = owl_clks[index];
+
+	if (__clk_get_ops(parent)->round_rate) {
+		l = __clk_get_ops(parent)->round_rate(__clk_get_hw(parent), rate, best_parent);
+		return l;
+	}
+	if (clocks[index].changed) {
+		calcfrequency(index);
+	}
+	l =  clocks[index].frequency;
+	return l;
+}
+
+static long clkops_b_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate)
+{
+	struct owl_div *div;
+	struct owl_div tmpdiv;
+	struct owl_refertab tab;
+	int divider;
+	int multipler;
+	int dividerlim;
+	int i;
+	int ret = -1;
+	int clock;
+	struct owl_clk_info *info;
+	unsigned long bp;
+	unsigned long best = 0;
+	unsigned long best_parent;
+	unsigned long tmp;
+
+	if (parent_rate == NULL) {
+		return clkops_round_rate(hw, rate, NULL);
+	}
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (clock >= 0 && clock < CLOCK__MAX && clocks[clock].type == TYPE_DYNAMIC) {
+
+		div = clocks[clock].actdiv;
+		if (!div) {
+			tmpdiv.type = DIV_T_TABLE;
+			tmpdiv.range_from = 0;
+			tmpdiv.range_to = 0;
+			tmpdiv.ext.tab = &tab;
+			tmpdiv.ext.tab->div[0] = clocks[clock].divider;
+			div = &tmpdiv;
+		}
+
+		if (rate == 0) {
+			pr_err("ERROR: requesting clock rate 0Hz");
+			goto error;
+		}
+		i = 0;
+		dividerlim = 0xffffffff / rate;
+		divider = getdivider(div, i);
+		while (divider > 0) {
+			unsigned long pr;
+			unsigned long pr_want;
+
+			multipler = divider >> 16;
+			if (multipler == 0 &&  divider > dividerlim)
+				break;
+			if (multipler > 0) {
+				divider &=  0xffff;
+				if (divider > dividerlim * multipler)
+					break;
+			}
+
+			if (multipler == 0) {
+				pr_want = rate * divider + divider - 1;
+				pr = parent_round_rate(clock, pr_want, &bp);
+				tmp = pr / divider;
+			} else {
+				pr_want = rate / multipler * divider + divider / multipler;
+				pr_want += rate % multipler * divider / multipler;
+				pr = parent_round_rate(clock, pr_want, &bp);
+				tmp = pr / divider * multipler;
+			}
+
+			if (tmp >= best && tmp <= rate) {
+				best = tmp;
+				best_parent = pr;
+			}
+
+			i++;
+			divider = getdivider(div, i);
+		}
+		if (best > 0) {
+			ret = best;
+			*parent_rate = best_parent;
+		}
+	}
+
+error:
+	if (ret < 0) {
+		ret = 0;
+	}
+	return ret;
+}
+
+static unsigned long best_newrate(struct owl_clocknode *node, unsigned long parent_rate)
+{
+	int nextdiv;
+	int lookup;
+	int divider;
+	int multipler;
+	unsigned long rate;
+	unsigned long bestrate;
+
+	bestrate = parent_rate/node->divider;
+	if (node->actdiv == NULL) {
+		return bestrate;
+	}
+
+	if (node->id == CLOCK__PRO_CLK) {
+		for (lookup = 0; ; lookup++) {
+			divider = getdivider(node->actdiv, lookup);
+			if (divider < 0) {
+				goto over;
+			}
+			multipler = divider >> 16;
+			if (multipler > 0) {
+				divider &= 0xffff;
+			} else {
+				multipler = 1;
+			}
+
+			rate = parent_rate / divider * multipler;
+			if (node->frequency <= bestrate && rate < bestrate) {
+				bestrate = rate;
+			} else if (bestrate <= rate && rate < node->frequency) {
+				bestrate = rate;
+			}
+		}
+		goto over;
+	}
+
+	nextdiv = parent_rate/node->frequency;
+
+	if (nextdiv > node->divider) {
+		for (lookup = node->divsel + 1; ; lookup++) {
+			divider = getdivider(node->actdiv, lookup);
+			if (divider < 0) {
+				goto over;
+			}
+			multipler = divider >> 16;
+			if (multipler > 0) {
+				divider &= 0xffff;
+			} else {
+				multipler = 1;
+			}
+
+			rate = parent_rate / divider * multipler;
+			if (rate >= node->frequency && rate < bestrate) {
+				bestrate = rate;
+			} else {
+				bestrate = rate;
+				goto over;
+			}
+		}
+	} else if (nextdiv < node->divider) {
+		for (lookup = node->divsel - 1; lookup >= 0; lookup--) {
+			divider = getdivider(node->actdiv, lookup);
+			if (divider < 0) {
+				goto over;
+			}
+			multipler = divider >> 16;
+			if (multipler > 0) {
+				divider &= 0xffff;
+			} else {
+				multipler = 1;
+			}
+
+			rate = parent_rate / divider * multipler;
+			if (rate <= node->frequency && rate > bestrate) {
+				bestrate = rate;
+			} else {
+				goto over;
+			}
+		}
+	}
+
+over:
+	return bestrate;
+}
+
+static unsigned long clkops_b_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	unsigned long rate;
+	int divider;
+	int multipler;
+	struct owl_div;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+	if (clock >= 0 && clock < CLOCK__MAX) {
+		if (clocks[clock].changed) {
+			calcfrequency(clock);
+		}
+
+		if (clocks[clock].parent->frequency != parent_rate) {
+			/* shall never be used on float divisor */
+			return best_newrate(&clocks[clock], parent_rate);
+		}
+
+		divider = clocks[clock].divider;
+		multipler = clocks[clock].multipler;
+
+		rate = parent_rate / divider;
+		if (multipler) {
+			rate *= multipler;
+		}
+		return rate;
+	}
+
+	/* fail */
+	return 0;
+}
+
+
+static int  pllops_enable(struct clk_hw *hw)
+{
+	int pll;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (clock >= 0 && clock < CLOCK__MAX && clocks[clock].type == TYPE_PLL) {
+		pll = clock - CLOCK__COREPLL;
+		if (pll >= 0 && pll < PLL__MAX) {
+			write_clkreg_val(pllnode[pll].reg_pllen, 1);
+			if (pllnode[pll].delay == 0)
+				udelay(PLLDELAY);
+			else
+				udelay(pllnode[pll].delay);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+static void pllops_disable(struct clk_hw *hw)
+{
+	int pll;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (clock >= 0 && clock < CLOCK__MAX && clocks[clock].type == TYPE_PLL) {
+		pll = clock - CLOCK__COREPLL;
+		if (pll >= 0 && pll < PLL__MAX) {
+			write_clkreg_val(pllnode[pll].reg_pllen, 0);
+		}
+	}
+}
+
+static int  pllops_is_enabled(struct clk_hw *hw)
+{
+	int pll;
+	int ret;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (clock >= 0 && clock < CLOCK__MAX && clocks[clock].type == TYPE_PLL) {
+		pll = clock - CLOCK__COREPLL;
+		if (pll >= 0 && pll < PLL__MAX) {
+			ret = read_clkreg_val(pllnode[pll].reg_pllen);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static unsigned long pllops_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	unsigned long ret;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	ret = clocks[clock].frequency;
+	return ret;
+}
+
+static long pllops_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate)
+{
+	int pll;
+	int index;
+	long best;
+	struct owl_pll *node;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	pll = clock - CLOCK__COREPLL;
+	if (clock >= 0 && clock < CLOCK__MAX && clocks[clock].type == TYPE_PLL) {
+		pll = clock - CLOCK__COREPLL;
+		if (pll >= 0 && pll < PLL__MAX) {
+			node = &pllnode[pll];
+		} else
+			goto error;
+	} else
+		goto error;
+
+	switch (node->type) {
+	case PLL_T_STEP:
+	case PLL_T_D4DYN:
+		index = (rate / node->freq.step.step) - node->freq.step.offset;
+		if (index >= node->range_from && index <= node->range_to) {
+			return (index + node->freq.step.offset) * node->freq.step.step;
+		}
+		if (index > node->range_to) {
+			return (node->range_to + node->freq.step.offset) * node->freq.step.step;
+		}
+		return 0;
+	case PLL_T_FREQ:
+		best = 0;
+		for (index = node->range_from; index <= node->range_to; index++) {
+			if (node->freq.freqtab[index] > best
+				&& node->freq.freqtab[index] < rate) {
+				best = node->freq.freqtab[index];
+			}
+			if (node->freq.freqtab[index] == rate) {
+				return rate;
+			}
+		}
+		if (best > 0) {
+			return best;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+error:
+	return -ENONET;
+}
+
+
+static int  pllops_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)
+{
+	int ret = -1;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (clock >= 0 && clock < CLOCK__MAX && clocks[clock].type == TYPE_PLL) {
+		ret = setpll(clock, rate);
+		if (ret < 0) {
+			ret = -ENOENT;
+		}
+		return ret;
+	}
+	if (ret < 0) {
+		ret = -ENOENT;
+	}
+	return ret;
+}
+
+static int  pllops_corepll_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)
+{
+	int ret = -1;
+	int clock;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	clock = info->clock_id;
+
+	if (clock >= 0 && clock < CLOCK__MAX && clocks[clock].type == TYPE_PLL) {
+		ret = setcorepll(clock, rate);
+		if (ret < 0) {
+			ret = -ENOENT;
+		}
+		return ret;
+	}
+	if (ret < 0) {
+		ret = -ENOENT;
+	}
+	return ret;
+}
+
+static int  modops_enable(struct clk_hw *hw)
+{
+	int ret = -1;
+	int module;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	module  = info->clock_id;
+
+	if (module >= 0 && module < MOD__MAX_IN_CLK) {
+		write_clkreg_val(modnode[module].reg_devclken, 1);
+		ret = 0;
+	}
+	if (ret < 0) {
+		ret = -ENOENT;
+	}
+	return ret;
+}
+
+static void modops_disable(struct clk_hw *hw)
+{
+	int module;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	module  = info->clock_id;
+
+	if (module >= 0 && module < MOD__MAX_IN_CLK) {
+		write_clkreg_val(modnode[module].reg_devclken, 0);
+	}
+}
+
+static int  modops_is_enabled(struct clk_hw *hw)
+{
+	int ret = -1;
+	int module;
+	struct owl_clk_info *info;
+
+	info = to_clk_info(hw);
+	module  = info->clock_id;
+
+	if (module >= 0 && module < MOD__MAX_IN_CLK) {
+		ret = read_clkreg_val(modnode[module].reg_devclken);
+	}
+	if (ret < 0) {
+		ret = 0;
+	}
+	return ret;
+}
+
+
+struct clk_ops clk_ops_corepll = {
+	.prepare = pllops_enable,
+	.unprepare = pllops_disable,
+	.is_enabled = pllops_is_enabled,
+	.recalc_rate = pllops_recalc_rate,
+	.round_rate = pllops_round_rate,
+	.set_rate = pllops_corepll_set_rate,
+};
+
+struct clk_ops clk_ops_pll = {
+	.prepare = pllops_enable,
+	.unprepare = pllops_disable,
+	.is_enabled = pllops_is_enabled,
+	.recalc_rate = pllops_recalc_rate,
+	.round_rate = pllops_round_rate,
+	.set_rate = pllops_set_rate,
+};
+
+struct clk_ops clk_ops_gate_module = {
+	.enable = modops_enable,
+	.disable = modops_disable,
+	.is_enabled = modops_is_enabled,
+};
+
+struct clk_ops clk_ops_direct_s_parent = {
+};
+
+struct clk_ops clk_ops_direct_m_parent = {
+	.set_parent = clkops_set_parent,
+	.get_parent = clkops_get_parent,
+};
+
+struct clk_ops clk_ops_s_divider_s_parent = {
+	.recalc_rate = clkops_recalc_rate,
+};
+
+struct clk_ops clk_ops_s_divider_m_parent = {
+	.recalc_rate = clkops_recalc_rate,
+	.set_parent = clkops_set_parent,
+	.get_parent = clkops_get_parent,
+};
+
+struct clk_ops clk_ops_m_divider_s_parent = {
+	.recalc_rate = clkops_recalc_rate,
+	.round_rate = clkops_round_rate,
+	.set_rate = clkops_set_rate,
+};
+
+struct clk_ops clk_ops_m_divider_m_parent = {
+	.recalc_rate = clkops_recalc_rate,
+	.round_rate = clkops_round_rate,
+	.set_rate = clkops_set_rate,
+	.set_parent = clkops_set_parent,
+	.get_parent = clkops_get_parent,
+};
+
+struct clk_ops clk_ops_foo = {
+};
+
+
+struct clk_ops clk_ops_b_s_divider_s_parent = {
+	.recalc_rate = clkops_b_recalc_rate,
+	.round_rate = clkops_b_round_rate,
+};
+
+struct clk_ops clk_ops_b_s_divider_m_parent = {
+	.recalc_rate = clkops_b_recalc_rate,
+	.round_rate = clkops_b_round_rate,
+	.set_rate = clkops_set_rate,
+	.set_parent = clkops_set_parent,
+	.get_parent = clkops_get_parent,
+};
+
+struct clk_ops clk_ops_b_m_divider_s_parent = {
+	.recalc_rate = clkops_b_recalc_rate,
+	.round_rate = clkops_b_round_rate,
+	.set_rate = clkops_set_rate,
+};
+
+struct clk_ops clk_ops_b_m_divider_m_parent = {
+	.recalc_rate = clkops_b_recalc_rate,
+	.round_rate = clkops_b_round_rate,
+	.set_rate = clkops_set_rate,
+	.set_parent = clkops_set_parent,
+	.get_parent = clkops_get_parent,
+};
+
+
+struct clk_ops clk_ops_h_s_divider_s_parent = {
+	.recalc_rate = clkops_b_recalc_rate,
+	.round_rate = clkops_round_rate,
+};
+
+struct clk_ops clk_ops_h_s_divider_m_parent = {
+	.recalc_rate = clkops_b_recalc_rate,
+	.round_rate = clkops_round_rate,
+	.set_rate = clkops_set_rate,
+	.set_parent = clkops_set_parent,
+	.get_parent = clkops_get_parent,
+};
+
+struct clk_ops clk_ops_h_m_divider_s_parent = {
+	.recalc_rate = clkops_b_recalc_rate,
+	.round_rate = clkops_round_rate,
+	.set_rate = clkops_set_rate,
+};
+
+struct clk_ops clk_ops_h_m_divider_m_parent = {
+	.recalc_rate = clkops_b_recalc_rate,
+	.round_rate = clkops_round_rate,
+	.set_rate = clkops_set_rate,
+	.set_parent = clkops_set_parent,
+	.get_parent = clkops_get_parent,
+};
+
+static struct clk_lookup cl_smp_twd = {
+	.dev_id = "smp_twd",
+};
+
+int owl_pllsub_set_putaway(int clock, int source)
+{
+	struct owl_clocknode *node;
+	int i;
+
+	if (clock < 0 || clock > CLOCK__MAX)
+		return -1;
+
+	node = &clocks[clock];
+	if (source == -1) {
+		node->putaway_enabled = 0;
+	} else {
+		for (i = 0; i < node->source_lim; i++) {
+			if (node->source_av[i] == source) {
+				node->putaway_sel = i;
+				node->putaway_enabled = 1;
+				node->putaway_divsel = -1;
+				node->putback_divsel = -1;
+				return 0;
+			}
+		}
+		return -1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(owl_pllsub_set_putaway);
+
+
+unsigned long owl_get_putaway_parent_rate(struct clk *clk)
+{
+	struct owl_clk_info *info;
+	struct owl_clocknode *node;
+	int away_parent_clock;
+
+	info = to_clk_info(__clk_get_hw(clk));
+	if (info->clock_id >= CLOCK__MAX)
+		return 0;
+
+	node = &clocks[info->clock_id];
+
+	if (node->putaway_enabled) {
+		away_parent_clock = node->source_av[node->putaway_sel];
+
+		if (clocks[away_parent_clock].changed)
+			calcfrequency(away_parent_clock);
+
+		return clocks[away_parent_clock].frequency;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(owl_get_putaway_parent_rate);
+
+
+unsigned long owl_getparent_newrate(struct clk *clk)
+{
+	if (__clk_get_parent(clk))
+		return __clk_get_newrate(__clk_get_parent(clk));
+
+	return 0;
+}
+EXPORT_SYMBOL(owl_getparent_newrate);
+
+
+int owl_getdivider_index(struct clk *clk, int divexp)
+{
+	struct owl_clk_info *info;
+	struct owl_clocknode *node;
+	int index;
+
+	info = to_clk_info(__clk_get_hw(clk));
+	if (info->clock_id >= CLOCK__MAX)
+		return -1;
+
+	node = &clocks[info->clock_id];
+	index = getdivider_index(node->actdiv, divexp);
+	return index;
+}
+EXPORT_SYMBOL(owl_getdivider_index);
+
+
+int owl_set_putaway_divsel(struct clk *clk, int tmp_divsel, int new_divsel)
+{
+	struct owl_clk_info *info;
+	struct owl_clocknode *node;
+	
+	info = to_clk_info(__clk_get_hw(clk));
+	if (info->clock_id>= CLOCK__MAX)
+		return -1;
+
+	node = &clocks[info->clock_id];
+	node->putaway_divsel = tmp_divsel;
+	node->putback_divsel = new_divsel;
+	
+	if (node->putaway_enabled)
+		return 0;
+	
+	return -1;
+}
+EXPORT_SYMBOL(owl_set_putaway_divsel);
+
+
+void owl_update_notify_newrate(struct clk *clk, unsigned long newrate)
+{
+	clk_set_rate(clk, newrate);
+}
+EXPORT_SYMBOL(owl_update_notify_newrate);
+
+
+int module_clk_enable(int mod_id)
+{
+	if (mod_id >= 0 && mod_id < MOD__MAX) {
+		if (modnode[mod_id].reg_devclken) {
+			write_clkreg_val(modnode[mod_id].reg_devclken, 1);
+		}
+		return 0;
+	}
+	return -1;
+}
+EXPORT_SYMBOL(module_clk_enable);
+
+int module_clk_disable(int mod_id)
+{
+	if (mod_id >= 0 && mod_id < MOD__MAX) {
+		if (modnode[mod_id].reg_devclken) {
+			write_clkreg_val(modnode[mod_id].reg_devclken, 0);
+		}
+		return 0;
+	}
+	return -1;
+}
+EXPORT_SYMBOL(module_clk_disable);
+
+static int __module_reset(int mod_id, int holding, int holding_assert)
+{
+	if (mod_id >= 0 && mod_id < MOD__MAX) {
+		if (modnode[mod_id].reg_devrst) {
+
+			if (!holding || holding_assert) {
+				write_clkreg_val(modnode[mod_id].reg_devrst, 0);
+				read_clkreg_val(modnode[mod_id].reg_devrst);
+//				mdelay(MODULE_RESET_TIME_MS);
+			}
+
+			if (!holding || !holding_assert) {
+				write_clkreg_val(modnode[mod_id].reg_devrst, 1);
+				read_clkreg_val(modnode[mod_id].reg_devrst);
+//				mdelay(MODULE_RESET_TIME_MS);
+			}
+
+		}
+		return 0;
+	}
+	return -1;
+}
+
+int module_reset(int modid)
+{
+	return __module_reset(modid, 0, 0);
+}
+EXPORT_SYMBOL(module_reset);
+
+int owl_module_reset_assert(int modid)
+{
+	return __module_reset(modid, 1, 1);
+}
+EXPORT_SYMBOL(owl_module_reset_assert);
+
+int owl_module_reset_deassert(int modid)
+{
+	return __module_reset(modid, 1, 0);
+}
+EXPORT_SYMBOL(owl_module_reset_deassert);
+
+static struct clk_ops *clkops_select_version(const struct clk_ops *ops, int version)
+{
+	static struct clk_ops *tab[4][3] = {
+		{&clk_ops_s_divider_s_parent, &clk_ops_b_s_divider_s_parent, &clk_ops_h_s_divider_s_parent},
+		{&clk_ops_s_divider_m_parent, &clk_ops_b_s_divider_m_parent, &clk_ops_h_s_divider_m_parent},
+		{&clk_ops_m_divider_s_parent, &clk_ops_b_m_divider_s_parent, &clk_ops_h_m_divider_s_parent},
+		{&clk_ops_m_divider_m_parent, &clk_ops_b_m_divider_m_parent, &clk_ops_h_m_divider_m_parent},
+	};
+
+	int i;
+	for (i = 0; i < sizeof(tab) / sizeof(tab[0]); i++) {
+		if (ops == tab[i][0] || ops == tab[i][1] || ops == tab[i][2]) {
+			if (version == 0) {
+				return tab[i][0];
+			} else if (version == 1) {
+				return tab[i][1];
+			} else if (version == 2) {
+				return tab[i][2];
+			}
+			return NULL;
+		}
+	}
+	return NULL;
+}
+
+
+int owl_clk_config_recursion(int clock, int recursion)
+{
+	const struct clk_ops *ops;
+	if (clock >= 0 && clock <= CLOCK__MAX) {
+		ops = __clk_get_ops(owl_clks[clock]);
+		if (ops == &clk_ops_direct_s_parent || ops == &clk_ops_direct_m_parent) {
+			if (recursion) {
+				__clk_set_flags(owl_clks[clock], __clk_get_flags(owl_clks[clock]) | CLK_SET_RATE_PARENT);
+			} else {
+				__clk_set_flags(owl_clks[clock], __clk_get_flags(owl_clks[clock]) & ~CLK_SET_RATE_PARENT);
+			}
+			return 0;
+		}
+
+		ops = clkops_select_version(__clk_get_ops(owl_clks[clock]), recursion);
+		if (ops == NULL) {
+			return -1;
+		}
+		if (ops == __clk_get_ops(owl_clks[clock])) {
+			return 0;
+		}
+		if (recursion == 1) {
+			__clk_set_flags(owl_clks[clock], __clk_get_flags(owl_clks[clock]) | CLK_SET_RATE_PARENT);
+		} else {
+			__clk_set_flags(owl_clks[clock], __clk_get_flags(owl_clks[clock]) & ~CLK_SET_RATE_PARENT);
+		}
+		__clk_set_ops(owl_clks[clock], ops);
+		return 0;
+	}
+	return -1;
+}
+EXPORT_SYMBOL(owl_clk_config_recursion);
+
+static void __init init_clocktree(struct device_node *cum_node)
+{
+    struct clocks_table *clks_table;
+
+	if (of_machine_is_compatible("actions,atm7059a")) {
+        clks_table = atm7059_get_clocktree();
+        clocks = clks_table->clocks;
+        rvregs = clks_table->rvregs;
+        pllnode = clks_table->pllnode;
+        owl_clks = clks_table->owl_clks;
+        modnode = clks_table->modnode;
+        clk_foo_clocks = clks_table->clk_foo_clocks;
+        lookup_table = clks_table->lookup_table;
+
+	atm7059_init_clocktree(cum_node);
+    }
+}
+
+static int owl_limit_notify(struct notifier_block *nb, unsigned long action, void *data)
+{
+	struct clk_notifier_data *cnd;
+	struct owl_clk_info *info;
+	int clock;
+
+	if (action == PRE_RATE_CHANGE) {
+		cnd = data;
+		info = to_clk_info(__clk_get_hw(cnd->clk));
+		clock = info->clock_id;
+
+		if (clock == CLOCK__NIC_CLK) {
+			if (cnd->new_rate > 300 * MEGA) {
+				printk("NIC_CLK is too fast to set to %lu!\n", cnd->new_rate);
+				return NOTIFY_BAD;
+			} else if (cnd->new_rate > 250 * MEGA) {
+				printk("warning: NIC_CLK is set to %lu!\n", cnd->new_rate);
+			} else if (cnd->new_rate < 180 * MEGA) {
+				printk("warning: NIC_CLK is set to %lu!\n", cnd->new_rate);
+			}
+		} else if (clock == CLOCK__NIC_DIV_CLK) {
+			if (cnd->new_rate > 150 * MEGA) {
+				printk("NIC_DIV_CLK cannot be set to %lu!\n", cnd->new_rate);
+				return NOTIFY_BAD;
+			}
+		} else if (clock == CLOCK__H_CLK) {
+			if (cnd->new_rate > 125 * MEGA) {
+				printk("H_CLK cannot be set to %lu!\n", cnd->new_rate);
+				return NOTIFY_BAD;
+			} else if (cnd->new_rate > 100 * MEGA) {
+				printk("warning: H_CLK is set to %lu\n", cnd->new_rate);
+			}
+		}
+	} else if (action == POST_RATE_CHANGE) {
+		cnd = data;
+		info = to_clk_info(__clk_get_hw(cnd->clk));
+		clock = info->clock_id;
+
+		if (clock == CLOCK__APBDBG_CLK
+			|| clock == CLOCK__ACP_CLK
+			|| clock == CLOCK__PERIPH_CLK) {
+			if (clocks[CLOCK__APBDBG_CLK].divider != 8
+				|| clocks[CLOCK__ACP_CLK].divider != 4
+				|| clocks[CLOCK__PERIPH_CLK].divider != 8) {
+				printk("clocktree: WARNING! ...................\n");
+				printk("APBDBG_CLK: ACP_CLK: PERIPH_CLK\n");
+				printk("should be /8   /4   /8\n");
+				printk("but is set to /%d  /%d  /%d\n",
+					clocks[CLOCK__APBDBG_CLK].divider,
+					clocks[CLOCK__ACP_CLK].divider,
+					clocks[CLOCK__PERIPH_CLK].divider);
+			}
+		}
+	}
+
+	return NOTIFY_OK;
+}
+
+static int pll_in_change;
+
+static int owl_pll_notify(struct notifier_block *nb, unsigned long action, void *data)
+{
+
+	if (action == PRE_RATE_CHANGE)
+		pll_in_change = 1;
+	else
+		pll_in_change = 0;
+
+	return NOTIFY_OK;
+}
+
+int owl_pll_in_change(void)
+{
+	return pll_in_change;
+}
+
+EXPORT_SYMBOL(owl_pll_in_change);
+
+
+static struct {
+	struct notifier_block nic_clk;
+	struct notifier_block apbdbg_clk;
+	struct notifier_block acp_clk;
+	struct notifier_block periph_clk;
+	struct notifier_block h_clk;
+
+	struct notifier_block devpll;
+	struct notifier_block displaypll;
+	struct notifier_block tvoutpll;
+	struct notifier_block deepcolorpll;
+	struct notifier_block audiopll;
+} owl_clk_nb  = {
+	{ .notifier_call = owl_limit_notify, },
+	{ .notifier_call = owl_limit_notify, },
+	{ .notifier_call = owl_limit_notify, },
+	{ .notifier_call = owl_limit_notify, },
+	{ .notifier_call = owl_limit_notify, },
+
+	{ .notifier_call = owl_pll_notify, },
+	{ .notifier_call = owl_pll_notify, },
+	{ .notifier_call = owl_pll_notify, },
+	{ .notifier_call = owl_pll_notify, },
+	{ .notifier_call = owl_pll_notify, },
+};
+
+static void __init prepare_clocktree(void)
+{
+	if (of_machine_is_compatible("actions,atm7059a")) {
+		atm7059_prepare_clocktree();
+	}
+}
+
+static void __init owl_init_clocks(struct device_node *cum_node)
+{
+	int i;
+    
+	spin_lock_init(&cpu_lock);
+
+	init_clocktree(cum_node);
+
+	prepare_clocktree();
+
+	for (i = 0; i < CLOCK__MAX; i++) {
+		calcfrequency(i);
+		clk_set_rate(owl_clks[i], clocks[i].frequency);
+	}
+
+	clkdev_add_table(lookup_table, CLOCK__MAX + MOD__MAX_IN_CLK);
+	
+	cl_smp_twd.clk = owl_clks[CLOCK__PERIPH_CLK],
+	clkdev_add(&cl_smp_twd);
+
+	return;
+}
+CLK_OF_DECLARE(s500, "actions,s500-cum", owl_init_clocks);
+
+/* arch_initcall(owl_init_clocks); moved init code to machine .init_early */
+
+static int __init init_notifier(void)
+{
+	clk_notifier_register(owl_clks[CLOCK__NIC_CLK], &owl_clk_nb.nic_clk);
+	clk_notifier_register(owl_clks[CLOCK__APBDBG_CLK], &owl_clk_nb.apbdbg_clk);
+	clk_notifier_register(owl_clks[CLOCK__ACP_CLK], &owl_clk_nb.acp_clk);
+	clk_notifier_register(owl_clks[CLOCK__PERIPH_CLK], &owl_clk_nb.periph_clk);
+	clk_notifier_register(owl_clks[CLOCK__H_CLK], &owl_clk_nb.h_clk);
+
+	clk_notifier_register(owl_clks[CLOCK__DEVPLL], &owl_clk_nb.devpll);
+	clk_notifier_register(owl_clks[CLOCK__DISPLAYPLL], &owl_clk_nb.displaypll);
+	clk_notifier_register(owl_clks[CLOCK__TVOUTPLL], &owl_clk_nb.tvoutpll);
+	clk_notifier_register(owl_clks[CLOCK__DEEPCOLORPLL], &owl_clk_nb.deepcolorpll);
+	clk_notifier_register(owl_clks[CLOCK__AUDIOPLL], &owl_clk_nb.audiopll);
+
+	return 0;
+}
+
+arch_initcall(init_notifier);
+
+/*******************/
+#include <linux/debugfs.h>
+
+static ssize_t corepll_delay_write(struct file *filp, const char __user *buffer,
+        size_t count, loff_t *ppos)
+{
+	unsigned int corepll_delay;
+
+	corepll_delay = simple_strtoul(buffer, NULL, 10);
+
+	pllnode[PLL__COREPLL].delay = corepll_delay;
+
+	return count;
+}
+
+static ssize_t corepll_delay_read(struct file *filp, char __user *buffer,
+        size_t count, loff_t *ppos)
+{
+	printk(KERN_WARNING "core pll delay = %d\n", pllnode[PLL__COREPLL].delay);
+	return 0;
+}
+
+static int corepll_delay_open(struct inode *inode, struct file *filp)
+{
+	filp->private_data = inode->i_private;
+	return 0;
+}
+
+static struct file_operations corepll_delay_fops = {
+	.open = corepll_delay_open,
+	.read = corepll_delay_read,
+	.write = corepll_delay_write,
+};
+
+int __init clocktree_debug_init(void)
+{
+	struct dentry *dir;
+	struct dentry *d;
+
+	dir = debugfs_create_dir("clocktree", NULL);
+	if (!dir)
+		return -ENOMEM;
+
+	d = debugfs_create_file("corepll_delay", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP, dir, NULL,
+		&corepll_delay_fops);
+	if (!d)
+		return -ENOMEM;
+
+	return 0;
+}
+module_init(clocktree_debug_init);
diff --git a/arch/arm/mach-owl/clocktree-owl.h b/arch/arm/mach-owl/clocktree-owl.h
new file mode 100755
index 0000000..ab814a4
--- /dev/null
+++ b/arch/arm/mach-owl/clocktree-owl.h
@@ -0,0 +1,178 @@
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+
+#include <linux/of.h>
+
+#include <mach/hardware.h>
+#include <mach/clkname.h>
+#include <mach/clkname_priv.h>
+#include "clock-owl.h"
+
+#define CLOCKNODE_UNUSED(clock)	\
+	/*[CLOCK__##clock] = */ {\
+		.name = CLKNAME_##clock,\
+		.id = CLOCK__##clock,\
+		.type = TYPE_STATIC,\
+		.source_lim = 0,\
+		.source_sel = -1,\
+		.frequency = 0,\
+		.clock_en = 0,\
+	}
+
+#define PLLNODE(clock, src)	\
+	/*[CLOCK__##clock] = */ {\
+		.name = CLKNAME_##clock,\
+		.id = CLOCK__##clock,\
+		.type = TYPE_PLL,\
+		.source_av = {CLOCK__##src,},\
+		.source_lim = 1,\
+		.source_sel = 0,\
+		.clock_en = 1,\
+	}
+
+#define CLOCKNODE_ROOT(clock, freq)	\
+	/*[CLOCK__##clock] = */ {\
+		.name = CLKNAME_##clock,\
+		.id = CLOCK__##clock,\
+		.type = TYPE_STATIC,\
+		.source_lim = 0,\
+		.source_sel = -1,\
+		.frequency = freq,\
+		.clock_en = 1,\
+	}
+
+#define CLOCKNODE_S1(clock, src)	\
+	/*[CLOCK__##clock] = */ {\
+		.name = CLKNAME_##clock,\
+		.id = CLOCK__##clock,\
+		.type = TYPE_DYNAMIC,\
+		.source_av = {CLOCK__##src,},\
+		.source_lim = 1,\
+		.source_sel = 0,\
+		.clock_en = 1,\
+		.changed = 1,\
+	}
+
+#define CLOCKNODE_S2(clock, src, src2, sel)	\
+	/* [CLOCK__##clock] = */ {\
+		.name = CLKNAME_##clock,\
+		.id = CLOCK__##clock,\
+		.type = TYPE_DYNAMIC,\
+		.source_av = {CLOCK__##src, CLOCK__##src2},\
+		.source_lim = 2,\
+		.source_sel = sel,\
+		.reg_srcsel = &selbit_##clock,\
+		.clock_en = 1,\
+		.changed = 1,\
+	}
+
+#define CLOCKNODE_S3(clock, src, src2, src3, sel)	\
+	/* [CLOCK__##clock] = */ {\
+		.name = CLKNAME_##clock,\
+		.id = CLOCK__##clock,\
+		.type = TYPE_DYNAMIC,\
+		.source_av = {CLOCK__##src, CLOCK__##src2, CLOCK__##src3},\
+		.source_lim = 3,\
+		.source_sel = sel,\
+		.reg_srcsel = &selbit_##clock,\
+		.clock_en = 1,\
+		.changed = 1,\
+	}
+
+#define CLOCKNODE_S4(clock, src, src2, src3, src4, sel)	\
+	/* [CLOCK__##clock] = */ {\
+		.name = CLKNAME_##clock,\
+		.id = CLOCK__##clock,\
+		.type = TYPE_DYNAMIC,\
+		.source_av = {CLOCK__##src, CLOCK__##src2, CLOCK__##src3, CLOCK__##src4},\
+		.source_lim = 4,\
+		.source_sel = sel,\
+		.reg_srcsel = &selbit_##clock,\
+		.clock_en = 1,\
+		.changed = 1,\
+	}
+
+#define CLOCKNODE_S5(clock, src, src2, src3, src4, src5, sel)	\
+	/* [CLOCK__##clock] = */ {\
+		.name = CLKNAME_##clock,\
+		.id = CLOCK__##clock,\
+		.type = TYPE_DYNAMIC,\
+		.source_av = {CLOCK__##src, CLOCK__##src2, CLOCK__##src3, CLOCK__##src4, CLOCK__##src5},\
+		.source_lim = 5,\
+		.source_sel = sel,\
+		.reg_srcsel = &selbit_##clock,\
+		.clock_en = 1,\
+		.changed = 1,\
+	}
+
+#define BITMAP(reg, _mask, _offset) \
+	{\
+		.reg_no = R_##reg, \
+		.reg_hw = (unsigned long *)reg, \
+		.mask = _mask, \
+		.offset = _offset,\
+	}
+
+#define FREQUENCY_24M	(24 * 1 * MEGA)
+#define FREQUENCY_32K	(32 * 1 * KILO)
+
+#define MODULE_RESET_TIME_MS  1
+
+extern struct clk_ops clk_ops_corepll;
+extern struct clk_ops clk_ops_pll;
+extern struct clk_ops clk_ops_gate_module;
+extern struct clk_ops clk_ops_direct_s_parent;
+extern struct clk_ops clk_ops_direct_m_parent;
+extern struct clk_ops clk_ops_s_divider_s_parent;
+extern struct clk_ops clk_ops_s_divider_m_parent;
+extern struct clk_ops clk_ops_m_divider_s_parent;
+extern struct clk_ops clk_ops_m_divider_m_parent;
+extern struct clk_ops clk_ops_foo;
+extern struct clk_ops clk_ops_b_s_divider_s_parent;
+extern struct clk_ops clk_ops_b_s_divider_m_parent;
+extern struct clk_ops clk_ops_b_m_divider_s_parent;
+extern struct clk_ops clk_ops_b_m_divider_m_parent;
+extern struct clk_ops clk_ops_h_s_divider_s_parent;
+extern struct clk_ops clk_ops_h_s_divider_m_parent;
+extern struct clk_ops clk_ops_h_m_divider_s_parent;
+extern struct clk_ops clk_ops_h_m_divider_m_parent;
+
+struct clocks_table {
+    struct owl_clocknode *clocks;
+    unsigned long *rvregs;
+    struct owl_pll *pllnode;
+    struct clk **owl_clks;
+    struct owl_cmumod *modnode;
+    struct owl_clk_foo *clk_foo_clocks;
+    struct clk_lookup *lookup_table;
+};
+
+struct owl_clk_info {
+	struct clk_hw	hw;
+	void __iomem	*reg;
+	u8		bit_idx;
+	u32		*table;
+	u32		mask;
+	u8		shift;
+	u8		flags;
+	spinlock_t	*lock;
+	u32		clock_id;
+	unsigned long	fixed_rate;
+	unsigned long	fixed_accuracy;
+};
+
+int owl_clk_config_recursion(int clock, int recursion);
+
+int getdivider(struct owl_div *div, int n);
+int getdivider_resetval(struct owl_div *div);
+int addclock(int clock);
+
+struct clocks_table * atm7059_get_clocktree(void);
+void atm7059_init_clocktree(struct device_node *cum_node);
+void atm7059_prepare_clocktree(void);
+
diff --git a/arch/arm/mach-owl/common-owl.c b/arch/arm/mach-owl/common-owl.c
new file mode 100755
index 0000000..c242ade
--- /dev/null
+++ b/arch/arm/mach-owl/common-owl.c
@@ -0,0 +1,443 @@
+/*
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/bootmem.h>
+#include <linux/memblock.h>
+#include <linux/dma-contiguous.h>
+
+#include "../../../drivers/staging/android/ion/ion.h"
+#include "../../../drivers/staging/android/uapi/ion-owl.h"
+
+#include <linux/pfn.h>
+#include <linux/vmalloc.h>
+#include <asm/setup.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#if defined(CONFIG_OF)
+#include <linux/of_fdt.h>
+#endif
+
+#include <mach/dss-owl.h>
+#include <mach/kinfo.h>
+
+
+static struct ion_platform_heap owl_pdev_ion_heaps[] = {
+    {
+        .type = ION_HEAP_TYPE_CARVEOUT,
+        .id = ION_HEAP_ID_FB,
+        .name = "ion_fb",
+        .base = 0,  /* Filled in by owl_reserve() */
+        .size = 0,  /* Filled in by owl_reserve() */
+    },
+
+    {
+#ifdef CONFIG_CMA
+        .type = ION_HEAP_TYPE_DMA,
+#else
+        .type = ION_HEAP_TYPE_CARVEOUT,
+#endif
+        .id = ION_HEAP_ID_PMEM,
+        .name = "ion_pmem",
+        .base = 0,  /* Filled in by owl_reserve() */
+        .size = 0,  /* Filled in by owl_reserve() */
+        .priv = NULL,
+    },
+
+    {
+        .type = ION_HEAP_TYPE_SYSTEM,
+        .id = ION_HEAP_ID_SYSTEM,
+        .name = "ion_system",
+    },
+};
+
+static struct ion_platform_data owl_pdev_ion_data = {
+	.nr = ARRAY_SIZE(owl_pdev_ion_heaps),
+	.heaps = owl_pdev_ion_heaps,
+};
+
+static struct platform_device owl_pdev_ion_device = {
+	.name = "ion-owl",
+	.id = -1,
+	.dev = {
+		.platform_data = &owl_pdev_ion_data,
+		.coherent_dma_mask = -1, /* no restrict */
+	},
+};
+
+#ifndef CONFIG_OF
+static struct resource owl_gpu_res[] = {
+	{
+		.name  = "gpu_irq",
+		.start = OWL_IRQ_GPU_3D,
+		.end   = OWL_IRQ_GPU_3D,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.name  = "gpu_base",
+		.start = 0xB0300000,
+		.end   = 0xB030FFFF,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device owl_gpu_device = {
+	.name = "pvrsrvkm",
+	.resource = owl_gpu_res,
+	.num_resources = ARRAY_SIZE(owl_gpu_res),
+};
+#endif
+
+/*
+unsigned char *g_afinfo = NULL;
+int afinfo_buf_len;
+static unsigned long afinfo_phy;
+static int __init afinfo_process(char *str)
+{
+	char *str_len;
+
+	if (str == NULL || *str == '\0')
+		return 0;
+
+	str_len = strchr(str, ',');
+	if (!str_len)
+		return 0;
+	if (*(str_len + 1) == 0)
+		return 0;
+
+	str_len = str_len + 1;
+
+	afinfo_phy = simple_strtoul(str, NULL, 16);
+	afinfo_buf_len = simple_strtoul(str_len, NULL, 16);
+
+	return 1;
+}
+__setup("afinfo=", afinfo_process);
+
+static int __init afinfo_init(void)
+{
+	void *tmp;
+
+	g_afinfo = kmalloc(afinfo_buf_len, GFP_ATOMIC);
+	tmp = ioremap(afinfo_phy, afinfo_buf_len);
+	memcpy(g_afinfo, tmp, afinfo_buf_len);
+	iounmap(tmp);
+
+	pr_err("### afinfo_phy 0x%08lx, g_afinfo: 0x%p, afinfo_buf_len 0x%x\n", 
+		afinfo_phy, g_afinfo, afinfo_buf_len);
+	return 0;
+}
+arch_initcall(afinfo_init);
+*/
+
+static phys_addr_t s_phy_mem_size_saved;
+phys_addr_t owl_get_phy_mem_size(void)
+{
+	return s_phy_mem_size_saved;
+}
+EXPORT_SYMBOL(owl_get_phy_mem_size);
+
+static unsigned int owl_fb_start, owl_fb_size, owl_kinfo_start, owl_kinfo_size, owl_ion0_size, owl_ion1_size;
+
+void __init earlyl_init_dt_get_ion_info(unsigned long node)
+{
+	const __be32 *prop;
+
+    if(owl_fb_size == 0) {
+        prop = of_get_flat_dt_prop(node, "fb_heap_size", NULL);
+    	if (prop) {
+            owl_fb_size = be32_to_cpup(prop) * SZ_1M;
+            printk("find owl_fb_size=0x%x\n", owl_fb_size);
+        }
+    }
+    if(owl_kinfo_size == 0) {
+        prop = of_get_flat_dt_prop(node, "kinfo_heap_size", NULL);
+    	if (prop) {
+            owl_kinfo_size = be32_to_cpup(prop) * SZ_1M;
+            printk("find owl_kinfo_size=0x%x\n", owl_kinfo_size);
+        }
+    }
+#ifdef CONFIG_ION
+    if(owl_ion0_size == 0) {
+        prop = of_get_flat_dt_prop(node, "carveout_heap_size", NULL);
+    	if (prop) {
+            owl_ion0_size = be32_to_cpup(prop) * SZ_1M;
+            printk("find owl_ion0_size=0x%x\n", owl_ion0_size);
+        }
+    }
+    if(owl_ion1_size == 0) {
+        prop = of_get_flat_dt_prop(node, "dma_heap_size", NULL);
+    	if (prop) {
+            owl_ion1_size = be32_to_cpup(prop) * SZ_1M;
+            printk("find owl_ion1_size=0x%x\n", owl_ion1_size);
+        }
+    }
+#endif
+}
+
+int __init early_init_dt_scan_ion(unsigned long node, const char *uname,
+				   int depth, void *data)
+{
+    static int prop_depth = 1;
+
+	if (depth != prop_depth)
+		return 0;
+
+    if(depth == 1 && strcmp(uname, "reserved") == 0) {
+        prop_depth = 2;
+        return 0;
+    }
+    
+    if(depth == 2) {
+        if((phys_addr_t)data > (512 * 1024 * 1024)) {
+            if(strcmp(uname, "normal") == 0) {
+                earlyl_init_dt_get_ion_info(node);
+                return 1;
+            }
+        } else {
+            if(strcmp(uname, "tiny") == 0) {
+                earlyl_init_dt_get_ion_info(node);
+                return 1;
+            }
+        }
+    }
+
+	return 0;
+}
+
+extern phys_addr_t arm_lowmem_limit;
+void __init owl_reserve(void)
+{
+	phys_addr_t phy_mem_size, phy_mem_end;
+	unsigned int owl_ion0_start = 0;
+	unsigned int owl_ion1_start = 0;
+
+	phy_mem_size = memblock_phys_mem_size();
+	if (phy_mem_size & (phy_mem_size - 1)) { /* != 2^n ? */
+		uint _tmp = __fls(phy_mem_size);
+		if (_tmp > 0 && (phy_mem_size & (1U << (_tmp - 1)))) {
+			/* close to next boundary */
+			_tmp++;
+			phy_mem_size =
+				(_tmp >= sizeof(phy_mem_size) * 8) ? phy_mem_size : (1U << _tmp);
+		} else {
+			phy_mem_size = 1U << _tmp;
+		}
+	}
+	s_phy_mem_size_saved = phy_mem_size;
+	phy_mem_end = arm_lowmem_limit;
+	pr_info("%s: pyhsical memory size %u bytes, end @0x%x\n",
+		__func__, phy_mem_size, phy_mem_end);
+
+	memblock_reserve(0, 0x4000); /* reserve low 16K for DDR dqs training */
+
+	of_scan_flat_dt(early_init_dt_scan_ion, (void*)phy_mem_size);
+
+	phy_mem_end -= owl_fb_size;
+#ifdef CONFIG_VIDEO_OWL_DSS
+    owl_fb_start = phy_mem_end;
+    memblock_reserve(owl_fb_start, owl_fb_size);
+#endif
+
+	phy_mem_end -= owl_kinfo_size;
+    owl_kinfo_start = phy_mem_end;
+    memblock_reserve(owl_kinfo_start, owl_kinfo_size);
+    
+#ifdef CONFIG_ION
+	phy_mem_end -= owl_ion0_size;
+	owl_ion0_start = phy_mem_end;
+	owl_pdev_ion_data.heaps[0].base = owl_ion0_start;
+	owl_pdev_ion_data.heaps[0].size = owl_ion0_size;
+
+	/* ion_pmem */
+#ifdef CONFIG_CMA
+	phy_mem_end -= owl_ion1_size;
+	owl_ion1_start = phy_mem_end; /* fake, not used. */
+	owl_pdev_ion_data.heaps[1].base = 0;
+	owl_pdev_ion_data.heaps[1].size = 0; /* prevent ion_reserve() from diging */
+	owl_pdev_ion_data.heaps[1].priv = &(owl_pdev_ion_device.dev);
+	dma_contiguous_set_global_reserve_size(owl_ion1_size); /* set size of the CMA global area */
+#else /* no CMA */
+	phy_mem_end -= owl_ion1_size;
+	owl_ion1_start = phy_mem_end;
+	owl_pdev_ion_data.heaps[1].base = owl_ion1_start;
+	owl_pdev_ion_data.heaps[1].size = owl_ion1_size;
+#endif
+	ion_reserve(&owl_pdev_ion_data);
+#endif
+
+	printk(KERN_INFO "Reserved memory %uMB\n",
+		(owl_ion0_size + owl_ion1_size) >> 20);
+	printk(KERN_INFO 
+	        "   FB:     0x%08x, %uMB\n"
+	        "   KINFO:  0x%08x, %uMB\n"
+	        "   ION0:   0x%08x, %uMB\n"
+			"   ION1:   0x%08x, %uMB\n",
+			owl_fb_start, owl_fb_size >> 20,
+			owl_kinfo_start, owl_kinfo_size >> 20,
+			owl_ion0_start, owl_ion0_size >> 20,
+			owl_ion1_start, owl_ion1_size >> 20);
+}
+
+static void free_owl_reserved_memory(unsigned int free_start, unsigned int free_size)
+{
+    unsigned long n, start, end;
+    unsigned long max_low = max_low_pfn + PHYS_PFN_OFFSET;
+
+    start = free_start;
+    end = free_start + free_size;
+    if( (start >> PAGE_SHIFT) <= max_low ) {
+        if( (end >> PAGE_SHIFT) > max_low )
+            end = max_low << PAGE_SHIFT;
+	n = free_reserved_area((void *)(__phys_to_virt(start)), (void *)(__phys_to_virt(end)), 0, NULL);
+        printk("free reserve pages %lu to buddy system\n", n);
+    }
+
+#ifdef	CONFIG_HIGHMEM
+    start = free_start >> PAGE_SHIFT;
+    end = (free_start + free_size) >> PAGE_SHIFT;
+    if( end > max_low ) {
+        if(start < max_low)
+            start = max_low;
+    	for (n = start; n < end; n++)
+    		free_highmem_page(pfn_to_page(n));
+        printk("free reserve high memory pages %lu to buddy system\n", end - start);
+    }
+#endif
+}
+
+#ifdef CONFIG_VIDEO_OWL_DSS
+void free_fb_reserved_memory(void)
+{
+	if(owl_fb_size > 0) {
+        free_owl_reserved_memory(owl_fb_start, owl_fb_size);
+		owl_fb_size = 0;
+	}
+}
+EXPORT_SYMBOL(free_fb_reserved_memory);
+#endif
+
+static struct platform_device *owl_common_devices[] __initdata = {
+	&owl_pdev_ion_device,
+#ifndef CONFIG_OF
+	&owl_gpu_device,
+#endif
+};
+
+unsigned long get_ion_reserved_mem_size(void)
+{
+	return (unsigned long)(owl_pdev_ion_data.heaps[0].size +
+		owl_pdev_ion_data.heaps[1].size);
+}
+
+int __init owl_common_init(void)
+{
+	printk(KERN_INFO "%s()\n", __func__);
+
+	platform_add_devices(owl_common_devices,
+		ARRAY_SIZE(owl_common_devices));
+
+	return 0;
+}
+
+arch_initcall(owl_common_init);
+
+
+/***************/
+#include <mach/kinfo.h>
+
+struct kernel_reserve_info *kinfo;
+EXPORT_SYMBOL(kinfo);
+
+int __init owl_kinfo_init(void)
+{
+    struct page **pages;
+    unsigned int pages_count, pfn, i;
+    void __iomem * kinfo_vaddr;
+
+    kinfo = kmalloc(sizeof(struct kernel_reserve_info), GFP_KERNEL);
+    if(kinfo == NULL) {
+        printk(KERN_ALERT "%s, kmalloc(%d) for kinfo failed!\n",
+                __func__, sizeof(struct kernel_reserve_info));
+        return -ENOMEM;
+    }
+    
+    pages_count = owl_kinfo_size >> PAGE_SHIFT;
+    pages = kmalloc(sizeof *pages * pages_count, GFP_KERNEL);
+    if (!pages) {
+        printk(KERN_ALERT "%s, kmalloc(%d) for pages failed!\n",
+                __func__, sizeof *pages * pages_count);
+        return -ENOMEM;
+    }
+    pfn = PFN_DOWN(owl_kinfo_start);
+    for (i = 0; i < pages_count; ++i)
+        pages[i] = pfn_to_page(pfn + i);
+    kinfo_vaddr = vm_map_ram(pages, pages_count, -1, PAGE_KERNEL);
+    if(kinfo_vaddr == NULL) {
+        printk(KERN_ALERT "%s, ioremap(0x%x, 0x%x) for kinfo failed!\n",
+                __func__, owl_kinfo_start, owl_kinfo_size);
+        return -ENOMEM;
+    }
+    memcpy(kinfo, kinfo_vaddr, sizeof(struct kernel_reserve_info));
+    vm_unmap_ram(kinfo_vaddr, pages_count);
+    kfree(pages);
+    
+    free_owl_reserved_memory(owl_kinfo_start, owl_kinfo_size);
+    return 0;
+}
+arch_initcall(owl_kinfo_init);
+
+
+/***************/
+
+
+
+/*0:atc2603 , 1:atc2609 , -1:NULL*/
+static int pmu_id = -1;
+static ssize_t pmu_id_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", pmu_id);
+}
+
+static DEVICE_ATTR(pmu_id, 0664, pmu_id_show, NULL);
+
+int __init owl_pmu_detect(void)
+{
+	int ret;
+	struct device_node *np;
+
+	ret = sysfs_create_file(power_kobj, &dev_attr_pmu_id.attr);
+	if (ret)
+		pr_err("sysfs_create_file failed: %d\n", ret);
+
+	np = of_find_node_by_name(NULL, "dcdc0");
+	if (np) {
+		pmu_id = 1;
+		return 0;
+	}
+
+	np = of_find_node_by_name(NULL, "dcdc1");
+	if (np) {
+		pmu_id = 0;
+		return 0;
+	}
+
+	pr_err("DTS without PMU node!\n");
+	return -EINVAL;
+}
+
+late_initcall(owl_pmu_detect);
+
diff --git a/arch/arm/mach-owl/cpu-owl.c b/arch/arm/mach-owl/cpu-owl.c
new file mode 100755
index 0000000..ecfc4c85
--- /dev/null
+++ b/arch/arm/mach-owl/cpu-owl.c
@@ -0,0 +1,118 @@
+/*
+ * arch/arm/mach-owl/cpu-owl.c
+ *
+ * cpu peripheral init for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_irq.h>
+#include <linux/irqchip.h>
+#include <linux/module.h>
+
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <asm/smp_twd.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+
+extern void __init owl_gp_timer_init(void);
+extern void __init owl_init_clocks(void);
+
+static struct map_desc owl_io_desc[] __initdata = {
+	{
+		.virtual	= IO_ADDRESS(OWL_PA_REG_BASE),
+		.pfn		= __phys_to_pfn(OWL_PA_REG_BASE),
+		.length		= OWL_PA_REG_SIZE,
+		.type		= MT_DEVICE,
+	},
+
+   /*for suspend , to load ddr ops code. by jlingzhang*/
+#if 1
+	{
+		.virtual	= OWL_VA_BOOT_RAM,
+		.pfn		= __phys_to_pfn(OWL_PA_BOOT_RAM),
+		.length		= SZ_4K,
+		.type		= MT_MEMORY_RWX,
+	},
+#endif
+};
+
+/*
+ return ATM7033: 0xf, ATM7039: 0xe
+ */
+int cpu_package(void)
+{
+	return (act_readl(0xb01b00e0) & 0xf);
+}
+EXPORT_SYMBOL(cpu_package);
+
+void __init owl_map_io(void)
+{
+	/* dma coherent allocate buffer: 2 ~ 14MB */
+	init_dma_coherent_pool_size(14 << 20);
+	iotable_init(owl_io_desc, ARRAY_SIZE(owl_io_desc));
+}
+
+void __init owl_init_irq(void)
+{
+#ifdef CONFIG_OF
+	irqchip_init();
+#else
+	gic_init(0, 29, IO_ADDRESS(OWL_PA_GIC_DIST),
+		IO_ADDRESS(OWL_PA_GIC_CPU));
+#endif
+}
+
+#ifdef CONFIG_CACHE_L2X0
+static int __init owl_l2x0_init(void)
+{
+	void __iomem *l2x0_base;
+	u32 val;
+
+	printk(KERN_INFO "%s()\n", __func__);
+
+	l2x0_base = (void *)IO_ADDRESS(OWL_PA_L2CC);
+
+	/* config l2c310 */
+	act_writel(0x78800002, (unsigned int)OWL_PA_L2CC + L310_PREFETCH_CTRL);
+	act_writel(L310_DYNAMIC_CLK_GATING_EN | L310_STNDBY_MODE_EN,
+		(unsigned int)OWL_PA_L2CC + L310_POWER_CTRL);
+
+	/* Instruction prefetch enable
+	   Data prefetch enable
+	   Round-robin replacement
+	   Use AWCACHE attributes for WA
+	   32kB way size, 16 way associativity
+	   disable exclusive cache
+	*/
+	val = L310_AUX_CTRL_INSTR_PREFETCH
+	| L310_AUX_CTRL_DATA_PREFETCH
+	| L310_AUX_CTRL_NS_INT_CTRL
+	| L310_AUX_CTRL_NS_LOCKDOWN
+	| (1 << 25) /* round robin*/
+	| L2C_AUX_CTRL_WAY_SIZE(2)
+	| L310_AUX_CTRL_ASSOCIATIVITY_16;
+
+#ifdef CONFIG_OF
+	l2x0_of_init(val, 0xc0000fff);
+#else
+	l2x0_init(l2x0_base, val, 0xc0000fff);
+#endif
+
+	return 0;
+}
+early_initcall(owl_l2x0_init);
+#endif
diff --git a/arch/arm/mach-owl/debug-owl.c b/arch/arm/mach-owl/debug-owl.c
new file mode 100755
index 0000000..738c6f9
--- /dev/null
+++ b/arch/arm/mach-owl/debug-owl.c
@@ -0,0 +1,489 @@
+/*
+ * arch/arm/mach-owl/debug-owl.c
+ *
+ * special debug support for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/kallsyms.h>
+#include <linux/perf_event.h>
+#include <linux/hw_breakpoint.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/debug.h>
+
+
+/* FIXME: move symbol from adfus to kernel temporarily */
+typedef unsigned int (*func_t)(unsigned int *, void *);
+
+func_t AdfuUpdateMbrFromPhyToUsr;
+EXPORT_SYMBOL(AdfuUpdateMbrFromPhyToUsr);
+
+typedef void (*func_t1)(void);
+func_t1 adfu_flush_nand_cache;
+EXPORT_SYMBOL(adfu_flush_nand_cache);
+
+typedef int (*func_t4)(unsigned long, unsigned long , void *, void *);
+
+func_t4 adfus_nand_read;
+func_t4 adfus_nand_write;
+EXPORT_SYMBOL(adfus_nand_read);
+EXPORT_SYMBOL(adfus_nand_write);
+
+extern void show_state_filter(unsigned long state_filter);
+void owl_show_state(void)
+{
+	show_state_filter(0);
+}
+EXPORT_SYMBOL(owl_show_state);
+
+typedef struct
+{
+    unsigned int magic;
+    void *caller;
+    struct task_struct  *tsk;
+    struct timer_list   timer;
+}watch_dog_data_t;
+
+static void owl_watchdog_callback(unsigned long data)
+{
+    watch_dog_data_t *watch_dog_data = (watch_dog_data_t *)data;
+    
+    console_verbose();
+#ifdef CONFIG_KALLSYMS
+    printk("watchdog set from [<%08lx>] (%pS)\n", (unsigned long)watch_dog_data->caller, watch_dog_data->caller);
+#else
+    printk("watchdog set from [<%08lx>]\n", (unsigned long)watch_dog_data->caller);
+#endif
+    show_stack(watch_dog_data->tsk, NULL);
+
+    printk("dump all task stack:\n");
+    owl_show_state();
+}
+
+/**
+ * owl_watchdog_start - start watchdog until timeout
+ * @timeout: timeout value in jiffies
+ * @callback: when timeout happened, this function will be called
+ *
+ * Make the current task run until @timeout jiffies have
+ * elapsed, and call owl_watchdog_callback defaultly when it happend.
+ *
+ * You can set the callback as yours by passing param callback with not NULL.
+ *
+ * return value is the handle of watchdog
+ */
+void *owl_watchdog_start(int timeout, void (*callback)(unsigned long data), unsigned long data)
+{
+    watch_dog_data_t *watch_dog_data = kmalloc(sizeof(watch_dog_data_t), GFP_KERNEL);
+    if(!watch_dog_data)
+        return NULL;
+    
+    watch_dog_data->magic = 0x77617463;
+    watch_dog_data->tsk = current;
+	watch_dog_data->caller = __builtin_return_address(0);
+    init_timer(&watch_dog_data->timer);
+    if(callback)
+    {
+        watch_dog_data->timer.function = callback;
+        watch_dog_data->timer.data = data;
+    }
+    else
+    {
+        watch_dog_data->timer.function = owl_watchdog_callback;
+        watch_dog_data->timer.data = (unsigned long)watch_dog_data;
+    }
+    watch_dog_data->timer.expires = jiffies + timeout;
+    add_timer(&watch_dog_data->timer);
+    return watch_dog_data;
+}
+
+void owl_watchdog_stop(void *owl_watchdog)
+{
+    watch_dog_data_t *watch_dog_data = owl_watchdog;
+	
+    if(watch_dog_data && watch_dog_data->magic == 0x77617463)
+    {
+        watch_dog_data->magic = 0;
+        del_timer_sync(&watch_dog_data->timer);
+        kfree(watch_dog_data);
+    }
+}
+
+#ifdef CONFIG_OWL_DEBUG_IRQ_STACK
+static void __owl_debug_show_regs(struct pt_regs *regs)
+{
+	pr_emerg("regs : [<%08lx>]\n", (long)regs);
+	pr_emerg("pc : [<%08lx>]    lr : [<%08lx>]    psr: %08lx\n"
+		   "sp : %08lx  ip : %08lx  fp : %08lx\n",
+		regs->ARM_pc, regs->ARM_lr, regs->ARM_cpsr,
+		regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
+	pr_emerg("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
+		regs->ARM_r10, regs->ARM_r9,
+		regs->ARM_r8);
+	pr_emerg("r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\n",
+		regs->ARM_r7, regs->ARM_r6,
+		regs->ARM_r5, regs->ARM_r4);
+	pr_emerg("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
+		regs->ARM_r3, regs->ARM_r2,
+		regs->ARM_r1, regs->ARM_r0);
+}
+
+static void hbp_handler(struct perf_event *bp,
+			       struct perf_sample_data *data,
+			       struct pt_regs *regs)
+{
+	pr_emerg("change here\n");
+	__owl_debug_show_regs(regs);
+}
+
+void hw_break_set(void **hbp, void *hbp_addr)
+{
+	struct perf_event_attr attr;
+	
+	hw_breakpoint_init(&attr);
+	attr.bp_addr = (unsigned long)hbp_addr;
+	attr.bp_len = HW_BREAKPOINT_LEN_4;
+	attr.bp_type = HW_BREAKPOINT_W;// | HW_BREAKPOINT_R;
+
+	*hbp = register_wide_hw_breakpoint(&attr, hbp_handler, NULL);
+	if (IS_ERR((void __force *)hbp)) {
+		printk("hw_break_init failed\n");
+	}
+}
+EXPORT_SYMBOL(hw_break_set);
+
+void hw_break_unset(void **hbp)
+{
+	if (!IS_ERR((void __force *)hbp)) {
+		unregister_wide_hw_breakpoint(*hbp);
+		*hbp = NULL;
+	}
+}
+EXPORT_SYMBOL(hw_break_unset);
+
+static int owl_irqstack_debug = 0;
+
+void owl_debug_save_irqstack(struct pt_regs *regs)
+{
+	struct thread_info *thread_info;
+	if(!owl_irqstack_debug)
+		return;
+
+	thread_info = current_thread_info();
+	if(thread_info->regs_init == 0x12345678)
+		return;
+	thread_info->regs_init = 0x12345678;
+	
+	thread_info->regs = *regs;
+}
+
+void owl_debug_check_irqstack(struct pt_regs *regs)
+{
+	struct thread_info *thread_info;
+	struct pt_regs *regs_save;
+	if(!owl_irqstack_debug)
+		return;
+
+	thread_info = current_thread_info();
+	if(thread_info->regs_init != 0x12345678)
+		return;
+	thread_info->regs_init = 0;
+	
+	regs_save = &thread_info->regs;
+	if(memcmp(regs_save, regs, sizeof(struct pt_regs)) != 0)
+	{
+		pr_emerg("irq stack diff from %p\n", __builtin_return_address(0));
+		pr_emerg("CPU: %d PID: %d Comm: %.20s\n",
+			   raw_smp_processor_id(), current->pid, current->comm);
+		pr_emerg("irq stack org:\n");
+		__owl_debug_show_regs(regs_save);
+		pr_emerg("irq stack now:\n");
+		__owl_debug_show_regs(regs);
+	}
+}
+
+void owl_debug_clear_irqstack(void)
+{
+	struct thread_info *thread_info;
+	if(!owl_irqstack_debug)
+		return;
+	
+	thread_info = current_thread_info();
+	thread_info->regs_init = 0;
+}
+
+static int owl_irqstack_debug_config(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	if (strcmp(str, "off") == 0)
+	{
+		owl_irqstack_debug = 0;
+		printk("owl_irqstack_debug off\n");
+	}
+	else if (strcmp(str, "on") == 0)
+	{
+		owl_irqstack_debug = 1;
+		printk("owl_irqstack_debug on\n");
+	}
+	else
+		return -EINVAL;
+	return 0;
+}
+early_param("owl_irqstack_debug", owl_irqstack_debug_config);
+
+#endif
+
+void owl_dump_mem(void *startaddr, int size, void *showaddr, int show_bytes)
+{
+    int i, count, count_per_line;
+    void *addr = startaddr;
+
+    if ((show_bytes != 1) && (show_bytes != 2) && (show_bytes != 4))
+    {
+        printk("dump_mem: not support mode\n");
+        return;
+    }
+
+    if (((int) startaddr & (show_bytes - 1)) || (size & (show_bytes - 1)))
+    {
+        printk("dump_mem: startaddr must be aligned by %d bytes!\n", show_bytes);
+        return;
+    }
+
+    count = size / show_bytes;
+    count_per_line = 16 / show_bytes; // 16 bytes per line
+
+    printk("startaddr 0x%p, size 0x%x\n",
+        startaddr, size);
+
+    i = 0;
+    while (i < count)
+    {
+        if ((i % count_per_line) == 0) {
+            if (i != 0)
+                printk("\n");
+
+            printk("%08x: ", (unsigned int)showaddr + ((i / count_per_line) * 16));
+        }
+        switch (show_bytes) {
+        case 1:
+            printk("%02x ", *((unsigned char *) addr + i));
+            break;
+        case 2:
+            printk("%04x ", *((unsigned short *) addr + i));
+            break;
+        case 4:
+            printk("%08x ", *((unsigned int *) addr + i));
+            break;
+        default:
+            printk("dump_mem: not support mode\n");
+            return;
+        }
+
+        i++;
+    }
+    printk("\n");
+}
+
+EXPORT_SYMBOL(owl_dump_mem);
+
+void owl_dump_reg(unsigned int addr, int size)
+{
+    int count, i = 0;
+
+    if ((addr & 3) || (size & 3)) {
+        printk("owl_dump_reg: startaddr must be aligned by 4 bytes!\n");
+        return;
+    }
+
+    count = size / 4;
+
+    printk("addr 0x%08x, size 0x%x\n", addr, size);
+
+    while (i < count) {
+        if ((i % 4) == 0) {
+            if (i != 0)
+                printk("\n");
+
+            printk("%08x: ", (unsigned int)addr + i * 4);
+        }
+
+        printk("%08x ", act_readl((unsigned int)addr + i * 4));
+
+        i++;
+    }
+    printk("\n");
+}
+
+EXPORT_SYMBOL(owl_dump_reg);
+
+#ifdef CONFIG_DEBUG_FS
+
+static ssize_t reg_read(struct file *filp, char __user *buffer,
+        size_t count, loff_t *ppos)
+{
+    printk("read/write a register:\n");
+    printk("  read : echo 0xb01c0000 > reg\n");
+    printk("  write: echo 0xb01c00000=0x12345678 > reg\n");
+
+    return 0;
+}
+
+static ssize_t reg_write(struct file *filp, const char __user *buffer,
+        size_t count, loff_t *ppos)
+{
+    unsigned int reg, read_val, reg_val;
+    char buf[32];
+    char *end_ptr;
+    int write = 0;
+
+    if (*ppos != 0)
+        return -EINVAL;
+    if (count > 32)
+        return -EINVAL;
+    if (copy_from_user(buf, buffer, count))
+        return -EFAULT;
+
+    *ppos += count;
+
+    reg = simple_strtoul(buf, &end_ptr, 16);
+
+    if ((reg & 0x3) || (reg < OWL_PA_REG_BASE) ||
+        (reg >= OWL_PA_REG_BASE + 6 * SZ_1M)) {
+        printk("invalid register address\n");
+        return -EINVAL;
+    }
+
+    if ((buf == end_ptr) )
+        goto out;
+
+    read_val = act_readl(reg);
+    printk("[0x%08x]: 0x%08x\n", reg, read_val);
+
+    if (*end_ptr++ == '=') {
+        reg_val = simple_strtoul(end_ptr, NULL, 16);
+        write = 1;
+    }
+
+    if (write) {
+        act_writel(reg_val, reg);
+        printk("[0x%08x] <- 0x%08x\n", reg, reg_val);
+    }
+
+out:
+    return count;
+}
+
+static int reg_open(struct inode *inode, struct file *filp)
+{
+    filp->private_data = inode->i_private;
+    return 0;
+}
+
+static struct file_operations reg_fops = {
+    .open = reg_open,
+    .read = reg_read,
+    .write = reg_write,
+};
+
+
+static ssize_t regs_read(struct file *filp, char __user *buffer,
+        size_t count, loff_t *ppos)
+{
+    printk("read registers:\n");
+    printk("  echo regs_start,regs_len > regs\n");	
+    printk("  echo 0xb01c0000,0x100 > regs\n");
+
+    return 0;
+}
+
+static ssize_t regs_write(struct file *filp, const char __user *buffer,
+        size_t count, loff_t *ppos)
+{
+    unsigned int reg, reg_len;
+    char buf[32];
+    char *end_ptr;
+
+    if (*ppos != 0)
+        return -EINVAL;
+    if (count > 32)
+        return -EINVAL;
+    if (copy_from_user(buf, buffer, count))
+        return -EFAULT;
+
+    *ppos += count;
+
+    reg = simple_strtoul(buf, &end_ptr, 16);
+
+    if ((reg & 0x3) || (reg < OWL_PA_REG_BASE) ||
+        (reg >= OWL_PA_REG_BASE + 6 * SZ_1M)) {
+        printk("invalid register address\n");
+        return -EINVAL;
+    }
+
+    if ((buf == end_ptr))
+        goto out;
+
+    if (*end_ptr++ == ',') {
+        reg_len = simple_strtoul(end_ptr, NULL, 16);
+		owl_dump_reg(reg, reg_len);
+    }
+
+out:
+    return count;
+}
+
+static int regs_open(struct inode *inode, struct file *filp)
+{
+    filp->private_data = inode->i_private;
+    return 0;
+}
+
+static struct file_operations regs_fops = {
+    .open = regs_open,
+    .read = regs_read,
+    .write = regs_write,
+};
+
+int __init owl_debug_init(void)
+{
+    struct dentry *dir;
+    struct dentry *d;
+
+    dir = debugfs_create_dir("owl", NULL);
+    if (!dir)
+        return -ENOMEM;
+
+    d = debugfs_create_file("reg", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP, dir, NULL,
+        &reg_fops);
+    if (!d)
+        return -ENOMEM;
+
+    d = debugfs_create_file("regs", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP, dir, NULL,
+        &regs_fops);
+    if (!d)
+        return -ENOMEM;		
+    return 0;
+}
+
+arch_initcall(owl_debug_init);
+
+#endif /* CONFIG_DEBUG_FS */
diff --git a/arch/arm/mach-owl/dump_stack-owl.c b/arch/arm/mach-owl/dump_stack-owl.c
new file mode 100755
index 0000000..ca1c8d27
--- /dev/null
+++ b/arch/arm/mach-owl/dump_stack-owl.c
@@ -0,0 +1,224 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/proc_fs.h>
+#include <linux/kallsyms.h>
+
+#include <linux/nsproxy.h>
+#include <linux/sched.h>
+#include <linux/stacktrace.h>
+#include <asm/stacktrace.h>
+#include <linux/slab.h>
+
+static int show_pid = 1;
+
+struct stack_trace_data {
+    struct stack_trace *trace;
+    unsigned int no_sched_functions;
+    unsigned int skip;
+};
+
+static int save_trace(struct stackframe *frame, void *d)
+{
+    struct stack_trace_data *data = d;
+    struct stack_trace *trace = data->trace;
+    unsigned long addr = frame->pc;
+
+//  if (data->no_sched_functions && in_sched_functions(addr))
+//      return 0;
+    if (data->skip) {
+        data->skip--;
+        return 0;
+    }
+
+    trace->entries[trace->nr_entries++] = addr;
+
+    return trace->nr_entries >= trace->max_entries;
+}
+
+static void save_stack_trace_tsk2(struct task_struct *tsk, struct stack_trace *trace)
+{
+    struct stack_trace_data data;
+    struct stackframe frame;
+
+    data.trace = trace;
+    data.skip = trace->skip;
+
+    if (tsk != current) {
+//#ifdef CONFIG_SMP
+        /*
+         * What guarantees do we have here that 'tsk' is not
+         * running on another CPU?  For now, ignore it as we
+         * can't guarantee we won't explode.
+         */
+//      if (trace->nr_entries < trace->max_entries)
+//          trace->entries[trace->nr_entries++] = ULONG_MAX;
+//      return;
+//#else
+        data.no_sched_functions = 1;
+        frame.fp = thread_saved_fp(tsk);
+        frame.sp = thread_saved_sp(tsk);
+        frame.lr = 0;       /* recovered from the stack */
+        frame.pc = thread_saved_pc(tsk);
+//#endif
+    } else {
+        register unsigned long current_sp asm ("sp");
+
+        data.no_sched_functions = 0;
+        frame.fp = (unsigned long)__builtin_frame_address(0);
+        frame.sp = current_sp;
+        frame.lr = (unsigned long)__builtin_return_address(0);
+        frame.pc = (unsigned long)save_stack_trace_tsk2;
+    }
+
+    walk_stackframe(&frame, save_trace, &data);
+    if (trace->nr_entries < trace->max_entries)
+        trace->entries[trace->nr_entries++] = ULONG_MAX;
+}
+
+
+static int dump_task_stack(struct task_struct *task)
+{
+    struct stack_trace trace;
+    char *buf;
+
+    printk(KERN_INFO "dump_task_stack: %p\n", task);
+
+    buf = kmalloc(4096, GFP_KERNEL);
+    trace.nr_entries    = 0;
+    trace.skip      = 0;
+    trace.entries       = (unsigned long*)buf;
+    trace.max_entries   = 100; 
+
+    save_stack_trace_tsk2(task, &trace);
+    print_stack_trace(&trace, 4);
+
+    kfree(buf);
+
+    return 0;
+}
+
+static inline void my_show_state(long state)
+{
+    /* -1 unrunnable, 0 runnable, >0 stopped */
+    if(state==0)
+       printk(" runnable\n");
+    else if(state>0)
+       printk(" stopped\n");
+    else
+       printk(" unrunnable\n");
+}
+
+static int dump_all_tasks(void)
+{
+#if 1
+    struct task_struct *g, *p;
+    int count=0;
+
+    printk( "Module testcurrent init\n" );
+    do_each_thread(g, p) {
+        count++;
+        printk( "%d : Thread name %s ,pid=%6d ",count ,p->comm,p->pid);
+        my_show_state(p->state);
+        dump_task_stack(p);
+    } while_each_thread(g, p);
+#else   
+    struct task_struct *task;
+
+    struct list_head *list;
+    int count=0;
+    printk( "Module testcurrent init\n" );
+
+    list_for_each(list, &current->tasks)
+    { 
+       count++;
+       task=list_entry(list,struct task_struct, tasks);
+       printk( "%d : Thread name %s ,pid=%6d ",count ,task->comm,task->pid);
+       my_show_state(task->state);
+
+       dump_task_stack(task);
+    }
+    printk( " current is %s ,total %d\n",current->comm,count );
+#endif
+    return 0;
+}
+static int dump_cur_task(int new_pid)
+{
+	struct task_struct *p; 
+	struct nsproxy *nsproxy = get_current()->nsproxy;
+
+	p =pid_task(find_pid_ns(show_pid, nsproxy->pid_ns_for_children), PIDTYPE_PID);
+	if(p == NULL)
+	{
+		printk("can not find task pid: %d\n", show_pid);
+		return -EINVAL;
+	}   
+	printk("find task: name %s, pid: %d, leader name %s pid: %d\n", 
+	     p->comm, p->pid, p->group_leader->comm, p->group_leader->pid);
+	my_show_state(p->state);
+
+	sched_show_task(p);
+	return 0;
+}
+
+static ssize_t sstack_read_proc(struct file *file, char __user *buffer,
+                   size_t count, loff_t * offset)
+{
+    dump_cur_task(show_pid);
+
+    return 0;
+}
+
+static ssize_t sstack_write_proc(struct file *file, const char __user *buffer,
+                   size_t count, loff_t * offset)
+{
+    char buf[16];
+    int new_pid;
+
+    if(count > 16) {
+        printk(KERN_INFO "the count is too large");
+        return -EINVAL;
+    }
+
+    if(copy_from_user(buf, buffer, count)) {
+        return -EFAULT;
+    }
+    new_pid = simple_strtoul(buf, NULL, 10);
+    show_pid = new_pid;
+    if(show_pid != 0) {
+        int ret;
+
+        ret = dump_cur_task(new_pid);
+        if(ret) 
+            return ret;
+        else
+            return count;
+    } else {
+        dump_all_tasks();
+        return count;
+    }
+}
+
+static const struct file_operations __sstack_file_operations =
+{
+    .owner =        THIS_MODULE,
+    .read =         sstack_read_proc,
+    .write =        sstack_write_proc,
+};
+
+static void sstack_create_proc(void)
+{
+    proc_create("show_stack", S_IRUGO | S_IWUGO, NULL, &__sstack_file_operations);
+}
+
+static int __init sstack_init(void)
+{
+    sstack_create_proc();
+    return 0;
+}
+
+late_initcall(sstack_init);
diff --git a/arch/arm/mach-owl/gpio-owl.c b/arch/arm/mach-owl/gpio-owl.c
new file mode 100755
index 0000000..079fa2f
--- /dev/null
+++ b/arch/arm/mach-owl/gpio-owl.c
@@ -0,0 +1,426 @@
+/*
+ * arch/arm/mach-owl/gpio-owl.c
+ *
+ * GPIO interface for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/irqdomain.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/of_device.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+
+#define GPIO_REG_BASE               (GPIO_MFP_PWM_BASE)
+
+#define GPIO_BANK(gpio)             ((gpio) / 32)
+#define GPIO_IN_BANK(gpio)          ((gpio) % 32)
+#define GPIO_BIT(gpio)              (1 << GPIO_IN_BANK(gpio))
+
+#define GPIO_REG_OUTEN(gpio)	(GPIO_REG_BASE + GPIO_BANK(gpio) * 0xc + 0x0)
+#define GPIO_REG_INEN(gpio)	(GPIO_REG_BASE + GPIO_BANK(gpio) * 0xc + 0x4)
+#define GPIO_REG_DAT(gpio)	(GPIO_REG_BASE + GPIO_BANK(gpio) * 0xc + 0x8)
+#define GPIO_REG_INTC_PD(gpio)	(GPIO_REG_BASE + GPIO_BANK(gpio) * 0x8 + 0x208)
+#define GPIO_REG_INTC_MASK(gpio)	(GPIO_REG_BASE  \
+						+ GPIO_BANK(gpio) * 0x8 + 0x20c)
+#define GPIO_REG_INTC_TYPE(gpio)	(GPIO_REG_BASE   \
+						+  GPIO_BANK(gpio)*0x8 + 0x230)
+
+#define GPIO_GAPD			(1<<0)
+#define GPIO_GBPD			(1<<5)
+#define GPIO_GCPD			(1<<10)
+#define GPIO_GDPD			(1<<15)
+#define GPIO_GEPD			(1<<20)
+
+/* INTC_EXTCTL */
+#define GPIO_INT_TYPE_MASK          0x3
+#define GPIO_INT_TYPE_HIGH          0x0
+#define GPIO_INT_TYPE_LOW           0x1
+#define GPIO_INT_TYPE_RISING        0x2
+#define GPIO_INT_TYPE_FALLING       0x3
+
+static struct irq_domain *irq_domain;
+
+#ifdef CONFIG_PINCTRL_OWL
+DEFINE_SPINLOCK(owl_gpio_lock);
+#else
+static DEFINE_SPINLOCK(owl_gpio_lock);
+#endif
+
+#define _GPIOA(offset)		  (offset)
+#define _GPIOB(offset)		  (32 + (offset))
+#define _GPIOC(offset)		  (64 + (offset))
+#define _GPIOD(offset)		  (96 + (offset))
+#define _GPIOE(offset)		  (128 + (offset))
+
+static int owl_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+#ifdef CONFIG_PINCTRL_OWL
+	int ret;
+	/*
+	 * Map back to global GPIO space and request muxing, the direction
+	 * parameter does not matter for this controller.
+	 */
+	int gpio = chip->base + offset;
+
+	ret = pinctrl_request_gpio(gpio);
+	return ret;
+#else
+	return 0;
+#endif
+}
+
+static void owl_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+#ifdef CONFIG_PINCTRL_OWL
+	int gpio = chip->base + offset;
+
+	pinctrl_free_gpio(gpio);
+#endif
+}
+
+static int owl_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	return act_readl(GPIO_REG_DAT(offset)) & GPIO_BIT(offset);
+}
+
+static void owl_gpio_set(struct gpio_chip *chip, unsigned offset, int val)
+{
+	unsigned int dat;
+
+	dat = act_readl(GPIO_REG_DAT(offset));
+
+	if (val)
+		dat |= GPIO_BIT(offset);
+	else
+		dat &= ~GPIO_BIT(offset);
+
+	act_writel(dat, GPIO_REG_DAT(offset));
+}
+
+static int owl_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&owl_gpio_lock, irq_flags);
+
+	act_writel(act_readl(GPIO_REG_OUTEN(offset)) & ~GPIO_BIT(offset),
+	GPIO_REG_OUTEN(offset));
+
+	act_writel(act_readl(GPIO_REG_INEN(offset)) | GPIO_BIT(offset),
+	GPIO_REG_INEN(offset));
+
+	spin_unlock_irqrestore(&owl_gpio_lock, irq_flags);
+
+	return 0;
+}
+
+static int owl_gpio_direction_output(struct gpio_chip *chip,
+		unsigned offset, int val)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&owl_gpio_lock, irq_flags);
+
+	act_writel(act_readl(GPIO_REG_INEN(offset)) & ~GPIO_BIT(offset),
+			GPIO_REG_INEN(offset));
+
+	act_writel(act_readl(GPIO_REG_OUTEN(offset)) | GPIO_BIT(offset),
+			GPIO_REG_OUTEN(offset));
+
+	owl_gpio_set(chip, offset, val);
+
+	spin_unlock_irqrestore(&owl_gpio_lock, irq_flags);
+	return 0;
+}
+
+static int owl_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+//	return OWL_EXT_GPIO_TO_IRQ(chip->base + offset);
+
+	return irq_find_mapping(irq_domain, offset);
+}
+
+static struct gpio_chip owl_gpio_chip = {
+	.label                = "owl-gpio-chip",
+	.base               = 0,
+	.ngpio              = NR_OWL_GPIO,
+	.request            = owl_gpio_request,
+	.free               = owl_gpio_free,
+	.direction_input    = owl_gpio_direction_input,
+	.direction_output   = owl_gpio_direction_output,
+	.get                = owl_gpio_get,
+	.set                = owl_gpio_set,
+	.to_irq             = owl_gpio_to_irq,
+};
+
+
+static void owl_gpio_irq_mask(struct irq_data *d)
+{
+	int gpio = d->hwirq;
+	unsigned long irq_flags;
+	unsigned int val;
+
+	spin_lock_irqsave(&owl_gpio_lock, irq_flags);
+
+	val = act_readl(GPIO_REG_INTC_MASK(gpio));
+	val &= ~GPIO_BIT(gpio);
+	act_writel(val, GPIO_REG_INTC_MASK(gpio));
+
+	if (val == 0) {
+		val = act_readl(INTC_GPIOCTL);
+		val &= ~(0x1 << (GPIO_BANK(gpio) * 5 + 1));
+		act_writel(val, INTC_GPIOCTL);
+	}
+
+	spin_unlock_irqrestore(&owl_gpio_lock, irq_flags);
+}
+
+
+static void owl_gpio_irq_unmask(struct irq_data *d)
+{
+	int gpio = d->hwirq;
+	unsigned long irq_flags;
+	unsigned int val;
+
+	spin_lock_irqsave(&owl_gpio_lock, irq_flags);
+
+	val = act_readl(GPIO_REG_INTC_MASK(gpio));
+	val |= GPIO_BIT(gpio);
+	act_writel(val, GPIO_REG_INTC_MASK(gpio));
+
+	val = act_readl(INTC_GPIOCTL);
+	val |= 0x1 << (GPIO_BANK(gpio) * 5 + 1);
+	act_writel(val, INTC_GPIOCTL);
+
+	spin_unlock_irqrestore(&owl_gpio_lock, irq_flags);
+}
+
+static void owl_gpio_irq_ack(struct irq_data *d)
+{
+	unsigned long irq_flags, bank;
+	unsigned int val;
+
+	bank = d->hwirq >> 5;
+
+	spin_lock_irqsave(&owl_gpio_lock, irq_flags);
+
+	/* clear GPIO* IRQ pending */
+	val = act_readl(INTC_GPIOCTL);
+	switch (bank) {
+	case 0:
+		val &= ~(GPIO_GBPD|GPIO_GCPD|GPIO_GDPD|GPIO_GEPD);
+		break;
+	case 1:
+		val &= ~(GPIO_GAPD|GPIO_GCPD|GPIO_GDPD|GPIO_GEPD);
+		break;
+	case 2:
+		val &= ~(GPIO_GAPD|GPIO_GBPD|GPIO_GDPD|GPIO_GEPD);
+		break;
+	case 3:
+		val &= ~(GPIO_GAPD|GPIO_GBPD|GPIO_GCPD|GPIO_GEPD);
+		break;
+	case 4:
+		val &= ~(GPIO_GAPD|GPIO_GBPD|GPIO_GCPD|GPIO_GDPD);
+		break;
+	default:
+		printk(KERN_INFO "[GPIO] %s(): invalid GPIO bank number %lu\n",
+			__func__, bank);
+		return;
+	}
+
+	act_writel(val, INTC_GPIOCTL);
+
+	spin_unlock_irqrestore(&owl_gpio_lock, irq_flags);
+}
+
+static int owl_gpio_irq_set_type(struct irq_data *d, unsigned int flow_type)
+{
+	int gpio = d->hwirq;
+	unsigned long irq_flags;
+	unsigned int type, val, offset;
+
+	spin_lock_irqsave(&owl_gpio_lock, irq_flags);
+
+	if (flow_type & IRQ_TYPE_EDGE_BOTH)
+		__irq_set_handler_locked(d->irq, handle_edge_irq);
+	else
+		__irq_set_handler_locked(d->irq, handle_level_irq);
+
+	flow_type &= IRQ_TYPE_SENSE_MASK;
+
+	switch (flow_type) {
+	case IRQ_TYPE_EDGE_RISING:
+		type = GPIO_INT_TYPE_RISING;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		type = GPIO_INT_TYPE_FALLING;
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		type = GPIO_INT_TYPE_HIGH;
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		type = GPIO_INT_TYPE_LOW;
+		break;
+	default:
+		pr_err("[GPIO] %s: gpio %d, unknow irq type %d\n",
+			__func__, gpio, flow_type);
+	return -1;
+	}
+
+	offset = (GPIO_IN_BANK(gpio) < 16) ? 4 : 0;
+	val = act_readl(GPIO_REG_INTC_TYPE(gpio)+offset);
+	val &= ~(0x3 << ((gpio%16) * 2));
+	val |= type << ((gpio%16) * 2);
+	act_writel(val, (GPIO_REG_INTC_TYPE(gpio)+offset));
+
+	spin_unlock_irqrestore(&owl_gpio_lock, irq_flags);
+
+	return 0;
+}
+
+/*
+ * When the summary IRQ is raised, any number of GPIO lines may be high.
+ * It is the job of the summary handler to find all those GPIO lines
+ * which have been set as summary IRQ lines and which are triggered,
+ * and to call their interrupt handlers.
+ */
+static void owl_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned long bank, gpio_in_bank, pending, gpioctl;
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+
+	chained_irq_enter(chip, desc);
+
+	gpioctl = act_readl(INTC_GPIOCTL);
+
+	bank = irq - OWL_IRQ_GPIOA;
+
+	if (bank >= 0 && bank < 5) {
+		if (gpioctl & (1 << ((bank * 5)))) {
+			/* check pending status in one gpio bank  */
+			pending = act_readl(GPIO_REG_INTC_PD(bank * 32));
+			while (pending != 0) {
+				gpio_in_bank = ffs(pending) - 1;
+
+				generic_handle_irq(owl_gpio_to_irq(
+				    &owl_gpio_chip, bank * 32 + gpio_in_bank));
+
+				pending &= ~GPIO_BIT(gpio_in_bank);
+			}
+		}
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static struct irq_chip owl_gpio_irq_chip = {
+	.name           = "owl-gpio-irq",
+	.irq_mask       = owl_gpio_irq_mask,
+	.irq_unmask     = owl_gpio_irq_unmask,
+	.irq_ack        = owl_gpio_irq_ack,
+	.irq_set_type   = owl_gpio_irq_set_type,
+};
+
+struct owl_gpio_bank {
+	int irq;
+};
+
+static struct owl_gpio_bank owl_gpio_banks[OWL_GPIO_BANKS];
+
+
+static struct of_device_id owl_gpio_of_match[] = {
+	{ .compatible = "actions,atm7039c-gpio"},
+	{ .compatible = "actions,atm7059a-gpio"},
+	{ },
+};
+
+static int owl_gpio_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id;
+	struct resource *res;
+	int i, irq;
+	int ret;
+
+	printk(KERN_INFO "owl_gpio_probe()\n");
+
+	of_id = of_match_device(owl_gpio_of_match, &pdev->dev);
+	if (!of_id)
+		return -EINVAL;
+
+	for (i = 0; i < OWL_GPIO_BANKS; i++) {
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, i);
+		if (res) {
+			owl_gpio_banks[i].irq = res->start;
+			printk(KERN_INFO "owl gpio bank%d - irq%d\n",
+					i, res->start);
+		} else {
+			printk(KERN_INFO "owl gpio bank%d Missing IRQ resource\n"
+					, i);
+			owl_gpio_banks[i].irq = (OWL_IRQ_GPIOA + i);
+		}
+	}
+	
+	irq_domain = irq_domain_add_linear(pdev->dev.of_node,
+					   owl_gpio_chip.ngpio, &irq_domain_simple_ops, NULL);
+
+	if (!irq_domain)
+		return -ENODEV;
+
+#ifdef CONFIG_OF_GPIO
+	owl_gpio_chip.of_node = pdev->dev.of_node;
+#endif
+
+	ret = gpiochip_add(&owl_gpio_chip);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < owl_gpio_chip.ngpio; ++i) {
+		irq = irq_create_mapping(irq_domain, i);
+		irq_set_chip_and_handler(irq, &owl_gpio_irq_chip,
+				handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	for (i = 0; i < OWL_GPIO_BANKS; i++)
+		irq_set_chained_handler(owl_gpio_banks[i].irq,
+					owl_gpio_irq_handler);
+
+
+	return 0;
+}
+
+static struct platform_driver owl_gpio_driver = {
+	.driver		= {
+		.name	= "owl-gpio",
+		.owner	= THIS_MODULE,
+		.of_match_table = owl_gpio_of_match,
+	},
+	.probe		= owl_gpio_probe,
+};
+
+static int __init owl_gpio_init(void)
+{
+	printk(KERN_INFO "owl_gpio_init()\n");
+
+	return platform_driver_register(&owl_gpio_driver);
+}
+postcore_initcall(owl_gpio_init);
diff --git a/arch/arm/mach-owl/headsmp-owl.S b/arch/arm/mach-owl/headsmp-owl.S
new file mode 100755
index 0000000..d8642e3
--- /dev/null
+++ b/arch/arm/mach-owl/headsmp-owl.S
@@ -0,0 +1,83 @@
+/*
+ * arch/arm/mach-gl5202/headsmp.S
+ *
+ * Secondary CPU startup routine source file
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+	/* __INIT */
+
+
+ENTRY(owl_v7_invalidate_l1)
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate I cache
+	mcr	p15, 2, r0, c0, c0, 0
+	mrc	p15, 1, r0, c0, c0, 0
+
+	ldr	r1, =0x7fff
+	and	r2, r1, r0, lsr #13
+
+	ldr	r1, =0x3ff
+
+	and	r3, r1, r0, lsr #3	@ NumWays - 1
+	add	r2, r2, #1		@ NumSets
+
+	and	r0, r0, #0x7
+	add	r0, r0, #4	@ SetShift
+
+	clz	r1, r3		@ WayShift
+	add	r4, r3, #1	@ NumWays
+1:	sub	r2, r2, #1	@ NumSets--
+	mov	r3, r4		@ Temp = NumWays
+2:	subs	r3, r3, #1	@ Temp--
+	mov	r5, r3, lsl r1
+	mov	r6, r2, lsl r0
+	orr	r5, r5, r6	@ Reg = (Temp<<WayShift)|(NumSets<<SetShift)
+	mcr	p15, 0, r5, c7, c6, 2
+	bgt	2b
+	cmp	r2, #0
+	bgt	1b
+	dsb
+	isb
+	mov	pc, lr
+ENDPROC(owl_v7_invalidate_l1)
+
+/*
+ * GL5202 specific entry point for secondary CPUs.
+ */
+/*
+ * GL5202 specific entry point for secondary CPU to jump from ROM
+ * code.  This routine also provides a holding flag into which
+ * secondary core is held until we're ready for it to initialise.
+ */
+ENTRY(owl_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #0xf
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:
+    ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	bl owl_v7_invalidate_l1
+	b	secondary_startup
+
+1:	.long	.
+	.long	pen_release
diff --git a/arch/arm/mach-owl/hotplug-owl.c b/arch/arm/mach-owl/hotplug-owl.c
new file mode 100755
index 0000000..14b7cef
--- /dev/null
+++ b/arch/arm/mach-owl/hotplug-owl.c
@@ -0,0 +1,1151 @@
+/* linux/arch/arm/mach-owl/hotplug-owl.c
+ *
+ * Copyright (c) 2012 actions Electronics Co., Ltd.
+ *		http://www.actions-semi.com/
+ *
+ * gs702a - Dynamic CPU hotpluging
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/sysfs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/serial_core.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/cpu.h>
+#include <linux/percpu.h>
+#include <linux/ktime.h>
+#include <linux/tick.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/suspend.h>
+#include <linux/reboot.h>
+#include <linux/gpio.h>
+#include <linux/cpufreq.h>
+#include <linux/moduleparam.h>
+#include <linux/cpufreq.h>
+#include <linux/earlysuspend.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <asm-generic/cputime.h>
+#include <linux/clk.h>
+
+#include <mach/module-owl.h>
+#include <mach/clkname.h>
+#include <mach/clkname_priv.h>
+#include <mach/cpu_map-owl.h>
+
+#define CREATE_TRACE_POINTS
+#include <trace/events/stand_hotplug.h>
+
+/*structures*/
+struct freq_tran_work {
+	struct delayed_work work;
+	unsigned int new;
+};
+
+struct early_suspend_work_t {
+	struct delayed_work work;
+	unsigned int flag;
+};
+
+struct cpu_time_info {
+	cputime64_t prev_cpu_idle;
+	cputime64_t prev_cpu_wall;
+	unsigned int load;
+};
+
+struct cpu_hotplug_info {
+	unsigned long nr_running;
+	pid_t tgid;
+};
+
+struct cpu_hotplug_rat{
+	int up_rate;
+	int down_rate;
+};
+
+enum flag{
+	HOTPLUG_NOP,
+	HOTPLUG_IN,
+	HOTPLUG_OUT
+};
+
+enum SUSPEND_STAT{
+		UP_CPU1=0x1,
+		DOWN_CPU1=0x11,
+};
+
+
+/*consts and macros*/
+#define INPUT_MODE_DETECT 0
+#define HOTPLUG_CPU_SUM CONFIG_NR_CPUS
+
+#define TRANS_LOAD_H0 (20-5)
+#define TRANS_LOAD_L1 (15-5)
+#define TRANS_LOAD_H1 30
+#define TRANS_LOAD_L2 20
+#define TRANS_LOAD_H2 60
+#define TRANS_LOAD_L3 45
+
+//#define BOOT_DELAY	60
+#define BOOT_DELAY	5
+
+#define CHECK_DELAY_ON	 (.1*HZ * 2)
+#define CHECK_DELAY_OFF  (.1*HZ)
+
+#define TRANS_RQ 2
+#define TRANS_LOAD_RQ 20
+
+#define CPU_OFF 0
+#define CPU_ON  1
+
+#define HOTPLUG_UNLOCKED 0
+#define HOTPLUG_LOCKED 1
+#define PM_HOTPLUG_DEBUG 0
+#define CPULOAD_TABLE (HOTPLUG_CPU_SUM + 1)
+#define cputime64_sub(__a, __b)		((__a) - (__b))
+
+/*debug abouts*/
+#define PRINT_PLUG_INFO 1
+#if PRINT_PLUG_INFO
+//static unsigned int g_avg_load = 0;
+#endif
+
+#define DBG_PRINT(fmt, ...)\
+	if(PM_HOTPLUG_DEBUG)			\
+		printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
+
+#define ASSERT_HOTPLUG(v)\
+if (v) printk("%s, %d erro\n", __FILE__, __LINE__)
+
+
+/*static varables*/
+#define MAX_DOWN_COUNT 1
+#ifdef MAX_DOWN_COUNT
+static int down_count = 0;
+#endif
+
+static unsigned int freq_min = 96000;
+/* static unsigned int freq_threshold_for_cpuplug = 400000; */
+static unsigned int freq_max = 0;
+static unsigned int max_performance;
+
+static struct workqueue_struct *hotplug_wq;
+static struct delayed_work hotplug_work;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend_work_t early_suspend_work;
+static struct early_suspend early_suspend;
+#endif
+
+static struct freq_tran_work freq_trans_works;
+static struct delayed_work detecting_freq_work;
+
+static unsigned int fb_lock = 0;
+static unsigned int user_lock = 1;
+static unsigned int freq_lock = 1;
+static unsigned int plug_mask = 0;
+static unsigned int plug_test = 0;
+#if INPUT_MODE_DETECT
+static unsigned long input_interval = 0;
+#endif
+
+static int work_sequence_on = 0;
+/* static unsigned int trans_rq= TRANS_RQ; */
+static unsigned int trans_load_rq = TRANS_LOAD_RQ;
+static unsigned int hotpluging_rate = CHECK_DELAY_OFF;
+
+static struct clk *cpu_clk;
+static DEFINE_MUTEX(hotplug_lock);
+static DEFINE_PER_CPU(struct cpu_time_info, hotplug_cpu_time);
+static struct cpu_hotplug_rat cpu_plug_rate_def[] = {
+		{
+			.up_rate   = .1*HZ,	//unused
+			.down_rate = .1*HZ	//after 2->1, in
+		},
+		{
+			.up_rate   = .1*HZ * 4,	//after 1->2, in or out
+			.down_rate = .1*HZ * 4	//after 3->2, in or out
+		},
+		{
+			.up_rate   = .1*HZ * 4,	//after 2->3, in or out
+			.down_rate = .1*HZ * 2	//after 4->3, in or out
+		},
+		{
+			.up_rate   = .1*HZ * 2,	//after 3->4, out
+			.down_rate = .1*HZ		//unused
+		},
+};
+
+/*load threshold*/
+static const unsigned int threshold[CPULOAD_TABLE][2] = {
+		{0, 60*1/4},
+		{12*2/4, 66*2/4},
+		{36*3/4, 60*3/4},
+		{40*4/4, 100},
+		{0, 0}
+};
+
+/*externs*/
+extern unsigned long clk_get_rate(struct clk *clk);
+extern struct clk *clk_get_sys(const char *dev_id, const char *con_id);
+extern unsigned long get_cpu_nr_running(unsigned int cpu);
+extern int __cpuinit cpu_up(unsigned int cpu);
+extern int __ref cpu_down(unsigned int cpu);
+
+static int test_cpu_not_mask(int cpu)
+{
+#if 0
+		if(cpu == 1)
+			return (plug_mask & (1<<1)) == 0;
+		else if((cpu == 2) || (cpu == 3))
+			return ((plug_mask & (1<<2)) == 0) && ((plug_mask & (1<<3)) == 0);
+		return 1;
+#endif
+	return ((plug_mask & (1 << cpu)) == 0);
+}
+
+#if INPUT_MODE_DETECT
+/*
+\D4\DA\D3\D0\D3û\A7\CA\E4\C8\EB\B5\C4\C7\E9\BF\F6\CF£\ACΪ\C1˼\F5\C9\D9\D5𵴣\AC\CC\E1\B8߿\AAcpu\C3ż\F7\A3\AC\BD\B5\B5͹\D8cpu\C3ż\F7\A3\BB
+*/
+static int check_loading_for_up(unsigned int load, int online)
+{
+		if(time_after_eq(jiffies, input_interval))
+		{
+				printk("+");
+				return load > threshold[online-1][1];
+		}
+		else
+		{
+				printk("^");
+				return load > threshold[online-1][1] + 5;
+		}
+}
+static int check_loading_for_down(unsigned int load, int online)
+{
+		if(time_after_eq(jiffies, input_interval))
+		{
+				printk("-");
+				return load < threshold[online-1][0];
+		}
+		else
+		{
+				printk("|");
+				return load < threshold[online-1][0] - 10;
+		}
+}
+#else
+static int check_loading_for_up(unsigned int load, int online)
+{
+		return load > threshold[online-1][1];
+}
+static int check_loading_for_down(unsigned int load, int online)
+{
+		return load < threshold[online-1][0];
+}
+#endif
+/*kernel fuctions*/
+static inline enum flag
+standalone_hotplug(unsigned int load, unsigned long load_min)
+{
+	unsigned int cur_freq;
+	unsigned int nr_online_cpu;
+	unsigned int avg_load;
+
+	cur_freq = clk_get_rate(cpu_clk) / 1000;
+
+	nr_online_cpu = num_online_cpus();
+	avg_load = (unsigned int)((cur_freq * load) / max_performance);
+	DBG_PRINT("avg_load=%d, cur_freq=%d, nr_running()=%ld\n", avg_load, cur_freq, nr_running());
+	DBG_PRINT("nr_online_cpu: %d, freq_max: %d\n", nr_online_cpu, freq_max);
+
+	if (nr_online_cpu > 1 && check_loading_for_down(avg_load, nr_online_cpu))
+	{
+		trace_stand_hotplug_out(1, hotpluging_rate, avg_load*4/nr_online_cpu, nr_online_cpu, down_count, 0, 0, 0);
+		goto cpu_plug_out;
+	}
+/* 	else if (nr_online_cpu > 1 && cur_freq <= freq_min)
+	{
+		trace_stand_hotplug_out(2, hotpluging_rate, 0, nr_online_cpu, down_count, 0, cur_freq, freq_min);
+		goto cpu_plug_out;
+	}	 */
+	/* If total nr_running is less than cpu(on-state) number, hotplug do not hotplug-in */
+	else if (nr_running() > nr_online_cpu &&
+		   check_loading_for_up(avg_load, nr_online_cpu) && cur_freq > freq_min)
+	{
+		down_count = 0;
+		// trace_stand_hotplug_out(5, hotpluging_rate, avg_load*4/nr_online_cpu, nr_online_cpu, down_count, 0, cur_freq, freq_min);
+		trace_stand_hotplug_in(1, hotpluging_rate, avg_load*4/nr_online_cpu, nr_online_cpu, nr_running(), cur_freq, freq_min);
+		return HOTPLUG_IN;
+	}
+	else if (nr_online_cpu > 1 && load_min < trans_load_rq)
+	{
+		/*If CPU(cpu_rq_min) load is less than trans_load_rq, hotplug-out*/
+		if (nr_online_cpu*avg_load < 100*(nr_online_cpu-1))
+		{
+			trace_stand_hotplug_out(3, hotpluging_rate, avg_load*4/nr_online_cpu, nr_online_cpu, down_count, load_min, 0, 0);
+			goto cpu_plug_out;
+		}
+	}
+
+	return HOTPLUG_NOP;
+
+cpu_plug_out:
+	/*\B8\FC\B5͵ĸ\BA\D4\D8Ӧ\B8ü\D3\CBٹر\D5cpu*/
+	if(avg_load <= 10)
+		down_count += 2;
+	else
+		down_count += 1;
+
+	if(down_count > MAX_DOWN_COUNT)
+	{
+		down_count = 0;
+		trace_stand_hotplug_out(0, hotpluging_rate, 0, nr_online_cpu, 0, 0, 0, 0);
+		return HOTPLUG_OUT;
+	}
+	else
+	{
+		return HOTPLUG_NOP;
+	}
+}
+
+static __cpuinit void cpu_hot_plug_test_for_stability(void)
+{
+		unsigned nr_online_cpu = num_online_cpus();
+		if (cpu_possible(3) && test_cpu_not_mask(3))
+		{
+			if(cpu_online(3) == CPU_OFF)
+			{
+				printk(KERN_DEBUG "cpu3 turning on start...");
+				cpu_up(3);
+				hotpluging_rate = cpu_plug_rate_def[nr_online_cpu].up_rate;
+				printk(KERN_DEBUG "end\n");
+			}
+			else
+			{
+				printk(KERN_DEBUG "cpu3 turning off start...");
+				cpu_down(3);
+				hotpluging_rate = cpu_plug_rate_def[nr_online_cpu-1].down_rate;
+				printk(KERN_DEBUG "end\n");
+			}
+		}
+		if (cpu_possible(2) && test_cpu_not_mask(2))
+		{
+			if(cpu_online(2) == CPU_OFF)
+			{
+				printk(KERN_DEBUG "cpu2 turning on start...");
+				cpu_up(2);
+				hotpluging_rate = cpu_plug_rate_def[nr_online_cpu].up_rate;
+				printk(KERN_DEBUG "end\n");
+			}
+			else
+			{
+				printk(KERN_DEBUG "cpu2 turning off start...");
+				cpu_down(2);
+				hotpluging_rate = cpu_plug_rate_def[nr_online_cpu-1].down_rate;
+				printk(KERN_DEBUG "end\n");
+			}
+		}
+		if(test_cpu_not_mask(1))
+		{
+			if(cpu_online(1) == CPU_OFF)
+			{
+				printk(KERN_DEBUG "cpu1 turning on start...");
+				cpu_up(1);
+				printk(KERN_DEBUG "end\n");
+			}
+			else
+			{
+				printk(KERN_DEBUG "cpu1 turning off start...");
+				cpu_down(1);
+				printk(KERN_DEBUG "end\n");
+			}
+		}
+}
+
+static __cpuinit void hotplug_timer(struct work_struct *work)
+{
+	struct cpu_hotplug_info tmp_hotplug_info[4];
+	int i;
+	unsigned int load = 0;
+	unsigned int load_min = 100;
+	//unsigned int select_off_cpu = 2;
+	enum flag flag_hotplug;
+	unsigned nr_online_cpu = num_online_cpus();
+
+	mutex_lock(&hotplug_lock);
+
+	/*just for test system stability*/
+	if(plug_test)
+	{
+		cpu_hot_plug_test_for_stability();
+		goto no_hotplug;
+	}
+#if 0
+	if((freq_lock == 1) &&
+		 ( ((fb_lock != 0) && (cpu_online(2) == CPU_OFF)) ||
+		   ((fb_lock == 0) && (cpu_online(1) == CPU_OFF)) )
+		)
+	{
+		/*cancel the work sequence*/
+		work_sequence_on = 0;
+		mutex_unlock(&hotplug_lock);
+		//printk("disable cpu_hot_plug\n");
+		return;
+	}
+#endif
+#if 0
+	struct timeval trace_start_tv;
+	struct timeval trace_end_tv;
+	do_gettimeofday(&trace_start_tv);
+#endif
+	if (user_lock == 1)
+	{
+		goto no_hotplug;
+	}
+
+	for_each_online_cpu(i) {
+		struct cpu_time_info *tmp_info;
+		cputime64_t cur_wall_time, cur_idle_time;
+		unsigned int idle_time, wall_time;
+
+		tmp_info = &per_cpu(hotplug_cpu_time, i);
+
+		cur_idle_time = get_cpu_idle_time_us(i, &cur_wall_time);
+
+		idle_time = (unsigned int)cputime64_sub(cur_idle_time,
+							tmp_info->prev_cpu_idle);
+		tmp_info->prev_cpu_idle = cur_idle_time;
+
+		wall_time = (unsigned int)cputime64_sub(cur_wall_time,
+							tmp_info->prev_cpu_wall);
+		tmp_info->prev_cpu_wall = cur_wall_time;
+
+		if (wall_time < idle_time)
+			goto no_hotplug;
+
+		if (wall_time == 0)	wall_time++;
+
+		tmp_info->load = 100 * (wall_time - idle_time) / wall_time;
+
+		load += tmp_info->load;
+		/*find minimum runqueue length*/
+		tmp_hotplug_info[i].nr_running = get_cpu_nr_running(i);
+
+		if (load_min > tmp_info->load) {
+			load_min = tmp_info->load;
+		}
+	}
+
+	/*standallone hotplug*/
+	flag_hotplug = standalone_hotplug(load, load_min);
+
+	/*cpu hotplug*/
+	if (flag_hotplug == HOTPLUG_IN)
+	{
+		if(test_cpu_not_mask(1) && (cpu_online(1) == CPU_OFF))
+		{
+			printk(KERN_DEBUG "cpu1 turning on start...");
+			mutex_unlock(&hotplug_lock);
+			cpu_up(1);
+			mutex_lock(&hotplug_lock);
+			hotpluging_rate = cpu_plug_rate_def[nr_online_cpu].up_rate;
+			printk(KERN_DEBUG "end\n");
+			goto no_hotplug;
+		}
+		if (cpu_possible(2) && test_cpu_not_mask(2) && (cpu_online(2) == CPU_OFF))
+		{
+			printk(KERN_DEBUG "cpu2 turning on start...");
+			mutex_unlock(&hotplug_lock);
+			cpu_up(2);/*up cpu2*/
+			mutex_lock(&hotplug_lock);
+			hotpluging_rate = cpu_plug_rate_def[nr_online_cpu].up_rate;
+			printk(KERN_DEBUG "end\n");
+			goto no_hotplug;
+		}
+		if (cpu_possible(3) && test_cpu_not_mask(3) && (cpu_online(3) == CPU_OFF))
+		{
+			printk(KERN_DEBUG "cpu3 turning on start...");
+			mutex_unlock(&hotplug_lock);
+			cpu_up(3);/*up cpu3*/
+			mutex_lock(&hotplug_lock);
+			hotpluging_rate = cpu_plug_rate_def[nr_online_cpu].up_rate;
+			printk(KERN_DEBUG "end\n");
+			goto no_hotplug;
+		}
+	}
+	else if (flag_hotplug == HOTPLUG_OUT)
+	{
+		if (test_cpu_not_mask(3) && (cpu_online(3) == CPU_ON))
+		{
+			printk(KERN_DEBUG "cpu3 turning off start...");
+			mutex_unlock(&hotplug_lock);
+			cpu_down(3);/*down cpu3*/
+			mutex_lock(&hotplug_lock);
+			hotpluging_rate = cpu_plug_rate_def[nr_online_cpu-2].down_rate;
+			printk(KERN_DEBUG "end\n");
+			goto no_hotplug;
+		}
+
+		if (test_cpu_not_mask(2) && (cpu_online(2) == CPU_ON))
+		{
+			printk(KERN_DEBUG "cpu2 turning off start...");
+			mutex_unlock(&hotplug_lock);
+			cpu_down(2);/*down cpu2*/
+			mutex_lock(&hotplug_lock);
+			hotpluging_rate = cpu_plug_rate_def[nr_online_cpu-2].down_rate;
+			printk(KERN_DEBUG "end\n");
+			goto no_hotplug;
+		}
+
+	    if(cpu_possible(2))
+	    {
+	        if(fb_lock == 0)
+	        {
+	           if(test_cpu_not_mask(1) && (cpu_online(1) == CPU_ON))
+	           {
+					printk(KERN_DEBUG "cpu1 turning off start...");
+					mutex_unlock(&hotplug_lock);
+					cpu_down(1);
+					mutex_lock(&hotplug_lock);
+					hotpluging_rate = cpu_plug_rate_def[nr_online_cpu-2].down_rate;
+					printk(KERN_DEBUG "end\n");
+					goto no_hotplug;
+	           }
+	        }
+	    }
+	    else
+	    {
+	       if(test_cpu_not_mask(1) && (cpu_online(1) == CPU_ON))
+	       {
+				printk(KERN_DEBUG "cpu1 turning off start...");
+				mutex_unlock(&hotplug_lock);
+				cpu_down(1);
+				mutex_lock(&hotplug_lock);
+				hotpluging_rate = cpu_plug_rate_def[nr_online_cpu-2].down_rate;
+				printk(KERN_NOTICE "end\n");
+				goto no_hotplug;
+			}
+		}
+	}
+
+no_hotplug:
+	queue_delayed_work_on(0, hotplug_wq, &hotplug_work, hotpluging_rate);
+	mutex_unlock(&hotplug_lock);
+#if 0
+	do_gettimeofday(&trace_end_tv);
+	long time_us = (trace_end_tv.tv_sec - trace_start_tv.tv_sec)*1000000 + \
+			 (trace_end_tv.tv_usec- trace_start_tv.tv_usec);
+	printk("used time: %d\n", time_us);
+#endif
+}
+
+/*notifiers*/
+static int owl_pm_hotplug_notifier_event(struct notifier_block *this,
+					     unsigned long event, void *ptr)
+{
+	static unsigned user_lock_saved;
+
+	switch (event) {
+	case PM_SUSPEND_PREPARE:
+	case PM_HIBERNATION_PREPARE:
+	case PM_RESTORE_PREPARE:
+		mutex_lock(&hotplug_lock);
+		user_lock_saved = user_lock;
+		user_lock = 1;
+		DBG_PRINT("%s: saving pm_hotplug lock %x\n",
+			__func__, user_lock_saved);
+		disable_nonboot_cpus();
+		mutex_unlock(&hotplug_lock);
+		return NOTIFY_OK;
+	case PM_POST_SUSPEND:
+	case PM_POST_HIBERNATION:
+	case PM_POST_RESTORE:
+		mutex_lock(&hotplug_lock);
+		DBG_PRINT("%s: restoring pm_hotplug lock %x\n",
+			__func__, user_lock_saved);
+		user_lock = user_lock_saved;
+		mutex_unlock(&hotplug_lock);
+		return NOTIFY_OK;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block owl_pm_hotplug_notifier = {
+	.notifier_call = owl_pm_hotplug_notifier_event,
+};
+
+static int hotplug_reboot_notifier_call(struct notifier_block *this,
+					unsigned long code, void *_cmd)
+{
+	mutex_lock(&hotplug_lock);
+	DBG_PRINT("%s: disabling pm hotplug\n", __func__);
+	user_lock = 1;
+	mutex_unlock(&hotplug_lock);
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block hotplug_reboot_notifier = {
+	.notifier_call = hotplug_reboot_notifier_call,
+};
+
+
+#ifdef CONFIG_CPU_FREQ
+static void get_cpu0_cpuinfo_policy(void)
+{
+	struct cpufreq_policy *cpu_policy;
+
+	/* get cpu0 policy */
+	cpu_policy = cpufreq_cpu_get(0);
+	freq_max = cpu_policy->max;
+	freq_min = cpu_policy->min;
+	max_performance = freq_max * HOTPLUG_CPU_SUM;
+	DBG_PRINT("%s, cpu_policy->max %d, cpu_policy->min %d\n",
+		__func__, cpu_policy->max, cpu_policy->min);
+	DBG_PRINT("%s, freq_min %d, freq_max %d, HOTPLUG_CPU_SUM: %d\n",
+		__func__, freq_min, freq_max, HOTPLUG_CPU_SUM);
+}
+
+static int owl_cpufreq_for_cpuhotplug(struct notifier_block *nb,
+				      unsigned long state, void *data)
+{
+	if (state == CPUFREQ_NOTIFY)
+		get_cpu0_cpuinfo_policy();
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block owl_cpufreq_for_cpuhotplug_nb = {
+	.notifier_call = owl_cpufreq_for_cpuhotplug,
+};
+#else
+static void get_cpu0_cpuinfo_policy(void) {}
+#endif
+
+static void start_cpu_hot_plug(int delay)
+{
+	queue_delayed_work_on(0, hotplug_wq, &hotplug_work, delay);
+}
+
+static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
+		unsigned long val, void *data)
+{
+	//int orgize_todo = 0;
+	struct cpufreq_freqs *freq = data;
+
+	if ((val != CPUFREQ_POSTCHANGE) || (freq->cpu != 0) )
+		return 0;
+	freq_trans_works.new = freq->new;
+	queue_delayed_work_on(0, hotplug_wq, &(freq_trans_works.work), 0);
+	return 0;
+}
+
+static void adjust_hot_plug_with_freq(struct work_struct *work)
+{
+/* 	struct freq_tran_work *freq_tran_workp = (struct freq_tran_work*)work;
+	if ((freq_tran_workp->new > freq_max/2)
+		&& (freq_tran_workp->new > freq_threshold_for_cpuplug))
+	{
+		if (mutex_is_locked(&hotplug_lock))
+		mutex_lock(&hotplug_lock);
+		if(work_sequence_on == 0)
+				start_cpu_hot_plug(0);
+		freq_lock = 0;
+		work_sequence_on = 1;
+		mutex_unlock(&hotplug_lock);
+		//printk("enable cpu_hot_plug, freq: %d, thresh: %d\n", freq_tran_workp->new, freq_max/2);
+	}
+	else
+	{
+		mutex_lock(&hotplug_lock);
+		freq_lock = 1;
+		//printk( "freq_lock: %d, freq: %d, thresh: %d\n", freq_lock, freq_tran_workp->new, freq_max/2);
+		mutex_unlock(&hotplug_lock);
+	}
+ */
+}
+
+static struct notifier_block notifier_freqtrans_block = {
+	.notifier_call = cpufreq_stat_notifier_trans
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static __cpuinit void early_suspend_process(struct work_struct *work)
+{
+		struct early_suspend_work_t *tmp = (struct early_suspend_work_t *)work;
+		switch(tmp->flag)
+		{
+			case UP_CPU1:
+				//printk( "early_suspend_process UP_CPU1 start ...");
+				//if(cpu_online(1) == CPU_OFF)
+				//	cpu_up(1);
+				mutex_lock(&hotplug_lock);
+				fb_lock = 1;
+				mutex_unlock(&hotplug_lock);
+				//printk( "end\n");
+				break;
+			case DOWN_CPU1:
+				//printk( "early_suspend_process DOWN start ...");
+				//if(cpu_online(1) == CPU_ON)
+				//	cpu_down(1);
+				mutex_lock(&hotplug_lock);
+				fb_lock = 0;
+				mutex_unlock(&hotplug_lock);
+				//printk( "end\n");
+				break;
+			default:
+				printk("wrong falg: 0x%08x\n", tmp->flag);
+		}
+}
+
+static void hotplug_early_suspend(struct early_suspend *h)
+{
+/* 	early_suspend_work.flag = DOWN_CPU1;
+	printk( "hotplug_early_suspend\n");
+	queue_delayed_work_on(0, hotplug_wq, &(early_suspend_work.work), 0); */
+}
+
+static void hotplug_late_resume(struct early_suspend *h)
+{
+/* 	early_suspend_work.flag = UP_CPU1;
+	printk( "hotplug_late_resume\n");
+	queue_delayed_work_on(0, hotplug_wq, &(early_suspend_work.work), 0); */
+}
+#endif
+
+/*input about*/
+struct cpuplug_inputopen {
+	struct input_handle *handle;
+	struct work_struct inputopen_work;
+};
+#if INPUT_MODE_DETECT
+static struct cpuplug_inputopen inputopen;
+static void cpuplug_input_event(struct input_handle *handle,
+					    unsigned int type,
+					    unsigned int code, int value)
+{
+	input_interval = jiffies + 30*HZ;
+}
+
+static void cpuplug_input_open(struct work_struct *w)
+{
+	struct cpuplug_inputopen *io =
+		container_of(w, struct cpuplug_inputopen,
+			     inputopen_work);
+	int error;
+
+	error = input_open_device(io->handle);
+	if (error)
+		input_unregister_handle(io->handle);
+}
+
+static int cpuplug_input_connect(struct input_handler *handler,
+					     struct input_dev *dev,
+					     const struct input_device_id *id)
+{
+	struct input_handle *handle;
+	int error;
+
+	printk("%s: connect to %s\n", __func__, dev->name);
+	handle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "cpuplug";
+
+	error = input_register_handle(handle);
+	if (error)
+		goto err;
+
+	inputopen.handle = handle;
+	queue_work(hotplug_wq, &inputopen.inputopen_work);
+	return 0;
+
+err:
+	kfree(handle);
+	return error;
+}
+
+static void cpuplug_input_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id cpuplug_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
+			 INPUT_DEVICE_ID_MATCH_ABSBIT,
+		.evbit = { BIT_MASK(EV_ABS) },
+		.absbit = { [BIT_WORD(ABS_MT_POSITION_X)] =
+			    BIT_MASK(ABS_MT_POSITION_X) |
+			    BIT_MASK(ABS_MT_POSITION_Y) },
+	}, /* multi-touch touchscreen */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_KEYBIT |
+			 INPUT_DEVICE_ID_MATCH_ABSBIT,
+		.keybit = { [BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH) },
+		.absbit = { [BIT_WORD(ABS_X)] =
+			    BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) },
+	}, /* touchpad */
+	{ },
+};
+
+static struct input_handler cpuplug_input_handler = {
+	.event          = cpuplug_input_event,
+	.connect       = cpuplug_input_connect,
+	.disconnect   = cpuplug_input_disconnect,
+	.name          = "cpuplug",
+	.id_table      = cpuplug_ids,
+};
+#endif
+
+static void set_cpu_frequence(struct work_struct *work)
+{
+#if 0
+	int i;
+	unsigned int freq;
+#endif
+	struct cpufreq_frequency_table *table;
+
+	table = cpufreq_frequency_get_table(0);
+	if(NULL == table)
+	{
+		queue_delayed_work_on(0, hotplug_wq, &detecting_freq_work, HZ);
+		DBG_PRINT("cpu hot plug set_cpu_frequence, cpufrequnce set failed\n");
+		return;
+	}
+
+#if 0
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; ) {
+		freq = table[i].frequency;
+		i++;
+		if(table[i].frequency == CPUFREQ_TABLE_END)
+			break;
+		if (freq > freq_max)
+			freq_max = freq;
+		if (freq_min > freq)
+			freq_min = freq;
+	}
+	/*get max frequence*/
+	max_performance = freq_max * HOTPLUG_CPU_SUM;
+	DBG_PRINT("freq_min %d\n", freq_min);
+	DBG_PRINT("freq_max %d, HOTPLUG_CPU_SUM: %d\n", freq_max, HOTPLUG_CPU_SUM);
+	DBG_PRINT(KERN_INFO "cpu hot plug set_cpu_frequence, cpufrequnce set ok\n");
+#else
+	get_cpu0_cpuinfo_policy();
+#endif
+
+	start_cpu_hot_plug(BOOT_DELAY * HZ);
+
+	/*enable cpu hot plug*/
+	mutex_lock(&hotplug_lock);
+	user_lock = 0;
+	freq_lock = 0;
+	/*on default, sequence work is on duty*/
+	work_sequence_on = 1;
+	mutex_unlock(&hotplug_lock);
+
+	if (cpufreq_register_notifier(&notifier_freqtrans_block, CPUFREQ_TRANSITION_NOTIFIER))
+	{
+		printk("cpufreq_register_notifier failed\n");
+		return;
+	}
+
+#if INPUT_MODE_DETECT
+	if (input_register_handler(&cpuplug_input_handler))
+		printk("%s: failed to register input handler\n",	__func__);
+#endif
+	return;
+}
+
+/*sys interface*/
+static ssize_t show_usr_lock(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	return sprintf(buf, "%u\n", user_lock);
+}
+
+int set_user_lock(int val)
+{
+	int ret=0;
+	if((val == 0) || (val == 1))
+	{
+		mutex_lock(&hotplug_lock);
+		user_lock = val;
+		mutex_unlock(&hotplug_lock);
+		printk(KERN_DEBUG "%s: user_lock: %d\n", __func__, user_lock);	
+	}
+	else
+	{
+		ret = -EINVAL;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(set_user_lock);
+
+static ssize_t __ref store_usr_lock(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	ssize_t ret = count;
+	
+	switch (buf[0]) {
+	case '0':
+		set_user_lock(0);
+		break;	
+	case '1':
+		set_user_lock(1);
+		break;
+	default:
+		DBG_PRINT("%s: user_lock: %d\n", __func__, user_lock);
+		ret = -EINVAL;
+	}
+	return count;
+}
+static DEVICE_ATTR(usr_lock, 0644, show_usr_lock,  store_usr_lock);
+static ssize_t show_freq_lock(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	return sprintf(buf, "%u\n", freq_lock);
+}
+static DEVICE_ATTR(freq_lock, 0644, show_freq_lock,  NULL);
+
+static ssize_t __ref store_fb_lock(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	ssize_t ret = count;
+	switch (buf[0]) {
+	case '0':
+		mutex_lock(&hotplug_lock);
+		fb_lock = 0;
+		mutex_unlock(&hotplug_lock);
+		break;
+	case '1':
+		mutex_lock(&hotplug_lock);
+		fb_lock = 1;
+		mutex_unlock(&hotplug_lock);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return count;
+}
+static ssize_t show_fb_lock(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	return sprintf(buf, "%u\n", fb_lock);
+}
+static DEVICE_ATTR(fb_lock, 0644, show_fb_lock, store_fb_lock);
+
+static int time_flag_2 = 0;
+
+static ssize_t show_time_2(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	return sprintf(buf, "%u\n", time_flag_2);
+}
+static ssize_t __ref store_time_2(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	ssize_t ret = count;
+	switch (buf[0]) {
+	case '0':
+		time_flag_2 = 0;
+		break;
+	case '1':
+		time_flag_2 = 1;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(opt2, 0644, show_time_2,  store_time_2);
+
+/*sys interface*/
+static ssize_t show_plug_mask(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	return sprintf(buf, "0x%01x\n", plug_mask);
+}
+/*extern int enable_plug_mask;
+*/
+int set_plug_mask(int val)
+{
+	int ret=0;
+	mutex_lock(&hotplug_lock);
+	plug_mask = val;
+	mutex_unlock(&hotplug_lock);
+	return ret;
+}
+EXPORT_SYMBOL(set_plug_mask);
+
+static ssize_t __ref store_plug_mask(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+/*	if(enable_plug_mask == 0)
+		return count;
+*/
+	mutex_lock(&hotplug_lock);
+	sscanf(buf, "0x%01x", &plug_mask);
+	mutex_unlock(&hotplug_lock);
+	printk("plug_mask :0x%08x\n", plug_mask);
+	return count;
+}
+static DEVICE_ATTR(plug_mask, 0644, show_plug_mask,  store_plug_mask);
+
+static ssize_t show_plug_test(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	return sprintf(buf, "0x%01x\n", plug_test);
+}
+/*extern int enable_plug_mask;
+*/
+static ssize_t __ref store_plug_test(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+/*	if(enable_plug_mask == 0)
+		return count;
+*/
+	mutex_lock(&hotplug_lock);
+	sscanf(buf, "0x%01x", &plug_test);
+	mutex_unlock(&hotplug_lock);
+	printk("plug_test :0x%08x\n", plug_test);
+	return count;
+}
+static DEVICE_ATTR(plug_test, 0644, show_plug_test,  store_plug_test);
+
+static struct attribute *cpuplug_lock_attrs[] = {
+	&dev_attr_usr_lock.attr,
+	&dev_attr_fb_lock.attr,
+	&dev_attr_freq_lock.attr,
+	&dev_attr_plug_mask.attr,
+	&dev_attr_plug_test.attr,
+	&dev_attr_opt2.attr,
+	NULL
+};
+
+static struct attribute_group cpuplug_attr_group = {
+	.attrs = cpuplug_lock_attrs,
+	.name = "autoplug",
+};
+/**
+ * cpuplug_add_interface - add CPU global sysfs attributes
+ */
+int cpuplug_add_interface(struct device *dev)
+{
+	return sysfs_create_group(&dev->kobj, &cpuplug_attr_group);
+}
+
+/*inits*/
+int owl_pm_hotplug_init(void)
+{
+	//unsigned int i;
+	//unsigned int freq;
+	return 0;
+	//hotplug_wq = create_workqueue("dynamic hotplug");
+	hotplug_wq = alloc_workqueue("dynamic hotplug", 0, 0);
+	if (!hotplug_wq) {
+		DBG_PRINT("Creation of hotplug work failed\n");
+		return -EFAULT;
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	/*early_suspend cpu hot plug*/
+	INIT_DELAYED_WORK(&(early_suspend_work.work), early_suspend_process);
+	early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB;
+	early_suspend.suspend = hotplug_early_suspend;
+	early_suspend.resume  = hotplug_late_resume;
+	register_early_suspend(&early_suspend);
+#endif
+
+	if(HOTPLUG_CPU_SUM <= 2)
+	{
+		/*work on default*/
+		user_lock = 0;
+		return 0;
+	}
+
+
+	//INIT_DELAYED_WORK(&hotplug_work, hotplug_timer);
+	INIT_DELAYED_WORK(&hotplug_work, hotplug_timer);
+	INIT_DELAYED_WORK(&(freq_trans_works.work), adjust_hot_plug_with_freq);
+	INIT_DELAYED_WORK(&detecting_freq_work, set_cpu_frequence);
+#if INPUT_MODE_DETECT
+	INIT_WORK(&inputopen.inputopen_work, cpuplug_input_open);
+#endif
+
+	queue_delayed_work_on(0, hotplug_wq, &detecting_freq_work, HZ);
+
+	/*default values when system booting*/
+	user_lock = 1;
+	freq_min = 96000;
+	freq_max = clk_get_rate(cpu_clk) / 1000;
+	max_performance = freq_max * HOTPLUG_CPU_SUM;
+
+
+	DBG_PRINT("freq_min %d\n", freq_min);
+	DBG_PRINT("freq_max %d, HOTPLUG_CPU_SUM: %d\n", freq_max, HOTPLUG_CPU_SUM);
+
+	register_pm_notifier(&owl_pm_hotplug_notifier);
+	register_reboot_notifier(&hotplug_reboot_notifier);
+	cpufreq_register_notifier(&owl_cpufreq_for_cpuhotplug_nb,
+		CPUFREQ_POLICY_NOTIFIER);
+
+	/*on default, sequence work of detecting cpufreq driver is on duty*/
+	work_sequence_on = 1;
+
+	return 0;
+}
+late_initcall(owl_pm_hotplug_init);
+
+static struct platform_device owl_pm_hotplug_device = {
+	.name = "owl-dynamic-cpu-hotplug",
+	.id = -1,
+};
+
+extern int clk_enable(struct clk *c);
+static int __init owl_pm_hotplug_device_init(void)
+{
+	int ret;
+	return 0;
+	ret = platform_device_register(&owl_pm_hotplug_device);
+	if (ret) {
+		DBG_PRINT("failed at(%d)\n", __LINE__);
+		return ret;
+	}
+
+	ret = cpuplug_add_interface(cpu_subsys.dev_root);
+	if (ret) {
+		DBG_PRINT("failed at(%d)\n", __LINE__);
+		return ret;
+	}
+
+	DBG_PRINT("owl_pm_hotplug_device_init: %d\n", ret);
+
+	cpu_clk = clk_get(NULL, CLKNAME_CPU_CLK);
+	if (IS_ERR(cpu_clk))
+	{
+		DBG_PRINT("owl_pm_hotplug_device_init clk_get_sys failed\n");
+		return PTR_ERR(cpu_clk);
+  }
+	/*clk_enable(cpu_clk);
+	*/
+
+	return ret;
+}
+
+late_initcall(owl_pm_hotplug_device_init);
diff --git a/arch/arm/mach-owl/hotplug_base-owl.c b/arch/arm/mach-owl/hotplug_base-owl.c
new file mode 100755
index 0000000..922c2be
--- /dev/null
+++ b/arch/arm/mach-owl/hotplug_base-owl.c
@@ -0,0 +1,133 @@
+/*
+ * arch/arm/mach-owl/hotplug_base-owl.c
+ *
+ * cpu hotplug stuff for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+
+#include <asm/cp15.h>
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+#include <asm/smp_scu.h>
+
+#include <mach/hardware.h>
+
+extern volatile int pen_release;
+
+static inline void cpu_enter_lowpower(void)
+{
+	unsigned int v;
+
+	/*flush_cache_all();*/
+	/*
+	Invalidate all instruction caches to PoU. Also flushes branch target cache.
+	Clean data cache line to PoC by VA.
+	Disable data coherency with other cores in the Cortex-A9 MPCore processor.(ACTLR)
+	Data caching disabled at all levels.(SCTLR)
+	*/
+	asm volatile(
+	"	mcr	p15, 0, %1, c7, c5, 0\n"
+	"	mcr	p15, 0, %1, c7, c10, 4\n"
+	/*
+	 * Turn off coherency
+	 */
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	bic	%0, %0, %3\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	"	mrc	p15, 0, %0, c1, c0, 0\n"
+	"	bic	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	  : "=&r" (v)
+	  : "r" (0), "Ir" (CR_C), "Ir" (0x40)
+	  : "cc");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+	asm volatile(
+	"mrc	p15, 0, %0, c1, c0, 0\n"
+	"	orr	%0, %0, %1\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	orr	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	  : "=&r" (v)
+	  : "Ir" (CR_C), "Ir" (0x40)
+	  : "cc");
+}
+
+static void __iomem *scu_base_addr(void)
+{
+    return (void *)IO_ADDRESS(OWL_PA_SCU);
+}
+
+extern void cpu_reset_to_brom( void );
+static inline void platform_do_lowpower(unsigned int cpu)
+{
+	void __iomem *scu_base = scu_base_addr();
+
+	flush_cache_all();
+	cpu_enter_lowpower();
+
+	/* we put the platform to just WFI */
+	for (;;) {
+		
+		if ((cpu >= 1) && (cpu < NR_CPUS))
+		{
+			if (cpu == 1)
+			{
+				cpu_reset_to_brom();
+			}
+			else
+			{
+				scu_power_mode(scu_base, 0x3);
+			}
+		}
+		__asm__ __volatile__("dsb\n\t" "wfi\n\t"
+				: : : "memory");
+		if (pen_release == cpu_logical_map(cpu)) {
+			/*
+			 * OK, proper wakeup, we're done
+			 */
+			break;
+		}
+	}
+	cpu_leave_lowpower();
+}
+
+int owl_cpu_kill(unsigned int cpu)
+{
+	return 1;
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void owl_cpu_die(unsigned int cpu)
+{
+	/* directly enter low power state, skipping secure registers */
+	platform_do_lowpower(cpu);
+}
+
+int owl_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-owl/i2c-owl.c b/arch/arm/mach-owl/i2c-owl.c
new file mode 100755
index 0000000..7b5d2ad
--- /dev/null
+++ b/arch/arm/mach-owl/i2c-owl.c
@@ -0,0 +1,1521 @@
+/*
+ * arch/arm/mach-owl/i2c-owl.c
+ *
+ * I2C master mode controller driver for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <linux/errno.h>
+#include <linux/ctype.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <mach/clkname.h>
+#include <mach/module-owl.h>
+
+static int info_switch;
+static int err_switch;
+
+//#define I2C_DEBUG_INFO
+#define I2C_DEBUG_WARNING
+#define owl_dump_mem(a, b, c, d)           do {} while (0);
+
+/* support FIFO read/write */
+#define OWL_I2C_SUPPORT_FIFO
+#define OWL_FIFO_MAX_DATA_LENGTH           120
+#define OWL_FIFO_MAX_INTER_ADDR_LENGTH     7
+
+/* don't use FIFO mode for HDMI HDCP because of incompatible timing */
+#define OWL_I2C_SUPPORT_HDMI_NOFIFO
+//#define I2C_DEBUG_INFO
+//#define I2C_DEBUG_WARNING
+#ifdef I2C_DEBUG_INFO
+#define i2c_dbg(fmt, args...)   \
+    printk(KERN_INFO fmt, ##args)
+#else
+#define i2c_dbg(fmt, args...)   \
+    do {} while(0)
+#endif
+
+#ifdef I2C_DEBUG_WARNING
+#define i2c_warn(fmt, args...)  \
+    printk(KERN_WARNING "owl_i2c: "fmt"\n", ##args)
+#else
+#define i2c_warn(fmt, args...)   \
+    do {} while(0)
+#endif
+
+#ifdef I2C_DEBUG_SWITCH
+#define i2c_info(fmt, args...) do { \
+	if (info_switch) \
+		pr_info(fmt"\n", ##args); \
+	} while (0)
+
+#define i2c_err(fmt, args...)  do { \
+	if (err_switch) \
+		pr_err(fmt"\n", ##args); \
+	} while (0)
+#else
+	#define i2c_info(fmt, args...)
+	#define i2c_err(fmt, args...)
+#endif
+
+
+#define I2C_CTL                     0x0000          /* I2C Control Register */
+#define I2C_CLKDIV                  0x0004          /* I2C Clock Divide Register */
+#define I2C_STAT                    0x0008          /* I2C Status Register */
+#define I2C_ADDR                    0x000C          /* I2C Address Register */
+#define I2C_TXDAT                   0x0010          /* I2C TX Data Register */
+#define I2C_RXDAT                   0x0014          /* I2C RX Data Register */
+#define I2C_CMD                     0x0018          /* I2C Command Register */
+#define I2C_FIFOCTL                 0x001C          /* I2C FIFO control Register */
+#define I2C_FIFOSTAT                0x0020          /* I2C FIFO status Register */
+#define I2C_DATCNT                  0x0024          /* I2C Data transmit counter */
+#define I2C_RCNT                    0x0028          /* I2C Data transmit remain counter */
+
+/* I2Cx_CTL */
+#define I2C_CTL_GRAS                (0x1 << 0)      /* Generate ACK or NACK Signal */
+#define I2C_CTL_GRAS_ACK            0            /* generate the ACK signal at 9th clock of SCL */
+#define I2C_CTL_GRAS_NACK           I2C_CTL_GRAS /* generate the NACK signal at 9th clock of SCL */
+#define I2C_CTL_RB                  (0x1 << 1)     /* Release Bus */
+#define I2C_CTL_GBCC_MASK           (0x3 << 2)     /* Loop Back Enable */
+#define I2C_CTL_GBCC(x)             (((x) & 0x3) << 2)
+#define I2C_CTL_GBCC_NONE           I2C_CTL_GBCC(0)
+#define I2C_CTL_GBCC_START          I2C_CTL_GBCC(1)
+#define I2C_CTL_GBCC_STOP           I2C_CTL_GBCC(2)
+#define I2C_CTL_GBCC_RESTART        I2C_CTL_GBCC(3)
+#define I2C_CTL_IRQE                (0x1 << 5)     /* IRQ Enable */
+#define I2C_CTL_PUEN                (0x1 << 6)     /* Internal Pull-Up resistor (1.5k) enable. */
+#define I2C_CTL_EN                  (0x1 << 7)     /* Enable. When enable, reset the status machine to IDLE */
+#define I2C_CTL_AE                  (0x1 << 8)     /* Arbitor enable */
+
+/* I2Cx_CLKDIV */
+#define I2C_CLKDIV_DIV_MASK         (0xff << 0)     /* Clock Divider Factor (only for master mode). */
+#define I2C_CLKDIV_DIV(x)           (((x) & 0xff) << 0)
+
+/* I2Cx_STAT */
+#define I2C_STAT_RACK               (0x1 << 0)      /* Receive ACK or NACK when transmit data or address */
+#define I2C_STAT_BEB                (0x1 << 1)      /* IRQ Pending Bit, Write \A1\B01\A1\B1 to clear this bit */
+#define I2C_STAT_IRQP               (0x1 << 2)      /* IRQ Pending Bit, Write \A1\B01\A1\B1 to clear this bit */
+#define I2C_STAT_LAB                (0x1 << 3)      /* Lose arbitration bit, Write \A1\B01\A1\B1 to clear this bit */
+#define I2C_STAT_STPD               (0x1 << 4)      /* Stop detect bit, Write \A1\B01\A1\B1 to clear this bit */
+#define I2C_STAT_STAD               (0x1 << 5)      /* Start detect bit, Write \A1\B01\A1\B1 to clear this bit */
+#define I2C_STAT_BBB                (0x1 << 6)      /* Bus busy bit */
+#define I2C_STAT_TCB                (0x1 << 7)      /* Transfer complete bit */
+#define I2C_STAT_LBST               (0x1 << 8)      /* Last Byte Status Bit, 0: address, 1: data */
+#define I2C_STAT_SAMB               (0x1 << 9)      /* Slave address match bit */
+#define I2C_STAT_SRGC               (0x1 << 10)     /* Slave receive general call */
+
+#define I2C_BUS_ERR_MSK             ( I2C_STAT_LAB | I2C_STAT_BEB)
+
+/* I2Cx_CMD */
+#define I2C_CMD_SBE                 (0x1 << 0)      /* Start bit enable */
+#define I2C_CMD_AS_MASK             (0x7 << 1)      /* Address select */
+#define I2C_CMD_AS(x)               (((x) & 0x7) << 1)
+#define I2C_CMD_RBE                 (0x1 << 4)      /* Restart bit enable */
+#define I2C_CMD_SAS_MASK            (0x7 << 5)      /* Second Address select */
+#define I2C_CMD_SAS(x)              (((x) & 0x7) << 5)
+#define I2C_CMD_DE                  (0x1 << 8)      /* Data enable */
+#define I2C_CMD_NS                  (0x1 << 9)      /* NACK select */
+#define I2C_CMD_SE                  (0x1 << 10)     /* Stop enable */
+#define I2C_CMD_MSS                 (0x1 << 11)     /* MSS Master or slave mode select */
+#define I2C_CMD_WRS                 (0x1 << 12)     /* Write or Read select */
+#define I2C_CMD_EXEC                (0x1 << 15)     /* Start to execute the command list */
+
+/* I2Cx_FIFOCTL */
+#define I2C_FIFOCTL_NIB             (0x1 << 0)      /* NACK Ignore Bit */
+#define I2C_FIFOCTL_RFR             (0x1 << 1)      /* RX FIFO reset bit, Write 1 to reset RX FIFO */
+#define I2C_FIFOCTL_TFR             (0x1 << 2)      /* TX FIFO reset bit, Write 1 to reset TX FIFO */
+
+/* I2Cx_FIFOSTAT */
+#define I2C_FIFOSTAT_CECB           (0x1 << 0)      /* command Execute Complete bit */
+#define I2C_FIFOSTAT_RNB            (0x1 << 1)      /* Receive NACK Error bit */
+#define I2C_FIFOSTAT_RFE            (0x1 << 2)      /* RX FIFO empty bit */
+#define I2C_FIFOSTAT_RFF            (0x1 << 3)      /* RX FIFO full bit */
+#define I2C_FIFOSTAT_TFE            (0x1 << 4)      /* TX FIFO empty bit */
+#define I2C_FIFOSTAT_TFF            (0x1 << 5)      /* TX FIFO full bit */
+#define I2C_FIFOSTAT_RFD_MASK       (0xff << 8)     /* Rx FIFO level display */
+#define I2C_FIFOSTAT_RFD_SHIFT      (8)
+#define I2C_FIFOSTAT_TFD_MASK       (0xff << 16)    /* Tx FIFO level display */
+#define I2C_FIFOSTAT_TFD_SHIFT      (16)
+
+#define I2C_CTL_START_CMD               (  \
+          I2C_CTL_IRQE |   \
+          I2C_CTL_EN |     \
+          I2C_CTL_GBCC_START |    \
+          I2C_CTL_PUEN |     \
+          I2C_CTL_RB   \
+         )
+
+#define I2C_CTL_STOP_CMD                (  \
+            I2C_CTL_EN |  \
+            I2C_CTL_PUEN | \
+            I2C_CTL_GBCC_STOP | \
+            I2C_CTL_RB | \
+            I2C_CTL_IRQE \
+        )
+
+#define I2C_CTL_RESTART_CMD             ( \
+            I2C_CTL_IRQE | \
+            I2C_CTL_EN | \
+            I2C_CTL_GBCC_RESTART | \
+            I2C_CTL_PUEN | \
+            I2C_CTL_RB \
+        )
+#define I2C_MODULE_CLK		(100*1000*1000)
+#define I2C_CLK_HDMI                    (87*1000)
+#define I2C_TRANS_TIMEOUT               (5*HZ)
+#define I2C_STATE_DEFAULT "default"
+
+enum i2c_state {
+    INVALIDSTATE,
+    RESTARTSTATE,
+    STARTSTATE,
+    WRITESTATE,
+    READSTATE,
+    STOPSTATE,
+
+    FIFO_READSTATE,
+    FIFO_WRITESTATE,
+};
+
+struct pin_state{
+	struct pinctrl *p;
+	struct pinctrl_state *s;
+};
+
+struct owl_i2c_dev {
+    struct device       *dev;
+    struct resource     *ioarea;
+    struct i2c_adapter  adapter;
+    struct completion   cmd_complete;
+    struct i2c_msg      *msgs;
+    struct mutex        mutex;
+    wait_queue_head_t   waitqueue;
+    unsigned int        msg_num;
+    unsigned int        msg_idx;
+    unsigned int        msg_ptr;
+	int i2c_addr_type;	/*1: HDMI,0 else */
+
+    spinlock_t          lock;
+    enum i2c_state           state;
+    void __iomem        *base;      /* virtual */
+    unsigned long       phys;
+    u32                 speed;      /* Speed of bus in Khz */
+    u32                 i2c_freq;
+    u32                 i2c_freq_cfg;
+    struct clk          *clk;
+	struct clk *i2c_clk;
+    int                 irq;
+    u8                  fifo_size;
+    u8                  rev;
+#ifdef OWL_I2C_SUPPORT_HDMI_NOFIFO
+    /* use FIFO mode for HDMI HDCP? */
+    int                 hdmi_nofifo;
+    uint                in_suspend_state;
+#endif
+    struct pin_state    i2c_pin_state;
+};
+
+static void owl_i2cdev_reinit(struct owl_i2c_dev *dev);
+static void owl_i2c_put_pin_mux(struct pin_state *i2c_pin_state);
+
+static int is_hdmi_use_i2c_flag;
+void set_hdmi_i2c_flag(int flag)
+{
+	if (0 != flag)
+		is_hdmi_use_i2c_flag = 1;
+	else
+		is_hdmi_use_i2c_flag = 0;
+}
+EXPORT_SYMBOL(set_hdmi_i2c_flag);
+static int is_hdmi_use_i2c(void)
+{
+	return !!is_hdmi_use_i2c_flag;
+}
+
+static ssize_t info_show(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	int cnt;
+
+	cnt = sprintf(buf, "%d\n(Note: 1: open, 0:close)\n", info_switch);
+	return cnt;
+}
+
+static ssize_t info_store(struct device *dev,
+			  struct device_attribute *attr, const char *buf,
+			  size_t count)
+{
+	int cnt, tmp;
+	cnt = sscanf(buf, "%d", &tmp);
+	switch (tmp) {
+	case 0:
+	case 1:
+		info_switch = tmp;
+		break;
+	default:
+		pr_err("invalid input\n");
+		break;
+	}
+	return count;
+}
+
+static ssize_t err_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int cnt;
+
+	cnt = sprintf(buf, "%d\n(Note: 1: open, 0:close)\n", err_switch);
+	return cnt;
+}
+
+static ssize_t err_store(struct device *dev,
+			 struct device_attribute *attr, const char *buf,
+			 size_t count)
+{
+	int cnt, tmp;
+	cnt = sscanf(buf, "%d", &tmp);
+	switch (tmp) {
+	case 0:
+	case 1:
+		err_switch = tmp;
+		break;
+	default:
+		pr_err("invalid input\n");
+		break;
+	}
+	return count;
+}
+
+static struct device_attribute owl_i2c_attr[] = {
+	__ATTR(msg_info, S_IRUSR | S_IWUSR, info_show, info_store),
+	__ATTR(msg_error, S_IRUSR | S_IWUSR, err_show, err_store),
+};
+
+static inline void owl_i2c_writel(struct owl_i2c_dev *i2c_dev, u32 val, int reg)
+{
+    i2c_dbg("-->>write 0x%x to 0x%x",val, (u32)(i2c_dev->base +reg));
+    __raw_writel(val, i2c_dev->base + reg);
+}
+
+static inline u32 owl_i2c_readl(struct owl_i2c_dev *i2c_dev, int reg)
+{
+    return __raw_readl(i2c_dev->base + reg);
+}
+
+
+static void owl_i2c_printifo(struct owl_i2c_dev * dev)
+{
+#if 0
+	i2c_info("====================================\n");
+	i2c_info("MFP_CTL2:0x%x\n", act_readl(MFP_CTL2));
+	i2c_info("MFP_CTL3:0x%x\n", act_readl(MFP_CTL3));
+	i2c_info("CMU_DEVCLKEN0:0x%x\n", act_readl(CMU_DEVCLKEN0));
+	i2c_info("CMU_DEVCLKEN1:0x%x\n", act_readl(CMU_DEVCLKEN1));
+	i2c_info("I2C_CTL:0x%x\n", owl_i2c_readl(dev, I2C_CTL));
+	i2c_info("I2C_CLKDIV:0x%x\n", owl_i2c_readl(dev, I2C_CLKDIV));
+	i2c_info("I2C_STAT:0x%x\n", owl_i2c_readl(dev, I2C_STAT));
+	i2c_info("I2C_ADDR:0x%x\n", owl_i2c_readl(dev, I2C_ADDR));
+	i2c_info("I2C_CMD:0x%x\n", owl_i2c_readl(dev, I2C_CMD));
+	i2c_info("I2C_FIFOCTL:0x%x\n", owl_i2c_readl(dev, I2C_FIFOCTL));
+	i2c_info("I2C_FIFOSTAT:0x%x\n", owl_i2c_readl(dev, I2C_FIFOSTAT));
+	i2c_info(":0x%x\n", owl_i2c_readl(dev, I2C_DATCNT));
+	i2c_info("I2C_RCNT:0x%x\n", owl_i2c_readl(dev, I2C_RCNT));
+	i2c_info("====================================\n");
+#endif
+
+}
+
+static int owl_i2c_set_speed(struct owl_i2c_dev *dev)
+{
+	u32 ret = 0;
+	u32 freq = 0;
+	u32 divide = 0;
+	ret = of_property_read_u32(dev->dev->of_node, "clock-frequency", &freq);
+	if (ret) {
+		ret = -ENODATA;
+		goto of_property_read_err;
+	}
+	if (freq == 0) {
+		ret = -EINVAL;
+		goto freq_err;
+	}
+	dev->i2c_addr_type = 0;
+	dev->i2c_freq_cfg = dev->i2c_freq = freq;
+	divide = I2C_MODULE_CLK / (freq * 16);
+	owl_i2c_writel(dev, divide, I2C_CLKDIV);
+	return 0;
+
+of_property_read_err:
+	i2c_err("of_property_read_u32() failed\n");
+	return ret;
+freq_err:
+	i2c_err("freq error\n");
+	return ret;
+}
+/*
+ * Disable i2C controler <Disable its clock..??>
+ */
+static void owl_i2c_disable(struct owl_i2c_dev *dev)
+{
+    owl_i2c_writel(dev,
+        owl_i2c_readl(dev, I2C_CTL) & ~I2C_CTL_EN, I2C_CTL);
+
+    clk_disable(dev->clk);
+
+    return;
+}
+
+//static void i2c_set_freq(struct owl_i2c_dev *dev, u32 pclk, u32 i2c_freq)
+//{
+//    u32 div_factor;
+
+//    div_factor = (pclk + i2c_freq * 16 - 1) / (i2c_freq * 16);
+//    owl_i2c_writel(dev, I2C_CLKDIV_DIV(div_factor), I2C_CLKDIV);
+
+//    i2c_dbg("iic clock divisor is %d!\n", div_factor);
+//    i2c_dbg("iic clock is %dHz!\n", pclk / (div_factor * 16));
+
+//    return;
+//}
+
+/*
+ * Initialize hardware registers.
+ */
+
+static void owl_i2cdev_init(struct owl_i2c_dev *dev)
+{
+//    u32 iiccon = I2C_CTL_EN | I2C_CTL_IRQE | I2C_CTL_PUEN;
+    u32 iiccon = I2C_CTL_EN | I2C_CTL_IRQE | I2C_CTL_PUEN;
+
+    i2c_dbg("owl_i2cdev_init");
+    owl_i2c_writel(dev, 0xff, I2C_STAT);
+    owl_i2c_writel(dev, iiccon, I2C_CTL);
+}
+
+static void owl_i2c_enable(struct owl_i2c_dev *dev)
+{
+	/* 1 enable clk */
+	clk_enable(dev->i2c_clk);
+	/* 2 init the dev */
+	owl_i2cdev_reinit(dev);
+}
+
+static inline void owl_i2c_disable_irq(struct owl_i2c_dev *dev)
+{
+    u32 tmp = owl_i2c_readl(dev, I2C_CTL) & (~I2C_CTL_IRQE);
+    owl_i2c_writel(dev, tmp, I2C_CTL);
+}
+
+static inline void owl_i2c_enable_irq(struct owl_i2c_dev *dev)
+{
+    u32 tmp = owl_i2c_readl(dev, I2C_CTL) | I2C_CTL_IRQE;
+    owl_i2c_writel(dev, tmp, I2C_CTL);
+}
+
+static inline void owl_i2c_clear_tcb(struct owl_i2c_dev *dev)
+{
+    volatile unsigned int tmp;
+    int retry_times = 10;
+
+    i2c_dbg("clear tcb");
+
+    do
+    {
+        tmp = owl_i2c_readl(dev, I2C_STAT) | I2C_STAT_IRQP;
+        owl_i2c_writel(dev, tmp, I2C_STAT);
+
+        /* ensure write finished */
+        tmp = owl_i2c_readl(dev, I2C_STAT);
+        if (!(tmp & I2C_STAT_IRQP))
+            return;
+
+        retry_times--;
+    } while (retry_times > 0);
+
+    /* clear IRQ pending timeout, we have to reset the I2C controller */
+
+    i2c_warn("%s(): [i2c%d] clear IRQ pending error! reset controller\n",
+        __FUNCTION__,
+        dev->adapter.nr);
+
+    owl_i2c_printifo(dev);
+
+    /* reset I2C controller */
+    owl_i2c_writel(dev, owl_i2c_readl(dev, I2C_CTL) & ~I2C_CTL_EN, I2C_CTL);
+    udelay(1);
+    owl_i2c_writel(dev, owl_i2c_readl(dev, I2C_CTL) | I2C_CTL_EN, I2C_CTL);
+    udelay(1);
+}
+
+static inline void owl_i2c_reset_fifo(struct owl_i2c_dev *dev)
+{
+    owl_i2c_writel(dev, I2C_FIFOCTL_RFR | I2C_FIFOCTL_TFR, I2C_FIFOCTL);
+    //wait for FIFO Reset ok	
+    while(owl_i2c_readl(dev, I2C_FIFOCTL) & (I2C_FIFOCTL_RFR | I2C_FIFOCTL_TFR));
+}
+
+static inline int isMsgEnd(struct owl_i2c_dev *dev)
+{
+    return (dev->msg_ptr == (dev->msgs->len - 1));
+}
+
+static inline int isLastMsg(struct owl_i2c_dev *dev)
+{
+    return (dev->msg_idx == (dev->msg_num - 1));
+}
+
+static inline int isMsgFinish(struct owl_i2c_dev *dev)
+{
+    return (dev->msg_ptr >= dev->msgs->len);
+}
+
+static inline int owl_i2c_reset(struct owl_i2c_dev *dev)
+{
+    owl_i2c_reset_fifo(dev);
+
+    /* reset i2c controller */
+    owl_i2c_writel(dev,
+        owl_i2c_readl(dev, I2C_CTL) & ~I2C_CTL_EN, I2C_CTL);
+
+    owl_i2c_writel(dev,
+        owl_i2c_readl(dev, I2C_CTL) | I2C_CTL_EN, I2C_CTL);
+	return 0;
+}
+
+static void owl_master_trans_completion(struct owl_i2c_dev *dev, int retval)
+{
+    i2c_dbg("I2C Trans complete %s", retval? "failed" : "successfully");
+
+//    spin_lock_irq(&dev->lock);
+    dev->msgs = NULL;
+    dev->msg_num = 0;
+    dev->msg_ptr = 0;
+    dev->msg_idx++;
+    if ( retval )
+        dev->msg_idx = retval;
+//    spin_unlock_irq(&dev->lock);
+
+    wake_up(&dev->waitqueue);
+}
+
+static void owl_i2c_message_start(struct owl_i2c_dev *dev,
+                                   struct i2c_msg *msg)
+{
+    u16 addr = (msg->addr & 0x7f) << 1;
+    u32 ctl;
+
+    i2c_dbg("%s()\n", __FUNCTION__);
+
+    if ( msg->flags & I2C_M_RD ) {
+        addr |= 1;
+    }
+
+#if 1
+    dev->state = STARTSTATE;
+    ctl = I2C_CTL_IRQE | I2C_CTL_EN | I2C_CTL_GBCC_START
+        | I2C_CTL_PUEN | I2C_CTL_RB;
+    owl_i2c_writel(dev, addr, I2C_TXDAT);
+    owl_i2c_writel(dev, ctl, I2C_CTL);
+#endif
+}
+
+static void owl_i2c_message_restart(struct owl_i2c_dev *dev,
+                                     struct i2c_msg *msg)
+{
+    u16 addr = (msg->addr & 0x7f) << 1;
+    u32 ctl;
+
+    i2c_dbg("%s()\n", __FUNCTION__);
+
+    if (msg->flags & I2C_M_RD){
+        addr |= 1;
+    }
+
+    ctl = (owl_i2c_readl(dev, I2C_CTL) & ~I2C_CTL_GBCC_MASK)
+        | I2C_CTL_GBCC_RESTART | I2C_CTL_RB;
+    owl_i2c_writel(dev, addr, I2C_TXDAT);
+    owl_i2c_writel(dev, ctl, I2C_CTL);
+}
+
+//Only to send stop command, but Not stop at all.
+static void owl_i2c_stop(struct owl_i2c_dev *dev, int retval)
+{
+    u32 ctl;
+
+    i2c_dbg("%s(): retval %d\n", __FUNCTION__, retval);
+
+    dev->state = STOPSTATE;
+    ctl = I2C_CTL_EN | I2C_CTL_GBCC_STOP | I2C_CTL_RB ; //stop cmd: 0xaa
+    owl_i2c_writel(dev, ctl, I2C_CTL);
+    udelay(10);
+    owl_master_trans_completion(dev, retval);
+}
+
+#ifdef OWL_I2C_SUPPORT_FIFO
+
+static void owl_i2c_message_fifo_start(struct owl_i2c_dev *dev,
+                                   struct i2c_msg *msgs, int num)
+{
+    u16 addr = (msgs[0].addr & 0x7f) << 1;
+    struct i2c_msg *msg;
+    int i, read = 1, addr_len;
+    int fifo_cmd;
+
+    i2c_dbg("%s() %d\n", __FUNCTION__, __LINE__);
+    owl_i2c_writel(dev, I2C_CTL_IRQE | I2C_CTL_EN, I2C_CTL);
+
+#ifdef I2C_DEBUG_INFO
+    owl_i2c_printifo(dev);
+#endif
+
+    if (num == 1) {
+        /* 1 message */
+        if (!(msgs[0].flags & I2C_M_RD)) {
+            /* for write to device */
+            owl_i2c_writel(dev, addr, I2C_TXDAT);
+            read = 0;
+        }
+
+        addr_len = 1;
+        msg = &msgs[0];
+        dev->msg_idx = 0;
+    } else {
+        /* 2 messages for read from device */
+
+        /* write address */
+        owl_i2c_writel(dev, addr, I2C_TXDAT);
+
+        /* write internal register address */
+        for (i = 0; i < msgs[0].len; i++)
+            owl_i2c_writel(dev, msgs[0].buf[i], I2C_TXDAT);
+
+        /* internal register address length +  1 byte device address */
+        addr_len = msgs[0].len + 1;
+        msg = &msgs[1];
+        dev->msg_idx = 1;
+    }
+
+    i2c_dbg("%s() %d: msg->len %d\n", __FUNCTION__, __LINE__, msg->len);
+    owl_i2c_writel(dev, msg->len, I2C_DATCNT);
+
+    if (read) {
+        /* write restart with WR address */
+        owl_i2c_writel(dev, addr | 1, I2C_TXDAT);
+
+        /* read from device */
+        fifo_cmd = I2C_CMD_EXEC | I2C_CMD_MSS | I2C_CMD_SE | I2C_CMD_NS | I2C_CMD_DE | \
+                   I2C_CMD_AS(addr_len) | I2C_CMD_SBE;
+        if (num == 2)
+            fifo_cmd |= I2C_CMD_SAS(1) | I2C_CMD_RBE;       /* 0x8f35 */
+
+        dev->state = FIFO_READSTATE;
+    } else {
+        /* write to device */
+        while (!(I2C_FIFOSTAT_TFF & owl_i2c_readl(dev, I2C_FIFOSTAT))) {
+            if (dev->msg_ptr >= msg->len)
+                break;
+
+            i2c_dbg("%s(): [i2c%d] fifostat %x, write dev->msg_ptr %d: %x\n", __FUNCTION__, 
+                dev->adapter.nr,
+                owl_i2c_readl(dev, I2C_FIFOSTAT),
+                dev->msg_ptr,
+                msg->buf[dev->msg_ptr]);
+
+            owl_i2c_writel(dev, msg->buf[dev->msg_ptr++], I2C_TXDAT);
+        }
+
+        fifo_cmd = I2C_CMD_EXEC | I2C_CMD_MSS | I2C_CMD_SE | I2C_CMD_NS | I2C_CMD_DE | \
+                   I2C_CMD_AS(1) | I2C_CMD_SBE;             /* 0x8f03 */
+
+        dev->state = FIFO_WRITESTATE;
+    }
+
+    /* don't care NACK for hdmi device */
+    if (msg->flags & I2C_M_IGNORE_NAK)
+        owl_i2c_writel(dev,
+            owl_i2c_readl(dev, I2C_FIFOCTL) | I2C_FIFOCTL_NIB, I2C_FIFOCTL);
+    else
+        owl_i2c_writel(dev,
+            owl_i2c_readl(dev, I2C_FIFOCTL) & ~I2C_FIFOCTL_NIB, I2C_FIFOCTL);
+
+    /* write fifo command to start transfer */
+    owl_i2c_writel(dev, fifo_cmd, I2C_CMD);
+
+    i2c_dbg("%s() %d\n", __FUNCTION__, __LINE__);
+
+#ifdef I2C_DEBUG_INFO
+    owl_i2c_printifo(dev);
+#endif
+
+    i2c_dbg("%s() end\n", __FUNCTION__);
+}
+
+/*
+ * check if we can use the fifo mode to transfer data
+ *
+ * For simplicity, only support the following data pattern:
+ *  1) 1 message,  msg[0] write (MAX 120bytes)
+ *  2) 1 message,  msg[0] read  (MAX 120bytes)
+ *  3) 2 messages, msg[0] write (MAX 7bytes), msg[1] read (MAX 120bytes)
+ */
+static int can_use_fifo_trans(struct owl_i2c_dev *dev,
+                              struct i2c_msg *msgs, int num)
+{
+    int pass = 0;
+
+
+    i2c_dbg("%s(): msgs[0].flags 0x%x, msgs[0].len %d\n", 
+        __FUNCTION__, msgs[0].flags, msgs[0].len);
+
+    switch (num) {
+    case 1:
+        /* 1 message must be write to device */
+        pass = 1;
+        break;
+    case 2:
+        /* 2 message must be read from device */
+        if ((msgs[0].flags & I2C_M_RD) || !(msgs[1].flags & I2C_M_RD)) {
+            i2c_warn("%s(): cannot use fifo mode, msgs[0].flags 0x%x, msgs[0].flags 0x%x\n", 
+                __FUNCTION__, msgs[0].flags, msgs[1].flags);
+            break;
+        }
+        pass = 1;
+        break;
+    default:
+        i2c_dbg("%s(): skip msg (num %d)\n", __FUNCTION__, num);
+    }
+	if(dev->adapter.nr ==1) {
+	i2c_dbg("can use i2c freq is %d\n", dev->i2c_freq);
+	i2c_dbg("can use hdmi_nofifo is %d\n", dev->hdmi_nofifo);
+	}
+#ifdef OWL_I2C_SUPPORT_HDMI_NOFIFO
+    /* don't use FIFO mode for hdmi */
+    if (dev->i2c_freq == I2C_CLK_HDMI || dev->hdmi_nofifo ==1) {
+        pass = 0;
+    }
+#endif
+    i2c_dbg("%s() pass %d\n", __FUNCTION__, pass);
+
+    return pass;
+}
+#else
+#define owl_i2c_message_fifo_start(dev, msgs, num) do { } while (0)
+#define can_use_fifo_trans(dev, msgs, num)          (0)
+#endif
+
+
+static int owl_i2c_doxfer(struct owl_i2c_dev *dev, struct i2c_msg *msgs, int num)
+{
+    unsigned long timeout;
+    int ret = 0;
+    int i;
+
+    spin_lock_irq(&dev->lock);
+    dev->state = STARTSTATE;
+    dev->msgs = msgs;
+    dev->msg_num = num;
+    dev->msg_idx = dev->msg_ptr = 0;
+    spin_unlock_irq(&dev->lock);
+
+    i2c_dbg("%s(): msg num %d\n", __FUNCTION__, num);
+
+    for (i = 0; i < num; i++) {
+        i2c_dbg("  msg[%d]: addr 0x%x, len %d, flags 0x%x\n", 
+            i, msgs[i].addr, msgs[i].len, msgs[i].flags);
+        owl_dump_mem(msgs[i].buf, msgs[i].len, 0, 1);
+    }
+
+    if (can_use_fifo_trans(dev, msgs, num))
+        owl_i2c_message_fifo_start(dev, msgs, num);
+    else
+        owl_i2c_message_start(dev, msgs);
+
+    timeout = wait_event_timeout(dev->waitqueue,
+                dev->msg_num == 0, I2C_TRANS_TIMEOUT);
+    if ( !timeout ) {
+        ret = -EAGAIN;
+        i2c_warn("Timedout..");
+        goto out;
+    }
+
+    if ( dev->msg_idx < 0) {
+        ret = -EAGAIN;
+        owl_i2cdev_init(dev);
+        i2c_warn("Transition failed");
+    } else {
+        ret = dev->msg_idx;
+    }
+
+out:
+    /* disable i2c after transfer */
+    owl_i2c_writel(dev, 0, I2C_CTL);
+
+    return ret;
+}
+
+static int owl_i2c_irq_nextbyte(struct owl_i2c_dev *dev, unsigned int status)
+{
+    u8 byte, ctl_reg, spec = 0;
+    int ret = 0;
+    unsigned long flags;
+
+    i2c_dbg("%s(): status 0x%x, dev->state 0x%x\n", __FUNCTION__, 
+        status, dev->state);
+#ifdef I2C_DEBUG_INFO
+    owl_i2c_printifo(dev);
+#endif
+
+    spin_lock_irqsave(&dev->lock, flags);
+    switch (dev->state) {
+        case STOPSTATE:
+            i2c_dbg("%s(): STOPSTATE\n", __FUNCTION__);
+
+//            owl_i2c_disable_irq(dev);
+            goto out;
+        case STARTSTATE:
+            i2c_dbg("%s(): STARTSTATE\n", __FUNCTION__);
+
+            if ( dev->msgs->flags & I2C_M_RD ) {
+                dev->state = READSTATE;
+            } else {
+                dev->state = WRITESTATE;
+            }
+
+            if ( dev->msgs->len == 0 ) {
+                owl_i2c_stop(dev, 0);
+                goto out;
+            }
+
+        i2c_dbg("%s(): -> dev->state 0x%x\n", __FUNCTION__, 
+            dev->state);
+
+            if ( dev->state == READSTATE ) {
+                goto pre_read;
+            } else if ( dev->state == WRITESTATE ) {
+                goto retry_write;
+            }
+
+        case READSTATE:
+
+            i2c_dbg("%s(): READSTATE\n", __FUNCTION__);
+
+            byte = owl_i2c_readl(dev, I2C_RXDAT);
+            dev->msgs->buf[dev->msg_ptr++] = byte;
+
+pre_read:
+            i2c_dbg("%s(): READSTATE - %d, %d, %d\n", __FUNCTION__,
+                isMsgEnd(dev), isMsgFinish(dev), isLastMsg(dev));
+
+            if ( isMsgEnd(dev) ) {
+                spec = I2C_CTL_GRAS;
+            } else if (isMsgFinish(dev)) {
+                if ( !isLastMsg(dev) ) {
+                    dev->msgs++;
+                    dev->msg_idx++;
+                    dev->msg_ptr = 0;
+                    dev->state = STARTSTATE;
+                    owl_i2c_message_restart(dev, dev->msgs);
+                    goto out;
+                } else {
+                    owl_i2c_stop(dev, 0);
+                    goto out;
+                }
+            }
+            break;
+
+        case WRITESTATE:
+            i2c_dbg("%s(): WRITESTATE\n", __FUNCTION__);
+
+retry_write:
+            i2c_dbg("%s(): WRITESTATE - %d, %d, %d\n", __FUNCTION__,
+                isMsgEnd(dev), isMsgFinish(dev), isLastMsg(dev));
+
+            if (!isMsgFinish(dev)) {
+
+#ifdef I2C_DEBUG_INFO
+    owl_i2c_printifo(dev);
+#endif
+                byte = dev->msgs->buf[dev->msg_ptr++];
+                owl_i2c_writel(dev, byte, I2C_TXDAT);
+
+#ifdef I2C_DEBUG_INFO
+    owl_i2c_printifo(dev);
+#endif
+            } else if (!isLastMsg(dev)) {
+                dev->msgs++;
+                dev->msg_idx++;
+                dev->msg_ptr = 0;
+                dev->state = STARTSTATE;
+                owl_i2c_message_restart(dev, dev->msgs);
+                goto out;
+            } else {
+                owl_i2c_stop(dev, 0);
+                goto out;
+            }
+
+            break;
+        default:
+            i2c_warn("Invalid State..");
+            ret = -EINVAL;
+            break;
+    }
+
+    ctl_reg = (owl_i2c_readl(dev, I2C_CTL) & ~I2C_CTL_GBCC_MASK)
+                | I2C_CTL_GBCC_NONE | I2C_CTL_RB | spec;
+    owl_i2c_writel(dev, ctl_reg, I2C_CTL);
+
+#ifdef I2C_DEBUG_INFO
+    owl_i2c_printifo(dev);
+#endif
+out:
+    spin_unlock_irqrestore(&dev->lock, flags);
+    return ret;
+}
+
+#ifdef OWL_I2C_SUPPORT_FIFO
+
+static int fifo_write_irq(struct owl_i2c_dev *dev)
+{
+    struct i2c_msg *msg = &dev->msgs[dev->msg_idx];
+
+    i2c_dbg("%s(): [i2c%d] fifo write, msg->len %d, dev->msg_ptr %d, fifostat %x, rcnt %d\n", __FUNCTION__, 
+        dev->adapter.nr,
+        msg->len, 
+        dev->msg_ptr, 
+        owl_i2c_readl(dev, I2C_FIFOSTAT),
+        owl_i2c_readl(dev, I2C_RCNT));
+
+    BUG_ON(msg->len < dev->msg_ptr);
+
+    while (!(I2C_FIFOSTAT_TFF & owl_i2c_readl(dev, I2C_FIFOSTAT))) {
+        if (dev->msg_ptr >= msg->len)
+            break;
+
+        i2c_dbg("%s(): [i2c%d] fifostat %x, write dev->msg_ptr %d: %x\n", __FUNCTION__, 
+            dev->adapter.nr,
+            owl_i2c_readl(dev, I2C_FIFOSTAT),
+            dev->msg_ptr,
+            msg->buf[dev->msg_ptr]);
+
+        owl_i2c_writel(dev, msg->buf[dev->msg_ptr++], I2C_TXDAT);
+    }
+
+    if (msg->len == dev->msg_ptr && (I2C_FIFOSTAT_CECB & owl_i2c_readl(dev, I2C_FIFOSTAT))) {
+        i2c_dbg("%s(): [i2c%d] end fifo write, msg->len %d, fifostat %x, %d/%d\n", __FUNCTION__, 
+            dev->adapter.nr,
+            msg->len, 
+            owl_i2c_readl(dev, I2C_FIFOSTAT),
+            owl_i2c_readl(dev, I2C_DATCNT) - owl_i2c_readl(dev, I2C_RCNT),
+            owl_i2c_readl(dev, I2C_DATCNT));
+        owl_i2c_reset(dev);
+        owl_master_trans_completion(dev, 0);
+    }
+
+    return 0;
+}
+
+
+static int fifo_read_irq(struct owl_i2c_dev *dev, int stop_detected)
+{
+    struct i2c_msg *msg = &dev->msgs[dev->msg_idx];
+    int byte;
+
+    i2c_dbg("%s(): [i2c%d] fifo read, msg->len %d, dev->msg_ptr %d, fifostat %x\n", __FUNCTION__, 
+        dev->adapter.nr,
+        msg->len, 
+        dev->msg_ptr, 
+        owl_i2c_readl(dev, I2C_FIFOSTAT));
+
+    BUG_ON(msg->len < dev->msg_ptr);
+
+    if (msg->len > dev->msg_ptr) {
+        while (I2C_FIFOSTAT_RFE & owl_i2c_readl(dev, I2C_FIFOSTAT)) {
+            i2c_dbg("%s(): [i2c%d] fifostat %x, stat %x\n", __FUNCTION__, 
+                dev->adapter.nr,
+                owl_i2c_readl(dev, I2C_FIFOSTAT),
+                owl_i2c_readl(dev, I2C_STAT));
+
+            byte = owl_i2c_readl(dev, I2C_RXDAT);
+            msg->buf[dev->msg_ptr++] = byte;
+
+            i2c_dbg("%s(): [i2c%d] read to dev->msg_ptr %d: 0x%02x\n", __FUNCTION__, 
+                dev->adapter.nr,
+                dev->msg_ptr - 1,
+                byte);
+        }
+    }
+
+    if (msg->len == dev->msg_ptr && stop_detected) {
+        i2c_dbg("%s(): [i2c%d] finish fifo read, msg->len %d, fifostat %x, stat %x, %d/%d\n", __FUNCTION__, 
+            dev->adapter.nr,
+            msg->len, 
+            owl_i2c_readl(dev, I2C_FIFOSTAT),
+            owl_i2c_readl(dev, I2C_STAT),
+            owl_i2c_readl(dev, I2C_DATCNT) - owl_i2c_readl(dev, I2C_RCNT),
+            owl_i2c_readl(dev, I2C_DATCNT));
+
+        owl_i2c_reset(dev);
+        owl_master_trans_completion(dev, 0);
+    }
+
+    return 0;
+}
+
+static int owl_i2c_fifo_irq(struct owl_i2c_dev *dev, int stop_detected)
+{
+#ifdef I2C_DEBUG_INFO
+    struct i2c_msg *msg = &dev->msgs[dev->msg_idx];
+#endif
+    unsigned int fifostat;
+
+    i2c_dbg("%s(): fifo mode, state %d, msg_idx %d, len %d, stop_detected %d\n", 
+        __FUNCTION__, dev->state, dev->msg_idx, msg->len, stop_detected);
+
+    if (dev->msg_idx >= 2) {
+        i2c_warn("%s(): [i2c%d] i2c bus error! I2C_CTL 0x%x, I2C_STAT 0x%x, fifostat 0x%x\n", 
+            __FUNCTION__,
+            dev->adapter.nr,
+            owl_i2c_readl(dev, I2C_CTL),
+            owl_i2c_readl(dev, I2C_STAT),
+            owl_i2c_readl(dev, I2C_FIFOSTAT));
+
+        owl_i2c_reset(dev);
+        owl_master_trans_completion(dev, -ENXIO);
+        return -1;
+    }
+
+    fifostat = owl_i2c_readl(dev, I2C_FIFOSTAT);
+    if (fifostat & I2C_FIFOSTAT_RNB) {
+        i2c_warn("%s(): [i2c%d] no ACK, fifostat 0x%x\n", __FUNCTION__, 
+            dev->adapter.nr,
+            fifostat);
+        owl_i2c_reset(dev);
+        owl_master_trans_completion(dev, -ENXIO);
+        return -1;
+    }
+    
+    if (dev->state == FIFO_WRITESTATE)
+        fifo_write_irq(dev);
+    else if (dev->state == FIFO_READSTATE)
+        fifo_read_irq(dev, stop_detected);
+    else 
+        BUG_ON(1);
+
+    i2c_dbg("%s() %d:\n", __FUNCTION__, __LINE__);
+
+    return 0;
+}
+#else
+#define owl_i2c_fifo_irq(dev)          do { } while (0)
+#endif
+
+static irqreturn_t owl_i2c_interrupt(int irq, void *dev_id)
+{
+    struct owl_i2c_dev *dev = dev_id;
+    unsigned int status = 0, ctl_reg = 0;
+    int flags, stop_detected;
+    
+    i2c_dbg("%s(): irq %d, I2C_STAT 0x%x, I2C_FIFOSTAT 0x%x, dev->state %d\n", 
+        __FUNCTION__, 
+        irq, owl_i2c_readl(dev, I2C_STAT),
+        owl_i2c_readl(dev, I2C_FIFOSTAT), dev->state);
+
+    stop_detected = (owl_i2c_readl(dev, I2C_STAT) & I2C_STAT_STPD) ? 1 : 0;
+
+    /* clear STPD/IRQP */
+    owl_i2c_clear_tcb(dev);
+
+    if (dev->state == FIFO_READSTATE || dev->state == FIFO_WRITESTATE) {
+        owl_i2c_fifo_irq(dev, stop_detected);
+        goto out;
+    }
+
+    status = owl_i2c_readl(dev, I2C_STAT);
+    if (status & I2C_BUS_ERR_MSK) {
+        i2c_warn("I2C trans failed <stat: 0x%x>", status);
+        goto out;
+    }
+
+    if (dev->state == STOPSTATE)
+        goto out;
+
+    if (dev->msgs == NULL) {
+        i2c_warn("I2C: skip spurious interrupt, status 0x%x\n", status);
+        goto out;
+    }
+
+    flags = dev->msgs->flags;
+
+    ctl_reg = owl_i2c_readl(dev, I2C_CTL);
+    if (!(flags & I2C_M_RD) && !(flags & I2C_M_IGNORE_NAK)) {
+        if ( status & I2C_STAT_RACK) {
+            i2c_dbg("ACK\n");                   
+        } else {                    
+            i2c_warn("No Ack\n");
+            goto no_ack;
+        }
+    }
+
+    owl_i2c_irq_nextbyte(dev, status);
+
+out:
+    return IRQ_HANDLED;
+no_ack:
+    owl_i2c_stop(dev, -ENXIO);
+    goto out;
+}
+
+static int owl_i2c_xfer(struct i2c_adapter *adap,
+    struct i2c_msg *pmsg, int num)
+{
+    struct owl_i2c_dev *dev = i2c_get_adapdata(adap);
+    int ret = 0;
+	u32 divide;
+	u32 freq = 0;
+    if (!adap || !pmsg)
+        return -EINVAL;
+
+    if (mutex_lock_interruptible(&dev->mutex) < 0)
+        return -EAGAIN;
+
+	if (dev->in_suspend_state != 0) {
+		dev_err(&adap->dev, "%s() someone call this API while we are in "
+			"suspend state, drop it.\n", __func__);
+		dump_stack();
+		return -EBUSY;
+	}
+
+    /* Sometimes the TP i2c address is 0x30 at I2C1 */
+	if ((0 != is_hdmi_use_i2c()) &&
+		(((0x60 >> 1) == pmsg->addr) ||
+		((0xA0 >> 1) == pmsg->addr) ||
+		((0x74 >> 1) == pmsg->addr))) {
+        	if (I2C_CLK_HDMI != dev->i2c_freq) {
+			dev->i2c_freq = I2C_CLK_HDMI;
+			dev->hdmi_nofifo = 1;
+		}
+	} else {
+		dev->hdmi_nofifo = 0;
+		dev->i2c_freq = dev->i2c_freq_cfg;
+	}
+	i2c_dbg("owl_i2c_xfer i2c freq is %d\n", dev->i2c_freq);
+	i2c_dbg("owl_i2c_xfer hdmi_nofifo is %d\n", dev->hdmi_nofifo);
+	freq = dev->i2c_freq;
+	divide = I2C_MODULE_CLK / (freq * 16);
+	owl_i2c_writel(dev, divide, I2C_CLKDIV);
+    owl_i2cdev_init(dev);
+    ret = owl_i2c_doxfer(dev, pmsg, num);
+
+    mutex_unlock(&dev->mutex);
+
+    return ret;
+}
+
+static u32 owl_i2c_func(struct i2c_adapter *adapter)
+{
+    return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm owl_i2c_algo = {
+    .master_xfer    = owl_i2c_xfer,
+    .functionality  = owl_i2c_func,
+};
+
+static int owl_i2c_remove(struct platform_device *pdev)
+{
+	struct owl_i2c_dev *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+
+	platform_set_drvdata(pdev, NULL);
+	free_irq(dev->irq, dev);
+	i2c_del_adapter(&dev->adapter);
+	owl_i2c_disable(dev);
+	owl_i2c_put_pin_mux(&dev->i2c_pin_state);
+	kfree(dev);
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, (mem->end - mem->start) + 1);
+
+	return 0;
+}
+
+static int owl_i2c_suspend(struct device *dev)
+{
+	struct owl_i2c_dev *i2c_dev = dev_get_drvdata(dev);
+
+	dev_info(dev, "suspend.\n");
+	if (mutex_lock_interruptible(&i2c_dev->mutex) < 0)
+		return -EAGAIN;
+	disable_irq(i2c_dev->irq);
+	owl_i2c_disable(i2c_dev);
+	i2c_dev->in_suspend_state = 1;
+	mutex_unlock(&i2c_dev->mutex);
+	return 0;
+}
+
+static int owl_i2c_resume(struct device *dev)
+{
+	struct owl_i2c_dev *i2c_dev = dev_get_drvdata(dev);
+
+	dev_info(dev, "resume.\n");
+	if (mutex_lock_interruptible(&i2c_dev->mutex) < 0)
+		return -EAGAIN;
+
+	pr_debug("%s %d\n", __FUNCTION__, __LINE__);
+
+	owl_i2c_enable(i2c_dev);
+	enable_irq(i2c_dev->irq);
+	i2c_dev->in_suspend_state = 0;
+	mutex_unlock(&i2c_dev->mutex);
+	return 0;
+}
+
+
+static int owl_i2c_set_pin_mux(struct platform_device *pdev)
+{
+	int ret;
+	struct owl_i2c_dev *dev = platform_get_drvdata(pdev);
+
+	dev->i2c_pin_state.p = pinctrl_get(&pdev->dev);
+	if (IS_ERR(dev->i2c_pin_state.p)) {
+		i2c_err("owl i2c get pinctrl handle failed");
+		return PTR_ERR(dev->i2c_pin_state.p);
+	}
+	dev->i2c_pin_state.s =
+	    pinctrl_lookup_state(dev->i2c_pin_state.p, I2C_STATE_DEFAULT);
+	if (IS_ERR(dev->i2c_pin_state.s)) {
+		i2c_err("alloc find pinctrl state failed");
+		pinctrl_put(dev->i2c_pin_state.p);
+		return PTR_ERR(dev->i2c_pin_state.s);
+	}
+
+	ret = pinctrl_select_state(dev->i2c_pin_state.p, dev->i2c_pin_state.s);
+	if (ret < 0) {
+		i2c_err("alloc set pinctrl state failed");
+		pinctrl_put(dev->i2c_pin_state.p);
+		return ret;
+	}
+
+	i2c_info("i2c pinctrl select state successfully\n");
+	return 0;
+
+}
+
+static void owl_i2c_put_pin_mux(struct pin_state *i2c_pin_state)
+{
+	if (i2c_pin_state->p)
+		pinctrl_put(i2c_pin_state->p);
+}
+
+/*Enable the i2c_clock tree. it's parent is eth_clk
+   i2c speed need be set additional*/
+static int owl_i2c_set_clk_tree(struct platform_device *pdev)
+{
+	int ret = 0;
+	u32 freq = 0;
+	struct owl_i2c_dev *dev = platform_get_drvdata(pdev);
+
+	switch (pdev->id) {
+	case 0:
+		dev->i2c_clk = clk_get(NULL, CLKNAME_I2C0_CLK);
+		freq = clk_round_rate(dev->i2c_clk, I2C_MODULE_CLK);
+		if (freq == I2C_MODULE_CLK)
+			ret = clk_set_rate(dev->i2c_clk, freq);
+		else
+			goto round_rate_failed;
+		clk_prepare(dev->i2c_clk);
+		clk_enable(dev->i2c_clk);
+		clk_put(dev->i2c_clk);
+		module_clk_enable(MOD_ID_I2C0);
+		break;
+
+	case 1:
+		dev->i2c_clk = clk_get(NULL, CLKNAME_I2C1_CLK);
+		freq = clk_round_rate(dev->i2c_clk, I2C_MODULE_CLK);
+		if (freq == I2C_MODULE_CLK)
+			ret = clk_set_rate(dev->i2c_clk, freq);
+		else
+			goto round_rate_failed;
+		clk_prepare(dev->i2c_clk);
+		clk_enable(dev->i2c_clk);
+		clk_put(dev->i2c_clk);
+		module_clk_enable(MOD_ID_I2C1);
+		break;
+
+	case 2:
+		dev->i2c_clk = clk_get(NULL, CLKNAME_I2C2_CLK);
+		freq = clk_round_rate(dev->i2c_clk, I2C_MODULE_CLK);
+		if (freq == I2C_MODULE_CLK)
+			ret = clk_set_rate(dev->i2c_clk, freq);
+		else
+			goto round_rate_failed;
+		clk_prepare(dev->i2c_clk);
+		clk_enable(dev->i2c_clk);
+		clk_put(dev->i2c_clk);
+		module_clk_enable(MOD_ID_I2C2);
+		break;
+
+	case 3:
+		dev->i2c_clk = clk_get(NULL, CLKNAME_I2C3_CLK);
+		freq = clk_round_rate(dev->i2c_clk, I2C_MODULE_CLK);
+		if (freq == I2C_MODULE_CLK)
+			ret = clk_set_rate(dev->i2c_clk, freq);
+		else
+			goto round_rate_failed;
+		clk_prepare(dev->i2c_clk);
+		clk_enable(dev->i2c_clk);
+		clk_put(dev->i2c_clk);
+		module_clk_enable(MOD_ID_I2C3);
+		break;
+
+	default:
+		goto clk_get_failed;
+		break;
+	}
+
+	return 0;
+
+round_rate_failed:
+	i2c_err("Round i2c module rate failed\r\n");
+	return -2;
+
+clk_get_failed:
+	i2c_err("Get i2c_clk failed\r\n");
+	return -1;
+}
+/*
+* Enable i2C module, including:
+* device tree
+* clock   tree
+* gpio
+* pin     ctrl
+*/
+static int owl_i2c_module_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	pdev->id = of_alias_get_id(np, "i2c");
+	if (pdev->id < 0)
+		goto alias_get_id_failed;
+
+	/*Pintrol I2C0 MFP UART0 */
+	if (owl_i2c_set_pin_mux(pdev))
+		goto set_pin_mux_failed;
+
+	if (owl_i2c_set_clk_tree(pdev))
+		goto set_clk_tree_failed;
+
+	return 0;
+
+alias_get_id_failed:
+	i2c_err("%s: Alias_get_id failed\r\n", __func__);
+	return -EINVAL;
+
+set_pin_mux_failed:
+	i2c_err("%s: set_pin_mux failed\r\n", __func__);
+	return -EINVAL;
+
+set_clk_tree_failed:
+	i2c_err("%s: set_clk_tree failed\r\n", __func__);
+	return -EINVAL;
+
+}
+
+static void owl_i2cdev_reinit(struct owl_i2c_dev *dev)
+{
+	/* u32 iiccon = I2C_CTL_EN | I2C_CTL_IRQE | I2C_CTL_PUEN; */
+	u32 iiccon = I2C_CTL_EN | I2C_CTL_IRQE | I2C_CTL_PUEN;
+	i2c_info("owl_i2cdev_reinit");
+
+	if (owl_i2c_set_speed(dev))
+		i2c_err("owl_i2c_set_speed failed\r\n");
+
+	owl_i2c_writel(dev, 0x8a, I2C_CTL);	/*stop i2c */
+	owl_i2c_writel(dev, 0x00, I2C_CTL);	/*disable i2c */
+	owl_i2c_writel(dev, 0xff, I2C_STAT);	/*clear state */
+	owl_i2c_writel(dev, iiccon, I2C_CTL);	/*enable i2c */
+}
+
+/*****************************************************************/
+static int owl_i2c_probe(struct platform_device *pdev)
+{
+	struct owl_i2c_dev *dev;
+	struct i2c_adapter *adap;
+	struct resource *mem, *irq, *ioarea;
+	int ret = 0;
+	int i = 0;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "no mem resource?\n");
+		return -ENODEV;
+	}
+
+	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq) {
+		dev_err(&pdev->dev, "no irq resource?\n");
+		return -ENODEV;
+	}
+
+	ioarea = request_mem_region(mem->start, resource_size(mem), pdev->name);
+	if (!ioarea) {
+		dev_err(&pdev->dev, "I2C region already claimed\n");
+		return -EBUSY;
+	}
+
+	dev = kzalloc(sizeof(struct owl_i2c_dev),
+		GFP_KERNEL);
+	if (!dev) {
+		i2c_err("alloc i2c device failed");
+		ret = -ENOMEM;
+		goto err_release_region;
+	}
+
+	mutex_init(&dev->mutex);
+	dev->dev = &pdev->dev;
+	dev->irq = irq->start;
+	spin_lock_init(&dev->lock);
+
+	dev->phys = (unsigned long)mem->start;
+	if (!dev->phys) {
+		ret = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	dev->base = (void __iomem *)IO_ADDRESS(dev->phys);
+
+	platform_set_drvdata(pdev, dev);
+	init_waitqueue_head(&dev->waitqueue);
+
+	ret = request_irq(dev->irq, owl_i2c_interrupt,
+			  0, pdev->name, dev);
+	if (ret) {
+		dev_err(dev->dev, "failure requesting irq %i\n", dev->irq);
+		goto err_unuse_clocks;
+	}
+
+	adap = &dev->adapter;
+	i2c_set_adapdata(adap, dev);
+	adap->owner = THIS_MODULE;
+	adap->class = I2C_CLASS_HWMON;
+	strlcpy(adap->name, "OWL I2C adapter", sizeof(adap->name));
+	adap->algo = &owl_i2c_algo;
+	adap->dev.parent = &pdev->dev;
+	adap->dev.of_node = pdev->dev.of_node;
+
+	ret = owl_i2c_module_init(pdev);
+	if (ret) {
+		dev_err(dev->dev, "owl_i2c_module_init failed\r\n");
+		ret = ENOMEM;
+		goto err_free_irq;
+	}
+
+	ret = owl_i2c_set_speed(dev);
+	if (ret) {
+		dev_err(dev->dev, "owl_i2c_set_speed failed\r\n");
+		ret = ENOMEM;
+		goto err_free_irq;
+	}
+
+	owl_i2cdev_init(dev);
+	
+	adap->nr = pdev->id;
+	ret = i2c_add_numbered_adapter(adap);
+	if (ret) {
+		dev_err(dev->dev, "failure adding adapter\n");
+		ret = ENOMEM;
+		goto err_free_irq;
+	}
+#ifdef I2C_DEBUG_INFO
+	owl_i2c_printifo(dev);
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(owl_i2c_attr); i++) {
+		ret = device_create_file(&pdev->dev, &owl_i2c_attr[i]);
+		if (ret) {
+			i2c_err("Add device file failed");
+			goto err_free_irq;
+		}
+	}
+
+	return 0;
+
+err_free_irq:
+	free_irq(dev->irq, dev);
+
+err_unuse_clocks:
+	/*err_iounmap:
+	   iounmap(dev->base); */
+err_free_mem:
+	platform_set_drvdata(pdev, NULL);
+	kfree(dev);
+err_release_region:
+	release_mem_region(mem->start, resource_size(mem));
+	return ret;
+}
+
+static const struct of_device_id owl_i2c_of_match[] = {
+	{ .compatible = "actions,owl-i2c" },
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, owl_i2c_of_match);
+
+static const struct dev_pm_ops owl_i2c_pm_ops = {
+	.suspend_noirq = owl_i2c_suspend,
+	.resume_noirq = owl_i2c_resume,
+};
+
+static struct platform_driver owl_fdt_driver = {
+	.driver = {
+		   .name = "owl-i2c",
+		   .owner = THIS_MODULE,
+		   .of_match_table = owl_i2c_of_match,
+		   },
+	.probe = owl_i2c_probe,
+	.remove = owl_i2c_remove,
+	.driver.pm	= &owl_i2c_pm_ops,
+};
+
+static int __init owl_i2c_init(void)
+{
+	return platform_driver_register(&owl_fdt_driver);
+}
+
+static void __exit owl_i2c_exit(void)
+{
+    platform_driver_unregister(&owl_fdt_driver);
+}
+
+MODULE_AUTHOR("lzhou");
+MODULE_DESCRIPTION("I2C driver for Actions SOC");
+MODULE_LICENSE("GPL");
+
+subsys_initcall(owl_i2c_init);
+module_exit(owl_i2c_exit);
+
diff --git a/arch/arm/mach-owl/include/mach/bootafinfo.h b/arch/arm/mach-owl/include/mach/bootafinfo.h
new file mode 100755
index 0000000..06208f5
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/bootafinfo.h
@@ -0,0 +1,24 @@
+/*
+ * arch/arm/mach-leopard/include/mach/bootafinfo.h
+ *
+ * Boot AFInfo interface
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_BOOTAFINFO_H
+#define __ASM_ARCH_BOOTAFINFO_H
+
+/*
+ * get boot afinfo 
+ */
+extern unsigned char *owl_get_boot_afinfo(void);
+extern int owl_get_boot_afinfo_len(void);
+
+#endif /* __ASM_ARCH_BOOTAFINFO_H */
diff --git a/arch/arm/mach-owl/include/mach/bootdev.h b/arch/arm/mach-owl/include/mach/bootdev.h
new file mode 100755
index 0000000..b68d100
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/bootdev.h
@@ -0,0 +1,41 @@
+/*
+ * arch/arm/mach-leopard/include/mach/bootdev.h
+ *
+ * Boot device
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_BOOTDEV_H
+#define __ASM_ARCH_BOOTDEV_H
+
+#define OWL_BOOTDEV_NAND       (0x00)
+#define OWL_BOOTDEV_SD0        (0x20)
+#define OWL_BOOTDEV_SD1        (0x21)
+#define OWL_BOOTDEV_SD2        (0x22)
+#define OWL_BOOTDEV_SD02NAND   (0x30)   //nand for cardburn 
+#define OWL_BOOTDEV_SD02SD2    (0x31)	 //emmc for cardburn 
+#define OWL_BOOTDEV_NOR        (0x40)   //spinor
+
+/*
+ * get boot device name
+ */
+extern int owl_get_boot_dev(void);
+
+
+
+
+#define OWL_BOOT_MODE_NORMAL 	0
+#define OWL_BOOT_MODE_UPGRADE 	1
+#define OWL_BOOT_MODE_CHARGER	2
+#define OWL_BOOT_MODE_RECOVERY	3
+/*return boot mode*/
+extern int owl_get_boot_mode(void);
+
+#endif /* __ASM_ARCH_BOOTDEV_H */
diff --git a/arch/arm/mach-owl/include/mach/chipid_reg-atm7039.h b/arch/arm/mach-owl/include/mach/chipid_reg-atm7039.h
new file mode 100755
index 0000000..c6a8f36
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/chipid_reg-atm7039.h
@@ -0,0 +1,53 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2012 Actions Semi Inc.
+*/
+/******************************************************************************/
+
+#ifndef __CHIPID_REG_ATM7039_H__
+#define __CHIPID_REG_ATM7039_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************/
+/* CHIPID_CTL0 */
+#define CHIPID_CTL0_EFUSE_CLKDIV_MASK			(0x7 << 5)
+#define CHIPID_CTL0_EFUSE_CLKDIV_SET(x)			(((x) & 0x7) << 5)
+#define CHIPID_CTL0_DATA_READY				(0x1 << 0)
+
+/******************************************************************************/
+/* CHIPID_DAT_1 */
+#define CHIPID_DAT_1_ID_MASK				(0xFF << 0)
+#define CHIPID_DAT_1_ID_SET(x)				(((x) & 0xFF) << 0)
+
+/******************************************************************************/
+/* CHIPID_CTL1 */
+#define CHIPID_CTL1_VDDQ_EN				(0x1 << 17)
+#define CHIPID_CTL1_VDDQ_SET_MASK			(0x7 << 14)
+#define CHIPID_CTL1_VDDQ_SET_SET(x)			(((x) & 0x7) << 14)
+#define CHIPID_CTL1_B2P_FLAG				(0x1 << 13)
+#define CHIPID_CTL1_B1P_FLAG				(0x1 << 12)
+#define CHIPID_CTL1_PGENB				(0x1 << 11)
+#define CHIPID_CTL1_STROBE				(0x1 << 10)
+#define CHIPID_CTL1_LOAD				(0x1 << 9)
+#define CHIPID_CTL1_CSB					(0x1 << 8)
+#define CHIPID_CTL1_P_SEL				(0x1 << 7)
+#define CHIPID_CTL1_B_SEL				(0x1 << 6)
+#define CHIPID_CTL1_A_MASK				(0x3F << 0)
+#define CHIPID_CTL1_A_SET(x)				(((x) & 0x3F) << 0)
+
+/******************************************************************************/
+/* CHIPID_CTL2 */
+#define CHIPID_CTL2_PASSWORD_MASK			(0xFFFFFFFF << 0)
+#define CHIPID_CTL2_PASSWORD_SET(x)		(((x) & 0xFFFFFFFF) << 0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* ifndef __CHIPID_REG_ATM7039_H__ */
diff --git a/arch/arm/mach-owl/include/mach/clkname.h b/arch/arm/mach-owl/include/mach/clkname.h
new file mode 100755
index 0000000..22d32c2
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/clkname.h
@@ -0,0 +1,174 @@
+#ifndef CLKNAME_H
+#define CLKNAME_H
+
+/*
+ * Assumed module level clocks
+ */
+#define CLKNAME_CMUMOD_DEVCLKS       "CMUMOD_DEVCLKS"
+#define CLKNAME_CMUMOD_GPU3D         "CMUMOD_GPU3D"
+#define CLKNAME_CMUMOD_SHARESRAM     "CMUMOD_SHARESRAM"
+#define CLKNAME_CMUMOD_HDCP2X        "CMUMOD_HDCP2X"
+#define CLKNAME_CMUMOD_VCE           "CMUMOD_VCE"
+#define CLKNAME_CMUMOD_VDE           "CMUMOD_VDE"
+#define CLKNAME_CMUMOD_PCM0          "CMUMOD_PCM0"
+#define CLKNAME_CMUMOD_SPDIF         "CMUMOD_SPDIF"
+#define CLKNAME_CMUMOD_HDMIA         "CMUMOD_HDMIA"
+#define CLKNAME_CMUMOD_I2SRX         "CMUMOD_I2SRX"
+#define CLKNAME_CMUMOD_I2STX         "CMUMOD_I2STX"
+#define CLKNAME_CMUMOD_GPIO          "CMUMOD_GPIO"
+#define CLKNAME_CMUMOD_KEY           "CMUMOD_KEY"
+#define CLKNAME_CMUMOD_LENS          "CMUMOD_LENS"
+#define CLKNAME_CMUMOD_BISP          "CMUMOD_BISP"
+#define CLKNAME_CMUMOD_CSI           "CMUMOD_CSI"
+#define CLKNAME_CMUMOD_DSI           "CMUMOD_DSI"
+#define CLKNAME_CMUMOD_LVDS          "CMUMOD_LVDS"
+#define CLKNAME_CMUMOD_LCD1          "CMUMOD_LCD1"
+#define CLKNAME_CMUMOD_LCD0          "CMUMOD_LCD0"
+#define CLKNAME_CMUMOD_DE            "CMUMOD_DE"
+#define CLKNAME_CMUMOD_SD2           "CMUMOD_SD2"
+#define CLKNAME_CMUMOD_SD1           "CMUMOD_SD1"
+#define CLKNAME_CMUMOD_SD0           "CMUMOD_SD0"
+#define CLKNAME_CMUMOD_NANDC         "CMUMOD_NANDC"
+#define CLKNAME_CMUMOD_DDRCH0        "CMUMOD_DDRCH0"
+#define CLKNAME_CMUMOD_NOR           "CMUMOD_NOR"
+#define CLKNAME_CMUMOD_DMAC          "CMUMOD_DMAC"
+#define CLKNAME_CMUMOD_DDRCH1        "CMUMOD_DDRCH1"
+#define CLKNAME_CMUMOD_I2C3          "CMUMOD_I2C3"
+#define CLKNAME_CMUMOD_I2C2          "CMUMOD_I2C2"
+#define CLKNAME_CMUMOD_TIMER         "CMUMOD_TIMER"
+#define CLKNAME_CMUMOD_PWM3          "CMUMOD_PWM3"
+#define CLKNAME_CMUMOD_PWM2          "CMUMOD_PWM2"
+#define CLKNAME_CMUMOD_PWM1          "CMUMOD_PWM1"
+#define CLKNAME_CMUMOD_PWM0          "CMUMOD_PWM0"
+#define CLKNAME_CMUMOD_ETHERNET      "CMUMOD_ETHERNET"
+#define CLKNAME_CMUMOD_UART5         "CMUMOD_UART5"
+#define CLKNAME_CMUMOD_UART4         "CMUMOD_UART4"
+#define CLKNAME_CMUMOD_UART3         "CMUMOD_UART3"
+#define CLKNAME_CMUMOD_UART6         "CMUMOD_UART6"
+#define CLKNAME_CMUMOD_PCM1          "CMUMOD_PCM1"
+#define CLKNAME_CMUMOD_I2C1          "CMUMOD_I2C1"
+#define CLKNAME_CMUMOD_I2C0          "CMUMOD_I2C0"
+#define CLKNAME_CMUMOD_SPI3          "CMUMOD_SPI3"
+#define CLKNAME_CMUMOD_SPI2          "CMUMOD_SPI2"
+#define CLKNAME_CMUMOD_SPI1          "CMUMOD_SPI1"
+#define CLKNAME_CMUMOD_SPI0          "CMUMOD_SPI0"
+#define CLKNAME_CMUMOD_IRC           "CMUMOD_IRC"
+#define CLKNAME_CMUMOD_UART2         "CMUMOD_UART2"
+#define CLKNAME_CMUMOD_UART1         "CMUMOD_UART1"
+#define CLKNAME_CMUMOD_UART0         "CMUMOD_UART0"
+#define CLKNAME_CMUMOD_HDMI          "CMUMOD_HDMI"
+#define CLKNAME_CMUMOD_SS            "CMUMOD_SS"
+#define CLKNAME_CMUMOD_TV24M         "CMUMOD_TV24M"
+#define CLKNAME_CMUMOD_TVOUT         "CMUMOD_TVOUT"
+
+/*
+ * CPU clocks
+ */
+#define CLKNAME_HOSC                 "HOSC"
+#define CLKNAME_IC_32K               "IC_32K"
+#define CLKNAME_DEVPLL               "DEVPLL"
+#define CLKNAME_DDRPLL               "DDRPLL"
+#define CLKNAME_NANDPLL              "NANDPLL"
+#define CLKNAME_DISPLAYPLL           "DISPLAYPLL"
+#define CLKNAME_AUDIOPLL             "AUDIOPLL"
+#define CLKNAME_TVOUTPLL             "TVOUTPLL"
+#define CLKNAME_DEEPCOLORPLL         "DEEPCOLORPLL"
+#define CLKNAME_ETHERNETPLL          "ETHERNETPLL"
+#define CLKNAME_CVBSPLL          	 "CVBSPLL"
+#define CLKNAME_DEV_CLK              "DEV_CLK"
+#define CLKNAME_DDR_CLK_0            "DDR_CLK_0"
+#define CLKNAME_DDR_CLK_90           "DDR_CLK_90"
+#define CLKNAME_DDR_CLK_180          "DDR_CLK_180"
+#define CLKNAME_DDR_CLK_270          "DDR_CLK_270"
+#define CLKNAME_DDR_CLK_CH0          "DDR_CLK_CH0"
+#define CLKNAME_DDR_CLK_CH1          "DDR_CLK_CH1"
+#define CLKNAME_DDR_CLK              "DDR_CLK"
+#define CLKNAME_SPDIF_CLK            "SPDIF_CLK"
+#define CLKNAME_HDMIA_CLK            "HDMIA_CLK"
+#define CLKNAME_I2SRX_CLK            "I2SRX_CLK"
+#define CLKNAME_I2STX_CLK            "I2STX_CLK"
+#define CLKNAME_PCM0_CLK             "PCM0_CLK"
+#define CLKNAME_PCM1_CLK             "PCM1_CLK"
+#define CLKNAME_CLK_CVBSX2           "CLK_CVBSX2"
+#define CLKNAME_CLK_CVBS             "CLK_CVBS"
+#define CLKNAME_CVBS_CLK108M         "CVBS_CLK108M"
+#define CLKNAME_CLK_PIXEL            "CLK_PIXEL"
+#define CLKNAME_CLK_TMDS             "CLK_TMDS"
+#define CLKNAME_CLK_TMDS_PHY_P       "CLK_TMDS_PHY_P"
+#define CLKNAME_CLK_TMDS_PHY_N       "CLK_TMDS_PHY_N"
+#define CLKNAME_L2_NIC_CLK           "L2_NIC_CLK"
+#define CLKNAME_APBDBG_CLK           "APBDBG_CLK"
+#define CLKNAME_L2_CLK               "L2_CLK"
+#define CLKNAME_ACP_CLK              "ACP_CLK"
+#define CLKNAME_PERIPH_CLK           "PERIPH_CLK"
+#define CLKNAME_NIC_DIV_CLK          "NIC_DIV_CLK"
+#define CLKNAME_NIC_CLK              "NIC_CLK"
+#define CLKNAME_AHBPREDIV_CLK        "AHBPREDIV_CLK"
+#define CLKNAME_H_CLK                "H_CLK"
+#define CLKNAME_APB30_CLK            "APB30_CLK"
+#define CLKNAME_APB20_CLK            "APB20_CLK"
+#define CLKNAME_AHB_CLK              "AHB_CLK"
+#define CLKNAME_SENSOR_CLKOUT0       "SENSOR_CLKOUT0"
+#define CLKNAME_SENSOR_CLKOUT1       "SENSOR_CLKOUT1"
+#define CLKNAME_LCD_CLK              "LCD_CLK"
+#define CLKNAME_LVDS_CLK             "LVDS_CLK"
+#define CLKNAME_CKA_LCD_H            "CKA_LCD_H"
+#define CLKNAME_LCD1_CLK             "LCD1_CLK"
+#define CLKNAME_LCD0_CLK             "LCD0_CLK"
+#define CLKNAME_DSI_HCLK             "DSI_HCLK"
+#define CLKNAME_DSI_HCLK90           "DSI_HCLK90"
+#define CLKNAME_PRO_CLK              "PRO_CLK"
+#define CLKNAME_PHY_CLK              "PHY_CLK"
+#define CLKNAME_CSI_CLK              "CSI_CLK"
+#define CLKNAME_DE1_CLK              "DE1_CLK"
+#define CLKNAME_DE2_CLK              "DE2_CLK"
+#define CLKNAME_BISP_CLK             "BISP_CLK"
+#define CLKNAME_ISPBP_CLK            "ISPBP_CLK"
+#define CLKNAME_IMG5_CLK             "IMG5_CLK"
+#define CLKNAME_VDE_CLK              "VDE_CLK"
+#define CLKNAME_VCE_CLK              "VCE_CLK"
+#define CLKNAME_NANDC_CLK            "NANDC_CLK"
+#define CLKNAME_ECC_CLK              "ECC_CLK"
+#define CLKNAME_PRESD0_CLK           "PRESD0_CLK"
+#define CLKNAME_PRESD1_CLK           "PRESD1_CLK"
+#define CLKNAME_PRESD2_CLK           "PRESD2_CLK"
+#define CLKNAME_SD0_CLK_2X           "SD0_CLK_2X"
+#define CLKNAME_SD1_CLK_2X           "SD1_CLK_2X"
+#define CLKNAME_SD2_CLK_2X           "SD2_CLK_2X"
+#define CLKNAME_SD0_CLK              "SD0_CLK"
+#define CLKNAME_SD1_CLK              "SD1_CLK"
+#define CLKNAME_SD2_CLK              "SD2_CLK"
+#define CLKNAME_UART0_CLK            "UART0_CLK"
+#define CLKNAME_UART1_CLK            "UART1_CLK"
+#define CLKNAME_UART2_CLK            "UART2_CLK"
+#define CLKNAME_UART3_CLK            "UART3_CLK"
+#define CLKNAME_UART4_CLK            "UART4_CLK"
+#define CLKNAME_UART5_CLK            "UART5_CLK"
+#define CLKNAME_UART6_CLK            "UART6_CLK"
+#define CLKNAME_PWM0_CLK             "PWM0_CLK"
+#define CLKNAME_PWM1_CLK             "PWM1_CLK"
+#define CLKNAME_PWM2_CLK             "PWM2_CLK"
+#define CLKNAME_PWM3_CLK             "PWM3_CLK"
+#define CLKNAME_PWM4_CLK             "PWM4_CLK"
+#define CLKNAME_PWM5_CLK             "PWM5_CLK"
+#define CLKNAME_RMII_REF_CLK         "RMII_REF_CLK"
+#define CLKNAME_I2C0_CLK             "I2C0_CLK"
+#define CLKNAME_I2C1_CLK             "I2C1_CLK"
+#define CLKNAME_I2C2_CLK             "I2C2_CLK"
+#define CLKNAME_I2C3_CLK             "I2C3_CLK"
+#define CLKNAME_25M_CLK              "25M_CLK"
+#define CLKNAME_LENS_CLK             "LENS_CLK"
+#define CLKNAME_HDMI24M              "HDMI24M"
+#define CLKNAME_TIMER_CLK            "TIMER_CLK"
+#define CLKNAME_SS_CLK               "SS_CLK"
+#define CLKNAME_SPS_CLK              "SPS_CLK"
+#define CLKNAME_IRC_CLK              "IRC_CLK"
+#define CLKNAME_TV24M                "TV24M"
+#define CLKNAME_MIPI24M              "MIPI24M"
+#define CLKNAME_LENS24M              "LENS24M"
+#define CLKNAME_GPU3D_SYSCLK         "GPU3D_SYSCLK"
+#define CLKNAME_GPU3D_HYDCLK         "GPU3D_HYDCLK"
+#define CLKNAME_GPU3D_NIC_MEMCLK     "GPU3D_NIC_MEMCLK"
+#define CLKNAME_GPU3D_CORECLK        "GPU3D_CORECLK"
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/clkname_priv.h b/arch/arm/mach-owl/include/mach/clkname_priv.h
new file mode 100755
index 0000000..b235432
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/clkname_priv.h
@@ -0,0 +1,11 @@
+#ifndef CLKNAME_PRIV_H
+#define CLKNAME_PRIV_H
+
+/*
+ * Assumed module level clocks
+ */
+#define CLKNAME_COREPLL              "COREPLL_PRIV"
+#define CLKNAME_CORE_CLK             "CORE_CLK_PRIV"
+#define CLKNAME_CPU_CLK              "CPU_CLK_PRIV"
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/clock-owl.h b/arch/arm/mach-owl/include/mach/clock-owl.h
new file mode 100755
index 0000000..6b78da6
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/clock-owl.h
@@ -0,0 +1,7 @@
+
+#ifndef __LINUX_CLK_PROVIDER_H
+#include <linux/clk-provider.h>
+#endif
+
+#include <mach/../../clock-owl.h>
+
diff --git a/arch/arm/mach-owl/include/mach/cpu_map-owl.h b/arch/arm/mach-owl/include/mach/cpu_map-owl.h
new file mode 100755
index 0000000..e61789e
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/cpu_map-owl.h
@@ -0,0 +1,31 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Actions Semi Inc.
+*/
+/******************************************************************************/
+
+/******************************************************************************/
+#ifndef __OWL_CPU_MAP_H__
+#define __OWL_CPU_MAP_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct cpu0_opp_table {
+	unsigned long clk; /*khz*/
+	unsigned long volt; /*uv*/
+};
+
+//extern int cpu0_add_opp_table(struct device *cpu_dev, struct cpu0_opp_table *table, int table_size);
+
+/******************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/debug-macro.S b/arch/arm/mach-owl/include/mach/debug-macro.S
new file mode 100755
index 0000000..04d9388
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/debug-macro.S
@@ -0,0 +1,56 @@
+/*
+ * arch/arm/mach-gl5202/include/mach/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <mach/hardware.h>
+
+    .macro  addruart, rp, rv, tmp
+    ldr     \rp, =UART0_CTL                     @ physical base address
+    mrc     p15, 0, \rv, c1, c0
+    tst     \rv, #1                             @ MMU enabled?
+    beq     100f
+    ldr     \rp, =IO_ADDRESS(UART0_CTL)         @ virtual address
+
+100:
+    ldr     \rv, [\rp]
+    and     \rv, \rv, #0x00008000
+    cmp     \rv, #0                             @ is port configured?
+    bne     101f
+    
+    add     \rp, \rp, #0x00002000
+    b       100b
+
+101:
+    and     \rp, \rp, #0x03ffffff
+    orr     \rv, \rp, #0xf8000000               @ virtual
+    orr     \rp, \rp, #0xb0000000               @ physical
+
+    .endm
+
+    .macro  senduart,rd,rx
+    str     \rd, [\rx, #(UART0_TXDAT - UART0_BASE)] @ Write to Transmitter Holding Register
+    .endm
+
+    .macro  busyuart, rd, rx
+1001:   
+    ldr     \rd, [\rx, #(UART0_STAT - UART0_BASE)]  @ Read Status Register
+    tst     \rd, #0x40                          @ TXFIFO Full?
+    bne     1001b
+    .endm
+
+    .macro  waituart,rd,rx
+1001:   
+    ldr     \rd, [\rx, #(UART0_STAT - UART0_BASE)]  @ Read Status Register
+    tst     \rd, #0x400                         @ TXFIFO Empty?
+    beq     1001b
+    .endm
\ No newline at end of file
diff --git a/arch/arm/mach-owl/include/mach/debug-owl.h b/arch/arm/mach-owl/include/mach/debug-owl.h
new file mode 100755
index 0000000..7bf8daa
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/debug-owl.h
@@ -0,0 +1,19 @@
+/*
+ * debug stuff
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __DEBUG_OWL_H__
+#define __DEBUG_OWL_H__
+
+extern void owl_dump_mem(void *startaddr, int size, void *showaddr, int show_bytes);
+extern void owl_dump_reg(unsigned int addr, int size);
+
+#endif /* __DEBUG_OWL_H__ */
diff --git a/arch/arm/mach-owl/include/mach/debug.h b/arch/arm/mach-owl/include/mach/debug.h
new file mode 100755
index 0000000..d932cb6
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/debug.h
@@ -0,0 +1,21 @@
+/*
+ * arch/arm/mach-leopard/include/mach/debug.h
+ *
+ * debug stuff
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_DEBUG_H
+#define __ASM_ARCH_DEBUG_H
+
+extern void owl_dump_mem(void *startaddr, int size, void *showaddr, int show_bytes);
+extern void owl_dump_reg(unsigned int addr, int size);
+
+#endif /* __ASM_ARCH_DEBUG_H */
diff --git a/arch/arm/mach-owl/include/mach/display-owl.h b/arch/arm/mach-owl/include/mach/display-owl.h
new file mode 100755
index 0000000..0bb6f88
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/display-owl.h
@@ -0,0 +1,247 @@
+/*
+ *
+ *  Copyright (C) 2006 Luming Yu <luming.yu@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#ifndef _LINUX_OWL_DISPLAY_H
+#define _LINUX_OWL_DISPLAY_H
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#include <mach/dss-owl.h>
+
+#define	DUMMY_DISPLAYER		0x40000000
+
+struct owl_display_device;
+//struct fb_info;
+
+//struct fb_videomode;
+
+struct display_ops {
+	int (*update_status)(struct owl_display_device *);
+	int (*get_status)(struct owl_display_device *);
+	int (*update_mode)(struct owl_display_device *);
+	int (*set_preline)(struct owl_display_device *, int num_preline);
+	int (*get_bpp)(struct owl_display_device *);
+
+	/*if src_clk_hz == 0, it means using the dev current src clk*/
+	/*if mode == NULL, it means using the dev current mode*/
+	unsigned int (*get_devclk_khz)(struct owl_display_device *, unsigned int src_clk_khz, const struct fb_videomode *mode);
+	unsigned int (*get_tvoutpll1_khz)(struct owl_display_device *, const struct fb_videomode *mode);
+
+	int (*check_fb)(struct fb_info *);
+};
+
+struct owl_videomode{
+	int valid;
+	struct fb_videomode mode;
+};
+
+struct owl_display_device {
+/***parameters that disp dev provides, framebuffer driver will never change them******/
+	int display_id;		/*LCD_DISPLAYER,HDMI_DISPLAYER... ...*/
+	struct list_head modelist;
+	const struct owl_videomode *modes;
+	int num_modes;
+	const struct fb_videomode *disp_cur_mode;
+	int is_plugged;
+/***********************************************************************/
+
+/*******parameters that framebuffer driver may change******************/	
+	const struct fb_videomode *fb_cur_mode;
+	int state;
+	int power;
+	int fb_blank;
+/***************************************************************/
+	
+	struct mutex lock;
+	struct display_ops *ops;
+	struct device dev;
+
+	struct notifier_block fb_notif;
+	struct notifier_block cpufreq_notif;
+	struct list_head entry;
+
+};
+#define to_owl_display_device(obj) container_of(obj, struct owl_display_device, dev)
+
+/* update current mode for each device */
+static inline int update_current_device_mode(struct owl_display_device *disp_dev)
+{
+	u32 i;
+	const struct owl_videomode *pmode = disp_dev->modes;
+	u32 vid = disp_dev->fb_cur_mode->vid;
+
+	u32 mode_num = disp_dev->num_modes;
+	for (i = 0; i < mode_num; i++, pmode++) {
+		if (vid == pmode->mode.vid) {
+			disp_dev->disp_cur_mode = &pmode->mode;
+			return 0;
+		}
+	}
+	disp_dev->disp_cur_mode = NULL;
+	return -EINVAL;
+}
+
+
+
+static inline void owl_display_update_status(struct owl_display_device *disp_dev)
+{
+	mutex_lock(&disp_dev->lock);
+	if (disp_dev->ops && disp_dev->ops->update_status){
+		disp_dev->ops->update_status(disp_dev);
+	}
+	mutex_unlock(&disp_dev->lock);
+}
+
+static inline void owl_display_update_mode(struct owl_display_device *disp_dev)
+{
+	mutex_lock(&disp_dev->lock);
+	if (disp_dev->ops && disp_dev->ops->update_mode){
+		update_current_device_mode(disp_dev);
+		disp_dev->ops->update_mode(disp_dev);
+	}
+	mutex_unlock(&disp_dev->lock);	
+}
+
+static inline void owl_display_set_preline(
+	struct owl_display_device *disp_dev,
+	int num_preline)
+{
+	mutex_lock(&disp_dev->lock);
+	if (disp_dev->ops && disp_dev->ops->set_preline)
+		disp_dev->ops->set_preline(disp_dev, num_preline);
+
+	mutex_unlock(&disp_dev->lock);
+}
+
+static inline int owl_display_get_bpp(struct owl_display_device *disp_dev)
+{
+	int ret;
+	mutex_lock(&disp_dev->lock);
+	if (disp_dev->ops && disp_dev->ops->get_bpp)
+		ret = disp_dev->ops->get_bpp(disp_dev);
+	else
+		ret = -EINVAL;
+	mutex_unlock(&disp_dev->lock);
+
+	return ret;
+}
+
+static inline unsigned int owl_display_get_devclk_khz(struct owl_display_device *disp_dev, 
+											int src_clk_hz,
+											const struct fb_videomode *mode)
+{
+	unsigned int devclk_khz = 0;
+//	mutex_lock(&disp_dev->lock);
+	if (disp_dev->ops && disp_dev->ops->get_devclk_khz)
+		devclk_khz = disp_dev->ops->get_devclk_khz(disp_dev, src_clk_hz, mode);
+//	mutex_unlock(&disp_dev->lock);	
+	return devclk_khz;
+}
+
+static inline unsigned int owl_display_get_tvoutpll1_khz(struct owl_display_device *disp_dev, 
+											const struct fb_videomode *mode)
+{
+	unsigned int tvoutpll1_khz = 0;
+//	mutex_lock(&disp_dev->lock);
+	if (disp_dev->ops && disp_dev->ops->get_tvoutpll1_khz)
+		tvoutpll1_khz = disp_dev->ops->get_tvoutpll1_khz(disp_dev, mode);
+//	mutex_unlock(&disp_dev->lock);	
+	return tvoutpll1_khz;
+}
+
+extern int owl_display_register_client(struct notifier_block *nb);
+extern int owl_display_unregister_client(struct notifier_block *nb);
+extern int owl_display_notifier_call_chain(unsigned long val, void *v);
+
+enum owl_display_notifiy_val{
+	OWL_DISPLAY_NOTIF_PLUG			= 0,
+	OWL_DISPLAY_NOTIF_REGISTER		= 1,
+};
+
+
+extern struct owl_display_device *get_owl_display(int display_id);
+extern struct owl_display_device *owl_display_connect(int display_id);
+extern void owl_display_disconnect(struct owl_display_device* disp_dev);
+extern int owl_display_check_display_devices(int *plugged_disp_dev_ids, int *registered_disp_dev_ids);
+extern struct owl_display_device *owl_display_device_register(const char *name,
+	struct device *dev,
+	void *devdata,
+	int display_id,
+	const struct owl_videomode *modes,
+	u32 num_modes,
+	struct display_ops *ops);
+extern void owl_display_device_unregister(struct owl_display_device *dev);
+extern int owl_display_device_store_modes(struct owl_display_device * dev,
+	const struct owl_videomode *modes,
+	u32 num_modes);
+extern void owl_videomode_to_modelist(const struct owl_videomode *modedb, int num,
+			      struct list_head *head);
+
+/****lcd interface convertion ic************/
+enum {
+	LCDIC_TYPE_LVDS2EDP = 0,
+	LCDIC_TYPE_MAX,
+};
+
+struct lcdi_convertion;
+
+struct lcdi_convertion_ops {
+	int (*enable)(struct lcdi_convertion *);	
+	int (*disable)(struct lcdi_convertion *);
+};
+
+struct lcdi_convertion {
+	struct device dev;
+
+	int type;
+	struct lcdi_convertion_ops *ops;
+};
+
+extern struct lcdi_convertion *lcdi_convertion_register(const char *name,
+				struct device *dev,
+				void *devdata,
+				int type,
+				struct lcdi_convertion_ops *ops);
+
+extern void lcdi_convertion_free(struct lcdi_convertion *lcdic);
+extern struct lcdi_convertion *lcdi_convertion_get(int type);
+
+static inline int lcdi_convertion_enable(struct lcdi_convertion *lcdic)
+{
+	int ret = 0;
+	if (lcdic && lcdic->ops->enable)
+		ret = lcdic->ops->enable(lcdic);
+
+	return ret;
+}
+
+static inline int lcdi_convertion_disable(struct lcdi_convertion *lcdic)
+{
+	int ret = 0;
+	if (lcdic && lcdic->ops->disable)
+		ret = lcdic->ops->disable(lcdic);
+
+	return ret;
+}
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/dsi-owl.h b/arch/arm/mach-owl/include/mach/dsi-owl.h
new file mode 100755
index 0000000..119becb
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/dsi-owl.h
@@ -0,0 +1,33 @@
+#ifndef __DSI_OWL_H__
+#define __DSI_OWL_H__
+
+/*=================================================================*/
+/* rgb lcd stuff */
+#include <linux/fb.h>
+#include <linux/delay.h>
+
+#include <mach/dss-owl.h>
+#include <mach/hardware.h>
+
+#if 0
+#define DSI_PRINT(fmt, args...) printk(KERN_ALERT fmt, ##args)
+#else
+#define DSI_PRINT(fmt, args...)
+#endif
+
+enum owl_mipi_dsi_data_fmt {
+	MIPI_RGB565,
+	MIPI_RGB666,
+	MIPI_RGB666_LP,
+	MIPI_RGB888,
+};
+
+
+struct owl_dsi_data {
+	struct owl_videomode *modes;
+	u32 num_modes;
+};
+
+
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/dss-owl.h b/arch/arm/mach-owl/include/mach/dss-owl.h
new file mode 100755
index 0000000..ed362ea
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/dss-owl.h
@@ -0,0 +1,597 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation
+ * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __DSS_OWL_H__
+#define __DSS_OWL_H__
+
+#include <linux/list.h>
+#include <linux/kobject.h>
+#include <linux/device.h>
+#include <linux/atomic.h>
+
+#include <mach/display-owl.h>
+#include <mach/dss_user-owl.h>
+
+struct owl_overlay_manager;
+
+#define OWL_DISP_CHANNEL_NUM	2
+#define MAX_CHANNEL_NUM	OWL_DISP_CHANNEL_NUM
+
+enum disp_dev_id {
+	LCD_DISPLAYER = 0x1,
+	HDMI_DISPLAYER = 0x2,
+	TV_CVBS_DISPLAYER = 0x4,
+	TV_YPbPr_DISPLAYER = 0x8,
+	LCD1_DISPLAYER = 0x10,
+	DSI_DISPLAYER = 0x20,
+};
+
+#define MAX_NUM_DISP_DEV	4
+
+#ifdef CONFIG_ACT_EBOX
+#define OWL_INIT_DISPLAYERS_MDSB		\
+	(HDMI_DISPLAYER | TV_CVBS_DISPLAYER)
+#endif
+
+/*
+enum owl_layer_id {
+	GL5201DE_GRAPHIC_LAYER	= 0,
+	GL5201DE_VIDEO_LAYER		= 1,
+	MAX_OVERLAY_NUM
+};
+*/
+
+#define OWL_MAX_LAYER_REGION_NUM		1
+#define MAX_LAYER_REGION_NUM		OWL_MAX_LAYER_REGION_NUM
+
+enum owl_overlay_manager_id {
+	OWL_OVERLAY_MANAGER_PRIMARY	= 0,
+	OWL_OVERLAY_MANAGER_OVERLAY	= 1,
+};
+
+enum owl_overlay_caps {
+	OWL_DSS_OVL_CAP_SCALE = 1 << 0,
+	OWL_DSS_OVL_CAP_REGIONS = 1 << 1,
+	OWL_DSS_OVL_CAP_2X = 1 << 2,
+
+	/*rotate stuff*/
+	OWL_DSS_OVL_CAP_ROT_180 = 1 << 3,
+};
+
+enum owl_overlay_manager_caps {
+	OWL_DSS_OVL_MGR_CAP_DISPC = 1 << 0,
+};
+
+enum owl_channel_caps {
+	OWL_DSS_CHANNEL_CAP_MDSB = 1 << 0,
+};
+
+enum owl_arrange_option {
+	/*no scale, preserve aspect*/
+	ARR_ORIGINAL_SIZE		= 0x0,
+
+	/*fill the whole screen,ignore aspect*/
+	ARR_SCALE_FULL_SIZE		= 0x1,
+
+	/*scale the image to fit the screen, centred , preserve aspect*/
+	ARR_SCALE_FIT_SIZE		= 0x2,
+
+	/*if original image is smaller than screen, then original size*/
+	ARR_SCALE_ORIGINAL_OR_FIT_SIZE	= 0x3,
+
+	ARR_SCALE_MAX,
+	ARR_BASE_MASK = 0xf,
+
+	/*extra arrange methods*/
+	ARR_2X_MODE			= 0x10,
+	ARR_ALL_CUSTOM		= 0x40,
+
+
+	ARR_EXTRA_MASK		= 0xf0,
+
+	ARR_TYPES_MASK		=
+			(ARR_BASE_MASK | ARR_EXTRA_MASK),
+
+
+	/*user defined cor&size, need to remap according to scale option*/
+	ARR_REMAP_FLAG	= 0x100,
+	ARR_SHUTDOWN_FLAG	= 0x200,
+
+	ARR_FLAGS_MASK	= 0xf00,
+
+};
+
+typedef union {
+		u32 rgb565;
+		struct {u32 y, u, v; } yuv_p;
+		struct {u32 y, uv; } yuv_sp;
+		u32 yuv_interleaved;
+		struct {u32 yc, uvc, ylut, uvlut; } yuv_spc;
+		struct {u32 ly, luv, ry, ruv; } yuv_sp3d;
+} pixel_t;
+
+struct rgb_color {
+	unsigned char red;
+	unsigned char green;
+	unsigned char blue;
+};
+
+
+enum COLORKEY_MATCH_RULE {
+	MATCH_ALWAYS  = 0x00,
+	MATCH_BETWEEN = 0x01,
+	MATCH_EXCEPT  = 0x02,
+};
+
+struct colorkey {
+	struct rgb_color min;
+	struct rgb_color max;
+
+	unsigned int  green_match_rule;
+	unsigned int  red_match_rule;
+	unsigned int  blue_match_rule;
+
+};
+
+struct owl_channel {
+	struct list_head list;
+
+	int id;
+
+	u32 caps;
+
+	int num_display;
+	u32 display_ids;
+	struct owl_display_device *display[MAX_NUM_DISP_DEV];
+
+	int num_layers;
+	int layers_bitmap;
+	int prim_ovl_id;
+
+	int preline_exptime_us;
+
+	struct rgb_color background;
+
+/*this "enable" member cannot be cached*/
+/*the channel enable/disable ops will flush it immediately*/
+	bool enable;
+};
+
+struct owl_region {
+	struct kobject kobj;
+	struct owl_overlay *ovl;
+	int id;
+/*****config info*******************/
+	bool enable;
+
+	/*input information*/
+	u16 xoff;
+	u16 yoff;
+	u16 input_width;
+	u16 input_height;
+
+	/* output information*/
+	u16 xcor;
+	u16 ycor;
+	u16 output_width;
+	u16 output_height;
+
+/****states*********************/
+	pixel_t data_buffer;
+
+};
+
+struct owl_overlay_info {
+	u32 paddr;
+	void __iomem *vaddr;
+	u32 width;
+	u32 height;
+	enum owl_pixel_format pixfmt;
+	u32 rotation;
+	bool global_alpha_enable;
+	u8 global_alpha;
+
+	bool trans_enable;
+	struct colorkey trans_key;
+
+	bool ilace;
+	u32 field;
+
+	pixel_t src_w;		/*line length in pixel*/
+
+	const struct fb_videomode *required_modes[MAX_NUM_DISP_DEV];
+	int required_mdsb_table_subs;
+
+	/*states, users don't need to set them, */
+	/*dss will encode them using infomations above*/
+	pixel_t bpp;
+	pixel_t pitch;			/*line length in bytes*/
+
+/*CURRENTLY, we assume all regions are controlled by the layer*/
+/*which means the overlay info will be set to every region*/
+/*but things may happen that some regions will controlled seperately, TODO*/
+	u32 arrange;
+	u32 w_scale_rate;
+	u32 h_scale_rate;
+
+
+	u32 umap_xoff;
+	u32 umap_yoff;
+	u32 umap_input_w;
+	u32 umap_input_h;
+	u32 virt_scr_w;
+	u32 virt_scr_h;
+	u32 umap_xcor;
+	u32 umap_ycor;
+	u32 umap_output_w;
+	u32 umap_output_h;
+
+	int num_regions;
+	struct owl_region region[MAX_LAYER_REGION_NUM];
+};
+
+struct overlay_stack {
+	struct owl_overlay *ovls[MAX_OVERLAY_NUM];
+	int ovl_num;
+};
+
+enum owl_overlay_stack_state {
+	OVL_STACK_NONE = 0,
+	OVL_STACK_SLAVE = 1,
+	OVL_STACK_PRIM= 1,
+};
+
+struct owl_overlay {
+	struct kobject kobj;
+	struct list_head list;
+
+	/* static fields */
+	char name[32];
+	int id;
+	u32 supported_pixfmts;
+	u32 caps;
+
+	const char *owner_name;
+
+	/* dynamic fields */
+	struct owl_overlay_manager *manager;
+
+	bool channel_changed;
+	struct owl_channel *channel;
+
+	bool wakeup;
+	bool state;
+
+	bool enable;
+	bool info_dirty;
+	struct owl_overlay_info info;
+
+	char master_dev_type[20];
+	struct platform_device *master_pdev;
+
+	struct overlay_stack *slave_ovls;
+	u32 stack_state; /*SEE OVL_STACK_*/
+
+	int (*set_manager)(struct owl_overlay *ovl,
+		struct owl_overlay_manager *mgr, bool init);
+	int (*unset_manager)(struct owl_overlay *ovl);
+
+	int (*set_overlay_info)(struct owl_overlay *ovl,
+			struct owl_overlay_info *info);
+	void (*get_overlay_info)(struct owl_overlay *ovl,
+			struct owl_overlay_info *info);
+	int (*set_overlay_flip)(struct owl_overlay *ovl,
+			u32 paddr, void __iomem *vaddr, u32 field);
+
+/*	int (*wait_for_go)(struct owl_overlay *ovl);*/
+
+	struct mutex ovl_lock;
+};
+
+
+struct owl_global_info {
+	bool info_dirty;
+
+};
+
+struct owl_overlay_manager {
+	struct kobject kobj;
+	struct list_head list;
+
+	/* static fields */
+	char name[32];
+	int id;
+	u32 caps;
+
+	/* dynamic fields */
+	struct owl_global_info *info;
+
+	int (*set_device)(struct owl_overlay *ovl, u32 disp_dev_ids);
+	int (*unset_device)(struct owl_overlay *ovl);
+
+	int (*set_manager_info)(struct owl_overlay_manager *mgr,
+			struct owl_global_info *info);
+	void (*get_manager_info)(struct owl_overlay_manager *mgr,
+			struct owl_global_info *info);
+	int (*write_colreg)(struct owl_overlay_manager *mgr,
+			unsigned regno, unsigned int colreg_data);
+	int (*channel_apply)(struct owl_overlay *ovl);
+	int (*apply)(struct owl_overlay *ovl, bool force);
+	int (*overlay_stack_apply)(struct owl_overlay *ovl, bool force);
+	int (*flip)(struct owl_overlay *ovl, u32 paddr,
+		void __iomem *vaddr, u32 field);
+	int (*overlay_stack_flip)(struct owl_overlay *ovl, u32 paddr[],
+		void __iomem *vaddr[], u32 field[], int num_ovls);
+	int (*wait_for_go)(struct owl_overlay *ovl);
+	int (*wait_for_vsync)(struct owl_overlay *ovl);
+
+	int (*enable)(struct owl_overlay *ovl);
+	int (*disable)(struct owl_overlay *ovl);
+	int (*sleep)(struct owl_overlay *ovl);
+	int (*wakeup)(struct owl_overlay *ovl);
+};
+
+static inline int mode_string(char *buf, unsigned int offset,
+		       const struct fb_videomode *mode)
+{
+	char m = 'U';
+	char v = 'p';
+
+	if (mode->flag & FB_MODE_IS_DETAILED)
+		m = 'D';
+	if (mode->flag & FB_MODE_IS_VESA)
+		m = 'V';
+	if (mode->flag & FB_MODE_IS_STANDARD)
+		m = 'S';
+
+	if (mode->vmode & FB_VMODE_INTERLACED)
+		v = 'i';
+	if (mode->vmode & FB_VMODE_DOUBLE)
+		v = 'd';
+
+	return snprintf(&buf[offset], PAGE_SIZE - offset, "%c:%dx%d%c-%d\n",
+		m, mode->xres, mode->yres, v, mode->refresh);
+}
+
+extern unsigned int snd_displayers_st_string(char *buf,
+	int plugged_disp_dev_ids, int registered_disp_dev_ids);
+extern unsigned int snd_displayers_string(char *buf, int disp_dev_ids);
+extern unsigned int rev_displayer_string(int *disp_dev_ids, const char *name);
+
+extern struct fb_videomode *fb_find_mode_by_str(
+	const char *buf, int len, struct list_head *head);
+
+extern int string_to_arrange_id(const char *name);
+
+
+int owl_dss_get_num_overlay_managers(void);
+struct owl_overlay_manager *owl_dss_get_overlay_manager(int num);
+
+int owl_dss_get_num_overlays(void);
+struct owl_overlay *owl_dss_get_overlay(int num);
+int owl_dss_grab_overlay(struct owl_overlay *ovl, struct device *owner);
+int owl_dss_release_overlay(struct owl_overlay *ovl, struct device *owner);
+bool is_overlay_inited(struct owl_overlay *ovl);
+
+struct owl_channel *owl_dss_get_channel(int num);
+
+extern int owl_compare_overlay_stack(struct owl_overlay *prim,
+		int ovl_ids[], int ovl_num,
+		int remove_ovl_ids[], int *remove_ovl_num,
+		int add_ovl_ids[], int *add_ovl_num);
+extern int owl_add_overlay_stack(
+		struct owl_overlay *prim, int ovl_id[], int ovl_num);
+extern int owl_remove_overlay_stack(
+		struct owl_overlay *prim, int ovl_id[], int ovl_num);
+extern void owl_destory_overlay_stack(struct owl_overlay *prim);
+extern int _owl_overlay_manager_set(struct owl_overlay *ovl,
+	struct owl_overlay_manager *mgr, bool init);
+extern int owl_overlay_manager_set(struct owl_overlay *ovl,
+	struct owl_overlay_manager *mgr, bool init);
+extern void owl_get_overlay_info(struct owl_overlay *ovl,
+	struct owl_overlay_info *info);
+extern int owl_set_overlay_info(struct owl_overlay *ovl,
+	struct owl_overlay_info *info);
+
+extern int owl_dss_update_display_device_state(struct owl_channel *channel);
+
+extern int owl_overlay_channel_set(struct owl_overlay *ovl,
+	struct owl_channel *channel,
+	struct owl_overlay_manager *mgr, bool init);
+extern int owl_disp_device_update(struct owl_overlay *ovl);
+extern int owl_disp_device_set(struct owl_overlay *ovl, u32 disp_dev_ids);
+extern int owl_overlay_channel_apply(struct owl_overlay *ovl);
+extern int owl_overlay_apply(struct owl_overlay *ovl);
+extern int owl_overlay_flip(struct owl_overlay *ovl,
+	u32 paddr, void __iomem *vaddr, u32 field);
+extern int owl_overlay_stack_apply(struct owl_overlay *ovl);
+extern int owl_overlay_stack_flip(struct owl_overlay *ovl,
+		u32 paddr[], void __iomem *vaddr[], u32 field[], int num_ovls);
+extern int owl_overlay_wait_for_go(struct owl_overlay *ovl);
+extern int owl_overlay_wait_for_vsync(struct owl_overlay *ovl);
+extern int owl_overlay_enable(struct owl_overlay *ovl);
+extern int owl_overlay_disable(struct owl_overlay *ovl);
+extern int owl_overlay_sleep(struct owl_overlay *ovl);
+extern int owl_overlay_wakeup(struct owl_overlay *ovl);
+const char *owl_overlay_master_dev_get(struct owl_overlay *ovl);
+extern int owl_overlay_master_dev_set(struct owl_overlay *ovl,
+	const char *dev_type, void *pdata);
+extern int owl_overlay_rotate_check(struct owl_overlay *ovl, u32 rotation);
+extern int owl_get_overlay_stack_state(struct owl_overlay *ovl);
+extern int owl_set_overlay_stack_state(struct owl_overlay *ovl,
+	u32 stack_state);
+
+
+
+static inline bool ovl_enable_encode(struct owl_overlay *ovl)
+{
+	return ovl->wakeup && ovl->state;
+}
+
+/*****de irq callback register*********************/
+#define OWL_DE_ISR_TYPE_ONESHOT		0
+#define OWL_DE_ISR_TYPE_STICK		1
+
+typedef void (*owl_de_isr_t) (void *arg, u32 mask);
+typedef void (*owl_de_work_t) (void *arg);
+
+extern int owl_de_register_isr(u32 channel_id,
+	owl_de_isr_t isr, void *arg, u32 mask, u32 type);
+extern int owl_de_unregister_isr(u32 channel_id,
+	owl_de_isr_t isr, void *arg, u32 mask, u32 type);
+extern int owl_de_register_isr_work(u32 channel_id,
+		owl_de_isr_t isr, void *arg_isr,
+		owl_de_work_t work, void *arg_work,
+		u32 mask, u32 type);
+extern int owl_de_unregister_isr_work(u32 channel_id,
+		owl_de_isr_t isr, void *arg_isr,
+		owl_de_work_t work, void *arg_work,
+		u32 mask, u32 type);
+/**************************/
+
+#define OWL_DSS_EVENT_OVL_DISPLAY_SET	1
+#define OWL_DSS_EVENT_OVL_CHANNEL_SET	2
+#define OWL_DSS_EVENT_OVL_DISPLAY_UPDATE	3
+#define OWL_DSS_EVENT_OVL_DISPLAY_PLUG	4
+#define OWL_DSS_EVENT_OVL_ENABLE_REQ	5
+
+struct owl_dss_channlevt {
+	u32 channel_id;
+	u32 changed_ovl_id;
+};
+
+struct owl_dss_plugevt {
+	u32 changed_disp_dev_ids;
+	u32 plugged_disp_dev_ids;
+};
+
+extern int owl_dss_register_client(struct notifier_block *nb);
+extern int owl_dss_unregister_client(struct notifier_block *nb);
+extern int owl_dss_notifier_call_chain(unsigned long val, void *v);
+
+
+extern void print_fb_videomode(const struct fb_videomode *mode);
+extern void owl_copy_modelist(struct list_head *to , struct list_head *from);
+
+
+#ifdef CONFIG_OWL_DSS_MDSB
+extern int mdsb_info_get(struct owl_display_device *displays[],
+					const struct fb_videomode *modes[],
+					int *mdsb_table_subs);
+extern int mdsb_set(int mdsb_table_subs);
+extern int mdsb_apply(void);
+extern int mdsb_hw_enable(void);
+extern int mdsb_hw_disable(void);
+extern int mdsb_enable(void);
+extern int mdsb_disable(void);
+extern int mdsb_init(void);
+#else
+static inline int mdsb_info_get(struct owl_display_device *displays[],
+					const struct fb_videomode *modes[],
+					int *mdsb_table_subs){
+	return 0;
+}
+
+static inline int mdsb_set(int mdsb_table_subs)
+{
+	return 0;
+}
+
+static inline int mdsb_apply(void)
+{
+	return 0;
+}
+
+static inline int mdsb_hw_enable(void)
+{
+	return 0;
+}
+
+static inline int mdsb_hw_disable(void)
+{
+	return 0;
+}
+
+static inline int mdsb_enable(void)
+{
+	return -EINVAL;
+}
+
+static inline int mdsb_disable(void)
+{
+	return 0;
+}
+
+static inline int mdsb_init(void)
+{
+	return 0;
+}
+
+#endif
+
+
+/* actions framebuffer platform data*/
+struct owl_fb_pdata {
+	int overlay_id;
+	bool show_logo;
+	bool inited;
+	bool use_rsvmem;
+
+	int bpp;
+	int img_w;
+	int img_h;
+};
+
+#define OWL_FBDRV_NAME		"owlfb"
+#define OWL_VOUTDRV_NAME	"gl5201_vout"
+
+/*framebuffer reserve mem block*/
+extern unsigned int owl_fb_rsvmem_start;
+extern unsigned int owl_fb_rsvmem_size;
+
+/**/
+
+/******lcd gamma stuff************/
+
+extern unsigned int lcdgamma_rsvmem_start;
+extern unsigned int lcdgamma_rsvmem_size;
+
+extern u32 lcdgamma_table[];
+extern int lcdgamma_table_valid;
+
+/**/
+
+/*dss init state from u-boot*/
+
+/**/
+
+#define PICOS2KHZ_ROUND(a) (DIV_ROUND_CLOSEST(1000000000UL, a))
+#define KHZ2PICOS_ROUND(a) (DIV_ROUND_CLOSEST(1000000000UL, a))
+
+#define PICOS2KHZ_ROUND_UP(a) (DIV_ROUND_UP(1000000000UL, a))
+#define KHZ2PICOS_ROUND_UP(a) (DIV_ROUND_UP(1000000000UL, a))
+
+#ifdef CONFIG_OWL_DSS
+extern int dss_bl_disable_charge(void);
+#else
+static inline int dss_bl_disable_charge(void)
+{
+	return 0;
+}
+#endif
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/dss_user-owl.h b/arch/arm/mach-owl/include/mach/dss_user-owl.h
new file mode 100755
index 0000000..2bb8693
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/dss_user-owl.h
@@ -0,0 +1,95 @@
+#ifndef __DSS_USER_OWL_H
+#define __DSS_USER_OWL_H
+
+/*owl fb private stuff*****/
+
+/****used in struct fb_var_screeninfo.vmode**********************************/
+
+/*don't touch displayers, adjust layer only*/
+/*this option will be cleared after been set,*/
+/*so if you want to use it, set it everytime*/
+#define FB_VMODE_LAYER_ONLY	1024
+
+
+/***********************************************************************/
+enum owl_pixel_format {
+	MONO_1 = 1 << 0,
+	MONO_2 = 1 << 1,
+	MONO_4 = 1 << 2,
+	MONO_8 = 1 << 3,
+
+	PALETTE_1 = 1 << 4,
+	PALETTE_2 = 1 << 5,
+	PALETTE_4 = 1 << 6,
+	PALETTE_8 = 1 << 7,
+
+	RGB_565 = 1 << 8,
+	ARGB_1555 = 1 << 9,
+	ARGB_8888 = 1 << 10,
+	ABGR_8888 = 1 << 11,
+	XRGB_8888 = 1 << 12,
+	XBGR_8888 = 1 << 13,
+
+	YUV_420_PLANAR = 1 << 14,
+	YUV_422_INTERLEAVED = 1 << 15,
+	YUV_420_SEMI_PLANAR = 1 << 16,
+	YUV_SEMI_PLANAR_COMPRESS = 1 << 17,
+};
+
+struct owl_fb_buffer {
+	unsigned int paddr;
+	void *vaddr;
+
+	unsigned long size;
+
+	enum owl_pixel_format pixfmt;
+
+	unsigned short width;
+	unsigned short height;
+
+	/* input information*/
+	unsigned short xoff;
+	unsigned short yoff;
+	unsigned short input_width;
+	unsigned short input_height;
+
+	/* output information*/
+	unsigned short xcor;
+	unsigned short ycor;
+	unsigned short output_width;
+	unsigned short output_height;
+
+	/*see FB_ROTATE_*/
+	unsigned int rotate;
+};
+
+#define MAX_OVERLAY_NUM	4
+
+/**************/
+
+struct owl_fb_dss_comp_data {
+	int num_buffers;
+	struct owl_fb_buffer bufs[MAX_OVERLAY_NUM];
+
+	int is_flip;
+};
+
+enum owl_fb_mem_mode {
+	OWL_FB_MEM_FRAMEBUFFER	= 0,
+	OWL_FB_MEM_USER,
+};
+
+typedef void (*owl_dc_complete_t) (void *);
+
+struct fb_info;
+
+extern int owl_fb_switch_mem_mode(struct fb_info *fbi,
+	enum owl_fb_mem_mode mode,
+	int ovl_ids[], int num_ovls);
+
+extern int owl_fb_dc_queue(struct fb_info *fbi,
+	struct owl_fb_dss_comp_data *buf_data,
+	owl_dc_complete_t func,
+	void *arg);
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/dvfs.h b/arch/arm/mach-owl/include/mach/dvfs.h
new file mode 100755
index 0000000..5fa06aa
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/dvfs.h
@@ -0,0 +1,24 @@
+#ifndef __ASM_ARCH_DVFS_H
+#define __ASM_ARCH_DVFS_H
+
+#define DVFSLEVEL_MAGIC    0x47739582
+#define ASOC_DVFSLEVEL(ic, version, level, level_aux)   \
+    (((((ic) & 0xff) << 24) | (((version) & 0xf)) << 16 | ((level^0x3f)<<10) | ((level_aux) & 0x3ff)) ^ DVFSLEVEL_MAGIC)
+
+#define ASOC_GET_IC(dvfslevel)         ((((dvfslevel) ^ DVFSLEVEL_MAGIC) >> 24) & 0xff)
+#define ASOC_GET_VERSION(dvfslevel)    ((((dvfslevel) ^ DVFSLEVEL_MAGIC) >> 16) & 0xf)
+#define ASOC_GET_TYPE(dvfslevel)       ((((dvfslevel) ^ DVFSLEVEL_MAGIC) >> 10) & 0x3f)
+#define ASOC_GET_TYPE_AUX(dvfslevel)	(((dvfslevel) ^ DVFSLEVEL_MAGIC) & 0x3ff)
+
+/* version A */
+#define ATM7059A_L_1              ASOC_DVFSLEVEL(0x59, 0x0, 0x0, 0x0)
+#define ATM7059B_L_1              ASOC_DVFSLEVEL(0x59, 0x1, 0x0, 0x0)
+#define ATM7059B_L_2              ASOC_DVFSLEVEL(0x59, 0x1, 0x0, 0x6)
+#define ATM7059B_L_3              ASOC_DVFSLEVEL(0x59, 0x1, 0x0, 0x16)
+#define ATM7059B_L_4              ASOC_DVFSLEVEL(0x59, 0x1, 0x0, 0x26)
+#define ATM7059B_L_5              ASOC_DVFSLEVEL(0x59, 0x1, 0x0, 0x15)
+#define ATM7059B_L_6              ASOC_DVFSLEVEL(0x59, 0x1, 0x0, 0x25)
+#define ATM7059B_L_7              ASOC_DVFSLEVEL(0x59, 0x1, 0x0, 0x5)
+#define ATM7059B_L_8              ASOC_DVFSLEVEL(0x59, 0x1, 0x0, 0x66)
+
+#endif /* __ASM_ARCH_DVFS_H */
diff --git a/arch/arm/mach-owl/include/mach/entry-macro.S b/arch/arm/mach-owl/include/mach/entry-macro.S
new file mode 100755
index 0000000..74c24f3
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/entry-macro.S
@@ -0,0 +1,85 @@
+/*
+ * arch/arm/mach-gl5202/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <mach/hardware.h>
+#include <asm/hardware/gic.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		ldr	\base, =IO_ADDRESS(OWL_PA_GIC_CPU)
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		/*
+		 * The interrupt numbering scheme is defined in the
+		 * interrupt controller spec.  To wit:
+		 *
+		 * Interrupts 0-15 are IPI
+		 * 16-28 are reserved
+		 * 29-31 are local.  We allow 30 to be used for the watchdog.
+		 * 32-1020 are global
+		 * 1021-1022 are reserved
+		 * 1023 is "spurious" (no interrupt)
+		 *
+		 * For now, we ignore all local interrupts so only return an interrupt if it's
+		 * between 30 and 1020.  The test_for_ipi routine below will pick up on IPIs.
+		 *
+		 * A simple read from the controller will tell us the number of the highest
+                 * priority enabled interrupt.  We then just need to check whether it is in the
+		 * valid range for an IRQ (30-1020 inclusive).
+		 */
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+		ldr     \irqstat, [\base, #GIC_CPU_INTACK] /* bits 12-10 = src CPU, 9-0 = int # */
+
+		ldr	\tmp, =1021
+
+		bic     \irqnr, \irqstat, #0x1c00
+
+		cmp     \irqnr, #29
+		cmpcc	\irqnr, \irqnr
+		cmpne	\irqnr, \tmp
+		cmpcs	\irqnr, \irqnr
+
+		.endm
+
+		/* We assume that irqstat (the raw value of the IRQ acknowledge
+		 * register) is preserved from the macro above.
+		 * If there is an IPI, we immediately signal end of interrupt on the
+		 * controller, since this requires the original irqstat value which
+		 * we won't easily be able to recreate later.
+		 */
+
+		.macro test_for_ipi, irqnr, irqstat, base, tmp
+		bic	\irqnr, \irqstat, #0x1c00
+		cmp	\irqnr, #16
+		strcc	\irqstat, [\base, #GIC_CPU_EOI]
+		cmpcs	\irqnr, \irqnr
+		.endm
+
+		/* As above, this assumes that irqstat and base are preserved.. */
+
+		.macro test_for_ltirq, irqnr, irqstat, base, tmp
+		bic	\irqnr, \irqstat, #0x1c00
+		mov	\tmp, #0
+		cmp	\irqnr, #29
+		moveq	\tmp, #1
+		streq	\irqstat, [\base, #GIC_CPU_EOI]
+		cmp	\tmp, #0
+		.endm
diff --git a/arch/arm/mach-owl/include/mach/gpio.h b/arch/arm/mach-owl/include/mach/gpio.h
new file mode 100755
index 0000000..efa2904
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/gpio.h
@@ -0,0 +1,41 @@
+/*
+ * GPIO definitions
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#define OWL_GPIO_BANKS         5
+#define OWL_GPIO_PER_BANK      32
+
+enum gpio_group
+{
+    GPIO_GROUP_INVALID = -1,
+    GPIO_GROUP_A = 0,
+    GPIO_GROUP_B,
+    GPIO_GROUP_C,
+    GPIO_GROUP_D,
+    GPIO_GROUP_E,
+};
+
+/* GPIOA/B/C/D/E, GPIOE0~4 */
+#define NR_OWL_GPIO            (4 * 32 + 4)
+
+#define OWL_GPIO_PORTA(x)      ((x) + OWL_GPIO_PER_BANK * 0)
+#define OWL_GPIO_PORTB(x)      ((x) + OWL_GPIO_PER_BANK * 1)
+#define OWL_GPIO_PORTC(x)      ((x) + OWL_GPIO_PER_BANK * 2)
+#define OWL_GPIO_PORTD(x)      ((x) + OWL_GPIO_PER_BANK * 3)
+#define OWL_GPIO_PORTE(x)      ((x) + OWL_GPIO_PER_BANK * 4)
+
+#define OWL_GPIO_PORT(iogroup, pin_num) ((pin_num) + OWL_GPIO_PER_BANK * (iogroup))
+
+#endif /* __ASM_ARCH_GPIO_H */
+
diff --git a/arch/arm/mach-owl/include/mach/hardware.h b/arch/arm/mach-owl/include/mach/hardware.h
new file mode 100755
index 0000000..fb844de
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/hardware.h
@@ -0,0 +1,134 @@
+/*
+ * arch/arm/mach-gl5202/include/mach/hardware.h
+ *
+ * hardware support
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <linux/types.h>
+#include <mach/regs_map-atm7039.h>
+
+#define OWL_SDRAM_BASE			UL(0x00000000)
+#define OWL_IO_DEVICE_BASE		UL(0xB0000000)
+
+#define OWL_IO_ADDR_BASE		0xF8000000
+
+/* macro to get at IO space when running virtually */
+#ifdef CONFIG_MMU
+/*
+ * Statically mapped addresses:
+ *
+ * b0xx xxxx -> f8xx xxxx
+ * b1xx xxxx -> f9xx xxxx
+ * b2xx xxxx -> faxx xxxx
+ * b3xx xxxx -> fbxx xxxx
+ */
+/*
+#define IO_ADDRESS(x)	(((void __iomem __force *)OWL_IO_ADDR_BASE \
+			+ ((x) & 0x03ffffff))
+*/
+#define IO_ADDRESS(x)	(OWL_IO_ADDR_BASE + ((x) & 0x03ffffff))
+#else
+#define IO_ADDRESS(x)	(x)
+#endif
+
+#define __io_address(n)	 __io(IO_ADDRESS(n))
+
+/*
+ * Peripheral physical addresses
+ */
+#define OWL_PA_REG_BASE	(0xB0000000)
+#define OWL_PA_REG_SIZE	(6 * SZ_1M)
+
+#define OWL_PA_CORESIGHT	(0xB0000000)
+#define OWL_PA_EXTDEBUG	(0xB0008000)
+
+#define OWL_PA_COREPERI	(0xB0020000)
+#define OWL_PA_SCU		(0xB0020000)
+#define OWL_PA_GIC_CPU		(0xB0020100)
+#define OWL_PA_GIC_GP		(0xB0020200)
+#define OWL_PA_TWD		(0xB0020600)
+#define OWL_PA_GIC_DIST	(0xB0021000)
+#define OWL_IO_COREPERI_SIZE   (SZ_8K)
+
+#define OWL_PA_L2CC		(0xB0022000)
+#define OWL_IO_L2CC_SIZE	(SZ_4K)
+
+#define OWL_PA_BOOT_RAM	(0xFFFF8000)
+#define OWL_VA_BOOT_RAM	(0xFFFF8000)
+
+#ifndef __ASSEMBLY__
+/******************************************************************************/
+static inline void act_writeb(u8 val, u32 reg)
+{
+	*(volatile u8 *)(IO_ADDRESS(reg)) = val;
+}
+
+static inline void act_writew(u16 val, u32 reg)
+{
+	*(volatile u16 *)(IO_ADDRESS(reg)) = val;
+}
+
+static inline void act_writel(u32 val, u32 reg)
+{
+	*(volatile u32 *)(IO_ADDRESS(reg)) = val;
+}
+/******************************************************************************/
+static inline u8 act_readb(u32 reg)
+{
+	return *(volatile u8 *)IO_ADDRESS(reg);
+}
+
+static inline u16 act_readw(u32 reg)
+{
+	return *(volatile u16 *)IO_ADDRESS(reg);
+}
+
+static inline u32 act_readl(u32 reg)
+{
+	return *(volatile u32 *)IO_ADDRESS(reg);
+}
+/******************************************************************************/
+static inline void act_setb(u8 val, u32 reg)
+{
+	*(volatile u8 *)IO_ADDRESS(reg) |= val;
+}
+
+static inline void act_setw(u16 val, u32 reg)
+{
+	*(volatile u16 *)IO_ADDRESS(reg) |= val;
+}
+
+static inline void act_setl(u32 val, u32 reg)
+{
+	*(volatile u32 *)IO_ADDRESS(reg) |= val;
+}
+/******************************************************************************/
+static inline void act_clearb(u8 val, u32 reg)
+{
+	*(volatile u8 *)IO_ADDRESS(reg) &= ~val;
+}
+
+static inline void act_clearw(u16 val, u32 reg)
+{
+	*(volatile u16 *)IO_ADDRESS(reg) &= ~val;
+}
+
+static inline void act_clearl(u32 val, u32 reg)
+{
+	*(volatile u32 *)IO_ADDRESS(reg) &= ~val;
+}
+/******************************************************************************/
+#endif
+
+#endif /* __ASM_ARCH_HARDWARE_H */
diff --git a/arch/arm/mach-owl/include/mach/hdmac-owl.h b/arch/arm/mach-owl/include/mach/hdmac-owl.h
new file mode 100755
index 0000000..428b118
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/hdmac-owl.h
@@ -0,0 +1,189 @@
+/*
+ * Header file for the actions AHB DMA Controller driver
+ *
+ * Copyright (C) 2012 actions Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef HDMAC_OWL_H
+#define HDMAC_OWL_H
+
+#include <linux/dmaengine.h>
+
+/**
+ * struct owl_dma_platform_data - Controller configuration parameters
+ * @nr_channels: Number of channels supported by hardware (max 8)
+ * @cap_mask: dma_capability flags supported by the platform
+ */
+struct owl_dma_platform_data {
+	unsigned int	nr_channels;
+	dma_cap_mask_t  cap_mask;
+};
+
+/**
+ * enum owl_dma_slave_width - DMA slave register access width.
+ * @AT_DMA_SLAVE_WIDTH_8BIT: Do 8-bit slave register accesses
+ * @AT_DMA_SLAVE_WIDTH_16BIT: Do 16-bit slave register accesses
+ * @AT_DMA_SLAVE_WIDTH_32BIT: Do 32-bit slave register accesses
+ */
+enum owl_dma_slave_width {
+	ACT_DMA_SLAVE_WIDTH_8BIT = 0,
+	ACT_DMA_SLAVE_WIDTH_16BIT,
+	ACT_DMA_SLAVE_WIDTH_32BIT,
+};
+
+enum owl_trans_type {
+	MEMCPY = 0,
+	SLAVE  = 1,
+	MEMSET = 2,
+	ACP    = 4,
+	CHAINED = 8,
+};
+
+static inline struct dma_async_tx_descriptor *dmaengine_prep_memcpy
+	(struct dma_chan *chan, dma_addr_t dst, dma_addr_t src,
+size_t len, unsigned long flags)
+{
+	return chan->device->device_prep_dma_memcpy(chan, dst, src, len, flags);
+}
+
+static inline int owl_dma_dump_all(struct dma_chan *chan)
+{
+	return chan->device->fsldma_external_start0(chan);
+}
+
+static inline int read_remain_cnt(struct dma_chan *chan)
+{
+	return chan->device->fsldma_external_start1(chan);
+}
+
+static inline int read_remain_frame_cnt(struct dma_chan *chan)
+{
+	return chan->device->fsldma_external_start2(chan);
+}
+
+/**
+ * struct owl_dma_slave - Controller-specific information about a slave
+ * @dma_dev: required DMA master device
+ * @tx_reg: physical address of data register used for
+ *	memory-to-peripheral transfers
+ * @rx_reg: physical address of data register used for
+ *	peripheral-to-memory transfers
+ * @reg_width: peripheral register width
+ * @cfg: Platform-specific initializer for the CFG register
+ * @ctrla: Platform-specific initializer for the CTRLA register
+ */
+struct owl_dma_slave {
+	struct device		*dma_dev;
+	enum owl_trans_type trans_type;
+#ifdef DMA_GL5201
+	u32			cfg;
+	u32			ctrla;
+#else
+	u32			mode;
+	u32			frame_len;
+	u32			frame_cnt;
+	u32			src_stride;
+	u32			dst_stride;
+	u32			acp_attr;
+	u32			chained_ctl;
+	u32			intctl;
+	u32			secure_ctl;
+	u32			nic_qos;
+#endif
+};
+
+enum priority_weight {
+	PRIORITY_ZERO = 0x0,
+	PRIORITY_ONE = (0x1 << 20),
+	PRIORITY_TWO = (0x2 << 20),
+	PRIORITY_THREE = (0x3 << 20),
+	PRIORITY_FOUR = (0x4 << 20),
+	PRIORITY_FIVE = (0x5 << 20),
+	PRIORITY_SIX = (0x6 << 20),
+	PRIORITY_SEVEN = (0x7 << 20),
+};
+
+enum src_srcmode {
+	SRC_CONSTANT = 0x0,
+	SRC_INCR = (0x1 << 16),
+	SRC_STRIDE = (0x2 << 16),
+};
+
+enum dst_dstmode {
+	DST_CONSTANT = 0x0,
+	DST_INCR = (0x1 << 18),
+	DST_STRIDE = (0x2 << 18),
+};
+
+enum dst_type {
+	DST_DEV = 0x0,
+	DST_ACP = (0x1 << 10),
+	DST_DCU = (0x2 << 10),
+	DST_SRAM = (0x3 << 10),
+};
+
+enum src_type {
+	SRC_DEV = 0x0,
+	SRC_ACP = (0x1 << 8),
+	SRC_DCU = (0x2 << 8),
+	SRC_SRAM = (0x3 << 8),
+};
+
+enum trigger_source {
+	DCU = 0x0,
+	SRAM,
+	SD0,
+	SD1,
+	SD2,
+	NANDCMD,
+	NANDDATA,
+	I2S_T,
+	I2S_R,
+	PCM0_T,
+	PCM0_R,
+	PCM1_T,
+	PCM1_R,
+	SPDIF,
+	HDMIAUDIO,
+	SPDIF_HDMI,
+	UART0_T,
+	UART0_R,
+	UART1_T,
+	UART1_R,
+	UART2_T,
+	UART2_R,
+	UART3_T,
+	UART3_R,
+	UART4_T,
+	UART4_R,
+	UART5_T,
+	UART5_R,
+	SPI0_T,
+	SPI0_R,
+	SPI1_T,
+	SPI1_R,
+	SPI2_T,
+	SPI2_R,
+	SPI3_T,
+	SPI3_R,
+	DSI_T,
+	DSI_R,
+	SRAMI,
+	AUDIP,
+	HDCP_T,
+	HDCP_R,
+	UART6_T,
+	UART6_R,
+};
+
+
+#define BUS_WIDTH_8BIT 0x10000000
+#define CRITICAL_BIT 0x800000
+
+
+
+#endif /* HDMAC_OWL_H */
diff --git a/arch/arm/mach-owl/include/mach/irqs.h b/arch/arm/mach-owl/include/mach/irqs.h
new file mode 100755
index 0000000..776bfda
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/irqs.h
@@ -0,0 +1,107 @@
+/*
+ * IRQ definitions
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define IRQ_LOCALTIMER				(29)
+#define IRQ_LOCALWDT				(30)
+
+#define OWL_IRQ_OFFSET				(32)
+#define OWL_IRQ(x)					((x) + OWL_IRQ_OFFSET)
+
+#define OWL_IRQ_ETHERNET			OWL_IRQ(0)
+#define OWL_IRQ_DE					OWL_IRQ(1)
+#define OWL_IRQ_xxx					OWL_IRQ(2)	/* reserved */
+#define OWL_IRQ_GPU_3D				OWL_IRQ(3)
+#define OWL_IRQ_PC0					OWL_IRQ(4)
+#define OWL_IRQ_PC1					OWL_IRQ(5)
+#define OWL_IRQ_PC2					OWL_IRQ(6)
+#define OWL_IRQ_PC3					OWL_IRQ(7)
+#define OWL_IRQ_2HZ0				OWL_IRQ(8)
+#define OWL_IRQ_2HZ1				OWL_IRQ(9)
+#define OWL_IRQ_TIMER0				OWL_IRQ(10)
+#define OWL_IRQ_TIMER1				OWL_IRQ(11)
+#define OWL_IRQ_BISP				OWL_IRQ(12)
+#define OWL_IRQ_SIRQ0				OWL_IRQ(13)
+#define OWL_IRQ_SIRQ1				OWL_IRQ(14)
+#define OWL_IRQ_SIRQ2				OWL_IRQ(15)
+#define OWL_IRQ_KEY					OWL_IRQ(16)
+#define OWL_IRQ_PCM0				OWL_IRQ(17)
+#define OWL_IRQ_PCM1				OWL_IRQ(18)
+#define OWL_IRQ_SPI0				OWL_IRQ(19)
+#define OWL_IRQ_SPI1				OWL_IRQ(20)
+#define OWL_IRQ_SPI2				OWL_IRQ(21)
+#define OWL_IRQ_SPI3				OWL_IRQ(22)
+#define OWL_IRQ_USB3				OWL_IRQ(23)
+#define OWL_IRQ_USBH0				OWL_IRQ(24)
+#define OWL_IRQ_I2C0				OWL_IRQ(25)
+#define OWL_IRQ_I2C1				OWL_IRQ(26)
+#define OWL_IRQ_I2C2				OWL_IRQ(27)
+#define OWL_IRQ_I2C3				OWL_IRQ(28)
+#define OWL_IRQ_UART0				OWL_IRQ(29)
+#define OWL_IRQ_UART1				OWL_IRQ(30)
+#define OWL_IRQ_UART2				OWL_IRQ(31)
+#define OWL_IRQ_UART3				OWL_IRQ(32)
+#define OWL_IRQ_UART4				OWL_IRQ(33)
+#define OWL_IRQ_UART5				OWL_IRQ(34)
+#define OWL_IRQ_UART6				OWL_IRQ(35)
+#define OWL_IRQ_GPIOA				OWL_IRQ(36)
+#define OWL_IRQ_GPIOB				OWL_IRQ(37)
+#define OWL_IRQ_GPIOC				OWL_IRQ(38)
+#define OWL_IRQ_GPIOD				OWL_IRQ(39)
+#define OWL_IRQ_GPIOE				OWL_IRQ(40)
+#define OWL_IRQ_NAND				OWL_IRQ(41)
+#define OWL_IRQ_SD0					OWL_IRQ(42)
+#define OWL_IRQ_SD1					OWL_IRQ(43)
+#define OWL_IRQ_SD2					OWL_IRQ(44)
+#define OWL_IRQ_LCD					OWL_IRQ(45)
+#define OWL_IRQ_HDMI				OWL_IRQ(46)
+#define OWL_IRQ_TVOUT				OWL_IRQ(47)
+#define OWL_IRQ_AUDIO_INOUT			OWL_IRQ(48)
+#define OWL_IRQ_H264_JPEG_ENCODER	OWL_IRQ(49)
+#define OWL_IRQ_HIVDE_DECODER		OWL_IRQ(50)
+#define OWL_IRQ_DSI					OWL_IRQ(51)
+#define OWL_IRQ_CSI					OWL_IRQ(52)
+/* OWL_IRQ(53) */
+#define OWL_IRQ_DCU_DEBUG			OWL_IRQ(54)
+#define OWL_IRQ_L2					OWL_IRQ(55)
+#define OWL_IRQ_HDCP2TX				OWL_IRQ(56)
+#define OWL_IRQ_DMA0				OWL_IRQ(57)
+#define OWL_IRQ_DMA1				OWL_IRQ(58)
+#define OWL_IRQ_DMA2				OWL_IRQ(59)
+#define OWL_IRQ_DMA3				OWL_IRQ(60)
+#define OWL_IRQ_USBH1				OWL_IRQ(61)
+
+#define OWL_IRQ_RESERVE1			OWL_IRQ(62)
+#define OWL_IRQ_RESERVE2			OWL_IRQ(63)
+
+//owl phy irqs num
+#define NR_OWL_PHY_IRQS				(OWL_IRQ(63) + 1)
+
+/*------------------------virtual irq used linear irq map---------------------*/
+/* virtual sirq interrupt num used by sirq interrupt controler */
+#define NR_OWL_SIRQ_IRQS			(3)
+
+/* virtual gpio interrupt num used by gpio interrupt controler */
+#define NR_OWL_GPIO_IRQS			(4 * 32 + 4)
+
+/* virtual atc260x interrupt num used by atc260x interrupt controler */
+#define NR_OWL_ATC260X_IRQS		    16
+
+//owl virtual irqs num
+#define NR_OWL_VIR_IRQS		        (NR_OWL_SIRQ_IRQS + NR_OWL_GPIO_IRQS + NR_OWL_ATC260X_IRQS)
+
+//interrupt table size:
+#define NR_IRQS						(NR_OWL_PHY_IRQS + NR_OWL_VIR_IRQS)
+
+#endif  /* __ASM_ARCH_IRQS_H */
diff --git a/arch/arm/mach-owl/include/mach/isp-owl.h b/arch/arm/mach-owl/include/mach/isp-owl.h
new file mode 100755
index 0000000..b12bc20
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/isp-owl.h
@@ -0,0 +1,226 @@
+
+#ifndef __ISP_OWL_H__
+#define __ISP_OWL_H__
+
+#include <media/soc_camera.h>
+#include <linux/pinctrl/consumer.h>
+struct soc_camera_link;
+
+
+/* for flags */
+/* used by dts, will replace sensor's default value */
+#define SENSOR_FLAG_CHANNEL1  (1 << 0) /* bit-0, 1 channel_1; 0 channel_2  */
+#define SENSOR_FLAG_CHANNEL2  (0 << 0)
+#define SENSOR_FLAG_CH_MASK   (SENSOR_FLAG_CHANNEL1)
+#define SENSOR_FLAG_DVP       (1 << 1) /* bit-1, 1,  parellal interface, DVP; 0 mipi*/
+#define SENSOR_FLAG_MIPI      (0 << 1)
+#define SENSOR_FLAG_INTF_MASK (SENSOR_FLAG_DVP)
+#define SENSOR_FLAG_YUV       (1 << 2) /* bit-2, 1, output yuv data; 0 raw data */
+#define SENSOR_FLAG_RAW       (0 << 2)
+#define SENSOR_FLAG_DATA_MASK (SENSOR_FLAG_YUV)
+#define SENSOR_FLAG_DTS_MASK  \
+    (SENSOR_FLAG_CH_MASK | SENSOR_FLAG_INTF_MASK | SENSOR_FLAG_DATA_MASK)
+
+/* determined by sensor driver, not dts */
+#define SENSOR_FLAG_8BIT      (1 << 8)
+#define SENSOR_FLAG_10BIT     (1 << 9)
+#define SENSOR_FLAG_12BIT     (1 << 10)
+
+
+#define OUTTO_SENSO_CLOCK 24000000
+
+#define ISP_CHANNEL_0 0
+#define ISP_CHANNEL_1 1
+
+#define SENSOR_DATA_TYPE_YUV 0
+#define SENSOR_DATA_TYPE_RAW 1
+
+
+#define OWL_ISP_HOST0  0
+#define OWL_ISP_HOST1  1
+
+/* ANSI Color codes */
+#define VT(CODES)  "\033[" CODES "m"
+#define VT_NORMAL  VT("")
+#define VT_RED     VT("0;32;31")
+#define VT_GREEN   VT("1;32")
+#define VT_YELLOW  VT("1;33")
+#define VT_BLUE    VT("1;34")
+#define VT_PURPLE  VT("0;35")
+
+#define xprintk(fmt, ...) \
+    printk("%s()->%d " fmt, __func__, __LINE__, ## __VA_ARGS__)
+
+#define _DBG(color, fmt, ...)  \
+    xprintk(color "" fmt VT_NORMAL, ## __VA_ARGS__)
+
+#define _INFO(color, fmt, ...) \
+    xprintk(color "::" fmt ""VT_NORMAL, ## __VA_ARGS__)
+
+/* mainly used in test code */
+#define INFO_PURLPLE(fmt, args...) _INFO(VT_PURPLE, fmt, ## args)
+#define INFO_RED(fmt, args...)     _INFO(VT_RED, fmt, ## args)
+#define INFO_GREEN(fmt, args...)   _INFO(VT_GREEN, fmt, ## args)
+#define INFO_BLUE(fmt, args...)    _INFO(VT_BLUE, fmt, ## args)
+
+#define QQVGA_WIDTH  160
+#define QQVGA_HEIGHT 120
+
+#define QVGA_WIDTH  320
+#define QVGA_HEIGHT 240
+
+#define CIF_WIDTH   352
+#define CIF_HEIGHT  288
+
+#define VGA_WIDTH   640
+#define VGA_HEIGHT  480
+
+#define SVGA_WIDTH	800
+#define SVGA_HEIGHT	600
+
+#define XGA_WIDTH	1024
+#define XGA_HEIGHT	768
+
+#define WXGA_WIDTH	1280
+#define WXGA_HEIGHT	720
+
+#define V720P_WIDTH (WXGA_WIDTH)
+#define V720P_HEIGHT (WXGA_HEIGHT)
+
+#define SXGA_WIDTH	1280
+#define SXGA_HEIGHT	960
+
+#define V1080P_WIDTH 1920
+#define V1080P_HEIGHT 1080
+
+#define UXGA_WIDTH	1600
+#define UXGA_HEIGHT	1200
+
+#define QXGA_WIDTH	2048
+#define QXGA_HEIGHT	1536
+
+#define QSXGA_WIDTH	    2592
+#define QSXGA_HEIGHT	1944
+
+
+struct v4l2_ctl_cmd_info {
+    unsigned int  id;
+    int min;
+    int max;
+    unsigned int step;
+    int def;
+};
+
+struct v4l2_ctl_cmd_info_menu {
+    unsigned int  id;
+    int max;
+    int mask;
+    int def;
+};
+
+/* 
+  * for Edge ctrl 
+  * 
+  * strength also control Auto or Manual Edge Control Mode 
+  * see also OV2643_MANUAL_EDGE_CTRL 
+  */
+struct module_edge_ctrl {	
+	unsigned char strength;	
+	unsigned char threshold;	
+	unsigned char upper;	
+	unsigned char lower;
+};
+
+/* 
+  * module info 
+  */
+struct module_info 
+{	
+	unsigned long		flags;	
+	struct module_edge_ctrl	edgectrl;	
+	unsigned int video_devnum;
+};
+
+
+struct dts_gpio {
+    int num;
+    int active_level;  /* 1: high level active, 0:low level active */
+};
+
+struct dts_regulator {
+    struct regulator *regul;
+    unsigned int min; /* uV */
+    unsigned int max;
+};
+
+struct isp_regulators {
+    int avdd_use_gpio;  /* 0: regul, 1: use gpio */
+    union {
+        struct dts_gpio gpio;
+        struct dts_regulator regul;
+    } avdd;
+
+    int dvdd_use_gpio;  /* 0: regul, 1: use gpio */
+    struct dts_gpio dvdd_gpio;
+    struct dts_regulator dvdd;
+};
+
+struct sensor_pwd_info {
+    int flag;  /* sensor supports: front only, rear only, or dual */
+    struct dts_gpio gpio_rear;
+    struct dts_gpio gpio_front;
+    struct dts_gpio gpio_reset;
+    struct clk *ch_clk[2];
+};
+
+struct dts_sensor_config {
+    int rear; /* 1: rear sensor, 0: front sensor */
+    int channel; /* 0: channel-1, 1: channel-2 */
+    int data_type; /* 0: output YUV data, 1: RAW data */
+    int host; /* bus_id of soc_camera_link */
+    int i2c_adapter;
+    enum v4l2_mbus_type bus_type; /* dvp or mipi */
+    struct device *dev; /* sensor's platform device */
+    struct device_node *dn;
+    struct pinctrl *mfp;
+};
+
+#define DECLARE_DTS_SENSOR_CFG(name) \
+    static struct dts_sensor_config name = { \
+        .rear = 1, .host = 0, .i2c_adapter = 1, \
+    }
+
+/**
+ * set current sensor mode, preview(or video) and capture
+ */
+enum {
+    ACTS_ISP_PREVIEW_MODE = 0,
+    ACTS_ISP_CAPTURE_MODE,
+    ACTS_ISP_VIDEO_MODE,
+};
+
+/**
+ * using sensor as a front/rear camera
+ */
+enum {
+    ACTS_CAM_SENSOR_FRONT = 0,
+    ACTS_CAM_SENSOR_REAR,
+};
+
+
+#define V4L2_CID_CAM_CV_MODE _IOW('v', BASE_VIDIOC_PRIVATE + 0, int)
+
+
+void attach_sensor_pwd_info(struct device *dev, 
+    struct sensor_pwd_info *pi, int host_id);
+void detach_sensor_pwd_info(struct device *dev, 
+    struct sensor_pwd_info *pi, int host_id);
+void owl_isp_reset(struct device *dev, int host_id);
+int owl_isp_power_on(int channel, int rear, int host_id);
+int owl_isp_power_off(int channel, int rear, int host_id);
+int parse_config_info(struct soc_camera_link *link,
+    struct dts_sensor_config *dsc, const char *name);
+
+extern int owl_isp_reset_pin_state;
+#endif  //__ISP_OWL_H__
+
diff --git a/arch/arm/mach-owl/include/mach/iversion.h b/arch/arm/mach-owl/include/mach/iversion.h
new file mode 100755
index 0000000..5e801fc
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/iversion.h
@@ -0,0 +1,29 @@
+/*
+ * arch/arm/mach-leopard/include/mach/iversion.h
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_IVERSION_H
+#define __ASM_ARCH_IVERSION_H
+
+enum {
+	MNO_1 = 1,
+	MNO_2,
+	MNO_3,
+	MNO_4,
+	MNO_5,
+	MNO_6,
+	MNO_MAX,
+};
+
+#extern unsigned char icversion_get(void);
+#extern unsigned int mno_get(void);
+
+#endif /* __ASM_ARCH_IVERSION_H */
diff --git a/arch/arm/mach-owl/include/mach/kinfo.h b/arch/arm/mach-owl/include/mach/kinfo.h
new file mode 100755
index 0000000..04eb6f7
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/kinfo.h
@@ -0,0 +1,54 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Actions Semi Inc.
+*/
+/******************************************************************************/
+
+/******************************************************************************/
+#ifndef __OWL_CPU_PWM_VOLT_H__
+#define __OWL_CPU_PWM_VOLT_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/********gamma info********************/
+#define OWL_DSS_GAMMA_SIZE	(256 * 3)
+
+struct owl_gamma_info {
+	u32 gamma_table[OWL_DSS_GAMMA_SIZE / 4];
+	int is_valid;
+};
+/****************************/
+
+/*********cpu pwm volt table**********************/
+#define CPU_PWM_VOLT_TABLE_LEN 16
+
+struct cpu_pwm_volt_table {
+	unsigned int pwm_val;
+	unsigned int voltage_mv;
+};
+
+struct cpu_pwm_volt_info {
+	struct cpu_pwm_volt_table cpu_pwm_volt_tb[CPU_PWM_VOLT_TABLE_LEN];
+	int cpu_pwm_volt_tb_len;
+};
+/******************************/
+
+struct kernel_reserve_info {
+	struct owl_gamma_info gamma;
+	struct cpu_pwm_volt_info cpu_pwm_volt;
+} __attribute__ ((packed));
+
+extern struct kernel_reserve_info *kinfo;
+
+/******************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/module-owl.h b/arch/arm/mach-owl/include/mach/module-owl.h
new file mode 100755
index 0000000..5671d26
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/module-owl.h
@@ -0,0 +1,207 @@
+#ifndef CMU_MODULE_ID_H
+#define CMU_MODULE_ID_H
+
+enum mod_id {
+	MOD_ID_ROOT,
+	MOD_ID_GPU3D,
+	MOD_ID_SHARESRAM,
+	MOD_ID_HDCP2X,
+	MOD_ID_VCE,
+	MOD_ID_VDE,
+	MOD_ID_PCM0,
+	MOD_ID_SPDIF,
+	MOD_ID_HDMIA,
+	MOD_ID_I2SRX,
+	MOD_ID_I2STX,
+	MOD_ID_GPIO,
+	MOD_ID_KEY,
+	MOD_ID_LENS,
+	MOD_ID_BISP,
+	MOD_ID_CSI,
+	MOD_ID_DSI,
+	MOD_ID_LVDS,
+	MOD_ID_LCD1,
+	MOD_ID_LCD0,
+	MOD_ID_DE,
+	MOD_ID_SD2,
+	MOD_ID_SD1,
+	MOD_ID_SD0,
+	MOD_ID_NANDC,
+	MOD_ID_DDRCH0,
+	MOD_ID_NOR,
+	MOD_ID_DMAC,
+	MOD_ID_DDRCH1,
+	MOD_ID_I2C3,
+	MOD_ID_I2C2,
+	MOD_ID_TIMER,
+	MOD_ID_PWM5,
+	MOD_ID_PWM4,
+	MOD_ID_PWM3,
+	MOD_ID_PWM2,
+	MOD_ID_PWM1,
+	MOD_ID_PWM0,
+	MOD_ID_ETHERNET,
+	MOD_ID_UART5,
+	MOD_ID_UART4,
+	MOD_ID_UART3,
+	MOD_ID_UART6,
+	MOD_ID_PCM1,
+	MOD_ID_I2C1,
+	MOD_ID_I2C0,
+	MOD_ID_SPI3,
+	MOD_ID_SPI2,
+	MOD_ID_SPI1,
+	MOD_ID_SPI0,
+	MOD_ID_IRC,
+	MOD_ID_UART2,
+	MOD_ID_UART1,
+	MOD_ID_UART0,
+	MOD_ID_HDMI,
+	MOD_ID_SS,
+	MOD_ID_TV24M,
+	MOD_ID_CVBS_CLK108M,
+	MOD_ID_TVOUT,
+	MOD_ID_MAX_IN_CLK,
+
+	MOD_ID_PERIPHRESET = MOD_ID_MAX_IN_CLK,
+	MOD_ID_NIC301,
+	MOD_ID_AUDIO,
+	MOD_ID_LCD,
+	MOD_ID_DDR,
+	MOD_ID_NORIF,
+	MOD_ID_DBG3RESET,
+	MOD_ID_DBG2RESET,
+	MOD_ID_DBG1RESET,
+	MOD_ID_DBG0RESET,
+	MOD_ID_WD3RESET,
+	MOD_ID_WD2RESET,
+	MOD_ID_WD1RESET,
+	MOD_ID_WD0RESET,
+	MOD_ID_CHIPID,
+	MOD_ID_USB3,
+	MOD_ID_HDCP2Tx,
+	MOD_ID_USB2_0,
+	MOD_ID_USB2_1,
+	MOD_ID_MAX
+};
+
+#define MODULE_CLK_GPU3D         MOD_ID_GPU3D
+#define MODULE_CLK_SHARESRAM     MOD_ID_SHARESRAM
+#define MODULE_CLK_HDCP2X        MOD_ID_HDCP2X
+#define MODULE_CLK_VCE           MOD_ID_VCE
+#define MODULE_CLK_VDE           MOD_ID_VDE
+#define MODULE_CLK_PCM0          MOD_ID_PCM0
+#define MODULE_CLK_SPDIF         MOD_ID_SPDIF
+#define MODULE_CLK_HDMIA         MOD_ID_HDMIA
+#define MODULE_CLK_I2SRX         MOD_ID_I2SRX
+#define MODULE_CLK_I2STX         MOD_ID_I2STX
+#define MODULE_CLK_GPIO          MOD_ID_GPIO
+#define MODULE_CLK_KEY           MOD_ID_KEY
+#define MODULE_CLK_LENS          MOD_ID_LENS
+#define MODULE_CLK_BISP          MOD_ID_BISP
+#define MODULE_CLK_CSI           MOD_ID_CSI
+#define MODULE_CLK_DSI           MOD_ID_DSI
+#define MODULE_CLK_LVDS          MOD_ID_LVDS
+#define MODULE_CLK_LCD1          MOD_ID_LCD1
+#define MODULE_CLK_LCD0          MOD_ID_LCD0
+#define MODULE_CLK_DE            MOD_ID_DE
+#define MODULE_CLK_SD2           MOD_ID_SD2
+#define MODULE_CLK_SD1           MOD_ID_SD1
+#define MODULE_CLK_SD0           MOD_ID_SD0
+#define MODULE_CLK_NANDC         MOD_ID_NANDC
+#define MODULE_CLK_DDRCH0        MOD_ID_DDRCH0
+#define MODULE_CLK_NOR           MOD_ID_NOR
+#define MODULE_CLK_DMAC          MOD_ID_DMAC
+#define MODULE_CLK_DDRCH1        MOD_ID_DDRCH1
+#define MODULE_CLK_I2C3          MOD_ID_I2C3
+#define MODULE_CLK_I2C2          MOD_ID_I2C2
+#define MODULE_CLK_TIMER         MOD_ID_TIMER
+#define MODULE_CLK_PWM5          MOD_ID_PWM5
+#define MODULE_CLK_PWM4          MOD_ID_PWM4
+#define MODULE_CLK_PWM3          MOD_ID_PWM3
+#define MODULE_CLK_PWM2          MOD_ID_PWM2
+#define MODULE_CLK_PWM1          MOD_ID_PWM1
+#define MODULE_CLK_PWM0          MOD_ID_PWM0
+#define MODULE_CLK_ETHERNET      MOD_ID_ETHERNET
+#define MODULE_CLK_UART5         MOD_ID_UART5
+#define MODULE_CLK_UART4         MOD_ID_UART4
+#define MODULE_CLK_UART3         MOD_ID_UART3
+#define MODULE_CLK_UART6         MOD_ID_UART6
+#define MODULE_CLK_PCM1          MOD_ID_PCM1
+#define MODULE_CLK_I2C1          MOD_ID_I2C1
+#define MODULE_CLK_I2C0          MOD_ID_I2C0
+#define MODULE_CLK_SPI3          MOD_ID_SPI3
+#define MODULE_CLK_SPI2          MOD_ID_SPI2
+#define MODULE_CLK_SPI1          MOD_ID_SPI1
+#define MODULE_CLK_SPI0          MOD_ID_SPI0
+#define MODULE_CLK_IRC           MOD_ID_IRC
+#define MODULE_CLK_UART2         MOD_ID_UART2
+#define MODULE_CLK_UART1         MOD_ID_UART1
+#define MODULE_CLK_UART0         MOD_ID_UART0
+#define MODULE_CLK_HDMI          MOD_ID_HDMI
+#define MODULE_CLK_SS            MOD_ID_SS
+#define MODULE_CLK_TV24M         MOD_ID_TV24M
+#define MODULE_CLK_TVOUT         MOD_ID_TVOUT
+#define MODULE_CLK_CVBS_CLK108M  MOD_ID_CVBS_CLK108M
+
+#define MODULE_RST_PERIPHRESET   MOD_ID_PERIPHRESET
+#define MODULE_RST_LENS          MOD_ID_LENS
+#define MODULE_RST_NIC301        MOD_ID_NIC301
+#define MODULE_RST_GPU3D         MOD_ID_GPU3D
+#define MODULE_RST_VCE           MOD_ID_VCE
+#define MODULE_RST_VDE           MOD_ID_VDE
+#define MODULE_RST_PCM0          MOD_ID_PCM0
+#define MODULE_RST_AUDIO         MOD_ID_AUDIO
+#define MODULE_RST_GPIO          MOD_ID_GPIO
+#define MODULE_RST_KEY           MOD_ID_KEY
+#define MODULE_RST_BISP          MOD_ID_BISP
+#define MODULE_RST_CSI           MOD_ID_CSI
+#define MODULE_RST_DSI           MOD_ID_DSI
+#define MODULE_RST_SD2           MOD_ID_SD2
+#define MODULE_RST_LCD           MOD_ID_LCD
+#define MODULE_RST_DE            MOD_ID_DE
+#define MODULE_RST_PCM11         MOD_ID_PCM11
+#define MODULE_RST_SD1           MOD_ID_SD1
+#define MODULE_RST_SD0           MOD_ID_SD0
+#define MODULE_RST_NANDC         MOD_ID_NANDC
+#define MODULE_RST_DDR           MOD_ID_DDR
+#define MODULE_RST_NORIF         MOD_ID_NORIF
+#define MODULE_RST_DMAC          MOD_ID_DMAC
+#define MODULE_RST_DBG3RESET     MOD_ID_DBG3RESET
+#define MODULE_RST_DBG2RESET     MOD_ID_DBG2RESET
+#define MODULE_RST_DBG1RESET     MOD_ID_DBG1RESET
+#define MODULE_RST_DBG0RESET     MOD_ID_DBG0RESET
+#define MODULE_RST_WD3RESET      MOD_ID_WD3RESET
+#define MODULE_RST_WD2RESET      MOD_ID_WD2RESET
+#define MODULE_RST_WD1RESET      MOD_ID_WD1RESET
+#define MODULE_RST_WD0RESET      MOD_ID_WD0RESET
+#define MODULE_RST_CHIPID        MOD_ID_CHIPID
+#define MODULE_RST_ETHERNET      MOD_ID_ETHERNET
+#define MODULE_RST_I2C3          MOD_ID_I2C3
+#define MODULE_RST_I2C2          MOD_ID_I2C2
+#define MODULE_RST_UART5         MOD_ID_UART5
+#define MODULE_RST_UART4         MOD_ID_UART4
+#define MODULE_RST_UART3         MOD_ID_UART3
+#define MODULE_RST_USB3          MOD_ID_USB3
+#define MODULE_RST_I2C1          MOD_ID_I2C1
+#define MODULE_RST_I2C0          MOD_ID_I2C0
+#define MODULE_RST_SPI3          MOD_ID_SPI3
+#define MODULE_RST_SPI2          MOD_ID_SPI2
+#define MODULE_RST_SPI1          MOD_ID_SPI1
+#define MODULE_RST_SPI0          MOD_ID_SPI0
+#define MODULE_RST_UART2         MOD_ID_UART2
+#define MODULE_RST_UART1         MOD_ID_UART1
+#define MODULE_RST_UART0         MOD_ID_UART0
+#define MODULE_RST_UART6         MOD_ID_UART6
+#define MODULE_RST_HDCP2Tx       MOD_ID_HDCP2Tx
+#define MODULE_RST_HDMI          MOD_ID_HDMI
+#define MODULE_RST_TVOUT         MOD_ID_TVOUT
+#define MODULE_RST_USB2          MOD_ID_USB2
+
+int module_clk_enable(int mod_id);
+int module_clk_disable(int mod_id);
+int module_reset(int mod_id);
+int owl_module_reset_assert(int mod_id);
+int owl_module_reset_deassert(int mod_id);
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/power.h b/arch/arm/mach-owl/include/mach/power.h
new file mode 100755
index 0000000..8b8385c
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/power.h
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2013 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef ASMARM_ARCH_POWER_H
+#define ASMARM_ARCH_POWER_H
+
+/* image of the saved processor state */
+struct saved_context {
+	/*
+	 * Structure saved_context would be used to hold processor state
+	 * except caller and callee registers, just before suspending.
+	 */
+
+	/* coprocessor 15 registers */
+	/* u32 ID_code; */     /* read only reg */
+	/* u32 cache_type; */  /* read only reg */
+	/* u32 TCM_stat;  */  /* read only reg */
+	u32 CR;
+	u32 AUXCR;
+	u32 DACR;
+	u32 D_FSR;
+	u32 I_FSR;
+	u32 D_FAR;
+	u32 I_FAR;
+	/* u32 COR; */   /*write only reg */
+	/* u32 TLBOR; */  /*write only reg */
+	u32 D_CLR;
+	u32 I_CLR;
+	u32 D_TCMRR;
+	u32 I_TCMRR;
+	u32 D_TLBLR;
+	u32 FCSE;
+	u32 CID;
+	u32 CSSR;
+	u32 CACR;
+	u32 TTB_0R;
+	u32 TTB_1R;
+	u32 TTBCR;
+	u32 D_AFSR;
+	u32 I_AFSR;
+	u32 PAR;
+	u32 PMControlR;
+	u32 CESR;
+	u32 CECR;
+	u32 OFSR;
+	u32 SIR;
+	u32 PCSR;
+	u32 CCR;
+	u32 ESR;
+	u32 PMCountR;
+	u32 UER;
+	u32 IESR;
+	u32 IECR;
+	u32 L2CLR;
+	u32 I_TLBLR;
+	u32 PRRR;
+	u32 NRRR;
+	u32 PLEUAR;
+	u32 PLECNR;
+	u32 PLECR;
+	u32 PLEISAR;
+	u32 PLEIEAR;
+	u32 PLECIDR;
+	u32 SNSVBAR;
+	u32 URWTPID;
+	u32 UROTPID;
+	u32 POTPID;
+} __packed;
+
+typedef u32 (read_block_fn)(u32 lba, u32 len, void *buffer);
+typedef u32 (write_block_fn)(u32 lba, u32 len, void *buffer);
+
+extern void cpu_resume(void);
+extern int cpu_suspend(unsigned long, int (*)(unsigned long));
+extern void owl_pm_do_save(void);
+extern void owl_pm_do_restore(void);
+
+extern void register_swap_rw_handler(read_block_fn *read,
+				write_block_fn *write);
+
+extern unsigned long saved_cr, saved_ttb, idmap;
+extern pgd_t *idmap_pgd;
+extern void cpu_v7_reset(unsigned long addr);
+
+extern void owl_finish_suspend(unsigned long cpu_state);
+extern void owl_cpu_resume(void);
+
+extern void fs_drop_page_caches(void);
+extern int cpu_package(void);
+extern int owl_pm_wakeup_flag(void);
+extern int set_judge_adapter_type_handle(void* handle);
+
+/* for PMIC operations ------------------------------------------------------ */
+
+/* wakeup sources */
+#define OWL_PMIC_WAKEUP_SRC_IR                  (1 << 0)
+#define OWL_PMIC_WAKEUP_SRC_RESET               (1 << 1)
+#define OWL_PMIC_WAKEUP_SRC_HDSW                (1 << 2)
+#define OWL_PMIC_WAKEUP_SRC_ALARM               (1 << 3)
+#define OWL_PMIC_WAKEUP_SRC_REMCON              (1 << 4)
+#define OWL_PMIC_WAKEUP_SRC_TP                  (1 << 5)  /* 2603a */
+#define OWL_PMIC_WAKEUP_SRC_WKIRQ               (1 << 6)  /* 2603a */
+#define OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT         (1 << 7)
+#define OWL_PMIC_WAKEUP_SRC_ONOFF_LONG          (1 << 8)
+#define OWL_PMIC_WAKEUP_SRC_WALL_IN             (1 << 9)
+#define OWL_PMIC_WAKEUP_SRC_VBUS_IN             (1 << 10)
+#define OWL_PMIC_WAKEUP_SRC_RESTART             (1 << 11)  /* 2603c */
+#define OWL_PMIC_WAKEUP_SRC_SGPIOIRQ            (1 << 12)  /* 2603c */
+#define OWL_PMIC_WAKEUP_SRC_WALL_OUT            (1 << 13)  /* 2603c */
+#define OWL_PMIC_WAKEUP_SRC_VBUS_OUT            (1 << 14)  /* 2603c */
+#define OWL_PMIC_WAKEUP_SRC_CNT                 (15)
+#define OWL_PMIC_WAKEUP_SRC_ALL                 ((1U<<OWL_PMIC_WAKEUP_SRC_CNT)-1U)
+
+/* reboot target */
+#define OWL_PMIC_REBOOT_TGT_NORMAL              (0) /* with charger_check etc. */
+#define OWL_PMIC_REBOOT_TGT_SYS                 (1) /* no charger ... */
+#define OWL_PMIC_REBOOT_TGT_ADFU                (2)
+#define OWL_PMIC_REBOOT_TGT_RECOVERY            (3)
+#define OWL_PMIC_REBOOT_TGT_BOOTLOADER          (4)
+#define OWL_PMIC_REBOOT_TGT_FASTBOOT	        (5)
+
+
+
+struct owl_pmic_pm_ops {
+	int (*set_wakeup_src)(uint wakeup_mask, uint wakeup_src);
+	int (*get_wakeup_src)(void);
+	int (*get_wakeup_flag)(void);       /* wakeup reason flag */
+
+	int (*shutdown_prepare)(void);
+	int (*powerdown)(uint deep_pwrdn, uint for_upgrade);
+	int (*reboot)(uint tgt);
+
+	int (*suspend_prepare)(void);
+	int (*suspend_enter)(void);
+	int (*suspend_wake)(void);
+	int (*suspend_finish)(void);
+
+	int (*get_bus_info)(uint *bus_num, uint *addr, uint *ic_type);
+};
+
+/* for atc260x_pm */
+extern void owl_pmic_set_pm_ops(struct owl_pmic_pm_ops *ops);
+
+/* other drivers (IR/TP/REMCON/SGPIO...) can use this API to setup their own wakeup source */
+extern int owl_pmic_setup_aux_wakeup_src(uint wakeup_src, uint on);
+
+#endif /* ASMARM_ARCH_POWER_H */
diff --git a/arch/arm/mach-owl/include/mach/powergate.h b/arch/arm/mach-owl/include/mach/powergate.h
new file mode 100755
index 0000000..c443218
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/powergate.h
@@ -0,0 +1,38 @@
+/*
+ * powergate definitions
+ *
+ * Copyright 2013 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_POWERGATE_H
+#define __ASM_ARCH_POWERGATE_H
+
+enum owl_powergate_id {
+	OWL_POWERGATE_CPU2 = 0,
+	OWL_POWERGATE_CPU3,
+	OWL_POWERGATE_GPU3D,
+	OWL_POWERGATE_VCE_BISP,
+	OWL_POWERGATE_VDE,
+	/*atm7059 avaliabe only*/
+	OWL_POWERGATE_USB2_0,
+	OWL_POWERGATE_USB2_1,
+	OWL_POWERGATE_USB3,
+	OWL_POWERGATE_DS,
+	OWL_POWERGATE_DMA,
+	OWL_POWERGATE_MAXID,
+};
+
+int  __init owl_powergate_init(void);
+
+int owl_cpu_powergate_id(int cpuid);
+int owl_powergate_is_powered(enum owl_powergate_id id);
+int owl_powergate_power_on(enum owl_powergate_id id);
+int owl_powergate_power_off(enum owl_powergate_id id);
+
+#endif /* __ASM_ARCH_POWERGATE_H */
diff --git a/arch/arm/mach-owl/include/mach/pwm-owl.h b/arch/arm/mach-owl/include/mach/pwm-owl.h
new file mode 100755
index 0000000..cd403cd
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/pwm-owl.h
@@ -0,0 +1,14 @@
+#ifndef __PWM_OWL_H__
+#define __PWM_OWL_H__
+
+/*=================================================================*/
+/* rgb lcd stuff */
+#include <linux/delay.h>
+#include <linux/pwm.h>
+
+#include <mach/hardware.h>
+
+enum pwm_polarity owl_pwm_get_polarity(struct pwm_device *pwm);
+
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/regs_map-atm7039.h b/arch/arm/mach-owl/include/mach/regs_map-atm7039.h
new file mode 100755
index 0000000..36e1365
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/regs_map-atm7039.h
@@ -0,0 +1,2170 @@
+/*
+* Automatically generated register definition: don't edit
+* ATM7039 Spec Version_V1.10
+* Sat 11-19-2012  10:32:23
+*/
+#ifndef __REGS_MAP_ATM7039_H__
+#define __REGS_MAP_ATM7039_H__
+
+
+//--------------SPS_PG--------------------------------------------//
+//--------------Register Address----------------------------------//
+#define SPS_PG_BASE                                 0xB01B0100
+#define SPS_PG_CTL                                  (SPS_PG_BASE+0x0000)
+#define SPS_RST_CTL                                 (SPS_PG_BASE+0x0004)
+#define SPS_LDO_CTL                                 (SPS_PG_BASE+0x0008)
+#define SPS_BDG_CTL                                 (SPS_PG_BASE+0x000c)
+#define SPS_TEMP_CTL                                (SPS_PG_BASE+0x0010)
+#define SPS_PG_CTL1									(SPS_PG_BASE+0x0014)
+#define SPS_PWR_AWK_MSK								(SPS_PG_BASE+0x0020)
+#define SPS_PWR_AWK_SRC								(SPS_PG_BASE+0x0024)
+#define SPS_PWR_CTL									(SPS_PG_BASE+0x0028)
+#define SPS_PWR_ISO_TIMER0							(SPS_PG_BASE+0x002C)
+#define SPS_PWR_ADDR								(SPS_PG_BASE+0x0030)
+#define SPS_PWR_ISO_TIMER1							(SPS_PG_BASE+0x0034)
+
+//--------------Bits Location-------------------------------------//
+//--------------CMU--------------------------------------//
+//--------------Register Address----------------------------------//
+#define CMU_BASE                                    0xB0160000
+#define CMU_COREPLL                                 (CMU_BASE+0x0000)
+#define CMU_DEVPLL                                  (CMU_BASE+0x0004)
+#define CMU_DDRPLL                                  (CMU_BASE+0x0008)
+#define CMU_NANDPLL                                 (CMU_BASE+0x000C)
+#define CMU_DISPLAYPLL                              (CMU_BASE+0x0010)
+#define CMU_AUDIOPLL                                (CMU_BASE+0x0014)
+#define CMU_TVOUTPLL                                (CMU_BASE+0x0018)
+#define CMU_BUSCLK                                  (CMU_BASE+0x001C)
+#define CMU_SENSORCLK                               (CMU_BASE+0x0020)
+#define CMU_LCDCLK                                  (CMU_BASE+0x0024)
+#define CMU_DSICLK                                  (CMU_BASE+0x0028)
+#define CMU_CSICLK                                  (CMU_BASE+0x002C)
+#define CMU_DECLK                                   (CMU_BASE+0x0030)
+#define CMU_BISPCLK                                 (CMU_BASE+0x0034)
+#define CMU_BUSCLK1                                 (CMU_BASE+0x0038)
+#define CMU_VDECLK                                  (CMU_BASE+0x0040)
+#define CMU_VCECLK                                  (CMU_BASE+0x0044)
+#define CMU_NANDCCLK                                (CMU_BASE+0x004C)
+#define CMU_SD0CLK                                  (CMU_BASE+0x0050)
+#define CMU_SD1CLK                                  (CMU_BASE+0x0054)
+#define CMU_SD2CLK                                  (CMU_BASE+0x0058)
+#define CMU_UART0CLK                                (CMU_BASE+0x005C)
+#define CMU_UART1CLK                                (CMU_BASE+0x0060)
+#define CMU_UART2CLK                                (CMU_BASE+0x0064)
+#define CMU_PWM4CLK                                 (CMU_BASE+0x0068)
+#define CMU_PWM5CLK                                 (CMU_BASE+0x006C)
+#define CMU_PWM0CLK                                 (CMU_BASE+0x0070)
+#define CMU_PWM1CLK                                 (CMU_BASE+0x0074)
+#define CMU_PWM2CLK                                 (CMU_BASE+0x0078)
+#define CMU_PWM3CLK                                 (CMU_BASE+0x007C)
+#define CMU_USBPLL                                  (CMU_BASE+0x0080)
+#define CMU_ETHERNETPLL                             (CMU_BASE+0x0084)
+#define CMU_CVBSPLL                             	(CMU_BASE+0x0088)
+#define CMU_LENSCLK                                 (CMU_BASE+0x008C)
+#define CMU_GPU3DCLK                                (CMU_BASE+0x0090)
+#define CMU_CORECTL                                 (CMU_BASE+0x009C)
+#define CMU_DEVCLKEN0                               (CMU_BASE+0x00A0)
+#define CMU_DEVCLKEN1                               (CMU_BASE+0x00A4)
+#define CMU_DEVRST0                                 (CMU_BASE+0x00A8)
+#define CMU_DEVRST1                                 (CMU_BASE+0x00AC)
+#define CMU_UART3CLK                                (CMU_BASE+0x00B0)
+#define CMU_UART4CLK                                (CMU_BASE+0x00B4)
+#define CMU_UART5CLK                                (CMU_BASE+0x00B8)
+#define CMU_UART6CLK                                (CMU_BASE+0x00BC)
+#define CMU_SSCLK                                   (CMU_BASE+0x00C0)
+#define CMU_DIGITALDEBUG                            (CMU_BASE+0x00D0)
+#define CMU_ANALOGDEBUG                             (CMU_BASE+0x00D4)
+#define CMU_COREPLLDEBUG                            (CMU_BASE+0x00D8)
+#define CMU_DEVPLLDEBUG                             (CMU_BASE+0x00DC)
+#define CMU_DDRPLLDEBUG                             (CMU_BASE+0x00E0)
+#define CMU_NANDPLLDEBUG                            (CMU_BASE+0x00E4)
+#define CMU_DISPLAYPLLDEBUG                         (CMU_BASE+0x00E8)
+#define CMU_TVOUTPLLDEBUG                           (CMU_BASE+0x00EC)
+#define CMU_DEEPCOLORPLLDEBUG                       (CMU_BASE+0x00F4)
+#define CMU_AUDIOPLL_ETHPLLDEBUG                    (CMU_BASE+0x00F8)
+#define CMU_CVBSPLLDEBUG                    		(CMU_BASE+0x00FC)
+
+
+//--------------Bits Location-------------------------------------//
+//--------------Timer_2HZ--------------------------------------//
+//--------------Register Address----------------------------------//
+#define TIMER_2HZ_BASE                              0xB0168000
+#define TWOHZ0_CTL                                  (TIMER_2HZ_BASE+0x0000)
+#define T0_CTL                                      (TIMER_2HZ_BASE+0x0008)
+#define T0_CMP                                      (TIMER_2HZ_BASE+0x000C)
+#define T0_VAL                                      (TIMER_2HZ_BASE+0x0010)
+#define T1_CTL                                      (TIMER_2HZ_BASE+0x0014)
+#define T1_CMP                                      (TIMER_2HZ_BASE+0x0018)
+#define T1_VAL                                      (TIMER_2HZ_BASE+0x001C)
+#define TWOHZ1_CTL                                  (TIMER_2HZ_BASE+0x0020)
+#define CPU1_ADDR                                   (TIMER_2HZ_BASE+0x0050)
+#define CPU2_ADDR                                   (TIMER_2HZ_BASE+0x0054)
+#define CPU3_ADDR                                   (TIMER_2HZ_BASE+0x0058)
+#define CPU1_FLAG                                   (TIMER_2HZ_BASE+0x005C)
+#define CPU2_FLAG                                   (TIMER_2HZ_BASE+0x0060)
+#define CPU3_FLAG                                   (TIMER_2HZ_BASE+0x0064)
+#define USB3_P0_CTL                                 (TIMER_2HZ_BASE+0x0080)
+#define USB3_P1_CTL                                 (TIMER_2HZ_BASE+0x0084)
+#define USB2_ECS                                    (TIMER_2HZ_BASE+0x0088)
+
+//--------------Bits Location-------------------------------------//
+//--------------CHIPID--------------------------------------//
+//--------------Register Address----------------------------------//
+#define CHIPID_BASE                                 0xB0150000
+#define CHIPID_CTRL0                                (CHIPID_BASE+0x0000)
+#define CHIPID_DAT_1                                (CHIPID_BASE+0x0004)
+#define CHIPID_CTRL1                                (CHIPID_BASE+0x0008)
+#define CHIPID_CTRL2                                (CHIPID_BASE+0x000C)
+
+//--------------Bits Location-------------------------------------//
+//--------------HDCP2Tx--------------------------------------//
+//--------------Register Address----------------------------------//
+#define HDCP2TX_BASE                                0xB0250000
+#define HDCP2TX_CR                                  (HDCP2TX_BASE+0x0000)
+#define HDCP2TX_SR                                  (HDCP2TX_BASE+0x0004)
+#define HDCP2TX_PDOFIFO                             (HDCP2TX_BASE+0x0008)
+#define HDCP2TX_HMACID                              (HDCP2TX_BASE+0x000C)
+#define HDCP2TX_RTXMR                               (HDCP2TX_BASE+0x0010)
+#define HDCP2TX_RTXLR                               (HDCP2TX_BASE+0x0014)
+#define HDCP2TX_KMD3                                (HDCP2TX_BASE+0x0018)
+#define HDCP2TX_KMD2                                (HDCP2TX_BASE+0x001C)
+#define HDCP2TX_KMD1                                (HDCP2TX_BASE+0x0020)
+#define HDCP2TX_KMD0                                (HDCP2TX_BASE+0x0024)
+#define HDCP2TX_RRXMR                               (HDCP2TX_BASE+0x0028)
+#define HDCP2TX_RRXLR                               (HDCP2TX_BASE+0x002C)
+#define HDCP2TX_RNMR                                (HDCP2TX_BASE+0x0030)
+#define HDCP2TX_RNLR                                (HDCP2TX_BASE+0x0034)
+#define HDCP2TX_RIVMR                               (HDCP2TX_BASE+0x0038)
+#define HDCP2TX_RIVLR                               (HDCP2TX_BASE+0x003C)
+#define HDCP2TX_EKSD3                               (HDCP2TX_BASE+0x0040)
+#define HDCP2TX_EKSD2                               (HDCP2TX_BASE+0x0044)
+#define HDCP2TX_EKSD1                               (HDCP2TX_BASE+0x0048)
+#define HDCP2TX_EKSD0                               (HDCP2TX_BASE+0x004C)
+#define HDCP2TX_KSD3                                (HDCP2TX_BASE+0x0050)
+#define HDCP2TX_KSD2                                (HDCP2TX_BASE+0x0054)
+#define HDCP2TX_KSD1                                (HDCP2TX_BASE+0x0058)
+#define HDCP2TX_KSD0                                (HDCP2TX_BASE+0x005C)
+#define HDCP2TX_GC3                                 (HDCP2TX_BASE+0x0060)
+#define HDCP2TX_GC2                                 (HDCP2TX_BASE+0x0064)
+#define HDCP2TX_GC1                                 (HDCP2TX_BASE+0x0068)
+#define HDCP2TX_GC0                                 (HDCP2TX_BASE+0x006C)
+#define HDCP2TX_STREAMCTR                           (HDCP2TX_BASE+0x0070)
+#define HDCP2TX_INPUTCTRMR                          (HDCP2TX_BASE+0x0074)
+#define HDCP2TX_INPUTCTRLR                          (HDCP2TX_BASE+0x0078)
+#define HDCP2TX_TSPH                                (HDCP2TX_BASE+0x007C)
+#define HDCP2TX_TSSP                                (HDCP2TX_BASE+0x0080)
+#define HDCP2TX_INOUTFIFOCR                         (HDCP2TX_BASE+0x0084)
+#define HDCP2TX_INRFIFOD                            (HDCP2TX_BASE+0x0088)
+#define HDCP2TX_INLENGTH                            (HDCP2TX_BASE+0x008C)
+#define HDCP2TX_OUTEFIFOD                           (HDCP2TX_BASE+0x0090)
+#define HDCP2TX_OUTLENGTH                           (HDCP2TX_BASE+0x0094)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA_GLOBAL--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA_GLOBAL_BASE                             0XB0260000
+#define DMA_NIC_QOS                                 (DMA_GLOBAL_BASE+0x0024)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA_IRQ_PD0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA_IRQ_PD0_BASE                            0XB0260000
+#define DMA_IRQ_PD0                                 (DMA_IRQ_PD0_BASE+0x0000)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA_IRQ_PD1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA_IRQ_PD1_BASE                            0XB0260004
+#define DMA_IRQ_PD1                                 (DMA_IRQ_PD1_BASE+0x0000)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA_IRQ_PD2--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA_IRQ_PD2_BASE                            0XB0260008
+#define DMA_IRQ_PD2                                 (DMA_IRQ_PD2_BASE+0x0000)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA_IRQ_PD3--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA_IRQ_PD3_BASE                            0XB026000c
+#define DMA_IRQ_PD3                                 (DMA_IRQ_PD3_BASE+0x0000)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA_IRQ_EN0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA_IRQ_EN0_BASE                            0XB0260010
+#define DMA_IRQ_EN0                                 (DMA_IRQ_EN0_BASE+0x0000)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA_IRQ_EN1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA_IRQ_EN1_BASE                            0XB0260014
+#define DMA_IRQ_EN1                                 (DMA_IRQ_EN1_BASE+0x0000)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA_IRQ_EN2--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA_IRQ_EN2_BASE                            0XB0260018
+#define DMA_IRQ_EN2                                 (DMA_IRQ_EN2_BASE+0x0000)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA_IRQ_EN3--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA_IRQ_EN3_BASE                            0XB026001c
+#define DMA_IRQ_EN3                                 (DMA_IRQ_EN3_BASE+0x0000)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA0_BASE                                   0XB0260100
+#define DMA0_MODE                                   (DMA0_BASE+0x0000)
+#define DMA0_SOURCE                                 (DMA0_BASE+0x0004)
+#define DMA0_DESTINATION                            (DMA0_BASE+0x0008)
+#define DMA0_FRAME_LEN                              (DMA0_BASE+0x000C)
+#define DMA0_FRAME_CNT                              (DMA0_BASE+0x0010)
+#define DMA0_REMAIN_FRAME_CNT                       (DMA0_BASE+0x0014)
+#define DMA0_REMAIN_CNT                             (DMA0_BASE+0x0018)
+#define DMA0_SOURCE_STRIDE                          (DMA0_BASE+0x001C)
+#define DMA0_DESTINATION_STRIDE                     (DMA0_BASE+0x0020)
+#define DMA0_START                                  (DMA0_BASE+0x0024)
+#define DMA0_ACP_ATTRIBUTE                          (DMA0_BASE+0x0028)
+#define DMA0_CHAINED_CTL                            (DMA0_BASE+0x002C)
+#define DMA0_CONSTANT                               (DMA0_BASE+0x0030)
+#define DMA0_LINKLIST_CTL                           (DMA0_BASE+0x0034)
+#define DMA0_NEXT_DESCRIPTOR                        (DMA0_BASE+0x0038)
+#define DMA0_CURRENT_DESCRIPTOR_NUM                 (DMA0_BASE+0x003C)
+#define DMA0_INT_CTL                                (DMA0_BASE+0x0040)
+#define DMA0_INT_STATUS                             (DMA0_BASE+0x0044)
+#define DMA0_CURRENT_SOURCE_POINTER                 (DMA0_BASE+0x0048)
+#define DMA0_CURRENT_DESTINATION_POINTER            (DMA0_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA1_BASE                                   0XB0260200
+#define DMA1_MODE                                   (DMA1_BASE+0x0000)
+#define DMA1_SOURCE                                 (DMA1_BASE+0x0004)
+#define DMA1_DESTINATION                            (DMA1_BASE+0x0008)
+#define DMA1_FRAME_LEN                              (DMA1_BASE+0x000C)
+#define DMA1_FRAME_CNT                              (DMA1_BASE+0x0010)
+#define DMA1_REMAIN_FRAME_CNT                       (DMA1_BASE+0x0014)
+#define DMA1_REMAIN_CNT                             (DMA1_BASE+0x0018)
+#define DMA1_SOURCE_STRIDE                          (DMA1_BASE+0x001C)
+#define DMA1_DESTINATION_STRIDE                     (DMA1_BASE+0x0020)
+#define DMA1_START                                  (DMA1_BASE+0x0024)
+#define DMA1_ACP_ATTRIBUTE                          (DMA1_BASE+0x0028)
+#define DMA1_CHAINED_CTL                            (DMA1_BASE+0x002C)
+#define DMA1_CONSTANT                               (DMA1_BASE+0x0030)
+#define DMA1_LINKLIST_CTL                           (DMA1_BASE+0x0034)
+#define DMA1_NEXT_DESCRIPTOR                        (DMA1_BASE+0x0038)
+#define DMA1_CURRENT_DESCRIPTOR_NUM                 (DMA1_BASE+0x003C)
+#define DMA1_INT_CTL                                (DMA1_BASE+0x0040)
+#define DMA1_INT_STATUS                             (DMA1_BASE+0x0044)
+#define DMA1_CURRENT_SOURCE_POINTER                 (DMA1_BASE+0x0048)
+#define DMA1_CURRENT_DESTINATION_POINTER            (DMA1_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA2--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA2_BASE                                   0XB0260300
+#define DMA2_MODE                                   (DMA2_BASE+0x0000)
+#define DMA2_SOURCE                                 (DMA2_BASE+0x0004)
+#define DMA2_DESTINATION                            (DMA2_BASE+0x0008)
+#define DMA2_FRAME_LEN                              (DMA2_BASE+0x000C)
+#define DMA2_FRAME_CNT                              (DMA2_BASE+0x0010)
+#define DMA2_REMAIN_FRAME_CNT                       (DMA2_BASE+0x0014)
+#define DMA2_REMAIN_CNT                             (DMA2_BASE+0x0018)
+#define DMA2_SOURCE_STRIDE                          (DMA2_BASE+0x001C)
+#define DMA2_DESTINATION_STRIDE                     (DMA2_BASE+0x0020)
+#define DMA2_START                                  (DMA2_BASE+0x0024)
+#define DMA2_ACP_ATTRIBUTE                          (DMA2_BASE+0x0028)
+#define DMA2_CHAINED_CTL                            (DMA2_BASE+0x002C)
+#define DMA2_CONSTANT                               (DMA2_BASE+0x0030)
+#define DMA2_LINKLIST_CTL                           (DMA2_BASE+0x0034)
+#define DMA2_NEXT_DESCRIPTOR                        (DMA2_BASE+0x0038)
+#define DMA2_CURRENT_DESCRIPTOR_NUM                 (DMA2_BASE+0x003C)
+#define DMA2_INT_CTL                                (DMA2_BASE+0x0040)
+#define DMA2_INT_STATUS                             (DMA2_BASE+0x0044)
+#define DMA2_CURRENT_SOURCE_POINTER                 (DMA2_BASE+0x0048)
+#define DMA2_CURRENT_DESTINATION_POINTER            (DMA2_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA3--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA3_BASE                                   0XB0260400
+#define DMA3_MODE                                   (DMA3_BASE+0x0000)
+#define DMA3_SOURCE                                 (DMA3_BASE+0x0004)
+#define DMA3_DESTINATION                            (DMA3_BASE+0x0008)
+#define DMA3_FRAME_LEN                              (DMA3_BASE+0x000C)
+#define DMA3_FRAME_CNT                              (DMA3_BASE+0x0010)
+#define DMA3_REMAIN_FRAME_CNT                       (DMA3_BASE+0x0014)
+#define DMA3_REMAIN_CNT                             (DMA3_BASE+0x0018)
+#define DMA3_SOURCE_STRIDE                          (DMA3_BASE+0x001C)
+#define DMA3_DESTINATION_STRIDE                     (DMA3_BASE+0x0020)
+#define DMA3_START                                  (DMA3_BASE+0x0024)
+#define DMA3_ACP_ATTRIBUTE                          (DMA3_BASE+0x0028)
+#define DMA3_CHAINED_CTL                            (DMA3_BASE+0x002C)
+#define DMA3_CONSTANT                               (DMA3_BASE+0x0030)
+#define DMA3_LINKLIST_CTL                           (DMA3_BASE+0x0034)
+#define DMA3_NEXT_DESCRIPTOR                        (DMA3_BASE+0x0038)
+#define DMA3_CURRENT_DESCRIPTOR_NUM                 (DMA3_BASE+0x003C)
+#define DMA3_INT_CTL                                (DMA3_BASE+0x0040)
+#define DMA3_INT_STATUS                             (DMA3_BASE+0x0044)
+#define DMA3_CURRENT_SOURCE_POINTER                 (DMA3_BASE+0x0048)
+#define DMA3_CURRENT_DESTINATION_POINTER            (DMA3_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA4--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA4_BASE                                   0XB0260500
+#define DMA4_MODE                                   (DMA4_BASE+0x0000)
+#define DMA4_SOURCE                                 (DMA4_BASE+0x0004)
+#define DMA4_DESTINATION                            (DMA4_BASE+0x0008)
+#define DMA4_FRAME_LEN                              (DMA4_BASE+0x000C)
+#define DMA4_FRAME_CNT                              (DMA4_BASE+0x0010)
+#define DMA4_REMAIN_FRAME_CNT                       (DMA4_BASE+0x0014)
+#define DMA4_REMAIN_CNT                             (DMA4_BASE+0x0018)
+#define DMA4_SOURCE_STRIDE                          (DMA4_BASE+0x001C)
+#define DMA4_DESTINATION_STRIDE                     (DMA4_BASE+0x0020)
+#define DMA4_START                                  (DMA4_BASE+0x0024)
+#define DMA4_ACP_ATTRIBUTE                          (DMA4_BASE+0x0028)
+#define DMA4_CHAINED_CTL                            (DMA4_BASE+0x002C)
+#define DMA4_CONSTANT                               (DMA4_BASE+0x0030)
+#define DMA4_LINKLIST_CTL                           (DMA4_BASE+0x0034)
+#define DMA4_NEXT_DESCRIPTOR                        (DMA4_BASE+0x0038)
+#define DMA4_CURRENT_DESCRIPTOR_NUM                 (DMA4_BASE+0x003C)
+#define DMA4_INT_CTL                                (DMA4_BASE+0x0040)
+#define DMA4_INT_STATUS                             (DMA4_BASE+0x0044)
+#define DMA4_CURRENT_SOURCE_POINTER                 (DMA4_BASE+0x0048)
+#define DMA4_CURRENT_DESTINATION_POINTER            (DMA4_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA5--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA5_BASE                                   0XB0260600
+#define DMA5_MODE                                   (DMA5_BASE+0x0000)
+#define DMA5_SOURCE                                 (DMA5_BASE+0x0004)
+#define DMA5_DESTINATION                            (DMA5_BASE+0x0008)
+#define DMA5_FRAME_LEN                              (DMA5_BASE+0x000C)
+#define DMA5_FRAME_CNT                              (DMA5_BASE+0x0010)
+#define DMA5_REMAIN_FRAME_CNT                       (DMA5_BASE+0x0014)
+#define DMA5_REMAIN_CNT                             (DMA5_BASE+0x0018)
+#define DMA5_SOURCE_STRIDE                          (DMA5_BASE+0x001C)
+#define DMA5_DESTINATION_STRIDE                     (DMA5_BASE+0x0020)
+#define DMA5_START                                  (DMA5_BASE+0x0024)
+#define DMA5_ACP_ATTRIBUTE                          (DMA5_BASE+0x0028)
+#define DMA5_CHAINED_CTL                            (DMA5_BASE+0x002C)
+#define DMA5_CONSTANT                               (DMA5_BASE+0x0030)
+#define DMA5_LINKLIST_CTL                           (DMA5_BASE+0x0034)
+#define DMA5_NEXT_DESCRIPTOR                        (DMA5_BASE+0x0038)
+#define DMA5_CURRENT_DESCRIPTOR_NUM                 (DMA5_BASE+0x003C)
+#define DMA5_INT_CTL                                (DMA5_BASE+0x0040)
+#define DMA5_INT_STATUS                             (DMA5_BASE+0x0044)
+#define DMA5_CURRENT_SOURCE_POINTER                 (DMA5_BASE+0x0048)
+#define DMA5_CURRENT_DESTINATION_POINTER            (DMA5_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA6--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA6_BASE                                   0XB0260700
+#define DMA6_MODE                                   (DMA6_BASE+0x0000)
+#define DMA6_SOURCE                                 (DMA6_BASE+0x0004)
+#define DMA6_DESTINATION                            (DMA6_BASE+0x0008)
+#define DMA6_FRAME_LEN                              (DMA6_BASE+0x000C)
+#define DMA6_FRAME_CNT                              (DMA6_BASE+0x0010)
+#define DMA6_REMAIN_FRAME_CNT                       (DMA6_BASE+0x0014)
+#define DMA6_REMAIN_CNT                             (DMA6_BASE+0x0018)
+#define DMA6_SOURCE_STRIDE                          (DMA6_BASE+0x001C)
+#define DMA6_DESTINATION_STRIDE                     (DMA6_BASE+0x0020)
+#define DMA6_START                                  (DMA6_BASE+0x0024)
+#define DMA6_ACP_ATTRIBUTE                          (DMA6_BASE+0x0028)
+#define DMA6_CHAINED_CTL                            (DMA6_BASE+0x002C)
+#define DMA6_CONSTANT                               (DMA6_BASE+0x0030)
+#define DMA6_LINKLIST_CTL                           (DMA6_BASE+0x0034)
+#define DMA6_NEXT_DESCRIPTOR                        (DMA6_BASE+0x0038)
+#define DMA6_CURRENT_DESCRIPTOR_NUM                 (DMA6_BASE+0x003C)
+#define DMA6_INT_CTL                                (DMA6_BASE+0x0040)
+#define DMA6_INT_STATUS                             (DMA6_BASE+0x0044)
+#define DMA6_CURRENT_SOURCE_POINTER                 (DMA6_BASE+0x0048)
+#define DMA6_CURRENT_DESTINATION_POINTER            (DMA6_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA7--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA7_BASE                                   0XB0260800
+#define DMA7_MODE                                   (DMA7_BASE+0x0000)
+#define DMA7_SOURCE                                 (DMA7_BASE+0x0004)
+#define DMA7_DESTINATION                            (DMA7_BASE+0x0008)
+#define DMA7_FRAME_LEN                              (DMA7_BASE+0x000C)
+#define DMA7_FRAME_CNT                              (DMA7_BASE+0x0010)
+#define DMA7_REMAIN_FRAME_CNT                       (DMA7_BASE+0x0014)
+#define DMA7_REMAIN_CNT                             (DMA7_BASE+0x0018)
+#define DMA7_SOURCE_STRIDE                          (DMA7_BASE+0x001C)
+#define DMA7_DESTINATION_STRIDE                     (DMA7_BASE+0x0020)
+#define DMA7_START                                  (DMA7_BASE+0x0024)
+#define DMA7_ACP_ATTRIBUTE                          (DMA7_BASE+0x0028)
+#define DMA7_CHAINED_CTL                            (DMA7_BASE+0x002C)
+#define DMA7_CONSTANT                               (DMA7_BASE+0x0030)
+#define DMA7_LINKLIST_CTL                           (DMA7_BASE+0x0034)
+#define DMA7_NEXT_DESCRIPTOR                        (DMA7_BASE+0x0038)
+#define DMA7_CURRENT_DESCRIPTOR_NUM                 (DMA7_BASE+0x003C)
+#define DMA7_INT_CTL                                (DMA7_BASE+0x0040)
+#define DMA7_INT_STATUS                             (DMA7_BASE+0x0044)
+#define DMA7_CURRENT_SOURCE_POINTER                 (DMA7_BASE+0x0048)
+#define DMA7_CURRENT_DESTINATION_POINTER            (DMA7_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA8--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA8_BASE                                   0XB0260900
+#define DMA8_MODE                                   (DMA8_BASE+0x0000)
+#define DMA8_SOURCE                                 (DMA8_BASE+0x0004)
+#define DMA8_DESTINATION                            (DMA8_BASE+0x0008)
+#define DMA8_FRAME_LEN                              (DMA8_BASE+0x000C)
+#define DMA8_FRAME_CNT                              (DMA8_BASE+0x0010)
+#define DMA8_REMAIN_FRAME_CNT                       (DMA8_BASE+0x0014)
+#define DMA8_REMAIN_CNT                             (DMA8_BASE+0x0018)
+#define DMA8_SOURCE_STRIDE                          (DMA8_BASE+0x001C)
+#define DMA8_DESTINATION_STRIDE                     (DMA8_BASE+0x0020)
+#define DMA8_START                                  (DMA8_BASE+0x0024)
+#define DMA8_ACP_ATTRIBUTE                          (DMA8_BASE+0x0028)
+#define DMA8_CHAINED_CTL                            (DMA8_BASE+0x002C)
+#define DMA8_CONSTANT                               (DMA8_BASE+0x0030)
+#define DMA8_LINKLIST_CTL                           (DMA8_BASE+0x0034)
+#define DMA8_NEXT_DESCRIPTOR                        (DMA8_BASE+0x0038)
+#define DMA8_CURRENT_DESCRIPTOR_NUM                 (DMA8_BASE+0x003C)
+#define DMA8_INT_CTL                                (DMA8_BASE+0x0040)
+#define DMA8_INT_STATUS                             (DMA8_BASE+0x0044)
+#define DMA8_CURRENT_SOURCE_POINTER                 (DMA8_BASE+0x0048)
+#define DMA8_CURRENT_DESTINATION_POINTER            (DMA8_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA9--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA9_BASE                                   0XB0260A00
+#define DMA9_MODE                                   (DMA9_BASE+0x0000)
+#define DMA9_SOURCE                                 (DMA9_BASE+0x0004)
+#define DMA9_DESTINATION                            (DMA9_BASE+0x0008)
+#define DMA9_FRAME_LEN                              (DMA9_BASE+0x000C)
+#define DMA9_FRAME_CNT                              (DMA9_BASE+0x0010)
+#define DMA9_REMAIN_FRAME_CNT                       (DMA9_BASE+0x0014)
+#define DMA9_REMAIN_CNT                             (DMA9_BASE+0x0018)
+#define DMA9_SOURCE_STRIDE                          (DMA9_BASE+0x001C)
+#define DMA9_DESTINATION_STRIDE                     (DMA9_BASE+0x0020)
+#define DMA9_START                                  (DMA9_BASE+0x0024)
+#define DMA9_ACP_ATTRIBUTE                          (DMA9_BASE+0x0028)
+#define DMA9_CHAINED_CTL                            (DMA9_BASE+0x002C)
+#define DMA9_CONSTANT                               (DMA9_BASE+0x0030)
+#define DMA9_LINKLIST_CTL                           (DMA9_BASE+0x0034)
+#define DMA9_NEXT_DESCRIPTOR                        (DMA9_BASE+0x0038)
+#define DMA9_CURRENT_DESCRIPTOR_NUM                 (DMA9_BASE+0x003C)
+#define DMA9_INT_CTL                                (DMA9_BASE+0x0040)
+#define DMA9_INT_STATUS                             (DMA9_BASE+0x0044)
+#define DMA9_CURRENT_SOURCE_POINTER                 (DMA9_BASE+0x0048)
+#define DMA9_CURRENT_DESTINATION_POINTER            (DMA9_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA10--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA10_BASE                                  0XB0260B00
+#define DMA10_MODE                                  (DMA10_BASE+0x0000)
+#define DMA10_SOURCE                                (DMA10_BASE+0x0004)
+#define DMA10_DESTINATION                           (DMA10_BASE+0x0008)
+#define DMA10_FRAME_LEN                             (DMA10_BASE+0x000C)
+#define DMA10_FRAME_CNT                             (DMA10_BASE+0x0010)
+#define DMA10_REMAIN_FRAME_CNT                      (DMA10_BASE+0x0014)
+#define DMA10_REMAIN_CNT                            (DMA10_BASE+0x0018)
+#define DMA10_SOURCE_STRIDE                         (DMA10_BASE+0x001C)
+#define DMA10_DESTINATION_STRIDE                    (DMA10_BASE+0x0020)
+#define DMA10_START                                 (DMA10_BASE+0x0024)
+#define DMA10_ACP_ATTRIBUTE                         (DMA10_BASE+0x0028)
+#define DMA10_CHAINED_CTL                           (DMA10_BASE+0x002C)
+#define DMA10_CONSTANT                              (DMA10_BASE+0x0030)
+#define DMA10_LINKLIST_CTL                          (DMA10_BASE+0x0034)
+#define DMA10_NEXT_DESCRIPTOR                       (DMA10_BASE+0x0038)
+#define DMA10_CURRENT_DESCRIPTOR_NUM                (DMA10_BASE+0x003C)
+#define DMA10_INT_CTL                               (DMA10_BASE+0x0040)
+#define DMA10_INT_STATUS                            (DMA10_BASE+0x0044)
+#define DMA10_CURRENT_SOURCE_POINTER                (DMA10_BASE+0x0048)
+#define DMA10_CURRENT_DESTINATION_POINTER           (DMA10_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMA11--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMA11_BASE                                  0XB0260C00
+#define DMA11_MODE                                  (DMA11_BASE+0x0000)
+#define DMA11_SOURCE                                (DMA11_BASE+0x0004)
+#define DMA11_DESTINATION                           (DMA11_BASE+0x0008)
+#define DMA11_FRAME_LEN                             (DMA11_BASE+0x000C)
+#define DMA11_FRAME_CNT                             (DMA11_BASE+0x0010)
+#define DMA11_REMAIN_FRAME_CNT                      (DMA11_BASE+0x0014)
+#define DMA11_REMAIN_CNT                            (DMA11_BASE+0x0018)
+#define DMA11_SOURCE_STRIDE                         (DMA11_BASE+0x001C)
+#define DMA11_DESTINATION_STRIDE                    (DMA11_BASE+0x0020)
+#define DMA11_START                                 (DMA11_BASE+0x0024)
+#define DMA11_ACP_ATTRIBUTE                         (DMA11_BASE+0x0028)
+#define DMA11_CHAINED_CTL                           (DMA11_BASE+0x002C)
+#define DMA11_CONSTANT                              (DMA11_BASE+0x0030)
+#define DMA11_LINKLIST_CTL                          (DMA11_BASE+0x0034)
+#define DMA11_NEXT_DESCRIPTOR                       (DMA11_BASE+0x0038)
+#define DMA11_CURRENT_DESCRIPTOR_NUM                (DMA11_BASE+0x003C)
+#define DMA11_INT_CTL                               (DMA11_BASE+0x0040)
+#define DMA11_INT_STATUS                            (DMA11_BASE+0x0044)
+#define DMA11_CURRENT_SOURCE_POINTER                (DMA11_BASE+0x0048)
+#define DMA11_CURRENT_DESTINATION_POINTER           (DMA11_BASE+0x004C)
+
+//--------------Bits Location-------------------------------------//
+//--------------ISP--------------------------------------//
+//--------------Register Address----------------------------------//
+#define ISP_BASE                                    0xB0270000
+#define ISP_CB_TIME                                 (ISP_BASE+0x00)
+//#define ISP_ENABLE                                  (ISP_BASE+0x10)
+//#define ISP_CTL                                     (ISP_BASE+0x20)
+//#define ISP_CHANNEL_1_STATE                         (ISP_BASE+0x24)
+#define ISP_CHANNEL_1_BA_OFFSET                     (ISP_BASE+0x28)
+//#define ISP_CHANNEL_1_ROW_RANGE                     (ISP_BASE+0x2C)
+//#define ISP_CHANNEL_1_COL_RANGE                     (ISP_BASE+0x30)
+#define ISP_CHANNEL_1_ADDR0                         (ISP_BASE+0x34)
+#define ISP_CHANNEL_1_ADDR1                         (ISP_BASE+0x38)
+#define ISP_CHANNEL_1_ADDR2                         (ISP_BASE+0x3C)
+#define ISP_CHANNEL_1_ADDR3                         (ISP_BASE+0x40)
+#define ISP_CHANNEL_1_ADDR4                         (ISP_BASE+0x44)
+#define ISP_CHANNEL_1_ADDR5                         (ISP_BASE+0x48)
+#define ISP_CHANNEL_1_ADDR6                         (ISP_BASE+0x4C)
+#define ISP_CHANNEL_1_ADDR7                         (ISP_BASE+0x50)
+#define VNC_LUT_PORT                                (ISP_BASE+0x54)
+#define VNC_RST                                     (ISP_BASE+0x58)
+#define ISP_LSC_LUT_PORT                            (ISP_BASE+0x60)
+#define ISP_LSC_PIX_INC                             (ISP_BASE+0x64)
+#define ISP_LSC_SCALING                             (ISP_BASE+0x68)
+#define ISP_LSC_CENTER0                             (ISP_BASE+0x6C)
+#define ISP_LSC_CENTER1                             (ISP_BASE+0x70)
+#define ISP_LSC_RST                                 (ISP_BASE+0x74)
+#define ISP_NR_CONTROL                              (ISP_BASE+0x80)
+#define ISP_DPC_THRESHOLD                           (ISP_BASE+0x88)
+#define ISP_CG_B_GAIN                               (ISP_BASE+0x90)
+#define ISP_CG_G_GAIN                               (ISP_BASE+0x94)
+#define ISP_CG_R_GAIN                               (ISP_BASE+0x98)
+#define ISP_STAT_REGION_Y                           (ISP_BASE+0xA0)
+#define ISP_STAT_REGION_X                           (ISP_BASE+0xA4)
+#define ISP_STAT_HIST_Y                             (ISP_BASE+0xA8)
+#define ISP_STAT_HIST_X                             (ISP_BASE+0xAC)
+#define ISP_WB_THRESHOLD                            (ISP_BASE+0xB0)
+#define ISP_CSC_OFFSET1                             (ISP_BASE+0xC0)
+#define ISP_CSC_OFFSET2                             (ISP_BASE+0xC4)
+#define ISP_CSC_OFFSET3                             (ISP_BASE+0xC8)
+#define ISP_CSC_Y_R                                 (ISP_BASE+0xCC)
+#define ISP_CSC_Y_G                                 (ISP_BASE+0xD0)
+#define ISP_CSC_Y_B                                 (ISP_BASE+0xD4)
+#define ISP_CSC_CB_R                                (ISP_BASE+0xD8)
+#define ISP_CSC_CB_G                                (ISP_BASE+0xDC)
+#define ISP_CSC_CB_B                                (ISP_BASE+0xE0)
+#define ISP_CSC_CR_R                                (ISP_BASE+0xE4)
+#define ISP_CSC_CR_G                                (ISP_BASE+0xE8)
+#define ISP_CSC_CR_B                                (ISP_BASE+0xEC)
+#define ISP_CSC_CONTROL                             (ISP_BASE+0xF0)
+#define ISP_GC_COEFF_0                              (ISP_BASE+0x100)
+#define ISP_GC_COEFF_1                              (ISP_BASE+0x104)
+#define ISP_GC_COEFF_2                              (ISP_BASE+0x108)
+#define ISP_GC_COEFF_3                              (ISP_BASE+0x10C)
+#define ISP_GC_COEFF_4                              (ISP_BASE+0x110)
+#define ISP_GC_COEFF_5                              (ISP_BASE+0x114)
+#define ISP_GC_COEFF_6                              (ISP_BASE+0x118)
+#define ISP_GC_COEFF_7                              (ISP_BASE+0x11C)
+#define ISP_GC_COEFF_8                              (ISP_BASE+0x120)
+#define ISP_GC_COEFF_9                              (ISP_BASE+0x124)
+#define ISP_GC_COEFF_10                             (ISP_BASE+0x128)
+#define ISP_GC_COEFF_11                             (ISP_BASE+0x12C)
+#define ISP_GC_COEFF_12                             (ISP_BASE+0x130)
+#define ISP_GC_COEFF_13                             (ISP_BASE+0x134)
+#define ISP_GC_COEFF_14                             (ISP_BASE+0x138)
+#define ISP_GC_COEFF_15                             (ISP_BASE+0x13C)
+//#define ISP_OUT_FMT                                 (ISP_BASE+0x148)
+//#define ISP_OUT_ADDRY                               (ISP_BASE+0x14C)
+//#define ISP_OUT_ADDRU                               (ISP_BASE+0x150)
+//#define ISP_OUT_ADDRV                               (ISP_BASE+0x154)
+//#define ISP_OUT_ADDR1UV                             (ISP_BASE+0x158)
+#define ISP_STAT_ADDR                               (ISP_BASE+0x160)
+#define ISP_COLOR_REPLACE1                          (ISP_BASE+0x170)
+#define ISP_COLOR_REPLACE2                          (ISP_BASE+0x174)
+#define ISP_COLOR_REPLACE3                          (ISP_BASE+0x178)
+#define ISP_COLOR_REPLACE4                          (ISP_BASE+0x17C)
+#define ISP_COLOR_REPLACE5                          (ISP_BASE+0x180)
+#define ISP_COLOR_REPLACE6                          (ISP_BASE+0x184)
+#define ISP_COLOR_REPLACE7                          (ISP_BASE+0x188)
+#define ISP_COLOR_REPLACE8                          (ISP_BASE+0x18C)
+#define ISP_COLOR_REPLACE9                          (ISP_BASE+0x190)
+#define ISP_COLOR_REPLACE10                         (ISP_BASE+0x194)
+#define ISP_COLOR_REPLACE11                         (ISP_BASE+0x198)
+#define ISP_COLOR_REPLACE12                         (ISP_BASE+0x19C)
+#define ISP_COLOR_REPLACE13                         (ISP_BASE+0x1A0)
+#define ISP_COLOR_REPLACE14                         (ISP_BASE+0x1A4)
+#define ISP_COLOR_REPLACE15                         (ISP_BASE+0x1A8)
+#define ISP_COLOR_REPLACE16                         (ISP_BASE+0x1AC)
+//#define ISP2_CTL                                    (ISP_BASE+0x1EC)
+//#define ISP_CHANNEL_2_STATE                         (ISP_BASE+0x1F0)
+#define ISP_CHANNEL_2_BA_OFFSET                     (ISP_BASE+0x1F4)
+//#define ISP_CHANNEL_2_ROW_RANGE                     (ISP_BASE+0x1F8)
+//#define ISP_CHANNEL_2_COL_RANGE                     (ISP_BASE+0x1FC)
+#define ISP_CHANNEL_2_ADDR0                         (ISP_BASE+0x200)
+#define ISP_CHANNEL_2_ADDR1                         (ISP_BASE+0x204)
+#define ISP_CHANNEL_2_ADDR2                         (ISP_BASE+0x208)
+#define ISP_CHANNEL_2_ADDR3                         (ISP_BASE+0x20C)
+#define ISP_CHANNEL_2_ADDR4                         (ISP_BASE+0x210)
+#define ISP_CHANNEL_2_ADDR5                         (ISP_BASE+0x214)
+#define ISP_CHANNEL_2_ADDR6                         (ISP_BASE+0x218)
+#define ISP_CHANNEL_2_ADDR7                         (ISP_BASE+0x21C)
+#define ISP2_LSC_LUT_PORT                           (ISP_BASE+0x22C)
+#define ISP2_LSC_PIX_INC                            (ISP_BASE+0x230)
+#define ISP2_LSC_SCALING                            (ISP_BASE+0x234)
+#define ISP2_LSC_CENTER0                            (ISP_BASE+0x238)
+#define ISP2_LSC_CENTER1                            (ISP_BASE+0x23C)
+#define ISP2_LSC_RST                                (ISP_BASE+0x240)
+#define ISP2_NR_CONTROL                             (ISP_BASE+0x24C)
+#define ISP2_DPC_THRESHOLD                          (ISP_BASE+0x254)
+#define ISP2_CG_B_GAIN                              (ISP_BASE+0x25C)
+#define ISP2_CG_G_GAIN                              (ISP_BASE+0x260)
+#define ISP2_CG_R_GAIN                              (ISP_BASE+0x264)
+#define ISP2_STAT_REGION_Y                          (ISP_BASE+0x26C)
+#define ISP2_STAT_REGION_X                          (ISP_BASE+0x270)
+#define ISP2_STAT_HIST_Y                            (ISP_BASE+0x274)
+#define ISP2_STAT_HIST_X                            (ISP_BASE+0x278)
+#define ISP2_WB_THRESHOLD                           (ISP_BASE+0x27C)
+#define ISP2_CSC_OFFSET1                            (ISP_BASE+0x28C)
+#define ISP2_CSC_OFFSET2                            (ISP_BASE+0x290)
+#define ISP2_CSC_OFFSET3                            (ISP_BASE+0x294)
+#define ISP2_CSC_Y_R                                (ISP_BASE+0x298)
+#define ISP2_CSC_Y_G                                (ISP_BASE+0x29C)
+#define ISP2_CSC_Y_B                                (ISP_BASE+0x2A0)
+#define ISP2_CSC_CB_R                               (ISP_BASE+0x2A4)
+#define ISP2_CSC_CB_G                               (ISP_BASE+0x2A8)
+#define ISP2_CSC_CB_B                               (ISP_BASE+0x2AC)
+#define ISP2_CSC_CR_R                               (ISP_BASE+0x2B0)
+#define ISP2_CSC_CR_G                               (ISP_BASE+0x2B4)
+#define ISP2_CSC_CR_B                               (ISP_BASE+0x2B8)
+#define ISP2_CSC_CONTROL                            (ISP_BASE+0x2BC)
+#define ISP2_GC_COEFF_0                             (ISP_BASE+0x2CC)
+#define ISP2_GC_COEFF_1                             (ISP_BASE+0x2D0)
+#define ISP2_GC_COEFF_2                             (ISP_BASE+0x2D4)
+#define ISP2_GC_COEFF_3                             (ISP_BASE+0x2D8)
+#define ISP2_GC_COEFF_4                             (ISP_BASE+0x2DC)
+#define ISP2_GC_COEFF_5                             (ISP_BASE+0x2E0)
+#define ISP2_GC_COEFF_6                             (ISP_BASE+0x2E4)
+#define ISP2_GC_COEFF_7                             (ISP_BASE+0x2E8)
+#define ISP2_GC_COEFF_8                             (ISP_BASE+0x2EC)
+#define ISP2_GC_COEFF_9                             (ISP_BASE+0x2F0)
+#define ISP2_GC_COEFF_10                            (ISP_BASE+0x2F4)
+#define ISP2_GC_COEFF_11                            (ISP_BASE+0x2F8)
+#define ISP2_GC_COEFF_12                            (ISP_BASE+0x2FC)
+#define ISP2_GC_COEFF_13                            (ISP_BASE+0x300)
+#define ISP2_GC_COEFF_14                            (ISP_BASE+0x304)
+#define ISP2_GC_COEFF_15                            (ISP_BASE+0x308)
+//#define ISP2_OUT_FMT                                (ISP_BASE+0x314)
+//#define ISP2_OUT_ADDRY                              (ISP_BASE+0x318)
+//#define ISP2_OUT_ADDRU                              (ISP_BASE+0x31C)
+//#define ISP2_OUT_ADDRV                              (ISP_BASE+0x320)
+//#define ISP2_OUT_ADDR1UV                            (ISP_BASE+0x324)
+#define ISP2_STAT_ADDR                              (ISP_BASE+0x32C)
+#define ISP2_COLOR_REPLACE1                         (ISP_BASE+0x33C)
+#define ISP2_COLOR_REPLACE2                         (ISP_BASE+0x340)
+#define ISP2_COLOR_REPLACE3                         (ISP_BASE+0x344)
+#define ISP2_COLOR_REPLACE4                         (ISP_BASE+0x348)
+#define ISP2_COLOR_REPLACE5                         (ISP_BASE+0x34C)
+#define ISP2_COLOR_REPLACE6                         (ISP_BASE+0x350)
+#define ISP2_COLOR_REPLACE7                         (ISP_BASE+0x354)
+#define ISP2_COLOR_REPLACE8                         (ISP_BASE+0x358)
+#define ISP2_COLOR_REPLACE9                         (ISP_BASE+0x35C)
+#define ISP2_COLOR_REPLACE10                        (ISP_BASE+0x360)
+#define ISP2_COLOR_REPLACE11                        (ISP_BASE+0x364)
+#define ISP2_COLOR_REPLACE12                        (ISP_BASE+0x368)
+#define ISP2_COLOR_REPLACE13                        (ISP_BASE+0x36C)
+#define ISP2_COLOR_REPLACE14                        (ISP_BASE+0x370)
+#define ISP2_COLOR_REPLACE15                        (ISP_BASE+0x374)
+#define ISP2_COLOR_REPLACE16                        (ISP_BASE+0x378)
+#define ISP_FREEMODE_IMAGE_SIZE                     (ISP_BASE+0x398)
+#define ISP_FREEMODE_SET                            (ISP_BASE+0x39C)
+#define ISP_FREEMODE_ADDRESS                        (ISP_BASE+0x3A0)
+#define AF_ENABLE                                   (ISP_BASE+0x3A4)
+#define AF_CTRL                                     (ISP_BASE+0x3A8)
+#define AF_WP0                                      (ISP_BASE+0x3AC)
+#define AF_WP1                                      (ISP_BASE+0x3B0)
+#define AF_WP2                                      (ISP_BASE+0x3B4)
+#define AF_WP3                                      (ISP_BASE+0x3B8)
+#define AF_WP4                                      (ISP_BASE+0x3BC)
+#define AF_WP5                                      (ISP_BASE+0x3C0)
+#define AF_WP6                                      (ISP_BASE+0x3C4)
+#define AF_WP7                                      (ISP_BASE+0x3C8)
+#define AF_WP8                                      (ISP_BASE+0x3CC)
+#define AF_FV0                                      (ISP_BASE+0x3D0)
+#define AF_FV1                                      (ISP_BASE+0x3D4)
+#define AF_FV2                                      (ISP_BASE+0x3D8)
+#define AF_FV3                                      (ISP_BASE+0x3DC)
+#define AF_FV4                                      (ISP_BASE+0x3E0)
+#define AF_FV5                                      (ISP_BASE+0x3E4)
+#define AF_FV6                                      (ISP_BASE+0x3E8)
+#define AF_FV7                                      (ISP_BASE+0x3EC)
+#define AF_FV8                                      (ISP_BASE+0x3F0)
+#define AF_TEN_THOD                                 (ISP_BASE+0x3F4)
+//#define ISP_INT_STAT                                (ISP_BASE+0x400)
+
+//--------------Bits Location-------------------------------------//
+//--------------DE--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DE_BASE                                     0xB02E0000
+#define DE_INTEN                                    (DE_BASE+0x0000)
+#define DE_STAT                                     (DE_BASE+0x0004)
+#define DE_CRITICAL_NUM                             (DE_BASE+0x0008)
+#define OUTPUT_CTL                                  (DE_BASE+0x1000)
+#define WB_CFG                                      (DE_BASE+0x1004)
+#define WB_ADDR                                     (DE_BASE+0x1008)
+#define FIFO_ERROR                                  (DE_BASE+0x100c)
+
+//--------------Bits Location-------------------------------------//
+//--------------PATH0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define PATH0_BASE                                  0xB02E0100
+#define PATH0_CTL                                   (PATH0_BASE+0x0000)
+#define PATH0_BK                                    (PATH0_BASE+0x0020)
+#define PATH0_SIZE                                  (PATH0_BASE+0x0024)
+#define PATH0_E_COOR                                (PATH0_BASE+0x0028)
+#define PATH0_GAMMA_IDX                             (PATH0_BASE+0x002c)
+#define PATH0_GAMMA_RAM                             (PATH0_BASE+0x0030)
+#define PATH0_CURSOR_FB                             (PATH0_BASE+0x0034)
+#define PATH0_CURSOR_STR                            (PATH0_BASE+0x0038)
+
+//--------------Bits Location-------------------------------------//
+//--------------PATH1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define PATH1_BASE                                  0xB02E0200
+#define PATH1_CTL                                   (PATH1_BASE+0x0000)
+#define PATH1_BK                                    (PATH1_BASE+0x0020)
+#define PATH1_SIZE                                  (PATH1_BASE+0x0024)
+#define PATH1_E_COOR                                (PATH1_BASE+0x0028)
+#define PATH1_GAMMA_IDX                             (PATH1_BASE+0x002c)
+#define PATH1_GAMMA_RAM                             (PATH1_BASE+0x0030)
+#define PATH1_CURSOR_FB                             (PATH1_BASE+0x0034)
+#define PATH1_CURSOR_STR                            (PATH1_BASE+0x0038)
+
+//--------------Bits Location-------------------------------------//
+//--------------VIDEO0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define VIDEO0_BASE                                 0xB02E0400
+#define VIDEO0_CFG                                  (VIDEO0_BASE+0x0000)
+#define VIDEO0_ISIZE                                (VIDEO0_BASE+0x0004)
+#define VIDEO0_OSIZE                                (VIDEO0_BASE+0x0008)
+#define VIDEO0_SR                                   (VIDEO0_BASE+0x000c)
+#define VIDEO0_SCOEF0                               (VIDEO0_BASE+0x0010)
+#define VIDEO0_SCOEF1                               (VIDEO0_BASE+0x0014)
+#define VIDEO0_SCOEF2                               (VIDEO0_BASE+0x0018)
+#define VIDEO0_SCOEF3                               (VIDEO0_BASE+0x001c)
+#define VIDEO0_SCOEF4                               (VIDEO0_BASE+0x0020)
+#define VIDEO0_SCOEF5                               (VIDEO0_BASE+0x0024)
+#define VIDEO0_SCOEF6                               (VIDEO0_BASE+0x0028)
+#define VIDEO0_SCOEF7                               (VIDEO0_BASE+0x002c )
+#define VIDEO0_FB_0                                 (VIDEO0_BASE+0x0030)
+#define VIDEO0_FB_1                                 (VIDEO0_BASE+0x0034)
+#define VIDEO0_FB_2                                 (VIDEO0_BASE+0x0038)
+#define VIDEO0_FB_RIGHT_0                           (VIDEO0_BASE+0x003c)
+#define VIDEO0_FB_RIGHT_1                           (VIDEO0_BASE+0x0040)
+#define VIDEO0_FB_RIGHT_2                           (VIDEO0_BASE+0x0044)
+#define VIDEO0_STR                                  (VIDEO0_BASE+0x0048)
+#define VIDEO0_CRITICAL_CFG                         (VIDEO0_BASE+0x004c)
+#define VIDEO0_REMAPPING                            (VIDEO0_BASE+0x0050)
+#define VIDEO0_COOR                                 (VIDEO0_BASE+0x0054)
+#define VIDEO0_ALPHA_CFG                            (VIDEO0_BASE+0x0058)
+#define VIDEO0_CKMAX                                (VIDEO0_BASE+0x005c)
+#define VIDEO0_CKMIN                                (VIDEO0_BASE+0x0060)
+#define VIDEO0_BLEND                                (VIDEO0_BASE+0x0064)
+
+//--------------Bits Location-------------------------------------//
+//--------------VIDEO1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define VIDEO1_BASE                                 0xB02E0500
+#define VIDEO1_CFG                                  (VIDEO1_BASE+0x0000)
+#define VIDEO1_ISIZE                                (VIDEO1_BASE+0x0004)
+#define VIDEO1_OSIZE                                (VIDEO1_BASE+0x0008)
+#define VIDEO1_SR                                   (VIDEO1_BASE+0x000c)
+#define VIDEO1_SCOEF0                               (VIDEO1_BASE+0x0010)
+#define VIDEO1_SCOEF1                               (VIDEO1_BASE+0x0014)
+#define VIDEO1_SCOEF2                               (VIDEO1_BASE+0x0018)
+#define VIDEO1_SCOEF3                               (VIDEO1_BASE+0x001c)
+#define VIDEO1_SCOEF4                               (VIDEO1_BASE+0x0020)
+#define VIDEO1_SCOEF5                               (VIDEO1_BASE+0x0024)
+#define VIDEO1_SCOEF6                               (VIDEO1_BASE+0x0028)
+#define VIDEO1_SCOEF7                               (VIDEO1_BASE+0x002c )
+#define VIDEO1_FB_0                                 (VIDEO1_BASE+0x0030)
+#define VIDEO1_FB_1                                 (VIDEO1_BASE+0x0034)
+#define VIDEO1_FB_2                                 (VIDEO1_BASE+0x0038)
+#define VIDEO1_FB_RIGHT_0                           (VIDEO1_BASE+0x003c)
+#define VIDEO1_FB_RIGHT_1                           (VIDEO1_BASE+0x0040)
+#define VIDEO1_FB_RIGHT_2                           (VIDEO1_BASE+0x0044)
+#define VIDEO1_STR                                  (VIDEO1_BASE+0x0048)
+#define VIDEO1_CRITICAL_CFG                         (VIDEO1_BASE+0x004c)
+#define VIDEO1_REMAPPING                            (VIDEO1_BASE+0x0050)
+#define VIDEO1_COOR                                 (VIDEO1_BASE+0x0054)
+#define VIDEO1_ALPHA_CFG                            (VIDEO1_BASE+0x0058)
+#define VIDEO1_CKMAX                                (VIDEO1_BASE+0x005c)
+#define VIDEO1_CKMIN                                (VIDEO1_BASE+0x0060)
+#define VIDEO1_BLEND                                (VIDEO1_BASE+0x0064)
+
+//--------------Bits Location-------------------------------------//
+//--------------VIDEO2--------------------------------------//
+//--------------Register Address----------------------------------//
+#define VIDEO2_BASE                                 0xB02E0600
+#define VIDEO2_CFG                                  (VIDEO2_BASE+0x0000)
+#define VIDEO2_ISIZE                                (VIDEO2_BASE+0x0004)
+#define VIDEO2_OSIZE                                (VIDEO2_BASE+0x0008)
+#define VIDEO2_SR                                   (VIDEO2_BASE+0x000c)
+#define VIDEO2_SCOEF0                               (VIDEO2_BASE+0x0010)
+#define VIDEO2_SCOEF1                               (VIDEO2_BASE+0x0014)
+#define VIDEO2_SCOEF2                               (VIDEO2_BASE+0x0018)
+#define VIDEO2_SCOEF3                               (VIDEO2_BASE+0x001c)
+#define VIDEO2_SCOEF4                               (VIDEO2_BASE+0x0020)
+#define VIDEO2_SCOEF5                               (VIDEO2_BASE+0x0024)
+#define VIDEO2_SCOEF6                               (VIDEO2_BASE+0x0028)
+#define VIDEO2_SCOEF7                               (VIDEO2_BASE+0x002c )
+#define VIDEO2_FB_0                                 (VIDEO2_BASE+0x0030)
+#define VIDEO2_FB_1                                 (VIDEO2_BASE+0x0034)
+#define VIDEO2_FB_2                                 (VIDEO2_BASE+0x0038)
+#define VIDEO2_FB_RIGHT_0                           (VIDEO2_BASE+0x003c)
+#define VIDEO2_FB_RIGHT_1                           (VIDEO2_BASE+0x0040)
+#define VIDEO2_FB_RIGHT_2                           (VIDEO2_BASE+0x0044)
+#define VIDEO2_STR                                  (VIDEO2_BASE+0x0048)
+#define VIDEO2_CRITICAL_CFG                         (VIDEO2_BASE+0x004c)
+#define VIDEO2_REMAPPING                            (VIDEO2_BASE+0x0050)
+#define VIDEO2_COOR                                 (VIDEO2_BASE+0x0054)
+#define VIDEO2_ALPHA_CFG                            (VIDEO2_BASE+0x0058)
+#define VIDEO2_CKMAX                                (VIDEO2_BASE+0x005c)
+#define VIDEO2_CKMIN                                (VIDEO2_BASE+0x0060)
+#define VIDEO2_BLEND                                (VIDEO2_BASE+0x0064)
+
+//--------------Bits Location-------------------------------------//
+//--------------VIDEO3--------------------------------------//
+//--------------Register Address----------------------------------//
+#define VIDEO3_BASE                                 0xB02E0700
+#define VIDEO3_CFG                                  (VIDEO3_BASE+0x0000)
+#define VIDEO3_ISIZE                                (VIDEO3_BASE+0x0004)
+#define VIDEO3_OSIZE                                (VIDEO3_BASE+0x0008)
+#define VIDEO3_SR                                   (VIDEO3_BASE+0x000c)
+#define VIDEO3_SCOEF0                               (VIDEO3_BASE+0x0010)
+#define VIDEO3_SCOEF1                               (VIDEO3_BASE+0x0014)
+#define VIDEO3_SCOEF2                               (VIDEO3_BASE+0x0018)
+#define VIDEO3_SCOEF3                               (VIDEO3_BASE+0x001c)
+#define VIDEO3_SCOEF4                               (VIDEO3_BASE+0x0020)
+#define VIDEO3_SCOEF5                               (VIDEO3_BASE+0x0024)
+#define VIDEO3_SCOEF6                               (VIDEO3_BASE+0x0028)
+#define VIDEO3_SCOEF7                               (VIDEO3_BASE+0x002c )
+#define VIDEO3_FB_0                                 (VIDEO3_BASE+0x0030)
+#define VIDEO3_FB_1                                 (VIDEO3_BASE+0x0034)
+#define VIDEO3_FB_2                                 (VIDEO3_BASE+0x0038)
+#define VIDEO3_FB_RIGHT_0                           (VIDEO3_BASE+0x003c)
+#define VIDEO3_FB_RIGHT_1                           (VIDEO3_BASE+0x0040)
+#define VIDEO3_FB_RIGHT_2                           (VIDEO3_BASE+0x0044)
+#define VIDEO3_STR                                  (VIDEO3_BASE+0x0048)
+#define VIDEO3_CRITICAL_CFG                         (VIDEO3_BASE+0x004c)
+#define VIDEO3_REMAPPING                            (VIDEO3_BASE+0x0050)
+#define VIDEO3_COOR                                 (VIDEO3_BASE+0x0054)
+#define VIDEO3_ALPHA_CFG                            (VIDEO3_BASE+0x0058)
+#define VIDEO3_CKMAX                                (VIDEO3_BASE+0x005c)
+#define VIDEO3_CKMIN                                (VIDEO3_BASE+0x0060)
+#define VIDEO3_BLEND                                (VIDEO3_BASE+0x0064)
+
+//--------------Bits Location-------------------------------------//
+//--------------DMM--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DMM_BASE                                    0xB0290000
+#define DMM_SCH_CTRL                                (DMM_BASE+0x0000)
+#define DMM_TO_CPU_BISP                             (DMM_BASE+0x0004)
+#define DMM_TO_VDE                                  (DMM_BASE+0x0008)
+#define DMM_TO_ETHERNET_DE                          (DMM_BASE+0x000C)
+#define DMM_TO_DE_CRITICAL_USB2                     (DMM_BASE+0x0010)
+#define DMM_TO_USB3_VCE                             (DMM_BASE+0x0014)
+#define DMM_TO_GPU3D_DAP                            (DMM_BASE+0x0018)
+#define DMM_TO_DMA_DMA_CRITICAL                     (DMM_BASE+0x001C)
+#define DMM_INTERLEAVE_BASEADDR                     (DMM_BASE+0x0020)
+#define DMM_INTERLEAVE_FRAGMENT                     (DMM_BASE+0x0024)
+#define DMM_INTERLEAVE_CONFIG                       (DMM_BASE+0x0028)
+#define DMM_AXI_PRIORITY                            (DMM_BASE+0x002C)
+#define DMM_WATCH_ADDR                              (DMM_BASE+0x0030)
+#define DMM_WATCH_ADDR_MASK                         (DMM_BASE+0x0034)
+#define DMM_WATCH_DATA                              (DMM_BASE+0x0038)
+#define DMM_WATCH_DATA_MASK                         (DMM_BASE+0x003C)
+#define DMM_WATCH_CTRL                              (DMM_BASE+0x0040)
+#define DMM_MONITOR_CTRL                            (DMM_BASE+0x0044)
+#define DMM_PM_CTRL0                                (DMM_BASE+0x0048)
+#define DMM_PM_CTRL1                                (DMM_BASE+0x004c)
+#define DMM_PC0                                     (DMM_BASE+0x0050)
+#define DMM_PC1                                     (DMM_BASE+0x0054)
+#define DMM_PC2                                     (DMM_BASE+0x0058)
+#define DMM_PC3                                     (DMM_BASE+0x005c)
+#define DMM_DEBUG                                   (DMM_BASE+0x0060)
+
+//--------------Bits Location-------------------------------------//
+//--------------NAND--------------------------------------//
+//--------------Register Address----------------------------------//
+#define NAND_BASE                                   0xB0210000
+#define NAND_CTL                                    (NAND_BASE+0x0000)
+#define NAND_STATUS                                 (NAND_BASE+0X0004)
+#define NAND_CONFIG                                 (NAND_BASE+0X0008)
+#define NAND_BC                                     (NAND_BASE+0X000c)
+#define NAND_COLADDR                                (NAND_BASE+0X0010)
+#define NAND_ROWADDR0                               (NAND_BASE+0X0014)
+#define NAND_ROWADDR1                               (NAND_BASE+0X0018)
+#define NAND_CMD_FSM0                               (NAND_BASE+0X001c)
+#define NAND_CMD_FSM_CTL0                           (NAND_BASE+0X0020)
+#define NAND_CMD_FSM1                               (NAND_BASE+0x0024)
+#define NAND_CMD_FSM_CTL1                           (NAND_BASE+0X0028)
+#define NAND_CMD_FSM2                               (NAND_BASE+0x002c)
+#define NAND_CMD_FSM_CTL2                           (NAND_BASE+0X0030)
+#define NAND_ECCST0                                 (NAND_BASE+0x0034)
+#define NAND_ECCST1                                 (NAND_BASE+0x0038)
+#define NAND_ECCST2                                 (NAND_BASE+0X003c)
+#define NAND_ECCST3                                 (NAND_BASE+0X0040)
+#define NAND_UDATAC0                                (NAND_BASE+0X0044)
+#define NAND_UDATAC1                                (NAND_BASE+0X0048)
+#define NAND_UDATAC2                                (NAND_BASE+0X004c)
+#define NAND_UDATAC3                                (NAND_BASE+0X0050)
+#define NAND_FSM_START                              (NAND_BASE+0X0054)
+#define NAND_DATA_ENTRY                             (NAND_BASE+0x0080)
+#define NAND_DATA                                    NAND_DATA_ENTRY
+#define NAND_CTL_STATUS                             (NAND_BASE+0xa0)
+#define NAND_TIMING                                 (NAND_BASE+0Xa4)
+#define NAND_ANALOG_CTL                             (NAND_BASE+0xa8)
+#define NAND_CHCMD                                  (NAND_BASE+0xac)
+#define NAND_CHCMD_INTERVAL                         (NAND_BASE+0xb0)
+
+//--------------Bits Location-------------------------------------//
+//--------------SD0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define SD0_BASE                                    0xB0230000
+#define SD0_EN                                      (SD0_BASE+0x0000)
+#define SD0_CTL                                     (SD0_BASE+0x0004)
+#define SD0_STATE                                   (SD0_BASE+0x0008)
+#define SD0_CMD                                     (SD0_BASE+0x000C)
+#define SD0_ARG                                     (SD0_BASE+0x0010)
+#define SD0_RSPBUF0                                 (SD0_BASE+0x0014)
+#define SD0_RSPBUF1                                 (SD0_BASE+0x0018)
+#define SD0_RSPBUF2                                 (SD0_BASE+0x001C)
+#define SD0_RSPBUF3                                 (SD0_BASE+0x0020)
+#define SD0_RSPBUF4                                 (SD0_BASE+0x0024)
+#define SD0_DAT                                     (SD0_BASE+0x0028)
+#define SD0_BLK_SIZE                                (SD0_BASE+0x002C)
+#define SD0_BLK_NUM                                 (SD0_BASE+0x0030)
+#define SD0_BUF_SIZE                                (SD0_BASE+0x0034)
+
+//--------------Bits Location-------------------------------------//
+//--------------SD1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define SD1_BASE                                    0xB0234000
+#define SD1_EN                                      (SD1_BASE+0x0000)
+#define SD1_CTL                                     (SD1_BASE+0x0004)
+#define SD1_STATE                                   (SD1_BASE+0x0008)
+#define SD1_CMD                                     (SD1_BASE+0x000C)
+#define SD1_ARG                                     (SD1_BASE+0x0010)
+#define SD1_RSPBUF0                                 (SD1_BASE+0x0014)
+#define SD1_RSPBUF1                                 (SD1_BASE+0x0018)
+#define SD1_RSPBUF2                                 (SD1_BASE+0x001C)
+#define SD1_RSPBUF3                                 (SD1_BASE+0x0020)
+#define SD1_RSPBUF4                                 (SD1_BASE+0x0024)
+#define SD1_DAT                                     (SD1_BASE+0x0028)
+#define SD1_BLK_SIZE                                (SD1_BASE+0x002C)
+#define SD1_BLK_NUM                                 (SD1_BASE+0x0030)
+#define SD1_BUF_SIZE                                (SD1_BASE+0x0034)
+
+//--------------Bits Location-------------------------------------//
+//--------------SD2--------------------------------------//
+//--------------Register Address----------------------------------//
+#define SD2_BASE                                    0xB0238000
+#define SD2_EN                                      (SD2_BASE+0x0000)
+#define SD2_CTL                                     (SD2_BASE+0x0004)
+#define SD2_STATE                                   (SD2_BASE+0x0008)
+#define SD2_CMD                                     (SD2_BASE+0x000C)
+#define SD2_ARG                                     (SD2_BASE+0x0010)
+#define SD2_RSPBUF0                                 (SD2_BASE+0x0014)
+#define SD2_RSPBUF1                                 (SD2_BASE+0x0018)
+#define SD2_RSPBUF2                                 (SD2_BASE+0x001C)
+#define SD2_RSPBUF3                                 (SD2_BASE+0x0020)
+#define SD2_RSPBUF4                                 (SD2_BASE+0x0024)
+#define SD2_DAT                                     (SD2_BASE+0x0028)
+#define SD2_BLK_SIZE                                (SD2_BASE+0x002C)
+#define SD2_BLK_NUM                                 (SD2_BASE+0x0030)
+#define SD2_BUF_SIZE                                (SD2_BASE+0x0034)
+
+//--------------Bits Location-------------------------------------//
+//--------------SRAMI--------------------------------------//
+//--------------Register Address----------------------------------//
+#define SRAMI_BASE                                  0xB0240000
+#define SRAMI_CTL                                   (SRAMI_BASE+0x00)
+
+//--------------Bits Location-------------------------------------//
+//--------------SHARESRAM_CRTL--------------------------------------//
+//--------------Register Address----------------------------------//
+#define SHARESRAM_CRTL_BASE                         0xB0240000
+#define SHARESRAM_CTL                               (SHARESRAM_CRTL_BASE+0x04)
+
+//--------------Bits Location-------------------------------------//
+//--------------USB3--------------------------------------//
+//--------------Register Address----------------------------------//
+#define USB3_REGISTER_BASE                           0xB0400000
+#define USB3_CAPLENGTH                              (USB3_REGISTER_BASE+0x0000)
+#define USB3_HCSPARAMS1                             (USB3_REGISTER_BASE+0x0004)
+#define USB3_HCSPARAMS2                             (USB3_REGISTER_BASE+0x0008)
+#define USB3_HCSPARAMS3                             (USB3_REGISTER_BASE+0x000C)
+#define USB3_HCCPARAMS                              (USB3_REGISTER_BASE+0x0010)
+#define USB3_DBOFF                                  (USB3_REGISTER_BASE+0x0014)
+#define USB3_RTSOFF                                 (USB3_REGISTER_BASE+0x0018)
+#define USB3_USBCMD                                 (USB3_REGISTER_BASE+0x0020)
+#define USB3_USBSTS                                 (USB3_REGISTER_BASE+0x0024)
+#define USB3_PAGESIZE                               (USB3_REGISTER_BASE+0x0028)
+#define USB3_DNCTRL                                 (USB3_REGISTER_BASE+0x0034)
+#define USB3_CRCR_L                                 (USB3_REGISTER_BASE+0x0038)
+#define USB3_CRCR_H                                 (USB3_REGISTER_BASE+0x003C)
+#define USB3_DCBAAP_L                               (USB3_REGISTER_BASE+0x0050)
+#define USB3_DCBAAP_H                               (USB3_REGISTER_BASE+0x0054)
+#define USB3_CONFIG                                 (USB3_REGISTER_BASE+0x0058)
+#define USB3_PORT0_PORTSC                           (USB3_REGISTER_BASE+0x0420)
+#define USB3_PORT0_PORTPMSC                         (USB3_REGISTER_BASE+0x0424)
+#define USB3_PORT0_PORTLI                           (USB3_REGISTER_BASE+0x0428)
+#define USB3_PORT0_PORTHLPMC                        (USB3_REGISTER_BASE+0x042c)
+#define USB3_PORT1_PORTSC                           (USB3_REGISTER_BASE+0x0430)
+#define USB3_PORT1_PORTPMSC                         (USB3_REGISTER_BASE+0x0434)
+#define USB3_PORT1_PORTLI                           (USB3_REGISTER_BASE+0x0438)
+#define USB3_PORT1_PORTHLPMC                        (USB3_REGISTER_BASE+0x043c)
+#define USB3_PORT2_PORTSC                           (USB3_REGISTER_BASE+0x0440)
+#define USB3_PORT2_PORTPMSC                         (USB3_REGISTER_BASE+0x0444)
+#define USB3_PORT2_PORTLI                           (USB3_REGISTER_BASE+0x0448)
+#define USB3_PORT2_PORTHLPMC                        (USB3_REGISTER_BASE+0x044c)
+#define USB3_MFINDEX                                (USB3_REGISTER_BASE+0x0460)
+#define USB3_IMAN                                   (USB3_REGISTER_BASE+0x0480)
+#define USB3_IMOD                                   (USB3_REGISTER_BASE+0x0484)
+#define USB3_ERSTSZ                                 (USB3_REGISTER_BASE+0x0488)
+#define USB3_ERSTBA_L                               (USB3_REGISTER_BASE+0x0490)
+#define USB3_ERSTBA_H                               (USB3_REGISTER_BASE+0x0494)
+#define USB3_ERDP_L                                 (USB3_REGISTER_BASE+0x0498)
+#define USB3_ERDP_H                                 (USB3_REGISTER_BASE+0x049c)
+#define USB3_DB_HOST                                (USB3_REGISTER_BASE+0x04a0)
+#define USB3_DB_DEVICE1                             (USB3_REGISTER_BASE+0x04a4)
+#define USB3_DB_DEVICE2                             (USB3_REGISTER_BASE+0x04a8)
+#define USB3_DB_DEVICE3                             (USB3_REGISTER_BASE+0x04ac)
+#define USB3_DB_DEVICE4                             (USB3_REGISTER_BASE+0x04b0)
+#define USB3_DB_DEVICE5                             (USB3_REGISTER_BASE+0x04b4)
+#define USB3_DB_DEVICE6                             (USB3_REGISTER_BASE+0x04b8)
+#define USB3_DB_DEVICE7                             (USB3_REGISTER_BASE+0x04bc)
+#define USB3_DB_DEVICE8                             (USB3_REGISTER_BASE+0x04c0)
+#define USB3_DB_DEVICE9                             (USB3_REGISTER_BASE+0x04c4)
+#define USB3_DB_DEVICE10                            (USB3_REGISTER_BASE+0x04c8)
+#define USB3_DB_DEVICE11                            (USB3_REGISTER_BASE+0x04cc)
+#define USB3_DB_DEVICE12                            (USB3_REGISTER_BASE+0x04d0)
+#define USB3_DB_DEVICE13                            (USB3_REGISTER_BASE+0x04d4)
+#define USB3_DB_DEVICE14                            (USB3_REGISTER_BASE+0x04d8)
+#define USB3_DB_DEVICE15                            (USB3_REGISTER_BASE+0x04dc)
+#define USB3_DB_DEVICE16                            (USB3_REGISTER_BASE+0x04e0)
+#define USB3_DB_DEVICE17                            (USB3_REGISTER_BASE+0x04e4)
+#define USB3_DB_DEVICE18                            (USB3_REGISTER_BASE+0x04e8)
+#define USB3_DB_DEVICE19                            (USB3_REGISTER_BASE+0x04ec)
+#define USB3_DB_DEVICE20                            (USB3_REGISTER_BASE+0x04f0)
+#define USB3_DB_DEVICE21                            (USB3_REGISTER_BASE+0x04f4)
+#define USB3_DB_DEVICE22                            (USB3_REGISTER_BASE+0x04f8)
+#define USB3_DB_DEVICE23                            (USB3_REGISTER_BASE+0x04fc)
+#define USB3_DB_DEVICE24                            (USB3_REGISTER_BASE+0x0500)
+#define USB3_DB_DEVICE25                            (USB3_REGISTER_BASE+0x0504)
+#define USB3_DB_DEVICE26                            (USB3_REGISTER_BASE+0x0508)
+#define USB3_DB_DEVICE27                            (USB3_REGISTER_BASE+0x050c)
+#define USB3_DB_DEVICE28                            (USB3_REGISTER_BASE+0x0510)
+#define USB3_DB_DEVICE29                            (USB3_REGISTER_BASE+0x0514)
+#define USB3_DB_DEVICE30                            (USB3_REGISTER_BASE+0x0518)
+#define USB3_DB_DEVICE31                            (USB3_REGISTER_BASE+0x051c)
+#define USB3_USBLEGSUP                              (USB3_REGISTER_BASE+0x08a0)
+#define USB3_USBLEGCTLSTS                           (USB3_REGISTER_BASE+0x08a4)
+#define USB3_SUPTPRT2_DW0                           (USB3_REGISTER_BASE+0x08b0)
+#define USB3_SUPTPRT2_DW1                           (USB3_REGISTER_BASE+0x08b4)
+#define USB3_SUPTPRT2_DW2                           (USB3_REGISTER_BASE+0x08b8)
+#define USB3_SUPTPRT2_DW3                           (USB3_REGISTER_BASE+0x08bc)
+#define USB3_SUPTPRT3_DW0                           (USB3_REGISTER_BASE+0x08c0)
+#define USB3_SUPTPRT3_DW1                           (USB3_REGISTER_BASE+0x08c4)
+#define USB3_SUPTPRT3_DW2                           (USB3_REGISTER_BASE+0x08c8)
+#define USB3_SUPTPRT3_DW3                           (USB3_REGISTER_BASE+0x08cc)
+#define USB3_DCID                                   (USB3_REGISTER_BASE+0x08d0)
+#define USB3_DCDB                                   (USB3_REGISTER_BASE+0x08d4)
+#define USB3_DCERSTSZ                               (USB3_REGISTER_BASE+0x08d8)
+#define USB3_DCERSTBA_LO                            (USB3_REGISTER_BASE+0x08e0)
+#define USB3_DCERSTBA_HI                            (USB3_REGISTER_BASE+0x08e4)
+#define USB3_DCERDP_LO                              (USB3_REGISTER_BASE+0x08e8)
+#define USB3_DCERDP_HI                              (USB3_REGISTER_BASE+0x08ec)
+#define USB3_DCCTRL                                 (USB3_REGISTER_BASE+0x08f0)
+#define USB3_DCSTAT                                 (USB3_REGISTER_BASE+0x08f4)
+#define USB3_DCPORTSC                               (USB3_REGISTER_BASE+0x08f8)
+#define USB3_DCECP_LO                               (USB3_REGISTER_BASE+0x0900)
+#define USB3_DCECP_HI                               (USB3_REGISTER_BASE+0x0904)
+#define USB3_DCDDI1                                 (USB3_REGISTER_BASE+0x0908)
+#define USB3_DCDDI2                                 (USB3_REGISTER_BASE+0x090c)
+#define USB3_GSBUSCFG0                              (USB3_REGISTER_BASE+0xC100)
+#define USB3_GSBUSCFG1                              (USB3_REGISTER_BASE+0xC104)
+#define USB3_GTXTHRCFG                              (USB3_REGISTER_BASE+0xC108)
+#define USB3_GRXTHRCFG                              (USB3_REGISTER_BASE+0xC10C)
+#define USB3_GCTL_OWL                               (USB3_REGISTER_BASE+0xC110)
+#define USB3_GSTS                                   (USB3_REGISTER_BASE+0xC118)
+#define USB3_GSNPSID                                (USB3_REGISTER_BASE+0xC120)
+#define USB3_GGPIO                                  (USB3_REGISTER_BASE+0xC124)
+#define USB3_GUID                                   (USB3_REGISTER_BASE+0xC128)
+#define USB3_GUCTL                                  (USB3_REGISTER_BASE+0xC12C)
+#define USB3_GBUSERRADDRLO                          (USB3_REGISTER_BASE+0xC130)
+#define USB3_GBUSERRADDRHI                          (USB3_REGISTER_BASE+0xC134)
+#define USB3_GPRTBIMAPL                             (USB3_REGISTER_BASE+0xC138)
+#define USB3_GPRTBIMAPH                             (USB3_REGISTER_BASE+0xC13C)
+#define USB3_GHWPARAMS0                             (USB3_REGISTER_BASE+0xC140)
+#define USB3_GHWPARAMS1                             (USB3_REGISTER_BASE+0xC144)
+#define USB3_GHWPARAMS2                             (USB3_REGISTER_BASE+0xC148)
+#define USB3_GHWPARAMS3                             (USB3_REGISTER_BASE+0xC14C)
+#define USB3_GHWPARAMS4                             (USB3_REGISTER_BASE+0xC150)
+#define USB3_GHWPARAMS5                             (USB3_REGISTER_BASE+0xC154)
+#define USB3_GHWPARAMS6                             (USB3_REGISTER_BASE+0xC158)
+#define USB3_GHWPARAMS7                             (USB3_REGISTER_BASE+0xC15C)
+#define USB3_GBDGFIFOSPACE                          (USB3_REGISTER_BASE+0xC160)
+#define USB3_GDBGLTSSM                              (USB3_REGISTER_BASE+0xC164)
+#define USB3_GDBGLNMCC                              (USB3_REGISTER_BASE+0xC168)
+#define USB3_GDBGBMU                                (USB3_REGISTER_BASE+0xC16C)
+#define USB3_GDBGLSPMUX                             (USB3_REGISTER_BASE+0xC170)
+#define USB3_GDBGLSP                                (USB3_REGISTER_BASE+0xC174)
+#define USB3_GDBGEPINFO0                            (USB3_REGISTER_BASE+0xC178)
+#define USB3_GDBGEPINFO1                            (USB3_REGISTER_BASE+0xC17C)
+#define USB3_GPRTBIMAPLO_HS                         (USB3_REGISTER_BASE+0xC180)
+#define USB3_GPRTBIMAPHI_HS                         (USB3_REGISTER_BASE+0xC184)
+#define USB3_GPRTBIMAPLO_FS                         (USB3_REGISTER_BASE+0xC188)
+#define USB3_GPRTBIMAPHI_FS                         (USB3_REGISTER_BASE+0xC18C)
+#define USB3_GUSB2CFG0                              (USB3_REGISTER_BASE+0xC200)
+#define USB3_GUSB2CFG1                              (USB3_REGISTER_BASE+0xC204)
+#define USB3_GUSB2I2CCTL                            (USB3_REGISTER_BASE+0xC240)
+#define USB3_GUSB2PHYACC0                           (USB3_REGISTER_BASE+0xC280)
+#define USB3_GUSB2PHYACC1                           (USB3_REGISTER_BASE+0xC284)
+#define USB3_GUSB3PIPECTL                           (USB3_REGISTER_BASE+0xC2C0)
+#define USB3_GTXFIFOSIZ0                            (USB3_REGISTER_BASE+0xC300)
+#define USB3_GTXFIFOSIZ1                            (USB3_REGISTER_BASE+0xC304)
+#define USB3_GTXFIFOSIZ2                            (USB3_REGISTER_BASE+0xC308)
+#define USB3_GTXFIFOSIZ3                            (USB3_REGISTER_BASE+0xC30C)
+#define USB3_GTXFIFOSIZ4                            (USB3_REGISTER_BASE+0xC310)
+#define USB3_GRXFIFOSIZ0                            (USB3_REGISTER_BASE+0xC380)
+#define USB3_GRXFIFOSIZ1                            (USB3_REGISTER_BASE+0xC384)
+#define USB3_GRXFIFOSIZ2                            (USB3_REGISTER_BASE+0xC388)
+#define USB3_GRXFIFOSIZ3                            (USB3_REGISTER_BASE+0xC38C)
+#define USB3_GRXFIFOSIZ4                            (USB3_REGISTER_BASE+0xC390)
+#define USB3_GEVETADR0                              (USB3_REGISTER_BASE+0xC400)
+#define USB3_GEVNTSIZ0                              (USB3_REGISTER_BASE+0xC408)
+#define USB3_GEVNTCOUNT0                            (USB3_REGISTER_BASE+0xC40C)
+#define USB3_DCFG                                   (USB3_REGISTER_BASE+0xC700)
+#define USB3_DCTL                                   (USB3_REGISTER_BASE+0xC704)
+#define USB3_DEVTEN                                 (USB3_REGISTER_BASE+0xC708)
+#define USB3_DSTS                                   (USB3_REGISTER_BASE+0xC70C)
+#define USB3_DGCMDPAR                               (USB3_REGISTER_BASE+0xC710)
+#define USB3_DGCMD                                  (USB3_REGISTER_BASE+0xC714)
+#define USB3_DALEPENA                               (USB3_REGISTER_BASE+0xC720)
+#define USB3_DEPCMDPAR2_0                           (USB3_REGISTER_BASE+0xC800)
+#define USB3_DEPCMDPAR1_0                           (USB3_REGISTER_BASE+0xC804)
+#define USB3_DEPCMDPAR0_0                           (USB3_REGISTER_BASE+0xC808)
+#define USB3_DEPCMD_0                               (USB3_REGISTER_BASE+0xC80C)
+#define USB3_DEPCMDPAR2_1                           (USB3_REGISTER_BASE+0xC810)
+#define USB3_DEPCMDPAR1_1                           (USB3_REGISTER_BASE+0xC814)
+#define USB3_DEPCMDPAR0_1                           (USB3_REGISTER_BASE+0xC818)
+#define USB3_DEPCMD_1                               (USB3_REGISTER_BASE+0xC81C)
+#define USB3_DEPCMDPAR2_2                           (USB3_REGISTER_BASE+0xC820)
+#define USB3_DEPCMDPAR1_2                           (USB3_REGISTER_BASE+0xC824)
+#define USB3_DEPCMDPAR0_2                           (USB3_REGISTER_BASE+0xC828)
+#define USB3_DEPCMD_2                               (USB3_REGISTER_BASE+0xC82C)
+#define USB3_DEPCMDPAR2_3                           (USB3_REGISTER_BASE+0xC830)
+#define USB3_DEPCMDPAR1_3                           (USB3_REGISTER_BASE+0xC834)
+#define USB3_DEPCMDPAR0_3                           (USB3_REGISTER_BASE+0xC838)
+#define USB3_DEPCMD_3                               (USB3_REGISTER_BASE+0xC83C)
+#define USB3_DEPCMDPAR2_4                           (USB3_REGISTER_BASE+0xC840)
+#define USB3_DEPCMDPAR1_4                           (USB3_REGISTER_BASE+0xC844)
+#define USB3_DEPCMDPAR0_4                           (USB3_REGISTER_BASE+0xC848)
+#define USB3_DEPCMD_4                               (USB3_REGISTER_BASE+0xC84C)
+#define USB3_DEPCMDPAR2_5                           (USB3_REGISTER_BASE+0xC850)
+#define USB3_DEPCMDPAR1_5                           (USB3_REGISTER_BASE+0xC854)
+#define USB3_DEPCMDPAR0_5                           (USB3_REGISTER_BASE+0xC858)
+#define USB3_DEPCMD_5                               (USB3_REGISTER_BASE+0xC85C)
+#define USB3_DEPCMDPAR2_6                           (USB3_REGISTER_BASE+0xC860)
+#define USB3_DEPCMDPAR1_6                           (USB3_REGISTER_BASE+0xC864)
+#define USB3_DEPCMDPAR0_6                           (USB3_REGISTER_BASE+0xC868)
+#define USB3_DEPCMD_6                               (USB3_REGISTER_BASE+0xC86C)
+#define USB3_DEPCMDPAR2_7                           (USB3_REGISTER_BASE+0xC870)
+#define USB3_DEPCMDPAR1_7                           (USB3_REGISTER_BASE+0xC874)
+#define USB3_DEPCMDPAR0_7                           (USB3_REGISTER_BASE+0xC878)
+#define USB3_DEPCMD_7                               (USB3_REGISTER_BASE+0xC87C)
+#define USB3_DEPCMDPAR2_8                           (USB3_REGISTER_BASE+0xC880)
+#define USB3_DEPCMDPAR1_8                           (USB3_REGISTER_BASE+0xC884)
+#define USB3_DEPCMDPAR0_8                           (USB3_REGISTER_BASE+0xC888)
+#define USB3_DEPCMD_8                               (USB3_REGISTER_BASE+0xC88C)
+#define USB3_DEPCMDPAR2_9                           (USB3_REGISTER_BASE+0xC890)
+#define USB3_DEPCMDPAR1_9                           (USB3_REGISTER_BASE+0xC894)
+#define USB3_DEPCMDPAR0_9                           (USB3_REGISTER_BASE+0xC898)
+#define USB3_DEPCMD_9                               (USB3_REGISTER_BASE+0xC89C)
+#define USB3_OCFG                                   (USB3_REGISTER_BASE+0xCC00)
+#define USB3_OCTL                                   (USB3_REGISTER_BASE+0xCC04)
+#define USB3_OEVEN                                  (USB3_REGISTER_BASE+0xCC08)
+#define USB3_OSTS                                   (USB3_REGISTER_BASE+0xCC0C)
+#define USB3_CDR_KIKD                               (USB3_REGISTER_BASE+0xCD00)
+#define USB3_CDR_KP1                                (USB3_REGISTER_BASE+0xCD04)
+#define USB3_TIMER_INIT                             (USB3_REGISTER_BASE+0xCD08)
+#define USB3_CDR_CONTROL                            (USB3_REGISTER_BASE+0xCD0C)
+#define USB3_RX_OFFSET_PS                           (USB3_REGISTER_BASE+0xCD10)
+#define USB3_EQ_CONTROL                             (USB3_REGISTER_BASE+0xCD14)
+#define USB3_RX_OOBS_SSC0                           (USB3_REGISTER_BASE+0xCD18)
+#define USB3_CMU_SSC1                               (USB3_REGISTER_BASE+0xCD1C)
+#define USB3_CMU_DEBUG_LDO                          (USB3_REGISTER_BASE+0xCD20)
+#define USB3_TX_AMP_DEBUG                           (USB3_REGISTER_BASE+0xCD24)
+#define USB3_Z0                                     (USB3_REGISTER_BASE+0xCD28)
+#define USB3_DMR_BACR                               (USB3_REGISTER_BASE+0xCD2C)
+#define USB3_IER_BCSR                               (USB3_REGISTER_BASE+0xCD30)
+#define USB3_BPR                                    (USB3_REGISTER_BASE+0xCD34)
+#define USB3_BFNR                                   (USB3_REGISTER_BASE+0xCD38)
+#define USB3_BENR_REV                               (USB3_REGISTER_BASE+0xCD3C)
+#define USB3_FLD                                    (USB3_REGISTER_BASE+0xCD40)
+#define USB3_CMU_PLL2_BISTDEBUG                     (USB3_REGISTER_BASE+0xCD44)
+#define USB3_USB2_P0_VDCTRL                         (USB3_REGISTER_BASE+0xCD48)
+#define USB3_BACKDOOR                               (USB3_REGISTER_BASE+0xCD4C)
+#define USB3_EXT_CTL                                (USB3_REGISTER_BASE+0xCD50)
+#define USB3_EFUSE_CTR                              (USB3_REGISTER_BASE+0xCD54)
+#define USB3_USB2_P1_VDCTRL                         (USB3_REGISTER_BASE+0xCD58)
+
+//--------------Bits Location-------------------------------------//
+//--------------USB2--------------------------------------//
+//--------------Register Address----------------------------------//
+#define USB2_BASE                                   0xB02B8000
+#define USB2_OTGIRQ                                 (USB2_BASE+0x01BC)
+#define USB2_OTGSTATE                               (USB2_BASE+0x01BD)
+#define USB2_OTGCTRL                                (USB2_BASE+0x01BE)
+#define USB2_OTGSTATUS                              (USB2_BASE+0x01BF)
+#define USB2_OTGIEN                                 (USB2_BASE+0x01C0)
+#define USB2_TAAIDLBDIS                             (USB2_BASE+0x01C1)
+#define USB2_TAWAITBCON                             (USB2_BASE+0x01C2)
+#define USB2_TBVBUSPLS                              (USB2_BASE+0x01C3)
+#define USB2_TBVBUSDISPLS                           (USB2_BASE+0x01C7)
+#define USB2_HCEP0CTRL                              (USB2_BASE+0x00C0)
+#define USB2_HCOUT1CTRL                             (USB2_BASE+0x00C4)
+#define USB2_HCOUT2CTRL                             (USB2_BASE+0x00C8)
+#define USB2_HCOUT3CTRL                             (USB2_BASE+0x00CC)
+#define USB2_HCOUT4CTRL                             (USB2_BASE+0x00D0)
+#define USB2_HCOUT5CTRL                             (USB2_BASE+0x00D4)
+#define USB2_HCOUT0ERR                              (USB2_BASE+0x00C1)
+#define USB2_HCOUT1ERR                              (USB2_BASE+0x00C5)
+#define USB2_HCOUT2ERR                              (USB2_BASE+0x00C9)
+#define USB2_HCOUT3ERR                              (USB2_BASE+0x00CD)
+#define USB2_HCOUT4ERR                              (USB2_BASE+0x00D1)
+#define USB2_HCOUT5ERR                              (USB2_BASE+0x00D5)
+#define USB2_HCIN1CTRL                              (USB2_BASE+0x00C6)
+#define USB2_HCIN2CTRL                              (USB2_BASE+0x00CA)
+#define USB2_HCIN3CTRL                              (USB2_BASE+0x00CE)
+#define USB2_HCIN4CTRL                              (USB2_BASE+0x00D2)
+#define USB2_HCIN5CTRL                              (USB2_BASE+0x00D6)
+#define USB2_HCIN0ERR                               (USB2_BASE+0x00C3)
+#define USB2_HCIN1ERR                               (USB2_BASE+0x00C7)
+#define USB2_HCIN2ERR                               (USB2_BASE+0x00CB)
+#define USB2_HCIN3ERR                               (USB2_BASE+0x00CF)
+#define USB2_HCIN4ERR                               (USB2_BASE+0x00D3)
+#define USB2_HCIN5ERR                               (USB2_BASE+0x00D7)
+#define USB2_HCPORTCTRL                             (USB2_BASE+0x01AB)
+#define USB2_HCFRMNRL                               (USB2_BASE+0x01AC)
+#define USB2_HCFRMNRH                               (USB2_BASE+0x01AD)
+#define USB2_HCFRMREMAINL                           (USB2_BASE+0x01AE)
+#define USB2_HCFRMREMAINH                           (USB2_BASE+0x01AF)
+#define USB2_HCINXERRIRQ                            (USB2_BASE+0x01B4)
+#define USB2_HCOUTXERRIRQ                           (USB2_BASE+0x01B6)
+#define USB2_HCINXERRIEN                            (USB2_BASE+0x01B8)
+#define USB2_HCOUTXERRIEN                           (USB2_BASE+0x01BA)
+#define USB2_HCIN0MAXPCK                            (USB2_BASE+0x01E0)
+#define USB2_HCIN1MAXPCKL                           (USB2_BASE+0x01E2)
+#define USB2_HCIN2MAXPCKL                           (USB2_BASE+0x01E4)
+#define USB2_HCIN3MAXPCKL                           (USB2_BASE+0x01E6)
+#define USB2_HCIN4MAXPCKL                           (USB2_BASE+0x01E8)
+#define USB2_HCIN5MAXPCKL                           (USB2_BASE+0x01EA)
+#define USB2_HCIN1MAXPCKH                           (USB2_BASE+0x01E3)
+#define USB2_HCIN2MAXPCKH                           (USB2_BASE+0x01E5)
+#define USB2_HCIN3MAXPCKH                           (USB2_BASE+0x01E7)
+#define USB2_HCIN4MAXPCKH                           (USB2_BASE+0x01E9)
+#define USB2_HCIN5MAXPCKH                           (USB2_BASE+0x01EB)
+#define USB2_HCOUT1MAXPCKL                          (USB2_BASE+0x03E2)
+#define USB2_HCOUT2MAXPCKL                          (USB2_BASE+0x03E4)
+#define USB2_HCOUT3MAXPCKL                          (USB2_BASE+0x03E6)
+#define USB2_HCOUT4MAXPCKL                          (USB2_BASE+0x03E8)
+#define USB2_HCOUT5MAXPCKL                          (USB2_BASE+0x03EA)
+#define USB2_HCOUT1MAXPCKH                          (USB2_BASE+0x03E3)
+#define USB2_HCOUT2MAXPCKH                          (USB2_BASE+0x03E5)
+#define USB2_HCOUT3MAXPCKH                          (USB2_BASE+0x03E7)
+#define USB2_HCOUT4MAXPCKH                          (USB2_BASE+0x03E9)
+#define USB2_HCOUT5MAXPCKH                          (USB2_BASE+0x03EB)
+#define USB2_OUT0BC                                 (USB2_BASE+0x0000)
+#define USB2_IN0BC                                  (USB2_BASE+0x0001)
+#define USB2_EP0CS                                  (USB2_BASE+0x0002)
+#define USB2_OUT1BCL                                (USB2_BASE+0x0008)
+#define USB2_OUT2BCL                                (USB2_BASE+0x0010)
+#define USB2_OUT3BCL                                (USB2_BASE+0x0018)
+#define USB2_OUT4BCL                                (USB2_BASE+0x0020)
+#define USB2_OUT5BCL                                (USB2_BASE+0x0028)
+#define USB2_OUT1BCH                                (USB2_BASE+0x0009)
+#define USB2_OUT2BCH                                (USB2_BASE+0x0011)
+#define USB2_OUT3BCH                                (USB2_BASE+0x0019)
+#define USB2_OUT4BCH                                (USB2_BASE+0x0021)
+#define USB2_OUT5BCH                                (USB2_BASE+0x0029)
+#define USB2_OUT1CS                                 (USB2_BASE+0x000B)
+#define USB2_OUT2CS                                 (USB2_BASE+0x0013)
+#define USB2_OUT3CS                                 (USB2_BASE+0x001B)
+#define USB2_OUT4CS                                 (USB2_BASE+0x0023)
+#define USB2_OUT5CS                                 (USB2_BASE+0x002B)
+#define USB2_OUT1CON                                (USB2_BASE+0x000A)
+#define USB2_OUT2CON                                (USB2_BASE+0x0012)
+#define USB2_OUT3CON                                (USB2_BASE+0x001A)
+#define USB2_OUT4CON                                (USB2_BASE+0x0022)
+#define USB2_OUT5CON                                (USB2_BASE+0x002A)
+#define USB2_IN1BCL                                 (USB2_BASE+0x000C)
+#define USB2_IN2BCL                                 (USB2_BASE+0x0014)
+#define USB2_IN3BCL                                 (USB2_BASE+0x001C)
+#define USB2_IN4BCL                                 (USB2_BASE+0x0024)
+#define USB2_IN5BCL                                 (USB2_BASE+0x002C)
+#define USB2_IN1BCH                                 (USB2_BASE+0x000D)
+#define USB2_IN2BCH                                 (USB2_BASE+0x0015)
+#define USB2_IN3BCH                                 (USB2_BASE+0x001D)
+#define USB2_IN4BCH                                 (USB2_BASE+0x0025)
+#define USB2_IN5BCH                                 (USB2_BASE+0x002D)
+#define USB2_IN1CS                                  (USB2_BASE+0x000F)
+#define USB2_IN2CS                                  (USB2_BASE+0x0017)
+#define USB2_IN3CS                                  (USB2_BASE+0x001F)
+#define USB2_IN4CS                                  (USB2_BASE+0x0027)
+#define USB2_IN5CS                                  (USB2_BASE+0x002F)
+#define USB2_IN1CON                                 (USB2_BASE+0x000E)
+#define USB2_IN2CON                                 (USB2_BASE+0x0016)
+#define USB2_IN3CON                                 (USB2_BASE+0x001E)
+#define USB2_IN4CON                                 (USB2_BASE+0x0026)
+#define USB2_IN5CON                                 (USB2_BASE+0x002E)
+#define USB2_FIFO1DATA                              (USB2_BASE+0x0084)
+#define USB2_FIFO2DATA                              (USB2_BASE+0x0088)
+#define USB2_FIFO3DATA                              (USB2_BASE+0x008C)
+#define USB2_FIFO4DATA                              (USB2_BASE+0x0090)
+#define USB2_FIFO5DATA                              (USB2_BASE+0x0094)
+#define USB2_EP0INDATA_W0                           (USB2_BASE+0X100)
+#define USB2_EP0INDATA_W1                           (USB2_BASE+0X104)
+#define USB2_EP0INDATA_W2                           (USB2_BASE+0X108)
+#define USB2_EP0INDATA_W3                           (USB2_BASE+0X10C)
+#define USB2_EP0INDATA_W4                           (USB2_BASE+0X110)
+#define USB2_EP0INDATA_W5                           (USB2_BASE+0X114)
+#define USB2_EP0INDATA_W6                           (USB2_BASE+0X118)
+#define USB2_EP0INDATA_W7                           (USB2_BASE+0X11C)
+#define USB2_EP0INDATA_W8                           (USB2_BASE+0X120)
+#define USB2_EP0INDATA_W9                           (USB2_BASE+0X124)
+#define USB2_EP0INDATA_W10                          (USB2_BASE+0X128)
+#define USB2_EP0INDATA_W11                          (USB2_BASE+0X12C)
+#define USB2_EP0INDATA_W12                          (USB2_BASE+0X130)
+#define USB2_EP0INDATA_W13                          (USB2_BASE+0X134)
+#define USB2_EP0INDATA_W14                          (USB2_BASE+0X138)
+#define USB2_EP0INDATA_W15                          (USB2_BASE+0X13C)
+#define USB2_EP0OUTDATA_W0                          (USB2_BASE+0X140)
+#define USB2_EP0OUTDATA_W1                          (USB2_BASE+0X144)
+#define USB2_EP0OUTDATA_W2                          (USB2_BASE+0X148)
+#define USB2_EP0OUTDATA_W3                          (USB2_BASE+0X14C)
+#define USB2_EP0OUTDATA_W4                          (USB2_BASE+0X150)
+#define USB2_EP0OUTDATA_W5                          (USB2_BASE+0X154)
+#define USB2_EP0OUTDATA_W6                          (USB2_BASE+0X158)
+#define USB2_EP0OUTDATA_W7                          (USB2_BASE+0X15C)
+#define USB2_EP0OUTDATA_W8                          (USB2_BASE+0X160)
+#define USB2_EP0OUTDATA_W9                          (USB2_BASE+0X164)
+#define USB2_EP0OUTDATA_W10                         (USB2_BASE+0X168)
+#define USB2_EP0OUTDATA_W11                         (USB2_BASE+0X16C)
+#define USB2_EP0OUTDATA_W12                         (USB2_BASE+0X170)
+#define USB2_EP0OUTDATA_W13                         (USB2_BASE+0X174)
+#define USB2_EP0OUTDATA_W14                         (USB2_BASE+0X178)
+#define USB2_EP0OUTDATA_W15                         (USB2_BASE+0X17C)
+#define USB2_SETUPDATA_W0                           (USB2_BASE+0X180)
+#define USB2_SETUPDATA_W1                           (USB2_BASE+0X184)
+#define USB2_INXIRQ                                 (USB2_BASE+0x0188)
+#define USB2_OUTXIRQ                                (USB2_BASE+0x018A)
+#define USB2_USBIRQ                                 (USB2_BASE+0x018C)
+#define USB2_OUTXPNGIRQ                             (USB2_BASE+0x018E)
+#define USB2_INXIEN                                 (USB2_BASE+0x0194)
+#define USB2_OUTXIEN                                (USB2_BASE+0x0196)
+#define USB2_USBIEN                                 (USB2_BASE+0x0198)
+#define USB2_OUTXPNGIEN                             (USB2_BASE+0x019A)
+#define USB2_INXTOKIRQ                              (USB2_BASE+0x0190)
+#define USB2_OUTXTOKIRQ                             (USB2_BASE+0x0191)
+#define USB2_INXTOKIEN                              (USB2_BASE+0x019C)
+#define USB2_OUTXTOKIEN                             (USB2_BASE+0x019D)
+#define USB2_IVECT                                  (USB2_BASE+0x01A0)
+#define USB2_ENDPRST                                (USB2_BASE+0x01A2)
+#define USB2_USBCS                                  (USB2_BASE+0x01A3)
+#define USB2_FRMNRL                                 (USB2_BASE+0x01A4)
+#define USB2_FRMNRH                                 (USB2_BASE+0x01A5)
+#define USB2_FNADDR                                 (USB2_BASE+0x01A6)
+#define USB2_CLKGATE                                (USB2_BASE+0x01A7)
+#define USB2_FIFOCTRL                               (USB2_BASE+0x01A8)
+#define USB2_OUT1STADDR                             (USB2_BASE+0x0304)
+#define USB2_OUT2STADDR                             (USB2_BASE+0x0308)
+#define USB2_OUT3STADDR                             (USB2_BASE+0x030C)
+#define USB2_OUT4STADDR                             (USB2_BASE+0x0310)
+#define USB2_OUT5STADDR                             (USB2_BASE+0x0314)
+#define USB2_IN1STADDR                              (USB2_BASE+0x0344)
+#define USB2_IN2STADDR                              (USB2_BASE+0x0348)
+#define USB2_IN3STADDR                              (USB2_BASE+0x034C)
+#define USB2_IN4STADDR                              (USB2_BASE+0x0350)
+#define USB2_IN5STADDR                              (USB2_BASE+0x0354)
+#define USB2_USBERESET                              (USB2_BASE+0x0400)
+#define USB2_TA_BCON_COUNT                          (USB2_BASE+0x0401)
+#define USB2_VBUSDBCTIMERL                          (USB2_BASE+0x0402)
+#define USB2_VBUSDBCTIMERH                          (USB2_BASE+0x0403)
+#define USB2_VDCTRL                                 (USB2_BASE+0x0404)
+#define USB2_VDSTATE                                (USB2_BASE+0x0405)
+#define USB2_BKDOOR                                 (USB2_BASE+0x0406)
+#define USB2_DBGMODE                                (USB2_BASE+0x0407)
+#define USB2_SRPCTRL                                (USB2_BASE+0x0408)
+#define USB2_USBEIRQ                                (USB2_BASE+0x040A)
+#define USB2_USBEIEN                                (USB2_BASE+0x040C)
+#define USB2_UDMAIRQ                                (USB2_BASE+0x040E)
+#define USB2_UDMAIEN                                (USB2_BASE+0x040F)
+#define USB2_OUTXSHORTPCKIRQ                        (USB2_BASE+0x0410)
+#define USB2_OUTXSHORTPCKIEN                        (USB2_BASE+0x0412)
+#define USB2_OUTXNAKCTRL                            (USB2_BASE+0x0414)
+#define USB2_HCINXSTART                             (USB2_BASE+0x0416)
+#define USB2_HCINXENDIRQ                            (USB2_BASE+0x0418)
+#define USB2_HCINXENDIEN                            (USB2_BASE+0x041A)
+#define USB2_HCIN1CNTL                              (USB2_BASE+0x0420)
+#define USB2_HCIN2CNTL                              (USB2_BASE+0x0422)
+#define USB2_HCIN3CNTL                              (USB2_BASE+0x0424)
+#define USB2_HCIN4CNTL                              (USB2_BASE+0x0426)
+#define USB2_HCIN5CNTL                              (USB2_BASE+0x0428)
+#define USB2_HCIN1CNTH                              (USB2_BASE+0x0421)
+#define USB2_HCIN2CNTH                              (USB2_BASE+0x0423)
+#define USB2_HCIN3CNTH                              (USB2_BASE+0x0425)
+#define USB2_HCIN4CNTH                              (USB2_BASE+0x0427)
+#define USB2_HCIN5CNTH                              (USB2_BASE+0x0429)
+#define USB2_INXBUFEMPTYIRQ                         (USB2_BASE+0x0440)
+#define USB2_INXBUFEMPTYIEN                         (USB2_BASE+0x0442)
+#define USB2_INXBUFEMPTYCTRL                        (USB2_BASE+0x0444)
+#define USB2_UDMA1MEMADDR                           (USB2_BASE+0x0450)
+#define USB2_UDMA1EPSEL                             (USB2_BASE+0x0454)
+#define USB2_UDMA1COM                               (USB2_BASE+0x0455)
+#define USB2_UDMA1CNTL                              (USB2_BASE+0x0458)
+#define USB2_UDMA1CNTM                              (USB2_BASE+0x0459)
+#define USB2_UDMA1CNTH                              (USB2_BASE+0x045A)
+#define USB2_UDMA1REML                              (USB2_BASE+0x045C)
+#define USB2_UDMA1REMM                              (USB2_BASE+0x045D)
+#define USB2_UDMA1REMH                              (USB2_BASE+0x045E)
+#define USB2_UDMA2MEMADDR                           (USB2_BASE+0x0460)
+#define USB2_UDMA2EPSEL                             (USB2_BASE+0x0464)
+#define USB2_UDMA2COM                               (USB2_BASE+0x0465)
+#define USB2_UDMA2CNTL                              (USB2_BASE+0x0468)
+#define USB2_UDMA2CNTM                              (USB2_BASE+0x0469)
+#define USB2_UDMA2CNTH                              (USB2_BASE+0x046A)
+#define USB2_UDMA2REML                              (USB2_BASE+0x046C)
+#define USB2_UDMA2REMM                              (USB2_BASE+0x046D)
+#define USB2_UDMA2REMH                              (USB2_BASE+0x046E)
+
+//--------------Bits Location-------------------------------------//
+//--------------Ethernet--------------------------------------//
+//--------------Register Address----------------------------------//
+#define ETHERNET_BASE                               0xB0310000
+#define MAC_CSR0                                    (ETHERNET_BASE+0x0000)
+#define MAC_CSR1                                    (ETHERNET_BASE+0x0008)
+#define MAC_CSR2                                    (ETHERNET_BASE+0x0010)
+#define MAC_CSR3                                    (ETHERNET_BASE+0x0018)
+#define MAC_CSR4                                    (ETHERNET_BASE+0x0020)
+#define MAC_CSR5                                    (ETHERNET_BASE+0x0028)
+#define MAC_CSR6                                    (ETHERNET_BASE+0x0030)
+#define MAC_CSR7                                    (ETHERNET_BASE+0x0038)
+#define MAC_CSR8                                    (ETHERNET_BASE+0x0040)
+#define MAC_CSR9                                    (ETHERNET_BASE+0x0048)
+#define MAC_CSR10                                   (ETHERNET_BASE+0x0050)
+#define MAC_CSR11                                   (ETHERNET_BASE+0x0058)
+#define MAC_CSR16                                   (ETHERNET_BASE+0x0080)
+#define MAC_CSR17                                   (ETHERNET_BASE+0x0088)
+#define MAC_CSR18                                   (ETHERNET_BASE+0x0090)
+#define MAC_CSR19                                   (ETHERNET_BASE+0x0098)
+#define MAC_CSR20                                   (ETHERNET_BASE+0x00A0)
+#define SC0                                         (ETHERNET_BASE+0X200)
+#define SC1                                         (ETHERNET_BASE+0X204)
+#define SC2                                         (ETHERNET_BASE+0X208)
+#define SC3                                         (ETHERNET_BASE+0X20C)
+#define SC4                                         (ETHERNET_BASE+0X210)
+#define SC5                                         (ETHERNET_BASE+0X214)
+#define SC6                                         (ETHERNET_BASE+0X218)
+#define SC7                                         (ETHERNET_BASE+0X21C)
+#define SC8                                         (ETHERNET_BASE+0X220)
+#define SC9                                         (ETHERNET_BASE+0X224)
+#define SC10                                        (ETHERNET_BASE+0X228)
+#define SC11                                        (ETHERNET_BASE+0X22C)
+#define SC12                                        (ETHERNET_BASE+0X230)
+#define SC13                                        (ETHERNET_BASE+0X234)
+#define SC14                                        (ETHERNET_BASE+0X238)
+#define SC15                                        (ETHERNET_BASE+0X23C)
+#define SC16                                        (ETHERNET_BASE+0X240)
+#define SC17                                        (ETHERNET_BASE+0X244)
+#define SC18                                        (ETHERNET_BASE+0X248)
+#define SC19                                        (ETHERNET_BASE+0X24C)
+#define SC20                                        (ETHERNET_BASE+0X250)
+#define SC21                                        (ETHERNET_BASE+0X254)
+#define SC22                                        (ETHERNET_BASE+0X258)
+#define SC23                                        (ETHERNET_BASE+0X25C)
+#define SC24                                        (ETHERNET_BASE+0X260)
+#define SC25                                        (ETHERNET_BASE+0X264)
+#define SC26                                        (ETHERNET_BASE+0X268)
+#define SC27                                        (ETHERNET_BASE+0X26C)
+#define SC28                                        (ETHERNET_BASE+0X270)
+#define SC29                                        (ETHERNET_BASE+0X274)
+#define SC30                                        (ETHERNET_BASE+0X278)
+#define SC31                                        (ETHERNET_BASE+0X27C)
+#define SC32                                        (ETHERNET_BASE+0X280)
+#define SC33                                        (ETHERNET_BASE+0X284)
+#define SC34                                        (ETHERNET_BASE+0X288)
+#define SC35                                        (ETHERNET_BASE+0X28C)
+#define SC36                                        (ETHERNET_BASE+0X290)
+#define SC37                                        (ETHERNET_BASE+0X294)
+#define SC38                                        (ETHERNET_BASE+0X298)
+#define SC39                                        (ETHERNET_BASE+0X29C)
+#define SC40                                        (ETHERNET_BASE+0X2A0)
+#define SC41                                        (ETHERNET_BASE+0X2A4)
+#define SC42                                        (ETHERNET_BASE+0X2A8)
+#define SC43                                        (ETHERNET_BASE+0X2AC)
+#define SC44                                        (ETHERNET_BASE+0X2B0)
+#define SC45                                        (ETHERNET_BASE+0X2B4)
+#define SC46                                        (ETHERNET_BASE+0X2B8)
+#define SC47                                        (ETHERNET_BASE+0X2BC)
+#define SC48                                        (ETHERNET_BASE+0X2C0)
+#define SC49                                        (ETHERNET_BASE+0X2C4)
+#define SC50                                        (ETHERNET_BASE+0X2C8)
+#define SC51                                        (ETHERNET_BASE+0X2CC)
+#define SC52                                        (ETHERNET_BASE+0X2D0)
+#define SC53                                        (ETHERNET_BASE+0X2D4)
+#define SC54                                        (ETHERNET_BASE+0X2D8)
+#define SC55                                        (ETHERNET_BASE+0X2DC)
+#define SC56                                        (ETHERNET_BASE+0X2E0)
+#define SC57                                        (ETHERNET_BASE+0X2E4)
+#define SC58                                        (ETHERNET_BASE+0X2E8)
+#define SC59                                        (ETHERNET_BASE+0X2EC)
+#define SC60                                        (ETHERNET_BASE+0X2F0)
+#define SC61                                        (ETHERNET_BASE+0X2F4)
+#define SC62                                        (ETHERNET_BASE+0X2F8)
+#define SC63                                        (ETHERNET_BASE+0X2FC)
+#define SC64                                        (ETHERNET_BASE+0X300)
+#define SC65                                        (ETHERNET_BASE+0X304)
+#define SC66                                        (ETHERNET_BASE+0X308)
+#define SC67                                        (ETHERNET_BASE+0X30C)
+#define SC68                                        (ETHERNET_BASE+0X310)
+#define SC69                                        (ETHERNET_BASE+0X314)
+#define SC70                                        (ETHERNET_BASE+0X318)
+#define SC71                                        (ETHERNET_BASE+0X31C)
+#define SC72                                        (ETHERNET_BASE+0X320)
+#define SC73                                        (ETHERNET_BASE+0X324)
+#define SC74                                        (ETHERNET_BASE+0X328)
+#define SC75                                        (ETHERNET_BASE+0X32C)
+#define SC76                                        (ETHERNET_BASE+0X330)
+#define SC77                                        (ETHERNET_BASE+0X334)
+#define SC78                                        (ETHERNET_BASE+0X338)
+#define SC79                                        (ETHERNET_BASE+0X33C)
+#define SC80                                        (ETHERNET_BASE+0X340)
+#define SC81                                        (ETHERNET_BASE+0X344)
+#define SC82                                        (ETHERNET_BASE+0X348)
+#define SC83                                        (ETHERNET_BASE+0X34C)
+#define SC84                                        (ETHERNET_BASE+0X350)
+#define SC85                                        (ETHERNET_BASE+0X354)
+#define SC86                                        (ETHERNET_BASE+0X358)
+#define SC87                                        (ETHERNET_BASE+0X35C)
+#define SC88                                        (ETHERNET_BASE+0X360)
+#define SC89                                        (ETHERNET_BASE+0X364)
+#define SC90                                        (ETHERNET_BASE+0X368)
+#define SC91                                        (ETHERNET_BASE+0X36C)
+#define SC92                                        (ETHERNET_BASE+0X370)
+#define SC93                                        (ETHERNET_BASE+0X374)
+#define SC94                                        (ETHERNET_BASE+0X378)
+#define SC95                                        (ETHERNET_BASE+0X37C)
+#define SC96                                        (ETHERNET_BASE+0X380)
+#define SC97                                        (ETHERNET_BASE+0X384)
+#define SC98                                        (ETHERNET_BASE+0X388)
+#define SC99                                        (ETHERNET_BASE+0X38C)
+#define SC100                                       (ETHERNET_BASE+0X390)
+#define SC101                                       (ETHERNET_BASE+0X394)
+#define SC102                                       (ETHERNET_BASE+0X398)
+#define SC103                                       (ETHERNET_BASE+0X39C)
+#define SC104                                       (ETHERNET_BASE+0X3A0)
+#define SC105                                       (ETHERNET_BASE+0X3A4)
+#define SC106                                       (ETHERNET_BASE+0X3A8)
+#define SC107                                       (ETHERNET_BASE+0X3AC)
+#define SC108                                       (ETHERNET_BASE+0X3B0)
+#define SC109                                       (ETHERNET_BASE+0X3B4)
+#define SC110                                       (ETHERNET_BASE+0X3B8)
+#define SC111                                       (ETHERNET_BASE+0X3BC)
+#define SC112                                       (ETHERNET_BASE+0X3C0)
+#define SC113                                       (ETHERNET_BASE+0X3C4)
+#define SC114                                       (ETHERNET_BASE+0X3C8)
+#define SC115                                       (ETHERNET_BASE+0X3CC)
+#define SC116                                       (ETHERNET_BASE+0X3D0)
+#define SC117                                       (ETHERNET_BASE+0X3D4)
+#define SC118                                       (ETHERNET_BASE+0X3D8)
+#define SC119                                       (ETHERNET_BASE+0X3DC)
+#define SC120                                       (ETHERNET_BASE+0X3E0)
+#define SC121                                       (ETHERNET_BASE+0X3E4)
+#define SC122                                       (ETHERNET_BASE+0X3E8)
+#define SC123                                       (ETHERNET_BASE+0X3EC)
+#define SC124                                       (ETHERNET_BASE+0X3F0)
+#define SC125                                       (ETHERNET_BASE+0X3F4)
+#define SC126                                       (ETHERNET_BASE+0X3F8)
+#define MAC_CTRL                                    (ETHERNET_BASE+0x00B0)
+
+//--------------Bits Location-------------------------------------//
+//--------------SPI0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define SPI0_BASE                                   0xB0200000
+#define SPI0_CTL                                    (SPI0_BASE+0x0000)
+#define SPI0_CLKDIV                                 (SPI0_BASE+0x0004)
+#define SPI0_STAT                                   (SPI0_BASE+0x0008)
+#define SPI0_RXDAT                                  (SPI0_BASE+0x000c)
+#define SPI0_TXDAT                                  (SPI0_BASE+0x0010)
+#define SPI0_TCNT                                   (SPI0_BASE+0x0014)
+#define SPI0_SEED                                   (SPI0_BASE+0x0018)
+#define SPI0_TXCR                                   (SPI0_BASE+0x001c)
+#define SPI0_RXCR                                   (SPI0_BASE+0x0020)
+
+//--------------Bits Location-------------------------------------//
+//--------------SPI1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define SPI1_BASE                                   0xB0204000
+#define SPI1_CTL                                    (SPI1_BASE+0x0000)
+#define SPI1_CLKDIV                                 (SPI1_BASE+0x0004)
+#define SPI1_STAT                                   (SPI1_BASE+0x0008)
+#define SPI1_RXDAT                                  (SPI1_BASE+0x000c)
+#define SPI1_TXDAT                                  (SPI1_BASE+0x0010)
+#define SPI1_TCNT                                   (SPI1_BASE+0x0014)
+#define SPI1_SEED                                   (SPI1_BASE+0x0018)
+#define SPI1_TXCR                                   (SPI1_BASE+0x001c)
+#define SPI1_RXCR                                   (SPI1_BASE+0x0020)
+
+//--------------Bits Location-------------------------------------//
+//--------------SPI2--------------------------------------//
+//--------------Register Address----------------------------------//
+#define SPI2_BASE                                   0xB0208000
+#define SPI2_CTL                                    (SPI2_BASE+0x0000)
+#define SPI2_CLKDIV                                 (SPI2_BASE+0x0004)
+#define SPI2_STAT                                   (SPI2_BASE+0x0008)
+#define SPI2_RXDAT                                  (SPI2_BASE+0x000c)
+#define SPI2_TXDAT                                  (SPI2_BASE+0x0010)
+#define SPI2_TCNT                                   (SPI2_BASE+0x0014)
+#define SPI2_SEED                                   (SPI2_BASE+0x0018)
+#define SPI2_TXCR                                   (SPI2_BASE+0x001c)
+#define SPI2_RXCR                                   (SPI2_BASE+0x0020)
+
+//--------------Bits Location-------------------------------------//
+//--------------SPI3--------------------------------------//
+//--------------Register Address----------------------------------//
+#define SPI3_BASE                                   0xB020C000
+#define SPI3_CTL                                    (SPI3_BASE+0x0000)
+#define SPI3_CLKDIV                                 (SPI3_BASE+0x0004)
+#define SPI3_STAT                                   (SPI3_BASE+0x0008)
+#define SPI3_RXDAT                                  (SPI3_BASE+0x000c)
+#define SPI3_TXDAT                                  (SPI3_BASE+0x0010)
+#define SPI3_TCNT                                   (SPI3_BASE+0x0014)
+#define SPI3_SEED                                   (SPI3_BASE+0x0018)
+#define SPI3_TXCR                                   (SPI3_BASE+0x001c)
+#define SPI3_RXCR                                   (SPI3_BASE+0x0020)
+
+//--------------Bits Location-------------------------------------//
+//--------------UART0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define UART0_BASE                                  0xB0120000
+#define UART0_CTL                                   (UART0_BASE+0x0000)
+#define UART0_RXDAT                                 (UART0_BASE+0x0004)
+#define UART0_TXDAT                                 (UART0_BASE+0x0008)
+#define UART0_STAT                                  (UART0_BASE+0x000c)
+
+//--------------Bits Location-------------------------------------//
+//--------------UART1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define UART1_BASE                                  0xB0122000
+#define UART1_CTL                                   (UART1_BASE+0x0000)
+#define UART1_RXDAT                                 (UART1_BASE+0x0004)
+#define UART1_TXDAT                                 (UART1_BASE+0x0008)
+#define UART1_STAT                                  (UART1_BASE+0x000c)
+
+//--------------Bits Location-------------------------------------//
+//--------------UART2--------------------------------------//
+//--------------Register Address----------------------------------//
+#define UART2_BASE                                  0xB0124000
+#define UART2_CTL                                   (UART2_BASE+0x0000)
+#define UART2_RXDAT                                 (UART2_BASE+0x0004)
+#define UART2_TXDAT                                 (UART2_BASE+0x0008)
+#define UART2_STAT                                  (UART2_BASE+0x000c)
+
+//--------------Bits Location-------------------------------------//
+//--------------UART3--------------------------------------//
+//--------------Register Address----------------------------------//
+#define UART3_BASE                                  0xB0126000
+#define UART3_CTL                                   (UART3_BASE+0x0000)
+#define UART3_RXDAT                                 (UART3_BASE+0x0004)
+#define UART3_TXDAT                                 (UART3_BASE+0x0008)
+#define UART3_STAT                                  (UART3_BASE+0x000c)
+
+//--------------Bits Location-------------------------------------//
+//--------------UART4--------------------------------------//
+//--------------Register Address----------------------------------//
+#define UART4_BASE                                  0xB0128000
+#define UART4_CTL                                   (UART4_BASE+0x0000)
+#define UART4_RXDAT                                 (UART4_BASE+0x0004)
+#define UART4_TXDAT                                 (UART4_BASE+0x0008)
+#define UART4_STAT                                  (UART4_BASE+0x000c)
+
+//--------------Bits Location-------------------------------------//
+//--------------UART5--------------------------------------//
+//--------------Register Address----------------------------------//
+#define UART5_BASE                                  0xB012a000
+#define UART5_CTL                                   (UART5_BASE+0x0000)
+#define UART5_RXDAT                                 (UART5_BASE+0x0004)
+#define UART5_TXDAT                                 (UART5_BASE+0x0008)
+#define UART5_STAT                                  (UART5_BASE+0x000c)
+
+//--------------Bits Location-------------------------------------//
+//--------------UART6--------------------------------------//
+//--------------Register Address----------------------------------//
+#define UART6_BASE                                  0xB012c000
+#define UART6_CTL                                   (UART6_BASE+0x0000)
+#define UART6_RXDAT                                 (UART6_BASE+0x0004)
+#define UART6_TXDAT                                 (UART6_BASE+0x0008)
+#define UART6_STAT                                  (UART6_BASE+0x000c)
+
+//--------------Bits Location-------------------------------------//
+//--------------IRC--------------------------------------//
+//--------------Register Address----------------------------------//
+#define IRC_BASE                                    0xB0120050
+#define IR_CTL                                      (IRC_BASE+0x00)
+#define IR_STAT                                     (IRC_BASE+0x04)
+#define IR_CC                                       (IRC_BASE+0x08)
+#define IR_KDC                                      (IRC_BASE+0x0C)
+#define IR_TCOUNTER                                 (IRC_BASE+0x10)
+#define IR_RCC                                      (IRC_BASE+0x14)
+
+//--------------Bits Location-------------------------------------//
+//--------------I2C0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define I2C0_BASE                                   0xB0170000
+#define I2C0_CTL                                    (I2C0_BASE+0x0000)
+#define I2C0_CLKDIV                                 (I2C0_BASE+0x0004)
+#define I2C0_STAT                                   (I2C0_BASE+0x0008)
+#define I2C0_ADDR                                   (I2C0_BASE+0x000C)
+#define I2C0_TXDAT                                  (I2C0_BASE+0x0010)
+#define I2C0_RXDAT                                  (I2C0_BASE+0x0014)
+#define I2C0_CMD                                    (I2C0_BASE+0x0018)
+#define I2C0_FIFOCTL                                (I2C0_BASE+0x001C)
+#define I2C0_FIFOSTAT                               (I2C0_BASE+0x0020)
+#define I2C0_DATCNT                                 (I2C0_BASE+0x0024)
+#define I2C0_RCNT                                   (I2C0_BASE+0x0028)
+
+//--------------Bits Location-------------------------------------//
+//--------------I2C1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define I2C1_BASE                                   0xB0174000
+#define I2C1_CTL                                    (I2C1_BASE+0x0000)
+#define I2C1_CLKDIV                                 (I2C1_BASE+0x0004)
+#define I2C1_STAT                                   (I2C1_BASE+0x0008)
+#define I2C1_ADDR                                   (I2C1_BASE+0x000C)
+#define I2C1_TXDAT                                  (I2C1_BASE+0x0010)
+#define I2C1_RXDAT                                  (I2C1_BASE+0x0014)
+#define I2C1_CMD                                    (I2C1_BASE+0x0018)
+#define I2C1_FIFOCTL                                (I2C1_BASE+0x001C)
+#define I2C1_FIFOSTAT                               (I2C1_BASE+0x0020)
+#define I2C1_DATCNT                                 (I2C1_BASE+0x0024)
+#define I2C1_RCNT                                   (I2C1_BASE+0x0028)
+
+//--------------Bits Location-------------------------------------//
+//--------------I2C2--------------------------------------//
+//--------------Register Address----------------------------------//
+#define I2C2_BASE                                   0xB0178000
+#define I2C2_CTL                                    (I2C2_BASE+0x0000)
+#define I2C2_CLKDIV                                 (I2C2_BASE+0x0004)
+#define I2C2_STAT                                   (I2C2_BASE+0x0008)
+#define I2C2_ADDR                                   (I2C2_BASE+0x000C)
+#define I2C2_TXDAT                                  (I2C2_BASE+0x0010)
+#define I2C2_RXDAT                                  (I2C2_BASE+0x0014)
+#define I2C2_CMD                                    (I2C2_BASE+0x0018)
+#define I2C2_FIFOCTL                                (I2C2_BASE+0x001C)
+#define I2C2_FIFOSTAT                               (I2C2_BASE+0x0020)
+#define I2C2_DATCNT                                 (I2C2_BASE+0x0024)
+#define I2C2_RCNT                                   (I2C2_BASE+0x0028)
+
+//--------------Bits Location-------------------------------------//
+//--------------I2C3--------------------------------------//
+//--------------Register Address----------------------------------//
+#define I2C3_BASE                                   0xB017C000
+#define I2C3_CTL                                    (I2C3_BASE+0x0000)
+#define I2C3_CLKDIV                                 (I2C3_BASE+0x0004)
+#define I2C3_STAT                                   (I2C3_BASE+0x0008)
+#define I2C3_ADDR                                   (I2C3_BASE+0x000C)
+#define I2C3_TXDAT                                  (I2C3_BASE+0x0010)
+#define I2C3_RXDAT                                  (I2C3_BASE+0x0014)
+#define I2C3_CMD                                    (I2C3_BASE+0x0018)
+#define I2C3_FIFOCTL                                (I2C3_BASE+0x001C)
+#define I2C3_FIFOSTAT                               (I2C3_BASE+0x0020)
+#define I2C3_DATCNT                                 (I2C3_BASE+0x0024)
+#define I2C3_RCNT                                   (I2C3_BASE+0x0028)
+
+//--------------Bits Location-------------------------------------//
+//--------------LCD--------------------------------------//
+//--------------Register Address----------------------------------//
+#define LCD_BASE                                    0xB02A0000
+#define LCD0_CTL                                    (LCD_BASE+0x0000)
+#define LCD0_SIZE                                   (LCD_BASE+0x0004)
+#define LCD0_STATUS                                 (LCD_BASE+0x0008)
+#define LCD0_TIM0                                   (LCD_BASE+0x000C)
+#define LCD0_TIM1                                   (LCD_BASE+0x0010)
+#define LCD0_TIM2                                   (LCD_BASE+0x0014)
+#define LCD0_COLOR                                  (LCD_BASE+0x0018)
+#define LCD0_CPU_CTL                                (LCD_BASE+0x001c)
+#define LCD0_CPU_CMD                                (LCD_BASE+0x0020)
+#define LCD0_TEST_P0                                (LCD_BASE+0x0024)
+#define LCD0_TEST_P1                                (LCD_BASE+0x0028)
+#define LCD0_IMG_XPOS                               (LCD_BASE+0x002c)
+#define LCD0_IMG_YPOS                               (LCD_BASE+0x0030)
+#define LCD1_CTL                                    (LCD_BASE+0x0100)
+#define LCD1_SIZE                                   (LCD_BASE+0x0104)
+#define LCD1_TIM1                                   (LCD_BASE+0x0108)
+#define LCD1_TIM2                                   (LCD_BASE+0x010c)
+#define LCD1_COLOR                                  (LCD_BASE+0x0110)
+#define LCD1_CPU_CTL                                (LCD_BASE+0x0114)
+#define LCD1_CPU_CMD                                (LCD_BASE+0x0118)
+#define LCD1_IMG_XPOS                               (LCD_BASE+0x011C)
+#define LCD1_IMG_YPOS                               (LCD_BASE+0x0120)
+
+//--------------Bits Location-------------------------------------//
+//--------------LVDS--------------------------------------//
+//--------------Register Address----------------------------------//
+#define LVDS_BASE                                   0xB02A0200
+#define LVDS_CTL                                    (LVDS_BASE+0x0000)
+#define LVDS_ALG_CTL0                               (LVDS_BASE+0x0004)
+#define LVDS_DEBUG                                  (LVDS_BASE+0x0008)
+
+//--------------Bits Location-------------------------------------//
+//--------------CSI--------------------------------------//
+//--------------Register Address----------------------------------//
+#define CSI_BASE                                    0xB02D0000
+#define CSI_CTRL                                    (CSI_BASE+0x00)
+#define SHORT_PACKET                                (CSI_BASE+0x04)
+#define ERROR_PENDING                               (CSI_BASE+0x08)
+#define STATUS_PENDING                              (CSI_BASE+0x0c)
+#define LANE_STATUS                                 (CSI_BASE+0x10)
+#define CSI_PHY_T0                                  (CSI_BASE+0x14)
+#define CSI_PHY_T1                                  (CSI_BASE+0x18)
+#define CSI_PHY_T2                                  (CSI_BASE+0x1c)
+#define CSI_ANALOG_PHY                              (CSI_BASE+0x20)
+#define CONTEXT0_CFG                                (CSI_BASE+0x100)
+#define CONTEXT0_STATUS                             (CSI_BASE+ 0x104)
+#define CONTEXT1_CFG                                (CSI_BASE+0x120)
+#define CONTEXT1_STATUS                             (CSI_BASE+ 0x124)
+#define TEST_CONTROL                                (CSI_BASE+0X130)
+#define TEST_DATA                                   (CSI_BASE+0X134)
+
+//--------------Bits Location-------------------------------------//
+//--------------DSI--------------------------------------//
+//--------------Register Address----------------------------------//
+#define DSI_BASE                                    0xB0220000
+#define DSI_CTRL                                    (DSI_BASE+0x00)
+#define DSI_SIZE                                    (DSI_BASE+0x04)
+#define DSI_COLOR                                   (DSI_BASE+0x08)
+#define DSI_VIDEO_CFG                               (DSI_BASE+0x0C)
+#define DSI_RGBHT0                                  (DSI_BASE+0x10)
+#define DSI_RGBHT1                                  (DSI_BASE+0x14)
+#define DSI_RGBVT0                                  (DSI_BASE+0x18)
+#define DSI_RGBVT1                                  (DSI_BASE+0x1C)
+#define DSI_TIMEOUT                                 (DSI_BASE+0x20)
+#define DSI_TR_STA                                  (DSI_BASE+0x24)
+#define DSI_INT_EN                                  (DSI_BASE+0x28)
+#define DSI_ERROR_REPORT                            (DSI_BASE+0x2C)
+#define DSI_FIFO_ODAT                               (DSI_BASE+0x30)
+#define DSI_FIFO_IDAT                               (DSI_BASE+0x34)
+#define DSI_IPACK                                   (DSI_BASE+0x38)
+#define DSI_PACK_CFG                                (DSI_BASE+0x40)
+#define DSI_PACK_HEADER                             (DSI_BASE+0x44)
+#define DSI_TX_TRIGGER                              (DSI_BASE+0x48)
+#define DSI_RX_TRIGGER                              (DSI_BASE+0x4C)
+#define DSI_LANE_CTRL                               (DSI_BASE+0x50)
+#define DSI_LANE_STA                                (DSI_BASE+0x54)
+#define DSI_PHY_T0                                  (DSI_BASE+0x60)
+#define DSI_PHY_T1                                  (DSI_BASE+0x64)
+#define DSI_PHY_T2                                  (DSI_BASE+0x68)
+#define DSI_APHY_DEBUG0                             (DSI_BASE+0x70)
+#define DSI_APHY_DEBUG1                             (DSI_BASE+0x74)
+#define DSI_SELF_TEST                               (DSI_BASE+0x78)
+#define DSI_PHY_CTRL                                (DSI_BASE+0x80)
+#define DSI_FT_TEST                                 (DSI_BASE+0x88)
+
+//--------------Bits Location-------------------------------------//
+//--------------TVOUT--------------------------------------//
+//--------------Register Address----------------------------------//
+#define TVOUT_BASE                                  0xB02B0000
+#define TVOUT_EN                                    (TVOUT_BASE+0x0000)
+#define TVOUT_OCR                                   (TVOUT_BASE+0x0004)
+#define TVOUT_STA                                   (TVOUT_BASE+0x0008)
+#define TVOUT_CCR                                   (TVOUT_BASE+0x000C)
+#define TVOUT_BCR                                   (TVOUT_BASE+0x0010)
+#define TVOUT_CSCR                                  (TVOUT_BASE+0x0014)
+#define TVOUT_PRL                                   (TVOUT_BASE+0x0018)
+#define TVOUT_VFALD                                 (TVOUT_BASE+0x001C)
+#define CVBS_MSR                                    (TVOUT_BASE+0x0020)
+#define CVBS_AL_SEPO                                (TVOUT_BASE+0x0024)
+#define CVBS_AL_SEPE                                (TVOUT_BASE+0x0028)
+#define CVBS_AD_SEP                                 (TVOUT_BASE+0x002C)
+#define CVBS_HUECR                                  (TVOUT_BASE+0x0030)
+#define CVBS_SCPCR                                  (TVOUT_BASE+0x0034)
+#define CVBS_SCFCR                                  (TVOUT_BASE+0x0038)
+#define CVBS_CBACR                                  (TVOUT_BASE+0x003C)
+#define CVBS_SACR                                   (TVOUT_BASE+0x0040)
+#define BT_MSR0                                     (TVOUT_BASE+0x0100)
+#define BT_MSR1                                     (TVOUT_BASE+0x0104)
+#define BT_AL_SEPO                                  (TVOUT_BASE+0x0108)
+#define BT_AL_SEPE                                  (TVOUT_BASE+0x010C)
+#define BT_AP_SEP                                   (TVOUT_BASE+0x0110)
+#define TVOUT_DCR                                   (TVOUT_BASE+0x0070)
+#define TVOUT_DDCR                                  (TVOUT_BASE+0x0074)
+#define TVOUT_DCORCTL                               (TVOUT_BASE+0x0078)
+#define TVOUT_DRCR                                  (TVOUT_BASE+0x007C)
+
+//--------------Bits Location-------------------------------------//
+//--------------HDMI--------------------------------------//
+//--------------Register Address----------------------------------//
+#define HDMI_BASE                                   0xB02C0000
+#define HDMI_VICTL                                  (HDMI_BASE+0x0000)
+#define HDMI_VIVSYNC                                (HDMI_BASE+0x0004)
+#define HDMI_VIVHSYNC                               (HDMI_BASE+0x0008)
+#define HDMI_VIALSEOF                               (HDMI_BASE+0x000C)
+#define HDMI_VIALSEEF                               (HDMI_BASE+0x0010)
+#define HDMI_VIADLSE                                (HDMI_BASE+0x0014)
+#define HDMI_AIFRAMEC                               (HDMI_BASE+0x0020)
+#define HDMI_AICHSTABYTE0TO3                        (HDMI_BASE+0x0024)
+#define HDMI_AICHSTABYTE4TO7                        (HDMI_BASE+0x0028)
+#define HDMI_AICHSTABYTE8TO11                       (HDMI_BASE+0x002C)
+#define HDMI_AICHSTABYTE12TO15                      (HDMI_BASE+0x0030)
+#define HDMI_AICHSTABYTE16TO19                      (HDMI_BASE+0x0034)
+#define HDMI_AICHSTABYTE20TO23                      (HDMI_BASE+0x0038)
+#define HDMI_AICHSTASCN                             (HDMI_BASE+0x003C)
+#define HDMI_VR                                     (HDMI_BASE+0x0050)
+#define HDMI_CR                                     (HDMI_BASE+0x0054)
+#define HDMI_SCHCR                                  (HDMI_BASE+0x0058)
+#define HDMI_ICR                                    (HDMI_BASE+0x005C)
+#define HDMI_SCR                                    (HDMI_BASE+0x0060)
+#define HDMI_LPCR                                   (HDMI_BASE+0x0064)
+#define HDCP_CR                                     (HDMI_BASE+0x0068)
+#define HDCP_SR                                     (HDMI_BASE+0x006C)
+#define HDCP_ANLR                                   (HDMI_BASE+0x0070)
+#define HDCP_ANMR                                   (HDMI_BASE+0x0074)
+#define HDCP_ANILR                                  (HDMI_BASE+0x0078)
+#define HDCP_ANIMR                                  (HDMI_BASE+0x007C)
+#define HDCP_DPKLR                                  (HDMI_BASE+0x0080)
+#define HDCP_DPKMR                                  (HDMI_BASE+0x0084)
+#define HDCP_LIR                                    (HDMI_BASE+0x0088)
+#define HDCP_SHACR                                  (HDMI_BASE+0x008C)
+#define HDCP_SHADR                                  (HDMI_BASE+0x0090)
+#define HDCP_ICR                                    (HDMI_BASE+0x0094)
+#define HDCP_KMMR                                   (HDMI_BASE+0x0098)
+#define HDCP_KMLR                                   (HDMI_BASE+0x009C)
+#define HDCP_MILR                                   (HDMI_BASE+0x00A0)
+#define HDCP_MIMR                                   (HDMI_BASE+0x00A4)
+#define HDCP_KOWR                                   (HDMI_BASE+0x00A8)
+#define HDCP_OWR                                    (HDMI_BASE+0x00AC)
+#define TMDS_STR0                                   (HDMI_BASE+0x00B8)
+#define TMDS_STR1                                   (HDMI_BASE+0x00BC)
+#define TMDS_EODR0                                  (HDMI_BASE+0x00C0)
+#define TMDS_EODR1                                  (HDMI_BASE+0x00C4)
+#define HDMI_ASPCR                                  (HDMI_BASE+0x00D0)
+#define HDMI_ACACR                                  (HDMI_BASE+0x00D4)
+#define HDMI_ACRPCR                                 (HDMI_BASE+0x00D8)
+#define HDMI_ACRPCTSR                               (HDMI_BASE+0x00DC)
+#define HDMI_ACRPPR                                 (HDMI_BASE+0x00E0)
+#define HDMI_GCPCR                                  (HDMI_BASE+0x00E4)
+#define HDMI_RPCR                                   (HDMI_BASE+0x00E8)
+#define HDMI_RPRBDR                                 (HDMI_BASE+0x00EC)
+#define HDMI_OPCR                                   (HDMI_BASE+0x00F0)
+#define HDMI_DIPCCR                                 (HDMI_BASE+0x00F4)
+#define HDMI_ORP6PH                                 (HDMI_BASE+0x00F8)
+#define HDMI_ORSP6W0                                (HDMI_BASE+0x00FC)
+#define HDMI_ORSP6W1                                (HDMI_BASE+0x0100)
+#define HDMI_ORSP6W2                                (HDMI_BASE+0x0104)
+#define HDMI_ORSP6W3                                (HDMI_BASE+0x0108)
+#define HDMI_ORSP6W4                                (HDMI_BASE+0x010C)
+#define HDMI_ORSP6W5                                (HDMI_BASE+0x0110)
+#define HDMI_ORSP6W6                                (HDMI_BASE+0x0114)
+#define HDMI_ORSP6W7                                (HDMI_BASE+0x0118)
+#define HDMI_CECCR                                  (HDMI_BASE+0x011C)
+#define HDMI_CECRTCR                                (HDMI_BASE+0x0120)
+#define HDMI_CECRXCR                                (HDMI_BASE+0x0124)
+#define HDMI_CECTXCR                                (HDMI_BASE+0x0128)
+#define HDMI_CECTXDR                                (HDMI_BASE+0x012C)
+#define HDMI_CECRXDR                                (HDMI_BASE+0x0130)
+#define HDMI_CECRXTCR                               (HDMI_BASE+0x0134)
+#define HDMI_CECTXTCR0                              (HDMI_BASE+0x0138)
+#define HDMI_CECTXTCR1                              (HDMI_BASE+0x013C)
+#define HDMI_CRCCR                                  (HDMI_BASE+0x0140)
+#define HDMI_CRCDOR                                 (HDMI_BASE+0x0144)
+#define HDMI_TX_1                                   (HDMI_BASE+0x0154)
+#define HDMI_TX_2                                   (HDMI_BASE+0x0158)
+#define CEC_DDC_HPD                                 (HDMI_BASE+0x015C)
+
+//--------------Bits Location-------------------------------------//
+//--------------I2S_SPDIF--------------------------------------//
+//--------------Register Address----------------------------------//
+#define I2S_SPDIF_BASE                              0xB0100000
+#define I2S_CTL                                     (I2S_SPDIF_BASE+0x0000)
+#define I2S_FIFOCTL                                 (I2S_SPDIF_BASE+0x0004)
+#define I2STX_DAT                                   (I2S_SPDIF_BASE+0x0008)
+#define I2SRX_DAT                                   (I2S_SPDIF_BASE+0x000c)
+#define SPDIF_HDMI_CTL                              (I2S_SPDIF_BASE+0x0010)
+#define SPDIF_DAT                                   (I2S_SPDIF_BASE+0x0014)
+#define SPDIF_CLSTAT                                (I2S_SPDIF_BASE+0x0018)
+#define SPDIF_CHSTAT                                (I2S_SPDIF_BASE+0x001c)
+#define HDMI_DAT                                    (I2S_SPDIF_BASE+0x0020)
+#define I2STX_DAT_DBG                               (I2S_SPDIF_BASE+0x0024)
+#define I2SRX_DAT_DBG                               (I2S_SPDIF_BASE+0x0028)
+#define I2STX_SPDIF_HDMI_CTL                        (I2S_SPDIF_BASE+0x002c)
+#define I2STX_SPDIF_HDMI_DAT                        (I2S_SPDIF_BASE+0x0030)
+
+//--------------Bits Location-------------------------------------//
+//--------------PCM0--------------------------------------//
+//--------------Register Address----------------------------------//
+#define PCM0_BASE                                   0xB0110000
+#define PCM0_CTL                                    (PCM0_BASE+0x0000)
+#define PCM0_STAT                                   (PCM0_BASE+0x0004)
+#define PCM0_RXDAT                                  (PCM0_BASE+0x0008)
+#define PCM0_TXDAT                                  (PCM0_BASE+0x000C)
+
+//--------------Bits Location-------------------------------------//
+//--------------PCM1--------------------------------------//
+//--------------Register Address----------------------------------//
+#define PCM1_BASE                                   0xB0118000
+#define PCM1_CTL                                    (PCM1_BASE+0x0000)
+#define PCM1_STAT                                   (PCM1_BASE+0x0004)
+#define PCM1_RXDAT                                  (PCM1_BASE+0x0008)
+#define PCM1_TXDAT                                  (PCM1_BASE+0x000C)
+
+//--------------Bits Location-------------------------------------//
+//--------------KEY--------------------------------------//
+//--------------Register Address----------------------------------//
+#define KEY_BASE                                    0xB01A0000
+#define KEY_CTL                                     (KEY_BASE+0x0000)
+#define KEY_DAT0                                    (KEY_BASE+0x0004)
+#define KEY_DAT1                                    (KEY_BASE+0x0008)
+#define KEY_DAT2                                    (KEY_BASE+0x000C)
+#define KEY_DAT3                                    (KEY_BASE+0x0010)
+#define KEY_DAT4                                    (KEY_BASE+0x0014)
+#define KEY_DAT5                                    (KEY_BASE+0x0018)
+#define KEY_DAT6                                    (KEY_BASE+0x001C)
+#define KEY_DAT7                                    (KEY_BASE+0x0020)
+
+//--------------Bits Location-------------------------------------//
+//--------------LENSC--------------------------------------//
+//--------------Register Address----------------------------------//
+#define LENSC_BASE                                  0xB0140000
+#define ST1_MOTOR_CTL1                              (LENSC_BASE+0x0)
+#define ST1_MOTOR_CTL2                              (LENSC_BASE+0x4)
+#define ST1_MOTOR_SPEED                             (LENSC_BASE+0x8)
+#define ST1_MOTOR_TRDATA                            (LENSC_BASE+0xC)
+#define ST1_MOTOR_CMD_CTL                           (LENSC_BASE+0x10)
+#define ST2_MOTOR_CTL1                              (LENSC_BASE+0x20)
+#define ST2_MOTOR_CTL2                              (LENSC_BASE+0x24)
+#define ST2_MOTOR_SPEED                             (LENSC_BASE+0x28)
+#define ST2_MOTOR_TRDATA                            (LENSC_BASE+0x2C)
+#define ST2_MOTOR_CMD_CTL                           (LENSC_BASE+0x30)
+#define ST3_MOTOR_CTL1                              (LENSC_BASE+0x40)
+#define ST3_MOTOR_CTL2                              (LENSC_BASE+0x44)
+#define ST3_MOTOR_SPEED                             (LENSC_BASE+0x48)
+#define ST3_MOTOR_TRDATA                            (LENSC_BASE+0x4C)
+#define ST3_MOTOR_CMD_CTL                           (LENSC_BASE+0x50)
+#define DC_MOTOR_CTL1                               (LENSC_BASE+0x60)
+#define DC_MOTOR_CTL2                               (LENSC_BASE+0x64)
+#define MOTOR_MFP_CTL                               (LENSC_BASE+0x70)
+#define MOTOR_PWM_CTL                               (LENSC_BASE+0x74)
+#define MOTOR_VD_CTL                                (LENSC_BASE+0x78)
+
+//--------------Bits Location-------------------------------------//
+//--------------GPIO_MFP_PWM--------------------------------------//
+//--------------Register Address----------------------------------//
+#define GPIO_MFP_PWM_BASE                           0xB01B0000
+#define GPIO_AOUTEN                                 (GPIO_MFP_PWM_BASE+0x0000)
+#define GPIO_AINEN                                  (GPIO_MFP_PWM_BASE+0x0004)
+#define GPIO_ADAT                                   (GPIO_MFP_PWM_BASE+0x0008)
+#define GPIO_BOUTEN                                 (GPIO_MFP_PWM_BASE+0x000C)
+#define GPIO_BINEN                                  (GPIO_MFP_PWM_BASE+0x0010)
+#define GPIO_BDAT                                   (GPIO_MFP_PWM_BASE+0x0014)
+#define GPIO_COUTEN                                 (GPIO_MFP_PWM_BASE+0x0018)
+#define GPIO_CINEN                                  (GPIO_MFP_PWM_BASE+0x001C)
+#define GPIO_CDAT                                   (GPIO_MFP_PWM_BASE+0x0020)
+#define GPIO_DOUTEN                                 (GPIO_MFP_PWM_BASE+0x0024)
+#define GPIO_DINEN                                  (GPIO_MFP_PWM_BASE+0x0028)
+#define GPIO_DDAT                                   (GPIO_MFP_PWM_BASE+0x002C)
+#define GPIO_EOUTEN                                 (GPIO_MFP_PWM_BASE+0x0030)
+#define GPIO_EINEN                                  (GPIO_MFP_PWM_BASE+0x0034)
+#define GPIO_EDAT                                   (GPIO_MFP_PWM_BASE+0x0038)
+#define MFP_CTL0                                    (GPIO_MFP_PWM_BASE+0x0040)
+#define MFP_CTL1                                    (GPIO_MFP_PWM_BASE+0x0044)
+#define MFP_CTL2                                    (GPIO_MFP_PWM_BASE+0x0048)
+#define MFP_CTL3                                    (GPIO_MFP_PWM_BASE+0x004C)
+#define PWM_CTL0                                    (GPIO_MFP_PWM_BASE+0X50)
+#define PWM_CTL1                                    (GPIO_MFP_PWM_BASE+0X54)
+#define PWM_CTL2                                    (GPIO_MFP_PWM_BASE+0X58)
+#define PWM_CTL3                                    (GPIO_MFP_PWM_BASE+0X5C)
+#define PWM_CTL4                                    (GPIO_MFP_PWM_BASE+0X78)
+#define PWM_CTL5                                    (GPIO_MFP_PWM_BASE+0X7C)
+#define PAD_PULLCTL0                                (GPIO_MFP_PWM_BASE+0x0060)
+#define PAD_PULLCTL1                                (GPIO_MFP_PWM_BASE+0x0064)
+#define PAD_PULLCTL2                                (GPIO_MFP_PWM_BASE+0x0068)
+#define PAD_ST0                                     (GPIO_MFP_PWM_BASE+0x006C)
+#define PAD_ST1                                     (GPIO_MFP_PWM_BASE+0x0070)
+#define PAD_CTL                                     (GPIO_MFP_PWM_BASE+0x0074)
+#define SPEED_SENSOR_CTL                            (GPIO_MFP_PWM_BASE+0x007C)
+#define PAD_DRV0                                    (GPIO_MFP_PWM_BASE+0x0080)
+#define PAD_DRV1                                    (GPIO_MFP_PWM_BASE+0x0084)
+#define PAD_DRV2                                    (GPIO_MFP_PWM_BASE+0x0088)
+#define DEBUG_SEL                                   (GPIO_MFP_PWM_BASE+0x0090)
+#define DEBUG_OEN0                                  (GPIO_MFP_PWM_BASE+0x0094)
+#define DEBUG_OEN1                                  (GPIO_MFP_PWM_BASE+0x0098)
+#define DEBUG_IEN0                                  (GPIO_MFP_PWM_BASE+0x009C)
+#define DEBUG_IEN1                                  (GPIO_MFP_PWM_BASE+0x00A0)
+#define MEM_MARGIN_CTRL0                            (GPIO_MFP_PWM_BASE+0x00B0)
+#define MEM_MARGIN_CTRL1                            (GPIO_MFP_PWM_BASE+0x00B4)
+#define BIST_START0                                 (GPIO_MFP_PWM_BASE+0x00C0)
+#define BIST_START1                                 (GPIO_MFP_PWM_BASE+0x00C4)
+#define BIST_DONE0                                  (GPIO_MFP_PWM_BASE+0x00C8)
+#define BIST_DONE1                                  (GPIO_MFP_PWM_BASE+0x00CC)
+#define BIST_FAIL0                                  (GPIO_MFP_PWM_BASE+0x00D0)
+#define BIST_FAIL1                                  (GPIO_MFP_PWM_BASE+0x00D4)
+#define INTC_EXTCTL                                 (GPIO_MFP_PWM_BASE+0x0200)
+#define INTC_GPIOCTL                                (GPIO_MFP_PWM_BASE+0x0204)
+#define INTC_GPIOA_PD                               (GPIO_MFP_PWM_BASE+0x0208)
+#define INTC_GPIOA_MSK                              (GPIO_MFP_PWM_BASE+0x020c)
+#define INTC_GPIOB_PD                               (GPIO_MFP_PWM_BASE+0x0210)
+#define INTC_GPIOB_MSK                              (GPIO_MFP_PWM_BASE+0x0214)
+#define INTC_GPIOC_PD                               (GPIO_MFP_PWM_BASE+0x0218)
+#define INTC_GPIOC_MSK                              (GPIO_MFP_PWM_BASE+0x021c)
+#define INTC_GPIOD_PD                               (GPIO_MFP_PWM_BASE+0x0220)
+#define INTC_GPIOD_MSK                              (GPIO_MFP_PWM_BASE+0x0224)
+#define INTC_GPIOE_PD                               (GPIO_MFP_PWM_BASE+0x0228)
+#define INTC_GPIOE_MSK                              (GPIO_MFP_PWM_BASE+0x022c)
+#define INTC_GPIOA_TYPE0                            (GPIO_MFP_PWM_BASE+0x0230)
+#define INTC_GPIOA_TYPE1                            (GPIO_MFP_PWM_BASE+0x0234)
+#define INTC_GPIOB_TYPE0                            (GPIO_MFP_PWM_BASE+0x0238)
+#define INTC_GPIOB_TYPE1                            (GPIO_MFP_PWM_BASE+0x023c)
+#define INTC_GPIOC_TYPE0                            (GPIO_MFP_PWM_BASE+0x0240)
+#define INTC_GPIOC_TYPE1                            (GPIO_MFP_PWM_BASE+0x0244)
+#define INTC_GPIOD_TYPE0                            (GPIO_MFP_PWM_BASE+0x0248)
+#define INTC_GPIOD_TYPE1                            (GPIO_MFP_PWM_BASE+0x024C)
+#define INTC_GPIOE_TYPE                             (GPIO_MFP_PWM_BASE+0x0250)
+
+//Following is added mannually   cjhhust 2012-08-01 
+//--------------NIC         --------------------------------------//
+#define NIC_BASE                                    0xB0500000
+
+//--------------VDE         --------------------------------------//
+#define VDE_BASE                                    0xB0280000
+
+//--------------VCE         --------------------------------------//
+#define VCE_BASE                                    0xB0288000
+
+//--------------G3D         --------------------------------------//
+#define G3D_BASE                                    0xB0300000
+
+//--------------DDR_Upctrl/Pub   ---------------------------------//
+#define UPCTL0_BASE                                 0xB01C0000
+#define UPCTL1_BASE                                 0xB01D0000
+#define PUB0_BASE                                   0xB01C8000
+#define PUB1_BASE                                   0xB01D8000
+
+#endif
diff --git a/arch/arm/mach-owl/include/mach/secure_storage.h b/arch/arm/mach-owl/include/mach/secure_storage.h
new file mode 100755
index 0000000..01786cc
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/secure_storage.h
@@ -0,0 +1,41 @@
+/*
+ * arch/arm/mach-leopard/include/mach/secure_storage.h
+ *
+ * secure storage interface
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_SECURE_STORAGE_H
+#define __ASM_ARCH_SECURE_STORAGE_H
+
+/* secure storage data type */
+#define SECURE_STORAGE_DATA_TYPE_SN     0
+#define SECURE_STORAGE_DATA_TYPE_DRM    1
+#define SECURE_STORAGE_DATA_TYPE_HDCP   2
+#define SECURE_STORAGE_DATA_TYPE_DEVNUM 3
+#define SECURE_STORAGE_DATA_TYPE_EXT    4 
+
+struct secure_storage
+{
+    const char *name;
+    unsigned int size;      /* maxinum size: byte */
+    int (*read_data)(int type, char * buf, int size);
+    int (*write_data)(int type, char * buf, int size);
+};
+
+/* provider interface */
+extern int owl_register_secure_storage(struct secure_storage *ss);
+extern int owl_unregister_secure_storage(struct secure_storage *ss);
+
+/* user interface*/
+extern int owl_read_secure_storage_data(int type, char * buf, int size);
+extern int owl_write_secure_storage_data(int type, char * buf, int size);
+
+#endif /* __ASM_ARCH_SECURE_STORAGE_H */
diff --git a/arch/arm/mach-owl/include/mach/smp.h b/arch/arm/mach-owl/include/mach/smp.h
new file mode 100755
index 0000000..5b6bf7f
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/smp.h
@@ -0,0 +1,41 @@
+/*
+ * arch/arm/mach-gl5202/include/mach/smp.h
+ *
+ * SMP definitions
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef ASMARM_ARCH_SMP_H
+#define ASMARM_ARCH_SMP_H
+
+//#include <asm/hardware/gic.h>
+
+/* This is required to wakeup the secondary core */
+extern void owl_secondary_startup(void);
+extern void gic_raise_softirq(const struct cpumask *mask, unsigned int irq);
+
+#define hard_smp_processor_id()             \
+    ({                      \
+        unsigned int cpunum;            \
+        __asm__("mrc p15, 0, %0, c0, c0, 5" \
+            : "=r" (cpunum));       \
+        cpunum &= 0x0F;             \
+    })
+
+
+/*
+ * We use IRQ1 as the IPI
+ */
+static inline void smp_cross_call(const struct cpumask *mask)
+{
+    gic_raise_softirq(mask, 1);
+}
+
+#endif /* ASMARM_ARCH_SMP_H */
diff --git a/arch/arm/mach-owl/include/mach/spi-owl.h b/arch/arm/mach-owl/include/mach/spi-owl.h
new file mode 100755
index 0000000..fac85c9
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/spi-owl.h
@@ -0,0 +1,61 @@
+#ifndef __SPI_OWL_H__
+#define __SPI_OWL_H__
+
+struct owl_gpio{
+	int gpio_group;
+	unsigned int gpio_pin;
+};
+
+struct owl_spi_pdata {
+	u32	source_clk;		/* source clk type */
+
+	void (*init_hw)(void);
+	void (*free_hw)(void);
+	struct owl_gpio *owl_spi_cs_table;
+	u16 max_chipselect;
+
+	u8 enable_dma;
+};
+
+#define SPIx_CTL_SDT(x)                    (((x) & 0x7) << 29)
+#define SPIx_CTL_BM                        (1 << 28)
+#define SPIx_CTL_GM                        (1 << 27)
+
+#define SPIx_CTL_CEB                        (1 << 26)
+#define SPIx_CTL_RANEN                     (1 << 24)
+#define SPIx_CTL_RDIC(x)                    (((x) & 0x3) << 22)
+#define SPIx_CTL_TDIC(x)                    (((x) & 0x3) << 20)
+#define SPIx_CTL_TWME                       (1 << 19)
+#define SPIx_CTL_EN                         (1 << 18)
+#define SPIx_CTL_RWC(x)                     (((x) & 0x3) << 16)
+#define SPIx_CTL_DTS                        (1 << 15)
+#define SPIx_CTL_SSATEN                     (1 << 14)
+#define SPIx_CTL_DM(x)                      (((x) & 0x3) << 12)
+#define SPIx_CTL_LBT                        (1 << 11)
+#define SPIx_CTL_MS                         (1 << 10)
+#define SPIx_CTL_DAWS(x)                    (((x) & 0x3) << 8)
+#define SPIx_CTL_CPOS(x)                    (((x) & 0x3) << 6)
+#define SPIx_CTL_LMFS                       (1 << 5)
+#define SPIx_CTL_SSCO                       (1 << 4)
+#define SPIx_CTL_TIEN                       (1 << 3)
+#define SPIx_CTL_RIEN                       (1 << 2)
+#define SPIx_CTL_TDEN                       (1 << 1)
+#define SPIx_CTL_RDEN                       (1 << 0)
+/******************************************************************************/
+/*SPIx_CLKDIV*/
+/*bit 10-31 Reserved*/
+#define SPIx_CLKDIV_CLKDIV(x)               (((x) & 0x3FF) << 0)
+/******************************************************************************/
+/*SPIx_STAT*/
+/*bit 10-31 Reserved*/
+#define SPIx_STAT_TFEM                      (1 << 9)
+#define SPIx_STAT_RFFU                      (1 << 8)
+#define SPIx_STAT_TFFU                      (1 << 7)
+#define SPIx_STAT_RFEM                      (1 << 6)
+#define SPIx_STAT_TFER                      (1 << 5)
+#define SPIx_STAT_RFER                      (1 << 4)
+#define SPIx_STAT_BEB                       (1 << 3)
+#define SPIx_STAT_TCOM                      (1 << 2)
+#define SPIx_STAT_TIP                       (1 << 1)
+#define SPIx_STAT_PIP                       (1 << 0)
+#endif
diff --git a/arch/arm/mach-owl/include/mach/storage_access.h b/arch/arm/mach-owl/include/mach/storage_access.h
new file mode 100755
index 0000000..ff29461
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/storage_access.h
@@ -0,0 +1,27 @@
+/*
+ * arch/arm/mach-owl/include/mach/storage_access.h
+ *
+ * storage interface
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_STORAGE_ACCESS_H
+#define __ASM_ARCH_STORAGE_ACCESS_H
+
+/* storage data type */
+#define STORAGE_DATA_TYPE_SN		0x736E0000
+#define STORAGE_DATA_TYPE_DRM		0x64724D00
+#define STORAGE_DATA_TYPE_HDCP		0x68646370
+#define STORAGE_DATA_TYPE_DEVNUM	0x64657600
+
+/* user interface*/
+extern int owl_read_storage_data(int type, char * buf, int size);
+
+#endif /* __ASM_ARCH_STORAGE_ACCESS_H */
diff --git a/arch/arm/mach-owl/include/mach/timex.h b/arch/arm/mach-owl/include/mach/timex.h
new file mode 100755
index 0000000..9a99493
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/timex.h
@@ -0,0 +1,20 @@
+/*
+ * arch/arm/mach-gl5202/include/mach/timex.h
+ *
+ * timex definitions
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#define CLOCK_TICK_RATE     (24000000)
+
+#endif /* __ASM_ARCH_TIMEX_H */
diff --git a/arch/arm/mach-owl/include/mach/uncompress.h b/arch/arm/mach-owl/include/mach/uncompress.h
new file mode 100755
index 0000000..a0285b3
--- /dev/null
+++ b/arch/arm/mach-owl/include/mach/uncompress.h
@@ -0,0 +1,35 @@
+/*
+ * arch/arm/mach-gl5202/include/mach/uncompress.h
+ *
+ * Serial port stubs for kernel decompress status messages
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#endif /* __ASM_ARCH_UNCOMPRESS_H */
diff --git a/arch/arm/mach-owl/isp_pwd-owl.c b/arch/arm/mach-owl/isp_pwd-owl.c
new file mode 100755
index 0000000..8968050
--- /dev/null
+++ b/arch/arm/mach-owl/isp_pwd-owl.c
@@ -0,0 +1,241 @@
+/*
+ * common power management functions for camera sensors
+ */
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/module.h>
+
+#include <mach/clkname.h>
+#include <mach/isp-owl.h>
+
+// for bisp's tow soc camera host
+static struct sensor_pwd_info *g_spinfo[2] = {NULL, NULL};
+
+static inline struct sensor_pwd_info *to_spinfo(int host_id)
+{
+    return g_spinfo[!!host_id];
+}
+
+/* should be called before register host using soc_camera_host_register() */
+void attach_sensor_pwd_info(struct device *dev, 
+    struct sensor_pwd_info *pi, int host_id)
+{
+    int id = !!host_id;
+
+    if (g_spinfo[id]) {
+        dev_err(dev, "already register it [host id : %d]\n", host_id);
+    }
+    g_spinfo[id] = pi;
+}
+EXPORT_SYMBOL(attach_sensor_pwd_info);
+
+
+void detach_sensor_pwd_info(struct device *dev, 
+    struct sensor_pwd_info *pi, int host_id)
+{
+    int id = !!host_id;
+
+    if (pi != g_spinfo[id]) {
+        dev_err(dev, "sensor pwd info don't match with host id[%d]\n", host_id);
+    }
+    g_spinfo[id] = NULL;
+}
+EXPORT_SYMBOL(detach_sensor_pwd_info);
+
+int owl_isp_reset_pin_state = 0;
+EXPORT_SYMBOL(owl_isp_reset_pin_state);
+
+void owl_isp_reset(struct device *dev, int host_id)
+{
+    struct sensor_pwd_info *pi = to_spinfo(host_id);
+    struct dts_gpio *reset = &pi->gpio_reset;
+
+    if(owl_isp_reset_pin_state){
+        printk("%s():maybe has open some camera,skip it.\n",__FUNCTION__);
+        return;
+    }
+    
+	printk("%s() %d\n",__FUNCTION__,__LINE__);
+	/* RESET */
+	gpio_direction_output(reset->num, reset->active_level);
+	msleep(10);
+	gpio_direction_output(reset->num, !reset->active_level);
+	msleep(10);
+}
+EXPORT_SYMBOL(owl_isp_reset);
+
+
+int owl_isp_power_on(int channel, int rear, int host_id)
+{
+    struct sensor_pwd_info *pi = to_spinfo(host_id);
+    struct dts_gpio *dgrear = &pi->gpio_rear;
+    struct dts_gpio *dgfront = &pi->gpio_front;
+    struct clk *sclk = pi->ch_clk[channel];
+    int ret = 0;
+
+    printk("%s(): %s, channel[%d], host[%d]\n",__func__,
+        rear ? "rear" : "front", channel, host_id);
+ 
+    if (rear) {
+        gpio_direction_output(dgrear->num, !dgrear->active_level);
+    } else {
+        gpio_direction_output(dgfront->num, !dgfront->active_level);
+    }
+
+    clk_prepare(sclk);
+	clk_enable(sclk);
+	ret = clk_set_rate(sclk, OUTTO_SENSO_CLOCK);
+	if(ret) {
+		printk(KERN_ERR "%s() : set isp clock error: %d\n",__func__, ret);
+		return ret;
+	}
+	printk("sensor clock is %dM\n",(int)(clk_get_rate(sclk) / 1000000));
+	msleep(10);
+
+	return ret;
+}
+EXPORT_SYMBOL(owl_isp_power_on);
+
+
+int owl_isp_power_off(int channel, int rear, int host_id)
+{
+    struct sensor_pwd_info *pi = to_spinfo(host_id);
+    struct dts_gpio *dgrear = &pi->gpio_rear;
+    struct dts_gpio *dgfront = &pi->gpio_front;
+    struct clk *sclk = pi->ch_clk[channel];
+
+	printk("%s():%s, channel[%d], host[%d]\n",__func__,
+        rear ? "rear" : "front", channel, host_id);
+    if (sclk) {
+        clk_disable(sclk);
+        clk_unprepare(sclk);
+    }
+
+    if (rear) {
+        gpio_direction_output(dgrear->num, dgrear->active_level);
+    } else {
+        gpio_direction_output(dgfront->num, dgfront->active_level);
+    }
+
+	return 0;
+}
+EXPORT_SYMBOL(owl_isp_power_off);
+
+
+static int get_parent_node_id(struct device_node *node,
+    const char *property, const char *stem)
+{
+    struct device_node *pnode;
+    unsigned int value = -ENODEV;
+
+    pnode = of_parse_phandle(node, property, 0);
+    if (NULL == pnode) {
+        printk(KERN_ERR "err: fail to get node[%s]\n", property);
+        return value;
+    }
+    value = of_alias_get_id(pnode, stem);
+
+    return value;
+}
+
+int parse_config_info(struct soc_camera_link *link,
+    struct dts_sensor_config *dsc, const char *name)
+{
+    struct device_node *fdt_node;
+    struct module_info *minfo = NULL;
+    const char *bus_type;
+    const char *data_type;
+
+
+    fdt_node = of_find_compatible_node(NULL, NULL, name);
+    if (NULL == fdt_node) {
+        printk(KERN_ERR "err: no sensor [%s]\n", name);
+        goto fail;
+    }
+    dsc->dn = fdt_node;
+
+    //if (of_property_read_u32(fdt_node, "rear", &dsc->rear)) {
+    //    printk(KERN_ERR "err: fail to get sensor position\n");
+    //    goto fail;
+    //}
+
+    if (of_property_read_u32(fdt_node, "channel", &dsc->channel)) {
+        printk(KERN_ERR "err: fail to get sensor channel\n");
+        goto fail;
+    }
+
+    if (of_property_read_string(fdt_node, "bus_type", &bus_type)) {
+        printk(KERN_ERR "err: faild to get sensor bus type\n");
+        goto fail;
+    }
+    if (!strcmp(bus_type, "dvp")) {
+        dsc->bus_type = V4L2_MBUS_PARALLEL;
+    } else if (!strcmp(bus_type, "mipi")) {
+        dsc->bus_type = V4L2_MBUS_CSI2;
+    } else {
+        printk(KERN_ERR "err: bus_type of sensor dts is wrong\n");
+        goto fail;
+    }
+
+    if (of_property_read_string(fdt_node, "data_type", &data_type)) {
+        printk(KERN_ERR "err: faild to get sensor output data type\n");
+        goto fail;
+    }
+    if (!strcmp(data_type, "yuv")) {
+        dsc->data_type = SENSOR_DATA_TYPE_YUV;
+    } else if (!strcmp(data_type, "raw")) {
+        dsc->data_type = SENSOR_DATA_TYPE_RAW;
+    } else {
+        printk(KERN_ERR "err: data_type of sensor dts is wrong\n");
+        goto fail;
+    }
+
+    dsc->host = get_parent_node_id(fdt_node, "host", "isp");
+    if (dsc->host < 0) {
+        printk(KERN_ERR "err: fail to get host id\n");
+        goto fail;
+    }
+
+    dsc->i2c_adapter = get_parent_node_id(fdt_node, "i2c_adapter", "i2c");
+    if (dsc->i2c_adapter < 0) {
+        printk(KERN_ERR "err: fail to get i2c adapter id\n");
+        goto fail;
+    }
+
+    if(link) {
+        minfo = link->priv;
+        link->bus_id = dsc->host;
+        link->i2c_adapter_id = dsc->i2c_adapter;
+
+        minfo->flags &= ~(SENSOR_FLAG_DTS_MASK);
+
+        if (V4L2_MBUS_PARALLEL == dsc->bus_type) {
+            minfo->flags |= SENSOR_FLAG_DVP;
+        } else {
+            minfo->flags |= SENSOR_FLAG_MIPI;
+        }
+
+        /* first logic index is 0 in driver, but 1 in spec */
+        if (ISP_CHANNEL_0 == dsc->channel) {
+            minfo->flags |= SENSOR_FLAG_CHANNEL1;
+        } else {
+            minfo->flags |= SENSOR_FLAG_CHANNEL2;
+        }
+
+        if (SENSOR_DATA_TYPE_YUV == dsc->data_type) {
+            minfo->flags |= SENSOR_FLAG_YUV;
+        } else {
+            minfo->flags |= SENSOR_FLAG_RAW;
+        }
+    }
+
+    return 0;
+
+fail:
+    return -EINVAL;
+}
+EXPORT_SYMBOL(parse_config_info);
+
diff --git a/arch/arm/mach-owl/misc-owl.c b/arch/arm/mach-owl/misc-owl.c
new file mode 100755
index 0000000..4a600c2
--- /dev/null
+++ b/arch/arm/mach-owl/misc-owl.c
@@ -0,0 +1,134 @@
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/module.h> 
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/memblock.h>
+#include <linux/device.h>
+#include <mach/hardware.h>
+
+#define GET_OWL_AFI_INFO 0
+
+extern unsigned char *g_afinfo;
+
+static int cdev_ret;
+static dev_t misc_owl_devt;
+static struct class *misc_owl_class;
+static struct device *misc_owl_dev;
+static struct cdev misc_owl_cdev;
+
+
+static int misc_owl_open(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int misc_owl_release(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int g_board_opt = 0;
+static int g_board_opt_flags = 0;
+
+static int __init boardopt_setup(char *str)
+{
+    int ints[3];
+    
+    get_options(str, 3, ints);
+    if (ints[0] != 2)
+        return 0;
+        
+    g_board_opt = ints[1];
+    g_board_opt_flags = ints[2];
+    printk("g_board_opt=%d, g_board_opt_flags=0x%x\n", g_board_opt, g_board_opt_flags);
+    return 1;
+}
+__setup("board_opt=", boardopt_setup);
+
+int owl_get_board_opt(void)
+{
+    return g_board_opt;
+}
+EXPORT_SYMBOL_GPL(owl_get_board_opt);
+
+int owl_get_board_opt_flags(void)
+{
+	return g_board_opt_flags;
+}
+EXPORT_SYMBOL_GPL(owl_get_board_opt_flags);
+
+
+static long misc_owl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    switch(cmd) {
+    case GET_OWL_AFI_INFO:
+        if(copy_to_user((char *)arg, g_afinfo, 0x400) != 0) {
+            printk("copy_to_user for owl misc failed\n");
+            return -1;
+        }
+        break;
+    
+    default:
+        return -1;
+    }
+    
+    return 0;
+}
+
+const struct file_operations misc_owl_cdev_file_operations = {
+    .open = misc_owl_open,
+    .release = misc_owl_release,
+    .unlocked_ioctl = misc_owl_ioctl,
+};
+
+static int __init misc_owl_init(void)
+{
+    int ret;
+
+    misc_owl_devt = MKDEV(90, 0);
+    ret = register_chrdev_region(misc_owl_devt, 1, "miscowl");
+    if (ret != 0) {
+        printk("misc_owl register_chrdev_region err: %d\n", ret);
+        return -1;
+    }
+
+    cdev_init(&misc_owl_cdev, &misc_owl_cdev_file_operations);
+    cdev_ret = cdev_add(&misc_owl_cdev, misc_owl_devt, 1);
+    if (cdev_ret != 0) {
+        printk("Unable to get misc_owl major %d\n", 92);
+        goto err;
+    }
+
+    /* create your own class under /sysfs */
+    misc_owl_class = class_create(THIS_MODULE, "miscowl");
+    if (IS_ERR(misc_owl_class)) {
+        printk("misc_owl: failed in creating class.\n");
+        goto err;
+    }
+
+    /* register your own device in sysfs, and this will cause udev to create corresponding device node */
+    misc_owl_dev = device_create(misc_owl_class, NULL, misc_owl_devt, NULL, "miscowl");
+    if (IS_ERR(misc_owl_dev)) {
+        printk("misc_owl: failed in creating device.\n");
+        goto err;
+    }
+
+    return 0;
+    
+err:
+    if (!IS_ERR(misc_owl_dev))
+        device_del(misc_owl_dev);
+    if (!IS_ERR(misc_owl_class))
+        class_destroy(misc_owl_class);
+    if (cdev_ret == 0)
+        cdev_del(&misc_owl_cdev);
+    unregister_chrdev_region(misc_owl_devt, 1);
+    
+    return -1;
+}
+
+late_initcall(misc_owl_init);
+
diff --git a/arch/arm/mach-owl/pinctrl-owl.c b/arch/arm/mach-owl/pinctrl-owl.c
new file mode 100755
index 0000000..5b2b877
--- /dev/null
+++ b/arch/arm/mach-owl/pinctrl-owl.c
@@ -0,0 +1,112 @@
+/*
+ * arch/arm/mach-owl/pinctrl-owl.c
+ *
+ * Pinctrl driver based on Actions SOC pinctrl
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include "pinctrl_common-owl.h"
+#include "pinctrl_data-owl.h"
+
+#define DRIVER_NAME "pinctrl-owl"
+
+static struct pinctrl_gpio_range owl_gpio_ranges[] = {
+	{
+		.name = "owl-gpio",
+		.id = 0,
+		.base = 0,
+		.pin_base = 0,
+		.npins = NR_OWL_GPIO,
+	},
+};
+
+static struct owl_pinctrl_soc_info atm7059_pinctrl_info = {
+	.gpio_ranges = owl_gpio_ranges,
+	.gpio_num_ranges = ARRAY_SIZE(owl_gpio_ranges),
+	.padinfo = atm7059_pad_tab,
+	.pins = (const struct pinctrl_pin_desc *)atm7059_pads,
+//	.npins = atm7059_num_pads,
+	.functions = atm7059_functions,
+//	.nfunctions = atm7059_num_functions,
+	.groups = atm7059_groups,
+//	.ngroups = atm7059_num_groups,
+	.owl_gpio_pad_data = &atm7059_gpio_pad_data,
+};
+
+static struct of_device_id owl_pinctrl_of_match[] = {
+	{ .compatible = "actions,atm7059a-pinctrl", .data = &atm7059_pinctrl_info},
+	{ },
+};
+
+static int owl_pinctrl_probe(struct platform_device *pdev)
+{
+	struct owl_pinctrl_soc_info *owl_pinctrl_info;
+
+	const struct of_device_id *id = of_match_device(owl_pinctrl_of_match, &pdev->dev);
+	if(id == NULL)
+		return -EINVAL;
+
+	owl_pinctrl_info = (struct owl_pinctrl_soc_info *)id->data;
+	if(owl_pinctrl_info == &atm7059_pinctrl_info)
+	{
+		owl_pinctrl_info->npins = atm7059_num_pads;
+		owl_pinctrl_info->nfunctions = atm7059_num_functions;
+		owl_pinctrl_info->ngroups = atm7059_num_groups;
+	}
+	else
+		return -EINVAL;
+
+	return owl_pinctrl_common_probe(pdev, owl_pinctrl_info);
+}
+
+
+static struct platform_driver owl_pinctrl_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = owl_pinctrl_of_match,
+	},
+	.probe = owl_pinctrl_probe,
+	.remove = owl_pinctrl_common_remove,
+};
+
+static int __init owl_pinctrl_init(void)
+{
+	return platform_driver_register(&owl_pinctrl_driver);
+}
+arch_initcall(owl_pinctrl_init);
+
+static void __exit owl_pinctrl_exit(void)
+{
+	platform_driver_unregister(&owl_pinctrl_driver);
+}
+module_exit(owl_pinctrl_exit);
+
+MODULE_AUTHOR("Actions Semi Inc.");
+MODULE_DESCRIPTION("Pin control driver for Actions SOC");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-owl/pinctrl_common-owl.c b/arch/arm/mach-owl/pinctrl_common-owl.c
new file mode 100755
index 0000000..a02886b
--- /dev/null
+++ b/arch/arm/mach-owl/pinctrl_common-owl.c
@@ -0,0 +1,1196 @@
+/*
+ * arch/arm/mach-owl/pinctrl_common-owl.c
+ *
+ * Pinctrl driver for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include "pinctrl_common-owl.h"
+#include "pinctrl_data-owl.h"
+#include <../drivers/pinctrl/core.h>
+
+struct owl_pinctrl {
+	struct device *dev;
+	struct pinctrl_dev *pctl;
+	const struct owl_pinctrl_soc_info *info;
+};
+
+#ifdef CONFIG_GPIOLIB
+extern spinlock_t owl_gpio_lock;
+#else 
+static DEFINE_SPINLOCK(owl_gpio_lock);
+#endif
+
+#define MFP_CTL_REG(i)    (MFP_CTL0 + (MFP_CTL1 - MFP_CTL0) * (i))
+#define PAD_ST_REG(i)     (PAD_ST0 + (PAD_ST1 - PAD_ST0) * (i))
+#define PAD_PULLCTL_REG(i) (PAD_PULLCTL0 + (PAD_PULLCTL1 - PAD_PULLCTL0) *(i))
+#define PAD_DRV_REG(i)    (PAD_DRV0 + (PAD_DRV1 - PAD_DRV0) * (i))
+#define GPIO_OUTEN_REG(i) (GPIO_AOUTEN + (GPIO_BOUTEN - GPIO_AOUTEN) * (i))
+#define GPIO_INEN_REG(i)  (GPIO_AINEN + (GPIO_BINEN - GPIO_AINEN) * (i))
+#define GPIO_DAT_REG(i)   (GPIO_ADAT + (GPIO_BDAT - GPIO_ADAT) * (i))
+
+#define PINCTRL_PULLREGS	3
+#define PINCTRL_DRVREGS		3
+
+struct dupcode {
+	u32 regaddr;
+	u32 regmask;
+
+	u32 regval;
+	int refcnt;
+};
+
+static struct dupcode mfp_dupcodes[] = {
+	{MFP_CTL0, (0x1 << 2), 0, 0},
+	{MFP_CTL1, (0x7 << 29), 0, 0},
+	{MFP_CTL1, (0x7 << 26), 0, 0},
+};
+
+static int mfp_dupcode_cnt = ARRAY_SIZE(mfp_dupcodes);
+
+/* part 1, pinctrl groups */
+static const struct owl_gpio_pad_data *owl_gpio_pad_data = NULL;
+
+static void owl_gpio_pad_set(int gpio, int val)
+{
+	int i;
+	unsigned long irq_flags;
+	unsigned int dat;
+
+	if(owl_gpio_pad_data == NULL)
+		return;
+    
+	for(i = 0; i < owl_gpio_pad_data->size; i++) {
+		if(owl_gpio_pad_data->gpio_pads[i].gpio == gpio) {
+			spin_lock_irqsave(&owl_gpio_lock, irq_flags);
+			if(val) {
+				owl_gpio_pad_data->gpio_pads[i].ref_count++;
+				if(owl_gpio_pad_data->gpio_pads[i].ref_count != 1) {
+					spin_unlock_irqrestore(&owl_gpio_lock, irq_flags);
+					return;
+				}
+			}
+			else {
+				owl_gpio_pad_data->gpio_pads[i].ref_count--;
+				if(owl_gpio_pad_data->gpio_pads[i].ref_count != 0) {
+					spin_unlock_irqrestore(&owl_gpio_lock, irq_flags);
+					return;
+				}
+			}
+			dat = act_readl(SPS_PWR_CTL) & (~owl_gpio_pad_data->gpio_pads[i].mask);
+			dat |= val << owl_gpio_pad_data->gpio_pads[i].bit;
+			act_writel(dat, owl_gpio_pad_data->gpio_pads[i].reg);
+			spin_unlock_irqrestore(&owl_gpio_lock, irq_flags);
+			return;
+		}
+	}
+}
+
+static void owl_gpio_pad_enable(int gpio)
+{
+	owl_gpio_pad_set(gpio, 1);
+}
+
+static void owl_gpio_pad_disable(int gpio)
+{
+	owl_gpio_pad_set(gpio, 0);
+}
+
+
+static int owl_pctlops_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct owl_pinctrl_soc_info *info = apctl->info;
+
+	PINCTRL_DBG("%s\n", __FUNCTION__);
+
+	return info->ngroups;
+}
+
+static const char *owl_pctlops_get_group_name(struct pinctrl_dev *pctldev,
+	unsigned selector)
+{
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct owl_pinctrl_soc_info *info = apctl->info;
+
+	PINCTRL_DBG("%s(selector:%d)\n", __FUNCTION__, selector);
+
+	return info->groups[selector].name;
+}
+
+static int owl_pctlops_get_group_pins(struct pinctrl_dev *pctldev, 
+	unsigned selector, const unsigned **pins, unsigned *num_pins)
+{
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct owl_pinctrl_soc_info *info = apctl->info;
+
+	PINCTRL_DBG("%s(selector:%d)\n", __FUNCTION__, selector);
+
+	if (selector >= info->ngroups)
+		return -EINVAL;
+
+	*pins = info->groups[selector].pads;
+	*num_pins = info->groups[selector].padcnt;
+
+	return 0;
+}
+
+static void owl_pctlops_pin_dbg_show(struct pinctrl_dev *pctldev,
+	struct seq_file *s, unsigned offset)
+{
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+
+	seq_printf(s, "%s", dev_name(apctl->dev));
+}
+
+static int reserve_map(struct device *dev, struct pinctrl_map **map,
+		       unsigned *reserved_maps, unsigned *num_maps,
+		       unsigned reserve)
+{
+	unsigned old_num = *reserved_maps;
+	unsigned new_num = *num_maps + reserve;
+	struct pinctrl_map *new_map;
+
+	if (old_num >= new_num)
+		return 0;
+
+	new_map = krealloc(*map, sizeof(*new_map) * new_num, GFP_KERNEL);
+	if (!new_map) {
+		dev_err(dev, "krealloc(map) failed\n");
+		return -ENOMEM;
+	}
+
+	memset(new_map + old_num, 0, (new_num - old_num) * sizeof(*new_map));
+
+	*map = new_map;
+	*reserved_maps = new_num;
+
+	return 0;
+}
+
+static int add_map_mux(struct pinctrl_map **map, unsigned *reserved_maps,
+		       unsigned *num_maps, const char *group,
+		       const char *function)
+{
+	if (WARN_ON(*num_maps == *reserved_maps))
+		return -ENOSPC;
+
+	(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;
+	(*map)[*num_maps].data.mux.group = group;
+	(*map)[*num_maps].data.mux.function = function;
+	(*num_maps)++;
+
+	return 0;
+}
+
+static int add_map_group_configs(struct device *dev, struct pinctrl_map **map,
+			   unsigned *reserved_maps, unsigned *num_maps,
+			   const char *group, unsigned long *configs,
+			   unsigned num_configs)
+{
+	unsigned long *dup_configs;
+
+	if (WARN_ON(*num_maps == *reserved_maps))
+		return -ENOSPC;
+
+	dup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),
+			      GFP_KERNEL);
+	if (!dup_configs) {
+		dev_err(dev, "kmemdup(configs) failed\n");
+		return -ENOMEM;
+	}
+
+	(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_GROUP;
+	(*map)[*num_maps].data.configs.group_or_pin = group;
+	(*map)[*num_maps].data.configs.configs = dup_configs;
+	(*map)[*num_maps].data.configs.num_configs = num_configs;
+	(*num_maps)++;
+
+	return 0;
+}
+
+static int add_map_pin_configs(struct device *dev, struct pinctrl_map **map,
+			   unsigned *reserved_maps, unsigned *num_maps,
+			   const char *pin, unsigned long *configs,
+			   unsigned num_configs)
+{
+	unsigned long *dup_configs;
+
+	if (WARN_ON(*num_maps == *reserved_maps))
+		return -ENOSPC;
+
+	dup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),
+			      GFP_KERNEL);
+	if (!dup_configs) {
+		dev_err(dev, "kmemdup(configs) failed\n");
+		return -ENOMEM;
+	}
+
+	(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_PIN;
+	(*map)[*num_maps].data.configs.group_or_pin = pin;
+	(*map)[*num_maps].data.configs.configs = dup_configs;
+	(*map)[*num_maps].data.configs.num_configs = num_configs;
+	(*num_maps)++;
+
+	return 0;
+}
+
+
+static int add_config(struct device *dev, unsigned long **configs,
+		      unsigned *num_configs, unsigned long config)
+{
+	unsigned old_num = *num_configs;
+	unsigned new_num = old_num + 1;
+	unsigned long *new_configs;
+
+	new_configs = krealloc(*configs, sizeof(*new_configs) * new_num,
+			       GFP_KERNEL);
+	if (!new_configs) {
+		dev_err(dev, "krealloc(configs) failed\n");
+		return -ENOMEM;
+	}
+
+	new_configs[old_num] = config;
+
+	*configs = new_configs;
+	*num_configs = new_num;
+
+	return 0;
+}
+
+static void owl_pinctrl_dt_free_map(struct pinctrl_dev *pctldev,
+				      struct pinctrl_map *map,
+				      unsigned num_maps)
+{
+	int i;
+
+	for (i = 0; i < num_maps; i++)
+		if (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP || map[i].type == PIN_MAP_TYPE_CONFIGS_PIN)
+			kfree(map[i].data.configs.configs);
+
+	kfree(map);
+}
+
+struct cfg_param {
+	const char *property;
+	enum owl_pinconf_param param;
+};
+
+static const struct cfg_param cfg_params[] = {
+	{"actions,pull",			OWL_PINCONF_PARAM_PULL},
+	{"actions,paddrv",		OWL_PINCONF_PARAM_PADDRV},
+};
+
+static int owl_pinctrl_dt_subnode_to_map(struct device *dev,
+					   struct device_node *np,
+					   struct pinctrl_map **map,
+					   unsigned *reserved_maps,
+					   unsigned *num_maps)
+{
+	int ret, i;
+	const char *function;
+	u32 val;
+	unsigned long config;
+	unsigned long *configs = NULL;
+	unsigned num_configs = 0;
+	unsigned reserve;
+	struct property *prop;
+	int groups_prop_num;
+	int pins_prop_num;
+	int groups_or_pins_prop_num;
+
+	ret = of_property_read_string(np, "actions,function", &function);
+	if (ret < 0) {
+		/* EINVAL=missing, which is fine since it's optional */
+		if (ret != -EINVAL)
+			dev_err(dev,
+				"could not parse property actions,function\n");
+		function = NULL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(cfg_params); i++) {
+		ret = of_property_read_u32(np, cfg_params[i].property, &val);
+		if (!ret) {
+			config = OWL_PINCONF_PACK(cfg_params[i].param, val);
+			ret = add_config(dev, &configs, &num_configs, config);
+			if (ret < 0)
+				goto exit;
+		/* EINVAL=missing, which is fine since it's optional */
+		} else if (ret != -EINVAL) {
+			dev_err(dev, "could not parse property %s\n",
+				cfg_params[i].property);
+		}
+	}
+
+	reserve = 0;
+	if (function != NULL)
+		reserve++;
+	if (num_configs)
+		reserve++;
+
+	ret = of_property_count_strings(np, "actions,pins");
+	if (ret < 0) {
+		if (ret != -EINVAL)
+			dev_err(dev, "could not parse property actions,pins\n");
+
+		pins_prop_num = 0;
+	} else {
+		pins_prop_num = ret;
+	}
+
+	if(pins_prop_num > 0 && function != NULL) {
+		dev_err(dev, "could not assign actions,pins to function\n");
+		goto exit;
+	}
+
+	ret = of_property_count_strings(np, "actions,groups");
+	if (ret < 0) {
+		if (ret != -EINVAL)
+			dev_err(dev, "could not parse property actions,groups\n");
+
+		groups_prop_num = 0;
+	} else {
+		groups_prop_num = ret;
+	}
+
+	groups_or_pins_prop_num = groups_prop_num + pins_prop_num;
+	if(groups_or_pins_prop_num == 0) {
+		dev_err(dev, "no property actions,pins or actions,groups\n");
+		goto exit;
+	}
+	
+	reserve *= groups_or_pins_prop_num;
+
+	ret = reserve_map(dev, map, reserved_maps, num_maps, reserve);
+	if (ret < 0)
+		goto exit;
+
+	if(groups_prop_num > 0) {
+		const char *group;
+		of_property_for_each_string(np, "actions,groups", prop, group) {
+			if (function) {
+				ret = add_map_mux(map, reserved_maps, num_maps,
+						  group, function);
+				if (ret < 0)
+					goto exit;
+			}
+
+			if (num_configs) {
+				ret = add_map_group_configs(dev, map, reserved_maps,
+						      num_maps, group, configs,
+						      num_configs);
+				if (ret < 0)
+					goto exit;
+			}
+		}
+	}
+
+	if(pins_prop_num > 0) {
+		const char *pin;
+		of_property_for_each_string(np, "actions,pins", prop, pin) {
+			if (num_configs) {
+				ret = add_map_pin_configs(dev, map, reserved_maps,
+						      num_maps, pin, configs,
+						      num_configs);
+				if (ret < 0)
+					goto exit;
+			}
+		}
+	}
+
+	ret = 0;
+
+exit:
+	kfree(configs);
+	return ret;
+}
+
+static int owl_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,
+					struct device_node *np_config,
+					struct pinctrl_map **map,
+					unsigned *num_maps)
+{
+	unsigned reserved_maps;
+	struct device_node *np;
+	int ret;
+
+	reserved_maps = 0;
+	*map = NULL;
+	*num_maps = 0;
+
+	for_each_child_of_node(np_config, np) {
+		ret = owl_pinctrl_dt_subnode_to_map(pctldev->dev, np, map,
+						      &reserved_maps, num_maps);
+		if (ret < 0) {
+			owl_pinctrl_dt_free_map(pctldev, *map, *num_maps);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+
+
+static struct pinctrl_ops owl_pctlops_ops = {
+	.get_groups_count = owl_pctlops_get_groups_count,
+	.get_group_name = owl_pctlops_get_group_name,
+	.get_group_pins = owl_pctlops_get_group_pins,
+	.pin_dbg_show = owl_pctlops_pin_dbg_show,
+	.dt_node_to_map = owl_pinctrl_dt_node_to_map,
+	.dt_free_map = owl_pinctrl_dt_free_map,
+
+};
+
+
+/* part 2, pinctrl pinmux */
+
+static int inc_dupcode(struct dupcode *code, 
+					u32 group_regaddr, u32 group_mask, u32 group_val)
+{
+	int comaskfound;
+	unsigned int comask;
+	unsigned int coval;
+	
+	comaskfound=0;
+
+	if(code->regaddr != group_regaddr)
+		return 0;
+
+	PINCTRL_DBG("%s\n", __FUNCTION__);
+
+	comask = (group_mask & code->regmask);
+	if (comask) {
+		if (comask != code->regmask)  {
+			PINCTRL_DBG("dupcode mask error !\n");
+			PINCTRL_DBG("group reg<0x%x> mask = 0x%x !\n",group_regaddr, group_mask);
+			PINCTRL_DBG("code mask = 0x%x!\n", code->regmask);
+			return -1;
+		}
+		comaskfound=1;
+	} else {
+		return 0;
+	}
+
+	if (comaskfound) {
+		if (code->refcnt > 0) {
+			coval = (code->regmask & group_val);
+ 			if (coval != code->regval)  {
+				PINCTRL_DBG("dupcode coval error !\n");
+				PINCTRL_DBG("group reg<0x%x> val = 0x%x !\n",group_regaddr, group_val);
+				PINCTRL_DBG("code val = 0x%x!\n", code->regval);
+
+				return -1;
+			}
+			code->refcnt++;
+		} else {
+			coval = (code->regmask & group_val);
+ 			code->regval = coval;
+			code->refcnt = 1;
+		}
+	}
+
+	PINCTRL_DBG("dup reg<0x%x> mask = 0x%x, val = 0x%x, refcnt = %d\n",
+			code->regaddr, code->regmask, code->regval, code->refcnt);
+	return comaskfound;
+}
+
+static int lookup_dupcode_idx(struct dupcode *code, int dupcode_num, 
+						u32 group_regaddr, u32 group_mask)
+{
+	int i;
+
+	for(i = 0; i < dupcode_num; i++) {
+		if((code[i].regaddr == group_regaddr) && 
+			(group_mask & code[i].regmask))
+			return i;
+	}
+
+	return -1;
+}
+
+static inline int get_group_mfp_mask_val(const struct owl_group *g, int function, u32 *mask, u32 *val)
+{
+	int i;
+	u32 option_num;
+	u32 option_mask;
+
+	for (i = 0; i < g->nfuncs; i++) {
+		if (g->funcs[i] == function)
+			break;
+	}
+	if (WARN_ON(i == g->nfuncs))
+		return -EINVAL;
+
+	option_num = (1 << g->mfpctl_width);
+	if(i > option_num)
+		i -= option_num;
+
+	option_mask = option_num - 1;
+ 	*mask = (option_mask  << g->mfpctl_shift);
+	*val = (i << g->mfpctl_shift);
+
+	return 0;
+
+}
+
+static int pinmux_request_check_gpio(struct pinctrl_dev *pctldev, u32 pin)
+{
+	struct pin_desc *desc;
+	desc = pin_desc_get(pctldev, pin);
+
+	if(desc->gpio_owner){
+		PINCTRL_ERR(KERN_ALERT "%s\n", __FUNCTION__);
+		PINCTRL_ERR(KERN_ALERT "CHECK PMX:%s has already been requested by %s",
+				desc->name, desc->gpio_owner);
+	}
+
+	return 0;
+}
+
+static int gpio_request_check_pinmux(struct pinctrl_dev *pctldev, u32 pin)
+{
+	struct pin_desc *desc;
+	desc = pin_desc_get(pctldev, pin);
+
+	if(desc->mux_owner){
+		PINCTRL_ERR("%s\n", __FUNCTION__);
+		PINCTRL_ERR("CHECK PMX:%s has already been requested by %s",
+				desc->name, desc->mux_owner);
+	}
+
+	return 0;
+}
+
+static int owl_pmxops_request(struct pinctrl_dev *pctldev, unsigned pin)
+{
+	return pinmux_request_check_gpio(pctldev, pin);
+}
+
+static int owl_pmxops_enable(struct pinctrl_dev *pctldev,
+	unsigned function, unsigned group)
+{
+	const struct owl_group *g;
+	int ret = 0;
+	int i;
+	int inc;
+	int mfpdup_idx;
+	int need_schimtt = 0;
+	u32 group_schimtt_val[PINCTRL_STREGS] = {0};
+	u32 group_schimtt_mask[PINCTRL_STREGS] = {0};
+
+	u32 g_val;
+	u32 g_mask;
+
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct owl_pinctrl_soc_info *info = apctl->info;
+
+
+ 	PINCTRL_DBG("%s function:%d '%s', group:%d '%s'\n", __FUNCTION__,
+       		function, info->functions[function].name,
+       		group, info->groups[group].name);
+
+	g = &info->groups[group];
+
+	if(g->mfpctl_regnum >= 0) {
+		u32 mfpval;
+
+		if(get_group_mfp_mask_val(g, function, &g_mask, &g_val)){
+			return -EINVAL;
+		}
+
+		mfpdup_idx = lookup_dupcode_idx(mfp_dupcodes, mfp_dupcode_cnt, 
+						MFP_CTL_REG(g->mfpctl_regnum), g_mask);
+
+		if(mfpdup_idx >= 0) {
+			inc = inc_dupcode(&mfp_dupcodes[mfpdup_idx], 
+					MFP_CTL_REG(g->mfpctl_regnum), g_mask, g_val);
+			if (inc < 0) {
+				ret = -EINVAL;
+				goto pmxen_fail;
+			}
+		}
+
+		/*******we've done all the checkings. From now on ,we will set hardware.*****************/
+		/*******No more errors should happen, otherwise it will be hard to roll back***************/
+		mfpval = act_readl(MFP_CTL_REG(g->mfpctl_regnum));
+		PINCTRL_DBG("read mfpval = 0x%x\n", mfpval);
+		mfpval &= (~ g_mask);
+		mfpval |= g_val;
+		PINCTRL_DBG("write mfpval = 0x%x\n", mfpval);
+		act_writel(mfpval, MFP_CTL_REG(g->mfpctl_regnum));
+		PINCTRL_DBG("read mfpval again = 0x%x\n",
+				act_readl(MFP_CTL_REG(g->mfpctl_regnum)));
+	}
+
+	/*check each pad of this group for schimtt info, fill the group_schimtt_mask & group_schimtt_val*/
+	for(i = 0; i < g->padcnt; i++) {
+		int pad_num;
+		const struct owl_pinconf_pad_info *pad_info;
+		struct owl_pinconf_schimtt *schimtt_info;
+
+		pad_num = g->pads[i];
+		pad_info = info->padinfo;
+
+		owl_gpio_pad_enable(pad_info[pad_num].gpio);
+			
+		schimtt_info = pad_info[pad_num].schimtt;
+
+		if(schimtt_info && schimtt_info->reg_num >= 0) {
+			int j;
+
+			need_schimtt = 1;
+
+			group_schimtt_mask[schimtt_info->reg_num] |= (1 << schimtt_info->shift);
+
+			for(j = 0; j < schimtt_info->num_schimtt_funcs; j++) {
+				if(schimtt_info->schimtt_funcs[j] == function) {
+					group_schimtt_val[schimtt_info->reg_num] |= (1 << schimtt_info->shift);
+					break;
+				}
+			}
+		}
+	}
+
+	/*set schimtt val*/
+	if(need_schimtt){
+		u32 val;
+		u32 reg;
+		for(i = 0; i < PINCTRL_STREGS; i++) {
+			if(group_schimtt_mask[i] != 0) {
+				reg = PAD_ST_REG(i);
+				val = act_readl(reg);
+				val &= (~group_schimtt_mask[i]);
+				val |= group_schimtt_val[i];
+				act_writel(val, reg);
+			}
+		}
+	}
+
+	return 0;
+
+pmxen_fail:
+	return ret;
+}
+
+static int owl_pmxops_get_funcs_count(struct pinctrl_dev *pctldev)
+{
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct owl_pinctrl_soc_info *info = apctl->info;
+
+	PINCTRL_DBG("%s\n", __FUNCTION__);
+
+	return info->nfunctions;
+}
+
+static const char *owl_pmxops_get_func_name(struct pinctrl_dev *pctldev,
+	unsigned selector)
+{
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct owl_pinctrl_soc_info *info = apctl->info;
+
+	PINCTRL_DBG("%s(selector:%d) name %s\n", __FUNCTION__, selector,
+		info->functions[selector].name);
+
+	return info->functions[selector].name;
+}
+
+static int owl_pmxops_get_groups(struct pinctrl_dev *pctldev,
+	unsigned selector, const char * const **groups,
+	unsigned * const num_groups)
+{
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct owl_pinctrl_soc_info *info = apctl->info;
+
+	PINCTRL_DBG("%s(selector:%d)\n", __FUNCTION__, selector);
+
+	*groups = info->functions[selector].groups;
+	*num_groups = info->functions[selector].ngroups;
+
+	return 0;
+}
+
+static int owl_pmxops_gpio_request_enable (struct pinctrl_dev *pctldev,
+	struct pinctrl_gpio_range *range, unsigned offset)
+{
+	if (range->id == 0 && range->base == 0) {
+		u32 gpio_num;
+		
+		gpio_num = offset - range->pin_base + range->base;
+		owl_gpio_pad_enable(gpio_num);
+	}
+	return gpio_request_check_pinmux(pctldev, offset);
+}
+
+static void owl_pmxops_gpio_disable_free (struct pinctrl_dev *pctldev,
+	struct pinctrl_gpio_range *range, unsigned offset)
+{
+	int bank;
+	unsigned long tmp;
+	unsigned long mask;
+	unsigned long flags;
+	u32 gpio_num;
+
+	if (range->id == 0 && range->base == 0) {
+		gpio_num = offset - range->pin_base + range->base;
+		bank = (gpio_num >> 5);
+		mask = (1 << (gpio_num & 0x1f));
+		if (bank < 5) {
+			spin_lock_irqsave(&owl_gpio_lock, flags);
+
+			tmp = act_readl(GPIO_INEN_REG(bank));
+			tmp &= ~mask;
+			act_writel(tmp, GPIO_INEN_REG(bank));
+
+			tmp = act_readl(GPIO_OUTEN_REG(bank));
+			tmp &= ~mask;
+			act_writel(tmp, GPIO_OUTEN_REG(bank));
+
+			spin_unlock_irqrestore(&owl_gpio_lock, flags);
+		}
+		owl_gpio_pad_disable(gpio_num);
+	}
+}
+
+static struct pinmux_ops owl_pmxops_ops = {
+	.get_functions_count = owl_pmxops_get_funcs_count,
+	.get_function_name = owl_pmxops_get_func_name,
+	.get_function_groups = owl_pmxops_get_groups,
+	.set_mux = owl_pmxops_enable,
+	.request = owl_pmxops_request,
+	.gpio_request_enable = owl_pmxops_gpio_request_enable,
+	.gpio_disable_free = owl_pmxops_gpio_disable_free,
+};
+
+/* part 3, pinctrl pinconfs */
+
+#ifdef SOC_HAVE_OWL_MATCH_GPIO_RANGE
+static struct pinctrl_gpio_range *owl_match_gpio_range(
+	struct pinctrl_dev *pctldev, unsigned pin)
+{
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	int i;
+
+	for (i = 0; i < apctl->info->gpio_num_ranges; i++) {
+		struct pinctrl_gpio_range *range;
+
+		range = &apctl->info->gpio_ranges[i];
+		if (pin >= range->pin_base &&
+			pin <= (range->pin_base + range->npins - 1))
+			return range;
+	}
+	return NULL;
+}
+#endif
+
+static int owl_group_pinconf_reg(const struct owl_group *g, 
+								enum owl_pinconf_param param, 
+								u32 *reg, u32 *bit, u32 *width)
+{
+	switch (param) {
+	case OWL_PINCONF_PARAM_PADDRV:
+		if(g->paddrv_regnum < 0)
+			return -EINVAL;
+
+		*reg = PAD_DRV_REG(g->paddrv_regnum);
+		*bit = g->paddrv_shift;
+		*width = g->paddrv_width;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+	
+}
+
+static int owl_group_pinconf_arg2val(const struct owl_group *g,
+									enum owl_pinconf_param param, 
+									u32 arg, u32 *val)
+{
+	switch (param) {
+	case OWL_PINCONF_PARAM_PADDRV:
+		*val = arg;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int owl_group_pinconf_val2arg(const struct owl_group *g,
+									enum owl_pinconf_param param, 
+									u32 val, u32 *arg)
+{
+	switch (param) {
+	case OWL_PINCONF_PARAM_PADDRV:
+		*arg = val;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int owl_pad_pinconf_reg(const struct owl_pinconf_pad_info *pad,
+								enum owl_pinconf_param param,
+								u32 *reg, u32 *bit, u32 *width)
+{
+	switch (param) {
+	case OWL_PINCONF_PARAM_PULL:
+		if((!pad->pull) || (pad->pull->reg_num < 0))
+			return -EINVAL;
+		
+		*reg = PAD_PULLCTL_REG(pad->pull->reg_num);
+		*bit = pad->pull->shift;
+		*width = pad->pull->width;
+		break;
+	case OWL_PINCONF_PARAM_SCHMITT:
+		PINCTRL_ERR("Cannot configure pad schmitt yet!\n");
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int owl_pad_pinconf_arg2val(const struct owl_pinconf_pad_info *pad,
+									enum owl_pinconf_param param, 
+									u32 arg, u32 *val)
+{
+	switch (param) {
+	case OWL_PINCONF_PARAM_PULL:
+		switch(arg) {
+		case OWL_PINCONF_PULL_NONE:
+			*val = 0;
+			break;
+		case OWL_PINCONF_PULL_DOWN:
+			if(pad->pull->pulldown)
+				*val = pad->pull->pulldown;
+			else
+				return -EINVAL;
+			break;
+		case OWL_PINCONF_PULL_UP:
+			if(pad->pull->pullup)
+				*val = pad->pull->pullup;
+			else
+				return -EINVAL;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		break;
+
+	case OWL_PINCONF_PARAM_SCHMITT:
+		PINCTRL_ERR("Cannot configure pad schmitt yet!\n");
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int owl_pad_pinconf_val2arg(const struct owl_pinconf_pad_info *pad,
+									enum owl_pinconf_param param, 
+									u32 val, u32 *arg)
+{
+	switch (param) {
+	case OWL_PINCONF_PARAM_PULL:
+		if(pad->pull->pulldown && (val == pad->pull->pulldown))
+			*arg = OWL_PINCONF_PULL_DOWN;
+		else if(pad->pull->pullup && (val == pad->pull->pullup))
+			*arg = OWL_PINCONF_PULL_UP;
+		else if(val == 0)
+			*arg = OWL_PINCONF_PULL_NONE;
+		else
+			return -EINVAL;
+
+		break;
+
+	case OWL_PINCONF_PARAM_SCHMITT:
+		PINCTRL_ERR("Cannot configure pad schmitt yet!\n");
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+
+static int owl_confops_pin_config_get(struct pinctrl_dev *pctldev,
+	unsigned pin, unsigned long *config)
+{
+	int ret;
+	struct owl_pinctrl *apctl;
+	const struct owl_pinctrl_soc_info *info;
+	const struct owl_pinconf_pad_info *pad_tab;
+	u32 reg = 0, bit = 0, width = 0;
+	u32 val, mask;
+	u32 tmp;
+	u32 arg = 0;
+	enum owl_pinconf_param param = OWL_PINCONF_UNPACK_PARAM(*config);
+
+	PINCTRL_DBG("%s(pin:%d)\n", __FUNCTION__, pin);
+
+	apctl = pinctrl_dev_get_drvdata(pctldev);  
+	info = apctl->info;         
+	pad_tab = &info->padinfo[pin];                                                                    
+	PINCTRL_DBG("%s(pin:%d)\n", __FUNCTION__, pin);
+	/* We get config for those pins we CAN get it for and that's it */
+
+	ret = owl_pad_pinconf_reg(pad_tab, param, &reg, &bit, &width);
+	if(ret)
+		return ret;
+
+	tmp = act_readl(reg);
+	mask = (1 << width) - 1;
+	val = (tmp >> bit) & mask;
+
+	ret = owl_pad_pinconf_val2arg(pad_tab, param, val, &arg);
+	if(ret)
+		return ret;
+
+	*config = OWL_PINCONF_PACK(param, arg);
+
+	return ret;
+}
+
+static int owl_confops_pin_config_set(struct pinctrl_dev *pctldev,
+	unsigned pin, unsigned long *configs, unsigned num_configs)
+{
+	int ret;
+	struct owl_pinctrl *apctl;
+	const struct owl_pinctrl_soc_info *info;
+	const struct owl_pinconf_pad_info *pad_tab;
+	u32 reg = 0, bit = 0, width = 0;
+	u32 val = 0, mask = 0;
+	u32 tmp;
+	int i = 0;
+
+	for (i = 0; i < num_configs; i++) {
+		enum owl_pinconf_param param = OWL_PINCONF_UNPACK_PARAM(configs[i]);
+		u32 arg = OWL_PINCONF_UNPACK_ARG(configs[i]);
+
+		PINCTRL_DBG("%s(pin:%d, config:%ld)\n", __FUNCTION__, pin, configs[i]);
+ 
+		apctl = pinctrl_dev_get_drvdata(pctldev);  
+		info = apctl->info;         
+		pad_tab = &info->padinfo[pin];                                                                    
+		PINCTRL_DBG("%s(pin:%d)\n", __FUNCTION__, pin);
+
+		ret = owl_pad_pinconf_reg(pad_tab, param, &reg, &bit, &width);
+		if(ret)
+			return ret;
+
+		ret = owl_pad_pinconf_arg2val(pad_tab, param, arg, &val);
+		if(ret)
+			return ret;
+
+		/* Update register */
+		mask = (1 << width) - 1;
+		mask = mask << bit;
+		tmp = act_readl(reg);
+		tmp &= ~mask;
+		tmp |= val << bit;
+		act_writel(tmp, reg);
+	}
+
+	return ret;
+}
+
+static int owl_confops_group_config_get(struct pinctrl_dev *pctldev,
+				   unsigned group, unsigned long *config)
+{
+	int ret = 0;
+	const struct owl_group *g;
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct owl_pinctrl_soc_info *info = apctl->info;
+	u32 reg, bit, width;
+	u32 val, mask;
+	u32 tmp;
+	u32 arg = 0;
+	enum owl_pinconf_param param = OWL_PINCONF_UNPACK_PARAM(*config);
+
+	g = &info->groups[group];
+
+	ret = owl_group_pinconf_reg(g, param, &reg, &bit, &width);
+	if(ret)
+		return ret;
+
+	tmp = act_readl(reg);
+	mask = (1 << width) - 1;
+	val = (tmp >> bit) & mask;
+
+	ret = owl_group_pinconf_val2arg(g, param, val, &arg);
+	if(ret)
+		return ret;
+
+	*config = OWL_PINCONF_PACK(param, arg);
+
+	return ret;
+		
+}
+
+static int owl_confops_group_config_set(struct pinctrl_dev *pctldev,
+				   unsigned group, unsigned long *configs,unsigned num_configs)
+{
+	int ret = 0;
+	const struct owl_group *g;
+	struct owl_pinctrl *apctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct owl_pinctrl_soc_info *info = apctl->info;
+	u32 reg, bit, width;
+	u32 val, mask;
+	u32 tmp;
+	int i = 0;
+
+	for (i = 0; i < num_configs; i++) {
+		enum owl_pinconf_param param = OWL_PINCONF_UNPACK_PARAM(configs[i]);
+		u32 arg = OWL_PINCONF_UNPACK_ARG(configs[i]);
+
+		g = &info->groups[group];
+		ret = owl_group_pinconf_reg(g, param, &reg, &bit, &width);
+		if(ret)
+			return ret;
+
+		ret = owl_group_pinconf_arg2val(g, param, arg, &val);
+		if(ret)
+			return ret;
+
+		/* Update register */
+		mask = (1 << width) - 1;
+		mask = mask << bit;
+		tmp = act_readl(reg);
+		tmp &= ~mask;
+		tmp |= val << bit;
+		act_writel(tmp, reg);
+	}
+
+	return ret;
+}
+
+static struct pinconf_ops owl_confops_ops = {
+	.pin_config_get = owl_confops_pin_config_get,
+	.pin_config_set = owl_confops_pin_config_set,
+	.pin_config_group_get = owl_confops_group_config_get,
+	.pin_config_group_set = owl_confops_group_config_set,
+};
+
+/* platform device */
+static struct pinctrl_desc owl_pinctrl_desc = {
+	.name = NULL,
+	.pins = NULL,
+	.npins = 0,
+	.pctlops = &owl_pctlops_ops,
+	.pmxops = &owl_pmxops_ops,
+	.confops = &owl_confops_ops,
+	.owner = THIS_MODULE,
+};
+
+
+int owl_pinctrl_common_probe(struct platform_device *pdev,
+				struct owl_pinctrl_soc_info *info)
+{
+	struct owl_pinctrl *apctl;
+	int ret;
+	int i;
+
+	PINCTRL_DBG("Actions pinctrl probe\n");
+
+	if (!info || !info->pins || !info->npins) {
+		dev_err(&pdev->dev, "wrong pinctrl info\n");
+		return -EINVAL;
+	}
+	info->dev = &pdev->dev;
+
+	owl_pinctrl_desc.name = dev_name(&pdev->dev);
+	owl_pinctrl_desc.pins = info->pins;
+	owl_pinctrl_desc.npins = info->npins;
+
+	owl_gpio_pad_data = info->owl_gpio_pad_data;
+    
+	/* Create state holders etc for this driver */
+	apctl = devm_kzalloc(&pdev->dev, sizeof(*apctl), GFP_KERNEL);
+	if (!apctl) {
+		return -ENOMEM;
+	}
+
+	apctl->info = info;
+	apctl->dev = info->dev;
+
+	PINCTRL_DBG("%s() nfunctions %d, ngroups %d\n",
+		__FUNCTION__, info->nfunctions, info->ngroups);
+
+	apctl->pctl = pinctrl_register(&owl_pinctrl_desc, &pdev->dev, apctl);
+	if (!apctl->pctl) {
+		dev_err(&pdev->dev, "could not register Actions SOC pinmux driver\n");
+		ret = -EINVAL;
+		goto out_no_pmx;
+	}
+
+	/* We will handle a range of GPIO pins */
+	for (i = 0; i < info->gpio_num_ranges; i++) {
+		pinctrl_add_gpio_range(apctl->pctl, &info->gpio_ranges[i]);
+	}
+
+	platform_set_drvdata(pdev, apctl);
+
+	PINCTRL_DBG("initialized Actions SOC pin control driver\n");
+
+	return 0;
+
+out_no_pmx:
+	platform_set_drvdata(pdev, NULL);
+	devm_kfree(&pdev->dev, apctl);
+	return ret;
+}
+
+int owl_pinctrl_common_remove(struct platform_device *pdev)
+{
+	struct owl_pinctrl *apctl = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < apctl->info->gpio_num_ranges; i++) {
+		pinctrl_remove_gpio_range(apctl->pctl, &apctl->info->gpio_ranges[i]);
+	}
+
+	pinctrl_unregister(apctl->pctl);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+	
+
diff --git a/arch/arm/mach-owl/pinctrl_common-owl.h b/arch/arm/mach-owl/pinctrl_common-owl.h
new file mode 100755
index 0000000..9ff2180
--- /dev/null
+++ b/arch/arm/mach-owl/pinctrl_common-owl.h
@@ -0,0 +1,62 @@
+/*
+ * Pinctrl definitions for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+ 
+#ifndef __PINCTRL_COMMON_OWL_H__ 
+#define __PINCTRL_COMMON_OWL_H__
+
+#include "pinctrl_data-owl.h"
+
+
+#if 0
+#define PINCTRL_DBG(format, ...) \
+	printk(KERN_NOTICE "owl pinctrl: " format, ## __VA_ARGS__)
+#else
+#define PINCTRL_DBG(format, ...)
+#endif
+
+#define PINCTRL_ERR(format, ...) \
+	printk(KERN_ERR "owl pinctrl: " format, ## __VA_ARGS__)
+
+
+/**
+ * struct owl_pinctrl_soc_info - Actions SOC pin controller per-SoC configuration
+ * @gpio_ranges: An array of GPIO ranges for this SoC
+ * @gpio_num_ranges: The number of GPIO ranges for this SoC
+ * @pins:	An array describing all pins the pin controller affects.
+ *		All pins which are also GPIOs must be listed first within the
+ *		array, and be numbered identically to the GPIO controller's
+ *		numbering.
+ * @npins:	The number of entries in @pins.
+ * @functions:	The functions supported on this SoC.
+ * @nfunction:	The number of entries in @functions.
+ * @groups:	An array describing all pin groups the pin SoC supports.
+ * @ngroups:	The number of entries in @groups.
+ */
+struct owl_pinctrl_soc_info {
+	struct device *dev;
+	struct pinctrl_gpio_range *gpio_ranges;
+	unsigned gpio_num_ranges;
+	const struct owl_pinconf_pad_info *padinfo;
+	const struct pinctrl_pin_desc *pins;
+	unsigned npins;
+	const struct owl_pinmux_func *functions;
+	unsigned nfunctions;
+	const struct owl_group *groups;
+	unsigned ngroups;
+	struct owl_gpio_pad_data *owl_gpio_pad_data;
+};
+
+int owl_pinctrl_common_probe(struct platform_device *pdev,
+				struct owl_pinctrl_soc_info *info);
+int owl_pinctrl_common_remove(struct platform_device *pdev);
+
+#endif /* __PINCTRL_COMMON_OWL_H__ */
diff --git a/arch/arm/mach-owl/pinctrl_data-atm7059.c b/arch/arm/mach-owl/pinctrl_data-atm7059.c
new file mode 100755
index 0000000..870a285a
--- /dev/null
+++ b/arch/arm/mach-owl/pinctrl_data-atm7059.c
@@ -0,0 +1,2892 @@
+#include "pinctrl_data-owl.h"
+#include <mach/hardware.h>
+
+enum owl_mux {
+	OWL_MUX_NOR,
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_ETH_SMII,
+	OWL_MUX_SPI0,
+	OWL_MUX_SPI1,
+	OWL_MUX_SPI2,
+	OWL_MUX_SPI3,
+	OWL_MUX_SENS0,
+	OWL_MUX_SENS1,
+	OWL_MUX_UART0,
+	OWL_MUX_UART1,
+	OWL_MUX_UART2,
+	OWL_MUX_UART3,
+	OWL_MUX_UART4,
+	OWL_MUX_UART5,
+	OWL_MUX_UART6,
+	OWL_MUX_I2S0,
+	OWL_MUX_I2S1,
+	OWL_MUX_PCM1,
+	OWL_MUX_PCM0,
+	OWL_MUX_KS,
+	OWL_MUX_JTAG,
+	OWL_MUX_PWM0,
+	OWL_MUX_PWM1,
+	OWL_MUX_PWM2,
+	OWL_MUX_PWM3,
+	OWL_MUX_PWM4,
+	OWL_MUX_PWM5,
+	OWL_MUX_P0,	/*what the hell is this?*/
+	OWL_MUX_SD0,
+	OWL_MUX_SD1,
+	OWL_MUX_SD2,
+	OWL_MUX_I2C0,
+	OWL_MUX_I2C1,
+	OWL_MUX_I2C2,
+	OWL_MUX_I2C3,
+	OWL_MUX_DSI,
+	OWL_MUX_LVDS,
+	OWL_MUX_USB30,
+	OWL_MUX_CLKO_25M,
+	OWL_MUX_MIPI_CSI,
+	OWL_MUX_NAND,	
+	OWL_MUX_SPDIF,
+	OWL_MUX_SIRQ0,
+	OWL_MUX_SIRQ1,
+	OWL_MUX_SIRQ2,
+	OWL_MUX_TS,
+	OWL_MUX_LCD0,
+	OWL_MUX_MAX,
+	OWL_MUX_RESERVED,
+};
+
+/*some basic definitions, we want to use this data file in uboot*/
+/*so don't include kernel headfiles*/
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#define NULL ((void *)0)
+
+/*
+ * Most pins affected by the pinmux can also be GPIOs. Define these first.
+ * These must match how the GPIO driver names/numbers its pins.
+ */
+
+#define _GPIOA(offset)		  (offset)
+#define _GPIOB(offset)		  (32 + (offset))
+#define _GPIOC(offset)		  (64 + (offset))
+#define _GPIOD(offset)		  (96 + (offset))
+#define _GPIOE(offset)		  (128 + (offset))
+
+/* All non-GPIO pins follow */
+#define NUM_GPIOS               (_GPIOE(3) + 1)
+#define _PIN(offset)            (NUM_GPIOS + (offset))
+
+#define P_RESERA0               _GPIOA(0)
+#define P_RESERA1               _GPIOA(1)
+#define P_RESERA2               _GPIOA(2)
+#define P_RESERA3               _GPIOA(3)
+#define P_RESERA4               _GPIOA(4)
+#define P_RESERA5               _GPIOA(5)
+#define P_RESERA6               _GPIOA(6)
+#define P_RESERA7               _GPIOA(7)
+#define P_RESERA8               _GPIOA(8)
+#define P_RESERA9               _GPIOA(9)
+#define P_RESERA10              _GPIOA(10)
+#define P_RESERA11              _GPIOA(11)
+
+/* Ethernet MAC */
+#define P_ETH_TXD0              _GPIOA(14)
+#define P_ETH_TXD1              _GPIOA(15)
+#define P_ETH_TXEN              _GPIOA(16)
+#define P_ETH_RXER              _GPIOA(17)
+#define P_ETH_CRS_DV            _GPIOA(18)
+#define P_ETH_RXD1              _GPIOA(19)
+#define P_ETH_RXD0              _GPIOA(20)
+#define P_ETH_REF_CLK           _GPIOA(21)
+#define P_ETH_MDC               _GPIOA(22)
+#define P_ETH_MDIO              _GPIOA(23)
+
+/* SIRQ */
+#define P_SIRQ0                 _GPIOA(24)
+#define P_SIRQ1                 _GPIOA(25)
+#define P_SIRQ2                 _GPIOA(26)
+
+/* I2S */
+#define P_I2S_D0                _GPIOA(27)
+#define P_I2S_BCLK0             _GPIOA(28)
+#define P_I2S_LRCLK0            _GPIOA(29)
+#define P_I2S_MCLK0             _GPIOA(30)
+#define P_I2S_D1                _GPIOA(31)
+#define P_I2S_BCLK1             _GPIOB(0)
+#define P_I2S_LRCLK1            _GPIOB(1)
+#define P_I2S_MCLK1             _GPIOB(2)
+
+/* PCM1 */
+#define P_PCM1_IN               _GPIOD(28)
+#define P_PCM1_CLK              _GPIOD(29)
+#define P_PCM1_SYNC             _GPIOD(30)
+#define P_PCM1_OUT              _GPIOD(31)
+
+/* KEY */
+#define P_KS_IN0                _GPIOB(3)
+#define P_KS_IN1                _GPIOB(4)
+#define P_KS_IN2                _GPIOB(5)
+#define P_KS_IN3                _GPIOB(6)
+#define P_KS_OUT0               _GPIOB(7)
+#define P_KS_OUT1               _GPIOB(8)
+#define P_KS_OUT2               _GPIOB(9)
+
+/* LVDS */
+#define P_LVDS_OEP              _GPIOB(10)
+#define P_LVDS_OEN              _GPIOB(11)
+#define P_LVDS_ODP              _GPIOB(12)
+#define P_LVDS_ODN              _GPIOB(13)
+#define P_LVDS_OCP              _GPIOB(14)
+#define P_LVDS_OCN              _GPIOB(15)
+#define P_LVDS_OBP              _GPIOB(16)
+#define P_LVDS_OBN              _GPIOB(17)
+#define P_LVDS_OAP              _GPIOB(18)
+#define P_LVDS_OAN              _GPIOB(19)
+#define P_LVDS_EEP              _GPIOB(20)
+#define P_LVDS_EEN              _GPIOB(21)
+#define P_LVDS_EDP              _GPIOB(22)
+#define P_LVDS_EDN              _GPIOB(23)
+#define P_LVDS_ECP              _GPIOB(24)
+#define P_LVDS_ECN              _GPIOB(25)
+#define P_LVDS_EBP              _GPIOB(26)
+#define P_LVDS_EBN              _GPIOB(27)
+#define P_LVDS_EAP              _GPIOB(28)
+#define P_LVDS_EAN              _GPIOB(29)
+#define P_LCD0_D18              _GPIOB(30)
+#define P_LCD0_D17              _GPIOB(31)
+
+/* DSI */
+#define P_DSI_DP3               _GPIOC(0)
+#define P_DSI_DN3               _GPIOC(1)
+#define P_DSI_DP1               _GPIOC(2)
+#define P_DSI_DN1               _GPIOC(3)
+#define P_DSI_CP                _GPIOC(4)
+#define P_DSI_CN                _GPIOC(5)
+#define P_DSI_DP0               _GPIOC(6)
+#define P_DSI_DN0               _GPIOC(7)
+#define P_DSI_DP2               _GPIOC(8)
+#define P_DSI_DN2               _GPIOC(9)
+
+/* SD */
+#define P_SD0_D0                _GPIOC(10)
+#define P_SD0_D1                _GPIOC(11)
+#define P_SD0_D2                _GPIOC(12)
+#define P_SD0_D3                _GPIOC(13)
+#define P_SD0_D4                _GPIOC(14)
+#define P_SD0_D5                _GPIOC(15)
+#define P_SD0_D6                _GPIOC(16)
+#define P_SD0_D7                _GPIOC(17)
+#define P_SD0_CMD               _GPIOC(18)
+#define P_SD0_CLK               _GPIOC(19)
+#define P_SD1_CMD               _GPIOC(20)
+#define P_SD1_CLK               _GPIOC(21)
+#define P_SD1_D0		P_SD0_D4
+#define P_SD1_D1		P_SD0_D5
+#define P_SD1_D2		P_SD0_D6
+#define P_SD1_D3		P_SD0_D7
+
+/* SPI */
+#define P_SPI0_SCLK             _GPIOC(22)
+#define P_SPI0_SS               _GPIOC(23)
+#define P_SPI0_MISO             _GPIOC(24)
+#define P_SPI0_MOSI             _GPIOC(25)
+
+/* UART for console */
+#define P_UART0_RX              _GPIOC(26)
+#define P_UART0_TX              _GPIOC(27)
+
+/* UART for Bluetooth */
+#define P_UART2_RX              _GPIOD(18)
+#define P_UART2_TX              _GPIOD(19)
+#define P_UART2_RTSB            _GPIOD(20)
+#define P_UART2_CTSB            _GPIOD(21)
+
+/* UART for 3G */
+#define P_UART3_RX              _GPIOD(22)
+#define P_UART3_TX              _GPIOD(23)
+#define P_UART3_RTSB            _GPIOD(24)
+#define P_UART3_CTSB            _GPIOD(25)
+
+/* UART for GPS */
+#define P_RESERD26              _GPIOD(26)
+#define P_RESERD27              _GPIOD(27)
+
+/* I2C */
+#define P_I2C0_SCLK             _GPIOC(28)
+#define P_I2C0_SDATA            _GPIOC(29)
+#define P_I2C1_SCLK             _GPIOE(0)
+#define P_I2C1_SDATA            _GPIOE(1)
+#define P_I2C2_SCLK             _GPIOE(2)
+#define P_I2C2_SDATA            _GPIOE(3)
+
+/* CSI*/
+#define P_CSI_DN0               _PIN(0)
+#define P_CSI_DP0               _PIN(1)
+#define P_CSI_DN1               _PIN(2)
+#define P_CSI_DP1               _PIN(3)
+#define P_CSI_CN                _PIN(4)
+#define P_CSI_CP                _PIN(5)
+#define P_CSI_DN2               _PIN(6)
+#define P_CSI_DP2               _PIN(7)
+#define P_CSI_DN3               _PIN(8)
+#define P_CSI_DP3               _PIN(9)
+
+#define P_RESERC30               _GPIOC(30)
+#define P_RESERD0                _GPIOD(0)
+#define P_RESERD1                _GPIOD(1)
+#define P_RESERD2                _GPIOD(2)
+#define P_RESERD3                _GPIOD(3)
+#define P_RESERD4                _GPIOD(4)
+#define P_RESERD5                _GPIOD(5)
+#define P_RESERD6                _GPIOD(6)
+#define P_RESERD7                _GPIOD(7)
+#define P_RESERD8                _GPIOD(8)
+#define P_RESERD9                _GPIOD(9)
+#define P_RESERD11               _GPIOD(11)
+
+/* Sensor */
+#define P_SENSOR0_PCLK            _GPIOC(31)
+#define P_SENSOR0_CKOUT           _GPIOD(10)
+
+/* NAND (1.8v / 3.3v) */
+#define P_DNAND_D0              _PIN(10)
+#define P_DNAND_D1              _PIN(11)
+#define P_DNAND_D2              _PIN(12)
+#define P_DNAND_D3              _PIN(13)
+#define P_DNAND_D4              _PIN(14)
+#define P_DNAND_D5              _PIN(15)
+#define P_DNAND_D6              _PIN(16)
+#define P_DNAND_D7              _PIN(17)
+#define P_DNAND_WRB             _PIN(18)
+#define P_DNAND_RDB             _PIN(19)
+#define P_DNAND_RDBN            _PIN(20)
+#define P_DNAND_DQS             _GPIOA(12)
+#define P_DNAND_DQSN            _GPIOA(13)
+#define P_DNAND_RB0             _PIN(21)
+#define P_DNAND_ALE             _GPIOD(12)
+#define P_DNAND_CLE             _GPIOD(13)
+#define P_DNAND_CEB0            _GPIOD(14)
+#define P_DNAND_CEB1            _GPIOD(15)
+#define P_DNAND_CEB2            _GPIOD(16)
+#define P_DNAND_CEB3            _GPIOD(17)
+
+/* System */
+#define P_PORB			_PIN(22)
+#define P_CLKO_25M		_PIN(23)
+#define P_BSEL			_PIN(24)
+#define P_PKG0			_PIN(25)
+#define P_PKG1			_PIN(26)
+#define P_PKG2			_PIN(27)
+#define P_PKG3			_PIN(28)
+
+#define _FIRSTPAD		P_RESERA0
+#define _LASTPAD		P_PKG3
+#define NUM_PADS		(_LASTPAD - _FIRSTPAD + 1)
+
+unsigned int atm7059_num_pads = NUM_PADS;
+
+#define PINCTRL_PIN(a, b) { .number = a, .name = b }
+/* Pad names for the pinmux subsystem */
+const struct owl_pinctrl_pin_desc atm7059_pads[NUM_PADS] = {
+	PINCTRL_PIN(P_RESERA0, "P_RESERA0"),
+	PINCTRL_PIN(P_RESERA1, "P_RESERA1"),
+	PINCTRL_PIN(P_RESERA2, "P_RESERA2"),
+	PINCTRL_PIN(P_RESERA3, "P_RESERA3"),
+	PINCTRL_PIN(P_RESERA4, "P_RESERA4"),
+	PINCTRL_PIN(P_RESERA5, "P_RESERA5"),
+	PINCTRL_PIN(P_RESERA6, "P_RESERA6"),
+	PINCTRL_PIN(P_RESERA7, "P_RESERA7"),
+	PINCTRL_PIN(P_RESERA8, "P_RESERA8"),
+	PINCTRL_PIN(P_RESERA9, "P_RESERA9"),
+	PINCTRL_PIN(P_RESERA10, "P_RESERA10"),
+	PINCTRL_PIN(P_RESERA11, "P_RESERA11"),
+	
+	PINCTRL_PIN(P_ETH_TXD0, "P_ETH_TXD0"),
+	PINCTRL_PIN(P_ETH_TXD1, "P_ETH_TXD1"),
+	PINCTRL_PIN(P_ETH_TXEN, "P_ETH_TXEN"),
+	PINCTRL_PIN(P_ETH_RXER, "P_ETH_RXER"),
+	PINCTRL_PIN(P_ETH_CRS_DV, "P_ETH_CRS_DV"),
+	PINCTRL_PIN(P_ETH_RXD1, "P_ETH_RXD1"),
+	PINCTRL_PIN(P_ETH_RXD0, "P_ETH_RXD0"),
+	PINCTRL_PIN(P_ETH_REF_CLK, "P_ETH_REF_CLK"),
+	PINCTRL_PIN(P_ETH_MDC, "P_ETH_MDC"),
+	PINCTRL_PIN(P_ETH_MDIO, "P_ETH_MDIO"),
+	PINCTRL_PIN(P_SIRQ0, "P_SIRQ0"),
+	PINCTRL_PIN(P_SIRQ1, "P_SIRQ1"),
+	PINCTRL_PIN(P_SIRQ2, "P_SIRQ2"),
+	PINCTRL_PIN(P_I2S_D0, "P_I2S_D0"),
+	PINCTRL_PIN(P_I2S_BCLK0, "P_I2S_BCLK0"),
+	PINCTRL_PIN(P_I2S_LRCLK0, "P_I2S_LRCLK0"),
+	PINCTRL_PIN(P_I2S_MCLK0, "P_I2S_MCLK0"),
+	PINCTRL_PIN(P_I2S_D1, "P_I2S_D1"),
+	PINCTRL_PIN(P_I2S_BCLK1, "P_I2S_BCLK1"),
+	PINCTRL_PIN(P_I2S_LRCLK1, "P_I2S_LRCLK1"),
+	PINCTRL_PIN(P_I2S_MCLK1, "P_I2S_MCLK1"),
+	PINCTRL_PIN(P_PCM1_IN, "P_PCM1_IN"),
+	PINCTRL_PIN(P_PCM1_CLK, "P_PCM1_CLK"),
+	PINCTRL_PIN(P_PCM1_SYNC, "P_PCM1_SYNC"),
+	PINCTRL_PIN(P_PCM1_OUT, "P_PCM1_OUT"),
+	PINCTRL_PIN(P_KS_IN0, "P_KS_IN0"),
+	PINCTRL_PIN(P_KS_IN1, "P_KS_IN1"),
+	PINCTRL_PIN(P_KS_IN2, "P_KS_IN2"),
+	PINCTRL_PIN(P_KS_IN3, "P_KS_IN3"),
+	PINCTRL_PIN(P_KS_OUT0, "P_KS_OUT0"),
+	PINCTRL_PIN(P_KS_OUT1, "P_KS_OUT1"),
+	PINCTRL_PIN(P_KS_OUT2, "P_KS_OUT2"),
+	PINCTRL_PIN(P_LVDS_OEP, "P_LVDS_OEP"),
+	PINCTRL_PIN(P_LVDS_OEN, "P_LVDS_OEN"),
+	PINCTRL_PIN(P_LVDS_ODP, "P_LVDS_ODP"),
+	PINCTRL_PIN(P_LVDS_ODN, "P_LVDS_ODN"),
+	PINCTRL_PIN(P_LVDS_OCP, "P_LVDS_OCP"),
+	PINCTRL_PIN(P_LVDS_OCN, "P_LVDS_OCN"),
+	PINCTRL_PIN(P_LVDS_OBP, "P_LVDS_OBP"),
+	PINCTRL_PIN(P_LVDS_OBN, "P_LVDS_OBN"),
+	PINCTRL_PIN(P_LVDS_OAP, "P_LVDS_OAP"),
+	PINCTRL_PIN(P_LVDS_OAN, "P_LVDS_OAN"),
+	PINCTRL_PIN(P_LVDS_EEP, "P_LVDS_EEP"),
+	PINCTRL_PIN(P_LVDS_EEN, "P_LVDS_EEN"),
+	PINCTRL_PIN(P_LVDS_EDP, "P_LVDS_EDP"),
+	PINCTRL_PIN(P_LVDS_EDN, "P_LVDS_EDN"),
+	PINCTRL_PIN(P_LVDS_ECP, "P_LVDS_ECP"),
+	PINCTRL_PIN(P_LVDS_ECN, "P_LVDS_ECN"),
+	PINCTRL_PIN(P_LVDS_EBP, "P_LVDS_EBP"),
+	PINCTRL_PIN(P_LVDS_EBN, "P_LVDS_EBN"),
+	PINCTRL_PIN(P_LVDS_EAP, "P_LVDS_EAP"),
+	PINCTRL_PIN(P_LVDS_EAN, "P_LVDS_EAN"),
+	PINCTRL_PIN(P_LCD0_D18, "P_LCD0_D18"),
+	PINCTRL_PIN(P_LCD0_D17, "P_LCD0_D17"),
+	PINCTRL_PIN(P_DSI_DP3, "P_DSI_DP3"),
+	PINCTRL_PIN(P_DSI_DN3, "P_DSI_DN3"),
+	PINCTRL_PIN(P_DSI_DP1, "P_DSI_DP1"),
+	PINCTRL_PIN(P_DSI_DN1, "P_DSI_DN1"),
+	PINCTRL_PIN(P_DSI_CP, "P_DSI_CP"),
+	PINCTRL_PIN(P_DSI_CN, "P_DSI_CN"),
+	PINCTRL_PIN(P_DSI_DP0, "P_DSI_DP0"),
+	PINCTRL_PIN(P_DSI_DN0, "P_DSI_DN0"),
+	PINCTRL_PIN(P_DSI_DP2, "P_DSI_DP2"),
+	PINCTRL_PIN(P_DSI_DN2, "P_DSI_DN2"),
+	PINCTRL_PIN(P_SD0_D0, "P_SD0_D0"),
+	PINCTRL_PIN(P_SD0_D1, "P_SD0_D1"),
+	PINCTRL_PIN(P_SD0_D2, "P_SD0_D2"),
+	PINCTRL_PIN(P_SD0_D3, "P_SD0_D3"),
+	PINCTRL_PIN(P_SD1_D0, "P_SD1_D0"),
+	PINCTRL_PIN(P_SD1_D1, "P_SD1_D1"),
+	PINCTRL_PIN(P_SD1_D2, "P_SD1_D2"),
+	PINCTRL_PIN(P_SD1_D3, "P_SD1_D3"),
+	PINCTRL_PIN(P_SD0_CMD, "P_SD0_CMD"),
+	PINCTRL_PIN(P_SD0_CLK, "P_SD0_CLK"),
+	PINCTRL_PIN(P_SD1_CMD, "P_SD1_CMD"),
+	PINCTRL_PIN(P_SD1_CLK, "P_SD1_CLK"),
+	PINCTRL_PIN(P_SPI0_SCLK, "P_SPI0_SCLK"),
+	PINCTRL_PIN(P_SPI0_SS, "P_SPI0_SS"),
+	PINCTRL_PIN(P_SPI0_MISO, "P_SPI0_MISO"),
+	PINCTRL_PIN(P_SPI0_MOSI, "P_SPI0_MOSI"),
+	PINCTRL_PIN(P_UART0_RX, "P_UART0_RX"),
+	PINCTRL_PIN(P_UART0_TX, "P_UART0_TX"),
+	PINCTRL_PIN(P_UART2_RX, "P_UART2_RX"),
+	PINCTRL_PIN(P_UART2_TX, "P_UART2_TX"),
+	PINCTRL_PIN(P_UART2_RTSB, "P_UART2_RTSB"),
+	PINCTRL_PIN(P_UART2_CTSB, "P_UART2_CTSB"),
+	PINCTRL_PIN(P_UART3_RX, "P_UART3_RX"),
+	PINCTRL_PIN(P_UART3_TX, "P_UART3_TX"),
+	PINCTRL_PIN(P_UART3_RTSB, "P_UART3_RTSB"),
+	PINCTRL_PIN(P_UART3_CTSB, "P_UART3_CTSB"),
+	PINCTRL_PIN(P_RESERD26, "P_RESERD26"),
+	PINCTRL_PIN(P_RESERD27, "P_RESERD27"),
+	PINCTRL_PIN(P_I2C0_SCLK, "P_I2C0_SCLK"),
+	PINCTRL_PIN(P_I2C0_SDATA, "P_I2C0_SDATA"),
+	PINCTRL_PIN(P_I2C1_SCLK, "P_I2C1_SCLK"),
+	PINCTRL_PIN(P_I2C1_SDATA, "P_I2C1_SDATA"),
+	PINCTRL_PIN(P_I2C2_SCLK, "P_I2C2_SCLK"),
+	PINCTRL_PIN(P_I2C2_SDATA, "P_I2C2_SDATA"),
+	PINCTRL_PIN(P_CSI_DN0, "P_CSI_DN0"),
+	PINCTRL_PIN(P_CSI_DP0, "P_CSI_DP0"),
+	PINCTRL_PIN(P_CSI_DN1, "P_CSI_DN1"),
+	PINCTRL_PIN(P_CSI_DP1, "P_CSI_DP1"),
+	PINCTRL_PIN(P_CSI_CN, "P_CSI_CN"),
+	PINCTRL_PIN(P_CSI_CP, "P_CSI_CP"),
+	PINCTRL_PIN(P_CSI_DN2, "P_CSI_DN2"),
+	PINCTRL_PIN(P_CSI_DP2, "P_CSI_DP2"),
+	PINCTRL_PIN(P_CSI_DN3, "P_CSI_DN3"),
+	PINCTRL_PIN(P_CSI_DP3, "P_CSI_DP3"),
+
+	PINCTRL_PIN(P_RESERC30, "P_RESERC30"),
+	PINCTRL_PIN(P_SENSOR0_PCLK, "P_SENSOR0_PCLK"),
+	PINCTRL_PIN(P_RESERD0, "P_RESERD0"),
+	PINCTRL_PIN(P_RESERD1, "P_RESERD1"),
+	PINCTRL_PIN(P_RESERD2, "P_RESERD2"),
+	PINCTRL_PIN(P_RESERD3, "P_RESERD3"),
+	PINCTRL_PIN(P_RESERD4, "P_RESERD4"),
+	PINCTRL_PIN(P_RESERD5, "P_RESERD5"),
+	PINCTRL_PIN(P_RESERD6, "P_RESERD6"),
+	PINCTRL_PIN(P_RESERD7, "P_RESERD7"),
+	PINCTRL_PIN(P_RESERD8, "P_RESERD8"),
+	PINCTRL_PIN(P_RESERD9, "P_RESERD9"),
+
+	PINCTRL_PIN(P_SENSOR0_CKOUT, "P_SENSOR0_CKOUT"),
+	PINCTRL_PIN(P_RESERD11, "P_RESERD11"),
+	
+	PINCTRL_PIN(P_DNAND_D0, "P_DNAND_D0"),
+	PINCTRL_PIN(P_DNAND_D1, "P_DNAND_D1"),
+	PINCTRL_PIN(P_DNAND_D2, "P_DNAND_D2"),
+	PINCTRL_PIN(P_DNAND_D3, "P_DNAND_D3"),
+	PINCTRL_PIN(P_DNAND_D4, "P_DNAND_D4"),
+	PINCTRL_PIN(P_DNAND_D5, "P_DNAND_D5"),
+	PINCTRL_PIN(P_DNAND_D6, "P_DNAND_D6"),
+	PINCTRL_PIN(P_DNAND_D7, "P_DNAND_D7"),
+	PINCTRL_PIN(P_DNAND_WRB, "P_DNAND_WRB"),
+	PINCTRL_PIN(P_DNAND_RDB, "P_DNAND_RDB"),
+	PINCTRL_PIN(P_DNAND_RDBN, "P_DNAND_RDBN"),
+	PINCTRL_PIN(P_DNAND_DQS, "P_DNAND_DQS"),
+	PINCTRL_PIN(P_DNAND_DQSN, "P_DNAND_DQSN"),
+	PINCTRL_PIN(P_DNAND_RB0, "P_DNAND_RB0"),
+	PINCTRL_PIN(P_DNAND_ALE, "P_DNAND_ALE"),
+	PINCTRL_PIN(P_DNAND_CLE, "P_DNAND_CLE"),
+	PINCTRL_PIN(P_DNAND_CEB0, "P_DNAND_CEB0"),
+	PINCTRL_PIN(P_DNAND_CEB1, "P_DNAND_CEB1"),
+	PINCTRL_PIN(P_DNAND_CEB2, "P_DNAND_CEB2"),
+	PINCTRL_PIN(P_DNAND_CEB3, "P_DNAND_CEB3"),
+	PINCTRL_PIN(P_PORB, "P_PORB"),
+	PINCTRL_PIN(P_CLKO_25M, "P_CLKO_25M"),
+	PINCTRL_PIN(P_BSEL, "P_BSEL"),
+	PINCTRL_PIN(P_PKG0, "P_PKG0"),
+	PINCTRL_PIN(P_PKG1, "P_PKG1"),
+	PINCTRL_PIN(P_PKG2, "P_PKG2"),
+	PINCTRL_PIN(P_PKG3, "P_PKG3"),
+};
+
+/*****MFP group data****************************/
+/*
+** mfp0_31_26 reserved
+*/
+
+/*
+** mfp0_25_23
+*/
+static unsigned int  owl_mfp0_25_23_pads[] = {
+	P_LCD0_D18,
+};
+
+static unsigned int  owl_mfp0_25_23_funcs[] = {
+	OWL_MUX_NOR,
+	OWL_MUX_SENS1,
+	OWL_MUX_PWM2,
+	OWL_MUX_PWM4,
+	OWL_MUX_LCD0,
+};
+
+/*
+** mfp0_22_20
+*/
+static unsigned int  owl_mfp0_22_20_pads[] = {
+	P_ETH_CRS_DV,
+};
+
+static unsigned int  owl_mfp0_22_20_funcs[] = {
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_ETH_SMII,
+	OWL_MUX_SPI2,
+	OWL_MUX_UART4,
+	OWL_MUX_PWM4,
+};
+
+
+/*
+** mfp0_18_16_eth_txd0
+*/
+static unsigned int  owl_mfp0_18_16_eth_txd0_pads[] = {
+	P_ETH_TXD0,
+};
+
+static unsigned int  owl_mfp0_18_16_eth_txd0_funcs[] = {
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_ETH_SMII,
+	OWL_MUX_SPI2,
+	OWL_MUX_UART6,
+	OWL_MUX_PWM4,
+};
+
+/*
+** mfp0_18_16_eth_txd1
+*/
+static unsigned int  owl_mfp0_18_16_eth_txd1_pads[] = {
+	P_ETH_TXD1,
+};
+
+static unsigned int  owl_mfp0_18_16_eth_txd1_funcs[] = {
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_ETH_SMII,
+	OWL_MUX_SPI2,
+	OWL_MUX_UART6,
+	OWL_MUX_PWM5,
+};
+
+/*
+** mfp0_15_13_rmii_txen
+*/
+static unsigned int  owl_mfp0_15_13_rmii_txen_pads[] = {
+	P_ETH_TXEN,
+};
+
+static unsigned int  owl_mfp0_15_13_rmii_txen_funcs[] = {
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI3,
+	OWL_MUX_PWM0,
+};
+
+/*
+** mfp0_15_13_rmii_rxen
+*/
+static unsigned int  owl_mfp0_15_13_rmii_rxen_pads[] = {
+	P_ETH_RXER,
+};
+
+static unsigned int  owl_mfp0_15_13_rmii_rxen_funcs[] = {
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI3,
+	OWL_MUX_PWM1,
+};
+
+
+/*
+** mfp0_12_11 reserved
+*/
+
+/*
+** mfp0_10_8_rmii_rxd1
+*/
+static unsigned int  owl_mfp0_10_8_rmii_rxd1_pads[] = {
+	P_ETH_RXD1,
+};
+
+static unsigned int  owl_mfp0_10_8_rmii_rxd1_funcs[] = {
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI3,
+	OWL_MUX_PWM2,
+	OWL_MUX_UART5,
+};
+
+/*
+** mfp0_10_8_rmii_rxd0
+*/
+static unsigned int  owl_mfp0_10_8_rmii_rxd0_pads[] = {
+	P_ETH_RXD0,
+};
+
+static unsigned int  owl_mfp0_10_8_rmii_rxd0_funcs[] = {
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI3,
+	OWL_MUX_PWM3,
+	OWL_MUX_UART5,
+};
+
+/*
+** mfp0_7_6
+*/
+static unsigned int  owl_mfp0_7_6_pads[] = {
+	P_ETH_REF_CLK,
+};
+
+static unsigned int  owl_mfp0_7_6_funcs[] = {
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_UART4,
+	OWL_MUX_SPI2,
+	OWL_MUX_RESERVED,
+
+	OWL_MUX_ETH_SMII,
+};
+
+/*
+** mfp0_5
+*/
+static unsigned int  owl_mfp0_5_pads[] = {
+	P_I2S_D0,
+};
+
+static unsigned int  owl_mfp0_5_funcs[] = {
+	OWL_MUX_I2S0,
+	OWL_MUX_NOR,
+};
+
+/*
+** mfp0_4_3
+*/
+static unsigned int  owl_mfp0_4_3_pads[] = {
+	P_I2S_LRCLK0,
+	P_I2S_MCLK0,
+};
+
+static unsigned int  owl_mfp0_4_3_funcs[] = {
+	OWL_MUX_I2S0,
+	OWL_MUX_RESERVED,
+	OWL_MUX_PCM1,
+};
+
+/*
+** mfp0_2_1_i2s0
+*/
+static unsigned int  owl_mfp0_2_1_i2s0_pads[] = {
+	P_I2S_BCLK0,
+};
+
+static unsigned int  owl_mfp0_2_1_i2s0_funcs[] = {
+	OWL_MUX_I2S0,
+	OWL_MUX_NOR,
+	OWL_MUX_PCM0,
+};
+
+/*
+** mfp0_2_1_i2s1
+*/
+static unsigned int  owl_mfp0_2_1_i2s1_pads[] = {
+	P_I2S_BCLK1,
+	P_I2S_LRCLK1,
+	P_I2S_MCLK1,
+};
+
+static unsigned int  owl_mfp0_2_1_i2s1_funcs[] = {
+	OWL_MUX_I2S1,
+	OWL_MUX_NOR,
+	OWL_MUX_PCM0,
+};
+
+/*
+** mfp0_0
+*/
+static unsigned int  owl_mfp0_0_pads[] = {
+	P_I2S_D1,
+};
+
+static unsigned int  owl_mfp0_0_funcs[] = {
+	OWL_MUX_I2S1,
+	OWL_MUX_NOR,
+};
+
+/*eth smii dummy group*/
+static unsigned int  owl_eth_smi_dummy_pads[] = {
+	P_ETH_MDC,
+	P_ETH_MDIO,
+};
+
+static unsigned int  owl_eth_smi_dummy_funcs[] = {
+	OWL_MUX_ETH_SMII,
+	OWL_MUX_ETH_RMII,
+};
+
+/*sirq0 dummy group*/
+static unsigned int  owl_sirq0_dummy_pads[] = {
+	P_SIRQ0,
+};
+
+static unsigned int  owl_sirq0_dummy_funcs[] = {
+	OWL_MUX_SIRQ0,
+};
+
+/*sirq1 dummy group*/
+static unsigned int  owl_sirq1_dummy_pads[] = {
+	P_SIRQ1,
+};
+
+static unsigned int  owl_sirq1_dummy_funcs[] = {
+	OWL_MUX_SIRQ1,
+};
+
+/*sirq2 dummy group*/
+static unsigned int  owl_sirq2_dummy_pads[] = {
+	P_SIRQ2,
+};
+
+static unsigned int  owl_sirq2_dummy_funcs[] = {
+	OWL_MUX_SIRQ2,
+};
+
+/*
+** mfp1_31_29_ks_in2
+*/
+static unsigned int  owl_mfp1_31_29_ks_in2_pads[] = {
+	P_KS_IN2,
+};
+
+static unsigned int  owl_mfp1_31_29_ks_in2_funcs[] = {
+	OWL_MUX_KS,
+	OWL_MUX_JTAG,
+	OWL_MUX_NOR,
+	OWL_MUX_PWM0,
+	OWL_MUX_PWM4,
+	OWL_MUX_SENS1,
+	OWL_MUX_PWM4,
+	OWL_MUX_P0,
+};
+
+/*
+** mfp1_31_29_ks_in1
+*/
+static unsigned int  owl_mfp1_31_29_ks_in1_pads[] = {
+	P_KS_IN1,
+};
+
+static unsigned int  owl_mfp1_31_29_ks_in1_funcs[] = {
+	OWL_MUX_KS,
+	OWL_MUX_JTAG,
+	OWL_MUX_NOR,
+	OWL_MUX_PWM1,
+	OWL_MUX_PWM5,
+	OWL_MUX_SENS1,
+	OWL_MUX_PWM1,
+	OWL_MUX_USB30,
+};
+
+/*
+** mfp1_31_29_ks_in0
+*/
+static unsigned int  owl_mfp1_31_29_ks_in0_pads[] = {
+	P_KS_IN0,
+};
+
+static unsigned int  owl_mfp1_31_29_ks_in0_funcs[] = {
+	OWL_MUX_KS,
+	OWL_MUX_JTAG,
+	OWL_MUX_NOR,
+	OWL_MUX_PWM0,
+	OWL_MUX_PWM0,
+	OWL_MUX_SENS1,
+	OWL_MUX_PWM0,
+	OWL_MUX_P0,
+};
+
+
+/*
+** mfp1_28_26_ks_in3
+*/
+static unsigned int  owl_mfp1_28_26_ks_in3_pads[] = {
+	P_KS_IN3,
+};
+
+static unsigned int  owl_mfp1_28_26_ks_in3_funcs[] = {
+	OWL_MUX_KS,
+	OWL_MUX_JTAG,
+	OWL_MUX_NOR,
+	OWL_MUX_PWM1,
+	OWL_MUX_RESERVED,
+	OWL_MUX_SENS1,
+};
+
+/*
+** mfp1_28_26_ks_out0
+*/
+static unsigned int  owl_mfp1_28_26_ks_out0_pads[] = {
+	P_KS_OUT0,
+};
+
+static unsigned int  owl_mfp1_28_26_ks_out0_funcs[] = {
+	OWL_MUX_KS,
+	OWL_MUX_UART5,
+	OWL_MUX_NOR,
+	OWL_MUX_PWM2,
+	OWL_MUX_RESERVED,
+	OWL_MUX_SENS1,
+	OWL_MUX_SD0,
+};
+
+/*
+** mfp1_28_26_ks_out1
+*/
+static unsigned int  owl_mfp1_28_26_ks_out1_pads[] = {
+	P_KS_OUT1,
+};
+
+static unsigned int  owl_mfp1_28_26_ks_out1_funcs[] = {
+	OWL_MUX_KS,
+	OWL_MUX_JTAG,
+	OWL_MUX_NOR,
+	OWL_MUX_PWM3,
+	OWL_MUX_RESERVED,
+	OWL_MUX_SENS1,
+	OWL_MUX_SD0,
+};
+
+/*
+** mfp1_25_23
+*/
+static unsigned int  owl_mfp1_25_23_pads[] = {
+	P_KS_OUT2,
+};
+
+static unsigned int  owl_mfp1_25_23_funcs[] = {
+	OWL_MUX_SD0,
+	OWL_MUX_KS,
+	OWL_MUX_NOR,
+	OWL_MUX_PWM2,
+	OWL_MUX_UART5,
+	OWL_MUX_SENS1,
+};
+
+/*
+** mfp1_22_21
+*/
+static unsigned int  owl_mfp1_22_21_pads[] = {
+	P_LVDS_OEP,
+	P_LVDS_OEN,
+	P_LVDS_ODP,
+	P_LVDS_ODN,
+	P_LVDS_OCP,
+	P_LVDS_OCN,
+	P_LVDS_OBP,
+	P_LVDS_OBN,
+	P_LVDS_OAP,
+	P_LVDS_OAN,
+};
+
+static unsigned int  owl_mfp1_22_21_funcs[] = {
+	OWL_MUX_LVDS,
+	OWL_MUX_TS,
+	OWL_MUX_LCD0,
+};
+
+/*
+** mfp1_20_19
+*/
+static unsigned int  owl_mfp1_20_19_pads[] = {
+	P_DSI_DN0,
+};
+
+static unsigned int  owl_mfp1_20_19_funcs[] = {
+	OWL_MUX_DSI,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI0,
+};
+
+/*
+** mfp1_18_17
+*/
+static unsigned int  owl_mfp1_18_17_pads[] = {
+	P_DSI_DP2,
+};
+
+static unsigned int  owl_mfp1_18_17_funcs[] = {
+	OWL_MUX_DSI,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI0,
+	OWL_MUX_SD1,
+};
+
+/*
+** mfp1_16_14
+*/
+static unsigned int  owl_mfp1_16_14_pads[] = {
+	P_LCD0_D17,
+};
+
+static unsigned int  owl_mfp1_16_14_funcs[] = {
+	OWL_MUX_NOR,
+	OWL_MUX_SD0,
+	OWL_MUX_SD1,
+	OWL_MUX_PWM3,
+	OWL_MUX_LCD0,
+};
+
+/*
+** mfp1_13_12
+*/
+static unsigned int  owl_mfp1_13_12_pads[] = {
+	P_DSI_DP3,
+};
+
+static unsigned int  owl_mfp1_13_12_funcs[] = {
+	OWL_MUX_DSI,
+	OWL_MUX_SD0,
+	OWL_MUX_SD1,
+	OWL_MUX_LCD0,
+};
+
+/*
+** mfp1_11_10
+*/
+static unsigned int  owl_mfp1_11_10_pads[] = {
+	P_DSI_DN3,
+};
+
+static unsigned int  owl_mfp1_11_10_funcs[] = {
+	OWL_MUX_DSI,
+	OWL_MUX_RESERVED,
+	OWL_MUX_SD1,
+	OWL_MUX_LCD0,
+};
+
+/*
+** mfp1_9_7
+*/
+static unsigned int  owl_mfp1_9_7_pads[] = {
+	P_DSI_DP0,
+};
+
+static unsigned int  owl_mfp1_9_7_funcs[] = {
+	OWL_MUX_DSI,
+	OWL_MUX_RESERVED,
+	OWL_MUX_SD0,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI0,
+};
+
+/*
+** mfp1_6_5
+*/
+static unsigned int  owl_mfp1_6_5_pads[] = {
+	P_LVDS_EEP,
+	P_LVDS_EEN,
+};
+
+static unsigned int  owl_mfp1_6_5_funcs[] = {
+	OWL_MUX_LVDS,
+	OWL_MUX_NOR,
+	OWL_MUX_TS,
+	OWL_MUX_LCD0,
+};
+
+/*
+** mfp1_4_3
+*/
+static unsigned int  owl_mfp1_4_3_pads[] = {
+	P_SPI0_SCLK,
+	P_SPI0_MOSI,
+
+};
+
+static unsigned int  owl_mfp1_4_3_funcs[] = {
+	OWL_MUX_SPI0,
+	OWL_MUX_NOR,
+	OWL_MUX_I2C3,
+	OWL_MUX_PCM0,
+};
+
+/*
+** mfp1_2_0
+*/
+static unsigned int  owl_mfp1_2_0_pads[] = {
+	P_SPI0_SS,
+	P_SPI0_MISO,
+
+};
+
+static unsigned int  owl_mfp1_2_0_funcs[] = {
+	OWL_MUX_SPI0,
+	OWL_MUX_NOR,
+	OWL_MUX_I2S1,
+	OWL_MUX_PCM1,
+	OWL_MUX_PCM0,
+};
+
+/*
+** mfp2_31 reserved
+*/
+
+/*
+** mfp2_30_29
+*/
+static unsigned int  owl_mfp2_30_29_pads[] = {
+	P_DSI_DP1,
+	P_DSI_CP,
+	P_DSI_CN,
+};
+
+static unsigned int  owl_mfp2_30_29_funcs[] = {
+	OWL_MUX_DSI,
+	OWL_MUX_SD1,
+	OWL_MUX_LCD0,
+};
+
+
+/*
+** mfp2_28_27
+*/
+static unsigned int  owl_mfp2_28_27_pads[] = {
+	P_LVDS_EDP,
+	P_LVDS_EDN,
+	P_LVDS_ECP,
+	P_LVDS_ECN,
+	P_LVDS_EBP,
+	P_LVDS_EBN,
+	P_LVDS_EAP,
+	P_LVDS_EAN,
+};
+
+static unsigned int  owl_mfp2_28_27_funcs[] = {
+	OWL_MUX_LVDS,
+	OWL_MUX_NOR,
+	OWL_MUX_LCD0,
+};
+
+/*
+** mfp2_26_24
+*/
+static unsigned int  owl_mfp2_26_24_pads[] = {
+	P_DSI_DN2,
+};
+
+static unsigned int  owl_mfp2_26_24_funcs[] = {
+	OWL_MUX_DSI,
+	OWL_MUX_RESERVED,
+	OWL_MUX_SD1,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI0,
+};
+
+/*
+** mfp2_23
+*/
+static unsigned int  owl_mfp2_23_pads[] = {
+	P_UART2_RTSB,
+};
+
+static unsigned int  owl_mfp2_23_funcs[] = {
+	OWL_MUX_UART2,
+	OWL_MUX_UART0,
+};
+
+/*
+** mfp2_22
+*/
+static unsigned int  owl_mfp2_22_pads[] = {
+	P_UART2_CTSB,
+};
+
+static unsigned int  owl_mfp2_22_funcs[] = {
+	OWL_MUX_UART2,
+	OWL_MUX_UART0,
+};
+
+/*
+** mfp2_21
+*/
+static unsigned int  owl_mfp2_21_pads[] = {
+	P_UART3_RTSB,
+};
+
+static unsigned int  owl_mfp2_21_funcs[] = {
+	OWL_MUX_UART3,
+	OWL_MUX_UART5,
+};
+
+/*
+** mfp2_20
+*/
+static unsigned int  owl_mfp2_20_pads[] = {
+	P_UART3_CTSB,
+};
+
+static unsigned int  owl_mfp2_20_funcs[] = {
+	OWL_MUX_UART3,
+	OWL_MUX_UART5,
+};
+
+/*
+** mfp2_19_17
+*/
+static unsigned int  owl_mfp2_19_17_pads[] = {
+	P_SD0_D0,
+};
+
+static unsigned int  owl_mfp2_19_17_funcs[] = {
+	OWL_MUX_SD0,
+	OWL_MUX_NOR,
+	OWL_MUX_RESERVED,
+	OWL_MUX_JTAG,
+	OWL_MUX_UART2,
+	OWL_MUX_UART5,
+};
+
+/*
+** mfp2_16_14
+*/
+static unsigned int  owl_mfp2_16_14_pads[] = {
+	P_SD0_D1,
+};
+
+static unsigned int  owl_mfp2_16_14_funcs[] = {
+	OWL_MUX_SD0,
+	OWL_MUX_NOR,
+	OWL_MUX_RESERVED,
+	OWL_MUX_RESERVED,
+	OWL_MUX_UART2,
+	OWL_MUX_UART5,
+};
+
+/*
+** mfp2_13_11
+*/
+static unsigned int  owl_mfp2_13_11_pads[] = {
+	P_SD0_D2,
+	P_SD0_D3,
+};
+
+static unsigned int  owl_mfp2_13_11_funcs[] = {
+	OWL_MUX_SD0,
+	OWL_MUX_NOR,
+	OWL_MUX_RESERVED,
+	OWL_MUX_JTAG,
+	OWL_MUX_UART2,
+	OWL_MUX_UART1,
+};
+
+/*
+** mfp2_10_9
+*/
+static unsigned int  owl_mfp2_10_9_pads[] = {
+	P_SD1_D0,
+	P_SD1_D1,
+	P_SD1_D2,
+	P_SD1_D3,
+};
+
+static unsigned int  owl_mfp2_10_9_funcs[] = {
+	OWL_MUX_SD0,
+	OWL_MUX_NOR,
+	OWL_MUX_RESERVED,
+	OWL_MUX_SD1,
+};
+
+/*
+** mfp2_8_7
+*/
+static unsigned int  owl_mfp2_8_7_pads[] = {
+	P_SD0_CMD,
+};
+
+static unsigned int  owl_mfp2_8_7_funcs[] = {
+	OWL_MUX_SD0,
+	OWL_MUX_NOR,
+	OWL_MUX_RESERVED,
+	OWL_MUX_JTAG,
+};
+
+/*
+** mfp2_6_5
+*/
+static unsigned int  owl_mfp2_6_5_pads[] = {
+	P_SD0_CLK,
+};
+
+static unsigned int  owl_mfp2_6_5_funcs[] = {
+	OWL_MUX_SD0,
+	OWL_MUX_RESERVED,
+	OWL_MUX_JTAG,
+};
+
+/*
+** mfp2_4_3
+*/
+static unsigned int  owl_mfp2_4_3_pads[] = {
+	P_SD1_CMD,
+};
+
+static unsigned int  owl_mfp2_4_3_funcs[] = {
+	OWL_MUX_SD1,
+	OWL_MUX_NOR,
+};
+
+/*
+** mfp2_2_0
+*/
+static unsigned int  owl_mfp2_2_0_pads[] = {
+	P_UART0_RX,
+};
+
+static unsigned int  owl_mfp2_2_0_funcs[] = {
+	OWL_MUX_UART0,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI1,
+	OWL_MUX_I2C0,
+	OWL_MUX_PCM1,
+	OWL_MUX_I2S1,
+};
+
+/*
+** sd1 dummy group
+*/
+static unsigned int  owl_sd1_dummy_pads[] = {
+	P_SD1_CLK,
+};
+
+static unsigned int  owl_sd1_dummy_funcs[] = {
+	OWL_MUX_SD1,
+};
+
+/*
+** mfp3_31 reserved
+*/
+
+/*
+** mfp3_30
+*/
+static unsigned int  owl_mfp3_30_pads[] = {
+	P_CLKO_25M,
+};
+
+static unsigned int  owl_mfp3_30_funcs[] = {
+	OWL_MUX_RESERVED,
+	OWL_MUX_CLKO_25M,
+};
+
+/*
+** mfp3_29_28
+*/
+static unsigned int  owl_mfp3_29_28_pads[] = {
+	P_CSI_CN,
+	P_CSI_CP,
+};
+
+static unsigned int  owl_mfp3_29_28_funcs[] = {
+	OWL_MUX_MIPI_CSI,
+	OWL_MUX_SENS0,
+};
+
+/*
+** mfp3_27_24 reserved
+*/
+
+/*
+** mfp3_23_22
+*/
+static unsigned int  owl_mfp3_23_22_pads[] = {
+	P_SENSOR0_CKOUT,
+};
+
+static unsigned int  owl_mfp3_23_22_funcs[] = {
+	OWL_MUX_SENS0,
+	OWL_MUX_NOR,
+	OWL_MUX_SENS1,
+	OWL_MUX_PWM1,
+};
+
+/*
+** mfp3_21_19
+*/
+static unsigned int  owl_mfp3_21_19_pads[] = {
+	P_UART0_TX,
+};
+
+static unsigned int  owl_mfp3_21_19_funcs[] = {
+	OWL_MUX_UART0,
+	OWL_MUX_UART2,
+	OWL_MUX_SPI1,
+	OWL_MUX_I2C0,
+	OWL_MUX_SPDIF,
+	OWL_MUX_PCM1,
+	OWL_MUX_I2S1,
+};
+
+/*
+** mfp3_18_16
+*/
+static unsigned int  owl_mfp3_18_16_pads[] = {
+	P_I2C0_SCLK,
+	P_I2C0_SDATA,
+};
+
+static unsigned int  owl_mfp3_18_16_funcs[] = {
+	OWL_MUX_I2C0,
+	OWL_MUX_UART2,
+	OWL_MUX_I2C1,
+	OWL_MUX_UART1,
+	OWL_MUX_SPI1,
+};
+
+/*
+** mfp3_15_14
+*/
+static unsigned int  owl_mfp3_15_14_pads[] = {
+	P_CSI_DN0,
+	P_CSI_DN1,
+	P_CSI_DN2,
+	P_CSI_DN3,
+	P_CSI_DP0,
+	P_CSI_DP1,
+	P_CSI_DP2,
+	P_CSI_DP3,
+};
+
+static unsigned int  owl_mfp3_15_14_funcs[] = {
+	OWL_MUX_MIPI_CSI,
+	OWL_MUX_SENS0,
+};
+
+/*
+** mfp3_13_12
+*/
+static unsigned int  owl_mfp3_13_12_pads[] = {
+	P_SENSOR0_PCLK,
+};
+
+static unsigned int  owl_mfp3_13_12_funcs[] = {
+	OWL_MUX_SENS0,
+	OWL_MUX_NOR,
+	OWL_MUX_PWM0,
+};
+
+/*
+** mfp3_11_10
+*/
+static unsigned int  owl_mfp3_11_10_pads[] = {
+	P_PCM1_IN,
+};
+
+static unsigned int  owl_mfp3_11_10_funcs[] = {
+	OWL_MUX_PCM1,
+	OWL_MUX_SENS1,
+	OWL_MUX_UART4,
+	OWL_MUX_PWM4,
+};
+
+/*
+** mfp3_9_8
+*/
+static unsigned int  owl_mfp3_9_8_pads[] = {
+	P_PCM1_CLK,
+};
+
+static unsigned int  owl_mfp3_9_8_funcs[] = {
+	OWL_MUX_PCM1,
+	OWL_MUX_SENS1,
+	OWL_MUX_UART4,
+	OWL_MUX_PWM5,
+};
+
+/*
+** 	mfp3_7_6
+*/
+static unsigned int  owl_mfp3_7_6_pads[] = {
+	P_PCM1_SYNC,
+};
+
+static unsigned int  owl_mfp3_7_6_funcs[] = {
+	OWL_MUX_PCM1,
+	OWL_MUX_SENS1,
+	OWL_MUX_UART6,
+	OWL_MUX_I2C3,
+};
+
+/*
+** mfp3_8
+*/
+static unsigned int  owl_mfp3_5_4_pads[] = {
+	P_PCM1_OUT,
+};
+
+static unsigned int  owl_mfp3_5_4_funcs[] = {
+	OWL_MUX_PCM1,
+	OWL_MUX_SENS1,
+	OWL_MUX_UART6,
+	OWL_MUX_I2C3,
+};
+
+/*
+** mfp3_3
+*/
+static unsigned int  owl_mfp3_3_pads[] = {
+	P_DNAND_D0,
+	P_DNAND_D1,
+	P_DNAND_D2,
+	P_DNAND_D3,
+	P_DNAND_D4,
+	P_DNAND_D5,
+	P_DNAND_D6,
+	P_DNAND_D7,
+	P_DNAND_RDB,
+	P_DNAND_RDBN,
+};
+
+static unsigned int  owl_mfp3_3_funcs[] = {
+	OWL_MUX_NAND,
+	OWL_MUX_SD2,
+};
+
+/*
+** mfp3_2
+*/
+static unsigned int  owl_mfp3_2_pads[] = {
+	P_DNAND_ALE,
+	P_DNAND_CLE,
+	P_DNAND_CEB0,
+	P_DNAND_CEB1,
+};
+
+static unsigned int  owl_mfp3_2_funcs[] = {
+	OWL_MUX_NAND,
+	OWL_MUX_SPI2,
+};
+
+/*
+** mfp3_1_0_nand_ceb2
+*/
+static unsigned int  owl_mfp3_1_0_nand_ceb2_pads[] = {
+	P_DNAND_CEB2,
+};
+
+static unsigned int  owl_mfp3_1_0_nand_ceb2_funcs[] = {
+	OWL_MUX_NAND,
+	OWL_MUX_PWM5,
+};
+
+/*
+** mfp3_1_0_nand_ceb3
+*/
+static unsigned int  owl_mfp3_1_0_nand_ceb3_pads[] = {
+	P_DNAND_CEB3,
+};
+
+static unsigned int  owl_mfp3_1_0_nand_ceb3_funcs[] = {
+	OWL_MUX_NAND,
+	OWL_MUX_PWM4,
+};
+
+/*
+** dsi dummy group
+*/
+static unsigned int  owl_dsi_dummy_pads[] = {
+	P_DSI_DN1,
+};
+
+static unsigned int  owl_dsi_dummy_funcs[] = {
+	OWL_MUX_DSI,
+};
+
+
+/*
+** nand dummy group
+*/
+static unsigned int  owl_nand_dummy_pads[] = {
+	P_DNAND_WRB,
+	P_DNAND_RB0,
+	P_DNAND_DQS,
+	P_DNAND_DQSN,
+};
+
+static unsigned int  owl_nand_dummy_funcs[] = {
+	OWL_MUX_NAND,
+};
+
+/*
+** uart2 dummy group
+*/
+static unsigned int  owl_uart2_dummy_pads[] = {
+	P_UART2_RX,
+	P_UART2_TX,
+};
+
+static unsigned int  owl_uart2_dummy_funcs[] = {
+	OWL_MUX_UART2,
+};
+
+/*
+** uart3 dummy group
+*/
+static unsigned int  owl_uart3_dummy_pads[] = {
+	P_UART3_RX,
+	P_UART3_TX,
+};
+
+static unsigned int  owl_uart3_dummy_funcs[] = {
+	OWL_MUX_UART3,
+};
+
+
+/*
+** i2c1 dummy group
+*/
+static unsigned int  owl_i2c1_dummy_pads[] = {
+	P_I2C1_SCLK,
+	P_I2C1_SDATA,
+};
+
+static unsigned int  owl_i2c1_dummy_funcs[] = {
+	OWL_MUX_I2C1,
+};
+
+/*
+** i2c2 dummy group
+*/
+static unsigned int  owl_i2c2_dummy_pads[] = {
+	P_I2C2_SCLK,
+	P_I2C2_SDATA,
+};
+
+static unsigned int  owl_i2c2_dummy_funcs[] = {
+	OWL_MUX_I2C2,
+};
+
+
+/*****End MFP group data****************************/
+
+/*****PADDRV group data****************************/
+
+/*PAD_DRV0*/
+static unsigned int  owl_paddrv0_29_28_pads[] = {
+	P_SIRQ0,
+	P_SIRQ1,
+	P_SIRQ2,
+};
+
+static unsigned int  owl_paddrv0_23_22_pads[] = {
+	P_ETH_TXD0,
+	P_ETH_TXD1,
+	P_ETH_TXEN,
+};
+
+static unsigned int  owl_paddrv0_21_20_pads[] = {
+	P_ETH_RXER,
+};
+
+static unsigned int  owl_paddrv0_19_18_pads[] = {
+	P_ETH_CRS_DV,
+};
+
+static unsigned int  owl_paddrv0_17_16_pads[] = {
+	P_ETH_RXD0,
+	P_ETH_RXD1,
+};
+
+static unsigned int  owl_paddrv0_15_14_pads[] = {
+	P_ETH_REF_CLK,
+};
+
+static unsigned int  owl_paddrv0_13_12_pads[] = {
+	P_ETH_MDC,
+	P_ETH_MDIO,
+};
+
+static unsigned int  owl_paddrv0_11_10_pads[] = {
+	P_I2S_D0,
+};
+
+static unsigned int  owl_paddrv0_9_8_pads[] = {
+	P_I2S_BCLK0,
+};
+
+static unsigned int  owl_paddrv0_7_6_pads[] = {
+	P_I2S_LRCLK0,
+	P_I2S_MCLK0,
+	P_I2S_D1,
+};
+
+static unsigned int  owl_paddrv0_5_4_pads[] = {
+	P_I2S_BCLK1,
+	P_I2S_LRCLK1,
+	P_I2S_MCLK1,
+};
+
+static unsigned int  owl_paddrv0_3_2_pads[] = {
+	P_PCM1_IN,
+	P_PCM1_CLK,
+	P_PCM1_SYNC,
+	P_PCM1_OUT,
+};
+
+static unsigned int  owl_paddrv0_1_0_pads[] = {
+	P_KS_IN0,
+	P_KS_IN1,
+	P_KS_IN2,
+	P_KS_IN3,
+};
+
+/*PAD_DRV1*/
+static unsigned int  owl_paddrv1_31_30_pads[] = {
+	P_KS_OUT0,
+	P_KS_OUT1,
+	P_KS_OUT2,
+};
+
+static unsigned int  owl_paddrv1_29_28_pads[] = {
+	P_LVDS_OEP,
+	P_LVDS_OEN,
+	P_LVDS_ODP,
+	P_LVDS_ODN,
+	P_LVDS_OCP,
+	P_LVDS_OCN,
+	P_LVDS_OBP,
+	P_LVDS_OBN,
+	P_LVDS_OAP,
+	P_LVDS_OAN,
+	P_LVDS_EEP,
+	P_LVDS_EEN,
+	P_LVDS_EDP,
+	P_LVDS_EDN,
+	P_LVDS_ECP,
+	P_LVDS_ECN,
+	P_LVDS_EBP,
+	P_LVDS_EBN,
+	P_LVDS_EAP,
+	P_LVDS_EAN,
+};
+
+static unsigned int  owl_paddrv1_27_26_pads[] = {
+	P_DSI_DP3,
+	P_DSI_DN3,
+	P_DSI_DP1,
+	P_DSI_DN1,
+	P_DSI_CP,
+	P_DSI_CN,
+};
+
+static unsigned int  owl_paddrv1_25_24_pads[] = {
+	P_DSI_DP0,
+	P_DSI_DN0,
+	P_DSI_DP2,
+	P_DSI_DN2,
+};
+
+static unsigned int  owl_paddrv1_23_22_pads[] = {
+	P_SD0_D0,
+	P_SD0_D1,
+	P_SD0_D2,
+	P_SD0_D3,
+};
+
+static unsigned int  owl_paddrv1_21_20_pads[] = {
+	P_SD1_D0,
+	P_SD1_D1,
+	P_SD1_D2,
+	P_SD1_D3,
+};
+
+static unsigned int  owl_paddrv1_19_18_pads[] = {
+	P_SD0_CMD,
+};
+
+static unsigned int  owl_paddrv1_17_16_pads[] = {
+	P_SD0_CLK,
+};
+
+static unsigned int  owl_paddrv1_15_14_pads[] = {
+	P_SD1_CMD,
+};
+
+static unsigned int  owl_paddrv1_13_12_pads[] = {
+	P_SD1_CLK,
+};
+
+static unsigned int  owl_paddrv1_11_10_pads[] = {
+	P_SPI0_SCLK,
+	P_SPI0_SS,
+	P_SPI0_MISO,
+	P_SPI0_MOSI,
+};
+
+/*PAD_DRV2*/
+static unsigned int  owl_paddrv2_31_30_pads[] = {
+	P_UART0_RX,
+};
+
+static unsigned int  owl_paddrv2_29_28_pads[] = {
+	P_UART0_TX,
+};
+
+static unsigned int  owl_paddrv2_27_26_pads[] = {
+	P_UART2_RX,
+	P_UART2_TX,
+	P_UART2_RTSB,
+	P_UART2_CTSB,
+};
+
+static unsigned int  owl_paddrv2_24_23_pads[] = {
+	P_I2C0_SCLK,
+	P_I2C0_SDATA,
+};
+
+static unsigned int  owl_paddrv2_22_21_pads[] = {
+	P_I2C1_SCLK,
+	P_I2C1_SDATA,
+	P_I2C2_SCLK,
+	P_I2C2_SDATA,
+};
+
+static unsigned int  owl_paddrv2_19_18_pads[] = {
+	P_SENSOR0_PCLK,
+};
+
+static unsigned int  owl_paddrv2_13_12_pads[] = {
+	P_SENSOR0_CKOUT,
+};
+
+static unsigned int  owl_paddrv2_3_2_pads[] = {
+	P_UART3_RX,
+	P_UART3_TX,
+	P_UART3_RTSB,
+	P_UART3_CTSB,
+};
+
+/*****End PADDRV group data****************************/
+
+#define MUX_PG(group_name, mfpctl_regn, mfpctl_sft, mfpctl_w)		\
+	{	\
+		.name = #group_name,		\
+		.pads = owl_##group_name##_pads,	\
+		.padcnt = ARRAY_SIZE(owl_##group_name##_pads),	\
+		.funcs = owl_##group_name##_funcs,	\
+		.nfuncs = ARRAY_SIZE(owl_##group_name##_funcs),	\
+		.mfpctl_regnum = mfpctl_regn,	\
+		.mfpctl_shift = mfpctl_sft,	\
+		.mfpctl_width = mfpctl_w,	\
+		.paddrv_regnum = -1,		\
+	}
+
+#define MUX_PG_DUMMY(group_name)		\
+	{	\
+		.name = #group_name,		\
+		.pads = owl_##group_name##_pads,	\
+		.padcnt = ARRAY_SIZE(owl_##group_name##_pads),	\
+		.funcs = owl_##group_name##_funcs,	\
+		.nfuncs = ARRAY_SIZE(owl_##group_name##_funcs),	\
+		.mfpctl_regnum = -1,	\
+		.paddrv_regnum = -1,	\
+	}
+
+#define PADDRV_PG(group_name, paddrv_regn, paddrv_sft)	\
+	{	\
+		.name = #group_name,		\
+		.pads = owl_##group_name##_pads,	\
+		.padcnt = ARRAY_SIZE(owl_##group_name##_pads),	\
+		.paddrv_regnum = paddrv_regn,		\
+		.paddrv_shift = paddrv_sft,	\
+		.paddrv_width = 2,		\
+		.mfpctl_regnum = -1,	\
+	}
+
+/*
+**
+** all pinctrl groups of atm7059 board
+**
+*/
+const struct owl_group atm7059_groups[] = {
+	MUX_PG(mfp0_25_23, 0, 23, 3),
+	MUX_PG(mfp0_22_20, 0, 20, 3),
+	MUX_PG(mfp0_18_16_eth_txd0, 0, 16, 3),
+	MUX_PG(mfp0_18_16_eth_txd1, 0, 16, 3),
+	MUX_PG(mfp0_15_13_rmii_txen, 0, 13, 3),
+	MUX_PG(mfp0_15_13_rmii_rxen, 0, 13, 3),
+	MUX_PG(mfp0_10_8_rmii_rxd1, 0, 8, 3),
+	MUX_PG(mfp0_10_8_rmii_rxd0, 0, 8, 3),
+	MUX_PG(mfp0_7_6, 0, 6, 2),
+	MUX_PG(mfp0_5, 0, 5, 1),
+	MUX_PG(mfp0_4_3, 0, 3, 2),
+	MUX_PG(mfp0_2_1_i2s0, 0, 1, 2),
+	MUX_PG(mfp0_2_1_i2s1, 0, 1, 2),
+	MUX_PG(mfp0_0, 0, 0, 1),
+	MUX_PG_DUMMY(eth_smi_dummy),
+	MUX_PG_DUMMY(sirq0_dummy),
+	MUX_PG_DUMMY(sirq1_dummy),
+	MUX_PG_DUMMY(sirq2_dummy),
+
+	MUX_PG(mfp1_31_29_ks_in2, 1, 29, 3),
+	MUX_PG(mfp1_31_29_ks_in1, 1, 29, 3),
+	MUX_PG(mfp1_31_29_ks_in0, 1, 29, 3),
+	MUX_PG(mfp1_28_26_ks_in3, 1, 26, 3),
+	MUX_PG(mfp1_28_26_ks_out0, 1, 26, 3),
+	MUX_PG(mfp1_28_26_ks_out1, 1, 26, 3),
+	MUX_PG(mfp1_25_23, 1, 23, 3),
+	MUX_PG(mfp1_22_21, 1, 21, 2),
+	MUX_PG(mfp1_20_19, 1, 19, 2),
+	MUX_PG(mfp1_18_17, 1, 17, 2),
+	MUX_PG(mfp1_16_14, 1, 14, 3),
+	MUX_PG(mfp1_13_12, 1, 12, 2),
+	MUX_PG(mfp1_11_10, 1, 10, 2),
+	MUX_PG(mfp1_9_7, 1, 7, 3),
+	MUX_PG(mfp1_6_5, 1, 5, 2),
+	MUX_PG(mfp1_4_3, 1, 3, 2),
+	MUX_PG(mfp1_2_0, 1, 0, 3),
+
+	MUX_PG(mfp2_30_29, 2, 29, 2),
+	MUX_PG(mfp2_28_27, 2, 27, 2),
+	MUX_PG(mfp2_26_24, 2, 24, 3),
+	MUX_PG(mfp2_23, 2, 23, 1),
+	MUX_PG(mfp2_22, 2, 22, 1),
+	MUX_PG(mfp2_21, 2, 21, 1),
+	MUX_PG(mfp2_20, 2, 20, 1),
+	MUX_PG(mfp2_19_17, 2, 17, 3),
+	MUX_PG(mfp2_16_14, 2, 14, 3),
+	MUX_PG(mfp2_13_11, 2, 11, 3),
+	MUX_PG(mfp2_10_9, 2, 9, 2),
+	MUX_PG(mfp2_8_7, 2, 7, 2),
+	MUX_PG(mfp2_6_5, 2, 5, 2),
+	MUX_PG(mfp2_4_3, 2, 3, 2),
+	MUX_PG(mfp2_2_0, 2, 0, 3),
+	MUX_PG_DUMMY(sd1_dummy),
+
+	MUX_PG(mfp3_30, 3, 30, 1),
+	MUX_PG(mfp3_29_28, 3, 28, 2),
+	MUX_PG(mfp3_23_22, 3, 22, 2),
+	MUX_PG(mfp3_21_19, 3, 19, 3),
+	MUX_PG(mfp3_18_16, 3, 16, 3),
+	MUX_PG(mfp3_15_14, 3, 14, 2),
+	MUX_PG(mfp3_13_12, 3, 12, 2),
+	MUX_PG(mfp3_11_10, 3, 10, 2),
+	MUX_PG(mfp3_9_8, 3, 8, 2),
+	MUX_PG(mfp3_7_6, 3, 6, 2),
+	MUX_PG(mfp3_5_4, 3, 4, 2),
+	MUX_PG(mfp3_3, 3, 3, 1),
+	MUX_PG(mfp3_2, 3, 2, 1),
+	MUX_PG(mfp3_1_0_nand_ceb2, 3, 0, 2),
+	MUX_PG(mfp3_1_0_nand_ceb3, 3, 0, 2),
+	
+	MUX_PG_DUMMY(dsi_dummy),
+	MUX_PG_DUMMY(nand_dummy),
+	MUX_PG_DUMMY(uart2_dummy),
+	MUX_PG_DUMMY(uart3_dummy),
+	MUX_PG_DUMMY(i2c1_dummy),
+	MUX_PG_DUMMY(i2c2_dummy),
+
+	PADDRV_PG(paddrv0_29_28, 0, 28),
+	PADDRV_PG(paddrv0_23_22, 0, 22),
+	PADDRV_PG(paddrv0_21_20, 0, 20),
+	PADDRV_PG(paddrv0_19_18, 0, 18),
+	PADDRV_PG(paddrv0_17_16, 0, 16),
+	PADDRV_PG(paddrv0_15_14, 0, 14),
+	PADDRV_PG(paddrv0_13_12, 0, 12),
+	PADDRV_PG(paddrv0_11_10, 0, 10),
+	PADDRV_PG(paddrv0_9_8, 0, 8),
+	PADDRV_PG(paddrv0_7_6, 0, 6),
+	PADDRV_PG(paddrv0_5_4, 0, 4),
+	PADDRV_PG(paddrv0_3_2, 0, 2),
+	PADDRV_PG(paddrv0_1_0, 0, 0),
+
+	PADDRV_PG(paddrv1_31_30, 1, 30),
+	PADDRV_PG(paddrv1_29_28, 1, 28),
+	PADDRV_PG(paddrv1_27_26, 1, 26),
+	PADDRV_PG(paddrv1_25_24, 1, 24),
+	PADDRV_PG(paddrv1_23_22, 1, 22),
+	PADDRV_PG(paddrv1_21_20, 1, 20),
+	PADDRV_PG(paddrv1_19_18, 1, 18),
+	PADDRV_PG(paddrv1_17_16, 1, 16),
+	PADDRV_PG(paddrv1_15_14, 1, 14),
+	PADDRV_PG(paddrv1_13_12, 1, 12),
+	PADDRV_PG(paddrv1_11_10, 1, 10),
+
+	PADDRV_PG(paddrv2_31_30, 2, 30),
+	PADDRV_PG(paddrv2_29_28, 2, 28),
+	PADDRV_PG(paddrv2_27_26, 2, 26),
+	PADDRV_PG(paddrv2_24_23, 2, 23),
+	PADDRV_PG(paddrv2_22_21, 2, 21),
+	PADDRV_PG(paddrv2_19_18, 2, 18),
+	PADDRV_PG(paddrv2_13_12, 2, 12),
+	PADDRV_PG(paddrv2_3_2, 2, 2),
+};
+
+int atm7059_num_groups = ARRAY_SIZE(atm7059_groups);
+
+static const char * const nor_groups[] = {
+	"mfp0_25_23",
+	"mfp0_5",
+	"mfp0_2_1_i2s0",
+	"mfp0_2_1_i2s1",
+	"mfp0_0",
+	"mfp1_31_29_ks_in2",
+	"mfp1_31_29_ks_in1",
+	"mfp1_31_29_ks_in0",
+	"mfp1_28_26_ks_in3",
+	"mfp1_28_26_ks_out0",
+	"mfp1_28_26_ks_out1",
+	"mfp1_25_23",
+	"mfp1_16_14",
+	"mfp1_6_5",
+	"mfp1_4_3",
+	"mfp1_2_0",
+	"mfp2_28_27",
+	"mfp2_19_17",
+	"mfp2_16_14",
+	"mfp2_13_11",
+	"mfp2_10_9",
+	"mfp2_8_7",
+	"mfp2_4_3",
+	"mfp3_23_22",
+	"mfp3_13_12",
+};
+
+static const char * const eth_rmii_groups[] = {
+	"mfp0_22_20",
+	"mfp0_18_16_eth_txd0",
+	"mfp0_18_16_eth_txd1",
+	"mfp0_15_13_rmii_txen",
+	"mfp0_15_13_rmii_rxen",
+	"mfp0_10_8_rmii_rxd1",
+	"mfp0_10_8_rmii_rxd0",
+	"mfp0_7_6",
+	"eth_smi_dummy",
+};
+
+static const char * const eth_smii_groups[] = {
+	"mfp0_22_20",
+	"mfp0_18_16_eth_txd0",
+	"mfp0_18_16_eth_txd1",
+	"mfp0_7_6",
+	"eth_smi_dummy",
+};
+
+static const char * const spi0_groups[] = {
+	"mfp1_20_19",
+	"mfp1_18_17",
+	"mfp1_9_7",
+	"mfp1_4_3",
+	"mfp1_2_0",
+	"mfp2_26_24",
+
+};
+
+static const char * const spi1_groups[] = {
+	"mfp2_2_0",
+	"mfp3_21_19",
+	"mfp3_18_16",
+};
+
+static const char * const spi2_groups[] = {
+	"mfp0_22_20",
+	"mfp0_18_16_eth_txd0",
+	"mfp0_18_16_eth_txd1",
+	"mfp0_7_6",
+	"mfp3_2",
+};
+
+static const char * const spi3_groups[] = {
+	"mfp0_15_13_rmii_txen",
+	"mfp0_15_13_rmii_rxen",
+	"mfp0_10_8_rmii_rxd1",
+	"mfp0_10_8_rmii_rxd0",
+};
+
+static const char * const sens0_groups[] = {
+	"mfp3_29_28",
+	"mfp3_23_22",
+	"mfp3_15_14",
+	"mfp3_13_12",
+};
+
+static const char * const sens1_groups[] = {
+	"mfp0_25_23",
+	"mfp1_31_29_ks_in2",
+	"mfp1_31_29_ks_in1",
+	"mfp1_31_29_ks_in0",
+	"mfp1_28_26_ks_in3",
+	"mfp1_28_26_ks_out0",
+	"mfp1_28_26_ks_out1",
+	"mfp1_25_23",
+	"mfp3_23_22",
+	"mfp3_11_10",
+	"mfp3_9_8",
+	"mfp3_7_6",
+	"mfp3_5_4",
+};
+
+static const char * const uart0_groups[] = {
+	"mfp2_23",
+	"mfp2_22",
+	"mfp2_2_0",
+	"mfp3_21_19",
+};
+
+static const char * const uart1_groups[] = {
+	"mfp2_13_11",
+	"mfp3_18_16",
+};
+
+static const char * const uart2_groups[] = {
+	"mfp0_15_13_rmii_txen",
+	"mfp0_15_13_rmii_rxen",
+	"mfp0_10_8_rmii_rxd1",
+	"mfp0_10_8_rmii_rxd0",
+	"mfp1_20_19",
+	"mfp1_18_17",
+	"mfp1_9_7",
+	"mfp2_26_24",
+	"mfp2_23",
+	"mfp2_22",
+	"mfp2_19_17",
+	"mfp2_16_14",
+	"mfp2_13_11",
+	"mfp2_2_0",
+	"mfp3_21_19",
+	"mfp3_18_16",
+	"uart2_dummy"
+};
+
+static const char * const uart3_groups[] = {
+	"mfp2_21",
+	"mfp2_20",
+	"uart3_dummy"
+};
+
+static const char * const uart4_groups[] = {
+	"mfp0_22_20",
+	"mfp0_7_6",
+	"mfp3_11_10",
+	"mfp3_9_8",
+};
+
+static const char * const uart5_groups[] = {
+	"mfp0_10_8_rmii_rxd1",
+	"mfp0_10_8_rmii_rxd0",
+	"mfp1_28_26_ks_out0",
+	"mfp1_25_23",
+	"mfp2_21",
+	"mfp2_20",
+	"mfp2_19_17",
+	"mfp2_16_14",
+};
+
+static const char * const uart6_groups[] = {
+	"mfp0_18_16_eth_txd0",
+	"mfp0_18_16_eth_txd1",
+	"mfp3_7_6",
+	"mfp3_5_4",
+};
+
+static const char * const i2s0_groups[] = {
+    "mfp0_5",
+	"mfp0_4_3",
+	"mfp0_2_1_i2s0",
+};
+
+static const char * const i2s1_groups[] = {
+	"mfp0_2_1_i2s1",
+	"mfp0_0",
+	"i2s1_dummy",
+	"mfp1_2_0",
+	"mfp2_2_0",
+	"mfp3_21_19",
+};
+
+static const char * const pcm1_groups[] = {
+	"mfp0_4_3",
+	"mfp1_2_0",
+	"mfp2_2_0",
+	"mfp3_21_19",
+	"mfp3_11_10",
+	"mfp3_9_8",
+	"mfp3_7_6",
+	"mfp3_5_4",
+};
+
+static const char * const pcm0_groups[] = {
+	"mfp0_2_1_i2s0",
+	"mfp0_2_1_i2s1",
+	"mfp1_4_3",
+	"mfp1_2_0",
+};
+
+static const char * const ks_groups[] = {
+	"mfp1_31_29_ks_in2",
+	"mfp1_31_29_ks_in1",
+	"mfp1_31_29_ks_in0",
+	"mfp1_28_26_ks_in3",
+	"mfp1_28_26_ks_out0",
+	"mfp1_28_26_ks_out1",
+	"mfp1_25_23",
+};
+
+static const char * const jtag_groups[] = {
+	"mfp1_31_29_ks_in2",
+	"mfp1_31_29_ks_in1",
+	"mfp1_31_29_ks_in0",
+	"mfp1_28_26_ks_in3",
+	"mfp1_28_26_ks_out1",
+	"mfp2_19_17",
+	"mfp2_13_11",
+	"mfp2_8_7",
+	"mfp2_6_5",
+};
+
+static const char * const pwm0_groups[] = {
+	"mfp1_31_29_ks_in2",
+	"mfp1_31_29_ks_in0",
+	"mfp0_15_13_rmii_txen",
+	"mfp3_13_12",
+};
+
+static const char * const pwm1_groups[] = {
+	"mfp0_15_13_rmii_rxen",
+	"mfp1_31_29_ks_in1",
+	"mfp1_28_26_ks_in3",
+	"mfp3_23_22",
+};
+
+static const char * const pwm2_groups[] = {
+	"mfp0_25_23",
+	"mfp0_10_8_rmii_rxd1",
+	"mfp1_28_26_ks_out0",
+	"mfp1_25_23",
+};
+
+static const char * const pwm3_groups[] = {
+	"mfp0_10_8_rmii_rxd0",
+	"mfp1_28_26_ks_out1",
+	"mfp1_16_14",
+};
+
+static const char * const pwm4_groups[] = {
+	"mfp0_25_23",
+	"mfp0_22_20",
+	"mfp0_18_16_eth_txd0",
+	"mfp1_31_29_ks_in0",
+	"mfp3_11_10",
+	"mfp3_1_0_nand_ceb3",
+};
+
+static const char * const pwm5_groups[] = {
+	"mfp0_18_16_eth_txd1",
+	"mfp1_31_29_ks_in1",
+	"mfp3_9_8",
+	"mfp3_1_0_nand_ceb2",
+};
+
+static const char * const p0_groups[] = {
+	"mfp1_31_29_ks_in2",
+	"mfp1_31_29_ks_in0",
+};
+
+static const char * const sd0_groups[] = {
+	"mfp1_28_26_ks_out0",
+	"mfp1_28_26_ks_out1",
+	"mfp1_25_23",
+	"mfp1_16_14",
+	"mfp1_13_12",
+	"mfp1_9_7",
+	"mfp2_19_17",
+	"mfp2_16_14",
+	"mfp2_13_11",
+	"mfp2_10_9",
+	"mfp2_8_7",
+	"mfp2_6_5",
+};
+
+static const char * const sd1_groups[] = {
+	"mfp1_18_17",
+	"mfp1_16_14",
+	"mfp1_13_12",
+	"mfp1_11_10",
+	"mfp2_30_29",
+	"mfp2_26_24",
+	"mfp2_10_9",
+	"mfp2_4_3",
+	"sd1_dummy",
+};
+
+static const char * const sd2_groups[] = {
+	"mfp3_3",
+};
+
+static const char * const i2c0_groups[] = {
+	"mfp2_2_0",
+	"mfp3_21_19",
+	"mfp3_18_16",
+};
+
+static const char * const i2c1_groups[] = {
+	"mfp3_18_16",
+	"i2c1_dummy"
+};
+
+static const char * const i2c2_groups[] = {
+	"i2c2_dummy"
+};
+
+static const char * const i2c3_groups[] = {
+	"mfp1_4_3",
+	"mfp3_7_6",
+	"mfp3_5_4",
+};
+
+static const char * const lvds_groups[] = {
+	"mfp1_22_21",
+	"mfp1_6_5",
+	"mfp2_28_27",
+};
+
+static const char * const ts_groups[] = {
+	"mfp1_22_21",
+	"mfp1_6_5",
+};
+
+static const char * const lcd0_groups[] = {
+	"mfp0_25_23",
+	"mfp1_16_14",
+	"mfp1_22_21",
+	"mfp1_13_12",
+	"mfp1_11_10",
+	"mfp1_6_5",
+	"mfp2_30_29",
+	"mfp2_28_27",
+};
+
+
+static const char * const usb30_groups[] = {
+	"mfp1_31_29_ks_in1",
+};
+
+static const char * const clko_25m_groups[] = {
+	"mfp3_30",
+};
+
+static const char * const mipi_csi_groups[] = {
+	"mfp3_29_28",
+	"mfp3_15_14",
+};
+
+static const char * const dsi_groups[] = {
+	"mfp1_20_19",
+	"mfp1_18_17",
+	"mfp1_13_12",
+	"mfp1_11_10",
+	"mfp1_9_7",
+	"mfp2_30_29",
+	"dsi_dummy",
+};
+
+static const char * const nand_groups[] = {
+	"mfp3_3",
+	"mfp3_2",
+	"mfp3_1_0_nand_ceb2",
+	"mfp3_1_0_nand_ceb3",
+	"nand_dummy",
+};
+
+static const char * const spdif_groups[] = {
+	"mfp3_21_19",
+};
+
+
+static const char * const sirq0_groups[] = {
+	"sirq0_dummy",
+};
+
+static const char * const sirq1_groups[] = {
+	"sirq1_dummy",
+};
+
+static const char * const sirq2_groups[] = {
+	"sirq2_dummy",
+};
+
+
+#define FUNCTION(fname)					\
+	{						\
+		.name = #fname,				\
+		.groups = fname##_groups,		\
+		.ngroups = ARRAY_SIZE(fname##_groups),	\
+	}
+
+const struct owl_pinmux_func atm7059_functions[] = {
+	[OWL_MUX_NOR] = FUNCTION(nor),
+	[OWL_MUX_ETH_RMII] = FUNCTION(eth_rmii),
+	[OWL_MUX_ETH_SMII] = FUNCTION(eth_smii),
+	[OWL_MUX_SPI0] = FUNCTION(spi0),
+	[OWL_MUX_SPI1] = FUNCTION(spi1),
+	[OWL_MUX_SPI2] = FUNCTION(spi2),
+	[OWL_MUX_SPI3] = FUNCTION(spi3),
+	[OWL_MUX_SENS0] = FUNCTION(sens0),
+	[OWL_MUX_SENS1] = FUNCTION(sens1),
+	[OWL_MUX_UART0] = FUNCTION(uart0),
+	[OWL_MUX_UART1] = FUNCTION(uart1),
+	[OWL_MUX_UART2] = FUNCTION(uart2),
+	[OWL_MUX_UART3] = FUNCTION(uart3),
+	[OWL_MUX_UART4] = FUNCTION(uart4),
+	[OWL_MUX_UART5] = FUNCTION(uart5),
+	[OWL_MUX_UART6] = FUNCTION(uart6),
+	[OWL_MUX_I2S0] = FUNCTION(i2s0),
+	[OWL_MUX_I2S1] = FUNCTION(i2s1),
+	[OWL_MUX_PCM1] = FUNCTION(pcm1),
+	[OWL_MUX_PCM0] = FUNCTION(pcm0),
+	[OWL_MUX_KS] = FUNCTION(ks),
+	[OWL_MUX_JTAG] = FUNCTION(jtag),
+	[OWL_MUX_PWM0] = FUNCTION(pwm0),
+	[OWL_MUX_PWM1] = FUNCTION(pwm1),
+	[OWL_MUX_PWM2] = FUNCTION(pwm2),
+	[OWL_MUX_PWM3] = FUNCTION(pwm3),
+	[OWL_MUX_PWM4] = FUNCTION(pwm4),
+	[OWL_MUX_PWM5] = FUNCTION(pwm5),
+	[OWL_MUX_P0] = FUNCTION(p0),
+	[OWL_MUX_SD0] = FUNCTION(sd0),
+	[OWL_MUX_SD1] = FUNCTION(sd1),
+	[OWL_MUX_SD2] = FUNCTION(sd2),
+	[OWL_MUX_I2C0] = FUNCTION(i2c0),
+	[OWL_MUX_I2C1] = FUNCTION(i2c1),
+	[OWL_MUX_I2C2] = FUNCTION(i2c2),
+	[OWL_MUX_I2C3] = FUNCTION(i2c3),
+	[OWL_MUX_DSI] = FUNCTION(dsi),
+	[OWL_MUX_LVDS] = FUNCTION(lvds),
+	[OWL_MUX_USB30] = FUNCTION(usb30),
+	[OWL_MUX_CLKO_25M] = FUNCTION(clko_25m),
+	[OWL_MUX_MIPI_CSI] = FUNCTION(mipi_csi),
+	[OWL_MUX_DSI] = FUNCTION(dsi),
+	[OWL_MUX_NAND] = FUNCTION(nand),
+	[OWL_MUX_SPDIF] = FUNCTION(spdif),
+	[OWL_MUX_SIRQ0] = FUNCTION(sirq0),
+	[OWL_MUX_SIRQ1] = FUNCTION(sirq1),
+	[OWL_MUX_SIRQ2] = FUNCTION(sirq2),
+	[OWL_MUX_TS] = FUNCTION(ts),
+	[OWL_MUX_LCD0] = FUNCTION(lcd0),
+};
+
+int atm7059_num_functions = ARRAY_SIZE(atm7059_functions);
+
+/******PAD SCHIMTT CONFIGURES*************************/
+
+/*refer to SPEC, schmitt trigger*/
+static unsigned int P_ETH_REF_CLK_schimtt_funcs[] = {
+	OWL_MUX_ETH_RMII,
+	OWL_MUX_ETH_SMII,
+};
+
+static unsigned int P_ETH_TXEN_schimtt_funcs[] = {
+	OWL_MUX_SPI3,
+};
+
+static unsigned int P_ETH_TXD0_schimtt_funcs[] = {
+	OWL_MUX_SPI2,
+	OWL_MUX_UART6,
+};
+
+static unsigned int P_I2S_LRCLK1_schimtt_funcs[] = {
+	OWL_MUX_PCM0,
+};
+
+static unsigned int P_UART0_TX_schimtt_funcs[] = {
+	OWL_MUX_I2C0,
+};
+
+static unsigned int P_SPI0_SCLK_schimtt_funcs[] = {
+	OWL_MUX_SPI0,
+	OWL_MUX_I2C3,
+	OWL_MUX_PCM0,
+};
+
+static unsigned int P_SD0_CLK_schimtt_funcs[] = {
+	OWL_MUX_JTAG,
+};
+
+static unsigned int P_KS_IN0_schimtt_funcs[] = {
+	OWL_MUX_JTAG,
+};
+
+static unsigned int P_I2C0_SCLK_schimtt_funcs[] = {
+	OWL_MUX_I2C0,
+	OWL_MUX_I2C1,
+	OWL_MUX_SPI1,
+};
+
+static unsigned int P_I2S_MCLK1_schimtt_funcs[] = {
+	OWL_MUX_PCM0,
+};
+
+static unsigned int P_KS_OUT0_schimtt_funcs[] = {
+	OWL_MUX_SENS1,
+};
+
+static unsigned int P_KS_OUT1_schimtt_funcs[] = {
+	OWL_MUX_SENS1,
+};
+
+static unsigned int P_KS_OUT2_schimtt_funcs[] = {
+	OWL_MUX_SENS1,
+};
+
+static unsigned int P_UART0_RX_schimtt_funcs[] = {
+	OWL_MUX_I2C0,
+};
+
+static unsigned int P_I2C0_SDATA_schimtt_funcs[] = {
+	OWL_MUX_I2C0,
+	OWL_MUX_I2C1,
+};
+
+static unsigned int P_I2S_BCLK0_schimtt_funcs[] = {
+	OWL_MUX_PCM0,
+};
+
+static unsigned int P_I2S_MCLK0_schimtt_funcs[] = {
+	OWL_MUX_PCM1,
+};
+
+static unsigned int P_SPI0_SS_schimtt_funcs[] = {
+	OWL_MUX_SPI0,
+};
+
+static unsigned int P_SPI0_MISO_schimtt_funcs[] = {
+	OWL_MUX_SPI0,
+	OWL_MUX_PCM1,
+	OWL_MUX_PCM0,
+};
+
+static unsigned int P_SPI0_MOSI_schimtt_funcs[] = {
+	OWL_MUX_SPI0,
+	OWL_MUX_I2C3,
+	OWL_MUX_PCM0,
+};
+
+static unsigned int P_I2C1_SCLK_schimtt_funcs[] = {
+	OWL_MUX_I2C1,
+};
+
+static unsigned int P_I2C1_SDATA_schimtt_funcs[] = {
+	OWL_MUX_I2C1,
+};
+
+static unsigned int P_I2C2_SCLK_schimtt_funcs[] = {
+	OWL_MUX_I2C2,
+};
+
+static unsigned int P_I2C2_SDATA_schimtt_funcs[] = {
+	OWL_MUX_I2C2,
+};
+
+static unsigned int P_PCM1_IN_schimtt_funcs[] = {
+	OWL_MUX_PCM1,
+};
+
+static unsigned int P_PCM1_SYNC_schimtt_funcs[] = {
+	OWL_MUX_PCM1,
+};
+
+static unsigned int P_PCM1_CLK_schimtt_funcs[] = {
+	OWL_MUX_PCM1,
+};
+
+static unsigned int P_ETH_TXD1_schimtt_funcs[] = {
+	OWL_MUX_SPI2,
+};
+
+static unsigned int P_ETH_RXER_schimtt_funcs[] = {
+	OWL_MUX_SPI3,
+};
+
+static unsigned int P_ETH_CRS_DV_schimtt_funcs[] = {
+	OWL_MUX_SPI2,
+	OWL_MUX_UART4,
+};
+
+static unsigned int P_ETH_RXD1_schimtt_funcs[] = {
+	OWL_MUX_SPI3,
+};
+
+static unsigned int P_ETH_RXD0_schimtt_funcs[] = {
+	OWL_MUX_SPI3,
+};
+
+static unsigned int P_UART2_RX_schimtt_funcs[] = {
+	OWL_MUX_UART2,
+};
+
+static unsigned int P_UART2_CTSB_schimtt_funcs[] = {
+	OWL_MUX_UART2,
+};
+
+static unsigned int P_UART3_RX_schimtt_funcs[] = {
+	OWL_MUX_UART3,
+};
+
+static unsigned int P_UART3_CTSB_schimtt_funcs[] = {
+	OWL_MUX_UART3,
+};
+
+static unsigned int P_UART2_RTSB_schimtt_funcs[] = {
+	OWL_MUX_UART0,
+};
+
+static unsigned int P_UART3_RTSB_schimtt_funcs[] = {
+	OWL_MUX_UART5,
+};
+
+static unsigned int P_I2S_LRCLK0_schimtt_funcs[] = {
+	OWL_MUX_PCM1,
+};
+
+static unsigned int P_DSI_DP0_schimtt_funcs[] = {
+	OWL_MUX_UART2,
+	OWL_MUX_SPI0,
+};
+
+static unsigned int P_DSI_DN0_schimtt_funcs[] = {
+	OWL_MUX_SPI0,
+};
+
+static unsigned int P_DSI_DP2_schimtt_funcs[] = {
+	OWL_MUX_SPI0,
+};
+
+static unsigned int P_DSI_DN2_schimtt_funcs[] = {
+	OWL_MUX_UART2,
+	OWL_MUX_SPI0,
+};
+
+
+#if 1
+#define SCHIMMT_CONF(pad_name, reg_n, sft)		\
+	{	\
+		.schimtt_funcs = pad_name##_schimtt_funcs,		\
+		.num_schimtt_funcs =	\
+			ARRAY_SIZE(pad_name##_schimtt_funcs),	\
+		.reg_num = reg_n,	\
+		.shift = sft,	\
+	}
+
+#else
+#define SCHIMMT_CONF(pad_name, reg_n, sft)		\
+	{	\
+		.schimtt_funcs = pad_name##_schimtt_funcs,		\
+		.reg_num = reg_n,	\
+		.shift = sft,	\
+	}
+#endif
+
+#if 0
+#define PAD_SCHIMMT_CONF(pad_name, reg_num, shift)		\
+	struct owl_pinconf_schimtt pad_name##_schimmt_conf	\
+		= SCHIMMT_CONF(pad_name, reg_num, shift)
+#endif
+
+#define PAD_SCHIMMT_CONF(pad_name, reg_n, sft)		\
+	struct owl_pinconf_schimtt pad_name##_schimmt_conf = {	\
+		.schimtt_funcs = pad_name##_schimtt_funcs,		\
+		.num_schimtt_funcs =	\
+			ARRAY_SIZE(pad_name##_schimtt_funcs),	\
+		.reg_num = reg_n,	\
+		.shift = sft,	\
+	}
+
+/*PAD_ST0*/
+static PAD_SCHIMMT_CONF(P_I2C0_SDATA, 0, 30);
+static PAD_SCHIMMT_CONF(P_UART0_RX, 0, 29);
+static PAD_SCHIMMT_CONF(P_I2S_MCLK1, 0, 23);
+static PAD_SCHIMMT_CONF(P_ETH_REF_CLK, 0, 22);
+static PAD_SCHIMMT_CONF(P_ETH_TXEN, 0, 21);
+static PAD_SCHIMMT_CONF(P_ETH_TXD0, 0, 20);
+static PAD_SCHIMMT_CONF(P_I2S_LRCLK1, 0, 19);
+static PAD_SCHIMMT_CONF(P_DSI_DP0, 0, 16);
+static PAD_SCHIMMT_CONF(P_DSI_DN0, 0, 15);
+static PAD_SCHIMMT_CONF(P_UART0_TX, 0, 14);
+static PAD_SCHIMMT_CONF(P_SPI0_SCLK, 0, 13);
+static PAD_SCHIMMT_CONF(P_SD0_CLK, 0, 12);
+static PAD_SCHIMMT_CONF(P_KS_IN0, 0, 11);
+static PAD_SCHIMMT_CONF(P_I2C0_SCLK, 0, 7);
+static PAD_SCHIMMT_CONF(P_KS_OUT0, 0, 6);
+static PAD_SCHIMMT_CONF(P_KS_OUT1, 0, 5);
+static PAD_SCHIMMT_CONF(P_KS_OUT2, 0, 4);
+
+/*PAD_ST1*/
+static PAD_SCHIMMT_CONF(P_DSI_DP2, 1, 31);
+static PAD_SCHIMMT_CONF(P_DSI_DN2, 1, 30);
+static PAD_SCHIMMT_CONF(P_I2S_LRCLK0, 1, 29);
+static PAD_SCHIMMT_CONF(P_UART3_CTSB, 1, 27);
+static PAD_SCHIMMT_CONF(P_UART3_RTSB, 1, 26);
+static PAD_SCHIMMT_CONF(P_UART3_RX, 1, 25);
+static PAD_SCHIMMT_CONF(P_UART2_RTSB, 1, 24);
+static PAD_SCHIMMT_CONF(P_UART2_CTSB, 1, 23);
+static PAD_SCHIMMT_CONF(P_UART2_RX, 1, 22);
+static PAD_SCHIMMT_CONF(P_ETH_RXD0, 1, 21);
+static PAD_SCHIMMT_CONF(P_ETH_RXD1, 1, 20);
+static PAD_SCHIMMT_CONF(P_ETH_CRS_DV, 1, 19);
+static PAD_SCHIMMT_CONF(P_ETH_RXER, 1, 18);
+static PAD_SCHIMMT_CONF(P_ETH_TXD1, 1, 17);
+static PAD_SCHIMMT_CONF(P_PCM1_CLK, 1, 11);
+static PAD_SCHIMMT_CONF(P_PCM1_IN, 1, 10);
+static PAD_SCHIMMT_CONF(P_PCM1_SYNC, 1, 9);
+static PAD_SCHIMMT_CONF(P_I2C1_SCLK, 1, 8);
+static PAD_SCHIMMT_CONF(P_I2C1_SDATA, 1, 7);
+static PAD_SCHIMMT_CONF(P_I2C2_SCLK, 1, 6);
+static PAD_SCHIMMT_CONF(P_I2C2_SDATA, 1, 5);
+static PAD_SCHIMMT_CONF(P_SPI0_MOSI, 1, 4);
+static PAD_SCHIMMT_CONF(P_SPI0_MISO, 1, 3);
+static PAD_SCHIMMT_CONF(P_SPI0_SS, 1, 2);
+static PAD_SCHIMMT_CONF(P_I2S_BCLK0, 1, 1);
+static PAD_SCHIMMT_CONF(P_I2S_MCLK0, 1, 0);
+
+
+/******PAD PULL UP/DOWN CONFIGURES*************************/
+#define PULL_CONF(reg_n, sft, w, pup, pdn)		\
+	{	\
+		.reg_num = reg_n,	\
+		.shift = sft,	\
+		.width = w,	\
+		.pullup = pup,		\
+		.pulldown = pdn,	\
+	}
+
+#define PAD_PULL_CONF(pad_name, reg_num,	\
+			shift, width, pull_up, pull_down)		\
+	struct owl_pinconf_reg_pull pad_name##_pull_conf	\
+		= PULL_CONF(reg_num, shift, width, pull_up, pull_down)
+
+/*PAD_PULLCTL0*/
+static PAD_PULL_CONF(P_PCM1_SYNC, 0, 30, 1, 0x1, 0);
+static PAD_PULL_CONF(P_PCM1_OUT, 0, 29, 1, 0x1, 0);
+static PAD_PULL_CONF(P_KS_OUT2, 0, 28, 1, 0x1, 0);
+static PAD_PULL_CONF(P_LCD0_D17, 0, 27, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DSI_DN3, 0, 26, 1, 0x1, 0);
+static PAD_PULL_CONF(P_ETH_RXER, 0, 16, 1, 0, 0x1);
+static PAD_PULL_CONF(P_SIRQ0, 0, 14, 2, 0x1, 0x2);
+static PAD_PULL_CONF(P_SIRQ1, 0, 12, 2, 0x1, 0x2);
+static PAD_PULL_CONF(P_SIRQ2, 0, 10, 2, 0x1, 0x2);
+static PAD_PULL_CONF(P_I2C0_SDATA, 0, 9, 1, 0x1, 0);
+static PAD_PULL_CONF(P_I2C0_SCLK, 0, 8, 1, 0x1, 0);
+static PAD_PULL_CONF(P_KS_IN0, 0, 7, 1, 0x1, 0);
+static PAD_PULL_CONF(P_KS_IN1, 0, 6, 1, 0x1, 0);
+static PAD_PULL_CONF(P_KS_IN2, 0, 5, 1, 0x1, 0);
+static PAD_PULL_CONF(P_KS_IN3, 0, 4, 1, 0x1, 0);
+static PAD_PULL_CONF(P_KS_OUT0, 0, 2, 1, 0x1, 0);
+static PAD_PULL_CONF(P_KS_OUT1, 0, 1, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DSI_DP1, 0, 0, 1, 0x1, 0);
+
+/*PAD_PULLCTL1*/
+static PAD_PULL_CONF(P_DSI_CP, 1, 31, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DSI_CN, 1, 30, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DSI_DN2, 1, 28, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DNAND_RDBN, 1, 25, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD0_D0, 1, 17, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD0_D1, 1, 16, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD0_D2, 1, 15, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD0_D3, 1, 14, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD0_CMD, 1, 13, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD0_CLK, 1, 12, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD1_CMD, 1, 11, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD1_D0, 1, 6, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD1_D1, 1, 5, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD1_D2, 1, 4, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SD1_D3, 1, 3, 1, 0x1, 0);
+static PAD_PULL_CONF(P_UART0_RX, 1, 2, 1, 0x1, 0);
+static PAD_PULL_CONF(P_UART0_TX, 1, 1, 1, 0x1, 0);
+static PAD_PULL_CONF(P_CLKO_25M, 1, 0, 1, 0, 0x1);
+
+/*PAD_PULLCTL2*/
+static PAD_PULL_CONF(P_SPI0_SCLK, 2, 12, 1, 0x1, 0);
+static PAD_PULL_CONF(P_SPI0_MOSI, 2, 11, 1, 0x1, 0);
+static PAD_PULL_CONF(P_I2C1_SDATA, 2, 10, 1, 0x1, 0);
+static PAD_PULL_CONF(P_I2C1_SCLK, 2, 9, 1, 0x1, 0);
+static PAD_PULL_CONF(P_I2C2_SDATA, 2, 8, 1, 0x1, 0);
+static PAD_PULL_CONF(P_I2C2_SCLK, 2, 7, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DNAND_DQSN, 2, 5, 2, 0x2, 0);
+static PAD_PULL_CONF(P_DNAND_DQS, 2, 3, 2, 0x1, 0x2);
+static PAD_PULL_CONF(P_DNAND_D0, 2, 2, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DNAND_D1, 2, 2, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DNAND_D2, 2, 2, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DNAND_D3, 2, 2, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DNAND_D4, 2, 2, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DNAND_D5, 2, 2, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DNAND_D6, 2, 2, 1, 0x1, 0);
+static PAD_PULL_CONF(P_DNAND_D7, 2, 2, 1, 0x1, 0);
+
+
+/********PAD INFOS*****************************/
+#define PAD_TO_GPIO(padnum)		\
+		((padnum < NUM_GPIOS) ? padnum : -1)
+
+#define PAD_INFO(name)		\
+	{		\
+		.pad = name,	\
+		.gpio = PAD_TO_GPIO(name),		\
+		.schimtt = NULL,		\
+		.pull = NULL,	\
+	}
+
+#define PAD_INFO_SCHIMTT(name)	\
+	{		\
+		.pad = name,	\
+		.gpio = PAD_TO_GPIO(name),		\
+		.schimtt = &name##_schimmt_conf,		\
+		.pull = NULL,	\
+	}
+
+#define PAD_INFO_PULL(name)	\
+	{		\
+		.pad = name,	\
+		.gpio = PAD_TO_GPIO(name),		\
+		.schimtt = NULL,		\
+		.pull = &name##_pull_conf,	\
+	}
+
+#define PAD_INFO_SCHIMTT_PULL(name)	\
+	{		\
+		.pad = name,	\
+		.gpio = PAD_TO_GPIO(name),		\
+		.schimtt = &name##_schimmt_conf,		\
+		.pull = &name##_pull_conf,	\
+	}
+
+/* Pad info table for the pinmux subsystem */
+struct owl_pinconf_pad_info atm7059_pad_tab[NUM_PADS] = {
+	[P_RESERA0] = PAD_INFO(P_RESERA0),
+	[P_RESERA1] = PAD_INFO(P_RESERA1),
+	[P_RESERA2] = PAD_INFO(P_RESERA2),
+	[P_RESERA3] = PAD_INFO(P_RESERA3),
+	[P_RESERA4] = PAD_INFO(P_RESERA4),
+	[P_RESERA5] = PAD_INFO(P_RESERA5),
+	[P_RESERA6] = PAD_INFO(P_RESERA6),
+	[P_RESERA7] = PAD_INFO(P_RESERA7),
+	[P_RESERA8] = PAD_INFO(P_RESERA8),
+	[P_RESERA9] = PAD_INFO(P_RESERA9),
+	[P_RESERA10] = PAD_INFO(P_RESERA10),
+	[P_RESERA11] = PAD_INFO(P_RESERA11),
+	[P_DNAND_DQS] = PAD_INFO_PULL(P_DNAND_DQS),
+	[P_DNAND_DQSN] = PAD_INFO_PULL(P_DNAND_DQSN),
+	[P_ETH_TXD0] = PAD_INFO_SCHIMTT(P_ETH_TXD0),
+	[P_ETH_TXD1] = PAD_INFO_SCHIMTT(P_ETH_TXD1),
+	[P_ETH_TXEN] = PAD_INFO_SCHIMTT(P_ETH_TXEN),
+	[P_ETH_RXER] = PAD_INFO_SCHIMTT_PULL(P_ETH_RXER),
+	[P_ETH_CRS_DV] = PAD_INFO_SCHIMTT(P_ETH_CRS_DV),
+	[P_ETH_RXD1] = PAD_INFO_SCHIMTT(P_ETH_RXD1),
+	[P_ETH_RXD0] = PAD_INFO_SCHIMTT(P_ETH_RXD0),
+	[P_ETH_REF_CLK] = PAD_INFO_SCHIMTT(P_ETH_REF_CLK),
+	[P_ETH_MDC] = PAD_INFO(P_ETH_MDC),
+	[P_ETH_MDIO] = PAD_INFO(P_ETH_MDIO),
+	[P_SIRQ0] = PAD_INFO_PULL(P_SIRQ0),
+	[P_SIRQ1] = PAD_INFO_PULL(P_SIRQ1),
+	[P_SIRQ2] = PAD_INFO_PULL(P_SIRQ2),
+	[P_I2S_D0] = PAD_INFO(P_I2S_D0),
+	[P_I2S_BCLK0] = PAD_INFO_SCHIMTT(P_I2S_BCLK0),
+	[P_I2S_LRCLK0] = PAD_INFO_SCHIMTT(P_I2S_LRCLK0),
+	[P_I2S_MCLK0] = PAD_INFO_SCHIMTT(P_I2S_MCLK0),
+	[P_I2S_D1] = PAD_INFO(P_I2S_D1),
+	[P_I2S_BCLK1] = PAD_INFO(P_I2S_BCLK1),
+	[P_I2S_LRCLK1] = PAD_INFO_SCHIMTT(P_I2S_LRCLK1),
+	[P_I2S_MCLK1] = PAD_INFO_SCHIMTT(P_I2S_MCLK1),
+	[P_KS_IN0] = PAD_INFO_SCHIMTT_PULL(P_KS_IN0),
+	[P_KS_IN1] = PAD_INFO_PULL(P_KS_IN1),
+	[P_KS_IN2] = PAD_INFO_PULL(P_KS_IN2),
+	[P_KS_IN3] = PAD_INFO_PULL(P_KS_IN3),
+	[P_KS_OUT0] = PAD_INFO_SCHIMTT_PULL(P_KS_OUT0),
+	[P_KS_OUT1] = PAD_INFO_SCHIMTT_PULL(P_KS_OUT1),
+	[P_KS_OUT2] = PAD_INFO_SCHIMTT_PULL(P_KS_OUT2),
+	[P_LVDS_OEP] = PAD_INFO(P_LVDS_OEP),
+	[P_LVDS_OEN] = PAD_INFO(P_LVDS_OEN),
+	[P_LVDS_ODP] = PAD_INFO(P_LVDS_ODP),
+	[P_LVDS_ODN] = PAD_INFO(P_LVDS_ODN),
+	[P_LVDS_OCP] = PAD_INFO(P_LVDS_OCP),
+	[P_LVDS_OCN] = PAD_INFO(P_LVDS_OCN),
+	[P_LVDS_OBP] = PAD_INFO(P_LVDS_OBP),
+	[P_LVDS_OBN] = PAD_INFO(P_LVDS_OBN),
+	[P_LVDS_OAP] = PAD_INFO(P_LVDS_OAP),
+	[P_LVDS_OAN] = PAD_INFO(P_LVDS_OAN),
+	[P_LVDS_EEP] = PAD_INFO(P_LVDS_EEP),
+	[P_LVDS_EEN] = PAD_INFO(P_LVDS_EEN),
+	[P_LVDS_EDP] = PAD_INFO(P_LVDS_EDP),
+	[P_LVDS_EDN] = PAD_INFO(P_LVDS_EDN),
+	[P_LVDS_ECP] = PAD_INFO(P_LVDS_ECP),
+	[P_LVDS_ECN] = PAD_INFO(P_LVDS_ECN),
+	[P_LVDS_EBP] = PAD_INFO(P_LVDS_EBP),
+	[P_LVDS_EBN] = PAD_INFO(P_LVDS_EBN),
+	[P_LVDS_EAP] = PAD_INFO(P_LVDS_EAP),
+	[P_LVDS_EAN] = PAD_INFO(P_LVDS_EAN),
+	[P_LCD0_D18] = PAD_INFO(P_LCD0_D18),
+	[P_LCD0_D17] = PAD_INFO_PULL(P_LCD0_D17),
+	[P_DSI_DP3] = PAD_INFO(P_DSI_DP3),
+	[P_DSI_DN3] = PAD_INFO_PULL(P_DSI_DN3),
+	[P_DSI_DP1] = PAD_INFO_PULL(P_DSI_DP1),
+	[P_DSI_DN1] = PAD_INFO(P_DSI_DN1),
+	[P_DSI_CP] = PAD_INFO_PULL(P_DSI_CP),
+	[P_DSI_CN] = PAD_INFO_PULL(P_DSI_CN),
+	[P_DSI_DP0] = PAD_INFO_SCHIMTT(P_DSI_DP0),
+	[P_DSI_DN0] = PAD_INFO_SCHIMTT(P_DSI_DN0),
+	[P_DSI_DP2] = PAD_INFO_SCHIMTT(P_DSI_DP2),
+	[P_DSI_DN2] = PAD_INFO_SCHIMTT_PULL(P_DSI_DN2),
+	[P_SD0_D0] = PAD_INFO_PULL(P_SD0_D0),
+	[P_SD0_D1] = PAD_INFO_PULL(P_SD0_D1),
+	[P_SD0_D2] = PAD_INFO_PULL(P_SD0_D2),
+	[P_SD0_D3] = PAD_INFO_PULL(P_SD0_D3),
+	[P_SD1_D0] = PAD_INFO_PULL(P_SD1_D0),
+	[P_SD1_D1] = PAD_INFO_PULL(P_SD1_D1),
+	[P_SD1_D2] = PAD_INFO_PULL(P_SD1_D2),
+	[P_SD1_D3] = PAD_INFO_PULL(P_SD1_D3),
+	[P_SD0_CMD] = PAD_INFO_PULL(P_SD0_CMD),
+	[P_SD0_CLK] = PAD_INFO_SCHIMTT_PULL(P_SD0_CLK),
+	[P_SD1_CMD] = PAD_INFO_PULL(P_SD1_CMD),
+	[P_SD1_CLK] = PAD_INFO(P_SD1_CLK),
+	[P_SPI0_SCLK] = PAD_INFO_SCHIMTT_PULL(P_SPI0_SCLK),
+	[P_SPI0_SS] = PAD_INFO_SCHIMTT(P_SPI0_SS),
+	[P_SPI0_MISO] = PAD_INFO_SCHIMTT(P_SPI0_MISO),
+	[P_SPI0_MOSI] = PAD_INFO_SCHIMTT_PULL(P_SPI0_MOSI),
+	[P_UART0_RX] = PAD_INFO_SCHIMTT_PULL(P_UART0_RX),
+	[P_UART0_TX] = PAD_INFO_SCHIMTT_PULL(P_UART0_TX),
+	[P_I2C0_SCLK] = PAD_INFO_SCHIMTT_PULL(P_I2C0_SCLK),
+	[P_I2C0_SDATA] = PAD_INFO_SCHIMTT_PULL(P_I2C0_SDATA),
+
+	[P_RESERC30] = PAD_INFO(P_RESERC30),
+	[P_SENSOR0_PCLK] = PAD_INFO(P_SENSOR0_PCLK),
+	[P_RESERD0] = PAD_INFO(P_RESERD0),
+	[P_RESERD1] = PAD_INFO(P_RESERD1),
+	[P_RESERD2] = PAD_INFO(P_RESERD2),
+	[P_RESERD3] = PAD_INFO(P_RESERD3),
+	[P_RESERD4] = PAD_INFO(P_RESERD4),
+	[P_RESERD5] = PAD_INFO(P_RESERD5),
+	[P_RESERD6] = PAD_INFO(P_RESERD6),
+	[P_RESERD7] = PAD_INFO(P_RESERD7),
+	[P_RESERD8] = PAD_INFO(P_RESERD8),
+	[P_RESERD9] = PAD_INFO(P_RESERD9),
+	[P_SENSOR0_CKOUT] = PAD_INFO(P_SENSOR0_CKOUT),
+	[P_RESERD11] = PAD_INFO(P_RESERD11),
+	[P_DNAND_ALE] = PAD_INFO(P_DNAND_ALE),
+	[P_DNAND_CLE] = PAD_INFO(P_DNAND_CLE),
+	[P_DNAND_CEB0] = PAD_INFO(P_DNAND_CEB0),
+	[P_DNAND_CEB1] = PAD_INFO(P_DNAND_CEB1),
+	[P_DNAND_CEB2] = PAD_INFO(P_DNAND_CEB2),
+	[P_DNAND_CEB3] = PAD_INFO(P_DNAND_CEB3),
+	[P_UART2_RX] = PAD_INFO_SCHIMTT(P_UART2_RX),
+	[P_UART2_TX] = PAD_INFO(P_UART2_TX),
+	[P_UART2_RTSB] = PAD_INFO_SCHIMTT(P_UART2_RTSB),
+	[P_UART2_CTSB] = PAD_INFO_SCHIMTT(P_UART2_CTSB),
+	[P_UART3_RX] = PAD_INFO_SCHIMTT(P_UART3_RX),
+	[P_UART3_TX] = PAD_INFO(P_UART3_TX),
+	[P_UART3_RTSB] = PAD_INFO_SCHIMTT(P_UART3_RTSB),
+	[P_UART3_CTSB] = PAD_INFO_SCHIMTT(P_UART3_CTSB),
+	[P_RESERD26] = PAD_INFO(P_RESERD26),
+	[P_RESERD27] = PAD_INFO(P_RESERD27),
+	[P_PCM1_IN] = PAD_INFO_SCHIMTT(P_PCM1_IN),
+	[P_PCM1_CLK] = PAD_INFO_SCHIMTT(P_PCM1_CLK),
+	[P_PCM1_SYNC] = PAD_INFO_SCHIMTT_PULL(P_PCM1_SYNC),
+	[P_PCM1_OUT] = PAD_INFO_PULL(P_PCM1_OUT),
+	[P_I2C1_SCLK] = PAD_INFO_SCHIMTT_PULL(P_I2C1_SCLK),
+	[P_I2C1_SDATA] = PAD_INFO_SCHIMTT_PULL(P_I2C1_SDATA),
+	[P_I2C2_SCLK] = PAD_INFO_SCHIMTT_PULL(P_I2C2_SCLK),
+	[P_I2C2_SDATA] = PAD_INFO_SCHIMTT_PULL(P_I2C2_SDATA),
+	[P_CSI_DN0] = PAD_INFO(P_CSI_DN0),
+	[P_CSI_DP0] = PAD_INFO(P_CSI_DP0),
+	[P_CSI_DN1] = PAD_INFO(P_CSI_DN1),
+	[P_CSI_DP1] = PAD_INFO(P_CSI_DP1),
+	[P_CSI_CN] = PAD_INFO(P_CSI_CN),
+	[P_CSI_CP] = PAD_INFO(P_CSI_CP),
+	[P_CSI_DN2] = PAD_INFO(P_CSI_DN2),
+	[P_CSI_DP2] = PAD_INFO(P_CSI_DP2),
+	[P_CSI_DN3] = PAD_INFO(P_CSI_DN3),
+	[P_CSI_DP3] = PAD_INFO(P_CSI_DP3),
+	[P_DNAND_D0] = PAD_INFO_PULL(P_DNAND_D0),
+	[P_DNAND_D1] = PAD_INFO_PULL(P_DNAND_D1),
+	[P_DNAND_D2] = PAD_INFO_PULL(P_DNAND_D2),
+	[P_DNAND_D3] = PAD_INFO_PULL(P_DNAND_D3),
+	[P_DNAND_D4] = PAD_INFO_PULL(P_DNAND_D4),
+	[P_DNAND_D5] = PAD_INFO_PULL(P_DNAND_D5),
+	[P_DNAND_D6] = PAD_INFO_PULL(P_DNAND_D6),
+	[P_DNAND_D7] = PAD_INFO_PULL(P_DNAND_D7),
+	[P_DNAND_WRB] = PAD_INFO(P_DNAND_WRB),
+	[P_DNAND_RDB] = PAD_INFO(P_DNAND_RDB),
+	[P_DNAND_RDBN] = PAD_INFO_PULL(P_DNAND_RDBN),
+	[P_DNAND_RB0] = PAD_INFO(P_DNAND_RB0),
+	[P_PORB] = PAD_INFO(P_PORB),
+	[P_CLKO_25M] = PAD_INFO_PULL(P_CLKO_25M),
+	[P_BSEL] = PAD_INFO(P_BSEL),
+	[P_PKG0] = PAD_INFO(P_PKG0),
+	[P_PKG1] = PAD_INFO(P_PKG1),
+	[P_PKG2] = PAD_INFO(P_PKG2),
+	[P_PKG3] = PAD_INFO(P_PKG3),
+};
+
+
+static struct owl_gpio_pad atm7059_gpio_pads[] = {
+	{.gpio = _GPIOD(28), .reg = SPS_PWR_CTL, .mask = 0x00000080, .bit = 7},
+	{.gpio = _GPIOD(29), .reg = SPS_PWR_CTL, .mask = 0x00000040, .bit = 6},
+	{.gpio = _GPIOD(30), .reg = SPS_PWR_CTL, .mask = 0x00000020, .bit = 5},
+	{.gpio = _GPIOD(31), .reg = SPS_PWR_CTL, .mask = 0x00000010, .bit = 4},
+};
+
+struct owl_gpio_pad_data atm7059_gpio_pad_data = 
+{
+	.gpio_pads = atm7059_gpio_pads, 
+	.size = sizeof(atm7059_gpio_pads)/sizeof(struct owl_gpio_pad),
+};
+
+
diff --git a/arch/arm/mach-owl/pinctrl_data-owl.h b/arch/arm/mach-owl/pinctrl_data-owl.h
new file mode 100755
index 0000000..0a3768c
--- /dev/null
+++ b/arch/arm/mach-owl/pinctrl_data-owl.h
@@ -0,0 +1,147 @@
+#ifndef __PINCTRL_DATA_OWL_H__ 
+#define __PINCTRL_DATA_OWL_H__
+
+#define PINCTRL_GROUP_NAME_LEN 24
+#define PINCTRL_MFPCTLREGS  4
+#define PINCTRL_GPIOBANKS   5
+#define PINCTRL_STREGS	    2
+
+enum owl_pinconf_param {
+	OWL_PINCONF_PARAM_PULL,
+	OWL_PINCONF_PARAM_PADDRV,
+	OWL_PINCONF_PARAM_SCHMITT,
+};
+
+enum owl_pinconf_pull {
+	OWL_PINCONF_PULL_NONE,
+	OWL_PINCONF_PULL_DOWN,
+	OWL_PINCONF_PULL_UP,
+};
+
+#define OWL_PINCONF_PACK(_param_, _arg_) ((_param_) << 16 | ((_arg_) & 0xffff))
+#define OWL_PINCONF_UNPACK_PARAM(_conf_) ((_conf_) >> 16)
+#define OWL_PINCONF_UNPACK_ARG(_conf_) ((_conf_) & 0xffff)
+
+
+
+/**
+ * struct owl_pinmux_group - describes a Actions SOC pin group
+ * @name: the name of this specific pin group
+ * @pads: an array of discrete physical pins, ie, named pads in ic spec,
+ *      used in this group, defined in driver-local pin enumeration space
+ * @padcnt: the number of pins in this group array, i.e. the number of
+ *	elements in .pads so we can iterate over that array
+ * @mfpctl: fragment of mfp code
+ * @gpiosw: gpio code for switch off pads
+ * @schimtt: schmitt trigger setup code for this module
+ */
+struct owl_group {
+	const char *name;
+	unsigned int *pads;
+	unsigned int padcnt;
+	unsigned int *funcs;
+	unsigned int nfuncs;
+
+	int mfpctl_regnum;
+	unsigned int mfpctl_shift;
+	unsigned int mfpctl_width;
+
+	int paddrv_regnum;
+	unsigned int paddrv_shift;
+	unsigned int paddrv_width;
+
+//	u32 gpiosw[PINCTRL_GPIOBANKS];
+//	u32 schimtt[PINCTRL_STREGS];
+};
+
+/**
+ * struct owl_pinmux_func - Actions SOC pinctrl mux functions
+ * @name: The name of the function, exported to pinctrl core.
+ * @groups: An array of pin groups that may select this function.
+ * @ngroups: The number of entries in @groups.
+ */
+struct owl_pinmux_func {
+	const char *name;
+	const char * const *groups;
+	unsigned ngroups;
+};
+
+/**
+ * struct owl_pinconf_reg_pull - Actions SOC pinctrl pull up/down regs
+ * @reg: The index of PAD_PULLCTL regs.
+ * @mask: The bit mask of PAD_PULLCTL fragment.
+ * @pullup: The pullup value of PAD_PULLCTL fragment.
+ * @pulldown: The pulldown value of PAD_PULLCTL fragment.
+ */
+struct owl_pinconf_reg_pull {
+	int reg_num;
+	unsigned int shift;
+	unsigned int width;
+	unsigned int pullup;
+	unsigned int pulldown;
+};
+
+/**
+ * struct owl_pinconf_schimtt - Actions SOC pinctrl PAD_ST regs
+ * @reg: The index of PAD_ST regs.
+ * @mask: The bit mask of PAD_ST fragment.
+ */
+struct owl_pinconf_schimtt {
+	unsigned int *schimtt_funcs;
+	unsigned int num_schimtt_funcs;
+	int reg_num;
+	unsigned int shift;
+};
+
+
+/**
+ * struct owl_pinconf_pad_info - Actions SOC pinctrl pad info
+ * @pad: The pin, in soc, the pad code of the silicon.
+ * @gpio: The gpio number of the pad.
+ * @pull: pull up/down reg, mask, and value.
+ * @paddrv: pad drive strength info.
+ * @schimtt: schimtt triger info.
+ */
+struct owl_pinconf_pad_info {
+	int  pad;
+	int  gpio;
+	struct owl_pinconf_reg_pull *pull;
+	struct owl_pinconf_schimtt *schimtt;
+};
+
+/**
+ * this struct is identical to pinctrl_pin_desc.
+ * struct pinctrl_pin_desc - boards/machines provide information on their
+ * pins, pads or other muxable units in this struct
+ * @number: unique pin number from the global pin number space
+ * @name: a name for this pin
+ */
+struct owl_pinctrl_pin_desc {
+	unsigned number;
+	const char *name;
+};
+
+struct owl_gpio_pad{
+	unsigned int gpio;
+	unsigned int reg;
+	unsigned int mask;
+	unsigned int bit;
+	int ref_count;
+};
+
+struct owl_gpio_pad_data {
+	struct owl_gpio_pad *gpio_pads;
+	int size;
+};
+
+extern const struct owl_pinctrl_pin_desc atm7059_pads[];
+extern unsigned int atm7059_num_pads;
+extern const struct owl_group atm7059_groups[];
+extern int atm7059_num_groups;
+extern const struct owl_pinmux_func atm7059_functions[];
+extern int atm7059_num_functions;
+extern struct owl_pinconf_pad_info atm7059_pad_tab[];
+extern struct owl_gpio_pad_data atm7059_gpio_pad_data;
+
+#endif /* __PINCTRL_DATA_OWL_H__ */
+
diff --git a/arch/arm/mach-owl/platsmp-owl.c b/arch/arm/mach-owl/platsmp-owl.c
new file mode 100755
index 0000000..5afc13f
--- /dev/null
+++ b/arch/arm/mach-owl/platsmp-owl.c
@@ -0,0 +1,223 @@
+/*
+ * arch/arm/mach-owl/platsmp-owl.c
+ *
+ * Platform file needed for Leopard. This file is based on arm
+ * realview smp platform.
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/cpu.h>
+
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+#include <asm/smp_scu.h>
+
+#include <mach/hardware.h>
+#include <mach/powergate.h>
+#include <mach/smp.h>
+#include <mach/module-owl.h>
+
+#define BOOT_FLAG					(0x55aa)
+#define CPU_SHIFT(cpu)	(19 + cpu)
+
+static DEFINE_SPINLOCK(boot_lock);
+
+static void __iomem *scu_base_addr(void)
+{
+	return (void *)IO_ADDRESS(OWL_PA_SCU);
+}
+
+/*
+ * Write pen_release in a way that is guaranteed to be visible to all
+ * observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void write_pen_release(int val)
+{
+	pen_release = val;
+	smp_wmb();
+	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+}
+
+void __cpuinit owl_secondary_init(unsigned int cpu)
+{
+	trace_hardirqs_off();
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+static void wakeup_secondary(unsigned int cpu)
+{
+	enum owl_powergate_id cpuid;
+
+	cpuid = owl_cpu_powergate_id(cpu);
+	owl_powergate_power_on(cpuid);
+
+	/* wait CPUx run to WFE instruct */
+	udelay(200);
+
+	/*
+	 * write the address of secondary startup into the boot ram register
+	 * at offset 0x204/0x304, then write the flag to the boot ram register
+	 * at offset 0x200/0x300, which is what boot rom code is waiting for.
+	 * This would wake up the secondary core from WFE
+	 */
+	switch (cpu) {
+	case 1:
+		/* ensure cpu1 dbg module reset complete before access dbg register */
+		module_reset(MODULE_RST_DBG1RESET);
+		udelay(10);
+		
+		act_writel(virt_to_phys(owl_secondary_startup), CPU1_ADDR);
+		act_writel(BOOT_FLAG, CPU1_FLAG);
+		break;
+	case 2:
+		act_writel(virt_to_phys(owl_secondary_startup),
+				 CPU2_ADDR);
+		act_writel(BOOT_FLAG, CPU2_FLAG);
+		break;
+	case 3:
+		act_writel(virt_to_phys(owl_secondary_startup),
+				CPU3_ADDR);
+		act_writel(BOOT_FLAG, CPU3_FLAG);
+		break;
+	default:
+		printk(KERN_INFO "%s(): invalid cpu number %d\n",
+			__func__, cpu);
+		break;
+	}
+
+	/*
+	 * Send a 'sev' to wake the secondary core from WFE.
+	 * Drain the outstanding writes to memory
+	 */
+	dsb_sev();
+	mb();
+}
+
+int __cpuinit owl_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	wakeup_secondary(cpu);
+
+	/* wait for CPUx wakeup */
+	udelay(10);
+
+	/*
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 */
+	write_pen_release(cpu_logical_map(cpu));
+	smp_send_reschedule(cpu);
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		if (pen_release == -1)
+			break;
+	}
+
+	switch (cpu) {
+	case 1:
+		act_writel(0, CPU1_ADDR);
+		act_writel(0, CPU1_FLAG);
+		break;
+	case 2:
+		act_writel(0, CPU2_ADDR);
+		act_writel(0, CPU2_FLAG);
+		break;
+	case 3:
+		act_writel(0, CPU3_ADDR);
+		act_writel(0, CPU3_FLAG);
+		break;
+	default:
+		printk(KERN_INFO "%s(): invalid cpu number %d\n",
+			__func__, cpu);
+		break;
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+static bool powersave = false;
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init owl_smp_init_cpus(void)
+{
+	void __iomem *scu_base = scu_base_addr();
+	unsigned int i, ncores;
+
+	ncores = scu_base ? scu_get_core_count(scu_base) : 1;
+
+	printk(KERN_INFO "%s(): ncores %d\n", __func__, ncores);
+
+	/* sanity check */
+	if (ncores > nr_cpu_ids) {
+		printk(KERN_WARNING
+			"[PLATSMP] no. of cores (%d) greater than configured "
+			"maximum of %d - clipping\n",
+			ncores, nr_cpu_ids);
+		ncores = nr_cpu_ids;
+	}
+	
+	if(powersave)
+		ncores = 2;
+	
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+}
+
+void __init owl_smp_prepare_cpus(unsigned int max_cpus)
+{
+	printk(KERN_INFO "%s(max_cpus:%d)\n", __func__, max_cpus);
+
+	scu_enable(scu_base_addr());
+}
+
+static int __init powersave_set(char *__unused)
+{
+	powersave = true;
+	pr_alert("powersave now\n");
+	return 0;
+}
+early_param("powersave", powersave_set);
+
diff --git a/arch/arm/mach-owl/pm-owl.c b/arch/arm/mach-owl/pm-owl.c
new file mode 100755
index 0000000..64eca13
--- /dev/null
+++ b/arch/arm/mach-owl/pm-owl.c
@@ -0,0 +1,1004 @@
+/*
+ * Copyright 2013 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/errno.h>
+#include <linux/export.h>
+#include <linux/power_supply.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/syscalls.h>
+#include <asm/system_misc.h>
+#include <asm/smp_scu.h>
+#include <asm/cacheflush.h>
+#include <mach/hardware.h>
+#include <mach/power.h>
+#include <mach/powergate.h>
+#include <linux/of_gpio.h>
+#include <linux/mfd/atc260x/atc260x.h>
+#include <linux/highmem.h>
+
+#define OWL_BOOT_MAX_PWM_NUM	3
+#define CMU_DEVCLKEN1_PWM0_EN	23
+
+
+
+
+int owl_powergate_suspend(void);
+int owl_powergate_resume(void);
+
+static int _pmic_warn_null_cb(void)
+{
+	pr_err("[PM] owl_pmic_pm_ops not registered!\n");
+	return -ENODEV;
+}
+static int _pmic_warn_null_cb_1ui(uint) __attribute__((alias("_pmic_warn_null_cb")));
+static int _pmic_warn_null_cb_2ui(uint, uint) __attribute__((alias("_pmic_warn_null_cb")));
+static int _pmic_warn_null_cb_3uip(uint*, uint*, uint*) __attribute__((alias("_pmic_warn_null_cb")));
+static struct owl_pmic_pm_ops s_pmic_fallback_pm_ops = {
+	.set_wakeup_src    = _pmic_warn_null_cb_2ui,
+	.get_wakeup_src    = _pmic_warn_null_cb,
+	.get_wakeup_flag   = _pmic_warn_null_cb,
+	.shutdown_prepare  = _pmic_warn_null_cb,
+	.powerdown         = _pmic_warn_null_cb_2ui,
+	.reboot            = _pmic_warn_null_cb_1ui,
+	.suspend_prepare   = _pmic_warn_null_cb,
+	.suspend_enter     = _pmic_warn_null_cb,
+	.suspend_wake      = _pmic_warn_null_cb,
+	.suspend_finish    = _pmic_warn_null_cb,
+	.get_bus_info      = _pmic_warn_null_cb_3uip,
+};
+static struct owl_pmic_pm_ops *s_pmic_pm_ops = &s_pmic_fallback_pm_ops;
+static volatile unsigned long s_pmic_pending_aux_wakeup_src_mask = 0;
+static volatile unsigned long s_pmic_pending_aux_wakeup_src_val = 0;
+
+static void (*charger_adjust)(int pre_post, int dev_type, int param);
+
+#define ADAPTER_TYPE_NO_PLUGIN             0
+#define ADAPTER_TYPE_WALL_PLUGIN           1
+#define ADAPTER_TYPE_PC_USB_PLUGIN         2
+#define ADAPTER_TYPE_USB_ADAPTER_PLUGIN    3
+#define ADAPTER_TYPE_USB_WALL_PLUGIN       4
+#define GPIO_NAME_RESTART_CTRL "restart_ctrl"
+
+#define PM_SYMBOL(symbol)  \
+	EXPORT_SYMBOL(symbol)
+
+static int _pm_tmp_judge_adapter_type(void)
+{
+	pr_err("[PM] judge_adapter_type not registered!\n");
+	return -ENODEV;
+}
+static int (*s_judge_adapter_type)(void) = _pm_tmp_judge_adapter_type;
+int set_judge_adapter_type_handle(void *handle)
+{
+	s_judge_adapter_type = handle;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(set_judge_adapter_type_handle);
+
+
+void system_powerdown_withgpio(void)
+{
+	struct device_node *node;
+	int restart_ctrl_gpio;
+	enum of_gpio_flags flags;
+
+	pr_err("%s\n", __func__);
+
+	sys_sync();
+	sys_sync();
+	sys_sync();
+	sys_sync();
+	sys_sync();
+	mdelay(1000);
+
+	node = of_find_node_by_name(NULL, "atc260x-power");
+	if (!node) {
+		pr_err("cann't find power node\n");
+		return;
+	}
+
+	restart_ctrl_gpio = of_get_named_gpio_flags(node, "system_restart_gpio",
+						    0, &flags);
+	if (restart_ctrl_gpio < 0) {
+		pr_err("cann't find system_restart_gpio\n");
+		return;
+	}
+
+	if (gpio_request(restart_ctrl_gpio, GPIO_NAME_RESTART_CTRL) < 0) {
+		pr_err("%s: restart_ctrl_gpio%d request failed!\n",
+			__func__, restart_ctrl_gpio);
+		return;
+	}
+
+	pr_err("%s, restart_ctrl_gpio =%d, flag=%d\n",
+		__func__, restart_ctrl_gpio, flags & OF_GPIO_ACTIVE_LOW);
+	gpio_direction_output(restart_ctrl_gpio, flags & OF_GPIO_ACTIVE_LOW);
+
+	while (1)
+		;
+
+	return;
+}
+EXPORT_SYMBOL_GPL(system_powerdown_withgpio);
+
+void owl_pm_halt(void)
+{
+	int deep_pwrdn, wakeup_src;
+
+	pr_info("[PM] %s %d:\n", __func__, __LINE__);
+
+	s_pmic_pm_ops->shutdown_prepare();
+
+	/* default sleep mode and wakeup source */
+	/* DO NOT add HARD_SWITCH source, we are here just because no batt switch. */
+	wakeup_src = OWL_PMIC_WAKEUP_SRC_RESET |
+		OWL_PMIC_WAKEUP_SRC_ONOFF_LONG/* |
+		OWL_PMIC_WAKEUP_SRC_WALL_IN |
+		OWL_PMIC_WAKEUP_SRC_VBUS_IN*/;
+
+	/* if wall/usb is connect, cannot enter S4, only can enter S3 */
+	deep_pwrdn = 0;
+	if (!power_supply_is_system_supplied())
+		deep_pwrdn = 1;
+
+	/* Power off system */
+	pr_info("Powering off (wakesrc: 0x%x, deep_pwrdn:%d)\n",
+		wakeup_src, deep_pwrdn);
+
+	s_pmic_pm_ops->set_wakeup_src(OWL_PMIC_WAKEUP_SRC_ALL, wakeup_src);
+	s_pmic_pm_ops->powerdown(deep_pwrdn, false);
+
+	/* never return to here */
+	pr_err("[PM] %s() failed\n", __func__);
+}
+EXPORT_SYMBOL_GPL(owl_pm_halt);
+
+static void owl_pm_halt_upgrade(void)
+{
+    int deep_pwrdn, wakeup_src;
+
+    pr_info("[PM] %s %d:\n", __func__, __LINE__);
+
+	s_pmic_pm_ops->shutdown_prepare();
+
+    /* default sleep mode and wakeup source */
+    /*xyl :alarm wakesource has some problem, so forbidden it until it's OK*/
+    deep_pwrdn = 0;
+    wakeup_src = OWL_PMIC_WAKEUP_SRC_RESET |
+			OWL_PMIC_WAKEUP_SRC_ONOFF_LONG;
+
+	/* Power off system */
+	pr_info("Powering off (wakesrc: 0x%x, deep_pwrdn:%d)\n",
+        wakeup_src, deep_pwrdn);
+
+	s_pmic_pm_ops->set_wakeup_src(OWL_PMIC_WAKEUP_SRC_ALL, wakeup_src);
+	s_pmic_pm_ops->powerdown(deep_pwrdn, true);
+
+    /* never return to here */
+    pr_err("[PM] %s() failed\n", __func__);
+}
+
+static void owl_pm_restart(enum reboot_mode mode, const char *cmd)
+{
+	pr_info("[PM] %s() cmd: %s\n", __func__, cmd ? cmd : "<null>");
+
+	s_pmic_pm_ops->shutdown_prepare();
+
+	if (cmd) {
+		if (!strcmp(cmd, "recovery")) {
+			pr_info("cmd:%s----restart------\n", cmd);
+			s_pmic_pm_ops->reboot(OWL_PMIC_REBOOT_TGT_RECOVERY);
+		} else if (!strcmp(cmd, "adfu")) {
+			pr_info("cmd:%s----restart------\n", cmd);
+			s_pmic_pm_ops->reboot(OWL_PMIC_REBOOT_TGT_ADFU);
+		} else if (!strcmp(cmd, "reboot")) {
+			pr_info("cmd:%s----restart------\n", cmd);
+			s_pmic_pm_ops->reboot(OWL_PMIC_REBOOT_TGT_SYS); /* no charger */
+		} else if (!strcmp(cmd, "upgrade_halt")) {
+			pr_info("cmd:%s----halt------\n", cmd);
+    		owl_pm_halt_upgrade();
+		}else if (!strcmp(cmd, "bootloader")) {
+			pr_info("cmd:%s----restart------\n", cmd);
+    		s_pmic_pm_ops->reboot(OWL_PMIC_REBOOT_TGT_BOOTLOADER);
+		}else if (!strcmp(cmd, "fastboot")) {
+			pr_info("cmd:%s----restart------\n", cmd);
+    		s_pmic_pm_ops->reboot(OWL_PMIC_REBOOT_TGT_FASTBOOT);
+		}			
+	}
+
+	/* fallback to reboot (no charger)*/
+	s_pmic_pm_ops->reboot(OWL_PMIC_REBOOT_TGT_SYS);
+
+	pr_err("[PM] %s() failed\n", __func__);
+}
+
+
+struct sleep_save {
+	u32 reg;
+	u32 val;
+};
+
+struct sleep_save owl_reg_save[] = {
+//	{.reg = SPS_PG_CTL},
+	{.reg = SPS_PWR_CTL},
+#if 1
+	{.reg = CMU_NANDPLL},
+	{.reg = CMU_DISPLAYPLL},
+	{.reg = CMU_AUDIOPLL},
+	{.reg = CMU_TVOUTPLL},
+	{.reg = CMU_SENSORCLK},
+	{.reg = CMU_LCDCLK},
+	{.reg = CMU_CSICLK},
+	{.reg = CMU_DECLK},
+	{.reg = CMU_BISPCLK},
+	{.reg = CMU_VDECLK},
+	{.reg = CMU_VCECLK},
+	{.reg = CMU_GPU3DCLK},
+	{.reg = CMU_NANDCCLK},
+	{.reg = CMU_SD0CLK},
+	{.reg = CMU_SD1CLK},
+	{.reg = CMU_SD2CLK},
+	{.reg = CMU_UART0CLK},
+	{.reg = CMU_UART1CLK},
+	{.reg = CMU_UART2CLK},
+	{.reg = CMU_PWM4CLK},
+	{.reg = CMU_PWM5CLK},
+	{.reg = CMU_PWM0CLK},
+	{.reg = CMU_PWM1CLK},
+	{.reg = CMU_PWM2CLK},
+	{.reg = CMU_PWM3CLK},
+	{.reg = CMU_USBPLL},
+	{.reg = CMU_LENSCLK},
+	{.reg = CMU_GPU3DCLK},
+	{.reg = CMU_ETHERNETPLL},
+	{.reg = CMU_CVBSPLL},
+	{.reg = CMU_DEVCLKEN0},
+	{.reg = CMU_DEVCLKEN1},
+	{.reg = CMU_DEVRST0},
+	{.reg = CMU_DEVRST1},
+	{.reg = CMU_UART3CLK},
+	{.reg = CMU_UART4CLK},
+	{.reg = CMU_UART5CLK},
+	{.reg = CMU_UART6CLK},
+#endif
+	{.reg = T0_VAL},
+	{.reg = T0_CTL},
+	{.reg = T0_CMP},
+	{.reg = MFP_CTL0},
+	{.reg = MFP_CTL1},
+	{.reg = MFP_CTL2},
+	{.reg = MFP_CTL3},
+	{.reg = INTC_EXTCTL},
+	{.reg = PAD_PULLCTL0},
+	{.reg = PAD_PULLCTL1},
+	{.reg = PAD_PULLCTL2},
+	{.reg = PAD_DRV0},
+	{.reg = PAD_DRV1},
+	{.reg = PAD_DRV2},
+	{.reg = INTC_GPIOCTL},
+	{.reg = GPIO_AOUTEN},
+	{.reg = GPIO_AINEN},
+	{.reg = GPIO_ADAT},
+	{.reg = GPIO_BOUTEN},
+	{.reg = GPIO_BINEN},
+	{.reg = GPIO_BDAT},
+	{.reg = GPIO_COUTEN},
+	{.reg = GPIO_CINEN},
+	{.reg = GPIO_CDAT},
+	{.reg = GPIO_DOUTEN},
+	{.reg = GPIO_DINEN},
+	{.reg = GPIO_DDAT},
+	{.reg = GPIO_EOUTEN},
+	{.reg = GPIO_EINEN},
+	{.reg = GPIO_EDAT},
+	{.reg = INTC_GPIOA_MSK},
+	{.reg = INTC_GPIOB_MSK},
+	{.reg = INTC_GPIOC_MSK},
+	{.reg = INTC_GPIOD_MSK},
+	{.reg = INTC_GPIOE_MSK},
+	{.reg = INTC_GPIOA_TYPE0},
+	{.reg = INTC_GPIOA_TYPE1},
+	{.reg = INTC_GPIOB_TYPE0},
+	{.reg = INTC_GPIOC_TYPE1},
+	{.reg = INTC_GPIOD_TYPE0},
+	{.reg = INTC_GPIOD_TYPE1},
+	{.reg = INTC_GPIOE_TYPE},
+	{.reg = UART0_CTL},
+	{.reg = UART1_CTL},
+	{.reg = UART2_CTL},
+	{.reg = UART3_CTL},
+	{.reg = UART4_CTL},
+	{.reg = UART5_CTL},
+	{.reg = UART6_CTL},
+	{.reg = USB3_P0_CTL},
+};
+struct mfp_t
+{
+    /* offs: 0x0 */
+	unsigned char shift;
+    /* offs: 0x1 */
+	unsigned char mask;
+    /* offs: 0x2 */
+	unsigned char val;
+    /* offs: 0x3 */
+	unsigned char no;
+};
+
+
+struct pwm_config_t
+{
+    /* offs: 0x0 */
+	unsigned long pwm_val;
+    /* offs: 0x4 */
+	struct mfp_t mfp;
+} ;
+
+
+
+static struct pwm_config_t owl_pwm_config_saved[3] =
+{
+/*0*/
+		{
+			.mfp = {
+			.shift = 0,
+			.mask = 0,
+			.val = 0,
+			.no = 0,
+				},
+
+		},
+/*1*/
+		{
+			.mfp = {
+			.shift = 0,
+			.mask = 0,
+			.val = 0,
+			.no = 0,
+			},
+
+		},
+/*2*/
+
+		{
+			.mfp = {
+			.shift = 0,
+			.mask = 0,
+			.val = 0,
+			.no = 0,
+			},
+		},
+};
+
+static unsigned int core_pll, dev_pll, bus_pll, bus1_pll;
+
+static void owl_core_clk_save(void)
+{
+	core_pll = act_readl(CMU_COREPLL);
+	if((core_pll&0x000000ff) > 0x32)
+		core_pll = (core_pll&0xffffff00)|0x32;
+	dev_pll  = act_readl(CMU_DEVPLL);
+	bus_pll  = act_readl(CMU_BUSCLK);
+	bus1_pll = act_readl(CMU_BUSCLK1);
+}
+
+static void owl_bus_clk_restore(void)
+{
+#define BUSCLK_CPUCLK_MASK	(0x3)
+	unsigned int mask;
+	unsigned int busclk = bus_pll & (~BUSCLK_CPUCLK_MASK);
+	
+	//打开noc时钟通路
+#define DEVCLKEN_NOC1			(0x1 << 28)
+	act_writel(act_readl(CMU_DEVCLKEN1) | DEVCLKEN_NOC1, CMU_DEVCLKEN1);	
+	//将devclk源切到hosc
+#define DEVCLKSS_MASK			(0x1 << 12)
+#define DEVCLKSS_HOSC			(0x0 << 12)
+	act_writel((act_readl(CMU_DEVPLL) & (~DEVCLKSS_MASK)) | DEVCLKSS_HOSC, CMU_DEVPLL);	
+	// udelay(5);
+	//待频率真正变为hosc时，取消noc分频
+#define BUSCLK_DIVEN			(0x1 << 31)
+	act_writel(act_readl(CMU_BUSCLK) & (~BUSCLK_DIVEN), CMU_BUSCLK);	
+	// udelay(5);
+	//取消noc分频后，调整noc分频系数
+	mask = ~(BUSCLK_DIVEN | DEVCLKSS_MASK);
+	act_writel((act_readl(CMU_BUSCLK) & (~mask)) | (busclk & mask), CMU_BUSCLK);	
+	act_writel(bus1_pll, CMU_BUSCLK1);
+	// udelay(5);
+	//打开noc分频
+	act_writel(act_readl(CMU_BUSCLK) | BUSCLK_DIVEN, CMU_BUSCLK);	
+	//打开dev_pll并设置dev_pll频率
+	act_writel((act_readl(CMU_DEVPLL) & DEVCLKSS_MASK) | (dev_pll & (~DEVCLKSS_MASK)), CMU_DEVPLL);	
+	// udelay(70);
+	udelay(1);
+	//等待pll输出稳定后，将devclk源切到dev_pll
+#define DEVCLKSS_DEVPLL			(0x1 << 12)
+	act_writel(dev_pll, CMU_DEVPLL);
+	// udelay(5);
+}
+
+static void owl_cpu_clk_restore(void)
+{
+	//cpuclk源切为hosc
+#define BUSCLK_CPUCLK_MASK		(0x3)
+#define BUSCLK_CPUCLK_HOSC		(0x1)
+#define BUSCLK_CPUCLK_COREPLL	(0x2)
+
+	act_writel((act_readl(CMU_BUSCLK) & (~BUSCLK_CPUCLK_MASK)) | BUSCLK_CPUCLK_HOSC, CMU_BUSCLK);
+	udelay(5);
+	//打开corepll，并设置频率
+	act_writel(core_pll, CMU_COREPLL);
+	udelay(70);
+	//等待corepll稳定输出后，将cpuclk源切换为corepll
+	act_writel((act_readl(CMU_BUSCLK) & (~BUSCLK_CPUCLK_MASK)) | BUSCLK_CPUCLK_COREPLL, CMU_BUSCLK);
+}
+
+
+void owl_pm_do_save(void)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(owl_reg_save); i++)
+		owl_reg_save[i].val = act_readl(owl_reg_save[i].reg);
+}
+EXPORT_SYMBOL(owl_pm_do_save);
+
+#if 0
+pwm_config_0_pwm_val = <0>;
+pwm_config_0_shift = <0>;
+pwm_config_0_mask = <0>;
+pwm_config_0_val = <0>;
+pwm_config_0_no = <0>;
+pwm_config_1_pwm_val = <0x102c3f>;
+pwm_config_1_shift = <0x26>;
+pwm_config_1_mask = <0x7>;
+pwm_config_1_val = <0x3>;
+pwm_config_1_no = <0x1>;
+pwm_config_2_pwm_val = <0x10343f>;
+pwm_config_2_shift = <0x26>;
+pwm_config_2_mask = <0x7>;
+pwm_config_2_val = <0x3>;
+pwm_config_2_no = <0x1>;
+#endif
+void owl_pwm_config_save(void)
+{
+	int i, offset;
+	for(i = 0; i < OWL_BOOT_MAX_PWM_NUM; i++)
+	{
+		offset = i * 4;
+		owl_pwm_config_saved[i].pwm_val = act_readl(offset + PWM_CTL0);
+	}
+}
+
+
+void owl_pwm_config_restore(void)
+{
+
+	unsigned int i, val, offset;
+
+	for(i = 0; i < OWL_BOOT_MAX_PWM_NUM; i++)
+	{
+		//owl_printf("afinfo address is 0x%x, pwm_config is 0x%x\n", atc260x_pwm_config, &(atc260x_pwm_config->pwm_config[i]));
+		if(owl_pwm_config_saved[i].pwm_val == 0)
+			continue;
+
+		printk("pwm%d val=0x%x\n", i, (unsigned int)owl_pwm_config_saved[i].pwm_val);
+
+		val = act_readl(CMU_DEVCLKEN1);
+		val |= 1 << (i + CMU_DEVCLKEN1_PWM0_EN);
+		act_writel(val, CMU_DEVCLKEN1);
+
+		offset = i * 4;
+		act_writel(0x1000, offset + CMU_PWM0CLK);
+		act_writel(owl_pwm_config_saved[i].pwm_val, offset + PWM_CTL0);
+		act_readl(offset + PWM_CTL0);
+	}
+
+	for(i = 0; i < OWL_BOOT_MAX_PWM_NUM; i++)
+	{
+		if(owl_pwm_config_saved[i].mfp.mask != 0)
+		{
+			unsigned int mask = (unsigned int)owl_pwm_config_saved[i].mfp.mask << owl_pwm_config_saved[i].mfp.shift;
+			unsigned int val = (unsigned int)owl_pwm_config_saved[i].mfp.val << owl_pwm_config_saved[i].mfp.shift;
+
+			offset = owl_pwm_config_saved[i].mfp.no * 4;
+			val = (act_readl(offset + MFP_CTL0) & (~mask)) | val;
+			act_writel(val, offset + MFP_CTL0);
+		}
+	}
+}
+
+void owl_pm_do_restore(void)
+{
+	int i;
+	act_writel(0, T0_CTL);
+	for (i = 0; i < ARRAY_SIZE(owl_reg_save); i++)
+		act_writel(owl_reg_save[i].val, owl_reg_save[i].reg);
+}
+EXPORT_SYMBOL(owl_pm_do_restore);
+
+typedef void (*finish_suspend_t)(ulong cpu_type, ulong pmic_busio, ulong pmic_addr, ulong pmic_type);
+
+#include <asm/sections.h>
+
+#define K_TEXT_CSUM_INFO_START_ADDR 0xC0002800
+#define K_TEXT_CSUM_INFO_END_ADDR (K_TEXT_CSUM_INFO_START_ADDR + 4)
+#define K_TEXT_CSUM_INFO_CSUM (K_TEXT_CSUM_INFO_START_ADDR + 8)
+
+unsigned long *ddr_checksum;
+static int train_Msize = -1;
+static int train_ces = -1;
+static char train_save_buf[2][64];
+
+static void get_ddr_train_option(void)
+{
+	train_Msize = (((act_readl(DMM_INTERLEAVE_CONFIG) >> 8) & 0x7) + 1) * 256;
+	train_ces = ((act_readl(DMM_INTERLEAVE_CONFIG) >> 4) & 0x1) + 1;
+	pr_alert("train_Msize:%d, train_ces:%d\n", train_Msize, train_ces);
+}
+
+void c_save_ddr_train_area(void)
+{
+	int train_offset;
+	char *vddr;
+	
+	if(train_Msize <= 0 || train_ces <= 0 || train_ces > 2) {
+		while(1) {
+			pr_alert("train_Msize:%d, train_ces:%d\n", train_Msize, train_ces);
+		}
+	}
+	
+	vddr = kmap_atomic(pfn_to_page(PFN_DOWN(0x2000)));
+	memcpy(train_save_buf[0], vddr, 64);
+	kunmap_atomic(vddr);
+	
+	if(train_ces == 2) {		
+		if((train_Msize) % 3 != 0) {
+			train_offset = train_Msize / 2;	//train_ces为2
+		} else {
+			train_offset = (train_Msize / 3) * 2;	//train_ces为2
+		}
+		
+		vddr = kmap_atomic(pfn_to_page(PFN_DOWN((train_offset<<20)+0x2000)));
+		memcpy(train_save_buf[1], vddr, 64);
+		kunmap_atomic(vddr);
+	}
+}
+
+void c_restore_ddr_train_area(void)
+{
+	int train_offset;
+	char *vddr;
+	
+	vddr = kmap_atomic(pfn_to_page(PFN_DOWN(0x2000)));
+	memcpy(vddr, train_save_buf[0], 64);
+	kunmap_atomic(vddr);
+	
+	if(train_ces == 2) {		
+		if((train_Msize) % 3 != 0) {
+			train_offset = train_Msize / 2;	//train_ces为2
+		} else {
+			train_offset = (train_Msize / 3) * 2;	//train_ces为2
+		}
+		
+		vddr = kmap_atomic(pfn_to_page(PFN_DOWN((train_offset<<20)+0x2000)));
+		memcpy(vddr, train_save_buf[1], 64);
+		kunmap_atomic(vddr);
+	}
+	flush_cache_all();
+}
+
+int c_calc_ddr_checksum(void)
+{
+#ifdef STATS_CALC_CHECKSUM_TIME
+	struct timeval start;
+	struct timeval stop;	
+	long time_us;
+#endif
+	unsigned long addr, checksum=0;
+
+	get_ddr_train_option();
+
+#ifdef STATS_CALC_CHECKSUM_TIME	
+	do_gettimeofday(&start);
+#endif
+	for(addr=(unsigned long)_text; addr<(unsigned long)_etext; addr+=4) {
+		checksum += *(volatile unsigned long *)addr;
+	}
+#ifdef STATS_CALC_CHECKSUM_TIME		
+	do_gettimeofday(&stop);
+	time_us = (stop.tv_sec - start.tv_sec)*1000000 + \
+			 (stop.tv_usec- start.tv_usec);
+	printk("used time: %ld ms\n", time_us/1000);
+#endif
+	
+	ddr_checksum = (unsigned long *)K_TEXT_CSUM_INFO_START_ADDR;	
+	*ddr_checksum = (unsigned long)_text;
+	
+	ddr_checksum = (unsigned long *)K_TEXT_CSUM_INFO_END_ADDR;
+	*ddr_checksum = (unsigned long)_etext;
+	
+	ddr_checksum = (unsigned long *)K_TEXT_CSUM_INFO_CSUM;
+	*ddr_checksum = checksum;
+	pr_alert("start:0x%lx, end:0x%lx, checksum:0x%lx\n", (unsigned long)_text, (unsigned long)_etext, *ddr_checksum);
+	
+	return 0;
+}
+
+int c_check_ddr_checksum(void)
+{
+	unsigned long addr, checksum=0;
+	
+	for(addr=(unsigned long)_text; addr<(unsigned long)_etext; addr+=4) {
+		checksum += *(volatile unsigned long *)addr;
+	}
+	
+	ddr_checksum = (unsigned long *)K_TEXT_CSUM_INFO_CSUM;	
+	if(*ddr_checksum != checksum) {
+		pr_alert("checksum:0x%lx vs 0x%lx\n", *ddr_checksum, checksum);
+		while(1);
+	}
+	pr_alert("ddr checksum ok\n");
+    
+	return 0;
+}
+
+static int owl_cpu_suspend(unsigned long cpu_state)
+{
+	static const ulong sc_i2c_iobase_tbl[] = {
+		/* MMU is disabled when S2 i2c/spi code is call, */
+		/* so use physical bus address here. */
+		I2C0_BASE, I2C1_BASE, I2C2_BASE, I2C3_BASE,
+	};
+	static const ulong sc_spi_iobase_tbl[] = {
+		SPI0_BASE, SPI1_BASE, SPI2_BASE, SPI3_BASE,
+	};
+	finish_suspend_t func;
+	int ret, cpu_type;
+	uint pmic_bus_num, pmic_addr, pmic_type;
+	ulong pmic_bus_iobase;
+
+//    switch_jtag();
+	c_check_ddr_checksum();
+	c_save_ddr_train_area();
+	
+	cpu_type = cpu_package();
+
+	ret = s_pmic_pm_ops->get_bus_info(&pmic_bus_num, &pmic_addr, &pmic_type);
+	while(ret);
+	while(pmic_bus_num >= 4); /* @_@b */
+
+	func = (finish_suspend_t)0xffff8000;
+	switch(pmic_type) {
+	case ATC260X_ICTYPE_2603A:
+		pmic_bus_iobase = sc_spi_iobase_tbl[pmic_bus_num];
+		break;
+	case ATC260X_ICTYPE_2603C:
+	case ATC260X_ICTYPE_2609A:
+		pmic_bus_iobase = sc_i2c_iobase_tbl[pmic_bus_num];
+		break;
+	default:
+		while(1);
+	}
+
+	memcpy((void *)func, (void *)owl_finish_suspend, 0x1000);
+	flush_cache_all();
+
+	pr_info("call owl_finish_suspend(%u, 0x%lx, 0x%x, %u)\n",
+		cpu_type, pmic_bus_iobase, pmic_addr, pmic_type);
+	func(cpu_type, pmic_bus_iobase, pmic_addr, pmic_type);
+
+	return 0;
+}
+
+void config_inner_charger_current(int pre_post, int dev_type, int param)
+{
+	if (charger_adjust)
+		(*charger_adjust)(pre_post, dev_type, param);
+}
+EXPORT_SYMBOL_GPL(config_inner_charger_current);
+
+void pmic_charger_set_fun(void (*funp)(int, int, int))
+{
+	pr_err("[PM] set charger adjust fun\n");
+	charger_adjust = funp;
+}
+EXPORT_SYMBOL_GPL(pmic_charger_set_fun);
+
+/**
+ *      pmic_suspend_set_ops - Set the global suspend method table.
+ *      @ops:   Pointer to ops structure.
+ */
+void owl_pmic_set_pm_ops(struct owl_pmic_pm_ops *ops)
+{
+	pr_info("[PM] set pmic suspend ops 0x%lx\n", (ulong)ops);
+	if(ops == NULL || IS_ERR(ops)) {
+		s_pmic_pm_ops = &s_pmic_fallback_pm_ops;
+	} else {
+		s_pmic_pm_ops = ops;
+	}
+}
+EXPORT_SYMBOL_GPL(owl_pmic_set_pm_ops);
+
+int owl_pmic_setup_aux_wakeup_src(uint wakeup_src, uint on)
+{
+	uint aux_mask, bitpos;
+
+	aux_mask = OWL_PMIC_WAKEUP_SRC_IR | OWL_PMIC_WAKEUP_SRC_ALARM |
+		OWL_PMIC_WAKEUP_SRC_REMCON | OWL_PMIC_WAKEUP_SRC_TP |
+		OWL_PMIC_WAKEUP_SRC_WKIRQ | OWL_PMIC_WAKEUP_SRC_SGPIOIRQ;
+	if (wakeup_src & ~aux_mask)
+		return -EINVAL;
+
+	bitpos = __ffs(wakeup_src); /* one bit per call. */
+
+	set_bit(bitpos, &s_pmic_pending_aux_wakeup_src_mask);
+	if (on) {
+		set_bit(bitpos, &s_pmic_pending_aux_wakeup_src_val);
+	} else {
+		clear_bit(bitpos, &s_pmic_pending_aux_wakeup_src_val);
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(owl_pmic_setup_aux_wakeup_src);
+
+PM_SYMBOL(owl_cpu_resume);
+
+static void owl_set_wakeup_source(void)
+{
+	uint wakeup_src, wakeup_mask, append_aux_wakeup_src=0;
+	int adapter_type = -1;
+
+	adapter_type = (*s_judge_adapter_type)();
+	pr_info("[PM] adapter_type: %d\n", adapter_type);
+	if (adapter_type < 0) {
+		pr_info("[PM] Err judge_adapter_type\n");
+		wakeup_src = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT;
+		wakeup_mask = OWL_PMIC_WAKEUP_SRC_ALL;
+	} else {
+		switch (adapter_type) {
+		case ADAPTER_TYPE_NO_PLUGIN:
+			/* no adapter plugged in */
+			wakeup_mask = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT |
+				OWL_PMIC_WAKEUP_SRC_VBUS_IN | OWL_PMIC_WAKEUP_SRC_VBUS_OUT |
+				OWL_PMIC_WAKEUP_SRC_WALL_IN | OWL_PMIC_WAKEUP_SRC_WALL_OUT |
+				OWL_PMIC_WAKEUP_SRC_ALARM;
+			wakeup_src = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT |
+				OWL_PMIC_WAKEUP_SRC_ALARM |
+				OWL_PMIC_WAKEUP_SRC_VBUS_IN | OWL_PMIC_WAKEUP_SRC_WALL_IN;
+			append_aux_wakeup_src = 1;
+			break;
+
+		case ADAPTER_TYPE_WALL_PLUGIN:
+			/* wall and full charged */
+			wakeup_mask = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT |
+				OWL_PMIC_WAKEUP_SRC_VBUS_IN | OWL_PMIC_WAKEUP_SRC_VBUS_OUT |
+				OWL_PMIC_WAKEUP_SRC_WALL_IN | OWL_PMIC_WAKEUP_SRC_WALL_OUT |
+				OWL_PMIC_WAKEUP_SRC_ALARM;
+			wakeup_src = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT |OWL_PMIC_WAKEUP_SRC_ALARM|
+				OWL_PMIC_WAKEUP_SRC_VBUS_IN | OWL_PMIC_WAKEUP_SRC_WALL_OUT;
+			append_aux_wakeup_src = 1;
+			break;
+
+		case ADAPTER_TYPE_PC_USB_PLUGIN:
+			/* usb connected to PC */
+			/* same as adapter */
+		case ADAPTER_TYPE_USB_ADAPTER_PLUGIN:
+			/* usb adapter */
+			wakeup_mask = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT |
+				OWL_PMIC_WAKEUP_SRC_VBUS_IN | OWL_PMIC_WAKEUP_SRC_VBUS_OUT |
+				OWL_PMIC_WAKEUP_SRC_WALL_IN | OWL_PMIC_WAKEUP_SRC_WALL_OUT |
+				OWL_PMIC_WAKEUP_SRC_ALARM;
+			wakeup_src = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT |OWL_PMIC_WAKEUP_SRC_ALARM|
+				OWL_PMIC_WAKEUP_SRC_WALL_IN | OWL_PMIC_WAKEUP_SRC_VBUS_OUT;
+			append_aux_wakeup_src = 1;
+			break;
+
+		case ADAPTER_TYPE_USB_WALL_PLUGIN:
+			/* usb adapter & Wall adatper */
+			wakeup_mask = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT |
+				OWL_PMIC_WAKEUP_SRC_VBUS_IN | OWL_PMIC_WAKEUP_SRC_VBUS_OUT |
+				OWL_PMIC_WAKEUP_SRC_WALL_IN | OWL_PMIC_WAKEUP_SRC_WALL_OUT |
+				OWL_PMIC_WAKEUP_SRC_ALARM;
+			wakeup_src = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT |OWL_PMIC_WAKEUP_SRC_ALARM|
+				OWL_PMIC_WAKEUP_SRC_VBUS_OUT | OWL_PMIC_WAKEUP_SRC_WALL_OUT;
+			append_aux_wakeup_src = 1;
+			break;
+
+		default:
+			/* something wrong */
+			pr_info("[PM] unknown adatper type\n");
+			wakeup_src = OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT;
+			wakeup_mask = OWL_PMIC_WAKEUP_SRC_ALL;
+			break;
+		}
+	}
+
+	/* add onoff long press wakeup source enabled,
+	 *    when the adapter is plugged in and the battery is full.
+	 */
+	wakeup_src |= OWL_PMIC_WAKEUP_SRC_ONOFF_LONG;
+	wakeup_mask |= OWL_PMIC_WAKEUP_SRC_ONOFF_LONG;
+
+	if (append_aux_wakeup_src) {
+		uint aux_mask = s_pmic_pending_aux_wakeup_src_mask; /* read only once */
+		uint aux_val = s_pmic_pending_aux_wakeup_src_val;
+		if (aux_mask != 0) {
+			pr_info("[PM] append aux wakeup source, mask=0x%x val=0x%x\n",
+				aux_mask, aux_val);
+			wakeup_mask |= aux_mask;
+			wakeup_src |= aux_val;
+		}
+	}
+
+	pr_warn("[PM] wakesrc: 0x%x, wakeup_mask: 0x%x\n", wakeup_src, wakeup_mask);
+	s_pmic_pm_ops->set_wakeup_src(wakeup_mask, wakeup_src);
+}
+
+static int owl_pm_prepare_late(void)
+{
+	pr_info("[PM] %s %d:\n", __func__, __LINE__);
+	return s_pmic_pm_ops->suspend_prepare();
+}
+
+static int owl_pm_enter(suspend_state_t state)
+{
+	int ret;
+
+	owl_pwm_config_save();
+	owl_core_clk_save();
+	ret = s_pmic_pm_ops->suspend_enter();
+	if(ret) {
+		pr_err("[PM] %s() PMIC enter suspend failed, ret=%d", __func__, ret);
+		return ret;
+	}
+	owl_set_wakeup_source();
+
+	owl_powergate_suspend();
+	owl_pm_do_save();
+
+	cpu_suspend(0, owl_cpu_suspend);
+	owl_pwm_config_restore();
+	owl_bus_clk_restore();
+	owl_pm_do_restore();
+	owl_cpu_clk_restore();
+	
+	c_restore_ddr_train_area();
+	c_check_ddr_checksum();
+
+	owl_powergate_resume();
+
+#ifdef CONFIG_SMP
+	scu_enable((void *)IO_ADDRESS(OWL_PA_SCU));
+#endif
+
+	/* DO NOT call s_pmic_pm_ops here, it's not ready at this moment! */
+
+	return 0;
+}
+
+static void owl_pm_wake(void)
+{
+	pr_info("[PM] %s %d:\n", __func__, __LINE__);
+	s_pmic_pm_ops->suspend_wake();
+	s_pmic_pm_ops->set_wakeup_src(OWL_PMIC_WAKEUP_SRC_ONOFF_SHORT, 0);
+}
+
+static void owl_pm_finish(void)
+{
+	pr_info("[PM] %s %d:\n", __func__, __LINE__);
+	s_pmic_pm_ops->suspend_finish();
+}
+
+int owl_pm_wakeup_flag(void)
+{
+	return s_pmic_pm_ops->get_wakeup_flag();
+}
+EXPORT_SYMBOL_GPL(owl_pm_wakeup_flag);
+
+static const struct platform_suspend_ops owl_pm_ops = {
+	.enter = owl_pm_enter,
+	.prepare_late = owl_pm_prepare_late,
+	.wake = owl_pm_wake,
+	.finish = owl_pm_finish,
+	.valid = suspend_valid_only_mem,
+};
+u32 get_phBaseAddr(void)
+{
+	u32 tmp;
+	
+	__asm__ __volatile__ ("mrc p15, 4, %0, c15, c0, 0":"=r"(tmp));
+	return tmp;
+}
+
+// void init_WD_timer(unsigned int load_value, unsigned int auto_reload)
+// Sets up the WD timer
+// r0: initial load value
+// r1:  IF 0 (AutoReload) ELSE (SingleShot)
+void init_WD_timer(unsigned int load_value, unsigned int auto_reload)
+{
+	u32 phBaseAddr, wdCountAddr, wdModeAddr, tmp=0;
+   	
+   	phBaseAddr = get_phBaseAddr();
+   	wdCountAddr = phBaseAddr+0x620;
+   	wdModeAddr = phBaseAddr+0x628;
+   	
+   	act_writel(load_value, wdCountAddr);
+   	if(auto_reload == 0)
+   	{
+   		tmp = 0x2;	
+   	}
+   	act_writel(tmp, wdModeAddr);
+}
+
+// void set_WD_mode(unsigned int mode)
+// Sets up the WD timer  
+// r0:  IF 0 (timer mode) ELSE (watchdog mode)
+void set_WD_mode(unsigned int mode)
+{
+	u32 phBaseAddr, wdModeAddr;
+	
+	phBaseAddr = get_phBaseAddr();
+   	wdModeAddr = phBaseAddr+0x628;
+   	
+   	if(mode == 0)
+   	{
+   		act_writel((act_readl(wdModeAddr) & 0xf7) | 0x4, wdModeAddr);
+   	}
+   	else
+   	{
+   		act_writel(act_readl(wdModeAddr) | 0x8, wdModeAddr);
+   	}
+}
+
+// void start_WD_timer(void)
+// Starts the WD timer
+void start_WD_timer(void)
+{
+	u32 phBaseAddr, wdModeAddr;
+	
+	phBaseAddr = get_phBaseAddr();
+   	wdModeAddr = phBaseAddr+0x628;
+   	
+	act_writel(act_readl(wdModeAddr) | 0x1, wdModeAddr);
+}
+void cpu_reset_to_brom(void)
+{
+	local_fiq_disable();
+	arch_local_irq_disable(); 	
+	init_WD_timer(0xA, 0x01);
+	set_WD_mode(1);
+	start_WD_timer();
+	while(1)
+	{
+		asm volatile("wfe");
+	}
+}
+
+int __init owl_pm_init(void)
+{
+	printk("[PM] %s() %d\n", __func__, __LINE__);
+	
+	c_calc_ddr_checksum();
+	suspend_set_ops(&owl_pm_ops);
+	pm_power_off = owl_pm_halt;
+	arm_pm_restart = owl_pm_restart;
+
+	return 0;
+}
+late_initcall(owl_pm_init);
+
+static void __exit owl_pm_remove(void)
+{
+
+}
diff --git a/arch/arm/mach-owl/powergate-owl.c b/arch/arm/mach-owl/powergate-owl.c
new file mode 100755
index 0000000..2dadf62
--- /dev/null
+++ b/arch/arm/mach-owl/powergate-owl.c
@@ -0,0 +1,518 @@
+/*
+ * arch/arm/mach-owl/powergate-owl.c
+ *
+ * powergate support for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#if 0
+#define DEBUG
+#endif
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/seq_file.h>
+#include <linux/spinlock.h>
+#include <linux/of_platform.h>
+
+#include <mach/hardware.h>
+#include <mach/powergate.h>
+#include <mach/module-owl.h>
+
+#define MAX_RESET_ID_SIZE 6
+#define NO_ACK_ID 0xffffffff
+
+static struct mutex powergate_mutex;        /* mutex of one powergate for multi muser */
+static int owl_powergate_maxid;
+static unsigned int sps_pg_ctl;
+
+struct owl_powergate_info {
+	char name[16];             /* name of powergate */
+	unsigned int reset_id[MAX_RESET_ID_SIZE];
+	unsigned int pwr_id;
+	unsigned int ack_id;
+	int count;                 /* power on count */
+	int init_power_off;        /* power off at boot init stage */
+	int use_mutex;             /* need use mutex? */
+};
+
+static struct owl_powergate_info powergate_info[] = {
+	[OWL_POWERGATE_CPU2] = {
+		.name = "cpu2",
+		.pwr_id = 5,
+		.ack_id = 21,
+		/* for CPU2, init_power_off shoud be 0 */
+		.init_power_off = 0,
+		.use_mutex = 0,
+		.count = 0,
+	},
+
+	[OWL_POWERGATE_CPU3] = {
+		.name = "cpu3",
+		.pwr_id = 6,
+		.ack_id = 22,
+		/* for CPU3, init_power_off shoud be 0 */
+		.init_power_off = 0,
+		.use_mutex = 0,
+		.count = 0,
+	},
+
+	[OWL_POWERGATE_GPU3D] = {
+		.name = "gpu3d",
+		.reset_id = {MOD_ID_GPU3D},
+		.pwr_id = 3,
+		.ack_id = NO_ACK_ID,
+		.init_power_off = 1,
+		.use_mutex = 1,
+		.count = 0,
+	},
+
+	[OWL_POWERGATE_VCE_BISP] = {
+		.name = "vce/bisp",
+		.reset_id = {MOD_ID_VCE, MOD_ID_BISP},
+		.pwr_id = 1,
+		.ack_id = 17,
+		/* for VCE_BISP, init_power_off shoud be 1 */
+		.init_power_off = 1,
+		.use_mutex = 1,
+		.count = 0,
+	},
+
+	[OWL_POWERGATE_VDE] = {
+		.name = "vde",
+		.reset_id = {MOD_ID_VDE},
+		.pwr_id = 0,
+		.ack_id = 16,
+		.init_power_off = 1,
+		.use_mutex = 1,
+		.count = 0,
+	},
+
+	/*atm7059 avaliabe only*/
+	[OWL_POWERGATE_USB2_0] = {
+		.name = "usb2_0",
+		.reset_id = {MOD_ID_USB2_0},
+		.pwr_id = 11,
+		.ack_id = 15,
+		.init_power_off = 1,
+		.use_mutex = 1,
+		.count = 0,
+	},
+	
+	[OWL_POWERGATE_USB2_1] = {
+		.name = "usb2_1",
+		.reset_id = {MOD_ID_USB2_1},
+		.pwr_id = 2,
+		.ack_id = 18,
+		.init_power_off = 1,
+		.use_mutex = 1,
+		.count = 0,
+	},
+	
+	[OWL_POWERGATE_USB3] = {
+		.name = "usb3",
+		.reset_id = {MOD_ID_USB3},
+		.pwr_id = 10,
+		.ack_id = 14,
+		.init_power_off = 1,
+		.use_mutex = 1,
+		.count = 0,
+	},
+	
+	[OWL_POWERGATE_DS] = {
+		.name = "ds",
+		.reset_id = {MOD_ID_DE, MOD_ID_LCD, MOD_ID_HDMI, MOD_ID_TVOUT, MOD_ID_DSI},
+		.pwr_id = 9,
+		.ack_id = 13,
+		.init_power_off = 0,
+		.use_mutex = 1,
+		.count = 0,
+	},
+	
+	[OWL_POWERGATE_DMA] = {
+		.name = "dma",
+		.reset_id = {MOD_ID_DMAC},
+		.pwr_id = 8,
+		.ack_id = 12,
+		.init_power_off = 1,
+		.use_mutex = 1,
+		.count = 0,
+	},
+	
+};
+
+static unsigned int owl_cpu_domains[] = {
+	0xffffffff,
+	0xffffffff,
+	OWL_POWERGATE_CPU2,
+	OWL_POWERGATE_CPU3,
+};
+
+static DEFINE_SPINLOCK(owl_powergate_lock);
+
+static int owl_powergate_set(enum owl_powergate_id id, bool on)
+{
+	struct owl_powergate_info *pgi = &powergate_info[id];
+	bool ack_is_on;
+	unsigned long val, flags;
+	int timeout, i, reset_id;
+	
+	if(id < OWL_POWERGATE_USB2_0)
+		pr_debug("[PowerGate] name: '%s', on: %d, before SPS_PG_CTL: 0x%x\n",
+			pgi->name, on, act_readl(SPS_PG_CTL));
+	else
+		printk("[PowerGate] name: '%s', on: %d, before SPS_PG_CTL: 0x%x\n",
+			pgi->name, on, act_readl(SPS_PG_CTL));
+
+	spin_lock_irqsave(&owl_powergate_lock, flags);
+		
+	if (pgi->ack_id != NO_ACK_ID) {
+		ack_is_on = (act_readl(SPS_PG_CTL) & (1 << pgi->ack_id));
+
+		if (ack_is_on == on) {
+			spin_unlock_irqrestore(&owl_powergate_lock, flags);
+			return 0;
+		}
+	}
+
+	/* assert modules reset before poweron */
+	if (on) {
+		if (id == OWL_POWERGATE_CPU2) {
+			/* core reset */
+			val = act_readl(CMU_CORECTL);
+			val &= ~(1 << 6);
+			act_writel(val, CMU_CORECTL);
+		} else if (id == OWL_POWERGATE_CPU3) {
+			/* core reset */
+			val = act_readl(CMU_CORECTL);
+			val &= ~(1 << 7);
+			act_writel(val, CMU_CORECTL);
+		} else {
+			for (i = 0; i < MAX_RESET_ID_SIZE; i++) {
+				reset_id = pgi->reset_id[i];
+				if (reset_id != MOD_ID_ROOT)
+					owl_module_reset_assert(reset_id);
+			}
+		}
+	}
+
+	val = act_readl(SPS_PG_CTL);
+	if (on)
+		val |= (1 << pgi->pwr_id);
+	else
+		val &= ~(1 << pgi->pwr_id);
+	act_writel(val, SPS_PG_CTL);
+
+	if (on) {
+		timeout = 5000;  /* 5ms */
+		while (timeout > 0 && !owl_powergate_is_powered(id)) {
+			udelay(50);
+			timeout -= 50;
+		}
+		if (timeout <= 0) {
+			pr_err("[PowerGate] enable power for id %d timeout\n",
+			       id);
+		}
+		udelay(10);
+		
+		/* deasert modules reset after poweron */
+		if (id == OWL_POWERGATE_CPU2) {
+			/* clk en */
+			val = act_readl(CMU_CORECTL);
+			val |= (1 << 2);
+			act_writel(val, CMU_CORECTL);
+			/* core reset */
+			val = act_readl(CMU_CORECTL);
+			val |= (1 << 6);
+			act_writel(val, CMU_CORECTL);
+		} else if (id == OWL_POWERGATE_CPU3) {
+			/* clk en */
+			val = act_readl(CMU_CORECTL);
+			val |= (1 << 3);
+			act_writel(val, CMU_CORECTL);
+			/* core reset */
+			val = act_readl(CMU_CORECTL);
+			val |= (1 << 7);
+			act_writel(val, CMU_CORECTL);
+		} else {
+			for (i = 0; i < MAX_RESET_ID_SIZE; i++) {
+				reset_id = pgi->reset_id[i];
+				if (reset_id != MOD_ID_ROOT) {
+					module_clk_enable(reset_id);
+					owl_module_reset_deassert(reset_id);
+				}
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&owl_powergate_lock, flags);
+
+	if(id < OWL_POWERGATE_USB2_0)
+		pr_debug("[PowerGate] name: '%s', on: %d, after SPS_PG_CTL: 0x%x\n",
+			pgi->name, on, act_readl(SPS_PG_CTL));
+	else
+		printk("[PowerGate] name: '%s', on: %d, after SPS_PG_CTL: 0x%x\n",
+			pgi->name, on, act_readl(SPS_PG_CTL));
+
+	return 0;
+}
+
+int owl_powergate_power_on(enum owl_powergate_id id)
+{
+	struct owl_powergate_info *pgi;
+	int ret;
+
+	if (id < 0 || id >= owl_powergate_maxid)
+		return -EINVAL;
+
+	pgi = &powergate_info[id];
+
+	pr_debug("[PowerGate] %s(): '%s', count %d\n",
+		__func__, pgi->name, pgi->count);
+
+	if (pgi->use_mutex)
+		mutex_lock(&powergate_mutex);
+	pgi->count++;
+
+	if (pgi->ack_id != NO_ACK_ID &&
+		owl_powergate_is_powered(id) > 0) {
+		if (pgi->use_mutex) {
+			pr_err("[PowerGate] '%s', skip power on, count %d\n",
+				pgi->name, pgi->count);
+
+			mutex_unlock(&powergate_mutex);
+		}
+		return 0;
+	}
+
+	ret = owl_powergate_set(id, true);
+
+	if (pgi->use_mutex)
+		mutex_unlock(&powergate_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(owl_powergate_power_on);
+
+int owl_powergate_power_off(enum owl_powergate_id id)
+{
+	struct owl_powergate_info *pgi;
+	int ret = 0;
+
+	if (id < 0 || id >= owl_powergate_maxid)
+		return -EINVAL;
+
+	pgi = &powergate_info[id];
+
+	pr_debug("[PowerGate] %s(): '%s', count %d\n",
+		__func__, pgi->name, pgi->count);
+
+	if (pgi->use_mutex)
+		mutex_lock(&powergate_mutex);
+
+	if (WARN(pgi->count <= 0,
+		"unbalanced power off for %s\n", pgi->name)) {
+		if (pgi->use_mutex)
+			mutex_unlock(&powergate_mutex);
+		return -EIO;
+	}
+
+	pgi->count--;
+	if (pgi->count == 0) {
+		pr_debug("[PowerGate] '%s', count is 0, real power off\n",
+			pgi->name);
+
+		ret = owl_powergate_set(id, false);
+	}
+
+	if (pgi->use_mutex)
+		mutex_unlock(&powergate_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(owl_powergate_power_off);
+
+int owl_powergate_is_powered(enum owl_powergate_id id)
+{
+	struct owl_powergate_info *pgi;
+	u32 status;
+
+	if (id < 0 || id >= owl_powergate_maxid)
+		return -EINVAL;
+
+	pgi = &powergate_info[id];
+	if (pgi->ack_id == NO_ACK_ID)
+		return 1;
+
+	status = act_readl(SPS_PG_CTL) & (1 << pgi->ack_id);
+
+	pr_debug("[PowerGate] %s(): '%s', status %d\n",
+		__func__, pgi->name, !!status);
+
+	return !!status;
+}
+EXPORT_SYMBOL(owl_powergate_is_powered);
+
+int owl_powergate_suspend(void)
+{
+	struct owl_powergate_info *pgi;
+	int i;
+
+	pr_debug("[PowerGate] suspend\n");
+	
+	sps_pg_ctl = act_readl(SPS_PG_CTL);
+	
+	for (i = 0; i < owl_powergate_maxid; i++) {
+		pgi = &powergate_info[i];
+
+		if (owl_powergate_is_powered(i) > 0) {
+			pgi->init_power_off = 0;
+		} else {
+			pgi->init_power_off = 1;
+		}
+	}
+
+	return 0;
+}
+
+int owl_powergate_resume(void)
+{
+	struct owl_powergate_info *pgi;
+	int i;
+
+	pr_debug("[PowerGate] resume\n");
+
+	for (i = 0; i < owl_powergate_maxid; i++) {
+		pgi = &powergate_info[i];
+
+		if (pgi->init_power_off == 0 && owl_powergate_is_powered(i) == 0) {
+			owl_powergate_set(i, true);
+		}
+	}
+	
+	act_writel(sps_pg_ctl, SPS_PG_CTL);
+
+	return 0;
+}
+
+int owl_cpu_powergate_id(int cpuid)
+{
+	if (cpuid > 1 && cpuid < ARRAY_SIZE(owl_cpu_domains))
+		return owl_cpu_domains[cpuid];
+
+	return -EINVAL;
+}
+
+void owl_powergate_earlyinit(void)
+{
+	if (of_machine_is_compatible("actions,atm7059a"))
+		owl_powergate_maxid = OWL_POWERGATE_MAXID;
+	else
+		owl_powergate_maxid = OWL_POWERGATE_VDE + 1;
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+static int powergate_show(struct seq_file *s, void *data)
+{
+	struct owl_powergate_info *pgi;
+	int i;
+
+	seq_printf(s, " powergate powered\n");
+	seq_printf(s, "------------------\n");
+
+	seq_printf(s, "     name     status    count\n");
+
+	for (i = 0; i < owl_powergate_maxid; i++) {
+		pgi = &powergate_info[i];
+
+		seq_printf(s, " %9s %7s %7d\n",
+		pgi->name,
+			owl_powergate_is_powered(i) ? "on" : "off",
+		pgi->count);
+	}
+
+	return 0;
+}
+
+static int powergate_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, powergate_show, inode->i_private);
+}
+
+static const struct file_operations powergate_fops = {
+	.open		= powergate_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init powergate_debugfs_init(void)
+{
+	struct dentry *dir = NULL;
+	struct dentry *d;
+
+	d = debugfs_create_file("powergate", S_IRUGO, dir, NULL,
+		&powergate_fops);
+	if (!d)
+		return -ENOMEM;
+
+	return 0;
+}
+
+#else
+static int powergate_debugfs_init(void)
+{
+	return 0;
+}
+#endif
+
+
+int owl_powergate_init(void)
+{
+	struct owl_powergate_info *pgi;
+	int i;
+
+	pr_debug("[PowerGate] init\n");
+	
+	for (i = 0; i < owl_powergate_maxid; i++) {
+		pgi = &powergate_info[i];
+
+		if (owl_powergate_is_powered(i) > 0) {
+			if (pgi->init_power_off) {
+				pr_debug("[PowerGate] %s(): '%s', init off\n",
+					__func__, pgi->name);
+				/* power off */
+				owl_powergate_set(i, false);
+				pgi->count = 0;
+			} else {
+				pgi->count = 1;
+			}
+		} else {
+			pgi->count = 0;
+		}
+
+		pr_debug("[PowerGate] %s(): '%s', init count %d\n",
+			__func__, pgi->name, pgi->count);
+	}
+	
+	mutex_init(&powergate_mutex);
+	powergate_debugfs_init();
+
+	return 0;
+}
+
+arch_initcall(owl_powergate_init);
diff --git a/arch/arm/mach-owl/processor-owl.c b/arch/arm/mach-owl/processor-owl.c
new file mode 100755
index 0000000..02b7031
--- /dev/null
+++ b/arch/arm/mach-owl/processor-owl.c
@@ -0,0 +1,105 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/uaccess.h>
+#include <linux/init.h>
+#include <mach/power.h>
+
+struct saved_context saved_context;
+
+void __save_processor_state(struct saved_context *ctxt)
+{
+	preempt_disable();
+
+	/* save coprocessor 15 registers*/
+	asm volatile ("mrc p15, 2, %0, c0, c0, 0" : "=r"(ctxt->CSSR));
+	asm volatile ("mrc p15, 0, %0, c1, c0, 0" : "=r"(ctxt->CR));
+	asm volatile ("mrc p15, 0, %0, c1, c0, 1" : "=r"(ctxt->AUXCR));
+	asm volatile ("mrc p15, 0, %0, c1, c0, 2" : "=r"(ctxt->CACR));
+	asm volatile ("mrc p15, 0, %0, c2, c0, 0" : "=r"(ctxt->TTB_0R));
+	asm volatile ("mrc p15, 0, %0, c2, c0, 1" : "=r"(ctxt->TTB_1R));
+	asm volatile ("mrc p15, 0, %0, c2, c0, 2" : "=r"(ctxt->TTBCR));
+	asm volatile ("mrc p15, 0, %0, c3, c0, 0" : "=r"(ctxt->DACR));
+	asm volatile ("mrc p15, 0, %0, c5, c0, 0" : "=r"(ctxt->D_FSR));
+	asm volatile ("mrc p15, 0, %0, c5, c0, 1" : "=r"(ctxt->I_FSR));
+	asm volatile ("mrc p15, 0, %0, c5, c1, 0" : "=r"(ctxt->D_AFSR));
+	asm volatile ("mrc p15, 0, %0, c5, c1, 1" : "=r"(ctxt->I_AFSR));
+	asm volatile ("mrc p15, 0, %0, c6, c0, 0" : "=r"(ctxt->D_FAR));
+	asm volatile ("mrc p15, 0, %0, c6, c0, 2" : "=r"(ctxt->I_FAR));
+	asm volatile ("mrc p15, 0, %0, c7, c4, 0" : "=r"(ctxt->PAR));
+	asm volatile ("mrc p15, 0, %0, c9, c12, 0" : "=r"(ctxt->PMControlR));
+	asm volatile ("mrc p15, 0, %0, c9, c12, 1" : "=r"(ctxt->CESR));
+	asm volatile ("mrc p15, 0, %0, c9, c12, 2" : "=r"(ctxt->CECR));
+	asm volatile ("mrc p15, 0, %0, c9, c12, 3" : "=r"(ctxt->OFSR));
+	asm volatile ("mrc p15, 0, %0, c9, c12, 5" : "=r"(ctxt->PCSR));
+	asm volatile ("mrc p15, 0, %0, c9, c13, 0" : "=r"(ctxt->CCR));
+	asm volatile ("mrc p15, 0, %0, c9, c13, 1" : "=r"(ctxt->ESR));
+	asm volatile ("mrc p15, 0, %0, c9, c13, 2" : "=r"(ctxt->PMCountR));
+	asm volatile ("mrc p15, 0, %0, c9, c14, 0" : "=r"(ctxt->UER));
+	asm volatile ("mrc p15, 0, %0, c9, c14, 1" : "=r"(ctxt->IESR));
+	asm volatile ("mrc p15, 0, %0, c9, c14, 2" : "=r"(ctxt->IECR));
+	asm volatile ("mrc p15, 0, %0, c10, c2, 0" : "=r"(ctxt->PRRR));
+	asm volatile ("mrc p15, 0, %0, c10, c2, 1" : "=r"(ctxt->NRRR));
+	asm volatile ("mrc p15, 0, %0, c12, c0, 0" : "=r"(ctxt->SNSVBAR));
+	asm volatile ("mrc p15, 0, %0, c13, c0, 0" : "=r"(ctxt->FCSE));
+	asm volatile ("mrc p15, 0, %0, c13, c0, 1" : "=r"(ctxt->CID));
+	asm volatile ("mrc p15, 0, %0, c13, c0, 2" : "=r"(ctxt->URWTPID));
+	asm volatile ("mrc p15, 0, %0, c13, c0, 3" : "=r"(ctxt->UROTPID));
+	asm volatile ("mrc p15, 0, %0, c13, c0, 4" : "=r"(ctxt->POTPID));
+
+	saved_cr = ctxt->CR;
+	saved_ttb = ctxt->TTB_0R;
+	idmap = virt_to_phys(idmap_pgd);
+}
+
+void save_processor_state(void)
+{
+	__save_processor_state(&saved_context);
+}
+EXPORT_SYMBOL(save_processor_state);
+
+void __restore_processor_state(struct saved_context *ctxt)
+{
+	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r"(ctxt->CSSR));
+	asm volatile ("mcr p15, 0, %0, c1, c0, 0" : : "r"(ctxt->CR));
+	asm volatile ("mcr p15, 0, %0, c1, c0, 1" : : "r"(ctxt->AUXCR));
+	asm volatile ("mcr p15, 0, %0, c1, c0, 2" : : "r"(ctxt->CACR));
+	asm volatile ("mcr p15, 0, %0, c2, c0, 0" : : "r"(ctxt->TTB_0R));
+	asm volatile ("mcr p15, 0, %0, c2, c0, 1" : : "r"(ctxt->TTB_1R));
+	asm volatile ("mcr p15, 0, %0, c2, c0, 2" : : "r"(ctxt->TTBCR));
+	asm volatile ("mcr p15, 0, %0, c3, c0, 0" : : "r"(ctxt->DACR));
+	asm volatile ("mcr p15, 0, %0, c5, c0, 0" : : "r"(ctxt->D_FSR));
+	asm volatile ("mcr p15, 0, %0, c5, c0, 1" : : "r"(ctxt->I_FSR));
+	asm volatile ("mcr p15, 0, %0, c5, c1, 0" : : "r"(ctxt->D_AFSR));
+	asm volatile ("mcr p15, 0, %0, c5, c1, 1" : : "r"(ctxt->I_AFSR));
+	asm volatile ("mcr p15, 0, %0, c6, c0, 0" : : "r"(ctxt->D_FAR));
+	asm volatile ("mcr p15, 0, %0, c6, c0, 2" : : "r"(ctxt->I_FAR));
+	asm volatile ("mcr p15, 0, %0, c7, c4, 0" : : "r"(ctxt->PAR));
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0" : : "r"(ctxt->PMControlR));
+	asm volatile ("mcr p15, 0, %0, c9, c12, 1" : : "r"(ctxt->CESR));
+	asm volatile ("mcr p15, 0, %0, c9, c12, 2" : : "r"(ctxt->CECR));
+	asm volatile ("mcr p15, 0, %0, c9, c12, 3" : : "r"(ctxt->OFSR));
+	asm volatile ("mcr p15, 0, %0, c9, c12, 5" : : "r"(ctxt->PCSR));
+	asm volatile ("mcr p15, 0, %0, c9, c13, 0" : : "r"(ctxt->CCR));
+	asm volatile ("mcr p15, 0, %0, c9, c13, 1" : : "r"(ctxt->ESR));
+	asm volatile ("mcr p15, 0, %0, c9, c13, 2" : : "r"(ctxt->PMCountR));
+	asm volatile ("mcr p15, 0, %0, c9, c14, 0" : : "r"(ctxt->UER));
+	asm volatile ("mcr p15, 0, %0, c9, c14, 1" : : "r"(ctxt->IESR));
+	asm volatile ("mcr p15, 0, %0, c9, c14, 2" : : "r"(ctxt->IECR));
+	asm volatile ("mcr p15, 0, %0, c10, c2, 0" : : "r"(ctxt->PRRR));
+	asm volatile ("mcr p15, 0, %0, c10, c2, 1" : : "r"(ctxt->NRRR));
+	asm volatile ("mcr p15, 0, %0, c12, c0, 0" : : "r"(ctxt->SNSVBAR));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 0" : : "r"(ctxt->FCSE));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 1" : : "r"(ctxt->CID));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 2" : : "r"(ctxt->URWTPID));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 3" : : "r"(ctxt->UROTPID));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 4" : : "r"(ctxt->POTPID));
+
+	preempt_enable();
+}
+
+void restore_processor_state(void)
+{
+	__restore_processor_state(&saved_context);
+}
+EXPORT_SYMBOL(restore_processor_state);
diff --git a/arch/arm/mach-owl/secure_storage-owl.c b/arch/arm/mach-owl/secure_storage-owl.c
new file mode 100755
index 0000000..bc44fb8
--- /dev/null
+++ b/arch/arm/mach-owl/secure_storage-owl.c
@@ -0,0 +1,177 @@
+/*
+ * arch/arm/mach-owl/secure_storage-owl.c
+ *
+ * secure storage interface
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <mach/secure_storage.h>
+#include <mach/storage_access.h>
+
+static struct secure_storage *cur_secure_storage = NULL;
+
+int owl_register_secure_storage(struct secure_storage *ss)
+{
+    if (!ss || !ss->name)
+        return -EINVAL;
+
+    pr_info("%s: register %s\n", __FUNCTION__, ss->name);
+
+    if (cur_secure_storage) {
+        pr_warning("%s: register %s override %s\n", __FUNCTION__,
+            ss->name, cur_secure_storage->name);
+    }
+
+    cur_secure_storage = ss;
+
+    return 0;
+}
+EXPORT_SYMBOL(owl_register_secure_storage);
+
+int owl_unregister_secure_storage(struct secure_storage *ss)
+{
+    if (!ss || !ss->name)
+        return -EINVAL;
+
+    pr_info("%s: unregister %s\n", __FUNCTION__, ss->name);
+
+    if (cur_secure_storage != ss) {
+        pr_warning("%s: unregister %s override %s\n", __FUNCTION__,
+            ss->name, cur_secure_storage->name);
+        return -EINVAL;
+    }
+
+    cur_secure_storage = NULL;
+
+    return 0;
+}
+EXPORT_SYMBOL(owl_unregister_secure_storage);
+
+
+static int check_secure_storage(int type, char * buf, int size)
+{
+    if (!cur_secure_storage) {
+        pr_err("%s: no valid secure storage\n", __FUNCTION__);
+        return -ENODEV;
+    }
+
+    if (!buf || !size) {
+        pr_err("%s: invalid buf\n", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    switch (type)
+    {
+    case SECURE_STORAGE_DATA_TYPE_SN:
+    case SECURE_STORAGE_DATA_TYPE_DRM:
+    case SECURE_STORAGE_DATA_TYPE_HDCP:
+    case SECURE_STORAGE_DATA_TYPE_DEVNUM:
+    case SECURE_STORAGE_DATA_TYPE_EXT:
+        break;
+    default:
+        pr_err("%s: invalid type %d\n", __FUNCTION__, type);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+int owl_read_secure_storage_data(int type, char * buf, int size)
+{
+    int ret;
+
+    ret = check_secure_storage(type, buf, size);
+    if (ret) {
+        pr_err("%s: invalid param, ret %d\n", __FUNCTION__, ret);
+        return ret;
+    }
+
+    if (!cur_secure_storage->read_data) {
+        pr_err("%s: cannot support read\n", __FUNCTION__);
+        return -ENODEV;
+    }
+
+    ret = cur_secure_storage->read_data(type, buf, size);
+    if (ret <= 0) {
+        pr_err("%s: faild to read secure storage, ret %d\n", __FUNCTION__, ret);
+        return ret;
+    }
+
+	return ret;
+}
+EXPORT_SYMBOL(owl_read_secure_storage_data);
+
+int owl_write_secure_storage_data(int type, char * buf, int size)
+{
+    int ret;
+
+    ret = check_secure_storage(type, buf, size);
+    if (ret) {
+        pr_err("%s: invalid param, ret %d\n", __FUNCTION__, ret);
+        return ret;
+    }
+
+    if (!cur_secure_storage->write_data) {
+        pr_err("%s: cannot support write\n", __FUNCTION__);
+        return -ENODEV;
+    }
+
+    ret = cur_secure_storage->write_data(type, buf, size);
+    if (ret <= 0) {
+        pr_err("%s: faild to write secure storage, ret %d\n", __FUNCTION__, ret);
+        return ret;
+    }
+
+    return ret;
+    return 0;
+}
+EXPORT_SYMBOL(owl_write_secure_storage_data);
+static int check_and_remap_storag_type(int type, int *new_type)
+{
+    switch (type)
+    {
+	case STORAGE_DATA_TYPE_SN:
+        *new_type = SECURE_STORAGE_DATA_TYPE_SN;
+        break;
+	case STORAGE_DATA_TYPE_DRM:
+        *new_type = SECURE_STORAGE_DATA_TYPE_DRM;
+        break;
+    case STORAGE_DATA_TYPE_HDCP:
+        *new_type = SECURE_STORAGE_DATA_TYPE_HDCP;
+        break;
+	case STORAGE_DATA_TYPE_DEVNUM:
+        *new_type = SECURE_STORAGE_DATA_TYPE_DEVNUM;
+        break;
+    default:
+        pr_err("%s: invalid type %d\n", __FUNCTION__, type);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+int owl_read_storage_data(int type, char * buf, int size)
+{
+    int ret;
+    int new_type;
+    
+    ret = check_and_remap_storag_type(type, &new_type);
+    if (ret) {
+        pr_err("%s: invalid param, ret %d\n", __FUNCTION__, ret);
+        return ret;
+    }    
+    return owl_read_secure_storage_data(new_type, buf, size);
+}
+EXPORT_SYMBOL(owl_read_storage_data);
diff --git a/arch/arm/mach-owl/serial-owl.c b/arch/arm/mach-owl/serial-owl.c
new file mode 100755
index 0000000..d0aa7c2
--- /dev/null
+++ b/arch/arm/mach-owl/serial-owl.c
@@ -0,0 +1,1802 @@
+/*
+ * arch/arm/mach-owl/serial-owl.c
+ *
+ * serial driver for Actions SOC
+ *
+ * Copyright 2013 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+ 
+#if defined(CONFIG_SERIAL_OWL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/kref.h>
+
+#include <linux/pinctrl/consumer.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-direction.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/hdmac-owl.h>
+#include <mach/clkname.h>
+#include <mach/module-owl.h>
+
+#define OWL_MAX_UART		7/*updated from 6 to 7*/
+#define OWL_SERIAL_MAJOR	204
+#define OWL_SERIAL_MINOR	0
+
+#define UART_TO_OWL_UART_PORT(uart_port) ((struct owl_uart_port *) uart_port)
+
+#define UART_CTL		0x0000
+#define UART_RXDAT		0x0004
+#define UART_TXDAT		0x0008
+#define UART_STAT		0x000C
+
+/* UART0_CTL */
+/*bit 31~23 reserved*/
+#define UART_CTL_DTCR		(0x1 << 22)	/* DMA TX counter reset */
+#define UART_CTL_DRCR		(0x1 << 21)	/* DMA RX counter reset */
+#define UART_CTL_LBEN		(0x1 << 20)	/* Loop Back Enable */
+#define UART_CTL_TXIE		(0x1 << 19)	/* TX IRQ Enable */
+#define UART_CTL_RXIE		(0x1 << 18)	/* RX IRQ Enable */
+#define UART_CTL_TXDE		(0x1 << 17)	/* TX DRQ Enable */
+#define UART_CTL_RXDE		(0x1 << 16)	/* RX DRQ Enable */
+#define UART_CTL_EN			(0x1 << 15)	/* UART0 Enable */
+#define UART_CTL_TRFS		(0x1 << 14)	/* UART0 TX/RX FIFO Enable */
+#define	 UART_CTL_TRFS_RX	(0x0 << 14)	/* select RX FIFO */
+#define	 UART_CTL_TRFS_TX	(0x1 << 14)	/* select TX FIFO */
+/*bit 13 reserved*/
+#define UART_CTL_AFE		(0x1 << 12)	/* Autoflow Enable */
+/*bit 11~7 reserved*/
+#define UART_CTL_PRS_MASK	(0x7 << 4)
+#define UART_CTL_PRS(x)		(((x) & 0x7) << 4)
+#define	 UART_CTL_PRS_NONE	UART_CTL_PRS(0)
+#define	 UART_CTL_PRS_ODD	UART_CTL_PRS(4)
+#define	 UART_CTL_PRS_MARK	UART_CTL_PRS(5)
+#define	 UART_CTL_PRS_EVEN	UART_CTL_PRS(6)
+#define	 UART_CTL_PRS_SPACE	UART_CTL_PRS(7)
+/*bit 3 reserved*/
+#define UART_CTL_STPS			(0x1 << 2)
+#define	 UART_CTL_STPS_1BITS	(0x0 << 2)
+#define	 UART_CTL_STPS_2BITS	(0x1 << 2)
+#define UART_CTL_DWLS_MASK		(0x3 << 0)
+#define UART_CTL_DWLS(x)		(((x) & 0x3) << 0)
+#define	 UART_CTL_DWLS_5BITS	UART_CTL_DWLS(0)
+#define	 UART_CTL_DWLS_6BITS	UART_CTL_DWLS(1)
+#define	 UART_CTL_DWLS_7BITS	UART_CTL_DWLS(2)
+#define	 UART_CTL_DWLS_8BITS	UART_CTL_DWLS(3)
+
+/******************************************************************************/
+/* UART0_RXDAT */
+/*bit 31~8 reserved*/
+#define UART_RXDAT_MASK		(0xFF << 0)	  /* Received Data */
+
+/******************************************************************************/
+/* UART0_TXDAT */
+/*bit 31~8 reserved*/
+#define UART_TXDAT_MASK		(0xFF << 0)	  /* Sending Data*/
+
+/******************************************************************************/
+/* UART_STAT */
+/*bit 31~17 reserved*/
+#define UART_STAT_UTBB		(0x1 << 16)	/* UART0 TX busy bit */
+#define UART_STAT_TRFL_MASK	(0x1F << 11)	/* TX/RX FIFO Level */
+#define UART_STAT_TRFL_SET(x)	(((x) & 0x1F) << 11)
+#define UART_STAT_TFES		(0x1 << 10)	/* TX FIFO Empty Status */
+#define UART_STAT_RFFS		(0x1 << 9)	/* RX FIFO full Status */
+#define UART_STAT_RTSS		(0x1 << 8)	/* RTS status */
+#define UART_STAT_CTSS		(0x1 << 7)	/* CTS status */
+#define UART_STAT_TFFU		(0x1 << 6)	/* TX FIFO full Status */
+#define UART_STAT_RFEM		(0x1 << 5)	/* RX FIFO Empty Status */
+#define UART_STAT_RXST		(0x1 << 4)	/* Receive Status */
+#define UART_STAT_TFER		(0x1 << 3)	/* TX FIFO Erro */
+#define UART_STAT_RXER		(0x1 << 2)	/* RX FIFO Erro */
+#define UART_STAT_TIP		(0x1 << 1)	/* TX IRQ Pending Bit */
+#define UART_STAT_RIP		(0x1 << 0)	/* RX IRQ Pending Bit */
+
+#define RX_FIFO_DEPTH  32
+/******************************************************************************/
+/*DMA*/
+#define OWL_UART_RX_DMA_BUFFER_SIZE (4096*4)
+#define DMA_RX_FLUSH_JIFFIES (HZ/50)
+#define STOP_TIMEOUT 1000000
+
+struct owl_uart_port {
+	struct uart_port uart;
+	char name[16];
+	struct clk *clk;
+	unsigned int saved_ctl;
+
+	/*dma*/
+	bool enable_dma_rx;
+	bool enable_dma_tx;
+	struct dma_chan *rx_dma_chan;
+	struct dma_chan *tx_dma_chan;
+	dma_addr_t rx_dma_buf_phys;
+	dma_addr_t tx_dma_buf_phys;
+	unsigned char *rx_dma_buf_virt;
+	unsigned char *tx_dma_buf_virt;
+	struct dma_async_tx_descriptor *rx_dma_desc;
+	struct dma_async_tx_descriptor *tx_dma_desc;
+	dma_cookie_t rx_cookie;
+	dma_cookie_t tx_cookie;
+
+	struct timer_list rx_dma_timer;
+	unsigned int dma_buf_tail;
+
+	int tx_dma_in_progress;
+	unsigned int tx_bytes;
+	int status;
+};
+
+struct owl_serial_state {
+	struct pinctrl *p;
+	int refcount;
+};
+
+static struct owl_uart_port owl_uart_ports[OWL_MAX_UART];
+static struct owl_serial_state *sdio_serial_state;
+static struct platform_device *g_pdev;
+static int owl_console_port = OWL_MAX_UART;
+
+static int owl_uart_start_dma(struct owl_uart_port *owl_uart_port, bool dma_to_memory);
+
+static inline struct uart_port *get_port_from_line(unsigned int line)
+{
+	return &owl_uart_ports[line].uart;
+}
+
+static inline void owl_write(struct uart_port *port, unsigned int val, unsigned int off)
+{
+	__raw_writel(val, port->membase + off);
+}
+
+static inline unsigned int owl_read(struct uart_port *port, unsigned int off)
+{
+	return __raw_readl(port->membase + off);
+}
+
+static void owl_uart_next_tx(struct owl_uart_port *owl_uart_port)
+{
+	struct uart_port *uport = &(owl_uart_port->uart);
+	struct circ_buf *xmit = &uport->state->xmit;
+
+	owl_uart_port->tx_bytes = CIRC_CNT_TO_END(xmit->head, xmit->tail,
+			UART_XMIT_SIZE);
+	if (!owl_uart_port->tx_bytes)
+		return;
+
+	owl_uart_start_dma(owl_uart_port, false);
+}
+
+/* Start transmitting */
+static void owl_start_tx(struct uart_port *port)
+{
+	unsigned int data;
+	struct owl_uart_port *owl_uart_port = UART_TO_OWL_UART_PORT(port);
+
+	if (owl_uart_port->enable_dma_tx) {
+		if (owl_uart_port->tx_dma_in_progress)
+			return;
+
+		owl_uart_next_tx(owl_uart_port);
+	} else{
+		data = owl_read(port, UART_STAT);
+		data |= UART_STAT_TIP;
+		owl_write(port, data, UART_STAT);
+
+		data = owl_read(port, UART_CTL);
+		data |= UART_CTL_TXIE;
+		owl_write(port, data, UART_CTL);
+	}
+}
+
+/*
+ * Stop transmitting.
+ */
+static void owl_stop_tx(struct uart_port *port)
+{
+	struct owl_uart_port *owl_uart_port = UART_TO_OWL_UART_PORT(port);
+	unsigned int data;
+
+	owl_uart_port->tx_dma_in_progress = 0;
+	if (owl_uart_port->enable_dma_tx)
+		dmaengine_terminate_all(owl_uart_port->tx_dma_chan);
+
+	data = owl_read(port, UART_CTL);
+	data &= ~(UART_CTL_TXIE | UART_CTL_TXDE);
+	owl_write(port, data, UART_CTL);
+
+	data = owl_read(port, UART_STAT);
+	data |= UART_STAT_TIP;
+	owl_write(port, data, UART_STAT);
+}
+
+/*
+ * Stop receiving - port is in process of being closed.
+ */
+static void owl_stop_rx(struct uart_port *port)
+{
+	struct owl_uart_port *owl_uart_port = UART_TO_OWL_UART_PORT(port);
+	unsigned int data;
+
+	if(port->line == owl_console_port)
+		return;
+	del_timer_sync(&(owl_uart_port->rx_dma_timer));
+
+	if (owl_uart_port->enable_dma_rx)
+		dmaengine_terminate_all(owl_uart_port->rx_dma_chan);
+
+	owl_uart_port->dma_buf_tail = 0;
+	data = owl_read(port, UART_CTL);
+	data &= ~(UART_CTL_RXIE | UART_CTL_RXDE);
+	owl_write(port, data, UART_CTL);
+
+	data = owl_read(port, UART_STAT);
+	data |= UART_STAT_RIP;
+	owl_write(port, data, UART_STAT);
+}
+
+/*
+ * Enable modem status interrupts
+ */
+static void owl_enable_ms(struct uart_port *port)
+{
+}
+
+static int owl_is_break_button_down(char c)
+{
+	static char breakbuf[] = {0x02, 0x12, 0x05, 0x01, 0x0b};	//ctrl + "break"
+	static int index = 0;
+	
+	if(c == breakbuf[index])
+	{
+		index++;
+		if(index == sizeof(breakbuf))
+		{
+			index = 0;
+			return 1;
+		}
+	}
+	else
+		index = 0;
+	
+	return 0;
+}
+
+#ifdef CONFIG_ARM_OWL_CPUFREQ
+void owl_cpufreq_frequency_lock(void);
+void owl_cpufreq_frequency_unlock(void);
+#endif
+
+static int owl_uart_handle_sysrq_char(struct uart_port *port, char c)
+{
+	if(port->line != owl_console_port)
+		return 0;
+
+	if(owl_is_break_button_down(c))
+		uart_handle_break(port);
+	else if(port->sysrq)
+	{
+		int console_loglevel_save = console_loglevel;
+		
+		spin_unlock(&port->lock);
+#ifdef CONFIG_ARM_OWL_CPUFREQ
+		owl_cpufreq_frequency_lock();
+#endif
+
+		console_loglevel = 7;
+		uart_handle_sysrq_char(port, c);
+		console_loglevel = console_loglevel_save;
+		
+#ifdef CONFIG_ARM_OWL_CPUFREQ
+		owl_cpufreq_frequency_unlock();
+#endif
+		spin_lock(&port->lock);
+		return 1;
+	}
+	
+	return 0;
+}
+/*
+ * Characters received (called from interrupt handler)
+ */
+static void handle_rx(struct uart_port *port)
+{
+	unsigned int stat, data;
+
+	/* select RX FIFO */
+	data = owl_read(port, UART_CTL);
+	data &= ~UART_CTL_TRFS;
+	data |= UART_CTL_TRFS_RX;
+	owl_write(port, data, UART_CTL);
+
+	/* and now the main RX loop */
+	while (!((stat = owl_read(port, UART_STAT)) & UART_STAT_RFEM)) {
+		unsigned int c;
+		char flag = TTY_NORMAL;
+
+		c = owl_read(port, UART_RXDAT);
+
+		if (stat & UART_STAT_RXER)
+			port->icount.overrun++;
+
+		if (stat & UART_STAT_RXST) {
+			/* we are not able to distinguish the error type */
+			port->icount.brk++;
+			port->icount.frame++;
+
+			/* Mask conditions we're ignorning. */
+			stat &= port->read_status_mask;
+			if (stat & UART_STAT_RXST)
+				flag = TTY_PARITY;
+		} else
+			port->icount.rx++;
+		
+		if(owl_uart_handle_sysrq_char(port, c))
+			continue;
+
+		uart_insert_char(port, stat, stat & UART_STAT_RXER, c, flag);
+	}
+
+	tty_flip_buffer_push(&port->state->port);
+}
+
+/*
+ * transmit interrupt handler
+ */
+static void handle_tx(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned int data;
+
+	if (port->x_char) {
+		/* wait TX FIFO not full */
+		while (owl_read(port, UART_STAT) & UART_STAT_TFFU)
+			;
+		owl_write(port, port->x_char, UART_TXDAT);
+		port->icount.tx++;
+		port->x_char = 0;
+	}
+
+	/* select TX FIFO */
+	data = owl_read(port, UART_CTL);
+	data &= ~UART_CTL_TRFS;
+	data |= UART_CTL_TRFS_TX;
+	owl_write(port, data, UART_CTL);
+
+	while (!(owl_read(port, UART_STAT) & UART_STAT_TFFU)) {
+		if (uart_circ_empty(xmit))
+			break;
+
+		owl_write(port, xmit->buf[xmit->tail], UART_TXDAT);
+
+		/* wait FIFO empty? */
+/*		while (owl_read(port, UART_STAT) & UART_STAT_TRFL_MASK)
+			;
+*/
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		owl_stop_tx(port);
+}
+
+/*
+ * Interrupt handler
+ */
+static irqreturn_t owl_uart_irq(int irq, void *dev_id)
+{
+	unsigned long flags;
+	struct uart_port *port = dev_id;
+	unsigned int stat;
+
+	spin_lock_irqsave(&port->lock, flags);
+	stat = owl_read(port, UART_STAT);
+
+	/*when using DMA, handle_rx will never be called*/
+	if (stat & UART_STAT_RIP)
+		handle_rx(port);
+
+	if (stat & UART_STAT_TIP)
+		handle_tx(port);
+
+	stat = owl_read(port, UART_STAT);
+	stat |= UART_STAT_RIP | UART_STAT_TIP;
+	owl_write(port, stat, UART_STAT);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Return TIOCSER_TEMT when transmitter FIFO and Shift register is empty.
+ */
+static unsigned int owl_tx_empty(struct uart_port *port)
+{
+	unsigned int data, ret;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&port->lock, flags);
+	/* select TX FIFO */
+	data = owl_read(port, UART_CTL);
+	data &= ~UART_CTL_TRFS;
+	data |= UART_CTL_TRFS_TX;
+	owl_write(port, data, UART_CTL);
+
+	/* check FIFO level */
+	data = owl_read(port, UART_STAT);
+	ret = (data & UART_STAT_TRFL_MASK) ? 0 : TIOCSER_TEMT;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return ret;
+}
+
+/*modem control is not implemented yet*/
+static unsigned int owl_get_mctrl(struct uart_port *port)
+{
+	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+}
+
+static void owl_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static void owl_break_ctl(struct uart_port *port, int break_ctl)
+{
+}
+
+static int owl_set_baud_rate(struct uart_port *port, unsigned int baud)
+{
+	struct owl_uart_port *owl_uart_port = UART_TO_OWL_UART_PORT(port);
+	unsigned int target_freq, lookup_freq, freq;
+	int ret;
+
+	if (!owl_uart_port->clk) {
+		printk("ERROR: uart%d did not get clk\n", port->line);
+		return -1;
+	}
+
+	target_freq = baud * 8;
+	lookup_freq = clk_round_rate(owl_uart_port->clk, target_freq);
+
+#if 1
+	/*provide an accuracy < 1%*/
+	lookup_freq = target_freq + target_freq/128;
+	freq = clk_round_rate(owl_uart_port->clk, lookup_freq);
+	while (freq > target_freq) {
+		lookup_freq = freq;
+		freq = clk_round_rate(owl_uart_port->clk, lookup_freq - 1);
+	}
+#endif
+
+	ret = clk_set_rate(owl_uart_port->clk, lookup_freq);
+	if (ret < 0) {
+		dev_err(port->dev, "clk_set_rate() failed for rate %u\n",
+				lookup_freq);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * RX DMA callback function -- do noting
+ * note:it will be called by dma_terminate_all()
+ */
+static void owl_uart_rx_dma_callback(void *param)
+{
+	return;
+}
+
+static void owl_uart_rx_to_tty(struct owl_uart_port *owl_uart_port,
+		unsigned int tail, unsigned int count)
+{
+	struct uart_port *uport = &(owl_uart_port->uart);
+	int copied;
+	unsigned int status;
+
+	status = owl_read(uport, UART_STAT);
+	if (status & (0x1 << 4 | 0x1 << 2)) {
+		pr_err("\n\nRX FIFO error, UART_STAT = 0x%x\n\n", status);
+		owl_dma_dump_all(owl_uart_port->rx_dma_chan);
+	}
+
+	uport->icount.rx += count;
+
+	dma_sync_single_for_cpu(uport->dev, owl_uart_port->rx_dma_buf_phys,
+			OWL_UART_RX_DMA_BUFFER_SIZE, DMA_FROM_DEVICE);
+
+	copied = tty_insert_flip_string(&owl_uart_port->uart.state->port,
+			(unsigned char *)(owl_uart_port->rx_dma_buf_virt + tail),
+			count);
+	if (copied != count)
+		pr_err("rx_dma_callback:RxData copy to tty layer failed\n");
+
+	dma_sync_single_for_device(uport->dev, owl_uart_port->rx_dma_buf_phys,
+			OWL_UART_RX_DMA_BUFFER_SIZE, DMA_FROM_DEVICE);
+	tty_flip_buffer_push(&owl_uart_port->uart.state->port);
+}
+
+static void owl_uart_rx_dma_timeout(struct owl_uart_port *owl_uart_port)
+{
+	struct uart_port *uport = &(owl_uart_port->uart);
+	unsigned int dma_remain = 0, count;
+	unsigned int head, tail = owl_uart_port->dma_buf_tail;
+	unsigned long flags;
+
+	spin_lock_irqsave(&uport->lock, flags);
+
+	dma_remain = read_remain_cnt(owl_uart_port->rx_dma_chan);
+	head = OWL_UART_RX_DMA_BUFFER_SIZE - dma_remain;
+	if (head < tail) {
+		count = OWL_UART_RX_DMA_BUFFER_SIZE - tail;
+		owl_uart_rx_to_tty(owl_uart_port, tail, count);
+		tail = 0;
+	}
+
+	count = head - tail;
+	if (count > 0)
+		owl_uart_rx_to_tty(owl_uart_port, tail, count);
+
+	owl_uart_port->dma_buf_tail = head;
+
+	spin_unlock_irqrestore(&uport->lock, flags);
+
+	mod_timer(&(owl_uart_port->rx_dma_timer), jiffies + DMA_RX_FLUSH_JIFFIES);
+}
+
+/*TX DMA callback function*/
+static void owl_uart_tx_dma_callback(void *param)
+{
+	struct owl_uart_port *owl_uart_port = (struct owl_uart_port *)param;
+	struct uart_port *uport = &(owl_uart_port->uart);
+	struct circ_buf *xmit = &uport->state->xmit;
+	unsigned long flags, timeout = STOP_TIMEOUT;
+	unsigned int status;
+
+	if (0 == owl_uart_port->tx_dma_in_progress)
+		return;
+
+	spin_lock_irqsave(&uport->lock, flags);
+
+	/*
+	 * we must wait until the TX FIFO is empty before
+	 * we start next dma transfer, otherwise we will
+	 * lost some bytes.
+	 */
+	while (owl_read(uport, UART_STAT) & UART_STAT_TRFL_MASK) {
+		udelay(10);
+		timeout--;
+		if (0 == timeout) {
+			pr_err("TX DMA timeout...");
+			return;
+		}
+	}
+
+	status = owl_read(uport, UART_STAT);
+	if (status & UART_STAT_TFER) {
+		pr_err("\n\nTX FIFO error, UART_STAT = 0x%x\n\n", status);
+		owl_dma_dump_all(owl_uart_port->tx_dma_chan);
+	}
+
+	dma_sync_single_for_cpu(owl_uart_port->uart.dev,
+			owl_uart_port->tx_dma_buf_phys,
+			UART_XMIT_SIZE, DMA_TO_DEVICE);
+
+	xmit->tail += owl_uart_port->tx_bytes;
+	xmit->tail &= UART_XMIT_SIZE - 1;
+	uport->icount.tx += owl_uart_port->tx_bytes;
+
+	if (uart_circ_empty(xmit))
+		owl_uart_port->tx_dma_in_progress = 0;
+	else
+		owl_uart_next_tx(owl_uart_port);
+
+	spin_unlock_irqrestore(&uport->lock, flags);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(uport);
+}
+
+static unsigned int owl_uart_dma_mode_config(unsigned int line,
+		bool dma_to_memory)
+{
+	unsigned int mode = 0;
+
+	if (dma_to_memory)
+		mode = PRIORITY_ZERO | SRC_CONSTANT |
+			DST_INCR | DST_DCU |
+			SRC_DEV | (0x10+line*2+1) | BUS_WIDTH_8BIT;
+	else
+		mode = PRIORITY_ZERO | SRC_INCR |
+			DST_CONSTANT | DST_DEV |
+			SRC_DCU | (0x10+line*2) | BUS_WIDTH_8BIT;
+
+	return mode;
+}
+
+static int owl_uart_dma_channel_allocate(struct owl_uart_port *owl_uart_port,
+		bool dma_to_memory)
+{
+	struct dma_chan *dma_chan;
+	struct owl_dma_slave *acts_slave;
+	dma_cap_mask_t mask;
+	unsigned char *dma_buf;
+	dma_addr_t dma_phys;
+	struct dma_slave_config *dma_sconf;
+	int ret;
+	struct uart_port *uport = &(owl_uart_port->uart);
+
+	/*request dma channel*/
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	dma_chan = dma_request_channel(mask, NULL, NULL);
+	if (!dma_chan) {
+		dev_err(uport->dev, "Failed to request DMA channel\n");
+		return -ENODEV;
+	}
+
+	/*do DMA mapping*/
+	/*ALERT: use dma_alloc_coherent() will not work!*/
+	if (dma_to_memory) { /*RX*/
+		dma_buf = kzalloc(OWL_UART_RX_DMA_BUFFER_SIZE, GFP_KERNEL);
+		if (!dma_buf) {
+			dev_err(uport->dev, "Not able to allocate the dma buffer for RX\n");
+			dma_release_channel(dma_chan);
+			return -ENOMEM;
+		}
+		dma_phys = dma_map_single(uport->dev, dma_buf,
+				OWL_UART_RX_DMA_BUFFER_SIZE, DMA_FROM_DEVICE);
+
+	} else{ /*TX*/
+		dma_buf = uport->state->xmit.buf;
+		dma_phys = dma_map_single(uport->dev, dma_buf, UART_XMIT_SIZE,
+				DMA_TO_DEVICE);
+	}
+
+	/*alloc and fill struct dma_slave_config*/
+	dma_sconf = devm_kzalloc(uport->dev, sizeof(*dma_sconf), GFP_KERNEL);
+	if (!dma_sconf) {
+		dev_err(uport->dev, "Not able to allocate struct dma_slave_config\n");
+		return -ENOMEM;
+	}
+	if (dma_to_memory)
+		dma_sconf->src_addr = (unsigned int)uport->mapbase + UART_RXDAT;
+	else
+		dma_sconf->dst_addr = (unsigned int)uport->mapbase + UART_TXDAT;
+
+	/*alloc and fill struct owl_dma_slave*/
+	acts_slave = devm_kzalloc(uport->dev, sizeof(*acts_slave), GFP_KERNEL);
+	if (!acts_slave) {
+		dev_err(uport->dev, "Not able to alloc struct owl_dma_slave\n");
+		return -ENOMEM;
+	}
+	acts_slave->dma_dev = dma_chan->device->dev;
+	acts_slave->trans_type = SLAVE;
+	acts_slave->mode = owl_uart_dma_mode_config(uport->line,
+			dma_to_memory);
+
+	if (dma_to_memory) {
+		owl_uart_port->rx_dma_chan = dma_chan;
+		owl_uart_port->rx_dma_buf_virt = dma_buf;
+		owl_uart_port->rx_dma_buf_phys = dma_phys;
+		owl_uart_port->rx_dma_chan->private = acts_slave;
+	} else{
+		owl_uart_port->tx_dma_chan = dma_chan;
+		owl_uart_port->tx_dma_buf_virt = dma_buf;
+		owl_uart_port->tx_dma_buf_phys = dma_phys;
+		owl_uart_port->tx_dma_chan->private = acts_slave;
+	}
+
+	/*finish DMA config*/
+	ret = dmaengine_slave_config(dma_chan, dma_sconf);
+	if (ret < 0) {
+		dev_err(uport->dev, "DMA slave config failed, err = %d\n", ret);
+		dma_release_channel(dma_chan);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void owl_uart_dma_channel_free(struct owl_uart_port *owl_uart_port,
+		bool dma_to_memory)
+{
+	struct dma_chan *dma_chan;
+	struct uart_port *uport = &(owl_uart_port->uart);
+
+	if (dma_to_memory) {
+		dma_unmap_single(uport->dev, owl_uart_port->rx_dma_buf_phys,
+				OWL_UART_RX_DMA_BUFFER_SIZE, DMA_FROM_DEVICE);
+		kfree(owl_uart_port->rx_dma_buf_virt);
+		dma_chan = owl_uart_port->rx_dma_chan;
+		owl_uart_port->rx_dma_chan = NULL;
+		owl_uart_port->rx_dma_buf_phys = 0;
+		owl_uart_port->rx_dma_buf_virt = NULL;
+	} else {
+		dma_unmap_single(uport->dev, owl_uart_port->tx_dma_buf_phys,
+				UART_XMIT_SIZE, DMA_TO_DEVICE);
+		dma_chan = owl_uart_port->tx_dma_chan;
+		owl_uart_port->tx_dma_chan = NULL;
+		owl_uart_port->tx_dma_buf_phys = 0;
+		owl_uart_port->tx_dma_buf_virt = NULL;
+	}
+
+	dma_release_channel(dma_chan);
+}
+
+static void owl_uart_module_enable(unsigned int line)
+{
+	switch (line) {
+	case 0:
+		module_clk_enable(MOD_ID_UART0);
+		break;
+
+	case 1:
+		module_clk_enable(MOD_ID_UART1);
+		break;
+
+	case 2:
+		module_clk_enable(MOD_ID_UART2);
+		break;
+
+	case 3:
+		module_clk_enable(MOD_ID_UART3);
+		break;
+
+	case 4:
+		module_clk_enable(MOD_ID_UART4);
+		break;
+
+	case 5:
+		module_clk_enable(MOD_ID_UART5);
+		break;
+
+	case 6:
+		module_clk_enable(MOD_ID_UART6);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void owl_uart_module_disable(unsigned int line)
+{
+	switch (line) {
+	case 0:
+		module_clk_disable(MOD_ID_UART0);
+		break;
+
+	case 1:
+		module_clk_disable(MOD_ID_UART1);
+		break;
+
+	case 2:
+		module_clk_disable(MOD_ID_UART2);
+		break;
+
+	case 3:
+		module_clk_disable(MOD_ID_UART3);
+		break;
+
+	case 4:
+		module_clk_disable(MOD_ID_UART4);
+		break;
+
+	case 5:
+		module_clk_disable(MOD_ID_UART5);
+		break;
+
+	case 6:
+		module_clk_disable(MOD_ID_UART6);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void owl_uart_hw_init(struct owl_uart_port *owl_uart_port)
+{
+	struct uart_port *uport = &(owl_uart_port->uart);
+	unsigned int data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&uport->lock, flags);
+	
+	data = owl_read(uport, UART_STAT);
+	/* clear IRQ pending and reset RX/TX FIFO*/
+	data |= UART_STAT_RIP | UART_STAT_TIP |
+		UART_STAT_RXER | UART_STAT_TFER | UART_STAT_RXST;
+	owl_write(uport, data, UART_STAT);
+
+	data = owl_read(uport, UART_CTL);
+	if (owl_uart_port->enable_dma_rx)
+		/*enable DRQ for RX*/
+		data |= UART_CTL_DRCR | UART_CTL_RXDE;
+	else
+		data |= UART_CTL_RXIE;
+
+	if (owl_uart_port->enable_dma_tx)
+		/*enable DRQ for TX*/
+		data |= UART_CTL_DTCR | UART_CTL_TXDE;
+	else
+		data |= UART_CTL_TXIE;
+
+	/* enable module*/
+	data |= UART_CTL_EN;
+	owl_write(uport, data, UART_CTL);
+	
+	spin_unlock_irqrestore(&uport->lock, flags);
+	/*no need to set trigger level*/
+}
+
+static int owl_uart_start_dma(struct owl_uart_port *owl_uart_port, bool dma_to_memory)
+{
+	struct uart_port *uport = &(owl_uart_port->uart);
+	struct circ_buf *xmit = &uport->state->xmit;
+
+	if (dma_to_memory) {
+		owl_uart_port->rx_dma_desc = dmaengine_prep_dma_cyclic(
+				owl_uart_port->rx_dma_chan,
+				owl_uart_port->rx_dma_buf_phys,
+				OWL_UART_RX_DMA_BUFFER_SIZE,
+				OWL_UART_RX_DMA_BUFFER_SIZE,
+				DMA_DEV_TO_MEM, 0);
+		if (!owl_uart_port->rx_dma_desc) {
+			dev_err(uport->dev, "Not able to get desc for RX\n");
+			return -EIO;
+		}
+
+		/*set callback function*/
+		owl_uart_port->rx_dma_desc->callback = owl_uart_rx_dma_callback;
+		owl_uart_port->rx_dma_desc->callback_param = owl_uart_port;
+
+		/*submit request*/
+		owl_uart_port->rx_cookie = dmaengine_submit(owl_uart_port->rx_dma_desc);
+
+		dma_sync_single_for_device(owl_uart_port->uart.dev,
+				owl_uart_port->rx_dma_buf_phys,
+				OWL_UART_RX_DMA_BUFFER_SIZE, DMA_FROM_DEVICE);
+		/*activate transactions in the pending queue*/
+		dma_async_issue_pending(owl_uart_port->rx_dma_chan);
+
+		/*init timer*/
+		owl_uart_port->rx_dma_timer.data = (unsigned long)owl_uart_port;
+		owl_uart_port->rx_dma_timer.function =
+			(void *)owl_uart_rx_dma_timeout;
+		owl_uart_port->rx_dma_timer.expires =
+			jiffies + DMA_RX_FLUSH_JIFFIES;
+		add_timer(&(owl_uart_port->rx_dma_timer));
+
+	} else{ /*TX*/
+		dma_sync_single_for_device(owl_uart_port->uart.dev,
+				owl_uart_port->tx_dma_buf_phys,
+				UART_XMIT_SIZE, DMA_TO_DEVICE);
+
+		owl_uart_port->tx_dma_in_progress = 1;
+
+		owl_uart_port->tx_dma_desc = dmaengine_prep_slave_single(
+				owl_uart_port->tx_dma_chan,
+				owl_uart_port->tx_dma_buf_phys + xmit->tail,
+				owl_uart_port->tx_bytes, DMA_MEM_TO_DEV, 0);
+		if (!owl_uart_port->tx_dma_desc) {
+			dev_err(uport->dev, "Not able to get desc for TX\n");
+			return -EIO;
+		}
+
+		owl_uart_port->tx_dma_desc->callback = owl_uart_tx_dma_callback;
+		owl_uart_port->tx_dma_desc->callback_param = owl_uart_port;
+
+		owl_uart_port->tx_cookie = dmaengine_submit(owl_uart_port->tx_dma_desc);
+		/*
+		 * do not issue pending according to
+		 * our dmaengine implementation
+		 */
+		/*dma_async_issue_pending(owl_uart_port->tx_dma_chan);*/
+	}
+	return 0;
+}
+
+
+static int keepuartonflag;
+static int __init keepuarton_setup(char *__str)
+{
+	keepuartonflag = 1;
+	return 1;
+}
+__setup("keepuarton", keepuarton_setup);
+
+/*
+ * Disable the port
+ */
+static void __owl_uart_shutdown(struct uart_port *port)
+{
+	struct owl_uart_port *owl_uart_port = UART_TO_OWL_UART_PORT(port);
+	unsigned int data;
+	unsigned long flags;
+
+	if(owl_uart_port->status == 0)
+		return;
+		
+	spin_lock_irqsave(&port->lock, flags);
+	
+	owl_uart_port->status = 0;
+		
+	/* disable module/IRQs/DRQs */
+	data = owl_read(port, UART_CTL);
+	data &= ~(UART_CTL_RXIE | UART_CTL_TXIE
+			| UART_CTL_RXDE | UART_CTL_TXDE);
+	if (1 != keepuartonflag)
+		data &= ~UART_CTL_EN;
+
+	owl_write(port, data, UART_CTL);
+	
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	if (owl_uart_port->enable_dma_rx)
+		owl_uart_dma_channel_free(owl_uart_port, true);
+
+	if (owl_uart_port->enable_dma_tx)
+		owl_uart_dma_channel_free(owl_uart_port, false);
+
+	if (!owl_uart_port->enable_dma_rx || !owl_uart_port->enable_dma_tx)
+		free_irq(port->irq, port);
+		
+}
+ 
+static void owl_uart_shutdown(struct uart_port *port)
+{
+	if(port->line == owl_console_port)	//console always on
+		return;
+
+	__owl_uart_shutdown(port);
+}
+
+/*
+ * use DMA for RX and TX if we set "enable-dma-xx" in dts
+ */
+static int owl_uart_dma_startup(struct uart_port *uport)
+{
+	int ret;
+	struct owl_uart_port *owl_uart_port = UART_TO_OWL_UART_PORT(uport);
+
+	if(uport->line == owl_console_port)		//console only closed when another open happened
+		__owl_uart_shutdown(uport);
+		
+	if(owl_uart_port->status == 1)
+		return 0;
+
+	if (owl_uart_port->enable_dma_rx) {
+		ret = owl_uart_dma_channel_allocate(owl_uart_port, true);/*RX*/
+		if (ret < 0) {
+			dev_err(uport->dev,
+					"UART Rx Dma allocation failed, "
+					"err = %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (owl_uart_port->enable_dma_tx) {
+		ret = owl_uart_dma_channel_allocate(owl_uart_port, false);/*TX*/
+		if (ret < 0) {
+			dev_err(uport->dev,
+					"UART Tx Dma allocation failed, "
+					"err = %d\n", ret);
+			if (owl_uart_port->enable_dma_rx)
+				owl_uart_dma_channel_free(owl_uart_port, true);
+			else
+				return ret;
+		}
+	}
+
+	if (!owl_uart_port->enable_dma_rx || !owl_uart_port->enable_dma_tx) {
+		ret = request_irq(uport->irq, owl_uart_irq, IRQF_TRIGGER_HIGH,
+				owl_uart_port->name, uport);
+		if (ret) {
+			if (owl_uart_port->enable_dma_rx)
+				owl_uart_dma_channel_free(owl_uart_port, true);
+			else if (owl_uart_port->enable_dma_tx)
+				owl_uart_dma_channel_free(owl_uart_port, false);
+			else
+				return ret;
+
+			return ret;
+		}
+	}
+
+	owl_uart_hw_init(owl_uart_port);
+
+	/*start RX DMA*/
+	if (owl_uart_port->enable_dma_rx) {
+		ret = owl_uart_start_dma(owl_uart_port, true);
+		if (ret < 0)
+			dev_err(uport->dev,
+					"RX DMA start failed, err = %d\n", ret);
+	}
+
+	pr_debug("open ttyS%x %s %s\n", uport->line,
+			owl_uart_port->enable_dma_rx ? "DMA RX" : " ",
+			owl_uart_port->enable_dma_tx ? "DMA TX" : " ");
+
+	owl_uart_port->status = 1;
+	
+	return 0;
+}
+
+/*
+ * Change the port parameters
+ */
+static void owl_set_termios(struct uart_port *port, struct ktermios *termios,
+		struct ktermios *old)
+{
+	unsigned long flags;
+	unsigned int ctl, baud;
+	int ret;
+
+	/*For BT, the max bit rate is 3M*/
+	baud = uart_get_baud_rate(port, termios, old, 0, 3200000);
+
+	/*it's not able to set baudrate on fpga*/
+	ret = owl_set_baud_rate(port, baud);
+	if (ret < 0) {
+		printk("owl_set_baud_rate failed\n");
+		return;
+	}
+
+	if (tty_termios_baud_rate(termios))
+		tty_termios_encode_baud_rate(termios, baud, baud);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* We don't support modem control lines. */
+	termios->c_cflag &= ~(HUPCL | CMSPAR);
+	termios->c_cflag |= CLOCAL;
+
+	/* We don't support BREAK character recognition. */
+	termios->c_iflag &= ~(IGNBRK | BRKINT);
+
+	ctl = owl_read(port, UART_CTL);
+	ctl &= ~(UART_CTL_DWLS_MASK | UART_CTL_STPS
+			| UART_CTL_PRS_MASK | UART_CTL_AFE);
+
+	/* byte size */
+	ctl &= ~UART_CTL_DWLS_MASK;
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		ctl |= UART_CTL_DWLS(0);
+		break;
+	case CS6:
+		ctl |= UART_CTL_DWLS(1);
+		break;
+	case CS7:
+		ctl |= UART_CTL_DWLS(2);
+		break;
+	case CS8:
+	default:
+		ctl |= UART_CTL_DWLS(3);
+		break;
+	}
+
+	/* stop bits */
+	if (termios->c_cflag & CSTOPB)
+		ctl |= UART_CTL_STPS_2BITS;
+	else
+		ctl |= UART_CTL_STPS_1BITS;
+
+	/* parity */
+	if (termios->c_cflag & PARENB) {
+		/* Mark or Space parity */
+		if (termios->c_cflag & CMSPAR) {
+			if (termios->c_cflag & PARODD)
+				ctl |= UART_CTL_PRS_MARK;
+			else
+				ctl |= UART_CTL_PRS_SPACE;
+		} else if (termios->c_cflag & PARODD)
+			ctl |= UART_CTL_PRS_ODD;
+		else
+			ctl |= UART_CTL_PRS_EVEN;
+	} else
+		ctl |= UART_CTL_PRS_NONE;
+
+	/* Only uart2/3 support RTS/CTS Automatic Hardware Flow Control. */
+	if ((termios->c_cflag & CRTSCTS) &&
+			(2 == port->line || 3 == port->line))
+		ctl |= UART_CTL_AFE;
+
+	owl_write(port, ctl, UART_CTL);
+
+	/* Configure status bits to ignore based on termio flags. */
+
+	/*
+	 * Normally we need to mask the bits we do care about
+	 * as there is no hardware support for
+	 * (termios->c_iflag & INPACK/BRKINT/PARMRK)
+	 * and it seems the interrupt happened only for tx/rx
+	 * we do nothing about the port.read_status_mask
+	 */
+	port->read_status_mask |= UART_STAT_RXER;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= UART_STAT_RXST;
+
+	/* update the per-port timeout */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/*
+ * Return string describing the specified port
+ */
+static const char *owl_uart_type(struct uart_port *port)
+{
+	return "OWL_SERIAL";
+}
+
+/*
+ * Release the memory region(s) being used by 'port'.
+ */
+static void owl_release_port(struct uart_port *port)
+{
+	struct platform_device *pdev = to_platform_device(port->dev);
+	struct resource *resource;
+	resource_size_t size;
+
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (unlikely(!resource))
+		return;
+	size = resource->end - resource->start + 1;
+
+	release_mem_region(port->mapbase, size);
+
+	if (port->flags & UPF_IOREMAP) {
+		iounmap(port->membase);
+		port->membase = NULL;
+	}
+}
+
+/*
+ * Request the memory region(s) being used by 'port'.
+ */
+static int owl_request_port(struct uart_port *port)
+{
+	struct platform_device *pdev = to_platform_device(port->dev);
+	struct resource *resource;
+	resource_size_t size;
+
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (unlikely(!resource))
+		return -ENXIO;
+	size = resource->end - resource->start + 1;
+
+	if (!request_mem_region(port->mapbase, size, "owl_serial"))
+		return -EBUSY;
+
+	if (port->flags & UPF_IOREMAP) {
+		port->membase = ioremap(port->mapbase, size);
+		if (port->membase == NULL) {
+			release_mem_region(port->mapbase, size);
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void owl_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_OWL;
+		owl_request_port(port);
+	}
+}
+
+static int owl_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (unlikely(ser->type != PORT_UNKNOWN && ser->type != PORT_OWL))
+		return -EINVAL;
+	if (unlikely(port->irq != ser->irq))
+		return -EINVAL;
+	if ((void *)port->membase != ser->iomem_base)
+		return -EINVAL;
+	return 0;
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+static int owl_poll_get_char(struct uart_port *port)
+{
+	unsigned int old_ctl, data;
+	unsigned long flags;
+	unsigned int ch = NO_POLL_CHAR;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* backup old control register */
+	old_ctl = owl_read(port, UART_CTL);
+
+	/* select RX FIFO */
+	data = old_ctl & (~(UART_CTL_TRFS));
+	data = data | UART_CTL_TRFS_RX;
+
+	/* disable IRQ */
+	/*
+	   data &= ~(UART_CTL_TXIE | UART_CTL_RXIE);
+	   */
+	owl_write(port, data, UART_CTL);
+
+	/* wait RX FIFO not emtpy */
+	do {
+		cpu_relax();
+		/* Get the interrupts */
+		data = owl_read(port, UART_STAT);
+	} while ((data & UART_STAT_RIP) == 0);
+
+	while (!(data & UART_STAT_RFEM)) {
+		ch = owl_read(port, UART_RXDAT);
+		data = owl_read(port, UART_STAT);
+	}
+
+	/* clear IRQ pending */
+	data = owl_read(port, UART_STAT);
+	/*
+	   data |= UART_STAT_TIP | UART_STAT_RIP;
+	   */
+	data |= UART_STAT_RIP;
+	owl_write(port, data, UART_STAT);
+
+	/* restore old ctl */
+	owl_write(port, old_ctl, UART_CTL);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	return ch;
+}
+
+static void owl_poll_put_char(struct uart_port *port, unsigned char ch)
+{
+	unsigned int old_ctl, data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* backup old control register */
+	old_ctl = owl_read(port, UART_CTL);
+
+	/* select TX FIFO */
+	data = old_ctl & (~(UART_CTL_TRFS));
+	data = data | UART_CTL_TRFS_TX;
+
+	/* disable IRQ */
+	data &= ~(UART_CTL_TXIE | UART_CTL_RXIE);
+	owl_write(port, data, UART_CTL);
+
+	/* wait TX FIFO not full */
+	while (owl_read(port, UART_STAT) & UART_STAT_TFFU)
+		cpu_relax();
+
+	owl_write(port, ch, UART_TXDAT);
+
+	/* wait until all content have been sent out
+	 * TODO:
+	 */
+	while (owl_read(port, UART_STAT) & UART_STAT_TRFL_MASK)
+		cpu_relax();
+
+	/* clear IRQ pending */
+	data = owl_read(port, UART_STAT);
+	/*
+	   data |= UART_STAT_TIP | UART_STAT_RIP;
+	   */
+	data |= UART_STAT_TIP;
+	owl_write(port, data, UART_STAT);
+	data = owl_read(port, UART_STAT);
+
+	/* restore old ctl */
+	owl_write(port, old_ctl, UART_CTL);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+	return;
+}
+#endif
+
+
+/*
+ * Power / Clock management.
+ */
+static void owl_uart_pm(struct uart_port *port, unsigned int state,
+			    unsigned int oldstate)
+{
+	switch (state) {
+	case 0:
+		/*
+		 * Enable clock for this serial port.
+		 * This is called on uart_open() or a resume event.
+		 */
+		owl_uart_module_enable(port->line);
+		break;
+	case 3:
+		/*
+		 * Disable clock for this serial port.
+		 * This is called on uart_close() or a suspend event.
+		 */
+		owl_uart_module_disable(port->line);
+		break;
+	default:
+		pr_err("owl_serial: unknown pm state: %d\n", state);
+	}
+}
+
+static struct uart_ops owl_uart_pops = {
+	.tx_empty = owl_tx_empty,
+	.set_mctrl = owl_set_mctrl,
+	.get_mctrl = owl_get_mctrl,
+	.stop_tx = owl_stop_tx,
+	.start_tx = owl_start_tx,
+	.stop_rx = owl_stop_rx,
+	.enable_ms = owl_enable_ms,
+	.break_ctl = owl_break_ctl,
+	.startup = owl_uart_dma_startup,
+	.shutdown = owl_uart_shutdown,
+	.set_termios = owl_set_termios,
+	.type = owl_uart_type,
+	.release_port = owl_release_port,
+	.request_port = owl_request_port,
+	.config_port = owl_config_port,
+	.verify_port = owl_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_get_char  = owl_poll_get_char,
+	.poll_put_char  = owl_poll_put_char,
+#endif
+	.pm = owl_uart_pm,
+};
+
+/*
+ * Configure the port from the platform device resource info.
+ */
+static int owl_init_uport(struct uart_port *uport,
+		struct platform_device *pdev)
+{
+	struct owl_uart_port *owl_uart_port = UART_TO_OWL_UART_PORT(uport);
+	struct resource *resource;
+
+	uport->type		= PORT_OWL;
+	uport->iotype   = UPIO_MEM;
+	uport->ops      = &owl_uart_pops;
+	uport->fifosize = 16;
+	uport->dev      = &pdev->dev;
+
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (unlikely(!resource)) {
+		dev_err(&pdev->dev, "No IO memory resource\n");
+		return -ENXIO;
+	}
+
+	uport->mapbase = resource->start;
+	uport->membase = (void __iomem *)IO_ADDRESS(uport->mapbase);
+	if (!uport->membase) {
+		dev_err(&pdev->dev, "memregion/iomap address req failed\n");
+		return -EADDRNOTAVAIL;
+	}
+
+	/*devm_clk_get() is not implemented yet in 3.4*/
+	/*    owl_uart_port->clk = devm_clk_get(&pdev->dev, NULL);*/
+	switch (uport->line) {
+	case 0:
+		owl_uart_port->clk = clk_get(NULL, CLKNAME_UART0_CLK);
+		break;
+	case 1:
+		owl_uart_port->clk = clk_get(NULL, CLKNAME_UART1_CLK);
+		break;
+	case 2:
+		owl_uart_port->clk = clk_get(NULL, CLKNAME_UART2_CLK);
+		break;
+	case 3:
+		owl_uart_port->clk = clk_get(NULL, CLKNAME_UART3_CLK);
+		break;
+	case 4:
+		owl_uart_port->clk = clk_get(NULL, CLKNAME_UART4_CLK);
+		break;
+	case 5:
+		owl_uart_port->clk = clk_get(NULL, CLKNAME_UART5_CLK);
+		break;
+	case 6:
+		owl_uart_port->clk = clk_get(NULL, CLKNAME_UART6_CLK);
+	default:
+		break;
+	}
+
+	if (IS_ERR(owl_uart_port->clk)) {
+		printk(KERN_ERR "%s(): cannot get clk for port %d\n",
+				__func__, pdev->id);
+		owl_uart_port->clk = NULL;
+		return -1;
+	}
+
+	strcpy(owl_uart_port->name, dev_name(&pdev->dev));
+
+	uport->irq = platform_get_irq(pdev, 0);
+	if (unlikely(uport->irq < 0))
+		return -ENXIO;
+
+	init_timer(&(owl_uart_port->rx_dma_timer));
+
+	return 0;
+}
+
+#ifdef CONFIG_SERIAL_OWL_CONSOLE
+static void owl_console_putchar(struct uart_port *port, int c)
+{
+	while (owl_read(port, UART_STAT) & UART_STAT_TFFU)
+		cpu_relax();
+	owl_write(port, c, UART_TXDAT);
+}
+
+static void owl_console_write(struct console *co, const char *s,
+		unsigned int count)
+{
+	struct uart_port *port;
+	unsigned long flags;
+	unsigned int old_ctl, data;
+
+	BUG_ON(co->index < 0 || co->index >= OWL_MAX_UART);
+
+	port = get_port_from_line(co->index);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* backup old control register */
+	old_ctl = owl_read(port, UART_CTL);
+
+	/* disable IRQ */
+	data = old_ctl | UART_CTL_TRFS_TX;
+	data &= ~(UART_CTL_TXIE | UART_CTL_RXIE);
+	owl_write(port, data, UART_CTL);
+
+	uart_console_write(port, s, count, owl_console_putchar);
+
+	/* wait until all content have been sent out */
+	while (owl_read(port, UART_STAT) & UART_STAT_TRFL_MASK)
+		;
+
+	/* clear IRQ pending */
+	data = owl_read(port, UART_STAT);
+	data |= UART_STAT_TIP | UART_STAT_RIP;
+	owl_write(port, data, UART_STAT);
+
+	/* restore old ctl */
+	owl_write(port, old_ctl, UART_CTL);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int __init owl_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (unlikely(co->index >= OWL_MAX_UART || co->index < 0))
+		return -ENXIO;
+
+	port = get_port_from_line(co->index);
+
+	if (unlikely(!port->membase))
+		return -ENXIO;
+
+	port->cons = co;
+    
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+#ifdef OWL_CONSOLE_KEEP_ON
+	owl_console_port = port->line;
+	printk(KERN_INFO "owl_serial: console setup on port #%d\n",
+			owl_console_port);
+#endif
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver owl_uart_driver;
+
+static struct console owl_console = {
+	.name = "ttyS",
+	.write = owl_console_write,
+	.device = uart_console_device,
+	.setup = owl_console_setup,
+	.flags = CON_PRINTBUFFER,
+	.index = -1,
+	.data = &owl_uart_driver,
+};
+/*
+   static int __init owl_uart_console_init(void)
+   {
+   register_console(&owl_console);
+   return 0;
+   }
+   console_initcall(owl_uart_console_init);
+   */
+#define OWL_CONSOLE	(&owl_console)
+#else
+#define OWL_CONSOLE	NULL
+#endif
+
+static struct uart_driver owl_uart_driver = {
+	.owner = THIS_MODULE,
+	.driver_name = "owl_serial",
+	.dev_name = "ttyS",
+	.nr = OWL_MAX_UART,
+	.cons = OWL_CONSOLE,
+	.major = OWL_SERIAL_MAJOR,
+	.minor = OWL_SERIAL_MINOR,
+};
+
+static struct of_device_id owl_uart_of_match[] = {
+	{.compatible = "actions,owl-uart",},
+	{},
+};
+MODULE_DEVICE_TABLE(of, owl_uart_of_match);
+
+static struct uart_port *owl_serial_parse_dt(struct platform_device *pdev)
+{
+	struct owl_uart_port *owl_uart_port;
+	struct uart_port *uport;
+	struct device_node *np = pdev->dev.of_node;
+	int line;
+
+	if (!of_device_is_compatible(np, "actions,owl-uart")) {
+		printk("owl_uart: no device is found\n");
+		return NULL;
+	}
+
+	line = of_alias_get_id(np, "serial");
+	if (line < 0) {
+		printk("failed to get alias id, err = %d\n", line);
+		return NULL;
+	}
+
+	owl_uart_port = &owl_uart_ports[line];
+	owl_uart_port->uart.line = line;
+
+	owl_uart_port->enable_dma_rx = of_property_read_bool(np,
+			"actions,enable-dma-rx");
+	owl_uart_port->enable_dma_tx = of_property_read_bool(np,
+			"actions,enable-dma-tx");
+
+	uport = &(owl_uart_port->uart);
+	return uport;
+}
+
+
+int uart_pinctrl_request(struct owl_serial_state *state,
+		struct platform_device *pdev)
+{
+	state->p = pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(state->p)) {
+		printk("failed to get pinctrl\n");
+		return PTR_ERR(state->p);
+	}
+	state->refcount++;
+	return 0;
+}
+
+int sdio_uart_pinctrl_request(void)
+{
+	return uart_pinctrl_request(sdio_serial_state, g_pdev);
+}
+EXPORT_SYMBOL(sdio_uart_pinctrl_request);
+
+void sdio_uart_pinctrl_free(void)
+{
+	if(sdio_serial_state && sdio_serial_state->refcount > 0) {
+		sdio_serial_state->refcount--;
+		pinctrl_put(sdio_serial_state->p);
+	}
+}
+EXPORT_SYMBOL(sdio_uart_pinctrl_free);
+
+static int owl_serial_pinctrl(struct platform_device *pdev)
+{
+	struct owl_serial_state *serial_state;
+	int ret;
+
+	if (of_find_property(pdev->dev.of_node, "sdio_uart_supported", NULL)) {
+		g_pdev = pdev;
+
+		sdio_serial_state = kzalloc(sizeof(struct owl_serial_state),
+				GFP_KERNEL);
+		if (!sdio_serial_state) {
+			printk("failed to alloc owl_serial_state\n");
+			return -ENOMEM;
+		}
+
+		//platform_driver_probe\D2Ѿ\AD\B5\F7\C1\CBһ\B4\CEpinctrl_get\A3\AC\D5\E2\C0\EF\B5\F7\D3ý\F6\CAǻ\F1ȡpinctrl\B5\C4ָ\D5\EB
+		ret = uart_pinctrl_request(sdio_serial_state, g_pdev);
+		if (ret < 0) {
+			printk("failed to request sdio uart pinctrl\n");
+			kfree(sdio_serial_state);
+			return -ENOMEM;
+		}
+		//\D5\E2\C0\EF\D6\F7\B6\AF\CAͷŵ\F4\B6\E0\D3\E0\B5\C4һ\B4\CE\D2\FD\D3\C3
+		pinctrl_put(sdio_serial_state->p);
+	} else {
+		serial_state =
+			kzalloc(sizeof(struct owl_serial_state), GFP_KERNEL);
+		if (!serial_state) {
+			printk("failed to alloc owl_serial_state\n");
+			return -ENOMEM;
+		}
+
+		//platform_driver_probe\D2Ѿ\AD\B5\F7\C1\CBһ\B4\CEpinctrl_get\A3\AC\D5\E2\C0\EF\B5\F7\D3ý\F6\CA\C7\C5ж\CF\CAǷ\F1\C4\DC\D5\FDȷ\BB\F1ȡpin
+		ret = uart_pinctrl_request(serial_state, pdev);
+		if (ret < 0) {
+			kfree(serial_state);
+			return -ENOMEM;
+		}
+		//\D5\E2\C0\EF\D6\F7\B6\AF\B5\F7\D3\C3pinctrl_put\CAͷŵ\F4\B6\E0\D3\E0\B5\C4һ\B4\CE\D2\FD\D3\C3
+		pinctrl_put(serial_state->p);
+		kfree(serial_state);
+	}
+
+	return 0;
+}
+
+static int __init owl_serial_probe(struct platform_device *pdev)
+{
+	struct uart_port *uport;
+	int ret;
+
+	uport = owl_serial_parse_dt(pdev);
+	if (NULL == uport)
+		return -ENODEV;
+
+	/*pinctrl may be fialed, but will not stop the probe*/
+	ret = owl_serial_pinctrl(pdev);
+	if (ret < 0)
+		printk("failed to set serial pin mux\n");
+
+	ret = owl_init_uport(uport, pdev);
+	if (ret) {
+		printk("owl_init_uport failed\n");
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, uport);
+
+	ret = uart_add_one_port(&owl_uart_driver, uport);
+	if (ret) {
+		printk("failed to add uart port, err = %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int owl_serial_remove(struct platform_device *pdev)
+{
+	struct uart_port *port = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	device_init_wakeup(&pdev->dev, 0);
+	platform_set_drvdata(pdev, NULL);
+
+	ret = uart_remove_one_port(&owl_uart_driver, port);
+
+	/* "port" is allocated statically, so we shouldn't free it */
+
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int owl_uart_suspend(struct device *dev)
+{
+	struct owl_uart_port *owl_uart_port = dev_get_drvdata(dev);
+	struct uart_port *uport = &owl_uart_port->uart;
+
+	if(uport->line == owl_console_port)	//console always on
+		return 0;
+
+	disable_irq(owl_uart_port->uart.irq);
+	return uart_suspend_port(&owl_uart_driver, uport);
+}
+
+static int owl_uart_resume(struct device *dev)
+{
+	struct owl_uart_port *owl_uart_port = dev_get_drvdata(dev);
+	struct uart_port *uport = &owl_uart_port->uart;
+
+	if(uport->line == owl_console_port)	//console always on
+		return 0;
+
+	enable_irq(owl_uart_port->uart.irq);
+	return uart_resume_port(&owl_uart_driver, uport);
+}
+#endif
+
+static const struct dev_pm_ops owl_uart_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(owl_uart_suspend, owl_uart_resume)
+};
+
+static struct platform_driver owl_platform_driver = {
+	.remove = owl_serial_remove,
+	.driver = {
+		.name   = "owl-serial",
+		.owner  = THIS_MODULE,
+		.of_match_table = owl_uart_of_match,
+		.pm = &owl_uart_pm_ops,
+	},
+};
+
+static int __init owl_serial_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&owl_uart_driver);
+	if (unlikely(ret)) {
+		printk("Could not register %s driver\n",
+				owl_uart_driver.driver_name);
+		return ret;
+	}
+
+	ret = platform_driver_probe(&owl_platform_driver, owl_serial_probe);
+	if (unlikely(ret)) {
+		printk("Uart platform driver register failed, err=%d\n",
+				ret);
+		uart_unregister_driver(&owl_uart_driver);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit owl_serial_exit(void)
+{
+	platform_driver_unregister(&owl_platform_driver);
+	uart_unregister_driver(&owl_uart_driver);
+}
+
+module_init(owl_serial_init);
+module_exit(owl_serial_exit);
+
+MODULE_AUTHOR("Actions Semi Inc.");
+MODULE_DESCRIPTION("serial driver for Actions SOC");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-owl/sirq-owl.c b/arch/arm/mach-owl/sirq-owl.c
new file mode 100755
index 0000000..a7766ff
--- /dev/null
+++ b/arch/arm/mach-owl/sirq-owl.c
@@ -0,0 +1,282 @@
+/*
+ * arch/arm/mach-owl/sirq.c
+ *
+ * special external IRQs support for Actions SOC
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/irqdomain.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/of_device.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+/*#include <mach/gl5202_cmu.h>*/
+
+/* INTC_EXTCTL */
+#define INTC_EXTCTL_E0EN            (0x1 << 21)
+#define INTC_EXTCTL_E0PD            (0x1 << 16)
+#define INTC_EXTCTL_E1EN            (0x1 << 13)
+#define INTC_EXTCTL_E1PD            (0x1 << 8)
+#define INTC_EXTCTL_E2EN            (0x1 << 5)
+#define INTC_EXTCTL_E2PD            (0x1 << 0)
+
+#define INTC_EXTCTL_ETYPE(x)    (22-x*8)
+
+#define EXT_INT_TYPE_MASK           0x3
+#define EXT_INT_TYPE_HIGH           0x0
+#define EXT_INT_TYPE_LOW            0x1
+#define EXT_INT_TYPE_RISING         0x2
+#define EXT_INT_TYPE_FALLING        0x3
+
+#define PAD_PULLCTL0_PSIRQP(x)     (14-x*2)
+
+static struct irq_domain *owl_sirq_irq_domain;
+
+struct owl_sirq_bank {
+	int irq;
+};
+static struct owl_sirq_bank owl_sirq_bank[NR_OWL_SIRQ_IRQS];
+
+static void owl_sirq_enable(struct irq_data *data)
+{
+	unsigned int hwirq = data->hwirq;
+    
+	switch (hwirq) {
+	case 0:
+		act_writel(act_readl(INTC_EXTCTL) | INTC_EXTCTL_E0EN,
+			INTC_EXTCTL);
+		break;
+	case 1:
+		act_writel(act_readl(INTC_EXTCTL) | INTC_EXTCTL_E1EN,
+			INTC_EXTCTL);
+		break;
+	case 2:
+		act_writel(act_readl(INTC_EXTCTL) | INTC_EXTCTL_E2EN,
+			INTC_EXTCTL);
+		break;
+	default:
+		break;
+	}
+}
+
+static void owl_sirq_disable(struct irq_data *data)
+{
+	unsigned int hwirq = data->hwirq;
+
+	switch (hwirq) {
+	case 0:
+		act_writel(act_readl(INTC_EXTCTL) & (~INTC_EXTCTL_E0EN),
+			INTC_EXTCTL);
+		break;
+	case 1:
+		act_writel(act_readl(INTC_EXTCTL) & (~INTC_EXTCTL_E1EN),
+			INTC_EXTCTL);
+		break;
+	case 2:
+		act_writel(act_readl(INTC_EXTCTL) & (~INTC_EXTCTL_E2EN),
+			INTC_EXTCTL);
+		break;
+	default:
+		break;
+	}
+}
+
+static int owl_sirq_set_type(struct irq_data *data, unsigned int flow_type)
+{
+	unsigned int regv, type, offset;
+
+	unsigned int hwirq = data->hwirq;
+	flow_type &= IRQ_TYPE_SENSE_MASK;
+	offset = hwirq;
+
+	switch (flow_type) {
+	case IRQ_TYPE_EDGE_RISING:
+		type = EXT_INT_TYPE_RISING;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		type = EXT_INT_TYPE_FALLING;
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		type = EXT_INT_TYPE_HIGH;
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		type = EXT_INT_TYPE_LOW;
+		break;
+	default:
+	pr_err("[SIRQ] %s: hwirq %d, unknow type %d\n",
+		__func__, hwirq, flow_type);
+	return -1;
+	}
+
+	regv = act_readl(INTC_EXTCTL);
+	regv &= ~(0x3<<INTC_EXTCTL_ETYPE(offset));
+	regv |= type<<INTC_EXTCTL_ETYPE(offset);
+	act_writel(regv, INTC_EXTCTL);
+
+	regv = act_readl(PAD_PULLCTL0);
+	regv &= ~(0x3<<PAD_PULLCTL0_PSIRQP(offset));
+	if ((flow_type == IRQ_TYPE_LEVEL_HIGH) ||
+			(flow_type == IRQ_TYPE_EDGE_RISING))
+		/* 100K pull-up disable and 100K pull-down enable */
+		regv |= 0x2<<PAD_PULLCTL0_PSIRQP(offset);
+	if ((flow_type == IRQ_TYPE_LEVEL_LOW) ||
+			(flow_type == IRQ_TYPE_EDGE_FALLING))
+		/* 100K pull-up enable and 100K pull-down disable */
+		regv |= 0x1<<PAD_PULLCTL0_PSIRQP(offset);
+	act_writel(regv, PAD_PULLCTL0);
+
+	return 0;
+}
+
+static struct irq_chip owl_sirq_irq = {
+	.name = "owl_sirq_irq",
+	.irq_ack = owl_sirq_disable,
+	.irq_mask = owl_sirq_disable,
+	.irq_mask_ack = owl_sirq_disable,
+	.irq_unmask = owl_sirq_enable,
+	.irq_set_type = owl_sirq_set_type,
+};
+
+static void owl_sirq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned int pending, casc_irq;
+	struct irq_chip *chip = irq_get_chip(irq);
+
+	pending = act_readl(INTC_EXTCTL);
+	casc_irq = -1;
+
+	if(irq == owl_sirq_bank[0].irq) {
+		if (pending & INTC_EXTCTL_E0PD) {
+		    casc_irq = irq_find_mapping(owl_sirq_irq_domain, 0);
+			/* don't clear other sirq pending */
+			pending &= ~(INTC_EXTCTL_E1PD | INTC_EXTCTL_E2PD);
+		}
+	}
+	else if(irq == owl_sirq_bank[1].irq) {
+		if (pending & INTC_EXTCTL_E1PD) {
+		    casc_irq = irq_find_mapping(owl_sirq_irq_domain, 1);
+			/* don't clear other sirq pending */
+			pending &= ~(INTC_EXTCTL_E0PD | INTC_EXTCTL_E2PD);
+		}
+	}
+	else if(irq == owl_sirq_bank[2].irq) {
+		if (pending & INTC_EXTCTL_E2PD) {
+		    casc_irq = irq_find_mapping(owl_sirq_irq_domain, 2);
+			/* don't clear other sirq pending */
+			pending &= ~(INTC_EXTCTL_E0PD | INTC_EXTCTL_E1PD);
+		}
+	}
+	else {
+		printk(KERN_INFO "[SIRQ] %s(): invalid virtual sirq number %d\n",
+			__func__, irq);
+		return;
+	}
+
+	/* clear pending */
+	act_writel(pending, INTC_EXTCTL);
+	if(casc_irq >= 0)
+		generic_handle_irq(casc_irq);
+
+	if (chip->irq_ack)
+		chip->irq_ack(&desc->irq_data);
+	if (chip->irq_eoi)
+		chip->irq_eoi(&desc->irq_data);
+
+	chip->irq_unmask(&desc->irq_data);
+}
+
+static int owl_sirq_irq_map(struct irq_domain *d, unsigned int virq,
+				irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(virq, &owl_sirq_irq, handle_simple_irq);
+	set_irq_flags(virq, IRQF_VALID);
+	irq_set_chained_handler(owl_sirq_bank[hwirq].irq, owl_sirq_handler);
+    printk("sirq map %d -> %d\n", owl_sirq_bank[hwirq].irq, virq);
+	return 0;
+}
+
+static struct irq_domain_ops owl_sirq_irq_ops = {
+	.map    = owl_sirq_irq_map,
+	.xlate  = irq_domain_xlate_twocell,
+};
+
+
+static struct of_device_id owl_sirq_of_match[] = {
+	{ .compatible = "actions,owl-sirq" },
+	{ },
+};
+
+static int owl_sirq_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int i, irq;
+
+	printk(KERN_INFO "owl_sirq_probe()\n");
+
+	for (i = 0; i < NR_OWL_SIRQ_IRQS; i++) {
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, i);
+		if (res) {
+			owl_sirq_bank[i].irq = res->start;
+			printk(KERN_INFO "owl sirq bank%d - irq%d\n",
+					i, res->start);
+		} else {
+			printk(KERN_INFO "owl gpio bank%d Missing IRQ resource\n"
+					, i);
+			owl_sirq_bank[i].irq = (OWL_IRQ_SIRQ0 + i);
+		}
+	}
+	
+	owl_sirq_irq_domain = irq_domain_add_linear(pdev->dev.of_node,
+					   NR_OWL_SIRQ_IRQS, &owl_sirq_irq_ops, NULL);
+
+	if (!owl_sirq_irq_domain)
+	{
+    	pr_err("[SIRQ] %s: irq_domain_add_linear failed!\n", __func__);
+		return -ENODEV;
+	}
+
+	for (i = 0; i < NR_OWL_SIRQ_IRQS; ++i) {
+		irq = irq_create_mapping(owl_sirq_irq_domain, i);
+	}
+
+	return 0;
+}
+
+
+static struct platform_driver owl_sirq_driver = {
+	.driver		= {
+		.name	= "owl-sirq",
+		.owner	= THIS_MODULE,
+		.of_match_table = owl_sirq_of_match,
+	},
+	.probe		= owl_sirq_probe,
+};
+
+
+int __init owl_sirq_init(void)
+{
+	printk(KERN_INFO "init sirqs\n");
+
+	return platform_driver_register(&owl_sirq_driver);
+
+}
+
+postcore_initcall(owl_sirq_init);
diff --git a/arch/arm/mach-owl/sleep-owl.S b/arch/arm/mach-owl/sleep-owl.S
new file mode 100755
index 0000000..319dc85
--- /dev/null
+++ b/arch/arm/mach-owl/sleep-owl.S
@@ -0,0 +1,533 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2013 Actions Semi Inc.
+*/
+/******************************************************************************/
+#include <mach/hardware.h>
+#include <asm/memory.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/asm-offsets.h>
+#include <asm/assembler.h>
+#include <linux/linkage.h>
+#include <linux/threads.h>
+
+/* note : DO NOT print before MMU_OFF */
+#define DBG_STAGE_PRINT_MMU_OFF         52  /* '4' */
+#define DBG_STAGE_PRINT_DDR_CH0_DWN     51  /* '3' */
+#define DBG_STAGE_PRINT_DDR_CH1_DWN     50  /* '2' */
+#define DBG_STAGE_PRINT_SWITCH_HOSC     49  /* '1' */
+#define DBG_STAGE_PRINT_PMU_CLR_S1      48  /* '0' */
+
+	.pushsection .sram.text, "ax"
+
+ENTRY(owl_finish_suspend)
+	ldr sp, =0xffff8FF0
+	stmfd sp!, {lr}
+	b _temp_arg_pool_end
+
+	/* tmp stack */ 
+_temp_arg_pool:
+    .word   0
+    .word   0
+    .word   0
+    .word   0
+_temp_arg_pool_end:
+	/* save arguments */
+	adrl    r12, _temp_arg_pool
+	stmia   r12, {r0-r3}
+
+	/* switch jtag */
+	ldr r0, =IO_ADDRESS(0xb01b0044)
+	ldr r1, =0x26000000
+	str r1, [r0]
+
+	bl  leopard_clean_dcache_all
+
+	/*
+	 * Clean & invalid L2 cache, and sync L2 cache.
+	 */
+	ldr  r0, =IO_ADDRESS(OWL_PA_L2CC)
+	ldr  r1, =0x0000ffff
+	str  r1, [r0, #L2X0_CLEAN_INV_WAY]
+wait:
+	ldr  r2, [r0, #L2X0_CLEAN_INV_WAY]
+	cmp  r2, #0
+	bne  wait
+
+	ldr  r1, =0x0
+	str  r1, [r0, #L2X0_CACHE_SYNC]
+sync:
+	ldr  r1, [r0, #L2X0_CACHE_SYNC]
+	ands r1, r1, #0x1
+	bne  sync
+
+	bl leopard_flush_dcache_all
+
+	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
+	bic	r0, r0, #0x1000			@ ...i............
+	bic	r0, r0, #0x0006			@ .............ca.
+	bic	r0, r0, #0x1
+	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
+	nop
+	nop
+
+	mov r0, #0x4000
+delay_mmu_off:
+	subs r0, r0, #1
+	bne delay_mmu_off
+	mov r0, #DBG_STAGE_PRINT_MMU_OFF
+	bl print_char
+
+	ldr r1, =0xB01C0004
+	mov r0, #3
+	str r0, [r1] /* SLEEP */
+
+	mov r0, #0x4000
+delay_ch0_lp:
+	subs r0, r0, #1
+	bne delay_ch0_lp
+
+	/* wait ch0 to LP, maximum retry 0x1000 times */
+	mov r3, #0x1000
+	ldr r1, =0xB01C0008
+	mov r2, #0x45
+wait_ch0:
+	ldr r0, [r1]
+	subs r3, r3, #1
+	beq wait_ch0_end
+	cmp r0, r2
+	nop
+	nop
+	bne wait_ch0
+wait_ch0_end:
+	mov r0, #0
+	cmp r0, r3
+	bne ch0_ok
+	mov r0, #DBG_STAGE_PRINT_DDR_CH0_DWN
+	bl print_char
+ch0_ok:
+
+//	ldr r1, =0xb01b00e0
+//	ldr r0, [r1]
+//	and r0, r0, #0xf
+//	mov r1, #0xf
+//	cmp r0, r1
+//	beq vdd_is_disable
+//
+//	ldr r1, =0xB01D0004
+//	mov r0, #3
+//	str r0, [r1] /* SLEEP */
+//
+//	mov r0, #0x4000
+//delay_ch1_lp:
+//	subs r0, r0, #1
+//	bne delay_ch1_lp
+//
+//	/* wait ch1 to LP, maximum retry 0x1000 times */
+//	mov r3, #0x1000
+//	ldr r1, =0xB01D0008
+//	mov r2, #0x45
+//wait_ch1:
+//	ldr r0, [r1]
+//	subs r3, r3, #1
+//	beq wait_ch1_end
+//	cmp r0, r2
+//	nop
+//	nop
+//	bne wait_ch1
+//wait_ch1_end:
+//	mov r0, #0
+//	cmp r0, r3
+//	bne ch1_ok
+//	mov r0, #DBG_STAGE_PRINT_DDR_CH1_DWN
+//	bl print_char
+//ch1_ok:
+
+
+
+vdd_is_disable:
+
+operate_ddr_pad_zhong:		//add by zhongxu for vddq down
+	ldr r0,=0xb01c8024
+	//ldr r1,=0x33fc3c1a
+	ldr r1,=0x1bfc3c18
+	str r1,[r0]
+  
+	ldr r0,=0xb01c8028
+	ldr r1,=0x0000080c
+	str r1,[r0] 
+  
+	ldr r0,=0xb01c802c
+	//ldr r1,=0xc4fc001f
+	//ldr r1,=0xc5fc001f 
+	//ldr r1,=0xc5fc1817 
+	//ldr r1,=0xc5f01817 
+	ldr r1,=0xc5fc0000
+	//ldr r1,=0xf2f0001f 
+	str r1,[r0]  
+
+	mov r0, #0x4000
+delay_ch0_lp_zhong:
+	subs r0, r0, #1
+	bne delay_ch0_lp_zhong
+
+
+
+	ldr r1, =0xB0290000
+	ldr r0, [r1]
+	orr r0, r0, #(1 << 1)
+	str r0, [r1]
+
+	mov r3, #0x30 @timeout
+	mov r4, #0
+wait_delay:
+	sub r3, r3, #0x1
+	cmp r3, r4
+	bne wait_delay
+
+	ldr r0, [r1]
+	ldr r3,=0xefffffff
+	and r0, r0, r3
+	str r0, [r1]
+	
+	mov r3, #0x30 @timeout
+	mov r4, #0
+wait_delay1:
+	sub r3, r3, #0x1
+	cmp r3, r4
+	bne wait_delay1
+
+	ldr r0, [r1]
+	orr r0, r0, #(1 << 28)
+	str r0, [r1]
+
+	mov r3, #0x30 @timeout
+	mov r4, #0
+wait_delay2:
+	sub r3, r3, #0x1
+	cmp r3, r4
+	bne wait_delay2
+
+
+	/* switch corepll to hosc! */
+	ldr r0, =CMU_BASE
+	ldr r1, [r0, #0x1c] @ load CMU_BUSCLK
+	bic r1, r1, #0x3    @ clear bit[1:0]
+	orr r1, r1, #0x1
+	str r1, [r0, #0x1c]
+	nop
+	nop
+	nop
+	nop
+
+	mov r0, #0x4000
+delay_switch_hosc:
+	subs r0, r0, #1
+	bne delay_switch_hosc
+	mov r0, #DBG_STAGE_PRINT_SWITCH_HOSC
+	bl print_char
+
+	/*---------------------------------------------*/
+	/* restore arguments */
+	adrl    r0, _temp_arg_pool
+	ldmia   r0, {r4-r7}
+	/* r4 :  cpu_type
+	 * r5 :  bus_iobase
+	 * r6 :  pmic_bus_addr
+	 * r7 :  pmic_type      */
+
+	ldr r0, =SPI0_BASE
+	cmp r5, r0
+	blo i2c_pmic_enter_s2
+	ldr r1, =SPI3_BASE
+	cmp r5, r1
+	bhi i2c_pmic_enter_s2
+
+	/*---------------------------------------------*/
+spi_pmic_enter_s2:
+	/* reset spi module */
+reset_spi:
+	mov r0, r5    @Load SPI1 Control base address
+	ldr r4, =0x0
+	ldr r3, =0x30 @timeout 2us at 24M clk
+
+	ldr r2, =0xd0
+	str r2, [r0]
+
+	/* delay 2us */
+wait_for_reset:
+	sub r3, r3, #0x1
+	cmp r3, r4
+	bne wait_for_reset
+
+	ldr  r2, =0x401d0
+	str  r2, [r0]
+
+	/* start transfer */
+	ldr r3, =0x1d4c0      @timeout 5ms at 24M clk
+	/* enter to S2 state */
+	mov r0, r5           @Load SPI1 Control base address
+	ldr r1, =0x30
+	str r1, [r0, #0x8]   @clear SPI FIFO
+
+	ldr r1, =0x401c0
+	str r1, [r0]         @16bit mode 3,SPI CS- low
+
+	ldr r1, =0x8008      @(1 << 3) | 0x8000
+	str r1, [r0, #0x10]  @write atc2603_PMU_SYS_CTL1 register number
+
+wait_for_spi:
+	subs  r3, r3, #0x1
+	beq  reset_spi
+
+	ldr r1, [r0, #0x8]
+	ands r1, r1, #0x4
+	beq  wait_for_spi
+	nop
+
+	ldr r1, [r0, #0x8]  @clear Transfer Complete Bit
+	str r1, [r0, #0x8]
+
+	ldr r1, =0x30
+	str r1, [r0, #0x8] @clear SPI FIFO
+
+	ldr r3, =0x1d4c0      @timeout 5ms at 24M clk
+	ldr r1, =0x16         @write reg value
+	str r1, [r0, #0x10]
+
+wait_for_spi_1:
+	subs  r3, r3, #0x1
+	beq  reset_spi
+
+	ldr r1, [r0, #0x8]
+	ands r1, r1, #0x4
+	beq  wait_for_spi_1
+	nop
+
+	ldr r1, [r0, #0x8]  @clear Transfer Complete Bit
+	str r1, [r0, #0x8]
+	ldr r1, =0x30
+	str r1, [r0, #0x8] @clear SPI FIFO
+
+	ldr r1, =0x401d0
+	str r1, [r0]         @16bit mode 3,SPI CS- high
+	nop
+	nop
+	nop
+	nop
+
+wait_for_spi_2:
+	mov r0, #DBG_STAGE_PRINT_PMU_CLR_S1
+	bl print_char
+	b   wait_for_spi_2
+
+	/*---------------------------------------------*/
+i2c_pmic_enter_s2:
+	/* reset i2c0 module */
+	/*check clock source & pll*/
+
+reset_i2c:
+	mov r0, r5
+	ldr r4, =0x0
+	ldr r3, =0x30 @timeout 2us at 24M clk
+
+	ldr r2, =0x00
+	str r2, [r0]
+
+	/* delay 2us */
+wait_for_i2c_reset:
+	sub r3, r3, #0x1
+	cmp r3, r4
+	bne wait_for_i2c_reset
+
+	/*enable i2c and pull-up resistor.*/
+	ldr  r2, =0xc0
+	str  r2, [r0]
+	
+	/*set data cnt*/
+	ldr r2, =0x02
+	str r2, [r0, #0x24]
+	
+	/*set slave address*/
+	mov r2, r6, LSL #1
+	str r2, [r0, #0x10]
+	
+	/*set reg address, PMU_SYS_CTL1 (same for 5307 & 5303)*/
+	ldr r2, =0x01
+	str r2, [r0, #0x10]
+	
+	/*set data, high bytes*/
+	ldr r2, =0x00
+	str r2, [r0, #0x10]
+	
+	/*set data, low bytes*/
+	ldr r2, =0x16
+	str r2, [r0, #0x10]
+	
+	/*write send cmd*/
+	ldr r2, =0x8d05
+	str r2, [r0, #0x18]
+
+	ldr r3, =0x1d4c0      @timeout 5ms at 24M clk
+wait_for_i2c_1:
+	subs  r3, r3, #0x1
+	beq  reset_i2c
+	/*check fifo status, CECB, wait i2c transfer finish.*/
+	ldr r1, [r0, #0x20]
+	ands r1, r1, #0x1
+	beq  wait_for_i2c_1
+	nop
+	
+	/*disable i2c0*/
+	ldr r1, =0x0;
+	str r1, [r0]
+	nop
+	nop
+	nop
+	nop
+
+wait_for_i2c_2:
+	mov r0, #DBG_STAGE_PRINT_PMU_CLR_S1
+	bl print_char
+	b   wait_for_i2c_2
+ENDPROC(owl_finish_suspend)
+
+ENTRY(print_char)
+	/* check clock before doing any thing! */
+	ldr r1, =0xb0160000
+	ldr r2, [r1, #0xa4]
+//	tst r2, #0x100             /* uart2, bit 21 */
+	tst r2, #0x200000          /* uart5, bit 21 */
+	beq 24f
+//	ldr r1, =0xb0124000        /* uart 2 */
+	ldr r1, =0xb012a000        /* uart 5 */
+	/* only test fifo_full bit, it will be 0 in most state,
+	 * and will not cause hang up here.
+	 * DO NOT test fifo_empty bit! */
+14:	ldr r2, [r1, #0xc]
+	tst r2, #0x200             @ TXFIFO Full?
+	bne 14b
+	str r0, [r1, #8]
+24:	mov	pc, lr
+ENDPROC(print_char)
+
+ENTRY(owl_cpu_resume)
+	/* goto cpu_resume */
+	b       cpu_resume
+ENDPROC(owl_cpu_resume)
+
+ENTRY(leopard_flush_dcache_all)
+	dmb
+	mrc p15, 1, r0, c0, c0, 1   @ read clidr
+	ands r3, r0, #0x7000000     @ extract loc from clidr
+	mov r3, r3, lsr #23         @ left align loc bit field
+	beq finished                @ if loc is 0, then no need to clean
+	mov r10, #0                 @ start clean at cache level 0
+loop1:
+	add r2, r10, r10, lsr #1    @ work out 3x current cache level
+	mov r1, r0, lsr r2          @ extract cache type bits from clidr
+	and r1, r1, #7              @ mask of the bits for current cache only
+	cmp r1, #2                  @ see what cache we have at this level
+	blt skip                    @ skip if no cache, or just i-cache
+#ifdef CONFIG_PREEMPT
+	save_and_disable_irqs_notrace r9  @ make cssr&csidr read atomic
+#endif
+	mcr p15, 2, r10, c0, c0, 0        @ select current cache level in cssr
+	isb                               @ isb to sych the new cssr&csidr
+	mrc p15, 1, r1, c0, c0, 0         @ read the new csidr
+#ifdef CONFIG_PREEMPT
+	restore_irqs_notrace r9
+#endif
+	and r2, r1, #7                @ extract the length of the cache lines
+	add r2, r2, #4                @ add 4 (line length offset)
+	ldr r4, =0x3ff
+	ands r4, r4, r1, lsr #3       @ find maximum number on the way size
+	clz r5, r4                    @ find bit position of way size increment
+	ldr	r7, =0x7fff
+	ands r7, r7, r1, lsr #13      @ extract max number of the index size
+loop2:
+	mov r9, r4                    @ create working copy of max way size
+loop3:
+ ARM(   orr r11, r10, r9, lsl r5   )  @ factor way and cache number into r11
+ THUMB( lsl r6, r9, r5  )
+ THUMB( orr r11, r10, r6  )           @ factor way and cache number into r11
+ ARM(   orr r11, r11, r7, lsl r2   )  @ factor index number into r11
+ THUMB( lsl r6, r7, r2    )
+ THUMB( orr r11, r11, r6    )         @ factor index number into r11
+	mcr p15, 0, r11, c7, c14, 2       @ clean & invalidate by set/way
+	subs r9, r9, #1                   @ decrement the way
+	bge	loop3
+	subs r7, r7, #1                   @ decrement the index
+	bge	loop2
+skip:
+	add r10, r10, #2                  @ increment cache number
+	cmp r3, r10
+	bgt loop1
+finished:
+	mov r10, #0                       @ swith back to cache level 0
+	mcr p15, 2, r10, c0, c0, 0        @ select current cache level in cssr
+	dsb
+	isb
+	mov	pc, lr
+ENDPROC(leopard_flush_dcache_all)
+
+
+ENTRY(leopard_clean_dcache_all)
+	dmb
+	mrc p15, 1, r0, c0, c0, 1     @ read clidr
+	ands r3, r0, #0x7000000       @ extract loc from clidr
+	mov r3, r3, lsr #23           @ left align loc bit field
+	beq finished_                 @ if loc is 0, then no need to clean
+	mov r10, #0                   @ start clean at cache level 0
+loop1_:
+	add r2, r10, r10, lsr #1      @ work out 3x current cache level
+	mov r1, r0, lsr r2            @ extract cache type bits from clidr
+	and r1, r1, #7                @ mask of the bits for current cache only
+	cmp r1, #2                    @ see what cache we have at this level
+	blt skip_                     @ skip if no cache, or just i-cache
+#ifdef CONFIG_PREEMPT
+	save_and_disable_irqs_notrace r9 @ make cssr&csidr read atomic
+#endif
+	mcr p15, 2, r10, c0, c0, 0       @ select current cache level in cssr
+	isb                              @ isb to sych the new cssr&csidr
+	mrc p15, 1, r1, c0, c0, 0        @ read the new csidr
+#ifdef CONFIG_PREEMPT
+	restore_irqs_notrace r9
+#endif
+	and r2, r1, #7                @ extract the length of the cache lines
+	add r2, r2, #4                @ add 4 (line length offset)
+	ldr r4, =0x3ff
+	ands r4, r4, r1, lsr #3       @ find maximum number on the way size
+	clz r5, r4                    @ find bit position of way size increment
+	ldr r7, =0x7fff
+	ands r7, r7, r1, lsr #13      @ extract max number of the index size
+loop2_:
+	mov r9, r4                    @ create working copy of max way size
+loop3_:
+ ARM(   orr r11, r10, r9, lsl r5    )   @ factor way and cache number into r11
+ THUMB( lsl r6, r9, r5    )
+ THUMB( orr r11, r10, r6    )           @ factor way and cache number into r11
+ ARM(   orr r11, r11, r7, lsl r2    )   @ factor index number into r11
+ THUMB( lsl	r6, r7, r2    )
+ THUMB( orr	r11, r11, r6    )           @ factor index number into r11
+	mcr p15, 0, r11, c7, c10, 2         @ clean & invalidate by set/way
+	subs r9, r9, #1                     @ decrement the way
+	bge loop3_
+	subs r7, r7, #1                     @ decrement the index
+	bge	loop2_
+skip_:
+	add r10, r10, #2                    @ increment cache number
+	cmp r3, r10
+	bgt loop1_
+finished_:
+	mov r10, #0                         @ swith back to cache level 0
+	mcr p15, 2, r10, c0, c0, 0          @ select current cache level in cssr
+	dsb
+	isb
+	mov	pc, lr
+ENDPROC(leopard_clean_dcache_all)
+
+	.popsection
diff --git a/arch/arm/mach-owl/swsusp-owl.S b/arch/arm/mach-owl/swsusp-owl.S
new file mode 100755
index 0000000..2ead398
--- /dev/null
+++ b/arch/arm/mach-owl/swsusp-owl.S
@@ -0,0 +1,325 @@
+/*
+ * swsusp.S - This file is based on arch/i386/power/swsusp.S;
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/page.h>
+
+	.text
+
+#define LOCAL_WORD(x) \
+	.data					; \
+	.p2align 2				; \
+	.type   x, #object		; \
+	.size   x, 4			; \
+x:							; \
+	.long 1
+
+#define WORD_ADDR(x) \
+	.align 2				; \
+.L##x:						; \
+	.word x
+
+#define FUNC(x) \
+	.text					; \
+	.p2align 2				; \
+	.globl x				; \
+	.type   x, #function	; \
+x:
+
+#define FUNC_END(x) \
+	.size   x, .-x
+
+#define CHANGE_MODE(x) \
+	mov     r1, r0				; \
+	bic     r1, r1, #0x1f		; \
+	orr     r1, r1, #0x##x		; \
+	msr     cpsr_c, r1
+
+#define SAVE_VFP_REG(x) \
+	fmrrd   r0, r1, d##x		; \
+	str     r0, [r2]			; \
+	str     r1, [r3]			; \
+	add     r2, r2, #4			; \
+	add     r3, r3, #4
+
+
+#define RESTORE_VFP_REG(x) \
+	ldr     r0, [r2]			; \
+	ldr     r1, [r3]			; \
+	fmdrr   d##x, r0, r1
+
+
+/* nonvolatile int registers */
+	.globl  saved_context_r0
+
+	LOCAL_WORD(saved_context_r0)
+	LOCAL_WORD(saved_context_r1)
+	LOCAL_WORD(saved_context_r2)
+	LOCAL_WORD(saved_context_r3)
+	LOCAL_WORD(saved_context_r4)
+	LOCAL_WORD(saved_context_r5)
+	LOCAL_WORD(saved_context_r6)
+	LOCAL_WORD(saved_context_r7)
+	LOCAL_WORD(saved_context_r8)
+	LOCAL_WORD(saved_context_r9)
+	LOCAL_WORD(saved_context_r10)
+	LOCAL_WORD(saved_context_r11)
+	LOCAL_WORD(saved_context_r12)
+	LOCAL_WORD(saved_context_r13)
+	LOCAL_WORD(saved_context_r14)
+	LOCAL_WORD(saved_cpsr)
+
+	LOCAL_WORD(saved_context_r8_fiq)
+	LOCAL_WORD(saved_context_r9_fiq)
+	LOCAL_WORD(saved_context_r10_fiq)
+	LOCAL_WORD(saved_context_r11_fiq)
+	LOCAL_WORD(saved_context_r12_fiq)
+	LOCAL_WORD(saved_context_r13_fiq)
+	LOCAL_WORD(saved_context_r14_fiq)
+	LOCAL_WORD(saved_spsr_fiq)
+
+	LOCAL_WORD(saved_context_r13_irq)
+	LOCAL_WORD(saved_context_r14_irq)
+	LOCAL_WORD(saved_spsr_irq)
+
+	LOCAL_WORD(saved_context_r13_svc)
+	LOCAL_WORD(saved_context_r14_svc)
+	LOCAL_WORD(saved_spsr_svc)
+
+	LOCAL_WORD(saved_context_r13_abt)
+	LOCAL_WORD(saved_context_r14_abt)
+	LOCAL_WORD(saved_spsr_abt)
+
+	LOCAL_WORD(saved_context_r13_und)
+	LOCAL_WORD(saved_context_r14_und)
+	LOCAL_WORD(saved_spsr_und)
+
+	LOCAL_WORD(saved_fpscr)
+	LOCAL_WORD(saved_fpexc)
+
+
+FUNC(swsusp_arch_suspend)
+	/* save current program status register */
+	ldr     r3, .Lsaved_cpsr
+	mrs     r1, cpsr
+	str     r1, [r3]
+
+	/* hold current mode */
+	mrs     r0, cpsr
+
+	CHANGE_MODE(1f) /* change to system(user) mode */
+	/* save nonvolatile int register */
+	ldr     r3, .Lsaved_context_r0
+	stmia   r3, {r0-r14}
+
+.Lnext:
+	CHANGE_MODE(11) /* change to fiq mode */
+	/* save nonvolatile int register */
+	ldr     r3, .Lsaved_context_r8_fiq
+	stmia   r3, {r8-r14}
+	/* save spsr_fiq register */
+	ldr     r3, .Lsaved_spsr_fiq
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	CHANGE_MODE(12) /* change to irq mode */
+	/* save nonvolatile int register */
+	ldr     r3, .Lsaved_context_r13_irq
+	stmia   r3, {r13-r14}
+	/* save spsr_irq register */
+	ldr     r3, .Lsaved_spsr_irq
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	CHANGE_MODE(13) /* change to svc mode */
+	/* save nonvolatile int register */
+	ldr     r3, .Lsaved_context_r13_svc
+	stmia   r3, {r13-r14}
+	/* save spsr_svc register */
+	ldr     r3, .Lsaved_spsr_svc
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	CHANGE_MODE(17) /* change to abt mode */
+	/* save nonvolatile int register */
+	ldr     r3, .Lsaved_context_r13_abt
+	stmia   r3, {r13-r14}
+	/* save spsr_abt register */
+	ldr     r3, .Lsaved_spsr_abt
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	CHANGE_MODE(1b) /* change to und mode */
+	/* save nonvolatile int register */
+	ldr     r3, .Lsaved_context_r13_und
+	stmia   r3, {r13-r14}
+	/* save spsr_und register */
+	ldr     r3, .Lsaved_spsr_und
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	/* go back to original mode */
+	msr     cpsr_c, r0
+
+	/* call swsusp_save */
+	bl      swsusp_save
+
+	/* restore return address */
+	ldr     r3, .Lsaved_context_r14_svc
+	ldr     lr, [r3]
+	mov     pc, lr
+
+	WORD_ADDR(saved_context_r0)
+	WORD_ADDR(saved_cpsr)
+	WORD_ADDR(saved_context_r8_fiq)
+	WORD_ADDR(saved_spsr_fiq)
+	WORD_ADDR(saved_context_r13_irq)
+	WORD_ADDR(saved_spsr_irq)
+	WORD_ADDR(saved_context_r13_svc)
+	WORD_ADDR(saved_context_r14_svc)
+	WORD_ADDR(saved_spsr_svc)
+	WORD_ADDR(saved_context_r13_abt)
+	WORD_ADDR(saved_spsr_abt)
+	WORD_ADDR(saved_context_r13_und)
+	WORD_ADDR(saved_spsr_und)
+
+	WORD_ADDR(saved_fpscr)
+	WORD_ADDR(saved_fpexc)
+
+FUNC_END(swsusp_arch_suspend)
+
+	.pushsection .idmap.text, "ax"
+ENTRY(swsusp_arch_resume)
+
+	mov r0, #0
+
+	/* Flush TLB (Invalidate unified TLB unlocked entries) */
+	mcr     p15, 0, r0, c8, c7, 0
+	mcr     p15, 0, r0, c7, c5, 0 @ invalidate I cache
+
+	ldr r1, idmap
+	mcr p15, 0, r1, c2, c0, 0		@ set TTB
+
+	mcr p15, 0, r0, c7, c5, 4		@ ISB
+	mcr p15, 0, r0, c7, c10, 4		@ DSB
+
+	ldr r3, =swsusp_arch_resume_with_mmu
+	ldr r1, saved_cr
+	mcr p15, 0, r1, c1, c0, 0		@ set CR
+
+	mcr p15, 0, r0, c7, c5, 4		@ CP15ISB
+
+	mov pc, r3 /* swsusp_arch_resume_with_mmu\B8\F9\BE\DD\D0\C2ҳ\B1\ED\D2\EBַ\C1\CB */
+
+	.globl idmap
+	.globl saved_cr
+idmap:
+	.long 1
+saved_cr:
+	.long 1
+ENDPROC(swsusp_arch_resume)
+	.popsection
+
+	.globl swsusp_arch_resume_with_mmu
+ENTRY(swsusp_arch_resume_with_mmu)
+	mov r0, #0
+	ldr r1, .Lsaved_ttb
+	ldr r1, [r1]
+
+	/* Flush TLB (Invalidate unified TLB unlocked entries) */
+	mcr     p15, 0, r0, c8, c7, 0
+
+	mcr   p15, 0, r1, c2, c0, 0     @ set TTB 0
+	mcr   p15, 0, r0, c7, c5, 4     @ CP15ISB
+
+	mrs     r0, cpsr
+
+	CHANGE_MODE(1f) /* change to system(user) mode */
+
+.Lnext_restore:
+	/* restore nonvolatile int register */
+	ldr     r3, .Lsaved_context_r0
+	ldmia   r3, {r0-r14}
+	/* restore current program status register */
+	ldr     r3, .Lsaved_cpsr
+	ldr     r1, [r3]
+	msr     cpsr_cxsf, r1
+
+	CHANGE_MODE(11) /* change to fiq mode */
+	/* restore nonvolatile int register */
+	ldr     r3, .Lsaved_context_r8_fiq
+	ldmia   r3, {r8-r14}
+	/* restore spsr_fiq register */
+	ldr     r3, .Lsaved_spsr_fiq
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+	CHANGE_MODE(12) /* change to irq mode */
+	/* restore nonvolatile int register */
+	ldr     r3, .Lsaved_context_r13_irq
+	ldmia   r3, {r13-r14}
+	/* restore spsr_irq register */
+	ldr     r3, .Lsaved_spsr_irq
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+	CHANGE_MODE(13) /* change to svc mode */
+	/* restore nonvolatile int register */
+	ldr     r3, .Lsaved_context_r13_svc
+	ldmia   r3, {r13-r14}
+	/*  ldr     r13, [r3] */
+	/* restore spsr_svc register */
+	ldr     r3, .Lsaved_spsr_svc
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+	CHANGE_MODE(17) /* change to abt mode */
+	/* restore nonvolatile int register */
+	ldr     r3, .Lsaved_context_r13_abt
+	ldmia   r3, {r13-r14}
+	/* restore spsr_abt register */
+	ldr     r3, .Lsaved_spsr_abt
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+	CHANGE_MODE(1b) /* change to und mode */
+	/* restore nonvolatile int register */
+	ldr     r3, .Lsaved_context_r13_und
+	ldmia   r3, {r13-r14}
+	/* restore spsr_und register */
+	ldr     r3, .Lsaved_spsr_und
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+	/* go back to original mode */
+	msr     cpsr_c, r0
+
+	/* restore return address */
+	ldr     r3, .Lsaved_context_r14_svc
+	ldr     lr, [r3]
+
+	mov r0, #0
+	mov pc, lr
+
+	.globl saved_ttb
+saved_ttb:
+	.long 1
+.Lsaved_ttb:
+	.long saved_ttb
+
+ENDPROC(swsusp_arch_resume_with_mmu)
diff --git a/arch/arm/mach-owl/timer-owl.c b/arch/arm/mach-owl/timer-owl.c
new file mode 100755
index 0000000..bb3a629
--- /dev/null
+++ b/arch/arm/mach-owl/timer-owl.c
@@ -0,0 +1,156 @@
+/*
+ * arch/arm/mach-owl/timer.c
+ *
+ * time0 use as clocksource
+ * timer1 for time tick at boot stage
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/time.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/sched_clock.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#include <mach/hardware.h>
+
+/*
+ * clocksource
+ */
+static cycle_t owl_read_timer(struct clocksource *cs)
+{
+	return (cycle_t)act_readl(T0_VAL);
+}
+
+static struct clocksource owl_clksrc = {
+	.name		= "timer0",
+	.rating		= 200,
+	.read		= owl_read_timer,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.shift		= 20,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/*
+ * Using this local implementation sched_clock which uses timer0
+ * to get some better resolution when scheduling the kernel.
+ */
+static u64 notrace owl_read_sched_clock(void)
+{
+	return act_readl(T0_VAL);
+}
+
+/* Clockevent device: use one-shot mode */
+static void owl_clkevt_mode(enum clock_event_mode mode,
+				 struct clock_event_device *dev)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		pr_err("%s: periodic mode not supported\n", __func__);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		act_writel(0, T1_CTL);
+		act_writel(0, T1_VAL);
+		act_writel(0, T1_CMP);
+		break;
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_UNUSED:
+		/* disable irq */
+		act_writel(0, T1_CTL);
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+		break;
+	}
+}
+
+static int owl_clkevt_next(unsigned long evt, struct clock_event_device *ev)
+{
+	/* disable timer */
+	act_writel(0x0, T1_CTL);
+
+	/* writing the value has immediate effect */
+	act_writel(0, T1_VAL);
+	act_writel(evt, T1_CMP);
+
+	/* enable timer & IRQ */
+	act_writel(0x6, T1_CTL);
+
+	return 0;
+}
+
+static struct clock_event_device owl_clkevt = {
+	.name		= "timer1",
+	.features	= CLOCK_EVT_FEAT_ONESHOT,
+	.rating	 = 200,
+	.set_mode	= owl_clkevt_mode,
+	.set_next_event	= owl_clkevt_next,
+};
+
+/*
+ * IRQ Handler for timer 1 of the MTU block.
+ */
+static irqreturn_t owl_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evdev = dev_id;
+
+	act_writel(1 << 0, T1_CTL); /* Interrupt clear reg */
+	evdev->event_handler(evdev);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction owl_timer_irq = {
+	.name		= "timer1_tick",
+	.flags		= IRQF_TIMER,
+	.handler	= owl_timer_interrupt,
+	.dev_id		= &owl_clkevt,
+};
+
+void __init owl_gp_timer_init(struct device_node *np)
+{
+	unsigned long rate;
+	int irq;
+
+	/* enable the clock of timer */
+	act_setl(1 << 27, CMU_DEVCLKEN1);
+
+	rate = 24000000;
+
+	/* Timer 0 is the free running clocksource */
+	act_writel(0, T0_CTL);
+	act_writel(0, T0_VAL);
+	act_writel(0, T0_CMP);
+	act_writel(4, T0_CTL);
+
+	sched_clock_register(owl_read_sched_clock, 32, rate);
+	clocksource_register_hz(&owl_clksrc, rate);
+
+	/* Timer 1 is used for events, fix according to rate */
+	act_writel(0, T1_CTL);
+	act_writel(0, T1_VAL);
+	act_writel(0, T1_CMP);
+
+	irq = irq_of_parse_and_map(np, 0);
+	setup_irq(irq, &owl_timer_irq);
+	owl_clkevt.cpumask = cpumask_of(0);
+	clockevents_config_and_register(&owl_clkevt, rate,
+					0xf, 0xffffffff);
+}
+CLOCKSOURCE_OF_DECLARE(s500_timer, "actions,s500-gpt", owl_gp_timer_init);
+
diff --git a/arch/arm/mach-owl/user_dump_stack.c b/arch/arm/mach-owl/user_dump_stack.c
new file mode 100755
index 0000000..3045f3c2
--- /dev/null
+++ b/arch/arm/mach-owl/user_dump_stack.c
@@ -0,0 +1,78 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/export.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+
+#include <asm/stacktrace.h>
+#include <asm/traps.h>
+#include <asm/unwind.h>
+
+#ifdef CONFIG_ARM_UNWIND
+
+void user_dump_backtrace_entry(int (*print)(const char *fmt, ...), unsigned long where, unsigned long from, unsigned long frame)
+{
+#ifdef CONFIG_KALLSYMS
+    print("[<%08lx>] (%pS) from [<%08lx>] (%pS)\n", where, (void *)where, from, (void *)from);
+#else
+    print("Function entered at [<%08lx>] from [<%08lx>]\n", where, from);
+#endif
+}
+
+void user_unwind_backtrace(int (*print)(const char *fmt, ...), struct pt_regs *regs, struct task_struct *tsk)
+{
+	struct stackframe frame;
+	register unsigned long current_sp asm ("sp");
+
+	if (!tsk)
+		tsk = current;
+
+	if (regs) {
+		frame.fp = regs->ARM_fp;
+		frame.sp = regs->ARM_sp;
+		frame.lr = regs->ARM_lr;
+		/* PC might be corrupted, use LR in that case. */
+		frame.pc = kernel_text_address(regs->ARM_pc)
+			 ? regs->ARM_pc : regs->ARM_lr;
+	} else if (tsk == current) {
+		frame.fp = (unsigned long)__builtin_frame_address(0);
+		frame.sp = current_sp;
+		frame.lr = (unsigned long)__builtin_return_address(0);
+		frame.pc = (unsigned long)unwind_backtrace;
+	} else {
+		/* task blocked in __switch_to */
+		frame.fp = thread_saved_fp(tsk);
+		frame.sp = thread_saved_sp(tsk);
+		/*
+		 * The function calling __switch_to cannot be a leaf function
+		 * so LR is recovered from the stack.
+		 */
+		frame.lr = 0;
+		frame.pc = thread_saved_pc(tsk);
+	}
+
+	while (1) {
+		int urc;
+		unsigned long where = frame.pc;
+
+		urc = unwind_frame(&frame);
+		if (urc < 0)
+			break;
+		user_dump_backtrace_entry(print, where, frame.pc, frame.sp - 4);
+	}
+}
+
+static inline void user_dump_backtrace(int (*print)(const char *fmt, ...), struct pt_regs *regs, struct task_struct *tsk)
+{
+	user_unwind_backtrace(print, regs, tsk);
+}
+
+void user_dump_stack(int (*print)(const char *fmt, ...), struct task_struct *tsk)
+{
+	user_dump_backtrace(print, NULL, tsk);
+}
+EXPORT_SYMBOL_GPL(user_dump_stack);
+
+#endif
diff --git a/arch/arm/mach-owl/version-owl.c b/arch/arm/mach-owl/version-owl.c
new file mode 100755
index 0000000..d3d7dba
--- /dev/null
+++ b/arch/arm/mach-owl/version-owl.c
@@ -0,0 +1,99 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/syscalls.h>
+
+#include <mach/hardware.h>
+
+extern unsigned char iversion_read(void);
+extern unsigned int mktno_read(void);
+
+static unsigned char verchar;
+static unsigned int mno;
+static DEFINE_SPINLOCK(cid_op_lock);
+
+unsigned char icversion_get(void)
+{
+	return verchar;
+}
+EXPORT_SYMBOL(icversion_get);
+
+unsigned int mno_get(void)
+{
+	return mno;
+}
+EXPORT_SYMBOL(mno_get);
+
+static void __init cinfo_read(void)
+{
+	unsigned long flag;
+
+	spin_lock_irqsave(&cid_op_lock, flag);
+	verchar = iversion_read();
+	spin_unlock_irqrestore(&cid_op_lock, flag);
+	mno = mktno_read();
+	printk(KERN_INFO "%s: %c, %d\n", __func__, verchar, mno);
+}
+
+static ssize_t cver_show(struct kobject *kobj,
+	struct kobj_attribute *attr, char *buf)
+{
+	unsigned char cver;
+	cver = icversion_get();
+	return sprintf(buf, "%c\n", cver);
+}
+static struct kobj_attribute cver_attribute =
+	__ATTR_RO(cver);
+
+static ssize_t mno_show(struct kobject *kobj,
+	struct kobj_attribute *attr, char *buf)
+{
+	unsigned int mno;
+	mno = mno_get();
+	return sprintf(buf, "%d\n", mno);
+}
+static struct kobj_attribute mno_attribute =
+	__ATTR_RO(mno);
+
+static struct attribute *cinfo_attrs[] = {
+	&cver_attribute.attr,
+	&mno_attribute.attr,
+	NULL,
+};
+
+struct attribute_group cinfo_attr_group = {
+	.name = "cinfo",
+	.attrs = cinfo_attrs,
+};
+
+static struct kobject *board_info_kobj;
+static int __init broad_info_init(void)
+{
+	int retval;
+
+	cinfo_read();
+
+	board_info_kobj = kobject_create_and_add("boardinfo", NULL);
+	if (!board_info_kobj) {
+		printk(KERN_INFO "unable to create board info kobject\n");
+		return -ENOMEM;
+	}
+	retval = sysfs_create_group(board_info_kobj, &cinfo_attr_group);
+	if (retval)
+		kobject_put(board_info_kobj);
+
+	return 0;
+}
+
+static void __exit broad_info_exit(void)
+{
+	kobject_put(board_info_kobj);
+}
+
+module_init(broad_info_init);
+module_exit(broad_info_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Actions");
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
old mode 100644
new mode 100755
index 64d7486..8f1037a
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -53,7 +53,7 @@
  * before transfers and delay cache invalidation until transfer completion.
  *
  */
-static void __dma_page_cpu_to_dev(struct page *, unsigned long,
+void __dma_page_cpu_to_dev(struct page *, unsigned long,
 		size_t, enum dma_data_direction);
 static void __dma_page_dev_to_cpu(struct page *, unsigned long,
 		size_t, enum dma_data_direction);
@@ -572,6 +572,13 @@ static void __free_from_contiguous(struct device *dev, struct page *page,
 
 static inline pgprot_t __get_dma_pgprot(struct dma_attrs *attrs, pgprot_t prot)
 {
+	/* add by actions */
+	if (dma_get_attr(DMA_ATTR_NON_CONSISTENT, attrs)) {
+		pgprot_t prot_new =
+			__pgprot_modify(prot, L_PTE_MT_MASK, L_PTE_MT_WRITEALLOC);
+		return prot_new;
+	}
+
 	prot = dma_get_attr(DMA_ATTR_WRITE_COMBINE, attrs) ?
 			    pgprot_writecombine(prot) :
 			    pgprot_dmacoherent(prot);
@@ -818,6 +825,8 @@ static void dma_cache_maint_page(struct page *page, unsigned long offset,
 			}
 		} else {
 			vaddr = page_address(page) + offset;
+			if ((vaddr + len) > high_memory)
+				len = PAGE_SIZE;
 			op(vaddr, len, dir);
 		}
 		offset = 0;
@@ -832,7 +841,7 @@ static void dma_cache_maint_page(struct page *page, unsigned long offset,
  * platforms with CONFIG_DMABOUNCE.
  * Use the driver DMA support - see dma-mapping.h (dma_sync_*)
  */
-static void __dma_page_cpu_to_dev(struct page *page, unsigned long off,
+void __dma_page_cpu_to_dev(struct page *page, unsigned long off,
 	size_t size, enum dma_data_direction dir)
 {
 	phys_addr_t paddr;
diff --git a/arch/arm/mm/proc-macros.S b/arch/arm/mm/proc-macros.S
old mode 100644
new mode 100755
index c671f34..18777cf
--- a/arch/arm/mm/proc-macros.S
+++ b/arch/arm/mm/proc-macros.S
@@ -309,6 +309,8 @@ ENTRY(\name\()_cache_fns)
 	.long	\name\()_flush_kern_dcache_area
 	.long	\name\()_dma_map_area
 	.long	\name\()_dma_unmap_area
+	.long	\name\()_dma_inv_range
+	.long	\name\()_dma_clean_range
 	.long	\name\()_dma_flush_range
 	.size	\name\()_cache_fns, . - \name\()_cache_fns
 .endm
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
old mode 100644
new mode 100755
index 7911f14..78cd530
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -257,8 +257,11 @@ ENDPROC(cpu_pj4b_do_resume)
  *	It is assumed that:
  *	- cache type register is implemented
  */
-__v7_ca5mp_setup:
 __v7_ca9mp_setup:
+	mrc	p15, 0, r0, c1, c0, 1
+	orr	r0, r0, #((1 << 1) | (1 << 2))
+	mcr	p15, 0, r0, c1, c0, 1
+__v7_ca5mp_setup:
 __v7_cr7mp_setup:
 	mov	r10, #(1 << 0)			@ Cache/TLB ops broadcasting
 	b	1f
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
old mode 100644
new mode 100755
index 2ed1b8a..bed67f4
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1006,3 +1006,4 @@ eco5_bx2		MACH_ECO5_BX2		ECO5_BX2		4572
 eukrea_cpuimx28sd	MACH_EUKREA_CPUIMX28SD	EUKREA_CPUIMX28SD	4573
 domotab			MACH_DOMOTAB		DOMOTAB			4574
 pfla03			MACH_PFLA03		PFLA03			4575
+owl				MACH_OWL		OWL				6666
diff --git a/drivers/base/Kconfig b/drivers/base/Kconfig
old mode 100644
new mode 100755
index 98504ec..323ff69
--- a/drivers/base/Kconfig
+++ b/drivers/base/Kconfig
@@ -306,7 +306,7 @@ endchoice
 
 config CMA_ALIGNMENT
 	int "Maximum PAGE_SIZE order of alignment for contiguous buffers"
-	range 4 12
+	range 1 9
 	default 8
 	help
 	  DMA mapping framework by default aligns all buffers to the smallest
diff --git a/drivers/base/dma-contiguous.c b/drivers/base/dma-contiguous.c
old mode 100644
new mode 100755
index 950fff9..ece00eb
--- a/drivers/base/dma-contiguous.c
+++ b/drivers/base/dma-contiguous.c
@@ -46,7 +46,7 @@ struct cma *dma_contiguous_default_area;
  * Users, who want to set the size of global CMA area for their system
  * should use cma= kernel parameter.
  */
-static const phys_addr_t size_bytes = CMA_SIZE_MBYTES * SZ_1M;
+static phys_addr_t size_bytes = CMA_SIZE_MBYTES * SZ_1M; /* modified by actions, 'const' removed */
 static phys_addr_t size_cmdline = -1;
 static phys_addr_t base_cmdline;
 static phys_addr_t limit_cmdline;
@@ -95,6 +95,13 @@ static inline __maybe_unused phys_addr_t cma_early_percent_memory(void)
 
 #endif
 
+/* add by actions */
+void __init dma_contiguous_set_global_reserve_size(phys_addr_t new_size)
+{
+	if (new_size > size_bytes)
+		size_bytes = new_size;
+}
+
 /**
  * dma_contiguous_reserve() - reserve area(s) for contiguous memory handling
  * @limit: End address of the reserved memory (optional, 0 for any).
diff --git a/drivers/base/regmap/regmap-irq.c b/drivers/base/regmap/regmap-irq.c
old mode 100644
new mode 100755
index a6c3f75..f71ad21
--- a/drivers/base/regmap/regmap-irq.c
+++ b/drivers/base/regmap/regmap-irq.c
@@ -33,6 +33,7 @@ struct regmap_irq_chip_data {
 
 	int irq;
 	int wake_count;
+	int parent_irq_no_wake;
 
 	void *status_reg_buf;
 	unsigned int *status_buf;
@@ -127,13 +128,20 @@ static void regmap_irq_sync_unlock(struct irq_data *data)
 		pm_runtime_put(map->dev);
 
 	/* If we've changed our wakeup count propagate it to the parent */
-	if (d->wake_count < 0)
-		for (i = d->wake_count; i < 0; i++)
-			irq_set_irq_wake(d->irq, 0);
-	else if (d->wake_count > 0)
-		for (i = 0; i < d->wake_count; i++)
-			irq_set_irq_wake(d->irq, 1);
-
+	/* modified by Actions :  fix unblanced irq_set_irq_wake call issue */
+	if (!d->parent_irq_no_wake) {
+		if (d->wake_count < 0)
+			for (i = d->wake_count; i < 0; i++)
+				irq_set_irq_wake(d->irq, 0);
+		else if (d->wake_count > 0)
+			for (i = 0; i < d->wake_count; i++) {
+				ret = irq_set_irq_wake(d->irq, 1);
+				if (ret && i == 0) {
+					d->parent_irq_no_wake = 1;
+					break;
+				}
+			}
+	}
 	d->wake_count = 0;
 
 	mutex_unlock(&d->lock);
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9f9cadd..e5c820d 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -671,6 +671,36 @@ unsigned long __clk_get_rate(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_rate);
 
+static unsigned long clk_core_get_newrate_nolock(struct clk_core *clk)
+{
+	unsigned long ret;
+
+	if (!clk) {
+		ret = 0;
+		goto out;
+	}
+
+	ret = clk->new_rate;
+
+	if (clk->flags & CLK_IS_ROOT)
+		goto out;
+
+	if (!clk->parent)
+		ret = 0;
+
+out:
+	return ret;
+}
+
+unsigned long __clk_get_newrate(struct clk *clk)
+{
+	if (!clk)
+		return 0;
+
+	return clk_core_get_newrate_nolock(clk->core);
+}
+EXPORT_SYMBOL_GPL(__clk_get_newrate);
+
 static unsigned long __clk_get_accuracy(struct clk_core *clk)
 {
 	if (!clk)
@@ -685,6 +715,24 @@ unsigned long __clk_get_flags(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_flags);
 
+void __clk_set_flags(struct clk *clk, unsigned long flags)
+{
+	clk->core->flags = flags;
+}
+EXPORT_SYMBOL_GPL(__clk_set_flags);
+
+const struct clk_ops *__clk_get_ops(struct clk *clk)
+{
+	return !clk ? NULL : clk->core->ops;
+}
+EXPORT_SYMBOL_GPL(__clk_get_ops);
+
+void __clk_set_ops(struct clk *clk, const struct clk_ops *clk_ops)
+{
+	clk->core->ops = clk_ops;
+}
+EXPORT_SYMBOL_GPL(__clk_set_ops);
+
 static bool clk_core_is_prepared(struct clk_core *clk)
 {
 	int ret;
diff --git a/drivers/staging/android/Kconfig b/drivers/staging/android/Kconfig
old mode 100644
new mode 100755
index 8feb904..e11b9da
--- a/drivers/staging/android/Kconfig
+++ b/drivers/staging/android/Kconfig
@@ -28,6 +28,8 @@ config ANDROID_LOW_MEMORY_KILLER
 	---help---
 	  Registers processes to be killed when memory is low
 
+source "drivers/staging/android/switch/Kconfig"
+
 config SYNC
 	bool "Synchronization framework"
 	default n
diff --git a/drivers/staging/android/Makefile b/drivers/staging/android/Makefile
old mode 100644
new mode 100755
index c7b6c99..786ab64
--- a/drivers/staging/android/Makefile
+++ b/drivers/staging/android/Makefile
@@ -6,5 +6,6 @@ obj-$(CONFIG_ASHMEM)			+= ashmem.o
 obj-$(CONFIG_ANDROID_TIMED_OUTPUT)	+= timed_output.o
 obj-$(CONFIG_ANDROID_TIMED_GPIO)	+= timed_gpio.o
 obj-$(CONFIG_ANDROID_LOW_MEMORY_KILLER)	+= lowmemorykiller.o
+obj-$(CONFIG_ANDROID_SWITCH)		+= switch/
 obj-$(CONFIG_SYNC)			+= sync.o sync_debug.o
 obj-$(CONFIG_SW_SYNC)			+= sw_sync.o
diff --git a/drivers/staging/android/ion/Kconfig b/drivers/staging/android/ion/Kconfig
old mode 100644
new mode 100755
index 3452346..e79df26
--- a/drivers/staging/android/ion/Kconfig
+++ b/drivers/staging/android/ion/Kconfig
@@ -33,3 +33,9 @@ config ION_TEGRA
 	help
 	  Choose this option if you wish to use ion on an nVidia Tegra.
 
+config ION_OWL
+	tristate "Ion for Actions SOC"
+	depends on (ARCH_LEOPARD || ARCH_OWL) && ION
+	help
+	  Choose this option if you wish to use ion on an nVidia Tegra.
+
diff --git a/drivers/staging/android/ion/Makefile b/drivers/staging/android/ion/Makefile
old mode 100644
new mode 100755
index b56fd2b..9590150
--- a/drivers/staging/android/ion/Makefile
+++ b/drivers/staging/android/ion/Makefile
@@ -7,4 +7,4 @@ endif
 
 obj-$(CONFIG_ION_DUMMY) += ion_dummy_driver.o
 obj-$(CONFIG_ION_TEGRA) += tegra/
-
+obj-$(CONFIG_ION_OWL) += owl/
diff --git a/drivers/staging/android/ion/ion.c b/drivers/staging/android/ion/ion.c
old mode 100644
new mode 100755
index abbc42a..f789bb1
--- a/drivers/staging/android/ion/ion.c
+++ b/drivers/staging/android/ion/ion.c
@@ -36,6 +36,10 @@
 #include <linux/debugfs.h>
 #include <linux/dma-buf.h>
 #include <linux/idr.h>
+#include <linux/cpu.h>
+
+#include <linux/smp.h>
+#include <asm/cacheflush.h>
 
 #include "ion.h"
 #include "ion_priv.h"
@@ -198,6 +202,9 @@ static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
 		if (!(heap->flags & ION_HEAP_FLAG_DEFER_FREE))
 			goto err2;
 
+		pr_debug("%s: wait for deffer free, heap=%s\n",
+			__func__, heap->name);
+
 		ion_heap_freelist_drain(heap, 0);
 		ret = heap->ops->allocate(heap, buffer, len, align,
 					  flags);
@@ -252,8 +259,10 @@ static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
 	   allocation via dma_map_sg. The implicit contract here is that
 	   memory coming from the heaps is ready for dma, ie if it has a
 	   cached mapping that mapping has been invalidated */
-	for_each_sg(buffer->sg_table->sgl, sg, buffer->sg_table->nents, i)
+	for_each_sg(buffer->sg_table->sgl, sg, buffer->sg_table->nents, i) {
 		sg_dma_address(sg) = sg_phys(sg);
+		sg_dma_len(sg) = sg->length;
+	}
 	mutex_lock(&dev->buffer_lock);
 	ion_buffer_add(dev, buffer);
 	mutex_unlock(&dev->buffer_lock);
@@ -399,6 +408,11 @@ static int ion_handle_put(struct ion_handle *handle)
 	return ret;
 }
 
+int ion_handle_put_outter(struct ion_handle *handle)
+{
+	return ion_handle_put(handle);
+}
+
 static struct ion_handle *ion_handle_lookup(struct ion_client *client,
 					    struct ion_buffer *buffer)
 {
@@ -417,7 +431,7 @@ static struct ion_handle *ion_handle_lookup(struct ion_client *client,
 	return ERR_PTR(-EINVAL);
 }
 
-static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,
+struct ion_handle *ion_handle_get_by_id(struct ion_client *client,
 						int id)
 {
 	struct ion_handle *handle;
@@ -479,8 +493,8 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 	struct ion_heap *heap;
 	int ret;
 
-	pr_debug("%s: len %zu align %zu heap_id_mask %u flags %x\n", __func__,
-		 len, align, heap_id_mask, flags);
+	pr_debug("%s: client %s len %zu align %zu heap_id_mask %u flags %x\n", __func__,
+		 client->name, len, align, heap_id_mask, flags);
 	/*
 	 * traverse the list of heaps available in this system in priority
 	 * order.  If the heap type is supported by the client, and matches the
@@ -500,14 +514,19 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 		buffer = ion_buffer_create(heap, dev, len, align, flags);
 		if (!IS_ERR(buffer))
 			break;
+		pr_debug("%s: failed to alloc from heap %s, client=%s size=%u\n",
+			__func__, heap->name, client->name, len);
 	}
 	up_read(&dev->lock);
 
 	if (buffer == NULL)
 		return ERR_PTR(-ENODEV);
 
-	if (IS_ERR(buffer))
+	if (IS_ERR(buffer)) {
+		pr_info("%s: failed to alloc, client=%s size=%u heap_id_mask=0x%x\n",
+			__func__, client->name, len, heap_id_mask);
 		return ERR_CAST(buffer);
+	}
 
 	handle = ion_handle_create(client, buffer);
 
@@ -566,9 +585,12 @@ int ion_phys(struct ion_client *client, struct ion_handle *handle,
 	buffer = handle->buffer;
 
 	if (!buffer->heap->ops->phys) {
-		pr_err("%s: ion_phys is not implemented by this heap (name=%s, type=%d).\n",
-			__func__, buffer->heap->name, buffer->heap->type);
-		mutex_unlock(&client->lock);
+		int heap_id = buffer->heap->id;
+		enum ion_heap_type heap_type = buffer->heap->type;
+		const char *heap_name = buffer->heap->name;
+		mutex_unlock(&client->lock); /* unlock before print. */
+		pr_warn("%s: ion_phys is not implemented by this heap (id=%u type=%u name=%s).\n",
+		       __func__, heap_id, (uint)heap_type, heap_name);
 		return -ENODEV;
 	}
 	mutex_unlock(&client->lock);
@@ -859,9 +881,9 @@ struct sg_table *ion_sg_table(struct ion_client *client,
 
 	mutex_lock(&client->lock);
 	if (!ion_handle_validate(client, handle)) {
+		mutex_unlock(&client->lock);
 		pr_err("%s: invalid handle passed to map_dma.\n",
 		       __func__);
-		mutex_unlock(&client->lock);
 		return ERR_PTR(-EINVAL);
 	}
 	buffer = handle->buffer;
@@ -904,6 +926,7 @@ void ion_pages_sync_for_device(struct device *dev, struct page *page,
 	 * hardware.
 	 */
 	sg_dma_address(&sg) = page_to_phys(page);
+
 	dma_sync_sg_for_device(dev, &sg, 1, dir);
 }
 
@@ -1199,6 +1222,18 @@ end:
 }
 EXPORT_SYMBOL(ion_import_dma_buf);
 
+static void _ion_local_l1_cache_flush_all(void *info)
+{
+	flush_cache_all();
+}
+
+static void ion_local_l1_cache_flush_all(void)
+{
+	get_online_cpus();
+	on_each_cpu(_ion_local_l1_cache_flush_all, NULL, 1);
+	put_online_cpus();
+}
+
 static int ion_sync_for_device(struct ion_client *client, int fd)
 {
 	struct dma_buf *dmabuf;
@@ -1217,12 +1252,177 @@ static int ion_sync_for_device(struct ion_client *client, int fd)
 	}
 	buffer = dmabuf->priv;
 
+	/* 原意是 > cache_size 时按照way刷, 否则按line刷, 在kernel内修改是很简单的,
+	 * 但是考虑到不通用(仅仅是ion用), 只能在ion内修改, 所以显得有点绕. */
+	if (buffer->size >= 64*1024 && buffer->heap->ops->phys) {
+		ion_phys_addr_t phy_addr;
+		size_t phy_len;
+		int ret;
+
+		ret = buffer->heap->ops->phys(buffer->heap, buffer, &phy_addr, &phy_len);
+		if(ret == 0) {
+			/* L1 clean and invalidate all */
+			ion_local_l1_cache_flush_all();
+			/* L2 clean and invalidate, 内部会判断, >cache_size则全刷. */
+			outer_flush_range(phy_addr, phy_addr + phy_len);
+			goto out;
+		}
+	}
+
+	/* fallback to original implement */
+	/* must be paired to form a clean-and-invalidate operation. */
 	dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
-			       buffer->sg_table->nents, DMA_BIDIRECTIONAL);
+				   buffer->sg_table->nents, DMA_BIDIRECTIONAL);
+	dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+				   buffer->sg_table->nents, DMA_BIDIRECTIONAL);
+
+out:
 	dma_buf_put(dmabuf);
 	return 0;
 }
 
+static int check_vaddr_bounds(unsigned long start, unsigned long end)
+{
+	struct mm_struct *mm = current->active_mm;
+	struct vm_area_struct *vma;
+	int ret = 1;
+
+	if (end < start)
+		goto out;
+
+	down_read(&mm->mmap_sem);
+	vma = find_vma(mm, start);
+	if (vma && vma->vm_start < end) {
+		if (start < vma->vm_start)
+			goto out_up;
+		if (end > vma->vm_end)
+			goto out_up;
+		ret = 0;
+	}
+
+out_up:
+	up_read(&mm->mmap_sem);
+out:
+	return ret;
+}
+
+static void _ion_outer_clean_range(phys_addr_t start, phys_addr_t end)
+{
+    outer_clean_range(start, end);
+}
+
+static void _ion_outer_inv_range(phys_addr_t start, phys_addr_t end)
+{
+    outer_inv_range(start, end);
+}
+
+static void _ion_outer_flush_range(phys_addr_t start, phys_addr_t end)
+{
+    outer_flush_range(start, end);
+}
+
+static int _ion_do_cache_op(struct ion_client *client, struct ion_handle *handle,
+			void *vaddr, unsigned long offset, unsigned long length,
+			unsigned int cmd)
+{
+	void (*outer_cache_op)(phys_addr_t, phys_addr_t);
+	struct ion_buffer *buffer;
+	ion_phys_addr_t phy_addr;
+	size_t phy_len;
+	int ret = -EINVAL;
+
+	mutex_lock(&client->lock);
+	if (!ion_handle_validate(client, handle)) {
+		pr_err("%s: invalid handle passed to do_cache_op.\n", __func__);
+		mutex_unlock(&client->lock);
+		return -EINVAL;
+	}
+	buffer = handle->buffer;
+	mutex_lock(&buffer->lock);
+
+	if ((buffer->flags & ION_FLAG_CACHED) == 0) {
+		pr_warn("%s: non-cached buffer, no need to do cache_op\n", __func__);
+		ret = 0;
+		goto out;
+	}
+
+	if (buffer->heap->ops->phys) {
+		switch (cmd) {
+		case ION_IOC_CLEAN_CACHES:
+			pr_debug("ION_IOC_CLEAN_CACHES");
+			__cpuc_flush_dcache_area(vaddr, length);
+			outer_cache_op = _ion_outer_clean_range;
+			break;
+		case ION_IOC_INV_CACHES:
+			pr_debug("ION_IOC_INV_CACHES");
+			__cpuc_flush_dcache_area(vaddr, length);
+			outer_cache_op = _ion_outer_inv_range;
+			break;
+		case ION_IOC_CLEAN_INV_CACHES:
+			pr_debug("ION_IOC_CLEAN_INV_CACHES");
+			__cpuc_flush_dcache_area(vaddr, length);
+			outer_cache_op = _ion_outer_flush_range;
+			break;
+		default:
+			pr_err("%s: unknown cache_op cmd 0x%x\n", __func__, cmd);
+			goto out;
+		}
+
+		ret = buffer->heap->ops->phys(buffer->heap, buffer, &phy_addr, &phy_len);
+		if (ret != 0) {
+			pr_err("%s: failed to get phy_addr of buffer\n", __func__);
+			goto out;
+		}
+		if (offset < phy_len) {
+			unsigned long pstart, pend;
+
+			pstart = phy_addr + offset;
+			pend = pstart + length;
+			if(pend > phy_addr + phy_len) {
+				pr_warn("%s: range err, phy_len=%u offset=%lu length=%lu\n",
+					__func__, phy_len, offset, length);
+				pend = phy_addr + phy_len;
+			}
+			pr_debug("%s %d: outer_cache_op pstart %lx end %lx\n",
+				__func__, __LINE__, pstart, pstart + length);
+			
+			outer_cache_op(pstart, pstart + length);
+		} else {
+			pr_err("%s: range err, phy_len=%u offset=%lu length=%lu\n",
+				__func__, phy_len, offset, length);
+		}
+	} else {
+		/* fallback to DMA-API */
+		enum dma_data_direction dma_dir;
+
+		switch (cmd) {
+		case ION_IOC_CLEAN_CACHES:
+			dma_dir = DMA_TO_DEVICE;
+			break;
+		case ION_IOC_INV_CACHES:
+			dma_dir = DMA_FROM_DEVICE;
+			break;
+		case ION_IOC_CLEAN_INV_CACHES:
+			dma_dir = DMA_BIDIRECTIONAL;
+			break;
+		default:
+			pr_err("%s: unknown cache_op cmd 0x%x\n", __func__, cmd);
+			goto out;
+		}
+		/* must be paired to form a clean-and-invalidate operation. */
+		dma_sync_sg_for_device(NULL, buffer->sg_table->sgl,
+					   buffer->sg_table->nents, dma_dir);
+		dma_sync_sg_for_cpu(NULL, buffer->sg_table->sgl,
+					   buffer->sg_table->nents, dma_dir);
+	}
+
+out:
+	mutex_unlock(&buffer->lock);
+	mutex_unlock(&client->lock);
+	return ret;
+
+}
+
 /* fix up the cases where the ioctl direction bits are incorrect */
 static unsigned int ion_ioctl_dir(unsigned int cmd)
 {
@@ -1326,7 +1526,55 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 						data.custom.arg);
 		break;
 	}
+	case ION_IOC_CLEAN_CACHES:
+	case ION_IOC_INV_CACHES:
+	case ION_IOC_CLEAN_INV_CACHES:
+	{
+		struct ion_flush_data data;
+		unsigned long start, end;
+		struct ion_handle *handle = NULL;
+		int ret;
+
+		pr_debug("%s CLEAN_CACHES/INV_CACHES/CLEAN_INV_CACHES\n", __func__);
+
+		if (copy_from_user(&data, (void __user *)arg,
+				sizeof(struct ion_flush_data))) {
+			pr_err("%s: copy_from_user err\n", __func__);
+			return -EFAULT;
+		}
+
+		start = (unsigned long) data.vaddr;
+		end = (unsigned long) data.vaddr + data.length;
+
+		if (check_vaddr_bounds(start, end)) {
+			pr_err("%s: virtual address %p is out of bounds\n",
+				__func__, data.vaddr);
+			return -EINVAL;
+		}
+
+		handle = ion_import_dma_buf(client, data.fd);
+		if (IS_ERR(handle)) {
+			pr_err("%s: Could not import handle: %d\n",
+				__func__, (int)handle);
+			return -EINVAL;
+		}
+
+		ret = _ion_do_cache_op(client,
+					handle,
+					data.vaddr, data.offset, data.length,
+					cmd);
+
+		ion_free(client, handle);
+
+		if (ret < 0) {
+			pr_err("%s: heap cache_op err, ret=%d\n", __func__, ret);
+			return ret;
+		}
+		break;
+
+	}
 	default:
+		pr_err("%s: unknown ion ioctl cmd 0x%x\n", __func__, cmd);
 		return -ENOTTY;
 	}
 
@@ -1650,3 +1898,16 @@ void __init ion_reserve(struct ion_platform_data *data)
 			data->heaps[i].size);
 	}
 }
+
+
+/**
+ * ion_get_handle_id() - get ion_handle's id.
+ * 
+ * This is an afterthought API provided by Actions(Zhuhai) Technology
+ * Co., Limited, which is used by OWL Display Engine MMU driver
+ * (drivers/video/owl/dss/mmu.c) to identify an unique ION buffer. */
+int ion_get_handle_id(struct ion_handle *handle)
+{
+	return handle->id;
+}
+
diff --git a/drivers/staging/android/ion/ion.h b/drivers/staging/android/ion/ion.h
old mode 100644
new mode 100755
index 443db84..d8f29a0
--- a/drivers/staging/android/ion/ion.h
+++ b/drivers/staging/android/ion/ion.h
@@ -200,4 +200,13 @@ int ion_share_dma_buf_fd(struct ion_client *client, struct ion_handle *handle);
  */
 struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd);
 
+/**
+ * ion_get_handle_id() - get ion_handle's id.
+ * 
+ * This is an afterthought API provided by Actions(Zhuhai) Technology
+ * Co., Limited, which is used by OWL Display Engine MMU driver
+ * (drivers/video/owl/dss/mmu.c) to identify an unique ION buffer.
+ */
+int ion_get_handle_id(struct ion_handle *handle);
+
 #endif /* _LINUX_ION_H */
diff --git a/drivers/staging/android/ion/ion_cma_heap.c b/drivers/staging/android/ion/ion_cma_heap.c
old mode 100644
new mode 100755
index f4211f1..cbd4e8e
--- a/drivers/staging/android/ion/ion_cma_heap.c
+++ b/drivers/staging/android/ion/ion_cma_heap.c
@@ -24,6 +24,8 @@
 #include "ion.h"
 #include "ion_priv.h"
 
+#define ION_CMA_ENABLE_ALLOC_TIME_CHK 1
+
 #define ION_CMA_ALLOCATE_FAILED -1
 
 struct ion_cma_heap {
@@ -45,15 +47,16 @@ static int ion_cma_allocate(struct ion_heap *heap, struct ion_buffer *buffer,
 			    unsigned long len, unsigned long align,
 			    unsigned long flags)
 {
+#if ION_CMA_ENABLE_ALLOC_TIME_CHK
+	struct timespec ts_alloc_start, ts_alloc_end, ts_tmp;
+	ulong alloc_time_ms;
+#endif
 	struct ion_cma_heap *cma_heap = to_cma_heap(heap);
 	struct device *dev = cma_heap->dev;
 	struct ion_cma_buffer_info *info;
 
 	dev_dbg(dev, "Request buffer allocation len %ld\n", len);
 
-	if (buffer->flags & ION_FLAG_CACHED)
-		return -EINVAL;
-
 	if (align > PAGE_SIZE)
 		return -EINVAL;
 
@@ -61,14 +64,41 @@ static int ion_cma_allocate(struct ion_heap *heap, struct ion_buffer *buffer,
 	if (!info)
 		return ION_CMA_ALLOCATE_FAILED;
 
-	info->cpu_addr = dma_alloc_coherent(dev, len, &(info->handle),
-						GFP_HIGHUSER | __GFP_ZERO);
-
+#if ION_CMA_ENABLE_ALLOC_TIME_CHK
+	getnstimeofday(&ts_alloc_start);
+#endif
+
+	if (buffer->flags & ION_FLAG_CACHED) {
+		/* 关于cached的更改, 大部分在kernel中.
+		 * 原本是可以不动kernel的代码, 直接用dma_alloc_coherent分配完后再重新将页表
+		 * 改为cached的, 但是这样1是重复call改页表浪费时间, 2是不好看.
+		 * 故沿用改动最小的方式, 将原有的但是arm没有实现的API: dma_alloc_noncoherent
+		 * 实现起来. */
+		printk("++ION CMA 1 %ld \n", len);		
+		info->cpu_addr = dma_alloc_noncoherent(dev, len, &(info->handle),
+							GFP_HIGHUSER | __GFP_ZERO);
+		printk("--\n");
+
+	} else {
+		printk("++ION CMA 2 %ld \n", len);	
+		info->cpu_addr = dma_alloc_coherent(dev, len, &(info->handle),
+							GFP_HIGHUSER | __GFP_ZERO);
+		printk("--\n");	
+	}
 	if (!info->cpu_addr) {
-		dev_err(dev, "Fail to allocate buffer\n");
+		dev_err(dev, "Fail to allocate CMA buffer\n");
 		goto err;
 	}
 
+#if ION_CMA_ENABLE_ALLOC_TIME_CHK
+	getnstimeofday(&ts_alloc_end);
+	ts_tmp = timespec_sub(ts_alloc_end, ts_alloc_start);
+	alloc_time_ms = div_u64(timespec_to_ns(&ts_tmp), 1000000U);
+	if (alloc_time_ms > 200U)
+		dev_info(dev, "%s() too slow (%lums), len=%lu align=%lu\n",
+			__func__, alloc_time_ms, len, align);
+#endif
+
 	info->table = kmalloc(sizeof(struct sg_table), GFP_KERNEL);
 	if (!info->table)
 		goto free_mem;
@@ -84,7 +114,10 @@ static int ion_cma_allocate(struct ion_heap *heap, struct ion_buffer *buffer,
 free_table:
 	kfree(info->table);
 free_mem:
-	dma_free_coherent(dev, len, info->cpu_addr, info->handle);
+	if (buffer->flags & ION_FLAG_CACHED)
+		dma_free_noncoherent(dev, len, info->cpu_addr, info->handle);
+	else
+		dma_free_coherent(dev, len, info->cpu_addr, info->handle);
 err:
 	kfree(info);
 	return ION_CMA_ALLOCATE_FAILED;
@@ -98,7 +131,10 @@ static void ion_cma_free(struct ion_buffer *buffer)
 
 	dev_dbg(dev, "Release buffer %p\n", buffer);
 	/* release memory */
-	dma_free_coherent(dev, buffer->size, info->cpu_addr, info->handle);
+	if (buffer->flags & ION_FLAG_CACHED)
+		dma_free_noncoherent(dev, buffer->size, info->cpu_addr, info->handle);
+	else
+		dma_free_coherent(dev, buffer->size, info->cpu_addr, info->handle);
 	/* release sg table */
 	sg_free_table(info->table);
 	kfree(info->table);
@@ -142,8 +178,12 @@ static int ion_cma_mmap(struct ion_heap *mapper, struct ion_buffer *buffer,
 	struct device *dev = cma_heap->dev;
 	struct ion_cma_buffer_info *info = buffer->priv_virt;
 
-	return dma_mmap_coherent(dev, vma, info->cpu_addr, info->handle,
-				 buffer->size);
+	if (buffer->flags & ION_FLAG_CACHED)
+		return dma_mmap_noncoherent(dev, vma, info->cpu_addr, info->handle,
+					buffer->size);
+	else
+		return dma_mmap_coherent(dev, vma, info->cpu_addr, info->handle,
+					buffer->size);
 }
 
 static void *ion_cma_map_kernel(struct ion_heap *heap,
diff --git a/drivers/staging/android/ion/ion_priv.h b/drivers/staging/android/ion/ion_priv.h
old mode 100644
new mode 100755
index 18a5f93..10af899
--- a/drivers/staging/android/ion/ion_priv.h
+++ b/drivers/staging/android/ion/ion_priv.h
@@ -402,4 +402,9 @@ int ion_page_pool_shrink(struct ion_page_pool *pool, gfp_t gfp_mask,
 void ion_pages_sync_for_device(struct device *dev, struct page *page,
 		size_t size, enum dma_data_direction dir);
 
+
+struct ion_handle *ion_handle_get_by_id(struct ion_client *client,
+						int id);
+int ion_handle_put_outter(struct ion_handle *handle);
+
 #endif /* _ION_PRIV_H */
diff --git a/drivers/staging/android/ion/owl/Makefile b/drivers/staging/android/ion/owl/Makefile
new file mode 100755
index 0000000..1323b33
--- /dev/null
+++ b/drivers/staging/android/ion/owl/Makefile
@@ -0,0 +1 @@
+obj-y += ion-owl.o
diff --git a/drivers/staging/android/ion/owl/ion-owl.c b/drivers/staging/android/ion/owl/ion-owl.c
new file mode 100755
index 0000000..851bea7
--- /dev/null
+++ b/drivers/staging/android/ion/owl/ion-owl.c
@@ -0,0 +1,177 @@
+/*
+ * Actions SOC ion heap device
+ *
+ * Copyright (C) 2014 Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+
+#include "../ion.h"
+#include "../ion_priv.h"
+#include "../../uapi/ion-owl.h"
+
+#if 0
+#define OWL_ION_HEAP_NUM	3
+static struct ion_platform_heap owl_ion_heaps[OWL_ION_HEAP_NUM] = {
+    {
+        .type = ION_HEAP_TYPE_CARVEOUT,
+        .id = ION_HEAP_ID_FB,
+        .name = "ion_fb",
+        .base = 0,
+        .size = 0,
+    },
+
+    {
+        .type = ION_HEAP_TYPE_CARVEOUT,
+        .id = ION_HEAP_ID_PMEM,
+        .name = "ion_pmem",
+        .base = 0,
+        .size = 0,
+    },
+
+    {
+        .type = ION_HEAP_TYPE_SYSTEM,
+        .id = ION_HEAP_ID_SYSTEM,
+        .name = "ion_system",
+    },
+};
+
+static struct ion_platform_data owl_ion_data = {
+	.nr = OWL_ION_HEAP_NUM,
+	.heaps = owl_ion_heaps,
+};
+#endif
+
+struct ion_device *owl_ion_device;
+EXPORT_SYMBOL(owl_ion_device);
+
+static int num_heaps;
+static struct ion_heap **heaps;
+
+static int owl_ion_get_phys(struct ion_client *client,
+					unsigned int cmd,
+					unsigned long arg)
+{
+	struct owl_ion_phys_data data;
+	struct owl_ion_phys_data *user_data =
+				(struct owl_ion_phys_data *)arg;
+	struct ion_handle *handle;
+	struct ion_buffer *buffer;
+	int ret;
+
+	if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+		return -EFAULT;
+
+	handle = ion_handle_get_by_id(client, data.handle);
+	if (IS_ERR(handle))
+		return PTR_ERR(handle);
+
+	buffer = ion_handle_buffer(handle);
+	ret = ion_phys(client, handle, &data.phys_addr, &data.size);
+	ion_handle_put_outter(handle);
+	if(ret < 0)
+		return ret;
+
+	if (copy_to_user(user_data, &data, sizeof(data)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static long owl_ion_ioctl(struct ion_client *client,
+				   unsigned int cmd,
+				   unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	switch (cmd) {
+	case OWL_ION_GET_PHY:
+		ret = owl_ion_get_phys(client, cmd, arg);
+		break;
+	default:
+		WARN(1, "Unknown custom ioctl\n");
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static int owl_ion_probe(struct platform_device *pdev)
+{
+	struct ion_platform_data *pdata = pdev->dev.platform_data;
+	int err;
+	int i;
+
+	num_heaps = pdata->nr;
+
+	heaps = kzalloc(sizeof(struct ion_heap *) * pdata->nr, GFP_KERNEL);
+
+	owl_ion_device = ion_device_create(owl_ion_ioctl);
+	if (IS_ERR_OR_NULL(owl_ion_device)) {
+		kfree(heaps);
+		return PTR_ERR(owl_ion_device);
+	}
+
+	/* create the heaps as specified in the board file */
+	for (i = 0; i < num_heaps; i++) {
+		struct ion_platform_heap *heap_data = &pdata->heaps[i];
+
+		heaps[i] = ion_heap_create(heap_data);
+		if (IS_ERR_OR_NULL(heaps[i])) {
+			err = PTR_ERR(heaps[i]);
+			goto err;
+		}
+		ion_device_add_heap(owl_ion_device, heaps[i]);
+		pr_info("%s: add heap %s\n", __func__, heaps[i]->name);
+	}
+
+	platform_set_drvdata(pdev, owl_ion_device);
+	return 0;
+err:
+	for (i = 0; i < num_heaps; i++) {
+		if (heaps[i])
+			ion_heap_destroy(heaps[i]);
+	}
+	kfree(heaps);
+	return err;
+}
+
+static int owl_ion_remove(struct platform_device *pdev)
+{
+	struct ion_device *owl_ion_device = platform_get_drvdata(pdev);
+	int i;
+
+	ion_device_destroy(owl_ion_device);
+	for (i = 0; i < num_heaps; i++)
+		ion_heap_destroy(heaps[i]);
+	kfree(heaps);
+	return 0;
+}
+
+static struct platform_driver owl_ion_driver = {
+	.probe = owl_ion_probe,
+	.remove = owl_ion_remove,
+	.driver = { .name = "ion-owl" }
+};
+
+static int __init owl_ion_init(void)
+{
+	return platform_driver_register(&owl_ion_driver);
+}
+
+static void __exit owl_ion_exit(void)
+{
+	platform_driver_unregister(&owl_ion_driver);
+}
+
+subsys_initcall(owl_ion_init);
+module_exit(owl_ion_exit);
+
diff --git a/drivers/staging/android/lowmem_killer.h b/drivers/staging/android/lowmem_killer.h
new file mode 100755
index 0000000..0cb3932
--- /dev/null
+++ b/drivers/staging/android/lowmem_killer.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM lowmem_killer
+
+#if !defined(_LOWMEM_KILLER_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _LOWMEM_KILLER_H
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/oom.h>
+#include <linux/sched.h>
+#include <linux/swap.h>
+#include <linux/rcupdate.h>
+#include <linux/notifier.h>
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(lowmem_kill,
+
+	TP_PROTO(struct task_struct *selected,   int other_file,  int minfree, int min_score_adj,  int other_free),
+
+	TP_ARGS(selected, other_file, minfree, min_score_adj, other_free),
+
+	TP_STRUCT__entry(
+		__field( unsigned int,		other_file			)
+		__field( unsigned int,		minfree			)
+		__field( unsigned int,		min_score_adj			)
+		__field( unsigned int,		other_free			)
+		__field( unsigned int,		oom_adj			)
+		__array( char,		selected_comm,	TASK_COMM_LEN	)
+		__field( unsigned int,	selected_pid		)
+		__array( char,      cur_comm, TASK_COMM_LEN )
+		__field( unsigned int,	cur_pid		)
+        ),
+
+	TP_fast_assign(							
+		memcpy(__entry->selected_comm, selected->comm, TASK_COMM_LEN);
+		__entry->selected_pid	= selected->pid;		
+		__entry->oom_adj		= selected->signal->oom_score_adj;
+		memcpy(__entry->cur_comm, current->comm, TASK_COMM_LEN);
+		__entry->cur_pid	= current->pid;
+		__entry->other_file	= other_file * (long)(PAGE_SIZE / 1024);
+		__entry->minfree	= minfree * (long)(PAGE_SIZE / 1024);
+		__entry->min_score_adj	= min_score_adj;
+		__entry->other_free	= other_free * (long)(PAGE_SIZE / 1024);
+        ),
+
+	TP_printk("selected [%s] %d  oomadj %u,  current [%s] %d,  other_file %d other_free %d minfree %d min_score_adj %d",
+		  __entry->selected_comm,__entry->selected_pid,__entry->oom_adj,
+		  __entry->cur_comm,__entry->cur_pid,
+		  __entry->other_file, __entry->other_free, __entry->minfree, __entry->min_score_adj)
+);
+
+
+#endif
+
+#undef TRACE_INCLUDE_PATH
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE lowmem_killer
+#include <trace/define_trace.h>
diff --git a/drivers/staging/android/lowmemorykiller.c b/drivers/staging/android/lowmemorykiller.c
old mode 100644
new mode 100755
index feafa17..52f73be
--- a/drivers/staging/android/lowmemorykiller.c
+++ b/drivers/staging/android/lowmemorykiller.c
@@ -42,6 +42,9 @@
 #include <linux/profile.h>
 #include <linux/notifier.h>
 
+#define CREATE_TRACE_POINTS
+#include <lowmem_killer.h>
+
 static uint32_t lowmem_debug_level = 1;
 static short lowmem_adj[6] = {
 	0,
@@ -83,6 +86,7 @@ static unsigned long lowmem_scan(struct shrinker *s, struct shrink_control *sc)
 	int tasksize;
 	int i;
 	short min_score_adj = OOM_SCORE_ADJ_MAX + 1;
+	int minfree = 0;
 	int selected_tasksize = 0;
 	short selected_oom_score_adj;
 	int array_size = ARRAY_SIZE(lowmem_adj);
@@ -96,6 +100,7 @@ static unsigned long lowmem_scan(struct shrinker *s, struct shrink_control *sc)
 	if (lowmem_minfree_size < array_size)
 		array_size = lowmem_minfree_size;
 	for (i = 0; i < array_size; i++) {
+		minfree = lowmem_minfree[i];
 		if (other_free < lowmem_minfree[i] &&
 		    other_file < lowmem_minfree[i]) {
 			min_score_adj = lowmem_adj[i];
@@ -159,6 +164,9 @@ static unsigned long lowmem_scan(struct shrinker *s, struct shrink_control *sc)
 		lowmem_print(1, "send sigkill to %d (%s), adj %hd, size %d\n",
 			     selected->pid, selected->comm,
 			     selected_oom_score_adj, selected_tasksize);
+
+		trace_lowmem_kill(selected,  other_file, minfree, min_score_adj, other_free);
+		
 		lowmem_deathpending_timeout = jiffies + HZ;
 		/*
 		 * FIXME: lowmemorykiller shouldn't abuse global OOM killer
diff --git a/drivers/staging/android/switch/Kconfig b/drivers/staging/android/switch/Kconfig
new file mode 100755
index 0000000..6756cbf
--- /dev/null
+++ b/drivers/staging/android/switch/Kconfig
@@ -0,0 +1,11 @@
+menuconfig ANDROID_SWITCH
+	tristate "Android Switch class support"
+	help
+	  Say Y here to enable Android switch class support. This allows
+	  monitoring switches by userspace via sysfs and uevent.
+
+config ANDROID_SWITCH_GPIO
+	tristate "Android GPIO Switch support"
+	depends on GPIOLIB && ANDROID_SWITCH
+	help
+	  Say Y here to enable GPIO based switch support.
diff --git a/drivers/staging/android/switch/Makefile b/drivers/staging/android/switch/Makefile
new file mode 100755
index 0000000..d76bfdc
--- /dev/null
+++ b/drivers/staging/android/switch/Makefile
@@ -0,0 +1,4 @@
+# Android Switch Class Driver
+obj-$(CONFIG_ANDROID_SWITCH)		+= switch_class.o
+obj-$(CONFIG_ANDROID_SWITCH_GPIO)	+= switch_gpio.o
+
diff --git a/drivers/staging/android/switch/switch.h b/drivers/staging/android/switch/switch.h
new file mode 100755
index 0000000..4fcb310
--- /dev/null
+++ b/drivers/staging/android/switch/switch.h
@@ -0,0 +1,53 @@
+/*
+ *  Switch class driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef __LINUX_SWITCH_H__
+#define __LINUX_SWITCH_H__
+
+struct switch_dev {
+	const char	*name;
+	struct device	*dev;
+	int		index;
+	int		state;
+
+	ssize_t	(*print_name)(struct switch_dev *sdev, char *buf);
+	ssize_t	(*print_state)(struct switch_dev *sdev, char *buf);
+};
+
+struct gpio_switch_platform_data {
+	const char *name;
+	unsigned	gpio;
+
+	/* if NULL, switch_dev.name will be printed */
+	const char *name_on;
+	const char *name_off;
+	/* if NULL, "0" or "1" will be printed */
+	const char *state_on;
+	const char *state_off;
+};
+
+extern int switch_dev_register(struct switch_dev *sdev);
+extern void switch_dev_unregister(struct switch_dev *sdev);
+
+static inline int switch_get_state(struct switch_dev *sdev)
+{
+	return sdev->state;
+}
+
+extern void switch_set_state(struct switch_dev *sdev, int state);
+
+#endif /* __LINUX_SWITCH_H__ */
diff --git a/drivers/staging/android/switch/switch_class.c b/drivers/staging/android/switch/switch_class.c
new file mode 100755
index 0000000..d4b691b
--- /dev/null
+++ b/drivers/staging/android/switch/switch_class.c
@@ -0,0 +1,174 @@
+/*
+ * switch_class.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/err.h>
+#include "switch.h"
+
+struct class *switch_class;
+static atomic_t device_count;
+
+static ssize_t state_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct switch_dev *sdev = (struct switch_dev *)
+		dev_get_drvdata(dev);
+
+	if (sdev->print_state) {
+		int ret = sdev->print_state(sdev, buf);
+		if (ret >= 0)
+			return ret;
+	}
+	return sprintf(buf, "%d\n", sdev->state);
+}
+
+static ssize_t name_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct switch_dev *sdev = (struct switch_dev *)
+		dev_get_drvdata(dev);
+
+	if (sdev->print_name) {
+		int ret = sdev->print_name(sdev, buf);
+		if (ret >= 0)
+			return ret;
+	}
+	return sprintf(buf, "%s\n", sdev->name);
+}
+
+static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
+static DEVICE_ATTR(name, S_IRUGO, name_show, NULL);
+
+void switch_set_state(struct switch_dev *sdev, int state)
+{
+	char name_buf[120];
+	char state_buf[120];
+	char *prop_buf;
+	char *envp[3];
+	int env_offset = 0;
+	int length;
+
+	if (sdev->state != state) {
+		sdev->state = state;
+
+		prop_buf = (char *)get_zeroed_page(GFP_KERNEL);
+		if (prop_buf) {
+			length = name_show(sdev->dev, NULL, prop_buf);
+			if (length > 0) {
+				if (prop_buf[length - 1] == '\n')
+					prop_buf[length - 1] = 0;
+				snprintf(name_buf, sizeof(name_buf),
+					"SWITCH_NAME=%s", prop_buf);
+				envp[env_offset++] = name_buf;
+			}
+			length = state_show(sdev->dev, NULL, prop_buf);
+			if (length > 0) {
+				if (prop_buf[length - 1] == '\n')
+					prop_buf[length - 1] = 0;
+				snprintf(state_buf, sizeof(state_buf),
+					"SWITCH_STATE=%s", prop_buf);
+				envp[env_offset++] = state_buf;
+			}
+			envp[env_offset] = NULL;
+			kobject_uevent_env(&sdev->dev->kobj, KOBJ_CHANGE, envp);
+			free_page((unsigned long)prop_buf);
+		} else {
+			printk(KERN_ERR "out of memory in switch_set_state\n");
+			kobject_uevent(&sdev->dev->kobj, KOBJ_CHANGE);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(switch_set_state);
+
+static int create_switch_class(void)
+{
+	if (!switch_class) {
+		switch_class = class_create(THIS_MODULE, "switch");
+		if (IS_ERR(switch_class))
+			return PTR_ERR(switch_class);
+		atomic_set(&device_count, 0);
+	}
+
+	return 0;
+}
+
+int switch_dev_register(struct switch_dev *sdev)
+{
+	int ret;
+
+	if (!switch_class) {
+		ret = create_switch_class();
+		if (ret < 0)
+			return ret;
+	}
+
+	sdev->index = atomic_inc_return(&device_count);
+	sdev->dev = device_create(switch_class, NULL,
+		MKDEV(0, sdev->index), NULL, sdev->name);
+	if (IS_ERR(sdev->dev))
+		return PTR_ERR(sdev->dev);
+
+	ret = device_create_file(sdev->dev, &dev_attr_state);
+	if (ret < 0)
+		goto err_create_file_1;
+	ret = device_create_file(sdev->dev, &dev_attr_name);
+	if (ret < 0)
+		goto err_create_file_2;
+
+	dev_set_drvdata(sdev->dev, sdev);
+	sdev->state = 0;
+	return 0;
+
+err_create_file_2:
+	device_remove_file(sdev->dev, &dev_attr_state);
+err_create_file_1:
+	device_destroy(switch_class, MKDEV(0, sdev->index));
+	printk(KERN_ERR "switch: Failed to register driver %s\n", sdev->name);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(switch_dev_register);
+
+void switch_dev_unregister(struct switch_dev *sdev)
+{
+	device_remove_file(sdev->dev, &dev_attr_name);
+	device_remove_file(sdev->dev, &dev_attr_state);
+	device_destroy(switch_class, MKDEV(0, sdev->index));
+	dev_set_drvdata(sdev->dev, NULL);
+}
+EXPORT_SYMBOL_GPL(switch_dev_unregister);
+
+static int __init switch_class_init(void)
+{
+	return create_switch_class();
+}
+
+static void __exit switch_class_exit(void)
+{
+	class_destroy(switch_class);
+}
+
+module_init(switch_class_init);
+module_exit(switch_class_exit);
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("Switch class driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/android/switch/switch_gpio.c b/drivers/staging/android/switch/switch_gpio.c
new file mode 100755
index 0000000..31824c0
--- /dev/null
+++ b/drivers/staging/android/switch/switch_gpio.c
@@ -0,0 +1,172 @@
+/*
+ * switch_gpio.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include "switch.h"
+
+struct gpio_switch_data {
+	struct switch_dev sdev;
+	unsigned gpio;
+	const char *name_on;
+	const char *name_off;
+	const char *state_on;
+	const char *state_off;
+	int irq;
+	struct work_struct work;
+};
+
+static void gpio_switch_work(struct work_struct *work)
+{
+	int state;
+	struct gpio_switch_data	*data =
+		container_of(work, struct gpio_switch_data, work);
+
+	state = gpio_get_value(data->gpio);
+	switch_set_state(&data->sdev, state);
+}
+
+static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_switch_data *switch_data =
+	    (struct gpio_switch_data *)dev_id;
+
+	schedule_work(&switch_data->work);
+	return IRQ_HANDLED;
+}
+
+static ssize_t switch_gpio_print_state(struct switch_dev *sdev, char *buf)
+{
+	struct gpio_switch_data	*switch_data =
+		container_of(sdev, struct gpio_switch_data, sdev);
+	const char *state;
+	if (switch_get_state(sdev))
+		state = switch_data->state_on;
+	else
+		state = switch_data->state_off;
+
+	if (state)
+		return sprintf(buf, "%s\n", state);
+	return -1;
+}
+
+static int gpio_switch_probe(struct platform_device *pdev)
+{
+	struct gpio_switch_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_switch_data *switch_data;
+	int ret = 0;
+
+	if (!pdata)
+		return -EBUSY;
+
+	switch_data = kzalloc(sizeof(struct gpio_switch_data), GFP_KERNEL);
+	if (!switch_data)
+		return -ENOMEM;
+
+	switch_data->sdev.name = pdata->name;
+	switch_data->gpio = pdata->gpio;
+	switch_data->name_on = pdata->name_on;
+	switch_data->name_off = pdata->name_off;
+	switch_data->state_on = pdata->state_on;
+	switch_data->state_off = pdata->state_off;
+	switch_data->sdev.print_state = switch_gpio_print_state;
+
+	ret = switch_dev_register(&switch_data->sdev);
+	if (ret < 0)
+		goto err_switch_dev_register;
+
+	ret = gpio_request(switch_data->gpio, pdev->name);
+	if (ret < 0)
+		goto err_request_gpio;
+
+	ret = gpio_direction_input(switch_data->gpio);
+	if (ret < 0)
+		goto err_set_gpio_input;
+
+	INIT_WORK(&switch_data->work, gpio_switch_work);
+
+	switch_data->irq = gpio_to_irq(switch_data->gpio);
+	if (switch_data->irq < 0) {
+		ret = switch_data->irq;
+		goto err_detect_irq_num_failed;
+	}
+
+	ret = request_irq(switch_data->irq, gpio_irq_handler,
+			  IRQF_TRIGGER_LOW, pdev->name, switch_data);
+	if (ret < 0)
+		goto err_request_irq;
+
+	/* Perform initial detection */
+	gpio_switch_work(&switch_data->work);
+
+	return 0;
+
+err_request_irq:
+err_detect_irq_num_failed:
+err_set_gpio_input:
+	gpio_free(switch_data->gpio);
+err_request_gpio:
+	switch_dev_unregister(&switch_data->sdev);
+err_switch_dev_register:
+	kfree(switch_data);
+
+	return ret;
+}
+
+static int gpio_switch_remove(struct platform_device *pdev)
+{
+	struct gpio_switch_data *switch_data = platform_get_drvdata(pdev);
+
+	cancel_work_sync(&switch_data->work);
+	gpio_free(switch_data->gpio);
+	switch_dev_unregister(&switch_data->sdev);
+	kfree(switch_data);
+
+	return 0;
+}
+
+static struct platform_driver gpio_switch_driver = {
+	.probe		= gpio_switch_probe,
+	.remove		= gpio_switch_remove,
+	.driver		= {
+		.name	= "switch-gpio",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init gpio_switch_init(void)
+{
+	return platform_driver_register(&gpio_switch_driver);
+}
+
+static void __exit gpio_switch_exit(void)
+{
+	platform_driver_unregister(&gpio_switch_driver);
+}
+
+module_init(gpio_switch_init);
+module_exit(gpio_switch_exit);
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("GPIO Switch driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/android/uapi/ion-owl.h b/drivers/staging/android/uapi/ion-owl.h
new file mode 100755
index 0000000..cbe732e
--- /dev/null
+++ b/drivers/staging/android/uapi/ion-owl.h
@@ -0,0 +1,51 @@
+/*
+ * include/linux/ion-owl.h
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#if !defined(__KERNEL__)
+#define __user
+#endif
+
+#ifndef _UAPI_LINUX_ION_OWL_H
+#define _UAPI_LINUX_ION_OWL_H
+
+#include <linux/types.h>
+
+/* for cmd OWL_ION_GET_PHY */
+struct owl_ion_phys_data {
+	ion_user_handle_t handle;
+	unsigned long phys_addr;
+	size_t size;
+};
+
+/* Custom Ioctl's. */
+enum {
+	OWL_ION_GET_PHY = 0,
+};
+
+/**
+ * These are the only ids that should be used for Ion heap ids.
+ * The ids listed are the order in which allocation will be attempted
+ * if specified. Don't swap the order of heap ids unless you know what
+ * you are doing!
+ * Id's are spaced by purpose to allow new Id's to be inserted in-between (for
+ * possible fallbacks)
+ */
+
+enum ion_heap_ids {
+	ION_HEAP_ID_INVALID = -1,
+	ION_HEAP_ID_PMEM = 0,
+	ION_HEAP_ID_FB = 8,
+	ION_HEAP_ID_SYSTEM = 12,
+	ION_HEAP_ID_RESERVED = 31 /** Bit reserved for ION_SECURE flag */
+};
+
+#endif /* _UAPI_LINUX_ION_OWL_H */
diff --git a/drivers/staging/android/uapi/ion.h b/drivers/staging/android/uapi/ion.h
old mode 100644
new mode 100755
index 6aa4956..125d396
--- a/drivers/staging/android/uapi/ion.h
+++ b/drivers/staging/android/uapi/ion.h
@@ -127,6 +127,26 @@ struct ion_custom_data {
 	unsigned long arg;
 };
 
+/** struct ion_flush_data - data passed to ion for flushing caches
+ *
+ * @handle:	handle with data to flush
+ * @fd:		fd to flush
+ * @vaddr:	userspace virtual address mapped with mmap
+ * @offset:	offset into the handle to flush
+ * @length:	length of handle to flush
+ *
+ * Performs cache operations on the handle. If p is the start address
+ * of the handle, p + offset through p + offset + length will have
+ * the cache operations performed
+ */
+struct ion_flush_data {
+	void *handle; /* no used, kept for compatibility */
+	int fd;
+	void *vaddr;
+	unsigned int offset;
+	unsigned int length;
+};
+
 #define ION_IOC_MAGIC		'I'
 
 /**
@@ -193,4 +213,28 @@ struct ion_custom_data {
  */
 #define ION_IOC_CUSTOM		_IOWR(ION_IOC_MAGIC, 6, struct ion_custom_data)
 
+
+/**
+ * DOC: ION_IOC_CLEAN_CACHES - clean the caches
+ *
+ * Clean the caches of the handle specified.
+ */
+#define ION_IOC_CLEAN_CACHES	_IOWR(ION_IOC_MAGIC, 20, \
+						struct ion_flush_data)
+/**
+ * DOC: ION_MSM_IOC_INV_CACHES - invalidate the caches
+ *
+ * Invalidate the caches of the handle specified.
+ */
+#define ION_IOC_INV_CACHES	_IOWR(ION_IOC_MAGIC, 21, \
+						struct ion_flush_data)
+/**
+ * DOC: ION_MSM_IOC_CLEAN_CACHES - clean and invalidate the caches
+ *
+ * Clean and invalidate the caches of the handle specified.
+ */
+#define ION_IOC_CLEAN_INV_CACHES	_IOWR(ION_IOC_MAGIC, 22, \
+						struct ion_flush_data)
+
+
 #endif /* _UAPI_LINUX_ION_H */
diff --git a/include/asm-generic/dma-mapping-common.h b/include/asm-generic/dma-mapping-common.h
old mode 100644
new mode 100755
index 940d5ec..0accd29
--- a/include/asm-generic/dma-mapping-common.h
+++ b/include/asm-generic/dma-mapping-common.h
@@ -219,6 +219,18 @@ dma_mmap_attrs(struct device *dev, struct vm_area_struct *vma, void *cpu_addr,
 
 #define dma_mmap_coherent(d, v, c, h, s) dma_mmap_attrs(d, v, c, h, s, NULL)
 
+/* add by actions */
+static inline int dma_mmap_noncoherent(struct device *dev, struct vm_area_struct *vma,
+		      void *cpu_addr, dma_addr_t dma_addr, size_t size)
+{
+	/* 原生的内核arm dma-mapping.c中的arm_dma_alloc是不管DMA_ATTR_NON_CONSISTENT的,
+	 * 为了实现ion_cma_heap能分到cached的buffer, 现在更改为碰到
+	 * DMA_ATTR_NON_CONSISTENT就建立cache覆盖的mapping. */
+	DEFINE_DMA_ATTRS(attrs);
+	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+	return dma_mmap_attrs(dev, vma, cpu_addr, dma_addr, size, &attrs);
+}
+
 int
 dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,
 		       void *cpu_addr, dma_addr_t dma_addr, size_t size);
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
old mode 100644
new mode 100755
index 15f5d2e..24317f5
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -490,6 +490,11 @@ struct request_queue {
 	struct list_head	tag_set_list;
 };
 
+struct uparam {
+	unsigned int flash_partition;
+	unsigned int devnum_in_phypart;
+};
+
 #define QUEUE_FLAG_QUEUED	1	/* uses generic tag queueing */
 #define QUEUE_FLAG_STOPPED	2	/* queue is stopped */
 #define	QUEUE_FLAG_SYNCFULL	3	/* read queue has been filled */
@@ -1095,7 +1100,7 @@ struct blk_plug {
 	struct list_head mq_list; /* blk-mq requests */
 	struct list_head cb_list; /* md requires an unplug callback */
 };
-#define BLK_MAX_REQUEST_COUNT 16
+#define BLK_MAX_REQUEST_COUNT 1
 
 struct blk_plug_cb;
 typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);
@@ -1616,6 +1621,17 @@ struct block_device_operations {
 	/* this callback is with swap_lock and sometimes page table lock held */
 	void (*swap_slot_free_notify) (struct block_device *, unsigned long);
 	struct module *owner;
+
+	/*
+	* following code added by actions 2012-07-09
+	*/
+	unsigned int (*blk_read)(unsigned long, unsigned long, void * ,struct inode *);
+	unsigned int (*blk_write)(unsigned long, unsigned long, void * ,struct inode *);
+
+	int (*adfu_read)(unsigned long start, unsigned long nsector, void *buf, struct uparam * i);
+	int (*adfu_write)(unsigned long start, unsigned long nsector, void *buf, struct uparam * i); 	
+	
+	void (*flush_disk_cache)(void);
 };
 
 extern int __blkdev_driver_ioctl(struct block_device *, fmode_t, unsigned int,
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index df69531..115673b 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -571,7 +571,11 @@ struct clk *__clk_get_parent(struct clk *clk);
 struct clk *clk_get_parent_by_index(struct clk *clk, u8 index);
 unsigned int __clk_get_enable_count(struct clk *clk);
 unsigned long __clk_get_rate(struct clk *clk);
+unsigned long __clk_get_newrate(struct clk *clk);
 unsigned long __clk_get_flags(struct clk *clk);
+void __clk_set_flags(struct clk *clk, unsigned long flags);
+const struct clk_ops *__clk_get_ops(struct clk *clk);
+void __clk_set_ops(struct clk *clk, const struct clk_ops *clk_ops);
 bool __clk_is_prepared(struct clk *clk);
 bool __clk_is_enabled(struct clk *clk);
 struct clk *__clk_lookup(const char *name);
diff --git a/include/linux/dma-contiguous.h b/include/linux/dma-contiguous.h
old mode 100644
new mode 100755
index 569bbd0..af1e8c8
--- a/include/linux/dma-contiguous.h
+++ b/include/linux/dma-contiguous.h
@@ -62,6 +62,7 @@ struct page;
 
 extern struct cma *dma_contiguous_default_area;
 
+void dma_contiguous_set_global_reserve_size(phys_addr_t new_size); /* add by actions */
 static inline struct cma *dev_get_cma_area(struct device *dev)
 {
 	if (dev && dev->cma_area)
@@ -127,6 +128,7 @@ static inline void dev_set_cma_area(struct device *dev, struct cma *cma) { }
 
 static inline void dma_contiguous_set_default(struct cma *cma) { }
 
+static inline void dma_contiguous_set_global_reserve_size(phys_addr_t new_size) { }  /* add by actions */
 static inline void dma_contiguous_reserve(phys_addr_t limit) { }
 
 static inline int dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index ad41975..51c85c9 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -675,6 +675,9 @@ struct dma_device {
 	int (*device_pause)(struct dma_chan *chan);
 	int (*device_resume)(struct dma_chan *chan);
 	int (*device_terminate_all)(struct dma_chan *chan);
+	int (*fsldma_external_start0)(struct dma_chan *chan);
+	int (*fsldma_external_start1)(struct dma_chan *chan);
+	int (*fsldma_external_start2)(struct dma_chan *chan);
 
 	enum dma_status (*device_tx_status)(struct dma_chan *chan,
 					    dma_cookie_t cookie,
diff --git a/include/linux/earlysuspend.h b/include/linux/earlysuspend.h
new file mode 100755
index 0000000..8343b81
--- /dev/null
+++ b/include/linux/earlysuspend.h
@@ -0,0 +1,56 @@
+/* include/linux/earlysuspend.h
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_EARLYSUSPEND_H
+#define _LINUX_EARLYSUSPEND_H
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/list.h>
+#endif
+
+/* The early_suspend structure defines suspend and resume hooks to be called
+ * when the user visible sleep state of the system changes, and a level to
+ * control the order. They can be used to turn off the screen and input
+ * devices that are not used for wakeup.
+ * Suspend handlers are called in low to high level order, resume handlers are
+ * called in the opposite order. If, when calling register_early_suspend,
+ * the suspend handlers have already been called without a matching call to the
+ * resume handlers, the suspend handler will be called directly from
+ * register_early_suspend. This direct call can violate the normal level order.
+ */
+enum {
+	EARLY_SUSPEND_LEVEL_BLANK_SCREEN = 50,
+	EARLY_SUSPEND_LEVEL_STOP_DRAWING = 100,
+	EARLY_SUSPEND_LEVEL_DISABLE_FB = 150,
+};
+struct early_suspend {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct list_head link;
+	int level;
+	void (*suspend)(struct early_suspend *h);
+	void (*resume)(struct early_suspend *h);
+#endif
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void register_early_suspend(struct early_suspend *handler);
+void unregister_early_suspend(struct early_suspend *handler);
+#else
+#define register_early_suspend(handler) do { } while (0)
+#define unregister_early_suspend(handler) do { } while (0)
+#endif
+
+#endif
+
diff --git a/include/linux/fs.h b/include/linux/fs.h
old mode 100644
new mode 100755
diff --git a/include/linux/ion.h b/include/linux/ion.h
new file mode 100755
index 0000000..e775838
--- /dev/null
+++ b/include/linux/ion.h
@@ -0,0 +1,17 @@
+/*
+ * include/linux/ion.h
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <../drivers/staging/android/ion/ion.h>
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
old mode 100644
new mode 100755
index 54d74f6..d1dcdef
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -519,6 +519,20 @@ struct zone {
 	int			compact_order_failed;
 #endif
 
+#ifdef CONFIG_CMA
+	unsigned long managed_cma_pages;
+	/*
+	 * Number of allocation attempt on each movable/cma type
+	 * without switching type. max_try(movable/cma) maintain
+	 * predefined calculated counter and replenish nr_try_(movable/cma)
+	 * with each of them whenever both of them are 0.
+	 */
+	int nr_try_movable;
+	int nr_try_cma;
+	int max_try_movable;
+	int max_try_cma;
+#endif
+
 #if defined CONFIG_COMPACTION || defined CONFIG_CMA
 	/* Set to true when the PG_migrate_skip bits should be cleared */
 	bool			compact_blockskip_flush;
diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
old mode 100644
new mode 100755
index 66e4697..293da9e
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -38,7 +38,7 @@ struct device_node;
 struct pinctrl_pin_desc {
 	unsigned number;
 	const char *name;
-	void *drv_data;
+//	void *drv_data;
 };
 
 /* Convenience macro to define a single named or anonymous pin descriptor */
diff --git a/include/trace/events/stand_hotplug.h b/include/trace/events/stand_hotplug.h
new file mode 100755
index 0000000..caab76b
--- /dev/null
+++ b/include/trace/events/stand_hotplug.h
@@ -0,0 +1,93 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM stand_hotplug
+
+#if !defined(_TRACE_STAND_HOTPLUG_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_STAND_HOTPLUG_H
+
+#include <linux/tracepoint.h>
+
+DECLARE_EVENT_CLASS(plug_in,
+	    TP_PROTO(unsigned long type, unsigned long hotpluging_rate, unsigned long avg_load,
+		     unsigned long nr_online_cpu, unsigned long nr_running,
+		     unsigned long cur_freq, unsigned long freq_min),
+	    TP_ARGS(type, hotpluging_rate, avg_load, nr_online_cpu, nr_running, cur_freq, freq_min),
+
+	    TP_STRUCT__entry(
+		    __field(unsigned long, type    )
+			__field(unsigned long, hotpluging_rate    )
+		    __field(unsigned long, avg_load      )
+		    __field(unsigned long, nr_online_cpu   )
+		    __field(unsigned long, nr_running )
+		    __field(unsigned long, cur_freq   )
+			__field(unsigned long, freq_min   )
+	    ),
+
+	    TP_fast_assign(
+		    __entry->type = type;
+			__entry->hotpluging_rate = hotpluging_rate;
+		    __entry->avg_load = avg_load;
+		    __entry->nr_online_cpu = nr_online_cpu;
+		    __entry->nr_running = nr_running;
+		    __entry->cur_freq = cur_freq;
+			__entry->freq_min = freq_min;
+	    ),
+	
+	    TP_printk("type=%lu hotpluging_rate=%lu avg_load=%lu nr_online_cpu=%lu nr_running=%lu cur_freq=%lu freq_min=%lu",
+		      __entry->type, __entry->hotpluging_rate, __entry->avg_load, __entry->nr_online_cpu,
+		      __entry->nr_running, __entry->cur_freq, __entry->freq_min)
+);
+
+DEFINE_EVENT(plug_in, stand_hotplug_in,
+	    TP_PROTO(unsigned long type, unsigned long hotpluging_rate, unsigned long avg_load,
+		     unsigned long nr_online_cpu, unsigned long nr_running,
+		     unsigned long cur_freq, unsigned long freq_min),
+	    TP_ARGS(type, hotpluging_rate, avg_load, nr_online_cpu, nr_running, cur_freq, freq_min)
+);
+
+DECLARE_EVENT_CLASS(plug_out,
+	    TP_PROTO(unsigned long type, unsigned long hotpluging_rate, unsigned long avg_load,
+		     unsigned long nr_online_cpu, unsigned long down_count,
+		     unsigned long load_min, unsigned long cur_freq,
+			 unsigned long freq_min),
+	    TP_ARGS(type, hotpluging_rate, avg_load, nr_online_cpu, down_count, load_min, cur_freq, freq_min),
+
+	    TP_STRUCT__entry(
+		    __field(unsigned long, type    )
+			__field(unsigned long, hotpluging_rate    )
+		    __field(unsigned long, avg_load      )
+		    __field(unsigned long, nr_online_cpu   )
+		    __field(unsigned long, down_count )
+		    __field(unsigned long, load_min   )
+			__field(unsigned long, cur_freq   )
+			__field(unsigned long, freq_min   )
+	    ),
+
+	    TP_fast_assign(
+		    __entry->type = type;
+			__entry->hotpluging_rate = hotpluging_rate;
+		    __entry->avg_load = avg_load;
+		    __entry->nr_online_cpu = nr_online_cpu;
+		    __entry->down_count = down_count;
+		    __entry->load_min = load_min;
+			__entry->cur_freq = cur_freq;
+			__entry->freq_min = freq_min;
+	    ),
+		
+		TP_printk("type=%lu hotpluging_rate=%lu avg_load=%lu nr_online_cpu=%lu down_count=%lu load_min=%lu cur_freq=%lu freq_min=%lu",
+			  __entry->type, __entry->hotpluging_rate, __entry->avg_load, __entry->nr_online_cpu,
+			  __entry->down_count, __entry->load_min, __entry->cur_freq, __entry->freq_min)
+);
+
+DEFINE_EVENT(plug_out, stand_hotplug_out,
+	    TP_PROTO(unsigned long type, unsigned long hotpluging_rate, unsigned long avg_load,
+		     unsigned long nr_online_cpu, unsigned long down_count,
+		     unsigned long load_min, unsigned long cur_freq,
+			 unsigned long freq_min),
+	    TP_ARGS(type, hotpluging_rate, avg_load, nr_online_cpu, down_count, load_min, cur_freq, freq_min)
+);
+
+
+#endif /* _TRACE_STAND_HOTPLUG_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/uapi/linux/serial_core.h b/include/uapi/linux/serial_core.h
old mode 100644
new mode 100755
index b212281..f4b8399
--- a/include/uapi/linux/serial_core.h
+++ b/include/uapi/linux/serial_core.h
@@ -225,6 +225,9 @@
 /* ARC (Synopsys) on-chip UART */
 #define PORT_ARC       101
 
+/* Actions SOC UART */
+#define PORT_OWL       200
+
 /* Rocketport EXPRESS/INFINITY */
 #define PORT_RP2	102
 
diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig
old mode 100644
new mode 100755
index 9e30231..a6dd21d
--- a/kernel/power/Kconfig
+++ b/kernel/power/Kconfig
@@ -18,6 +18,17 @@ config SUSPEND_FREEZER
 
 	  Turning OFF this setting is NOT recommended! If in doubt, say Y.
 
+config HAS_EARLYSUSPEND
+	bool
+
+config EARLYSUSPEND
+	bool "Early suspend"
+	depends on WAKELOCK && PM_AUTOSLEEP
+	default n
+	select HAS_EARLYSUSPEND
+	---help---
+	  Call early suspend handlers when the user requested sleep state
+	  changes.
 config HIBERNATE_CALLBACKS
 	bool
 
diff --git a/kernel/power/Makefile b/kernel/power/Makefile
old mode 100644
new mode 100755
index 29472bf..ea00b9a
--- a/kernel/power/Makefile
+++ b/kernel/power/Makefile
@@ -13,3 +13,5 @@ obj-$(CONFIG_PM_AUTOSLEEP)	+= autosleep.o
 obj-$(CONFIG_PM_WAKELOCKS)	+= wakelock.o
 
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
+
+obj-$(CONFIG_EARLYSUSPEND)	+= earlysuspend.o
diff --git a/kernel/power/earlysuspend.c b/kernel/power/earlysuspend.c
new file mode 100755
index 0000000..5e6b6e3
--- /dev/null
+++ b/kernel/power/earlysuspend.c
@@ -0,0 +1,231 @@
+/* kernel/power/earlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/rtc.h>
+#include <linux/syscalls.h> /* sys_sync */
+#include <linux/wakelock.h>
+#include <linux/workqueue.h>
+
+#include "power.h"
+
+enum {
+	DEBUG_USER_STATE = 1U << 0,
+	DEBUG_SUSPEND = 1U << 2,
+	DEBUG_VERBOSE = 1U << 3,
+};
+static int debug_mask = DEBUG_USER_STATE;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+static DEFINE_MUTEX(early_suspend_lock);
+static LIST_HEAD(early_suspend_handlers);
+static void sync_system(struct work_struct *work);
+static void early_suspend(struct work_struct *work);
+static void late_resume(struct work_struct *work);
+static DECLARE_WORK(sync_system_work, sync_system);
+static DECLARE_WORK(early_suspend_work, early_suspend);
+static DECLARE_WORK(late_resume_work, late_resume);
+struct wake_lock sys_sync_wake_lock;
+struct workqueue_struct *suspend_work_queue;
+struct workqueue_struct *sys_sync_work_queue;
+suspend_state_t requested_suspend_state = PM_SUSPEND_MEM;
+enum {
+	SUSPEND_REQUESTED = 0x1,
+	SUSPENDED = 0x2,
+	SUSPEND_REQUESTED_AND_SUSPENDED = SUSPEND_REQUESTED | SUSPENDED,
+};
+static int state;
+
+void register_early_suspend(struct early_suspend *handler)
+{
+	struct list_head *pos;
+
+	mutex_lock(&early_suspend_lock);
+	list_for_each(pos, &early_suspend_handlers) {
+		struct early_suspend *e;
+		e = list_entry(pos, struct early_suspend, link);
+		if (e->level > handler->level)
+			break;
+	}
+	list_add_tail(&handler->link, pos);
+	if ((state & SUSPENDED) && handler->suspend)
+		handler->suspend(handler);
+	mutex_unlock(&early_suspend_lock);
+}
+EXPORT_SYMBOL(register_early_suspend);
+
+void unregister_early_suspend(struct early_suspend *handler)
+{
+	mutex_lock(&early_suspend_lock);
+	list_del(&handler->link);
+	mutex_unlock(&early_suspend_lock);
+}
+EXPORT_SYMBOL(unregister_early_suspend);
+
+static void sync_system(struct work_struct *work)
+{
+	printk("%s +\n", __func__);
+    wake_lock(&sys_sync_wake_lock);
+	sys_sync();
+    wake_unlock(&sys_sync_wake_lock);
+	printk("%s -\n", __func__);
+}
+static void early_suspend(struct work_struct *work)
+{
+	struct early_suspend *pos;
+	int abort = 0;
+
+	mutex_lock(&early_suspend_lock);
+	if (state == SUSPEND_REQUESTED)
+		state |= SUSPENDED;
+	else
+		abort = 1;
+
+	if (abort) {
+		if (debug_mask & DEBUG_SUSPEND)
+			printk("early_suspend: abort, state %d\n", state);
+		mutex_unlock(&early_suspend_lock);
+		goto abort;
+	}
+
+	if (debug_mask & DEBUG_SUSPEND)
+		printk("early_suspend: call handlers\n");
+	list_for_each_entry(pos, &early_suspend_handlers, link) {
+		if (pos->suspend != NULL) {
+			if (debug_mask & DEBUG_VERBOSE)
+				printk("early_suspend: calling %pf\n", pos->suspend);
+			pos->suspend(pos);
+		}
+	}
+	mutex_unlock(&early_suspend_lock);
+
+	if (debug_mask & DEBUG_SUSPEND)
+		printk("early_suspend: sync\n");
+
+	/* sys_sync(); */
+	queue_work(sys_sync_work_queue, &sync_system_work);
+
+abort:
+#ifdef CONFIG_PLATFORM_UBUNTU
+	pm_suspend(PM_SUSPEND_MEM);
+	request_suspend_state(PM_SUSPEND_ON);
+#else
+	if (state == SUSPEND_REQUESTED_AND_SUSPENDED)
+		pm_autosleep_set_state(PM_SUSPEND_MEM);
+#endif
+}
+
+static void late_resume(struct work_struct *work)
+{
+	struct early_suspend *pos;
+	int abort = 0;
+
+	mutex_lock(&early_suspend_lock);
+	if (state == SUSPENDED)
+		state &= ~SUSPENDED;
+	else
+		abort = 1;
+
+	if (abort) {
+		if (debug_mask & DEBUG_SUSPEND)
+			printk("late_resume: abort, state %d\n", state);
+		goto abort;
+	}
+	if (debug_mask & DEBUG_SUSPEND)
+		printk("late_resume: call handlers\n");
+	list_for_each_entry_reverse(pos, &early_suspend_handlers, link) {
+		if (pos->resume != NULL) {
+			if (debug_mask & DEBUG_VERBOSE)
+				printk("late_resume: calling %pf\n", pos->resume);
+
+			pos->resume(pos);
+		}
+	}
+	if (debug_mask & DEBUG_SUSPEND)
+		printk("late_resume: done\n");
+abort:
+	mutex_unlock(&early_suspend_lock);
+}
+
+void request_suspend_state(suspend_state_t new_state)
+{
+/* 	unsigned long irqflags; */
+	int old_sleep;
+
+	mutex_lock(&early_suspend_lock);
+	old_sleep = state & SUSPEND_REQUESTED;
+	if (debug_mask & DEBUG_USER_STATE) {
+		struct timespec ts;
+		struct rtc_time tm;
+		getnstimeofday(&ts);
+		rtc_time_to_tm(ts.tv_sec, &tm);
+		printk("request_suspend_state: %s (%d->%d) at %lld "
+			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n",
+			new_state != PM_SUSPEND_ON ? "sleep" : "wakeup",
+			requested_suspend_state, new_state,
+			ktime_to_ns(ktime_get()),
+			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+	}
+	if (!old_sleep && new_state != PM_SUSPEND_ON) {
+		state |= SUSPEND_REQUESTED;
+		queue_work(suspend_work_queue, &early_suspend_work);
+	} else if (old_sleep && new_state == PM_SUSPEND_ON) {
+		state &= ~SUSPEND_REQUESTED;
+		//wake_lock(&main_wake_lock);
+		queue_work(suspend_work_queue, &late_resume_work);
+	}
+	requested_suspend_state = new_state;
+	mutex_unlock(&early_suspend_lock);
+}
+
+suspend_state_t get_suspend_state(void)
+{
+	return requested_suspend_state;
+}
+
+static int __init wakelocks_init(void)
+{
+    int ret;
+   
+    wake_lock_init(&sys_sync_wake_lock, WAKE_LOCK_SUSPEND, "sys_sync");
+
+    sys_sync_work_queue = create_singlethread_workqueue("fs_sync");
+    if (sys_sync_work_queue == NULL) {
+        pr_err("[wakelocks_init] fs_sync workqueue create failed\n");
+    }
+
+    suspend_work_queue = create_singlethread_workqueue("suspend");
+    if (suspend_work_queue == NULL) {
+        ret = -ENOMEM;
+        goto err_suspend_work_queue;
+    }
+    return 0;
+
+err_suspend_work_queue:
+
+    return ret;
+}
+
+static void  __exit wakelocks_exit(void)
+{
+    destroy_workqueue(suspend_work_queue);
+    destroy_workqueue(sys_sync_work_queue);
+}
+
+core_initcall(wakelocks_init);
+module_exit(wakelocks_exit);
diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c
old mode 100644
new mode 100755
index 642c04f..0d7cf8b
--- a/kernel/power/hibernate.c
+++ b/kernel/power/hibernate.c
@@ -30,6 +30,7 @@
 #include <linux/genhd.h>
 #include <linux/ktime.h>
 #include <trace/events/power.h>
+#include <mach/power.h>
 
 #include "power.h"
 
@@ -296,6 +297,7 @@ static int create_image(int platform_mode)
 		goto Power_up;
 
 	in_suspend = 1;
+	owl_pm_do_save();
 	save_processor_state();
 	trace_suspend_resume(TPS("machine_suspend"), PM_EVENT_HIBERNATE, true);
 	error = swsusp_arch_suspend();
@@ -305,6 +307,7 @@ static int create_image(int platform_mode)
 	if (error)
 		printk(KERN_ERR "PM: Error %d creating hibernation image\n",
 			error);
+	owl_pm_do_restore();
 	if (!in_suspend)
 		events_check_enabled = false;
 
@@ -670,6 +673,7 @@ int hibernate(void)
 
 	printk(KERN_INFO "PM: Syncing filesystems ... ");
 	sys_sync();
+	fs_drop_page_caches();
 	printk("done.\n");
 
 	error = freeze_processes();
diff --git a/kernel/power/main.c b/kernel/power/main.c
old mode 100644
new mode 100755
index 86e8157..4f82416
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -277,6 +277,7 @@ static inline void pm_print_times_init(void) {}
 #endif /* CONFIG_PM_SLEEP_DEBUG */
 
 struct kobject *power_kobj;
+EXPORT_SYMBOL(power_kobj);
 
 /**
  * state - control system sleep states.
@@ -345,20 +346,23 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 	if (error)
 		return error;
 
-	if (pm_autosleep_state() > PM_SUSPEND_ON) {
-		error = -EBUSY;
-		goto out;
-	}
-
 	state = decode_state(buf, n);
-	if (state < PM_SUSPEND_MAX)
+	
+	if (state < PM_SUSPEND_MAX) {
+#ifdef CONFIG_EARLYSUSPEND
+		if (state == PM_SUSPEND_ON || valid_state(state)) {
+			error = 0;
+			request_suspend_state(state);
+		}
+#else
 		error = pm_suspend(state);
+#endif
+	}
 	else if (state == PM_SUSPEND_MAX)
 		error = hibernate();
 	else
 		error = -EINVAL;
 
- out:
 	pm_autosleep_unlock();
 	return error ? error : n;
 }
diff --git a/kernel/power/power.h b/kernel/power/power.h
old mode 100644
new mode 100755
index 1747657..908996c
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -12,6 +12,10 @@ struct swsusp_info {
 	unsigned long		image_pages;
 	unsigned long		pages;
 	unsigned long		size;
+	unsigned long		nosave_begin;
+	unsigned long		nosave_end;
+	unsigned long		swsusp_arch_resume_begin;
+	unsigned long		cpu_reset_begin;
 } __aligned(PAGE_SIZE);
 
 #ifdef CONFIG_HIBERNATION
@@ -297,3 +301,9 @@ extern int pm_wake_lock(const char *buf);
 extern int pm_wake_unlock(const char *buf);
 
 #endif /* !CONFIG_PM_WAKELOCKS */
+
+#ifdef CONFIG_EARLYSUSPEND
+/* kernel/power/earlysuspend.c */
+void request_suspend_state(suspend_state_t state);
+suspend_state_t get_suspend_state(void);
+#endif
diff --git a/kernel/power/snapshot.c b/kernel/power/snapshot.c
old mode 100644
new mode 100755
index 5235dd4..f7b8646
--- a/kernel/power/snapshot.c
+++ b/kernel/power/snapshot.c
@@ -35,6 +35,7 @@
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 #include <asm/io.h>
+#include <mach/power.h>
 
 #include "power.h"
 
@@ -42,6 +43,16 @@ static int swsusp_page_is_free(struct page *);
 static void swsusp_set_page_forbidden(struct page *);
 static void swsusp_unset_page_forbidden(struct page *);
 
+int pfn_is_nosave(unsigned long pfn)
+{
+	unsigned long nosave_begin_pfn =
+			__pa(__nosave_begin) >> PAGE_SHIFT;
+	unsigned long nosave_end_pfn =
+			PAGE_ALIGN(__pa(__nosave_end)) >> PAGE_SHIFT;
+
+	return ((pfn >= nosave_begin_pfn) && (pfn < nosave_end_pfn));
+}
+
 /*
  * Number of bytes to reserve for memory allocations made by device drivers
  * from their ->freeze() and ->freeze_noirq() callbacks so that they don't
@@ -1914,6 +1925,10 @@ static int init_header(struct swsusp_info *info)
 	info->pages = snapshot_get_image_size();
 	info->size = info->pages;
 	info->size <<= PAGE_SHIFT;
+	info->nosave_begin = (unsigned long)__nosave_begin;
+	info->nosave_end = (unsigned long)__nosave_end;
+	info->swsusp_arch_resume_begin = virt_to_phys(swsusp_arch_resume);
+	info->cpu_reset_begin = virt_to_phys(cpu_v7_reset);
 	return init_header_complete(info);
 }
 
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
old mode 100644
new mode 100755
index 8d7a1ef..704e16b
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -32,7 +32,11 @@
 
 #include "power.h"
 
-const char *pm_labels[] = { "mem", "standby", "freeze", NULL };
+#ifdef CONFIG_EARLYSUSPEND
+	const char *pm_labels[] = { "mem", "standby", "freeze", "on" };
+#else
+	const char *pm_labels[] = { "mem", "standby", "freeze", NULL };
+#endif
 const char *pm_states[PM_SUSPEND_MAX];
 
 static const struct platform_suspend_ops *suspend_ops;
@@ -373,6 +377,7 @@ static int suspend_enter(suspend_state_t state, bool *wakeup)
 	arch_suspend_enable_irqs();
 	BUG_ON(irqs_disabled());
 
+	outer_resume();
  Enable_cpus:
 	enable_nonboot_cpus();
 
diff --git a/kernel/power/swap.c b/kernel/power/swap.c
old mode 100644
new mode 100755
index 570aff8..aacc96d
--- a/kernel/power/swap.c
+++ b/kernel/power/swap.c
@@ -233,6 +233,7 @@ static int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)
 			swsusp_header->crc32 = handle->crc32;
 		error = hib_bio_write_page(swsusp_resume_block,
 					swsusp_header, NULL);
+		blkdev_ioctl(hib_resume_bdev, 0, BLKFLSBUF, 0);
 	} else {
 		printk(KERN_ERR "PM: Swap header not found!\n");
 		error = -ENODEV;
diff --git a/kernel/reboot.c b/kernel/reboot.c
old mode 100644
new mode 100755
index d20c85d..eabb258
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -203,6 +203,11 @@ void migrate_to_reboot_cpu(void)
 	set_cpus_allowed_ptr(current, cpumask_of(cpu));
 }
 
+#ifdef CONFIG_MACH_OWL
+void *owl_watchdog_start(int timeout, void (*callback)(unsigned long data), unsigned long data);
+void owl_watchdog_stop(void *owl_watchdog);
+#endif
+
 /**
  *	kernel_restart - reboot the system
  *	@cmd: pointer to buffer containing command to execute for restart
@@ -213,6 +218,9 @@ void migrate_to_reboot_cpu(void)
  */
 void kernel_restart(char *cmd)
 {
+#ifdef CONFIG_MACH_OWL
+	void *owl_watchdog = owl_watchdog_start(HZ * 20, NULL, 0);	//若20秒都没有关机成功就打印所有任务栈
+#endif
 	kernel_restart_prepare(cmd);
 	migrate_to_reboot_cpu();
 	syscore_shutdown();
@@ -222,6 +230,9 @@ void kernel_restart(char *cmd)
 		pr_emerg("Restarting system with command '%s'\n", cmd);
 	kmsg_dump(KMSG_DUMP_RESTART);
 	machine_restart(cmd);
+#ifdef CONFIG_MACH_OWL
+	owl_watchdog_stop(owl_watchdog);
+#endif
 }
 EXPORT_SYMBOL_GPL(kernel_restart);
 
@@ -240,12 +251,18 @@ static void kernel_shutdown_prepare(enum system_states state)
  */
 void kernel_halt(void)
 {
+#ifdef CONFIG_MACH_OWL
+	void *owl_watchdog = owl_watchdog_start(HZ * 20, NULL, 0);	//若20秒都没有关机成功就打印所有任务栈
+#endif
 	kernel_shutdown_prepare(SYSTEM_HALT);
 	migrate_to_reboot_cpu();
 	syscore_shutdown();
 	pr_emerg("System halted\n");
 	kmsg_dump(KMSG_DUMP_HALT);
 	machine_halt();
+#ifdef CONFIG_MACH_OWL
+	owl_watchdog_stop(owl_watchdog);
+#endif
 }
 EXPORT_SYMBOL_GPL(kernel_halt);
 
@@ -256,6 +273,9 @@ EXPORT_SYMBOL_GPL(kernel_halt);
  */
 void kernel_power_off(void)
 {
+#ifdef CONFIG_MACH_OWL
+	void *owl_watchdog = owl_watchdog_start(HZ * 20, NULL, 0);	//若20秒都没有关机成功就打印所有任务栈
+#endif
 	kernel_shutdown_prepare(SYSTEM_POWER_OFF);
 	if (pm_power_off_prepare)
 		pm_power_off_prepare();
@@ -264,6 +284,9 @@ void kernel_power_off(void)
 	pr_emerg("Power down\n");
 	kmsg_dump(KMSG_DUMP_POWEROFF);
 	machine_power_off();
+#ifdef CONFIG_MACH_OWL
+	owl_watchdog_stop(owl_watchdog);
+#endif
 }
 EXPORT_SYMBOL_GPL(kernel_power_off);
 
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
old mode 100644
new mode 100755
index dd05cb5..918d3cd
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -2378,6 +2378,14 @@ bool single_task_running(void)
 }
 EXPORT_SYMBOL(single_task_running);
 
+unsigned long get_cpu_nr_running(unsigned int cpu)
+{
+	if(cpu < NR_CPUS)
+		return cpu_rq(cpu)->nr_running;
+	else
+		return 0;
+}
+
 unsigned long long nr_context_switches(void)
 {
 	int i;
diff --git a/mm/backing-dev.c b/mm/backing-dev.c
old mode 100644
new mode 100755
index 000e7b3..71e95e0
--- a/mm/backing-dev.c
+++ b/mm/backing-dev.c
@@ -374,9 +374,9 @@ static void bdi_wb_init(struct bdi_writeback *wb, struct backing_dev_info *bdi)
 }
 
 /*
- * Initial write bandwidth: 100 MB/s
+ * Initial write bandwidth: 30 MB/s
  */
-#define INIT_BW		(100 << (20 - PAGE_SHIFT))
+#define INIT_BW		(30 << (20 - PAGE_SHIFT))
 
 int bdi_init(struct backing_dev_info *bdi)
 {
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
old mode 100644
new mode 100755
index 18490f3..4232fdd
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -67,6 +67,8 @@
 #include <asm/div64.h>
 #include "internal.h"
 
+extern void invalidate_bh_lrus(void);
+
 /* prevent >1 _updater_ of zone percpu pageset ->high and ->batch fields */
 static DEFINE_MUTEX(pcp_batch_high_lock);
 #define MIN_PERCPU_PAGELIST_FRACTION	(8)
@@ -853,6 +855,56 @@ void __init __free_pages_bootmem(struct page *page, unsigned int order)
 }
 
 #ifdef CONFIG_CMA
+void adjust_managed_cma_page_count(struct zone *zone, long count)
+{
+	unsigned long flags;
+	long total, cma, movable;
+
+	spin_lock_irqsave(&zone->lock, flags);
+	zone->managed_cma_pages += count;
+
+	total = zone->managed_pages;
+	cma = zone->managed_cma_pages;
+	movable = total - cma - high_wmark_pages(zone);
+
+	/* No cma pages, so do only movable allocation */
+	if (cma <= 0) {
+		zone->max_try_movable = pageblock_nr_pages;
+		zone->max_try_cma = 0;
+		goto out;
+	}
+
+	/*
+	 * We want to consume cma pages with well balanced ratio so that
+	 * we have consumed enough cma pages before the reclaim. For this
+	 * purpose, we can use the ratio, movable : cma. And we doesn't
+	 * want to switch too frequently, because it prevent allocated pages
+	 * from beging successive and it is bad for some sorts of devices.
+	 * I choose pageblock_nr_pages for the minimum amount of successive
+	 * allocation because it is the size of a huge page and fragmentation
+	 * avoidance is implemented based on this size.
+	 *
+	 * To meet above criteria, I derive following equation.
+	 *
+	 * if (movable > cma) then; movable : cma = X : pageblock_nr_pages
+	 * else (movable <= cma) then; movable : cma = pageblock_nr_pages : X
+	 */
+	if (movable > cma) {
+		zone->max_try_movable =
+			(movable * pageblock_nr_pages) / cma;
+		zone->max_try_cma = pageblock_nr_pages;
+	} else {
+		zone->max_try_movable = pageblock_nr_pages;
+		zone->max_try_cma = cma * pageblock_nr_pages / movable;
+	}
+
+out:
+	zone->nr_try_movable = zone->max_try_movable;
+	zone->nr_try_cma = zone->max_try_cma;
+
+	spin_unlock_irqrestore(&zone->lock, flags);
+}
+
 /* Free whole pageblock and set its migration type to MIGRATE_CMA. */
 void __init init_cma_reserved_pageblock(struct page *page)
 {
@@ -1285,6 +1337,45 @@ __rmqueue_fallback(struct zone *zone, unsigned int order, int start_migratetype)
 	return NULL;
 }
 
+#ifdef CONFIG_CMA
+static struct page *__rmqueue_cma(struct zone *zone, unsigned int order)
+{
+	struct page *page;
+	unsigned long force_cma_wmark, zone_free_pages;
+
+	/* mod by actions:
+	 * if we are lack of memory, get pages from CMA first. */
+	force_cma_wmark = zone->managed_cma_pages;
+	zone_free_pages = zone_page_state(zone, NR_FREE_PAGES) -
+			zone_page_state(zone, NR_FREE_CMA_PAGES);
+
+	while (1) {
+		if (zone->nr_try_cma > 0 || zone_free_pages < force_cma_wmark) {
+			/* Okay. Now, we can try to allocate the page from cma region */
+			zone->nr_try_cma -= 1 << order;
+			page = __rmqueue_smallest(zone, order, MIGRATE_CMA);
+
+			/* CMA pages can vanish through CMA allocation */
+			if (unlikely(!page && order == 0))
+				zone->nr_try_cma = 0;
+
+			return page;
+		}
+
+		if (zone->nr_try_movable > 0)
+			break;
+
+		/* Reset counter */
+		zone->nr_try_movable = zone->max_try_movable;
+		zone->nr_try_cma = zone->max_try_cma;
+	}
+
+	/* alloc_movable */
+	zone->nr_try_movable -= 1 << order;
+	return NULL;
+}
+#endif
+
 /*
  * Do the hard work of removing an element from the buddy allocator.
  * Call me with the zone->lock already held.
@@ -1292,10 +1383,16 @@ __rmqueue_fallback(struct zone *zone, unsigned int order, int start_migratetype)
 static struct page *__rmqueue(struct zone *zone, unsigned int order,
 						int migratetype)
 {
-	struct page *page;
+	struct page *page = NULL;
+
+#ifdef CONFIG_CMA
+	if (migratetype == MIGRATE_MOVABLE && zone->managed_cma_pages)
+		page = __rmqueue_cma(zone, order);
+#endif
 
 retry_reserve:
-	page = __rmqueue_smallest(zone, order, migratetype);
+	if (!page)
+		page = __rmqueue_smallest(zone, order, migratetype);
 
 	if (unlikely(!page) && migratetype != MIGRATE_RESERVE) {
 		if (migratetype == MIGRATE_MOVABLE)
@@ -4980,6 +5077,9 @@ static void __paginginit free_area_init_core(struct pglist_data *pgdat,
 		zone->zone_pgdat = pgdat;
 		zone_pcp_init(zone);
 
+#ifdef CONFIG_CMA
+		zone->managed_cma_pages = 0;
+#endif
 		/* For bootup, initialized properly in watermark setup */
 		mod_zone_page_state(zone, NR_ALLOC_BATCH, zone->managed_pages);
 
@@ -6384,6 +6484,8 @@ static int __alloc_contig_migrate_range(struct compact_control *cc,
 	return 0;
 }
 
+//extern void boost_cma_requests_start(unsigned int start_pfn, unsigned int end_pfn);
+//extern void boost_cma_requests_end(void);
 /**
  * alloc_contig_range() -- tries to allocate given range of pages
  * @start:	start PFN to allocate
@@ -6449,7 +6551,18 @@ int alloc_contig_range(unsigned long start, unsigned long end,
 	if (ret)
 		return ret;
 
+	/* patch applied by actions
+	 * For page migration of CMA, buffer-heads of lru should be dropped.
+	 * please refer to:
+	 *   https://lkml.org/lkml/2014/6/23/932
+	 *   https://lkml.org/lkml/2014/7/4/101
+	 *   http://www.gossamer-threads.com/lists/linux/kernel/1971100 */
+	invalidate_bh_lrus();
+
+	//boost_cma_requests_start(start, end);	
 	ret = __alloc_contig_migrate_range(&cc, start, end);
+	//boost_cma_requests_end();
+	
 	if (ret)
 		goto done;
 
-- 
1.7.5.4

