From c43a67a9d062ed45705922dd680338c49f67ee2a Mon Sep 17 00:00:00 2001
From: Andrey Pronin <apronin@chromium.org>
Date: Thu, 30 Jun 2016 10:25:43 -0700
Subject: [PATCH 88/94] tpm: read burstcount from TPM_STS in one 32-bit
 transaction

commit 9754d45e997000ad4021bc4606cc266bb38d876f from upstream

Some chips incorrectly support partial reads from TPM_STS register
at non-zero offsets. Read the entire 32-bits register instead of
making two 8-bit reads to support such devices and reduce the number
of bus transactions when obtaining the burstcount from TPM_STS.

Fixes: 27084efee0c3 ("tpm: driver for next generation TPM chips")
Signed-off-by: Andrey Pronin <apronin@chromium.org>
Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
---
 drivers/char/tpm/tpm_tis_core.c |   11 +++--------
 1 files changed, 3 insertions(+), 8 deletions(-)

diff --git a/drivers/char/tpm/tpm_tis_core.c b/drivers/char/tpm/tpm_tis_core.c
index ace95b3..fb8c3de 100644
--- a/drivers/char/tpm/tpm_tis_core.c
+++ b/drivers/char/tpm/tpm_tis_core.c
@@ -157,22 +157,17 @@ static int get_burstcount(struct tpm_chip *chip)
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	unsigned long stop;
 	int burstcnt, rc;
-	u8 value;
+	u32 value;
 
 	/* wait for burstcount */
 	/* which timeout value, spec has 2 answers (c & d) */
 	stop = jiffies + chip->timeout_d;
 	do {
-		rc = tpm_tis_read8(priv, TPM_STS(priv->locality) + 1, &value);
+		rc = tpm_tis_read32(priv, TPM_STS(priv->locality), &value);
 		if (rc < 0)
 			return rc;
 
-		burstcnt = value;
-		rc = tpm_tis_read8(priv, TPM_STS(priv->locality) + 2, &value);
-		if (rc < 0)
-			return rc;
-
-		burstcnt += value << 8;
+		burstcnt = (value >> 8) & 0xFFFF;
 		if (burstcnt)
 			return burstcnt;
 		msleep(TPM_TIMEOUT);
-- 
1.7.5.4

