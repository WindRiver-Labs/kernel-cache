From 7039d04edc7d964431377d2f7d4ae9bd5d300cea Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E8=B0=A2=E5=8F=8C=E5=8F=8C?= <xieshsh@srv-pad-compile2.actions.com.cn>
Date: Tue, 29 Dec 2015 15:02:48 +0800
Subject: [PATCH 51/62] display: hdmi: fix hdmi read edid in kernel

commit 472d820a1d178e13b04ca3215db842a51228fb70 from
https://github.com/xapp-le/kernel.git

Change-Id: I6a16522bba3817ba6987046cfa53e1e96ce5ec08
---
 drivers/video/fbdev/owl/displays/hdmi/hdmi.c      |   47 +++++++-----
 drivers/video/fbdev/owl/displays/hdmi/hdmi_edid.c |    8 ++-
 drivers/video/fbdev/owl/fb/owlfb-dc.c             |   26 +++++++-
 drivers/video/fbdev/owl/fb/owlfb-ioctl.c          |    6 +-
 drivers/video/fbdev/owl/fb/owlfb-main.c           |   78 ++++++++-------------
 drivers/video/fbdev/owl/fb/owlfb-sysfs.c          |    5 ++
 6 files changed, 96 insertions(+), 74 deletions(-)

diff --git a/drivers/video/fbdev/owl/displays/hdmi/hdmi.c b/drivers/video/fbdev/owl/displays/hdmi/hdmi.c
index b19c366..88cfd80 100755
--- a/drivers/video/fbdev/owl/displays/hdmi/hdmi.c
+++ b/drivers/video/fbdev/owl/displays/hdmi/hdmi.c
@@ -502,40 +502,44 @@ void hdmi_send_uevent(bool data)
 			HDMI_DEBUG("parse_edid end\n");		
 			if(hdmi.data.hpd_en){	
 				switch_set_state(&hdev, 1);	
-				atomic_set(&hdmi_status, 1);
-			}
-			if(hdmi.dssdev != NULL 
-				&& hdmi.dssdev->driver != NULL 
-				&& hdmi.dssdev->driver->hot_plug_nodify){
-				hdmi.dssdev->driver->hot_plug_nodify(hdmi.dssdev,data);	
+				atomic_set(&hdmi_status, 1);			
+			}else{
+				if(hdmi.dssdev != NULL 
+					&& hdmi.dssdev->driver != NULL 
+					&& hdmi.dssdev->driver->hot_plug_nodify){
+					hdmi.dssdev->driver->hot_plug_nodify(hdmi.dssdev,data);	
+				}
 			}
 		}
 	}else{
 		if((atomic_read(&hdmi_status)==1)&&hdmi.data.send_uevent){
 			if(hdmi.data.hpd_en){
-				switch_set_state(&hdev, 0);	
-				atomic_set(&hdmi_status, 0);
-			}
-			if(hdmi.dssdev != NULL 
-				&& hdmi.dssdev->driver != NULL 
-				&& hdmi.dssdev->driver->hot_plug_nodify){
-				hdmi.dssdev->driver->hot_plug_nodify(hdmi.dssdev,data);	
-			}
+				switch_set_state(&hdev, 0);
+				atomic_set(&hdmi_status, 0);					
+			}else{
+				if(hdmi.dssdev != NULL 
+					&& hdmi.dssdev->driver != NULL 
+					&& hdmi.dssdev->driver->hot_plug_nodify){
+
+					hdmi.dssdev->driver->hot_plug_nodify(hdmi.dssdev,data);	
+				
+				}
+			}		
 		}	
 	}		
 	mutex_unlock(&hdmi.ip_data.lock);
 
 }
-
+static bool old_hotplug_state = false;
 void hdmi_cable_check(struct work_struct *work)
 {
 	/*HDMI_DEBUG("hdmi_cable_check  ~~~~~~~~\n");*/	
 	if(hdmi.data.cable_check_onoff){
-		if(hdmi.ip_data.ops->cable_check(&hdmi.ip_data)){		
-			hdmi_send_uevent(1);
-		}else{
-			hdmi_send_uevent(0);
-		}
+		bool new_hotplug_state = hdmi.ip_data.ops->cable_check(&hdmi.ip_data);
+		if(old_hotplug_state != new_hotplug_state){			
+			hdmi_send_uevent(new_hotplug_state);
+			old_hotplug_state = new_hotplug_state;
+		}		
 	}
 	queue_delayed_work(hdmi.ip_data.hdcp.wq, &hdmi_cable_check_work,
 				msecs_to_jiffies(2000));
@@ -1173,6 +1177,9 @@ static int platform_hdmihw_probe(struct platform_device *pdev)
 	hdmi.data.send_uevent = 1;
 	hdmi.edid.isHDMI = HDMI_HDMI;
 	is_probe_called = true;
+	if(is_hdmi_power_on()){
+	 	old_hotplug_state = true;
+	}
 	return 0;
 	
 err2:
diff --git a/drivers/video/fbdev/owl/displays/hdmi/hdmi_edid.c b/drivers/video/fbdev/owl/displays/hdmi/hdmi_edid.c
index a714942..2d25cfa 100755
--- a/drivers/video/fbdev/owl/displays/hdmi/hdmi_edid.c
+++ b/drivers/video/fbdev/owl/displays/hdmi/hdmi_edid.c
@@ -515,9 +515,13 @@ int read_edid(u8 * edid , int len)
 
 	if (len >= 128 * 2 && edid[0x7e] > 0) {
 		r = ddc_read(1,0x80,edid + 0x80);
-		if (r)
+		if (r<0)
+		{
+			printk("read ddc_read is error r=%d\n", r);
 			return r;
-		l += 128;
+		}
+
+		l = 256;
 	}
 	return l;
 	
diff --git a/drivers/video/fbdev/owl/fb/owlfb-dc.c b/drivers/video/fbdev/owl/fb/owlfb-dc.c
index bb9e283..1e18806 100755
--- a/drivers/video/fbdev/owl/fb/owlfb-dc.c
+++ b/drivers/video/fbdev/owl/fb/owlfb-dc.c
@@ -260,6 +260,27 @@ static int owlfb_dc_arrange_overlay(setup_dispc_data_t *psDispcData,
 	
 	return used_overlay_num;
 }
+static int owlfb_dc_check_frame_scale_by_display(struct owl_dss_device *dssdev,
+		struct owl_overlay_info *info)
+{
+	u16 dw, dh;
+	
+	dssdev->driver->get_resolution(dssdev,&dw,&dh);
+	
+	if(my_fbdev->xres == dw && my_fbdev->yres == dh)
+	{
+		return 0;
+	}
+	printk("dw %d  dh %d my_fbdev->xres %d ,my_fbdev->yres %d \n",dw, dh,my_fbdev->xres ,my_fbdev->yres);
+	printk("window (%d %d %d %d ) \n",info->pos_x,info->pos_y,info->out_width,info->out_height);
+	info->out_width = info->out_width * dw / my_fbdev->xres; 
+	info->out_height = info->out_height *  dh / my_fbdev->yres;
+			
+	info->pos_x =  info->pos_x * dw /  my_fbdev->xres;
+	info->pos_y =  info->pos_y * dh / my_fbdev->yres ;
+
+	return 0;
+}
 
 static int hdmi_discard_frame = 0;
 
@@ -302,7 +323,10 @@ static int owlfb_dc_update_overlay(struct owl_disp_info * disp_info)
 		info.pos_x = layer->scn_win.x;
 		info.pos_y = layer->scn_win.y;
 		info.out_width = layer->scn_win.width;
-		info.out_height = layer->scn_win.height;	
+		info.out_height = layer->scn_win.height;
+		if (i < psDispcData->primary_display_layer_num) {
+			owlfb_dc_check_frame_scale_by_display(ovl->manager->device,&info);
+		}	
 				
 		info.rotation =	layer->rotate;
 		if(layer->fb.buffer_id != -1){
diff --git a/drivers/video/fbdev/owl/fb/owlfb-ioctl.c b/drivers/video/fbdev/owl/fb/owlfb-ioctl.c
index 7bf8913..c614551 100755
--- a/drivers/video/fbdev/owl/fb/owlfb-ioctl.c
+++ b/drivers/video/fbdev/owl/fb/owlfb-ioctl.c
@@ -547,12 +547,12 @@ int owlfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 			break;
 		}
 				
-		if(display->driver->get_resolution){
+		/*if(display->driver->get_resolution){
 			display->driver->get_resolution(display, &p.display_info.xres, &p.display_info.yres);
-		}else{
+		}else{*/
 			p.display_info.xres = fbdev->xres;
 			p.display_info.yres = fbdev->yres;
-		}
+		/*}*/
 		
 		p.display_info.virtual_xres = fbdev->xres;
 		p.display_info.virtual_yres = fbdev->yres;		
diff --git a/drivers/video/fbdev/owl/fb/owlfb-main.c b/drivers/video/fbdev/owl/fb/owlfb-main.c
index b90b417..bed0f5b 100755
--- a/drivers/video/fbdev/owl/fb/owlfb-main.c
+++ b/drivers/video/fbdev/owl/fb/owlfb-main.c
@@ -575,42 +575,6 @@ static unsigned calc_offset_dma(const struct fb_var_screeninfo *var,
 	return offset;
 }
 
-static int owlfb_hotplug_notify(struct owl_dss_device *dssdev, int state)
-{
-	struct owl_overlay_manager *external_mgr = owl_dss_get_overlay_manager(OWL_DSS_OVL_MGR_EXTERNAL);
-	int vid ;
-	if(external_mgr != NULL 
-		&& external_mgr->device != NULL 
-		&& external_mgr->mirror_context 
-		&& external_mgr->device->type == dssdev->type)
-	{
-		if(state == 1){
-			dssdev->driver->get_vid(dssdev,&vid);
-			dssdev->driver->set_vid(dssdev,vid);		
-			dssdev->driver->enable(dssdev);	
-		}else{
-			dssdev->driver->disable(dssdev);    	
-		}
-		if(external_mgr->link_fbi != NULL){
-			owlfb_get_mem_region(FB2OFB(external_mgr->link_fbi)->region);
-			owlfb_apply_changes(external_mgr->link_fbi, 0);
-			owlfb_put_mem_region(FB2OFB(external_mgr->link_fbi)->region);
-			DBG("owlfb_hotplug_notify  dssdev %s  state %d \n",dssdev->name,state);
-		}		
-	}
-
-	return 0;	
-}
-
-static void owlfb_register_hotplug_notify(struct owl_dss_device *dssdev)
-{
-	if(dssdev && dssdev->driver){
-		if(!dssdev->driver->hot_plug_nodify){
-			dssdev->driver->hot_plug_nodify = owlfb_hotplug_notify;
-			DBG("owlfb_register_hotplug_notify  dssdev %s  \n",dssdev->name);
-		}
-	}
-}
 
 static void owlfb_calc_addr(const struct owlfb_info *ofbi,
 			     const struct fb_var_screeninfo *var,
@@ -960,6 +924,8 @@ static int owlfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)
 	unsigned long start;
 	u32 len;
 	int r = -EINVAL;
+	struct owl_dss_device * dssdev = ofbi->manager->device;
+	struct owl_overlay *ovl = ofbi->overlays[0];
 
 	if (vma->vm_end - vma->vm_start == 0)
 		return 0;
@@ -995,13 +961,31 @@ static int owlfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)
 	/* vm_ops.open won't be called for mmap itself. */
 	atomic_inc(&rg->map_count);
 
-	owlfb_put_mem_region(rg);
 
-	/* Apply overlay changes, SHOULD NOT be here, TODO */
-	if (ofbi->num_overlays > 0) {
-		struct owl_overlay *ovl = ofbi->overlays[0];
-		ovl->manager->apply(ovl->manager);
-	}
+DBG("Apply overlay changes ofbi->num_overlays %d \n", ofbi->num_overlays);
+	
+#if CONFIG_FB_MAP_TO_DE
+	if(ofbi->manager != NULL && ofbi->manager->device != NULL && ofbi->manager->device->driver != NULL)
+	{
+		
+		if(dssdev->driver->get_vid != 0 && dssdev->driver->set_vid != 0)
+		{
+			int vid = 0;
+			dssdev->driver->get_vid(dssdev,&vid);
+			dssdev->driver->set_vid(dssdev,vid);
+		}
+		if(dssdev->driver->enable){
+			dssdev->driver->enable(dssdev);	
+		}		
+
+	    r = owlfb_overlay_enable(ovl, 1);		
+		
+		r = owlfb_apply_changes(fbi, 0);
+ 	}
+#endif
+
+	owlfb_put_mem_region(rg);
+	
 
 	return 0;
 
@@ -1724,17 +1708,15 @@ static int owlfb_create_framebuffers(struct owlfb_device *fbdev)
 		/* connected display to managers */
 		if(fbdev->def_display != NULL && i == 0){
 			ofbi->manager->set_device(ofbi->manager,fbdev->def_display);
+			owlfb_register_hotplug_notify(fbdev->def_display);
 		}else{
 			for( j = 0 ; j < fbdev->num_displays ; j++){
 				if(!fbdev->displays[j].connected){
 					fbdev->displays[j].connected = true;
 					ofbi->manager->set_device(ofbi->manager,fbdev->displays[j].dssdev);
-					
-					if(i != 0){
-						DBG("owlfb_register_hotplug_notify allocated %s \n",fbdev->displays[j].dssdev->name);
-						owlfb_register_hotplug_notify(fbdev->displays[j].dssdev);
-					}
-					
+
+					DBG("owlfb_register_hotplug_notify allocated %s \n",fbdev->displays[j].dssdev->name);
+					owlfb_register_hotplug_notify(fbdev->displays[j].dssdev);
 					break;
 				}
 			}			
diff --git a/drivers/video/fbdev/owl/fb/owlfb-sysfs.c b/drivers/video/fbdev/owl/fb/owlfb-sysfs.c
index 9247231..1c73d28 100755
--- a/drivers/video/fbdev/owl/fb/owlfb-sysfs.c
+++ b/drivers/video/fbdev/owl/fb/owlfb-sysfs.c
@@ -54,6 +54,7 @@ static ssize_t store_mirror_to_hdmi(struct device *dev,
 	struct owlfb_info *ofbi = FB2OFB(fbi);
 	struct owlfb_device *fbdev = ofbi->fbdev;
 	bool mirror_to_hdmi;
+	int r;
 	int vid = 1;
 	
 	struct owl_overlay_manager *external_mgr = owl_dss_get_overlay_manager(OWL_DSS_OVL_MGR_EXTERNAL);
@@ -67,6 +68,10 @@ static ssize_t store_mirror_to_hdmi(struct device *dev,
 	r = strtobool(buf, &mirror_to_hdmi);
 	if (r)
 		return r;
+	if(ofbi->id != 0)
+	{
+		return r;
+	}
 
 	if (!lock_fb_info(fbi))
 		return -ENODEV;
-- 
1.7.5.4

