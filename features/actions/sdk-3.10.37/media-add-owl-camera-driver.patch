From 0fdd3bb78db5732f354eb426c43c69adc659418a Mon Sep 17 00:00:00 2001
From: wurui <wurui@actions-semi.com>
Date: Mon, 7 Dec 2015 13:19:09 +0800
Subject: [PATCH 17/62] media: add owl camera driver

commit d4fcf90f76d1cf8cd6eb2f0629d7d289ccd99a32 from
https://github.com/xapp-le/kernel.git

Change-Id: I094f5592ae4aa046f44f08002785615c9ad14f4e
---
 drivers/media/i2c/Kconfig                          |    6 +
 drivers/media/i2c/Makefile                         |    1 +
 drivers/media/i2c/camera/Kconfig                   |   24 +
 drivers/media/i2c/camera/Makefile                  |   21 +
 drivers/media/i2c/camera/flashlight/Kconfig        |   13 +
 drivers/media/i2c/camera/flashlight/Makefile       |    2 +
 drivers/media/i2c/camera/flashlight/flashlight.c   |  276 +
 drivers/media/i2c/camera/flashlight/flashlight.h   |   22 +
 drivers/media/i2c/camera/gc0308/Kconfig            |   13 +
 drivers/media/i2c/camera/gc0308/Makefile           |    2 +
 drivers/media/i2c/camera/gc0308/gc0308.c           |  508 ++
 drivers/media/i2c/camera/gc0308/module_diff.h      |  822 +++
 drivers/media/i2c/camera/gc0312/Kconfig            |   13 +
 drivers/media/i2c/camera/gc0312/Makefile           |    2 +
 drivers/media/i2c/camera/gc0312/gc0312.c           |  664 +++
 drivers/media/i2c/camera/gc0312/module_diff.h      |  919 ++++
 drivers/media/i2c/camera/gc0328/Kconfig            |   13 +
 drivers/media/i2c/camera/gc0328/Makefile           |    2 +
 drivers/media/i2c/camera/gc0328/gc0328.c           |  641 +++
 drivers/media/i2c/camera/gc0328/module_diff.h      |  927 ++++
 drivers/media/i2c/camera/gc0329/Kconfig            |   13 +
 drivers/media/i2c/camera/gc0329/Makefile           |    2 +
 drivers/media/i2c/camera/gc0329/gc0329.c           |  425 ++
 drivers/media/i2c/camera/gc0329/module_diff.h      |  586 +++
 drivers/media/i2c/camera/gc2035/Kconfig            |   13 +
 drivers/media/i2c/camera/gc2035/Makefile           |    2 +
 drivers/media/i2c/camera/gc2035/gc2035.c           |  715 +++
 drivers/media/i2c/camera/gc2035/module_diff.h      | 1264 +++++
 drivers/media/i2c/camera/gc2145/Kconfig            |   13 +
 drivers/media/i2c/camera/gc2145/Makefile           |    2 +
 drivers/media/i2c/camera/gc2145/gc2145.c           |  680 +++
 drivers/media/i2c/camera/gc2145/module_diff.h      | 1263 +++++
 drivers/media/i2c/camera/gc2155/Kconfig            |   13 +
 drivers/media/i2c/camera/gc2155/Makefile           |    2 +
 drivers/media/i2c/camera/gc2155/gc2155.c           |  672 +++
 drivers/media/i2c/camera/gc2155/module_diff.h      | 1178 +++++
 drivers/media/i2c/camera/gs5604/Kconfig            |   13 +
 drivers/media/i2c/camera/gs5604/Makefile           |    1 +
 drivers/media/i2c/camera/gs5604/gs5604.c           |  914 ++++
 drivers/media/i2c/camera/gs5604/module_diff.h      | 2347 +++++++++
 drivers/media/i2c/camera/hi257/Kconfig             |   13 +
 drivers/media/i2c/camera/hi257/Makefile            |    2 +
 drivers/media/i2c/camera/hi257/hi257.c             |  536 ++
 drivers/media/i2c/camera/hi257/module_diff.h       | 1480 ++++++
 drivers/media/i2c/camera/hi708/Kconfig             |   13 +
 drivers/media/i2c/camera/hi708/Makefile            |    2 +
 drivers/media/i2c/camera/hi708/hi708.c             |  679 +++
 drivers/media/i2c/camera/hi708/module_diff.h       |  984 ++++
 .../i2c/camera/module_comm/camera_chip_ident.h     |   33 +
 drivers/media/i2c/camera/module_comm/module_comm.c | 1128 ++++
 drivers/media/i2c/camera/module_comm/module_comm.h |  234 +
 .../media/i2c/camera/module_comm/module_detect.c   |  649 +++
 drivers/media/i2c/camera/ov2686/Kconfig            |   13 +
 drivers/media/i2c/camera/ov2686/Makefile           |    2 +
 drivers/media/i2c/camera/ov2686/module_diff.h      |  842 +++
 drivers/media/i2c/camera/ov2686/ov2686.c           |  505 ++
 drivers/media/i2c/camera/ov5640/Kconfig            |   13 +
 drivers/media/i2c/camera/ov5640/Makefile           |    2 +
 drivers/media/i2c/camera/ov5640/module_diff.h      | 5416 ++++++++++++++++++++
 drivers/media/i2c/camera/ov5640/ov5640.c           |  805 +++
 drivers/media/i2c/camera/owl_camera/Kconfig        |   13 +
 drivers/media/i2c/camera/owl_camera/Makefile       |    1 +
 drivers/media/i2c/camera/owl_camera/atm7039c.c     |  803 +++
 drivers/media/i2c/camera/owl_camera/atm7059.c      |  704 +++
 drivers/media/i2c/camera/owl_camera/bisp.c         | 1787 +++++++
 drivers/media/i2c/camera/owl_camera/bisp.h         |  206 +
 drivers/media/i2c/camera/owl_camera/owl_7059.txt   |    7 +
 drivers/media/i2c/camera/owl_camera/owl_camera.c   | 2339 +++++++++
 drivers/media/i2c/camera/owl_camera/owl_camera.h   |  221 +
 drivers/media/i2c/camera/owl_camera/readme         |  224 +
 drivers/media/i2c/camera/sensor_detect/Kconfig     |   13 +
 drivers/media/i2c/camera/sensor_detect/Makefile    |    1 +
 .../media/i2c/camera/sensor_detect/module_detect.h |   30 +
 .../media/i2c/camera/sensor_detect/module_list.c   | 1120 ++++
 .../media/i2c/camera/sensor_detect/sensor_detect.c |  927 ++++
 drivers/media/i2c/camera/siv121du/Kconfig          |   13 +
 drivers/media/i2c/camera/siv121du/Makefile         |    2 +
 drivers/media/i2c/camera/siv121du/module_diff.h    |  530 ++
 drivers/media/i2c/camera/siv121du/siv121du.c       |  482 ++
 drivers/media/i2c/camera/soc5140/Kconfig           |   13 +
 drivers/media/i2c/camera/soc5140/Makefile          |    2 +
 drivers/media/i2c/camera/soc5140/module_diff.h     | 1421 +++++
 drivers/media/i2c/camera/soc5140/soc5140.c         |  687 +++
 drivers/media/i2c/camera/sp0718/Kconfig            |   13 +
 drivers/media/i2c/camera/sp0718/Makefile           |    2 +
 drivers/media/i2c/camera/sp0718/module_diff.h      |  675 +++
 drivers/media/i2c/camera/sp0718/sp0718.c           |  430 ++
 drivers/media/i2c/camera/sp0a19/Kconfig            |   13 +
 drivers/media/i2c/camera/sp0a19/Makefile           |    2 +
 drivers/media/i2c/camera/sp0a19/module_diff.h      |  833 +++
 drivers/media/i2c/camera/sp0a19/sp0a19.c           |  591 +++
 drivers/media/i2c/camera/sp2519/Kconfig            |   13 +
 drivers/media/i2c/camera/sp2519/Makefile           |    2 +
 drivers/media/i2c/camera/sp2519/module_diff.h      | 1133 ++++
 drivers/media/i2c/camera/sp2519/sp2519.c           |  672 +++
 drivers/media/platform/Kconfig                     |    1 +
 drivers/media/platform/soc_camera/soc_camera.c     |   19 +-
 drivers/media/usb/uvc/Makefile                     |    6 +-
 drivers/media/usb/uvc/uvc_driver.c                 |   12 +-
 drivers/media/usb/uvc/uvc_queue.c                  |  104 +-
 drivers/media/usb/uvc/uvc_queue_asoc.c             |  125 +
 drivers/media/usb/uvc/uvc_v4l2.c                   |   12 +
 drivers/media/usb/uvc/uvc_video.c                  |   75 +-
 drivers/media/usb/uvc/uvcvideo.h                   |   30 +-
 drivers/media/v4l2-core/v4l2-ctrls.c               |   45 +-
 drivers/media/v4l2-core/videobuf2-core.c           |    2 +
 drivers/media/v4l2-core/videobuf2-dma-contig.c     |   14 +-
 include/media/soc_camera.h                         |    1 +
 include/uapi/linux/v4l2-controls.h                 |   61 +-
 109 files changed, 44724 insertions(+), 68 deletions(-)
 mode change 100644 => 100755 drivers/media/i2c/Kconfig
 mode change 100644 => 100755 drivers/media/i2c/Makefile
 create mode 100755 drivers/media/i2c/camera/Kconfig
 create mode 100755 drivers/media/i2c/camera/Makefile
 create mode 100755 drivers/media/i2c/camera/flashlight/Kconfig
 create mode 100755 drivers/media/i2c/camera/flashlight/Makefile
 create mode 100755 drivers/media/i2c/camera/flashlight/flashlight.c
 create mode 100755 drivers/media/i2c/camera/flashlight/flashlight.h
 create mode 100755 drivers/media/i2c/camera/gc0308/Kconfig
 create mode 100755 drivers/media/i2c/camera/gc0308/Makefile
 create mode 100755 drivers/media/i2c/camera/gc0308/gc0308.c
 create mode 100755 drivers/media/i2c/camera/gc0308/module_diff.h
 create mode 100755 drivers/media/i2c/camera/gc0312/Kconfig
 create mode 100755 drivers/media/i2c/camera/gc0312/Makefile
 create mode 100755 drivers/media/i2c/camera/gc0312/gc0312.c
 create mode 100755 drivers/media/i2c/camera/gc0312/module_diff.h
 create mode 100755 drivers/media/i2c/camera/gc0328/Kconfig
 create mode 100755 drivers/media/i2c/camera/gc0328/Makefile
 create mode 100755 drivers/media/i2c/camera/gc0328/gc0328.c
 create mode 100755 drivers/media/i2c/camera/gc0328/module_diff.h
 create mode 100755 drivers/media/i2c/camera/gc0329/Kconfig
 create mode 100755 drivers/media/i2c/camera/gc0329/Makefile
 create mode 100755 drivers/media/i2c/camera/gc0329/gc0329.c
 create mode 100755 drivers/media/i2c/camera/gc0329/module_diff.h
 create mode 100755 drivers/media/i2c/camera/gc2035/Kconfig
 create mode 100755 drivers/media/i2c/camera/gc2035/Makefile
 create mode 100755 drivers/media/i2c/camera/gc2035/gc2035.c
 create mode 100755 drivers/media/i2c/camera/gc2035/module_diff.h
 create mode 100755 drivers/media/i2c/camera/gc2145/Kconfig
 create mode 100755 drivers/media/i2c/camera/gc2145/Makefile
 create mode 100755 drivers/media/i2c/camera/gc2145/gc2145.c
 create mode 100755 drivers/media/i2c/camera/gc2145/module_diff.h
 create mode 100755 drivers/media/i2c/camera/gc2155/Kconfig
 create mode 100755 drivers/media/i2c/camera/gc2155/Makefile
 create mode 100755 drivers/media/i2c/camera/gc2155/gc2155.c
 create mode 100755 drivers/media/i2c/camera/gc2155/module_diff.h
 create mode 100755 drivers/media/i2c/camera/gs5604/Kconfig
 create mode 100755 drivers/media/i2c/camera/gs5604/Makefile
 create mode 100755 drivers/media/i2c/camera/gs5604/gs5604.c
 create mode 100755 drivers/media/i2c/camera/gs5604/module_diff.h
 create mode 100755 drivers/media/i2c/camera/hi257/Kconfig
 create mode 100755 drivers/media/i2c/camera/hi257/Makefile
 create mode 100755 drivers/media/i2c/camera/hi257/hi257.c
 create mode 100755 drivers/media/i2c/camera/hi257/module_diff.h
 create mode 100755 drivers/media/i2c/camera/hi708/Kconfig
 create mode 100755 drivers/media/i2c/camera/hi708/Makefile
 create mode 100755 drivers/media/i2c/camera/hi708/hi708.c
 create mode 100755 drivers/media/i2c/camera/hi708/module_diff.h
 create mode 100755 drivers/media/i2c/camera/module_comm/camera_chip_ident.h
 create mode 100755 drivers/media/i2c/camera/module_comm/module_comm.c
 create mode 100755 drivers/media/i2c/camera/module_comm/module_comm.h
 create mode 100755 drivers/media/i2c/camera/module_comm/module_detect.c
 create mode 100755 drivers/media/i2c/camera/ov2686/Kconfig
 create mode 100755 drivers/media/i2c/camera/ov2686/Makefile
 create mode 100755 drivers/media/i2c/camera/ov2686/module_diff.h
 create mode 100755 drivers/media/i2c/camera/ov2686/ov2686.c
 create mode 100755 drivers/media/i2c/camera/ov5640/Kconfig
 create mode 100755 drivers/media/i2c/camera/ov5640/Makefile
 create mode 100755 drivers/media/i2c/camera/ov5640/module_diff.h
 create mode 100755 drivers/media/i2c/camera/ov5640/ov5640.c
 create mode 100755 drivers/media/i2c/camera/owl_camera/Kconfig
 create mode 100755 drivers/media/i2c/camera/owl_camera/Makefile
 create mode 100755 drivers/media/i2c/camera/owl_camera/atm7039c.c
 create mode 100755 drivers/media/i2c/camera/owl_camera/atm7059.c
 create mode 100755 drivers/media/i2c/camera/owl_camera/bisp.c
 create mode 100755 drivers/media/i2c/camera/owl_camera/bisp.h
 create mode 100755 drivers/media/i2c/camera/owl_camera/owl_7059.txt
 create mode 100755 drivers/media/i2c/camera/owl_camera/owl_camera.c
 create mode 100755 drivers/media/i2c/camera/owl_camera/owl_camera.h
 create mode 100755 drivers/media/i2c/camera/owl_camera/readme
 create mode 100755 drivers/media/i2c/camera/sensor_detect/Kconfig
 create mode 100755 drivers/media/i2c/camera/sensor_detect/Makefile
 create mode 100755 drivers/media/i2c/camera/sensor_detect/module_detect.h
 create mode 100755 drivers/media/i2c/camera/sensor_detect/module_list.c
 create mode 100755 drivers/media/i2c/camera/sensor_detect/sensor_detect.c
 create mode 100755 drivers/media/i2c/camera/siv121du/Kconfig
 create mode 100755 drivers/media/i2c/camera/siv121du/Makefile
 create mode 100755 drivers/media/i2c/camera/siv121du/module_diff.h
 create mode 100755 drivers/media/i2c/camera/siv121du/siv121du.c
 create mode 100755 drivers/media/i2c/camera/soc5140/Kconfig
 create mode 100755 drivers/media/i2c/camera/soc5140/Makefile
 create mode 100755 drivers/media/i2c/camera/soc5140/module_diff.h
 create mode 100755 drivers/media/i2c/camera/soc5140/readme
 create mode 100755 drivers/media/i2c/camera/soc5140/soc5140.c
 create mode 100755 drivers/media/i2c/camera/sp0718/Kconfig
 create mode 100755 drivers/media/i2c/camera/sp0718/Makefile
 create mode 100755 drivers/media/i2c/camera/sp0718/module_diff.h
 create mode 100755 drivers/media/i2c/camera/sp0718/sp0718.c
 create mode 100755 drivers/media/i2c/camera/sp0a19/Kconfig
 create mode 100755 drivers/media/i2c/camera/sp0a19/Makefile
 create mode 100755 drivers/media/i2c/camera/sp0a19/module_diff.h
 create mode 100755 drivers/media/i2c/camera/sp0a19/sp0a19.c
 create mode 100755 drivers/media/i2c/camera/sp2519/Kconfig
 create mode 100755 drivers/media/i2c/camera/sp2519/Makefile
 create mode 100755 drivers/media/i2c/camera/sp2519/module_diff.h
 create mode 100755 drivers/media/i2c/camera/sp2519/sp2519.c
 mode change 100644 => 100755 drivers/media/platform/Kconfig
 mode change 100644 => 100755 drivers/media/platform/soc_camera/soc_camera.c
 mode change 100644 => 100755 drivers/media/usb/uvc/Makefile
 mode change 100644 => 100755 drivers/media/usb/uvc/uvc_driver.c
 mode change 100644 => 100755 drivers/media/usb/uvc/uvc_queue.c
 create mode 100755 drivers/media/usb/uvc/uvc_queue_asoc.c
 mode change 100644 => 100755 drivers/media/usb/uvc/uvc_v4l2.c
 mode change 100644 => 100755 drivers/media/usb/uvc/uvc_video.c
 mode change 100644 => 100755 drivers/media/usb/uvc/uvcvideo.h
 mode change 100644 => 100755 drivers/media/v4l2-core/v4l2-ctrls.c
 mode change 100644 => 100755 drivers/media/v4l2-core/videobuf2-core.c
 mode change 100644 => 100755 drivers/media/v4l2-core/videobuf2-dma-contig.c
 mode change 100644 => 100755 include/media/soc_camera.h
 mode change 100644 => 100755 include/uapi/linux/v4l2-controls.h

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
old mode 100644
new mode 100755
index 6f30ea7..087d277
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -716,5 +716,11 @@ if SOC_CAMERA
 endif
 
 endmenu
+config ACTIONS_CAMERA
+	tristate "actions camera driver"
+	depends on VIDEO_V4L2 
+menu "Sensors used on Actions driver"
+	source "drivers/media/i2c/camera/Kconfig"
+endmenu
 
 endif
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
old mode 100644
new mode 100755
index f165fae..ca9bebb
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -1,6 +1,7 @@
 msp3400-objs	:=	msp3400-driver.o msp3400-kthreads.o
 obj-$(CONFIG_VIDEO_MSP3400) += msp3400.o
 
+obj-$(CONFIG_ACTIONS_CAMERA)	+= camera/
 obj-$(CONFIG_VIDEO_SMIAPP)	+= smiapp/
 obj-$(CONFIG_VIDEO_CX25840) += cx25840/
 obj-$(CONFIG_VIDEO_M5MOLS)	+= m5mols/
diff --git a/drivers/media/i2c/camera/Kconfig b/drivers/media/i2c/camera/Kconfig
new file mode 100755
index 0000000..09c6745
--- /dev/null
+++ b/drivers/media/i2c/camera/Kconfig
@@ -0,0 +1,24 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+source "drivers/media/i2c/camera/gc2035/Kconfig"
+source "drivers/media/i2c/camera/gc0308/Kconfig"
+source "drivers/media/i2c/camera/gc2155/Kconfig"
+source "drivers/media/i2c/camera/gc0312/Kconfig"
+source "drivers/media/i2c/camera/gc2145/Kconfig"
+source "drivers/media/i2c/camera/gc0328/Kconfig"
+source "drivers/media/i2c/camera/gc0329/Kconfig"
+source "drivers/media/i2c/camera/sp0a19/Kconfig"
+source "drivers/media/i2c/camera/hi257/Kconfig"
+source "drivers/media/i2c/camera/hi708/Kconfig"
+source "drivers/media/i2c/camera/ov5640/Kconfig"
+source "drivers/media/i2c/camera/sp2519/Kconfig"
+source "drivers/media/i2c/camera/ov2686/Kconfig"
+source "drivers/media/i2c/camera/soc5140/Kconfig"
+source "drivers/media/i2c/camera/sp0718/Kconfig"
+source "drivers/media/i2c/camera/siv121du/Kconfig"
+source "drivers/media/i2c/camera/flashlight/Kconfig"
+source "drivers/media/i2c/camera/owl_camera/Kconfig"
+source "drivers/media/i2c/camera/sensor_detect/Kconfig"
diff --git a/drivers/media/i2c/camera/Makefile b/drivers/media/i2c/camera/Makefile
new file mode 100755
index 0000000..628b69d
--- /dev/null
+++ b/drivers/media/i2c/camera/Makefile
@@ -0,0 +1,21 @@
+#Makefile for actions si or isp driver and the sensors of actions support
+
+obj-y				+= owl_camera/
+obj-y       		+= gc2035/
+obj-y				+= gc0308/
+obj-y				+= gc2155/
+obj-y				+= gc0312/
+obj-y				+= gc2145/
+obj-y				+= gc0328/
+obj-y				+= gc0329/
+obj-y				+= sp0a19/
+obj-y				+= hi257/
+obj-y				+= hi708/
+obj-y				+= ov5640/
+obj-y				+= ov2686/
+obj-y				+= soc5140/
+obj-y				+= sp2519/
+obj-y				+= sp0718/
+obj-y				+= siv121du/
+obj-y				+= flashlight/
+obj-y				+= sensor_detect/
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/flashlight/Kconfig b/drivers/media/i2c/camera/flashlight/Kconfig
new file mode 100755
index 0000000..7247e5a4
--- /dev/null
+++ b/drivers/media/i2c/camera/flashlight/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config FLASHLIGHT
+	tristate "flashlight sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for flashlight
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called flashlight.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/flashlight/Makefile b/drivers/media/i2c/camera/flashlight/Makefile
new file mode 100755
index 0000000..762cc12
--- /dev/null
+++ b/drivers/media/i2c/camera/flashlight/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_FLASHLIGHT)	+= flashlight.o
+
diff --git a/drivers/media/i2c/camera/flashlight/flashlight.c b/drivers/media/i2c/camera/flashlight/flashlight.c
new file mode 100755
index 0000000..66e7cdc
--- /dev/null
+++ b/drivers/media/i2c/camera/flashlight/flashlight.c
@@ -0,0 +1,276 @@
+/*
+ * arch/arm/mach-msm/flashlight.c - flashlight driver
+ *
+ *  Copyright (C) 2009 raymond wang <wangjiaqi@actions-semi.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/earlysuspend.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/wakelock.h>
+#include <linux/hrtimer.h>
+#include <linux/leds.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <linux/of_gpio.h>
+
+#include "flashlight.h"
+
+#define GPIO_NAME_FLASHLIGHT	"flashlight_gpio"
+
+struct flashlight_struct {
+	struct led_classdev fl_lcdev;
+	struct early_suspend early_suspend_flashlight;
+	spinlock_t spin_lock;
+	struct hrtimer timer;
+	int brightness;
+	int gpio_pin;
+	int flash_duration_ms;
+};
+
+static struct flashlight_struct the_fl;
+//static struct gpio_pre_cfg gpio_cfg;
+static bool gpio_act_level=1;
+static int gpio_pin;
+static bool flashlight_exist = false;
+    
+#if 0
+static inline void toggle(void)
+{
+	gpio_direction_output(the_fl.gpio_torch, 0);
+	udelay(2);
+	gpio_direction_output(the_fl.gpio_torch, 1);
+	udelay(2);
+}
+
+static void flashlight_hw_command(uint8_t addr, uint8_t data)
+{
+	int i;
+
+	for (i = 0; i < addr + 17; i++)
+		toggle();
+	udelay(500);
+
+	for (i = 0; i < data; i++)
+		toggle();
+	udelay(500);
+}
+#endif
+
+static enum hrtimer_restart flashlight_timeout(struct hrtimer *timer)
+{
+	unsigned long flags;
+
+	pr_debug("%s\n", __func__);
+
+	spin_lock_irqsave(&the_fl.spin_lock, flags);
+	gpio_direction_output(gpio_pin, 0);
+	the_fl.brightness = LED_OFF;
+	spin_unlock_irqrestore(&the_fl.spin_lock, flags);
+
+	return HRTIMER_NORESTART;
+}
+
+int flashlight_control(int mode)
+{
+	int ret = 0;
+	unsigned long flags;
+	printk("[flashlight] function:%s , mode:%d \n",__func__,mode);
+	
+
+	spin_lock_irqsave(&the_fl.spin_lock, flags);
+
+	/*if (!flashlight_exist) {
+		ret = -EINVAL;
+		goto done;
+	}*/
+	
+	the_fl.brightness = mode;
+
+	switch (mode) {
+	case FLASHLIGHT_TORCH:
+#if 0
+		pr_info("%s: half\n", __func__);
+		/* If we are transitioning from flash to torch, make sure to
+		 * cancel the flash timeout timer, otherwise when it expires,
+		 * the torch will go off as well.
+		 */
+		hrtimer_cancel(&the_fl.timer);
+		flashlight_hw_command(2, 4);
+#else
+		gpio_direction_output(gpio_pin, gpio_act_level);
+#endif
+
+		break;
+
+	case FLASHLIGHT_FLASH:
+       	gpio_direction_output(gpio_pin, gpio_act_level);
+
+		break;
+
+	case FLASHLIGHT_OFF:
+       	gpio_direction_output(gpio_pin, gpio_act_level ^ 0x1);
+		break;
+
+	default:
+		pr_err("%s: unknown flash_light flags: %d\n", __func__, mode);
+		ret = -EINVAL;
+		goto done;
+	}
+
+done:
+	spin_unlock_irqrestore(&the_fl.spin_lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(flashlight_control);
+
+static void fl_lcdev_brightness_set(struct led_classdev *led_cdev,
+		enum led_brightness brightness)
+{
+	int level;
+
+	switch (brightness) {
+	case LED_HALF:
+		level = FLASHLIGHT_TORCH;
+		break;
+	case LED_FULL:
+		level = FLASHLIGHT_FLASH;
+		break;
+	case LED_OFF:
+	default:
+		level = FLASHLIGHT_OFF;
+	};
+
+	flashlight_control(level);
+}
+
+static void flashlight_early_suspend(struct early_suspend *handler)
+{
+	flashlight_control(FLASHLIGHT_OFF);
+}
+
+static int flashlight_init_gpio(struct flashlight_platform_data *fl_pdata,struct platform_device *pdev)
+{
+	int ret;
+	enum of_gpio_flags flags;
+
+	printk("[flashlight] function:%s\n",__func__);
+    flashlight_exist = false;
+	/*ret = gpio_get_pre_cfg(GPIO_NAME_FLASHLIGHT, &gpio_cfg);
+	if (ret != 0) {
+		goto out;
+	}
+
+	gpio_pin = ASOC_GPIO_PORT(gpio_cfg.iogroup, gpio_cfg.pin_num);*/
+	
+	gpio_pin = of_get_named_gpio_flags(pdev->dev.of_node, "flashlight-gpios", 0, &flags);
+	printk("flashlight GPIO: %d \n",gpio_pin);
+	gpio_act_level = !(flags & OF_GPIO_ACTIVE_LOW);
+	ret = gpio_request(gpio_pin, GPIO_NAME_FLASHLIGHT);
+    if (ret == 0) {
+        gpio_direction_output(gpio_pin, gpio_act_level ^ 0x1);
+        flashlight_exist = true;            
+    } else {
+		goto out;
+    }
+
+out:
+	return ret;
+}
+
+
+static int flashlight_probe(struct platform_device *pdev)
+{
+	struct flashlight_platform_data *fl_pdata = pdev->dev.platform_data;
+	int err = 0;
+	printk("[flashlight] function:%s ,line:%d \n",__func__,__LINE__);
+	err = flashlight_init_gpio(fl_pdata,pdev);
+	if (err < 0) {
+		pr_err("%s: setup GPIO failed\n", __func__);
+		goto fail_free_mem;
+	}
+	spin_lock_init(&the_fl.spin_lock);
+	the_fl.fl_lcdev.name = pdev->name;
+	the_fl.fl_lcdev.brightness_set = fl_lcdev_brightness_set;
+	the_fl.fl_lcdev.brightness = LED_OFF;
+
+	err = led_classdev_register(&pdev->dev, &the_fl.fl_lcdev);
+	if (err < 0) {
+		pr_err("failed on led_classdev_register\n");
+		goto fail_free_gpio;
+	}
+
+	hrtimer_init(&the_fl.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	the_fl.timer.function = flashlight_timeout;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	the_fl.early_suspend_flashlight.suspend = flashlight_early_suspend;
+	the_fl.early_suspend_flashlight.resume = NULL;
+	register_early_suspend(&the_fl.early_suspend_flashlight);
+#endif
+
+	return 0;
+
+fail_free_gpio:
+	if (gpio_pin)
+		gpio_free(gpio_pin);
+fail_free_mem:
+	return err;
+}
+
+static int flashlight_remove(struct platform_device *pdev)
+{
+
+	hrtimer_cancel(&the_fl.timer);
+	unregister_early_suspend(&the_fl.early_suspend_flashlight);
+	flashlight_control(FLASHLIGHT_OFF);
+	led_classdev_unregister(&the_fl.fl_lcdev);
+	if (gpio_pin)
+		gpio_free(gpio_pin);
+	
+	return 0;
+}
+
+static struct of_device_id flashlight_of_match[] = {
+    { .compatible = "flashlight" },
+    { }
+};
+
+static struct platform_driver flashlight_driver = {
+	.driver	= {
+		.name = "flashlight",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(flashlight_of_match),
+	},
+	.probe		= flashlight_probe,
+	.remove		= flashlight_remove,
+};
+
+static int __init flashlight_init(void)
+{
+	int ret;
+
+    printk("[flash light] %s version: %s, 2015-01-08\n", THIS_MODULE->name, THIS_MODULE->version);
+
+	ret = platform_driver_register(&flashlight_driver);
+
+	return ret;
+}
+
+static void __exit flashlight_exit(void)
+{
+	platform_driver_unregister(&flashlight_driver);
+}
+
+module_init(flashlight_init);
+module_exit(flashlight_exit);
+
+MODULE_AUTHOR("Actions Semi, Inc");
+MODULE_DESCRIPTION("flash light driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/media/i2c/camera/flashlight/flashlight.h b/drivers/media/i2c/camera/flashlight/flashlight.h
new file mode 100755
index 0000000..5435575
--- /dev/null
+++ b/drivers/media/i2c/camera/flashlight/flashlight.h
@@ -0,0 +1,22 @@
+#ifndef __ASM_ARM_ARCH_FLASHLIGHT_H
+#define __ASM_ARM_ARCH_FLASHLIGHT_H
+
+#include <linux/gpio.h>
+#include <mach/gpio.h>
+
+#define FLASHLIGHT_NAME "flashlight"
+
+#define FLASHLIGHT_OFF   0
+#define FLASHLIGHT_TORCH 1
+#define FLASHLIGHT_FLASH 2
+#define FLASHLIGHT_NUM   3
+
+struct flashlight_platform_data {
+    struct gpio_pre_cfg *gpio_cfg;
+	int gpio_pin;
+	int flash_duration_ms;
+};
+
+int flashlight_control(int level);
+
+#endif /*__ASM_ARM_ARCH_FLASHLIGHT_H*/
diff --git a/drivers/media/i2c/camera/gc0308/Kconfig b/drivers/media/i2c/camera/gc0308/Kconfig
new file mode 100755
index 0000000..5a046ff
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0308/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config GC0308
+	tristate "gc0308 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for gc0308 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc0308.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc0308/Makefile b/drivers/media/i2c/camera/gc0308/Makefile
new file mode 100755
index 0000000..78c4096
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0308/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_GC0308)	+= gc0308.o
+
diff --git a/drivers/media/i2c/camera/gc0308/gc0308.c b/drivers/media/i2c/camera/gc0308/gc0308.c
new file mode 100755
index 0000000..79d17d0
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0308/gc0308.c
@@ -0,0 +1,508 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include"../module_comm/camera_chip_ident.h"
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0)
+			{
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+			}
+		vals++;
+	}
+	return 0;
+}
+
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret = 0;
+	unsigned int reg_0xfe;
+	printk("in the gc0308 module_soft_reset\n");
+	//struct i2c_adapter *i2c_adap = client->adapter;
+	ret = camera_i2c_read(client->adapter, 0xfe, &reg_0xfe);
+	reg_0xfe |= (0x1<<7);
+	ret = camera_i2c_write(client->adapter, 0xfe, reg_0xfe);
+	msleep(10);
+	return ret;
+}
+
+static int  module_start_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+
+	//printk("int the module_start_aec\n ");
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_freeze_aec\n ");
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_set_exposure_param\n ");
+	return ret;
+}
+
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int scene_exposure = ctrl->val;
+	
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_NIGHT:  //\CA\D2\C4\DA
+		ret = camera_write_array(client->adapter, module_scene_night_regs);
+		break;
+	
+	case V4L2_SCENE_MODE_SUNSET:  //\CA\D2\CD\E2
+		ret = camera_write_array(client->adapter, module_scene_auto_regs);
+		break;
+	
+	default:
+		printk("[gc2035] set scene_exposure over range, scene_exposure = %d\n", scene_exposure);
+		return -ERANGE;
+	}
+
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+	return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_save_exposure_param\n ");
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	//int auto_white_balance = ctrl->val;
+	int ret = 0;
+	
+	int auto_white_balance;
+		if(ctrl)
+			{
+			auto_white_balance = ctrl->val;
+		}
+		else 
+			{
+				auto_white_balance = 1;
+			}
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		{
+	ctrl->cur.val = auto_white_balance;
+		}
+
+	return ret;
+}
+
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	 int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	
+	switch(ctrl->val){
+		case 4:
+			camera_write_array(client->adapter,module_exp_comp_pos4_regs);
+			break;
+		case 3:
+			camera_write_array(client->adapter,module_exp_comp_pos3_regs);
+			break;
+		case 2:
+			camera_write_array(client->adapter,module_exp_comp_pos2_regs);
+			break;
+		case 1:
+			camera_write_array(client->adapter,module_exp_comp_pos1_regs);
+			break;
+		case 0:
+			camera_write_array(client->adapter,module_exp_comp_zero_regs);
+			break;
+		case -1:
+			camera_write_array(client->adapter,module_exp_comp_neg1_regs);
+			break;
+		case -2:
+			camera_write_array(client->adapter,module_exp_comp_neg2_regs);
+			break;
+		case -3:
+			camera_write_array(client->adapter,module_exp_comp_neg3_regs);
+			break;
+		case -4:
+			camera_write_array(client->adapter,module_exp_comp_neg4_regs);
+			break;
+		default:
+			break;		
+	}
+
+	
+	return ret;
+}
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	ctrl->val = (0 + 16) * 16;
+	return ret;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+
+
+
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+   // int exposure_auto = ctrl->val;
+	int ret = 0;
+	
+	int exposure_auto;
+		if(ctrl)
+			{
+			exposure_auto = ctrl->val;
+			}
+		else 
+			{
+				exposure_auto = V4L2_EXPOSURE_AUTO;
+			}
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		{
+	ctrl->cur.val = exposure_auto;
+		}
+
+	return 0;
+}
+
+
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	
+	int ret = 0;
+	unsigned int analog1;
+	//mdelay(10);
+	//struct i2c_adapter *i2c_adap = client->adapter;
+    camera_i2c_read(client->adapter, 0x1a, &analog1);
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+		     /* power down all analog modules */
+		analog1 |= 0x01;
+        ret = camera_i2c_write(client->adapter, 0x1a,analog1 );
+        /* power down data, pclk, vsync, hsync */
+        ret = camera_i2c_write(client->adapter, 0x25, 0x00);
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	   analog1 &= 0xfe;
+	   ret = camera_i2c_write(client->adapter, 0x1a,analog1);
+       ret = camera_i2c_write(client->adapter, 0x25, 0xff);
+	   return ret;
+}
+
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+
+
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	int ret = 0;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		
+		break;
+		
+	default:
+		return -ERANGE;
+	}
+	
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	unsigned int reg_0x14 = 0x10;
+	unsigned int reg_0xfe = 0x00;
+	if ((!mirror) && (!flip)) {
+		return 0;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+
+	if (mirror)	{
+		reg_0x14 |= 0x1;
+	} else {
+		reg_0x14 &= (~0x1);
+	}
+	
+	if (flip) {
+		reg_0x14 |= (0x1<<0x1);
+	} else {
+		reg_0x14 &= (~(0x1<<0x1));	
+	}
+
+	ret |= camera_i2c_write(i2c_adap, 0x14, reg_0x14);
+	return ret;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int  		pid;
+	int ret = 0;
+	camera_i2c_write(i2c_adap,0xfe,0x00);
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PID, &pid); 
+	switch (pid) 
+    {
+	case CAMERA_MODULE_PID:
+		if(priv)
+			{
+		     priv->model= V4L2_IDENT_GC0308;
+			}
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, pid);
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, pid);
+		return -ENODEV;
+	}
+	return ret;
+}
+
+
+
diff --git a/drivers/media/i2c/camera/gc0308/module_diff.h b/drivers/media/i2c/camera/gc0308/module_diff.h
new file mode 100755
index 0000000..e8c039a
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0308/module_diff.h
@@ -0,0 +1,822 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+
+#define CAMERA_MODULE_NAME 		"gc0308"
+#define CAMERA_MODULE_PID		0x9B
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_I2C_REAL_ADDRESS  (0x42>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x21)
+
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+#define IS_FRONT_OR_REAR        0
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING
+
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+
+
+#if 1
+#define PID						0x00 /* Product ID Number */
+#else
+#define PIDH					XXX /* Product ID Number H byte */
+#define PIDL					XXX /* Product ID Number L byte */
+#endif
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA
+#define MODULE_MAX_WIDTH		WIDTH_VGA
+#define MODULE_MAX_HEIGHT		HEIGHT_VGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		1
+#define DROP_NUM_PREVIEW		2
+//static unsigned int frame_rate_qqvga[]  = {30,};
+static unsigned int frame_rate_qvga[]  = {30,};
+static unsigned int frame_rate_vga[]   = {15,};
+
+
+static const struct regval_list module_init_regs[] =
+{
+	/* for the setting , 24M Mlck input and 24M Plck output */
+    // VGA_YUV 25 fps
+    // 24 MHz input clock, 24Mhz PCLK
+
+    {0xfe, 0x80},       // softreset
+    {0xfe, 0x00},
+    {0x22, 0x55},       // auto DNDD,SA,ABS
+    {0x03, 0x01},
+    {0x04, 0x2c},       //exp 300
+    {0x5a, 0x56},       //awb_r_gain
+    {0x5b, 0x40},       //awb_g_gain
+    {0x5c, 0x4a},       //awb_b_gain
+    {0x22, 0x57},       //add auto AWB
+    {0x0f, 0x00},
+
+    {0x01, 0x6a},       //horizontal blanking 106
+    {0x02, 0x70},       //vertical blanking 137
+    {0x0f, 0x00},       // vb and hb high 4 bits
+    {0xe2, 0x00},       //anti-flicker step [11:8]
+    {0xe3, 0x96},       // anti-flicker step [7:0]
+    {0xe4, 0x03},       //exposure level 1~4
+    {0xe5, 0x84},       //25FPS
+    {0xe6, 0x04},
+    {0xe7, 0xb0},
+    {0xe8, 0x07},
+    {0xe9, 0x08},
+    {0xea, 0x07},
+    {0xeb, 0x08},
+    //frame rate ctrl
+    {0x05, 0x00},       //start row
+    {0x06, 0x00},
+    {0x07, 0x00},       //start column
+    {0x08, 0x02},
+    {0x09, 0x01},       // height
+    {0x0a, 0xea},
+    {0x0b, 0x02},       // width
+    {0x0c, 0x88},
+    {0x0d, 0x02},       //st
+    {0x0e, 0x02},       //et
+    {0x10, 0x26},
+    {0x11, 0x0d},
+    {0x12, 0x2a},       //sample-hold delay time
+
+    {0x13, 0x00},
+    {0x14, 0x10},       // h_v
+    {0x15, 0x0a},
+    {0x16, 0x05},
+    {0x17, 0x01},
+    {0x18, 0x44},
+    {0x19, 0x44},
+    {0x1a, 0x2a},
+    {0x1b, 0x00},
+    {0x1c, 0x49},
+    {0x1d, 0x9a},
+    {0x1e, 0x61},
+    {0x1f, 0x2b/*0x16*/}, // pad drive level
+    //isp
+    {0x20, 0xff},       //block enable
+    {0x21, 0xf8},       //fa
+    {0x22, 0x57},       // auto enable
+    {0x24, 0xa0},       //UYVY
+    {0x25, 0x0f},       // data, pclk, hsync, vsync enable
+    {0x26, 0x03},       //hsync and vsync high valid
+    {0x2f, 0x01},       //update gain mode
+    //blk
+    {0x30, 0xf7},
+    {0x31, 0x50},
+    {0x32, 0x00},
+    {0x39, 0x04},
+    {0x3a, 0x20},
+    {0x3b, 0x20},
+    {0x3c, 0x00},       //manual gain
+    {0x3d, 0x00},
+    {0x3e, 0x00},
+    {0x3f, 0x00},
+    //pregain
+    {0x50, 0x14},       //global gain
+    {0x53, 0x80},       //channel gain
+    {0x54, 0x87},
+    {0x55, 0x87},
+    {0x56, 0x80},
+    //lsc
+    {0x8b, 0x20},
+    {0x8c, 0x20},
+    {0x8d, 0x20},
+    {0x8e, 0x14},
+    {0x8f, 0x10},
+    {0x90, 0x14},
+    {0x91, 0x3c},
+    {0x92, 0x50},
+    {0x5d, 0x12},
+    {0x5e, 0x1a},
+    {0x5f, 0x24},
+    //dndd
+    {0x60, 0x07},
+    {0x61, 0x15},
+    {0x62, 0x08},
+    {0x64, 0x03},
+    {0x66, 0xe8},
+    {0x67, 0x86},
+    {0x68, 0xa2},
+    // asde
+    {0x69, 0x18},
+    {0x6a, 0x0f},
+    {0x6b, 0x00},
+    {0x6c, 0x5f},
+    {0x6d, 0x8f},
+    {0x6e, 0x55},
+    {0x6f, 0x38},
+    {0x70, 0x15},
+    {0x71, 0x33},
+    //intpee
+    {0x72, 0xdc},
+    {0x73, 0x80},
+    {0x74, 0x02},
+    {0x75, 0x3f},
+    {0x76, 0x02},
+    {0x77, 0x54},
+    {0x78, 0x88},
+    {0x79, 0x81},
+    {0x7a, 0x81},
+    {0x7b, 0x22},
+    {0x7c, 0xff},
+    //cc
+    {0x93, 0x4c},
+    {0x94, 0x02},
+    {0x95, 0x07},
+    {0x96, 0xe0},
+    {0x97, 0x46},
+    {0x98, 0xf3},
+    //ycp
+    {0xb1, 0x40},       //3
+    {0xb2, 0x40},
+    {0xb3, 0x40},
+    {0xb5, 0x00},
+    {0xb6, 0xe0},
+    {0xbd, 0x3C},
+    {0xbe, 0x36},
+    //aec
+    {0xd0, 0xCb},
+    {0xd1, 0x10},
+    {0xd2, 0x90},       // AEC enable
+    {0xd3, 0x58},
+    {0xd5, 0xF2},
+    {0xd6, 0x10},
+    {0xdb, 0x92},
+    {0xdc, 0xA5},
+    {0xdf, 0x23},
+    {0xd9, 0x00},
+    {0xda, 0x00},
+    {0xe0, 0x09},
+    {0xed, 0x04},
+    {0xee, 0xa0},
+    {0xef, 0x40},
+    //abb
+    {0x80, 0x03},       //ABB enable
+    //gamma
+    {0x9F, 0x0e},
+    {0xA0, 0x1c},
+    {0xA1, 0x34},
+    {0xA2, 0x48},
+    {0xA3, 0x5a},
+    {0xA4, 0x6b},
+    {0xA5, 0x7b},
+    {0xA6, 0x95},
+    {0xA7, 0xab},
+    {0xA8, 0xbf},
+    {0xA9, 0xce},
+    {0xAA, 0xd9},
+    {0xAB, 0xe4},
+    {0xAC, 0xec},
+    {0xAD, 0xF7},
+    {0xAE, 0xFd},
+    {0xAF, 0xFF},
+    //ycp-gamma
+    {0xc0, 0x00},
+    {0xc1, 0x14},
+    {0xc2, 0x21},
+    {0xc3, 0x36},
+    {0xc4, 0x49},
+    {0xc5, 0x5B},
+    {0xc6, 0x6B},
+    {0xc7, 0x7B},
+    {0xc8, 0x98},
+    {0xc9, 0xB4},
+    {0xca, 0xCE},
+    {0xcb, 0xE8},
+    {0xcc, 0xFF},
+    //abs
+    {0xf0, 0x02},
+    {0xf1, 0x01},
+    {0xf2, 0x02},
+    {0xf3, 0x30},
+    //measure window
+    {0xf7, 0x12},
+    {0xf8, 0x0a},
+    {0xf9, 0x9f},
+    {0xfa, 0x78},
+    //awb
+    {0xfe, 0x01},       //select page1
+    {0x00, 0xf5},
+    {0x02, 0x20},
+    {0x04, 0x10},
+    {0x05, 0x08},
+    {0x06, 0x20},
+    {0x08, 0x0a},
+    {0x0a, 0xa0},
+    {0x0b, 0x64},
+    {0x0c, 0x08},
+    {0x0e, 0x44},
+    {0x0f, 0x32},
+    {0x10, 0x41},
+    {0x11, 0x37},
+    {0x12, 0x22},       //awb gain adjust speed
+    {0x13, 0x19},
+    {0x14, 0x44},       //awb_set1
+    {0x15, 0x44},
+    {0x16, 0xc2},
+    {0x17, 0xA8},
+    {0x18, 0x18},
+    {0x19, 0x50},
+    {0x1a, 0xd8},
+    {0x1b, 0xf5},
+    {0x1c, 0x60},       //r gain limit
+    {0x70, 0x40},       //awb_set2
+    {0x71, 0x58},
+    {0x72, 0x30},
+    {0x73, 0x48},
+    {0x74, 0x20},
+    {0x75, 0x60},
+    {0x77, 0x20},
+    {0x78, 0x32},
+    //hsp
+    {0x30, 0x03},
+    {0x31, 0x40},
+    {0x32, 0x10},
+    {0x33, 0xe0},
+    {0x34, 0xe0},
+    {0x35, 0x00},
+    {0x36, 0x80},
+    {0x37, 0x00},
+    {0x38, 0x04},
+    {0x39, 0x09},
+    {0x3a, 0x12},
+    {0x3b, 0x1C},
+    {0x3c, 0x28},
+    {0x3d, 0x31},
+    {0x3e, 0x44},
+    {0x3f, 0x57},
+    {0x40, 0x6C},
+    {0x41, 0x81},
+    {0x42, 0x94},
+    {0x43, 0xA7},
+    {0x44, 0xB8},
+    {0x45, 0xD6},
+    {0x46, 0xEE},
+    {0x47, 0x0d},
+
+    //-----------Update the registers end---------//
+
+    {0xfe, 0x00},       // back to page0
+    ENDMARKER,
+};
+
+#if 0
+/* 160*120: QVGA */
+static const struct regval_list module_qqvga_regs[] = 
+{
+	// YUV 25 fps
+	{0xfe, 0x01},
+	{0x54, 0x44},
+	{0x55, 0x03},
+	{0x56, 0x00},
+	{0x57, 0x00},
+	{0x58, 0x00},
+	{0x59, 0x00},
+
+	{0xfe, 0x00},
+	{0x01, 0x6a},
+	{0x02, 0x70},
+	{0x0f, 0x00},
+	{0x05, 0x00},
+	{0x06, 0x00},
+	{0x07, 0x00},
+	{0x08, 0x00},
+	{0x09, 0x01},
+	{0x0a, 0xe8},
+	{0x0b, 0x02},
+	{0x0c, 0x88},
+
+	{0x91, 0x3c},		//LSC row center
+	{0x92, 0x50},		//LSC colum center
+	{0xf7, 0x01},		//big_win_x0,X4
+	{0xf8, 0x01},		//big_win_y0
+	{0xf9, 0x9c},		//big_win_x1
+	{0xfa, 0x76},		//big_win_y1
+
+	{0xfe, 0x01},
+	{0x0a, 0xa0},
+	{0x0e, 0x44},
+	{0x0f, 0x32},
+	{0xfe, 0x00},	
+	ENDMARKER,
+};
+#endif
+
+/* 320*240: QVGA */
+static const struct regval_list module_qvga_regs[] = 
+{
+	
+	//YUV 25fps
+	   {0xfe, 0x01},
+	   {0x54, 0x22},
+	   {0x55, 0x03},
+	   {0x56, 0x00},
+	   {0x57, 0x00},
+	   {0x58, 0x00},
+	   {0x59, 0x00},
+	
+	   {0xfe, 0x00},
+	   {0x01, 0x6a},
+	   {0x02, 0x70},
+	   {0x0f, 0x00},
+	   {0x05, 0x00},
+	   {0x06, 0x00},
+	   {0x07, 0x00},
+	   {0x08, 0x00},
+	   {0x09, 0x01},
+	   {0x0a, 0xe8},
+	   {0x0b, 0x02},
+	   {0x0c, 0x88},
+	
+	   {0x91, 0x3c},	   //LSC row center
+	   {0x92, 0x50},	   //LSC colum center
+	   {0xf7, 0x01},	   //big_win_x0,X4
+	   {0xf8, 0x01},	   //big_win_y0
+	   {0xf9, 0x9c},	   //big_win_x1
+	   {0xfa, 0x76},	   //big_win_y1
+	
+	   {0xfe, 0x01},
+	   {0x0a, 0xa0},
+	   {0x0e, 0x44},
+	   {0x0f, 0x32},
+	   {0xfe, 0x00},
+	   ENDMARKER,
+};
+
+/* 640*480: VGA */
+static const struct regval_list module_vga_regs[] = 
+{
+
+	 //YUV 25fps
+    {0xfe, 0x01},
+    {0x54, 0x11},
+    {0x55, 0x03},
+    {0x56, 0x00},
+    {0x57, 0x00},
+    {0x58, 0x00},
+    {0x59, 0x00},
+
+    {0xfe, 0x00},
+    {0x01, 0x6a},
+    {0x02, 0x70},
+    {0x0f, 0x00},
+    {0x05, 0x00},
+    {0x06, 0x00},
+    {0x07, 0x00},
+    {0x08, 0x00},
+    {0x09, 0x01},
+    {0x0a, 0xe8},
+    {0x0b, 0x02},
+    {0x0c, 0x88},
+
+    {0x91, 0x3c},       //LSC row center
+    {0x92, 0x50},       //LSC colum center
+    {0xf7, 0x04},       //big_win_x0,X4
+    {0xf8, 0x02},       //big_win_y0
+    {0xf9, 0x9f},       //big_win_x1
+    {0xfa, 0x78},       //big_win_y1
+
+    {0xfe, 0x01},
+    {0x0a, 0xa0},
+    {0x0e, 0x44},
+    {0x0f, 0x32},
+    {0xfe, 0x00},
+    ENDMARKER,
+};
+
+/* 800*600: SVGA */
+static const struct regval_list module_svga_regs[] = 
+{
+//  NULL
+};
+
+/* 1280*720: 720P*/
+static const struct regval_list module_720p_regs[] = 
+{
+//  NULL
+};
+
+/* 1600*1200: UXGA */
+static const struct regval_list module_uxga_regs[] = 
+{
+//  NULL
+};
+
+/* 1920*1080: 1080P*/
+static const struct regval_list module_1080p_regs[] = 
+{
+//  NULL
+};
+
+/* 2592X1944 QSXGA */
+static const struct regval_list module_qsxga_regs[] = 
+{
+//  NULL
+};
+
+static const struct regval_list module_init_auto_focus[] =
+{
+//  NULL
+};
+
+#if 0
+/*
+ * window size list
+ */
+ /* 320*240 */
+static struct camera_module_win_size module_win_qqvga = {
+	.name             = "QQVGA",
+	.width            = WIDTH_QQVGA,
+	.height           = HEIGHT_QQVGA,
+	.win_regs         = module_qqvga_regs,
+
+	.frame_rate_array = frame_rate_qqvga,
+	 .capture_only     = 0,
+};
+#endif
+/* 320*240 */
+static struct camera_module_win_size module_win_qvga = {
+	.name             = "QVGA",
+	.width            = WIDTH_QVGA,
+	.height           = HEIGHT_QVGA,
+	.win_regs         = module_qvga_regs,
+
+	.frame_rate_array = frame_rate_qvga,
+	 .capture_only     = 0,
+	
+};
+
+/* 640*480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+#if 0
+/* 800*600 */
+static struct camera_module_win_size module_win_svga = {
+	.name             = "VGA",
+	.width            = WIDTH_SVGA,
+	.height           = HEIGHT_SVGA,
+	.win_regs         = module_svga_regs,
+	.win_regs_size    = ARRAY_SIZE(module_svga_regs),
+
+	.frame_rate_array = frame_rate_svga,
+};
+
+/* 1280*720 */
+static struct camera_module_win_size module_win_720p = {
+	.name             = "720P",
+	.width            = WIDTH_720P,
+	.height           = HEIGHT_720P,
+	.win_regs         = module_720p_regs,
+	.win_regs_size    = ARRAY_SIZE(module_720p_regs),
+	.frame_rate_array = frame_rate_720p,
+};
+/* 1600*1200 */
+static struct camera_module_win_size module_win_uxga = {
+	.name             = "UXGA",
+	.width            = WIDTH_UXGA,
+	.height           = HEIGHT_UXGA,
+	.win_regs         = module_uxga_regs,
+	.win_regs_size    = ARRAY_SIZE(module_uxga_regs),
+	.frame_rate_array = frame_rate_uxga,
+};
+
+/* 1920*1080 */
+static struct camera_module_win_size module_win_1080p = {
+	.name             = "1080P",
+	.width            = WIDTH_1080P,
+	.height           = HEIGHT_1080P,
+	.win_regs         = module_1080p_regs,
+	.win_regs_size    = ARRAY_SIZE(module_1080p_regs),
+
+	.frame_rate_array = frame_rate_1080p,
+};
+
+/* 2592*1944 */
+static struct camera_module_win_size module_win_qsxga = {
+	.name             = "QSXGA",
+	.width            = WIDTH_QSXGA,
+	.height           = HEIGHT_QSXGA,
+	.win_regs         = module_qsxga_regs,
+	.win_regs_size    = ARRAY_SIZE(module_qsxga_regs),
+	.frame_rate_array = frame_rate_qsxga,
+};
+#endif
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_vga,
+	//&module_win_qqvga,
+	&module_win_qvga, 
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+	{0x22, 0x57}, 
+	{0x5a, 0x56},
+	{0x5b, 0x40},
+	{0x5c, 0x4a},
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	{0x22, 0x55},
+	{0x5a, 0x78},
+	{0x5b, 0x44},
+	{0x5c, 0x40},
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+	{0x22, 0x55},
+    {0x5a, 0x68},
+    {0x5b, 0x44},
+    {0x5c, 0x40},
+    ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+	{0x22, 0x55},
+    {0x5a, 0x48},
+    {0x5b, 0x40},
+    {0x5c, 0x58},
+    ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	{0x22, 0x55},
+    {0x5a, 0x48},
+    {0x5b, 0x40},
+    {0x5c, 0x68},
+	ENDMARKER,
+};
+
+
+static struct regval_list module_scene_auto_regs[] =
+{
+	{0xec, 0x20},
+	ENDMARKER,
+};
+
+
+
+static struct regval_list module_scene_night_regs[] =
+{
+	{0xec, 0x30},
+	ENDMARKER,
+
+};
+
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list module_exp_comp_neg4_regs[] = {
+	
+	{0xb5,0xd0},	
+	{0xd3,0x38}, 		
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg3_regs[] = {
+	
+	{0xb5,0xe0}, 
+	{0xd3,0x40},	
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg2_regs[] = {
+	
+	{0xb5,0xf0},   
+	{0xd3,0x48},	
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg1_regs[] = {
+	
+	{0xb5,0x00},  
+	{0xd3,0x50},	
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_zero_regs[] = {
+	
+	{0xb5,0x00},  
+	{0xd3,0x58},	
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos1_regs[] = {
+	
+	{0xb5,0x30},  
+	{0xd3,0x60},	
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos2_regs[] = {
+	
+	{0xb5,0x40},
+	{0xd3,0x68},	
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos3_regs[] = {
+   
+   {0xb5,0x50},  
+   {0xd3,0x70},	    
+
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos4_regs[] = {
+	
+	{0xb5,0x60},  
+	{0xd3,0x78},	
+	ENDMARKER,
+};
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{   .id = V4L2_CID_EXPOSURE, 
+		.min = 0, 
+		.max = 975,
+		.step = 1, 
+		.def = 500,
+	},
+	{	.id = V4L2_CID_EXPOSURE_COMP, 
+		.min = -4, 
+		.max = 4, 
+		.step = 1, 
+		.def = 0,
+	},	
+	{	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,
+	},
+	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},
+	{
+        .id = V4L2_CID_AUTO_WHITE_BALANCE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 1,
+    },
+    {
+        .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+        .min = 0,
+        .max = 3,
+        .step = 1,
+        .def = 0,
+    },
+
+    {
+        .id = V4L2_CID_HFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_VFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+       {	.id = V4L2_CID_AF_MODE,
+		.min = NONE_AF, 
+		.max = CONTINUE_AF|SINGLE_AF, 
+		.step = 1, 
+		.def = NONE_AF,},
+    {	.id = V4L2_CID_AF_STATUS, 
+		.min = AF_STATUS_DISABLE, 
+		.max = AF_STATUS_FAIL, 
+		.step = 1, 
+		.def = AF_STATUS_DISABLE,},
+	{	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	 {
+        .id = V4L2_CID_COLORFX,
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_EXPOSURE_AUTO,
+        .max = 1,
+        .mask = 0x0,
+        .def = 1,
+    },
+
+    {
+        .id = V4L2_CID_SCENE_MODE,
+        .max = V4L2_SCENE_MODE_TEXT,
+        .mask = 0x0,
+        .def = 0,
+    },
+	{	
+		.id   = V4L2_CID_FLASH_LED_MODE, 
+		.max  = 3,
+		.mask = 0x0,
+		.def  = 0,
+	},
+	{
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/gc0312/Kconfig b/drivers/media/i2c/camera/gc0312/Kconfig
new file mode 100755
index 0000000..27bae72
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0312/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config GC0312
+	tristate "gc0312 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for gc0312 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc0312.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc0312/Makefile b/drivers/media/i2c/camera/gc0312/Makefile
new file mode 100755
index 0000000..37b4963
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0312/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_GC0312)	+= gc0312.o
+
diff --git a/drivers/media/i2c/camera/gc0312/gc0312.c b/drivers/media/i2c/camera/gc0312/gc0312.c
new file mode 100755
index 0000000..7de46df
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0312/gc0312.c
@@ -0,0 +1,664 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0){
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+		}
+		vals++;
+	}
+	return 0;
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+	unsigned int ret = 0;
+	unsigned int reg_0xfe;
+	struct i2c_adapter *i2c_adap = client->adapter;
+
+	ret = camera_i2c_read(i2c_adap, 0xfe, &reg_0xfe);
+	reg_0xfe |= (0x1<<7);
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	msleep(3);
+	reg_0xfe &= ~(0x1<<7);
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	msleep(5);
+	
+	return ret;
+}
+
+/*
+static int module_soft_standby(struct i2c_client *client)
+{
+	int ret = 0;
+	unsigned int reg_0x1a;
+	unsigned int reg_0x25;
+	ret = camera_i2c_read(client, 0x1a, &reg_0x1a);
+	reg_0x1a |= (0x1<<0);
+	ret = camera_i2c_write(client, 0x1a, &reg_0x1a);
+	reg_0x25 = 0x00;
+	ret |= camera_i2c_write(client, 0x25, &reg_0x25);
+	return ret;	
+}
+
+static int module_normal(struct v4l2_subdev *sd)
+{
+
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	unsigned int reg_0x1a;
+	unsigned int reg_0xfe;
+	unsigned int reg_0x25;
+	
+	reg_0xfe = 0x00;
+	ret  = camera_i2c_write(client, 0xfe, &reg_0xfe);
+	ret |= camera_i2c_read(client, 0x1a, &reg_0x1a);
+	reg_0x1a &= (~(0x1<<0));
+	
+	ret |= camera_i2c_write(client, 0x1a, &reg_0x1a);
+	reg_0x25 = 0xff;
+	ret |= camera_i2c_write(client, 0x25, &reg_0x25);
+	
+	return ret;
+}
+*/
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+  	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0x4f = 0x01;
+	unsigned int reg_0x03;
+	unsigned int reg_0x04;
+	
+	//priv->preview_exposure_param.shutter = (priv->preview_exposure_param.shutter)*4;
+
+	reg_0x03 = ((priv->preview_exposure_param.shutter)>>8) & 0xFF ;
+	reg_0x04 = (priv->preview_exposure_param.shutter) & 0xFF;
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+	ret |= camera_i2c_write(i2c_adap, 0x04, reg_0x04);
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0x4f, reg_0x4f); 
+
+	//printk("GC0312 module_start_aec, win->name:%s\n", priv->win->name);
+	*/
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0x4f = 0x00;
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0x4f, reg_0x4f); 
+	//printk("GC0312 module_freeze_aec, win->name:%s\n", priv->win->name);
+	*/
+	return ret;
+}
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0x03;
+	unsigned int reg_0x04;
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_read(i2c_adap, 0x03, &reg_0x03);
+	ret |= camera_i2c_read(i2c_adap, 0x04, &reg_0x04);
+		
+	priv->preview_exposure_param.shutter = (reg_0x03 << 8) | reg_0x04;
+	priv->capture_exposure_param.shutter = (priv->preview_exposure_param.shutter)/2;
+	
+	//printk("GC2155 module_save_exposure_param, win->name:%s\n", priv->win->name);
+	*/
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0x03;
+	unsigned int reg_0x04;
+
+	if(0 == strcmp("QVGA", priv->win->name))
+	{
+		priv->capture_exposure_param.shutter = (priv->preview_exposure_param.shutter)*2;
+	}
+
+	if(priv->capture_exposure_param.shutter < 1) {
+		priv->capture_exposure_param.shutter = 1;
+	}
+	
+	reg_0x03 = ((priv->capture_exposure_param.shutter)>>8) & 0xFF ;
+	reg_0x04 = (priv->capture_exposure_param.shutter) & 0xFF;
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+	ret |= camera_i2c_write(i2c_adap, 0x04, reg_0x04);
+
+	//printk("GC0312 module_set_exposure_param, win->name:%s\n", priv->win->name);
+	*/
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int auto_white_balance;
+	int ret = 0;
+	
+	if(ctrl)
+		auto_white_balance = ctrl->val;
+	else
+		auto_white_balance = 1;
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		ctrl->cur.val = auto_white_balance;  
+		
+
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+#if 0
+static int module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int colorfx = ctrl->val;
+	int ret = 0;
+
+	switch (colorfx) {
+	case V4L2_COLORFX_NONE: ///* normal */
+		ret = camera_write_array(client, module_effect_normal_regs, ARRAY_SIZE(module_effect_normal_regs));
+		break;
+	
+	case V4L2_COLORFX_BW: /* black and white */
+		ret = camera_write_array(client, module_effect_white_black_regs, ARRAY_SIZE(module_effect_white_black_regs));
+		break;
+	
+	case V4L2_COLORFX_SEPIA: /* antique ,\B8\B4\B9\C5*/
+		ret = camera_write_array(client, module_effect_antique_regs, ARRAY_SIZE(module_effect_antique_regs));
+		break;
+
+	case V4L2_COLORFX_NEGATIVE: /* negative\A3\AC\B8\BAƬ */
+		ret = camera_write_array(client, module_effect_negative_regs, ARRAY_SIZE(module_effect_negative_regs));
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	priv->colorfx = colorfx;
+	ctrl->cur.val = colorfx;
+	return ret;
+}
+#endif 
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    int exposure_auto;
+	int ret = 0;
+
+	if(ctrl)
+		exposure_auto = ctrl->val;
+	else
+		exposure_auto = V4L2_EXPOSURE_AUTO;
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		ctrl->cur.val = exposure_auto;
+
+	return 0;
+}
+
+static int module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int scene_exposure = ctrl->val;
+//	unsigned int reg_0x3a00;
+	int ret = 0;
+#if 0
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_HOUSE:  //\CA\D2\C4\DA
+		ret = camera_write_array(client, module_scene_night_regs, ARRAY_SIZE(module_scene_night_regs));
+		break;
+	
+	case V4L2_SCENE_MODE_SUNLIGHT:  //\CA\D2\CD\E2
+		ret = camera_write_array(client, module_scene_auto_regs, ARRAY_SIZE(module_scene_auto_regs));
+		break;
+
+	default:
+		return -ERANGE;
+	}
+#endif
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+
+	return ret;
+}
+
+/*
+static int module_set_prev_capt_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+  int mode = ctrl->val;
+  
+	switch(mode) {
+	case PREVIEW_MODE:
+		priv->prev_capt_mode = mode;
+		break;
+
+	case CAPTURE_MODE:
+        priv->prev_capt_mode = mode;
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	ctrl->cur.val = mode;
+	return 0;
+}
+
+static int module_pause_af(struct i2c_client *client)
+{
+	int ret = 0;
+	
+    msleep(50);
+	
+	return ret;
+}
+
+static int module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+    return 0;
+}
+
+static int module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+    
+    return 0;
+}
+
+static int module_set_exposure(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+
+	return ret;
+}
+*/
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	unsigned char reg_0xfe = 0x00;
+	unsigned char reg_0xf3 = 0xff;
+	struct i2c_adapter *i2c_adap = client->adapter;
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+		   reg_0xf3 = 0x00;
+		   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+		   camera_i2c_write(i2c_adap, 0xf3, reg_0xf3);
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	   reg_0xf3 = 0xff;
+	   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	   camera_i2c_write(i2c_adap, 0xf3, reg_0xf3);
+	return 0;
+}
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	//unsigned int digital_gain = 0;
+	//unsigned int total_gain = 0;
+	int gain_value = 0;
+	int ret = 0;
+
+	int reg_00  = 0x01;
+	
+	ret = camera_i2c_write(client->adapter, 0xfe, reg_00);
+
+	ret |= camera_i2c_read(client->adapter, 0x14, &gain_value);
+
+	if(ret != 0)
+	{
+		printk("[siv121du] get gain error!\n");
+		return -1;
+	}
+	printk("---1func: %s  gain_value: %d---\r\n",__func__,gain_value);
+	gain_value = abs(110-gain_value);
+	ctrl->val = gain_value;
+	printk("---2func: %s  gain_value: %d---\r\n",__func__,gain_value);
+		
+	return gain_value;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+
+	return 0;
+}
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	struct i2c_adapter *i2c_adap = client->adapter;
+	unsigned int reg_0x44 = 0;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_0x44 = 0x02;
+		break;
+		
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		reg_0x44 = 0x00;
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		reg_0x44 = 0x03;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		reg_0x44 = 0x01;
+		break;
+		
+	default:
+		printk("[gc0312] %s, %d, mbus code error\n",__FUNCTION__, __LINE__);
+		return -1;
+	}
+	return camera_i2c_write(i2c_adap, 0x44, reg_0x44);
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	int ret = 0;
+	unsigned int reg_0x17 = 0x14;
+	unsigned int reg_0xfe = 0x00;
+	
+	if ((!mirror) && (!flip)) {
+		return 0;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+
+	if (mirror)	{
+		reg_0x17 |= 0x1;
+	} else {
+		reg_0x17 &= (~0x1);
+	}
+	
+	if (flip) {
+		reg_0x17 |= (0x1<<0x1);
+	} else {
+		reg_0x17 &= (~(0x1<<0x1));	
+	}
+
+	ret |= camera_i2c_write(i2c_adap, 0x17, reg_0x17);
+    return ret;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int    pidh = 0;
+	unsigned int		pidl = 0;
+	unsigned int	  PID = 0;
+	int ret = 0;
+	camera_i2c_write(i2c_adap,0xfe,0x00);
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PIDH, &pidh); 
+	ret |= camera_i2c_read(i2c_adap, PIDL, &pidl); 
+	PID = pidh<<8 | pidl;
+	switch (PID) 
+  {
+		case CAMERA_MODULE_PID:
+/*			if(priv)
+				priv->model = V4L2_IDENT_GC0312;*/
+			printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, PID);
+			break;
+	
+		default:
+			printk("[%s] Product ID error %x\n", CAMERA_MODULE_NAME,PID);
+			return -ENODEV;
+	}
+	return ret;
+}
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc0312/module_diff.h b/drivers/media/i2c/camera/gc0312/module_diff.h
new file mode 100755
index 0000000..13195ef
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0312/module_diff.h
@@ -0,0 +1,919 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME      "gc0312"
+#define CAMERA_MODULE_PID       0xb310  
+#define VERSION(pid, ver)       ((pid<<8)|(ver&0xFF))
+
+#define MODULE_PLATFORM_ID				GC0312_PLATFORM_ID
+#define MODULE_I2C_REAL_ADDRESS		(0x42>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x42>>1)
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+#define IS_FRONT_OR_REAR        1
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_LOW
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING
+#define DEFAULT_POWER_LINE_FREQUENCY    V4L2_CID_POWER_LINE_FREQUENCY_50HZ 
+
+#if 0
+#define PID						XXX /* Product ID Number */
+#else
+#define PIDH					0xf0 /* Product ID Number H byte */
+#define PIDL					0xf1 /* Product ID Number L byte */
+#endif
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA
+#define MODULE_MAX_WIDTH		WIDTH_VGA
+#define MODULE_MAX_HEIGHT		HEIGHT_VGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		4
+#define DROP_NUM_PREVIEW		4
+
+static unsigned int frame_rate_qvga[] = {30,};
+static unsigned int frame_rate_vga[]  = {30,};
+
+static const struct regval_list module_init_regs[] =
+{
+    
+    {0xfe, 0xf0},
+    {0xfe, 0xf0},
+    {0xfe, 0x00},
+    {0xfc, 0x0e}, 
+    {0xfc, 0x0e}, 
+    {0xf2, 0x07}, 
+    {0xf3, 0x00},// output_disable 
+    {0xf7, 0x1b}, 
+    {0xf8, 0x04}, 
+    {0xf9, 0x0e}, 
+    {0xfa, 0x11},
+        
+        /////////////////////////////////////////////////
+        /////////////////  CISCTL reg   /////////////////
+        /////////////////////////////////////////////////
+    {0x00, 0x2f},
+    {0x01, 0x0f},//06
+    {0x02, 0x04},
+    {0x03, 0x03},
+    {0x04, 0x50},
+    {0x09, 0x00},
+    {0x0a, 0x00},
+    {0x0b, 0x00},
+    {0x0c, 0x04},
+    {0x0d, 0x01},
+    {0x0e, 0xe8},
+    {0x0f, 0x02},
+    {0x10, 0x88},
+    {0x16, 0x00},
+    {0x17, 0x14},
+    {0x18, 0x1a},
+    {0x19, 0x14},
+    {0x1b, 0x48},
+    {0x1e, 0x6b},
+    {0x1f, 0x28},
+    {0x20, 0x89},
+    {0x21, 0x49},
+    {0x22, 0xb0},
+    {0x23, 0x04},
+    {0x24, 0x16},
+    {0x34, 0x20},
+        
+        /////////////////////////////////////////////////
+        ////////////////////   BLK   ////////////////////
+        /////////////////////////////////////////////////
+    {0x26, 0x23},
+    {0x28, 0xff},
+    {0x29, 0x00},
+    {0x33, 0x10}, 
+    {0x37, 0x20},
+    {0x38, 0x10},
+    {0x47, 0x80},
+    {0x4e, 0x66},
+    {0xa8, 0x02},
+    {0xa9, 0x80},
+        
+        /////////////////////////////////////////////////
+        //////////////////  ISP reg   ///////////////////
+        /////////////////////////////////////////////////
+    {0x40, 0xff},
+    {0x41, 0x21},
+    {0x42, 0xcf},
+//  {0x44, 0x02},
+    {0x45, 0xa8}, 
+    {0x46, 0x02}, //sync
+    {0x4a, 0x11},
+    {0x4b, 0x01},
+    {0x4c, 0x20},
+    {0x4d, 0x05},
+    {0x4f, 0x01},
+    {0x50, 0x01},
+    {0x55, 0x01},
+    {0x56, 0xe0},
+    {0x57, 0x02},
+    {0x58, 0x80},
+        
+        /////////////////////////////////////////////////
+        ///////////////////   GAIN   ////////////////////
+        /////////////////////////////////////////////////
+    {0x70, 0x70},
+    {0x5a, 0x84},
+    {0x5b, 0xc9},
+    {0x5c, 0xed},
+    {0x77, 0x74},
+    {0x78, 0x40},
+    {0x79, 0x5f},
+        
+        ///////////////////////////////////////////////// 
+        ///////////////////   DNDD  /////////////////////
+        ///////////////////////////////////////////////// 
+    {0x82, 0x14}, 
+    {0x83, 0x0b},
+    {0x89, 0xf0},
+        
+        ///////////////////////////////////////////////// 
+        //////////////////   EEINTP  ////////////////////
+        ///////////////////////////////////////////////// 
+    {0x8f, 0xaa}, 
+    {0x90, 0x8c}, 
+    {0x91, 0x90},
+    {0x92, 0x03}, 
+    {0x93, 0x03}, 
+    {0x94, 0x05}, 
+    {0x95, 0x65}, 
+    {0x96, 0xf0}, 
+        
+        ///////////////////////////////////////////////// 
+        /////////////////////  ASDE  ////////////////////
+        ///////////////////////////////////////////////// 
+    {0xfe, 0x00},
+                                           
+    {0x9a, 0x20},
+    {0x9b, 0x80},
+    {0x9c, 0x40},
+    {0x9d, 0x80},
+                                       
+    {0xa1, 0x30},
+     {0xa2, 0x32},
+    {0xa4, 0x30},
+    {0xa5, 0x30},
+    {0xaa, 0x10}, 
+    {0xac, 0x22},
+         
+        /////////////////////////////////////////////////
+        ///////////////////   GAMMA   ///////////////////
+        /////////////////////////////////////////////////
+    {0xfe, 0x00},//default
+    {0xbf, 0x08},
+    {0xc0, 0x16},
+    {0xc1, 0x28},
+    {0xc2, 0x41},
+    {0xc3, 0x5a},
+    {0xc4, 0x6c},
+    {0xc5, 0x7a},
+    {0xc6, 0x96},
+    {0xc7, 0xac},
+    {0xc8, 0xbc},
+    {0xc9, 0xc9},
+    {0xca, 0xd3},
+    {0xcb, 0xdd},
+    {0xcc, 0xe5},
+    {0xcd, 0xf1},
+    {0xce, 0xfa},
+    {0xcf, 0xff},
+        
+    /* 
+    {0xfe, 0x00},//big gamma
+    {0xbf, 0x08},
+    {0xc0, 0x1d},
+    {0xc1, 0x34},
+    {0xc2, 0x4b},
+    {0xc3, 0x60},
+    {0xc4, 0x73},
+    {0xc5, 0x85},
+    {0xc6, 0x9f},
+    {0xc7, 0xb5},
+    {0xc8, 0xc7},
+    {0xc9, 0xd5},
+    {0xca, 0xe0},
+    {0xcb, 0xe7},
+    {0xcc, 0xec},
+    {0xcd, 0xf4},
+    {0xce, 0xfa},
+    {0xcf, 0xff},
+    */  
+    
+    /*
+    {0xfe, 0x00},//small gamma
+    {0xbf, 0x08},
+    {0xc0, 0x18},
+    {0xc1, 0x2c},
+    {0xc2, 0x41},
+    {0xc3, 0x59},
+    {0xc4, 0x6e},
+    {0xc5, 0x81},
+    {0xc6, 0x9f},
+    {0xc7, 0xb5},
+    {0xc8, 0xc7},
+    {0xc9, 0xd5},
+    {0xca, 0xe0},
+    {0xcb, 0xe7},
+    {0xcc, 0xec},
+    {0xcd, 0xf4},
+    {0xce, 0xfa},
+    {0xcf, 0xff},
+    */
+    
+#if 0
+            case GC0310MIPI_RGB_Gamma_m1:                       //smallest gamma curve
+                {0xfe, 0x00},
+                {0xbf, 0x06},
+                {0xc0, 0x12},
+                {0xc1, 0x22},
+                {0xc2, 0x35},
+                {0xc3, 0x4b},
+                {0xc4, 0x5f},
+                {0xc5, 0x72},
+                {0xc6, 0x8d},
+                {0xc7, 0xa4},
+                {0xc8, 0xb8},
+                {0xc9, 0xc8},
+                {0xca, 0xd4},
+                {0xcb, 0xde},
+                {0xcc, 0xe6},
+                {0xcd, 0xf1},
+                {0xce, 0xf8},
+                {0xcf, 0xfd},
+                break;
+            case GC0310MIPI_RGB_Gamma_m2:
+                {0xBF, 0x08},
+                {0xc0, 0x0F},
+                {0xc1, 0x21},
+                {0xc2, 0x32},
+                {0xc3, 0x43},
+                {0xc4, 0x50},
+                {0xc5, 0x5E},
+                {0xc6, 0x78},
+                {0xc7, 0x90},
+                {0xc8, 0xA6},
+                {0xc9, 0xB9},
+                {0xcA, 0xC9},
+                {0xcB, 0xD6},
+                {0xcC, 0xE0},
+                {0xcD, 0xEE},
+                {0xcE, 0xF8},
+                {0xcF, 0xFF},
+                break;
+                
+            case GC0310MIPI_RGB_Gamma_m3:           
+                {0xBF, 0x0B},
+                {0xc0, 0x16},
+                {0xc1, 0x29},
+                {0xc2, 0x3C},
+                {0xc3, 0x4F},
+                {0xc4, 0x5F},
+                {0xc5, 0x6F},
+                {0xc6, 0x8A},
+                {0xc7, 0x9F},
+                {0xc8, 0xB4},
+                {0xc9, 0xC6},
+                {0xcA, 0xD3},
+                {0xcB, 0xDD},
+                {0xcC, 0xE5},
+                {0xcD, 0xF1},
+                {0xcE, 0xFA},
+                {0xcF, 0xFF},
+                
+                
+            case GC0310MIPI_RGB_Gamma_m4:
+                {0xBF, 0x0E},
+                {0xc0, 0x1C},
+                {0xc1, 0x34},
+                {0xc2, 0x48},
+                {0xc3, 0x5A},
+                {0xc4, 0x6B},
+                {0xc5, 0x7B},
+                {0xc6, 0x95},
+                {0xc7, 0xAB},
+                {0xc8, 0xBF},
+                {0xc9, 0xCE},
+                {0xcA, 0xD9},
+                {0xcB, 0xE4},
+                {0xcC, 0xEC},
+                {0xcD, 0xF7},
+                {0xcE, 0xFD},
+                {0xcF, 0xFF},
+                
+                
+            case GC0310MIPI_RGB_Gamma_m5:
+                {0xBF, 0x10},
+                {0xc0, 0x20},
+                {0xc1, 0x38},
+                {0xc2, 0x4E},
+                {0xc3, 0x63},
+                {0xc4, 0x76},
+                {0xc5, 0x87},
+                {0xc6, 0xA2},
+                {0xc7, 0xB8},
+                {0xc8, 0xCA},
+                {0xc9, 0xD8},
+                {0xcA, 0xE3},
+                {0xcB, 0xEB},
+                {0xcC, 0xF0},
+                {0xcD, 0xF8},
+                {0xcE, 0xFD},
+                {0xcF, 0xFF},
+                
+                
+            case GC0310MIPI_RGB_Gamma_m6:// largest gamma curve
+                {0xBF, 0x14},
+                {0xc0, 0x28},
+                {0xc1, 0x44},
+                {0xc2, 0x5D},
+                {0xc3, 0x72},
+                {0xc4, 0x86},
+                {0xc5, 0x95},
+                {0xc6, 0xB1},
+                {0xc7, 0xC6},
+                {0xc8, 0xD5},
+                {0xc9, 0xE1},
+                {0xcA, 0xEA},
+                {0xcB, 0xF1},
+                {0xcC, 0xF5},
+                {0xcD, 0xFB},
+                {0xcE, 0xFE},
+                {0xcF, 0xFF},
+                
+            case GC0310MIPI_RGB_Gamma_night:        //Gamma for night mode
+                {0xBF, 0x0B},
+                {0xc0, 0x16},
+                {0xc1, 0x29},
+                {0xc2, 0x3C},
+                {0xc3, 0x4F},
+                {0xc4, 0x5F},
+                {0xc5, 0x6F},
+                {0xc6, 0x8A},
+                {0xc7, 0x9F},
+                {0xc8, 0xB4},
+                {0xc9, 0xC6},
+                {0xcA, 0xD3},
+                {0xcB, 0xDD},
+                {0xcC, 0xE5},
+                {0xcD, 0xF1},
+                {0xcE, 0xFA},
+                {0xcF, 0xFF},
+                break;
+            default:
+                //GC0310MIPI_RGB_Gamma_m1
+                {0xfe, 0x00},
+                {0xbf, 0x06},
+                {0xc0, 0x12},
+                {0xc1, 0x22},
+                {0xc2, 0x35},
+                {0xc3, 0x4b},
+                {0xc4, 0x5f},
+                {0xc5, 0x72},
+                {0xc6, 0x8d},
+                {0xc7, 0xa4},
+                {0xc8, 0xb8},
+                {0xc9, 0xc8},
+                {0xca, 0xd4},
+                {0xcb, 0xde},
+                {0xcc, 0xe6},
+                {0xcd, 0xf1},
+                {0xce, 0xf8},
+                {0xcf, 0xfd},
+#endif
+        /////////////////////////////////////////////////
+        ///////////////////   YCP  //////////////////////
+        /////////////////////////////////////////////////
+    {0xd0, 0x40},
+    {0xd1, 0x34}, 
+    {0xd2, 0x34}, 
+    {0xd3, 0x40}, 
+    {0xd6, 0xf2},
+    {0xd7, 0x1b},
+    {0xd8, 0x18},
+    {0xdd, 0x03}, 
+        
+        /////////////////////////////////////////////////
+        ////////////////////   AEC   ////////////////////
+        /////////////////////////////////////////////////
+    {0xfe, 0x01},
+    {0x05, 0x30}, 
+    {0x06, 0x75}, 
+    {0x07, 0x40}, 
+    {0x08, 0xb0}, 
+    {0x0a, 0xc5}, 
+    {0x0b, 0x11}, 
+    {0x0c, 0x00},
+    {0x12, 0x52}, 
+    {0x13, 0x38}, 
+    {0x18, 0x95}, 
+    {0x19, 0x96}, 
+    {0x1f, 0x20}, 
+    {0x20, 0xc0}, //80
+    {0x3e, 0x40}, 
+    {0x3f, 0x57}, 
+    {0x40, 0x7d}, 
+    {0x03, 0x60},
+    {0x44, 0x02},
+        
+        /////////////////////////////////////////////////
+        ////////////////////   AWB   ////////////////////
+        /////////////////////////////////////////////////
+    {0x1c, 0x91}, 
+    {0x21, 0x15}, 
+    {0x50, 0x80}, 
+    {0x56, 0x04}, 
+    {0x59, 0x08}, 
+    {0x5b, 0x02},
+    {0x61, 0x8d}, 
+    {0x62, 0xa7}, 
+    {0x63, 0xd0}, 
+    {0x65, 0x06},
+    {0x66, 0x06}, 
+    {0x67, 0x84}, 
+    {0x69, 0x08},
+    {0x6a, 0x25},//50
+    {0x6b, 0x01}, 
+    {0x6c, 0x00}, 
+    {0x6d, 0x02}, 
+    {0x6e, 0xf0}, 
+    {0x6f, 0x80}, 
+    {0x76, 0x80},
+    {0x78, 0xaf}, 
+    {0x79, 0x75},
+    {0x7a, 0x40},
+    {0x7b, 0x50},   
+    {0x7c, 0x0c},
+                                       
+    {0xa4, 0xb9}, 
+    {0xa5, 0xa0},
+    {0x90, 0xc9},
+    {0x91, 0xbe},
+                                       
+    {0xa6, 0xb8},
+    {0xa7, 0x95},
+    {0x92, 0xe6},
+    {0x93, 0xca},
+                                       
+    {0xa9, 0xbc}, 
+    {0xaa, 0x95}, 
+    {0x95, 0x23},
+    {0x96, 0xe7},
+                                       
+    {0xab, 0x9d},
+    {0xac, 0x80},
+    {0x97, 0x43},
+    {0x98, 0x24},
+                                       
+    {0xae, 0xb7},
+    {0xaf, 0x9e},
+    {0x9a, 0x43},
+    {0x9b, 0x24},
+                                       
+    {0xb0, 0xc8},
+    {0xb1, 0x97},
+    {0x9c, 0xc4},
+    {0x9d, 0x44},
+        
+    {0xb3, 0xb7},
+    {0xb4, 0x7f},
+    {0x9f, 0xc7},
+    {0xa0, 0xc8},
+        
+    {0xb5, 0x00},
+    {0xb6, 0x00},
+    {0xa1, 0x00},
+    {0xa2, 0x00},
+        
+    {0x86, 0x60},
+    {0x87, 0x08},
+    {0x88, 0x00},
+    {0x89, 0x00},
+    {0x8b, 0xde},
+    {0x8c, 0x80},
+    {0x8d, 0x00},
+    {0x8e, 0x00},
+        
+    {0x94, 0x55},
+    {0x99, 0xa6},
+    {0x9e, 0xaa},
+    {0xa3, 0x0a},
+    {0x8a, 0x0a},
+    {0xa8, 0x55},
+    {0xad, 0x55},
+    {0xb2, 0x55},
+    {0xb7, 0x05},
+    {0x8f, 0x05},
+    
+    {0xb8, 0xcc}, 
+    {0xb9, 0x9a}, 
+        /////////////////////////////////////////////////
+        ////////////////////   CC    ////////////////////
+        /////////////////////////////////////////////////
+    {0xfe, 0x01},
+        
+    {0xd0, 0x38},//skin red
+    {0xd1, 0x00},
+    {0xd2, 0x02},
+    {0xd3, 0x04},
+    {0xd4, 0x38},
+    {0xd5, 0x12},   
+    /*                     
+    {0xd0, 0x38},//skin white
+    {0xd1, 0xfd},
+    {0xd2, 0x06},
+    {0xd3, 0xf0},
+    {0xd4, 0x40},
+    {0xd5, 0x08},
+    */
+        
+    /*                       
+    {0xd0, 0x38},//guodengxiang
+    {0xd1, 0xf8},
+    {0xd2, 0x06},
+    {0xd3, 0xfd},
+    {0xd4, 0x40},
+    {0xd5, 0x00},   
+    */
+        
+    {0xd6, 0x30},
+    {0xd7, 0x00},
+    {0xd8, 0x0a},
+    {0xd9, 0x16},
+    {0xda, 0x39},
+    {0xdb, 0xf8},
+    
+        /////////////////////////////////////////////////
+        ////////////////////   LSC   ////////////////////
+        /////////////////////////////////////////////////
+    {0xfe, 0x01},
+    {0xc1, 0x3c},
+    {0xc2, 0x50},
+    {0xc3, 0x00},
+    {0xc4, 0x40},
+    {0xc5, 0x30},
+    {0xc6, 0x30},
+    {0xc7, 0x10},
+    {0xc8, 0x00},
+    {0xc9, 0x00},
+    {0xdc, 0x20},
+    {0xdd, 0x10},
+    {0xdf, 0x00},
+    {0xde, 0x00},
+        
+        /////////////////////////////////////////////////
+        ///////////////////  Histogram  /////////////////
+        /////////////////////////////////////////////////
+    {0x01, 0x10},
+    {0x0b, 0x31},
+    {0x0e, 0x50},
+    {0x0f, 0x0f},
+    {0x10, 0x6e},
+    {0x12, 0xa0},
+    {0x15, 0x60},
+    {0x16, 0x60},
+    {0x17, 0xe0},
+        
+        /////////////////////////////////////////////////
+        //////////////  Measure Window    ///////////////
+        /////////////////////////////////////////////////
+    {0xcc, 0x0c}, 
+    {0xcd, 0x10},
+    {0xce, 0xa0},
+    {0xcf, 0xe6},
+        
+        /////////////////////////////////////////////////
+        /////////////////   dark sun   //////////////////
+        /////////////////////////////////////////////////
+    {0x45, 0xf7},
+    {0x46, 0xff},
+    {0x47, 0x15},
+    {0x48, 0x03}, 
+    {0x4f, 0x60},
+    
+        //////////////////banding//////////////////////
+    {0xfe, 0x00}, 
+    {0x05, 0x02},
+    {0x06, 0xd1}, //HB
+    {0x07, 0x00},
+    {0x08, 0x22}, //VB
+        
+    {0xfe, 0x01},
+    {0x25, 0x00},   //anti-flicker step [11:8]
+    {0x26, 0x6a},   //anti-flicker step [7:0]
+    
+    {0x27, 0x02},   //exp level 0  20fps
+    {0x28, 0x12}, 
+    {0x29, 0x03},   //exp level 1  12.50fps
+    {0x2a, 0x50}, 
+    {0x2b, 0x05},   //7.14fps
+    {0x2c, 0xcc}, 
+    {0x2d, 0x07},   //exp level 3  5.55fps
+    {0x2e, 0x74}, 
+    {0x3c, 0x20},   
+    {0xfe, 0x00},
+        
+        /////////////////////////////////////////////////
+        /////////////////////  DVP   ////////////////////
+        /////////////////////////////////////////////////
+    {0xfe, 0x03},
+    {0x01, 0x00},
+    {0x02, 0x00},
+    {0x10, 0x00},
+    {0x15, 0x00},
+    {0xfe, 0x00},
+        ///////////////////OUTPUT//////////////////////
+    {0xf3, 0xff},// output_enable
+    
+		ENDMARKER,
+};              
+
+/* 320*240: QVGA */
+static const struct regval_list module_qvga_regs[] = 
+{
+    {0xfe, 0x00}, //
+    {0x18, 0x7a}, //
+    {0x50, 0x01}, //crop enable
+    {0x55, 0x00}, //crop window height
+    {0x56, 0xf0},
+    {0x57, 0x01}, //crop window width
+    {0x58, 0x40},
+        
+    {0xfe, 0x01}, //
+    {0xc1, 0x3c}, //row center
+    {0xc2, 0x50}, //col center
+    {0xcc, 0x06}, //0c  //aec window size 
+    {0xcd, 0x06}, //10 
+    {0xce, 0x28}, //a0 
+    {0xcf, 0x3a}, //e6 
+    {0xfe, 0x00}, //
+    ENDMARKER,
+    
+};
+
+/* 640*480: VGA*/
+static const struct regval_list module_vga_regs[] = 
+{
+    {0xfe, 0x00}, 
+    {0x18, 0x1a},  
+    {0x50, 0x01}, //crop enable
+    {0x55, 0x01}, //crop window height
+    {0x56, 0xe0},
+    {0x57, 0x02}, //crop window width
+    {0x58, 0x80},
+        
+    {0xfe, 0x01},  
+    {0xc1, 0x3c},
+    {0xc2, 0x50},
+    {0xcc, 0x0c}, 
+    {0xcd, 0x10},
+    {0xce, 0xa0},
+    {0xcf, 0xe6},
+    {0xfe, 0x00},  
+    ENDMARKER,
+};
+static const struct regval_list module_init_auto_focus[] =
+{
+	ENDMARKER,
+//  NULL
+};
+
+/*
+ * window size list
+ */
+/* 320*240 */
+static struct camera_module_win_size module_win_qvga = {
+	.name             = "QVGA",
+	.width            = WIDTH_QVGA,
+	.height           = HEIGHT_QVGA,
+	.win_regs         = module_qvga_regs,
+
+	.frame_rate_array = frame_rate_qvga,
+	.capture_only     = 0,
+};
+
+/* 640*480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+static struct camera_module_win_size *module_win_list[] = 
+{
+//    &module_win_qvga,
+    &module_win_vga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+    {0x42, 0x8f},
+		ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+    {0x42, 0x8d},
+    {0x77, 0x8c}, //WB_manual_gain 
+    {0x78, 0x50},
+    {0x79, 0x40},
+		ENDMARKER,
+
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+    {0x42, 0x8d},
+    {0x77, 0x74}, 
+    {0x78, 0x52},
+    {0x79, 0x40},   
+		ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+    {0x42, 0x8d},
+    {0x77, 0x40},
+    {0x78, 0x42},
+    {0x79, 0x50},
+		ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+    {0x42, 0x8d},
+    {0x77, 0x48},
+    {0x78, 0x40},
+    {0x79, 0x5c},
+    ENDMARKER,
+};
+#if 0
+/*\D5\FD\B3\A3ģʽ*/
+static struct regval_list module_effect_normal_regs[] =
+{
+    {0x43 , 0x00},
+		ENDMARKER,
+};
+
+/*\B5\A5ɫ\A3\AC\BAڰ\D7\D5\D5Ƭ*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+    {0x43 , 0x02},
+    {0xda , 0x00},
+    {0xdb , 0x00},
+		ENDMARKER,
+};
+
+/*\B8\BAƬЧ\B9\FB*/
+static struct regval_list module_effect_negative_regs[] =
+{
+    {0x43 , 0x01},
+		ENDMARKER,
+};
+/*\B8\B4\B9\C5Ч\B9\FB*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+    {0x43 , 0x02},
+    {0xda , 0xd0},
+    {0xdb , 0x28},
+		ENDMARKER,
+};
+#endif
+static struct regval_list module_scene_auto_regs[] =
+{
+    {0xfe, 0x01},
+    {0x3c, 0x20},
+    {0xfe, 0x00},
+    ENDMARKER,
+};
+#if 0
+static struct regval_list module_scene_night_regs[] =
+{
+    {0xfe, 0x01},
+    {0x3c, 0x30},
+    {0xfe, 0x00},
+		ENDMARKER,
+};
+#endif
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{
+        .id = V4L2_CID_AUTO_WHITE_BALANCE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 1,
+    },
+    {
+        .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+        .min = 0,
+        .max = 3,
+        .step = 1,
+        .def = 0,
+    },
+
+    {
+        .id = V4L2_CID_HFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_VFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+	{	.id   = V4L2_CID_GAIN, 
+		.min  = 10,
+		.max  = 0xffff,
+		.step = 1,
+		.def  = 0x50,
+	},
+		
+	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+    {	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,
+	},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	 {
+        .id = V4L2_CID_COLORFX,
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_EXPOSURE_AUTO,
+        .max = 1,
+        .mask = 0x0,
+        .def = 1,
+    },
+	{  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_TEXT, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+
+#if 1
+
+	{	.id   = V4L2_CID_FLASH_LED_MODE, 
+		.max  = 3,
+		.mask = 0x0,
+		.def  = 0,},
+#endif
+	{
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/gc0328/Kconfig b/drivers/media/i2c/camera/gc0328/Kconfig
new file mode 100755
index 0000000..a07c598
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0328/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config GC0328
+	tristate "gc0328 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for gc0328 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc0328.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc0328/Makefile b/drivers/media/i2c/camera/gc0328/Makefile
new file mode 100755
index 0000000..dbb2b96
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0328/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_GC0328)	+= gc0328.o
+
diff --git a/drivers/media/i2c/camera/gc0328/gc0328.c b/drivers/media/i2c/camera/gc0328/gc0328.c
new file mode 100755
index 0000000..efdd424
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0328/gc0328.c
@@ -0,0 +1,641 @@
+/*
+ * gc0328 Camera Driver
+ *
+ * Copyright (C) 2011 Actions Semiconductor Co.,LTD
+ * Wang Xin <wangxin@actions-semi.com>
+ *
+ * Based on ov227x driver
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+  unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0)
+			{
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+			}
+		vals++;
+	}
+	return 0;
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret = 0;
+	unsigned int reg_0xfe;
+	printk("in the gc0238 module_soft_reset\n");
+	//struct i2c_adapter *i2c_adap = client->adapter;
+	ret = camera_i2c_read(client->adapter, 0xfe, &reg_0xfe);
+	reg_0xfe |= (0x1<<7);
+	ret = camera_i2c_write(client->adapter, 0xfe, reg_0xfe);
+	msleep(10);
+	return ret;
+}
+/*
+
+static int module_soft_standby(struct i2c_client *client)
+{
+	int ret = 0;
+#if 0
+	unsigned int reg_0xfc;
+	unsigned int reg_0xfe;
+	unsigned int reg_0xf1;
+	unsigned int reg_0xf2;
+ 
+	// softstandy has a problem ,so return
+  reg_0xfe = 0x00;
+  ret  = camera_i2c_write(client->adapter, 0xfe, reg_0xfe);
+    
+	ret |= camera_i2c_read(client->adapter, 0xfc, &reg_0xfc);
+	reg_0xfc |= (0x1<<0);
+	ret = camera_i2c_write(client->adapter, 0xfc, reg_0xfc);
+	
+	reg_0xf1 = 0x00;
+	reg_0xf2 = 0x00;
+	ret |= camera_i2c_write(client->adapter, 0xf1, reg_0xf1);
+	ret |= camera_i2c_write(client->adapter, 0xf2, reg_0xf2);
+#endif
+	
+	return ret;
+}
+
+
+static int module_normal(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+
+	unsigned int reg_0xf1;
+	unsigned int reg_0xfc;
+	unsigned int reg_0xfe;
+	int ret = 0;
+
+	reg_0xfe = 0x00;
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	
+	ret = camera_i2c_read(i2c_adap, 0xfc, &reg_0xfc);
+	reg_0xfc &= (~(0x1<<0));
+	ret  = camera_i2c_write(i2c_adap, 0xfc, reg_0xfc);
+	
+	reg_0xf1 = 0x07;
+	ret |= camera_i2c_write(i2c_adap, 0xf1, reg_0xf1);
+	
+	return ret;
+}
+*/
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+    int ret = 0;
+	
+	return ret;
+}
+
+int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int auto_white_balance;
+	int ret = 0;
+	
+	if(ctrl)
+		auto_white_balance = ctrl->val;
+	else
+		auto_white_balance = 1;
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		ctrl->cur.val = auto_white_balance;  
+		
+
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+  struct i2c_adapter *i2c_adap = client->adapter;
+  int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+#if 0
+static int module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int colorfx = ctrl->val;
+	int ret = 0;
+
+	switch (colorfx) {
+	case V4L2_COLORFX_NONE: /* normal */
+		ret = camera_write_array(client->adapter, module_effect_normal_regs);
+		break;
+	
+	case V4L2_COLORFX_BW: /* black and white */
+		ret = camera_write_array(client->adapter, module_effect_white_black_regs);
+		break;
+	
+	case V4L2_COLORFX_SEPIA: /* antique ,\B8\B4\B9\C5*/
+		ret = camera_write_array(client->adapter, module_effect_antique_regs);
+		break;
+
+	case V4L2_COLORFX_NEGATIVE: /* negative\A3\AC\B8\BAƬ */
+		ret = camera_write_array(client->adapter, module_effect_negative_regs);
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	priv->colorfx = colorfx;
+	ctrl->cur.val = colorfx;
+
+	return 0;
+}
+#endif
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    int exposure_auto;
+	int ret = 0;
+
+	if(ctrl)
+		exposure_auto = ctrl->val;
+	else
+		exposure_auto = V4L2_EXPOSURE_AUTO;
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+	
+	case V4L2_EXPOSURE_MANUAL:/*  auto */
+		ret = 0;
+		break;
+    }
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		ctrl->cur.val = exposure_auto;
+
+	return 0;
+}
+
+
+static int module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+#if 0	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+  int scene_exposure = ctrl->val;
+	
+
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_HOUSE:  //\CA\D2\C4\DA
+		ret = camera_write_array(client->adapter, module_scene_night_regs);
+		break;
+	
+	case V4L2_SCENE_MODE_SUNLIGHT:  //\CA\D2\CD\E2
+		ret = camera_write_array(client->adapter, module_scene_auto_regs);
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+#endif
+	return ret;
+
+}
+
+/*
+static int module_set_prev_capt_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int mode = ctrl->val;
+
+	switch(mode) {
+	case PREVIEW_MODE:
+		priv->prev_capt_mode = mode;
+		break;
+
+	case CAPTURE_MODE:
+        priv->prev_capt_mode = mode;
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	ctrl->cur.val = mode;
+	return 0;
+	
+}
+
+static int module_pause_af(struct i2c_client *client)
+{	
+	int ret = 0;
+	
+	return ret;	
+}
+
+static int module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	
+    return 0;
+}
+
+static int module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+//	struct v4l2_subdev *sd = &priv->subdev;
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    
+    return 0;
+}
+
+
+
+
+static int module_set_exposure(struct v4l2_subdev *sd)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+
+	return ret;
+}
+*/
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+
+	
+	struct i2c_adapter *i2c_adap = client->adapter;
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+
+		 camera_i2c_write(i2c_adap, 0xfe, 0x00);
+	   camera_i2c_write(i2c_adap, 0xf1, 0x70);
+	   camera_i2c_write(i2c_adap, 0xf2, 0x00);
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+		
+		 camera_i2c_write(i2c_adap, 0xfe, 0x00);
+	   camera_i2c_write(i2c_adap, 0xf1, 0x07);
+	   camera_i2c_write(i2c_adap, 0xf2, 0x01);
+	   
+	return 0;
+}
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+//  unsigned int analog_gain = 0;
+//	unsigned int digital_gain = 0;
+	unsigned int total_gain = 0;
+//	int ret = 0;
+    
+	return total_gain;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+
+	return 0;
+}
+
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	unsigned int reg_0x44 = 0;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_0x44 = 0x02;
+		break;
+		
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		reg_0x44 = 0x00;
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		reg_0x44 = 0x03;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		reg_0x44 = 0x01;
+		break;
+		
+	default:
+		printk("[gc0328] %s, %d, mbus code error\n",__FUNCTION__, __LINE__);
+		return -1;
+	}
+	return camera_i2c_write(client->adapter, 0x44, reg_0x44);
+}
+
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	unsigned int reg_0x17 = 0x10;
+	unsigned int reg_0xfe = 0x00;
+	int ret = 0;
+	
+	if ((!mirror) && (!flip)) {
+		return 0;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+
+	if (mirror)	{
+		reg_0x17 |= 0x1;
+	} else {
+		reg_0x17 &= (~0x1);
+	}
+	
+	if (flip) {
+		reg_0x17 |= (0x1<<0x1);
+	} else {
+		reg_0x17 &= (~(0x1<<0x1));
+	}
+
+	ret |= camera_i2c_write(i2c_adap, 0x17, reg_0x17);
+	return ret;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int  		pid;
+	int ret = 0;
+	camera_i2c_write(i2c_adap,0xfe,0x00);
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PID, &pid); 
+	switch (pid) 
+    {
+	case CAMERA_MODULE_PID:
+/*		if(priv)
+			{
+		     priv->model= V4L2_IDENT_GC0328;
+			}*/
+		printk("[gc0328] Product ID verified %x\n", pid);
+		break;
+	
+	default:
+		printk("[gc0328] Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+	
+	return ret;
+}
+#if 0
+void module_power_on_sequence(struct device *dev)
+{
+	enable_module_clk();
+	disable_module_power_down(dev);
+	enable_module_reset(dev);
+}
+
+void module_power_off_sequence(struct device *dev)
+{
+    enable_module_power_down(dev);
+    disable_module_clk();
+    disable_module_reset(dev);
+}
+
+void module_extra_handle(struct i2c_client *client)
+{
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	
+}
+#endif
+
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc0328/module_diff.h b/drivers/media/i2c/camera/gc0328/module_diff.h
new file mode 100755
index 0000000..58e99f8
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0328/module_diff.h
@@ -0,0 +1,927 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME 	"gc0328"
+#define CAMERA_MODULE_PID		0x9d
+
+#define MODULE_PLATFORM_ID		GC0328_PLATFORM_ID
+#define MODULE_I2C_REAL_ADDRESS		(0x42>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x42>>1)
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+
+#define PID						0xf0 /* Product ID Number H byte */
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_LOW
+ #define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA
+#define MODULE_MAX_WIDTH		WIDTH_VGA
+#define MODULE_MAX_HEIGHT		HEIGHT_VGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		4
+#define DROP_NUM_PREVIEW		4
+
+static unsigned int frame_rate_qvga[] = {30,};
+static unsigned int frame_rate_vga[]  = {30,};
+
+static const struct regval_list module_init_regs[] =
+{
+	// Initail Sequence Write In.
+	{0xfe , 0x80},
+	{0xfe , 0x80},
+	{0xfc , 0x16},
+	{0xfc , 0x16},
+	{0xfc , 0x16},
+	{0xfc , 0x16},
+	{0xf1 , 0x00},
+	{0xf2 , 0x00},
+	{0xfe , 0x00},
+	{0x4f , 0x00},
+	{0x03 , 0x00},
+	{0x04 , 0xc0},
+	{0x42 , 0x00},
+	{0x77 , 0x5a},
+	{0x78 , 0x40},
+	{0x79 , 0x56},
+
+	{0xfe , 0x00},
+	{0x0d , 0x01},
+	{0x0e , 0xe8},
+	{0x0f , 0x02},
+	{0x10 , 0x88},
+	{0x09 , 0x00},
+	{0x0a , 0x00},
+	{0x0b , 0x00},
+	{0x0c , 0x00},
+	{0x16 , 0x00},
+	{0x17 , 0x14},//miorr
+	{0x18 , 0x0e},
+	{0x19 , 0x06},
+
+	{0x1b , 0x48},
+	{0x1f , 0xC8},
+	{0x20 , 0x01},
+	{0x21 , 0x78},
+	{0x22 , 0xb0},
+	{0x23 , 0x04},//0x06  20140519 GC0328C
+	{0x24 , 0x11}, 
+	{0x26 , 0x00},
+	{0x50 , 0x01}, //crop mode
+
+	//global gain for range 
+	{0x70 , 0x45},
+	
+	/////////////banding/////////////
+	{0x05 , 0x02},//hb
+	{0x06 , 0x2c},//
+	{0x07 , 0x00},//vb
+	{0x08 , 0xb8},//
+	{0xfe , 0x01},//
+	{0x29 , 0x00},//anti-flicker step [11:8]
+	{0x2a , 0x60},//anti-flicker step [7:0]
+	{0x2b , 0x02},//exp level 0  14.28fps
+	{0x2c , 0xa0},//             
+	{0x2d , 0x03},//exp level 1  12.50fps
+	{0x2e , 0x00},//             
+	{0x2f , 0x03},//exp level 2  10.00fps
+	{0x30 , 0xc0},//             
+	{0x31 , 0x05},//exp level 3  7.14fps
+	{0x32 , 0x40},//
+	{0xfe , 0x00},//
+
+	///////////////AWB//////////////
+	{0xfe , 0x01},
+	{0x50 , 0x00},
+	{0x4f , 0x00},
+	{0x4c , 0x01},
+	{0x4f , 0x00},
+	{0x4f , 0x00},
+	{0x4f , 0x00},
+	{0x4f , 0x00},
+	{0x4f , 0x00}, 
+	{0x4d , 0x30},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4d , 0x40},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4d , 0x50},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4d , 0x60},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4d , 0x70},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},	
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},	
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4f , 0x01},
+	{0x50 , 0x88},
+	{0xfe , 0x00},
+
+	//////////// BLK//////////////////////
+	{0xfe , 0x00}, 
+	{0x27 , 0xb7},
+	{0x28 , 0x7F},
+	{0x29 , 0x20},
+	{0x33 , 0x20},
+	{0x34 , 0x20},
+	{0x35 , 0x20},
+	{0x36 , 0x20},
+	{0x32 , 0x08},
+	{0x3b , 0x00}, 
+	{0x3c , 0x00},
+	{0x3d , 0x00},
+	{0x3e , 0x00},
+	{0x47 , 0x00},
+	{0x48 , 0x00}, 
+
+	//////////// block enable/////////////
+	{0x40 , 0x7f}, 
+	{0x41 , 0x26}, 
+	{0x42 , 0xfb},
+	{0x44 , 0x02}, //yuv
+	{0x45 , 0x00},
+	{0x46 , 0x02},
+	{0x4f , 0x01},
+	{0x4b , 0x01},
+	{0x50 , 0x01}, 
+
+	/////DN & EEINTP/////
+	{0x7e , 0x0a}, 
+	{0x7f , 0x03}, 
+	{0x81 , 0x15}, 
+	{0x82 , 0x90},
+	{0x83 , 0x02},
+	{0x84 , 0xe5},
+	{0x90 , 0x2c}, 
+	{0x92 , 0x02},
+	{0x94 , 0x02},
+	{0x95 , 0x35},
+
+	////////////YCP///////////
+	{0xd1 , 0x24},// 0x30 for front
+	{0xd2 , 0x24},// 0x30 for front
+	{0xd3 , 0x40},
+	{0xdd , 0xd3},
+	{0xde , 0x38},
+	{0xe4 , 0x88},
+	{0xe5 , 0x40}, 
+	{0xd7 , 0x0e}, 
+
+	///////////rgb gamma ////////////
+	{0xfe , 0x00},
+	{0xbf , 0x0e},
+	{0xc0 , 0x1c},
+	{0xc1 , 0x34},
+	{0xc2 , 0x48},
+	{0xc3 , 0x5a},
+	{0xc4 , 0x6e},
+	{0xc5 , 0x80},
+	{0xc6 , 0x9c},
+	{0xc7 , 0xb4},
+	{0xc8 , 0xc7},
+	{0xc9 , 0xd7},
+	{0xca , 0xe3},
+	{0xcb , 0xed},
+	{0xcc , 0xf2},
+	{0xcd , 0xf8},
+	{0xce , 0xfd},
+	{0xcf , 0xff},
+
+#if 0
+			case RGB_Gamma_m1:				 //smallest gamma curve
+	{0xfe, 0x00},
+	{0xbf, 0x06},
+	{0xc0, 0x12},
+	{0xc1, 0x22},
+	{0xc2, 0x35},
+	{0xc3, 0x4b},
+	{0xc4, 0x5f},
+	{0xc5, 0x72},
+	{0xc6, 0x8d},
+	{0xc7, 0xa4},
+	{0xc8, 0xb8},
+	{0xc9, 0xc8},
+	{0xca, 0xd4},
+	{0xcb, 0xde},
+	{0xcc, 0xe6},
+	{0xcd, 0xf1},
+	{0xce, 0xf8},
+	{0xcf, 0xfd},
+				break;
+			case RGB_Gamma_m2:
+	{0xBF, 0x08},
+	{0xc0, 0x0F},
+	{0xc1, 0x21},
+	{0xc2, 0x32},
+	{0xc3, 0x43},
+	{0xc4, 0x50},
+	{0xc5, 0x5E},
+	{0xc6, 0x78},
+	{0xc7, 0x90},
+	{0xc8, 0xA6},
+	{0xc9, 0xB9},
+	{0xcA, 0xC9},
+	{0xcB, 0xD6},
+	{0xcC, 0xE0},
+	{0xcD, 0xEE},
+	{0xcE, 0xF8},
+	{0xcF, 0xFF},
+				break;
+				
+			case RGB_Gamma_m3:			
+	{0xBF, 0x0B},
+	{0xc0, 0x16},
+	{0xc1, 0x29},
+	{0xc2, 0x3C},
+	{0xc3, 0x4F},
+	{0xc4, 0x5F},
+	{0xc5, 0x6F},
+	{0xc6, 0x8A},
+	{0xc7, 0x9F},
+	{0xc8, 0xB4},
+	{0xc9, 0xC6},
+	{0xcA, 0xD3},
+	{0xcB, 0xDD},
+	{0xcC, 0xE5},
+	{0xcD, 0xF1},
+	{0xcE, 0xFA},
+	{0xcF, 0xFF},
+				break;
+				
+			case RGB_Gamma_m4:
+	{0xBF, 0x0E},
+	{0xc0, 0x1C},
+	{0xc1, 0x34},
+	{0xc2, 0x48},
+	{0xc3, 0x5A},
+	{0xc4, 0x6B},
+	{0xc5, 0x7B},
+	{0xc6, 0x95},
+	{0xc7, 0xAB},
+	{0xc8, 0xBF},
+	{0xc9, 0xCE},
+	{0xcA, 0xD9},
+	{0xcB, 0xE4},
+	{0xcC, 0xEC},
+	{0xcD, 0xF7},
+	{0xcE, 0xFD},
+	{0xcF, 0xFF},
+				break;
+				
+			case RGB_Gamma_m5:
+	{0xBF, 0x10},
+	{0xc0, 0x20},
+	{0xc1, 0x38},
+	{0xc2, 0x4E},
+	{0xc3, 0x63},
+	{0xc4, 0x76},
+	{0xc5, 0x87},
+	{0xc6, 0xA2},
+	{0xc7, 0xB8},
+	{0xc8, 0xCA},
+	{0xc9, 0xD8},
+	{0xcA, 0xE3},
+	{0xcB, 0xEB},
+	{0xcC, 0xF0},
+	{0xcD, 0xF8},
+	{0xcE, 0xFD},
+	{0xcF, 0xFF},
+				break;
+				
+			case RGB_Gamma_m6:
+	{0xBF, 0x14},							// largest gamma curve
+	{0xc0, 0x28},
+	{0xc1, 0x44},
+	{0xc2, 0x5D},
+	{0xc3, 0x72},
+	{0xc4, 0x86},
+	{0xc5, 0x95},
+	{0xc6, 0xB1},
+	{0xc7, 0xC6},
+	{0xc8, 0xD5},
+	{0xc9, 0xE1},
+	{0xcA, 0xEA},
+	{0xcB, 0xF1},
+	{0xcC, 0xF5},
+	{0xcD, 0xFB},
+	{0xcE, 0xFE},
+	{0xcF, 0xFF},	
+				break;
+			case RGB_Gamma_night:									//Gamma for night mode
+	{0xBF, 0x0B},
+	{0xc0, 0x16},
+	{0xc1, 0x29},
+	{0xc2, 0x3C},
+	{0xc3, 0x4F},
+	{0xc4, 0x5F},
+	{0xc5, 0x6F},
+	{0xc6, 0x8A},
+	{0xc7, 0x9F},
+	{0xc8, 0xB4},
+	{0xc9, 0xC6},
+	{0xcA, 0xD3},
+	{0xcB, 0xDD},
+	{0xcC, 0xE5},
+	{0xcD, 0xF1},
+	{0xcE, 0xFA},
+	{0xcF, 0xFF},	
+				break;
+			default:
+				//RGB_Gamma_m1
+	{0xfe, 0x00},
+	{0xbf, 0x06},
+	{0xc0, 0x12},
+	{0xc1, 0x22},
+	{0xc2, 0x35},
+	{0xc3, 0x4b},
+	{0xc4, 0x5f},
+	{0xc5, 0x72},
+	{0xc6, 0x8d},
+	{0xc7, 0xa4},
+	{0xc8, 0xb8},
+	{0xc9, 0xc8},
+	{0xca, 0xd4},
+	{0xcb, 0xde},
+	{0xcc, 0xe6},
+	{0xcd, 0xf1},
+	{0xce, 0xf8},
+	{0xcf, 0xfd},
+				break;
+		
+#endif
+		/////////////Y gamma//////////
+		{0xfe , 0x00},
+		{0x63 , 0x00},
+		{0x64 , 0x05},
+		{0x65 , 0x0b},
+		{0x66 , 0x19},
+		{0x67 , 0x2e},
+		{0x68 , 0x40},
+		{0x69 , 0x54},
+		{0x6a , 0x66},
+		{0x6b , 0x86},
+		{0x6c , 0xa7},
+	{0x6d , 0xc6},
+	{0x6e , 0xe4},
+	{0x6f , 0xff},
+	
+	//////////////ASDE/////////////
+	{0xfe , 0x01},
+	{0x18 , 0x02},
+	{0xfe , 0x00},
+	{0x97 , 0x30},
+	{0x98 , 0x00},
+	{0x9b , 0x60},
+	{0x9c , 0x60},
+	{0xa4 , 0x50},
+	{0xa8 , 0x80},
+	{0xaa , 0x40},
+	{0xa2 , 0x23},
+	{0xad , 0x28},
+	
+	//////////////abs///////////
+	{0xfe , 0x01},
+	{0x9c , 0x00}, 
+	{0x9e , 0xc0}, 
+	{0x9f , 0x40},	
+	
+	////////////// AEC////////////
+	{0xfe , 0x01},
+	{0x08 , 0xa0},
+	{0x09 , 0xe8},
+	{0x10 , 0x08},
+	{0x11 , 0x21},
+	{0x12 , 0x11},
+	{0x13 , 0x45},
+	{0x15 , 0xfc},
+	{0x18 , 0x02},
+	{0x21 , 0xf0},
+	{0x22 , 0x60},
+	{0x23 , 0x30},
+	{0x25 , 0x00},
+	{0x24 , 0x14},
+	{0x3d , 0x80},
+	{0x3e , 0x40},
+
+	////////////////AWB///////////
+	{0xfe , 0x01},
+	{0x51 , 0x88},
+	{0x52 , 0x12},
+	{0x53 , 0x80},
+	{0x54 , 0x60},
+	{0x55 , 0x01},
+	{0x56 , 0x02},
+	{0x58 , 0x00},
+	{0x5b , 0x02},
+	{0x5e , 0xa4},
+	{0x5f , 0x8a},
+	{0x61 , 0xdc},
+	{0x62 , 0xdc},
+	{0x70 , 0xfc},
+	{0x71 , 0x10},
+	{0x72 , 0x30},
+	{0x73 , 0x0b},
+	{0x74 , 0x0b},
+	{0x75 , 0x01},
+	{0x76 , 0x00},
+	{0x77 , 0x40},
+	{0x78 , 0x70},
+	{0x79 , 0x00},
+	{0x7b , 0x00},
+	{0x7c , 0x71},
+	{0x7d , 0x00},
+	{0x80 , 0x70},
+	{0x81 , 0x58},
+	{0x82 , 0x98},
+	{0x83 , 0x60},
+	{0x84 , 0x58},
+	{0x85 , 0x50},
+	{0xfe , 0x00},	
+	
+	////////////////LSC////////////////
+	{0xfe , 0x01},
+	{0xc0 , 0x10},
+	{0xc1 , 0x0c},
+	{0xc2 , 0x0a},
+	{0xc6 , 0x0e},
+	{0xc7 , 0x0b},
+	{0xc8 , 0x0a},
+	{0xba , 0x26},
+	{0xbb , 0x1c},
+	{0xbc , 0x1d},
+	{0xb4 , 0x23},
+	{0xb5 , 0x1c},
+	{0xb6 , 0x1a},
+	{0xc3 , 0x00},
+	{0xc4 , 0x00},
+	{0xc5 , 0x00},
+	{0xc9 , 0x00},
+	{0xca , 0x00},
+	{0xcb , 0x00},
+	{0xbd , 0x00},
+	{0xbe , 0x00},
+	{0xbf , 0x00},
+	{0xb7 , 0x07},
+	{0xb8 , 0x05},
+	{0xb9 , 0x05},
+	{0xa8 , 0x07},
+	{0xa9 , 0x06},
+	{0xaa , 0x00},
+	{0xab , 0x04},
+	{0xac , 0x00},
+	{0xad , 0x02},
+	{0xae , 0x0d},
+	{0xaf , 0x05},
+	{0xb0 , 0x00},
+	{0xb1 , 0x07},
+	{0xb2 , 0x03},
+	{0xb3 , 0x00},
+	{0xa4 , 0x00},
+	{0xa5 , 0x00},
+	{0xa6 , 0x00},
+	{0xa7 , 0x00},
+	{0xa1 , 0x3c},
+	{0xa2 , 0x50},
+	{0xfe , 0x00},
+		
+	///////////////CCT ///////////
+	{0xb1 , 0x12},
+	{0xb2 , 0xf5},
+	{0xb3 , 0xfe},
+	{0xb4 , 0xe0},
+	{0xb5 , 0x15},
+	{0xb6 , 0xc8},
+	
+	/*   /////skin CC for front //////
+	{0xb1 , 0x00},
+	{0xb2 , 0x00},
+	{0xb3 , 0x00},
+	{0xb4 , 0xf0},
+	{0xb5 , 0x00},
+	{0xb6 , 0x00},
+	*/
+
+	///////////////AWB////////////////
+	{0xfe , 0x01},
+	{0x50 , 0x00},
+	{0xfe , 0x01}, 
+	{0x4f , 0x00},
+	{0x4c , 0x01},
+	{0x4f , 0x00},
+	{0x4f , 0x00},
+	{0x4f , 0x00}, 
+	{0x4d , 0x34},
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4e , 0x02},
+	{0x4e , 0x02},
+	{0x4d , 0x44},
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4d , 0x53},
+	{0x4e , 0x00},
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4e , 0x04},
+	{0x4d , 0x65},
+	{0x4e , 0x04},
+	{0x4d , 0x73},
+	{0x4e , 0x20},
+	{0x4d , 0x83},
+	{0x4e , 0x20},
+	{0x4f , 0x01}, 
+	{0x50 , 0x88}, 
+	/////////output//////// 
+	{0xfe , 0x00},  
+	{0xf1 , 0x07}, 
+	{0xf2 , 0x01}, 
+	ENDMARKER,	
+};
+
+/* 320*240: QVGA*/
+static const struct regval_list module_qvga_regs[] = {
+	{0xfe,0x00},
+	{0x59,0x22},  
+	{0x5a,0x0e},  
+	{0x5b,0x00}, 
+	{0x5c,0x00}, 
+	{0x5d,0x00}, 
+	{0x5e,0x00}, 
+  {0x5f,0x00}, 
+	{0x60,0x00}, 
+	{0x61,0x00}, 
+	{0x62,0x00}, 
+	
+	{0x50,0x01},//enable crop window mode
+	{0x51,0x00},  
+	{0x52,0x00},  
+	{0x53,0x00}, 
+	{0x54,0x00}, 	
+	{0x55,0x00}, 
+	{0x56,0xf0}, 
+	{0x57,0x01}, 
+	{0x58,0x40}, 
+    {0xfe,0x00},
+	ENDMARKER,
+};
+
+/* 640*480: VGA*/
+static const struct regval_list module_vga_regs[] = {
+	{0xfe,0x00},
+	{0x59,0x11},  
+	{0x5a,0x0e},  //0x03
+	{0x5b,0x00}, 
+	{0x5c,0x00}, 
+	{0x5d,0x00}, 
+	{0x5e,0x00}, 
+	{0x5f,0x00}, 
+	{0x60,0x00}, 
+	{0x61,0x00}, 
+	{0x62,0x00}, 
+
+	{0x50,0x01},
+	{0x51,0x00},  
+	{0x52,0x00}, 
+	{0x53,0x00}, 
+	{0x54,0x00}, 
+	{0x55,0x01}, 
+	{0x56,0xe0}, 
+	{0x57,0x02}, 
+	{0x58,0x80}, 
+
+	{0xfe,0x00},
+	ENDMARKER,
+};
+
+static const struct regval_list module_init_auto_focus[] = {
+	ENDMARKER,
+//  NULL
+};
+
+/*
+ * window size list
+ */
+/* 320X240 */
+static struct camera_module_win_size module_win_qvga = {
+	.name             = "QVGA",
+	.width            = WIDTH_QVGA,
+	.height           = HEIGHT_QVGA,
+	.win_regs         = module_qvga_regs,
+	.frame_rate_array = frame_rate_qvga,
+	.capture_only     = 0,
+};
+
+/* 640X480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_qvga,
+	&module_win_vga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+    {0xfe, 0x00},
+    {0x42, 0xfe},
+    {0x77, 0x57},
+    {0x78, 0x4d},
+    {0x79, 0x45},
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+    {0xfe, 0x00},
+    {0x42, 0xfd},
+    {0x77, 0x5e},
+    {0x78, 0x40},
+    {0x79, 0x54},
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+    {0xfe, 0x00},
+    {0x42, 0xfd},
+    {0x77, 0x4c},
+    {0x78, 0x70},
+    {0x79, 0x7a},
+	ENDMARKER,	
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+    {0xfe, 0x00},
+    {0x42, 0xfd},
+    {0x77, 0x40},
+    {0x78, 0x50},
+    {0x79, 0xc6},
+	ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+    {0xfe, 0x00},
+    {0x42, 0x48},
+    {0x77, 0x40},
+    {0x78, 0x7a},
+    {0x79, 0x70},
+	ENDMARKER,
+};
+#if 0
+/*\D5\FD\B3\A3ģʽ*/
+static struct regval_list module_effect_normal_regs[] =
+{
+    {0x43, 0x00},
+    {0xda, 0x00}, 
+    {0xdb, 0x00},
+	ENDMARKER,
+};
+
+/*\B5\A5ɫ\A3\AC\BAڰ\D7\D5\D5Ƭ*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+    {0x43, 0x02},
+    {0xda, 0x00}, 
+    {0xdb, 0x00},
+	ENDMARKER,
+};
+
+/*\B8\BAƬЧ\B9\FB*/
+static struct regval_list module_effect_negative_regs[] =
+{
+    {0x43, 0x01},
+    {0xda, 0x00}, 
+    {0xdb, 0x00},
+	ENDMARKER,
+};
+
+/*\B8\B4\B9\C5Ч\B9\FB*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+    {0x43, 0x02},
+    {0xda, 0xd0}, 
+    {0xdb, 0x28},
+	ENDMARKER,	
+};
+#endif
+static struct regval_list module_scene_auto_regs[] =
+{
+    {0xfe, 0x01},
+    {0x33, 0x00},
+	ENDMARKER,
+};
+#if 0
+static struct regval_list module_scene_night_regs[] =
+{
+    {0xfe, 0x01},
+    {0x33, 0x20}, 
+	ENDMARKER,
+};
+#endif
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+#if 0
+
+    {	.id = V4L2_CID_AF_MODE,   //\B4\CB\CF\EE\D0\E8\D6\C3\D3\DA\CA\FD\D7\E9ͷ\B2\BF
+		.min = NONE_AF, 
+		.max = CONTINUE_AF|SINGLE_AF, 
+		.step = 1, 
+		.def = CONTINUE_AF|SINGLE_AF,},
+#endif
+		{	.id = V4L2_CID_GAIN, 
+		.min = 256,
+		.max = 0XFFFF,
+		.step = 1,
+		.def = 0,},
+	{	.id = V4L2_CID_AUTO_WHITE_BALANCE, 
+		.min = 0,
+		.max = 1, 
+		.step = 1, 
+		.def = 1,},
+	{	.id = V4L2_CID_WHITE_BALANCE_TEMPERATURE, 
+		.min = 0, 
+		.max = 3, 
+		.step = 1, 
+		.def = 1,},
+	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+#if 0
+	{	.id = V4L2_CID_SCENE_EXPOSURE, 
+		.min = 0, 
+		.max = 1, 
+		.step = 1, 
+		.def = 0,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+	{	.id = V4L2_CID_PRIVATE_PREV_CAPT, 
+		.min = 0, 
+		.max = 1, 
+		.step = 1, 
+		.def = PREVIEW_MODE,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+
+	{	.id = V4L2_CID_AF_STATUS, 
+		.min = AF_STATUS_DISABLE, 
+		.max = AF_STATUS_FAIL, 
+		.step = 1, 
+		.def = AF_STATUS_DISABLE,},
+	{	.id = V4L2_CID_FLASH_STROBE, 
+		.min = 0, 
+		.max = 1, 
+		.step = 1, 
+		.def = 0,},
+	{	.id = V4L2_CID_FLASH_STROBE_STOP, 
+		.min = 0, 
+		.max = 1, 
+		.step = 1, 
+		.def = 0,},
+#endif
+	{	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	{	.id = V4L2_CID_COLORFX, 
+		.max = 3, 
+		.mask = 0x0, 
+		.def = 0,},
+	{	.id = V4L2_CID_EXPOSURE_AUTO, 
+		.max = 1, 
+		.mask = 0x0, 
+		.def = 1,},
+	{  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_TEXT, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+#if 1
+	{	.id = V4L2_CID_FLASH_LED_MODE, 
+		.max = 3,
+		.mask = 0x0,
+		.def = 0,},
+#endif
+	{
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/gc0329/Kconfig b/drivers/media/i2c/camera/gc0329/Kconfig
new file mode 100755
index 0000000..2c06831
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0329/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config GC0329
+	tristate "gc0329 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for gc0329 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc0329.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc0329/Makefile b/drivers/media/i2c/camera/gc0329/Makefile
new file mode 100755
index 0000000..a89e586
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0329/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_GC0329)	+= gc0329.o
diff --git a/drivers/media/i2c/camera/gc0329/gc0329.c b/drivers/media/i2c/camera/gc0329/gc0329.c
new file mode 100755
index 0000000..92a8920
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0329/gc0329.c
@@ -0,0 +1,425 @@
+/*
+ * gc0328 Camera Driver
+ *
+ * Copyright (C) 2011 Actions Semiconductor Co.,LTD
+ * Wang Xin <wangxin@actions-semi.com>
+ *
+ * Based on ov227x driver
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+  unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0)
+			{
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+			}
+		vals++;
+	}
+	return 0;
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret = 0;
+	unsigned int reg_0xfe;
+	printk("in the gc0238 module_soft_reset\n");
+	//struct i2c_adapter *i2c_adap = client->adapter;
+	ret = camera_i2c_read(client->adapter, 0xfe, &reg_0xfe);
+	reg_0xfe |= (0x1<<7);
+	ret = camera_i2c_write(client->adapter, 0xfe, reg_0xfe);
+	msleep(10);
+	return ret;
+}
+
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+    int ret = 0;
+	
+	return ret;
+}
+
+int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int auto_white_balance;
+	int ret = 0;
+	
+	if(ctrl)
+		auto_white_balance = ctrl->val;
+	else
+		auto_white_balance = 1;
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		ctrl->cur.val = auto_white_balance;  
+		
+
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+  struct i2c_adapter *i2c_adap = client->adapter;
+  int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    int exposure_auto;
+	int ret = 0;
+
+	if(ctrl)
+		exposure_auto = ctrl->val;
+	else
+		exposure_auto = V4L2_EXPOSURE_AUTO;
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+	
+	case V4L2_EXPOSURE_MANUAL:/*  auto */
+		ret = 0;
+		break;
+    }
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		ctrl->cur.val = exposure_auto;
+
+	return 0;
+}
+
+
+static int module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+
+}
+
+
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+
+	
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+
+		 
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	   
+	return 0;
+}
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+//  unsigned int analog_gain = 0;
+//	unsigned int digital_gain = 0;
+	unsigned int total_gain = 0;
+//	int ret = 0;
+    
+	return total_gain;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+
+	return 0;
+}
+
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	unsigned int reg_0x44 = 0;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_0x44 = 0x02;
+		break;
+		
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		reg_0x44 = 0x00;
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		reg_0x44 = 0x03;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		reg_0x44 = 0x01;
+		break;
+		
+	default:
+		printk("[gc0328] %s, %d, mbus code error\n",__FUNCTION__, __LINE__);
+		return -1;
+	}
+	return camera_i2c_write(client->adapter, 0x44, reg_0x44);
+}
+
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+
+	return 0;	
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int  		pid;
+	int ret = 0;
+	
+	camera_i2c_write(i2c_adap,0xfc,0x16);
+	
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PID, &pid); 
+	switch (pid) 
+    {
+	case CAMERA_MODULE_PID:
+/*		if(priv)
+			{
+		     priv->model= V4L2_IDENT_GC0328;
+			}*/
+		printk("[gc0329] Product ID verified %x\n", pid);
+		break;
+	
+	default:
+		printk("[gc0329] Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+	
+	return ret;
+}
+
+
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc0329/module_diff.h b/drivers/media/i2c/camera/gc0329/module_diff.h
new file mode 100755
index 0000000..9fb45ab
--- /dev/null
+++ b/drivers/media/i2c/camera/gc0329/module_diff.h
@@ -0,0 +1,586 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME 	"gc0329"
+#define CAMERA_MODULE_PID		0xc0
+
+#define MODULE_PLATFORM_ID		GC0329_PLATFORM_ID
+#define MODULE_I2C_REAL_ADDRESS		(0x62>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x62>>1)
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+
+#define PID						0x00 /* Product ID Number H byte */
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_LOW
+ #define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA
+#define MODULE_MAX_WIDTH		WIDTH_VGA
+#define MODULE_MAX_HEIGHT		HEIGHT_VGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		4
+#define DROP_NUM_PREVIEW		4
+
+static unsigned int frame_rate_qvga[] = {30,};
+static unsigned int frame_rate_vga[]  = {30,};
+
+static const struct regval_list module_init_regs[] =
+{
+   //TODO: add initial code here
+	{0xfe, 0x80},
+	{0xfe, 0x80},
+	{0xfc, 0x16},
+	{0xfc, 0x16},
+	{0xfc, 0x16},
+	{0xfc, 0x16},
+	{0xfe, 0x00},  //page 0
+	{0xf0, 0x07},
+	{0xf1, 0x01},
+	{0x73, 0x90},
+	{0x74, 0x80},
+	{0x75, 0x80},
+	{0x76, 0x94},
+	{0x42, 0x00},
+	{0x77, 0x57},
+	{0x78, 0x4d},
+	{0x79, 0x45},
+	//{0x42, 0xfc},
+	////////////////////analog////////////////////
+	{0x0a, 0x02},
+	{0x0c, 0x02},
+	{0x17, 0x14},  //0x16
+	{0x19, 0x05},
+	{0x1b, 0x24},
+	{0x1c, 0x04},
+	{0x1e, 0x08},
+	{0x1f, 0xc8}, // 0XC0 update
+	{0x20, 0x00},
+	{0x21, 0x48},
+	{0x22, 0xba},
+	{0x23, 0x22},
+	{0x24, 0x16},
+	////////////////////blk////////////////////
+	{0x26, 0xf7}, 
+	{0x29, 0x80}, 
+	{0x32, 0x04},
+	{0x33, 0x20},
+	{0x34, 0x20},
+	{0x35, 0x20},
+	{0x36, 0x20},
+	////////////////////ISP BLOCK ENABL////////////////////
+	{0x40, 0xff},
+	{0x41, 0x46},
+	{0x42, 0x7e},
+	{0x44, 0xa0},  //a2  a0 a1
+	{0x46, 0x02},
+	{0x4b, 0xca},
+	{0x4d, 0x01},
+	{0x4f, 0x01},
+	{0x70, 0x48},
+	//{0xb0, 0x00},
+	//{0xbc, 0x00},
+	//{0xbd, 0x00},
+	//{0xbe, 0x00},
+	////////////////////DNDD////////////////////
+	{0x80, 0xe7}, 
+	{0x82, 0x55}, 
+	{0x87, 0x4a},
+	////////////////////INTPEE////////////////////
+	{0x95, 0x45},
+	////////////////////ASDE////////////////////
+	//{0xfe, 0x01},
+	//{0x18, 0x22},
+	//{0xfe, 0x00},
+	//{0x9c, 0x0a},
+	//{0xa0, 0xaf},
+	//{0xa2, 0xff},
+	//{0xa4, 0x50},
+	//{0xa5, 0x21},
+	//{0xa7, 0x35},
+	////////////////////RGB gamma////////////////////
+	//RGB gamma m4'
+	{0xbf, 0x06},
+	{0xc0, 0x14},
+	{0xc1, 0x27},
+	{0xc2, 0x3b},
+	{0xc3, 0x4f},
+	{0xc4, 0x62},
+	{0xc5, 0x72},
+	{0xc6, 0x8d},
+	{0xc7, 0xa4},
+	{0xc8, 0xb8},
+	{0xc9, 0xc9},
+	{0xcA, 0xd6},
+	{0xcB, 0xe0},
+	{0xcC, 0xe8},
+	{0xcD, 0xf4},
+	{0xcE, 0xFc},
+	{0xcF, 0xFF},
+	//////////////////CC///////////////////
+	{0xfe, 0x00},
+	{0xb3, 0x44},
+	{0xb4, 0xfd},
+	{0xb5, 0x02},
+	{0xb6, 0xfa},
+	{0xb7, 0x48},
+	{0xb8, 0xf0},
+	// crop 						   
+	{0x50, 0x01},
+	////////////////////YCP////////////////////
+	{0xfe, 0x00},
+	{0xd1, 0x38},
+	{0xd2, 0x38},
+	{0xdd, 0x54},
+	////////////////////AEC////////////////////
+	{0xfe, 0x01},
+	{0x10, 0x40},
+	{0x11, 0x21},
+	{0x12, 0x07},
+	{0x13, 0x50},
+	{0x17, 0x88},
+	{0x21, 0xb0},
+	{0x22, 0x48},
+	{0x3c, 0x95},
+	{0x3d, 0x50},
+	{0x3e, 0x48}, 
+	////////////////////AWB////////////////////
+	{0xfe, 0x01},
+	{0x06, 0x16},
+	{0x07, 0x06},
+	{0x08, 0x98},
+	{0x09, 0xee},
+	{0x50, 0xfc},
+	{0x51, 0x20},
+	{0x52, 0x0b},
+	{0x53, 0x20},
+	{0x54, 0x40},
+	{0x55, 0x10},
+	{0x56, 0x20},
+	//{0x57, 0x40},
+	{0x58, 0xa0},
+	{0x59, 0x28},
+	{0x5a, 0x02},
+	{0x5b, 0x63},
+	{0x5c, 0x34},
+	{0x5d, 0x73},
+	{0x5e, 0x11},
+	{0x5f, 0x40},
+	{0x60, 0x40},
+	{0x61, 0xc8},
+	{0x62, 0xa0},
+	{0x63, 0x40},
+	{0x64, 0x50},
+	{0x65, 0x98},
+	{0x66, 0xfa},
+	{0x67, 0x70},
+	{0x68, 0x58},
+	{0x69, 0x85},
+	{0x6a, 0x40},
+	{0x6b, 0x39},
+	{0x6c, 0x18},
+	{0x6d, 0x28},
+	{0x6e, 0x41},
+	{0x70, 0x02},
+	{0x71, 0x00},
+	{0x72, 0x10},
+	{0x73, 0x40},
+	//{0x74, 0x32},
+	//{0x75, 0x40},
+	//{0x76, 0x30},
+	//{0x77, 0x48},
+	//{0x7a, 0x50},
+	//{0x7b, 0x20}, 
+	{0x80, 0x60},
+	{0x81, 0x50},
+	{0x82, 0x42},
+	{0x83, 0x40},
+	{0x84, 0x40},
+	{0x85, 0x40},
+	{0x74, 0x40},
+	{0x75, 0x58},
+	{0x76, 0x24},
+	{0x77, 0x40},
+	{0x78, 0x20},
+	{0x79, 0x60},
+	{0x7a, 0x58},
+	{0x7b, 0x20},
+	{0x7c, 0x30},
+	{0x7d, 0x35},
+	{0x7e, 0x10},
+	{0x7f, 0x08},
+	////////////////////ABS////////////////////
+	{0x9c, 0x02}, 
+	{0x9d, 0x20},
+	//{0x9f, 0x40},	
+	////////////////////CC-AWB////////////////////
+	{0xd0, 0x00},
+	{0xd2, 0x2c},
+	{0xd3, 0x80}, 
+	////////////////////LSC///////////////////
+	{0xfe, 0x01},
+	{0xa0, 0x00},
+	{0xa1, 0x3c},
+	{0xa2, 0x50},
+	{0xa3, 0x00},
+	{0xa8, 0x0f},
+	{0xa9, 0x08},
+	{0xaa, 0x00},
+	{0xab, 0x04},
+	{0xac, 0x00},
+	{0xad, 0x07},
+	{0xae, 0x0e},
+	{0xaf, 0x00},
+	{0xb0, 0x00},
+	{0xb1, 0x09},
+	{0xb2, 0x00},
+	{0xb3, 0x00},
+	{0xb4, 0x31},
+	{0xb5, 0x19},
+	{0xb6, 0x24},
+	{0xba, 0x3a},
+	{0xbb, 0x24},
+	{0xbc, 0x2a},
+	{0xc0, 0x17},
+	{0xc1, 0x13},
+	{0xc2, 0x17},
+	{0xc6, 0x21},
+	{0xc7, 0x1c},
+	{0xc8, 0x1c},
+	{0xb7, 0x00},
+	{0xb8, 0x00},
+	{0xb9, 0x00},
+	{0xbd, 0x00},
+	{0xbe, 0x00},
+	{0xbf, 0x00},
+	{0xc3, 0x00},
+	{0xc4, 0x00},
+	{0xc5, 0x00},
+	{0xc9, 0x00},
+	{0xca, 0x00},
+	{0xcb, 0x00},
+	{0xa4, 0x00},
+	{0xa5, 0x00},
+	{0xa6, 0x00},
+	{0xa7, 0x00},
+	{0xfe, 0x00},	
+	////////////////////asde ///////////////////
+	//{0xa0, 0xaf},
+	//{0xa2, 0xff},
+	{0x44, 0xa2},
+	/////banding/////////
+#if 1
+	{0x05, 0x01}, 	
+	{0x06, 0x32}, 
+	{0x07, 0x00},
+	{0x08, 0x70},
+	{0xfe,0x01},
+	{0x29, 0x00},   //anti-flicker step [11:8]
+	{0x2a, 0x78},   //anti-flicker step [7:0]
+	{0x2b, 0x02},   //exp level 0  14.28fps
+	{0x2c, 0x58}, 
+	{0x2d, 0x03},   //exp level 1  12.50fps
+	{0x2e, 0x48}, 
+	{0x2f, 0x04},   //exp level 2  10.00fps
+	{0x30, 0xb0}, 
+	{0x31, 0x05},   //exp level 3  7.14fps
+	{0x32, 0xa0}, 
+#else
+	{0x05, 0x00}, 	
+	{0x06, 0x6a}, 
+	{0x07, 0x00},
+	{0x08, 0x70},
+	{0xfe,0x01},
+	{0x29, 0x00},   //anti-flicker step [11:8]
+	{0x2a, 0x96},   //anti-flicker step [7:0]
+	{0x2b, 0x02},   //exp level 0  14.28fps
+	{0x2c, 0x58}, 
+	{0x2d, 0x02},   //exp level 1  12.50fps
+	{0x2e, 0x58}, 
+	{0x2f, 0x02},   //exp level 2  10.00fps
+	{0x30, 0x58}, 
+	{0x31, 0x02},   //exp level 3  7.14fps
+	{0x32, 0x58}, 
+#endif
+
+	{0xfe,0x00},
+	//effect
+	{0x43 , 0x00},
+	//wb
+	{0x77, 0x57},
+	{0x78, 0x4d},
+	{0x79, 0x45},
+	{0x42,0x7e},// awb on 
+
+	/////20120427////
+	{0xfe,0x01},
+	{0x18,0x22},
+	{0x21,0xc0},
+	{0x06,0x12},
+	{0x08,0x9c},
+	{0x51,0x28},
+	{0x52,0x10},
+	{0x53,0x20},
+	{0x54,0x40},
+	{0x55,0x16},
+	{0x56,0x30},
+	{0x58,0x60},
+	{0x59,0x08},
+	{0x5c,0x35},
+	{0x5d,0x72},
+	{0x67,0x80},
+	{0x68,0x60},
+	{0x69,0x90},
+	{0x6c,0x30},
+	{0x6d,0x60},
+	{0x70,0x10},
+
+	{0xfe,0x00},
+	{0x9c,0x0a},
+	{0xa0,0xaf},
+	{0xa2,0xff},
+	{0xa4,0x60},
+	{0xa5,0x31},
+	{0xa7,0x35},
+	{0x42,0xfe},
+	{0xd1,0x34},
+	{0xd2,0x34},
+	{0xfe,0x00},
+   // Reg[0x1f] , \B4\D30xc0 \B8\C4Ϊ0xc8;  
+	ENDMARKER,	
+};
+
+/* 320*240: QVGA*/
+static const struct regval_list module_qvga_regs[] = {
+	
+    { 0xfe, 0x00 },
+    { 0x4b, 0xca },
+    { 0x50, 0x01 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x00 },
+    { 0x55, 0x00 },
+    { 0x56, 0xf0 },  
+    { 0x57, 0x01 },
+    { 0x58, 0x40 },
+    
+    { 0x59, 0x22 },  
+    { 0x5a, 0x03 },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+	ENDMARKER,
+};
+
+/* 640*480: VGA*/
+static const struct regval_list module_vga_regs[] = {
+	 { 0xfe, 0x00 },
+    { 0x4b, 0xcb },
+    { 0x50, 0x01 },
+    { 0x51, 0x00 },
+    { 0x52, 0x00 },
+    { 0x53, 0x00 },
+    { 0x54, 0x00 },
+    { 0x55, 0x01 },
+    { 0x56, 0xe0 },  
+    { 0x57, 0x02 },
+    { 0x58, 0x80 },
+    
+    { 0x59, 0x11 },  
+    { 0x5a, 0x0e },
+    { 0x5b, 0x00 },
+    { 0x5c, 0x00 },
+    { 0x5d, 0x00 },
+    { 0x5e, 0x00 },
+    { 0x5f, 0x00 },
+    { 0x60, 0x00 },
+    { 0x61, 0x00 },
+    { 0x62, 0x00 },
+    { 0x4c, 0x00 },
+	ENDMARKER,
+};
+
+static const struct regval_list module_init_auto_focus[] = {
+	ENDMARKER,
+//  NULL
+};
+
+/*
+ * window size list
+ */
+/* 320X240 */
+static struct camera_module_win_size module_win_qvga = {
+	.name             = "QVGA",
+	.width            = WIDTH_QVGA,
+	.height           = HEIGHT_QVGA,
+	.win_regs         = module_qvga_regs,
+	.frame_rate_array = frame_rate_qvga,
+	.capture_only     = 0,
+};
+
+/* 640X480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_qvga,
+	&module_win_vga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+     {0x42, 0xfe},
+    {0x77, 0x57},
+    {0x78, 0x4d},
+    {0x79, 0x45},
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+  {0x42, 0xfd},
+    {0x77, 0x5a},
+    {0x78, 0x42},
+    {0x79, 0x40},
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+   {0x42, 0xfd},
+    {0x77, 0x50},
+    {0x78, 0x45},
+    {0x79, 0x40},
+	ENDMARKER,	
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+    {0x42, 0xfd},
+    {0x77, 0x40},
+    {0x78, 0x42},
+    {0x79, 0x50},
+	ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+     {0x42, 0xfd},
+    {0x77, 0x48},
+    {0x78, 0x40},
+    {0x79, 0x5c},
+	ENDMARKER,
+};
+
+static struct regval_list module_scene_auto_regs[] =
+{
+  {0x42, 0xfe},
+    {0x77, 0x57},
+    {0x78, 0x4d},
+    {0x79, 0x45},
+	ENDMARKER,
+};
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+
+	{	.id = V4L2_CID_AUTO_WHITE_BALANCE, 
+		.min = 0,
+		.max = 1, 
+		.step = 1, 
+		.def = 1,},
+	{	.id = V4L2_CID_WHITE_BALANCE_TEMPERATURE, 
+		.min = 0, 
+		.max = 3, 
+		.step = 1, 
+		.def = 1,},
+	{	.id   = V4L2_CID_GAIN, 
+		.min  = 10,
+		.max  = 0xffff,
+		.step = 1,
+		.def  = 0x00,},
+	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+
+	{	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	{	.id = V4L2_CID_COLORFX, 
+		.max = 3, 
+		.mask = 0x0, 
+		.def = 0,},
+	{	.id = V4L2_CID_EXPOSURE_AUTO, 
+		.max = 1, 
+		.mask = 0x0, 
+		.def = 1,},
+	{	.id = V4L2_CID_FLASH_LED_MODE, 
+		.max = 3,
+		.mask = 0x0,
+		.def = 0,},
+	{  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_TEXT, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+	{
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/gc2035/Kconfig b/drivers/media/i2c/camera/gc2035/Kconfig
new file mode 100755
index 0000000..74e0d8e
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2035/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config GC2035
+	tristate "gc2035 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for gc2035 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc2035.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc2035/Makefile b/drivers/media/i2c/camera/gc2035/Makefile
new file mode 100755
index 0000000..4260369
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2035/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_GC2035)	+= gc2035.o
diff --git a/drivers/media/i2c/camera/gc2035/gc2035.c b/drivers/media/i2c/camera/gc2035/gc2035.c
new file mode 100755
index 0000000..85fc209
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2035/gc2035.c
@@ -0,0 +1,715 @@
+/*
+ * gc2035 Camera Driver
+ *
+ * Copyright (C) 2011 Actions Semiconductor Co.,LTD
+ * Wang Xin <wangxin@actions-semi.com>
+ *
+ * Based on ov227x driver
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include"../module_comm/camera_chip_ident.h"
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0){
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+		}
+		vals++;
+	}
+	return 0;
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret;
+	unsigned int reg_0xfe;
+	struct i2c_adapter *i2c_adap = client->adapter;
+    GC_INFO("");
+    ret = camera_i2c_read(i2c_adap, 0xfe, &reg_0xfe);
+    reg_0xfe |= (0x1 << 7);
+    ret |= camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+    mdelay(1);
+    reg_0xfe &= (~(0x1 << 7));
+    ret |= camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+    return ret;
+}
+#if 0
+/*
+ *softstandby:ͨ\B9\FD\C5\E4\D6üĴ\E6\C6\F7ʹģ\D7\E9\BD\F8\C8\EB\B5͹\A6\BA\C4ģʽ\A3\AC\B4\CB״̬\CF\C2\CA\E4\B3\F6pin\B8\DF\D7衣\BCĴ\E6\C6\F7ֵ\B1\A3\C1\F4\A3\AC\C7ҼĴ\E6\C6\F7\BF\C9д
+ *ͨ\B9\FD\C0\AD\B8\DFpwdn pin\C0\B4\BD\F8\B5͹\A6\BA\C4ģʽʱ\A3\AC\CA\E4\B3\F6pin\B8\DF\D7裬\BCĴ\E6\C6\F7ֵ\B1\A3\C1\F4\B2\BB\B1䣬\B5\AB\BCĴ\E6\C6\F7\B2\BB\BF\C9д\A1\A3
+ */
+static int module_soft_standby(struct i2c_client *client)
+{
+    unsigned int reg_0xfe = 0x00;
+    unsigned int reg_0xf2 = 0x08;
+    int ret = 0;	
+		/*
+    ret = camera_i2c_write(client, 0xfe, &reg_0xfe);
+    ret |= camera_i2c_write(client, 0xf2, &reg_0xf2);
+		*/
+    return ret;
+}
+
+/*
+ *\B4\D3softstandby״̬\BBָ\B4normal״̬
+ */
+static int module_normal(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0xf2 = 0x70;
+	
+	
+	ret = camera_i2c_write(client, 0xfe, &reg_0xfe);
+	ret |= camera_i2c_write(client, 0xf2, &reg_0xf2);
+	*/
+	return ret;
+}
+#endif
+
+
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+  int ret = 0;
+  
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct i2c_adapter *i2c_adap = client->adapter;
+  
+  unsigned int reg_0xfe = 0x00;
+  unsigned int reg_0xb6 = 0x03;
+
+  ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+  ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+
+  return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+ int ret = 0;
+ 
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct i2c_adapter *i2c_adap = client->adapter;
+ 
+  unsigned int reg_0xfe = 0x00;
+  unsigned int reg_0xb6 = 0x00;
+
+  ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+  ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+ 
+  return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0x03;
+	unsigned int reg_0x04;
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_read(i2c_adap, 0x03, &reg_0x03);
+	ret |= camera_i2c_read(i2c_adap, 0x04, &reg_0x04);
+		
+	priv->preview_exposure_param.shutter = (reg_0x03 << 8) | reg_0x04;
+	priv->capture_exposure_param.shutter = (priv->preview_exposure_param.shutter)/2;
+	
+	//printk("GC2155 module_save_exposure_param, win->name:%s\n", priv->win->name);
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+ 	int ret = 0;
+  
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned char reg_0x03;
+	unsigned char reg_0x04;
+
+	if(priv->capture_exposure_param.shutter < 1) {
+		priv->capture_exposure_param.shutter = 1;
+	}
+
+	reg_0x03 = ((priv->capture_exposure_param.shutter)>>8) & 0x1F ;
+	reg_0x04 = (priv->capture_exposure_param.shutter) & 0xFF;
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+	ret |= camera_i2c_write(i2c_adap, 0x04, reg_0x04);
+	
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int auto_white_balance;
+	int ret = 0;
+  unsigned int reg_0x82;
+  unsigned int reg_0xfe = 0x00;
+
+	if(ctrl)
+		auto_white_balance = ctrl->val;
+	else
+		auto_white_balance = 1;
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("[gc2155] set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_read(i2c_adap, 0x82, &reg_0x82); 
+
+	switch(auto_white_balance)
+	{
+	case 0:
+		ret = 0;
+		goto change_val;
+		
+	case 1:	
+		ret |=camera_write_array(i2c_adap, module_whitebance_auto_regs);
+		break;
+	}
+	
+	reg_0x82 |= 0x02;
+	ret |= camera_i2c_write(i2c_adap, 0x82, reg_0x82); 
+ 
+change_val:
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		ctrl->cur.val = auto_white_balance;  
+		
+
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+  int white_balance_temperature = ctrl->val;
+  struct i2c_adapter *i2c_adap = client->adapter;
+  unsigned int reg_0x82;
+  unsigned int reg_0xfe = 0x00;
+	int ret = 0;
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_read(i2c_adap, 0x82, &reg_0x82); 
+	 
+	reg_0x82 &= (~0x02);  //\CA\D7\CF\C8disable awb\A3\AC\B7\F1\D4\F2\BCĴ\E6\C6\F7\B2\BB\BF\C9д\A1\A3
+	ret |= camera_i2c_write(i2c_adap, 0x82, reg_0x82);  
+
+	switch(white_balance_temperature)
+	{
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		printk("[gc2035] set white_balance_temperature over range, white_balance_temperature = %d\n", white_balance_temperature);
+		return -ERANGE;	
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+#if 0
+static int module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+  int colorfx = ctrl->val;
+	int ret = 0;
+
+
+	switch (colorfx) {
+	case V4L2_COLORFX_NONE: /* normal */
+		ret = camera_write_array(i2c_adap, module_effect_normal_regs);
+		break;
+	
+	case V4L2_COLORFX_BW: /* black and white */
+		ret = camera_write_array(i2c_adap, module_effect_white_black_regs);
+		break;
+	
+	case V4L2_COLORFX_SEPIA: /* antique ,\B8\B4\B9\C5*/
+		ret = camera_write_array(i2c_adap, module_effect_antique_regs);
+		break;
+
+	case V4L2_COLORFX_NEGATIVE: /* negative\A3\AC\B8\BAƬ */
+		ret = camera_write_array(i2c_adap, module_effect_negative_regs);
+		break;
+
+    default:
+        printk("[gc2035] set colorfx over range, colorfx = %d\n", colorfx);
+        return -ERANGE;	
+    }
+
+    priv->colorfx = colorfx;
+    ctrl->cur.val = colorfx;
+
+    return 0;
+}
+#endif
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    int exposure_auto;
+	int ret = 0;
+
+	if(ctrl)
+		exposure_auto = ctrl->val;
+	else
+		exposure_auto = V4L2_EXPOSURE_AUTO;
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+    case V4L2_EXPOSURE_MANUAL: // non auto
+        ret = 0;
+        break;
+    }
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		ctrl->cur.val = exposure_auto;
+
+    return 0;
+}
+
+static int module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+#if 0
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+  int scene_exposure = ctrl->val;
+	unsigned int reg_0x3a00;
+	
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_HOUSE:  //\CA\D2\C4\DA
+		ret = camera_write_array(i2c_adap, module_scene_night_regs);
+		break;
+	
+	case V4L2_SCENE_MODE_SUNLIGHT:  //\CA\D2\CD\E2
+		ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+    default:
+        printk("[gc2035] set scene_exposure over range, scene_exposure = %d\n", scene_exposure);
+        return -ERANGE;
+    }
+
+    priv->scene_exposure = scene_exposure;
+    ctrl->cur.val = scene_exposure;
+
+	
+#endif
+	return ret;
+}
+
+
+#if 0
+static int module_set_prev_capt_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+    int mode = ctrl->val;
+
+    switch(mode) {
+    case PREVIEW_MODE:
+        priv->prev_capt_mode = mode;
+        break;
+
+    case CAPTURE_MODE:
+        priv->prev_capt_mode = mode;
+        break;
+
+    default:
+        printk("[gc2035] set_prev_capt_mode over range, prev_capt_mode = %d\n", mode);
+        return -ERANGE;
+    }
+    ctrl->cur.val = mode;
+
+    return 0;
+}
+
+
+static int module_pause_af(struct i2c_client *client)
+{
+    int ret = 0;
+
+    return ret;	
+}
+
+static int module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+
+    return 0;
+}
+
+static int module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+    //	struct v4l2_subdev *sd = &priv->subdev;
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+    return 0;
+}
+
+static int module_set_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+    int ret = 0;
+
+    return ret;
+}
+#endif
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	unsigned char reg_0xfe = 0;
+	unsigned char reg_0xf2= 0x0f;
+
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+		   reg_0xf2 = 0x08;
+		   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+		   camera_i2c_write(i2c_adap, 0xf2, reg_0xf2);
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	   reg_0xf2 = 0x70;
+	   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	   camera_i2c_write(i2c_adap, 0xf2, reg_0xf2);
+	   
+	 return 0;   
+}
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    int ret = 0;
+
+    return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+    //  unsigned int analog_gain = 0;
+    //	unsigned int digital_gain = 0;
+    unsigned int total_gain = 0;
+    //	int ret = 0;
+
+    return total_gain;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+
+    return 0;
+}
+
+static int module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+   int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	
+	switch(ctrl->val){
+		case 4:
+			camera_write_array(client->adapter,module_exp_comp_pos4_regs);
+			break;
+		case 3:
+			camera_write_array(client->adapter,module_exp_comp_pos3_regs);
+			break;
+		case 2:
+			camera_write_array(client->adapter,module_exp_comp_pos2_regs);
+			break;
+		case 1:
+			camera_write_array(client->adapter,module_exp_comp_pos1_regs);
+			break;
+		case 0:
+			camera_write_array(client->adapter,module_exp_comp_zero_regs);
+			break;
+		case -1:
+			camera_write_array(client->adapter,module_exp_comp_neg1_regs);
+			break;
+		case -2:
+			camera_write_array(client->adapter,module_exp_comp_neg2_regs);
+			break;
+		case -3:
+			camera_write_array(client->adapter,module_exp_comp_neg3_regs);
+			break;
+		case -4:
+			camera_write_array(client->adapter,module_exp_comp_neg4_regs);
+			break;
+		default:
+			break;		
+	}
+
+	
+	return ret;
+}
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	struct i2c_adapter *i2c_adap = client->adapter;
+	enum v4l2_mbus_pixelcode code;
+	unsigned char reg_0x84;
+	unsigned char reg_0xfe = 0x00;  //pgae0
+	int ret = 0;
+	
+	code = cfmt->code;
+	
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_0x84 = 0x02;
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		reg_0x84 = 0x00;
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		reg_0x84 = 0x03;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		reg_0x84 = 0x01;
+		break;
+		
+	default:
+		printk("[gc2155] mbus code error in %s() line %d\n",__FUNCTION__, __LINE__);
+		return -1;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_write(i2c_adap, 0x84, reg_0x84);
+	return ret;
+}
+
+
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	unsigned int reg_0x17 = 0x14;
+	unsigned int reg_0xfe = 0x00;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	
+	if ((!mirror) && (!flip)) {
+		return 0;
+	}
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+ 
+	if (mirror)	{
+		reg_0x17 |= 0x1;
+	} else {
+		reg_0x17 &= (~0x1);
+	}
+	
+	if (flip) {
+		reg_0x17 |= (0x1<<0x1);
+	} else {
+		reg_0x17 &= (~(0x1<<0x1));	
+	}
+	
+	ret |= camera_i2c_write(i2c_adap, 0x17, reg_0x17);
+
+	return ret;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int pidh = 0;
+    unsigned int pidl = 0;
+    int ret;
+
+	
+	GC_INFO("");
+
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PIDH, &pidh); 
+	ret |= camera_i2c_read(i2c_adap, PIDL, &pidl); 
+	switch (VERSION(pidh, pidl)) 
+    {
+	case CAMERA_MODULE_PID:
+/*		if(priv)
+			{
+		     priv->model= V4L2_IDENT_GC2035;
+			}*/
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, VERSION(pidh, pidl));
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, VERSION(pidh, pidl));
+		return -ENODEV;
+	}
+	return ret;
+}
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc2035/module_diff.h b/drivers/media/i2c/camera/gc2035/module_diff.h
new file mode 100755
index 0000000..ed6bb94
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2035/module_diff.h
@@ -0,0 +1,1264 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME 		"gc2035"
+#define CAMERA_MODULE_PID			0x2035
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+#define GC2035_SUBSAMPLE
+
+#define MODULE_PLATFORM_ID		GC2035_PLATFORM_ID
+#define MODULE_I2C_REAL_ADDRESS		(0x78>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x78>>1)
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+
+#define PIDH					0xf0 /* Product ID Number H byte */
+#define PIDL					0xf1 /* Product ID Number L byte */
+#define OUTTO_SENSO_CLOCK 		24000000
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_HSYNC_ACTIVE_LEVEL		V4L2_MBUS_HSYNC_ACTIVE_HIGH
+#define DEFAULT_PCLK_SAMPLE_EDGE        V4L2_MBUS_PCLK_SAMPLE_RISING
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_SVGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_SVGA
+#define MODULE_MAX_WIDTH		WIDTH_UXGA
+#define MODULE_MAX_HEIGHT		HEIGHT_UXGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		2
+#define DROP_NUM_PREVIEW		6
+
+static unsigned int frame_rate_svga[] = {30,};
+//static unsigned int frame_rate_720p[] = {30,};
+static unsigned int frame_rate_uxga[] = {15,};
+
+/*
+ * register setting for window size 800*600
+ */
+static const struct regval_list module_init_regs[] =
+{
+	{0xfe , 0x80},
+	{0xfe , 0x80}, 
+	{0xfe , 0x80}, 
+	{0xfc , 0x06},
+	{0xf2 , 0x00}, 
+	{0xf3 , 0x00}, 
+	{0xf4 , 0x00}, 
+	{0xf5 , 0x00}, 
+	{0xf9 , 0xfe}, //[0] pll enable
+	{0xfa , 0x00}, 
+	{0xf6 , 0x00},
+	{0xf7 , 0x15}, //pll enable 
+	{0xf8 , 0x85}, 
+	{0xfe , 0x00}, 
+	{0x82 , 0x00}, 
+	{0xb3 , 0x60}, 
+	{0xb4 , 0x40},
+	{0xb5 , 0x60},
+	{0x03 , 0x02}, 
+	{0x04 , 0x80},
+		//////////measure window  ///////////
+	{0xfe , 0x00}, 
+	{0xec , 0x06},//04 
+	{0xed , 0x06},//04 
+	{0xee , 0x62},//60 
+	{0xef , 0x92},//90 
+		///////////analog/////////////
+	{0x0a , 0x00}, //row start 
+	{0x0c , 0x00}, //col start 
+	{0x0d , 0x04},
+	{0x0e , 0xc0}, 
+	{0x0f , 0x06}, //Window setting 
+	{0x10 , 0x58}, 
+	{0x17 , 0x14}, //[0]mirror [1]flip 
+	{0x18 , 0x0e}, //0a 2012.10.26
+	{0x19 , 0x0c}, //AD pipe number 
+	{0x1a , 0x01}, //CISCTL mode4 
+	{0x1b , 0x8b}, 
+	{0x1c , 0x05},//add by lanking 20130403
+	{0x1e , 0x88}, //analog mode1 [7] tx-high en [5:3]COL_bias 
+	{0x1f , 0x08}, //[3] tx-low en// 
+	{0x20 , 0x05}, //[0]adclk mode , 0x[1]rowclk_MODE [2]rsthigh_en
+	{0x21 , 0x0f}, //[6:4]rsg 
+	{0x22 , 0xf0}, //[3:0]vref  d0 20130628
+	{0x23 , 0xc3}, //f3//ADC_r {0x24 , 0x17}, //pad drive  16
+	//AWB_gray
+	{0xfe , 0x01},
+	{0x4f , 0x00},
+	{0x4d , 0x32}, // 30
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4d , 0x42}, // 40
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4d , 0x52}, // 50 
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4d , 0x62}, // 60 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4d , 0x72}, // 70 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4d , 0x82}, // 80 
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4d , 0x92}, // 90 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4e , 0x04},
+	{0x4e , 0x04}, 
+	{0x4e , 0x04}, 
+	{0x4f , 0x01}, 
+	{0x50 , 0x88}, 
+	{0xfe , 0x00}, 
+	{0x82 , 0xfe},
+		///////awb start ////////////////
+	{0xfe , 0x01}, 
+	{0x50 , 0x88},//c0//[6]green mode 
+	{0x52 , 0x40}, 
+	{0x54 , 0x60}, 
+	{0x56 , 0x06}, 
+	{0x57 , 0x20},//pre adjust 
+	{0x58 , 0x01}, 
+	{0x5b , 0x02},//AWB_gain_delta
+	{0x61 , 0xaa},//R/G stand 
+	{0x62 , 0xaa},//R/G stand 
+	{0x71 , 0x00}, 
+	{0x74 , 0x10},//AWB_C_max 
+	{0x77 , 0x08},//AWB_p2_x 
+	{0x78 , 0xfd},//AWB_p2_y 
+	{0x86 , 0x30}, 
+	{0x87 , 0x00}, 
+	{0x88 , 0x04},//[1]dark mode 
+	{0x8a , 0xc0},//awb move mode 
+	{0x89 , 0x75}, 
+	{0x84 , 0x08},//auto_window 
+	{0x8b , 0x00},//awb compare luma 
+	{0x8d , 0x70},//awb gain limit R
+	{0x8e , 0x70},//G 
+	{0x8f , 0xf4},//B
+	  /////////awb end /////////////
+		//AEC
+	{0xfe , 0x01},
+	{0x11 , 0x20},//AEC_out_slope , 0x 
+	{0x1f , 0xb0},//max_post_gain 
+	{0x20 , 0x50},//max_pre_gain 
+	{0x47 , 0x30},//AEC_outdoor_th 
+	{0x0b , 0x10},//
+	{0x13 , 0x80},//y_target
+	{0xfe , 0x00}, 
+	{0x05 , 0x01},
+	{0x06 , 0x0d},
+	{0x07 , 0x00},
+	{0x08 , 0x40}, 
+	{0xfe , 0x01}, 
+	{0x27 , 0x00},
+	{0x28 , 0xa0}, 
+	{0x29 , 0x05},//  level 0 13.75 
+	{0x2a , 0x00}, 
+	{0x2b , 0x06},//  level 1 13.75 
+	{0x2c , 0x40},
+	{0x2d , 0x06},//  level 2 10 
+	{0x2e , 0x40}, 
+	{0x2f , 0x08},//  level 3 7.5 
+	{0x30 , 0xc0}, 
+	{0xfe , 0x00},// 
+	{0xb6 , 0x03},//AEC enable
+	{0xfe , 0x00},
+		/////////BLK//////
+	{0x3f , 0x00},//prc close 
+	{0x40 , 0x77},// 
+	{0x42 , 0x7f}, 
+	{0x43 , 0x30},
+	{0x5c , 0x08}, 
+	{0x5e , 0x20}, 
+	{0x5f , 0x20}, 
+	{0x60 , 0x20}, 
+	{0x61 , 0x20}, 
+	{0x62 , 0x20}, 
+	{0x63 , 0x20},
+	{0x64 , 0x20}, 
+	{0x65 , 0x20},
+		///block////////////
+	{0x80 , 0xff}, 
+	{0x81 , 0x26},//38 //skin_Y 8c_debug 
+	{0x87 , 0x90},//[7]middle gamma
+	{0x84 , 0x02},//output put foramat 
+	{0x86 , 0x03},//02 //sync plority  lanking 
+	{0x8b , 0xbc}, 
+	{0xb0 , 0x80},//globle gain 
+	{0xc0 , 0x40},//Yuv bypass
+		//////lsc/////////////
+	{0xfe , 0x01},
+	{0xc2 , 0x38}, 
+	{0xc3 , 0x25}, 
+	{0xc4 , 0x21}, 
+	{0xc8 , 0x19}, 
+	{0xc9 , 0x12}, 
+	{0xca , 0x0e}, 
+	{0xbc , 0x43}, 
+	{0xbd , 0x18}, 
+	{0xbe , 0x1b}, 
+	{0xb6 , 0x40},
+	{0xb7 , 0x2e},
+	{0xb8 , 0x26}, 
+	{0xc5 , 0x05},
+	{0xc6 , 0x03}, 
+	{0xc7 , 0x04}, 
+	{0xcb , 0x00}, 
+	{0xcc , 0x00}, 
+	{0xcd , 0x00}, 
+	{0xbf , 0x14}, 
+	{0xc0 , 0x22}, 
+	{0xc1 , 0x1b}, 
+	{0xb9 , 0x00}, 
+	{0xba , 0x05}, 
+	{0xbb , 0x05}, 
+	{0xaa , 0x35},
+	{0xab , 0x33}, 
+	{0xac , 0x33}, 
+	{0xad , 0x25}, 
+	{0xae , 0x22}, 
+	{0xaf , 0x27}, 
+	{0xb0 , 0x1d}, 
+	{0xb1 , 0x20}, 
+	{0xb2 , 0x22}, 
+	{0xb3 , 0x14}, 
+	{0xb4 , 0x15}, 
+	{0xb5 , 0x16}, 
+	{0xd0 , 0x00}, 
+	{0xd2 , 0x07}, 
+	{0xd3 , 0x08}, 
+	{0xd8 , 0x00}, 
+	{0xda , 0x13}, 
+	{0xdb , 0x17}, 
+	{0xdc , 0x00}, 
+	{0xde , 0x0a}, 
+	{0xdf , 0x08}, 
+	{0xd4 , 0x00}, 
+	{0xd6 , 0x00}, 
+	{0xd7 , 0x0c}, 
+	{0xa4 , 0x00}, 
+	{0xa5 , 0x00}, 
+	{0xa6 , 0x00}, 
+	{0xa7 , 0x00}, 
+	{0xa8 , 0x00}, 
+	{0xa9 , 0x00}, 
+	{0xa1 , 0x80}, 
+	{0xa2 , 0x80},
+		//////////cc//////////////
+	{0xfe , 0x02}, 
+	{0xc0 , 0x01},
+	{0xc1 , 0x40},//Green_cc for d 
+	{0xc2 , 0xfc}, 
+	{0xc3 , 0x05}, 
+	{0xc4 , 0xec}, 
+	{0xc5 , 0x42}, 
+	{0xc6 , 0xf8}, 
+	{0xc7 , 0x40},//for cwf
+	{0xc8 , 0xf8}, 
+	{0xc9 , 0x06},
+	{0xca , 0xfd}, 
+	{0xcb , 0x3e}, 
+	{0xcc , 0xf3}, 
+	{0xcd , 0x36},//for A 
+	{0xce , 0xf6}, 
+	{0xcf , 0x04}, 
+	{0xe3 , 0x0c}, 
+	{0xe4 , 0x44}, 
+	{0xe5 , 0xe5}, 
+	{0xfe , 0x00},
+		///==========asde
+	{0xfe , 0x01},
+	{0x21 , 0xbf}, 
+	{0xfe , 0x02}, 
+	{0xa4 , 0x00},
+	{0xa5 , 0x40},//lsc_th 
+	{0xa2 , 0xa0},//lsc_dec_slope
+	///////20140505 update for DD///
+	{0x86 , 0x27},//add for DPC travis 20140505 
+	{0x8a , 0x33},//add for DPC travis 20140505 
+	{0x8d , 0x85},//add for DPC travis 20140505 
+	{0xa6 , 0xf0},//80//change for DPC travis 20140505 //
+	{0xa6 , 0x80},//dd_th
+	{0xa7 , 0x80},//ot_th
+	{0xab , 0x31}, 
+	{0xa9 , 0x6f}, 
+	{0xb0 , 0x99},//edge effect slope low
+	{0xb1 , 0x34},//edge effect slope low
+	{0xb3 , 0x80},//saturation dec slope 
+	{0xde , 0xb6}, 
+	{0x38 , 0x0f}, 
+	{0x39 , 0x60}, 
+	{0xfe , 0x00}, 
+	{0x81 , 0x26}, 
+	{0xfe , 0x02}, 
+	{0x83 , 0x00}, 
+	{0x84 , 0x45}, ////////////YCP//////////
+	{0xd1 , 0x38},//saturation_cb 
+	{0xd2 , 0x38},//saturation_Cr 
+	{0xd3 , 0x40},//contrast 
+	{0xd4 , 0x80},//contrast center 
+	{0xd5 , 0x00},//luma_offset 
+	{0xdc , 0x30}, 
+	{0xdd , 0xb8},//edge_sa_g,b 
+	{0xfe , 0x00}, //////////dndd///////////
+	{0xfe , 0x02},
+	{0x88 , 0x1f},//dn_b_base 
+	{0x8c , 0xf6},//[2]b_in_dark_inc
+	{0x89 , 0x03},//dn_c_weight //////////EE ///////////
+	{0xfe , 0x02}, 
+	{0x90 , 0x6c},// EEINTP mode1 
+	{0x97 , 0x23},// edge effect 
+	////==============RGB Gamma ////
+	{0xfe , 0x02},
+	{0x15 , 0x0a}, 
+	{0x16 , 0x12}, 
+	{0x17 , 0x19},
+	{0x18 , 0x1f}, 
+	{0x19 , 0x2c}, 
+	{0x1a , 0x38}, 
+	{0x1b , 0x42}, 
+	{0x1c , 0x4e}, 
+	{0x1d , 0x63}, 
+	{0x1e , 0x76},
+	{0x1f , 0x87},
+	{0x20 , 0x96}, 
+	{0x21 , 0xa2}, 
+	{0x22 , 0xb8}, 
+	{0x23 , 0xca}, 
+	{0x24 , 0xd8}, 
+	{0x25 , 0xe3}, 
+	{0x26 , 0xf0}, 
+	{0x27 , 0xf8}, 
+	{0x28 , 0xfd}, 
+	{0x29 , 0xff}, 
+//// small  RGB gamma////
+	/* 
+	{0xfe , 0x02},
+	{0x15 , 0x0b},
+	{0x16 , 0x0e},
+	{0x17 , 0x10}, 
+	{0x18 , 0x12}, 
+	{0x19 , 0x19}, 
+	{0x1a , 0x21}, 
+	{0x1b , 0x29},
+	{0x1c , 0x31}, 
+	{0x1d , 0x41},
+	{0x1e , 0x50},
+	{0x1f , 0x5f},
+	{0x20 , 0x6d}, 
+	{0x21 , 0x79},
+	{0x22 , 0x91},
+	{0x23 , 0xa5}, 
+	{0x24 , 0xb9}, 
+	{0x25 , 0xc9}, 
+	{0x26 , 0xe1}, 
+	{0x27 , 0xee}, 
+	{0x28 , 0xf7}, 
+	{0x29 , 0xff},
+	*/
+	///=================y gamma
+	{0xfe , 0x02}, 
+	{0x2b , 0x00},
+	{0x2c , 0x04},
+	{0x2d , 0x09}, 
+	{0x2e , 0x18}, 
+	{0x2f , 0x27}, 
+	{0x30 , 0x37}, 
+	{0x31 , 0x49}, 
+	{0x32 , 0x5c}, 
+	{0x33 , 0x7e}, 
+	{0x34 , 0xa0}, 
+	{0x35 , 0xc0}, 
+	{0x36 , 0xe0}, 
+	{0x37 , 0xff},
+	//	Sleep(250},
+		//AWB clear
+	{0xfe , 0x01}, 
+	{0x4f , 0x00}, 
+	{0x4d , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4d , 0x10}, // 10 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4d , 0x20}, // 20
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4d , 0x30}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, // 30 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4d , 0x40}, // 40 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00},
+	{0x4d , 0x50}, // 50 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4d , 0x60}, // 60 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4d , 0x70}, // 70 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4d , 0x80}, // 80 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4d , 0x90}, // 90 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4d , 0xa0}, // a0 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4d , 0xb0}, // b0 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4d , 0xc0}, // c0 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4d , 0xd0}, // d0 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x00},
+	{0x4e , 0x00}, 
+	{0x4e , 0x00}, 
+	{0x4f , 0x01}, 
+	/////// awb value////////
+	{0xfe , 0x01}, 
+	{0x4f , 0x00},
+	{0x4d , 0x30}, 
+	{0x4e , 0x00},
+	{0x4e , 0x80}, 
+	{0x4e , 0x80}, 
+	{0x4e , 0x02}, 
+	{0x4e , 0x02}, 
+	{0x4d , 0x40}, 
+	{0x4e , 0x00}, 
+	{0x4e , 0x80},
+	{0x4e , 0x80}, 
+	{0x4e , 0x02}, 
+	{0x4e , 0x02}, 
+	{0x4e , 0x02}, 
+	{0x4d , 0x53}, 
+	{0x4e , 0x08},
+	{0x4e , 0x04}, 
+	{0x4d , 0x62}, 
+	{0x4e , 0x10}, 
+	{0x4d , 0x72}, 
+	{0x4e , 0x20}, 
+	{0x4f , 0x01},
+	/////1600x1200size// 
+	{0xfe , 0x00},// 
+	{0x90 , 0x01}, ////crop enable 
+	{0x95 , 0x04},  ////1600x1200
+	{0x96 , 0xb0}, 
+	{0x97 , 0x06}, 
+	{0x98 , 0x40},
+	{0xfe , 0x03}, 
+	{0x17 , 0x00}, //widv 
+	{0x40 , 0x40},  //00 
+	{0x41 , 0x02}, // Pclk_polarity 
+	{0x42 , 0x40}, 
+	{0x43 , 0x06}, //output buf width
+#if defined(GC2035_SUBSAMPLE)
+	    ////////sabsumple  800X600//////
+	{0xfe , 0x01}, 
+	{0x21 , 0xbf},
+	{0xfe , 0x00}, 
+	{0xfa , 0x00}, 
+	{0xc8 , 0x00},
+	{0x99 , 0x22}, 
+	{0x9a , 0x07}, 
+	{0x9b , 0x00}, 
+	{0x9c , 0x00}, 
+	{0x9d , 0x00}, 
+	{0x9e , 0x00},
+	{0x9f , 0x00}, 
+	{0xa0 , 0x00},
+	{0xa1 , 0x00}, 
+	{0xa2 , 0x00},
+	{0x90 , 0x01}, 
+	{0x95 , 0x02}, 
+	{0x96 , 0x58}, 
+	{0x97 , 0x03}, 
+	{0x98 , 0x20},	 
+#else 
+	{0xfe , 0x01}, 
+	{0x21 , 0xbf},
+		////////scalar  800X600/////////
+	{0xfe , 0x00}, 
+	{0xfa , 0x00}, 
+	{0xc8 , 0x54},
+	{0x90 , 0x01}, 
+	{0x95 , 0x02}, 
+	{0x96 , 0x58}, 
+	{0x97 , 0x03}, 
+	{0x98 , 0x20},
+#endif
+	  #if 0 /////////  re zao///
+	{0xfe , 0x00}, 
+	{0xfe , 0x01}, 
+	{0x21 , 0xff}, 
+	{0xfe , 0x02},
+	{0x8a , 0x33},
+	{0x8c , 0x76}, 
+	{0x8d , 0x85}, 
+	{0xa6 , 0xf0}, 
+	{0xae , 0x9f}, 
+	{0xa2 , 0x90}, 
+	{0xa5 , 0x40}, 
+	{0xa7 , 0x30}, 
+	{0xb0 , 0x88}, 
+	{0x38 , 0x0b}, 
+	{0x39 , 0x30}, 
+	{0xfe , 0x00}, 
+	{0x87 , 0xb0},
+	 	////dark sun/////
+	{0xfe , 0x02}, 
+	{0x40 , 0x06}, 
+	{0x41 , 0x23}, 
+	{0x42 , 0x3f}, 
+	{0x43 , 0x06},
+	{0x44 , 0x00}, 
+	{0x45 , 0x00},
+	{0x46 , 0x14}, 
+	{0x47 , 0x09},
+	  #endif
+		////output DVP/////
+	{0xfe , 0x00}, 
+	{0x82 , 0xfe},
+	{0xf2 , 0x70}, 
+	{0xf3 , 0xff}, 
+	{0xf4 , 0x00}, 
+	{0xf5 , 0x30},
+
+	ENDMARKER,
+};
+
+/* 800*600: SVGA*/
+static const struct regval_list module_svga_regs[] = {
+  	#if defined(GC2035_SUBSAMPLE)
+	{0xfe , 0x01},	
+	{0x21 , 0xbf},
+	    ////////sabsumple  800X600//////
+	{0xfe , 0x00},
+	{0xf8 , 0x85}, 
+	{0xfa , 0x00},
+	{0xc8 , 0x00},
+	                                  
+	{0x99 , 0x22},
+	{0x9a , 0x07},
+	{0x9b , 0x00},  
+	{0x9c , 0x00},
+	{0x9d , 0x00},
+	{0x9e , 0x00},
+	{0x9f , 0x00},  
+	{0xa0 , 0x00},
+	{0xa1 , 0x00},
+	{0xa2 , 0x00},
+		                                
+	{0x90 , 0x01},
+	{0x95 , 0x02},
+	{0x96 , 0x58},  
+	{0x97 , 0x03},
+	{0x98 , 0x20},	 
+
+#else
+	{0xfe , 0x01},	
+	{0x21 , 0xbf},
+		////////scalar  800X600/////////
+	{0xfe , 0x00},
+		{0xf8 , 0x85}, 
+	{0xfa , 0x00},
+	{0xc8 , 0x54},
+	                                                                                
+	{0x90 , 0x01},
+	{0x95 , 0x02},
+	{0x96 , 0x58},  
+	{0x97 , 0x03},
+	{0x98 , 0x20},
+
+#endif
+
+	ENDMARKER,
+};
+#if 0
+/* 1280*720: 720P*/
+static const struct regval_list module_720p_regs[] = {
+	////////subsumple  1280X720//////
+	   {0xfe,0x00},
+	   	{0xf8 , 0x84}, 
+	   {0xfa,0x00},
+	   {0xc8,0x00},
+	   
+	   {0x99,0x55},// 4/5 subsample
+	   {0x9a,0x06},
+	   {0x9b,0x00},
+	   {0x9c,0x00},
+	   {0x9d,0x01},
+	   {0x9e,0x23},
+	   {0x9f,0x00},
+	   {0xa0,0x00},
+	   {0xa1,0x01},
+	   {0xa2,0x23},
+	   
+	   {0x90,0x01},
+	   {0x95,0x02},
+	   {0x96,0xd0},  
+	   {0x97,0x05},
+	   {0x98,0x00},
+	   ENDMARKER,
+
+};
+#endif
+/* 1600*1200 UXGA */
+static const struct regval_list module_uxga_regs[] = {
+#if defined(GC2035_SUBSAMPLE)
+	{0xfe , 0x01},	
+	{0x21 , 0xdf},
+	  	////////sabsumple  1600X1200//////
+	{0xfe , 0x00},
+		{0xf8 , 0x85}, 
+	{0xfa , 0x11},
+	{0xc8 , 0x00},
+	                                  
+	{0x99 , 0x11},
+	{0x9a , 0x06},
+	{0x9b , 0x00},  
+	{0x9c , 0x00},
+	{0x9d , 0x00},
+	{0x9e , 0x00},
+	{0x9f , 0x00},  
+	{0xa0 , 0x00},
+	{0xa1 , 0x00},
+	{0xa2 , 0x00},
+	                                  
+		                                
+	{0x90 , 0x01},
+	{0x95 , 0x04},
+	{0x96 , 0xb0},  
+	{0x97 , 0x06},
+	{0x98 , 0x40},	 
+
+#else
+	{0xfe , 0x01},	
+	{0x21 , 0xdf},
+		////////scalar  1600X1200/////////
+	{0xfe , 0x00},
+		{0xf8 , 0x85}, 
+	{0xfa , 0x11},
+	{0xc8 , 0x00},
+		                                
+	{0x90 , 0x01},
+	{0x95 , 0x04},
+	{0x96 , 0xb0},  
+	{0x97 , 0x06},
+	{0x98 , 0x40},
+	             
+
+#endif
+  ENDMARKER,
+};
+
+static const struct regval_list module_init_auto_focus[] = {
+    //  NULL
+	ENDMARKER,
+};
+/*
+ * window size list
+ */
+
+#if 0
+/* 640X480 */
+static struct camera_module_win_size module_win_vga = {
+    .name             = "VGA",
+    .width            = WIDTH_VGA,
+    .height           = HEIGHT_VGA,
+    .win_regs         = module_vga_regs,
+    .frame_rate_array = frame_rate_vga,
+};
+#endif
+/* 800X600 */
+static struct camera_module_win_size module_win_svga = {
+    .name             = "SVGA",
+    .width            = WIDTH_SVGA,
+    .height           = HEIGHT_SVGA,
+    .win_regs         = module_svga_regs,
+
+    .frame_rate_array = frame_rate_svga,
+    .capture_only     = 0,
+};
+#if 0
+/* 1280X720 */
+static struct camera_module_win_size module_win_720p = {
+    .name             = "720P",
+    .width            = WIDTH_720P,
+    .height           = HEIGHT_720P,
+    .win_regs         = module_720p_regs,
+    .frame_rate_array = frame_rate_720p,
+};
+#endif
+/* 1600X1200 */
+static struct camera_module_win_size module_win_uxga = {
+    .name             = "UXGA",
+    .width            = WIDTH_UXGA,
+    .height           = HEIGHT_UXGA,
+    .win_regs         = module_uxga_regs,
+    .frame_rate_array = frame_rate_uxga,
+    .capture_only     = 1,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+   // &module_win_vga,
+    &module_win_svga,
+  //  &module_win_720p,
+    &module_win_uxga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+//  NULL
+	{0xfe, 0x00},
+    {0xb3, 0x61},
+    {0xb4, 0x40},
+    {0xb5, 0x61},
+    ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+//  NULL
+	{0xfe, 0x00},
+    {0xb3, 0x88},
+    {0xb4, 0x44},
+    {0xb5, 0x40},
+    ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+//  NULL
+	{0xfe, 0x00},
+    {0xb3, 0x94},
+    {0xb4, 0x58},
+    {0xb5, 0x68},
+    ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+//  NULL
+	
+    {0xfe, 0x00},
+    {0xb3, 0x58},
+    {0xb4, 0x40},
+    {0xb5, 0x90},
+    ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+//  NULL
+	{0xfe, 0x00},
+    {0xb3, 0x40},
+    {0xb4, 0x40},
+    {0xb5, 0xf0},       //0x50
+    ENDMARKER,
+};
+#if 0
+/*\D5\FD\B3\A3ģʽ*/
+static struct regval_list module_effect_normal_regs[] =
+{
+//  NULL
+	{0xfe, 0x00},
+    {0x83, 0x00},
+    ENDMARKER,
+};
+
+/*\B5\A5ɫ\A3\AC\BAڰ\D7\D5\D5Ƭ*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+    {0xfe, 0x00},
+    {0x83, 0x12},
+	ENDMARKER,
+};
+
+/*\B8\BAƬЧ\B9\FB*/
+static struct regval_list module_effect_negative_regs[] =
+{
+    //Negative
+    {0xfe, 0x00},
+    {0x83, 0x01},
+	ENDMARKER,
+};
+/*\B8\B4\B9\C5Ч\B9\FB*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+    {0xfe, 0x00},
+    {0x83, 0x82},
+	ENDMARKER,
+};
+#endif
+static struct regval_list module_scene_auto_regs[] =
+{
+//  NULL
+	{0xfe, 0x01},
+    {0x3e, 0x40},
+    {0xfe, 0x00},
+	ENDMARKER,
+};
+/*
+ * The exposure target setttings
+ */
+static struct regval_list module_exp_comp_neg4_regs[] = {
+	{0xfe,0x01},
+	{0x13,0x40},
+	{0xfe,0x02},
+	{0xd5,0xc0},
+	{0xfe,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg3_regs[] = {
+	{0xfe,0x01},
+	{0x13,0x50},
+	{0xfe,0x02},
+	{0xd5,0xd0},
+	{0xfe,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg2_regs[] = {
+	{0xfe,0x01},
+	{0x13,0x60},
+	{0xfe,0x02},
+	{0xd5,0xe0},
+	{0xfe,0x00},
+
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg1_regs[] = {
+	{0xfe,0x01},
+	{0x13,0x68},
+	{0xfe,0x02},
+	{0xd5,0xf0},
+	{0xfe,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_zero_regs[] = {
+	 {0xfe,0x01},
+	{0x13,0x78},
+     {0xfe,0x02},
+	{0xd5,0x00},
+	{0xfe,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos1_regs[] = {
+	{0xfe,0x01},
+	{0x13,0x80},
+	{0xfe,0x02},
+	{0xd5,0x10},
+	{0xfe,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos2_regs[] = {
+	{0xfe,0x01},
+	{0x13,0x90},
+	{0xfe,0x02},
+	{0xd5,0x20},
+	{0xfe,0x00},
+	{0xff,0xff},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos3_regs[] = {
+    {0xfe,0x01},
+	{0x13,0xa0},
+	{0xfe,0x02},
+	{0xd5,0x30},
+	{0xfe,0x00},
+
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos4_regs[] = {
+	{0xfe,0x01},
+	{0x13,0xb0},
+	{0xfe,0x02},
+	{0xd5,0x50},
+	{0xfe,0x00},
+	ENDMARKER,
+};
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{
+			.id = V4L2_CID_AUTO_WHITE_BALANCE,
+			.min = 0,
+			.max = 1,
+			.step = 1,
+			.def = 1,
+		},
+		{	.id = V4L2_CID_EXPOSURE_COMP, 
+			.min = -4, 
+			.max = 4, 
+			.step = 1, 
+			.def = 0,
+		},	
+		{	.id = V4L2_CID_GAIN, 
+			.min = 10, 
+			.max = 2048, 
+			.step = 1, 
+			.def = 30,
+		},
+    {	.id = V4L2_CID_WHITE_BALANCE_TEMPERATURE, 
+        .min = 0, 
+        .max = 3, 
+        .step = 1, 
+        .def = 1,},
+     	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+//    {	.id = V4L2_CID_SCENE_EXPOSURE, 
+//        .min = 0, 
+//        .max = 1, 
+//        .step = 1, 
+//        .def = 0,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+//    {	.id = V4L2_CID_PRIVATE_PREV_CAPT, 
+//        .min = 0, 
+//        .max = 1, 
+//        .step = 1, 
+//        .def = PREVIEW_MODE,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+#if 0
+    {	.id = V4L2_CID_AF_STATUS, 
+        .min = AF_STATUS_DISABLE, 
+        .max = AF_STATUS_FAIL, 
+        .step = 1, 
+        .def = AF_STATUS_DISABLE,},
+    {	.id = V4L2_CID_FLASH_STROBE, 
+        .min = 0, 
+        .max = 1, 
+        .step = 1, 
+        .def = 0,},
+    {	.id = V4L2_CID_FLASH_STROBE_STOP, 
+        .min = 0, 
+        .max = 1, 
+        .step = 1, 
+        .def = 0,},
+#endif
+	{	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+    {	.id = V4L2_CID_COLORFX, 
+        .max = 3, 
+        .mask = 0x0, 
+        .def = 0,},
+    {	.id = V4L2_CID_EXPOSURE_AUTO, 
+        .max = 1, 
+        .mask = 0x0, 
+        .def = 1,},
+    {	
+	    .id = V4L2_CID_SCENE_MODE, 
+	    .max = V4L2_SCENE_MODE_TEXT, 
+	    .mask = 0x0, 
+	    .def = 0,},
+#if 1
+    {	.id = V4L2_CID_FLASH_LED_MODE, 
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,},
+#endif
+		{
+		.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+		.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+		.mask = 0x0,
+		.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/gc2145/Kconfig b/drivers/media/i2c/camera/gc2145/Kconfig
new file mode 100755
index 0000000..b5722a7
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2145/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config GC2145
+	tristate "gc2145 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for gc2145 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc2145.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc2145/Makefile b/drivers/media/i2c/camera/gc2145/Makefile
new file mode 100755
index 0000000..5c5d9c4
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2145/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_GC2145)	+= gc2145.o
+
diff --git a/drivers/media/i2c/camera/gc2145/gc2145.c b/drivers/media/i2c/camera/gc2145/gc2145.c
new file mode 100755
index 0000000..445bbb0
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2145/gc2145.c
@@ -0,0 +1,680 @@
+/*
+ * gc2145 Camera Driver
+ *
+ * Copyright (C) 2011 Actions Semiconductor Co.,LTD
+ * Wang Xin <wangxin@actions-semi.com>
+ *
+ * Based on ov227x driver
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0){
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+		}
+		vals++;
+	}
+	return 0;
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret;
+	unsigned int reg_0xfe;
+	struct i2c_adapter *i2c_adap = client->adapter;
+    GC_INFO("");
+    ret = camera_i2c_read(i2c_adap, 0xfe, &reg_0xfe);
+    reg_0xfe |= (0x1 << 7);
+    ret |= camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+    mdelay(1);
+    reg_0xfe &= (~(0x1 << 7));
+    ret |= camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+    return ret;
+}
+#if 0
+/*
+ *softstandby:ͨ\B9\FD\C5\E4\D6üĴ\E6\C6\F7ʹģ\D7\E9\BD\F8\C8\EB\B5͹\A6\BA\C4ģʽ\A3\AC\B4\CB״̬\CF\C2\CA\E4\B3\F6pin\B8\DF\D7衣\BCĴ\E6\C6\F7ֵ\B1\A3\C1\F4\A3\AC\C7ҼĴ\E6\C6\F7\BF\C9д
+ *ͨ\B9\FD\C0\AD\B8\DFpwdn pin\C0\B4\BD\F8\B5͹\A6\BA\C4ģʽʱ\A3\AC\CA\E4\B3\F6pin\B8\DF\D7裬\BCĴ\E6\C6\F7ֵ\B1\A3\C1\F4\B2\BB\B1䣬\B5\AB\BCĴ\E6\C6\F7\B2\BB\BF\C9д\A1\A3
+ */
+static int module_soft_standby(struct i2c_client *client)
+{
+    unsigned int reg_0xfe = 0x00;
+    unsigned int reg_0xf2 = 0x08;
+    int ret = 0;	
+		/*
+    ret = camera_i2c_write(client, 0xfe, &reg_0xfe);
+    ret |= camera_i2c_write(client, 0xf2, &reg_0xf2);
+		*/
+    return ret;
+}
+
+/*
+ *\B4\D3softstandby״̬\BBָ\B4normal״̬
+ */
+static int module_normal(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0xf2 = 0x70;
+	
+	
+	ret = camera_i2c_write(client, 0xfe, &reg_0xfe);
+	ret |= camera_i2c_write(client, 0xf2, &reg_0xf2);
+	*/
+	return ret;
+}
+#endif
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+  int ret = 0;
+  
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+//  struct camera_module_priv *priv = to_camera_priv(client);
+  struct i2c_adapter *i2c_adap = client->adapter;
+  
+  unsigned int reg_0xfe = 0x00;
+  unsigned int reg_0xb6 = 0x01;
+
+  ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+  ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+
+  return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+ int ret = 0;
+ 
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+//  struct camera_module_priv *priv = to_camera_priv(client);
+  struct i2c_adapter *i2c_adap = client->adapter;
+ 
+  unsigned int reg_0xfe = 0x00;
+  unsigned int reg_0xb6 = 0x00;
+
+  ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+  ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+ 
+  return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0x03;
+	unsigned int reg_0x04;
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_read(i2c_adap, 0x03, &reg_0x03);
+	ret |= camera_i2c_read(i2c_adap, 0x04, &reg_0x04);
+		
+	priv->preview_exposure_param.shutter = (reg_0x03 << 8) | reg_0x04;
+	priv->capture_exposure_param.shutter = (priv->preview_exposure_param.shutter)/2;
+	
+	//printk("GC2155 module_save_exposure_param, win->name:%s\n", priv->win->name);
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+ 	int ret = 0;
+  
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned char reg_0x03;
+	unsigned char reg_0x04;
+
+	if(priv->capture_exposure_param.shutter < 1) {
+		priv->capture_exposure_param.shutter = 1;
+	}
+
+	reg_0x03 = ((priv->capture_exposure_param.shutter)>>8) & 0x1F ;
+	reg_0x04 = (priv->capture_exposure_param.shutter) & 0xFF;
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+	ret |= camera_i2c_write(i2c_adap, 0x04, reg_0x04);
+	
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int auto_white_balance;
+	int ret = 0;
+  unsigned int reg_0x82;
+  unsigned int reg_0xfe = 0x00;
+
+	if(ctrl)
+		auto_white_balance = ctrl->val;
+	else
+		auto_white_balance = 1;
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("[gc2155] set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_read(i2c_adap, 0x82, &reg_0x82); 
+
+	switch(auto_white_balance)
+	{
+	case 0:
+		ret = 0;
+		goto change_val;
+		
+	case 1:	
+		ret |=camera_write_array(i2c_adap, module_whitebance_auto_regs);
+		break;
+	}
+	
+	reg_0x82 |= 0x02;
+	ret |= camera_i2c_write(i2c_adap, 0x82, reg_0x82); 
+ 
+change_val:
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		ctrl->cur.val = auto_white_balance;  
+		
+
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+  int white_balance_temperature = ctrl->val;
+  struct i2c_adapter *i2c_adap = client->adapter;
+  unsigned int reg_0x82;
+  unsigned int reg_0xfe = 0x00;
+	int ret = 0;
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_read(i2c_adap, 0x82, &reg_0x82); 
+	 
+	reg_0x82 &= (~0x02);  //\CA\D7\CF\C8disable awb\A3\AC\B7\F1\D4\F2\BCĴ\E6\C6\F7\B2\BB\BF\C9д\A1\A3
+	ret |= camera_i2c_write(i2c_adap, 0x82, reg_0x82);  
+
+	switch(white_balance_temperature)
+	{
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		printk("[gc2145] set white_balance_temperature over range, white_balance_temperature = %d\n", white_balance_temperature);
+		return -ERANGE;	
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+#if 0
+static int module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+  int colorfx = ctrl->val;
+	int ret = 0;
+
+
+	switch (colorfx) {
+	case V4L2_COLORFX_NONE: /* normal */
+		ret = camera_write_array(i2c_adap, module_effect_normal_regs);
+		break;
+	
+	case V4L2_COLORFX_BW: /* black and white */
+		ret = camera_write_array(i2c_adap, module_effect_white_black_regs);
+		break;
+	
+	case V4L2_COLORFX_SEPIA: /* antique ,\B8\B4\B9\C5*/
+		ret = camera_write_array(i2c_adap, module_effect_antique_regs);
+		break;
+
+	case V4L2_COLORFX_NEGATIVE: /* negative\A3\AC\B8\BAƬ */
+		ret = camera_write_array(i2c_adap, module_effect_negative_regs);
+		break;
+
+    default:
+        printk("[gc2145] set colorfx over range, colorfx = %d\n", colorfx);
+        return -ERANGE;	
+    }
+
+    priv->colorfx = colorfx;
+    ctrl->cur.val = colorfx;
+
+    return 0;
+}
+#endif
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    int exposure_auto;
+	int ret = 0;
+
+	if(ctrl)
+		exposure_auto = ctrl->val;
+	else
+		exposure_auto = V4L2_EXPOSURE_AUTO;
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+    case V4L2_EXPOSURE_MANUAL: // non auto
+        ret = 0;
+        break;
+    }
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		ctrl->cur.val = exposure_auto;
+
+    return 0;
+}
+
+static int module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+#if 0
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+  int scene_exposure = ctrl->val;
+	unsigned int reg_0x3a00;
+	
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_HOUSE:  //\CA\D2\C4\DA
+		ret = camera_write_array(i2c_adap, module_scene_night_regs);
+		break;
+	
+	case V4L2_SCENE_MODE_SUNLIGHT:  //\CA\D2\CD\E2
+		ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+    default:
+        printk("[gc2145] set scene_exposure over range, scene_exposure = %d\n", scene_exposure);
+        return -ERANGE;
+    }
+
+    priv->scene_exposure = scene_exposure;
+    ctrl->cur.val = scene_exposure;
+
+	
+#endif
+	return ret;
+}
+
+
+#if 0
+static int module_set_prev_capt_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+    int mode = ctrl->val;
+
+    switch(mode) {
+    case PREVIEW_MODE:
+        priv->prev_capt_mode = mode;
+        break;
+
+    case CAPTURE_MODE:
+        priv->prev_capt_mode = mode;
+        break;
+
+    default:
+        printk("[gc2145] set_prev_capt_mode over range, prev_capt_mode = %d\n", mode);
+        return -ERANGE;
+    }
+    ctrl->cur.val = mode;
+
+    return 0;
+}
+
+
+static int module_pause_af(struct i2c_client *client)
+{
+    int ret = 0;
+
+    return ret;	
+}
+
+static int module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+
+    return 0;
+}
+
+static int module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+    //	struct v4l2_subdev *sd = &priv->subdev;
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+    return 0;
+}
+
+static int module_set_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+    int ret = 0;
+
+    return ret;
+}
+#endif
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	unsigned char reg_0xfe = 0;
+	unsigned char reg_0xf2= 0x0f;
+
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+		   reg_0xf2 = 0x00;
+		   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+		   camera_i2c_write(i2c_adap, 0xf2, reg_0xf2);
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	   reg_0xf2 = 0x0f;
+	   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	   camera_i2c_write(i2c_adap, 0xf2, reg_0xf2);
+	   
+	 return 0;   
+}
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    int ret = 0;
+
+    return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+    //  unsigned int analog_gain = 0;
+    //	unsigned int digital_gain = 0;
+    unsigned int total_gain = 0;
+    //	int ret = 0;
+
+    return total_gain;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+
+    return 0;
+}
+
+static int module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    int ret = 0;
+
+    return ret;
+}
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	struct i2c_adapter *i2c_adap = client->adapter;
+	enum v4l2_mbus_pixelcode code;
+	unsigned char reg_0x84;
+	unsigned char reg_0xfe = 0x00;  //pgae0
+	int ret = 0;
+	
+	code = cfmt->code;
+	
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_0x84 = 0x02;
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		reg_0x84 = 0x00;
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		reg_0x84 = 0x03;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		reg_0x84 = 0x01;
+		break;
+		
+	default:
+		printk("[gc2155] mbus code error in %s() line %d\n",__FUNCTION__, __LINE__);
+		return -1;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_write(i2c_adap, 0x84, reg_0x84);
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	unsigned int reg_0x17 = 0x14;
+    unsigned int reg_0xfe = 0x00;
+    int ret = 0;
+
+    if ((!mirror) && (!flip)) {
+        return 0;
+    }
+
+    ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+
+    if (mirror)	{
+        reg_0x17 |= 0x1;
+    } else {
+        reg_0x17 &= (~0x1);
+    }
+
+    if (flip) {
+        reg_0x17 |= (0x1<<0x1);
+    } else {
+        reg_0x17 &= (~(0x1<<0x1));	
+    }
+
+    ret |= camera_i2c_write(i2c_adap, 0x17, reg_0x17);
+	return ret;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int pidh = 0;
+    unsigned int pidl = 0;
+    int ret;
+
+	
+	GC_INFO("");
+
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PIDH, &pidh); 
+	ret |= camera_i2c_read(i2c_adap, PIDL, &pidl); 
+	switch (VERSION(pidh, pidl)) 
+    {
+	case CAMERA_MODULE_PID:
+/*		if(priv)
+			{
+		     priv->model= V4L2_IDENT_GC2145;
+			}*/
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, VERSION(pidh, pidl));
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, VERSION(pidh, pidl));
+		return -ENODEV;
+	}
+	return ret;
+}
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
diff --git a/drivers/media/i2c/camera/gc2145/module_diff.h b/drivers/media/i2c/camera/gc2145/module_diff.h
new file mode 100755
index 0000000..8da523f
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2145/module_diff.h
@@ -0,0 +1,1263 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME 		"gc2145"
+#define CAMERA_MODULE_PID			0x2145
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_PLATFORM_ID		GC2145_PLATFORM_ID
+#define MODULE_I2C_REAL_ADDRESS		(0x78>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x78>>1)
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+
+#define PIDH					0xf0 /* Product ID Number H byte */
+#define PIDL					0xf1 /* Product ID Number L byte */
+#define OUTTO_SENSO_CLOCK 		24000000
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_HSYNC_ACTIVE_LEVEL		V4L2_MBUS_HSYNC_ACTIVE_HIGH
+#define DEFAULT_PCLK_SAMPLE_EDGE        V4L2_MBUS_PCLK_SAMPLE_RISING
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_SVGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_SVGA
+#define MODULE_MAX_WIDTH		WIDTH_UXGA
+#define MODULE_MAX_HEIGHT		HEIGHT_UXGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		2
+#define DROP_NUM_PREVIEW		5
+
+//static unsigned int frame_rate_vga[]  = {30,};
+static unsigned int frame_rate_svga[] = {30,};
+static unsigned int frame_rate_720p[] = {30,};
+static unsigned int frame_rate_uxga[] = {15,};
+
+/*
+ * register setting for window size 800*600
+ */
+static const struct regval_list module_init_regs[] =
+{
+    	/////////////p sub
+	//////// gain 8.8x
+	/////////a gain 4x
+	/////////d gain 2.2x
+	{0xfe,0xf0},
+	{0xfe,0xf0},
+	{0xfe,0xf0},
+	  
+	{0xfc,0x06},
+	{0xf6,0x00},
+		
+	{0xf7,0x1d}, //37 //17 //37 //1d//05
+	{0xf8,0x84}, //87 //83 //82
+	{0xfa,0x00},
+	{0xf9,0xfe}, //ff
+	{0xfd,0x00},
+	{0xc2,0x00},
+	{0xf2,0x0f},
+	//////////////////////////////////////////////////////
+	////////////////////  Analog & Cisctl ////////////////
+	//////////////////////////////////////////////////////
+	{0xfe,0x00},
+		
+	{0x03,0x04}, //exp time
+	{0x04,0x00}, //exp time
+		
+	{0x05,0x01}, //00 //hb[11:8]
+	{0x06,0x68}, //0b //hb
+		
+	{0x09,0x00}, //row start
+	{0x0a,0x00}, //
+	{0x0b,0x00}, //col start
+	{0x0c,0x00},
+	{0x0d,0x04}, //height
+	{0x0e,0xc0},
+	{0x0f,0x06}, //width
+	{0x10,0x52},
+		
+	{0x12,0x2e}, //sh_delay ̫\B6\CC YUV\B3\F6ͼ\D2쳣
+	{0x17,0x14}, //CISCTL Mode1 [1:0]mirror flip
+	{0x18,0x22}, //sdark mode
+	{0x19,0x0e}, //0f// AD pipe number
+	{0x1a,0x01}, //AD manual switch mode
+	   
+	{0x1b,0x4b}, //48 restg Width,SH width
+	{0x1c,0x07}, //06  ֡\C2ʿ\EC\BA󣬺\E1\CC\F5\CE\C6 //12 //TX Width,Space Width
+	{0x1d,0x10}, //double reset
+	{0x1e,0x88},//90//98 //fix	\CA\FA\CF\DF//Analog Mode1,TX high,Coln_r
+	{0x1f,0x78}, //78 //38 //18 //Analog Mode2,txlow
+	{0x20,0x03}, //07 //Analog Mode3,comv,ad_clk mode
+	{0x21,0x40},//10//20//40 //fix \B5ƹܺ\E1\CC\F5\CE\C6
+	{0x22,0xf0},//d0//f0 //a2 //Vref vpix  FPN\D1\CF\D6\D8
+	{0x24,0x16}, //Pad drv
+	{0x25,0x01}, //col sel
+	{0x26,0x10}, //Analog PGA gain1
+	{0x2d,0x60},//40//40 //txl drv mode
+	{0x30,0x01}, //Analog Mode4 
+	{0x31,0x90},//b0//70 // Analog Mode7 [7:5]rsgh_r\B5ƹܺ\E1\CC\F5\CE\C6[4:3]isp_g
+	{0x33,0x06},//03//02//01 //EQ_hstart_width
+	{0x34,0x01},
+	//
+	///////////////////////////////////////////////////
+	////////////////////  ISP reg  //////////////////////
+	//////////////////////////////////////////////////////
+	{0x80,0x7f},//ff //outdoor gamma_en, GAMMA_en, CC_en, EE_en, INTP_en, DN_en, DD_en,LSC_en
+	{0x81,0x26},//24 //BLK dither mode, ll_y_en ,skin_en, edge SA, new_skin_mode, autogray_en,ll_gamma_en,BFF test image
+	{0x82,0xfa}, //FA //auto_SA, auto_EE, auto_DN, auto_DD, auto_LSC, ABS_en, AWB_en, NA
+	{0x83,0x00}, //special_effect
+	{0x84,0x02}, //output format
+	{0x86,0x03}, //c2 //46 //c2 //sync mode
+	{0x88,0x03}, //[1]ctl_auto_gating [0]out_auto_gating
+	{0x89,0x03}, //bypass disable
+	{0x85,0x04}, //30 //60//frame start cut
+	{0x8a,0x00}, //ISP_quiet_mode,close aaa pclk,BLK gate mode,exception,close first pipe clock,close dndd clock,close intp clock,DIV_gatedclk_en
+	{0x8b,0x00}, //[7:6]BFF_gate_mode,[5]BLK switch gain,[4]protect exp,[3:2]pipe gate mode,[1]not split sram,[0]dark current update
+		
+	{0xb0,0x55},//60 //global gain
+	{0xc3,0x00}, //[7:4]auto_exp_gamma_th1[11:8],[3:0]auto_exp_gamma_th2[11:8]
+	{0xc4,0x80}, //auto_exp_gamma_th1[7:0] into 
+	{0xc5,0x90}, //auto_exp_gamma_th2[7:0] out //outdoor gamma
+	{0xc6,0x3b},//38 //auto_gamma_th1 
+	{0xc7,0x46},//40 //auto_gamma_th2
+		
+	{0xec,0x06},  //measure window
+	{0xed,0x04},
+	{0xee,0x60}, //16  col
+	{0xef,0x90}, //8  row
+		
+	{0xb6,0x01}, //[0]aec en
+		 
+	{0x90,0x01}, //crop
+	{0x91,0x00},
+	{0x92,0x00},
+	{0x93,0x00},
+	{0x94,0x00}, //08
+	{0x95,0x04},
+	{0x96,0xb0},
+	{0x97,0x06},
+	{0x98,0x40},
+	
+	///////////////////////////////////////////////
+	///////////  BLK ////////////////////////
+	///////////////////////////////////////////////
+	{0x40,0x42}, //2b //27
+	{0x41,0x00}, //80 //dark row sel
+	{0x43,0x58}, //54 //[7:4]BLK start not smooth  [3:0]output start frame
+	   
+	{0x5e,0x00},//00//10 //18
+	{0x5f,0x00},//00//10 //18
+	{0x60,0x00},//00//10 //18
+	{0x61,0x00},//00///10 //18
+	{0x62,0x00},//00//10 //18
+	{0x63,0x00},//00//10 //18
+	{0x64,0x00},//00/10 //18
+	{0x65,0x00},//00//10 //18
+	{0x66,0x20},//24//1e
+	{0x67,0x20},//24//1e 
+	{0x68,0x20},//24//1e 
+	{0x69,0x20},//24//1e
+		
+	{0x76,0x00},//0f
+	   
+	{0x6a,0x00},//04//06
+	{0x6b,0x00},//04//06
+	{0x6c,0x3e},//04//06
+	{0x6d,0x3e},//04//06
+	{0x6e,0x3f},//04//06
+	{0x6f,0x3f},//04//06
+	{0x70,0x00},//04//06
+	{0x71,0x00},//04//06 //manual offset
+		
+	{0x76,0x00},//1f//add offset
+	{0x72,0xf0}, //[7:4]BLK DD th [3:0]BLK various th
+	{0x7e,0x3c}, //ndark
+	{0x7f,0x00}, 
+	   
+	{0xfe,0x02},
+	{0x48,0x15},
+	{0x49,0x00},//04//04 //ASDE OFFSET SLOPE 
+	{0x4b,0x0b}, //ASDE y OFFSET SLOPE
+	{0xfe,0x00},
+	
+	///////////////////////////////////////////////
+	/////////// AEC ////////////////////////
+	///////////////////////////////////////////////
+	{0xfe,0x01},
+	   
+	{0x01,0x04}, //AEC X1
+	{0x02,0xc0}, //AEC X2
+	{0x03,0x04}, //AEC Y1
+	{0x04,0x90}, //AEC Y2
+	{0x05,0x30}, //20 //AEC center X1
+	{0x06,0x90}, //40 //AEC center X2
+	{0x07,0x30}, //30 //AEC center Y1
+	{0x08,0x80}, //60 //AEC center Y2
+	{0x09,0x00}, //AEC show mode
+	{0x0a,0x82},//c2 //[7]col gain enable
+	{0x0b,0x11}, //AEC every N
+	{0x0c,0x10}, //AEC_mode3 center weight 
+	{0x11,0x10},//
+	{0x13,0x30},//75//30//2a //AEC Y target
+	{0x17,0x00}, //AEC ignore mode
+	{0x1c,0x11}, //
+	{0x1e,0x61}, //
+	{0x1f,0x35},//30//40//50 //max pre gain
+	{0x20,0x40},//60//40 //max post gain
+	{0x22,0x40},//80 //AEC outdoor THD
+	{0x23,0x20}, //target_Y_low_limit
+	{0xfe,0x02},
+	{0x0f,0x04},//05//04//05  
+	{0xfe,0x01},
+		
+	{0x12,0x35}, //35 //[5:4]group_size [3]slope_disable [2]outdoor_enable [0]histogram_enable
+	{0x15,0xb0}, //target_Y_high_limit
+	{0x10,0x31}, //num_thd_high
+	{0x3e,0x28}, //num_thd_low
+	{0x3f,0xb0}, //luma_thd
+	{0x40,0x90}, //luma_slope
+	{0x41,0x0f}, //color_diff
+	
+	/////////////////////////////
+	//////// INTPEE /////////////
+	/////////////////////////////
+	{0xfe,0x02}, //page2
+	{0x90,0x6c}, //ac //eeintp mode1
+	{0x91,0x03},//02 ////eeintp mode2
+	{0x92,0xcb},//64//c8//44 //low criteria for direction
+	{0x94,0x33},//66
+	{0x95,0x84},//b5
+	{0x97,0x65},//78 ////edge effect
+	{0xa2,0x11}, //fix direction
+	{0xfe,0x00},
+	
+	/////////////////////////////
+	//////// DNDD///////////////
+	/////////////////////////////
+	{0xfe,0x02},
+	{0x80,0xc1}, //c1 //[7]share mode [6]skin mode	[5]is 5x5 mode [1:0]noise value select 0:2	1:2.5  2:3	3:4
+	{0x81,0x08}, //
+	{0x82,0x05},//08 //signal a 0.6
+	{0x83,0x08},//05//04 //signal b 2.5
+		 
+	{0x84,0x0a}, //10 //05 dark_DD_TH
+	{0x86,0xf0}, //a0 Y_value_dd_th2
+	{0x87,0x50}, //90 Y_value_dd_th3
+	{0x88,0x15}, //60 Y_value_dd_th4
+		
+	{0x89,0x50}, //80  // asde th2
+	{0x8a,0x30}, //60  // asde th3
+	{0x8b,0x10}, //30  // asde th4
+	
+	/////////////////////////////////////////////////
+	///////////// ASDE ////////////////////////
+	/////////////////////////////////////////////////
+	{0xfe,0x01}, //page 1
+	{0x21,0x04}, //14//luma_value_div_sel(\B7\D6Ƶ\A3\AC\D3\EB0xef\B3\CA2\B1\B6\B9\D8ϵ\A3\AC\D4\F6\B4\F31\A3\AC0xef\B5\C4ֵ\BC\F5С1\B1\B6)
+	//{0xef  luma_value read_only
+	
+	{0xfe,0x02}, //page2
+	{0xa3,0x50},//40 //ASDE_low_luma_value_LSC_th_H
+	{0xa4,0x20}, //ASDE_low_luma_value_LSC_th_L
+		
+	{0xa5,0x40}, //80 //ASDE_LSC_gain_dec_slope_H
+	{0xa6,0x80}, // 80 //ASDE_LSC_gain_dec_slope_L
+	//{0xa7  ASDE_LSC_gain_dec	//read only
+	
+	{0xab,0x40},//50 //ASDE_low_luma_value_OT_th 
+		
+	{0xae,0x0c}, //[3]EE1_effect_inc_or_dec_high,[2]EE2_effect_inc_or_dec_high,
+				 //[1]EE1_effect_inc_or_dec_low,[0]EE2_effect_inc_or_dec_low,  1:inc  0:dec
+			   
+	{0xb3,0x46},//34//44 //ASDE_EE1_effect_slope_low,ASDE_EE2_effect_slope_low
+	{0xb4,0x64},//44 //12 //ASDE_EE1_effect_slope_high,ASDE_EE2_effect_slope_high
+		 
+	{0xb6,0x38},//40//40 //ASDE_auto_saturation_dec_slope 
+	{0xb7,0x02},//04 //ASDE_sub_saturation_slope
+	{0xb9,0x28},//32 //[7:0]ASDE_auto_saturation_low_limit
+	{0x3c,0x08},//[3:0]auto gray_dec_slope
+	{0x3d,0x20},//30//[7:0]auto gray_dec_th
+		
+	{0x4b,0x08},//0d//y offset slope
+	{0x4c,0x20},//y offset limit
+	{0xfe,0x00},
+	///////////////////gamma1////////////////////
+	////Gamma
+	
+	{0xfe,0x02},
+	{0x10,0x09},//10
+	{0x11,0x0d},//15
+	{0x12,0x13},//1a
+	{0x13,0x19},//1f
+	{0x14,0x27},//2c
+	{0x15,0x37},//39
+	{0x16,0x45},//45
+	{0x17,0x53},//54
+	{0x18,0x69},
+	{0x19,0x7d},
+	{0x1a,0x8f},
+	{0x1b,0x9d},
+	{0x1c,0xa9},
+	{0x1d,0xbd},
+	{0x1e,0xcd},
+	{0x1f,0xd9},
+	{0x20,0xe3},
+	{0x21,0xea},
+	{0x22,0xef},
+	{0x23,0xf5},
+	{0x24,0xf9},
+	{0x25,0xff},
+	
+	//{0xfe,0x02},
+	//{0x10,0x0a},
+	//{0x11,0x12},
+	//{0x12,0x19},
+	//{0x13,0x1f},
+	//{0x14,0x2c},
+	//{0x15,0x38},
+	//{0x16,0x42},
+	//{0x17,0x4e},
+	//{0x18,0x63},
+	//{0x19,0x76},
+	//{0x1a,0x87},
+	//{0x1b,0x96},
+	//{0x1c,0xa2},
+	//{0x1d,0xb8},
+	//{0x1e,0xcb},
+	//{0x1f,0xd8},
+	//{0x20,0xe2},
+	//{0x21,0xe9},
+	//{0x22,0xf0},
+	//{0x23,0xf8},
+	//{0x24,0xfd},
+	//{0x25,0xff},
+	//{0xfe,0x00},
+	{0xc6,0x20},//20//40//auto gammath1
+	{0xc7,0x2b},//2b//50//auto gammath2
+	/////auto gamma dark/////
+	{0xfe,0x02},
+	{0x26,0x0f},
+	{0x27,0x14},
+	{0x28,0x19},
+	{0x29,0x1e},
+	{0x2a,0x27},
+	{0x2b,0x33},
+	{0x2c,0x3b},
+	{0x2d,0x45},
+	{0x2e,0x59},
+	{0x2f,0x69},
+	{0x30,0x7c},
+	{0x31,0x89},
+	{0x32,0x98},
+	{0x33,0xae},
+	{0x34,0xc0},
+	{0x35,0xcf},
+	{0x36,0xda},
+	{0x37,0xe2},
+	{0x38,0xe9},
+	{0x39,0xf3},
+	{0x3a,0xf9},
+	{0x3b,0xff},
+	///////////////////gamma2////////////////////
+	////Gamma outdoor
+	//{0xfe,0x02},
+	//{0x26,0x17},
+	//{0x27,0x18},
+	//{0x28,0x1c},
+	//{0x29,0x20},
+	//{0x2a,0x28},
+	//{0x2b,0x34},
+	//{0x2c,0x40},
+	//{0x2d,0x49},
+	//{0x2e,0x5b},
+	//{0x2f,0x6d},
+	//{0x30,0x7d},
+	//{0x31,0x89},
+	//{0x32,0x97},
+	//{0x33,0xac},
+	//{0x34,0xc0},
+	//{0x35,0xcf},
+	//{0x36,0xda},
+	//{0x37,0xe5},
+	//{0x38,0xec},
+	//{0x39,0xf8},
+	//{0x3a,0xfd},
+	//{0x3b,0xff},
+	
+	/////////////////////////////////////////////// 	 
+	///////////   YCP		///////////////////////  
+	///////////////////////////////////////////////  
+	{0xfe,0x02},
+	{0xd1,0x32}, // 
+	{0xd2,0x32}, //
+	{0xd3,0x40},//45
+	{0xd6,0xf0},
+	{0xd7,0x10},
+	{0xd8,0xda},
+	{0xdd,0x14}, //edge sa
+	{0xde,0x86}, //asde auto gray
+	{0xed,0x81},//01//
+	{0xee,0x3f},//2b//28
+	{0xef,0x3f},//3b//38 
+	{0xd8,0xd8},//autogray protecy
+	///////////////abs////////////
+	{0xfe,0x01},
+	{0x9f,0x40},
+	
+	////////////////////////////
+	//////// LSC  ///////////////
+	////////////////////////////
+	{0xfe,0x01},
+	{0xc2,0x14},
+	{0xc3,0x0d},
+	{0xc4,0x0c},
+	{0xc8,0x15},
+	{0xc9,0x11},
+	{0xca,0x0a},
+	{0xbc,0x24},
+	{0xbd,0x15},
+	{0xbe,0x0b},
+	{0xb6,0x25},
+	{0xb7,0x1b},
+	{0xb8,0x15},
+	{0xc5,0x00},
+	{0xc6,0x00},
+	{0xc7,0x00},
+	{0xcb,0x00},
+	{0xcc,0x00},
+	{0xcd,0x00},
+	{0xbf,0x07},
+	{0xc0,0x00},
+	{0xc1,0x00},
+	{0xb9,0x00},
+	{0xba,0x00},
+	{0xbb,0x00},
+	{0xaa,0x01},
+	{0xab,0x01},
+	{0xac,0x00},
+	{0xad,0x05},
+	{0xae,0x06},
+	{0xaf,0x0e},
+	{0xb0,0x0b},
+	{0xb1,0x07},
+	{0xb2,0x06},
+	{0xb3,0x17},
+	{0xb4,0x0e},
+	{0xb5,0x0e},
+	{0xd0,0x09},
+	{0xd1,0x00},
+	{0xd2,0x00},
+	{0xd6,0x08},
+	{0xd7,0x00},
+	{0xd8,0x00},
+	{0xd9,0x00},
+	{0xda,0x00},
+	{0xdb,0x00},
+	{0xd3,0x0a},
+	{0xd4,0x00},
+	{0xd5,0x00},
+	{0xa4,0x00},
+	{0xa5,0x00},
+	{0xa6,0x77},
+	{0xa7,0x77},
+	{0xa8,0x77},
+	{0xa9,0x77},
+	{0xa1,0x80},
+	{0xa2,0x80},
+		
+	{0xfe,0x01},
+	{0xdf,0x0d},//01//0c
+	{0xdc,0x25},//80
+	{0xdd,0x50},//30
+	{0xe0,0x77},
+	{0xe1,0x80},
+	{0xe2,0x77},
+	{0xe3,0x90},
+	{0xe6,0x90},
+	{0xe7,0xa0},
+	{0xe8,0x90},
+	{0xe9,0xa0},
+	   
+	{0xfe,0x00},
+	
+	/////////////////////////////////////////////////
+	/////////////	 AWB	 ////////////////////////
+	/////////////////////////////////////////////////
+	{0xfe,0x01},
+	{0x4f,0x00},
+	{0x4f,0x00},
+	{0x4b,0x01},
+	{0x4f,0x00},
+								 
+	{0x4c,0x01}, // D75
+	{0x4d,0x71},
+	{0x4e,0x01},
+	{0x4c,0x01},
+	{0x4d,0x91},
+	{0x4e,0x01},
+	{0x4c,0x01},
+	{0x4d,0x70},
+	{0x4e,0x01},
+		
+	{0x4c,0x01}, // D65
+	{0x4d,0x90},
+	{0x4e,0x02},									
+									
+	{0x4c,0x01},
+	{0x4d,0xb0},
+	{0x4e,0x02},
+	{0x4c,0x01},
+	{0x4d,0x8f},
+	{0x4e,0x02},
+	{0x4c,0x01},
+	{0x4d,0x6f},
+	{0x4e,0x02},
+	{0x4c,0x01},
+	{0x4d,0xaf},
+	{0x4e,0x02},
+		 
+	{0x4c,0x01},
+	{0x4d,0xd0},
+	{0x4e,0x02},
+	{0x4c,0x01},
+	{0x4d,0xf0},
+	{0x4e,0x02},
+	{0x4c,0x01},
+	{0x4d,0xcf},
+	{0x4e,0x02},
+	{0x4c,0x01},
+	{0x4d,0xef},
+	{0x4e,0x02},
+	   
+	{0x4c,0x01},//D50
+	{0x4d,0x6e},
+	{0x4e,0x03},
+	{0x4c,0x01}, 
+	{0x4d,0x8e},
+	{0x4e,0x03},
+	{0x4c,0x01},
+	{0x4d,0xae},
+	{0x4e,0x03},//03
+	{0x4c,0x01},
+	{0x4d,0xce},
+	{0x4e,0x03},//03
+	//{0x4c,0x01},
+	//{0x4d,0xcf},
+	//{0x4e,0x03},//03
+	{0x4c,0x01},
+	{0x4d,0xee},
+	{0x4e,0x03},//03
+		 
+	{0x4c,0x01},
+	{0x4d,0x6d},
+	{0x4e,0x03},
+	{0x4c,0x01},
+	{0x4d,0x8d},
+	{0x4e,0x03},
+	{0x4c,0x01},
+	{0x4d,0xad},
+	{0x4e,0x03},//03
+	{0x4c,0x01},
+	{0x4d,0xcd},
+	{0x4e,0x03},//03
+	{0x4c,0x01},
+	{0x4d,0xed},
+	{0x4e,0x03},//03
+	   
+	{0x4c,0x01},
+	{0x4d,0x6c},
+	{0x4e,0x03},
+	//{0x4c,0x01},
+	//{0x4d,0xed},
+	//{0x4e,0x03},//skin
+	{0x4c,0x01},
+	{0x4d,0x8c},
+	{0x4e,0x03},
+	{0x4c,0x01},
+	{0x4d,0xac},
+	{0x4e,0x03},//03
+	{0x4c,0x01},
+	{0x4d,0xcc},
+	{0x4e,0x03},//03
+	{0x4c,0x01},
+	{0x4d,0xec},
+	{0x4e,0x03},//05	//03/////////////////////////////
+	{0x4c,0x01},
+	{0x4d,0x6b},
+	{0x4e,0x03},
+	{0x4c,0x01},
+	{0x4d,0x8b},
+	{0x4e,0x03},//skin
+	//{0x4c,0x01},
+	//{0x4d,0xab},
+	//{0x4e,0x03},
+	//{0x4c,0x01},
+	//{0x4d,0xcb},
+	//{0x4e,0x03},
+	//{0x4c,0x01},
+	//{0x4d,0xeb},
+	//{0x4e,0x03},
+	{0x4c,0x01},
+	{0x4d,0x8a},
+	{0x4e,0x03},
+	
+	
+	//{0x4c,0x02},
+	//{0x4d,0x2b},
+	//{0x4e,0x03},
+	//{0x4c,0x02},
+	//{0x4d,0x4b},
+	//{0x4e,0x03},
+	
+	{0x4c,0x01}, // CWF
+	{0x4d,0xaa},
+	{0x4e,0x04},
+	{0x4c,0x01}, // CWF
+	{0x4d,0xab},
+	{0x4e,0x04},
+	{0x4c,0x01}, // CWF
+	{0x4d,0xcb},
+	{0x4e,0x04},
+	{0x4c,0x01}, // CWF
+	{0x4d,0xa9},
+	{0x4e,0x04},
+								  
+	{0x4c,0x01},
+	{0x4d,0xca},
+	{0x4e,0x04},
+	{0x4c,0x01},
+	{0x4d,0xc9},
+	{0x4e,0x04},
+	{0x4c,0x01},
+	{0x4d,0x8a},
+	{0x4e,0x04},
+	{0x4c,0x01},
+	{0x4d,0x89},
+	{0x4e,0x04},
+	   
+	{0x4c,0x01}, // TL84
+	{0x4d,0xeb},
+	{0x4e,0x05},
+	{0x4c,0x02},
+	{0x4d,0x0b},
+	{0x4e,0x05},
+	{0x4c,0x02},
+	{0x4d,0x0c},
+	{0x4e,0x05},
+	{0x4c,0x02},
+	{0x4d,0x2c},
+	{0x4e,0x05},
+	{0x4c,0x02},
+	{0x4d,0x2b},
+	{0x4e,0x05},
+	{0x4c,0x01},
+	{0x4d,0xea},
+	{0x4e,0x05},	//05/////////////////////////
+	{0x4c,0x02},
+	{0x4d,0x0a},/////////wtoffice
+	{0x4e,0x05},   
+		
+	{0x4c,0x02},
+	{0x4d,0x8b},
+	{0x4e,0x06},
+	{0x4c,0x02},
+	{0x4d,0x2a},
+	{0x4e,0x06},
+	{0x4c,0x02},
+	{0x4d,0x4a},
+	{0x4e,0x06},
+	{0x4c,0x02},
+	{0x4d,0x6a},
+	{0x4e,0x06},
+	{0x4c,0x02},
+	{0x4d,0x8a},
+	{0x4e,0x06},
+	{0x4c,0x02},
+	{0x4d,0xaa},
+	{0x4e,0x06},
+	{0x4c,0x02},
+	{0x4d,0x09},
+	{0x4e,0x06},
+	{0x4c,0x02},
+	{0x4d,0x29},
+	{0x4e,0x06},
+	{0x4c,0x02},
+	{0x4d,0x49},
+	{0x4e,0x06},
+	{0x4c,0x02},
+	{0x4d,0x69},
+	{0x4e,0x06},
+	 {0x4c,0x02}, // H
+	{0x4d,0xcc},
+	{0x4e,0x07},
+	{0x4c,0x02},
+	{0x4d,0xca},
+	{0x4e,0x07},
+	{0x4c,0x02},
+	{0x4d,0xa9},
+	{0x4e,0x07},
+	{0x4c,0x02},
+	{0x4d,0xc9},
+	{0x4e,0x07},
+	{0x4c,0x02},
+	{0x4d,0xe9},
+	{0x4e,0x07},
+		
+	{0x4f,0x01}, 
+	{0x4f,0x01},
+	{0x50,0x80}, //AWB_PRE_mode
+	{0x51,0xa8}, //AWB_pre_THD_min[7:0]
+	{0x52,0x47},//57 //AWB_pre_THD_min[15:8] Dominiate luma 0.25=639c 0.22=57a8
+	{0x53,0x38}, //AWB_pre_THD_min_MIX[7:0]
+	{0x54,0xc7}, //AWB_pre_THD_min_MIX[15:8] Mix luma 0.5
+		 
+	{0x56,0x0e}, //AWB_tone mode
+	{0x58,0x08}, //AWB_C_num_sel,AWB_D_num_sel
+	{0x5b,0x00}, //AWB_mix_mode 
+		
+	{0x5c,0x74}, //green_num0[7:0]
+	{0x5d,0x8b}, //green_num0[15:8] 0.35
+		
+	{0x61,0xdb},//a8 //R2G_stand0	OUT BA c0
+	{0x62,0xb8},//b8 //B2G_stand0		B6	c2
+	{0x63,0x86},//aa//00//88//a4 //AWB gray mode [7]enable
+	{0x64,0xc0},//80
+	{0x65,0x04}, //AWB margin
+		
+	{0x67,0xa8}, //R2G_stand3[7:0]	FF/CWF
+	{0x68,0xb0}, //B2G_stand3[7:0]
+	{0x69,0x00}, //R2G_stand4[9:8] B2G_stand4[9:8] R2G_stand3[9:8] B2G_stand3[9:8]
+	{0x6a,0xa8}, //R2G_stand4[7:0]	TL84/TL84&CWF
+	{0x6b,0xb0}, //B2G_stand4[7:0]
+	{0x6c,0xaf}, //R2G_stand5[7:0]	A
+	{0x6d,0x8b}, //B2G_stand5[7:0]
+	{0x6e,0x50}, //AWB_skin_weight R2G_stand5[9:8] B2G_stand5[9:8]
+	{0x6f,0x18}, //AWB_indoor_THD (0x21=17 caculate)
+	{0x73,0xf0},//e0//0f //AWB_indoor_mode
+	   
+	{0x70,0x0d},//10 //AWB low luma TH
+	{0x71,0x68},//e8 //AWB outdoor TH
+	{0x72,0x81},//c1//c0 //outdoor mode
+	{0x74,0x01}, //[2:0]AWB skip mode 2x2,4x4,4x8,8x8
+	{0x75,0x01}, //[1:0]AWB_every_N
+	{0x7f,0x0c},//08 //[3]gray world frame start
+		 
+	{0x76,0x70}, //R limit
+	{0x77,0x58}, //G limit
+	{0x78,0xa0}, //d8 //B limit
+	{0x79,0x5e},//53
+	{0x7a,0x54},
+	{0x7b,0x55},
+		
+	{0xfe,0x00},
+	//
+	//////////////////////////////////////////
+	///////////  CC   ////////////////////////
+	//////////////////////////////////////////
+	{0xfe,0x02},
+	{0xc0,0x01}, //[5:4] CC mode [0]CCT enable
+	   
+	{0xC1,0x48},//44//50 //D50/D65
+	{0xc2,0xF8},//F4
+	{0xc3,0x04},//02 //0
+	{0xc4,0xF0},//f2//e8 //e0
+	{0xc5,0x4B},//44//48
+	{0xc6,0xFD},//f8//f0
+	   
+	   
+	{0xC7,0x50},
+	{0xc8,0xf2},
+	{0xc9,0x00},
+	{0xcA,0xE0},
+	{0xcB,0x45},
+	{0xcC,0xec},
+		
+	{0xCd,0x48},//45
+	{0xce,0xf0},
+	{0xcf,0xf0},//00
+	{0xe3,0x0c},
+	{0xe4,0x4b},
+	{0xe5,0xe0},
+		  
+	{0xfe,0x00},
+		
+	{0xf2,0x0f},
+	
+	
+	//////////////frame rate   50Hz
+	{0xfe,0x00},
+	{0xf7,0x1d},
+	{0xf8,0x84},
+	   
+	{0x03,0x04},
+	{0x04,0xe2},
+	{0x05,0x01},//hb
+	{0x06,0x56},
+	{0x07,0x00},//Vb
+	{0x08,0x14},
+		
+	{0xfe,0x01},
+		
+	{0x25,0x00},
+	{0x26,0xfa}, //step
+	{0x27,0x05}, //20fps
+	{0x28,0xdc},
+	{0x29,0x07}, //16.7fps
+	{0x2a,0xd0},
+	{0x2b,0x0b},//07 //12.5fps
+	{0x2c,0xb8},//d0
+	{0x2d,0x0b}, //night mode 8.3fps
+	{0x2e,0xb8},
+	{0xfe,0x00},
+	
+	
+	/////////dark  sun//////  
+	{0xfe,0x02},
+	{0x40,0xbf},
+	{0x46,0xcf},
+	{0xfe,0x00},
+		ENDMARKER,
+};
+
+/* 800*600: SVGA*/
+static const struct regval_list module_svga_regs[] = {
+    {0xfe , 0x00},
+    {0xfa , 0x00},
+    {0xfd , 0x01}, 
+    //// crop window              
+    {0xfe , 0x00},
+    {0x99 , 0x11},  
+    {0x9a , 0x06},
+    {0x9b , 0x00},
+    {0x9c , 0x00},
+    {0x9d , 0x00},
+    {0x9e , 0x00},
+    {0x9f , 0x00},
+    {0xa0 , 0x00},  
+    {0xa1 , 0x00},
+    {0xa2  ,0x00},
+    {0x90 , 0x01}, 
+    {0x91 , 0x00},
+    {0x92 , 0x00},
+    {0x93 , 0x00},
+    {0x94 , 0x00},
+    {0x95 , 0x02},
+    {0x96 , 0x58},
+    {0x97 , 0x03},
+    {0x98 , 0x20},
+
+    //// AWB                      
+    {0xfe , 0x00},
+    {0xec , 0x01}, 
+    {0xed , 0x02},
+    {0xee , 0x30},
+    {0xef , 0x48},
+    {0xfe , 0x01},
+    {0x74 , 0x00}, 
+    //// AEC                      
+    {0xfe , 0x01},
+    {0x01 , 0x04},
+    {0x02 , 0x60},
+    {0x03 , 0x02},
+    {0x04 , 0x48},
+    {0x05 , 0x18},
+    {0x06 , 0x4c},
+    {0x07 , 0x14},
+    {0x08 , 0x36},
+    {0x0a , 0xc0}, 
+    {0x21 , 0x14},
+    {0xfe , 0x00},
+	ENDMARKER,
+};
+#if 0
+/* 640*480: VGA*/
+static const struct regval_list module_vga_regs[] = {
+	ENDMARKER,
+};
+#endif
+
+/* 1280*720: 720P*/
+static const struct regval_list module_720p_regs[] = {
+	{0xfe , 0x00},
+	//{0xfa , 0x11},
+	{0xb6 , 0x01},
+	{0xfd , 0x00},
+	//// crop window
+	{0xfe , 0x00},
+	{0x99 , 0x55},	
+	{0x9a , 0x06},
+	{0x9b , 0x00},
+	{0x9c , 0x00},
+	{0x9d , 0x01},
+	{0x9e , 0x23},
+	{0x9f , 0x00},
+	{0xa0 , 0x00},	
+	{0xa1 , 0x01},
+	{0xa2  ,0x23},
+	
+	{0x90 , 0x01},
+	{0x91 , 0x00},
+	{0x92 , 0x78},
+	{0x93 , 0x00},
+	{0x94 , 0x00},
+	{0x95 , 0x02},
+	{0x96 , 0xd0},	
+	{0x97 , 0x05},
+	{0x98 , 0x00},
+
+    //// AWB   
+    {0xfe , 0x00},
+    {0xec , 0x02},
+    {0xed , 0x04},
+    {0xee , 0x60},
+    {0xef , 0x90},
+    {0xfe , 0x01},
+    {0x74 , 0x01},
+    //// AEC	  
+    {0xfe , 0x01},
+    {0x01 , 0x08},
+    {0x02 , 0xc0},
+    {0x03 , 0x04},
+    {0x04 , 0x90},
+    {0x05 , 0x30},
+    {0x06 , 0x98},
+    {0x07 , 0x28},
+    {0x08 , 0x6c},
+    {0x0a , 0xc2}, 
+    {0x21 , 0x15}, //if 0xfa=11,then 0x21=15;else if 0xfa=00,then 0x21=14
+    {0xfe , 0x00},
+	ENDMARKER,
+};
+
+/* 1600*1200 UXGA */
+static const struct regval_list module_uxga_regs[] = {
+   {0xfe , 0x00},
+    {0xfa , 0x11},
+    {0xfd , 0x00},
+    //// crop window
+    {0xfe , 0x00},
+    {0x99 , 0x11},  
+    {0x9a , 0x06},
+    {0x9b , 0x00},
+    {0x9c , 0x00},
+    {0x9d , 0x00},
+    {0x9e , 0x00},
+    {0x9f , 0x00},
+    {0xa0 , 0x00},  
+    {0xa1 , 0x00},
+    {0xa2  ,0x00},
+    
+    {0x90 , 0x01},
+    {0x91 , 0x00},
+    {0x92 , 0x00},
+    {0x93 , 0x00},
+    {0x94 , 0x00},
+    {0x95 , 0x04},
+    {0x96 , 0xb0},
+    {0x97 , 0x06},
+    {0x98 , 0x40},
+
+    //// AWB   
+    {0xfe , 0x00},
+    {0xec , 0x02},
+    {0xed , 0x04},
+    {0xee , 0x60},
+    {0xef , 0x90},
+    {0xfe , 0x01},
+    {0x74 , 0x01},
+    //// AEC	  
+    {0xfe , 0x01},
+    {0x01 , 0x08},
+    {0x02 , 0xc0},
+    {0x03 , 0x04},
+    {0x04 , 0x90},
+    {0x05 , 0x30},
+    {0x06 , 0x98},
+    {0x07 , 0x28},
+    {0x08 , 0x6c},
+    {0x0a , 0xc2}, 
+    {0x21 , 0x15}, //if 0xfa=11,then 0x21=15;else if 0xfa=00,then 0x21=14
+    {0xfe , 0x00},
+  ENDMARKER,
+};
+
+static const struct regval_list module_init_auto_focus[] = {
+    //  NULL
+	ENDMARKER,
+};
+/*
+ * window size list
+ */
+
+#if 0
+/* 640X480 */
+static struct camera_module_win_size module_win_vga = {
+    .name             = "VGA",
+    .width            = WIDTH_VGA,
+    .height           = HEIGHT_VGA,
+    .win_regs         = module_vga_regs,
+    .frame_rate_array = frame_rate_vga,
+};
+#endif
+/* 800X600 */
+static struct camera_module_win_size module_win_svga = {
+    .name             = "SVGA",
+    .width            = WIDTH_SVGA,
+    .height           = HEIGHT_SVGA,
+    .win_regs         = module_svga_regs,
+
+    .frame_rate_array = frame_rate_svga,
+    .capture_only     = 0,
+};
+
+/* 1280X720 */
+static struct camera_module_win_size module_win_720p = {
+    .name             = "720P",
+    .width            = WIDTH_720P,
+    .height           = HEIGHT_720P,
+    .win_regs         = module_720p_regs,
+    .frame_rate_array = frame_rate_720p,
+    .capture_only     = 0,
+};
+
+/* 1600X1200 */
+static struct camera_module_win_size module_win_uxga = {
+    .name             = "UXGA",
+    .width            = WIDTH_UXGA,
+    .height           = HEIGHT_UXGA,
+    .win_regs         = module_uxga_regs,
+    .frame_rate_array = frame_rate_uxga,
+    .capture_only     = 1,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+    //&module_win_vga,
+    &module_win_svga,
+    &module_win_720p,
+    &module_win_uxga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+    {0xfe, 0x00},
+    {0xb3, 0x61},
+    {0xb4, 0x40}, 
+    {0xb5, 0x61},
+    {0x82, 0xfe},
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+
+    {0xfe, 0x00},
+    {0x82, 0xfc},
+    {0xb3, 0x58},
+    {0xb4, 0x40}, 
+    {0xb5, 0x50},
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+    {0xfe, 0x00},
+    {0x82, 0xfc},
+    {0xb3, 0x70},
+    {0xb4, 0x40}, 
+    {0xb5, 0x50},	
+	ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+
+    {0xfe, 0x00},
+    {0x82, 0xfc},
+    {0xb3, 0x72},
+    {0xb4, 0x40}, 
+    {0xb5, 0x5b},
+	ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+    {0xfe, 0x00},
+    {0x82, 0xfc},
+    {0xb3, 0x50},
+    {0xb4, 0x40},
+    {0xb5, 0xa8}, 
+	ENDMARKER,
+};
+#if 0
+/*\D5\FD\B3\A3ģʽ*/
+static struct regval_list module_effect_normal_regs[] =
+{
+    {0xfe, 0x00},
+    {0x83, 0xe0},
+	ENDMARKER,
+};
+
+/*\B5\A5ɫ\A3\AC\BAڰ\D7\D5\D5Ƭ*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+    {0xfe, 0x00},
+    {0x83, 0x12},
+	ENDMARKER,
+};
+
+/*\B8\BAƬЧ\B9\FB*/
+static struct regval_list module_effect_negative_regs[] =
+{
+    //Negative
+    {0xfe, 0x00},
+    {0x83, 0x01},
+	ENDMARKER,
+};
+/*\B8\B4\B9\C5Ч\B9\FB*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+    {0xfe, 0x00},
+    {0x83, 0x82},
+	ENDMARKER,
+};
+#endif
+static struct regval_list module_scene_auto_regs[] =
+{
+    {0xfe, 0x01},
+    {0x3c, 0x40},
+    {0xfe, 0x00},
+	ENDMARKER,
+};
+#if 0
+static struct regval_list module_scene_night_regs[] =
+{
+    {0xfe, 0x01},
+    {0x3c, 0x60},
+    {0xfe, 0x00},
+	ENDMARKER,
+};
+#endif
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+#if 0
+    {	.id = V4L2_CID_GAIN, 
+        .min = 256,
+        .max = 0XFFFF,
+        .step = 1,
+        .def = 2560,},
+    {	.id = V4L2_CID_AF_MODE,   //\B4\CB\CF\EE\D0\E8\D6\C3\D3\DA\CA\FD\D7\E9ͷ\B2\BF
+        .min = NONE_AF, 
+        .max = CONTINUE_AF|SINGLE_AF, 
+        .step = 1, 
+        .def = CONTINUE_AF|SINGLE_AF,},
+#endif
+	{	.id = V4L2_CID_GAIN, 
+			.min = 10, 
+			.max = 2048, 
+			.step = 1, 
+			.def = 30,},
+    {	.id = V4L2_CID_AUTO_WHITE_BALANCE, 
+        .min = 0,
+        .max = 1, 
+        .step = 1, 
+        .def = 1,},
+    {	.id = V4L2_CID_WHITE_BALANCE_TEMPERATURE, 
+        .min = 0, 
+        .max = 3, 
+        .step = 1, 
+        .def = 1,},
+       	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+//    {	.id = V4L2_CID_SCENE_EXPOSURE, 
+//        .min = 0, 
+//        .max = 1, 
+//        .step = 1, 
+//        .def = 0,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+//    {	.id = V4L2_CID_PRIVATE_PREV_CAPT, 
+//        .min = 0, 
+//        .max = 1, 
+//        .step = 1, 
+//        .def = PREVIEW_MODE,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+#if 0
+    {	.id = V4L2_CID_AF_STATUS, 
+        .min = AF_STATUS_DISABLE, 
+        .max = AF_STATUS_FAIL, 
+        .step = 1, 
+        .def = AF_STATUS_DISABLE,},
+    {	.id = V4L2_CID_FLASH_STROBE, 
+        .min = 0, 
+        .max = 1, 
+        .step = 1, 
+        .def = 0,},
+    {	.id = V4L2_CID_FLASH_STROBE_STOP, 
+        .min = 0, 
+        .max = 1, 
+        .step = 1, 
+        .def = 0,},
+#endif
+	{	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+    {	.id = V4L2_CID_COLORFX, 
+        .max = 3, 
+        .mask = 0x0, 
+        .def = 0,},
+    {	.id = V4L2_CID_EXPOSURE_AUTO, 
+        .max = 1, 
+        .mask = 0x0, 
+        .def = 1,},
+    {  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_TEXT, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+#if 1
+    {	.id = V4L2_CID_FLASH_LED_MODE, 
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,},
+#endif
+		{
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/gc2155/Kconfig b/drivers/media/i2c/camera/gc2155/Kconfig
new file mode 100755
index 0000000..6f13c6d
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2155/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config GC2155
+	tristate "gc2155 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for gc2155 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc2155.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc2155/Makefile b/drivers/media/i2c/camera/gc2155/Makefile
new file mode 100755
index 0000000..2f9e3f3
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2155/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_GC2155)	+= gc2155.o
+
diff --git a/drivers/media/i2c/camera/gc2155/gc2155.c b/drivers/media/i2c/camera/gc2155/gc2155.c
new file mode 100755
index 0000000..63a77f8
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2155/gc2155.c
@@ -0,0 +1,672 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0){
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+		}
+		vals++;
+	}
+	return 0;
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+	struct i2c_adapter *i2c_adap = client->adapter;
+	unsigned int reg_0xfe;
+    int ret;
+
+    GC_INFO("");
+    ret = camera_i2c_read(i2c_adap, 0xfe, &reg_0xfe);
+    reg_0xfe |= (0x1 << 7);
+    ret |= camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+    mdelay(1);
+    reg_0xfe &= (~(0x1 << 7));
+    ret |= camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+    return ret;
+}
+#if 0
+/*
+*softstandby:ͨ\B9\FD\C5\E4\D6üĴ\E6\C6\F7ʹģ\D7\E9\BD\F8\C8\EB\B5͹\A6\BA\C4ģʽ\A3\AC\B4\CB״̬\CF\C2\CA\E4\B3\F6pin\B8\DF\D7衣\BCĴ\E6\C6\F7ֵ\B1\A3\C1\F4\A3\AC\C7ҼĴ\E6\C6\F7\BF\C9д
+*ͨ\B9\FD\C0\AD\B8\DFpwdn pin\C0\B4\BD\F8\B5͹\A6\BA\C4ģʽʱ\A3\AC\CA\E4\B3\F6pin\B8\DF\D7裬\BCĴ\E6\C6\F7ֵ\B1\A3\C1\F4\B2\BB\B1䣬\B5\AB\BCĴ\E6\C6\F7\B2\BB\BF\C9д\A1\A3
+*/
+static int module_soft_standby(struct i2c_client *client)
+{
+	
+	return 0;
+}
+
+static int module_normal(struct v4l2_subdev *sd)
+{
+	// struct i2c_client *client = v4l2_get_subdevdata(sd);
+	// struct i2c_adapter *i2c_adap = client->adapter;
+	return 0;
+}
+#endif
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0xb6 = 0x01;
+	unsigned int reg_0x03;
+	unsigned int reg_0x04;
+	
+	//priv->preview_exposure_param.shutter = (priv->preview_exposure_param.shutter)*4;
+	reg_0x03 = ((priv->preview_exposure_param.shutter)>>8) & 0xFF ;
+	reg_0x04 = (priv->preview_exposure_param.shutter) & 0xFF;
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+	ret |= camera_i2c_write(i2c_adap, 0x04, reg_0x04);
+
+	ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+	*/
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0xb6 = 0x00;
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+	
+	//printk("GC2155 module_freeze_aec, win->name:%s \n", priv->win->name);
+	*/
+	return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0x03;
+	unsigned int reg_0x04;
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_read(i2c_adap, 0x03, &reg_0x03);
+	ret |= camera_i2c_read(i2c_adap, 0x04, &reg_0x04);
+		
+	priv->preview_exposure_param.shutter = (reg_0x03 << 8) | reg_0x04;
+	priv->capture_exposure_param.shutter = (priv->preview_exposure_param.shutter)/2;
+	
+	//printk("GC2155 module_save_exposure_param, win->name:%s\n", priv->win->name);
+	*/
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	struct camera_module_priv *priv = to_camera_priv(client);
+	unsigned int reg_0xfe = 0x00;
+  	unsigned char reg_0x03;
+  	unsigned char reg_0x04;
+
+	if(0 == strcmp("UXGA", priv->win->name))
+	{
+		if(priv->capture_exposure_param.shutter < 1) {
+			priv->capture_exposure_param.shutter = 1;
+		}
+		
+		reg_0x03 = ((priv->capture_exposure_param.shutter)>>8) & 0xFF ;
+		reg_0x04 = (priv->capture_exposure_param.shutter) & 0xFF;
+    }	
+	else
+	{
+		if(priv->preview_exposure_param.shutter < 1) {
+			priv->preview_exposure_param.shutter = 1;
+		}
+		
+		reg_0x03 = ((priv->preview_exposure_param.shutter)>>8) & 0xFF ;
+		reg_0x04 = (priv->preview_exposure_param.shutter) & 0xFF;
+	}
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+	ret |= camera_i2c_write(i2c_adap, 0x04, reg_0x04);
+
+	//printk("GC2155 module_set_exposure_param, win->name:%s\n", priv->win->name);
+	*/
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int auto_white_balance;
+	int ret = 0;
+  	unsigned int reg_0x82;
+  	unsigned int reg_0xfe = 0x00;
+	if(ctrl)
+		auto_white_balance = ctrl->val;
+	else
+		auto_white_balance = 1;
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("[gc2155] set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_read(i2c_adap, 0x82, &reg_0x82); 
+
+	switch(auto_white_balance)
+	{
+	case 0:
+		ret = 0;
+		goto change_val;
+		
+	case 1:	
+		ret |=camera_write_array(i2c_adap, module_whitebance_auto_regs);
+		break;
+	}
+	
+	reg_0x82 |= 0x02;
+	ret |= camera_i2c_write(i2c_adap, 0x82, reg_0x82); 
+ 
+change_val:
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		ctrl->cur.val = auto_white_balance;  
+		
+
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	struct camera_module_priv *priv = to_camera_priv(client);
+  int white_balance_temperature = ctrl->val;
+	int ret = 0;
+	unsigned int reg_0x82;
+	unsigned int reg_0xfe = 0x00;
+
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_read(i2c_adap, 0x82, &reg_0x82); 
+	 
+	reg_0x82 &= (~0x02);  //\CA\D7\CF\C8disable awb\A3\AC\B7\F1\D4\F2\BCĴ\E6\C6\F7\B2\BB\BF\C9д\A1\A3
+	ret |= camera_i2c_write(i2c_adap, 0x82, reg_0x82);  
+
+	switch(white_balance_temperature)
+	{
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		printk("[gc2155] set white_balance_temperature over range, white_balance_temperature = %d\n", white_balance_temperature);
+		return -ERANGE;	
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+#if 0
+static int module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+  int colorfx = ctrl->val;
+	int ret = 0;
+
+	switch (colorfx) {
+	case V4L2_COLORFX_NONE: /* normal */
+		ret = camera_write_array(i2c_adap, module_effect_normal_regs);
+		break;
+	
+	case V4L2_COLORFX_BW: /* black and white */
+		ret = camera_write_array(i2c_adap, module_effect_white_black_regs);
+		break;
+	
+	case V4L2_COLORFX_SEPIA: /* antique ,\B8\B4\B9\C5*/
+		ret = camera_write_array(i2c_adap, module_effect_antique_regs);
+		break;
+
+	case V4L2_COLORFX_NEGATIVE: /* negative\A3\AC\B8\BAƬ */
+		ret = camera_write_array(i2c_adap, module_effect_negative_regs);
+		break;
+
+	default:
+		printk("[gc2155] set colorfx over range, colorfx = %d\n", colorfx);
+		return -ERANGE;	
+	}
+
+	priv->colorfx = colorfx;
+	ctrl->cur.val = colorfx;
+
+	return 0;
+}
+#endif 
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int exposure_auto;
+	int ret = 0;
+
+	if(ctrl)
+		exposure_auto = ctrl->val;
+	else
+		exposure_auto = V4L2_EXPOSURE_AUTO;
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		printk("[gc2155] set exposure_auto over range, exposure_auto = %d\n", exposure_auto);
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		ctrl->cur.val = exposure_auto;
+
+	return 0;
+}
+
+static int module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+#if 0	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int scene_exposure = ctrl->val;
+	unsigned int reg_0x3a00;
+	
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_HOUSE:  //\CA\D2\C4\DA
+		ret = camera_write_array(i2c_adap, module_scene_night_regs);
+		break;
+	
+	case V4L2_SCENE_MODE_SUNLIGHT:  //\CA\D2\CD\E2
+		ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	default:
+		printk("[gc2155] set scene_exposure over range, scene_exposure = %d\n", scene_exposure);
+		return -ERANGE;
+	}
+
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+
+#endif
+	return ret;
+}
+
+
+#if 0
+static int module_set_prev_capt_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int mode = ctrl->val;
+
+	switch(mode) {
+	case PREVIEW_MODE:
+		priv->prev_capt_mode = mode;
+		break;
+
+	case CAPTURE_MODE:
+        priv->prev_capt_mode = mode;
+		break;
+	
+	default:
+		printk("[gc2155] set_prev_capt_mode over range, prev_capt_mode = %d\n", mode);
+		return -ERANGE;
+	}
+	ctrl->cur.val = mode;
+	return 0;
+}
+
+
+static int module_pause_af(struct i2c_client *client)
+{	
+	int ret = 0;
+	
+	return ret;	
+}
+
+static int module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = &priv->subdev;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_set_exposure(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+
+	return ret;
+}
+#endif
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	unsigned char reg_0xfe = 0;
+	unsigned char reg_0xf2= 0x0f;
+
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+		   reg_0xf2 = 0x08;
+		   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+		   camera_i2c_write(i2c_adap, 0xf2, reg_0xf2);
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	   reg_0xf2 = 0x0f;
+	   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	   camera_i2c_write(i2c_adap, 0xf2, reg_0xf2);
+	return 0;
+}
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	unsigned int digital_gain = 0;
+	unsigned int total_gain = 0;
+//	int ret = 0;
+
+	
+	return total_gain;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+
+	return 0;
+}
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	struct i2c_adapter *i2c_adap = client->adapter;
+	enum v4l2_mbus_pixelcode code;
+	unsigned char reg_0x84;
+	unsigned char reg_0xfe = 0x00;  //pgae0
+	int ret = 0;
+	
+	code = cfmt->code;
+	
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_0x84 = 0x02;
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		reg_0x84 = 0x00;
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		reg_0x84 = 0x03;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		reg_0x84 = 0x01;
+		break;
+		
+	default:
+		printk("[gc2155] mbus code error in %s() line %d\n",__FUNCTION__, __LINE__);
+		return -1;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_write(i2c_adap, 0x84, reg_0x84);
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip){
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+
+	unsigned int reg_0x17 = 0x14;
+	unsigned int reg_0xfe = 0x00;
+	int ret = 0;
+	
+	if ((!mirror) && (!flip)) {
+		return 0;
+	}
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+ 
+	if (mirror)	{
+		reg_0x17 |= 0x1;
+	} else {
+		reg_0x17 &= (~0x1);
+	}
+	
+	if (flip) {
+		reg_0x17 |= (0x1<<0x1);
+	} else {
+		reg_0x17 &= (~(0x1<<0x1));	
+	}
+	
+	ret |= camera_i2c_write(i2c_adap, 0x17, reg_0x17);
+   
+	
+	return ret;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int   pidh = 0;
+	unsigned int		pidl = 0;
+	unsigned int	  PID = 0;
+	int ret = 0;
+	camera_i2c_write(i2c_adap,0xfe,0x00);
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PIDH, &pidh); 
+	ret |= camera_i2c_read(i2c_adap, PIDL, &pidl); 
+	PID = pidh<<8 | pidl;
+	switch (PID) 
+  {
+		case 0x2155:
+	/*		if(priv){  
+				priv->model = V4L2_IDENT_GC2155;
+			}*/
+			printk("[%s] Product ID verified 0x%x\n",CAMERA_MODULE_NAME, PID);
+			break;
+	
+		default:
+			printk("[%s] Product ID error 0x%x\n", CAMERA_MODULE_NAME,PID);
+			return -ENODEV;
+	}
+	return ret;
+}
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gc2155/module_diff.h b/drivers/media/i2c/camera/gc2155/module_diff.h
new file mode 100755
index 0000000..bf4585e
--- /dev/null
+++ b/drivers/media/i2c/camera/gc2155/module_diff.h
@@ -0,0 +1,1178 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME 		"gc2155"
+#define CAMERA_MODULE_PID			0x2155
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_PLATFORM_ID		GC2155_PLATFORM_ID
+#define MODULE_I2C_REAL_ADDRESS		(0x78>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x78>>1)
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+
+#define IS_FRONT_OR_REAR        0
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING 
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+#if 0
+#define PID						XXX /* Product ID Number */
+#else
+#define PIDH					0xf0 /* Product ID Number H byte */
+#define PIDL					0xf1 /* Product ID Number L byte */
+#endif
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_SVGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_SVGA
+#define MODULE_MAX_WIDTH		WIDTH_UXGA
+#define MODULE_MAX_HEIGHT		HEIGHT_UXGA
+
+#define AHEAD_LINE_NUM			15    //10ÐÐ = 50´ÎÑ­»·
+#define DROP_NUM_CAPTURE		2
+#define DROP_NUM_PREVIEW		3
+
+static unsigned int frame_rate_svga[] = {30,};
+static unsigned int frame_rate_720p[] = {30,};
+static unsigned int frame_rate_uxga[] = {15,};
+
+static const struct regval_list module_init_regs[] =
+{
+	{0xfe , 0xf0},
+	{0xfe , 0xf0},
+	{0xfe , 0xf0},
+	{0xfc , 0x06},
+	{0xf6 , 0x00},
+	{0xf7 , 0x1d},
+	{0xf8 , 0x84},
+	{0xfa , 0x00},
+	{0xf9 , 0xfe},
+	{0xf2 , 0x00},
+	/////////////////////////////////////////////////
+	//////////////////ISP reg//////////////////////
+	////////////////////////////////////////////////////
+	{0xfe , 0x00},
+	{0x03 , 0x04},
+	{0x04 , 0xe2},
+	{0x09 , 0x00},
+	{0x0a , 0x00},
+	{0x0b , 0x00},
+	{0x0c , 0x00},
+	{0x0d , 0x04},
+	{0x0e , 0xc0},
+	{0x0f , 0x06},
+	{0x10 , 0x50},
+	{0x12 , 0x2e},
+	{0x17 , 0x14}, // mirror
+	{0x18 , 0x02},
+	{0x19 , 0x0e},
+	{0x1a , 0x01},
+	{0x1b , 0x4b},
+	{0x1c , 0x07},
+	{0x1d , 0x10},
+	{0x1e , 0x98},
+	{0x1f , 0x78},
+	{0x20 , 0x05},
+	{0x21 , 0x40},
+	{0x22 , 0xf0},
+	{0x24 , 0x16},
+	{0x25 , 0x01},
+	{0x26 , 0x10},
+	{0x2d , 0x40},
+	{0x30 , 0x01},
+	{0x31 , 0x90},
+	{0x33 , 0x04},
+	{0x34 , 0x01},
+	/////////////////////////////////////////////////
+	//////////////////ISP reg////////////////////
+	/////////////////////////////////////////////////
+	{0xfe , 0x00},
+	{0x80 , 0xff},
+	{0x81 , 0x2c},
+	{0x82 , 0xfa},
+	{0x83 , 0x00},
+	{0x84 , 0x02}, //yuv 01
+	{0x85 , 0x08},
+	{0x86 , 0x03},
+	{0x89 , 0x03},
+	{0x8a , 0x00},
+	{0x8b , 0x00},
+	{0xb0 , 0x55},
+	{0xc3 , 0x11}, //00
+	{0xc4 , 0x20},
+	{0xc5 , 0x30},
+	{0xc6 , 0x38},
+	{0xc7 , 0x40},
+	{0xec , 0x02},
+	{0xed , 0x04},
+	{0xee , 0x60},
+	{0xef , 0x90},
+	{0xb6 , 0x01},
+	{0x90 , 0x01},
+	{0x91 , 0x00},
+	{0x92 , 0x00},
+	{0x93 , 0x00},
+	{0x94 , 0x00},
+	{0x95 , 0x04},
+	{0x96 , 0xb0},
+	{0x97 , 0x06},
+	{0x98 , 0x40},
+	/////////////////////////////////////////
+	/////////// BLK ////////////////////////
+	/////////////////////////////////////////
+	{0xfe , 0x00},
+	{0x18 , 0x02},
+	{0x40 , 0x42},
+	{0x41 , 0x00},
+	{0x43 , 0x5b},//0x54
+	{0x5e , 0x00},
+	{0x5f , 0x00},
+	{0x60 , 0x00},
+	{0x61 , 0x00},
+	{0x62 , 0x00},
+	{0x63 , 0x00},
+	{0x64 , 0x00},
+	{0x65 , 0x00},
+	{0x66 , 0x20},
+	{0x67 , 0x20},
+	{0x68 , 0x20},
+	{0x69 , 0x20},
+	{0x6a , 0x08},
+	{0x6b , 0x08},
+	{0x6c , 0x08},
+	{0x6d , 0x08},
+	{0x6e , 0x08},
+	{0x6f , 0x08},
+	{0x70 , 0x08},
+	{0x71 , 0x08},
+	{0x72 , 0xf0},
+	{0x7e , 0x3c},
+	{0x7f , 0x00},
+	{0xfe , 0x00},
+	////////////////////////////////////////
+	/////////// AEC ////////////////////////
+	////////////////////////////////////////
+	{0xfe , 0x01},
+	{0x01 , 0x08},
+	{0x02 , 0xc0},
+	{0x03 , 0x04},
+	{0x04 , 0x90},
+	{0x05 , 0x30},
+	{0x06 , 0x98},
+	{0x07 , 0x28},
+	{0x08 , 0x6c},
+	{0x09 , 0x00},
+	{0x0a , 0xc2},
+	{0x0b , 0x11},
+	{0x0c , 0x10},
+	{0x13 , 0x2d},
+	{0x17 , 0x00},
+	{0x1c , 0x11},
+	{0x1e , 0x61},
+	{0x1f , 0x30},
+	{0x20 , 0x40},
+	{0x22 , 0x80},
+	{0x23 , 0x20},
+
+	{0x12 , 0x35},
+	{0x15 , 0x50},
+	{0x10 , 0x31},
+	{0x3e , 0x28},
+	{0x3f , 0xe0},
+	{0x40 , 0xe0},
+	{0x41 , 0x08},
+
+	{0xfe , 0x02},
+	{0x0f , 0x05},
+	/////////////////////////////
+	//////// INTPEE /////////////
+	/////////////////////////////
+	{0xfe , 0x02},
+	{0x90 , 0x6c},
+	{0x91 , 0x03},
+	{0x92 , 0xc4},
+	{0x97 , 0x64},
+	{0x98 , 0x88},
+	{0x9d , 0x08},
+	{0xa2 , 0x11},
+	{0xfe , 0x00},
+	/////////////////////////////
+	//////// DNDD///////////////
+	/////////////////////////////
+	{0xfe , 0x02},
+	{0x80 , 0xc1},
+	{0x81 , 0x08},
+	{0x82 , 0x05},
+	{0x83 , 0x04},
+	{0x84 , 0x0a},
+	{0x86 , 0x80},
+	{0x87 , 0x30},
+	{0x88 , 0x15},
+	{0x89 , 0x80},
+	{0x8a , 0x60},
+	{0x8b , 0x30},
+	/////////////////////////////////////////
+	/////////// ASDE ////////////////////////
+	/////////////////////////////////////////
+	{0xfe , 0x01},
+	{0x21 , 0x14},
+	{0xfe , 0x02},
+	{0x3c , 0x06},
+	{0x3d , 0x40},
+	{0x48 , 0x30},
+	{0x49 , 0x06},
+	{0x4b , 0x08},
+	{0x4c , 0x20},
+	{0xa3 , 0x50},
+	{0xa4 , 0x30},
+	{0xa5 , 0x40},
+	{0xa6 , 0x80},
+	{0xab , 0x40},
+	{0xae , 0x0c},
+	{0xb3 , 0x42},
+	{0xb4 , 0x24},
+	{0xb6 , 0x50},
+	{0xb7 , 0x01},
+	{0xb9 , 0x28}, 
+	{0xfe , 0x00},	 
+	///////////////////gamma1////////////////////
+	{0xfe , 0x02},
+	{0x10 , 0x0d},
+	{0x11 , 0x12},
+	{0x12 , 0x17},
+	{0x13 , 0x1c},
+	{0x14 , 0x27},
+	{0x15 , 0x34},
+	{0x16 , 0x44},
+	{0x17 , 0x55},
+	{0x18 , 0x6e},
+	{0x19 , 0x81},
+	{0x1a , 0x91},
+	{0x1b , 0x9c},
+	{0x1c , 0xaa},
+	{0x1d , 0xbb},
+	{0x1e , 0xca},
+	{0x1f , 0xd5},
+	{0x20 , 0xe0},
+	{0x21 , 0xe7},
+	{0x22 , 0xed},
+	{0x23 , 0xf6},
+	{0x24 , 0xfb},
+	{0x25 , 0xff},
+	///////////////////gamma2////////////////////
+	{0xfe , 0x02},
+	{0x26 , 0x0d},
+	{0x27 , 0x12},
+	{0x28 , 0x17},
+	{0x29 , 0x1c},
+	{0x2a , 0x27},
+	{0x2b , 0x34},
+	{0x2c , 0x44},
+	{0x2d , 0x55},
+	{0x2e , 0x6e},
+	{0x2f , 0x81},
+	{0x30 , 0x91},
+	{0x31 , 0x9c},
+	{0x32 , 0xaa},
+	{0x33 , 0xbb},
+	{0x34 , 0xca},
+	{0x35 , 0xd5},
+	{0x36 , 0xe0},
+	{0x37 , 0xe7},
+	{0x38 , 0xed},
+	{0x39 , 0xf6},
+	{0x3a , 0xfb},
+	{0x3b , 0xff},
+	/////////////////////////////////////////////// 
+	///////////YCP /////////////////////// 
+	/////////////////////////////////////////////// 
+	{0xfe , 0x02},
+	{0xd1 , 0x28},
+	{0xd2 , 0x28},
+	{0xdd , 0x14},
+	{0xde , 0x88},
+	{0xed , 0x80},
+	////////////////////////////
+	//////// LSC ///////////////
+	////////////////////////////
+	{0xfe , 0x01},
+	{0xc2 , 0x1f},
+	{0xc3 , 0x13},
+	{0xc4 , 0x0e},
+	{0xc8 , 0x16},
+	{0xc9 , 0x0f},
+	{0xca , 0x0c},
+	{0xbc , 0x52},
+	{0xbd , 0x2c},
+	{0xbe , 0x27},
+	{0xb6 , 0x47},
+	{0xb7 , 0x32},
+	{0xb8 , 0x30},
+	{0xc5 , 0x00},
+	{0xc6 , 0x00},
+	{0xc7 , 0x00},
+	{0xcb , 0x00},
+	{0xcc , 0x00},
+	{0xcd , 0x00},
+	{0xbf , 0x0e},
+	{0xc0 , 0x00},
+	{0xc1 , 0x00},
+	{0xb9 , 0x08},
+	{0xba , 0x00},
+	{0xbb , 0x00},
+	{0xaa , 0x0a},
+	{0xab , 0x0c},
+	{0xac , 0x0d},
+	{0xad , 0x02},
+	{0xae , 0x06},
+	{0xaf , 0x05},
+	{0xb0 , 0x00},
+	{0xb1 , 0x05},
+	{0xb2 , 0x02},
+	{0xb3 , 0x04},
+	{0xb4 , 0x04},
+	{0xb5 , 0x05},
+	{0xd0 , 0x00},
+	{0xd1 , 0x00},
+	{0xd2 , 0x00},
+	{0xd6 , 0x02},
+	{0xd7 , 0x00},
+	{0xd8 , 0x00},
+	{0xd9 , 0x00},
+	{0xda , 0x00},
+	{0xdb , 0x00},
+	{0xd3 , 0x00},
+	{0xd4 , 0x00},
+	{0xd5 , 0x00},
+	{0xa4 , 0x04},
+	{0xa5 , 0x00},
+	{0xa6 , 0x77},
+	{0xa7 , 0x77},
+	{0xa8 , 0x77},
+	{0xa9 , 0x77},
+	{0xa1 , 0x80},
+	{0xa2 , 0x80},
+
+	{0xfe , 0x01},
+	{0xdc , 0x35},
+	{0xdd , 0x28},
+	{0xdf , 0x0d},
+	{0xe0 , 0x70},
+	{0xe1 , 0x78},
+	{0xe2 , 0x70},
+	{0xe3 , 0x78},
+	{0xe6 , 0x90},
+	{0xe7 , 0x70},
+	{0xe8 , 0x90},
+	{0xe9 , 0x70},
+	{0xfe , 0x00},
+	///////////////////////////////////////////////
+	/////////// AWB////////////////////////
+	///////////////////////////////////////////////
+	{0xfe , 0x01},
+	{0x4f , 0x00},
+	{0x4f , 0x00},
+	{0x4b , 0x01},
+	{0x4f , 0x00},
+	{0x4c , 0x01},
+	{0x4d , 0x71},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0x91},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0x50},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0x70},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0x90},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0xb0},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0xd0},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0x4f},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0x6f},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0x8f},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0xaf},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0xcf},
+	{0x4e , 0x02},
+	{0x4c , 0x01},
+	{0x4d , 0x6e},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x8e},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0xae},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0xce},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x4d},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x6d},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x8d},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0xad},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0xcd},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x4c},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x6c},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x8c},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0xac},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0xcc},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0xec},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x4b},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x6b},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x8b},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0xab},
+	{0x4e , 0x03},
+	{0x4c , 0x01},
+	{0x4d , 0x8a},
+	{0x4e , 0x04},
+	{0x4c , 0x01},
+	{0x4d , 0xaa},
+	{0x4e , 0x04},
+	{0x4c , 0x01},
+	{0x4d , 0xca},
+	{0x4e , 0x04},
+	{0x4c , 0x01},
+	{0x4d , 0xa9},
+	{0x4e , 0x04},
+	{0x4c , 0x01},
+	{0x4d , 0xc9},
+	{0x4e , 0x04},
+	{0x4c , 0x01},
+	{0x4d , 0xcb},
+	{0x4e , 0x05},
+	{0x4c , 0x01},
+	{0x4d , 0xeb},
+	{0x4e , 0x05},
+	{0x4c , 0x02},
+	{0x4d , 0x0b},
+	{0x4e , 0x05},
+	{0x4c , 0x02},
+	{0x4d , 0x2b},
+	{0x4e , 0x05},
+	{0x4c , 0x02},
+	{0x4d , 0x4b},
+	{0x4e , 0x05},
+	{0x4c , 0x01},
+	{0x4d , 0xea},
+	{0x4e , 0x05},
+	{0x4c , 0x02},
+	{0x4d , 0x0a},
+	{0x4e , 0x05},
+	{0x4c , 0x02},
+	{0x4d , 0x2a},
+	{0x4e , 0x05},
+	{0x4c , 0x02},
+	{0x4d , 0x6a},
+	{0x4e , 0x06},
+	{0x4c , 0x02},
+	{0x4d , 0x29},
+	{0x4e , 0x06},
+	{0x4c , 0x02},
+	{0x4d , 0x49},
+	{0x4e , 0x06},
+	{0x4c , 0x02},
+	{0x4d , 0x69},
+	{0x4e , 0x06},
+	{0x4c , 0x02},
+	{0x4d , 0x89},
+	{0x4e , 0x06},
+	{0x4c , 0x02},
+	{0x4d , 0xa9},
+	{0x4e , 0x06},
+	{0x4c , 0x02},
+	{0x4d , 0xc9},
+	{0x4e , 0x06},
+	{0x4c , 0x02},
+	{0x4d , 0x48},
+	{0x4e , 0x06},
+	{0x4c , 0x02},
+	{0x4d , 0x68},
+	{0x4e , 0x06},
+	{0x4c , 0x03},
+	{0x4d , 0x09},
+	{0x4e , 0x07},
+	{0x4c , 0x02},
+	{0x4d , 0xa8},
+	{0x4e , 0x07},
+	{0x4c , 0x02},
+	{0x4d , 0xc8},
+	{0x4e , 0x07},
+	{0x4c , 0x02},
+	{0x4d , 0xe8},
+	{0x4e , 0x07},
+	{0x4c , 0x03},
+	{0x4d , 0x08},
+	{0x4e , 0x07},
+	{0x4c , 0x03},
+	{0x4d , 0x28},
+	{0x4e , 0x07},
+	{0x4c , 0x02},
+	{0x4d , 0x87},
+	{0x4e , 0x07},
+	{0x4c , 0x02},
+	{0x4d , 0xa7},
+	{0x4e , 0x07},
+	{0x4c , 0x02},
+	{0x4d , 0xc7},
+	{0x4e , 0x07},
+	{0x4c , 0x02},
+	{0x4d , 0xe7},
+	{0x4e , 0x07},
+	{0x4c , 0x03},
+	{0x4d , 0x07},
+	{0x4e , 0x07},
+	{0x4f , 0x01},
+	{0xfe , 0x01},
+
+	{0x50 , 0x80},
+	{0x51 , 0xa8},
+	{0x52 , 0x57},
+	{0x53 , 0x38},
+	{0x54 , 0xc7},
+	{0x56 , 0x0e},
+	{0x58 , 0x08},
+	{0x5b , 0x00},
+	{0x5c , 0x74},
+	{0x5d , 0x8b},
+	{0x61 , 0xd3},
+	{0x62 , 0x90},
+	{0x63 , 0xaa},
+	{0x65 , 0x04},
+	{0x67 , 0xb2},
+	{0x68 , 0xac},
+	{0x69 , 0x00},
+	{0x6a , 0xb2},
+	{0x6b , 0xac},
+	{0x6c , 0xdc},
+	{0x6d , 0xb0},
+	{0x6e , 0x30},
+	{0x6f , 0x40},
+	{0x70 , 0x05},
+	{0x71 , 0x80},
+	{0x72 , 0x80},
+	{0x73 , 0x30},
+	{0x74 , 0x01},
+	{0x75 , 0x01},
+	{0x7f , 0x08},
+	{0x76 , 0x70},
+	{0x77 , 0x48},
+	{0x78 , 0xa0},
+	{0xfe , 0x00},
+
+	//////////////////////////////////////////
+	///////////CC////////////////////////
+	//////////////////////////////////////////
+	{0xfe , 0x02},
+	{0xc0 , 0x01},
+	{0xc1 , 0x4a},
+	{0xc2 , 0xf3},
+	{0xc3 , 0xfc},
+	{0xc4 , 0xe4},
+	{0xc5 , 0x48},
+	{0xc6 , 0xec},
+	{0xc7 , 0x45},
+	{0xc8 , 0xf8},
+	{0xc9 , 0x02},
+	{0xca , 0xfe},
+	{0xcb , 0x42},
+	{0xcc , 0x00},
+	{0xcd , 0x45},
+	{0xce , 0xf0},
+	{0xcf , 0x00},
+	{0xe3 , 0xf0},
+	{0xe4 , 0x45},
+	{0xe5 , 0xe8}, 
+	//////////////////////////////////////////
+	///////////ABS ////////////////////
+	//////////////////////////////////////////
+	{0xfe , 0x01},
+	{0x9f , 0x42},
+	{0xfe , 0x00}, 
+
+	//////////////frame rate 50Hz/////////
+#if 1
+	{0xfe , 0x00},
+	{0x05 , 0x01},
+	{0x06 , 0x56},
+	{0x07 , 0x00},
+	{0x08 , 0x32},
+	{0xfe , 0x01},
+	{0x25 , 0x00},
+	{0x26 , 0xfa}, 
+	#if 1//min frame rate is 10fps
+	{0x27 , 0x04}, 
+	{0x28 , 0xe2}, //20fps 
+	{0x29 , 0x04}, 
+	{0x2a , 0xe2}, //16fps 
+	{0x2b , 0x04}, 
+	{0x2c , 0xe2}, //10fps
+	{0x2d , 0x04}, 
+	{0x2e , 0xe2}, //8fps
+	#else//min Frame rate is 12fps
+	{0x27 , 0x04}, 
+	{0x28 , 0xe2}, //20fps 
+	{0x29 , 0x06}, 
+	{0x2a , 0xd6}, //16fps 
+	{0x2b , 0x07}, 
+	{0x2c , 0xd0}, //12fps
+	{0x2d , 0x0b}, 
+	{0x2e , 0xb8}, //8fps
+	#endif
+	{0xfe , 0x00},
+#else
+    //min Frame rate is less than 8 fps
+	//////////////frame rate   50Hz
+	{0xfe , 0x00},
+	{0x05 , 0x02},
+	{0x06 , 0x2d},
+	{0x07 , 0x00},
+	{0x08 , 0xa0},
+	{0xfe , 0x01},
+	{0x25 , 0x00},
+	{0x26 , 0xd4},
+	{0x27 , 0x04},
+	{0x28 , 0xf8},
+	{0x29 , 0x08},
+	{0x2a , 0x48},
+	{0x2b , 0x0a},
+	{0x2c , 0xc4},
+	{0x2d , 0x0f},
+	{0x2e , 0xbc},
+	{0xfe , 0x00},
+
+#endif
+	///////GC2155_Sensor_SVGA////
+	{0xfe , 0x00},
+	{0xfa , 0x00},
+	{0xfd , 0x01}, 
+		//// crop window			  
+	{0xfe , 0x00},
+	{0x90 , 0x01}, 
+	{0x91 , 0x00},
+	{0x92 , 0x00},
+	{0x93 , 0x00},
+	{0x94 , 0x00},
+	{0x95 , 0x02},
+	{0x96 , 0x58},
+	{0x97 , 0x03},
+	{0x98 , 0x20},
+	{0x99 , 0x11},
+	{0x9a , 0x06},
+		//// AWB					  
+	{0xfe , 0x00},
+	{0xec , 0x01}, 
+	{0xed , 0x02},
+	{0xee , 0x30},
+	{0xef , 0x48},
+	{0xfe , 0x01},
+	{0x74 , 0x00}, 
+		//// AEC					  
+	{0xfe , 0x01},
+	{0x01 , 0x04},
+	{0x02 , 0x60},
+	{0x03 , 0x02},
+	{0x04 , 0x48},
+	{0x05 , 0x18},
+	{0x06 , 0x4c},
+	{0x07 , 0x14},
+	{0x08 , 0x36},
+	{0x0a , 0xc0}, 
+	{0x21 , 0x14}, 
+	{0xfe , 0x00},
+		//// gamma
+	{0xfe , 0x00},
+	{0xc3 , 0x11},
+	{0xc4 , 0x20},
+	{0xc5 , 0x30},
+	{0xfe , 0x00},
+	////////svga setting end//////
+
+
+	//////////////////////////////////////////
+	///////////OUTPUT ////////////////////
+	//////////////////////////////////////////
+	{0xfe , 0x00},
+	{0xf2 , 0x0f},
+	ENDMARKER,
+};
+
+
+/* 800*600: SVGA*/
+static const struct regval_list module_svga_regs[] = {
+	{0xfe , 0x00},
+	{0xfa , 0x00},
+	{0xfd , 0x01}, 
+	{0xb6 , 0x01},	
+	
+	{0xfe , 0x00},
+	{0x99 , 0x11},	
+	{0x9a , 0x06},
+	{0x9b , 0x00},
+	{0x9c , 0x00},
+	{0x9d , 0x00},
+	{0x9e , 0x00},
+	{0x9f , 0x00},
+	{0xa0 , 0x00},	
+	{0xa1 , 0x00},
+	{0xa2  ,0x00},	
+	//// crop window              
+	{0xfe , 0x00},
+	{0x90 , 0x01}, 
+	{0x91 , 0x00},
+	{0x92 , 0x00},
+	{0x93 , 0x00},
+	{0x94 , 0x00},
+	{0x95 , 0x02},
+	{0x96 , 0x58},
+	{0x97 , 0x03},
+	{0x98 , 0x20},
+	{0x99 , 0x11},
+	{0x9a , 0x06},
+	//// AWB                      
+	{0xfe , 0x00},
+	{0xec , 0x01}, 
+	{0xed , 0x02},
+	{0xee , 0x30},
+	{0xef , 0x48},
+	{0xfe , 0x01},
+	{0x74 , 0x00}, 
+	//// AEC                      
+	{0xfe , 0x01},
+	{0x01 , 0x04},
+	{0x02 , 0x60},
+	{0x03 , 0x02},
+	{0x04 , 0x48},
+	{0x05 , 0x18},
+	{0x06 , 0x4c},
+	{0x07 , 0x14},
+	{0x08 , 0x36},
+	{0x0a , 0xc0}, 
+	{0x21 , 0x14}, 
+	{0xfe , 0x00},
+	//// gamma
+	{0xfe , 0x00},
+	{0xc3 , 0x11},
+	{0xc4 , 0x20},
+	{0xc5 , 0x30},
+	{0xfe , 0x00},
+	ENDMARKER,
+};
+
+/* 1280*720: 720P*/
+static const struct regval_list module_720p_regs[] = {
+	{0xfe , 0x00},
+	{0xfa , 0x11},
+	{0xb6 , 0x01},
+	{0xfd , 0x00},
+	//// crop window
+	
+	{0xfe , 0x00},
+	{0x99 , 0x55},	
+	{0x9a , 0x06},
+	{0x9b , 0x00},
+	{0x9c , 0x00},
+	{0x9d , 0x01},
+	{0x9e , 0x23},
+	{0x9f , 0x00},
+	{0xa0 , 0x00},	
+	{0xa1 , 0x01},
+	{0xa2  ,0x23},
+
+	{0x90 , 0x01},
+	{0x91 , 0x00},
+	{0x92 , 0x78},
+	{0x93 , 0x00},
+	{0x94 , 0x00},
+	{0x95 , 0x02},
+	{0x96 , 0xd0},  
+	{0x97 , 0x05},
+	{0x98 , 0x00},
+
+	
+	//// AWB   
+	{0xfe , 0x00},
+	{0xec , 0x02},
+	{0xed , 0x04},
+	{0xee , 0x60},
+	{0xef , 0x90},
+	{0xfe , 0x01},
+	{0x74 , 0x01},
+	//// AEC	  
+	{0xfe , 0x01},
+	{0x01 , 0x08},
+	{0x02 , 0xc0},
+	{0x03 , 0x04},
+	{0x04 , 0x90},
+	{0x05 , 0x30},
+	{0x06 , 0x98},
+	{0x07 , 0x28},
+	{0x08 , 0x6c},
+	{0x0a , 0xc2}, 
+	{0x21 , 0x15}, 
+	{0xfe , 0x00},
+	//// gamma
+	{0xfe , 0x00},
+	{0xc3 , 0x11},
+	{0xc4 , 0x20},
+	{0xc5 , 0x30},
+	{0xfe , 0x00},
+	ENDMARKER,
+};
+
+/* 1600*1200 UXGA */
+static const struct regval_list module_uxga_regs[] = {
+	{0xfe , 0x00},
+	{0xfa , 0x00},
+	{0xfd , 0x00},
+	
+	{0xfe , 0x00},
+	{0x99 , 0x11},	
+	{0x9a , 0x06},
+	{0x9b , 0x00},
+	{0x9c , 0x00},
+	{0x9d , 0x00},
+	{0x9e , 0x00},
+	{0x9f , 0x00},
+	{0xa0 , 0x00},	
+	{0xa1 , 0x00},
+	{0xa2  ,0x00},	
+	//// crop window
+	{0xfe , 0x00},
+	{0x90 , 0x01},
+	{0x91 , 0x00},
+	{0x92 , 0x00},
+	{0x93 , 0x00},
+	{0x94 , 0x00},
+	{0x95 , 0x04},
+	{0x96 , 0xb0},
+	{0x97 , 0x06},
+	{0x98 , 0x40},
+	{0x99 , 0x11}, 
+	{0x9a , 0x06},
+	//// AWB   
+	{0xfe , 0x00},
+	{0xec , 0x02},
+	{0xed , 0x04},
+	{0xee , 0x60},
+	{0xef , 0x90},
+	{0xfe , 0x01},
+	{0x74 , 0x01},
+	//// AEC	  
+	{0xfe , 0x01},
+	{0x01 , 0x08},
+	{0x02 , 0xc0},
+	{0x03 , 0x04},
+	{0x04 , 0x90},
+	{0x05 , 0x30},
+	{0x06 , 0x98},
+	{0x07 , 0x28},
+	{0x08 , 0x6c},
+	{0x0a , 0xc2}, 
+	{0x21 , 0x15}, //if 0xfa=11,then 0x21=15;else if 0xfa=00,then 0x21=14
+	{0xfe , 0x00},
+	//// gamma
+	{0xfe , 0x00},
+	{0xc3 , 0x00}, //if shutter/2 when capture,then exp_gamma_th/2
+	{0xc4 , 0x90},
+	{0xc5 , 0x98},
+	{0xfe , 0x00},
+	ENDMARKER,
+};
+
+static const struct regval_list module_init_auto_focus[] =
+{
+	ENDMARKER,
+//  NULL
+};
+
+/*
+ * window size list
+ */
+  
+
+/* 800X600 */
+static struct camera_module_win_size module_win_svga = {
+	.name             = "SVGA",
+	.width            = WIDTH_SVGA,
+	.height           = HEIGHT_SVGA,
+	.win_regs         = module_svga_regs,
+
+	.frame_rate_array = frame_rate_svga,
+	.capture_only     = 0,
+};
+
+/* 1280*720 */
+static struct camera_module_win_size module_win_720p = {
+	.name             = "720P",
+	.width            = WIDTH_720P,
+	.height           = HEIGHT_720P,
+	.win_regs         = module_720p_regs,
+	.frame_rate_array = frame_rate_720p,
+	.capture_only     = 0,
+};
+/* 1600*1200 */
+static struct camera_module_win_size module_win_uxga = {
+	.name             = "UXGA",
+	.width            = WIDTH_UXGA,
+	.height           = HEIGHT_UXGA,
+	.win_regs         = module_uxga_regs,
+	.frame_rate_array = frame_rate_uxga,
+	.capture_only     = 1,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+  &module_win_svga,
+	&module_win_720p,
+	&module_win_uxga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+	{0xfe, 0x00},
+	{0xb3, 0x61},
+	{0xb4, 0x40},
+	{0xb5, 0x61},
+	{0x82, 0xfe},
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	{0xfe, 0x00},
+	{0x82, 0xfc},
+	{0xb3, 0xa0},
+	{0xb4, 0x45},
+	{0xb5, 0x40},	
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+	{0xfe, 0x00},
+	{0x82, 0xfc},
+	{0xb3, 0x70},
+	{0xb4, 0x40},
+	{0xb5, 0x50},
+	ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,Ó«¹âµÆ */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+	{0xfe, 0x00},
+	{0x82, 0xfc},
+	{0xb3, 0x58},
+	{0xb4, 0x40},
+	{0xb5, 0x70},
+	ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K £¬°×³ãµÆ */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	{0xfe, 0x00},
+	{0x82, 0xfc},
+	{0xb3, 0x50},
+	{0xb4, 0x40},
+	{0xb5, 0xa8},
+	ENDMARKER,
+};
+#if 0
+/*正常模式*/
+static struct regval_list module_effect_normal_regs[] =
+{
+	{0xfe, 0x00},
+	{0x83, 0xe0},
+	ENDMARKER,
+};
+
+/*µ¥É«£¬ºÚ°×ÕÕÆ¬*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+  {0xfe, 0x00},
+	{0x83, 0x12},
+	ENDMARKER,
+};
+
+/*¸ºÆ¬Ð§¹û*/
+static struct regval_list module_effect_negative_regs[] =
+{
+  //Negative
+  {0xfe, 0x00},
+	{0x83, 0x01},
+		ENDMARKER,
+};
+/*¸´¹ÅÐ§¹û*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+  {0xfe, 0x00},
+	{0x83, 0x82},
+	ENDMARKER,
+};
+#endif
+static struct regval_list module_scene_auto_regs[] =
+{
+	{0xfe,0x01},
+	{0x3c,0x40},	
+	{0xfe,0x00},
+	ENDMARKER,
+};
+#if 0
+static struct regval_list module_scene_night_regs[] =
+{
+	{0xfe,0x01},
+	{0x3c,0x60},	
+	{0xfe,0x00},
+	ENDMARKER,
+};
+#endif
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{
+        .id = V4L2_CID_AUTO_WHITE_BALANCE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 1,
+    },
+    {
+        .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+        .min = 0,
+        .max = 3,
+        .step = 1,
+        .def = 0,
+    },
+    {	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,},
+    {	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+
+    {
+        .id = V4L2_CID_HFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_VFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {	.id = V4L2_CID_MIRRORFLIP, //3.4ÄÚºËÃ»ÓÐ¶¨Òå´ËÃüÁî×Ö,Í¬Ê±Ð´ÈëvflipºÍhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	{	.id = V4L2_CID_COLORFX, 
+		.max = 3, 
+		.mask = 0x0, 
+		.def = 0,},
+	{	.id = V4L2_CID_EXPOSURE_AUTO, 
+		.max = 1, 
+		.mask = 0x0, 
+		.def = 1,},
+	{  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_TEXT, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+#if 1
+	{	.id = V4L2_CID_FLASH_LED_MODE, 
+		.max = 3,
+		.mask = 0x0,
+		.def = 0,},
+#endif
+		{
+		.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+		.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+		.mask = 0x0,
+		.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/gs5604/Kconfig b/drivers/media/i2c/camera/gs5604/Kconfig
new file mode 100755
index 0000000..a192206
--- /dev/null
+++ b/drivers/media/i2c/camera/gs5604/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config GS5604
+	tristate "GS5604 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for GS5604 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called GS5604.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gs5604/Makefile b/drivers/media/i2c/camera/gs5604/Makefile
new file mode 100755
index 0000000..a61d4f0
--- /dev/null
+++ b/drivers/media/i2c/camera/gs5604/Makefile
@@ -0,0 +1 @@
+obj-m	+= gs5604.o
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gs5604/gs5604.c b/drivers/media/i2c/camera/gs5604/gs5604.c
new file mode 100755
index 0000000..d3f04a1
--- /dev/null
+++ b/drivers/media/i2c/camera/gs5604/gs5604.c
@@ -0,0 +1,914 @@
+/*
+ * gs5604 Camera Driver
+ *
+ * Copyright (C) 2011 Actions Semiconductor Co.,LTD
+ * Wang Xin <wangxin@actions-semi.com>
+ *
+ * Based on ov227x driver
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+// extern inline void set_gpio_level(struct dts_gpio *gpio, bool active);
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap,unsigned int data_width, 
+unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	
+	if (I2C_REGS_WIDTH == 1)		
+		regs_array[0] = reg & 0xff;
+	if (I2C_REGS_WIDTH == 2) {
+		regs_array[0] = (reg >> 8) & 0xff;
+		regs_array[1] = reg & 0xff;
+	}
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+		return ret;
+	}
+
+	msg.flags = I2C_M_RD;
+	msg.len   = data_width;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+        if (data_width == 1)
+			*dest = data_array[0];
+		if (data_width == 2)
+			*dest = data_array[0]<<8 | data_array[1];
+	}
+	else {
+	    printk("read register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int data_width, 
+unsigned int reg, unsigned int data)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret,i;
+	
+//	printk("data_width = %d,reg = 0x%04x, data = 0x%x \n",data_width,reg,data);
+	if (I2C_REGS_WIDTH == 1)		
+		regs_array[0] = reg & 0xff;
+	if (I2C_REGS_WIDTH == 2) {
+		regs_array[0] = (reg >> 8) & 0xff;
+		regs_array[1] = reg & 0xff;
+	}
+	if (data_width == 1)
+		data_array[0] = data & 0xff;
+	if (data_width == 2) {
+		data_array[0] = data & 0xff;
+		data_array[1] = (data >> 8) & 0xff;
+	}
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + data_width); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + data_width;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->data_width,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0){
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+		}
+		vals++;
+	}
+	return 0;
+}
+/*************************************************************************
+* FUNCTION
+*   GS5604MIPI_WAIT_STATUS
+*
+* DESCRIPTION
+*   This function wait the 0x000E bit 0 is 1;then clear the bit 0;
+*   The salve address is 0x34
+* PARAMETERS
+*   None
+*
+* RETURNS
+*   None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void gs5604mipi_wait_status(struct i2c_adapter *i2c_adap)
+
+{
+    unsigned int tmp = 0,count = 0;
+    DBG_INFO("");
+	
+    do{
+    	count ++;
+		if (count > 50)
+			break;
+    	camera_i2c_read(i2c_adap, 1, 0x000E, &tmp);
+    	tmp &= 0x01;
+    	DBG_INFO("gs5604mipi_wait_status while1!\r\n");		
+	}while(!tmp);
+	
+	mdelay(10);
+	
+	camera_i2c_write(i2c_adap, 1, 0x0012, 0x01);
+	
+	mdelay(10);
+	 
+    do{
+    	camera_i2c_read(i2c_adap, 1, 0x000E, &tmp);
+    	tmp &= 0x01;
+    	DBG_INFO("gs5604mipi_wait_status while2!\r\n");
+    }while(tmp);
+    
+    mdelay(100);
+	
+    DBG_INFO("gs5604mipi_wait_status exit\n ");
+}
+
+/*************************************************************************
+* FUNCTION
+*   GS5604MIPI_WAIT_STATUS1
+*
+* DESCRIPTION
+*   This function wait the 0x000E bit 1 is 1;then clear the bit 1;
+*   The salve address is 0x78
+* PARAMETERS
+*   None
+*
+* RETURNS
+*   None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void gs5604mipi_wait_status1(struct i2c_adapter *i2c_adap)
+
+{
+    unsigned int tmp = 0,count = 0;
+    DBG_INFO("[GS5604MIPI]enter GS5604MIPI_WAIT_STATUS1 function:\n ");
+
+    do{
+    	count ++;
+		if (count > 50)
+			break;
+     	camera_i2c_read(i2c_adap, 1, 0x000E, &tmp);
+     	tmp &= 0x02;
+     	DBG_INFO("gs5604mipi_wait_status while1!\r\n");	
+    }while(tmp !=0x02);
+    mdelay(10);
+
+    camera_i2c_write(i2c_adap, 1, 0x0012,0x02);
+
+    do{
+    	camera_i2c_read(i2c_adap, 1, 0x000E, &tmp);
+    	tmp &= 0x02;
+    	DBG_INFO("gs5604mipi_wait_status while2!\r\n");	
+    }while(tmp);
+    
+    mdelay(10);
+    DBG_INFO("[GS5604MIPI]exit GS5604MIPI_WAIT_STATUS1 function:\n ");
+}
+
+/*************************************************************************
+* FUNCTION
+*   GS5604MIPI_WAIT_STATUS2
+*
+* DESCRIPTION
+*   This function wait the 0x000E bit 0 is 1;then clear the bit 0;
+*   The salve address is 0x78
+* PARAMETERS
+*   None
+*
+* RETURNS
+*   None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void gs5604mipi_wait_status2(struct i2c_adapter *i2c_adap)
+
+{
+    unsigned int tmp = 0,count = 0;
+
+    DBG_INFO("[GS5604MIPI]enter GS5604MIPI_WAIT_STATUS2 function:\n ");
+
+    do{
+    	count ++;
+		if (count > 50)
+			break;
+    	camera_i2c_read(i2c_adap, 1, 0x000E, &tmp);
+    	tmp &= 0x01;
+    	DBG_INFO("gs5604mipi_wait_status while1!\r\n");	
+    }while(!tmp);
+    mdelay(10);
+
+    camera_i2c_write(i2c_adap, 1, 0x0012,0x01);
+
+    do{
+    	camera_i2c_read(i2c_adap, 1, 0x000E, &tmp);
+    	tmp &= 0x01;
+    	DBG_INFO("gs5604mipi_wait_status while2!\r\n");	
+    }while(tmp);
+    
+    mdelay(10);
+    DBG_INFO("[GS5604MIPI]exit GS5604MIPI_WAIT_STATUS2 function:\n ");
+}
+
+/*************************************************************************
+* FUNCTION
+*   GS5604MIPI_WAIT_STATUS3
+*
+* DESCRIPTION
+*   This function wait the 0x000E bit 4 is 1;then clear the bit 1;
+*   The salve address is 0x78
+* PARAMETERS
+*   None
+*
+* RETURNS
+*   None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void gs5604mipi_wait_status3(struct i2c_adapter *i2c_adap)
+{
+    unsigned int tmp = 0;
+    int count = 0;
+    DBG_INFO("[GS5604MIPI]enter GS5604MIPI_WAIT_STATUS3 function:\n ");
+    do{
+    	camera_i2c_read(i2c_adap, 1, 0x000E, &tmp);
+    	tmp &= 0x10;
+    	DBG_INFO("gs5604mipi_wait_status while1!\r\n");	
+    }while(tmp !=0x10);
+    
+    mdelay(10);
+    camera_i2c_write(i2c_adap, 1, 0x0012,0x10);
+    
+    do{
+    	count ++;
+		if (count > 50)
+			break;
+    	camera_i2c_read(i2c_adap, 1, 0x000E, &tmp);
+    	tmp &= 0x10;
+    	DBG_INFO("gs5604mipi_wait_status while1!\r\n");	
+	}while(tmp);
+	
+    mdelay(10);
+    DBG_INFO("[GS5604MIPI]exit GS5604MIPI_WAIT_STATUS3 function:\n ");
+}
+static void update_after_init(struct i2c_adapter *i2c_adap)
+{
+
+	/*change iic address form 0x1a to 0x3c*/
+	MODULE_I2C_REAL_ADDRESS = 0x3c;
+	
+	mdelay(50);  //don't delete
+    gs5604mipi_wait_status2(i2c_adap);
+	camera_i2c_write(i2c_adap, 1, 0x5008,0x00); 
+    mdelay(50);	
+}
+static void start_af(struct i2c_adapter *i2c_adap)
+{
+	int af_state = 0;
+	int count = 0;
+	
+     /***** AF manual start******/
+    camera_i2c_write(i2c_adap, 2, 0x6648,0x00);
+	camera_i2c_write(i2c_adap, 1, 0x00B2,0x02);
+	camera_i2c_write(i2c_adap, 1, 0x00B3,0x02);//halfrelease mode: manual af
+	camera_i2c_write(i2c_adap, 1, 0x00B4,0x02);
+	camera_i2c_write(i2c_adap, 1, 0x00B1,0x01);//restart
+	mdelay(100);
+	do
+	{	
+		count ++;
+		if (count > 50)
+			break;
+		camera_i2c_read(i2c_adap, 1, 0x8b8a, &af_state);
+	}while(af_state !=0x03);
+	/***** AF manual end******/	
+}
+static void enter_preview_mode(struct i2c_adapter *i2c_adap)
+{
+	gs5604mipi_wait_status1(i2c_adap);
+	mdelay(20);
+}
+static void enter_capture_mode(struct i2c_adapter *i2c_adap)
+{
+	start_af(i2c_adap);
+	gs5604mipi_wait_status1(i2c_adap);
+	mdelay(100);	
+}
+static void enter_video_mode(struct i2c_adapter *i2c_adap)
+{
+	gs5604mipi_wait_status1(i2c_adap);
+	mdelay(20);		
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret;
+	unsigned int reg_0xfe;
+	struct i2c_adapter *i2c_adap = client->adapter;
+    DBG_INFO("");
+    
+	gs5604mipi_wait_status(i2c_adap);
+    return ret;
+}
+
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+  int ret = 0;
+  
+//  struct i2c_client *client = v4l2_get_subdevdata(sd);
+////  struct camera_module_priv *priv = to_camera_priv(client);
+//  struct i2c_adapter *i2c_adap = client->adapter;
+//  
+//  unsigned int reg_0xfe = 0x00;
+//  unsigned int reg_0xb6 = 0x01;
+//
+//  ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+//  ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+
+  return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+ int ret = 0;
+ 
+//  struct i2c_client *client = v4l2_get_subdevdata(sd);
+////  struct camera_module_priv *priv = to_camera_priv(client);
+//  struct i2c_adapter *i2c_adap = client->adapter;
+// 
+//  unsigned int reg_0xfe = 0x00;
+//  unsigned int reg_0xb6 = 0x00;
+//
+//  ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+//  ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+ 
+  return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+//	struct i2c_adapter *i2c_adap = client->adapter;
+//	
+//	unsigned int reg_0xfe = 0x00;
+//	unsigned int reg_0x03;
+//	unsigned int reg_0x04;
+//
+//	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+//	ret |= camera_i2c_read(i2c_adap, 0x03, &reg_0x03);
+//	ret |= camera_i2c_read(i2c_adap, 0x04, &reg_0x04);
+//		
+//	priv->preview_exposure_param.shutter = (reg_0x03 << 8) | reg_0x04;
+//	priv->capture_exposure_param.shutter = (priv->preview_exposure_param.shutter)/2;
+//	
+//	//printk("GC2155 module_save_exposure_param, win->name:%s\n", priv->win->name);
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+ 	int ret = 0;
+  
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+//	struct i2c_adapter *i2c_adap = client->adapter;
+//	
+//	unsigned int reg_0xfe = 0x00;
+//	unsigned char reg_0x03;
+//	unsigned char reg_0x04;
+//
+//	if(priv->capture_exposure_param.shutter < 1) {
+//		priv->capture_exposure_param.shutter = 1;
+//	}
+//
+//	reg_0x03 = ((priv->capture_exposure_param.shutter)>>8) & 0x1F ;
+//	reg_0x04 = (priv->capture_exposure_param.shutter) & 0xFF;
+//
+//	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+//	ret |= camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+//	ret |= camera_i2c_write(i2c_adap, 0x04, reg_0x04);
+	
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+//	struct i2c_adapter *i2c_adap = client->adapter;
+//	int auto_white_balance;
+//
+//
+//	if(ctrl)
+//		auto_white_balance = ctrl->val;
+//	else
+//		auto_white_balance = 1;
+//  
+//	if (auto_white_balance < 0 || auto_white_balance > 1) {
+//		printk("[gs5604] set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+//		return -ERANGE;
+//	}
+//	
+//	switch(auto_white_balance)
+//	{
+//	case 0:
+//		ret = 0;
+//		goto change_val;
+//		
+//	case 1:	
+//		ret |=camera_write_array(i2c_adap, module_whitebance_auto_regs);
+//		break;
+//	}
+//	
+//change_val:
+//	priv->auto_white_balance = auto_white_balance;
+//	if(ctrl)
+//		ctrl->cur.val = auto_white_balance;  
+//		
+
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+//	int white_balance_temperature = ctrl->val;
+//	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	
+//	switch(white_balance_temperature)
+//	{
+//	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+//		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+//		break;
+//	
+//	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+//		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+//		break;
+//	
+//	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+//		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+//		break;
+//	
+//	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+//		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+//		break;
+//	
+//	default:
+//		printk("[gs5604] set white_balance_temperature over range, white_balance_temperature = %d\n", white_balance_temperature);
+//		return -ERANGE;	
+//	}
+//	
+//	priv->auto_white_balance = 0;
+//	priv->white_balance_temperature = white_balance_temperature;
+//	ctrl->cur.val = white_balance_temperature;
+//	
+	return ret;
+}
+static int module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+//	struct i2c_adapter *i2c_adap = client->adapter;
+//  int colorfx = ctrl->val;
+//	int ret = 0;
+//
+//
+//	switch (colorfx) {
+//	case V4L2_COLORFX_NONE: /* normal */
+//		ret = camera_write_array(i2c_adap, module_effect_normal_regs);
+//		break;
+//	
+//	case V4L2_COLORFX_BW: /* black and white */
+//		ret = camera_write_array(i2c_adap, module_effect_white_black_regs);
+//		break;
+//	
+//	case V4L2_COLORFX_SEPIA: /* antique ,\B8\B4\B9\C5*/
+//		ret = camera_write_array(i2c_adap, module_effect_antique_regs);
+//		break;
+//
+//	case V4L2_COLORFX_NEGATIVE: /* negative\A3\AC\B8\BAƬ */
+//		ret = camera_write_array(i2c_adap, module_effect_negative_regs);
+//		break;
+//
+//    default:
+//        printk("[gs5604] set colorfx over range, colorfx = %d\n", colorfx);
+//        return -ERANGE;	
+//    }
+//
+//    priv->colorfx = colorfx;
+//    ctrl->cur.val = colorfx;
+
+    return 0;
+}
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+//	struct i2c_adapter *i2c_adap = client->adapter;
+//    int exposure_auto;
+	int ret = 0;
+
+//	if(ctrl)
+//		exposure_auto = ctrl->val;
+//	else
+//		exposure_auto = V4L2_EXPOSURE_AUTO;
+//
+//	if (exposure_auto < 0 || exposure_auto > 1) {
+//		return -ERANGE;
+//	}
+//  
+//	switch (exposure_auto) {
+//	case V4L2_EXPOSURE_AUTO:/*  auto */
+//        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+//		break;
+//
+//    case V4L2_EXPOSURE_MANUAL: // non auto
+//        ret = 0;
+//        break;
+//    }
+//
+//	priv->exposure_auto = exposure_auto;
+//	if(ctrl)
+//		ctrl->cur.val = exposure_auto;
+
+    return ret;
+}
+
+static int module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct camera_module_priv *priv = to_camera_priv(client);
+//	struct i2c_adapter *i2c_adap = client->adapter;
+//  	int scene_exposure = ctrl->val;
+//  	unsigned char reg_3a00 = 0;
+//
+//	
+//	switch(scene_exposure) {
+//	case 0:  //\CA\D2\C4\DA
+//
+//		break;
+//	
+//	case 1:  //\CA\D2\CD\E2
+//
+//		break;
+//
+//    default:
+//        printk("[gs5604] set scene_exposure over range, scene_exposure = %d\n", scene_exposure);
+//        return -ERANGE;
+//    }
+//
+//    priv->scene_exposure = scene_exposure;
+//    ctrl->cur.val = scene_exposure;
+
+	return ret;
+}
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+
+
+	DBG_INFO("");
+	   if (!enable) {
+		   DBG_INFO("stream down");
+//		   camera_i2c_write(i2c_adap, 0x4202, 0x0f);
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   DBG_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   DBG_INFO("stream on");
+//	   camera_i2c_write(i2c_adap, 0x4202, 0x00);   
+	 return 0;   
+}
+static int  module_set_exposure(struct v4l2_subdev *sd, int val)
+{
+	// struct i2c_adapter *i2c_adap = client->adapter;
+	// unsigned int exposure_3500 = 0;
+	// unsigned int exposure_3501 = 0;
+	// unsigned int exposure_3502 = 0;
+	int ret = 0;
+	// DBG_INFO(" val = 0x%04x \n", val);
+	// exposure_3500 = (val >> 16) & 0x0f;
+	// exposure_3501 = (val >> 8) & 0xff;
+	// exposure_3502 = val & 0xf0;
+	 	
+//	ret = camera_i2c_write(i2c_adap, 0x3500, exposure_3500);
+//	ret |= camera_i2c_write(i2c_adap, 0x3501, exposure_3501);
+//	ret |= camera_i2c_write(i2c_adap, 0x3502, exposure_3502);
+	return ret;
+}
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	// struct i2c_adapter *i2c_adap = client->adapter;
+	// unsigned int exposure_3500 = 0;
+	// unsigned int exposure_3501 = 0;
+	// unsigned int exposure_3502 = 0;
+	int ret = 0;
+	
+	// ret = camera_i2c_read(i2c_adap, 0x3500, &exposure_3500);
+	// ret |= camera_i2c_read(i2c_adap, 0x3501, &exposure_3501);
+	// ret |= camera_i2c_read(i2c_adap, 0x3502, &exposure_3502);
+	// val = (exposure_3500 & 0x0f) << 16 + (exposure_3501 & 0xff) << 8 + exposure_3502 & 0xf0;
+	
+	// DBG_INFO(" val = 0x%04x \n", val);
+    return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	// struct i2c_adapter *i2c_adap = client->adapter;
+	// unsigned int gain_350a = 0;
+	// unsigned int gain_350b = 0;
+	int ret = 0;
+	
+//	ret = camera_i2c_read(i2c_adap, 0x350a, &gain_350a);
+//	ret |= camera_i2c_read(i2c_adap, 0x350b, &gain_350b);
+//	val = (gain_350a & 0x03) << 8 + gain_350b & 0xff;
+//	
+	DBG_INFO(" val = 0x%04x \n", val);
+    return ret;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	// struct i2c_adapter *i2c_adap = client->adapter;
+	// unsigned int gain_350a = 0;
+	// unsigned int gain_350b = 0;
+	int ret = 0;
+	
+	DBG_INFO(" val = 0x%04x \n", val);
+//	gain_350a = (val >> 8) &0x03; 
+//	gain_350b = val & 0xff;
+//	ret = camera_i2c_write(i2c_adap, 0x350a, gain_350a);
+//	ret |= camera_i2c_write(i2c_adap, 0x350b, gain_350b);
+
+    return ret;
+}
+
+static int module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+ 	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	switch(ctrl->val) {
+		case 3:
+
+			break;
+		case 2:
+		
+			break;
+		case 1:
+			
+			break;
+		case 0:
+			
+			break;
+		case -1:
+			
+			break;
+		case -2:
+		
+			break;
+		case -3:
+		
+			break;
+		default:
+			printk("error:gs5604 env setting,val out of rang\n");
+			return -ERANGE;	
+	}
+    return 0;
+}
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	return 0;
+}
+
+static int module_s_mirror_flip(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+
+    DBG_INFO("");
+
+    switch (ctrl->id) {
+    case V4L2_CID_HFLIP:
+        if (ctrl->val) {
+// 			ret = camera_i2c_write(i2c_adap, 0x3820, 0x47);
+        } else {
+//			ret |= camera_i2c_write(i2c_adap, 0x3820, 0x41);
+        }
+        break;
+    case MODULE_FLAG_VFLIP:
+        if (ctrl->val) {
+//            ret |= camera_i2c_write(i2c_adap, 0x3821, 0x07);
+        } else {
+//            ret |= camera_i2c_write(i2c_adap, 0x3821, 0x01);
+        }
+        break;
+    default:
+        DBG_ERR("set flip out of range\n");
+        return (-ERANGE);
+    }
+  
+	return ret;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int pid = 0;
+    int ret;
+
+	
+	DBG_INFO("");
+
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, 1, PID, &pid); 
+	
+	switch (pid) 
+    {
+		case CAMERA_MODULE_PID:
+
+			printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, pid);
+		break;
+	
+		default:
+			printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, pid);
+		return -ENODEV;
+	}
+	return ret;
+}
+
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+//	struct i2c_client *client = v4l2_get_subdevdata(sd);
+//	struct i2c_adapter *i2c_adap = client->adapter;
+//	
+//	ret |= camera_i2c_write(i2c_adap, 0x3022, 0x03);
+	return 0;
+}
+
+static int module_get_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+  int ret = 0;
+	ctrl->val = NONE_AF;
+	//DBG_INFO("module_get_af_mode: %d\n", ctrl->val);
+	return ret;
+}
+
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+// void sensor_power_on(bool rear, struct sensor_pwd_info *spinfo, bool hardware)
+// {
+   
+	// if (hardware) {
+		
+		// if (rear) { 
+			// set_gpio_level(&spinfo->gpio_power, GPIO_LOW);
+			// mdelay(50);
+			// set_gpio_level(&spinfo->gpio_power, GPIO_HIGH);
+			// mdelay(50);
+			// set_gpio_level(&spinfo->gpio_rear, GPIO_LOW);
+			// set_gpio_level(&spinfo->gpio_rear_reset, GPIO_LOW);
+			// mdelay(50);
+			// set_gpio_level(&spinfo->gpio_rear_reset, GPIO_HIGH);
+			// mdelay(50);
+	        // set_gpio_level(&spinfo->gpio_rear, GPIO_HIGH);
+	        // mdelay(50);
+	    // } else {
+			// set_gpio_level(spinfo->gpio_power, GPIO_LOW);
+			// mdelay(500);
+			// set_gpio_level(spinfo->gpio_power, GPIO_HIGH);
+			// mdelay(500);	    	
+			// set_gpio_level(&spinfo->gpio_front, GPIO_LOW);
+			// set_gpio_level(&spinfo->gpio_front_reset, GPIO_LOW);
+			// mdelay(500);
+			// set_gpio_level(&spinfo->gpio_front_reset, GPIO_HIGH);
+			// mdelay(500);
+	        // set_gpio_level(&spinfo->gpio_front, GPIO_HIGH);
+	        // mdelay(500);    
+	    // }
+
+	// } else {
+		// if (rear) {
+			// set_gpio_level(&spinfo->gpio_rear, GPIO_HIGH);
+			// mdelay(20);
+		// } else {
+			// set_gpio_level(&spinfo->gpio_front, GPIO_HIGH);
+			// mdelay(20);
+		// }
+	// }
+// }
+
+// void sensor_power_off(bool rear, struct sensor_pwd_info *spinfo, bool hardware)
+// {
+	// if (hardware) {
+		
+	    // if (rear) {
+	    	// set_gpio_level(&spinfo->gpio_rear, GPIO_LOW);
+	    	// mdelay(5);
+	    	// set_gpio_level(&spinfo->gpio_rear_reset, GPIO_LOW);
+	    	// mdelay(10);
+	    // } else {
+	    	// set_gpio_level(&spinfo->gpio_front, GPIO_LOW);
+	    	// mdelay(5);
+	    	// set_gpio_level(&spinfo->gpio_front_reset, GPIO_LOW);
+	        
+	    // }
+	// } else {
+		// if (rear) {
+			// set_gpio_level(&spinfo->gpio_rear, GPIO_LOW);
+			// mdelay(10);
+		// }
+		// else
+			// set_gpio_level(&spinfo->gpio_front, GPIO_LOW);
+	// }
+// }
+// static int get_sensor_id(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+// {
+	// int ret = 0;
+	
+	// ctrl->val = CAMERA_MODULE_PID;
+	
+	// return ret;
+// }
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/gs5604/module_diff.h b/drivers/media/i2c/camera/gs5604/module_diff.h
new file mode 100755
index 0000000..b653135
--- /dev/null
+++ b/drivers/media/i2c/camera/gs5604/module_diff.h
@@ -0,0 +1,2347 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME 		"gs5604"
+#define CAMERA_MODULE_PID		0x0017
+
+unsigned char MODULE_I2C_REAL_ADDRESS = 0x1a;
+#define MODULE_I2C_REG_ADDRESS		0x1a
+#define I2C_REGS_WIDTH			2
+
+#define PID					0x0000 /* Product ID Number H byte */
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_HSYNC_ACTIVE_LEVEL		V4L2_MBUS_HSYNC_ACTIVE_HIGH
+#define DEFAULT_PCLK_SAMPLE_EDGE        V4L2_MBUS_PCLK_SAMPLE_RISING
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_720P
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_720P
+#define MODULE_MAX_WIDTH		WIDTH_QSXGA
+#define MODULE_MAX_HEIGHT		HEIGHT_QSXGA
+
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		2
+#define DROP_NUM_PREVIEW		5
+
+static unsigned int frame_rate_svga[] = {60,};
+static unsigned int frame_rate_720p[] = {60,};
+static unsigned int frame_rate_qsxga[] = {15,};
+
+#define MODULE_SUPPORT_AF
+/*
+MIPI SENSOR \B2\CE\CA\FD\C9\E8\D6\C3
+*/
+static mipi_setting mipi_sensor_setting = {
+    .lan_num = 1,    //0~3
+    .contex0_en = 1,
+    .contex0_virtual_num = 0,
+    .contex0_data_type = MIPI_YUV422,  //MIPI_YUV422 MIPI_RAW8 MIPI_RAW10 MIPI_RAW12
+    .clk_settle_time = 7,	//7
+    .clk_term_time = 5,    //5
+    .data_settle_time = 7,  //7
+    .data_term_time = 5,    //5
+    .crc_en = 1,
+    .ecc_en = 1,
+    .hclk_om_ent_en = 1,
+    .lp11_not_chek = 0,
+    .hsclk_edge = 0,   //0: rising edge; 1: falling edge
+    .lane0_map = 0,
+    .lane1_map = 1,
+    .lane2_map = 2,
+    .lane3_map = 3,
+    .mipi_en = 1,
+    .csi_clk = 150000000,
+};
+
+struct module_info camera_module_info = {
+    .flags      = 0 | SENSOR_FLAG_8BIT | SENSOR_FLAG_YUV | SENSOR_FLAG_MIPI | SENSOR_FLAG_CHANNEL1 ,
+    .mipi_cfg   = &mipi_sensor_setting,
+};
+
+static const struct module_color_format module_cfmts[] = {
+
+    {
+        .code = V4L2_MBUS_FMT_YUYV8_2X8,
+        .colorspace = V4L2_COLORSPACE_JPEG,
+    },
+
+};
+static const struct regval_list module_init_regs[] = {
+    /***************pll********************/    
+    {1, 0x500A,0x01},
+    {1, 0x0004,0x02},
+    {1, 0x0007,0x00},
+    {1, 0x0008,0x00},
+    {1, 0x00c4,0x11},
+    {1, 0x00c5,0x11},
+
+    /***************mipi timing clk=432MHZ,PCLK=86.2MHz**************/
+    {1, 0x5C01,0x00},                  // RGLANESEL
+    {1, 0x5C04,0x04},                  // RGTLPX   
+    {1, 0x5C05,0x03},                  // RGTCLKPRE
+    {1, 0x5C06,0x0E},                  // RGTCLKZER
+    {1, 0x5C07,0x02},                  // RGTCLKPRE
+    {1, 0x5C08,0x0B},                  // RGTCLKPOS
+    {1, 0x5C09,0x05},                  // RGTCLKTRA
+    {1, 0x5C0A,0x07},                  // RGTHSEXIT
+    {1, 0x5C0B,0x03},                  // RGTHSPREP
+    {1, 0x5C0C,0x07},                  // RGTHSZERO
+    {1, 0x5C0D,0x05},                  // RGTHSTRAI
+    {1, 0x5C0E,0x01},                  // RGTLPXESC
+    //{1, 0x0006,0x16},	
+    //GS5604MIPI_WAIT_STATUS2(}, 
+
+	//SHD1
+	{2, 0xED00, 0x9191},
+	{1, 0xED02, 0xd7},
+	{1, 0xED03, 0x69},
+	{1, 0xED04, 0xd0},
+	{1, 0xED05, 0x73},
+	{1, 0xED06, 0x04},
+	{1, 0xED07, 0xd4},
+	{1, 0xED08, 0x9b},
+	{1, 0xED09, 0xf7},
+	{1, 0xED0A, 0xc0},
+	{1, 0xED0B, 0x86},
+	{1, 0xED0C, 0x3c},
+	{1, 0xED0D, 0xad},
+	{1, 0xED0E, 0x09},
+	{1, 0xED0F, 0x8f},
+	{1, 0xED10, 0x6b},
+	{1, 0xED11, 0xc6},
+	{1, 0xED12, 0x93},
+	{1, 0xED13, 0x1b},
+	{1, 0xED14, 0xf9},
+	{1, 0xED15, 0x24},
+	{1, 0xED16, 0x07},
+	{1, 0xED17, 0x41},
+	{1, 0xED18, 0xcc},
+	{1, 0xED19, 0x59},
+	{1, 0xED1A, 0x10},
+	{1, 0xED1B, 0x75},
+	{1, 0xED1C, 0x0e},
+	{1, 0xED1D, 0xb4},
+	{1, 0xED1E, 0x9c},
+	{1, 0xED1F, 0xfd},
+	{1, 0xED20, 0xc8},
+	{1, 0xED21, 0xc6},
+	{1, 0xED22, 0x3b},
+	{1, 0xED23, 0xa0},
+	{1, 0xED24, 0x69},
+	{1, 0xED25, 0x8e},
+	{1, 0xED26, 0x65},
+	{1, 0xED27, 0x84},
+	{1, 0xED28, 0xf3},
+	{1, 0xED29, 0x99},
+	{1, 0xED2A, 0xe6},
+	{1, 0xED2B, 0xbc},
+	{1, 0xED2C, 0x26},
+	{1, 0xED2D, 0x3c},
+	{1, 0xED2E, 0xc6},
+	{1, 0xED2F, 0x09},
+	{1, 0xED30, 0x90},
+	{1, 0xED31, 0x72},
+	{1, 0xED32, 0x12},
+	{1, 0xED33, 0x34},
+	{1, 0xED34, 0x9b},
+	{1, 0xED35, 0xef},
+	{1, 0xED36, 0x84},
+	{1, 0xED37, 0xe6},
+	{1, 0xED38, 0x38},
+	{1, 0xED39, 0x7e},
+	{1, 0xED3A, 0xe9},
+	{1, 0xED3B, 0xcc},
+	{1, 0xED3C, 0x59},
+	{1, 0xED3D, 0x04},
+	{1, 0xED3E, 0x03},
+	{1, 0xED3F, 0x16},
+	{1, 0xED40, 0xbd},
+	{1, 0xED41, 0x98},
+	{1, 0xED42, 0x45},
+	{1, 0xED43, 0x30},
+	{1, 0xED44, 0x7c},
+	{1, 0xED45, 0xf1},
+	{1, 0xED46, 0x4c},
+	{1, 0xED47, 0x67},
+	{1, 0xED48, 0x94},
+	{1, 0xED49, 0xb3},
+	{1, 0xED4A, 0x9a},
+	{1, 0xED4B, 0xf0},
+	{1, 0xED4C, 0x50},
+	{1, 0xED4D, 0x06},
+	{1, 0xED4E, 0x37},
+	{1, 0xED4F, 0x7a},
+	{1, 0xED50, 0xb9},
+	{1, 0xED51, 0x4c},
+	{1, 0xED52, 0x54},
+	{1, 0xED53, 0xc6},
+	{1, 0xED54, 0x82},
+	{1, 0xED55, 0x93},
+	{1, 0xED56, 0xa2},
+	{1, 0xED57, 0xb4},
+	{1, 0xED58, 0x04},
+	{1, 0xED59, 0x27},
+	{1, 0xED5A, 0x36},
+	{1, 0xED5B, 0x21},
+	{1, 0xED5C, 0x8a},
+	{1, 0xED5D, 0x53},
+	{1, 0xED5E, 0xc4},
+	{1, 0xED5F, 0x72},
+	{1, 0xED60, 0x17},
+	{1, 0xED61, 0xcb},
+	{1, 0xED62, 0x34},
+	{1, 0xED63, 0x06},
+	{1, 0xED64, 0x37},
+	{1, 0xED65, 0x7c},
+	{1, 0xED66, 0xd9},
+	{1, 0xED67, 0x8c},
+	{1, 0xED68, 0x56},
+	{1, 0xED69, 0xde},
+	{1, 0xED6A, 0xf2},
+	{1, 0xED6B, 0x12},
+	{1, 0xED6C, 0x9d},
+	{1, 0xED6D, 0x58},
+	{1, 0xED6E, 0x64},
+	{1, 0xED6F, 0x23},
+	{1, 0xED70, 0x0e},
+	{1, 0xED71, 0x89},
+	{1, 0xED72, 0x48},
+	{1, 0xED73, 0x45},
+	{1, 0xED74, 0x32},
+	{1, 0xED75, 0xd2},
+	{1, 0xED76, 0x12},
+	{1, 0xED77, 0x9c},
+	{1, 0xED78, 0x5c},
+	{1, 0xED79, 0xc5},
+	{1, 0xED7A, 0x2d},
+	{1, 0xED7B, 0x75},
+	{1, 0xED7C, 0xc9},
+	{1, 0xED7D, 0x4c},
+	{1, 0xED7E, 0x5b},
+	{1, 0xED7F, 0x14},
+	{1, 0xED80, 0xa3},
+	{1, 0xED81, 0x94},
+	{1, 0xED82, 0xae},
+	{1, 0xED83, 0x88},
+	{1, 0xED84, 0x44},
+	{1, 0xED85, 0x25},
+	{1, 0xED86, 0x09},
+	{1, 0xED87, 0x59},
+	{1, 0xED88, 0x08},
+	{1, 0xED89, 0x40},
+	{1, 0xED8A, 0x00},
+	{1, 0xED8B, 0x82},
+	{1, 0xED8C, 0x10},
+	{1, 0xED8D, 0x85},
+	{1, 0xED8E, 0x84},
+	{1, 0xED8F, 0x04},
+	{1, 0xED90, 0x25},
+	{1, 0xED91, 0x48},
+	{1, 0xED92, 0xe1},
+	{1, 0xED93, 0x0a},
+	{1, 0xED94, 0x5a},
+	{1, 0xED95, 0x10},
+	{1, 0xED96, 0x03},
+	{1, 0xED97, 0x97},
+	{1, 0xED98, 0xc6},
+	{1, 0xED99, 0x30},
+	{1, 0xED9A, 0x05},
+	{1, 0xED9B, 0x2c},
+	{1, 0xED9C, 0x24},
+	{1, 0xED9D, 0x69},
+	{1, 0xED9E, 0xc9},
+	{1, 0xED9F, 0x42},
+	{1, 0xEDA0, 0x1a},
+	{1, 0xEDA1, 0x12},
+	{1, 0xEDA2, 0x10},
+	{1, 0xEDA3, 0x81},
+	{1, 0xEDA4, 0x28},
+	{1, 0xEDA5, 0x84},
+	{1, 0xEDA6, 0x21},
+	{1, 0xEDA7, 0x23},
+	{1, 0xEDA8, 0x59},
+	{1, 0xEDA9, 0x89},
+	{1, 0xEDAA, 0x52},
+	{1, 0xEDAB, 0xbe},
+	{1, 0xEDAC, 0xa2},
+	{1, 0xEDAD, 0x96},
+	{1, 0xEDAE, 0xc5},
+	{1, 0xEDAF, 0x08},
+	{1, 0xEDB0, 0xa6},
+	{1, 0xEDB1, 0x34},
+	{1, 0xEDB2, 0x60},
+	{1, 0xEDB3, 0xc1},
+	{1, 0xEDB4, 0x4b},
+	{1, 0xEDB5, 0x4d},
+	{1, 0xEDB6, 0x84},
+	{1, 0xEDB7, 0xb2},
+	{1, 0xEDB8, 0x11},
+	{1, 0xEDB9, 0x91},
+	{1, 0xEDBA, 0x4c},
+	{1, 0xEDBB, 0x04},
+	{1, 0xEDBC, 0x23},
+	{1, 0xEDBD, 0x1a},
+	{1, 0xEDBE, 0x09},
+	{1, 0xEDBF, 0xc9},
+	{1, 0xEDC0, 0x4c},
+	{1, 0xEDC1, 0x82},
+	{1, 0xEDC2, 0xe2},
+	{1, 0xEDC3, 0x95},
+	{1, 0xEDC4, 0xbb},
+	{1, 0xEDC5, 0xf4},
+	{1, 0xEDC6, 0x65},
+	{1, 0xEDC7, 0x34},
+	{1, 0xEDC8, 0x9c},
+	{1, 0xEDC9, 0x39},
+	{1, 0xEDCA, 0x8e},
+	{1, 0xEDCB, 0x60},
+	{1, 0xEDCC, 0x48},
+	{1, 0xEDCD, 0x93},
+	{1, 0xEDCE, 0x95},
+	{1, 0xEDCF, 0xb7},
+	{1, 0xEDD0, 0xfc},
+	{1, 0xEDD1, 0xe4},
+	{1, 0xEDD2, 0x29},
+	{1, 0xEDD3, 0x34},
+	{1, 0xEDD4, 0x11},
+	{1, 0xEDD5, 0x8a},
+	{1, 0xEDD6, 0x4f},
+	{1, 0xEDD7, 0xa0},
+	{1, 0xEDD8, 0x72},
+	{1, 0xEDD9, 0x95},
+	{1, 0xEDDA, 0xb7},
+	{1, 0xEDDB, 0x00},
+	{1, 0xEDDC, 0xa6},
+	{1, 0xEDDD, 0x34},
+	{1, 0xEDDE, 0x97},
+	{1, 0xEDDF, 0x31},
+	{1, 0xEDE0, 0x0e},
+	{1, 0xEDE1, 0x6f},
+	{1, 0xEDE2, 0xe4},
+	{1, 0xEDE3, 0x93},
+	{1, 0xEDE4, 0x9a},
+	{1, 0xEDE5, 0xec},
+	{1, 0xEDE6, 0x18},
+	{1, 0xEDE7, 0x66},
+	{1, 0xEDE8, 0x35},
+	{1, 0xEDE9, 0x6f},
+	{1, 0xEDEA, 0x71},
+	{1, 0xEDEB, 0x0c},
+	{1, 0xEDEC, 0x5a},
+	{1, 0xEDED, 0x0c},
+	{1, 0xEDEE, 0xe3},
+	{1, 0xEDEF, 0x96},
+	{1, 0xEDF0, 0xc7},
+	{1, 0xEDF1, 0x14},
+	{1, 0xEDF2, 0x86},
+	{1, 0xEDF3, 0x35},
+	{1, 0xEDF4, 0xa8},
+	{1, 0xEDF5, 0xd9},
+	{1, 0xEDF6, 0x0e},
+	{1, 0xEDF7, 0x6e},
+	{1, 0xEDF8, 0xe2},
+	{1, 0xEDF9, 0xc3},
+	{1, 0xEDFA, 0x9d},
+	{1, 0xEDFB, 0x0e},
+	{1, 0xEDFC, 0x45},
+	{1, 0xEDFD, 0xc7},
+	{1, 0xEDFE, 0x41},
+	{1, 0xEDFF, 0xb6},
+	{1, 0xEE00, 0x71},
+	{1, 0xEE01, 0x8f},
+	{1, 0xEE02, 0x69},
+	{1, 0xEE03, 0xb0},
+	{1, 0xEE04, 0xa3},
+	{1, 0xEE05, 0x19},
+	{1, 0xEE06, 0xe6},
+	{1, 0xEE07, 0x8c},
+	{1, 0xEE08, 0xe6},
+	{1, 0xEE09, 0x3a},
+	{1, 0xEE0A, 0xb5},
+	{1, 0xEE0B, 0x69},
+	{1, 0xEE0C, 0x0f},
+	{1, 0xEE0D, 0x74},
+	{1, 0xEE0E, 0x20},
+	{1, 0xEE0F, 0x84},
+	{1, 0xEE10, 0x1d},
+	{1, 0xEE11, 0x0e},
+	{1, 0xEE12, 0x91},
+	{1, 0xEE13, 0xa7},
+	{1, 0xEE14, 0x44},
+	{1, 0xEE15, 0xd4},
+	{1, 0xEE16, 0x79},
+	{1, 0xEE17, 0x90},
+	{1, 0xEE18, 0x6f},
+	{1, 0xEE19, 0xec},
+	{1, 0xEE1A, 0x23},
+	{1, 0xEE1B, 0x9b},
+	{1, 0xEE1C, 0xf3},
+	{1, 0xEE1D, 0xb4},
+	{1, 0xEE1E, 0x46},
+	{1, 0xEE1F, 0x3c},
+	{1, 0xEE20, 0xb0},
+	{1, 0xEE21, 0x29},
+	{1, 0xEE22, 0x4f},
+	{1, 0xEE23, 0x6f},
+	{1, 0xEE24, 0xec},
+	{1, 0xEE25, 0x33},
+	{1, 0xEE26, 0x1d},
+	{1, 0xEE27, 0x08},
+	{1, 0xEE28, 0x7d},
+	{1, 0xEE29, 0xe7},
+	{1, 0xEE2A, 0x43},
+	{1, 0xEE2B, 0x9c},
+	{1, 0xEE2C, 0xb9},
+	{1, 0xEE2D, 0x4e},
+	{1, 0xEE2E, 0x66},
+	{1, 0xEE2F, 0xa2},
+	{1, 0xEE30, 0xf3},
+	{1, 0xEE31, 0x98},
+	{1, 0xEE32, 0xe0},
+	{1, 0xEE33, 0x24},
+	{1, 0xEE34, 0x86},
+	{1, 0xEE35, 0x36},
+	{1, 0xEE36, 0x88},
+	{1, 0xEE37, 0x91},
+	{1, 0xEE38, 0x8d},
+	{1, 0xEE39, 0x63},
+	{1, 0xEE3A, 0x6a},
+	{1, 0xEE3B, 0x83},
+	{1, 0xEE3C, 0x19},
+	{1, 0xEE3D, 0xe1},
+	{1, 0xEE3E, 0x94},
+	{1, 0xEE3F, 0x86},
+	{1, 0xEE40, 0x3a},
+	{1, 0xEE41, 0xa6},
+	{1, 0xEE42, 0xb9},
+	{1, 0xEE43, 0x8e},
+	{1, 0xEE44, 0x67},
+	{1, 0xEE45, 0xae},
+	{1, 0xEE46, 0xb3},
+	{1, 0xEE47, 0x99},
+	{1, 0xEE48, 0xe7},
+	{1, 0xEE49, 0x28},
+	{1, 0xEE4A, 0xc6},
+	{1, 0xEE4B, 0x36},
+	{1, 0xEE4C, 0x80},
+	{1, 0xEE4D, 0x31},
+	{1, 0xEE4E, 0xcd},
+	{1, 0xEE4F, 0x5e},
+	{1, 0xEE50, 0x3a},
+	{1, 0xEE51, 0x53},
+	{1, 0xEE52, 0x18},
+	{1, 0xEE53, 0xd4},
+	{1, 0xEE54, 0x4c},
+	{1, 0xEE55, 0x26},
+	{1, 0xEE56, 0x37},
+	{1, 0xEE57, 0xa8},
+	{1, 0xEE58, 0x91},
+	{1, 0xEE59, 0x8e},
+	{1, 0xEE5A, 0x6a},
+	{1, 0xEE5B, 0xac},
+	{1, 0xEE5C, 0x63},
+	{1, 0xEE5D, 0x18},
+	{1, 0xEE5E, 0xdb},
+	{1, 0xEE5F, 0xec},
+	{1, 0xEE60, 0xa5},
+	{1, 0xEE61, 0x34},
+	{1, 0xEE62, 0x62},
+	{1, 0xEE63, 0x19},
+	{1, 0xEE64, 0xcc},
+	{1, 0xEE65, 0x54},
+	{1, 0xEE66, 0xda},
+	{1, 0xEE67, 0x02},
+	{1, 0xEE68, 0x95},
+	{1, 0xEE69, 0xb3},
+	{1, 0xEE6A, 0x5c},
+	{1, 0xEE6B, 0xc5},
+	{1, 0xEE6C, 0x2d},
+	{1, 0xEE6D, 0x6a},
+	{1, 0xEE6E, 0x21},
+	{1, 0xEE6F, 0xcc},
+	{1, 0xEE70, 0x61},
+	{1, 0xEE71, 0x4e},
+	{1, 0xEE72, 0x33},
+	{1, 0xEE73, 0x19},
+	{1, 0xEE74, 0xda},
+	{1, 0xEE75, 0xb4},
+	{1, 0xEE76, 0xc5},
+	{1, 0xEE77, 0x32},
+	{1, 0xEE78, 0x5d},
+	{1, 0xEE79, 0xe9},
+	{1, 0xEE7A, 0xcb},
+	{1, 0xEE7B, 0x4f},
+	{1, 0xEE7C, 0xac},
+	{1, 0xEE7D, 0xd2},
+	{1, 0xEE7E, 0x12},
+	{1, 0xEE7F, 0x9f},
+	{1, 0xEE80, 0x98},
+	{1, 0xEE81, 0x64},
+	{1, 0xEE82, 0x26},
+	{1, 0xEE83, 0x30},
+	{1, 0xEE84, 0xe9},
+	{1, 0xEE85, 0x09},
+	{1, 0xEE86, 0x51},
+	{1, 0xEE87, 0xaa},
+	{1, 0xEE88, 0x62},
+	{1, 0xEE89, 0x16},
+	{1, 0xEE8A, 0xbf},
+	{1, 0xEE8B, 0xe4},
+	{1, 0xEE8C, 0x85},
+	{1, 0xEE8D, 0x32},
+	{1, 0xEE8E, 0x5b},
+	{1, 0xEE8F, 0xe9},
+	{1, 0xEE90, 0x8b},
+	{1, 0xEE91, 0x50},
+	{1, 0xEE92, 0xba},
+	{1, 0xEE93, 0x32},
+	{1, 0xEE94, 0x92},
+	{1, 0xEE95, 0x99},
+	{1, 0xEE96, 0x44},
+	{1, 0xEE97, 0x44},
+	{1, 0xEE98, 0x23},
+	{1, 0xEE99, 0x0d},
+	{1, 0xEE9A, 0x91},
+	{1, 0xEE9B, 0x08},
+	{1, 0xEE9C, 0x45},
+	{1, 0xEE9D, 0x30},
+	{1, 0xEE9E, 0x82},
+	{1, 0xEE9F, 0x92},
+	{1, 0xEEA0, 0x98},
+	{1, 0xEEA1, 0x28},
+	{1, 0xEEA2, 0x65},
+	{1, 0xEEA3, 0x2b},
+	{1, 0xEEA4, 0x63},
+	{1, 0xEEA5, 0xc9},
+	{1, 0xEEA6, 0xcb},
+	{1, 0xEEA7, 0x53},
+	{1, 0xEEA8, 0xda},
+	{1, 0xEEA9, 0x52},
+	{1, 0xEEAA, 0x93},
+	{1, 0xEEAB, 0xa5},
+	{1, 0xEEAC, 0x60},
+	{1, 0xEEAD, 0x84},
+	{1, 0xEEAE, 0x24},
+	{1, 0xEEAF, 0x05},
+	{1, 0xEEB0, 0x59},
+	{1, 0xEEB1, 0x08},
+	{1, 0xEEB2, 0x40},
+	{1, 0xEEB3, 0x02},
+	{1, 0xEEB4, 0x82},
+	{1, 0xEEB5, 0x90},
+	{1, 0xEEB6, 0x84},
+	{1, 0xEEB7, 0x74},
+	{1, 0xEEB8, 0x24},
+	{1, 0xEEB9, 0x24},
+	{1, 0xEEBA, 0x3b},
+	{1, 0xEEBB, 0x41},
+	{1, 0xEEBC, 0x4a},
+	{1, 0xEEBD, 0x55},
+	{1, 0xEEBE, 0xce},
+	{1, 0xEEBF, 0xf2},
+	{1, 0xEEC0, 0x94},
+	{1, 0xEEC1, 0xb5},
+	{1, 0xEEC2, 0xd8},
+	{1, 0xEEC3, 0x24},
+	{1, 0xEEC4, 0x29},
+	{1, 0xEEC5, 0x18},
+	{1, 0xEEC6, 0x19},
+	{1, 0xEEC7, 0x49},
+	{1, 0xEEC8, 0x41},
+	{1, 0xEEC9, 0x14},
+	{1, 0xEECA, 0x02},
+	{1, 0xEECB, 0x10},
+	{1, 0xEECC, 0x80},
+	{1, 0xEECD, 0x20},
+	{1, 0xEECE, 0x04},
+	{1, 0xEECF, 0x21},
+	{1, 0xEED0, 0x1c},
+	{1, 0xEED1, 0x01},
+	{1, 0xEED2, 0x89},
+	{1, 0xEED3, 0x4e},
+	{1, 0xEED4, 0x90},
+	{1, 0xEED5, 0x32},
+	{1, 0xEED6, 0x95},
+	{1, 0xEED7, 0xb3},
+	{1, 0xEED8, 0x7c},
+	{1, 0xEED9, 0x45},
+	{1, 0xEEDA, 0x2f},
+	{1, 0xEEDB, 0x45},
+	{1, 0xEEDC, 0xd1},
+	{1, 0xEEDD, 0x4a},
+	{1, 0xEEDE, 0x49},
+	{1, 0xEEDF, 0x62},
+	{1, 0xEEE0, 0x12},
+	{1, 0xEEE1, 0x11},
+	{1, 0xEEE2, 0x8c},
+	{1, 0xEEE3, 0x34},
+	{1, 0xEEE4, 0xe4},
+	{1, 0xEEE5, 0x21},
+	{1, 0xEEE6, 0x13},
+	{1, 0xEEE7, 0xb1},
+	{1, 0xEEE8, 0xc8},
+	{1, 0xEEE9, 0x49},
+	{1, 0xEEEA, 0x5c},
+	{1, 0xEEEB, 0x72},
+	{1, 0xEEEC, 0x94},
+	{1, 0xEEED, 0xac},
+	{1, 0xEEEE, 0x7c},
+	{1, 0xEEEF, 0x05},
+	{1, 0xEEF0, 0x2f},
+	{1, 0xEEF1, 0x77},
+	{1, 0xEEF2, 0x99},
+	{1, 0xEEF3, 0xcc},
+	{1, 0xEEF4, 0x58},
+	{1, 0xEEF5, 0xf6},
+	{1, 0xEEF6, 0x32},
+	{1, 0xEEF7, 0x94},
+	{1, 0xEEF8, 0xa9},
+	{1, 0xEEF9, 0xc0},
+	{1, 0xEEFA, 0x64},
+	{1, 0xEEFB, 0x27},
+	{1, 0xEEFC, 0x28},
+	{1, 0xEEFD, 0x81},
+	{1, 0xEEFE, 0x09},
+	{1, 0xEEFF, 0x4c},
+	{1, 0xEF00, 0x74},
+	{1, 0xEF01, 0x32},
+	{1, 0xEF02, 0x14},
+	{1, 0xEF03, 0xa9},
+	{1, 0xEF04, 0x88},
+	{1, 0xEF05, 0x65},
+	{1, 0xEF06, 0x2f},
+	{1, 0xEF07, 0x72},
+	{1, 0xEF08, 0x91},
+	{1, 0xEF09, 0xcc},
+	{1, 0xEF0A, 0x64},
+	{1, 0xEF0B, 0x66},
+	{1, 0xEF0C, 0x73},
+	{1, 0xEF0D, 0x18},
+	{1, 0xEF0E, 0xd1},
+	{1, 0xEF0F, 0xb0},
+	{1, 0xEF10, 0x25},
+	{1, 0xEF11, 0x30},
+	{1, 0xEF12, 0x5a},
+	{1, 0xEF13, 0x59},
+	{1, 0xEF14, 0x0b},
+	{1, 0xEF15, 0x55},
+	{1, 0xEF16, 0xca},
+	{1, 0xEF17, 0x82},
+	{1, 0xEF18, 0x95},
+	{1, 0xEF19, 0xb5},
+	{1, 0xEF1A, 0xa0},
+	{1, 0xEF1B, 0x45},
+	{1, 0xEF1C, 0x30},
+	{1, 0xEF1D, 0x83},
+	{1, 0xEF1E, 0x31},
+	{1, 0xEF1F, 0x0d},
+	{1, 0xEF20, 0x63},
+	{1, 0xEF21, 0x68},
+	{1, 0xEF22, 0xf3},
+	{1, 0xEF23, 0x9a},
+	{1, 0xEF24, 0xea},
+	{1, 0xEF25, 0xa8},
+	{1, 0xEF26, 0x86},
+	{1, 0xEF27, 0x39},
+	{1, 0xEF28, 0x98},
+	{1, 0xEF29, 0xa1},
+	{1, 0xEF2A, 0xcd},
+	{1, 0xEF2B, 0x62},
+	{1, 0xEF2C, 0x4a},
+	{1, 0xEF2D, 0x13},
+	{1, 0xEF2E, 0x98},
+	{1, 0xEF2F, 0xcd},
+	{1, 0xEF30, 0x1c},
+	{1, 0xEF31, 0x86},
+	{1, 0xEF32, 0x34},
+	{1, 0xEF33, 0x92},
+	{1, 0xEF34, 0xb1},
+	{1, 0xEF35, 0x0d},
+	{1, 0xEF36, 0x69},
+	{1, 0xEF37, 0xa2},
+	{1, 0xEF38, 0x73},
+	{1, 0xEF39, 0x1a},
+	{1, 0xEF3A, 0xeb},
+	{1, 0xEF3B, 0xc8},
+	{1, 0xEF3C, 0xc6},
+	{1, 0xEF3D, 0x3b},
+	{1, 0xEF3E, 0xa7},
+	{1, 0xEF3F, 0x89},
+	{1, 0xEF40, 0x4e},
+	{1, 0xEF41, 0x66},
+	{1, 0xEF42, 0x7c},
+	{1, 0xEF43, 0x13},
+	{1, 0xEF44, 0x99},
+	{1, 0xEF45, 0xd9},
+	{1, 0xEF46, 0x34},
+	{1, 0xEF47, 0x06},
+	{1, 0xEF48, 0x36},
+	{1, 0xEF49, 0x8c},
+	{1, 0xEF4A, 0xa1},
+	{1, 0xEF4B, 0xcd},
+	{1, 0xEF4C, 0x64},
+	{1, 0xEF4D, 0x80},
+	{1, 0xEF4E, 0xf3},
+	{1, 0xEF4F, 0x19},
+	{1, 0xEF50, 0xea},
+	{1, 0xEF51, 0x98},
+	{1, 0xEF52, 0xc6},
+	{1, 0xEF53, 0x3b},
+	                                                                          
+	//SHD2                               
+	{1, 0xEF54, 0xf7},
+	{1, 0xEF55, 0x89},
+	{1, 0xEF56, 0x8f},
+	{1, 0xEF57, 0x77},
+	{1, 0xEF58, 0xa0},
+	{1, 0xEF59, 0xc3},
+	{1, 0xEF5A, 0x1c},
+	{1, 0xEF5B, 0xe8},
+	{1, 0xEF5C, 0x7c},
+	{1, 0xEF5D, 0x67},
+	{1, 0xEF5E, 0x3e},
+	{1, 0xEF5F, 0xf3},
+	{1, 0xEF60, 0x99},
+	{1, 0xEF61, 0xcf},
+	{1, 0xEF62, 0x7a},
+	{1, 0xEF63, 0x9c},
+	{1, 0xEF64, 0xb3},
+	{1, 0xEF65, 0x1b},
+	{1, 0xEF66, 0xd8},
+	{1, 0xEF67, 0xe8},
+	{1, 0xEF68, 0xc6},
+	{1, 0xEF69, 0x39},
+	{1, 0xEF6A, 0xed},
+	{1, 0xEF6B, 0x99},
+	{1, 0xEF6C, 0x0f},
+	{1, 0xEF6D, 0x73},
+	{1, 0xEF6E, 0x70},
+	{1, 0xEF6F, 0xf3},
+	{1, 0xEF70, 0x98},
+	{1, 0xEF71, 0xba},
+	{1, 0xEF72, 0xb4},
+	{1, 0xEF73, 0x85},
+	{1, 0xEF74, 0x2e},
+	{1, 0xEF75, 0x8d},
+	{1, 0xEF76, 0xc1},
+	{1, 0xEF77, 0x4d},
+	{1, 0xEF78, 0x73},
+	{1, 0xEF79, 0x4c},
+	{1, 0xEF7A, 0x93},
+	{1, 0xEF7B, 0x18},
+	{1, 0xEF7C, 0xad},
+	{1, 0xEF7D, 0xf8},
+	{1, 0xEF7E, 0x24},
+	{1, 0xEF7F, 0x26},
+	{1, 0xEF80, 0x3c},
+	{1, 0xEF81, 0xc1},
+	{1, 0xEF82, 0x0a},
+	{1, 0xEF83, 0x62},
+	{1, 0xEF84, 0x4a},
+	{1, 0xEF85, 0xa3},
+	{1, 0xEF86, 0x98},
+	{1, 0xEF87, 0xb2},
+	{1, 0xEF88, 0xd4},
+	{1, 0xEF89, 0x04},
+	{1, 0xEF8A, 0x23},
+	{1, 0xEF8B, 0x0f},
+	{1, 0xEF8C, 0xb9},
+	{1, 0xEF8D, 0xc8},
+	{1, 0xEF8E, 0x4c},
+	{1, 0xEF8F, 0xc6},
+	{1, 0xEF90, 0x72},
+	{1, 0xEF91, 0x98},
+	{1, 0xEF92, 0xbd},
+	{1, 0xEF93, 0x50},
+	{1, 0xEF94, 0xe5},
+	{1, 0xEF95, 0x24},
+	{1, 0xEF96, 0x0b},
+	{1, 0xEF97, 0x01},
+	{1, 0xEF98, 0x48},
+	{1, 0xEF99, 0x42},
+	{1, 0xEF9A, 0x4a},
+	{1, 0xEF9B, 0x32},
+	{1, 0xEF9C, 0x15},
+	{1, 0xEF9D, 0xbc},
+	{1, 0xEF9E, 0xf4},
+	{1, 0xEF9F, 0xe5},
+	{1, 0xEFA0, 0x2a},
+	{1, 0xEFA1, 0x2a},
+	{1, 0xEFA2, 0x69},
+	{1, 0xEFA3, 0x88},
+	{1, 0xEFA4, 0x40},
+	{1, 0xEFA5, 0x18},
+	{1, 0xEFA6, 0x82},
+	{1, 0xEFA7, 0x12},
+	{1, 0xEFA8, 0xab},
+	{1, 0xEFA9, 0xf0},
+	{1, 0xEFAA, 0x65},
+	{1, 0xEFAB, 0x32},
+	{1, 0xEFAC, 0x6d},
+	{1, 0xEFAD, 0xe1},
+	{1, 0xEFAE, 0xc9},
+	{1, 0xEFAF, 0x47},
+	{1, 0xEFB0, 0x2c},
+	{1, 0xEFB1, 0xe2},
+	{1, 0xEFB2, 0x91},
+	{1, 0xEFB3, 0x9d},
+	{1, 0xEFB4, 0xb0},
+	{1, 0xEFB5, 0x25},
+	{1, 0xEFB6, 0x32},
+	{1, 0xEFB7, 0xb3},
+	{1, 0xEFB8, 0xa9},
+	{1, 0xEFB9, 0x4c},
+	{1, 0xEFBA, 0x59},
+	{1, 0xEFBB, 0x90},
+	{1, 0xEFBC, 0xc2},
+	{1, 0xEFBD, 0x13},
+	{1, 0xEFBE, 0xa4},
+	{1, 0xEFBF, 0x94},
+	{1, 0xEFC0, 0xa5},
+	{1, 0xEFC1, 0x32},
+	{1, 0xEFC2, 0xb2},
+	{1, 0xEFC3, 0xe1},
+	{1, 0xEFC4, 0xce},
+	{1, 0xEFC5, 0x71},
+	{1, 0xEFC6, 0x38},
+	{1, 0xEFC7, 0x03},
+	{1, 0xEFC8, 0x18},
+	{1, 0xEFC9, 0xbc},
+	{1, 0xEFCA, 0x00},
+	{1, 0xEFCB, 0x86},
+	{1, 0xEFCC, 0x33},
+	{1, 0xEFCD, 0xc8},
+	{1, 0xEFCE, 0xe1},
+	{1, 0xEFCF, 0xce},
+	{1, 0xEFD0, 0x81},
+	{1, 0xEFD1, 0xf8},
+	{1, 0xEFD2, 0xc3},
+	{1, 0xEFD3, 0x9d},
+	{1, 0xEFD4, 0xe3},
+	{1, 0xEFD5, 0xe8},
+	{1, 0xEFD6, 0xa6},
+	{1, 0xEFD7, 0x38},
+	{1, 0xEFD8, 0xdb},
+	{1, 0xEFD9, 0xe1},
+	{1, 0xEFDA, 0x8f},
+	{1, 0xEFDB, 0x81},
+	{1, 0xEFDC, 0x1e},
+	{1, 0xEFDD, 0xe4},
+	{1, 0xEFDE, 0x1f},
+	{1, 0xEFDF, 0xf3},
+	{1, 0xEFE0, 0x5c},
+	{1, 0xEFE1, 0x47},
+	{1, 0xEFE2, 0x3a},
+	{1, 0xEFE3, 0xd5},
+	{1, 0xEFE4, 0x29},
+	{1, 0xEFE5, 0x8f},
+	{1, 0xEFE6, 0x7f},
+	{1, 0xEFE7, 0x12},
+	{1, 0xEFE8, 0x04},
+	{1, 0xEFE9, 0x00},
+	{1, 0xEFEA, 0x00},
+	{1, 0xEFEB, 0xd0},
+	{1, 0xEFEC, 0x05},
+	{1, 0xEFED, 0x00},
+	                                     
+	//SHD3                               
+	{1, 0xEFEE, 0x68},
+	{1, 0xEFEF, 0xf2},
+	{1, 0xEFF0, 0x92},
+	{1, 0xEFF1, 0x91},
+	{1, 0xEFF2, 0x6a},
+	{1, 0xEFF3, 0xe4},
+	{1, 0xEFF4, 0x22},
+	{1, 0xEFF5, 0x19},
+	{1, 0xEFF6, 0x19},
+	{1, 0xEFF7, 0x09},
+	{1, 0xEFF8, 0x4c},
+	{1, 0xEFF9, 0x62},
+	{1, 0xEFFA, 0x12},
+	{1, 0xEFFB, 0xd3},
+	{1, 0xEFFC, 0x94},
+	{1, 0xEFFD, 0x58},
+	{1, 0xEFFE, 0x24},
+	{1, 0xEFFF, 0xa1},
+	{1, 0xF000, 0x01},
+	{1, 0xF001, 0x41},
+	{1, 0xF002, 0x88},
+	{1, 0xF003, 0x45},
+	{1, 0xF004, 0x56},
+	{1, 0xF005, 0x02},
+	{1, 0xF006, 0x13},
+	{1, 0xF007, 0x8b},
+	{1, 0xF008, 0x16},
+	{1, 0xF009, 0x24},
+	{1, 0xF00A, 0x1d},
+	{1, 0xF00B, 0xd6},
+	{1, 0xF00C, 0x80},
+	{1, 0xF00D, 0x66},
+	{1, 0xF00E, 0x35},
+	{1, 0xF00F, 0xd1},
+	{1, 0xF010, 0x69},
+	{1, 0xF011, 0x10},
+	{1, 0xF012, 0x8b},
+	{1, 0xF013, 0xec},
+	{1, 0xF014, 0x83},
+	{1, 0xF015, 0x9c},
+	{1, 0xF016, 0xc1},
+	{1, 0xF017, 0x68},
+	{1, 0xF018, 0x25},
+	{1, 0xF019, 0x29},
+	{1, 0xF01A, 0x58},
+	{1, 0xF01B, 0x09},
+	{1, 0xF01C, 0xcc},
+	{1, 0xF01D, 0x71},
+	{1, 0xF01E, 0xea},
+	{1, 0xF01F, 0xd3},
+	{1, 0xF020, 0x9c},
+	{1, 0xF021, 0xc9},
+	{1, 0xF022, 0x30},
+	{1, 0xF023, 0x65},
+	{1, 0xF024, 0x24},
+	{1, 0xF025, 0x16},
+	{1, 0xF026, 0x11},
+	{1, 0xF027, 0x89},
+	{1, 0xF028, 0x52},
+	{1, 0xF029, 0x24},
+	{1, 0xF02A, 0xb3},
+	{1, 0xF02B, 0x1c},
+	{1, 0xF02C, 0xdb},
+	{1, 0xF02D, 0xe8},
+	{1, 0xF02E, 0xc5},
+	{1, 0xF02F, 0x26},
+	{1, 0xF030, 0x0e},
+	{1, 0xF031, 0x01},
+	{1, 0xF032, 0x48},
+	{1, 0xF033, 0x43},
+	{1, 0xF034, 0x6a},
+	{1, 0xF035, 0x92},
+	{1, 0xF036, 0x97},
+	{1, 0xF037, 0xda},
+	{1, 0xF038, 0xe4},
+	{1, 0xF039, 0xa6},
+	{1, 0xF03A, 0x2f},
+	{1, 0xF03B, 0x39},
+	{1, 0xF03C, 0x81},
+	{1, 0xF03D, 0x88},
+	{1, 0xF03E, 0x40},
+	{1, 0xF03F, 0x1e},
+	{1, 0xF040, 0x82},
+	{1, 0xF041, 0x93},
+	{1, 0xF042, 0xbe},
+	{1, 0xF043, 0xe0},
+	{1, 0xF044, 0xe6},
+	{1, 0xF045, 0x3a},
+	{1, 0xF046, 0x9b},
+	{1, 0xF047, 0xa1},
+	{1, 0xF048, 0x8a},
+	{1, 0xF049, 0x4a},
+	{1, 0xF04A, 0x3c},
+	{1, 0xF04B, 0xa2},
+	{1, 0xF04C, 0x12},
+	{1, 0xF04D, 0xaa},
+	{1, 0xF04E, 0x70},
+	{1, 0xF04F, 0xc6},
+	{1, 0xF050, 0x3a},
+	{1, 0xF051, 0x05},
+	{1, 0xF052, 0xa2},
+	{1, 0xF053, 0x8e},
+	{1, 0xF054, 0x63},
+	{1, 0xF055, 0xc8},
+	{1, 0xF056, 0x42},
+	{1, 0xF057, 0x95},
+	{1, 0xF058, 0xb2},
+	{1, 0xF059, 0x40},
+	{1, 0xF05A, 0xc6},
+	{1, 0xF05B, 0x3a},
+	{1, 0xF05C, 0x04},
+	{1, 0xF05D, 0xea},
+	{1, 0xF05E, 0x11},
+	{1, 0xF05F, 0x87},
+	{1, 0xF060, 0xbe},
+	{1, 0xF061, 0x83},
+	{1, 0xF062, 0x1b},
+	{1, 0xF063, 0xd6},
+	{1, 0xF064, 0xe4},
+	{1, 0xF065, 0x26},
+	{1, 0xF066, 0x3c},
+	{1, 0xF067, 0x1f},
+	{1, 0xF068, 0xf2},
+	{1, 0xF069, 0x51},
+	{1, 0xF06A, 0x9d},
+	{1, 0xF06B, 0xc6},
+	{1, 0xF06C, 0x94},
+	{1, 0xF06D, 0xa3},
+	{1, 0xF06E, 0x0e},
+	{1, 0xF06F, 0x35},
+	{1, 0xF070, 0x68},
+	{1, 0xF071, 0x43},
+	{1, 0xF072, 0x39},
+	{1, 0xF073, 0x32},
+	{1, 0xF074, 0x53},
+	{1, 0xF075, 0x9d},
+	{1, 0xF076, 0x04},
+	{1, 0xF077, 0xb5},
+	{1, 0xF078, 0x26},
+	{1, 0xF079, 0x26},
+	{1, 0xF07A, 0xe1},
+	{1, 0xF07B, 0x28},
+	{1, 0xF07C, 0x46},
+	{1, 0xF07D, 0x36},
+	{1, 0xF07E, 0x52},
+	{1, 0xF07F, 0xd2},
+	{1, 0xF080, 0x9a},
+	{1, 0xF081, 0xfc},
+	{1, 0xF082, 0x14},
+	{1, 0xF083, 0x9c},
+	{1, 0xF084, 0xdd},
+	{1, 0xF085, 0xb8},
+	{1, 0xF086, 0xc6},
+	{1, 0xF087, 0x34},
+	{1, 0xF088, 0xc1},
+	{1, 0xF089, 0xd9},
+	{1, 0xF08A, 0x8d},
+	{1, 0xF08B, 0x6b},
+	{1, 0xF08C, 0x4c},
+	{1, 0xF08D, 0x43},
+	{1, 0xF08E, 0x9a},
+	{1, 0xF08F, 0xd4},
+	{1, 0xF090, 0xdc},
+	{1, 0xF091, 0x26},
+	{1, 0xF092, 0x39},
+	{1, 0xF093, 0xcb},
+	{1, 0xF094, 0x01},
+	{1, 0xF095, 0x8e},
+	{1, 0xF096, 0x6e},
+	{1, 0xF097, 0x4c},
+	{1, 0xF098, 0xa3},
+	{1, 0xF099, 0x19},
+	{1, 0xF09A, 0xc9},
+	{1, 0xF09B, 0x74},
+	{1, 0xF09C, 0xe6},
+	{1, 0xF09D, 0x35},
+	{1, 0xF09E, 0xc9},
+	{1, 0xF09F, 0x71},
+	{1, 0xF0A0, 0x8e},
+	{1, 0xF0A1, 0x68},
+	{1, 0xF0A2, 0x28},
+	{1, 0xF0A3, 0x73},
+	{1, 0xF0A4, 0x97},
+	{1, 0xF0A5, 0xb2},
+	{1, 0xF0A6, 0x88},
+	{1, 0xF0A7, 0x45},
+	{1, 0xF0A8, 0x2d},
+	{1, 0xF0A9, 0x80},
+	{1, 0xF0AA, 0x11},
+	{1, 0xF0AB, 0x0d},
+	{1, 0xF0AC, 0x6c},
+	{1, 0xF0AD, 0x0a},
+	{1, 0xF0AE, 0x13},
+	{1, 0xF0AF, 0x97},
+	{1, 0xF0B0, 0xa7},
+	{1, 0xF0B1, 0xe8},
+	{1, 0xF0B2, 0x24},
+	{1, 0xF0B3, 0x26},
+	{1, 0xF0B4, 0x3c},
+	{1, 0xF0B5, 0xa1},
+	{1, 0xF0B6, 0x0a},
+	{1, 0xF0B7, 0x5f},
+	{1, 0xF0B8, 0x24},
+	{1, 0xF0B9, 0xe3},
+	{1, 0xF0BA, 0x16},
+	{1, 0xF0BB, 0xa9},
+	{1, 0xF0BC, 0xb8},
+	{1, 0xF0BD, 0x04},
+	{1, 0xF0BE, 0x23},
+	{1, 0xF0BF, 0x12},
+	{1, 0xF0C0, 0xd1},
+	{1, 0xF0C1, 0x88},
+	{1, 0xF0C2, 0x4c},
+	{1, 0xF0C3, 0xb6},
+	{1, 0xF0C4, 0x82},
+	{1, 0xF0C5, 0x97},
+	{1, 0xF0C6, 0xaf},
+	{1, 0xF0C7, 0x04},
+	{1, 0xF0C8, 0xe5},
+	{1, 0xF0C9, 0x23},
+	{1, 0xF0CA, 0x09},
+	{1, 0xF0CB, 0x09},
+	{1, 0xF0CC, 0xc8},
+	{1, 0xF0CD, 0x42},
+	{1, 0xF0CE, 0x46},
+	{1, 0xF0CF, 0x92},
+	{1, 0xF0D0, 0x94},
+	{1, 0xF0D1, 0xb3},
+	{1, 0xF0D2, 0x7c},
+	{1, 0xF0D3, 0x05},
+	{1, 0xF0D4, 0x28},
+	{1, 0xF0D5, 0x1e},
+	{1, 0xF0D6, 0x39},
+	{1, 0xF0D7, 0x08},
+	{1, 0xF0D8, 0x40},
+	{1, 0xF0D9, 0x12},
+	{1, 0xF0DA, 0x12},
+	{1, 0xF0DB, 0x12},
+	{1, 0xF0DC, 0xa3},
+	{1, 0xF0DD, 0x90},
+	{1, 0xF0DE, 0xa5},
+	{1, 0xF0DF, 0x2d},
+	{1, 0xF0E0, 0x50},
+	{1, 0xF0E1, 0x59},
+	{1, 0xF0E2, 0x09},
+	{1, 0xF0E3, 0x45},
+	{1, 0xF0E4, 0x1c},
+	{1, 0xF0E5, 0x52},
+	{1, 0xF0E6, 0x91},
+	{1, 0xF0E7, 0x96},
+	{1, 0xF0E8, 0x50},
+	{1, 0xF0E9, 0x25},
+	{1, 0xF0EA, 0x2e},
+	{1, 0xF0EB, 0x85},
+	{1, 0xF0EC, 0x71},
+	{1, 0xF0ED, 0xcb},
+	{1, 0xF0EE, 0x52},
+	{1, 0xF0EF, 0x6a},
+	{1, 0xF0F0, 0xc2},
+	{1, 0xF0F1, 0x12},
+	{1, 0xF0F2, 0x9b},
+	{1, 0xF0F3, 0x30},
+	{1, 0xF0F4, 0x45},
+	{1, 0xF0F5, 0x2e},
+	{1, 0xF0F6, 0x87},
+	{1, 0xF0F7, 0x29},
+	{1, 0xF0F8, 0x4d},
+	{1, 0xF0F9, 0x65},
+	{1, 0xF0FA, 0xee},
+	{1, 0xF0FB, 0x22},
+	{1, 0xF0FC, 0x16},
+	{1, 0xF0FD, 0xae},
+	{1, 0xF0FE, 0x88},
+	{1, 0xF0FF, 0xc5},
+	{1, 0xF100, 0x2e},
+	{1, 0xF101, 0x98},
+	{1, 0xF102, 0x29},
+	{1, 0xF103, 0x8d},
+	{1, 0xF104, 0x71},
+	{1, 0xF105, 0x7a},
+	{1, 0xF106, 0x73},
+	{1, 0xF107, 0x1a},
+	{1, 0xF108, 0xcc},
+	{1, 0xF109, 0x38},
+	{1, 0xF10A, 0xe6},
+	{1, 0xF10B, 0x32},
+	{1, 0xF10C, 0xa6},
+	{1, 0xF10D, 0xf1},
+	{1, 0xF10E, 0x0d},
+	{1, 0xF10F, 0x71},
+	{1, 0xF110, 0x96},
+	{1, 0xF111, 0xd3},
+	{1, 0xF112, 0x1b},
+	{1, 0xF113, 0xd5},
+	{1, 0xF114, 0x84},
+	{1, 0xF115, 0xa6},
+	{1, 0xF116, 0x33},
+	{1, 0xF117, 0x9f},
+	{1, 0xF118, 0x51},
+	{1, 0xF119, 0xcd},
+	{1, 0xF11A, 0x6e},
+	{1, 0xF11B, 0x8e},
+	{1, 0xF11C, 0x03},
+	{1, 0xF11D, 0x00},
+	{1, 0xF11E, 0xf4},
+	{1, 0xF11F, 0x53},
+	{1, 0xF120, 0xcb},
+	{1, 0xF121, 0x92},
+
+	//SHD TH 
+	{2, 0x6C32, 0x19C8},    // SHD_INP_TH_HB_H_R2
+	{2, 0x6C34, 0x1900},    // SHD_INP_TH_HB_L_R2
+	{2, 0x6C36, 0x10CC},    // SHD_INP_TH_LB_H_R2
+	{2, 0x6C38, 0x1004},    // SHD_INP_TH_LB_L_R2
+	{1, 0x6C3A, 0x58},       // SHD_GAIN_TH_H : 
+	{1, 0x6C3B, 0x48},       // SHD_GAIN_TH_L : 
+	{2, 0x6C3C, 0x10CC},    // SHD_INP_TH_HB_H_RB
+	{2, 0x6C3E, 0x1004},    // SHD_INP_TH_HB_L_RB
+	{2, 0x6C40, 0x0000},    // SHD_INP_TH_LB_H_RB
+	{2, 0x6C42, 0x0000},    // SHD_INP_TH_LB_L_RB
+	                                     
+	//SHD ON                             
+	{1, 0x01BC, 0x5D},  //[3]SHD_GAINCTRL_EN [2]SHD_INP_EN [0]SHD_EN
+	                                     
+	//PreWB                              
+	{2, 0x6804, 0x0B89},    // NORMR
+	{2, 0x6806, 0x1080},    // NORMB
+	{2, 0x6808, 0x0110},    // AWBPRER
+	{2, 0x680A, 0x0245},    // AWBPREB
+	                                     
+	//IN/OUT JUDGPOS                     
+	{1, 0x6258, 0xB0},  //INJUDGPOS
+	{1, 0x6259, 0xBA},  //OUTJUDGPOS
+	                                     
+	//AWB                                
+	{2, 0x6238, 0x0B6C},    // INIT_CONT_INR : 
+	{2, 0x623A, 0x187B},    // INIT_CONT_INB : 
+	{2, 0x623C, 0x0B6C},    // INIT_CONT_OUTR : 
+	{2, 0x623E, 0x187B},    // INIT_CONT_OUTB : 
+	{1, 0x629C, 0x60},    // FRMOUT_RATIO_BLEND1_IN : 0x80=INIT_CONT
+	{1, 0x629D, 0x80},    // FRMOUT_RATIO_BLEND1_OUT : 
+	{1, 0x629E, 0x60},    // FRMOUT_RATIO_BLEND2_IN : 0x80=Previous Ratio
+	{1, 0x629F, 0x00},    // FRMOUT_RATIO_BLEND2_OUT :
+	{2, 0x62CA, 0x0000},    // A_LIGHT_AIM_SHIFT_R : 
+	{2, 0x62CC, 0x0000},    // A_LIGHT_AIM_SHIFT_B : 
+	{1, 0x6400, 0xAA},    // INFRM_LEFT00 :
+	{1, 0x6401, 0xAA},    // INFRM_LEFT01 :
+	{1, 0x6402, 0xAA},    // INFRM_LEFT02 :
+	{1, 0x6403, 0xAA},    // INFRM_LEFT03 :
+	{1, 0x6404, 0xAA},    // INFRM_LEFT04 :
+	{1, 0x6405, 0xAA},    // INFRM_LEFT05 :
+	{1, 0x6406, 0xAA},    // INFRM_LEFT06 :
+	{1, 0x6407, 0xAA},    // INFRM_LEFT07 :
+	{1, 0x6408, 0xAA},    // INFRM_LEFT08 :
+	{1, 0x6409, 0xAE},    // INFRM_LEFT09 :
+	{1, 0x640A, 0xA0},    // INFRM_LEFT10 :
+	{1, 0x640B, 0x8C},    // INFRM_LEFT11 :
+	{1, 0x640C, 0x72},    // INFRM_LEFT12 :
+	{1, 0x640D, 0x64},    // INFRM_LEFT13 :
+	{1, 0x640E, 0x5A},    // INFRM_LEFT14 :
+	{1, 0x640F, 0x52},    // INFRM_LEFT15 :
+	{1, 0x6410, 0x4B},    // INFRM_LEFT16 :
+	{1, 0x6411, 0x46},    // INFRM_LEFT17 :
+	{1, 0x6412, 0x40},    // INFRM_LEFT18 :
+	{1, 0x6413, 0x3A},    // INFRM_LEFT19 :
+	{1, 0x6414, 0x36},    // INFRM_LEFT20 :
+	{1, 0x6415, 0x34},    // INFRM_LEFT21 :
+	{1, 0x6416, 0x33},    // INFRM_LEFT22 :
+	{1, 0x6417, 0x32},    // INFRM_LEFT23 :
+	{1, 0x6418, 0x31},    // INFRM_LEFT24 :
+	{1, 0x6419, 0x2F},    // INFRM_LEFT25 :
+	{1, 0x641A, 0x2D},    // INFRM_LEFT26 :
+	{1, 0x641B, 0x2A},    // INFRM_LEFT27 :
+	{1, 0x641C, 0x28},    // INFRM_LEFT28 :
+	{1, 0x641D, 0x26},    // INFRM_LEFT29 :
+	{1, 0x641E, 0x23},    // INFRM_LEFT30 :
+	{1, 0x641F, 0x23},    // INFRM_LEFT31 :
+	{1, 0x6420, 0x22},    // INFRM_LEFT32 :
+	{1, 0x6421, 0x1A},    // INFRM_LEFT33 :
+	{1, 0x6422, 0x18},    // INFRM_LEFT34 :
+	{1, 0x6423, 0x17},    // INFRM_LEFT35 :
+	{1, 0x6424, 0x16},    // INFRM_LEFT36 :
+	{1, 0x6425, 0x16},    // INFRM_LEFT37 :
+	{1, 0x6426, 0xAF},    // INFRM_RIGHT00 :
+	{1, 0x6427, 0xAF},    // INFRM_RIGHT01 :
+	{1, 0x6428, 0xAF},    // INFRM_RIGHT02 :
+	{1, 0x6429, 0xAF},    // INFRM_RIGHT03 :
+	{1, 0x642A, 0xAF},    // INFRM_RIGHT04 :
+	{1, 0x642B, 0xAF},    // INFRM_RIGHT05 :
+	{1, 0x642C, 0xAF},    // INFRM_RIGHT06 :
+	{1, 0x642D, 0xAF},    // INFRM_RIGHT07 :
+	{1, 0x642E, 0xAF},    // INFRM_RIGHT08 :
+	{1, 0x642F, 0xAA},    // INFRM_RIGHT09 :
+	{1, 0x6430, 0xB2},    // INFRM_RIGHT10 :
+	{1, 0x6431, 0xB4},    // INFRM_RIGHT11 :
+	{1, 0x6432, 0xB6},    // INFRM_RIGHT12 :
+	{1, 0x6433, 0xB4},    // INFRM_RIGHT13 :
+	{1, 0x6434, 0x9B},    // INFRM_RIGHT14 :
+	{1, 0x6435, 0x82},    // INFRM_RIGHT15 :
+	{1, 0x6436, 0x78},    // INFRM_RIGHT16 :
+	{1, 0x6437, 0x6E},    // INFRM_RIGHT17 :
+	{1, 0x6438, 0x5D},    // INFRM_RIGHT18 :
+	{1, 0x6439, 0x4D},    // INFRM_RIGHT19 :
+	{1, 0x643A, 0x4A},    // INFRM_RIGHT20 :
+	{1, 0x643B, 0x46},    // INFRM_RIGHT21 :
+	{1, 0x643C, 0x42},    // INFRM_RIGHT22 :
+	{1, 0x643D, 0x43},    // INFRM_RIGHT23 :
+	{1, 0x643E, 0x44},    // INFRM_RIGHT24 :
+	{1, 0x643F, 0x47},    // INFRM_RIGHT25 :
+	{1, 0x6440, 0x46},    // INFRM_RIGHT26 :
+	{1, 0x6441, 0x42},    // INFRM_RIGHT27 :
+	{1, 0x6442, 0x3F},    // INFRM_RIGHT28 :
+	{1, 0x6443, 0x3C},    // INFRM_RIGHT29 :
+	{1, 0x6444, 0x3A},    // INFRM_RIGHT30 :
+	{1, 0x6445, 0x38},    // INFRM_RIGHT31 :
+	{1, 0x6446, 0x37},    // INFRM_RIGHT32 :
+	{1, 0x6447, 0x2E},    // INFRM_RIGHT33 :
+	{1, 0x6448, 0x2D},    // INFRM_RIGHT34 :
+	{1, 0x6449, 0x2C},    // INFRM_RIGHT35 :
+	{1, 0x644A, 0x2C},    // INFRM_RIGHT36 :
+	{1, 0x644B, 0x36},    // INFRM_RIGHT37 :
+	{2, 0x644C, 0x1F40},    // INFRM_TOP :
+	{2, 0x644E, 0x0940},    // INFRM_BOTM :
+	{1, 0x6450, 0x19},    // INFRM_FLTOP :
+	{1, 0x6451, 0x10},    // INFRM_FLBOTM :
+	{1, 0x6452, 0x91},    // INAIM_LEFT00 :
+	{1, 0x6453, 0x91},    // INAIM_LEFT01 :
+	{1, 0x6454, 0x91},    // INAIM_LEFT02 :
+	{1, 0x6455, 0x91},    // INAIM_LEFT03 :
+	{1, 0x6456, 0x91},    // INAIM_LEFT04 :
+	{1, 0x6457, 0x91},    // INAIM_LEFT05 :
+	{1, 0x6458, 0x91},    // INAIM_LEFT06 :
+	{1, 0x6459, 0x91},    // INAIM_LEFT07 :
+	{1, 0x645A, 0x91},    // INAIM_LEFT08 :
+	{1, 0x645B, 0x91},    // INAIM_LEFT09 :
+	{1, 0x645C, 0x91},    // INAIM_LEFT10 :
+	{1, 0x645D, 0x91},    // INAIM_LEFT11 :
+	{1, 0x645E, 0x91},    // INAIM_LEFT12 :
+	{1, 0x645F, 0x66},    // INAIM_LEFT13 :
+	{1, 0x6460, 0x5D},    // INAIM_LEFT14 :
+	{1, 0x6461, 0x55},    // INAIM_LEFT15 :
+	{1, 0x6462, 0x4E},    // INAIM_LEFT16 :
+	{1, 0x6463, 0x47},    // INAIM_LEFT17 :
+	{1, 0x6464, 0x42},    // INAIM_LEFT18 :
+	{1, 0x6465, 0x3C},    // INAIM_LEFT19 :
+	{1, 0x6466, 0x38},    // INAIM_LEFT20 :
+	{1, 0x6467, 0x36},    // INAIM_LEFT21 :
+	{1, 0x6468, 0x35},    // INAIM_LEFT22 :
+	{1, 0x6469, 0x33},    // INAIM_LEFT23 :
+	{1, 0x646A, 0x32},    // INAIM_LEFT24 :
+	{1, 0x646B, 0x30},    // INAIM_LEFT25 :
+	{1, 0x646C, 0x2F},    // INAIM_LEFT26 :
+	{1, 0x646D, 0x2D},    // INAIM_LEFT27 :
+	{1, 0x646E, 0x2C},    // INAIM_LEFT28 :
+	{1, 0x646F, 0x2B},    // INAIM_LEFT29 :
+	{1, 0x6470, 0x2A},    // INAIM_LEFT30 :
+	{1, 0x6471, 0x28},    // INAIM_LEFT31 :
+	{1, 0x6472, 0x26},    // INAIM_LEFT32 :
+	{1, 0x6473, 0x24},    // INAIM_LEFT33 :
+	{1, 0x6474, 0x29},    // INAIM_LEFT34 :
+	{1, 0x6475, 0x28},    // INAIM_LEFT35 :
+	{1, 0x6476, 0x29},    // INAIM_LEFT36 :
+	{1, 0x6477, 0x26},    // INAIM_LEFT37 :
+	{1, 0x6478, 0xFF},    // INAIM_RIGHT00 :
+	{1, 0x6479, 0xFF},    // INAIM_RIGHT01 :
+	{1, 0x647A, 0xFF},    // INAIM_RIGHT02 :
+	{1, 0x647B, 0xFF},    // INAIM_RIGHT03 :
+	{1, 0x647C, 0xFF},    // INAIM_RIGHT04 :
+	{1, 0x647D, 0xFF},    // INAIM_RIGHT05 :
+	{1, 0x647E, 0xFF},    // INAIM_RIGHT06 :
+	{1, 0x647F, 0xFF},    // INAIM_RIGHT07 :
+	{1, 0x6480, 0xFF},    // INAIM_RIGHT08 :
+	{1, 0x6481, 0xFF},    // INAIM_RIGHT09 :
+	{1, 0x6482, 0xD9},    // INAIM_RIGHT10 :
+	{1, 0x6483, 0xB7},    // INAIM_RIGHT11 :
+	{1, 0x6484, 0x96},    // INAIM_RIGHT12 :
+	{1, 0x6485, 0x68},    // INAIM_RIGHT13 :
+	{1, 0x6486, 0x70},    // INAIM_RIGHT14 :
+	{1, 0x6487, 0x72},    // INAIM_RIGHT15 :
+	{1, 0x6488, 0x71},    // INAIM_RIGHT16 :
+	{1, 0x6489, 0x6B},    // INAIM_RIGHT17 :
+	{1, 0x648A, 0x5D},    // INAIM_RIGHT18 :
+	{1, 0x648B, 0x4D},    // INAIM_RIGHT19 :
+	{1, 0x648C, 0x4A},    // INAIM_RIGHT20 :
+	{1, 0x648D, 0x46},    // INAIM_RIGHT21 :
+	{1, 0x648E, 0x42},    // INAIM_RIGHT22 :
+	{1, 0x648F, 0x43},    // INAIM_RIGHT23 :
+	{1, 0x6490, 0x44},    // INAIM_RIGHT24 :
+	{1, 0x6491, 0x44},    // INAIM_RIGHT25 :
+	{1, 0x6492, 0x41},    // INAIM_RIGHT26 :
+	{1, 0x6493, 0x3E},    // INAIM_RIGHT27 :
+	{1, 0x6494, 0x3B},    // INAIM_RIGHT28 :
+	{1, 0x6495, 0x39},    // INAIM_RIGHT29 :
+	{1, 0x6496, 0x37},    // INAIM_RIGHT30 :
+	{1, 0x6497, 0x34},    // INAIM_RIGHT31 :
+	{1, 0x6498, 0x33},    // INAIM_RIGHT32 :
+	{1, 0x6499, 0x32},    // INAIM_RIGHT33 :
+	{1, 0x649A, 0x31},    // INAIM_RIGHT34 :
+	{1, 0x649B, 0x30},    // INAIM_RIGHT35 :
+	{1, 0x649C, 0x2F},    // INAIM_RIGHT36 :
+	{1, 0x649D, 0x2E},    // INAIM_RIGHT37 :
+	{2, 0x649E, 0x1C20},    // INAIM_TOP :
+	{2, 0x64A0, 0x0D90},    // INAIM_BOTM :
+	{1, 0x64A2, 0x18},    // INAIM_FLTOP :
+	{1, 0x64A3, 0x10},    // INAIM_FLBOTM : 
+	{1, 0x64A4, 0xFF},    // OUTFRM_LEFT00 :
+	{1, 0x64A5, 0xFF},    // OUTFRM_LEFT01 :
+	{1, 0x64A6, 0xFF},    // OUTFRM_LEFT02 :
+	{1, 0x64A7, 0xFF},    // OUTFRM_LEFT03 :
+	{1, 0x64A8, 0xFF},    // OUTFRM_LEFT04 :
+	{1, 0x64A9, 0xFF},    // OUTFRM_LEFT05 :
+	{1, 0x64AA, 0xFF},    // OUTFRM_LEFT06 :
+	{1, 0x64AB, 0xFF},    // OUTFRM_LEFT07 :
+	{1, 0x64AC, 0xFF},    // OUTFRM_LEFT08 :
+	{1, 0x64AD, 0xFD},    // OUTFRM_LEFT09 :
+	{1, 0x64AE, 0xCB},    // OUTFRM_LEFT10 :
+	{1, 0x64AF, 0xA9},    // OUTFRM_LEFT11 :
+	{1, 0x64B0, 0x90},    // OUTFRM_LEFT12 :
+	{1, 0x64B1, 0x7D},    // OUTFRM_LEFT13 :
+	{1, 0x64B2, 0x70},    // OUTFRM_LEFT14 :
+	{1, 0x64B3, 0x65},    // OUTFRM_LEFT15 :
+	{1, 0x64B4, 0x5C},    // OUTFRM_LEFT16 :
+	{1, 0x64B5, 0x55},    // OUTFRM_LEFT17 :
+	{1, 0x64B6, 0x4F},    // OUTFRM_LEFT18 :
+	{1, 0x64B7, 0x32},    // OUTFRM_LEFT19 :
+	{1, 0x64B8, 0x4D},    // OUTFRM_LEFT20 :
+	{1, 0x64B9, 0x40},    // OUTFRM_LEFT21 :
+	{1, 0x64BA, 0x2D},    // OUTFRM_LEFT22 :
+	{1, 0x64BB, 0x2B},    // OUTFRM_LEFT23 :
+	{1, 0x64BC, 0x29},    // OUTFRM_LEFT24 :
+	{1, 0x64BD, 0x27},    // OUTFRM_LEFT25 :
+	{1, 0x64BE, 0x25},    // OUTFRM_LEFT26 :
+	{1, 0x64BF, 0x23},    // OUTFRM_LEFT27 :
+	{1, 0x64C0, 0x21},    // OUTFRM_LEFT28 :
+	{1, 0x64C1, 0x1F},    // OUTFRM_LEFT29 :
+	{1, 0x64C2, 0x1D},    // OUTFRM_LEFT30 :
+	{1, 0x64C3, 0x1B},    // OUTFRM_LEFT31 :
+	{1, 0x64C4, 0x1A},    // OUTFRM_LEFT32 :
+	{1, 0x64C5, 0x1A},    // OUTFRM_LEFT33 :
+	{1, 0x64C6, 0x1A},    // OUTFRM_LEFT34 :
+	{1, 0x64C7, 0x28},    // OUTFRM_LEFT35 :
+	{1, 0x64C8, 0x27},    // OUTFRM_LEFT36 :
+	{1, 0x64C9, 0x26},    // OUTFRM_LEFT37 :
+	{1, 0x64CA, 0xFF},    // OUTFRM_RIGHT00 :
+	{1, 0x64CB, 0xFF},    // OUTFRM_RIGHT01 :
+	{1, 0x64CC, 0xFF},    // OUTFRM_RIGHT02 :
+	{1, 0x64CD, 0xFF},    // OUTFRM_RIGHT03 :
+	{1, 0x64CE, 0xFF},    // OUTFRM_RIGHT04 :
+	{1, 0x64CF, 0xFF},    // OUTFRM_RIGHT05 :
+	{1, 0x64D0, 0xFF},    // OUTFRM_RIGHT06 :
+	{1, 0x64D1, 0xFF},    // OUTFRM_RIGHT07 :
+	{1, 0x64D2, 0xFF},    // OUTFRM_RIGHT08 :
+	{1, 0x64D3, 0xFF},    // OUTFRM_RIGHT09 :
+	{1, 0x64D4, 0xD3},    // OUTFRM_RIGHT10 :
+	{1, 0x64D5, 0xB1},    // OUTFRM_RIGHT11 :
+	{1, 0x64D6, 0x98},    // OUTFRM_RIGHT12 :
+	{1, 0x64D7, 0x85},    // OUTFRM_RIGHT13 :
+	{1, 0x64D8, 0x78},    // OUTFRM_RIGHT14 :
+	{1, 0x64D9, 0x6D},    // OUTFRM_RIGHT15 :
+	{1, 0x64DA, 0x64},    // OUTFRM_RIGHT16 :
+	{1, 0x64DB, 0x5D},    // OUTFRM_RIGHT17 :
+	{1, 0x64DC, 0x57},    // OUTFRM_RIGHT18 :
+	{1, 0x64DD, 0x63},    // OUTFRM_RIGHT19 :
+	{1, 0x64DE, 0x5E},    // OUTFRM_RIGHT20 :
+	{1, 0x64DF, 0x5A},    // OUTFRM_RIGHT21 :
+	{1, 0x64E0, 0x56},    // OUTFRM_RIGHT22 :
+	{1, 0x64E1, 0x52},    // OUTFRM_RIGHT23 :
+	{1, 0x64E2, 0x50},    // OUTFRM_RIGHT24 :
+	{1, 0x64E3, 0x4E},    // OUTFRM_RIGHT25 :
+	{1, 0x64E4, 0x4C},    // OUTFRM_RIGHT26 :
+	{1, 0x64E5, 0x4A},    // OUTFRM_RIGHT27 :
+	{1, 0x64E6, 0x48},    // OUTFRM_RIGHT28 :
+	{1, 0x64E7, 0x46},    // OUTFRM_RIGHT29 :
+	{1, 0x64E8, 0x44},    // OUTFRM_RIGHT30 :
+	{1, 0x64E9, 0x43},    // OUTFRM_RIGHT31 :
+	{1, 0x64EA, 0x42},    // OUTFRM_RIGHT32 :
+	{1, 0x64EB, 0x42},    // OUTFRM_RIGHT33 :
+	{1, 0x64EC, 0x42},    // OUTFRM_RIGHT34 :
+	{1, 0x64ED, 0x30},    // OUTFRM_RIGHT35 :
+	{1, 0x64EE, 0x2F},    // OUTFRM_RIGHT36 :
+	{1, 0x64EF, 0x2E},    // OUTFRM_RIGHT37 :
+	{2, 0x64F0, 0x1CD2},    // OUTFRM_TOP :
+	{2, 0x64F2, 0x1400},    // OUTFRM_BOTM :
+	{1, 0x64F4, 0x19},    // OUTFRM_FLTOP :
+	{1, 0x64F5, 0x14},    // OUTFRM_FLBOTM :
+	{1, 0x64F6, 0xFF},    // OUTAIM_LEFT00 :
+	{1, 0x64F7, 0xFF},    // OUTAIM_LEFT01 :
+	{1, 0x64F8, 0xFF},    // OUTAIM_LEFT02 :
+	{1, 0x64F9, 0xFF},    // OUTAIM_LEFT03 :
+	{1, 0x64FA, 0xFF},    // OUTAIM_LEFT04 :
+	{1, 0x64FB, 0xFF},    // OUTAIM_LEFT05 :
+	{1, 0x64FC, 0xFF},    // OUTAIM_LEFT06 :
+	{1, 0x64FD, 0xFF},    // OUTAIM_LEFT07 :
+	{1, 0x64FE, 0xFF},    // OUTAIM_LEFT08 :
+	{1, 0x64FF, 0xFF},    // OUTAIM_LEFT09 :
+	{1, 0x6500, 0x91},    // OUTAIM_LEFT10 :
+	{1, 0x6501, 0x91},    // OUTAIM_LEFT11 :
+	{1, 0x6502, 0x91},    // OUTAIM_LEFT12 :
+	{1, 0x6503, 0x66},    // OUTAIM_LEFT13 :
+	{1, 0x6504, 0x5D},    // OUTAIM_LEFT14 :
+	{1, 0x6505, 0x3C},    // OUTAIM_LEFT15 :
+	{1, 0x6506, 0x3C},    // OUTAIM_LEFT16 :
+	{1, 0x6507, 0x3C},    // OUTAIM_LEFT17 :
+	{1, 0x6508, 0x3A},    // OUTAIM_LEFT18 :
+	{1, 0x6509, 0x39},    // OUTAIM_LEFT19 :
+	{1, 0x650A, 0x40},    // OUTAIM_LEFT20 :
+	{1, 0x650B, 0x46},    // OUTAIM_LEFT21 :
+	{1, 0x650C, 0x42},    // OUTAIM_LEFT22 :
+	{1, 0x650D, 0x40},    // OUTAIM_LEFT23 :
+	{1, 0x650E, 0x3C},    // OUTAIM_LEFT24 :
+	{1, 0x650F, 0x37},    // OUTAIM_LEFT25 :
+	{1, 0x6510, 0x34},    // OUTAIM_LEFT26 :
+	{1, 0x6511, 0x32},    // OUTAIM_LEFT27 :
+	{1, 0x6512, 0x2F},    // OUTAIM_LEFT28 :
+	{1, 0x6513, 0x2E},    // OUTAIM_LEFT29 :
+	{1, 0x6514, 0x2C},    // OUTAIM_LEFT30 :
+	{1, 0x6515, 0x2A},    // OUTAIM_LEFT31 :
+	{1, 0x6516, 0x2D},    // OUTAIM_LEFT32 :
+	{1, 0x6517, 0x2C},    // OUTAIM_LEFT33 :
+	{1, 0x6518, 0x2B},    // OUTAIM_LEFT34 :
+	{1, 0x6519, 0x2A},    // OUTAIM_LEFT35 :
+	{1, 0x651A, 0x29},    // OUTAIM_LEFT36 :
+	{1, 0x651B, 0x28},    // OUTAIM_LEFT37 :
+	{1, 0x651C, 0xFF},    // OUTAIM_RIGHT00 :
+	{1, 0x651D, 0xFF},    // OUTAIM_RIGHT01 :
+	{1, 0x651E, 0xFF},    // OUTAIM_RIGHT02 :
+	{1, 0x651F, 0xFF},    // OUTAIM_RIGHT03 :
+	{1, 0x6520, 0xFF},    // OUTAIM_RIGHT04 :
+	{1, 0x6521, 0xFF},    // OUTAIM_RIGHT05 :
+	{1, 0x6522, 0xFF},    // OUTAIM_RIGHT06 :
+	{1, 0x6523, 0xFF},    // OUTAIM_RIGHT07 :
+	{1, 0x6524, 0xFF},    // OUTAIM_RIGHT08 :
+	{1, 0x6525, 0xFF},    // OUTAIM_RIGHT09 :
+	{1, 0x6526, 0xD9},    // OUTAIM_RIGHT10 :
+	{1, 0x6527, 0xB7},    // OUTAIM_RIGHT11 :
+	{1, 0x6528, 0x96},    // OUTAIM_RIGHT12 :
+	{1, 0x6529, 0x6C},    // OUTAIM_RIGHT13 :
+	{1, 0x652A, 0x64},    // OUTAIM_RIGHT14 :
+	{1, 0x652B, 0x62},    // OUTAIM_RIGHT15 :
+	{1, 0x652C, 0x62},    // OUTAIM_RIGHT16 :
+	{1, 0x652D, 0x61},    // OUTAIM_RIGHT17 :
+	{1, 0x652E, 0x60},    // OUTAIM_RIGHT18 :
+	{1, 0x652F, 0x5E},    // OUTAIM_RIGHT19 :
+	{1, 0x6530, 0x5B},    // OUTAIM_RIGHT20 :
+	{1, 0x6531, 0x4F},    // OUTAIM_RIGHT21 :
+	{1, 0x6532, 0x4B},    // OUTAIM_RIGHT22 :
+	{1, 0x6533, 0x49},    // OUTAIM_RIGHT23 :
+	{1, 0x6534, 0x44},    // OUTAIM_RIGHT24 :
+	{1, 0x6535, 0x3F},    // OUTAIM_RIGHT25 :
+	{1, 0x6536, 0x3D},    // OUTAIM_RIGHT26 :
+	{1, 0x6537, 0x3B},    // OUTAIM_RIGHT27 :
+	{1, 0x6538, 0x3B},    // OUTAIM_RIGHT28 :
+	{1, 0x6539, 0x3A},    // OUTAIM_RIGHT29 :
+	{1, 0x653A, 0x38},    // OUTAIM_RIGHT30 :
+	{1, 0x653B, 0x38},    // OUTAIM_RIGHT31 :
+	{1, 0x653C, 0x33},    // OUTAIM_RIGHT32 :
+	{1, 0x653D, 0x32},    // OUTAIM_RIGHT33 :
+	{1, 0x653E, 0x31},    // OUTAIM_RIGHT34 :
+	{1, 0x653F, 0x30},    // OUTAIM_RIGHT35 :
+	{1, 0x6540, 0x2F},    // OUTAIM_RIGHT36 :
+	{1, 0x6541, 0x2E},    // OUTAIM_RIGHT37 :
+	{2, 0x6542, 0x1A56},    // OUTAIM_TOP :
+	{2, 0x6544, 0x16AF},    // OUTAIM_BOTM :
+	{1, 0x6546, 0x19},    // OUTAIM_FLTOP :
+	{1, 0x6547, 0x17},    // OUTAIM_FLBOTM :
+	{1, 0x657A, 0x7E},    // IN_CTMP_FRM_BG0 :
+	{1, 0x657B, 0x6D},    // IN_CTMP_FRM_BG1 :
+	{1, 0x657C, 0x64},    // IN_CTMP_FRM_BG2 :
+	{1, 0x657D, 0x5B},    // IN_CTMP_FRM_BG3 :
+	{1, 0x657E, 0x55},    // IN_CTMP_FRM_BG4 :
+	{1, 0x657F, 0x4F},    // IN_CTMP_FRM_BG5 :
+	{1, 0x6580, 0x49},    // IN_CTMP_FRM_BG6 :
+	{1, 0x6581, 0x43},    // IN_CTMP_FRM_BG7 :
+	{1, 0x6582, 0x3E},    // IN_CTMP_FRM_BG8 :
+	{1, 0x6583, 0x38},    // IN_CTMP_FRM_BG9 :
+	{1, 0x6584, 0x22},    // IN_CTMP_FRM_BG10 :
+	{1, 0x6585, 0x23},    // IN_CTMP_FRM_RG0 :
+	{1, 0x6586, 0x33},    // IN_CTMP_FRM_RG1 :
+	{1, 0x6587, 0x3F},    // IN_CTMP_FRM_RG2 :
+	{1, 0x6588, 0x53},    // IN_CTMP_FRM_RG3 :
+	{1, 0x6589, 0x63},    // IN_CTMP_FRM_RG4 :
+	{1, 0x658A, 0x76},    // IN_CTMP_FRM_RG5 :
+	{1, 0x658B, 0xC1},    // IN_CTMP_FRM_RG6 :
+	{1, 0x658C, 0x00},    // IN_CTMP_WEIGHT00_01 :
+	{1, 0x658D, 0x00},    // IN_CTMP_WEIGHT02_03 :
+	{1, 0x658E, 0x00},    // IN_CTMP_WEIGHT04_05 :
+	{1, 0x658F, 0x40},    // IN_CTMP_WEIGHT06_07 :
+	{1, 0x6590, 0x00},    // IN_CTMP_WEIGHT08_09 :
+	{1, 0x6591, 0x00},    // IN_CTMP_WEIGHT10_11 :
+	{1, 0x6592, 0xA0},    // IN_CTMP_WEIGHT12_13 :
+	{1, 0x6593, 0x07},    // IN_CTMP_WEIGHT14_15 :
+	{1, 0x6594, 0x00},    // IN_CTMP_WEIGHT16_17 :
+	{1, 0x6595, 0x70},    // IN_CTMP_WEIGHT18_19 :
+	{1, 0x6596, 0x07},    // IN_CTMP_WEIGHT20_21 :
+	{1, 0x6597, 0x00},    // IN_CTMP_WEIGHT22_23 :
+	{1, 0x6598, 0x30},    // IN_CTMP_WEIGHT24_25 :
+	{1, 0x6599, 0x00},    // IN_CTMP_WEIGHT26_27 :
+	{1, 0x659A, 0x00},    // IN_CTMP_WEIGHT28_29 :
+	{1, 0x659B, 0x00},    // IN_CTMP_WEIGHT30_31 :
+	{1, 0x659C, 0x00},    // IN_CTMP_WEIGHT32_33 :
+	{1, 0x659D, 0x00},    // IN_CTMP_WEIGHT34_35 :
+	{1, 0x659E, 0x00},    // IN_CTMP_WEIGHT36_37 :
+	{1, 0x659F, 0x00},    // IN_CTMP_WEIGHT38_39 :
+	{1, 0x65A0, 0x00},    // IN_CTMP_WEIGHT40_41 :
+	{1, 0x65A1, 0x00},    // IN_CTMP_WEIGHT42_43 :
+	{1, 0x65A2, 0x00},    // IN_CTMP_WEIGHT44_45 :
+	{1, 0x65A3, 0x00},    // IN_CTMP_WEIGHT46_47 :
+	{1, 0x65A4, 0x00},    // IN_CTMP_WEIGHT48_49 :
+	{1, 0x65A5, 0x00},    // IN_CTMP_WEIGHT50_51 :
+	{1, 0x65A6, 0x00},    // IN_CTMP_WEIGHT52_53 :
+	{1, 0x65A7, 0x00},    // IN_CTMP_WEIGHT54_55 :
+	{1, 0x65A8, 0x00},    // IN_CTMP_WEIGHT56_57 :
+	{1, 0x65A9, 0x00},    // IN_CTMP_WEIGHT58_59 :
+	{1, 0x65AA, 0x7D},    // OUT_CTMP_FRM_BG0 :
+	{1, 0x65AB, 0x74},    // OUT_CTMP_FRM_BG1 :
+	{1, 0x65AC, 0x70},    // OUT_CTMP_FRM_BG2 :
+	{1, 0x65AD, 0x6C},    // OUT_CTMP_FRM_BG3 :
+	{1, 0x65AE, 0x68},    // OUT_CTMP_FRM_BG4 :
+	{1, 0x65AF, 0x64},    // OUT_CTMP_FRM_BG5 :
+	{1, 0x65B0, 0x60},    // OUT_CTMP_FRM_BG6 :
+	{1, 0x65B1, 0x5C},    // OUT_CTMP_FRM_BG7 :
+	{1, 0x65B2, 0x58},    // OUT_CTMP_FRM_BG8 :
+	{1, 0x65B3, 0x54},    // OUT_CTMP_FRM_BG9 :
+	{1, 0x65B4, 0x50},    // OUT_CTMP_FRM_BG10 :
+	{1, 0x65B5, 0x19},    // OUT_CTMP_FRM_RG0 :
+	{1, 0x65B6, 0x27},    // OUT_CTMP_FRM_RG1 :
+	{1, 0x65B7, 0x32},    // OUT_CTMP_FRM_RG2 :
+	{1, 0x65B8, 0x3E},    // OUT_CTMP_FRM_RG3 :
+	{1, 0x65B9, 0x49},    // OUT_CTMP_FRM_RG4 :
+	{1, 0x65BA, 0x54},    // OUT_CTMP_FRM_RG5 :
+	{1, 0x65BB, 0x5E},    // OUT_CTMP_FRM_RG6 :
+	{1, 0x65BC, 0x00},    // OUT_CTMP_WEIGHT00_01 :
+	{1, 0x65BD, 0x00},    // OUT_CTMP_WEIGHT02_03 :
+	{1, 0x65BE, 0x00},    // OUT_CTMP_WEIGHT04_05 :
+	{1, 0x65BF, 0x00},    // OUT_CTMP_WEIGHT06_07 :
+	{1, 0x65C0, 0x00},    // OUT_CTMP_WEIGHT08_09 :
+	{1, 0x65C1, 0x00},    // OUT_CTMP_WEIGHT10_11 :
+	{1, 0x65C2, 0x11},    // OUT_CTMP_WEIGHT12_13 :
+	{1, 0x65C3, 0x11},    // OUT_CTMP_WEIGHT14_15 :
+	{1, 0x65C4, 0x00},    // OUT_CTMP_WEIGHT16_17 :
+	{1, 0x65C5, 0x20},    // OUT_CTMP_WEIGHT18_19 :
+	{1, 0x65C6, 0x22},    // OUT_CTMP_WEIGHT20_21 :
+	{1, 0x65C7, 0x02},    // OUT_CTMP_WEIGHT22_23 :
+	{1, 0x65C8, 0x30},    // OUT_CTMP_WEIGHT24_25 :
+	{1, 0x65C9, 0x33},    // OUT_CTMP_WEIGHT26_27 :
+	{1, 0x65CA, 0x03},    // OUT_CTMP_WEIGHT28_29 :
+	{1, 0x65CB, 0x30},    // OUT_CTMP_WEIGHT30_31 :
+	{1, 0x65CC, 0x77},    // OUT_CTMP_WEIGHT32_33 :
+	{1, 0x65CD, 0x03},    // OUT_CTMP_WEIGHT34_35 :
+	{1, 0x65CE, 0x30},    // OUT_CTMP_WEIGHT36_37 :
+	{1, 0x65CF, 0x77},    // OUT_CTMP_WEIGHT38_39 :
+	{1, 0x65D0, 0x03},    // OUT_CTMP_WEIGHT40_41 :
+	{1, 0x65D1, 0x30},    // OUT_CTMP_WEIGHT42_43 :
+	{1, 0x65D2, 0x33},    // OUT_CTMP_WEIGHT44_45 :
+	{1, 0x65D3, 0x03},    // OUT_CTMP_WEIGHT46_47 :
+	{1, 0x65D4, 0x10},    // OUT_CTMP_WEIGHT48_49 :
+	{1, 0x65D5, 0x11},    // OUT_CTMP_WEIGHT50_51 :
+	{1, 0x65D6, 0x11},    // OUT_CTMP_WEIGHT52_53 :
+	{1, 0x65D7, 0x00},    // OUT_CTMP_WEIGHT54_55 :
+	{1, 0x65D8, 0x00},    // OUT_CTMP_WEIGHT56_57 :
+	{1, 0x65D9, 0x00},    // OUT_CTMP_WEIGHT58_59 :
+	                                     
+	//AE
+	{1, 0x0189, 0x40},    //AE_FREE_BLEND_RATIO
+	{1, 0x02AC, 0x00},    //AE_SUB_SN1                             
+	{1, 0x0180, 0x00},    //EV LEVEL
+	{1, 0x02F0, 0x00},    //EVREF_CAP_SN1_2
+	{2, 0x02FC, 0x2272}, //EVREF_TYPE1
+	{1, 0x0326, 0x22},    // SHTCTRLTIME1_TYPE1 : 
+	{1, 0x0327, 0x12},    // AGCGAIN1_TYPE1 : 
+	{1, 0x0328, 0x53},    // SHTCTRLTIME2_TYPE1 : 
+	{1, 0x0329, 0x23},    // AGCGAIN2_TYPE1 : 
+	{1, 0x032A, 0x7D},    // SHTCTRLTIME3_TYPE1 : 
+	{1, 0x032B, 0x25},    // AGCGAIN3_TYPE1 : 
+	{1, 0x5E00, 0x05},    //FLCMODE 0: AUTO 5: Fixed 50Hz
+	{1, 0x5E30, 0x14},    //AESPEED
+
+	//Type
+	{1, 0x9208,  0x25},    // GAIN_TH_A_TYPE0 : 
+	{1, 0x9209,  0x18},    // GAIN_TH_B_TYPE0 : 
+	{1, 0x920A,  0x05},    // GAIN_TH_C_TYPE0 : 
+	{1, 0x921D,  0x1E},    // GAIN_TH_A_TYPE7 : 
+	{1, 0x921E,  0x18},    // GAIN_TH_B_TYPE7 : 
+	{1, 0x921F,  0x05},    // GAIN_TH_C_TYPE7 : 
+	{1, 0x9220,  0x07},    // DYZ1_2ND_TH_SEL : 
+	{1, 0x9221,  0x07},    // DYZ1_MAX_TH_SEL : 
+	{1, 0x9222,  0x07},    // DYZ1_OCR_TH_SEL :  
+	                                     
+	//Gamma              
+	{2, 0x7000, 0x0000},    // G0_KNOT_G0 :
+	{2, 0x7002, 0x001B},    // G0_KNOT_G1 :
+	{2, 0x7004, 0x001F},    // G0_KNOT_G2 :
+	{2, 0x7006, 0x0035},    // G0_KNOT_G3 :
+	{2, 0x7008, 0x003F},    // G0_KNOT_G4 :
+	{2, 0x700A, 0x0050},    // G0_KNOT_G5 :
+	{2, 0x700C, 0x005A},    // G0_KNOT_G6 :
+	{2, 0x700E, 0x0065},    // G0_KNOT_G7 :
+	{2, 0x7010, 0x006C},    // G0_KNOT_G8 :
+	{2, 0x7012, 0x0074},    // G0_KNOT_G9 :
+	{2, 0x7014, 0x0052},    // G0_KNOT_G10 :
+	{2, 0x7016, 0x0091},    // G0_KNOT_G11 :
+	{2, 0x7018, 0x00B8},    // G0_KNOT_G12 :
+	{2, 0x701A, 0x00D2},    // G0_KNOT_G13 :
+	{2, 0x701C, 0x00E2},    // G0_KNOT_G14 :
+	{2, 0x701E, 0x00F1},    // G0_KNOT_G15 :
+	{2, 0x7020, 0x00FA},    // G0_KNOT_G16 :
+	{2, 0x7022, 0x0104},    // G0_KNOT_G17 :
+	{2, 0x7024, 0x0104},    // G0_KNOT_G18 :
+	{1, 0x9211, 0x93},    // GAIN_TH_A_TYPE3 : 
+	{1, 0x9212, 0xA1},    // GAIN_TH_B_TYPE3 : 
+	{1, 0x9213, 0xB4},    // GAIN_TH_C_TYPE3 : 
+	                                     
+	//APCON GAIN
+	{1, 0x03A1, 0x20},    // UISHARPNESS_POS_TYPE1[U3.5]
+	{1, 0x03A4, 0x20},    // UISHARPNESS_NEG_TYPE1[U3.5]                      
+	{1, 0x5005, 0xD9},    // IHGAIN_OFF
+	{1, 0x942F, 0x2A},    // AP_N_GAIN_POS_A :
+	{1, 0x9430, 0x52},    // AP_N_GAIN_POS_B :
+	{1, 0x9431, 0x44},    // AP_N_GAIN_POS_C1 :
+	{1, 0x9432, 0x44},    // AP_N_GAIN_POS_C2 :
+	{1, 0x9433, 0x29},    // AP_N_GAIN_NEG_A :
+	{1, 0x9434, 0x52},    // AP_N_GAIN_NEG_B :
+	{1, 0x9435, 0x3A},    // AP_N_GAIN_NEG_C1 :
+	{1, 0x9436, 0x3A},    // AP_N_GAIN_NEG_C2 :
+	{1, 0x9447, 0x1C},    // AP_H_GAIN_POS_A :
+	{1, 0x9448, 0x1E},    // AP_H_GAIN_POS_B :
+	{1, 0x9449, 0x3F},    // AP_H_GAIN_POS_C1 :
+	{1, 0x944A, 0x8B},    // AP_H_GAIN_POS_C2 :
+	{1, 0x944B, 0x1C},    // AP_H_GAIN_NEG_A :
+	{1, 0x944C, 0x1D},    // AP_H_GAIN_NEG_B :
+	{1, 0x944D, 0x3E},    // AP_H_GAIN_NEG_C1 :
+	{1, 0x944E, 0x8B},    // AP_H_GAIN_NEG_C2 :
+	{1, 0x945F, 0x0C},    // AP_L_GAIN_POS_A :
+	{1, 0x9460, 0x1D},    // AP_L_GAIN_POS_B :
+	{1, 0x9461, 0x24},    // AP_L_GAIN_POS_C1 :
+	{1, 0x9462, 0x62},    // AP_L_GAIN_POS_C2 :
+	{1, 0x9463, 0x0C},    // AP_L_GAIN_NEG_A :
+	{1, 0x9464, 0x16},    // AP_L_GAIN_NEG_B :
+	{1, 0x9465, 0x1B},    // AP_L_GAIN_NEG_C1 :
+	{1, 0x9466, 0x1B},    // AP_L_GAIN_NEG_C2 :
+	{2, 0x9510, 0x00C8},    // AP_POST_LIM_POS_A :
+	{2, 0x9512, 0x00C8},    // AP_POST_LIM_POS_B :
+	{2, 0x9514, 0x00C8},    // AP_POST_LIM_POS_C1 :
+	{2, 0x9516, 0x00C8},    // AP_POST_LIM_POS_C2 :
+	{2, 0x9518, 0x00C8},    // AP_POST_LIM_NEG_A :
+	{2, 0x951A, 0x00C8},    // AP_POST_LIM_NEG_B :
+	{2, 0x951C, 0x00C8},    // AP_POST_LIM_NEG_C1 :
+	{2, 0x951E, 0x00C8},    // AP_POST_LIM_NEG_C2 :
+	{2, 0x9520, 0x0000},    // AP_POST_CORE_POS_A :
+	{2, 0x9522, 0x0000},    // AP_POST_CORE_POS_B :
+	{2, 0x9524, 0x0000},    // AP_POST_CORE_POS_C1 :
+	{2, 0x9526, 0x0000},    // AP_POST_CORE_POS_C2 :
+	{2, 0x9528, 0x0000},    // AP_POST_CORE_NEG_A :
+	{2, 0x952A, 0x0000},    // AP_POST_CORE_NEG_B :
+	{2, 0x952C, 0x0000},    // AP_POST_CORE_NEG_C1 :
+	{2, 0x952E, 0x0000},    // AP_POST_CORE_NEG_C2 :
+	                                     
+	//saturation                        
+	{1, 0x039E, 0x88},    // UISATURATION_TYPE1 US1.7
+	
+	//HUE 
+	{2, 0x6E86, 0x0000},    // IBYHUE1_POS1 :
+	{2, 0x6E88, 0xFFF6},    // IRYHUE1_POS1 :
+	{2, 0x6E8A, 0xFFF8},    // IBYHUE2_POS1 :
+	{2, 0x6E8C, 0xFFF7},    // IRYHUE2_POS1 :
+	{2, 0x6E8E, 0xFFF8},    // IBYHUE3_POS1 :
+	{2, 0x6E90, 0xFFEE},    // IRYHUE3_POS1 :
+	{2, 0x6E92, 0x0000},    // IBYHUE4_POS1 :
+	{2, 0x6E94, 0xFFEC},    // IRYHUE4_POS1 :
+	{2, 0x6E96, 0x0000},    // IBYHUE1_POS2 :
+	{2, 0x6E98, 0xFFF6},    // IRYHUE1_POS2 :
+	{2, 0x6E9A, 0xFFF8},    // IBYHUE2_POS2 :
+	{2, 0x6E9C, 0xFFF7},    // IRYHUE2_POS2 :
+	{2, 0x6E9E, 0xFFF8},    // IBYHUE3_POS2 :
+	{2, 0x6EA0, 0xFFEE},    // IRYHUE3_POS2 :
+	{2, 0x6EA2, 0x0000},    // IBYHUE4_POS2 :
+	{2, 0x6EA4, 0xFFEC},    // IRYHUE4_POS2 :
+	{2, 0x6EA6, 0x0000},    // IBYHUE1_POS3 :
+	{2, 0x6EA8, 0xFFF6},    // IRYHUE1_POS3 :
+	{2, 0x6EAA, 0xFFF8},    // IBYHUE2_POS3 :
+	{2, 0x6EAC, 0xFFF7},    // IRYHUE2_POS3 :
+	{2, 0x6EAE, 0xFFF8},    // IBYHUE3_POS3 :
+	{2, 0x6EB0, 0xFFEE},    // IRYHUE3_POS3 :
+	{2, 0x6EB2, 0x0000},    // IBYHUE4_POS3 :
+	{2, 0x6EB4, 0xFFEC},    // IRYHUE4_POS3 :
+	{2, 0x6EB6, 0x0000},    // IBYHUE1_POS4 :
+	{2, 0x6EB8, 0xFFF3},    // IRYHUE1_POS4 :
+	{2, 0x6EBA, 0xFFF8},    // IBYHUE2_POS4 :
+	{2, 0x6EBC, 0xFFF3},    // IRYHUE2_POS4 :
+	{2, 0x6EBE, 0xFFF8},    // IBYHUE3_POS4 :
+	{2, 0x6EC0, 0xFFEE},    // IRYHUE3_POS4 :
+	{2, 0x6EC2, 0x0000},    // IBYHUE4_POS4 :
+	{2, 0x6EC4, 0xFFEC},    // IRYHUE4_POS4 :
+	{2, 0x6EC6, 0x0000},    // IBYHUE1_POS5 :
+	{2, 0x6EC8, 0xFFF6},    // IRYHUE1_POS5 :
+	{2, 0x6ECA, 0xFFF8},    // IBYHUE2_POS5 :
+	{2, 0x6ECC, 0xFFF7},    // IRYHUE2_POS5 :
+	{2, 0x6ECE, 0xFFF8},    // IBYHUE3_POS5 :
+	{2, 0x6ED0, 0xFFEE},    // IRYHUE3_POS5 :
+	{2, 0x6ED2, 0x0000},    // IBYHUE4_POS5 :
+	{2, 0x6ED4, 0xFFEC},    // IRYHUE4_POS5 :
+	{2, 0x6ED6, 0x0000},    // IBYHUE1_POS6 :
+	{2, 0x6ED8, 0xFFF6},    // IRYHUE1_POS6 :
+	{2, 0x6EDA, 0xFFF8},    // IBYHUE2_POS6 :
+	{2, 0x6EDC, 0xFFF7},    // IRYHUE2_POS6 :
+	{2, 0x6EDE, 0xFFF8},    // IBYHUE3_POS6 :
+	{2, 0x6EE0, 0xFFEE},    // IRYHUE3_POS6 :
+	{2, 0x6EE2, 0x0000},    // IBYHUE4_POS6 :
+	{2, 0x6EE4, 0xFFEC},    // IRYHUE4_POS6 :
+	{2, 0x6EE6, 0x0000},    // IBYHUE1_POS7 :
+	{2, 0x6EE8, 0xFFF1},    // IRYHUE1_POS7 :
+	{2, 0x6EEA, 0xFFFE},    // IBYHUE2_POS7 :
+	{2, 0x6EEC, 0xFFF1},    // IRYHUE2_POS7 :
+	{2, 0x6EEE, 0xFFFE},    // IBYHUE3_POS7 :
+	{2, 0x6EF0, 0xFFEE},    // IRYHUE3_POS7 :
+	{2, 0x6EF2, 0x0000},    // IBYHUE4_POS7 :
+	{2, 0x6EF4, 0xFFEC},    // IRYHUE4_POS7 :
+	{2, 0x6EF6, 0xFFF5},    // IBYHUE1_OUT :
+	{2, 0x6EF8, 0xFFEB},    // IRYHUE1_OUT :
+	{2, 0x6EFA, 0xFFFD},    // IBYHUE2_OUT :
+	{2, 0x6EFC, 0xFFEF},    // IRYHUE2_OUT :
+	{2, 0x6EFE, 0xFFFD},    // IBYHUE3_OUT :
+	{2, 0x6F00, 0xFFD8},    // IRYHUE3_OUT :
+	{2, 0x6F02, 0xFFF5},    // IBYHUE4_OUT :
+	{2, 0x6F04, 0xFFCF},    // IRYHUE4_OUT :
+	{2, 0x6F06, 0x0000},    // IBYHUE1_R2_POS4 :
+	{2, 0x6F08, 0xFFF6},    // IRYHUE1_R2_POS4 :
+	{2, 0x6F0A, 0xFFF8},    // IBYHUE2_R2_POS4 :
+	{2, 0x6F0C, 0xFFF7},    // IRYHUE2_R2_POS4 :
+	{2, 0x6F0E, 0xFFF8},    // IBYHUE3_R2_POS4 :
+	{2, 0x6F10, 0xFFEE},    // IRYHUE3_R2_POS4 :
+	{2, 0x6F12, 0x0000},    // IBYHUE4_R2_POS4 :
+	{2, 0x6F14, 0xFFEC},    // IRYHUE4_R2_POS4 :
+	{2, 0x6F16, 0x0000},    // IBYHUE1_R2_POS5 :
+	{2, 0x6F18, 0xFFF6},    // IRYHUE1_R2_POS5 :
+	{2, 0x6F1A, 0xFFF8},    // IBYHUE2_R2_POS5 :
+	{2, 0x6F1C, 0xFFF7},    // IRYHUE2_R2_POS5 :
+	{2, 0x6F1E, 0xFFF8},    // IBYHUE3_R2_POS5 :
+	{2, 0x6F20, 0xFFEE},    // IRYHUE3_R2_POS5 :
+	{2, 0x6F22, 0x0000},    // IBYHUE4_R2_POS5 :
+	{2, 0x6F24, 0xFFEC},    // IRYHUE4_R2_POS5 :
+	{1, 0x6F26, 0x46},    // IRYGAIN1_POS1 :
+	{1, 0x6F27, 0x50},    // IBYGAIN1_POS1 :
+	{1, 0x6F28, 0x46},    // IRYGAIN2_POS1 :
+	{1, 0x6F29, 0x5A},    // IBYGAIN2_POS1 :
+	{1, 0x6F2A, 0x50},    // IRYGAIN3_POS1 :
+	{1, 0x6F2B, 0x5A},    // IBYGAIN3_POS1 :
+	{1, 0x6F2C, 0x50},    // IRYGAIN4_POS1 :
+	{1, 0x6F2D, 0x50},    // IBYGAIN4_POS1 :
+	{1, 0x6F2E, 0x47},    // IRYGAIN1_POS2 :
+	{1, 0x6F2F, 0x50},    // IBYGAIN1_POS2 :
+	{1, 0x6F30, 0x47},    // IRYGAIN2_POS2 :
+	{1, 0x6F31, 0x5A},    // IBYGAIN2_POS2 :
+	{1, 0x6F32, 0x50},    // IRYGAIN3_POS2 :
+	{1, 0x6F33, 0x5A},    // IBYGAIN3_POS2 :
+	{1, 0x6F34, 0x50},    // IRYGAIN4_POS2 :
+	{1, 0x6F35, 0x50},    // IBYGAIN4_POS2 :
+	{1, 0x6F36, 0x4B},    // IRYGAIN1_POS3 :
+	{1, 0x6F37, 0x50},    // IBYGAIN1_POS3 :
+	{1, 0x6F38, 0x4B},    // IRYGAIN2_POS3 :
+	{1, 0x6F39, 0x5D},    // IBYGAIN2_POS3 :
+	{1, 0x6F3A, 0x50},    // IRYGAIN3_POS3 :
+	{1, 0x6F3B, 0x5D},    // IBYGAIN3_POS3 :
+	{1, 0x6F3C, 0x50},    // IRYGAIN4_POS3 :
+	{1, 0x6F3D, 0x50},    // IBYGAIN4_POS3 :
+	{1, 0x6F3E, 0x49},    // IRYGAIN1_POS4 :
+	{1, 0x6F3F, 0x50},    // IBYGAIN1_POS4 :
+	{1, 0x6F40, 0x49},    // IRYGAIN2_POS4 :
+	{1, 0x6F41, 0x61},    // IBYGAIN2_POS4 :
+	{1, 0x6F42, 0x50},    // IRYGAIN3_POS4 :
+	{1, 0x6F43, 0x61},    // IBYGAIN3_POS4 :
+	{1, 0x6F44, 0x50},    // IRYGAIN4_POS4 :
+	{1, 0x6F45, 0x50},    // IBYGAIN4_POS4 :
+	{1, 0x6F46, 0x4E},    // IRYGAIN1_POS5 :
+	{1, 0x6F47, 0x50},    // IBYGAIN1_POS5 :
+	{1, 0x6F48, 0x4E},    // IRYGAIN2_POS5 :
+	{1, 0x6F49, 0x5A},    // IBYGAIN2_POS5 :
+	{1, 0x6F4A, 0x50},    // IRYGAIN3_POS5 :
+	{1, 0x6F4B, 0x5A},    // IBYGAIN3_POS5 :
+	{1, 0x6F4C, 0x50},    // IRYGAIN4_POS5 :
+	{1, 0x6F4D, 0x50},    // IBYGAIN4_POS5 :
+	{1, 0x6F4E, 0x4A},    // IRYGAIN1_POS6 :
+	{1, 0x6F4F, 0x50},    // IBYGAIN1_POS6 :
+	{1, 0x6F50, 0x4A},    // IRYGAIN2_POS6 :
+	{1, 0x6F51, 0x5D},    // IBYGAIN2_POS6 :
+	{1, 0x6F52, 0x50},    // IRYGAIN3_POS6 :
+	{1, 0x6F53, 0x5D},    // IBYGAIN3_POS6 :
+	{1, 0x6F54, 0x50},    // IRYGAIN4_POS6 :
+	{1, 0x6F55, 0x50},    // IBYGAIN4_POS6 :
+	{1, 0x6F56, 0x48},    // IRYGAIN1_POS7 :
+	{1, 0x6F57, 0x50},    // IBYGAIN1_POS7 :
+	{1, 0x6F58, 0x48},    // IRYGAIN2_POS7 :
+	{1, 0x6F59, 0x61},    // IBYGAIN2_POS7 :
+	{1, 0x6F5A, 0x50},    // IRYGAIN3_POS7 :
+	{1, 0x6F5B, 0x61},    // IBYGAIN3_POS7 :
+	{1, 0x6F5C, 0x50},    // IRYGAIN4_POS7 :
+	{1, 0x6F5D, 0x50},    // IBYGAIN4_POS7 :
+	{1, 0x6F5E, 0x78},    // IRYGAIN1_OUT :
+	{1, 0x6F5F, 0x4E},    // IBYGAIN1_OUT :
+	{1, 0x6F60, 0x78},    // IRYGAIN2_OUT :
+	{1, 0x6F61, 0x5F},    // IBYGAIN2_OUT :
+	{1, 0x6F62, 0x78},    // IRYGAIN3_OUT :
+	{1, 0x6F63, 0x5F},    // IBYGAIN3_OUT :
+	{1, 0x6F64, 0x78},    // IRYGAIN4_OUT :
+	{1, 0x6F65, 0x4E},    // IBYGAIN4_OUT :
+	{1, 0x6F66, 0x4E},    // IRYGAIN1_R2_POS4 :
+	{1, 0x6F67, 0x50},    // IBYGAIN1_R2_POS4 :
+	{1, 0x6F68, 0x4E},    // IRYGAIN2_R2_POS4 :
+	{1, 0x6F69, 0x5A},    // IBYGAIN2_R2_POS4 :
+	{1, 0x6F6A, 0x50},    // IRYGAIN3_R2_POS4 :
+	{1, 0x6F6B, 0x5A},    // IBYGAIN3_R2_POS4 :
+	{1, 0x6F6C, 0x50},    // IRYGAIN4_R2_POS4 :
+	{1, 0x6F6D, 0x50},    // IBYGAIN4_R2_POS4 :
+	{1, 0x6F6E, 0x4E},    // IRYGAIN1_R2_POS5 :
+	{1, 0x6F6F, 0x50},    // IBYGAIN1_R2_POS5 :
+	{1, 0x6F70, 0x4E},    // IRYGAIN2_R2_POS5 :
+	{1, 0x6F71, 0x5A},    // IBYGAIN2_R2_POS5 :
+	{1, 0x6F72, 0x50},    // IRYGAIN3_R2_POS5 :
+	{1, 0x6F73, 0x5A},    // IBYGAIN3_R2_POS5 :
+	{1, 0x6F74, 0x50},    // IRYGAIN4_R2_POS5 :
+	{1, 0x6F75, 0x50},    // IBYGAIN4_R2_POS5 :
+	                                     
+	//MC3                                
+	{1, 0x6C49, 0xF5},    // MAIN_CONFIG4 
+	{1, 0x7638, 0x41},    // MC3_RDEF0_POS1 :
+	{1, 0x7639, 0x46},    // MC3_RDEF1_POS1 :
+	{1, 0x763A, 0x46},    // MC3_RDEF2_POS1 :
+	{1, 0x763B, 0x71},    // MC3_RDEF3_POS1 :
+	{1, 0x763C, 0x41},    // MC3_RDEF0_POS2 :
+	{1, 0x763D, 0x46},    // MC3_RDEF1_POS2 :
+	{1, 0x763E, 0x46},    // MC3_RDEF2_POS2 :
+	{1, 0x763F, 0x71},    // MC3_RDEF3_POS2 :
+	{1, 0x7640, 0x3C},    // MC3_RDEF0_POS3 :
+	{1, 0x7641, 0x46},    // MC3_RDEF1_POS3 :
+	{1, 0x7642, 0x46},    // MC3_RDEF2_POS3 :
+	{1, 0x7643, 0x71},    // MC3_RDEF3_POS3 :
+	{1, 0x7644, 0x46},    // MC3_RDEF0_POS4 :
+	{1, 0x7645, 0x46},    // MC3_RDEF1_POS4 :
+	{1, 0x7646, 0x46},    // MC3_RDEF2_POS4 :
+	{1, 0x7647, 0x71},    // MC3_RDEF3_POS4 :
+	{1, 0x7648, 0x46},    // MC3_RDEF0_POS5 :
+	{1, 0x7649, 0x46},    // MC3_RDEF1_POS5 :
+	{1, 0x764A, 0x46},    // MC3_RDEF2_POS5 :
+	{1, 0x764B, 0x71},    // MC3_RDEF3_POS5 :
+	{1, 0x764C, 0x46},    // MC3_RDEF0_POS6 :
+	{1, 0x764D, 0x46},    // MC3_RDEF1_POS6 :
+	{1, 0x764E, 0x46},    // MC3_RDEF2_POS6 :
+	{1, 0x764F, 0x71},    // MC3_RDEF3_POS6 :
+	{1, 0x7650, 0x46},    // MC3_RDEF0_POS7 :
+	{1, 0x7651, 0x46},    // MC3_RDEF1_POS7 :
+	{1, 0x7652, 0x46},    // MC3_RDEF2_POS7 :
+	{1, 0x7653, 0x71},    // MC3_RDEF3_POS7 :
+	{1, 0x7654, 0x2D},    // MC3_RDEF0_OUT :
+	{1, 0x7655, 0x2D},    // MC3_RDEF1_OUT :
+	{1, 0x7656, 0x62},    // MC3_RDEF2_OUT :
+	{1, 0x7657, 0x54},    // MC3_RDEF3_OUT :
+	{1, 0x7658, 0x46},    // MC3_RDEF0_R2_POS4 :
+	{1, 0x7659, 0x32},    // MC3_RDEF1_R2_POS4 :
+	{1, 0x765A, 0x46},    // MC3_RDEF2_R2_POS4 :
+	{1, 0x765B, 0x71},    // MC3_RDEF3_R2_POS4 :
+	{1, 0x765C, 0x46},    // MC3_RDEF0_R2_POS5 :
+	{1, 0x765D, 0x32},    // MC3_RDEF1_R2_POS5 :
+	{1, 0x765E, 0x46},    // MC3_RDEF2_R2_POS5 :
+	{1, 0x765F, 0x71},    // MC3_RDEF3_R2_POS5 :
+	{2, 0x7660, 0xFFBA},    // MC3_X0DEF0_POS1 :
+	{2, 0x7662, 0xFFBA},    // MC3_Y0DEF0_POS1 :
+	{2, 0x7664, 0xFFE2},    // MC3_X0DEF1_POS1 :
+	{2, 0x7666, 0x0039},    // MC3_Y0DEF1_POS1 :
+	{2, 0x7668, 0xFFD3},    // MC3_X0DEF2_POS1 :
+	{2, 0x766A, 0xFFF6},    // MC3_Y0DEF2_POS1 :
+	{2, 0x766C, 0x003B},    // MC3_X0DEF3_POS1 :
+	{2, 0x766E, 0xFFBB},    // MC3_Y0DEF3_POS1 :
+	{2, 0x7670, 0xFFBA},    // MC3_X0DEF0_POS2 :
+	{2, 0x7672, 0xFFBA},    // MC3_Y0DEF0_POS2 :
+	{2, 0x7674, 0xFFE2},    // MC3_X0DEF1_POS2 :
+	{2, 0x7676, 0x0039},    // MC3_Y0DEF1_POS2 :
+	{2, 0x7678, 0xFFD3},    // MC3_X0DEF2_POS2 :
+	{2, 0x767A, 0xFFF6},    // MC3_Y0DEF2_POS2 :
+	{2, 0x767C, 0x003B},    // MC3_X0DEF3_POS2 :
+	{2, 0x767E, 0xFFBB},    // MC3_Y0DEF3_POS2 :
+	{2, 0x7680, 0xFFCE},    // MC3_X0DEF0_POS3 :
+	{2, 0x7682, 0xFFBA},    // MC3_Y0DEF0_POS3 :
+	{2, 0x7684, 0xFFE2},    // MC3_X0DEF1_POS3 :
+	{2, 0x7686, 0x0039},    // MC3_Y0DEF1_POS3 :
+	{2, 0x7688, 0xFFD3},    // MC3_X0DEF2_POS3 :
+	{2, 0x768A, 0xFFF6},    // MC3_Y0DEF2_POS3 :
+	{2, 0x768C, 0x003B},    // MC3_X0DEF3_POS3 :
+	{2, 0x768E, 0xFFBB},    // MC3_Y0DEF3_POS3 :
+	{2, 0x7690, 0xFFCE},    // MC3_X0DEF0_POS4 :
+	{2, 0x7692, 0xFFC9},    // MC3_Y0DEF0_POS4 :
+	{2, 0x7694, 0xFFE2},    // MC3_X0DEF1_POS4 :
+	{2, 0x7696, 0x0039},    // MC3_Y0DEF1_POS4 :
+	{2, 0x7698, 0xFFD3},    // MC3_X0DEF2_POS4 :
+	{2, 0x769A, 0xFFF6},    // MC3_Y0DEF2_POS4 :
+	{2, 0x769C, 0x003B},    // MC3_X0DEF3_POS4 :
+	{2, 0x769E, 0xFFBB},    // MC3_Y0DEF3_POS4 :
+	{2, 0x76A0, 0xFFCE},    // MC3_X0DEF0_POS5 :
+	{2, 0x76A2, 0xFFC9},    // MC3_Y0DEF0_POS5 :
+	{2, 0x76A4, 0xFFE2},    // MC3_X0DEF1_POS5 :
+	{2, 0x76A6, 0x0039},    // MC3_Y0DEF1_POS5 :
+	{2, 0x76A8, 0xFFD3},    // MC3_X0DEF2_POS5 :
+	{2, 0x76AA, 0xFFF6},    // MC3_Y0DEF2_POS5 :
+	{2, 0x76AC, 0x003B},    // MC3_X0DEF3_POS5 :
+	{2, 0x76AE, 0xFFBB},    // MC3_Y0DEF3_POS5 :
+	{2, 0x76B0, 0xFFCE},    // MC3_X0DEF0_POS6 :
+	{2, 0x76B2, 0xFFC9},    // MC3_Y0DEF0_POS6 :
+	{2, 0x76B4, 0xFFE2},    // MC3_X0DEF1_POS6 :
+	{2, 0x76B6, 0x0039},    // MC3_Y0DEF1_POS6 :
+	{2, 0x76B8, 0xFFD3},    // MC3_X0DEF2_POS6 :
+	{2, 0x76BA, 0xFFF6},    // MC3_Y0DEF2_POS6 :
+	{2, 0x76BC, 0x003B},    // MC3_X0DEF3_POS6 :
+	{2, 0x76BE, 0xFFBB},    // MC3_Y0DEF3_POS6 :
+	{2, 0x76C0, 0xFFCE},    // MC3_X0DEF0_POS7 :
+	{2, 0x76C2, 0xFFC9},    // MC3_Y0DEF0_POS7 :
+	{2, 0x76C4, 0xFFE2},    // MC3_X0DEF1_POS7 :
+	{2, 0x76C6, 0x0039},    // MC3_Y0DEF1_POS7 :
+	{2, 0x76C8, 0xFFD3},    // MC3_X0DEF2_POS7 :
+	{2, 0x76CA, 0xFFF6},    // MC3_Y0DEF2_POS7 :
+	{2, 0x76CC, 0x003B},    // MC3_X0DEF3_POS7 :
+	{2, 0x76CE, 0xFFBB},    // MC3_Y0DEF3_POS7 :
+	{2, 0x76D0, 0xFF7E},    // MC3_X0DEF0_OUT :
+	{2, 0x76D2, 0xFFE2},    // MC3_Y0DEF0_OUT :
+	{2, 0x76D4, 0x003C},    // MC3_X0DEF1_OUT :
+	{2, 0x76D6, 0xFFEC},    // MC3_Y0DEF1_OUT :
+	{2, 0x76D8, 0xFFD0},    // MC3_X0DEF2_OUT :
+	{2, 0x76DA, 0x0037},    // MC3_Y0DEF2_OUT :
+	{2, 0x76DC, 0xFFC4},    // MC3_X0DEF3_OUT :
+	{2, 0x76DE, 0xFFEC},    // MC3_Y0DEF3_OUT :
+	{2, 0x76E0, 0xFFCE},    // MC3_X0DEF0_R2_POS4 :
+	{2, 0x76E2, 0xFFC9},    // MC3_Y0DEF0_R2_POS4 :
+	{2, 0x76E4, 0xFFD0},    // MC3_X0DEF1_R2_POS4 :
+	{2, 0x76E6, 0x0037},    // MC3_Y0DEF1_R2_POS4 :
+	{2, 0x76E8, 0xFFD3},    // MC3_X0DEF2_R2_POS4 :
+	{2, 0x76EA, 0xFFF6},    // MC3_Y0DEF2_R2_POS4 :
+	{2, 0x76EC, 0x003B},    // MC3_X0DEF3_R2_POS4 :
+	{2, 0x76EE, 0xFFBB},    // MC3_Y0DEF3_R2_POS4 :
+	{2, 0x76F0, 0xFFCE},    // MC3_X0DEF0_R2_POS5 :
+	{2, 0x76F2, 0xFFC9},    // MC3_Y0DEF0_R2_POS5 :
+	{2, 0x76F4, 0xFFD0},    // MC3_X0DEF1_R2_POS5 :
+	{2, 0x76F6, 0x0037},    // MC3_Y0DEF1_R2_POS5 :
+	{2, 0x76F8, 0xFFD3},    // MC3_X0DEF2_R2_POS5 :
+	{2, 0x76FA, 0xFFF6},    // MC3_Y0DEF2_R2_POS5 :
+	{2, 0x76FC, 0x003B},    // MC3_X0DEF3_R2_POS5 :
+	{2, 0x76FE, 0xFFBB},    // MC3_Y0DEF3_R2_POS5 :
+	{2, 0x7700, 0x0019},    // MC3_PXDEF0_POS1 :
+	{2, 0x7702, 0xFF66},    // MC3_PYDEF0_POS1 :
+	{2, 0x7704, 0x0009},    // MC3_PXDEF1_POS1 :
+	{2, 0x7706, 0x000A},    // MC3_PYDEF1_POS1 :
+	{2, 0x7708, 0xFFCC},    // MC3_PXDEF2_POS1 :
+	{2, 0x770A, 0xFFCC},    // MC3_PYDEF2_POS1 :
+	{2, 0x770C, 0xFFD7},    // MC3_PXDEF3_POS1 :
+	{2, 0x770E, 0x0068},    // MC3_PYDEF3_POS1 :
+	{2, 0x7710, 0x0000},    // MC3_PXDEF0_POS2 :
+	{2, 0x7712, 0xFF66},    // MC3_PYDEF0_POS2 :
+	{2, 0x7714, 0x0009},    // MC3_PXDEF1_POS2 :
+	{2, 0x7716, 0x000A},    // MC3_PYDEF1_POS2 :
+	{2, 0x7718, 0xFFCC},    // MC3_PXDEF2_POS2 :
+	{2, 0x771A, 0xFFCC},    // MC3_PYDEF2_POS2 :
+	{2, 0x771C, 0xFFD7},    // MC3_PXDEF3_POS2 :
+	{2, 0x771E, 0x0068},    // MC3_PYDEF3_POS2 :
+	{2, 0x7720, 0x0000},    // MC3_PXDEF0_POS3 :
+	{2, 0x7722, 0xFF80},    // MC3_PYDEF0_POS3 :
+	{2, 0x7724, 0x0009},    // MC3_PXDEF1_POS3 :
+	{2, 0x7726, 0x000A},    // MC3_PYDEF1_POS3 :
+	{2, 0x7728, 0xFFE6},    // MC3_PXDEF2_POS3 :
+	{2, 0x772A, 0xFFCC},    // MC3_PYDEF2_POS3 :
+	{2, 0x772C, 0xFFD7},    // MC3_PXDEF3_POS3 :
+	{2, 0x772E, 0x0068},    // MC3_PYDEF3_POS3 :
+	{2, 0x7730, 0x0000},    // MC3_PXDEF0_POS4 :
+	{2, 0x7732, 0xFFCC},    // MC3_PYDEF0_POS4 :
+	{2, 0x7734, 0x0009},    // MC3_PXDEF1_POS4 :
+	{2, 0x7736, 0x000A},    // MC3_PYDEF1_POS4 :
+	{2, 0x7738, 0xFFCC},    // MC3_PXDEF2_POS4 :
+	{2, 0x773A, 0xFFCC},    // MC3_PYDEF2_POS4 :
+	{2, 0x773C, 0xFFD7},    // MC3_PXDEF3_POS4 :
+	{2, 0x773E, 0x0068},    // MC3_PYDEF3_POS4 :
+	{2, 0x7740, 0x0000},    // MC3_PXDEF0_POS5 :
+	{2, 0x7742, 0xFFCC},    // MC3_PYDEF0_POS5 :
+	{2, 0x7744, 0x0009},    // MC3_PXDEF1_POS5 :
+	{2, 0x7746, 0x000A},    // MC3_PYDEF1_POS5 :
+	{2, 0x7748, 0xFFCC},    // MC3_PXDEF2_POS5 :
+	{2, 0x774A, 0xFFCC},    // MC3_PYDEF2_POS5 :
+	{2, 0x774C, 0xFFD7},    // MC3_PXDEF3_POS5 :
+	{2, 0x774E, 0x0068},    // MC3_PYDEF3_POS5 :
+	{2, 0x7750, 0xFFB3},    // MC3_PXDEF0_POS6 :
+	{2, 0x7752, 0x0000},    // MC3_PYDEF0_POS6 :
+	{2, 0x7754, 0x0009},    // MC3_PXDEF1_POS6 :
+	{2, 0x7756, 0x000A},    // MC3_PYDEF1_POS6 :
+	{2, 0x7758, 0xFFE6},    // MC3_PXDEF2_POS6 :
+	{2, 0x775A, 0xFFCC},    // MC3_PYDEF2_POS6 :
+	{2, 0x775C, 0xFFD7},    // MC3_PXDEF3_POS6 :
+	{2, 0x775E, 0x0068},    // MC3_PYDEF3_POS6 :
+	{2, 0x7760, 0xFFB3},    // MC3_PXDEF0_POS7 :
+	{2, 0x7762, 0x0000},    // MC3_PYDEF0_POS7 :
+	{2, 0x7764, 0x0009},    // MC3_PXDEF1_POS7 :
+	{2, 0x7766, 0x000A},    // MC3_PYDEF1_POS7 :
+	{2, 0x7768, 0xFFE6},    // MC3_PXDEF2_POS7 :
+	{2, 0x776A, 0xFFCC},    // MC3_PYDEF2_POS7 :
+	{2, 0x776C, 0xFFD7},    // MC3_PXDEF3_POS7 :
+	{2, 0x776E, 0x0068},    // MC3_PYDEF3_POS7 :
+	{2, 0x7770, 0x0019},    // MC3_PXDEF0_OUT :
+	{2, 0x7772, 0xFFE6},    // MC3_PYDEF0_OUT :
+	{2, 0x7774, 0xFF99},    // MC3_PXDEF1_OUT :
+	{2, 0x7776, 0xFFB3},    // MC3_PYDEF1_OUT :
+	{2, 0x7778, 0x001E},    // MC3_PXDEF2_OUT :
+	{2, 0x777A, 0x0000},    // MC3_PYDEF2_OUT :
+	{2, 0x777C, 0xFFE1},    // MC3_PXDEF3_OUT :
+	{2, 0x777E, 0xFFEB},    // MC3_PYDEF3_OUT :
+	{2, 0x7780, 0x0000},    // MC3_PXDEF0_R2_POS4 :
+	{2, 0x7782, 0xFFCC},    // MC3_PYDEF0_R2_POS4 :
+	{2, 0x7784, 0x0000},    // MC3_PXDEF1_R2_POS4 :
+	{2, 0x7786, 0x0000},    // MC3_PYDEF1_R2_POS4 :
+	{2, 0x7788, 0xFFCC},    // MC3_PXDEF2_R2_POS4 :
+	{2, 0x778A, 0xFFCC},    // MC3_PYDEF2_R2_POS4 :
+	{2, 0x778C, 0xFFD7},    // MC3_PXDEF3_R2_POS4 :
+	{2, 0x778E, 0x0068},    // MC3_PYDEF3_R2_POS4 :
+	{2, 0x7790, 0x0000},    // MC3_PXDEF0_R2_POS5 :
+	{2, 0x7792, 0xFFCC},    // MC3_PYDEF0_R2_POS5 :
+	{2, 0x7794, 0x0000},    // MC3_PXDEF1_R2_POS5 :
+	{2, 0x7796, 0x0000},    // MC3_PYDEF1_R2_POS5 :
+	{2, 0x7798, 0xFFCC},    // MC3_PXDEF2_R2_POS5 :
+	{2, 0x779A, 0xFFCC},    // MC3_PYDEF2_R2_POS5 :
+	{2, 0x779C, 0xFFD7},    // MC3_PXDEF3_R2_POS5 :
+	{2, 0x779E, 0x0068},    // MC3_PYDEF3_R2_POS5 :
+
+	{1, 0x981A,  0x0E},	
+	{1, 0x0006,  0x16},     //change iic addr		
+	ENDMARKER,
+};
+
+/* 1280*720: 720P*/
+static const struct regval_list module_720p_regs[] = {
+
+    {1, 0x0089,   0x00},        // OUTFMT_MONI(YUV) 
+    {2, 0x0090, 0x0500},        // HSIZE_MONI(1280)      
+    {2, 0x0096, 0x03c0},        // VSIZE_MONI(960)      
+    {1, 0x0086,   0x02},        // FPSTYPE_MONI(30fps)
+    {1, 0x0083,   0x01},        // SENSMODE_MONI(V1/2) 
+    {2, 0x00DE, 0x1169},        // YUVCONFIG                               
+    {2, 0x6A9E, 0x15c0},        // HMAX Extention ON(Capture 15fps ->
+    {1, 0x00AF,   0x11},        // HSENS_MODE(Monitor & Movie H1/2)		
+	
+	
+    {1, 0x008B,   0x00},         // OUTFMT_Movie(YUV) 
+    {2, 0x0094, 0x0500},         // HSIZE_(1280)      
+    {2, 0x009A, 0x02d0},         // VSIZE_MOVIE(720)      
+    {1, 0x0088,   0x02},         // FPSTYPE_MOVIE(30fps)
+    {1, 0x0085,   0x01},         // SENSMODE_MOVIE(V1/2) 	                                                            
+    {2, 0x00DE, 0x1169},         // YUVCONFIG                               
+    {2, 0x6A9E, 0x15c0},         // HMAX Extention ON(Capture 15fps ->
+    {1, 0x00AF,   0x11},          // HSENS_MODE(Monitor & Movie H1/2)
+
+    {1, 0x0081,   0x00},
+  	{1, 0x0081,   0x03},
+  	{1, 0x0082,   0x01},    
+  ENDMARKER,
+};
+/*1280*960: svga*/
+static const struct regval_list module_960p_regs[] = {
+    {1, 0x0089,   0x00},        // OUTFMT_MONI(YUV) 
+    {2, 0x0090, 0x0500},        // HSIZE_MONI(1280)      
+    {2, 0x0096, 0x03c0},        // VSIZE_MONI(960)      
+    {1, 0x0086,   0x02},        // FPSTYPE_MONI(30fps)
+    {1, 0x0083,   0x01},        // SENSMODE_MONI(V1/2) 
+    {2, 0x00DE, 0x1169},        // YUVCONFIG                               
+    {2, 0x6A9E, 0x15c0},        // HMAX Extention ON(Capture 15fps ->
+    {1, 0x00AF,   0x11},        // HSENS_MODE(Monitor & Movie H1/2)	
+    
+    {1, 0x0081,   0x00},
+  	{1, 0x0082,   0x01},
+	ENDMARKER,
+};
+/* 2592*1944: 5M*/
+static const struct regval_list module_qsxga_regs[] = {
+    {1, 0x008A,   0x00},         // OUTFMT_CAP(YUV)   
+    {2, 0x0092, 0x0a20},         // HSIZE_CAP(2560)) 2592 
+    {2, 0x0098, 0x0798},         // VSIZE_CAP(1920)  1944 
+    {1, 0x0087,   0x03},         // FPSTYPE_CAP(15fps)
+    {1, 0x0084,   0x00},         // SENSMODE_CAP(Full)
+    {2, 0x00DE, 0x1169},         // YUVCONFIG                               
+    {2, 0x6A9E, 0x15c0},         // HMAX Extention ON(Capture 15fps ->
+    {1, 0x00AF,   0x11},         // HSENS_MODE(Monitor & Movie H1/2)
+    
+    {1, 0x0081,   0x02},
+  	{1, 0x0082,   0x01},
+  ENDMARKER,
+};
+static const struct regval_list module_init_auto_focus[] = {
+	/*AF INIT*/
+    {1, 0x000B,	0x01}, //AF_EXT : AF driver start
+    {2, 0x6666, 0x0000},    // AF_AREA_LOW_TYPE1
+    {2, 0x6668, 0x0258},    // AF_AREA_HIGH_TYPE1(AF_SEARCH_AREA_HIGH) = 600
+    {2, 0x8B4C, 0x0258},    // AF_SEARCH_CORNER_HIGH =500
+    {2, 0x6656, 0x0000},    // AF_OVERSRCH_AREA_HIGH = CORNER_HIGH - AREA_HIGH
+    {2, 0x6622, 0x0004},    // AF_CAF_PARAM_WOBBLE_STEP  
+    {2, 0x6624, 0x002E},    // AF_CAF_CLIMB_STEP 
+    {2, 0x665A, 0x0000},    // AF_LENSPOS_ON_AFNG 	
+    
+    /*START CONSTANT AF*/
+    {1, 0x0188, 0x00}, //AE free window
+	{1, 0x00B2, 0x01}, //AFMODE_MONITOR : continous AF mode
+	{1, 0x00B3, 0x01}, //AFMODE_HREL : continous AF mode
+	{1, 0x00B4, 0x01}, //AFMODE_MOVIE : continous AF mode
+    ENDMARKER,
+};
+/*
+ * window size list
+ */
+ 
+/* 1280X960 */
+static struct camera_module_win_size module_win_960p = {
+    .name             = "960p",
+    .width            = 1280,
+    .height           = 960,
+    .win_regs         = module_960p_regs,
+    .frame_rate_array = frame_rate_svga,
+}; 
+/* 1280X720 */
+static struct camera_module_win_size module_win_720p = {
+    .name             = "720P",
+    .width            = WIDTH_720P,
+    .height           = HEIGHT_720P,
+    .win_regs         = module_720p_regs,
+    .frame_rate_array = frame_rate_720p,
+};
+/* 2592X1944 */
+static struct camera_module_win_size module_win_qsxga = {
+    .name             = "QSXGA",
+    .width            = WIDTH_QSXGA,
+    .height           = HEIGHT_QSXGA,
+    .win_regs         = module_qsxga_regs,
+    .frame_rate_array = frame_rate_qsxga,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_960p,    
+	&module_win_720p,
+	&module_win_qsxga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+
+
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+
+	ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+
+
+	ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+
+	ENDMARKER,
+};
+/*\D5\FD\B3\A3ģʽ*/
+static struct regval_list module_effect_normal_regs[] =
+{
+
+
+	ENDMARKER,
+};
+
+/*\B5\A5ɫ\A3\AC\BAڰ\D7\D5\D5Ƭ*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+
+	ENDMARKER,
+};
+
+/*\B8\BAƬЧ\B9\FB*/
+static struct regval_list module_effect_negative_regs[] =
+{
+
+
+	ENDMARKER,
+};
+/*\B8\B4\B9\C5Ч\B9\FB*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+
+	ENDMARKER,
+};
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+
+    {	.id = V4L2_CID_GAIN, 
+        .min = 256,
+        .max = 0XFFFF,
+        .step = 1,
+        .def = 2560,},
+    {	.id = V4L2_CID_AF_MODE,   //\B4\CB\CF\EE\D0\E8\D6\C3\D3\DA\CA\FD\D7\E9ͷ\B2\BF
+        .min = NONE_AF, 
+        .max = CONTINUE_AF|SINGLE_AF, 
+        .step = 1, 
+        .def = CONTINUE_AF|SINGLE_AF,},
+    {	.id = V4L2_CID_AUTO_WHITE_BALANCE, 
+        .min = 0, .
+            max = 1, 
+        .step = 1, 
+        .def = 1,},
+    {	.id = V4L2_CID_WHITE_BALANCE_TEMPERATURE, 
+        .min = 0, 
+        .max = 3, 
+        .step = 1, 
+        .def = 1,},
+//    {	.id = V4L2_CID_SCENE_EXPOSURE, 
+//        .min = 0, 
+//        .max = 1, 
+//        .step = 1, 
+//        .def = 0,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+//    {	.id = V4L2_CID_PRIVATE_PREV_CAPT, 
+//        .min = 0, 
+//        .max = 1, 
+//        .step = 1, 
+//        .def = PREVIEW_MODE,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+#if 0
+    {	.id = V4L2_CID_AF_STATUS, 
+        .min = AF_STATUS_DISABLE, 
+        .max = AF_STATUS_FAIL, 
+        .step = 1, 
+        .def = AF_STATUS_DISABLE,},
+    {	.id = V4L2_CID_FLASH_STROBE, 
+        .min = 0, 
+        .max = 1, 
+        .step = 1, 
+        .def = 0,},
+    {	.id = V4L2_CID_FLASH_STROBE_STOP, 
+        .min = 0, 
+        .max = 1, 
+        .step = 1, 
+        .def = 0,},
+#endif
+    // {	.id = V4L2_CID_SENSOR_ID, 
+        // .min = 0,
+        // .max = 0xffffff,
+        // .step = 1,
+        // .def = 0,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+    {	.id = V4L2_CID_COLORFX, 
+        .max = 3, 
+        .mask = 0x0, 
+        .def = 0,},
+    {	.id = V4L2_CID_EXPOSURE_AUTO, 
+        .max = 1, 
+        .mask = 0x0, 
+        .def = 1,},
+     {
+		.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+		.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+		.mask = 0x0,
+		.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+#if 0
+    {	.id = V4L2_CID_FLASH_LED_MODE, 
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,},
+#endif
+};
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/hi257/Kconfig b/drivers/media/i2c/camera/hi257/Kconfig
new file mode 100755
index 0000000..16c5d5a
--- /dev/null
+++ b/drivers/media/i2c/camera/hi257/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config HI257
+	tristate "hi257 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for hi257 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called hi257.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/hi257/Makefile b/drivers/media/i2c/camera/hi257/Makefile
new file mode 100755
index 0000000..c09401c
--- /dev/null
+++ b/drivers/media/i2c/camera/hi257/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_HI257)	+= hi257.o
diff --git a/drivers/media/i2c/camera/hi257/hi257.c b/drivers/media/i2c/camera/hi257/hi257.c
new file mode 100755
index 0000000..fb97dda
--- /dev/null
+++ b/drivers/media/i2c/camera/hi257/hi257.c
@@ -0,0 +1,536 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include"../module_comm/camera_chip_ident.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+
+
+
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0)
+			{
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+			}
+		vals++;
+	}
+	return 0;
+}
+
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret = 0;
+	unsigned int reg_0x01;
+	printk("in the hi257 module_soft_reset\n");
+	ret = camera_i2c_write(client->adapter, 0x03, 0x00);
+	ret = camera_i2c_read(client->adapter, 0x01, &reg_0x01);
+	reg_0x01 |= (0x01 << 0x1);   
+    ret |= camera_i2c_write(client->adapter, 0x01, reg_0x01);
+    mdelay(1);
+    reg_0x01  &= (~(0x01 << 0x1));
+    ret |= camera_i2c_write(client->adapter, 0x01, reg_0x01);
+	msleep(10);
+	return ret;
+}
+static int  module_start_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+
+	//printk("int the module_start_aec\n ");
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_freeze_aec\n ");
+	return ret;
+}
+
+
+
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int scene_exposure = ctrl->val;
+	unsigned int reg_0x03 = 0x10;
+	unsigned int reg_0x12;	
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03);
+	ret |= camera_i2c_read(client->adapter, 0x12, &reg_0x12); 
+	reg_0x12 |= 0x10;  //make sure the Yoffset control is opened.
+	ret |= camera_i2c_write(client->adapter, 0x12, reg_0x12);
+	
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_NIGHT:  //\CA\D2\C4\DA
+		ret = camera_write_array(client->adapter, module_scene_night_regs);
+		break;
+	
+	case V4L2_SCENE_MODE_SUNSET:  //\CA\D2\CD\E2
+		ret = camera_write_array(client->adapter, module_scene_auto_regs);
+		break;
+	
+	default:
+		printk("[gc2035] set scene_exposure over range, scene_exposure = %d\n", scene_exposure);
+		return -ERANGE;
+	}
+
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+	return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_save_exposure_param\n ");
+	return ret;
+}
+
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	//int auto_white_balance = ctrl->val;
+	int ret = 0;
+	
+	int auto_white_balance;
+		if(ctrl)
+			{
+			auto_white_balance = ctrl->val;
+		}
+		else 
+			{
+				auto_white_balance = 1;
+			}
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		{
+	ctrl->cur.val = auto_white_balance;
+		}
+
+	return ret;
+}
+
+
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	#if 1
+	switch(ctrl->val){
+		case 4:
+			camera_write_array(client->adapter,module_exp_comp_pos4_regs);
+			break;
+		case 3:
+			camera_write_array(client->adapter,module_exp_comp_pos3_regs);
+			break;
+		case 2:
+			camera_write_array(client->adapter,module_exp_comp_pos2_regs);
+			break;
+		case 1:
+			camera_write_array(client->adapter,module_exp_comp_pos1_regs);
+			break;
+		case 0:
+			camera_write_array(client->adapter,module_exp_comp_zero_regs);
+			break;
+		case -1:
+			camera_write_array(client->adapter,module_exp_comp_neg1_regs);
+			break;
+		case -2:
+			camera_write_array(client->adapter,module_exp_comp_neg2_regs);
+			break;
+		case -3:
+			camera_write_array(client->adapter,module_exp_comp_neg3_regs);
+			break;
+		case -4:
+			camera_write_array(client->adapter,module_exp_comp_neg4_regs);
+			break;
+		default:
+			break;		
+	}
+	#endif
+	
+	return ret;
+}
+
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_set_exposure_param\n ");
+	return ret;
+}
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int reg_0x10, reg_0x03;
+	unsigned int reg_0x83,reg_0x84,reg_0x85;
+	int ret = 0;
+	reg_0x03 = 0x20;
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03);
+	
+	reg_0x10 = 0;
+	ret = camera_i2c_read(client->adapter, 0x10, &reg_0x10);
+	if(reg_0x10 >> 7){
+		ret |= camera_i2c_read(client->adapter, 0x80, &reg_0x83);
+		ret |= camera_i2c_read(client->adapter, 0x81, &reg_0x84);
+		ret |= camera_i2c_read(client->adapter, 0x82, &reg_0x85);
+	}
+	else {
+		ret |= camera_i2c_read(client->adapter, 0x83, &reg_0x83);
+		ret |= camera_i2c_read(client->adapter, 0x84, &reg_0x84);
+		ret |= camera_i2c_read(client->adapter, 0x85, &reg_0x85);
+	}
+	ctrl->val = ((reg_0x83&0xff)<<16) + ((reg_0x84&0xff) << 8) + (reg_0x85&0xff);
+	ctrl->val /= 246;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int reg_0x03;
+	unsigned int reg_0xb0;
+	
+	
+	reg_0x03 = 0x20;
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03);
+	
+	reg_0xb0 = 0;
+	ret = camera_i2c_read(client->adapter, 0xb0, &reg_0xb0);	
+	ctrl->val = (reg_0xb0 + 16) * 16;
+
+	return ret;
+	return ret;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int reg_0x03;
+	unsigned int reg_0xb0;
+	int ret = 0;
+	int gain; 
+
+	gain = ctrl->val / 16 - 16;
+	if (gain < 0) {
+		gain = 0;
+	}
+		
+	reg_0x03 = 0x20;
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03);
+	
+	reg_0xb0 = gain;
+	ret = camera_i2c_write(client->adapter, 0xb0, reg_0xb0);	
+ 
+	return ret;
+}
+
+
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+   // int exposure_auto = ctrl->val;
+	int ret = 0;
+	
+	int exposure_auto;
+		if(ctrl)
+			{
+			exposure_auto = ctrl->val;
+			}
+		else 
+			{
+				exposure_auto = V4L2_EXPOSURE_AUTO;
+			}
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		{
+	ctrl->cur.val = exposure_auto;
+		}
+
+	return 0;
+}
+
+
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	
+	int ret = 0;
+	   if (!enable) {
+		   GC_INFO("stream down");
+			return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	  return ret;
+}
+
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+
+
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	int ret = 0;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		
+		break;
+		
+	default:
+		return -ERANGE;
+	}
+	
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+
+{
+	unsigned int ret = 0;
+	
+	return ret;
+}
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int  		pid;
+	int ret = 0;
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PID, &pid); 
+	switch (pid) 
+    {
+	case CAMERA_MODULE_PID:
+		if(priv)
+			{
+		     priv->model= V4L2_IDENT_HI257;
+			}
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, pid);
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, pid);
+		return -ENODEV;
+	}
+	return ret;
+}
+
+
+
diff --git a/drivers/media/i2c/camera/hi257/module_diff.h b/drivers/media/i2c/camera/hi257/module_diff.h
new file mode 100755
index 0000000..5cd3932
--- /dev/null
+++ b/drivers/media/i2c/camera/hi257/module_diff.h
@@ -0,0 +1,1480 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+
+#define CAMERA_MODULE_NAME 		"hi257"
+#define CAMERA_MODULE_PID		0xc4
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_I2C_REAL_ADDRESS  (0x40 >> 1)
+#define MODULE_I2C_REG_ADDRESS		(0x40 >> 1)
+
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+//#define IS_FRONT_OR_REAR        0
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_FALLING
+
+
+
+
+#define PID						0x04 /* Product ID Number */
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_SVGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_SVGA
+#define MODULE_MAX_WIDTH		UXGA_WIDTH
+#define MODULE_MAX_HEIGHT		UXGA_WIDTH
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		3
+#define DROP_NUM_PREVIEW		3
+
+static unsigned int frame_rate_svga[]   = {30,};
+
+static unsigned int frame_rate_uxga[]   = {15,};
+
+
+static const struct regval_list module_init_regs[] =
+{
+    {0x01, 0x01},//sleep on
+	{0x01, 0x03},//sleep off
+	{0x01, 0x01},//sleep on
+
+	{0x03, 0x00},//Dummy 750us
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	                       
+	{0x08, 0x00},
+	{0x09, 0x77},	// pad strength = max
+	{0x0a, 0x07},	// pad strength = max
+	       
+	{0x0e, 0x03},//PLL On
+	{0x0e, 0x73},//PLLx2
+	                  
+	{0x03, 0x00},//Dummy 750us
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+
+	///// PAGE 20 /////
+	{0x03, 0x20},//page 20
+	{0x10, 0x1c},//AE off 50hz
+
+	///// PAGE 22 /////
+	{0x03, 0x22},//page 22
+	{0x10, 0x69},//AWB off
+
+	///// Initial Start /////
+	///// PAGE 0 Start /////
+	{0x03, 0x00},//page 0
+	{0x10, 0x91},//Pre off
+	{0x11, 0x90},//Windowing On + 0Frame Skip
+	{0x12, 0x24},//Rinsing edge 0x04 // Falling edge 0x00
+
+	{0x20, 0x00},//Row H
+	{0x21, 0x0a},//Row L
+	{0x22, 0x00},//Col H
+	{0x23, 0x0a},//Col L
+
+	{0x24, 0x04},//Window height_H //= 1200
+	{0x25, 0xb0},//Window height_L //
+	{0x26, 0x06},//Window width_H  //= 1600
+	{0x27, 0x40},//Window wight_L
+
+	{0x40, 0x01},//Hblank_376
+	{0x41, 0x78},
+	{0x42, 0x00},//Vblank
+	{0x43, 0x14},//Flick Stop
+
+	{0x50, 0x00},//Test Pattern
+
+	///// BLC /////
+	{0x80, 0x2e},
+	{0x81, 0x7e},
+	{0x82, 0x90},
+	{0x83, 0x00},
+	{0x84, 0x0c},
+	{0x85, 0x00},
+	{0x86, 0x00},
+	{0x87, 0x0f},
+	{0x88, 0x34},
+	{0x8a, 0x0b},
+	{0x8e, 0x80},//Pga Blc Hold
+
+	{0x90, 0x0a},//BLC_TIME_TH_ON
+	{0x91, 0x0a},//BLC_TIME_TH_OFF
+	{0x92, 0x98},//BLC_AG_TH_ON
+	{0x93, 0x90},//BLC_AG_TH_OFF
+	{0x96, 0xdc},//BLC Outdoor Th On
+	{0x97, 0xfe},//BLC Outdoor Th Off
+	{0x98, 0x38},
+
+	//OutDoor  BLC
+	{0x99, 0x43},//R,Gr,B,Gb Offset
+
+	//Dark BLC
+	{0xa0, 0x00},//R,Gr,B,Gb Offset
+
+	//Normal BLC
+	{0xa8, 0x43},//R,Gr,B,Gb Offset
+	///// PAGE 0 END /////
+
+
+	///// PAGE 2 START /////
+	{0x03, 0x02},
+	{0x10, 0x00},
+	{0x13, 0x00},
+	{0x14, 0x00},
+	{0x18, 0xcc},
+	{0x19, 0x01},// pmos switch on (for cfpn)
+	{0x1A, 0x09},
+	{0x1B, 0x00},
+	{0x1C, 0x1a}, // for ncp
+	{0x1D, 0x14}, // for ncp
+	{0x1E, 0x30}, // for ncp
+	{0x1F, 0x10},
+
+	{0x20, 0x77},
+	{0x21, 0xde},
+	{0x22, 0xa7},
+	{0x23, 0x30},
+	{0x24, 0x77},
+	{0x25, 0x10},
+	{0x26, 0x10},
+	{0x27, 0x3c},
+	{0x2b, 0x80},
+	{0x2c, 0x02},
+	{0x2d, 0x58},
+	{0x2e, 0xde},
+	{0x2f, 0xa7},
+
+	{0x30, 0x00},
+	{0x31, 0x99},
+	{0x32, 0x00},
+	{0x33, 0x00},
+	{0x34, 0x22},
+	{0x36, 0x75},
+	{0x38, 0x88},
+	{0x39, 0x88},
+	{0x3d, 0x03},
+	{0x3f, 0x02},
+
+	{0x49, 0x87},
+	{0x4a, 0x10},
+
+	{0x50, 0x21},
+	{0x53, 0xb1},
+	{0x54, 0x10},
+	{0x55, 0x1c},// for ncp
+	{0x56, 0x11},
+	{0x5d, 0xa2},
+	{0x5e, 0x5a},
+	{0x5d, 0xa2},
+	{0x5e, 0x5a},
+
+	{0x60, 0x87},
+	{0x61, 0x98},
+	{0x62, 0x88},
+	{0x63, 0x96},
+	{0x64, 0x88},
+	{0x65, 0x96},
+	{0x67, 0x3f},
+	{0x68, 0x3f},
+	{0x69, 0x3f},
+
+	{0x72, 0x89},
+	{0x73, 0x95},
+	{0x74, 0x89},
+	{0x75, 0x95},
+	{0x7C, 0x84},
+	{0x7D, 0xaf},
+
+	{0x80, 0x01},
+	{0x81, 0x7a},
+	{0x82, 0x13},
+	{0x83, 0x24},
+	{0x84, 0x78},
+	{0x85, 0x7c},
+
+	{0x92, 0x44},
+	{0x93, 0x59},
+	{0x94, 0x78},
+	{0x95, 0x7c},
+
+	{0xA0, 0x02},
+	{0xA1, 0x74},
+	{0xA4, 0x74},
+	{0xA5, 0x02},
+	{0xA8, 0x85},
+	{0xA9, 0x8c},
+	{0xAC, 0x10},
+	{0xAD, 0x16},
+
+	{0xB0, 0x99},
+	{0xB1, 0xa3},
+	{0xB4, 0x9b},
+	{0xB5, 0xa2},
+	{0xB8, 0x9b},
+	{0xB9, 0x9f},
+	{0xBC, 0x9b},
+	{0xBD, 0x9f},
+
+	{0xc4, 0x29},
+	{0xc5, 0x40},
+	{0xc6, 0x5c},
+	{0xc7, 0x72},
+	{0xc8, 0x2a},
+	{0xc9, 0x3f},
+	{0xcc, 0x5d},
+	{0xcd, 0x71},
+
+	{0xd0, 0x10},
+	{0xd1, 0x14},
+	{0xd2, 0x20},
+	{0xd3, 0x00},
+	{0xd4, 0x0a},//DCDC_TIME_TH_ON
+	{0xd5, 0x0a},//DCDC_TIME_TH_OFF 
+	{0xd6, 0x98},//DCDC_AG_TH_ON
+	{0xd7, 0x90},//DCDC_AG_TH_OFF
+	{0xdc, 0x00},
+	{0xdd, 0xa3},
+	{0xde, 0x00},
+	{0xdf, 0x84},
+
+	{0xe0, 0xa4},
+	{0xe1, 0xa4},
+	{0xe2, 0xa4},
+	{0xe3, 0xa4},
+	{0xe4, 0xa4},
+	{0xe5, 0x01},
+	{0xe8, 0x00},
+	{0xe9, 0x00},
+	{0xea, 0x77},
+
+	{0xF0, 0x00},
+	{0xF1, 0x00},
+	{0xF2, 0x00},
+
+	///// PAGE 2 END /////
+
+
+	///// PAGE 10 START /////
+	{0x03, 0x10},//page 10
+	{0x10, 0x01},//S2D enable _ UYVY Order
+	{0x11, 0x03},
+	{0x12, 0xf0},
+	{0x13, 0x03},
+
+	{0x20, 0x00},
+	{0x21, 0x40},
+	{0x22, 0x0f},
+	{0x24, 0x20},
+	{0x25, 0x10},
+	{0x26, 0x01},
+	{0x27, 0x02},
+	{0x28, 0x11},
+
+	{0x40, 0x80},
+	{0x41, 0x00}, //D-YOffset Th
+	{0x42, 0x00}, //Cb Offset
+	{0x43, 0x00}, //Cr Offset
+	{0x44, 0x80},
+	{0x45, 0x80},
+	{0x46, 0xf0},
+	{0x48, 0x88},
+	{0x4a, 0x80},
+
+	{0x50, 0xa0}, //D-YOffset AG
+
+	{0x60, 0x4f},
+	{0x61, 0x94}, //Sat B
+	{0x62, 0x98}, //Sat R
+	{0x63, 0x80}, //Auto-De Color
+
+	{0x66, 0x42},
+	{0x67, 0x22},
+
+	{0x6a, 0x8c}, //White Protection Offset Dark/Indoor
+	{0x74, 0x0c}, //White Protection Offset Outdoor
+	{0x76, 0x01}, //White Protection Enable
+
+
+
+	///// PAGE 11 START /////
+	{0x03, 0x11},//page 11
+
+	//LPF Auto Control
+	{0x20, 0x00},
+	{0x21, 0x00},
+	{0x26, 0x58},// Double_AG
+	{0x27, 0x52},// Double_AG
+	{0x28, 0x0f},
+	{0x29, 0x10},
+	{0x2b, 0x30},
+	{0x2c, 0x32},
+
+	//GBGR
+	{0x70, 0x2b},
+	{0x74, 0x30},
+	{0x75, 0x18},
+	{0x76, 0x30},
+	{0x77, 0xff},
+	{0x78, 0xa0},
+	{0x79, 0xff},//Dark GbGr Th
+	{0x7a, 0x30},
+	{0x7b, 0x20},
+	{0x7c, 0xf4},//Dark Dy Th B[7:4]
+	///// PAGE 11 END /////
+
+	///// PAGE 12 START /////
+	{0x03, 0x12},//page 11
+
+	//YC2D
+	{0x10, 0x03},//Y DPC Enable
+	{0x11, 0x08},//
+	{0x12, 0x10},//0x30 -> 0x10
+	{0x20, 0x53},//Y_lpf_enable
+	{0x21, 0x03},//C_lpf_enable_on
+	{0x22, 0xe6},//YC2D_CrCbY_Dy
+
+	{0x23, 0x14}, //Outdoor Dy Th
+	{0x24, 0x20}, //Indoor Dy Th // For reso Limit 0x20
+	{0x25, 0x30}, //Dark Dy Th
+
+	//Outdoor LPF Flat
+	{0x30, 0xff},//Y Hi Th
+	{0x31, 0x00},//Y Lo Th
+	{0x32, 0xf0},//Std Hi Th //Reso Improve Th Low //50
+	{0x33, 0x00},//Std Lo Th
+	{0x34, 0x00},//Median ratio
+
+	//Indoor LPF Flat
+	{0x35, 0xff},//Y Hi Th
+	{0x36, 0x00},//Y Lo Th
+	{0x37, 0xff},//Std Hi Th //Reso Improve Th Low //50
+	{0x38, 0x00},//Std Lo Th
+	{0x39, 0x00},//Median ratio
+
+	//Dark LPF Flat
+	{0x3a, 0xff},//Y Hi Th
+	{0x3b, 0x00},//Y Lo Th
+	{0x3c, 0x93},//Std Hi Th //Reso Improve Th Low //50
+	{0x3d, 0x00},//Std Lo Th
+	{0x3e, 0x00},//Median ratio
+
+	//Outdoor Cindition
+	{0x46, 0xa0},//Out Lum Hi
+	{0x47, 0x40},//Out Lum Lo
+
+	//Indoor Cindition
+	{0x4c, 0xb0},//Indoor Lum Hi
+	{0x4d, 0x60},//Indoor Lum Lo
+
+	//Dark Cindition
+	{0x52, 0xb0},//Dark Lum Hi
+	{0x53, 0x80},//Dark Lum Lo
+
+	//C-Filter
+	{0x70, 0x10},//Outdoor(2:1) AWM Th Horizontal
+	{0x71, 0x0a},//Outdoor(2:1) Diff Th Vertical
+	{0x72, 0x10},//Indoor,Dark1 AWM Th Horizontal
+	{0x73, 0x0a},//Indoor,Dark1 Diff Th Vertical
+	{0x74, 0x14},//Dark(2:3) AWM Th Horizontal
+	{0x75, 0x0c},//Dark(2:3) Diff Th Vertical
+
+	//DPC
+	{0x90, 0x3d},
+	{0x91, 0x34},
+	{0x99, 0x28},
+	{0x9c, 0x14},
+	{0x9d, 0x15},
+	{0x9e, 0x28},
+	{0x9f, 0x28},
+	{0xb0, 0x0e},//Zipper noise Detault change (0x75->0x0e)
+	{0xb8, 0x44},
+	{0xb9, 0x15},
+	///// PAGE 12 END /////
+
+	///// PAGE 13 START /////
+	{0x03, 0x13},//page 13
+
+	{0x80, 0xfd},//Sharp2D enable _ YUYV Order 
+	{0x81, 0x07},//Sharp2D Clip/Limit
+	{0x82, 0x71}, //Sharp2D Filter 
+	{0x83, 0x00},//Sharp2D Low Clip
+	{0x85, 0x00},
+
+	{0x92, 0x33},//Sharp2D Slop n/p
+	{0x93, 0x30},//Sharp2D LClip
+	{0x94, 0x02},//Sharp2D HiClip1 Th
+	{0x95, 0xf0},//Sharp2D HiClip2 Th
+	{0x96, 0x1e},//Sharp2D HiClip2 Resolution
+	{0x97, 0x40},
+	{0x98, 0x80},
+	{0x99, 0x40},
+
+	//Sharp Lclp
+	{0xa2, 0x04},//Outdoor Lclip_N
+	{0xa3, 0x05},//Outdoor Lclip_P
+	{0xa4, 0x04},//Indoor Lclip_N 0x03 For reso Limit 0x0e
+	{0xa5, 0x05},//Indoor Lclip_P 0x0f For reso Limit 0x0f
+	{0xa6, 0x80},//Dark Lclip_N
+	{0xa7, 0x80},//Dark Lclip_P
+
+	//Outdoor Slope
+	{0xb6, 0x28},//Lum negative Hi
+	{0xb7, 0x20},//Lum negative middle
+	{0xb8, 0x24},//Lum negative Low
+	{0xb9, 0x28},//Lum postive Hi
+	{0xba, 0x20},//Lum postive middle
+	{0xbb, 0x24},//Lum postive Low
+
+	//Indoor Slope
+	{0xbc, 0x28},//Lum negative Hi
+	{0xbd, 0x20},//Lum negative middle
+	{0xbe, 0x24},//Lum negative Low
+	{0xbf, 0x28},//Lum postive Hi
+	{0xc0, 0x20},//Lum postive middle
+	{0xc1, 0x24},//Lum postive Low
+
+	//Dark Slope
+	{0xc2, 0x18},//dark
+	{0xc3, 0x18},//Lum negative middle
+	{0xc4, 0x18},
+	{0xc5, 0x18},
+	{0xc6, 0x18},//Lum postive middle
+	{0xc7, 0x18},
+	///// PAGE 13 END /////
+
+	///// PAGE 14 START /////
+	{0x03, 0x14},//page 14
+	{0x10, 0x01},
+
+	{0x20, 0xA0},//X-Center
+	{0x21, 0x80},//Y-Center
+
+	{0x22, 0x1d},//LSC R 1b->15 20130125
+	{0x23, 0x16},//LSC G
+	{0x24, 0x14},//LSC B
+
+	{0x25, 0xf0},//LSC Off
+	{0x26, 0xf0},//LSC On
+	///// PAGE 14 END /////
+
+	/////// PAGE 15 START ///////
+	{0x03, 0x15},//page 15
+	{0x10, 0x21},
+	{0x14, 0x44},	//CMCOFSGH 
+	{0x15, 0x34},	//CMCOFSGM
+	{0x16, 0x26},	//CMCOFSGL
+	{0x17, 0x2f},	//CMC SIGN
+	//CMC
+	{0x30, 0xdd},
+	{0x31, 0x68},
+	{0x32, 0x0b},
+	{0x33, 0x2c},
+	{0x34, 0xce},
+	{0x35, 0x22},
+	{0x36, 0x04},
+	{0x37, 0x38},
+	{0x38, 0xbc},
+	//CMC OFS
+	{0x40, 0x90},
+	{0x41, 0x16},
+	{0x42, 0x86},
+	{0x43, 0x01},
+	{0x44, 0x10},
+	{0x45, 0x91},
+	{0x46, 0x82},
+	{0x47, 0x9c},
+	{0x48, 0x1d},
+	//CMC POFS
+	{0x50, 0x0d},
+	{0x51, 0x91},
+	{0x52, 0x04},
+	{0x53, 0x07},
+	{0x54, 0x19},
+	{0x55, 0xa0},
+	{0x56, 0x00},
+	{0x57, 0x98},
+	{0x58, 0x18},
+	///// PAGE 15 END /////
+	///// PAGE 16 START /////
+	{0x03, 0x16},
+	{0x10, 0x31},//GMA_CTL
+	{0x18, 0x5a},//AG_ON
+	{0x19, 0x58},//AG_OFF
+	{0x1A, 0x0e},//TIME_ON
+	{0x1B, 0x01},//TIME_OFF
+	{0x1C, 0xdc},//OUT_ON
+	{0x1D, 0xfe},//OUT_OFF
+	//GMA
+	{0x30, 0x00},
+	{0x31, 0x0b},
+	{0x32, 0x19},
+	{0x33, 0x2e},
+	{0x34, 0x5c},
+	{0x35, 0x78},
+	{0x36, 0x90},
+	{0x37, 0xa1},
+	{0x38, 0xaf},
+	{0x39, 0xb9},
+	{0x3a, 0xc1},
+	{0x3b, 0xca},
+	{0x3c, 0xd5},
+	{0x3d, 0xde},
+	{0x3e, 0xe6},
+	{0x3f, 0xec},
+	{0x40, 0xf4},
+	{0x41, 0xfa},
+	{0x42, 0xff},
+
+
+	//Outdoor
+	{0x50, 0x00},
+	{0x51, 0x03},
+	{0x52, 0x10},
+	{0x53, 0x26},
+	{0x54, 0x43},
+	{0x55, 0x5d},
+	{0x56, 0x79},
+	{0x57, 0x8c},
+	{0x58, 0x9f},
+	{0x59, 0xaa},
+	{0x5a, 0xb6},
+	{0x5b, 0xc3},
+	{0x5c, 0xce},
+	{0x5d, 0xd9},
+	{0x5e, 0xe1},
+	{0x5f, 0xe9},
+	{0x60, 0xf0},
+	{0x61, 0xf4},
+	{0x62, 0xf5},
+
+	//Dark
+	{0x70, 0x00},
+	{0x71, 0x10},
+	{0x72, 0x1c},
+	{0x73, 0x2e},
+	{0x74, 0x4e},
+	{0x75, 0x6c},
+	{0x76, 0x82},
+	{0x77, 0x96},
+	{0x78, 0xa7},
+	{0x79, 0xb6},
+	{0x7a, 0xc4},
+	{0x7b, 0xd0},
+	{0x7c, 0xda},
+	{0x7d, 0xe2},
+	{0x7e, 0xea},
+	{0x7f, 0xf0},
+	{0x80, 0xf6},
+	{0x81, 0xfa},
+	{0x82, 0xff},///// PAGE 16 END /////
+
+	///// PAGE 17 START /////
+	{0x03, 0x17}, //page 17
+	{0xc1, 0x00},
+	{0xc4, 0x4b},
+	{0xc5, 0x3f},
+	{0xc6, 0x02},
+	{0xc7, 0x20},
+	{0x03, 0x18},//page18
+	{0x10, 0x00},
+	{0x03, 0x19},//page19
+	{0x10, 0x7f},
+	{0x11, 0x7f},
+	{0x12, 0x1e},
+	{0x13, 0x32},
+	{0x14, 0x1e},
+	{0x15, 0x5e},
+	{0x16, 0x0a},
+	{0x17, 0xb8},
+	{0x18, 0x1e},
+	{0x19, 0xe6},
+	{0x1a, 0x9e},
+	{0x1b, 0x22},
+	{0x1c, 0x9e},
+	{0x1d, 0x5e},
+	{0x1e, 0x3b},
+	{0x1f, 0x30},//26
+	{0x20, 0x40},//50
+	{0x21, 0x40},//60
+	{0x22, 0x2f},
+	{0x23, 0x27},
+	{0x24, 0x00},
+	{0x25, 0x01},
+	{0x26, 0x0e},
+	{0x27, 0x04},
+	{0x28, 0x00},
+	{0x29, 0x8c},
+	{0x2a, 0x40},
+	{0x2b, 0x3f},
+	{0x2c, 0x00},
+	{0x2d, 0x00},
+	{0x2e, 0x00},
+	{0x2f, 0x00},
+	{0x30, 0x00},
+	{0x31, 0x00},
+	{0x32, 0x00},
+	{0x33, 0x00},
+	{0x34, 0x00},
+	{0x35, 0x00},
+	{0x36, 0x00},
+	{0x37, 0x00},
+	{0x38, 0x00},
+	{0x39, 0x00},
+	{0x3a, 0x00},
+	{0x3b, 0x00},
+	{0x3c, 0x00},
+	{0x3d, 0x00},
+	{0x3e, 0x00},
+	{0x3f, 0x00},
+	{0x40, 0x00},
+	{0x41, 0x00},
+	{0x42, 0x00},
+	{0x43, 0x00},
+	{0x44, 0x00},
+	{0x45, 0x00},
+	{0x46, 0x00},
+	{0x47, 0x00},
+	{0x48, 0x00},
+	{0x49, 0x00},
+	{0x4a, 0x00},
+	{0x4b, 0x00},
+	{0x4c, 0x00},
+	{0x4d, 0x00},
+	{0x4e, 0x00},
+	{0x4f, 0x00},
+	{0x50, 0x00},
+	{0x51, 0x00},
+	{0x52, 0x00},
+	{0x53, 0x10},
+	{0x54, 0x00},
+	{0x55, 0x01},
+	{0x56, 0x1b},
+	{0x57, 0x39},
+	{0x58, 0x5a},
+	{0x59, 0x80},
+	{0x5a, 0xa6},
+	{0x5b, 0xc1},
+	{0x5c, 0xe8},
+	{0x5d, 0x38},
+	{0x5e, 0x3a},
+	{0x5f, 0x3c},
+	{0x60, 0x3f},
+	{0x61, 0x3f},
+	{0x62, 0x3f},
+	{0x63, 0x3f},
+	{0x64, 0x3f},
+	{0x65, 0x00},
+	{0x66, 0x00},
+	{0x67, 0x00},
+	{0x68, 0x00},
+	{0x69, 0x00},
+	{0x6a, 0xff},
+	{0x6b, 0x00},
+	{0x6c, 0xff}, //mcmc_lum_ctl1 sat hue offset
+	{0x6d, 0x3f}, //mcmc_lum_ctl2 gain
+	{0x6e, 0x00}, //mcmc_lum_ctl3 hue
+	{0x6f, 0x00}, //mcmc_lum_ctl4 rgb offset
+	{0x70, 0x00}, //mcmc_lum_ctl5 rgb scale
+
+	{0x71, 0x3f}, //mcmc_lum_gain_wgt_th1 R1 magenta
+	{0x72, 0x3f}, //mcmc_lum_gain_wgt_th2 R1
+	{0x73, 0x3f}, //mcmc_lum_gain_wgt_th3 R1
+	{0x74, 0x3f}, //mcmc_lum_gain_wgt_th4 R1
+	{0x75, 0x30}, //mcmc_rg1_lum_sp1      R1
+	{0x76, 0x50}, //mcmc_rg1_lum_sp2      R1
+	{0x77, 0x80}, //mcmc_rg1_lum_sp3      R1
+	{0x78, 0xb0}, //mcmc_rg1_lum_sp4      R1
+
+	{0x79, 0x3f}, //mcmc_lum_gain_wgt_th1 R2 bright green
+	{0x7a, 0x3f}, //mcmc_lum_gain_wgt_th2 R2
+	{0x7b, 0x3f}, //mcmc_lum_gain_wgt_th3 R2
+	{0x7c, 0x3f}, //mcmc_lum_gain_wgt_th4 R2
+	{0x7d, 0x28}, //mcmc_rg2_lum_sp1      R2
+	{0x7e, 0x50},//mcmc_rg2_lum_sp2      R2
+	{0x7f, 0x80},//mcmc_rg2_lum_sp3      R2
+	{0x80, 0xb0},//mcmc_rg2_lum_sp4      R2
+
+	{0x81, 0x28},//mcmc_lum_gain_wgt_th1 R3 dark green
+	{0x82, 0x3f},//mcmc_lum_gain_wgt_th2 R3
+	{0x83, 0x3f},//mcmc_lum_gain_wgt_th3 R3
+	{0x84, 0x3f},//mcmc_lum_gain_wgt_th4 R3
+	{0x85, 0x28},//mcmc_rg3_lum_sp1      R3
+	{0x86, 0x50},//mcmc_rg3_lum_sp2      R3
+	{0x87, 0x80},//mcmc_rg3_lum_sp3      R3
+	{0x88, 0xb0},//mcmc_rg3_lum_sp4      R3
+
+	{0x89, 0x1a},//mcmc_lum_gain_wgt_th1 R4 skin
+	{0x8a, 0x28},//mcmc_lum_gain_wgt_th2 R4
+	{0x8b, 0x3f},//mcmc_lum_gain_wgt_th3 R4
+	{0x8c, 0x3f},//mcmc_lum_gain_wgt_th4 R4
+	{0x8d, 0x10},//mcmc_rg3_lum_sp1      R4
+	{0x8e, 0x30},//mcmc_rg3_lum_sp2      R4
+	{0x8f, 0x60},//mcmc_rg3_lum_sp3      R4
+	{0x90, 0x90},//mcmc_rg3_lum_sp4      R4
+
+	{0x91, 0x1a},//mcmc_rg5_gain_wgt_th1 R5 cyan
+	{0x92, 0x28},//mcmc_rg5_gain_wgt_th2 R5
+	{0x93, 0x3f},//mcmc_rg5_gain_wgt_th3 R5
+	{0x94, 0x3f},//mcmc_rg5_gain_wgt_th4 R5
+	{0x95, 0x28},//mcmc_rg5_lum_sp1      R5
+	{0x96, 0x50},//mcmc_rg5_lum_sp2      R5
+	{0x97, 0x80},//mcmc_rg5_lum_sp3      R5
+	{0x98, 0xb0},//mcmc_rg5_lum_sp4      R5
+
+	{0x99, 0x1a},//mcmc_rg6_gain_wgt_th1 R6 blue
+	{0x9a, 0x28},//mcmc_rg6_gain_wgt_th2 R6
+	{0x9b, 0x3f},//mcmc_rg6_gain_wgt_th3 R6
+	{0x9c, 0x3f},//mcmc_rg6_gain_wgt_th4 R6
+	{0x9d, 0x28},//mcmc_rg6_lum_sp1      R6
+	{0x9e, 0x50},//mcmc_rg6_lum_sp2      R6
+	{0x9f, 0x80},//mcmc_rg6_lum_sp3      R6
+	{0xa0, 0xb0},//mcmc_rg6_lum_sp4      R6
+
+	{0xa2, 0x00},
+	{0xe5, 0x80}, //add 20120709 Bit[7] On MCMC --> YC2D_LPF
+
+	/////// PAGE 20 START ///////
+	{0x03, 0x20},
+	{0x11, 0x1c},
+	{0x18, 0x30},
+	{0x20, 0x25},//8x8 Ae weight 0~7 Outdoor / Weight Outdoor On B[5]
+	{0x21, 0x30},
+	{0x22, 0x10},
+	{0x23, 0x00},
+
+	{0x28, 0xa7},
+	{0x29, 0x0d},
+	{0x2a, 0xff},
+	{0x2b, 0x34}, //Adaptive Off,1/100 Flicker
+
+	{0x2c, 0x83},//AE After CI
+	{0x2d, 0x03},
+	{0x2e, 0x13},
+	{0x2f, 0x0b},
+
+	{0x30, 0x78},
+	{0x31, 0xd7},
+	{0x32, 0x10},
+	{0x33, 0x2e},
+	{0x34, 0x20},
+	{0x35, 0xd4},
+	{0x36, 0xfe},
+	{0x37, 0x32},
+	{0x38, 0x04},
+	{0x39, 0x22},
+	{0x3a, 0xde},
+	{0x3b, 0x22},
+	{0x3c, 0xde},
+	{0x3d, 0xe1},
+
+	{0x50, 0x45},
+	{0x51, 0x88},
+
+	{0x56, 0x1f},// for tracking
+	{0x57, 0xa6},// for tracking
+	{0x58, 0x1a},// for tracking
+	{0x59, 0x7a},// for tracking 
+
+	{0x5a, 0x04},
+	{0x5b, 0x04},
+
+	{0x5e, 0xc7},
+	{0x5f, 0x95},
+
+	{0x62, 0x10},
+	{0x63, 0xc0},
+	{0x64, 0x10},
+	{0x65, 0x8a},
+	{0x66, 0x58},
+	{0x67, 0x58},
+
+	{0x70, 0x48}, //6c
+	{0x71, 0x80}, //81(+4),89(-4)
+
+	{0x76, 0x32},
+	{0x77, 0xa1},
+	{0x78, 0x22}, //24
+	{0x79, 0x35}, // Y Target 70 => 25, 72 => 26 //30jacky
+	{0x7a, 0x23}, //23
+	{0x7b, 0x22}, //22
+	{0x7d, 0x23},
+
+	{0x83, 0x0a}, //EXP Normal 9.09 fps 
+	{0x84, 0x12}, 
+	{0x85, 0x20}, 
+	{0x86, 0x01}, //EXPMin 12000.00 fps
+	{0x87, 0xf4}, 
+	{0x88, 0x09}, //EXP Max 60hz 9.23 fps 
+	{0x89, 0xeb}, 
+	{0x8a, 0x10}, 
+	{0xa5, 0x0a}, //EXP Max 50hz 9.09 fps 
+	{0xa6, 0x12}, 
+	{0xa7, 0x20}, 
+	{0x8B, 0xea}, //EXP100 
+	{0x8C, 0x60}, 
+	{0x8D, 0xc3}, //EXP120 
+	{0x8E, 0x50}, 
+	{0x9c, 0x1b}, //EXP Limit 857.14 fps 
+	{0x9d, 0x58}, 
+	{0x9e, 0x01}, //EXP Unit 
+	{0x9f, 0xf4}, 
+	{0xa3, 0x00}, //Outdoor Int 
+	{0xa4, 0xc3}, 
+
+	{0x9c, 0x0f},//EXP Limit 2155.17 fps
+	{0x9d, 0xa0},
+	{0x9e, 0x01},//EXP Unit
+	{0x9f, 0xf4},
+
+	{0xb0, 0x15},
+	{0xb1, 0x14},
+	{0xb2, 0x80},
+	{0xb3, 0x15},
+	{0xb4, 0x16},
+	{0xb5, 0x3c},
+	{0xb6, 0x29},
+	{0xb7, 0x23},
+	{0xb8, 0x20},
+	{0xb9, 0x1e},
+	{0xba, 0x1c},
+	{0xbb, 0x1b},
+	{0xbc, 0x1b},
+	{0xbd, 0x1a},
+
+	{0xc0, 0x10},
+	{0xc1, 0x40},
+	{0xc2, 0x40},
+	{0xc3, 0x40},
+	{0xc4, 0x06},
+
+	{0xc8, 0x80},
+	{0xc9, 0x80},
+	///// PAGE 20 END /////
+
+	///// PAGE 21 START /////
+	{0x03, 0x21},//page 21
+
+	//Indoor Weight
+	{0x20, 0x11},
+	{0x21, 0x11},
+	{0x22, 0x11},
+	{0x23, 0x11},
+	{0x24, 0x14},
+	{0x25, 0x44},
+	{0x26, 0x44},
+	{0x27, 0x41},
+	{0x28, 0x14},
+	{0x29, 0x44},
+	{0x2a, 0x44},
+	{0x2b, 0x41},
+	{0x2c, 0x14},
+	{0x2d, 0x47},
+	{0x2e, 0x74},
+	{0x2f, 0x41},
+	{0x30, 0x14},
+	{0x31, 0x47},
+	{0x32, 0x74},
+	{0x33, 0x41},
+	{0x34, 0x14},
+	{0x35, 0x44},
+	{0x36, 0x44},
+	{0x37, 0x41},
+	{0x38, 0x14},
+	{0x39, 0x44},
+	{0x3a, 0x44},
+	{0x3b, 0x41},
+	{0x3c, 0x11},
+	{0x3d, 0x11},
+	{0x3e, 0x11},
+	{0x3f, 0x11},
+
+	//Outdoor Weight
+	{0x40, 0x11},
+	{0x41, 0x11},
+	{0x42, 0x11},
+	{0x43, 0x11},
+	{0x44, 0x14},
+	{0x45, 0x44},
+	{0x46, 0x44},
+	{0x47, 0x41},
+	{0x48, 0x14},
+	{0x49, 0x44},
+	{0x4a, 0x44},
+	{0x4b, 0x41},
+	{0x4c, 0x14},
+	{0x4d, 0x47},
+	{0x4e, 0x74},
+	{0x4f, 0x41},
+	{0x50, 0x14},
+	{0x51, 0x47},
+	{0x52, 0x74},
+	{0x53, 0x41},
+	{0x54, 0x14},
+	{0x55, 0x44},
+	{0x56, 0x44},
+	{0x57, 0x41},
+	{0x58, 0x14},
+	{0x59, 0x44},
+	{0x5a, 0x44},
+	{0x5b, 0x41},
+	{0x5c, 0x11},
+	{0x5d, 0x11},
+	{0x5e, 0x11},
+	{0x5f, 0x11},
+
+
+	///// PAGE 22 START /////
+	{0x03, 0x22}, //page 22
+	{0x10, 0xfd},
+	{0x11, 0x2e},
+	{0x19, 0x00},
+	{0x20, 0x30}, //For AWB Speed
+	{0x21, 0x80},
+	{0x22, 0x00},
+	{0x23, 0x00},
+	{0x24, 0x01},
+	{0x25, 0x4f}, //2013-09-13 AWB Hunting
+
+	{0x30, 0x80},
+	{0x31, 0x81},
+	{0x38, 0x11},
+	{0x39, 0x34},
+	{0x40, 0xe4}, //Stb Yth
+	{0x41, 0x33}, //Stb cdiff
+	{0x42, 0x22}, //Stb csum
+	{0x43, 0xf3}, //Unstb Yth
+	{0x44, 0x55}, //Unstb cdiff
+	{0x45, 0x33}, //Unstb csum
+	{0x46, 0x00},
+	{0x47, 0x09}, //2013-09-13 AWB Hunting
+	{0x48, 0x00}, //2013-09-13 AWB Hunting
+	{0x49, 0x0a},
+
+	{0x60, 0x04},
+	{0x61, 0xc4},
+	{0x62, 0x04},
+	{0x63, 0x92},
+	{0x66, 0x04},
+	{0x67, 0xc4},
+	{0x68, 0x04},
+	{0x69, 0x92},
+
+	{0x80, 0x36},
+	{0x81, 0x20},
+	{0x82, 0x2a},
+
+	{0x83, 0x52},
+	{0x84, 0x10},
+	{0x85, 0x5f},
+	{0x86, 0x27},
+
+	{0x87, 0x44},
+	{0x88, 0x30},
+	{0x89, 0x2c},
+	{0x8a, 0x18},
+
+	{0x8b, 0x3b},
+	{0x8c, 0x32},
+	{0x8d, 0x2a},
+	{0x8e, 0x1b},
+
+	{0x8f, 0x4d},
+	{0x90, 0x4a},
+	{0x91, 0x45},
+	{0x92, 0x3f},
+	{0x93, 0x38},
+	{0x94, 0x31},
+	{0x95, 0x27},
+	{0x96, 0x1d},
+	{0x97, 0x13},
+	{0x98, 0x12},
+	{0x99, 0x11},
+	{0x9a, 0x10},
+
+	{0x9b, 0xaa},
+	{0x9c, 0xaa},
+	{0x9d, 0x48},
+	{0x9e, 0x38},
+	{0x9f, 0x30},
+
+	{0xa0, 0x70},
+	{0xa1, 0x54},
+	{0xa2, 0x6f},
+	{0xa3, 0xff},
+
+	{0xa4, 0x14}, //1536fps
+	{0xa5, 0x2c}, //698fps
+	{0xa6, 0xcf}, //148fps
+
+	{0xad, 0x2e},
+	{0xae, 0x28},
+
+	{0xaf, 0x18}, //Low temp Rgain
+	{0xb0, 0x16}, //Low temp Rgain
+
+	{0xb1, 0x08},
+	{0xb4, 0xbf}, //For Tracking AWB Weight
+	{0xb8, 0x5d}, //(0+,1-)High Cb , (0+,1-)Low Cr
+	{0xb9, 0xb0},
+	/////// PAGE 22 END ///////
+
+	/////// PAGE 20 ///////
+	{0x03, 0x20},
+	{0x10, 0x9c},//AE On 50hz
+
+	/////// PAGE 22 ///////
+	{0x03, 0x22},
+	{0x10, 0xe9},//AWB On
+
+	/////// PAGE 0 ///////
+	{0x03, 0x00},
+	{0x0e, 0x03},
+	{0x0e, 0x73},
+
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+
+	{0x03, 0x00},
+	{0x01, 0x00},
+
+	//{0x01, 0xf8}, // Sleep Off
+    ENDMARKER,
+};
+
+
+
+/* 800*600: SVGA */
+static const struct regval_list module_svga_regs[] = 
+{
+	
+	{0x03, 0x00},
+	{0x10, 0x10},
+	{0x12, 0x24},
+
+	{0x20, 0x00}, 
+	{0x21, 0x0a},
+	{0x22, 0x00},
+	{0x23, 0x0a},
+
+	{0x40, 0x01},//Hblank_376
+	{0x41, 0x78},
+	{0x42, 0x00},//Vblank
+	{0x43, 0x14},//Flick Stop
+
+	{0x03, 0x20},//page 20
+	
+	{0x86, 0x01},//EXPMin 17241.38 fps
+	{0x87, 0xf4},
+
+	
+	{0x8B, 0xea},//EXP100
+	{0x8C, 0x60},
+
+	{0x8D, 0xc3},//EXP120
+	{0x8E, 0x50},
+
+	{0x9c, 0x0f},//EXP Limit 2155.17 fps
+	{0x9d, 0xa0},
+	{0x9e, 0x01},//EXP Unit
+	{0x9f, 0xf4},
+	ENDMARKER,
+};
+
+
+
+
+/* 1600*1200: UXGA */
+static const struct regval_list module_uxga_regs[] = 
+{
+	{0x03, 0x00},
+	{0x10, 0x00},
+	{0x12, 0x24},
+
+	{0x20, 0x00}, 
+	{0x21, 0x0a}, 
+	{0x22, 0x00}, 
+	{0x23, 0x0a}, 
+	{0x24, 0x04}, 
+	{0x25, 0xb0}, 
+	{0x26, 0x06}, 
+	{0x27, 0x40}, 
+
+	{0x40, 0x01},//Hblank_376
+	{0x41, 0x78},
+	{0x42, 0x00},//Vblank
+	{0x43, 0x14},//Flick Stop
+
+	{0x03, 0x20},//page 20
+	
+	{0x86, 0x01},//EXPMin 17241.38 fps
+	{0x87, 0xf4},
+
+	
+	{0x8B, 0xea},//EXP100
+	{0x8C, 0x60},
+
+	{0x8D, 0xc3},//EXP120
+	{0x8E, 0x50},
+
+	{0x9c, 0x0f},//EXP Limit 2155.17 fps
+	{0x9d, 0xa0},
+	{0x9e, 0x01},//EXP Unit
+	{0x9f, 0xf4},
+	ENDMARKER,
+};
+
+
+
+
+/* 800*600 */
+static struct camera_module_win_size module_win_svga = {
+	.name             = "SVGA",
+	.width            = WIDTH_SVGA,
+	.height           = HEIGHT_SVGA,
+	.win_regs         = module_svga_regs,
+	.frame_rate_array = frame_rate_svga,
+	.capture_only     = 0,
+};
+
+/* 1600*1200 */
+static struct camera_module_win_size module_win_uxga = {
+	.name             = "UXGA",
+	.width            = WIDTH_UXGA,
+	.height           = HEIGHT_UXGA,
+	.win_regs         = module_uxga_regs,
+	.frame_rate_array = frame_rate_uxga,
+	.capture_only     = 1,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_svga,
+	&module_win_uxga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+	{0x03, 0x22},			
+	{0x11, 0x2e},				
+			
+	{0x83, 0x5e},
+	{0x84, 0x1e},
+	{0x85, 0x5e},
+	{0x86, 0x22},	
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	{0x03, 0x22},
+	{0x11, 0x28},
+	{0x80, 0x71},
+	{0x82, 0x2b},
+	{0x83, 0x72},
+	{0x84, 0x70},
+	{0x85, 0x2b},
+	{0x86, 0x28},
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+	{0x03, 0x22},
+	{0x11, 0x28},		  
+	{0x80, 0x59},
+	{0x82, 0x29},
+	{0x83, 0x60},
+	{0x84, 0x50},
+	{0x85, 0x2f},
+	{0x86, 0x23},
+    ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+	{0x03, 0x22},
+	{0x11, 0x28},
+	{0x80, 0x41},
+	{0x82, 0x42},
+	{0x83, 0x44},
+	{0x84, 0x34},
+	{0x85, 0x46},
+	{0x86, 0x3a},
+    ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	{0x03, 0x22},
+	{0x11, 0x28},		  
+	{0x80, 0x29},
+	{0x82, 0x54},
+	{0x83, 0x2e},
+	{0x84, 0x23},
+	{0x85, 0x58},
+	{0x86, 0x4f},
+	ENDMARKER,
+};
+
+
+static struct regval_list module_scene_auto_regs[] =
+{
+	{0x03, 0x10},
+	{0x40, 0x80},
+	
+	{0x03, 0x20},//page 20
+	{0x10, 0x1c},//AE ON
+	//{0x18, 0x38},
+
+    //{0x83, 0x02}, //EXP Normal 33.33 fps 
+	//{0x84, 0xbf}, 
+	//{0x85, 0x20}, 
+
+	{0x88, 0x09}, //EXP Max 60hz 9.23 fps 
+	{0x89, 0xeb}, 
+	{0x8a, 0x10}, 
+	{0xa5, 0x0a}, //EXP Max 50hz 9.09 fps 
+	{0xa6, 0x12}, 
+	{0xa7, 0x20}, 
+
+	{0x03, 0x20},//page 20
+	{0x10, 0x9c},//AE ON
+	ENDMARKER,
+};
+
+static struct regval_list module_scene_night_regs[] =
+{	
+    {0x03, 0x10},
+	{0x40, 0x20},
+
+	{0x03, 0x20},//page 20
+	{0x10, 0x1c},//AE ON
+	//{0x18, 0x38},
+
+    //{0x83, 0x02}, //EXP Normal 33.33 fps 
+	//{0x84, 0xbf}, 
+	//{0x85, 0x20}, 
+
+	{0x88, 0x09}, //EXP Max 60hz 9.23 fps 
+	{0x89, 0xeb}, 
+	{0x8a, 0x10}, 
+	{0xa5, 0x0a}, //EXP Max 50hz 9.09 fps 
+	{0xa6, 0x12}, 
+	{0xa7, 0x20}, 
+
+	{0x03, 0x20},//page 20
+	{0x10, 0x9c},//AE ON
+	ENDMARKER,
+};
+
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list module_exp_comp_neg4_regs[] = {
+	{0x03,0x20},
+	{0x70,0x12},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg3_regs[] = {
+	{0x03,0x20},
+	{0x70,0x2a},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg2_regs[] = {
+	{0x03,0x20},
+	{0x70,0x32},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg1_regs[] = {
+	{0x03,0x20},
+	{0x70,0x3a},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_zero_regs[] = {
+	{0x03,0x20},
+	{0x70,0x4a},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos1_regs[] = {
+	{0x03,0x20},
+	{0x70,0x4a},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos2_regs[] = {
+	{0x03,0x20},
+	{0x70,0x52},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos3_regs[] = {
+	{0x03,0x20},
+	{0x70,0x5a},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos4_regs[] = {
+	{0x03,0x20},
+	{0x70,0x62},
+	ENDMARKER,
+};
+
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{
+        .id = V4L2_CID_AUTO_WHITE_BALANCE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 1,
+    },
+    {	.id = V4L2_CID_EXPOSURE_COMP, 
+		.min = -4, 
+		.max = 4, 
+		.step = 1, 
+		.def = 0,
+	},	
+	{	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,
+	},
+    {
+        .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+        .min = 0,
+        .max = 3,
+        .step = 1,
+        .def = 0,
+    },
+    {	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+
+    {
+        .id = V4L2_CID_HFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_VFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+     {	.id = V4L2_CID_AF_MODE,
+		.min = NONE_AF, 
+		.max = CONTINUE_AF|SINGLE_AF, 
+		.step = 1, 
+		.def = NONE_AF,},
+    {	.id = V4L2_CID_AF_STATUS, 
+		.min = AF_STATUS_DISABLE, 
+		.max = AF_STATUS_FAIL, 
+		.step = 1, 
+		.def = AF_STATUS_DISABLE,},
+	{	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	 {
+        .id = V4L2_CID_COLORFX,
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_EXPOSURE_AUTO,
+        .max = 1,
+        .mask = 0x0,
+        .def = 1,
+    },
+  	{  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_TEXT, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+    {	.id = V4L2_CID_FLASH_LED_MODE, 
+		.max = 3,
+		.mask = 0x0,
+		.def = 0,},
+   {
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/hi708/Kconfig b/drivers/media/i2c/camera/hi708/Kconfig
new file mode 100755
index 0000000..bb4f7fd
--- /dev/null
+++ b/drivers/media/i2c/camera/hi708/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config HI708
+	tristate "hi708 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for hi708 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called hi708.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/hi708/Makefile b/drivers/media/i2c/camera/hi708/Makefile
new file mode 100755
index 0000000..5ba9cdf
--- /dev/null
+++ b/drivers/media/i2c/camera/hi708/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_HI708)	+= hi708.o
+
diff --git a/drivers/media/i2c/camera/hi708/hi708.c b/drivers/media/i2c/camera/hi708/hi708.c
new file mode 100755
index 0000000..154bfac
--- /dev/null
+++ b/drivers/media/i2c/camera/hi708/hi708.c
@@ -0,0 +1,679 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include"../module_comm/camera_chip_ident.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+
+
+
+
+
+
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	
+	int ret,i;
+	
+	
+	//printk("the i2c address is 0x%x value is 0x%x\n",reg,src);
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+    GC_INFO("");
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0)
+			{
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+			}
+		vals++;
+	}
+	return 0;
+}
+
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret = 0;
+	unsigned int reg_0x01;
+	GC_INFO("in the hi708 module_soft_reset\n");
+	msleep(10);
+	camera_i2c_write(client->adapter,0x03,0x00);
+    ret = camera_i2c_read(client->adapter, 0x01, &reg_0x01);
+    reg_0x01 |= (0x01 << 0x1);   
+    ret |= camera_i2c_write(client->adapter, 0x01, reg_0x01);
+    mdelay(1);
+    reg_0x01  &= (~(0x01 << 0x1));
+    ret |= camera_i2c_write(client->adapter, 0x01, reg_0x01);
+	msleep(10);
+	return ret;
+}
+
+#if 0
+static int module_normal(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int reg_0x03 = 0x00;
+	unsigned int reg_0x01;
+	int ret;
+	
+	GC_INFO("");
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03);
+	ret |= camera_i2c_read(client->adapter, 0x01, &reg_0x01);
+	reg_0x01 &= 0xfe;   //0λ\D6\C30
+	ret |= camera_i2c_write(client->adapter, 0x01, reg_0x01);
+	
+    return ret;
+}
+#endif
+
+static int  module_start_aec(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+
+	unsigned int reg_0x03 = 0x20;								 
+	unsigned int reg_0x10 = 0x00;	
+
+		GC_INFO("");
+	ret = camera_i2c_write(i2c_adap, 0x03, reg_0x03); //page 20	 
+	ret |= camera_i2c_read(i2c_adap, 0x10, &reg_0x10);			 
+	reg_0x10 |= 0xc0;											 
+	ret |= camera_i2c_write(i2c_adap, 0x10, reg_0x10);			 
+	ret |= camera_i2c_read(i2c_adap, 0x10, &reg_0x10);	
+
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;		
+	int ret = 0;												
+	unsigned int reg_0x03 = 0x20;								
+	unsigned int reg_0x10 = 0x00;
+	GC_INFO("");
+	ret = camera_i2c_write(i2c_adap, 0x03, reg_0x03); //page 20	
+	ret |= camera_i2c_read(i2c_adap, 0x10, &reg_0x10);			
+	reg_0x10 &= 0x7f;											
+	ret |= camera_i2c_write(i2c_adap, 0x10, reg_0x10);			
+	ret |= camera_i2c_read(i2c_adap, 0x10, &reg_0x10);	
+
+																
+	return ret; 												
+}
+
+
+#if 0
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{				  
+	int ret = 0;	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;	
+	unsigned int reg_0x03 = 0x20;												  
+	unsigned int reg_0x83 = 0;													  
+	unsigned int reg_0x84 = 0;													  
+	unsigned int reg_0x85 = 0;	
+	GC_INFO("");
+	if (priv->capture_exposure_param.shutter < 1)								  
+		priv->capture_exposure_param.shutter = 1;								  
+																				  
+	reg_0x83 = (priv->capture_exposure_param.shutter)>>16;						  
+	reg_0x84 = ((priv->capture_exposure_param.shutter)>>8) & 0x000000FF;		  
+	reg_0x85 = (priv->capture_exposure_param.shutter) & 0x000000FF; 			  
+																				  
+	ret  = camera_i2c_write(i2c_adap, 0x03, reg_0x03); //page 20					  
+	ret |= camera_i2c_write(i2c_adap, 0x83, reg_0x83);							  
+	ret |= camera_i2c_write(i2c_adap, 0x84, reg_0x84);							  
+	ret |= camera_i2c_write(i2c_adap, 0x85, reg_0x85);							  
+	return ret; 																  
+}
+
+#endif
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	unsigned int reg_0x03 = 0x20;
+	unsigned int reg_0x80 = 0;
+	unsigned int reg_0x81 = 0;
+	unsigned int reg_0x82 = 0;
+	
+	GC_INFO("");
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03); //page 20
+	ret |= camera_i2c_read(client->adapter, 0x80, &reg_0x80);
+	ret |= camera_i2c_read(client->adapter, 0x81, &reg_0x81);
+	ret |= camera_i2c_read(client->adapter, 0x82, &reg_0x82);
+			
+	priv->preview_exposure_param.shutter = (reg_0x80 << 16)|(reg_0x81 << 8)|reg_0x82;
+    priv->capture_exposure_param.shutter = (priv->preview_exposure_param.shutter);
+
+	return ret;
+}
+
+
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	int auto_white_balance;
+	if(ctrl)
+		{
+		auto_white_balance = ctrl->val;
+	}
+	else 
+		{
+			auto_white_balance = 1;
+		}
+
+	GC_INFO("");
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		{
+	ctrl->cur.val = auto_white_balance;
+		}
+
+	return ret;
+}
+
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	switch(ctrl->val){
+		case 4:
+			camera_write_array(client->adapter,module_exp_comp_pos4_regs);
+			break;
+		case 3:
+			camera_write_array(client->adapter,module_exp_comp_pos3_regs);
+			break;
+		case 2:
+			camera_write_array(client->adapter,module_exp_comp_pos2_regs);
+			break;
+		case 1:
+			camera_write_array(client->adapter,module_exp_comp_pos1_regs);
+			break;
+		case 0:
+			camera_write_array(client->adapter,module_exp_comp_zero_regs);
+			break;
+		case -1:
+			camera_write_array(client->adapter,module_exp_comp_neg1_regs);
+			break;
+		case -2:
+			camera_write_array(client->adapter,module_exp_comp_neg2_regs);
+			break;
+		case -3:
+			camera_write_array(client->adapter,module_exp_comp_neg3_regs);
+			break;
+		case -4:
+			camera_write_array(client->adapter,module_exp_comp_neg4_regs);
+			break;
+		default:
+			break;		
+	}
+	
+	return ret;
+}
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int reg_0x10, reg_0x03;
+	unsigned int reg_0x83,reg_0x84,reg_0x85;
+	int ret = 0;
+	reg_0x03 = 0x20;
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03);
+	
+	reg_0x10 = 0;
+	ret = camera_i2c_read(client->adapter, 0x10, &reg_0x10);
+	if(reg_0x10 >> 7){
+		ret |= camera_i2c_read(client->adapter, 0x80, &reg_0x83);
+		ret |= camera_i2c_read(client->adapter, 0x81, &reg_0x84);
+		ret |= camera_i2c_read(client->adapter, 0x82, &reg_0x85);
+	}
+	else {
+		ret |= camera_i2c_read(client->adapter, 0x83, &reg_0x83);
+		ret |= camera_i2c_read(client->adapter, 0x84, &reg_0x84);
+		ret |= camera_i2c_read(client->adapter, 0x85, &reg_0x85);
+	}
+	ctrl->val = ((reg_0x83&0xff)<<16) + ((reg_0x84&0xff) << 8) + (reg_0x85&0xff);
+	ctrl->val /= 246;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int reg_0x03;
+	unsigned int reg_0xb0;
+	int ret = 0;
+	reg_0x03 = 0x20;
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03);
+	
+	reg_0xb0 = 0;
+	ret = camera_i2c_read(client->adapter, 0xb0, &reg_0xb0);	
+	ctrl->val = (reg_0xb0 + 16) * 16;
+
+	return ret;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int reg_0x03;
+	unsigned int reg_0xb0;
+	int ret = 0;
+	int gain; 
+	gain = ctrl->val / 16 - 16;
+	if (gain < 0) {
+		gain = 0;
+	}
+		
+	reg_0x03 = 0x20;
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03);
+	
+	reg_0xb0 = gain;
+	ret = camera_i2c_write(client->adapter, 0xb0, reg_0xb0);	
+
+	return 0;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_set_exposure_param\n ");
+	return ret;
+}
+
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int white_balance_temperature = ctrl->val;
+	int ret = 0;
+	GC_INFO("");
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+		int ret = 0;
+	unsigned int reg_0x03 = 0x10;
+	unsigned int reg_0x12;
+	int exposure_auto;
+	if(ctrl)
+		{
+		exposure_auto = ctrl->val;
+		}
+	else 
+		{
+			exposure_auto = V4L2_EXPOSURE_AUTO;
+		}
+
+	GC_INFO("");
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		dev_err(&client->dev, "set exposure_auto over range, exposure_auto = %d\n", exposure_auto);
+		return -ERANGE;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+	ret |= camera_i2c_read(i2c_adap, 0x12, &reg_0x12); 
+	reg_0x12 |= 0x10;  //make sure the Yoffset control is opened.
+	ret |= camera_i2c_write(i2c_adap, 0x12, reg_0x12);
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		{
+		ctrl->cur.val = exposure_auto;
+		}
+
+	return 0;
+}
+
+
+
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    int scene_exposure = ctrl->val;
+
+	unsigned int reg_0x03 = 0x10;
+	unsigned int reg_0x12;
+	int ret;
+	GC_INFO("");
+	ret = camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+	ret |= camera_i2c_read(i2c_adap, 0x12, &reg_0x12); 
+	reg_0x12 |= 0x10;  //make sure the Yoffset control is opened.
+	ret |= camera_i2c_write(i2c_adap, 0x12, reg_0x12);
+	
+	switch(scene_exposure)
+	{
+		case V4L2_SCENE_MODE_NIGHT:  //\CA\D2\C4\DA
+		{
+			ret = camera_write_array(i2c_adap, module_scene_night_regs);
+			break;
+		}
+		case V4L2_SCENE_MODE_SUNSET:  //\CA\D2\CD\E2
+		{
+			ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+			break;
+		}
+		default:
+		{
+			dev_err(&client->dev, "set scene_exposure over range, scene_exposure = %d\n", scene_exposure);
+			return -ERANGE;
+		}
+	}
+
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+
+	return 0;
+}
+
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	msleep(10);
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+		  
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	   return ret;
+}
+
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+
+
+
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	int ret = 0;
+	unsigned int reg_0x10;
+	unsigned int reg_0x03 = 0x10;  //pgae10
+	GC_INFO("");
+
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_0x10 = 0x03;
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		reg_0x10 = 0x01;
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		reg_0x10 = 0x02;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		reg_0x10 = 0x00;
+		break;
+		
+	default:
+		return -ERANGE;
+	}
+	ret = camera_i2c_write(client->adapter, 0x03, reg_0x03);
+	ret |= camera_i2c_write(client->adapter, 0x10, reg_0x10);
+	
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	unsigned int reg_0x03 = 0x00;
+	unsigned int reg_0x11 = 0x90;
+	
+	GC_INFO("");
+	
+	if ((!mirror) && (!flip)) {
+		return 0;
+	}
+
+	ret = camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+
+	ret |= camera_i2c_read(i2c_adap, 0x11, &reg_0x11);
+	
+	if (mirror)	{
+		reg_0x11 |= 0x1;
+	} else {
+		reg_0x11 &= (~0x1);
+	}
+	
+	if (flip) {
+		reg_0x11 |= (0x1<<0x1);
+	} else {
+		reg_0x11 &= (~(0x1<<0x1));	
+	}
+	
+	ret |= camera_i2c_write(i2c_adap, 0x11, reg_0x11);
+	return ret;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int  		pid;
+	int ret = 0;
+	GC_INFO("");
+	
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PID, &pid); 
+	switch (pid) 
+    {
+	case CAMERA_MODULE_PID:
+		if(priv)
+			{
+		     priv->model= V4L2_IDENT_HI708;
+			}
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, pid);
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, pid);
+		return -ENODEV;
+	}
+	return ret;
+}
+
+
+
diff --git a/drivers/media/i2c/camera/hi708/module_diff.h b/drivers/media/i2c/camera/hi708/module_diff.h
new file mode 100755
index 0000000..36abdf9
--- /dev/null
+++ b/drivers/media/i2c/camera/hi708/module_diff.h
@@ -0,0 +1,984 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+
+#define CAMERA_MODULE_NAME 		"hi708"
+#define CAMERA_MODULE_PID		0x96
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_I2C_REAL_ADDRESS  (0x60>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x60>>1)
+
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+//#define IS_FRONT_OR_REAR        0
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_LOW
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING
+
+
+
+
+#define PID						0x04 /* Product ID Number */
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+
+#define MODULE_DEFAULT_WIDTH 	WIDTH_QVGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_QVGA
+#define MODULE_MAX_WIDTH		WIDTH_VGA
+#define MODULE_MAX_HEIGHT		HEIGHT_VGA
+
+#define AHEAD_LINE_NUM			15    //10DD = 50\A1\E4??-?\A1\A4
+#define DROP_NUM_CAPTURE		4
+#define DROP_NUM_PREVIEW		6
+static unsigned int frame_rate_qvga[]  = {30,};
+static unsigned int frame_rate_vga[]   = {30,};
+
+
+static const struct regval_list module_init_regs[] =
+{
+	#if 0
+	{0x03,0x20},
+	{0x10,0x0c},
+	{0x83,0x01},
+	{0x84,0xe0},
+	{0x85,0x78},
+	{0x03,0x20},
+	{0xb0,0x00},
+	{0x03,0x22},
+	{0x10,0x6a},
+	{0x80,0x48},
+	{0x81,0x20},
+	{0x82,0x3d},
+	{0x83,0x58},
+	{0x84,0x1b},
+	{0x85,0x50},
+	{0x86,0x25},
+	{0x03,0x22},
+	{0x10,0x6a},
+	{0x80,0x40},
+	{0x81,0x20},
+	{0x82,0x4f},
+	{0x83,0x44},
+	{0x84,0x3a},
+	{0x85,0x47},
+	{0x86,0x3a},
+	{0x03,0x10},
+	{0x12,0x10},
+	{0x03,0x20},
+	{0x10,0x1c},
+	{0x88, 0x02}, //EXP Max 8.33 fps 
+	{0x89, 0xbf}, 
+	{0x8a, 0x20}, 
+
+    {0x03, 0x20}, //Page 20
+	{0x10, 0x9c}, 
+	//{0x18, 0x30},
+    {0x03, 0x20}, //Page 20
+	{0xb2, 0x80},
+	{0x03,0x10},
+	{0x11,0x03},
+	{0x12,0x30},
+	{0x13,0x00},
+	{0x44,0x80},
+	{0x45,0x80},
+	{0x47,0x7f},
+	{0x03,0x13},
+	{0x20,0x06},
+	{0x21,0x04},
+	{0x03,0x10},
+	{0x12,0x30},
+	{0x03,0x10},
+	{0x10,0x01},
+	{0x03,0x10},
+	{0x10,0x03},
+	{0x03,0x10},
+	{0x10,0x03},
+	{0x03,0x10},
+	{0x11,0x03},
+	{0x12,0x30},
+	{0x13,0x00},
+	{0x44,0x80},
+	{0x45,0x80},
+	{0x47,0x7f},
+	{0x03,0x13},
+	{0x20,0x06},
+	{0x21,0x04},
+	{0x03,0x10},
+	{0x12,0x30},
+	{0x03, 0x20}, //Page 20
+	{0x10, 0x1c}, 
+	//{0x18, 0x38},
+ 
+	{0x88, 0x02}, //EXP Max 8.33 fps 
+	{0x89, 0xbf}, 
+	{0x8a, 0x20}, 
+
+    {0x03, 0x20}, //Page 20
+	{0x10, 0x9c}, 
+	//{0x18, 0x30},
+    {0x03, 0x20}, //Page 20
+	{0xb2, 0x60},
+	{0x03,0x22},
+	{0x10,0x6a},
+	{0x80,0x48},
+	{0x81,0x20},
+	{0x82,0x3d},
+	{0x83,0x58},
+	{0x84,0x1b},
+	{0x85,0x50},
+	{0x86,0x25},
+	{0x03,0x10},
+	{0x10,0x03},
+	{0x03,0x10},
+	{0x11,0x03},
+	{0x12,0x30},
+	{0x13,0x00},
+	{0x44,0x80},
+	{0x45,0x80},
+	{0x47,0x7f},
+	{0x03,0x13},
+	{0x20,0x06},
+	{0x21,0x04},
+	{0x03,0x22},
+	{0x10,0x6a},
+	{0x80,0x48},
+	{0x81,0x20},
+	{0x82,0x3d},
+	{0x83,0x58},
+	{0x84,0x1b},
+	{0x85,0x50},
+	{0x86,0x25},
+	{0x03,0x10},
+	{0x12,0x30},
+	{0x03, 0x20}, //Page 20
+	{0x10, 0x1c}, 
+	//{0x18, 0x38},
+ 
+	{0x88, 0x02}, //EXP Max 8.33 fps 
+	{0x89, 0xbf}, 
+	{0x8a, 0x20}, 
+
+    {0x03, 0x20}, //Page 20
+	{0x10, 0x9c}, 
+	//{0x18, 0x30},
+    {0x03, 0x20}, //Page 20
+	{0xb2, 0x60},
+	{0x03,0x00},
+	{0x0e, 0x04},//PLL On
+	{0x0e, 0x74},//PLLx2
+#endif
+	//PAGE 0
+	{0x01, 0xf1},
+	{0x01, 0xf3},
+	{0x01, 0xf1},
+	
+	{0x03, 0x00},
+	//{0x11, 0x93},
+	//{0x12, 0x21},
+//	{0x10, 0x93},//Pre off
+	{0x12, 0x00},
+	{0x01, 0xf1},
+	//{0x10, 0x00},
+	{0x20, 0x00},
+	{0x21, 0x04},
+	{0x22, 0x00},
+	{0x23, 0x04},
+	
+	{0x40, 0x01},
+	{0x41, 0x58},
+	{0x42, 0x00},
+	{0x43, 0x64},
+	
+	//BLC
+	{0x80, 0x2e},
+	{0x81, 0x7e},
+	{0x82, 0x90},
+	{0x83, 0x30},
+	{0x84, 0x20},
+	{0x85, 0x0b},
+	{0x89, 0x48},//BLC hold
+	{0x90, 0x0f},
+	{0x91, 0x10},
+	
+	{0x92, 0x48},//AG_IN
+	{0x93, 0x48},//AG_OUT
+	{0x98, 0x20},
+	{0x99, 0x42}, //Out BLC
+	{0xa0, 0x00}, //Dark BLC
+	{0xa8, 0x42}, //Normal BLC
+	
+	//Page 2
+	{0x03, 0x02},
+	{0x20, 0x33},
+	{0x21, 0x77},
+	{0x22, 0xa7},
+	{0x23, 0x30},
+	{0x52, 0xa2},
+	{0x55, 0x18},
+	{0x56, 0x0c},
+	{0x60, 0x11},
+	{0x61, 0x1b},
+	{0x62, 0x11},
+	{0x63, 0x1a},
+	{0x64, 0x11},
+	{0x65, 0x1a},
+	{0x72, 0x12},
+	{0x73, 0x19},
+	{0x74, 0x12},
+	{0x75, 0x19},
+	{0x80, 0x1d},
+	{0x81, 0x6f},
+	{0x82, 0x1e},
+	{0x83, 0x2b},
+	{0x84, 0x1e},
+	{0x85, 0x2b},
+	{0x92, 0x45},
+	{0x93, 0x52},
+	{0x94, 0x45},
+	{0x95, 0x52},
+	{0xa0, 0x1d},
+	{0xa1, 0x6b},
+	{0xa4, 0x6b},
+	{0xa5, 0x1d},
+	{0xa8, 0x2e},
+	{0xa9, 0x42},
+	{0xaa, 0x55},
+	{0xab, 0x69},
+	{0xb8, 0x10},
+	{0xb9, 0x13},
+	{0xbc, 0x1d},
+	{0xbd, 0x1f},
+	{0xc0, 0x04},
+	{0xc1, 0x0d},
+	{0xc4, 0x05},
+	{0xc5, 0x0c},
+	{0xc8, 0x06},
+	{0xc9, 0x0b},
+	{0xcc, 0x06},
+	{0xcd, 0x0a},
+	{0xc2, 0x04},
+	{0xc3, 0x0d},
+	{0xc6, 0x05},
+	{0xc7, 0x0c},
+	{0xca, 0x06},
+	{0xcb, 0x0b},
+	{0xce, 0x06},
+	{0xcf, 0x0a},
+	{0xd0, 0x03},
+	{0xd1, 0x1c},
+	{0xd6, 0x46},
+	{0xd7, 0x48},
+	
+	//Page 10
+	{0x03, 0x10},
+	{0x10, 0x01}, //03, //ISPCTL1, YUV ORDER(FIX)
+	{0x11, 0x43},
+	{0x12, 0x30}, //Y offet, dy offseet enable
+	{0x40, 0x88},
+	{0x41, 0x00}, //00 DYOFS
+	{0x48, 0x88}, //Contrast
+	{0x50, 0x48}, //AGBRT
+		   
+	{0x60, 0x7f},
+	{0x61, 0x00}, //
+	{0x62, 0x94}, //SATB
+	{0x63, 0x9a}, //SATR
+	{0x64, 0x48}, //AGSAT
+	
+	//LPF
+	{0x03, 0x11},
+	{0x10, 0x25},	//LPF_CTL1 //0x01
+	{0x11, 0x07},	//Test Setting
+	{0x20, 0x00},	//LPF_AUTO_CTL
+	{0x21, 0x38},	//LPF_PGA_TH
+	{0x22, 0x00},	//LPF_TIME_TH
+	{0x23, 0x10},	//Test Setting
+	{0x60, 0x10},	//ZARA_SIGMA_TH //40->10
+	{0x61, 0x82},
+	{0x62, 0x00},	//ZARA_HLVL_CTL
+	{0x63, 0x00},	//ZARA_LLVL_CTL
+	{0x64, 0x00},	//ZARA_DY_CTL
+	
+	{0x67, 0xA0},	//Test Setting
+	{0x68, 0x40},	//Test Setting
+	{0x69, 0x10},	//Test Setting
+	
+	//2D
+	{0x03, 0x12},
+	{0x40, 0xeb},	//YC2D_LPF_CTL1
+	{0x41, 0x10},	//YC2D_LPF_CTL2
+	{0x50, 0x18},	//Test Setting
+	{0x51, 0x24},	//Test Setting
+	{0x70, 0x1f},	//GBGR_CTL1 //0x1f
+	{0x71, 0x00},	//Test Setting
+	{0x72, 0x00},	//Test Setting
+	{0x73, 0x00},	//Test Setting
+	{0x74, 0x10},	//GBGR_G_UNIT_TH
+	{0x75, 0x10},	//GBGR_RB_UNIT_TH
+	{0x76, 0x20},	//GBGR_EDGE_TH
+	{0x77, 0x80},	//GBGR_HLVL_TH
+	{0x78, 0x88},	//GBGR_HLVL_COMP
+	{0x79, 0x18},	//Test Setting
+	{0xb0, 0x7d},	//dpc
+	
+	//Edge
+	{0x03, 0x13},
+	{0x10, 0x01},	
+	{0x11, 0x89},	
+	{0x12, 0x14},	
+	{0x13, 0x19},	
+	{0x14,0x08},	//Test Setting
+	{0x20, 0x04},	//SHARP_SLOPE
+	{0x21, 0x02},	//SHARP_SLOPE_TH
+	{0x23,0x30},	//SHARP_DY_CTL
+	{0x24,0x33},	//40->33
+	{0x25,0x08},	//SHARP_PGA_TH
+	{0x26,0x18},	//Test Setting
+	{0x27,0x00},	//Test Setting
+	{0x28,0x08},	//Test Setting
+	{0x29,0x50},	//AG_TH
+	{0x2a,0xe0},	//region ratio
+	{0x2b,0x10},	//Test Setting
+	{0x2c,0x28},	//Test Setting
+	{0x2d,0x40},	//Test Setting
+	{0x2e,0x00},	//Test Setting
+	{0x2f,0x00},	//Test Setting
+	{0x30,0x11},	//Test Setting
+	{0x80,0x03},	//SHARP2D_CTL
+	{0x81,0x07},	//Test Setting
+	{0x90, 0x04},	//SHARP2D_SLOPE
+	{0x91, 0x02},	//SHARP2D_DIFF_CTL
+	{0x92,0x00},	//SHARP2D_HI_CLIP
+	{0x93,0x20},	//SHARP2D_DY_CTL
+	{0x94,0x42},	//Test Setting
+	{0x95,0x60},	//Test Setting
+	     
+	//Shading
+	{0x03, 0x14},
+	{0x10, 0x01},
+	{0x20, 0x93}, //XCEN
+	{0x21, 0x80}, //YCEN
+	{0x22, 0x76}, //76, 34, 2b
+	{0x23,0x50}, //4b, 15, 0d
+	{0x24,0x44}, //3b, 10, 0b
+       
+	/////Page,CMC
+	{0x03,0x15}, 
+	{0x10,0x03},
+       
+	{0x14,0x3c},
+	{0x16,0x2c},
+	{0x17,0x2f},
+       
+	{0x30,0xcb},
+	{0x31,0x61},
+	{0x32,0x16},
+	{0x33,0x23},
+	{0x34,0xce},
+	{0x35,0x2b},
+	{0x36,0x01},
+	{0x37,0x34},
+	{0x38,0x75},
+       
+	{0x40,0x87},
+	{0x41,0x18},
+	{0x42,0x91},
+	{0x43,0x94},
+	{0x44,0x9f},
+	{0x45,0x33},
+	{0x46,0x00},
+	{0x47,0x94},
+	{0x48,0x14},
+       
+	{0x03,0x16}, 
+	{0x30,0x00},
+	{0x31,0x0a},
+	{0x32,0x1b},
+	{0x33,0x2e},
+	{0x34,0x5c},
+	{0x35,0x79},
+	{0x36,0x95},
+	{0x37,0xa4},
+	{0x38,0xb1},
+	{0x39,0xbd},
+	{0x3a,0xc8},
+	{0x3b,0xd9},
+	{0x3c,0xe8},
+	{0x3d,0xf5},
+	{0x3e,0xff},
+       
+	///Page,AE 
+	{0x03,0x17},
+	{0xc4,0x3c},
+	{0xc5,0x32},
+       
+	////Page,AE 
+	{0x03,0x20},
+	{0x10,0x0c},
+	{0x11,0x04},
+       
+	{0x20,0x01},
+	{0x28,0x27},
+	{0x29,0xa1},
+       
+	{0x2a,0xf0},
+	{0x2b,0x34},
+		   
+	{0x30,0xf8},
+       
+	{0x39,0x22},
+	{0x3a,0xde},
+	{0x3b,0x22}, //23->22 _10_04_06 hhzin
+	{0x3c,0xde},
+       
+	{0x60,0x95}, //d5, 99
+	{0x68,0x3c},
+	{0x69,0x64},
+	{0x6A,0x28},
+	{0x6B,0xc8},
+       
+	{0x70,0x42},//Y Target 42       
+	{0x76, 0x22}, //Unlock bnd1
+	{0x77, 0x02}, //Unlock bnd2
+	
+	{0x78, 0x12}, //Yth 1
+	{0x79, 0x26}, //Yth 2
+	{0x7a,0x23}, //Yth 3
+       
+	{0x7c, 0x1c},
+	{0x7d,0x22}, 
+	     
+	////50Hz,
+	{0x83, 0x00},//ExpTime 30fps
+	{0x84, 0xaf}, 
+	{0x85, 0xc8}, 
+	{0x86, 0x00}, //EXPMin 6000.00 fps
+	{0x87, 0xfa},
+
+	
+	{0x88, 0x02}, //EXP Max 8.33 fps 
+	{0x89, 0xbf}, 
+	{0x8a, 0x20}, 
+	{0x8B, 0x3a}, //EXP100 
+	{0x8C, 0x98}, 
+	{0x8D, 0x30}, //EXP120 
+	{0x8E, 0xd4}, 
+	{0x9c, 0x0b}, //EXP Limit 500.00 fps 
+	{0x9d, 0xb8}, 
+	{0x9e, 0x00}, //EXP Unit 
+	{0x9f, 0xfa},	
+       
+	{0xb1,0x14},
+	{0xb2,0x60},
+	{0xb4,0x14},
+	{0xb5,0x38},
+	{0xb6,0x26},
+	{0xb7,0x20},
+	{0xb8,0x1d},
+	{0xb9,0x1b},
+	{0xba,0x1a},
+	{0xbb,0x19},
+	{0xbc,0x19},
+	{0xbd,0x18},
+       
+	{0xc0, 0x16},	//0x1a->0x16
+	{0xc3,0x48},
+	{0xc4,0x48},
+       
+	////Page,AWB
+	{0x03,0x22},
+	{0x10, 0xfb},
+	{0x11,0x26},
+	{0x30,0x80},
+	{0x31,0x80},
+	{0x38,0x12},
+	{0x39,0x33},
+	{0x3a, 0x88},
+	{0x3b, 0xc4},
+	{0x40,0xf0},
+	{0x41, 0x33},
+	{0x42,0x33},
+	{0x43,0xf3},
+	{0x44, 0x55},
+	{0x45, 0x44},
+	{0x46,0x02},
+	{0x60, 0x00},
+	{0x61, 0x00},
+	{0x80, 0x39},
+	{0x81,0x20},
+	{0x82, 0x50},
+	{0x83,0x52}, //RMAX Default : 50 -> 48 -> 52 
+	{0x84,0x18}, //RMIN Default : 20
+	{0x85, 0x4b},
+	{0x86,0x25}, //BMIN Default : 20
+	{0x87,0x4d}, //RMAXB Default : 50, 4d
+	{0x88,0x38}, //RMINB Default : 3e, 45 --> 42
+	{0x89,0x3e}, //BMAXB Default : 2e, 2d --> 30
+	{0x8a,0x29}, //BMINB Default : 20, 22 --> 26 --> 29
+	{0x8b,0x02}, //OUT TH
+	{0x8d,0x22},
+	{0x8e,0x71},
+	{0x8f, 0x63},
+	{0x90, 0x60},
+	{0x91, 0x5c},
+	{0x92, 0x56},
+	{0x93, 0x52},
+	{0x94, 0x4c},
+	{0x95, 0x36},
+	{0x96, 0x31},
+	{0x97, 0x2e},
+	{0x98, 0x2a},
+	{0x99, 0x29},
+	{0x9a, 0x26},
+	{0x9b, 0x09},
+	{0xb0, 0x30},
+	{0xb1, 0x48},		
+	{0x03,0x22},
+	{0x10,0xfb},
+       
+	{0x03,0x20},
+	{0x10,0x9c},
+	
+	{0x01, 0xf0},
+    ENDMARKER,
+};
+
+
+
+
+/* 640*480: VGA */
+static const struct regval_list module_vga_regs[] = 
+{
+
+	{0x03,0x00},	//PAGEMODE(0x03)
+	//{0x01,0xf1},//Sleep: For Write Reg
+	     
+	{0x10,0x00},//VGA Size
+	     
+	{0x20,0x00},
+	{0x21,0x04},
+	     
+	{0x40,0x01},//HBLANK: 0x70 = 112
+	{0x41,0x58},
+	{0x42,0x00},//VBLANK: 0x04 = 4
+	{0x43,0x64},
+	     
+	{0x03,0x11},
+	{0x10,0x25},
+	     
+	{0x03,0x20},
+	//{0x10,0x1c},//Close AE
+	//{0x18,0x38},//Reset AE
+	     
+	{0x86,0x00},
+	{0x87,0xfa}, 
+	
+	{0x8B,0x3a}, //EXP100 
+	{0x8C,0x98}, 
+	{0x8D,0x30}, //EXP120 
+	{0x8E,0xd4}, 
+	{0x9c,0x0b}, //EXP Limit 500.00 fps 
+	{0x9d,0xb8}, 
+	{0x9e,0x00}, //EXP Unit 
+	{0x9f,0xfa},	
+	     
+	//{0x01,0xf0},//Exit Sleep: For Write Reg//brian 20120308 f0 
+	     
+	//{0x03,0x20},
+	//{0x10,0x9c},//Open AE
+	//{0x18,0x30},//Reset AE
+	
+    ENDMARKER,
+};
+
+/* 320*240: QVGA */
+static const struct regval_list module_qvga_regs[] = 
+{
+	
+	{0x03,0x00},	//PAGEMODE(0x03)
+	//{0x01,0xf1},//Sleep: For Write Reg
+	     
+	{0x10,0x10},//QVGA Size
+	     
+	{0x20,0x00},
+	{0x21,0x02},
+	     
+	{0x40,0x01},//HBLANK: 0x70 = 112
+	{0x41,0x58},
+	{0x42,0x00},//VBLANK: 0x04 = 4
+	{0x43,0x64},
+	     
+	{0x03,0x11},//QVGA Fixframerate
+	{0x10,0x21},
+	     
+	{0x03,0x20},
+	//{0x10,0x1c},//Close AE
+	//{0x18,0x38},//Reset AE
+	     
+	{0x86,0x00},
+	{0x87,0xfa},
+	
+	{0x8B,0x3a}, //EXP100 
+	{0x8C,0x98}, 
+	{0x8D,0x30}, //EXP120 
+	{0x8E,0xd4}, 
+	{0x9c,0x0b}, //EXP Limit 500.00 fps 
+	{0x9d,0xb8}, 
+	{0x9e,0x00}, //EXP Unit 
+	{0x9f,0xfa},	
+	     
+	//{0x01,0xf0},//Exit Sleep: For Write Reg brian 20120308 f0 
+	     
+	//{0x03,0x20},
+	//{0x10,0x9c},//Open AE
+	//{0x18,0x30},//Reset AE
+	   ENDMARKER,
+};
+
+/*
+ * window size list
+ */
+
+/* 320*240 */
+static struct camera_module_win_size module_win_qvga = {
+	.name             = "QVGA",
+	.width            = WIDTH_QVGA,
+	.height           = HEIGHT_QVGA,
+	.win_regs         = module_qvga_regs,
+
+	.frame_rate_array = frame_rate_qvga,
+	.capture_only     = 0,
+};
+
+/* 640*480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+
+	&module_win_vga,
+	&module_win_qvga, 
+
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+	{0x03,0x22},
+	{0x10,0xea},  //AWB enable
+	{0x80,0x48},
+	{0x81,0x20},
+	{0x82,0x3d},
+	{0x83,0x58},
+	{0x84,0x1b},
+	{0x85,0x50},
+	{0x86,0x25},
+
+	{0x03,0x10},
+	{0x11,0x03},
+	{0x12,0x30},
+	{0x13,0x00},
+	{0x44,0x80},
+	{0x45,0x80},
+	{0x47,0x7f},
+	{0x03,0x13},
+	{0x20,0x06},
+	{0x21,0x04},
+	ENDMARKER,
+};
+
+static struct regval_list module_scene_night_regs[] =
+{	
+   	{0x03, 0x20}, //Page 20
+	{0x10, 0x1c}, 
+	//{0x18, 0x38},
+ 
+	{0x88, 0x02}, //EXP Max 8.33 fps 
+	{0x89, 0xbf}, 
+	{0x8a, 0x20}, 
+
+    {0x03, 0x20}, //Page 20
+	{0x10, 0x9c}, 
+	//{0x18, 0x30},
+    {0x03, 0x20}, //Page 20
+	{0xb2, 0x80},
+	ENDMARKER,
+};
+
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	{0x03,0x22},
+	{0x10,0x6a},
+	{0x80,0x62},
+	{0x81,0x20},
+	{0x82,0x2e},
+	{0x83,0x6d},
+	{0x84,0x65},
+	{0x85,0x30},
+	{0x86,0x25},
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+	{0x03,0x22},
+	{0x10,0x6a},
+	{0x80,0x50},
+	{0x81,0x20},
+	{0x82,0x2d},
+	{0x83,0x52},
+	{0x84,0x45},
+	{0x85,0x30},
+	{0x86,0x1c},
+    ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+	{0x03,0x22},
+	{0x10,0x6a},
+	{0x80,0x40},
+	{0x81,0x20},
+	{0x82,0x4f},
+	{0x83,0x44},
+	{0x84,0x3a},
+	{0x85,0x47},
+	{0x86,0x3a},
+    ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	{0x03,0x22},
+	{0x10,0x6a},
+	{0x80,0x26},
+	{0x81,0x20},
+	{0x82,0x55},
+	{0x83,0x24},
+	{0x84,0x1e},
+	{0x85,0x58},
+	{0x86,0x4a},
+	ENDMARKER,
+};
+
+
+static struct regval_list module_scene_auto_regs[] =
+{
+	{0x03, 0x20}, //Page 20
+	{0x10, 0x1c}, 
+	//{0x18, 0x38},
+ 
+	{0x88, 0x02}, //EXP Max 8.33 fps 
+	{0x89, 0xbf}, 
+	{0x8a, 0x20}, 
+
+    {0x03, 0x20}, //Page 20
+	{0x10, 0x9c}, 
+	//{0x18, 0x30},
+    {0x03, 0x20}, //Page 20
+	{0xb2, 0x60},
+	ENDMARKER,
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list module_exp_comp_neg4_regs[] = {
+	{0x03,0x20},
+	{0x70,0x12},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg3_regs[] = {
+	{0x03,0x20},
+	{0x70,0x2a},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg2_regs[] = {
+	{0x03,0x20},
+	{0x70,0x32},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg1_regs[] = {
+	{0x03,0x20},
+	{0x70,0x3a},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_zero_regs[] = {
+	{0x03,0x20},
+	{0x70,0x42},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos1_regs[] = {
+	{0x03,0x20},
+	{0x70,0x4a},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos2_regs[] = {
+	{0x03,0x20},
+	{0x70,0x52},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos3_regs[] = {
+	{0x03,0x20},
+	{0x70,0x5a},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos4_regs[] = {
+	{0x03,0x20},
+	{0x70,0x62},
+	ENDMARKER,
+};
+
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{   .id = V4L2_CID_EXPOSURE, 
+		.min = 0, 
+		.max = 975,
+		.step = 1, 
+		.def = 500,
+	},
+	{	.id = V4L2_CID_EXPOSURE_COMP, 
+		.min = -4, 
+		.max = 4, 
+		.step = 1, 
+		.def = 0,
+	},	
+	{	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,
+	},
+	{
+        .id = V4L2_CID_AUTO_WHITE_BALANCE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 1,
+    },
+    {
+        .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+        .min = 0,
+        .max = 3,
+        .step = 1,
+        .def = 1,
+    },
+   /* {	.id = V4L2_CID_SCENE_EXPOSURE, 
+		.min = 0, 
+		.max = 1, 
+		.step = 1, 
+		.def = 0,},*/
+
+    {
+        .id = V4L2_CID_HFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_VFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+     {	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+     {	.id = V4L2_CID_AF_MODE,
+		.min = NONE_AF, 
+		.max = CONTINUE_AF|SINGLE_AF, 
+		.step = 1, 
+		.def = NONE_AF,},
+    {	.id = V4L2_CID_AF_STATUS, 
+		.min = AF_STATUS_DISABLE, 
+		.max = AF_STATUS_FAIL, 
+		.step = 1, 
+		.def = AF_STATUS_DISABLE,},
+	{	.id = V4L2_CID_MIRRORFLIP, //3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	 {
+        .id = V4L2_CID_COLORFX,
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_EXPOSURE_AUTO,
+        .max = 1,
+        .mask = 0x0,
+        .def = 1,
+    },
+	{  
+		   .id = V4L2_CID_SCENE_MODE, 
+		   .max = V4L2_SCENE_MODE_TEXT, 
+		   .mask = 0x0, 
+		   .def = 0,
+		},
+
+    {	.id = V4L2_CID_FLASH_LED_MODE, 
+		.max = 3,
+		.mask = 0x0,
+		.def = 0,},
+   {
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/module_comm/camera_chip_ident.h b/drivers/media/i2c/camera/module_comm/camera_chip_ident.h
new file mode 100755
index 0000000..2a120d7
--- /dev/null
+++ b/drivers/media/i2c/camera/module_comm/camera_chip_ident.h
@@ -0,0 +1,33 @@
+#ifndef __ACT_CAMERA_CHIP_IDENT_H__
+#define __ACT_CAMERA_CHIP_IDENT_H__
+
+#define ACT_CAMERA_CHIP_IDENT_START 65000
+
+enum {
+	V4L2_IDENT_GC0311 = ACT_CAMERA_CHIP_IDENT_START,
+    V4L2_IDENT_GC2145,
+    V4L2_IDENT_SIV120D,
+    V4L2_IDENT_SIV121D,
+    V4L2_IDENT_SP0A19,
+    V4L2_IDENT_SIV121DU,
+    V4L2_IDENT_SIV130B,
+    V4L2_IDENT_GC2015,
+    V4L2_IDENT_GC0310,
+    V4L2_IDENT_BF3703,
+    V4L2_IDENT_BF3920,
+    V4L2_IDENT_BF3A03,
+    V4L2_IDENT_SOC5140,
+    V4L2_IDENT_HI257,
+    V4L2_IDENT_HI708,
+    V4L2_IDENT_GC2035,
+    V4L2_IDENT_GC0308,
+    V4L2_IDENT_SP0718,
+    V4L2_IDENT_OV2686,
+   
+    //insert more ident in here
+    
+    V4L2_IDENT_ACT_MAX,  
+};
+
+
+#endif
diff --git a/drivers/media/i2c/camera/module_comm/module_comm.c b/drivers/media/i2c/camera/module_comm/module_comm.c
new file mode 100755
index 0000000..0e32ecf
--- /dev/null
+++ b/drivers/media/i2c/camera/module_comm/module_comm.c
@@ -0,0 +1,1128 @@
+/*
+ * Camera module common Driver
+ *
+ * Copyright (C) 2011 Actions Semiconductor Co.,LTD
+ * Wang Xin <wangxin@actions-semi.com>
+ *
+ * Based on gc2035 driver
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-subdev.h>
+#include <media/soc_camera.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <mach/isp-owl.h>
+#include "../flashlight/flashlight.h"
+
+static int flash_flag = 0;
+#define GPIO_NAME_FLASHLIGHT    "flashlight_gpio"
+static int  rear  = 1;
+static int dual = 0;
+static bool gpio_flash_cfg_exist      = false;
+
+
+static bool init_regs_writed   = false;
+
+
+static struct camera_module_priv *to_camera_priv(const struct i2c_client *client)
+{
+    return container_of(i2c_get_clientdata(client), struct camera_module_priv, subdev);
+}
+
+
+static struct camera_module_win_size *camera_module_select_win(u32 width, u32 height)
+{
+    
+    __u32 diff;
+    struct camera_module_win_size *win = NULL;
+    int win_num = 0;
+    int i = 0;
+    int j = 0;
+
+	
+	GC_INFO("width:%d, height:%d", width, height);
+
+	
+    win_num = ARRAY_SIZE(module_win_list);
+    if (win_num == 1) {
+        win = module_win_list[0];
+        j = 0;
+    } else {
+        diff = abs(width - module_win_list[0]->width) + abs(height - module_win_list[0]->height);
+        win = module_win_list[0];
+        j = 0;
+        for (i=1; i<win_num; i++) {
+            if (diff > abs(width  - module_win_list[i]->width) + abs(height - module_win_list[i]->height)) {
+                win = module_win_list[i];
+                j = i;
+                diff = abs(width  - module_win_list[i]->width) + abs(height - module_win_list[i]->height);
+            }
+        }
+    }
+
+    return win;
+}
+
+
+static int camera_module_get_params(struct i2c_client *client, u32 *width, u32 *height, enum v4l2_mbus_pixelcode code)
+{
+	 
+    struct camera_module_priv *priv = to_camera_priv(client);
+    int ret = 0;
+    int i = 0;
+
+	GC_INFO("");
+    /*
+     * select format
+     */
+    priv->cfmt = NULL;
+    for (i = 0; i < ARRAY_SIZE(module_cfmts); i++) {
+        if (code == module_cfmts[i].code) {
+            priv->cfmt = module_cfmts + i;
+            break;
+        }
+    }
+
+    if (!priv->cfmt) {
+        printk("[camera] Unsupported sensor format.\n");
+        goto module_get_fmt_error;
+    }
+	 priv->win = camera_module_select_win(*width, *height);
+	*width = priv->win->width;
+    *height = priv->win->height;
+	GC_INFO("current params: %s %dX%d\n", priv->win->name, *width, *height);
+	return ret;
+module_get_fmt_error:
+module_soft_reset(client);
+priv->win = NULL;
+priv->cfmt = NULL;
+return ret;
+
+}
+
+static int camera_module_set_params(struct i2c_client *client, u32 *width, u32 *height, enum v4l2_mbus_pixelcode code)
+{
+
+    struct camera_module_priv *priv= to_camera_priv(client);
+    int ret = 0;
+    int i = 0;
+
+	GC_INFO("");
+
+    /*
+     * select format
+     */
+    priv->cfmt = NULL;
+    for (i = 0; i < ARRAY_SIZE(module_cfmts); i++) {
+        if (code == module_cfmts[i].code) {
+            priv->cfmt = module_cfmts + i;
+            break;
+        }
+    }
+
+    if (!priv->cfmt) {
+        printk("[camera] Unsupported sensor format.\n");
+        goto module_set_fmt_error;
+    }
+
+    /*
+     * select win
+     */
+    
+     
+    priv->win = camera_module_select_win(*width, *height);
+	//mdelay(20);
+	
+   // GC_INFO("the window name is %s,size is %d",priv->win->name,priv->win->win_regs_size);
+	camera_write_array(client->adapter, priv->win->win_regs);
+
+    ret = module_set_mbusformat(client, priv->cfmt);
+
+    if (ret < 0) {
+        printk("[camera] module set mbus format error.\n");
+        goto module_set_fmt_error;
+    }
+
+    *width = priv->win->width;
+    *height = priv->win->height;
+
+    return ret;
+
+module_set_fmt_error:
+    module_soft_reset(client);
+    priv->win = NULL;
+    priv->cfmt = NULL;
+
+    return ret;
+}
+
+
+static int camera_module_set_flash_led_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //DEBUG_PRINT("");    
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+    int mode = ctrl->val;
+
+    switch(mode) {
+        case V4L2_FLASH_LED_MODE_NONE:
+            priv->flash_led_mode = mode;
+            flashlight_control(FLASHLIGHT_OFF);
+            break;
+        
+        case V4L2_FLASH_LED_MODE_TORCH:
+            priv->flash_led_mode = mode;
+            flashlight_control(FLASHLIGHT_TORCH);
+            break;
+        
+        case V4L2_FLASH_LED_MODE_FLASH:
+            priv->flash_led_mode = mode;
+            break;
+
+        case V4L2_FLASH_LED_MODE_AUTO:
+            priv->flash_led_mode = mode;
+            break;
+
+        default :
+            return -ERANGE;
+    }
+ 
+    ctrl->cur.val = mode;
+
+    return 0;
+}
+/*
+ * v4l2_subdev_core_ops function
+ */
+static int camera_module_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
+{
+    
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+	GC_INFO("");
+    id->ident    = priv->model;
+    id->revision = 0;
+
+    return 0;
+}
+
+/*
+ * v4l2_ctrl_ops function
+ */
+static int camera_module_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+   
+    struct camera_module_priv *priv = container_of(ctrl->handler, struct camera_module_priv , hdl);
+    struct v4l2_subdev *sd = &priv->subdev;
+    int ret = 0;
+
+	if (NULL == priv->win) {
+        GC_INFO("skip such ctrl -s %s\n", v4l2_ctrl_get_name(ctrl->id));
+        return (0);     // hasn't chose win, no need process anymore
+    }
+    GC_INFO("s_ctrl- %s\n", v4l2_ctrl_get_name(ctrl->id));
+    switch (ctrl->id) {
+    case V4L2_CID_GAIN:
+        module_set_gain(sd, ctrl);
+        break;
+    case V4L2_CID_AUTO_WHITE_BALANCE:
+        module_set_auto_white_balance(sd, ctrl);
+        break;
+ 
+    case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+        module_set_white_balance_temperature(sd, ctrl);
+        break;
+    case V4L2_CID_FLASH_LED_MODE:
+        if(flash_flag)
+        	{
+        		camera_module_set_flash_led_mode(sd, ctrl);
+        	}		
+        break;
+    case V4L2_CID_FLASH_STROBE:
+         if(flash_flag)
+        	{
+        		flashlight_control(FLASHLIGHT_FLASH);
+        	}
+        break;
+
+    case V4L2_CID_FLASH_STROBE_STOP:
+	   if(flash_flag)
+        	{
+        		flashlight_control(FLASHLIGHT_OFF);
+        	}
+        break;
+	case V4L2_CID_HFLIP:
+		 if(ctrl->val ==1)    	  
+						priv->info->flags |=MODULE_FLAG_HFLIP;
+				else
+						priv->info->flags &= (~MODULE_FLAG_HFLIP);	
+				module_s_mirror_flip(sd, (priv->info->flags) & MODULE_FLAG_HFLIP, (priv->info->flags) & MODULE_FLAG_VFLIP);
+		break;
+    case V4L2_CID_VFLIP:
+       if(ctrl->val ==1)     	
+    				priv->info->flags |= MODULE_FLAG_VFLIP;
+				else
+						priv->info->flags &= (~MODULE_FLAG_VFLIP);    
+				module_s_mirror_flip(sd, (priv->info->flags) & MODULE_FLAG_HFLIP, (priv->info->flags) & MODULE_FLAG_VFLIP);
+        break;
+	//hal\B2\E3\B3\F5ʼ\BB\AFʱ\A3\AC\BB\E1дHFlip\BA\CDVflip\A3\BBʹ\D3ô˿\D8\D6\C6\D7\D6ͬʱд\A3\BB\B1\DC\C3\E2\CFȺ\F3\C1\AC\D0\F8\B2\D9\D7\F7\C1\BD\B4μĴ\E6\C6\F7\A3\AC\B6\F8\B5\BC\D6\C2ģ\D7\E9\CA\E4\B3\F6\B5\C4\CA\FD\BE\DD\D3\D0\CE\CA\CC⣻
+	case V4L2_CID_MIRRORFLIP:
+	  if((ctrl->val & HFLIP) >0)     	
+				priv->info->flags |= MODULE_FLAG_HFLIP;
+			else
+					priv->info->flags &= (~MODULE_FLAG_HFLIP);
+	  if((ctrl->val & VFLIP) >0)     	
+				priv->info->flags |= MODULE_FLAG_VFLIP;
+			else
+					priv->info->flags &= (~MODULE_FLAG_VFLIP);		 
+			module_s_mirror_flip(sd, (priv->info->flags) & MODULE_FLAG_HFLIP, (priv->info->flags) & MODULE_FLAG_VFLIP);
+			break;
+		
+	case V4L2_CID_EXPOSURE_AUTO:
+		module_set_exposure_auto(sd, ctrl);
+		break;
+	 case V4L2_CID_SCENE_MODE:
+        module_set_scene_exposure(sd, ctrl);
+        break;
+		
+	case V4L2_CID_AF_MODE:
+		module_set_af_mode(sd, ctrl);
+		break;
+		
+	case V4L2_CID_AF_STATUS:
+		break;	//\C9ϲ㲻Ӧ\B8õ\F7\D3ô\CB\C3\FC\C1\EE\D7֡\A3
+	
+	case V4L2_CID_COLORFX:
+			break;
+
+    case V4L2_CID_EXPOSURE_COMP:
+        module_set_ev(sd,ctrl);
+        break;
+       
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		module_set_power_line(sd,ctrl);
+		break;
+    default:
+        return -EINVAL;
+    }
+
+    return ret;
+}
+
+static int camera_module_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	 struct camera_module_priv *priv = container_of(ctrl->handler, struct camera_module_priv , hdl);
+    struct v4l2_subdev *sd = &priv->subdev;
+
+    int ret = 0;
+
+    switch (ctrl->id) {	
+	case V4L2_CID_AF_STATUS:				   
+		ret = module_get_af_status(priv, ctrl);
+		break;								   
+    case V4L2_CID_GAIN:
+        ret = module_get_gain(sd, ctrl);
+        break;
+
+    case V4L2_CID_EXPOSURE:
+        ret = module_get_exposure(sd,ctrl);
+        break;
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+    ret = module_get_power_line(sd,ctrl);
+    break;
+
+    default:
+        return -EINVAL;
+    }
+    return 0;
+}
+/*
+ * v4l2_subdev_video_ops function
+ */
+static int camera_module_s_stream(struct v4l2_subdev *sd, int enable)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+    int ret = 0;
+	ret = module_set_stream(client,enable);
+   if(ACTS_ISP_PREVIEW_MODE == priv->pcv_mode)
+   	{
+   		GC_INFO("");
+			ret |= module_save_exposure_param(sd);
+		GC_INFO("");
+		
+   	}
+   else if(ACTS_ISP_CAPTURE_MODE == priv->pcv_mode)
+   	{
+   		GC_INFO("");
+   		 ret |= module_freeze_aec(sd);
+		 ret |= module_set_exposure_param(sd);
+		 ret |= module_start_aec(sd);
+		 msleep(5);
+		 GC_INFO("");
+   	}
+	   printk("format %d, win %s", priv->cfmt->code, priv->win->name);
+	return ret;
+
+}
+
+static int camera_module_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)
+{
+    GC_INFO("");
+    a->bounds.left              = 0;
+    a->bounds.top               = 0;
+    a->bounds.width             = MODULE_MAX_WIDTH;
+    a->bounds.height            = MODULE_MAX_HEIGHT;
+    a->defrect                  = a->bounds;
+    a->type                     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    a->pixelaspect.numerator    = 1;
+    a->pixelaspect.denominator  = 30;
+
+    return 0;
+}
+
+static int camera_module_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *vc)
+{
+    GC_INFO("");
+
+    vc->c.left = 0;
+    vc->c.top = 0;
+    vc->c.width = MODULE_MAX_WIDTH;
+    vc->c.height = MODULE_MAX_HEIGHT;
+    vc->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+    return 0;
+}
+
+static int camera_module_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+    GC_INFO("");
+    return 0;
+}
+
+static int camera_module_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+    GC_INFO("");
+    return 0;
+}
+
+static int camera_module_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+    GC_INFO("index:%d", fsize->index);
+//    struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+    if (fsize->index >= ARRAY_SIZE(module_win_list)) {
+        return -EINVAL;
+    }
+
+    switch (fsize->pixel_format) {
+    case V4L2_PIX_FMT_YUV420:
+    case V4L2_PIX_FMT_YUV422P:
+    case V4L2_PIX_FMT_NV12:
+    case V4L2_PIX_FMT_YUYV:
+        fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+        fsize->discrete.width = module_win_list[fsize->index]->width;
+        fsize->discrete.height = module_win_list[fsize->index]->height;
+		fsize->reserved[0]     = module_win_list[fsize->index]->capture_only;
+        break;
+
+    default:
+        printk("[camera] pixel_format(%d) is Unsupported\n", fsize->pixel_format);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int camera_module_enum_frameintervals(struct v4l2_subdev *sd, struct v4l2_frmivalenum *fival)
+{
+   
+    const struct camera_module_win_size *win_size = camera_module_select_win(fival->width, fival->height);
+    unsigned int array_size = sizeof(win_size->frame_rate_array)/sizeof(unsigned int);
+	GC_INFO("");
+    if (fival->index >= array_size) {
+        return -EINVAL;
+    }
+
+    if ((win_size->width != fival->width) || (win_size->height != fival->height)) {
+        printk("[camera] width(%d) height(%d) is over range.\n", fival->width, fival->height);
+        return -EINVAL;
+    }
+
+    fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+    fival->discrete.numerator = 1;
+    fival->discrete.denominator = (win_size->frame_rate_array)[fival->index];
+
+    return 0;
+}
+
+static int camera_module_enum_fmt(struct v4l2_subdev *sd, unsigned int index, enum v4l2_mbus_pixelcode *code)
+{
+    GC_INFO("");
+    if (index >= ARRAY_SIZE(module_cfmts)) {
+        return -EINVAL;
+    }
+
+    *code = module_cfmts[index].code;
+    return 0;
+}
+
+static int camera_module_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+    int ret = 0;
+    GC_INFO("");
+    if (!priv->win || !priv->cfmt) {
+        u32 width = MODULE_DEFAULT_WIDTH;
+        u32 height = MODULE_DEFAULT_HEIGHT;
+
+        ret = camera_module_get_params(client, &width, &height, V4L2_MBUS_FMT_UYVY8_2X8);
+        if (ret < 0) {
+            return ret;
+        }
+    }
+
+    mf->width       = priv->win->width;
+    mf->height      = priv->win->height;
+    mf->code        = priv->cfmt->code;
+    mf->colorspace  = priv->cfmt->colorspace;
+    mf->field       = V4L2_FIELD_NONE;
+    return ret;
+}
+
+static int camera_module_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+    const struct camera_module_win_size *win;
+    int i = 0;
+	GC_INFO("");
+    // select suitable win
+    win = camera_module_select_win(mf->width, mf->height);
+
+    mf->width   = win->width;
+    mf->height  = win->height;
+    mf->field   = V4L2_FIELD_NONE;
+
+    for (i = 0; i < ARRAY_SIZE(module_cfmts); i++) {
+        if (mf->code == module_cfmts[i].code) {
+            break;
+        }
+    }
+
+    if (i == ARRAY_SIZE(module_cfmts)) {
+        /* Unsupported format requested. Propose either */
+        if (priv->cfmt) {
+            /* the current one or */
+            mf->colorspace = priv->cfmt->colorspace;
+            mf->code = priv->cfmt->code;
+        } else {
+            /* the default one */
+            mf->colorspace = module_cfmts[0].colorspace;
+            mf->code = module_cfmts[0].code;
+        }
+    } else {
+        /* Also return the colorspace */
+        mf->colorspace    = module_cfmts[i].colorspace;
+    }
+
+    return 0;
+}
+
+static int camera_module_s_fmt(struct v4l2_subdev *sd,    struct v4l2_mbus_framefmt *mf)
+{
+   
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+    int ret = 0;
+	GC_INFO("");
+    ret = camera_module_set_params(client, &mf->width, &mf->height, mf->code);
+    if (!ret) {
+        mf->colorspace = priv->cfmt->colorspace;
+    }
+  
+    return ret;
+}
+
+static int camera_module_g_mbus_config(struct v4l2_subdev *sd, struct v4l2_mbus_config *cfg)
+{
+ 
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_subdev_desc *desc = soc_camera_i2c_to_desc(client);
+
+    GC_INFO("");
+    cfg->flags =  DEFAULT_PCLK_SAMPLE_EDGE | V4L2_MBUS_MASTER |
+        V4L2_MBUS_HSYNC_ACTIVE_HIGH | DEFAULT_VSYNC_ACTIVE_LEVEL |
+        V4L2_MBUS_DATA_ACTIVE_HIGH;
+
+    cfg->type = V4L2_MBUS_PARALLEL;
+
+    cfg->flags = soc_camera_apply_board_flags(desc, cfg);
+    return (0);
+}
+
+static int camera_module_s_mbus_config(struct v4l2_subdev *sd, const struct v4l2_mbus_config *cfg)
+{
+    return 0;
+}
+
+static long camera_module_ioctrl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+
+    GC_INFO("cmd:%d", cmd);
+    switch (cmd) {
+    case V4L2_CID_CAM_CV_MODE: {
+            int mode = *(int *) arg;
+
+            if (mode < ACTS_ISP_PREVIEW_MODE || mode > ACTS_ISP_VIDEO_MODE) {
+                return (-EINVAL);
+            }
+            priv->pcv_mode = mode;
+            break;
+        }
+    default:
+        GC_ERR("Don't support current cmd:0x%x", cmd);
+        return (-EINVAL);
+    }
+
+    switch (priv->pcv_mode) {
+    case ACTS_ISP_PREVIEW_MODE:
+        GC_INFO("Preview");
+        break;
+    case ACTS_ISP_CAPTURE_MODE:
+        GC_INFO("Capture");
+        break;
+    case ACTS_ISP_VIDEO_MODE:
+        GC_INFO("Video");
+        break;
+    default:
+        GC_ERR("out of range");
+        break;
+    }
+
+    return 0;
+}
+
+static int camera_module_s_power(struct v4l2_subdev *sd, int on)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_subdev_desc *desc = soc_camera_i2c_to_desc(client);
+    int ret = 0;
+
+    GC_INFO("%s", on ? "on" : "off");
+
+    if (!on) {
+        return soc_camera_power_off(&client->dev, desc);
+    }
+
+    ret = soc_camera_power_on(&client->dev, desc);
+    if (ret < 0)
+        return ret;
+	mdelay(10);
+	module_soft_reset(client);
+	if(!init_regs_writed)
+		{
+		
+    	ret = camera_write_array(client->adapter, module_init_regs);
+		}
+	init_regs_writed = false;
+    return (ret);
+}
+
+static int camera_module_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+
+    if (ACTS_ISP_CAPTURE_MODE == priv->pcv_mode) {
+        *frames = DROP_NUM_CAPTURE;
+    } else {
+        *frames = DROP_NUM_PREVIEW;
+    }
+    GC_INFO("skip %d frames\n", *frames);
+    return 0;
+}
+
+
+static const struct v4l2_ctrl_ops camera_module_ctrl_ops = {
+	.g_volatile_ctrl = camera_module_g_volatile_ctrl,
+    .s_ctrl  = camera_module_s_ctrl,
+};
+
+static struct v4l2_subdev_sensor_ops module_subdev_sensor_ops = {
+	.g_skip_frames = camera_module_g_skip_frames,
+};
+
+
+static struct v4l2_subdev_core_ops camera_module_subdev_core_ops = {
+    .g_chip_ident    = camera_module_g_chip_ident,
+	.ioctl           = camera_module_ioctrl,
+	.s_power         = camera_module_s_power,	
+};
+
+static struct v4l2_subdev_video_ops camera_module_subdev_video_ops = {
+    .s_stream               = camera_module_s_stream,
+    .cropcap                = camera_module_cropcap,
+    .g_crop                 = camera_module_g_crop,
+    .g_parm                 = camera_module_g_parm,
+    .s_parm                 = camera_module_s_parm,
+    .enum_framesizes        = camera_module_enum_framesizes,
+    .enum_frameintervals    = camera_module_enum_frameintervals,
+    .enum_mbus_fmt          = camera_module_enum_fmt,
+    .g_mbus_fmt             = camera_module_g_fmt,
+    .try_mbus_fmt           = camera_module_try_fmt,
+    .s_mbus_fmt             = camera_module_s_fmt,
+    .g_mbus_config          = camera_module_g_mbus_config,
+    .s_mbus_config          = camera_module_s_mbus_config,
+};
+
+static struct v4l2_subdev_ops module_subdev_ops = {
+    .core   = &camera_module_subdev_core_ops,
+    .video  = &camera_module_subdev_video_ops,
+    .sensor = &module_subdev_sensor_ops,
+};
+
+static void camera_module_priv_init(struct camera_module_priv * priv)
+{
+    priv->pcv_mode           = ACTS_ISP_PREVIEW_MODE;
+    priv->exposure_auto            = 1;
+    priv->auto_white_balance       = 1;
+	priv->power_line_frequency     = DEFAULT_POWER_LINE_FREQUENCY;
+   	priv->power_line_frequency = V4L2_CID_POWER_LINE_FREQUENCY_50HZ;
+    priv->win = NULL;
+	priv->af_status 			   = AF_STATUS_DISABLE;   
+	priv->af_mode				   = CONTINUE_AF;		  
+	return;
+}
+
+static void camera_module_init_ops(struct v4l2_ctrl_handler *hdl, const struct v4l2_ctrl_ops *ops)
+{
+   
+    unsigned int cmd_array_size = ARRAY_SIZE(v4l2_ctl_array);
+    unsigned int cmd_menu_array_size = ARRAY_SIZE(v4l2_ctl_array_menu);
+	
+    struct v4l2_ctrl *ret = NULL;
+    unsigned int i = 0;
+	unsigned int err = 0;
+	GC_INFO("");
+
+    err = v4l2_ctrl_handler_init(hdl, cmd_array_size + cmd_menu_array_size);
+    
+	for (i = 0; i < cmd_array_size; i++) {
+			const struct v4l2_ctl_cmd_info *pctl = v4l2_ctl_array + i;
+	
+			ret = v4l2_ctrl_new_std(hdl, ops, pctl->id, pctl->min, pctl->max, pctl->step, pctl->def);
+	
+			if (NULL == ret) {
+				GC_ERR("ctr[%d] - id:%d, min:%d, max:%d, step:%d, def:%d", i,
+					   pctl->id, pctl->min, pctl->max, pctl->step, pctl->def);
+			}
+			if ((pctl->id == V4L2_CID_GAIN)	
+			 || (pctl->id == V4L2_CID_POWER_LINE_FREQUENCY)
+			 || (pctl->id == V4L2_CID_AF_STATUS)		 
+			 || (pctl->id == V4L2_CID_EXPOSURE)){ 	 
+				if (ret!= NULL){								 
+					ret->flags |= V4L2_CTRL_FLAG_VOLATILE;		 
+					ret = NULL; 								 
+				}													 
+			}														 
+			
+			hdl->error = 0;
+		}
+	  for (i = 0; i < cmd_menu_array_size; i++) {
+        const struct v4l2_ctl_cmd_info_menu *pmenu = v4l2_ctl_array_menu + i;
+		if((pmenu->id == V4L2_CID_FLASH_LED_MODE) && (!gpio_flash_cfg_exist))
+			{
+				continue;
+			}
+
+        ret = v4l2_ctrl_new_std_menu(hdl, ops, pmenu->id, pmenu->max, pmenu->mask, pmenu->def);
+
+        if (NULL == ret) {
+            GC_ERR("menu[%d] - id:%d, max:%d, mask:%d, def:%d", i,
+                   pmenu->id, pmenu->max, pmenu->mask, pmenu->def);
+        }
+        hdl->error = 0;
+    }
+	  GC_INFO("");
+    return ;
+}
+
+
+static int camera_module_probe(struct i2c_client *client, const struct i2c_device_id *did)
+{
+	int ret = 0;
+    
+    struct camera_module_priv  *priv;
+    struct soc_camera_subdev_desc *desc = soc_camera_i2c_to_desc(client);
+    struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	
+	struct v4l2_subdev *subdev;
+
+	
+	GC_INFO("%s probe start...",CAMERA_MODULE_NAME);
+    GC_INFO("flags:0x%x, addr:0x%x, name:%s, irq:0x%x",
+            client->flags, client->addr, client->name, client->irq);
+
+    if (NULL == desc) {
+        GC_ERR("error: camera module missing soc camera link");
+        return -EINVAL;
+    }
+    if (NULL == desc->drv_priv) {
+        GC_ERR("error: no init module_info of camera module");
+        return -EINVAL;
+    }
+
+    if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+        printk("[camera] I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE_DATA\n");
+        return -EIO;
+    }
+
+    priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+    if (!priv) {
+        return -ENOMEM;
+    }
+
+    camera_module_priv_init(priv);
+    priv->info = desc->drv_priv;
+
+    v4l2_i2c_subdev_init(&priv->subdev, client, &module_subdev_ops);
+	camera_module_init_ops(&priv->hdl, &camera_module_ctrl_ops);
+    priv->subdev.ctrl_handler = &priv->hdl;
+	priv->hdl.error = 0;
+    if (priv->hdl.error) {
+        ret = priv->hdl.error;
+        kfree(priv);
+        printk("[camera]%s %d, module init error!\n",__FUNCTION__, __LINE__);
+        return ret;
+    }
+	
+    subdev = i2c_get_clientdata(client);
+	init_regs_writed = true;
+	ret = camera_module_s_power(subdev, 1);
+	if(ret < 0)
+		return ret;
+	ret = module_verify_pid(client->adapter,priv);
+	ret = camera_module_s_power(subdev, 0);
+	if(0 > ret)
+		return ret;
+    priv->pcv_mode = ACTS_ISP_PREVIEW_MODE;
+	ret = v4l2_ctrl_handler_setup(&priv->hdl);
+	
+    return ret;
+}
+
+static int camera_module_remove(struct i2c_client *client)
+{
+    
+    struct camera_module_priv *priv = to_camera_priv(client);
+	GC_INFO("");
+    v4l2_device_unregister_subdev(&priv->subdev);
+    v4l2_ctrl_handler_free(&priv->hdl);
+    kfree(priv);
+
+
+    return 0;
+}
+
+
+DECLARE_DTS_SENSOR_CFG(g_sensor_cfg);
+
+#define CAMERA_COMMON_NAME           "sensor_common"
+
+/* soc_camer_link's hooks */
+static int camera_module_power(struct device *dev, int mode)
+{
+    struct dts_sensor_config *dsc = &g_sensor_cfg;
+    int channel = !!dsc->channel;
+    int rear_cam = !!dsc->rear;
+    int host_id = !!dsc->host;
+    int err;
+    
+    printk(KERN_INFO"isp_sensor_power, mode:%d\n", mode);
+    
+    if (mode) {
+       // dsc->mfp = pinctrl_get_select_default(dsc->dev);
+        printk(KERN_INFO"owl_isp_power_on - channel:%d, rear_cam:%d, host_id:%d\n",
+                channel, rear_cam, host_id);
+        err = owl_isp_power_on(channel, rear_cam, host_id);
+		//flash_flag = rear_cam;
+		if(dual)
+		{
+			flash_flag = !rear_cam;
+		}
+		else
+		{
+	   		flash_flag = rear_cam;
+		}
+    } else {
+        if (!IS_ERR(dsc->mfp)) {
+         //   pinctrl_put(dsc->mfp);
+        }
+        printk(KERN_INFO"owl_isp_power_off - channel:%d, rear_cam:%d, host_id:%d\n",
+                channel, rear_cam, host_id);
+        err = owl_isp_power_off(channel, rear_cam, host_id);
+    }
+    return err;
+}
+
+static int camera_module_reset(struct device *dev)
+{
+    //printk(KERN_INFO"isp_sensor_reset\n");
+    int host_id = !!g_sensor_cfg.host;
+    owl_isp_reset(dev, host_id);
+    return 0;
+}
+
+
+static struct i2c_board_info owl_i2c_camera = {
+    I2C_BOARD_INFO(CAMERA_MODULE_NAME, MODULE_I2C_REG_ADDRESS),
+};
+
+static struct module_info camera_module_info = {
+    .flags            = SENSOR_FLAG_8BIT | SENSOR_FLAG_DVP | SENSOR_FLAG_CHANNEL2,
+};
+
+static const unsigned short camera_module_addrs[] = {
+    MODULE_I2C_REG_ADDRESS,
+    I2C_CLIENT_END,
+};
+
+
+static struct soc_camera_link camera_module_link = {
+    .bus_id          = 0,
+    .power           = camera_module_power,
+    .reset           = camera_module_reset,
+    .board_info      = &owl_i2c_camera,
+    .i2c_adapter_id  = 1,  //id\B1\E0\BAŴ\D30\BF\AAʼ
+    .module_name     = CAMERA_MODULE_NAME,
+    .priv            = &camera_module_info,
+};
+
+static struct platform_device owl_camera_device = {
+    .name           = "soc-camera-pdrv",
+    .id             = 0,
+    .dev = {
+        .platform_data = &camera_module_link,
+    },
+};
+
+static struct platform_device  two_module_flag_device = {
+    .name           = "camera_flag_device",
+    .id             = 0,
+    .dev = {
+        //.platform_data = &camera_module_link,
+        //.init_name     = "sens1",
+    },
+};
+
+
+
+
+static const struct i2c_device_id camera_module_id[] = {
+    { CAMERA_MODULE_NAME, 0 },
+    { }
+};
+MODULE_DEVICE_TABLE(i2c, camera_module_id);
+
+
+
+static struct i2c_driver camera_i2c_driver = {
+    .driver = {
+        .name         = CAMERA_MODULE_NAME,
+    },
+    .probe            = camera_module_probe,
+    .remove           = camera_module_remove,
+    .id_table         = camera_module_id,
+};
+
+static ssize_t dualmod_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+    return (sprintf(buf, "%d [0: front, 1: rear]\n", !!g_sensor_cfg.rear));
+}
+
+/* if call it, should before opening the video */
+static ssize_t dualmod_store(struct kobject *kobj, struct kobj_attribute *attr,
+                             const char *buf, size_t n)
+{
+    int err = 0;
+
+    if ('1' == buf[0]) {
+        if (!g_sensor_cfg.rear) {
+            g_sensor_cfg.rear = 1;
+        }
+    } else if ('0' == buf[0]) {
+        if (g_sensor_cfg.rear) {
+            g_sensor_cfg.rear = 0;
+        }
+    } else {
+        err = -EINVAL;
+    }
+    return (err ? err : n);
+}
+static struct kobj_attribute dualmod_attr = __ATTR(dualmod, 0666, dualmod_show, dualmod_store);
+
+static struct kobject *dual_kobj = NULL;
+
+static int dual_sysfs_init(void)
+{
+    dual_kobj = kobject_create_and_add("dualcam", NULL);
+    if (NULL == dual_kobj) {
+        return (-ENOMEM);
+    }
+    if (sysfs_create_file(dual_kobj, &dualmod_attr.attr)) {
+        kobject_put(dual_kobj);
+        return (-ENOMEM);
+    }
+    return (0);
+}
+
+static void dual_sysfs_cleanup(void)
+{
+    if (NULL == dual_kobj) {
+        return;
+    }
+    sysfs_remove_file(dual_kobj, &dualmod_attr.attr);
+    kobject_put(dual_kobj);
+    return;
+}
+
+
+static int sensor_mod_init(struct soc_camera_link *link, struct platform_device *pdev,
+                            struct i2c_driver *idrv)
+{
+    struct dts_sensor_config *dsc = &g_sensor_cfg;
+    int ret = 0;
+	struct device_node *fdt_node;
+	fdt_node = of_find_compatible_node(NULL, NULL, "flashlight");
+	 if (NULL == fdt_node) {
+        printk("err: no [flashlight] in dts\n");
+		gpio_flash_cfg_exist =false;
+        }
+	 else
+	 	{
+	 		gpio_flash_cfg_exist = true;
+	 	}
+
+    ret = parse_config_info(link, dsc, CAMERA_COMMON_NAME);
+    if (ret) {
+        printk(KERN_ERR "fail go get config\n");
+        goto err;
+    }
+	
+    pdev->dev.of_node = dsc->dn;
+    dsc->dev = &pdev->dev;
+	#ifdef  SELf_DETECT
+	ret = detect_init();
+    if (ret) {
+        GC_INFO("module detect init error.");
+       goto err;
+    }
+	
+	camera_id = detect_work();
+
+	detect_deinit();
+	if(SENSOR_REAR == camera_id)
+		{
+		dsc->rear = 1;
+		camera_module_info.video_devnum = 0;
+		}
+	else if(SENSOR_FRONT == camera_id)
+		{
+		dsc->rear = 0;
+		camera_module_info.video_devnum = 1;
+		}
+	else
+		return camera_id;
+	#endif
+	camera_module_info.video_devnum = (rear == 0);
+	dsc->rear = rear;
+    GC_INFO("install as [%s] camera\n", (dsc->rear ? "REAR" : "FRONT"));
+    GC_INFO("i2c adapter[%d], host[%d], channel[%d], bus[%s], output data[%s]\n", 
+              dsc->i2c_adapter, dsc->host, dsc->channel,
+              V4L2_MBUS_PARALLEL == dsc->bus_type ? "DVP" : "MIPI",
+              SENSOR_DATA_TYPE_YUV == dsc->data_type ? "YUV" : "RAW");
+
+    pdev->id = !!dsc->rear;
+
+    printk("sensor_mod_init():platform_device_register: %s.%d,the modules name is %s\n",
+            pdev->name, pdev->id,CAMERA_MODULE_NAME);
+	 if (dual && (ret = dual_sysfs_init())) {
+        printk(KERN_ERR "sysfs init failed\n");
+        goto err;
+	   ret |= platform_device_register(&two_module_flag_device);
+      if (ret) {
+               goto err;
+        }
+    }
+    ret = platform_device_register(pdev);
+    if (ret) {
+        printk(KERN_ERR "fail to register platform\n");
+        goto regdev_err;
+    }
+
+    printk("sensor_mod_init():i2c_add_driver\n");
+    ret = i2c_add_driver(idrv);
+    if (ret) {
+        printk(KERN_ERR "fail to add i2c driver\n");
+        goto regdrv_err;
+    }
+    return (ret);
+
+  regdrv_err:
+    platform_device_unregister(pdev);
+  regdev_err:
+  err:
+
+    return (ret);
+}
+
+
+/* module function */
+static int __init camera_module_init(void)
+{
+    
+	unsigned int ret = 0;
+	GC_INFO("");
+    ret = sensor_mod_init(&camera_module_link, &owl_camera_device, &camera_i2c_driver);
+    return ret;
+}
+module_init(camera_module_init);
+
+static void  __exit camera_module_exit(void)
+{
+    GC_INFO("");
+	i2c_del_driver(&camera_i2c_driver);
+    platform_device_unregister(&owl_camera_device);
+	 if (dual) {
+        dual_sysfs_cleanup();
+    }
+}
+
+module_exit(camera_module_exit);
+module_param(rear, int, S_IRUSR);
+module_param(dual, int, 0);
+
+MODULE_DESCRIPTION("Camera module driver");
+MODULE_AUTHOR("Actions-semi");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.0");
+
diff --git a/drivers/media/i2c/camera/module_comm/module_comm.h b/drivers/media/i2c/camera/module_comm/module_comm.h
new file mode 100755
index 0000000..929d7da
--- /dev/null
+++ b/drivers/media/i2c/camera/module_comm/module_comm.h
@@ -0,0 +1,234 @@
+
+/*
+ * module common macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_COMM_H__
+#define __MODULE_COMM_H__
+
+
+/* for flags */
+#define MODULE_FLAG_VFLIP	(1 << 0) /* Vertical flip image */
+#define MODULE_FLAG_HFLIP	(1 << 1) /* Horizontal flip image */
+#define MODULE_FLAG_V_H_FLIP (MODULE_FLAG_VFLIP | MODULE_FLAG_HFLIP)
+
+#define MODULE_FLAG_8BIT	(1 << 2) /* default 8 bit */
+#define MODULE_FLAG_10BIT	(1 << 3) /*  10 bit interface*/
+#define MODULE_FLAG_12BIT	(1 << 4) /* 12 bit interface*/
+#define MODULE_FLAG_FRONT	(1 << 5) /* posization front */
+#define MODULE_FLAG_BACK	(1 << 6) /* posization back */
+#define MODULE_FLAG_PALL	(1 << 7) /* parellal interface */
+#define MODULE_FLAG_MIPI	(1 << 8) /* mipi interface */
+#define MODULE_FLAG_CHANNEL1	(1 << 9) /* use isp channel1 */
+#define MODULE_FLAG_CHANNEL2	(1 << 10) /* use isp channel2 */
+#define MODULE_FLAG_3D	(1 << 11) /* 3d mode */
+#define MODULE_FLAG_HOST1	(1 << 12) /* on host1 */
+#define MODULE_FLAG_HOST2	(1 << 13) /* on host2 */
+#define MODULE_FLAG_NODVDD	(1 << 14) /* no use dvdd */
+#define MODULE_FLAG_AF	(1 << 15) /* AUTO FOCUS */
+#define MODULE_FLAG_ALWAYS_POWER	(1 << 16) /* always power on */
+#define MODULE_FLAG_NO_AVDD	(1 << 17) /* no need to operate avdd */
+
+
+#define SENSOR_FRONT 0x1
+#define SENSOR_REAR 0x2
+#define SENSOR_DUAL 0x4
+
+#define ENDMARKER { 0xff, 0xff }
+
+//module interface type
+//#define INTERFACE_PALL "pall"
+//#define INTERFACE_MIPI "mipi"
+
+
+#define WIDTH_QQVGA		160
+#define HEIGHT_QQVGA	120
+#define WIDTH_QVGA		320
+#define HEIGHT_QVGA		240 
+#define WIDTH_VGA		640
+#define HEIGHT_VGA		480 
+#define WIDTH_SVGA		800
+#define HEIGHT_SVGA		600
+#define WIDTH_720P		1280
+#define HEIGHT_720P		720
+#define WIDTH_1080P		1920
+#define HEIGHT_1080P	1080
+#define WIDTH_UXGA		1600
+#define HEIGHT_UXGA		1200
+#define WIDTH_QSXGA		2592
+#define HEIGHT_QSXGA	1944
+#define WIDTH_QXGA      2048
+#define HEIGHT_QXGA      1536
+
+//#define MODULE_DBG
+
+#ifdef MODULE_DBG
+#define GC_INFO(fmt, args...)  printk(KERN_INFO"[" CAMERA_MODULE_NAME "] line:%d--%s() "fmt"\n", __LINE__, __FUNCTION__, ##args)
+#else
+#define GC_INFO(fmt, args...)  
+#endif
+
+#define GC_ERR(fmt, args...)   printk(KERN_ERR"[" CAMERA_MODULE_NAME "] line:%d--%s() "fmt"\n", __LINE__, __FUNCTION__, ##args)
+
+
+struct regval_list {
+	unsigned short reg_num;
+	unsigned short value;
+};
+
+
+
+
+struct camera_module_win_size {
+	char								*name;
+	__u32								width;
+	__u32								height;
+	const struct regval_list			*win_regs;
+	unsigned int        				*frame_rate_array;
+	unsigned int capture_only;
+};
+
+typedef struct
+{
+	 unsigned int max_shutter;
+    unsigned int shutter;
+    unsigned int gain;
+    unsigned int dummy_line;
+    unsigned int dummy_pixel;
+    unsigned int extra_line;
+} exposure_param_t;
+
+struct module_color_format {
+	enum v4l2_mbus_pixelcode code;
+    enum v4l2_colorspace colorspace;
+};
+
+struct camera_module_priv {
+	struct v4l2_subdev subdev;
+    struct v4l2_ctrl_handler hdl;
+    struct module_info *info;
+    const struct module_color_format *cfmt;
+    const struct camera_module_win_size *win;
+    int model;
+    int pcv_mode;
+    int flip_flag;
+
+    unsigned short auto_white_balance;
+    unsigned short exposure;
+    unsigned short power_line_frequency;
+    unsigned short white_balance_temperature;
+    unsigned short colorfx;
+    unsigned short exposure_auto;
+    unsigned short scene_exposure;
+
+    exposure_param_t preview_exposure_param;
+    exposure_param_t capture_exposure_param;
+	enum v4l2_flash_led_mode 			flash_led_mode;
+	enum af_status						af_status;	
+	enum af_mode						af_mode;	
+};
+
+/*
+ * supported color format list.
+ * see definition in
+ *     http://thread.gmane.org/gmane.linux.drivers.video-input-infrastructure/12830/focus=13394
+ * YUYV8_2X8_LE == YUYV with LE packing
+ * YUYV8_2X8_BE == UYVY with LE packing
+ * YVYU8_2X8_LE == YVYU with LE packing
+ * YVYU8_2X8_BE == VYUY with LE packing
+ */
+static const struct module_color_format module_cfmts[] = {
+	{
+        .code = V4L2_MBUS_FMT_YUYV8_2X8,
+        .colorspace = V4L2_COLORSPACE_JPEG,
+    },
+    {
+        .code = V4L2_MBUS_FMT_UYVY8_2X8,
+        .colorspace = V4L2_COLORSPACE_JPEG,
+    },
+    {
+        .code = V4L2_MBUS_FMT_YVYU8_2X8,
+        .colorspace = V4L2_COLORSPACE_JPEG,
+    },
+    {
+        .code = V4L2_MBUS_FMT_VYUY8_2X8,
+        .colorspace = V4L2_COLORSPACE_JPEG,
+    },
+};
+
+#ifdef  SELf_DETECT
+static int detect_work(void);
+static int detect_init(void);
+static void detect_deinit(void);
+#endif
+
+
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest);
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src);
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals);
+
+static struct camera_module_priv *to_camera_priv(const struct i2c_client *client);
+
+static int  module_soft_reset(struct i2c_client *client);
+static int module_save_exposure_param(struct v4l2_subdev *sd);
+
+
+static int  module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+
+
+
+static int  module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt);
+//static int  module_s_mirror_flip(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip);
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv);
+static int module_set_stream(struct i2c_client *client,int enable);
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl);
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+
+
+
+static int  module_start_aec(struct v4l2_subdev *sd);
+static int  module_freeze_aec(struct v4l2_subdev *sd);
+//static int module_normal(struct v4l2_subdev *sd);
+static int  module_set_exposure_param(struct v4l2_subdev *sd);
+static int module_save_exposure_param(struct v4l2_subdev *sd);
+
+#if 0
+static int  module_soft_standby(struct i2c_client *client);
+
+static int  module_set_exposure(struct v4l2_subdev *sd);
+
+static int  module_start_aec(struct v4l2_subdev *sd);
+static int  module_freeze_aec(struct v4l2_subdev *sd);
+
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_set_prev_capt_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_pause_af(struct i2c_client *client);
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl);
+static int  module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+static int  module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+
+static int  module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl);
+#endif
+
+#endif  //__MODULE_COMM_H__
diff --git a/drivers/media/i2c/camera/module_comm/module_detect.c b/drivers/media/i2c/camera/module_comm/module_detect.c
new file mode 100755
index 0000000..6086a00
--- /dev/null
+++ b/drivers/media/i2c/camera/module_comm/module_detect.c
@@ -0,0 +1,649 @@
+#include <linux/of_gpio.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <mach/isp-owl.h>
+#include <mach/module-owl.h>
+#include <mach/clkname.h>
+#include "module_comm.h"
+
+#define CAMERA_COMMON_NAME           "sensor_common"
+#define CAMERA_DETECT_NAME           "sensor_detect before probe"
+
+#define ISP_FDT_COMPATIBLE           "actions,owl-isp"
+
+#define CAMERA_MODULE_CLOCK     24000000
+#define ISP_MODULE_CLOCK        60000000
+#define CAMERA_REAR_NAME        "rear_camera"
+#define CAMERA_FRONT_NAME        "front_camera"
+
+static int  camera_front_offset  = -1;
+static int  camera_rear_offset   = -1;
+
+
+
+static struct clk *g_sensor_clk = NULL;
+static struct clk *g_isp_clk    = NULL;
+
+static char camera_front_name[32];
+static char camera_rear_name[32];
+
+
+/////////////
+static struct sensor_pwd_info   g_spinfo;
+static struct isp_regulators    g_isp_ir;
+static int                      g_sens_channel = 0;   // sens0 or sens1
+static struct i2c_adapter       *g_adap;
+/////////////
+
+
+//struct module_item_t g_module = CAMERA_ITEM_INIT(gc2035, 0x78, 1, 1, module_verify_pid);
+
+static int get_parent_node_id(struct device_node *node,
+    const char *property, const char *stem)
+{
+    struct device_node *pnode;
+    unsigned int value = -ENODEV;
+
+    pnode = of_parse_phandle(node, property, 0);
+    if (NULL == pnode) {
+        printk(KERN_ERR "err: fail to get node[%s]", property);
+        return value;
+    }
+    value = of_alias_get_id(pnode, stem);
+
+    return value;
+}
+
+static int init_common(void)
+{
+    struct device_node *fdt_node;
+    int i2c_adap_id = 0;
+    struct dts_regulator *dr = &g_isp_ir.avdd.regul;
+
+	// GC_INFO("");
+    // get i2c adapter
+    fdt_node = of_find_compatible_node(NULL, NULL, CAMERA_COMMON_NAME);
+    if (NULL == fdt_node) {
+        GC_ERR("err: no ["CAMERA_COMMON_NAME"] in dts");
+        return -1;
+    }
+    i2c_adap_id = get_parent_node_id(fdt_node, "i2c_adapter", "i2c");
+    g_adap = i2c_get_adapter(i2c_adap_id);
+	// GC_INFO("");
+    // get sens channel
+    if(of_property_read_u32(fdt_node, "channel", &g_sens_channel)) {
+        g_sens_channel = 0;
+    }
+	//GC_INFO("");
+
+
+    g_spinfo.flag = 0;
+    g_spinfo.gpio_rear.num = -1;
+    g_spinfo.gpio_front.num = -1;
+    g_spinfo.gpio_reset.num = -1;
+    g_spinfo.ch_clk[ISP_CHANNEL_0] = NULL;
+    g_spinfo.ch_clk[ISP_CHANNEL_1] = NULL;
+
+    dr->regul = NULL;
+    g_isp_ir.avdd_use_gpio = 0;
+    g_isp_ir.dvdd_use_gpio = 0;
+    g_isp_ir.dvdd.regul = NULL;
+
+    return 0;
+}
+
+static inline void set_gpio_level(struct dts_gpio *gpio, bool active) {
+    if (active) {
+        gpio_direction_output(gpio->num, gpio->active_level);
+    } else {
+        gpio_direction_output(gpio->num, !gpio->active_level);
+    }
+}
+
+static int gpio_init(struct device_node *fdt_node,
+                     const char *gpio_name, struct dts_gpio *gpio, bool active)
+{
+    enum of_gpio_flags flags;
+
+    if (!of_find_property(fdt_node, gpio_name, NULL)) {
+        GC_ERR("no config gpios:%s", gpio_name);
+        goto fail;
+    }
+    gpio->num = of_get_named_gpio_flags(fdt_node, gpio_name, 0, &flags);
+    gpio->active_level = !(flags & OF_GPIO_ACTIVE_LOW);
+
+  // GC_INFO("%s: num-%d, active-%s", gpio_name, gpio->num, gpio->active_level ? "high" : "low");
+
+    if (gpio_request(gpio->num, gpio_name)) {
+        GC_ERR("fail to request gpio [%d]", gpio->num);
+        gpio->num = -1;
+        goto fail;
+    }
+
+    set_gpio_level(gpio, active);
+
+   // GC_INFO("gpio value: 0x%x", gpio_get_value(gpio->num));
+
+    return 0;
+  fail:
+    return -1;
+}
+
+static void gpio_exit(struct dts_gpio *gpio, bool active)
+{
+    //GC_INFO("gpio free:%d", gpio->num);
+    if (gpio->num >= 0) {
+        set_gpio_level(gpio, active);
+        gpio_free(gpio->num);
+    }
+}
+
+static int regulator_init(struct device_node *fdt_node,
+                          const char *regul_name, const char *scope_name,
+                          struct dts_regulator *dts_regul)
+{
+    unsigned int scope[2];
+    const char *regul = NULL;
+
+   // GC_INFO("");
+    if (of_property_read_string(fdt_node, regul_name, &regul)) {
+        GC_ERR("don't config %s", regul_name);
+        goto fail;
+    }
+   // GC_INFO("%s", regul ? regul : "NULL");
+
+    if (of_property_read_u32_array(fdt_node, scope_name, scope, 2)) {
+        GC_ERR("fail to get %s", scope_name);
+        goto fail;
+    }
+   // GC_INFO("min-%d, max-%d", scope[0], scope[1]);
+    dts_regul->min = scope[0];
+    dts_regul->max = scope[1];
+
+    dts_regul->regul = regulator_get(NULL, regul);
+    if (IS_ERR(dts_regul->regul)) {
+        dts_regul->regul = NULL;
+        GC_ERR("get regulator failed");
+        goto fail;
+    }
+
+    regulator_set_voltage(dts_regul->regul, dts_regul->min, dts_regul->max);
+    //regulator_enable(dts_regul->regul);
+    //mdelay(5);
+    return 0;
+
+  fail:
+    return -1;
+
+}
+
+static inline void regulator_exit(struct dts_regulator *dr)
+{
+    regulator_put(dr->regul);
+    dr->regul = NULL;
+}
+
+static int isp_regulator_init(struct device_node *fdt_node, struct isp_regulators *ir)
+{
+    const char *avdd_src = NULL;
+
+/*DVDD*/
+    struct dts_gpio *dvdd_gpio = &ir->dvdd_gpio;
+    //GC_INFO("");
+    if (!gpio_init(fdt_node, "dvdd-gpios", dvdd_gpio, 0))/* poweroff */
+        ir->dvdd_use_gpio = 1;
+    else
+        ir->dvdd_use_gpio = 0;
+
+    if (regulator_init(fdt_node, "dvdd-regulator",
+                "dvdd-regulator-scope", &ir->dvdd))
+        goto fail;
+
+/*AVDD*/
+    if (of_property_read_string(fdt_node, "avdd-src", &avdd_src)) {
+        GC_ERR("get avdd-src faild");
+        goto fail;
+    }
+
+    if (!strcmp(avdd_src, "regulator")) {
+  //      GC_INFO("avdd using regulator");
+        ir->avdd_use_gpio = 0;
+
+        if (regulator_init(fdt_node, "avdd-regulator",
+                    "avdd-regulator-scope", &ir->avdd.regul))
+            goto free_dvdd;
+    } else if (!strcmp(avdd_src, "gpio")) {
+        struct dts_gpio *gpio = &ir->avdd.gpio;
+        ir->avdd_use_gpio = 1;
+
+    gpio_init(fdt_node, "avdd-gpios", gpio, 0);
+
+      //  GC_INFO("set - avdd gpio value: 0x%x", gpio_get_value(gpio->num));
+    } else {
+        //GC_INFO("needn't operate avdd manually");
+    }
+
+    return 0;
+
+free_dvdd:
+    regulator_exit(&ir->dvdd);
+fail:
+    return -1;
+}
+
+static void isp_regulator_exit(struct isp_regulators *ir)
+{
+   // GC_INFO("");
+    if (ir->dvdd_use_gpio)
+        gpio_exit(&ir->dvdd_gpio, 0);
+
+    if (ir->dvdd.regul) {
+        regulator_exit(&ir->dvdd);
+    }
+
+    if (ir->avdd_use_gpio) {
+        gpio_exit(&ir->avdd.gpio, 0);
+    } else {
+        struct dts_regulator *dr = &ir->avdd.regul;
+
+        if (dr->regul) {
+            regulator_exit(dr);
+        }
+    }
+}
+
+static void isp_regulator_enable(struct isp_regulators *ir)
+{
+  //  GC_INFO("");
+  	int ret = 0;
+    if (ir->dvdd.regul) {
+        ret = regulator_enable(ir->dvdd.regul);
+        mdelay(1);
+    }
+
+    if (ir->avdd_use_gpio) {
+        set_gpio_level(&ir->avdd.gpio, 1);
+    } else {
+        struct dts_regulator *dr = &ir->avdd.regul;
+        if (dr->regul) {
+            ret = regulator_enable(dr->regul);
+            mdelay(1);
+        }
+    }
+
+    if (ir->dvdd_use_gpio) {
+        set_gpio_level(&ir->dvdd_gpio, 1);
+    }
+}
+
+static void isp_regulator_disable(struct isp_regulators *ir)
+{
+    //GC_INFO("");
+    if (ir->dvdd_use_gpio) {
+        set_gpio_level(&ir->dvdd_gpio, 0);
+    }
+
+    if (ir->dvdd.regul) {
+        regulator_disable(ir->dvdd.regul);
+    }
+
+    if (ir->avdd_use_gpio) {
+        set_gpio_level(&ir->avdd.gpio, 0);
+    } else {
+        struct dts_regulator *dr = &ir->avdd.regul;
+        if (dr->regul) {
+            regulator_disable(dr->regul);
+        }
+    }
+}
+static int isp_gpio_init(struct device_node *fdt_node, struct sensor_pwd_info *spinfo)
+{
+    const char *sensors = NULL;
+
+   // GC_INFO("");
+    if (gpio_init(fdt_node, "reset-gpios", &spinfo->gpio_reset, 0)) {
+        goto fail;
+    }
+
+    if (of_property_read_string(fdt_node, "sensors", &sensors)) {
+        GC_ERR("get sensors faild");
+        goto free_reset;
+    }
+
+    if (!strcmp(sensors, "front")) {
+        // default is power-down
+        if (gpio_init(fdt_node, "pwdn-front-gpios", &spinfo->gpio_front, 1)) {
+            goto free_reset;
+        }
+        spinfo->flag = SENSOR_FRONT;
+    } else if (!strcmp(sensors, "rear")) {
+        if (gpio_init(fdt_node, "pwdn-rear-gpios", &spinfo->gpio_rear, 1)) {
+            goto free_reset;
+        }
+        spinfo->flag = SENSOR_REAR;
+    } else if (!strcmp(sensors, "dual")) {
+        if (gpio_init(fdt_node, "pwdn-front-gpios", &spinfo->gpio_front, 1)) {
+            goto free_reset;
+        }
+        if (gpio_init(fdt_node, "pwdn-rear-gpios", &spinfo->gpio_rear, 1)) {
+            gpio_exit(&spinfo->gpio_front, 1);
+            goto free_reset;
+        }
+        spinfo->flag = SENSOR_DUAL;
+    } else {
+        GC_ERR("sensors of dts is wrong");
+        goto free_reset;
+    }
+    return 0;
+
+  free_reset:
+    gpio_exit(&spinfo->gpio_reset, 0);
+  fail:
+    return -1;
+}
+
+static void isp_gpio_exit(struct sensor_pwd_info *spinfo)
+{
+    //GC_INFO("");
+    // only free valid gpio, so no need to check its existence.
+    gpio_exit(&spinfo->gpio_front, 1);
+    gpio_exit(&spinfo->gpio_rear, 1);
+    gpio_exit(&spinfo->gpio_reset, 0);
+}
+
+static int isp_clk_init(void)
+{
+    struct clk *tmp = NULL;
+    int ret = 0;
+
+    module_reset(MODULE_RST_BISP);
+    module_clk_enable(MOD_ID_BISP);
+
+   // GC_INFO("");
+    tmp = clk_get(NULL, CLKNAME_BISP_CLK);
+    if (IS_ERR(tmp)) {
+        ret = PTR_ERR(tmp);
+        g_isp_clk = NULL;
+        GC_ERR("get isp clock error (%d)", ret);
+        return ret;
+    }
+    g_isp_clk = tmp;
+
+    mdelay(1);
+    
+    return ret;
+}
+
+static int isp_clk_enable(void)
+{
+    int ret = 0;
+    if (g_isp_clk != NULL) {
+        clk_prepare(g_isp_clk);
+        ret = clk_enable(g_isp_clk);  /*enable clk*/
+        if (ret) {
+            GC_ERR("si clock enable error (%d)", ret);
+        }
+        ret = clk_set_rate(g_isp_clk, ISP_MODULE_CLOCK); /*\C9\E8\D6\C3isp\B9\A4\D7\F7Ƶ\C2\CA*/
+    }
+    
+    return ret;    
+}
+
+static void isp_clk_disable(void)
+{
+    //GC_INFO("");
+    if (g_isp_clk != NULL) {
+        clk_disable(g_isp_clk);
+        clk_unprepare(g_isp_clk);
+        clk_put(g_isp_clk);
+        module_clk_disable(MOD_ID_BISP);
+        g_isp_clk = NULL;
+    }
+}
+
+static int sensor_clk_init(void)
+{
+    struct clk *tmp = NULL;
+    int ret = 0;
+
+    module_clk_enable(MOD_ID_CSI);
+    module_reset(MODULE_RST_CSI);
+
+  //  GC_INFO("sensor channel:%d", g_sens_channel);
+    if(g_sens_channel == 0)
+        tmp = clk_get(NULL, CLKNAME_SENSOR_CLKOUT0);
+    else
+        tmp = clk_get(NULL, CLKNAME_SENSOR_CLKOUT1);
+    if (IS_ERR(tmp)) {
+        ret = PTR_ERR(tmp);
+        GC_ERR("get isp-channel-%d clock error%d", g_sens_channel, ret);
+        return ret;
+    }
+    g_sensor_clk = tmp;
+ //   GC_INFO("sensor_clk:%p", g_sensor_clk);
+    return ret;
+}
+
+static int sensor_clk_enable(void)
+{
+    int ret;
+
+  //  GC_INFO("");
+    if(g_sensor_clk == NULL) {
+        GC_ERR("sensor clk not initialized!");
+        return -1;
+    }
+
+    clk_prepare(g_sensor_clk);
+    clk_enable(g_sensor_clk);
+
+    ret = clk_set_rate(g_sensor_clk, CAMERA_MODULE_CLOCK); /*\C9\E8\D6\C3sensorƵ\C2\CA*/
+    if (ret) {
+        GC_ERR("set isp clock error");
+    }
+    mdelay(2);
+    return ret;
+}
+
+static void sensor_clk_disable(void)
+{
+   // GC_INFO("");
+    if(g_sensor_clk == NULL) {
+        GC_ERR("sensor clk not initialized!");
+        return;
+    }
+
+    clk_disable(g_sensor_clk);
+    clk_unprepare(g_sensor_clk);
+    clk_put(g_sensor_clk);
+    module_clk_disable(MOD_ID_CSI);
+    g_sensor_clk = NULL;
+}
+
+
+static void sensor_power(bool front, bool on)
+{
+   // GC_INFO("%s sensor power %s", front ? "front" : "rear", on ? "on" : "off");
+    if (front) {
+        set_gpio_level(&g_spinfo.gpio_front, !on);
+      //  sensor_reset();
+    } else {
+        set_gpio_level(&g_spinfo.gpio_rear, !on);
+    }
+    mdelay(2);
+}
+static int detect_init(void)
+{
+    struct device_node *fdt_node = NULL;
+    int ret = 0;
+
+   // GC_INFO("");
+
+    if(init_common()) {
+        return -1;
+    }
+
+    ret = isp_clk_init();
+    if (ret) {
+        GC_ERR("init isp clock error");
+        goto exit;
+    }
+
+    ret = sensor_clk_init();
+    if (ret) {
+        GC_ERR("init sensor clock error");
+        goto exit;
+    }
+
+    fdt_node = of_find_compatible_node(NULL, NULL, ISP_FDT_COMPATIBLE);
+    if (NULL == fdt_node) {
+        GC_ERR("err: no ["ISP_FDT_COMPATIBLE"] in dts");
+        return -1;
+    }
+
+    ret = isp_gpio_init(fdt_node, &g_spinfo);
+    if (ret) {
+        GC_ERR("pwdn init error!");
+        goto exit;
+    }
+
+    ret = isp_regulator_init(fdt_node, &g_isp_ir);
+    if (ret) {
+        GC_ERR("avdd init error!");
+        goto exit;
+    }
+
+    ret = isp_clk_enable();
+    if (ret) {
+        GC_ERR("enable isp clock error");
+        goto exit;
+    }
+
+    ret = sensor_clk_enable();
+    if (ret) {
+        GC_ERR("enable sensor clock error");
+        goto exit;
+    }
+
+    isp_regulator_enable(&g_isp_ir);
+    return ret;
+
+exit:
+    isp_clk_disable();
+    sensor_clk_disable();
+    isp_regulator_exit(&g_isp_ir);
+    isp_gpio_exit(&g_spinfo);
+
+    return ret;
+}
+
+ static void detect_deinit(void)
+{
+    isp_clk_disable();
+    sensor_clk_disable();
+	isp_regulator_disable(&g_isp_ir);
+    isp_regulator_exit(&g_isp_ir);
+    isp_gpio_exit(&g_spinfo);
+   
+}
+
+
+static int detect_process(void)
+{
+    int ret = -1;
+    ret = module_verify_pid(g_adap,NULL);
+    if (ret == 0) {
+        GC_INFO("detect  success!!!!!!!!");
+    }
+    else
+    {
+        GC_INFO("( failed.");
+    }
+
+    return ret;
+}
+
+#if 1
+static ssize_t front_name_show(struct device *dev,  struct device_attribute *attr,  
+        char *buf)  
+{  
+    return strlcpy(buf, camera_front_name, sizeof(camera_front_name)); 
+}  
+
+static ssize_t rear_name_show(struct device *dev,  struct device_attribute *attr,
+        char *buf)  
+{  
+    return strlcpy(buf, camera_rear_name, sizeof(camera_rear_name)); 
+}
+
+
+static ssize_t front_offset_show(struct device *dev,  struct device_attribute *attr,  
+        char *buf)  
+{  
+    return sprintf(buf, "%d", camera_front_offset); 
+}  
+
+static ssize_t rear_offset_show(struct device *dev,  struct device_attribute *attr,
+        char *buf)  
+{  
+    return sprintf(buf, "%d", camera_rear_offset); 
+}  
+
+static DEVICE_ATTR(front_name,   0444, front_name_show,   NULL); 
+static DEVICE_ATTR(rear_name,    0444, rear_name_show,    NULL);
+static DEVICE_ATTR(front_offset, 0444, front_offset_show, NULL); 
+static DEVICE_ATTR(rear_offset,  0444, rear_offset_show,  NULL);
+
+#endif
+static int  detect_work(void)
+{
+    int ret = 0;
+
+   
+       // GC_INFO("--------detect front sensor------");
+        sensor_power(true, true);
+        ret = detect_process();
+		sensor_power(true, false);
+		if(0 == ret)
+			{
+			#if 1
+			 struct kobject             *front_kobj;
+			 front_kobj = kobject_create_and_add(CAMERA_FRONT_NAME, NULL);
+			 if (front_kobj == NULL) {  
+       			 GC_ERR("kobject_create_and_add failed.");
+        			ret = -ENOMEM;  
+					return ret;
+    			}  
+			 	camera_front_offset = 1;
+			 	sprintf(camera_front_name, "%s.ko", CAMERA_MODULE_NAME);
+				ret = sysfs_create_file(front_kobj, &dev_attr_front_offset.attr);
+			    ret = sysfs_create_file(front_kobj, &dev_attr_front_name.attr);
+				#endif
+			 return SENSOR_FRONT;
+			}
+
+      //  DBG_INFO("-------detect rear sensor-------");
+        sensor_power(false, true);
+        ret = detect_process();
+		sensor_power(false, false);
+        if (ret == 0) {
+		struct kobject             *rear_kobj;
+			 rear_kobj = kobject_create_and_add(CAMERA_REAR_NAME, NULL);
+			 if (rear_kobj == NULL) {  
+       			 GC_ERR("kobject_create_and_add failed.");
+        			ret = -ENOMEM;  
+					return ret;
+    			}  
+			 	camera_rear_offset = 0;
+			 	ret = sysfs_create_file(rear_kobj, &dev_attr_rear_offset.attr);
+			 	sprintf(camera_rear_name, "%s.ko", CAMERA_MODULE_NAME);
+			    ret = sysfs_create_file(rear_kobj, &dev_attr_rear_name.attr);
+		return SENSOR_REAR;
+        }
+		return ret;
+}
+
diff --git a/drivers/media/i2c/camera/ov2686/Kconfig b/drivers/media/i2c/camera/ov2686/Kconfig
new file mode 100755
index 0000000..c407ed53
--- /dev/null
+++ b/drivers/media/i2c/camera/ov2686/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config OV2686
+	tristate "ov5640 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for ov2686 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ov2686.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/ov2686/Makefile b/drivers/media/i2c/camera/ov2686/Makefile
new file mode 100755
index 0000000..451db91
--- /dev/null
+++ b/drivers/media/i2c/camera/ov2686/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_OV2686)	+= ov2686.o
+
diff --git a/drivers/media/i2c/camera/ov2686/module_diff.h b/drivers/media/i2c/camera/ov2686/module_diff.h
new file mode 100755
index 0000000..91901bb
--- /dev/null
+++ b/drivers/media/i2c/camera/ov2686/module_diff.h
@@ -0,0 +1,842 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+
+#define CAMERA_MODULE_NAME 		"ov2686"
+#define CAMERA_MODULE_PID		0x2685
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_I2C_REAL_ADDRESS  (0x78 >> 1)
+#define MODULE_I2C_REG_ADDRESS		(0x78 >> 1)
+
+#define I2C_REGS_WIDTH			2
+#define I2C_DATA_WIDTH			1
+//#define IS_FRONT_OR_REAR        0
+
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_LOW
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING
+//V4L2_MBUS_PCLK_SAMPLE_FALLING
+
+
+
+#if 0
+#define PID						0x00 /* Product ID Number */
+#else
+#define PIDH					0x300a /* Product ID Number H byte */
+#define PIDL					0x300b /* Product ID Number L byte */
+#endif
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA
+#define MODULE_MAX_WIDTH		WIDTH_QSXGA
+#define MODULE_MAX_HEIGHT		HEIGHT_QSXGA
+
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		2
+#define DROP_NUM_PREVIEW		4
+static unsigned int frame_rate_vga[]   = {30,};
+static unsigned int frame_rate_720p[]  = {30,};
+static unsigned int frame_rate_uxga[] = {15,};
+
+
+
+static const struct regval_list module_init_regs[] =
+{ 
+	//																											 
+	//OV2686 setting version History																			 
+	//;;1. 05/17/2014 V00																						 
+	// based on OV2686_AA_00_02_00.ovt																			 
+	// 1. Initial release																						 
+	//;;1. 6/11/2014 V02a																						 
+	// based on OV2686_AA_00_02_00.ovt																			 
+	// 1. update CMX,AWB,LENC,DPC settings																		 
+	{0x0103,0x01},//software reset																				 
+	{0x3000,0x03},//Y[9:8] output																				 
+	{0x3001,0xff},//Y[7:0] output																				 
+	{0x3002,0x1a},//Vsync output, FSIN input																	 
+	{0x3011,0x00},//Pad 																						 
+	{0x301d,0xf0},//sclk_fc, sclk_grp, sclk_bist, daclk_sel0													 
+	{0x3020,0x00},//output raw																					 
+	{0x3021,0x23},//software standby enter at l_blk, frex_ef_sel, cen_blobal_o									 
+	{0x3082,0x2c},//PLL 																						 
+	{0x3083,0x00},																								 
+	{0x3084,0x07},																								 
+	{0x3085,0x03},																								 
+	{0x3086,0x01},																								 
+	{0x3087,0x00},																								 
+	{0x3106,0x01},//PLL 																						 
+	{0x3501,0x26},//exposure M																					 
+	{0x3502,0x40},//exposure L																					 
+	{0x3503,0x03},//gain delay 1 frame, vts auto, agc off, aec off												 
+	{0x350b,0x36},//gain L																						 
+	{0x3600,0xb4},//Analog Control																				 
+	{0x3603,0x35},																								 
+	{0x3604,0x24},																								 
+	{0x3605,0x00},																								 
+	{0x3620,0x25},																								 
+	{0x3621,0x37},																								 
+	{0x3622,0x23},																								 
+	{0x3628,0x10},//Analog Control																				 
+	{0x3701,0x64},//Sensor Conrol																				 
+	{0x3705,0x3c},																								 
+	{0x370a,0x23},																								 
+	{0x370c,0x50},																								 
+	{0x370d,0xc0},																								 
+	{0x3717,0x58},																								 
+	{0x3718,0x80},																								 
+	{0x3720,0x00},																								 
+	{0x3721,0x00},																								 
+	{0x3722,0x00},																								 
+	{0x3723,0x00},																								 
+	{0x3738,0x00},//Sensor Control																				 
+	{0x3781,0x80},//PSRAM control																				 
+	{0x3789,0x60},//PSRAM control																				 
+	{0x3800,0x00},//Timing, x start H																			 
+	{0x3801,0x00},//x start L																					 
+	{0x3802,0x00},//y start H																					 
+	{0x3803,0x00},//y start L																					 
+	{0x3804,0x06},//x end H 																					 
+	{0x3805,0x4f},//x end L 																					 
+	{0x3806,0x04},//y end H 																					 
+	{0x3807,0xbf},//y end L 																					 
+	{0x3808,0x03},//x output size H 																			 
+	{0x3809,0x20},//x output size L 																			 
+	{0x380a,0x02},//y output size H 																			 
+	{0x380b,0x58},//y output size L 																			 
+	{0x380c,0x06},//HTS H																						 
+	{0x380d,0xac},//HTS L																						 
+	{0x380e,0x02},//VTS H																						 
+	{0x380f,0x84},//VTS L																						 
+	{0x3810,0x00},//isp x win H 																				 
+	{0x3811,0x04},//isp x win L 																				 
+	{0x3812,0x00},//isp y win H 																				 
+	{0x3813,0x04},//isp y win L 																				 
+	{0x3814,0x31},//x inc																						 
+	{0x3815,0x31},//y inc																						 
+	{0x3819,0x04},//vsync_end_row L 																			 
+	{0x3820,0xc2},//vsub48_blc, vflip_blc, vbinf																 
+	{0x3821,0x01},//hbin																						 
+	{0x3a06,0x00},//B50 H																						 
+	{0x3a07,0xc2},//B50 L																						 
+	{0x3a08,0x00},//B60 H																						 
+	{0x3a09,0xA1},//B60 L																						 
+	{0x3a0a,0x07},//max exp 50 H																				 
+	{0x3a0b,0x94},//max exp 50 L																				 
+	{0x3a0c,0x07},//max exp 60 H																				 
+	{0x3a0d,0x94},//max exp 60 L																				 
+	{0x3a0e,0x02},//VTS band 50 H																				 
+	{0x3a0f,0x46},//VTS band 50 L																				 
+	{0x3a10,0x02},//VTS band 60 H																				 
+	{0x3a11,0x84},//VTS band 60 L																				 
+	{0x4000,0x81},//avg_weight, mf_en																			 
+	{0x4001,0x40},//format_trig_beh 																			 
+	{0x4008,0x00},//bl_start																					 
+	{0x4009,0x03},//bl_end																						 
+	{0x4300,0x31},//YUV422	
+	{0x4301,0x41},
+	{0x430e,0x20},//no swap, no bypass																			 
+	{0x4602,0x02},//Frame reset enable																			 
+	{0x5000,0xff},//lenc_en, awb_gain_en, lcd_en, avg_en, dgc_en, bc_en, wc_en, blc-en							 
+	{0x5001,0x05},//avg_sel after LCD																			 
+	{0x5002,0x32},//dpc_href_s, sof_sel, bias_plus																 
+	{0x5003,0x04},//bias_man																					 
+	{0x5004,0xff},//uv_dns_en, rng_dns_en, gamma_en, cmxen, cip_en, raw_dns_en, stretch_en, awb_en				 
+	{0x5005,0x12},//sde_en, rgb2yuv_en																			 
+	{0x5180,0xf4},//AWB 																						 
+	{0x5181,0x11},																								 
+	{0x5182,0x41},																								 
+	{0x5183,0x42},																								 
+	{0x5184,0x6e},																								 
+	{0x5185,0x56},																								 
+	{0x5186,0xb4},																								 
+	{0x5187,0xb2},																								 
+	{0x5188,0x08},																								 
+	{0x5189,0x0e},																								 
+	{0x518a,0x0e},																								 
+	{0x518b,0x46},																								 
+	{0x518c,0x38},																								 
+	{0x518d,0xf8},																								 
+	{0x518e,0x04},																								 
+	{0x518f,0x7f},																								 
+	{0x5190,0x40},																								 
+	{0x5191,0x5f},																								 
+	{0x5192,0x40},																								 
+	{0x5193,0xff},																								 
+	{0x5194,0x40},																								 
+	{0x5195,0x07},																								 
+	{0x5196,0x04},																								 
+	{0x5197,0x04},																								 
+	{0x5198,0x00},																								 
+	{0x5199,0x05},																								 
+	{0x519a,0xd2},																								 
+	{0x519b,0x04},//AWB 																						 
+	{0x5200,0x09},//stretch minimum value is 3096, auto 														 
+	{0x5201,0x00},//stretch min low level																		 
+	{0x5202,0x06},//stretch max low level																		 
+	{0x5203,0x20},//stretch min high level																		 
+	{0x5204,0x41},//stretch step2, stretch step1																 
+	{0x5205,0x16},//stretch current low level																	 
+	{0x5206,0x00},//stretch current high level L																 
+	{0x5207,0x05},//stretch current high level H																 
+	{0x520b,0x30},//stretch_thres1 L																			 
+	{0x520c,0x75},//stretch_thres1 M																			 
+	{0x520d,0x00},//stretch_thres1 H																			 
+	{0x520e,0x30},//stretch_thres2 L																			 
+	{0x520f,0x75},//stretch_thres2 M																			 
+	{0x5210,0x00},//stretch_thres2 H																			 
+	{0x5280,0x14},//raw_DNS, m_nNoiseYslop = 5																	 
+	{0x5281,0x02},//m_nNoiseList[0] 																			 
+	{0x5282,0x02},//m_nNoiseList[1] 																			 
+	{0x5283,0x04},//m_nNoiseList[2] 																			 
+	{0x5284,0x06},//m_nNoiseList[3] 																			 
+	{0x5285,0x08},//m_nNoiseList[4] 																			 
+	{0x5286,0x0c},//m_nNoiseList[5] 																			 
+	{0x5287,0x10},//m_nMaxEdgeThre																				 
+	{0x5300,0xc5},//CIP, m_bColorEdgeEnable, m_bAntiAliasing, m_nDetailSlop=0, m_nNoiseYSlop=5					 
+	{0x5301,0xa0},//m_nSharpenSlope=1, m_nGbGrShift=0															 
+	{0x5302,0x06},//m_nNoiseList[0] 																			 
+	{0x5303,0x0a},//m_nNoiseList[1] 																			 
+	{0x5304,0x30},//m_nNoiseList[2] 																			 
+	{0x5305,0x60},//m_nNoiseList[3] 																			 
+	{0x5306,0x90},//m_nNoiseList[4] 																			 
+	{0x5307,0xc0},//m_nNoiseList[5] 																			 
+	{0x5308,0x82},//m_nMaxSharpenGain=8, m_nMinSharpenGain=2													 
+	{0x5309,0x00},//m_nMinSharpen																				 
+	{0x530a,0x26},//m_nMaxSharpen																				 
+	{0x530b,0x02},//m_nMinDetail																				 
+	{0x530c,0x02},//m_nMaxDetail																				 
+	{0x530d,0x00},//m_nDetailRatioList[0]																		 
+	{0x530e,0x0c},//m_nDetailRatioList[1]																		 
+	{0x530f,0x14},//m_nDetailRatioList[2]																		 
+	{0x5310,0x1a},//m_nSharpenNegEdgeRatio																		 
+	{0x5311,0x20},//m_nClrEdgeShpT1 																			 
+	{0x5312,0x80},//m_nClrEdgeShpT2 																			 
+	{0x5313,0x4b},//m_nClrEdgeShpSlope																			 
+	{0x5380,0x01},//nCCM_D[0][0] H																				 
+	{0x5381,0x0c},//nCCM_D[0][0] L																				 
+	{0x5382,0x00},//nCCM_D[0][1] H																				 
+	{0x5383,0x16},//nCCM_D[0][1] L																				 
+	{0x5384,0x00},//nCCM_D[1][0] H																				 
+	{0x5385,0xb3},//nCCM_D[1][0] L																				 
+	{0x5386,0x00},//nCCM_D[1][1] H																				 
+	{0x5387,0x7e},//nCCM_D[1][1] L																				 
+	{0x5388,0x00},//nCCM_D[2][0] H																				 
+	{0x5389,0x07},//nCCM_D[2][0] L																				 
+	{0x538a,0x01},//nCCM_D[2][1] H																				 
+	{0x538b,0x35},//nCCM_D[2][1] L																				 
+	{0x538c,0x00},//sign bit of nCCM_D[2][1], [2][0], [1][1], [1][0], [0][1], [0][0]							 
+	{0x5400,0x0d},//Gamma, m_pCurveYlist[0] 																	 
+	{0x5401,0x18},//m_pCurveYlist[1]																			 
+	{0x5402,0x31},//m_pCurveYlist[2]																			 
+	{0x5403,0x5a},//m_pCurveYlist[3]																			 
+	{0x5404,0x65},//m_pCurveYlist[4]																			 
+	{0x5405,0x6f},//m_pCurveYlist[5]																			 
+	{0x5406,0x77},//m_pCurveYlist[6]																			 
+	{0x5407,0x80},//m_pCurveYlist[7]																			 
+	{0x5408,0x87},//m_pCurveYlist[8]																			 
+	{0x5409,0x8f},//m_pCurveYlist[9]																			 
+	{0x540a,0xa2},//m_pCurveYlist[10]																			 
+	{0x540b,0xb2},//m_pCurveYlist[11]																			 
+	{0x540c,0xcc},//m_pCurveYlist[12]																			 
+	{0x540d,0xe4},//m_pCurveYlist[13]																			 
+	{0x540e,0xf0},//m_pCurveYlist[14]																			 
+	{0x540f,0xa0},//m_nMaxShadowHGain																			 
+	{0x5410,0x6e},//m_nMidTondHGain 																			 
+	{0x5411,0x06},//m_nHighLightGain																			 
+	{0x5480,0x19},//RGB_DNS, m_nShadowExtraNoise = 12, m_bSmoothYEnable 										 
+	{0x5481,0x00},//m_nNoiseYList[1], m_nNoiseYList[0]															 
+	{0x5482,0x09},//m_nNoiseYList[3], m_nNoiseYList[2]															 
+	{0x5483,0x12},//m_nNoiseYList[5], m_nNoiseYList[4]															 
+	{0x5484,0x04},//m_nNoiseUVList[0]																			 
+	{0x5485,0x06},//m_nNoiseUVList[1]																			 
+	{0x5486,0x08},//m_nNoiseUVList[2]																			 
+	{0x5487,0x0c},//m_nNoiseUVList[3]																			 
+	{0x5488,0x10},//m_nNoiseUVList[4]																			 
+	{0x5489,0x18},//m_nNoiseUVList[5]																			 
+	{0x5500,0x02},//UV_DNS, m_nNoiseList[0] 																	 
+	{0x5501,0x03},//m_nNoiseList[1] 																			 
+	{0x5502,0x04},//m_nNoiseList[2] 																			 
+	{0x5503,0x05},//m_nNoiseList[3] 																			 
+	{0x5504,0x06},//m_nNoiseList[4] 																			 
+	{0x5505,0x08},//m_nNoiseList[5] 																			 
+	{0x5506,0x00},//m_nShadowExtraNoise = 0 																	 
+	{0x5600,0x06},//SDE, saturation_en, contrast_en 															 
+	{0x5603,0x40},//sat u																						 
+	{0x5604,0x28},//sat v																						 
+	{0x5609,0x20},//uvadjust_th1																				 
+	{0x560a,0x60},//uvadjust_th2																				 
+	{0x560b,0x00},//uvadjust_auto																				 
+	{0x5780,0x3e},//DPC 																						 
+	{0x5781,0x0f},																								 
+	{0x5782,0x04},																								 
+	{0x5783,0x02},																								 
+	{0x5784,0x01},																								 
+	{0x5785,0x01},																								 
+	{0x5786,0x00},																								 
+	{0x5787,0x04},																								 
+	{0x5788,0x02},																								 
+	{0x5789,0x00},																								 
+	{0x578a,0x01},																								 
+	{0x578b,0x02},																								 
+	{0x578c,0x03},																								 
+	{0x578d,0x03},																								 
+	{0x578e,0x08},																								 
+	{0x578f,0x0c},																								 
+	{0x5790,0x08},																								 
+	{0x5791,0x04},																								 
+	{0x5792,0x00},																								 
+	{0x5793,0x00},																								 
+	{0x5794,0x03},//DPC 																						 
+	{0x5800,0x03},//Lenc, red x H																				 
+	{0x5801,0x14},//red x L 																					 
+	{0x5802,0x02},//red y H 																					 
+	{0x5803,0x64},//red y L 																					 
+	{0x5804,0x1e},//red_a1																						 
+	{0x5805,0x05},//red_a2																						 
+	{0x5806,0x2a},//red_b1																						 
+	{0x5807,0x05},//red_b2																						 
+	{0x5808,0x03},//green x H																					 
+	{0x5809,0x17},//green x L																					 
+	{0x580a,0x02},//green y H																					 
+	{0x580b,0x63},//green y L																					 
+	{0x580c,0x1a},//green a1																					 
+	{0x580d,0x05},//green a2																					 
+	{0x580e,0x1f},//green b1																					 
+	{0x580f,0x05},//green b2																					 
+	{0x5810,0x03},//blue x H																					 
+	{0x5811,0x0c},//blue x L																					 
+	{0x5812,0x02},//blue y H																					 
+	{0x5813,0x5e},//blue Y L																					 
+	{0x5814,0x18},//blue a1 																					 
+	{0x5815,0x05},//blue a2 																					 
+	{0x5816,0x19},//blue b1 																					 
+	{0x5817,0x05},//blue b2 																					 
+	{0x5818,0x0d},//rst_seed, rnd_en, gcoef_en																	 
+	{0x5819,0x40},//lenc_coef_th																				 
+	{0x581a,0x04},//lenc_gain_thre1 																			 
+	{0x581b,0x0c},//lenc_gain__thre2																			 
+	{0x3106,0x21},//byp_arb 																					 
+	{0x3784,0x08},																								 
+	//AEC GC																								 
+	{0x3a03,0x4c},//AEC H																						 
+	{0x3a04,0x40},//AEC L																						 
+	{0x3503,0x00},//AEC auto, AGC auto																			 
+	{0x3a02,0x90},//50Hz, speed ratio = 0x10	
+	{0x382D,0x03},
+	{0x0100,0x01},//stream on																					 
+   										  
+  	
+    ENDMARKER,
+};
+
+
+
+
+/* 800*600: SVGA */
+static const struct regval_list module_svga_regs[] = 
+{
+	
+	#if 1
+	{0x3503,0x00},// AGC on, AEC on 				  
+	{0x3086,0x01},// PLL							  
+	{0x370a,0x23},// Sensor Conrol					  
+	{0x3801,0x00},// x start L						  
+	{0x3803,0x00},// y start L						  
+	{0x3804,0x06},// x end H						  
+	{0x3805,0x4f},// x end L						  
+	{0x3806,0x04},// y end H						  
+	{0x3807,0xbf},// y end L						  
+	{0x3808,0x03},// x output size H				  
+	{0x3809,0x20},// x output size L				  
+	{0x380a,0x02},// y output size H				  
+	{0x380b,0x58},// y output size L				  
+	{0x380c,0x06},// HTS H							  
+	{0x380d,0xac},// HTS L							  
+	{0x380e,0x02},// VTS H							  
+	{0x380f,0x84},// VTS L							  
+	{0x3811,0x04},// isp x win L					  
+	{0x3813,0x04},// isp y win L					  
+	{0x3814,0x31},// x inc							  
+	{0x3815,0x31},// y inc							  
+	{0x3820,0xc2},// vsub48_blc, vflip_blc, vbinf	  
+	{0x3821,0x01},// hbin							  
+	{0x3a07,0xc2},// B50 L							  
+	{0x3a09,0xa1},// B60 L							  
+	{0x3a0a,0x07},// max exp 50 H					  
+	{0x3a0b,0x94},// max exp 50 L					  
+	{0x3a0c,0x07},// max exp 60 H					  
+	{0x3a0d,0x94},// max exp 60 L					  
+	{0x3a0e,0x02},// VTS band 50 H					  
+	{0x3a0f,0x46},// VTS band 50 L					  
+	{0x3a10,0x02},// VTS band 60 H					  
+	{0x3a11,0x84},// VTS band 60 L					  
+	{0x4008,0x00},// bl_start						  
+	{0x4009,0x03},// bl_end 	
+	#endif
+	#if 0
+	{0x3503,0x00},// AGC on, AEC on 			   
+	{0x3086,0x03},// PLL						   
+	{0x370a,0x23},// Sensor Conrol				   
+	{0x3801,0x00},// x start L					   
+	{0x3803,0x00},// y start L					   
+	{0x3804,0x06},// x end H					   
+	{0x3805,0x4f},// x end L					   
+	{0x3806,0x04},// y end H					   
+	{0x3807,0xbf},// y end L					   
+	{0x3808,0x03},// x output size H			   
+	{0x3809,0x20},// x output size L			   
+	{0x380a,0x02},// y output size H			   
+	{0x380b,0x58},// y output size L			   
+	{0x380c,0x06},// HTS H						   
+	{0x380d,0xac},// HTS L						   
+	{0x380e,0x02},// VTS H						   
+	{0x380f,0x84},// VTS L						   
+	{0x3811,0x04},// isp x win L				   
+	{0x3813,0x04},// isp y win L				   
+	{0x3814,0x31},// x inc						   
+	{0x3815,0x31},// y inc						   
+	{0x3820,0xc2},// vsub48_blc, vflip_blc, vbinf  
+	{0x3821,0x01},// hbin						   
+	{0x3a07,0xc2},// B50 L						   
+	{0x3a09,0xa1},// B60 L						   
+	{0x3a0a,0x07},// max exp 50 H				   
+	{0x3a0b,0x94},// max exp 50 L				   
+	{0x3a0c,0x07},// max exp 60 H				   
+	{0x3a0d,0x94},// max exp 60 L				   
+	{0x3a0e,0x02},// VTS band 50 H				   
+	{0x3a0f,0x46},// VTS band 50 L				   
+	{0x3a10,0x02},// VTS band 60 H				   
+	{0x3a11,0x84},// VTS band 60 L				   
+	{0x4008,0x00},// bl_start					   
+	{0x4009,0x03},// bl_end 
+	#endif
+    ENDMARKER,
+};
+
+
+
+/* 1280*720: 720P*/
+static const struct regval_list module_720p_regs[] = 
+{
+	
+	{0x3503,0x00},// AGC on, AEC on 		
+	{0x3086,0x01},// PLL					
+	{0x370a,0x21},// Sensor Conrol			
+	{0x3801,0xa0},// x start L				
+	{0x3803,0xf2},// y start L				
+	{0x3804,0x05},// x end H				
+	{0x3805,0xaf},// x end L				
+	{0x3806,0x03},// y end H				
+	{0x3807,0xcd},// y end L				
+	{0x3808,0x05},// x output size H		
+	{0x3809,0x00},// x output size L		
+	{0x380a,0x02},// y output size H		
+	{0x380b,0xd0},// y output size L		
+	{0x380c,0x05},// HTS H					
+	{0x380d,0xa6},// HTS L					
+	{0x380e,0x02},// VTS H					
+	{0x380f,0xf8},// VTS L					
+	{0x3811,0x08},// isp x win L			
+	{0x3813,0x06},// isp y win L			
+	{0x3814,0x11},// x inc					
+	{0x3815,0x11},// y inc					
+	{0x3820,0xc0},// vsub48_blc, vflip_blc	
+	{0x3821,0x00},// hbin off				
+	{0x3a07,0xe4},// B50 L					
+	{0x3a09,0xbd},// B60 L					
+	{0x3a0a,0x0e},// max exp 50 H			
+	{0x3a0b,0x40},// max exp 50 L			
+	{0x3a0c,0x17},// max exp 60 H			
+	{0x3a0d,0xc0},// max exp 60 L			
+	{0x3a0e,0x02},// VTS band 50 H			
+	{0x3a0f,0xac},// VTS band 50 L			
+	{0x3a10,0x02},// VTS band 60 H			
+	{0x3a11,0xf8},// VTS band 60 L			
+	{0x4008,0x02},// bl_start				
+	{0x4009,0x09},// bl_end 				
+							  
+	 ENDMARKER,
+};
+
+
+
+/* 1600X1200 UXGA */
+static const struct regval_list module_uxga_regs[] = 
+{
+	{0x3503,0x03},// AEC off, AGC off		
+	{0x3086,0x01},// PLL					
+	{0x370a,0x21},// Sensor Conrol			
+	{0x3801,0x00},// x start L				
+	{0x3803,0x00},// y start L				
+	{0x3804,0x06},// x end H				
+	{0x3805,0x4f},// x end L				
+	{0x3806,0x04},// y end H				
+	{0x3807,0xbf},// y end L				
+	{0x3808,0x06},// x output size H		
+	{0x3809,0x40},// x output size L		
+	{0x380a,0x04},// y output size H		
+	{0x380b,0xb0},// y output size L		
+	{0x380c,0x06},// HTS H					
+	{0x380d,0xa4},// HTS L					
+	{0x380e,0x05},// VTS H					
+	{0x380f,0x0e},// VTS L					
+	{0x3811,0x08},// isp x win L			
+	{0x3813,0x08},// isp y win L			
+	{0x3814,0x11},// x inc					
+	{0x3815,0x11},// y inc					
+	{0x3820,0xc0},// vsub48_blc, vflip_blc	
+	{0x3821,0x00},// hbin off				
+	{0x3a07,0xc2},// B50 L					
+	{0x3a09,0xa1},// B60 L					
+	{0x3a0a,0x0f},// max exp 50 H			
+	{0x3a0b,0x28},// max exp 50 L			
+	{0x3a0c,0x0f},// max exp 60 H			
+	{0x3a0d,0x28},// max exp 60 L			
+	{0x3a0e,0x04},// VTS band 50 H			
+	{0x3a0f,0x8c},// VTS band 50 L			
+	{0x3a10,0x05},// VTS band 60 H			
+	{0x3a11,0x08},// VTS band 60 L			
+	{0x4008,0x02},// bl_start				
+	{0x4009,0x09},// bl_end 				
+							   
+     ENDMARKER,
+};
+
+
+
+
+static const struct regval_list module_init_auto_focus[] =
+{
+//  NULL
+ENDMARKER,
+
+};
+
+/* 640*480 */
+static struct camera_module_win_size module_win_svga = {
+	.name             = "SVGA",
+	.width            = WIDTH_SVGA,
+	.height           = HEIGHT_SVGA,
+	.win_regs         = module_svga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+/* 1280*720 */
+static struct camera_module_win_size module_win_720p = {
+	.name             = "720P",
+	.width            = WIDTH_720P,
+	.height           = HEIGHT_720P,
+	.win_regs         = module_720p_regs,
+	
+	.frame_rate_array = frame_rate_720p,
+	.capture_only     = 0,
+};
+
+/* 1600*1200 */
+static struct camera_module_win_size module_win_uxga = {
+	.name             = "UXGA",
+	.width            = WIDTH_UXGA,
+	.height           = HEIGHT_UXGA,
+	.win_regs         = module_uxga_regs,
+	
+	.frame_rate_array = frame_rate_uxga,
+	.capture_only     = 1,
+};
+
+
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_svga,
+	&module_win_720p,
+	&module_win_uxga,
+};
+
+
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+	
+	{0x3208,0x00},// start group 1	  
+	{0x5180,0xf4},					  
+	{0x3208,0x10},// end group 1	  
+	{0x3208,0xa0},// launch group 1   
+	
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	
+	
+	
+	{0x3208,0x00},// start group 1	   
+	{0x5180,0xf6},//				   
+	{0x5195,0x07},//R Gain			   
+	{0x5196,0xdc},//				   
+	{0x5197,0x04},//G Gain			   
+	{0x5198,0x00},//				   
+	{0x5199,0x05},//B Gain			   
+	{0x519a,0xd3},//				   
+	{0x3208,0x10},// end group 1	   
+	{0x3208,0xa0},// launch group 1    
+	
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+	
+	{0x3208,0x00},// start group 1 
+	{0x5180,0xf6},//			   
+	{0x5195,0x07},//R Gain		   
+	{0x5196,0x9c},//			   
+	{0x5197,0x04},//G Gain		   
+	{0x5198,0x00},//			   
+	{0x5199,0x05},//B Gain		   
+	{0x519a,0xf3},//			   
+	{0x3208,0x10},// end group 1   
+	{0x3208,0xa0},// launch group 1
+    ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+	
+	{0x3208,0x00},// start group 1	
+	{0x5180,0xf6},//				
+	{0x5195,0x06},//R Gain			
+	{0x5196,0xb8},//				
+	{0x5197,0x04},//G Gain			
+	{0x5198,0x00},//				
+	{0x5199,0x06},//B Gain			
+	{0x519a,0x5f},//				
+	{0x3208,0x10},// end group 1	
+	{0x3208,0xa0},// launch group 1 
+	
+    ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	
+	{0x3208,0x00},// start group 1	 
+	{0x5180,0xf6},//				 
+	{0x5195,0x04},//R Gain			 
+	{0x5196,0x90},//				 
+	{0x5197,0x04},//G Gain			 
+	{0x5198,0x00},//				 
+	{0x5199,0x09},//B Gain			 
+	{0x519a,0x20},//				 
+	{0x3208,0x10},// end group 1	 
+	{0x3208,0xa0},// launch group 1  
+	
+	ENDMARKER,
+};
+
+
+static struct regval_list module_scene_auto_regs[] =
+{
+	ENDMARKER,
+};
+
+/*
+ * The exposure target setttings
+ */
+
+static struct regval_list module_exp_comp_pos4_regs[] = {
+	{0x3a03,0x66},	 
+	{0x3a04,0x62},	
+	ENDMARKER,
+
+};
+
+
+static struct regval_list module_exp_comp_pos3_regs[] = {
+	{0x3a03,0x62},	 
+	{0x3a04,0x58},	
+	ENDMARKER,
+
+};
+
+static struct regval_list module_exp_comp_pos2_regs[] = {
+	{0x3a03,0x5a},	 
+	{0x3a04,0x50},
+	ENDMARKER,
+
+};
+
+static struct regval_list module_exp_comp_pos1_regs[] = {
+	{0x3a03,0x54},	 
+	{0x3a04,0x48},	
+	ENDMARKER,
+
+};
+
+static struct regval_list module_exp_comp_zero_regs[] = {
+	{0x3a03,0x4e},	 
+	{0x3a04,0x40},  
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg1_regs[] = {
+	{0x3a03,0x44},	 
+	{0x3a04,0x38},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg2_regs[] = {
+	{0x3a03,0x3c},	 
+	{0x3a04,0x30},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg3_regs[] = {
+	{0x3a03,0x34},	 
+	{0x3a04,0x28},
+	ENDMARKER,
+};
+static struct regval_list module_exp_comp_neg4_regs[] = {
+	{0x3a03,0x28},	 
+	{0x3a04,0x24},
+	ENDMARKER,
+};
+
+
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{   .id = V4L2_CID_EXPOSURE, 
+		.min = 0, 
+		.max = 975,
+		.step = 1, 
+		.def = 500,
+	},
+	{	.id = V4L2_CID_EXPOSURE_COMP, 
+		.min = -4, 
+		.max = 4, 
+		.step = 1, 
+		.def = 0,
+	},	
+	{	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,
+	},
+	{
+        .id = V4L2_CID_AUTO_WHITE_BALANCE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 1,
+    },
+    {
+        .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+        .min = 0,
+        .max = 3,
+        .step = 1,
+        .def = 0,
+    },
+
+    {
+        .id = V4L2_CID_HFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_VFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+     {	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+     {	.id = V4L2_CID_AF_MODE,
+		.min = NONE_AF, 
+		.max = CONTINUE_AF|SINGLE_AF, 
+		.step = 1, 
+		.def = NONE_AF,},
+    {	.id = V4L2_CID_AF_STATUS, 
+		.min = AF_STATUS_DISABLE, 
+		.max = AF_STATUS_FAIL, 
+		.step = 1, 
+		.def = AF_STATUS_DISABLE,},
+	 {	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	 {
+        .id = V4L2_CID_COLORFX,
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_EXPOSURE_AUTO,
+        .max = 1,
+        .mask = 0x0,
+        .def = 1,
+    },
+	{  
+		   .id = V4L2_CID_SCENE_MODE, 
+		   .max = V4L2_SCENE_MODE_TEXT, 
+		   .mask = 0x0, 
+		   .def = 0,
+	},
+
+    {	.id = V4L2_CID_FLASH_LED_MODE, 
+		.max = 3,
+		.mask = 0x0,
+		.def = 0,},  
+	 {
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/ov2686/ov2686.c b/drivers/media/i2c/camera/ov2686/ov2686.c
new file mode 100755
index 0000000..cf2b175
--- /dev/null
+++ b/drivers/media/i2c/camera/ov2686/ov2686.c
@@ -0,0 +1,505 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include"../module_comm/camera_chip_ident.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+
+
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = (reg & 0xff00) >> 8;
+    regs_array[1] =  reg & 0x00ff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = (reg & 0xff00) >> 8;
+    regs_array[1] =  reg & 0x00ff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0)
+			{
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+			}
+		vals++;
+	}
+	return 0;
+}
+
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret = 0;
+	ret |= camera_i2c_write(client->adapter, 0x0103, 0x01);
+	return ret;
+}
+
+
+
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int scene_exposure = ctrl->val;
+	int ret = 0;
+
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_NIGHT:  //\CA\D2\C4\DA
+		
+		break;
+
+	case V4L2_SCENE_MODE_SUNSET:	//\CA\D2\CD\E2
+		
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+	
+	return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_save_exposure_param\n ");
+	return ret;
+}
+
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	//int auto_white_balance = ctrl->val;
+	int ret = 0;
+	
+	int auto_white_balance;
+		if(ctrl)
+			{
+			auto_white_balance = ctrl->val;
+		}
+		else 
+			{
+				auto_white_balance = 1;
+			}
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		{
+	ctrl->cur.val = auto_white_balance;
+		}
+
+	return ret;
+}
+
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	switch(ctrl->val){
+		case 4:
+			camera_write_array(client->adapter,module_exp_comp_pos4_regs);
+			break;
+		case 3:
+			camera_write_array(client->adapter,module_exp_comp_pos3_regs);
+			break;
+		case 2:
+			camera_write_array(client->adapter,module_exp_comp_pos2_regs);
+			break;
+		case 1:
+			camera_write_array(client->adapter,module_exp_comp_pos1_regs);
+			break;
+		case 0:
+			camera_write_array(client->adapter,module_exp_comp_zero_regs);
+			break;
+		case -1:
+			camera_write_array(client->adapter,module_exp_comp_neg1_regs);
+			break;
+		case -2:
+			camera_write_array(client->adapter,module_exp_comp_neg2_regs);
+			break;
+		case -3:
+			camera_write_array(client->adapter,module_exp_comp_neg3_regs);
+			break;
+		case -4:
+			camera_write_array(client->adapter,module_exp_comp_neg4_regs);
+		break;
+		default:
+			break;		
+	}
+	
+	return ret;
+}
+
+
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int reg_0x3500, reg_0x3501,reg_0x3502;
+	
+	int ret = 0;
+	
+	ret |= camera_i2c_read(client->adapter, 0x3500, &reg_0x3500);
+	ret |= camera_i2c_read(client->adapter, 0x3501, &reg_0x3501);
+	ret |= camera_i2c_read(client->adapter, 0x3502, &reg_0x3502);
+
+	
+	ctrl->val = (reg_0x3500<<16) + (reg_0x3501 << 4) + (reg_0x3502 >> 4);
+	return ret;
+	
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int reg_350a,reg_350b;
+	int ret = 0;
+	reg_350a = 0;
+	ret = camera_i2c_read(client->adapter, 0x350a, &reg_350a);
+	reg_350b = 0;
+	ret = camera_i2c_read(client->adapter, 0x350a, &reg_350b);
+	ctrl->val = ((reg_350a&0x3)<<8) + reg_350b;
+
+	return ret;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int tmp = 0;
+	int ret = 0;
+	ctrl->val = ctrl->val & 0x3ff;
+	tmp = ctrl->val & 0xff;
+	ret |= camera_i2c_write(client->adapter, 0x350b, tmp);
+	tmp = ctrl->val >> 8;
+	ret |= camera_i2c_write(client->adapter, 0x350a, tmp);
+	return ret;
+}
+
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_set_exposure_param\n ");
+	return ret;
+}
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+   // int exposure_auto = ctrl->val;
+	int ret = 0;
+	
+	int exposure_auto;
+		if(ctrl)
+			{
+			exposure_auto = ctrl->val;
+			}
+		else 
+			{
+				exposure_auto = V4L2_EXPOSURE_AUTO;
+			}
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		{
+	ctrl->cur.val = exposure_auto;
+		}
+
+	return 0;
+}
+
+
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	
+	int ret = 0;
+	   if (!enable) {
+		   GC_INFO("stream down");
+			return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	  return ret;
+}
+
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+
+
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	
+	int ret = 0;
+	
+	return ret;
+}
+
+
+
+
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	int ret = 0;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		
+		break;
+		
+	default:
+		return -ERANGE;
+	}
+	
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+
+{
+	int ret = 0;
+	
+	return ret;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	int ret = 0;
+	unsigned int pidh,pidl;
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	camera_i2c_read(i2c_adap, PIDH, &pidh);
+    camera_i2c_read(i2c_adap, PIDL, &pidl);
+	switch (VERSION(pidh, pidl)) 
+    {
+	case CAMERA_MODULE_PID:
+		if(priv)
+			{
+		     priv->model= V4L2_IDENT_OV2686;
+			}
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, VERSION(pidh, pidl));
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, VERSION(pidh, pidl));
+		return -ENODEV;
+	}
+	return ret;
+}
+
+
+
diff --git a/drivers/media/i2c/camera/ov5640/Kconfig b/drivers/media/i2c/camera/ov5640/Kconfig
new file mode 100755
index 0000000..62dd919
--- /dev/null
+++ b/drivers/media/i2c/camera/ov5640/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config OV5640
+	tristate "ov5640 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for ov5640 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ov5640.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/ov5640/Makefile b/drivers/media/i2c/camera/ov5640/Makefile
new file mode 100755
index 0000000..1471b4d
--- /dev/null
+++ b/drivers/media/i2c/camera/ov5640/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_OV5640)	+= ov5640.o
+
diff --git a/drivers/media/i2c/camera/ov5640/module_diff.h b/drivers/media/i2c/camera/ov5640/module_diff.h
new file mode 100755
index 0000000..98b9a90
--- /dev/null
+++ b/drivers/media/i2c/camera/ov5640/module_diff.h
@@ -0,0 +1,5416 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+
+#define CAMERA_MODULE_NAME 		"ov5640"
+#define CAMERA_MODULE_PID		0x5640
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_I2C_REAL_ADDRESS  (0x78 >> 1)
+#define MODULE_I2C_REG_ADDRESS		(0x78)
+
+#define I2C_REGS_WIDTH			2
+#define I2C_DATA_WIDTH			1
+//#define IS_FRONT_OR_REAR        0
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_LOW
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_FALLING
+
+
+
+
+#if 0
+#define PID						0x00 /* Product ID Number */
+#else
+#define PIDH					0x300a /* Product ID Number H byte */
+#define PIDL					0x300b /* Product ID Number L byte */
+#endif
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA
+#define MODULE_MAX_WIDTH		WIDTH_QSXGA
+#define MODULE_MAX_HEIGHT		HEIGHT_QSXGA
+
+
+#define AHEAD_LINE_NUM			15    //10? = 50???
+#define DROP_NUM_CAPTURE		3
+#define DROP_NUM_PREVIEW		3
+static unsigned int frame_rate_vga[]   = {30,};
+static unsigned int frame_rate_720p[]  = {30,};
+static unsigned int frame_rate_1080p[] = {30,};
+static unsigned int frame_rate_uxga[] = {15,};
+
+static unsigned int frame_rate_qsxga[] = {7,};
+
+
+
+static const struct regval_list module_init_regs[] =
+{ // {0x3103, 0x11},
+    // {0x3008, 0x82},
+    {0x3008, 0x42},
+    {0x3103, 0x03},
+    {0x3017, 0x7f},
+    {0x3018, 0xff},
+
+    //{0x3031,0x08},//inner regulator
+    {0x302c, 0xc2},
+
+    {0x3108, 0x01},
+    {0x3630, 0x36},
+    {0x3631, 0x0e},
+    {0x3632, 0xe2},
+    {0x3633, 0x12},
+    {0x3621, 0xe0},
+    {0x3704, 0xa0},
+    {0x3703, 0x5a},
+    {0x3715, 0x78},
+    {0x3717, 0x01},
+    {0x370b, 0x60},
+    {0x3705, 0x1a},
+    {0x3905, 0x02},
+    {0x3906, 0x10},
+    {0x3901, 0x0a},
+    {0x3731, 0x12},
+    {0x3600, 0x08},
+    {0x3601, 0x33},
+    {0x302d, 0x60},
+    {0x3620, 0x52},
+    {0x371b, 0x20},
+    {0x471c, 0x50},
+
+    {0x3a13, 0x43},
+    {0x3a18, 0x00},
+    {0x3a19, 0xf8},
+
+    {0x3635, 0x13},
+    {0x3636, 0x03},
+    {0x3634, 0x40},
+    {0x3622, 0x01},
+
+    {0x3c04, 0x28},
+    {0x3c05, 0x98},
+    {0x3c06, 0x00},
+    {0x3c07, 0x08},
+    {0x3c08, 0x00},
+    {0x3c09, 0x1c},
+    {0x3c0a, 0x9c},
+    {0x3c0b, 0x40},
+
+    {0x3820, 0x41},
+    {0x3821, 0x07},
+
+    {0x3800, 0x00},
+    {0x3801, 0x00},
+    {0x3802, 0x00},
+    {0x3803, 0x04},
+    {0x3804, 0x0a},
+    {0x3805, 0x3f},
+    {0x3806, 0x07},
+    {0x3807, 0x9b},
+    {0x3808, 0x02},     //640x480
+    {0x3809, 0x80},
+    {0x380a, 0x01},
+    {0x380b, 0xe0},
+    {0x3810, 0x00},
+    {0x3811, 0x10},
+    {0x3812, 0x00},
+    {0x3813, 0x06},
+    {0x3814, 0x31},
+    {0x3815, 0x31},
+
+    {0x3034, 0x1a},
+    {0x3035, 0x11},
+    {0x3036, 0x46},
+    {0x3037, 0x13},
+
+    {0x380c, 0x07},
+    {0x380d, 0x68},
+    {0x380e, 0x03},
+    {0x380f, 0xd0},
+
+    {0x3c01, 0xb4},
+    {0x3c00, 0x04},
+    {0x3a08, 0x01},
+    {0x3a09, 0x27},
+    {0x3a0e, 0x03},
+    {0x3a0a, 0x00},
+    {0x3a0b, 0xf6},
+    {0x3a0d, 0x04},
+
+    {0x3a00, 0x38},     //30fps-10fps
+    {0x3a02, 0x0b},
+    {0x3a03, 0x88},
+    {0x3a14, 0x0b},
+    {0x3a15, 0x88},
+
+    {0x3618, 0x00},
+    {0x3612, 0x29},
+    {0x3708, 0x64},
+    {0x3709, 0x52},
+    {0x370c, 0x03},
+
+    {0x4001, 0x02},
+    {0x4004, 0x02},
+    {0x3000, 0x00},
+    {0x3002, 0x1c},
+    {0x3004, 0xff},
+    {0x3006, 0xc3},
+    {0x300e, 0x58},
+    {0x302e, 0x00},
+    {0x4300, 0x32},
+    {0x501f, 0x00},
+    {0x4713, 0x03},
+    {0x4407, 0x04},
+    {0x440e, 0x00},
+    {0x460b, 0x35},
+    {0x460c, 0x22},
+    {0x4837, 0x22},
+    {0x3824, 0x02},
+    {0x5001, 0xa3},
+	//awb
+	{0x5180, 0xff},
+	{0x5181, 0xf2},
+	{0x5182, 0x00},
+	{0x5183, 0x14},
+	{0x5184, 0x25},
+	{0x5185, 0x24},
+	{0x5186, 0x16},
+	{0x5187, 0x16},
+	{0x5188, 0x16},
+	{0x5189, 0x72},
+	{0x518a, 0x68},
+	{0x518b, 0xe0},
+	{0x518c, 0xb2},
+	{0x518d, 0x42},
+	{0x518e, 0x3e},
+	{0x518f, 0x4c},
+	{0x5190, 0x56},
+	{0x5191, 0xf8},
+	{0x5192, 0x04},
+	{0x5193, 0x70},
+	{0x5194, 0xf0},
+	{0x5195, 0xf0},
+	{0x5196, 0x03},
+	{0x5197, 0x01},     // local limit
+	{0x5198, 0x04},
+	{0x5199, 0x12},
+	{0x519a, 0x04},
+	{0x519b, 0x00},
+	{0x519c, 0x06},
+	{0x519d, 0x82},
+	{0x519e, 0x38},
+
+	//color matrix
+	{0x5381, 0x1e},
+	{0x5382, 0x5b},
+	{0x5383, 0x12},
+	{0x5384, 0x0d},
+	{0x5385, 0x7e},
+	{0x5386, 0x8d},
+	{0x5387, 0x78},
+	{0x5388, 0x68},
+	{0x5389, 0x10},
+	{0x538a, 0x01},
+	{0x538b, 0x98},
+
+
+
+	//gamma
+	{0x5480, 0x01},
+	{0x5481, 0x06},
+	{0x5482, 0x12},
+	{0x5483, 0x24},
+	{0x5484, 0x4a},
+	{0x5485, 0x58},
+	{0x5486, 0x65},
+	{0x5487, 0x72},
+	{0x5488, 0x7d},
+	{0x5489, 0x88},
+	{0x548a, 0x92},
+	{0x548b, 0xa3},
+	{0x548c, 0xb2},
+	{0x548d, 0xc8},
+	{0x548e, 0xdd},
+	{0x548f, 0xf0},
+	{0x5490, 0x15},
+
+
+	//sharpness and noise 
+	{0x5300, 0x08},
+	{0x5301, 0x30},
+	{0x5302, 0x28},
+	{0x5303, 0x10},
+	{0x5304, 0x08},
+	{0x5305, 0x30},
+	{0x5306, 0x08},
+	{0x5307, 0x18},
+	{0x5309, 0x08},
+	{0x530a, 0x30},
+	{0x530b, 0x04},
+	{0x530c, 0x06},
+
+	//UV adjust
+	{0x5580, 0x06},
+	{0x5583, 0x40},
+	{0x5584, 0x20},
+	{0x5589, 0x10},
+	{0x558a, 0x00},
+	{0x558b, 0xf8},
+
+	//lens shading
+	{0x5000, 0xa7},
+	{0x5800, 0x1f},
+	{0x5801, 0x11},
+	{0x5802, 0xe },
+	{0x5803, 0xe },
+	{0x5804, 0x11},
+	{0x5805, 0x23},
+	{0x5806, 0xc },
+	{0x5807, 0x9 },
+	{0x5808, 0x5 },
+	{0x5809, 0x5 },
+	{0x580a, 0x8 },
+	{0x580b, 0xe },
+	{0x580c, 0x8 },
+	{0x580d, 0x3 },
+	{0x580e, 0x0 },
+	{0x580f, 0x0 },
+	{0x5810, 0x3 },
+	{0x5811, 0xa },
+	{0x5812, 0x9 },
+	{0x5813, 0x4 },
+	{0x5814, 0x0 },
+	{0x5815, 0x1 },
+	{0x5816, 0x4 },
+	{0x5817, 0xb },
+	{0x5818, 0xd },
+	{0x5819, 0xa },
+	{0x581a, 0x7 },
+	{0x581b, 0x7 },
+	{0x581c, 0xa },
+	{0x581d, 0x10},
+	{0x581e, 0x3a},
+	{0x581f, 0x1a},
+	{0x5820, 0x13},
+	{0x5821, 0x13},
+	{0x5822, 0x1a},
+	{0x5823, 0x3e},
+	{0x5824, 0x4c},
+	{0x5825, 0x2a},
+	{0x5826, 0xc },
+	{0x5827, 0x2a},
+	{0x5828, 0x26},
+	{0x5829, 0xa },
+	{0x582a, 0x24},
+	{0x582b, 0x24},
+	{0x582c, 0x24},
+	{0x582d, 0x28},
+	{0x582e, 0x8 },
+	{0x582f, 0x42},
+	{0x5830, 0x40},
+	{0x5831, 0x42},
+	{0x5832, 0x6 },
+	{0x5833, 0xa },
+	{0x5834, 0x24},
+	{0x5835, 0x24},
+	{0x5836, 0x26},
+	{0x5837, 0x28},
+	{0x5838, 0x2c},
+	{0x5839, 0x2c},
+	{0x583a, 0xc },
+	{0x583b, 0x2c},
+	{0x583c, 0x28},
+	{0x583d, 0xce},
+
+    {0x5688, 0x22},
+    {0x5689, 0x22},
+    {0x568a, 0x42},
+    {0x568b, 0x24},
+    {0x568c, 0x42},
+    {0x568d, 0x24},
+    {0x568e, 0x22},
+    {0x568f, 0x22},
+
+    {0x5025, 0x00},
+
+	//EV
+    {0x3a0f, 0x35},
+    {0x3a10, 0x28},
+    {0x3a11, 0x60},
+    {0x3a1b, 0x35},
+    {0x3a1e, 0x28},
+    {0x3a1f, 0x10},
+
+    {0x4005, 0x1a},
+
+    {0x3503, 0x00},
+    {0x3008, 0x02},
+    ENDMARKER,
+};
+
+
+
+
+/* 640*480: VGA */
+static const struct regval_list module_vga_regs[] = 
+{
+
+	{0x3008,0x42},
+    
+    {0x3c07,0x08}, 
+    {0x5189,0x72},
+    
+    {0x3503,0x00}, 
+    {0x3a00,0x3c}, 
+    
+    {0x5302,0x30}, 
+    {0x5303,0x10}, 
+    {0x5306,0x10}, 
+    {0x5307,0x20}, 
+    
+    {0x3820,0x41}, 
+    {0x3821,0x07}, 
+    
+    {0x3800,0x00},
+    {0x3801,0x00},
+    {0x3802,0x00},
+    {0x3803,0x04},
+    {0x3804,0x0a},
+    {0x3805,0x3f},
+    {0x3806,0x07},
+    {0x3807,0x9b},
+    {0x3808,0x02},
+    {0x3809,0x80},
+    {0x380a,0x01},
+    {0x380b,0xe0},
+    {0x3810,0x00},
+    {0x3811,0x10},
+    {0x3812,0x00},
+    {0x3813,0x06},
+    {0x3814,0x31},
+    {0x3815,0x31},
+    
+    {0x3034,0x1a},                
+    {0x3035,0x11},                
+    {0x3036,0x46},                
+    {0x3037,0x13}, 
+    
+    {0x380c,0x07},     
+    {0x380d,0x68},    
+    {0x380e,0x03},     
+    {0x380f,0xd8},          
+          
+    {0x3a08,0x01},
+    {0x3a09,0x27}, 
+    {0x3a0e,0x03},
+    {0x3a0a,0x00}, 
+    {0x3a0b,0xf6},  
+    {0x3a0d,0x04}, 
+    
+    {0x3618,0x00},      
+    {0x3612,0x29},      
+    {0x3709,0x52},      
+    {0x370c,0x03}, 
+    
+    {0x4004,0x02},   
+    {0x3002,0x1c},  
+    {0x3006,0xc3},      
+    {0x3824,0x02},                
+    {0x5001,0xa3},         
+    
+    {0x4713,0x03}, 
+    {0x4407,0x04}, 
+    {0x460b,0x35}, 
+    {0x460c,0x22}, 
+    {0x4837,0x22},   
+    
+    {0x3008,0x02},
+    
+    {0x3023,0x01},  
+    {0x3022,0x04}, 
+    ENDMARKER,
+};
+
+
+
+/* 1280*720: 720P*/
+static const struct regval_list module_720p_regs[] = 
+{
+	  //power down
+	{0x3008,0x42},
+	//pll and clock setting
+	{0x3034,0x18},
+	{0x3035,0x41},	//0x11:60fps 0x21:30fps 0x41:15fps 0xa1:7.5fps
+	{0x3036,0x54},
+	{0x3037,0x13},
+	{0x3108,0x01},
+	{0x3824,0x01},
+	//{0xffff,0x32},//delay 50ms,//delay 100ms
+	//timing
+	//1280x720
+	{0x3808,0x05},	//H size MSB
+	{0x3809,0x00},	//H size LSB
+	{0x380a,0x02},	//V size MSB
+	{0x380b,0xd0},	//V size LSB
+	{0x380c,0x07},	//HTS MSB        
+	{0x380d,0x64},	//HTS LSB   
+	{0x380e,0x02},	//VTS MSB        
+	{0x380f,0xe4},	//LSB       
+	//banding step
+	{0x3a08,0x00}, //50HZ step MSB 
+	{0x3a09,0xdd}, //50HZ step LSB 
+	{0x3a0a,0x00}, //60HZ step MSB 
+	{0x3a0b,0xb8}, //60HZ step LSB 
+	{0x3a0e,0x03}, //50HZ step max 
+	{0x3a0d,0x04}, //60HZ step max 
+	
+	{0x3c07,0x07}, //light meter 1 thereshold   
+	{0x3814,0x31}, //horizton subsample
+	{0x3815,0x31}, //vertical subsample
+	{0x3800,0x00}, //x address start high byte
+	{0x3801,0x00}, //x address start low byte  
+	{0x3802,0x00},	//y address start high byte 
+	{0x3803,0xfa}, //y address start low byte 
+	{0x3804,0x0a}, //x address end high byte
+	{0x3805,0x3f}, //x address end low byte 
+	{0x3806,0x06}, //y address end high byte
+	{0x3807,0xa9}, //y address end low byte 
+	{0x3810,0x00}, //isp hortizontal offset high byte
+	{0x3811,0x10}, //isp hortizontal offset low byte
+	{0x3812,0x00}, //isp vertical offset high byte
+	{0x3813,0x04},	//isp vertical offset low byte
+	
+	{0x5308,0x65},		//sharpen manual
+	{0x5302,0x00},		//sharpen offset 1
+	{0x4002,0x45},		//BLC related
+	{0x4005,0x18},		//BLC related
+	       
+	{0x3618,0x00},
+	{0x3612,0x29},
+	{0x3709,0x52},
+	{0x370c,0x03},
+	{0x3a02,0x02}, //60HZ max exposure limit MSB 
+	{0x3a03,0xe0}, //60HZ max exposure limit LSB 
+	{0x3a14,0x02}, //50HZ max exposure limit MSB 
+	{0x3a15,0xe0}, //50HZ max exposure limit LSB 
+	       
+	{0x4004,0x02}, //BLC line number
+	{0x3002,0x1c}, //reset JFIFO SFIFO JPG
+	{0x3006,0xc3}, //enable xx clock
+	{0x460b,0x37},	//debug mode
+	{0x460c,0x20}, //PCLK Manuale
+	{0x4837,0x16}, //PCLK period
+	{0x5001,0x83}, //ISP effect
+	{0x3503,0x00},//AEC enable
+	
+	{0x302c,0xc2},//bit[7:6]: output drive capability
+					//00: 1x   01: 2x  10: 3x  11: 4x 
+	//power down release
+	{0x3008,0x02},    
+	 ENDMARKER,
+};
+
+
+
+/* 1600X1200 UXGA */
+static const struct regval_list module_uxga_regs[] = 
+{
+	
+	 //capture 2Mega 7.5fps
+   //power down
+ // {0x3008,0x42},
+   //pll and clock setting                                                                                                                        
+   {0x3034,0x18},                                                                                                             
+
+   {0x3035,0x41},                                                                                                                                   
+   {0x3036,0x54},                                                                                                             
+   {0x3037,0x13},                                                                                                             
+   {0x3108,0x01},                                                                                                             
+   {0x3824,0x01},                                                                                                                                                     
+   //timing                                                                                                                             
+   //1600*1200                                                                                                                          
+   {0x3808,0x06}, //H size MSB                                                                                             
+   {0x3809,0x40}, //H size LSB                                                                                             
+   {0x380a,0x04}, //V size MSB                                                                                             
+   {0x380b,0xb0}, //V size LSB                                                                                             
+   {0x380c,0x0b}, //HTS MSB                                                                                                
+   {0x380d,0x1c}, //HTS LSB                                                                                                
+   {0x380e,0x07}, //VTS MSB                                                                                                
+   {0x380f,0xb0}, //LSB                                                                                                    
+ 
+   //banding step                                        
+   {0x3a08,0x00}, //50HZ step MSB                 
+   {0x3a09,0x49}, //50HZ step LSB                 
+   {0x3a0a,0x00}, //60HZ step MSB                 
+   {0x3a0b,0x3d}, //60HZ step LSB                 
+   {0x3a0e,0x1a}, //50HZ step max                 
+   {0x3a0d,0x20}, //60HZ step max                                                                                        
+                                                                                                                                        
+ //  {0x3503,0x07}, //AEC disable                                                                                                                                                                                                                  
+   {0x350c,0x00},                                                                                                                 
+   {0x350d,0x00},                                                                                                                 
+   {0x3c07,0x07}, //light meter 1 thereshold                                                                                      
+                                                                                                                                                                                                                         
+   {0x3814,0x11}, //horizton subsample
+   {0x3815,0x11}, //vertical subsample
+   {0x3800,0x00}, //x address start high byte
+   {0x3801,0x00}, //x address start low byte  
+   {0x3802,0x00},  //y address start high byte 
+   {0x3803,0x00}, //y address start low byte 
+   {0x3804,0x0a}, //x address end high byte
+   {0x3805,0x3f}, //x address end low byte 
+   {0x3806,0x07}, //y address end high byte
+   {0x3807,0x9f}, //y address end low byte 
+   {0x3810,0x00}, //isp hortizontal offset high byte
+   {0x3811,0x10}, //isp hortizontal offset low byte
+   {0x3812,0x00}, //isp vertical offset high byte
+   {0x3813,0x04},  //isp vertical offset low byte 
+                                                                                                                                        
+   {0x4002,0xc5}, //BLC related                                                                                                     
+   {0x4005,0x12}, //BLC related                                                                                        
+ //  {0x5308,0x65},    //sharpen manual
+ //  {0x5302,0x20},//sharpness                                                                                          
+                                                                                                                                                                                                                                        
+   {0x3618,0x04},                                                                                                               
+   {0x3612,0x2b},                                                                                                               
+   {0x3709,0x12},                                                                                                               
+   {0x370c,0x00},                                                                                                               
+   {0x3a02,0x07},//60HZ max exposure limit MSB                                                                                                                  
+   {0x3a03,0xb0},//60HZ max exposure limit LSB                                                                                   
+   {0x3a14,0x07},//50HZ max exposure limit MSB                                                                                   
+   {0x3a15,0xb0},//50HZ max exposure limit LSB                                                                                   
+   {0x4004,0x06},//BLC line number                                                                                               
+                                                                                                                                                                                
+                                                                                                                        
+   {0x4837,0x2c}, //PCLK period                                                                                                  
+   {0x5001,0xa3}, //ISP effect  
+   {0x302c,0xc2},//bit[7:6]: output drive capability     
+     ENDMARKER,
+};
+
+
+/* 1920*1080: 1080P*/
+static const struct regval_list module_1080p_regs[] = 
+{
+	
+	{0x3008, 0x42},
+	
+	{0x3c07, 0x07},
+	{0x5189, 0x72},
+
+	{0x3503, 0x00},
+
+	{0x5302, 0x30},
+	{0x5303, 0x10},
+	{0x5306, 0x10},
+	{0x5307, 0x20},
+
+	{0x3820, 0x40},
+	{0x3821, 0x06},
+
+	{0x3800, 0x01},
+	{0x3801, 0x50},
+	{0x3802, 0x01},
+	{0x3803, 0xb2},
+	{0x3804, 0x08},
+	{0x3805, 0xef},
+	{0x3806, 0x05},
+	{0x3807, 0xf1},
+	{0x3808, 0x07}, 	//1920x1080
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x3810, 0x00},
+	{0x3811, 0x10},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x3814, 0x11},
+	{0x3815, 0x11},
+
+	{0x3034, 0x1a},
+	{0x3035, 0x21}, 	//15fps
+	{0x3036, 0x46},
+	{0x3037, 0x13},
+
+	{0x380c, 0x09},
+	{0x380d, 0xc4},
+	{0x380e, 0x04},
+	{0x380f, 0x60},
+
+	{0x3a08, 0x00},
+	{0x3a09, 0x70},
+	{0x3a0e, 0x0a},
+	{0x3a0a, 0x00},
+	{0x3a0b, 0x5d},
+	{0x3a0d, 0x0c},
+
+	{0x3a00, 0x38},
+	{0x3a02, 0x04},
+	{0x3a03, 0x60},
+	{0x3a14, 0x17},
+	{0x3a15, 0x76},
+
+	{0x3618, 0x04},
+	{0x3612, 0x2b},
+	{0x3709, 0x12},
+	{0x370c, 0x00},
+
+	{0x4004, 0x06},
+	{0x3002, 0x1c},
+	{0x3006, 0xc3},
+	{0x3824, 0x04},
+	{0x5001, 0x83},
+
+	{0x4713, 0x02},
+	{0x4407, 0x04},
+	{0x460b, 0x37},
+	{0x460c, 0x20},
+	{0x4837, 0x0a},
+
+	{0x3008, 0x02},
+
+	{0x3023, 0x01},
+	{0x3022, 0x04},
+	{0x302c, 0xc3},
+	 ENDMARKER,
+};
+
+/* 2592X1944 QSXGA */
+static const struct regval_list module_qsxga_regs[] = 
+{
+	//{0x3212,0x03},
+    
+    {0x3008,0x42}, // added by p on 20131025
+    {0x3c07,0x07}, 
+    {0x5189,0x66},
+    
+    {0x5302,0x30},
+    {0x5303,0x10}, 
+    {0x5306,0x10},
+    {0x5307,0x20},
+    
+    {0x3503,0x07}, 
+    {0x3a00,0x38},  
+    
+    {0x3820,0x40},
+    {0x3821,0x06}, 
+    
+    {0x3800,0x00},
+    {0x3801,0x00},
+    {0x3802,0x00},
+    {0x3803,0x00},
+    {0x3804,0x0a},
+    {0x3805,0x3f}, // HW (HE)
+    {0x3806,0x07},
+    {0x3807,0x9f},
+    {0x3808,0x0a},//2592x1944
+    {0x3809,0x20},
+    {0x380a,0x07},
+    {0x380b,0x98},
+    {0x3810,0x00},
+    {0x3811,0x10},
+    {0x3812,0x00},
+    {0x3813,0x04},
+    {0x3814,0x11},
+    {0x3815,0x11},
+    
+    {0x3034,0x1a},                                 
+    {0x3035,0x21},                                 
+    {0x3036,0x46},                                 
+    {0x3037,0x13},                                
+                 
+    {0x380c,0x0b},                     
+    {0x380d,0x1c},                     
+    {0x380e,0x07},//5fps                      
+    {0x380f,0xb0},                          
+                                        
+    {0x3a08,0x00},                  
+    {0x3a09,0x62},   
+    {0x3a0e,0x14},  
+    {0x3a0a,0x00},                
+    {0x3a0b,0x52},      
+    {0x3a0d,0x18},      
+                                                                                      
+    {0x3618,0x04},                                 
+    {0x3612,0x2b},                                 
+    {0x3709,0x12},                                 
+    {0x370c,0x00},                                 
+ 
+	//0x3a02, 0x07, // 60Hz max exposure   
+	//0x3a03, 0xae, // 60Hz max exposure   
+	//0x3a08, 0x01, // B50 step  
+	//0x3a09, 0x27, // B50 step  
+	//0x3a0a, 0x00, // B60 step  
+	//0x3a0b, 0xf6, // B60 step  
+	//0x3a0e, 0x06, // 50Hz max band
+    {0x4004,0x06},
+    {0x3002,0x1c},  
+    {0x3006,0xc3}, 
+    {0x3824,0x01},   
+    {0x5001,0x83},
+    
+    {0x4713,0x02}, 
+    {0x4407,0x0c},  
+    {0x460b,0x37},
+    {0x460c,0x20},               
+     
+    //{0x3212,0x13}, 
+    //{0x3212,0xa3}, 
+    
+    //power down release
+    {0x3008,0x02},  // added by p on 20131025
+    ENDMARKER,
+};
+
+
+/* 2048X1536 QXGA */
+static const struct regval_list module_qxga_regs[] = 
+{
+	//{0x3212,0x03},
+    
+    {0x3008,0x42}, // added by p on 20131025
+    {0x3c07,0x07}, 
+    {0x5189,0x66},
+    
+    {0x5302,0x30},
+    {0x5303,0x10}, 
+    {0x5306,0x10},
+    {0x5307,0x20},
+    
+    {0x3503,0x07}, 
+    {0x3a00,0x38},  
+    
+    {0x3820,0x40},
+    {0x3821,0x06}, 
+    
+    {0x3801,0x00},
+    {0x3802,0x00},
+    {0x3803,0x00},
+    {0x3804,0x0a},
+    {0x3805,0x3f}, // HW (HE)
+    {0x3806,0x07},
+    
+    {0x3814,0x11},
+    {0x3815,0x11},
+    
+    {0x3034,0x1a},                                 
+    {0x3035,0x21},                                 
+    {0x3036,0x46},                                 
+    {0x3037,0x13},                                
+                 
+    {0x380c,0x0b},                     
+    {0x380d,0x1c},                     
+    {0x380e,0x07},//5fps                      
+    {0x380f,0xb0},                          
+                                        
+    {0x3a08,0x00},                  
+    {0x3a09,0x62},   
+    {0x3a0e,0x14},  
+    {0x3a0a,0x00},                
+    {0x3a0b,0x52},      
+    {0x3a0d,0x18},      
+                                                                                      
+    {0x3618,0x04},                                 
+    {0x3612,0x2b},                                 
+    {0x3709,0x12},                                 
+    {0x370c,0x00},                                 
+    {0x4004,0x06},
+    {0x3002,0x1c},  
+    {0x3006,0xc3}, 
+    {0x3824,0x01},   
+    {0x5001,0x83},
+    
+    {0x4713,0x02}, 
+    {0x4407,0x0c},  
+    {0x460b,0x37},
+    {0x460c,0x20},               
+     
+    //{0x3212,0x13}, 
+    //{0x3212,0xa3}, 
+    
+    //power down release
+    {0x3008,0x02},  // added by p on 20131025
+    //{0x3212,0x03},
+    
+    {0x3008,0x42}, // added by p on 20131025
+    {0x3c07,0x07}, 
+    {0x5189,0x66},
+    
+    {0x5302,0x30},
+    {0x5303,0x10}, 
+    {0x5306,0x10},
+    {0x5307,0x20},
+    
+    {0x3503,0x07}, 
+    {0x3a00,0x38},  
+    
+    {0x3820,0x40},
+    {0x3821,0x06}, 
+    
+    {0x3800,0x00},
+    {0x3801,0x00},
+    {0x3802,0x00},
+    {0x3803,0x00},
+    {0x3804,0x0a},
+    {0x3805,0x3f}, // HW (HE)
+    {0x3806,0x07},
+    {0x3807,0x9f},
+	{0x3808,0x08},//2048x1536
+    {0x3809,0x00},
+    {0x380a,0x06},
+    {0x380b,0x00},
+    {0x380c,0x0c},
+    {0x380d,0x80},
+    {0x380e,0x07},
+    {0x380f,0xd0},                                                                     
+    {0x5001,0xa3},
+    {0x5680,0x00},
+    {0x5681,0x00},
+    {0x5682,0x0a},
+    {0x5683,0x20},
+    {0x5684,0x00},
+    {0x5685,0x00},
+    {0x5686,0x07},
+    {0x5687,0x98},
+    ENDMARKER,
+};
+
+
+
+
+/* 640*480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+/* 1280*720 */
+static struct camera_module_win_size module_win_720p = {
+	.name             = "720P",
+	.width            = WIDTH_720P,
+	.height           = HEIGHT_720P,
+	.win_regs         = module_720p_regs,
+	
+	.frame_rate_array = frame_rate_720p,
+	.capture_only     = 0,
+};
+
+/* 1600*1200 */
+static struct camera_module_win_size module_win_uxga = {
+	.name             = "UXGA",
+	.width            = WIDTH_UXGA,
+	.height           = HEIGHT_UXGA,
+	.win_regs         = module_uxga_regs,
+	
+	.frame_rate_array = frame_rate_uxga,
+	.capture_only     = 1,
+};
+
+
+/* 1920*1080 */
+static struct camera_module_win_size module_win_1080p = {
+	.name             = "1080P",
+	.width            = WIDTH_1080P,
+	.height           = HEIGHT_1080P,
+	.win_regs         = module_1080p_regs,
+	
+	.frame_rate_array = frame_rate_1080p,
+	.capture_only     = 0,
+};
+
+/* 2592*1944 */
+static struct camera_module_win_size module_win_qsxga = {
+	.name             = "QSXGA",
+	.width            = WIDTH_QSXGA,
+	.height           = HEIGHT_QSXGA,
+	.win_regs         = module_qsxga_regs,
+	
+	.frame_rate_array = frame_rate_qsxga,
+	.capture_only     = 1,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_vga,
+	&module_win_720p,
+	&module_win_1080p,
+	&module_win_qsxga,
+	&module_win_uxga,
+};
+
+
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+	{0x3406 ,0x00},
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	{0x3406 ,0x01},
+	{0x3400 ,0x6 },
+	{0x3401 ,0x48},
+	{0x3402 ,0x4 },
+	{0x3403 ,0x0 },
+	{0x3404 ,0x4 },
+	{0x3405 ,0xd3},	
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+	{0x3406 ,0x1 },
+	{0x3400 ,0x6 },
+	{0x3401 ,0x1c},
+	{0x3402 ,0x4 },
+	{0x3403 ,0x0 },
+	{0x3404 ,0x4 },
+	{0x3405 ,0xf3},
+    ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+	{0x3406 ,0x01},
+	{0x3400 ,0x05},
+	{0x3401 ,0x48},
+	{0x3402 ,0x4 },
+	{0x3403 ,0x0 },
+	{0x3404 ,0x7 },
+	{0x3405 ,0xcf},
+    ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K ,??? */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	{0x3406 ,0x1 },
+	{0x3400 ,0x4 },
+	{0x3401 ,0x10},
+	{0x3402 ,0x4 },
+	{0x3403 ,0x0 },
+	{0x3404 ,0x8 },
+	{0x3405 ,0xb6},
+	ENDMARKER,
+};
+
+
+static struct regval_list module_scene_auto_regs[] =
+{
+	ENDMARKER,
+};
+
+
+static const struct regval_list module_init_auto_focus[] =
+{
+    {0x3000,0x20},	          
+    {0x8000,0x02},
+    {0x8001,0x0f},
+    {0x8002,0xe0},
+    {0x8003,0x02},
+    {0x8004,0x09},
+    {0x8005,0x28},
+    {0x8006,0xc2},
+    {0x8007,0x01},
+    {0x8008,0x22},
+    {0x8009,0x22},
+    {0x800a,0x00},
+    {0x800b,0x02},
+    {0x800c,0x0d},
+    {0x800d,0xea},
+    {0x800e,0x30},
+    {0x800f,0x01},
+    {0x8010,0x03},
+    {0x8011,0x02},
+    {0x8012,0x02},
+    {0x8013,0xa6},
+    {0x8014,0x30},
+    {0x8015,0x02},
+    {0x8016,0x03},
+    {0x8017,0x02},
+    {0x8018,0x02},
+    {0x8019,0xa6},
+    {0x801a,0x90},
+    {0x801b,0x51},
+    {0x801c,0xa5},
+    {0x801d,0xe0},
+    {0x801e,0x78},
+    {0x801f,0x93},
+    {0x8020,0xf6},
+    {0x8021,0xa3},
+    {0x8022,0xe0},
+    {0x8023,0x08},
+    {0x8024,0xf6},
+    {0x8025,0xa3},
+    {0x8026,0xe0},
+    {0x8027,0x08},
+    {0x8028,0xf6},
+    {0x8029,0xe5},
+    {0x802a,0x1f},
+    {0x802b,0x70},
+    {0x802c,0x4f},
+    {0x802d,0x75},
+    {0x802e,0x1e},
+    {0x802f,0x20},
+    {0x8030,0xd2},
+    {0x8031,0x35},
+    {0x8032,0xd3},
+    {0x8033,0x78},
+    {0x8034,0x4f},
+    {0x8035,0xe6},
+    {0x8036,0x94},
+    {0x8037,0x00},
+    {0x8038,0x18},
+    {0x8039,0xe6},
+    {0x803a,0x94},
+    {0x803b,0x00},
+    {0x803c,0x40},
+    {0x803d,0x07},
+    {0x803e,0xe6},
+    {0x803f,0xfe},
+    {0x8040,0x08},
+    {0x8041,0xe6},
+    {0x8042,0xff},
+    {0x8043,0x80},
+    {0x8044,0x03},
+    {0x8045,0x12},
+    {0x8046,0x0c},
+    {0x8047,0x67},
+    {0x8048,0x78},
+    {0x8049,0x7e},
+    {0x804a,0xa6},
+    {0x804b,0x06},
+    {0x804c,0x08},
+    {0x804d,0xa6},
+    {0x804e,0x07},
+    {0x804f,0x78},
+    {0x8050,0x8b},
+    {0x8051,0xa6},
+    {0x8052,0x09},
+    {0x8053,0x18},
+    {0x8054,0x76},
+    {0x8055,0x01},
+    {0x8056,0x12},
+    {0x8057,0x0c},
+    {0x8058,0x67},
+    {0x8059,0x78},
+    {0x805a,0x4e},
+    {0x805b,0xa6},
+    {0x805c,0x06},
+    {0x805d,0x08},
+    {0x805e,0xa6},
+    {0x805f,0x07},
+    {0x8060,0x78},
+    {0x8061,0x8b},
+    {0x8062,0xe6},
+    {0x8063,0x78},
+    {0x8064,0x6e},
+    {0x8065,0xf6},
+    {0x8066,0x75},
+    {0x8067,0x1f},
+    {0x8068,0x01},
+    {0x8069,0x78},
+    {0x806a,0x93},
+    {0x806b,0xe6},
+    {0x806c,0x78},
+    {0x806d,0x90},
+    {0x806e,0xf6},
+    {0x806f,0x78},
+    {0x8070,0x94},
+    {0x8071,0xe6},
+    {0x8072,0x78},
+    {0x8073,0x91},
+    {0x8074,0xf6},
+    {0x8075,0x78},
+    {0x8076,0x95},
+    {0x8077,0xe6},
+    {0x8078,0x78},
+    {0x8079,0x92},
+    {0x807a,0xf6},
+    {0x807b,0x22},
+    {0x807c,0x79},
+    {0x807d,0x90},
+    {0x807e,0xe7},
+    {0x807f,0xd3},
+    {0x8080,0x78},
+    {0x8081,0x93},
+    {0x8082,0x96},
+    {0x8083,0x40},
+    {0x8084,0x05},
+    {0x8085,0xe7},
+    {0x8086,0x96},
+    {0x8087,0xff},
+    {0x8088,0x80},
+    {0x8089,0x08},
+    {0x808a,0xc3},
+    {0x808b,0x79},
+    {0x808c,0x93},
+    {0x808d,0xe7},
+    {0x808e,0x78},
+    {0x808f,0x90},
+    {0x8090,0x96},
+    {0x8091,0xff},
+    {0x8092,0x78},
+    {0x8093,0x88},
+    {0x8094,0x76},
+    {0x8095,0x00},
+    {0x8096,0x08},
+    {0x8097,0xa6},
+    {0x8098,0x07},
+    {0x8099,0x79},
+    {0x809a,0x91},
+    {0x809b,0xe7},
+    {0x809c,0xd3},
+    {0x809d,0x78},
+    {0x809e,0x94},
+    {0x809f,0x96},
+    {0x80a0,0x40},
+    {0x80a1,0x05},
+    {0x80a2,0xe7},
+    {0x80a3,0x96},
+    {0x80a4,0xff},
+    {0x80a5,0x80},
+    {0x80a6,0x08},
+    {0x80a7,0xc3},
+    {0x80a8,0x79},
+    {0x80a9,0x94},
+    {0x80aa,0xe7},
+    {0x80ab,0x78},
+    {0x80ac,0x91},
+    {0x80ad,0x96},
+    {0x80ae,0xff},
+    {0x80af,0x12},
+    {0x80b0,0x0c},
+    {0x80b1,0xb0},
+    {0x80b2,0x79},
+    {0x80b3,0x92},
+    {0x80b4,0xe7},
+    {0x80b5,0xd3},
+    {0x80b6,0x78},
+    {0x80b7,0x95},
+    {0x80b8,0x96},
+    {0x80b9,0x40},
+    {0x80ba,0x05},
+    {0x80bb,0xe7},
+    {0x80bc,0x96},
+    {0x80bd,0xff},
+    {0x80be,0x80},
+    {0x80bf,0x08},
+    {0x80c0,0xc3},
+    {0x80c1,0x79},
+    {0x80c2,0x95},
+    {0x80c3,0xe7},
+    {0x80c4,0x78},
+    {0x80c5,0x92},
+    {0x80c6,0x96},
+    {0x80c7,0xff},
+    {0x80c8,0x12},
+    {0x80c9,0x0c},
+    {0x80ca,0xb0},
+    {0x80cb,0x12},
+    {0x80cc,0x0c},
+    {0x80cd,0x67},
+    {0x80ce,0x78},
+    {0x80cf,0x8a},
+    {0x80d0,0xe6},
+    {0x80d1,0x25},
+    {0x80d2,0xe0},
+    {0x80d3,0x24},
+    {0x80d4,0x4e},
+    {0x80d5,0xf8},
+    {0x80d6,0xa6},
+    {0x80d7,0x06},
+    {0x80d8,0x08},
+    {0x80d9,0xa6},
+    {0x80da,0x07},
+    {0x80db,0x78},
+    {0x80dc,0x8a},
+    {0x80dd,0xe6},
+    {0x80de,0x24},
+    {0x80df,0x6e},
+    {0x80e0,0xf8},
+    {0x80e1,0xa6},
+    {0x80e2,0x09},
+    {0x80e3,0x90},
+    {0x80e4,0x0e},
+    {0x80e5,0x93},
+    {0x80e6,0xe4},
+    {0x80e7,0x93},
+    {0x80e8,0x24},
+    {0x80e9,0xff},
+    {0x80ea,0xff},
+    {0x80eb,0xe4},
+    {0x80ec,0x34},
+    {0x80ed,0xff},
+    {0x80ee,0xfe},
+    {0x80ef,0x78},
+    {0x80f0,0x8a},
+    {0x80f1,0xe6},
+    {0x80f2,0x24},
+    {0x80f3,0x01},
+    {0x80f4,0xfd},
+    {0x80f5,0xe4},
+    {0x80f6,0x33},
+    {0x80f7,0xfc},
+    {0x80f8,0xd3},
+    {0x80f9,0xed},
+    {0x80fa,0x9f},
+    {0x80fb,0xee},
+    {0x80fc,0x64},
+    {0x80fd,0x80},
+    {0x80fe,0xf8},
+    {0x80ff,0xec},
+    {0x8100,0x64},
+    {0x8101,0x80},
+    {0x8102,0x98},
+    {0x8103,0x40},
+    {0x8104,0x04},
+    {0x8105,0x7f},
+    {0x8106,0x00},
+    {0x8107,0x80},
+    {0x8108,0x05},
+    {0x8109,0x78},
+    {0x810a,0x8a},
+    {0x810b,0xe6},
+    {0x810c,0x04},
+    {0x810d,0xff},
+    {0x810e,0x78},
+    {0x810f,0x8a},
+    {0x8110,0xa6},
+    {0x8111,0x07},
+    {0x8112,0xe5},
+    {0x8113,0x1f},
+    {0x8114,0xb4},
+    {0x8115,0x01},
+    {0x8116,0x0a},
+    {0x8117,0xe6},
+    {0x8118,0x60},
+    {0x8119,0x03},
+    {0x811a,0x02},
+    {0x811b,0x02},
+    {0x811c,0xa6},
+    {0x811d,0x75},
+    {0x811e,0x1f},
+    {0x811f,0x02},
+    {0x8120,0x22},
+    {0x8121,0x78},
+    {0x8122,0x4e},
+    {0x8123,0xe6},
+    {0x8124,0xfe},
+    {0x8125,0x08},
+    {0x8126,0xe6},
+    {0x8127,0xff},
+    {0x8128,0x78},
+    {0x8129,0x80},
+    {0x812a,0xa6},
+    {0x812b,0x06},
+    {0x812c,0x08},
+    {0x812d,0xa6},
+    {0x812e,0x07},
+    {0x812f,0x78},
+    {0x8130,0x4e},
+    {0x8131,0xe6},
+    {0x8132,0xfe},
+    {0x8133,0x08},
+    {0x8134,0xe6},
+    {0x8135,0xff},
+    {0x8136,0x78},
+    {0x8137,0x82},
+    {0x8138,0xa6},
+    {0x8139,0x06},
+    {0x813a,0x08},
+    {0x813b,0xa6},
+    {0x813c,0x07},
+    {0x813d,0x78},
+    {0x813e,0x6e},
+    {0x813f,0xe6},
+    {0x8140,0x78},
+    {0x8141,0x8c},
+    {0x8142,0xf6},
+    {0x8143,0x78},
+    {0x8144,0x6e},
+    {0x8145,0xe6},
+    {0x8146,0x78},
+    {0x8147,0x8d},
+    {0x8148,0xf6},
+    {0x8149,0x7f},
+    {0x814a,0x01},
+    {0x814b,0x90},
+    {0x814c,0x0e},
+    {0x814d,0x93},
+    {0x814e,0xe4},
+    {0x814f,0x93},
+    {0x8150,0xfe},
+    {0x8151,0xef},
+    {0x8152,0xc3},
+    {0x8153,0x9e},
+    {0x8154,0x50},
+    {0x8155,0x5f},
+    {0x8156,0xef},
+    {0x8157,0x25},
+    {0x8158,0xe0},
+    {0x8159,0x24},
+    {0x815a,0x4f},
+    {0x815b,0xf9},
+    {0x815c,0xc3},
+    {0x815d,0x78},
+    {0x815e,0x81},
+    {0x815f,0xe6},
+    {0x8160,0x97},
+    {0x8161,0x18},
+    {0x8162,0xe6},
+    {0x8163,0x19},
+    {0x8164,0x97},
+    {0x8165,0x50},
+    {0x8166,0x0a},
+    {0x8167,0x12},
+    {0x8168,0x0c},
+    {0x8169,0x98},
+    {0x816a,0x78},
+    {0x816b,0x80},
+    {0x816c,0xa6},
+    {0x816d,0x04},
+    {0x816e,0x08},
+    {0x816f,0xa6},
+    {0x8170,0x05},
+    {0x8171,0x74},
+    {0x8172,0x6e},
+    {0x8173,0x2f},
+    {0x8174,0xf9},
+    {0x8175,0x78},
+    {0x8176,0x8c},
+    {0x8177,0xe6},
+    {0x8178,0xc3},
+    {0x8179,0x97},
+    {0x817a,0x50},
+    {0x817b,0x08},
+    {0x817c,0x74},
+    {0x817d,0x6e},
+    {0x817e,0x2f},
+    {0x817f,0xf8},
+    {0x8180,0xe6},
+    {0x8181,0x78},
+    {0x8182,0x8c},
+    {0x8183,0xf6},
+    {0x8184,0xef},
+    {0x8185,0x25},
+    {0x8186,0xe0},
+    {0x8187,0x24},
+    {0x8188,0x4f},
+    {0x8189,0xf9},
+    {0x818a,0xd3},
+    {0x818b,0x78},
+    {0x818c,0x83},
+    {0x818d,0xe6},
+    {0x818e,0x97},
+    {0x818f,0x18},
+    {0x8190,0xe6},
+    {0x8191,0x19},
+    {0x8192,0x97},
+    {0x8193,0x40},
+    {0x8194,0x0a},
+    {0x8195,0x12},
+    {0x8196,0x0c},
+    {0x8197,0x98},
+    {0x8198,0x78},
+    {0x8199,0x82},
+    {0x819a,0xa6},
+    {0x819b,0x04},
+    {0x819c,0x08},
+    {0x819d,0xa6},
+    {0x819e,0x05},
+    {0x819f,0x74},
+    {0x81a0,0x6e},
+    {0x81a1,0x2f},
+    {0x81a2,0xf9},
+    {0x81a3,0x78},
+    {0x81a4,0x8d},
+    {0x81a5,0xe6},
+    {0x81a6,0xd3},
+    {0x81a7,0x97},
+    {0x81a8,0x40},
+    {0x81a9,0x08},
+    {0x81aa,0x74},
+    {0x81ab,0x6e},
+    {0x81ac,0x2f},
+    {0x81ad,0xf8},
+    {0x81ae,0xe6},
+    {0x81af,0x78},
+    {0x81b0,0x8d},
+    {0x81b1,0xf6},
+    {0x81b2,0x0f},
+    {0x81b3,0x80},
+    {0x81b4,0x96},
+    {0x81b5,0xc3},
+    {0x81b6,0x79},
+    {0x81b7,0x81},
+    {0x81b8,0xe7},
+    {0x81b9,0x78},
+    {0x81ba,0x83},
+    {0x81bb,0x96},
+    {0x81bc,0xff},
+    {0x81bd,0x19},
+    {0x81be,0xe7},
+    {0x81bf,0x18},
+    {0x81c0,0x96},
+    {0x81c1,0x78},
+    {0x81c2,0x84},
+    {0x81c3,0xf6},
+    {0x81c4,0x08},
+    {0x81c5,0xa6},
+    {0x81c6,0x07},
+    {0x81c7,0xc3},
+    {0x81c8,0x79},
+    {0x81c9,0x8c},
+    {0x81ca,0xe7},
+    {0x81cb,0x78},
+    {0x81cc,0x8d},
+    {0x81cd,0x96},
+    {0x81ce,0x08},
+    {0x81cf,0xf6},
+    {0x81d0,0x12},
+    {0x81d1,0x0c},
+    {0x81d2,0xa4},
+    {0x81d3,0x40},
+    {0x81d4,0x05},
+    {0x81d5,0x09},
+    {0x81d6,0xe7},
+    {0x81d7,0x08},
+    {0x81d8,0x80},
+    {0x81d9,0x06},
+    {0x81da,0xc3},
+    {0x81db,0x79},
+    {0x81dc,0x7f},
+    {0x81dd,0xe7},
+    {0x81de,0x78},
+    {0x81df,0x81},
+    {0x81e0,0x96},
+    {0x81e1,0xff},
+    {0x81e2,0x19},
+    {0x81e3,0xe7},
+    {0x81e4,0x18},
+    {0x81e5,0x96},
+    {0x81e6,0xfe},
+    {0x81e7,0x78},
+    {0x81e8,0x86},
+    {0x81e9,0xa6},
+    {0x81ea,0x06},
+    {0x81eb,0x08},
+    {0x81ec,0xa6},
+    {0x81ed,0x07},
+    {0x81ee,0x79},
+    {0x81ef,0x8c},
+    {0x81f0,0xe7},
+    {0x81f1,0xd3},
+    {0x81f2,0x78},
+    {0x81f3,0x8b},
+    {0x81f4,0x96},
+    {0x81f5,0x40},
+    {0x81f6,0x05},
+    {0x81f7,0xe7},
+    {0x81f8,0x96},
+    {0x81f9,0xff},
+    {0x81fa,0x80},
+    {0x81fb,0x08},
+    {0x81fc,0xc3},
+    {0x81fd,0x79},
+    {0x81fe,0x8b},
+    {0x81ff,0xe7},
+    {0x8200,0x78},
+    {0x8201,0x8c},
+    {0x8202,0x96},
+    {0x8203,0xff},
+    {0x8204,0x78},
+    {0x8205,0x8f},
+    {0x8206,0xa6},
+    {0x8207,0x07},
+    {0x8208,0xe5},
+    {0x8209,0x1f},
+    {0x820a,0x64},
+    {0x820b,0x02},
+    {0x820c,0x60},
+    {0x820d,0x03},
+    {0x820e,0x02},
+    {0x820f,0x02},
+    {0x8210,0x92},
+    {0x8211,0x90},
+    {0x8212,0x0e},
+    {0x8213,0x91},
+    {0x8214,0x93},
+    {0x8215,0xff},
+    {0x8216,0x18},
+    {0x8217,0xe6},
+    {0x8218,0xc3},
+    {0x8219,0x9f},
+    {0x821a,0x40},
+    {0x821b,0x03},
+    {0x821c,0x02},
+    {0x821d,0x02},
+    {0x821e,0xa6},
+    {0x821f,0x78},
+    {0x8220,0x84},
+    {0x8221,0x12},
+    {0x8222,0x0c},
+    {0x8223,0x89},
+    {0x8224,0x12},
+    {0x8225,0x0c},
+    {0x8226,0x5e},
+    {0x8227,0x90},
+    {0x8228,0x0e},
+    {0x8229,0x8e},
+    {0x822a,0x12},
+    {0x822b,0x0c},
+    {0x822c,0x77},
+    {0x822d,0x78},
+    {0x822e,0x80},
+    {0x822f,0xe6},
+    {0x8230,0xfe},
+    {0x8231,0x08},
+    {0x8232,0xe6},
+    {0x8233,0xff},
+    {0x8234,0x12},
+    {0x8235,0x0c},
+    {0x8236,0xba},
+    {0x8237,0x7b},
+    {0x8238,0x04},
+    {0x8239,0x12},
+    {0x823a,0x0c},
+    {0x823b,0x4c},
+    {0x823c,0xc3},
+    {0x823d,0x12},
+    {0x823e,0x06},
+    {0x823f,0xa6},
+    {0x8240,0x50},
+    {0x8241,0x64},
+    {0x8242,0x90},
+    {0x8243,0x0e},
+    {0x8244,0x92},
+    {0x8245,0xe4},
+    {0x8246,0x93},
+    {0x8247,0xff},
+    {0x8248,0x78},
+    {0x8249,0x8f},
+    {0x824a,0xe6},
+    {0x824b,0x9f},
+    {0x824c,0x40},
+    {0x824d,0x02},
+    {0x824e,0x80},
+    {0x824f,0x11},
+    {0x8250,0x90},
+    {0x8251,0x0e},
+    {0x8252,0x90},
+    {0x8253,0xe4},
+    {0x8254,0x93},
+    {0x8255,0xff},
+    {0x8256,0xd3},
+    {0x8257,0x78},
+    {0x8258,0x89},
+    {0x8259,0xe6},
+    {0x825a,0x9f},
+    {0x825b,0x18},
+    {0x825c,0xe6},
+    {0x825d,0x94},
+    {0x825e,0x00},
+    {0x825f,0x40},
+    {0x8260,0x03},
+    {0x8261,0x75},
+    {0x8262,0x1f},
+    {0x8263,0x05},
+    {0x8264,0x78},
+    {0x8265,0x86},
+    {0x8266,0x12},
+    {0x8267,0x0c},
+    {0x8268,0x89},
+    {0x8269,0x12},
+    {0x826a,0x0c},
+    {0x826b,0x5e},
+    {0x826c,0x90},
+    {0x826d,0x0e},
+    {0x826e,0x8f},
+    {0x826f,0x12},
+    {0x8270,0x0c},
+    {0x8271,0x77},
+    {0x8272,0x12},
+    {0x8273,0x0c},
+    {0x8274,0xa4},
+    {0x8275,0x40},
+    {0x8276,0x02},
+    {0x8277,0x80},
+    {0x8278,0x02},
+    {0x8279,0x78},
+    {0x827a,0x80},
+    {0x827b,0xe6},
+    {0x827c,0xfe},
+    {0x827d,0x08},
+    {0x827e,0xe6},
+    {0x827f,0xff},
+    {0x8280,0x12},
+    {0x8281,0x0c},
+    {0x8282,0xba},
+    {0x8283,0x7b},
+    {0x8284,0x10},
+    {0x8285,0x12},
+    {0x8286,0x0c},
+    {0x8287,0x4c},
+    {0x8288,0xd3},
+    {0x8289,0x12},
+    {0x828a,0x06},
+    {0x828b,0xa6},
+    {0x828c,0x40},
+    {0x828d,0x18},
+    {0x828e,0x75},
+    {0x828f,0x1f},
+    {0x8290,0x05},
+    {0x8291,0x22},
+    {0x8292,0xe5},
+    {0x8293,0x1f},
+    {0x8294,0xb4},
+    {0x8295,0x05},
+    {0x8296,0x0f},
+    {0x8297,0xd2},
+    {0x8298,0x01},
+    {0x8299,0xc2},
+    {0x829a,0x02},
+    {0x829b,0xe4},
+    {0x829c,0xf5},
+    {0x829d,0x1f},
+    {0x829e,0xf5},
+    {0x829f,0x1e},
+    {0x82a0,0xd2},
+    {0x82a1,0x35},
+    {0x82a2,0xd2},
+    {0x82a3,0x33},
+    {0x82a4,0xd2},
+    {0x82a5,0x36},
+    {0x82a6,0x22},
+    {0x82a7,0xe5},
+    {0x82a8,0x1f},
+    {0x82a9,0x70},
+    {0x82aa,0x72},
+    {0x82ab,0xf5},
+    {0x82ac,0x1e},
+    {0x82ad,0xd2},
+    {0x82ae,0x35},
+    {0x82af,0xff},
+    {0x82b0,0xef},
+    {0x82b1,0x25},
+    {0x82b2,0xe0},
+    {0x82b3,0x24},
+    {0x82b4,0x4e},
+    {0x82b5,0xf8},
+    {0x82b6,0xe4},
+    {0x82b7,0xf6},
+    {0x82b8,0x08},
+    {0x82b9,0xf6},
+    {0x82ba,0x0f},
+    {0x82bb,0xbf},
+    {0x82bc,0x34},
+    {0x82bd,0xf2},
+    {0x82be,0x90},
+    {0x82bf,0x0e},
+    {0x82c0,0x94},
+    {0x82c1,0xe4},
+    {0x82c2,0x93},
+    {0x82c3,0xff},
+    {0x82c4,0xe5},
+    {0x82c5,0x4b},
+    {0x82c6,0xc3},
+    {0x82c7,0x9f},
+    {0x82c8,0x50},
+    {0x82c9,0x04},
+    {0x82ca,0x7f},
+    {0x82cb,0x05},
+    {0x82cc,0x80},
+    {0x82cd,0x02},
+    {0x82ce,0x7f},
+    {0x82cf,0xfb},
+    {0x82d0,0x78},
+    {0x82d1,0xbd},
+    {0x82d2,0xa6},
+    {0x82d3,0x07},
+    {0x82d4,0x12},
+    {0x82d5,0x0e},
+    {0x82d6,0xb1},
+    {0x82d7,0x40},
+    {0x82d8,0x04},
+    {0x82d9,0x7f},
+    {0x82da,0x03},
+    {0x82db,0x80},
+    {0x82dc,0x02},
+    {0x82dd,0x7f},
+    {0x82de,0x30},
+    {0x82df,0x78},
+    {0x82e0,0xbc},
+    {0x82e1,0xa6},
+    {0x82e2,0x07},
+    {0x82e3,0xe6},
+    {0x82e4,0x18},
+    {0x82e5,0xf6},
+    {0x82e6,0x08},
+    {0x82e7,0xe6},
+    {0x82e8,0x78},
+    {0x82e9,0xb9},
+    {0x82ea,0xf6},
+    {0x82eb,0x78},
+    {0x82ec,0xbc},
+    {0x82ed,0xe6},
+    {0x82ee,0x78},
+    {0x82ef,0xba},
+    {0x82f0,0xf6},
+    {0x82f1,0x78},
+    {0x82f2,0xbf},
+    {0x82f3,0x76},
+    {0x82f4,0x33},
+    {0x82f5,0xe4},
+    {0x82f6,0x08},
+    {0x82f7,0xf6},
+    {0x82f8,0x78},
+    {0x82f9,0xb8},
+    {0x82fa,0x76},
+    {0x82fb,0x01},
+    {0x82fc,0x75},
+    {0x82fd,0x4a},
+    {0x82fe,0x02},
+    {0x82ff,0x78},
+    {0x8300,0xb6},
+    {0x8301,0xf6},
+    {0x8302,0x08},
+    {0x8303,0xf6},
+    {0x8304,0x74},
+    {0x8305,0xff},
+    {0x8306,0x78},
+    {0x8307,0xc1},
+    {0x8308,0xf6},
+    {0x8309,0x08},
+    {0x830a,0xf6},
+    {0x830b,0x75},
+    {0x830c,0x1f},
+    {0x830d,0x01},
+    {0x830e,0x78},
+    {0x830f,0xbc},
+    {0x8310,0xe6},
+    {0x8311,0x75},
+    {0x8312,0xf0},
+    {0x8313,0x05},
+    {0x8314,0xa4},
+    {0x8315,0xf5},
+    {0x8316,0x4b},
+    {0x8317,0x12},
+    {0x8318,0x0b},
+    {0x8319,0x39},
+    {0x831a,0xc2},
+    {0x831b,0x37},
+    {0x831c,0x22},
+    {0x831d,0x78},
+    {0x831e,0xb8},
+    {0x831f,0xe6},
+    {0x8320,0xd3},
+    {0x8321,0x94},
+    {0x8322,0x00},
+    {0x8323,0x40},
+    {0x8324,0x02},
+    {0x8325,0x16},
+    {0x8326,0x22},
+    {0x8327,0xe5},
+    {0x8328,0x1f},
+    {0x8329,0xb4},
+    {0x832a,0x05},
+    {0x832b,0x23},
+    {0x832c,0xe4},
+    {0x832d,0xf5},
+    {0x832e,0x1f},
+    {0x832f,0xc2},
+    {0x8330,0x01},
+    {0x8331,0x78},
+    {0x8332,0xb6},
+    {0x8333,0xe6},
+    {0x8334,0xfe},
+    {0x8335,0x08},
+    {0x8336,0xe6},
+    {0x8337,0xff},
+    {0x8338,0x78},
+    {0x8339,0x4e},
+    {0x833a,0xa6},
+    {0x833b,0x06},
+    {0x833c,0x08},
+    {0x833d,0xa6},
+    {0x833e,0x07},
+    {0x833f,0xa2},
+    {0x8340,0x37},
+    {0x8341,0xe4},
+    {0x8342,0x33},
+    {0x8343,0xf5},
+    {0x8344,0x3c},
+    {0x8345,0x90},
+    {0x8346,0x30},
+    {0x8347,0x28},
+    {0x8348,0xf0},
+    {0x8349,0x75},
+    {0x834a,0x1e},
+    {0x834b,0x10},
+    {0x834c,0xd2},
+    {0x834d,0x35},
+    {0x834e,0x22},
+    {0x834f,0xe5},
+    {0x8350,0x4b},
+    {0x8351,0x75},
+    {0x8352,0xf0},
+    {0x8353,0x05},
+    {0x8354,0x84},
+    {0x8355,0x78},
+    {0x8356,0xbc},
+    {0x8357,0xf6},
+    {0x8358,0x90},
+    {0x8359,0x0e},
+    {0x835a,0x8c},
+    {0x835b,0xe4},
+    {0x835c,0x93},
+    {0x835d,0xff},
+    {0x835e,0x25},
+    {0x835f,0xe0},
+    {0x8360,0x24},
+    {0x8361,0x0a},
+    {0x8362,0xf8},
+    {0x8363,0xe6},
+    {0x8364,0xfc},
+    {0x8365,0x08},
+    {0x8366,0xe6},
+    {0x8367,0xfd},
+    {0x8368,0x78},
+    {0x8369,0xbc},
+    {0x836a,0xe6},
+    {0x836b,0x25},
+    {0x836c,0xe0},
+    {0x836d,0x24},
+    {0x836e,0x4e},
+    {0x836f,0xf8},
+    {0x8370,0xa6},
+    {0x8371,0x04},
+    {0x8372,0x08},
+    {0x8373,0xa6},
+    {0x8374,0x05},
+    {0x8375,0xef},
+    {0x8376,0x12},
+    {0x8377,0x0e},
+    {0x8378,0xf5},
+    {0x8379,0xd3},
+    {0x837a,0x78},
+    {0x837b,0xb7},
+    {0x837c,0x96},
+    {0x837d,0xee},
+    {0x837e,0x18},
+    {0x837f,0x96},
+    {0x8380,0x40},
+    {0x8381,0x0d},
+    {0x8382,0x78},
+    {0x8383,0xbc},
+    {0x8384,0xe6},
+    {0x8385,0x78},
+    {0x8386,0xb9},
+    {0x8387,0xf6},
+    {0x8388,0x78},
+    {0x8389,0xb6},
+    {0x838a,0xa6},
+    {0x838b,0x06},
+    {0x838c,0x08},
+    {0x838d,0xa6},
+    {0x838e,0x07},
+    {0x838f,0x90},
+    {0x8390,0x0e},
+    {0x8391,0x8c},
+    {0x8392,0xe4},
+    {0x8393,0x93},
+    {0x8394,0x12},
+    {0x8395,0x0e},
+    {0x8396,0xf5},
+    {0x8397,0xc3},
+    {0x8398,0x78},
+    {0x8399,0xc2},
+    {0x839a,0x96},
+    {0x839b,0xee},
+    {0x839c,0x18},
+    {0x839d,0x96},
+    {0x839e,0x50},
+    {0x839f,0x0d},
+    {0x83a0,0x78},
+    {0x83a1,0xbc},
+    {0x83a2,0xe6},
+    {0x83a3,0x78},
+    {0x83a4,0xba},
+    {0x83a5,0xf6},
+    {0x83a6,0x78},
+    {0x83a7,0xc1},
+    {0x83a8,0xa6},
+    {0x83a9,0x06},
+    {0x83aa,0x08},
+    {0x83ab,0xa6},
+    {0x83ac,0x07},
+    {0x83ad,0x78},
+    {0x83ae,0xb6},
+    {0x83af,0xe6},
+    {0x83b0,0xfe},
+    {0x83b1,0x08},
+    {0x83b2,0xe6},
+    {0x83b3,0xc3},
+    {0x83b4,0x78},
+    {0x83b5,0xc2},
+    {0x83b6,0x96},
+    {0x83b7,0xff},
+    {0x83b8,0xee},
+    {0x83b9,0x18},
+    {0x83ba,0x96},
+    {0x83bb,0x78},
+    {0x83bc,0xc3},
+    {0x83bd,0xf6},
+    {0x83be,0x08},
+    {0x83bf,0xa6},
+    {0x83c0,0x07},
+    {0x83c1,0x90},
+    {0x83c2,0x0e},
+    {0x83c3,0x96},
+    {0x83c4,0xe4},
+    {0x83c5,0x18},
+    {0x83c6,0x12},
+    {0x83c7,0x0e},
+    {0x83c8,0xb8},
+    {0x83c9,0x40},
+    {0x83ca,0x02},
+    {0x83cb,0xd2},
+    {0x83cc,0x37},
+    {0x83cd,0x78},
+    {0x83ce,0xbc},
+    {0x83cf,0xe6},
+    {0x83d0,0x08},
+    {0x83d1,0x26},
+    {0x83d2,0x08},
+    {0x83d3,0xf6},
+    {0x83d4,0xe5},
+    {0x83d5,0x1f},
+    {0x83d6,0x64},
+    {0x83d7,0x01},
+    {0x83d8,0x70},
+    {0x83d9,0x7a},
+    {0x83da,0xe6},
+    {0x83db,0xc3},
+    {0x83dc,0x78},
+    {0x83dd,0xc0},
+    {0x83de,0x12},
+    {0x83df,0x0e},
+    {0x83e0,0xa1},
+    {0x83e1,0x40},
+    {0x83e2,0x08},
+    {0x83e3,0x12},
+    {0x83e4,0x0e},
+    {0x83e5,0x9c},
+    {0x83e6,0x50},
+    {0x83e7,0x03},
+    {0x83e8,0x02},
+    {0x83e9,0x04},
+    {0x83ea,0xf1},
+    {0x83eb,0x12},
+    {0x83ec,0x0e},
+    {0x83ed,0xaf},
+    {0x83ee,0x40},
+    {0x83ef,0x04},
+    {0x83f0,0x7f},
+    {0x83f1,0xfe},
+    {0x83f2,0x80},
+    {0x83f3,0x02},
+    {0x83f4,0x7f},
+    {0x83f5,0x02},
+    {0x83f6,0x78},
+    {0x83f7,0xbd},
+    {0x83f8,0xa6},
+    {0x83f9,0x07},
+    {0x83fa,0x78},
+    {0x83fb,0xb9},
+    {0x83fc,0xe6},
+    {0x83fd,0x24},
+    {0x83fe,0x03},
+    {0x83ff,0x78},
+    {0x8400,0xbf},
+    {0x8401,0xf6},
+    {0x8402,0x78},
+    {0x8403,0xb9},
+    {0x8404,0xe6},
+    {0x8405,0x24},
+    {0x8406,0xfd},
+    {0x8407,0x78},
+    {0x8408,0xc0},
+    {0x8409,0xf6},
+    {0x840a,0x18},
+    {0x840b,0x12},
+    {0x840c,0x0e},
+    {0x840d,0xb1},
+    {0x840e,0x40},
+    {0x840f,0x04},
+    {0x8410,0xe6},
+    {0x8411,0xff},
+    {0x8412,0x80},
+    {0x8413,0x02},
+    {0x8414,0x7f},
+    {0x8415,0x00},
+    {0x8416,0x12},
+    {0x8417,0x0e},
+    {0x8418,0xd1},
+    {0x8419,0x40},
+    {0x841a,0x04},
+    {0x841b,0xe6},
+    {0x841c,0xff},
+    {0x841d,0x80},
+    {0x841e,0x02},
+    {0x841f,0x7f},
+    {0x8420,0x00},
+    {0x8421,0x12},
+    {0x8422,0x0e},
+    {0x8423,0xdd},
+    {0x8424,0x50},
+    {0x8425,0x04},
+    {0x8426,0xe6},
+    {0x8427,0xff},
+    {0x8428,0x80},
+    {0x8429,0x02},
+    {0x842a,0x7f},
+    {0x842b,0x33},
+    {0x842c,0x12},
+    {0x842d,0x0e},
+    {0x842e,0xe9},
+    {0x842f,0x50},
+    {0x8430,0x04},
+    {0x8431,0xe6},
+    {0x8432,0xff},
+    {0x8433,0x80},
+    {0x8434,0x02},
+    {0x8435,0x7f},
+    {0x8436,0x33},
+    {0x8437,0x12},
+    {0x8438,0x0e},
+    {0x8439,0xab},
+    {0x843a,0x40},
+    {0x843b,0x06},
+    {0x843c,0x78},
+    {0x843d,0xc0},
+    {0x843e,0xe6},
+    {0x843f,0xff},
+    {0x8440,0x80},
+    {0x8441,0x04},
+    {0x8442,0x78},
+    {0x8443,0xbf},
+    {0x8444,0xe6},
+    {0x8445,0xff},
+    {0x8446,0x78},
+    {0x8447,0xbe},
+    {0x8448,0xa6},
+    {0x8449,0x07},
+    {0x844a,0x75},
+    {0x844b,0x1f},
+    {0x844c,0x02},
+    {0x844d,0x78},
+    {0x844e,0xb8},
+    {0x844f,0x76},
+    {0x8450,0x01},
+    {0x8451,0x02},
+    {0x8452,0x04},
+    {0x8453,0xf1},
+    {0x8454,0xe5},
+    {0x8455,0x1f},
+    {0x8456,0x64},
+    {0x8457,0x02},
+    {0x8458,0x70},
+    {0x8459,0x77},
+    {0x845a,0x78},
+    {0x845b,0xbe},
+    {0x845c,0xe6},
+    {0x845d,0xff},
+    {0x845e,0xc3},
+    {0x845f,0x78},
+    {0x8460,0xc0},
+    {0x8461,0x12},
+    {0x8462,0x0e},
+    {0x8463,0xa2},
+    {0x8464,0x40},
+    {0x8465,0x05},
+    {0x8466,0x12},
+    {0x8467,0x0e},
+    {0x8468,0x9c},
+    {0x8469,0x40},
+    {0x846a,0x64},
+    {0x846b,0x12},
+    {0x846c,0x0e},
+    {0x846d,0xaf},
+    {0x846e,0x40},
+    {0x846f,0x04},
+    {0x8470,0x7f},
+    {0x8471,0xff},
+    {0x8472,0x80},
+    {0x8473,0x02},
+    {0x8474,0x7f},
+    {0x8475,0x01},
+    {0x8476,0x78},
+    {0x8477,0xbd},
+    {0x8478,0xa6},
+    {0x8479,0x07},
+    {0x847a,0x78},
+    {0x847b,0xb9},
+    {0x847c,0xe6},
+    {0x847d,0x04},
+    {0x847e,0x78},
+    {0x847f,0xbf},
+    {0x8480,0xf6},
+    {0x8481,0x78},
+    {0x8482,0xb9},
+    {0x8483,0xe6},
+    {0x8484,0x14},
+    {0x8485,0x78},
+    {0x8486,0xc0},
+    {0x8487,0xf6},
+    {0x8488,0x18},
+    {0x8489,0x12},
+    {0x848a,0x0e},
+    {0x848b,0xd6},
+    {0x848c,0x40},
+    {0x848d,0x04},
+    {0x848e,0xe6},
+    {0x848f,0xff},
+    {0x8490,0x80},
+    {0x8491,0x02},
+    {0x8492,0x7f},
+    {0x8493,0x00},
+    {0x8494,0x12},
+    {0x8495,0x0e},
+    {0x8496,0xd1},
+    {0x8497,0x40},
+    {0x8498,0x04},
+    {0x8499,0xe6},
+    {0x849a,0xff},
+    {0x849b,0x80},
+    {0x849c,0x02},
+    {0x849d,0x7f},
+    {0x849e,0x00},
+    {0x849f,0x12},
+    {0x84a0,0x0e},
+    {0x84a1,0xdd},
+    {0x84a2,0x50},
+    {0x84a3,0x04},
+    {0x84a4,0xe6},
+    {0x84a5,0xff},
+    {0x84a6,0x80},
+    {0x84a7,0x02},
+    {0x84a8,0x7f},
+    {0x84a9,0x33},
+    {0x84aa,0x12},
+    {0x84ab,0x0e},
+    {0x84ac,0xe9},
+    {0x84ad,0x50},
+    {0x84ae,0x04},
+    {0x84af,0xe6},
+    {0x84b0,0xff},
+    {0x84b1,0x80},
+    {0x84b2,0x02},
+    {0x84b3,0x7f},
+    {0x84b4,0x33},
+    {0x84b5,0x12},
+    {0x84b6,0x0e},
+    {0x84b7,0xab},
+    {0x84b8,0x40},
+    {0x84b9,0x06},
+    {0x84ba,0x78},
+    {0x84bb,0xc0},
+    {0x84bc,0xe6},
+    {0x84bd,0xff},
+    {0x84be,0x80},
+    {0x84bf,0x04},
+    {0x84c0,0x78},
+    {0x84c1,0xbf},
+    {0x84c2,0xe6},
+    {0x84c3,0xff},
+    {0x84c4,0x78},
+    {0x84c5,0xbe},
+    {0x84c6,0xa6},
+    {0x84c7,0x07},
+    {0x84c8,0x75},
+    {0x84c9,0x1f},
+    {0x84ca,0x03},
+    {0x84cb,0x78},
+    {0x84cc,0xb8},
+    {0x84cd,0x76},
+    {0x84ce,0x01},
+    {0x84cf,0x80},
+    {0x84d0,0x20},
+    {0x84d1,0xe5},
+    {0x84d2,0x1f},
+    {0x84d3,0x64},
+    {0x84d4,0x03},
+    {0x84d5,0x70},
+    {0x84d6,0x26},
+    {0x84d7,0x78},
+    {0x84d8,0xbe},
+    {0x84d9,0xe6},
+    {0x84da,0xff},
+    {0x84db,0xc3},
+    {0x84dc,0x78},
+    {0x84dd,0xc0},
+    {0x84de,0x12},
+    {0x84df,0x0e},
+    {0x84e0,0xa2},
+    {0x84e1,0x40},
+    {0x84e2,0x05},
+    {0x84e3,0x12},
+    {0x84e4,0x0e},
+    {0x84e5,0x9c},
+    {0x84e6,0x40},
+    {0x84e7,0x09},
+    {0x84e8,0x78},
+    {0x84e9,0xb9},
+    {0x84ea,0xe6},
+    {0x84eb,0x78},
+    {0x84ec,0xbe},
+    {0x84ed,0xf6},
+    {0x84ee,0x75},
+    {0x84ef,0x1f},
+    {0x84f0,0x04},
+    {0x84f1,0x78},
+    {0x84f2,0xbe},
+    {0x84f3,0xe6},
+    {0x84f4,0x75},
+    {0x84f5,0xf0},
+    {0x84f6,0x05},
+    {0x84f7,0xa4},
+    {0x84f8,0xf5},
+    {0x84f9,0x4b},
+    {0x84fa,0x02},
+    {0x84fb,0x0b},
+    {0x84fc,0x39},
+    {0x84fd,0xe5},
+    {0x84fe,0x1f},
+    {0x84ff,0x64},
+    {0x8500,0x04},
+    {0x8501,0x70},
+    {0x8502,0x1e},
+    {0x8503,0x90},
+    {0x8504,0x0e},
+    {0x8505,0x95},
+    {0x8506,0x78},
+    {0x8507,0xc3},
+    {0x8508,0x12},
+    {0x8509,0x0e},
+    {0x850a,0xb8},
+    {0x850b,0x40},
+    {0x850c,0x04},
+    {0x850d,0xd2},
+    {0x850e,0x37},
+    {0x850f,0x80},
+    {0x8510,0x0d},
+    {0x8511,0x90},
+    {0x8512,0x0e},
+    {0x8513,0x97},
+    {0x8514,0xe4},
+    {0x8515,0x93},
+    {0x8516,0xff},
+    {0x8517,0x60},
+    {0x8518,0x05},
+    {0x8519,0xf5},
+    {0x851a,0x4b},
+    {0x851b,0x12},
+    {0x851c,0x0b},
+    {0x851d,0x39},
+    {0x851e,0x75},
+    {0x851f,0x1f},
+    {0x8520,0x05},
+    {0x8521,0x22},
+    {0x8522,0xef},
+    {0x8523,0x8d},
+    {0x8524,0xf0},
+    {0x8525,0xa4},
+    {0x8526,0xa8},
+    {0x8527,0xf0},
+    {0x8528,0xcf},
+    {0x8529,0x8c},
+    {0x852a,0xf0},
+    {0x852b,0xa4},
+    {0x852c,0x28},
+    {0x852d,0xce},
+    {0x852e,0x8d},
+    {0x852f,0xf0},
+    {0x8530,0xa4},
+    {0x8531,0x2e},
+    {0x8532,0xfe},
+    {0x8533,0x22},
+    {0x8534,0xbc},
+    {0x8535,0x00},
+    {0x8536,0x0b},
+    {0x8537,0xbe},
+    {0x8538,0x00},
+    {0x8539,0x29},
+    {0x853a,0xef},
+    {0x853b,0x8d},
+    {0x853c,0xf0},
+    {0x853d,0x84},
+    {0x853e,0xff},
+    {0x853f,0xad},
+    {0x8540,0xf0},
+    {0x8541,0x22},
+    {0x8542,0xe4},
+    {0x8543,0xcc},
+    {0x8544,0xf8},
+    {0x8545,0x75},
+    {0x8546,0xf0},
+    {0x8547,0x08},
+    {0x8548,0xef},
+    {0x8549,0x2f},
+    {0x854a,0xff},
+    {0x854b,0xee},
+    {0x854c,0x33},
+    {0x854d,0xfe},
+    {0x854e,0xec},
+    {0x854f,0x33},
+    {0x8550,0xfc},
+    {0x8551,0xee},
+    {0x8552,0x9d},
+    {0x8553,0xec},
+    {0x8554,0x98},
+    {0x8555,0x40},
+    {0x8556,0x05},
+    {0x8557,0xfc},
+    {0x8558,0xee},
+    {0x8559,0x9d},
+    {0x855a,0xfe},
+    {0x855b,0x0f},
+    {0x855c,0xd5},
+    {0x855d,0xf0},
+    {0x855e,0xe9},
+    {0x855f,0xe4},
+    {0x8560,0xce},
+    {0x8561,0xfd},
+    {0x8562,0x22},
+    {0x8563,0xed},
+    {0x8564,0xf8},
+    {0x8565,0xf5},
+    {0x8566,0xf0},
+    {0x8567,0xee},
+    {0x8568,0x84},
+    {0x8569,0x20},
+    {0x856a,0xd2},
+    {0x856b,0x1c},
+    {0x856c,0xfe},
+    {0x856d,0xad},
+    {0x856e,0xf0},
+    {0x856f,0x75},
+    {0x8570,0xf0},
+    {0x8571,0x08},
+    {0x8572,0xef},
+    {0x8573,0x2f},
+    {0x8574,0xff},
+    {0x8575,0xed},
+    {0x8576,0x33},
+    {0x8577,0xfd},
+    {0x8578,0x40},
+    {0x8579,0x07},
+    {0x857a,0x98},
+    {0x857b,0x50},
+    {0x857c,0x06},
+    {0x857d,0xd5},
+    {0x857e,0xf0},
+    {0x857f,0xf2},
+    {0x8580,0x22},
+    {0x8581,0xc3},
+    {0x8582,0x98},
+    {0x8583,0xfd},
+    {0x8584,0x0f},
+    {0x8585,0xd5},
+    {0x8586,0xf0},
+    {0x8587,0xea},
+    {0x8588,0x22},
+    {0x8589,0xe8},
+    {0x858a,0x8f},
+    {0x858b,0xf0},
+    {0x858c,0xa4},
+    {0x858d,0xcc},
+    {0x858e,0x8b},
+    {0x858f,0xf0},
+    {0x8590,0xa4},
+    {0x8591,0x2c},
+    {0x8592,0xfc},
+    {0x8593,0xe9},
+    {0x8594,0x8e},
+    {0x8595,0xf0},
+    {0x8596,0xa4},
+    {0x8597,0x2c},
+    {0x8598,0xfc},
+    {0x8599,0x8a},
+    {0x859a,0xf0},
+    {0x859b,0xed},
+    {0x859c,0xa4},
+    {0x859d,0x2c},
+    {0x859e,0xfc},
+    {0x859f,0xea},
+    {0x85a0,0x8e},
+    {0x85a1,0xf0},
+    {0x85a2,0xa4},
+    {0x85a3,0xcd},
+    {0x85a4,0xa8},
+    {0x85a5,0xf0},
+    {0x85a6,0x8b},
+    {0x85a7,0xf0},
+    {0x85a8,0xa4},
+    {0x85a9,0x2d},
+    {0x85aa,0xcc},
+    {0x85ab,0x38},
+    {0x85ac,0x25},
+    {0x85ad,0xf0},
+    {0x85ae,0xfd},
+    {0x85af,0xe9},
+    {0x85b0,0x8f},
+    {0x85b1,0xf0},
+    {0x85b2,0xa4},
+    {0x85b3,0x2c},
+    {0x85b4,0xcd},
+    {0x85b5,0x35},
+    {0x85b6,0xf0},
+    {0x85b7,0xfc},
+    {0x85b8,0xeb},
+    {0x85b9,0x8e},
+    {0x85ba,0xf0},
+    {0x85bb,0xa4},
+    {0x85bc,0xfe},
+    {0x85bd,0xa9},
+    {0x85be,0xf0},
+    {0x85bf,0xeb},
+    {0x85c0,0x8f},
+    {0x85c1,0xf0},
+    {0x85c2,0xa4},
+    {0x85c3,0xcf},
+    {0x85c4,0xc5},
+    {0x85c5,0xf0},
+    {0x85c6,0x2e},
+    {0x85c7,0xcd},
+    {0x85c8,0x39},
+    {0x85c9,0xfe},
+    {0x85ca,0xe4},
+    {0x85cb,0x3c},
+    {0x85cc,0xfc},
+    {0x85cd,0xea},
+    {0x85ce,0xa4},
+    {0x85cf,0x2d},
+    {0x85d0,0xce},
+    {0x85d1,0x35},
+    {0x85d2,0xf0},
+    {0x85d3,0xfd},
+    {0x85d4,0xe4},
+    {0x85d5,0x3c},
+    {0x85d6,0xfc},
+    {0x85d7,0x22},
+    {0x85d8,0x75},
+    {0x85d9,0xf0},
+    {0x85da,0x08},
+    {0x85db,0x75},
+    {0x85dc,0x82},
+    {0x85dd,0x00},
+    {0x85de,0xef},
+    {0x85df,0x2f},
+    {0x85e0,0xff},
+    {0x85e1,0xee},
+    {0x85e2,0x33},
+    {0x85e3,0xfe},
+    {0x85e4,0xcd},
+    {0x85e5,0x33},
+    {0x85e6,0xcd},
+    {0x85e7,0xcc},
+    {0x85e8,0x33},
+    {0x85e9,0xcc},
+    {0x85ea,0xc5},
+    {0x85eb,0x82},
+    {0x85ec,0x33},
+    {0x85ed,0xc5},
+    {0x85ee,0x82},
+    {0x85ef,0x9b},
+    {0x85f0,0xed},
+    {0x85f1,0x9a},
+    {0x85f2,0xec},
+    {0x85f3,0x99},
+    {0x85f4,0xe5},
+    {0x85f5,0x82},
+    {0x85f6,0x98},
+    {0x85f7,0x40},
+    {0x85f8,0x0c},
+    {0x85f9,0xf5},
+    {0x85fa,0x82},
+    {0x85fb,0xee},
+    {0x85fc,0x9b},
+    {0x85fd,0xfe},
+    {0x85fe,0xed},
+    {0x85ff,0x9a},
+    {0x8600,0xfd},
+    {0x8601,0xec},
+    {0x8602,0x99},
+    {0x8603,0xfc},
+    {0x8604,0x0f},
+    {0x8605,0xd5},
+    {0x8606,0xf0},
+    {0x8607,0xd6},
+    {0x8608,0xe4},
+    {0x8609,0xce},
+    {0x860a,0xfb},
+    {0x860b,0xe4},
+    {0x860c,0xcd},
+    {0x860d,0xfa},
+    {0x860e,0xe4},
+    {0x860f,0xcc},
+    {0x8610,0xf9},
+    {0x8611,0xa8},
+    {0x8612,0x82},
+    {0x8613,0x22},
+    {0x8614,0xb8},
+    {0x8615,0x00},
+    {0x8616,0xc1},
+    {0x8617,0xb9},
+    {0x8618,0x00},
+    {0x8619,0x59},
+    {0x861a,0xba},
+    {0x861b,0x00},
+    {0x861c,0x2d},
+    {0x861d,0xec},
+    {0x861e,0x8b},
+    {0x861f,0xf0},
+    {0x8620,0x84},
+    {0x8621,0xcf},
+    {0x8622,0xce},
+    {0x8623,0xcd},
+    {0x8624,0xfc},
+    {0x8625,0xe5},
+    {0x8626,0xf0},
+    {0x8627,0xcb},
+    {0x8628,0xf9},
+    {0x8629,0x78},
+    {0x862a,0x18},
+    {0x862b,0xef},
+    {0x862c,0x2f},
+    {0x862d,0xff},
+    {0x862e,0xee},
+    {0x862f,0x33},
+    {0x8630,0xfe},
+    {0x8631,0xed},
+    {0x8632,0x33},
+    {0x8633,0xfd},
+    {0x8634,0xec},
+    {0x8635,0x33},
+    {0x8636,0xfc},
+    {0x8637,0xeb},
+    {0x8638,0x33},
+    {0x8639,0xfb},
+    {0x863a,0x10},
+    {0x863b,0xd7},
+    {0x863c,0x03},
+    {0x863d,0x99},
+    {0x863e,0x40},
+    {0x863f,0x04},
+    {0x8640,0xeb},
+    {0x8641,0x99},
+    {0x8642,0xfb},
+    {0x8643,0x0f},
+    {0x8644,0xd8},
+    {0x8645,0xe5},
+    {0x8646,0xe4},
+    {0x8647,0xf9},
+    {0x8648,0xfa},
+    {0x8649,0x22},
+    {0x864a,0x78},
+    {0x864b,0x18},
+    {0x864c,0xef},
+    {0x864d,0x2f},
+    {0x864e,0xff},
+    {0x864f,0xee},
+    {0x8650,0x33},
+    {0x8651,0xfe},
+    {0x8652,0xed},
+    {0x8653,0x33},
+    {0x8654,0xfd},
+    {0x8655,0xec},
+    {0x8656,0x33},
+    {0x8657,0xfc},
+    {0x8658,0xc9},
+    {0x8659,0x33},
+    {0x865a,0xc9},
+    {0x865b,0x10},
+    {0x865c,0xd7},
+    {0x865d,0x05},
+    {0x865e,0x9b},
+    {0x865f,0xe9},
+    {0x8660,0x9a},
+    {0x8661,0x40},
+    {0x8662,0x07},
+    {0x8663,0xec},
+    {0x8664,0x9b},
+    {0x8665,0xfc},
+    {0x8666,0xe9},
+    {0x8667,0x9a},
+    {0x8668,0xf9},
+    {0x8669,0x0f},
+    {0x866a,0xd8},
+    {0x866b,0xe0},
+    {0x866c,0xe4},
+    {0x866d,0xc9},
+    {0x866e,0xfa},
+    {0x866f,0xe4},
+    {0x8670,0xcc},
+    {0x8671,0xfb},
+    {0x8672,0x22},
+    {0x8673,0x75},
+    {0x8674,0xf0},
+    {0x8675,0x10},
+    {0x8676,0xef},
+    {0x8677,0x2f},
+    {0x8678,0xff},
+    {0x8679,0xee},
+    {0x867a,0x33},
+    {0x867b,0xfe},
+    {0x867c,0xed},
+    {0x867d,0x33},
+    {0x867e,0xfd},
+    {0x867f,0xcc},
+    {0x8680,0x33},
+    {0x8681,0xcc},
+    {0x8682,0xc8},
+    {0x8683,0x33},
+    {0x8684,0xc8},
+    {0x8685,0x10},
+    {0x8686,0xd7},
+    {0x8687,0x07},
+    {0x8688,0x9b},
+    {0x8689,0xec},
+    {0x868a,0x9a},
+    {0x868b,0xe8},
+    {0x868c,0x99},
+    {0x868d,0x40},
+    {0x868e,0x0a},
+    {0x868f,0xed},
+    {0x8690,0x9b},
+    {0x8691,0xfd},
+    {0x8692,0xec},
+    {0x8693,0x9a},
+    {0x8694,0xfc},
+    {0x8695,0xe8},
+    {0x8696,0x99},
+    {0x8697,0xf8},
+    {0x8698,0x0f},
+    {0x8699,0xd5},
+    {0x869a,0xf0},
+    {0x869b,0xda},
+    {0x869c,0xe4},
+    {0x869d,0xcd},
+    {0x869e,0xfb},
+    {0x869f,0xe4},
+    {0x86a0,0xcc},
+    {0x86a1,0xfa},
+    {0x86a2,0xe4},
+    {0x86a3,0xc8},
+    {0x86a4,0xf9},
+    {0x86a5,0x22},
+    {0x86a6,0xeb},
+    {0x86a7,0x9f},
+    {0x86a8,0xf5},
+    {0x86a9,0xf0},
+    {0x86aa,0xea},
+    {0x86ab,0x9e},
+    {0x86ac,0x42},
+    {0x86ad,0xf0},
+    {0x86ae,0xe9},
+    {0x86af,0x9d},
+    {0x86b0,0x42},
+    {0x86b1,0xf0},
+    {0x86b2,0xe8},
+    {0x86b3,0x9c},
+    {0x86b4,0x45},
+    {0x86b5,0xf0},
+    {0x86b6,0x22},
+    {0x86b7,0xe8},
+    {0x86b8,0x60},
+    {0x86b9,0x0f},
+    {0x86ba,0xec},
+    {0x86bb,0xc3},
+    {0x86bc,0x13},
+    {0x86bd,0xfc},
+    {0x86be,0xed},
+    {0x86bf,0x13},
+    {0x86c0,0xfd},
+    {0x86c1,0xee},
+    {0x86c2,0x13},
+    {0x86c3,0xfe},
+    {0x86c4,0xef},
+    {0x86c5,0x13},
+    {0x86c6,0xff},
+    {0x86c7,0xd8},
+    {0x86c8,0xf1},
+    {0x86c9,0x22},
+    {0x86ca,0xe8},
+    {0x86cb,0x60},
+    {0x86cc,0x0f},
+    {0x86cd,0xef},
+    {0x86ce,0xc3},
+    {0x86cf,0x33},
+    {0x86d0,0xff},
+    {0x86d1,0xee},
+    {0x86d2,0x33},
+    {0x86d3,0xfe},
+    {0x86d4,0xed},
+    {0x86d5,0x33},
+    {0x86d6,0xfd},
+    {0x86d7,0xec},
+    {0x86d8,0x33},
+    {0x86d9,0xfc},
+    {0x86da,0xd8},
+    {0x86db,0xf1},
+    {0x86dc,0x22},
+    {0x86dd,0xe4},
+    {0x86de,0x93},
+    {0x86df,0xfc},
+    {0x86e0,0x74},
+    {0x86e1,0x01},
+    {0x86e2,0x93},
+    {0x86e3,0xfd},
+    {0x86e4,0x74},
+    {0x86e5,0x02},
+    {0x86e6,0x93},
+    {0x86e7,0xfe},
+    {0x86e8,0x74},
+    {0x86e9,0x03},
+    {0x86ea,0x93},
+    {0x86eb,0xff},
+    {0x86ec,0x22},
+    {0x86ed,0xe6},
+    {0x86ee,0xfb},
+    {0x86ef,0x08},
+    {0x86f0,0xe6},
+    {0x86f1,0xf9},
+    {0x86f2,0x08},
+    {0x86f3,0xe6},
+    {0x86f4,0xfa},
+    {0x86f5,0x08},
+    {0x86f6,0xe6},
+    {0x86f7,0xcb},
+    {0x86f8,0xf8},
+    {0x86f9,0x22},
+    {0x86fa,0xec},
+    {0x86fb,0xf6},
+    {0x86fc,0x08},
+    {0x86fd,0xed},
+    {0x86fe,0xf6},
+    {0x86ff,0x08},
+    {0x8700,0xee},
+    {0x8701,0xf6},
+    {0x8702,0x08},
+    {0x8703,0xef},
+    {0x8704,0xf6},
+    {0x8705,0x22},
+    {0x8706,0xa4},
+    {0x8707,0x25},
+    {0x8708,0x82},
+    {0x8709,0xf5},
+    {0x870a,0x82},
+    {0x870b,0xe5},
+    {0x870c,0xf0},
+    {0x870d,0x35},
+    {0x870e,0x83},
+    {0x870f,0xf5},
+    {0x8710,0x83},
+    {0x8711,0x22},
+    {0x8712,0xd0},
+    {0x8713,0x83},
+    {0x8714,0xd0},
+    {0x8715,0x82},
+    {0x8716,0xf8},
+    {0x8717,0xe4},
+    {0x8718,0x93},
+    {0x8719,0x70},
+    {0x871a,0x12},
+    {0x871b,0x74},
+    {0x871c,0x01},
+    {0x871d,0x93},
+    {0x871e,0x70},
+    {0x871f,0x0d},
+    {0x8720,0xa3},
+    {0x8721,0xa3},
+    {0x8722,0x93},
+    {0x8723,0xf8},
+    {0x8724,0x74},
+    {0x8725,0x01},
+    {0x8726,0x93},
+    {0x8727,0xf5},
+    {0x8728,0x82},
+    {0x8729,0x88},
+    {0x872a,0x83},
+    {0x872b,0xe4},
+    {0x872c,0x73},
+    {0x872d,0x74},
+    {0x872e,0x02},
+    {0x872f,0x93},
+    {0x8730,0x68},
+    {0x8731,0x60},
+    {0x8732,0xef},
+    {0x8733,0xa3},
+    {0x8734,0xa3},
+    {0x8735,0xa3},
+    {0x8736,0x80},
+    {0x8737,0xdf},
+    {0x8738,0x90},
+    {0x8739,0x38},
+    {0x873a,0x04},
+    {0x873b,0x78},
+    {0x873c,0x52},
+    {0x873d,0x12},
+    {0x873e,0x0b},
+    {0x873f,0x0f},
+    {0x8740,0x90},
+    {0x8741,0x38},
+    {0x8742,0x00},
+    {0x8743,0xe0},
+    {0x8744,0xfe},
+    {0x8745,0xa3},
+    {0x8746,0xe0},
+    {0x8747,0xfd},
+    {0x8748,0xed},
+    {0x8749,0xff},
+    {0x874a,0xc3},
+    {0x874b,0x12},
+    {0x874c,0x0a},
+    {0x874d,0xb0},
+    {0x874e,0x90},
+    {0x874f,0x38},
+    {0x8750,0x10},
+    {0x8751,0x12},
+    {0x8752,0x0a},
+    {0x8753,0xa4},
+    {0x8754,0x90},
+    {0x8755,0x38},
+    {0x8756,0x06},
+    {0x8757,0x78},
+    {0x8758,0x54},
+    {0x8759,0x12},
+    {0x875a,0x0b},
+    {0x875b,0x0f},
+    {0x875c,0x90},
+    {0x875d,0x38},
+    {0x875e,0x02},
+    {0x875f,0xe0},
+    {0x8760,0xfe},
+    {0x8761,0xa3},
+    {0x8762,0xe0},
+    {0x8763,0xfd},
+    {0x8764,0xed},
+    {0x8765,0xff},
+    {0x8766,0xc3},
+    {0x8767,0x12},
+    {0x8768,0x0a},
+    {0x8769,0xb0},
+    {0x876a,0x90},
+    {0x876b,0x38},
+    {0x876c,0x12},
+    {0x876d,0x12},
+    {0x876e,0x0a},
+    {0x876f,0xa4},
+    {0x8770,0xa3},
+    {0x8771,0xe0},
+    {0x8772,0xb4},
+    {0x8773,0x31},
+    {0x8774,0x07},
+    {0x8775,0x78},
+    {0x8776,0x52},
+    {0x8777,0x79},
+    {0x8778,0x52},
+    {0x8779,0x12},
+    {0x877a,0x0b},
+    {0x877b,0x2f},
+    {0x877c,0x90},
+    {0x877d,0x38},
+    {0x877e,0x14},
+    {0x877f,0xe0},
+    {0x8780,0xb4},
+    {0x8781,0x71},
+    {0x8782,0x15},
+    {0x8783,0x78},
+    {0x8784,0x52},
+    {0x8785,0xe6},
+    {0x8786,0xfe},
+    {0x8787,0x08},
+    {0x8788,0xe6},
+    {0x8789,0x78},
+    {0x878a,0x02},
+    {0x878b,0xce},
+    {0x878c,0xc3},
+    {0x878d,0x13},
+    {0x878e,0xce},
+    {0x878f,0x13},
+    {0x8790,0xd8},
+    {0x8791,0xf9},
+    {0x8792,0x79},
+    {0x8793,0x53},
+    {0x8794,0xf7},
+    {0x8795,0xee},
+    {0x8796,0x19},
+    {0x8797,0xf7},
+    {0x8798,0x90},
+    {0x8799,0x38},
+    {0x879a,0x15},
+    {0x879b,0xe0},
+    {0x879c,0xb4},
+    {0x879d,0x31},
+    {0x879e,0x07},
+    {0x879f,0x78},
+    {0x87a0,0x54},
+    {0x87a1,0x79},
+    {0x87a2,0x54},
+    {0x87a3,0x12},
+    {0x87a4,0x0b},
+    {0x87a5,0x2f},
+    {0x87a6,0x90},
+    {0x87a7,0x38},
+    {0x87a8,0x15},
+    {0x87a9,0xe0},
+    {0x87aa,0xb4},
+    {0x87ab,0x71},
+    {0x87ac,0x15},
+    {0x87ad,0x78},
+    {0x87ae,0x54},
+    {0x87af,0xe6},
+    {0x87b0,0xfe},
+    {0x87b1,0x08},
+    {0x87b2,0xe6},
+    {0x87b3,0x78},
+    {0x87b4,0x02},
+    {0x87b5,0xce},
+    {0x87b6,0xc3},
+    {0x87b7,0x13},
+    {0x87b8,0xce},
+    {0x87b9,0x13},
+    {0x87ba,0xd8},
+    {0x87bb,0xf9},
+    {0x87bc,0x79},
+    {0x87bd,0x55},
+    {0x87be,0xf7},
+    {0x87bf,0xee},
+    {0x87c0,0x19},
+    {0x87c1,0xf7},
+    {0x87c2,0x79},
+    {0x87c3,0x52},
+    {0x87c4,0x12},
+    {0x87c5,0x0a},
+    {0x87c6,0xeb},
+    {0x87c7,0x09},
+    {0x87c8,0x12},
+    {0x87c9,0x0a},
+    {0x87ca,0xeb},
+    {0x87cb,0xaf},
+    {0x87cc,0x47},
+    {0x87cd,0x12},
+    {0x87ce,0x0a},
+    {0x87cf,0xc4},
+    {0x87d0,0xe5},
+    {0x87d1,0x44},
+    {0x87d2,0xfb},
+    {0x87d3,0x7a},
+    {0x87d4,0x00},
+    {0x87d5,0xfd},
+    {0x87d6,0x7c},
+    {0x87d7,0x00},
+    {0x87d8,0x12},
+    {0x87d9,0x05},
+    {0x87da,0x34},
+    {0x87db,0x78},
+    {0x87dc,0x5a},
+    {0x87dd,0xa6},
+    {0x87de,0x06},
+    {0x87df,0x08},
+    {0x87e0,0xa6},
+    {0x87e1,0x07},
+    {0x87e2,0xaf},
+    {0x87e3,0x45},
+    {0x87e4,0x12},
+    {0x87e5,0x0a},
+    {0x87e6,0xc4},
+    {0x87e7,0xad},
+    {0x87e8,0x03},
+    {0x87e9,0x7c},
+    {0x87ea,0x00},
+    {0x87eb,0x12},
+    {0x87ec,0x05},
+    {0x87ed,0x34},
+    {0x87ee,0x78},
+    {0x87ef,0x56},
+    {0x87f0,0xa6},
+    {0x87f1,0x06},
+    {0x87f2,0x08},
+    {0x87f3,0xa6},
+    {0x87f4,0x07},
+    {0x87f5,0xaf},
+    {0x87f6,0x48},
+    {0x87f7,0x78},
+    {0x87f8,0x54},
+    {0x87f9,0x12},
+    {0x87fa,0x0a},
+    {0x87fb,0xc6},
+    {0x87fc,0xe5},
+    {0x87fd,0x43},
+    {0x87fe,0xfb},
+    {0x87ff,0xfd},
+    {0x8800,0x7c},
+    {0x8801,0x00},
+    {0x8802,0x12},
+    {0x8803,0x05},
+    {0x8804,0x34},
+    {0x8805,0x78},
+    {0x8806,0x5c},
+    {0x8807,0xa6},
+    {0x8808,0x06},
+    {0x8809,0x08},
+    {0x880a,0xa6},
+    {0x880b,0x07},
+    {0x880c,0xaf},
+    {0x880d,0x46},
+    {0x880e,0x7e},
+    {0x880f,0x00},
+    {0x8810,0x78},
+    {0x8811,0x54},
+    {0x8812,0x12},
+    {0x8813,0x0a},
+    {0x8814,0xc8},
+    {0x8815,0xad},
+    {0x8816,0x03},
+    {0x8817,0x7c},
+    {0x8818,0x00},
+    {0x8819,0x12},
+    {0x881a,0x05},
+    {0x881b,0x34},
+    {0x881c,0x78},
+    {0x881d,0x58},
+    {0x881e,0xa6},
+    {0x881f,0x06},
+    {0x8820,0x08},
+    {0x8821,0xa6},
+    {0x8822,0x07},
+    {0x8823,0xc3},
+    {0x8824,0x78},
+    {0x8825,0x5b},
+    {0x8826,0xe6},
+    {0x8827,0x94},
+    {0x8828,0x08},
+    {0x8829,0x18},
+    {0x882a,0xe6},
+    {0x882b,0x94},
+    {0x882c,0x00},
+    {0x882d,0x50},
+    {0x882e,0x05},
+    {0x882f,0x76},
+    {0x8830,0x00},
+    {0x8831,0x08},
+    {0x8832,0x76},
+    {0x8833,0x08},
+    {0x8834,0xc3},
+    {0x8835,0x78},
+    {0x8836,0x5d},
+    {0x8837,0xe6},
+    {0x8838,0x94},
+    {0x8839,0x08},
+    {0x883a,0x18},
+    {0x883b,0xe6},
+    {0x883c,0x94},
+    {0x883d,0x00},
+    {0x883e,0x50},
+    {0x883f,0x05},
+    {0x8840,0x76},
+    {0x8841,0x00},
+    {0x8842,0x08},
+    {0x8843,0x76},
+    {0x8844,0x08},
+    {0x8845,0x78},
+    {0x8846,0x5a},
+    {0x8847,0x12},
+    {0x8848,0x0a},
+    {0x8849,0xd8},
+    {0x884a,0xff},
+    {0x884b,0xd3},
+    {0x884c,0x78},
+    {0x884d,0x57},
+    {0x884e,0xe6},
+    {0x884f,0x9f},
+    {0x8850,0x18},
+    {0x8851,0xe6},
+    {0x8852,0x9e},
+    {0x8853,0x40},
+    {0x8854,0x0e},
+    {0x8855,0x78},
+    {0x8856,0x5a},
+    {0x8857,0xe6},
+    {0x8858,0x13},
+    {0x8859,0xfe},
+    {0x885a,0x08},
+    {0x885b,0xe6},
+    {0x885c,0x78},
+    {0x885d,0x57},
+    {0x885e,0x12},
+    {0x885f,0x0b},
+    {0x8860,0x1a},
+    {0x8861,0x80},
+    {0x8862,0x04},
+    {0x8863,0x7e},
+    {0x8864,0x00},
+    {0x8865,0x7f},
+    {0x8866,0x00},
+    {0x8867,0x78},
+    {0x8868,0x5e},
+    {0x8869,0x12},
+    {0x886a,0x0a},
+    {0x886b,0xd0},
+    {0x886c,0xff},
+    {0x886d,0xd3},
+    {0x886e,0x78},
+    {0x886f,0x59},
+    {0x8870,0xe6},
+    {0x8871,0x9f},
+    {0x8872,0x18},
+    {0x8873,0xe6},
+    {0x8874,0x9e},
+    {0x8875,0x40},
+    {0x8876,0x0e},
+    {0x8877,0x78},
+    {0x8878,0x5c},
+    {0x8879,0xe6},
+    {0x887a,0x13},
+    {0x887b,0xfe},
+    {0x887c,0x08},
+    {0x887d,0xe6},
+    {0x887e,0x78},
+    {0x887f,0x59},
+    {0x8880,0x12},
+    {0x8881,0x0b},
+    {0x8882,0x1a},
+    {0x8883,0x80},
+    {0x8884,0x04},
+    {0x8885,0x7e},
+    {0x8886,0x00},
+    {0x8887,0x7f},
+    {0x8888,0x00},
+    {0x8889,0xe4},
+    {0x888a,0xfc},
+    {0x888b,0xfd},
+    {0x888c,0x78},
+    {0x888d,0x62},
+    {0x888e,0x12},
+    {0x888f,0x06},
+    {0x8890,0xfa},
+    {0x8891,0x78},
+    {0x8892,0x5a},
+    {0x8893,0x12},
+    {0x8894,0x0a},
+    {0x8895,0xd8},
+    {0x8896,0x78},
+    {0x8897,0x57},
+    {0x8898,0x26},
+    {0x8899,0xff},
+    {0x889a,0xee},
+    {0x889b,0x18},
+    {0x889c,0x36},
+    {0x889d,0xfe},
+    {0x889e,0x78},
+    {0x889f,0x66},
+    {0x88a0,0x12},
+    {0x88a1,0x0a},
+    {0x88a2,0xd0},
+    {0x88a3,0x78},
+    {0x88a4,0x59},
+    {0x88a5,0x26},
+    {0x88a6,0xff},
+    {0x88a7,0xee},
+    {0x88a8,0x18},
+    {0x88a9,0x36},
+    {0x88aa,0xfe},
+    {0x88ab,0xe4},
+    {0x88ac,0xfc},
+    {0x88ad,0xfd},
+    {0x88ae,0x78},
+    {0x88af,0x6a},
+    {0x88b0,0x12},
+    {0x88b1,0x06},
+    {0x88b2,0xfa},
+    {0x88b3,0x12},
+    {0x88b4,0x0a},
+    {0x88b5,0xe0},
+    {0x88b6,0x78},
+    {0x88b7,0x66},
+    {0x88b8,0x12},
+    {0x88b9,0x06},
+    {0x88ba,0xed},
+    {0x88bb,0xd3},
+    {0x88bc,0x12},
+    {0x88bd,0x06},
+    {0x88be,0xa6},
+    {0x88bf,0x40},
+    {0x88c0,0x08},
+    {0x88c1,0x12},
+    {0x88c2,0x0a},
+    {0x88c3,0xe0},
+    {0x88c4,0x78},
+    {0x88c5,0x66},
+    {0x88c6,0x12},
+    {0x88c7,0x06},
+    {0x88c8,0xfa},
+    {0x88c9,0x78},
+    {0x88ca,0x54},
+    {0x88cb,0x12},
+    {0x88cc,0x0a},
+    {0x88cd,0xe2},
+    {0x88ce,0x78},
+    {0x88cf,0x6a},
+    {0x88d0,0x12},
+    {0x88d1,0x06},
+    {0x88d2,0xed},
+    {0x88d3,0xd3},
+    {0x88d4,0x12},
+    {0x88d5,0x06},
+    {0x88d6,0xa6},
+    {0x88d7,0x40},
+    {0x88d8,0x0a},
+    {0x88d9,0x78},
+    {0x88da,0x54},
+    {0x88db,0x12},
+    {0x88dc,0x0a},
+    {0x88dd,0xe2},
+    {0x88de,0x78},
+    {0x88df,0x6a},
+    {0x88e0,0x12},
+    {0x88e1,0x06},
+    {0x88e2,0xfa},
+    {0x88e3,0x78},
+    {0x88e4,0x61},
+    {0x88e5,0xe6},
+    {0x88e6,0x90},
+    {0x88e7,0x60},
+    {0x88e8,0x01},
+    {0x88e9,0xf0},
+    {0x88ea,0x78},
+    {0x88eb,0x65},
+    {0x88ec,0xe6},
+    {0x88ed,0xa3},
+    {0x88ee,0xf0},
+    {0x88ef,0x78},
+    {0x88f0,0x69},
+    {0x88f1,0xe6},
+    {0x88f2,0xa3},
+    {0x88f3,0xf0},
+    {0x88f4,0x78},
+    {0x88f5,0x55},
+    {0x88f6,0xe6},
+    {0x88f7,0xa3},
+    {0x88f8,0xf0},
+    {0x88f9,0x7d},
+    {0x88fa,0x01},
+    {0x88fb,0x78},
+    {0x88fc,0x61},
+    {0x88fd,0x12},
+    {0x88fe,0x0a},
+    {0x88ff,0xfb},
+    {0x8900,0x24},
+    {0x8901,0x01},
+    {0x8902,0x12},
+    {0x8903,0x0a},
+    {0x8904,0xb8},
+    {0x8905,0x78},
+    {0x8906,0x65},
+    {0x8907,0x12},
+    {0x8908,0x0a},
+    {0x8909,0xfb},
+    {0x890a,0x24},
+    {0x890b,0x02},
+    {0x890c,0x12},
+    {0x890d,0x0a},
+    {0x890e,0xb8},
+    {0x890f,0x78},
+    {0x8910,0x69},
+    {0x8911,0x12},
+    {0x8912,0x0a},
+    {0x8913,0xfb},
+    {0x8914,0x24},
+    {0x8915,0x03},
+    {0x8916,0x12},
+    {0x8917,0x0a},
+    {0x8918,0xb8},
+    {0x8919,0x78},
+    {0x891a,0x6d},
+    {0x891b,0x12},
+    {0x891c,0x0a},
+    {0x891d,0xfb},
+    {0x891e,0x24},
+    {0x891f,0x04},
+    {0x8920,0x12},
+    {0x8921,0x0a},
+    {0x8922,0xb8},
+    {0x8923,0x0d},
+    {0x8924,0xbd},
+    {0x8925,0x05},
+    {0x8926,0xd4},
+    {0x8927,0x22},
+    {0x8928,0xc0},
+    {0x8929,0xe0},
+    {0x892a,0xc0},
+    {0x892b,0x83},
+    {0x892c,0xc0},
+    {0x892d,0x82},
+    {0x892e,0xc0},
+    {0x892f,0xd0},
+    {0x8930,0x90},
+    {0x8931,0x3f},
+    {0x8932,0x0c},
+    {0x8933,0xe0},
+    {0x8934,0xf5},
+    {0x8935,0x32},
+    {0x8936,0xe5},
+    {0x8937,0x32},
+    {0x8938,0x30},
+    {0x8939,0xe3},
+    {0x893a,0x74},
+    {0x893b,0x30},
+    {0x893c,0x36},
+    {0x893d,0x66},
+    {0x893e,0x90},
+    {0x893f,0x60},
+    {0x8940,0x19},
+    {0x8941,0xe0},
+    {0x8942,0xf5},
+    {0x8943,0x0a},
+    {0x8944,0xa3},
+    {0x8945,0xe0},
+    {0x8946,0xf5},
+    {0x8947,0x0b},
+    {0x8948,0x90},
+    {0x8949,0x60},
+    {0x894a,0x1d},
+    {0x894b,0xe0},
+    {0x894c,0xf5},
+    {0x894d,0x14},
+    {0x894e,0xa3},
+    {0x894f,0xe0},
+    {0x8950,0xf5},
+    {0x8951,0x15},
+    {0x8952,0x90},
+    {0x8953,0x60},
+    {0x8954,0x21},
+    {0x8955,0xe0},
+    {0x8956,0xf5},
+    {0x8957,0x0c},
+    {0x8958,0xa3},
+    {0x8959,0xe0},
+    {0x895a,0xf5},
+    {0x895b,0x0d},
+    {0x895c,0x90},
+    {0x895d,0x60},
+    {0x895e,0x29},
+    {0x895f,0xe0},
+    {0x8960,0xf5},
+    {0x8961,0x0e},
+    {0x8962,0xa3},
+    {0x8963,0xe0},
+    {0x8964,0xf5},
+    {0x8965,0x0f},
+    {0x8966,0x90},
+    {0x8967,0x60},
+    {0x8968,0x31},
+    {0x8969,0xe0},
+    {0x896a,0xf5},
+    {0x896b,0x10},
+    {0x896c,0xa3},
+    {0x896d,0xe0},
+    {0x896e,0xf5},
+    {0x896f,0x11},
+    {0x8970,0x90},
+    {0x8971,0x60},
+    {0x8972,0x39},
+    {0x8973,0xe0},
+    {0x8974,0xf5},
+    {0x8975,0x12},
+    {0x8976,0xa3},
+    {0x8977,0xe0},
+    {0x8978,0xf5},
+    {0x8979,0x13},
+    {0x897a,0x30},
+    {0x897b,0x01},
+    {0x897c,0x06},
+    {0x897d,0x30},
+    {0x897e,0x33},
+    {0x897f,0x03},
+    {0x8980,0xd3},
+    {0x8981,0x80},
+    {0x8982,0x01},
+    {0x8983,0xc3},
+    {0x8984,0x92},
+    {0x8985,0x09},
+    {0x8986,0x30},
+    {0x8987,0x02},
+    {0x8988,0x06},
+    {0x8989,0x30},
+    {0x898a,0x33},
+    {0x898b,0x03},
+    {0x898c,0xd3},
+    {0x898d,0x80},
+    {0x898e,0x01},
+    {0x898f,0xc3},
+    {0x8990,0x92},
+    {0x8991,0x0a},
+    {0x8992,0x30},
+    {0x8993,0x33},
+    {0x8994,0x0c},
+    {0x8995,0x30},
+    {0x8996,0x03},
+    {0x8997,0x09},
+    {0x8998,0x20},
+    {0x8999,0x02},
+    {0x899a,0x06},
+    {0x899b,0x20},
+    {0x899c,0x01},
+    {0x899d,0x03},
+    {0x899e,0xd3},
+    {0x899f,0x80},
+    {0x89a0,0x01},
+    {0x89a1,0xc3},
+    {0x89a2,0x92},
+    {0x89a3,0x0b},
+    {0x89a4,0x90},
+    {0x89a5,0x30},
+    {0x89a6,0x01},
+    {0x89a7,0xe0},
+    {0x89a8,0x44},
+    {0x89a9,0x40},
+    {0x89aa,0xf0},
+    {0x89ab,0xe0},
+    {0x89ac,0x54},
+    {0x89ad,0xbf},
+    {0x89ae,0xf0},
+    {0x89af,0xe5},
+    {0x89b0,0x32},
+    {0x89b1,0x30},
+    {0x89b2,0xe1},
+    {0x89b3,0x14},
+    {0x89b4,0x30},
+    {0x89b5,0x34},
+    {0x89b6,0x11},
+    {0x89b7,0x90},
+    {0x89b8,0x30},
+    {0x89b9,0x22},
+    {0x89ba,0xe0},
+    {0x89bb,0xf5},
+    {0x89bc,0x08},
+    {0x89bd,0xe4},
+    {0x89be,0xf0},
+    {0x89bf,0x30},
+    {0x89c0,0x00},
+    {0x89c1,0x03},
+    {0x89c2,0xd3},
+    {0x89c3,0x80},
+    {0x89c4,0x01},
+    {0x89c5,0xc3},
+    {0x89c6,0x92},
+    {0x89c7,0x08},
+    {0x89c8,0xe5},
+    {0x89c9,0x32},
+    {0x89ca,0x30},
+    {0x89cb,0xe5},
+    {0x89cc,0x12},
+    {0x89cd,0x90},
+    {0x89ce,0x56},
+    {0x89cf,0xa1},
+    {0x89d0,0xe0},
+    {0x89d1,0xf5},
+    {0x89d2,0x09},
+    {0x89d3,0x30},
+    {0x89d4,0x31},
+    {0x89d5,0x09},
+    {0x89d6,0x30},
+    {0x89d7,0x05},
+    {0x89d8,0x03},
+    {0x89d9,0xd3},
+    {0x89da,0x80},
+    {0x89db,0x01},
+    {0x89dc,0xc3},
+    {0x89dd,0x92},
+    {0x89de,0x0d},
+    {0x89df,0x90},
+    {0x89e0,0x3f},
+    {0x89e1,0x0c},
+    {0x89e2,0xe5},
+    {0x89e3,0x32},
+    {0x89e4,0xf0},
+    {0x89e5,0xd0},
+    {0x89e6,0xd0},
+    {0x89e7,0xd0},
+    {0x89e8,0x82},
+    {0x89e9,0xd0},
+    {0x89ea,0x83},
+    {0x89eb,0xd0},
+    {0x89ec,0xe0},
+    {0x89ed,0x32},
+    {0x89ee,0x85},
+    {0x89ef,0x08},
+    {0x89f0,0x41},
+    {0x89f1,0x90},
+    {0x89f2,0x30},
+    {0x89f3,0x24},
+    {0x89f4,0xe0},
+    {0x89f5,0xf5},
+    {0x89f6,0x3d},
+    {0x89f7,0xa3},
+    {0x89f8,0xe0},
+    {0x89f9,0xf5},
+    {0x89fa,0x3e},
+    {0x89fb,0xa3},
+    {0x89fc,0xe0},
+    {0x89fd,0xf5},
+    {0x89fe,0x3f},
+    {0x89ff,0xa3},
+    {0x8a00,0xe0},
+    {0x8a01,0xf5},
+    {0x8a02,0x40},
+    {0x8a03,0xa3},
+    {0x8a04,0xe0},
+    {0x8a05,0xf5},
+    {0x8a06,0x3c},
+    {0x8a07,0xd2},
+    {0x8a08,0x34},
+    {0x8a09,0xe5},
+    {0x8a0a,0x41},
+    {0x8a0b,0x12},
+    {0x8a0c,0x07},
+    {0x8a0d,0x12},
+    {0x8a0e,0x0a},
+    {0x8a0f,0x33},
+    {0x8a10,0x03},
+    {0x8a11,0x0a},
+    {0x8a12,0x40},
+    {0x8a13,0x04},
+    {0x8a14,0x0a},
+    {0x8a15,0x51},
+    {0x8a16,0x05},
+    {0x8a17,0x0a},
+    {0x8a18,0x54},
+    {0x8a19,0x06},
+    {0x8a1a,0x0a},
+    {0x8a1b,0x5d},
+    {0x8a1c,0x08},
+    {0x8a1d,0x0a},
+    {0x8a1e,0x6d},
+    {0x8a1f,0x12},
+    {0x8a20,0x0a},
+    {0x8a21,0x72},
+    {0x8a22,0x1a},
+    {0x8a23,0x0a},
+    {0x8a24,0x7d},
+    {0x8a25,0x1b},
+    {0x8a26,0x0a},
+    {0x8a27,0x6d},
+    {0x8a28,0x80},
+    {0x8a29,0x0a},
+    {0x8a2a,0x6d},
+    {0x8a2b,0x81},
+    {0x8a2c,0x0a},
+    {0x8a2d,0x85},
+    {0x8a2e,0xec},
+    {0x8a2f,0x00},
+    {0x8a30,0x00},
+    {0x8a31,0x0a},
+    {0x8a32,0xa3},
+    {0x8a33,0x12},
+    {0x8a34,0x0f},
+    {0x8a35,0xd2},
+    {0x8a36,0xd2},
+    {0x8a37,0x36},
+    {0x8a38,0xd2},
+    {0x8a39,0x01},
+    {0x8a3a,0xc2},
+    {0x8a3b,0x02},
+    {0x8a3c,0x12},
+    {0x8a3d,0x0f},
+    {0x8a3e,0xd7},
+    {0x8a3f,0x22},
+    {0x8a40,0xd2},
+    {0x8a41,0x33},
+    {0x8a42,0xd2},
+    {0x8a43,0x36},
+    {0x8a44,0xe5},
+    {0x8a45,0x3d},
+    {0x8a46,0xd3},
+    {0x8a47,0x94},
+    {0x8a48,0x00},
+    {0x8a49,0x40},
+    {0x8a4a,0x03},
+    {0x8a4b,0x12},
+    {0x8a4c,0x0f},
+    {0x8a4d,0xd2},
+    {0x8a4e,0xd2},
+    {0x8a4f,0x03},
+    {0x8a50,0x22},
+    {0x8a51,0xd2},
+    {0x8a52,0x03},
+    {0x8a53,0x22},
+    {0x8a54,0xc2},
+    {0x8a55,0x03},
+    {0x8a56,0x20},
+    {0x8a57,0x01},
+    {0x8a58,0x4a},
+    {0x8a59,0x30},
+    {0x8a5a,0x02},
+    {0x8a5b,0x2c},
+    {0x8a5c,0x22},
+    {0x8a5d,0xc2},
+    {0x8a5e,0x01},
+    {0x8a5f,0xc2},
+    {0x8a60,0x02},
+    {0x8a61,0xc2},
+    {0x8a62,0x03},
+    {0x8a63,0x12},
+    {0x8a64,0x0d},
+    {0x8a65,0x39},
+    {0x8a66,0x75},
+    {0x8a67,0x1e},
+    {0x8a68,0x70},
+    {0x8a69,0xd2},
+    {0x8a6a,0x35},
+    {0x8a6b,0x80},
+    {0x8a6c,0x1b},
+    {0x8a6d,0x12},
+    {0x8a6e,0x0b},
+    {0x8a6f,0xcc},
+    {0x8a70,0x80},
+    {0x8a71,0x16},
+    {0x8a72,0x85},
+    {0x8a73,0x40},
+    {0x8a74,0x4a},
+    {0x8a75,0x85},
+    {0x8a76,0x3c},
+    {0x8a77,0x4b},
+    {0x8a78,0x12},
+    {0x8a79,0x0b},
+    {0x8a7a,0x39},
+    {0x8a7b,0x80},
+    {0x8a7c,0x0b},
+    {0x8a7d,0x85},
+    {0x8a7e,0x4a},
+    {0x8a7f,0x40},
+    {0x8a80,0x85},
+    {0x8a81,0x4b},
+    {0x8a82,0x3c},
+    {0x8a83,0x80},
+    {0x8a84,0x03},
+    {0x8a85,0x12},
+    {0x8a86,0x0f},
+    {0x8a87,0x00},
+    {0x8a88,0x90},
+    {0x8a89,0x30},
+    {0x8a8a,0x24},
+    {0x8a8b,0xe5},
+    {0x8a8c,0x3d},
+    {0x8a8d,0xf0},
+    {0x8a8e,0xa3},
+    {0x8a8f,0xe5},
+    {0x8a90,0x3e},
+    {0x8a91,0xf0},
+    {0x8a92,0xa3},
+    {0x8a93,0xe5},
+    {0x8a94,0x3f},
+    {0x8a95,0xf0},
+    {0x8a96,0xa3},
+    {0x8a97,0xe5},
+    {0x8a98,0x40},
+    {0x8a99,0xf0},
+    {0x8a9a,0xa3},
+    {0x8a9b,0xe5},
+    {0x8a9c,0x3c},
+    {0x8a9d,0xf0},
+    {0x8a9e,0x90},
+    {0x8a9f,0x30},
+    {0x8aa0,0x23},
+    {0x8aa1,0xe4},
+    {0x8aa2,0xf0},
+    {0x8aa3,0x22},
+    {0x8aa4,0xe0},
+    {0x8aa5,0xa3},
+    {0x8aa6,0xe0},
+    {0x8aa7,0x75},
+    {0x8aa8,0xf0},
+    {0x8aa9,0x02},
+    {0x8aaa,0xa4},
+    {0x8aab,0xff},
+    {0x8aac,0xae},
+    {0x8aad,0xf0},
+    {0x8aae,0xc3},
+    {0x8aaf,0x08},
+    {0x8ab0,0xe6},
+    {0x8ab1,0x9f},
+    {0x8ab2,0xf6},
+    {0x8ab3,0x18},
+    {0x8ab4,0xe6},
+    {0x8ab5,0x9e},
+    {0x8ab6,0xf6},
+    {0x8ab7,0x22},
+    {0x8ab8,0xff},
+    {0x8ab9,0xe5},
+    {0x8aba,0xf0},
+    {0x8abb,0x34},
+    {0x8abc,0x60},
+    {0x8abd,0x8f},
+    {0x8abe,0x82},
+    {0x8abf,0xf5},
+    {0x8ac0,0x83},
+    {0x8ac1,0xec},
+    {0x8ac2,0xf0},
+    {0x8ac3,0x22},
+    {0x8ac4,0x78},
+    {0x8ac5,0x52},
+    {0x8ac6,0x7e},
+    {0x8ac7,0x00},
+    {0x8ac8,0xe6},
+    {0x8ac9,0xfc},
+    {0x8aca,0x08},
+    {0x8acb,0xe6},
+    {0x8acc,0xfd},
+    {0x8acd,0x02},
+    {0x8ace,0x05},
+    {0x8acf,0x22},
+    {0x8ad0,0xe4},
+    {0x8ad1,0xfc},
+    {0x8ad2,0xfd},
+    {0x8ad3,0x12},
+    {0x8ad4,0x06},
+    {0x8ad5,0xfa},
+    {0x8ad6,0x78},
+    {0x8ad7,0x5c},
+    {0x8ad8,0xe6},
+    {0x8ad9,0xc3},
+    {0x8ada,0x13},
+    {0x8adb,0xfe},
+    {0x8adc,0x08},
+    {0x8add,0xe6},
+    {0x8ade,0x13},
+    {0x8adf,0x22},
+    {0x8ae0,0x78},
+    {0x8ae1,0x52},
+    {0x8ae2,0xe6},
+    {0x8ae3,0xfe},
+    {0x8ae4,0x08},
+    {0x8ae5,0xe6},
+    {0x8ae6,0xff},
+    {0x8ae7,0xe4},
+    {0x8ae8,0xfc},
+    {0x8ae9,0xfd},
+    {0x8aea,0x22},
+    {0x8aeb,0xe7},
+    {0x8aec,0xc4},
+    {0x8aed,0xf8},
+    {0x8aee,0x54},
+    {0x8aef,0xf0},
+    {0x8af0,0xc8},
+    {0x8af1,0x68},
+    {0x8af2,0xf7},
+    {0x8af3,0x09},
+    {0x8af4,0xe7},
+    {0x8af5,0xc4},
+    {0x8af6,0x54},
+    {0x8af7,0x0f},
+    {0x8af8,0x48},
+    {0x8af9,0xf7},
+    {0x8afa,0x22},
+    {0x8afb,0xe6},
+    {0x8afc,0xfc},
+    {0x8afd,0xed},
+    {0x8afe,0x75},
+    {0x8aff,0xf0},
+    {0x8b00,0x04},
+    {0x8b01,0xa4},
+    {0x8b02,0x22},
+    {0x8b03,0x12},
+    {0x8b04,0x06},
+    {0x8b05,0xdd},
+    {0x8b06,0x8f},
+    {0x8b07,0x48},
+    {0x8b08,0x8e},
+    {0x8b09,0x47},
+    {0x8b0a,0x8d},
+    {0x8b0b,0x46},
+    {0x8b0c,0x8c},
+    {0x8b0d,0x45},
+    {0x8b0e,0x22},
+    {0x8b0f,0xe0},
+    {0x8b10,0xfe},
+    {0x8b11,0xa3},
+    {0x8b12,0xe0},
+    {0x8b13,0xfd},
+    {0x8b14,0xee},
+    {0x8b15,0xf6},
+    {0x8b16,0xed},
+    {0x8b17,0x08},
+    {0x8b18,0xf6},
+    {0x8b19,0x22},
+    {0x8b1a,0x13},
+    {0x8b1b,0xff},
+    {0x8b1c,0xc3},
+    {0x8b1d,0xe6},
+    {0x8b1e,0x9f},
+    {0x8b1f,0xff},
+    {0x8b20,0x18},
+    {0x8b21,0xe6},
+    {0x8b22,0x9e},
+    {0x8b23,0xfe},
+    {0x8b24,0x22},
+    {0x8b25,0xfb},
+    {0x8b26,0xd3},
+    {0x8b27,0xed},
+    {0x8b28,0x9b},
+    {0x8b29,0x74},
+    {0x8b2a,0x80},
+    {0x8b2b,0xf8},
+    {0x8b2c,0x6c},
+    {0x8b2d,0x98},
+    {0x8b2e,0x22},
+    {0x8b2f,0xe6},
+    {0x8b30,0xc3},
+    {0x8b31,0x13},
+    {0x8b32,0xf7},
+    {0x8b33,0x08},
+    {0x8b34,0xe6},
+    {0x8b35,0x13},
+    {0x8b36,0x09},
+    {0x8b37,0xf7},
+    {0x8b38,0x22},
+    {0x8b39,0x90},
+    {0x8b3a,0x0e},
+    {0x8b3b,0x7e},
+    {0x8b3c,0xe4},
+    {0x8b3d,0x93},
+    {0x8b3e,0xfe},
+    {0x8b3f,0x74},
+    {0x8b40,0x01},
+    {0x8b41,0x93},
+    {0x8b42,0xff},
+    {0x8b43,0xc3},
+    {0x8b44,0x90},
+    {0x8b45,0x0e},
+    {0x8b46,0x7c},
+    {0x8b47,0x74},
+    {0x8b48,0x01},
+    {0x8b49,0x93},
+    {0x8b4a,0x9f},
+    {0x8b4b,0xff},
+    {0x8b4c,0xe4},
+    {0x8b4d,0x93},
+    {0x8b4e,0x9e},
+    {0x8b4f,0xfe},
+    {0x8b50,0xe4},
+    {0x8b51,0x8f},
+    {0x8b52,0x3b},
+    {0x8b53,0x8e},
+    {0x8b54,0x3a},
+    {0x8b55,0xf5},
+    {0x8b56,0x39},
+    {0x8b57,0xf5},
+    {0x8b58,0x38},
+    {0x8b59,0xab},
+    {0x8b5a,0x3b},
+    {0x8b5b,0xaa},
+    {0x8b5c,0x3a},
+    {0x8b5d,0xa9},
+    {0x8b5e,0x39},
+    {0x8b5f,0xa8},
+    {0x8b60,0x38},
+    {0x8b61,0xaf},
+    {0x8b62,0x4b},
+    {0x8b63,0xfc},
+    {0x8b64,0xfd},
+    {0x8b65,0xfe},
+    {0x8b66,0x12},
+    {0x8b67,0x05},
+    {0x8b68,0x89},
+    {0x8b69,0x12},
+    {0x8b6a,0x0f},
+    {0x8b6b,0x91},
+    {0x8b6c,0xe4},
+    {0x8b6d,0x7b},
+    {0x8b6e,0xff},
+    {0x8b6f,0xfa},
+    {0x8b70,0xf9},
+    {0x8b71,0xf8},
+    {0x8b72,0x12},
+    {0x8b73,0x06},
+    {0x8b74,0x14},
+    {0x8b75,0x12},
+    {0x8b76,0x0f},
+    {0x8b77,0x91},
+    {0x8b78,0x90},
+    {0x8b79,0x0e},
+    {0x8b7a,0x69},
+    {0x8b7b,0xe4},
+    {0x8b7c,0x12},
+    {0x8b7d,0x0f},
+    {0x8b7e,0xa6},
+    {0x8b7f,0x12},
+    {0x8b80,0x0f},
+    {0x8b81,0x91},
+    {0x8b82,0xe4},
+    {0x8b83,0x85},
+    {0x8b84,0x4a},
+    {0x8b85,0x37},
+    {0x8b86,0xf5},
+    {0x8b87,0x36},
+    {0x8b88,0xf5},
+    {0x8b89,0x35},
+    {0x8b8a,0xf5},
+    {0x8b8b,0x34},
+    {0x8b8c,0xaf},
+    {0x8b8d,0x37},
+    {0x8b8e,0xae},
+    {0x8b8f,0x36},
+    {0x8b90,0xad},
+    {0x8b91,0x35},
+    {0x8b92,0xac},
+    {0x8b93,0x34},
+    {0x8b94,0xa3},
+    {0x8b95,0x12},
+    {0x8b96,0x0f},
+    {0x8b97,0xa6},
+    {0x8b98,0x8f},
+    {0x8b99,0x37},
+    {0x8b9a,0x8e},
+    {0x8b9b,0x36},
+    {0x8b9c,0x8d},
+    {0x8b9d,0x35},
+    {0x8b9e,0x8c},
+    {0x8b9f,0x34},
+    {0x8ba0,0xe5},
+    {0x8ba1,0x3b},
+    {0x8ba2,0x45},
+    {0x8ba3,0x37},
+    {0x8ba4,0xf5},
+    {0x8ba5,0x3b},
+    {0x8ba6,0xe5},
+    {0x8ba7,0x3a},
+    {0x8ba8,0x45},
+    {0x8ba9,0x36},
+    {0x8baa,0xf5},
+    {0x8bab,0x3a},
+    {0x8bac,0xe5},
+    {0x8bad,0x39},
+    {0x8bae,0x45},
+    {0x8baf,0x35},
+    {0x8bb0,0xf5},
+    {0x8bb1,0x39},
+    {0x8bb2,0xe5},
+    {0x8bb3,0x38},
+    {0x8bb4,0x45},
+    {0x8bb5,0x34},
+    {0x8bb6,0xf5},
+    {0x8bb7,0x38},
+    {0x8bb8,0xe4},
+    {0x8bb9,0xf5},
+    {0x8bba,0x22},
+    {0x8bbb,0xf5},
+    {0x8bbc,0x23},
+    {0x8bbd,0x85},
+    {0x8bbe,0x3b},
+    {0x8bbf,0x31},
+    {0x8bc0,0x85},
+    {0x8bc1,0x3a},
+    {0x8bc2,0x30},
+    {0x8bc3,0x85},
+    {0x8bc4,0x39},
+    {0x8bc5,0x2f},
+    {0x8bc6,0x85},
+    {0x8bc7,0x38},
+    {0x8bc8,0x2e},
+    {0x8bc9,0x02},
+    {0x8bca,0x0f},
+    {0x8bcb,0x63},
+    {0x8bcc,0xe5},
+    {0x8bcd,0x3c},
+    {0x8bce,0xd3},
+    {0x8bcf,0x94},
+    {0x8bd0,0x01},
+    {0x8bd1,0x40},
+    {0x8bd2,0x0b},
+    {0x8bd3,0x90},
+    {0x8bd4,0x0e},
+    {0x8bd5,0x88},
+    {0x8bd6,0x12},
+    {0x8bd7,0x0b},
+    {0x8bd8,0x03},
+    {0x8bd9,0x90},
+    {0x8bda,0x0e},
+    {0x8bdb,0x86},
+    {0x8bdc,0x80},
+    {0x8bdd,0x09},
+    {0x8bde,0x90},
+    {0x8bdf,0x0e},
+    {0x8be0,0x82},
+    {0x8be1,0x12},
+    {0x8be2,0x0b},
+    {0x8be3,0x03},
+    {0x8be4,0x90},
+    {0x8be5,0x0e},
+    {0x8be6,0x80},
+    {0x8be7,0xe4},
+    {0x8be8,0x93},
+    {0x8be9,0xf5},
+    {0x8bea,0x44},
+    {0x8beb,0xa3},
+    {0x8bec,0xe4},
+    {0x8bed,0x93},
+    {0x8bee,0xf5},
+    {0x8bef,0x43},
+    {0x8bf0,0xe5},
+    {0x8bf1,0x3c},
+    {0x8bf2,0xd3},
+    {0x8bf3,0x94},
+    {0x8bf4,0x00},
+    {0x8bf5,0x40},
+    {0x8bf6,0x06},
+    {0x8bf7,0x85},
+    {0x8bf8,0x3d},
+    {0x8bf9,0x45},
+    {0x8bfa,0x85},
+    {0x8bfb,0x3e},
+    {0x8bfc,0x46},
+    {0x8bfd,0xe5},
+    {0x8bfe,0x47},
+    {0x8bff,0xc3},
+    {0x8c00,0x13},
+    {0x8c01,0xff},
+    {0x8c02,0xe5},
+    {0x8c03,0x45},
+    {0x8c04,0xc3},
+    {0x8c05,0x9f},
+    {0x8c06,0x50},
+    {0x8c07,0x02},
+    {0x8c08,0x8f},
+    {0x8c09,0x45},
+    {0x8c0a,0xe5},
+    {0x8c0b,0x48},
+    {0x8c0c,0xc3},
+    {0x8c0d,0x13},
+    {0x8c0e,0xff},
+    {0x8c0f,0xe5},
+    {0x8c10,0x46},
+    {0x8c11,0xc3},
+    {0x8c12,0x9f},
+    {0x8c13,0x50},
+    {0x8c14,0x02},
+    {0x8c15,0x8f},
+    {0x8c16,0x46},
+    {0x8c17,0xe5},
+    {0x8c18,0x47},
+    {0x8c19,0xc3},
+    {0x8c1a,0x13},
+    {0x8c1b,0xff},
+    {0x8c1c,0xfd},
+    {0x8c1d,0xe5},
+    {0x8c1e,0x45},
+    {0x8c1f,0x2d},
+    {0x8c20,0xfd},
+    {0x8c21,0xe4},
+    {0x8c22,0x33},
+    {0x8c23,0xfc},
+    {0x8c24,0xe5},
+    {0x8c25,0x44},
+    {0x8c26,0x12},
+    {0x8c27,0x0b},
+    {0x8c28,0x25},
+    {0x8c29,0x40},
+    {0x8c2a,0x05},
+    {0x8c2b,0xe5},
+    {0x8c2c,0x44},
+    {0x8c2d,0x9f},
+    {0x8c2e,0xf5},
+    {0x8c2f,0x45},
+    {0x8c30,0xe5},
+    {0x8c31,0x48},
+    {0x8c32,0xc3},
+    {0x8c33,0x13},
+    {0x8c34,0xff},
+    {0x8c35,0xfd},
+    {0x8c36,0xe5},
+    {0x8c37,0x46},
+    {0x8c38,0x2d},
+    {0x8c39,0xfd},
+    {0x8c3a,0xe4},
+    {0x8c3b,0x33},
+    {0x8c3c,0xfc},
+    {0x8c3d,0xe5},
+    {0x8c3e,0x43},
+    {0x8c3f,0x12},
+    {0x8c40,0x0b},
+    {0x8c41,0x25},
+    {0x8c42,0x40},
+    {0x8c43,0x05},
+    {0x8c44,0xe5},
+    {0x8c45,0x43},
+    {0x8c46,0x9f},
+    {0x8c47,0xf5},
+    {0x8c48,0x46},
+    {0x8c49,0x02},
+    {0x8c4a,0x07},
+    {0x8c4b,0x38},
+    {0x8c4c,0xad},
+    {0x8c4d,0x39},
+    {0x8c4e,0xac},
+    {0x8c4f,0x38},
+    {0x8c50,0xfa},
+    {0x8c51,0xf9},
+    {0x8c52,0xf8},
+    {0x8c53,0x12},
+    {0x8c54,0x05},
+    {0x8c55,0x89},
+    {0x8c56,0x8f},
+    {0x8c57,0x3b},
+    {0x8c58,0x8e},
+    {0x8c59,0x3a},
+    {0x8c5a,0x8d},
+    {0x8c5b,0x39},
+    {0x8c5c,0x8c},
+    {0x8c5d,0x38},
+    {0x8c5e,0xab},
+    {0x8c5f,0x37},
+    {0x8c60,0xaa},
+    {0x8c61,0x36},
+    {0x8c62,0xa9},
+    {0x8c63,0x35},
+    {0x8c64,0xa8},
+    {0x8c65,0x34},
+    {0x8c66,0x22},
+    {0x8c67,0x90},
+    {0x8c68,0x0e},
+    {0x8c69,0x8c},
+    {0x8c6a,0xe4},
+    {0x8c6b,0x93},
+    {0x8c6c,0x25},
+    {0x8c6d,0xe0},
+    {0x8c6e,0x24},
+    {0x8c6f,0x0a},
+    {0x8c70,0xf8},
+    {0x8c71,0xe6},
+    {0x8c72,0xfe},
+    {0x8c73,0x08},
+    {0x8c74,0xe6},
+    {0x8c75,0xff},
+    {0x8c76,0x22},
+    {0x8c77,0x93},
+    {0x8c78,0xff},
+    {0x8c79,0xe4},
+    {0x8c7a,0xfc},
+    {0x8c7b,0xfd},
+    {0x8c7c,0xfe},
+    {0x8c7d,0x12},
+    {0x8c7e,0x05},
+    {0x8c7f,0x89},
+    {0x8c80,0x8f},
+    {0x8c81,0x37},
+    {0x8c82,0x8e},
+    {0x8c83,0x36},
+    {0x8c84,0x8d},
+    {0x8c85,0x35},
+    {0x8c86,0x8c},
+    {0x8c87,0x34},
+    {0x8c88,0x22},
+    {0x8c89,0xe6},
+    {0x8c8a,0xfe},
+    {0x8c8b,0x08},
+    {0x8c8c,0xe6},
+    {0x8c8d,0xff},
+    {0x8c8e,0xe4},
+    {0x8c8f,0x8f},
+    {0x8c90,0x37},
+    {0x8c91,0x8e},
+    {0x8c92,0x36},
+    {0x8c93,0xf5},
+    {0x8c94,0x35},
+    {0x8c95,0xf5},
+    {0x8c96,0x34},
+    {0x8c97,0x22},
+    {0x8c98,0xef},
+    {0x8c99,0x25},
+    {0x8c9a,0xe0},
+    {0x8c9b,0x24},
+    {0x8c9c,0x4e},
+    {0x8c9d,0xf8},
+    {0x8c9e,0xe6},
+    {0x8c9f,0xfc},
+    {0x8ca0,0x08},
+    {0x8ca1,0xe6},
+    {0x8ca2,0xfd},
+    {0x8ca3,0x22},
+    {0x8ca4,0xd3},
+    {0x8ca5,0x79},
+    {0x8ca6,0x81},
+    {0x8ca7,0xe7},
+    {0x8ca8,0x78},
+    {0x8ca9,0x7f},
+    {0x8caa,0x96},
+    {0x8cab,0x19},
+    {0x8cac,0xe7},
+    {0x8cad,0x18},
+    {0x8cae,0x96},
+    {0x8caf,0x22},
+    {0x8cb0,0x78},
+    {0x8cb1,0x89},
+    {0x8cb2,0xef},
+    {0x8cb3,0x26},
+    {0x8cb4,0xf6},
+    {0x8cb5,0x18},
+    {0x8cb6,0xe4},
+    {0x8cb7,0x36},
+    {0x8cb8,0xf6},
+    {0x8cb9,0x22},
+    {0x8cba,0xe4},
+    {0x8cbb,0x8f},
+    {0x8cbc,0x3b},
+    {0x8cbd,0x8e},
+    {0x8cbe,0x3a},
+    {0x8cbf,0xf5},
+    {0x8cc0,0x39},
+    {0x8cc1,0xf5},
+    {0x8cc2,0x38},
+    {0x8cc3,0x22},
+    {0x8cc4,0x75},
+    {0x8cc5,0x89},
+    {0x8cc6,0x03},
+    {0x8cc7,0x75},
+    {0x8cc8,0xa8},
+    {0x8cc9,0x01},
+    {0x8cca,0x75},
+    {0x8ccb,0xb8},
+    {0x8ccc,0x04},
+    {0x8ccd,0x75},
+    {0x8cce,0x34},
+    {0x8ccf,0xff},
+    {0x8cd0,0x75},
+    {0x8cd1,0x35},
+    {0x8cd2,0x0e},
+    {0x8cd3,0x75},
+    {0x8cd4,0x36},
+    {0x8cd5,0x15},
+    {0x8cd6,0x75},
+    {0x8cd7,0x37},
+    {0x8cd8,0x0d},
+    {0x8cd9,0x12},
+    {0x8cda,0x0d},
+    {0x8cdb,0xaa},
+    {0x8cdc,0x12},
+    {0x8cdd,0x00},
+    {0x8cde,0x09},
+    {0x8cdf,0x12},
+    {0x8ce0,0x0b},
+    {0x8ce1,0xcc},
+    {0x8ce2,0x12},
+    {0x8ce3,0x00},
+    {0x8ce4,0x06},
+    {0x8ce5,0xd2},
+    {0x8ce6,0x00},
+    {0x8ce7,0xd2},
+    {0x8ce8,0x34},
+    {0x8ce9,0xd2},
+    {0x8cea,0xaf},
+    {0x8ceb,0x75},
+    {0x8cec,0x34},
+    {0x8ced,0xff},
+    {0x8cee,0x75},
+    {0x8cef,0x35},
+    {0x8cf0,0x0e},
+    {0x8cf1,0x75},
+    {0x8cf2,0x36},
+    {0x8cf3,0x49},
+    {0x8cf4,0x75},
+    {0x8cf5,0x37},
+    {0x8cf6,0x03},
+    {0x8cf7,0x12},
+    {0x8cf8,0x0d},
+    {0x8cf9,0xaa},
+    {0x8cfa,0x30},
+    {0x8cfb,0x08},
+    {0x8cfc,0x09},
+    {0x8cfd,0xc2},
+    {0x8cfe,0x34},
+    {0x8cff,0x12},
+    {0x8d00,0x09},
+    {0x8d01,0xee},
+    {0x8d02,0xc2},
+    {0x8d03,0x08},
+    {0x8d04,0xd2},
+    {0x8d05,0x34},
+    {0x8d06,0x30},
+    {0x8d07,0x0b},
+    {0x8d08,0x09},
+    {0x8d09,0xc2},
+    {0x8d0a,0x36},
+    {0x8d0b,0x12},
+    {0x8d0c,0x00},
+    {0x8d0d,0x0e},
+    {0x8d0e,0xc2},
+    {0x8d0f,0x0b},
+    {0x8d10,0xd2},
+    {0x8d11,0x36},
+    {0x8d12,0x30},
+    {0x8d13,0x09},
+    {0x8d14,0x09},
+    {0x8d15,0xc2},
+    {0x8d16,0x36},
+    {0x8d17,0x12},
+    {0x8d18,0x02},
+    {0x8d19,0xa7},
+    {0x8d1a,0xc2},
+    {0x8d1b,0x09},
+    {0x8d1c,0xd2},
+    {0x8d1d,0x36},
+    {0x8d1e,0x30},
+    {0x8d1f,0x0e},
+    {0x8d20,0x03},
+    {0x8d21,0x12},
+    {0x8d22,0x07},
+    {0x8d23,0x38},
+    {0x8d24,0x30},
+    {0x8d25,0x35},
+    {0x8d26,0xd3},
+    {0x8d27,0x90},
+    {0x8d28,0x30},
+    {0x8d29,0x29},
+    {0x8d2a,0xe5},
+    {0x8d2b,0x1e},
+    {0x8d2c,0xf0},
+    {0x8d2d,0xb4},
+    {0x8d2e,0x10},
+    {0x8d2f,0x05},
+    {0x8d30,0x90},
+    {0x8d31,0x30},
+    {0x8d32,0x23},
+    {0x8d33,0xe4},
+    {0x8d34,0xf0},
+    {0x8d35,0xc2},
+    {0x8d36,0x35},
+    {0x8d37,0x80},
+    {0x8d38,0xc1},
+    {0x8d39,0xe4},
+    {0x8d3a,0xf5},
+    {0x8d3b,0x4b},
+    {0x8d3c,0x90},
+    {0x8d3d,0x0e},
+    {0x8d3e,0x7a},
+    {0x8d3f,0x93},
+    {0x8d40,0xff},
+    {0x8d41,0xe4},
+    {0x8d42,0x8f},
+    {0x8d43,0x37},
+    {0x8d44,0xf5},
+    {0x8d45,0x36},
+    {0x8d46,0xf5},
+    {0x8d47,0x35},
+    {0x8d48,0xf5},
+    {0x8d49,0x34},
+    {0x8d4a,0xaf},
+    {0x8d4b,0x37},
+    {0x8d4c,0xae},
+    {0x8d4d,0x36},
+    {0x8d4e,0xad},
+    {0x8d4f,0x35},
+    {0x8d50,0xac},
+    {0x8d51,0x34},
+    {0x8d52,0x90},
+    {0x8d53,0x0e},
+    {0x8d54,0x6a},
+    {0x8d55,0x12},
+    {0x8d56,0x0f},
+    {0x8d57,0xa6},
+    {0x8d58,0x8f},
+    {0x8d59,0x37},
+    {0x8d5a,0x8e},
+    {0x8d5b,0x36},
+    {0x8d5c,0x8d},
+    {0x8d5d,0x35},
+    {0x8d5e,0x8c},
+    {0x8d5f,0x34},
+    {0x8d60,0x90},
+    {0x8d61,0x0e},
+    {0x8d62,0x72},
+    {0x8d63,0x12},
+    {0x8d64,0x06},
+    {0x8d65,0xdd},
+    {0x8d66,0xef},
+    {0x8d67,0x45},
+    {0x8d68,0x37},
+    {0x8d69,0xf5},
+    {0x8d6a,0x37},
+    {0x8d6b,0xee},
+    {0x8d6c,0x45},
+    {0x8d6d,0x36},
+    {0x8d6e,0xf5},
+    {0x8d6f,0x36},
+    {0x8d70,0xed},
+    {0x8d71,0x45},
+    {0x8d72,0x35},
+    {0x8d73,0xf5},
+    {0x8d74,0x35},
+    {0x8d75,0xec},
+    {0x8d76,0x45},
+    {0x8d77,0x34},
+    {0x8d78,0xf5},
+    {0x8d79,0x34},
+    {0x8d7a,0xe4},
+    {0x8d7b,0xf5},
+    {0x8d7c,0x22},
+    {0x8d7d,0xf5},
+    {0x8d7e,0x23},
+    {0x8d7f,0x85},
+    {0x8d80,0x37},
+    {0x8d81,0x31},
+    {0x8d82,0x85},
+    {0x8d83,0x36},
+    {0x8d84,0x30},
+    {0x8d85,0x85},
+    {0x8d86,0x35},
+    {0x8d87,0x2f},
+    {0x8d88,0x85},
+    {0x8d89,0x34},
+    {0x8d8a,0x2e},
+    {0x8d8b,0x12},
+    {0x8d8c,0x0f},
+    {0x8d8d,0x63},
+    {0x8d8e,0xe4},
+    {0x8d8f,0xf5},
+    {0x8d90,0x22},
+    {0x8d91,0xf5},
+    {0x8d92,0x23},
+    {0x8d93,0x90},
+    {0x8d94,0x0e},
+    {0x8d95,0x72},
+    {0x8d96,0x12},
+    {0x8d97,0x0f},
+    {0x8d98,0x9a},
+    {0x8d99,0x12},
+    {0x8d9a,0x0f},
+    {0x8d9b,0x63},
+    {0x8d9c,0xe4},
+    {0x8d9d,0xf5},
+    {0x8d9e,0x22},
+    {0x8d9f,0xf5},
+    {0x8da0,0x23},
+    {0x8da1,0x90},
+    {0x8da2,0x0e},
+    {0x8da3,0x6e},
+    {0x8da4,0x12},
+    {0x8da5,0x0f},
+    {0x8da6,0x9a},
+    {0x8da7,0x02},
+    {0x8da8,0x0f},
+    {0x8da9,0x63},
+    {0x8daa,0xae},
+    {0x8dab,0x35},
+    {0x8dac,0xaf},
+    {0x8dad,0x36},
+    {0x8dae,0xe4},
+    {0x8daf,0xfd},
+    {0x8db0,0xed},
+    {0x8db1,0xc3},
+    {0x8db2,0x95},
+    {0x8db3,0x37},
+    {0x8db4,0x50},
+    {0x8db5,0x33},
+    {0x8db6,0x12},
+    {0x8db7,0x0f},
+    {0x8db8,0xec},
+    {0x8db9,0xe4},
+    {0x8dba,0x93},
+    {0x8dbb,0xf5},
+    {0x8dbc,0x38},
+    {0x8dbd,0x74},
+    {0x8dbe,0x01},
+    {0x8dbf,0x93},
+    {0x8dc0,0xf5},
+    {0x8dc1,0x39},
+    {0x8dc2,0x45},
+    {0x8dc3,0x38},
+    {0x8dc4,0x60},
+    {0x8dc5,0x23},
+    {0x8dc6,0x85},
+    {0x8dc7,0x39},
+    {0x8dc8,0x82},
+    {0x8dc9,0x85},
+    {0x8dca,0x38},
+    {0x8dcb,0x83},
+    {0x8dcc,0xe0},
+    {0x8dcd,0xfc},
+    {0x8dce,0x12},
+    {0x8dcf,0x0f},
+    {0x8dd0,0xec},
+    {0x8dd1,0x74},
+    {0x8dd2,0x03},
+    {0x8dd3,0x93},
+    {0x8dd4,0x52},
+    {0x8dd5,0x04},
+    {0x8dd6,0x12},
+    {0x8dd7,0x0f},
+    {0x8dd8,0xec},
+    {0x8dd9,0x74},
+    {0x8dda,0x02},
+    {0x8ddb,0x93},
+    {0x8ddc,0x42},
+    {0x8ddd,0x04},
+    {0x8dde,0x85},
+    {0x8ddf,0x39},
+    {0x8de0,0x82},
+    {0x8de1,0x85},
+    {0x8de2,0x38},
+    {0x8de3,0x83},
+    {0x8de4,0xec},
+    {0x8de5,0xf0},
+    {0x8de6,0x0d},
+    {0x8de7,0x80},
+    {0x8de8,0xc7},
+    {0x8de9,0x22},
+    {0x8dea,0xc0},
+    {0x8deb,0xe0},
+    {0x8dec,0xc0},
+    {0x8ded,0x83},
+    {0x8dee,0xc0},
+    {0x8def,0x82},
+    {0x8df0,0x90},
+    {0x8df1,0x3f},
+    {0x8df2,0x0d},
+    {0x8df3,0xe0},
+    {0x8df4,0xf5},
+    {0x8df5,0x33},
+    {0x8df6,0xe5},
+    {0x8df7,0x33},
+    {0x8df8,0xf0},
+    {0x8df9,0xd0},
+    {0x8dfa,0x82},
+    {0x8dfb,0xd0},
+    {0x8dfc,0x83},
+    {0x8dfd,0xd0},
+    {0x8dfe,0xe0},
+    {0x8dff,0x32},
+    {0x8e00,0x12},
+    {0x8e01,0x04},
+    {0x8e02,0x13},
+    {0x8e03,0x10},
+    {0x8e04,0x01},
+    {0x8e05,0x03},
+    {0x8e06,0x4f},
+    {0x8e07,0x56},
+    {0x8e08,0x54},
+    {0x8e09,0x20},
+    {0x8e0a,0x20},
+    {0x8e0b,0x20},
+    {0x8e0c,0x20},
+    {0x8e0d,0x20},
+    {0x8e0e,0x13},
+    {0x8e0f,0x01},
+    {0x8e10,0x10},
+    {0x8e11,0x01},
+    {0x8e12,0x56},
+    {0x8e13,0x40},
+    {0x8e14,0x1a},
+    {0x8e15,0x30},
+    {0x8e16,0x29},
+    {0x8e17,0x7e},
+    {0x8e18,0x00},
+    {0x8e19,0x30},
+    {0x8e1a,0x04},
+    {0x8e1b,0x20},
+    {0x8e1c,0xdf},
+    {0x8e1d,0x30},
+    {0x8e1e,0x05},
+    {0x8e1f,0x40},
+    {0x8e20,0xbf},
+    {0x8e21,0x50},
+    {0x8e22,0x03},
+    {0x8e23,0x00},
+    {0x8e24,0xfd},
+    {0x8e25,0x50},
+    {0x8e26,0x27},
+    {0x8e27,0x01},
+    {0x8e28,0xfe},
+    {0x8e29,0x60},
+    {0x8e2a,0x00},
+    {0x8e2b,0x11},
+    {0x8e2c,0x00},
+    {0x8e2d,0x3f},
+    {0x8e2e,0x05},
+    {0x8e2f,0x30},
+    {0x8e30,0x00},
+    {0x8e31,0x3f},
+    {0x8e32,0x06},
+    {0x8e33,0x22},
+    {0x8e34,0x00},
+    {0x8e35,0x3f},
+    {0x8e36,0x01},
+    {0x8e37,0x2a},
+    {0x8e38,0x00},
+    {0x8e39,0x3f},
+    {0x8e3a,0x02},
+    {0x8e3b,0x00},
+    {0x8e3c,0x00},
+    {0x8e3d,0x36},
+    {0x8e3e,0x06},
+    {0x8e3f,0x07},
+    {0x8e40,0x00},
+    {0x8e41,0x3f},
+    {0x8e42,0x0b},
+    {0x8e43,0x0f},
+    {0x8e44,0xf0},
+    {0x8e45,0x00},
+    {0x8e46,0x00},
+    {0x8e47,0x00},
+    {0x8e48,0x00},
+    {0x8e49,0x30},
+    {0x8e4a,0x01},
+    {0x8e4b,0x40},
+    {0x8e4c,0xbf},
+    {0x8e4d,0x30},
+    {0x8e4e,0x01},
+    {0x8e4f,0x00},
+    {0x8e50,0xbf},
+    {0x8e51,0x30},
+    {0x8e52,0x29},
+    {0x8e53,0x70},
+    {0x8e54,0x00},
+    {0x8e55,0x3a},
+    {0x8e56,0x00},
+    {0x8e57,0x00},
+    {0x8e58,0xff},
+    {0x8e59,0x3a},
+    {0x8e5a,0x00},
+    {0x8e5b,0x00},
+    {0x8e5c,0xff},
+    {0x8e5d,0x36},
+    {0x8e5e,0x03},
+    {0x8e5f,0x36},
+    {0x8e60,0x02},
+    {0x8e61,0x41},
+    {0x8e62,0x44},
+    {0x8e63,0x58},
+    {0x8e64,0x20},
+    {0x8e65,0x18},
+    {0x8e66,0x10},
+    {0x8e67,0x0a},
+    {0x8e68,0x04},
+    {0x8e69,0x04},
+    {0x8e6a,0x00},
+    {0x8e6b,0x03},
+    {0x8e6c,0xff},
+    {0x8e6d,0x64},
+    {0x8e6e,0x00},
+    {0x8e6f,0x00},
+    {0x8e70,0x80},
+    {0x8e71,0x00},
+    {0x8e72,0x00},
+    {0x8e73,0x00},
+    {0x8e74,0x00},
+    {0x8e75,0x00},
+    {0x8e76,0x00},
+    {0x8e77,0x02},
+    {0x8e78,0x04},
+    {0x8e79,0x06},
+    {0x8e7a,0x06},
+    {0x8e7b,0x00},
+    {0x8e7c,0x02},
+    {0x8e7d,0x33},
+    {0x8e7e,0x01},
+    {0x8e7f,0x00},
+    {0x8e80,0x50},
+    {0x8e81,0x3c},
+    {0x8e82,0x28},
+    {0x8e83,0x1e},
+    {0x8e84,0x10},
+    {0x8e85,0x10},
+    {0x8e86,0x50},
+    {0x8e87,0x2d},
+    {0x8e88,0x28},
+    {0x8e89,0x16},
+    {0x8e8a,0x10},
+    {0x8e8b,0x10},
+    {0x8e8c,0x02},
+    {0x8e8d,0x00},
+    {0x8e8e,0x10},
+    {0x8e8f,0x30},
+    {0x8e90,0x0a},
+    {0x8e91,0x04},
+    {0x8e92,0x05},
+    {0x8e93,0x08},
+    {0x8e94,0x64},
+    {0x8e95,0x06},
+    {0x8e96,0x05},
+    {0x8e97,0x01},
+    {0x8e98,0x00},
+    {0x8e99,0xa5},
+    {0x8e9a,0x5a},
+    {0x8e9b,0x00},
+    {0x8e9c,0x78},
+    {0x8e9d,0xbe},
+    {0x8e9e,0xe6},
+    {0x8e9f,0xd3},
+    {0x8ea0,0x08},
+    {0x8ea1,0xff},
+    {0x8ea2,0xe6},
+    {0x8ea3,0x64},
+    {0x8ea4,0x80},
+    {0x8ea5,0xf8},
+    {0x8ea6,0xef},
+    {0x8ea7,0x64},
+    {0x8ea8,0x80},
+    {0x8ea9,0x98},
+    {0x8eaa,0x22},
+    {0x8eab,0x78},
+    {0x8eac,0xc0},
+    {0x8ead,0xa6},
+    {0x8eae,0x07},
+    {0x8eaf,0x78},
+    {0x8eb0,0xbd},
+    {0x8eb1,0xd3},
+    {0x8eb2,0xe6},
+    {0x8eb3,0x64},
+    {0x8eb4,0x80},
+    {0x8eb5,0x94},
+    {0x8eb6,0x80},
+    {0x8eb7,0x22},
+    {0x8eb8,0x93},
+    {0x8eb9,0xff},
+    {0x8eba,0x7e},
+    {0x8ebb,0x00},
+    {0x8ebc,0xe6},
+    {0x8ebd,0xfc},
+    {0x8ebe,0x08},
+    {0x8ebf,0xe6},
+    {0x8ec0,0xfd},
+    {0x8ec1,0x12},
+    {0x8ec2,0x05},
+    {0x8ec3,0x22},
+    {0x8ec4,0x78},
+    {0x8ec5,0xc1},
+    {0x8ec6,0xe6},
+    {0x8ec7,0xfc},
+    {0x8ec8,0x08},
+    {0x8ec9,0xe6},
+    {0x8eca,0xfd},
+    {0x8ecb,0xd3},
+    {0x8ecc,0xef},
+    {0x8ecd,0x9d},
+    {0x8ece,0xee},
+    {0x8ecf,0x9c},
+    {0x8ed0,0x22},
+    {0x8ed1,0x78},
+    {0x8ed2,0xbf},
+    {0x8ed3,0xa6},
+    {0x8ed4,0x07},
+    {0x8ed5,0x08},
+    {0x8ed6,0xd3},
+    {0x8ed7,0xe6},
+    {0x8ed8,0x64},
+    {0x8ed9,0x80},
+    {0x8eda,0x94},
+    {0x8edb,0x80},
+    {0x8edc,0x22},
+    {0x8edd,0x78},
+    {0x8ede,0xc0},
+    {0x8edf,0xa6},
+    {0x8ee0,0x07},
+    {0x8ee1,0xc3},
+    {0x8ee2,0x18},
+    {0x8ee3,0xe6},
+    {0x8ee4,0x64},
+    {0x8ee5,0x80},
+    {0x8ee6,0x94},
+    {0x8ee7,0xb3},
+    {0x8ee8,0x22},
+    {0x8ee9,0x78},
+    {0x8eea,0xbf},
+    {0x8eeb,0xa6},
+    {0x8eec,0x07},
+    {0x8eed,0xc3},
+    {0x8eee,0x08},
+    {0x8eef,0xe6},
+    {0x8ef0,0x64},
+    {0x8ef1,0x80},
+    {0x8ef2,0x94},
+    {0x8ef3,0xb3},
+    {0x8ef4,0x22},
+    {0x8ef5,0x25},
+    {0x8ef6,0xe0},
+    {0x8ef7,0x24},
+    {0x8ef8,0x0a},
+    {0x8ef9,0xf8},
+    {0x8efa,0xe6},
+    {0x8efb,0xfe},
+    {0x8efc,0x08},
+    {0x8efd,0xe6},
+    {0x8efe,0xff},
+    {0x8eff,0x22},
+    {0x8f00,0xe5},
+    {0x8f01,0x40},
+    {0x8f02,0x24},
+    {0x8f03,0xf2},
+    {0x8f04,0xf5},
+    {0x8f05,0x37},
+    {0x8f06,0xe5},
+    {0x8f07,0x3f},
+    {0x8f08,0x34},
+    {0x8f09,0x43},
+    {0x8f0a,0xf5},
+    {0x8f0b,0x36},
+    {0x8f0c,0xe5},
+    {0x8f0d,0x3e},
+    {0x8f0e,0x34},
+    {0x8f0f,0xa2},
+    {0x8f10,0xf5},
+    {0x8f11,0x35},
+    {0x8f12,0xe5},
+    {0x8f13,0x3d},
+    {0x8f14,0x34},
+    {0x8f15,0x28},
+    {0x8f16,0xf5},
+    {0x8f17,0x34},
+    {0x8f18,0xe5},
+    {0x8f19,0x37},
+    {0x8f1a,0xff},
+    {0x8f1b,0xe4},
+    {0x8f1c,0xfe},
+    {0x8f1d,0xfd},
+    {0x8f1e,0xfc},
+    {0x8f1f,0x78},
+    {0x8f20,0x18},
+    {0x8f21,0x12},
+    {0x8f22,0x06},
+    {0x8f23,0xca},
+    {0x8f24,0x8f},
+    {0x8f25,0x40},
+    {0x8f26,0x8e},
+    {0x8f27,0x3f},
+    {0x8f28,0x8d},
+    {0x8f29,0x3e},
+    {0x8f2a,0x8c},
+    {0x8f2b,0x3d},
+    {0x8f2c,0xe5},
+    {0x8f2d,0x37},
+    {0x8f2e,0x54},
+    {0x8f2f,0xa0},
+    {0x8f30,0xff},
+    {0x8f31,0xe5},
+    {0x8f32,0x36},
+    {0x8f33,0xfe},
+    {0x8f34,0xe4},
+    {0x8f35,0xfd},
+    {0x8f36,0xfc},
+    {0x8f37,0x78},
+    {0x8f38,0x07},
+    {0x8f39,0x12},
+    {0x8f3a,0x06},
+    {0x8f3b,0xb7},
+    {0x8f3c,0x78},
+    {0x8f3d,0x10},
+    {0x8f3e,0x12},
+    {0x8f3f,0x0f},
+    {0x8f40,0xac},
+    {0x8f41,0xe4},
+    {0x8f42,0xff},
+    {0x8f43,0xfe},
+    {0x8f44,0xe5},
+    {0x8f45,0x35},
+    {0x8f46,0xfd},
+    {0x8f47,0xe4},
+    {0x8f48,0xfc},
+    {0x8f49,0x78},
+    {0x8f4a,0x0e},
+    {0x8f4b,0x12},
+    {0x8f4c,0x06},
+    {0x8f4d,0xb7},
+    {0x8f4e,0x12},
+    {0x8f4f,0x0f},
+    {0x8f50,0xaf},
+    {0x8f51,0xe4},
+    {0x8f52,0xff},
+    {0x8f53,0xfe},
+    {0x8f54,0xfd},
+    {0x8f55,0xe5},
+    {0x8f56,0x34},
+    {0x8f57,0xfc},
+    {0x8f58,0x78},
+    {0x8f59,0x18},
+    {0x8f5a,0x12},
+    {0x8f5b,0x06},
+    {0x8f5c,0xb7},
+    {0x8f5d,0x78},
+    {0x8f5e,0x08},
+    {0x8f5f,0x12},
+    {0x8f60,0x0f},
+    {0x8f61,0xac},
+    {0x8f62,0x22},
+    {0x8f63,0xa2},
+    {0x8f64,0xaf},
+    {0x8f65,0x92},
+    {0x8f66,0x32},
+    {0x8f67,0xc2},
+    {0x8f68,0xaf},
+    {0x8f69,0xe5},
+    {0x8f6a,0x23},
+    {0x8f6b,0x45},
+    {0x8f6c,0x22},
+    {0x8f6d,0x90},
+    {0x8f6e,0x0e},
+    {0x8f6f,0x5d},
+    {0x8f70,0x60},
+    {0x8f71,0x0e},
+    {0x8f72,0x12},
+    {0x8f73,0x0f},
+    {0x8f74,0xc7},
+    {0x8f75,0xe0},
+    {0x8f76,0xf5},
+    {0x8f77,0x2c},
+    {0x8f78,0x12},
+    {0x8f79,0x0f},
+    {0x8f7a,0xc4},
+    {0x8f7b,0xe0},
+    {0x8f7c,0xf5},
+    {0x8f7d,0x2d},
+    {0x8f7e,0x80},
+    {0x8f7f,0x0c},
+    {0x8f80,0x12},
+    {0x8f81,0x0f},
+    {0x8f82,0xc7},
+    {0x8f83,0xe5},
+    {0x8f84,0x30},
+    {0x8f85,0xf0},
+    {0x8f86,0x12},
+    {0x8f87,0x0f},
+    {0x8f88,0xc4},
+    {0x8f89,0xe5},
+    {0x8f8a,0x31},
+    {0x8f8b,0xf0},
+    {0x8f8c,0xa2},
+    {0x8f8d,0x32},
+    {0x8f8e,0x92},
+    {0x8f8f,0xaf},
+    {0x8f90,0x22},
+    {0x8f91,0x8f},
+    {0x8f92,0x3b},
+    {0x8f93,0x8e},
+    {0x8f94,0x3a},
+    {0x8f95,0x8d},
+    {0x8f96,0x39},
+    {0x8f97,0x8c},
+    {0x8f98,0x38},
+    {0x8f99,0x22},
+    {0x8f9a,0x12},
+    {0x8f9b,0x06},
+    {0x8f9c,0xdd},
+    {0x8f9d,0x8f},
+    {0x8f9e,0x31},
+    {0x8f9f,0x8e},
+    {0x8fa0,0x30},
+    {0x8fa1,0x8d},
+    {0x8fa2,0x2f},
+    {0x8fa3,0x8c},
+    {0x8fa4,0x2e},
+    {0x8fa5,0x22},
+    {0x8fa6,0x93},
+    {0x8fa7,0xf9},
+    {0x8fa8,0xf8},
+    {0x8fa9,0x02},
+    {0x8faa,0x06},
+    {0x8fab,0xca},
+    {0x8fac,0x12},
+    {0x8fad,0x06},
+    {0x8fae,0xca},
+    {0x8faf,0xe5},
+    {0x8fb0,0x40},
+    {0x8fb1,0x2f},
+    {0x8fb2,0xf5},
+    {0x8fb3,0x40},
+    {0x8fb4,0xe5},
+    {0x8fb5,0x3f},
+    {0x8fb6,0x3e},
+    {0x8fb7,0xf5},
+    {0x8fb8,0x3f},
+    {0x8fb9,0xe5},
+    {0x8fba,0x3e},
+    {0x8fbb,0x3d},
+    {0x8fbc,0xf5},
+    {0x8fbd,0x3e},
+    {0x8fbe,0xe5},
+    {0x8fbf,0x3d},
+    {0x8fc0,0x3c},
+    {0x8fc1,0xf5},
+    {0x8fc2,0x3d},
+    {0x8fc3,0x22},
+    {0x8fc4,0x90},
+    {0x8fc5,0x0e},
+    {0x8fc6,0x5f},
+    {0x8fc7,0xe4},
+    {0x8fc8,0x93},
+    {0x8fc9,0xfe},
+    {0x8fca,0x74},
+    {0x8fcb,0x01},
+    {0x8fcc,0x93},
+    {0x8fcd,0xf5},
+    {0x8fce,0x82},
+    {0x8fcf,0x8e},
+    {0x8fd0,0x83},
+    {0x8fd1,0x22},
+    {0x8fd2,0xd2},
+    {0x8fd3,0x01},
+    {0x8fd4,0xc2},
+    {0x8fd5,0x02},
+    {0x8fd6,0xe4},
+    {0x8fd7,0xf5},
+    {0x8fd8,0x1f},
+    {0x8fd9,0xf5},
+    {0x8fda,0x1e},
+    {0x8fdb,0xd2},
+    {0x8fdc,0x35},
+    {0x8fdd,0xd2},
+    {0x8fde,0x33},
+    {0x8fdf,0x22},
+    {0x8fe0,0x78},
+    {0x8fe1,0x7f},
+    {0x8fe2,0xe4},
+    {0x8fe3,0xf6},
+    {0x8fe4,0xd8},
+    {0x8fe5,0xfd},
+    {0x8fe6,0x75},
+    {0x8fe7,0x81},
+    {0x8fe8,0xcd},
+    {0x8fe9,0x02},
+    {0x8fea,0x0c},
+    {0x8feb,0xc4},
+    {0x8fec,0x8f},
+    {0x8fed,0x82},
+    {0x8fee,0x8e},
+    {0x8fef,0x83},
+    {0x8ff0,0x75},
+    {0x8ff1,0xf0},
+    {0x8ff2,0x04},
+    {0x8ff3,0xed},
+    {0x8ff4,0x02},
+    {0x8ff5,0x07},
+    {0x8ff6,0x06},  
+    {0x3022,0x00},
+    {0x3023,0x00},
+    {0x3024,0x00},
+    {0x3025,0x00},
+    {0x3026,0x00},
+    {0x3027,0x00},
+    {0x3028,0x00},
+    {0x3029,0x7F},
+    {0x3000,0x00},
+    ENDMARKER,
+};
+
+
+#if 0
+
+/*????*/
+static struct regval_list module_effect_normal_regs[] =
+{
+	{0x22, 0x55},
+    {0x5a, 0x48},
+    {0x5b, 0x40},
+    {0x5c, 0x68},
+    ENDMARKER,
+};
+
+/*??,????*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+	{0x23, 0x00},
+    {0x2d, 0x0a},
+    {0x20, 0xff},
+    {0xd2, 0x90},
+    {0x73, 0x00},
+    {0x77, 0x38 /*0x54 */ },
+    {0xb3, 0x40},
+    {0xb4, 0x80},
+    {0xba, 0x00},
+    {0xbb, 0x00},
+    ENDMARKER,
+};
+
+/*????*/
+static struct regval_list module_effect_negative_regs[] =
+{
+	{0x23, 0x02},       //0x00},
+    {0x2d, 0x0a},
+    {0x20, 0x7f},       //0xff},
+    {0xd2, 0x90},
+    {0x73, 0x00},
+    {0x77, 0x54},
+    {0xb3, 0x40},
+    {0xb4, 0x80},
+    {0xba, 0x00},
+    {0xbb, 0x00},
+    ENDMARKER,
+};
+
+/*????*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+	
+};
+
+
+
+static struct regval_list module_scene_night_regs[] =
+{
+//  NULL
+};
+
+static  struct regval_list module_scene_portrait[] =
+{
+//  NULL
+};
+#endif
+/*
+ * The exposure target setttings
+ */
+static struct regval_list module_exp_comp_neg4_regs[] = {
+	
+	{0x3a0f ,0x10},
+	{0x3a10 ,0x08},
+	{0x3a1b ,0x10},
+	{0x3a1e ,0x08},
+	{0x3a11 ,0x20},
+	{0x3a1f ,0x10},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg3_regs[] = {
+	
+	{0x3a0f ,0x18},  
+	{0x3a10 ,0x10},  
+	{0x3a1b ,0x18},  
+	{0x3a1e ,0x10},  
+	{0x3a11 ,0x30},  
+	{0x3a1f ,0x10},  
+	ENDMARKER,
+
+};
+
+static struct regval_list module_exp_comp_neg2_regs[] = {
+	
+	{0x3a0f ,0x20},    
+	{0x3a10 ,0x18},    
+	{0x3a11 ,0x41},    
+	{0x3a1b ,0x20},    
+	{0x3a1e ,0x18},    
+	{0x3a1f ,0x10},    
+	ENDMARKER,
+
+};
+
+static struct regval_list module_exp_comp_neg1_regs[] = {
+	
+	{0x3a0f ,0x28},  
+	{0x3a10 ,0x20},  
+	{0x3a11 ,0x51},  
+	{0x3a1b ,0x28},  
+	{0x3a1e ,0x20},  
+	{0x3a1f ,0x10},  
+	ENDMARKER,
+
+};
+
+static struct regval_list module_exp_comp_zero_regs[] = {
+	
+	{0x3a0f ,0x38},
+	{0x3a10 ,0x30},
+	{0x3a11 ,0x61},
+	{0x3a1b ,0x38},
+	{0x3a1e ,0x30},
+	{0x3a1f ,0x10},
+	ENDMARKER,
+
+};
+
+static struct regval_list module_exp_comp_pos1_regs[] = {
+	
+	{0x3a0f ,0x48},
+	{0x3a10 ,0x40},
+	{0x3a11 ,0x80},
+	{0x3a1b ,0x48},
+	{0x3a1e ,0x40},
+	{0x3a1f ,0x20},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos2_regs[] = {
+	
+	{0x3a0f ,0x50},   
+	{0x3a10 ,0x48},   
+	{0x3a11 ,0x90},   
+	{0x3a1b ,0x50},   
+	{0x3a1e ,0x48},   
+	{0x3a1f ,0x20},   
+	ENDMARKER,
+
+};
+
+static struct regval_list module_exp_comp_pos3_regs[] = {
+	
+	{0x3a0f ,0x58}, 
+	{0x3a10 ,0x50}, 
+	{0x3a11 ,0x91}, 
+	{0x3a1b ,0x58}, 
+	{0x3a1e ,0x50}, 
+	{0x3a1f ,0x20}, 
+	ENDMARKER,
+
+};
+
+static struct regval_list module_exp_comp_pos4_regs[] = {
+	
+	{0x3a0f ,0x60},
+	{0x3a10 ,0x58},
+	{0x3a11 ,0xa0},
+	{0x3a1b ,0x60},
+	{0x3a1e ,0x58},
+	{0x3a1f ,0x20},
+	ENDMARKER,
+
+};
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{   .id = V4L2_CID_EXPOSURE, 
+		.min = 0, 
+		.max = 975,
+		.step = 1, 
+		.def = 500,
+	},
+	{	.id = V4L2_CID_EXPOSURE_COMP, 
+		.min = -4, 
+		.max = 4, 
+		.step = 1, 
+		.def = 0,
+	},	
+	{	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,
+	},
+	{
+        .id = V4L2_CID_AUTO_WHITE_BALANCE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 1,
+    },
+    {
+        .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+        .min = 0,
+        .max = 3,
+        .step = 1,
+        .def = 0,
+    },
+       {	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+
+    {
+        .id = V4L2_CID_HFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_VFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+     {	.id = V4L2_CID_AF_MODE,
+		.min = NONE_AF, 
+		.max = CONTINUE_AF|SINGLE_AF, 
+		.step = 1, 
+		.def =  CONTINUE_AF|SINGLE_AF,},
+    {	.id = V4L2_CID_AF_STATUS, 
+		.min = AF_STATUS_DISABLE, 
+		.max = AF_STATUS_FAIL, 
+		.step = 1, 
+		.def = AF_STATUS_DISABLE,},
+	{	.id = V4L2_CID_MIRRORFLIP, //3.10??????????,????vflip?hflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+	
+};
+
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	 {
+        .id = V4L2_CID_COLORFX,
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_EXPOSURE_AUTO,
+        .max = 1,
+        .mask = 0x0,
+        .def = 1,
+    },
+
+    {  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_HDR, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+    {	.id   = V4L2_CID_FLASH_LED_MODE, 
+		.max  = 3,
+		.mask = 0x0,
+		.def  = 0,},
+	 {
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/ov5640/ov5640.c b/drivers/media/i2c/camera/ov5640/ov5640.c
new file mode 100755
index 0000000..065ce29
--- /dev/null
+++ b/drivers/media/i2c/camera/ov5640/ov5640.c
@@ -0,0 +1,805 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include"../module_comm/camera_chip_ident.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+
+static bool need_freeze_aec = false;
+
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = (reg & 0xff00) >> 8;
+    regs_array[1] =  reg & 0x00ff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = (reg & 0xff00) >> 8;
+    regs_array[1] =  reg & 0x00ff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0)
+			{
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+			}
+		vals++;
+	}
+	return 0;
+}
+
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret = 0;
+	ret = camera_i2c_write(client->adapter, 0x3103, 0x11);
+    ret = camera_i2c_write(client->adapter, 0x3008, 0x82);
+    mdelay(50);
+	return ret;
+}
+#if 0
+
+static int module_soft_standby(struct i2c_client *client)
+{
+	unsigned int reg_0x1a;
+	
+	int ret = 0;
+	struct i2c_adapter *i2c_adap = client->adapter;
+	ret = camera_i2c_read(i2c_adap, 0x1a, &reg_0x1a);
+	reg_0x1a |= (0x1<<0);
+	ret = camera_i2c_write(i2c_adap, 0x1a, reg_0x1a);
+	
+	ret |= camera_i2c_write(i2c_adap, 0x25, 0x00);
+	
+	return ret;	
+}
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	//struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+    
+    
+	return ret;
+}
+
+#endif
+
+#if 0
+static int module_normal(struct v4l2_subdev *sd)
+{
+	unsigned int reg_0x1a;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	
+	int ret = 0;
+
+	
+	struct i2c_adapter *i2c_adap = client->adapter;
+	ret  = camera_i2c_write(i2c_adap, 0xfe,0x00);
+	ret |= camera_i2c_read(i2c_adap, 0x1a, &reg_0x1a);
+	reg_0x1a &= (~(0x1<<0));
+	
+	ret |= camera_i2c_write(i2c_adap, 0x1a, reg_0x1a);
+	
+	ret |= camera_i2c_write(i2c_adap, 0x25, 0xff);
+	
+	return ret;
+}
+#endif
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	const struct camera_module_win_size *win = priv->win;
+	unsigned int reg_0x3503 = 0x00;
+	int ret = 0;
+
+	if (win->width == module_win_vga.width && win->height == module_win_vga.height) {
+		need_freeze_aec = true;
+	} else {
+		need_freeze_aec = false;
+	}
+
+	ret = camera_i2c_write(client->adapter, 0x3503, reg_0x3503); 	
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	unsigned int reg_0x3503 = 0x07;
+
+    //if (need_freeze_aec) 
+		{
+	    ret = camera_i2c_write(client->adapter, 0x3503, reg_0x3503); 
+	}
+	
+	return ret;
+}
+
+
+
+
+
+#if 0
+static int  module_start_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+
+	//printk("int the module_start_aec\n ");
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_freeze_aec\n ");
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_set_exposure_param\n ");
+	return ret;
+}
+static int module_normal(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_set_scene_exposure\n ");
+	return ret;
+}
+#endif
+
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int scene_exposure = ctrl->val;
+	unsigned int reg_0x3a00;
+	int ret = 0;
+
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_NIGHT:  //\CA\D2\C4\DA
+		ret = camera_i2c_read(client->adapter, 0x3a00, &reg_0x3a00);
+		reg_0x3a00 = reg_0x3a00 | (0x1 << 2);  //\BF\AA\C6\F4ҹģʽ
+		ret |= camera_i2c_write(client->adapter, 0x3a00, reg_0x3a00);
+		break;
+
+	case V4L2_SCENE_MODE_SUNSET:	//\CA\D2\CD\E2
+		ret = camera_i2c_read(client->adapter, 0x3a00, &reg_0x3a00);
+		reg_0x3a00 = reg_0x3a00 & 0xfb;  //\B9ر\D5ҹģʽ
+		ret |= camera_i2c_write(client->adapter, 0x3a00, reg_0x3a00);
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+	
+	return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    int ret;
+    unsigned int shutter;
+    unsigned int  reg_0x3500 = 0;
+    unsigned int  reg_0x3501 = 0;
+    unsigned int  reg_0x3502 = 0;
+
+    ret = camera_i2c_read(i2c_adap, 0x3500, &reg_0x3500);
+    ret |= camera_i2c_read(i2c_adap, 0x3501, &reg_0x3501);
+    ret |= camera_i2c_read(i2c_adap, 0x3502, &reg_0x3502);
+
+    shutter = (reg_0x3500 & 0x0f);
+    shutter = (shutter << 8) + reg_0x3501;
+    shutter = (shutter << 4) + (reg_0x3502 >> 4);
+
+    shutter = shutter * 5 / 8;   // for 7.5fps 5M capture
+    priv->preview_exposure_param.shutter = shutter;
+//pr_alert("###############shutter = 0x%x###########\n", shutter);
+    return ret;
+}
+
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	//int auto_white_balance = ctrl->val;
+	int ret = 0;
+	
+	int auto_white_balance;
+		if(ctrl)
+			{
+			auto_white_balance = ctrl->val;
+		}
+		else 
+			{
+				auto_white_balance = 1;
+			}
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		{
+	ctrl->cur.val = auto_white_balance;
+		}
+
+	return ret;
+}
+
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	
+		
+		switch(ctrl->val){
+			case 4:
+				camera_write_array(client->adapter,module_exp_comp_pos4_regs);
+				break;
+			case 3:
+				camera_write_array(client->adapter,module_exp_comp_pos3_regs);
+				break;
+			case 2:
+				camera_write_array(client->adapter,module_exp_comp_pos2_regs);
+				break;
+			case 1:
+				camera_write_array(client->adapter,module_exp_comp_pos1_regs);
+				break;
+			case 0:
+				camera_write_array(client->adapter,module_exp_comp_zero_regs);
+				break;
+			case -1:
+				camera_write_array(client->adapter,module_exp_comp_neg1_regs);
+				break;
+			case -2:
+				camera_write_array(client->adapter,module_exp_comp_neg2_regs);
+				break;
+			case -3:
+				camera_write_array(client->adapter,module_exp_comp_neg3_regs);
+				break;
+			case -4:
+				camera_write_array(client->adapter,module_exp_comp_neg4_regs);
+				break;
+			default:
+				break;		
+		}
+	return ret;
+}
+
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int digital_gain = 0;
+	unsigned int total_gain = 0;
+	int ret = 0;
+
+	ret = camera_i2c_read(client->adapter, 0x56a1, &digital_gain);
+    digital_gain &= 0xFF;
+	/*???,??digital_gain >64(???)??????,<64(???)?????,???????????*/
+	if (digital_gain < 32) {
+		total_gain =  128*32;//on
+	} else {
+		total_gain =  28*32;//off
+	}    
+	
+	return total_gain;
+}
+
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int ret = 0;
+    unsigned int capture_shutter;
+    unsigned int preview_shutter = priv->preview_exposure_param.shutter;
+   	unsigned int  temp = 0;
+
+    capture_shutter = preview_shutter * 15 / 16;
+
+    capture_shutter = capture_shutter * 16;
+    temp = capture_shutter & 0xff;
+    ret |= camera_i2c_write(i2c_adap, 0x3502, temp);
+
+    temp = (capture_shutter & 0xff00) >> 8;
+
+    ret |= camera_i2c_write(i2c_adap, 0x3501, temp);
+    temp = (capture_shutter & 0xff0000) >> 16;
+    ret |= camera_i2c_write(i2c_adap, 0x3500, temp);
+
+    return ret;
+}
+
+
+#if 0
+static int module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	//struct camera_module_priv *priv = to_camera_priv(client);
+   // int colorfx = ctrl->val;
+	int ret = 0;
+#if 0
+	switch (colorfx) {
+	case V4L2_COLORFX_NONE: /* normal */
+		ret = camera_write_array(client, module_effect_normal_regs, ARRAY_SIZE(module_effect_normal_regs));
+		break;
+	
+	case V4L2_COLORFX_BW: /* black and white */
+		ret = camera_write_array(client, module_effect_white_black_regs, ARRAY_SIZE(module_effect_white_black_regs));
+		break;
+	
+	case V4L2_COLORFX_SEPIA: /* antique ,\B8\B4\B9\C5*/
+		ret = camera_write_array(client, module_effect_antique_regs, ARRAY_SIZE(module_effect_antique_regs));
+		break;
+
+	case V4L2_COLORFX_NEGATIVE: /* negative\A3\AC\B8\BAƬ */
+		ret = camera_write_array(client, module_effect_negative_regs, ARRAY_SIZE(module_effect_negative_regs));
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	priv->colorfx = colorfx;
+	ctrl->cur.val = colorfx;
+#endif
+	return ret;
+}
+#endif
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+   // int exposure_auto = ctrl->val;
+	int ret = 0;
+	
+	int exposure_auto;
+		if(ctrl)
+			{
+			exposure_auto = ctrl->val;
+			}
+		else 
+			{
+				exposure_auto = V4L2_EXPOSURE_AUTO;
+			}
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		{
+	ctrl->cur.val = exposure_auto;
+		}
+
+	return 0;
+}
+
+
+
+
+
+
+static int module_pause_af(struct i2c_client *client)
+{	
+
+	unsigned int reg_0x3022,reg_0x3023;
+	int ret = 0;
+	
+	printk("%s, %d, pause af\n", __func__, __LINE__);
+	reg_0x3023 = 0x01;
+	reg_0x3022 = 0x06;
+	ret  = camera_i2c_write(client->adapter, 0x3023, reg_0x3023); 
+	ret |= camera_i2c_write(client->adapter, 0x3022, reg_0x3022); 
+	if (ret) {
+		return ret;
+	}
+msleep(50);
+
+	return ret;
+}
+
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int mode = ctrl->val;
+	unsigned int reg_0x3022;
+	unsigned int reg_0x3023;
+	int ret = 0;
+
+	switch(mode) {
+	case NONE_AF:
+		reg_0x3023 = 0x01;
+		reg_0x3022 = 0x08;
+		ret  = camera_i2c_write(client->adapter, 0x3023, reg_0x3023); 
+		ret |= camera_i2c_write(client->adapter, 0x3022, reg_0x3022); 
+		if (ret) {
+			return ret;
+		}
+		
+		priv->af_mode = NONE_AF;
+		msleep(50);
+		break;
+	
+	case SINGLE_AF:
+#ifndef SINGLE_AF_DISABLE
+		reg_0x3023 = 0x01;
+		reg_0x3022 = 0x03;
+		ret  = camera_i2c_write(client->adapter, 0x3023, reg_0x3023); 
+		ret |= camera_i2c_write(client->adapter, 0x3022, reg_0x3022);
+		if (ret) {
+			return ret;
+		}
+		
+		priv->af_mode = SINGLE_AF;
+		msleep(5);
+#else
+		priv->af_mode = SINGLE_AF;
+#endif
+		break;
+	
+	case CONTINUE_AF:
+		reg_0x3023 = 0x01;
+		reg_0x3022 = 0x04;
+		ret  = camera_i2c_write(client->adapter, 0x3023, reg_0x3023); 
+		ret |= camera_i2c_write(client->adapter, 0x3022, reg_0x3022);
+		if (ret) {
+			return ret; 
+		}
+		
+		priv->af_mode = CONTINUE_AF;
+		msleep(25);
+		printk("in the module_set_af_mode CONTINUE_AF\n");
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	ctrl->cur.val = mode;
+	return ret;
+}
+
+
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = &priv->subdev;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	unsigned int reg_value = 0;
+	
+	
+	switch (priv->af_mode){
+	case NONE_AF:
+		ctrl->val = AF_STATUS_DISABLE;
+		break;
+	
+	case SINGLE_AF:			
+	case CONTINUE_AF:
+		ret |=  camera_i2c_read(client->adapter, 0x3029, &reg_value); 				
+		if (!reg_value) {
+			ctrl->val = AF_STATUS_UNFINISH;	
+//			printk("-----AF_STATUS_UNFINISH----\r\n");
+		} else if(reg_value==0x10||reg_value==0x70){
+			ctrl->val = AF_STATUS_OK;
+//			printk("-----AF_STATUS_OK----\r\n");			
+		}
+		break;
+
+	default:
+		return -ERANGE;
+	}
+	
+	return ret;
+}
+
+
+
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+
+	
+	int ret = 0;
+	   if (!enable) {
+		   GC_INFO("stream down");
+		   printk("in the stream pause \n");
+		   module_pause_af(client);
+			return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+
+	   printk("the width is %d,height is %d\n",priv->win->width,priv->win->height);
+	   ret = camera_write_array(client->adapter,module_init_auto_focus);
+	   GC_INFO("stream on");
+	  return ret;
+}
+
+
+
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	int ret = 0;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		
+		break;
+		
+	default:
+		return -ERANGE;
+	}
+	
+	return ret;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	 unsigned int reg_0x3820 = 0x40;
+    unsigned int reg_0x3821 = 0x00;
+	
+	if ((!mirror) && (!flip)) {
+			printk("%s():no need to set mirror flip \n",__FUNCTION__);
+			return 0;
+		}
+	
+	camera_i2c_read(i2c_adap, 0x3821, &reg_0x3821);
+   if (mirror) {
+        reg_0x3821 |= (0x3 << 1);
+    } else {
+        reg_0x3821 &= ~(0x3 << 1);
+    }
+	camera_i2c_write(i2c_adap, 0x3821, reg_0x3821);
+
+	
+    camera_i2c_read(i2c_adap, 0x3820, &reg_0x3820);
+   if (flip) {
+        reg_0x3821 |= (0x3 << 1);
+    } else {
+        reg_0x3821 &= ~(0x3 << 1);
+    }
+	camera_i2c_write(i2c_adap, 0x3820, reg_0x3820);
+	return ret;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	int ret = 0;
+	unsigned int pidh,pidl;
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	camera_i2c_read(i2c_adap, PIDH, &pidh);
+    camera_i2c_read(i2c_adap, PIDL, &pidl);
+	switch (VERSION(pidh, pidl)) 
+    {
+	case CAMERA_MODULE_PID:
+		if(priv)
+			{
+		     priv->model= V4L2_IDENT_OV5640;
+			}
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, VERSION(pidh, pidl));
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, VERSION(pidh, pidl));
+		return -ENODEV;
+	}
+	return ret;
+}
+
+
+
diff --git a/drivers/media/i2c/camera/owl_camera/Kconfig b/drivers/media/i2c/camera/owl_camera/Kconfig
new file mode 100755
index 0000000..08e162a
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config OWL7059_CAMERA
+	tristate "owl7059 si driver"
+	depends on VIDEO_V4L2
+	help
+	  Support for owl7059 si
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called owl7059_camera.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/owl_camera/Makefile b/drivers/media/i2c/camera/owl_camera/Makefile
new file mode 100755
index 0000000..7766cce
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_OWL7059_CAMERA)	+= owl_camera.o 
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/owl_camera/atm7039c.c b/drivers/media/i2c/camera/owl_camera/atm7039c.c
new file mode 100755
index 0000000..f904c51
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/atm7039c.c
@@ -0,0 +1,803 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/videodev2.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-dev.h>
+#include <media/videobuf2-dma-contig.h>
+#include <linux/slab.h>
+#include <media/soc_camera.h>
+#include <media/soc_mediabus.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/time.h>
+#include <mach/hardware.h>
+#include <asm/delay.h>
+#include <mach/module-owl.h>
+#include <mach/clkname.h>
+#include <mach/powergate.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/mfd/atc260x/atc260x.h>
+#include <linux/io.h>
+
+
+
+
+#include "owl_camera.h"
+
+
+#define HW_NAME "owl_camera"
+#define MAX_WIDTH	4288
+#define MAX_HEIGHT	3000
+#define WORK_CLOCK	60000000     
+#define CROP_X_ALIGN	2
+#define CROP_Y_ALIGN	1
+#define CROP_W_ALIGN	32
+#define CROP_H_ALIGN	4
+#define ISP_PRELINE_NUM 16U
+
+
+static volatile void*	atm_7039_cmu_sensor_clk = 0;	
+static volatile void*	ATM_7039_SI_BASE = 0;
+
+#define     SI_ENABLE             (ATM_7039_SI_BASE+0x00)
+#define     SI_INT_STAT           (ATM_7039_SI_BASE+0x04)
+
+#define     SI_CH0_CTRL           (ATM_7039_SI_BASE+0x08)
+#define     SI_CH0_ROW_RANGE      (ATM_7039_SI_BASE+0x0c)
+#define     SI_CH0_COL_RANGE      (ATM_7039_SI_BASE+0x10)
+#define     SI_CH0_ADDRY          (ATM_7039_SI_BASE+0x14)
+#define     SI_CH0_ADDRU          (ATM_7039_SI_BASE+0x18)
+#define     SI_CH0_ADDRV          (ATM_7039_SI_BASE+0x1c)
+
+#define     SI_CH1_CTRL           (ATM_7039_SI_BASE+0x20)
+#define     SI_CH1_ROW_RANGE      (ATM_7039_SI_BASE+0x24)
+#define     SI_CH1_COL_RANGE      (ATM_7039_SI_BASE+0x28)
+#define     SI_CH1_ADDRY          (ATM_7039_SI_BASE+0x2c)
+#define     SI_CH1_ADDRU          (ATM_7039_SI_BASE+0x30)
+#define     SI_CH1_ADDRV          (ATM_7039_SI_BASE+0x34)
+
+#define CMU_SENSORCLK_INVT0 (0x1 << 12)
+#define CMU_SENSORCLK_INVT1 (0x1 << 13)
+
+// SI_ENABLE
+#define CH1_ENABLE              (0x1<<31)
+#define CH1_PRELINE_NUM_MASK    (0xFFF << 16)
+#define CH1_PRELINE_NUM(x)      ((0xFFF & (x)) << 16)
+#define CH0_ENABLE              (0x1<<15)
+#define CH0_PRELINE_NUM_MASK    (0xFFF)
+#define CH0_PRELINE_NUM(x)      (0xFFF & (x))
+
+#define ROW_START(x)    (0xFFF & (x))
+#define ROW_END(x)      ((0xFFF & (x)) << 16)
+
+#define COL_START(x)    (0x1FFF & (x))
+#define COL_END(x)      ((0x1FFF & (x)) << 16)
+
+//SI_CHx_CTRL
+#define SYNC_POL_HSYNC          (0x1<<13)
+#define SYNC_POL_VSYNC          (0x1<<12)
+#define SEMI_UV_INV             (0x1<<10)
+#define YUV_OUTPUT_FORMAT_MASK  (0x3<<8)    //9:8
+#define YUV_OUTPUT_FORMAT(v)    ((0x3&(v))<<8)
+#define YUV_INPUT_FORMAT_MASK  (0x3<<4)    //5:4
+#define YUV_INPUT_FORMAT(v)    ((0x3&(v))<<4)
+#define SRC_INTF                (0x1<<3)
+#define IN_FMT_MASK             (0)         //2:0
+#define IN_FMT(v)               (v)
+
+// yuv output format
+#define YUV_OUTPUT_FMT_YUV422       YUV_OUTPUT_FORMAT(0)
+#define YUV_OUTPUT_FMT_YUV420       YUV_OUTPUT_FORMAT(1)
+#define YUV_OUTPUT_FMT_YUV422_SEMI  YUV_OUTPUT_FORMAT(2)
+#define YUV_OUTPUT_FMT_YUV420_SEMI  YUV_OUTPUT_FORMAT(3)
+
+// yuv input format(is input format is yuv)
+#define YUV_INPUT_FMT_UYVY  YUV_INPUT_FORMAT(0)
+#define YUV_INPUT_FMT_VYUY  YUV_INPUT_FORMAT(1)
+#define YUV_INPUT_FMT_YUYV  YUV_INPUT_FORMAT(2)
+#define YUV_INPUT_FMT_YVYU  YUV_INPUT_FORMAT(3)
+
+// input format
+#define INT_FMT_RAW8        IN_FMT(0)
+#define INT_FMT_RAW10       IN_FMT(1)
+#define INT_FMT_RAW12       IN_FMT(2)
+#define INT_FMT_YUV         IN_FMT(3)
+#define INT_FMT_RGB565      IN_FMT(4)
+#define INT_FMT_RGB888      IN_FMT(5)
+
+
+//src intf
+#define SRC_INTF_SENSOR     (0x0<<3)   // dvp
+#define SRC_INTF_CSI        (0x1<<3)   // mipi
+
+
+// SI_INT_STAT
+#define CH1_IN_OVERFLOW_PEND    (0x1<<15)
+#define CH1_OUT_OVERFLOW_PEND   (0x1<<14)
+#define CH1_PRELINE_PEND        (0x1<<13)
+#define CH1_FRAME_PEND          (0x1<<12)
+#define CH0_IN_OVERFLOW_PEND    (0x1<<11)
+#define CH0_OUT_OVERFLOW_PEND   (0x1<<10)
+#define CH0_PRELINE_PEND        (0x1<<9)
+#define CH0_FRAME_PEND          (0x1<<8)
+
+#define CH1_PRELINE_IRQ_EN      (0x1<<3)
+#define CH1_FRAME_END_IRQ_EN    (0x1<<2)
+#define CH0_PRELINE_IRQ_EN      (0x1<<1)
+#define CH0_FRAME_END_IRQ_EN    (0x1<<0)
+
+#define CSI_CTRL_EN  (0x1 << 0)
+#define CSI_CTRL_D_PHY_EN    (0x1 << 2)
+#define CSI_CTRL_PHY_INIT    (0x1 << 3)
+#define CSI_CTRL_LANE_NUM(x) (((x) & 0x3) << 4)
+#define CSI_CTRL_ECE (0x1 << 6)
+#define CSI_CTRL_CCE (0x1 << 7)
+#define CSI_CTRL_CLK_LANE_HS  (0x1 << 8)
+#define CSI_CTRL_PHY_INIT_SEL (0x1 << 9)
+
+#define MIPI_PHY_1LANE 0x3
+#define MIPI_PHY_2LANE 0x7
+#define MIPI_PHY_3LANE 0xf
+#define MIPI_PHY_4LANE 0x1f
+
+#define CSI_CONTEXT_EN (0x1 << 0)
+#define CSI_CONTEXT_DT(x) (((x) & 0x3f) << 1)
+
+
+
+
+
+//atm7039 camera si 
+#define ISP_ENABLE                                  (ATM_7039_SI_BASE+0x10)
+#define ISP_CTL                                     (ATM_7039_SI_BASE+0x20)
+#define ISP_CHANNEL_1_ROW_RANGE                     (ATM_7039_SI_BASE+0x2C)
+#define ISP_CHANNEL_1_COL_RANGE                     (ATM_7039_SI_BASE+0x30)
+#define ISP_CHANNEL_1_STATE                         (ATM_7039_SI_BASE+0x24)
+
+#define ISP_OUT_FMT                                 (ATM_7039_SI_BASE+0x148)
+#define ISP_OUT_ADDRY                               (ATM_7039_SI_BASE+0x14C)
+#define ISP_OUT_ADDRU                               (ATM_7039_SI_BASE+0x150)
+#define ISP_OUT_ADDRV                               (ATM_7039_SI_BASE+0x154)
+#define ISP_OUT_ADDR1UV                             (ATM_7039_SI_BASE+0x158)
+
+
+#define ISP_CHANNEL_2_STATE                         (ATM_7039_SI_BASE+0x1F0)
+#define ISP2_CTL                                    (ATM_7039_SI_BASE+0x1EC)
+#define ISP_CHANNEL_2_ROW_RANGE                     (ATM_7039_SI_BASE+0x1F8)
+#define ISP_CHANNEL_2_COL_RANGE                     (ATM_7039_SI_BASE+0x1FC)
+
+
+#define ISP2_OUT_FMT                                (ATM_7039_SI_BASE+0x314)
+#define ISP2_OUT_ADDRY                              (ATM_7039_SI_BASE+0x318)
+#define ISP2_OUT_ADDRU                              (ATM_7039_SI_BASE+0x31C)
+#define ISP2_OUT_ADDRV                              (ATM_7039_SI_BASE+0x320)
+#define ISP2_OUT_ADDR1UV                            (ATM_7039_SI_BASE+0x324)
+
+
+
+#define ISP_INT_STAT                                (ATM_7039_SI_BASE+0x400)
+
+#define CMU_SENSORCLK_INVT0 (0x1 << 12)
+#define CMU_SENSORCLK_INVT1 (0x1 << 13)
+
+#define ISP_CH1_PRELINE_NUM_MASK (0xFFF << 8)
+#define ISP_CH1_PRELINE_NUM(x) ((0xFFF & (x)) << 8)
+
+#define ISP_CH1_COL_START(x)  (0x1FFF & (x))
+#define ISP_CH1_COL_END(x)  ((0x1FFF & (x)) << 16)
+
+#define ISP_CH1_ROW_START(x)  (0xFFF & (x))
+#define ISP_CH1_ROW_END(x)  ((0xFFF & (x)) << 16)
+
+
+#define ISP_CH2_PRELINE_NUM_MASK (0xFFF << 8)
+#define ISP_CH2_PRELINE_NUM(x) ((0xFFF & (x)) << 8)
+
+#define ISP_CH2_COL_START(x)  (0x1FFF & (x))
+#define ISP_CH2_COL_END(x)  ((0x1FFF & (x)) << 16)
+
+#define ISP_CH2_ROW_START(x)  (0xFFF & (x))
+#define ISP_CH2_ROW_END(x)  ((0xFFF & (x)) << 16)
+
+#define ISP_ENABLE_EN (0x1)
+#define ISP_ENABLE_MODE_MASK (0x7 << 1)
+#define ISP_ENABLE_MODE(x)   ((0x7 & (x)) << 1)
+#define ISP_ENABLE_CH1_EN    (0x1 << 4)
+#define ISP_ENABLE_CH2_EN    (0x1 << 5)
+#define ISP_ENABLE_CH1_MODE  (0x1 << 6)
+#define ISP_ENABLE_CH2_MODE  (0x1 << 7)
+#define ISP_ENABLE_CH2_SYNC  (0x1 << 8)
+#define ISP_ENABLE_MASK      (0x1FF)
+
+
+#define ISP_INT_STAT_ISP1_PL_INT_EN (0x1 << 2)
+#define ISP_INT_STAT_ISP2_PL_INT_EN (0x1 << 3)
+#define ISP_INT_STAT_CH1_PL_INT_EN (0x1 << 5)
+#define ISP_INT_STAT_CH2_PL_INT_EN (0x1 << 6)
+#define ISP_INT_STAT_FRAME_END_INT_EN (0x1 << 7)
+#define ISP_INT_STAT_ISP1_PL_PD (0x1 << 10)
+#define ISP_INT_STAT_ISP2_PL_PD (0x1 << 11)
+#define ISP_INT_STAT_AF_OK_PD  (0x1 << 12)
+#define ISP_INT_STAT_CH1_PL_PD (0x1 << 13)
+#define ISP_INT_STAT_CH2_PL_PD (0x1 << 14)
+
+
+
+// isp_out_fmt reg
+#define ISP_OUT_FMT_STRIDE1_MASK  (0x1fff << 16)
+#define ISP_OUT_FMT_STRIDE1(x)    ((0x1fff & (x)) << 16)
+#define ISP_OUT_FMT_SEMI_UV_INV   (0x1 << 15)
+#define ISP_OUT_FMT_STRIDE2_MASK  (0x1ffff << 2)
+#define ISP_OUT_FMT_STRIDE2(x)    ((0x1fff & (x)) << 2)
+#define ISP_OUT_FMT_MASK    0x3
+#define ISP_OUT_FMT_YUV420  0x0
+#define ISP_OUT_FMT_YUV422P 0x1
+#define ISP_OUT_FMT_NV12    0x2
+#define ISP_OUT_FMT_YUYV    0x3
+
+#define ISP_CTL_CHANNEL1_INTF_MIPI (0x1 << 6)
+#define ISP_CTL_CHANNEL1_INTF_PARAL (0x0 << 6)
+#define ISP_CTL_MODE_MASK (0x3 << 4)
+#define ISP_CTL_MODE_RGB8 (0x0 << 4)
+#define ISP_CTL_MODE_RGB10 (0x1 << 4)
+#define ISP_CTL_MODE_RGB12 (0x2 << 4)
+#define ISP_CTL_MODE_YUYV  (0x3 << 4)
+#define ISP_CTL_HSYNC_ACTIVE_HIGH (0x1 << 3)
+#define ISP_CTL_VSYNC_ACTIVE_HIGH (0x1 << 2)
+#define ISP_CTL_COLOR_SEQ_MASK 0x3
+#define ISP_CTL_COLOR_SEQ_UYVY 0x0
+#define ISP_CTL_COLOR_SEQ_VYUY 0x1
+#define ISP_CTL_COLOR_SEQ_YUYV 0x2
+#define ISP_CTL_COLOR_SEQ_YVYU 0x3
+#define ISP_CTL_COLOR_SEQ_SBGGR 0x0
+#define ISP_CTL_COLOR_SEQ_SGRBG 0x1
+#define ISP_CTL_COLOR_SEQ_SGBRG 0x2
+#define ISP_CTL_COLOR_SEQ_SRGGB 0x3
+
+#define ISP2_CTL_CHANNEL_INTF_MIPI (0x1 << 5)
+#define ISP2_CTL_CHANNEL_INTF_PARAL (0x0 << 5)
+#define ISP2_CTL_MODE_MASK (0x1 << 4)
+#define ISP2_CTL_MODE_RGB (0x0 << 4)
+#define ISP2_CTL_MODE_YUYV  (0x1 << 4)
+#define ISP2_CTL_HSYNC_ACTIVE_HIGH (0x1 << 3)
+#define ISP2_CTL_VSYNC_ACTIVE_HIGH (0x1 << 2)
+#define ISP2_CTL_COLOR_SEQ_MASK 0x3
+#define ISP2_CTL_COLOR_SEQ_UYVY 0x0
+#define ISP2_CTL_COLOR_SEQ_VYUY 0x1
+#define ISP2_CTL_COLOR_SEQ_YUYV 0x2
+#define ISP2_CTL_COLOR_SEQ_YVYU 0x3
+#define ISP2_CTL_COLOR_SEQ_SBGGR 0x0
+#define ISP2_CTL_COLOR_SEQ_SGRBG 0x1
+#define ISP2_CTL_COLOR_SEQ_SGBRG 0x2
+#define ISP2_CTL_COLOR_SEQ_SRGGB 0x3
+
+
+#define CSI_CTRL_EN  (0x1 << 0)
+#define CSI_CTRL_D_PHY_EN    (0x1 << 2)
+#define CSI_CTRL_PHY_INIT    (0x1 << 3)
+#define CSI_CTRL_LANE_NUM(x) (((x) & 0x3) << 4)
+#define CSI_CTRL_ECE (0x1 << 6)
+#define CSI_CTRL_CCE (0x1 << 7)
+#define CSI_CTRL_CLK_LANE_HS  (0x1 << 8)
+#define CSI_CTRL_PHY_INIT_SEL (0x1 << 9)
+
+#define MIPI_PHY_1LANE 0x3
+#define MIPI_PHY_2LANE 0x7
+#define MIPI_PHY_3LANE 0xf
+#define MIPI_PHY_4LANE 0x1f
+
+#define CSI_CONTEXT_EN (0x1 << 0)
+#define CSI_CONTEXT_DT(x) (((x) & 0x3f) << 1)
+
+#define CONTEXT_DT_RAW8  (0x2A)
+#define CONTEXT_DT_RAW10 (0x2B)
+#define CONTEXT_DT_RAW12 (0x2C)
+
+
+
+
+
+
+
+
+
+
+static int atm_7039_hw_adapter_init(struct owl_camera_hw_adapter* hw,struct platform_device *pdev)
+{
+	struct resource *res;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource\n");
+		return -ENODEV;
+	}
+	//DBG_ERR("res->start is  : 0x%x,resource size is 0x%x",res->start,resource_size(res));
+	
+	if (!request_mem_region(res->start,
+					resource_size(res), "isp")) {
+			dev_err(&pdev->dev, "Unable to request register region\n");
+			return -EBUSY;
+		}	
+
+	ATM_7039_SI_BASE = devm_ioremap(&pdev->dev,res->start,resource_size(res));
+	if(!ATM_7039_SI_BASE)
+		return -ENXIO;
+	printk("SI paddr is %x",(int)ATM_7039_SI_BASE);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource\n");
+		return -ENODEV;
+	}
+	printk("res->start is  : 0x%x,resource size is 0x%x",res->start,resource_size(res));
+	
+	if (!request_mem_region(res->start,
+					resource_size(res), "isp")) {
+			dev_err(&pdev->dev, "Unable to request register region\n");
+			return -EBUSY;
+		}	
+	atm_7039_cmu_sensor_clk = devm_ioremap(&pdev->dev,res->start,resource_size(res));
+	if(!atm_7039_cmu_sensor_clk)
+		return -ENXIO;
+	return 0;
+	
+}
+
+
+
+
+
+
+
+static int atm_7039_get_channel_state(struct owl_camera_hw_adapter* hw, int channel)
+{
+    
+   return readl(ISP_INT_STAT);
+}
+
+
+static int atm_7039_set_channel_if(struct owl_camera_hw_adapter* hw, int channel, int bus_type)
+{
+	unsigned long ch1_intf,ch2_intf;
+    volatile void * reg = 0;
+    unsigned long value;
+
+	if (V4L2_MBUS_PARALLEL == bus_type) {
+        ch1_intf = ISP_CTL_CHANNEL1_INTF_PARAL;
+		ch2_intf = ISP2_CTL_CHANNEL_INTF_PARAL;
+    } else {
+        ch1_intf = ISP_CTL_CHANNEL1_INTF_MIPI;
+		ch2_intf = ISP2_CTL_CHANNEL_INTF_MIPI;
+    }
+	 // intf
+    if (ISP_CHANNEL_0 == channel) {
+        reg = ISP_CTL;
+		value = readl(ISP_CTL);
+	    value &= ~ISP_CTL_CHANNEL1_INTF_MIPI;
+		value  |= (ch1_intf);
+    } else {
+        reg = ISP2_CTL;
+		value = readl(ISP2_CTL);
+		value  &= ~ISP2_CTL_CHANNEL_INTF_MIPI;
+		value  |= (ch2_intf);
+    }
+    writel(value, reg);
+    return 0;
+}
+
+
+static int atm_7039_set_channel_int_en(struct owl_camera_hw_adapter* hw, int channel)
+{
+	
+	//channel enable
+	int ret = 0;
+	unsigned long isp_enable,isp_int_stat;
+   isp_enable = readl(ISP_ENABLE);
+   isp_enable &= ~(ISP_ENABLE_MASK);
+   if (ISP_CHANNEL_0 == channel) {
+   		isp_int_stat = readl(ISP_INT_STAT);
+		isp_int_stat |= ISP_INT_STAT_ISP1_PL_INT_EN;
+		writel(isp_int_stat, ISP_INT_STAT);
+		isp_enable |= (ISP_ENABLE_EN | ISP_ENABLE_MODE(1) | ISP_ENABLE_CH1_EN | ISP_ENABLE_CH1_MODE);
+   } else {
+   		isp_int_stat = readl(ISP_INT_STAT);
+        isp_int_stat |= ISP_INT_STAT_ISP2_PL_INT_EN;
+        writel(isp_int_stat, ISP_INT_STAT);
+		isp_enable |= (ISP_ENABLE_EN | ISP_ENABLE_MODE(2) | ISP_ENABLE_CH2_EN | ISP_ENABLE_CH2_MODE);
+   }
+   writel(isp_enable, SI_ENABLE);
+
+   
+   return ret;
+}
+
+
+static int atm_7039_set_channel_addrY(struct owl_camera_hw_adapter* hw, int channel, void *addrY)
+{
+    if(ISP_CHANNEL_0 == channel)
+    {
+        writel((u32)addrY, ISP_OUT_ADDRY); 
+    }
+    else
+    {
+        writel((u32)addrY, ISP2_OUT_ADDRY);
+    }
+    return 0;
+}
+static int atm_7039_set_channel_addrU(struct owl_camera_hw_adapter* hw, int channel, void *addrU)
+{
+    
+    if(ISP_CHANNEL_0 == channel)
+    {
+        writel((u32)addrU, ISP_OUT_ADDRU); 
+    }
+    else
+    {
+        writel((u32)addrU, ISP2_OUT_ADDRU);
+    }
+    return 0;
+}
+static int atm_7039_set_channel_addrV(struct owl_camera_hw_adapter* hw, int channel, void *addrV)
+{
+    if(ISP_CHANNEL_0 == channel)
+    {
+        writel((u32)addrV, ISP_OUT_ADDRV); 
+    }
+    else
+    {
+        writel((u32)addrV, ISP2_OUT_ADDRV);
+    }
+    return 0;
+}
+static int atm_7039_set_channel_addr1UV(struct owl_camera_hw_adapter* hw, int channel, void *addr1UV)
+{
+	 if(ISP_CHANNEL_0 == channel)
+    {
+        writel((u32)addr1UV, ISP_OUT_ADDRU); 
+    }
+    else
+    {
+        writel((u32)addr1UV, ISP2_OUT_ADDRU);
+    }
+    return 0;
+}
+
+static int atm_7039_set_channel_input_fmt(struct owl_camera_hw_adapter* hw, int channel, enum v4l2_mbus_pixelcode code)
+{
+	unsigned int isp_ctl = readl(ISP_CTL);
+    unsigned int isp2_ctl = readl(ISP2_CTL);
+
+
+    isp_ctl &= ~(ISP_CTL_MODE_MASK | ISP_CTL_COLOR_SEQ_MASK);
+    isp2_ctl &= ~(ISP2_CTL_MODE_MASK | ISP2_CTL_COLOR_SEQ_MASK);
+
+    switch (code) {
+    case V4L2_MBUS_FMT_UYVY8_2X8:{  /* UYVY */
+            // should be the same as senor's output format
+            isp_ctl |= (ISP_CTL_MODE_YUYV | ISP_CTL_COLOR_SEQ_UYVY);
+            isp2_ctl |= (ISP2_CTL_MODE_YUYV | ISP2_CTL_COLOR_SEQ_UYVY);
+            isp_info("input format UYVY, 1pix/clk\n");
+            break;
+        }
+    case V4L2_MBUS_FMT_SGRBG8_1X8:{
+            isp_info("input format RAW SGRBG8 - ");
+            
+                isp_ctl |= ISP_CTL_MODE_RGB10 | ISP_CTL_COLOR_SEQ_SBGGR;
+                isp_info("10bit\n");
+            
+            isp2_ctl |= ISP2_CTL_MODE_RGB | ISP2_CTL_COLOR_SEQ_SGRBG;
+
+            break;
+        }
+    case V4L2_MBUS_FMT_SRGGB8_1X8:
+    	{
+    		isp_info("input format RAW SRGGB - ");
+            
+                isp_ctl |= ISP_CTL_MODE_RGB10 | ISP_CTL_COLOR_SEQ_SGBRG;//ISP_CTL_COLOR_SEQ_SRGGB;
+                isp_info("10bit\n");
+            
+            isp2_ctl |= ISP2_CTL_MODE_RGB | ISP2_CTL_COLOR_SEQ_SGRBG;
+
+            break;
+    	}
+    	case V4L2_MBUS_FMT_SGBRG8_1X8:
+    	{
+    		isp_info("input format RAW GBRG - ");
+           
+                isp_ctl |= ISP_CTL_MODE_RGB10 | ISP_CTL_COLOR_SEQ_SGBRG;
+                isp_info("10bit\n");
+           
+            isp2_ctl |= ISP2_CTL_MODE_RGB | ISP2_CTL_COLOR_SEQ_SGRBG;
+
+            break;
+    	}
+    	case V4L2_MBUS_FMT_SBGGR8_1X8:
+    	{
+    		isp_info("input format RAW BGGR - ");
+           
+                isp_ctl |= ISP_CTL_MODE_RGB10 | ISP_CTL_COLOR_SEQ_SBGGR;
+                isp_info("10bit\n");
+          
+            isp2_ctl |= ISP2_CTL_MODE_RGB | ISP2_CTL_COLOR_SEQ_SGRBG;
+
+            break;
+    	}
+    default:
+        isp_err("input data error (pixel code:0x%x)\n", code);
+        break;
+
+    }
+
+    if (ISP_CHANNEL_0 == channel) {
+        writel(isp_ctl, ISP_CTL);
+    } else {
+        writel(isp2_ctl, ISP2_CTL);
+    }
+	return 0;
+}
+
+static int atm_7039_set_channel_output_fmt(struct owl_camera_hw_adapter* hw, int channel, u32 fourcc)
+{
+	unsigned int isp_out_fmt = readl(ISP_OUT_FMT);
+    unsigned int isp2_out_fmt = readl(ISP2_OUT_FMT);
+
+    isp_out_fmt &= ~ISP_OUT_FMT_MASK;
+    isp2_out_fmt &= ~ISP_OUT_FMT_MASK;
+
+    switch (fourcc) {
+    case V4L2_PIX_FMT_YUV420: {  //420 planar
+            isp_out_fmt |= ISP_OUT_FMT_YUV420;
+            isp2_out_fmt |= ISP_OUT_FMT_YUV420;
+            printk("output format YUV420\n");
+            break;
+        }
+    case V4L2_PIX_FMT_YUV422P: { //422 semi planar
+            isp_out_fmt |= ISP_OUT_FMT_YUV422P;
+            isp2_out_fmt |= ISP_OUT_FMT_YUV422P;
+            printk("output format YUV422P\n");
+            break;
+        }
+    case V4L2_PIX_FMT_NV12: {    //420 semi-planar
+            isp_out_fmt |= ISP_OUT_FMT_NV12;
+            isp2_out_fmt |= ISP_OUT_FMT_NV12;
+            printk("output format NV12\n");
+            break;
+        }
+    case V4L2_PIX_FMT_YUYV: {   //interleaved
+            isp_out_fmt |= ISP_OUT_FMT_YUYV;
+            isp2_out_fmt |= ISP_OUT_FMT_YUYV;
+            printk("output format YUYV\n");
+            break;
+        }
+    default:   /* Raw RGB */
+        printk("set isp output format failed, fourcc = 0x%x\n", fourcc);
+        return -EINVAL;
+    }
+
+    if (ISP_CHANNEL_0 == channel) {
+        writel(isp_out_fmt, ISP_OUT_FMT);
+    } else {
+        writel(isp2_out_fmt, ISP2_OUT_FMT);
+    }
+    return 0;
+
+}
+
+
+static int atm_7039_set_channel_preline(struct owl_camera_hw_adapter* hw, int channel, int preline)
+{
+	 unsigned int state;
+
+
+    if (ISP_CHANNEL_0 == channel) {
+        state = readl(ISP_CHANNEL_1_STATE);
+        state &= ~ISP_CH1_PRELINE_NUM_MASK;
+        state |= ISP_CH1_PRELINE_NUM(channel + ISP_PRELINE_NUM);
+        writel(state, ISP_CHANNEL_1_STATE);
+    } else {
+        state =readl(ISP_CHANNEL_2_STATE);
+        state &= ~ISP_CH2_PRELINE_NUM_MASK;
+        state |= ISP_CH2_PRELINE_NUM(channel + ISP_PRELINE_NUM);
+        writel(state, ISP_CHANNEL_2_STATE);
+    }
+    return 0;
+}
+
+static int atm_7039_clear_channel_int_en(struct owl_camera_hw_adapter* hw, int channel)
+{
+	unsigned int isp_enable;
+	 if (ISP_CHANNEL_0 == channel) {
+        writel(isp_enable & (~(ISP_ENABLE_EN | ISP_ENABLE_CH1_EN)), ISP_ENABLE);
+    } else {
+        writel(isp_enable & (~(ISP_ENABLE_EN | ISP_ENABLE_CH2_EN)), ISP_ENABLE);
+    }
+    return 0;
+}
+
+static int atm_7039_set_channel_preline_int_en(struct owl_camera_hw_adapter* hw, int channel)
+{
+    return 0;
+}
+
+static int atm_7039_set_channel_frameend_int_en(struct owl_camera_hw_adapter* hw, int channel)
+{
+
+    u32 int_stat;
+    int_stat = readl(SI_INT_STAT);
+    int_stat &= ~(CH0_PRELINE_IRQ_EN | CH1_PRELINE_IRQ_EN);
+	if(ISP_CHANNEL_0 == channel)
+	{
+		writel(int_stat | CH0_FRAME_END_IRQ_EN, SI_INT_STAT);
+	}
+	else 
+	{
+		writel(int_stat | CH1_FRAME_END_IRQ_EN, SI_INT_STAT);
+	}
+    return 0;
+    
+}
+
+static int atm_7039_clear_channel_preline_pending(struct owl_camera_hw_adapter* hw, unsigned int isp_int_stat)
+{
+	isp_int_stat &= ~CH0_FRAME_END_IRQ_EN;
+    isp_int_stat |= (0x7<<8);
+    writel(isp_int_stat, SI_INT_STAT);
+    return 0;
+}
+
+static int atm_7039_clear_channel_frameend_pending(struct owl_camera_hw_adapter* hw,  unsigned int isp_int_stat)
+{
+	
+    return 0;
+}
+
+
+static int atm_7039_set_signal_polarity(struct owl_camera_hw_adapter* hw, int channel,unsigned int common_flags)
+{
+	u32 cmu_sensorclk;
+	volatile void * reg = 0;
+    unsigned long value;
+
+	cmu_sensorclk = readl(atm_7039_cmu_sensor_clk);
+
+    if (ISP_CHANNEL_0 == channel) {
+       // isp_ctl = readl(ISP_CTL);
+		reg = ISP_CTL;
+        if (common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING) {
+            cmu_sensorclk |= CMU_SENSORCLK_INVT0;
+        } else {
+            cmu_sensorclk &= ~CMU_SENSORCLK_INVT0;
+        }
+        /*if (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW) {
+            isp_ctl &= ~ISP_CTL_HSYNC_ACTIVE_HIGH;
+        } else {
+            isp_ctl |= ISP_CTL_HSYNC_ACTIVE_HIGH;
+        }
+        if (common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW) {
+            isp_ctl &= ~ISP_CTL_VSYNC_ACTIVE_HIGH;
+        } else {
+            isp_ctl |= ISP_CTL_VSYNC_ACTIVE_HIGH;
+        }
+        writel(isp_ctl, ISP_CTL);*/
+    } else {
+        //isp2_ctl = readl(ISP2_CTL);
+		
+		reg = ISP2_CTL;
+        if (common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING) {
+            cmu_sensorclk |= CMU_SENSORCLK_INVT1;
+        } else {
+            cmu_sensorclk &= ~CMU_SENSORCLK_INVT1;
+        }
+
+		/*if (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW) {
+            isp2_ctl &= ~ISP2_CTL_HSYNC_ACTIVE_HIGH;
+        } else {
+            isp2_ctl |= ISP2_CTL_HSYNC_ACTIVE_HIGH;
+        }
+        if (common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW) {
+            isp2_ctl &= ~ISP2_CTL_VSYNC_ACTIVE_HIGH;
+        } else {
+            isp2_ctl |= ISP2_CTL_VSYNC_ACTIVE_HIGH;
+        }
+        writel(isp2_ctl, ISP2_CTL);*/
+    }
+	value = readl(reg);
+	 if (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW) {
+        value &= ~SYNC_POL_HSYNC;
+    } else {
+        value |= SYNC_POL_HSYNC;
+    }
+    if (common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW) {
+        value &= ~SYNC_POL_VSYNC;
+    } else {
+        value |= SYNC_POL_VSYNC;
+    }
+	printk("before writel\n");
+    writel(value, reg);
+    writel(cmu_sensorclk, atm_7039_cmu_sensor_clk);
+	return 0;
+}
+
+
+
+static int atm_7039_set_col_range(struct owl_camera_hw_adapter* hw,int channel,unsigned int start,unsigned int end)
+{
+	int ret = 0;
+	  if (ISP_CHANNEL_0 == channel) {
+        writel(ISP_CH1_COL_START(start) | ISP_CH1_COL_END(end), ISP_CHANNEL_1_COL_RANGE);
+    } else {
+        writel(ISP_CH2_COL_START(start) | ISP_CH2_COL_END(end), ISP_CHANNEL_2_COL_RANGE);
+    }
+	return ret;
+}
+
+static int atm_7039_set_row_range(struct owl_camera_hw_adapter* hw,int channel,unsigned int start,unsigned int end)
+{
+	int ret = 0;
+	 if (ISP_CHANNEL_0 == channel) {
+        writel(ISP_CH1_ROW_START(start) | ISP_CH1_ROW_END(end), ISP_CHANNEL_1_ROW_RANGE);
+    } else {
+        writel(ISP_CH2_ROW_START(start) | ISP_CH2_ROW_END(end), ISP_CHANNEL_2_ROW_RANGE);
+    }
+	return ret;
+}
+
+
+
+
+
+static struct owl_camera_hw_ops atm7039_hw_ops = {
+	.hw_adapter_init = atm_7039_hw_adapter_init,
+    .get_channel_state = atm_7039_get_channel_state,
+    .set_channel_if = atm_7039_set_channel_if,
+    .set_channel_addrY = atm_7039_set_channel_addrY,
+    .set_channel_addrU = atm_7039_set_channel_addrU,
+    .set_channel_addrV = atm_7039_set_channel_addrV,
+    .set_channel_addr1UV = atm_7039_set_channel_addr1UV,
+    .set_channel_input_fmt = atm_7039_set_channel_input_fmt,
+    .set_channel_output_fmt = atm_7039_set_channel_output_fmt,
+    .set_channel_preline = atm_7039_set_channel_preline,
+    .clear_channel_int_en = atm_7039_clear_channel_int_en,
+    .set_channel_preline_int_en = atm_7039_set_channel_preline_int_en,
+    .set_channel_frameend_int_en = atm_7039_set_channel_frameend_int_en,
+    .clear_channel_preline_pending = atm_7039_clear_channel_preline_pending,
+    .clear_channel_frameend_pending = atm_7039_clear_channel_frameend_pending,
+    .set_signal_polarity = atm_7039_set_signal_polarity,
+    .set_col_range = atm_7039_set_col_range,
+    .set_row_range = atm_7039_set_row_range,
+    .set_channel_int_en = atm_7039_set_channel_int_en,
+};
+struct owl_camera_hw_adapter atm7039_hw_adapter = {
+    .hw_name = HW_NAME,
+
+    .cam_dev = NULL,
+
+    .max_channel = 1,
+    .has_isp = 0,
+    .is_3D_support = 0,
+    .crop_x_align = CROP_X_ALIGN,
+    .crop_y_align = CROP_Y_ALIGN,
+    .crop_w_align = CROP_W_ALIGN,
+    .crop_h_align = CROP_H_ALIGN,
+    .max_width = MAX_WIDTH,
+    .max_height = MAX_HEIGHT,
+	.preline_int_pd = ISP_INT_STAT_ISP1_PL_PD,
+
+
+    .power_ref = 0,
+    .enable_ref = 0,
+    .hw_clk = NULL,
+
+    .ops = &atm7039_hw_ops,
+};
diff --git a/drivers/media/i2c/camera/owl_camera/atm7059.c b/drivers/media/i2c/camera/owl_camera/atm7059.c
new file mode 100755
index 0000000..48270e4
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/atm7059.c
@@ -0,0 +1,704 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/videodev2.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-dev.h>
+#include <media/videobuf2-dma-contig.h>
+#include <linux/slab.h>
+#include <media/soc_camera.h>
+#include <media/soc_mediabus.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/time.h>
+#include <mach/hardware.h>
+#include <asm/delay.h>
+#include <mach/module-owl.h>
+#include <mach/clkname.h>
+#include <mach/powergate.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/mfd/atc260x/atc260x.h>
+#include <linux/io.h>
+
+
+
+
+#include "owl_camera.h"
+
+
+#define HW_NAME "owl_camera"
+#define MAX_WIDTH	4288
+#define MAX_HEIGHT	3000
+#define WORK_CLOCK	60000000     
+#define CROP_X_ALIGN	2
+#define CROP_Y_ALIGN	1
+#define CROP_W_ALIGN	32
+#define CROP_H_ALIGN	4
+#define ISP_PRELINE_NUM 16U
+
+static volatile void*	atm_7059_cmu_sensor_clk = 0;	
+static volatile void*	ATM_7059_SI_BASE = 0;
+
+#define     ATM_7059_SI_ENABLE             (ATM_7059_SI_BASE+0x00)
+#define     ATM_7059_SI_INT_STAT           (ATM_7059_SI_BASE+0x04)
+
+#define     ATM_7059_SI_CH0_CTRL           (ATM_7059_SI_BASE+0x08)
+#define     ATM_7059_SI_CH0_ROW_RANGE      (ATM_7059_SI_BASE+0x0c)
+#define     ATM_7059_SI_CH0_COL_RANGE      (ATM_7059_SI_BASE+0x10)
+#define     ATM_7059_SI_CH0_ADDRY          (ATM_7059_SI_BASE+0x14)
+#define     ATM_7059_SI_CH0_ADDRU          (ATM_7059_SI_BASE+0x18)
+#define     ATM_7059_SI_CH0_ADDRV          (ATM_7059_SI_BASE+0x1c)
+
+#define     ATM_7059_SI_CH1_CTRL           (ATM_7059_SI_BASE+0x20)
+#define     ATM_7059_SI_CH1_ROW_RANGE      (ATM_7059_SI_BASE+0x24)
+#define     ATM_7059_SI_CH1_COL_RANGE      (ATM_7059_SI_BASE+0x28)
+#define     ATM_7059_SI_CH1_ADDRY          (ATM_7059_SI_BASE+0x2c)
+#define     ATM_7059_SI_CH1_ADDRU          (ATM_7059_SI_BASE+0x30)
+#define     ATM_7059_SI_CH1_ADDRV          (ATM_7059_SI_BASE+0x34)
+
+#define ATM_7059_CMU_SENSORCLK_INVT0 (0x1 << 12)
+#define ATM_7059_CMU_SENSORCLK_INVT1 (0x1 << 13)
+
+// SI_ENABLE
+#define CH1_ENABLE              (0x1<<31)
+#define CH1_PRELINE_NUM_MASK    (0xFFF << 16)
+#define CH1_PRELINE_NUM(x)      ((0xFFF & (x)) << 16)
+#define CH0_ENABLE              (0x1<<15)
+#define CH0_PRELINE_NUM_MASK    (0xFFF)
+#define CH0_PRELINE_NUM(x)      (0xFFF & (x))
+
+#define ROW_START(x)    (0xFFF & (x))
+#define ROW_END(x)      ((0xFFF & (x)) << 16)
+
+#define COL_START(x)    (0x1FFF & (x))
+#define COL_END(x)      ((0x1FFF & (x)) << 16)
+
+//SI_CHx_CTRL
+#define SYNC_POL_HSYNC          (0x1<<13)
+#define SYNC_POL_VSYNC          (0x1<<12)
+#define SEMI_UV_INV             (0x1<<10)
+#define YUV_OUTPUT_FORMAT_MASK  (0x3<<8)    //9:8
+#define YUV_OUTPUT_FORMAT_UV_REVERSE  (0x1<<10)    //10
+
+#define YUV_OUTPUT_FORMAT(v)    ((0x3&(v))<<8)
+#define YUV_INPUT_FORMAT_MASK  (0x3<<4)    //5:4
+#define YUV_INPUT_FORMAT(v)    ((0x3&(v))<<4)
+#define SRC_INTF                (0x1<<3)
+#define IN_FMT_MASK             (0)         //2:0
+#define IN_FMT(v)               (v)
+
+// yuv output format
+#define YUV_OUTPUT_FMT_YUV422       YUV_OUTPUT_FORMAT(0)
+#define YUV_OUTPUT_FMT_YUV420       YUV_OUTPUT_FORMAT(1)
+#define YUV_OUTPUT_FMT_YUV422_SEMI  YUV_OUTPUT_FORMAT(2)
+#define YUV_OUTPUT_FMT_YUV420_SEMI  YUV_OUTPUT_FORMAT(3)
+
+// yuv input format(is input format is yuv)
+#define YUV_INPUT_FMT_UYVY  YUV_INPUT_FORMAT(0)
+#define YUV_INPUT_FMT_VYUY  YUV_INPUT_FORMAT(1)
+#define YUV_INPUT_FMT_YUYV  YUV_INPUT_FORMAT(2)
+#define YUV_INPUT_FMT_YVYU  YUV_INPUT_FORMAT(3)
+
+// input format
+#define INT_FMT_RAW8        IN_FMT(0)
+#define INT_FMT_RAW10       IN_FMT(1)
+#define INT_FMT_RAW12       IN_FMT(2)
+#define INT_FMT_YUV         IN_FMT(3)
+#define INT_FMT_RGB565      IN_FMT(4)
+#define INT_FMT_RGB888      IN_FMT(5)
+
+
+//src intf
+#define SRC_INTF_SENSOR     (0x0<<3)   // dvp
+#define SRC_INTF_CSI        (0x1<<3)   // mipi
+
+
+// SI_INT_STAT
+#define CH1_IN_OVERFLOW_PEND    (0x1<<15)
+#define CH1_OUT_OVERFLOW_PEND   (0x1<<14)
+#define CH1_PRELINE_PEND        (0x1<<13)
+#define CH1_FRAME_PEND          (0x1<<12)
+#define CH0_IN_OVERFLOW_PEND    (0x1<<11)
+#define CH0_OUT_OVERFLOW_PEND   (0x1<<10)
+#define CH0_PRELINE_PEND        (0x1<<9)
+#define CH0_FRAME_PEND          (0x1<<8)
+
+#define CH1_PRELINE_IRQ_EN      (0x1<<3)
+#define CH1_FRAME_END_IRQ_EN    (0x1<<2)
+#define CH0_PRELINE_IRQ_EN      (0x1<<1)
+#define CH0_FRAME_END_IRQ_EN    (0x1<<0)
+
+#define CSI_CTRL_EN  (0x1 << 0)
+#define CSI_CTRL_D_PHY_EN    (0x1 << 2)
+#define CSI_CTRL_PHY_INIT    (0x1 << 3)
+#define CSI_CTRL_LANE_NUM(x) (((x) & 0x3) << 4)
+#define CSI_CTRL_ECE (0x1 << 6)
+#define CSI_CTRL_CCE (0x1 << 7)
+#define CSI_CTRL_CLK_LANE_HS  (0x1 << 8)
+#define CSI_CTRL_PHY_INIT_SEL (0x1 << 9)
+
+#define MIPI_PHY_1LANE 0x3
+#define MIPI_PHY_2LANE 0x7
+#define MIPI_PHY_3LANE 0xf
+#define MIPI_PHY_4LANE 0x1f
+
+#define CSI_CONTEXT_EN (0x1 << 0)
+#define CSI_CONTEXT_DT(x) (((x) & 0x3f) << 1)
+
+static struct owl_camera_reg restored_regs[8];
+
+
+
+
+#define RESTORED_REG_NUM  8
+
+
+void*	noc_si_to_ddr = NULL;	
+void*	gpio_dinen = NULL;	
+void*	si_reset = NULL;	
+
+
+
+
+
+static int atm_7059_hw_adapter_init(struct owl_camera_hw_adapter* hw,struct platform_device *pdev)
+{
+
+	struct resource *res;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource\n");
+		
+		return -ENODEV;
+	}
+	//DBG_ERR("res->start is  : 0x%x,resource size is 0x%x",res->start,resource_size(res));
+	
+	if (!request_mem_region(res->start,
+					resource_size(res), "isp")) {
+			dev_err(&pdev->dev, "Unable to request register region\n");
+			return -EBUSY;
+		}	
+
+	ATM_7059_SI_BASE = devm_ioremap(&pdev->dev,res->start,resource_size(res));
+	if(!ATM_7059_SI_BASE)
+		return -ENXIO;
+	printk("SI paddr is %x",(int)ATM_7059_SI_BASE);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource\n");
+		return -ENODEV;
+	}
+	printk("res->start is  : 0x%x,resource size is 0x%x",res->start,resource_size(res));
+	
+	if (!request_mem_region(res->start,
+					resource_size(res), "isp")) {
+			dev_err(&pdev->dev, "Unable to request register region\n");
+			return -EBUSY;
+		}	
+	atm_7059_cmu_sensor_clk = devm_ioremap(&pdev->dev,res->start,resource_size(res));
+	if(!atm_7059_cmu_sensor_clk)
+		return -ENXIO;
+	noc_si_to_ddr = ioremap(0xb0500508,4);
+	restored_regs[0].reg = ATM_7059_SI_ENABLE;
+	restored_regs[1].reg = ATM_7059_SI_CH0_CTRL;
+	restored_regs[2].reg = ATM_7059_SI_INT_STAT;
+	restored_regs[3].reg = ATM_7059_SI_CH0_ROW_RANGE;
+	restored_regs[4].reg = ATM_7059_SI_CH0_COL_RANGE;
+	restored_regs[5].reg = ATM_7059_SI_CH0_ADDRY;
+	restored_regs[6].reg = ATM_7059_SI_CH0_ADDRU;
+	restored_regs[7].reg = ATM_7059_SI_CH0_ADDRV;
+	gpio_dinen = ioremap(0xb01b0028,4);
+	si_reset = ioremap(0xb01b001c,4);
+	return 0;
+	
+}
+
+
+
+static int atm_7059_get_channel_state(struct owl_camera_hw_adapter* hw, int channel)
+{
+    
+   return readl(ATM_7059_SI_INT_STAT);
+}
+
+int atm_7059_get_channel_overflow(struct owl_camera_hw_adapter* hw, int channel)
+{
+	u32 si_con_stat;
+    si_con_stat = readl(ATM_7059_SI_INT_STAT);
+
+    return si_con_stat&(0x3<<10);
+}
+
+int atm_7059_clear_channel_overflow(struct owl_camera_hw_adapter* hw, int channel)
+{
+	 u32 si_con_stat;
+    si_con_stat = readl(ATM_7059_SI_INT_STAT);
+    //si_con_stat &= ~(0xf<<8);
+   // si_con_stat |= (0x3<<10);
+    writel(si_con_stat, ATM_7059_SI_INT_STAT);
+    return 0;
+
+}
+
+
+
+static int atm_7059_set_channel_if(struct owl_camera_hw_adapter* hw, int channel, int bus_type)
+{
+	unsigned long intf;
+    volatile void * reg = 0;
+    unsigned long value;
+	 // intf
+    if (ISP_CHANNEL_0 == channel) {
+        reg = ATM_7059_SI_CH0_CTRL;
+    } else {
+        reg = ATM_7059_SI_CH1_CTRL;
+    }
+    value = readl(reg);
+
+    if (V4L2_MBUS_PARALLEL == bus_type) {
+        intf = SRC_INTF_SENSOR;
+    } else {
+        intf = SRC_INTF_CSI;
+    }
+    value &= ~SRC_INTF;
+    value |= intf;
+    writel(value, reg);
+    return 0;
+}
+
+static int atm_7059_set_channel_addrY(struct owl_camera_hw_adapter* hw, int channel, void *addrY)
+{
+    if(ISP_CHANNEL_0 == channel)
+    {
+        writel((u32)addrY, ATM_7059_SI_CH0_ADDRY); 
+    }
+    else
+    {
+        writel((u32)addrY, ATM_7059_SI_CH1_ADDRY);
+    }
+    return 0;
+}
+static int atm_7059_set_channel_addrU(struct owl_camera_hw_adapter* hw, int channel, void *addrU)
+{
+    
+    if(ISP_CHANNEL_0 == channel)
+    {
+        writel((u32)addrU,  ATM_7059_SI_CH0_ADDRU ); 
+    }
+    else
+    {
+        writel((u32)addrU, ATM_7059_SI_CH1_ADDRU);
+    }
+    return 0;
+}
+static int atm_7059_set_channel_addrV(struct owl_camera_hw_adapter* hw, int channel, void *addrV)
+{
+    if(ISP_CHANNEL_0 == channel)
+    {
+        writel((u32)addrV,  ATM_7059_SI_CH0_ADDRV); 
+    }
+    else
+    {
+        writel((u32)addrV, ATM_7059_SI_CH1_ADDRV);
+    }
+    return 0;
+}
+static int atm_7059_set_channel_addr1UV(struct owl_camera_hw_adapter* hw, int channel, void *addr1UV)
+{
+	 if(ISP_CHANNEL_0 == channel)
+    {
+        writel((u32)addr1UV,  ATM_7059_SI_CH0_ADDRU ); 
+    }
+    else
+    {
+        writel((u32)addr1UV, ATM_7059_SI_CH1_ADDRU);
+    }
+    return 0;
+}
+
+static int atm_7059_set_channel_input_fmt(struct owl_camera_hw_adapter* hw, int channel, enum v4l2_mbus_pixelcode code)
+{
+	 unsigned long value;
+	 volatile void * reg = 0;
+	 if (ISP_CHANNEL_0 == channel) {
+        reg = ATM_7059_SI_CH0_CTRL;
+    } else {
+        reg = ATM_7059_SI_CH1_CTRL;
+    }
+    value = readl(reg);
+
+    value &= ~YUV_INPUT_FORMAT_MASK;
+    value &= ~IN_FMT_MASK;
+    switch (code) {
+    case V4L2_MBUS_FMT_UYVY8_2X8:  /* UYVY */
+        // should be the same as senor's output format
+        value |= YUV_INPUT_FMT_UYVY;
+        value |= INT_FMT_YUV;
+        printk("input format UYVY, 1pix/clk\n");
+        break;
+
+    default:
+        printk("input data error (pixel code:0x%x)\n", code);
+        break;
+
+    }
+
+    writel(value, reg);
+	return 0;
+}
+
+static int atm_7059_set_channel_output_fmt(struct owl_camera_hw_adapter* hw, int channel, u32 fourcc)
+{
+	volatile void * reg = 0;
+    unsigned int  value;
+	 if (ISP_CHANNEL_0 == channel) {
+        reg = ATM_7059_SI_CH0_CTRL;
+    } else {
+        reg = ATM_7059_SI_CH1_CTRL;
+    }
+    value = readl(reg);
+
+    value &= ~(YUV_OUTPUT_FORMAT_MASK | YUV_OUTPUT_FORMAT_UV_REVERSE);
+    switch (fourcc) {
+    case V4L2_PIX_FMT_YUV420:  //420 planar
+        value |= YUV_OUTPUT_FMT_YUV420;
+        printk("output format YUV420\n");
+        break;
+
+    case V4L2_PIX_FMT_YUV422P: //422 semi planar
+        value |= YUV_OUTPUT_FMT_YUV422_SEMI;
+        printk("output format YUV422P\n");
+        break;
+
+    case V4L2_PIX_FMT_NV12:    //420 semi-planar
+        value |= YUV_OUTPUT_FMT_YUV420_SEMI;
+        printk("output format NV12.the value :%x\n",value);
+        break;
+	 case V4L2_PIX_FMT_NV21:    //420 semi-planar
+        value |= YUV_OUTPUT_FMT_YUV420_SEMI|YUV_OUTPUT_FORMAT_UV_REVERSE;
+        printk("output format NV21\n");
+        break;
+	 case V4L2_PIX_FMT_YVU420:    //420 semi-planar
+		value |= YUV_OUTPUT_FMT_YUV420;
+		printk("output V4L2_PIX_FMT_YVU420\n");
+		break;
+
+    case V4L2_PIX_FMT_YUYV:    //interleaved
+    case V4L2_PIX_FMT_UYVY:
+        value |= YUV_OUTPUT_FMT_YUV422;
+        printk("output format YUYV\n");
+        break;
+
+    default:   /* Raw RGB */
+        printk("set isp output format failed, fourcc = 0x%x", fourcc);
+        return -EINVAL;
+    }
+
+    writel(value, reg);
+    return 0;
+
+}
+
+
+static int atm_7059_set_channel_preline(struct owl_camera_hw_adapter* hw, int channel, int preline)
+{
+	  unsigned int state;
+	 if (ISP_CHANNEL_0 == channel) {
+        state = readl(ATM_7059_SI_ENABLE);
+		
+        state &= ~CH0_PRELINE_NUM_MASK;
+        state |= CH0_PRELINE_NUM(preline + ISP_PRELINE_NUM);
+        writel(state, ATM_7059_SI_ENABLE);
+    } else {
+        state = readl(ATM_7059_SI_ENABLE);
+		printk("channel:%d, state:%d\n", channel,state);
+        state &= ~CH1_PRELINE_NUM_MASK;
+        state |= CH1_PRELINE_NUM(channel + ISP_PRELINE_NUM);
+		printk("channel:%d, state:%d\n", channel,state);
+        writel(state, ATM_7059_SI_ENABLE);
+    }
+    return 0;
+}
+
+static int atm_7059_clear_channel_int_en(struct owl_camera_hw_adapter* hw, int channel)
+{
+	 unsigned int isp_enable;
+	isp_enable = readl(ATM_7059_SI_ENABLE);
+
+    if (ISP_CHANNEL_0 == channel) {
+        isp_enable &= ~(CH0_ENABLE);
+    } else {
+        isp_enable &= ~(CH1_ENABLE);
+    }
+    writel(isp_enable, ATM_7059_SI_ENABLE);
+    return 0;
+}
+
+static int atm_7059_set_channel_preline_int_en(struct owl_camera_hw_adapter* hw, int channel)
+{
+	
+    // int stat
+    unsigned long isp_int_stat;
+    isp_int_stat = readl(ATM_7059_SI_INT_STAT);
+	isp_int_stat &= ~CH0_FRAME_END_IRQ_EN;
+    if (ISP_CHANNEL_0 == channel) {
+        isp_int_stat |= CH0_PRELINE_IRQ_EN;
+    } else {
+        isp_int_stat |= CH1_PRELINE_IRQ_EN;
+    }
+    writel(isp_int_stat, ATM_7059_SI_INT_STAT);
+    return 0;
+}
+
+static int atm_7059_set_channel_frameend_int_en(struct owl_camera_hw_adapter* hw, int channel)
+{
+
+    u32 int_stat;
+    int_stat = readl(ATM_7059_SI_INT_STAT);
+    int_stat &= ~(CH0_PRELINE_IRQ_EN | CH1_PRELINE_IRQ_EN);
+	if(ISP_CHANNEL_0 == channel)
+	{
+		writel(int_stat | CH0_FRAME_END_IRQ_EN, ATM_7059_SI_INT_STAT);
+	}
+	else 
+	{
+		writel(int_stat | CH1_FRAME_END_IRQ_EN, ATM_7059_SI_INT_STAT);
+	}
+    return 0;
+    
+}
+
+static int atm_7059_clear_channel_frameend_int_en(struct owl_camera_hw_adapter* hw, int channel)
+{
+
+    u32 int_stat;
+    int_stat = readl(ATM_7059_SI_INT_STAT);
+  //  int_stat &= ~(CH0_PRELINE_IRQ_EN | CH1_PRELINE_IRQ_EN);
+	if(ISP_CHANNEL_0 == channel)
+	{
+		writel(int_stat & (~CH0_FRAME_END_IRQ_EN), ATM_7059_SI_INT_STAT);
+	}
+	else 
+	{
+		writel(int_stat & (~CH1_FRAME_END_IRQ_EN), ATM_7059_SI_INT_STAT);
+	}
+    return 0;
+    
+}
+
+
+static int atm_7059_clear_channel_preline_pending(struct owl_camera_hw_adapter* hw, int channel)
+{
+	u32 isp_int_stat;
+    isp_int_stat = readl(ATM_7059_SI_INT_STAT);
+	//isp_int_stat &= ~CH0_FRAME_END_IRQ_EN;
+   // isp_int_stat |= (0x3<<8);
+    writel(isp_int_stat, ATM_7059_SI_INT_STAT);
+    return 0;
+}
+static int atm_7059_clear_channel_preline_int_en(struct owl_camera_hw_adapter* hw)
+{
+	u32 isp_int_stat;
+	isp_int_stat = readl(ATM_7059_SI_INT_STAT);
+	isp_int_stat &= ~CH0_PRELINE_IRQ_EN;
+    writel(isp_int_stat, ATM_7059_SI_INT_STAT);
+    return 0;
+}
+
+static int atm_7059_clear_channel_frameend_pending(struct owl_camera_hw_adapter* hw,  unsigned int isp_int_stat)
+{
+	//isp_int_stat &= ~CH0_FRAME_END_IRQ_EN;
+	writel(isp_int_stat, ATM_7059_SI_INT_STAT);
+    return 0;
+}
+
+
+static int atm_7059_set_signal_polarity(struct owl_camera_hw_adapter* hw, int channel,unsigned int common_flags)
+{
+	u32 cmu_sensorclk;
+	volatile void * reg = 0;
+    unsigned long value;
+	cmu_sensorclk = readl(atm_7059_cmu_sensor_clk);
+	 if (ISP_CHANNEL_0 == channel) {
+        reg = ATM_7059_SI_CH0_CTRL;
+        if (common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING) {
+            cmu_sensorclk |= ATM_7059_CMU_SENSORCLK_INVT0;
+        } else {
+            cmu_sensorclk &= ~ATM_7059_CMU_SENSORCLK_INVT0;
+         //  cmu_sensorclk |= ATM_7059_CMU_SENSORCLK_INVT0;
+        }
+    } else {
+        reg = ATM_7059_SI_CH1_CTRL;
+        if (common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING) {
+            cmu_sensorclk |= ATM_7059_CMU_SENSORCLK_INVT0;
+        } else {
+            cmu_sensorclk &= ~ATM_7059_CMU_SENSORCLK_INVT0;
+        }
+    }
+    value = readl(reg);
+
+    if (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW) {
+        value &= ~SYNC_POL_HSYNC;
+    } else {
+        value |= SYNC_POL_HSYNC;
+    }
+    if (common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW) {
+        value &= ~SYNC_POL_VSYNC;
+    } else {
+        value |= SYNC_POL_VSYNC;
+    }
+    writel(value, reg);
+    writel(cmu_sensorclk, atm_7059_cmu_sensor_clk);
+	return 0;
+}
+
+
+static int atm_7059_set_col_range(struct owl_camera_hw_adapter* hw,int channel,unsigned int start,unsigned int end)
+{
+	int ret = 0;
+	 if (ISP_CHANNEL_0 == channel) {
+        writel(COL_START(start) | COL_END(end), ATM_7059_SI_CH0_COL_RANGE);
+    } else {
+        writel(COL_START(start) | COL_END(end),  ATM_7059_SI_CH1_COL_RANGE);
+    }
+	return ret;
+}
+
+static int atm_7059_set_row_range(struct owl_camera_hw_adapter* hw,int channel,unsigned int start,unsigned int end)
+{
+	int ret = 0;
+	 if (ISP_CHANNEL_0 == channel) {
+        writel(COL_START(start) | COL_END(end), ATM_7059_SI_CH0_ROW_RANGE);
+    } else {
+        writel(COL_START(start) | COL_END(end), ATM_7059_SI_CH1_ROW_RANGE);
+    }
+	return ret;
+}
+
+
+static int atm_7059_set_channel_int_en(struct owl_camera_hw_adapter* hw, int channel)
+{
+	
+	//channel enable
+	int ret = 0;
+	unsigned long isp_enable;
+   isp_enable = readl(ATM_7059_SI_ENABLE);
+   if (ISP_CHANNEL_0 == channel) {
+	   isp_enable |= CH0_ENABLE;
+   } else {
+	   isp_enable |= CH1_ENABLE;
+   }
+   writel(isp_enable, ATM_7059_SI_ENABLE);
+   return ret;
+}
+static void atm_7059_save_reg_array(struct owl_camera_reg *regs, int num)
+{
+	unsigned int reg_i;
+	//printk(KERN_ERR"in the atm_7059_save_reg_array \n");
+    for(reg_i = 0; reg_i < num; reg_i++)
+    {
+        regs[reg_i].val = readl(regs[reg_i].reg);
+		//printk(KERN_ERR"the reg is 0x%x,value is 0x%x  \n",*((long *)regs[reg_i].reg),regs[reg_i].val);
+    }
+}
+
+static int atm_7059_save_regs(struct owl_camera_hw_adapter* hw)
+{
+    atm_7059_save_reg_array(hw->restored_regs, hw->restored_regs_num);
+    return 0;
+}
+
+
+static void atm_7059_restore_reg_array(struct owl_camera_reg *regs, int num)
+{
+	unsigned int reg_i;
+
+    for (reg_i = 0; reg_i < num; reg_i++)
+    {
+    	//printk(KERN_ERR"the reg is 0x%x,value is 0x%x\n",*((long *)regs[reg_i].reg),regs[reg_i].val);
+        writel(regs[reg_i].val, regs[reg_i].reg);
+    }
+}
+
+int atm_7059_restore_regs(struct owl_camera_hw_adapter* hw)
+{
+	atm_7059_restore_reg_array(hw->restored_regs, hw->restored_regs_num);
+    return 0;	
+}
+
+int atm_7059_clear_all_pending(struct owl_camera_hw_adapter* hw)
+{
+	 u32 isp_int_stat;
+    isp_int_stat = readl(ATM_7059_SI_INT_STAT);
+    writel(isp_int_stat, ATM_7059_SI_INT_STAT);
+	return 0;
+}
+
+struct owl_camera_hw_ops atm7059_hw_ops = {
+	.hw_adapter_init = atm_7059_hw_adapter_init,
+    .get_channel_state = atm_7059_get_channel_state,
+    .set_channel_if = atm_7059_set_channel_if,
+    .set_channel_addrY = atm_7059_set_channel_addrY,
+    .set_channel_addrU = atm_7059_set_channel_addrU,
+    .set_channel_addrV = atm_7059_set_channel_addrV,
+    .set_channel_addr1UV = atm_7059_set_channel_addr1UV,
+    .set_channel_input_fmt = atm_7059_set_channel_input_fmt,
+    .set_channel_output_fmt = atm_7059_set_channel_output_fmt,
+    .set_channel_preline = atm_7059_set_channel_preline,
+    .clear_channel_int_en = atm_7059_clear_channel_int_en,
+    .set_channel_preline_int_en = atm_7059_set_channel_preline_int_en,
+    .clear_channel_preline_int_en = atm_7059_clear_channel_preline_int_en,
+    .set_channel_frameend_int_en = atm_7059_set_channel_frameend_int_en,
+    .clear_channel_frameend_int_en = atm_7059_clear_channel_frameend_int_en,
+    .clear_channel_preline_pending = atm_7059_clear_channel_preline_pending,
+    .clear_channel_frameend_pending = atm_7059_clear_channel_frameend_pending,
+    .set_signal_polarity = atm_7059_set_signal_polarity,
+    .clear_all_pending = atm_7059_clear_all_pending,
+    .set_col_range = atm_7059_set_col_range,
+    .set_row_range = atm_7059_set_row_range,
+    .set_channel_int_en = atm_7059_set_channel_int_en,
+    .get_channel_overflow = atm_7059_get_channel_overflow,
+    .clear_channel_overflow = atm_7059_clear_channel_overflow,
+    .save_regs = atm_7059_save_regs,
+    .restore_regs = atm_7059_restore_regs,
+};
+
+struct owl_camera_hw_adapter atm7059_hw_adapter = {
+    .hw_name = HW_NAME,
+
+    .cam_dev = NULL,
+
+    .max_channel = 1,
+    .has_isp = 0,
+    .is_3D_support = 0,
+    .crop_x_align = CROP_X_ALIGN,
+    .crop_y_align = CROP_Y_ALIGN,
+    .crop_w_align = CROP_W_ALIGN,
+    .crop_h_align = CROP_H_ALIGN,
+    .max_width = MAX_WIDTH,
+    .max_height = MAX_HEIGHT,
+	.preline_int_pd = CH0_PRELINE_PEND,
+	.frameend_int_pd = CH0_FRAME_PEND,
+	.restored_regs_num = RESTORED_REG_NUM,
+	.restored_regs = restored_regs,
+
+
+    .power_ref = 0,
+    .enable_ref = 0,
+    .hw_clk = NULL,
+
+    .ops = &atm7059_hw_ops,
+};
+
diff --git a/drivers/media/i2c/camera/owl_camera/bisp.c b/drivers/media/i2c/camera/owl_camera/bisp.c
new file mode 100755
index 0000000..05049aa
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/bisp.c
@@ -0,0 +1,1787 @@
+//#include <asm/mach-actions/actions_soc.h>//T:\mydroid_23\actsdk\psp\kernel\linux-2.6.35\arch\mips\include\asm\mach-actions
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/kernel.h>   /* printk() */
+#include <linux/errno.h>    /* error codes */
+#include <linux/vmalloc.h>
+#include <linux/init.h>     /* module_init/module_exit */
+#include <linux/dma-mapping.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <mach/hardware.h>
+#include <linux/of.h>
+#include <mach/irqs.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <asm/prom.h>
+#include "bisp.h"
+#define CLT_CH_1
+
+#define DEVDRV_NAME_BISP      "bisp"       //device_driver.h
+#define DEVICE_BISP           "/dev/bisp"  //major.h
+
+
+#define PUT_USER                        put_user
+#define GET_USER                        get_user
+//#define GET_USER_STRUCT                 copy_from_user
+//#define SET_USER_STRUCT                 copy_to_user
+
+#define  		ISP_BASE_PHY  0xb0270000
+#define     ISP_CB_TIME_OFFSET                                                       (0x00)
+#define     ISP_ENABLE_OFFSET                                                        (0x10)
+#define     ISP_CTL_OFFSET                                                           (0x20)
+#define     ISP_CHANNEL_1_STATE_OFFSET                                               (0x24)
+#define     ISP_CHANNEL_1_BA_OFFSET_OFFSET                                           (0x28)
+#define     ISP_CHANNEL_1_ROW_RANGE_OFFSET                                           (0x2C)
+#define     ISP_CHANNEL_1_COL_RANGE_OFFSET                                           (0x30)
+#define     ISP_CHANNEL_1_ADDR0_OFFSET                                               (0x34)//~0x50
+
+#define     VNC_LUT_PORT_OFFSET                                                      (0x54)
+#define     VNC_RST_OFFSET                                                           (0x58)
+#define     ISP_LSC_LUT_PORT_OFFSET                                                  (0x60)
+#define     ISP_LSC_PIX_INC_OFFSET                                                   (0x64)
+#define     ISP_LSC_SCALING_OFFSET                                                   (0x68)
+#define     ISP_LSC_CENTER0_OFFSET                                                   (0x6C)
+#define     ISP_LSC_CENTER1_OFFSET                                                   (0x70)
+#define     ISP_LSC_RST_OFFSET                                                       (0x74)
+#define     ISP_NR_CONTROL_OFFSET                                                    (0x80)
+#define     ISP_DPC_THRESHOLD_OFFSET                                                 (0x88)
+#define     ISP_CG_B_GAIN_OFFSET                                                     (0x90)
+#define     ISP_CG_G_GAIN_OFFSET                                                     (0x94)
+#define     ISP_CG_R_GAIN_OFFSET                                                     (0x98)
+#define     ISP_STAT_REGION_Y_OFFSET                                                 (0xA0)
+#define     ISP_STAT_REGION_X_OFFSET                                                 (0xA4)
+#define     ISP_STAT_HIST_Y_OFFSET                                                   (0xA8)
+#define     ISP_STAT_HIST_X_OFFSET                                                   (0xAC)
+#define     ISP_WB_THRESHOLD_OFFSET                                                  (0xB0)
+#define     ISP_CSC_OFFSET1_OFFSET                                                   (0xC0)
+#define     ISP_CSC_OFFSET2_OFFSET                                                   (0xC4)
+#define     ISP_CSC_OFFSET3_OFFSET                                                   (0xC8)
+#define     ISP_CSC_Y_R_OFFSET                                                       (0xCC)
+#define     ISP_CSC_Y_G_OFFSET                                                       (0xD0)
+#define     ISP_CSC_Y_B_OFFSET                                                       (0xD4)
+#define     ISP_CSC_CB_R_OFFSET                                                      (0xD8)
+#define     ISP_CSC_CB_G_OFFSET                                                      (0xDC)
+#define     ISP_CSC_CB_B_OFFSET                                                      (0xE0)
+#define     ISP_CSC_CR_R_OFFSET                                                      (0xE4)
+#define     ISP_CSC_CR_G_OFFSET                                                      (0xE8)
+#define     ISP_CSC_CR_B_OFFSET                                                      (0xEC)
+#define     ISP_CSC_CONTROL_OFFSET                                                  (0xF0)
+#define     ISP_GC_COEFF_0_OFFSET                                                    (0x100)//~0x13c
+
+#define     ISP_OUT_FMT_OFFSET                                                       (0x148)
+#define     ISP_OUT_ADDRY_OFFSET                                                     (0x14C)
+#define     ISP_OUT_ADDRU_OFFSET                                                     (0x150)
+#define     ISP_OUT_ADDRV_OFFSET                                                     (0x154)
+#define     ISP_OUT_ADDR1UV_OFFSET                                                   (0x158)
+#define     ISP_STAT_ADDR_OFFSET                                                     (0x160)
+#define     ISP_COLOR_REPLACE1_OFFSET                                                (0x170)//~0x1ac
+
+#define     ISP2_CTL_OFFSET                                                          (0x1EC)
+#define     ISP_CHANNEL_2_STATE_OFFSET                                               (0x1F0)
+#define     ISP_CHANNEL_2_BA_OFFSET_OFFSET                                          (0x1F4)
+#define     ISP_CHANNEL_2_ROW_RANGE_OFFSET                                           (0x1F8)
+#define     ISP_CHANNEL_2_COL_RANGE_OFFSET                                           (0x1FC)
+#define     ISP_CHANNEL_2_ADDR0_OFFSET                                               (0x200)
+//#define     ISP_CHANNEL_2_ADDR1_OFFSET                                               (0x204)//~0x21c
+
+#define     ISP2_LSC_LUT_PORT_OFFSET                                                 (0x22C)
+#define     ISP2_LSC_PIX_INC_OFFSET                                                  (0x230)
+#define     ISP2_LSC_SCALING_OFFSET                                                  (0x234)
+#define     ISP2_LSC_CENTER0_OFFSET                                                  (0x238)
+#define     ISP2_LSC_CENTER1_OFFSET                                                  (0x23C)
+#define     ISP2_LSC_RST_OFFSET                                                      (0x240)
+#define     ISP2_NR_CONTROL_OFFSET                                                   (0x24C)
+#define     ISP2_DPC_THRESHOLD_OFFSET                                                (0x254)
+#define     ISP2_CG_B_GAIN_OFFSET                                                    (0x25C)
+#define     ISP2_CG_G_GAIN_OFFSET                                                    (0x260)
+#define     ISP2_CG_R_GAIN_OFFSET                                                    (0x264)
+#define     ISP2_STAT_REGION_Y_OFFSET                                                (0x26C)
+#define     ISP2_STAT_REGION_X_OFFSET                                                (0x270)
+#define     ISP2_STAT_HIST_Y_OFFSET                                                  (0x274)
+#define     ISP2_STAT_HIST_X_OFFSET                                                  (0x278)
+#define     ISP2_WB_THRESHOLD_OFFSET                                                 (0x27C)
+#define     ISP2_CSC_OFFSET1_OFFSET                                                  (0x28C)
+#define     ISP2_CSC_OFFSET2_OFFSET                                                  (0x290)
+#define     ISP2_CSC_OFFSET3_OFFSET                                                  (0x294)
+#define     ISP2_CSC_Y_R_OFFSET                                                      (0x298)
+#define     ISP2_CSC_Y_G_OFFSET                                                      (0x29C)
+#define     ISP2_CSC_Y_B_OFFSET                                                      (0x2A0)
+#define     ISP2_CSC_CB_R_OFFSET                                                     (0x2A4)
+#define     ISP2_CSC_CB_G_OFFSET                                                     (0x2A8)
+#define     ISP2_CSC_CB_B_OFFSET                                                     (0x2AC)
+#define     ISP2_CSC_CR_R_OFFSET                                                     (0x2B0)
+#define     ISP2_CSC_CR_G_OFFSET                                                     (0x2B4)
+#define     ISP2_CSC_CR_B_OFFSET                                                     (0x2B8)
+#define     ISP2_CSC_CONTROL_OFFSET                                                  (0x2BC)
+#define     ISP2_GC_COEFF_0_OFFSET                                                   (0x2CC)//~0x308
+
+#define     ISP2_OUT_FMT_OFFSET                                                      (0x314)
+#define     ISP2_OUT_ADDRY_OFFSET                                                    (0x318)
+#define     ISP2_OUT_ADDRU_OFFSET                                                    (0x31C)
+#define     ISP2_OUT_ADDRV_OFFSET                                                    (0x320)
+#define     ISP2_OUT_ADDR1UV_OFFSET                                                  (0x324)
+#define     ISP2_STAT_ADDR_OFFSET                                                    (0x32C)
+#define     ISP2_COLOR_REPLACE1_OFFSET                                               (0x33C)//~0x398
+
+#define     ISP_FREEMODE_IMAGE_SIZE_OFFSET                                           (0x398)
+#define     ISP_FREEMODE_SET_OFFSET                                                  (0x39C)
+#define     ISP_FREEMODE_ADDRESS_OFFSET                                              (0x3A0)
+#define     AF_ENABLE_OFFSET                                                         (0x3A4)
+#define     AF_CTRL_OFFSET                                                           (0x3A8)
+#define     AF_WP0_OFFSET                                                            (0x3AC)//~0x3cc
+#define     AF_FV0_OFFSET                                                            (0x3D0)//~0x3f0
+#define     AF_TEN_THOD_OFFSET                                                       (0x3F4)
+#define     ISP_INT_STAT_OFFSET                                                      (0x400)
+
+#define     BISP_FRONT_SENSOR 0
+#define     BISP_REAR_SENSOR  1
+
+enum{
+	UNUSED,
+	FREED,
+	PREPARED,
+	ACTIVED,
+	READY,	
+	USED,
+};
+
+
+typedef struct{
+	unsigned int pHyaddr;
+	unsigned int pViraddr;
+	int					 mState;
+	short				 Pred;
+	short				 Next;
+}bisp_buffer_node_t;
+
+typedef struct{
+	int ch_id;
+	int open_count;
+	int total_node_num;
+	int ready_num;
+	int free_idx;
+	int read_idx;
+	int baf_enabled;
+	af_pv_t				af_sharpness;
+	af_param_t    af_param;
+	unsigned int  af_count;
+	unsigned int  af_status;
+	unsigned int  af_ready;
+	bisp_buffer_node_t buffer_queue[16];
+}bisp_internal_t;
+
+static unsigned int bisp_drv_opened = 0;
+
+typedef struct{
+	unsigned int id;
+	unsigned int update_awb;
+	unsigned int rgain;
+	unsigned int ggain;
+	unsigned int bgain;
+	unsigned int update_gamma;
+	unsigned int gamma_tatle[16];
+	unsigned int updata_csc;
+	unsigned int csc_table[9];
+	unsigned int on_running;
+}isp_realtime_gain_t;
+
+typedef struct{
+	unsigned int stat_addr;
+	unsigned int rgain;
+	unsigned int ggain;
+	unsigned int bgain;
+}stat_updata_t;
+
+typedef struct{
+	unsigned int bset_alogs;
+	unsigned int alogs_param;
+	unsigned int pv_num;
+	unsigned int bset_pvv;
+	unsigned int pvv[9];
+	unsigned int bset_pvs;
+	unsigned int pvs[9];
+	unsigned int noise_th;
+	unsigned int noise_set;
+}af_pv_data_t;
+
+static af_pv_data_t af_pv_data;
+static unsigned int af_enable_count = 0;
+
+typedef struct {
+    unsigned int channel;
+    const char *name;
+} bisp_sensor_info_t;
+
+typedef struct {
+    int rear;  /* 1: exist, 0: or not */
+    int front;
+    bisp_sensor_info_t sinfo[2];  /* 0: front, 1: rear */
+} bisp_dts_t;
+
+static bisp_dts_t g_bisp_dts;
+
+#define AF_ISP_REG_BASE                    0xb02703A4 //Actions_reg_gl5202.h
+#define AF_ISP_ENABLE                     (AF_ISP_REG_BASE+0x00)
+#define AF_ISP_CTRL                       (AF_ISP_REG_BASE+0x04)//
+#define AF_ISP_WP0                        (AF_ISP_REG_BASE+0x08)
+#define AF_ISP_WP1                        (AF_ISP_REG_BASE+0x0C)
+#define AF_ISP_WP2                        (AF_ISP_REG_BASE+0x10)
+#define AF_ISP_WP3                        (AF_ISP_REG_BASE+0x14)
+#define AF_ISP_WP4                        (AF_ISP_REG_BASE+0x18)
+#define AF_ISP_WP5                        (AF_ISP_REG_BASE+0x1C)
+#define AF_ISP_WP6                        (AF_ISP_REG_BASE+0x20)
+#define AF_ISP_WP7                        (AF_ISP_REG_BASE+0x24)
+#define AF_ISP_WP8                        (AF_ISP_REG_BASE+0x28)
+
+#if 1
+#define AF_ISP_FV0                        (AF_ISP_REG_BASE+0x2C)
+#define AF_ISP_FV1                        (AF_ISP_REG_BASE+0x30)
+#define AF_ISP_FV2                        (AF_ISP_REG_BASE+0x34)
+#define AF_ISP_FV3                        (AF_ISP_REG_BASE+0x38)
+#define AF_ISP_FV4                        (AF_ISP_REG_BASE+0x3C)
+#define AF_ISP_FV5                        (AF_ISP_REG_BASE+0x40)
+#define AF_ISP_FV6                        (AF_ISP_REG_BASE+0x44)
+#define AF_ISP_FV7                        (AF_ISP_REG_BASE+0x48)
+#define AF_ISP_FV8                        (AF_ISP_REG_BASE+0x4C)
+#define AF_ISP_TEN_THLD                        (AF_ISP_REG_BASE+0x50)
+#else
+
+#define AF_ISP1_REG_BASE                  0xb0270034 //Actions_reg_gl5202.h
+#define AF_ISP2_REG_BASE                  0xb0270200 //Actions_reg_gl5202.h
+#define AF_ISP1_ST                         (AF_ISP1_REG_BASE+0x00)
+#define AF_ISP1_FV0                        (AF_ISP1_REG_BASE+0x04)
+#define AF_ISP1_FV1                        (AF_ISP1_REG_BASE+0x08)
+#define AF_ISP1_FV2                        (AF_ISP1_REG_BASE+0x0c)
+#define AF_ISP1_FV3                        (AF_ISP1_REG_BASE+0x10)
+#define AF_ISP1_FV4                        (AF_ISP1_REG_BASE+0x14)
+#define AF_ISP1_FV5                        (AF_ISP1_REG_BASE+0x18)
+#define AF_ISP1_FV6                        (AF_ISP1_REG_BASE+0x1c)
+
+#define AF_ISP2_ST                         (AF_ISP2_REG_BASE+0x00)
+#define AF_ISP2_FV0                        (AF_ISP2_REG_BASE+0x04)
+#define AF_ISP2_FV1                        (AF_ISP2_REG_BASE+0x08)
+#define AF_ISP2_FV2                        (AF_ISP2_REG_BASE+0x0c)
+#define AF_ISP2_FV3                        (AF_ISP2_REG_BASE+0x10)
+#define AF_ISP2_FV4                        (AF_ISP2_REG_BASE+0x14)
+#define AF_ISP2_FV5                        (AF_ISP2_REG_BASE+0x18)
+#define AF_ISP2_FV6                        (AF_ISP2_REG_BASE+0x1c)
+
+#endif
+
+
+
+#define AF_ISP_TEN_THOD                   (AF_ISP_REG_BASE+0x50) //noise throld
+#define AF_ISP_STAT                       (AF_ISP_REG_BASE+0x5c)
+#define _CH_MX_NUM_ 64
+static isp_realtime_gain_t isp_rl_gain[_CH_MX_NUM_];
+static DEFINE_MUTEX(gisp_cmd_mutex);
+static stat_updata_t gstat_data[_CH_MX_NUM_][2];
+static bisp_internal_t *gbisp_fifo[_CH_MX_NUM_] = {0};
+
+static int finder_ch(int ch_id){
+	int i = 0;
+	int idx = -1;
+	for(i = 0; i < _CH_MX_NUM_; i++){
+		if(gbisp_fifo[i]){
+			//printk("info cnt %d,%d\n",gbisp_fifo[i]->open_count,gbisp_fifo[i]->ch_id);
+			if(gbisp_fifo[i]->ch_id == (ch_id+1)){
+				idx = i;
+				return idx;
+			}
+		}
+	}
+	return idx;
+}
+
+static void init_node(bisp_internal_t *bisp_fifo,bisp_stat_buffers_info_t *buffers_node){
+	int i;
+	//memset(bisp_fifo,0,sizeof(bisp_internal_t));
+	bisp_fifo->total_node_num = 0;
+	bisp_fifo->ready_num = 0;
+	bisp_fifo->free_idx = 0;
+	bisp_fifo->read_idx = 0;
+	memset(bisp_fifo->buffer_queue,0,sizeof(bisp_buffer_node_t)*16);
+	
+	printk("init_node %d\n",buffers_node->buffer_num);
+	for(i = 0; i < buffers_node->buffer_num; i++){
+		bisp_fifo->buffer_queue[i].pHyaddr = buffers_node->pHyaddr[i];
+		bisp_fifo->buffer_queue[i].pViraddr = buffers_node->pViaddr[i];
+		printk("init_node adr %x\n",bisp_fifo->buffer_queue[i].pHyaddr);
+		bisp_fifo->buffer_queue[i].mState = FREED;
+		if(i == 0){
+			bisp_fifo->buffer_queue[i].Pred  = buffers_node->buffer_num-1;
+			bisp_fifo->buffer_queue[i].Next  = i+1;
+		}
+		else if(i == buffers_node->buffer_num-1){
+			bisp_fifo->buffer_queue[i].Pred  = i-1;
+			bisp_fifo->buffer_queue[i].Next  = 0;
+		}
+		else {
+			bisp_fifo->buffer_queue[i].Pred  = i-1;
+			bisp_fifo->buffer_queue[i].Next  = i+1;
+		}			
+	}
+	bisp_fifo->free_idx = 0;
+	bisp_fifo->read_idx = -1;
+	bisp_fifo->total_node_num = buffers_node->buffer_num;
+}
+
+static void change_buffer_state(bisp_internal_t *bisp_fifo,unsigned int *pPhyAddr){
+	int i,k;
+	int fidx;
+	int has_idx = -1;
+	bisp_buffer_node_t *buff_node_tmp = NULL;	
+	if(bisp_fifo->total_node_num == 0) return;
+		
+	for(i = 0; i < bisp_fifo->total_node_num; i++){
+		buff_node_tmp = &bisp_fifo->buffer_queue[i];
+		if(buff_node_tmp->mState == PREPARED){
+			buff_node_tmp->mState = ACTIVED;
+		}
+		else if(buff_node_tmp->mState == ACTIVED){			
+			buff_node_tmp->mState = READY;
+			if(bisp_fifo->read_idx < 0){
+				bisp_fifo->read_idx = i;
+				bisp_fifo->ready_num = 1;
+			}
+			else {
+				if(bisp_fifo->buffer_queue[bisp_fifo->read_idx].mState == READY){
+					bisp_fifo->buffer_queue[bisp_fifo->read_idx].mState = FREED;
+					bisp_fifo->read_idx = i;
+					bisp_fifo->ready_num = 1;
+				}else if(bisp_fifo->buffer_queue[bisp_fifo->read_idx].mState == USED){
+					bisp_fifo->read_idx = i;
+					bisp_fifo->ready_num = 1;
+				}else if(bisp_fifo->buffer_queue[bisp_fifo->read_idx].mState == FREED){
+					bisp_fifo->read_idx = i;
+					bisp_fifo->ready_num = 1;
+				}
+			}
+		}
+	}
+	*pPhyAddr = (unsigned int)NULL;		
+	buff_node_tmp = (bisp_buffer_node_t*)&bisp_fifo->buffer_queue[bisp_fifo->free_idx];
+	if(buff_node_tmp->mState == FREED){
+		buff_node_tmp->mState = PREPARED;
+		*pPhyAddr = buff_node_tmp->pHyaddr;
+	}	
+	else{
+		printk("free_idx err %d,%d\n",bisp_fifo->free_idx,buff_node_tmp->mState);
+		k = bisp_fifo->free_idx+1;
+		fidx = bisp_fifo->free_idx;
+		do{
+			if(k >= bisp_fifo->total_node_num) k = 0;
+			buff_node_tmp = &bisp_fifo->buffer_queue[k];
+			if(buff_node_tmp->mState == FREED){
+				bisp_fifo->free_idx = k;
+				has_idx = 1;
+				break;
+			}
+			k++;
+			//printk("fidx %d\n",k);
+		}while(k != fidx);
+		if(has_idx == 1){
+			buff_node_tmp->mState = PREPARED;
+			*pPhyAddr = buff_node_tmp->pHyaddr;
+		}else{
+			printk("free_idx err2 %d,%d\n",bisp_fifo->free_idx,buff_node_tmp->mState);
+		}
+	}
+	k = bisp_fifo->free_idx+1;
+	fidx = bisp_fifo->free_idx;
+	do{
+		if(k >= bisp_fifo->total_node_num) k = 0;
+		buff_node_tmp = &bisp_fifo->buffer_queue[k];
+		if(buff_node_tmp->mState == FREED){
+			bisp_fifo->free_idx = k;
+			break;
+		}
+		k++;
+		//printk("fidx %d\n",k);
+	}while(k != fidx);
+	
+}
+
+static bisp_buffer_node_t* get_buffer_node(bisp_internal_t *bisp_fifo){
+	int idx = bisp_fifo->read_idx;
+	if(bisp_fifo->read_idx == -1) return NULL;
+	if(idx != bisp_fifo->read_idx) return NULL;
+	if(bisp_fifo->buffer_queue[idx].mState == READY){
+		bisp_fifo->buffer_queue[idx].mState = USED;
+		//printk("fidx %d,%x\n",idx,bisp_fifo->buffer_queue[idx].pHyaddr);
+		return &bisp_fifo->buffer_queue[idx];
+	}else {
+		return NULL;
+	}
+}
+
+static void set_buffer_node(bisp_internal_t *bisp_fifo,int pHyaddr){
+	int i;
+	bisp_buffer_node_t *buff_node_tmp = NULL;		
+	int bufidx = -1;
+	//mutex_lock(&gisp_cmd_mutex);
+	for(i = 0; i < bisp_fifo->total_node_num;i++){
+		buff_node_tmp = &bisp_fifo->buffer_queue[i];
+		if(pHyaddr == buff_node_tmp->pHyaddr){
+			bufidx = i;
+			i = bisp_fifo->total_node_num + 1;
+		}
+	}
+	
+	if(bufidx == -1){
+		printk("set_buffer_node %d,%x,%x\n",bufidx,pHyaddr,bisp_fifo->total_node_num);
+//		mutex_unlock(&gisp_cmd_mutex);
+		 return;
+		}
+		
+	if(bisp_fifo->buffer_queue[bufidx].mState == USED){
+		bisp_fifo->buffer_queue[bufidx].mState = FREED;
+	}
+//	mutex_unlock(&gisp_cmd_mutex);
+}
+
+static unsigned int reg_read(unsigned int reg)
+{
+	unsigned int value = act_readl(reg);
+	//printk(KERN_ERR"Read Reg:%x ,value:%x...\n",reg,value);
+	return value;
+}
+
+static void reg_write(unsigned int reg,unsigned int value)
+{
+	//printk(KERN_ERR"Wr Reg:%x ,value:%x ...%x\n",reg,value,act_readl(0xb0210010));
+	act_writel(value,reg);
+	//printk(KERN_ERR"redo Read reg:%x,%x,%x...\n",reg,value,act_readl(reg));
+}
+
+
+static void ov5647_af_clk_enable(void)
+{    
+	printk(KERN_ERR"ov5647_af_clk_enable\n");
+	//if (owl_powergate_is_powered(OWL_POWERGATE_VCE_BISP)){
+  	act_writel(0x1,AF_ISP_ENABLE);
+	//}
+}
+
+static void ov5647_af_clk_disable(void)
+{    
+	printk(KERN_ERR"ov5647_af_clk_disable\n");
+  act_writel(0x0,AF_ISP_ENABLE);
+}
+
+/*
+AF irq enable/disable
+*/
+static inline void ov5647_af_irq_enable(void)
+{
+	int af_status = reg_read(AF_ISP_STAT);
+	af_status = af_status&0x000000ff;
+	af_status = af_status|(1<<4)|(1<<12);	
+	act_writel(af_status,AF_ISP_STAT);
+}
+    
+static inline void ov5647_af_irq_disable(void)
+{
+  int af_status = reg_read(AF_ISP_STAT);
+  if(af_status&(1<<12))
+  {
+  	af_status &= 0xff;
+		af_status |= (1<<12);
+		act_writel(af_status,AF_ISP_STAT);
+	}
+	else
+	{
+		printk("af irq err %x\n",af_status);
+	}
+}
+
+/*
+AF info read
+*/
+static int ov5647_af_fv_read(af_pv_t *af_wv,int win_num)
+{
+	int i;
+	int ret = 0;
+	if(af_pv_data.bset_pvv == 2){
+		af_pv_data.bset_pvv = 1;
+		for(i = 0; i < win_num+1;i ++){
+			af_wv->pv[i] = af_pv_data.pvv[i];
+		}
+		af_pv_data.bset_pvv = 0;
+		af_wv->bPrepared = 0;		
+	}else {
+		af_wv->bPrepared = -1;
+	}
+	
+	printk("working status 0x%x,0x%x,0x%x\n",af_wv->pv[0],af_wv->pv[1],af_wv->pv[2]);
+	return ret;
+}
+
+int af_updata(int s){
+	int i = 0;
+	if(af_pv_data.bset_alogs){
+		act_writel(af_pv_data.alogs_param,AF_ISP_CTRL);
+		af_pv_data.bset_alogs = 0;
+	}
+	if(af_pv_data.bset_pvs){
+		for(i = 0; i < af_pv_data.pv_num; i++)
+		{
+			act_writel(af_pv_data.pvs[i],AF_ISP_WP0+i*4);
+		}
+		af_pv_data.bset_pvs = 0;
+	}
+	if(af_pv_data.noise_set == 1){
+			act_writel(af_pv_data.noise_th,AF_ISP_TEN_THLD);
+			af_pv_data.noise_set = 0;
+		}
+	if(af_pv_data.bset_pvv != 1){
+		af_pv_data.bset_pvv = 3;
+		for(i = 0; i < af_pv_data.pv_num; i++){
+				af_pv_data.pvv[i] = reg_read(AF_ISP_FV0+i*4);
+			}
+			//printk("PV0 %x\n",af_pv_data.pvv[0]);
+			af_pv_data.bset_pvv = 2;
+	}	
+	return 0;
+}
+EXPORT_SYMBOL(af_updata);
+
+static void ov5647_af_param_set(bisp_internal_t *info,af_param_t *af_param)
+{
+	int maf_enable = 0;
+	unsigned int preline = af_param->win_h/2 + 34;
+	int i;
+	//maf_enable = af_param->win_num | (af_param->win_size << 4)|(0 << 8)|(0 << 10)|(0 << 13)|(af_param->af_mode << 27) | (af_param->af_inc << 28)|(af_param->af_al << 30) | (preline << 16);
+
+	maf_enable = af_param->win_num | (af_param->win_size << 4)|(af_param->tshift << 8)|(af_param->thold << 10)|(af_param->rshift << 13)|\
+								(af_param->af_mode << 27) | (af_param->af_inc << 28)|(af_param->af_al << 30) | (preline << 16);
+	af_pv_data.pv_num = af_param->win_num + 1;
+	
+	
+	if(af_enable_count == 0){
+		act_writel(maf_enable,AF_ISP_CTRL);
+		act_writel(af_param->af_pos[0],AF_ISP_WP0);
+		act_writel(af_param->af_pos[1],AF_ISP_WP1);
+		act_writel(af_param->af_pos[2],AF_ISP_WP2);
+		act_writel(af_param->af_pos[3],AF_ISP_WP3);
+		act_writel(af_param->af_pos[4],AF_ISP_WP4);
+		act_writel(af_param->af_pos[5],AF_ISP_WP5);
+		act_writel(af_param->af_pos[6],AF_ISP_WP6);
+		act_writel(af_param->af_pos[7],AF_ISP_WP7);
+		act_writel(af_param->af_pos[8],AF_ISP_WP8);
+		act_writel(af_param->noise_th,AF_ISP_TEN_THLD);
+	}
+	else {
+		if(af_pv_data.alogs_param != maf_enable){
+			af_pv_data.alogs_param = maf_enable;
+			af_pv_data.bset_alogs = 1;				
+		}
+		if(af_param->noise_th != af_pv_data.noise_th){
+			af_pv_data.noise_th = af_param->noise_th;
+			af_pv_data.noise_set = 1;
+		}
+		for(i = 0; i < af_param->win_num; i++){
+			af_pv_data.pvs[i] = af_param->af_pos[i];
+		}
+		af_pv_data.bset_pvs = 1;
+	}	
+	
+	//ov5647_af_Wr_Reg(af_param->win_num+1,AF_ISP2_ST);
+}
+#if 0
+static void ov5647_af_param_get(af_param_t *af_param){
+		unsigned int maf_enable = reg_read(AF_ISP_CTRL);		
+		
+		af_param->win_num = maf_enable&0xf;
+		af_param->win_size = (maf_enable>>4)&0x7;
+		af_param->tshift = (maf_enable>>8)&0x3;
+		af_param->thold = (maf_enable>>10)&0x7;
+		af_param->rshift = (maf_enable>>13)&0x7;
+		af_param->af_mode = (maf_enable>>27)&0x1;
+		af_param->af_inc = (maf_enable>>28)&0x3;
+		af_param->af_al = (maf_enable>>30)&0x1;
+		
+		af_param->af_pos[0] =  reg_read(AF_ISP_WP0);
+		af_param->af_pos[1] =  reg_read(AF_ISP_WP1);
+		af_param->af_pos[2] =  reg_read(AF_ISP_WP2);
+		af_param->af_pos[3] =  reg_read(AF_ISP_WP3);
+		af_param->af_pos[4] =  reg_read(AF_ISP_WP4);
+		af_param->af_pos[5] =  reg_read(AF_ISP_WP5);
+		af_param->af_pos[6] =  reg_read(AF_ISP_WP6);
+		af_param->af_pos[7] =  reg_read(AF_ISP_WP7);
+		af_param->af_pos[8] =  reg_read(AF_ISP_WP8);
+		af_param->noise_th =  reg_read(AF_ISP_TEN_THLD);
+}
+
+static int ov5647_af_status_query(void)
+{
+   int af_status = reg_read(AF_ISP_ENABLE);
+	 return af_status;
+}
+#endif
+
+static int set_info(bisp_info_t *isp_info)
+{
+	//int ctl_id = isp_info->chid;
+	unsigned int reg_val = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+	
+	reg_val = reg_val&(~(3<<11));
+	reg_val = reg_val | (isp_info->stat_en << 11);// | (isp_info->eis_en << 12);
+	printk(KERN_ERR"stat %x,%x\n",(unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset,reg_val);
+	reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset, reg_val);
+	
+	return 0;
+}
+static int set_blc(blc_info_t *blc_info){
+	unsigned int reg_val = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CHANNEL_1_BA_OFFSET_OFFSET + reg_offset);
+	/*
+	typedef struct{
+	int r_off;
+	int g1_off;
+	int g2_off;
+	int b_off;
+	}blc_info_t;
+	*/
+	reg_val = ((blc_info->r_off&0xff) << 24)|((blc_info->g1_off&0xff) << 16)|((blc_info->g2_off&0xff) << 8)|((blc_info->b_off&0xff) << 0);// | (isp_info->eis_en << 12);
+	printk(KERN_ERR"set_blc %x,%x,%x,%x\n",blc_info->r_off,blc_info->b_off,(unsigned int)ISP_BASE_PHY + ISP_CHANNEL_1_BA_OFFSET_OFFSET + reg_offset,reg_val);
+	reg_write((unsigned int)ISP_BASE_PHY + ISP_CHANNEL_1_BA_OFFSET_OFFSET + reg_offset, reg_val);
+	
+	return 0;
+}
+
+static int set_hvb(bisp_bank_t *isp_bank)
+{
+	unsigned int reg_val = 0;
+	reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CB_TIME_OFFSET);
+	
+	reg_val = reg_val&(0xffff0000);
+	reg_val = reg_val | (isp_bank->hbank << 0) | (isp_bank->vbank << 8);
+	
+	reg_write((unsigned int)ISP_BASE_PHY + ISP_CB_TIME_OFFSET,reg_val);
+	
+	return 0;
+}
+
+static int set_cop(bisp_region_t *isp_bar)
+{
+	//int ctl_id = isp_bar->chid;
+	unsigned int reg_val0 = 0,reg_val1 = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_CHANNEL_1_ROW_RANGE_OFFSET + reg_offset;
+	unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_CHANNEL_1_COL_RANGE_OFFSET + reg_offset;
+	
+	reg_val0 = reg_read(reg_addr_0);
+	reg_val1 = reg_read(reg_addr_1);
+	
+	reg_val0 = (isp_bar->ey<<16) + (isp_bar->sy<<0);
+	reg_val1 = (isp_bar->ex<<16) + (isp_bar->sx<<0);
+	
+	reg_write(reg_addr_0,reg_val0);
+	reg_write(reg_addr_1,reg_val1);
+	return 0;
+}
+
+static int get_cop(bisp_region_t *isp_bar)
+{
+	//int ctl_id = isp_bar->chid;
+	unsigned int reg_val0 = 0,reg_val1 = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_CHANNEL_1_ROW_RANGE_OFFSET + reg_offset;
+	unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_CHANNEL_1_COL_RANGE_OFFSET + reg_offset;
+	
+	reg_val0 = reg_read(reg_addr_0);
+	reg_val1 = reg_read(reg_addr_1);
+	isp_bar->ey = reg_val0>>16;
+	isp_bar->sy = reg_val0&0xffff;
+	isp_bar->ex = reg_val1>>16;
+	isp_bar->sx = reg_val1&0xffff;
+	return 0;
+}
+#define STAT_ISP2_L1   (0xB0210218)
+#define STAT_ISP2_L2   (0xB021021c)
+
+static int get_sds(bisp_internal_t *bisp_fifo,bisp_ads_t *clt_param)
+{
+	#if 0
+	int ctl_id = clt_param->chid;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_STAT_ADDR_OFFSET + reg_offset;
+	clt_param->ads = reg_read(reg_addr_0);	
+	clt_param->ready_addr = reg_read(STAT_ISP2_L2);
+	clt_param->last_addr = reg_read(STAT_ISP2_L1);
+	reg_write(STAT_ISP2_L1,0);
+	
+	#endif	
+	
+	return 0;
+}
+
+static int get_yds(bisp_ads_t *clt_param)
+{
+	//int ctl_id = clt_param->chid;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_OUT_ADDRY_OFFSET + reg_offset;
+	clt_param->ads = reg_read(reg_addr_0);
+	return 0;
+}
+
+static int set_vnc(bisp_vnc_t *vnc_info)
+{
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + VNC_LUT_PORT_OFFSET;
+	int i,j;
+	unsigned int reg_val = 0;
+	
+	if(vnc_info->b_en){
+		reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET);	
+		//reg_val = reg_val & (~(1<<15));
+		//reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET,reg_val);
+		if(((reg_val >> 15)&0x1) == 0){
+			reg_write((unsigned int)ISP_BASE_PHY+VNC_RST_OFFSET,1);//reset
+			for(i = 0; i < 3; i++)
+			{
+				for(j =0; j< vnc_info->vnc_num; j++){
+					reg_write((unsigned int)reg_addr_0,vnc_info->color_info[i][j]);//reset
+					//printk(KERN_ERR"set_vnc val %x,%x\n",reg_addr_0,vnc_info->color_info[i][j]);
+				}
+				if(vnc_info->vnc_num < 128){
+					for(j =0; j< 128 - vnc_info->vnc_num; j++)
+						reg_write((unsigned int)reg_addr_0,0);//reset
+				}
+			}
+			
+			reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET);	
+			reg_val = reg_val | ((1<<15));
+			printk(KERN_ERR"set_vnc %x,%x\n",reg_val,vnc_info->vnc_num);
+			reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET,reg_val);
+		}
+		
+	}else {
+		reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET);
+		reg_val = reg_val & (~(1<<15));
+		reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET,reg_val);
+	}
+	
+	return 0;
+}
+
+static int set_lsc(bisp_lsc_t *lut_data)
+{
+	//int ctl_id = lut_data->chid;
+	unsigned int reg_val = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_LSC_PIX_INC_OFFSET + reg_offset;
+	unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_LSC_SCALING_OFFSET + reg_offset;
+	unsigned int reg_addr_2 = (unsigned int)ISP_BASE_PHY + ISP_LSC_CENTER0_OFFSET + reg_offset;
+	unsigned int reg_addr_3 = (unsigned int)ISP_BASE_PHY + ISP_LSC_CENTER1_OFFSET + reg_offset;
+	unsigned int reg_addr_4 = (unsigned int)ISP_BASE_PHY + ISP_LSC_RST_OFFSET + reg_offset;
+	unsigned int reg_addr_5 = (unsigned int)ISP_BASE_PHY + ISP_LSC_LUT_PORT_OFFSET + reg_offset;
+	int i;
+	  
+	if(lut_data->lsc_en){
+		reg_write(reg_addr_0,(lut_data->hinc&0xf) + ((lut_data->vinc&0xf) << 4));
+		reg_write(reg_addr_1,lut_data->scaleidx);
+		reg_write(reg_addr_2,lut_data->xcenter + (lut_data->ycenter << 16));
+		reg_write(reg_addr_3,lut_data->xcenter_1);
+		reg_write(reg_addr_4,1);//reset
+		printk(KERN_ERR"lsc %d,%d\n",lut_data->hinc,lut_data->vinc);
+		for(i = 0; i < 64; i++){
+			//printk(KERN_ERR"lsc %x,%x\n",lut_data->lsc_coeff[i],reg_read(0xB0210010));
+			reg_write(reg_addr_5,lut_data->lsc_coeff[i]);
+		}
+		reg_write(reg_addr_4,0);//reset
+		reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+		reg_val = reg_val & (~(1<<7));
+		reg_val = reg_val | (1 << 7) ;
+		reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset,reg_val);
+	}
+	else
+	{
+		reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+		reg_val = reg_val & (~(1<<7));
+		reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset,reg_val);
+	}
+
+	return 0;
+}
+
+static int set_nr(bisp_nr_t *isp_nr)
+{
+	//int ctl_id = isp_nr->chid;
+	unsigned int reg_val = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_NR_CONTROL_OFFSET + reg_offset;
+		
+	reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+	reg_val = reg_val & (~(1<<8));
+	reg_val = reg_val | (isp_nr->nr_en << 8);
+	reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset,reg_val);
+
+	reg_write(reg_addr_0,isp_nr->nr_level);
+	
+	return 0;
+}
+
+static int set_ee(bisp_nr_t *clt_param)
+{
+	//int ctl_id = clt_param->chid;
+	unsigned int reg_val = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+	reg_val = reg_val & (~(1<<9));
+	reg_val = reg_val | ((clt_param->ee_en&0x1) << 9);// | (isp_nr->dpc_en << 10);
+	reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset,reg_val);
+
+	return 0;
+}
+
+static int set_dpc(bisp_nr_t *isp_nr)
+{
+	//int ctl_id = isp_nr->chid;
+	unsigned int reg_val = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_DPC_THRESHOLD_OFFSET + reg_offset;
+	
+	reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+	reg_val = reg_val & (~(4<<8));
+	reg_val = reg_val |  (isp_nr->dpc_en << 10);//(isp_nr->nr_en << 8) |
+	reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset,reg_val);
+	reg_write(reg_addr_1,isp_nr->dpc_level);
+	
+	return 0;
+}
+
+static int set_srg(bisp_region_t *isp_bar)
+{
+	//int ctl_id = isp_bar->chid;
+	unsigned int reg_val0 = 0,reg_val1 = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_STAT_REGION_Y_OFFSET + reg_offset;
+	unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_STAT_REGION_X_OFFSET + reg_offset;
+	
+	
+	reg_val0 = (isp_bar->ey<<16) + (isp_bar->sy<<0);
+	reg_val1 = (isp_bar->ex<<16) + (isp_bar->sx<<0);
+	
+	reg_write(reg_addr_0,reg_val0);
+	reg_write(reg_addr_1,reg_val1);
+	
+	return 0;
+}
+
+static int set_hrg(bisp_region_t *isp_bar)
+{
+	//int ctl_id = isp_bar->chid;
+	unsigned int reg_val0 = 0,reg_val1 = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_STAT_HIST_Y_OFFSET + reg_offset;
+	unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_STAT_HIST_X_OFFSET + reg_offset;
+	
+	reg_val0 = (isp_bar->ey<<16) + (isp_bar->sy<<0);
+	reg_val1 = (isp_bar->ex<<16) + (isp_bar->sx<<0);
+	
+	reg_write(reg_addr_0, reg_val0);
+	reg_write(reg_addr_1,reg_val1);
+	
+	return 0;
+}
+
+static int set_wbp(bisp_wp_t *isp_bar)
+{
+	//int ctl_id = isp_bar->chid;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_WB_THRESHOLD_OFFSET + reg_offset;
+	
+	reg_write(reg_addr_0,(isp_bar->wb_thr<<24) + (isp_bar->wb_thg<<16) +(isp_bar->wb_thb<<8) +(isp_bar->wb_cnt<<0));
+	return 0;
+}
+
+static int set_csc(bisp_csc_t *lut_data)
+{
+	//int ctl_id = lut_data->chid;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_CSC_OFFSET1_OFFSET + reg_offset;	
+	
+	reg_write(reg_addr_0,lut_data->offset1);
+	reg_write(reg_addr_0 + 4, lut_data->offset2);
+	reg_write(reg_addr_0 + 8, lut_data->offset3);
+	reg_write(reg_addr_0 + 12, lut_data->y_r);
+	reg_write(reg_addr_0 + 16, lut_data->y_g);
+	reg_write(reg_addr_0 + 20, lut_data->y_b);
+	reg_write(reg_addr_0 + 24, lut_data->cb_r);
+	reg_write(reg_addr_0 + 28, lut_data->cb_g);
+	reg_write(reg_addr_0 + 32, lut_data->cb_b);
+	reg_write(reg_addr_0 + 36, lut_data->cr_r);
+	reg_write(reg_addr_0 + 40, lut_data->cr_g);
+	reg_write(reg_addr_0 + 44, lut_data->cr_b);
+	return 0;
+}
+
+static int set_gc(bisp_gc_t *lut_data)
+{
+	//int ctl_id = lut_data->chid;
+	unsigned int reg_val = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_GC_COEFF_0_OFFSET + reg_offset;
+	int i;
+	
+	if(lut_data->gc_en){		
+		for(i = 0; i < 16; i++){
+			reg_write(reg_addr_0 + i * 4, lut_data->gc_coeff[i]);
+		}
+		
+		reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+		reg_val = reg_val & (~(1<<13));
+		reg_val = reg_val | (1 << 13) ;
+		reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset, reg_val);
+	}
+	else
+	{
+		reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+		reg_val = reg_val & (~(1<<13));
+		reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset, reg_val);
+	}
+
+	return 0;
+}
+
+static int set_cfx(bisp_color_t *cr_data)
+{
+	//int ctl_id = cr_data->chid;
+	unsigned int reg_val = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_CSC_CONTROL_OFFSET + reg_offset;
+	
+	//int i;
+	reg_val = reg_read(reg_addr_0);
+
+	if(cr_data->cr < 0)		reg_val = reg_val & (~(1<<2));
+	else
+	{
+		reg_val = reg_val & 0x00ffffff;
+		reg_val = reg_val | ((1<<2));
+		reg_val = reg_val | (cr_data->cr << 24);
+	}
+	if(cr_data->cb < 0)		reg_val = reg_val & (~(1<<1));
+	else
+	{
+		reg_val = reg_val & 0xff00ffff;
+		reg_val = reg_val | ((1<<1));
+		reg_val = reg_val | (cr_data->cb << 16);
+	}
+
+	if(cr_data->yinc <= 0) reg_val = reg_val & (~(1<<0));
+	else reg_val = reg_val | (1<<0);
+
+	reg_write(reg_addr_0, reg_val);
+	
+	return 0;
+}
+
+static int set_crp(bisp_color_adjust_t *lut_data)
+{
+	//int ctl_id = lut_data->chid;
+	unsigned int reg_val = 0;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_COLOR_REPLACE1_OFFSET + reg_offset;
+	int i;
+	
+	if(lut_data->b_en){		
+		for(i = 0; i < 16; i++){
+			reg_write(reg_addr_0 + i * 4, lut_data->color_info[i]);
+		}
+		
+		reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+		reg_val = reg_val & (~(1<<14));
+		reg_val = reg_val | (1 << 14) ;
+		reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset,reg_val);
+	}
+	else
+	{
+		reg_val = reg_read((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset);
+		reg_val = reg_val & (~(1<<14));
+		reg_write((unsigned int)ISP_BASE_PHY + ISP_CTL_OFFSET + reg_offset, reg_val);
+	}
+
+	return 0;
+}
+#if 0
+static int set_gn(bisp_bg_t *lut_data)
+{
+	int ctl_id = lut_data->chid;
+#ifdef CLT_CH_1
+	unsigned int reg_offset = 0;
+#else
+	unsigned int reg_offset = (ctl_id==2)?0x1cc:0;
+#endif
+	unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_CG_B_GAIN_OFFSET + reg_offset;
+	unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_CG_G_GAIN_OFFSET + reg_offset;
+	unsigned int reg_addr_2 = (unsigned int)ISP_BASE_PHY + ISP_CG_R_GAIN_OFFSET + reg_offset;	
+	
+	reg_write(reg_addr_0,lut_data->bgain);
+	reg_write(reg_addr_1, lut_data->ggain);
+	reg_write(reg_addr_2, lut_data->rgain);
+	return 0;
+}
+#endif
+
+void bisp_updata(unsigned int *pHyaddr,int isp_ch){
+	unsigned int pyaddr = 0;
+	int ch_id = finder_ch(1);
+	//printk("ch id %d,%d\n",ch_id,isp_ch);
+	if(ch_id == -1) return;
+	
+	//mutex_lock(&gisp_cmd_mutex);
+	isp_rl_gain[ch_id].on_running = 1;
+	change_buffer_state(gbisp_fifo[ch_id],&pyaddr);	
+	gstat_data[ch_id][0].stat_addr = gstat_data[ch_id][1].stat_addr;
+	gstat_data[ch_id][0].rgain = gstat_data[ch_id][1].rgain;
+	gstat_data[ch_id][0].ggain = gstat_data[ch_id][1].ggain;
+	gstat_data[ch_id][0].bgain = gstat_data[ch_id][1].bgain;
+	if(isp_ch == 1){
+		gstat_data[ch_id][1].stat_addr = reg_read(0xb027032c);
+		gstat_data[ch_id][1].rgain = reg_read(0xb0270264);
+		gstat_data[ch_id][1].ggain = reg_read(0xb0270260);
+		gstat_data[ch_id][1].bgain = reg_read(0xb027025c);
+		if(pyaddr)
+			reg_write(0xb027032c,pyaddr);		
+	
+		if(isp_rl_gain[ch_id].update_awb){
+			unsigned int reg_offset = 0x1cc;
+			unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_CG_B_GAIN_OFFSET + reg_offset;
+			unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_CG_G_GAIN_OFFSET + reg_offset;
+			unsigned int reg_addr_2 = (unsigned int)ISP_BASE_PHY + ISP_CG_R_GAIN_OFFSET + reg_offset;		
+			reg_write(reg_addr_0,isp_rl_gain[ch_id].bgain);
+			reg_write(reg_addr_1, isp_rl_gain[ch_id].ggain);
+			reg_write(reg_addr_2, isp_rl_gain[ch_id].rgain);
+			isp_rl_gain[ch_id].update_awb = 0;
+		}		
+	}else if(isp_ch == 0){
+		gstat_data[ch_id][1].stat_addr = reg_read(0xb0270160);
+		gstat_data[ch_id][1].rgain = reg_read(0xb0270098);
+		gstat_data[ch_id][1].ggain = reg_read(0xb0270094);
+		gstat_data[ch_id][1].bgain = reg_read(0xb0270090);
+		if(pyaddr)
+			reg_write(0xb0270160,pyaddr);
+		
+	
+		if(isp_rl_gain[ch_id].update_awb){
+			unsigned int reg_offset = 0;
+			unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_CG_B_GAIN_OFFSET + reg_offset;
+			unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_CG_G_GAIN_OFFSET + reg_offset;
+			unsigned int reg_addr_2 = (unsigned int)ISP_BASE_PHY + ISP_CG_R_GAIN_OFFSET + reg_offset;		
+			reg_write(reg_addr_0,isp_rl_gain[ch_id].bgain);
+			reg_write(reg_addr_1, isp_rl_gain[ch_id].ggain);
+			reg_write(reg_addr_2, isp_rl_gain[ch_id].rgain);
+			isp_rl_gain[ch_id].update_awb = 0;
+		}
+	}
+	isp_rl_gain[ch_id].on_running = 0;
+	//printk("set pyaddr %x \n",pyaddr);
+	//mutex_unlock(&gisp_cmd_mutex);
+}
+
+void isp_set_gain(bisp_bg_t *lut_data,int ch_id){
+	int i = 1000;
+//	mutex_lock(&gisp_cmd_mutex);
+	while(isp_rl_gain[ch_id].update_awb == 1 && isp_rl_gain[ch_id].on_running == 1 && i-- > 0){
+		mdelay(1);
+	}
+	if(isp_rl_gain[ch_id].on_running == 0){
+		isp_rl_gain[ch_id].bgain = lut_data->bgain;
+		isp_rl_gain[ch_id].ggain = lut_data->ggain;
+		isp_rl_gain[ch_id].rgain = lut_data->rgain;
+		isp_rl_gain[ch_id].update_awb = 1;
+	}
+	
+	if(1){
+		unsigned int isp_en = reg_read(ISP_BASE_PHY + ISP_ENABLE_OFFSET);
+		if((isp_en&0x1) == 0){
+			unsigned int reg_offset = 0;
+			unsigned int reg_addr_0 = (unsigned int)ISP_BASE_PHY + ISP_CG_B_GAIN_OFFSET;
+			unsigned int reg_addr_1 = (unsigned int)ISP_BASE_PHY + ISP_CG_G_GAIN_OFFSET;
+			unsigned int reg_addr_2 = (unsigned int)ISP_BASE_PHY + ISP_CG_R_GAIN_OFFSET;		
+			reg_write(reg_addr_0,isp_rl_gain[ch_id].bgain);
+			reg_write(reg_addr_1, isp_rl_gain[ch_id].ggain);
+			reg_write(reg_addr_2, isp_rl_gain[ch_id].rgain);
+			isp_rl_gain[ch_id].update_awb = 0;
+		}		
+	}
+//	mutex_unlock(&gisp_cmd_mutex);
+}
+
+void isp_get_gain(bisp_internal_t *bisp_fifo,bisp_bg_t *lut_data){
+	int ch_id = 0;
+//	mutex_lock(&gisp_cmd_mutex);
+	bisp_buffer_node_t *buffer_node_tmp = NULL;
+	ch_id = bisp_fifo->open_count;
+
+	//lut_data->stat_addr = gstat_data[0].stat_addr;
+	lut_data->bgain = gstat_data[ch_id][0].bgain;
+	lut_data->ggain = gstat_data[ch_id][0].ggain;
+	lut_data->rgain = gstat_data[ch_id][0].rgain;	
+	
+	buffer_node_tmp = get_buffer_node(bisp_fifo);
+	if(buffer_node_tmp){
+		lut_data->stat_addr = buffer_node_tmp->pHyaddr;
+		lut_data->stat_vddr = buffer_node_tmp->pViraddr;
+	}
+	else {
+		lut_data->stat_addr = 0;
+		lut_data->stat_vddr = 0;
+	}
+	
+//	mutex_unlock(&gisp_cmd_mutex);
+}
+EXPORT_SYMBOL(bisp_updata); 
+
+static module_name_t module_name;
+void bisp_set_module_name(char *buf)
+{
+	strcpy(module_name.buf, buf);
+}
+EXPORT_SYMBOL(bisp_set_module_name);
+
+long bisp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	bisp_internal_t *info = (bisp_internal_t*) filp->private_data;
+	void __user *from = (void __user *)arg;
+	int ret_value = 0;
+	int ret_count = 0;
+	mutex_lock(&gisp_cmd_mutex);
+	//printk("bisp_ioctl in \n");
+
+	switch (cmd)
+	{
+		case BRI_BLC:
+		{
+			blc_info_t blc_inf;
+			ret_count=copy_from_user(&blc_inf,from,sizeof(blc_info_t));
+			set_blc(&blc_inf);
+		}
+		break;
+		case AF_CMD_GET_INFO:
+  	{
+  		void __user *to = (void __user *)arg;
+  		//printk("AF_CMD_GET_INFO===\n");
+  		//mutex_lock(&af_cmd_mutex);
+      ret_value = 0;
+      info->af_ready--;
+      ret_value = ov5647_af_fv_read(&info->af_sharpness,info->af_param.win_num);
+      if(ret_value == 0){
+      	//printk(KERN_ERR"AF_CMD_GET_INFO===\n");
+    		ret_count = copy_to_user(to,&info->af_sharpness,sizeof(af_pv_t));
+    	}
+  		//mutex_unlock(&af_cmd_mutex);  
+		}    
+    break; 
+   
+    case AF_CMD_ENABLE:
+    {
+    	//mutex_lock(&af_cmd_mutex);    	
+    	ov5647_af_clk_enable();
+    	ov5647_af_irq_enable();
+    	info->baf_enabled = 1;
+    	af_enable_count++;
+    	//mutex_unlock(&af_cmd_mutex);
+    }
+    break;
+    case AF_CMD_DISABLE:
+    {
+    	//mutex_lock(&af_cmd_mutex);   
+    	info->baf_enabled = 0;  	
+    	ov5647_af_irq_disable();
+    	ov5647_af_clk_disable();
+    	af_enable_count--;
+    	memset(&af_pv_data,0,sizeof(af_pv_data_t));
+    	//mutex_unlock(&af_cmd_mutex); 
+    }
+    break;
+    case AF_CMD_SET_WINPS:
+    {
+    	void __user *from = (void __user *)arg;
+    	//mutex_lock(&af_cmd_mutex);  	
+    	printk(KERN_ERR"AF_CMD_SET_WINPS \n");
+    	ret_count=copy_from_user(&info->af_param,from,sizeof(af_param_t));
+    	ov5647_af_param_set(info,&info->af_param);
+    	//mutex_unlock(&af_cmd_mutex);
+    }
+    break;
+    
+	case BRI_SEN:
+	{
+		bisp_info_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_info_t));
+		set_info(&binf);
+	}
+	break;
+	case BRI_SBS:
+	{
+		bisp_stat_buffers_info_t bisp_buffers;
+		ret_count=copy_from_user(&bisp_buffers,from,sizeof(bisp_stat_buffers_info_t));
+		printk("BRI_SBS \n");
+		init_node(info,&bisp_buffers);
+		printk("BRI_SBS 2\n");
+	}
+	break;
+	case BRI_FTB:
+	{
+		bisp_ads_t bisp_ads;
+		ret_count=copy_from_user(&bisp_ads,from,sizeof(bisp_ads_t));
+		//printk("BRI_FTB %x \n",bisp_ads.ads);
+		set_buffer_node(info,bisp_ads.ads);
+	}
+	break;
+	case BRI_COP:
+	{
+		bisp_region_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_region_t));
+		set_cop(&binf);
+	}
+	break;
+	case BRI_VNC:
+	{
+		bisp_vnc_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_vnc_t));
+		set_vnc(&binf);
+	}
+	break;
+	case BRI_LUT:
+	{
+		bisp_lsc_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_lsc_t));
+		set_lsc(&binf);
+	}
+	break;
+	case BRI_NR:
+	{
+		bisp_nr_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_nr_t));
+		set_nr(&binf);
+	}
+	break;
+	case BRI_EE:
+	{
+		bisp_nr_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_nr_t));
+		set_ee(&binf);
+	}
+	break;
+	case BRI_DPC:
+	{
+		bisp_nr_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_nr_t));
+		set_dpc(&binf);
+	}
+	break;
+	case BRI_GN:
+	{
+		bisp_bg_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_bg_t));
+		//set_gn(&binf);
+		isp_set_gain(&binf,info->open_count);
+	}
+	break;
+	case BRI_GET_GN:
+	{
+		bisp_bg_t binf;
+		isp_get_gain(info,&binf);
+		ret_count = copy_to_user(from,&binf,sizeof(bisp_bg_t));
+	}
+	break;
+	case BRI_SRG:
+	{
+		bisp_region_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_region_t));
+		set_srg(&binf);
+	}
+	break;
+	case BRI_SHG:
+	{
+		bisp_region_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_region_t));
+		set_hrg(&binf);
+	}
+	break;
+	case BRI_WBP:
+	{
+		bisp_wp_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_wp_t));
+		set_wbp(&binf);
+	}
+	break;
+	case BRI_CSC:
+	{
+		bisp_csc_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_csc_t));
+		set_csc(&binf);
+	}
+	break;
+	case BRI_CRP:
+	{
+		bisp_color_adjust_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_color_adjust_t));
+		set_crp(&binf);
+	}
+	break;
+	case BRI_CFX:
+	{
+		bisp_color_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_color_t));
+		set_cfx(&binf);
+	}
+	break;
+	case BRI_GC:
+	{
+		bisp_gc_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_gc_t));
+		set_gc(&binf);
+	}
+	break;
+	case BRI_HVB:
+	{
+		bisp_bank_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_bank_t));
+		set_hvb(&binf);
+	}
+	break;
+	case BRI_GET_SDS:
+	{
+		bisp_ads_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_ads_t));
+		get_sds(info,&binf);
+		ret_count = copy_to_user(from,&binf,sizeof(bisp_ads_t));
+		
+	}
+	break;
+	case BRI_GET_YDS:
+	{
+		bisp_ads_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_ads_t));
+		get_yds(&binf);
+		ret_count = copy_to_user(from,&binf,sizeof(bisp_ads_t));
+	}
+	break;
+	case BRI_GET_CRP:
+	{
+		bisp_region_t binf;
+		ret_count=copy_from_user(&binf,from,sizeof(bisp_region_t));
+		get_cop(&binf);
+		ret_count = copy_to_user(from,&binf,sizeof(bisp_region_t));
+	}
+	break;
+
+	case BRI_SID:
+	{
+		//int ch_id = (int)arg;
+		//int channel_num = 0;
+
+		//if(ch_id == 1){
+		//	get_config((char*)"cameraf.channel_num",(char*) &channel_num, sizeof(channel_num));
+		//}else {
+		//	get_config((char*)"camerab.channel_num",(char*) &channel_num, sizeof(channel_num));
+		//}
+		info->ch_id = 2;//channel_num + 1;
+		
+		//printk("info->ch_id %d %d %d,%d\n",info->ch_id,channel_num,info->open_count,gbisp_fifo[info->open_count]->ch_id);
+	}
+	break;
+	case BRI_GET_MODULE_NAME:
+		{
+	
+		int ch_id = (int)arg;
+		//char module_name[20];
+		//module_name_t module_name = {"ov5648",};
+		//if(ch_id == 1){
+		//	get_config("cameraf.module_name", &module_name.buf[0], 16);
+		//}
+		//else {
+		//	get_config("camerab.module_name", &module_name.buf[0], 16);
+		//}
+		printk("info->module_name %s\n",module_name.buf);
+		ret_count = copy_to_user(from,&module_name,sizeof(module_name_t));
+	}
+	break;
+
+	default:
+		mutex_unlock(&gisp_cmd_mutex);
+		return -EIO;
+	}
+
+//out:
+	mutex_unlock(&gisp_cmd_mutex);
+	//printk("bisp_ioctl out \n");
+	return 0;
+}
+
+int bisp_open(struct inode *inode, struct file *filp)
+{  
+  bisp_internal_t *info = NULL;
+	int i = 0;
+	int opened_cnt = 0;
+	mutex_lock(&gisp_cmd_mutex);
+  bisp_drv_opened++;
+  if (bisp_drv_opened > _CH_MX_NUM_)
+  {
+  	 printk("bisp_drv open count %d\n",bisp_drv_opened);
+  		bisp_drv_opened -= 1;
+  		mutex_unlock(&gisp_cmd_mutex);
+      return -1;
+  }
+  if(bisp_drv_opened == 1){
+  	 for(i = 0; i < _CH_MX_NUM_; i++){
+   		gbisp_fifo[i] = NULL;
+   	}
+  }
+   for(i = 0; i < _CH_MX_NUM_; i++){
+   	if(gbisp_fifo[i] == NULL){
+   		opened_cnt = i;
+   		i = _CH_MX_NUM_+1;   		
+   	}
+   	else{
+   		printk(KERN_ERR"xxxbisp_openx %d,%d,%d\n",bisp_drv_opened,opened_cnt,gbisp_fifo[i]->ch_id);
+   	}
+  }  
+  info = (bisp_internal_t*)kzalloc(sizeof(bisp_internal_t),GFP_KERNEL | GFP_DMA);
+  if(info == NULL)
+  {
+  	printk("bisp_drv malloc failed!\n");
+  	mutex_unlock(&gisp_cmd_mutex);
+  	return -1;
+  }
+   
+  info->open_count = opened_cnt;
+  
+  memset(info,0,sizeof(bisp_internal_t));
+  memset(&isp_rl_gain[opened_cnt],0,sizeof(isp_realtime_gain_t));    
+  filp->private_data = (void*)info;  
+  gbisp_fifo[opened_cnt] = info;
+  printk(KERN_ERR"xxxbisp_open %d,%d,%d\n",bisp_drv_opened,opened_cnt,gbisp_fifo[0]->ch_id);
+  if(bisp_drv_opened == 1){  		
+    	memset(&af_pv_data,0,sizeof(af_pv_data_t));
+    }
+  mutex_unlock(&gisp_cmd_mutex);
+	return 0;
+}
+
+int bisp_release(struct inode *inode, struct file *filp)
+{
+	bisp_internal_t *info = (bisp_internal_t *) filp->private_data;
+	mutex_lock(&gisp_cmd_mutex);
+  bisp_drv_opened--;
+  if(bisp_drv_opened <= 0){
+  	bisp_drv_opened = 0;  	
+  }
+  if(info){
+  	gbisp_fifo[info->open_count] = NULL;
+		kfree(info);
+		info = NULL;
+  }
+  mutex_unlock(&gisp_cmd_mutex);
+	printk(KERN_ERR"bisp_release\n");
+	return 0;
+
+}
+
+static void bisp_dts_init(void)
+{
+    bisp_sensor_info_t *sinfo;
+    g_bisp_dts.front = -1;
+    g_bisp_dts.rear = -1;
+    sinfo = &g_bisp_dts.sinfo[BISP_FRONT_SENSOR];
+    sinfo->channel = 0;
+    sinfo->name = NULL;
+    sinfo = &g_bisp_dts.sinfo[BISP_REAR_SENSOR];
+    sinfo->channel = 0;
+    sinfo->name = NULL;
+}
+
+static int parse_sensor_dts(struct device_node *dn, bisp_sensor_info_t *si)
+{
+    unsigned int channel;
+    const char *name;
+    
+    if (of_property_read_u32(dn, "channel", &channel)) {
+        printk(KERN_ERR "err: bisp fail to get sensor channel\n");
+        goto fail;
+    }
+    
+    si->channel = channel;
+#if 0
+    if (of_property_read_string(dn, "compatible", &name)) {
+        printk(KERN_ERR "err: bisp faild to get sensor's name\n");
+        goto fail;
+    }
+    si->name = name;
+#endif
+    return 0;
+fail:
+    return -EINVAL;
+}
+
+static int parse_bisp_dts(void)
+{
+    struct device_node *fdt_node;
+    struct device_node *rear_dn;
+    struct device_node *front_dn;
+    bisp_sensor_info_t *sinfo;
+    int err = 0;
+
+    static const char *sensorName[2] = {"sensor0", "sensor1"};
+
+    fdt_node = of_find_compatible_node(NULL, NULL, DEVDRV_NAME_BISP);
+    if (NULL == fdt_node) {
+        printk(KERN_ERR "err: no sensor [%s]\n", DEVDRV_NAME_BISP);
+        goto fail;
+    }
+    rear_dn = of_parse_phandle(fdt_node, "rear", 0);
+    if (NULL == rear_dn) {
+        printk(KERN_WARNING "not support rear sensor ??\n");  /* ignore it */
+    } else {
+        err = parse_sensor_dts(rear_dn, &g_bisp_dts.sinfo[BISP_REAR_SENSOR]);
+        if (0 == err) {
+            g_bisp_dts.sinfo[BISP_REAR_SENSOR].name = sensorName[BISP_REAR_SENSOR];
+            g_bisp_dts.rear = 1;
+        } else {
+            printk(KERN_ERR "bisp parse rear sensor failed\n");
+            goto fail;
+        }
+    }
+
+    front_dn = of_parse_phandle(fdt_node, "front", 0);
+    if (NULL == rear_dn) {
+        printk(KERN_WARNING "not support front sensor ??\n");
+    } else {
+        err = parse_sensor_dts(front_dn, &g_bisp_dts.sinfo[BISP_FRONT_SENSOR]);
+        if (0 == err) {
+            g_bisp_dts.sinfo[BISP_FRONT_SENSOR].name = sensorName[BISP_FRONT_SENSOR];
+            g_bisp_dts.front = 1;
+        } else {
+            printk(KERN_ERR "bisp parse front sensor failed\n");
+            goto fail;
+        }
+    }
+    if (g_bisp_dts.front) {
+        sinfo = &g_bisp_dts.sinfo[BISP_FRONT_SENSOR];
+        printk("front sensor: channel[%d], name: %s\n", sinfo->channel, sinfo->name);
+    } else {
+        printk("front sensor: don't support!!\n");
+    }
+    if (g_bisp_dts.rear) {
+        sinfo = &g_bisp_dts.sinfo[BISP_REAR_SENSOR];
+        printk("rear sensor: channel[%d], name: %s\n", sinfo->channel, sinfo->name);
+    } else {
+        printk("rear sensor: don't support!!\n");
+    }
+    return 0;
+
+fail:
+    return -EINVAL;
+}
+
+/* \BD\F8\C8\EB\B5͹\A6\BA\C4֮ǰ\A3\AC\B1\D8\D0뱣֤vpx\D2Ѿ\AD\BD\E2\C2\EB\CD굱ǰ֡\A1\A3
+ * 
+ */
+int bisp_suspend (struct platform_device * dev, pm_message_t state)
+{    
+		printk(KERN_ERR"bisp_suspend! %d,%d\n",bisp_drv_opened,af_enable_count);
+		if(bisp_drv_opened > 0 && af_enable_count > 0){
+			ov5647_af_irq_disable();
+    	//ov5647_af_clk_disable();
+  	}
+  	printk(KERN_ERR"bisp_suspend ok\n");
+    return 0;
+}
+
+
+int bisp_resume (struct platform_device * dev)
+{
+		printk(KERN_ERR"bisp_resume! %d,%d\n",bisp_drv_opened,af_enable_count);
+		if(bisp_drv_opened > 0 && af_enable_count > 0) {
+			//ov5647_af_clk_enable();
+		}
+		printk(KERN_ERR"bisp_resume ok\n");
+    return 0;
+}
+
+static void bisp_dummy_release(struct device *dev)
+{
+}
+
+
+static struct file_operations bisp_fops = 
+{
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = bisp_ioctl,
+	.open = bisp_open,
+	.release = bisp_release,
+};
+
+
+static struct platform_device bisp_platform_device = 
+{
+    .name   = DEVDRV_NAME_BISP,
+    .id = -1,
+    .dev = {
+        .release = bisp_dummy_release,
+    },
+};
+
+static struct platform_driver bisp_platform_driver = 
+{
+   .driver = 
+	 {
+        .name = DEVDRV_NAME_BISP,
+        .owner = THIS_MODULE,
+    },
+    .suspend = bisp_suspend,
+    .resume = bisp_resume,
+};
+
+
+static struct miscdevice bisp_miscdevice = 
+{
+     .minor = MISC_DYNAMIC_MINOR,
+     .name = DEVDRV_NAME_BISP,
+      .fops = &bisp_fops,
+};
+
+
+static int bisp_init(void)
+{
+	int ret;
+
+    bisp_dts_init();
+    parse_bisp_dts();
+    
+	//\D7Զ\AFinsmod\A3\ACע\B2\E1\C9豸
+    ret = misc_register(&bisp_miscdevice);
+    if (ret) 
+	  {
+        printk(KERN_ERR"register bisp misc device failed!...\n");
+        goto err0;
+    }
+    printk(KERN_ERR"bisp_drv_init ...\n");
+ 
+
+    ret = platform_device_register(&bisp_platform_device);
+    if (ret)
+    {
+        printk(KERN_ERR"register bisp_platform_device error!...\n");
+        goto err1;
+    }
+
+    ret = platform_driver_register(&bisp_platform_driver);
+    if (ret) 
+    {
+        printk(KERN_ERR"register bisp platform driver4pm error!...\n");
+        goto err2;
+    } 
+
+
+    return 0;
+
+err2:
+	platform_device_unregister(&bisp_platform_device);
+	
+err1:
+	misc_deregister(&bisp_miscdevice);
+	
+err0:
+    return ret;
+}
+
+static void bisp_exit(void)
+{
+	printk(KERN_ERR"bisp_drv_exit ...\n");
+	misc_deregister(&bisp_miscdevice);
+	platform_device_unregister(&bisp_platform_device);
+	platform_driver_unregister(&bisp_platform_driver);
+}
+
+module_init(bisp_init);
+module_exit(bisp_exit);
+
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/media/i2c/camera/owl_camera/bisp.h b/drivers/media/i2c/camera/owl_camera/bisp.h
new file mode 100755
index 0000000..6a765dd
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/bisp.h
@@ -0,0 +1,206 @@
+#ifndef __BISP_DRV__
+#define __BISP_DRV__
+
+typedef struct{
+	int chid;
+	int offset1;
+	int offset2;
+	int offset3;
+	int y_r;
+	int y_g;
+	int y_b;
+	int cb_r;
+	int cb_g;
+	int cb_b;
+	int cr_r;
+	int cr_g;
+	int cr_b;
+}bisp_csc_t;
+
+
+typedef struct{
+	int chid;
+	int lsc_en;
+	int vinc;
+	int hinc;
+	int xcenter;
+	int ycenter;
+	int xcenter_1;
+	int scaleidx;
+	unsigned int lsc_coeff[64];
+}bisp_lsc_t;
+
+typedef struct{
+	int chid;
+	short nr_en;
+	short nr_level;
+	short dpc_en;
+	short dpc_level;
+	int ee_en;
+}bisp_nr_t;
+
+typedef struct{
+	int chid;
+	unsigned int sx;
+  unsigned int ex;
+  unsigned int sy;
+  unsigned int ey;
+}bisp_region_t;
+
+typedef struct{
+	int chid;
+	unsigned int bgain;
+	unsigned int ggain;
+	unsigned int rgain;
+	unsigned int stat_addr;
+	unsigned int stat_vddr;
+}bisp_bg_t;
+
+typedef struct {
+	int chid;
+	int wb_thr;
+	int wb_thg;
+	int wb_thb;
+	unsigned int wb_cnt;
+}bisp_wp_t;
+
+typedef struct{
+	int chid;
+	int gc_en;
+	unsigned int gc_coeff[16];
+}bisp_gc_t;
+
+typedef struct{
+	int chid;
+	int ow;
+	int oh;
+	int ofmt;
+}bisp_outinfo_t;
+
+typedef struct{
+	int chid;
+	int color_seq;
+	int hsync;
+	int vsync;
+	int isp_mode;//not care here
+	int ch_IF;//parallel/mipi
+	int stat_en;
+	int eis_en;
+}bisp_info_t;
+
+typedef struct{
+	int chid;
+	int cb;
+	int cr;
+	int yinc;
+}bisp_color_t;
+
+
+typedef struct{
+	int hbank;
+	int vbank;
+}bisp_bank_t;
+
+
+typedef struct{
+	int chid;
+	int b_en;
+	unsigned int color_info[16];
+}bisp_color_adjust_t;
+
+typedef struct{
+	int b_en;
+	int vnc_num;
+	unsigned int color_info[3][128];
+}bisp_vnc_t;
+
+typedef struct{
+	int chid;
+	unsigned int ads;
+	unsigned int vds;
+	unsigned int last_addr;
+}bisp_ads_t;
+
+typedef struct{
+	int chid;
+	unsigned int buffer_num;//<16
+	unsigned int pHyaddr[16];
+	unsigned int pViaddr[16];
+}bisp_stat_buffers_info_t;
+
+typedef struct{
+	//\CAǷ\F1\D3\D0Чͳ\BCƣ\AC1 true\A3\AC0 false
+	int bPrepared;
+	unsigned int pv[9];
+}af_pv_t;
+//\CB㷨\B2\CE\CA\FD\C9\E8\D6ã\ACͬ\BCĴ\E6\C6\F7
+typedef struct{
+	//ͼ\CF\F3\B5Ŀ\ED\B8\DF
+	int win_w;
+	int win_h;
+	//\B5\F7\BD\B9\CB㷨
+	int af_al;
+	//\B2\C9\D1\F9\BE\AB\B6\C8
+	int af_inc;
+	//\D6ж\CFģʽ
+	int af_mode;
+	int rshift;
+	int thold;
+	int tshift;
+	//\B4\B0\B8\F6\CA\FD-1
+	int win_num;
+	//\B4\B0\BFڴ\F3С
+	int win_size;
+	//\CF\E0\B6\D4λ\D6\C3
+	unsigned int af_pos[9];
+	unsigned int noise_th;
+}af_param_t;
+
+typedef struct{
+	int r_off;
+	int g1_off;
+	int g2_off;
+	int b_off;
+}blc_info_t;
+typedef struct{
+	char buf[16];
+	int  rev[4];
+}module_name_t;
+#define BRAWISP_DRV_IOC_MAGIC_NUMBER             'P'
+//#define BRI_SCH         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x100) //not set ch
+#define BRI_SEN         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x101,bisp_info_t)
+#define BRI_COP         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x102,bisp_region_t)
+#define BRI_VNC         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x103,bisp_vnc_t) // not support here
+#define BRI_LUT         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x104,bisp_lsc_t)
+#define BRI_NR          _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x105,bisp_nr_t)
+#define BRI_EE          _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x106,bisp_nr_t)
+#define BRI_DPC         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x107,bisp_nr_t)
+#define BRI_GN          _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x108,bisp_bg_t)
+#define BRI_SRG         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x109,bisp_region_t)
+#define BRI_SHG         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x10A,bisp_region_t)
+#define BRI_WBP         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x10B,bisp_wp_t)
+#define BRI_CSC         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x10C,bisp_csc_t)
+#define BRI_CRP         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x10D,bisp_color_adjust_t)
+#define BRI_CFX         _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x10E,bisp_color_t)
+#define BRI_GC          _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x10F,bisp_gc_t)
+#define BRI_HVB          _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x110,bisp_bank_t)
+#define BRI_SBS          _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x120,bisp_stat_buffers_info_t)
+#define BRI_FTB          _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x121,bisp_ads_t)
+#define BRI_SID          _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x122,int)
+#define BRI_BLC          _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x123,blc_info_t)
+//\CD\EA\B3\C9irq\BA\CDenable\C9\E8\D6\C3
+#define AF_CMD_ENABLE          _IO(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x1000)
+//disableirq\BA\CDenable
+#define AF_CMD_DISABLE         _IO(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x1001)
+//\BB\F1ȡͳ\BC\C6\D0\C5Ϣ
+#define AF_CMD_GET_INFO        _IOR(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x1002,af_pv_t)
+//\C9\E8\D6ô\B0\BFں\CD\CB㷨\B2\CE\CA\FD\A3\AC\C9\E8\D6\C3һ\B4Σ\AC\D4\CB\D0\D0\D6\D0\C9\E8\D6ã\AC\D0\E8Ҫ\B5ȴ\FDһ֡
+#define AF_CMD_SET_WINPS     	 _IOW(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x1003,af_param_t)
+
+#define BRI_GET_SDS     _IOWR(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x200,bisp_ads_t)
+#define BRI_GET_YDS     _IOWR(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x201,bisp_ads_t)
+#define BRI_GET_CRP     _IOWR(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x202,bisp_region_t)
+#define BRI_GET_GN     _IOWR(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x203,bisp_bg_t)
+#define BRI_GET_MODULE_NAME     _IOWR(BRAWISP_DRV_IOC_MAGIC_NUMBER, 0x204,module_name_t)
+
+#endif
diff --git a/drivers/media/i2c/camera/owl_camera/owl_7059.txt b/drivers/media/i2c/camera/owl_camera/owl_7059.txt
new file mode 100755
index 0000000..a69a0f0
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/owl_7059.txt
@@ -0,0 +1,7 @@
+make -C /harddisk3/lichi/gs705a/leopard/build/gs703a/out_atm7059tc_hr820ac/kernel ARCH=arm CROSS_COMPILE=/opt/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_GNU_Linux/bin/arm-none-linux-gnueabi- \
+		EXTRA_CFLAGS="" M=/harddisk3/lichi/gs705a/leopard/platform/drivers/camera/isp modules
+make[1]: Entering directory `/harddisk3/lichi/gs705a/leopard/build/gs703a/out_atm7059tc_hr820ac/kernel'
+  CC [M]  /harddisk3/lichi/gs705a/leopard/platform/drivers/camera/isp/gl5203_camera.o
+  CC [M]  /harddisk3/lichi/gs705a/leopard/platform/drivers/camera/isp/bisp.o
+  CC [M]  /harddisk3/lichi/gs705a/leopard/platform/drivers/camera/isp/gl5206_camera.o
+make[1]: Leaving directory `/harddisk3/lichi/gs705a/leopard/build/gs703a/out_atm7059tc_hr820ac/kernel'
diff --git a/drivers/media/i2c/camera/owl_camera/owl_camera.c b/drivers/media/i2c/camera/owl_camera/owl_camera.c
new file mode 100755
index 0000000..cf4f895
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/owl_camera.c
@@ -0,0 +1,2339 @@
+/*
+ * V4L2 Driver for OWL camera host
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/videodev2.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-dev.h>
+#include <media/videobuf2-dma-contig.h>
+#include <linux/slab.h>
+#include <media/soc_camera.h>
+#include <media/soc_mediabus.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/time.h>
+#include <mach/hardware.h>
+#include <asm/delay.h>
+#include <mach/module-owl.h>
+#include <mach/clkname.h>
+#include <mach/powergate.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/mfd/atc260x/atc260x.h>
+#include <media/videobuf2-memops.h>
+
+#include "owl_camera.h"
+#include"atm7059.c"
+
+static struct owl_camera_hw_adapter* hw_adapter = NULL;
+
+#define ISP_FDT_COMPATIBLE "actions,owl-isp"
+
+#define	DEBUG_FRAME_RATE 0
+
+#define DBG_ERR(fmt, args...)   printk(KERN_ERR"[owl_camera] (ERR) line:%d--%s() "fmt"\n", __LINE__, __FUNCTION__, ##args)
+#ifdef OWL_DBG
+#define DBG_INFO(fmt, args...)  printk(KERN_INFO"[owl_camera] (ERR) line:%d--%s() "fmt"\n", __LINE__, __FUNCTION__, ##args) 
+#else 
+#define DBG_INFO(fmt, args...)  do{}while(0)
+#endif
+
+#define ISP_MAX_WIDTH	4288
+#define ISP_MAX_HEIGHT	3000
+#define ISP_WORK_CLOCK	60000000        //Hz
+#define CSI_WORK_CLOCK  150000000
+
+#define OWL_CAM_HOST_NAME "owl-camera-host"
+#define CAM_DRV_NAME OWL_CAM_HOST_NAME
+
+#define MAX_VIDEO_MEM 32
+#define ISP_REG_NUM_WORD    189
+#define DROP_FRAM_INIT_VAL  0xff
+
+#define ISP_MIN_FRAME_RATE 2
+#define ISP_FRAME_INTVL_MSEC	(1000 / ISP_MIN_FRAME_RATE)
+
+struct owl_camera_buffer {
+    /* common v4l buffer stuff -- must be first */
+    struct vb2_buffer vb;
+    struct list_head queue;
+    enum v4l2_mbus_pixelcode code;
+};
+
+static inline void isp_set_preline(struct soc_camera_device *icd)
+{
+    	struct owl_camera_param *param = icd->host_priv;
+  	int ret = 0;
+	
+	ret = owl_camera_hw_call(hw_adapter, set_channel_preline, param->channel, param->isp_top);
+}
+
+static inline int isp_set_col_range(struct soc_camera_device *icd, unsigned int start,
+                                    unsigned int end)
+{
+	struct owl_camera_param *cam_param = icd->host_priv;
+
+	int width;
+	int ret = 0;
+	start = ((start + 1) / 2) * 2;
+	width = end - start + 1;
+	width = ((width + 31) / 32) * 32;
+	end = width + start - 1;
+
+	if (width >= ISP_MAX_WIDTH) {
+		DBG_ERR("width is over range, width:%d, start:%d, end:%d", width, start, end);
+		return -EINVAL;
+	}
+	ret = owl_camera_hw_call(hw_adapter, set_col_range,cam_param->channel, start, end);
+
+	return 0;
+}
+
+static inline int isp_set_row_range(struct soc_camera_device *icd, unsigned int start,
+                                    unsigned int end)
+{
+	struct owl_camera_param *cam_param = icd->host_priv;
+	int height = end - start + 1;
+	int ret = 0;
+
+	height = ((height + 1) / 2) * 2;
+	end = height + start - 1;
+
+	if (height > ISP_MAX_HEIGHT) {
+		DBG_ERR("height is over range, height:%d, start:%d, end:%d", height, start, end);
+		return -EINVAL;
+	}
+	ret = owl_camera_hw_call(hw_adapter, set_row_range,cam_param->channel, start, end);
+
+	return 0;
+}
+
+/* rect is guaranteed to not exceed the camera rectangle */
+static inline void isp_set_rect(struct soc_camera_device *icd)
+{
+    struct owl_camera_param *cam_param = icd->host_priv;
+
+    isp_set_col_range(icd, cam_param->isp_left, cam_param->isp_left + icd->user_width - 1);
+    isp_set_row_range(icd, cam_param->isp_top, cam_param->isp_top + icd->user_height - 1);
+}
+
+
+static int isp_set_input_fmt(struct soc_camera_device *icd, enum v4l2_mbus_pixelcode code)
+{
+	struct owl_camera_param *cam_param = icd->host_priv;
+	int ret = 0;
+
+	ret = owl_camera_hw_call(hw_adapter, set_channel_input_fmt, cam_param->channel, code);
+
+	return ret;
+}
+
+static int isp_set_output_fmt(struct soc_camera_device *icd, u32 fourcc)
+{
+	struct owl_camera_param *cam_param = icd->host_priv;
+	int ret = 0; 
+
+	ret = owl_camera_hw_call(hw_adapter, set_channel_output_fmt, cam_param->channel, fourcc);
+
+	return ret;
+}
+
+static void isp_set_frame(struct owl_camera_dev *cam_dev, struct vb2_buffer *vb)
+{
+    struct soc_camera_device *icd = cam_dev->icd;
+    struct owl_camera_param *cam_param = icd->host_priv;
+    u32 fourcc = icd->current_fmt->host_fmt->fourcc;
+
+    dma_addr_t isp_addr;
+    dma_addr_t isp_addr_Y;
+    dma_addr_t isp_addr_U;
+    dma_addr_t isp_addr_V;
+    dma_addr_t isp_addr_UV;
+
+    if (NULL == vb) {
+        DBG_ERR( "cannot get video buffer.");
+        return;
+    }
+	DBG_INFO("");
+    switch (vb->v4l2_buf.memory) {
+    case V4L2_MEMORY_MMAP:
+        isp_addr = vb2_dma_contig_plane_dma_addr(vb, 0);
+        break;
+    case V4L2_MEMORY_USERPTR:
+        isp_addr = vb->v4l2_planes[0].m.userptr;
+        break;
+    default:
+        DBG_ERR("wrong memory type.");
+        return;
+    }
+
+    DBG_INFO("frame paddr:0x%x", isp_addr);
+
+    switch (fourcc) {
+    case V4L2_PIX_FMT_YUV420:      //420 planar
+        DBG_INFO("420p");
+        isp_addr_Y = ALIGN(isp_addr, 2);
+        isp_addr_U = ALIGN(isp_addr_Y + icd->user_width * icd->user_height, 2);
+        isp_addr_V = ALIGN(isp_addr_U + icd->user_width * icd->user_height / 4, 2);
+		owl_camera_hw_call(hw_adapter, set_channel_addrY, cam_param->channel, (void*)isp_addr_Y);
+		owl_camera_hw_call(hw_adapter, set_channel_addrU, cam_param->channel, (void*)isp_addr_U);
+		owl_camera_hw_call(hw_adapter, set_channel_addrV, cam_param->channel, (void*)isp_addr_V);
+     
+        break;
+	 case V4L2_PIX_FMT_YVU420:      //420 planar
+        DBG_INFO("420p");
+        isp_addr_Y = ALIGN(isp_addr, 2);
+        isp_addr_U = ALIGN(isp_addr_Y + icd->user_width * icd->user_height, 2);
+        isp_addr_V = ALIGN(isp_addr_U + icd->user_width * icd->user_height / 4, 2);
+		owl_camera_hw_call(hw_adapter, set_channel_addrY, cam_param->channel, (void*)isp_addr_Y);
+		owl_camera_hw_call(hw_adapter, set_channel_addrU, cam_param->channel, (void*)isp_addr_V);
+		owl_camera_hw_call(hw_adapter, set_channel_addrV, cam_param->channel, (void*)isp_addr_U);
+     
+        break;	
+
+    case V4L2_PIX_FMT_YUV422P:     //422 semi planar
+        DBG_INFO("422p");
+        isp_addr_Y = ALIGN(isp_addr, 2);
+        isp_addr_U = ALIGN(isp_addr_Y + icd->user_width * icd->user_height, 2);
+        isp_addr_V = ALIGN(isp_addr_U + icd->user_width * icd->user_height / 4, 2);
+        owl_camera_hw_call(hw_adapter, set_channel_addrY, cam_param->channel, (void*)isp_addr_Y);
+        owl_camera_hw_call(hw_adapter, set_channel_addrU, cam_param->channel, (void*)isp_addr_V);
+        owl_camera_hw_call(hw_adapter, set_channel_addrV, cam_param->channel, (void*)isp_addr_U);
+
+        break;
+
+    case V4L2_PIX_FMT_NV12:        //420 semi-planar
+    case V4L2_PIX_FMT_NV21:        //420 semi-planar
+        DBG_INFO("420sp");
+        isp_addr_Y = ALIGN(isp_addr, 2);
+        isp_addr_UV = ALIGN(isp_addr_Y + icd->user_width * icd->user_height, 2);
+		owl_camera_hw_call(hw_adapter, set_channel_addrY, cam_param->channel, (void*)isp_addr_Y);
+		owl_camera_hw_call(hw_adapter, set_channel_addrU, cam_param->channel, (void*)isp_addr_UV);
+      
+        break;
+
+    case V4L2_PIX_FMT_YUYV:        //interleaved
+	case V4L2_PIX_FMT_UYVY:
+        DBG_INFO("422P");
+        isp_addr_Y = ALIGN(isp_addr, 2);
+        isp_addr_U = ALIGN(isp_addr_Y + icd->user_width * icd->user_height, 2);
+        isp_addr_V = ALIGN(isp_addr_U + icd->user_width * icd->user_height / 4, 2);
+        owl_camera_hw_call(hw_adapter, set_channel_addrY, cam_param->channel, (void*)isp_addr_Y);
+        owl_camera_hw_call(hw_adapter, set_channel_addrU, cam_param->channel, (void*)isp_addr_V);
+        owl_camera_hw_call(hw_adapter, set_channel_addrV, cam_param->channel, (void*)isp_addr_U);
+        break;
+
+    default:       /* Raw RGB */
+        DBG_ERR("Set isp output format failed, fourcc = 0x%x", fourcc);
+        return;
+    }
+}
+
+
+static int isp_set_signal_polarity(struct soc_camera_device *icd, unsigned int common_flags)
+{
+	struct owl_camera_param *cam_param = icd->host_priv;
+
+	DBG_INFO("channel:%d, pclk:%s, hsync:%s, vsync:%s",
+		cam_param->channel, 
+		common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING ? "falling" : "rising",
+		common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW ? "low" : "high",
+		common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW ? "low" : "high");
+
+        if(!owl_camera_hw_call(hw_adapter,set_signal_polarity,cam_param->channel,common_flags))
+	{
+	
+		return 0;
+	}
+
+	return 0;
+}
+
+
+static void isp_capture_start(struct owl_camera_dev *cam_dev)
+{
+	int ret = 0;
+    struct soc_camera_device *icd = cam_dev->icd;
+    struct owl_camera_param *cam_param = icd->host_priv;
+	
+    if (cam_dev->started == DEV_START) {
+        DBG_INFO("already start");
+        return;
+    }
+
+    if (V4L2_MBUS_CSI2 == cam_param->bus_type) {
+    }
+
+    cam_dev->skip_frames = DROP_FRAM_INIT_VAL;
+    isp_set_preline(icd);
+	ret |= owl_camera_hw_call(cam_dev->hw_adapter, set_channel_if, cam_param->channel,cam_param->bus_type);
+	ret |= owl_camera_hw_call(hw_adapter, set_channel_preline_int_en, cam_param->channel);
+	ret |= owl_camera_hw_call(hw_adapter, clear_all_pending);
+	
+	ret |= owl_camera_hw_call(hw_adapter, set_channel_int_en, cam_param->channel);
+	
+    cam_dev->started = DEV_START;
+
+    DBG_INFO("chnnel-%d, %s", cam_param->channel,
+             V4L2_MBUS_PARALLEL == cam_param->bus_type ? "dvp" : "mipi");
+
+    
+}
+
+static void isp_capture_stop(struct owl_camera_dev *cam_dev)
+{
+    struct soc_camera_device *icd = cam_dev->icd;
+    struct owl_camera_param *cam_param = icd->host_priv;
+    unsigned long flags;
+    int ret;
+
+    if (cam_dev->started == DEV_STOP) {
+        DBG_INFO("already stop");
+        return;
+    }
+
+    spin_lock_irqsave(&cam_dev->lock, flags);
+	
+	ret |= owl_camera_hw_call(hw_adapter, clear_channel_int_en, cam_param->channel);
+	ret |= owl_camera_hw_call(hw_adapter, clear_channel_preline_pending, cam_param->channel);
+	ret |= owl_camera_hw_call(hw_adapter, set_channel_frameend_int_en, cam_param->channel);
+	
+    cam_dev->started = DEV_STOP;
+    spin_unlock_irqrestore(&cam_dev->lock, flags);
+
+    ret = wait_for_completion_timeout(&cam_dev->wait_stop, msecs_to_jiffies(ISP_FRAME_INTVL_MSEC));
+    if (ret <= 0) {
+        DBG_ERR("%s wake up before frame complete", __func__);
+    } else {
+        DBG_INFO("%s ret is %d remain %dms to wait for stop", __func__, ret,jiffies_to_msecs(ret));
+    }
+    if (V4L2_MBUS_CSI2 == cam_param->bus_type) {
+    }
+}
+
+
+static inline struct owl_camera_buffer *to_isp_buf(struct vb2_buffer *vb)
+{
+    return (container_of(vb, struct owl_camera_buffer, vb));
+}
+
+/* make sure capture list is not empty */
+static inline struct vb2_buffer *next_vb2_buf(struct owl_camera_dev *ispdev)
+{
+    struct owl_camera_buffer *cb = NULL;
+
+    cb = list_entry(ispdev->capture.next, struct owl_camera_buffer, queue);
+    list_del_init(&cb->queue);
+
+    return (&cb->vb);
+}
+
+static inline int get_bytes_per_line(struct soc_camera_device *icd)
+{
+    return (soc_mbus_bytes_per_line(icd->user_width, icd->current_fmt->host_fmt));
+}
+
+static inline int get_frame_size(struct soc_camera_device *icd)
+{
+    int bytes_per_line = get_bytes_per_line(icd);
+    return (icd->user_height * bytes_per_line);
+}
+
+
+static int owl_isp_videobuf_setup(struct vb2_queue *vq,
+    const struct v4l2_format *fmt, unsigned int *count,
+    unsigned int *num_planes, unsigned int sizes[], void *alloc_ctxs[])
+{
+    struct soc_camera_device *icd = soc_camera_from_vb2q(vq);
+    struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
+    struct owl_camera_dev *ispdev = ici->priv;
+    unsigned long frame_size = get_frame_size(icd);
+
+    if (frame_size < 0)
+        return (frame_size);
+
+    *num_planes = 1;
+
+    ispdev->sequence = 0;
+    sizes[0] = frame_size;
+    alloc_ctxs[0] = ispdev->alloc_ctx;
+
+    if (*count < 2) {
+        *count = 2;
+    }
+
+    if (sizes[0] * *count > MAX_VIDEO_MEM * 1024 * 1024)
+        *count = MAX_VIDEO_MEM * 1024 * 1024 / sizes[0];
+
+    dev_dbg(icd->parent, "count=%d, size=%d", *count, sizes[0]);
+
+    return 0;
+}
+
+static int owl_isp_videobuf_prepare(struct vb2_buffer *vb)
+{
+    struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
+    struct owl_camera_buffer *buf = NULL;
+    unsigned long frame_size = get_frame_size(icd);;
+
+    if (frame_size < 0) {
+        return (frame_size);
+    }
+
+    buf = to_isp_buf(vb);
+
+    dev_dbg(icd->parent, "%s (vb=0x%p) 0x%p %lu", __func__,
+            vb, vb2_plane_vaddr(vb, 0), vb2_get_plane_payload(vb, 0));
+
+    /* Added list head initialization on alloc */
+    if (!list_empty(&buf->queue)) {
+        dev_err(icd->parent, "Buffer %p on queue already!", vb);
+    }
+#ifdef DEBUG
+    /*
+     * This can be useful if you want to see if we actually fill
+     * the buffer with something
+     */
+    if (vb2_plane_vaddr(vb, 0)) {
+        memset(vb2_plane_vaddr(vb, 0), 0xaa, vb2_get_plane_payload(vb, 0));
+    }
+#endif
+
+    BUG_ON(NULL == icd->current_fmt);
+
+    if (vb2_plane_size(vb, 0) < frame_size) {
+        dev_err(icd->parent, "Buffer too small (%lu < %lu)", vb2_plane_size(vb, 0), frame_size);
+        return (-ENOBUFS);
+    }
+
+    vb2_set_plane_payload(vb, 0, frame_size);
+
+    return 0;
+}
+
+
+static void owl_isp_videobuf_queue(struct vb2_buffer *vb)
+{
+	struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
+	struct owl_camera_dev *ispdev = ici->priv;
+	struct owl_camera_buffer *buf = to_isp_buf(vb);
+	unsigned long flag;
+
+	dev_dbg(icd->parent, "%s (vb=0x%p) 0x%p %lu", __func__,
+	    vb, vb2_plane_vaddr(vb, 0), vb2_get_plane_payload(vb, 0));
+
+	spin_lock_irqsave(&ispdev->lock, flag);
+	list_add_tail(&buf->queue, &ispdev->capture);
+	if (NULL == ispdev->cur_frm) {      // first one to enable isp
+		/* Is better to move into start_streaming, but HAL start stream before qbuf */
+		ispdev->cur_frm = next_vb2_buf(ispdev);
+		ispdev->prev_frm = NULL;
+		spin_unlock_irqrestore(&ispdev->lock, flag);
+
+		isp_set_rect(icd);
+		isp_set_frame(ispdev, ispdev->cur_frm);
+		isp_capture_start(ispdev);
+	} else {
+		spin_unlock_irqrestore(&ispdev->lock, flag);
+	}
+}
+
+static void owl_isp_videobuf_release(struct vb2_buffer *vb)
+{
+    struct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);
+    struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
+    struct owl_camera_buffer *buf = to_isp_buf(vb);
+    struct owl_camera_dev *ispdev = ici->priv;
+    unsigned long flag;
+
+    spin_lock_irqsave(&ispdev->lock, flag);
+
+    if (ispdev->cur_frm == vb) {
+        ispdev->cur_frm = NULL;
+    }
+
+    if (ispdev->prev_frm == vb) {
+        ispdev->prev_frm = NULL;
+    }
+
+    if(buf != NULL && buf->queue.next != NULL) {
+        list_del_init(&buf->queue);
+    }
+
+    spin_unlock_irqrestore(&ispdev->lock, flag);
+}
+
+
+static int owl_isp_videobuf_init(struct vb2_buffer *vb)
+{
+	struct owl_camera_buffer *buf = to_isp_buf(vb);
+
+	INIT_LIST_HEAD(&buf->queue);
+
+	return 0;
+}
+
+static int owl_isp_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	return 0;
+}
+
+
+static int owl_isp_stop_streaming(struct vb2_queue *vq)
+{
+    struct soc_camera_device *icd = soc_camera_from_vb2q(vq);
+    struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
+    struct owl_camera_dev *ispdev = ici->priv;
+    struct owl_camera_buffer *buf, *node;
+    unsigned long flag;
+
+	DBG_INFO("");
+
+    spin_lock_irqsave(&ispdev->lock, flag);
+
+    ispdev->cur_frm = NULL;
+    list_for_each_entry_safe(buf, node, &ispdev->capture, queue) {
+        list_del_init(&buf->queue);
+        vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+    }
+
+    spin_unlock_irqrestore(&ispdev->lock, flag);
+
+    isp_capture_stop(ispdev);
+
+    return (0);
+}
+
+
+static struct vb2_ops owl_isp_videobuf_ops = {
+    .queue_setup = owl_isp_videobuf_setup,
+    .buf_prepare = owl_isp_videobuf_prepare,
+    .buf_queue = owl_isp_videobuf_queue,
+    .buf_cleanup = owl_isp_videobuf_release,
+    .buf_init = owl_isp_videobuf_init,
+    .wait_prepare = soc_camera_unlock,
+    .wait_finish = soc_camera_lock,
+    .start_streaming = owl_isp_start_streaming,
+    .stop_streaming = owl_isp_stop_streaming,
+};
+
+
+/** 
+ * using preline interrupt of current active buffer to indicate that previous buffer
+ * have received all data from sensor, unlike old manner to indicate current buffer's.
+ * so ISP_PRELINE_NUM should be as small as possible.
+ * to do this taking tow reasons into account:
+ * 1. no need to check or wait for frame end interrupt pending which is less useful for ISR.
+ * 2. max time of  interrupt response delay shoud be less than about 30ms for 30 fps.
+ *     if interval time between preline-interrupt and vsync is less than 30ms, 
+ *     there is a risk that ISR receive tow preline interrupt between 
+ *     tow adjacent vsync, a buffer will be skipped leaving old data in it.
+ */
+
+struct vb2_buffer *tmp_vbbuffer = NULL;
+
+static irqreturn_t owl_camera_host_isp_isr(int irq, void *data)
+{
+	struct owl_camera_dev *cam_dev = data;
+	struct soc_camera_device *icd = cam_dev->icd;
+	struct owl_camera_param *cam_param = icd->host_priv;
+	int reset = 0;
+	struct vb2_buffer *vb = NULL;
+	int ret;
+	unsigned long flags;
+	unsigned int preline_int_pd,frameend_int_pd;
+	unsigned int isp_int_stat,tmp_int_stat;
+	DBG_INFO("Enter isr");
+	reset = 0;
+	preline_int_pd = hw_adapter->preline_int_pd;
+	frameend_int_pd = hw_adapter->frameend_int_pd;
+	spin_lock_irqsave(&cam_dev->lock, flags);
+	isp_int_stat = owl_camera_hw_call(hw_adapter, get_channel_state,cam_param->channel);
+	tmp_int_stat = isp_int_stat;
+	if (DROP_FRAM_INIT_VAL == cam_dev->skip_frames) {
+		cam_dev->skip_frames = cam_param->skip_frames;
+	}
+
+	if ((cam_dev->skip_frames) && (isp_int_stat & preline_int_pd)) {
+		cam_dev->skip_frames--;
+		DBG_INFO("skip frame: %d", cam_dev->skip_frames);
+		goto out;
+	}
+	
+	if(owl_camera_hw_call(hw_adapter, get_channel_overflow,cam_param->channel))
+	{
+		printk(KERN_ERR"si is over flow , reset si\n");
+	
+		owl_camera_hw_call(hw_adapter, clear_channel_overflow, cam_param->channel);
+		writel(readl(si_reset)|(0x1<<31),si_reset);
+		ret |= owl_camera_hw_call(hw_adapter, clear_channel_int_en, cam_param->channel);
+		mdelay(1);
+		owl_camera_hw_call(hw_adapter, save_regs);
+		
+		module_reset(MODULE_RST_BISP);
+		
+		owl_camera_hw_call(hw_adapter, restore_regs);
+		isp_set_rect(icd);
+		isp_set_frame(cam_dev, cam_dev->prev_frm);
+		writel(readl(si_reset)&(~(0x1<<31)),si_reset);
+		ret |= owl_camera_hw_call(hw_adapter, set_channel_int_en, cam_param->channel);
+		tmp_vbbuffer = cam_dev->cur_frm;
+		cam_dev->cur_frm = cam_dev->prev_frm;
+		cam_dev->prev_frm = NULL;
+		reset = 1;
+		
+	}
+	if(reset)
+	{
+		DBG_INFO("in the reset\n");
+		goto out;
+	}
+	if (cam_dev->started == DEV_STOP&&(tmp_int_stat&frameend_int_pd)) {
+		printk(KERN_INFO"found stop in isp_isr");
+			ret |= owl_camera_hw_call(hw_adapter, clear_channel_frameend_int_en, cam_param->channel);
+		complete(&cam_dev->wait_stop);
+		goto out;
+    	}
+	if(tmp_int_stat & preline_int_pd)
+	{
+		ret = owl_camera_hw_call(hw_adapter, clear_channel_preline_pending,isp_int_stat);
+	}
+  	if(tmp_int_stat & frameend_int_pd)
+	{
+		ret = owl_camera_hw_call(hw_adapter, clear_channel_frameend_pending,isp_int_stat);
+	}
+    if (isp_int_stat & preline_int_pd) {
+        // send out a packet already recevied all data
+        if (cam_dev->prev_frm != NULL) {
+            vb = cam_dev->prev_frm;
+            do_gettimeofday(&vb->v4l2_buf.timestamp);
+            vb->v4l2_buf.sequence = cam_dev->sequence++;
+            vb2_buffer_done(vb, VB2_BUF_STATE_DONE);
+        }
+
+        if (!list_empty(&cam_dev->capture)) {
+            
+			
+			cam_dev->prev_frm = cam_dev->cur_frm;
+			if(tmp_vbbuffer)
+				{
+				cam_dev->cur_frm = tmp_vbbuffer;
+				}
+			else
+				{
+				cam_dev->cur_frm = next_vb2_buf(cam_dev);
+				}
+				
+            isp_set_rect(icd);
+            isp_set_frame(cam_dev, cam_dev->cur_frm);
+        } else {
+            cam_dev->prev_frm = NULL;
+            isp_set_rect(icd);
+            isp_set_frame(cam_dev, cam_dev->cur_frm);
+        }
+
+    }
+	tmp_vbbuffer = NULL;
+  out:
+  	if(tmp_int_stat & preline_int_pd)
+		{
+		ret = owl_camera_hw_call(hw_adapter, clear_channel_preline_pending,isp_int_stat);
+		}
+  	if((tmp_int_stat & frameend_int_pd))
+  		{
+		ret = owl_camera_hw_call(hw_adapter, clear_channel_frameend_pending,isp_int_stat);
+  		}
+    spin_unlock_irqrestore(&cam_dev->lock, flags);
+
+    return IRQ_HANDLED;
+}
+
+
+
+
+static void isp_regulator_enable(struct isp_regulators *ir);
+static void isp_regulator_disable(struct isp_regulators *ir);
+
+
+/* Called with .video_lock held */
+static int owl_camera_add_device(struct soc_camera_device *icd)
+{
+    struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
+    struct owl_camera_dev *cam_dev = ici->priv;
+    struct clk *isp_clk = cam_dev->isp_clk;
+    int err;
+
+    if (cam_dev->icd) {
+        DBG_ERR("devices has already exists.");
+        return -EBUSY;
+    }
+    config_inner_charger_current(DEV_CHARGER_PRE_CONFIG, DEV_CHARGER_CURRENT_CAMERA, 1);
+	err = owl_powergate_power_on(OWL_POWERGATE_VCE_BISP);
+	if (err) {
+		DBG_ERR("owl powergate power-on error %d", err);
+		return err;
+	}
+	module_reset(MODULE_RST_BISP);
+	module_clk_enable(MOD_ID_BISP);
+
+    clk_prepare(isp_clk);
+    err = clk_enable(isp_clk);
+    if (err) {
+        DBG_ERR("enable isp clock failed %d", err);
+        return err;
+    }
+  
+    err = clk_set_rate(isp_clk, ISP_WORK_CLOCK);
+    if (err) {
+        DBG_ERR("set isp clock rate failed %d", err);
+        return err;
+    }
+    DBG_INFO("isp clock is %dM", (int) (clk_get_rate(isp_clk) / 1000000));
+
+   
+    isp_regulator_enable(&cam_dev->ir);
+
+    cam_dev->started = DEV_OPEN;
+    owl_isp_reset_pin_state = 1;
+    cam_dev->icd = icd;
+    config_inner_charger_current(DEV_CHARGER_POST_CONFIG, DEV_CHARGER_CURRENT_CAMERA, 1);
+    pm_runtime_get_sync(ici->v4l2_dev.dev);
+	writel(0xf,noc_si_to_ddr);
+    DBG_INFO("[add_device] isp attached to sensor %d", icd->devnum);
+
+    return 0;
+}
+
+/* Called with .video_lock held */
+static void owl_camera_remove_device(struct soc_camera_device *icd)
+{
+    struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
+    struct owl_camera_dev *cam_dev = ici->priv;
+    struct clk *isp_clk = cam_dev->isp_clk;
+    unsigned long flags;
+    int err = 0;
+
+    BUG_ON(icd != cam_dev->icd);
+
+    /* make sure active buffer is canceled */
+
+    BUG_ON(NULL != cam_dev->cur_frm);
+    BUG_ON(NULL != cam_dev->prev_frm);
+
+    spin_lock_irqsave(&cam_dev->lock, flags);
+    cam_dev->started = DEV_CLOSE;
+    owl_isp_reset_pin_state = 0;
+    spin_unlock_irqrestore(&cam_dev->lock, flags);
+
+    pm_runtime_put_sync(ici->v4l2_dev.dev);
+    config_inner_charger_current(DEV_CHARGER_PRE_CONFIG, DEV_CHARGER_CURRENT_CAMERA, 0);
+    isp_regulator_disable(&cam_dev->ir);
+
+    clk_disable(isp_clk);
+    clk_unprepare(isp_clk);
+    clk_put(isp_clk);
+    module_clk_disable(MOD_ID_BISP);
+
+    err = owl_powergate_power_off(OWL_POWERGATE_VCE_BISP);
+    if (err) {
+        DBG_ERR("owl powergate power-off err %d", err);
+    }
+
+  
+    config_inner_charger_current(DEV_CHARGER_POST_CONFIG, DEV_CHARGER_CURRENT_CAMERA, 0);
+    cam_dev->icd = NULL;
+    DBG_INFO("[remove_device] isp detached from sensor %d", icd->devnum);
+
+}
+
+static int get_supported_mbus_param(struct owl_camera_param *cam_param)
+{
+    int flags = 0;
+    /*
+     * OWL camera interface only works in master mode
+     * and only support 8bits currently
+     */
+    if (V4L2_MBUS_PARALLEL == cam_param->bus_type) {
+        flags = V4L2_MBUS_MASTER |
+            V4L2_MBUS_HSYNC_ACTIVE_HIGH |
+            V4L2_MBUS_HSYNC_ACTIVE_LOW |
+            V4L2_MBUS_VSYNC_ACTIVE_HIGH |
+            V4L2_MBUS_VSYNC_ACTIVE_LOW |
+            V4L2_MBUS_PCLK_SAMPLE_RISING |
+            V4L2_MBUS_PCLK_SAMPLE_FALLING |
+            V4L2_MBUS_DATA_ACTIVE_HIGH |
+            SOCAM_DATAWIDTH_8;
+
+    } else if (V4L2_MBUS_CSI2 == cam_param->bus_type) {
+        flags = V4L2_MBUS_CSI2_CHANNEL_0 |
+            V4L2_MBUS_CSI2_CHANNEL_1 |
+            V4L2_MBUS_CSI2_CONTINUOUS_CLOCK |
+            V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK |
+            V4L2_MBUS_CSI2_LANES;
+    } else {
+        DBG_ERR("bus_type is not supported");
+    }
+
+    return flags;
+}
+
+
+static int select_dvp_mbus_param(struct owl_camera_dev *cdev, unsigned int common_flags)
+{
+    if ((common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)
+        && (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)) {
+        if (cdev->dvp_mbus_flags & OWL_CAMERA_HSYNC_HIGH) {
+            common_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_LOW;
+        } else {
+            common_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_HIGH;
+        }
+    }
+
+    if ((common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)
+        && (common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)) {
+        if (cdev->dvp_mbus_flags & OWL_CAMERA_VSYNC_HIGH) {
+            common_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_LOW;
+        } else {
+            common_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_HIGH;
+        }
+    }
+
+    if ((common_flags & V4L2_MBUS_DATA_ACTIVE_HIGH)
+        && (common_flags & V4L2_MBUS_DATA_ACTIVE_LOW)) {
+        if (cdev->dvp_mbus_flags & OWL_CAMERA_DATA_HIGH) {
+            common_flags &= ~V4L2_MBUS_DATA_ACTIVE_LOW;
+        } else {
+            common_flags &= ~V4L2_MBUS_DATA_ACTIVE_HIGH;
+        }
+    }
+	
+    if ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING)
+        && (common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {
+        if (cdev->dvp_mbus_flags & OWL_CAMERA_PCLK_RISING) {
+            common_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;
+        } else {
+            common_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;
+        }
+    }
+	//common_flags |= V4L2_MBUS_PCLK_SAMPLE_RISING;
+	DBG_INFO("OWL,common_flags is %x",common_flags);
+    return common_flags;
+}
+
+
+static int select_mipi_mbus_param(struct owl_camera_dev *cdev, unsigned int common_flags)
+{
+    struct soc_camera_device *icd = cdev->icd;
+    struct owl_camera_param *param = icd->host_priv;
+
+    if (common_flags & V4L2_MBUS_CSI2_1_LANE) {
+        param->lane_num = 0;    /* correspond to cis  CSI_CTRL_LANE_NUM's defined */
+    } else if (common_flags & V4L2_MBUS_CSI2_2_LANE) {
+        param->lane_num = 1;
+    } else if (common_flags & V4L2_MBUS_CSI2_3_LANE) {
+        param->lane_num = 2;
+    } else {
+        param->lane_num = 3;
+    }
+    // determined by CSI, ignore pclk polarity
+    return V4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_LOW;
+}
+
+static int owl_camera_set_bus_param(struct soc_camera_device *icd)
+{
+    struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+    struct owl_camera_dev *cam_dev = ici->priv;
+    struct owl_camera_param *cam_param = icd->host_priv;
+    struct v4l2_mbus_config cfg;
+
+    unsigned int bus_flags;
+    unsigned int common_flags;
+    int ret;
+
+
+    bus_flags = get_supported_mbus_param(cam_param);
+
+    v4l2_subdev_call(sd, video, g_mbus_config, &cfg);
+    DBG_INFO("get mbus flags host[0x%x] sensor[0x%x]", bus_flags, cfg.flags);
+
+    common_flags = soc_mbus_config_compatible(&cfg, bus_flags);
+    if (!common_flags) {
+        DBG_ERR("flags incompatible: host 0x%x, sensor 0x%x", bus_flags, cfg.flags);
+        return -EINVAL;
+    }
+
+    if (V4L2_MBUS_PARALLEL == cam_param->bus_type) {
+        common_flags = select_dvp_mbus_param(cam_dev, common_flags);
+    } else {
+        common_flags = select_mipi_mbus_param(cam_dev, common_flags);
+    }
+
+    cfg.flags = common_flags;
+    ret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);
+    if (ret < 0 && ret != -ENOIOCTLCMD) {
+        DBG_ERR("camera s_mbus_config(0x%x) returned %d", common_flags, ret);
+        return ret;
+    }
+
+    DBG_INFO("mbus flags host[0x%x] sensor[0x%x] comm[x%x]", bus_flags, cfg.flags, common_flags);
+
+    isp_set_signal_polarity(icd, common_flags);
+    isp_set_input_fmt(icd, cam_param->code);
+
+    return 0;
+}
+
+static int check_mbus_param(struct soc_camera_device *icd)
+{
+    struct owl_camera_param *cam_param = icd->host_priv;
+
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+    struct v4l2_mbus_config cfg;
+    unsigned long bus_flags, common_flags;
+    int ret;
+
+    bus_flags = get_supported_mbus_param(cam_param);
+
+    ret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);
+    if (!ret) {
+        common_flags = soc_mbus_config_compatible(&cfg, bus_flags);
+        if (!common_flags) {
+            DBG_ERR("flags incompatible: sensor[0x%x], host[0x%lx]", cfg.flags, bus_flags);
+            return -EINVAL;
+        }
+    } else if (ret == -ENOIOCTLCMD) {
+        ret = 0;
+    }
+
+    return ret;
+}
+
+static const struct soc_mbus_pixelfmt owl_camera_formats[] = {
+	{
+		.fourcc = V4L2_PIX_FMT_YUV420,
+		.name = "YUV 4:2:0 planar 12 bit",
+		.bits_per_sample = 12,
+		.packing = SOC_MBUS_PACKING_NONE,
+		.order = SOC_MBUS_ORDER_LE,
+	},
+	{    
+		.fourcc = V4L2_PIX_FMT_YVU420, 
+		.name = "YVU 4:2:0 planar 12 bit",        
+		.bits_per_sample = 12,        
+		.packing = SOC_MBUS_PACKING_NONE,        
+		.order = SOC_MBUS_ORDER_LE,    
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUV422P,
+		.name = "YUV 4:2:2 planar 16 bit",
+		.bits_per_sample = 16,
+		.packing = SOC_MBUS_PACKING_NONE,
+		.order = SOC_MBUS_ORDER_LE,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUYV,
+		.name = "YUYV 4:2:2 interleaved 16bit",
+		.bits_per_sample = 16,
+		.packing = SOC_MBUS_PACKING_NONE,
+		.order = SOC_MBUS_ORDER_LE,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_NV12,
+		.name = "YUV 4:2:0 semi-planar 12 bit",
+		.bits_per_sample = 12,
+		.packing = SOC_MBUS_PACKING_NONE,
+		.order = SOC_MBUS_ORDER_LE,
+	},
+	{        .fourcc = V4L2_PIX_FMT_NV21,        
+		 .name = "YUV 4:2:0 semi-planar 12 bit",       
+		 .bits_per_sample = 12,        
+		 .packing = SOC_MBUS_PACKING_NONE,        
+		 .order = SOC_MBUS_ORDER_LE,    
+	},  
+};
+
+
+static int client_g_rect(struct v4l2_subdev *sd, struct v4l2_rect *rect)
+{
+    struct v4l2_crop crop;
+    struct v4l2_cropcap cap;
+    int ret;
+
+    crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+    ret = v4l2_subdev_call(sd, video, g_crop, &crop);
+    if (!ret) {
+        *rect = crop.c;
+        return ret;
+    }
+
+    /* Camera driver doesn't support .g_crop(), assume default rectangle */
+    cap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+    ret = v4l2_subdev_call(sd, video, cropcap, &cap);
+    if (!ret)
+        *rect = cap.defrect;
+
+    return ret;
+}
+
+/*
+ * The common for both scaling and cropping iterative approach is:
+ * 1. try if the client can produce exactly what requested by the user
+ * 2. if (1) failed, try to double the client image until we get one big enough
+ * 3. if (2) failed, try to request the maximum image
+ */
+static int client_s_crop(struct soc_camera_device *icd, const struct v4l2_crop *crop,
+                         struct v4l2_crop *cam_crop)
+{
+	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+	const  struct v4l2_rect *rect = &crop->c;
+	struct v4l2_rect *cam_rect = &cam_crop->c;
+	struct v4l2_cropcap cap;
+	int ret;
+	unsigned int width, height;
+	unsigned int rect_left = rect->left;
+	unsigned int rect_width = rect->width;
+	unsigned int rect_top = rect->top;
+	unsigned int rect_height = rect->height;
+	ret = client_g_rect(sd, cam_rect);
+	if (ret < 0) {
+		DBG_ERR("get sensor rect failed %d", ret);
+		return ret;
+	}
+
+	/* Try to fix cropping, that camera hasn't managed to set */
+	DBG_INFO("fix camera S_CROP for %dx%d@%d:%d to %dx%d@%d:%d",
+	     cam_rect->width, cam_rect->height, cam_rect->left, cam_rect->top, 
+	     rect->width, rect->height, rect->left, rect->top);
+
+	/* We need sensor maximum rectangle */
+	ret = v4l2_subdev_call(sd, video, cropcap, &cap);
+	if (ret < 0) {
+		DBG_ERR("get sensor cropcap failed %d", ret);
+		return ret;
+	}
+
+	/* Put user requested rectangle within sensor and isp bounds */
+
+	soc_camera_limit_side(&rect_left, &rect_width, cap.bounds.left, 32,
+		          min(ISP_MAX_WIDTH, cap.bounds.width));
+	/* TO FIXUP: must be 32B-aligned if not support stride */
+
+	soc_camera_limit_side(&rect_top, &rect_height, cap.bounds.top, 1,
+		          min(ISP_MAX_HEIGHT, cap.bounds.height));
+
+	/*
+	* Popular special case - some cameras can only handle fixed sizes like
+	* QVGA, VGA,... Take care to avoid infinite loop.
+	*/
+	width = max(cam_rect->width, 2);
+	height = max(cam_rect->height, 2);
+
+	if (!ret && (cap.bounds.width >= width || cap.bounds.height >= height)
+	    && ((rect->left >= cam_rect->left) && (rect->top >= cam_rect->top)
+	    && (rect->left + rect->width <= cam_rect->left + cam_rect->width)
+	    && (rect->top + rect->height <= cam_rect->top + cam_rect->height))) {
+		return 0;
+	} else {
+		DBG_ERR("crop rect must be within sensor rect.");
+		return -ERANGE;
+	}
+}
+
+extern void bisp_updata(unsigned int *pHyaddr, int isp_ch);
+extern int af_updata(int isp_ch);
+static int ext_cmd(struct v4l2_subdev *sd, int cmd, void *args)
+{
+	int ret = 0;
+
+	switch (cmd) {
+		default:
+			printk("getctrl invalid control id %d", cmd);
+			return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int parse_sensor_flags(struct owl_camera_param *param, unsigned long flags)
+{
+    if (flags & SENSOR_FLAG_CH_MASK) {
+        param->channel = ISP_CHANNEL_0;
+    } else {
+        param->channel = ISP_CHANNEL_1;
+    }
+
+    if (flags & SENSOR_FLAG_INTF_MASK) {
+        param->ext_cmd = NULL;
+        param->bus_type = V4L2_MBUS_PARALLEL;
+    } else {
+        param->ext_cmd = ext_cmd;
+        param->bus_type = V4L2_MBUS_CSI2;
+    }
+
+    if (flags & SENSOR_FLAG_DATA_MASK) {
+        param->data_type = SENSOR_DATA_TYPE_YUV;
+    } else {
+        param->data_type = SENSOR_DATA_TYPE_RAW;
+    }
+    DBG_INFO("%s: channel[%d], bus[%s], data[%s]", __func__, param->channel,
+             V4L2_MBUS_PARALLEL == param->bus_type ? "dvp" : "mipi",
+             SENSOR_DATA_TYPE_YUV == param->data_type ? "yuv" : "raw");
+
+    return 0;
+}
+
+static int owl_camera_get_formats(struct soc_camera_device *icd, unsigned int idx,
+                                     struct soc_camera_format_xlate *xlate)
+{
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+    struct owl_camera_param *cam_param;
+    int formats = 0, ret, k, n;
+    enum v4l2_mbus_pixelcode code;
+    const struct soc_mbus_pixelfmt *fmt;
+    struct device *pdev = icd->pdev;
+    struct soc_camera_link *module_link = pdev->platform_data;
+    struct module_info *module_info = module_link->priv;
+
+
+    ret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);
+    if (ret < 0) {
+        /* No more formats */
+        DBG_ERR("No more formats, %s, %d", __func__, __LINE__);
+        return ret;
+    }
+
+    fmt = soc_mbus_get_fmtdesc(code);
+    if (!fmt) {
+        DBG_ERR("invalid format code #%u: %d", idx, code);
+        return -EINVAL;
+    }
+
+    if (!icd->host_priv) {
+        struct v4l2_mbus_framefmt mf;
+        struct v4l2_rect rect;
+
+        /* Cache current client geometry */
+        ret = client_g_rect(sd, &rect);
+        if (ret < 0)
+            return ret;
+
+        /* First time */
+        ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
+        if (ret < 0) {
+            DBG_ERR("failed to g_mbus_fmt.");
+            return ret;
+        }
+
+        DBG_INFO("isp get sensor's default fmt %ux%u", mf.width, mf.height);
+
+        cam_param = kzalloc(sizeof(*cam_param), GFP_KERNEL);
+        if (NULL == cam_param) {
+            DBG_ERR("alloc camera_param struct failed");
+            return -ENOMEM;
+        }
+
+        /* We are called with current camera crop, initialise subrect with it */
+        cam_param->rect = rect;
+        cam_param->subrect = rect;
+
+        cam_param->width = mf.width;
+        cam_param->height = mf.height;
+        cam_param->isp_left = 0;
+        cam_param->isp_top = 0;
+        cam_param->flags = module_info->flags;
+        cam_param->skip_frames = 0;
+        icd->host_priv = cam_param;
+
+        parse_sensor_flags(cam_param, module_info->flags);
+
+        /* This also checks support for the requested bits-per-sample */
+        ret = check_mbus_param(icd);
+        if (ret < 0) {
+            kfree(cam_param);
+            icd->host_priv = NULL;
+            DBG_ERR("no right formats, %s, %d", __func__, __LINE__);
+            return ret;
+        }
+    } else {
+        cam_param = icd->host_priv;
+    }
+
+    /* Beginning of a pass */
+    if (!idx) {
+        cam_param->extra_fmt = NULL;
+    }
+
+    switch (code) {
+    case V4L2_MBUS_FMT_UYVY8_2X8:
+    case V4L2_MBUS_FMT_SGBRG8_1X8:
+    case V4L2_MBUS_FMT_SBGGR8_1X8:
+    case V4L2_MBUS_FMT_SRGGB8_1X8:
+    case V4L2_MBUS_FMT_SGRBG8_1X8:{
+            if (cam_param->extra_fmt)
+                break;
+
+            /*
+             * Our case is simple so far: for any of the above four camera
+             * formats we add all our four synthesized NV* formats, so,
+             * just marking the device with a single flag suffices. If
+             * the format generation rules are more complex, you would have
+             * to actually hang your already added / counted formats onto
+             * the host_priv pointer and check whether the format you're
+             * going to add now is already there.
+             */
+            cam_param->extra_fmt = owl_camera_formats;
+
+            n = ARRAY_SIZE(owl_camera_formats);
+            formats += n;
+            DBG_INFO("isp provide output format:");
+            for (k = 0; xlate && k < n; k++) {
+                xlate->host_fmt = &owl_camera_formats[k];
+                xlate->code = code;
+                xlate++;
+                DBG_INFO("[%d].code-%#x, %s", k, code, owl_camera_formats[k].name);
+            }
+            break;
+        }
+    default:
+        //DBG_INFO("code:0x%x is not supported", code);
+        return 0;
+
+    }
+
+    /* Generic pass-through */
+    formats++;
+    if (xlate) {
+        xlate->host_fmt = fmt;
+        xlate->code = code;
+        DBG_INFO("xlate->code = %#x", xlate->code);
+        xlate++;
+    }
+
+    return formats;
+}
+
+static void owl_camera_put_formats(struct soc_camera_device *icd)
+{
+    if (icd->host_priv) {
+        kfree(icd->host_priv);
+    }
+    icd->host_priv = NULL;
+}
+
+
+static int check_frame_range(u32 width, u32 height)
+{
+    /* limit to owl_camera hardware capabilities */
+    return height < 1 || height > ISP_MAX_HEIGHT || width < 32
+        || width > ISP_MAX_WIDTH /* || (width % 32) */ ;
+}
+
+static int owl_camera_cropcap(struct soc_camera_device *icd, struct v4l2_cropcap *a)
+{
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+    struct v4l2_rect *rect = &a->defrect;
+    int ret;
+
+    ret = v4l2_subdev_call(sd, video, cropcap, a);
+    if (ret < 0) {
+        DBG_ERR("failed to get camera cropcap");
+        return ret;
+    }
+
+    /* Put user requested rectangle within sensor and isp bounds */
+    if (rect->width > ISP_MAX_WIDTH) {
+        rect->width = ISP_MAX_WIDTH;
+    }
+    rect->width = rect->width - (rect->width % 32);
+
+    if (rect->height > ISP_MAX_HEIGHT) {
+        rect->height = ISP_MAX_HEIGHT;
+    }
+
+    return 0;
+}
+
+/*
+ * OWL_CAMERA can not crop or scale for YUV,but can crop for RawData.
+ * And we don't want to waste bandwidth and kill the
+ * framerate by always requesting the maximum image from the client.
+ */
+static int owl_camera_set_crop(struct soc_camera_device *icd, const struct v4l2_crop *a)
+{
+    const struct v4l2_rect *rect = &a->c;
+    struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
+    struct owl_camera_dev *cam_dev = ici->priv;
+    struct owl_camera_param *cam_param = icd->host_priv;
+    struct v4l2_crop cam_crop;
+    struct v4l2_rect *cam_rect = &cam_crop.c;
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+    struct v4l2_mbus_framefmt mf;
+    unsigned long flags;
+    int ret;
+
+    DBG_INFO("S_CROP(%ux%u@%u:%u)", rect->width, rect->height, rect->left, rect->top);
+
+    //      /* During camera cropping its output window can change too, stop OWL_CAMERA */
+    //      ISP_ENABLE = owl_camera_capture_save_reset(cam_dev);
+
+    /* For UYVY/Bayer Raw input data */
+    /* 1. - 2. Apply iterative camera S_CROP for new input window. */
+    ret = client_s_crop(icd, a, &cam_crop);
+    if (ret < 0)
+        return ret;
+    DBG_INFO("1-2: camera cropped to %ux%u@%u:%u",
+             cam_rect->width, cam_rect->height, cam_rect->left, cam_rect->top);
+
+    /* On success cam_crop contains current camera crop */
+
+    /* 3. Retrieve camera output window */
+    ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
+    if (ret < 0) {
+        DBG_ERR("failed to g_mbus_fmt.");
+        return ret;
+    }
+
+    if (check_frame_range(mf.width, mf.height)) {
+        DBG_ERR("inconsistent state. Use S_FMT to repair");
+        return -EINVAL;
+    }
+
+    spin_lock_irqsave(&cam_dev->lock, flags);
+
+    /* Cache camera output window */
+    cam_param->width = mf.width;
+    cam_param->height = mf.height;
+
+    icd->user_width = rect->width;
+    icd->user_height = rect->height;
+    cam_param->isp_left = rect->left - cam_rect->left;
+    cam_param->isp_top = rect->top - cam_rect->top;
+
+    /* 4. Use OWL_CAMERA cropping to crop to the new window. */
+
+    cam_param->rect = *cam_rect;
+    cam_param->subrect = *rect;
+
+    spin_unlock_irqrestore(&cam_dev->lock, flags);
+
+    DBG_INFO("4: isp cropped to %ux%u@%u:%u", icd->user_width, 
+             icd->user_height, cam_param->isp_left, cam_param->isp_top);
+
+    return ret;
+}
+
+static int owl_camera_get_crop(struct soc_camera_device *icd, struct v4l2_crop *a)
+{
+    struct owl_camera_param *cam_param = icd->host_priv;
+
+    a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    a->c = cam_param->subrect;
+    return 0;
+}
+
+
+static int owl_camera_set_fmt(struct soc_camera_device *icd, struct v4l2_format *f)
+{
+    //struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
+    //struct owl_camera_dev *cam_dev = ici->priv;
+    struct owl_camera_param *cam_param = icd->host_priv;
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+    const struct soc_camera_format_xlate *xlate = NULL;
+    struct v4l2_pix_format *pix = &f->fmt.pix;
+    struct v4l2_mbus_framefmt mf;
+    __u32 pixfmt = pix->pixelformat;
+    unsigned int skip_frames_num;
+    int ret;
+
+
+    DBG_INFO("%s, S_FMT(pix=0x%x, %ux%u)", __func__, pixfmt, pix->width, pix->height);
+
+    /* sensor may skip different some frames */
+    ret = v4l2_subdev_call(sd, sensor, g_skip_frames, &skip_frames_num);
+    if (ret < 0) {
+        skip_frames_num = 0;
+    }
+    cam_param->skip_frames = skip_frames_num;
+
+    xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
+    if (!xlate) {
+        DBG_INFO("format %x not found", pixfmt);
+        return -EINVAL;
+    }
+
+    DBG_INFO("set format %dx%d", pix->width, pix->height);
+
+    mf.width = pix->width;
+    mf.height = pix->height;
+    mf.field = pix->field;
+    mf.colorspace = pix->colorspace;
+    mf.code = xlate->code;
+
+    ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
+    if (ret < 0) {
+        DBG_ERR("failed to configure for format %x", pix->pixelformat);
+        return ret;
+    }
+
+    if (mf.code != xlate->code) {
+        DBG_ERR("wrong code: mf.code = 0x%x, xlate->code = 0x%x", mf.code, xlate->code);
+        return -EINVAL;
+    }
+
+
+    if (check_frame_range(mf.width, mf.height)) {
+        DBG_ERR("sensor produced an unsupported frame %dx%d", mf.width, mf.height);
+        return -EINVAL;
+    }
+
+    cam_param->isp_left = 0;
+    cam_param->isp_top = 0;
+    cam_param->width = mf.width;
+    cam_param->height = mf.height;
+    cam_param->code = xlate->code;
+
+    pix->bytesperline = soc_mbus_bytes_per_line(pix->width, xlate->host_fmt);
+    if (pix->bytesperline < 0) {
+        DBG_ERR("bytesperline %d not correct.", pix->bytesperline);
+        return pix->bytesperline;
+    }
+    pix->sizeimage = pix->height * pix->bytesperline;
+    pix->width = mf.width;
+    pix->height = mf.height;
+    pix->field = mf.field;
+    pix->colorspace = mf.colorspace;
+
+    icd->current_fmt = xlate;
+    icd->user_width = cam_param->width;
+    icd->user_height = cam_param->height;
+
+    DBG_INFO("sensor set %dx%d, code = %#x", pix->width, pix->height, cam_param->code);
+
+    isp_set_rect(icd);
+    ret = isp_set_output_fmt(icd, icd->current_fmt->host_fmt->fourcc);
+    if(ret)
+        return ret;
+
+    DBG_INFO("set output data format %s", icd->current_fmt->host_fmt->name);
+
+    return 0;
+}
+
+static int owl_camera_try_fmt(struct soc_camera_device *icd, struct v4l2_format *f)
+{
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+    const struct soc_camera_format_xlate *xlate;
+    struct v4l2_pix_format *pix = &f->fmt.pix;
+    struct v4l2_mbus_framefmt mf;
+    __u32 pixfmt = pix->pixelformat;
+    int ret;
+    xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
+    if (pixfmt && !xlate) {
+        DBG_ERR("format %x not found", pixfmt);
+        return -EINVAL;
+    }
+
+    /*
+     * Limit to OWL_CAMERA hardware capabilities.  YUV422P planar format requires
+     * images size to be a multiple of 16 bytes.  If not, zeros will be
+     * inserted between Y and U planes, and U and V planes, which violates
+     * the YUV422P standard.
+     */
+    v4l_bound_align_image(&pix->width, 32, ISP_MAX_WIDTH, 5,
+                          &pix->height, 1, ISP_MAX_HEIGHT, 0,
+                          pixfmt == V4L2_PIX_FMT_YUV422P ? 4 : 0);
+
+    pix->bytesperline = soc_mbus_bytes_per_line(pix->width, xlate->host_fmt);
+    if (pix->bytesperline < 0) {
+        DBG_ERR("bytesperline %d not correct.", pix->bytesperline);
+        return pix->bytesperline;
+    }
+    pix->sizeimage = pix->height * pix->bytesperline;
+
+    /* limit to sensor capabilities */
+    mf.width = pix->width;
+    mf.height = pix->height;
+    mf.field = pix->field;
+    mf.colorspace = pix->colorspace;
+    mf.code = xlate->code;
+
+    DBG_INFO("try %dx%d", mf.width, mf.height);
+
+    ret = v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);
+    if (ret < 0) {
+        return ret;
+    }
+
+    pix->width = mf.width;
+    pix->height = mf.height;
+    //      pix->field      = mf.field;
+    pix->colorspace = mf.colorspace;
+
+    switch (mf.field) {
+    case V4L2_FIELD_ANY:
+    case V4L2_FIELD_NONE:
+        pix->field = V4L2_FIELD_NONE;
+        break;
+    default:
+        DBG_ERR("field type %d unsupported.", mf.field);
+        ret = -EINVAL;
+    }
+
+    return ret;
+}
+
+static int owl_camera_reqbufs(struct soc_camera_device *icd, struct v4l2_requestbuffers *p)
+{
+    int i;
+
+    /*
+     * This is for locking debugging only. I removed spinlocks and now I
+     * check whether .prepare is ever called on a linked buffer, or whether
+     * a dma IRQ can occur for an in-work or unlinked buffer. Until now
+     * it hadn't triggered
+     */
+    for (i = 0; i < p->count; i++) {
+        struct owl_camera_buffer *buf;
+
+        buf = to_isp_buf(icd->vb2_vidq.bufs[i]);
+        INIT_LIST_HEAD(&buf->queue);
+    }
+
+    return 0;
+}
+
+static unsigned int owl_camera_poll(struct file *file, poll_table * pt)
+{
+    struct soc_camera_device *icd = file->private_data;
+
+    return vb2_poll(&icd->vb2_vidq, file, pt);
+}
+
+static int owl_camera_querycap(struct soc_camera_host *ici, struct v4l2_capability *cap)
+{
+    /* cap->name is set by the firendly caller:-> */
+    strlcpy(cap->card, "OWL Camera", sizeof(cap->card));
+    cap->version = KERNEL_VERSION(0, 0, 1);
+    cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+
+    return 0;
+}
+
+
+struct vb2_dc_buf {
+	struct device			*dev;
+	void				*vaddr;
+	unsigned long			size;
+	dma_addr_t			dma_addr;
+	enum dma_data_direction		dma_dir;
+	struct sg_table			*dma_sgt;
+
+	/* MMAP related */
+	struct vb2_vmarea_handler	handler;
+	atomic_t			refcount;
+	struct sg_table			*sgt_base;
+
+	/* USERPTR related */
+	struct vm_area_struct		*vma;
+
+	/* DMABUF related */
+	struct dma_buf_attachment	*db_attach;
+};
+static void *owl_vb2_get_userptr(void *alloc_ctx, unsigned long vaddr,
+	unsigned long size, int write)
+{
+	struct vb2_dc_buf  *buf;
+	int ret = 0;
+	unsigned long pfn;
+	void* now_vaddr=NULL;
+	
+	buf = kzalloc(sizeof *buf, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	pfn =vaddr>>PAGE_SHIFT;
+	if (pfn_valid(pfn)) {
+		
+		now_vaddr = phys_to_virt(pfn << PAGE_SHIFT);
+	} else {
+		
+		now_vaddr = ioremap(pfn << PAGE_SHIFT, PAGE_SIZE);
+	}
+	if (!now_vaddr)
+		ret = -ENOMEM;
+	if (ret) {
+		printk(KERN_ERR "Failed acquiring vaddr 0x%08lx\n",
+				(unsigned long)vaddr);
+		kfree(buf);
+		return ERR_PTR(ret);
+	}
+	buf->size = size;
+	buf->vaddr = now_vaddr;
+	buf->dma_addr = vaddr;
+	buf->vma = NULL;
+
+	return buf;
+}
+
+static void owl_vb2_put_userptr(void *mem_priv)
+{
+	struct vb2_dc_buf *buf = mem_priv;
+	void* vaddr;
+	unsigned long pfn;
+
+	if (!buf)
+		return;
+	pfn = buf->dma_addr>>PAGE_SHIFT;
+	vaddr = buf->vaddr;
+	if (!pfn_valid(pfn))
+		iounmap(vaddr);
+	kfree(buf);
+}
+
+struct vb2_mem_ops owl_dma_contig_memops;
+
+
+static int owl_camera_init_videobuf(struct vb2_queue *q, struct soc_camera_device *icd)
+{
+	DBG_INFO("%s, %d", __func__, __LINE__);
+
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_USERPTR;
+	q->drv_priv = icd;
+	q->ops = &owl_isp_videobuf_ops;
+	memcpy(&owl_dma_contig_memops,&vb2_dma_contig_memops,sizeof(struct vb2_mem_ops));
+	owl_dma_contig_memops.get_userptr	= owl_vb2_get_userptr;
+	owl_dma_contig_memops.put_userptr   = owl_vb2_put_userptr;
+	q->mem_ops = &owl_dma_contig_memops;
+	q->buf_struct_size = sizeof(struct owl_camera_buffer);
+	q->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+
+	return (vb2_queue_init(q));
+}
+
+
+static int owl_camera_get_parm(struct soc_camera_device *icd, struct v4l2_streamparm *parm)
+{
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+
+    return v4l2_subdev_call(sd, video, g_parm, parm);
+}
+
+static int owl_camera_set_parm(struct soc_camera_device *icd, struct v4l2_streamparm *parm)
+{
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+
+    return v4l2_subdev_call(sd, video, s_parm, parm);
+}
+
+static int owl_camera_suspend(struct device *dev)
+{
+	// usually when system suspend, it will close camera, so no need process more
+	struct soc_camera_host *ici = to_soc_camera_host(dev);
+	struct owl_camera_dev *cam_dev = container_of(ici, struct owl_camera_dev,soc_host);
+
+	disable_irq(cam_dev->irq);
+	module_clk_disable(MOD_ID_BISP);
+
+
+	isp_regulator_disable(&cam_dev->ir);
+
+	DBG_INFO("enter camera suspend...");
+
+	return 0;
+}
+static void isp_regulator_enable_resume(struct isp_regulators *ir)
+{
+	int ret = 0;
+	if (ir->dvdd.regul) {
+		ret = regulator_enable(ir->dvdd.regul);
+	}
+
+	if (ir->avdd_use_gpio) {
+		struct dts_gpio *dg = &ir->avdd.gpio;
+		gpio_direction_output(dg->num, dg->active_level);
+	} else {
+		struct dts_regulator *dr = &ir->avdd.regul;
+		if (dr->regul) {
+			ret = regulator_enable(dr->regul);
+		}
+	}
+
+	if (ir->dvdd_use_gpio) {
+		struct dts_gpio *dvdd_dg = &ir->dvdd_gpio;
+		gpio_direction_output(dvdd_dg->num, dvdd_dg->active_level);
+	}
+}
+
+static int owl_camera_resume(struct device *dev)
+{
+	struct soc_camera_host *ici = to_soc_camera_host(dev);
+	struct owl_camera_dev *cam_dev = container_of(ici, struct owl_camera_dev,soc_host);
+	isp_regulator_enable_resume(&cam_dev->ir);
+	module_reset(MODULE_RST_BISP);
+	module_clk_enable(MOD_ID_BISP);
+	enable_irq(cam_dev->irq);
+	DBG_INFO("enter camera resume...");
+
+	return 0;
+}
+
+int owl_camera_enum_fsizes(struct soc_camera_device *icd, struct v4l2_frmsizeenum *fsize)
+{
+    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+
+    return v4l2_subdev_call(sd, video, enum_framesizes, fsize);
+}
+
+
+static struct soc_camera_host_ops owl_soc_camera_host_ops = {
+    .owner = THIS_MODULE,
+    .add = owl_camera_add_device,
+    .remove = owl_camera_remove_device,
+    .get_formats = owl_camera_get_formats,
+    .put_formats = owl_camera_put_formats,
+    .cropcap = owl_camera_cropcap,
+    .get_crop = owl_camera_get_crop,
+    .set_crop = owl_camera_set_crop,
+    .set_livecrop = owl_camera_set_crop,
+    .set_fmt = owl_camera_set_fmt,
+    .try_fmt = owl_camera_try_fmt,
+    .set_parm = owl_camera_set_parm,
+    .get_parm = owl_camera_get_parm,
+    .reqbufs = owl_camera_reqbufs,
+    .poll = owl_camera_poll,
+    .querycap = owl_camera_querycap,
+    .set_bus_param = owl_camera_set_bus_param,
+    .init_videobuf2 = owl_camera_init_videobuf,
+    .enum_framesizes = owl_camera_enum_fsizes,
+};
+
+
+static inline void sensor_pwd_info_init(struct sensor_pwd_info *spinfo)
+{
+    spinfo->flag = 0;
+    spinfo->gpio_rear.num = -1;
+    spinfo->gpio_front.num = -1;
+    spinfo->gpio_reset.num = -1;
+    spinfo->ch_clk[ISP_CHANNEL_0] = NULL;
+    spinfo->ch_clk[ISP_CHANNEL_1] = NULL;
+}
+
+static inline void isp_regulators_init(struct isp_regulators *ir)
+{
+    struct dts_regulator *dr = &ir->avdd.regul;
+
+    dr->regul = NULL;
+    ir->avdd_use_gpio = 0;
+    ir->dvdd_use_gpio = 0;
+    ir->dvdd.regul = NULL;
+}
+
+static int camera_clock_init(struct owl_camera_dev *cdev)
+{
+    struct sensor_pwd_info *spinfo = &cdev->spinfo;
+    struct clk *tmp;
+    int err;
+
+    tmp = clk_get(NULL, CLKNAME_BISP_CLK);
+    if (IS_ERR(tmp)) {
+        err = PTR_ERR(tmp);
+        DBG_ERR("get isp clock error%d", err);
+        goto isp_clk_err;
+    }
+    cdev->isp_clk = tmp;
+
+    tmp = clk_get(NULL, CLKNAME_CSI_CLK);
+    if (IS_ERR(tmp)) {
+        err = PTR_ERR(tmp);
+        DBG_ERR("get csi clock error%d", err);
+        goto csi_err;
+    }
+    cdev->csi_clk = tmp;
+
+    tmp = clk_get(NULL, CLKNAME_SENSOR_CLKOUT0);
+    if (IS_ERR(tmp)) {
+        err = PTR_ERR(tmp);
+        DBG_ERR("get isp-channel-0 clock error%d", err);
+        goto ch0_err;
+    }
+    cdev->ch_clk[ISP_CHANNEL_0] = tmp;
+
+    tmp = clk_get(NULL, CLKNAME_SENSOR_CLKOUT1);
+    if (IS_ERR(tmp)) {
+        err = PTR_ERR(tmp);
+        DBG_ERR("get isp-channel-1 clock error%d", err);
+        goto ch1_err;
+    }
+    cdev->ch_clk[ISP_CHANNEL_1] = tmp;
+    spinfo->ch_clk[ISP_CHANNEL_0] = cdev->ch_clk[ISP_CHANNEL_0];
+    spinfo->ch_clk[ISP_CHANNEL_1] = cdev->ch_clk[ISP_CHANNEL_1];
+
+    return 0;
+
+  ch1_err:
+    clk_put(cdev->ch_clk[ISP_CHANNEL_0]);
+  ch0_err:
+    clk_put(cdev->csi_clk);
+  csi_err:
+    clk_put(cdev->isp_clk);
+  isp_clk_err:
+    return err;
+}
+
+
+static void camera_clock_exit(struct owl_camera_dev *cdev)
+{
+    clk_put(cdev->isp_clk);
+    clk_put(cdev->csi_clk);
+    clk_put(cdev->ch_clk[ISP_CHANNEL_0]);
+    clk_put(cdev->ch_clk[ISP_CHANNEL_1]);
+}
+
+static int gpio_init(struct device_node *fdt_node,
+                     const char *gpio_name, struct dts_gpio *gpio, bool active)
+{
+    enum of_gpio_flags flags;
+
+    if (!of_find_property(fdt_node, gpio_name, NULL)) {
+        DBG_ERR("<isp>no config gpios");
+        goto fail;
+    }
+    gpio->num = of_get_named_gpio_flags(fdt_node, gpio_name, 0, &flags);
+    gpio->active_level = !(flags & OF_GPIO_ACTIVE_LOW);
+
+    DBG_INFO("%s: num-%d, active-%s", gpio_name, gpio->num, gpio->active_level ? "high" : "low");
+
+    if (gpio_request(gpio->num, gpio_name)) {
+        DBG_ERR("<isp>fail to request gpio [%d]", gpio->num);
+        gpio->num = -1;
+        goto fail;
+    }
+    if (active) {
+        gpio_direction_output(gpio->num, gpio->active_level);
+    } else {
+        gpio_direction_output(gpio->num, !gpio->active_level);
+    }
+
+    DBG_INFO("gpio value: 0x%x", gpio_get_value(gpio->num));
+
+    return 0;
+  fail:
+    return -1;
+}
+
+static void gpio_exit(struct dts_gpio *gpio, bool active)
+{
+    if (gpio->num >= 0) {
+        if (active) {
+            gpio_set_value(gpio->num, gpio->active_level);
+        } else {
+            gpio_set_value(gpio->num, !gpio->active_level);
+        }
+
+        gpio_free(gpio->num);
+    }
+}
+
+static int regulator_init(struct device_node *fdt_node,
+                          const char *regul_name, const char *scope_name,
+                          struct dts_regulator *dts_regul)
+{
+    unsigned int scope[2];
+    const char *regul = NULL;
+
+    if (of_property_read_string(fdt_node, regul_name, &regul)) {
+        DBG_ERR("<isp> don't config %s", regul_name);
+        goto fail;
+    }
+    DBG_INFO("%s", regul ? regul : "NULL");
+
+    if (of_property_read_u32_array(fdt_node, scope_name, scope, 2)) {
+        printk("<isp> fail to get %s", scope_name);
+        goto fail;
+    }
+    DBG_INFO("<isp>: min-%d, max-%d", scope[0], scope[1]);
+    dts_regul->min = scope[0];
+    dts_regul->max = scope[1];
+
+    dts_regul->regul = regulator_get(NULL, regul);
+    if (IS_ERR(dts_regul->regul)) {
+        dts_regul->regul = NULL;
+        DBG_ERR("<isp> get regulator failed");
+        goto fail;
+    }
+
+    regulator_set_voltage(dts_regul->regul, dts_regul->min, dts_regul->max);
+    //regulator_enable(dts_regul->regul);
+    //mdelay(5);
+    return 0;
+
+  fail:
+    return -1;
+
+}
+
+static inline void regulator_exit(struct dts_regulator *dr)
+{
+    //regulator_disable(dr->regul);
+    regulator_put(dr->regul);
+    dr->regul = NULL;
+}
+
+static int isp_regulator_init(struct device_node *fdt_node, struct isp_regulators *ir)
+{
+	const char *avdd_src = NULL;
+
+/*DVDD*/
+	struct dts_gpio *dvdd_gpio = &ir->dvdd_gpio;
+	if (!gpio_init(fdt_node, "dvdd-gpios", dvdd_gpio, 0))/* poweroff */
+		ir->dvdd_use_gpio = 1;
+	else
+		ir->dvdd_use_gpio = 0;
+
+	if (regulator_init(fdt_node, "dvdd-regulator",
+				"dvdd-regulator-scope", &ir->dvdd))
+		goto fail;
+
+/*AVDD*/
+	if (of_property_read_string(fdt_node, "avdd-src", &avdd_src)) {
+		DBG_ERR("<isp> get avdd-src faild");
+		goto fail;
+	}
+
+	if (!strcmp(avdd_src, "regulator")) {
+		DBG_INFO("avdd using regulator: ");
+		ir->avdd_use_gpio = 0;
+
+		if (regulator_init(fdt_node, "avdd-regulator",
+					"avdd-regulator-scope", &ir->avdd.regul))
+			goto free_dvdd;
+	} else if (!strcmp(avdd_src, "gpio")) {
+		struct dts_gpio *gpio = &ir->avdd.gpio;
+		ir->avdd_use_gpio = 1;
+
+
+	gpio_init(fdt_node, "avdd-gpios", gpio, 0);
+	
+		DBG_INFO("set - avdd gpio value: 0x%x", gpio_get_value(gpio->num));
+	} else
+		DBG_INFO("needn't operate avdd manually");
+
+	return 0;
+
+free_dvdd:
+	regulator_exit(&ir->dvdd);
+fail:
+	return -1;
+}
+
+static void isp_regulator_exit(struct isp_regulators *ir)
+{
+    if (ir->dvdd_use_gpio)
+        gpio_exit(&ir->dvdd_gpio, 0);
+
+    if (ir->dvdd.regul) {
+        regulator_exit(&ir->dvdd);
+    }
+
+    if (ir->avdd_use_gpio) {
+        gpio_exit(&ir->avdd.gpio, 0);
+    } else {
+        struct dts_regulator *dr = &ir->avdd.regul;
+
+        if (dr->regul) {
+            regulator_exit(dr);
+        }
+    }
+}
+
+static void isp_regulator_enable(struct isp_regulators *ir)
+{
+	int ret = 0;
+	if (ir->dvdd.regul) {
+		ret = regulator_enable(ir->dvdd.regul);
+		mdelay(5);
+	}
+
+	if (ir->avdd_use_gpio) {
+		struct dts_gpio *dg = &ir->avdd.gpio;
+		gpio_direction_output(dg->num, dg->active_level);
+	} else {
+		struct dts_regulator *dr = &ir->avdd.regul;
+		if (dr->regul) {
+			ret = regulator_enable(dr->regul);
+			mdelay(5);
+		}
+	}
+
+	if (ir->dvdd_use_gpio) {
+		struct dts_gpio *dvdd_dg = &ir->dvdd_gpio;
+		gpio_direction_output(dvdd_dg->num, dvdd_dg->active_level);
+	}
+}
+
+static void isp_regulator_disable(struct isp_regulators *ir)
+{
+    if (ir->dvdd_use_gpio) {
+        struct dts_gpio *dvdd_dg = &ir->dvdd_gpio;
+        gpio_direction_output(dvdd_dg->num, !dvdd_dg->active_level);
+    }
+	
+    if (ir->dvdd.regul) {
+        regulator_disable(ir->dvdd.regul);
+    }
+
+    if (ir->avdd_use_gpio) {
+        struct dts_gpio *dg = &ir->avdd.gpio;
+        gpio_direction_output(dg->num, !dg->active_level);
+    } else {
+        struct dts_regulator *dr = &ir->avdd.regul;
+        if (dr->regul) {
+            regulator_disable(dr->regul);
+        }
+    }
+}
+
+static int isp_gpio_init(struct device_node *fdt_node, struct sensor_pwd_info *spinfo)
+{
+    const char *sensors = NULL;
+
+	
+    if (gpio_init(fdt_node, "reset-gpios", &spinfo->gpio_reset, 0)) {
+        goto fail;
+    }
+
+    if (of_property_read_string(fdt_node, "sensors", &sensors)) {
+        DBG_ERR("<isp> get sensors faild");
+        goto free_reset;
+    }
+
+    if (!strcmp(sensors, "front")) {
+        // default is power-down
+        if (gpio_init(fdt_node, "pwdn-front-gpios", &spinfo->gpio_front, 1)) {
+            goto free_reset;
+        }
+        spinfo->flag = SENSOR_FRONT;
+    } else if (!strcmp(sensors, "rear")) {
+        if (gpio_init(fdt_node, "pwdn-rear-gpios", &spinfo->gpio_rear, 1)) {
+            goto free_reset;
+        }
+        spinfo->flag = SENSOR_REAR;
+    } else if (!strcmp(sensors, "dual")) {
+        if (gpio_init(fdt_node, "pwdn-front-gpios", &spinfo->gpio_front, 1)) {
+            goto free_reset;
+        }
+        if (gpio_init(fdt_node, "pwdn-rear-gpios", &spinfo->gpio_rear, 1)) {
+            gpio_exit(&spinfo->gpio_front, 1);
+            goto free_reset;
+        }
+        spinfo->flag = SENSOR_DUAL;
+    } else {
+        DBG_ERR("sensors of dts is wrong");
+        goto free_reset;
+    }
+    return 0;
+
+  free_reset:
+    gpio_exit(&spinfo->gpio_reset, 0);
+  fail:
+    return -1;
+}
+
+static void isp_gpio_exit(struct sensor_pwd_info *spinfo)
+{
+    // only free valid gpio, so no need to check its existence.
+    gpio_exit(&spinfo->gpio_front, 1);
+    gpio_exit(&spinfo->gpio_rear, 1);
+    gpio_exit(&spinfo->gpio_reset, 0);
+}
+
+
+static struct owl_camera_dev *cam_dev_alloc(struct device *dev, struct device_node *dn)
+{
+    struct owl_camera_dev *cdev;
+
+
+    cdev = devm_kzalloc(dev,sizeof(struct owl_camera_dev), GFP_ATOMIC);
+    if (NULL == cdev) {
+        DBG_ERR("alloc owl camera device failed");
+        goto ealloc;
+    }
+
+    cdev->alloc_ctx = vb2_dma_contig_init_ctx(dev);
+    if (IS_ERR(cdev->alloc_ctx)) {
+        goto ealloc;
+    }
+    cdev->started = DEV_CLOSE;
+
+    INIT_LIST_HEAD(&cdev->capture);
+    spin_lock_init(&cdev->lock);
+    init_completion(&cdev->wait_stop);
+    cdev->dvp_mbus_flags = DEFAULT_MBUS_PARAM_DVP;
+    cdev->cur_frm = NULL;
+    cdev->prev_frm = NULL;
+    cdev->mfp = NULL;
+    cdev->isp_clk = NULL;
+    cdev->csi_clk = NULL;
+    cdev->ch_clk[ISP_CHANNEL_0] = NULL;
+    cdev->ch_clk[ISP_CHANNEL_1] = NULL;
+
+    sensor_pwd_info_init(&cdev->spinfo);
+    isp_regulators_init(&cdev->ir);
+    if (camera_clock_init(cdev)) {
+        DBG_ERR("camera clocks init error");
+        goto clk_err;
+    }
+
+    if (isp_gpio_init(dn, &cdev->spinfo)) {
+        DBG_ERR("gpio init error");
+        goto egpio;
+    }
+
+    /* set digital core and analog voltage for sensor */
+    if (isp_regulator_init(dn, &cdev->ir)) {
+        DBG_ERR("regulator init error");
+        goto eregul;
+    }
+
+
+    return cdev;
+
+  eregul:
+    isp_gpio_exit(&cdev->spinfo);
+  egpio:
+    camera_clock_exit(cdev);
+  clk_err:
+    vb2_dma_contig_cleanup_ctx(cdev->alloc_ctx);
+  ealloc:
+    return NULL;
+}
+
+static void cam_dev_free(struct owl_camera_dev *cdev)
+{
+    isp_regulator_exit(&cdev->ir);
+    isp_gpio_exit(&cdev->spinfo);
+    camera_clock_exit(cdev);
+    vb2_dma_contig_cleanup_ctx(cdev->alloc_ctx);
+
+}
+
+static int owl_camera_host_probe(struct platform_device *pdev)
+{
+	
+    struct device_node *dn = pdev->dev.of_node;
+    struct owl_camera_dev *cam_dev;
+    struct soc_camera_host *soc_host;
+    unsigned int irq;
+    int err = 0;
+    const char *owl_camera_status;
+
+    err = of_property_read_string(dn, "status", &owl_camera_status);
+    if (err == 0 && strcmp(owl_camera_status, "okay") != 0) {
+        printk(KERN_DEBUG"%s owl_camera_status disabled by DTS in %s\n",__func__,dn->full_name);
+        return -ENODEV;
+    }
+	
+	err = owl_camera_hw_call(hw_adapter, hw_adapter_init,pdev);
+	
+    pdev->id = of_alias_get_id(dn, "isp");
+    if (pdev->id < 0) {
+        dev_err(&pdev->dev, "failed to get alias id, errno %d", pdev->id);
+        goto eid;
+    }
+
+    DBG_INFO("pdev name: %s", pdev->name);
+
+    cam_dev = cam_dev_alloc(&pdev->dev, dn);
+    if (NULL == cam_dev) {
+        dev_err(&pdev->dev, "owl_camera_dev alloc failed");
+        goto eid;
+    }
+
+    attach_sensor_pwd_info(&pdev->dev, &cam_dev->spinfo, pdev->id);
+
+    irq = platform_get_irq(pdev, 0);
+    if (!irq) {
+        dev_err(&pdev->dev, "no isp irq resource?");
+        err = -ENODEV;
+        goto egetirq;
+    }
+
+    cam_dev->irq = irq;
+    DBG_INFO("irq num : %d", cam_dev->irq);
+
+    err = devm_request_irq(&pdev->dev,cam_dev->irq, owl_camera_host_isp_isr,
+                      IRQF_DISABLED, OWL_CAM_HOST_NAME, cam_dev);
+    if (err) {
+        dev_err(&pdev->dev, "Unable to register isp %d interrupt.", cam_dev->irq);
+        err = -EBUSY;
+        goto egetirq;
+    }
+	cam_dev->hw_adapter = hw_adapter;
+    pm_suspend_ignore_children(&pdev->dev, true);
+    pm_runtime_enable(&pdev->dev);
+    pm_runtime_resume(&pdev->dev);
+    soc_host = &cam_dev->soc_host;
+    soc_host->ops = &owl_soc_camera_host_ops;
+    soc_host->priv = cam_dev;
+    soc_host->v4l2_dev.dev = &pdev->dev;
+    soc_host->nr = pdev->id;
+    switch (soc_host->nr) {
+    case 0:
+        soc_host->drv_name = CAM_HOST_NAME;
+        break;
+    case 1:
+        soc_host->drv_name = CAM_HOST2_NAME;
+        break;
+    default:
+        DBG_ERR("host num error");
+    }
+
+    err = soc_camera_host_register(soc_host);
+    if (err) {
+        dev_err(&pdev->dev, "Unable to register owl soc camera host.");
+        goto echreg;
+    }
+	isp_regulator_enable(&cam_dev->ir);
+    DBG_INFO("isp driver probe success...");
+    return 0;
+
+  echreg:
+    pm_runtime_disable(&pdev->dev);
+
+  egetirq:
+    detach_sensor_pwd_info(&pdev->dev, &cam_dev->spinfo, pdev->id);
+    cam_dev_free(cam_dev);
+
+  eid:
+    DBG_ERR("owl camera driver probe fail...");
+
+    return err;
+}
+
+static int owl_camera_remove(struct platform_device *pdev)
+{
+    struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
+    struct owl_camera_dev *cam_dev = soc_host->priv;
+		struct resource *res = NULL;
+	disable_irq(cam_dev->irq);
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+    soc_camera_host_unregister(soc_host);
+    pm_runtime_disable(&pdev->dev);
+    detach_sensor_pwd_info(&pdev->dev, &cam_dev->spinfo, pdev->id);
+    cam_dev_free(cam_dev);
+	if(noc_si_to_ddr)
+		iounmap(noc_si_to_ddr);
+	if(gpio_dinen)
+		iounmap(gpio_dinen);
+	if(si_reset)
+		iounmap(si_reset);
+	
+    DBG_INFO("owl camera is shutdown...");
+
+    return 0;
+}
+
+static void owl_camera_shutdown(struct platform_device *pdev)
+{
+	
+	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
+    struct owl_camera_dev *cam_dev = soc_host->priv;
+	isp_regulator_exit(&cam_dev->ir);
+	
+	DBG_ERR("owl camera is shutdown...");
+}
+
+
+
+static const struct dev_pm_ops owl_camera_dev_pm_ops = {
+    .suspend = owl_camera_suspend,
+    .resume = owl_camera_resume,
+};
+
+static const struct of_device_id owl_camera_of_match[] = {
+    {.compatible = ISP_FDT_COMPATIBLE,},
+    {},
+};
+MODULE_DEVICE_TABLE(of, owl_camera_of_match);
+
+static struct platform_driver owl_camera_host_driver = {
+    .driver = {
+        .name = OWL_CAM_HOST_NAME,
+        .owner = THIS_MODULE,
+        .pm = &owl_camera_dev_pm_ops,
+        .of_match_table = owl_camera_of_match,
+    },
+    .probe = owl_camera_host_probe,
+    .remove = owl_camera_remove,
+    .shutdown = owl_camera_shutdown,
+};
+
+struct owl_camera_hw_adapter *get_owl_camera_hw_adapter(void)
+{
+	if(of_find_compatible_node(NULL, NULL, "actions,atm7059tc") || of_find_compatible_node(NULL, NULL, "actions,atm7059a"))
+	{
+		printk("actions,atm7059\n");
+	    	return &atm7059_hw_adapter;
+	}
+	else if(of_find_compatible_node(NULL, NULL, "actions,atm7039c"))
+	{
+
+	}
+
+	return NULL;
+}
+
+// platform device register by dts
+static int __init owl_camera_init(void)
+{
+	int ret;
+
+	DBG_INFO("code(2013.09.15): compile time");
+	hw_adapter = get_owl_camera_hw_adapter();
+	ret = platform_driver_register(&owl_camera_host_driver);
+	if (ret) {
+		DBG_ERR(CAM_DRV_NAME":Could not register isp driver");
+	}
+
+	return ret;
+}
+
+static void __exit owl_camera_exit(void)
+{
+    platform_driver_unregister(&owl_camera_host_driver);
+}
+
+late_initcall(owl_camera_init);
+module_exit(owl_camera_exit);
+
+MODULE_DESCRIPTION("OWL SoC Camera Host driver");
+MODULE_AUTHOR("lichi <lichi@actions-semi.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/camera/owl_camera/owl_camera.h b/drivers/media/i2c/camera/owl_camera/owl_camera.h
new file mode 100755
index 0000000..57d8412
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/owl_camera.h
@@ -0,0 +1,221 @@
+/*
+ * gl5206_camera.h - GL5206 camera driver header file
+ */
+
+#ifndef _OWL_CAMERA_H_
+#define _OWL_CAMERA_H_
+
+#include <linux/device.h>
+#include <linux/videodev2.h>
+#include <media/soc_mediabus.h>
+#include <mach/isp-owl.h>
+
+#define owl_camera_hw_call(hw,f,args...)  ((!(hw)) ? -ENODEV : (((hw)->ops->f) ? ((hw)->ops->f((hw), ##args)) : -ENOIOCTLCMD))
+
+#define SENSOR_FRONT 0x1
+#define SENSOR_REAR 0x2
+#define SENSOR_DUAL 0x4
+
+#define DEFAULT_MBUS_PARAM_DVP \
+    (OWL_CAMERA_DATA_HIGH | OWL_CAMERA_PCLK_RISING | \
+    OWL_CAMERA_HSYNC_HIGH | OWL_CAMERA_VSYNC_HIGH | \
+    OWL_CAMERA_DATAWIDTH_8)
+
+#define DEFAULT_MBUS_PARAM_MIPI \
+    (V4L2_MBUS_CSI2_CHANNEL_0 | V4L2_MBUS_CSI2_2_LANE | \
+    V4L2_MBUS_CSI2_CONTINUOUS_CLOCK)
+
+
+#define OWL_CAMERA_DATA_HIGH		1
+#define OWL_CAMERA_PCLK_RISING	2
+#define OWL_CAMERA_HSYNC_HIGH	4
+#define OWL_CAMERA_VSYNC_HIGH	8
+#define OWL_CAMERA_DATAWIDTH_4	0x10
+#define OWL_CAMERA_DATAWIDTH_8	0x20
+#define OWL_CAMERA_DATAWIDTH_10	0x40
+#define OWL_CAMERA_DATAWIDTH_16	0x80
+
+#define CONTEXT_DT_RAW8  (0x2A)
+#define CONTEXT_DT_RAW10 (0x2B)
+#define CONTEXT_DT_RAW12 (0x2C)
+
+
+
+#define CAMERA_CSI2_CHANNEL_0 (1 << 9)
+#define CAMERA_CSI2_CHANNEL_1 (1 << 10)
+#define CAMERA_CSI2_CONTINUOUS_CLOCK (1 << 11)
+#define CAMERA_CSI2_NONCONTINUOUS_CLOCK (1 << 12)
+#define CAMERA_CSI2_LANE_1 (1 << 13)
+#define CAMERA_CSI2_LANE_2 (1 << 14)
+#define CAMERA_CSI2_LANE_3 (1 << 15)
+#define CAMERA_CSI2_LANE_4 (1 << 16)
+
+
+#define CAM_HOST_NAME "camera_host"
+#define CAM_HOST2_NAME "camera_host2"
+
+#define CAMERA_DATAWIDTH_MASK (CAMERA_DATAWIDTH_4 | CAMERA_DATAWIDTH_8 | \
+				   CAMERA_DATAWIDTH_10 | CAMERA_DATAWIDTH_16)
+
+
+enum owl_dev_state {
+    DEV_STOP = 0,
+    DEV_START,
+    DEV_SUSPEND,
+    DEV_RESUME,
+    DEV_OPEN,
+    DEV_CLOSE,
+};
+
+struct owl_camera_hw_adapter;
+
+struct owl_camera_reg{
+	volatile void * reg;
+	u32 val;
+};
+extern volatile void*	si_clk;
+
+extern void*	noc_si_to_ddr;	
+extern void*	gpio_dinen;
+extern void* si_reset;
+
+
+
+struct owl_camera_hw_ops
+{
+	int (*hw_adapter_init)(struct owl_camera_hw_adapter* hw,struct platform_device *pdev);
+    int (*get_channel_state)(struct owl_camera_hw_adapter* hw, int channel);
+    int (*set_channel_if)(struct owl_camera_hw_adapter* hw, int channel, int bus_type);
+    int (*set_channel_addrY)(struct owl_camera_hw_adapter* hw, int channel, void *addrY);
+    int (*set_channel_addrU)(struct owl_camera_hw_adapter* hw, int channel, void *addrU);
+    int (*set_channel_addrV)(struct owl_camera_hw_adapter* hw, int channel, void *addrV);
+    int (*set_channel_addr1UV)(struct owl_camera_hw_adapter* hw, int channel, void *addr1UV);
+    int (*set_channel_input_fmt)(struct owl_camera_hw_adapter* hw, int channel, enum v4l2_mbus_pixelcode code);
+    int (*set_channel_output_fmt)(struct owl_camera_hw_adapter* hw, int channel, u32 fourcc);
+    int (*set_channel_preline)(struct owl_camera_hw_adapter* hw, int channel, int preline);
+	int (*set_channel_int_en)(struct owl_camera_hw_adapter* hw, int channel);
+    int (*clear_channel_int_en)(struct owl_camera_hw_adapter* hw, int channel);
+    int (*set_channel_preline_int_en)(struct owl_camera_hw_adapter* hw, int channel);
+    int (*set_channel_frameend_int_en)(struct owl_camera_hw_adapter* hw, int channel);
+	int (*clear_channel_frameend_int_en)(struct owl_camera_hw_adapter* hw, int channel);
+	int (*clear_all_pending)(struct owl_camera_hw_adapter* hw);
+	int (*clear_channel_preline_int_en)(struct owl_camera_hw_adapter* hw);
+    int (*clear_channel_preline_pending)(struct owl_camera_hw_adapter* hw, int channel);
+    int (*clear_channel_frameend_pending)(struct owl_camera_hw_adapter* hw, unsigned int isp_int_stat);
+	int (*set_signal_polarity)(struct owl_camera_hw_adapter* hw,int channel,unsigned int common_flags);
+	int (*set_col_range)(struct owl_camera_hw_adapter* hw,int channel,unsigned int start,unsigned int end);
+	int (*set_row_range)(struct owl_camera_hw_adapter* hw,int channel,unsigned int start,unsigned int end); 
+	int (*get_channel_overflow)(struct owl_camera_hw_adapter* hw, int channel);
+	int (*clear_channel_overflow)(struct owl_camera_hw_adapter* hw, int channel); 
+	int (*save_regs)(struct owl_camera_hw_adapter* hw);
+	int (*restore_regs)(struct owl_camera_hw_adapter* hw); 
+};
+
+
+struct owl_camera_hw_adapter {
+    char *hw_name;
+	struct owl_camera_reg *restored_regs;
+	int restored_regs_num;
+    struct owl_camera_dev *cam_dev;
+
+    int max_channel;
+    int has_isp;
+    int is_3D_support;
+    int crop_x_align;
+    int crop_y_align;
+    int crop_w_align;
+    int crop_h_align;
+    int max_width;
+    int max_height;
+	int preline_int_pd;
+	int frameend_int_pd;
+
+    int isp_state;
+
+    int power_ref;
+    int enable_ref;
+
+    struct clk *hw_clk;
+
+    struct owl_camera_hw_ops *ops;
+
+    void *priv;
+
+};
+
+
+/*
+ * OWL have tow channel, if support all, should register tow soc camera host
+ */
+struct owl_camera_dev {
+
+    struct soc_camera_device *icd;
+
+    unsigned int dvp_mbus_flags;
+    struct soc_camera_host soc_host;
+
+    struct list_head capture;
+    spinlock_t lock;            /* Protects video buffer lists */
+    struct vb2_buffer *cur_frm;
+    struct vb2_buffer *prev_frm;
+
+    struct vb2_alloc_ctx *alloc_ctx;
+    unsigned int sequence;
+    struct completion wait_stop;
+
+    int irq;
+
+    int started;
+    struct pinctrl *mfp;
+    int skip_frames;
+
+    struct sensor_pwd_info spinfo;
+    struct isp_regulators ir;
+    struct clk *isp_clk;
+    struct clk *csi_clk;
+    struct clk *ch_clk[2]; /* correspond to ISP_CHANNEL_0/1 (should be 0 or 1) */
+	struct owl_camera_hw_adapter *hw_adapter;
+
+};
+
+struct owl_camera_param {
+    /* ISP data offsets within croped by the GL5203 camera output */
+    unsigned int isp_left;
+    unsigned int isp_top;
+    /* Client output, as seen by the GL5203 */
+    unsigned int width;
+    unsigned int height;
+    /*
+     * User window from S_CROP / G_CROP, produced by client cropping,
+     * GL5203 cropping, mapped back onto the client
+     * input window
+     */
+    struct v4l2_rect subrect;
+    /* Camera cropping rectangle */
+    struct v4l2_rect rect;
+    const struct soc_mbus_pixelfmt *extra_fmt;
+    enum v4l2_mbus_pixelcode code;
+    unsigned long flags;
+    unsigned int skip_frames;
+    int channel;
+    enum v4l2_mbus_type bus_type;
+    int lane_num;
+    int raw_width;
+    int data_type;//0 for yuv sensor,1 for raw-bayer sensor
+    int (*ext_cmd)(struct v4l2_subdev *sd,int cmd,void *args);
+};
+
+
+
+#define debug_print(fmt, arg...) do { if (1) printk(KERN_ERR fmt, ##arg); } while (0)
+
+#define isp_info(fmt, ...) \
+    printk(KERN_INFO fmt, ## __VA_ARGS__)
+    
+#define isp_err(fmt, ...) \
+    printk(KERN_ERR "%s(L%d) error: " fmt, __func__, __LINE__, ## __VA_ARGS__)
+
+
+extern struct owl_camera_hw_adapter atm7059_hw_adapter;
+extern struct owl_camera_hw_adapter atm7039_hw_adapter;
+#endif
diff --git a/drivers/media/i2c/camera/owl_camera/readme b/drivers/media/i2c/camera/owl_camera/readme
new file mode 100755
index 0000000..0ee8cd4
--- /dev/null
+++ b/drivers/media/i2c/camera/owl_camera/readme
@@ -0,0 +1,224 @@
+isp dts config\A3\BA
+
+\B5\DAһ\B2\BD\A3\BA
+leopard\build\gs703a\config\dts
+
+\CC\ED\BC\D3\C8\E7\CF\C2\C4\DA\C8ݣ\BA
+	aliases {
+    ...
+		isp0 = &isp0;
+	};
+	
+	isp0: isp@b0270000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,gl5203-isp";
+		reg = <0xb0270000 0x400>;
+		interrupts = < 0 12 0x4 >;
+	};
+	
+	\B5\B1ǰֻ֧\B3\D6һ\B8\F6isp host\A3\AC\C8\E7\B9\FB֧\B3\D6\C1\BD\B8\F6\A3\AC\D4\F2\D0\E8Ҫ\D4\D9\CC\ED\BC\D3\C9\CF\C3\E6\C1\BD\B8\F6\C0\E0\CBƵ\C4\C4\DA\C8ݣ\AC
+	\D2\F2Ϊ\C1\BD\B8\F6isp\D3\D0regs\CAǹ\B2\CF\ED\B5ģ\AC\CB\F9\D2\D4\D4\DA֧\B3ֵڶ\FE\B8\F6hostʱ\A3\AC\B5\D8ַ\BF\C9\D2\D4\C9\D4΢\B8ı\E4һ\CF£\AC
+	\B6\D4\C7\FD\B6\AF\B6\F8\D2ѣ\AC\B2\A2û\D3\D0\D3õ\BD\D5\E2\C0\EF\CCṩ\BCĴ\E6\C6\F7\B7\B6Χ\B5\C4ֵ\A1\A3
+	
+	ע\D2⣺\C9\CF\CA\F6aliases\D6е\C4isp0\A3\AC\C6\E40\B1\EDʾΪ\B5\DAһ\B8\F6isp host\A3\ACsensor \C7\FD\B6\AF\B5\C4
+	struct soc_camera_link.bus_idʹ\D3õľ\CD\CAǸ\C3ֵ\A3\AC\D4\DAsensor\B5\C4dts\C5\E4\D6\C3\D6У\AC
+	\C6\E4Ĭ\C8\CFֵΪ0\A3\BB
+	
+	֧\B3\D6\C1\BD\B8\F6ispʱ\A3\AC\BFɸ\C4Ϊ\A3\BA
+	aliases {
+    ...
+		isp0 = &isp0;
+		isp1 = &isp1;
+	};
+	
+	isp0: isp@b0270000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,gl5203-isp";
+		reg = <0xb0270000 0x400>;
+		interrupts = < 0 12 0x4 >;
+	};
+	isp1: isp@b02701ec {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "actions,gl5203-isp";
+		reg = <0xb02701ec 0x214>;
+		interrupts = < 0 12 0x4 >;
+	};
+
+\B5ڶ\FE\B2\BD\A3\BA
+build\gs703a\config\boards\board_type\dts \A3\A8board_typeΪ\BE\DF\CC\E5\B5İ\E6\D0ͣ\AC\C0\FD\C8磺
+liger_fpga\A3\A9\A3\BA
+
+\CC\ED\BCӵ\C4\C4\DA\C8ݣ\BA
+pinctrl\CF\E0\B9ز\BF\B7֣\BA
+  pinctrl@b01b0040 {
+          pinctrl-names = "default";
+          pinctrl-0 = <&state_default>;
+          
+          /* the format of isp state name: channel + pin + bus type(pin function) */
+          /* channel: isp0/isp1, pin: csi/bt/sens1, bus type: dvp/mipi */
+          isp0_state_csi_dvp: isp0_csi_dvp {
+                  isp0_csi_dvp_mfp {
+                          asoc,groups = "mfp3_31", "mfp3_29_28", "mfp3_15_14", "mfp3_13_12";
+                          asoc,function = "sens0";
+                  };
+          };
+
+          isp0_state_csi_mipi: isp0_csi_mipi {
+                  isp0_csi_mipi_mfp {
+                          asoc,groups = "mfp3_29_28", "mfp3_15_14";
+                          asoc,function = "mipi_csi";
+                  };
+                  isp0_csi_mipi_clkout_mfp {
+                          asoc,groups = "mfp3_31";
+                          asoc,function = "sens0";
+                  };
+          };
+
+          isp0_state_bt_dvp: isp0_bt_dvp {
+                  isp0_bt_dvp_mfp {
+                          asoc,groups = "mfp0_31_29", "mfp0_28_26", "mfp0_25_24", "mfp0_23_22", "mfp0_21_20";
+                          asoc,function = "sens0";
+                  };
+                  isp0_bt_dvp_clkout_mfp {
+                          asoc,groups = "mfp3_31";
+                          asoc,function = "sens0";
+                  };
+          };
+
+          isp1_state_csi_dvp: isp1_csi_dvp {
+                  isp1_csi_dvp_mfp {
+                          asoc,groups = "mfp3_29_28", "mfp3_15_14", "mfp3_11_10", "mfp3_3_2";
+                          asoc,function = "sens1";
+                  };
+          };
+
+          isp1_state_csi_mipi: isp1_csi_mipi {
+                  /* should not select it when 'isp0_state_csi_mipi' is selected, and vice versa */
+                  isp1_csi_mipi_mfp {
+                          asoc,groups = "mfp3_29_28", "mfp3_15_14";
+                          asoc,function = "mipi_csi";
+                  };
+                  isp1_csi_mipi_clkout_mfp {
+                          asoc,groups = "mfp3_3_2";
+                          asoc,function = "sens1";
+                  };
+          };
+
+          isp1_state_sens1_dvp: isp1_sens1_dvp {
+                  isp1_sens1_dvp_mfp {
+                          asoc,groups = "mfp3_11_10", "mfp3_9_7", "mfp3_6_4", "mfp3_3_2", "mfp3_1_0";
+                          asoc,function = "sens1";
+                  };
+          };
+
+  }
+  
+\B9\D8ϵͼ\A3\BA
+
+channel        PIN       BUS TYPE
+
+                     /-- DVP
+         /---- CSI -|
+        /            \-- MIPI   (1)
+sens0 -|
+        \
+         \---- BT  -| -- DVP
+
+                     /-- DVP
+         /---- CSI -|
+        /            \-- MIPI    (2)
+sens1 -|
+        \
+         \---- P_SEN1 -|-- DVP
+
+ע\D2⣺MIPI\A3\A81,2\A3\A9ֻ\C4\DC\D3\C9һ\B8\F6channel\A3\AC\D2\F2ΪPIN\D7\E9\CA\C7һ\D1\F9\B5ģ\A8\B5\B1ǰ\B5\C4PIN\CA\C7\D4\DAprobeʱ\C5\E4\D6õģ\A9\A3\BB
+
+ע\CA\CD\D6\D0\D2Ѿ\AD˵\C3\F7\C1\CBisp pinctrl\B5\C4\C3\FC\C3\FB\B9\E6\D4򣬴\D3ѡ\D4\F1\B5\C4pin\D7\E9\C3\FB\D7\D6\C9Ͽ\C9\D2Ի\F1\B5þ\DF\CC\E5\B5\C4\C5\E4\D6\C3\D0\C5Ϣ\A3\BB
+SOC\C9\CF\D3\D0\C1\BD\B8\F6ISP channel\A3\AC\D4\DA\C8\ED\BC\FE\C9Ͽɶ\D4Ӧ\C1\BD\B8\F6host\A3\AC\B6\D4\D3\DAchannel0\A3\A8\BB\F2\D5\DFsens0\A3\A9\D3\D0\C1\BD\D7\E9pin\BF\C9\D2\D4ʹ\D3ã\AC
+һ\CA\C7CSI\A3\AC\B6\FE\CA\C7BT\A3\AC\B5\B1ʹ\D3\C3CSI \D7\E9pinʱ\A3\AC\D7\DC\CF߿\C9\D2\D4\C5\E4\D6\C3ΪDVP\BA\CDMIPI\A3\AC\B6\F8\C8\E7\B9\FBʹ\D3\C3BT\A3\AC\D4\F2\CA\FD\BE\DD\D7\DC\CF\DFֻ\C4\DC\CA\C7
+DVP\A3\BB\B6\D4\D3\DAchannel1\A3\A8\BB\F2\D5\DFsens0\A3\A9Ҳ\D3\D0\C1\BD\D7\E9pin\BF\C9\D2\D4ʹ\D3ã\ACһ\CA\C7CSI\A3\AC\B6\FE\CA\C7P_SEN1\A3\AC\C8\E7\B9\FBʹ\D3\C3CSI\D7\E9pin\A3\AC
+\CA\FD\BE\DD\D7\DC\CF\DF\C0\E0\D0Ϳ\C9\D2\D4ѡ\D4\F1DVP\BB\F2\D5\DFMIPI\A3\AC\C8\E7\B9\FBʹ\D3\C3P_SEN1\A3\AC\D4\F2\CA\FD\BE\DD\D7\DC\CF\DFֻ\C4\DC\CA\C7DVP\A3\BB\B4\D3\C9\CF\C3\E6\BF\C9\D2Կ\B4\B3\F6\B6\D4\D3\DACSI
+\D7\E9pin\B6\F8\D1ԣ\AC֧\B3\D6\C1\BD\D6\D6\CA\FD\BE\DD\D7\DC\CF\DF\C0\E0\D0ͣ\AC\D3\C9\D3\DA\C1\BD\B8\F6channelֻ\C4\DC\D3\D0һ\B8\F6\BF\C9\D2\D4ʹ\D3\C3CSI\D7\E9pin\A3\AC\B9\CA\C8\E7\B9\FB\C1\BD\B8\F6channel
+ͬʱʹ\D3ã\AC\D4\F2\BD\F6\D3\D0һ\B8\F6channel\B5\C4\CA\FD\BE\DD\D7\DC\CF\DFΪMIPI\A3\BB
+\D5\E2\C0\EF\D3\D0һ\B8\F6\CE\CA\CC⣺\D4\DAѡ\D4\F1һ\D7\E9pin\C5\E4\D6\C3ʱ\A3\AC\C0\FD\C8\E7isp0_state_bt_dvp\A3\AC\D3\C9\D3\DA\C6\E4bt\D7\E9\B5\C4pin\D2Ѿ\AD\CCṩ\C1\CBpclk\A3\AC
+\B9\CA\D0\E8Ҫ\B9ر\D5sens0_pclk\CCṩ\B5\C4pclk[mfp_ctl3.sens0_pclk]\A3\AC\BC\B4\C9\E8\D6\C3Ϊ\B7\C70ֵ\A3\AC\B5\AB\CAǲ\BB֪\B5\C0\C9\E8\D6\C3Ϊ\BA\CEֵ\B1ȽϺã\AC
+\D2\F2Ϊһ\B5\A9\D4\DApinctrl\C0\EFʹ\D3ã\AC\BBᵼ\D6\C2\C6\E4\CB\FB\CF\E0Ӧ\B5\C4ģ\BF\E9\CE޷\A8ʹ\D3ã\AC\D5\E2\D0\E8Ҫpinctrlģ\D7\E9\D7\F6\CF\E0Ӧ\B5Ĵ\A6\C0\ED\A3\AC\B5\ABĿǰ
+ÿ\B8\F6pinֻ\C4\DC\D3\D0һ\B8\F6ģ\BF\E9ʹ\D3ã\AC\D5\E2\D4\DApinctrl\C0\EFû\D3з\B4Ӧ\B3\F6\C0\B4\A3\AC\C8\E7\B9\FB\B2\BB\B9رգ\AC\D4\F2isp\CE޷\A8\D5\FD\B3\A3\B9\A4\D7\F7\A3\BB
+\C8\E7\B9\FBʹ\D3\C3MIPI\A3\AC\C6\E4ʵpinctrl\C5\E4\D6\C3\CA\C7һ\D1\F9\B5ģ\A8\BF\C9\C4\DC\D0\E8Ҫ\B9رղ\BBͬ\B5\C4pclk\A3\AC\B5\ABĿǰ\BB\B9û\B7\B4Ӧ\B3\F6\C0\B4\A3\A9\A3\AC\C7\D2ֻ\C4\DC\D3\D0
+һ\B8\F6channel\BF\C9\D2\D4ʹ\D3ã\AC\B4\CBʱ\CCṩ\C1\BD\B8\F6\A3\AC\CA\C7\C8\C3isp driver֪\B5\C0\B5\B1ǰʹ\D3\C3\C1\CB\C4ĸ\F6channel\A3\BB
+
+	isp@b0270000 {
+		avdd-src = "regulator";  /* only: "gpio", "regulator" */
+
+		avdd-gpios = <&gpio 14 0>; /* GPIOA14, 0: high, 1: low only when vbus-src is "gpio" */
+
+		avdd-regulator = "LDO1"; /* only when vbus-src is "regulator" */
+		avdd-regulator-scope = <2800000 2810000>;  /* uV */
+		dvdd-regulator = "LDO7";
+		dvdd-regulator-scope = <1800000 1810000>;  /* uV */
+
+		sensors = "dual"; /* "dual", "front" or "rear" */
+		pwdn-rear-gpios = <&gpio 119 0>; /* GPIOC23 */
+		pwdn-front-gpios = <&gpio 120 0>; /* GPIOC24 */
+		reset-gpios = <&gpio 121 0>; /* GPIOC25 */
+
+		status = "okay"; /* create platform-device */
+	};
+	\B8\C3\C5\E4\D6ð\FC\BA\AC\C1\BD\B2\BF\B7֣\BAһ\CAǵ\E7Դ\CF\E0\B9أ\AC\B6\FE\CA\C7gpio\CF\E0\B9أ\BBÿ\B8\F6isp host\B6\BC\D0\E8Ҫ\B6\C0\C1\A2\B5\C4\C5\E4\D6ã\AC
+	\D2\F2Ϊ\B8\F7\B8\F6isp host\B6\BC\D0\E8ҪΪ\B9\D2\D4\DA\C6\E4\C9ϵ\C4sensor\CCṩavdd\A3\ACdvdd\B5ȵ\E7ѹ\A3\AC\D2Լ\B0ǰ\BA\F3\C9\E3\CF\F1ͷ
+	\B5\C4power gpio\BA\CDreset gpio\C5\E4\D6á\A3
+	
+	\B8\F7\CF\EE\C5\E4\D6õ\C4˵\C3\F7\A3\BA
+	avdd-src\A3\BA ˵\C3\F7avdd\CA\C7\C4\C4\D6ַ\BDʽ\CCṩ\A3\ACĿǰֻ\D3\D0gpio\A3\AC\BA\CDregulator\C1\BD\D6ַ\BDʽ\A3\AC
+	           \C8\E7\B9\FB\CA\C7gpio\B7\BDʽ\A3\AC\D4\F2\BD\F6\D0\E8Ҫ\C5\E4\D6\C3avdd-gpios\A3\AC\B4\CBʱgpio\CA\C7\D7\F7Ϊ\B4\F2\BF\AAavdd
+	           \B5Ŀ\AA\B9أ\BB\B7\F1\D4\F2\BD\F6\D0\E8Ҫavdd-regulator\BA\CDavdd-regulator-scope\A3\AC
+	           ˵\C3\F7\D0\E8Ҫʹ\D3\C3\C4Ǹ\F6regulator\A3\AC\BC\B0\C6\E4ʹ\D3õķ\B6Χ\A3\BB
+	           \B4\CB\C1\BD\D6\D6\CAǻ\A5\B3\E2\B5ġ\A3
+	dvdd-regulator\A3\BAʹ\D3õ\C4regulator\A3\AC\B8\C3\C3\FB\D7\D6\D3\C9regulator \C7\FD\B6\AF\BE\F6\B6\A8\A3\AC\B9\CAҪ\BA\CD\C6\E4һ\D6£\BB
+	dvdd-regulator-scope\A3\BA \B8\C3regulator\B5ķ\B6Χ\A3\BB
+	sensors\A3\BA\B1\ED\C3\F7\B5\B1ǰhostʹ\D3õ\C4sensor\C7\E9\BF\F6\A3\AC\D3\D0\C8\FD\D6֣\BA\B5\A5\C9\E3\CF\F1ͷʱ\B0\FC\C0\A8ǰ\D6úͺ\F3\D6ã\AC
+	         \BC\B0˫\C9\E3\CF\F1ͷ\A3\BB
+	pwdn-rear-gpios\A3\BA\BA\F3\D6\C3\C9\E3\CF\F1ͷ\B5\C4power gpio\C5\E4\D6ã\AC"dual" or "rear"ʱʹ\D3ã\BB
+	pwdn-front-gpios\A3\BAǰ\D6\C3\C9\E3\CF\F1ͷ\B5\C4power gpio\C5\E4\D6ã\AC"dual" or "front"ʱʹ\D3ã\BB
+  reset-gpios\A3\BA\C9\E3\CF\F1ͷ\B5\C4reset gpio\C5\E4\D6ã\AC\BE\F9ʹ\D3ã\BB
+
+  status\A3\BA\C9\E8\D6\C3Ϊokay\A3\ACϵͳ\BB\E1\D7Զ\AFΪ\B8\C3isp\B4\B4\BD\A8platform-device\A1\A3
+
+  ֧\B3\D6˫hostʱ\A3\AC\D0\E8\CC\ED\BCӵ\C4\C5\E4\D6\C3Ϊ\A3\AC\B4\CBʱ\B2\BB\C4\DC֧\B3\D63Dģʽ\A3\BA
+	isp@b02701ec {
+    ... // ͬ\C9\CF
+		status = "okay"; /* create platform-device */
+	};
+	ע\D2⣺---\BB\F9\B1\BE\C9ϲ\BB\BB\E1\D3\D0˫host\B5\C4\D0\E8\C7\F3---
+
+
+\B5\DA\C8\FD\B2\BD\A3\BA
+	\C8\E7\B9\FB֧\B3\D6˫host\A3\AC\C7\FD\B6\AF\D0\E8Ҫ\B5ĸĶ\AFΪ\A3\BA
+	\C1\BD\B8\F6isp hostʹ\D3\C3ͬһ\B8\F6isr\A3\AC\B9\CA\D4\DAprobeʱ\A3\AC\D0\E8Ҫ\D4\DAȫ\BEֱ\E4\C1\BF\C0ﱣ\B4浱ǰ\B7\D6\C5\E4\B5\C4
+	struct gl5203_camera_dev\BDṹ\CC壬\B2\A2\D4\DAisr\D6и\F9\BE\DDpreline pending\C0\B4\BE\F6\B6\A8ʹ\D3\C3
+	\C4ĸ\F6gl5203_camera_dev\A3\AC\D2\D4ѡ\D6в\BBͬ\B5\C4videobuf\B6\D3\C1У\BB\C7\D2isrֻ\C4\DCע\B2\E1һ\B4Σ\BB
+
+	\B4\D3Ӧ\D3ó\A1\BE\B0\B6\F8\D1ԣ\AC\BB\F9\B1\BE\C9ϲ\BB\BBᴴ\BD\A8\C1\BD\B8\F6host\A3\BA\B5\B1ǰ֧\B3ֵ\C4ǰ\BA\F3\C9\E3\CF\F1ͷ\BE\F9\B2\BB\BB\E1ͬʱʹ\D3ã\AC
+	һ\B8\F6host\BC\B4\BF\C9\C2\FA\D7㣻\B3\FD\B7\C7ǰ\BA\F3\C9\E3\CF\F1ͷͬʱʹ\D3ã\AC\B7\F1\D4\F2\CE\DE\D0贴\BD\A8\C1\BD\B8\F6host\A3\BB
+	\B6\D4\D3\DA3D\B6\F8\D1ԣ\AC\B2Ż\E1ͬʱʹ\D3\C3\C1\BD\B8\F6channel\A3\AC\B5\AB\D4\DA\CA\FD\BE\DD\C9\CFӲ\BC\FE\BB\E1\B0\D1\C1\BD\B8\F6\CA\FD\BE\DD\C1\F7\BAϲ\A2Ϊһ\B8\F6\A3\AC\C8\ED\BC\FE
+	\C9\CFҲ\BE\CDֻʹ\D3\C3һ\B8\F6host\A3\BB
+	
+GPIO \B9\DC\C0\ED\B5\C4˵\C3\F7\A3\BA
+  \D4\DA5202\C9ϣ\ACpoweroff/on reset\B5\C4gpio\CA\C7\D3\C9sensor driver\C9\EA\C7벢\C5\E4\D6õģ\AC\C7\D2\D4\DApoweroff/on
+ʱ\B6\BC\BB\E1\B7\D6\C5\E4\BA\CD\CAͷţ\AC\B4\CB\D7\F6\B7\A8\D3е㲻\CDף\AC\B6\F8\C7Ҳ\BB\C0\FB\D3\DAsensor driver\B5ĸ\B4\D3á\A3
+  \B6\D4\D3\DAͬһ\BF\EEsensor\A3\AC\BF\C9\D2\D4\D7\F7Ϊǰ\D6\C3\C9\E3\CF\F1ͷ\A3\ACҲ\BF\C9\D2\D4\D7\F7Ϊ\BA\F3\D6\C3\C9\E3\CF\F1ͷ\A3\AC\BCȿ\C9\D2\D4\D4\DAdemo\C9\CFʹ\D3ã\AC
+Ҳ\BF\C9\D2\D4\D4\DAevb\B5\C8\C9\CFʹ\D3ã\AC\D4ڲ\BBͬ\B5İ\E5\D7\D3\C9ϣ\AC\BB\E1\C9漰\B5\BD\B2\BBͬ\B5\C4gpio\C5\E4\D6ã\BB
+  \D7\EE\D6\D8Ҫ\B5\C4һ\B5\E3\CAǣ\ACgpio\B2\BB\CA\C7\D3\C9sensor\BE\F6\B6\A8\B5ģ\AC\B6\F8\CA\C7\D3ɰ\E6\D0;\F6\B6\A8\B5ģ\AC\B6\D4\D3\DAͬһ\B8\F6\B0\E6\D0ͣ\AC\BF\C9\D2\D4
+ʹ\D3ò\BBͬ\BF\EE\B5\C4sensor\A3\ACֻҪ\B1\A3֤pin\D0\F2\C1кͲ\E5\B2۵\C4һ\D6¼\B4\BFɣ\AC\D2\F2\B6\F8\B7\C5\D4\DAsensor driver\B2\BB\BA\CF\C0\ED\A3\AC
+\D7\EE\BA\C3\CAǷ\C5\D4ڰ\E6\D0͵Ĺ\AB\B9\B2\B4\FA\C2\EB\D6У\AC\BB\F2\D5\DFֱ\BDӷ\C5\D4\DAisp driver\C4ڡ\A3
+  \B7\C5\D4\DAsensor dirver\D6У\AC\B2\BB\C0\FB\D3\DAsensor driver\B5\C4\D2\C6ֲ\A3\AC\B6\F8\C7һ\E1\D3\D0\D6ظ\B4\C5\E4\D6ò\D9\D7\F7\A3\AC\B6\F8\B7\C5\D4\DAisp
+driver\D6\D0ͳһ\B9\DC\C0\ED\A3\AC\BB\E1\B1Ƚϼ\F2\B5\A5Щ\A1\A3
+  \B0\D1gpio\B5\C4\C9\EA\C7\EB\BA\CD\CAͷţ\AC\B7\C5\D4\DAisp driver\C4ڣ\AC\BBᵼ\D6\C2һ\B8\F6\CE\CA\CC⣬\D2\F2Ϊ\D5\E2Щgpio\B5\C4ʹ\D3\C3\CA\C7\D4\DA
+struct soc_camera_link\D6У\AC\C6\E4һ\B0㶨\D2\E5\D4\DAsensor driver\A3\AC\D2Ա\E3sensor\B5Ŀ\C9\CC\E6\B4\FA\D0ԡ\A3\B9ʶ\D4\D3\DA
+gpio\B5Ĳ\D9\D7\F7\BDӿڣ\AC\D6\F7ҪΪpoweron/off\BA\CDreset\A3\AC\D0\E8Ҫ\B6\D4sensor driver\BFɼ\FB\A3\AC\D2\F2\B6\F8\B7\C5\D4\DA\C1\CBkernel
+\B5İ\E6\D0ʹ\FA\C2\EB\C4ڣ\AC\BC\B4arch/arm/mach-liger/isp_pwd.c\CEļ\FE\A3\BB
+                                                    
+                                            yunchf\A3\AC2013-05-20
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/sensor_detect/Kconfig b/drivers/media/i2c/camera/sensor_detect/Kconfig
new file mode 100755
index 0000000..30d1a75
--- /dev/null
+++ b/drivers/media/i2c/camera/sensor_detect/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config SENSOR_DETECT
+	tristate "sensor detect module"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Detect functions of camera sensors that actions supports; 
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sensor_detect.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/sensor_detect/Makefile b/drivers/media/i2c/camera/sensor_detect/Makefile
new file mode 100755
index 0000000..b34d04e
--- /dev/null
+++ b/drivers/media/i2c/camera/sensor_detect/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_SENSOR_DETECT) += sensor_detect.o
diff --git a/drivers/media/i2c/camera/sensor_detect/module_detect.h b/drivers/media/i2c/camera/sensor_detect/module_detect.h
new file mode 100755
index 0000000..0f8d53b
--- /dev/null
+++ b/drivers/media/i2c/camera/sensor_detect/module_detect.h
@@ -0,0 +1,30 @@
+#ifndef __MODULE_DETECT_H__
+#define __MODULE_DETECT_H__
+
+#include <linux/i2c.h>
+
+#define MAX_CAMERA_MODULE_NUM     32
+
+#define CAMERA_ITEM_INIT(module_name, i2c_address, i2c_reg_width, \
+        i2c_data_width, module_detect) \
+{\
+    .name         = #module_name,\
+    .i2c_addr     = i2c_address,\
+    .reg_width    = i2c_reg_width,\
+    .data_width   = i2c_data_width,\
+    .detect       = module_detect,\
+    .need_detect  = false,\
+}\
+
+struct module_item_t {
+    unsigned char *name;
+    unsigned int  i2c_addr;
+    unsigned int  reg_width;
+    unsigned int  data_width;
+
+    int           (*detect)(struct module_item_t *, struct i2c_adapter *i2c_adap);
+    bool          need_detect;
+};
+
+extern struct module_item_t g_module_list[MAX_CAMERA_MODULE_NUM];
+#endif
diff --git a/drivers/media/i2c/camera/sensor_detect/module_list.c b/drivers/media/i2c/camera/sensor_detect/module_list.c
new file mode 100755
index 0000000..a56cbac
--- /dev/null
+++ b/drivers/media/i2c/camera/sensor_detect/module_list.c
@@ -0,0 +1,1120 @@
+
+#include "module_detect.h"
+
+#define DBG_SEN_INFO(fmt, args...)  printk(KERN_INFO"[sensor_list] line:%d--%s() "fmt"\n", __LINE__, __FUNCTION__, ##args)
+#define DBG_SEN_ERR(fmt, args...)   printk(KERN_ERR"[sensor_list] line:%d--%s() "fmt"\n", __LINE__, __FUNCTION__, ##args)
+
+struct regval_t {
+    unsigned char reg_array[2];
+    unsigned char data_array[2];
+};
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int i2c_addr, unsigned char reg_width, unsigned char data_width,
+					unsigned char *reg_array, unsigned char *data_array)
+{
+	struct i2c_msg msg;
+	int ret = 0;
+	
+	msg.addr = i2c_addr >> 1;
+	msg.flags = 0;
+	msg.len   = reg_width;
+	msg.buf   = reg_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		DBG_SEN_ERR("write register error %d", ret);
+		return ret;
+	}
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = data_width;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+	}
+	else {
+	    DBG_SEN_ERR("read register error %d", ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int i2c_addr, unsigned char reg_width, unsigned char data_width,
+					unsigned char *reg_array, unsigned char *data_array)
+{
+	struct i2c_msg msg;
+	unsigned char data[4];
+	int ret,i;
+	
+	for (i = 0; i < reg_width; i++) {
+	    data[i] = reg_array[i];
+	}
+	
+	for(i = reg_width; i < (reg_width + data_width); i++) {
+		data[i] = data_array[i - reg_width];
+	}
+	
+	msg.addr = i2c_addr >> 1;
+	msg.flags = 0;
+	msg.len   = reg_width + data_width;
+	msg.buf   = data;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    DBG_SEN_ERR("write register error %d", ret);
+	}
+	
+	return ret;
+}
+
+static int module_detect_gc0308(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+    regval.reg_array[0]  = 0xfe;
+	regval.data_array[0] = 0x00; 
+	ret = camera_i2c_write(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    	
+	regval.reg_array[0] = 0x00;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0x9b) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_gc0312(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+	unsigned int module_pid;
+    int ret = 0;
+    
+    regval.reg_array[0]  = 0xfe;
+	regval.data_array[0] = 0x00; 
+	ret = camera_i2c_write(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    	
+	
+	regval.reg_array[0] = 0xf0;
+		ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+		if (ret < 0) {
+			return ret;
+		}
+		
+		module_pid = regval.data_array[0] << 8;
+		
+		regval.reg_array[0] = 0xf1;
+		ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+		if (ret < 0) {
+			return ret;
+		}
+		
+		 module_pid |= regval.data_array[0];
+		
+		if (module_pid == 0xb310) {
+	
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_gc0328(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+    regval.reg_array[0]  = 0xfe;
+	regval.data_array[0] = 0x00; 
+	ret = camera_i2c_write(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    	
+	regval.reg_array[0] = 0xf0;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0x9d) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_gc0329(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+    regval.reg_array[0]  = 0xfc;
+	regval.data_array[0] = 0x16; 
+	ret = camera_i2c_write(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    	
+	regval.reg_array[0] = 0x00;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0xc0) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_gc2035(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0xf0;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid = regval.data_array[0] << 8;
+    
+    regval.reg_array[0] = 0xf1;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+    
+	if (module_pid == 0x2035) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_gt2005(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+    regval.reg_array[0] = 0x00;
+	regval.reg_array[1] = 0x00;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0x51) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_hi253(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+    regval.reg_array[0]  = 0x03;
+	regval.data_array[0] = 0x00; 
+	ret = camera_i2c_write(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    	
+	regval.reg_array[0] = 0x04;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0x92) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+
+static int module_detect_hi708(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;	
+	regval.reg_array[0] = 0x04;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0x96) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_hi257(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x04;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0xc4) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_hm2057(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x00;
+	regval.reg_array[1] = 0x01;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid = regval.data_array[0] << 8;
+
+	regval.reg_array[0] = 0x00;
+	regval.reg_array[1] = 0x02;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+
+	if (module_pid == 0x2056) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_ov2643(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x0a;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid = regval.data_array[0] << 8;
+
+	regval.reg_array[0] = 0x0b;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+
+	if (module_pid == 0x2643) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+static int module_detect_ov2686(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x30;
+	regval.reg_array[1] = 0x0a;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid = regval.data_array[0] << 8;
+
+	regval.reg_array[0] = 0x30;
+	regval.reg_array[1] = 0x0b;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+
+	if (module_pid == 0x2685) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s,the module_pid is 0x%x", item->name,module_pid);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+
+static int module_detect_ov5640(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x30;
+	regval.reg_array[1] = 0x0a;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid = regval.data_array[0] << 8;
+
+	regval.reg_array[0] = 0x30;
+	regval.reg_array[1] = 0x0b;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+
+	if (module_pid == 0x5640) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_sp0838(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+    regval.reg_array[0]  = 0xfd;
+	regval.data_array[0] = 0x00; 
+	ret = camera_i2c_write(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    	
+	regval.reg_array[0] = 0x02;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0x27) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_sp2518(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x02;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0x53) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_sp2519(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+	unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x02;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid = regval.data_array[0] << 8;
+    
+    regval.reg_array[0] = 0xa0;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+    
+	if (module_pid == 0x2519) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_sp0718(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x02;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0x71) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+
+static int module_detect_gc0311(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0xf0;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0xBB) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_gc2145(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0xf0;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid = regval.data_array[0] << 8;
+    
+    regval.reg_array[0] = 0xf1;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+    
+	if (module_pid == 0x2145) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s, pid=0x%x", item->name, module_pid);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_gc2155(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+
+	 regval.reg_array[0]  = 0xfe;
+	regval.data_array[0] = 0x00; 
+	ret = camera_i2c_write(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	regval.reg_array[0] = 0xf0;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid = regval.data_array[0] << 8;
+    
+    regval.reg_array[0] = 0xf1;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+    
+	if (module_pid == 0x2155) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s, pid=0x%x", item->name, module_pid);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+
+static int module_detect_siv120d(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x01;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0x12) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_siv121d(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x01;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0xDE) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_sp0a19(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x02;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0xa6) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_siv121du(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x01;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+	if (regval.data_array[0] == 0xde) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_siv130b(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    int ret = 0;
+
+	regval.reg_array[0] = 0x01;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	
+	if (ret < 0) {
+		return ret;
+	}
+	if (regval.data_array[0] == 0x1B) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s", item->name);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_gc2015(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+    unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+
+    DBG_SEN_INFO("start detect %s, i2c addr:0x%02x",
+            item->name, i2c_addr);
+
+    regval.reg_array[0] = 0x00;
+    ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+    if (ret < 0) {
+        DBG_SEN_ERR("i2c read reg 0 error");
+        return ret;
+    }
+
+    module_pid = regval.data_array[0] << 8;
+
+    regval.reg_array[0] = 0x01;
+    ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+    if (ret < 0) {
+        DBG_SEN_ERR("i2c read reg 1 error");
+        return ret;
+    }
+
+    module_pid |= (regval.data_array[0] & 0x1f);
+
+    if (module_pid == 0x2005) {
+        DBG_SEN_INFO("detect %s", item->name);
+    } else {
+        DBG_SEN_INFO("not detect %s, excepted values in reg[0x00, 0x01] is [0x20 0x05], actual:[0x%02x, 0x%02x]",
+                item->name, regval.data_array[0], regval.data_array[1]);
+        ret = -ENODEV;
+    }
+
+    return ret;
+}
+
+static int module_detect_gc0310(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+    unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+
+    DBG_SEN_INFO("start detect %s, i2c addr:0x%02x\n",
+            item->name, i2c_addr);
+
+    regval.reg_array[0] = 0xf0;
+    ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+    if (ret < 0) {
+        DBG_SEN_ERR("i2c read reg 0 error\n");
+        return ret;
+    }
+
+    module_pid = regval.data_array[0] << 8;
+
+    regval.reg_array[0] = 0xf1;
+    ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+    if (ret < 0) {
+        DBG_SEN_ERR("i2c read reg 1 error\n");
+        return ret;
+    }
+
+    module_pid |= regval.data_array[0];
+
+    if (module_pid == 0xa310) {
+        DBG_SEN_INFO("detect %s", item->name);
+    } else {
+        DBG_SEN_INFO("not detect %s, excepted values in reg[0xf0, 0xf1] is [0x3a 0x10], actual:[0x%02x, 0x%02x]",
+                item->name, regval.data_array[0], regval.data_array[1]);
+        ret = -ENODEV;
+    }
+
+    return ret;
+}
+
+static int module_detect_ov5642(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+    unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+
+    regval.reg_array[0] = 0x30;
+    regval.reg_array[1] = 0x0a;
+    ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+    if (ret < 0) {
+        return ret;
+    }
+
+    module_pid = regval.data_array[0] << 8;
+
+    regval.reg_array[0] = 0x30;
+    regval.reg_array[1] = 0x0b;
+    ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+    if (ret < 0) {
+        return ret;
+    }
+
+    module_pid |= regval.data_array[0];
+
+    if (module_pid == 0x5642) {
+        DBG_SEN_INFO("detect %s", item->name);
+    } else {
+        DBG_SEN_INFO("not detect %s", item->name);
+        ret = -ENODEV;
+    }
+
+    return ret;
+}
+
+static int module_detect_bf3a03(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+	unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0xfc;//PIDH 
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    module_pid = regval.data_array[0] << 8;
+
+	regval.reg_array[0] = 0xfd;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+
+	module_pid |= regval.data_array[0];
+	
+	if (module_pid == 0x3a03) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s,pid=%x", item->name,module_pid);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+}
+
+static int module_detect_bf3920(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0xfc;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+	
+    module_pid = regval.data_array[0] << 8;
+    
+    regval.reg_array[0] = 0xfd;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+    
+	if (module_pid == 0x3920) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s, pid=0x%x", item->name, module_pid);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+
+}
+
+static int module_detect_bf3703(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0xfc;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+
+    module_pid = regval.data_array[0] << 8;
+    
+    regval.reg_array[0] = 0xfd;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+    
+    module_pid |= regval.data_array[0];
+    
+	if (module_pid == 0x3703) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s, pid=0x%x", item->name, module_pid);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+
+}
+
+static int module_detect_soc5140(struct module_item_t *item, struct i2c_adapter *i2c_adap)
+{
+	unsigned int i2c_addr   = item->i2c_addr;
+    unsigned int reg_width  = item->reg_width;
+    unsigned int data_width = item->data_width;
+    struct regval_t regval;
+    unsigned int module_pid;
+    int ret = 0;
+    
+	regval.reg_array[0] = 0x00;
+	regval.reg_array[1] = 0x00;
+	ret = camera_i2c_read(i2c_adap, i2c_addr, reg_width, data_width, regval.reg_array, regval.data_array);
+	if (ret < 0) {
+		return ret;
+	}
+
+    module_pid = regval.data_array[1] | regval.data_array[0] << 8;
+    
+	if (module_pid == 0x2880) {
+	    DBG_SEN_INFO("detect %s", item->name);
+	} else {
+	    DBG_SEN_INFO("not detect %s, pid=0x%x", item->name, module_pid);
+		ret = -ENODEV;
+	}	
+    
+    return ret;
+
+}
+
+
+struct module_item_t g_module_list[MAX_CAMERA_MODULE_NUM] = {
+    CAMERA_ITEM_INIT(gc0308, 0x42, 1, 1, module_detect_gc0308),
+	CAMERA_ITEM_INIT(gc0312, 0x42, 1, 1, module_detect_gc0312),
+    CAMERA_ITEM_INIT(gc0328, 0x42, 1, 1, module_detect_gc0328),
+    CAMERA_ITEM_INIT(gc0329, 0x62, 1, 1, module_detect_gc0329),
+    CAMERA_ITEM_INIT(gc2035, 0x78, 1, 1, module_detect_gc2035),
+    CAMERA_ITEM_INIT(gt2005, 0x78, 2, 1, module_detect_gt2005),
+    CAMERA_ITEM_INIT(hi253,  0x40, 1, 1, module_detect_hi253),
+    CAMERA_ITEM_INIT(hi708,  0x60, 1, 1, module_detect_hi708),
+    CAMERA_ITEM_INIT(hi257,  0x40, 1, 1, module_detect_hi257),
+    CAMERA_ITEM_INIT(hm2057, 0x48, 2, 1, module_detect_hm2057),
+    CAMERA_ITEM_INIT(ov2643, 0x60, 1, 1, module_detect_ov2643),
+    CAMERA_ITEM_INIT(ov2686, 0x78, 2, 1, module_detect_ov2686),
+    CAMERA_ITEM_INIT(ov5640, 0x78, 2, 1, module_detect_ov5640),
+    CAMERA_ITEM_INIT(sp0838, 0x30, 1, 1, module_detect_sp0838),
+    CAMERA_ITEM_INIT(sp0718, 0x42, 1, 1, module_detect_sp0718),
+    CAMERA_ITEM_INIT(sp2518, 0x60, 1, 1, module_detect_sp2518),
+    CAMERA_ITEM_INIT(sp2519, 0x60, 1, 1, module_detect_sp2519),
+    CAMERA_ITEM_INIT(gc0311, 0x66, 1, 1, module_detect_gc0311),
+    CAMERA_ITEM_INIT(gc2145, 0x78, 1, 1, module_detect_gc2145),
+    CAMERA_ITEM_INIT(gc2155, 0x78, 1, 1, module_detect_gc2155),
+    CAMERA_ITEM_INIT(siv120d, 0x66, 1, 1, module_detect_siv120d),
+    CAMERA_ITEM_INIT(siv121d, 0x66, 1, 1, module_detect_siv121d),
+    CAMERA_ITEM_INIT(sp0a19,  0x42, 1, 1, module_detect_sp0a19),
+    CAMERA_ITEM_INIT(siv121du,0x66, 1, 1, module_detect_siv121du),
+    CAMERA_ITEM_INIT(siv130b, 0x6F, 1, 1, module_detect_siv130b),
+    CAMERA_ITEM_INIT(gc2015,  0x60, 1, 1, module_detect_gc2015),
+    CAMERA_ITEM_INIT(gc0310,  0x42, 1, 1, module_detect_gc0310),
+    CAMERA_ITEM_INIT(ov5642,  0x78, 2, 1, module_detect_ov5642),
+    CAMERA_ITEM_INIT(bf3a03,  0xdc, 1, 1, module_detect_bf3a03),
+    CAMERA_ITEM_INIT(bf3920,  0xdc, 1, 1, module_detect_bf3920),
+    CAMERA_ITEM_INIT(bf3703,  0xdc, 1, 1, module_detect_bf3703),
+    CAMERA_ITEM_INIT(soc5140,  0x78, 2, 2, module_detect_soc5140),
+
+};
diff --git a/drivers/media/i2c/camera/sensor_detect/sensor_detect.c b/drivers/media/i2c/camera/sensor_detect/sensor_detect.c
new file mode 100755
index 0000000..93263ec
--- /dev/null
+++ b/drivers/media/i2c/camera/sensor_detect/sensor_detect.c
@@ -0,0 +1,927 @@
+#include "module_list.c"
+#include <linux/of_gpio.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <mach/isp-owl.h>
+
+#include <mach/module-owl.h>
+
+#include <mach/clkname.h>
+
+#define CAMERA_COMMON_NAME           "sensor_common"
+#define CAMERA_DETECT_NAME           "sensor_detect"
+#define CFG_CAMERA_DETECT_LIST       "sensor_detect_list"
+
+#define ISP_FDT_COMPATIBLE           "actions,owl-isp"
+
+#define SENSOR_FRONT 0x1
+#define SENSOR_REAR 0x2
+#define SENSOR_DUAL 0x4
+
+#ifdef DETECT_DBG
+#define DBG_INFO(fmt, args...)  printk(KERN_INFO"[" CAMERA_DETECT_NAME "] (INFO) line:%d--%s() "fmt"\n", __LINE__, __FUNCTION__, ##args)
+#else
+#define DBG_INFO(fmt, args...)
+#endif
+
+#define DBG_ERR(fmt, args...)   printk(KERN_ERR"[" CAMERA_DETECT_NAME "] (ERR) line:%d--%s() "fmt"\n", __LINE__, __FUNCTION__, ##args)
+
+#define CAMERA_MODULE_CLOCK     24000000
+#define ISP_MODULE_CLOCK        60000000
+
+#define DELAY_INTERVAL            msecs_to_jiffies(2 * 1000)
+
+static struct kobject              *front_kobj = NULL;
+static struct kobject              *rear_kobj = NULL;
+#define CAMERA_REAR_NAME        "rear_camera"
+#define CAMERA_FRONT_NAME        "front_camera"
+
+
+
+static char camera_front_name[32];
+static char camera_rear_name[32];
+
+static int  camera_detect_status = 0;
+static int  camera_front_start   = 0;
+static int  camera_rear_start    = 0;
+static int  camera_front_offset  = -1;
+static int  camera_rear_offset   = -1;
+
+static bool g_front_detected      = false;
+static bool g_rear_detected       = false;
+
+static int  hot_plug_enable     = 0;
+static int  detect_times        = 0;
+
+static struct clk *g_sensor_clk = NULL;
+static struct clk *g_isp_clk    = NULL;
+
+/////////////
+static struct delayed_work      g_work;
+static struct sensor_pwd_info   g_spinfo;
+static struct isp_regulators    g_isp_ir;
+static int                      g_sens_channel = 0;   // sens0 or sens1
+static struct i2c_adapter       *g_adap;
+/////////////
+
+
+static int get_parent_node_id(struct device_node *node,
+    const char *property, const char *stem)
+{
+    struct device_node *pnode;
+    unsigned int value = -ENODEV;
+
+    pnode = of_parse_phandle(node, property, 0);
+    if (NULL == pnode) {
+        printk(KERN_ERR "err: fail to get node[%s]", property);
+        return value;
+    }
+    value = of_alias_get_id(pnode, stem);
+
+    return value;
+}
+
+static int init_common(void)
+{
+    struct module_item_t *module_item;
+    struct device_node *fdt_node;
+    int i2c_adap_id = 0;
+    struct dts_regulator *dr = &g_isp_ir.avdd.regul;
+
+    int i = 0;
+    int value = 0;
+
+    // get i2c adapter
+    fdt_node = of_find_compatible_node(NULL, NULL, CAMERA_COMMON_NAME);
+    if (NULL == fdt_node) {
+        DBG_ERR("err: no ["CAMERA_COMMON_NAME"] in dts");
+        return -1;
+    }
+    i2c_adap_id = get_parent_node_id(fdt_node, "i2c_adapter", "i2c");
+    g_adap = i2c_get_adapter(i2c_adap_id);
+
+    // get sens channel
+    if(of_property_read_u32(fdt_node, "channel", &g_sens_channel)) {
+        g_sens_channel = 0;
+    }
+
+	#if 1
+    // get detect sensor list
+    fdt_node = of_find_compatible_node(NULL, NULL, CAMERA_DETECT_NAME);
+    if (NULL == fdt_node) {
+        DBG_ERR("err: no ["CAMERA_DETECT_NAME"] in dts");
+        return -1;
+    }
+    if(of_property_read_u32(fdt_node, "hot_plugin_enable", &hot_plug_enable)) {
+        DBG_ERR("no hot_plugin_enable node");
+        hot_plug_enable = 0;
+    }
+    fdt_node = of_get_child_by_name(fdt_node, CFG_CAMERA_DETECT_LIST);
+    if (NULL == fdt_node) {
+        DBG_ERR("err: no ["CFG_CAMERA_DETECT_LIST"] in dts");
+        return -1;
+    }
+	#endif
+    for (i = 0; i < ARRAY_SIZE(g_module_list); i++) {
+        module_item = &g_module_list[i];
+        if(of_property_read_u32(fdt_node, module_item->name, &value))
+            continue;
+        module_item->need_detect = (bool)value;
+    }
+
+
+    g_spinfo.flag = 0;
+    g_spinfo.gpio_rear.num = -1;
+    g_spinfo.gpio_front.num = -1;
+    g_spinfo.gpio_reset.num = -1;
+    g_spinfo.ch_clk[ISP_CHANNEL_0] = NULL;
+    g_spinfo.ch_clk[ISP_CHANNEL_1] = NULL;
+
+    dr->regul = NULL;
+    g_isp_ir.avdd_use_gpio = 0;
+    g_isp_ir.dvdd_use_gpio = 0;
+    g_isp_ir.dvdd.regul = NULL;
+
+    return 0;
+}
+
+static inline void set_gpio_level(struct dts_gpio *gpio, bool active) {
+    if (active) {
+        gpio_direction_output(gpio->num, gpio->active_level);
+    } else {
+        gpio_direction_output(gpio->num, !gpio->active_level);
+    }
+}
+
+static int gpio_init(struct device_node *fdt_node,
+                     const char *gpio_name, struct dts_gpio *gpio, bool active)
+{
+    enum of_gpio_flags flags;
+
+    if (!of_find_property(fdt_node, gpio_name, NULL)) {
+        DBG_ERR("no config gpios:%s", gpio_name);
+        goto fail;
+    }
+    gpio->num = of_get_named_gpio_flags(fdt_node, gpio_name, 0, &flags);
+    gpio->active_level = !(flags & OF_GPIO_ACTIVE_LOW);
+
+    DBG_INFO("%s: num-%d, active-%s", gpio_name, gpio->num, gpio->active_level ? "high" : "low");
+
+    if (gpio_request(gpio->num, gpio_name)) {
+        DBG_ERR("fail to request gpio [%d]", gpio->num);
+        gpio->num = -1;
+        goto fail;
+    }
+
+    set_gpio_level(gpio, active);
+
+    DBG_INFO("gpio value: 0x%x", gpio_get_value(gpio->num));
+
+    return 0;
+  fail:
+    return -1;
+}
+
+static void gpio_exit(struct dts_gpio *gpio, bool active)
+{
+    DBG_INFO("gpio free:%d", gpio->num);
+    if (gpio->num >= 0) {
+        set_gpio_level(gpio, active);
+        gpio_free(gpio->num);
+    }
+}
+
+static int regulator_init(struct device_node *fdt_node,
+                          const char *regul_name, const char *scope_name,
+                          struct dts_regulator *dts_regul)
+{
+    unsigned int scope[2];
+    const char *regul = NULL;
+
+    DBG_INFO("");
+    if (of_property_read_string(fdt_node, regul_name, &regul)) {
+        DBG_ERR("don't config %s", regul_name);
+        goto fail;
+    }
+    DBG_INFO("%s", regul ? regul : "NULL");
+
+    if (of_property_read_u32_array(fdt_node, scope_name, scope, 2)) {
+        DBG_ERR("fail to get %s", scope_name);
+        goto fail;
+    }
+    DBG_INFO("min-%d, max-%d", scope[0], scope[1]);
+    dts_regul->min = scope[0];
+    dts_regul->max = scope[1];
+
+    dts_regul->regul = regulator_get(NULL, regul);
+    if (IS_ERR(dts_regul->regul)) {
+        dts_regul->regul = NULL;
+        DBG_ERR("get regulator failed");
+        goto fail;
+    }
+
+    regulator_set_voltage(dts_regul->regul, dts_regul->min, dts_regul->max);
+    //regulator_enable(dts_regul->regul);
+    //mdelay(5);
+    return 0;
+
+  fail:
+    return -1;
+
+}
+
+static inline void regulator_exit(struct dts_regulator *dr)
+{
+    regulator_put(dr->regul);
+    dr->regul = NULL;
+}
+
+static int isp_regulator_init(struct device_node *fdt_node, struct isp_regulators *ir)
+{
+    const char *avdd_src = NULL;
+
+/*DVDD*/
+    struct dts_gpio *dvdd_gpio = &ir->dvdd_gpio;
+    DBG_INFO("");
+    if (!gpio_init(fdt_node, "dvdd-gpios", dvdd_gpio, 0))/* poweroff */
+        ir->dvdd_use_gpio = 1;
+    else
+        ir->dvdd_use_gpio = 0;
+
+    if (regulator_init(fdt_node, "dvdd-regulator",
+                "dvdd-regulator-scope", &ir->dvdd))
+        goto fail;
+
+/*AVDD*/
+    if (of_property_read_string(fdt_node, "avdd-src", &avdd_src)) {
+        DBG_ERR("get avdd-src faild");
+        goto fail;
+    }
+
+    if (!strcmp(avdd_src, "regulator")) {
+        DBG_INFO("avdd using regulator");
+        ir->avdd_use_gpio = 0;
+
+        if (regulator_init(fdt_node, "avdd-regulator",
+                    "avdd-regulator-scope", &ir->avdd.regul))
+            goto free_dvdd;
+    } else if (!strcmp(avdd_src, "gpio")) {
+        struct dts_gpio *gpio = &ir->avdd.gpio;
+        ir->avdd_use_gpio = 1;
+
+        if (gpio_init(fdt_node, "avdd-gpios", gpio, 0))/* poweroff */
+            goto fail;
+
+        DBG_INFO("set - avdd gpio value: 0x%x", gpio_get_value(gpio->num));
+    } else {
+        DBG_INFO("needn't operate avdd manually");
+    }
+
+    return 0;
+
+free_dvdd:
+    regulator_exit(&ir->dvdd);
+fail:
+    return -1;
+}
+
+static void isp_regulator_exit(struct isp_regulators *ir)
+{
+    DBG_INFO("");
+    if (ir->dvdd_use_gpio)
+        gpio_exit(&ir->dvdd_gpio, 0);
+
+    if (ir->dvdd.regul) {
+        regulator_exit(&ir->dvdd);
+    }
+
+    if (ir->avdd_use_gpio) {
+        gpio_exit(&ir->avdd.gpio, 0);
+    } else {
+        struct dts_regulator *dr = &ir->avdd.regul;
+
+        if (dr->regul) {
+            regulator_exit(dr);
+        }
+    }
+}
+
+static void isp_regulator_enable(struct isp_regulators *ir)
+{
+	int ret = 0;
+    DBG_INFO("");
+    if (ir->dvdd.regul) {
+        ret = regulator_enable(ir->dvdd.regul);
+        mdelay(5);
+    }
+
+    if (ir->avdd_use_gpio) {
+        set_gpio_level(&ir->avdd.gpio, 1);
+    } else {
+        struct dts_regulator *dr = &ir->avdd.regul;
+        if (dr->regul) {
+            ret = regulator_enable(dr->regul);
+            mdelay(5);
+        }
+    }
+
+    if (ir->dvdd_use_gpio) {
+        set_gpio_level(&ir->dvdd_gpio, 1);
+    }
+}
+
+static void isp_regulator_disable(struct isp_regulators *ir)
+{
+    DBG_INFO("");
+    if (ir->dvdd_use_gpio) {
+        set_gpio_level(&ir->dvdd_gpio, 0);
+    }
+
+    if (ir->dvdd.regul) {
+        regulator_disable(ir->dvdd.regul);
+    }
+
+    if (ir->avdd_use_gpio) {
+        set_gpio_level(&ir->avdd.gpio, 0);
+    } else {
+        struct dts_regulator *dr = &ir->avdd.regul;
+        if (dr->regul) {
+            regulator_disable(dr->regul);
+        }
+    }
+}
+
+static int isp_gpio_init(struct device_node *fdt_node, struct sensor_pwd_info *spinfo)
+{
+    const char *sensors = NULL;
+
+    DBG_INFO("");
+    if (gpio_init(fdt_node, "reset-gpios", &spinfo->gpio_reset, 0)) {
+        goto fail;
+    }
+
+    if (of_property_read_string(fdt_node, "sensors", &sensors)) {
+        DBG_ERR("get sensors faild");
+        goto free_reset;
+    }
+
+    if (!strcmp(sensors, "front")) {
+        // default is power-down
+        if (gpio_init(fdt_node, "pwdn-front-gpios", &spinfo->gpio_front, 1)) {
+            goto free_reset;
+        }
+        spinfo->flag = SENSOR_FRONT;
+    } else if (!strcmp(sensors, "rear")) {
+        if (gpio_init(fdt_node, "pwdn-rear-gpios", &spinfo->gpio_rear, 1)) {
+            goto free_reset;
+        }
+        spinfo->flag = SENSOR_REAR;
+    } else if (!strcmp(sensors, "dual")) {
+        if (gpio_init(fdt_node, "pwdn-front-gpios", &spinfo->gpio_front, 1)) {
+            goto free_reset;
+        }
+        if (gpio_init(fdt_node, "pwdn-rear-gpios", &spinfo->gpio_rear, 1)) {
+            gpio_exit(&spinfo->gpio_front, 1);
+            goto free_reset;
+        }
+        spinfo->flag = SENSOR_DUAL;
+    } else {
+        DBG_ERR("sensors of dts is wrong");
+        goto free_reset;
+    }
+    return 0;
+
+  free_reset:
+    gpio_exit(&spinfo->gpio_reset, 0);
+  fail:
+    return -1;
+}
+
+static void isp_gpio_exit(struct sensor_pwd_info *spinfo)
+{
+    DBG_INFO("");
+    // only free valid gpio, so no need to check its existence.
+    gpio_exit(&spinfo->gpio_front, 1);
+    gpio_exit(&spinfo->gpio_rear, 1);
+    gpio_exit(&spinfo->gpio_reset, 0);
+}
+
+static int isp_clk_init(void)
+{
+    struct clk *tmp = NULL;
+    int ret = 0;
+
+    module_reset(MODULE_RST_BISP);
+    module_clk_enable(MOD_ID_BISP);
+
+    DBG_INFO("");
+    tmp = clk_get(NULL, CLKNAME_BISP_CLK);
+    if (IS_ERR(tmp)) {
+        ret = PTR_ERR(tmp);
+        g_isp_clk = NULL;
+        DBG_ERR("get isp clock error (%d)", ret);
+        return ret;
+    }
+    g_isp_clk = tmp;
+
+    mdelay(1);
+    
+    return ret;
+}
+
+static int isp_clk_enable(void)
+{
+    int ret = 0;
+
+    DBG_INFO("");
+    if (g_isp_clk != NULL) {
+        clk_prepare(g_isp_clk);
+        ret = clk_enable(g_isp_clk);  /*enable clk*/
+        if (ret) {
+            DBG_ERR("si clock enable error (%d)", ret);
+        }
+        ret = clk_set_rate(g_isp_clk, ISP_MODULE_CLOCK); /*\C9\E8\D6\C3isp\B9\A4\D7\F7Ƶ\C2\CA*/
+    }
+    
+    return ret;    
+}
+
+static void isp_clk_disable(void)
+{
+    DBG_INFO("");
+    if (g_isp_clk != NULL) {
+        clk_disable(g_isp_clk);
+        clk_unprepare(g_isp_clk);
+        clk_put(g_isp_clk);
+        module_clk_disable(MOD_ID_BISP);
+        g_isp_clk = NULL;
+    }
+}
+
+static int sensor_clk_init(void)
+{
+    struct clk *tmp = NULL;
+    int ret = 0;
+
+    module_clk_enable(MOD_ID_CSI);
+    module_reset(MODULE_RST_CSI);
+
+    DBG_INFO("sensor channel:%d", g_sens_channel);
+    if(g_sens_channel == 0)
+        tmp = clk_get(NULL, CLKNAME_SENSOR_CLKOUT0);
+    else
+        tmp = clk_get(NULL, CLKNAME_SENSOR_CLKOUT1);
+    if (IS_ERR(tmp)) {
+        ret = PTR_ERR(tmp);
+        DBG_ERR("get isp-channel-%d clock error%d", g_sens_channel, ret);
+        return ret;
+    }
+    g_sensor_clk = tmp;
+    DBG_INFO("sensor_clk:%p", g_sensor_clk);
+    return ret;
+}
+
+static int sensor_clk_enable(void)
+{
+    int ret;
+
+    DBG_INFO("");
+    if(g_sensor_clk == NULL) {
+        DBG_ERR("sensor clk not initialized!");
+        return -1;
+    }
+
+    clk_prepare(g_sensor_clk);
+    clk_enable(g_sensor_clk);
+
+    ret = clk_set_rate(g_sensor_clk, CAMERA_MODULE_CLOCK); /*\C9\E8\D6\C3sensorƵ\C2\CA*/
+    if (ret) {
+        DBG_ERR("set isp clock error");
+    }
+    mdelay(10);
+    return ret;
+}
+
+static void sensor_clk_disable(void)
+{
+    DBG_INFO("");
+    if(g_sensor_clk == NULL) {
+        DBG_ERR("sensor clk not initialized!");
+        return;
+    }
+
+    clk_disable(g_sensor_clk);
+    clk_unprepare(g_sensor_clk);
+    clk_put(g_sensor_clk);
+    module_clk_disable(MOD_ID_CSI);
+    g_sensor_clk = NULL;
+}
+
+static void sensor_reset(void)
+{
+    DBG_INFO("");
+    set_gpio_level(&g_spinfo.gpio_reset, 1);
+    mdelay(10);
+    set_gpio_level(&g_spinfo.gpio_reset, 0);
+    mdelay(10);
+}
+
+static void sensor_power(bool front, bool on)
+{
+    DBG_INFO("%s sensor power %s", front ? "front" : "rear", on ? "on" : "off");
+    if (front) {
+        set_gpio_level(&g_spinfo.gpio_front, !on);
+        sensor_reset();
+    } else {
+        set_gpio_level(&g_spinfo.gpio_rear, !on);
+    }
+    mdelay(10);
+}
+
+static ssize_t front_name_show(struct device *dev,  struct device_attribute *attr,  
+        char *buf)  
+{  
+    return strlcpy(buf, camera_front_name, sizeof(camera_front_name)); 
+}  
+
+static ssize_t rear_name_show(struct device *dev,  struct device_attribute *attr,
+        char *buf)  
+{  
+    return strlcpy(buf, camera_rear_name, sizeof(camera_rear_name)); 
+}    
+
+static ssize_t front_offset_show(struct device *dev,  struct device_attribute *attr,  
+        char *buf)  
+{  
+    return sprintf(buf, "%d", camera_front_offset); 
+}  
+
+static ssize_t rear_offset_show(struct device *dev,  struct device_attribute *attr,
+        char *buf)  
+{  
+    return sprintf(buf, "%d", camera_rear_offset); 
+}  
+
+static ssize_t status_show(struct device *dev,  struct device_attribute *attr,  
+        char *buf)  
+{  
+    return sprintf(buf, "%d", camera_detect_status); 
+}  
+
+static DEVICE_ATTR(front_name,   0444, front_name_show,   NULL); 
+static DEVICE_ATTR(rear_name,    0444, rear_name_show,    NULL);
+static DEVICE_ATTR(front_offset, 0444, front_offset_show, NULL); 
+static DEVICE_ATTR(rear_offset,  0444, rear_offset_show,  NULL);
+
+static DEVICE_ATTR(status,       0444, status_show,       NULL); 
+
+static int detect_init(void)
+{
+    struct device_node *fdt_node = NULL;
+    int ret = 0;
+
+    DBG_INFO("");
+
+    if(init_common()) {
+        return -1;
+    }
+
+    ret = isp_clk_init();
+    if (ret) {
+        DBG_ERR("init isp clock error");
+        goto exit;
+    }
+
+    ret = sensor_clk_init();
+    if (ret) {
+        DBG_ERR("init sensor clock error");
+        goto exit;
+    }
+
+    fdt_node = of_find_compatible_node(NULL, NULL, ISP_FDT_COMPATIBLE);
+    if (NULL == fdt_node) {
+        DBG_ERR("err: no ["ISP_FDT_COMPATIBLE"] in dts");
+        return -1;
+    }
+
+    ret = isp_gpio_init(fdt_node, &g_spinfo);
+    if (ret) {
+        DBG_ERR("pwdn init error!");
+        goto exit;
+    }
+
+    ret = isp_regulator_init(fdt_node, &g_isp_ir);
+    if (ret) {
+        DBG_ERR("avdd init error!");
+        goto exit;
+    }
+
+    ret = isp_clk_enable();
+    if (ret) {
+        DBG_ERR("enable isp clock error");
+        goto exit;
+    }
+
+    ret = sensor_clk_enable();
+    if (ret) {
+        DBG_ERR("enable sensor clock error");
+        goto exit;
+    }
+
+    isp_regulator_enable(&g_isp_ir);
+    return ret;
+
+exit:
+    isp_clk_disable();
+    sensor_clk_disable();
+    isp_regulator_exit(&g_isp_ir);
+    isp_gpio_exit(&g_spinfo);
+
+    return ret;
+}
+
+static void detect_deinit(void)
+{
+    DBG_INFO("");
+    isp_clk_disable();
+    sensor_clk_disable();
+	isp_regulator_disable(&g_isp_ir);
+    isp_regulator_exit(&g_isp_ir);
+    isp_gpio_exit(&g_spinfo);
+    cancel_delayed_work(&g_work);
+}
+
+static int detect_process(int id, char * drvname)
+{
+    struct module_item_t *module_item;
+    int ret = -1;
+
+    module_item = &g_module_list[id];
+    //module_item->power_on();
+
+    ret = module_item->detect(module_item, g_adap);
+    if (ret == 0) {
+        sprintf(drvname, "%s.ko", module_item->name);
+        DBG_INFO("detect (%s) success!!!!!!!!", module_item->name);
+    }
+    else
+    {
+        DBG_INFO("(%s) failed.", module_item->name);
+    }
+
+    //module_item->power_off();
+
+    return ret;
+}
+
+static int detect_modules(char *drvname, int scan_start, int *offset)
+{
+    int ret = 0;
+    int i = 0;
+
+    DBG_INFO("");
+    if (scan_start > 0 && scan_start < ARRAY_SIZE(g_module_list) ) {
+        ret = detect_process(scan_start, drvname);
+        if (ret == 0) {
+            *offset = scan_start;
+            return ret;
+        }
+    }
+
+    for (i = 0; i < ARRAY_SIZE(g_module_list); i++) {
+        if (g_module_list[i].need_detect) {
+            ret = detect_process(i, drvname);
+            if (ret == 0) {
+                *offset = i;
+                break;
+            }
+        }
+    }
+
+    return ret;
+}
+
+static void detect_work(struct work_struct *work)
+{
+    int ret = 0;
+
+    DBG_INFO("");
+    if (!g_front_detected)  {
+        DBG_INFO("--------detect front sensor------");
+        sensor_power(true, true);
+        ret = detect_modules(camera_front_name, camera_front_start, &camera_front_offset);
+        if (ret == 0) {
+            g_front_detected = true;
+        }
+        sensor_power(true, false);
+    }
+
+    if (!g_rear_detected) {
+        DBG_INFO("-------detect rear sensor-------");
+        sensor_power(false, true);
+        ret = detect_modules(camera_rear_name, camera_rear_start, &camera_rear_offset);
+        if (ret == 0) {
+            g_rear_detected = true;
+        }
+        sensor_power(false, false);
+    }
+
+    detect_times++;
+
+    // stop detect when:
+    // 1. both camera has been detected
+    // 2. if hot_plug_enable, detected until satisfy 1, elsewhere
+    // 3. detect_times less than 2
+    if((!g_front_detected || !g_rear_detected) && (detect_times < 2 || hot_plug_enable)) {
+        schedule_delayed_work(&g_work, DELAY_INTERVAL);
+    } else {
+        camera_detect_status = 1;
+        detect_deinit();
+    }
+}
+
+static int camera_detect_probe(struct platform_device *pdev)
+{
+    int ret = 0;
+    const char *detect_status = NULL;
+    struct device_node *fdt_node;
+    
+    DBG_INFO("");
+    fdt_node = of_find_compatible_node(NULL, NULL, CAMERA_DETECT_NAME);
+    if (NULL == fdt_node) {
+        DBG_ERR("err: no ["CAMERA_DETECT_NAME"] in dts");
+        return -1;
+    }
+
+    ret = of_property_read_string(fdt_node, "status", &detect_status);
+    if (ret == 0 && strcmp(detect_status, "okay") != 0) {
+        printk(KERN_DEBUG"%s camera detect disabled by DTS in %s\n",__func__,fdt_node->full_name);
+        return -ENODEV;
+    }
+
+    ret = detect_init();
+    if (ret) {
+        DBG_ERR("module detect init error.");
+        goto exit;
+    }
+
+    rear_kobj = kobject_create_and_add(CAMERA_REAR_NAME, NULL);
+    if (rear_kobj == NULL) {  
+        DBG_ERR("kobject_create_and_add failed.");
+        ret = -ENOMEM;  
+        goto kobject_create_err;
+    }  
+	front_kobj = kobject_create_and_add(CAMERA_FRONT_NAME, NULL);
+    if (front_kobj == NULL) {  
+        DBG_ERR("kobject_create_and_add failed.");
+        ret = -ENOMEM;  
+        goto kobject_create_err;
+    }  
+    
+    ret = sysfs_create_file(front_kobj, &dev_attr_front_name.attr);
+    if (ret < 0){
+        DBG_ERR("sysfs_create_file front_name failed.");
+        goto sysfs_create_err;
+    }
+	 ret = sysfs_create_file(front_kobj, &dev_attr_front_offset.attr);
+    if (ret < 0){
+        DBG_ERR("sysfs_create_file front_offset failed.");
+        goto sysfs_create_err;
+    }
+    ret = sysfs_create_file(rear_kobj, &dev_attr_rear_name.attr);
+    if (ret < 0){
+        DBG_ERR("sysfs_create_file rear_name failed.");
+        goto sysfs_create_err;
+    }
+	 ret = sysfs_create_file(rear_kobj, &dev_attr_rear_offset.attr);
+    if (ret < 0){
+        DBG_ERR("sysfs_create_file rear_offset failed.");
+        goto sysfs_create_err;
+    }
+
+    ret = sysfs_create_file(rear_kobj, &dev_attr_status.attr);
+    if (ret < 0){
+        DBG_ERR("sysfs_create_file status failed.");
+        goto sysfs_create_err;
+    }  
+    
+    camera_detect_status = 0;
+    INIT_DELAYED_WORK(&g_work, detect_work);
+    schedule_delayed_work(&g_work, DELAY_INTERVAL);
+    
+    return 0;
+    
+sysfs_create_err:  
+    kobject_del(rear_kobj);
+	kobject_del(front_kobj);
+
+kobject_create_err:
+
+exit:
+    detect_deinit();
+
+    return ret;
+}
+
+static int camera_detect_suspend(struct platform_device *pdev, pm_message_t m)
+{
+    DBG_INFO("");
+	if((!g_front_detected || !g_rear_detected) && ( hot_plug_enable))
+	{
+	cancel_delayed_work_sync(&g_work);
+	}
+    isp_regulator_disable(&g_isp_ir);
+    set_gpio_level(&g_spinfo.gpio_front, 0);
+    set_gpio_level(&g_spinfo.gpio_rear, 0);
+    set_gpio_level(&g_spinfo.gpio_reset, 1);
+    
+    return 0;
+}
+
+static int camera_detect_resume(struct platform_device *pdev)
+{
+    DBG_INFO("");
+    set_gpio_level(&g_spinfo.gpio_front, 1);
+    set_gpio_level(&g_spinfo.gpio_rear, 1);
+    set_gpio_level(&g_spinfo.gpio_reset, 0);
+    isp_regulator_enable(&g_isp_ir);
+	if((!g_front_detected || !g_rear_detected) && ( hot_plug_enable))
+	{
+	schedule_delayed_work(&g_work, DELAY_INTERVAL);
+	}
+    return 0;
+}
+
+static int camera_detect_remove(struct platform_device *pdev)
+{
+    cancel_delayed_work_sync(&g_work);
+
+    sysfs_remove_file(front_kobj, &dev_attr_front_name.attr);
+    sysfs_remove_file(rear_kobj, &dev_attr_rear_name.attr);
+    sysfs_remove_file(rear_kobj, &dev_attr_status.attr);
+    kobject_del(front_kobj);
+	kobject_del(rear_kobj);
+    detect_deinit();
+    
+    return 0;
+}
+
+static struct platform_driver camera_detect_driver = {
+    .driver = {
+        .name  = CAMERA_DETECT_NAME,
+        .owner = THIS_MODULE,
+    },
+    .probe   = camera_detect_probe,
+    .suspend = camera_detect_suspend,
+    .resume  = camera_detect_resume,
+    .remove  = camera_detect_remove,
+};
+
+static void detect_device_release(struct device * dev)
+{
+    return;
+}
+
+static struct platform_device camera_detect_device = {
+    .name = CAMERA_DETECT_NAME,
+    .dev = {
+        .release = detect_device_release,
+    }
+};
+
+/* module function */
+static int __init camera_detect_init(void)
+{
+    int ret = 0;
+
+    DBG_INFO("%s version: %s, 2014-07-16", THIS_MODULE->name, THIS_MODULE->version);
+    ret = platform_device_register(&camera_detect_device);
+    if (ret) {
+        return ret;
+    }
+    
+    ret = platform_driver_register(&camera_detect_driver);
+    
+    return ret;
+}
+
+module_init(camera_detect_init);
+
+static void __exit camera_detect_exit(void)
+{
+    platform_driver_unregister(&camera_detect_driver);
+    platform_device_unregister(&camera_detect_device);
+}
+
+module_exit(camera_detect_exit);
+module_param(camera_front_start, int, S_IRUSR);
+module_param(camera_rear_start, int, S_IRUSR);
+
+MODULE_DESCRIPTION("Camera module detect driver");
+MODULE_AUTHOR("Actions-semi");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/media/i2c/camera/siv121du/Kconfig b/drivers/media/i2c/camera/siv121du/Kconfig
new file mode 100755
index 0000000..55caa08
--- /dev/null
+++ b/drivers/media/i2c/camera/siv121du/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config SIV121DU
+	tristate "siv121du camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for siv121du camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called siv121du.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/siv121du/Makefile b/drivers/media/i2c/camera/siv121du/Makefile
new file mode 100755
index 0000000..2eb7ac7
--- /dev/null
+++ b/drivers/media/i2c/camera/siv121du/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_SIV121DU)	+= siv121du.o
diff --git a/drivers/media/i2c/camera/siv121du/module_diff.h b/drivers/media/i2c/camera/siv121du/module_diff.h
new file mode 100755
index 0000000..05bf221
--- /dev/null
+++ b/drivers/media/i2c/camera/siv121du/module_diff.h
@@ -0,0 +1,530 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME 		"camera_siv121du"
+#define CAMERA_MODULE_PID		0xDE
+
+#define MODULE_PLATFORM_ID		SIV121DU_PLATFORM_ID
+#define MODULE_I2C_REAL_ADDRESS	(0x66>>1)
+#define MODULE_I2C_REG_ADDRESS	(0x6d>>1)
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+
+#if 1
+#define PID						0x01 /* Product ID Number */
+#else
+#define PIDH					XXX /* Product ID Number H byte */
+#define PIDL					XXX /* Product ID Number L byte */
+#endif
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_LOW
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA
+#define MODULE_MAX_WIDTH		WIDTH_VGA
+#define MODULE_MAX_HEIGHT		HEIGHT_VGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		4
+#define DROP_NUM_PREVIEW		4
+
+static unsigned int frame_rate_qvga[]  = {30,};
+static unsigned int frame_rate_vga[]   = {30,};
+
+static const struct regval_list module_init_regs[] =
+{
+     {0x00,0x01},  
+	{0x03,0x08}, 
+	{0x00,0x01},  
+	{0x03,0x08}, 
+	
+	{0x00,0x00},  
+	{0x03,0x04},                                           
+	{0x10,0x86},//8d}, //85  
+	{0x11,0x71},// f1},	  //0x11  0x61 davis20120514
+	
+	{0x00,0x01},                             
+    {0x04,0x00},//0x04}, 
+	{0x06,0x04},                                           
+	{0x10,0x11},//46},                                           
+	{0x11,0x25},//23},                                           
+	{0x12,0x21},                                           
+	{0x17,0x94},//86},                                           
+	{0x18,0x00},                                           
+	{0x20,0x00},                                           
+	{0x21,0x05},                                           
+  //  {0x22, 0x01},
+	{0x23,0x69}, //add 
+	{0x40,0x0F},                                        
+	{0x41,0x90},                                        
+	{0x42,0xd2},                                           
+	{0x43,0x00}, 
+
+	// AE
+	{0x00,0x02},                                          
+	{0x10,0x84},                                           
+    {0x11,0x0a},//0d}, min frame rate \D7\EE\B5\CD֡\C2\CA
+    {0x12,0x72},//75},//78},//0x80}, //0x64
+    {0x14,0x70},//75},//78},//0x80},
+    {0x34,0x96},
+    {0x40,0x38},//35},//38},//40}, //0x48
+  
+    {0x44,0x08},
+  
+
+	
+	// AWB 
+	{0x00,0x03},                                          
+    {0x10, 0xd0},
+	{0x11,0xc1},//c0},//c0  
+    {0x13,0x82},//81},//0x82}, //Cr target
+	{0x14,0x7f},//80}, //Cb target  7f                                                                 
+	{0x15,0xe0},//c0}, // R gain Top   e0                                                             
+    {0x16, 0x7c}, // R gain bottom 
+	{0x17,0xe0}, // B gain Top   e0                                                             
+	{0x18,0x80},//70}, // B gain bottom 0x80     //                                                  
+    {0x19, 0x8c}, // Cr top value 0x90
+	{0x1a,0x64},	// Cr bottom value 0x64   60        //YCbYCr                                 
+	{0x1b,0x94}, // Cb top value 0x98                                                        
+	{0x1c,0x6c}, // Cb bottom value 0x6c           // 0x01        
+	{0x1d,0x94}, // 0xa0                                 
+	{0x1e,0x6c}, // 0x60                                                
+	{0x20,0xe8}, // AWB luminous top value                                                   
+	{0x21,0x30}, // AWB luminous bottom value 0x20                                           
+	{0x22,0xb8},                                           
+	{0x23,0x10},   
+	{0x25,0x08},//20},    
+	{0x26,0x0f},//0f},    
+	{0x27,0x60},    // BRTSRT                                            
+	{0x28,0x70},    // BRTEND                                           
+	{0x29,0xb7},    // BRTRGNBOT                                        
+	{0x2a,0xa3},    // BRTBGNTOP 
+	                                         
+	{0x40,0x01},                                           
+	{0x41,0x03},//04},                                           
+	{0x42,0x08},                                           
+	{0x43,0x10},                                           
+	{0x44,0x13},//12}, // 0x12  
+	{0x45,0x6a},//35},  //35                                 
+	{0x46,0xca},  //  fc   
+	
+    {0x62,0x80},//0x78},//80},
+    {0x63, 0x90}, // R D30 to D20
+    {0x64, 0xd0}, // B D30 to D20
+	{0x65,0x98},//a0},//90},  // R D20 to D30                                          
+	{0x66,0xd0},  // B D20 to D30  
+
+	// IDP 
+	{0x00,0x04},                                          
+	{0x10,0x7f},//ff},                                           
+	{0x11,0x1d}, // changed
+    {0x12, 0x3d},
+	{0x13,0xfe},//++ 
+	{0x14,0x01},//++ 
+	
+	
+		// DPCBNR                                            
+	{0x18,0xbf},//fe},  // DPCNRCTRL                                               
+	{0x19,0x00},//04},  // DPCTHV                                                  
+	{0x1A,0x00},//01},  // DPCTHVSLP                                               
+	{0x1B,0x00},//08},//08},  // DPCTHVDIFSRT                                                                                                                                                                                                                                                                                                              
+	//{0x1C,0x0f},//08},  // DPCTHVDIFSLP                                            
+	//{0x1d,0xFF},  // DPCTHVMAX      
+	                                                             
+	{0x1E,0x04},  // BNRTHV  0c                                              
+	{0x1F,0x08},//04},  // BNRTHVSLPN 10                                           
+	{0x20,0x20},  // BNRTHVSLPD                                              
+	{0x21,0x00}, /// BNRNEICNT      / 0x08                                   
+	{0x22,0x08},  // STRTNOR        // 0x03                                  
+	{0x23,0x38},//40},  // STRTDRK        
+	{0x24,0x00},
+
+	// Gamma 
+    {0x31, 0x03}, //0x08
+    {0x32, 0x0b}, //0x10
+    {0x33, 0x1e}, //0x1B
+    {0x34, 0x46}, //0x37
+    {0x35, 0x62}, //0x4D
+    {0x36, 0x78}, //0x60
+    {0x37, 0x8b}, //0x72
+    {0x38, 0x9b}, //0x82
+    {0x39, 0xa8}, //0x91
+    {0x3a, 0xb6}, //0xA0
+    {0x3b, 0xcc}, //0xBA
+    {0x3c, 0xdf}, //0xD3
+    {0x3d, 0xf0}, //0xEA
+    
+    // Shading Register Setting 				 
+	{0x40,0x55},//04},  //06                                         
+	{0x41,0x44},                                           
+	{0x42,0x33},//43},                                           
+	{0x43,0x00},                                   
+	{0x44,0x22},  // left R gain[7:4], right R gain[3:0] 	 22					                                          
+	{0x45,0x22},  // top R gain[7:4], bottom R gain[3:0] 		22				                                          
+	{0x46,0x00},  // left G gain[7:4], right G gain[3:0] 	                                                    
+	{0x47,0x03},  // top G gain[7:4], bottom G gain[3:0] 	   11                                                   
+	{0x48,0x01},  // left B gain[7:4], right B gain[3:0] 	                                                   
+	{0x49,0x11},  // top B gain[7:4], bottom B gain[3:0] 	           //color matrix default                                          
+	{0x4a,0x05},  // X-axis center high[3:2], Y-axis center high[1:0]                                         
+	{0x4b,0x40},  // X-axis center low[7:0]				48		                                                        
+	{0x4c,0x10},  // Y-axis center low[7:0]		 e8			                                                          
+	{0x4d,0x80},  // Shading Center Gain     80                                                                  
+	{0x4e,0x00},  // Shading R Offset                                                                   
+	{0x4f,0x00},  // Shading Gr Offset                                                                        
+	{0x50,0x00},  // Shading B Offset                                
+
+	
+	// Interpolation                                           
+	{0x60,0x7f},                                     
+	{0x61,0x08},  
+	 
+	 // Color matrix (D65) - Daylight    
+    {0x71, 0x39},//34},	 
+    {0x72, 0xc8},//CE},	 
+    {0x73, 0xff},	 
+	{0x74,0x13},         //0x13       0x10                           
+	{0x75,0x25},         //0x25       0x21                           
+	{0x76,0x08},         //0x08       0x0f                           
+	{0x77,0xf8},		 //0xec 	  0xf8							 
+	{0x78,0xc0},		 //0xd1 	  0xc0							 
+	{0x79,0x48},		 //0x47 	  0x48
+	
+	// Color matrix (D20) - A                                           
+    {0x83, 0x38}, //0x3c 	
+    {0x84, 0xd1}, //0xc6 	
+    {0x85, 0xf7}, //0xff   
+	{0x86,0x12},     //0x12                                         
+	{0x87,0x25},     //0x24 	                                  
+	{0x88,0x09},     //0x0a 	                                      
+    {0x89, 0xed}, //0xed   
+    {0x8a, 0xbb}, //0xc2 	
+    {0x8b, 0x58}, //0x51
+    
+	{0x8c,0x10},     //CMA select
+	
+	//G Edge                                        
+	{0x90,0x35},    //Upper gain                                                                 
+	{0x91,0x48},    //down gain                                                                  
+	{0x92,0x33},//22},    //[7:4] upper coring [3:0] down coring                                       
+	{0x9a,0x40},                                           
+	{0x9b,0x40},                                           
+	{0x9c,0x38},    //edge suppress start   30                                      
+	{0x9d,0x30},    //edge suppress slope   
+	{0x9f,0x26},
+	{0xa0,0x11},
+	
+	{0xa8,0x12},//0x11},//10},                                     
+    {0xa9,0x12},//cr saturation-----------
+    {0xaa,0x12},//cb,-----------
+		 
+    {0xab, 0x00},//0x08},//brightness-----------
+		 
+    {0xb9, 0x28}, // nightmode 38 at gain 0x48 5fps
+    {0xba, 0x41}, // nightmode 80 at gain 0x48 5fps
+
+    {0xbf, 0x20},
+    {0xc0, 0x24},	 
+    {0xc1, 0x00},	 
+   {0xc2, 0x80},	
+   {0xc3, 0x00},	 
+   {0xc4, 0xe0},	 
+    
+	{0xde,0x80},  
+	                                         
+	{0xe5,0x15},                                           
+	{0xe6,0x02},                                           
+	{0xe7,0x04}, 
+	                                                                                             
+	//Sensor On //Sensor On                                                             
+    //Sensor On  
+	{0x00,0x01},                                           
+	{0x03,0x01},  
+       
+     {0x00,0x00},
+     ENDMARKER,
+};
+
+/* 320*240: QVGA */
+static const struct regval_list module_qvga_regs[] = 
+{
+ 	{0x00,	0x01}, 
+	{0x06,	0x06},
+
+	{0x00,	0x04}, 
+	//{0x12,	0x3d},
+
+	{0xc0,	0x10},
+	{0xc1,	0x00},
+	{0xc2,	0x40},
+	{0xc3,	0x00},
+	{0xc4,	0xf0},
+     ENDMARKER,
+};
+
+/* 640*480: VGA */
+static const struct regval_list module_vga_regs[] = 
+{
+//  NULL
+	{0x00,  0x01}, 
+    {0x06,	0x04},
+
+    {0x00,  0x04}, 
+   // {0x12,	0x3d},
+
+    {0xc0,	0x24},
+    {0xc1,	0x00},
+    {0xc2,	0x80},
+    {0xc3,	0x00},
+    {0xc4,  0xe0},
+     ENDMARKER,
+
+};
+
+static const struct regval_list module_init_auto_focus[] = {
+     ENDMARKER,
+	//  NULL
+	};
+
+
+
+/*
+ * window size list
+ */
+/* 320*240 */
+static struct camera_module_win_size module_win_qvga = {
+	.name             = "QVGA",
+	.width            = WIDTH_QVGA,
+	.height           = HEIGHT_QVGA,
+	.win_regs         = module_qvga_regs,
+	.frame_rate_array = frame_rate_qvga,
+	.capture_only     = 0,
+};
+
+/* 640*480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_qvga,
+	&module_win_vga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+	{0x00,	0x03}, 
+	{0x10,	0xd0}, 
+     ENDMARKER,
+
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	{0x00, 0x03}, 
+	{0x10, 0x00},  // disable AWB
+	{0x60, 0xb4}, 
+	{0x61, 0x74}, 
+     ENDMARKER,
+
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+		{0x00, 0x03}, 
+	   {0x10, 0x00},   // disable AWB
+	   {0x60, 0xd8}, 
+	   {0x61, 0x90},
+     ENDMARKER,
+
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+		{0x00, 0x03}, 
+		{0x10, 0x00},  // disable AWB
+		{0x60, 0x80},
+		{0x61, 0xe0},
+     ENDMARKER,
+
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	{0x00, 0x03}, 
+    {0x10, 0x00},  // disable AWB
+    {0x60, 0xb8},
+    {0x61, 0xcc},
+     ENDMARKER,
+};
+#if 0
+
+/*\D5\FD\B3\A3ģʽ*/
+static struct regval_list module_effect_normal_regs[] =
+{
+	{0x00, 0x04}, 
+	{0xd6, 0x00}, 
+     ENDMARKER, 
+};
+
+/*\B5\A5ɫ\A3\AC\BAڰ\D7\D5\D5Ƭ*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+	{0x00, 0x04}, 
+	{0xd6, 0x40}, 
+     ENDMARKER,
+
+};
+
+/*\B8\BAƬЧ\B9\FB*/
+static struct regval_list module_effect_negative_regs[] =
+{
+	{0x00, 0x04}, 
+	{0xd6, 0x20}, 
+     ENDMARKER,
+
+};
+/*\B8\B4\B9\C5Ч\B9\FB*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+	{0x00, 0x04}, 
+	{0xd6, 0x20}, 
+     ENDMARKER,
+
+};
+#endif
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{	.id   = V4L2_CID_AUTO_WHITE_BALANCE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 1,},
+	{	.id   = V4L2_CID_WHITE_BALANCE_TEMPERATURE, 
+		.min  = 0, 
+		.max  = 3, 
+		.step = 1, 
+		.def  = 1,},
+#if 0
+
+	{	.id   = V4L2_CID_SCENE_EXPOSURE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+	{	.id   = V4L2_CID_PRIVATE_PREV_CAPT, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = ACTS_ISP_PREVIEW_MODE,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+#endif
+#if 1
+	{	.id   = V4L2_CID_GAIN, 
+		.min  = 10,
+		.max  = 0xffff,
+		.step = 1,
+		.def  = 0x50,},
+		
+	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},
+	{	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+
+#endif
+	
+
+#if 0
+	{   .id   = V4L2_CID_EXPOSURE, 
+		.min  = 0, 
+		.max  = 0,
+		.step = 0, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_EXPOSURE_COMP, 
+		.min  = -4, 
+		.max  = 4, 
+		.step = 1, 
+		.def  = 0,},
+
+    {	.id   = V4L2_CID_AF_MODE,
+		.min  = NONE_AF, 
+		.max  = CONTINUE_AF|SINGLE_AF, 
+		.step = 1, 
+		.def  = CONTINUE_AF|SINGLE_AF,},
+	{	.id   = V4L2_CID_AF_STATUS, 
+		.min  = AF_STATUS_DISABLE, 
+		.max  = AF_STATUS_FAIL, 
+		.step = 1, 
+		.def  = AF_STATUS_DISABLE,},
+#endif
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	{	.id   = V4L2_CID_COLORFX, 
+		.max  = 3, 
+		.mask = 0x0, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_EXPOSURE_AUTO, 
+		.max  = 1, 
+		.mask = 0x0, 
+		.def  = 1,},
+	{  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_TEXT, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+	{	
+		.id   = V4L2_CID_FLASH_LED_MODE, 
+		.max  = 3,
+		.mask = 0x0,
+		.def  = 0,
+	},
+	 {
+		.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+		.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+		.mask = 0x0,
+		.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,
+	},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/siv121du/siv121du.c b/drivers/media/i2c/camera/siv121du/siv121du.c
new file mode 100755
index 0000000..a77cd4a
--- /dev/null
+++ b/drivers/media/i2c/camera/siv121du/siv121du.c
@@ -0,0 +1,482 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include"../module_comm/camera_chip_ident.h"
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0)
+			{
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+			}
+		vals++;
+	}
+	return 0;
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+	
+	int ret = 0;
+	int reg_00 = 0x00;
+	int reg_03 = 0x08;
+	ret = camera_i2c_write(client->adapter, 0x00, reg_00); 
+
+	ret = camera_i2c_write(client->adapter, 0x03, reg_03);//reg_0xfe);
+	msleep(10);
+	return ret;
+}
+
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	//ret = camera_i2c_write(client, 0xXXX, &reg_0xXXX);
+	
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	
+	//ret = camera_i2c_write(client, 0xXXX, &reg_0xXXX);
+	
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	//struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+    
+   // ret = camera_i2c_write(client, 0xXXX, &reg_0xXXX);
+    
+	return ret;
+}
+
+
+
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int scene_exposure = ctrl->val;
+	int ret = 0;
+
+
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_NIGHT:  //\CA\D2\C4\DA
+		//ret = camera_write_array(client->adapter, module_scene_night_regs);
+		break;
+	
+	case V4L2_SCENE_MODE_SUNSET:  //\CA\D2\CD\E2
+//		ret = camera_write_array(client->adapter, module_scene_auto_regs);
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+
+	return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	//struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	
+	
+	//ret = camera_i2c_write(client, 0xXXX, &reg_0xXXX);
+	
+	return ret;
+}
+
+
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int auto_white_balance = ctrl->val;
+	int ret = 0;
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	ctrl->cur.val = auto_white_balance;
+
+	return ret;
+}
+
+static int module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	//unsigned int digital_gain = 0;
+	//unsigned int total_gain = 0;
+	int gain_value = 0;
+	int ret = 0;
+
+	int reg_00  = 0x02;
+	
+	ret = camera_i2c_write(client->adapter, 0x00, reg_00);
+
+	ret |= camera_i2c_read(client->adapter, 0xe5, &gain_value);
+
+	if(ret != 0)
+	{
+		printk("[siv121du] get gain error!\n");
+		return -1;
+	}
+	printk("---1func: %s  gain_value: %d---\r\n",__func__,gain_value);
+	gain_value = abs(152-gain_value);
+	ctrl->val = gain_value;
+	printk("---2func: %s  gain_value: %d---\r\n",__func__,gain_value);
+		
+	
+	return gain_value;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	//struct camera_module_priv *priv = to_camera_priv(client);
+
+	return 0;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int exposure_auto = ctrl->val;
+	int ret = 0;
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+//        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	ctrl->cur.val = exposure_auto;
+
+	return 0;
+}
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	//struct camera_module_priv *priv = to_camera_priv(client);
+	
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	//struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	//struct v4l2_subdev *sd = &priv->subdev;
+	//struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	int ret = 0;
+	unsigned int reg_12,reg_00 = 0x04;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_12 = 0x3d;
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		reg_12 = 0x1d;
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		reg_12 = 0x2d;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		reg_12 = 0x0d;
+		break;
+		
+	default:
+		return -ERANGE;
+	}
+	ret = camera_i2c_write(client->adapter, 0x00, reg_00);
+	ret = camera_i2c_write(client->adapter, 0x12, reg_12);
+	
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	unsigned int reg_0x04 = 0x00;
+		int reg_00  = 0x01;
+	int ret;
+	
+	if ((!mirror) && (!flip))
+	{
+		return 0;
+	}
+
+	ret = camera_i2c_write(i2c_adap, 0x00, reg_00);
+
+	if (mirror)
+	{
+		reg_0x04 |= 0x01;
+	}
+	else
+	{
+		reg_0x04 &= (~0x01);
+	}
+	
+	if (flip)
+	{
+		reg_0x04 |= (0x1<<0x1);
+	}
+	else
+	{
+		reg_0x04 &= (~(0x1<<0x1));	
+	}
+	
+		ret = camera_i2c_write(i2c_adap, 0x00, reg_00); 
+
+	ret |= camera_i2c_write(i2c_adap, 0x04, reg_0x04);
+	return ret;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int  		pid;
+
+	const char         	*devname;
+	int ret = 0;
+
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PID, &pid); 
+	switch (pid) 
+    {
+	case CAMERA_MODULE_PID:
+		devname     = CAMERA_MODULE_NAME;
+		priv->model = V4L2_IDENT_SIV121DU;
+		printk("[siv121du] Product ID verified %x\n",pid);
+		break;
+	
+	default:
+		printk("[siv121du] Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+	
+	return ret;
+}
+
diff --git a/drivers/media/i2c/camera/soc5140/Kconfig b/drivers/media/i2c/camera/soc5140/Kconfig
new file mode 100755
index 0000000..6a5ee34
--- /dev/null
+++ b/drivers/media/i2c/camera/soc5140/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config SOC5140
+	tristate "soc5140 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for soc5140 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called soc5140.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/soc5140/Makefile b/drivers/media/i2c/camera/soc5140/Makefile
new file mode 100755
index 0000000..fce4c39
--- /dev/null
+++ b/drivers/media/i2c/camera/soc5140/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SOC5140)	+= soc5140.o
+
diff --git a/drivers/media/i2c/camera/soc5140/module_diff.h b/drivers/media/i2c/camera/soc5140/module_diff.h
new file mode 100755
index 0000000..96a0d04
--- /dev/null
+++ b/drivers/media/i2c/camera/soc5140/module_diff.h
@@ -0,0 +1,1421 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+
+#define CAMERA_MODULE_NAME 		"soc5140"
+#define CAMERA_MODULE_PID		0x2880
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_I2C_REAL_ADDRESS  (0x78 >> 1)
+#define MODULE_I2C_REG_ADDRESS		(0x78 >> 1)
+
+#define I2C_REGS_WIDTH			2
+#define I2C_DATA_WIDTH			2
+
+#define REGLIST_8BIT_START_FLAG  {0xFdFF,0x0000}
+#define REGLIST_8BIT_STOP_FLAG	 {0xFdFF,0xFFFF}
+
+
+#define DELAY_nMS_ARRAY(n)	 	 {0xFF,n}
+
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING
+//V4L2_MBUS_PCLK_SAMPLE_RISING
+
+
+
+
+#define PID						0x0000 /* Product ID Number */
+
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA                                                                           
+#define MODULE_MAX_WIDTH		WIDTH_QSXGA
+#define MODULE_MAX_HEIGHT		HEIGHT_QSXGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		3
+#define DROP_NUM_PREVIEW		3
+static unsigned int frame_rate_vga[]   = {30,};
+static unsigned int frame_rate_720p[]  = {30,};
+static unsigned int frame_rate_1080p[] = {20,};
+
+
+static unsigned int frame_rate_svga[] = {30,};
+
+static unsigned int frame_rate_qsxga[] = {15,};
+
+
+
+static const struct regval_list module_init_regs[] =
+{ 
+	
+	{0x001A, 0x0019}, //SOFT RESET
+     {0x001A, 0x0018},
+	//MCLK=24MHz, preview: 640 x 480@30fps, capture YUV 2592 X 1944@5fps
+	//Load sections in this order even if making changes
+	//LOAD = Step2-PLL_Timing		//PLL, Timing & Flicker 
+	// [PLL_settings]
+	{0x0010, 0x0339},	//PLL Dividers = 832
+	{0x0012, 0x0080},	//PLL P Dividers = 112
+	{0x0014, 0x2025},	//PLL Control: TEST_BYPASS off = 8229
+	{0x001E, 0x0663},	//Pad Slew Pad Config = 1911
+	{0x0022, 0x0048},	//VDD_DIS counter delay
+	{0x002A, 0x7F7F},	//PLL P Dividers 4-5-6 = 32636
+	{0x002C, 0x0000},	//PLL P Dividers 7 = 0
+	{0x002E, 0x0000},	//Sensor Clock Divider = 0
+	{0x0018, 0x4008},	//Standby Control and Status: Out of standby
+	DELAY_nMS_ARRAY(10),
+	{0x3CAA, 0x0F0F},	//Disable Double Samplings
+
+	{0x098E, 0x1000},
+	{0xC86C, 0x0518},	//Output Width (A) = 1304
+	{0xC86E, 0x03D4},	//Output Height (A) = 980
+	{0xC83A, 0x000C},	//Row Start (A) = 12
+	{0xC83C, 0x0018},	//Column Start (A) = 24
+	
+	DELAY_nMS_ARRAY(10),
+	
+	{0xC83E, 0x07B1},	//Row End (A) = 1969
+	{0xC840, 0x0A45},	//Column End (A) = 2629
+	{0xC842, 0x0001},	//Row Speed (A) = 1
+	{0xC844, 0x0103},	//Core Skip X (A) = 259
+	{0xC846, 0x0103},	//Core Skip Y (A) = 259
+	{0xC848, 0x0103},	//Pipe Skip X (A) = 259
+	{0xC84A, 0x0103},	//Pipe Skip Y (A) = 259
+	{0xC84C, 0x00F6},	//Power Mode (A) = 246
+	{0xC84E, 0x0001},	//Bin Mode (A) = 1
+
+	REGLIST_8BIT_START_FLAG,
+	{0xC850, 0x00},		//Orientation (A) = 0    modify
+	{0xC851, 0x00},		//Pixel Order (A) = 0
+	REGLIST_8BIT_STOP_FLAG,
+
+	{0xC852, 0x019C},	//Fine Correction (A) = 412
+	{0xC854, 0x0732},	//Fine IT Min (A) = 1842
+	{0xC856, 0x048E},	//Fine IT Max Margin (A) = 1166
+	{0xC858, 0x0002},	//Coarse IT Min (A) = 2
+	{0xC85A, 0x0001},	//Coarse IT Max Margin (A) = 1
+	{0xC85C, 0x0423},	//Min Frame Lines (A) = 1059
+	{0xC85E, 0xFFFF},	//Max Frame Lines (A) = 65535
+	{0xC860, 0x0423},	//Base Frame Lines (A) = 1059
+	{0xC862, 0x0DBB},	//Min Line Length (A) = 3719
+	{0xC864, 0xFFFE},	//Max Line Length (A) = 65534
+	{0xC866, 0x7F7E},	//P456 Divider (A) = 32636
+	{0xC868, 0x0423},	//Frame Lines (A) = 1059
+	{0xC86A, 0x0DBB},	//Line Length (A) = 3719
+	{0xC870, 0x0014},	//RX FIFO Watermark (A) = 20
+	{0xC8AA, 0x0320}, 	// CAM_OUTPUT_0_IMAGE_WIDTH
+	{0xC8AC, 0x0258}, 	// CAM_OUTPUT_0_IMAGE_HEIGHT
+	{0xC8AE, 0x0001},	//Output_0 Image Format = 1
+	{0xC8B0, 0x0000},	//Output_0 Format Order = 0
+	{0xC8B8, 0x0004},	//Output_0 JPEG control = 4
+	{0xC8A4, 0x0A28},	//Output Width (B) = 2600
+	{0xC8A6, 0x07A0},	//Output Height (B) = 1952
+	{0xC872, 0x0010},	//Row Start (B) = 16
+	{0xC874, 0x001C},	//Column Start (B) = 28
+	{0xC876, 0x07AF},	//Row End (B) = 1967
+	{0xC878, 0x0A43},	//Column End (B) = 2627
+	{0xC87A, 0x0001},	//Row Speed (B) = 1
+	{0xC87C, 0x0101},	//Core Skip X (B) = 257
+	{0xC87E, 0x0101},	//Core Skip Y (B) = 257
+	{0xC880, 0x0101},	//Pipe Skip X (B) = 257
+	{0xC882, 0x0101},	//Pipe Skip Y (B) = 257
+	{0xC884, 0x00F2},	//Power Mode (B) = 242
+	{0xC886, 0x0000},	//Bin Mode (B) = 0
+
+	REGLIST_8BIT_START_FLAG,
+	{0xC888, 0x00},	    //Orientation (B) = 0
+	{0xC889, 0x00},	    //Pixel Order (B) = 0
+	REGLIST_8BIT_STOP_FLAG,
+	
+	{0xC88A, 0x009C},	//Fine Correction (B) = 156
+	{0xC88C, 0x034A},	//Fine IT Min (B) = 842
+	{0xC88E, 0x02A6},	//Fine IT Max Margin (B) = 678
+	{0xC890, 0x0002},	//Coarse IT Min (B) = 2
+	{0xC892, 0x0001},	//Coarse IT Max Margin (B) = 1
+	{0xC894, 0x07EF},	//Min Frame Lines (B) = 2031
+	{0xC896, 0xFFFF},	//Max Frame Lines (B) = 65535
+	{0xC898, 0x07EF},	//Base Frame Lines (B) = 2031
+	{0xC89A, 0x1B31},	//Min Line Length (B) = 7752
+	{0xC89C, 0xFFFE},	//Max Line Length (B) = 65534
+	{0xC89E, 0x7F7F},	//P456 Divider (B) = 32636
+	{0xC8A0, 0x07EF},	//Frame Lines (B) = 2031
+	{0xC8A2, 0x1B31},	//Line Length (B) = 7752
+	{0xC8A8, 0x0014},	//RX FIFO Watermark (B) = 20
+	{0xC8C0, 0x0A20},	//Output_1 Image Width = 2592
+	{0xC8C2, 0x0798},	//Output_1 Image Height = 1944
+	{0xC8C4, 0x0001},	//Output_1 Image Format = 1
+	{0xC8C6, 0x0000},	//Output_1 Format Order = 0
+	{0xC8CE, 0x0004},	//Output_1 JPEG control = 4
+	#if 0
+	{0xA010, 0x00DF},	//fd_min_expected50hz_flicker_period = 308
+	{0xA012, 0x00FD},	//fd_max_expected50hz_flicker_period = 328
+	{0xA014, 0x00B6},	//fd_min_expected60hz_flicker_period = 255
+	{0xA016, 0x00D4},	//fd_max_expected60hz_flicker_period = 275
+	{0xA018, 0x0104},	//fd_expected50hz_flicker_period (A) = 318
+	{0xA01A, 0x007B},	//fd_expected50hz_flicker_period (B) = 152
+	{0xA01C, 0x00D7},	//fd_expected60hz_flicker_period (A) = 265
+	{0xA01E, 0x0066},	//fd_expected60hz_flicker_period (B) = 127
+	#endif
+	
+	{0xA010,0x0134},	//fd_min_expected50hz_flicker_period = 303	 
+	{0xA012,0x0148},	//fd_max_expected50hz_flicker_period = 323	 
+	{0xA014,0x00FF},	//fd_min_expected60hz_flicker_period = 251	 
+	{0xA016,0x0113},	//fd_max_expected60hz_flicker_period = 271	 
+	{0xA018,0x013E},	//fd_expected50hz_flicker_period (A) = 313	 
+	{0xA01A,0x0066},	//fd_expected50hz_flicker_period (B) = 77	 
+	{0xA01C,0x0109},	//fd_expected60hz_flicker_period (A) = 261	 
+	{0xA01E,0x0055},	//fd_expected60hz_flicker_period (B) = 64	 
+	
+	REGLIST_8BIT_START_FLAG,
+	{0xDC0A, 0x06},  	//Scaler Allow Zoom Ratio = 6
+	
+	REGLIST_8BIT_STOP_FLAG,
+	
+	{0xDC1C, 0x2710},	//System Zoom Ratio = 10000
+    //{0xE004, 0x1E00},	//I2C Master Clock Divider = 7680
+	//LOAD = Step3-Recommended		//Patch & Char settings
+	//k28a_rev3_FW_patch
+
+	{0x0982, 0x0000}, 	// ACCESS_CTL_STAT
+
+	{0x098A, 0x0000}, 	// PHYSICAL_ADDRESS_ACCESS
+	{0x886C, 0xC0F1},
+	{0x886E, 0xC5E1},
+	{0x8870, 0x246A},
+	{0x8872, 0x1280},
+	{0x8874, 0xC4E1},
+	{0x8876, 0xD20F},
+	{0x8878, 0x2069},
+	{0x887A, 0x0000},
+	{0x887C, 0x6A62},
+	{0x887E, 0x1303},
+	{0x8880, 0x0084},
+	{0x8882, 0x1734},
+	{0x8884, 0x7005},
+	{0x8886, 0xD801},
+	{0x8888, 0x8A41},
+	{0x888A, 0xD900},
+	{0x888C, 0x0D5A},
+	{0x888E, 0x0664},
+	{0x8890, 0x8B61},
+	{0x8892, 0xE80B},
+	{0x8894, 0x000D},
+	{0x8896, 0x0020},
+	{0x8898, 0xD508},
+	{0x889A, 0x1504},
+	{0x889C, 0x1400},
+	{0x889E, 0x7840},
+	{0x88A0, 0xD007},
+	{0x88A2, 0x0DFB},
+	{0x88A4, 0x9004},
+	{0x88A6, 0xC4C1},
+	{0x88A8, 0x2029},
+	{0x88AA, 0x0300},
+	{0x88AC, 0x0219},
+	{0x88AE, 0x06C4},
+	{0x88B0, 0xFF80},
+	{0x88B2, 0x08C4},
+	{0x88B4, 0xFF80},
+	{0x88B6, 0x086C},
+	{0x88B8, 0xFF80},
+	{0x88BA, 0x08C0},
+	{0x88BC, 0xFF80},
+	{0x88BE, 0x08C4},
+	{0x88C0, 0xFF80},
+	{0x88C2, 0x097C},
+	{0x88C4, 0x0001},
+	{0x88C6, 0x0005},
+	{0x88C8, 0x0000},
+	{0x88CA, 0x0000},
+	{0x88CC, 0xC0F1},
+	{0x88CE, 0x0976},
+	{0x88D0, 0x06C4},
+	{0x88D2, 0xD639},
+	{0x88D4, 0x7708},
+	{0x88D6, 0x8E01},
+	{0x88D8, 0x1604},
+	{0x88DA, 0x1091},
+	{0x88DC, 0x2046},
+	{0x88DE, 0x00C1},
+	{0x88E0, 0x202F},
+	{0x88E2, 0x2047},
+	{0x88E4, 0xAE21},
+	{0x88E6, 0x0F8F},
+	{0x88E8, 0x1440},
+	{0x88EA, 0x8EAA},
+	{0x88EC, 0x8E0B},
+	{0x88EE, 0x224A},
+	{0x88F0, 0x2040},
+	{0x88F2, 0x8E2D},
+	{0x88F4, 0xBD08},
+	{0x88F6, 0x7D05},
+	{0x88F8, 0x8E0C},
+	{0x88FA, 0xB808},
+	{0x88FC, 0x7825},
+	{0x88FE, 0x7510},
+	{0x8900, 0x22C2},
+	{0x8902, 0x248C},
+	{0x8904, 0x081D},
+	{0x8906, 0x0363},
+	{0x8908, 0xD9FF},
+	{0x890A, 0x2502},
+	{0x890C, 0x1002},
+	{0x890E, 0x2A05},
+	{0x8910, 0x03FE},
+	{0x8912, 0x0A16},
+	{0x8914, 0x06E4},
+	{0x8916, 0x702F},
+	{0x8918, 0x7810},
+	{0x891A, 0x7D02},
+	{0x891C, 0x7DB0},
+	{0x891E, 0xF00B},
+	{0x8920, 0x78A2},
+	{0x8922, 0x2805},
+	{0x8924, 0x03FE},
+	{0x8926, 0x0A02},
+	{0x8928, 0x06E4},
+	{0x892A, 0x702F},
+	{0x892C, 0x7810},
+	{0x892E, 0x651D},
+	{0x8930, 0x7DB0},
+	{0x8932, 0x7DAF},
+	{0x8934, 0x8E08},
+	{0x8936, 0xBD06},
+	{0x8938, 0xD120},
+	{0x893A, 0xB8C3},
+	{0x893C, 0x78A5},
+	{0x893E, 0xB88F},
+	{0x8940, 0x1908},
+	{0x8942, 0x0024},
+	{0x8944, 0x2841},
+	{0x8946, 0x0201},
+	{0x8948, 0x1E26},
+	{0x894A, 0x1042},
+	{0x894C, 0x0F15},
+	{0x894E, 0x1463},
+	{0x8950, 0x1E27},
+	{0x8952, 0x1002},
+	{0x8954, 0x224C},
+	{0x8956, 0xA000},
+	{0x8958, 0x224A},
+	{0x895A, 0x2040},
+	{0x895C, 0x22C2},
+	{0x895E, 0x2482},
+	{0x8960, 0x204F},
+	{0x8962, 0x2040},
+	{0x8964, 0x224C},
+	{0x8966, 0xA000},
+	{0x8968, 0xB8A2},
+	{0x896A, 0xF204},
+	{0x896C, 0x2045},
+	{0x896E, 0x2180},
+	{0x8970, 0xAE01},
+	{0x8972, 0x0D9E},
+	{0x8974, 0xFFE3},
+	{0x8976, 0x70E9},
+	{0x8978, 0x0125},
+	{0x897A, 0x06C4},
+	{0x897C, 0xC0F1},
+	{0x897E, 0xD010},
+	{0x8980, 0xD110},
+	{0x8982, 0xD20D},
+	{0x8984, 0xA020},
+	{0x8986, 0x8A00},
+	{0x8988, 0x0809},
+	{0x898A, 0x01DE},
+	{0x898C, 0xB8A7},
+	{0x898E, 0xAA00},
+	{0x8990, 0xDBFF},
+	{0x8992, 0x2B41},
+	{0x8994, 0x0200},
+	{0x8996, 0xAA0C},
+	{0x8998, 0x1228},
+	{0x899A, 0x0080},
+	{0x899C, 0xAA6D},
+	{0x899E, 0x0815},
+	{0x89A0, 0x01DE},
+	{0x89A2, 0xB8A7},
+	{0x89A4, 0x1A28},
+	{0x89A6, 0x0002},
+	{0x89A8, 0x8123},
+	{0x89AA, 0x7960},
+	{0x89AC, 0x1228},
+	{0x89AE, 0x0080},
+	{0x89B0, 0xC0D1},
+	{0x89B2, 0x7EE0},
+	{0x89B4, 0xFF80},
+	{0x89B6, 0x0158},
+	{0x89B8, 0xFF00},
+	{0x89BA, 0x0618},
+	{0x89BC, 0x8000},
+	{0x89BE, 0x0008},
+	{0x89C0, 0xFF80},
+	{0x89C2, 0x0A08},
+	{0x89C4, 0xE280},
+	{0x89C6, 0x24CA},
+	{0x89C8, 0x7082},
+	{0x89CA, 0x78E0},
+	{0x89CC, 0x20E8},
+	{0x89CE, 0x01A2},
+	{0x89D0, 0x1002},
+	{0x89D2, 0x0D02},
+	{0x89D4, 0x1902},
+	{0x89D6, 0x0094},
+	{0x89D8, 0x7FE0},
+	{0x89DA, 0x7028},
+	{0x89DC, 0x7308},
+	{0x89DE, 0x1000},
+	{0x89E0, 0x0900},
+	{0x89E2, 0x7904},
+	{0x89E4, 0x7947},
+	{0x89E6, 0x1B00},
+	{0x89E8, 0x0064},
+	{0x89EA, 0x7EE0},
+	{0x89EC, 0xE280},
+	{0x89EE, 0x24CA},
+	{0x89F0, 0x7082},
+	{0x89F2, 0x78E0},
+	{0x89F4, 0x20E8},
+	{0x89F6, 0x01A2},
+	{0x89F8, 0x1102},
+	{0x89FA, 0x0502},
+	{0x89FC, 0x1802},
+	{0x89FE, 0x00B4},
+	{0x8A00, 0x7FE0},
+	{0x8A02, 0x7028},
+	{0x8A04, 0x0000},
+	{0x8A06, 0x0000},
+	{0x8A08, 0xFF80},
+	{0x8A0A, 0x097C},
+	{0x8A0C, 0xFF80},
+	{0x8A0E, 0x08CC},
+	{0x8A10, 0x0000},
+	{0x8A12, 0x08DC},
+	{0x8A14, 0x0000},
+	{0x8A16, 0x0998},
+	{0x098E, 0x0016}, 	// LOGICAL_ADDRESS_ACCESS [MON_ADDRESS_LO]
+	{0x8016, 0x086C}, 	// MON_ADDRESS_LO 
+	{0x8002, 0x0001}, 	// MON_CMD
+	DELAY_nMS_ARRAY(10),
+	{0x098E, 0xC40C}, 	// LOGICAL_ADDRESS_ACCESS
+	{0xC40C, 0x00FF}, 	// AFM_POS_MAX
+	{0xC40A, 0x0000}, 	// AFM_POS_MIN
+	{0x30D4, 0x9080}, 	// COLUMN_CORRECTION
+	{0x316E, 0xCAFF}, 	// DAC_ECL
+	{0x305E, 0x10A0}, 	// GLOBAL_GAIN
+	{0x3E00, 0x0010}, 	// SAMP_CONTROL
+	{0x3E02, 0xED02}, 	// SAMP_ADDR_EN
+	{0x3E04, 0xC88C}, 	// SAMP_RD1_SIG
+	{0x3E06, 0xC88C}, 	// SAMP_RD1_SIG_BOOST
+	{0x3E08, 0x700A}, 	// SAMP_RD1_RST
+	{0x3E0A, 0x701E}, 	// SAMP_RD1_RST_BOOST
+	{0x3E0C, 0x00FF}, 	// SAMP_RST1_EN
+	{0x3E0E, 0x00FF}, 	// SAMP_RST1_BOOST
+	{0x3E10, 0x00FF}, 	// SAMP_RST1_CLOOP_SH
+	{0x3E12, 0x0000}, 	// SAMP_RST_BOOST_SEQ
+	{0x3E14, 0xC78C}, 	// SAMP_SAMP1_SIG
+	{0x3E16, 0x6E06}, 	// SAMP_SAMP1_RST
+	{0x3E18, 0xA58C}, 	// SAMP_TX_EN
+	{0x3E1A, 0xA58E}, 	// SAMP_TX_BOOST
+	{0x3E1C, 0xA58E}, 	// SAMP_TX_CLOOP_SH
+	{0x3E1E, 0xC0D0}, 	// SAMP_TX_BOOST_SEQ
+	{0x3E20, 0xEB00}, 	// SAMP_VLN_EN
+	{0x3E22, 0x00FF}, 	// SAMP_VLN_HOLD
+	{0x3E24, 0xEB02}, 	// SAMP_VCL_EN
+	{0x3E26, 0xEA02}, 	// SAMP_COLCLAMP
+	{0x3E28, 0xEB0A}, 	// SAMP_SH_VCL
+	{0x3E2A, 0xEC01}, 	// SAMP_SH_VREF
+	{0x3E2C, 0xEB01}, 	// SAMP_SH_VBST
+	{0x3E2E, 0x00FF}, 	// SAMP_SPARE
+	{0x3E30, 0x00F3}, 	// SAMP_READOUT
+	{0x3E32, 0x3DFA}, 	// SAMP_RESET_DONE
+	{0x3E34, 0x00FF}, 	// SAMP_VLN_CLAMP
+	{0x3E36, 0x00F3}, 	// SAMP_ASC_INT
+	{0x3E38, 0x0000}, 	// SAMP_RS_CLOOP_SH_R
+	{0x3E3A, 0xF802}, 	// SAMP_RS_CLOOP_SH
+	{0x3E3C, 0x0FFF}, 	// SAMP_RS_BOOST_SEQ
+	{0x3E3E, 0xEA10}, 	// SAMP_TXLO_GND
+	{0x3E40, 0xEB05}, 	// SAMP_VLN_PER_COL
+	{0x3E42, 0xE5C8}, 	// SAMP_RD2_SIG
+	{0x3E44, 0xE5C8}, 	// SAMP_RD2_SIG_BOOST
+	{0x3E46, 0x8C70}, 	// SAMP_RD2_RST
+	{0x3E48, 0x8C71}, 	// SAMP_RD2_RST_BOOST
+	{0x3E4A, 0x00FF}, 	// SAMP_RST2_EN
+	{0x3E4C, 0x00FF}, 	// SAMP_RST2_BOOST
+	{0x3E4E, 0x00FF}, 	// SAMP_RST2_CLOOP_SH
+	{0x3E50, 0xE38D}, 	// SAMP_SAMP2_SIG
+	{0x3E52, 0x8B0A}, 	// SAMP_SAMP2_RST
+	{0x3E58, 0xEB0A}, 	// SAMP_PIX_CLAMP_EN
+	{0x3E5C, 0x0A00}, 	// SAMP_PIX_PULLUP_EN
+	{0x3E5E, 0x00FF}, 	// SAMP_PIX_PULLDOWN_EN_R
+	{0x3E60, 0x00FF}, 	// SAMP_PIX_PULLDOWN_EN_S
+	{0x3E90, 0x3C01}, 	// RST_ADDR_EN
+	{0x3E92, 0x00FF}, 	// RST_RST_EN
+	{0x3E94, 0x00FF}, 	// RST_RST_BOOST
+	{0x3E96, 0x3C00}, 	// RST_TX_EN
+	{0x3E98, 0x3C00}, 	// RST_TX_BOOST
+	{0x3E9A, 0x3C00}, 	// RST_TX_CLOOP_SH
+	{0x3E9C, 0xC0E0}, 	// RST_TX_BOOST_SEQ
+	{0x3E9E, 0x00FF}, 	// RST_RST_CLOOP_SH
+	{0x3EA0, 0x0000}, 	// RST_RST_BOOST_SEQ
+	{0x3EA6, 0x3C00}, 	// RST_PIX_PULLUP_EN
+	{0x3ED8, 0x3057}, 	// DAC_LD_12_13
+	{0x316C, 0xB44F}, 	// DAC_TXLO
+	{0x316E, 0xCAFF}, 	// DAC_ECL
+	{0x3ED2, 0xEA0A}, 	// DAC_LD_6_7
+	{0x3ED4, 0x00A3}, 	// DAC_LD_8_9
+	{0x3EDC, 0x6020}, 	// DAC_LD_16_17
+	{0x3EE6, 0xA541}, 	// DAC_LD_26_27
+	{0x31E0, 0x0000}, 	// PIX_DEF_ID
+	{0x3ED0, 0x2409}, 	// DAC_LD_4_5
+	{0x3EDE, 0x0A49}, 	// DAC_LD_18_19
+	{0x3EE0, 0x4910}, 	// DAC_LD_20_21
+	{0x3EE2, 0x09D2}, 	// DAC_LD_22_23
+	{0x30B6, 0x0006}, 	// AUTOLR_CONTROL
+	{0x337C, 0x0006}, 	// YUV_YCBCR_CONTROL
+	{0x3210, 0x49B0}, 	// COLOR_PIPELINE_CONTROL 
+	{0x337C, 0x0006},  	// YUV_YCBCR_CONTROL
+
+	{0x3640, 0x00D0},	// P_G1_P0Q0	
+	{0x3642, 0x5A2C},	// P_G1_P0Q1	
+	{0x3644, 0x2FF1},	// P_G1_P0Q2	
+	{0x3646, 0xD9A9},	// P_G1_P0Q3	
+	{0x3648, 0xB710},	// P_G1_P0Q4	
+	{0x364A, 0x0350},	// P_R_P0Q0 	
+	{0x364C, 0x800D},	// P_R_P0Q1 	
+	{0x364E, 0x35F0},	// P_R_P0Q2 	
+	{0x3650, 0x176F},	// P_R_P0Q3 	
+	{0x3652, 0x8F0F},	// P_R_P0Q4 	
+	{0x3654, 0x0370},	// P_B_P0Q0 	
+	{0x3656, 0x08ED},	// P_B_P0Q1 	
+	{0x3658, 0x2190},	// P_B_P0Q2 	
+	{0x365A, 0xF3AD},	// P_B_P0Q3 	
+	{0x365C, 0x832F},	// P_B_P0Q4 	
+	{0x365E, 0x0ED0},	// P_G2_P0Q0	
+	{0x3660, 0xBB2E},	// P_G2_P0Q1	
+	{0x3662, 0x4911},	// P_G2_P0Q2	
+	{0x3664, 0x382F},	// P_G2_P0Q3	
+	{0x3666, 0x85B1},	// P_G2_P0Q4	
+	{0x3680, 0x978B},	// P_G1_P1Q0	
+	{0x3682, 0x858E},	// P_G1_P1Q1	
+	{0x3684, 0x41CD},	// P_G1_P1Q2	
+	{0x3686, 0x322D},	// P_G1_P1Q3	
+	{0x3688, 0xE1CE},	// P_G1_P1Q4	
+	{0x368A, 0x19AE},	// P_R_P1Q0 	
+	{0x368C, 0x20EE},	// P_R_P1Q1 	
+	{0x368E, 0x862F},	// P_R_P1Q2 	
+	{0x3690, 0xD50E},	// P_R_P1Q3 	
+	{0x3692, 0x26CA},	// P_R_P1Q4 	
+	{0x3694, 0xBDAD},	// P_B_P1Q0 	
+	{0x3696, 0x508B},	// P_B_P1Q1 	
+	{0x3698, 0x272D},	// P_B_P1Q2 	
+	{0x369A, 0xD48E},	// P_B_P1Q3 	
+	{0x369C, 0x8A8F},	// P_B_P1Q4 	
+	{0x369E, 0xDB2C},	// P_G2_P1Q0	
+	{0x36A0, 0x9E4E},	// P_G2_P1Q1	
+	{0x36A2, 0xC18D},	// P_G2_P1Q2	
+	{0x36A4, 0x0FCF},	// P_G2_P1Q3	
+	{0x36A6, 0x2E8E},	// P_G2_P1Q4	
+	{0x36C0, 0x57B1},	// P_G1_P2Q0	
+	{0x36C2, 0x0CCF},	// P_G1_P2Q1	
+	{0x36C4, 0xCD91},	// P_G1_P2Q2	
+	{0x36C6, 0xB94F},	// P_G1_P2Q3	
+	{0x36C8, 0x5091},	// P_G1_P2Q4	
+	{0x36CA, 0x27F1},	// P_R_P2Q0 	
+	{0x36CC, 0x8968},	// P_R_P2Q1 	
+	{0x36CE, 0xE630},	// P_R_P2Q2 	
+	{0x36D0, 0x9EB0},	// P_R_P2Q3 	
+	{0x36D2, 0x0DF2},	// P_R_P2Q4 	
+	{0x36D4, 0x1531},	// P_B_P2Q0 	
+	{0x36D6, 0x3D8F},	// P_B_P2Q1 	
+	{0x36D8, 0xB351},	// P_B_P2Q2 	
+	{0x36DA, 0x9AB0},	// P_B_P2Q3 	
+	{0x36DC, 0x6C52},	// P_B_P2Q4 	
+	{0x36DE, 0x6E31},	// P_G2_P2Q0	
+	{0x36E0, 0x418C},	// P_G2_P2Q1	
+	{0x36E2, 0xC292},	// P_G2_P2Q2	
+	{0x36E4, 0xE650},	// P_G2_P2Q3	
+	{0x36E6, 0x1193},	// P_G2_P2Q4	
+	{0x3700, 0x6F4F},	// P_G1_P3Q0	
+	{0x3702, 0x248B},	// P_G1_P3Q1	
+	{0x3704, 0x946B},	// P_G1_P3Q2	
+	{0x3706, 0xEE4E},	// P_G1_P3Q3	
+	{0x3708, 0x5330},	// P_G1_P3Q4	
+	{0x370A, 0x07D0},	// P_R_P3Q0 	
+	{0x370C, 0xD12B},	// P_R_P3Q1 	
+	{0x370E, 0xAB10},	// P_R_P3Q2 	
+	{0x3710, 0x810F},	// P_R_P3Q3 	
+	{0x3712, 0x5052},	// P_R_P3Q4 	
+	{0x3714, 0xA16F},	// P_B_P3Q0 	
+	{0x3716, 0x9F4E},	// P_B_P3Q1 	
+	{0x3718, 0x1872},	// P_B_P3Q2 	
+	{0x371A, 0x0250},	// P_B_P3Q3 	
+	{0x371C, 0xADB2},	// P_B_P3Q4 	
+	{0x371E, 0x47CD},	// P_G2_P3Q0	
+	{0x3720, 0x156E},	// P_G2_P3Q1	
+	{0x3722, 0x5D91},	// P_G2_P3Q2	
+	{0x3724, 0xC9D1},	// P_G2_P3Q3	
+	{0x3726, 0xC530},	// P_G2_P3Q4	
+	{0x3740, 0x86B1},	// P_G1_P4Q0	
+	{0x3742, 0x8ED0},	// P_G1_P4Q1	
+	{0x3744, 0xB12E},	// P_G1_P4Q2	
+	{0x3746, 0x5FF2},	// P_G1_P4Q3	
+	{0x3748, 0x01B1},	// P_G1_P4Q4	
+	{0x374A, 0x9CB1},	// P_R_P4Q0 	
+	{0x374C, 0x81F0},	// P_R_P4Q1 	
+	{0x374E, 0x1733},	// P_R_P4Q2 	
+	{0x3750, 0x2BF2},	// P_R_P4Q3 	
+	{0x3752, 0xF133},	// P_R_P4Q4 	
+	{0x3754, 0xC04F},	// P_B_P4Q0 	
+	{0x3756, 0xB070},	// P_B_P4Q1 	
+	{0x3758, 0x1AD0},	// P_B_P4Q2 	
+	{0x375A, 0x4F92},	// P_B_P4Q3 	
+	{0x375C, 0xF971},	// P_B_P4Q4 	
+	{0x375E, 0xAC11},	// P_G2_P4Q0	
+	{0x3760, 0xC28F},	// P_G2_P4Q1	
+	{0x3762, 0x34D2},	// P_G2_P4Q2	
+	{0x3764, 0x0AD3},	// P_G2_P4Q3	
+	{0x3766, 0xBF33},	// P_G2_P4Q4	
+	{0x3782, 0x0300},	// CENTER_ROW	
+	{0x3784, 0x04F4},	// CENTER_COLUMN
+
+	{0x3210, 0x49B8},  	// COLOR_PIPELINE_CONTROL
+	{0x098E, 0xAC01}, 	// LOGICAL_ADDRESS_ACCESS [AWB_MODE]
+
+	REGLIST_8BIT_START_FLAG,
+	{0xAC01, 0xAB}, 	// AWB_MODE
+	REGLIST_8BIT_STOP_FLAG,
+	//
+	//[AWB and CCMs 06/26/14 14:12:30]
+	{0x098E, 0x2C46},	// LOGICAL_ADDRESS_ACCESS [AWB_LEFT_CCM_0]
+	{0xAC46, 0x0221},	// AWB_LEFT_CCM_0
+	{0xAC48, 0xFEAE},	// AWB_LEFT_CCM_1
+	{0xAC4A, 0x0032},	// AWB_LEFT_CCM_2
+	{0xAC4C, 0xFFA1},	// AWB_LEFT_CCM_3
+	{0xAC4E, 0x0187},	// AWB_LEFT_CCM_4
+	{0xAC50, 0xFFD8},	// AWB_LEFT_CCM_5
+	{0xAC52, 0xFFB1},	// AWB_LEFT_CCM_6
+	{0xAC54, 0xFEC5},	// AWB_LEFT_CCM_7
+	{0xAC56, 0x028A},	// AWB_LEFT_CCM_8                                         
+	{0xAC58, 0x0118},	// AWB_LEFT_CCM_R2BRATIO                                         
+	{0xAC5C, 0x02F7},	// AWB_RIGHT_CCM_0                                         
+	{0xAC5E, 0xFE0F},	// AWB_RIGHT_CCM_1                                         
+	{0xAC60, 0xFFF5},	// AWB_RIGHT_CCM_2                                         
+	{0xAC62, 0xFFCB},	// AWB_RIGHT_CCM_3                                         
+	{0xAC64, 0x0139},	// AWB_RIGHT_CCM_4                                         
+	{0xAC66, 0xFFF9},	// AWB_RIGHT_CCM_5                                         
+	{0xAC68, 0x0047},	// AWB_RIGHT_CCM_6                                         
+	{0xAC6A, 0xFE34},	// AWB_RIGHT_CCM_7                                         
+	{0xAC6C, 0x033A},	// AWB_RIGHT_CCM_8                                         
+	{0xAC6E, 0x0070},	// AWB_RIGHT_CCM_R2BRATIO  
+	REGLIST_8BIT_START_FLAG,
+	{0xB83E, 0x00},	// STAT_AWB_WINDOW_POS_X                                         
+	{0xB83F, 0x00},	// STAT_AWB_WINDOW_POS_Y                                         
+	{0xB840, 0xFF},	// STAT_AWB_WINDOW_SIZE_X                                         
+	{0xB841, 0xEF},	// STAT_AWB_WINDOW_SIZE_Y 
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0x3842}, 	// LOGICAL_ADDRESS_ACCESS [STAT_AWB_GRAY_CHECKER_OFFSET_X]
+	{0xB842, 0x0037}, 	// STAT_AWB_GRAY_CHECKER_OFFSET_X
+	{0xB844, 0x0044}, 	// STAT_AWB_GRAY_CHECKER_OFFSET_Y
+	{0x3240, 0x0024}, 	// AWB_XY_SCALE
+	{0x3240, 0x0024}, 	// AWB_XY_SCALE
+	{0x3242, 0x0000}, 	// AWB_WEIGHT_R0
+	{0x3244, 0x0000}, 	// AWB_WEIGHT_R1
+	{0x3246, 0x0000}, 	// AWB_WEIGHT_R2
+	{0x3248, 0x7F00}, 	// AWB_WEIGHT_R3
+	{0x324A, 0xA500}, 	// AWB_WEIGHT_R4
+	{0x324C, 0x1540}, 	// AWB_WEIGHT_R5
+	{0x324E, 0x01AC}, 	// AWB_WEIGHT_R6
+	{0x3250, 0x003E}, 	// AWB_WEIGHT_R7
+	{0x098E, 0xAC3C}, 	// LOGICAL_ADDRESS_ACCESS [AWB_MIN_ACCEPTED_PRE_AWB_R2G_RATIO]
+
+	REGLIST_8BIT_START_FLAG,
+	{0xAC3C, 0x2E}, 	// AWB_MIN_ACCEPTED_PRE_AWB_R2G_RATIO
+	{0xAC3D, 0x84}, 	// AWB_MAX_ACCEPTED_PRE_AWB_R2G_RATIO
+	{0xAC3E, 0x11}, 	// AWB_MIN_ACCEPTED_PRE_AWB_B2G_RATIO
+	{0xAC3F, 0x63}, 	// AWB_MAX_ACCEPTED_PRE_AWB_B2G_RATIO
+	{0xACB0, 0x2B}, 	// AWB_RG_MIN
+	{0xACB1, 0x84}, 	// AWB_RG_MAX
+	{0xACB4, 0x11}, 	// AWB_BG_MIN
+	{0xACB5, 0x63}, 	// AWB_BG_MAX
+	REGLIST_8BIT_STOP_FLAG,
+	
+	{0x098E, 0xD80F}, 	// LOGICAL_ADDRESS_ACCESS [JPEG_QSCALE_0]
+
+	REGLIST_8BIT_START_FLAG,
+	{0xD80F, 0x04}, 	// JPEG_QSCALE_0
+	{0xD810, 0x08}, 	// JPEG_QSCALE_1
+	{0xC8D2, 0x04}, 	// CAM_OUTPUT_1_JPEG_QSCALE_0
+	{0xC8D3, 0x08}, 	// CAM_OUTPUT_1_JPEG_QSCALE_1
+	{0xC8BC, 0x04}, 	// CAM_OUTPUT_0_JPEG_QSCALE_0
+	{0xC8BD, 0x08}, 	// CAM_OUTPUT_0_JPEG_QSCALE_1
+	REGLIST_8BIT_STOP_FLAG,
+	
+	{0x301A, 0x10F4}, 	// RESET_REGISTER
+	{0x301E, 0x0000}, 	// DATA_PEDESTAL
+	{0x301A, 0x10FC}, 	// RESET_REGISTER
+	{0x098E, 0xDC33}, 	// LOGICAL_ADDRESS_ACCESS [SYS_FIRST_BLACK_LEVEL]
+
+	REGLIST_8BIT_START_FLAG,
+	{0xDC33, 0x00}, 	// SYS_FIRST_BLACK_LEVEL
+	{0xDC35, 0x04}, 	// SYS_UV_COLOR_BOOST
+	REGLIST_8BIT_STOP_FLAG,
+	
+	{0x326E, 0x0006}, 	// LOW_PASS_YUV_FILTER
+	REGLIST_8BIT_START_FLAG,
+	{0xDC37, 0x62}, 	// SYS_BRIGHT_COLORKILL
+	REGLIST_8BIT_STOP_FLAG,
+	{0x35A4, 0x0596}, 	// BRIGHT_COLOR_KILL_CONTROLS
+	{0x35A2, 0x0094}, 	// DARK_COLOR_KILL_CONTROLS
+	REGLIST_8BIT_START_FLAG,
+	{0xDC36, 0x23}, 	// SYS_DARK_COLOR_KILL
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0xBC18}, 	// LOGICAL_ADDRESS_ACCESS [LL_GAMMA_CONTRAST_CURVE_0]
+	REGLIST_8BIT_START_FLAG,
+	{0xBC18, 0x00}, 	// LL_GAMMA_CONTRAST_CURVE_0
+	{0xBC19, 0x11}, 	// LL_GAMMA_CONTRAST_CURVE_1
+	{0xBC1A, 0x23}, 	// LL_GAMMA_CONTRAST_CURVE_2
+	{0xBC1B, 0x3F}, 	// LL_GAMMA_CONTRAST_CURVE_3
+	{0xBC1C, 0x67}, 	// LL_GAMMA_CONTRAST_CURVE_4
+	{0xBC1D, 0x85}, 	// LL_GAMMA_CONTRAST_CURVE_5
+	{0xBC1E, 0x9B}, 	// LL_GAMMA_CONTRAST_CURVE_6
+	{0xBC1F, 0xAD}, 	// LL_GAMMA_CONTRAST_CURVE_7
+	{0xBC20, 0xBB}, 	// LL_GAMMA_CONTRAST_CURVE_8
+	{0xBC21, 0xC7}, 	// LL_GAMMA_CONTRAST_CURVE_9
+	{0xBC22, 0xD1}, 	// LL_GAMMA_CONTRAST_CURVE_10
+	{0xBC23, 0xDA}, 	// LL_GAMMA_CONTRAST_CURVE_11
+	{0xBC24, 0xE1}, 	// LL_GAMMA_CONTRAST_CURVE_12
+	{0xBC25, 0xE8}, 	// LL_GAMMA_CONTRAST_CURVE_13
+	{0xBC26, 0xEE}, 	// LL_GAMMA_CONTRAST_CURVE_14
+	{0xBC27, 0xF3}, 	// LL_GAMMA_CONTRAST_CURVE_15
+	{0xBC28, 0xF7}, 	// LL_GAMMA_CONTRAST_CURVE_16
+	{0xBC29, 0xFB}, 	// LL_GAMMA_CONTRAST_CURVE_17
+	{0xBC2A, 0xFF}, 	// LL_GAMMA_CONTRAST_CURVE_18
+	{0xBC2B, 0x00}, 	// LL_GAMMA_NEUTRAL_CURVE_0
+	{0xBC2C, 0x11}, 	// LL_GAMMA_NEUTRAL_CURVE_1
+	{0xBC2D, 0x23}, 	// LL_GAMMA_NEUTRAL_CURVE_2
+	{0xBC2E, 0x3F}, 	// LL_GAMMA_NEUTRAL_CURVE_3
+	{0xBC2F, 0x67}, 	// LL_GAMMA_NEUTRAL_CURVE_4
+	{0xBC30, 0x85}, 	// LL_GAMMA_NEUTRAL_CURVE_5
+	{0xBC31, 0x9B}, 	// LL_GAMMA_NEUTRAL_CURVE_6
+	{0xBC32, 0xAD}, 	// LL_GAMMA_NEUTRAL_CURVE_7
+	{0xBC33, 0xBB}, 	// LL_GAMMA_NEUTRAL_CURVE_8
+	{0xBC34, 0xC7}, 	// LL_GAMMA_NEUTRAL_CURVE_9
+	{0xBC35, 0xD1}, 	// LL_GAMMA_NEUTRAL_CURVE_10
+	{0xBC36, 0xDA}, 	// LL_GAMMA_NEUTRAL_CURVE_11
+	{0xBC37, 0xE1}, 	// LL_GAMMA_NEUTRAL_CURVE_12
+	{0xBC38, 0xE8}, 	// LL_GAMMA_NEUTRAL_CURVE_13
+	{0xBC39, 0xEE}, 	// LL_GAMMA_NEUTRAL_CURVE_14
+	{0xBC3A, 0xF3}, 	// LL_GAMMA_NEUTRAL_CURVE_15
+	{0xBC3B, 0xF7}, 	// LL_GAMMA_NEUTRAL_CURVE_16
+	{0xBC3C, 0xFB}, 	// LL_GAMMA_NEUTRAL_CURVE_17
+	{0xBC3D, 0xFF}, 	// LL_GAMMA_NEUTRAL_CURVE_18
+	{0xBC3E, 0x00}, 	// LL_GAMMA_NR_CURVE_0
+	{0xBC3F, 0x18}, 	// LL_GAMMA_NR_CURVE_1
+	{0xBC40, 0x25}, 	// LL_GAMMA_NR_CURVE_2
+	{0xBC41, 0x3A}, 	// LL_GAMMA_NR_CURVE_3
+	{0xBC42, 0x59}, 	// LL_GAMMA_NR_CURVE_4
+	{0xBC43, 0x70}, 	// LL_GAMMA_NR_CURVE_5
+	{0xBC44, 0x81}, 	// LL_GAMMA_NR_CURVE_6
+	{0xBC45, 0x90}, 	// LL_GAMMA_NR_CURVE_7
+	{0xBC46, 0x9E}, 	// LL_GAMMA_NR_CURVE_8
+	{0xBC47, 0xAB}, 	// LL_GAMMA_NR_CURVE_9
+	{0xBC48, 0xB6}, 	// LL_GAMMA_NR_CURVE_10
+	{0xBC49, 0xC1}, 	// LL_GAMMA_NR_CURVE_11
+	{0xBC4A, 0xCB}, 	// LL_GAMMA_NR_CURVE_12
+	{0xBC4B, 0xD5}, 	// LL_GAMMA_NR_CURVE_13
+	{0xBC4C, 0xDE}, 	// LL_GAMMA_NR_CURVE_14
+	{0xBC4D, 0xE7}, 	// LL_GAMMA_NR_CURVE_15
+	{0xBC4E, 0xEF}, 	// LL_GAMMA_NR_CURVE_16
+	{0xBC4F, 0xF7}, 	// LL_GAMMA_NR_CURVE_17
+	{0xBC50, 0xFF}, 	// LL_GAMMA_NR_CURVE_18
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0xB801}, 	// LOGICAL_ADDRESS_ACCESS [STAT_MODE]
+	REGLIST_8BIT_START_FLAG,
+	{0xB801, 0xE0}, 	// STAT_MODE
+	{0xB862, 0x04}, 	// STAT_BMTRACKING_SPEED
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0xB829}, 	// LOGICAL_ADDRESS_ACCESS [STAT_LL_BRIGHTNESS_METRIC_DIVISOR]
+	REGLIST_8BIT_START_FLAG,
+	{0xB829, 0x02}, 	// STAT_LL_BRIGHTNESS_METRIC_DIVISOR
+	{0xB863, 0x02}, 	// STAT_BM_MUL
+	{0xB827, 0x0F}, 	// STAT_AE_EV_SHIFT
+	//{0xA409, 0x37}, 	// AE_RULE_BASE_TARGET
+	{0xA409, 0x27},	 // AE_RULE_BASE_TARGET   \A8\A2\A8\A2?\A8\A8
+	REGLIST_8BIT_STOP_FLAG,
+	{0x337E, 0x2000},
+	{0x098E, 0x3C52}, 	// LOGICAL_ADDRESS_ACCESS [LL_START_BRIGHTNESS_METRIC]
+	{0xBC52, 0x00C8}, 	// LL_START_BRIGHTNESS_METRIC
+	{0xBC54, 0x0A28}, 	// LL_END_BRIGHTNESS_METRIC
+	{0xBC58, 0x00C8}, 	// LL_START_GAIN_METRIC
+	{0xBC5A, 0x12C0}, 	// LL_END_GAIN_METRIC
+	{0xBC5E, 0x00FA}, 	// LL_START_APERTURE_GAIN_BM
+	{0xBC60, 0x0258}, 	// LL_END_APERTURE_GAIN_BM
+	{0xBC66, 0x00FA}, 	// LL_START_APERTURE_GM
+	{0xBC68, 0x0258}, 	// LL_END_APERTURE_GM
+	{0xBC86, 0x00C8}, 	// LL_START_FFNR_GM
+	{0xBC88, 0x0640}, 	// LL_END_FFNR_GM
+	{0xBCBC, 0x0040}, 	// LL_SFFB_START_GAIN
+	{0xBCBE, 0x01FC}, 	// LL_SFFB_END_GAIN
+	{0xBCCC, 0x00C8}, 	// LL_SFFB_START_MAX_GM
+	{0xBCCE, 0x0640}, 	// LL_SFFB_END_MAX_GM
+	{0xBC90, 0x00C8}, 	// LL_START_GRB_GM
+	{0xBC92, 0x0640}, 	// LL_END_GRB_GM
+	{0xBC0E, 0x0001}, 	// LL_GAMMA_CURVE_ADJ_START_POS
+	{0xBC10, 0x0002}, 	// LL_GAMMA_CURVE_ADJ_MID_POS
+	{0xBC12, 0x02BC}, 	// LL_GAMMA_CURVE_ADJ_END_POS
+	{0xBCAA, 0x044C}, 	// LL_CDC_THR_ADJ_START_POS
+	{0xBCAC, 0x00AF}, 	// LL_CDC_THR_ADJ_MID_POS
+	{0xBCAE, 0x0009}, 	// LL_CDC_THR_ADJ_END_POS
+	{0xBCD8, 0x00C8}, 	// LL_PCR_START_BM
+	{0xBCDA, 0x0A28}, 	// LL_PCR_END_BM
+	{0x3380, 0x0504}, 	// KERNEL_CONFIG
+	{0x098E, 0xBC94}, 	// LOGICAL_ADDRESS_ACCESS [LL_GB_START_THRESHOLD_0]
+	REGLIST_8BIT_START_FLAG,
+	{0xBC94, 0x0C}, 	// LL_GB_START_THRESHOLD_0
+	{0xBC95, 0x08}, 	// LL_GB_START_THRESHOLD_1
+	{0xBC9C, 0x3C}, 	// LL_GB_END_THRESHOLD_0
+	{0xBC9D, 0x28}, 	// LL_GB_END_THRESHOLD_1
+	REGLIST_8BIT_STOP_FLAG,
+	{0x33B0, 0x2A16}, 	// FFNR_ALPHA_BETA
+	{0x098E, 0xBC8A}, 	// LOGICAL_ADDRESS_ACCESS [LL_START_FF_MIX_THRESH_Y]
+	REGLIST_8BIT_START_FLAG,
+	{0xBC8A, 0x02}, 	// LL_START_FF_MIX_THRESH_Y
+	{0xBC8B, 0x0F}, 	// LL_END_FF_MIX_THRESH_Y
+	{0xBC8C, 0xFF}, 	// LL_START_FF_MIX_THRESH_YGAIN
+	{0xBC8D, 0xFF}, 	// LL_END_FF_MIX_THRESH_YGAIN
+	{0xBC8E, 0xFF}, 	// LL_START_FF_MIX_THRESH_GAIN
+	{0xBC8F, 0x00}, 	// LL_END_FF_MIX_THRESH_GAIN
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0xBCB2}, 	// LOGICAL_ADDRESS_ACCESS [LL_CDC_DARK_CLUS_SLOPE]
+	
+	REGLIST_8BIT_START_FLAG,
+	{0xBCB2, 0x20}, 	// LL_CDC_DARK_CLUS_SLOPE
+	{0xBCB3, 0x3A}, 	// LL_CDC_DARK_CLUS_SATUR
+	{0xBCB4, 0x39}, 	// LL_CDC_BRIGHT_CLUS_LO_LIGHT_SLOPE
+	{0xBCB7, 0x39}, 	// LL_CDC_BRIGHT_CLUS_LO_LIGHT_SATUR
+	{0xBCB5, 0x20}, 	// LL_CDC_BRIGHT_CLUS_MID_LIGHT_SLOPE
+	{0xBCB8, 0x3A}, 	// LL_CDC_BRIGHT_CLUS_MID_LIGHT_SATUR
+	{0xBCB6, 0x80}, 	// LL_CDC_BRIGHT_CLUS_HI_LIGHT_SLOPE
+	{0xBCB9, 0x24}, 	// LL_CDC_BRIGHT_CLUS_HI_LIGHT_SATUR
+	REGLIST_8BIT_STOP_FLAG,
+	{0xBCAA, 0x03E8}, 	// LL_CDC_THR_ADJ_START_POS
+	{0xBCAC, 0x012C}, 	// LL_CDC_THR_ADJ_MID_POS
+	{0xBCAE, 0x0009}, 	// LL_CDC_THR_ADJ_END_POS
+	{0x33BA, 0x0084}, 	// APEDGE_CONTROL
+	{0x33BE, 0x0000}, 	// UA_KNEE_L
+	{0x33C2, 0x8800}, 	// UA_WEIGHTS
+	{0x098E, 0x3C5E}, 	// LOGICAL_ADDRESS_ACCESS [LL_START_APERTURE_GAIN_BM]
+	{0xBC5E, 0x0154}, 	// LL_START_APERTURE_GAIN_BM
+	{0xBC60, 0x0640}, 	// LL_END_APERTURE_GAIN_BM
+
+	REGLIST_8BIT_START_FLAG,
+	{0xBC62, 0x0E}, 	// LL_START_APERTURE_KPGAIN
+	{0xBC63, 0x14}, 	// LL_END_APERTURE_KPGAIN
+	{0xBC64, 0x0E}, 	// LL_START_APERTURE_KNGAIN
+	{0xBC65, 0x14}, 	// LL_END_APERTURE_KNGAIN
+	{0xBCE2, 0x0A}, 	// LL_START_POS_KNEE
+	{0xBCE3, 0x2B}, 	// LL_END_POS_KNEE
+	{0xBCE4, 0x0A}, 	// LL_START_NEG_KNEE
+	{0xBCE5, 0x2B}, 	// LL_END_NEG_KNEE
+	REGLIST_8BIT_STOP_FLAG,
+	
+	{0x098E, 0xBCC0}, 	// LOGICAL_ADDRESS_ACCESS [LL_SFFB_RAMP_START]
+	REGLIST_8BIT_START_FLAG,
+	{0xBCC0, 0x1F}, 	// LL_SFFB_RAMP_START
+	{0xBCC1, 0x03}, 	// LL_SFFB_RAMP_STOP
+	{0xBCC2, 0x2C}, 	// LL_SFFB_SLOPE_START
+	{0xBCC3, 0x10}, 	// LL_SFFB_SLOPE_STOP
+	{0xBCC4, 0x07}, 	// LL_SFFB_THSTART
+	{0xBCC5, 0x0B}, 	// LL_SFFB_THSTOP
+	REGLIST_8BIT_STOP_FLAG,
+	{0xBCBA, 0x0009}, 	// LL_SFFB_CONFIG
+	{0x098E, 0x3C14}, 	// LOGICAL_ADDRESS_ACCESS [LL_GAMMA_FADE_TO_BLACK_START_POS]
+	{0xBC14, 0xFFFE}, 	// LL_GAMMA_FADE_TO_BLACK_START_POS
+	{0xBC16, 0xFFFF}, 	// LL_GAMMA_FADE_TO_BLACK_END_POS
+	{0x098E, 0x3C66}, 	// LOGICAL_ADDRESS_ACCESS [LL_START_APERTURE_GM]
+	{0xBC66, 0x0154}, 	// LL_START_APERTURE_GM
+	{0xBC68, 0x07D0}, 	// LL_END_APERTURE_GM
+
+	REGLIST_8BIT_START_FLAG,
+	{0xBC6A, 0x04}, 	// LL_START_APERTURE_INTEGER_GAIN
+	{0xBC6B, 0x00}, 	// LL_END_APERTURE_INTEGER_GAIN
+	{0xBC6C, 0x00}, 	// LL_START_APERTURE_EXP_GAIN
+	{0xBC6D, 0x00}, 	// LL_END_APERTURE_EXP_GAIN
+	REGLIST_8BIT_STOP_FLAG,
+	
+	{0x098E, 0x281C}, 	// LOGICAL_ADDRESS_ACCESS [AE_TRACK_MIN_AGAIN]
+	{0xA81C, 0x0080}, 	// AE_TRACK_MIN_AGAIN
+	//{0xA820, 0x01FC}, 	// AE_TRACK_MAX_AGAIN
+	{0xA820, 0x017E}, 	// AE_TRACK_MAX_AGAIN   DT???a???\A8\A6???\A8\AEDT??\A1\C1?\A1䨮???\A8\BA
+	{0xA822, 0x0080}, 	// AE_TRACK_MIN_DGAIN
+	{0xA824, 0x0100}, 	// AE_TRACK_MAX_DGAIN
+	{0x098E, 0xBC56}, 	// LOGICAL_ADDRESS_ACCESS [LL_START_CCM_SATURATION]
+	REGLIST_8BIT_START_FLAG,
+	{0xBC56, 0x64}, 	// LL_START_CCM_SATURATION
+	{0xBC57, 0x1E}, 	// LL_END_CCM_SATURATION
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0xBCDE}, 	// LOGICAL_ADDRESS_ACCESS [LL_START_SYS_THRESHOLD]
+	REGLIST_8BIT_START_FLAG,
+	{0xBCDE, 0x03}, 	// LL_START_SYS_THRESHOLD
+	{0xBCDF, 0x50}, 	// LL_STOP_SYS_THRESHOLD
+	{0xBCE0, 0x08}, 	// LL_START_SYS_GAIN
+	{0xBCE1, 0x03}, 	// LL_STOP_SYS_GAIN
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0x3CD0}, 	// LOGICAL_ADDRESS_ACCESS [LL_SFFB_SOBEL_FLAT_START]
+	{0xBCD0, 0x000A}, 	// LL_SFFB_SOBEL_FLAT_START
+	{0xBCD2, 0x00FE}, 	// LL_SFFB_SOBEL_FLAT_STOP
+	{0xBCD4, 0x001E}, 	// LL_SFFB_SOBEL_SHARP_START
+	{0xBCD6, 0x00FF}, 	// LL_SFFB_SOBEL_SHARP_STOP
+	REGLIST_8BIT_START_FLAG,
+	{0xBCC6, 0x00}, 	// LL_SFFB_SHARPENING_START
+	{0xBCC7, 0x00}, 	// LL_SFFB_SHARPENING_STOP
+	{0xBCC8, 0x20}, 	// LL_SFFB_FLATNESS_START
+	{0xBCC9, 0x40}, 	// LL_SFFB_FLATNESS_STOP
+	{0xBCCA, 0x04}, 	// LL_SFFB_TRANSITION_START
+	{0xBCCB, 0x00}, 	// LL_SFFB_TRANSITION_STOP
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0xBCE6}, 	// LOGICAL_ADDRESS_ACCESS [LL_SFFB_ZERO_ENABLE]
+	REGLIST_8BIT_START_FLAG,
+	{0xBCE6, 0x03}, 	// LL_SFFB_ZERO_ENABLE
+	{0xBCE6, 0x03}, 	// LL_SFFB_ZERO_ENABLE
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0xA410}, 	// LOGICAL_ADDRESS_ACCESS [AE_RULE_TARGET_AE_6]
+	REGLIST_8BIT_START_FLAG,
+	{0xA410, 0x04}, 	// AE_RULE_TARGET_AE_6
+	{0xA411, 0x06}, 	// AE_RULE_TARGET_AE_7
+	
+	REGLIST_8BIT_STOP_FLAG,
+	{0x098E, 0xC8BC}, 	// LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_JPEG_QSCALE_0]
+	REGLIST_8BIT_START_FLAG,
+	{0xC8BC, 0x04}, 	// CAM_OUTPUT_0_JPEG_QSCALE_0
+	{0xC8BD, 0x0A}, 	// CAM_OUTPUT_0_JPEG_QSCALE_1
+	{0xC8D2, 0x04}, 	// CAM_OUTPUT_1_JPEG_QSCALE_0
+	{0xC8D3, 0x0A}, 	// CAM_OUTPUT_1_JPEG_QSCALE_1
+	{0xDC3A, 0x23}, 	// SYS_SEPIA_CR
+	{0xDC3B, 0xB2}, 	// SYS_SEPIA_CB
+	REGLIST_8BIT_STOP_FLAG,
+	
+	{0x098E, 0x8404},
+
+	REGLIST_8BIT_START_FLAG,
+	{0x8404, 0x06}, 	// SEQ_CMD
+	REGLIST_8BIT_STOP_FLAG,
+	DELAY_nMS_ARRAY(10),
+
+	{0x0018, 0x2008}, 	// STANDBY_CONTROL_AND_STATUS
+	DELAY_nMS_ARRAY(10),
+
+	{0x098E, 0x1000}, 
+	{0xC872, 0x0010}, 
+	{0xC874, 0x001C}, 
+	{0xC876, 0x07AF}, 
+	{0xC878, 0x0A43}, 
+	REGLIST_8BIT_START_FLAG,
+	{0xDC0A, 0x06	}, 
+	REGLIST_8BIT_STOP_FLAG,
+	{0xDC1C, 0x2710 }, 
+	{0xC8A4, 0x0A28 }, 
+	{0xC8A6, 0x07A0 },
+	{0xC8C0, 0x0A20 },	// CAM_OUTPUT_1_IMAGE_WIDTH
+	{0xC8C2, 0x0798},	// CAM_OUTPUT_1_IMAGE_HEIGHT
+
+	{0x098E, 0x843C}, 
+	REGLIST_8BIT_START_FLAG,
+	{0x843C, 0xFF}, 
+	{0x8404, 0x02},
+	{0xac01, 0xab}, 
+	{0xac97, 0x80}, 
+	{0xac98, 0x80}, 
+	{0xac99, 0x80}, 
+	{0xAC9a, 0x80}, 
+	{0xAC9b, 0x80},
+	{0xAC9c, 0x80},  
+	REGLIST_8BIT_STOP_FLAG,
+
+	{0xFFFF,0xFFFF},
+};
+
+
+
+
+/* 640*480: VGA */
+static const struct regval_list module_vga_regs[] = 
+{
+
+    {0x098E, 0x48AA}, 	// LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_IMAGE_WIDTH]
+	{0xC8AA, 0x0280}, 	// CAM_OUTPUT_0_IMAGE_WIDTH
+	{0xC8AC, 0x01E0}, 	// CAM_OUTPUT_0_IMAGE_HEIGH
+	{0x098E, 0x843C}, 	// LOGICAL_ADDRESS_ACCESS [SEQ_STATE_CFG_5_MAX_FRAME_CNT]
+	REGLIST_8BIT_START_FLAG,
+	{0x843C, 0x01},	// SEQ_STATE_CFG_5_MAX_FRAME_CNT
+	{0x8404, 0x01},	// SEQ_CMD
+	REGLIST_8BIT_STOP_FLAG,
+	DELAY_nMS_ARRAY(10),
+	{0x0016, 0x0447}, 	// CLOCKS_CONTROL
+    {0xFFFF,0xFFFF},
+};
+
+/* 800*600: SVGA */
+static const struct regval_list module_svga_regs[] = 
+{
+
+	//DELAY_nMS_ARRAY(20),
+    {0x098E, 0x48AA}, 	// LOGICAL_ADDRESS_ACCESS [CAM_OUTPUT_0_IMAGE_WIDTH]
+	{0xC8AA, 0x0320}, 	// CAM_OUTPUT_0_IMAGE_WIDTH   320
+	{0xC8AC, 0x0258}, 	// CAM_OUTPUT_0_IMAGE_HEIGH   258
+	{0x098E, 0x843C}, 	// LOGICAL_ADDRESS_ACCESS [SEQ_STATE_CFG_5_MAX_FRAME_CNT]
+	REGLIST_8BIT_START_FLAG,
+	{0x843C, 0x01},	// SEQ_STATE_CFG_5_MAX_FRAME_CNT
+	{0x8404, 0x01},	// SEQ_CMD
+	REGLIST_8BIT_STOP_FLAG,
+	DELAY_nMS_ARRAY(10),
+	{0x0016, 0x0447}, 	// CLOCKS_CONTROL
+   {0xFFFF,0xFFFF},
+};
+
+
+/* 1280*720: 720P*/
+static const struct regval_list module_720p_regs[] = 
+{
+	
+	{0x098E, 0x843C}, // LOGICAL_ADDRESS_ACCESS [CAM_CORE_A_Y_ADDR_START]
+	REGLIST_8BIT_START_FLAG,
+	{0x843C, 0x01}, // SEQ_STATE_CFG_5_MAX_FRAME_CNT
+	{0x8404, 0x01}, // SEQ_CMD
+	REGLIST_8BIT_STOP_FLAG, 
+	{0x0016, 0x0447},  // CLOCKS_CONTROL
+	{0xC83A, 0x0106},  // CAM_CORE_A_Y_ADDR_START
+	{0xC83C, 0x0018},  // CAM_CORE_A_X_ADDR_START
+	{0xC83E, 0x06B7},  // CAM_CORE_A_Y_ADDR_END
+	{0xC840, 0x0A45},  // CAM_CORE_A_X_ADDR_END
+	{0xC86C, 0x0518},  // CAM_CORE_A_OUTPUT_SIZE_WIDTH
+	{0xC86E, 0x02D8},  // CAM_CORE_A_OUTPUT_SIZE_HEIGHT
+	{0xC870, 0x0014},  // CAM_CORE_A_RX_FIFO_TRIGGER_MARK
+	{0xC858, 0x0003}, // CAM_CORE_A_COARSE_ITMIN
+	{0xC8B8, 0x0004},  // CAM_OUTPUT_0_JPEG_CONTROL
+	{0xC8AA, 0x0500},  // CAM_OUTPUT_0_IMAGE_WIDTH
+	{0xC8AC, 0x02D0},  // CAM_OUTPUT_0_IMAGE_HEIGHT
+	{0xC8AE, 0x0001},  // CAM_OUTPUT_0_OUTPUT_FORMAT
+	REGLIST_8BIT_START_FLAG,
+	{0x8404, 0x06},  // SEQ_CMD
+	REGLIST_8BIT_STOP_FLAG, 
+	DELAY_nMS_ARRAY(100),
+	 {0xFFFF,0xFFFF},
+};
+
+
+
+
+/* 1920*1080: 1080P*/
+static const struct regval_list module_1080p_regs[] = 
+{
+	//DELAY_nMS_ARRAY(10),
+	//{0x001E, 0x0663},
+	{0x098E, 0x1000}, 
+	{0xC872, 0x0110}, 
+	{0xC874, 0x0020}, 
+	{0xC876, 0x06C9	}, 
+	{0xC878, 0x0A47	},
+	REGLIST_8BIT_START_FLAG,
+	{0xDC0A, 0x06	}, 
+	REGLIST_8BIT_STOP_FLAG,
+	{0xDC1C, 0x2710	}, 
+	{0xC8A4, 0x0A28	}, 
+	{0xC8A6, 0x05BA	}, 
+	{0xC8C0, 0x0780	}, 
+	{0xC8C2, 0x0438},
+
+	{0x098E, 0x843C}, 
+	REGLIST_8BIT_START_FLAG,
+	{0x843C, 0xff}, 
+	{0x8404, 0x02}, 
+	REGLIST_8BIT_STOP_FLAG,
+	DELAY_nMS_ARRAY(10),
+	 {0xFFFF,0xFFFF},
+};
+
+
+/* 2592X1944 QSXGA */
+static const struct regval_list module_qsxga_regs[] = 
+{
+	#if 1
+	{0x098E, 0x1000}, 
+	{0xC872, 0x0010}, 
+	{0xC874, 0x001C}, 
+	{0xC876, 0x07AF}, 
+	{0xC878, 0x0A43}, 
+	REGLIST_8BIT_START_FLAG,
+	{0xDC0A, 0x06	}, 
+	REGLIST_8BIT_STOP_FLAG,
+	{0xDC1C, 0x2710 }, 
+	{0xC8A4, 0x0A28 }, 
+	{0xC8A6, 0x07A0 },
+	{0xC8C0, 0x0A20 },	// CAM_OUTPUT_1_IMAGE_WIDTH
+	{0xC8C2, 0x0798},	// CAM_OUTPUT_1_IMAGE_HEIGHT
+
+	{0x098E, 0x843C}, 
+	REGLIST_8BIT_START_FLAG,
+	{0x843C, 0xFF}, 
+	{0x8404, 0x02}, 
+	REGLIST_8BIT_STOP_FLAG,
+	DELAY_nMS_ARRAY(10),
+	{0xFFFF,0xFFFF},
+	#endif
+};
+
+
+
+static const struct regval_list module_init_auto_focus[] =
+{
+	{0xFFFF,0xFFFF},
+//  NULL
+};
+
+/* 640*480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+/* 1280*720 */
+static struct camera_module_win_size module_win_720p = {
+	.name             = "720P",
+	.width            = WIDTH_720P,
+	.height           = HEIGHT_720P,
+	.win_regs         = module_720p_regs,
+	
+	.frame_rate_array = frame_rate_720p,
+	.capture_only     = 0,
+};
+
+/* 800*600 */
+static struct camera_module_win_size module_win_svga = {
+	.name             = "SVGA",
+	.width            = WIDTH_SVGA,
+	.height           = HEIGHT_SVGA,
+	.win_regs         = module_svga_regs,
+	
+	.frame_rate_array = frame_rate_svga,
+	.capture_only     = 0,
+};
+
+
+/* 1920*1080 */
+static struct camera_module_win_size module_win_1080p = {
+	.name             = "1080P",
+	.width            = WIDTH_1080P,
+	.height           = HEIGHT_1080P,
+	.win_regs         = module_1080p_regs,
+	
+	.frame_rate_array = frame_rate_1080p,
+	.capture_only     = 0,
+};
+
+/* 2592*1944 */
+static struct camera_module_win_size module_win_qsxga = {
+	.name             = "QSXGA",
+	.width            = WIDTH_QSXGA,
+	.height           = HEIGHT_QSXGA,
+	.win_regs         = module_qsxga_regs,
+	
+	.frame_rate_array = frame_rate_qsxga,
+	.capture_only     = 1,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_vga,
+	&module_win_svga,
+//	&module_win_uxga,
+	&module_win_720p,
+	&module_win_1080p,
+	&module_win_qsxga,
+};
+
+
+
+static struct regval_list module_whitebance_auto_regs[]=
+{
+	REGLIST_8BIT_START_FLAG,
+	{0xac01, 0xab}, 
+	{0xac97, 0x80}, 
+	{0xac98, 0x80}, 
+	{0xac99, 0x80}, 
+	{0xAC9a, 0x80}, 
+	{0xAC9b, 0x80},
+	{0xAC9c, 0x80},  
+	REGLIST_8BIT_STOP_FLAG,
+	{0xFFFF,0xFFFF},
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	REGLIST_8BIT_START_FLAG,
+	{0xac01, 0xeb}, 
+	{0xac97, 0xf0}, 
+	{0xac98, 0x80}, 
+	{0xac99, 0x80}, 
+	{0xAC9a, 0xf0}, 
+	{0xAC9b, 0x80},
+	{0xAC9c, 0x80},
+	REGLIST_8BIT_STOP_FLAG,      
+	{0xFFFF,0xFFFF},
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+	REGLIST_8BIT_START_FLAG,
+	{0xac01, 0xeb},
+	{0xac97, 0xc0}, 
+	{0xac98, 0x80}, 
+	{0xac99, 0x80}, 
+	{0xAC9a, 0xc0}, 
+	{0xAC9b, 0x80},
+	{0xAC9c, 0x80},     
+	REGLIST_8BIT_STOP_FLAG,    
+    {0xFFFF,0xFFFF},
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+	REGLIST_8BIT_START_FLAG,
+	{0xac01, 0xeb}, 
+	{0xac97, 0xa0}, 
+	{0xac98, 0x90}, 
+	{0xac99, 0x80}, 
+	{0xAC9a, 0xa0}, 
+	{0xAC9b, 0x90},
+	{0xAC9c, 0x80},        
+	REGLIST_8BIT_STOP_FLAG, 
+    {0xFFFF,0xFFFF},
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	REGLIST_8BIT_START_FLAG,
+	{0xac01, 0xeb}, 
+	{0xac97, 0x80}, 
+	{0xac98, 0x80}, 
+	{0xac99, 0xb0}, 
+	{0xAC9a, 0x80}, 
+	{0xAC9b, 0x80},
+	{0xAC9c, 0xb0},  
+	REGLIST_8BIT_STOP_FLAG,   
+	{0xFFFF,0xFFFF},
+};
+
+
+static struct regval_list module_scene_auto_regs[] =
+{
+	{0x337E, 0x0000},
+	{0x098E, 0xA401},		// [AE_BASETARGET]   	
+	REGLIST_8BIT_START_FLAG,	   	
+    {0xA401, 0x00},                      
+	//{0xA805, 0x04},		// [SEQ_CMD]       
+	{0xA409, 0x27},     //                 
+    //{0x8404, 0x06},      //delete for decrease capture time
+    REGLIST_8BIT_STOP_FLAG,   
+	{0xFFFF,0xFFFF},
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list module_exp_comp_neg4_regs[] = {
+	REGLIST_8BIT_START_FLAG,
+	{0xA409,0x18},
+	REGLIST_8BIT_STOP_FLAG,  
+	{0xFFFF,0xFFFF},
+};
+
+static struct regval_list module_exp_comp_neg3_regs[] = {
+	REGLIST_8BIT_START_FLAG,
+	{0xA409,0x20},
+	REGLIST_8BIT_STOP_FLAG,  
+	{0xFFFF,0xFFFF},
+};
+
+static struct regval_list module_exp_comp_neg2_regs[] = {
+	
+	REGLIST_8BIT_START_FLAG,
+	{0xA409, 0x28},
+	REGLIST_8BIT_STOP_FLAG,  
+	{0xFFFF,0xFFFF},
+};
+
+static struct regval_list module_exp_comp_neg1_regs[] = {
+	REGLIST_8BIT_START_FLAG,
+	{0xA409,0x30},
+	REGLIST_8BIT_STOP_FLAG,  
+	{0xFFFF,0xFFFF},
+};
+
+static struct regval_list module_exp_comp_zero_regs[] = {
+	REGLIST_8BIT_START_FLAG,
+	{0xA409, 0x38},
+	REGLIST_8BIT_STOP_FLAG,   
+	{0xFFFF,0xFFFF},
+};
+
+static struct regval_list module_exp_comp_pos1_regs[] = {
+	REGLIST_8BIT_START_FLAG,
+	{0xA409,0x40},
+	REGLIST_8BIT_STOP_FLAG,  
+	{0xFFFF,0xFFFF},
+};
+
+static struct regval_list module_exp_comp_pos2_regs[] = {
+	REGLIST_8BIT_START_FLAG,
+	{0xA409,0x48},
+	REGLIST_8BIT_STOP_FLAG,  
+	{0xFFFF,0xFFFF},
+};
+
+static struct regval_list module_exp_comp_pos3_regs[] = {
+    
+	REGLIST_8BIT_START_FLAG,
+	{0xA409,0x50},
+	REGLIST_8BIT_STOP_FLAG,  
+	{0xFFFF,0xFFFF},
+};
+
+static struct regval_list module_exp_comp_pos4_regs[] = {
+	REGLIST_8BIT_START_FLAG,
+	{0xA409, 0x58},
+	REGLIST_8BIT_STOP_FLAG,  
+	{0xFFFF,0xFFFF},
+};
+
+
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+
+	{   .id = V4L2_CID_EXPOSURE, 
+		.min = 0, 
+		.max = 975,
+		.step = 1, 
+		.def = 500,
+	},
+	{	.id = V4L2_CID_EXPOSURE_COMP, 
+		.min = -4, 
+		.max = 4, 
+		.step = 1, 
+		.def = 0,
+	},	
+	{	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,
+	},
+	{
+        .id = V4L2_CID_AUTO_WHITE_BALANCE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 1,
+    },
+    {
+        .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+        .min = 0,
+        .max = 3,
+        .step = 1,
+        .def = 0,
+    },
+	  {	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+    {
+        .id = V4L2_CID_HFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_VFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {	.id = V4L2_CID_MIRRORFLIP, //3.10\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+		
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	 {
+        .id = V4L2_CID_COLORFX,
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_EXPOSURE_AUTO,
+        .max = 1,
+        .mask = 0x0,
+        .def = 1,
+    },
+	{  
+		   .id = V4L2_CID_SCENE_MODE, 
+		   .max = V4L2_SCENE_MODE_TEXT, 
+		   .mask = 0x0, 
+		   .def = 0,
+	},
+	{	.id   = V4L2_CID_FLASH_LED_MODE, 
+		.max  = 3,
+		.mask = 0x0,
+		.def  = 0,},
+	 {
+	.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/soc5140/readme b/drivers/media/i2c/camera/soc5140/readme
new file mode 100755
index 0000000..e69de29
diff --git a/drivers/media/i2c/camera/soc5140/soc5140.c b/drivers/media/i2c/camera/soc5140/soc5140.c
new file mode 100755
index 0000000..d1e4cba
--- /dev/null
+++ b/drivers/media/i2c/camera/soc5140/soc5140.c
@@ -0,0 +1,687 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include"../module_comm/camera_chip_ident.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+
+
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = (reg & 0xff00) >> 8;
+    regs_array[1] =  reg & 0x00ff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = (data_array[0] << 8) | data_array[1];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+static int camera_i2c_read8(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = (reg & 0xff00) >> 8;
+    regs_array[1] =  reg & 0x00ff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = 1;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0]&0xff;
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	//printk("the address is %x,value is %x\n",(0xffff&reg),(0xffff&src));
+	
+	regs_array[0] = (reg & 0xff00) >> 8;
+    regs_array[1] =  reg & 0x00ff;
+	data_array[0] = (data & 0xff00) >> 8;
+    data_array[1] =  data & 0x00ff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_i2c_write8(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	//printk("the address is %x,value is %x\n",(0xffff&reg),(0xff&src));
+	//printk("the i2c addr is %x,val is %x\n",reg,src);
+	
+	regs_array[0] = (reg & 0xff00) >> 8;
+    regs_array[1] =  reg & 0x00ff;
+	data_array[0] = data & 0xff;
+
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + 1); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + 1;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+
+
+int SOC5140_8404_Polling(struct i2c_adapter *i2c_adap,unsigned int src,unsigned int wate_t)
+{
+	int ret = 0;
+	unsigned int regdest;
+	unsigned short  count = 0;
+    //ret |= camera_i2c_write(client,0x098E, (unsigned int*)&regadress);
+	//printk("Start polling 0x8404 \n");
+	
+	while(count<wate_t)
+	{
+		ret |= camera_i2c_read8(i2c_adap,0x8404,&regdest);
+
+		if( 0== regdest )
+		{
+			ret |= camera_i2c_write8(i2c_adap, 0x8404, src);
+			//printk("Write to 0x8404 \n");
+			break;
+		}
+
+		count++;
+		mdelay(1);
+	}
+
+	if(count>=wate_t)
+	{
+		printk("SOC5140_8404_BEFOR_W_ERR!\n");
+	}
+
+	count = 0;	
+	while(count<wate_t)
+	{
+		ret |= camera_i2c_read8(i2c_adap,0x8404,&regdest);
+
+		if( 0== regdest )
+		{
+			//printk("SOC5140_8404_Polling delay:%dms\n",count*5);
+			break;
+		}
+
+		count++;
+		mdelay(1);
+	}
+	if(count>=wate_t)
+	{
+		printk("SOC5140_8404_AFTER_W_ERR!\n");
+	}
+
+	return ret;
+}
+
+
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{	
+	int tmp_flag = false;
+	unsigned int regdest,k;
+	int standby_done_flag = 0;
+	while (vals->reg_num != 0xffff) {
+		if(vals->reg_num == 0xff)
+			{
+				mdelay(vals->value);
+				//printk("in the msleep \n");
+			}
+		else if((vals->reg_num == 0xFdFF)&&(vals->value == 0x0000))
+			{
+				tmp_flag = true;
+			
+			}
+			else if((vals->reg_num == 0xFdFF)&&(vals->value == 0xFFFF))
+			{
+				tmp_flag = false;
+				
+				//printk("tmp_flag is false\n");
+			} else {	
+				if(!tmp_flag)
+					{
+					int ret = camera_i2c_write(i2c_adap,
+								vals->reg_num,
+								vals->value);
+						if(vals->reg_num==0x0018)
+						{
+							for(k=0;k<5;k++)
+							{
+								standby_done_flag = regdest&(1<<14);
+								if(standby_done_flag==1)
+								;
+								else 
+									{
+								ret = camera_i2c_write(i2c_adap, vals->reg_num, vals->value);
+								mdelay(1);
+								ret |= camera_i2c_read(i2c_adap,vals->reg_num,&regdest);
+									}
+
+							}
+							
+						}
+					if (ret < 0)
+						{
+						printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+						return ret;
+						}
+					}
+					else
+					{
+					if(vals->reg_num == 0x8404)
+					{
+						SOC5140_8404_Polling(i2c_adap,vals->value,40);//200
+						//int tmp = camera_i2c_write8(i2c_adap,
+							//		vals->reg_num,
+								//	vals->value);
+											
+					}
+					else
+						{
+						int err = camera_i2c_write8(i2c_adap,
+									vals->reg_num,
+									vals->value);
+						if (err < 0)
+						{
+						printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+						return err;
+						}
+						}
+				}
+			}
+		vals++;
+	}
+	return 0;
+}
+
+static int module_soft_reset(struct i2c_client *client)
+{
+	unsigned int reg_0x001A;
+	int ret = 0;
+
+	ret = camera_i2c_read(client->adapter, 0x001A, &reg_0x001A);
+	reg_0x001A |= (0x1<<0); 
+	ret |= camera_i2c_write(client->adapter, 0x001A, reg_0x001A);
+	mdelay(1);
+	reg_0x001A &= (~(0x1<<0));
+	ret |= camera_i2c_write(client->adapter, 0x001A, reg_0x001A);
+	return ret;
+}
+
+
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	//printk("int the module_set_scene_exposure\n ");
+	return ret;
+}
+
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+  int ret = 0;
+  
+ 
+
+  return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+ int ret = 0;
+ 
+ 
+ 
+  return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+ 	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	
+
+	if(priv->capture_exposure_param.shutter < 1) {
+		priv->capture_exposure_param.shutter = 1;
+	}
+	return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_save_exposure_param\n ");
+	return ret;
+}
+
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	
+	switch(ctrl->val){
+		case 4:
+			camera_write_array(client->adapter,module_exp_comp_pos4_regs);
+			break;
+		case 3:
+			camera_write_array(client->adapter,module_exp_comp_pos3_regs);
+			break;
+		case 2:
+			camera_write_array(client->adapter,module_exp_comp_pos2_regs);
+			break;
+		case 1:
+			camera_write_array(client->adapter,module_exp_comp_pos1_regs);
+			break;
+		case 0:
+			camera_write_array(client->adapter,module_exp_comp_zero_regs);
+			break;
+		case -1:
+			camera_write_array(client->adapter,module_exp_comp_neg1_regs);
+			break;
+		case -2:
+			camera_write_array(client->adapter,module_exp_comp_neg2_regs);
+			break;
+		case -3:
+			camera_write_array(client->adapter,module_exp_comp_neg3_regs);
+			break;
+		case -4:
+			camera_write_array(client->adapter,module_exp_comp_neg4_regs);
+			break;
+		default:
+			break;		
+	}
+
+	
+	return ret;
+}
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+
+
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	//int auto_white_balance = ctrl->val;
+	int ret = 0;
+	
+	int auto_white_balance;
+		if(ctrl)
+			{
+			auto_white_balance = ctrl->val;
+		}
+		else 
+			{
+				auto_white_balance = 1;
+			}
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		{
+	ctrl->cur.val = auto_white_balance;
+		}
+
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+   // int exposure_auto = ctrl->val;
+	int ret = 0;
+	
+	int exposure_auto;
+		if(ctrl)
+			{
+			exposure_auto = ctrl->val;
+			}
+		else 
+			{
+				exposure_auto = V4L2_EXPOSURE_AUTO;
+			}
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		{
+	ctrl->cur.val = exposure_auto;
+		}
+
+	return 0;
+}
+
+
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	//mdelay(10);
+	int ret = 0;
+	   if (!enable) {
+		   GC_INFO("stream down");
+			return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	  return ret;
+}
+
+
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+
+
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	int ret = 0;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		
+		break;
+		
+	default:
+		return -ERANGE;
+	}
+	
+	return ret;
+}
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	 unsigned int reg_0x3820 = 0x40;
+    unsigned int reg_0x3821 = 0x00;
+
+
+    GC_INFO("");
+	
+	if ((!mirror) && (!flip)) {
+		printk("%s():no need to set mirror flip \n",__FUNCTION__);
+		return 0;
+	}
+
+	camera_i2c_read(i2c_adap, 0x3821, &reg_0x3821);
+   if (mirror) {
+        reg_0x3821 |= (0x3 << 1);
+    } else {
+        reg_0x3821 &= ~(0x3 << 1);
+    }
+	camera_i2c_write(i2c_adap, 0x3821, reg_0x3821);
+  
+    camera_i2c_read(i2c_adap, 0x3820, &reg_0x3820);
+   if (flip) {
+        reg_0x3821 |= (0x3 << 1);
+    } else {
+        reg_0x3821 &= ~(0x3 << 1);
+    }
+	camera_i2c_write(i2c_adap, 0x3820, reg_0x3820);
+   
+	return ret;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	int ret = 0;
+	unsigned int pid;
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	printk("in the soc5140 \n");
+	ret = camera_i2c_read(i2c_adap, PID, &pid); 
+	switch (pid) 
+    {
+	case CAMERA_MODULE_PID:
+		if(priv)
+			{
+		     priv->model= V4L2_IDENT_SOC5140;
+			}
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, pid);
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, pid);
+		return -ENODEV;
+	}
+	return ret;
+}
+
+
+
diff --git a/drivers/media/i2c/camera/sp0718/Kconfig b/drivers/media/i2c/camera/sp0718/Kconfig
new file mode 100755
index 0000000..b07cd2d
--- /dev/null
+++ b/drivers/media/i2c/camera/sp0718/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config SP0718
+	tristate "sp0718 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for sp0718 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sp0718.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/sp0718/Makefile b/drivers/media/i2c/camera/sp0718/Makefile
new file mode 100755
index 0000000..de645bf
--- /dev/null
+++ b/drivers/media/i2c/camera/sp0718/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SP0718) += sp0718.o
+
diff --git a/drivers/media/i2c/camera/sp0718/module_diff.h b/drivers/media/i2c/camera/sp0718/module_diff.h
new file mode 100755
index 0000000..e850593
--- /dev/null
+++ b/drivers/media/i2c/camera/sp0718/module_diff.h
@@ -0,0 +1,675 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+
+#define CAMERA_MODULE_NAME 		"sp0718"
+#define CAMERA_MODULE_PID		0x71
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_I2C_REAL_ADDRESS  (0x42>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x21)
+
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_PCLK_SAMPLE_EDGE      V4L2_MBUS_PCLK_SAMPLE_RISING
+
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+
+
+#define PID						0x02 /* Product ID Number */
+
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA
+#define MODULE_MAX_WIDTH		WIDTH_VGA
+#define MODULE_MAX_HEIGHT		HEIGHT_VGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		3
+#define DROP_NUM_PREVIEW		2
+static unsigned int frame_rate_vga[]   = {30,};
+/*
+ * register setting for window size
+ */
+#define SP0718_NORMAL_Y0ffset  0x20
+#define SP0718_LOWLIGHT_Y0ffset  0x25
+//AE target
+#define  SP0718_P1_0xeb  0x78
+#define  SP0718_P1_0xec  0x6c
+//HEQ
+#define  SP0718_P1_0x10  0x00//outdoor
+#define  SP0718_P1_0x14  0x20
+#define  SP0718_P1_0x11  0x00//nr
+#define  SP0718_P1_0x15  0x18
+#define  SP0718_P1_0x12  0x00//dummy
+#define  SP0718_P1_0x16  0x10
+#define  SP0718_P1_0x13  0x00//low
+#define  SP0718_P1_0x17  0x00
+
+
+
+static const struct regval_list module_init_regs[] =
+{
+	
+	{0xfd,0x00},
+	{0x1C,0x00},
+	{0x31,0x10},
+	{0x27,0xb3},//0xb3	//2x gain
+	{0x1b,0x17},
+	{0x26,0xaa},
+	{0x37,0x02},
+	{0x28,0x8f},
+	{0x1a,0x73},
+	{0x1e,0x1b},
+	{0x21,0x06},  //blackout voltage
+	{0x22,0x2a},  //colbias
+	{0x0f,0x3f},
+	{0x10,0x3e},
+	{0x11,0x00},
+	{0x12,0x01},
+	{0x13,0x3f},
+	{0x14,0x04},
+	{0x15,0x30},
+	{0x16,0x31},
+	{0x17,0x01},
+	{0x69,0x31},
+	{0x6a,0x2a},
+	{0x6b,0x33},
+	{0x6c,0x1a},
+	{0x6d,0x32},
+	{0x6e,0x28},
+	{0x6f,0x29},
+	{0x70,0x34},
+	{0x71,0x18},
+	{0x36,0x00},//02 delete badframe
+	{0xfd,0x01},
+	{0x5d,0x51},//position
+	{0xf2,0x19},
+
+	//Blacklevel
+	{0x1f,0x10},
+	{0x20,0x1f},
+	//pregain 
+	{0xfd,0x02},
+	{0x00,0x88},
+	{0x01,0x88},
+	//SI15_SP0718 24M 50Hz 15-8fps 
+	//ae setting
+	{0xfd,0x00},
+	{0x03,0x01},
+	{0x04,0xce},
+	{0x06,0x00},
+	{0x09,0x02},
+	{0x0a,0xc4},
+	{0xfd,0x01},
+	{0xef,0x4d},
+	{0xf0,0x00},
+	{0x02,0x0c},
+	{0x03,0x01},
+	{0x06,0x47},
+	{0x07,0x00},
+	{0x08,0x01},
+	{0x09,0x00},
+	//Status   
+	{0xfd,0x02},
+	{0xbe,0x9c},
+	{0xbf,0x03},
+	{0xd0,0x9c},
+	{0xd1,0x03},
+	{0xfd,0x01},
+	{0x5b,0x03},
+	{0x5c,0x9c},
+
+	//rpc
+	{0xfd,0x01},
+	{0xe0,0x40},////24//4c//48//4c//44//4c//3e//3c//3a//38//rpc_1base_max
+	{0xe1,0x30},////24//3c//38//3c//36//3c//30//2e//2c//2a//rpc_2base_max
+	{0xe2,0x2e},////24//34//30//34//2e//34//2a//28//26//26//rpc_3base_max
+	{0xe3,0x2a},////24//2a//2e//2c//2e//2a//2e//26//24//22//rpc_4base_max
+	{0xe4,0x2a},////24//2a//2e//2c//2e//2a//2e//26//24//22//rpc_5base_max
+	{0xe5,0x28},////24//2c//2a//2c//28//2c//24//22//20//rpc_6base_max
+	{0xe6,0x28},////24//2c//2a//2c//28//2c//24//22//20//rpc_7base_max
+	{0xe7,0x26},////24//2a//28//2a//26//2a//22//20//20//1e//rpc_8base_max
+	{0xe8,0x26},////24//2a//28//2a//26//2a//22//20//20//1e//rpc_9base_max
+	{0xe9,0x26},////24//2a//28//2a//26//2a//22//20//20//1e//rpc_10base_max
+	{0xea,0x26},////24//28//26//28//24//28//20//1f//1e//1d//rpc_11base_max
+	{0xf3,0x26},////24//28//26//28//24//28//20//1f//1e//1d//rpc_12base_max
+	{0xf4,0x26},////24//28//26//28//24//28//20//1f//1e//1d//rpc_13base_max
+	//ae gain &status
+	{0xfd,0x01},
+	{0x04,0xe0},//rpc_max_indr
+	{0x05,0x26},//1e//rpc_min_indr 
+	{0x0a,0xa0},//rpc_max_outdr
+	{0x0b,0x26},//rpc_min_outdr
+	{0x5a,0x40},//dp rpc   
+	{0xfd,0x02}, 
+	{0xbc,0xa0},//rpc_heq_low
+	{0xbd,0x80},//rpc_heq_dummy
+	{0xb8,0x80},//mean_normal_dummy
+	{0xb9,0x90},//mean_dummy_normal
+
+	//ae target
+	{0xfd,0x01}, 
+	{0xeb,SP0718_P1_0xeb},//78 
+	{0xec,SP0718_P1_0xec},//78
+	{0xed,0x0a},	
+	{0xee,0x10},
+
+	//lsc		
+	{0xfd,0x01},
+	{0x26,0x30},
+	{0x27,0x2c},
+	{0x28,0x07},
+	{0x29,0x08},
+	{0x2a,0x40},
+	{0x2b,0x03},
+	{0x2c,0x00},
+	{0x2d,0x00},
+	  
+	{0xa1,0x24},
+	{0xa2,0x27},
+	{0xa3,0x27},
+	{0xa4,0x2b},
+	{0xa5,0x1c},
+	{0xa6,0x1a},
+	{0xa7,0x1a},
+	{0xa8,0x1a},
+	{0xa9,0x18},
+	{0xaa,0x1c},
+	{0xab,0x17},
+	{0xac,0x17},
+	{0xad,0x08},
+	{0xae,0x08},
+	{0xaf,0x08},
+	{0xb0,0x00},
+	{0xb1,0x00},
+	{0xb2,0x00},
+	{0xb3,0x00},
+	{0xb4,0x00},
+	{0xb5,0x02},
+	{0xb6,0x06},
+	{0xb7,0x00},
+	{0xb8,0x00},
+	   
+	   
+	//DP	   
+	{0xfd,0x01},
+	{0x48,0x09},
+	{0x49,0x99},
+		
+	//awb		
+	{0xfd,0x01},
+	{0x32,0x05},
+	{0xfd,0x00},
+	{0xe7,0x03},
+	{0xfd,0x02},
+	{0x26,0xc8},
+	{0x27,0xb6},
+	{0xfd,0x00},
+	{0xe7,0x00},
+	{0xfd,0x02},
+	{0x1b,0x80},
+	{0x1a,0x80},
+	{0x18,0x26},
+	{0x19,0x28},
+	{0xfd,0x02},
+	{0x2a,0x00},
+	{0x2b,0x08},
+	{0x28,0xef},//0xa0//f8
+	{0x29,0x20},
+
+	//d65 90  e2 93
+	{0x66,0x42},//0x59//0x60////0x58//4e//0x48
+	{0x67,0x62},//0x74//0x70//0x78//6b//0x69
+	{0x68,0xee},//0xd6//0xe3//0xd5//cb//0xaa
+	{0x69,0x18},//0xf4//0xf3//0xf8//ed
+	{0x6a,0xa6},//0xa5
+	//indoor 91
+	{0x7c,0x3b},//0x45//30//41//0x2f//0x44
+	{0x7d,0x5b},//0x70//60//55//0x4b//0x6f
+	{0x7e,0x15},//0a//0xed
+	{0x7f,0x39},//23//0x28
+	{0x80,0xaa},//0xa6
+	//cwf	92 
+	{0x70,0x3e},//0x38//41//0x3b
+	{0x71,0x59},//0x5b//5f//0x55
+	{0x72,0x31},//0x30//22//0x28
+	{0x73,0x4f},//0x54//44//0x45
+	{0x74,0xaa},
+	//tl84	93 
+	{0x6b,0x1b},//0x18//11
+	{0x6c,0x3a},//0x3c//25//0x2f
+	{0x6d,0x3e},//0x3a//35
+	{0x6e,0x59},//0x5c//46//0x52
+	{0x6f,0xaa},
+	//f    94
+	{0x61,0xea},//0x03//0x00//f4//0xed
+	{0x62,0x03},//0x1a//0x25//0f//0f
+	{0x63,0x6a},//0x62//0x60//52//0x5d
+	{0x64,0x8a},//0x7d//0x85//70//0x75//0x8f
+	{0x65,0x6a},//0xaa//6a
+	  
+	{0x75,0x80},
+	{0x76,0x20},
+	{0x77,0x00},
+	{0x24,0x25},
+
+	//\D5\EB\B6\D4\CA\D2\C4ڵ\F7ƫ\B2\BB\B9\FD\B5\C6\CF\E4\B2\E2\CA\D4ʹ\D3\C3//\D5\EB\B6\D4\C8\CB\C1\B3\B5\F7ƫ
+	{0x20,0xd8},
+	{0x21,0xa3},//82//a8ƫ\B0\B5\D5նȻ\B9\D3е\F7ƫ
+	{0x22,0xd0},//e3//bc
+	{0x23,0x86},
+
+	//outdoor r\b range
+	{0x78,0xc3},//d8
+	{0x79,0xba},//82
+	{0x7a,0xa6},//e3
+	{0x7b,0x99},//86
+
+
+	//skin 
+	{0x08,0x15},//
+	{0x09,0x04},//
+	{0x0a,0x20},//
+	{0x0b,0x12},//
+	{0x0c,0x27},//
+	{0x0d,0x06},//
+	{0x0e,0x63},//
+
+	//wt th
+	{0x3b,0x10},
+	//gw
+	{0x31,0x60},
+	{0x32,0x60},
+	{0x33,0xc0},
+	{0x35,0x6f},
+
+	// sharp
+	{0xfd,0x02},
+	{0xde,0x0f},
+	{0xd2,0x02},//6//\BF\D8\D6ƺڰױߣ\BB0-\B1ߴ֣\ACf-\B1\E4ϸ
+	{0xd3,0x06},
+	{0xd4,0x06},
+	{0xd5,0x06},
+	{0xd7,0x20},//10//2x\B8\F9\BE\DD\D4\F6\D2\E6\C5ж\CF\C2\D6\C0\AA\E3\D0ֵ
+	{0xd8,0x30},//24//1A//4x
+	{0xd9,0x38},//28//8x
+	{0xda,0x38},//16x
+	{0xdb,0x08},//
+	{0xe8,0x58},//48//\C2\D6\C0\AAǿ\B6\C8
+	{0xe9,0x48},
+	{0xea,0x30},
+	{0xeb,0x20},
+	{0xec,0x48},//60//80
+	{0xed,0x48},//50//60
+	{0xee,0x30},
+	{0xef,0x20},
+	//ƽ̹\C7\F8\D3\F2\C8\F1\BB\AF\C1\A6\B6\C8
+	{0xf3,0x50},
+	{0xf4,0x10},
+	{0xf5,0x10},
+	{0xf6,0x10},
+	//dns		
+	{0xfd,0x01},
+	{0x64,0x44},//\D1ط\BD\CF\F2\B1\DFԵƽ\BB\AC\C1\A6\B6\C8  //0-\D7\EEǿ\A3\AC8-\D7\EE\C8\F5
+	{0x65,0x22},
+	{0x6d,0x04},//8//ǿƽ\BB\AC\A3\A8ƽ̹\A3\A9\C7\F8\D3\F2ƽ\BB\AC\E3\D0ֵ
+	{0x6e,0x06},//8
+	{0x6f,0x10},
+	{0x70,0x10},
+	{0x71,0x08},//0d//\C8\F5ƽ\BB\AC\A3\A8\B7\C7ƽ̹\A3\A9\C7\F8\D3\F2ƽ\BB\AC\E3\D0ֵ	
+	{0x72,0x12},//1b
+	{0x73,0x1c},//20
+	{0x74,0x24},
+	{0x75,0x44},//[7:4]ƽ̹\C7\F8\D3\F2ǿ\B6ȣ\AC[3:0]\B7\C7ƽ̹\C7\F8\D3\F2ǿ\B6ȣ\BB0-\D7\EEǿ\A3\AC8-\D7\EE\C8\F5\A3\BB
+	{0x76,0x02},//46
+	{0x77,0x02},//33
+	{0x78,0x02},
+	{0x81,0x10},//18//2x//\B8\F9\BE\DD\D4\F6\D2\E6\C5ж\A8\C7\F8\D3\F2\E3\D0ֵ\A3\AC\B5\CD\D3\DA\D5\E2\B8\F6\D7\F6ǿƽ\BB\AC\A1\A2\B4\F3\D3\DA\D5\E2\B8\F6\D7\F6\C8\F5ƽ\BB\AC\A3\BB
+	{0x82,0x20},//30//4x
+	{0x83,0x30},//40//8x
+	{0x84,0x48},//50//16x
+	{0x85,0x0c},//12/8+reg0x81 \B5ڶ\FE\E3\D0ֵ\A3\AC\D4\DAƽ̹\BAͷ\C7ƽ̹\C7\F8\D3\F2\D7\F6\C1\AC\BD\D3
+	{0xfd,0x02},
+	{0xdc,0x0f},
+	   
+	//gamma    
+	{0xfd,0x01},
+	{0x8b,0x00},//00//00	 
+	{0x8c,0x0a},//0c//09	 
+	{0x8d,0x16},//19//17	 
+	{0x8e,0x1f},//25//24	 
+	{0x8f,0x2a},//30//33	 
+	{0x90,0x3c},//44//47	 
+	{0x91,0x4e},//54//58	 
+	{0x92,0x5f},//61//64	 
+	{0x93,0x6c},//6d//70	 
+	{0x94,0x82},//80//81	 
+	{0x95,0x94},//92//8f	 
+	{0x96,0xa6},//a1//9b	 
+	{0x97,0xb2},//ad//a5	 
+	{0x98,0xbf},//ba//b0	 
+	{0x99,0xc9},//c4//ba	 
+	{0x9a,0xd1},//cf//c4	 
+	{0x9b,0xd8},//d7//ce	 
+	{0x9c,0xe0},//e0//d7	 
+	{0x9d,0xe8},//e8//e1	 
+	{0x9e,0xef},//ef//ea	 
+	{0x9f,0xf8},//f7//f5	 
+	{0xa0,0xff},//ff//ff	 
+	//CCM	   
+	{0xfd,0x02},
+	{0x15,0xd0},//b>th
+	{0x16,0x95},//r<th
+	//gc\BE\B5ͷ\D5\D5\C8\CB\C1\B3ƫ\BB\C6
+	//!F		
+	{0xa0,0x80},//80
+	{0xa1,0x00},//00
+	{0xa2,0x00},//00
+	{0xa3,0x00},//06
+	{0xa4,0x8c},//8c
+	{0xa5,0xf4},//ed
+	{0xa6,0x0c},//0c
+	{0xa7,0xf4},//f4
+	{0xa8,0x80},//80
+	{0xa9,0x00},//00
+	{0xaa,0x30},//30
+	{0xab,0x0c},//0c 
+	//F 	   
+	{0xac,0x8c},
+	{0xad,0xf4},
+	{0xae,0x00},
+	{0xaf,0xed},
+	{0xb0,0x8c},
+	{0xb1,0x06},
+	{0xb2,0xf4},
+	{0xb3,0xf4},
+	{0xb4,0x99},
+	{0xb5,0x0c},
+	{0xb6,0x03},
+	{0xb7,0x0f},
+		
+	//sat u 	
+	{0xfd,0x01},
+	{0xd3,0x9c},//0x88//50
+	{0xd4,0x98},//0x88//50
+	{0xd5,0x8c},//50
+	{0xd6,0x84},//50
+	//sat v   
+	{0xd7,0x9c},//0x88//50
+	{0xd8,0x98},//0x88//50
+	{0xd9,0x8c},//50
+	{0xda,0x84},//50
+	//auto_sat	
+	{0xdd,0x30},
+	{0xde,0x10},
+	{0xd2,0x01},//autosa_en
+	{0xdf,0xff},//a0//y_mean_th
+		
+	//uv_th 	
+	{0xfd,0x01},
+	{0xc2,0xaa},
+	{0xc3,0xaa},
+	{0xc4,0x66},
+	{0xc5,0x66}, 
+
+	//heq
+	{0xfd,0x01},
+	{0x0f,0xff},
+	{0x10,SP0718_P1_0x10}, //out
+	{0x14,SP0718_P1_0x14}, 
+	{0x11,SP0718_P1_0x11}, //nr
+	{0x15,SP0718_P1_0x15},	
+	{0x12,SP0718_P1_0x12}, //dummy
+	{0x16,SP0718_P1_0x16}, 
+	{0x13,SP0718_P1_0x13}, //low	
+	{0x17,SP0718_P1_0x17},		
+
+	{0xfd,0x01},
+	{0xcd,0x20},
+	{0xce,0x1f},
+	{0xcf,0x20},
+	{0xd0,0x55},  
+	//auto 
+	{0xfd,0x01},
+	{0xfb,0x33},
+	{0x32,0x15},
+	{0x33,0xff},
+	{0x34,0xe7},
+	{0x35,0x00},	
+	//vga
+	{0xfd, 0x01},
+	{0x4a, 0x00},
+	{0x4b, 0x01},
+	{0x4c, 0xe0},
+	{0x4d, 0x00},
+	{0x4e, 0x02},
+	{0x4f, 0x80},
+
+	{0xfd, 0x02},
+	{0x0f, 0x00},	// 1/4 subsample disable
+
+	{0xfd, 0x00},
+	{0x30, 0x00},
+    ENDMARKER,
+};
+
+
+
+
+/* 640*480: VGA */
+static const struct regval_list module_vga_regs[] = 
+{
+
+	{0xfd, 0x01},
+	{0x4a, 0x00},
+	{0x4b, 0x01},
+	{0x4c, 0xe0},
+	{0x4d, 0x00},
+	{0x4e, 0x02},
+	{0x4f, 0x80},
+
+	{0xfd, 0x02},
+	{0x0f, 0x00},	// 1/4 subsample disable
+		
+	{0xfd, 0x00},
+	{0x30, 0x00},
+    ENDMARKER,
+};
+
+
+/* 640*480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_vga,
+};
+
+static struct regval_list module_whitebance_auto_regs[]=
+{	
+	{0xfd,0x02},                      
+	{0x26,0xc8},		                  
+	{0x27,0xb6},                      
+	{0xfd,0x01}, 		
+	{0x32,0x15},   
+	{0xfd,0x00},  
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	{0xfd,0x01}, 
+	{0x32,0x05},                 
+	{0xfd,0x02},                 
+	{0x26,0xdc},		             
+	{0x27,0xe5},		             
+	{0xfd,0x00}, 
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+	{0xfd,0x01}, 
+	{0x32,0x05},                 
+	{0xfd,0x02},                 
+	{0x26,0xc8},		             
+	{0x27,0x89},		             
+	{0xfd,0x00}, 
+    ENDMARKER,
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{	
+	{0xfd,0x01}, 
+	{0x32,0x05},                 
+	{0xfd,0x02},                 
+	{0x26,0x75},		             
+	{0x27,0xe2},		             
+	{0xfd,0x00}, 
+    ENDMARKER,
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	{0xfd,0x01}, 
+	{0x32,0x05},                 
+	{0xfd,0x02},                 
+	{0x26,0x91},		             
+	{0x27,0xc8},		             
+	{0xfd,0x00}, 
+	ENDMARKER,
+};
+
+
+static struct regval_list module_scene_auto_regs[] =
+{
+	ENDMARKER,
+};
+
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{   .id = V4L2_CID_EXPOSURE, 
+		.min = 0, 
+		.max = 975,
+		.step = 1, 
+		.def = 500,
+	},
+	{	.id = V4L2_CID_EXPOSURE_COMP, 
+		.min = -4, 
+		.max = 4, 
+		.step = 1, 
+		.def = 0,
+	},	
+	{	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,
+	},
+	{
+        .id = V4L2_CID_AUTO_WHITE_BALANCE,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 1,
+    },
+    {
+        .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+        .min = 0,
+        .max = 3,
+        .step = 1,
+        .def = 0,
+    },
+     {	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+
+    {
+        .id = V4L2_CID_HFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_VFLIP,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+    },
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	 {
+        .id = V4L2_CID_COLORFX,
+        .max = 3,
+        .mask = 0x0,
+        .def = 0,
+    },
+    {
+        .id = V4L2_CID_EXPOSURE_AUTO,
+        .max = 1,
+        .mask = 0x0,
+        .def = 1,
+    },
+	{  
+		   .id = V4L2_CID_SCENE_MODE, 
+		   .max = V4L2_SCENE_MODE_TEXT, 
+		   .mask = 0x0, 
+		   .def = 0,
+	},
+
+   	{	.id   = V4L2_CID_FLASH_LED_MODE, 
+		.max  = 3,
+		.mask = 0x0,
+		.def  = 0,},
+	{.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/sp0718/sp0718.c b/drivers/media/i2c/camera/sp0718/sp0718.c
new file mode 100755
index 0000000..871255d
--- /dev/null
+++ b/drivers/media/i2c/camera/sp0718/sp0718.c
@@ -0,0 +1,430 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include"../module_comm/camera_chip_ident.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+
+
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0)
+			{
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+			}
+		vals++;
+	}
+	return 0;
+}
+
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret = 0;
+
+	printk("in the sp0718 module_soft_reset\n");
+	
+	//msleep(10);
+	return ret;
+}
+static int  module_start_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+
+	//printk("int the module_start_aec\n ");
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_freeze_aec\n ");
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_set_exposure_param\n ");
+	return ret;
+}
+
+
+static int  module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	//printk("int the module_set_scene_exposure\n ");
+	return ret;
+}
+
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	//printk("int the module_save_exposure_param\n ");
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	//int auto_white_balance = ctrl->val;
+	int ret = 0;
+	
+	int auto_white_balance;
+		if(ctrl)
+			{
+			auto_white_balance = ctrl->val;
+		}
+		else 
+			{
+				auto_white_balance = 1;
+			}
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+		    ret = 0;
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		{
+	ctrl->cur.val = auto_white_balance;
+		}
+
+	return ret;
+}
+
+
+static int  module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+   // int exposure_auto = ctrl->val;
+	int ret = 0;
+	
+	int exposure_auto;
+		if(ctrl)
+			{
+			exposure_auto = ctrl->val;
+			}
+		else 
+			{
+				exposure_auto = V4L2_EXPOSURE_AUTO;
+			}
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		{
+	ctrl->cur.val = exposure_auto;
+		}
+
+	return 0;
+}
+
+
+
+
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	
+	int ret = 0;
+	unsigned int analog1;
+	mdelay(10);
+	//struct i2c_adapter *i2c_adap = client->adapter;
+    camera_i2c_read(client->adapter, 0x1a, &analog1);
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+		     /* power down all analog modules */
+		analog1 |= 0x01;
+        ret = camera_i2c_write(client->adapter, 0x1a,analog1 );
+        /* power down data, pclk, vsync, hsync */
+        ret = camera_i2c_write(client->adapter, 0x25, 0x00);
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	   analog1 &= 0xfe;
+	   ret = camera_i2c_write(client->adapter, 0x1a,analog1);
+       ret = camera_i2c_write(client->adapter, 0x25, 0xff);
+	   return ret;
+}
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+	int ret = 0;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		
+		break;
+		
+	default:
+		return -ERANGE;
+	}
+	
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	
+	int ret = 0;
+	
+	return ret;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int  		pid;
+	int ret = 0;
+	camera_i2c_write(i2c_adap,0xfd,0x00);
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PID, &pid); 
+	switch (pid) 
+    {
+	case CAMERA_MODULE_PID:
+		if(priv)
+			{
+		     priv->model= V4L2_IDENT_SP0718;
+			}
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, pid);
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, pid);
+		return -ENODEV;
+	}
+	return ret;
+}
+
+
+
diff --git a/drivers/media/i2c/camera/sp0a19/Kconfig b/drivers/media/i2c/camera/sp0a19/Kconfig
new file mode 100755
index 0000000..cb193bf
--- /dev/null
+++ b/drivers/media/i2c/camera/sp0a19/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config SP0A19
+	tristate "sp0a19 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for sp0a19 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sp0a19.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/sp0a19/Makefile b/drivers/media/i2c/camera/sp0a19/Makefile
new file mode 100755
index 0000000..dd2d825
--- /dev/null
+++ b/drivers/media/i2c/camera/sp0a19/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SP0A19)	+= sp0a19.o
+
diff --git a/drivers/media/i2c/camera/sp0a19/module_diff.h b/drivers/media/i2c/camera/sp0a19/module_diff.h
new file mode 100755
index 0000000..b170121
--- /dev/null
+++ b/drivers/media/i2c/camera/sp0a19/module_diff.h
@@ -0,0 +1,833 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME 		"sp0a19"
+#define CAMERA_MODULE_PID		0xa6
+#define VERSION(pid, ver) 		((pid<<8)|(ver&0xFF))
+
+#define MODULE_PLATFORM_ID		SP0A19_PLATFORM_ID
+#define MODULE_I2C_REAL_ADDRESS		(0x42>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x42>>1)
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+
+#define PID						0x02 /* Product ID Number */
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_PCLK_SAMPLE_EDGE      	V4L2_MBUS_PCLK_SAMPLE_RISING 
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_QVGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_QVGA
+#define MODULE_MAX_WIDTH		WIDTH_VGA
+#define MODULE_MAX_HEIGHT		HEIGHT_VGA
+
+#define AHEAD_LINE_NUM			15    //10ÐÐ = 50´ÎÑ­»·
+#define DROP_NUM_CAPTURE		3
+#define DROP_NUM_PREVIEW		5
+
+static unsigned int frame_rate_qvga[]  = {30,};
+static unsigned int frame_rate_vga[]   = {30,};
+
+//AE target
+#define  SP0A19_P0_0xf7  0x88
+#define  SP0A19_P0_0xf8  0x80
+#define  SP0A19_P0_0xf9  0x70
+#define  SP0A19_P0_0xfa  0x68
+//HEQ
+#define  SP0A19_P0_0xdd  0x78	//0x7c
+#define  SP0A19_P0_0xde  0xa0	//0xc4
+
+static const struct regval_list module_init_regs[] =
+{
+	/*init registers code.*/
+	{0xfd,0x00},
+	{0x1c,0x28},
+	{0x32,0x00},
+	{0x0f,0x2f},
+	{0x10,0x2e},
+	{0x11,0x00},
+	{0x12,0x18},
+	{0x13,0x2f},
+	{0x14,0x00},
+	{0x15,0x3f},
+	{0x16,0x00},
+	{0x17,0x18},
+	{0x25,0x40},
+	{0x1a,0x0b},
+	{0x1b,0xc },
+	{0x1e,0xb },
+	{0x20,0x3f},
+	{0x21,0x13},
+	{0x22,0x19},
+	{0x26,0x1a},
+	{0x27,0xab},
+	{0x28,0xfd},
+	{0x30,0x00},
+	{0x31,0x10}, //0x00
+	{0xfb,0x33}, //0x31
+	{0x1f,0x08},  
+
+	//Blacklevel
+	{0xfd,0x00},
+	{0x65,0x00},//06
+	{0x66,0x00},//06
+	{0x67,0x00},//06
+	{0x68,0x00},//06
+	{0x45,0x00},
+	{0x46,0x0f},
+
+#if 0
+	//ae setting 
+	{0xfd,0x00},
+	{0x03,0x01},
+	{0x04,0x32},
+	{0x06,0x00},
+	{0x09,0x01},
+	{0x0a,0x46},
+	{0xf0,0x66},
+	{0xf1,0x00},
+	{0xfd,0x01},
+	{0x90,0x0c},
+	{0x92,0x01},
+	{0x98,0x66},
+	{0x99,0x00},
+	{0x9a,0x01},
+	{0x9b,0x00},
+
+	//Status
+	{0xfd,0x01},
+	{0xce,0xc8},
+	{0xcf,0x04},
+	{0xd0,0xc8},
+	{0xd1,0x04}, 
+#else
+	//24M 50HZ 20-6 FPS 
+	//ae setting
+	{0xfd,0x00},
+	{0x03,0x01},
+	{0x04,0x32},
+	{0x06,0x00},
+	{0x09,0x01},
+	{0x0a,0x46},
+	{0xf0,0x66},
+	{0xf1,0x00},
+	{0xfd,0x01},
+	{0x90,0x10},
+	{0x92,0x01},
+	{0x98,0x66},
+	{0x99,0x00},
+	{0x9a,0x01},
+	{0x9b,0x00},
+	//Status
+	{0xfd,0x01},
+	{0xce,0x60},
+	{0xcf,0x06},
+	{0xd0,0x60},
+	{0xd1,0x06},
+	{0xfd,0x00},
+#endif
+
+	{0xfd,0x01},
+	{0xc4,0x56},
+	{0xc5,0x8f},
+	{0xca,0x30},
+	{0xcb,0x45},
+	{0xcc,0x70},
+	{0xcd,0x48},
+	{0xfd,0x00},
+
+	//lsc  for st
+	{0xfd,0x01},
+	{0x35,0x15},
+	{0x36,0x15},
+	{0x37,0x15},
+	{0x38,0x15},
+	{0x39,0x15},
+	{0x3a,0x15},
+	{0x3b,0x13},
+	{0x3c,0x15},
+	{0x3d,0x15},
+	{0x3e,0x15},
+	{0x3f,0x15},
+	{0x40,0x18},
+	{0x41,0x00},
+	{0x42,0x04},
+	{0x43,0x04},
+	{0x44,0x00},
+	{0x45,0x00},
+	{0x46,0x00},
+	{0x47,0x00},
+	{0x48,0x00},
+	{0x49,0xfd},
+	{0x4a,0x00},
+	{0x4b,0x00},
+	{0x4c,0xfd},
+	{0xfd,0x00},  
+	//awb 1
+	{0xfd,0x01},
+	{0x28,0xc5},
+	{0x29,0x9b},
+	{0x2e,0x02},	
+	{0x2f,0x16},
+	{0x17,0x17},
+	{0x18,0x19},
+	{0x19,0x45},
+	{0x2a,0xef},
+	{0x2b,0x15},  
+	//awb2
+	{0xfd,0x01},
+	{0x73,0x80},
+	{0x1a,0x80},
+	{0x1b,0x80}, 
+	//d65
+	{0x65,0xd5},
+	{0x66,0xfa},
+	{0x67,0x72},
+	{0x68,0x8a},
+	//indoor
+	{0x69,0xc6},
+	{0x6a,0xee},
+	{0x6b,0x94},
+	{0x6c,0xab},
+	//f
+	{0x61,0x7a},
+	{0x62,0x98},
+	{0x63,0xc5},
+	{0x64,0xe6},
+	//cwf
+	{0x6d,0xb9},
+	{0x6e,0xde},
+	{0x6f,0xb2},
+	{0x70,0xd5},
+
+	//////////////////skin detect//////
+	{0xfd,0x01},
+	{0x08,0x15},
+	{0x09,0x04},
+	{0x0a,0x20},
+	{0x0b,0x12},
+	{0x0c,0x27},
+	{0x0d,0x06},
+	{0x0f,0x63},  
+	//BPC_grad
+	{0xfd,0x00},
+	{0x79,0xf0},
+	{0x7a,0x80},  //f0
+	{0x7b,0x80},  //f0
+	{0x7c,0x20},  //f0  
+
+#if 0 //default
+	//smooth
+	{0xfd,0x00},
+	//µ¥Í¨µÀ¼äÆ½»¬ãÐÖµ	
+	{0x57,0x08},	//raw_dif_thr_outdoor
+	{0x58,0x0c}, //raw_dif_thr_normal
+	{0x56,0x0e}, //raw_dif_thr_dummy
+	{0x59,0x12}, //raw_dif_thr_lowlight
+	//GrGbÆ½»¬ãÐÖµ
+	{0x89,0x08},	//raw_grgb_thr_outdoor 
+	{0x8a,0x0c}, //raw_grgb_thr_normal  
+	{0x9c,0x0e}, //raw_grgb_thr_dummy   
+	{0x9d,0x12}, //raw_grgb_thr_lowlight
+
+	//Gr\GbÖ®¼äÆ½»¬Ç¿¶È
+	{0x81,0xe0},    //raw_gflt_fac_outdoor
+	{0x82,0x80}, //80//raw_gflt_fac_normal
+	{0x83,0x40},    //raw_gflt_fac_dummy
+	{0x84,0x20},    //raw_gflt_fac_lowlight
+	//Gr¡¢Gbµ¥Í¨µÀÄÚÆ½»¬Ç¿¶È  
+	{0x85,0xe0}, //raw_gf_fac_outdoor  
+	{0x86,0x80}, //raw_gf_fac_normal  
+	{0x87,0x40}, //raw_gf_fac_dummy   
+	{0x88,0x20}, //raw_gf_fac_lowlight
+	//R¡¢BÆ½»¬Ç¿¶È  
+	{0x5a,0xff},		 //raw_rb_fac_outdoor
+	{0x5b,0xe0}, //40//raw_rb_fac_normal
+	{0x5c,0x80}, 	 //raw_rb_fac_dummy
+	{0x5d,0x20}, 	 //raw_rb_fac_lowlight
+
+	//sharpen 
+	{0xfd,0x01},
+	{0xe2,0x50},	//sharpen_y_base
+	{0xe4,0xa0},	//sharpen_y_max
+
+	{0xe5,0x08}, //rangek_neg_outdoor
+	{0xd3,0x08}, //rangek_pos_outdoor   
+	{0xd7,0x08}, //range_base_outdoor   
+
+	{0xe6,0x0a}, //rangek_neg_normal
+	{0xd4,0x0a}, //rangek_pos_normal 
+	{0xd8,0x0a}, //range_base_normal  
+
+	{0xe7,0x12}, //rangek_neg_dummy
+	{0xd5,0x12}, //rangek_pos_dummy
+	{0xd9,0x12}, //range_base_dummy  
+
+	{0xd2,0x15}, //rangek_neg_lowlight
+	{0xd6,0x15}, //rangek_pos_lowlight
+	{0xda,0x15}, //range_base_lowlight
+
+	{0xe8,0x20},//sharp_fac_pos_outdoor
+	{0xec,0x2c},//sharp_fac_neg_outdoor
+	{0xe9,0x20},//sharp_fac_pos_nr
+	{0xed,0x2c},//sharp_fac_neg_nr
+	{0xea,0x18},//sharp_fac_pos_dummy
+	{0xef,0x1c},//sharp_fac_neg_dummy
+	{0xeb,0x15},//sharp_fac_pos_low
+	{0xf0,0x18},//sharp_fac_neg_low 
+#else
+	//smooth
+	{0xfd,0x00},
+	//µ¥Í¨µÀ¼äÆ½»¬ãÐÖµ	
+	{0x57,0x0c},	//raw_dif_thr_outdoor
+	{0x58,0x14}, //raw_dif_thr_normal
+	{0x56,0x18}, //raw_dif_thr_dummy
+	{0x59,0x18}, //raw_dif_thr_lowlight
+	//GrGbÆ½»¬ãÐÖµ
+	{0x89,0x0c},	//raw_grgb_thr_outdoor 
+	{0x8a,0x14}, //raw_grgb_thr_normal  
+	{0x9c,0x18}, //raw_grgb_thr_dummy   
+	{0x9d,0x18}, //raw_grgb_thr_lowlight
+
+	//Gr\GbÖ®¼äÆ½»¬Ç¿¶È
+	{0x81,0xd8},    //raw_gflt_fac_outdoor
+	{0x82,0xd4}, //80//raw_gflt_fac_normal
+	{0x83,0x74},    //raw_gflt_fac_dummy
+	{0x84,0x40},    //raw_gflt_fac_lowlight
+	//Gr¡¢Gbµ¥Í¨µÀÄÚÆ½»¬Ç¿¶È  
+	{0x85,0xd8}, //raw_gf_fac_outdoor  
+	{0x86,0xb4}, //raw_gf_fac_normal  
+	{0x87,0x74}, //raw_gf_fac_dummy   
+	{0x88,0x40}, //raw_gf_fac_lowlight
+	//R¡¢BÆ½»¬Ç¿¶È  
+	{0x5a,0xff},		 //raw_rb_fac_outdoor
+	{0x5b,0xd4}, //40//raw_rb_fac_normal
+	{0x5c,0x74}, 	 //raw_rb_fac_dummy
+	{0x5d,0x00}, 	 //raw_rb_fac_lowlight
+
+	//sharpen 
+	{0xfd,0x01},
+	{0xe2,0x30},	//sharpen_y_base
+	{0xe4,0xa0},	//sharpen_y_max
+
+	{0xe5,0x08}, //rangek_neg_outdoor
+	{0xd3,0x08}, //rangek_pos_outdoor   
+	{0xd7,0x08}, //range_base_outdoor   
+
+	{0xe6,0x0a}, //rangek_neg_normal
+	{0xd4,0x0a}, //rangek_pos_normal 
+	{0xd8,0x0a}, //range_base_normal  
+
+	{0xe7,0x0c}, //rangek_neg_dummy
+	{0xd5,0x0c}, //rangek_pos_dummy
+	{0xd9,0x0c}, //range_base_dummy  
+
+	{0xd2,0x16}, //rangek_neg_lowlight
+	{0xd6,0x16}, //rangek_pos_lowlight
+	{0xda,0x16}, //range_base_lowlight
+
+	{0xe8,0x20},//sharp_fac_pos_outdoor
+	{0xec,0x2c},//sharp_fac_neg_outdoor
+	{0xe9,0x20},//sharp_fac_pos_nr
+	{0xed,0x2c},//sharp_fac_neg_nr
+	{0xea,0x1c},//sharp_fac_pos_dummy
+	{0xef,0x20},//sharp_fac_neg_dummy
+	{0xeb,0x18},//sharp_fac_pos_low
+	{0xf0,0x1c},//sharp_fac_neg_low 
+#endif
+
+#if 0 //default
+	//CCM
+	{0xfd,0x01},
+	{0xa0,0x66},//80(ºìÉ«½Ó½ü£¬·ôÉ«²»ÀíÏë)
+	{0xa1,0x0 },//0 
+	{0xa2,0x19},//0 
+	{0xa3,0xf3},//f0
+	{0xa4,0x8e},//a6
+	{0xa5,0x0 },//ea
+	{0xa6,0x0 },//0 
+	{0xa7,0xe6},//e6
+	{0xa8,0x9a},//9a
+	{0xa9,0x0 },//0 
+	{0xaa,0x3 },//33
+	{0xab,0xc },//c 
+	{0xfd,0x00},
+#else
+	{0xfd,0x01},
+	{0xa0,0x7c},//80(o¨¬¨¦??¨®?¨¹¡ê?¡¤?¨¦?2?¨¤¨ª??)
+	{0xa1,0x0 },//0 
+	{0xa2,0x0 },//0 
+	{0xa3,0xf3},//f0
+	{0xa4,0x8e},//a6
+	{0xa5,0x0 },//ea
+	{0xa6,0x0 },//0 
+	{0xa7,0xe6},//e6
+	{0xa8,0x9a},//9a
+	{0xa9,0x0 },//0 
+	{0xaa,0x3 },//33
+	{0xab,0xc },//c 
+	{0xfd,0x00},
+#endif
+
+	//gamma  
+
+	{0xfd,0x00},
+	{0x8b,0x0 },//0 
+	{0x8c,0xC },//11
+	{0x8d,0x19},//19 
+	{0x8e,0x2C},//28 
+	{0x8f,0x49},//46 
+	{0x90,0x61},//61 
+	{0x91,0x77},//78 
+	{0x92,0x8A},//8A 
+	{0x93,0x9B},//9B 
+	{0x94,0xA9},//A9 
+	{0x95,0xB5},//B5 
+	{0x96,0xC0},//C0 
+	{0x97,0xCA},//CA 
+	{0x98,0xD4},//D4 
+	{0x99,0xDD},//DD 
+	{0x9a,0xE6},//E6 
+	{0x9b,0xEF},//EF 
+	{0xfd,0x01},//01 
+	{0x8d,0xF7},//F7 
+	{0x8e,0xFF},//FF 
+
+	//rpc
+	{0xfd,0x00},
+	{0xe0,0x4c},
+	{0xe1,0x3c},
+	{0xe2,0x34},
+	{0xe3,0x2e},
+	{0xe4,0x2e},
+	{0xe5,0x2c},
+	{0xe6,0x2c},
+	{0xe8,0x2a},
+	{0xe9,0x2a},
+	{0xea,0x2a},
+	{0xeb,0x28},
+	{0xf5,0x28},
+	{0xf6,0x28},
+	//ae min gain  
+	{0xfd,0x01},
+	{0x94,0x80},//rpc_max_indr 0xa0
+	{0x95,0x28},//1e//rpc_min_indr 
+	{0x9c,0xa0},//rpc_max_outdr
+	{0x9d,0x28},//rpc_min_outdr    
+
+	//ae target
+	{0xfd,0x00}, 
+	{0xed,SP0A19_P0_0xf7+0x04}, 
+	{0xf7,SP0A19_P0_0xf7},
+	{0xf8,SP0A19_P0_0xf8},  
+	{0xec,SP0A19_P0_0xf8-0x04},
+	{0xef,SP0A19_P0_0xf9+0x04},
+	{0xf9,SP0A19_P0_0xf9},
+	{0xfa,SP0A19_P0_0xfa},  
+	{0xee,SP0A19_P0_0xfa-0x04}, 
+	//gray detect
+	{0xfd,0x01},
+	{0x30,0x40},
+	{0x31,0x70},//
+	{0x32,0x40},//80
+	{0x33,0xef},//
+	{0x34,0x05},//04
+	{0x4d,0x2f},//40
+	{0x4e,0x20},//
+	{0x4f,0x16},//13      
+	//lowlight lum
+	{0xfd,0x00}, 
+	{0xb2,0x10},//lum_limit
+	{0xb3,0x1f},//lum_set
+	{0xb4,0x30},//black_vt
+	{0xb5,0x45},//white_vt
+	//saturation
+	{0xfd,0x00},
+	{0xbe,0xff},
+	{0xbf,0x01}, 
+	{0xc0,0xff},
+	{0xc1,0xd8},
+	{0xd3,0x80},//0x78
+	{0xd4,0x80},//0x78
+	{0xd6,0x78},//0x70      
+	{0xd7,0x78},//0x50
+	//HEQ
+	{0xfd,0x00},
+	{0xdc,0x00},
+	{0xdd,SP0A19_P0_0xdd},
+	{0xde,SP0A19_P0_0xde},//80
+	{0xdf,0x80},    
+	//func enable
+	{0xfd,0x00},
+	{0x32,0x15},//d
+	{0x34,0x76},//16
+	{0x35,0x40},
+	{0x33,0xef},
+	{0x5f,0x51},
+	ENDMARKER,
+};
+
+/* 320*240: QVGA */
+static const struct regval_list module_qvga_regs[] = 
+{
+	{0xfd,0x01},  
+	{0x0e,0x03},
+	{0xfd,0x00},
+	{0x30,0x10},
+ENDMARKER,
+};
+
+/* 640*480: VGA */
+static const struct regval_list module_vga_regs[] = 
+{
+	{0xfd,0x01},  
+	{0x0e,0x00},
+	{0xfd,0x00},
+	{0x30,0x00},
+ENDMARKER,
+};
+
+static const struct regval_list module_init_auto_focus[] =
+{
+ENDMARKER,
+//  NULL
+};
+    
+/*
+ * window size list
+ */
+/* 320*240 */
+static struct camera_module_win_size module_win_qvga = {
+	.name             = "QVGA",
+	.width            = WIDTH_QVGA,
+	.height           = HEIGHT_QVGA,
+	.win_regs         = module_qvga_regs,
+
+	.frame_rate_array = frame_rate_qvga,
+	.capture_only     = 0,
+};
+
+/* 640*480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_qvga,
+	&module_win_vga,
+};
+  
+static struct regval_list module_whitebance_auto_regs[]=
+{
+	{0xfd,0x01},                      
+	{0x28,0xc5},		                  
+	{0x29,0x9b},                      
+	{0xfd,0x00}, 		
+	{0x32,0x15},   //awb & ae  opened
+	{0xfd,0x00}, 
+	ENDMARKER, 
+};
+
+static struct regval_list module_whitebance_none_auto_regs[]=
+{
+	//{0xfd,0x01},	
+	//{0x28,0xce},	
+	//{0x29,0x8a},
+	{0xfd,0x00},
+	{0x32,0x05},
+	ENDMARKER,
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+	{0xfd,0x00}, 
+	{0x32,0x05},          
+	{0xfd,0x01},          
+	{0x28,0xbf},	        
+	{0x29,0x89},	        
+	{0xfd,0x00},
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+	{0xfd,0x00}, 
+	{0x32,0x05},           
+	{0xfd,0x01},           
+	{0x28,0xbc},	         
+	{0x29,0x5d},	         
+	{0xfd,0x00},
+	ENDMARKER, 		
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,Ó«¹âµÆ */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+	{0xfd,0x00},  
+	{0x32,0x05},                  
+	{0xfd,0x01},                  
+	{0x28,0xaf},		              
+	{0x29,0x99},		              
+	{0xfd,0x00},
+	ENDMARKER,	
+};
+
+/* Home Colour Temperature : 2500K - 3500K £¬°×³ãµÆ */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+	{0xfd,0x00}, 
+	{0x32,0x05},                 
+	{0xfd,0x01},                 
+	{0x28,0x89},		             
+	{0x29,0xb8},		             
+	{0xfd,0x00}, 
+	ENDMARKER,
+};
+#if 0
+/*正常模式*/
+static struct regval_list module_effect_normal_regs[] =
+{
+	{0xfd, 0x00},
+	{0x62, 0x00},
+	{0x63, 0x80},
+	{0x64, 0x80},
+	ENDMARKER,
+};
+
+/*µ¥É«£¬ºÚ°×ÕÕÆ¬*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+	{0xfd, 0x00},
+	{0x62, 0x20},
+	{0x63, 0x80},
+	{0x64, 0x80},
+	ENDMARKER,
+};
+
+/*¸ºÆ¬Ð§¹û*/
+static struct regval_list module_effect_negative_regs[] =
+{
+	{0xfd, 0x00},
+	{0x62, 0x04},
+	{0x63, 0x80},
+	{0x64, 0x80},
+	ENDMARKER,
+};
+
+/*¸´¹ÅÐ§¹û*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+	{0xfd, 0x00},
+	{0x62, 0x10},
+	{0x63, 0xc0},
+	{0x64, 0x20},
+	ENDMARKER,
+};
+#endif
+static struct regval_list module_scene_auto_regs[] =
+{
+    {0xfd, 0x00},
+    {0xdc, 0x00},
+	ENDMARKER,
+};
+#if 0
+static struct regval_list module_scene_night_regs[] =
+{
+    {0xfd, 0x00},
+    {0xdc, 0x20},
+	ENDMARKER,
+};
+
+static  struct regval_list module_scene_portrait[] =
+{
+//  NULL
+ENDMARKER,
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list module_exp_comp_neg4_regs[] = {
+//  NULL
+ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg3_regs[] = {
+//  NULL
+ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg2_regs[] = {
+//  NULL
+ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg1_regs[] = {
+//  NULL
+ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_zero_regs[] = {
+//  NULL
+ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos1_regs[] = {
+//  NULL
+ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos2_regs[] = {
+//  NULL
+ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos3_regs[] = {
+//  NULL
+ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos4_regs[] = {
+//  NULL
+ENDMARKER,
+};
+#endif
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{	.id   = V4L2_CID_AUTO_WHITE_BALANCE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 1,},
+	{	.id   = V4L2_CID_WHITE_BALANCE_TEMPERATURE, 
+		.min  = 0, 
+		.max  = 3, 
+		.step = 1, 
+		.def  = 1,},
+	{	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,},
+	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+	
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,
+	},
+#if 0
+	{	.id   = V4L2_CID_SCENE_EXPOSURE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},//3.4ÄÚºËÃ»ÓÐ¶¨Òå´ËÃüÁî×Ö
+	{	.id   = V4L2_CID_PRIVATE_PREV_CAPT, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = PREVIEW_MODE,},//3.4ÄÚºËÃ»ÓÐ¶¨Òå´ËÃüÁî×Ö
+
+	{	.id   = V4L2_CID_GAIN, 
+		.min  = 0,
+		.max  = 0,
+		.step = 0,
+		.def  = 0,},
+	{   .id   = V4L2_CID_EXPOSURE, 
+		.min  = 0, 
+		.max  = 0,
+		.step = 0, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_EXPOSURE_COMP, 
+		.min  = -4, 
+		.max  = 4, 
+		.step = 1, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},
+    {	.id   = V4L2_CID_AF_MODE,
+		.min  = NONE_AF, 
+		.max  = CONTINUE_AF|SINGLE_AF, 
+		.step = 1, 
+		.def  = CONTINUE_AF|SINGLE_AF,},
+	{	.id   = V4L2_CID_AF_STATUS, 
+		.min  = AF_STATUS_DISABLE, 
+		.max  = AF_STATUS_FAIL, 
+		.step = 1, 
+		.def  = AF_STATUS_DISABLE,},
+#endif
+		{	.id = V4L2_CID_MIRRORFLIP, //3.10ÄÚºËÃ»ÓÐ¶¨Òå´ËÃüÁî×Ö,Í¬Ê±Ð´ÈëvflipºÍhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	{	.id   = V4L2_CID_COLORFX, 
+		.max  = 3, 
+		.mask = 0x0, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_EXPOSURE_AUTO, 
+		.max  = 1, 
+		.mask = 0x0, 
+		.def  = 1,},
+	{  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_TEXT, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+#if 1
+	{	.id   = V4L2_CID_FLASH_LED_MODE, 
+		.max  = 3,
+		.mask = 0x0,
+		.def  = 0,},
+#endif
+	{.id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/sp0a19/sp0a19.c b/drivers/media/i2c/camera/sp0a19/sp0a19.c
new file mode 100755
index 0000000..f4a0c3e
--- /dev/null
+++ b/drivers/media/i2c/camera/sp0a19/sp0a19.c
@@ -0,0 +1,591 @@
+/*
+ * XXX Camera Driver
+ *
+ * Copyright (C) 2013 Actions Semiconductor Co.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include"../module_comm/camera_chip_ident.h"
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d", CAMERA_MODULE_NAME,ret);
+		return ret;
+	}
+
+
+	
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register%s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0){
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+		}
+		vals++;
+	}
+	return 0;
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+/*
+static int module_soft_standby(struct i2c_client *client)
+{
+	int ret = 0;
+
+	return ret;	
+}
+
+static int module_normal(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+#if 0
+	unsigned int reg_0x31;
+	unsigned int reg_0xfd;
+
+	reg_0xfd = 0x00;
+	ret = camera_i2c_write(client, 0xfd, reg_0xfd);
+	ret = camera_i2c_read(client, 0x31, &reg_0x31);
+#endif
+
+	return ret;
+}
+*/
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	
+	return ret;
+}
+
+int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int auto_white_balance;
+	int ret = 0;
+	
+	if(ctrl)
+		auto_white_balance = ctrl->val;
+	else
+		auto_white_balance = 1;
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+	switch(auto_white_balance)
+	{
+		case 0:
+			ret = camera_write_array(i2c_adap, module_whitebance_none_auto_regs);
+		    break;
+		    
+		case 1:	
+			ret = camera_write_array(i2c_adap, module_whitebance_auto_regs);
+			break;
+		
+		default:
+			break;
+	}
+	
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		ctrl->cur.val = auto_white_balance;  
+		
+
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+  	struct i2c_adapter *i2c_adap = client->adapter;
+  	int white_balance_temperature = ctrl->val;
+	int ret = 0;
+
+	switch(white_balance_temperature) {
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+#if 0
+static int module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    struct i2c_adapter *i2c_adap = client->adapter;
+    int colorfx = ctrl->val;
+	int ret = 0;
+
+	switch (colorfx) {
+	case V4L2_COLORFX_NONE: /* normal */
+		ret = camera_write_array(i2c_adap, module_effect_normal_regs);
+		break;
+	
+	case V4L2_COLORFX_BW: /* black and white */
+		ret = camera_write_array(i2c_adap, module_effect_white_black_regs);
+		break;
+	
+	case V4L2_COLORFX_SEPIA: /* antique ,\B8\B4\B9\C5*/
+		ret = camera_write_array(i2c_adap, module_effect_antique_regs);
+		break;
+
+	case V4L2_COLORFX_NEGATIVE: /* negative\A3\AC\B8\BAƬ */
+		ret = camera_write_array(i2c_adap, module_effect_negative_regs);
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	priv->colorfx = colorfx;
+	ctrl->cur.val = colorfx;
+
+	return ret;
+}
+#endif 
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    int exposure_auto;
+	int ret = 0;
+
+	if(ctrl)
+		exposure_auto = ctrl->val;
+	else
+		exposure_auto = V4L2_EXPOSURE_AUTO;
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	case V4L2_EXPOSURE_MANUAL: // non auto
+		ret = 0;
+		break;
+	}
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		ctrl->cur.val = exposure_auto;
+
+
+	return 0;
+}
+
+static int module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{	
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+  int scene_exposure = ctrl->val;
+	
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_HOUSE:  //\CA\D2\C4\DA
+		ret = camera_write_array(i2c_adap, module_scene_night_regs);
+		break;
+	
+	case V4L2_SCENE_MODE_SUNLIGHT:  //\CA\D2\CD\E2
+		ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+	default:
+		return -ERANGE;
+	}
+
+	priv->scene_exposure = scene_exposure;
+	ctrl->cur.val = scene_exposure;
+	*/
+	return ret;
+}
+
+/*
+static int module_set_prev_capt_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+    int mode = ctrl->val;
+#if 0
+	switch(mode) {
+	case PREVIEW_MODE:
+		priv->prev_capt_mode = mode;
+		break;
+
+	case CAPTURE_MODE:
+        priv->prev_capt_mode = mode;
+		break;
+	
+	default:
+		return -ERANGE;
+	}
+	
+	ctrl->cur.val = mode;
+#endif
+	return 0;
+}
+
+static int module_pause_af(struct i2c_client *client)
+{
+	int ret = 0;
+	
+	return ret;
+}
+
+static int module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	
+	return ret;
+}
+static int module_set_exposure(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+
+	return ret;
+}
+*/
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+/* 	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	unsigned char reg_0xfe = 0x00;
+	unsigned char reg_0xf3 = 0xff;
+	struct i2c_adapter *i2c_adap = client->adapter;
+	GC_INFO("");
+	   if (!enable) {
+		   GC_INFO("stream down");
+		   reg_0xf3 = 0x00;
+		   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+		   camera_i2c_write(i2c_adap, 0xf3, reg_0xf3);
+		   return ret;
+	   }
+	
+	   if (NULL == priv->win || NULL == priv->cfmt) {
+		   GC_ERR("cfmt or win select error");
+		   return (-EPERM);
+	   }	
+	   GC_INFO("stream on");
+	   reg_0xf3 = 0xff;
+	   camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	   camera_i2c_write(i2c_adap, 0xf3, reg_0xf3); */
+	return 0;
+}
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	unsigned int total_gain = 0;
+	
+	return total_gain;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+int module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+
+	return ret;
+}
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	enum v4l2_mbus_pixelcode code;
+		struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	unsigned int reg_0xfd;
+	unsigned int reg_0x35;
+	
+	code = cfmt->code;
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_0xfd = 0x00;
+		reg_0x35 = 0x40;
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+	    reg_0xfd = 0x00;	
+	    reg_0x35 = 0x00;
+
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+	    reg_0xfd = 0x00;	
+	    reg_0x35 = 0x41;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+	    reg_0xfd = 0x00;	
+	    reg_0x35 = 0x01;
+		break;
+		
+	default:
+		return -ERANGE;
+	}
+	
+	ret  = camera_i2c_write(i2c_adap, 0xfd, reg_0xfd);	
+	ret |= camera_i2c_write(i2c_adap, 0x35, reg_0x35);	
+	
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	unsigned int reg_0x31= 0x10;
+	unsigned int reg_0xfd= 0x00;
+
+	if ((!mirror) && (!flip)) {
+		return 0;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfd, reg_0xfd);
+	ret |= camera_i2c_read(i2c_adap, 0x31, &reg_0x31);
+	
+	if (mirror)	{
+		reg_0x31 |= 0x20;
+	} else {
+		reg_0x31 &= (~0x20);
+	}
+	
+	if (flip) {
+		reg_0x31 |= 0x40;
+	} else {
+		reg_0x31 &= (~0x40);	
+	}
+
+	ret |= camera_i2c_write(i2c_adap, 0x31, reg_0x31);	
+
+	return ret;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int  		pid = 0;
+
+	int ret = 0;
+
+    /*
+	 * check and show product ID and manufacturer ID
+	 */  
+	ret = camera_i2c_read(i2c_adap, PID, &pid); 
+	switch (pid) 
+    {
+	case CAMERA_MODULE_PID:
+		/*if(priv)
+			priv->model = V4L2_IDENT_GC0312;*/
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME, PID);
+		break;
+	
+	default:
+		printk("[sp0a19] Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+	
+	return ret;
+}
+#if 0
+void module_power_on_sequence(struct device *dev)
+{
+	disable_module_power_down(dev);
+#if 0
+	mdelay(10);
+	enable_module_power_down(dev);
+	mdelay(10);
+	disable_module_power_down(dev);
+	mdelay(10);
+#endif
+	enable_module_clk();
+	enable_module_reset(dev);
+}
+
+void module_power_off_sequence(struct device *dev)
+{
+    disable_module_clk();
+    enable_module_power_down(dev);
+    disable_module_reset(dev);
+}
+
+void module_extra_handle(struct i2c_client *client)
+{
+//	struct camera_module_priv *priv = to_camera_priv(client);
+	
+}
+#endif
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
diff --git a/drivers/media/i2c/camera/sp2519/Kconfig b/drivers/media/i2c/camera/sp2519/Kconfig
new file mode 100755
index 0000000..220d30c
--- /dev/null
+++ b/drivers/media/i2c/camera/sp2519/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions CPU si or isp driver and the camera sensors of Actions support 
+#
+# 
+
+config SP2519
+	tristate "sp2519 camera sensor driver"
+	depends on VIDEO_V4L2 && I2C
+	help
+	  Support for sp2519 camera
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sp2519.
\ No newline at end of file
diff --git a/drivers/media/i2c/camera/sp2519/Makefile b/drivers/media/i2c/camera/sp2519/Makefile
new file mode 100755
index 0000000..4fda629
--- /dev/null
+++ b/drivers/media/i2c/camera/sp2519/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SP2519)	+= sp2519.o
+
diff --git a/drivers/media/i2c/camera/sp2519/module_diff.h b/drivers/media/i2c/camera/sp2519/module_diff.h
new file mode 100755
index 0000000..afcdd54
--- /dev/null
+++ b/drivers/media/i2c/camera/sp2519/module_diff.h
@@ -0,0 +1,1133 @@
+/*
+ * module different macro
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MODULE_DIFF_H__
+#define __MODULE_DIFF_H__
+
+#include "./../module_comm/module_comm.h"
+
+#define CAMERA_MODULE_NAME 		"sp2519"
+
+#define MODULE_I2C_REAL_ADDRESS		(0x60>>1)
+#define MODULE_I2C_REG_ADDRESS		(0x60>>1)
+#define I2C_REGS_WIDTH			1
+#define I2C_DATA_WIDTH			1
+
+#define OUTTO_SENSO_CLOCK 		24000000
+
+#define DEFAULT_HSYNC_ACTIVE_LEVEL 		V4L2_MBUS_HSYNC_ACTIVE_HIGH
+#define DEFAULT_VSYNC_ACTIVE_LEVEL		V4L2_MBUS_VSYNC_ACTIVE_HIGH
+#define DEFAULT_PCLK_SAMPLE_EDGE      	V4L2_MBUS_PCLK_SAMPLE_FALLING
+#define DEFAULT_POWER_LINE_FREQUENCY	V4L2_CID_POWER_LINE_FREQUENCY_50HZ
+
+#define MODULE_DEFAULT_WIDTH	WIDTH_VGA
+#define MODULE_DEFAULT_HEIGHT	HEIGHT_VGA
+#define MODULE_MAX_WIDTH		WIDTH_UXGA
+#define MODULE_MAX_HEIGHT		HEIGHT_UXGA
+
+#define AHEAD_LINE_NUM			15    //10\D0\D0 = 50\B4\CEѭ\BB\B7
+#define DROP_NUM_CAPTURE		3
+#define DROP_NUM_PREVIEW		5
+
+
+#define  SP2519_720P  //for 720P  20141223 Kavie
+
+static unsigned int frame_rate_vga[]  = {30,};
+static unsigned int frame_rate_svga[]   = {30,};
+static unsigned int frame_rate_uxga[]   = {15,};
+static unsigned int frame_rate_720p[]	= {15,};
+
+
+static const struct regval_list module_init_regs[] =
+{
+	//===========================================================
+	//note:SP2519 MCLK=24MHZ 2.5PLL 8-11.2fps output size:1600*1200
+	//===========================================================
+	{0xfd, 0x01},
+	{0x36, 0x02},
+	{0xfd, 0x00},
+	{0x30, 0x00},//0x0c
+	{0x2f, 0x11},
+	{0x09, 0x01},
+	{0xfd, 0x00},
+	{0x0c, 0x55},
+	{0x27, 0xa5},
+	{0x1a, 0x4b},
+	{0x20, 0x2f},
+	{0x22, 0x5a},
+	{0x25, 0xad},
+	{0x21, 0x0d},
+	{0x28, 0x08},//\C8\F4ϵͳ\C1\D0\D4\EB\C9\F9ƫ\B4󣬿\C9\D2\D4\CAʵ\B1\D4\F6\BC\D30x28 = 0x09~0x0b\A3\AC\B2\BBҪ\B3\AC\B9\FD0x0b
+	{0x1d, 0x01},//\C8\F4\CAֻ\FAƽ̨\D3\D0\D0\D0\D4\EB\C9\F9\A3\AC\D4\F20x1d = 0x00
+	{0x7a, 0x5d},
+	{0x70, 0x41},
+	{0x74, 0x40},
+	{0x75, 0x40},
+	{0x15, 0x3e},
+	{0x71, 0x3f},
+	{0x7c, 0x3f},
+	{0x76, 0x3f},
+	{0x7e, 0x29},
+	{0x72, 0x29},
+	{0x77, 0x28},
+	{0x1e, 0x01},
+	{0x1c, 0x0f},
+	{0x2e, 0xc5},
+	{0x1f, 0xc0},
+	{0x6c, 0x00},
+	{0xfd, 0x01},
+	{0x32, 0x00},
+	{0xfd, 0x02},
+	{0x85, 0x00},
+
+	//24M 50HZ 2.5PLL 8-11.2fps uxga
+	{0xfd, 0x00},
+	{0x03, 0x03},
+	{0x04, 0x42},
+	{0x05, 0x00},
+	{0x06, 0x00},
+	{0x07, 0x00},
+	{0x08, 0x00},
+	{0x09, 0x00},
+	{0x0a, 0x9d},
+	{0xfd, 0x01},
+	{0xf0, 0x00},
+	{0xf7, 0x8b},
+	{0xf8, 0x74},
+	{0x02, 0x0c},
+	{0x03, 0x01},
+	{0x06, 0x8b},
+	{0x07, 0x00},
+	{0x08, 0x01},
+	{0x09, 0x00},
+	{0xfd, 0x02},
+	{0x3d, 0x0f},
+	{0x3e, 0x74},
+	{0x3f, 0x00},
+	{0x88, 0xae},
+	{0x89, 0x69},
+	{0x8a, 0x43},
+	{0xfd, 0x02},
+	{0xbe, 0x84},
+	{0xbf, 0x06},
+	{0xd0, 0x84},
+	{0xd1, 0x06},
+	{0xc9, 0x84},
+	{0xca, 0x06},                                                                                             
+
+	{0xb8, 0x70}, //mean_nr_dummy    
+	{0xb9, 0x80},  //mean_dummy_nr    
+	{0xba, 0x30},  //mean_dummy_low   
+	{0xbb, 0x45},  //mean_low_dummy   
+	{0xbc, 0x90},  //rpc_heq_low      
+	{0xbd, 0x70},  //rpc_heq_dummy    
+	{0xfd, 0x03},                    
+	{0x77, 0x48},  //rpc_heq_nr2      
+
+	{0xfd, 0x01},
+	{0xe0, 0x48},
+	{0xe1, 0x38},
+	{0xe2, 0x30},
+	{0xe3, 0x2c},
+	{0xe4, 0x2c},
+	{0xe5, 0x2a},
+	{0xe6, 0x2a},
+	{0xe7, 0x28},
+	{0xe8, 0x28},
+	{0xe9, 0x28},
+	{0xea, 0x26},
+	{0xf3, 0x26},
+	{0xf4, 0x26},
+	{0xfd, 0x01},  //ae min gain    
+	{0x04, 0xc0},  //rpc_max_indr   
+	{0x05, 0x26},  //rpc_min_indr   
+	{0x0a, 0x48},  //rpc_max_outdr  
+	{0x0b, 0x26},  //rpc_min_outdr  
+
+	{0xfd, 0x01},   //ae target                     
+	{0xf2, 0x09},                
+	{0xeb, 0x78},   //target_indr	
+	{0xec, 0x78},   //target_outdr	
+	{0xed, 0x06},   //lock_range    
+	{0xee, 0x0a},   //hold_range    
+
+	{0xfd, 0x02},      
+	{0x4f, 0x46},    //dem_morie_thr              
+	         
+	{0xfd, 0x03},
+	{0x52, 0xff}, //dpix_wht_ofst_outdoor        
+	{0x53, 0x60}, //dpix_wht_ofst_normal1        
+	{0x94, 0x00},//20 //dpix_wht_ofst_normal2        
+	{0x54, 0x00}, //dpix_wht_ofst_dummy          
+	{0x55, 0x00}, //dpix_wht_ofst_low            
+	           
+	{0x56, 0x80}, //dpix_blk_ofst_outdoor        
+	{0x57, 0x80}, //dpix_blk_ofst_normal1        
+	{0x95, 0x00},//80 //dpix_blk_ofst_normal2        
+	{0x58, 0x00}, //dpix_blk_ofst_dummy          
+	{0x59, 0x00}, //dpix_blk_ofst_low            
+	           
+	{0x5a, 0xf6}, //dpix_wht_ratio               
+	{0x5b, 0x00},                               
+	{0x5c, 0x88}, //dpix_blk_ratio               
+	{0x5d, 0x00},                               
+	{0x96, 0x00},//68 //dpix_wht/blk_ratio_nr2       
+
+	{0xfd, 0x03},
+	{0x8a, 0x00},
+	{0x8b, 0x00},
+	{0x8c, 0xff},
+
+	{0x22, 0xff}, //dem_gdif_thr_outdoor    
+	{0x23, 0xff}, //dem_gdif_thr_normal     
+	{0x24, 0xff}, //dem_gdif_thr_dummy      
+	{0x25, 0xff}, //dem_gdif_thr_low        
+	     
+	{0x5e, 0xff}, //dem_gwnd_wht_outdoor    
+	{0x5f, 0xff}, //dem_gwnd_wht_normal     
+	{0x60, 0xff}, //dem_gwnd_wht_dummy      
+	{0x61, 0xff}, //dem_gwnd_wht_low        
+	{0x62, 0x00}, //dem_gwnd_blk_outdoor    
+	{0x63, 0x00}, //dem_gwnd_blk_normal     
+	{0x64, 0x00}, //dem_gwnd_blk_dummy      
+	{0x65, 0x00}, //dem_gwnd_blk_low        
+
+	{0xfd, 0x01},
+	{0x21, 0x00},  //lsc_sig_ru lsc_sig_lu             
+	{0x22, 0x00},  //lsc_sig_rd lsc_sig_ld             
+	{0x26, 0x60},  //lsc_gain_thr                      
+	{0x27, 0x14},  //lsc_exp_thrl                      
+	{0x28, 0x05},  //lsc_exp_thrh                      
+	{0x29, 0x00},  //lsc_dec_fac     \BD\F8dummy̬\CD\CBshading \B9\A6\C4\DC\D3\D0\CE\CA\CC⣬\D0\E8\B9ص\F4                  
+	{0x2a, 0x01},  //lsc_rpc_en lens ˥\BC\F5\D7\D4\CA\CAӦ        
+	                                            
+	{0xfd, 0x01},                                     
+	{0xa1, 0x1D},  //lsc_rsx_l                                       
+	{0xa2, 0x20},  //lsc_rsx_r                         
+	{0xa3, 0x20},  //lsc_rsy_u                         
+	{0xa4, 0x1D},  //lsc_rsy_d                         
+	{0xa5, 0x1D},  //lsc_gxy_l                         
+	{0xa6, 0x1D},  //lsc_gxy_r                         
+	{0xa7, 0x22},  //lsc_gxy_l                         
+	{0xa8, 0x1b},  //lsc_gxy_r                         
+	{0xa9, 0x1c},  //lsc_bsx_l                         
+	{0xaa, 0x1e},  //lsc_bsx_r                         
+	{0xab, 0x1e},  //lsc_bsy_u                         
+	{0xac, 0x1c},  //lsc_bsy_d                         
+	{0xad, 0x0a},  //lsc_rxy_lu                        
+	{0xae, 0x09},  //lsc_rxy_ru                        
+	{0xaf, 0x05},  //lsc_rxy_ld                        
+	{0xb0, 0x05},  //lsc_rxy_rd                        
+	{0xb1, 0x0A},  //lsc_gsx_lu                        
+	{0xb2, 0x0a},  //lsc_gsx_ru                        
+	{0xb3, 0x05},  //lsc_gsy_ud                        
+	{0xb4, 0x07},  //lsc_gsy_dd                        
+	{0xb5, 0x0A},  //lsc_bxy_lu                        
+	{0xb6, 0x0a},  //lsc_bxy_ru                        
+	{0xb7, 0x04},  //lsc_bxy_ld                        
+	{0xb8, 0x07},  //lsc_bxy_rd                         
+	                           
+	{0xfd, 0x02},
+	{0x26, 0xa0},  //Red channel gain                                 
+	{0x27, 0x96},  //Blue channel gain                                
+	{0x28, 0xcc},  //Y top value limit                                
+	{0x29, 0x01},  //Y bot value limit                                
+	{0x2a, 0x00},  //rg_limit_log                                     
+	{0x2b, 0x00},  //bg_limit_log                                     
+	{0x2c, 0x20},  //Awb image center row start                       
+	{0x2d, 0xdc},  //Awb image center row end                         
+	{0x2e, 0x20},  //Awb image center col start                       
+	{0x2f, 0x96},  //Awb image center col end                         
+	{0x1b, 0x80},  //b,g mult a constant for detect white pixel       
+	{0x1a, 0x80},  //r,g mult a constant for detect white pixel       
+	{0x18, 0x16},  //wb_fine_gain_step,wb_rough_gain_step             
+	{0x19, 0x26},  //wb_dif_fine_th, wb_dif_rough_th                  
+	{0x1d, 0x04},  //skin detect u bot                                 
+	{0x1f, 0x06},  //skin detect v bot                                
+
+{0x66, 0x36},
+{0x67, 0x5c},
+{0x68, 0xbb},
+{0x69, 0xdf},
+{0x6a, 0xa5},
+
+{0x7c, 0x26},
+{0x7d, 0x4A},
+{0x7e, 0xe0},
+{0x7f, 0x05},
+{0x80, 0xa6},
+
+{0x70, 0x21},
+{0x71, 0x41},
+{0x72, 0x05},
+{0x73, 0x25},
+{0x74, 0xaa},
+
+{0x6b, 0x00},
+{0x6c, 0x20},
+{0x6d, 0x0e},
+{0x6e, 0x2a},
+{0x6f, 0xaa},
+
+{0x61, 0xdb},
+{0x62, 0xfe},
+{0x63, 0x37},
+{0x64, 0x56},
+{0x65, 0x5a},
+
+{0x75, 0x00},
+{0x76, 0x09},
+{0x77, 0x02},
+{0x0e, 0x16},
+{0x3b, 0x09},
+
+{0xfd, 0x02}, //awb outdoor mode               
+{0x02, 0x00}, //outdoor exp 5msb   
+{0x03, 0x10}, //outdoor exp 8lsb   
+{0x04, 0xf0}, //outdoor rpc        
+{0xf5, 0xb3}, //outdoor rgain top  
+{0xf6, 0x80}, //outdoor rgain bot  
+{0xf7, 0xe0}, //outdoor bgain top  
+{0xf8, 0x89}, //outdoor bgain bot  
+           
+{0xfd, 0x02},
+{0x08, 0x00},
+{0x09, 0x04},
+
+{0xfd, 0x02},
+{0xdd, 0x0f}, //raw smooth en 
+{0xde, 0x0f}, //sharpen en    
+
+{0xfd, 0x02}, // sharp               
+{0x57, 0x30}, //raw_sharp_y_base     
+{0x58, 0x10}, //raw_sharp_y_min      
+{0x59, 0xe0}, //raw_sharp_y_max      
+{0x5a, 0x00}, //raw_sharp_rangek_neg 
+{0x5b, 0x12}, //raw_sharp_rangek_pos 
+
+{0xcb, 0x08}, //raw_sharp_range_base_outdoor	
+{0xcc, 0x0b}, //raw_sharp_range_base_nr 	
+{0xcd, 0x10}, //raw_sharp_range_base_dummy	
+{0xce, 0x1a}, //raw_sharp_range_base_low	
+
+{0xfd, 0x03},
+{0x87, 0x04}, //raw_sharp_range_ofst1	4x  
+{0x88, 0x08}, //raw_sharp_range_ofst2	8x  
+{0x89, 0x10}, //raw_sharp_range_ofst3	16x 
+
+{0xfd, 0x02}, 
+{0xe8, 0x58}, //sharpness gain for increasing pixel\A1\AFs Y, in outdoor        
+{0xec, 0x68}, //sharpness gain for decreasing pixel\A1\AFs Y, in outdoor        
+{0xe9, 0x60}, //sharpness gain for increasing pixel\A1\AFs Y, in normal         
+{0xed, 0x68}, //sharpness gain for decreasing pixel\A1\AFs Y, in normal         
+{0xea, 0x58}, //sharpness gain for increasing pixel\A1\AFs Y,in dummy           
+{0xee, 0x60}, //sharpness gain for decreasing pixel\A1\AFs Y, in dummy          
+{0xeb, 0x48}, //sharpness gain for increasing pixel\A1\AFs Y,in lowlight        
+{0xef, 0x40}, //sharpness gain for decreasing pixel\A1\AFs Y, in low light      
+
+{0xfd, 0x02}, //skin sharpen                                   
+{0xdc, 0x04}, //skin_sharp_sel\B7\F4ɫ\BD\B5\C8\F1\BB\AF                       
+{0x05, 0x6f}, //skin_num_th2\C5ų\FD\B7\F4ɫ\BD\B5\C8񻯶Էֱ\E6\C2ʿ\A8\D2\FD\C6\F0\B5ĸ\C9\C8\C5 
+
+{0xfd, 0x02},
+{0xf4, 0x30},  //raw_ymin           
+{0xfd, 0x03},                      
+{0x97, 0x98},  //raw_ymax_outdoor   
+{0x98, 0x88},  //raw_ymax_normal    
+{0x99, 0x88},  //raw_ymax_dummy     
+{0x9a, 0x80},  //raw_ymax_low       
+{0xfd, 0x02},                      
+{0xe4, 0xff},  //raw_yk_fac_outdoor 
+{0xe5, 0xff},  //raw_yk_fac_normal  
+{0xe6, 0xff},  //raw_yk_fac_dummy   
+{0xe7, 0xff},  //raw_yk_fac_low     
+
+{0xfd, 0x03},
+{0x72, 0x18},  //raw_lsc_fac_outdoor 
+{0x73, 0x28},  //raw_lsc_fac_normal  
+{0x74, 0x28},  //raw_lsc_fac_dummy   
+{0x75, 0x30},  //raw_lsc_fac_low     
+
+{0xfd, 0x02},
+{0x78, 0x20},
+{0x79, 0x20},
+{0x7a, 0x14},
+{0x7b, 0x08},
+
+{0x81, 0x02},//raw_grgb_thr_outdoor  
+{0x82, 0x20},
+{0x83, 0x20},
+{0x84, 0x08},
+
+{0xfd, 0x03},
+{0x7e, 0x06}, //raw_noise_base_outdoor                   
+{0x7f, 0x0d}, //raw_noise_base_normal                    
+{0x80, 0x10}, //raw_noise_base_dummy                     
+{0x81, 0x16}, //raw_noise_base_low                       
+{0x7c, 0xff}, //raw_noise_base_dark                      
+{0x82, 0x54}, //raw_dns_fac_outdoor,raw_dns_fac_normal} 
+{0x83, 0x43}, //raw_dns_fac_dummy,raw_dns_fac_low}         
+{0x84, 0x00},  //raw_noise_ofst1 	4x                   
+{0x85, 0x20},  //raw_noise_ofst2	8x                   
+{0x86, 0x40}, //raw_noise_ofst3	16x    
+
+{0xfd, 0x03},
+{0x66, 0x18}, //pf_bg_thr_normal b-g>thr      
+{0x67, 0x28}, //pf_rg_thr_normal r-g<thr      
+{0x68, 0x20}, //pf_delta_thr_normal |val|>thr 
+{0x69, 0x88}, //pf_k_fac val/16               
+{0x9b, 0x18}, //pf_bg_thr_outdoor             
+{0x9c, 0x28}, //pf_rg_thr_outdoor             
+{0x9d, 0x20}, //pf_delta_thr_outdoor          
+
+{0xfd, 0x01},
+{0x8b, 0x00},
+{0x8c, 0x0f},
+{0x8d, 0x21},
+{0x8e, 0x2c},
+{0x8f, 0x37},
+{0x90, 0x46},
+{0x91, 0x53},
+{0x92, 0x5e},
+{0x93, 0x6a},
+{0x94, 0x7d},
+{0x95, 0x8d},
+{0x96, 0x9e},
+{0x97, 0xac},
+{0x98, 0xba},
+{0x99, 0xc6},
+{0x9a, 0xd1},
+{0x9b, 0xda},
+{0x9c, 0xe4},
+{0x9d, 0xeb},
+{0x9e, 0xf2},
+{0x9f, 0xf9},
+{0xa0, 0xff}, 
+
+{0xfd, 0x02}, 
+{0x15, 0xa9}, 
+{0x16, 0x84}, 
+
+{0xa0, 0x97},
+{0xa1, 0xea},
+{0xa2, 0xff},
+{0xa3, 0x0e},
+{0xa4, 0x77},
+{0xa5, 0xfa},
+{0xa6, 0x08},
+{0xa7, 0xcb},
+{0xa8, 0xad},
+{0xa9, 0x3c},
+{0xaa, 0x30},
+{0xab, 0x0c}, 
+     
+{0xac, 0x7f},
+{0xad, 0x08},
+{0xae, 0xf8},
+{0xaf, 0xff},
+{0xb0, 0x6e},
+{0xb1, 0x13},
+{0xb2, 0xd2},
+{0xb3, 0x6e},
+{0xb4, 0x40},
+{0xb5, 0x30},
+{0xb6, 0x03},
+{0xb7, 0x1f},
+
+{0xfd, 0x01},  //auto_sat                 
+{0xd2, 0x2d},  //autosat_en[0]             
+{0xd1, 0x38},  //lum thr in green enhance 
+{0xdd, 0x3f}, 
+{0xde, 0x37}, 
+
+{0xfd, 0x02},
+{0xc1, 0x40},
+{0xc2, 0x40},
+{0xc3, 0x40},
+{0xc4, 0x40},
+{0xc5, 0x80},
+{0xc6, 0x60},
+{0xc7, 0x00},
+{0xc8, 0x00},
+
+
+	{0xfd, 0x01},
+	{0xd3, 0xa0},
+	{0xd4, 0x9c},
+	{0xd5, 0x94},
+	{0xd6, 0x88},
+
+	{0xd7, 0xa0},
+	{0xd8, 0x9c},
+	{0xd9, 0x94},
+	{0xda, 0x88},
+
+{0xfd, 0x03},
+{0x76, 0x0a},
+{0x7a, 0x40},
+{0x7b, 0x40},
+
+{0xfd, 0x01},
+{0xc2, 0xaa},  //u_v_th_outdoor\B0\D7ɫ\CE\EF\CC\E5\B1\ED\C3\E6\D3в\CAɫ\D4\EB\C9\F9\BD\B5\B5ʹ\CBֵ    
+{0xc3, 0xaa},  //u_v_th_nr                                       
+{0xc4, 0x66},  //u_v_th_dummy                                    
+{0xc5, 0x66},  //u_v_th_low          
+
+{0xfd, 0x01},
+{0xcd, 0x08},
+{0xce, 0x18},
+
+{0xfd, 0x02},
+{0x32, 0x60},
+{0x35, 0x60}, //uv_fix_dat 
+{0x37, 0x13},
+
+{0xfd, 0x01}, 
+{0xdb, 0x00}, //buf_heq_offset    
+{0x10, 0x88}, //ku_outdoor       
+{0x11, 0x88}, //ku_nr            
+{0x12, 0x90}, //ku_dummy         
+{0x13, 0x90}, //ku_low           
+{0x14, 0x9a}, //kl_outdoor       
+{0x15, 0x9a}, //kl_nr            
+{0x16, 0x8b}, //kl_dummy         
+{0x17, 0x88}, //kl_low           
+
+{0xfd, 0x03},
+{0x00, 0x80}, //ctf_heq_mean	                          
+{0x03, 0x68}, //ctf_range_thr   \BF\C9\D2\D4\C5ų\FD\BBҰ峡\BE\B0\B5\C4\E3\D0ֵ   
+{0x06, 0xd8}, //ctf_reg_max	                          
+{0x07, 0x28}, //ctf_reg_min	                          
+{0x0a, 0xfd}, //ctf_lum_ofst                             
+{0x01, 0x16}, //ctf_posk_fac_outdoor                     
+{0x02, 0x16}, //ctf_posk_fac_nr                          
+{0x04, 0x16}, //ctf_posk_fac_dummy                       
+{0x05, 0x16}, //ctf_posk_fac_low                         
+{0x0c, 0x40}, //ctf_negk_fac_nr                          
+{0x0b, 0x40}, //ctf_negk_fac_outdoor                     
+{0x0d, 0x40}, //ctf_negk_fac_dummy                       
+{0x0e, 0x40}, //ctf_negk_fac_low                         
+{0x08, 0x0c}, 
+{0x09, 0x0c}, 
+ 
+{0xfd, 0x02}, //cnr                   
+{0x8e, 0x0a}, //cnr_grad_thr_dummy    
+{0x90, 0x40}, //20 //cnr_thr_outdoor   
+{0x91, 0x40}, //20 //cnr_thr_nr        
+{0x92, 0x60}, //60 //cnr_thr_dummy     
+{0x93, 0x80}, //80 //cnr_thr_low       
+{0x9e, 0x44}, 
+{0x9f, 0x44}, 
+
+{0xfd, 0x02}, //auto                                                
+{0x85, 0x00}, //enable 50Hz/60Hz function[4]  [3:0] interval_line   
+{0xfd, 0x01}, 
+{0x00, 0x00}, //fix mode 
+{0xfb, 0x25}, 
+{0x32, 0x15}, //ae en 
+{0x33, 0xef}, //lsc\bpc en
+{0x34, 0xef},  //ynr[4]\cnr[0]\gamma[2]\colo[1]  
+{0x35, 0x00},  //YUYV                            
+{0xfd, 0x00},        
+{0x3f, 0x00}, //mirror/flip    
+{0xfd, 0x01}, 
+{0x50, 0x00}, //heq_auto_mode \B6\C1״̬ 
+{0x66, 0x00}, //effect               
+{0xfd, 0x02}, 
+{0xd6, 0x0f}, 
+
+{0xfd, 0x00}, 
+{0x1b, 0x30}, 
+{0xfd, 0x01}, 
+{0x36, 0x00}, 
+
+	{0xfd, 0x02},
+	{0x0f, 0x00},
+	{0x8f, 0x03},
+	{0xfd, 0x00}, 
+	ENDMARKER,
+};
+/* 640*480: QVGA */
+static const struct regval_list module_vga_regs[] = 
+{
+	{0xfd, 0x02},
+	{0x40, 0x00},
+	{0x41, 0x50},
+	{0x42, 0x00},
+	{0x43, 0x50},
+	{0x44, 0x01},
+	{0x45, 0xe0},
+	{0x46, 0x02},
+	{0x47, 0x80},
+	{0x0f, 0x01},
+	{0x8f, 0x02},
+    {0xfd, 0x00},
+    ENDMARKER,
+};
+
+/* 800*600: SVGA */
+static const struct regval_list module_svga_regs[] = 
+{
+//window   //for uxga  20141223 Kavie
+	{0xfd, 0x01},
+	{0x4a, 0x00},
+	{0x4b, 0x04},
+	{0x4c, 0xb0},
+	{0x4d, 0x00},
+	{0x4e, 0x06},
+	{0x4f, 0x40},
+//close resize	
+	{0xfd, 0x02},
+	{0x40, 0x00},
+	{0x41, 0x20},
+	{0x42, 0x00},
+	{0x43, 0x20},
+	{0x44, 0x04},
+	{0x45, 0xb0},
+	{0x46, 0x06},
+	{0x47, 0x40},
+	{0x48, 0x00},
+	{0xfd, 0x00},
+	{0xfd, 0x02},
+	{0x0f, 0x00},
+	{0x8f, 0x03},
+	{0xfd, 0x00},	
+		
+	
+	{0xfd, 0x02},
+	{0x40, 0x00},
+	{0x41, 0x40},
+	{0x42, 0x00},
+	{0x43, 0x40},
+	{0x44, 0x02},
+	{0x45, 0x58},
+	{0x46, 0x03},
+	{0x47, 0x20},
+	{0x48, 0x00},
+	{0xfd, 0x00},
+	{0xfd, 0x02},
+	{0x0f, 0x01},
+	{0x8f, 0x02},
+	{0xfd, 0x00},
+    ENDMARKER,
+};
+/* 1280*720: 720P */
+static const struct regval_list module_720p_regs[] = 
+{
+#ifdef SP2519_720P //for 720P  20141223 Kavie
+//window  
+	{0xfd, 0x01},
+	{0x4a, 0x96},
+	{0x4b, 0x03},
+	{0x4c, 0x84},
+	{0x4d, 0x00},
+	{0x4e, 0x06},
+	{0x4f, 0x40},
+//resize
+	{0xfd, 0x02},
+	{0x40, 0x00},
+	{0x41, 0x28},
+	{0x42, 0x00},
+	{0x43, 0x28},
+	{0x44, 0x03},
+	{0x45, 0x84},
+	{0x46, 0x06},
+	{0x47, 0x40},
+	{0x48, 0x00},
+	{0xfd, 0x00},
+	{0xfd, 0x02},
+	{0x0f, 0x01},
+	{0x8f, 0x02},
+	{0xfd, 0x00},
+ #endif
+
+    ENDMARKER,
+};
+
+/* 1600*1200: UXGA */
+static const struct regval_list module_uxga_regs[] = 
+{
+//window   //for uxga  20141223 Kavie
+	{0xfd, 0x01},
+	{0x4a, 0x00},
+	{0x4b, 0x04},
+	{0x4c, 0xb0},
+	{0x4d, 0x00},
+	{0x4e, 0x06},
+	{0x4f, 0x40},
+//close resize	
+	{0xfd, 0x02},
+	{0x40, 0x00},
+	{0x41, 0x20},
+	{0x42, 0x00},
+	{0x43, 0x20},
+	{0x44, 0x04},
+	{0x45, 0xb0},
+	{0x46, 0x06},
+	{0x47, 0x40},
+	{0x48, 0x00},
+	{0xfd, 0x00},
+	{0xfd, 0x02},
+	{0x0f, 0x00},
+	{0x8f, 0x03},
+	{0xfd, 0x00},	
+    ENDMARKER,
+};
+static const struct regval_list module_init_auto_focus[] =
+{
+ENDMARKER,
+//  NULL
+};
+    
+/*
+ * window size list
+ */
+/* 640*480 */
+static struct camera_module_win_size module_win_vga = {
+	.name             = "VGA",
+	.width            = WIDTH_VGA,
+	.height           = HEIGHT_VGA,
+	.win_regs         = module_vga_regs,
+	.frame_rate_array = frame_rate_vga,
+	.capture_only     = 0,
+};
+
+/* 800*600 */
+static struct camera_module_win_size module_win_svga = {
+	.name             = "SVGA",
+	.width            = WIDTH_SVGA,
+	.height           = HEIGHT_SVGA,
+	.win_regs         = module_svga_regs,
+
+	.frame_rate_array = frame_rate_svga,
+	.capture_only     = 0,
+};
+/* 1280*720 */
+static struct camera_module_win_size module_win_720p = {
+	.name             = "720P",
+	.width            = WIDTH_720P,
+	.height           = HEIGHT_720P,
+	.win_regs         = module_720p_regs,
+
+	.frame_rate_array = frame_rate_720p,
+	.capture_only     = 0,
+};
+
+/* 1600*1200 */
+static struct camera_module_win_size module_win_uxga = {
+	.name             = "UXGA",
+	.width            = WIDTH_UXGA,
+	.height           = HEIGHT_UXGA,
+	.win_regs         = module_uxga_regs,
+	.frame_rate_array = frame_rate_uxga,
+	.capture_only     = 1,
+};
+
+static struct camera_module_win_size *module_win_list[] = {
+	&module_win_vga,
+	&module_win_svga,
+	&module_win_720p,
+	&module_win_uxga,
+};
+  
+static struct regval_list module_whitebance_auto_regs[]=
+{
+{0xfd , 0x02},
+{0x26 , 0xc1},
+{0x27 , 0x88},	   
+{0xfd , 0x01},
+{0x32 , 0x15},
+
+	ENDMARKER, 
+};
+
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static struct regval_list module_whitebance_cloudy_regs[]=
+{
+{0xfd , 0x01},
+{0x32 , 0x05},
+{0xfd , 0x02},
+{0x26 , 0xe2},
+{0x27 , 0x82},
+{0xfd , 0x00},
+	ENDMARKER,
+};
+
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static struct regval_list module_whitebance_sunny_regs[]=
+{
+{0xfd , 0x01},
+{0x32 , 0x05},
+{0xfd , 0x02},
+{0x26 , 0xc1},
+{0x27 , 0x88},
+{0xfd , 0x00},
+	ENDMARKER, 		
+};
+
+/* Office Colour Temperature : 3500K - 5000K ,ӫ\B9\E2\B5\C6 */
+static struct regval_list module_whitebance_fluorescent_regs[]=
+{
+{0xfd , 0x01},
+{0x32 , 0x05},
+{0xfd , 0x02},
+{0x26 , 0xb4},
+{0x27 , 0xc4},
+{0xfd , 0x00},
+	ENDMARKER,	
+};
+
+/* Home Colour Temperature : 2500K - 3500K \A3\AC\B0׳\E3\B5\C6 */
+static struct regval_list module_whitebance_incandescent_regs[]=
+{
+{0xfd , 0x01},
+{0x32 , 0x05},
+{0xfd , 0x02},
+{0x26 , 0x7b},
+{0x27 , 0xd3},
+{0xfd , 0x00},
+
+	ENDMARKER,
+};
+#if 0
+/*\D5\FD\B3\A3ģʽ*/
+static struct regval_list module_effect_normal_regs[] =
+{
+	{0xfd, 0x01},
+	{0x66, 0x00},
+	{0x67, 0x80},
+	{0x68, 0x80},
+	{0xdb, 0x00},
+	{0x34, 0xc7},
+	{0xfd, 0x02},
+	{0x14, 0x00},
+	{0xfd, 0x00},
+	ENDMARKER,
+};
+
+/*\B5\A5ɫ\A3\AC\BAڰ\D7\D5\D5Ƭ*/
+static struct regval_list module_effect_white_black_regs[] =
+{
+	{0xfd, 0x01},
+	{0x66, 0x20},
+	{0x67, 0x80},
+	{0x68, 0x80},
+	{0xdb, 0x00},
+	{0x34, 0xc7},
+	{0xfd, 0x02},
+	{0x14, 0x00},
+	{0xfd, 0x00},
+	ENDMARKER,
+};
+
+/*\B8\BAƬЧ\B9\FB*/
+static struct regval_list module_effect_negative_regs[] =
+{
+	{0xfd, 0x01},
+	{0x66, 0x08},
+	{0x67, 0x80},
+	{0x68, 0x80},
+	{0xdb, 0x00},
+	{0x34, 0xc7},
+	{0xfd, 0x02},
+	{0x14, 0x00},
+	{0xfd, 0x00},
+	ENDMARKER,
+};
+
+/*\B8\B4\B9\C5Ч\B9\FB*/
+static struct regval_list module_effect_antique_regs[] =
+{    
+	{0xfd, 0x01},
+	{0x66, 0x10},
+	{0x67, 0x98},
+	{0x68, 0x58},
+	{0xdb, 0x00},
+	{0x34, 0xc7},
+	{0xfd, 0x02},
+	{0x14, 0x00},
+	{0xfd, 0x00},
+	ENDMARKER,
+};
+#endif
+static struct regval_list module_scene_auto_regs[] =
+{
+	{0xfd, 0x01},
+	{0xcd, 0x08},
+	{0xce, 0x18},
+	{0xcf, 0x30},
+	{0xd0, 0x45},
+	//24M 50HZ 2.5PLL 8-11.2fps uxga
+	{0xfd, 0x00},
+	{0x03, 0x03},
+	{0x04, 0x42},
+	{0x05, 0x00},
+	{0x06, 0x00},
+	{0x07, 0x00},
+	{0x08, 0x00},
+	{0x09, 0x00},
+	{0x0a, 0x9d},
+	{0xfd, 0x01},
+	{0xf0, 0x00},
+	{0xf7, 0x8b},
+	{0xf8, 0x74},
+	{0x02, 0x0c},
+	{0x03, 0x01},
+	{0x06, 0x8b},
+	{0x07, 0x00},
+	{0x08, 0x01},
+	{0x09, 0x00},
+	{0xfd, 0x02},
+	{0x3d, 0x0f},
+	{0x3e, 0x74},
+	{0x3f, 0x00},
+	{0x88, 0xae},
+	{0x89, 0x69},
+	{0x8a, 0x43},
+	{0xfd, 0x02},
+	{0xbe, 0x84},
+	{0xbf, 0x06},
+	{0xd0, 0x84},
+	{0xd1, 0x06},
+	{0xc9, 0x84},
+	{0xca, 0x06},
+	{0xfd, 0x00},
+	ENDMARKER,
+};
+#if 0
+static struct regval_list module_scene_night_regs[] =
+{
+	{0xfd, 0x01},
+	{0xcd, 0x20},
+	{0xce, 0x1f},
+	{0xcf, 0x40},
+	{0xd0, 0x60},
+//24M 50HZ 2.5PLL 6-10fps uxga
+	{0xfd, 0x00},
+	{0x03, 0x02},
+	{0x04, 0xe8},
+	{0x05, 0x00},
+	{0x06, 0x00},
+	{0x07, 0x00},
+	{0x08, 0x00},
+	{0x09, 0x01},
+	{0x0a, 0x20},
+	{0xfd, 0x01},
+	{0xf0, 0x00},
+	{0xf7, 0x7c},
+	{0xf8, 0x67},
+	{0x02, 0x10},
+	{0x03, 0x01},
+	{0x06, 0x7c},
+	{0x07, 0x00},
+	{0x08, 0x01},
+	{0x09, 0x00},
+	{0xfd, 0x02},
+	{0x3d, 0x14},
+	{0x3e, 0x67},
+	{0x3f, 0x00},
+	{0x88, 0x21},
+	{0x89, 0xf8},
+	{0x8a, 0x44},
+	{0xfd, 0x02},
+	{0xbe, 0xc0},
+	{0xbf, 0x07},
+	{0xd0, 0xc0},
+	{0xd1, 0x07},
+	{0xc9, 0xc0},
+	{0xca, 0x07},
+	{0xfd, 0x00},
+	ENDMARKER,
+};
+
+static  struct regval_list module_scene_portrait[] =
+{
+//  NULL
+ENDMARKER,
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list module_exp_comp_neg4_regs[] = {
+//  NULL
+	{0xfd,0x01},
+	{0xdb,0xc0},
+	{0xfd,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg3_regs[] = {
+//  NULL
+	{0xfd,0x01},
+	{0xdb,0xd0},
+	{0xfd,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg2_regs[] = {
+//  NULL
+	{0xfd,0x01},
+	{0xdb,0xe0},
+	{0xfd,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_neg1_regs[] = {
+//  NULL
+	{0xfd,0x01},
+	{0xdb,0xf0},
+	{0xfd,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_zero_regs[] = {
+//  NULL
+	{0xfd,0x01},
+	{0xdb,0x00},
+	{0xfd,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos1_regs[] = {
+//  NULL
+	{0xfd,0x01},
+	{0xdb,0x10},
+	{0xfd,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos2_regs[] = {
+//  NULL
+	{0xfd,0x01},
+	{0xdb,0x20},
+	{0xfd,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos3_regs[] = {
+//  NULL
+	{0xfd,0x01},
+	{0xdb,0x30},
+	{0xfd,0x00},
+	ENDMARKER,
+};
+
+static struct regval_list module_exp_comp_pos4_regs[] = {
+//  NULL
+	{0xfd,0x01},
+	{0xdb,0x40},
+	{0xfd,0x00},
+	ENDMARKER,
+};
+#endif
+static struct v4l2_ctl_cmd_info v4l2_ctl_array[] =
+{
+	{	.id   = V4L2_CID_AUTO_WHITE_BALANCE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 1,},
+	{	.id   = V4L2_CID_WHITE_BALANCE_TEMPERATURE, 
+		.min  = 0, 
+		.max  = 3, 
+		.step = 1, 
+		.def  = 1,},
+	{	.id = V4L2_CID_GAIN, 
+		.min = 10, 
+		.max = 2048, 
+		.step = 1, 
+		.def = 30,},
+	{	.id   = V4L2_CID_FLASH_STROBE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_FLASH_STROBE_STOP, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},
+#if 0
+	{	.id   = V4L2_CID_SCENE_EXPOSURE, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = 0,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+	{	.id   = V4L2_CID_PRIVATE_PREV_CAPT, 
+		.min  = 0, 
+		.max  = 1, 
+		.step = 1, 
+		.def  = PREVIEW_MODE,},//3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6
+
+	{	.id   = V4L2_CID_GAIN, 
+		.min  = 0,
+		.max  = 0,
+		.step = 0,
+		.def  = 0,},
+	{   .id   = V4L2_CID_EXPOSURE, 
+		.min  = 0, 
+		.max  = 0,
+		.step = 0, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_EXPOSURE_COMP, 
+		.min  = -4, 
+		.max  = 4, 
+		.step = 1, 
+		.def  = 0,},
+    {	.id   = V4L2_CID_AF_MODE,
+		.min  = NONE_AF, 
+		.max  = CONTINUE_AF|SINGLE_AF, 
+		.step = 1, 
+		.def  = CONTINUE_AF|SINGLE_AF,},
+	{	.id   = V4L2_CID_AF_STATUS, 
+		.min  = AF_STATUS_DISABLE, 
+		.max  = AF_STATUS_FAIL, 
+		.step = 1, 
+		.def  = AF_STATUS_DISABLE,},
+#endif
+		{	.id = V4L2_CID_MIRRORFLIP, //3.4\C4ں\CBû\D3ж\A8\D2\E5\B4\CB\C3\FC\C1\EE\D7\D6,ͬʱд\C8\EBvflip\BA\CDhflip
+		.min = NONE, 
+		.max = HFLIP|VFLIP, 
+		.step = 1, 
+		.def = NONE,},
+};
+
+static struct v4l2_ctl_cmd_info_menu v4l2_ctl_array_menu[] =
+{
+	{	.id   = V4L2_CID_COLORFX, 
+		.max  = 3, 
+		.mask = 0x0, 
+		.def  = 0,},
+	{	.id   = V4L2_CID_EXPOSURE_AUTO, 
+		.max  = 1, 
+		.mask = 0x0, 
+		.def  = 1,},
+	{  
+	   .id = V4L2_CID_SCENE_MODE, 
+	   .max = V4L2_SCENE_MODE_TEXT, 
+	   .mask = 0x0, 
+	   .def = 0,
+	},
+	{ .id = V4L2_CID_POWER_LINE_FREQUENCY, 
+	.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 
+	.mask = 0x0,
+	.def = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,},
+#if 1
+	{	.id   = V4L2_CID_FLASH_LED_MODE, 
+		.max  = 3,
+		.mask = 0x0,
+		.def  = 0,},
+#endif
+};
+
+
+#endif /* __MODULE_DIFF_H__ */
diff --git a/drivers/media/i2c/camera/sp2519/sp2519.c b/drivers/media/i2c/camera/sp2519/sp2519.c
new file mode 100755
index 0000000..4ddcbf8
--- /dev/null
+++ b/drivers/media/i2c/camera/sp2519/sp2519.c
@@ -0,0 +1,672 @@
+/*
+ * gc2145 Camera Driver
+ *
+ * Copyright (C) 2011 Actions Semiconductor Co.,LTD
+ * Wang Xin <wangxin@actions-semi.com>
+ *
+ * Based on ov227x driver
+ *
+ * Copyright (C) 2008 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/platform_device.h>
+#include <mach/isp-owl.h>
+#include "module_diff.h"
+#include "../module_comm/module_comm.c"
+#ifdef  SELf_DETECT
+#include "../module_comm/module_detect.c"
+#endif
+
+static int camera_i2c_read(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int *dest)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+	struct i2c_msg msg;
+	int ret = 0;
+	regs_array[0] = reg & 0xff;
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH;
+	msg.buf   = regs_array;
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret < 0) {
+		printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+		return ret;
+	}
+
+	msg.flags = I2C_M_RD;
+	msg.len   = I2C_DATA_WIDTH;
+	msg.buf   = data_array;	
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret >= 0) {
+        ret = 0;
+		*dest = data_array[0];
+	}
+	else {
+	    printk("read register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	
+	return ret;
+}
+
+static int camera_i2c_write(struct i2c_adapter *i2c_adap, unsigned int reg, unsigned int src)
+{
+	unsigned char regs_array[4] = {0, 0, 0, 0};
+    unsigned char data_array[4] = {0, 0, 0, 0};
+    unsigned char tran_array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	struct i2c_msg msg;
+	unsigned int data = src;
+	int ret,i;
+	
+	
+	regs_array[0] = reg & 0xff;
+	data_array[0] = data & 0xff;
+	for (i = 0; i < I2C_REGS_WIDTH; i++) {
+        tran_array[i] = regs_array[i];
+    }
+
+    for (i = I2C_REGS_WIDTH; i < (I2C_REGS_WIDTH + I2C_DATA_WIDTH); i++) {
+        tran_array[i] = data_array[i - I2C_REGS_WIDTH];
+    }
+	
+	msg.addr = MODULE_I2C_REAL_ADDRESS;
+	msg.flags = 0;
+	msg.len   = I2C_REGS_WIDTH + I2C_DATA_WIDTH;
+	msg.buf   = tran_array;    
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+	    printk("write register %s error %d",CAMERA_MODULE_NAME, ret);
+	}
+	return ret;	
+}
+
+static int camera_write_array(struct i2c_adapter *i2c_adap, const struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff) {
+		int ret = camera_i2c_write(i2c_adap,
+							vals->reg_num,
+							vals->value);
+		if (ret < 0){
+			printk("[camera] i2c write error!,i2c address is %x\n",MODULE_I2C_REAL_ADDRESS);
+			return ret;
+		}
+		vals++;
+	}
+	return 0;
+}
+static int module_soft_reset(struct i2c_client *client)
+{
+
+	/*
+	unsigned int reg_0xfe;
+	struct i2c_adapter *i2c_adap = client->adapter;
+    GC_INFO("");
+    ret = camera_i2c_read(i2c_adap, 0xfe, &reg_0xfe);
+    reg_0xfe |= (0x1 << 7);
+    ret |= camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+    mdelay(1);
+    reg_0xfe &= (~(0x1 << 7));
+    ret |= camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+    */
+    return 0;
+}
+#if 0
+/*
+ *softstandby:ͨ\B9\FD\C5\E4\D6üĴ\E6\C6\F7ʹģ\D7\E9\BD\F8\C8\EB\B5͹\A6\BA\C4ģʽ\A3\AC\B4\CB״̬\CF\C2\CA\E4\B3\F6pin\B8\DF\D7衣\BCĴ\E6\C6\F7ֵ\B1\A3\C1\F4\A3\AC\C7ҼĴ\E6\C6\F7\BF\C9д
+ *ͨ\B9\FD\C0\AD\B8\DFpwdn pin\C0\B4\BD\F8\B5͹\A6\BA\C4ģʽʱ\A3\AC\CA\E4\B3\F6pin\B8\DF\D7裬\BCĴ\E6\C6\F7ֵ\B1\A3\C1\F4\B2\BB\B1䣬\B5\AB\BCĴ\E6\C6\F7\B2\BB\BF\C9д\A1\A3
+ */
+static int module_soft_standby(struct i2c_client *client)
+{
+    unsigned int reg_0xfe = 0x00;
+    unsigned int reg_0xf2 = 0x08;
+    int ret = 0;	
+		/*
+    ret = camera_i2c_write(client, 0xfe, &reg_0xfe);
+    ret |= camera_i2c_write(client, 0xf2, &reg_0xf2);
+		*/
+    return ret;
+}
+
+/*
+ *\B4\D3softstandby״̬\BBָ\B4normal״̬
+ */
+static int module_normal(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0xf2 = 0x70;
+	
+	
+	ret = camera_i2c_write(client, 0xfe, &reg_0xfe);
+	ret |= camera_i2c_write(client, 0xf2, &reg_0xf2);
+	*/
+	return ret;
+}
+#endif
+static int module_start_aec(struct v4l2_subdev *sd)
+{
+  int ret = 0;
+  /*
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct camera_module_priv *priv = to_camera_priv(client);
+  struct i2c_adapter *i2c_adap = client->adapter;
+  
+  unsigned int reg_0xfe = 0x00;
+  unsigned int reg_0xb6 = 0x01;
+
+  ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+  ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+	*/
+  return ret;
+}
+
+static int module_freeze_aec(struct v4l2_subdev *sd)
+{
+ int ret = 0;
+ /*
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct camera_module_priv *priv = to_camera_priv(client);
+  struct i2c_adapter *i2c_adap = client->adapter;
+ 
+  unsigned int reg_0xfe = 0x00;
+  unsigned int reg_0xb6 = 0x00;
+
+  ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+  ret |= camera_i2c_write(i2c_adap, 0xb6, reg_0xb6); 
+ */
+  return ret;
+}
+
+static int module_save_exposure_param(struct v4l2_subdev *sd)
+{
+	int ret = 0;
+	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned int reg_0x03;
+	unsigned int reg_0x04;
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_read(i2c_adap, 0x03, &reg_0x03);
+	ret |= camera_i2c_read(i2c_adap, 0x04, &reg_0x04);
+		
+	priv->preview_exposure_param.shutter = (reg_0x03 << 8) | reg_0x04;
+	priv->capture_exposure_param.shutter = (priv->preview_exposure_param.shutter)/2;
+	*/
+	//printk("GC2155 module_save_exposure_param, win->name:%s\n", priv->win->name);
+	return ret;
+}
+
+static int module_set_exposure_param(struct v4l2_subdev *sd)
+{
+ 	int ret = 0;
+  	/*
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	
+	unsigned int reg_0xfe = 0x00;
+	unsigned char reg_0x03;
+	unsigned char reg_0x04;
+
+	if(priv->capture_exposure_param.shutter < 1) {
+		priv->capture_exposure_param.shutter = 1;
+	}
+
+	reg_0x03 = ((priv->capture_exposure_param.shutter)>>8) & 0x1F ;
+	reg_0x04 = (priv->capture_exposure_param.shutter) & 0xFF;
+
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe); //page 0
+	ret |= camera_i2c_write(i2c_adap, 0x03, reg_0x03);
+	ret |= camera_i2c_write(i2c_adap, 0x04, reg_0x04);
+	*/
+	return ret;
+}
+
+static int module_set_auto_white_balance(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int auto_white_balance;
+	int ret = 0;
+
+	
+	if(ctrl)
+		auto_white_balance = ctrl->val;
+	else
+		auto_white_balance = 1;
+  
+	if (auto_white_balance < 0 || auto_white_balance > 1) {
+		printk("[gc2155] set auto_white_balance over range, auto_white_balance = %d\n", auto_white_balance);
+		return -ERANGE;
+	}
+	
+//	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+//	ret |= camera_i2c_read(i2c_adap, 0x82, &reg_0x82); 
+
+	switch(auto_white_balance)
+	{
+	case 0:
+		ret = 0;
+		goto change_val;
+		
+	case 1:	
+		ret |=camera_write_array(i2c_adap, module_whitebance_auto_regs);
+		break;
+	}
+	
+//	reg_0x82 |= 0x02;
+//	ret |= camera_i2c_write(i2c_adap, 0x82, reg_0x82); 
+ 
+change_val:
+	priv->auto_white_balance = auto_white_balance;
+	if(ctrl)
+		ctrl->cur.val = auto_white_balance;  
+		
+	
+	return ret;
+}
+
+static int module_set_white_balance_temperature(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int white_balance_temperature = ctrl->val;
+	struct i2c_adapter *i2c_adap = client->adapter;
+
+	int ret = 0;
+	
+
+	switch(white_balance_temperature)
+	{
+	case V4L2_WHITE_BALANCE_INCANDESCENT: /* \B0׳\E3\B9\E2 */
+		ret = camera_write_array(i2c_adap, module_whitebance_incandescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_FLUORESCENT: /* ӫ\B9\E2\B5\C6 */
+		ret = camera_write_array(i2c_adap, module_whitebance_fluorescent_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_DAYLIGHT: /* \C8չ\E2 (\C7\E7\CC\EC)*/
+		ret = camera_write_array(i2c_adap, module_whitebance_sunny_regs);
+		break;
+	
+	case V4L2_WHITE_BALANCE_CLOUDY: /* \B6\E0\D4\C6 \A3\A8\D2\F5\CC죩*/
+		ret = camera_write_array(i2c_adap, module_whitebance_cloudy_regs);
+		break;
+	
+	default:
+		printk("[gc2145] set white_balance_temperature over range, white_balance_temperature = %d\n", white_balance_temperature);
+		return -ERANGE;	
+	}
+	
+	priv->auto_white_balance = 0;
+	priv->white_balance_temperature = white_balance_temperature;
+	ctrl->cur.val = white_balance_temperature;
+	
+	return ret;
+}
+#if 0
+static int module_set_colorfx(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+  int colorfx = ctrl->val;
+	int ret = 0;
+
+
+	switch (colorfx) {
+	case V4L2_COLORFX_NONE: /* normal */
+		ret = camera_write_array(i2c_adap, module_effect_normal_regs);
+		break;
+	
+	case V4L2_COLORFX_BW: /* black and white */
+		ret = camera_write_array(i2c_adap, module_effect_white_black_regs);
+		break;
+	
+	case V4L2_COLORFX_SEPIA: /* antique ,\B8\B4\B9\C5*/
+		ret = camera_write_array(i2c_adap, module_effect_antique_regs);
+		break;
+
+	case V4L2_COLORFX_NEGATIVE: /* negative\A3\AC\B8\BAƬ */
+		ret = camera_write_array(i2c_adap, module_effect_negative_regs);
+		break;
+
+    default:
+        printk("[gc2145] set colorfx over range, colorfx = %d\n", colorfx);
+        return -ERANGE;	
+    }
+
+    priv->colorfx = colorfx;
+    ctrl->cur.val = colorfx;
+
+    return 0;
+}
+#endif
+
+static int module_set_exposure_auto(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+    int exposure_auto;
+	int ret = 0;
+
+	if(ctrl)
+		exposure_auto = ctrl->val;
+	else
+		exposure_auto = V4L2_EXPOSURE_AUTO;
+
+	if (exposure_auto < 0 || exposure_auto > 1) {
+		return -ERANGE;
+	}
+  
+	switch (exposure_auto) {
+	case V4L2_EXPOSURE_AUTO:/*  auto */
+        ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+    case V4L2_EXPOSURE_MANUAL: // non auto
+        ret = 0;
+        break;
+    }
+
+	priv->exposure_auto = exposure_auto;
+	if(ctrl)
+		ctrl->cur.val = exposure_auto;
+
+    return 0;
+}
+
+static int module_set_scene_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+#if 0
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+  int scene_exposure = ctrl->val;
+	unsigned int reg_0x3a00;
+	
+	switch(scene_exposure) {
+	case V4L2_SCENE_MODE_HOUSE:  //\CA\D2\C4\DA
+		ret = camera_write_array(i2c_adap, module_scene_night_regs);
+		break;
+	
+	case V4L2_SCENE_MODE_SUNLIGHT:  //\CA\D2\CD\E2
+		ret = camera_write_array(i2c_adap, module_scene_auto_regs);
+		break;
+
+    default:
+        printk("[gc2145] set scene_exposure over range, scene_exposure = %d\n", scene_exposure);
+        return -ERANGE;
+    }
+
+    priv->scene_exposure = scene_exposure;
+    ctrl->cur.val = scene_exposure;
+
+	
+#endif
+	return ret;
+}
+
+
+#if 0
+static int module_set_prev_capt_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct camera_module_priv *priv = to_camera_priv(client);
+    int mode = ctrl->val;
+
+    switch(mode) {
+    case PREVIEW_MODE:
+        priv->prev_capt_mode = mode;
+        break;
+
+    case CAPTURE_MODE:
+        priv->prev_capt_mode = mode;
+        break;
+
+    default:
+        printk("[gc2145] set_prev_capt_mode over range, prev_capt_mode = %d\n", mode);
+        return -ERANGE;
+    }
+    ctrl->cur.val = mode;
+
+    return 0;
+}
+
+
+static int module_pause_af(struct i2c_client *client)
+{
+    int ret = 0;
+
+    return ret;	
+}
+
+static int module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+
+    return 0;
+}
+
+static int module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+    //	struct v4l2_subdev *sd = &priv->subdev;
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+    return 0;
+}
+
+static int module_set_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+    int ret = 0;
+
+    return ret;
+}
+#endif
+static int module_set_stream(struct i2c_client *client,int enable)
+{
+	struct camera_module_priv *priv = to_camera_priv(client);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	int ret = 0;
+	
+	GC_INFO("");
+	if (!enable) {
+		GC_INFO("stream down");
+		camera_i2c_write(i2c_adap, 0xfd, 0x01);
+		camera_i2c_write(i2c_adap, 0x36, 0x02);
+		return ret;
+	}
+	
+	if (NULL == priv->win || NULL == priv->cfmt) {
+		GC_ERR("cfmt or win select error");
+		return (-EPERM);
+	}	
+	GC_INFO("stream on");
+	camera_i2c_write(i2c_adap, 0xfd, 0x01);
+	camera_i2c_write(i2c_adap, 0x36, 0x00);
+//	  
+	 return 0;   
+}
+static int module_get_exposure(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    int ret = 0;
+
+    return ret;
+}
+
+static int module_get_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+    //  unsigned int analog_gain = 0;
+    //	unsigned int digital_gain = 0;
+    unsigned int total_gain = 0;
+    //	int ret = 0;
+
+    return total_gain;
+}
+
+static int module_set_gain(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    //	struct camera_module_priv *priv = to_camera_priv(client);
+
+    return 0;
+}
+
+static int module_set_ev(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+    //	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    int ret = 0;
+
+    return ret;
+}
+static int module_set_mbusformat(struct i2c_client *client, const struct module_color_format *cfmt)
+{
+	int ret = 0;
+
+	
+	/*
+	struct i2c_adapter *i2c_adap = client->adapter;
+	enum v4l2_mbus_pixelcode code;
+	unsigned char reg_0x84;
+	unsigned char reg_0xfe = 0x00;  //pgae0
+	
+	code = cfmt->code;
+
+	switch (code) {
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+		reg_0x84 = 0x02;
+		break;
+				
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		reg_0x84 = 0x00;
+		break;
+		
+	case V4L2_MBUS_FMT_YVYU8_2X8:
+		reg_0x84 = 0x03;
+		break;
+		
+	case V4L2_MBUS_FMT_VYUY8_2X8:
+		reg_0x84 = 0x01;
+		break;
+		
+	default:
+		printk("[gc2155] mbus code error in %s() line %d\n",__FUNCTION__, __LINE__);
+		return -1;
+	}
+	
+	ret = camera_i2c_write(i2c_adap, 0xfe, reg_0xfe);
+	ret |= camera_i2c_write(i2c_adap, 0x84, reg_0x84);
+	*/
+	return ret;
+}
+
+static int  module_s_mirror_flip(struct v4l2_subdev *sd, unsigned int mirror, unsigned int flip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *i2c_adap = client->adapter;
+	struct camera_module_priv *priv = to_camera_priv(client);
+	int ret = 0;
+	unsigned int reg3f;
+	if ((!mirror) && (!flip)) {
+		return 0;
+	}
+	
+
+    GC_INFO("");
+    camera_i2c_write(i2c_adap, 0xfd, 0x01);
+    camera_i2c_read(i2c_adap, 0x3f	, &reg3f);
+    reg3f &= ~MODULE_FLAG_V_H_FLIP;  /* [0]:mirror, [1]: vertical flip */
+
+        if (mirror) {
+            priv->flip_flag |= MODULE_FLAG_HFLIP;
+        } else {
+            priv->flip_flag &= ~MODULE_FLAG_HFLIP;
+        }
+        if (flip) {
+            priv->flip_flag |= MODULE_FLAG_VFLIP;
+        } else {
+            priv->flip_flag &= ~MODULE_FLAG_VFLIP;
+        }
+
+    reg3f |= (priv->flip_flag & MODULE_FLAG_V_H_FLIP);
+	camera_i2c_write(i2c_adap, 0xfd, 0x01);
+    camera_i2c_write(i2c_adap, 0x3f, reg3f);
+    //GC_INFO("flip reg17:0x%x\n", reg17);
+	
+	return ret;
+}
+
+static int module_verify_pid(struct i2c_adapter *i2c_adap,struct camera_module_priv 	*priv)
+{
+	unsigned int pidh = 0;
+    unsigned int pidl = 0;
+    int ret = 0;
+
+	
+	GC_INFO("");
+
+
+	ret = camera_i2c_read(i2c_adap,0x02,&pidh);
+	ret |= camera_i2c_read(i2c_adap,0xa0,&pidl);
+	
+	switch (pidh<<8 | pidl) 
+    {
+	case 0x2519:
+
+		printk("[%s] Product ID verified %x\n",CAMERA_MODULE_NAME,pidl);
+		break;
+	
+	default:
+		printk("[%s] Product ID error %x\n",CAMERA_MODULE_NAME, pidl);
+		return -ENODEV;
+	}
+	return ret;
+}
+static int  module_set_af_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_af_status(struct camera_module_priv *priv, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int  module_set_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+static int  module_get_power_line(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)
+{
+	ctrl->val = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	return 0;
+}
+
diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
old mode 100644
new mode 100755
index 421f531..e1f7492
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -270,3 +270,4 @@ config VIDEO_VIM2M
 	  This is a virtual test device for the memory-to-memory driver
 	  framework.
 endif #V4L_TEST_DRIVERS
+
diff --git a/drivers/media/platform/soc_camera/soc_camera.c b/drivers/media/platform/soc_camera/soc_camera.c
old mode 100644
new mode 100755
index 7bfe7665..0e9c172
--- a/drivers/media/platform/soc_camera/soc_camera.c
+++ b/drivers/media/platform/soc_camera/soc_camera.c
@@ -2084,6 +2084,19 @@ static int soc_camera_device_register(struct soc_camera_device *icd)
 	return 0;
 }
 
+static long soc_camera_vidioc_default(struct file *file, void *fh, bool valid_prio,
+               unsigned int cmd, void *arg)
+{
+	struct soc_camera_device *icd = file->private_data;
+	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+
+	if(sd->ops->core && sd->ops->core->ioctl) {
+		return sd->ops->core->ioctl(sd, cmd, arg);
+	} else {
+		return -ENOTTY;
+	}
+}
+
 static const struct v4l2_ioctl_ops soc_camera_ioctl_ops = {
 	.vidioc_querycap	 = soc_camera_querycap,
 	.vidioc_try_fmt_vid_cap  = soc_camera_try_fmt_vid_cap,
@@ -2112,6 +2125,7 @@ static const struct v4l2_ioctl_ops soc_camera_ioctl_ops = {
 	.vidioc_s_selection	 = soc_camera_s_selection,
 	.vidioc_g_parm		 = soc_camera_g_parm,
 	.vidioc_s_parm		 = soc_camera_s_parm,
+	.vidioc_default      = soc_camera_vidioc_default,
 };
 
 static int video_dev_create(struct soc_camera_device *icd)
@@ -2143,6 +2157,9 @@ static int soc_camera_video_start(struct soc_camera_device *icd)
 {
 	const struct device_type *type = icd->vdev->dev.type;
 	int ret;
+	struct soc_camera_desc *sdesc = to_soc_camera_desc(icd);
+	struct soc_camera_subdev_desc *ssdd = &sdesc->subdev_desc;
+	struct module_info *info = ssdd->drv_priv;
 
 	if (!icd->parent)
 		return -ENODEV;
@@ -2154,7 +2171,7 @@ static int soc_camera_video_start(struct soc_camera_device *icd)
 		v4l2_disable_ioctl(icd->vdev, VIDIOC_S_STD);
 		v4l2_disable_ioctl(icd->vdev, VIDIOC_ENUMSTD);
 	}
-	ret = video_register_device(icd->vdev, VFL_TYPE_GRABBER, -1);
+	ret = video_register_device(icd->vdev, VFL_TYPE_GRABBER,info->video_devnum);
 	if (ret < 0) {
 		dev_err(icd->pdev, "video_register_device failed: %d\n", ret);
 		return ret;
diff --git a/drivers/media/usb/uvc/Makefile b/drivers/media/usb/uvc/Makefile
old mode 100644
new mode 100755
index c26d12f..409f3bf
--- a/drivers/media/usb/uvc/Makefile
+++ b/drivers/media/usb/uvc/Makefile
@@ -1,5 +1,9 @@
+ifneq ($(CONFIG_PLATFORM_UBUNTU),y)
+EXTRA_CFLAGS += -DCONFIG_ASOC_CAMERA=y
+endif
+
 uvcvideo-objs  := uvc_driver.o uvc_queue.o uvc_v4l2.o uvc_video.o uvc_ctrl.o \
-		  uvc_status.o uvc_isight.o uvc_debugfs.o
+		  uvc_status.o uvc_isight.o uvc_debugfs.o uvc_queue_asoc.o
 ifeq ($(CONFIG_MEDIA_CONTROLLER),y)
 uvcvideo-objs  += uvc_entity.o
 endif
diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
old mode 100644
new mode 100755
index 5970dd6..20774f5
--- a/drivers/media/usb/uvc/uvc_driver.c
+++ b/drivers/media/usb/uvc/uvc_driver.c
@@ -1718,7 +1718,7 @@ static void uvc_unregister_video(struct uvc_device *dev)
 
 		video_unregister_device(&stream->vdev);
 
-		uvc_debugfs_cleanup_stream(stream);
+		uvc_debugfs_cleanup_stream(stream);	
 	}
 
 	/* Decrement the stream count and call uvc_delete explicitly if there
@@ -1772,15 +1772,21 @@ static int uvc_register_video(struct uvc_device *dev,
 	video_set_drvdata(vdev, stream);
 
 	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+
 	if (ret < 0) {
 		uvc_printk(KERN_ERR, "Failed to register video device (%d).\n",
 			   ret);
 		return ret;
 	}
 
-	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	/**
+ 	* BUGFIX: Add specific usbcamera dropframes demand support .
+ 	*ActionsCode(author:liyuan, change_code)
+ 	*/
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
 		stream->chain->caps |= V4L2_CAP_VIDEO_CAPTURE;
-	else
+		get_dropframesnum(stream);
+	} else
 		stream->chain->caps |= V4L2_CAP_VIDEO_OUTPUT;
 
 	atomic_inc(&dev->nstreams);
diff --git a/drivers/media/usb/uvc/uvc_queue.c b/drivers/media/usb/uvc/uvc_queue.c
old mode 100644
new mode 100755
index 87a19f3..e8693e5
--- a/drivers/media/usb/uvc/uvc_queue.c
+++ b/drivers/media/usb/uvc/uvc_queue.c
@@ -24,6 +24,12 @@
 
 #include "uvcvideo.h"
 
+#include <linux/cpu.h>
+#include <asm/cacheflush.h>
+
+#ifdef CONFIG_ASOC_CAMERA
+extern struct vb2_mem_ops asoc_vb2_ion_memops;
+#endif
 /* ------------------------------------------------------------------------
  * Video buffers queue management.
  *
@@ -67,6 +73,34 @@ static void uvc_queue_return_buffers(struct uvc_video_queue *queue,
 /* -----------------------------------------------------------------------------
  * videobuf2 queue operations
  */
+#ifdef CONFIG_ASOC_CAMERA
+int uvc_get_buffer_size(struct uvc_streaming *stream, struct uvc_format *format, struct uvc_frame *frame)
+{
+	unsigned int size = stream->ctrl.dwMaxVideoFrameSize;
+
+	if(format && frame)
+	{
+		printk("%s, %d, frame->wWidth=0x%x, frame->wHeight=0x%x, format->bpp=0x%x\n", 
+				__FUNCTION__, __LINE__, frame->wWidth, frame->wHeight, format->bpp);
+		switch(format->fcc)
+		{
+			case V4L2_PIX_FMT_YUYV:
+			case V4L2_PIX_FMT_UYVY:
+			case V4L2_PIX_FMT_NV12:
+			case V4L2_PIX_FMT_YVU420:
+			case V4L2_PIX_FMT_YUV420:
+				size = (frame->wWidth * frame->wHeight * format->bpp)>>3;
+				break;
+			case V4L2_PIX_FMT_MJPEG:
+				size = (frame->wWidth * frame->wHeight * 16)>>3;
+				break;
+			default:
+				break;
+		}
+	}
+	return size;
+}
+#endif
 
 static int uvc_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,
 			   unsigned int *nbuffers, unsigned int *nplanes,
@@ -75,14 +109,24 @@ static int uvc_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,
 	struct uvc_video_queue *queue = vb2_get_drv_priv(vq);
 	struct uvc_streaming *stream = uvc_queue_to_stream(queue);
 
+	
+#ifdef CONFIG_ASOC_CAMERA
+	struct uvc_format *format = stream->cur_format;
+	struct uvc_frame *frame = stream->cur_frame;
+#endif
+
 	/* Make sure the image size is large enough. */
 	if (fmt && fmt->fmt.pix.sizeimage < stream->ctrl.dwMaxVideoFrameSize)
 		return -EINVAL;
 
 	*nplanes = 1;
 
+#ifdef CONFIG_ASOC_CAMERA
+	sizes[0] = uvc_get_buffer_size(stream, format, frame);
+#else
 	sizes[0] = fmt ? fmt->fmt.pix.sizeimage
 		 : stream->ctrl.dwMaxVideoFrameSize;
+#endif
 
 	return 0;
 }
@@ -103,7 +147,21 @@ static int uvc_buffer_prepare(struct vb2_buffer *vb)
 
 	buf->state = UVC_BUF_STATE_QUEUED;
 	buf->error = 0;
+#ifdef CONFIG_ASOC_CAMERA
+#ifdef UVC_DEBUG
+	printk("vb->num_planes : %d ,vb->state : %d,vb->planes[plane_no].mem_priv is 0x%x\n", 
+		vb->num_planes,vb->state,vb->planes[0].mem_priv);
+#endif
+    buf->mem_virt = (void *)vb2_plane_vaddr(vb, 0);
+    buf->mem = buf->mem_virt;
+    buf->mem_phys= vb2_plane_cookie(vb, 0);
+	#ifdef UVC_DEBUG
+	printk("buf->mem : 0x%x ,buf->mem_virt 0x%x,buf->mem_phys : 0x%x\n", 
+		buf->mem,buf->mem_virt,buf->mem_phys);
+	#endif
+#else
 	buf->mem = vb2_plane_vaddr(vb, 0);
+#endif
 	buf->length = vb2_plane_size(vb, 0);
 	if (vb->v4l2_buf.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		buf->bytesused = 0;
@@ -133,6 +191,19 @@ static void uvc_buffer_queue(struct vb2_buffer *vb)
 	spin_unlock_irqrestore(&queue->irqlock, flags);
 }
 
+#ifdef CONFIG_ASOC_CAMERA	
+static void _ion_local_l1_cache_flush_all(void *info)
+{
+    flush_cache_all();
+}
+static void ion_local_l1_cache_flush_all(void)
+{
+    get_online_cpus();
+    on_each_cpu(_ion_local_l1_cache_flush_all, NULL, 1);
+    put_online_cpus();
+}
+#endif
+
 static void uvc_buffer_finish(struct vb2_buffer *vb)
 {
 	struct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);
@@ -141,6 +212,21 @@ static void uvc_buffer_finish(struct vb2_buffer *vb)
 
 	if (vb->state == VB2_BUF_STATE_DONE)
 		uvc_video_clock_update(stream, &vb->v4l2_buf, buf);
+#ifdef CONFIG_ASOC_CAMERA
+    /*
+	* Current uvc use phys_to_virt() for ion buf, which need extra cache flush ops.
+	* ActionsCode(author:liyuan, add_code)
+	*/	
+	{
+	   unsigned int plane;    
+	   /* L1 clean and invalidate all */
+	   ion_local_l1_cache_flush_all();
+	   for (plane = 0; plane < vb->num_planes; ++plane) {
+	       /* L2 clean and invalidate */
+	       outer_flush_range(vb->v4l2_planes[plane].m.userptr, vb->v4l2_planes[plane].m.userptr + PAGE_ALIGN(vb->v4l2_planes[plane].length)); 
+	   }
+	}
+#endif
 }
 
 static int uvc_start_streaming(struct vb2_queue *vq, unsigned int count)
@@ -197,7 +283,11 @@ int uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,
 	queue->queue.drv_priv = queue;
 	queue->queue.buf_struct_size = sizeof(struct uvc_buffer);
 	queue->queue.ops = &uvc_queue_qops;
+#ifdef CONFIG_ASOC_CAMERA
+	queue->queue.mem_ops = &asoc_vb2_ion_memops;
+#else
 	queue->queue.mem_ops = &vb2_vmalloc_memops;
+#endif
 	queue->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC
 		| V4L2_BUF_FLAG_TSTAMP_SRC_SOE;
 	queue->queue.lock = &queue->mutex;
@@ -288,6 +378,7 @@ int uvc_queue_streamon(struct uvc_video_queue *queue, enum v4l2_buf_type type)
 
 	mutex_lock(&queue->mutex);
 	ret = vb2_streamon(&queue->queue, type);
+	queue->framesdropped = 0;
 	mutex_unlock(&queue->mutex);
 
 	return ret;
@@ -296,8 +387,10 @@ int uvc_queue_streamon(struct uvc_video_queue *queue, enum v4l2_buf_type type)
 int uvc_queue_streamoff(struct uvc_video_queue *queue, enum v4l2_buf_type type)
 {
 	int ret;
+	struct uvc_streaming *stream = container_of(queue, struct uvc_streaming, queue);
 
 	mutex_lock(&queue->mutex);
+	uvc_trace(UVC_TRACE_FRAME_ERR, "## framesdropped:%d, totalframes:%d.\n",queue->framesdropped,stream->sequence);
 	ret = vb2_streamoff(&queue->queue, type);
 	mutex_unlock(&queue->mutex);
 
@@ -381,8 +474,15 @@ struct uvc_buffer *uvc_queue_next_buffer(struct uvc_video_queue *queue,
 {
 	struct uvc_buffer *nextbuf;
 	unsigned long flags;
-
-	if ((queue->flags & UVC_QUEUE_DROP_CORRUPTED) && buf->error) {
+	/**
+ 	* BUGFIX: Add specific usbcamera dropframes demand support .
+ 	*ActionsCode(author:liyuan, change_code)
+ 	*/
+	if (((queue->flags & UVC_QUEUE_DROP_CORRUPTED) && buf->error) ||
+	      queue->framestodrop > 0) {
+		if(queue->framestodrop > 0)
+			queue->framestodrop--;
+		queue->framesdropped++;
 		buf->error = 0;
 		buf->state = UVC_BUF_STATE_QUEUED;
 		buf->bytesused = 0;
diff --git a/drivers/media/usb/uvc/uvc_queue_asoc.c b/drivers/media/usb/uvc/uvc_queue_asoc.c
new file mode 100755
index 0000000..5da226e
--- /dev/null
+++ b/drivers/media/usb/uvc/uvc_queue_asoc.c
@@ -0,0 +1,125 @@
+/*	uvc_queue_asoc.c  --  USB Video Class driver - Buffers management
+ *
+ *      Copyright (C) 2005-2010
+ *          Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ *
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ */
+#ifdef CONFIG_ASOC_CAMERA
+
+#include <linux/atomic.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/usb.h>
+#include <linux/videodev2.h>
+#include <linux/vmalloc.h>
+#include <linux/wait.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-memops.h>
+
+
+#include "uvcvideo.h"  
+
+struct asoc_vb2_ion_buf {
+	void				*vaddr;
+	dma_addr_t			dma_addr;
+	unsigned long			size;
+	struct vm_area_struct		*vma;
+	atomic_t			refcount;
+	struct vb2_vmarea_handler	handler;
+};
+
+
+static void *asoc_vb2_ion_get_userptr(void *alloc_ctx, unsigned long paddr,
+					unsigned long size, int write)
+{
+	struct asoc_vb2_ion_buf *buf;
+	int ret = 0;
+	unsigned long pfn;
+	void* vaddr=NULL;
+	buf = kzalloc(sizeof *buf, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	pfn =paddr>>PAGE_SHIFT;
+	if (pfn_valid(pfn)) {
+		vaddr = phys_to_virt(pfn << PAGE_SHIFT);
+	} else {
+		vaddr = ioremap(pfn << PAGE_SHIFT, PAGE_SIZE);
+	}
+	if (!vaddr)
+		ret = -ENOMEM;
+	if (ret) {
+		printk(KERN_ERR "Failed acquiring vaddr 0x%08lx\n",
+				(unsigned long)vaddr);
+		kfree(buf);
+		return ERR_PTR(ret);
+	}
+
+	buf->size = size;
+	buf->vaddr = vaddr;
+	buf->dma_addr = paddr;
+	buf->vma = NULL;
+
+	return buf;
+}
+
+static void asoc_vb2_ion_put_userptr(void *mem_priv)
+{
+	struct asoc_vb2_ion_buf *buf = mem_priv;
+	void* vaddr;
+	unsigned long pfn;
+
+	if (!buf)
+		return;
+	pfn = buf->dma_addr>>PAGE_SHIFT;
+	vaddr = buf->vaddr;
+	if (!pfn_valid(pfn))
+		iounmap(vaddr);
+	kfree(buf);
+}
+
+static void *asoc_vb2_ion_vaddr(void *buf_priv)
+{
+	struct asoc_vb2_ion_buf *buf = buf_priv;
+	if (!buf)
+		return NULL;
+
+	return buf->vaddr;
+}
+
+static void *asoc_vb2_ion_cookie(void *buf_priv)
+{
+	struct asoc_vb2_ion_buf *buf = buf_priv;
+	if (!buf)
+		return NULL;
+
+	return &buf->dma_addr;
+}
+
+static unsigned int asoc_vb2_ion_num_users(void *buf_priv)
+{
+	struct asoc_vb2_ion_buf *buf = buf_priv;
+
+	return atomic_read(&buf->refcount);
+}
+
+
+
+struct vb2_mem_ops asoc_vb2_ion_memops=
+{
+    .cookie		= asoc_vb2_ion_cookie,
+	.vaddr		= asoc_vb2_ion_vaddr,
+	.get_userptr	= asoc_vb2_ion_get_userptr,
+	.put_userptr	= asoc_vb2_ion_put_userptr,
+	.num_users	= asoc_vb2_ion_num_users,
+};
+#endif
+
diff --git a/drivers/media/usb/uvc/uvc_v4l2.c b/drivers/media/usb/uvc/uvc_v4l2.c
old mode 100644
new mode 100755
index c4b1ac6..c9d766c
--- a/drivers/media/usb/uvc/uvc_v4l2.c
+++ b/drivers/media/usb/uvc/uvc_v4l2.c
@@ -142,6 +142,10 @@ static __u32 uvc_try_frame_interval(struct uvc_frame *frame, __u32 interval)
 	return interval;
 }
 
+#ifdef ASOC_CAMERA
+extern int uvc_get_buffer_size(struct uvc_streaming *stream, struct uvc_format *format, struct uvc_frame *frame);
+#endif
+
 static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt, struct uvc_streaming_control *probe,
 	struct uvc_format **uvc_format, struct uvc_frame **uvc_frame)
@@ -246,7 +250,11 @@ static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	fmt->fmt.pix.height = frame->wHeight;
 	fmt->fmt.pix.field = V4L2_FIELD_NONE;
 	fmt->fmt.pix.bytesperline = format->bpp * frame->wWidth / 8;
+#ifdef ASOC_CAMERA
+	fmt->fmt.pix.sizeimage = uvc_get_buffer_size(stream, format, frame);
+#else
 	fmt->fmt.pix.sizeimage = probe->dwMaxVideoFrameSize;
+#endif
 	fmt->fmt.pix.colorspace = format->colorspace;
 	fmt->fmt.pix.priv = 0;
 
@@ -283,7 +291,11 @@ static int uvc_v4l2_get_format(struct uvc_streaming *stream,
 	fmt->fmt.pix.height = frame->wHeight;
 	fmt->fmt.pix.field = V4L2_FIELD_NONE;
 	fmt->fmt.pix.bytesperline = format->bpp * frame->wWidth / 8;
+#ifdef ASOC_CAMERA
+	fmt->fmt.pix.sizeimage = uvc_get_buffer_size(stream, format, frame);
+#else
 	fmt->fmt.pix.sizeimage = stream->ctrl.dwMaxVideoFrameSize;
+#endif
 	fmt->fmt.pix.colorspace = format->colorspace;
 	fmt->fmt.pix.priv = 0;
 
diff --git a/drivers/media/usb/uvc/uvc_video.c b/drivers/media/usb/uvc/uvc_video.c
old mode 100644
new mode 100755
index 20ccc9d..b561a9b
--- a/drivers/media/usb/uvc/uvc_video.c
+++ b/drivers/media/usb/uvc/uvc_video.c
@@ -623,6 +623,17 @@ void uvc_video_clock_update(struct uvc_streaming *stream,
 	first = &clock->samples[clock->head];
 	last = &clock->samples[(clock->head - 1) % clock->size];
 
+	/* ActionsCode(authro:songzhining, comment: Check dev_sof validation) */
+    /* Invalid: The difference between host and device is more than 15ms */
+	y1 = (last->dev_sof + 2048 - first->dev_sof) & 2047;
+	y2 = (last->host_sof + 2048 - first->host_sof) & 2047;
+	if (y2 > (y1 + 15)) {
+	uvc_trace(UVC_TRACE_CLOCK, "%s: invalid sof! diff %u, ts %lu.%06lu\n",
+		stream->dev->name, (y2-y1),
+		v4l2_buf->timestamp.tv_sec, v4l2_buf->timestamp.tv_usec);
+	goto done;
+	}
+
 	/* First step, PTS to SOF conversion. */
 	delta_stc = buf->pts - (1UL << 31);
 	x1 = first->dev_stc - delta_stc;
@@ -996,7 +1007,9 @@ static int uvc_video_decode_start(struct uvc_streaming *stream,
 	if (data[1] & UVC_STREAM_ERR) {
 		uvc_trace(UVC_TRACE_FRAME, "Marking buffer as bad (error bit "
 			  "set).\n");
-		buf->error = 1;
+		/*added for one frame split to two parts, or one frame with err data problems, ActionsCode(author:liyuan, change_code)*/	  
+		buf->error = UVC_BUF_ERR_ISOFRAM_ERR;
+		uvc_trace(UVC_TRACE_FRAME_ERR, "## USB isochronous frame err .\n");
 	}
 
 	/* Synchronize to the input stream by waiting for the FID bit to be
@@ -1050,6 +1063,12 @@ static int uvc_video_decode_start(struct uvc_streaming *stream,
 		uvc_trace(UVC_TRACE_FRAME, "Frame complete (FID bit "
 				"toggled).\n");
 		buf->state = UVC_BUF_STATE_READY;
+		/*added for one frame split to two parts, or one frame with err data problems, ActionsCode(author:liyuan, change_code)*/
+		if((buf->bytesused != buf->length) &&
+		   !(stream->cur_format->flags & UVC_FMT_FLAG_COMPRESSED)){
+			buf->error = UVC_BUF_ERR_NOTFULL;
+			uvc_trace(UVC_TRACE_FRAME_ERR, "## Frame complete (not full).\n");
+		}
 		return -EAGAIN;
 	}
 
@@ -1071,13 +1090,20 @@ static void uvc_video_decode_data(struct uvc_streaming *stream,
 	maxlen = buf->length - buf->bytesused;
 	mem = buf->mem + buf->bytesused;
 	nbytes = min((unsigned int)len, maxlen);
+#ifdef UVC_DEBUG
+	printk("buf->length:%d, buf->bytesused:%d, maxlen:%d,len:%d, nbytes:%d\n", 
+		buf->length, buf->bytesused, maxlen,len, nbytes);
+	printk("mem:0x%x, buf->mem:0x%x, data:0x%x\n",mem, buf->mem, data);
+#endif
 	memcpy(mem, data, nbytes);
 	buf->bytesused += nbytes;
 
 	/* Complete the current frame if the buffer size was exceeded. */
 	if (len > maxlen) {
-		uvc_trace(UVC_TRACE_FRAME, "Frame complete (overflow).\n");
+		uvc_trace(UVC_TRACE_FRAME_ERR, "## Frame complete (overflow).\n");
 		buf->state = UVC_BUF_STATE_READY;
+		/*added for one frame split to two parts, or one frame with err data problems, ActionsCode(author:liyuan, change_code)*/
+		buf->error = UVC_BUF_ERR_OVERFLOW;
 	}
 }
 
@@ -1145,8 +1171,11 @@ static void uvc_video_validate_buffer(const struct uvc_streaming *stream,
 				      struct uvc_buffer *buf)
 {
 	if (stream->ctrl.dwMaxVideoFrameSize != buf->bytesused &&
-	    !(stream->cur_format->flags & UVC_FMT_FLAG_COMPRESSED))
-		buf->error = 1;
+	    !(stream->cur_format->flags & UVC_FMT_FLAG_COMPRESSED)) {
+		/*added for one frame split to two parts, or one frame with err data problems, ActionsCode(author:liyuan, change_code)*/  
+		buf->error = UVC_BUF_ERR_NOTFULL;
+		uvc_trace(UVC_TRACE_FRAME_ERR, "## Frame complete (not full).\n");
+	}
 }
 
 /*
@@ -1163,8 +1192,11 @@ static void uvc_video_decode_isoc(struct urb *urb, struct uvc_streaming *stream,
 			uvc_trace(UVC_TRACE_FRAME, "USB isochronous frame "
 				"lost (%d).\n", urb->iso_frame_desc[i].status);
 			/* Mark the buffer as faulty. */
-			if (buf != NULL)
-				buf->error = 1;
+			if (buf != NULL){
+			        /*added for one frame split to two parts, or one frame with err data problems, ActionsCode(author:liyuan, change_code)*/
+				buf->error = UVC_BUF_ERR_ISOFRAM_LOST;
+				uvc_trace(UVC_TRACE_FRAME_ERR, "## USB isochronous frame lost .\n");
+			}
 			continue;
 		}
 
@@ -1316,6 +1348,9 @@ static void uvc_video_complete(struct urb *urb)
 	struct uvc_buffer *buf = NULL;
 	unsigned long flags;
 	int ret;
+#ifdef CONFIG_ASOC_CAMERA
+	static int is_nodev = 0;
+#endif
 
 	switch (urb->status) {
 	case 0:
@@ -1344,15 +1379,28 @@ static void uvc_video_complete(struct urb *urb)
 	stream->decode(urb, stream, buf);
 
 	if ((ret = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
+#ifdef CONFIG_ASOC_CAMERA
+		if (ret == -ENODEV) {
+			if (is_nodev == 0) {
+				is_nodev = 1;
+				uvc_queue_cancel(queue,1);
+			}
+		}
+#endif
 		uvc_printk(KERN_ERR, "Failed to resubmit video URB (%d).\n",
 			ret);
+#ifdef CONFIG_ASOC_CAMERA
+	} else
+		is_nodev = 0;
+#else 
 	}
+#endif
 }
 
 /*
  * Free transfer buffers.
  */
-static void uvc_free_urb_buffers(struct uvc_streaming *stream)
+void uvc_free_urb_buffers(struct uvc_streaming *stream)
 {
 	unsigned int i;
 
@@ -1362,8 +1410,14 @@ static void uvc_free_urb_buffers(struct uvc_streaming *stream)
 			usb_free_coherent(stream->dev->udev, stream->urb_size,
 				stream->urb_buffer[i], stream->urb_dma[i]);
 #else
+#ifdef CONFIG_ASOC_CAMERA
+			char *urb_buffer = stream->urb_buffer[i];
+			stream->urb_buffer[i] = NULL;
+			kfree(urb_buffer);
+#else
 			kfree(stream->urb_buffer[i]);
 #endif
+#endif
 			stream->urb_buffer[i] = NULL;
 		}
 	}
@@ -1861,8 +1915,13 @@ int uvc_video_enable(struct uvc_streaming *stream, int enable)
 	if (!enable) {
 		uvc_uninit_video(stream, 1);
 		if (stream->intf->num_altsetting > 1) {
+#ifdef CONFIG_ASOC_CAMERA
+			if (!(stream->dev->state & UVC_DEV_DISCONNECTED))
+				usb_set_interface(stream->dev->udev, stream->intfnum, 0);
+#else
 			usb_set_interface(stream->dev->udev,
 					  stream->intfnum, 0);
+#endif
 		} else {
 			/* UVC doesn't specify how to inform a bulk-based device
 			 * when the video stream is stopped. Windows sends a
@@ -1879,6 +1938,7 @@ int uvc_video_enable(struct uvc_streaming *stream, int enable)
 			usb_clear_halt(stream->dev->udev, pipe);
 		}
 
+		(&stream->queue)->framestodrop = 0;
 		uvc_video_clock_cleanup(stream);
 		return 0;
 	}
@@ -1887,6 +1947,7 @@ int uvc_video_enable(struct uvc_streaming *stream, int enable)
 	if (ret < 0)
 		return ret;
 
+	(&stream->queue)->framestodrop = stream->uvc_drop_nframes;
 	/* Commit the streaming parameters. */
 	ret = uvc_commit_video(stream, &stream->ctrl);
 	if (ret < 0)
diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
old mode 100644
new mode 100755
index 1b594c2..15999ed
--- a/drivers/media/usb/uvc/uvcvideo.h
+++ b/drivers/media/usb/uvc/uvcvideo.h
@@ -219,6 +219,16 @@ struct uvc_control {
 	__u8 *uvc_data;
 };
 
+/**
+ * BUGFIX: Add specific usbcamera dropframes demand support .
+ *ActionsCode(author:liyuan, change_code)
+ */
+struct uvc_dropframes {
+	__u16		idVendor;
+	__u16		idProduct;
+	__u16       drop_nframes_needed;
+};
+
 struct uvc_format_desc {
 	char *name;
 	__u8 guid[16];
@@ -352,7 +362,14 @@ enum uvc_buffer_state {
 	UVC_BUF_STATE_DONE	= 4,
 	UVC_BUF_STATE_ERROR	= 5,
 };
-
+/*added for one frame split to two parts, or one frame with err data problems, ActionsCode(author:liyuan, change_code)*/
+enum uvc_buffer_err {
+	UVC_BUF_ERR_NONE	 = 0,
+	UVC_BUF_ERR_ISOFRAM_LOST = 1,
+	UVC_BUF_ERR_ISOFRAM_ERR	 = 2,
+	UVC_BUF_ERR_OVERFLOW	 = 3,
+	UVC_BUF_ERR_NOTFULL	 = 4,
+};
 struct uvc_buffer {
 	struct vb2_buffer buf;
 	struct list_head queue;
@@ -361,6 +378,10 @@ struct uvc_buffer {
 	unsigned int error;
 
 	void *mem;
+#ifdef CONFIG_ASOC_CAMERA
+	void *mem_phys;
+    void *mem_virt;
+#endif
 	unsigned int length;
 	unsigned int bytesused;
 
@@ -376,7 +397,8 @@ struct uvc_video_queue {
 
 	unsigned int flags;
 	unsigned int buf_used;
-
+	unsigned int framesdropped;
+    	int framestodrop;
 	spinlock_t irqlock;			/* Protects irqqueue */
 	struct list_head irqqueue;
 };
@@ -472,6 +494,8 @@ struct uvc_streaming {
 	struct uvc_video_queue queue;
 	void (*decode) (struct urb *urb, struct uvc_streaming *video,
 			struct uvc_buffer *buf);
+	int uvc_drop_nframes;
+
 
 	/* Context data used by the bulk completion handler. */
 	struct {
@@ -589,6 +613,8 @@ struct uvc_driver {
 #define UVC_TRACE_VIDEO		(1 << 10)
 #define UVC_TRACE_STATS		(1 << 11)
 #define UVC_TRACE_CLOCK		(1 << 12)
+/*added for one frame split to two parts, or one frame with err data problems, ActionsCode(author:liyuan, change_code)*/
+#define UVC_TRACE_FRAME_ERR	(1 << 13)
 
 #define UVC_WARN_MINMAX		0
 #define UVC_WARN_PROBE_DEF	1
diff --git a/drivers/media/v4l2-core/v4l2-ctrls.c b/drivers/media/v4l2-core/v4l2-ctrls.c
old mode 100644
new mode 100755
index e3a3468..4ce3bb7
--- a/drivers/media/v4l2-core/v4l2-ctrls.c
+++ b/drivers/media/v4l2-core/v4l2-ctrls.c
@@ -796,6 +796,11 @@ const char *v4l2_ctrl_get_name(u32 id)
 	case V4L2_CID_AUTO_FOCUS_STOP:		return "Auto Focus, Stop";
 	case V4L2_CID_AUTO_FOCUS_STATUS:	return "Auto Focus, Status";
 	case V4L2_CID_AUTO_FOCUS_RANGE:		return "Auto Focus, Range";
+	case V4L2_CID_EXPOSURE_COMP:		return "Exposure Compensation";
+	case V4L2_CID_AF_MODE:		return "auto focus mode";
+	case V4L2_CID_AF_STATUS:		return "focus status";
+	case V4L2_CID_AF_REGION:		return "zone focus region";
+	case V4L2_CID_MIRRORFLIP:		return "set flip and mirror";
 	case V4L2_CID_PAN_SPEED:		return "Pan, Speed";
 	case V4L2_CID_TILT_SPEED:		return "Tilt, Speed";
 
@@ -1597,42 +1602,6 @@ static void cur_to_new(struct v4l2_ctrl *ctrl)
 	ptr_to_ptr(ctrl, ctrl->p_cur, ctrl->p_new);
 }
 
-/* Return non-zero if one or more of the controls in the cluster has a new
-   value that differs from the current value. */
-static int cluster_changed(struct v4l2_ctrl *master)
-{
-	bool changed = false;
-	unsigned idx;
-	int i;
-
-	for (i = 0; i < master->ncontrols; i++) {
-		struct v4l2_ctrl *ctrl = master->cluster[i];
-		bool ctrl_changed = false;
-
-		if (ctrl == NULL)
-			continue;
-
-		if (ctrl->flags & V4L2_CTRL_FLAG_EXECUTE_ON_WRITE)
-			changed = ctrl_changed = true;
-
-		/*
-		 * Set has_changed to false to avoid generating
-		 * the event V4L2_EVENT_CTRL_CH_VALUE
-		 */
-		if (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE) {
-			ctrl->has_changed = false;
-			continue;
-		}
-
-		for (idx = 0; !ctrl_changed && idx < ctrl->elems; idx++)
-			ctrl_changed = !ctrl->type_ops->equal(ctrl, idx,
-				ctrl->p_cur, ctrl->p_new);
-		ctrl->has_changed = ctrl_changed;
-		changed |= ctrl->has_changed;
-	}
-	return changed;
-}
-
 /* Control range checking */
 static int check_range(enum v4l2_ctrl_type type,
 		s64 min, s64 max, u64 step, s64 def)
@@ -2997,7 +2966,9 @@ static int try_or_set_cluster(struct v4l2_fh *fh, struct v4l2_ctrl *master,
 	ret = call_op(master, try_ctrl);
 
 	/* Don't set if there is no change */
-	if (ret || !set || !cluster_changed(master))
+	//if (ret || !set || !cluster_changed(master))
+	/* always set if there is no change */
+	if (ret || !set)
 		return ret;
 	ret = call_op(master, s_ctrl);
 	if (ret)
diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c
old mode 100644
new mode 100755
index 472eaad..c3d2226
--- a/drivers/media/v4l2-core/videobuf2-core.c
+++ b/drivers/media/v4l2-core/videobuf2-core.c
@@ -1333,6 +1333,8 @@ static void __fill_vb2_buffer(struct vb2_buffer *vb, const struct v4l2_buffer *b
 		if (b->memory == V4L2_MEMORY_USERPTR) {
 			v4l2_planes[0].m.userptr = b->m.userptr;
 			v4l2_planes[0].length = b->length;
+			//vb->v4l2_planes[0].m.userptr = b->m.userptr;
+			//vb->v4l2_planes[0].length = b->length;
 		}
 
 		if (b->memory == V4L2_MEMORY_DMABUF) {
diff --git a/drivers/media/v4l2-core/videobuf2-dma-contig.c b/drivers/media/v4l2-core/videobuf2-dma-contig.c
old mode 100644
new mode 100755
index 644dec7..89c91cad
--- a/drivers/media/v4l2-core/videobuf2-dma-contig.c
+++ b/drivers/media/v4l2-core/videobuf2-dma-contig.c
@@ -114,7 +114,12 @@ static unsigned int vb2_dc_num_users(void *buf_priv)
 static void vb2_dc_prepare(void *buf_priv)
 {
 	struct vb2_dc_buf *buf = buf_priv;
-	struct sg_table *sgt = buf->dma_sgt;
+    struct sg_table *sgt;
+    
+    if(!buf) {
+        return;
+    }
+    sgt = buf->dma_sgt;
 
 	/* DMABUF exporter will flush the cache for us */
 	if (!sgt || buf->db_attach)
@@ -126,7 +131,12 @@ static void vb2_dc_prepare(void *buf_priv)
 static void vb2_dc_finish(void *buf_priv)
 {
 	struct vb2_dc_buf *buf = buf_priv;
-	struct sg_table *sgt = buf->dma_sgt;
+    struct sg_table *sgt;
+    
+    if(!buf) {
+        return;
+    }
+	sgt = buf->dma_sgt;
 
 	/* DMABUF exporter will flush the cache for us */
 	if (!sgt || buf->db_attach)
diff --git a/include/media/soc_camera.h b/include/media/soc_camera.h
old mode 100644
new mode 100755
index 2f6261f..862a97e
--- a/include/media/soc_camera.h
+++ b/include/media/soc_camera.h
@@ -22,6 +22,7 @@
 #include <media/v4l2-async.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
+#include <mach/isp-owl.h>
 
 struct file;
 struct soc_camera_desc;
diff --git a/include/uapi/linux/v4l2-controls.h b/include/uapi/linux/v4l2-controls.h
old mode 100644
new mode 100755
index 9f6e108..183a175
--- a/include/uapi/linux/v4l2-controls.h
+++ b/include/uapi/linux/v4l2-controls.h
@@ -94,9 +94,9 @@
 #define V4L2_CID_POWER_LINE_FREQUENCY	(V4L2_CID_BASE+24)
 enum v4l2_power_line_frequency {
 	V4L2_CID_POWER_LINE_FREQUENCY_DISABLED	= 0,
-	V4L2_CID_POWER_LINE_FREQUENCY_50HZ	= 1,
-	V4L2_CID_POWER_LINE_FREQUENCY_60HZ	= 2,
-	V4L2_CID_POWER_LINE_FREQUENCY_AUTO	= 3,
+	V4L2_CID_POWER_LINE_FREQUENCY_AUTO	= 1,
+	V4L2_CID_POWER_LINE_FREQUENCY_50HZ	= 2,
+	V4L2_CID_POWER_LINE_FREQUENCY_60HZ	= 3,
 };
 #define V4L2_CID_HUE_AUTO			(V4L2_CID_BASE+25)
 #define V4L2_CID_WHITE_BALANCE_TEMPERATURE	(V4L2_CID_BASE+26)
@@ -681,16 +681,17 @@ enum  v4l2_exposure_auto_type {
 
 #define V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE	(V4L2_CID_CAMERA_CLASS_BASE+20)
 enum v4l2_auto_n_preset_white_balance {
-	V4L2_WHITE_BALANCE_MANUAL		= 0,
-	V4L2_WHITE_BALANCE_AUTO			= 1,
-	V4L2_WHITE_BALANCE_INCANDESCENT		= 2,
-	V4L2_WHITE_BALANCE_FLUORESCENT		= 3,
-	V4L2_WHITE_BALANCE_FLUORESCENT_H	= 4,
-	V4L2_WHITE_BALANCE_HORIZON		= 5,
-	V4L2_WHITE_BALANCE_DAYLIGHT		= 6,
-	V4L2_WHITE_BALANCE_FLASH		= 7,
-	V4L2_WHITE_BALANCE_CLOUDY		= 8,
-	V4L2_WHITE_BALANCE_SHADE		= 9,
+	V4L2_WHITE_BALANCE_INCANDESCENT 	= 0,
+	V4L2_WHITE_BALANCE_FLUORESCENT,
+	V4L2_WHITE_BALANCE_DAYLIGHT,
+	V4L2_WHITE_BALANCE_CLOUDY,
+	V4L2_WHITE_BALANCE_FLUORESCENT_H,
+	V4L2_WHITE_BALANCE_HORIZON,
+	V4L2_WHITE_BALANCE_SHADE,
+
+	V4L2_WHITE_BALANCE_FLASH,
+	V4L2_WHITE_BALANCE_MANUAL,
+	V4L2_WHITE_BALANCE_AUTO,
 };
 
 #define V4L2_CID_WIDE_DYNAMIC_RANGE		(V4L2_CID_CAMERA_CLASS_BASE+21)
@@ -727,6 +728,7 @@ enum v4l2_scene_mode {
 	V4L2_SCENE_MODE_SPORTS			= 11,
 	V4L2_SCENE_MODE_SUNSET			= 12,
 	V4L2_SCENE_MODE_TEXT			= 13,
+	V4L2_SCENE_MODE_HDR				= 14,
 };
 
 #define V4L2_CID_3A_LOCK			(V4L2_CID_CAMERA_CLASS_BASE+27)
@@ -743,6 +745,31 @@ enum v4l2_scene_mode {
 #define V4L2_AUTO_FOCUS_STATUS_FAILED		(1 << 2)
 
 #define V4L2_CID_AUTO_FOCUS_RANGE		(V4L2_CID_CAMERA_CLASS_BASE+31)
+#define V4L2_CID_EXPOSURE_COMP			(V4L2_CID_CAMERA_CLASS_BASE+35)
+#define V4L2_CID_AF_MODE			(V4L2_CID_CAMERA_CLASS_BASE+36)
+
+enum af_mode{
+	NONE_AF = 0,
+	SINGLE_AF = (0x1<<1),
+	CONTINUE_AF = (0x1<<2),
+	ZONE_AF = (0x1<<3),
+	MACRO_AF = (0x1<<4),
+	MANUAL_AF = (0x1<<5),
+	FACE_AF = (0x1<<6),
+	UNDEFINED_AF = (1<<30),
+};
+
+#define V4L2_CID_AF_STATUS	(V4L2_CID_CAMERA_CLASS_BASE+37)
+
+enum af_status{
+	AF_STATUS_DISABLE = 0,
+	AF_STATUS_UNFINISH,
+	AF_STATUS_OK,
+	AF_STATUS_FAIL,
+};
+
+#define V4L2_CID_AF_REGION	(V4L2_CID_CAMERA_CLASS_BASE+38)
+
 enum v4l2_auto_focus_range {
 	V4L2_AUTO_FOCUS_RANGE_AUTO		= 0,
 	V4L2_AUTO_FOCUS_RANGE_NORMAL		= 1,
@@ -750,6 +777,13 @@ enum v4l2_auto_focus_range {
 	V4L2_AUTO_FOCUS_RANGE_INFINITY		= 3,
 };
 
+#define V4L2_CID_MIRRORFLIP			(V4L2_CID_CAMERA_CLASS_BASE+39)
+enum flip_mode{
+	NONE = 0,
+	HFLIP = (0x1<<1),
+	VFLIP = (0x1<<2),
+};
+
 #define V4L2_CID_PAN_SPEED			(V4L2_CID_CAMERA_CLASS_BASE+32)
 #define V4L2_CID_TILT_SPEED			(V4L2_CID_CAMERA_CLASS_BASE+33)
 
@@ -807,6 +841,7 @@ enum v4l2_flash_led_mode {
 	V4L2_FLASH_LED_MODE_NONE,
 	V4L2_FLASH_LED_MODE_FLASH,
 	V4L2_FLASH_LED_MODE_TORCH,
+	V4L2_FLASH_LED_MODE_AUTO,
 };
 
 #define V4L2_CID_FLASH_STROBE_SOURCE		(V4L2_CID_FLASH_CLASS_BASE + 2)
-- 
1.7.5.4

