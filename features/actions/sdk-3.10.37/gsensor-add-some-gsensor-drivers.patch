From 919b42ca8520eb43752c1c53500a841d7f560fe6 Mon Sep 17 00:00:00 2001
From: wurui <wurui@actions-semi.com>
Date: Mon, 7 Dec 2015 13:31:33 +0800
Subject: [PATCH 23/62] gsensor: add some gsensor drivers

commit 6ac4d14117b2d7b4f485739b200e9fe062f8553d from
https://github.com/xapp-le/kernel.git

Change-Id: I08352ec5ad56894ed97c9fb61a7e2104cee8356a
---
 drivers/input/misc/Kconfig                       |    2 +
 drivers/input/misc/Makefile                      |    1 +
 drivers/input/misc/bma222.c                      | 4077 ++++++++++++++++++++++
 drivers/input/misc/gsensor/Kconfig               |  105 +
 drivers/input/misc/gsensor/Makefile              |   26 +
 drivers/input/misc/gsensor/bma220.c              | 1797 ++++++++++
 drivers/input/misc/gsensor/bma222.c              | 2014 +++++++++++
 drivers/input/misc/gsensor/bma250.c              | 1980 +++++++++++
 drivers/input/misc/gsensor/bma250_dummy.c        |  474 +++
 drivers/input/misc/gsensor/gsensor_detect.c      |  386 ++
 drivers/input/misc/gsensor/gsensor_detect.h      |  189 +
 drivers/input/misc/gsensor/kionix/Makefile       |    6 +
 drivers/input/misc/gsensor/kionix/kionix_accel.c | 2212 ++++++++++++
 drivers/input/misc/gsensor/kionix/kionix_accel.h |   34 +
 drivers/input/misc/gsensor/mc3230.c              | 1730 +++++++++
 drivers/input/misc/gsensor/mc3232.c              | 1900 ++++++++++
 drivers/input/misc/gsensor/mc3236.c              | 1563 +++++++++
 drivers/input/misc/gsensor/mir3da/Makefile       |    8 +
 drivers/input/misc/gsensor/mir3da/mir3da_core.c  | 2121 +++++++++++
 drivers/input/misc/gsensor/mir3da/mir3da_core.h  |  321 ++
 drivers/input/misc/gsensor/mir3da/mir3da_cust.c  | 1114 ++++++
 drivers/input/misc/gsensor/mir3da/mir3da_cust.h  |   41 +
 drivers/input/misc/gsensor/mma7660/Makefile      |    6 +
 drivers/input/misc/gsensor/mma7660/XYZ_Filter.h  |  138 +
 drivers/input/misc/gsensor/mma7660/mma7660.c     | 1010 ++++++
 drivers/input/misc/gsensor/stk8312/Makefile      |    6 +
 drivers/input/misc/gsensor/stk8312/stk8312.h     |   51 +
 drivers/input/misc/gsensor/stk8312/stk831x.c     | 2989 ++++++++++++++++
 drivers/input/misc/gsensor/stk8313/Makefile      |    6 +
 drivers/input/misc/gsensor/stk8313/readme.txt    |    4 +
 drivers/input/misc/gsensor/stk8313/stk8313.h     |   52 +
 drivers/input/misc/gsensor/stk8313/stk831x.c     | 2989 ++++++++++++++++
 32 files changed, 29352 insertions(+), 0 deletions(-)
 mode change 100644 => 100755 drivers/input/evdev.c
 mode change 100644 => 100755 drivers/input/misc/Kconfig
 mode change 100644 => 100755 drivers/input/misc/Makefile
 create mode 100755 drivers/input/misc/bma222.c
 create mode 100755 drivers/input/misc/gsensor/Kconfig
 create mode 100755 drivers/input/misc/gsensor/Makefile
 create mode 100755 drivers/input/misc/gsensor/bma220.c
 create mode 100755 drivers/input/misc/gsensor/bma222.c
 create mode 100755 drivers/input/misc/gsensor/bma250.c
 create mode 100755 drivers/input/misc/gsensor/bma250_dummy.c
 create mode 100755 drivers/input/misc/gsensor/gsensor_detect.c
 create mode 100755 drivers/input/misc/gsensor/gsensor_detect.h
 create mode 100755 drivers/input/misc/gsensor/kionix/Makefile
 create mode 100755 drivers/input/misc/gsensor/kionix/kionix_accel.c
 create mode 100755 drivers/input/misc/gsensor/kionix/kionix_accel.h
 create mode 100755 drivers/input/misc/gsensor/mc3230.c
 create mode 100755 drivers/input/misc/gsensor/mc3232.c
 create mode 100755 drivers/input/misc/gsensor/mc3236.c
 create mode 100755 drivers/input/misc/gsensor/mir3da/Makefile
 create mode 100755 drivers/input/misc/gsensor/mir3da/mir3da_core.c
 create mode 100755 drivers/input/misc/gsensor/mir3da/mir3da_core.h
 create mode 100755 drivers/input/misc/gsensor/mir3da/mir3da_cust.c
 create mode 100755 drivers/input/misc/gsensor/mir3da/mir3da_cust.h
 create mode 100755 drivers/input/misc/gsensor/mma7660/Makefile
 create mode 100755 drivers/input/misc/gsensor/mma7660/XYZ_Filter.h
 create mode 100755 drivers/input/misc/gsensor/mma7660/mma7660.c
 create mode 100755 drivers/input/misc/gsensor/stk8312/Makefile
 create mode 100755 drivers/input/misc/gsensor/stk8312/stk8312.h
 create mode 100755 drivers/input/misc/gsensor/stk8312/stk831x.c
 create mode 100755 drivers/input/misc/gsensor/stk8313/Makefile
 create mode 100755 drivers/input/misc/gsensor/stk8313/readme.txt
 create mode 100755 drivers/input/misc/gsensor/stk8313/stk8313.h
 create mode 100755 drivers/input/misc/gsensor/stk8313/stk831x.c

diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
old mode 100644
new mode 100755
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
old mode 100644
new mode 100755
index 4436ab1..87f5dba
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -785,5 +785,7 @@ config INPUT_DRV2667_HAPTICS
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called drv260x-haptics.
+	  
+source "drivers/input/misc/gsensor/Kconfig"
 
 endif
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
old mode 100644
new mode 100755
index 78ba4c1..db585a1
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -74,3 +74,4 @@ obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_INPUT_IDEAPAD_SLIDEBAR)	+= ideapad_slidebar.o
+obj-$(CONFIG_INPUT_GSENSOR)	+= gsensor/
diff --git a/drivers/input/misc/bma222.c b/drivers/input/misc/bma222.c
new file mode 100755
index 0000000..deffe20
--- /dev/null
+++ b/drivers/input/misc/bma222.c
@@ -0,0 +1,4077 @@
+ï»¿/* Date: 2011/8/31 17:00:00
+ *  Revision: 2.2
+ */
+
+/*
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+
+ * (C) Copyright 2011 Bosch Sensortec GmbH
+ * All Rights Reserved
+ */
+
+
+/* file BMA222.c
+   brief This file contains all function implementations for the BMA222 in linux
+
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include "gsensor_common.h"
+
+#ifdef BMA222_ENABLE_INT1
+#define BMA222_IRQ  OWL_EXT_IRQ_SIRQ1
+#endif
+
+
+
+#define SENSOR_NAME 			"bma222"
+#define ABSMIN				-512
+#define ABSMAX				512
+#define SLOPE_THRESHOLD_VALUE 		32
+#define SLOPE_DURATION_VALUE 		1
+#define INTERRUPT_LATCH_MODE 		13
+#define INTERRUPT_ENABLE 		1
+#define INTERRUPT_DISABLE 		0
+#define MAP_SLOPE_INTERRUPT 		2
+#define SLOPE_X_INDEX 			5
+#define SLOPE_Y_INDEX 			6
+#define SLOPE_Z_INDEX 			7
+#define BMA222_MAX_DELAY		200
+#define BMA222_CHIP_ID			3
+#define BMA222_RANGE_SET		0
+#define BMA222_BW_SET			4
+
+#define LOW_G_INTERRUPT				REL_Z
+#define HIGH_G_INTERRUPT 			REL_HWHEEL
+#define SLOP_INTERRUPT 				REL_DIAL
+#define DOUBLE_TAP_INTERRUPT 			REL_WHEEL
+#define SINGLE_TAP_INTERRUPT 			REL_MISC
+#define ORIENT_INTERRUPT 			ABS_PRESSURE
+#define FLAT_INTERRUPT 				ABS_DISTANCE
+
+
+#define HIGH_G_INTERRUPT_X_HAPPENED			1
+#define HIGH_G_INTERRUPT_Y_HAPPENED 			2
+#define HIGH_G_INTERRUPT_Z_HAPPENED 			3
+#define HIGH_G_INTERRUPT_X_NEGATIVE_HAPPENED 		4
+#define HIGH_G_INTERRUPT_Y_NEGATIVE_HAPPENED		5
+#define HIGH_G_INTERRUPT_Z_NEGATIVE_HAPPENED 		6
+#define SLOPE_INTERRUPT_X_HAPPENED 			7
+#define SLOPE_INTERRUPT_Y_HAPPENED 			8
+#define SLOPE_INTERRUPT_Z_HAPPENED 			9
+#define SLOPE_INTERRUPT_X_NEGATIVE_HAPPENED 		10
+#define SLOPE_INTERRUPT_Y_NEGATIVE_HAPPENED 		11
+#define SLOPE_INTERRUPT_Z_NEGATIVE_HAPPENED 		12
+#define DOUBLE_TAP_INTERRUPT_HAPPENED 			13
+#define SINGLE_TAP_INTERRUPT_HAPPENED 			14
+#define UPWARD_PORTRAIT_UP_INTERRUPT_HAPPENED 		15
+#define UPWARD_PORTRAIT_DOWN_INTERRUPT_HAPPENED	 	16
+#define UPWARD_LANDSCAPE_LEFT_INTERRUPT_HAPPENED 	17
+#define UPWARD_LANDSCAPE_RIGHT_INTERRUPT_HAPPENED	18
+#define DOWNWARD_PORTRAIT_UP_INTERRUPT_HAPPENED 	19
+#define DOWNWARD_PORTRAIT_DOWN_INTERRUPT_HAPPENED 	20
+#define DOWNWARD_LANDSCAPE_LEFT_INTERRUPT_HAPPENED 	21
+#define DOWNWARD_LANDSCAPE_RIGHT_INTERRUPT_HAPPENED 	22
+#define FLAT_INTERRUPT_TURE_HAPPENED			23
+#define FLAT_INTERRUPT_FALSE_HAPPENED			24
+#define LOW_G_INTERRUPT_HAPPENED			25
+
+#define PAD_LOWG					0
+#define PAD_HIGHG					1
+#define PAD_SLOP					2
+#define PAD_DOUBLE_TAP					3
+#define PAD_SINGLE_TAP					4
+#define PAD_ORIENT					5
+#define PAD_FLAT					6
+
+
+#define BMA222_CHIP_ID_REG                      0x00
+#define BMA222_VERSION_REG                      0x01
+#define BMA222_X_AXIS_LSB_REG                   0x02
+#define BMA222_X_AXIS_MSB_REG                   0x03
+#define BMA222_Y_AXIS_LSB_REG                   0x04
+#define BMA222_Y_AXIS_MSB_REG                   0x05
+#define BMA222_Z_AXIS_LSB_REG                   0x06
+#define BMA222_Z_AXIS_MSB_REG                   0x07
+#define BMA222_TEMP_RD_REG                      0x08
+#define BMA222_STATUS1_REG                      0x09
+#define BMA222_STATUS2_REG                      0x0A
+#define BMA222_STATUS_TAP_SLOPE_REG             0x0B
+#define BMA222_STATUS_ORIENT_HIGH_REG           0x0C
+#define BMA222_RANGE_SEL_REG                    0x0F
+#define BMA222_BW_SEL_REG                       0x10
+#define BMA222_MODE_CTRL_REG                    0x11
+#define BMA222_LOW_NOISE_CTRL_REG               0x12
+#define BMA222_DATA_CTRL_REG                    0x13
+#define BMA222_RESET_REG                        0x14
+#define BMA222_INT_ENABLE1_REG                  0x16
+#define BMA222_INT_ENABLE2_REG                  0x17
+#define BMA222_INT1_PAD_SEL_REG                 0x19
+#define BMA222_INT_DATA_SEL_REG                 0x1A
+#define BMA222_INT2_PAD_SEL_REG                 0x1B
+#define BMA222_INT_SRC_REG                      0x1E
+#define BMA222_INT_SET_REG                      0x20
+#define BMA222_INT_CTRL_REG                     0x21
+#define BMA222_LOW_DURN_REG                     0x22
+#define BMA222_LOW_THRES_REG                    0x23
+#define BMA222_LOW_HIGH_HYST_REG                0x24
+#define BMA222_HIGH_DURN_REG                    0x25
+#define BMA222_HIGH_THRES_REG                   0x26
+#define BMA222_SLOPE_DURN_REG                   0x27
+#define BMA222_SLOPE_THRES_REG                  0x28
+#define BMA222_TAP_PARAM_REG                    0x2A
+#define BMA222_TAP_THRES_REG                    0x2B
+#define BMA222_ORIENT_PARAM_REG                 0x2C
+#define BMA222_THETA_BLOCK_REG                  0x2D
+#define BMA222_THETA_FLAT_REG                   0x2E
+#define BMA222_FLAT_HOLD_TIME_REG               0x2F
+#define BMA222_STATUS_LOW_POWER_REG             0x31
+#define BMA222_SELF_TEST_REG                    0x32
+#define BMA222_EEPROM_CTRL_REG                  0x33
+#define BMA222_SERIAL_CTRL_REG                  0x34
+#define BMA222_CTRL_UNLOCK_REG                  0x35
+#define BMA222_OFFSET_CTRL_REG                  0x36
+#define BMA222_OFFSET_PARAMS_REG                0x37
+#define BMA222_OFFSET_FILT_X_REG                0x38
+#define BMA222_OFFSET_FILT_Y_REG                0x39
+#define BMA222_OFFSET_FILT_Z_REG                0x3A
+#define BMA222_OFFSET_UNFILT_X_REG              0x3B
+#define BMA222_OFFSET_UNFILT_Y_REG              0x3C
+#define BMA222_OFFSET_UNFILT_Z_REG              0x3D
+#define BMA222_SPARE_0_REG                      0x3E
+#define BMA222_SPARE_1_REG                      0x3F
+
+#define BMA222_ACC_X8_LSB__POS           0
+#define BMA222_ACC_X8_LSB__LEN           0
+#define BMA222_ACC_X8_LSB__MSK           0x00
+#define BMA222_ACC_X8_LSB__REG           BMA222_X_AXIS_LSB_REG
+
+#define BMA222_ACC_Y8_LSB__POS           0
+#define BMA222_ACC_Y8_LSB__LEN           0
+#define BMA222_ACC_Y8_LSB__MSK           0x00
+#define BMA222_ACC_Y8_LSB__REG           BMA222_Y_AXIS_LSB_REG
+
+#define BMA222_ACC_Z8_LSB__POS           0
+#define BMA222_ACC_Z8_LSB__LEN           0
+#define BMA222_ACC_Z8_LSB__MSK           0x00
+#define BMA222_ACC_Z8_LSB__REG          BMA222_Z_AXIS_LSB_REG
+
+#define BMA222_ACC_X_LSB__POS           6
+#define BMA222_ACC_X_LSB__LEN           2
+#define BMA222_ACC_X_LSB__MSK           0xC0
+#define BMA222_ACC_X_LSB__REG           BMA222_X_AXIS_LSB_REG
+
+#define BMA222_ACC_X_MSB__POS           0
+#define BMA222_ACC_X_MSB__LEN           8
+#define BMA222_ACC_X_MSB__MSK           0xFF
+#define BMA222_ACC_X_MSB__REG           BMA222_X_AXIS_MSB_REG
+
+#define BMA222_ACC_Y_LSB__POS           6
+#define BMA222_ACC_Y_LSB__LEN           2
+#define BMA222_ACC_Y_LSB__MSK           0xC0
+#define BMA222_ACC_Y_LSB__REG           BMA222_Y_AXIS_LSB_REG
+
+#define BMA222_ACC_Y_MSB__POS           0
+#define BMA222_ACC_Y_MSB__LEN           8
+#define BMA222_ACC_Y_MSB__MSK           0xFF
+#define BMA222_ACC_Y_MSB__REG           BMA222_Y_AXIS_MSB_REG
+
+#define BMA222_ACC_Z_LSB__POS           6
+#define BMA222_ACC_Z_LSB__LEN           2
+#define BMA222_ACC_Z_LSB__MSK           0xC0
+#define BMA222_ACC_Z_LSB__REG           BMA222_Z_AXIS_LSB_REG
+
+#define BMA222_ACC_Z_MSB__POS           0
+#define BMA222_ACC_Z_MSB__LEN           8
+#define BMA222_ACC_Z_MSB__MSK           0xFF
+#define BMA222_ACC_Z_MSB__REG           BMA222_Z_AXIS_MSB_REG
+
+#define BMA222_RANGE_SEL__POS             0
+#define BMA222_RANGE_SEL__LEN             4
+#define BMA222_RANGE_SEL__MSK             0x0F
+#define BMA222_RANGE_SEL__REG             BMA222_RANGE_SEL_REG
+
+#define BMA222_BANDWIDTH__POS             0
+#define BMA222_BANDWIDTH__LEN             5
+#define BMA222_BANDWIDTH__MSK             0x1F
+#define BMA222_BANDWIDTH__REG             BMA222_BW_SEL_REG
+
+#define BMA222_EN_LOW_POWER__POS          6
+#define BMA222_EN_LOW_POWER__LEN          1
+#define BMA222_EN_LOW_POWER__MSK          0x40
+#define BMA222_EN_LOW_POWER__REG          BMA222_MODE_CTRL_REG
+
+#define BMA222_EN_SUSPEND__POS            7
+#define BMA222_EN_SUSPEND__LEN            1
+#define BMA222_EN_SUSPEND__MSK            0x80
+#define BMA222_EN_SUSPEND__REG            BMA222_MODE_CTRL_REG
+
+#define BMA222_INT_MODE_SEL__POS                0
+#define BMA222_INT_MODE_SEL__LEN                4
+#define BMA222_INT_MODE_SEL__MSK                0x0F
+#define BMA222_INT_MODE_SEL__REG                BMA222_INT_CTRL_REG
+
+#define BMA222_LOWG_INT_S__POS          0
+#define BMA222_LOWG_INT_S__LEN          1
+#define BMA222_LOWG_INT_S__MSK          0x01
+#define BMA222_LOWG_INT_S__REG          BMA222_STATUS1_REG
+
+#define BMA222_HIGHG_INT_S__POS          1
+#define BMA222_HIGHG_INT_S__LEN          1
+#define BMA222_HIGHG_INT_S__MSK          0x02
+#define BMA222_HIGHG_INT_S__REG          BMA222_STATUS1_REG
+
+#define BMA222_SLOPE_INT_S__POS          2
+#define BMA222_SLOPE_INT_S__LEN          1
+#define BMA222_SLOPE_INT_S__MSK          0x04
+#define BMA222_SLOPE_INT_S__REG          BMA222_STATUS1_REG
+
+#define BMA222_DOUBLE_TAP_INT_S__POS     4
+#define BMA222_DOUBLE_TAP_INT_S__LEN     1
+#define BMA222_DOUBLE_TAP_INT_S__MSK     0x10
+#define BMA222_DOUBLE_TAP_INT_S__REG     BMA222_STATUS1_REG
+
+#define BMA222_SINGLE_TAP_INT_S__POS     5
+#define BMA222_SINGLE_TAP_INT_S__LEN     1
+#define BMA222_SINGLE_TAP_INT_S__MSK     0x20
+#define BMA222_SINGLE_TAP_INT_S__REG     BMA222_STATUS1_REG
+
+#define BMA222_ORIENT_INT_S__POS         6
+#define BMA222_ORIENT_INT_S__LEN         1
+#define BMA222_ORIENT_INT_S__MSK         0x40
+#define BMA222_ORIENT_INT_S__REG         BMA222_STATUS1_REG
+
+#define BMA222_FLAT_INT_S__POS           7
+#define BMA222_FLAT_INT_S__LEN           1
+#define BMA222_FLAT_INT_S__MSK           0x80
+#define BMA222_FLAT_INT_S__REG           BMA222_STATUS1_REG
+
+#define BMA222_DATA_INT_S__POS           7
+#define BMA222_DATA_INT_S__LEN           1
+#define BMA222_DATA_INT_S__MSK           0x80
+#define BMA222_DATA_INT_S__REG           BMA222_STATUS2_REG
+
+#define BMA222_SLOPE_FIRST_X__POS        0
+#define BMA222_SLOPE_FIRST_X__LEN        1
+#define BMA222_SLOPE_FIRST_X__MSK        0x01
+#define BMA222_SLOPE_FIRST_X__REG        BMA222_STATUS_TAP_SLOPE_REG
+
+#define BMA222_SLOPE_FIRST_Y__POS        1
+#define BMA222_SLOPE_FIRST_Y__LEN        1
+#define BMA222_SLOPE_FIRST_Y__MSK        0x02
+#define BMA222_SLOPE_FIRST_Y__REG        BMA222_STATUS_TAP_SLOPE_REG
+
+#define BMA222_SLOPE_FIRST_Z__POS        2
+#define BMA222_SLOPE_FIRST_Z__LEN        1
+#define BMA222_SLOPE_FIRST_Z__MSK        0x04
+#define BMA222_SLOPE_FIRST_Z__REG        BMA222_STATUS_TAP_SLOPE_REG
+
+#define BMA222_SLOPE_SIGN_S__POS         3
+#define BMA222_SLOPE_SIGN_S__LEN         1
+#define BMA222_SLOPE_SIGN_S__MSK         0x08
+#define BMA222_SLOPE_SIGN_S__REG         BMA222_STATUS_TAP_SLOPE_REG
+
+#define BMA222_TAP_FIRST_X__POS        4
+#define BMA222_TAP_FIRST_X__LEN        1
+#define BMA222_TAP_FIRST_X__MSK        0x10
+#define BMA222_TAP_FIRST_X__REG        BMA222_STATUS_TAP_SLOPE_REG
+
+#define BMA222_TAP_FIRST_Y__POS        5
+#define BMA222_TAP_FIRST_Y__LEN        1
+#define BMA222_TAP_FIRST_Y__MSK        0x20
+#define BMA222_TAP_FIRST_Y__REG        BMA222_STATUS_TAP_SLOPE_REG
+
+#define BMA222_TAP_FIRST_Z__POS        6
+#define BMA222_TAP_FIRST_Z__LEN        1
+#define BMA222_TAP_FIRST_Z__MSK        0x40
+#define BMA222_TAP_FIRST_Z__REG        BMA222_STATUS_TAP_SLOPE_REG
+
+#define BMA222_TAP_FIRST_XYZ__POS        4
+#define BMA222_TAP_FIRST_XYZ__LEN        3
+#define BMA222_TAP_FIRST_XYZ__MSK        0x70
+#define BMA222_TAP_FIRST_XYZ__REG        BMA222_STATUS_TAP_SLOPE_REG
+
+#define BMA222_TAP_SIGN_S__POS         7
+#define BMA222_TAP_SIGN_S__LEN         1
+#define BMA222_TAP_SIGN_S__MSK         0x80
+#define BMA222_TAP_SIGN_S__REG         BMA222_STATUS_TAP_SLOPE_REG
+
+#define BMA222_HIGHG_FIRST_X__POS        0
+#define BMA222_HIGHG_FIRST_X__LEN        1
+#define BMA222_HIGHG_FIRST_X__MSK        0x01
+#define BMA222_HIGHG_FIRST_X__REG        BMA222_STATUS_ORIENT_HIGH_REG
+
+#define BMA222_HIGHG_FIRST_Y__POS        1
+#define BMA222_HIGHG_FIRST_Y__LEN        1
+#define BMA222_HIGHG_FIRST_Y__MSK        0x02
+#define BMA222_HIGHG_FIRST_Y__REG        BMA222_STATUS_ORIENT_HIGH_REG
+
+#define BMA222_HIGHG_FIRST_Z__POS        2
+#define BMA222_HIGHG_FIRST_Z__LEN        1
+#define BMA222_HIGHG_FIRST_Z__MSK        0x04
+#define BMA222_HIGHG_FIRST_Z__REG        BMA222_STATUS_ORIENT_HIGH_REG
+
+#define BMA222_HIGHG_SIGN_S__POS         3
+#define BMA222_HIGHG_SIGN_S__LEN         1
+#define BMA222_HIGHG_SIGN_S__MSK         0x08
+#define BMA222_HIGHG_SIGN_S__REG         BMA222_STATUS_ORIENT_HIGH_REG
+
+#define BMA222_ORIENT_S__POS             4
+#define BMA222_ORIENT_S__LEN             3
+#define BMA222_ORIENT_S__MSK             0x70
+#define BMA222_ORIENT_S__REG             BMA222_STATUS_ORIENT_HIGH_REG
+
+#define BMA222_FLAT_S__POS               7
+#define BMA222_FLAT_S__LEN               1
+#define BMA222_FLAT_S__MSK               0x80
+#define BMA222_FLAT_S__REG               BMA222_STATUS_ORIENT_HIGH_REG
+
+#define BMA222_EN_SLOPE_X_INT__POS         0
+#define BMA222_EN_SLOPE_X_INT__LEN         1
+#define BMA222_EN_SLOPE_X_INT__MSK         0x01
+#define BMA222_EN_SLOPE_X_INT__REG         BMA222_INT_ENABLE1_REG
+
+#define BMA222_EN_SLOPE_Y_INT__POS         1
+#define BMA222_EN_SLOPE_Y_INT__LEN         1
+#define BMA222_EN_SLOPE_Y_INT__MSK         0x02
+#define BMA222_EN_SLOPE_Y_INT__REG         BMA222_INT_ENABLE1_REG
+
+#define BMA222_EN_SLOPE_Z_INT__POS         2
+#define BMA222_EN_SLOPE_Z_INT__LEN         1
+#define BMA222_EN_SLOPE_Z_INT__MSK         0x04
+#define BMA222_EN_SLOPE_Z_INT__REG         BMA222_INT_ENABLE1_REG
+
+#define BMA222_EN_SLOPE_XYZ_INT__POS         0
+#define BMA222_EN_SLOPE_XYZ_INT__LEN         3
+#define BMA222_EN_SLOPE_XYZ_INT__MSK         0x07
+#define BMA222_EN_SLOPE_XYZ_INT__REG         BMA222_INT_ENABLE1_REG
+
+#define BMA222_EN_DOUBLE_TAP_INT__POS      4
+#define BMA222_EN_DOUBLE_TAP_INT__LEN      1
+#define BMA222_EN_DOUBLE_TAP_INT__MSK      0x10
+#define BMA222_EN_DOUBLE_TAP_INT__REG      BMA222_INT_ENABLE1_REG
+
+#define BMA222_EN_SINGLE_TAP_INT__POS      5
+#define BMA222_EN_SINGLE_TAP_INT__LEN      1
+#define BMA222_EN_SINGLE_TAP_INT__MSK      0x20
+#define BMA222_EN_SINGLE_TAP_INT__REG      BMA222_INT_ENABLE1_REG
+
+#define BMA222_EN_ORIENT_INT__POS          6
+#define BMA222_EN_ORIENT_INT__LEN          1
+#define BMA222_EN_ORIENT_INT__MSK          0x40
+#define BMA222_EN_ORIENT_INT__REG          BMA222_INT_ENABLE1_REG
+
+#define BMA222_EN_FLAT_INT__POS            7
+#define BMA222_EN_FLAT_INT__LEN            1
+#define BMA222_EN_FLAT_INT__MSK            0x80
+#define BMA222_EN_FLAT_INT__REG            BMA222_INT_ENABLE1_REG
+
+#define BMA222_EN_HIGHG_X_INT__POS         0
+#define BMA222_EN_HIGHG_X_INT__LEN         1
+#define BMA222_EN_HIGHG_X_INT__MSK         0x01
+#define BMA222_EN_HIGHG_X_INT__REG         BMA222_INT_ENABLE2_REG
+
+#define BMA222_EN_HIGHG_Y_INT__POS         1
+#define BMA222_EN_HIGHG_Y_INT__LEN         1
+#define BMA222_EN_HIGHG_Y_INT__MSK         0x02
+#define BMA222_EN_HIGHG_Y_INT__REG         BMA222_INT_ENABLE2_REG
+
+#define BMA222_EN_HIGHG_Z_INT__POS         2
+#define BMA222_EN_HIGHG_Z_INT__LEN         1
+#define BMA222_EN_HIGHG_Z_INT__MSK         0x04
+#define BMA222_EN_HIGHG_Z_INT__REG         BMA222_INT_ENABLE2_REG
+
+#define BMA222_EN_HIGHG_XYZ_INT__POS         2
+#define BMA222_EN_HIGHG_XYZ_INT__LEN         1
+#define BMA222_EN_HIGHG_XYZ_INT__MSK         0x04
+#define BMA222_EN_HIGHG_XYZ_INT__REG         BMA222_INT_ENABLE2_REG
+
+#define BMA222_EN_LOWG_INT__POS            3
+#define BMA222_EN_LOWG_INT__LEN            1
+#define BMA222_EN_LOWG_INT__MSK            0x08
+#define BMA222_EN_LOWG_INT__REG            BMA222_INT_ENABLE2_REG
+
+#define BMA222_EN_NEW_DATA_INT__POS        4
+#define BMA222_EN_NEW_DATA_INT__LEN        1
+#define BMA222_EN_NEW_DATA_INT__MSK        0x10
+#define BMA222_EN_NEW_DATA_INT__REG        BMA222_INT_ENABLE2_REG
+
+#define BMA222_EN_INT1_PAD_LOWG__POS        0
+#define BMA222_EN_INT1_PAD_LOWG__LEN        1
+#define BMA222_EN_INT1_PAD_LOWG__MSK        0x01
+#define BMA222_EN_INT1_PAD_LOWG__REG        BMA222_INT1_PAD_SEL_REG
+
+#define BMA222_EN_INT1_PAD_HIGHG__POS       1
+#define BMA222_EN_INT1_PAD_HIGHG__LEN       1
+#define BMA222_EN_INT1_PAD_HIGHG__MSK       0x02
+#define BMA222_EN_INT1_PAD_HIGHG__REG       BMA222_INT1_PAD_SEL_REG
+
+#define BMA222_EN_INT1_PAD_SLOPE__POS       2
+#define BMA222_EN_INT1_PAD_SLOPE__LEN       1
+#define BMA222_EN_INT1_PAD_SLOPE__MSK       0x04
+#define BMA222_EN_INT1_PAD_SLOPE__REG       BMA222_INT1_PAD_SEL_REG
+
+#define BMA222_EN_INT1_PAD_DB_TAP__POS      4
+#define BMA222_EN_INT1_PAD_DB_TAP__LEN      1
+#define BMA222_EN_INT1_PAD_DB_TAP__MSK      0x10
+#define BMA222_EN_INT1_PAD_DB_TAP__REG      BMA222_INT1_PAD_SEL_REG
+
+#define BMA222_EN_INT1_PAD_SNG_TAP__POS     5
+#define BMA222_EN_INT1_PAD_SNG_TAP__LEN     1
+#define BMA222_EN_INT1_PAD_SNG_TAP__MSK     0x20
+#define BMA222_EN_INT1_PAD_SNG_TAP__REG     BMA222_INT1_PAD_SEL_REG
+
+#define BMA222_EN_INT1_PAD_ORIENT__POS      6
+#define BMA222_EN_INT1_PAD_ORIENT__LEN      1
+#define BMA222_EN_INT1_PAD_ORIENT__MSK      0x40
+#define BMA222_EN_INT1_PAD_ORIENT__REG      BMA222_INT1_PAD_SEL_REG
+
+#define BMA222_EN_INT1_PAD_FLAT__POS        7
+#define BMA222_EN_INT1_PAD_FLAT__LEN        1
+#define BMA222_EN_INT1_PAD_FLAT__MSK        0x80
+#define BMA222_EN_INT1_PAD_FLAT__REG        BMA222_INT1_PAD_SEL_REG
+
+#define BMA222_EN_INT2_PAD_LOWG__POS        0
+#define BMA222_EN_INT2_PAD_LOWG__LEN        1
+#define BMA222_EN_INT2_PAD_LOWG__MSK        0x01
+#define BMA222_EN_INT2_PAD_LOWG__REG        BMA222_INT2_PAD_SEL_REG
+
+#define BMA222_EN_INT2_PAD_HIGHG__POS       1
+#define BMA222_EN_INT2_PAD_HIGHG__LEN       1
+#define BMA222_EN_INT2_PAD_HIGHG__MSK       0x02
+#define BMA222_EN_INT2_PAD_HIGHG__REG       BMA222_INT2_PAD_SEL_REG
+
+#define BMA222_EN_INT2_PAD_SLOPE__POS       2
+#define BMA222_EN_INT2_PAD_SLOPE__LEN       1
+#define BMA222_EN_INT2_PAD_SLOPE__MSK       0x04
+#define BMA222_EN_INT2_PAD_SLOPE__REG       BMA222_INT2_PAD_SEL_REG
+
+#define BMA222_EN_INT2_PAD_DB_TAP__POS      4
+#define BMA222_EN_INT2_PAD_DB_TAP__LEN      1
+#define BMA222_EN_INT2_PAD_DB_TAP__MSK      0x10
+#define BMA222_EN_INT2_PAD_DB_TAP__REG      BMA222_INT2_PAD_SEL_REG
+
+#define BMA222_EN_INT2_PAD_SNG_TAP__POS     5
+#define BMA222_EN_INT2_PAD_SNG_TAP__LEN     1
+#define BMA222_EN_INT2_PAD_SNG_TAP__MSK     0x20
+#define BMA222_EN_INT2_PAD_SNG_TAP__REG     BMA222_INT2_PAD_SEL_REG
+
+#define BMA222_EN_INT2_PAD_ORIENT__POS      6
+#define BMA222_EN_INT2_PAD_ORIENT__LEN      1
+#define BMA222_EN_INT2_PAD_ORIENT__MSK      0x40
+#define BMA222_EN_INT2_PAD_ORIENT__REG      BMA222_INT2_PAD_SEL_REG
+
+#define BMA222_EN_INT2_PAD_FLAT__POS        7
+#define BMA222_EN_INT2_PAD_FLAT__LEN        1
+#define BMA222_EN_INT2_PAD_FLAT__MSK        0x80
+#define BMA222_EN_INT2_PAD_FLAT__REG        BMA222_INT2_PAD_SEL_REG
+
+#define BMA222_EN_INT1_PAD_NEWDATA__POS     0
+#define BMA222_EN_INT1_PAD_NEWDATA__LEN     1
+#define BMA222_EN_INT1_PAD_NEWDATA__MSK     0x01
+#define BMA222_EN_INT1_PAD_NEWDATA__REG     BMA222_INT_DATA_SEL_REG
+
+#define BMA222_EN_INT2_PAD_NEWDATA__POS     7
+#define BMA222_EN_INT2_PAD_NEWDATA__LEN     1
+#define BMA222_EN_INT2_PAD_NEWDATA__MSK     0x80
+#define BMA222_EN_INT2_PAD_NEWDATA__REG     BMA222_INT_DATA_SEL_REG
+
+
+#define BMA222_UNFILT_INT_SRC_LOWG__POS        0
+#define BMA222_UNFILT_INT_SRC_LOWG__LEN        1
+#define BMA222_UNFILT_INT_SRC_LOWG__MSK        0x01
+#define BMA222_UNFILT_INT_SRC_LOWG__REG        BMA222_INT_SRC_REG
+
+#define BMA222_UNFILT_INT_SRC_HIGHG__POS       1
+#define BMA222_UNFILT_INT_SRC_HIGHG__LEN       1
+#define BMA222_UNFILT_INT_SRC_HIGHG__MSK       0x02
+#define BMA222_UNFILT_INT_SRC_HIGHG__REG       BMA222_INT_SRC_REG
+
+#define BMA222_UNFILT_INT_SRC_SLOPE__POS       2
+#define BMA222_UNFILT_INT_SRC_SLOPE__LEN       1
+#define BMA222_UNFILT_INT_SRC_SLOPE__MSK       0x04
+#define BMA222_UNFILT_INT_SRC_SLOPE__REG       BMA222_INT_SRC_REG
+
+#define BMA222_UNFILT_INT_SRC_TAP__POS         4
+#define BMA222_UNFILT_INT_SRC_TAP__LEN         1
+#define BMA222_UNFILT_INT_SRC_TAP__MSK         0x10
+#define BMA222_UNFILT_INT_SRC_TAP__REG         BMA222_INT_SRC_REG
+
+#define BMA222_UNFILT_INT_SRC_DATA__POS        5
+#define BMA222_UNFILT_INT_SRC_DATA__LEN        1
+#define BMA222_UNFILT_INT_SRC_DATA__MSK        0x20
+#define BMA222_UNFILT_INT_SRC_DATA__REG        BMA222_INT_SRC_REG
+
+#define BMA222_INT1_PAD_ACTIVE_LEVEL__POS       0
+#define BMA222_INT1_PAD_ACTIVE_LEVEL__LEN       1
+#define BMA222_INT1_PAD_ACTIVE_LEVEL__MSK       0x01
+#define BMA222_INT1_PAD_ACTIVE_LEVEL__REG       BMA222_INT_SET_REG
+
+#define BMA222_INT2_PAD_ACTIVE_LEVEL__POS       2
+#define BMA222_INT2_PAD_ACTIVE_LEVEL__LEN       1
+#define BMA222_INT2_PAD_ACTIVE_LEVEL__MSK       0x04
+#define BMA222_INT2_PAD_ACTIVE_LEVEL__REG       BMA222_INT_SET_REG
+
+#define BMA222_INT1_PAD_OUTPUT_TYPE__POS        1
+#define BMA222_INT1_PAD_OUTPUT_TYPE__LEN        1
+#define BMA222_INT1_PAD_OUTPUT_TYPE__MSK        0x02
+#define BMA222_INT1_PAD_OUTPUT_TYPE__REG        BMA222_INT_SET_REG
+
+#define BMA222_INT2_PAD_OUTPUT_TYPE__POS        3
+#define BMA222_INT2_PAD_OUTPUT_TYPE__LEN        1
+#define BMA222_INT2_PAD_OUTPUT_TYPE__MSK        0x08
+#define BMA222_INT2_PAD_OUTPUT_TYPE__REG        BMA222_INT_SET_REG
+
+
+#define BMA222_INT_MODE_SEL__POS                0
+#define BMA222_INT_MODE_SEL__LEN                4
+#define BMA222_INT_MODE_SEL__MSK                0x0F
+#define BMA222_INT_MODE_SEL__REG                BMA222_INT_CTRL_REG
+
+
+#define BMA222_INT_RESET_LATCHED__POS           7
+#define BMA222_INT_RESET_LATCHED__LEN           1
+#define BMA222_INT_RESET_LATCHED__MSK           0x80
+#define BMA222_INT_RESET_LATCHED__REG           BMA222_INT_CTRL_REG
+
+#define BMA222_LOWG_DUR__POS                    0
+#define BMA222_LOWG_DUR__LEN                    8
+#define BMA222_LOWG_DUR__MSK                    0xFF
+#define BMA222_LOWG_DUR__REG                    BMA222_LOW_DURN_REG
+
+#define BMA222_LOWG_THRES__POS                  0
+#define BMA222_LOWG_THRES__LEN                  8
+#define BMA222_LOWG_THRES__MSK                  0xFF
+#define BMA222_LOWG_THRES__REG                  BMA222_LOW_THRES_REG
+
+#define BMA222_LOWG_HYST__POS                   0
+#define BMA222_LOWG_HYST__LEN                   2
+#define BMA222_LOWG_HYST__MSK                   0x03
+#define BMA222_LOWG_HYST__REG                   BMA222_LOW_HIGH_HYST_REG
+
+#define BMA222_LOWG_INT_MODE__POS               2
+#define BMA222_LOWG_INT_MODE__LEN               1
+#define BMA222_LOWG_INT_MODE__MSK               0x04
+#define BMA222_LOWG_INT_MODE__REG               BMA222_LOW_HIGH_HYST_REG
+
+#define BMA222_HIGHG_DUR__POS                    0
+#define BMA222_HIGHG_DUR__LEN                    8
+#define BMA222_HIGHG_DUR__MSK                    0xFF
+#define BMA222_HIGHG_DUR__REG                    BMA222_HIGH_DURN_REG
+
+#define BMA222_HIGHG_THRES__POS                  0
+#define BMA222_HIGHG_THRES__LEN                  8
+#define BMA222_HIGHG_THRES__MSK                  0xFF
+#define BMA222_HIGHG_THRES__REG                  BMA222_HIGH_THRES_REG
+
+#define BMA222_HIGHG_HYST__POS                  6
+#define BMA222_HIGHG_HYST__LEN                  2
+#define BMA222_HIGHG_HYST__MSK                  0xC0
+#define BMA222_HIGHG_HYST__REG                  BMA222_LOW_HIGH_HYST_REG
+
+#define BMA222_SLOPE_DUR__POS                    0
+#define BMA222_SLOPE_DUR__LEN                    2
+#define BMA222_SLOPE_DUR__MSK                    0x03
+#define BMA222_SLOPE_DUR__REG                    BMA222_SLOPE_DURN_REG
+
+#define BMA222_SLOPE_THRES__POS                  0
+#define BMA222_SLOPE_THRES__LEN                  8
+#define BMA222_SLOPE_THRES__MSK                  0xFF
+#define BMA222_SLOPE_THRES__REG                  BMA222_SLOPE_THRES_REG
+
+#define BMA222_TAP_DUR__POS                    0
+#define BMA222_TAP_DUR__LEN                    3
+#define BMA222_TAP_DUR__MSK                    0x07
+#define BMA222_TAP_DUR__REG                    BMA222_TAP_PARAM_REG
+
+#define BMA222_TAP_SHOCK_DURN__POS             6
+#define BMA222_TAP_SHOCK_DURN__LEN             1
+#define BMA222_TAP_SHOCK_DURN__MSK             0x40
+#define BMA222_TAP_SHOCK_DURN__REG             BMA222_TAP_PARAM_REG
+
+#define BMA222_TAP_QUIET_DURN__POS             7
+#define BMA222_TAP_QUIET_DURN__LEN             1
+#define BMA222_TAP_QUIET_DURN__MSK             0x80
+#define BMA222_TAP_QUIET_DURN__REG             BMA222_TAP_PARAM_REG
+
+#define BMA222_TAP_THRES__POS                  0
+#define BMA222_TAP_THRES__LEN                  5
+#define BMA222_TAP_THRES__MSK                  0x1F
+#define BMA222_TAP_THRES__REG                  BMA222_TAP_THRES_REG
+
+#define BMA222_TAP_SAMPLES__POS                6
+#define BMA222_TAP_SAMPLES__LEN                2
+#define BMA222_TAP_SAMPLES__MSK                0xC0
+#define BMA222_TAP_SAMPLES__REG                BMA222_TAP_THRES_REG
+
+#define BMA222_ORIENT_MODE__POS                  0
+#define BMA222_ORIENT_MODE__LEN                  2
+#define BMA222_ORIENT_MODE__MSK                  0x03
+#define BMA222_ORIENT_MODE__REG                  BMA222_ORIENT_PARAM_REG
+
+#define BMA222_ORIENT_BLOCK__POS                 2
+#define BMA222_ORIENT_BLOCK__LEN                 2
+#define BMA222_ORIENT_BLOCK__MSK                 0x0C
+#define BMA222_ORIENT_BLOCK__REG                 BMA222_ORIENT_PARAM_REG
+
+#define BMA222_ORIENT_HYST__POS                  4
+#define BMA222_ORIENT_HYST__LEN                  3
+#define BMA222_ORIENT_HYST__MSK                  0x70
+#define BMA222_ORIENT_HYST__REG                  BMA222_ORIENT_PARAM_REG
+
+#define BMA222_ORIENT_AXIS__POS                  7
+#define BMA222_ORIENT_AXIS__LEN                  1
+#define BMA222_ORIENT_AXIS__MSK                  0x80
+#define BMA222_ORIENT_AXIS__REG                  BMA222_THETA_BLOCK_REG
+
+#define BMA222_THETA_BLOCK__POS                  0
+#define BMA222_THETA_BLOCK__LEN                  6
+#define BMA222_THETA_BLOCK__MSK                  0x3F
+#define BMA222_THETA_BLOCK__REG                  BMA222_THETA_BLOCK_REG
+
+#define BMA222_THETA_FLAT__POS                  0
+#define BMA222_THETA_FLAT__LEN                  6
+#define BMA222_THETA_FLAT__MSK                  0x3F
+#define BMA222_THETA_FLAT__REG                  BMA222_THETA_FLAT_REG
+
+#define BMA222_FLAT_HOLD_TIME__POS              4
+#define BMA222_FLAT_HOLD_TIME__LEN              2
+#define BMA222_FLAT_HOLD_TIME__MSK              0x30
+#define BMA222_FLAT_HOLD_TIME__REG              BMA222_FLAT_HOLD_TIME_REG
+
+#define BMA222_EN_SELF_TEST__POS                0
+#define BMA222_EN_SELF_TEST__LEN                2
+#define BMA222_EN_SELF_TEST__MSK                0x03
+#define BMA222_EN_SELF_TEST__REG                BMA222_SELF_TEST_REG
+
+
+
+#define BMA222_NEG_SELF_TEST__POS               2
+#define BMA222_NEG_SELF_TEST__LEN               1
+#define BMA222_NEG_SELF_TEST__MSK               0x04
+#define BMA222_NEG_SELF_TEST__REG               BMA222_SELF_TEST_REG
+
+
+#define BMA222_LOW_POWER_MODE_S__POS            0
+#define BMA222_LOW_POWER_MODE_S__LEN            1
+#define BMA222_LOW_POWER_MODE_S__MSK            0x01
+#define BMA222_LOW_POWER_MODE_S__REG            BMA222_STATUS_LOW_POWER_REG
+
+#define BMA222_EN_FAST_COMP__POS                5
+#define BMA222_EN_FAST_COMP__LEN                2
+#define BMA222_EN_FAST_COMP__MSK                0x60
+#define BMA222_EN_FAST_COMP__REG                BMA222_OFFSET_CTRL_REG
+
+#define BMA222_FAST_COMP_RDY_S__POS             4
+#define BMA222_FAST_COMP_RDY_S__LEN             1
+#define BMA222_FAST_COMP_RDY_S__MSK             0x10
+#define BMA222_FAST_COMP_RDY_S__REG             BMA222_OFFSET_CTRL_REG
+
+#define BMA222_COMP_TARGET_OFFSET_X__POS        1
+#define BMA222_COMP_TARGET_OFFSET_X__LEN        2
+#define BMA222_COMP_TARGET_OFFSET_X__MSK        0x06
+#define BMA222_COMP_TARGET_OFFSET_X__REG        BMA222_OFFSET_PARAMS_REG
+
+#define BMA222_COMP_TARGET_OFFSET_Y__POS        3
+#define BMA222_COMP_TARGET_OFFSET_Y__LEN        2
+#define BMA222_COMP_TARGET_OFFSET_Y__MSK        0x18
+#define BMA222_COMP_TARGET_OFFSET_Y__REG        BMA222_OFFSET_PARAMS_REG
+
+#define BMA222_COMP_TARGET_OFFSET_Z__POS        5
+#define BMA222_COMP_TARGET_OFFSET_Z__LEN        2
+#define BMA222_COMP_TARGET_OFFSET_Z__MSK        0x60
+#define BMA222_COMP_TARGET_OFFSET_Z__REG        BMA222_OFFSET_PARAMS_REG
+
+#define BMA222_RANGE_2G                 0
+#define BMA222_RANGE_4G                 1
+#define BMA222_RANGE_8G                 2
+#define BMA222_RANGE_16G                3
+
+#define BMA222_BW_7_81HZ        0x08
+#define BMA222_BW_15_63HZ       0x09
+#define BMA222_BW_31_25HZ       0x0A
+#define BMA222_BW_62_50HZ       0x0B
+#define BMA222_BW_125HZ         0x0C
+#define BMA222_BW_250HZ         0x0D
+#define BMA222_BW_500HZ         0x0E
+#define BMA222_BW_1000HZ        0x0F
+
+#define BMA222_MODE_NORMAL      0
+#define BMA222_MODE_LOWPOWER    1
+#define BMA222_MODE_SUSPEND     2
+
+
+#define BMA222_GET_BITSLICE(regvar, bitname)\
+	((regvar & bitname##__MSK) >> bitname##__POS)
+
+
+#define BMA222_SET_BITSLICE(regvar, bitname, val)\
+	((regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK))
+
+
+struct bma222acc{
+	s16	x,
+		y,
+		z;
+} ;
+
+struct bma222_data {
+	struct i2c_client *bma222_client;
+	atomic_t delay;
+	atomic_t enable;
+	atomic_t selftest_result;
+	unsigned char mode;
+	struct input_dev *input;
+	struct bma222acc value;
+	struct mutex value_mutex;
+	struct mutex enable_mutex;
+	struct mutex mode_mutex;
+	struct delayed_work work;
+	struct work_struct irq_work;
+	atomic_t position;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+	int IRQ;
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma222_early_suspend(struct early_suspend *h);
+static void bma222_late_resume(struct early_suspend *h);
+#endif
+
+
+
+static int bma222_smbus_read_byte(struct i2c_client *client,
+		unsigned char reg_addr, unsigned char *data)
+{
+	s32 dummy;
+	dummy = i2c_smbus_read_byte_data(client, reg_addr);
+	if (dummy < 0)
+		return -1;
+	*data = dummy & 0x000000ff;
+
+	return 0;
+}
+
+static int bma222_smbus_write_byte(struct i2c_client *client,
+		unsigned char reg_addr, unsigned char *data)
+{
+	s32 dummy;
+	dummy = i2c_smbus_write_byte_data(client, reg_addr, *data);
+	if (dummy < 0)
+		return -1;
+	return 0;
+}
+
+static int bma222_smbus_read_byte_block(struct i2c_client *client,
+		unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+	s32 dummy;
+	dummy = i2c_smbus_read_i2c_block_data(client, reg_addr, len, data);
+	if (dummy < 0)
+		return -1;
+	return 0;
+}
+
+static int bma222_smbus_write_byte_block(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    s32 idx;
+    
+
+    for (idx = 0; idx < len; idx ++)
+    {
+        dummy = i2c_smbus_write_byte_data(client, reg_addr+idx, data[idx]);
+        if (dummy < 0)
+            return -1;
+    }
+    
+    return 0;
+}
+
+static int bma222_set_mode(struct i2c_client *client, unsigned char Mode)
+{
+	int comres = 0;
+	unsigned char data1;
+
+
+	if (Mode < 3) {
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_LOW_POWER__REG, &data1);
+		switch (Mode) {
+		case BMA222_MODE_NORMAL:
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_EN_LOW_POWER, 0);
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_EN_SUSPEND, 0);
+			break;
+		case BMA222_MODE_LOWPOWER:
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_EN_LOW_POWER, 1);
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_EN_SUSPEND, 0);
+			break;
+		case BMA222_MODE_SUSPEND:
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_EN_LOW_POWER, 0);
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_EN_SUSPEND, 1);
+			break;
+		default:
+			break;
+		}
+
+		comres += bma222_smbus_write_byte(client,
+				BMA222_EN_LOW_POWER__REG, &data1);
+	} else{
+		comres = -1;
+	}
+
+
+	return comres;
+}
+#ifdef BMA222_ENABLE_INT1
+static int bma222_set_int1_pad_sel(struct i2c_client *client, unsigned char
+		int1sel)
+{
+	int comres = 0;
+	unsigned char data;
+	unsigned char state;
+	state = 0x01;
+
+
+	switch (int1sel) {
+	case 0:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT1_PAD_LOWG__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT1_PAD_LOWG,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT1_PAD_LOWG__REG, &data);
+		break;
+	case 1:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT1_PAD_HIGHG__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT1_PAD_HIGHG,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT1_PAD_HIGHG__REG, &data);
+		break;
+	case 2:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT1_PAD_SLOPE__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT1_PAD_SLOPE,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT1_PAD_SLOPE__REG, &data);
+		break;
+	case 3:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT1_PAD_DB_TAP__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT1_PAD_DB_TAP,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT1_PAD_DB_TAP__REG, &data);
+		break;
+	case 4:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT1_PAD_SNG_TAP__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT1_PAD_SNG_TAP,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT1_PAD_SNG_TAP__REG, &data);
+		break;
+	case 5:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT1_PAD_ORIENT__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT1_PAD_ORIENT,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT1_PAD_ORIENT__REG, &data);
+		break;
+	case 6:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT1_PAD_FLAT__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT1_PAD_FLAT,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT1_PAD_FLAT__REG, &data);
+		break;
+	default:
+		break;
+	}
+
+	return comres;
+}
+#endif /* BMA222_ENABLE_INT1 */
+#ifdef BMA222_ENABLE_INT2
+static int bma222_set_int2_pad_sel(struct i2c_client *client, unsigned char
+		int2sel)
+{
+	int comres = 0;
+	unsigned char data;
+	unsigned char state;
+	state = 0x01;
+
+
+	switch (int2sel) {
+	case 0:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT2_PAD_LOWG__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT2_PAD_LOWG,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT2_PAD_LOWG__REG, &data);
+		break;
+	case 1:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT2_PAD_HIGHG__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT2_PAD_HIGHG,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT2_PAD_HIGHG__REG, &data);
+		break;
+	case 2:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT2_PAD_SLOPE__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT2_PAD_SLOPE,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT2_PAD_SLOPE__REG, &data);
+		break;
+	case 3:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT2_PAD_DB_TAP__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT2_PAD_DB_TAP,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT2_PAD_DB_TAP__REG, &data);
+		break;
+	case 4:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT2_PAD_SNG_TAP__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT2_PAD_SNG_TAP,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT2_PAD_SNG_TAP__REG, &data);
+		break;
+	case 5:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT2_PAD_ORIENT__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT2_PAD_ORIENT,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT2_PAD_ORIENT__REG, &data);
+		break;
+	case 6:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_EN_INT2_PAD_FLAT__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_EN_INT2_PAD_FLAT,
+				state);
+		comres = bma222_smbus_write_byte(client,
+				BMA222_EN_INT2_PAD_FLAT__REG, &data);
+		break;
+	default:
+		break;
+	}
+
+	return comres;
+}
+#endif /* BMA222_ENABLE_INT2 */
+
+static int bma222_set_Int_Enable(struct i2c_client *client, unsigned char
+		InterruptType , unsigned char value)
+{
+	int comres = 0;
+	unsigned char data1, data2;
+
+
+	comres = bma222_smbus_read_byte(client, BMA222_INT_ENABLE1_REG, &data1);
+	comres = bma222_smbus_read_byte(client, BMA222_INT_ENABLE2_REG, &data2);
+
+	value = value & 1;
+	switch (InterruptType) {
+	case 0:
+		/* Low G Interrupt  */
+		data2 = BMA222_SET_BITSLICE(data2, BMA222_EN_LOWG_INT, value);
+		break;
+	case 1:
+		/* High G X Interrupt */
+
+		data2 = BMA222_SET_BITSLICE(data2, BMA222_EN_HIGHG_X_INT,
+				value);
+		break;
+	case 2:
+		/* High G Y Interrupt */
+
+		data2 = BMA222_SET_BITSLICE(data2, BMA222_EN_HIGHG_Y_INT,
+				value);
+		break;
+	case 3:
+		/* High G Z Interrupt */
+
+		data2 = BMA222_SET_BITSLICE(data2, BMA222_EN_HIGHG_Z_INT,
+				value);
+		break;
+	case 4:
+		/* New Data Interrupt  */
+
+		data2 = BMA222_SET_BITSLICE(data2, BMA222_EN_NEW_DATA_INT,
+				value);
+		break;
+	case 5:
+		/* Slope X Interrupt */
+
+		data1 = BMA222_SET_BITSLICE(data1, BMA222_EN_SLOPE_X_INT,
+				value);
+		break;
+	case 6:
+		/* Slope Y Interrupt */
+
+		data1 = BMA222_SET_BITSLICE(data1, BMA222_EN_SLOPE_Y_INT,
+				value);
+		break;
+	case 7:
+		/* Slope Z Interrupt */
+
+		data1 = BMA222_SET_BITSLICE(data1, BMA222_EN_SLOPE_Z_INT,
+				value);
+		break;
+	case 8:
+		/* Single Tap Interrupt */
+
+		data1 = BMA222_SET_BITSLICE(data1, BMA222_EN_SINGLE_TAP_INT,
+				value);
+		break;
+	case 9:
+		/* Double Tap Interrupt */
+
+		data1 = BMA222_SET_BITSLICE(data1, BMA222_EN_DOUBLE_TAP_INT,
+				value);
+		break;
+	case 10:
+		/* Orient Interrupt  */
+
+		data1 = BMA222_SET_BITSLICE(data1, BMA222_EN_ORIENT_INT, value);
+		break;
+	case 11:
+		/* Flat Interrupt */
+
+		data1 = BMA222_SET_BITSLICE(data1, BMA222_EN_FLAT_INT, value);
+		break;
+	default:
+		break;
+	}
+	comres = bma222_smbus_write_byte(client, BMA222_INT_ENABLE1_REG,
+			&data1);
+	comres = bma222_smbus_write_byte(client, BMA222_INT_ENABLE2_REG,
+			&data2);
+
+	return comres;
+}
+
+
+static int bma222_get_mode(struct i2c_client *client, unsigned char *Mode)
+{
+	int comres = 0;
+
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_EN_LOW_POWER__REG, Mode);
+	*Mode  = (*Mode) >> 6;
+
+
+	return comres;
+}
+
+static int bma222_set_range(struct i2c_client *client, unsigned char Range)
+{
+	int comres = 0;
+	unsigned char data1;
+
+
+	if (Range < 4) {
+		comres = bma222_smbus_read_byte(client,
+				BMA222_RANGE_SEL_REG, &data1);
+		switch (Range) {
+		case 0:
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_RANGE_SEL, 0);
+			break;
+		case 1:
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_RANGE_SEL, 5);
+			break;
+		case 2:
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_RANGE_SEL, 8);
+			break;
+		case 3:
+			data1  = BMA222_SET_BITSLICE(data1,
+					BMA222_RANGE_SEL, 12);
+			break;
+		default:
+			break;
+		}
+		comres += bma222_smbus_write_byte(client,
+				BMA222_RANGE_SEL_REG, &data1);
+	} else{
+		comres = -1;
+	}
+
+
+	return comres;
+}
+
+static int bma222_get_range(struct i2c_client *client, unsigned char *Range)
+{
+	int comres = 0;
+	unsigned char data;
+
+
+	comres = bma222_smbus_read_byte(client, BMA222_RANGE_SEL__REG,
+			&data);
+	data = BMA222_GET_BITSLICE(data, BMA222_RANGE_SEL);
+	*Range = data;
+
+
+	return comres;
+}
+
+
+static int bma222_set_bandwidth(struct i2c_client *client, unsigned char BW)
+{
+	int comres = 0;
+	unsigned char data;
+	int Bandwidth = 0;
+
+
+	if (BW < 8) {
+		switch (BW) {
+		case 0:
+			Bandwidth = BMA222_BW_7_81HZ;
+			break;
+		case 1:
+			Bandwidth = BMA222_BW_15_63HZ;
+			break;
+		case 2:
+			Bandwidth = BMA222_BW_31_25HZ;
+			break;
+		case 3:
+			Bandwidth = BMA222_BW_62_50HZ;
+			break;
+		case 4:
+			Bandwidth = BMA222_BW_125HZ;
+			break;
+		case 5:
+			Bandwidth = BMA222_BW_250HZ;
+			break;
+		case 6:
+			Bandwidth = BMA222_BW_500HZ;
+			break;
+		case 7:
+			Bandwidth = BMA222_BW_1000HZ;
+			break;
+		default:
+			break;
+		}
+		comres = bma222_smbus_read_byte(client,
+				BMA222_BANDWIDTH__REG, &data);
+		data = BMA222_SET_BITSLICE(data, BMA222_BANDWIDTH,
+				Bandwidth);
+		comres += bma222_smbus_write_byte(client,
+				BMA222_BANDWIDTH__REG, &data);
+	} else{
+		comres = -1;
+	}
+
+
+	return comres;
+}
+
+static int bma222_get_bandwidth(struct i2c_client *client, unsigned char *BW)
+{
+	int comres = 0;
+	unsigned char data;
+
+
+	comres = bma222_smbus_read_byte(client, BMA222_BANDWIDTH__REG,
+			&data);
+	data = BMA222_GET_BITSLICE(data, BMA222_BANDWIDTH);
+	if (data <= 8) {
+		*BW = 0;
+	} else{
+		if (data >= 0x0F)
+			*BW = 7;
+		else
+			*BW = data - 8;
+
+	}
+
+
+	return comres;
+}
+
+#if defined(BMA222_ENABLE_INT1) || defined(BMA222_ENABLE_INT2)
+static int bma222_get_interruptstatus1(struct i2c_client *client, unsigned char
+		*intstatus)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_STATUS1_REG, &data);
+	*intstatus = data;
+
+	return comres;
+}
+
+
+static int bma222_get_HIGH_first(struct i2c_client *client, unsigned char
+						param, unsigned char *intstatus)
+{
+	int comres = 0;
+	unsigned char data;
+
+	switch (param) {
+	case 0:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_STATUS_ORIENT_HIGH_REG, &data);
+		data = BMA222_GET_BITSLICE(data, BMA222_HIGHG_FIRST_X);
+		*intstatus = data;
+		break;
+	case 1:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_STATUS_ORIENT_HIGH_REG, &data);
+		data = BMA222_GET_BITSLICE(data, BMA222_HIGHG_FIRST_Y);
+		*intstatus = data;
+		break;
+	case 2:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_STATUS_ORIENT_HIGH_REG, &data);
+		data = BMA222_GET_BITSLICE(data, BMA222_HIGHG_FIRST_Z);
+		*intstatus = data;
+		break;
+	default:
+		break;
+	}
+
+	return comres;
+}
+
+static int bma222_get_HIGH_sign(struct i2c_client *client, unsigned char
+		*intstatus)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_STATUS_ORIENT_HIGH_REG,
+			&data);
+	data = BMA222_GET_BITSLICE(data, BMA222_HIGHG_SIGN_S);
+	*intstatus = data;
+
+	return comres;
+}
+
+
+static int bma222_get_slope_first(struct i2c_client *client, unsigned char
+	param, unsigned char *intstatus)
+{
+	int comres = 0;
+	unsigned char data;
+
+	switch (param) {
+	case 0:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_STATUS_TAP_SLOPE_REG, &data);
+		data = BMA222_GET_BITSLICE(data, BMA222_SLOPE_FIRST_X);
+		*intstatus = data;
+		break;
+	case 1:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_STATUS_TAP_SLOPE_REG, &data);
+		data = BMA222_GET_BITSLICE(data, BMA222_SLOPE_FIRST_Y);
+		*intstatus = data;
+		break;
+	case 2:
+		comres = bma222_smbus_read_byte(client,
+				BMA222_STATUS_TAP_SLOPE_REG, &data);
+		data = BMA222_GET_BITSLICE(data, BMA222_SLOPE_FIRST_Z);
+		*intstatus = data;
+		break;
+	default:
+		break;
+	}
+
+	return comres;
+}
+
+static int bma222_get_slope_sign(struct i2c_client *client, unsigned char
+		*intstatus)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_STATUS_TAP_SLOPE_REG,
+			&data);
+	data = BMA222_GET_BITSLICE(data, BMA222_SLOPE_SIGN_S);
+	*intstatus = data;
+
+	return comres;
+}
+
+static int bma222_get_orient_status(struct i2c_client *client, unsigned char
+		*intstatus)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_STATUS_ORIENT_HIGH_REG,
+			&data);
+	data = BMA222_GET_BITSLICE(data, BMA222_ORIENT_S);
+	*intstatus = data;
+
+	return comres;
+}
+
+static int bma222_get_orient_flat_status(struct i2c_client *client, unsigned
+		char *intstatus)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_STATUS_ORIENT_HIGH_REG,
+			&data);
+	data = BMA222_GET_BITSLICE(data, BMA222_FLAT_S);
+	*intstatus = data;
+
+	return comres;
+}
+#endif /* defined(BMA222_ENABLE_INT1)||defined(BMA222_ENABLE_INT2) */
+static int bma222_set_Int_Mode(struct i2c_client *client, unsigned char Mode)
+{
+	int comres = 0;
+	unsigned char data;
+
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_INT_MODE_SEL__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_INT_MODE_SEL, Mode);
+	comres = bma222_smbus_write_byte(client,
+			BMA222_INT_MODE_SEL__REG, &data);
+
+
+	return comres;
+}
+
+static int bma222_get_Int_Mode(struct i2c_client *client, unsigned char *Mode)
+{
+	int comres = 0;
+	unsigned char data;
+
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_INT_MODE_SEL__REG, &data);
+	data  = BMA222_GET_BITSLICE(data, BMA222_INT_MODE_SEL);
+	*Mode = data;
+
+
+	return comres;
+}
+static int bma222_set_slope_duration(struct i2c_client *client, unsigned char
+		duration)
+{
+	int comres = 0;
+	unsigned char data;
+
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_SLOPE_DUR__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_SLOPE_DUR, duration);
+	comres = bma222_smbus_write_byte(client,
+			BMA222_SLOPE_DUR__REG, &data);
+
+
+	return comres;
+}
+
+static int bma222_get_slope_duration(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_SLOPE_DURN_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_SLOPE_DUR);
+	*status = data;
+
+
+	return comres;
+}
+
+static int bma222_set_slope_threshold(struct i2c_client *client,
+		unsigned char threshold)
+{
+	int comres = 0;
+	unsigned char data;
+
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_SLOPE_THRES__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_SLOPE_THRES, threshold);
+	comres = bma222_smbus_write_byte(client,
+			BMA222_SLOPE_THRES__REG, &data);
+
+
+	return comres;
+}
+
+static int bma222_get_slope_threshold(struct i2c_client *client,
+		unsigned char *status)
+{
+	int comres = 0;
+	unsigned char data;
+
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_SLOPE_THRES_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_SLOPE_THRES);
+	*status = data;
+
+
+	return comres;
+}
+static int bma222_set_low_g_duration(struct i2c_client *client, unsigned char
+		duration)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_LOWG_DUR__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_LOWG_DUR, duration);
+	comres = bma222_smbus_write_byte(client, BMA222_LOWG_DUR__REG, &data);
+
+	return comres;
+}
+
+static int bma222_get_low_g_duration(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_LOW_DURN_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_LOWG_DUR);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_low_g_threshold(struct i2c_client *client, unsigned char
+		threshold)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_LOWG_THRES__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_LOWG_THRES, threshold);
+	comres = bma222_smbus_write_byte(client, BMA222_LOWG_THRES__REG, &data);
+
+	return comres;
+}
+
+static int bma222_get_low_g_threshold(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_LOW_THRES_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_LOWG_THRES);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_high_g_duration(struct i2c_client *client, unsigned char
+		duration)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_HIGHG_DUR__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_HIGHG_DUR, duration);
+	comres = bma222_smbus_write_byte(client, BMA222_HIGHG_DUR__REG, &data);
+
+	return comres;
+}
+
+static int bma222_get_high_g_duration(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_HIGH_DURN_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_HIGHG_DUR);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_high_g_threshold(struct i2c_client *client, unsigned char
+		threshold)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_HIGHG_THRES__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_HIGHG_THRES, threshold);
+	comres = bma222_smbus_write_byte(client, BMA222_HIGHG_THRES__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_get_high_g_threshold(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_HIGH_THRES_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_HIGHG_THRES);
+	*status = data;
+
+	return comres;
+}
+
+
+static int bma222_set_tap_duration(struct i2c_client *client, unsigned char
+		duration)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_DUR__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_TAP_DUR, duration);
+	comres = bma222_smbus_write_byte(client, BMA222_TAP_DUR__REG, &data);
+
+	return comres;
+}
+
+static int bma222_get_tap_duration(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_PARAM_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_TAP_DUR);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_tap_shock(struct i2c_client *client, unsigned char setval)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_SHOCK_DURN__REG,
+			&data);
+	data = BMA222_SET_BITSLICE(data, BMA222_TAP_SHOCK_DURN, setval);
+	comres = bma222_smbus_write_byte(client, BMA222_TAP_SHOCK_DURN__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_get_tap_shock(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_PARAM_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_TAP_SHOCK_DURN);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_tap_quiet(struct i2c_client *client, unsigned char
+		duration)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_QUIET_DURN__REG,
+			&data);
+	data = BMA222_SET_BITSLICE(data, BMA222_TAP_QUIET_DURN, duration);
+	comres = bma222_smbus_write_byte(client, BMA222_TAP_QUIET_DURN__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_get_tap_quiet(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_PARAM_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_TAP_QUIET_DURN);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_tap_threshold(struct i2c_client *client, unsigned char
+		threshold)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_THRES__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_TAP_THRES, threshold);
+	comres = bma222_smbus_write_byte(client, BMA222_TAP_THRES__REG, &data);
+
+	return comres;
+}
+
+static int bma222_get_tap_threshold(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_THRES_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_TAP_THRES);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_tap_samp(struct i2c_client *client, unsigned char samp)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_SAMPLES__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_TAP_SAMPLES, samp);
+	comres = bma222_smbus_write_byte(client, BMA222_TAP_SAMPLES__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_get_tap_samp(struct i2c_client *client, unsigned char *status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_TAP_THRES_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_TAP_SAMPLES);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_orient_mode(struct i2c_client *client, unsigned char mode)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_ORIENT_MODE__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_ORIENT_MODE, mode);
+	comres = bma222_smbus_write_byte(client, BMA222_ORIENT_MODE__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_get_orient_mode(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_ORIENT_PARAM_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_ORIENT_MODE);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_orient_blocking(struct i2c_client *client, unsigned char
+		samp)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_ORIENT_BLOCK__REG,
+			&data);
+	data = BMA222_SET_BITSLICE(data, BMA222_ORIENT_BLOCK, samp);
+	comres = bma222_smbus_write_byte(client, BMA222_ORIENT_BLOCK__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_get_orient_blocking(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_ORIENT_PARAM_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_ORIENT_BLOCK);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_orient_hyst(struct i2c_client *client, unsigned char
+		orienthyst)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_ORIENT_HYST__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_ORIENT_HYST, orienthyst);
+	comres = bma222_smbus_write_byte(client, BMA222_ORIENT_HYST__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_get_orient_hyst(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_ORIENT_PARAM_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_ORIENT_HYST);
+	*status = data;
+
+	return comres;
+}
+static int bma222_set_theta_blocking(struct i2c_client *client, unsigned char
+		thetablk)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_THETA_BLOCK__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_THETA_BLOCK, thetablk);
+	comres = bma222_smbus_write_byte(client, BMA222_THETA_BLOCK__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_get_theta_blocking(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_THETA_BLOCK_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_THETA_BLOCK);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_theta_flat(struct i2c_client *client, unsigned char
+		thetaflat)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_THETA_FLAT__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_THETA_FLAT, thetaflat);
+	comres = bma222_smbus_write_byte(client, BMA222_THETA_FLAT__REG, &data);
+
+	return comres;
+}
+
+static int bma222_get_theta_flat(struct i2c_client *client, unsigned char
+		*status)
+{
+	int comres = 0 ;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_THETA_FLAT_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_THETA_FLAT);
+	*status = data;
+
+	return comres;
+}
+
+static int bma222_set_flat_hold_time(struct i2c_client *client, unsigned char
+		holdtime)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_FLAT_HOLD_TIME__REG,
+			&data);
+	data = BMA222_SET_BITSLICE(data, BMA222_FLAT_HOLD_TIME, holdtime);
+	comres = bma222_smbus_write_byte(client, BMA222_FLAT_HOLD_TIME__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_get_flat_hold_time(struct i2c_client *client, unsigned char
+		*holdtime)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_FLAT_HOLD_TIME_REG,
+			&data);
+	data  = BMA222_GET_BITSLICE(data, BMA222_FLAT_HOLD_TIME);
+	*holdtime = data ;
+
+	return comres;
+}
+
+static int bma222_write_reg(struct i2c_client *client, unsigned char addr,
+		unsigned char *data)
+{
+	int comres = 0;
+	comres = bma222_smbus_write_byte(client, addr, data);
+
+	return comres;
+}
+
+
+static int bma222_set_offset_target_x(struct i2c_client *client, unsigned char
+		offsettarget)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_COMP_TARGET_OFFSET_X__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_COMP_TARGET_OFFSET_X,
+			offsettarget);
+	comres = bma222_smbus_write_byte(client,
+			BMA222_COMP_TARGET_OFFSET_X__REG, &data);
+
+	return comres;
+}
+
+static int bma222_get_offset_target_x(struct i2c_client *client, unsigned char
+		*offsettarget)
+{
+	int comres = 0 ;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_OFFSET_PARAMS_REG,
+			&data);
+	data = BMA222_GET_BITSLICE(data, BMA222_COMP_TARGET_OFFSET_X);
+	*offsettarget = data;
+
+	return comres;
+}
+
+static int bma222_set_offset_target_y(struct i2c_client *client, unsigned char
+		offsettarget)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_COMP_TARGET_OFFSET_Y__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_COMP_TARGET_OFFSET_Y,
+			offsettarget);
+	comres = bma222_smbus_write_byte(client,
+			BMA222_COMP_TARGET_OFFSET_Y__REG, &data);
+
+	return comres;
+}
+
+static int bma222_get_offset_target_y(struct i2c_client *client, unsigned char
+		*offsettarget)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_OFFSET_PARAMS_REG,
+			&data);
+	data = BMA222_GET_BITSLICE(data, BMA222_COMP_TARGET_OFFSET_Y);
+	*offsettarget = data;
+
+	return comres;
+}
+
+static int bma222_set_offset_target_z(struct i2c_client *client, unsigned char
+		offsettarget)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client,
+			BMA222_COMP_TARGET_OFFSET_Z__REG, &data);
+	data = BMA222_SET_BITSLICE(data, BMA222_COMP_TARGET_OFFSET_Z,
+			offsettarget);
+	comres = bma222_smbus_write_byte(client,
+			BMA222_COMP_TARGET_OFFSET_Z__REG, &data);
+
+	return comres;
+}
+
+static int bma222_get_offset_target_z(struct i2c_client *client, unsigned char
+		*offsettarget)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_OFFSET_PARAMS_REG,
+			&data);
+	data = BMA222_GET_BITSLICE(data, BMA222_COMP_TARGET_OFFSET_Z);
+	*offsettarget = data;
+
+	return comres;
+}
+
+static int bma222_get_cal_ready(struct i2c_client *client, unsigned char
+		*calrdy)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_OFFSET_CTRL_REG, &data);
+	data = BMA222_GET_BITSLICE(data, BMA222_FAST_COMP_RDY_S);
+	*calrdy = data;
+
+	return comres;
+}
+
+static int bma222_set_cal_trigger(struct i2c_client *client, unsigned char
+		caltrigger)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_EN_FAST_COMP__REG,
+			&data);
+	data = BMA222_SET_BITSLICE(data, BMA222_EN_FAST_COMP, caltrigger);
+	comres = bma222_smbus_write_byte(client, BMA222_EN_FAST_COMP__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_set_selftest_st(struct i2c_client *client, unsigned char
+		selftest)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_EN_SELF_TEST__REG,
+			&data);
+	data = BMA222_SET_BITSLICE(data, BMA222_EN_SELF_TEST, selftest);
+	comres = bma222_smbus_write_byte(client, BMA222_EN_SELF_TEST__REG,
+			&data);
+
+	return comres;
+}
+
+static int bma222_set_selftest_stn(struct i2c_client *client, unsigned char stn)
+{
+	int comres = 0;
+	unsigned char data;
+
+	comres = bma222_smbus_read_byte(client, BMA222_NEG_SELF_TEST__REG,
+			&data);
+	data = BMA222_SET_BITSLICE(data, BMA222_NEG_SELF_TEST, stn);
+	comres = bma222_smbus_write_byte(client, BMA222_NEG_SELF_TEST__REG,
+			&data);
+
+	return comres;
+}
+static int bma222_read_accel_xyz(struct i2c_client *client,
+		struct bma222acc *acc)
+{
+	int comres;
+	unsigned char data[6];
+
+	comres = bma222_smbus_read_byte_block(client, BMA222_ACC_X8_LSB__REG,
+			data, 6);
+	acc->x = BMA222_GET_BITSLICE(data[0], BMA222_ACC_X8_LSB)|
+		(BMA222_GET_BITSLICE(data[1],
+			BMA222_ACC_X_MSB)<<(BMA222_ACC_X8_LSB__LEN));
+	acc->x = acc->x << (sizeof(short)*8-(BMA222_ACC_X8_LSB__LEN +
+				BMA222_ACC_X_MSB__LEN));
+	acc->x = acc->x >> (sizeof(short)*8-(BMA222_ACC_X8_LSB__LEN +
+				BMA222_ACC_X_MSB__LEN));
+
+	acc->y = BMA222_GET_BITSLICE(data[2], BMA222_ACC_Y8_LSB)|
+		(BMA222_GET_BITSLICE(data[3],
+			BMA222_ACC_Y_MSB)<<(BMA222_ACC_Y8_LSB__LEN));
+	acc->y = acc->y << (sizeof(short)*8-(BMA222_ACC_Y8_LSB__LEN +
+				BMA222_ACC_Y_MSB__LEN));
+	acc->y = acc->y >> (sizeof(short)*8-(BMA222_ACC_Y8_LSB__LEN +
+				BMA222_ACC_Y_MSB__LEN));
+
+	acc->z = BMA222_GET_BITSLICE(data[4], BMA222_ACC_Z8_LSB)|
+		(BMA222_GET_BITSLICE(data[5],
+			BMA222_ACC_Z_MSB)<<(BMA222_ACC_Z8_LSB__LEN));
+	acc->z = acc->z << (sizeof(short)*8-(BMA222_ACC_Z8_LSB__LEN +
+				BMA222_ACC_Z_MSB__LEN));
+	acc->z = acc->z >> (sizeof(short)*8-(BMA222_ACC_Z8_LSB__LEN +
+				BMA222_ACC_Z_MSB__LEN));
+
+	return comres;
+}
+
+static int bma222_read_accel_x(struct i2c_client *client, short *a_x)
+{
+	int comres;
+	unsigned char data[2];
+
+	comres = bma222_smbus_read_byte_block(client, BMA222_ACC_X8_LSB__REG,
+			data, 2);
+	*a_x = BMA222_GET_BITSLICE(data[0], BMA222_ACC_X8_LSB)|
+		(BMA222_GET_BITSLICE(data[1],
+			BMA222_ACC_X_MSB)<<(BMA222_ACC_X8_LSB__LEN));
+	*a_x = *a_x << (sizeof(short)*8-(BMA222_ACC_X8_LSB__LEN +
+				BMA222_ACC_X_MSB__LEN));
+	*a_x = *a_x >> (sizeof(short)*8-(BMA222_ACC_X8_LSB__LEN +
+				BMA222_ACC_X_MSB__LEN));
+
+	return comres;
+}
+
+static int bma222_read_accel_y(struct i2c_client *client, short *a_y)
+{
+	int comres;
+	unsigned char data[2];
+
+	comres = bma222_smbus_read_byte_block(client, BMA222_ACC_Y8_LSB__REG,
+			data, 2);
+	*a_y = BMA222_GET_BITSLICE(data[0], BMA222_ACC_Y8_LSB)|
+		(BMA222_GET_BITSLICE(data[1],
+			BMA222_ACC_Y_MSB)<<(BMA222_ACC_Y8_LSB__LEN));
+	*a_y = *a_y << (sizeof(short)*8-(BMA222_ACC_Y8_LSB__LEN +
+				BMA222_ACC_Y_MSB__LEN));
+	*a_y = *a_y >> (sizeof(short)*8-(BMA222_ACC_Y8_LSB__LEN +
+				BMA222_ACC_Y_MSB__LEN));
+
+	return comres;
+}
+
+static int bma222_read_accel_z(struct i2c_client *client, short *a_z)
+{
+	int comres;
+	unsigned char data[2];
+
+	comres = bma222_smbus_read_byte_block(client, BMA222_ACC_Z8_LSB__REG,
+			data, 2);
+	*a_z = BMA222_GET_BITSLICE(data[0], BMA222_ACC_Z8_LSB)|
+		(BMA222_GET_BITSLICE(data[1],
+			BMA222_ACC_Z_MSB)<<(BMA222_ACC_Z8_LSB__LEN));
+	*a_z = *a_z << (sizeof(short)*8-(BMA222_ACC_Z8_LSB__LEN +
+				BMA222_ACC_Z_MSB__LEN));
+	*a_z = *a_z >> (sizeof(short)*8-(BMA222_ACC_Z8_LSB__LEN +
+				BMA222_ACC_Z_MSB__LEN));
+
+	return comres;
+}
+
+static int bma222_axis_remap(struct i2c_client *client,
+		struct bma222acc *acc)
+{
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    s16 swap;
+    int bma_position = atomic_read(&bma222->position);
+
+    if (bma_position > 0) {
+        acc->z = -(acc->z);
+        switch (bma_position) {
+            case 1:
+                break;
+            case 2:
+                swap = acc->x;
+                acc->x = acc->y;
+                acc->y = -swap;
+                break;
+            case 3:
+                acc->x = -(acc->x);
+                acc->y = -(acc->y);
+                break;
+            case 4:
+                swap = acc->x;
+                acc->x = -(acc->y);
+                acc->y = swap;
+                break;
+        }
+    } else if (bma_position < 0) {
+        switch (-bma_position) {
+            case 1:
+                acc->y = -(acc->y);
+                break;
+            case 2:
+                swap = acc->x;
+                acc->x = acc->y;
+                acc->y = swap;
+                break;
+            case 3:
+                acc->x = -(acc->x);
+                break;
+            case 4:
+                swap = acc->x;
+                acc->x = -(acc->y);
+                acc->y = -swap;
+                break;
+        }
+    }
+
+    return 0;
+}
+
+static void bma222_work_func(struct work_struct *work)
+{
+	struct bma222_data *bma222 = container_of((struct delayed_work *)work,
+			struct bma222_data, work);
+	static struct bma222acc acc;
+	unsigned long delay = msecs_to_jiffies(atomic_read(&bma222->delay));
+
+	bma222_read_accel_xyz(bma222->bma222_client, &acc);
+	bma222_axis_remap(bma222->bma222_client, &acc);
+	input_report_abs(bma222->input, ABS_X, acc.x);
+	input_report_abs(bma222->input, ABS_Y, acc.y);
+	input_report_abs(bma222->input, ABS_Z, acc.z);
+	input_sync(bma222->input);
+	mutex_lock(&bma222->value_mutex);
+	bma222->value = acc;
+	mutex_unlock(&bma222->value_mutex);
+	schedule_delayed_work(&bma222->work, delay);
+}
+
+
+static ssize_t bma222_register_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int address, value;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	sscanf(buf, "%d%d", &address, &value);
+
+	if (bma222_write_reg(bma222->bma222_client, (unsigned char)address,
+				(unsigned char *)&value) < 0)
+		return -EINVAL;
+
+	return count;
+}
+static ssize_t bma222_register_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	size_t count = 0;
+	u8 reg[0x3d];
+	int i;
+
+	for (i = 0 ; i < 0x3d; i++) {
+		bma222_smbus_read_byte(bma222->bma222_client, i, reg+i);
+
+		count += sprintf(&buf[count], "0x%x: %d\n", i, reg[i]);
+	}
+	return count;
+
+
+}
+static ssize_t bma222_range_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_range(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma222_range_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma222_set_range(bma222->bma222_client, (unsigned char) data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_bandwidth_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_bandwidth(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_bandwidth_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma222_set_bandwidth(bma222->bma222_client,
+				(unsigned char) data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_mode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_mode(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma222_mode_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma222_set_mode(bma222->bma222_client, (unsigned char) data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+
+static ssize_t bma222_value_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct input_dev *input = to_input_dev(dev);
+	struct bma222_data *bma222 = input_get_drvdata(input);
+	struct bma222acc acc_value;
+
+	mutex_lock(&bma222->value_mutex);
+	acc_value = bma222->value;
+	mutex_unlock(&bma222->value_mutex);
+
+	return sprintf(buf, "%d %d %d\n", acc_value.x, acc_value.y,
+			acc_value.z);
+}
+
+static ssize_t bma222_delay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d\n", atomic_read(&bma222->delay));
+
+}
+
+static ssize_t bma222_delay_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (data > BMA222_MAX_DELAY)
+		data = BMA222_MAX_DELAY;
+	atomic_set(&bma222->delay, (unsigned int) data);
+
+	return count;
+}
+
+
+static ssize_t bma222_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d\n", atomic_read(&bma222->enable));
+
+}
+
+static void bma222_set_enable(struct device *dev, int enable)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+	int pre_enable = atomic_read(&bma222->enable);
+
+	mutex_lock(&bma222->enable_mutex);
+	if (enable) {
+		if (pre_enable == 0) {
+			bma222_set_mode(bma222->bma222_client,
+					BMA222_MODE_NORMAL);
+			schedule_delayed_work(&bma222->work,
+				msecs_to_jiffies(atomic_read(&bma222->delay)));
+			atomic_set(&bma222->enable, 1);
+		}
+
+	} else {
+		if (pre_enable == 1) {
+			bma222_set_mode(bma222->bma222_client,
+					BMA222_MODE_SUSPEND);
+			cancel_delayed_work_sync(&bma222->work);
+			atomic_set(&bma222->enable, 0);
+		}
+	}
+	mutex_unlock(&bma222->enable_mutex);
+
+}
+
+static ssize_t bma222_enable_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if ((data == 0) || (data == 1))
+		bma222_set_enable(dev, data);
+
+	return count;
+}
+
+static ssize_t bma222_enable_int_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int type, value;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	sscanf(buf, "%d%d", &type, &value);
+
+	if (bma222_set_Int_Enable(bma222->bma222_client, type, value) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_int_mode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_Int_Mode(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma222_int_mode_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_Int_Mode(bma222->bma222_client, (unsigned char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+static ssize_t bma222_slope_duration_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_slope_duration(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_slope_duration_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_slope_duration(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_slope_threshold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_slope_threshold(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_slope_threshold_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma222_set_slope_threshold(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+static ssize_t bma222_high_g_duration_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_high_g_duration(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_high_g_duration_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_high_g_duration(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_high_g_threshold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_high_g_threshold(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_high_g_threshold_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma222_set_high_g_threshold(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_low_g_duration_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_low_g_duration(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_low_g_duration_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_low_g_duration(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_low_g_threshold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_low_g_threshold(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_low_g_threshold_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma222_set_low_g_threshold(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+static ssize_t bma222_tap_threshold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_tap_threshold(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_tap_threshold_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma222_set_tap_threshold(bma222->bma222_client, (unsigned char)data)
+			< 0)
+		return -EINVAL;
+
+	return count;
+}
+static ssize_t bma222_tap_duration_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_tap_duration(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_tap_duration_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_tap_duration(bma222->bma222_client, (unsigned char)data)
+			< 0)
+		return -EINVAL;
+
+	return count;
+}
+static ssize_t bma222_tap_quiet_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_tap_quiet(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_tap_quiet_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_tap_quiet(bma222->bma222_client, (unsigned char)data) <
+			0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_tap_shock_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_tap_shock(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_tap_shock_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_tap_shock(bma222->bma222_client, (unsigned char)data) <
+			0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_tap_samp_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_tap_samp(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_tap_samp_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_tap_samp(bma222->bma222_client, (unsigned char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_orient_mode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_orient_mode(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_orient_mode_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_orient_mode(bma222->bma222_client, (unsigned char)data) <
+			0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_orient_blocking_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_orient_blocking(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_orient_blocking_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_orient_blocking(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+static ssize_t bma222_orient_hyst_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_orient_hyst(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_orient_hyst_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_orient_hyst(bma222->bma222_client, (unsigned char)data) <
+			0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_orient_theta_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_theta_blocking(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_orient_theta_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_theta_blocking(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma222_flat_theta_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_theta_flat(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_flat_theta_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_theta_flat(bma222->bma222_client, (unsigned char)data) <
+			0)
+		return -EINVAL;
+
+	return count;
+}
+static ssize_t bma222_flat_hold_time_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_flat_hold_time(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_flat_hold_time_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_flat_hold_time(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+
+static ssize_t bma222_fast_calibration_x_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_offset_target_x(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_fast_calibration_x_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	signed char tmp;
+	unsigned char timeout = 0;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_offset_target_x(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	if (bma222_set_cal_trigger(bma222->bma222_client, 1) < 0)
+		return -EINVAL;
+
+	do {
+		mdelay(2);
+		bma222_get_cal_ready(bma222->bma222_client, &tmp);
+
+	/*	printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+		timeout++;
+		if (timeout == 50) {
+			printk(KERN_INFO "get fast calibration ready error\n");
+			return -EINVAL;
+		};
+
+	} while (tmp == 0);
+
+	printk(KERN_INFO "x axis fast calibration finished\n");
+	return count;
+}
+
+static ssize_t bma222_fast_calibration_y_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_offset_target_y(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_fast_calibration_y_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	signed char tmp;
+	unsigned char timeout = 0;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_offset_target_y(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	if (bma222_set_cal_trigger(bma222->bma222_client, 2) < 0)
+		return -EINVAL;
+
+	do {
+		mdelay(2);
+		bma222_get_cal_ready(bma222->bma222_client, &tmp);
+
+	/*	printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+		timeout++;
+		if (timeout == 50) {
+			printk(KERN_INFO "get fast calibration ready error\n");
+			return -EINVAL;
+		};
+
+	} while (tmp == 0);
+
+	printk(KERN_INFO "y axis fast calibration finished\n");
+	return count;
+}
+
+static ssize_t bma222_fast_calibration_z_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	if (bma222_get_offset_target_z(bma222->bma222_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_fast_calibration_z_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	signed char tmp;
+	unsigned char timeout = 0;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+	if (bma222_set_offset_target_z(bma222->bma222_client, (unsigned
+					char)data) < 0)
+		return -EINVAL;
+
+	if (bma222_set_cal_trigger(bma222->bma222_client, 3) < 0)
+		return -EINVAL;
+
+	do {
+		mdelay(2);
+		bma222_get_cal_ready(bma222->bma222_client, &tmp);
+
+	/*	printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+		timeout++;
+		if (timeout == 50) {
+			printk(KERN_INFO "get fast calibration ready error\n");
+			return -EINVAL;
+		};
+
+	} while (tmp == 0);
+
+	printk(KERN_INFO "z axis fast calibration finished\n");
+	return count;
+}
+
+static ssize_t bma222_selftest_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d\n", atomic_read(&bma222->selftest_result));
+
+}
+
+static ssize_t bma222_selftest_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	unsigned char clear_value = 0;
+	int error;
+	short value1 = 0;
+	short value2 = 0;
+	short diff = 0;
+	unsigned long result = 0;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+
+
+	if (data != 1)
+		return -EINVAL;
+	/* set to 2 G range */
+	if (bma222_set_range(bma222->bma222_client, 0) < 0)
+		return -EINVAL;
+
+	bma222_write_reg(bma222->bma222_client, 0x32, &clear_value);
+
+	bma222_set_selftest_st(bma222->bma222_client, 1); /* 1 for x-axis*/
+	bma222_set_selftest_stn(bma222->bma222_client, 0); /* positive
+							      direction*/
+	mdelay(10);
+	bma222_read_accel_x(bma222->bma222_client, &value1);
+	bma222_set_selftest_stn(bma222->bma222_client, 1); /* negative
+							      direction*/
+	mdelay(10);
+	bma222_read_accel_x(bma222->bma222_client, &value2);
+	diff = value1-value2;
+
+	printk(KERN_INFO "diff x is %d,value1 is %d, value2 is %d\n", diff,
+			value1, value2);
+
+	if (abs(diff) < 51)
+		result |= 1;
+
+	bma222_set_selftest_st(bma222->bma222_client, 2); /* 2 for y-axis*/
+	bma222_set_selftest_stn(bma222->bma222_client, 0); /* positive
+							      direction*/
+	mdelay(10);
+	bma222_read_accel_y(bma222->bma222_client, &value1);
+	bma222_set_selftest_stn(bma222->bma222_client, 1); /* negative
+							      direction*/
+	mdelay(10);
+	bma222_read_accel_y(bma222->bma222_client, &value2);
+	diff = value1-value2;
+	printk(KERN_INFO "diff y is %d,value1 is %d, value2 is %d\n", diff,
+			value1, value2);
+	if (abs(diff) < 51)
+		result |= 2;
+
+
+	bma222_set_selftest_st(bma222->bma222_client, 3); /* 3 for z-axis*/
+	bma222_set_selftest_stn(bma222->bma222_client, 0); /* positive
+							      direction*/
+	mdelay(10);
+	bma222_read_accel_z(bma222->bma222_client, &value1);
+	bma222_set_selftest_stn(bma222->bma222_client, 1); /* negative
+							      direction*/
+	mdelay(10);
+	bma222_read_accel_z(bma222->bma222_client, &value2);
+	diff = value1-value2;
+
+	printk(KERN_INFO "diff z is %d,value1 is %d, value2 is %d\n", diff,
+			value1, value2);
+	if (abs(diff) < 25)
+		result |= 4;
+
+	atomic_set(&bma222->selftest_result, (unsigned int) result);
+
+	printk(KERN_INFO "self test finished\n");
+
+
+	return count;
+}
+
+#define BMA222_OFFSET_CTRL_REG                  0x36
+#define BMA222_OFFSET_PARAMS_REG                0x37
+#define BMA222_RESET_FAST_COMP__POS                7
+#define BMA222_RESET_FAST_COMP__LEN                1
+#define BMA222_RESET_FAST_COMP__MSK                0x80
+#define BMA222_RESET_FAST_COMP__REG                BMA222_OFFSET_CTRL_REG
+
+static int bma222_reset_cal_offset(struct i2c_client *client)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma222_smbus_read_byte(client, BMA222_RESET_FAST_COMP__REG,
+            &data);
+    data = BMA222_SET_BITSLICE(data, BMA222_RESET_FAST_COMP, 1);
+    comres = bma222_smbus_write_byte(client, BMA222_RESET_FAST_COMP__REG,
+            &data);
+
+    return comres;
+}
+static int bma222_set_offset_filt_xyz(struct i2c_client *client, unsigned char
+        *offset, int len)
+{
+    int comres = 0;
+
+    comres = bma222_smbus_write_byte_block(client, BMA222_OFFSET_FILT_X_REG, offset, len);
+        
+    return comres;
+}
+
+static int bma222_get_offset_filt_xyz(struct i2c_client *client, unsigned char
+        *offset, int len)
+{
+    int comres = 0 ;
+
+    comres = bma222_smbus_read_byte_block(client, BMA222_OFFSET_FILT_X_REG,    offset, len);
+
+    return comres;
+}
+
+static ssize_t bma222_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    int bma_position = atomic_read(&bma222->position);
+    
+    bma222_fast_calibration_x_store(dev, attr, "0", 2);
+    bma222_fast_calibration_y_store(dev, attr, "0", 2);
+    if (bma_position > 0) {
+        bma222_fast_calibration_z_store(dev, attr, "1", 2); // z: +g
+    } else {
+        bma222_fast_calibration_z_store(dev, attr, "2", 2); // z: -g
+    }
+
+    if (bma222_get_offset_filt_xyz(bma222->bma222_client, offset, sizeof(offset)) < 0)
+        return sprintf((char*)buf, "Read error\n");
+    
+    cfg_calibration[0] = offset[0];
+    cfg_calibration[1] = offset[1];
+    cfg_calibration[2] = offset[2];
+    
+    printk(KERN_INFO "run fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma222_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    
+    bma222_reset_cal_offset(bma222->bma222_client);
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+
+    printk(KERN_INFO "reset fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma222_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    if (bma222_get_offset_filt_xyz(bma222->bma222_client, offset, sizeof(offset)) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d %d %d\n", offset[0], offset[1], offset[2]);
+}
+
+static ssize_t bma222_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[3];
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    sscanf(buf, "%d %d %d", &data[0], &data[1], &data[2]);
+    offset[0] = (unsigned char) data[0];
+    offset[1] = (unsigned char) data[1];
+    offset[2] = (unsigned char) data[2];
+    
+    if (bma222_set_offset_filt_xyz(bma222->bma222_client, offset, sizeof(offset)) < 0)
+        return -EINVAL;
+
+    printk(KERN_INFO "set fast calibration finished\n");
+    return count;
+}
+
+static DEVICE_ATTR(range, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_range_show, bma222_range_store);
+static DEVICE_ATTR(bandwidth, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_bandwidth_show, bma222_bandwidth_store);
+static DEVICE_ATTR(mode, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_mode_show, bma222_mode_store);
+static DEVICE_ATTR(value, S_IRUGO,
+		bma222_value_show, NULL);
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_delay_show, bma222_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_enable_show, bma222_enable_store);
+static DEVICE_ATTR(enable_int, S_IWUSR|S_IWGRP|S_IWOTH,
+		NULL, bma222_enable_int_store);
+static DEVICE_ATTR(int_mode, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_int_mode_show, bma222_int_mode_store);
+static DEVICE_ATTR(slope_duration, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_slope_duration_show, bma222_slope_duration_store);
+static DEVICE_ATTR(slope_threshold, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_slope_threshold_show, bma222_slope_threshold_store);
+static DEVICE_ATTR(high_g_duration, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_high_g_duration_show, bma222_high_g_duration_store);
+static DEVICE_ATTR(high_g_threshold, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_high_g_threshold_show, bma222_high_g_threshold_store);
+static DEVICE_ATTR(low_g_duration, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_low_g_duration_show, bma222_low_g_duration_store);
+static DEVICE_ATTR(low_g_threshold, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_low_g_threshold_show, bma222_low_g_threshold_store);
+static DEVICE_ATTR(tap_duration, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_tap_duration_show, bma222_tap_duration_store);
+static DEVICE_ATTR(tap_threshold, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_tap_threshold_show, bma222_tap_threshold_store);
+static DEVICE_ATTR(tap_quiet, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_tap_quiet_show, bma222_tap_quiet_store);
+static DEVICE_ATTR(tap_shock, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_tap_shock_show, bma222_tap_shock_store);
+static DEVICE_ATTR(tap_samp, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_tap_samp_show, bma222_tap_samp_store);
+static DEVICE_ATTR(orient_mode, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_orient_mode_show, bma222_orient_mode_store);
+static DEVICE_ATTR(orient_blocking, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_orient_blocking_show, bma222_orient_blocking_store);
+static DEVICE_ATTR(orient_hyst, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_orient_hyst_show, bma222_orient_hyst_store);
+static DEVICE_ATTR(orient_theta, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_orient_theta_show, bma222_orient_theta_store);
+static DEVICE_ATTR(flat_theta, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_flat_theta_show, bma222_flat_theta_store);
+static DEVICE_ATTR(flat_hold_time, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_flat_hold_time_show, bma222_flat_hold_time_store);
+static DEVICE_ATTR(reg, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_register_show, bma222_register_store);
+static DEVICE_ATTR(fast_calibration_x, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_fast_calibration_x_show,
+		bma222_fast_calibration_x_store);
+static DEVICE_ATTR(fast_calibration_y, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_fast_calibration_y_show,
+		bma222_fast_calibration_y_store);
+static DEVICE_ATTR(fast_calibration_z, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_fast_calibration_z_show,
+		bma222_fast_calibration_z_store);
+static DEVICE_ATTR(selftest, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma222_selftest_show, bma222_selftest_store);
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, bma222_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, bma222_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma222_calibration_value_show, bma222_calibration_value_store);
+
+static struct attribute *bma222_attributes[] = {
+	&dev_attr_range.attr,
+	&dev_attr_bandwidth.attr,
+	&dev_attr_mode.attr,
+	&dev_attr_value.attr,
+	&dev_attr_delay.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_enable_int.attr,
+	&dev_attr_int_mode.attr,
+	&dev_attr_slope_duration.attr,
+	&dev_attr_slope_threshold.attr,
+	&dev_attr_high_g_duration.attr,
+	&dev_attr_high_g_threshold.attr,
+	&dev_attr_low_g_duration.attr,
+	&dev_attr_low_g_threshold.attr,
+	&dev_attr_tap_threshold.attr,
+	&dev_attr_tap_duration.attr,
+	&dev_attr_tap_quiet.attr,
+	&dev_attr_tap_shock.attr,
+	&dev_attr_tap_samp.attr,
+	&dev_attr_orient_mode.attr,
+	&dev_attr_orient_blocking.attr,
+	&dev_attr_orient_hyst.attr,
+	&dev_attr_orient_theta.attr,
+	&dev_attr_flat_theta.attr,
+	&dev_attr_flat_hold_time.attr,
+	&dev_attr_reg.attr,
+	&dev_attr_fast_calibration_x.attr,
+	&dev_attr_fast_calibration_y.attr,
+	&dev_attr_fast_calibration_z.attr,
+    &dev_attr_calibration_run.attr,
+    &dev_attr_calibration_reset.attr,
+    &dev_attr_calibration_value.attr,
+	&dev_attr_selftest.attr,
+	NULL
+};
+
+static struct attribute_group bma222_attribute_group = {
+	.attrs = bma222_attributes
+};
+
+
+#if defined(BMA222_ENABLE_INT1) || defined(BMA222_ENABLE_INT2)
+unsigned char *orient[] = {"upward looking portrait upright",   \
+	"upward looking portrait upside-down",   \
+		"upward looking landscape left",   \
+		"upward looking landscape right",   \
+		"downward looking portrait upright",   \
+		"downward looking portrait upside-down",   \
+		"downward looking landscape left",   \
+		"downward looking landscape right"};
+
+static void bma222_irq_work_func(struct work_struct *work)
+{
+	struct bma222_data *bma222 = container_of((struct work_struct *)work,
+			struct bma222_data, irq_work);
+
+	unsigned char status = 0;
+	unsigned char i;
+	unsigned char first_value = 0;
+	unsigned char sign_value = 0;
+
+	bma222_get_interruptstatus1(bma222->bma222_client, &status);
+
+	switch (status) {
+
+	case 0x01:
+		printk(KERN_INFO "Low G interrupt happened\n");
+		input_report_rel(bma222->input, LOW_G_INTERRUPT,
+				LOW_G_INTERRUPT_HAPPENED);
+		break;
+	case 0x02:
+		for (i = 0; i < 3; i++) {
+			bma222_get_HIGH_first(bma222->bma222_client, i,
+					   &first_value);
+			if (first_value == 1) {
+
+				bma222_get_HIGH_sign(bma222->bma222_client,
+						   &sign_value);
+
+				if (sign_value == 1) {
+					if (i == 0)
+						input_report_rel(bma222->input,
+						HIGH_G_INTERRUPT,
+					HIGH_G_INTERRUPT_X_NEGATIVE_HAPPENED);
+					if (i == 1)
+						input_report_rel(bma222->input,
+						HIGH_G_INTERRUPT,
+					HIGH_G_INTERRUPT_Y_NEGATIVE_HAPPENED);
+					if (i == 2)
+						input_report_rel(bma222->input,
+						HIGH_G_INTERRUPT,
+					HIGH_G_INTERRUPT_Z_NEGATIVE_HAPPENED);
+				} else {
+					if (i == 0)
+						input_report_rel(bma222->input,
+						HIGH_G_INTERRUPT,
+					HIGH_G_INTERRUPT_X_HAPPENED);
+					if (i == 1)
+						input_report_rel(bma222->input,
+						HIGH_G_INTERRUPT,
+					HIGH_G_INTERRUPT_Y_HAPPENED);
+					if (i == 2)
+						input_report_rel(bma222->input,
+						HIGH_G_INTERRUPT,
+					HIGH_G_INTERRUPT_Z_HAPPENED);
+
+				}
+			   }
+
+		      printk(KERN_INFO "High G interrupt happened,exis is %d,"
+				      "first is %d,sign is %d\n", i,
+					   first_value, sign_value);
+		}
+		   break;
+	case 0x04:
+		for (i = 0; i < 3; i++) {
+			bma222_get_slope_first(bma222->bma222_client, i,
+					   &first_value);
+			if (first_value == 1) {
+
+				bma222_get_slope_sign(bma222->bma222_client,
+						   &sign_value);
+
+				if (sign_value == 1) {
+					if (i == 0)
+						input_report_rel(bma222->input,
+						SLOP_INTERRUPT,
+					SLOPE_INTERRUPT_X_NEGATIVE_HAPPENED);
+					else if (i == 1)
+						input_report_rel(bma222->input,
+						SLOP_INTERRUPT,
+					SLOPE_INTERRUPT_Y_NEGATIVE_HAPPENED);
+					else if (i == 2)
+						input_report_rel(bma222->input,
+						SLOP_INTERRUPT,
+					SLOPE_INTERRUPT_Z_NEGATIVE_HAPPENED);
+				} else {
+					if (i == 0)
+						input_report_rel(bma222->input,
+								SLOP_INTERRUPT,
+						SLOPE_INTERRUPT_X_HAPPENED);
+					else if (i == 1)
+						input_report_rel(bma222->input,
+								SLOP_INTERRUPT,
+						SLOPE_INTERRUPT_Y_HAPPENED);
+					else if (i == 2)
+						input_report_rel(bma222->input,
+								SLOP_INTERRUPT,
+						SLOPE_INTERRUPT_Z_HAPPENED);
+
+				}
+			}
+
+			printk(KERN_INFO "Slop interrupt happened,exis is %d,"
+					"first is %d,sign is %d\n", i,
+					first_value, sign_value);
+		}
+		break;
+
+	case 0x10:
+		printk(KERN_INFO "double tap interrupt happened\n");
+		input_report_rel(bma222->input, DOUBLE_TAP_INTERRUPT,
+					DOUBLE_TAP_INTERRUPT_HAPPENED);
+		break;
+	case 0x20:
+		printk(KERN_INFO "single tap interrupt happened\n");
+		input_report_rel(bma222->input, SINGLE_TAP_INTERRUPT,
+					SINGLE_TAP_INTERRUPT_HAPPENED);
+		break;
+	case 0x40:
+		bma222_get_orient_status(bma222->bma222_client,
+				    &first_value);
+		printk(KERN_INFO "orient interrupt happened,%s\n",
+				orient[first_value]);
+		if (first_value == 0)
+			input_report_abs(bma222->input, ORIENT_INTERRUPT,
+				UPWARD_PORTRAIT_UP_INTERRUPT_HAPPENED);
+		else if (first_value == 1)
+			input_report_abs(bma222->input, ORIENT_INTERRUPT,
+				UPWARD_PORTRAIT_DOWN_INTERRUPT_HAPPENED);
+		else if (first_value == 2)
+			input_report_abs(bma222->input, ORIENT_INTERRUPT,
+				UPWARD_LANDSCAPE_LEFT_INTERRUPT_HAPPENED);
+		else if (first_value == 3)
+			input_report_abs(bma222->input, ORIENT_INTERRUPT,
+				UPWARD_LANDSCAPE_RIGHT_INTERRUPT_HAPPENED);
+		else if (first_value == 4)
+			input_report_abs(bma222->input, ORIENT_INTERRUPT,
+				DOWNWARD_PORTRAIT_UP_INTERRUPT_HAPPENED);
+		else if (first_value == 5)
+			input_report_abs(bma222->input, ORIENT_INTERRUPT,
+				DOWNWARD_PORTRAIT_DOWN_INTERRUPT_HAPPENED);
+		else if (first_value == 6)
+			input_report_abs(bma222->input, ORIENT_INTERRUPT,
+				DOWNWARD_LANDSCAPE_LEFT_INTERRUPT_HAPPENED);
+		else if (first_value == 7)
+			input_report_abs(bma222->input, ORIENT_INTERRUPT,
+				DOWNWARD_LANDSCAPE_RIGHT_INTERRUPT_HAPPENED);
+		break;
+	case 0x80:
+		bma222_get_orient_flat_status(bma222->bma222_client,
+				    &sign_value);
+		printk(KERN_INFO "flat interrupt happened,flat status is %d\n",
+				    sign_value);
+		if (sign_value == 1) {
+			input_report_abs(bma222->input, FLAT_INTERRUPT,
+				FLAT_INTERRUPT_TURE_HAPPENED);
+		} else {
+			input_report_abs(bma222->input, FLAT_INTERRUPT,
+				FLAT_INTERRUPT_FALSE_HAPPENED);
+		}
+		break;
+	default:
+		break;
+	}
+
+}
+
+static irqreturn_t bma222_irq_handler(int irq, void *handle)
+{
+
+
+	struct bma222_data *data = handle;
+
+
+	if (data == NULL)
+		return IRQ_HANDLED;
+	if (data->bma222_client == NULL)
+		return IRQ_HANDLED;
+
+
+	schedule_work(&data->irq_work);
+
+	return IRQ_HANDLED;
+
+
+}
+
+
+#endif /* defined(BMA222_ENABLE_INT1)||defined(BMA222_ENABLE_INT2) */
+struct i2c_client *bmaclient;
+void bma222_position_release(struct kobject *kobject);
+ssize_t bma222_position_show(struct kobject *kobject, struct attribute *attr,char *buf);
+ssize_t bma222_position_store(struct kobject *kobject,struct attribute *attr,const char *buf, size_t count);
+
+/*
+ * module function
+ */
+struct attribute b222_position_attr = {
+	.name = "position",
+	.mode = S_IRUGO | S_IWUGO,
+};
+
+struct attribute b222_gtype_attr = {
+	.name = "gtype",
+	.mode =  S_IRUGO,
+};
+
+
+static struct attribute *def_attrs[] = {
+	&b222_position_attr,
+	&b222_gtype_attr,
+	NULL,
+};
+
+struct sysfs_ops bma222_position_sysops =
+{
+	.show = bma222_position_show,
+	.store = bma222_position_store,
+};
+
+struct kobj_type bma222_ktype =
+{
+	.release = bma222_position_release,
+	.sysfs_ops=&bma222_position_sysops,
+	.default_attrs=def_attrs,
+};
+
+void bma222_position_release(struct kobject *kobject)
+{
+	printk("eric_test: release .\n");
+}
+
+ssize_t bma222_position_show(struct kobject *kobject, struct attribute *attr,char *buf)
+{
+	char show_buf[10];
+	if (attr->name=="position")
+	{
+		struct bma222_data *bma222 = i2c_get_clientdata(bmaclient);
+		sprintf(buf,"%d\n",bma222->position);
+	}
+	else if (attr->name=="gtype")
+		sprintf(buf,"%s\n","bma222");
+	return strlen(buf)+2;
+}
+
+ssize_t bma222_position_store(struct kobject *kobject,struct attribute *attr,const char *buf, size_t count)
+{
+	if (attr->name=="position")
+	{
+		signed long tmp;
+		strict_strtol(buf, 10, &tmp);
+		if (tmp<-4 || tmp>4)
+		{
+			printk("Write Error:less than 1 or more than 8!\n");
+			return count;
+		}
+		else
+		{
+			int error;
+			struct bma222_data *bma222 = i2c_get_clientdata(bmaclient);
+			atomic_set(&(bma222->position), (int) tmp);
+			return count;
+		}
+
+	}
+}
+struct kobject bma222_kobj;
+int cfg_position;
+static int bma222_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int err = 0;
+	unsigned char tempvalue;
+	struct bma222_data *data;
+	struct input_dev *dev;
+	bmaclient=client;
+	//omap_mux_init_gpio(145, OMAP_PIN_INPUT);
+	//omap_mux_init_gpio(146, OMAP_PIN_INPUT);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_INFO "i2c_check_functionality error\n");
+		goto exit;
+	}
+	data = kzalloc(sizeof(struct bma222_data), GFP_KERNEL);
+	if (!data) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	/* read chip id */
+	tempvalue = i2c_smbus_read_byte_data(client, BMA222_CHIP_ID_REG);
+
+	if (tempvalue == BMA222_CHIP_ID) {
+		printk(KERN_INFO "Bosch Sensortec Device detected!\n"
+				"BMA222 registered I2C driver!\n");
+	} else{
+		printk(KERN_INFO "Bosch Sensortec Device not found"
+				"i2c error %d \n", tempvalue);
+		err = -ENODEV;
+		goto kfree_exit;
+	}
+	i2c_set_clientdata(client, data);
+	data->bma222_client = client;
+	mutex_init(&data->value_mutex);
+	mutex_init(&data->mode_mutex);
+	mutex_init(&data->enable_mutex);
+	bma222_set_bandwidth(client, BMA222_BW_SET);
+	bma222_set_range(client, BMA222_RANGE_SET);
+	cfg_position=gsensor_dt_position(SENSOR_NAME,client);
+	atomic_set(&data->position, cfg_position);
+#if defined(BMA222_ENABLE_INT1) || defined(BMA222_ENABLE_INT2)
+	bma222_set_Int_Mode(client, 1);/*latch interrupt 250ms*/
+#endif
+	/*8,single tap
+	  10,orient
+	  11,flat*/
+/*	bma222_set_Int_Enable(client,8, 1);
+	bma222_set_Int_Enable(client,10, 1);
+	bma222_set_Int_Enable(client,11, 1);
+*/
+#ifdef BMA222_ENABLE_INT1
+	/* maps interrupt to INT1 pin */
+	bma222_set_int1_pad_sel(client, PAD_LOWG);
+	bma222_set_int1_pad_sel(client, PAD_HIGHG);
+	bma222_set_int1_pad_sel(client, PAD_SLOP);
+	bma222_set_int1_pad_sel(client, PAD_DOUBLE_TAP);
+	bma222_set_int1_pad_sel(client, PAD_SINGLE_TAP);
+	bma222_set_int1_pad_sel(client, PAD_ORIENT);
+	bma222_set_int1_pad_sel(client, PAD_FLAT);
+#endif
+
+#ifdef BMA222_ENABLE_INT2
+	/* maps interrupt to INT2 pin */
+	bma222_set_int2_pad_sel(client, PAD_LOWG);
+	bma222_set_int2_pad_sel(client, PAD_HIGHG);
+	bma222_set_int2_pad_sel(client, PAD_SLOP);
+	bma222_set_int2_pad_sel(client, PAD_DOUBLE_TAP);
+	bma222_set_int2_pad_sel(client, PAD_SINGLE_TAP);
+	bma222_set_int2_pad_sel(client, PAD_ORIENT);
+	bma222_set_int2_pad_sel(client, PAD_FLAT);
+#endif
+
+#if defined(BMA222_ENABLE_INT1) || defined(BMA222_ENABLE_INT2)
+	data->IRQ = BMA222_IRQ;
+	err = request_irq(data->IRQ, bma222_irq_handler, IRQF_TRIGGER_RISING,
+			"bma222", data);
+	if (err)
+		printk(KERN_ERR "could not request irq\n");
+
+	INIT_WORK(&data->irq_work, bma222_irq_work_func);
+#endif
+
+	INIT_DELAYED_WORK(&data->work, bma222_work_func);
+	atomic_set(&data->delay, BMA222_MAX_DELAY);
+	atomic_set(&data->enable, 0);
+
+	dev = input_allocate_device();
+	if (!dev)
+		return -ENOMEM;
+	dev->name = SENSOR_NAME;
+	dev->id.bustype = BUS_I2C;
+
+	input_set_capability(dev, EV_REL, LOW_G_INTERRUPT);
+	input_set_capability(dev, EV_REL, HIGH_G_INTERRUPT);
+	input_set_capability(dev, EV_REL, SLOP_INTERRUPT);
+	input_set_capability(dev, EV_REL, DOUBLE_TAP_INTERRUPT);
+	input_set_capability(dev, EV_REL, SINGLE_TAP_INTERRUPT);
+	input_set_capability(dev, EV_ABS, ORIENT_INTERRUPT);
+	input_set_capability(dev, EV_ABS, FLAT_INTERRUPT);
+	input_set_abs_params(dev, ABS_X, ABSMIN, ABSMAX, 0, 0);
+	input_set_abs_params(dev, ABS_Y, ABSMIN, ABSMAX, 0, 0);
+	input_set_abs_params(dev, ABS_Z, ABSMIN, ABSMAX, 0, 0);
+
+	input_set_drvdata(dev, data);
+
+	err = input_register_device(dev);
+	if (err < 0) {
+		input_free_device(dev);
+		goto kfree_exit;
+	}
+
+	data->input = dev;
+
+	err = sysfs_create_group(&data->input->dev.kobj,
+			&bma222_attribute_group);
+	if (err < 0)
+		goto error_sysfs;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	data->early_suspend.suspend = bma222_early_suspend;
+	data->early_suspend.resume = bma222_late_resume;
+	register_early_suspend(&data->early_suspend);
+#endif
+
+	mutex_init(&data->value_mutex);
+	mutex_init(&data->mode_mutex);
+	mutex_init(&data->enable_mutex);
+	kobject_init_and_add(&bma222_kobj,&bma222_ktype,NULL,"gsensor");
+
+	return 0;
+
+error_sysfs:
+	input_unregister_device(data->input);
+
+kfree_exit:
+	kfree(data);
+exit:
+	return err;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma222_early_suspend(struct early_suspend *h)
+{
+	struct bma222_data *data =
+		container_of(h, struct bma222_data, early_suspend);
+
+	mutex_lock(&data->enable_mutex);
+	if (atomic_read(&data->enable) == 1) {
+		//bma222_set_mode(data->bma222_client, BMA222_MODE_SUSPEND);
+		cancel_delayed_work_sync(&data->work);
+	}
+	mutex_unlock(&data->enable_mutex);
+}
+
+
+static void bma222_late_resume(struct early_suspend *h)
+{
+	struct bma222_data *data =
+		container_of(h, struct bma222_data, early_suspend);
+
+	mutex_lock(&data->enable_mutex);
+	if (atomic_read(&data->enable) == 1) {
+		//bma222_set_mode(data->bma222_client, BMA222_MODE_NORMAL);
+		schedule_delayed_work(&data->work,
+				msecs_to_jiffies(atomic_read(&data->delay)));
+	}
+	mutex_unlock(&data->enable_mutex);
+}
+#endif
+
+static int bma222_remove(struct i2c_client *client)
+{
+	struct bma222_data *data = i2c_get_clientdata(client);
+
+	bma222_set_enable(&client->dev, 0);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&data->early_suspend);
+#endif
+	sysfs_remove_group(&data->input->dev.kobj, &bma222_attribute_group);
+	input_unregister_device(data->input);
+	kfree(data);
+
+	return 0;
+}
+#ifdef CONFIG_PM
+
+static int bma222_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct bma222_data *data = i2c_get_clientdata(client);
+
+	mutex_lock(&data->enable_mutex);
+	if (atomic_read(&data->enable) == 1) {
+		//bma222_set_mode(data->bma222_client, BMA222_MODE_SUSPEND);
+		cancel_delayed_work_sync(&data->work);
+	}
+	mutex_unlock(&data->enable_mutex);
+
+	return 0;
+}
+
+static int bma222_resume(struct i2c_client *client)
+{
+	struct bma222_data *data = i2c_get_clientdata(client);
+
+	mutex_lock(&data->enable_mutex);
+	if (atomic_read(&data->enable) == 1) {
+		//bma222_set_mode(data->bma222_client, BMA222_MODE_NORMAL);
+		schedule_delayed_work(&data->work,
+				msecs_to_jiffies(atomic_read(&data->delay)));
+	}
+	mutex_unlock(&data->enable_mutex);
+
+	return 0;
+}
+
+#else
+
+#define bma222_suspend		NULL
+#define bma222_resume		NULL
+
+#endif /* CONFIG_PM */
+static const unsigned short  bma222_addresses[] = {
+    0x18,
+    I2C_CLIENT_END,
+};
+static int bma222_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+  struct i2c_adapter *adapter = client->adapter;
+
+  if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+    return -ENODEV;
+  strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+
+  return 0;
+}
+
+
+static const struct i2c_device_id bma222_id[] = {
+	{ SENSOR_NAME, 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, bma222_id);
+
+static struct i2c_driver bma222_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= SENSOR_NAME,
+	},
+	.suspend	= bma222_suspend,
+	.resume		= bma222_resume,
+	.id_table	= bma222_id,
+	.address_list    = bma222_addresses,
+	.detect = bma222_detect,
+	.probe		= bma222_probe,
+	.remove		= bma222_remove,
+};
+
+
+static struct i2c_board_info gsensor_info = {    .type	= SENSOR_NAME,    .addr	= 0x08,};
+
+static int __init BMA222_init(void)
+{
+    int ret;
+
+    ret=i2c_add_driver(&bma222_driver);
+
+    return ret;
+
+}
+
+static void __exit BMA222_exit(void)
+{
+	i2c_del_driver(&bma222_driver);
+}
+
+MODULE_AUTHOR("Albert Zhang <xu.zhang@bosch-sensortec.com>");
+MODULE_DESCRIPTION("BMA222 accelerometer sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(BMA222_init);
+module_exit(BMA222_exit);
+
diff --git a/drivers/input/misc/gsensor/Kconfig b/drivers/input/misc/gsensor/Kconfig
new file mode 100755
index 0000000..5ca97ae
--- /dev/null
+++ b/drivers/input/misc/gsensor/Kconfig
@@ -0,0 +1,105 @@
+#
+# Input misc drivers configuration
+#
+menuconfig INPUT_GSENSOR
+	bool "Actions Gsensor devices"
+	help
+	  Say Y here, and a list of miscellaneous input drivers will be displayed.
+	  Everything that didn't fit into the other categories is here. This option
+	  doesn't affect the kernel.
+
+	  If unsure, say Y.
+
+if INPUT_GSENSOR
+
+config GSENSOR_DETECT
+	tristate "gsensor_detect support"
+	depends on I2C
+	help
+	  Support the gsensor auto detect as an input device
+	  detect the gsesnor automatically.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called gsensor_detect.
+
+config GSENSOR_BMA222
+	tristate "bma222 support"
+	depends on I2C
+	help
+	  Support the bma222 as an input device
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called bma222.
+	  
+config GSENSOR_STK8312
+	tristate "stk8312 support"
+	depends on I2C
+	help
+	  Support the stk8312 as an input device
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called stk8312.
+	  
+config GSENSOR_STK8313
+	tristate "stk8313 support"
+	depends on I2C
+	help
+	  Support the stk8313 as an input device
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called stk8313.
+	  
+config GSENSOR_MC3236
+	tristate "mc3236 support"
+	depends on I2C
+	help
+	  Support the mc3236 as an input device
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called bma250_dummy.
+	  
+config GSENSOR_MC3230
+	tristate "mc3230 support"
+	depends on I2C
+	help
+	  Support the mc3230 as an input device
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called bma250_dummy.
+	  
+config GSENSOR_MC3232
+	tristate "mc3232 support"
+	depends on I2C
+	help
+	  Support the mc3232 as an input device
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called mc3232.
+	  
+config GSENSOR_MMA7660
+	tristate "mma7660 support"
+	depends on I2C
+	help
+	  Support the mma7660 as an input device
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called mma7660.
+	  
+config GSENSOR_KIONIX
+       tristate "kionix support"
+       depends on I2C
+       help
+         Support the kionix as an input device
+
+         To compile this driver as a module, choose M here: the module
+         will be called kionix.
+
+config GSENSOR_MIR3DA
+	tristate "mir3da support"
+	depends on I2C
+	help
+	  Support the mir3da as an input device
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called mir3da.
+endif
diff --git a/drivers/input/misc/gsensor/Makefile b/drivers/input/misc/gsensor/Makefile
new file mode 100755
index 0000000..c003a27
--- /dev/null
+++ b/drivers/input/misc/gsensor/Makefile
@@ -0,0 +1,26 @@
+#
+# Makefile for the gsensor drivers
+#
+
+obj-$(CONFIG_GSENSOR_BMA250_DUMMY)    += gsensor_bma250_dummy.o
+gsensor_bma250_dummy-objs := bma250_dummy.o
+obj-$(CONFIG_GSENSOR_BMA220)		  += gsensor_bma220.o
+gsensor_bma220-objs := bma220.o
+obj-$(CONFIG_GSENSOR_BMA222)		  += gsensor_bma222.o
+gsensor_bma222-objs := bma222.o
+obj-$(CONFIG_GSENSOR_BMA250)		  += gsensor_bma250.o
+gsensor_bma250-objs := bma250.o
+obj-$(CONFIG_GSENSOR_MC3210)		  += gsensor_mc3210.o
+gsensor_mc3210-objs := mc3210.o
+obj-$(CONFIG_GSENSOR_MC3230)		  += gsensor_mc3230.o
+gsensor_mc3230-objs := mc3230.o
+obj-$(CONFIG_GSENSOR_MC3232)		  += gsensor_mc3232.o
+gsensor_mc3232-objs := mc3232.o
+obj-$(CONFIG_GSENSOR_MC3236)		  += gsensor_mc3236.o
+gsensor_mc3236-objs := mc3236.o
+obj-$(CONFIG_GSENSOR_KIONIX)      += kionix/
+obj-$(CONFIG_GSENSOR_STK8312)		  += stk8312/
+obj-$(CONFIG_GSENSOR_STK8313)		  += stk8313/
+obj-$(CONFIG_GSENSOR_MMA7660)		  += mma7660/
+obj-$(CONFIG_GSENSOR_MIR3DA)		  += mir3da/
+obj-$(CONFIG_GSENSOR_DETECT)		  += gsensor_detect.o
\ No newline at end of file
diff --git a/drivers/input/misc/gsensor/bma220.c b/drivers/input/misc/gsensor/bma220.c
new file mode 100755
index 0000000..df733dd
--- /dev/null
+++ b/drivers/input/misc/gsensor/bma220.c
@@ -0,0 +1,1797 @@
+/* file bma220.c
+   brief This file contains all function implementations for the BMA220 in linux
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include "../gsensor_common.h"
+
+
+#define SENSOR_NAME              "bma220"
+#define SENSOR_I2C_ADDR         0x0a
+#define ABSMIN                          -32
+#define ABSMAX                          31
+#define FUZZ                    1
+
+#define BMA220_MAX_DELAY        200
+#define BMA220_CHIP_ID              0xdd
+#define BMA220_RANGE_SET        0
+#define BMA220_BW_SET              4
+
+#define BMA220_CHIP_ID_REG                      0x00
+#define BMA220_VERSION_REG                      0x01
+#define BMA220_X_AXIS_DATA_REG              0x02
+#define BMA220_Y_AXIS_DATA_REG              0x03
+#define BMA220_Z_AXIS_DATA_REG              0x04
+#define BMA220_SLEEP_CONFIG_REG               0x0F
+#define BMA220_BANDWIDTH_CONFIG_REG   0x10
+#define BMA220_RANGE_SELFTEST_REG        0x11
+#define BMA220_HPASS_CONFIG_REG            0x12
+#define BMA220_OFFSET_TARGET_REG          0x13
+#define BMA220_OFFSET_X_RESULT_REG        0x14
+#define BMA220_OFFSET_Y_RESULT_REG        0x15
+#define BMA220_OFFSET_Z_RESULT_REG        0x16
+#define BMA220_SUSPEND_MODE_REG           0x18
+#define BMA220_SOFTRESET_REG                  0x19
+
+#define BMA220_RANGE__POS                0
+#define BMA220_RANGE__MSK                0x03
+#define BMA220_RANGE__LEN                2
+#define BMA220_RANGE__REG                BMA220_RANGE_SELFTEST_REG
+
+#define BMA220_SUSPEND__POS                0
+#define BMA220_SUSPEND__MSK                0xFF
+#define BMA220_SUSPEND__LEN                 8
+#define BMA220_SUSPEND__REG                BMA220_SUSPEND_MODE_REG
+
+#define BMA220_SERIAL_HIGH_BW__POS        7
+#define BMA220_SERIAL_HIGH_BW__MSK        0x80
+#define BMA220_SERIAL_HIGH_BW__LEN        1
+#define BMA220_SERIAL_HIGH_BW__REG        BMA220_BANDWIDTH_CONFIG_REG
+
+#define BMA220_SC_FILT_CONFIG__POS        0
+#define BMA220_SC_FILT_CONFIG__MSK        0x0F
+#define BMA220_SC_FILT_CONFIG__LEN        4
+#define BMA220_SC_FILT_CONFIG__REG        BMA220_BANDWIDTH_CONFIG_REG
+
+#define BMA220_SBIST__POS                2
+#define BMA220_SBIST__MSK                0x0C
+#define BMA220_SBIST__LEN                2
+#define BMA220_SBIST__REG                BMA220_RANGE_SELFTEST_REG
+
+#define BMA220_SBIST_SIGN__POS            4
+#define BMA220_SBIST_SIGN__MSK            0x10
+#define BMA220_SBIST_SIGN__LEN            1
+#define BMA220_SBIST_SIGN__REG            BMA220_RANGE_SELFTEST_REG
+
+#define BMA220_OFFSET_RESET__POS        3
+#define BMA220_OFFSET_RESET__MSK        0x08
+#define BMA220_OFFSET_RESET__LEN               1
+#define BMA220_OFFSET_RESET__REG        BMA220_HPASS_CONFIG_REG
+
+#define BMA220_CAL_RDY__POS                4
+#define BMA220_CAL_RDY__MSK                0x10
+#define BMA220_CAL_RDY__LEN                1
+#define BMA220_CAL_RDY__REG                BMA220_HPASS_CONFIG_REG
+
+#define BMA220_CAL_TRIGGER__POS            5
+#define BMA220_CAL_TRIGGER__MSK            0xE0
+#define BMA220_CAL_TRIGGER__LEN            3
+#define BMA220_CAL_TRIGGER__REG            BMA220_HPASS_CONFIG_REG
+
+#define BMA220_CUT_OFF__POS                0
+#define BMA220_CUT_OFF__MSK                0x01
+#define BMA220_CUT_OFF__LEN                1
+#define BMA220_CUT_OFF__REG                BMA220_OFFSET_TARGET_REG
+
+#define BMA220_OFFSET_TARGET_Z__POS        1
+#define BMA220_OFFSET_TARGET_Z__MSK        0x06
+#define BMA220_OFFSET_TARGET_Z__LEN        2
+#define BMA220_OFFSET_TARGET_Z__REG        BMA220_OFFSET_TARGET_REG
+
+#define BMA220_OFFSET_TARGET_Y__POS        3
+#define BMA220_OFFSET_TARGET_Y__MSK        0x18
+#define BMA220_OFFSET_TARGET_Y__LEN        2
+#define BMA220_OFFSET_TARGET_Y__REG        BMA220_OFFSET_TARGET_REG
+
+#define BMA220_OFFSET_TARGET_X__POS        5
+#define BMA220_OFFSET_TARGET_X__MSK        0x60
+#define BMA220_OFFSET_TARGET_X__LEN        2
+#define BMA220_OFFSET_TARGET_X__REG        BMA220_OFFSET_TARGET_REG
+
+#define BMA220_CAL_MANUAL__POS            7
+#define BMA220_CAL_MANUAL__MSK            0x80
+#define BMA220_CAL_MANUAL__LEN            1
+#define BMA220_CAL_MANUAL__REG            BMA220_OFFSET_TARGET_REG
+
+#define BMA220_OFFSET_X__POS            2
+#define BMA220_OFFSET_X__MSK            0xFC
+#define BMA220_OFFSET_X__LEN            6
+#define BMA220_OFFSET_X__REG            BMA220_OFFSET_X_RESULT_REG
+
+#define BMA220_OFFSET_Y__POS            2
+#define BMA220_OFFSET_Y__MSK            0xFC
+#define BMA220_OFFSET_Y__LEN            6
+#define BMA220_OFFSET_Y__REG            BMA220_OFFSET_Y_RESULT_REG
+
+#define BMA220_OFFSET_Z__POS            2
+#define BMA220_OFFSET_Z__MSK            0xFC
+#define BMA220_OFFSET_Z__LEN            6
+#define BMA220_OFFSET_Z__REG            BMA220_OFFSET_Z_RESULT_REG
+
+#define BMA220_SLEEP_EN__POS            6
+#define BMA220_SLEEP_EN__MSK            0x40
+#define BMA220_SLEEP_EN__LEN              1
+#define BMA220_SLEEP_EN__REG            BMA220_SLEEP_CONFIG_REG
+
+#define BMA220_ACC_X__REG               BMA220_X_AXIS_DATA_REG
+#define BMA220_ACC_Y__REG               BMA220_Y_AXIS_DATA_REG
+#define BMA220_ACC_Z__REG               BMA220_Z_AXIS_DATA_REG
+#define BMA220_DATA_SHIFT_RIGHT         0x02
+
+
+#define BMA220_RANGE_2G                 0
+#define BMA220_RANGE_4G                 1
+#define BMA220_RANGE_8G                 2
+#define BMA220_RANGE_16G                3
+
+#define BMA220_BW_7_81HZ        0x08
+#define BMA220_BW_15_63HZ       0x09
+#define BMA220_BW_31_25HZ       0x0A
+#define BMA220_BW_62_50HZ       0x0B
+#define BMA220_BW_125HZ         0x0C
+#define BMA220_BW_250HZ         0x0D
+#define BMA220_BW_500HZ         0x0E
+#define BMA220_BW_1000HZ        0x0F
+
+#define BMA220_MODE_NORMAL      0
+#define BMA220_MODE_LOWPOWER    1
+#define BMA220_MODE_SUSPEND     2
+
+
+#define BMA220_GET_BITSLICE(regvar, bitname)\
+    ((regvar & bitname##__MSK) >> bitname##__POS)
+
+
+#define BMA220_SET_BITSLICE(regvar, bitname, val)\
+    ((regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK))
+
+
+struct bma220acc{
+    s16    x,
+        y,
+        z;
+} ;
+
+struct bma220_data {
+    struct i2c_client *bma220_client;
+    struct mutex enable_mutex;
+    atomic_t selftest_result;
+    
+    atomic_t delay;
+    atomic_t enable;
+    struct input_dev *input;
+    struct delayed_work work;
+    unsigned char mode;
+    
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend early_suspend;
+#endif
+    atomic_t fuzz;
+    atomic_t position;
+    atomic_t calibrated;
+    unsigned char offset_saved[3];
+};
+
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  1
+
+// calibration file path
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+/*******************************************
+* for xml cfg
+*******************************************/
+#define CFG_GSENSOR_ADAP_ID          "gsensor.i2c_adap_id"
+#define CFG_GSENSOR_POSITION         "gsensor.position"
+#define CFG_GSENSOR_CALIBRATION      "gsensor.calibration"
+
+extern int get_config(const char *key, char *buff, int len);
+/*******************************************
+* end for xml cfg
+*******************************************/
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma220_early_suspend(struct early_suspend *h);
+static void bma220_late_resume(struct early_suspend *h);
+#endif
+
+static int bma220_smbus_read_byte(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data)
+{
+    s32 dummy;
+    unsigned char addr;
+    addr = reg_addr<<1;        /*bma220 i2c addr left shift*/
+    dummy = i2c_smbus_read_byte_data(client, addr);
+    if (dummy < 0)
+        return -1;
+    *data = dummy & 0x000000ff;
+
+    return 0;
+}
+
+static int bma220_smbus_write_byte(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data)
+{
+    s32 dummy;
+    unsigned char addr;
+    addr = reg_addr<<1;        /*bma220 i2c addr left shift*/
+    dummy = i2c_smbus_write_byte_data(client, addr, *data);
+    if (dummy < 0)
+        return -1;
+    return 0;
+}
+
+static int bma220_smbus_read_byte_block(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    unsigned char addr;
+    addr = reg_addr<<1;        /*bma220 i2c addr left shift*/
+    dummy = i2c_smbus_read_i2c_block_data(client, addr, len, data);
+    if (dummy < 0)
+        return -1;
+    return 0;
+}
+
+static int bma220_smbus_write_byte_block(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    s32 idx;
+    unsigned char addr;
+
+    //bma220 only support byte data write
+    for (idx = 0; idx < len; idx ++)
+    {
+        addr = (reg_addr+idx)<<1;        /*bma220 i2c addr left shift*/
+        dummy = i2c_smbus_write_byte_data(client, addr, data[idx]);
+        if (dummy < 0)
+            return -1;
+    }
+    
+    return 0;
+}
+
+/** Perform soft reset of BMA220 via bus command
+    \param none
+    \return result of communication routines 
+*/
+int bma220_soft_reset(struct i2c_client *client) 
+{
+    int comres;
+    unsigned char data=0;
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+    
+    /* read softreset twice for setting and releasing the reset */
+    comres = bma220_smbus_read_byte(client, BMA220_SOFTRESET_REG, &data);    
+    comres = bma220_smbus_read_byte(client, BMA220_SOFTRESET_REG, &data);  
+     
+    /* Required to reset mode to normal */
+    bma220->mode = BMA220_MODE_NORMAL;
+    
+    return comres;
+}
+
+/** Set/reset suspend of BMA220
+    \param none
+    \return result of communication routines 
+    \note calling this function will toggle between normal mode and suspend mode
+*/
+int bma220_set_suspend(struct i2c_client *client) 
+{
+    int comres;
+    unsigned char data=0;
+    
+    /* read suspend to toggle between suspend and normal operation mode */
+    comres = bma220_smbus_read_byte(client, BMA220_SUSPEND__REG, &data);    
+    return comres;
+}
+
+
+/** Set BMA220 to sleep mode via bus command
+    \param sleep    0=disable sleep mode, 1=enable sleep mode
+    \return result of communication routines
+*/
+int bma220_set_sleep_en(struct i2c_client *client, unsigned char sleep) 
+{
+    int comres;
+    unsigned char data=0;
+    
+    comres = bma220_smbus_read_byte(client, BMA220_SLEEP_EN__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_SLEEP_EN, sleep);
+    comres |= bma220_smbus_write_byte(client, BMA220_SLEEP_EN__REG, &data);
+    return comres;
+}
+
+/** Set Mode
+    \param mode 0=Normal Mode, 1=Sleep Mode, 2=Suspend Mode
+    \return result of communication routines
+*/
+static int bma220_set_mode(struct bma220_data *bma220, unsigned char mode)
+{
+    int comres=0;
+        
+    if (mode == bma220->mode)
+        return 0;
+        
+    switch(bma220->mode) {
+        case 0: if (mode==1)
+                    comres = bma220_set_sleep_en(bma220->bma220_client,1);
+                else if (mode==2)
+                    comres = bma220_set_suspend(bma220->bma220_client);
+                break;
+        case 1: comres = bma220_set_sleep_en(bma220->bma220_client,0);
+                if (mode==2)
+                    comres |= bma220_set_suspend(bma220->bma220_client);
+                break;
+        case 2: comres = bma220_set_suspend(bma220->bma220_client);
+                if (mode==1)
+                    comres |= bma220_set_sleep_en(bma220->bma220_client,1);
+                break;
+        default: comres = -1;
+                break;
+    }
+    bma220->mode = mode;            
+    return comres;
+}
+
+/** Set range
+    \param range 0=2g, 1=4g, 2=8g, 3=16g
+    \return result of communication routines 
+*/
+static int bma220_set_range(struct i2c_client *client, unsigned char range)
+{
+    unsigned char data;
+    int comres;
+
+    
+    comres = bma220_smbus_read_byte(client, BMA220_RANGE__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_RANGE, range);
+    comres |= bma220_smbus_write_byte(client, BMA220_RANGE__REG, &data);
+    return comres;
+}
+
+/** Get range
+    \param *range 0=2g, 1=4g, 2=8g, 3=16g.
+    \return result of communication routines 
+*/
+static int bma220_get_range(struct i2c_client *client, unsigned char *range)
+{
+    unsigned char data;
+    int comres = 0;
+
+    comres = bma220_smbus_read_byte(client, BMA220_RANGE__REG, &data);
+    *range = BMA220_GET_BITSLICE(data, BMA220_RANGE);
+    return comres;
+}
+
+/** Set SC_FILT_CONFIG
+    \param sc_filt 0=1kHz, 1=600hz, 2=250Hz, 3=150Hz, 4=75Hz, 5=50Hz.
+    \return result of communication routines 
+*/
+static int bma220_set_sc_filt_config(struct i2c_client *client, char sc_filt) 
+{
+    int comres = 0;
+    unsigned char data;
+
+    if (sc_filt<16)
+    {
+        comres = bma220_smbus_read_byte(client, BMA220_SC_FILT_CONFIG__REG, &data);
+      data = BMA220_SET_BITSLICE(data, BMA220_SC_FILT_CONFIG, sc_filt);
+      comres += bma220_smbus_write_byte(client, BMA220_SC_FILT_CONFIG__REG, &data);
+    }
+    return comres;
+}
+
+/** Get SC_FILT_CONFIG
+    \param *sc_filt 0=1kHz, 1=600hz, 2=250Hz, 3=150Hz, 4=75Hz, 5=50Hz.
+    \return result of communication routines 
+*/
+static int bma220_get_sc_filt_config(struct i2c_client *client, unsigned char *sc_filt)
+{
+    unsigned char data;
+    int comres = 0;
+
+    comres = bma220_smbus_read_byte(client, BMA220_SC_FILT_CONFIG__REG, &data);        
+    *sc_filt = BMA220_GET_BITSLICE(data, BMA220_SC_FILT_CONFIG);
+    return comres;
+}
+
+/* Bandwidth configuration
+
+*/
+
+/** Set Bandwidth (SC_FILT_CONFIG)
+    \param bw 0=1kHz, 1=600hz, 2=250Hz, 3=150Hz, 4=75Hz, 5=50Hz.
+    \return result of communication routines 
+*/
+static int bma220_set_bandwidth(struct i2c_client *client, unsigned char bw)
+{
+    return bma220_set_sc_filt_config(client,bw);
+}
+
+/** Get Bandwidth (SC_FILT_CONFIG)
+    \param *bw 0=1kHz, 1=600hz, 2=250Hz, 3=150Hz, 4=75Hz, 5=50Hz.
+    \return result of communication routines 
+*/
+static int bma220_get_bandwidth(struct i2c_client *client, unsigned char *bw)
+{
+    return bma220_get_sc_filt_config(client,bw);
+}
+
+/** Get Acceleration Data for all 3 axis XYZ
+    \param *accel pointer to struc of three signed char (-32..31)
+    \return result of communication routines
+*/
+static int bma220_read_accel_xyz(struct i2c_client *client, struct bma220acc *accel)
+{
+    int comres;
+    unsigned char data[3];
+    
+    comres = bma220_smbus_read_byte_block(client, BMA220_ACC_X__REG, data, 3);
+    accel->x = ((signed char)data[0]);    
+    accel->x = accel->x >> BMA220_DATA_SHIFT_RIGHT;
+    accel->y = ((signed char)data[1]);
+    accel->y = accel->y >> BMA220_DATA_SHIFT_RIGHT;
+    accel->z = ((signed char)data[2]);
+    accel->z = accel->z >> BMA220_DATA_SHIFT_RIGHT;
+    return comres;
+}
+
+/** Get Acceleration Data for X
+    \param *accel_x pointer to signed char (-32..31)
+    \return result of communication routines
+*/
+static int bma220_read_accel_x(struct i2c_client *client, signed char  *accel_x) 
+{
+    int comres;
+    unsigned char data;
+    
+    comres = bma220_smbus_read_byte(client, BMA220_ACC_X__REG, &data);
+    *accel_x = ((signed char) data>>BMA220_DATA_SHIFT_RIGHT);
+    return comres;
+}
+
+/** Get Acceleration Data for Y
+    \param *accel_y pointer to signed char (-32..31)
+    \return result of communication routines
+*/
+static int bma220_read_accel_y(struct i2c_client *client, signed char  *accel_y) 
+{
+    int comres;
+    unsigned char data;
+    
+    comres =  bma220_smbus_read_byte(client, BMA220_ACC_Y__REG, &data);
+    *accel_y = ((signed char) data>>BMA220_DATA_SHIFT_RIGHT);
+    return comres;
+}
+
+/** Get Acceleration Data for Z
+    \param *accel_z pointer to signed char (-32..31)
+    \return result of communication routines
+*/
+static int bma220_read_accel_z(struct i2c_client *client, signed char  *accel_z) 
+{
+    int comres;
+    unsigned char data;
+    
+    comres =  bma220_smbus_read_byte(client, BMA220_ACC_Z__REG, &data);
+    *accel_z = ((signed char) data>>BMA220_DATA_SHIFT_RIGHT);
+    return comres;
+}
+
+/** Set offset_target_x
+    \param offset_target_x 0=0g, 1=1g,2=-1g.
+    \return result of communication routines
+*/
+static int bma220_set_offset_target_x(struct i2c_client *client, unsigned char offset_target_x)
+{
+    unsigned char data;
+    int comres;
+    
+    comres = bma220_smbus_read_byte(client, BMA220_OFFSET_TARGET_X__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_OFFSET_TARGET_X, offset_target_x);
+    comres |= bma220_smbus_write_byte(client, BMA220_OFFSET_TARGET_X__REG, &data);
+    return comres;
+}
+
+/** Get offset_target_x
+    \param *offset_target_x 0=0g, 1=1g,2=-1g.
+    \return result of communication routines
+*/
+static int bma220_get_offset_target_x(struct i2c_client *client, unsigned char *offset_target_x) 
+{
+    unsigned char data;
+    int comres;
+    
+    comres = bma220_smbus_read_byte(client, BMA220_OFFSET_TARGET_X__REG, &data);
+    *offset_target_x = BMA220_GET_BITSLICE(data, BMA220_OFFSET_TARGET_X);
+    return comres;
+}
+
+/** Set offset_target_y
+    \param offset_target_y 0=0g, 1=1g,2=-1g.
+    \return result of communication routines
+*/
+static int bma220_set_offset_target_y(struct i2c_client *client, unsigned char offset_target_y)
+{
+    unsigned char data;
+    int comres;
+    
+    comres = bma220_smbus_read_byte(client, BMA220_OFFSET_TARGET_Y__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_OFFSET_TARGET_Y, offset_target_y);
+    comres |= bma220_smbus_write_byte(client, BMA220_OFFSET_TARGET_Y__REG, &data);
+    return comres;
+}
+
+/** Get offset_target_y
+    \param *offset_target_y 0=0g, 1=1g,2=-1g.
+    \return result of communication routines
+*/
+static int bma220_get_offset_target_y(struct i2c_client *client, unsigned char *offset_target_y) 
+{
+    unsigned char data;
+    int comres;
+    
+    comres = bma220_smbus_read_byte(client, BMA220_OFFSET_TARGET_Y__REG, &data);
+    *offset_target_y = BMA220_GET_BITSLICE(data, BMA220_OFFSET_TARGET_Y);
+    return comres;
+}
+
+/** Set offset_target_z
+    \param offset_target_z 0=0g, 1=1g,2=-1g.
+    \return result of communication routines
+*/
+static int bma220_set_offset_target_z(struct i2c_client *client, unsigned char offset_target_z)
+{
+    unsigned char data;
+    int comres;
+    
+    comres = bma220_smbus_read_byte(client, BMA220_OFFSET_TARGET_Z__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_OFFSET_TARGET_Z, offset_target_z);
+    comres |= bma220_smbus_write_byte(client, BMA220_OFFSET_TARGET_Z__REG, &data);
+    return comres;
+}
+
+/** Get offset_target_z
+    \param *offset_target_z 0=0g, 1=1g,2=-1g.
+    \return result of communication routines
+*/
+static int bma220_get_offset_target_z(struct i2c_client *client, unsigned char *offset_target_z)
+{
+    unsigned char data;
+    int comres;
+    
+    comres = bma220_smbus_read_byte(client, BMA220_OFFSET_TARGET_Z__REG, &data);
+    *offset_target_z = BMA220_GET_BITSLICE(data, BMA220_OFFSET_TARGET_Z);
+    return comres;
+}
+
+static int bma220_get_cal_ready(struct i2c_client *client, unsigned char *calrdy)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma220_smbus_read_byte(client, BMA220_CAL_RDY__REG, &data);
+    data = BMA220_GET_BITSLICE(data, BMA220_CAL_RDY);
+    *calrdy = data;
+    
+    return comres;
+}
+
+static int bma220_reset_cal_offset(struct i2c_client *client)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma220_smbus_read_byte(client, BMA220_OFFSET_RESET__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_OFFSET_RESET, 1);
+    comres = bma220_smbus_write_byte(client, BMA220_OFFSET_RESET__REG,  &data);
+
+    return comres;
+}
+
+static int bma220_set_cal_trigger(struct i2c_client *client, unsigned char
+        caltrigger)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma220_smbus_read_byte(client, BMA220_CAL_TRIGGER__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_CAL_TRIGGER, caltrigger);
+    comres = bma220_smbus_write_byte(client, BMA220_CAL_TRIGGER__REG, &data);
+
+    return comres;
+}
+
+/** Set sbist(off,x,y,z) Enable/Disable selftest 
+    \param sbist 0=off, 1=x axis, 2=y axis, 3=z axis.
+    \return result of communication routines 
+*/
+static int bma220_set_selftest_st(struct i2c_client *client, unsigned char selftest)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma220_smbus_read_byte(client, BMA220_SBIST__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_SBIST, selftest);
+    comres = bma220_smbus_write_byte(client, BMA220_SBIST__REG, &data);
+
+    return comres;
+}
+
+/** Set sbist_sign 
+    \param sbist_sign 0=positive stimuli, 1=negative stimuli.
+    \return result of communication routines 
+*/
+static int bma220_set_selftest_stn(struct i2c_client *client, unsigned char stn)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma220_smbus_read_byte(client, BMA220_SBIST_SIGN__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_SBIST_SIGN, stn);
+    comres = bma220_smbus_write_byte(client, BMA220_SBIST_SIGN__REG, &data);
+
+    return comres;
+}
+
+/** Set cal_manual
+    \param cal_manual 0=write access to offset register disabled, 1=write access to offset register enabled
+    \return result of communication routines
+*/
+static int bma220_set_cal_manual(struct i2c_client *client, unsigned char cal_manual)
+{
+    unsigned char data;
+    int comres;
+    
+    comres = bma220_smbus_read_byte(client, BMA220_CAL_MANUAL__REG, &data);
+    data = BMA220_SET_BITSLICE(data, BMA220_CAL_MANUAL, cal_manual);
+    comres |= bma220_smbus_write_byte(client, BMA220_CAL_MANUAL__REG, &data);
+    return comres;
+}
+
+/** Set offset word for all 3 axis XYZ
+    \param offset struct of three signed char (-32..31)
+    \return result of communication routines
+*/
+static int bma220_set_offset_filt_xyz(struct i2c_client *client, unsigned char *offset, int len)
+{
+    int comres = 0;
+    unsigned char data[8];
+    int idx;
+
+    // Enable write access to offset register by setting cal_manual
+    bma220_set_cal_manual(client, 1);
+    
+    for (idx=0; idx < len; idx++)
+    {
+        data[idx] =(offset[idx]<<BMA220_DATA_SHIFT_RIGHT);
+    }    
+    comres = bma220_smbus_write_byte_block(client, BMA220_OFFSET_X__REG, data, len);
+        
+    // Enable write access to offset register by setting cal_manual
+    bma220_set_cal_manual(client, 0);
+    
+    return comres;
+}
+
+/** Get offset word for all 3 axis XYZ 
+    \param *offset pointer to struct of three signed char (-32..31)
+    \return result of communication routines
+*/
+static int bma220_get_offset_filt_xyz(struct i2c_client *client, unsigned char *offset, int len)
+{
+    int comres = 0 ;
+    unsigned char data[8];
+    int idx;
+
+    comres = bma220_smbus_read_byte_block(client, BMA220_OFFSET_X__REG, data, len);
+    
+    for (idx=0; idx < len; idx++)
+    {
+        offset[idx] = (data[idx]>>BMA220_DATA_SHIFT_RIGHT);
+    }
+    return comres;
+}
+
+static int bma220_read_file(char *path, char *buf, int size)
+{
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+static int bma220_load_user_calibration(struct i2c_client *client)
+{
+    char buffer[16];
+    int ret = 0;
+    int data[3];
+    unsigned char offset[3];
+    struct bma220_data *bma220 = i2c_get_clientdata(client);    
+    int calibrated = atomic_read(&bma220->calibrated);
+    
+    // only calibrate once
+    if (calibrated) {
+        goto usr_calib_end;
+    } else {
+        atomic_set(&bma220->calibrated, 1);
+    }
+
+    ret = bma220_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d", &data[0], &data[1], &data[2]);
+    offset[0] = (unsigned char) data[0];
+    offset[1] = (unsigned char) data[1];
+    offset[2] = (unsigned char) data[2];    
+    
+    printk(KERN_INFO "user cfg_calibration: %d %d %d\n", offset[0], offset[1], offset[2]);
+    
+    if (bma220_set_offset_filt_xyz(bma220->bma220_client, offset, sizeof(offset)) < 0) {
+        printk(KERN_ERR"set offset fail\n");
+        goto usr_calib_end;
+    }
+    
+    printk(KERN_INFO "load user calibration finished\n");
+    
+usr_calib_end:
+    return ret;
+}
+
+static int bma220_axis_remap(struct i2c_client *client,
+        struct bma220acc *acc)
+{
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+    s16 swap;
+    int bma_position = atomic_read(&bma220->position);
+
+    switch (abs(bma_position)) {
+        case 1:
+            acc->x = -(acc->x);
+            acc->y = -(acc->y);
+            break;
+        case 2:
+            swap = acc->x;
+            acc->x = -acc->y;
+            acc->y = swap;
+            break;
+        case 3:
+            break;
+        case 4:
+            swap = acc->x;
+            acc->x = acc->y;
+            acc->y = -swap; 
+            break;
+    }
+    
+    if (bma_position < 0) {
+        acc->z = -(acc->z);
+        acc->x = -(acc->x);
+    }
+    
+    return 0;
+}
+
+static void bma220_work_func(struct work_struct *work)
+{
+    struct bma220_data *bma220 = container_of((struct delayed_work *)work,
+            struct bma220_data, work);
+    static struct bma220acc acc;
+    unsigned long delay = msecs_to_jiffies(atomic_read(&bma220->delay));
+
+    //bma220_load_user_calibration(bma220->bma220_client);
+    
+    bma220_read_accel_xyz(bma220->bma220_client, &acc);
+    bma220_axis_remap(bma220->bma220_client, &acc);
+    input_report_abs(bma220->input, ABS_X, acc.x);
+    input_report_abs(bma220->input, ABS_Y, acc.y);
+    input_report_abs(bma220->input, ABS_Z, acc.z);
+    input_sync(bma220->input);
+    
+    schedule_delayed_work(&bma220->work, delay);
+}
+
+static ssize_t bma220_register_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int address, value;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    sscanf(buf, "[0x%x]=0x%x", &address, &value);
+
+    if (bma220_smbus_write_byte(bma220->bma220_client, (unsigned char)address,
+                (unsigned char *)&value) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma220_register_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    size_t count = 0;
+    u8 reg[0x20];
+    int i;
+
+    for (i = 0 ; i <= 0x17; i++) {
+        bma220_smbus_read_byte(bma220->bma220_client, i, reg+i);
+
+        count += sprintf(&buf[count], "[0x%x]=0x%x\n", i, reg[i]);
+    }
+    return count;
+}
+
+static ssize_t bma220_range_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    if (bma220_get_range(bma220->bma220_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma220_range_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (bma220_set_range(bma220->bma220_client, (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma220_bandwidth_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    if (bma220_get_bandwidth(bma220->bma220_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma220_bandwidth_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (bma220_set_bandwidth(bma220->bma220_client,
+                (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma220_mode_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", bma220->mode);
+}
+
+static ssize_t bma220_mode_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (bma220_set_mode(bma220, (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma220_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct input_dev *input = to_input_dev(dev);
+    struct bma220_data *bma220 = input_get_drvdata(input);
+    struct bma220acc acc;
+    
+    bma220_read_accel_xyz(bma220->bma220_client, &acc);
+    bma220_axis_remap(bma220->bma220_client, &acc);
+
+    return sprintf(buf, "%d %d %d\n", acc.x, acc.y, acc.z);
+}
+
+static ssize_t bma220_delay_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma220->delay));
+}
+
+static ssize_t bma220_delay_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+    unsigned char bandwidth;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (data > BMA220_MAX_DELAY)
+        data = BMA220_MAX_DELAY;
+    atomic_set(&bma220->delay, (unsigned int) data);
+
+    // change band width
+    data = 1000 / data;
+    if (data > 500) {
+        bandwidth = 0;
+    } else if (data > 250) {
+        bandwidth = 1;
+    } else if (data > 125) {
+        bandwidth = 2;
+    } else if (data > 64) {
+        bandwidth = 3;
+    } else if (data > 32) {
+        bandwidth = 4;
+    } else {
+        bandwidth = 5;
+    }
+    bma220_set_bandwidth(bma220->bma220_client, bandwidth);
+    
+    return count;
+}
+
+static ssize_t bma220_enable_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma220->enable));
+
+}
+
+static void bma220_do_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+    int used = enable;
+
+    if (used) {
+        bma220_set_mode(bma220, BMA220_MODE_NORMAL);
+    } else {
+        bma220_set_mode(bma220, BMA220_MODE_SUSPEND);
+    }
+    
+    if (enable) {
+        schedule_delayed_work(&bma220->work,
+            msecs_to_jiffies(atomic_read(&bma220->delay)));
+    } else {
+        cancel_delayed_work_sync(&bma220->work);
+    }
+}
+
+static void bma220_set_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+    int pre_enable = atomic_read(&bma220->enable);
+
+    mutex_lock(&bma220->enable_mutex);
+    if (enable != pre_enable) {
+        bma220_do_enable(dev, enable);
+        atomic_set(&bma220->enable, enable);
+    }
+    mutex_unlock(&bma220->enable_mutex);
+}
+
+static ssize_t bma220_enable_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if ((data == 0) || (data == 1)) {
+        bma220_set_enable(dev, data);
+    }
+
+    return count;
+}
+
+static ssize_t bma220_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    data = atomic_read(&(bma220->position));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma220_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(bma220->position), (int) data);
+
+    return count;
+}
+
+static ssize_t bma220_fast_calibration_x_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    if (bma220_get_offset_target_x(bma220->bma220_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma220_fast_calibration_x_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    signed char tmp;
+    unsigned char timeout = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (bma220_set_offset_target_x(bma220->bma220_client, (unsigned
+                    char)data) < 0)
+        return -EINVAL;
+
+    if (bma220_set_cal_trigger(bma220->bma220_client, 1) < 0)
+        return -EINVAL;
+
+    do {
+        mdelay(2);
+        bma220_get_cal_ready(bma220->bma220_client, &tmp);
+
+    /*    printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+        timeout++;
+        if (timeout == 500) {
+            printk(KERN_INFO "get fast calibration ready error\n");
+            return -EINVAL;
+        };
+
+    } while (tmp == 0);
+
+    printk(KERN_INFO "x axis fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma220_fast_calibration_y_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    if (bma220_get_offset_target_y(bma220->bma220_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma220_fast_calibration_y_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    signed char tmp;
+    unsigned char timeout = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (bma220_set_offset_target_y(bma220->bma220_client, (unsigned
+                    char)data) < 0)
+        return -EINVAL;
+
+    if (bma220_set_cal_trigger(bma220->bma220_client, 2) < 0)
+        return -EINVAL;
+
+    do {
+        mdelay(2);
+        bma220_get_cal_ready(bma220->bma220_client, &tmp);
+
+    /*    printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+        timeout++;
+        if (timeout == 500) {
+            printk(KERN_INFO "get fast calibration ready error\n");
+            return -EINVAL;
+        };
+
+    } while (tmp == 0);
+
+    printk(KERN_INFO "y axis fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma220_fast_calibration_z_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    if (bma220_get_offset_target_z(bma220->bma220_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma220_fast_calibration_z_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    signed char tmp;
+    unsigned char timeout = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (bma220_set_offset_target_z(bma220->bma220_client, (unsigned
+                    char)data) < 0)
+        return -EINVAL;
+
+    if (bma220_set_cal_trigger(bma220->bma220_client, 3) < 0)
+        return -EINVAL;
+
+    do {
+        mdelay(2);
+        bma220_get_cal_ready(bma220->bma220_client, &tmp);
+
+    /*    printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+        timeout++;
+        if (timeout == 500) {
+            printk(KERN_INFO "get fast calibration ready error\n");
+            return -EINVAL;
+        };
+
+    } while (tmp == 0);
+
+    printk(KERN_INFO "z axis fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma220_selftest_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma220->selftest_result));
+}
+
+static ssize_t bma220_selftest_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    unsigned char value1 = 0;
+    unsigned char value2 = 0;
+    char diff = 0;
+    unsigned long result = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (data != 1)
+        return -EINVAL;
+    /* set to 2 G range */
+    if (bma220_set_range(bma220->bma220_client, 0) < 0)
+        return -EINVAL;
+
+    bma220_set_selftest_st(bma220->bma220_client, 0); /* off */
+    bma220_set_selftest_stn(bma220->bma220_client, 0); /* positive direction*/
+    mdelay(10);
+    
+    bma220_set_selftest_st(bma220->bma220_client, 1); /* 1 for x-axis*/
+    bma220_set_selftest_stn(bma220->bma220_client, 0); /* positive direction*/
+    mdelay(10);
+    bma220_read_accel_x(bma220->bma220_client, &value1);
+    bma220_set_selftest_stn(bma220->bma220_client, 1); /* negative direction*/
+    mdelay(10);
+    bma220_read_accel_x(bma220->bma220_client, &value2);
+    diff = value1-value2;
+
+    printk(KERN_INFO "diff x is %d,value1 is %d, value2 is %d\n", diff,
+            value1, value2);
+
+    if (abs(diff) < 204)
+        result |= 1;
+
+    bma220_set_selftest_st(bma220->bma220_client, 2); /* 2 for y-axis*/
+    bma220_set_selftest_stn(bma220->bma220_client, 0); /* positive direction*/
+    mdelay(10);
+    bma220_read_accel_y(bma220->bma220_client, &value1);
+    bma220_set_selftest_stn(bma220->bma220_client, 1); /* negative direction*/
+    mdelay(10);
+    bma220_read_accel_y(bma220->bma220_client, &value2);
+    diff = value1-value2;
+    printk(KERN_INFO "diff y is %d,value1 is %d, value2 is %d\n", diff,
+            value1, value2);
+    if (abs(diff) < 204)
+        result |= 2;
+
+    bma220_set_selftest_st(bma220->bma220_client, 3); /* 3 for z-axis*/
+    bma220_set_selftest_stn(bma220->bma220_client, 0); /* positive direction*/
+    mdelay(10);
+    bma220_read_accel_z(bma220->bma220_client, &value1);
+    bma220_set_selftest_stn(bma220->bma220_client, 1); /* negative direction*/
+    mdelay(10);
+    bma220_read_accel_z(bma220->bma220_client, &value2);
+    diff = value1-value2;
+
+    printk(KERN_INFO "diff z is %d,value1 is %d, value2 is %d\n", diff,
+            value1, value2);
+    if (abs(diff) < 102)
+        result |= 4;
+
+    atomic_set(&bma220->selftest_result, (unsigned int)result);
+
+    printk(KERN_INFO "self test finished\n");
+    return count;
+}
+
+static ssize_t bma220_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+    int bma_position = atomic_read(&bma220->position);
+    
+    bma220_fast_calibration_x_store(dev, attr, "0", 2);
+    bma220_fast_calibration_y_store(dev, attr, "0", 2);
+    if (bma_position > 0) {
+        bma220_fast_calibration_z_store(dev, attr, "1", 2); // z: +g
+    } else {
+        bma220_fast_calibration_z_store(dev, attr, "2", 2); // z: -g
+    }
+
+    if (bma220_get_offset_filt_xyz(bma220->bma220_client, offset, sizeof(offset)) < 0)
+        return sprintf((char*)buf, "Read error\n");
+    
+    cfg_calibration[0] = offset[0];
+    cfg_calibration[1] = offset[1];
+    cfg_calibration[2] = offset[2];
+    
+    printk(KERN_INFO "run fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma220_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+    
+    bma220_reset_cal_offset(bma220->bma220_client);
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+
+    printk(KERN_INFO "reset fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma220_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    if (bma220_get_offset_filt_xyz(bma220->bma220_client, offset, sizeof(offset)) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d %d %d\n", offset[0], offset[1], offset[2]);
+}
+
+static ssize_t bma220_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[3];
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    sscanf(buf, "%d %d %d", &data[0], &data[1], &data[2]);
+    offset[0] = (unsigned char) data[0];
+    offset[1] = (unsigned char) data[1];
+    offset[2] = (unsigned char) data[2];
+    
+    if (bma220_set_offset_filt_xyz(bma220->bma220_client, offset, sizeof(offset)) < 0)
+        return -EINVAL;
+
+    printk(KERN_INFO "set fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma220_fuzz_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    data = atomic_read(&(bma220->fuzz));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma220_fuzz_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *bma220 = i2c_get_clientdata(client);
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(bma220->fuzz), (int) data);
+    
+    if(bma220->input != NULL) {
+        bma220->input->absinfo[ABS_X].fuzz = data;
+        bma220->input->absinfo[ABS_Y].fuzz = data;
+        bma220->input->absinfo[ABS_Z].fuzz = data;
+    }
+    
+    return count;
+}
+
+static DEVICE_ATTR(range, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_range_show, bma220_range_store);
+static DEVICE_ATTR(bandwidth, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_bandwidth_show, bma220_bandwidth_store);
+static DEVICE_ATTR(mode, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_mode_show, bma220_mode_store);
+static DEVICE_ATTR(value, S_IRUGO,
+        bma220_value_show, NULL);
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_delay_show, bma220_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_enable_show, bma220_enable_store);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_board_position_show, bma220_board_position_store);
+static DEVICE_ATTR(reg, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_register_show, bma220_register_store);
+static DEVICE_ATTR(fast_calibration_x, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_fast_calibration_x_show,
+        bma220_fast_calibration_x_store);
+static DEVICE_ATTR(fast_calibration_y, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_fast_calibration_y_show,
+        bma220_fast_calibration_y_store);
+static DEVICE_ATTR(fast_calibration_z, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_fast_calibration_z_show,
+        bma220_fast_calibration_z_store);
+static DEVICE_ATTR(selftest, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_selftest_show, bma220_selftest_store);
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, bma220_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, bma220_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_calibration_value_show, bma220_calibration_value_store);
+static DEVICE_ATTR(fuzz, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma220_fuzz_show, bma220_fuzz_store);
+
+static struct attribute *bma220_attributes[] = {
+    &dev_attr_range.attr,
+    &dev_attr_bandwidth.attr,
+    &dev_attr_mode.attr,
+    &dev_attr_value.attr,
+    &dev_attr_delay.attr,
+    &dev_attr_enable.attr,
+    &dev_attr_board_position.attr,
+    &dev_attr_reg.attr,
+    &dev_attr_fast_calibration_x.attr,
+    &dev_attr_fast_calibration_y.attr,
+    &dev_attr_fast_calibration_z.attr,
+    &dev_attr_selftest.attr,
+    &dev_attr_calibration_run.attr,
+    &dev_attr_calibration_reset.attr,
+    &dev_attr_calibration_value.attr,
+    &dev_attr_fuzz.attr,
+    NULL
+};
+
+static struct attribute_group bma220_attribute_group = {
+    .attrs = bma220_attributes
+};
+
+static int bma220_register_input(struct bma220_data *data)
+{
+    int err = 0;
+    struct input_dev *dev;
+    
+    /* register gsensor input device */
+    dev = input_allocate_device();
+    if (!dev) {
+        return -ENOMEM;
+    }
+
+    dev->name = SENSOR_NAME;
+    dev->id.bustype = BUS_I2C;    
+    input_set_capability(dev, EV_ABS, ABS_MISC);
+    input_set_abs_params(dev, ABS_X, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_abs_params(dev, ABS_Y, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_abs_params(dev, ABS_Z, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_drvdata(dev, data);
+
+    err = input_register_device(dev);
+    if (err < 0) {
+        input_free_device(dev);
+        return err;
+    }
+    
+    data->input = dev;        
+    return 0;
+}
+
+static int bma220_probe(struct i2c_client *client,
+        const struct i2c_device_id *id)
+{
+    int err = 0;
+    unsigned char tempvalue;
+    struct bma220_data *data;
+    int cfg_calibration[3],cfg_position;
+    unsigned char offset[3];
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        printk(KERN_INFO "i2c_check_functionality error\n");
+        goto exit;
+    }
+    
+    data = kzalloc(sizeof(struct bma220_data), GFP_KERNEL);
+    if (!data) {
+        err = -ENOMEM;
+        goto exit;
+    }
+
+    /* read chip id */
+    tempvalue = i2c_smbus_read_byte_data(client, BMA220_CHIP_ID_REG);
+    if (tempvalue == BMA220_CHIP_ID) {
+        printk(KERN_INFO "BMA220 detected!\n");
+    } else{
+        printk(KERN_INFO "BMA220 not found! I2c error %d \n", tempvalue);
+        err = -ENODEV;
+        goto kfree_exit;
+    }    
+    i2c_set_clientdata(client, data);
+    data->bma220_client = client;
+    
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+	if (gsensor_read_calibration(&cfg_calibration)!=0){		//if get the file calib failed,then read dts default.
+		if (gsensor_dt_calib(SENSOR_NAME,&cfg_calibration,client)!=0)
+		{
+			printk(KERN_ERR "get calibration error\n");
+			memset(cfg_calibration, 0, sizeof(cfg_calibration));
+		}
+	}
+    offset[0] = (unsigned char) cfg_calibration[0];
+    offset[1] = (unsigned char) cfg_calibration[1];
+    offset[2] = (unsigned char) cfg_calibration[2];
+    printk(KERN_INFO "cfg_calibration: %d %d %d\n", offset[0], offset[1], offset[2]);
+
+    if (bma220_set_offset_filt_xyz(client, offset, sizeof(offset)) < 0) {
+        printk(KERN_ERR"set offset fail\n");
+        goto kfree_exit;
+    }    
+
+    cfg_position=gsensor_dt_position(SENSOR_NAME,client);
+    atomic_set(&data->position, cfg_position);
+    
+    /* register input device */
+    err = bma220_register_input(data);
+    if (err < 0) {
+        goto error_sysfs;
+    }
+
+    err = sysfs_create_group(&data->input->dev.kobj, &bma220_attribute_group);
+    if (err < 0) {
+        goto error_sysfs;
+    }
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    data->early_suspend.suspend = bma220_early_suspend;
+    data->early_suspend.resume = bma220_late_resume;
+    register_early_suspend(&data->early_suspend);
+#endif
+
+    INIT_DELAYED_WORK(&data->work, bma220_work_func);
+    
+    mutex_init(&data->enable_mutex);
+    atomic_set(&data->delay, BMA220_MAX_DELAY); 
+    atomic_set(&data->enable, 0);
+    atomic_set(&data->calibrated, 0);
+    atomic_set(&data->fuzz, FUZZ);
+    
+    bma220_set_bandwidth(client, BMA220_BW_SET);
+    bma220_set_range(client, BMA220_RANGE_SET);
+
+    return 0;
+
+error_sysfs:
+    input_unregister_device(data->input);
+kfree_exit:
+    kfree(data);
+exit:
+    return err;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma220_early_suspend(struct early_suspend *h)
+{
+    // sensor hal will disable when early suspend
+}
+
+
+static void bma220_late_resume(struct early_suspend *h)
+{
+    // sensor hal will enable when early resume
+}
+#endif
+
+static int bma220_remove(struct i2c_client *client)
+{
+    struct bma220_data *data = i2c_get_clientdata(client);
+
+    bma220_set_enable(&client->dev, 0);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    unregister_early_suspend(&data->early_suspend);
+#endif
+    sysfs_remove_group(&data->input->dev.kobj, &bma220_attribute_group);
+    input_unregister_device(data->input);
+    kfree(data);
+
+    return 0;
+}
+#ifdef CONFIG_PM
+
+static int bma220_suspend(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *data = i2c_get_clientdata(client);
+    
+    // save offset
+    bma220_get_offset_filt_xyz(data->bma220_client, 
+                data->offset_saved, sizeof(data->offset_saved));
+                
+    bma220_do_enable(dev, 0);  
+    
+    return 0;
+}
+
+static int bma220_resume(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma220_data *data = i2c_get_clientdata(client);
+
+    bma220_soft_reset(client);
+
+    bma220_set_bandwidth(client, BMA220_BW_SET);
+
+    bma220_set_range(client, BMA220_RANGE_SET);
+
+
+     /*restore offset,must before bma220_do_enable,
+     because i2c can't write to bma220 when suspend.
+     */
+    bma220_set_offset_filt_xyz(data->bma220_client, 
+                data->offset_saved, sizeof(data->offset_saved));
+
+
+    bma220_do_enable(dev, atomic_read(&data->enable));
+    
+    return 0;
+}
+
+#else
+
+#define bma220_suspend        NULL
+#define bma220_resume        NULL
+
+#endif /* CONFIG_PM */
+
+static SIMPLE_DEV_PM_OPS(bma220_pm_ops, bma220_suspend, bma220_resume);
+
+static const unsigned short  bma220_addresses[] = {
+    SENSOR_I2C_ADDR,
+    I2C_CLIENT_END,
+};
+
+static const struct i2c_device_id bma220_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, bma220_id);
+
+static int bma220_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+  struct i2c_adapter *adapter = client->adapter;
+
+  if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+    return -ENODEV;
+  strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+
+  return 0;
+}
+
+static struct i2c_driver bma220_driver = {
+    .driver = {
+        .owner    = THIS_MODULE,
+        .name    = SENSOR_NAME,
+        .pm    = &bma220_pm_ops,
+    },
+    .class        = I2C_CLASS_HWMON,
+    .address_list    = bma220_addresses,
+    .detect = bma220_detect,
+    .id_table    = bma220_id,
+    .probe        = bma220_probe,
+    .remove        = bma220_remove,
+
+};
+
+static struct i2c_board_info bma220_board_info={
+    .type = SENSOR_NAME, 
+    .addr = SENSOR_I2C_ADDR,
+};
+
+
+static int __init BMA220_init(void)
+{
+	return i2c_add_driver(&bma220_driver);
+}
+
+static void __exit BMA220_exit(void)
+{
+    i2c_del_driver(&bma220_driver);
+}
+
+MODULE_AUTHOR("Albert Zhang <xu.zhang@bosch-sensortec.com>");
+MODULE_DESCRIPTION("BMA220 accelerometer sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(BMA220_init);
+module_exit(BMA220_exit);
+
diff --git a/drivers/input/misc/gsensor/bma222.c b/drivers/input/misc/gsensor/bma222.c
new file mode 100755
index 0000000..1e68777
--- /dev/null
+++ b/drivers/input/misc/gsensor/bma222.c
@@ -0,0 +1,2014 @@
+/* file bma222.c
+   brief This file contains all function implementations for the bma222 in linux
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/uaccess.h>
+//#include "gsensor_common.h"
+
+#define SENSOR_NAME     "bma222"
+#define ABSMIN                -512
+#define ABSMAX                512
+#define FUZZ                     0
+
+#define SENSOR_NAME2    "bma222t"
+#define ABSMIN2                (24*2-128)
+#define ABSMAX2               (24*2+127)
+#define FUZZ2                    1
+
+#define bma222_MAX_DELAY        200
+#define bma222_CHIP_ID            2
+#define bma222E_CHIP_ID            248
+#define bma222_RANGE_SET        0
+#define bma222_BW_SET            4
+
+#define bma222_CHIP_ID_REG                      0x00
+#define bma222_VERSION_REG                      0x01
+#define bma222_X_AXIS_LSB_REG                   0x02
+#define bma222_X_AXIS_MSB_REG                   0x03
+#define bma222_Y_AXIS_LSB_REG                   0x04
+#define bma222_Y_AXIS_MSB_REG                   0x05
+#define bma222_Z_AXIS_LSB_REG                   0x06
+#define bma222_Z_AXIS_MSB_REG                   0x07
+#define bma222_TEMP_RD_REG                      0x08
+#define bma222_RANGE_SEL_REG                    0x0F
+#define bma222_BW_SEL_REG                       0x10
+#define bma222_MODE_CTRL_REG                    0x11
+#define bma222_SELF_TEST_REG                    0x32
+#define bma222_OFFSET_CTRL_REG                  0x36
+#define bma222_OFFSET_PARAMS_REG                0x37
+#define bma222_OFFSET_FILT_X_REG                0x38
+#define bma222_OFFSET_FILT_Y_REG                0x39
+#define bma222_OFFSET_FILT_Z_REG                0x3A
+
+#define bma222_ACC_X_LSB__POS           0
+#define bma222_ACC_X_LSB__LEN           0
+#define bma222_ACC_X_LSB__MSK           0x00
+#define bma222_ACC_X_LSB__REG           bma222_X_AXIS_LSB_REG
+
+#define bma222_ACC_X_MSB__POS           0
+#define bma222_ACC_X_MSB__LEN           8
+#define bma222_ACC_X_MSB__MSK           0xFF
+#define bma222_ACC_X_MSB__REG           bma222_X_AXIS_MSB_REG
+
+#define bma222_ACC_Y_LSB__POS           0
+#define bma222_ACC_Y_LSB__LEN           0
+#define bma222_ACC_Y_LSB__MSK           0x00
+#define bma222_ACC_Y_LSB__REG           bma222_Y_AXIS_LSB_REG
+
+#define bma222_ACC_Y_MSB__POS           0
+#define bma222_ACC_Y_MSB__LEN           8
+#define bma222_ACC_Y_MSB__MSK           0xFF
+#define bma222_ACC_Y_MSB__REG           bma222_Y_AXIS_MSB_REG
+
+#define bma222_ACC_Z_LSB__POS           0
+#define bma222_ACC_Z_LSB__LEN           0
+#define bma222_ACC_Z_LSB__MSK           0x00
+#define bma222_ACC_Z_LSB__REG           bma222_Z_AXIS_LSB_REG
+
+#define bma222_ACC_Z_MSB__POS           0
+#define bma222_ACC_Z_MSB__LEN           8
+#define bma222_ACC_Z_MSB__MSK           0xFF
+#define bma222_ACC_Z_MSB__REG           bma222_Z_AXIS_MSB_REG
+
+#define bma222_RANGE_SEL__POS             0
+#define bma222_RANGE_SEL__LEN             4
+#define bma222_RANGE_SEL__MSK             0x0F
+#define bma222_RANGE_SEL__REG             bma222_RANGE_SEL_REG
+
+#define bma222_BANDWIDTH__POS             0
+#define bma222_BANDWIDTH__LEN             5
+#define bma222_BANDWIDTH__MSK             0x1F
+#define bma222_BANDWIDTH__REG             bma222_BW_SEL_REG
+
+#define bma222_EN_LOW_POWER__POS          6
+#define bma222_EN_LOW_POWER__LEN          1
+#define bma222_EN_LOW_POWER__MSK          0x40
+#define bma222_EN_LOW_POWER__REG          bma222_MODE_CTRL_REG
+
+#define bma222_EN_SUSPEND__POS          5
+#define bma222_EN_SUSPEND__LEN            1
+#define bma222_EN_SUSPEND__MSK            0x20
+#define bma222_EN_SUSPEND__REG            bma222_MODE_CTRL_REG
+
+#define bma222_EN_SELF_TEST__POS                0
+#define bma222_EN_SELF_TEST__LEN                2
+#define bma222_EN_SELF_TEST__MSK                0x03
+#define bma222_EN_SELF_TEST__REG                bma222_SELF_TEST_REG
+
+#define bma222_NEG_SELF_TEST__POS               2
+#define bma222_NEG_SELF_TEST__LEN               1
+#define bma222_NEG_SELF_TEST__MSK               0x04
+#define bma222_NEG_SELF_TEST__REG               bma222_SELF_TEST_REG
+
+#define bma222_RESET_FAST_COMP__POS                7
+#define bma222_RESET_FAST_COMP__LEN                1
+#define bma222_RESET_FAST_COMP__MSK                0x80
+#define bma222_RESET_FAST_COMP__REG                bma222_OFFSET_CTRL_REG
+
+#define bma222_EN_FAST_COMP__POS                5
+#define bma222_EN_FAST_COMP__LEN                2
+#define bma222_EN_FAST_COMP__MSK                0x60
+#define bma222_EN_FAST_COMP__REG                bma222_OFFSET_CTRL_REG
+
+#define bma222_FAST_COMP_RDY_S__POS             4
+#define bma222_FAST_COMP_RDY_S__LEN             1
+#define bma222_FAST_COMP_RDY_S__MSK             0x10
+#define bma222_FAST_COMP_RDY_S__REG             bma222_OFFSET_CTRL_REG
+
+#define bma222_COMP_TARGET_OFFSET_X__POS        1
+#define bma222_COMP_TARGET_OFFSET_X__LEN        2
+#define bma222_COMP_TARGET_OFFSET_X__MSK        0x06
+#define bma222_COMP_TARGET_OFFSET_X__REG        bma222_OFFSET_PARAMS_REG
+
+#define bma222_COMP_TARGET_OFFSET_Y__POS        3
+#define bma222_COMP_TARGET_OFFSET_Y__LEN        2
+#define bma222_COMP_TARGET_OFFSET_Y__MSK        0x18
+#define bma222_COMP_TARGET_OFFSET_Y__REG        bma222_OFFSET_PARAMS_REG
+
+#define bma222_COMP_TARGET_OFFSET_Z__POS        5
+#define bma222_COMP_TARGET_OFFSET_Z__LEN        2
+#define bma222_COMP_TARGET_OFFSET_Z__MSK        0x60
+#define bma222_COMP_TARGET_OFFSET_Z__REG        bma222_OFFSET_PARAMS_REG
+
+#define bma222_RANGE_2G                 0
+#define bma222_RANGE_4G                 1
+#define bma222_RANGE_8G                 2
+#define bma222_RANGE_16G                3
+
+#define bma222_BW_7_81HZ        0x08
+#define bma222_BW_15_63HZ       0x09
+#define bma222_BW_31_25HZ       0x0A
+#define bma222_BW_62_50HZ       0x0B
+#define bma222_BW_125HZ         0x0C
+#define bma222_BW_250HZ         0x0D
+#define bma222_BW_500HZ         0x0E
+#define bma222_BW_1000HZ        0x0F
+
+#define bma222_MODE_NORMAL      0
+#define bma222_MODE_LOWPOWER    1
+#define bma222_MODE_SUSPEND     2
+
+
+#define bma222_GET_BITSLICE(regvar, bitname)\
+    ((regvar & bitname##__MSK) >> bitname##__POS)
+
+
+#define bma222_SET_BITSLICE(regvar, bitname, val)\
+    ((regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK))
+
+
+struct bma222acc{
+    s16    x,
+        y,
+        z,
+        temp;
+} ;
+
+struct bma222_data {
+    struct i2c_client *bma222_client;
+    struct mutex enable_mutex;
+    atomic_t selftest_result;
+    
+    atomic_t delay;
+    atomic_t enable;
+    struct input_dev *input;
+    struct delayed_work work;
+    
+    atomic_t delay2;
+    atomic_t enable2;
+    struct input_dev *input2;
+    struct delayed_work work2;
+    
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend early_suspend;
+#endif
+    atomic_t fuzz;
+    atomic_t position;
+    atomic_t calibrated;
+    unsigned char offset_saved[3];
+};
+
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  1
+
+// calibration file path
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma222_early_suspend(struct early_suspend *h);
+static void bma222_late_resume(struct early_suspend *h);
+#endif
+
+static int bma222_smbus_read_byte(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data)
+{
+    s32 dummy;
+    dummy = i2c_smbus_read_byte_data(client, reg_addr);
+    if (dummy < 0)
+        return -1;
+    *data = dummy & 0x000000ff;
+
+    return 0;
+}
+
+static int bma222_smbus_write_byte(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data)
+{
+    s32 dummy;
+    dummy = i2c_smbus_write_byte_data(client, reg_addr, *data);
+    if (dummy < 0)
+        return -1;
+    return 0;
+}
+
+static int bma222_smbus_read_byte_block(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    dummy = i2c_smbus_read_i2c_block_data(client, reg_addr, len, data);
+    if (dummy < 0)
+        return -1;
+    return 0;
+}
+
+static int bma222_smbus_write_byte_block(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    s32 idx;
+    
+    //bma222 only support byte data write
+    for (idx = 0; idx < len; idx ++)
+    {
+        dummy = i2c_smbus_write_byte_data(client, reg_addr+idx, data[idx]);
+        if (dummy < 0)
+            return -1;
+    }
+    
+    return 0;
+}
+static int bma222_set_mode(struct i2c_client *client, unsigned char Mode)
+{
+    int comres = 0;
+    unsigned char data1 = 0;
+
+    if (Mode < 3) {
+        comres = bma222_smbus_read_byte(client,
+                bma222_EN_LOW_POWER__REG, &data1);
+        switch (Mode) {
+        case bma222_MODE_NORMAL:
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_EN_LOW_POWER, 0);
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_EN_SUSPEND, 0);
+            break;
+        case bma222_MODE_LOWPOWER:
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_EN_LOW_POWER, 1);
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_EN_SUSPEND, 0);
+            break;
+        case bma222_MODE_SUSPEND:
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_EN_LOW_POWER, 0);
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_EN_SUSPEND, 1);
+            break;
+        default:
+            break;
+        }
+
+        comres += bma222_smbus_write_byte(client,
+                bma222_EN_LOW_POWER__REG, &data1);
+    } else{
+        comres = -1;
+    }
+
+    return comres;
+}
+
+static int bma222_get_mode(struct i2c_client *client, unsigned char *Mode)
+{
+    int comres = 0;
+
+    comres = bma222_smbus_read_byte(client,
+            bma222_EN_LOW_POWER__REG, Mode);
+    *Mode  = (*Mode) >> 6;
+
+    return comres;
+}
+
+static int bma222_set_range(struct i2c_client *client, unsigned char Range)
+{
+    int comres = 0;
+    unsigned char data1 = 0;
+
+    if (Range < 4) {
+        comres = bma222_smbus_read_byte(client,
+                bma222_RANGE_SEL_REG, &data1);
+        switch (Range) {
+        case 0:
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_RANGE_SEL, 3);
+            break;
+        case 1:
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_RANGE_SEL, 5);
+            break;
+        case 2:
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_RANGE_SEL, 8);
+            break;
+        case 3:
+            data1  = bma222_SET_BITSLICE(data1,
+                    bma222_RANGE_SEL, 12);
+            break;
+        default:
+            break;
+        }
+        comres += bma222_smbus_write_byte(client,
+                bma222_RANGE_SEL_REG, &data1);
+    } else{
+        comres = -1;
+    }
+
+    return comres;
+}
+
+static int bma222_get_range(struct i2c_client *client, unsigned char *Range)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma222_smbus_read_byte(client, bma222_RANGE_SEL__REG,
+            &data);
+    data = bma222_GET_BITSLICE(data, bma222_RANGE_SEL);
+    *Range = data;
+
+    return comres;
+}
+
+
+static int bma222_set_bandwidth(struct i2c_client *client, unsigned char BW)
+{
+    int comres = 0;
+    unsigned char data = 0;
+    int Bandwidth = 0;
+
+    if (BW < 8) {
+        switch (BW) {
+        case 0:
+            Bandwidth = bma222_BW_7_81HZ;
+            break;
+        case 1:
+            Bandwidth = bma222_BW_15_63HZ;
+            break;
+        case 2:
+            Bandwidth = bma222_BW_31_25HZ;
+            break;
+        case 3:
+            Bandwidth = bma222_BW_62_50HZ;
+            break;
+        case 4:
+            Bandwidth = bma222_BW_125HZ;
+            break;
+        case 5:
+            Bandwidth = bma222_BW_250HZ;
+            break;
+        case 6:
+            Bandwidth = bma222_BW_500HZ;
+            break;
+        case 7:
+            Bandwidth = bma222_BW_1000HZ;
+            break;
+        default:
+            break;
+        }
+        comres = bma222_smbus_read_byte(client,
+                bma222_BANDWIDTH__REG, &data);
+        data = bma222_SET_BITSLICE(data, bma222_BANDWIDTH,
+                Bandwidth);
+        comres += bma222_smbus_write_byte(client,
+                bma222_BANDWIDTH__REG, &data);
+    } else{
+        comres = -1;
+    }
+
+    return comres;
+}
+
+static int bma222_get_bandwidth(struct i2c_client *client, unsigned char *BW)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_BANDWIDTH__REG,
+            &data);
+    data = bma222_GET_BITSLICE(data, bma222_BANDWIDTH);
+    if (data <= 8) {
+        *BW = 0;
+    } else{
+        if (data >= 0x0F)
+            *BW = 7;
+        else
+            *BW = data - 8;
+    }
+
+    return comres;
+}
+
+static int bma222_set_offset_target_x(struct i2c_client *client, unsigned char
+        offsettarget)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client,
+            bma222_COMP_TARGET_OFFSET_X__REG, &data);
+    data = bma222_SET_BITSLICE(data, bma222_COMP_TARGET_OFFSET_X,
+            offsettarget);
+    comres = bma222_smbus_write_byte(client,
+            bma222_COMP_TARGET_OFFSET_X__REG, &data);
+
+    return comres;
+}
+
+static int bma222_get_offset_target_x(struct i2c_client *client, unsigned char
+        *offsettarget)
+{
+    int comres = 0 ;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_OFFSET_PARAMS_REG,
+            &data);
+    data = bma222_GET_BITSLICE(data, bma222_COMP_TARGET_OFFSET_X);
+    *offsettarget = data;
+
+    return comres;
+}
+
+static int bma222_set_offset_target_y(struct i2c_client *client, unsigned char
+        offsettarget)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client,
+            bma222_COMP_TARGET_OFFSET_Y__REG, &data);
+    data = bma222_SET_BITSLICE(data, bma222_COMP_TARGET_OFFSET_Y,
+            offsettarget);
+    comres = bma222_smbus_write_byte(client,
+            bma222_COMP_TARGET_OFFSET_Y__REG, &data);
+
+    return comres;
+}
+
+static int bma222_get_offset_target_y(struct i2c_client *client, unsigned char
+        *offsettarget)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_OFFSET_PARAMS_REG,
+            &data);
+    data = bma222_GET_BITSLICE(data, bma222_COMP_TARGET_OFFSET_Y);
+    *offsettarget = data;
+
+    return comres;
+}
+
+static int bma222_set_offset_target_z(struct i2c_client *client, unsigned char
+        offsettarget)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client,
+            bma222_COMP_TARGET_OFFSET_Z__REG, &data);
+    data = bma222_SET_BITSLICE(data, bma222_COMP_TARGET_OFFSET_Z,
+            offsettarget);
+    comres = bma222_smbus_write_byte(client,
+            bma222_COMP_TARGET_OFFSET_Z__REG, &data);
+
+    return comres;
+}
+
+static int bma222_get_offset_target_z(struct i2c_client *client, unsigned char
+        *offsettarget)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_OFFSET_PARAMS_REG,
+            &data);
+    data = bma222_GET_BITSLICE(data, bma222_COMP_TARGET_OFFSET_Z);
+    *offsettarget = data;
+
+    return comres;
+}
+
+static int bma222_get_cal_ready(struct i2c_client *client, unsigned char
+        *calrdy)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_OFFSET_CTRL_REG, &data);
+    data = bma222_GET_BITSLICE(data, bma222_FAST_COMP_RDY_S);
+    *calrdy = data;
+
+    return comres;
+}
+
+static int bma222_reset_cal_offset(struct i2c_client *client)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_RESET_FAST_COMP__REG,
+            &data);
+    data = bma222_SET_BITSLICE(data, bma222_RESET_FAST_COMP, 1);
+    comres = bma222_smbus_write_byte(client, bma222_RESET_FAST_COMP__REG,
+            &data);
+
+    return comres;
+}
+
+static int bma222_set_cal_trigger(struct i2c_client *client, unsigned char
+        caltrigger)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_EN_FAST_COMP__REG,
+            &data);
+    data = bma222_SET_BITSLICE(data, bma222_EN_FAST_COMP, caltrigger);
+    comres = bma222_smbus_write_byte(client, bma222_EN_FAST_COMP__REG,
+            &data);
+
+    return comres;
+}
+
+static int bma222_set_selftest_st(struct i2c_client *client, unsigned char
+        selftest)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_EN_SELF_TEST__REG,
+            &data);
+    data = bma222_SET_BITSLICE(data, bma222_EN_SELF_TEST, selftest);
+    comres = bma222_smbus_write_byte(client, bma222_EN_SELF_TEST__REG,
+            &data);
+
+    return comres;
+}
+
+static int bma222_set_selftest_stn(struct i2c_client *client, unsigned char stn)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_NEG_SELF_TEST__REG,
+            &data);
+    data = bma222_SET_BITSLICE(data, bma222_NEG_SELF_TEST, stn);
+    comres = bma222_smbus_write_byte(client, bma222_NEG_SELF_TEST__REG,
+            &data);
+
+    return comres;
+}
+static int bma222_read_accel_x(struct i2c_client *client, short *a_x)
+{
+    int comres;
+    unsigned char data[2] = {0};
+
+    comres = bma222_smbus_read_byte_block(client, bma222_ACC_X_LSB__REG,
+            data, 2);
+    *a_x = bma222_GET_BITSLICE(data[0], bma222_ACC_X_LSB) |
+        (bma222_GET_BITSLICE(data[1],
+                     bma222_ACC_X_MSB)<<bma222_ACC_X_LSB__LEN);
+    *a_x = *a_x <<
+        (sizeof(short)*8-(bma222_ACC_X_LSB__LEN+bma222_ACC_X_MSB__LEN));
+    *a_x = *a_x >>
+        (sizeof(short)*8-(bma222_ACC_X_LSB__LEN+bma222_ACC_X_MSB__LEN));
+
+    return comres;
+}
+static int bma222_read_accel_y(struct i2c_client *client, short *a_y)
+{
+    int comres;
+    unsigned char data[2];
+
+    comres = bma222_smbus_read_byte_block(client, bma222_ACC_Y_LSB__REG,
+            data, 2);
+    *a_y = bma222_GET_BITSLICE(data[0], bma222_ACC_Y_LSB) |
+        (bma222_GET_BITSLICE(data[1],
+                     bma222_ACC_Y_MSB)<<bma222_ACC_Y_LSB__LEN);
+    *a_y = *a_y <<
+        (sizeof(short)*8-(bma222_ACC_Y_LSB__LEN+bma222_ACC_Y_MSB__LEN));
+    *a_y = *a_y >>
+        (sizeof(short)*8-(bma222_ACC_Y_LSB__LEN+bma222_ACC_Y_MSB__LEN));
+
+    return comres;
+}
+
+static int bma222_read_accel_z(struct i2c_client *client, short *a_z)
+{
+    int comres;
+    unsigned char data[2];
+
+    comres = bma222_smbus_read_byte_block(client, bma222_ACC_Z_LSB__REG,
+            data, 2);
+    *a_z = bma222_GET_BITSLICE(data[0], bma222_ACC_Z_LSB) |
+        bma222_GET_BITSLICE(data[1],
+                bma222_ACC_Z_MSB)<<bma222_ACC_Z_LSB__LEN;
+    *a_z = *a_z <<
+        (sizeof(short)*8-(bma222_ACC_Z_LSB__LEN+bma222_ACC_Z_MSB__LEN));
+    *a_z = *a_z >>
+        (sizeof(short)*8-(bma222_ACC_Z_LSB__LEN+bma222_ACC_Z_MSB__LEN));
+
+    return comres;
+}
+
+static int bma222_read_accel_xyz(struct i2c_client *client,
+        struct bma222acc *acc)
+{
+    int comres;
+    unsigned char data[6];
+
+    comres = bma222_smbus_read_byte_block(client,
+            bma222_ACC_X_LSB__REG, data, 6);
+
+    acc->x = bma222_GET_BITSLICE(data[0], bma222_ACC_X_LSB)
+        |(bma222_GET_BITSLICE(data[1],
+                bma222_ACC_X_MSB)<<bma222_ACC_X_LSB__LEN);
+    acc->x = acc->x << (sizeof(short)*8-(bma222_ACC_X_LSB__LEN
+                + bma222_ACC_X_MSB__LEN));
+    acc->x = acc->x >> (sizeof(short)*8-(bma222_ACC_X_LSB__LEN
+                + bma222_ACC_X_MSB__LEN));
+    acc->y = bma222_GET_BITSLICE(data[2], bma222_ACC_Y_LSB)
+        | (bma222_GET_BITSLICE(data[3],
+                bma222_ACC_Y_MSB)<<bma222_ACC_Y_LSB__LEN);
+    acc->y = acc->y << (sizeof(short)*8-(bma222_ACC_Y_LSB__LEN
+                + bma222_ACC_Y_MSB__LEN));
+    acc->y = acc->y >> (sizeof(short)*8-(bma222_ACC_Y_LSB__LEN
+                + bma222_ACC_Y_MSB__LEN));
+
+    acc->z = bma222_GET_BITSLICE(data[4], bma222_ACC_Z_LSB)
+        | (bma222_GET_BITSLICE(data[5],
+                bma222_ACC_Z_MSB)<<bma222_ACC_Z_LSB__LEN);
+    acc->z = acc->z << (sizeof(short)*8-(bma222_ACC_Z_LSB__LEN
+                + bma222_ACC_Z_MSB__LEN));
+    acc->z = acc->z >> (sizeof(short)*8-(bma222_ACC_Z_LSB__LEN
+                + bma222_ACC_Z_MSB__LEN));
+
+    return comres;
+}
+
+static int bma222_read_temperature(struct i2c_client *client,
+        struct bma222acc *acc)
+{
+    int comres;
+    unsigned char data = 0;
+
+    comres = bma222_smbus_read_byte(client, bma222_TEMP_RD_REG, &data);
+    acc->temp = 24 * 2 + (signed char)data;
+
+    return comres;
+}
+
+static int bma222_set_offset_filt_xyz(struct i2c_client *client, unsigned char
+        *offset, int len)
+{
+    int comres = 0;
+	
+    comres = bma222_smbus_write_byte_block(client, bma222_OFFSET_FILT_X_REG, offset, len);
+        
+    return comres;
+}
+
+static int bma222_get_offset_filt_xyz(struct i2c_client *client, unsigned char
+        *offset, int len)
+{
+    int comres = 0 ;
+
+    comres = bma222_smbus_read_byte_block(client, bma222_OFFSET_FILT_X_REG,    offset, len);
+
+	return comres;
+}
+
+static int bma222_read_file(char *path, char *buf, int size)
+{
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+static int bma222_load_user_calibration(struct i2c_client *client)
+{
+    char buffer[16];
+    int ret = 0;
+    int data[3];
+    unsigned char offset[3];
+    struct bma222_data *bma222 = i2c_get_clientdata(client);    
+    int calibrated = atomic_read(&bma222->calibrated);
+    
+    // only calibrate once
+    if (calibrated) {
+        goto usr_calib_end;
+    } else {
+        atomic_set(&bma222->calibrated, 1);
+    }
+
+    ret = bma222_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d", &data[0], &data[1], &data[2]);
+    offset[0] = (unsigned char) data[0];
+    offset[1] = (unsigned char) data[1];
+    offset[2] = (unsigned char) data[2];    
+    
+    printk(KERN_INFO "user cfg_calibration: %d %d %d\n", offset[0], offset[1], offset[2]);
+    
+    if (bma222_set_offset_filt_xyz(bma222->bma222_client, offset, sizeof(offset)) < 0) {
+        printk(KERN_ERR"set offset fail\n");
+        goto usr_calib_end;
+    }
+    
+    printk(KERN_INFO "load user calibration finished\n");
+    
+usr_calib_end:
+    return ret;
+}
+
+static int bma222_axis_remap(struct i2c_client *client,
+        struct bma222acc *acc)
+{
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    s16 swap;
+    int bma_position = atomic_read(&bma222->position);
+
+    switch (abs(bma_position)) {
+        case 1:
+            acc->x = -(acc->x);
+            acc->y = -(acc->y);
+            break;
+        case 2:
+            swap = acc->x;
+            acc->x = -acc->y;
+            acc->y = swap;
+            break;
+        case 3:
+            break;
+        case 4:
+            swap = acc->x;
+            acc->x = acc->y;
+            acc->y = -swap; 
+            break;
+    }
+    
+    if (bma_position < 0) {
+        acc->z = -(acc->z);
+        acc->x = -(acc->x);
+    }
+    
+    return 0;
+}
+
+static void bma222_work_func(struct work_struct *work)
+{
+    struct bma222_data *bma222 = container_of((struct delayed_work *)work,
+            struct bma222_data, work);
+    static struct bma222acc acc;
+    unsigned long delay = msecs_to_jiffies(atomic_read(&bma222->delay));
+
+    bma222_load_user_calibration(bma222->bma222_client);
+    
+    bma222_read_accel_xyz(bma222->bma222_client, &acc);
+    bma222_axis_remap(bma222->bma222_client, &acc);
+    input_report_abs(bma222->input, ABS_X, acc.x);
+    input_report_abs(bma222->input, ABS_Y, acc.y);
+    input_report_abs(bma222->input, ABS_Z, acc.z);
+    input_sync(bma222->input);
+    
+    schedule_delayed_work(&bma222->work, delay);
+}
+
+static void bma222_work_func2(struct work_struct *work)
+{
+    struct bma222_data *bma222 = container_of((struct delayed_work *)work,
+            struct bma222_data, work2);
+    static struct bma222acc acc;
+    unsigned long delay = msecs_to_jiffies(atomic_read(&bma222->delay2));
+    
+    bma222_read_temperature(bma222->bma222_client, &acc);
+    input_report_abs(bma222->input2, ABS_MISC, acc.temp);
+    input_sync(bma222->input2);
+    
+    schedule_delayed_work(&bma222->work2, delay);
+}
+
+static ssize_t bma222_register_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int address, value;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    sscanf(buf, "0x%x=0x%x", &address, &value);
+
+    if (bma222_smbus_write_byte(bma222->bma222_client, (unsigned char)address,
+                (unsigned char *)&value) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma222_register_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    size_t count = 0;
+    u8 reg[0x3d];
+    int i;
+
+    for (i = 0 ; i <= 0x3d; i++) {
+        bma222_smbus_read_byte(bma222->bma222_client, i, reg+i);
+
+        count += sprintf(&buf[count], "0x%x: 0x%x\n", i, reg[i]);
+    }
+    return count;
+
+
+}
+
+static ssize_t bma222_range_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    if (bma222_get_range(bma222->bma222_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma222_range_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (bma222_set_range(bma222->bma222_client, (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma222_bandwidth_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    if (bma222_get_bandwidth(bma222->bma222_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_bandwidth_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (bma222_set_bandwidth(bma222->bma222_client,
+                (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma222_mode_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    if (bma222_get_mode(bma222->bma222_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma222_mode_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (bma222_set_mode(bma222->bma222_client, (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+
+static ssize_t bma222_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct input_dev *input = to_input_dev(dev);
+    struct bma222_data *bma222 = input_get_drvdata(input);
+    struct bma222acc acc;
+    
+    bma222_read_accel_xyz(bma222->bma222_client, &acc);
+    bma222_axis_remap(bma222->bma222_client, &acc);
+
+    return sprintf(buf, "%d %d %d\n", acc.x, acc.y, acc.z);
+}
+
+static ssize_t bma222_delay_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma222->delay));
+
+}
+
+static ssize_t bma222_delay_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    unsigned char bandwidth;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (data > bma222_MAX_DELAY)
+        data = bma222_MAX_DELAY;
+    atomic_set(&bma222->delay, (unsigned int) data);
+
+    // change band width
+    data = 1000 / data;
+    if (data > 500) {
+        bandwidth = 7;
+    } else if (data > 250) {
+        bandwidth = 6;
+    } else if (data > 125) {
+        bandwidth = 5;
+    } else if (data > 62) {
+        bandwidth = 4;
+    } else if (data > 31) {
+        bandwidth = 3;
+    } else {
+        bandwidth = 2;
+    }
+    bma222_set_bandwidth(bma222->bma222_client, bandwidth);
+    
+    return count;
+}
+
+static ssize_t bma222_enable_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma222->enable));
+
+}
+
+static void bma222_do_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    int used = enable || atomic_read(&bma222->enable2);
+	
+	if(enable == 0)//add by sujiewei(2014-12-11),save offset before turn off gsensor 
+	{
+		bma222_get_offset_filt_xyz(bma222->bma222_client, 
+				bma222->offset_saved, sizeof(bma222->offset_saved));
+	}
+
+    if (used) {
+        bma222_set_mode(bma222->bma222_client,
+                bma222_MODE_NORMAL);
+    } else {
+        bma222_set_mode(bma222->bma222_client,
+                bma222_MODE_SUSPEND);
+    }
+
+    if (enable) {
+        schedule_delayed_work(&bma222->work,
+            msecs_to_jiffies(atomic_read(&bma222->delay)));
+    } else {
+        cancel_delayed_work_sync(&bma222->work);
+    }
+	
+	if(enable == 1)//add by sujiewei(2014-12-11),get offset after turn on gsensor
+	{
+		mdelay(2);	//delay for set offset accurately
+		bma222_set_offset_filt_xyz(bma222->bma222_client, 
+                bma222->offset_saved, sizeof(bma222->offset_saved));
+	}
+}
+
+static void bma222_set_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    int pre_enable = atomic_read(&bma222->enable);
+
+    mutex_lock(&bma222->enable_mutex);
+    if (enable != pre_enable) {
+        bma222_do_enable(dev, enable);
+        atomic_set(&bma222->enable, enable);
+    }
+    mutex_unlock(&bma222->enable_mutex);
+}
+
+static ssize_t bma222_enable_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if ((data == 0) || (data == 1)) {
+        bma222_set_enable(dev, data);
+    }
+
+    return count;
+}
+
+static ssize_t bma222_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    data = atomic_read(&(bma222->position));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma222_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(bma222->position), (int) data);
+
+    return count;
+}
+
+static ssize_t bma222_fast_calibration_x_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+
+
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    if (bma222_get_offset_target_x(bma222->bma222_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_fast_calibration_x_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    signed char tmp;
+    unsigned char timeout = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (bma222_set_offset_target_x(bma222->bma222_client, (unsigned
+                    char)data) < 0)
+        return -EINVAL;
+
+    if (bma222_set_cal_trigger(bma222->bma222_client, 1) < 0)
+        return -EINVAL;
+
+    do {
+        mdelay(2);
+        bma222_get_cal_ready(bma222->bma222_client, &tmp);
+
+    /*    printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+        timeout++;
+        if (timeout == 500) {
+            printk(KERN_INFO "get fast calibration ready error\n");
+            return -EINVAL;
+        };
+
+    } while (tmp == 0);
+
+    printk(KERN_INFO "x axis fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma222_fast_calibration_y_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+
+
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    if (bma222_get_offset_target_y(bma222->bma222_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma222_fast_calibration_y_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    signed char tmp;
+    unsigned char timeout = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (bma222_set_offset_target_y(bma222->bma222_client, (unsigned
+                    char)data) < 0)
+        return -EINVAL;
+
+    if (bma222_set_cal_trigger(bma222->bma222_client, 2) < 0)
+        return -EINVAL;
+
+    do {
+        mdelay(2);
+        bma222_get_cal_ready(bma222->bma222_client, &tmp);
+
+    /*    printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+        timeout++;
+        if (timeout == 500) {
+            printk(KERN_INFO "get fast calibration ready error\n");
+            return -EINVAL;
+        };
+
+    } while (tmp == 0);
+
+    printk(KERN_INFO "y axis fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma222_fast_calibration_z_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    if (bma222_get_offset_target_z(bma222->bma222_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma222_fast_calibration_z_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    signed char tmp;
+    unsigned char timeout = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (bma222_set_offset_target_z(bma222->bma222_client, (unsigned
+                    char)data) < 0)
+        return -EINVAL;
+
+    if (bma222_set_cal_trigger(bma222->bma222_client, 3) < 0)
+        return -EINVAL;
+
+    do {
+        mdelay(2);
+        bma222_get_cal_ready(bma222->bma222_client, &tmp);
+
+    /*    printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+        timeout++;
+        if (timeout == 500) {
+            printk(KERN_INFO "get fast calibration ready error\n");
+            return -EINVAL;
+        };
+
+    } while (tmp == 0);
+
+    printk(KERN_INFO "z axis fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma222_selftest_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma222->selftest_result));
+}
+
+static ssize_t bma222_selftest_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    unsigned char clear_value = 0;
+    int error;
+    short value1 = 0;
+    short value2 = 0;
+    short diff = 0;
+    unsigned long result = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (data != 1)
+        return -EINVAL;
+    /* set to 2 G range */
+    if (bma222_set_range(bma222->bma222_client, 0) < 0)
+        return -EINVAL;
+
+    bma222_smbus_write_byte(bma222->bma222_client, 0x32, &clear_value);
+
+    bma222_set_selftest_st(bma222->bma222_client, 1); /* 1 for x-axis*/
+    bma222_set_selftest_stn(bma222->bma222_client, 0); /* positive
+                                  direction*/
+    mdelay(10);
+    bma222_read_accel_x(bma222->bma222_client, &value1);
+    bma222_set_selftest_stn(bma222->bma222_client, 1); /* negative
+                                  direction*/
+    mdelay(10);
+    bma222_read_accel_x(bma222->bma222_client, &value2);
+    diff = value1-value2;
+
+    printk(KERN_INFO "diff x is %d,value1 is %d, value2 is %d\n", diff,
+            value1, value2);
+
+    if (abs(diff) < 204)
+        result |= 1;
+
+    bma222_set_selftest_st(bma222->bma222_client, 2); /* 2 for y-axis*/
+    bma222_set_selftest_stn(bma222->bma222_client, 0); /* positive
+                                  direction*/
+    mdelay(10);
+    bma222_read_accel_y(bma222->bma222_client, &value1);
+    bma222_set_selftest_stn(bma222->bma222_client, 1); /* negative
+                                  direction*/
+    mdelay(10);
+    bma222_read_accel_y(bma222->bma222_client, &value2);
+    diff = value1-value2;
+    printk(KERN_INFO "diff y is %d,value1 is %d, value2 is %d\n", diff,
+            value1, value2);
+    if (abs(diff) < 204)
+        result |= 2;
+
+    bma222_set_selftest_st(bma222->bma222_client, 3); /* 3 for z-axis*/
+    bma222_set_selftest_stn(bma222->bma222_client, 0); /* positive
+                                  direction*/
+    mdelay(10);
+    bma222_read_accel_z(bma222->bma222_client, &value1);
+    bma222_set_selftest_stn(bma222->bma222_client, 1); /* negative
+                                  direction*/
+    mdelay(10);
+    bma222_read_accel_z(bma222->bma222_client, &value2);
+    diff = value1-value2;
+
+    printk(KERN_INFO "diff z is %d,value1 is %d, value2 is %d\n", diff,
+            value1, value2);
+    if (abs(diff) < 102)
+        result |= 4;
+
+    atomic_set(&bma222->selftest_result, (unsigned int)result);
+
+    printk(KERN_INFO "self test finished\n");
+    return count;
+}
+
+static ssize_t bma222_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    int bma_position = atomic_read(&bma222->position);
+    
+    bma222_fast_calibration_x_store(dev, attr, "0", 2);
+    bma222_fast_calibration_y_store(dev, attr, "0", 2);
+    if (bma_position > 0) {
+        bma222_fast_calibration_z_store(dev, attr, "1", 2); // z: +g
+    } else {
+        bma222_fast_calibration_z_store(dev, attr, "2", 2); // z: -g
+    }
+
+    if (bma222_get_offset_filt_xyz(bma222->bma222_client, offset, sizeof(offset)) < 0)
+        return sprintf((char*)buf, "Read error\n");
+    
+    cfg_calibration[0] = offset[0];
+    cfg_calibration[1] = offset[1];
+    cfg_calibration[2] = offset[2];
+    
+    printk(KERN_INFO "run fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma222_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    
+    bma222_reset_cal_offset(bma222->bma222_client);
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+
+    printk(KERN_INFO "reset fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma222_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    if (bma222_get_offset_filt_xyz(bma222->bma222_client, offset, sizeof(offset)) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d %d %d\n", offset[0], offset[1], offset[2]);
+}
+
+static ssize_t bma222_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[3];
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    sscanf(buf, "%d %d %d", &data[0], &data[1], &data[2]);
+    offset[0] = (unsigned char) data[0];
+    offset[1] = (unsigned char) data[1];
+    offset[2] = (unsigned char) data[2];
+    
+    if (bma222_set_offset_filt_xyz(bma222->bma222_client, offset, sizeof(offset)) < 0)
+        return -EINVAL;
+
+    printk(KERN_INFO "set fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma222_fuzz_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    data = atomic_read(&(bma222->fuzz));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma222_fuzz_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(bma222->fuzz), (int) data);
+    
+    if(bma222->input != NULL) {
+        bma222->input->absinfo[ABS_X].fuzz = data;
+        bma222->input->absinfo[ABS_Y].fuzz = data;
+        bma222->input->absinfo[ABS_Z].fuzz = data;
+    }
+    
+    return count;
+}
+
+static DEVICE_ATTR(range, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_range_show, bma222_range_store);
+static DEVICE_ATTR(bandwidth, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_bandwidth_show, bma222_bandwidth_store);
+static DEVICE_ATTR(mode, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_mode_show, bma222_mode_store);
+static DEVICE_ATTR(value, S_IRUGO,
+        bma222_value_show, NULL);
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_delay_show, bma222_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_enable_show, bma222_enable_store);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_board_position_show, bma222_board_position_store);
+static DEVICE_ATTR(reg, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_register_show, bma222_register_store);
+static DEVICE_ATTR(fast_calibration_x, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_fast_calibration_x_show,
+        bma222_fast_calibration_x_store);
+static DEVICE_ATTR(fast_calibration_y, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_fast_calibration_y_show,
+        bma222_fast_calibration_y_store);
+static DEVICE_ATTR(fast_calibration_z, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_fast_calibration_z_show,
+        bma222_fast_calibration_z_store);
+static DEVICE_ATTR(selftest, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_selftest_show, bma222_selftest_store);
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP,
+        NULL, bma222_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP,
+        NULL, bma222_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_calibration_value_show, bma222_calibration_value_store);
+static DEVICE_ATTR(fuzz, S_IRUGO|S_IWUSR|S_IWGRP,
+        bma222_fuzz_show, bma222_fuzz_store);
+
+static struct attribute *bma222_attributes[] = {
+    &dev_attr_range.attr,
+    &dev_attr_bandwidth.attr,
+    &dev_attr_mode.attr,
+    &dev_attr_value.attr,
+    &dev_attr_delay.attr,
+    &dev_attr_enable.attr,
+    &dev_attr_board_position.attr,
+    &dev_attr_reg.attr,
+    &dev_attr_fast_calibration_x.attr,
+    &dev_attr_fast_calibration_y.attr,
+    &dev_attr_fast_calibration_z.attr,
+    &dev_attr_selftest.attr,
+    &dev_attr_calibration_run.attr,
+    &dev_attr_calibration_reset.attr,
+    &dev_attr_calibration_value.attr,
+    &dev_attr_fuzz.attr,
+    NULL
+};
+
+static struct attribute_group bma222_attribute_group = {
+    .attrs = bma222_attributes
+};
+
+static ssize_t bma222_value2_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct input_dev *input = to_input_dev(dev);
+    struct bma222_data *bma222 = input_get_drvdata(input);
+    struct bma222acc acc;
+    
+    bma222_read_temperature(bma222->bma222_client, &acc);
+
+    return sprintf(buf, "%d\n", acc.temp);
+}
+
+static ssize_t bma222_delay2_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma222->delay2));
+
+}
+
+static ssize_t bma222_delay2_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+        
+    if (data > bma222_MAX_DELAY)
+        data = bma222_MAX_DELAY;
+        
+    atomic_set(&bma222->delay2, (unsigned int) data);
+
+    return count;
+}
+
+static ssize_t bma222_enable2_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma222->enable2));
+
+}
+
+static void bma222_do_enable2(struct device *dev, int enable2)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    int used = enable2 || atomic_read(&bma222->enable);
+
+    if (used) {
+        bma222_set_mode(bma222->bma222_client,
+                bma222_MODE_NORMAL);
+    } else {
+        bma222_set_mode(bma222->bma222_client,
+                bma222_MODE_SUSPEND);
+    }
+    
+    if (enable2) {
+        schedule_delayed_work(&bma222->work2,
+            msecs_to_jiffies(atomic_read(&bma222->delay2)));
+    } else {
+        cancel_delayed_work_sync(&bma222->work2);
+    }
+}
+
+static void bma222_set_enable2(struct device *dev, int enable2)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *bma222 = i2c_get_clientdata(client);
+    int pre_enable = atomic_read(&bma222->enable2);
+
+    mutex_lock(&bma222->enable_mutex);
+    if (enable2 != pre_enable) {
+        bma222_do_enable2(dev, enable2);
+        atomic_set(&bma222->enable2, enable2);
+    }
+    mutex_unlock(&bma222->enable_mutex);
+}
+
+static ssize_t bma222_enable2_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if ((data == 0) || (data == 1)) {
+        bma222_set_enable2(dev, data);
+    }
+
+    return count;
+}
+
+static struct device_attribute dev_attr_value2 = __ATTR(value, S_IRUGO,
+        bma222_value2_show, NULL);
+static struct device_attribute dev_attr_delay2 = __ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma222_delay2_show, bma222_delay2_store);
+static struct device_attribute dev_attr_enable2 = __ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma222_enable2_show, bma222_enable2_store);
+
+static struct attribute *bma222_attributes2[] = {
+    &dev_attr_value2.attr,
+    &dev_attr_delay2.attr,
+    &dev_attr_enable2.attr,
+    &dev_attr_reg.attr,
+    NULL
+};
+
+static struct attribute_group bma222_attribute_group2 = {
+    .attrs = bma222_attributes2
+};
+
+static int bma222_register_input(struct bma222_data *data)
+{
+    int err = 0;
+    struct input_dev *dev;
+    
+    /* register gsensor input device */
+    dev = input_allocate_device();
+    if (!dev) {
+        return -ENOMEM;
+    }
+
+    dev->name = SENSOR_NAME;
+    dev->id.bustype = BUS_I2C;    
+    input_set_capability(dev, EV_ABS, ABS_MISC);
+    input_set_abs_params(dev, ABS_X, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_abs_params(dev, ABS_Y, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_abs_params(dev, ABS_Z, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_drvdata(dev, data);
+
+    err = input_register_device(dev);
+    if (err < 0) {
+        input_free_device(dev);
+        return err;
+    }
+    
+    data->input = dev;
+    
+    /* register temperature sensor input device */
+    dev = input_allocate_device();
+    if (!dev) {
+        return -ENOMEM;
+    }
+
+    dev->name = SENSOR_NAME2;
+    dev->id.bustype = BUS_I2C;
+    input_set_capability(dev, EV_ABS, ABS_MISC);
+    input_set_abs_params(dev, ABS_MISC, ABSMIN2, ABSMAX2, FUZZ2, 0);    
+    input_set_drvdata(dev, data);
+
+    err = input_register_device(dev);
+    if (err < 0) {
+        input_free_device(dev);
+        return err;
+    }
+
+    data->input2 = dev;
+    
+    return 0;
+}
+
+static int bma222_probe(struct i2c_client *client,
+        const struct i2c_device_id *id)
+{
+    int err = 0;
+    unsigned char tempvalue;
+    struct bma222_data *data;
+    int cfg_position;
+    int cfg_calibration[3];
+    unsigned char offset[3];
+    char const * buf;
+    long int temp;
+
+    printk("%s,%d, addr:0x%x\n", __func__, __LINE__, client->addr);
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        printk( "i2c_check_functionality error\n");
+        err = -ENODEV;
+        goto exit;
+    }
+    
+    data = kzalloc(sizeof(struct bma222_data), GFP_KERNEL);
+    if (!data) {
+        err = -ENOMEM;
+        goto exit;
+    }
+
+    /* read chip id */
+    tempvalue = i2c_smbus_read_byte_data(client, bma222_CHIP_ID_REG);
+    if ((tempvalue == bma222_CHIP_ID) || (tempvalue == bma222E_CHIP_ID)) {
+        printk(KERN_INFO "bma222 detected!\n");
+    } else{
+        printk(KERN_INFO "bma222 not found! I2c error %d \n", tempvalue);
+        err = -ENODEV;
+        goto kfree_exit;
+    }    
+    i2c_set_clientdata(client, data);
+    data->bma222_client = client;
+    
+#if CFG_GSENSOR_USE_CONFIG > 0
+        //get dts configures
+        err = of_property_read_u32_array(client->dev.of_node, "calibration_table", cfg_calibration, 3);
+        if (err != 0) {
+            printk(KERN_ERR"get calibration fail\n");
+            memset(cfg_calibration, 0, sizeof(cfg_calibration));
+        }
+#else
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+#endif    
+
+    offset[0] = (unsigned char) cfg_calibration[0];
+    offset[1] = (unsigned char) cfg_calibration[1];
+    offset[2] = (unsigned char) cfg_calibration[2];
+    printk(KERN_INFO "cfg_calibration: %d %d %d\n", offset[0], offset[1], offset[2]);
+
+    if (bma222_set_offset_filt_xyz(client, offset, sizeof(offset)) < 0) {
+        printk(KERN_ERR"set offset fail\n");
+        goto kfree_exit;
+    }    
+//K70 Gsensor IC bma 223\BA\CD8452\B7\BD\CF\F2\B2\BBÒ»\D1\F9
+#if CFG_GSENSOR_USE_CONFIG > 0
+    err = of_property_read_string(client->dev.of_node, "position", &buf);
+    if (err != 0) {
+      printk(KERN_ERR"get position fail\n");
+    }
+    err = strict_strtol(buf, 10, &temp);  
+    cfg_position = (int)temp;
+
+#else
+    cfg_position = -3;
+#endif
+
+    atomic_set(&data->position, cfg_position);
+    
+    /* register input device */
+    err = bma222_register_input(data);
+    if (err < 0) {
+        goto error_sysfs;
+    }
+
+    err = sysfs_create_group(&data->input->dev.kobj, &bma222_attribute_group);
+    if (err < 0) {
+        goto error_sysfs;
+    }
+
+    err = sysfs_create_group(&data->input2->dev.kobj, &bma222_attribute_group2);
+    if (err < 0) {
+        goto error_sysfs;
+    }
+    
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    data->early_suspend.suspend = bma222_early_suspend;
+    data->early_suspend.resume = bma222_late_resume;
+    register_early_suspend(&data->early_suspend);
+#endif
+
+    INIT_DELAYED_WORK(&data->work, bma222_work_func);
+    INIT_DELAYED_WORK(&data->work2, bma222_work_func2);
+    
+    mutex_init(&data->enable_mutex);
+    atomic_set(&data->delay, bma222_MAX_DELAY);
+    atomic_set(&data->delay2, bma222_MAX_DELAY);    
+    atomic_set(&data->enable, 0);
+    atomic_set(&data->enable2, 0);
+    atomic_set(&data->calibrated, 0);
+    atomic_set(&data->fuzz, FUZZ);
+    
+    bma222_set_bandwidth(client, bma222_BW_SET);
+    bma222_set_range(client, bma222_RANGE_SET);
+
+    return 0;
+
+error_sysfs:
+    input_unregister_device(data->input);
+    input_unregister_device(data->input2);
+kfree_exit:
+    kfree(data);
+exit:
+    return err;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma222_early_suspend(struct early_suspend *h)
+{
+    // sensor hal will disable when early suspend
+}
+
+
+static void bma222_late_resume(struct early_suspend *h)
+{
+    // sensor hal will enable when early resume
+}
+#endif
+
+static int  bma222_remove(struct i2c_client *client)
+{
+    struct bma222_data *data = i2c_get_clientdata(client);
+
+    bma222_set_enable(&client->dev, 0);
+    bma222_set_enable2(&client->dev, 0);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    unregister_early_suspend(&data->early_suspend);
+#endif
+    sysfs_remove_group(&data->input->dev.kobj, &bma222_attribute_group);
+    sysfs_remove_group(&data->input->dev.kobj, &bma222_attribute_group2);
+    input_unregister_device(data->input);
+    input_unregister_device(data->input2);
+    kfree(data);
+
+    return 0;
+}
+
+static int bma222_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+    struct i2c_adapter *adapter = client->adapter;
+
+    printk( "%s,%d\n", __func__, __LINE__);
+
+    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+        return -ENODEV;
+
+    strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+
+    return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int bma222_suspend(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *data = i2c_get_clientdata(client);
+    
+    // save offset
+    bma222_get_offset_filt_xyz(data->bma222_client, 
+                data->offset_saved, sizeof(data->offset_saved));
+                
+    bma222_do_enable(dev, 0);  
+    bma222_do_enable2(dev, 0);  
+    
+    return 0;
+}
+
+static int bma222_resume(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma222_data *data = i2c_get_clientdata(client);
+
+    bma222_do_enable(dev, atomic_read(&data->enable));
+    bma222_do_enable2(dev, atomic_read(&data->enable2));
+    
+    // restore offset 
+    bma222_set_offset_filt_xyz(data->bma222_client, 
+                data->offset_saved, sizeof(data->offset_saved));
+    
+    return 0;
+}
+
+#else
+
+#define bma222_suspend        NULL
+#define bma222_resume        NULL
+
+#endif /* CONFIG_PM */
+
+static SIMPLE_DEV_PM_OPS(bma222_pm_ops, bma222_suspend, bma222_resume);
+
+static const unsigned short  bma222_addresses[] = {
+    0x18,
+    I2C_CLIENT_END,
+};
+
+static const struct i2c_device_id bma222_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, bma222_id);
+
+static struct of_device_id bma222_of_match[] = {
+	{ .compatible = "bma222" },
+	{ }
+};
+
+static struct i2c_driver bma222_driver = {
+    .driver = {
+        .owner    = THIS_MODULE,
+        .name    = SENSOR_NAME,
+        .pm    = &bma222_pm_ops,
+        .of_match_table	= of_match_ptr(bma222_of_match),
+    },
+    .class        = I2C_CLASS_HWMON,
+//    .address_list    = bma222_addresses,
+    .id_table    = bma222_id,
+    .probe        = bma222_probe,
+    .remove        = bma222_remove,
+    .detect        = bma222_detect,
+};
+
+#if 0
+static struct i2c_board_info bma222_board_info={
+    .type = SENSOR_NAME, 
+    .addr = 0x18,
+};
+#endif
+
+static int __init bma222_init(void)
+{
+    return i2c_add_driver(&bma222_driver);
+}
+
+static void __exit bma222_exit(void)
+{
+    i2c_del_driver(&bma222_driver);
+}
+
+MODULE_AUTHOR("Albert Zhang <xu.zhang@bosch-sensortec.com>");
+MODULE_DESCRIPTION("bma222 accelerometer sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(bma222_init);
+module_exit(bma222_exit);
+
diff --git a/drivers/input/misc/gsensor/bma250.c b/drivers/input/misc/gsensor/bma250.c
new file mode 100755
index 0000000..6c8bd19
--- /dev/null
+++ b/drivers/input/misc/gsensor/bma250.c
@@ -0,0 +1,1980 @@
+/* file bma250.c
+   brief This file contains all function implementations for the BMA250 in linux
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include "../gsensor_common.h"
+
+#define SENSOR_NAME     "bma250"
+#define ABSMIN                -512
+#define ABSMAX                511
+#define FUZZ                     4
+
+#define SENSOR_NAME2    "bma250t"
+#define ABSMIN2                (24*2-128)
+#define ABSMAX2               (24*2+127)
+#define FUZZ2                    1
+
+#define BMA250_MAX_DELAY        200
+#define BMA250_CHIP_ID            3
+#define BMA250E_CHIP_ID            249
+#define BMA250_RANGE_SET        0
+#define BMA250_BW_SET            4
+
+#define BMA250_CHIP_ID_REG                      0x00
+#define BMA250_VERSION_REG                      0x01
+#define BMA250_X_AXIS_LSB_REG                   0x02
+#define BMA250_X_AXIS_MSB_REG                   0x03
+#define BMA250_Y_AXIS_LSB_REG                   0x04
+#define BMA250_Y_AXIS_MSB_REG                   0x05
+#define BMA250_Z_AXIS_LSB_REG                   0x06
+#define BMA250_Z_AXIS_MSB_REG                   0x07
+#define BMA250_TEMP_RD_REG                      0x08
+#define BMA250_RANGE_SEL_REG                    0x0F
+#define BMA250_BW_SEL_REG                       0x10
+#define BMA250_MODE_CTRL_REG                    0x11
+#define BMA250_SELF_TEST_REG                    0x32
+#define BMA250_OFFSET_CTRL_REG                  0x36
+#define BMA250_OFFSET_PARAMS_REG                0x37
+#define BMA250_OFFSET_FILT_X_REG                0x38
+#define BMA250_OFFSET_FILT_Y_REG                0x39
+#define BMA250_OFFSET_FILT_Z_REG                0x3A
+
+#define BMA250_ACC_X_LSB__POS           6
+#define BMA250_ACC_X_LSB__LEN           2
+#define BMA250_ACC_X_LSB__MSK           0xC0
+#define BMA250_ACC_X_LSB__REG           BMA250_X_AXIS_LSB_REG
+
+#define BMA250_ACC_X_MSB__POS           0
+#define BMA250_ACC_X_MSB__LEN           8
+#define BMA250_ACC_X_MSB__MSK           0xFF
+#define BMA250_ACC_X_MSB__REG           BMA250_X_AXIS_MSB_REG
+
+#define BMA250_ACC_Y_LSB__POS           6
+#define BMA250_ACC_Y_LSB__LEN           2
+#define BMA250_ACC_Y_LSB__MSK           0xC0
+#define BMA250_ACC_Y_LSB__REG           BMA250_Y_AXIS_LSB_REG
+
+#define BMA250_ACC_Y_MSB__POS           0
+#define BMA250_ACC_Y_MSB__LEN           8
+#define BMA250_ACC_Y_MSB__MSK           0xFF
+#define BMA250_ACC_Y_MSB__REG           BMA250_Y_AXIS_MSB_REG
+
+#define BMA250_ACC_Z_LSB__POS           6
+#define BMA250_ACC_Z_LSB__LEN           2
+#define BMA250_ACC_Z_LSB__MSK           0xC0
+#define BMA250_ACC_Z_LSB__REG           BMA250_Z_AXIS_LSB_REG
+
+#define BMA250_ACC_Z_MSB__POS           0
+#define BMA250_ACC_Z_MSB__LEN           8
+#define BMA250_ACC_Z_MSB__MSK           0xFF
+#define BMA250_ACC_Z_MSB__REG           BMA250_Z_AXIS_MSB_REG
+
+#define BMA250_RANGE_SEL__POS             0
+#define BMA250_RANGE_SEL__LEN             4
+#define BMA250_RANGE_SEL__MSK             0x0F
+#define BMA250_RANGE_SEL__REG             BMA250_RANGE_SEL_REG
+
+#define BMA250_BANDWIDTH__POS             0
+#define BMA250_BANDWIDTH__LEN             5
+#define BMA250_BANDWIDTH__MSK             0x1F
+#define BMA250_BANDWIDTH__REG             BMA250_BW_SEL_REG
+
+#define BMA250_EN_LOW_POWER__POS          6
+#define BMA250_EN_LOW_POWER__LEN          1
+#define BMA250_EN_LOW_POWER__MSK          0x40
+#define BMA250_EN_LOW_POWER__REG          BMA250_MODE_CTRL_REG
+
+#define BMA250_EN_SUSPEND__POS            7
+#define BMA250_EN_SUSPEND__LEN            1
+#define BMA250_EN_SUSPEND__MSK            0x80
+#define BMA250_EN_SUSPEND__REG            BMA250_MODE_CTRL_REG
+
+#define BMA250_EN_SELF_TEST__POS                0
+#define BMA250_EN_SELF_TEST__LEN                2
+#define BMA250_EN_SELF_TEST__MSK                0x03
+#define BMA250_EN_SELF_TEST__REG                BMA250_SELF_TEST_REG
+
+#define BMA250_NEG_SELF_TEST__POS               2
+#define BMA250_NEG_SELF_TEST__LEN               1
+#define BMA250_NEG_SELF_TEST__MSK               0x04
+#define BMA250_NEG_SELF_TEST__REG               BMA250_SELF_TEST_REG
+
+#define BMA250_RESET_FAST_COMP__POS                7
+#define BMA250_RESET_FAST_COMP__LEN                1
+#define BMA250_RESET_FAST_COMP__MSK                0x80
+#define BMA250_RESET_FAST_COMP__REG                BMA250_OFFSET_CTRL_REG
+
+#define BMA250_EN_FAST_COMP__POS                5
+#define BMA250_EN_FAST_COMP__LEN                2
+#define BMA250_EN_FAST_COMP__MSK                0x60
+#define BMA250_EN_FAST_COMP__REG                BMA250_OFFSET_CTRL_REG
+
+#define BMA250_FAST_COMP_RDY_S__POS             4
+#define BMA250_FAST_COMP_RDY_S__LEN             1
+#define BMA250_FAST_COMP_RDY_S__MSK             0x10
+#define BMA250_FAST_COMP_RDY_S__REG             BMA250_OFFSET_CTRL_REG
+
+#define BMA250_COMP_TARGET_OFFSET_X__POS        1
+#define BMA250_COMP_TARGET_OFFSET_X__LEN        2
+#define BMA250_COMP_TARGET_OFFSET_X__MSK        0x06
+#define BMA250_COMP_TARGET_OFFSET_X__REG        BMA250_OFFSET_PARAMS_REG
+
+#define BMA250_COMP_TARGET_OFFSET_Y__POS        3
+#define BMA250_COMP_TARGET_OFFSET_Y__LEN        2
+#define BMA250_COMP_TARGET_OFFSET_Y__MSK        0x18
+#define BMA250_COMP_TARGET_OFFSET_Y__REG        BMA250_OFFSET_PARAMS_REG
+
+#define BMA250_COMP_TARGET_OFFSET_Z__POS        5
+#define BMA250_COMP_TARGET_OFFSET_Z__LEN        2
+#define BMA250_COMP_TARGET_OFFSET_Z__MSK        0x60
+#define BMA250_COMP_TARGET_OFFSET_Z__REG        BMA250_OFFSET_PARAMS_REG
+
+#define BMA250_RANGE_2G                 0
+#define BMA250_RANGE_4G                 1
+#define BMA250_RANGE_8G                 2
+#define BMA250_RANGE_16G                3
+
+#define BMA250_BW_7_81HZ        0x08
+#define BMA250_BW_15_63HZ       0x09
+#define BMA250_BW_31_25HZ       0x0A
+#define BMA250_BW_62_50HZ       0x0B
+#define BMA250_BW_125HZ         0x0C
+#define BMA250_BW_250HZ         0x0D
+#define BMA250_BW_500HZ         0x0E
+#define BMA250_BW_1000HZ        0x0F
+
+#define BMA250_MODE_NORMAL      0
+#define BMA250_MODE_LOWPOWER    1
+#define BMA250_MODE_SUSPEND     2
+
+
+#define BMA250_GET_BITSLICE(regvar, bitname)\
+    ((regvar & bitname##__MSK) >> bitname##__POS)
+
+
+#define BMA250_SET_BITSLICE(regvar, bitname, val)\
+    ((regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK))
+
+
+struct bma250acc{
+    s16    x,
+        y,
+        z,
+        temp;
+} ;
+
+struct bma250_data {
+    struct i2c_client *bma250_client;
+    struct mutex enable_mutex;
+    atomic_t selftest_result;
+    
+    atomic_t delay;
+    atomic_t enable;
+    struct input_dev *input;
+    struct delayed_work work;
+    
+    atomic_t delay2;
+    atomic_t enable2;
+    struct input_dev *input2;
+    struct delayed_work work2;
+    
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend early_suspend;
+#endif
+    atomic_t fuzz;
+    atomic_t position;
+    atomic_t calibrated;
+    unsigned char offset_saved[3];
+};
+
+
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma250_early_suspend(struct early_suspend *h);
+static void bma250_late_resume(struct early_suspend *h);
+#endif
+
+static int bma250_smbus_read_byte(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data)
+{
+    s32 dummy;
+    dummy = i2c_smbus_read_byte_data(client, reg_addr);
+    if (dummy < 0)
+        return -1;
+    *data = dummy & 0x000000ff;
+
+    return 0;
+}
+
+static int bma250_smbus_write_byte(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data)
+{
+    s32 dummy;
+    dummy = i2c_smbus_write_byte_data(client, reg_addr, *data);
+    if (dummy < 0)
+        return -1;
+    return 0;
+}
+
+static int bma250_smbus_read_byte_block(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    dummy = i2c_smbus_read_i2c_block_data(client, reg_addr, len, data);
+    if (dummy < 0)
+        return -1;
+    return 0;
+}
+
+static int bma250_smbus_write_byte_block(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    s32 idx;
+    
+
+    for (idx = 0; idx < len; idx ++)
+    {
+        dummy = i2c_smbus_write_byte_data(client, reg_addr+idx, data[idx]);
+        if (dummy < 0)
+            return -1;
+    }
+    
+    return 0;
+}
+static int bma250_set_mode(struct i2c_client *client, unsigned char Mode)
+{
+    int comres = 0;
+    unsigned char data1;
+
+    if (Mode < 3) {
+        comres = bma250_smbus_read_byte(client,
+                BMA250_EN_LOW_POWER__REG, &data1);
+        switch (Mode) {
+        case BMA250_MODE_NORMAL:
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_EN_LOW_POWER, 0);
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_EN_SUSPEND, 0);
+            break;
+        case BMA250_MODE_LOWPOWER:
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_EN_LOW_POWER, 1);
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_EN_SUSPEND, 0);
+            break;
+        case BMA250_MODE_SUSPEND:
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_EN_LOW_POWER, 0);
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_EN_SUSPEND, 1);
+            break;
+        default:
+            break;
+        }
+
+        comres += bma250_smbus_write_byte(client,
+                BMA250_EN_LOW_POWER__REG, &data1);
+    } else{
+        comres = -1;
+    }
+
+    return comres;
+}
+
+static int bma250_get_mode(struct i2c_client *client, unsigned char *Mode)
+{
+    int comres = 0;
+
+    comres = bma250_smbus_read_byte(client,
+            BMA250_EN_LOW_POWER__REG, Mode);
+    *Mode  = (*Mode) >> 6;
+
+    return comres;
+}
+
+static int bma250_set_range(struct i2c_client *client, unsigned char Range)
+{
+    int comres = 0;
+    unsigned char data1;
+
+    if (Range < 4) {
+        comres = bma250_smbus_read_byte(client,
+                BMA250_RANGE_SEL_REG, &data1);
+        switch (Range) {
+        case 0:
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_RANGE_SEL, 0);
+            break;
+        case 1:
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_RANGE_SEL, 5);
+            break;
+        case 2:
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_RANGE_SEL, 8);
+            break;
+        case 3:
+            data1  = BMA250_SET_BITSLICE(data1,
+                    BMA250_RANGE_SEL, 12);
+            break;
+        default:
+            break;
+        }
+        comres += bma250_smbus_write_byte(client,
+                BMA250_RANGE_SEL_REG, &data1);
+    } else{
+        comres = -1;
+    }
+
+    return comres;
+}
+
+static int bma250_get_range(struct i2c_client *client, unsigned char *Range)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_RANGE_SEL__REG,
+            &data);
+    data = BMA250_GET_BITSLICE(data, BMA250_RANGE_SEL);
+    *Range = data;
+
+    return comres;
+}
+
+
+static int bma250_set_bandwidth(struct i2c_client *client, unsigned char BW)
+{
+    int comres = 0;
+    unsigned char data;
+    int Bandwidth = 0;
+
+    if (BW < 8) {
+        switch (BW) {
+        case 0:
+            Bandwidth = BMA250_BW_7_81HZ;
+            break;
+        case 1:
+            Bandwidth = BMA250_BW_15_63HZ;
+            break;
+        case 2:
+            Bandwidth = BMA250_BW_31_25HZ;
+            break;
+        case 3:
+            Bandwidth = BMA250_BW_62_50HZ;
+            break;
+        case 4:
+            Bandwidth = BMA250_BW_125HZ;
+            break;
+        case 5:
+            Bandwidth = BMA250_BW_250HZ;
+            break;
+        case 6:
+            Bandwidth = BMA250_BW_500HZ;
+            break;
+        case 7:
+            Bandwidth = BMA250_BW_1000HZ;
+            break;
+        default:
+            break;
+        }
+        comres = bma250_smbus_read_byte(client,
+                BMA250_BANDWIDTH__REG, &data);
+        data = BMA250_SET_BITSLICE(data, BMA250_BANDWIDTH,
+                Bandwidth);
+        comres += bma250_smbus_write_byte(client,
+                BMA250_BANDWIDTH__REG, &data);
+    } else{
+        comres = -1;
+    }
+
+    return comres;
+}
+
+static int bma250_get_bandwidth(struct i2c_client *client, unsigned char *BW)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_BANDWIDTH__REG,
+            &data);
+    data = BMA250_GET_BITSLICE(data, BMA250_BANDWIDTH);
+    if (data <= 8) {
+        *BW = 0;
+    } else{
+        if (data >= 0x0F)
+            *BW = 7;
+        else
+            *BW = data - 8;
+    }
+
+    return comres;
+}
+
+static int bma250_set_offset_target_x(struct i2c_client *client, unsigned char
+        offsettarget)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client,
+            BMA250_COMP_TARGET_OFFSET_X__REG, &data);
+    data = BMA250_SET_BITSLICE(data, BMA250_COMP_TARGET_OFFSET_X,
+            offsettarget);
+    comres = bma250_smbus_write_byte(client,
+            BMA250_COMP_TARGET_OFFSET_X__REG, &data);
+
+    return comres;
+}
+
+static int bma250_get_offset_target_x(struct i2c_client *client, unsigned char
+        *offsettarget)
+{
+    int comres = 0 ;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_OFFSET_PARAMS_REG,
+            &data);
+    data = BMA250_GET_BITSLICE(data, BMA250_COMP_TARGET_OFFSET_X);
+    *offsettarget = data;
+
+    return comres;
+}
+
+static int bma250_set_offset_target_y(struct i2c_client *client, unsigned char
+        offsettarget)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client,
+            BMA250_COMP_TARGET_OFFSET_Y__REG, &data);
+    data = BMA250_SET_BITSLICE(data, BMA250_COMP_TARGET_OFFSET_Y,
+            offsettarget);
+    comres = bma250_smbus_write_byte(client,
+            BMA250_COMP_TARGET_OFFSET_Y__REG, &data);
+
+    return comres;
+}
+
+static int bma250_get_offset_target_y(struct i2c_client *client, unsigned char
+        *offsettarget)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_OFFSET_PARAMS_REG,
+            &data);
+    data = BMA250_GET_BITSLICE(data, BMA250_COMP_TARGET_OFFSET_Y);
+    *offsettarget = data;
+
+    return comres;
+}
+
+static int bma250_set_offset_target_z(struct i2c_client *client, unsigned char
+        offsettarget)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client,
+            BMA250_COMP_TARGET_OFFSET_Z__REG, &data);
+    data = BMA250_SET_BITSLICE(data, BMA250_COMP_TARGET_OFFSET_Z,
+            offsettarget);
+    comres = bma250_smbus_write_byte(client,
+            BMA250_COMP_TARGET_OFFSET_Z__REG, &data);
+
+    return comres;
+}
+
+static int bma250_get_offset_target_z(struct i2c_client *client, unsigned char
+        *offsettarget)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_OFFSET_PARAMS_REG,
+            &data);
+    data = BMA250_GET_BITSLICE(data, BMA250_COMP_TARGET_OFFSET_Z);
+    *offsettarget = data;
+
+    return comres;
+}
+
+static int bma250_get_cal_ready(struct i2c_client *client, unsigned char
+        *calrdy)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_OFFSET_CTRL_REG, &data);
+    data = BMA250_GET_BITSLICE(data, BMA250_FAST_COMP_RDY_S);
+    *calrdy = data;
+
+    return comres;
+}
+
+static int bma250_reset_cal_offset(struct i2c_client *client)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_RESET_FAST_COMP__REG,
+            &data);
+    data = BMA250_SET_BITSLICE(data, BMA250_RESET_FAST_COMP, 1);
+    comres = bma250_smbus_write_byte(client, BMA250_RESET_FAST_COMP__REG,
+            &data);
+
+    return comres;
+}
+
+static int bma250_set_cal_trigger(struct i2c_client *client, unsigned char
+        caltrigger)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_EN_FAST_COMP__REG,
+            &data);
+    data = BMA250_SET_BITSLICE(data, BMA250_EN_FAST_COMP, caltrigger);
+    comres = bma250_smbus_write_byte(client, BMA250_EN_FAST_COMP__REG,
+            &data);
+
+    return comres;
+}
+
+static int bma250_set_selftest_st(struct i2c_client *client, unsigned char
+        selftest)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_EN_SELF_TEST__REG,
+            &data);
+    data = BMA250_SET_BITSLICE(data, BMA250_EN_SELF_TEST, selftest);
+    comres = bma250_smbus_write_byte(client, BMA250_EN_SELF_TEST__REG,
+            &data);
+
+    return comres;
+}
+
+static int bma250_set_selftest_stn(struct i2c_client *client, unsigned char stn)
+{
+    int comres = 0;
+    unsigned char data;
+
+    comres = bma250_smbus_read_byte(client, BMA250_NEG_SELF_TEST__REG,
+            &data);
+    data = BMA250_SET_BITSLICE(data, BMA250_NEG_SELF_TEST, stn);
+    comres = bma250_smbus_write_byte(client, BMA250_NEG_SELF_TEST__REG,
+            &data);
+
+    return comres;
+}
+static int bma250_read_accel_x(struct i2c_client *client, short *a_x)
+{
+    int comres;
+    unsigned char data[2];
+
+    comres = bma250_smbus_read_byte_block(client, BMA250_ACC_X_LSB__REG,
+            data, 2);
+    *a_x = BMA250_GET_BITSLICE(data[0], BMA250_ACC_X_LSB) |
+        (BMA250_GET_BITSLICE(data[1],
+                     BMA250_ACC_X_MSB)<<BMA250_ACC_X_LSB__LEN);
+    *a_x = *a_x <<
+        (sizeof(short)*8-(BMA250_ACC_X_LSB__LEN+BMA250_ACC_X_MSB__LEN));
+    *a_x = *a_x >>
+        (sizeof(short)*8-(BMA250_ACC_X_LSB__LEN+BMA250_ACC_X_MSB__LEN));
+
+    return comres;
+}
+static int bma250_read_accel_y(struct i2c_client *client, short *a_y)
+{
+    int comres;
+    unsigned char data[2];
+
+    comres = bma250_smbus_read_byte_block(client, BMA250_ACC_Y_LSB__REG,
+            data, 2);
+    *a_y = BMA250_GET_BITSLICE(data[0], BMA250_ACC_Y_LSB) |
+        (BMA250_GET_BITSLICE(data[1],
+                     BMA250_ACC_Y_MSB)<<BMA250_ACC_Y_LSB__LEN);
+    *a_y = *a_y <<
+        (sizeof(short)*8-(BMA250_ACC_Y_LSB__LEN+BMA250_ACC_Y_MSB__LEN));
+    *a_y = *a_y >>
+        (sizeof(short)*8-(BMA250_ACC_Y_LSB__LEN+BMA250_ACC_Y_MSB__LEN));
+
+    return comres;
+}
+
+static int bma250_read_accel_z(struct i2c_client *client, short *a_z)
+{
+    int comres;
+    unsigned char data[2];
+
+    comres = bma250_smbus_read_byte_block(client, BMA250_ACC_Z_LSB__REG,
+            data, 2);
+    *a_z = BMA250_GET_BITSLICE(data[0], BMA250_ACC_Z_LSB) |
+        BMA250_GET_BITSLICE(data[1],
+                BMA250_ACC_Z_MSB)<<BMA250_ACC_Z_LSB__LEN;
+    *a_z = *a_z <<
+        (sizeof(short)*8-(BMA250_ACC_Z_LSB__LEN+BMA250_ACC_Z_MSB__LEN));
+    *a_z = *a_z >>
+        (sizeof(short)*8-(BMA250_ACC_Z_LSB__LEN+BMA250_ACC_Z_MSB__LEN));
+
+    return comres;
+}
+
+static int bma250_read_accel_xyz(struct i2c_client *client,
+        struct bma250acc *acc)
+{
+    int comres;
+    unsigned char data[6];
+
+    comres = bma250_smbus_read_byte_block(client,
+            BMA250_ACC_X_LSB__REG, data, 6);
+
+    acc->x = BMA250_GET_BITSLICE(data[0], BMA250_ACC_X_LSB)
+        |(BMA250_GET_BITSLICE(data[1],
+                BMA250_ACC_X_MSB)<<BMA250_ACC_X_LSB__LEN);
+    acc->x = acc->x << (sizeof(short)*8-(BMA250_ACC_X_LSB__LEN
+                + BMA250_ACC_X_MSB__LEN));
+    acc->x = acc->x >> (sizeof(short)*8-(BMA250_ACC_X_LSB__LEN
+                + BMA250_ACC_X_MSB__LEN));
+    acc->y = BMA250_GET_BITSLICE(data[2], BMA250_ACC_Y_LSB)
+        | (BMA250_GET_BITSLICE(data[3],
+                BMA250_ACC_Y_MSB)<<BMA250_ACC_Y_LSB__LEN);
+    acc->y = acc->y << (sizeof(short)*8-(BMA250_ACC_Y_LSB__LEN
+                + BMA250_ACC_Y_MSB__LEN));
+    acc->y = acc->y >> (sizeof(short)*8-(BMA250_ACC_Y_LSB__LEN
+                + BMA250_ACC_Y_MSB__LEN));
+
+    acc->z = BMA250_GET_BITSLICE(data[4], BMA250_ACC_Z_LSB)
+        | (BMA250_GET_BITSLICE(data[5],
+                BMA250_ACC_Z_MSB)<<BMA250_ACC_Z_LSB__LEN);
+    acc->z = acc->z << (sizeof(short)*8-(BMA250_ACC_Z_LSB__LEN
+                + BMA250_ACC_Z_MSB__LEN));
+    acc->z = acc->z >> (sizeof(short)*8-(BMA250_ACC_Z_LSB__LEN
+                + BMA250_ACC_Z_MSB__LEN));
+
+    return comres;
+}
+
+static int bma250_read_temperature(struct i2c_client *client,
+        struct bma250acc *acc)
+{
+    int comres;
+    unsigned char data = 0;
+
+    comres = bma250_smbus_read_byte(client, BMA250_TEMP_RD_REG, &data);
+    acc->temp = 24 * 2 + (signed char)data;
+
+    return comres;
+}
+
+static int bma250_set_offset_filt_xyz(struct i2c_client *client, unsigned char
+        *offset, int len)
+{
+    int comres = 0;
+
+    comres = bma250_smbus_write_byte_block(client, BMA250_OFFSET_FILT_X_REG, offset, len);
+        
+    return comres;
+}
+
+static int bma250_get_offset_filt_xyz(struct i2c_client *client, unsigned char
+        *offset, int len)
+{
+    int comres = 0 ;
+
+    comres = bma250_smbus_read_byte_block(client, BMA250_OFFSET_FILT_X_REG,    offset, len);
+
+    return comres;
+}
+
+static int bma250_read_file(char *path, char *buf, int size)
+{
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+static int bma250_load_user_calibration(struct i2c_client *client)
+{
+    char buffer[16];
+    int ret = 0;
+    int data[3];
+    unsigned char offset[3];
+    struct bma250_data *bma250 = i2c_get_clientdata(client);    
+    int calibrated = atomic_read(&bma250->calibrated);
+    
+    if (calibrated) {
+        goto usr_calib_end;
+    } else {
+        atomic_set(&bma250->calibrated, 1);
+    }
+
+    ret = bma250_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d", &data[0], &data[1], &data[2]);
+    offset[0] = (unsigned char) data[0];
+    offset[1] = (unsigned char) data[1];
+    offset[2] = (unsigned char) data[2];    
+    
+    printk(KERN_INFO "user cfg_calibration: %d %d %d\n", offset[0], offset[1], offset[2]);
+    
+    if (bma250_set_offset_filt_xyz(bma250->bma250_client, offset, sizeof(offset)) < 0) {
+        printk(KERN_ERR"set offset fail\n");
+        goto usr_calib_end;
+    }
+    
+    printk(KERN_INFO "load user calibration finished\n");
+    
+usr_calib_end:
+    return ret;
+}
+
+static int bma250_axis_remap(struct i2c_client *client,
+        struct bma250acc *acc)
+{
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    s16 swap;
+    int bma_position = atomic_read(&bma250->position);
+
+    switch (abs(bma_position)) {
+        case 1:
+            acc->x = -(acc->x);
+            acc->y = -(acc->y);
+            break;
+        case 2:
+            swap = acc->x;
+            acc->x = -acc->y;
+            acc->y = swap;
+            break;
+        case 3:
+            break;
+        case 4:
+            swap = acc->x;
+            acc->x = acc->y;
+            acc->y = -swap; 
+            break;
+    }
+    
+    if (bma_position < 0) {
+        acc->z = -(acc->z);
+        acc->x = -(acc->x);
+    }
+    
+    return 0;
+}
+
+static void bma250_work_func(struct work_struct *work)
+{
+    struct bma250_data *bma250 = container_of((struct delayed_work *)work,
+            struct bma250_data, work);
+    static struct bma250acc acc;
+    unsigned long delay = msecs_to_jiffies(atomic_read(&bma250->delay));
+
+    //bma250_load_user_calibration(bma250->bma250_client);
+    
+    bma250_read_accel_xyz(bma250->bma250_client, &acc);
+    bma250_axis_remap(bma250->bma250_client, &acc);
+    input_report_abs(bma250->input, ABS_X, acc.x);
+    input_report_abs(bma250->input, ABS_Y, acc.y);
+    input_report_abs(bma250->input, ABS_Z, acc.z);
+    input_sync(bma250->input);
+    
+    schedule_delayed_work(&bma250->work, delay);
+}
+
+static void bma250_work_func2(struct work_struct *work)
+{
+    struct bma250_data *bma250 = container_of((struct delayed_work *)work,
+            struct bma250_data, work2);
+    static struct bma250acc acc;
+    unsigned long delay = msecs_to_jiffies(atomic_read(&bma250->delay2));
+    
+    bma250_read_temperature(bma250->bma250_client, &acc);
+    input_report_abs(bma250->input2, ABS_MISC, acc.temp);
+    input_sync(bma250->input2);
+    
+    schedule_delayed_work(&bma250->work2, delay);
+}
+
+static ssize_t bma250_register_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int address, value;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    sscanf(buf, "0x%x=0x%x", &address, &value);
+
+    if (bma250_smbus_write_byte(bma250->bma250_client, (unsigned char)address,
+                (unsigned char *)&value) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma250_register_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    size_t count = 0;
+    u8 reg[0x3d];
+    int i;
+
+    for (i = 0 ; i <= 0x3d; i++) {
+        bma250_smbus_read_byte(bma250->bma250_client, i, reg+i);
+
+        count += sprintf(&buf[count], "0x%x: 0x%x\n", i, reg[i]);
+    }
+    return count;
+
+
+}
+
+static ssize_t bma250_range_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    if (bma250_get_range(bma250->bma250_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma250_range_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (bma250_set_range(bma250->bma250_client, (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma250_bandwidth_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    if (bma250_get_bandwidth(bma250->bma250_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma250_bandwidth_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (bma250_set_bandwidth(bma250->bma250_client,
+                (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t bma250_mode_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    if (bma250_get_mode(bma250->bma250_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma250_mode_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (bma250_set_mode(bma250->bma250_client, (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+
+static ssize_t bma250_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct input_dev *input = to_input_dev(dev);
+    struct bma250_data *bma250 = input_get_drvdata(input);
+    struct bma250acc acc;
+    
+    bma250_read_accel_xyz(bma250->bma250_client, &acc);
+    bma250_axis_remap(bma250->bma250_client, &acc);
+
+    return sprintf(buf, "%d %d %d\n", acc.x, acc.y, acc.z);
+}
+
+static ssize_t bma250_delay_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma250->delay));
+
+}
+
+static ssize_t bma250_delay_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    unsigned char bandwidth;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (data > BMA250_MAX_DELAY)
+        data = BMA250_MAX_DELAY;
+    atomic_set(&bma250->delay, (unsigned int) data);
+
+    // change band width
+    data = 1000 / data;
+    if (data > 500) {
+        bandwidth = 7;
+    } else if (data > 250) {
+        bandwidth = 6;
+    } else if (data > 125) {
+        bandwidth = 5;
+    } else if (data > 62) {
+        bandwidth = 4;
+    } else if (data > 31) {
+        bandwidth = 3;
+    } else {
+        bandwidth = 2;
+    }
+    bma250_set_bandwidth(bma250->bma250_client, bandwidth);
+    
+    return count;
+}
+
+static ssize_t bma250_enable_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma250->enable));
+
+}
+
+static void bma250_do_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    int used = enable || atomic_read(&bma250->enable2);
+
+    if (used) {
+        bma250_set_mode(bma250->bma250_client,
+                BMA250_MODE_NORMAL);
+    } else {
+        bma250_set_mode(bma250->bma250_client,
+                BMA250_MODE_SUSPEND);
+    }
+    
+    if (enable) {
+        schedule_delayed_work(&bma250->work,
+            msecs_to_jiffies(atomic_read(&bma250->delay)));
+    } else {
+        cancel_delayed_work_sync(&bma250->work);
+    }
+}
+
+static void bma250_set_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    int pre_enable = atomic_read(&bma250->enable);
+
+    mutex_lock(&bma250->enable_mutex);
+    if (enable != pre_enable) {
+        bma250_do_enable(dev, enable);
+        atomic_set(&bma250->enable, enable);
+    }
+    mutex_unlock(&bma250->enable_mutex);
+}
+
+static ssize_t bma250_enable_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if ((data == 0) || (data == 1)) {
+        bma250_set_enable(dev, data);
+    }
+
+    return count;
+}
+
+static ssize_t bma250_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    data = atomic_read(&(bma250->position));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma250_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(bma250->position), (int) data);
+
+    return count;
+}
+
+static ssize_t bma250_fast_calibration_x_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+
+
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    if (bma250_get_offset_target_x(bma250->bma250_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma250_fast_calibration_x_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    signed char tmp;
+    unsigned char timeout = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (bma250_set_offset_target_x(bma250->bma250_client, (unsigned
+                    char)data) < 0)
+        return -EINVAL;
+
+    if (bma250_set_cal_trigger(bma250->bma250_client, 1) < 0)
+        return -EINVAL;
+
+    do {
+        mdelay(2);
+        bma250_get_cal_ready(bma250->bma250_client, &tmp);
+
+    /*    printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+        timeout++;
+        if (timeout == 500) {
+            printk(KERN_INFO "get fast calibration ready error\n");
+            return -EINVAL;
+        };
+
+    } while (tmp == 0);
+
+    printk(KERN_INFO "x axis fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma250_fast_calibration_y_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+
+
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    if (bma250_get_offset_target_y(bma250->bma250_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma250_fast_calibration_y_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    signed char tmp;
+    unsigned char timeout = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (bma250_set_offset_target_y(bma250->bma250_client, (unsigned
+                    char)data) < 0)
+        return -EINVAL;
+
+    if (bma250_set_cal_trigger(bma250->bma250_client, 2) < 0)
+        return -EINVAL;
+
+    do {
+        mdelay(2);
+        bma250_get_cal_ready(bma250->bma250_client, &tmp);
+
+    /*    printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+        timeout++;
+        if (timeout == 500) {
+            printk(KERN_INFO "get fast calibration ready error\n");
+            return -EINVAL;
+        };
+
+    } while (tmp == 0);
+
+    printk(KERN_INFO "y axis fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma250_fast_calibration_z_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    if (bma250_get_offset_target_z(bma250->bma250_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma250_fast_calibration_z_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    signed char tmp;
+    unsigned char timeout = 0;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (bma250_set_offset_target_z(bma250->bma250_client, (unsigned
+                    char)data) < 0)
+        return -EINVAL;
+
+    if (bma250_set_cal_trigger(bma250->bma250_client, 3) < 0)
+        return -EINVAL;
+
+    do {
+        mdelay(2);
+        bma250_get_cal_ready(bma250->bma250_client, &tmp);
+
+    /*    printk(KERN_INFO "wait 2ms cal ready flag is %d\n",tmp);*/
+        timeout++;
+        if (timeout == 500) {
+            printk(KERN_INFO "get fast calibration ready error\n");
+            return -EINVAL;
+        };
+
+    } while (tmp == 0);
+
+    printk(KERN_INFO "z axis fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma250_selftest_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma250->selftest_result));
+}
+
+static ssize_t bma250_selftest_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    unsigned char clear_value = 0;
+    int error;
+    short value1 = 0;
+    short value2 = 0;
+    short diff = 0;
+    unsigned long result = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    if (data != 1)
+        return -EINVAL;
+        
+    if (bma250_set_range(bma250->bma250_client, 0) < 0)
+        return -EINVAL;
+
+    bma250_smbus_write_byte(bma250->bma250_client, 0x32, &clear_value);
+
+    bma250_set_selftest_st(bma250->bma250_client, 1); /* 1 for x-axis*/
+    bma250_set_selftest_stn(bma250->bma250_client, 0); /* positive
+                                  direction*/
+    mdelay(10);
+    bma250_read_accel_x(bma250->bma250_client, &value1);
+    bma250_set_selftest_stn(bma250->bma250_client, 1); /* negative
+                                  direction*/
+    mdelay(10);
+    bma250_read_accel_x(bma250->bma250_client, &value2);
+    diff = value1-value2;
+
+    printk(KERN_INFO "diff x is %d,value1 is %d, value2 is %d\n", diff,
+            value1, value2);
+
+    if (abs(diff) < 204)
+        result |= 1;
+
+    bma250_set_selftest_st(bma250->bma250_client, 2); /* 2 for y-axis*/
+    bma250_set_selftest_stn(bma250->bma250_client, 0); /* positive
+                                  direction*/
+    mdelay(10);
+    bma250_read_accel_y(bma250->bma250_client, &value1);
+    bma250_set_selftest_stn(bma250->bma250_client, 1); /* negative
+                                  direction*/
+    mdelay(10);
+    bma250_read_accel_y(bma250->bma250_client, &value2);
+    diff = value1-value2;
+    printk(KERN_INFO "diff y is %d,value1 is %d, value2 is %d\n", diff,
+            value1, value2);
+    if (abs(diff) < 204)
+        result |= 2;
+
+    bma250_set_selftest_st(bma250->bma250_client, 3); /* 3 for z-axis*/
+    bma250_set_selftest_stn(bma250->bma250_client, 0); /* positive
+                                  direction*/
+    mdelay(10);
+    bma250_read_accel_z(bma250->bma250_client, &value1);
+    bma250_set_selftest_stn(bma250->bma250_client, 1); /* negative
+                                  direction*/
+    mdelay(10);
+    bma250_read_accel_z(bma250->bma250_client, &value2);
+    diff = value1-value2;
+
+    printk(KERN_INFO "diff z is %d,value1 is %d, value2 is %d\n", diff,
+            value1, value2);
+    if (abs(diff) < 102)
+        result |= 4;
+
+    atomic_set(&bma250->selftest_result, (unsigned int)result);
+
+    printk(KERN_INFO "self test finished\n");
+    return count;
+}
+
+static ssize_t bma250_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    int bma_position = atomic_read(&bma250->position);
+    
+    bma250_fast_calibration_x_store(dev, attr, "0", 2);
+    bma250_fast_calibration_y_store(dev, attr, "0", 2);
+    if (bma_position > 0) {
+        bma250_fast_calibration_z_store(dev, attr, "1", 2); // z: +g
+    } else {
+        bma250_fast_calibration_z_store(dev, attr, "2", 2); // z: -g
+    }
+
+    if (bma250_get_offset_filt_xyz(bma250->bma250_client, offset, sizeof(offset)) < 0)
+        return sprintf((char*)buf, "Read error\n");
+    
+    cfg_calibration[0] = offset[0];
+    cfg_calibration[1] = offset[1];
+    cfg_calibration[2] = offset[2];
+    
+    printk(KERN_INFO "run fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma250_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    
+    bma250_reset_cal_offset(bma250->bma250_client);
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+
+    printk(KERN_INFO "reset fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma250_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    if (bma250_get_offset_filt_xyz(bma250->bma250_client, offset, sizeof(offset)) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d %d %d\n", offset[0], offset[1], offset[2]);
+}
+
+static ssize_t bma250_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[3];
+    unsigned char offset[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    sscanf(buf, "%d %d %d", &data[0], &data[1], &data[2]);
+    offset[0] = (unsigned char) data[0];
+    offset[1] = (unsigned char) data[1];
+    offset[2] = (unsigned char) data[2];
+    
+    if (bma250_set_offset_filt_xyz(bma250->bma250_client, offset, sizeof(offset)) < 0)
+        return -EINVAL;
+
+    printk(KERN_INFO "set fast calibration finished\n");
+    return count;
+}
+
+static ssize_t bma250_fuzz_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    data = atomic_read(&(bma250->fuzz));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma250_fuzz_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(bma250->fuzz), (int) data);
+    
+    if(bma250->input != NULL) {
+        bma250->input->absinfo[ABS_X].fuzz = data;
+        bma250->input->absinfo[ABS_Y].fuzz = data;
+        bma250->input->absinfo[ABS_Z].fuzz = data;
+    }
+    
+    return count;
+}
+
+static DEVICE_ATTR(range, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_range_show, bma250_range_store);
+static DEVICE_ATTR(bandwidth, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_bandwidth_show, bma250_bandwidth_store);
+static DEVICE_ATTR(mode, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_mode_show, bma250_mode_store);
+static DEVICE_ATTR(value, S_IRUGO,
+        bma250_value_show, NULL);
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_delay_show, bma250_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_enable_show, bma250_enable_store);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_board_position_show, bma250_board_position_store);
+static DEVICE_ATTR(reg, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_register_show, bma250_register_store);
+static DEVICE_ATTR(fast_calibration_x, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_fast_calibration_x_show,
+        bma250_fast_calibration_x_store);
+static DEVICE_ATTR(fast_calibration_y, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_fast_calibration_y_show,
+        bma250_fast_calibration_y_store);
+static DEVICE_ATTR(fast_calibration_z, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_fast_calibration_z_show,
+        bma250_fast_calibration_z_store);
+static DEVICE_ATTR(selftest, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_selftest_show, bma250_selftest_store);
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, bma250_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, bma250_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_calibration_value_show, bma250_calibration_value_store);
+static DEVICE_ATTR(fuzz, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_fuzz_show, bma250_fuzz_store);
+
+static struct attribute *bma250_attributes[] = {
+    &dev_attr_range.attr,
+    &dev_attr_bandwidth.attr,
+    &dev_attr_mode.attr,
+    &dev_attr_value.attr,
+    &dev_attr_delay.attr,
+    &dev_attr_enable.attr,
+    &dev_attr_board_position.attr,
+    &dev_attr_reg.attr,
+    &dev_attr_fast_calibration_x.attr,
+    &dev_attr_fast_calibration_y.attr,
+    &dev_attr_fast_calibration_z.attr,
+    &dev_attr_selftest.attr,
+    &dev_attr_calibration_run.attr,
+    &dev_attr_calibration_reset.attr,
+    &dev_attr_calibration_value.attr,
+    &dev_attr_fuzz.attr,
+    NULL
+};
+
+static struct attribute_group bma250_attribute_group = {
+    .attrs = bma250_attributes
+};
+
+static ssize_t bma250_value2_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct input_dev *input = to_input_dev(dev);
+    struct bma250_data *bma250 = input_get_drvdata(input);
+    struct bma250acc acc;
+    
+    bma250_read_temperature(bma250->bma250_client, &acc);
+
+    return sprintf(buf, "%d\n", acc.temp);
+}
+
+static ssize_t bma250_delay2_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma250->delay2));
+
+}
+
+static ssize_t bma250_delay2_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+        
+    if (data > BMA250_MAX_DELAY)
+        data = BMA250_MAX_DELAY;
+        
+    atomic_set(&bma250->delay2, (unsigned int) data);
+
+    return count;
+}
+
+static ssize_t bma250_enable2_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma250->enable2));
+
+}
+
+static void bma250_do_enable2(struct device *dev, int enable2)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    int used = enable2 || atomic_read(&bma250->enable);
+
+    if (used) {
+        bma250_set_mode(bma250->bma250_client,
+                BMA250_MODE_NORMAL);
+    } else {
+        bma250_set_mode(bma250->bma250_client,
+                BMA250_MODE_SUSPEND);
+    }
+    
+    if (enable2) {
+        schedule_delayed_work(&bma250->work2,
+            msecs_to_jiffies(atomic_read(&bma250->delay2)));
+    } else {
+        cancel_delayed_work_sync(&bma250->work2);
+    }
+}
+
+static void bma250_set_enable2(struct device *dev, int enable2)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    int pre_enable = atomic_read(&bma250->enable2);
+
+    mutex_lock(&bma250->enable_mutex);
+    if (enable2 != pre_enable) {
+        bma250_do_enable2(dev, enable2);
+        atomic_set(&bma250->enable2, enable2);
+    }
+    mutex_unlock(&bma250->enable_mutex);
+}
+
+static ssize_t bma250_enable2_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if ((data == 0) || (data == 1)) {
+        bma250_set_enable2(dev, data);
+    }
+
+    return count;
+}
+
+static struct device_attribute dev_attr_value2 = __ATTR(value, S_IRUGO,
+        bma250_value2_show, NULL);
+static struct device_attribute dev_attr_delay2 = __ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_delay2_show, bma250_delay2_store);
+static struct device_attribute dev_attr_enable2 = __ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_enable2_show, bma250_enable2_store);
+
+static struct attribute *bma250_attributes2[] = {
+    &dev_attr_value2.attr,
+    &dev_attr_delay2.attr,
+    &dev_attr_enable2.attr,
+    &dev_attr_reg.attr,
+    NULL
+};
+
+static struct attribute_group bma250_attribute_group2 = {
+    .attrs = bma250_attributes2
+};
+
+static int bma250_register_input(struct bma250_data *data)
+{
+    int err = 0;
+    struct input_dev *dev;
+    
+    /* register gsensor input device */
+    dev = input_allocate_device();
+    if (!dev) {
+        return -ENOMEM;
+    }
+
+    dev->name = SENSOR_NAME;
+    dev->id.bustype = BUS_I2C;    
+    input_set_capability(dev, EV_ABS, ABS_MISC);
+    input_set_abs_params(dev, ABS_X, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_abs_params(dev, ABS_Y, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_abs_params(dev, ABS_Z, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_drvdata(dev, data);
+
+    err = input_register_device(dev);
+    if (err < 0) {
+        input_free_device(dev);
+        return err;
+    }
+    
+    data->input = dev;
+    
+    /* register temperature sensor input device */
+    dev = input_allocate_device();
+    if (!dev) {
+        return -ENOMEM;
+    }
+
+    dev->name = SENSOR_NAME2;
+    dev->id.bustype = BUS_I2C;
+    input_set_capability(dev, EV_ABS, ABS_MISC);
+    input_set_abs_params(dev, ABS_MISC, ABSMIN2, ABSMAX2, FUZZ2, 0);    
+    input_set_drvdata(dev, data);
+
+    err = input_register_device(dev);
+    if (err < 0) {
+        input_free_device(dev);
+        return err;
+    }
+
+    data->input2 = dev;
+    
+    return 0;
+}
+
+int cfg_position;
+unsigned int cfg_i2c_adap_id;
+
+
+
+static int bma250_probe(struct i2c_client *client,
+        const struct i2c_device_id *id)
+{
+    int err = 0;
+    unsigned char tempvalue;
+    struct bma250_data *data;
+    int cfg_calibration[3],cfg_position;
+    unsigned char offset[3];
+    int ret=0;
+    int index;
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        printk(KERN_INFO "i2c_check_functionality error\n");
+        goto exit;
+    }
+    
+    data = kzalloc(sizeof(struct bma250_data), GFP_KERNEL);
+    if (!data) {
+        err = -ENOMEM;
+        goto exit;
+    }
+
+    /* read chip id */
+    tempvalue = i2c_smbus_read_byte_data(client, BMA250_CHIP_ID_REG);
+    if ((tempvalue == BMA250_CHIP_ID) || (tempvalue == BMA250E_CHIP_ID)) {
+        printk(KERN_INFO "BMA250 detected!\n");
+    } else{
+        printk(KERN_INFO "BMA250 not found! I2c error %d \n", tempvalue);
+        err = -ENODEV;
+        goto kfree_exit;
+    }    
+    i2c_set_clientdata(client, data);
+    data->bma250_client = client;
+
+	cfg_position=gsensor_dt_position(SENSOR_NAME,client);
+    atomic_set(&data->position, cfg_position);
+    
+	if (gsensor_read_calibration(&cfg_calibration)!=0){		//if get the file calib failed,then read dts default.
+		if (gsensor_dt_calib("bma250",&cfg_calibration,client)!=0)
+		{
+			printk(KERN_ERR "get calibration error\n");
+			memset(offset, 0, sizeof(offset));
+		}
+		else
+		{
+			printk("get calibration success %d,%d,%d\n",cfg_calibration[0],cfg_calibration[1],cfg_calibration[2]);
+		}
+	}
+	offset[0] = (unsigned char) cfg_calibration[0];
+    offset[1] = (unsigned char) cfg_calibration[1];
+    offset[2] = (unsigned char) cfg_calibration[2];
+    
+    if (bma250_set_offset_filt_xyz(client, offset, sizeof(offset)) < 0) {
+        printk(KERN_ERR"set offset fail\n");
+        goto kfree_exit;
+    }
+
+    /* register input device */
+    err = bma250_register_input(data);
+    if (err < 0) {
+        goto error_sysfs;
+    }
+
+    err = sysfs_create_group(&data->input->dev.kobj, &bma250_attribute_group);
+    if (err < 0) {
+        goto error_sysfs;
+    }
+
+    err = sysfs_create_group(&data->input2->dev.kobj, &bma250_attribute_group2);
+    if (err < 0) {
+        goto error_sysfs;
+    }
+    
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    data->early_suspend.suspend = bma250_early_suspend;
+    data->early_suspend.resume = bma250_late_resume;
+    register_early_suspend(&data->early_suspend);
+#endif
+
+    INIT_DELAYED_WORK(&data->work, bma250_work_func);
+    INIT_DELAYED_WORK(&data->work2, bma250_work_func2);
+    
+    mutex_init(&data->enable_mutex);
+    atomic_set(&data->delay, BMA250_MAX_DELAY);
+    atomic_set(&data->delay2, BMA250_MAX_DELAY);    
+    atomic_set(&data->enable, 0);
+    atomic_set(&data->enable2, 0);
+    atomic_set(&data->calibrated, 0);
+    atomic_set(&data->fuzz, FUZZ);
+    
+    bma250_set_bandwidth(client, BMA250_BW_SET);
+    bma250_set_range(client, BMA250_RANGE_SET);
+
+    return 0;
+
+error_sysfs:
+    input_unregister_device(data->input);
+    input_unregister_device(data->input2);
+kfree_exit:
+    kfree(data);
+exit:
+    return err;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma250_early_suspend(struct early_suspend *h)
+{
+    // sensor hal will disable when early suspend
+}
+
+
+static void bma250_late_resume(struct early_suspend *h)
+{
+    // sensor hal will enable when early resume
+}
+#endif
+
+static int bma250_remove(struct i2c_client *client)
+{
+    struct bma250_data *data = i2c_get_clientdata(client);
+
+    bma250_set_enable(&client->dev, 0);
+    bma250_set_enable2(&client->dev, 0);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    unregister_early_suspend(&data->early_suspend);
+#endif
+    sysfs_remove_group(&data->input->dev.kobj, &bma250_attribute_group);
+    sysfs_remove_group(&data->input->dev.kobj, &bma250_attribute_group2);
+    input_unregister_device(data->input);
+    input_unregister_device(data->input2);
+    kfree(data);
+
+    return 0;
+}
+#ifdef CONFIG_PM
+
+static int bma250_suspend(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *data = i2c_get_clientdata(client);
+    
+    // save offset
+    bma250_get_offset_filt_xyz(data->bma250_client, 
+                data->offset_saved, sizeof(data->offset_saved));
+                
+    bma250_do_enable(dev, 0);  
+    bma250_do_enable2(dev, 0);  
+    
+    return 0;
+}
+
+static int bma250_resume(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *data = i2c_get_clientdata(client);
+
+    // restore offset 
+    bma250_set_offset_filt_xyz(data->bma250_client, 
+                data->offset_saved, sizeof(data->offset_saved));
+                
+    bma250_do_enable(dev, atomic_read(&data->enable));
+    bma250_do_enable2(dev, atomic_read(&data->enable2));
+     
+    
+    return 0;
+}
+
+#else
+
+#define bma250_suspend        NULL
+#define bma250_resume        NULL
+
+#endif /* CONFIG_PM */
+
+static SIMPLE_DEV_PM_OPS(bma250_pm_ops, bma250_suspend, bma250_resume);
+
+static const unsigned short  bma250_addresses[] = {
+    0x18,
+    I2C_CLIENT_END,
+};
+
+static const struct i2c_device_id bma250_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, bma250_id);
+
+static int bma250_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+  struct i2c_adapter *adapter = client->adapter;
+
+  if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+    return -ENODEV;
+  strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+
+  return 0;
+}
+
+
+static struct i2c_driver bma250_driver = {
+    .driver = {
+        .owner    = THIS_MODULE,
+        .name    = SENSOR_NAME,
+        .pm    = &bma250_pm_ops,
+    },
+    .class        = I2C_CLASS_HWMON,
+    .address_list    = bma250_addresses,
+    .detect = bma250_detect,
+    .id_table    = bma250_id,
+    .probe        = bma250_probe,
+    .remove        = bma250_remove,
+
+};
+
+static struct i2c_board_info bma250_board_info={
+    .type = SENSOR_NAME, 
+    .addr = 0x18,
+};
+
+
+static int __init BMA250_init(void)
+{     
+    return i2c_add_driver(&bma250_driver);
+}
+
+static void __exit BMA250_exit(void)
+{;
+    i2c_del_driver(&bma250_driver);
+}
+
+MODULE_AUTHOR("Albert Zhang <xu.zhang@bosch-sensortec.com>");
+MODULE_DESCRIPTION("BMA250 accelerometer sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(BMA250_init);
+module_exit(BMA250_exit);
+
diff --git a/drivers/input/misc/gsensor/bma250_dummy.c b/drivers/input/misc/gsensor/bma250_dummy.c
new file mode 100755
index 0000000..15e5024
--- /dev/null
+++ b/drivers/input/misc/gsensor/bma250_dummy.c
@@ -0,0 +1,474 @@
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/uaccess.h>
+
+// dummy sensor rotation
+// 1 -- 0 degree, 2 -- 90 degree
+// 3- - 180 degree, 4 -- 270 degree
+#define SENSOR_ROTATION            3
+
+// device info
+#define SENSOR_NAME                   "bma250"
+#define SENSOR_I2C_ADDR            0x18
+#define ABSMIN                              -512
+#define ABSMAX                             512
+#define LSG                                   256
+#define MAX_DELAY                       200
+
+struct bma250_acc{
+    s16    x;
+    s16    y;
+    s16    z;
+} ;
+
+struct bma250_data {
+    struct i2c_client *bma250_client;
+    struct input_dev *input;
+    atomic_t delay;
+    atomic_t enable;
+    struct mutex enable_mutex;
+    struct delayed_work work;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend early_suspend;
+#endif
+    atomic_t position;
+};
+
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  1
+
+/*******************************************
+* for xml cfg
+*******************************************/
+#define CFG_GSENSOR_ADAP_ID          "gsensor.i2c_adap_id"
+#define CFG_GSENSOR_POSITION         "gsensor.position"
+#define CFG_GSENSOR_CALIBRATION      "gsensor.calibration"
+
+extern int get_config(const char *key, char *buff, int len);
+/*******************************************
+* end for xml cfg
+*******************************************/
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma250_early_suspend(struct early_suspend *h);
+static void bma250_early_resume(struct early_suspend *h);
+#endif
+
+static int bma250_read_data(struct i2c_client *client, struct bma250_acc *acc)
+{
+    static int count = 0;
+    int noise;
+    
+    // generate noise
+    noise = count / 4 - 1;
+    count = (count + 1)  % 12;
+    
+    // default orientation: screen upright
+    acc->x =  0;
+    acc->y =  LSG + noise;
+    acc->z =  0; 
+    
+    return 0;
+}
+
+static int bma250_axis_remap(struct i2c_client *client, struct bma250_acc *acc)
+{
+    s16 swap, cnt;
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    int position = atomic_read(&bma250->position);
+
+    for (cnt = 1; cnt < abs(position); cnt ++) { 
+        // rotate 90 degree
+        swap = acc->x;
+        acc->x = -(acc->y);
+        acc->y = swap;
+    }
+    
+    return 0;
+}
+
+static ssize_t bma250_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct input_dev *input = to_input_dev(dev);
+    struct bma250_data *bma250 = input_get_drvdata(input);
+    struct bma250_acc acc;
+
+    bma250_read_data(bma250->bma250_client, &acc);
+    bma250_axis_remap(bma250->bma250_client, &acc);   
+    
+    return sprintf(buf, "%d %d %d\n", acc.x, acc.y, acc.z);
+}
+
+static ssize_t bma250_delay_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma250->delay));
+
+}
+
+static ssize_t bma250_delay_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&bma250->delay, (unsigned int) data);
+
+    return count;
+}
+
+
+static ssize_t bma250_enable_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&bma250->enable));
+
+}
+
+static void bma250_do_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    if (enable) {
+        schedule_delayed_work(&bma250->work,
+            msecs_to_jiffies(atomic_read(&bma250->delay)));
+    } else {
+        cancel_delayed_work_sync(&bma250->work);
+    }
+}
+
+static void bma250_set_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+    int pre_enable = atomic_read(&bma250->enable);
+
+    mutex_lock(&bma250->enable_mutex);
+    if (enable != pre_enable) {
+        bma250_do_enable(dev, enable);
+        atomic_set(&bma250->enable, enable);
+    }
+    mutex_unlock(&bma250->enable_mutex);
+}
+
+static ssize_t bma250_enable_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if ((data == 0) || (data == 1))
+        bma250_set_enable(dev, data);
+
+    return count;
+}
+
+static ssize_t bma250_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    data = atomic_read(&(bma250->position));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma250_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(bma250->position), (int) data);
+
+    return count;
+}
+
+static DEVICE_ATTR(value, S_IRUGO,
+        bma250_value_show, NULL);
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_delay_show, bma250_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_enable_show, bma250_enable_store);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        bma250_board_position_show, bma250_board_position_store);
+
+static struct attribute *bma250_attributes[] = {
+    &dev_attr_value.attr,
+    &dev_attr_delay.attr,
+    &dev_attr_enable.attr,
+    &dev_attr_board_position.attr,
+    NULL
+};
+
+static struct attribute_group bma250_attribute_group = {
+    .attrs = bma250_attributes
+};
+
+static void bma250_work_func(struct work_struct *work)
+{
+    struct bma250_data *bma250 = container_of((struct delayed_work *)work,
+            struct bma250_data, work);
+    static struct bma250_acc acc;    
+    int result;
+    unsigned long delay = msecs_to_jiffies(atomic_read(&bma250->delay));
+    
+    result = bma250_read_data(bma250->bma250_client, &acc);
+    if (result == 0) {
+        bma250_axis_remap(bma250->bma250_client, &acc);
+        
+        input_report_abs(bma250->input, ABS_X, acc.x);
+        input_report_abs(bma250->input, ABS_Y, acc.y);
+        input_report_abs(bma250->input, ABS_Z, acc.z);
+        input_sync(bma250->input);
+    }
+    schedule_delayed_work(&bma250->work, delay);
+}
+
+static int bma250_probe(struct i2c_client *client,
+        const struct i2c_device_id *id)
+{
+    int err = 0;
+    struct bma250_data *data;
+    struct input_dev *dev;
+    int cfg_position;
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        printk(KERN_INFO "i2c_check_functionality error\n");
+        goto exit;
+    }
+    data = kzalloc(sizeof(struct bma250_data), GFP_KERNEL);
+    if (!data) {
+        err = -ENOMEM;
+        goto exit;
+    }
+
+    i2c_set_clientdata(client, data);
+    data->bma250_client = client;
+    mutex_init(&data->enable_mutex);
+
+    INIT_DELAYED_WORK(&data->work, bma250_work_func);
+    atomic_set(&data->delay, MAX_DELAY);
+    atomic_set(&data->enable, 0);
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+        /*get xml cfg*/
+        err = get_config(CFG_GSENSOR_POSITION, (char *)(&cfg_position), sizeof(int));
+        if (err != 0) {
+            printk(KERN_ERR"get position %d fail\n", cfg_position);
+            goto kfree_exit;
+        }
+#else
+        cfg_position = SENSOR_ROTATION;
+#endif
+    atomic_set(&data->position, cfg_position);
+        
+    dev = input_allocate_device();
+    if (!dev)
+        return -ENOMEM;
+    dev->name = SENSOR_NAME;
+    dev->id.bustype = BUS_I2C;
+
+    input_set_capability(dev, EV_ABS, ABS_MISC);
+    input_set_abs_params(dev, ABS_X, ABSMIN, ABSMAX, 0, 0);
+    input_set_abs_params(dev, ABS_Y, ABSMIN, ABSMAX, 0, 0);
+    input_set_abs_params(dev, ABS_Z, ABSMIN, ABSMAX, 0, 0);
+    input_set_drvdata(dev, data);
+
+    err = input_register_device(dev);
+    if (err < 0) {
+        input_free_device(dev);
+        goto kfree_exit;
+    }
+
+    data->input = dev;
+
+    err = sysfs_create_group(&data->input->dev.kobj,
+            &bma250_attribute_group);
+    if (err < 0)
+        goto error_sysfs;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    data->early_suspend.suspend = bma250_early_suspend;
+    data->early_suspend.resume = bma250_early_resume;
+    register_early_suspend(&data->early_suspend);
+#endif
+        
+    return 0;
+
+error_sysfs:
+    input_unregister_device(data->input);
+
+kfree_exit:
+    kfree(data);
+exit:
+    return err;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma250_early_suspend(struct early_suspend *h)
+{
+    // sensor hal will disable when early suspend
+}
+
+
+static void bma250_early_resume(struct early_suspend *h)
+{
+    // sensor hal will enable when early resume
+}
+#endif
+
+static int bma250_remove(struct i2c_client *client)
+{
+    struct bma250_data *data = i2c_get_clientdata(client);
+
+    bma250_set_enable(&client->dev, 0);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    unregister_early_suspend(&data->early_suspend);
+#endif
+    sysfs_remove_group(&data->input->dev.kobj, &bma250_attribute_group);
+    input_unregister_device(data->input);
+    kfree(data);
+
+    return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int bma250_suspend(struct device *dev)
+{
+    bma250_do_enable(dev, 0);
+    return 0;
+}
+
+static int bma250_resume(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct bma250_data *data = i2c_get_clientdata(client);
+    
+    bma250_do_enable(dev, atomic_read(&data->enable));    
+    return 0;
+}
+
+#else
+
+#define bma250_suspend        NULL
+#define bma250_resume        NULL
+
+#endif /* CONFIG_PM */
+
+static SIMPLE_DEV_PM_OPS(bma250_pm_ops, bma250_suspend, bma250_resume);
+
+static const unsigned short  bma250_addresses[] = {
+    SENSOR_I2C_ADDR,
+    I2C_CLIENT_END,
+};
+
+static const struct i2c_device_id bma250_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, bma250_id);
+
+static struct i2c_driver bma250_driver = {
+    .driver = {
+        .owner    = THIS_MODULE,
+        .name    = SENSOR_NAME,
+        .pm    = &bma250_pm_ops,
+    },
+    .class        = I2C_CLASS_HWMON,
+//    .address_list    = bma250_addresses,
+    .id_table    = bma250_id,
+    .probe        = bma250_probe,
+    .remove        = bma250_remove,
+
+};
+
+static struct i2c_board_info bma250_board_info={
+    .type = SENSOR_NAME, 
+    .addr = SENSOR_I2C_ADDR,
+};
+
+static struct i2c_client *bma250_client;
+
+static int __init bma250_init(void)
+{
+    struct i2c_adapter *i2c_adap;
+    unsigned int cfg_i2c_adap_id;
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+    int ret;
+    
+    /*get xml cfg*/
+    ret = get_config(CFG_GSENSOR_ADAP_ID, (char *)(&cfg_i2c_adap_id), sizeof(unsigned int));
+    if (ret != 0) {
+        printk(KERN_ERR"get i2c_adap_id %d fail\n", cfg_i2c_adap_id);
+        return ret;
+    }
+#else
+    cfg_i2c_adap_id = 2;
+#endif
+    
+    i2c_adap = i2c_get_adapter(cfg_i2c_adap_id);  
+    bma250_client = i2c_new_device(i2c_adap, &bma250_board_info);  
+    i2c_put_adapter(i2c_adap);
+    
+    return i2c_add_driver(&bma250_driver);
+}
+
+static void __exit bma250_exit(void)
+{
+    i2c_unregister_device(bma250_client);
+    i2c_del_driver(&bma250_driver);
+}
+
+MODULE_AUTHOR("Zhining Song <songzhining@actions-semi.com>");
+MODULE_DESCRIPTION("BMA250 dummy 3-Axis Orientation/Motion Detection Sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(bma250_init);
+module_exit(bma250_exit);
+
diff --git a/drivers/input/misc/gsensor/gsensor_detect.c b/drivers/input/misc/gsensor/gsensor_detect.c
new file mode 100755
index 0000000..6c6cc32
--- /dev/null
+++ b/drivers/input/misc/gsensor/gsensor_detect.c
@@ -0,0 +1,386 @@
+/*
+ * gsensor_detect.c  --  auto detect gsensor device
+ *
+ * Copyright 2012 Actions Semi Inc.
+ * Author: Actions Semi, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/async.h>
+#include <linux/hrtimer.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/gpio.h>
+#include <asm/prom.h>
+#include <mach/gpio.h>
+#include <linux/of.h>
+#include "gsensor_detect.h"
+
+#define CFG_GSENSOR_USE_CONFIG 1
+#define CFG_GSENSOR_ADAP_ID          "gsensor.i2c_adap_id"
+#define CFG_GSENSOR_REGULATOR        "gsensor.regulator"
+#define CFG_GSENSOR_DETECT_LIST      "gsensor_detect_list"
+
+//default value
+#define GSENSOR_I2C_ADAPTER     (2)
+#define GSENSOR_DETECT_NAME        "gsensor_detect"
+
+static int scan_start = 0;
+
+static unsigned int gsensor_adapter = 0;
+static char gsensor_regulator[32];
+
+struct i2c_client    *client;
+struct i2c_adapter *adap = NULL;
+static struct regulator *regulator = NULL;
+static struct kobject *kobj; 
+
+static char export_ko_name[32];
+static int export_ko_offset = 0;
+
+//GSENSOR POWER
+#define GSENSOR_POWER_ID        ("ldo5")
+#define GSENSOR_POWER_MIN_VOL    (3300000)
+#define GSENSOR_POWER_MAX_VOL    (3300000)   
+
+
+static struct regulator *regulator_init(const char *name, int minvol, int maxvol)
+{
+    struct regulator *power;
+		int ret;
+
+    power = regulator_get(NULL,name);
+        if (IS_ERR(power)) {
+        printk("err,regulator_get fail\n!!!");
+        return NULL;
+    }
+ 
+    if (regulator_set_voltage(power, minvol, maxvol)) {
+            printk("err,cannot set voltage\n!!!");
+            regulator_put(power);
+        return NULL;
+    }
+    ret = regulator_enable(power);
+    return (power);
+}
+
+static inline void regulator_deinit(struct regulator *power)
+{
+    regulator_disable(power);
+    regulator_put(power);
+}
+
+#if CFG_GSENSOR_USE_CONFIG
+static int gsensor_of_data_get(struct platform_device *pdev)
+{
+    int ret = -1;
+    int idx = 0;
+    struct gsensor_device *dev = NULL;
+    char cfg_name[32];
+    u32 cfg_detect = 0;
+    struct device_node *of_node;
+    struct device_node *list_node;
+    
+    of_node = pdev->dev.of_node;
+    ret = of_property_read_u32(of_node, "i2c_adapter_id", &gsensor_adapter);
+    if (ret == 0) {
+        gsensor_adapter = GSENSOR_I2C_ADAPTER;
+    }
+    
+    list_node = of_find_compatible_node(NULL, NULL, "gsensor_detect_list");
+    
+    /* get detect list config */
+    for (idx=0; idx < ARRAY_SIZE(gsensor_device_list); idx++) {
+        dev = &gsensor_device_list[idx];        
+        sprintf(cfg_name, "%s",  dev->name);
+        ret = of_property_read_u32(list_node, cfg_name, &cfg_detect);
+        if (ret == 0) {
+            dev->need_detect = (bool)cfg_detect;
+        }
+        printk("%s,%d, ctp_detect:%d\n", __func__, __LINE__, cfg_detect);
+    }
+
+    return ret;
+}
+#endif
+
+
+int gsensor_init(void)
+{
+    int ret=0;    
+    
+    if(gsensor_regulator[0] != '\0') {
+        regulator = regulator_init(gsensor_regulator, GSENSOR_POWER_MIN_VOL, GSENSOR_POWER_MAX_VOL);
+        if ( !regulator ) {
+            printk("gsensor init power failed");
+            ret = -EINVAL;
+        }
+    }
+    
+    return ret;
+}
+
+int gsensor_deinit(void)
+{
+    int ret=0;
+    
+    if (regulator != NULL) {
+        regulator_deinit(regulator);
+    }
+    
+    return ret;
+}
+
+bool test_i2c(struct gsensor_device *dev)
+{
+    int ret = -1, retry = 0;
+    uint8_t test_data[1] = { 0 };
+    
+    if (dev->need_detect == false) {
+        //printk("Skip the gsensor:%s,no need detect.\n", dev->name);
+        return false;
+    }
+    
+    if (dev->has_chipid == false) {
+        for (retry = 0; retry < 3; retry++) {
+            client->addr = dev->i2c_addr;
+            ret = i2c_master_send(client, test_data, 1);
+            if (ret == 1)
+                break;
+                
+            if (dev->has_sa0 == true) {
+                client->addr = dev->i2c_addr + 1;
+                ret = i2c_master_send(client, test_data, 1);
+                if (ret == 1)
+                    break;
+            }            
+            msleep(5);
+        }
+        
+        if (ret == 1) {
+            printk(KERN_ERR"Find u,u are:%s\n", dev->name);
+            return true;
+        }else{
+            printk(KERN_ERR"Is not the gsensor:%s,skip it.\n",dev->name);
+            return false;
+        }
+    } else {
+        for (retry = 0; retry < 3; retry++) {
+            client->addr = dev->i2c_addr;
+            ret = i2c_smbus_read_byte_data(client, dev->chipid_reg);
+            if (ret >= 0)
+                break;
+            
+            if (dev->has_sa0 == true) {
+                client->addr = dev->i2c_addr + 1;
+                ret = i2c_smbus_read_byte_data(client, dev->chipid_reg);
+                if (ret >= 0)
+                    break;
+            }       
+            msleep(5);
+        }
+        printk("%s: read the chipid is: 0x%x\n", dev->name, ret);
+        
+        if (ret == dev->chipid[0] || ret == dev->chipid[1]) {
+            printk("Find u,u are:%s\n",dev->name);
+            return true;
+        } else {
+            printk("Is not the gsensor:%s,skip it.\n",dev->name);
+            return false;
+        }
+    }
+
+    return false;
+}
+
+int gsensor_detect(void)
+{
+    int idx = 0;
+   
+    client = kzalloc(sizeof *client, GFP_KERNEL);
+    if (!client)
+        return -1;
+    
+    adap = i2c_get_adapter(gsensor_adapter);
+    if(!adap){
+        printk(KERN_ERR"err:%s, %d.\n", __func__, __LINE__);
+        return -1;
+    }
+    client->adapter = adap;
+    if ( scan_start > 0 && scan_start < ARRAY_SIZE(gsensor_device_list) ) {
+        if (true == test_i2c(&gsensor_device_list[scan_start])) {
+            return scan_start;
+        }
+    }
+    for(idx = 0; idx < ARRAY_SIZE(gsensor_device_list); idx++) {
+        if (true == test_i2c(&gsensor_device_list[idx])) {
+            return idx;
+        }
+    }
+    return -1;
+}
+
+static ssize_t name_show(struct device *dev,  struct device_attribute *attr,  
+        char *buf)  
+{  
+    return strlcpy(buf, export_ko_name, sizeof(export_ko_name)); 
+}  
+
+static ssize_t offset_show(struct device *dev,  struct device_attribute *attr,  
+        char *buf)  
+{  
+    return sprintf(buf, "%d", export_ko_offset); 
+}  
+
+static DEVICE_ATTR(name, 0400, name_show, NULL); 
+static DEVICE_ATTR(offset, 0400, offset_show, NULL); 
+
+static int gsensor_detect_probe(struct platform_device *pdev)
+{
+    int ret = 0;
+
+#if CFG_GSENSOR_USE_CONFIG
+    gsensor_of_data_get(pdev);
+#else
+    gsensor_adapter = GSENSOR_I2C_ADAPTER;
+    strcpy(gsensor_regulator, GSENSOR_POWER_ID);
+#endif
+
+    ret=gsensor_init();
+    if(ret){
+        printk(KERN_ERR"gsensor init failed.\n");
+        goto exit;
+    }
+    
+    kobj = kobject_create_and_add("gsensor_detect", NULL);  
+    if (kobj == NULL) {  
+        printk("kobject_create_and_add failed.\n"); 
+        ret = -ENOMEM;  
+        goto kobject_create_err;  
+    }  
+    
+    ret = sysfs_create_file(kobj,&dev_attr_name.attr);  
+    if (ret < 0){
+        printk(KERN_ERR"sysfs_create_file failed.\n");
+        goto sysfs_create_err;
+    }
+
+    ret = sysfs_create_file(kobj,&dev_attr_offset.attr);  
+    if (ret < 0){
+        printk(KERN_ERR"sysfs_create_file failed.\n");
+        goto sysfs_create_err;
+    }
+    
+    ret = gsensor_detect();
+    if (ret < 0) {
+        printk(KERN_ERR"Sorry,no one suit!!!\n");
+    } else {
+        strlcpy(export_ko_name, gsensor_device_list[ret].ko_name, strlen(gsensor_device_list[ret].ko_name)+1);
+        
+        if (gsensor_device_list[ret].has_chipid == true) {
+            export_ko_offset = ret;
+        } else {
+            export_ko_offset = 0;
+        }
+    }
+    gsensor_deinit();
+
+    return 0;
+    
+sysfs_create_err:  
+    kobject_del(kobj);
+kobject_create_err:
+    gsensor_deinit();
+exit:
+    return ret;
+}
+
+static int gsensor_detect_remove(struct platform_device *pdev)
+{
+    //printk("==gsensor_detect_remove==\n");
+    sysfs_remove_file(kobj,&dev_attr_name.attr);
+    kobject_del(kobj);
+    kfree(client);
+    return 0;
+}
+
+static struct of_device_id gsensor_detect_of_match[] = {
+	{ .compatible = "owl-gsensor-detect" },
+	{ }
+};
+
+static struct platform_driver detect_driver = {
+    .driver = {
+        .name = GSENSOR_DETECT_NAME,
+        .owner = THIS_MODULE,
+        .of_match_table	= of_match_ptr(gsensor_detect_of_match),
+    },
+    .probe = gsensor_detect_probe,
+    .remove = gsensor_detect_remove,
+};
+
+#if 0
+static void detect_device_release(struct device * dev)
+{
+    return;
+}
+
+static struct platform_device detect_device = {
+    .name = GSENSOR_DETECT_NAME,
+    .dev = {
+        .release = detect_device_release,
+    }
+};
+#endif
+
+static int __init gsensor_detect_init(void)
+{
+    int ret;
+    printk("==gsensor_detect_init==\n");
+
+    //ret=platform_device_register(&detect_device);
+    //if(ret) return ret;
+    ret=platform_driver_register(&detect_driver);
+    return ret;
+}
+
+static void __exit gsensor_detect_exit(void)
+{
+    printk("==gsensor_detect_exit==\n");
+    
+    platform_driver_unregister(&detect_driver);
+    //platform_device_unregister(&detect_device);
+    return;
+}
+
+module_init(gsensor_detect_init);
+module_exit(gsensor_detect_exit);
+
+module_param(scan_start, int, S_IRUSR);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("GSENSOR auto detect driver");
+MODULE_AUTHOR("Actions Semi, Inc");
+MODULE_ALIAS("platform:gsensor_detect");
+
diff --git a/drivers/input/misc/gsensor/gsensor_detect.h b/drivers/input/misc/gsensor/gsensor_detect.h
new file mode 100755
index 0000000..cf25362
--- /dev/null
+++ b/drivers/input/misc/gsensor/gsensor_detect.h
@@ -0,0 +1,189 @@
+#ifndef _GSENSOR_DETECT_H_
+#define _GSENSOR_DETECT_H_
+
+struct gsensor_device
+{
+    char * name;            //0.IC\C3\FB\B3\C6
+    char * ko_name;         //1.ko\C3\FB\B3\C6
+    bool has_sa0;             //2.\D3\D0sa0 pin
+    unsigned char i2c_addr;    //3.i2c\B5\D8Ö·
+    bool has_chipid;        //4.\D3\D0chipid
+    unsigned char chipid_reg; //5.chipid\BCÄ´\E6\C6\F7
+    unsigned char chipid[2];   //6.chipid 
+    bool need_detect;	     //7.\CAÇ·\F1É¨\C3\E8
+};
+
+//Ã¿\D4\F6\BC\D3Ò»\BF\EEIC\A3\AC\CD\F9\D5\E2\B8\F6\C1Ð±\ED\C0\EF\CC\ED\BC\D3
+//×¢\D2\E2\C8\E7\B9\FB\C1\BD\B8\F6ic\B5\C4i2c\B5\D8Ö·\CF\E0Í¬\A3\AC\B0\D1\D3\D0chipid\B5Ä·\C5\D4\DAÇ°\C3æ¡£
+struct gsensor_device gsensor_device_list[]=
+{
+    // AFA750
+    {
+        "afa750",                    //0.IC\C3\FB\B3\C6
+        "gsensor_afa750.ko",    //1.ko\C3\FB\B3\C6
+        true,                           //2.\D3\D0sa0 pin
+        0x3c,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x37,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x3c, 0x3d},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    // BMA220
+    {
+        "bma220",                    //0.IC\C3\FB\B3\C6
+        "gsensor_bma220.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x0a,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x00,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0xdd, 0xdd},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    
+    // BMA222 bma223
+    {
+        "bma222",                    //0.IC\C3\FB\B3\C6
+        "gsensor_bma222.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x18,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x00,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x02, 0xf8},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    
+    // BMA250/BMA250E
+    {
+        "bma250",                    //0.IC\C3\FB\B3\C6
+        "gsensor_bma250.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x18,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x00,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x03, 0xf9},              //6.chipid
+        //true,                           //7.\CAÇ·\F1É¨\C3\E8
+        false,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    // DMARD10
+    {
+        "dmard10",                    //0.IC\C3\FB\B3\C6
+        "gsensor_dmard10.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x18,                          //3.i2c\B5\D8Ö·
+        false,                           //4.\D3\D0chipid
+        0x00,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x00, 0x00},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    
+    // kxtj9-1007
+    {
+        "kxtj9",                    //0.IC\C3\FB\B3\C6
+        "gsensor_kionix_accel.ko",    //1.ko\C3\FB\B3\C6
+        true,                           //2.\D3\D0sa0 pin
+        0x0e,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x0f,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x08, 0x08},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    
+    // lis3dh
+    {
+        "lis3dh",                    //0.IC\C3\FB\B3\C6
+        "gsensor_lis3dh_acc.ko",    //1.ko\C3\FB\B3\C6
+        true,                           //2.\D3\D0sa0 pin
+        0x18,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x0f,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x33, 0x33},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    
+    // mc3210
+    {
+        "mc3210",                    //0.IC\C3\FB\B3\C6
+        "gsensor_mc3210.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x4c,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x3b,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x90, 0x90},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+
+    // mc3232
+    {
+        "mc3232",                    //0.IC\C3\FB\B3\C6
+        "gsensor_mc3232.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x4c,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x3b,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x19, 0x19},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+
+    // mc3236
+    {
+        "mc3236",                    //0.IC\C3\FB\B3\C6
+        "gsensor_mc3236.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x4c,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x3b,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x60, 0x60},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+
+    // mma7660
+    {
+        "mma7660",                    //0.IC\C3\FB\B3\C6
+        "gsensor_mma7660.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x4c,                          //3.i2c\B5\D8Ö·
+        false,                           //4.\D3\D0chipid
+        0x00,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x00, 0x00},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    
+    // mma8452
+    {
+        "mma8452",                    //0.IC\C3\FB\B3\C6
+        "gsensor_mma8452.ko",    //1.ko\C3\FB\B3\C6
+        true,                           //2.\D3\D0sa0 pin
+        0x1c,                          //3.i2c\B5\D8Ö·
+        true,                           //4.\D3\D0chipid
+        0x0d,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x2a, 0x2a},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    
+    // stk8312
+    {
+        "stk8312",                    //0.IC\C3\FB\B3\C6
+        "gsensor_stk8312.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x3d,                          //3.i2c\B5\D8Ö·
+        false,                           //4.\D3\D0chipid
+        0x00,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x00, 0x00},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+    
+    // stk8313
+    {
+        "stk8313",                    //0.IC\C3\FB\B3\C6
+        "gsensor_stk8313.ko",    //1.ko\C3\FB\B3\C6
+        false,                           //2.\D3\D0sa0 pin
+        0x22,                          //3.i2c\B5\D8Ö·
+        false,                           //4.\D3\D0chipid
+        0x00,                          //5.chipid\BCÄ´\E6\C6\F7
+        {0x00, 0x00},              //6.chipid
+        true,                           //7.\CAÇ·\F1É¨\C3\E8
+    },
+};
+
+
+#endif
diff --git a/drivers/input/misc/gsensor/kionix/Makefile b/drivers/input/misc/gsensor/kionix/Makefile
new file mode 100755
index 0000000..2ff8170
--- /dev/null
+++ b/drivers/input/misc/gsensor/kionix/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the kionix drivers
+#
+
+obj-$(CONFIG_GSENSOR_KIONIX) += gsensor_kionix.o
+gsensor_kionix-objs := kionix_accel.o
diff --git a/drivers/input/misc/gsensor/kionix/kionix_accel.c b/drivers/input/misc/gsensor/kionix/kionix_accel.c
new file mode 100755
index 0000000..29cd9de
--- /dev/null
+++ b/drivers/input/misc/gsensor/kionix/kionix_accel.c
@@ -0,0 +1,2212 @@
+/* drivers/input/misc/kionix_accel.c - Kionix accelerometer driver
+ *
+ * Copyright (C) 2012 Kionix, Inc.
+ * Written by Kuching Tan <kuchingtan@kionix.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+
+#ifdef    CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+#include "kionix_accel.h"
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  1
+
+
+/* Debug Message Flags */
+#define KIONIX_KMSG_ERR	1	/* Print kernel debug message for error */
+#define KIONIX_KMSG_INF	1	/* Print kernel debug message for info */
+
+#if KIONIX_KMSG_ERR
+#define KMSGERR(format, ...)	\
+		dev_err(format, ## __VA_ARGS__)
+#else
+#define KMSGERR(format, ...)
+#endif
+
+#if KIONIX_KMSG_INF
+#define KMSGINF(format, ...)	\
+		dev_info(format, ## __VA_ARGS__)
+#else
+#define KMSGINF(format, ...)
+#endif
+
+// calibration file path
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+#define LSG 1024
+
+/******************************************************************************
+ * Accelerometer WHO_AM_I return value
+ *****************************************************************************/
+#define KIONIX_ACCEL_WHO_AM_I_KXTE9 		0x00
+#define KIONIX_ACCEL_WHO_AM_I_KXTF9 		0x01
+#define KIONIX_ACCEL_WHO_AM_I_KXTI9_1001 	0x04
+#define KIONIX_ACCEL_WHO_AM_I_KXTIK_1004 	0x05
+#define KIONIX_ACCEL_WHO_AM_I_KXTJ9_1005 	0x07
+#define KIONIX_ACCEL_WHO_AM_I_KXTJ9_1007 	0x08
+#define KIONIX_ACCEL_WHO_AM_I_KXCJ9_1008 	0x0A
+#define KIONIX_ACCEL_WHO_AM_I_KXTJ2_1009 	0x09
+#define KIONIX_ACCEL_WHO_AM_I_KXCJK_1013 	0x11
+
+/******************************************************************************
+ * Accelerometer Grouping
+ *****************************************************************************/
+#define KIONIX_ACCEL_GRP1	1	/* KXTE9 */
+#define KIONIX_ACCEL_GRP2	2	/* KXTF9/I9-1001/J9-1005 */
+#define KIONIX_ACCEL_GRP3	3	/* KXTIK-1004 */
+#define KIONIX_ACCEL_GRP4	4	/* KXTJ9-1007/KXCJ9-1008 */
+#define KIONIX_ACCEL_GRP5	5	/* KXTJ2-1009 */
+#define KIONIX_ACCEL_GRP6	6	/* KXCJK-1013 */
+
+/******************************************************************************
+ * Registers for Accelerometer Group 1 & 2 & 3
+ *****************************************************************************/
+#define ACCEL_WHO_AM_I		0x0F
+
+/*****************************************************************************/
+/* Registers for Accelerometer Group 1 */
+/*****************************************************************************/
+/* Output Registers */
+#define ACCEL_GRP1_XOUT			0x12
+/* Control Registers */
+#define ACCEL_GRP1_CTRL_REG1	0x1B
+/* CTRL_REG1 */
+#define ACCEL_GRP1_PC1_OFF		0x7F
+#define ACCEL_GRP1_PC1_ON		(1 << 7)
+#define ACCEL_GRP1_ODR40		(3 << 3)
+#define ACCEL_GRP1_ODR10		(2 << 3)
+#define ACCEL_GRP1_ODR3			(1 << 3)
+#define ACCEL_GRP1_ODR1			(0 << 3)
+#define ACCEL_GRP1_ODR_MASK		(3 << 3)
+
+/*****************************************************************************/
+/* Registers for Accelerometer Group 2 & 3 */
+/*****************************************************************************/
+/* Output Registers */
+#define ACCEL_GRP2_XOUT_L		0x06
+/* Control Registers */
+#define ACCEL_GRP2_INT_REL		0x1A
+#define ACCEL_GRP2_CTRL_REG1	0x1B
+#define ACCEL_GRP2_INT_CTRL1	0x1E
+#define ACCEL_GRP2_DATA_CTRL	0x21
+/* CTRL_REG1 */
+#define ACCEL_GRP2_PC1_OFF		0x7F
+#define ACCEL_GRP2_PC1_ON		(1 << 7)
+#define ACCEL_GRP2_DRDYE		(1 << 5)
+#define ACCEL_GRP2_G_8G			(2 << 3)
+#define ACCEL_GRP2_G_4G			(1 << 3)
+#define ACCEL_GRP2_G_2G			(0 << 3)
+#define ACCEL_GRP2_G_MASK		(3 << 3)
+#define ACCEL_GRP2_RES_8BIT		(0 << 6)
+#define ACCEL_GRP2_RES_12BIT	(1 << 6)
+#define ACCEL_GRP2_RES_MASK		(1 << 6)
+/* INT_CTRL1 */
+#define ACCEL_GRP2_IEA			(1 << 4)
+#define ACCEL_GRP2_IEN			(1 << 5)
+/* DATA_CTRL_REG */
+#define ACCEL_GRP2_ODR12_5		0x00
+#define ACCEL_GRP2_ODR25		0x01
+#define ACCEL_GRP2_ODR50		0x02
+#define ACCEL_GRP2_ODR100		0x03
+#define ACCEL_GRP2_ODR200		0x04
+#define ACCEL_GRP2_ODR400		0x05
+#define ACCEL_GRP2_ODR800		0x06
+/*****************************************************************************/
+
+/*****************************************************************************/
+/* Registers for Accelerometer Group 4 & 5 & 6 */
+/*****************************************************************************/
+/* Output Registers */
+#define ACCEL_GRP4_XOUT_L		0x06
+/* Control Registers */
+#define ACCEL_GRP4_INT_REL		0x1A
+#define ACCEL_GRP4_CTRL_REG1	0x1B
+#define ACCEL_GRP4_INT_CTRL1	0x1E
+#define ACCEL_GRP4_DATA_CTRL	0x21
+/* CTRL_REG1 */
+#define ACCEL_GRP4_PC1_OFF		0x7F
+#define ACCEL_GRP4_PC1_ON		(1 << 7)
+#define ACCEL_GRP4_DRDYE		(1 << 5)
+#define ACCEL_GRP4_G_8G			(2 << 3)
+#define ACCEL_GRP4_G_4G			(1 << 3)
+#define ACCEL_GRP4_G_2G			(0 << 3)
+#define ACCEL_GRP4_G_MASK		(3 << 3)
+#define ACCEL_GRP4_RES_8BIT		(0 << 6)
+#define ACCEL_GRP4_RES_12BIT	(1 << 6)
+#define ACCEL_GRP4_RES_MASK		(1 << 6)
+/* INT_CTRL1 */
+#define ACCEL_GRP4_IEA			(1 << 4)
+#define ACCEL_GRP4_IEN			(1 << 5)
+/* DATA_CTRL_REG */
+#define ACCEL_GRP4_ODR0_781		0x08
+#define ACCEL_GRP4_ODR1_563		0x09
+#define ACCEL_GRP4_ODR3_125		0x0A
+#define ACCEL_GRP4_ODR6_25		0x0B
+#define ACCEL_GRP4_ODR12_5		0x00
+#define ACCEL_GRP4_ODR25		0x01
+#define ACCEL_GRP4_ODR50		0x02
+#define ACCEL_GRP4_ODR100		0x03
+#define ACCEL_GRP4_ODR200		0x04
+#define ACCEL_GRP4_ODR400		0x05
+#define ACCEL_GRP4_ODR800		0x06
+#define ACCEL_GRP4_ODR1600		0x07
+/*****************************************************************************/
+
+/* Input Event Constants */
+#define ACCEL_G_MAX			8096
+#define ACCEL_FUZZ			3
+#define ACCEL_FLAT			3
+/* I2C Retry Constants */
+#define KIONIX_I2C_RETRY_COUNT		10 	/* Number of times to retry i2c */
+#define KIONIX_I2C_RETRY_TIMEOUT	1	/* Timeout between retry (miliseconds) */
+
+/* Earlysuspend Contants */
+#define KIONIX_ACCEL_EARLYSUSPEND_TIMEOUT	5000	/* Timeout (miliseconds) */
+
+/*
+ * The following table lists the maximum appropriate poll interval for each
+ * available output data rate (ODR).
+ */
+static const struct {
+	unsigned int cutoff;
+	u8 mask;
+} kionix_accel_grp1_odr_table[] = {
+	{ 100,	ACCEL_GRP1_ODR40 },
+	{ 334,	ACCEL_GRP1_ODR10 },
+	{ 1000,	ACCEL_GRP1_ODR3  },
+	{ 0,	ACCEL_GRP1_ODR1  },
+};
+
+static const struct {
+	unsigned int cutoff;
+	u8 mask;
+} kionix_accel_grp2_odr_table[] = {
+	{ 3,	ACCEL_GRP2_ODR800 },
+	{ 5,	ACCEL_GRP2_ODR400 },
+	{ 10,	ACCEL_GRP2_ODR200 },
+	{ 20,	ACCEL_GRP2_ODR100 },
+	{ 40,	ACCEL_GRP2_ODR50  },
+	{ 80,	ACCEL_GRP2_ODR25  },
+	{ 0,	ACCEL_GRP2_ODR12_5},
+};
+
+static const struct {
+	unsigned int cutoff;
+	u8 mask;
+} kionix_accel_grp4_odr_table[] = {
+	{ 2,	ACCEL_GRP4_ODR1600 },
+	{ 3,	ACCEL_GRP4_ODR800 },
+	{ 5,	ACCEL_GRP4_ODR400 },
+	{ 10,	ACCEL_GRP4_ODR200 },
+	{ 20,	ACCEL_GRP4_ODR100 },
+	{ 40,	ACCEL_GRP4_ODR50  },
+	{ 80,	ACCEL_GRP4_ODR25  },
+	{ 160,	ACCEL_GRP4_ODR12_5},
+	{ 320,	ACCEL_GRP4_ODR6_25},
+	{ 640,	ACCEL_GRP4_ODR3_125},
+	{ 1280,	ACCEL_GRP4_ODR1_563},
+	{ 0,	ACCEL_GRP4_ODR0_781},
+};
+
+enum {
+	accel_grp1_ctrl_reg1 = 0,
+	accel_grp1_regs_count,
+};
+
+enum {
+	accel_grp2_ctrl_reg1 = 0,
+	accel_grp2_data_ctrl,
+	accel_grp2_int_ctrl,
+	accel_grp2_regs_count,
+};
+
+enum {
+	accel_grp4_ctrl_reg1 = 0,
+	accel_grp4_data_ctrl,
+	accel_grp4_int_ctrl,
+	accel_grp4_regs_count,
+};
+struct kionix_acc{
+    s16    x;
+    s16    y;
+    s16    z;
+} ;
+
+struct kionix_accel_driver {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct delayed_work accel_work;
+	struct workqueue_struct *accel_workqueue;
+	wait_queue_head_t wqh_suspend;
+
+	int accel_data[3];
+	int accel_cali[3];
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+	bool negate_x;
+	bool negate_y;
+	bool negate_z;
+	u8 shift;
+
+	struct kionix_acc offset;
+
+
+	unsigned int poll_interval;
+	unsigned int poll_delay;
+	unsigned int accel_group;
+	u8 *accel_registers;
+	atomic_t position;
+	atomic_t calibrated;
+	atomic_t accel_suspended;
+	atomic_t accel_suspend_continue;
+	atomic_t accel_enabled;
+	atomic_t accel_input_event;
+	atomic_t accel_enable_resume;
+	struct mutex mutex_earlysuspend;
+	struct mutex mutex_resume;
+	rwlock_t rwlock_accel_data;
+
+	bool accel_drdy;
+
+	/* Function callback */
+	void (*kionix_accel_report_accel_data)(struct kionix_accel_driver *acceld);
+	int (*kionix_accel_update_odr)(struct kionix_accel_driver *acceld, unsigned int poll_interval);
+	int (*kionix_accel_power_on_init)(struct kionix_accel_driver *acceld);
+	int (*kionix_accel_operate)(struct kionix_accel_driver *acceld);
+	int (*kionix_accel_standby)(struct kionix_accel_driver *acceld);
+
+#ifdef    CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+};
+
+static int kionix_i2c_read(struct i2c_client *client, u8 addr, u8 *data, int len)
+{
+	struct i2c_msg msgs[] = {
+		{
+			.addr = client->addr,
+			.flags = client->flags,
+			.len = 1,
+			.buf = &addr,
+		},
+		{
+			.addr = client->addr,
+			.flags = client->flags | I2C_M_RD,
+			.len = len,
+			.buf = data,
+		},
+	};
+
+	return i2c_transfer(client->adapter, msgs, 2);
+}
+
+static int kionix_strtok(const char *buf, size_t count, char **token, const int token_nr)
+{
+	char *buf2 = (char *)kzalloc((count + 1) * sizeof(char), GFP_KERNEL);
+	char **token2 = token;
+	unsigned int num_ptr = 0, num_nr = 0, num_neg = 0;
+	int i = 0, start = 0, end = (int)count;
+
+	strcpy(buf2, buf);
+
+	/* We need to breakup the string into separate chunks in order for kstrtoint
+	 * or strict_strtol to parse them without returning an error. Stop when the end of
+	 * the string is reached or when enough value is read from the string */
+	while((start < end) && (i < token_nr)) {
+		/* We found a negative sign */
+		if(*(buf2 + start) == '-') {
+			/* Previous char(s) are numeric, so we store their value first before proceed */
+			if(num_nr > 0) {
+				/* If there is a pending negative sign, we adjust the variables to account for it */
+				if(num_neg) {
+					num_ptr--;
+					num_nr++;
+				}
+				*token2 = (char *)kzalloc((num_nr + 2) * sizeof(char), GFP_KERNEL);
+				strncpy(*token2, (const char *)(buf2 + num_ptr), (size_t) num_nr);
+				*(*token2+num_nr) = '\n';
+				i++;
+				token2++;
+				/* Reset */
+				num_ptr = num_nr = 0;
+			}
+			/* This indicates that there is a pending negative sign in the string */
+			num_neg = 1;
+		}
+		/* We found a numeric */
+		else if((*(buf2 + start) >= '0') && (*(buf2 + start) <= '9')) {
+			/* If the previous char(s) are not numeric, set num_ptr to current char */
+			if(num_nr < 1)
+				num_ptr = start;
+			num_nr++;
+		}
+		/* We found an unwanted character */
+		else {
+			/* Previous char(s) are numeric, so we store their value first before proceed */
+			if(num_nr > 0) {
+				if(num_neg) {
+					num_ptr--;
+					num_nr++;
+				}
+				*token2 = (char *)kzalloc((num_nr + 2) * sizeof(char), GFP_KERNEL);
+				strncpy(*token2, (const char *)(buf2 + num_ptr), (size_t) num_nr);
+				*(*token2+num_nr) = '\n';
+				i++;
+				token2++;
+			}
+			/* Reset all the variables to start afresh */
+			num_ptr = num_nr = num_neg = 0;
+		}
+		start++;
+	}
+
+	kfree(buf2);
+
+	return (i == token_nr) ? token_nr : -1;
+}
+static int kionix_read_file(char *path, char *buf, int size)
+{
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+static int kionix_load_user_calibration(struct i2c_client *client)
+{
+    char buffer[16];
+    int ret = 0;
+    int data[3];
+    struct kionix_accel_driver *acceld = i2c_get_clientdata(client);    
+    int calibrated = atomic_read(&acceld->calibrated);
+    
+    // only calibrate once
+    if (calibrated) {
+        goto usr_calib_end;
+    } else {
+        atomic_set(&acceld->calibrated, 1);
+    }
+
+    ret = kionix_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d", &data[0], &data[1], &data[2]);
+    acceld->offset.x = (signed short) data[0];
+    acceld->offset.y = (signed short) data[1];
+    acceld->offset.z = (signed short) data[2];
+    
+    printk(KERN_INFO "user cfg_calibration: %d %d %d\n", data[0], data[1], data[2]);
+    
+usr_calib_end:
+    return ret;
+
+
+}
+
+static int kionix_accel_grp1_power_on_init(struct kionix_accel_driver *acceld)
+{
+	int err;
+
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		err = i2c_smbus_write_byte_data(acceld->client,
+						ACCEL_GRP1_CTRL_REG1, acceld->accel_registers[accel_grp1_ctrl_reg1] | ACCEL_GRP1_PC1_ON);
+		if (err < 0)
+			return err;
+	}
+	else {
+		err = i2c_smbus_write_byte_data(acceld->client,
+						ACCEL_GRP1_CTRL_REG1, acceld->accel_registers[accel_grp1_ctrl_reg1]);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int kionix_accel_grp1_operate(struct kionix_accel_driver *acceld)
+{
+	int err;
+
+	err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP1_CTRL_REG1, \
+			acceld->accel_registers[accel_grp2_ctrl_reg1] | ACCEL_GRP1_PC1_ON);
+	if (err < 0)
+		return err;
+
+	if(acceld->accel_workqueue != NULL)
+		queue_delayed_work(acceld->accel_workqueue, &acceld->accel_work, 0);
+
+	return 0;
+}
+
+static int kionix_accel_grp1_standby(struct kionix_accel_driver *acceld)
+{
+	int err;
+
+	cancel_delayed_work_sync(&acceld->accel_work);
+
+	err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP1_CTRL_REG1, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static void kionix_accel_grp1_report_accel_data(struct kionix_accel_driver *acceld)
+{
+	u8 accel_data[3];
+	s16 x, y, z;
+	int err;
+	struct input_dev *input_dev = NULL;
+	int loop = KIONIX_I2C_RETRY_COUNT;
+
+	input_dev = acceld->input_dev;
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		if(atomic_read(&acceld->accel_enable_resume) > 0)
+		{
+			while(loop) {
+				//mutex_lock(&input_dev->mutex);
+				//printk("lock input_dev->mutex\n");
+				err = kionix_i2c_read(acceld->client, ACCEL_GRP1_XOUT, accel_data, 6);
+				
+				//mutex_unlock(&input_dev->mutex);
+				if(err < 0){
+					loop--;
+					mdelay(KIONIX_I2C_RETRY_TIMEOUT);
+				}
+				else
+					loop = 0;
+			}
+			if (err < 0) {
+				KMSGERR(&acceld->client->dev, "%s: read data output error = %d\n", __func__, err);
+			}
+			else {
+				write_lock(&acceld->rwlock_accel_data);
+
+				x = ((s16) le16_to_cpu(((s16)(accel_data[acceld->axis_map_x] >> 2)) - 32)) << 6;
+				y = ((s16) le16_to_cpu(((s16)(accel_data[acceld->axis_map_y] >> 2)) - 32)) << 6;
+				z = ((s16) le16_to_cpu(((s16)(accel_data[acceld->axis_map_z] >> 2)) - 32)) << 6;
+
+				acceld->accel_data[acceld->axis_map_x] = (acceld->negate_x ? -x : x) + acceld->accel_cali[acceld->axis_map_x];
+				acceld->accel_data[acceld->axis_map_y] = (acceld->negate_y ? -y : y) + acceld->accel_cali[acceld->axis_map_y];
+				acceld->accel_data[acceld->axis_map_z] = (acceld->negate_z ? -z : z) + acceld->accel_cali[acceld->axis_map_z];
+
+				if(atomic_read(&acceld->accel_input_event) > 0) {
+					input_report_abs(acceld->input_dev, ABS_X, acceld->accel_data[acceld->axis_map_x]);
+					input_report_abs(acceld->input_dev, ABS_Y, acceld->accel_data[acceld->axis_map_y]);
+					input_report_abs(acceld->input_dev, ABS_Z, acceld->accel_data[acceld->axis_map_z]);
+					input_sync(acceld->input_dev);
+				}
+
+				write_unlock(&acceld->rwlock_accel_data);
+			}
+		}
+		else
+		{
+			atomic_inc(&acceld->accel_enable_resume);
+		}
+	}
+}
+
+
+
+
+
+static int kionix_accel_grp1_update_odr(struct kionix_accel_driver *acceld, unsigned int poll_interval)
+{
+	int err;
+	int i;
+	u8 odr;
+
+	/* Use the lowest ODR that can support the requested poll interval */
+	for (i = 0; i < ARRAY_SIZE(kionix_accel_grp1_odr_table); i++) {
+		odr = kionix_accel_grp1_odr_table[i].mask;
+		if (poll_interval < kionix_accel_grp1_odr_table[i].cutoff)
+			break;
+	}
+
+	/* Do not need to update CTRL_REG1 register if the ODR is not changed */
+	if((acceld->accel_registers[accel_grp1_ctrl_reg1] & ACCEL_GRP1_ODR_MASK) == odr)
+		return 0;
+	else {
+		acceld->accel_registers[accel_grp1_ctrl_reg1] &= ~ACCEL_GRP1_ODR_MASK;
+		acceld->accel_registers[accel_grp1_ctrl_reg1] |= odr;
+	}
+
+	/* Do not need to update CTRL_REG1 register if the sensor is not currently turn on */
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP1_CTRL_REG1, \
+				acceld->accel_registers[accel_grp1_ctrl_reg1] | ACCEL_GRP1_PC1_ON);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int kionix_accel_grp2_power_on_init(struct kionix_accel_driver *acceld)
+{
+	int err;
+
+	/* ensure that PC1 is cleared before updating control registers */
+	err = i2c_smbus_write_byte_data(acceld->client,
+					ACCEL_GRP2_CTRL_REG1, 0);
+	if (err < 0)
+		return err;
+
+	err = i2c_smbus_write_byte_data(acceld->client,
+					ACCEL_GRP2_DATA_CTRL, acceld->accel_registers[accel_grp2_data_ctrl]);
+	if (err < 0)
+		return err;
+
+	/* only write INT_CTRL_REG1 if in irq mode */
+	if (acceld->client->irq) {
+		err = i2c_smbus_write_byte_data(acceld->client,
+						ACCEL_GRP2_INT_CTRL1, acceld->accel_registers[accel_grp2_int_ctrl]);
+		if (err < 0)
+			return err;
+	}
+
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		err = i2c_smbus_write_byte_data(acceld->client,
+						ACCEL_GRP2_CTRL_REG1, acceld->accel_registers[accel_grp2_ctrl_reg1] | ACCEL_GRP2_PC1_ON);
+		if (err < 0)
+			return err;
+	}
+	else {
+		err = i2c_smbus_write_byte_data(acceld->client,
+						ACCEL_GRP2_CTRL_REG1, acceld->accel_registers[accel_grp2_ctrl_reg1]);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static void kionix_accel_grp2_update_g_range(struct kionix_accel_driver *acceld)
+{
+	acceld->accel_registers[accel_grp2_ctrl_reg1] &= ~ACCEL_GRP2_G_MASK;
+
+	switch (KIONIX_ACCEL_G_2G) {
+		case KIONIX_ACCEL_G_8G:
+		case KIONIX_ACCEL_G_6G:
+			acceld->shift = 2;
+			acceld->accel_registers[accel_grp2_ctrl_reg1] |= ACCEL_GRP2_G_8G;
+			break;
+		case KIONIX_ACCEL_G_4G:
+			acceld->shift = 3;
+			acceld->accel_registers[accel_grp2_ctrl_reg1] |= ACCEL_GRP2_G_4G;
+			break;
+		case KIONIX_ACCEL_G_2G:
+		default:
+			acceld->shift = 4;
+			acceld->accel_registers[accel_grp2_ctrl_reg1] |= ACCEL_GRP2_G_2G;
+			break;
+	}
+
+	return;
+}
+
+
+
+static int kionix_accel_grp2_operate(struct kionix_accel_driver *acceld)
+{
+	int err;
+
+	err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP2_CTRL_REG1, \
+			acceld->accel_registers[accel_grp2_ctrl_reg1] | ACCEL_GRP2_PC1_ON);
+	if (err < 0)
+		return err;
+
+	if(acceld->accel_drdy == 0 && acceld->accel_workqueue != NULL)
+		queue_delayed_work(acceld->accel_workqueue, &acceld->accel_work, 0);
+
+	return 0;
+}
+
+static int kionix_accel_grp2_standby(struct kionix_accel_driver *acceld)
+{
+	int err;
+
+	if(acceld->accel_drdy == 0){
+
+		cancel_delayed_work_sync(&acceld->accel_work);
+	}
+
+	err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP2_CTRL_REG1, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+
+static void kionix_accel_grp2_report_accel_data(struct kionix_accel_driver *acceld)
+{
+	struct { union {
+		s16 accel_data_s16[3];
+		s8	accel_data_s8[6];
+	}; } accel_data;
+	s16 x, y, z;
+	int err;
+	struct input_dev *input_dev = acceld->input_dev;
+	int loop;
+
+	/* Only read the output registers if enabled */
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		if(atomic_read(&acceld->accel_enable_resume) > 0)
+		{
+			loop = KIONIX_I2C_RETRY_COUNT;
+			while(loop) {
+				mutex_lock(&input_dev->mutex);
+				err = kionix_i2c_read(acceld->client, ACCEL_GRP2_XOUT_L, (u8 *)accel_data.accel_data_s16, 6);
+				mutex_unlock(&input_dev->mutex);
+				if(err < 0){
+					loop--;
+					mdelay(KIONIX_I2C_RETRY_TIMEOUT);
+				}
+				else
+					loop = 0;
+			}
+			if (err < 0) {
+				KMSGERR(&acceld->client->dev, "%s: read data output error = %d\n", __func__, err);
+			}
+			else {
+				write_lock(&acceld->rwlock_accel_data);
+
+				x = ((s16) le16_to_cpu(accel_data.accel_data_s16[acceld->axis_map_x])) >> acceld->shift;
+				y = ((s16) le16_to_cpu(accel_data.accel_data_s16[acceld->axis_map_y])) >> acceld->shift;
+				z = ((s16) le16_to_cpu(accel_data.accel_data_s16[acceld->axis_map_z])) >> acceld->shift;
+
+				acceld->accel_data[acceld->axis_map_x] = (acceld->negate_x ? -x : x) + acceld->accel_cali[acceld->axis_map_x];
+				acceld->accel_data[acceld->axis_map_y] = (acceld->negate_y ? -y : y) + acceld->accel_cali[acceld->axis_map_y];
+				acceld->accel_data[acceld->axis_map_z] = (acceld->negate_z ? -z : z) + acceld->accel_cali[acceld->axis_map_z];
+
+				if(atomic_read(&acceld->accel_input_event) > 0) {
+					printk("pga x=%d\n",acceld->accel_data[acceld->axis_map_x]);
+					input_report_abs(acceld->input_dev, ABS_X, acceld->accel_data[acceld->axis_map_x]);
+					input_report_abs(acceld->input_dev, ABS_Y, acceld->accel_data[acceld->axis_map_y]);
+					input_report_abs(acceld->input_dev, ABS_Z, acceld->accel_data[acceld->axis_map_z]);
+					input_sync(acceld->input_dev);
+				}
+
+				write_unlock(&acceld->rwlock_accel_data);
+			}
+		}
+		else
+		{
+			atomic_inc(&acceld->accel_enable_resume);
+		}
+	}
+
+	/* Clear the interrupt if using drdy */
+	if(acceld->accel_drdy == 1) {
+		loop = KIONIX_I2C_RETRY_COUNT;
+		while(loop) {
+			err = i2c_smbus_read_byte_data(acceld->client, ACCEL_GRP2_INT_REL);
+			if(err < 0){
+				loop--;
+				mdelay(KIONIX_I2C_RETRY_TIMEOUT);
+			}
+			else
+				loop = 0;
+		}
+		if (err < 0)
+			KMSGERR(&acceld->client->dev, "%s: clear interrupt error = %d\n", __func__, err);
+	}
+}
+
+static int kionix_accel_grp2_update_odr(struct kionix_accel_driver *acceld, unsigned int poll_interval)
+{
+	int err;
+	int i;
+	u8 odr;
+
+	/* Use the lowest ODR that can support the requested poll interval */
+	for (i = 0; i < ARRAY_SIZE(kionix_accel_grp2_odr_table); i++) {
+		odr = kionix_accel_grp2_odr_table[i].mask;
+		if (poll_interval < kionix_accel_grp2_odr_table[i].cutoff)
+			break;
+	}
+
+	/* Do not need to update DATA_CTRL_REG register if the ODR is not changed */
+	if(acceld->accel_registers[accel_grp2_data_ctrl] == odr)
+		return 0;
+	else
+		acceld->accel_registers[accel_grp2_data_ctrl] = odr;
+
+	/* Do not need to update DATA_CTRL_REG register if the sensor is not currently turn on */
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP2_CTRL_REG1, 0);
+		if (err < 0)
+			return err;
+
+		err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP2_DATA_CTRL, acceld->accel_registers[accel_grp2_data_ctrl]);
+		if (err < 0)
+			return err;
+
+		err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP2_CTRL_REG1, acceld->accel_registers[accel_grp2_ctrl_reg1] | ACCEL_GRP2_PC1_ON);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+
+static int kionix_accel_grp4_power_on_init(struct kionix_accel_driver *acceld)
+{
+	int err;
+
+	/* ensure that PC1 is cleared before updating control registers */
+	err = i2c_smbus_write_byte_data(acceld->client,
+					ACCEL_GRP4_CTRL_REG1, 0);
+	if (err < 0)
+		return err;
+
+	err = i2c_smbus_write_byte_data(acceld->client,
+					ACCEL_GRP4_DATA_CTRL, acceld->accel_registers[accel_grp4_data_ctrl]);
+	if (err < 0)
+		return err;
+
+	/* only write INT_CTRL_REG1 if in irq mode */
+	if (acceld->client->irq) {
+		err = i2c_smbus_write_byte_data(acceld->client,
+						ACCEL_GRP4_INT_CTRL1, acceld->accel_registers[accel_grp4_int_ctrl]);
+		if (err < 0)
+			return err;
+	}
+
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		err = i2c_smbus_write_byte_data(acceld->client,
+						ACCEL_GRP4_CTRL_REG1, acceld->accel_registers[accel_grp4_ctrl_reg1] | ACCEL_GRP4_PC1_ON);
+		if (err < 0)
+			return err;
+	}
+	else {
+		err = i2c_smbus_write_byte_data(acceld->client,
+						ACCEL_GRP4_CTRL_REG1, acceld->accel_registers[accel_grp4_ctrl_reg1]);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int kionix_accel_grp4_operate(struct kionix_accel_driver *acceld)
+{
+	int err;
+
+	err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP4_CTRL_REG1, \
+			acceld->accel_registers[accel_grp4_ctrl_reg1] | ACCEL_GRP4_PC1_ON);
+	if (err < 0)
+		return err;
+
+
+
+	return 0;
+}
+
+static int kionix_accel_grp4_standby(struct kionix_accel_driver *acceld)
+{
+	int err;
+
+
+
+	err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP4_CTRL_REG1, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static void kionix_accel_grp4_report_accel_data(struct kionix_accel_driver *acceld)
+{
+	struct { union {
+		s16 accel_data_s16[3];
+		s8	accel_data_s8[6];
+	}; } accel_data;
+	s16 x, y, z;
+	int err;
+	struct input_dev *input_dev = acceld->input_dev;
+	int loop;
+
+	/* Only read the output registers if enabled */
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		//if(atomic_read(&acceld->accel_enable_resume) > 0)
+		//{
+			loop = KIONIX_I2C_RETRY_COUNT;
+			while(loop) {
+				mutex_lock(&input_dev->mutex);
+				err = kionix_i2c_read(acceld->client, ACCEL_GRP4_XOUT_L, (u8 *)accel_data.accel_data_s16, 6);
+				mutex_unlock(&input_dev->mutex);
+				if(err < 0){
+					loop--;
+					mdelay(KIONIX_I2C_RETRY_TIMEOUT);
+				}
+				else
+					loop = 0;
+			}
+			
+			if (err < 0) {
+				KMSGERR(&acceld->client->dev, "%s: read data output error = %d\n", __func__, err);
+			}
+			else {
+				//write_lock(&acceld->rwlock_accel_data);
+
+				x = ((s16) le16_to_cpu(accel_data.accel_data_s16[acceld->axis_map_x])) >> acceld->shift;
+				y = ((s16) le16_to_cpu(accel_data.accel_data_s16[acceld->axis_map_y])) >> acceld->shift;
+				z = ((s16) le16_to_cpu(accel_data.accel_data_s16[acceld->axis_map_z])) >> acceld->shift;
+
+				acceld->accel_data[acceld->axis_map_x] = (acceld->negate_x ? -x : x) - acceld->offset.x;
+				acceld->accel_data[acceld->axis_map_y] = (acceld->negate_y ? -y : y) + acceld->offset.y;
+				acceld->accel_data[acceld->axis_map_z] = (acceld->negate_z ? -z : z) + acceld->offset.z;
+
+				if(atomic_read(&acceld->accel_input_event) > 0) {
+					input_report_abs(acceld->input_dev, ABS_X, acceld->accel_data[acceld->axis_map_x]);
+					input_report_abs(acceld->input_dev, ABS_Y, acceld->accel_data[acceld->axis_map_y]);
+					input_report_abs(acceld->input_dev, ABS_Z, acceld->accel_data[acceld->axis_map_z]);
+					input_sync(acceld->input_dev);
+				}
+
+				//write_unlock(&acceld->rwlock_accel_data);
+			}
+		//}
+	//	else
+		//{
+	//		atomic_inc(&acceld->accel_enable_resume);
+	//	}
+	}
+
+	/* Clear the interrupt if using drdy */
+	if(acceld->accel_drdy == 1) {
+		loop = KIONIX_I2C_RETRY_COUNT;
+		while(loop) {
+			err = i2c_smbus_read_byte_data(acceld->client, ACCEL_GRP4_INT_REL);
+			if(err < 0){
+				loop--;
+				mdelay(KIONIX_I2C_RETRY_TIMEOUT);
+			}
+			else
+				loop = 0;
+		}
+		if (err < 0)
+			KMSGERR(&acceld->client->dev, "%s: clear interrupt error = %d\n", __func__, err);
+	}
+}
+
+
+
+
+static void kionix_accel_grp4_update_g_range(struct kionix_accel_driver *acceld)
+{
+	acceld->accel_registers[accel_grp4_ctrl_reg1] &= ~ACCEL_GRP4_G_MASK;
+
+	switch (KIONIX_ACCEL_G_2G) {
+		case KIONIX_ACCEL_G_8G:
+		case KIONIX_ACCEL_G_6G:
+			acceld->shift = 2;
+			acceld->accel_registers[accel_grp4_ctrl_reg1] |= ACCEL_GRP4_G_8G;
+			break;
+		case KIONIX_ACCEL_G_4G:
+			acceld->shift = 3;
+			acceld->accel_registers[accel_grp4_ctrl_reg1] |= ACCEL_GRP4_G_4G;
+			break;
+		case KIONIX_ACCEL_G_2G:
+		default:
+			acceld->shift = 4;
+			acceld->accel_registers[accel_grp4_ctrl_reg1] |= ACCEL_GRP4_G_2G;
+			break;
+	}
+
+	return;
+}
+
+static int kionix_accel_grp4_update_odr(struct kionix_accel_driver *acceld, unsigned int poll_interval)
+{
+	int err;
+	int i;
+	u8 odr;
+
+	/* Use the lowest ODR that can support the requested poll interval */
+	for (i = 0; i < ARRAY_SIZE(kionix_accel_grp4_odr_table); i++) {
+		odr = kionix_accel_grp4_odr_table[i].mask;
+		if (poll_interval < kionix_accel_grp4_odr_table[i].cutoff)
+			break;
+	}
+
+	/* Do not need to update DATA_CTRL_REG register if the ODR is not changed */
+	if(acceld->accel_registers[accel_grp4_data_ctrl] == odr)
+		return 0;
+	else
+		acceld->accel_registers[accel_grp4_data_ctrl] = odr;
+
+	/* Do not need to update DATA_CTRL_REG register if the sensor is not currently turn on */
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP4_CTRL_REG1, 0);
+		if (err < 0)
+			return err;
+
+		err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP4_DATA_CTRL, acceld->accel_registers[accel_grp4_data_ctrl]);
+		if (err < 0)
+			return err;
+
+		err = i2c_smbus_write_byte_data(acceld->client, ACCEL_GRP4_CTRL_REG1, acceld->accel_registers[accel_grp4_ctrl_reg1] | ACCEL_GRP4_PC1_ON);
+		if (err < 0)
+			return err;
+		//#############
+		err = i2c_smbus_read_byte_data(acceld->client, ACCEL_GRP4_DATA_CTRL);
+		if (err < 0)
+			return err;
+		switch(err) {
+			case ACCEL_GRP4_ODR0_781:
+				dev_info(&acceld->client->dev, "ODR = 0.781 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR1_563:
+				dev_info(&acceld->client->dev, "ODR = 1.563 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR3_125:
+				dev_info(&acceld->client->dev, "ODR = 3.125 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR6_25:
+				dev_info(&acceld->client->dev, "ODR = 6.25 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR12_5:
+				dev_info(&acceld->client->dev, "ODR = 12.5 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR25:
+				dev_info(&acceld->client->dev, "ODR = 25 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR50:
+				dev_info(&acceld->client->dev, "ODR = 50 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR100:
+				dev_info(&acceld->client->dev, "ODR = 100 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR200:
+				dev_info(&acceld->client->dev, "ODR = 200 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR400:
+				dev_info(&acceld->client->dev, "ODR = 400 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR800:
+				dev_info(&acceld->client->dev, "ODR = 800 Hz\n");
+				break;
+			case ACCEL_GRP4_ODR1600:
+				dev_info(&acceld->client->dev, "ODR = 1600 Hz\n");
+				break;
+			default:
+				dev_info(&acceld->client->dev, "Unknown ODR\n");
+				break;
+		}
+		//#############
+	}
+
+	return 0;
+}
+
+static int kionix_accel_power_on(struct kionix_accel_driver *acceld)
+{
+	return 0;
+}
+
+static void kionix_accel_power_off(struct kionix_accel_driver *acceld)
+{
+	return ;
+}
+
+static irqreturn_t kionix_accel_isr(int irq, void *dev)
+{
+	struct kionix_accel_driver *acceld = dev;
+
+	if(acceld->accel_workqueue != NULL)
+		queue_delayed_work(acceld->accel_workqueue, &acceld->accel_work, 0);
+
+	return IRQ_HANDLED;
+}
+
+static void kionix_accel_work(struct work_struct *work)
+{
+	struct kionix_accel_driver *acceld = container_of((struct delayed_work *)work,	struct kionix_accel_driver, accel_work);
+	kionix_load_user_calibration(acceld->client);
+	//printk("kionix_accel_work \n");
+
+	if(acceld->accel_drdy == 0 && acceld->accel_workqueue != NULL)
+		queue_delayed_work(acceld->accel_workqueue, &acceld->accel_work, acceld->poll_delay);
+
+	acceld->kionix_accel_report_accel_data(acceld);
+}
+
+static void kionix_accel_update_direction(struct kionix_accel_driver *acceld)
+{
+	unsigned int direction;
+	unsigned int accel_group = acceld->accel_group;
+	direction = atomic_read(&acceld->position);
+	//write_lock(&acceld->rwlock_accel_data);
+	acceld->axis_map_x = ((direction-1)%2);
+	acceld->axis_map_y =  (direction%2);
+	acceld->axis_map_z =  2;
+	acceld->negate_z = ((direction-1)/4);
+	switch(accel_group) {
+		case KIONIX_ACCEL_GRP3:
+		case KIONIX_ACCEL_GRP6:
+			acceld->negate_x = (((direction+2)/2)%2);
+			acceld->negate_y = (((direction+5)/4)%2);
+			break;
+		case KIONIX_ACCEL_GRP5:
+			acceld->axis_map_x =  (direction%2);
+			acceld->axis_map_y = ((direction-1)%2);
+			acceld->negate_x =  (((direction+1)/2)%2);
+			acceld->negate_y =  (((direction/2)+((direction-1)/4))%2);
+			break;
+		default:
+			acceld->negate_x =  ((direction/2)%2);
+			acceld->negate_y = (((direction+1)/4)%2);
+			break;
+	}
+	//write_unlock(&acceld->rwlock_accel_data);
+	return;
+}
+
+static int kionix_accel_enable(struct kionix_accel_driver *acceld)
+{
+	int err = 0;
+	//mutex_lock(&acceld->mutex_earlysuspend);
+
+	//atomic_set(&acceld->accel_suspend_continue, 0);
+
+	/* Make sure that the sensor had successfully resumed before enabling it */
+	/*
+	if(atomic_read(&acceld->accel_suspended) == 1) {
+		KMSGINF(&acceld->client->dev, "%s: waiting for resume\n", __func__);
+		remaining = wait_event_interruptible_timeout(acceld->wqh_suspend, \
+				atomic_read(&acceld->accel_suspended) == 0, \
+				msecs_to_jiffies(KIONIX_ACCEL_EARLYSUSPEND_TIMEOUT));
+
+		if(atomic_read(&acceld->accel_suspended) == 1) {
+			KMSGERR(&acceld->client->dev, "%s: timeout waiting for resume\n", __func__);
+			err = -ETIME;
+			goto exit;
+		}
+	}*/
+	printk("kionix_accel_enable \n");
+	if(atomic_read(&acceld->accel_enabled) == 0) 
+	{
+		err = acceld->kionix_accel_operate(acceld);
+		if (err < 0) {
+			KMSGERR(&acceld->client->dev, \
+					"%s: kionix_accel_operate returned err = %d\n", __func__, err);
+			goto exit;
+		}
+
+		atomic_set(&acceld->accel_enabled,1);
+	}
+
+exit:
+	//mutex_unlock(&acceld->mutex_earlysuspend);
+
+	return err;
+}
+
+static int kionix_accel_disable(struct kionix_accel_driver *acceld)
+{
+	int err = 0;
+	printk("kionix_accel_disable \n");
+	
+	if(atomic_read(&acceld->accel_enabled) == 1) 
+	{
+		err = acceld->kionix_accel_standby(acceld);
+		if (err < 0) {
+			KMSGERR(&acceld->client->dev, \
+					"%s: kionix_accel_standby returned err = %d\n", __func__, err);
+//			goto exit;
+		}
+
+		atomic_set(&acceld->accel_enabled,0);
+	}
+
+	return err;
+}
+
+static int kionix_accel_input_open(struct input_dev *input)
+{
+	struct kionix_accel_driver *acceld = input_get_drvdata(input);
+
+	atomic_inc(&acceld->accel_input_event);
+
+	return 0;
+}
+
+static void kionix_accel_input_close(struct input_dev *dev)
+{
+	struct kionix_accel_driver *acceld = input_get_drvdata(dev);
+
+	atomic_dec(&acceld->accel_input_event);
+}
+
+static void kionix_accel_init_input_device(struct kionix_accel_driver *acceld,
+					      struct input_dev *input_dev)
+{
+	__set_bit(EV_ABS, input_dev->evbit);
+	input_set_abs_params(input_dev, ABS_X, -ACCEL_G_MAX, ACCEL_G_MAX, ACCEL_FUZZ, ACCEL_FLAT);
+	input_set_abs_params(input_dev, ABS_Y, -ACCEL_G_MAX, ACCEL_G_MAX, ACCEL_FUZZ, ACCEL_FLAT);
+	input_set_abs_params(input_dev, ABS_Z, -ACCEL_G_MAX, ACCEL_G_MAX, ACCEL_FUZZ, ACCEL_FLAT);
+
+	input_dev->name = KIONIX_ACCEL_NAME;
+	input_dev->id.bustype = BUS_I2C;
+	//input_dev->dev.parent = &acceld->client->dev;
+	//acceld->input_dev = input_dev;
+}
+
+static int kionix_accel_setup_input_device(struct kionix_accel_driver *acceld)
+{
+	struct input_dev *input_dev;
+	int err;
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		KMSGERR(&acceld->client->dev, "input_allocate_device failed\n");
+		return -ENOMEM;
+	}
+
+	acceld->input_dev = input_dev;
+
+	input_dev->open = kionix_accel_input_open;
+	input_dev->close = kionix_accel_input_close;
+	input_set_drvdata(input_dev, acceld);
+
+	kionix_accel_init_input_device(acceld, input_dev);
+
+	err = input_register_device(acceld->input_dev);
+	if (err) {
+		KMSGERR(&acceld->client->dev, \
+				"%s: input_register_device returned err = %d\n", __func__, err);
+		input_free_device(acceld->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+/* Returns the enable state of device */
+static ssize_t kionix_accel_get_enable(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d\n", atomic_read(&acceld->accel_enabled) > 0 ? 1 : 0);
+}
+
+
+static ssize_t kionix_accel_do_enable(struct kionix_accel_driver *acceld,int enable )
+{
+	int err = 0;
+	struct input_dev *input_dev = acceld->input_dev;
+	
+	printk("kionix_accel_do_enable %d \n",enable);
+	
+      mutex_lock(&input_dev->mutex);
+
+	if(enable){
+		err = kionix_accel_enable(acceld);
+		if(acceld->accel_drdy == 0 && acceld->accel_workqueue != NULL)
+			queue_delayed_work(acceld->accel_workqueue, &acceld->accel_work, 0);
+	}
+	else
+	{
+		if(acceld->accel_drdy == 0 && acceld->accel_workqueue != NULL){
+			//flush_workqueue(acceld->accel_workqueue);
+			cancel_delayed_work_sync(&acceld->accel_work);
+		}
+		err = kionix_accel_disable(acceld);
+	}
+      mutex_unlock(&input_dev->mutex);
+	return err;
+}
+
+/* Allow users to enable/disable the device */
+static ssize_t kionix_accel_set_enable(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+	struct input_dev *input_dev = NULL;
+	char *buf2;
+	const int enable_count = 1;
+	unsigned long enable;
+	int err = 0;
+	
+	//printk("kionix_accel_set_enable \n");
+	input_dev = acceld->input_dev;
+	/* Lock the device to prevent races with open/close (and itself) */
+	//mutex_lock(&input_dev->mutex);
+
+	if(kionix_strtok(buf, count, &buf2, enable_count) < 0) {
+		KMSGERR(&acceld->client->dev, \
+				"%s: No enable data being read. " \
+				"No enable data will be updated.\n", __func__);
+	}
+
+	else {
+		/* Removes any leading negative sign */
+		while(*buf2 == '-')
+			buf2++;
+		#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
+		err = kstrtouint((const char *)buf2, 10, (unsigned int *)&enable);
+		if (err < 0) {
+			KMSGERR(&acceld->client->dev, \
+					"%s: kstrtouint returned err = %d\n", __func__, err);
+			goto exit;
+		}
+		#else
+		err = strict_strtoul((const char *)buf2, 10, &enable);
+		if (err < 0) {
+			KMSGERR(&acceld->client->dev, \
+					"%s: strict_strtoul returned err = %d\n", __func__, err);
+			goto exit;
+		}
+		#endif
+
+		kionix_accel_do_enable(acceld,enable);
+
+	}
+
+exit:
+	//mutex_unlock(&input_dev->mutex);
+
+	return (err < 0) ? err : count;
+}
+
+
+
+
+/* Returns currently selected poll interval (in ms) */
+static ssize_t kionix_accel_get_delay(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%d\n", acceld->poll_interval);
+}
+
+/* Allow users to select a new poll interval (in ms) */
+static ssize_t kionix_accel_set_delay(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+	struct input_dev *input_dev = acceld->input_dev;
+	char *buf2;
+	const int delay_count = 1;
+	unsigned long interval;
+	int err = 0;
+
+	/* Lock the device to prevent races with open/close (and itself) */
+	mutex_lock(&input_dev->mutex);
+
+	if(kionix_strtok(buf, count, &buf2, delay_count) < 0) {
+		KMSGERR(&acceld->client->dev, \
+				"%s: No delay data being read. " \
+				"No delay data will be updated.\n", __func__);
+	}
+
+	else {
+		/* Removes any leading negative sign */
+		while(*buf2 == '-')
+			buf2++;
+		#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
+		err = kstrtouint((const char *)buf2, 10, (unsigned int *)&interval);
+		if (err < 0) {
+			KMSGERR(&acceld->client->dev, \
+					"%s: kstrtouint returned err = %d\n", __func__, err);
+			goto exit;
+		}
+		#else
+		err = strict_strtoul((const char *)buf2, 10, &interval);
+		if (err < 0) {
+			KMSGERR(&acceld->client->dev, \
+					"%s: strict_strtoul returned err = %d\n", __func__, err);
+			goto exit;
+		}
+		#endif
+
+		if(acceld->accel_drdy == 1)
+			disable_irq(client->irq);
+
+		/*
+		 * Set current interval to the greater of the minimum interval or
+		 * the requested interval
+		 */
+		acceld->poll_interval = (unsigned int)interval;
+		acceld->poll_delay = msecs_to_jiffies(acceld->poll_interval);
+
+		err = acceld->kionix_accel_update_odr(acceld, acceld->poll_interval);
+
+		if(acceld->accel_drdy == 1)
+			enable_irq(client->irq);
+	}
+
+exit:
+	mutex_unlock(&input_dev->mutex);
+
+	return (err < 0) ? err : count;
+}
+
+/* Returns the direction of device */
+static ssize_t kionix_accel_get_direct(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+	int data;
+	int tmp;
+	data = atomic_read(&(acceld->position));
+	tmp =data;
+	// printk("pga read before direction=%d",tmp);
+	if (data >4){
+		data = 4-tmp;
+		}
+	// printk("pga read direction=%d",data);
+	return sprintf(buf, "%d\n", data);
+}
+
+/* Allow users to change the direction the device */
+static ssize_t kionix_accel_set_direct(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+	struct input_dev *input_dev = acceld->input_dev;
+	char *buf2;
+	const int direct_count = 1;
+	 long direction;
+	int err = 0;
+
+	/* Lock the device to prevent races with open/close (and itself) */
+	mutex_lock(&input_dev->mutex);
+
+	if(kionix_strtok(buf, count, &buf2, direct_count) < 0) {
+		KMSGERR(&acceld->client->dev, \
+				"%s: No direction data being read. " \
+				"No direction data will be updated.\n", __func__);
+	}
+
+	else {
+		/* Removes any leading negative sign */
+		//while(*buf2 == '-')
+		//	buf2++;
+		#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
+		err = kstrtoint((const char *)buf2, 10, ( int *)&direction);
+		if (err < 0) {
+			KMSGERR(&acceld->client->dev, \
+					"%s: kstrtouint returned err = %d\n", __func__, err);
+			goto exit;
+		}
+		#else
+		err = strict_strtoul((const char *)buf2, 10, &direction);
+		if (err < 0) {
+			KMSGERR(&acceld->client->dev, \
+					"%s: strict_strtoul returned err = %d\n", __func__, err);
+			goto exit;
+		}
+		#endif
+        
+		if (direction < 0) { 
+			direction = 4-direction;
+			}
+
+		if(direction < 1 || direction > 8)
+			KMSGERR(&acceld->client->dev, "%s: invalid direction = %d\n", __func__, (unsigned int) direction);
+
+		else {
+			
+			atomic_set(&(acceld->position), (int) direction);
+			kionix_accel_update_direction(acceld);
+		}
+	}
+
+exit:
+	mutex_unlock(&input_dev->mutex);
+
+	return (err < 0) ? err : count;
+}
+
+/* Returns the data output of device */
+static ssize_t kionix_accel_get_data(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+	int x, y, z;
+
+	//read_lock(&acceld->rwlock_accel_data);
+
+	x = acceld->accel_data[acceld->axis_map_x];
+	y = acceld->accel_data[acceld->axis_map_y];
+	z = acceld->accel_data[acceld->axis_map_z];
+
+	//read_unlock(&acceld->rwlock_accel_data);
+
+	return sprintf(buf, "%d %d %d\n", x, y, z);
+}
+
+/* Returns the calibration value of the device */
+static ssize_t kionix_accel_get_cali(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+	int calibration[3];
+
+	//read_lock(&acceld->rwlock_accel_data);
+
+	calibration[0] = acceld->accel_cali[acceld->axis_map_x];
+	calibration[1] = acceld->accel_cali[acceld->axis_map_y];
+	calibration[2] = acceld->accel_cali[acceld->axis_map_z];
+
+	//read_unlock(&acceld->rwlock_accel_data);
+
+	return sprintf(buf, "%d %d %d\n", calibration[0], calibration[1], calibration[2]);
+}
+
+/* Allow users to change the calibration value of the device */
+static ssize_t kionix_accel_set_cali(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+	struct input_dev *input_dev = acceld->input_dev;
+	const int cali_count = 3; /* How many calibration that we expect to get from the string */
+	char **buf2;
+	long calibration[cali_count];
+	int err = 0, i = 0;
+
+	/* Lock the device to prevent races with open/close (and itself) */
+	mutex_lock(&input_dev->mutex);
+
+	buf2 = (char **)kzalloc(cali_count * sizeof(char *), GFP_KERNEL);
+
+	if(kionix_strtok(buf, count, buf2, cali_count) < 0) {
+		KMSGERR(&acceld->client->dev, \
+				"%s: Not enough calibration data being read. " \
+				"No calibration data will be updated.\n", __func__);
+	}
+	else {
+		/* Convert string to integers  */
+		for(i = 0 ; i < cali_count ; i++) {
+			#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
+			err = kstrtoint((const char *)*(buf2+i), 10, (int *)&calibration[i]);
+			if(err < 0) {
+				KMSGERR(&acceld->client->dev, \
+						"%s: kstrtoint returned err = %d." \
+						"No calibration data will be updated.\n", __func__ , err);
+				goto exit;
+			}
+			#else
+			err = strict_strtol((const char *)*(buf2+i), 10, &calibration[i]);
+			if(err < 0) {
+				KMSGERR(&acceld->client->dev, \
+						"%s: strict_strtol returned err = %d." \
+						"No calibration data will be updated.\n", __func__ , err);
+				goto exit;
+			}
+			#endif
+		}
+
+		//write_lock(&acceld->rwlock_accel_data);
+
+		acceld->accel_cali[acceld->axis_map_x] = (int)calibration[0];
+		acceld->accel_cali[acceld->axis_map_y] = (int)calibration[1];
+		acceld->accel_cali[acceld->axis_map_z] = (int)calibration[2];
+
+		//write_unlock(&acceld->rwlock_accel_data);
+	}
+
+exit:
+	for(i = 0 ; i < cali_count ; i++)
+		kfree(*(buf2+i));
+
+	kfree(buf2);
+
+	mutex_unlock(&input_dev->mutex);
+
+	return (err < 0) ? err : count;
+}
+
+static ssize_t kionix_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+   int cfg_calibration[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct kionix_accel_driver *acceld  = i2c_get_clientdata(client);
+
+ 	struct { union {
+		s16 accel_data_s16[3];
+		s8	accel_data_s8[6];
+	}; } accel_data;
+	s16 x=0, y=0, z=0;
+	int err;
+	struct input_dev *input_dev = acceld->input_dev;
+	int loop;
+
+	/* Only read the output registers if enabled */
+	if(atomic_read(&acceld->accel_enabled) > 0) {
+		//if(atomic_read(&acceld->accel_enable_resume) > 0)
+		{
+			loop = KIONIX_I2C_RETRY_COUNT;
+			while(loop) {
+				mutex_lock(&input_dev->mutex);
+				err = kionix_i2c_read(acceld->client, ACCEL_GRP4_XOUT_L, (u8 *)accel_data.accel_data_s16, 6);
+				mutex_unlock(&input_dev->mutex);
+				if(err < 0){
+					loop--;
+					mdelay(KIONIX_I2C_RETRY_TIMEOUT);
+				}
+				else
+					loop = 0;
+			}
+			if (err < 0) {
+				KMSGERR(&acceld->client->dev, "%s: read data output error = %d\n", __func__, err);
+			}
+			else {
+				//write_lock(&acceld->rwlock_accel_data);
+
+				x = ((s16) le16_to_cpu(accel_data.accel_data_s16[acceld->axis_map_x])) >> acceld->shift;
+				y = ((s16) le16_to_cpu(accel_data.accel_data_s16[acceld->axis_map_y])) >> acceld->shift;
+				z = ((s16) le16_to_cpu(accel_data.accel_data_s16[acceld->axis_map_z])) >> acceld->shift;
+				//write_unlock(&acceld->rwlock_accel_data);
+			}
+		}
+		//else
+		//{
+	//		atomic_inc(&acceld->accel_enable_resume);
+		//}
+	}
+	printk(KERN_INFO "read x y z:%d,%d, %d ,position=%d\n",x,y,z,atomic_read(&acceld->position));
+
+    acceld ->offset.x = 0 - x;
+    acceld ->offset.y = 0 - y;
+    if (atomic_read(&acceld->position) > 0) {
+        acceld->offset.z = LSG - z;
+    } else {
+        acceld->offset.z = (-LSG) - z;
+    }
+    
+    printk(KERN_INFO "fast calibration: %d %d %d\n", acceld->offset.x,
+                        acceld->offset.y, acceld->offset.z);
+    
+    cfg_calibration[0] = acceld->offset.x;
+    cfg_calibration[1] = acceld->offset.y;
+    cfg_calibration[2] = acceld->offset.z;
+
+    printk(KERN_INFO "run fast calibration finished\n");
+    return count;
+   
+}
+
+static ssize_t kionix_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    struct i2c_client *client = to_i2c_client(dev);
+     struct kionix_accel_driver *acceld  = i2c_get_clientdata(client);
+    
+    memset(&(acceld->offset), 0, sizeof(struct kionix_acc));
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+
+    printk(KERN_INFO "reset fast calibration finished\n");
+    return count;
+}
+
+static ssize_t kionix_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d %d %d\n", acceld->offset.x, 
+                                acceld->offset.y, acceld->offset.z);
+}
+
+static ssize_t kionix_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[3];
+    struct i2c_client *client = to_i2c_client(dev);
+     struct kionix_accel_driver *acceld  = i2c_get_clientdata(client);
+
+    sscanf(buf, "%d %d %d", &data[0], &data[1], &data[2]);
+    acceld->offset.x = (signed short) data[0];
+    acceld->offset.y = (signed short) data[1];
+    acceld->offset.z = (signed short) data[2];
+    
+    printk(KERN_INFO "set fast calibration finished\n");
+    return count;
+}
+
+
+
+
+
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH, 
+	kionix_accel_get_enable, kionix_accel_set_enable);
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH, 
+	kionix_accel_get_delay, kionix_accel_set_delay);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH, 
+	kionix_accel_get_direct, kionix_accel_set_direct);
+static DEVICE_ATTR(data, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+	kionix_accel_get_data, NULL);
+static DEVICE_ATTR(cali, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH, 
+	kionix_accel_get_cali, kionix_accel_set_cali);
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, kionix_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, kionix_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        kionix_calibration_value_show,
+        kionix_calibration_value_store);
+
+static struct attribute *kionix_accel_attributes[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_delay.attr,
+	&dev_attr_board_position.attr,
+	&dev_attr_data.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_calibration_run.attr,
+    &dev_attr_calibration_reset.attr,
+    &dev_attr_calibration_value.attr,
+	NULL
+};
+
+static struct attribute_group kionix_accel_attribute_group = {
+	.attrs = kionix_accel_attributes
+};
+
+static int kionix_verify(struct kionix_accel_driver *acceld)
+{
+	int retval = i2c_smbus_read_byte_data(acceld->client, ACCEL_WHO_AM_I);
+
+#if KIONIX_KMSG_INF
+	switch (retval) {
+		case KIONIX_ACCEL_WHO_AM_I_KXTE9:
+			KMSGINF(&acceld->client->dev, "this accelerometer is a KXTE9.\n");
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXTF9:
+			KMSGINF(&acceld->client->dev, "this accelerometer is a KXTF9.\n");
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXTI9_1001:
+			KMSGINF(&acceld->client->dev, "this accelerometer is a KXTI9-1001.\n");
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXTIK_1004:
+			KMSGINF(&acceld->client->dev, "this accelerometer is a KXTIK-1004.\n");
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXTJ9_1005:
+			KMSGINF(&acceld->client->dev, "this accelerometer is a KXTJ9-1005.\n");
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXTJ9_1007:
+			KMSGINF(&acceld->client->dev, "this accelerometer is a KXTJ9-1007.\n");
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXCJ9_1008:
+			KMSGINF(&acceld->client->dev, "this accelerometer is a KXCJ9-1008.\n");
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXTJ2_1009:
+			KMSGINF(&acceld->client->dev, "this accelerometer is a KXTJ2-1009.\n");
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXCJK_1013:
+			KMSGINF(&acceld->client->dev, "this accelerometer is a KXCJK-1013.\n");
+			break;
+		default:
+			break;
+	}
+#endif
+
+	return retval;
+}
+
+#ifdef    CONFIG_HAS_EARLYSUSPEND
+void kionix_accel_earlysuspend_suspend(struct early_suspend *h)
+{
+	struct kionix_accel_driver *acceld = container_of(h, struct kionix_accel_driver, early_suspend);
+
+	printk("kionix_accel_earlysuspend_suspend\n");
+	//if(acceld->accel_workqueue != NULL)
+	//	flush_workqueue(acceld->accel_workqueue);
+
+	kionix_accel_disable(acceld);
+
+	return;
+}
+
+void kionix_accel_earlysuspend_resume(struct early_suspend *h)
+{
+	struct kionix_accel_driver *acceld = container_of(h, struct kionix_accel_driver, early_suspend);
+	int err;
+
+	printk("kionix_accel_earlysuspend_resume\n");
+
+	err = acceld->kionix_accel_power_on_init(acceld);
+	if (err) {
+		KMSGERR(&acceld->client->dev, "%s: kionix_accel_power_on_init returned err = %d\n", __func__, err);
+		goto exit;
+	}
+	
+	kionix_accel_enable(acceld);
+
+exit:
+
+	return;
+}
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+static int kionix_accel_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	//const struct kionix_accel_platform_data *accel_pdata = client->dev.platform_data;
+	struct kionix_accel_driver *acceld;
+	//struct proc_dir_entry *proc_dir, *proc_entry;
+	int cfg_calibration[3];
+	int cfg_position;
+#if CFG_GSENSOR_USE_CONFIG > 0	
+  const char * buf;
+    long int temp;
+#endif
+    int err;
+
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE_DATA)) {
+		KMSGERR(&client->dev, "client is not i2c capable. Abort.\n");
+		return -ENXIO;
+	}
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+    err = of_property_read_string(client->dev.of_node, "position", &buf);
+    if (err != 0) {
+        printk(KERN_ERR"get position fail\n");
+    }
+    err = strict_strtol(buf, 10, &temp);  
+    cfg_position = (int)temp;
+#else
+    cfg_position = 0;
+#endif  
+
+
+	/*if (!accel_pdata) {
+		KMSGERR(&client->dev, "platform data is NULL. Abort.\n");
+		return -EINVAL;
+	}
+	*/
+	acceld = kzalloc(sizeof(*acceld), GFP_KERNEL);
+	if (acceld == NULL) {
+		KMSGERR(&client->dev, \
+			"failed to allocate memory for module data. Abort.\n");
+		return -ENOMEM;
+	}
+
+	acceld->client = client;
+	//acceld->accel_pdata = NULL;
+
+	i2c_set_clientdata(client, acceld);
+
+	err = kionix_accel_power_on(acceld);
+	if (err < 0)
+		goto err_free_mem;
+
+	err = kionix_verify(acceld);
+	if (err < 0) {
+		KMSGERR(&acceld->client->dev, "%s: kionix_verify returned err = %d. Abort.\n", __func__, err);
+		goto err_accel_pdata_exit;
+	}
+
+	/* Setup group specific configuration and function callback */
+	switch (err) {
+		case KIONIX_ACCEL_WHO_AM_I_KXTE9:
+			acceld->accel_group = KIONIX_ACCEL_GRP1;
+			acceld->accel_registers = kzalloc(sizeof(u8)*accel_grp1_regs_count, GFP_KERNEL);
+			if (acceld->accel_registers == NULL) {
+				KMSGERR(&client->dev, \
+					"failed to allocate memory for accel_registers. Abort.\n");
+				goto err_accel_pdata_exit;
+			}
+			acceld->accel_drdy = 0;
+			acceld->kionix_accel_report_accel_data	= kionix_accel_grp1_report_accel_data;
+			acceld->kionix_accel_update_odr			= kionix_accel_grp1_update_odr;
+			acceld->kionix_accel_power_on_init		= kionix_accel_grp1_power_on_init;
+			acceld->kionix_accel_operate			= kionix_accel_grp1_operate;
+			acceld->kionix_accel_standby			= kionix_accel_grp1_standby;
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXTF9:
+		case KIONIX_ACCEL_WHO_AM_I_KXTI9_1001:
+		case KIONIX_ACCEL_WHO_AM_I_KXTIK_1004:
+		case KIONIX_ACCEL_WHO_AM_I_KXTJ9_1005:
+			if(err == KIONIX_ACCEL_WHO_AM_I_KXTIK_1004)
+				acceld->accel_group = KIONIX_ACCEL_GRP3;
+			else
+				acceld->accel_group = KIONIX_ACCEL_GRP2;
+			acceld->accel_registers = kzalloc(sizeof(u8)*accel_grp2_regs_count, GFP_KERNEL);
+			if (acceld->accel_registers == NULL) {
+				KMSGERR(&client->dev, \
+					"failed to allocate memory for accel_registers. Abort.\n");
+				goto err_accel_pdata_exit;
+			}
+			switch(KIONIX_ACCEL_RES_12BIT) {
+				case KIONIX_ACCEL_RES_6BIT:
+				case KIONIX_ACCEL_RES_8BIT:
+					acceld->accel_registers[accel_grp2_ctrl_reg1] |= ACCEL_GRP2_RES_8BIT;
+					break;
+				case KIONIX_ACCEL_RES_12BIT:
+				default:
+					acceld->accel_registers[accel_grp2_ctrl_reg1] |= ACCEL_GRP2_RES_12BIT;
+					break;
+			}
+			if(client->irq) {
+				acceld->accel_registers[accel_grp2_int_ctrl] |= ACCEL_GRP2_IEN | ACCEL_GRP2_IEA;
+				acceld->accel_registers[accel_grp2_ctrl_reg1] |= ACCEL_GRP2_DRDYE;
+				acceld->accel_drdy = 1;
+			}
+			else
+				acceld->accel_drdy = 0;
+			kionix_accel_grp2_update_g_range(acceld);
+			acceld->kionix_accel_report_accel_data	= kionix_accel_grp2_report_accel_data;
+			acceld->kionix_accel_update_odr			= kionix_accel_grp2_update_odr;
+			acceld->kionix_accel_power_on_init		= kionix_accel_grp2_power_on_init;
+			acceld->kionix_accel_operate			= kionix_accel_grp2_operate;
+			acceld->kionix_accel_standby			= kionix_accel_grp2_standby;
+			break;
+		case KIONIX_ACCEL_WHO_AM_I_KXTJ9_1007:
+		case KIONIX_ACCEL_WHO_AM_I_KXCJ9_1008:
+		case KIONIX_ACCEL_WHO_AM_I_KXTJ2_1009:
+		case KIONIX_ACCEL_WHO_AM_I_KXCJK_1013:
+			if(err == KIONIX_ACCEL_WHO_AM_I_KXTJ2_1009)
+				acceld->accel_group = KIONIX_ACCEL_GRP5;
+			else if(err == KIONIX_ACCEL_WHO_AM_I_KXCJK_1013)
+				acceld->accel_group = KIONIX_ACCEL_GRP6;
+			else
+				acceld->accel_group = KIONIX_ACCEL_GRP4;
+			acceld->accel_registers = kzalloc(sizeof(u8)*accel_grp4_regs_count, GFP_KERNEL);
+			if (acceld->accel_registers == NULL) {
+				KMSGERR(&client->dev, \
+					"failed to allocate memory for accel_registers. Abort.\n");
+				goto err_accel_pdata_exit;
+			}
+			switch(KIONIX_ACCEL_RES_12BIT) {
+				case KIONIX_ACCEL_RES_6BIT:
+				case KIONIX_ACCEL_RES_8BIT:
+					acceld->accel_registers[accel_grp4_ctrl_reg1] |= ACCEL_GRP4_RES_8BIT;
+					break;
+				case KIONIX_ACCEL_RES_12BIT:
+				default:
+					acceld->accel_registers[accel_grp4_ctrl_reg1] |= ACCEL_GRP4_RES_12BIT;
+					break;
+			}
+			if(client->irq) {
+				acceld->accel_registers[accel_grp4_int_ctrl] |= ACCEL_GRP4_IEN | ACCEL_GRP4_IEA;
+				acceld->accel_registers[accel_grp4_ctrl_reg1] |= ACCEL_GRP4_DRDYE;
+				acceld->accel_drdy = 1;
+			}
+			else
+				acceld->accel_drdy = 0;
+			kionix_accel_grp4_update_g_range(acceld);
+			acceld->kionix_accel_report_accel_data	= kionix_accel_grp4_report_accel_data;
+			acceld->kionix_accel_update_odr			= kionix_accel_grp4_update_odr;
+			acceld->kionix_accel_power_on_init		= kionix_accel_grp4_power_on_init;
+			acceld->kionix_accel_operate			= kionix_accel_grp4_operate;
+			acceld->kionix_accel_standby			= kionix_accel_grp4_standby;
+			break;
+		default:
+			KMSGERR(&acceld->client->dev, \
+					"%s: unsupported device, who am i = %d. Abort.\n", __func__, err);
+			goto err_accel_pdata_exit;
+	}
+
+	err = kionix_accel_setup_input_device(acceld);
+	if (err)
+		goto err_free_accel_registers;
+
+	atomic_set(&acceld->accel_suspended, 0);
+	//atomic_set(&acceld->accel_suspend_continue, 1);
+	atomic_set(&acceld->accel_enabled, 0);
+	atomic_set(&acceld->accel_input_event, 0);
+	atomic_set(&acceld->accel_enable_resume, 0);
+	atomic_set(&(acceld->position), cfg_position);
+	//mutex_init(&acceld->mutex_earlysuspend);
+	//mutex_init(&acceld->mutex_resume);
+	//rwlock_init(&acceld->rwlock_accel_data);
+
+	acceld->poll_interval = 200;
+	acceld->poll_delay = msecs_to_jiffies(acceld->poll_interval);
+	acceld->kionix_accel_update_odr(acceld, acceld->poll_interval);
+	kionix_accel_update_direction(acceld);
+#if 0
+	proc_dir = proc_mkdir("sensors", NULL);
+	if (proc_dir == NULL)
+		KMSGERR(&client->dev, "failed to create /proc/sensors\n");
+	else {
+		proc_entry = create_proc_entry( "accelinfo", 0644, proc_dir);
+		if (proc_entry == NULL)
+			KMSGERR(&client->dev, "failed to create /proc/cpu/accelinfo\n");
+	}
+#endif
+	acceld->accel_workqueue = create_workqueue("Kionix Accel Workqueue");
+	INIT_DELAYED_WORK(&acceld->accel_work, kionix_accel_work);
+	init_waitqueue_head(&acceld->wqh_suspend);
+
+	if (acceld->accel_drdy) {
+		err = request_threaded_irq(client->irq, NULL, kionix_accel_isr, \
+					   IRQF_TRIGGER_RISING | IRQF_ONESHOT, \
+					   KIONIX_ACCEL_IRQ, acceld);
+		if (err) {
+			KMSGERR(&acceld->client->dev, "%s: request_threaded_irq returned err = %d\n", __func__, err);
+			KMSGERR(&acceld->client->dev, "%s: running in software polling mode instead\n", __func__);
+			acceld->accel_drdy = 0;
+		}
+		KMSGINF(&acceld->client->dev, "running in hardware interrupt mode\n");
+	} else {
+		KMSGINF(&acceld->client->dev, "running in software polling mode\n");
+	}
+
+	err = acceld->kionix_accel_power_on_init(acceld);
+	if (err) {
+		KMSGERR(&acceld->client->dev, "%s: kionix_accel_power_on_init returned err = %d. Abort.\n", __func__, err);
+		goto err_free_irq;
+	}
+	
+
+	err = sysfs_create_group(&acceld->input_dev->dev.kobj, &kionix_accel_attribute_group);
+	if (err) {
+		KMSGERR(&acceld->client->dev, "%s: sysfs_create_group returned err = %d. Abort.\n", __func__, err);
+		goto err_free_irq;
+	}
+
+#if  0 //def    CONFIG_HAS_EARLYSUSPEND
+	/* The higher the level, the earlier it resume, and the later it suspend */
+	acceld->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB + 50;
+	acceld->early_suspend.suspend = kionix_accel_earlysuspend_suspend;
+	acceld->early_suspend.resume = kionix_accel_earlysuspend_resume;
+	register_early_suspend(&acceld->early_suspend);
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+	
+#if CFG_GSENSOR_USE_CONFIG > 0
+        //get dts configures
+        err = of_property_read_u32_array(client->dev.of_node, "calibration_table", cfg_calibration, 3);
+        if (err != 0) {
+            printk(KERN_ERR"get calibration fail\n");
+            memset(cfg_calibration, 0, sizeof(cfg_calibration));
+        }
+#else
+		memset(cfg_calibration, 0, sizeof(cfg_calibration));
+#endif    
+		
+		acceld->offset.x = (signed short) cfg_calibration[0];
+		acceld->offset.y = (signed short) cfg_calibration[1];
+		acceld->offset.z = (signed short) cfg_calibration[2];
+
+
+
+
+
+	return 0;
+//kfree_exit:
+    kfree(acceld);
+//error_sysfs:
+		input_unregister_device(acceld->input_dev);
+
+err_free_irq:
+	if (acceld->accel_drdy)
+		free_irq(client->irq, acceld);
+	
+	if(acceld->accel_workqueue != NULL)
+		destroy_workqueue(acceld->accel_workqueue);
+	input_unregister_device(acceld->input_dev);
+err_free_accel_registers:
+	kfree(acceld->accel_registers);
+err_accel_pdata_exit:
+	kionix_accel_power_off(acceld);
+err_free_mem:
+	kfree(acceld);
+	return err;
+}
+
+static int kionix_accel_remove(struct i2c_client *client)
+{
+	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+
+#ifdef    CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&acceld->early_suspend);
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+	sysfs_remove_group(&client->dev.kobj, &kionix_accel_attribute_group);
+	if (acceld->accel_drdy)
+		free_irq(client->irq, acceld);
+	
+	if(acceld->accel_workqueue != NULL)
+		destroy_workqueue(acceld->accel_workqueue);
+	input_unregister_device(acceld->input_dev);
+	kfree(acceld->accel_registers);
+	kionix_accel_power_off(acceld);
+	kfree(acceld);
+	printk("HOLYTU KIONIX kionix_accel_remove\n");
+
+	return 0;
+}
+
+#if 0
+static int kionix_accel_shutdown(struct i2c_client *client)
+{
+	
+	printk("HOLYTU KIONIX kionix_accel_shutdown\n");
+	return 0;
+}
+#endif
+
+static int kionix_suspend(struct device *dev)
+{
+    	struct i2c_client *client = to_i2c_client(dev);
+    	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+
+	//struct kionix_accel_driver *acceld = container_of(dev, struct kionix_accel_driver, device);
+
+	printk("kionix_accel_earlysuspend_suspend\n");
+
+	//if(acceld->accel_workqueue != NULL)
+	//	flush_workqueue(acceld->accel_workqueue);
+	kionix_accel_do_enable(acceld,0);
+	//kionix_accel_disable(acceld);
+
+	return 0;
+}
+
+static int kionix_resume(struct device *dev)
+{
+	//struct kionix_accel_driver *acceld = container_of(dev, struct kionix_accel_driver, device);
+    	struct i2c_client *client = to_i2c_client(dev);
+    	struct kionix_accel_driver *acceld = i2c_get_clientdata(client);
+
+	printk("kionix_accel_earlysuspend_suspend\n");
+	//if(acceld->accel_workqueue != NULL)
+	//	flush_workqueue(acceld->accel_workqueue);
+	kionix_accel_do_enable(acceld,1);
+
+	//kionix_accel_disable(acceld);
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, kionix_accel_id);
+static SIMPLE_DEV_PM_OPS(kionix_pm_ops, kionix_suspend, kionix_resume);
+
+static struct of_device_id kionix_of_match[] = {
+	{ .compatible = "kionix", },
+	{ }
+};
+
+static const struct i2c_device_id kionix_accel_id[] = {
+	{ KIONIX_ACCEL_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver kionix_accel_driver = {
+	.driver = {
+		.name	= KIONIX_ACCEL_NAME,
+		.owner	= THIS_MODULE,
+		.pm    = &kionix_pm_ops,
+		.of_match_table	= of_match_ptr(kionix_of_match),
+	},
+	.id_table	= kionix_accel_id,
+	.probe		= kionix_accel_probe,
+	.remove		= kionix_accel_remove,
+	//.shutdown   = kionix_accel_shutdown,
+};
+
+void (*shutdown)(struct i2c_client *);
+#if 0
+static struct i2c_board_info kionix_board_info={
+    .type = KIONIX_ACCEL_NAME, 
+    .addr = KIONIX_ACCEL_I2C_ADDR,
+};
+static struct i2c_client *kionix_client;
+#endif
+static int __init kionix_accel_init(void)
+{	 
+    #if 0
+	struct i2c_adapter *i2c_adap;
+    unsigned int cfg_i2c_adap_id;
+    cfg_i2c_adap_id = 2;
+    i2c_adap = i2c_get_adapter(cfg_i2c_adap_id);  
+    kionix_client = i2c_new_device(i2c_adap, &kionix_board_info);  
+    i2c_put_adapter(i2c_adap);
+    #endif
+    
+	printk("HOLYTU KIONIX kionix_accel_init\n");
+	return i2c_add_driver(&kionix_accel_driver);
+}
+module_init(kionix_accel_init);
+
+static void __exit kionix_accel_exit(void)
+{
+
+	printk("HOLYTU KIONIX kionix_accel_exit\n");
+
+	i2c_del_driver(&kionix_accel_driver);
+}
+module_exit(kionix_accel_exit);
+
+MODULE_DESCRIPTION("Kionix accelerometer driver");
+MODULE_AUTHOR("Kuching Tan <kuchingtan@kionix.com>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("3.3.0");
diff --git a/drivers/input/misc/gsensor/kionix/kionix_accel.h b/drivers/input/misc/gsensor/kionix/kionix_accel.h
new file mode 100755
index 0000000..4b498d9
--- /dev/null
+++ b/drivers/input/misc/gsensor/kionix/kionix_accel.h
@@ -0,0 +1,34 @@
+/* include/linux/input/kionix_accel.h - Kionix accelerometer driver
+ *
+ * Copyright (C) 2012 Kionix, Inc.
+ * Written by Kuching Tan <kuchingtan@kionix.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __KIONIX_ACCEL_H__
+#define __KIONIX_ACCEL_H__
+
+#define KIONIX_ACCEL_I2C_ADDR		0x0E
+#define KIONIX_ACCEL_NAME			"kionix_accel"
+#define KIONIX_ACCEL_IRQ			"kionix-irq"
+#define KIONIX_ACCEL_RES_12BIT	0
+#define KIONIX_ACCEL_RES_8BIT	1
+#define KIONIX_ACCEL_RES_6BIT	2
+#define KIONIX_ACCEL_G_2G		0
+#define KIONIX_ACCEL_G_4G		1
+#define KIONIX_ACCEL_G_6G		2
+#define KIONIX_ACCEL_G_8G		3
+#endif  /* __KIONIX_ACCEL_H__ */
diff --git a/drivers/input/misc/gsensor/mc3230.c b/drivers/input/misc/gsensor/mc3230.c
new file mode 100755
index 0000000..7657ad3
--- /dev/null
+++ b/drivers/input/misc/gsensor/mc3230.c
@@ -0,0 +1,1730 @@
+/*
+ * Copyright (C) 2011 MCUBE, Inc.
+ *
+ * Initial Code:
+ *    Tan Liang
+ */
+
+
+/*! \file mc32x0_driver.c
+    \brief This file contains all function implementations for the mc32x0 in linux
+    
+    Details.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <asm/uaccess.h>
+#include <linux/unistd.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/input-polldev.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+/* ----------------------------------------------------------------------------------------------------*/
+
+#define MC32X0_WR_FUNC_PTR char (* bus_write)(unsigned char, unsigned char *, unsigned char)
+
+#define MC32X0_BUS_WRITE_FUNC(dev_addr, reg_addr, reg_data, wr_len)\
+           bus_write(reg_addr, reg_data, wr_len)
+
+#define MC32X0_RD_FUNC_PTR char (* bus_read)( unsigned char, unsigned char *, unsigned char)
+
+#define MC32X0_BUS_READ_FUNC(dev_addr, reg_addr, reg_data, r_len)\
+           bus_read(reg_addr, reg_data, r_len)
+
+#define GET_REAL_VALUE(rv, bn) \
+    ((rv & (0x01 << (bn - 1))) ? (- (rv & ~(0xffff << (bn - 1)))) : (rv & ~(0xffff << (bn - 1))))
+
+
+
+//#define MC32X0_HIGH_END
+/*******MC3210/20 define this**********/
+
+//#define MCUBE_2G_10BIT_TAP
+//#define MCUBE_2G_10BIT
+//#define MCUBE_8G_14BIT_TAP
+//#define MCUBE_8G_14BIT
+#define MC32X0_LOW_END
+/*******MC3230 define this**********/
+
+#define MCUBE_1_5G_8BIT
+//#define MCUBE_1_5G_8BIT_TAP
+
+#define SENSOR_NAME "mc3230"
+
+
+
+/** MC32X0 Data Range
+*/
+#if defined(MCUBE_1_5G_8BIT) || defined(MCUBE_1_5G_8BIT_TAP)
+    #define ABSMIN                -128
+    #define ABSMAX                127
+    #define FUZZ                     0
+    #define LSG                  86
+#elif defined(MCUBE_2G_10BIT) || defined(MCUBE_2G_10BIT_TAP)
+    #define ABSMIN                -512
+    #define ABSMAX                511
+    #define FUZZ                     0
+    #define LSG                  256
+#elif defined(MCUBE_8G_14BIT) || defined(MCUBE_8G_14BIT_TAP)
+    #define ABSMIN                -8192
+    #define ABSMAX                8191
+    #define FUZZ                     0
+    #define LSG                  1024
+#else   // default: 8bit
+    #define ABSMIN                -128
+    #define ABSMAX                127    
+    #define FUZZ                     0
+    #define LSG                  86
+#endif
+
+/** MC32X0 I2C Address
+*/
+
+#define MC32X0_I2C_ADDR        0x4c // 0x98 >> 1
+
+
+
+/*
+    MC32X0 API error codes
+*/
+
+#define E_NULL_PTR        (char)-127
+
+/* 
+ *    
+ *    register definitions     
+ *
+ */
+
+#define MC32X0_XOUT_REG                        0x00
+#define MC32X0_YOUT_REG                        0x01
+#define MC32X0_ZOUT_REG                        0x02
+#define MC32X0_Tilt_Status_REG                0x03
+#define MC32X0_Sampling_Rate_Status_REG        0x04
+#define MC32X0_Sleep_Count_REG                0x05
+#define MC32X0_Interrupt_Enable_REG            0x06
+#define MC32X0_Mode_Feature_REG                0x07
+#define MC32X0_Sample_Rate_REG                0x08
+#define MC32X0_Tap_Detection_Enable_REG        0x09
+#define MC32X0_TAP_Dwell_Reject_REG            0x0a
+#define MC32X0_DROP_Control_Register_REG    0x0b
+#define MC32X0_SHAKE_Debounce_REG            0x0c
+#define MC32X0_XOUT_EX_L_REG                0x0d
+#define MC32X0_XOUT_EX_H_REG                0x0e
+#define MC32X0_YOUT_EX_L_REG                0x0f
+#define MC32X0_YOUT_EX_H_REG                0x10
+#define MC32X0_ZOUT_EX_L_REG                0x11
+#define MC32X0_ZOUT_EX_H_REG                0x12
+#define MC32X0_CHIP_ID                        0x18
+#define MC32X0_RANGE_Control_REG            0x20
+#define MC32X0_SHAKE_Threshold_REG            0x2B
+#define MC32X0_UD_Z_TH_REG                    0x2C
+#define MC32X0_UD_X_TH_REG                    0x2D
+#define MC32X0_RL_Z_TH_REG                    0x2E
+#define MC32X0_RL_Y_TH_REG                    0x2F
+#define MC32X0_FB_Z_TH_REG                    0x30
+#define MC32X0_DROP_Threshold_REG            0x31
+#define MC32X0_TAP_Threshold_REG            0x32
+
+
+
+
+/** MC32X0 acceleration data 
+    \brief Structure containing acceleration values for x,y and z-axis in signed short
+
+*/
+
+typedef struct  {
+        short x, /**< holds x-axis acceleration data sign extended. Range -512 to 511. */
+              y, /**< holds y-axis acceleration data sign extended. Range -512 to 511. */
+              z; /**< holds z-axis acceleration data sign extended. Range -512 to 511. */
+} mc32x0acc_t;
+
+/* RANGE */
+
+#define MC32X0_RANGE__POS                2
+#define MC32X0_RANGE__LEN                2
+#define MC32X0_RANGE__MSK                0x0c    
+#define MC32X0_RANGE__REG                MC32X0_RANGE_Control_REG
+
+/* MODE */
+
+#define MC32X0_MODE__POS                0
+#define MC32X0_MODE__LEN                2
+#define MC32X0_MODE__MSK                0x03    
+#define MC32X0_MODE__REG                MC32X0_Mode_Feature_REG
+
+#define MC32X0_MODE_DEF                 0x43
+
+
+/* BANDWIDTH */
+
+#define MC32X0_BANDWIDTH__POS            4
+#define MC32X0_BANDWIDTH__LEN            3
+#define MC32X0_BANDWIDTH__MSK            0x70    
+#define MC32X0_BANDWIDTH__REG            MC32X0_RANGE_Control_REG
+
+
+#define MC32X0_GET_BITSLICE(regvar, bitname)\
+            (regvar & bitname##__MSK) >> bitname##__POS
+
+
+#define MC32X0_SET_BITSLICE(regvar, bitname, val)\
+          (regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK)  
+
+
+
+
+
+
+#define MC32X0_RANGE_2G                    0
+#define MC32X0_RANGE_4G                    1
+#define MC32X0_RANGE_8G                    2
+
+
+#define MC32X0_WAKE                        1
+#define MC32X0_SNIFF                    2
+#define MC32X0_STANDBY                    3
+
+
+#define MC32X0_LOW_PASS_512HZ            0
+#define MC32X0_LOW_PASS_256HZ            1
+#define MC32X0_LOW_PASS_128HZ            2
+#define MC32X0_LOW_PASS_64HZ            3
+#define MC32X0_LOW_PASS_32HZ            4
+#define MC32X0_LOW_PASS_16HZ            5
+#define MC32X0_LOW_PASS_8HZ                6
+
+
+
+
+
+typedef struct {    
+    unsigned char mode;        /**< save current MC32X0 operation mode */
+    unsigned char chip_id;    /**< save MC32X0's chip id which has to be 0x00/0x01 after calling mc32x0_init() */
+    unsigned char dev_addr;   /**< initializes MC32X0's I2C device address 0x4c */
+    MC32X0_WR_FUNC_PTR;          /**< function pointer to the SPI/I2C write function */
+    MC32X0_RD_FUNC_PTR;          /**< function pointer to the SPI/I2C read function */
+} mc32x0_t;
+
+//------------------------------------------------------------------------------------------------------------------------
+
+mc32x0_t *p_mc32x0;                /**< pointer to MC32X0 device structure  */
+
+
+/** API Initialization routine
+ \param *mc32x0 pointer to MC32X0 structured type
+ \return result of communication routines 
+ */
+
+int mcube_mc32x0_init(mc32x0_t *mc32x0) 
+{
+    int comres=0;
+    unsigned char data;
+
+    p_mc32x0 = mc32x0;                                                                                /* assign mc32x0 ptr */
+    p_mc32x0->dev_addr = MC32X0_I2C_ADDR;                                                            /* preset  I2C_addr */
+    comres += p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_CHIP_ID, &data, 1);            /* read Chip Id */
+    
+    p_mc32x0->chip_id = data;                        
+    return comres;
+}
+
+int mc32x0_set_image (void) 
+{
+    int comres;
+    unsigned char data;
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+    
+#ifdef MCUBE_2G_10BIT_TAP        
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );    
+    
+    data = 0x80;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+    
+    data = 0x05;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Dwell_Reject_REG, &data, 1 );
+    
+    data = 0x33;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+    
+    data = 0x07;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Threshold_REG, &data, 1 );
+    
+    data = 0x04;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+        
+#endif
+
+#ifdef MCUBE_2G_10BIT
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );    
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+
+    data = 0x33;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+
+#endif
+
+#ifdef MCUBE_8G_14BIT_TAP        
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );    
+    
+    data = 0x80;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+    
+    data = 0x05;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Dwell_Reject_REG, &data, 1 );
+    
+    data = 0x3F;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+    
+    data = 0x07;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Threshold_REG, &data, 1 );
+    
+    data = 0x04;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+        
+#endif
+
+#ifdef MCUBE_8G_14BIT
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );    
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+
+    data = 0x3F;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+
+#endif
+
+
+
+#ifdef MCUBE_1_5G_8BIT
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );    
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );
+
+    data = 0x02;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+
+#endif
+
+
+#ifdef MCUBE_1_5G_8BIT_TAP
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );    
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );
+
+    data = 0x80;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );    
+
+    data = 0x02;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+
+    data = 0x03;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Dwell_Reject_REG, &data, 1 );
+
+    data = 0x07;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Threshold_REG, &data, 1 );
+
+    data = 0x04;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+
+#endif
+
+    
+#ifdef  MCUBE_1_5G_6BIT
+    
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );    
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+    
+        
+#endif
+
+
+
+    return comres;
+}
+
+
+int mc32x0_get_offset(unsigned char *offset, int len) 
+{    
+    int comres;
+    
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, 0x21, offset, len);
+    
+    return comres;
+}    
+
+
+int mc32x0_set_offset(unsigned char *offset, int len) 
+{
+    int comres;
+    unsigned char data;
+    
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    data = 0x43;
+    comres = p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1); 
+    
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, 0x21, offset, len);
+    
+    data = 0x41;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1);
+    
+    return comres;
+}
+
+
+
+
+/**    set mc32x0s range 
+ \param range 
+ 
+ \see MC32X0_RANGE_2G        
+ \see MC32X0_RANGE_4G            
+ \see MC32X0_RANGE_8G            
+*/
+int mc32x0_set_range(char range) 
+{            
+   int comres = 0;
+   unsigned char data;
+
+   if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+   if (range<3) {    
+       comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE__REG, &data, 1);
+       data = MC32X0_SET_BITSLICE(data, MC32X0_RANGE, range);
+       comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE__REG, &data, 1);
+
+   }
+   return comres;
+
+}
+
+
+/* readout select range from MC32X0 
+   \param *range pointer to range setting
+   \return result of bus communication function
+   \see MC32X0_RANGE_2G, MC32X0_RANGE_4G, MC32X0_RANGE_8G        
+   \see mc32x0_set_range()
+*/
+int mc32x0_get_range(unsigned char *range) 
+{
+
+    int comres = 0;
+    unsigned char data;
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE__REG, &data, 1);
+    data = MC32X0_GET_BITSLICE(data, MC32X0_RANGE);
+
+    *range = data;
+
+    
+    return comres;
+
+}
+
+
+
+int mc32x0_set_mode(unsigned char mode) {
+    
+    int comres=0;
+    unsigned char data;
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    if (mode<4) {
+        data  = MC32X0_MODE_DEF;
+        data  = MC32X0_SET_BITSLICE(data, MC32X0_MODE, mode);          
+        comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_MODE__REG, &data, 1 );
+
+          p_mc32x0->mode = mode;
+    } 
+    return comres;
+    
+}
+
+
+
+int mc32x0_get_mode(unsigned char *mode) 
+{
+    if (p_mc32x0==0)
+        return E_NULL_PTR;    
+        *mode =  p_mc32x0->mode;
+      return 0;
+}
+
+
+int mc32x0_set_bandwidth(char bw) 
+{
+    int comres = 0;
+    unsigned char data;
+
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    if (bw<7) {
+
+        comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_BANDWIDTH__REG, &data, 1 );
+      data = MC32X0_SET_BITSLICE(data, MC32X0_BANDWIDTH, bw);
+      comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_BANDWIDTH__REG, &data, 1 );
+
+    }
+
+    return comres;
+
+
+}
+
+int mc32x0_get_bandwidth(unsigned char *bw) {
+    int comres = 1;
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_BANDWIDTH__REG, bw, 1 );        
+
+    *bw = MC32X0_GET_BITSLICE(*bw, MC32X0_BANDWIDTH);
+    
+    return comres;
+
+}
+
+
+int mc32x0_read_accel_x(short *a_x) 
+{
+    int comres;
+    unsigned char data[2];
+    
+    
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_XOUT_EX_L_REG, &data[0],2);
+    
+    *a_x = ((short)data[0])|(((short)data[1])<<8);
+
+    return comres;
+    
+}
+
+
+
+int mc32x0_read_accel_y(short *a_y) 
+{
+    int comres;
+    unsigned char data[2];    
+
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_YOUT_EX_L_REG, &data[0],2);
+    
+    *a_y = ((short)data[0])|(((short)data[1])<<8);
+
+    return comres;
+}
+
+
+int mc32x0_read_accel_z(short *a_z)
+{
+    int comres;
+    unsigned char data[2];    
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_ZOUT_EX_L_REG, &data[0],2);
+    
+    *a_z = ((short)data[0])|(((short)data[1])<<8);
+
+    return comres;
+}
+
+
+int mc32x0_read_accel_xyz(mc32x0acc_t * acc)
+{
+    int comres;
+    unsigned char data[6];
+
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+    
+#ifdef MC32X0_HIGH_END
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_XOUT_EX_L_REG, &data[0],6);
+    
+    acc->x = ((signed short)data[0])|(((signed short)data[1])<<8);
+    acc->y = ((signed short)data[2])|(((signed short)data[3])<<8);
+    acc->z = ((signed short)data[4])|(((signed short)data[5])<<8);
+#endif
+
+#ifdef MC32X0_LOW_END
+        comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_XOUT_REG, &data[0],3);
+        
+#ifndef MCUBE_1_5G_6BIT        
+                acc->x = (signed char)data[0];
+                acc->y = (signed char)data[1];
+                acc->z = (signed char)data[2];
+#else 
+                acc->x = (signed short)GET_REAL_VALUE(data[0],6);
+                acc->y = (signed short)GET_REAL_VALUE(data[1],6);
+                acc->z = (signed short)GET_REAL_VALUE(data[2],6);
+#endif
+        
+#endif
+
+
+
+    
+    return comres;
+    
+}
+
+
+
+int mc32x0_get_interrupt_status(unsigned char * ist) 
+{
+
+    int comres=0;    
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_Tilt_Status_REG, ist, 1);
+    return comres;
+}
+
+
+
+int mc32x0_read_reg(unsigned char addr, unsigned char *data, unsigned char len)
+{
+
+    int comres;
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, addr, data, len);
+    return comres;
+
+}
+
+
+int mc32x0_write_reg(unsigned char addr, unsigned char *data, unsigned char len) 
+{
+
+    int comres;
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, addr, data, len);
+
+    return comres;
+
+}
+
+//------------------------------------------------------------------------------------------------------------------------
+
+#define MC32X0_IOC_MAGIC 'M'
+
+#define MC32X0_SET_RANGE                _IOWR(MC32X0_IOC_MAGIC,4, unsigned char)
+#define MC32X0_GET_RANGE                _IOWR(MC32X0_IOC_MAGIC,5, unsigned char)
+#define MC32X0_SET_MODE                    _IOWR(MC32X0_IOC_MAGIC,6, unsigned char)
+#define MC32X0_GET_MODE                    _IOWR(MC32X0_IOC_MAGIC,7, unsigned char)
+#define MC32X0_SET_BANDWIDTH            _IOWR(MC32X0_IOC_MAGIC,8, unsigned char)
+#define MC32X0_GET_BANDWIDTH            _IOWR(MC32X0_IOC_MAGIC,9, unsigned char)
+#define MC32X0_READ_ACCEL_X                _IOWR(MC32X0_IOC_MAGIC,10,short)
+#define MC32X0_READ_ACCEL_Y                _IOWR(MC32X0_IOC_MAGIC,11,short)
+#define MC32X0_READ_ACCEL_Z                _IOWR(MC32X0_IOC_MAGIC,12,short)
+#define MC32X0_GET_INTERRUPT_STATUS        _IOWR(MC32X0_IOC_MAGIC,13,unsigned char)
+#define MC32X0_READ_ACCEL_XYZ            _IOWR(MC32X0_IOC_MAGIC,14,short)
+
+#define MC32X0_IOC_MAXNR                50
+
+#define MC32X0_DEBUG                 1
+
+// configuration
+#define MC32X0_POLL_INTERVAL        (100)
+#define MC32X0_DEF_VOLTAGE          (3300000)
+
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  0
+
+// calibration file path
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+/*******************************************
+* for xml cfg
+*******************************************/
+#define CFG_GSENSOR_ADAP_ID          "gsensor.i2c_adap_id"
+#define CFG_GSENSOR_POSITION         "gsensor.position"
+#define CFG_GSENSOR_CALIBRATION      "gsensor.calibration"
+#define CFG_GSENSOR_REGULATOR        "gsensor.regulator"
+
+extern int get_config(const char *key, char *buff, int len);
+
+static struct input_dev *mc32x0_idev;
+static struct i2c_client *mc32x0_client = NULL;  
+static struct delayed_work mc32x0_work;
+
+static char mc32x0_regulator_name[16];
+static struct regulator *mc32x0_regulator = NULL;
+static int mc32x0_voltage = MC32X0_DEF_VOLTAGE;
+
+static atomic_t mc32x0_delay = {0};
+static atomic_t mc32x0_enable = {0};
+static atomic_t mc32x0_position = {0};
+static atomic_t mc32x0_fuzz = {0};
+
+static int mc32x0_calib_inited = 0;
+static unsigned char mc32x0_calib_default[9];
+static unsigned char mc32x0_offset_saved[9];
+
+struct mc32x0_data{
+    mc32x0_t mc32x0;
+};
+
+static char mc32x0_i2c_write(unsigned char reg_addr, unsigned char *data, unsigned char len);
+static char mc32x0_i2c_read(unsigned char reg_addr, unsigned char *data, unsigned char len);
+static void mc32x0_i2c_delay(unsigned int msec);
+static int mc32x0_axis_remap(mc32x0acc_t *acc);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend mc32x0_es_handler;
+static void mc32x0_early_suspend(struct early_suspend *handler);
+static void mc32x0_early_resume(struct early_suspend *handler);
+#endif
+
+static ssize_t mc32x0_delay_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_enable_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_fuzz_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_fuzz_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_regs_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_regs_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_value_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_board_position_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_board_position_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_calibration_run_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_calibration_reset_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_calibration_value_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_calibration_value_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        mc32x0_delay_show, mc32x0_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        mc32x0_enable_show, mc32x0_enable_store);
+static DEVICE_ATTR(fuzz, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        mc32x0_fuzz_show, mc32x0_fuzz_store);
+static DEVICE_ATTR(regs, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        mc32x0_regs_show, mc32x0_regs_store);
+static DEVICE_ATTR(value, S_IRUGO, mc32x0_value_show, NULL);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        mc32x0_board_position_show, mc32x0_board_position_store);
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, mc32x0_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP|S_IWOTH,
+        NULL, mc32x0_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+        mc32x0_calibration_value_show,
+        mc32x0_calibration_value_store);
+
+static struct attribute* mc32x0_attrs[] =
+{
+  &dev_attr_delay.attr,
+  &dev_attr_enable.attr,
+  &dev_attr_fuzz.attr,
+  &dev_attr_regs.attr,
+  &dev_attr_value.attr,
+  &dev_attr_board_position.attr,
+  &dev_attr_calibration_run.attr,
+  &dev_attr_calibration_reset.attr,
+  &dev_attr_calibration_value.attr,
+  NULL
+};
+
+static const struct attribute_group mc32x0_group =
+{
+  .attrs = mc32x0_attrs,
+};
+
+static ssize_t mc32x0_delay_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", atomic_read(&mc32x0_delay));
+}
+
+static ssize_t mc32x0_delay_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+ 
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    
+    atomic_set(&mc32x0_delay, (unsigned int) data);
+    return count;
+}
+
+
+static ssize_t mc32x0_enable_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", atomic_read(&mc32x0_enable));
+}
+
+static void mc32x0_do_enable(struct device *dev, int enable)
+{
+    if (enable) {
+        mc32x0_set_mode(MC32X0_WAKE); 
+        schedule_delayed_work(&mc32x0_work,
+            msecs_to_jiffies(atomic_read(&mc32x0_delay)));
+    } else {
+        mc32x0_set_mode(MC32X0_STANDBY);  
+        cancel_delayed_work_sync(&mc32x0_work);
+    }
+}
+
+static void mc32x0_set_enable(struct device *dev, int enable)
+{
+    int pre_enable = atomic_read(&mc32x0_enable);
+
+    if (enable != pre_enable) {
+        mc32x0_do_enable(dev, enable);
+        atomic_set(&mc32x0_enable, enable);        
+    }  
+}
+
+static ssize_t mc32x0_enable_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{ 
+    unsigned long data;
+    int error;
+    
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif   
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    
+    if ((data == 0) || (data == 1)) {
+        mc32x0_set_enable(dev, data);
+    }
+
+    return count;
+}
+
+static ssize_t mc32x0_fuzz_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+
+    data = atomic_read(&mc32x0_fuzz);
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t mc32x0_fuzz_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&mc32x0_fuzz, (int) data);
+    
+    if(mc32x0_idev != NULL) {
+        mc32x0_idev->absinfo[ABS_X].fuzz = data;
+        mc32x0_idev->absinfo[ABS_Y].fuzz = data;
+        mc32x0_idev->absinfo[ABS_Z].fuzz = data;
+    }
+    
+    return count;
+}
+
+static ssize_t mc32x0_regs_show(struct device *dev, 
+        struct device_attribute *attr, char *buf)
+{
+  int idx, len=0, result;
+  unsigned char regs[0x13];
+
+  result = mc32x0_read_reg(0x0, regs, 0x13);
+  if(result != 0) 
+  {
+    printk(KERN_ERR "read reg error!\n");
+    return -1;
+  }
+
+  for(idx=0; idx<0x13; idx++)
+  {
+    len += sprintf(buf+len, "[0x%x]=0x%x\n", idx, regs[idx]);
+  }
+  
+  result = mc32x0_read_reg(0x20, regs, 0x0a);
+  if(result != 0) 
+  {
+    printk(KERN_ERR "read reg error!\n");
+    return -1;
+  }
+
+  for(idx=0; idx<0x0a; idx++)
+  {
+    len += sprintf(buf+len, "[0x%x]=0x%x\n", 0x20+idx, regs[idx]);
+  }
+  return len;
+}
+
+static ssize_t mc32x0_regs_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned int addr;
+    unsigned int data;
+    int error;
+    
+    sscanf(buf, "[0x%x]=0x%x", &addr, &data); 
+    
+    error = mc32x0_write_reg((unsigned char)addr, (unsigned char *)&data, 1);
+    if(error) 
+    {
+        printk(KERN_INFO "write reg error!\n");
+        return error;
+    }
+    
+    return count;
+}
+
+static ssize_t mc32x0_value_show(struct device *dev, 
+        struct device_attribute *attr, char *buf)
+{
+  int result;
+  mc32x0acc_t acc;
+
+  result = mc32x0_read_accel_xyz(&acc);
+  if(result != 0) 
+  {
+    printk(KERN_ERR "read accel xyz error!\n");
+    return -1;
+  }
+  
+  mc32x0_axis_remap(&acc);
+  
+  return sprintf(buf, "%d,%d,%d\n", acc.x, acc.y, acc.z);
+}
+
+static ssize_t mc32x0_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+
+    data = atomic_read(&mc32x0_position);
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t mc32x0_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&mc32x0_position, (int) data);
+
+    return count;
+}
+
+static int mc32x0_calibration_offset(mc32x0acc_t *acc)
+{    
+    int result;
+    unsigned char buf[9];
+    short tmp, x_gain, y_gain, z_gain ;
+    int x_off, y_off, z_off;
+
+    //read register 0x21~0x29
+    result = mc32x0_read_reg(0x21, buf, 9);
+    
+    // get x,y,z offset
+    tmp = ((buf[1] & 0x3f) << 8) + buf[0];
+    if (tmp & 0x2000)
+        tmp |= 0xc000;
+    x_off = tmp;
+                    
+    tmp = ((buf[3] & 0x3f) << 8) + buf[2];
+    if (tmp & 0x2000)
+        tmp |= 0xc000;
+    y_off = tmp;
+                    
+    tmp = ((buf[5] & 0x3f) << 8) + buf[4];
+    if (tmp & 0x2000)
+        tmp |= 0xc000;
+    z_off = tmp;
+                    
+    // get x,y,z gain
+    x_gain = ((buf[1] >> 7) << 8) + buf[6];
+    y_gain = ((buf[3] >> 7) << 8) + buf[7];
+    z_gain = ((buf[5] >> 7) << 8) + buf[8];
+                                
+    // prepare new offset
+    x_off = x_off + 16 * acc->x * 256 * 128 / 3 / LSG / (40 + x_gain);
+    y_off = y_off + 16 * acc->y * 256 * 128 / 3 / LSG / (40 + y_gain);
+    z_off = z_off + 16 * acc->z * 256 * 128 / 3 / LSG / (40 + z_gain);
+    
+    // write offset to register 0x21~0x26
+    buf[0] = 0x43;
+    result += mc32x0_write_reg(0x07, buf, 1);
+    
+    buf[0] = x_off & 0xff;
+    buf[1] = ((x_off >> 8) & 0x3f) | (x_gain & 0x0100 ? 0x80 : 0);
+    buf[2] = y_off & 0xff;
+    buf[3] = ((y_off >> 8) & 0x3f) | (y_gain & 0x0100 ? 0x80 : 0);
+    buf[4] = z_off & 0xff;
+    buf[5] = ((z_off >> 8) & 0x3f) | (z_gain & 0x0100 ? 0x80 : 0);    
+    result += mc32x0_write_reg(0x21, buf, 6);
+    
+    buf[0] = 0x41;
+    result += mc32x0_write_reg(0x07, buf, 1);
+    
+    return result;
+}
+
+static ssize_t mc32x0_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int ret;
+    int cfg_calibration[9];
+    unsigned char offset[9];
+    int idx;
+    mc32x0acc_t acc;
+    
+    ret = mc32x0_read_accel_xyz(&acc);
+    if(ret != 0) 
+    {
+        printk(KERN_ERR "read accel xyz error!\n");
+        return -1;
+    }
+
+    // get diff
+    acc.x = 0 - acc.x;
+    acc.y = 0 - acc.y;
+    if (atomic_read(&mc32x0_position) > 0) {
+        acc.z = LSG - acc.z;
+    } else {
+        acc.z = (-LSG) - acc.z;
+    }
+    
+    mc32x0_calibration_offset(&acc);
+
+    if (mc32x0_get_offset(offset, sizeof(offset)) < 0)
+        return sprintf((char*)buf, "Read error\n");
+    
+    for (idx = 0; idx < sizeof(offset); idx++)
+    {
+        cfg_calibration[idx] = offset[idx];
+    }
+    
+    printk(KERN_INFO "run fast calibration finished\n");
+    return count;
+}
+
+static ssize_t mc32x0_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int ret;
+    int cfg_calibration[9];
+    int idx;
+    
+    mc32x0_set_offset(mc32x0_calib_default, sizeof(mc32x0_calib_default));    
+    
+    for (idx = 0; idx < sizeof(mc32x0_calib_default); idx++)
+    {
+        cfg_calibration[idx] = mc32x0_calib_default[idx];
+    }
+
+    printk(KERN_INFO "reset fast calibration finished\n");
+    return count;
+}
+
+static ssize_t mc32x0_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char offset[9];
+
+    if (mc32x0_get_offset(offset, sizeof(offset)) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d %d %d %d %d %d %d %d %d\n", offset[0], offset[1], offset[2], 
+                                offset[3], offset[4], offset[5], offset[6], offset[7], offset[8]);
+}
+
+static ssize_t mc32x0_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[9];
+    unsigned char offset[9];
+    int idx;
+
+    sscanf(buf, "%d %d %d %d %d %d %d %d %d", &data[0], &data[1], &data[2],
+                    &data[3], &data[4], &data[5], &data[6], &data[7], &data[8]);
+                    
+    for (idx = 0; idx < sizeof(offset); idx++)
+    {
+        offset[idx] = (unsigned char) data[idx];
+    }
+    
+    if (mc32x0_set_offset(offset, sizeof(offset)) < 0)
+        return -EINVAL;
+
+    printk(KERN_INFO "set fast calibration finished\n");
+    return count;
+}
+
+/*    i2c delay routine for eeprom    */
+static inline void mc32x0_i2c_delay(unsigned int msec)
+{
+    mdelay(msec);
+}
+#if 1
+/*    i2c write routine for mc32x0    */
+static inline char mc32x0_i2c_write(unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    if( mc32x0_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+        dummy = i2c_smbus_write_i2c_block_data(mc32x0_client, reg_addr, len, data);
+        if(dummy < 0)
+            return -1;        
+            
+    return 0;
+}
+
+/*    i2c read routine for mc32x0    */
+static inline char mc32x0_i2c_read(unsigned char reg_addr, unsigned char *data, unsigned char len) 
+{
+    s32 dummy;
+    if( mc32x0_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+        dummy = i2c_smbus_read_i2c_block_data(mc32x0_client, reg_addr, len, data);
+        if(dummy < 0)
+            return -1;        
+    
+    return 0;
+}
+#else
+/*    i2c write routine for mc32x0    */
+static inline char mc32x0_i2c_write(unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    unsigned char buffer[2];
+    if( mc32x0_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+    while(len--)
+    {
+        buffer[0] = reg_addr;
+        buffer[1] = *data;
+        dummy = i2c_master_send(mc32x0_client, (char*)buffer, 2);
+
+        reg_addr++;
+        data++;
+        if(dummy < 0)
+            return -1;
+    }
+    return 0;
+}
+
+/*    i2c read routine for mc32x0    */
+static inline char mc32x0_i2c_read(unsigned char reg_addr, unsigned char *data, unsigned char len) 
+{
+    s32 dummy;
+    if( mc32x0_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+       
+        dummy = i2c_master_send(mc32x0_client, (char*)&reg_addr, 1);
+        if(dummy < 0)
+            return -1;
+        dummy = i2c_master_recv(mc32x0_client, (char*)data, len);
+        if(dummy < 0)
+            return -1;
+        
+    
+    return 0;
+}
+#endif
+
+static int mc32x0_power_on(void)
+{
+    if(mc32x0_regulator_name[0] != '\0') {        
+        // request regulator
+        mc32x0_regulator = regulator_get(NULL, mc32x0_regulator_name);
+        if (IS_ERR(mc32x0_regulator)) {
+            printk(KERN_ERR "mc32x0 get regulator failed\n");
+            return -1;
+        }
+        
+        if (regulator_set_voltage(mc32x0_regulator, mc32x0_voltage, mc32x0_voltage)) {
+            printk(KERN_ERR "mc32x0 set regulator voltage failed\n");
+            regulator_put(mc32x0_regulator);
+            return -1;
+        }
+        
+        regulator_enable(mc32x0_regulator);
+        msleep(20);
+        
+    #ifdef MC32X0_DEBUG
+        printk(KERN_INFO "%s\n",__FUNCTION__);
+    #endif
+    }
+
+    return 0;
+}
+
+static int mc32x0_power_off(void)
+{
+    if(mc32x0_regulator != NULL) {
+        // save current voltage
+        mc32x0_voltage = regulator_get_voltage(mc32x0_regulator);
+        
+        regulator_disable(mc32x0_regulator);    
+        
+        // release regulator
+        regulator_put(mc32x0_regulator);
+        
+    #ifdef MC32X0_DEBUG
+        printk(KERN_INFO "%s\n",__FUNCTION__);
+    #endif
+    }
+    
+    return 0;
+}
+
+static int mc32x0_read_file(char *path, char *buf, int size)
+{
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+static int mc32x0_load_user_calibration(void)
+{
+    char buffer[64];
+    int ret = 0;
+    int data[9];
+    unsigned char offset[9];
+    int idx;
+    
+    // only calibrate once
+    if (mc32x0_calib_inited) {
+        goto usr_calib_end;
+    } else {
+        mc32x0_calib_inited = 1;
+    }
+
+    ret = mc32x0_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d %d %d %d %d %d %d", &data[0], &data[1], &data[2],
+                                &data[3], &data[4], &data[5], &data[6], &data[7], &data[8]);
+                                
+    for (idx = 0; idx < sizeof(offset); idx ++) {
+        offset[idx] = (unsigned char) data[idx];
+    }
+    
+    if (mc32x0_set_offset(offset, sizeof(offset)) < 0) {
+        printk(KERN_ERR"set offset fail\n");
+        goto usr_calib_end;
+    }
+    
+    printk(KERN_INFO "load user calibration finished\n");
+    
+usr_calib_end:
+    return ret;
+}
+
+static int mc32x0_axis_remap(mc32x0acc_t *acc)
+{
+    s16 swap;
+    int position = atomic_read(&mc32x0_position);
+
+    switch (abs(position)) {
+        case 1:
+            break;
+        case 2:
+            swap = acc->x;
+            acc->x = acc->y;
+            acc->y = -swap; 
+            break;
+        case 3:
+            acc->x = -(acc->x);
+            acc->y = -(acc->y);
+            break;
+        case 4:
+            swap = acc->x;
+            acc->x = -acc->y;
+            acc->y = swap;
+            break;
+    }
+    
+    if (position < 0) {
+        acc->z = -(acc->z);
+        acc->x = -(acc->x);
+    }
+    
+    return 0;
+}
+
+static void mc32x0_work_func(struct work_struct *work)
+{
+    mc32x0acc_t acc;
+    unsigned long delay = msecs_to_jiffies(atomic_read(&mc32x0_delay));
+
+    mc32x0_load_user_calibration();
+    
+    mc32x0_read_accel_xyz(&acc);
+    mc32x0_axis_remap(&acc);
+    input_report_abs(mc32x0_idev, ABS_X, acc.x);
+    input_report_abs(mc32x0_idev, ABS_Y, acc.y);
+    input_report_abs(mc32x0_idev, ABS_Z, acc.z);
+    input_sync(mc32x0_idev);
+    
+    schedule_delayed_work(&mc32x0_work, delay);
+}
+
+static int mc32x0_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+    struct i2c_adapter *adapter = client->adapter;
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n", __FUNCTION__);
+#endif
+    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+        return -ENODEV;
+
+    strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+
+    return 0;
+}
+
+static int mc32x0_probe(struct i2c_client *client,
+             const struct i2c_device_id *id)
+{
+        struct mc32x0_data *data;
+        int cfg_position;
+        int err = 0;
+        int tempvalue;
+        int cfg_calibration[3];
+        mc32x0acc_t acc;
+    	char * buf;
+			int temp;
+#ifdef MC32X0_DEBUG
+        printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+    
+        if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+        {
+            printk(KERN_INFO "i2c_check_functionality error\n");
+            goto exit;
+        }
+    
+        /* OK. For now, we presume we have a valid client. We now create the
+           client structure, even though we cannot fill it completely yet. */
+        if (!(data = kmalloc(sizeof(struct mc32x0_data), GFP_KERNEL)))
+        {
+            err = -ENOMEM;
+            printk(KERN_INFO "kmalloc error\n");
+            goto exit;
+        }
+        memset(data, 0, sizeof(struct mc32x0_data));
+    
+        i2c_set_clientdata(client, data);
+        
+        /* read chip id */
+        tempvalue = i2c_smbus_read_byte_data(client, MC32X0_CHIP_ID);
+
+        if((tempvalue&0x00FF) == 0x0001)
+        {
+            printk(KERN_INFO "mCube Device detected!\nMC32X0 registered I2C driver!\n");
+            mc32x0_client = client;
+        }
+        else
+        {
+            printk(KERN_INFO "mCube Device not found, i2c error %d \n", tempvalue);
+            
+            data = i2c_get_clientdata(client);
+    
+            mc32x0_client = NULL;
+            err = -1;
+            goto exit_kfree;
+        }
+#if CFG_GSENSOR_USE_CONFIG > 0
+        err = of_property_read_string(client->dev.of_node, "position", &buf);
+        if (err != 0) {
+            printk(KERN_ERR"get position fail\n");
+        //    goto exit_kfree;
+        }
+      err = strict_strtol(buf, 10, &temp);	
+			cfg_position = (int)temp;
+#else
+        cfg_position = 4;
+#endif
+	printk(KERN_ERR "position is %d\n", cfg_position);
+	
+        atomic_set(&mc32x0_position, cfg_position);
+        atomic_set(&mc32x0_delay, MC32X0_POLL_INTERVAL);
+        atomic_set(&mc32x0_enable, 0); 
+        atomic_set(&mc32x0_fuzz, FUZZ);       
+        INIT_DELAYED_WORK(&mc32x0_work, mc32x0_work_func);
+    
+        /*input poll device register */
+        mc32x0_idev = input_allocate_device();
+        if (!mc32x0_idev) {
+            printk(KERN_ERR"alloc poll device failed!\n");
+            goto exit_kfree;
+        }
+
+        mc32x0_idev->name = SENSOR_NAME;
+        mc32x0_idev->id.bustype = BUS_I2C;
+//        mc32x0_idev->dev.parent = &client->dev;
+        
+        input_set_capability(mc32x0_idev, EV_ABS, ABS_MISC);
+        input_set_abs_params(mc32x0_idev, ABS_X, ABSMIN, ABSMAX, FUZZ, 0);
+        input_set_abs_params(mc32x0_idev, ABS_Y, ABSMIN, ABSMAX, FUZZ, 0);
+        input_set_abs_params(mc32x0_idev, ABS_Z, ABSMIN, ABSMAX, FUZZ, 0);
+
+        err = input_register_device(mc32x0_idev);
+        if (err) {
+            printk(KERN_ERR "mc32x0 input register failed\n");
+            goto error_register;
+        }
+  
+        err = sysfs_create_group(&mc32x0_idev->dev.kobj, &mc32x0_group);
+        if (err) {
+            printk(KERN_ERR "mc32x0 create sysfs group failed\n");
+            goto error_register;
+        }
+  
+#ifdef CONFIG_HAS_EARLYSUSPEND
+        mc32x0_es_handler.suspend = mc32x0_early_suspend;
+        mc32x0_es_handler.resume = mc32x0_early_resume;
+        register_early_suspend(&mc32x0_es_handler);
+#endif
+
+        printk(KERN_INFO "mc32x0 device create ok: %s\n", SENSOR_NAME);
+        
+        data->mc32x0.bus_write = mc32x0_i2c_write;
+        data->mc32x0.bus_read = mc32x0_i2c_read;
+        mcube_mc32x0_init(&(data->mc32x0));
+        
+        mc32x0_set_image();    
+        
+        // save default offset & gain
+        mc32x0_get_offset(mc32x0_calib_default, sizeof(mc32x0_calib_default));
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+        /*get xml cfg*/
+        err = of_property_read_u32_array(client->dev.of_node, "calibration_table", cfg_calibration, 3);
+        if (err != 0) {
+            printk(KERN_ERR"get calibration fail\n");
+           // goto error_register;
+        }
+#else
+        memset(cfg_calibration, 0, sizeof(cfg_calibration));
+#endif    
+    
+        acc.x = (unsigned char) cfg_calibration[0];
+        acc.y = (unsigned char) cfg_calibration[1];
+        acc.z = (unsigned char) cfg_calibration[2];
+
+        // calibration from xml config
+        mc32x0_calibration_offset(&acc);
+
+        return 0;
+        
+error_register:
+        input_unregister_device(mc32x0_idev);
+exit_kfree:
+        kfree(data);
+ exit:
+        return err;
+}
+
+
+
+static int mc32x0_remove(struct i2c_client *client)
+{
+    struct mc32x0_data *data;
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+    mc32x0_set_mode(MC32X0_STANDBY);
+    mc32x0_power_off();
+
+    sysfs_remove_group(&client->dev.kobj, &mc32x0_group);
+
+    data = i2c_get_clientdata(client);
+    mc32x0_client = NULL;
+    
+    if (mc32x0_idev) 
+    {
+        printk(KERN_INFO "remove input device\n");
+        input_unregister_device(mc32x0_idev);
+        input_free_device(mc32x0_idev);
+        mc32x0_idev = NULL;
+    }
+    kfree(data);
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int mc32x0_suspend(struct device *dev)
+{    
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+
+    // save offset 
+    mc32x0_get_offset(mc32x0_offset_saved, sizeof(mc32x0_offset_saved));      
+    
+    mc32x0_do_enable(dev, 0);      
+    //mc32x0_power_off();
+    
+    return 0;
+}
+
+static int mc32x0_resume(struct device *dev)
+{
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+
+    mc32x0_set_image();     
+    mc32x0_do_enable(dev, atomic_read(&mc32x0_enable));
+    
+    // restore offset 
+    mc32x0_set_offset(mc32x0_offset_saved, sizeof(mc32x0_offset_saved));        
+    
+    return 0;
+}
+#else
+
+#define mc32x0_suspend NULL
+#define mc32x0_resume NULL
+
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mc32x0_early_suspend(struct early_suspend *handler)
+{
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+    // sensor hal will disable when early suspend
+}
+
+static void mc32x0_early_resume(struct early_suspend *handler)
+{ 
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+    // sensor hal will enable when early resume
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(mc32x0_pm_ops, mc32x0_suspend, mc32x0_resume);
+
+//static unsigned short normal_i2c[] = { MC32X0_I2C_ADDR, I2C_CLIENT_END};
+
+static const struct i2c_device_id mc32x0_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+static struct of_device_id mc323x_of_match[] = {
+	{ .compatible = "mc323x" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, mc32x0_id);
+
+static struct i2c_driver mc32x0_driver = {    
+    .driver = {
+        .owner    = THIS_MODULE,    
+        .name    = SENSOR_NAME,
+        .pm    = &mc32x0_pm_ops,
+        .of_match_table	= of_match_ptr(mc323x_of_match),
+    },
+    .class        = I2C_CLASS_HWMON,
+    .id_table    = mc32x0_id,
+//    .address_list    = normal_i2c,
+    .probe        = mc32x0_probe,
+    .remove        = mc32x0_remove,
+    .detect        = mc32x0_detect,
+};
+
+static struct i2c_board_info mc32x0_board_info={
+    .type = SENSOR_NAME, 
+    .addr = MC32X0_I2C_ADDR,
+};
+
+static struct i2c_client *mc32x0_init_client;
+
+static int __init MC32X0_init(void)
+{
+    printk(KERN_ERR "MC32X0 init\n");    
+    return i2c_add_driver(&mc32x0_driver);
+}
+
+static void __exit MC32X0_exit(void)
+{
+    i2c_del_driver(&mc32x0_driver);
+    printk(KERN_ERR "MC32X0 exit\n");
+}
+
+MODULE_DESCRIPTION("MC32X0 driver");
+MODULE_LICENSE("GPL");
+
+module_init(MC32X0_init);
+module_exit(MC32X0_exit);
diff --git a/drivers/input/misc/gsensor/mc3232.c b/drivers/input/misc/gsensor/mc3232.c
new file mode 100755
index 0000000..2051a76
--- /dev/null
+++ b/drivers/input/misc/gsensor/mc3232.c
@@ -0,0 +1,1900 @@
+/*
+ * Copyright (C) 2011 MCUBE, Inc.
+ *
+ * Initial Code:
+ *    Tan Liang
+ */
+
+
+/*! \file mc32x0_driver.c
+    \brief This file contains all function implementations for the mc32x0 in linux
+    
+    Details.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <asm/uaccess.h>
+#include <linux/unistd.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/input-polldev.h>
+#include <linux/regulator/consumer.h>
+#include <linux/hrtimer.h>  
+#include <linux/ktime.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+//#include "gsensor_common.h"
+
+
+/* ----------------------------------------------------------------------------------------------------*/
+
+#define MC32X0_WR_FUNC_PTR char (* bus_write)(unsigned char, unsigned char *, unsigned char)
+
+#define MC32X0_BUS_WRITE_FUNC(dev_addr, reg_addr, reg_data, wr_len)\
+           bus_write(reg_addr, reg_data, wr_len)
+
+#define MC32X0_RD_FUNC_PTR char (* bus_read)( unsigned char, unsigned char *, unsigned char)
+
+#define MC32X0_BUS_READ_FUNC(dev_addr, reg_addr, reg_data, r_len)\
+           bus_read(reg_addr, reg_data, r_len)
+
+#define GET_REAL_VALUE(rv, bn) \
+    ((rv & (0x01 << (bn - 1))) ? (- (rv & ~(0xffff << (bn - 1)))) : (rv & ~(0xffff << (bn - 1))))
+
+
+
+//#define MC32X0_HIGH_END
+/*******MC3210/20 define this**********/
+
+//#define MCUBE_2G_10BIT_TAP
+//#define MCUBE_2G_10BIT
+//#define MCUBE_8G_14BIT_TAP
+//#define MCUBE_8G_14BIT
+
+//#define SENSOR_NAME "mc3210"
+
+#define MC32X0_HRTIMER 1
+
+#define MC32X0_LOW_END
+/*******MC3230 define this**********/
+
+#define MCUBE_1_5G_8BIT
+//#define MCUBE_1_5G_8BIT_TAP
+
+#define SUPPORT_VIRTUAL_Z_SENSOR
+
+#define LOW_RESOLUTION 1
+#define HIGH_RESOLUTION 2
+#define RBM_RESOLUTION 3
+#ifdef SUPPORT_VIRTUAL_Z_SENSOR
+#define Low_Pos_Max 127
+#define Low_Neg_Max -128
+#define High_Pos_Max 8191
+#define High_Neg_Max -8192
+#define VIRTUAL_Z	1
+#define 	G_2_REVERSE 0
+static int Railed = 0;
+#else
+#define VIRTUAL_Z	0
+#endif
+#define SENSOR_NAME "mc3230"
+
+
+/** MC32X0 Data Range
+*/
+#if defined(MCUBE_1_5G_8BIT) || defined(MCUBE_1_5G_8BIT_TAP)
+    #define ABSMIN                -128
+    #define ABSMAX                127
+    #define FUZZ                     0
+    #define LSG                  86
+#elif defined(MCUBE_2G_10BIT) || defined(MCUBE_2G_10BIT_TAP)
+    #define ABSMIN                -512
+    #define ABSMAX                511
+    #define FUZZ                     0
+    #define LSG                  256
+#elif defined(MCUBE_8G_14BIT) || defined(MCUBE_8G_14BIT_TAP)
+    #define ABSMIN                -8192
+    #define ABSMAX                8191
+    #define FUZZ                     0
+    #define LSG                  1024
+#else   // default: 8bit
+    #define ABSMIN                -128
+    #define ABSMAX                127    
+    #define FUZZ                     0
+    #define LSG                  86
+#endif
+
+/** MC32X0 I2C Address
+*/
+
+#define MC32X0_I2C_ADDR        0x4c // 0x98 >> 1
+
+
+
+/*
+    MC32X0 API error codes
+*/
+
+#define E_NULL_PTR        (char)-127
+
+/* 
+ *    
+ *    register definitions     
+ *
+ */
+
+#define MC32X0_XOUT_REG                        0x00
+#define MC32X0_YOUT_REG                        0x01
+#define MC32X0_ZOUT_REG                        0x02
+#define MC32X0_Tilt_Status_REG                0x03
+#define MC32X0_Sampling_Rate_Status_REG        0x04
+#define MC32X0_Sleep_Count_REG                0x05
+#define MC32X0_Interrupt_Enable_REG            0x06
+#define MC32X0_Mode_Feature_REG                0x07
+#define MC32X0_Sample_Rate_REG                0x08
+#define MC32X0_Tap_Detection_Enable_REG        0x09
+#define MC32X0_TAP_Dwell_Reject_REG            0x0a
+#define MC32X0_DROP_Control_Register_REG    0x0b
+#define MC32X0_SHAKE_Debounce_REG            0x0c
+#define MC32X0_XOUT_EX_L_REG                0x0d
+#define MC32X0_XOUT_EX_H_REG                0x0e
+#define MC32X0_YOUT_EX_L_REG                0x0f
+#define MC32X0_YOUT_EX_H_REG                0x10
+#define MC32X0_ZOUT_EX_L_REG                0x11
+#define MC32X0_ZOUT_EX_H_REG                0x12
+#define MC32X0_CHIP_ID                        0x3B
+#define MC32X0_RANGE_Control_REG            0x20
+#define MC32X0_SHAKE_Threshold_REG            0x2B
+#define MC32X0_UD_Z_TH_REG                    0x2C
+#define MC32X0_UD_X_TH_REG                    0x2D
+#define MC32X0_RL_Z_TH_REG                    0x2E
+#define MC32X0_RL_Y_TH_REG                    0x2F
+#define MC32X0_FB_Z_TH_REG                    0x30
+#define MC32X0_DROP_Threshold_REG            0x31
+#define MC32X0_TAP_Threshold_REG            0x32
+
+
+
+
+/** MC32X0 acceleration data 
+    \brief Structure containing acceleration values for x,y and z-axis in signed short
+
+*/
+
+typedef struct  {
+        short x, /**< holds x-axis acceleration data sign extended. Range -512 to 511. */
+              y, /**< holds y-axis acceleration data sign extended. Range -512 to 511. */
+              z; /**< holds z-axis acceleration data sign extended. Range -512 to 511. */
+} mc32x0acc_t;
+
+/* RANGE */
+
+#define MC32X0_RANGE__POS                2
+#define MC32X0_RANGE__LEN                2
+#define MC32X0_RANGE__MSK                0x0c    
+#define MC32X0_RANGE__REG                MC32X0_RANGE_Control_REG
+
+/* MODE */
+
+#define MC32X0_MODE__POS                0
+#define MC32X0_MODE__LEN                2
+#define MC32X0_MODE__MSK                0x03    
+#define MC32X0_MODE__REG                MC32X0_Mode_Feature_REG
+
+#define MC32X0_MODE_DEF                 0x43
+
+
+/* BANDWIDTH */
+
+#define MC32X0_BANDWIDTH__POS            4
+#define MC32X0_BANDWIDTH__LEN            3
+#define MC32X0_BANDWIDTH__MSK            0x70    
+#define MC32X0_BANDWIDTH__REG            MC32X0_RANGE_Control_REG
+
+
+#define MC32X0_GET_BITSLICE(regvar, bitname)\
+            (regvar & bitname##__MSK) >> bitname##__POS
+
+
+#define MC32X0_SET_BITSLICE(regvar, bitname, val)\
+          (regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK)  
+
+
+
+
+
+
+#define MC32X0_RANGE_2G                    0
+#define MC32X0_RANGE_4G                    1
+#define MC32X0_RANGE_8G                    2
+
+
+#define MC32X0_WAKE                        1
+#define MC32X0_SNIFF                    2
+#define MC32X0_STANDBY                    3
+
+
+#define MC32X0_LOW_PASS_512HZ            0
+#define MC32X0_LOW_PASS_256HZ            1
+#define MC32X0_LOW_PASS_128HZ            2
+#define MC32X0_LOW_PASS_64HZ            3
+#define MC32X0_LOW_PASS_32HZ            4
+#define MC32X0_LOW_PASS_16HZ            5
+#define MC32X0_LOW_PASS_8HZ                6
+
+
+
+
+
+typedef struct {    
+    unsigned char mode;        /**< save current MC32X0 operation mode */
+    unsigned char chip_id;    /**< save MC32X0's chip id which has to be 0x00/0x01 after calling mc32x0_init() */
+    unsigned char dev_addr;   /**< initializes MC32X0's I2C device address 0x4c */
+    MC32X0_WR_FUNC_PTR;          /**< function pointer to the SPI/I2C write function */
+    MC32X0_RD_FUNC_PTR;          /**< function pointer to the SPI/I2C read function */
+} mc32x0_t;
+
+//------------------------------------------------------------------------------------------------------------------------
+
+mc32x0_t *p_mc32x0;                /**< pointer to MC32X0 device structure  */
+
+
+/** API Initialization routine
+ \param *mc32x0 pointer to MC32X0 structured type
+ \return result of communication routines 
+ */
+
+int mcube_mc32x0_init(mc32x0_t *mc32x0) 
+{
+    int comres=0;
+    unsigned char data;
+
+    p_mc32x0 = mc32x0;                                                                                /* assign mc32x0 ptr */
+    p_mc32x0->dev_addr = MC32X0_I2C_ADDR;                                                            /* preset  I2C_addr */
+    comres += p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_CHIP_ID, &data, 1);            /* read Chip Id */
+    
+    p_mc32x0->chip_id = data;
+    return comres;
+}
+
+int mc32x0_set_image (void) 
+{
+    int comres;
+    unsigned char data;
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+    
+#ifdef MCUBE_2G_10BIT_TAP        
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );    
+    
+    data = 0x80;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+    
+    data = 0x05;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Dwell_Reject_REG, &data, 1 );
+    
+    data = 0x33;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+    
+    data = 0x07;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Threshold_REG, &data, 1 );
+    
+    data = 0x04;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+        
+#endif
+
+#ifdef MCUBE_2G_10BIT
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );    
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+
+    data = 0x33;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+
+#endif
+
+#ifdef MCUBE_8G_14BIT_TAP        
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );    
+    
+    data = 0x80;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+    
+    data = 0x05;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Dwell_Reject_REG, &data, 1 );
+    
+    data = 0x3F;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+    
+    data = 0x07;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Threshold_REG, &data, 1 );
+    
+    data = 0x04;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+        
+#endif
+
+#ifdef MCUBE_8G_14BIT
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );    
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+
+    data = 0x3F;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+
+#endif
+
+
+
+#ifdef MCUBE_1_5G_8BIT
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );    
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );
+
+    data = 0x02;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+
+#endif
+
+
+#ifdef MCUBE_1_5G_8BIT_TAP
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );    
+
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );
+
+    data = 0x80;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );    
+
+    data = 0x02;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+
+    data = 0x03;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Dwell_Reject_REG, &data, 1 );
+
+    data = 0x07;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_TAP_Threshold_REG, &data, 1 );
+
+    data = 0x04;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+
+#endif
+
+    
+#ifdef  MCUBE_1_5G_6BIT
+    
+    data = MC32X0_MODE_DEF;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1 );
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sleep_Count_REG, &data, 1 );    
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Sample_Rate_REG, &data, 1 );
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE_Control_REG, &data, 1 );
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Tap_Detection_Enable_REG, &data, 1 );
+    
+    data = 0x00;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Interrupt_Enable_REG, &data, 1 );
+    
+        
+#endif
+
+
+
+    return comres;
+}
+
+
+int mc32x0_get_offset(unsigned char *offset, int len) 
+{    
+    int comres;
+    
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, 0x21, offset, len);
+    
+    return comres;
+}    
+
+
+int mc32x0_set_offset(unsigned char *offset, int len) 
+{
+    int comres;
+    unsigned char data;
+    
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    data = 0x43;
+    comres = p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1); 
+    
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, 0x21, offset, len);
+    
+    data = 0x41;
+    comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_Mode_Feature_REG, &data, 1);
+    
+    return comres;
+}
+
+
+
+
+/**    set mc32x0s range 
+ \param range 
+ 
+ \see MC32X0_RANGE_2G        
+ \see MC32X0_RANGE_4G            
+ \see MC32X0_RANGE_8G            
+*/
+int mc32x0_set_range(char range) 
+{            
+   int comres = 0;
+   unsigned char data;
+
+   if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+   if (range<3) {    
+       comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE__REG, &data, 1);
+       data = MC32X0_SET_BITSLICE(data, MC32X0_RANGE, range);
+       comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE__REG, &data, 1);
+
+   }
+   return comres;
+
+}
+
+
+/* readout select range from MC32X0 
+   \param *range pointer to range setting
+   \return result of bus communication function
+   \see MC32X0_RANGE_2G, MC32X0_RANGE_4G, MC32X0_RANGE_8G        
+   \see mc32x0_set_range()
+*/
+int mc32x0_get_range(unsigned char *range) 
+{
+
+    int comres = 0;
+    unsigned char data;
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_RANGE__REG, &data, 1);
+    data = MC32X0_GET_BITSLICE(data, MC32X0_RANGE);
+
+    *range = data;
+
+    
+    return comres;
+
+}
+
+
+
+int mc32x0_set_mode(unsigned char mode) {
+    
+    int comres=0;
+    unsigned char data;
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    if (mode<4) {
+        data  = MC32X0_MODE_DEF;
+        data  = MC32X0_SET_BITSLICE(data, MC32X0_MODE, mode);          
+        comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_MODE__REG, &data, 1 );
+
+          p_mc32x0->mode = mode;
+    } 
+    return comres;
+    
+}
+
+
+
+int mc32x0_get_mode(unsigned char *mode) 
+{
+    if (p_mc32x0==0)
+        return E_NULL_PTR;    
+        *mode =  p_mc32x0->mode;
+      return 0;
+}
+
+#ifdef SUPPORT_VIRTUAL_Z_SENSOR
+int Verify_Z_Railed(int AccData, int resolution)
+{
+	int status = 0;
+	
+//	GSE_LOG("%s: AccData = %d",__func__, AccData);
+	if(resolution == 1) // Low resolution
+	{
+		if((AccData >= Low_Pos_Max && AccData >=0)|| (AccData <= Low_Neg_Max && AccData < 0))
+		{
+			status = 1;
+//			GSE_LOG("%s: Railed at Low Resolution",__func__);
+		}
+	}
+	else if (resolution == 2)	//High resolution
+	{
+		if((AccData >= High_Pos_Max && AccData >=0) || (AccData <= High_Neg_Max && AccData < 0))
+		{
+			status = 1;
+		//	GSE_LOG("%s: Railed at High Resolution",__func__);
+		}
+	}
+	else if (resolution == 3)	//High resolution
+	{
+		if((AccData >= Low_Pos_Max*3 && AccData >=0) || (AccData <= Low_Neg_Max*3 && AccData < 0))
+		{
+			status = 1;
+	//		GSE_LOG("%s: Railed at High Resolution",__func__);
+		}
+	}
+	else{
+	//	GSE_LOG("%s, Wrong resolution",__func__);
+	//printk("%s: -- snake add --- nothing!\n");
+}
+	return status;
+}
+
+int SquareRoot(int x) 
+{
+    int lowerbound = 1;
+    int upperbound = x;
+    int root;;
+
+    if(x < 0) 
+    	return -1;
+    	
+    if(x == 0 || x == 1) 
+    	return x;
+
+		root = lowerbound + (upperbound - lowerbound)/2;
+
+    while(root > x/root || root+1 <= x/(root+1))
+    {
+        if(root > x/root)
+        {
+            upperbound = root;
+        } 
+        else 
+        {
+            lowerbound = root;
+        }
+        root = lowerbound + (upperbound - lowerbound)/2;
+    }
+//    GSE_LOG("%s: Sqrt root is %d",__func__, root);
+    return root;
+}
+#endif
+
+int mc32x0_set_bandwidth(char bw) 
+{
+    int comres = 0;
+    unsigned char data;
+
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    if (bw<7) {
+
+        comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_BANDWIDTH__REG, &data, 1 );
+      data = MC32X0_SET_BITSLICE(data, MC32X0_BANDWIDTH, bw);
+      comres += p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, MC32X0_BANDWIDTH__REG, &data, 1 );
+
+    }
+
+    return comres;
+
+
+}
+
+int mc32x0_get_bandwidth(unsigned char *bw) {
+    int comres = 1;
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_BANDWIDTH__REG, bw, 1 );        
+
+    *bw = MC32X0_GET_BITSLICE(*bw, MC32X0_BANDWIDTH);
+    
+    return comres;
+
+}
+
+
+int mc32x0_read_accel_x(short *a_x) 
+{
+    int comres;
+    unsigned char data[2];
+    
+    
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_XOUT_EX_L_REG, &data[0],2);
+    
+    *a_x = ((short)data[0])|(((short)data[1])<<8);
+
+    return comres;
+    
+}
+
+
+
+int mc32x0_read_accel_y(short *a_y) 
+{
+    int comres;
+    unsigned char data[2];    
+
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_YOUT_EX_L_REG, &data[0],2);
+    
+    *a_y = ((short)data[0])|(((short)data[1])<<8);
+
+    return comres;
+}
+
+
+int mc32x0_read_accel_z(short *a_z)
+{
+    int comres;
+    unsigned char data[2];    
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_ZOUT_EX_L_REG, &data[0],2);
+    
+    *a_z = ((short)data[0])|(((short)data[1])<<8);
+
+    return comres;
+}
+
+
+int mc32x0_read_accel_xyz(mc32x0acc_t * acc)
+{
+    int comres;
+    unsigned char data[6];
+    static short sx=0, sy=0, sz=0;
+    #ifdef SUPPORT_VIRTUAL_Z_SENSOR
+	int tempX=0;
+	int tempY=0;
+#endif
+
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+    
+#ifdef MC32X0_HIGH_END
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_XOUT_EX_L_REG, &data[0],6);
+    
+    acc->x = ((signed short)data[0])|(((signed short)data[1])<<8);
+    acc->y = ((signed short)data[2])|(((signed short)data[3])<<8);
+    acc->z = ((signed short)data[4])|(((signed short)data[5])<<8);
+    			#ifdef SUPPORT_VIRTUAL_Z_SENSOR
+			
+			if(1 == Verify_Z_Railed(buffer[MC32X0_AXIS_Z], LOW_RESOLUTION)) // z-railed
+			{
+				Railed = 1;
+				if (G_2_REVERSE == 1)
+					buffer[MC32X0_AXIS_Z] = (signed short) (  gsensor_gain.z - (abs(tempX) + abs(tempY)));
+				else
+					buffer[MC32X0_AXIS_Z] = (signed short) -(  gsensor_gain.z - (abs(tempX) + abs(tempY)));
+			}
+			else
+			{
+				Railed = 0;	
+			}
+			#endif  
+#endif
+
+#ifdef MC32X0_LOW_END
+        comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_XOUT_REG, &data[0],3);
+        
+#ifndef MCUBE_1_5G_6BIT        
+                acc->x = (signed char)data[0];
+                acc->y = (signed char)data[1];
+                acc->z = (signed char)data[2];
+			#ifdef SUPPORT_VIRTUAL_Z_SENSOR
+		//printk("%s: -- snake add -- LINE[%d] acc->z = %d. LSG = %d.\n", __func__, __LINE__, acc->z, LSG);									
+  
+			if(1 == Verify_Z_Railed(acc->z, LOW_RESOLUTION)) // z-railed
+			{
+				//printk("%s: --- snake add --- Enter\n", __func__);
+				Railed = 1;
+				tempX = acc->x;
+				tempY = acc->y;
+				if (G_2_REVERSE == 1)
+					acc->z = (signed short) (LSG - (abs(tempX) + abs(tempY)));
+				else
+					acc->z = (signed short) -(LSG - (abs(tempX) + abs(tempY)));
+			}
+			else
+			{
+				Railed = 0;	
+			}
+			#endif  
+#else 
+                acc->x = (signed short)GET_REAL_VALUE(data[0],6);
+                acc->y = (signed short)GET_REAL_VALUE(data[1],6);
+                acc->z = (signed short)GET_REAL_VALUE(data[2],6);
+#endif
+        
+#endif
+
+   if((sx == acc->x) && (sy == acc->y) && (sz == acc->z)) {            
+		acc->z = acc->z + 1;
+	}
+
+	sx = acc->x;
+    sy = acc->y;
+    sz = acc->z;
+    
+    return comres;
+    
+}
+
+
+
+int mc32x0_get_interrupt_status(unsigned char * ist) 
+{
+
+    int comres=0;    
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, MC32X0_Tilt_Status_REG, ist, 1);
+    return comres;
+}
+
+
+
+int mc32x0_read_reg(unsigned char addr, unsigned char *data, unsigned char len)
+{
+
+    int comres;
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_READ_FUNC(p_mc32x0->dev_addr, addr, data, len);
+    return comres;
+
+}
+
+
+int mc32x0_write_reg(unsigned char addr, unsigned char *data, unsigned char len) 
+{
+
+    int comres;
+
+    if (p_mc32x0==0)
+        return E_NULL_PTR;
+
+    comres = p_mc32x0->MC32X0_BUS_WRITE_FUNC(p_mc32x0->dev_addr, addr, data, len);
+
+    return comres;
+
+}
+
+//------------------------------------------------------------------------------------------------------------------------
+
+#define MC32X0_IOC_MAGIC 'M'
+
+#define MC32X0_SET_RANGE                _IOWR(MC32X0_IOC_MAGIC,4, unsigned char)
+#define MC32X0_GET_RANGE                _IOWR(MC32X0_IOC_MAGIC,5, unsigned char)
+#define MC32X0_SET_MODE                    _IOWR(MC32X0_IOC_MAGIC,6, unsigned char)
+#define MC32X0_GET_MODE                    _IOWR(MC32X0_IOC_MAGIC,7, unsigned char)
+#define MC32X0_SET_BANDWIDTH            _IOWR(MC32X0_IOC_MAGIC,8, unsigned char)
+#define MC32X0_GET_BANDWIDTH            _IOWR(MC32X0_IOC_MAGIC,9, unsigned char)
+#define MC32X0_READ_ACCEL_X                _IOWR(MC32X0_IOC_MAGIC,10,short)
+#define MC32X0_READ_ACCEL_Y                _IOWR(MC32X0_IOC_MAGIC,11,short)
+#define MC32X0_READ_ACCEL_Z                _IOWR(MC32X0_IOC_MAGIC,12,short)
+#define MC32X0_GET_INTERRUPT_STATUS        _IOWR(MC32X0_IOC_MAGIC,13,unsigned char)
+#define MC32X0_READ_ACCEL_XYZ            _IOWR(MC32X0_IOC_MAGIC,14,short)
+
+#define MC32X0_IOC_MAXNR                50
+
+#define MC32X0_DEBUG                 1
+
+// configuration
+#define MC32X0_POLL_INTERVAL        (100)
+#define MC32X0_DEF_VOLTAGE          (3300000)
+
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  1
+
+// calibration file path
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+/*******************************************
+* for xml cfg
+*******************************************/
+#define CFG_GSENSOR_ADAP_ID          "i2c_adap_id"
+#define CFG_GSENSOR_POSITION         "position"
+#define CFG_GSENSOR_CALIBRATION      "calibration"
+#define CFG_GSENSOR_REGULATOR        "gsensor.regulator"
+#define CFG_GSENSOR_MOD_POSITION   "gsensor_"SENSOR_NAME".position"
+
+static struct input_dev *mc32x0_idev;
+static struct i2c_client *mc32x0_client = NULL;  
+static struct hrtimer hr_timer;
+static struct workqueue_struct *wq;
+static struct delayed_work mc32x0_work;
+
+//static char mc32x0_regulator_name[16];
+//static struct regulator *mc32x0_regulator = NULL;
+//static int mc32x0_voltage = MC32X0_DEF_VOLTAGE;
+
+static atomic_t mc32x0_delay = {0};
+static atomic_t mc32x0_enable = {0};
+static atomic_t mc32x0_position = {0};
+static atomic_t mc32x0_fuzz = {0};
+
+static int mc32x0_calib_inited = 0;
+static unsigned char mc32x0_calib_default[9];
+static unsigned char mc32x0_offset_saved[9];
+
+struct mc32x0_data{
+    mc32x0_t mc32x0;
+};
+
+static char mc32x0_i2c_write(unsigned char reg_addr, unsigned char *data, unsigned char len);
+static char mc32x0_i2c_read(unsigned char reg_addr, unsigned char *data, unsigned char len);
+static void mc32x0_i2c_delay(unsigned int msec);
+static int mc32x0_axis_remap(mc32x0acc_t *acc);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend mc32x0_es_handler;
+static void mc32x0_early_suspend(struct early_suspend *handler);
+static void mc32x0_early_resume(struct early_suspend *handler);
+#endif
+
+static ssize_t mc32x0_delay_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_enable_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_fuzz_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_fuzz_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_regs_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_regs_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_value_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_board_position_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_board_position_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_calibration_run_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_calibration_reset_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc32x0_calibration_value_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc32x0_calibration_value_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc32x0_delay_show, mc32x0_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc32x0_enable_show, mc32x0_enable_store);
+static DEVICE_ATTR(fuzz, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc32x0_fuzz_show, mc32x0_fuzz_store);
+static DEVICE_ATTR(regs, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc32x0_regs_show, mc32x0_regs_store);
+static DEVICE_ATTR(value, S_IRUGO, mc32x0_value_show, NULL);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc32x0_board_position_show, mc32x0_board_position_store);
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP,
+        NULL, mc32x0_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP,
+        NULL, mc32x0_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc32x0_calibration_value_show,
+        mc32x0_calibration_value_store);
+
+static struct attribute* mc32x0_attrs[] =
+{
+  &dev_attr_delay.attr,
+  &dev_attr_enable.attr,
+  &dev_attr_fuzz.attr,
+  &dev_attr_regs.attr,
+  &dev_attr_value.attr,
+  &dev_attr_board_position.attr,
+  &dev_attr_calibration_run.attr,
+  &dev_attr_calibration_reset.attr,
+  &dev_attr_calibration_value.attr,
+  NULL
+};
+
+static const struct attribute_group mc32x0_group =
+{
+  .attrs = mc32x0_attrs,
+};
+
+static ssize_t mc32x0_delay_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", atomic_read(&mc32x0_delay));
+}
+
+static ssize_t mc32x0_delay_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+ 
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    
+    atomic_set(&mc32x0_delay, (unsigned int) data);
+    return count;
+}
+
+
+static ssize_t mc32x0_enable_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", atomic_read(&mc32x0_enable));
+}
+
+static void mc32x0_do_enable(struct device *dev, int enable)
+{
+    if (enable) {
+        mc32x0_set_mode(MC32X0_WAKE); 
+		#if (MC32X0_HRTIMER == 0)
+			queue_delayed_work(wq,&mc32x0_work,
+				msecs_to_jiffies(atomic_read(&mc32x0_delay)));
+		#else
+			hrtimer_start(&hr_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+		#endif
+    } else {
+        mc32x0_set_mode(MC32X0_STANDBY);  
+		#if MC32X0_HRTIMER
+    	    hrtimer_cancel(&hr_timer);
+        #endif
+        cancel_delayed_work_sync(&mc32x0_work);
+    }
+}
+
+static void mc32x0_set_enable(struct device *dev, int enable)
+{
+    int pre_enable = atomic_read(&mc32x0_enable);
+
+    if (enable != pre_enable) {
+        mc32x0_do_enable(dev, enable);
+        atomic_set(&mc32x0_enable, enable);        
+    }  
+}
+
+static ssize_t mc32x0_enable_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{ 
+    unsigned long data;
+    int error;
+    
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif   
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    
+    if ((data == 0) || (data == 1)) {
+        mc32x0_set_enable(dev, data);
+    }
+
+    return count;
+}
+
+static ssize_t mc32x0_fuzz_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+
+    data = atomic_read(&mc32x0_fuzz);
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t mc32x0_fuzz_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&mc32x0_fuzz, (int) data);
+    
+    if(mc32x0_idev != NULL) {
+        mc32x0_idev->absinfo[ABS_X].fuzz = data;
+        mc32x0_idev->absinfo[ABS_Y].fuzz = data;
+        mc32x0_idev->absinfo[ABS_Z].fuzz = data;
+    }
+    
+    return count;
+}
+
+static ssize_t mc32x0_regs_show(struct device *dev, 
+        struct device_attribute *attr, char *buf)
+{
+  int idx, len=0, result;
+  unsigned char regs[0x13];
+
+  result = mc32x0_read_reg(0x0, regs, 0x13);
+  if(result != 0) 
+  {
+    printk(KERN_ERR "read reg error!\n");
+    return -1;
+  }
+
+  for(idx=0; idx<0x13; idx++)
+  {
+    len += sprintf(buf+len, "[0x%x]=0x%x\n", idx, regs[idx]);
+  }
+  
+  result = mc32x0_read_reg(0x20, regs, 0x0a);
+  if(result != 0) 
+  {
+    printk(KERN_ERR "read reg error!\n");
+    return -1;
+  }
+
+  for(idx=0; idx<0x0a; idx++)
+  {
+    len += sprintf(buf+len, "[0x%x]=0x%x\n", 0x20+idx, regs[idx]);
+  }
+  return len;
+}
+
+static ssize_t mc32x0_regs_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned int addr;
+    unsigned int data;
+    int error;
+    
+    sscanf(buf, "[0x%x]=0x%x", &addr, &data); 
+    
+    error = mc32x0_write_reg((unsigned char)addr, (unsigned char *)&data, 1);
+    if(error) 
+    {
+        printk(KERN_INFO "write reg error!\n");
+        return error;
+    }
+    
+    return count;
+}
+
+static ssize_t mc32x0_value_show(struct device *dev, 
+        struct device_attribute *attr, char *buf)
+{
+  int result;
+  mc32x0acc_t acc;
+
+  result = mc32x0_read_accel_xyz(&acc);
+  if(result != 0) 
+  {
+    printk(KERN_ERR "read accel xyz error!\n");
+    return -1;
+  }
+  
+  mc32x0_axis_remap(&acc);
+  
+  return sprintf(buf, "%d,%d,%d\n", acc.x, acc.y, acc.z);
+}
+
+static ssize_t mc32x0_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+
+    data = atomic_read(&mc32x0_position);
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t mc32x0_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&mc32x0_position, (int) data);
+
+    return count;
+}
+
+static int mc32x0_calibration_offset(mc32x0acc_t *acc)
+{    
+    int result;
+    unsigned char buf[9];
+    short tmp, x_gain, y_gain, z_gain ;
+    int x_off, y_off, z_off;
+
+    //read register 0x21~0x29
+    result = mc32x0_read_reg(0x21, buf, 9);
+    
+    // get x,y,z offset
+    tmp = ((buf[1] & 0x3f) << 8) + buf[0];
+    if (tmp & 0x2000)
+        tmp |= 0xc000;
+    x_off = tmp;
+                    
+    tmp = ((buf[3] & 0x3f) << 8) + buf[2];
+    if (tmp & 0x2000)
+        tmp |= 0xc000;
+    y_off = tmp;
+                    
+    tmp = ((buf[5] & 0x3f) << 8) + buf[4];
+    if (tmp & 0x2000)
+        tmp |= 0xc000;
+    z_off = tmp;
+                    
+    // get x,y,z gain
+    x_gain = ((buf[1] >> 7) << 8) + buf[6];
+    y_gain = ((buf[3] >> 7) << 8) + buf[7];
+    z_gain = ((buf[5] >> 7) << 8) + buf[8];
+                                
+    // prepare new offset
+    x_off = x_off + 16 * acc->x * 256 * 128 / 3 / LSG / (40 + x_gain);
+    y_off = y_off + 16 * acc->y * 256 * 128 / 3 / LSG / (40 + y_gain);
+    z_off = z_off + 16 * acc->z * 256 * 128 / 3 / LSG / (40 + z_gain);
+    
+    // write offset to register 0x21~0x26
+    buf[0] = 0x43;
+    result += mc32x0_write_reg(0x07, buf, 1);
+    
+    buf[0] = x_off & 0xff;
+    buf[1] = ((x_off >> 8) & 0x3f) | (x_gain & 0x0100 ? 0x80 : 0);
+    buf[2] = y_off & 0xff;
+    buf[3] = ((y_off >> 8) & 0x3f) | (y_gain & 0x0100 ? 0x80 : 0);
+    buf[4] = z_off & 0xff;
+    buf[5] = ((z_off >> 8) & 0x3f) | (z_gain & 0x0100 ? 0x80 : 0);    
+    result += mc32x0_write_reg(0x21, buf, 6);
+    
+    buf[0] = 0x41;
+    result += mc32x0_write_reg(0x07, buf, 1);
+    
+    return result;
+}
+
+static ssize_t mc32x0_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int ret;
+    int cfg_calibration[9];
+    unsigned char offset[9];
+    int idx;
+    mc32x0acc_t acc;
+    
+    ret = mc32x0_read_accel_xyz(&acc);
+    if(ret != 0) 
+    {
+        printk(KERN_ERR "read accel xyz error!\n");
+        return -1;
+    }
+
+    // get diff
+    acc.x = 0 - acc.x;
+    acc.y = 0 - acc.y;
+    if (atomic_read(&mc32x0_position) > 0) {
+        acc.z = LSG - acc.z;
+    } else {
+        acc.z = (-LSG) - acc.z;
+    }
+    
+    mc32x0_calibration_offset(&acc);
+
+    if (mc32x0_get_offset(offset, sizeof(offset)) < 0)
+        return sprintf((char*)buf, "Read error\n");
+    
+    for (idx = 0; idx < sizeof(offset); idx++)
+    {
+        cfg_calibration[idx] = offset[idx];
+    }
+    
+    printk(KERN_INFO "run fast calibration finished\n");
+    return count;
+}
+
+static ssize_t mc32x0_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[9];
+    int idx;
+    
+    mc32x0_set_offset(mc32x0_calib_default, sizeof(mc32x0_calib_default));    
+    
+    for (idx = 0; idx < sizeof(mc32x0_calib_default); idx++)
+    {
+        cfg_calibration[idx] = mc32x0_calib_default[idx];
+    }
+
+    printk(KERN_INFO "reset fast calibration finished\n");
+    return count;
+}
+
+static ssize_t mc32x0_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char offset[9];
+
+    if (mc32x0_get_offset(offset, sizeof(offset)) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d %d %d %d %d %d %d %d %d\n", offset[0], offset[1], offset[2], 
+                                offset[3], offset[4], offset[5], offset[6], offset[7], offset[8]);
+}
+
+static ssize_t mc32x0_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[9];
+    unsigned char offset[9];
+    int idx;
+
+    sscanf(buf, "%d %d %d %d %d %d %d %d %d", &data[0], &data[1], &data[2],
+                    &data[3], &data[4], &data[5], &data[6], &data[7], &data[8]);
+                    
+    for (idx = 0; idx < sizeof(offset); idx++)
+    {
+        offset[idx] = (unsigned char) data[idx];
+    }
+    
+    if (mc32x0_set_offset(offset, sizeof(offset)) < 0)
+        return -EINVAL;
+
+    printk(KERN_INFO "set fast calibration finished\n");
+    return count;
+}
+
+/*    i2c delay routine for eeprom    */
+static inline void mc32x0_i2c_delay(unsigned int msec)
+{
+    mdelay(msec);
+}
+#if 1
+/*    i2c write routine for mc32x0    */
+static inline char mc32x0_i2c_write(unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    if( mc32x0_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+        dummy = i2c_smbus_write_i2c_block_data(mc32x0_client, reg_addr, len, data);
+        if(dummy < 0)
+            return -1;        
+            
+    return 0;
+}
+
+/*    i2c read routine for mc32x0    */
+static inline char mc32x0_i2c_read(unsigned char reg_addr, unsigned char *data, unsigned char len) 
+{
+    s32 dummy;
+    if( mc32x0_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+        dummy = i2c_smbus_read_i2c_block_data(mc32x0_client, reg_addr, len, data);
+        if(dummy < 0)
+            return -1;        
+    
+    return 0;
+}
+#else
+/*    i2c write routine for mc32x0    */
+static inline char mc32x0_i2c_write(unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    unsigned char buffer[2];
+    if( mc32x0_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+    while(len--)
+    {
+        buffer[0] = reg_addr;
+        buffer[1] = *data;
+        dummy = i2c_master_send(mc32x0_client, (char*)buffer, 2);
+
+        reg_addr++;
+        data++;
+        if(dummy < 0)
+            return -1;
+    }
+    return 0;
+}
+
+/*    i2c read routine for mc32x0    */
+static inline char mc32x0_i2c_read(unsigned char reg_addr, unsigned char *data, unsigned char len) 
+{
+    s32 dummy;
+    if( mc32x0_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+       
+        dummy = i2c_master_send(mc32x0_client, (char*)&reg_addr, 1);
+        if(dummy < 0)
+            return -1;
+        dummy = i2c_master_recv(mc32x0_client, (char*)data, len);
+        if(dummy < 0)
+            return -1;
+        
+    
+    return 0;
+}
+#endif
+#if 0
+static int mc32x0_power_on(void)
+{
+    if(mc32x0_regulator_name[0] != '\0') {        
+        // request regulator
+        mc32x0_regulator = regulator_get(NULL, mc32x0_regulator_name);
+        if (IS_ERR(mc32x0_regulator)) {
+            printk(KERN_ERR "mc32x0 get regulator failed\n");
+            return -1;
+        }
+        
+        if (regulator_set_voltage(mc32x0_regulator, mc32x0_voltage, mc32x0_voltage)) {
+            printk(KERN_ERR "mc32x0 set regulator voltage failed\n");
+            regulator_put(mc32x0_regulator);
+            return -1;
+        }
+        
+        regulator_enable(mc32x0_regulator);
+        msleep(20);
+        
+    #ifdef MC32X0_DEBUG
+        printk(KERN_INFO "%s\n",__FUNCTION__);
+    #endif
+    }
+
+    return 0;
+}
+
+static int mc32x0_power_off(void)
+{
+    if(mc32x0_regulator != NULL) {
+        // save current voltage
+        mc32x0_voltage = regulator_get_voltage(mc32x0_regulator);
+        
+        regulator_disable(mc32x0_regulator);    
+        
+        // release regulator
+        regulator_put(mc32x0_regulator);
+        
+    #ifdef MC32X0_DEBUG
+        printk(KERN_INFO "%s\n",__FUNCTION__);
+    #endif
+    }
+    
+    return 0;
+}
+#endif
+static int mc32x0_read_file(char *path, char *buf, int size)
+{
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+static int mc32x0_load_user_calibration(void)
+{
+    char buffer[64];
+    int ret = 0;
+    int data[9];
+    unsigned char offset[9];
+    int idx;
+    
+    // only calibrate once
+    if (mc32x0_calib_inited) {
+        goto usr_calib_end;
+    } else {
+        mc32x0_calib_inited = 1;
+    }
+
+    ret = mc32x0_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d %d %d %d %d %d %d", &data[0], &data[1], &data[2],
+                                &data[3], &data[4], &data[5], &data[6], &data[7], &data[8]);
+                                
+    for (idx = 0; idx < sizeof(offset); idx ++) {
+        offset[idx] = (unsigned char) data[idx];
+    }
+    
+    if (mc32x0_set_offset(offset, sizeof(offset)) < 0) {
+        printk(KERN_ERR"set offset fail\n");
+        goto usr_calib_end;
+    }
+    
+    printk(KERN_INFO "load user calibration finished\n");
+    
+usr_calib_end:
+    return ret;
+}
+
+static int mc32x0_axis_remap(mc32x0acc_t *acc)
+{
+    s16 swap;
+    int position = atomic_read(&mc32x0_position);
+
+    switch (abs(position)) {
+        case 1:
+            break;
+        case 2:
+            swap = acc->x;
+            acc->x = acc->y;
+            acc->y = -swap; 
+            break;
+        case 3:
+            acc->x = -(acc->x);
+            acc->y = -(acc->y);
+            break;
+        case 4:
+            swap = acc->x;
+            acc->x = -acc->y;
+            acc->y = swap;
+            break;
+    }
+    
+    if (position < 0) {
+        acc->z = -(acc->z);
+        acc->x = -(acc->x);
+    }
+    
+    return 0;
+}
+
+#if MC32X0_HRTIMER
+enum hrtimer_restart mc32x0_hrtimer_callback( struct hrtimer *timer )  
+{  
+    int wq_delay = atomic_read(&mc32x0_delay) - 3;
+
+    queue_delayed_work(wq, &mc32x0_work, msecs_to_jiffies(0));
+    hrtimer_forward_now(&hr_timer, ktime_set(0, wq_delay * 1000000));
+    
+    return HRTIMER_RESTART;
+}
+#endif
+
+static void mc32x0_work_func(struct work_struct *work)
+{
+    mc32x0acc_t acc;
+	int wq_delay = atomic_read(&mc32x0_delay);
+    unsigned long delay = msecs_to_jiffies(atomic_read(&mc32x0_delay));
+
+    mc32x0_load_user_calibration();
+    
+    mc32x0_read_accel_xyz(&acc);
+    mc32x0_axis_remap(&acc);
+
+    input_report_abs(mc32x0_idev, ABS_X, acc.x);
+    input_report_abs(mc32x0_idev, ABS_Y, acc.y);
+    input_report_abs(mc32x0_idev, ABS_Z, acc.z);
+    input_sync(mc32x0_idev);
+
+	
+#if (MC32X0_HRTIMER == 0)
+    queue_delayed_work(wq,&mc32x0_work, msecs_to_jiffies(wq_delay - 3));
+#endif	
+}
+
+static int mc32x0_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+    struct i2c_adapter *adapter = client->adapter;
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n", __FUNCTION__);
+#endif
+    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+        return -ENODEV;
+
+    strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+
+    return 0;
+}
+
+static int mc32x0_probe(struct i2c_client *client,
+             const struct i2c_device_id *id)
+{
+        struct mc32x0_data *data;
+        int cfg_position;
+        int err = 0;
+        int tempvalue;
+        int cfg_calibration[3];
+        mc32x0acc_t acc;
+        char const* buf;
+		long int temp;
+    
+#ifdef MC32X0_DEBUG
+        printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+    
+        if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+        {
+            printk(KERN_INFO "i2c_check_functionality error\n");
+            goto exit;
+        }
+    
+        /* OK. For now, we presume we have a valid client. We now create the
+           client structure, even though we cannot fill it completely yet. */
+        if (!(data = kmalloc(sizeof(struct mc32x0_data), GFP_KERNEL)))
+        {
+            err = -ENOMEM;
+            printk(KERN_INFO "kmalloc error\n");
+            goto exit;
+        }
+        memset(data, 0, sizeof(struct mc32x0_data));
+    
+        i2c_set_clientdata(client, data);
+        
+        /* read chip id */
+        tempvalue = i2c_smbus_read_byte_data(client, MC32X0_CHIP_ID);
+
+        if((tempvalue&0x00FF) == 0x0019)
+        {
+            printk(KERN_INFO "mCube Device detected!\nMC32X0 registered I2C driver!\n");
+            mc32x0_client = client;
+        }
+        else
+        {
+            printk(KERN_INFO "mCube Device not found, i2c error %d \n", tempvalue);
+            
+            data = i2c_get_clientdata(client);
+    
+            mc32x0_client = NULL;
+            err = -1;
+            goto exit_kfree;
+        }
+#if CFG_GSENSOR_USE_CONFIG > 0
+    err = of_property_read_string(client->dev.of_node, "position", &buf);
+    if (err != 0) {
+      printk(KERN_ERR"get position fail\n");
+    }
+    err = strict_strtol(buf, 10, &temp);  
+    cfg_position = (int)temp;
+
+#else
+    cfg_position = -3;
+#endif
+
+        atomic_set(&mc32x0_position, cfg_position);
+        atomic_set(&mc32x0_delay, MC32X0_POLL_INTERVAL);
+        atomic_set(&mc32x0_enable, 0); 
+        atomic_set(&mc32x0_fuzz, FUZZ); 
+
+#if MC32X0_HRTIMER
+    hrtimer_init(&hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    hr_timer.function = mc32x0_hrtimer_callback; 
+#endif	
+		wq = create_singlethread_workqueue( "mc32x0_wq" );	
+        INIT_DELAYED_WORK(&mc32x0_work, mc32x0_work_func);
+    
+        /*input poll device register */
+        mc32x0_idev = input_allocate_device();
+        if (!mc32x0_idev) {
+            printk(KERN_ERR"alloc poll device failed!\n");
+            goto exit_kfree;
+        }
+
+        mc32x0_idev->name = SENSOR_NAME;
+        mc32x0_idev->id.bustype = BUS_I2C;
+//        mc32x0_idev->dev.parent = &client->dev;
+        
+        input_set_capability(mc32x0_idev, EV_ABS, ABS_MISC);
+        input_set_abs_params(mc32x0_idev, ABS_X, ABSMIN, ABSMAX, FUZZ, 0);
+        input_set_abs_params(mc32x0_idev, ABS_Y, ABSMIN, ABSMAX, FUZZ, 0);
+        input_set_abs_params(mc32x0_idev, ABS_Z, ABSMIN, ABSMAX, FUZZ, 0);
+
+        err = input_register_device(mc32x0_idev);
+        if (err) {
+            printk(KERN_ERR "mc32x0 input register failed\n");
+            goto error_register;
+        }
+  
+        err = sysfs_create_group(&mc32x0_idev->dev.kobj, &mc32x0_group);
+        if (err) {
+            printk(KERN_ERR "mc32x0 create sysfs group failed\n");
+            goto error_register;
+        }
+  
+#ifdef CONFIG_HAS_EARLYSUSPEND
+        mc32x0_es_handler.suspend = mc32x0_early_suspend;
+        mc32x0_es_handler.resume = mc32x0_early_resume;
+        register_early_suspend(&mc32x0_es_handler);
+#endif
+
+        printk(KERN_INFO "mc32x0 device create ok: %s\n", SENSOR_NAME);
+        
+        data->mc32x0.bus_write = mc32x0_i2c_write;
+        data->mc32x0.bus_read = mc32x0_i2c_read;
+        mcube_mc32x0_init(&(data->mc32x0));
+        
+        mc32x0_set_image();    
+        
+        // save default offset & gain
+        mc32x0_get_offset(mc32x0_calib_default, sizeof(mc32x0_calib_default));
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+        //get dts configures
+        err = of_property_read_u32_array(client->dev.of_node, "calibration_table", cfg_calibration, 3);
+        if (err != 0) {
+            printk(KERN_ERR"get calibration fail\n");
+            memset(cfg_calibration, 0, sizeof(cfg_calibration));
+        }
+#else
+        memset(cfg_calibration, 0, sizeof(cfg_calibration));
+#endif    
+
+        acc.x = (unsigned char) cfg_calibration[0];
+        acc.y = (unsigned char) cfg_calibration[1];
+        acc.z = (unsigned char) cfg_calibration[2];
+
+        // calibration from xml config
+        mc32x0_calibration_offset(&acc);
+
+        return 0;
+        
+error_register:
+        input_unregister_device(mc32x0_idev);
+exit_kfree:
+        kfree(data);
+ exit:
+        return err;
+}
+
+
+
+static int mc32x0_remove(struct i2c_client *client)
+{
+    struct mc32x0_data *data;
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    unregister_early_suspend(&mc32x0_es_handler);
+#endif
+
+    mc32x0_do_enable(&client->dev, 0);
+	flush_workqueue(wq);
+    destroy_workqueue(wq);
+
+    sysfs_remove_group(&client->dev.kobj, &mc32x0_group);
+
+    data = i2c_get_clientdata(client);
+    mc32x0_client = NULL;
+    if (mc32x0_idev) 
+    {
+        printk(KERN_INFO "remove input device\n");
+        input_unregister_device(mc32x0_idev);
+        input_free_device(mc32x0_idev);
+        mc32x0_idev = NULL;
+    }
+    kfree(data);
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int mc32x0_suspend(struct device *dev)
+{    
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+
+    // save offset 
+    mc32x0_get_offset(mc32x0_offset_saved, sizeof(mc32x0_offset_saved));      
+    
+    mc32x0_do_enable(dev, 0);      
+    //mc32x0_power_off();
+    
+    return 0;
+}
+
+static int mc32x0_resume(struct device *dev)
+{
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+
+    //power on init regs    
+    //mc32x0_power_on();
+    mc32x0_set_image();     
+    mc32x0_do_enable(dev, atomic_read(&mc32x0_enable));
+    
+    // restore offset 
+    mc32x0_set_offset(mc32x0_offset_saved, sizeof(mc32x0_offset_saved));        
+    
+    return 0;
+}
+#else
+
+#define mc32x0_suspend NULL
+#define mc32x0_resume NULL
+
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mc32x0_early_suspend(struct early_suspend *handler)
+{
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+    // sensor hal will disable when early suspend
+}
+
+static void mc32x0_early_resume(struct early_suspend *handler)
+{ 
+#ifdef MC32X0_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+    // sensor hal will enable when early resume
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(mc32x0_pm_ops, mc32x0_suspend, mc32x0_resume);
+
+//static unsigned short normal_i2c[] = { MC32X0_I2C_ADDR, I2C_CLIENT_END};
+
+static const struct i2c_device_id mc32x0_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, mc32x0_id);
+
+static struct of_device_id mc323x_of_match[] = {
+	{ .compatible = "mc323x" },
+	{ }
+};
+
+static struct i2c_driver mc32x0_driver = {    
+    .driver = {
+        .owner    = THIS_MODULE,    
+        .name    = SENSOR_NAME,
+        .pm    = &mc32x0_pm_ops,
+        .of_match_table	= of_match_ptr(mc323x_of_match),
+    },
+    .class        = I2C_CLASS_HWMON,
+    .id_table    = mc32x0_id,
+//    .address_list    = normal_i2c,
+    .probe        = mc32x0_probe,
+    .remove        = mc32x0_remove,
+    .detect        = mc32x0_detect,
+};
+
+#if 0
+static struct i2c_board_info mc32x0_board_info={
+    .type = SENSOR_NAME, 
+    .addr = MC32X0_I2C_ADDR,
+};
+#endif
+static int __init MC32X0_init(void)
+{
+    printk(KERN_ERR "MC32X0 init\n");    
+    return i2c_add_driver(&mc32x0_driver);
+}
+
+static void __exit MC32X0_exit(void)
+{
+    i2c_del_driver(&mc32x0_driver);
+    printk(KERN_ERR "MC32X0 exit\n");
+}
+
+MODULE_DESCRIPTION("MC32X0 driver");
+MODULE_LICENSE("GPL");
+
+module_init(MC32X0_init);
+module_exit(MC32X0_exit);
diff --git a/drivers/input/misc/gsensor/mc3236.c b/drivers/input/misc/gsensor/mc3236.c
new file mode 100755
index 0000000..87b71a3
--- /dev/null
+++ b/drivers/input/misc/gsensor/mc3236.c
@@ -0,0 +1,1563 @@
+/*
+ * Copyright (C) 2011 MCUBE, Inc.
+ *
+ * Initial Code:
+ */
+
+
+/*! \file mc3236.c
+    \brief This file contains all function implementations for the mc3236 in linux
+    
+    Details.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <asm/uaccess.h>
+#include <linux/unistd.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/input-polldev.h>
+#include <linux/regulator/consumer.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/of.h>
+#include <linux/of_i2c.h>
+#include <linux/of_gpio.h>
+//#include "gsensor_common.h"
+
+/* ----------------------------------------------------------------------------------------------------*/
+
+#define mc3236_WR_FUNC_PTR char (* bus_write)(unsigned char, unsigned char *, unsigned char)
+
+#define mc3236_BUS_WRITE_FUNC(dev_addr, reg_addr, reg_data, wr_len)\
+           bus_write(reg_addr, reg_data, wr_len)
+
+#define mc3236_RD_FUNC_PTR char (* bus_read)( unsigned char, unsigned char *, unsigned char)
+
+#define mc3236_BUS_READ_FUNC(dev_addr, reg_addr, reg_data, r_len)\
+           bus_read(reg_addr, reg_data, r_len)
+
+#define GET_REAL_VALUE(rv, bn) \
+    ((rv & (0x01 << (bn - 1))) ? (- (rv & ~(0xffff << (bn - 1)))) : (rv & ~(0xffff << (bn - 1))))
+
+
+/*******mc3236 define this**********/
+
+//#define MCUBE_1_5G_8BIT
+#define MCUBE_2G_8BIT
+
+#define SENSOR_NAME "mc3236"
+
+/* mc3236 Data Range  */
+#if defined(MCUBE_1_5G_8BIT)
+    #define ABSMIN                -128
+    #define ABSMAX                127
+    #define FUZZ                     0
+    #define LSG                  86
+#elif defined(MCUBE_2G_10BIT) 
+    #define ABSMIN                -512
+    #define ABSMAX                511
+    #define FUZZ                     0
+    #define LSG                  256
+#elif defined(MCUBE_8G_14BIT) 
+    #define ABSMIN                -8192
+    #define ABSMAX                8191
+    #define FUZZ                     0
+    #define LSG                  1024
+#elif  defined(MCUBE_2G_8BIT	)
+    #define ABSMIN                -128
+    #define ABSMAX                127
+    #define FUZZ                     0
+    #define LSG                  64
+#else   // default: 8bit
+    #define ABSMIN                -128
+    #define ABSMAX                127    
+    #define FUZZ                     0
+    #define LSG                  86
+#endif
+
+/* mc3236 I2C Address  */
+#define mc3236_I2C_ADDR        0x4c  // 0x98 >> 1     //0x6C
+
+/*  mc3236 API error codes  */
+#define E_NULL_PTR        (char)-127
+
+/* register definitions     */
+#define mc3236_XOUT_REG                        0x00
+#define mc3236_YOUT_REG                        0x01
+#define mc3236_ZOUT_REG                        0x02
+#define mc3236_Tilt_Status_REG                0x03
+#define mc3236_Sampling_Rate_Status_REG        0x04
+#define mc3236_Sleep_Count_REG                0x05
+#define mc3236_Interrupt_Enable_REG            0x06
+#define mc3236_Mode_Feature_REG                0x07
+#define mc3236_Sample_Rate_REG                0x08
+#define mc3236_Tap_Detection_Enable_REG        0x09
+#define mc3236_TAP_Dwell_Reject_REG            0x0a
+#define mc3236_DROP_Control_Register_REG    0x0b
+#define mc3236_SHAKE_Debounce_REG            0x0c
+#define mc3236_XOUT_EX_L_REG                0x0d
+#define mc3236_XOUT_EX_H_REG                0x0e
+#define mc3236_YOUT_EX_L_REG                0x0f
+#define mc3236_YOUT_EX_H_REG                0x10
+#define mc3236_ZOUT_EX_L_REG                0x11
+#define mc3236_ZOUT_EX_H_REG                0x12
+#define mc3236_CHIP_ID                        0x18
+#define mc3236_RANGE_Control_REG            0x20
+#define mc3236_SHAKE_Threshold_REG            0x2B
+#define mc3236_UD_Z_TH_REG                    0x2C
+#define mc3236_UD_X_TH_REG                    0x2D
+#define mc3236_RL_Z_TH_REG                    0x2E
+#define mc3236_RL_Y_TH_REG                    0x2F
+#define mc3236_FB_Z_TH_REG                    0x30
+#define mc3236_DROP_Threshold_REG            0x31
+#define mc3236_TAP_Threshold_REG            0x32
+#define mc3236_REG_PRODUCT_CODE            		0x3B
+
+/***********************************************
+ *** PRODUCT ID
+ ***********************************************/
+#define mc3236_PCODE_3210     	0x90
+#define mc3236_PCODE_3230     	0x19
+#define mc3236_PCODE_3250     	0x88
+#define mc3236_PCODE_3410     	0xA8
+#define mc3236_PCODE_3410N   0xB8
+#define mc3236_PCODE_3430     	0x29
+#define mc3236_PCODE_3430N   0x39
+#define mc3236_PCODE_3510B   0x40
+#define mc3236_PCODE_3530B   0x30
+#define mc3236_PCODE_3510C   0x10//MC3216,MC3256,MC3413
+#define mc3236_PCODE_3530C   0x60//MC3236,MC3433
+
+#define MCUBE_8BIT    	0x01		//mc3236_LOW_END
+#define MCUBE_14BIT     	0x02		//mc3236_HIGH_END
+
+static unsigned char  is_new_mc34x0 = 0;
+static unsigned char  is_mc3250 = 0;
+static unsigned char  is_mc35xx = 0;
+static unsigned char  Sensor_Accuracy = 0;
+static unsigned char s_bPCODE      = 0x00;
+
+
+/** mc3236 acceleration data 
+    \brief Structure containing acceleration values for x,y and z-axis in signed short
+
+*/
+
+typedef struct  {
+        short x, /**< holds x-axis acceleration data sign extended. Range -512 to 511. */
+              y, /**< holds y-axis acceleration data sign extended. Range -512 to 511. */
+              z; /**< holds z-axis acceleration data sign extended. Range -512 to 511. */
+} mc3236acc_t;
+
+/* RANGE */
+#define mc3236_RANGE__POS                2
+#define mc3236_RANGE__LEN                2
+#define mc3236_RANGE__MSK                0x0c    
+#define mc3236_RANGE__REG                mc3236_RANGE_Control_REG
+
+/* MODE */
+#define mc3236_MODE__POS                0
+#define mc3236_MODE__LEN                2
+#define mc3236_MODE__MSK                0x03    
+#define mc3236_MODE__REG                mc3236_Mode_Feature_REG
+
+#define mc3236_MODE_DEF                 0x43
+
+/* BANDWIDTH */
+#define mc3236_BANDWIDTH__POS            4
+#define mc3236_BANDWIDTH__LEN            3
+#define mc3236_BANDWIDTH__MSK            0x70    
+#define mc3236_BANDWIDTH__REG            mc3236_RANGE_Control_REG
+
+
+#define mc3236_GET_BITSLICE(regvar, bitname)\
+            (regvar & bitname##__MSK) >> bitname##__POS
+
+
+#define mc3236_SET_BITSLICE(regvar, bitname, val)\
+          (regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK)  
+
+
+#define mc3236_RANGE_2G                    0
+#define mc3236_RANGE_4G                    1
+#define mc3236_RANGE_8G                    2
+
+#define mc3236_WAKE                        1
+#define mc3236_SNIFF                    2
+#define mc3236_STANDBY                    3
+
+
+#define mc3236_LOW_PASS_512HZ            0
+#define mc3236_LOW_PASS_256HZ            1
+#define mc3236_LOW_PASS_128HZ            2
+#define mc3236_LOW_PASS_64HZ            3
+#define mc3236_LOW_PASS_32HZ            4
+#define mc3236_LOW_PASS_16HZ            5
+#define mc3236_LOW_PASS_8HZ                6
+
+
+typedef struct {    
+    unsigned char mode;        /**< save current mc3236 operation mode */
+    unsigned char chip_id;    /**< save mc3236's chip id which has to be 0x00/0x01 after calling mc3236_init() */
+    unsigned char dev_addr;   /**< initializes mc3236's I2C device address 0x4c */
+    mc3236_WR_FUNC_PTR;          /**< function pointer to the SPI/I2C write function */
+    mc3236_RD_FUNC_PTR;          /**< function pointer to the SPI/I2C read function */
+} mc3236_t;
+
+//------------------------------------------------------------------------------------------------------------------------
+
+mc3236_t *p_mc3236;                /**< pointer to mc3236 device structure  */
+
+int mcube_mc3236_init(mc3236_t *mc3236) 
+{
+	int comres=0;
+	unsigned char data;
+    static    unsigned short        mc3236_i2c_auto_probe_addr[] = { 0x4C,0x6C,0x6E};
+    int              _nProbeAddrCount = (sizeof(mc3236_i2c_auto_probe_addr) / sizeof(mc3236_i2c_auto_probe_addr[0]));
+    int              _nCount = 0;
+    
+     for (_nCount = 0; _nCount < _nProbeAddrCount; _nCount++)
+    {   
+			p_mc3236 = mc3236;                                                                                /* assign mc3236 ptr */
+			p_mc3236->dev_addr = mc3236_i2c_auto_probe_addr[_nCount];                                                            /* preset  I2C_addr */
+			comres += p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_REG_PRODUCT_CODE, &data, 1);            /* read Chip Id */
+		
+			p_mc3236->chip_id = data;
+			s_bPCODE = data;
+		
+			if((data == mc3236_PCODE_3230)||(data == mc3236_PCODE_3430)
+				||(data == mc3236_PCODE_3430N)||(data == mc3236_PCODE_3530B)
+				||((data & 0xF1) == mc3236_PCODE_3530C))
+			{
+				Sensor_Accuracy = MCUBE_8BIT;	//8bit
+				break;
+			}
+			else if((data == mc3236_PCODE_3210)||(data == mc3236_PCODE_3410)
+				||(data == mc3236_PCODE_3250)||(data == mc3236_PCODE_3410N)
+				||(data == mc3236_PCODE_3510B)||((data & 0xF1) == mc3236_PCODE_3510C))
+			{
+				Sensor_Accuracy = MCUBE_14BIT;		//14bit
+				break;
+			}
+			else
+			{
+				Sensor_Accuracy = 0;
+			}
+		}
+	if (data == mc3236_PCODE_3250)
+       		 is_mc3250 = 1;
+
+	if ((data == mc3236_PCODE_3430N)||(data == mc3236_PCODE_3410N))
+		is_new_mc34x0 = 1;
+
+	if((mc3236_PCODE_3510B == data) || (mc3236_PCODE_3510C == (data & 0xF1))
+		||(data == mc3236_PCODE_3530B)||((data & 0xF1) == mc3236_PCODE_3530C))
+		is_mc35xx = 1;
+
+
+	return comres;
+}
+
+int mc3236_set_image (void) 
+{
+	int comres;
+	unsigned char data;
+	//unsigned char data = 0;
+	if (p_mc3236==0)
+		return E_NULL_PTR;
+
+	if(MCUBE_14BIT == Sensor_Accuracy)
+	{
+		data = 0x43;
+		comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Mode_Feature_REG, &data, 1 );
+		data = 0x00;
+    		comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Sleep_Count_REG, &data, 1 );
+
+		data = 0x00;
+		if (is_mc35xx)
+		{	
+			data = 0x0A;
+		}	
+		
+	  	comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Sample_Rate_REG, &data, 1 );    
+
+		data = 0x3F;
+		if ((mc3236_PCODE_3510B == s_bPCODE) || (mc3236_PCODE_3510C == (s_bPCODE & 0xF1)))
+			data = 0x25;
+		else if ((mc3236_PCODE_3530B == s_bPCODE) || (mc3236_PCODE_3530C == (s_bPCODE & 0xF1)))
+			data = 0x02;
+		
+	  	comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_RANGE_Control_REG, &data, 1 );
+
+		data = 0x00;
+    		comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Tap_Detection_Enable_REG, &data, 1 );
+		data = 0x00;
+    		comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Interrupt_Enable_REG, &data, 1 );
+
+	}
+	else if(MCUBE_8BIT == Sensor_Accuracy)
+	{		
+		data = 0x43;
+		comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Mode_Feature_REG, &data, 1 );
+		data = 0x00;
+    		comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Sleep_Count_REG, &data, 1 );
+
+		data = 0x00;
+		if (is_mc35xx)
+		{	
+			data = 0x0A;
+		}
+		
+	  	comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Sample_Rate_REG, &data, 1 );    
+
+		data = 0x32;
+		if ((mc3236_PCODE_3510B == s_bPCODE) || (mc3236_PCODE_3510C == (s_bPCODE & 0xF1)))
+			data = 0x25;
+		else if ((mc3236_PCODE_3530B == s_bPCODE) || (mc3236_PCODE_3530C == (s_bPCODE & 0xF1)))
+			data = 0x02;
+		
+	  	comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_RANGE_Control_REG, &data, 1 );
+		data = 0x00;
+    		comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Tap_Detection_Enable_REG, &data, 1 );
+		data = 0x00;
+    		comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Interrupt_Enable_REG, &data, 1 );
+
+	}
+
+	data = 0x41;
+	comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Mode_Feature_REG, &data, 1 );
+
+
+    return comres;
+}
+
+
+int mc3236_get_offset(unsigned char *offset, int len) 
+{    
+    int comres;
+    
+    if (p_mc3236==0)
+        return E_NULL_PTR;
+
+    comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, 0x21, offset, len);
+    
+    return comres;
+}    
+
+
+int mc3236_set_offset(unsigned char *offset, int len) 
+{
+    int comres;
+    unsigned char data;
+    
+    if (p_mc3236==0)
+        return E_NULL_PTR;
+
+    data = 0x43;
+    comres = p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Mode_Feature_REG, &data, 1); 
+    
+    comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, 0x21, offset, len);
+    
+    data = 0x41;
+    comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_Mode_Feature_REG, &data, 1);
+    
+    return comres;
+}
+
+
+int mc3236_set_range(char range) 
+{            
+   int comres = 0;
+   unsigned char data;
+
+   if (p_mc3236==0)
+        return E_NULL_PTR;
+
+   if (range<3) {    
+       comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_RANGE__REG, &data, 1);
+       data = mc3236_SET_BITSLICE(data, mc3236_RANGE, range);
+       comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_RANGE__REG, &data, 1);
+
+   }
+   return comres;
+
+}
+
+
+int mc3236_get_range(unsigned char *range) 
+{
+	int comres = 0;
+	unsigned char data;
+
+	if (p_mc3236==0)
+	    return E_NULL_PTR;
+	comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_RANGE__REG, &data, 1);
+	data = mc3236_GET_BITSLICE(data, mc3236_RANGE);
+
+	*range = data;
+
+	return comres;
+}
+
+
+
+int mc3236_set_mode(unsigned char mode) {
+    
+    int comres=0;
+    unsigned char data;
+
+    if (p_mc3236==0)
+        return E_NULL_PTR;
+
+    if (mode<4) {
+        data  = mc3236_MODE_DEF;
+        data  = mc3236_SET_BITSLICE(data, mc3236_MODE, mode);          
+        comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_MODE__REG, &data, 1 );
+
+          p_mc3236->mode = mode;
+    } 
+    return comres;
+}
+
+
+int mc3236_get_mode(unsigned char *mode) 
+{
+    if (p_mc3236==0)
+        return E_NULL_PTR;    
+        *mode =  p_mc3236->mode;
+      return 0;
+}
+
+int mc3236_set_bandwidth(char bw) 
+{
+	int comres = 0;
+	unsigned char data;
+
+	if (p_mc3236==0)
+	    return E_NULL_PTR;
+
+	if (bw<7) 
+	{
+		comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_BANDWIDTH__REG, &data, 1 );
+		data = mc3236_SET_BITSLICE(data, mc3236_BANDWIDTH, bw);
+		comres += p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, mc3236_BANDWIDTH__REG, &data, 1 );
+	}
+
+	return comres;
+}
+
+int mc3236_get_bandwidth(unsigned char *bw) 
+{
+	int comres = 1;
+	if (p_mc3236==0)
+		return E_NULL_PTR;
+
+	comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_BANDWIDTH__REG, bw, 1 );        
+
+	*bw = mc3236_GET_BITSLICE(*bw, mc3236_BANDWIDTH);
+
+	return comres;
+}
+
+
+int mc3236_read_accel_x(short *a_x) 
+{
+	int comres;
+	unsigned char data[2];
+
+
+	if (p_mc3236==0)
+		return E_NULL_PTR;
+
+	comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_XOUT_EX_L_REG, &data[0],2);
+
+	*a_x = ((short)data[0])|(((short)data[1])<<8);
+
+	return comres;
+}
+
+
+int mc3236_read_accel_y(short *a_y) 
+{
+	int comres;
+	unsigned char data[2];    
+
+
+	if (p_mc3236==0)
+		return E_NULL_PTR;
+
+	comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_YOUT_EX_L_REG, &data[0],2);
+
+	*a_y = ((short)data[0])|(((short)data[1])<<8);
+
+	return comres;
+}
+
+
+int mc3236_read_accel_z(short *a_z)
+{
+	int comres;
+	unsigned char data[2];    
+
+	if (p_mc3236==0)
+		return E_NULL_PTR;
+
+	comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_ZOUT_EX_L_REG, &data[0],2);
+
+	*a_z = ((short)data[0])|(((short)data[1])<<8);
+
+	return comres;
+}
+
+
+int mc3236_read_accel_xyz(mc3236acc_t * acc)
+{
+    int comres = 0;
+    unsigned char data[6];
+
+	if (p_mc3236==0)
+		return E_NULL_PTR;
+    
+	if(Sensor_Accuracy == MCUBE_14BIT)
+	{
+		comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_XOUT_EX_L_REG, &data[0],6);
+
+		acc->x = ((signed short)data[0])|(((signed short)data[1])<<8);
+		acc->y = ((signed short)data[2])|(((signed short)data[3])<<8);
+		acc->z = ((signed short)data[4])|(((signed short)data[5])<<8);
+	}
+	 else if(Sensor_Accuracy == MCUBE_8BIT)
+	 {
+	 	comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_XOUT_REG, &data[0],3);
+ 		acc->x = (signed char)data[0];
+                acc->y = (signed char)data[1];
+                acc->z = (signed char)data[2];
+	 }
+
+	if (is_mc3250)
+	{
+		s16    temp = 0;
+
+		temp = acc->x;
+		acc->x = acc->y;
+		acc->y = -temp;
+	}
+    
+    return comres;
+    
+}
+
+
+
+int mc3236_get_interrupt_status(unsigned char * ist) 
+{
+
+    int comres=0;    
+    if (p_mc3236==0)
+        return E_NULL_PTR;
+    comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, mc3236_Tilt_Status_REG, ist, 1);
+    return comres;
+}
+
+
+
+int mc3236_read_reg(unsigned char addr, unsigned char *data, unsigned char len)
+{
+
+    int comres;
+    if (p_mc3236==0)
+        return E_NULL_PTR;
+
+    comres = p_mc3236->mc3236_BUS_READ_FUNC(p_mc3236->dev_addr, addr, data, len);
+    return comres;
+
+}
+
+
+int mc3236_write_reg(unsigned char addr, unsigned char *data, unsigned char len) 
+{
+
+    int comres;
+
+    if (p_mc3236==0)
+        return E_NULL_PTR;
+
+    comres = p_mc3236->mc3236_BUS_WRITE_FUNC(p_mc3236->dev_addr, addr, data, len);
+
+    return comres;
+
+}
+
+//------------------------------------------------------------------------------------------------------------------------
+
+#define mc3236_IOC_MAGIC 'M'
+
+#define mc3236_SET_RANGE                _IOWR(mc3236_IOC_MAGIC,4, unsigned char)
+#define mc3236_GET_RANGE                _IOWR(mc3236_IOC_MAGIC,5, unsigned char)
+#define mc3236_SET_MODE                    _IOWR(mc3236_IOC_MAGIC,6, unsigned char)
+#define mc3236_GET_MODE                    _IOWR(mc3236_IOC_MAGIC,7, unsigned char)
+#define mc3236_SET_BANDWIDTH            _IOWR(mc3236_IOC_MAGIC,8, unsigned char)
+#define mc3236_GET_BANDWIDTH            _IOWR(mc3236_IOC_MAGIC,9, unsigned char)
+#define mc3236_READ_ACCEL_X                _IOWR(mc3236_IOC_MAGIC,10,short)
+#define mc3236_READ_ACCEL_Y                _IOWR(mc3236_IOC_MAGIC,11,short)
+#define mc3236_READ_ACCEL_Z                _IOWR(mc3236_IOC_MAGIC,12,short)
+#define mc3236_GET_INTERRUPT_STATUS        _IOWR(mc3236_IOC_MAGIC,13,unsigned char)
+#define mc3236_READ_ACCEL_XYZ            _IOWR(mc3236_IOC_MAGIC,14,short)
+
+#define mc3236_IOC_MAXNR                50
+
+#define mc3236_DEBUG                 1
+
+// configuration
+#define mc3236_POLL_INTERVAL        (100)
+#define mc3236_DEF_VOLTAGE          (3300000)
+
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  1
+
+// calibration file path
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+static struct input_dev *mc3236_idev;
+static struct i2c_client *mc3236_client = NULL;  
+static struct delayed_work mc3236_work;
+
+//static char mc3236_regulator_name[16];
+//static struct regulator *mc3236_regulator = NULL;
+//static int mc3236_voltage = mc3236_DEF_VOLTAGE;
+
+static atomic_t mc3236_delay = {0};
+static atomic_t mc3236_enable = {0};
+static atomic_t mc3236_position = {0};
+static atomic_t mc3236_fuzz = {0};
+
+static int mc3236_calib_inited = 0;
+static unsigned char mc3236_calib_default[9];
+static unsigned char mc3236_offset_saved[9];
+
+struct mc3236_data{
+    mc3236_t mc3236;
+};
+
+static char mc3236_i2c_write(unsigned char reg_addr, unsigned char *data, unsigned char len);
+static char mc3236_i2c_read(unsigned char reg_addr, unsigned char *data, unsigned char len);
+static void mc3236_i2c_delay(unsigned int msec);
+static int mc3236_axis_remap(mc3236acc_t *acc);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend mc3236_es_handler;
+static void mc3236_early_suspend(struct early_suspend *handler);
+static void mc3236_early_resume(struct early_suspend *handler);
+#endif
+
+static ssize_t mc3236_delay_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc3236_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc3236_enable_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc3236_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc3236_fuzz_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc3236_fuzz_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc3236_regs_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc3236_regs_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc3236_value_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc3236_board_position_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc3236_board_position_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc3236_calibration_run_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc3236_calibration_reset_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t mc3236_calibration_value_show(struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t mc3236_calibration_value_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc3236_delay_show, mc3236_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc3236_enable_show, mc3236_enable_store);
+static DEVICE_ATTR(fuzz, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc3236_fuzz_show, mc3236_fuzz_store);
+static DEVICE_ATTR(regs, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc3236_regs_show, mc3236_regs_store);
+static DEVICE_ATTR(value, S_IRUGO, mc3236_value_show, NULL);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc3236_board_position_show, mc3236_board_position_store);
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP,
+        NULL, mc3236_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP,
+        NULL, mc3236_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, S_IRUGO|S_IWUSR|S_IWGRP,
+        mc3236_calibration_value_show,
+        mc3236_calibration_value_store);
+
+static struct attribute* mc3236_attrs[] =
+{
+	&dev_attr_delay.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_fuzz.attr,
+	&dev_attr_regs.attr,
+	&dev_attr_value.attr,
+	&dev_attr_board_position.attr,
+	&dev_attr_calibration_run.attr,
+	&dev_attr_calibration_reset.attr,
+	&dev_attr_calibration_value.attr,
+	NULL
+};
+
+static const struct attribute_group mc3236_group =
+{
+  .attrs = mc3236_attrs,
+};
+
+static ssize_t mc3236_delay_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", atomic_read(&mc3236_delay));
+}
+
+static ssize_t mc3236_delay_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+ 
+#ifdef mc3236_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    
+    atomic_set(&mc3236_delay, (unsigned int) data);
+    return count;
+}
+
+
+static ssize_t mc3236_enable_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", atomic_read(&mc3236_enable));
+}
+
+static void mc3236_do_enable(struct device *dev, int enable)
+{
+    if (enable) {
+        mc3236_set_mode(mc3236_WAKE); 
+        schedule_delayed_work(&mc3236_work,
+            msecs_to_jiffies(atomic_read(&mc3236_delay)));
+    } else {
+        mc3236_set_mode(mc3236_STANDBY);  
+        cancel_delayed_work_sync(&mc3236_work);
+    }
+}
+
+static void mc3236_set_enable(struct device *dev, int enable)
+{
+    int pre_enable = atomic_read(&mc3236_enable);
+
+    if (enable != pre_enable) {
+        mc3236_do_enable(dev, enable);
+        atomic_set(&mc3236_enable, enable);        
+    }  
+}
+
+static ssize_t mc3236_enable_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{ 
+    unsigned long data;
+    int error;
+    
+#ifdef mc3236_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif   
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    
+    if ((data == 0) || (data == 1)) {
+        mc3236_set_enable(dev, data);
+    }
+
+    return count;
+}
+
+static ssize_t mc3236_fuzz_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+
+    data = atomic_read(&mc3236_fuzz);
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t mc3236_fuzz_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&mc3236_fuzz, (int) data);
+    
+    if(mc3236_idev != NULL) {
+        mc3236_idev->absinfo[ABS_X].fuzz = data;
+        mc3236_idev->absinfo[ABS_Y].fuzz = data;
+        mc3236_idev->absinfo[ABS_Z].fuzz = data;
+    }
+    
+    return count;
+}
+
+static ssize_t mc3236_regs_show(struct device *dev, 
+        struct device_attribute *attr, char *buf)
+{
+  int idx, len=0, result;
+  unsigned char regs[0x13];
+
+  result = mc3236_read_reg(0x0, regs, 0x13);
+  if(result != 0) 
+  {
+    printk(KERN_ERR "read reg error!\n");
+    return -1;
+  }
+
+  for(idx=0; idx<0x13; idx++)
+  {
+    len += sprintf(buf+len, "[0x%x]=0x%x\n", idx, regs[idx]);
+  }
+  
+  result = mc3236_read_reg(0x20, regs, 0x0a);
+  if(result != 0) 
+  {
+    printk(KERN_ERR "read reg error!\n");
+    return -1;
+  }
+
+  for(idx=0; idx<0x0a; idx++)
+  {
+    len += sprintf(buf+len, "[0x%x]=0x%x\n", 0x20+idx, regs[idx]);
+  }
+  return len;
+}
+
+static ssize_t mc3236_regs_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned int addr;
+    unsigned int data;
+    int error;
+    
+    sscanf(buf, "[0x%x]=0x%x", &addr, &data); 
+    
+    error = mc3236_write_reg((unsigned char)addr, (unsigned char *)&data, 1);
+    if(error) 
+    {
+        printk(KERN_INFO "write reg error!\n");
+        return error;
+    }
+    
+    return count;
+}
+
+static ssize_t mc3236_value_show(struct device *dev, 
+        struct device_attribute *attr, char *buf)
+{
+  int result;
+  mc3236acc_t acc;
+
+  result = mc3236_read_accel_xyz(&acc);
+  if(result != 0) 
+  {
+    printk(KERN_ERR "read accel xyz error!\n");
+    return -1;
+  }
+  
+  mc3236_axis_remap(&acc);
+  
+  return sprintf(buf, "%d,%d,%d\n", acc.x, acc.y, acc.z);
+}
+
+static ssize_t mc3236_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+
+    data = atomic_read(&mc3236_position);
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t mc3236_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&mc3236_position, (int) data);
+
+    return count;
+}
+
+static int mc3236_calibration_offset(mc3236acc_t *acc)
+{    
+    int result;
+    unsigned char buf[9];
+    short tmp, x_gain, y_gain, z_gain ;
+    int x_off, y_off, z_off;
+
+	u8  bMsbFilter       = 0x3F;
+	s16 wSignBitMask     = 0x2000;
+	s16 wSignPaddingBits = 0xC000;
+	s32 dwRangePosLimit  = 0x1FFF;
+	s32 dwRangeNegLimit  = -0x2000;
+
+	if (is_mc35xx)
+	{
+	    bMsbFilter       = 0x7F;
+	    wSignBitMask     = 0x4000;
+	    wSignPaddingBits = 0x8000;
+	    dwRangePosLimit  = 0x3FFF;
+	    dwRangeNegLimit  = -0x4000;
+	}
+
+	//read register 0x21~0x29
+	result = mc3236_read_reg(0x21, buf, 9);
+    
+	 // get x,y,z offset
+	tmp = ((buf[1] & bMsbFilter) << 8) + buf[0];
+	if (tmp & wSignBitMask)
+		tmp |= wSignPaddingBits;
+	x_off = tmp;
+					
+	tmp = ((buf[3] & bMsbFilter) << 8) + buf[2];
+	if (tmp & wSignBitMask)
+		tmp |= wSignPaddingBits;
+	y_off = tmp;
+					
+	tmp = ((buf[5] & bMsbFilter) << 8) + buf[4];
+	if (tmp & wSignBitMask)
+		tmp |= wSignPaddingBits;
+	z_off = tmp;
+                    
+    // get x,y,z gain
+    x_gain = ((buf[1] >> 7) << 8) + buf[6];
+    y_gain = ((buf[3] >> 7) << 8) + buf[7];
+    z_gain = ((buf[5] >> 7) << 8) + buf[8];
+                                
+    // prepare new offset
+    x_off = x_off + 16 * acc->x * 256 * 128 / 3 / LSG / (40 + x_gain);
+    y_off = y_off + 16 * acc->y * 256 * 128 / 3 / LSG / (40 + y_gain);
+    z_off = z_off + 16 * acc->z * 256 * 128 / 3 / LSG / (40 + z_gain);
+    
+    // write offset to register 0x21~0x26
+    buf[0] = 0x43;
+    result += mc3236_write_reg(0x07, buf, 1);
+    
+    buf[0] = x_off & 0xff;
+    buf[1] = ((x_off >> 8) & bMsbFilter) | (x_gain & 0x0100 ? 0x80 : 0);
+    buf[2] = y_off & 0xff;
+    buf[3] = ((y_off >> 8) & bMsbFilter) | (y_gain & 0x0100 ? 0x80 : 0);
+    buf[4] = z_off & 0xff;
+    buf[5] = ((z_off >> 8) & bMsbFilter) | (z_gain & 0x0100 ? 0x80 : 0);    
+    result += mc3236_write_reg(0x21, buf, 6);
+    
+    buf[0] = 0x41;
+    result += mc3236_write_reg(0x07, buf, 1);
+    
+    return result;
+}
+
+static ssize_t mc3236_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int ret;
+    int cfg_calibration[9];
+    unsigned char offset[9];
+    int idx;
+    mc3236acc_t acc;
+    
+    ret = mc3236_read_accel_xyz(&acc);
+    if(ret != 0) 
+    {
+        printk(KERN_ERR "read accel xyz error!\n");
+        return -1;
+    }
+
+    // get diff
+    acc.x = 0 - acc.x;
+    acc.y = 0 - acc.y;
+    if (atomic_read(&mc3236_position) > 0) {
+        acc.z = LSG - acc.z;
+    } else {
+        acc.z = (-LSG) - acc.z;
+    }
+    
+    mc3236_calibration_offset(&acc);
+
+    if (mc3236_get_offset(offset, sizeof(offset)) < 0)
+        return sprintf((char*)buf, "Read error\n");
+    
+    for (idx = 0; idx < sizeof(offset); idx++)
+    {
+        cfg_calibration[idx] = offset[idx];
+    }
+    
+    printk(KERN_INFO "run fast calibration finished\n");
+    return count;
+}
+
+static ssize_t mc3236_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    //int ret;
+    int cfg_calibration[9];
+    int idx;
+    
+    mc3236_set_offset(mc3236_calib_default, sizeof(mc3236_calib_default));    
+    
+    for (idx = 0; idx < sizeof(mc3236_calib_default); idx++)
+    {
+        cfg_calibration[idx] = mc3236_calib_default[idx];
+    }
+
+    printk(KERN_INFO "reset fast calibration finished\n");
+    return count;
+}
+
+static ssize_t mc3236_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char offset[9];
+
+    if (mc3236_get_offset(offset, sizeof(offset)) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d %d %d %d %d %d %d %d %d\n", offset[0], offset[1], offset[2], 
+                                offset[3], offset[4], offset[5], offset[6], offset[7], offset[8]);
+}
+
+static ssize_t mc3236_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[9];
+    unsigned char offset[9];
+    int idx;
+
+    sscanf(buf, "%d %d %d %d %d %d %d %d %d", &data[0], &data[1], &data[2],
+                    &data[3], &data[4], &data[5], &data[6], &data[7], &data[8]);
+                    
+    for (idx = 0; idx < sizeof(offset); idx++)
+    {
+        offset[idx] = (unsigned char) data[idx];
+    }
+    
+    if (mc3236_set_offset(offset, sizeof(offset)) < 0)
+        return -EINVAL;
+
+    printk(KERN_INFO "set fast calibration finished\n");
+    return count;
+}
+
+/*    i2c delay routine for eeprom    */
+static inline void mc3236_i2c_delay(unsigned int msec)
+{
+    mdelay(msec);
+}
+
+
+/*    i2c write routine for mc3236    */
+static inline char mc3236_i2c_write(unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    if( mc3236_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+        dummy = i2c_smbus_write_i2c_block_data(mc3236_client, reg_addr, len, data);
+        if(dummy < 0)
+            return -1;        
+            
+    return 0;
+}
+
+/*    i2c read routine for mc3236    */
+static inline char mc3236_i2c_read(unsigned char reg_addr, unsigned char *data, unsigned char len) 
+{
+    s32 dummy;
+    if( mc3236_client == NULL )    /*    No global client pointer?    */
+        return -1;
+
+        dummy = i2c_smbus_read_i2c_block_data(mc3236_client, reg_addr, len, data);
+        if(dummy < 0)
+            return -1;        
+    
+    return 0;
+}
+#if 0
+static int mc3236_power_on(void)
+{
+    if(mc3236_regulator_name[0] != '\0') {        
+        // request regulator
+        mc3236_regulator = regulator_get(NULL, mc3236_regulator_name);
+        if (IS_ERR(mc3236_regulator)) {
+            printk(KERN_ERR "mc3236 get regulator failed\n");
+            return -1;
+        }
+        
+        if (regulator_set_voltage(mc3236_regulator, mc3236_voltage, mc3236_voltage)) {
+            printk(KERN_ERR "mc3236 set regulator voltage failed\n");
+            regulator_put(mc3236_regulator);
+            return -1;
+        }
+        
+        regulator_enable(mc3236_regulator);
+        msleep(20);
+        
+    #ifdef mc3236_DEBUG
+        printk(KERN_INFO "%s\n",__FUNCTION__);
+    #endif
+    }
+
+    return 0;
+}
+
+static int mc3236_power_off(void)
+{
+    if(mc3236_regulator != NULL) {
+        // save current voltage
+        mc3236_voltage = regulator_get_voltage(mc3236_regulator);
+        
+        regulator_disable(mc3236_regulator);    
+        
+        // release regulator
+        regulator_put(mc3236_regulator);
+        
+    #ifdef mc3236_DEBUG
+        printk(KERN_INFO "%s\n",__FUNCTION__);
+    #endif
+    }
+    
+    return 0;
+}
+#endif
+static int mc3236_read_file(char *path, char *buf, int size)
+{
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+static int mc3236_load_user_calibration(void)
+{
+    char buffer[64];
+    int ret = 0;
+    int data[9];
+    unsigned char offset[9];
+    int idx;
+    
+    // only calibrate once
+    if (mc3236_calib_inited) {
+        goto usr_calib_end;
+    } else {
+        mc3236_calib_inited = 1;
+    }
+
+    ret = mc3236_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d %d %d %d %d %d %d", &data[0], &data[1], &data[2],
+                                &data[3], &data[4], &data[5], &data[6], &data[7], &data[8]);
+                                
+    for (idx = 0; idx < sizeof(offset); idx ++) {
+        offset[idx] = (unsigned char) data[idx];
+    }
+    
+    if (mc3236_set_offset(offset, sizeof(offset)) < 0) {
+        printk(KERN_ERR"set offset fail\n");
+        goto usr_calib_end;
+    }
+    
+    printk(KERN_INFO "load user calibration finished\n");
+    
+usr_calib_end:
+    return ret;
+}
+
+static int mc3236_axis_remap(mc3236acc_t *acc)
+{
+    s16 swap;
+    int position = atomic_read(&mc3236_position);
+
+    switch (abs(position)) {
+        case 1:
+            break;
+        case 2:
+            swap = acc->x;
+            acc->x = acc->y;
+            acc->y = -swap; 
+            break;
+        case 3:
+            acc->x = -(acc->x);
+            acc->y = -(acc->y);
+            break;
+        case 4:
+            swap = acc->x;
+            acc->x = -acc->y;
+            acc->y = swap;
+            break;
+    }
+    
+    if (position < 0) {
+        acc->z = -(acc->z);
+        acc->x = -(acc->x);
+    }
+    
+    return 0;
+}
+
+static void mc3236_work_func(struct work_struct *work)
+{
+    mc3236acc_t acc;
+    unsigned long delay = msecs_to_jiffies(atomic_read(&mc3236_delay));
+
+    mc3236_load_user_calibration();
+    
+    mc3236_read_accel_xyz(&acc);
+    mc3236_axis_remap(&acc);
+    input_report_abs(mc3236_idev, ABS_X, acc.x);
+    input_report_abs(mc3236_idev, ABS_Y, acc.y);
+    input_report_abs(mc3236_idev, ABS_Z, acc.z);
+    input_sync(mc3236_idev);
+    
+    schedule_delayed_work(&mc3236_work, delay);
+}
+
+static int mc3236_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+    struct i2c_adapter *adapter = client->adapter;
+#ifdef mc3236_DEBUG
+    printk(KERN_INFO "%s\n", __FUNCTION__);
+#endif
+    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+        return -ENODEV;
+
+    strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+
+    return 0;
+}
+
+static int mc3236_probe(struct i2c_client *client,
+             const struct i2c_device_id *id)
+{
+        struct mc3236_data *data;
+        int cfg_position;
+        int err = 0;
+//        int tempvalue;
+        int cfg_calibration[3];
+        mc3236acc_t acc;
+//        unsigned char *regulator;
+        const char * buf;
+        long int temp;
+    
+#ifdef mc3236_DEBUG
+        printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+    
+        if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+        {
+            printk(KERN_INFO "i2c_check_functionality error\n");
+            goto exit;
+        }
+    
+        /* OK. For now, we presume we have a valid client. We now create the
+           client structure, even though we cannot fill it completely yet. */
+        if (!(data = kmalloc(sizeof(struct mc3236_data), GFP_KERNEL)))
+        {
+            err = -ENOMEM;
+            printk(KERN_INFO "kmalloc error\n");
+            goto exit;
+        }
+        memset(data, 0, sizeof(struct mc3236_data));
+    
+        i2c_set_clientdata(client, data);
+
+        mc3236_client = client;
+		
+#if CFG_GSENSOR_USE_CONFIG > 0
+        err = of_property_read_string(client->dev.of_node, "position", &buf);
+        if (err != 0) {
+            printk(KERN_ERR"get position fail\n");
+        }
+        err = strict_strtol(buf, 10, &temp);  
+        cfg_position = (int)temp;
+#else
+        cfg_position = -3;
+#endif
+
+        atomic_set(&mc3236_position, cfg_position);
+        atomic_set(&mc3236_delay, mc3236_POLL_INTERVAL);
+        atomic_set(&mc3236_enable, 0); 
+        atomic_set(&mc3236_fuzz, FUZZ);       
+        INIT_DELAYED_WORK(&mc3236_work, mc3236_work_func);
+    
+        /*input poll device register */
+        mc3236_idev = input_allocate_device();
+        if (!mc3236_idev) {
+            printk(KERN_ERR"alloc poll device failed!\n");
+            goto exit_kfree;
+        }
+
+        mc3236_idev->name = SENSOR_NAME;
+        mc3236_idev->id.bustype = BUS_I2C;
+//        mc3236_idev->dev.parent = &client->dev;
+        
+        input_set_capability(mc3236_idev, EV_ABS, ABS_MISC);
+        input_set_abs_params(mc3236_idev, ABS_X, ABSMIN, ABSMAX, FUZZ, 0);
+        input_set_abs_params(mc3236_idev, ABS_Y, ABSMIN, ABSMAX, FUZZ, 0);
+        input_set_abs_params(mc3236_idev, ABS_Z, ABSMIN, ABSMAX, FUZZ, 0);
+
+        err = input_register_device(mc3236_idev);
+        if (err) {
+            printk(KERN_ERR "mc3236 input register failed\n");
+            goto error_register;
+        }
+  
+        err = sysfs_create_group(&mc3236_idev->dev.kobj, &mc3236_group);
+        if (err) {
+            printk(KERN_ERR "mc3236 create sysfs group failed\n");
+            goto error_register;
+        }
+  
+#ifdef CONFIG_HAS_EARLYSUSPEND
+        mc3236_es_handler.suspend = mc3236_early_suspend;
+        mc3236_es_handler.resume = mc3236_early_resume;
+        register_early_suspend(&mc3236_es_handler);
+#endif
+
+        printk(KERN_INFO "mc3236 device create ok: %s\n", SENSOR_NAME);
+        
+        data->mc3236.bus_write = mc3236_i2c_write;
+        data->mc3236.bus_read = mc3236_i2c_read;
+        mcube_mc3236_init(&(data->mc3236));
+        
+        mc3236_set_image();    
+        
+        // save default offset & gain
+        mc3236_get_offset(mc3236_calib_default, sizeof(mc3236_calib_default));
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+        //get dts configures
+        err = of_property_read_u32_array(client->dev.of_node, "calibration_table", cfg_calibration, 3);
+        if (err != 0) {
+            printk(KERN_ERR"get calibration fail\n");
+            memset(cfg_calibration, 0, sizeof(cfg_calibration));
+        }
+#else
+        memset(cfg_calibration, 0, sizeof(cfg_calibration));
+#endif    
+    
+        acc.x = (unsigned char) cfg_calibration[0];
+        acc.y = (unsigned char) cfg_calibration[1];
+        acc.z = (unsigned char) cfg_calibration[2];
+
+        // calibration from xml config
+        mc3236_calibration_offset(&acc);
+
+        return 0;
+        
+error_register:
+        input_unregister_device(mc3236_idev);
+exit_kfree:
+        kfree(data);
+ exit:
+        return err;
+}
+
+
+
+static int mc3236_remove(struct i2c_client *client)
+{
+    struct mc3236_data *data;
+#ifdef mc3236_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+    mc3236_do_enable(&client->dev, 0);
+    //mc3236_power_off();
+
+    sysfs_remove_group(&client->dev.kobj, &mc3236_group);
+
+    data = i2c_get_clientdata(client);
+    mc3236_client = NULL;
+    
+    if (mc3236_idev) 
+    {
+        printk(KERN_INFO "remove input device\n");
+        input_unregister_device(mc3236_idev);
+        input_free_device(mc3236_idev);
+        mc3236_idev = NULL;
+    }
+    kfree(data);
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int mc3236_suspend(struct device *dev)
+{    
+#ifdef mc3236_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif
+
+    // save offset 
+    mc3236_get_offset(mc3236_offset_saved, sizeof(mc3236_offset_saved));      
+    
+    mc3236_do_enable(dev, 0);      
+    //mc3236_power_off();
+    
+    return 0;
+}
+
+static int mc3236_resume(struct device *dev)
+{
+#ifdef mc3236_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+
+    //power on init regs    
+    //mc3236_power_on();
+    mc3236_set_image();     
+    mc3236_do_enable(dev, atomic_read(&mc3236_enable));
+    
+    // restore offset 
+    mc3236_set_offset(mc3236_offset_saved, sizeof(mc3236_offset_saved));        
+    
+    return 0;
+}
+#else
+
+#define mc3236_suspend NULL
+#define mc3236_resume NULL
+
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mc3236_early_suspend(struct early_suspend *handler)
+{
+#ifdef mc3236_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+    // sensor hal will disable when early suspend
+}
+
+static void mc3236_early_resume(struct early_suspend *handler)
+{ 
+#ifdef mc3236_DEBUG
+    printk(KERN_INFO "%s\n",__FUNCTION__);
+#endif    
+    // sensor hal will enable when early resume
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(mc3236_pm_ops, mc3236_suspend, mc3236_resume);
+
+static const struct i2c_device_id mc3236_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, mc3236_id);
+
+static struct of_device_id mc323x_of_match[] = {
+	{ .compatible = "mc323x" },
+	{ }
+};
+
+static struct i2c_driver mc3236_driver = {    
+    .driver = {
+        .owner    = THIS_MODULE,    
+        .name    = SENSOR_NAME,
+        .pm    = &mc3236_pm_ops,
+        .of_match_table	= of_match_ptr(mc323x_of_match),
+    },
+    .class        = I2C_CLASS_HWMON,
+    .id_table    = mc3236_id,
+    .probe        = mc3236_probe,
+    .remove        = mc3236_remove,
+    .detect        = mc3236_detect,
+};
+#if 0
+static struct i2c_board_info mc3236_board_info={
+    .type = SENSOR_NAME, 
+    .addr = mc3236_I2C_ADDR,
+};
+#endif
+
+static int __init mc3236_init(void)
+{
+    printk(KERN_ERR "mc3236 init\n");    
+    return i2c_add_driver(&mc3236_driver);
+}
+
+static void __exit mc3236_exit(void)
+{
+    i2c_del_driver(&mc3236_driver);
+
+    printk(KERN_ERR "mc3236 exit,%d\n", __LINE__);
+}
+
+MODULE_DESCRIPTION("mc3236 driver");
+MODULE_LICENSE("GPL");
+
+module_init(mc3236_init);
+module_exit(mc3236_exit);
diff --git a/drivers/input/misc/gsensor/mir3da/Makefile b/drivers/input/misc/gsensor/mir3da/Makefile
new file mode 100755
index 0000000..0ae59a5
--- /dev/null
+++ b/drivers/input/misc/gsensor/mir3da/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the mma7660 drivers
+#
+
+obj-$(CONFIG_GSENSOR_MIR3DA) += gsensor_mir3da.o
+gsensor_mir3da-objs := mir3da_cust.o mir3da_core.o 
+
+
diff --git a/drivers/input/misc/gsensor/mir3da/mir3da_core.c b/drivers/input/misc/gsensor/mir3da/mir3da_core.c
new file mode 100755
index 0000000..76df7fb
--- /dev/null
+++ b/drivers/input/misc/gsensor/mir3da/mir3da_core.c
@@ -0,0 +1,2121 @@
+/* Core file for MiraMEMS 3-Axis Accelerometer's driver. 
+ *
+ * mir3da_core.c - Linux kernel modules for 3-Axis Accelerometer
+ *
+ * Copyright (C) 2011-2013 MiraMEMS Sensing Technology Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include "mir3da_core.h"
+#include "mir3da_cust.h"
+
+#define MIR3DA_REG_PAGE(REG)                (((REG)>>8)&0xFF)
+#define MIR3DA_REG_ADDR(REG)                ((REG)&0xFF)
+
+#define MIR3DA_OFFSET_THRESHOLD             10
+#define PEAK_LVL                            800                        
+#define STICK_LSB                           2000
+#define AIX_HISTORY_SIZE                    3
+
+typedef struct reg_obj_s {
+    
+    short               addr;
+    unsigned char       mask;
+    unsigned char       value;
+    
+} reg_obj_t;
+
+struct gsensor_data_fmt_s {
+
+    unsigned char       msbw;
+    unsigned char       lsbw;
+    unsigned char       endian;                         /* 0: little endian; 1: big endian */
+};
+
+struct gsensor_data_obj_s {
+
+#define MIR3DA_DATA_LEN         6
+    reg_obj_t                   data_sect[MIR3DA_DATA_LEN];
+    struct gsensor_data_fmt_s   data_fmt;
+};
+
+struct gsensor_obj_s {
+    
+    char                        asic[10];
+
+    reg_obj_t                   chip_id;
+    reg_obj_t                   mod_id;
+    reg_obj_t                   soft_reset;
+    reg_obj_t                   power;
+
+#define MIR3DA_INIT_SECT_LEN    11
+#define MIR3DA_OFF_SECT_LEN     MIR3DA_OFFSET_LEN
+#define MIR3DA_ODR_SECT_LEN   	3
+
+    reg_obj_t                   init_sect[MIR3DA_INIT_SECT_LEN];
+    reg_obj_t                   offset_sect[MIR3DA_OFF_SECT_LEN];
+    reg_obj_t                   odr_sect[MIR3DA_ODR_SECT_LEN]; 	
+    
+    struct gsensor_data_obj_s   data;
+
+    int                         (*calibrate)(MIR_HANDLE handle, int z_dir);
+    int                         (*auto_calibrate)(MIR_HANDLE handle, int xyz[3]);
+    int                         (*int_ops)(MIR_HANDLE handle, mir_int_ops_t *ops);
+    int                         (*get_reg_data)(MIR_HANDLE handle, char *buf);
+};
+
+struct gsensor_drv_s {
+    
+    struct general_op_s         *method;
+
+    struct gsensor_obj_s        *obj;
+};
+
+#define MIR3DA_SOCLE_INIT_SECTION                       { SOCLE_REG_TEMP_CFG_REG,       0xFF,   0x08    },                                  \
+                                                        { SOCLE_REG_CTRL_REG5,          0xFF,   0x80    },                                  \
+                                                        { SOCLE_REG_CTRL_REG4,          0x30,   0x00    },                                  \
+                                                        { SOCLE_REG_CTRL_REG1,          0xFF,   0x6F    },                                  \
+                                                        { SOCLE_REG_TEMP_CFG_REG,       0xFF,   0x88    },                                  \
+                                                        { SOCLE_REG_LDO_REG,            0xFF,   0x02    },                                  \
+                                                        { SOCLE_REG_OTP_TRIM_OSC,       0xFF,   0x27    },                                  \
+                                                        { SOCLE_REG_LPF_ABSOLUTE,       0xFF,   0x30    },                                  \
+                                                        { SOCLE_REG_TEMP_OFF1,          0xFF,   0x3f    },                                  \
+                                                        { SOCLE_REG_TEMP_OFF2,          0xFF,   0xff    },                                  \
+                                                        { SOCLE_REG_TEMP_OFF3,          0xFF,   0x0f    },                                  \
+
+
+#define MIR3DA_SOCLE_OFFSET_SECTION                     { SOCLE_REG_OTP_XOFF_L,         0xFF,   0x00    },                                  \
+                                                        { SOCLE_REG_OTP_XOFF_H,         0xFF,   0x00    },                                  \
+                                                        { SOCLE_REG_OTP_YOFF_L,         0xFF,   0x00    },                                  \
+                                                        { SOCLE_REG_OTP_YOFF_H,         0xFF,   0x00    },                                  \
+                                                        { SOCLE_REG_OTP_ZOFF_L,         0xFF,   0x00    },                                  \
+                                                        { SOCLE_REG_OTP_ZOFF_H,         0xFF,   0x00    },                                  \
+                                                        { -1,                           0x00,   0x00    },                                  \
+                                                        { -1,                           0x00,   0x00    },                                  \
+                                                        { -1,                           0x00,   0x00    },                                  \
+
+#define MIR3DA_SOCLE_ODR_SECTION                        { SOCLE_REG_CTRL_REG1,          0xF0,   0x40    },                                  \
+                                                        { SOCLE_REG_CTRL_REG1,          0xF0,   0x50    },                                  \
+                                                        { SOCLE_REG_CTRL_REG1,          0xF0,   0x60    },                                  \
+
+
+#define MIR3DA_SOCLE_DATA_SECTION                     { { (SOCLE_REG_OUT_X_L|0x80),     0xFF,   0x00    },                                  \
+                                                        { (SOCLE_REG_OUT_X_H|0x80),     0xFF,   0x00    },                                  \
+                                                        { (SOCLE_REG_OUT_Y_L|0x80),     0xFF,   0x00    },                                  \
+                                                        { (SOCLE_REG_OUT_Y_H|0x80),     0xFF,   0x00    },                                  \
+                                                        { (SOCLE_REG_OUT_Z_L|0x80),     0xFF,   0x00    },                                  \
+                                                        { (SOCLE_REG_OUT_Z_H|0x80),     0xFF,   0x00    } },                                \
+                                                        { 8,                            4,      0       }
+
+
+#define MIR3DA_NSA_INIT_SECTION                         { NSA_REG_G_RANGE,              0x03,   0x00    },                                  \
+                                                        { NSA_REG_POWERMODE_BW,         0xFF,   0x1e    },                                  \
+                                                        { NSA_REG_ODR_AXIS_DISABLE,     0xFF,   0x07    },                                  \
+                                                        { NSA_REG_INTERRUPT_SETTINGS2,  0xFF,   0x00    },                                  \
+                                                        { NSA_REG_INTERRUPT_MAPPING2,   0xFF,   0x00    },                                  \
+                                                        { NSA_REG_ENGINEERING_MODE,     0xFF,   0x83    },                                  \
+                                                        { NSA_REG_ENGINEERING_MODE,     0xFF,   0x69    },                                  \
+                                                        { NSA_REG_ENGINEERING_MODE,     0xFF,   0xBD    },                                  \
+                                                        { NSA_REG_INT_PIN_CONFIG,       0x0F,   0x05    },                                  \
+                                                        { -1,                           0x00,   0x00    },                                  \
+                                                        { -1,                           0x00,   0x00    },                                  \
+                                                        
+                                                                                                 
+#define MIR3DA_NSA_OFFSET_SECTION                       { NSA_REG_COARSE_OFFSET_TRIM_X, 0xFF,   0x00    },                                  \
+                                                        { NSA_REG_COARSE_OFFSET_TRIM_Y, 0xFF,   0x00    },                                  \
+                                                        { NSA_REG_COARSE_OFFSET_TRIM_Z, 0xFF,   0x00    },                                  \
+                                                        { NSA_REG_FINE_OFFSET_TRIM_X,   0xFF,   0x00    },                                  \
+                                                        { NSA_REG_FINE_OFFSET_TRIM_Y,   0xFF,   0x00    },                                  \
+                                                        { NSA_REG_FINE_OFFSET_TRIM_Z,   0xFF,   0x00    },                                  \
+                                                        { NSA_REG_CUSTOM_OFFSET_X,      0xFF,   0x00    },                                  \
+                                                        { NSA_REG_CUSTOM_OFFSET_Y,      0xFF,   0x00    },                                  \
+                                                        { NSA_REG_CUSTOM_OFFSET_Z,      0xFF,   0x00    },                                  \
+
+#define MIR3DA_NSA_ODR_SECTION                          { NSA_REG_ODR_AXIS_DISABLE,     0x0F,   0x06    },                                  \
+                                                        { NSA_REG_ODR_AXIS_DISABLE,     0x0F,   0x07    },                                  \
+                                                        { NSA_REG_ODR_AXIS_DISABLE,     0x0F,   0x08    },                                  \
+
+
+#define MIR3DA_NSA_DATA_SECTION                       { { NSA_REG_ACC_X_LSB,            0xFF,   0x00    },                                  \
+                                                        { NSA_REG_ACC_X_MSB,            0xFF,   0x00    },                                  \
+                                                        { NSA_REG_ACC_Y_LSB,            0xFF,   0x00    },                                  \
+                                                        { NSA_REG_ACC_Y_MSB,            0xFF,   0x00    },                                  \
+                                                        { NSA_REG_ACC_Z_LSB,            0xFF,   0x00    },                                  \
+                                                        { NSA_REG_ACC_Z_MSB,            0xFF,   0x00    } },                                \
+                                                        { 8,                            4,      0       }
+                                         
+                                         
+static int SOCLE_calibrate(MIR_HANDLE handle, int z_dir);
+static int SOCLE_auto_calibrate(MIR_HANDLE handle, int xyz[3]);
+static int NSA_MLM_calibrate(MIR_HANDLE handle, int z_dir);
+static int NSA_NTO_calibrate(MIR_HANDLE handle, int z_dir);
+static int NSA_MLM_auto_calibrate(MIR_HANDLE handle, int xyz[3]);
+static int NSA_NTO_auto_calibrate(MIR_HANDLE handle, int xyz[3]);
+#if MIR3DA_AUTO_CALIBRATE
+static int mir3da_auto_calibrate(MIR_HANDLE handle, int x, int y, int z);
+#endif /* !MIR3DA_AUTO_CALIBRATE */
+static int SOCLE_interrupt_ops(MIR_HANDLE handle, mir_int_ops_t *ops);
+static int NSA_interrupt_ops(MIR_HANDLE handle, mir_int_ops_t *ops);
+static int SOCLE_get_reg_data(MIR_HANDLE handle, char *buf);
+static int NSA_get_reg_data(MIR_HANDLE handle, char *buf);
+
+#define MIR_SOCLE                       { "SOCLE",      { SOCLE_REG_WHO_AM_I,           0xFF,   0x13    },                                  \
+                                                        { SOCLE_REG_WHO_AM_I,           0xFF,   0x13    },                                  \
+                                                        { SOCLE_REG_SOFT_RESET,         0xFF,   0xAA    },                                  \
+                                                        { SOCLE_REG_TEMP_CFG_REG,       0x20,   0x20    },                                  \
+                                                        { MIR3DA_SOCLE_INIT_SECTION                     },                                  \
+                                                        { MIR3DA_SOCLE_OFFSET_SECTION                   },                                  \
+                                                        { MIR3DA_SOCLE_ODR_SECTION                      },                                  \
+                                                        { MIR3DA_SOCLE_DATA_SECTION                     },                                  \
+                                                          SOCLE_calibrate                                ,                                  \
+                                                          SOCLE_auto_calibrate                           ,                                  \
+                                                          SOCLE_interrupt_ops                            ,                                  \
+                                                          SOCLE_get_reg_data                             ,                                  \
+                                        }
+
+#define MIR_NSA_NTO                     { "NSA_NTO",    { NSA_REG_WHO_AM_I,             0xFF,   0x13    },                                  \
+                                                        { NSA_REG_FIFO_CTRL,            0xFF,   0x00    },                                  \
+                                                        { NSA_REG_SPI_I2C,              0x24,   0x24    },                                  \
+                                                        { NSA_REG_POWERMODE_BW,         0xC0,   0xC0    },                                  \
+                                                        { MIR3DA_NSA_INIT_SECTION                       },                                  \
+                                                        { MIR3DA_NSA_OFFSET_SECTION                     },                                  \
+                                                        { MIR3DA_NSA_ODR_SECTION                   	    },                                  \
+                                                        { MIR3DA_NSA_DATA_SECTION                       },                                  \
+                                                          NSA_NTO_calibrate                              ,                                  \
+                                                          NSA_NTO_auto_calibrate                         ,                                  \
+                                                          NSA_interrupt_ops                              ,                                  \
+                                                          NSA_get_reg_data                               ,                                  \
+                                        }
+                                                        
+#define MIR_NSA_MLM                     { "NSA_MLM",    { NSA_REG_WHO_AM_I,             0xFF,   0x13    },                                  \
+                                                        { NSA_REG_FIFO_CTRL,            0xFF,   0x10    },                                  \
+                                                        { NSA_REG_SPI_I2C,              0x24,   0x24    },                                  \
+                                                        { NSA_REG_POWERMODE_BW,         0xC0,   0xC0    },                                  \
+                                                        { MIR3DA_NSA_INIT_SECTION                       },                                  \
+                                                        { MIR3DA_NSA_OFFSET_SECTION                     },                                  \
+                                                        { MIR3DA_NSA_ODR_SECTION                        },                                  \
+                                                        { MIR3DA_NSA_DATA_SECTION                       },                                  \
+                                                          NSA_MLM_calibrate                              ,                                  \
+                                                          NSA_MLM_auto_calibrate                         ,                                  \
+                                                          NSA_interrupt_ops                              ,                                  \
+                                                          NSA_get_reg_data                               ,                                  \
+                                        }
+
+
+/**************************************************************** COMMON ***************************************************************************/
+#define MIR3DA_GSENSOR_SCHEME           MIR3DA_SUPPORT_CHIP_LIST
+
+
+/* this level can be modified while runtime through system attribute */
+int                                 Log_level = DEBUG_ERR;//|DEBUG_ASSERT|DEBUG_MSG|DEBUG_FUNC|DEBUG_DATA;
+static int                                gsensor_mod = -1;        /* Initial value */
+static struct gsensor_obj_s         mir3da_gsensor[] = { MIR3DA_GSENSOR_SCHEME };
+struct gsensor_drv_s                mir3da_gsensor_drv;
+
+#define MI_DATA(format, ...)            if(DEBUG_DATA&Log_level){mir3da_gsensor_drv.method->myprintf(MI_TAG format "\n", ## __VA_ARGS__);}
+#define MI_MSG(format, ...)             if(DEBUG_MSG&Log_level){mir3da_gsensor_drv.method->myprintf(MI_TAG format "\n", ## __VA_ARGS__);}
+#define MI_ERR(format, ...)             if(DEBUG_ERR&Log_level){mir3da_gsensor_drv.method->myprintf(MI_TAG format "\n", ## __VA_ARGS__);}
+#define MI_FUN                          if(DEBUG_FUNC&Log_level){mir3da_gsensor_drv.method->myprintf(MI_TAG "%s is called, line: %d\n", __FUNCTION__,__LINE__);}
+#define MI_ASSERT(expr)                 \
+	if (!(expr)) {\
+		mir3da_gsensor_drv.method->myprintf("Assertion failed! %s,%d,%s,%s\n",\
+			__FILE__, __LINE__, __func__, #expr);\
+	}
+
+#define abs(x) ({ long __x = (x); (__x < 0) ? -__x : __x; })
+
+#if FILTER_AVERAGE_ENHANCE
+typedef struct FilterAverageContextTag{
+    int sample_l;
+    int sample_h;
+    int filter_param_l;
+    int filter_param_h;
+    int filter_threhold;
+
+    int refN_l;
+    int refN_h;
+        
+} FilterAverageContext;
+
+typedef struct mir3da_core_ctx_s{
+    struct mir3da_filter_param_s    filter_param;
+    FilterAverageContext            tFac[3];   
+} mir3da_core_ctx;
+
+static mir3da_core_ctx       core_ctx;
+#endif 
+
+#if MIR3DA_SENS_TEMP_SOLUTION
+static int bSensZoom = 0;
+#endif
+
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+static int is_cali = 0;
+char bLoad = 0;
+static char readOffsetCnt=-1;
+static unsigned char original_offset[9];
+static int mir3da_write_offset_to_file(unsigned char* offset);
+static int mir3da_read_offset_from_file(unsigned char* offset);
+void manual_load_cali_file(MIR_HANDLE handle);
+#endif /* !MIR3DA_OFFSET_TEMP_SOLUTION */
+
+#if MIR3DA_STK_TEMP_SOLUTION
+static short aixHistort[AIX_HISTORY_SIZE*3] = {0};
+static short aixHistoryIndex = 0;
+char bxstk = 0;
+char bystk = 0;
+char bzstk = 0;
+
+static void addAixHistory(short x,short y,short z){
+    aixHistort[aixHistoryIndex++] = x;
+    aixHistort[aixHistoryIndex++] = y;
+    aixHistort[aixHistoryIndex++] = z;    
+    aixHistoryIndex = (aixHistoryIndex)%(AIX_HISTORY_SIZE*3);
+}
+
+static char isXStick(void){
+    int i;
+    for (i = 0; i < AIX_HISTORY_SIZE; i++){
+        if ((abs(aixHistort[i*3]) < STICK_LSB)&&(aixHistort[i*3] != 0)){
+            break;
+        }
+    }
+
+	if((aixHistort[0] +aixHistort[3]+aixHistort[6]) == 0)
+		return 1;
+    
+    return i == AIX_HISTORY_SIZE; 
+}
+
+static char isYStick(void){
+    int i;
+    for (i = 0; i < AIX_HISTORY_SIZE; i++){
+        if ((abs(aixHistort[i*3+1]) < STICK_LSB)&&(aixHistort[i*3+1] != 0)){
+            break;
+        }
+    }
+
+	if((aixHistort[1] +aixHistort[4]+aixHistort[7]) == 0)
+		return 1;    
+	
+    return i == AIX_HISTORY_SIZE;
+}
+
+static char isZStick(void){
+    int i;
+    for (i = 0; i < AIX_HISTORY_SIZE; i++){
+        if ((abs(aixHistort[i*3+2]) < STICK_LSB)&&(aixHistort[i*3+2] != 0)){
+            break;
+        }
+    }
+		
+	if((aixHistort[2] +aixHistort[5]+aixHistort[8]) == 0)
+		return 1;    
+    
+    return i == AIX_HISTORY_SIZE; 
+}
+
+ int squareRoot(int val){
+    int r = 0;
+    int shift;
+    
+    if (val < 0){
+        return 0;
+    }
+    
+    for(shift=0;shift<32;shift+=2)
+    { 
+        int x=0x40000000l >> shift;
+        if(x + r <= val)
+        { 
+            val -= x + r;
+            r = (r >> 1) | x;
+        } else{ 
+            r = r >> 1;
+        }
+    }
+    
+    return r;
+}
+#endif /* ! MIR3DA_STK_TEMP_SOLUTION */
+
+#if FILTER_AVERAGE_ENHANCE
+static short filter_average(short preAve, short sample, int paramN, int* refNum)
+{
+ #if FILTER_AVERAGE_EX
+    if( abs(sample-preAve) > PEAK_LVL  && *refNum < 3  ){ 
+         MI_DATA("Hit, sample = %d, preAve = %d, refN =%d\n", sample, preAve, *refNum);
+         sample = preAve;
+         (*refNum) ++;
+    }else{
+         if (*refNum == 3){
+                preAve = sample;
+         }
+         
+         *refNum  = 0;
+    }
+#endif
+
+    return preAve + (sample - preAve)/paramN;
+}
+
+static int filter_average_enhance(FilterAverageContext* fac, short sample)
+{
+    if (fac == 0){
+        MI_ERR("0 parameter fac");
+        return 0;
+    }
+
+    if (fac->filter_param_l == fac->filter_param_h){
+        fac->sample_l = fac->sample_h = filter_average(fac->sample_l, sample, fac->filter_param_l, &fac->refN_l);
+    }else{
+        fac->sample_l = filter_average(fac->sample_l, sample, fac->filter_param_l,  &fac->refN_l);
+        fac->sample_h= filter_average(fac->sample_h, sample, fac->filter_param_h, &fac->refN_h);  
+        if (abs(fac->sample_l- fac->sample_h) > fac->filter_threhold){
+            MI_DATA("adjust, fac->sample_l = %d, fac->sample_h = %d\n", fac->sample_l, fac->sample_h); 
+            fac->sample_h = fac->sample_l;            
+        }
+     }
+
+    return fac->sample_h;    
+}
+#endif /* ! FILTER_AVERAGE_ENHANCE */
+
+int mir3da_register_read(MIR_HANDLE handle, short addr, unsigned char *data)
+{
+    unsigned char      cur_page;
+    int     res = 0;
+
+    /* check page */
+    if(MIR3DA_REG_PAGE(addr) > 0) {
+        res = mir3da_gsensor_drv.method->smi.read(handle, 0x0, &cur_page);
+        if(res != 0) {
+            return res;
+        }
+
+        if(cur_page != MIR3DA_REG_PAGE(addr)) {
+            res |= mir3da_gsensor_drv.method->smi.write(handle, 0x0, MIR3DA_REG_PAGE(addr));
+            if(res != 0) {
+                return res;
+            }
+        }
+    }
+
+    res = mir3da_gsensor_drv.method->smi.read(handle, MIR3DA_REG_ADDR(addr), data);
+
+    if(MIR3DA_REG_PAGE(addr) > 0) {
+        /* restore page NO. */
+        res |= mir3da_gsensor_drv.method->smi.write(handle, 0x0, cur_page);
+    }
+
+    return res;
+}
+
+int mir3da_register_read_continuously(MIR_HANDLE handle, short addr, unsigned char count, unsigned char *data)
+{
+    unsigned char      cur_page;
+    int     res = 0;
+
+    /* check page */
+    if(MIR3DA_REG_PAGE(addr) > 0) {
+        res = mir3da_gsensor_drv.method->smi.read(handle, 0x0, &cur_page);
+        if(res != 0) {
+            return res;
+        }
+
+        if(cur_page != MIR3DA_REG_PAGE(addr)) {
+            res |= mir3da_gsensor_drv.method->smi.write(handle, 0x0, MIR3DA_REG_PAGE(addr));
+            if(res != 0) {
+                return res;
+            }
+        }
+    }
+
+    res = (count==mir3da_gsensor_drv.method->smi.read_block(handle, MIR3DA_REG_ADDR(addr), count, data)) ? 0 : 1;
+
+    if(MIR3DA_REG_PAGE(addr) > 0) {
+        /* restore page NO. */
+        res |= mir3da_gsensor_drv.method->smi.write(handle, 0x0, cur_page);
+    }
+
+    return res;
+}
+
+int mir3da_register_write(MIR_HANDLE handle, short addr, unsigned char data)
+{
+    unsigned char      cur_page;
+    int     res = 0;
+
+    /* check page */
+    if(MIR3DA_REG_PAGE(addr) > 0) {
+        res = mir3da_gsensor_drv.method->smi.read(handle, 0x0, &cur_page);
+        if(res != 0) {
+            return res;
+        }
+
+        if(cur_page != MIR3DA_REG_PAGE(addr)) {
+            res |= mir3da_gsensor_drv.method->smi.write(handle, 0x0, MIR3DA_REG_PAGE(addr));
+            if(res != 0) {
+                return res;
+            }
+        }
+    }
+
+    res = mir3da_gsensor_drv.method->smi.write(handle, MIR3DA_REG_ADDR(addr), data);
+
+    if(MIR3DA_REG_PAGE(addr) > 0) {
+        /* restore page NO. */
+        res |= mir3da_gsensor_drv.method->smi.write(handle, 0x0, cur_page);
+    }
+
+    return res;
+}
+
+int mir3da_register_mask_write(MIR_HANDLE handle, short addr, unsigned char mask, unsigned char data)
+{
+    int     res = 0;
+    unsigned char      tmp_data;
+
+    res = mir3da_register_read(handle, addr, &tmp_data);
+    if(res) {
+        return res;
+    }
+
+    tmp_data &= ~mask; 
+    tmp_data |= data & mask;
+    res = mir3da_register_write(handle, addr, tmp_data);
+
+    return res;
+}
+
+static int mir3da_read_raw_data(MIR_HANDLE handle, short *x, short *y, short *z)
+{
+    unsigned char    tmp_data[6] = {0};
+
+    if (mir3da_register_read_continuously(handle, mir3da_gsensor_drv.obj[gsensor_mod].data.data_sect[0].addr, 6, tmp_data) != 0) {
+        MI_ERR("i2c block read failed\n");
+        return -1;
+    }
+
+    *x = ((short)(tmp_data[1] << mir3da_gsensor_drv.obj[gsensor_mod].data.data_fmt.msbw | tmp_data[0]))>> (8-mir3da_gsensor_drv.obj[gsensor_mod].data.data_fmt.lsbw);
+    *y = ((short)(tmp_data[3] << mir3da_gsensor_drv.obj[gsensor_mod].data.data_fmt.msbw | tmp_data[2]))>> (8-mir3da_gsensor_drv.obj[gsensor_mod].data.data_fmt.lsbw);
+    *z = ((short)(tmp_data[5] << mir3da_gsensor_drv.obj[gsensor_mod].data.data_fmt.msbw | tmp_data[4]))>> (8-mir3da_gsensor_drv.obj[gsensor_mod].data.data_fmt.lsbw);
+
+    MI_DATA("mir3da_raw: x=%d, y=%d, z=%d",  *x, *y, *z);
+    
+#if MIR3DA_SENS_TEMP_SOLUTION
+    if (bSensZoom == 1){
+        *z = (*z )*5/4;
+        MI_DATA("SensZoom take effect, Zoomed Z = %d", *z);
+    }
+#endif
+    return 0;
+}
+
+
+int mir3da_read_data(MIR_HANDLE handle, short *x, short *y, short *z)
+{
+    int    rst = 0;
+	static short sx=0, sy=0, sz=0;	
+
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+    if(is_cali){
+        *x = *y = *z = 0;
+        return 0;
+    }
+
+    manual_load_cali_file(handle);
+#endif
+
+    rst = mir3da_read_raw_data(handle, x, y, z);
+    if (rst != 0){
+        MI_ERR("mir3da_read_raw_data failed, rst = %d", rst);
+        return rst;
+    }
+#if MIR3DA_AUTO_CALIBRATE
+    if(!bLoad) {
+		if (GSENSOR_MOD_SOCLE != gsensor_mod ){	
+            mir3da_auto_calibrate(handle, *x, *y, *z);
+		}
+    }
+#endif
+    
+#if MIR3DA_STK_TEMP_SOLUTION   
+    addAixHistory(*x,*y,*z);
+
+    bxstk = isXStick();
+    bystk = isYStick();
+    bzstk = isZStick();
+
+    if ((bxstk + bystk+ bzstk) < 2){
+        if(bxstk)
+        *x = squareRoot(1024*1024 - (*y)*(*y) - (*z)*(*z));
+    if(bystk)
+        *y = squareRoot(1024*1024 - (*x)*(*x) - (*z)*(*z));
+    if(bzstk)
+        *z = -1*squareRoot(1024*1024 - (*x)*(*x) - (*y)*(*y));
+    }else{
+        // MI_ERR( "CHIP ERR !MORE STK!\n"); 
+        return 0;
+    }
+#endif
+
+
+#if FILTER_AVERAGE_ENHANCE
+if(GSENSOR_MOD_SOCLE == gsensor_mod)
+{
+    *x = filter_average_enhance(&core_ctx.tFac[0], *x);
+    *y = filter_average_enhance(&core_ctx.tFac[1], *y);
+    *z = filter_average_enhance(&core_ctx.tFac[2], *z);
+
+    MI_DATA("mir3da_filt: x=%d, y=%d, z=%d",  *x, *y, *z);
+} 
+#endif
+
+	if((sx == *x) && (sy == *y) && (sz == *z)) {            
+		*z = *z + 1;
+	}
+
+    sx = *x;
+    sy = *y;
+    sz = *z;
+
+    return 0;
+}
+
+int cycle_read_xyz(MIR_HANDLE handle, int* x, int* y, int* z, int ncycle)
+{
+    unsigned int j = 0;
+    short raw_x,raw_y,raw_z;    
+
+    *x = *y = *z = 0;
+
+    for (j = 0; j < ncycle; j++)
+    {
+        raw_x = raw_y = raw_z = 0;
+        mir3da_read_raw_data (handle, &raw_x, &raw_y, &raw_z);
+
+        (*x) += raw_x;
+        (*y) += raw_y;
+        (*z) += raw_z;
+
+        mir3da_gsensor_drv.method->msdelay(5);
+    }
+    
+    (*x) /= ncycle;
+    (*y) /= ncycle;
+    (*z) /= ncycle;
+    
+    return 0;
+}
+
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+int mir3da_read_offset(MIR_HANDLE handle, unsigned char* offset)
+{
+    int     i, res = 0;
+    
+    for(i=0;i<MIR3DA_OFF_SECT_LEN;i++) {
+        if( mir3da_gsensor_drv.obj[gsensor_mod].offset_sect[i].addr < 0 ) {
+            break;
+        }
+
+        res = mir3da_register_read(handle, mir3da_gsensor_drv.obj[gsensor_mod].offset_sect[i].addr, &offset[i]);
+        if(res != 0) {
+            return res;
+        } 
+    }
+    
+    return res;
+}
+
+int mir3da_write_offset(MIR_HANDLE handle, unsigned char* offset)
+{
+    int     i, res = 0;
+
+    for(i=0;i<MIR3DA_OFF_SECT_LEN;i++) {
+        if( mir3da_gsensor_drv.obj[gsensor_mod].offset_sect[i].addr < 0 ) {
+            break;
+        }
+
+        res = mir3da_register_write(handle, mir3da_gsensor_drv.obj[gsensor_mod].offset_sect[i].addr, offset[i]);
+        if(res != 0) {
+            return res;
+        } 
+    }
+
+    return res;
+}
+
+static int mir3da_write_offset_to_file(unsigned char* offset)
+{
+    int     ret = 0;
+    
+    ret = mir3da_gsensor_drv.method->data_save(offset);
+    
+    MI_MSG("====sensor_sync_write, offset = 0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x", offset[0],offset[1],offset[2],offset[3],offset[4],offset[5],offset[6],offset[7],offset[8]);
+    
+    return ret;
+}
+
+static int mir3da_read_offset_from_file(unsigned char* offset)
+{
+    int     ret = 0;
+
+    ret = mir3da_gsensor_drv.method->data_get(offset);
+
+    MI_MSG("====sensor_sync_read, offset = 0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x", offset[0],offset[1],offset[2],offset[3],offset[4],offset[5],offset[6],offset[7],offset[8]);
+    
+    return ret;
+}
+
+void manual_load_cali_file(MIR_HANDLE handle)
+{ 
+    unsigned char  offset[MIR3DA_OFFSET_LEN] = {0};
+        
+    if (!bLoad){
+	 		readOffsetCnt++;	
+	 		if(readOffsetCnt%10 == 0)
+	 		{
+	 			if(readOffsetCnt>0)
+	 				readOffsetCnt =0;
+	     
+		 		MI_DATA("====444 manual_load_cali_file(), bLoad = %d, readOffsetCnt=%d.\n", bLoad, readOffsetCnt); 
+	      if(!mir3da_read_offset_from_file(offset))
+	      {
+	      	MI_MSG("========= WRITE OFFSET");
+	       	mir3da_write_offset(handle, offset);
+	       	bLoad = 1;
+	      }
+	   	}
+    }
+}
+
+typedef struct  linearitydata{
+    unsigned short  off;
+    int                    val; 
+
+}LinearityData;
+
+int check_linearity_offset(MIR_HANDLE handle, int *step)
+{
+
+    int                 i,result = 0;
+    int                 x, y, z;
+
+#if 1
+    unsigned char       xdata_count = 0;
+    unsigned char       ydata_count = 0;
+    unsigned char       zdata_count = 0;  	
+    LinearityData       xdata[2] = {{0}};
+    LinearityData       ydata[2] = {{0}};
+    LinearityData       zdata[2] = {{0}}; 
+     
+    for (i = 10; i <= 0x3ff; i+= 50){
+        result |= mir3da_register_write(handle, SOCLE_REG_OTP_XOFF_L, i & 0xFF);
+        result |= mir3da_register_write(handle, SOCLE_REG_OTP_XOFF_H, (i & 0xFF00) >> 8);
+        result |= mir3da_register_write(handle, SOCLE_REG_OTP_YOFF_L, i & 0xFF);
+        result |= mir3da_register_write(handle, SOCLE_REG_OTP_YOFF_H, (i & 0xFF00) >> 8);
+        result |= mir3da_register_write(handle, SOCLE_REG_OTP_ZOFF_L, i & 0xFF);
+        result |= mir3da_register_write(handle, SOCLE_REG_OTP_ZOFF_H, (i & 0xFF00) >> 8);
+        result |= cycle_read_xyz(handle, &x, &y, &z, 20);
+
+        MI_MSG ("detect_linearity_ratio: i = %d, x = %d, y = %d, z= %d \n", i, x, y, z); 
+
+        if (result){
+            MI_MSG ("detect_linearity_ratio: chip op failed, result = %d \n", result); 
+            return result;
+        }
+
+        if (abs(x) < 1800 && xdata_count < 2){
+            MI_MSG("detect linearity ratio: xdata_count = %d, x = %d i = %d\n", xdata_count, x, i);
+            
+            xdata[xdata_count].val = x;  
+            xdata[xdata_count].off = i;    
+            xdata_count ++;
+        }
+
+        if (abs(y) < 1800 && ydata_count < 2){
+            MI_MSG("detect linearity ratio: ydata_count = %d, y = %d i = %d\n", ydata_count, y, i);
+            ydata[ydata_count].val = y;  
+            ydata[ydata_count].off = i;    
+            ydata_count ++;                       
+        }
+
+        if (abs(z) < 1800 && zdata_count < 2){
+            MI_MSG("detect linearity ratio: zdata_count = %d, z = %d i = %d\n", zdata_count, z, i);
+            zdata[zdata_count].val = z;  
+            zdata[zdata_count].off = i;    
+            zdata_count ++;                       
+        }
+
+        if (xdata_count == 2 && ydata_count == 2 && zdata_count == 2 ){
+            MI_MSG ("all linearity_ratio found!");
+            step[0] = (xdata[1].val - xdata[0].val)/(xdata[1].off - xdata[0].off);
+            step[1] = (ydata[1].val - ydata[0].val)/(ydata[1].off - ydata[0].off);
+            step[2] = (zdata[1].val - zdata[0].val)/(zdata[1].off - zdata[0].off);
+
+            MI_MSG("CUSTOM offset step: x = %d, y = %d, z= %d", step[0], step[1], step[2] );
+
+            break;
+        }
+    }
+
+    if( abs(step[0]) < 10 || abs(step[1]) < 10 || abs(step[2]) < 10 ){
+        MI_MSG("detect linearity ratio failed!");
+        return -1;
+    }  
+    
+#endif    
+    return result;
+}
+
+static void mir3da_cali_off_to_lsb(int off, int *coarse, int coarse_step, int *fine, int fine_step)
+{
+	*coarse = off/coarse_step;
+	*fine = 100*(off-(*coarse)*coarse_step)/fine_step;
+	
+	MI_MSG("off = %d; delta_coarse = %d; delta_fine = %d", off, *coarse, *fine);
+}
+
+#if MIR3DA_AUTO_CALIBRATE
+static int NSA_once_calibrate(MIR_HANDLE handle, int coarse_step[3], int fine_step[3], int xyz[3])
+{
+    int     coarse[3] = {0};
+    int     coarse_delta[3] = {0};
+    int     fine[3] = {0};
+    int     fine_delta[3] = {0};
+    int     target[3] = {0};
+    int     i;
+    unsigned char   offset_data[9] = {0};
+
+    if(mir3da_read_offset(handle, offset_data)){
+        MI_ERR("Get old offset failed !");
+        return -1;
+    }
+    coarse[0] = offset_data[0] & 0x3f;
+    coarse[1] = offset_data[1] & 0x3f;
+    coarse[2] = offset_data[2] & 0x3f;
+    fine[0] = (((int)offset_data[0] << 2) & 0x300)|offset_data[3];
+    fine[1] = (((int)offset_data[1] << 2) & 0x300)|offset_data[4];
+    fine[2] = (((int)offset_data[2] << 2) & 0x300)|offset_data[5];
+    
+    MI_MSG("Old coarse_x = %d; coarse_y = %d; coarse_z = %d; fine_x = %d; fine_y = %d; fine_z = %d;", coarse[0], coarse[1], coarse[2], fine[0], fine[1], fine[2]);
+        
+    /* 0 means auto detect z direction assume z axis is verticle */
+    if ((abs(target[0]) + abs(target[1]) + abs(target[2])) == 0){
+        target[2] = (xyz[2] > 0) ? 1024 : (-1024);
+    }
+    
+    for(i = 0;i < 3; i++){
+        coarse_step[i] *= coarse[i] >= 32 ? (-1) : 1;
+        mir3da_cali_off_to_lsb((xyz[i]-target[i]), &coarse_delta[i], coarse_step[i], &fine_delta[i], fine_step[i]);
+        
+        coarse[i] += coarse_delta[i];
+        fine[i] += fine_delta[i];
+        offset_data[i] = coarse[i]|((fine[i]>>2)&0xc0);
+        offset_data[i+3] = fine[i]&0xFF;
+    }
+    
+    if(mir3da_write_offset(handle, offset_data)){
+        MI_ERR("Update offset failed !");
+        return -1;
+    }
+    /* Discard unstable data after offset register changed */
+    cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], 5);
+    if(cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], 10)){
+        return -1;
+    }
+    MI_MSG("---calibrate_Done, x = %d, y = %d, z = %d, coarse_x = %d, coarse_y = %d, coarse_z = %d, fine_x = %d, fine_y = %d, fine_z = %d", xyz[0], xyz[1], xyz[2], coarse[0], coarse[1], coarse[2], fine[0], fine[1], fine[2]);
+    
+    return mir3da_write_offset_to_file(offset_data);
+}
+#endif /* !MIR3DA_AUTO_CALIBRATE */
+
+static int NSA_calibrate(MIR_HANDLE handle, int coarse_step[3], int fine_step[3], int fine_max, int target[3])
+{
+    int             i = 0, j = 0;
+    unsigned char   ncycle = 20;
+    unsigned char   nLoop = 20;
+    unsigned char   offset_data[9] = {0};
+    unsigned char   fine_ok_map = 0;
+    
+    int             xyz[3] = {0};  
+    int             coarse[3] = {0};
+    int             coarse_delta[3] = {0};
+    int             fine[3] = {0};
+    int             fine_delta[3] = {0};
+    
+    if( (abs(target[0]) + abs(target[1]) + abs(target[2])) != 0 && (abs(target[0]) + abs(target[1]) + abs(target[2])) != 1024 ) {
+        MI_ERR("Invalid argument !");
+        return -1;
+    }
+        
+    /* 0 means auto detect z direction assume z axis is verticle */
+    if ((abs(target[0]) + abs(target[1]) + abs(target[2])) == 0){
+       if(cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], 5)){
+            MI_ERR("check z direction failed\n");
+            return -1;
+       }
+       target[2] = (xyz[2] > 0) ? 1024 : (-1024);
+    }
+
+    MI_MSG("---Start Calibrate, trim target %d, %d, %d---\n", target[0], target[1], target[2]);
+
+    // Stage1: Coarse tune once
+    MI_MSG("---Stage1, coarse tune---");            
+    // change to 16G mode
+    if(mir3da_register_mask_write(handle, NSA_REG_G_RANGE, 0x03, 3)){
+        MI_ERR("i2c mask write failed !\n");
+        return -1;
+    }
+
+    /* reset coarse offset register */
+    mir3da_write_offset(handle, offset_data);  
+    /* Discard unstable data after offset register changed */
+    cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], 5);
+  
+    if( cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], ncycle) ){
+        goto EXIT_16G_MOD;
+    }
+
+    for(i = 0; i < 3; i++){
+        /* check rule */
+        xyz[i] *= 8;
+
+        coarse[i] = ((xyz[i]-target[i]) > 0) ? 0 : 32;
+
+        MI_MSG("xyz[%d] = %d, coarse[%d] = 0x%x", i, xyz[i], i, coarse[i]);
+        
+        coarse_step[i] *= coarse[i] >= 32 ? (-1) : 1;
+        mir3da_cali_off_to_lsb((xyz[i]-target[i]), &coarse_delta[i], coarse_step[i], &fine_delta[i], fine_step[i]);
+
+        coarse[i] += coarse_delta[i];
+        fine[i] += fine_delta[i];
+        mir3da_register_mask_write(handle, NSA_REG_COARSE_OFFSET_TRIM_X+i, 0x3f, (unsigned char)coarse[i]);
+    }
+    
+    /* Discard unstable data after offset register changed */
+    cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], 5);
+    if(cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], 5)){
+        return -1;
+    }
+    for(i = 0; i < 3; i++){   
+        fine[i] += (xyz[i] > 0) ? 0 : fine_max;
+        mir3da_register_write(handle, NSA_REG_FINE_OFFSET_TRIM_X+i, (unsigned char)(fine[i]&0xff));
+        mir3da_register_mask_write(handle, NSA_REG_COARSE_OFFSET_TRIM_X+i, 0xc0, (unsigned char)(0xc0&(fine[i]>>2)));
+    }
+
+EXIT_16G_MOD:
+    // change back to 2G mode
+    if(mir3da_register_mask_write(handle, NSA_REG_G_RANGE, 0x03, 0)){
+        MI_ERR("i2c mask write failed !\n");
+        return -1;
+    }
+    /* Discard unstable data after offset register changed */
+    cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], 5);
+    if(cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], ncycle)){
+        return -1;
+    }
+    MI_MSG("---Stage1, coarse tune done: x = %d, y = %d, z = %d, coarse_x = %d, coarse_y = %d, coarse_z = %d, fine_x = %d, fine_y = %d, fine_z = %d", xyz[0], xyz[1], xyz[2], coarse[0], coarse[1], coarse[2], fine[0], fine[1], fine[2]);
+    
+    // Stage2: Fine tune
+    MI_MSG("---Stage2, Fine tune---");
+    for (i = 0; i < nLoop; i++){
+    
+        if( 0x07==(fine_ok_map & 0x07) ){
+            break;
+        }
+        /* Discard unstable data after offset register changed */
+        cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], 5);
+        MI_MSG("---Stage2, Fine loop %d", i);
+        if(cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], ncycle)){
+            return -1;
+        }
+        
+        for(j = 0; j < 3; j++){
+            MI_MSG("xyz[%d] = %d, caorse[%d] = 0x%x, fine[%d] = 0x%x", j, xyz[j], j, coarse[j], j, fine[j]);
+            if( abs(xyz[j]-target[j]) < MIR3DA_OFFSET_THRESHOLD ){
+                fine_ok_map |= (1<<j);
+                offset_data[j] = coarse[j]|((fine[j]>>2)&0xc0);
+                offset_data[j+3] = fine[j];
+                continue;        
+            }
+            mir3da_cali_off_to_lsb((xyz[j]-target[j]), &coarse_delta[j], coarse_step[j], &fine_delta[j], fine_step[j]);
+
+            coarse[j] += coarse_delta[j];
+            fine[j] += fine_delta[j];
+            mir3da_register_write(handle, NSA_REG_FINE_OFFSET_TRIM_X+j, (unsigned char)(fine[j]&0xff));
+            mir3da_register_mask_write(handle, NSA_REG_COARSE_OFFSET_TRIM_X+j, 0xFF, (unsigned char)(0xc0&(fine[j]>>2))|coarse[j]);
+        }                       
+    }
+    MI_MSG("---Stage2, Fine tune done: x = %d, y = %d, z = %d, coarse_x = %d, coarse_y = %d, coarse_z = %d, fine_x = %d, fine_y = %d, fine_z = %d", xyz[0], xyz[1], xyz[2], coarse[0], coarse[1], coarse[2], fine[0], fine[1], fine[2]);
+    
+    if( 0x07==(fine_ok_map & 0x07) ){
+        goto SUCCESS_EXIT;
+    }
+#if MIR3DA_STK_TEMP_SOLUTION
+    if( 0x03==(fine_ok_map & 0x07) ){
+        goto SUCCESS_EXIT;
+    }
+#endif
+    
+    MI_MSG("---calibrate Failed !---");
+    return -1;
+    
+SUCCESS_EXIT:
+    MI_MSG("---calibrate OK !---");
+    return mir3da_write_offset_to_file(offset_data);
+}
+
+static int NSA_NTO_cali_step_calc(MIR_HANDLE handle, int coarse[3], int x100_fine[3], int x100_cust[3])
+{
+    int                i;
+    unsigned int       total_gain[3] = {0}; 
+    unsigned char      coarse_gain = 0;
+    unsigned char      fine_gain[3] = {0};
+    unsigned int       const coarse_gain_map[] = {1000, 1125, 1250, 1375, 500, 625, 750, 875};   /* *1000  */
+    unsigned char      const fine_dig_gain_map[] = {1, 2, 4, 8};
+        
+    if(mir3da_register_read_continuously(handle, NSA_REG_SENSITIVITY_TRIM_X, 3, fine_gain) != 0){
+        MI_ERR("i2c block read failed\n");
+        return -1;
+    }
+
+    if(mir3da_register_read(handle, NSA_REG_SENS_COARSE_TRIM, &coarse_gain) != 0){
+        MI_ERR("i2c block read failed\n");
+        return -1;
+    }
+    
+    for(i = 0;i < 3;i++) {        
+        // *100*1000
+        total_gain[i] = ((1000 + (fine_gain[i]&0x1F)*1000/32)/15) * fine_dig_gain_map[((fine_gain[i]>>5)&0x03)] * coarse_gain_map[coarse_gain&0x07]; 
+        coarse[i] = (int)(total_gain[i] * 500 / 100000);
+        x100_fine[i] = (int)(total_gain[i] * 293 / 100000);
+        x100_cust[i] = (int)(total_gain[i] * 390 / 100000);
+    }
+    MI_MSG("coarse_step_x = %d, coarse_step_y = %d, coarse_step_z = %d\n", coarse[0], coarse[1], coarse[2]);
+    MI_MSG("fine_step_x = %d, fine_step_y = %d, fine_step_z = %d\n", x100_fine[0], x100_fine[1], x100_fine[2]);
+    MI_MSG("custom_step_x = %d, custom_step_y = %d, custom_step_z = %d\n", x100_cust[0], x100_cust[1], x100_cust[2]);
+    
+    return 0;    
+}
+
+static int NSA_MLM_cali_step_calc(MIR_HANDLE handle, int coarse[3], int x100_fine[3], int x100_cust[3])
+{
+    int                i;
+    unsigned int       total_gain[3] = {0};
+    unsigned char      gain[3] = {0};
+    unsigned int       const coarse_gain_map[] = {1000, 1125, 1250, 1375, 500, 625, 750, 875};   /* *1000  */
+        
+    if(mir3da_register_read_continuously(handle, NSA_REG_SENSITIVITY_TRIM_X, 3, gain) != 0){
+        MI_ERR("i2c block read failed\n");
+        return -1;
+    }
+    
+    for(i = 0;i < 3;i++) {    
+        // *100*1000
+        total_gain[i] = ((1000 + (gain[i]&0x1F)*1000/32)/15) * coarse_gain_map[((gain[i]>>5)&0x07)];
+        MI_MSG("total gain = %d", total_gain[i]); 
+        coarse[i] = (int)(total_gain[i] * 500 / 100000);
+        x100_fine[i] = (int)(total_gain[i] * 589 / 100000);
+        x100_cust[i] = (int)(total_gain[i] * 390 / 100000);
+    }
+
+    MI_MSG("coarse_step_x = %d, coarse_step_y = %d, coarse_step_z = %d\n", coarse[0], coarse[1], coarse[2]);
+    MI_MSG("fine_step_x = %d, fine_step_y = %d, fine_step_z = %d\n", x100_fine[0], x100_fine[1], x100_fine[2]);
+    MI_MSG("custom_step_x = %d, custom_step_y = %d, custom_step_z = %d\n", x100_cust[0], x100_cust[1], x100_cust[2]);
+    
+    return 0;
+}
+
+#endif /* !MIR3DA_OFFSET_TEMP_SOLUTION */
+
+static int NSA_NTO_calibrate(MIR_HANDLE handle, int z_dir)
+{
+    int     result = 0;
+
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+    int     coarse_step[3] = {0};
+    int     fine_step[3] = {0};
+    int     custom_step[3] = {0};
+    int     target[3] = {0};
+
+   unsigned char     swap_plarity_old = 0;  
+      
+    /* compute step */
+    if( NSA_NTO_cali_step_calc(handle, coarse_step, fine_step, custom_step) ) {
+        MI_ERR("Compute step failed !");
+        return -1; 
+    }
+    target[2] = z_dir*1024;
+
+    // save swap/plarity old setting
+    if(mir3da_register_read(handle, NSA_REG_SWAP_POLARITY, &swap_plarity_old)){
+        MI_ERR("Get SWAP/PLARITY setting failed !");
+        return -1;
+    }
+    if(mir3da_register_mask_write(handle, NSA_REG_SWAP_POLARITY, 0x0F, 0x00)){
+        MI_ERR("Set Plarity failed !");
+        return -1;
+    }
+    
+    result=NSA_calibrate(handle, coarse_step, fine_step, 0x3ff, target);
+
+    // Restore swap/plarity setting
+    if(mir3da_register_mask_write(handle, NSA_REG_SWAP_POLARITY, 0x0F, swap_plarity_old&0x0F)){
+        MI_ERR("Restore SWAP/PLARITY setting failed !");
+        return -1;
+    }
+
+#endif /* !MIR3DA_OFFSET_TEMP_SOLUTION */
+    return result;
+}
+
+static int NSA_NTO_auto_calibrate(MIR_HANDLE handle, int xyz[3])
+{
+    int     result = 0;
+
+#if MIR3DA_AUTO_CALIBRATE
+    int     coarse_step[3];
+    int     fine_step[3];
+    int     custom_step[3] = {0};
+   unsigned char     swap_plarity_old = 0;
+    int     temp=0;  
+      
+ 
+    /* compute step */
+    if( NSA_NTO_cali_step_calc(handle, coarse_step, fine_step, custom_step) ) {
+        MI_ERR("Compute step failed !");
+        return -1; 
+    }
+
+    // save swap/plarity old setting
+    if(mir3da_register_read(handle, NSA_REG_SWAP_POLARITY, &swap_plarity_old)){
+        MI_ERR("Get SWAP/PLARITY setting failed !");
+        return -1;
+    }
+    if((swap_plarity_old & (1<<0))){
+       MI_ERR("==xy swap==\n");
+       temp = xyz[0];
+       xyz[0] = ((swap_plarity_old & (1<<2)) != 0) ? (-xyz[1]) :xyz[1];
+       xyz[1] = ((swap_plarity_old & (1<<3)) != 0) ? (-temp) :temp;
+    }else{
+       MI_ERR("==xy no swap==\n");  
+       xyz[0] = ((swap_plarity_old & (1<<3)) != 0) ? (-xyz[0]) :xyz[0];
+       xyz[1] = ((swap_plarity_old & (1<<2)) != 0) ? (-xyz[1]) :xyz[1];
+    }
+
+    xyz[2] = ((swap_plarity_old & (1<<1)) != 0) ? (-xyz[2]) :xyz[2];
+   
+
+    
+    result = NSA_once_calibrate(handle, coarse_step, fine_step, xyz);
+
+
+#endif /* !MIR3DA_AUTO_CALIBRATE */
+    return result;
+}
+
+
+static int NSA_MLM_calibrate(MIR_HANDLE handle, int z_dir)
+{
+    int     result = 0;
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+    int     coarse_step[3] = {0};
+    int     fine_step[3] = {0};
+    int     custom_step[3] = {0};
+    int     target[3] = {0};
+    unsigned char     swap_plarity_old = 0;  
+      
+    /* compute step */
+    if( NSA_MLM_cali_step_calc(handle, coarse_step, fine_step, custom_step) ) {
+        MI_ERR("Compute step failed !");
+        return -1; 
+    }    
+    target[2] = z_dir*1024;
+    
+    // save swap/plarity old setting
+    if(mir3da_register_read(handle, NSA_REG_SWAP_POLARITY, &swap_plarity_old)){
+        MI_ERR("Get SWAP/PLARITY setting failed !");
+        return -1;
+    }
+    if(mir3da_register_mask_write(handle, NSA_REG_SWAP_POLARITY, 0x0F, 0x0E)){
+        MI_ERR("Set Plarity failed !");
+        return -1;
+    }
+    
+    result=NSA_calibrate(handle, coarse_step, fine_step, 0xff, target);
+    // Restore swap/plarity setting
+    if(mir3da_register_mask_write(handle, NSA_REG_SWAP_POLARITY, 0x0F, swap_plarity_old&0x0F)){
+        MI_ERR("Restore SWAP/PLARITY setting failed !");
+        return -1;
+    }
+#endif /* !MIR3DA_OFFSET_TEMP_SOLUTION */
+    return result;
+}
+
+static int NSA_MLM_auto_calibrate(MIR_HANDLE handle, int xyz[3])
+{
+    int     result = 0;
+#if MIR3DA_AUTO_CALIBRATE
+    int     coarse_step[3] = {0};
+    int     fine_step[3] = {0};
+    int     custom_step[3] = {0};
+    unsigned char     swap_plarity_old = 0;  
+      
+    /* compute step */
+    if( NSA_MLM_cali_step_calc(handle, coarse_step, fine_step, custom_step) ) {
+        MI_ERR("Compute step failed !");
+        return -1; 
+    }    
+    
+    // save swap/plarity old setting
+    if(mir3da_register_read(handle, NSA_REG_SWAP_POLARITY, &swap_plarity_old)){
+        MI_ERR("Get SWAP/PLARITY setting failed !");
+        return -1;
+    }
+    
+    xyz[0] = ((swap_plarity_old & (1<<3)) != 0) ? xyz[0] : (-xyz[0]);
+    xyz[1] = ((swap_plarity_old & (1<<2)) != 0) ? xyz[1] : (-xyz[1]);
+    xyz[2] = ((swap_plarity_old & (1<<1)) != 0) ? xyz[2] : (-xyz[2]);
+    
+    result=NSA_once_calibrate(handle, coarse_step, fine_step, xyz);
+
+#endif /* !MIR3DA_AUTO_CALIBRATE */
+    return result;
+}
+
+static int SOCLE_auto_calibrate(MIR_HANDLE handle, int xyz[3])
+{
+#if MIR3DA_AUTO_CALIBRATE
+    int     coarse_step[3] = {-20, -20, -20};
+    int     coarse_delta[3] = {0};
+    int     coarse[3] = {0};
+    int     fine_step[3] = {0};
+    int     fine_delta[3] = {0};
+    int     target[3] = {0};
+    int     i;
+    unsigned char   offset_data[9] = {0};
+    
+    if(mir3da_read_offset(handle, offset_data)){
+        MI_ERR("Get old offset failed !");
+        return -1;
+    }
+    
+    /* 0 means auto detect z direction assume z axis is verticle */
+    if ((abs(target[0]) + abs(target[1]) + abs(target[2])) == 0){
+        target[2] = (xyz[2] > 0) ? 1024 : (-1024);
+    }
+    
+    for(i = 0;i < 3; i++){
+        coarse[i] = offset_data[i*2+1] & 0xff;   /* high byte */
+        coarse[i] = (coarse[i] << 8)|offset_data[i*2]; /* low gyte */
+
+        mir3da_cali_off_to_lsb((xyz[i]-target[i]), &coarse_delta[i], coarse_step[i], &fine_delta[i], fine_step[i]);
+        coarse[i] += coarse_delta[i];
+        
+        offset_data[i*2] = coarse[i] & 0xff;
+        offset_data[i*2+1] = (coarse[i] >> 8) & 0xff;
+    }
+ 
+    if(mir3da_write_offset(handle, offset_data)){
+        MI_ERR("Update offset failed !");
+        return -1;
+    }
+
+    if(cycle_read_xyz(handle, &xyz[0], &xyz[1], &xyz[2], 10)){
+        return -1;
+    }
+    MI_MSG("---calibrate_Done, x = %d, y = %d, z = %d, off_x = %d, off_y = %d, off_z = %d", xyz[0], xyz[1], xyz[2], coarse[0], coarse[1], coarse[2]);
+    
+    return mir3da_write_offset_to_file(offset_data);
+
+#endif /* !MIR3DA_AUTO_CALIBRATE */
+    return 0;
+}
+
+static int SOCLE_calibrate(MIR_HANDLE handle, int z_dir)
+{
+    int             result = 0;
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+    short   i;
+    unsigned char      tmp_data[6];
+    int     x = 0, y = 0, z = 0;
+    short     tmp_off = 0, tmp_off2 = 0 ;
+    unsigned char      ncycle = 50;
+    unsigned char      offset_data[9] = {0};
+    int     fine_step[3] = {0};	
+	
+    unsigned char x_ok=0;
+    unsigned char y_ok=0;
+    unsigned char z_ok=0;
+    unsigned short x_off=0;	
+    unsigned short y_off=0;	
+    unsigned short z_off=0;	
+    unsigned short x_off_original = 0;
+    unsigned short y_off_original = 0;
+    unsigned short z_off_original = 0;
+
+    /* decide the z direction, if 0 which means auto */
+    if (z_dir == 0){
+       result = cycle_read_xyz(handle, &x, &y, &z, 5);
+       if (result != 0){
+            MI_ERR("check z direction failed\n");
+            goto fail_exit;
+       }
+       z_dir = z > 0 ? 1 : (-1);
+    }
+
+    if(mir3da_register_read_continuously(handle, (SOCLE_REG_OTP_XOFF_L|0x80), 6, tmp_data))
+    {
+        MI_ERR("i2c block read failed\n");
+        goto fail_exit;
+    }
+
+    x_off = (tmp_data[1] << 8) | tmp_data[0] ;
+    y_off = (tmp_data[3] << 8) | tmp_data[2] ;
+    z_off = (tmp_data[5] << 8) | tmp_data[4] ;
+
+#if MIR3DA_STK_TEMP_SOLUTION 
+    x_off_original = x_off;
+    y_off_original = y_off;
+    z_off_original = z_off;
+#endif
+
+    if (0 != check_linearity_offset(handle, fine_step)){
+        fine_step[0] = fine_step[1] = fine_step[2] = -20;
+    }   
+
+    result = mir3da_register_write(handle, SOCLE_REG_OTP_XOFF_L, x_off & 0xFF);
+    MI_ASSERT(result==0);
+    result = mir3da_register_write(handle, SOCLE_REG_OTP_XOFF_H, (x_off & 0xFF00) >> 8);
+    MI_ASSERT(result==0);
+    result = mir3da_register_write(handle, SOCLE_REG_OTP_YOFF_L, y_off & 0xFF);
+    MI_ASSERT(result==0);
+    result = mir3da_register_write(handle, SOCLE_REG_OTP_YOFF_H, (y_off & 0xFF00) >> 8);
+    MI_ASSERT(result==0);        
+    result = mir3da_register_write(handle, SOCLE_REG_OTP_ZOFF_L, z_off & 0xFF);
+    MI_ASSERT(result==0);
+    result = mir3da_register_write(handle, SOCLE_REG_OTP_ZOFF_H, (z_off & 0xFF00) >> 8);
+    MI_ASSERT(result==0);
+
+    MI_MSG("---Start Calibrate, z direction = %d---\n", z_dir);
+
+    for (i = 0; i < 20 ; i++)
+    {
+        x = y = z = 0;
+        
+       result = cycle_read_xyz(handle, &x, &y, &z, ncycle);
+       if (result != 0){
+            MI_ERR("i2c block read failed\n");
+            goto fail_exit;
+       }
+
+        MI_MSG("----loop %d: x = %d, y = %d, z = %d; x_off = 0x%x, y_off = 0x%x, z_off = 0x%x\n", i, x, y, z, x_off, y_off, z_off);
+
+        if (! x_ok)
+        {
+            if ( abs(x) <= MIR3DA_OFFSET_THRESHOLD )
+            {
+                x_ok = 1 ;
+                MI_MSG("------X is OK, 0x%X-------\n", x_off); 
+            }
+            else
+            {
+                tmp_off = x/fine_step[0];                
+
+                tmp_off2 = (short)x_off - tmp_off;
+                if (tmp_off2 > 0x3ff){
+                     tmp_off2 = 0x3ff;
+                }else if (tmp_off2 < 0){
+                    tmp_off2 = 0x01;
+                }
+                
+                x_off = (unsigned short)tmp_off2;
+                MI_MSG("tmp_off = %d, tmp_off2 = %d,  x_off = %d\n", tmp_off, tmp_off2,  x_off);
+               
+                result = mir3da_register_write(handle, SOCLE_REG_OTP_XOFF_L, x_off & 0xFF);
+                MI_ASSERT(result==0);
+                result = mir3da_register_write(handle, SOCLE_REG_OTP_XOFF_H, (x_off & 0xFF00) >> 8);
+                MI_ASSERT(result==0);
+            }
+            
+        }
+
+        if (! y_ok)
+        {
+            if ( abs(y) <= MIR3DA_OFFSET_THRESHOLD )
+            {
+                y_ok = 1 ;
+                MI_MSG("------Y is OK, 0x%X-------\n", y_off); 
+            }
+            else
+            {
+                 tmp_off = y/fine_step[1];                
+
+                tmp_off2 = (short)y_off - tmp_off;
+                if (tmp_off2 > 0x3ff){
+                     tmp_off2 = 0x3ff;
+                }else if (tmp_off2 < 0){
+                    tmp_off2 = 0x01;
+                }
+                
+                y_off = (unsigned short)tmp_off2;
+                MI_MSG("tmp_off = %d, tmp_off2 = %d,  y_off = %d\n", tmp_off, tmp_off2,  y_off);
+
+                result = mir3da_register_write(handle, SOCLE_REG_OTP_YOFF_L, y_off & 0xFF);
+                MI_ASSERT(result==0);
+                result = mir3da_register_write(handle, SOCLE_REG_OTP_YOFF_H, (y_off & 0xFF00) >> 8);
+                MI_ASSERT(result==0);
+            }
+            
+        }
+
+        if (! z_ok)
+        {
+            if ( abs(z - (z_dir > 0 ? 1024 : -1024)) <= MIR3DA_OFFSET_THRESHOLD )
+            {
+                z_ok = 1 ;
+                MI_MSG("------Z is OK, 0x%X-------\n", z_off); 
+            }
+            else
+            {
+                tmp_off = (z - (z_dir > 0 ? 1024 : -1024)) /fine_step[2];                
+
+                tmp_off2 = (short)z_off - tmp_off;
+                if (tmp_off2 > 0x3ff){
+                     tmp_off2 = 0x3ff;
+                }else if (tmp_off2 < 0){
+                    tmp_off2 = 0x01;
+                }
+                
+                z_off = (unsigned short)tmp_off2;
+                MI_MSG("tmp_off = %d, tmp_off2 = %d,  z_off = %d\n", tmp_off, tmp_off2,  z_off);
+                
+
+                result = mir3da_register_write(handle, SOCLE_REG_OTP_ZOFF_L, z_off & 0xFF);
+                MI_ASSERT(result==0);
+                result = mir3da_register_write(handle, SOCLE_REG_OTP_ZOFF_H, (z_off & 0xFF00) >> 8);
+                MI_ASSERT(result==0);
+            }
+            
+        }
+
+        if(x_ok && y_ok && z_ok )
+        {
+            MI_MSG("--- Calibrate done ---\n");
+            goto success_exit;
+        }
+    }
+
+#if MIR3DA_STK_TEMP_SOLUTION   
+     if(x_ok + y_ok + z_ok  == 2){
+
+       if(x_ok == 0){
+        x_off = x_off_original;
+        result = mir3da_register_write(handle, SOCLE_REG_OTP_XOFF_L, x_off & 0xFF);
+        MI_ASSERT(result==0);
+        result = mir3da_register_write(handle, SOCLE_REG_OTP_XOFF_H, (x_off & 0xFF00) >> 8);
+        MI_ASSERT(result==0);
+
+        MI_MSG("--- Calibrate done but x skipped---\n");    
+
+       }else 
+       if(y_ok == 0){
+           
+        y_off = y_off_original;
+        result = mir3da_register_write(handle, SOCLE_REG_OTP_YOFF_L, y_off & 0xFF);
+        MI_ASSERT(result==0);
+        result = mir3da_register_write(handle, SOCLE_REG_OTP_YOFF_H, (y_off & 0xFF00) >> 8);
+        MI_ASSERT(result==0);
+
+        MI_MSG("--- Calibrate done but y skipped---\n");    
+
+       }else
+        if(z_ok == 0){
+
+        z_off = z_off_original;
+        result = mir3da_register_write(handle, SOCLE_REG_OTP_ZOFF_L, z_off & 0xFF);
+        MI_ASSERT(result==0);
+        result = mir3da_register_write(handle, SOCLE_REG_OTP_ZOFF_H, (z_off & 0xFF00) >> 8);
+        MI_ASSERT(result==0);
+
+        MI_MSG("--- Calibrate done but z skipped---\n");    
+        }
+
+         goto success_exit;
+        }
+#endif
+
+fail_exit:
+    return -1;
+
+success_exit:
+   offset_data[0]= x_off & 0xFF;
+   offset_data[1]= (x_off & 0xFF00) >> 8;
+   offset_data[2]= y_off & 0xFF;
+   offset_data[3]= (y_off & 0xFF00) >> 8;
+   offset_data[4]= z_off & 0xFF;
+   offset_data[5]= (z_off & 0xFF00) >> 8;   
+   result = mir3da_write_offset_to_file(offset_data); 
+   
+#endif /* !MIR3DA_OFFSET_TEMP_SOLUTION */ 
+   return result;
+}
+
+int mir3da_calibrate(MIR_HANDLE handle, int z_dir)
+{
+    int     res = 0;
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+    if( is_cali )
+        return -1;
+    is_cali = 1;
+
+    /* restore original direction if last calibration was done in a wrong direction */
+    mir3da_write_offset(handle, original_offset);
+ 
+    res = mir3da_gsensor_drv.obj[gsensor_mod].calibrate(handle, z_dir); 
+    if (res != 0){
+	 MI_ERR("Calibrate failed !");
+	 mir3da_write_offset(handle, original_offset); 
+    }
+    bLoad = 1;
+    is_cali = 0;
+#endif /* !MIR3DA_OFFSET_TEMP_SOLUTION */
+    return res;
+}
+
+#if MIR3DA_AUTO_CALIBRATE
+#define STABLE_CHECK_SAMPLE_NUM     10
+#define STABLE_CHECK_THRESHOLD      50000
+#define AUTO_CALI_THRESHOLD_XY      300
+#define AUTO_CALI_THRESHOLD_Z       500
+static unsigned char    stable_sample_cnt = 0;
+static int              stable_sample_pow_sum[STABLE_CHECK_SAMPLE_NUM] = {0};
+static int              stable_sample_sum[3] = {0};
+
+static int mir3da_auto_cali_condition_confirm(int x, int y, int z, int ave_xyz[3])
+{
+    int    max = 0, min = 0;
+    int    i;
+	 int x_ok=0,y_ok=0,z_ok=0; 	
+    
+    stable_sample_pow_sum[stable_sample_cnt] = x*x + y*y + z*z;
+    stable_sample_sum[0] += x;
+    stable_sample_sum[1] += y;
+    stable_sample_sum[2] += z;
+    stable_sample_cnt++;
+    
+    MI_MSG("---stable_sample_cnt = %d", stable_sample_cnt);
+    
+    if( stable_sample_cnt < STABLE_CHECK_SAMPLE_NUM )
+        return -1;
+    stable_sample_cnt = 0;
+    
+    max = stable_sample_pow_sum[0];
+    min = stable_sample_pow_sum[0];
+    stable_sample_pow_sum[0] = 0;
+    for(i = 1; i < STABLE_CHECK_SAMPLE_NUM; i++){
+        if( stable_sample_pow_sum[i] > max )
+            max = stable_sample_pow_sum[i];
+        if( stable_sample_pow_sum[i] < min )
+            min = stable_sample_pow_sum[i];
+        stable_sample_pow_sum[i] = 0;
+    }
+    MI_MSG("---max = %d; min = %d", max, min);
+
+    ave_xyz[0] = stable_sample_sum[0]/STABLE_CHECK_SAMPLE_NUM;
+    stable_sample_sum[0] = 0;
+    ave_xyz[1] = stable_sample_sum[1]/STABLE_CHECK_SAMPLE_NUM;
+    stable_sample_sum[1] = 0;
+    ave_xyz[2] = stable_sample_sum[2]/STABLE_CHECK_SAMPLE_NUM;
+    stable_sample_sum[2] = 0;
+    
+    MI_MSG("ave_x = %d, ave_y = %d, ave_z = %d", ave_xyz[0], ave_xyz[1], ave_xyz[2]);
+	 x_ok =	(abs(ave_xyz[0]) < AUTO_CALI_THRESHOLD_XY) ? 1:0;
+	 y_ok =	(abs(ave_xyz[1]) < AUTO_CALI_THRESHOLD_XY) ? 1:0;
+	 z_ok =	(abs(abs(ave_xyz[2])-1024) < AUTO_CALI_THRESHOLD_Z) ? 1:0;
+        
+     if( (abs(max-min) > STABLE_CHECK_THRESHOLD) ||((x_ok + y_ok + z_ok) < 2) ) {
+        return -1;
+    }
+    return 0;
+}
+
+static int mir3da_auto_calibrate(MIR_HANDLE handle, int x, int y, int z)
+{
+    int     res = 0;
+    int     xyz[3] = {0};
+
+    if( is_cali )
+        return -1;
+    is_cali = 1;
+
+    if( mir3da_auto_cali_condition_confirm(x, y, z, xyz) ){
+        res = -1;
+        goto EXIT;
+    }
+    
+    /* restore original direction if last calibration was done in a wrong direction */
+    mir3da_write_offset(handle, original_offset);
+ 
+    res = mir3da_gsensor_drv.obj[gsensor_mod].auto_calibrate(handle, xyz); 
+    if (res != 0){
+	    MI_ERR("Calibrate failed !");
+	    mir3da_write_offset(handle, original_offset); 
+    }
+
+EXIT:    
+    is_cali = 0;
+
+    return res;
+}
+#endif /* !MIR3DA_AUTO_CALIBRATE */
+
+static int SOCLE_interrupt_ops(MIR_HANDLE handle, mir_int_ops_t *ops)
+{
+    int                 res = 0;
+    
+    switch(ops->type)
+    {
+        case INTERRUPT_OP_INIT:
+        
+            /* active level */
+            mir3da_register_mask_write(handle, SOCLE_REG_CTRL_REG6, (1<<1), (ops->data.init.level<<1));
+            /* latch */
+            mir3da_register_mask_write(handle, SOCLE_REG_CTRL_REG5, (1<<3), (ops->data.init.latch<<3));
+            mir3da_register_mask_write(handle, SOCLE_REG_CLICK_CFG, (1<<6), (ops->data.init.latch<<6));
+            
+            break;
+            
+        case INTERRUPT_OP_ENABLE:
+        
+            switch( ops->data.int_src )
+            {            
+                case INTERRUPT_ACTIVITY:
+                        
+                    mir3da_register_write(handle, SOCLE_REG_INT1_CFG, 0x7f);
+                    mir3da_register_write(handle, SOCLE_REG_INT2_CFG, 0x7f);
+                    break;
+                    
+                case INTERRUPT_CLICK:
+                    /* Enable all directions click and double click detect */
+                    mir3da_register_mask_write(handle, SOCLE_REG_CLICK_CFG, 0x3f, 0x3f);
+                    break;
+            }
+            break;
+            
+        case INTERRUPT_OP_CONFIG:
+        
+            switch( ops->data.cfg.int_src )
+            {
+                case INTERRUPT_ACTIVITY:
+                    
+                    if(ops->data.cfg.pin == INTERRUPT_PIN1) {
+                        /* enable this int on INT1 */
+                        mir3da_register_mask_write(handle, SOCLE_REG_CTRL_REG3, (1<<6), (1<<6));
+
+                        mir3da_register_mask_write(handle, SOCLE_REG_INT1_THS, 0x7f, ops->data.cfg.int_cfg.act.threshold);
+                        mir3da_register_mask_write(handle, SOCLE_REG_INT1_DURATION, 0x7f, ops->data.cfg.int_cfg.act.duration);
+                    }
+                    else if(ops->data.cfg.pin == INTERRUPT_PIN2) {
+                        /* enable this int on INT2 */
+                        mir3da_register_mask_write(handle, SOCLE_REG_CTRL_REG6, (1<<5), (1<<5));
+                        
+                        mir3da_register_mask_write(handle, SOCLE_REG_INT2_THS, 0x7f, ops->data.cfg.int_cfg.act.threshold);
+                        mir3da_register_mask_write(handle, SOCLE_REG_INT2_DURATION, 0x7f, ops->data.cfg.int_cfg.act.duration);
+                    }
+                    break;
+                    
+                case INTERRUPT_CLICK:
+                    
+                    mir3da_register_mask_write(handle, SOCLE_REG_CLICK_THS, 0x7f, ops->data.cfg.int_cfg.clk.threshold);
+                    mir3da_register_mask_write(handle, SOCLE_REG_TIME_LIMIT, 0x7f, ops->data.cfg.int_cfg.clk.click_time);
+                    mir3da_register_write(handle, SOCLE_REG_TIME_LATENCY, ops->data.cfg.int_cfg.clk.quiet_time);
+                    mir3da_register_write(handle, SOCLE_REG_TIME_WINDOW, ops->data.cfg.int_cfg.clk.window);
+                    
+                    if(ops->data.cfg.pin == INTERRUPT_PIN1) {
+                        mir3da_register_mask_write(handle, SOCLE_REG_CTRL_REG3, (1<<7), (1<<7));
+                    }
+                    else if(ops->data.cfg.pin == INTERRUPT_PIN2) {
+                        mir3da_register_mask_write(handle, SOCLE_REG_CTRL_REG6, (1<<7), (1<<7));
+                    }
+                    break;
+            }
+            break;
+            
+        case INTERRUPT_OP_DISABLE:
+            switch( ops->data.int_src )
+            {
+                case INTERRUPT_ACTIVITY:
+                        
+                    mir3da_register_write(handle, SOCLE_REG_INT1_CFG, 0);
+                    mir3da_register_write(handle, SOCLE_REG_INT2_CFG, 0);
+                    break;
+                    
+                case INTERRUPT_CLICK:
+                    /* Enable all directions click and double click detect */
+                    mir3da_register_mask_write(handle, SOCLE_REG_CLICK_CFG, 0x3f, 0);
+                    break;
+            }
+            break;
+            
+        default:
+            MI_ERR("Unsupport operation !");
+    }
+    
+    return res;
+}
+
+static int NSA_interrupt_ops(MIR_HANDLE handle, mir_int_ops_t *ops)
+{   
+    switch(ops->type)
+    {
+        case INTERRUPT_OP_INIT:
+        
+            /* latch */
+            mir3da_register_mask_write(handle, NSA_REG_INT_LATCH, 0x0f, ops->data.init.latch);
+            /* active level & output mode */
+            mir3da_register_mask_write(handle, NSA_REG_INT_PIN_CONFIG, 0x0f, ops->data.init.level|(ops->data.init.pin_mod<<1)|(ops->data.init.level<<2)|(ops->data.init.pin_mod<<3));
+            
+            break;
+            
+        case INTERRUPT_OP_ENABLE:
+            switch( ops->data.int_src )
+            { 
+                case INTERRUPT_ACTIVITY:
+                    /* Enable active interrupt */
+                    mir3da_register_mask_write(handle, NSA_REG_INTERRUPT_SETTINGS1, 0x07, 0x07);                    
+                    break;
+                case INTERRUPT_CLICK:
+                    /* Enable single and double tap detect */
+                    mir3da_register_mask_write(handle, NSA_REG_INTERRUPT_SETTINGS1, 0x30, 0x30);                   
+                    break;
+            }
+            break;
+            
+        case INTERRUPT_OP_CONFIG:
+            
+                            
+            switch( ops->data.cfg.int_src )
+            {
+                case INTERRUPT_ACTIVITY:
+                         
+                    mir3da_register_write(handle, NSA_REG_ACTIVE_THRESHOLD, ops->data.cfg.int_cfg.act.threshold);
+                    mir3da_register_mask_write(handle, NSA_REG_ACTIVE_DURATION, 0x03, ops->data.cfg.int_cfg.act.duration);
+                    
+                    /* Int mapping */
+                    if(ops->data.cfg.pin == INTERRUPT_PIN1) {  
+                        mir3da_register_mask_write(handle, NSA_REG_INTERRUPT_MAPPING1, (1<<2), (1<<2));
+                    }
+                    else if(ops->data.cfg.pin == INTERRUPT_PIN2) {
+                        mir3da_register_mask_write(handle, NSA_REG_INTERRUPT_MAPPING3, (1<<2), (1<<2));
+                    }
+                    break;
+                    
+                case INTERRUPT_CLICK:
+                    
+                    mir3da_register_mask_write(handle, NSA_REG_TAP_THRESHOLD, 0x1f, ops->data.cfg.int_cfg.clk.threshold);
+                    mir3da_register_mask_write(handle, NSA_REG_TAP_DURATION, (0x03<<5)|(0x07), (ops->data.cfg.int_cfg.clk.quiet_time<<7)|(ops->data.cfg.int_cfg.clk.click_time<<6)|(ops->data.cfg.int_cfg.clk.window));
+                    
+                    if(ops->data.cfg.pin == INTERRUPT_PIN1) {
+                        mir3da_register_mask_write(handle, NSA_REG_INTERRUPT_MAPPING1, 0x30, 0x30);
+                    }
+                    else if(ops->data.cfg.pin == INTERRUPT_PIN2) {
+                        mir3da_register_mask_write(handle, NSA_REG_INTERRUPT_MAPPING3, 0x30, 0x30);
+                    }
+                    break;
+            }
+            break;
+            
+        case INTERRUPT_OP_DISABLE:
+            switch( ops->data.int_src )
+            {
+                case INTERRUPT_ACTIVITY:
+                    /* Enable active interrupt */
+                    mir3da_register_mask_write(handle, NSA_REG_INTERRUPT_SETTINGS1, 0x07, 0x00);
+                    break;
+                    
+                case INTERRUPT_CLICK:
+                    /* Enable single and double tap detect */
+                    mir3da_register_mask_write(handle, NSA_REG_INTERRUPT_SETTINGS1, 0x30, 0x00);
+                    break;
+            }
+            break;
+            
+        default:
+            MI_ERR("Unsupport operation !");
+    }
+    return 0;
+}
+
+int mir3da_interrupt_ops(MIR_HANDLE handle, mir_int_ops_t *ops)
+{
+    int res = 0;
+    
+    res = mir3da_gsensor_drv.obj[gsensor_mod].int_ops(handle, ops);
+    return res;
+}
+
+#if FILTER_AVERAGE_ENHANCE
+int mir3da_get_filter_param(struct mir3da_filter_param_s* param){
+    if (param == 0){
+        MI_ERR("Invalid param!");
+        return -1;
+    }
+
+    param->filter_param_h = core_ctx.tFac[0].filter_param_h;
+    param->filter_param_l = core_ctx.tFac[0].filter_param_l;
+    param->filter_threhold = core_ctx.tFac[0].filter_threhold;
+
+    MI_MSG("FILTER param is get: filter_param_h = %d, filter_param_l = %d, filter_threhold = %d", param->filter_param_h, param->filter_param_l, param->filter_threhold);
+    
+    return 0;
+}
+
+int mir3da_set_filter_param(struct mir3da_filter_param_s* param){
+
+    if (param == 0){
+        MI_ERR("Invalid param!");
+        return -1;
+    }
+
+    MI_MSG("FILTER param is set: filter_param_h = %d, filter_param_l = %d, filter_threhold = %d", param->filter_param_h, param->filter_param_l, param->filter_threhold);
+
+    core_ctx.tFac[1].filter_param_l = core_ctx.tFac[2].filter_param_l = core_ctx.tFac[0].filter_param_l = param->filter_param_l;
+    core_ctx.tFac[1].filter_param_h =core_ctx.tFac[2].filter_param_h = core_ctx.tFac[0].filter_param_h  = param->filter_param_h;
+    core_ctx.tFac[1].filter_threhold = core_ctx.tFac[2].filter_threhold =core_ctx.tFac[0].filter_threhold = param->filter_threhold;
+
+    return 0;
+}
+#endif //#if FILTER_AVERAGE_ENHANCE
+
+int mir3da_get_enable(MIR_HANDLE handle, char *enable)
+{
+	unsigned char              reg_data;    
+    int             res = 0;
+ 
+    res = mir3da_register_read(handle, mir3da_gsensor_drv.obj[gsensor_mod].power.addr, &reg_data);
+    if(res != 0) {
+		return res;
+	}
+    
+     *enable = ( reg_data & mir3da_gsensor_drv.obj[gsensor_mod].power.mask ) ? 0 : 1;
+
+    return res;
+}
+
+int mir3da_set_enable(MIR_HANDLE handle, char enable)
+{
+    int             res = 0;
+    unsigned char              reg_data = 0;
+
+    if(!enable) {
+        reg_data = mir3da_gsensor_drv.obj[gsensor_mod].power.value;
+    }
+    
+    res = mir3da_register_mask_write(handle, mir3da_gsensor_drv.obj[gsensor_mod].power.addr, mir3da_gsensor_drv.obj[gsensor_mod].power.mask, reg_data);
+
+    return res;
+}
+
+static int SOCLE_get_reg_data(MIR_HANDLE handle, char *buf)
+{
+    int     i, count = 0;
+    unsigned char   val;
+    
+    count += mir3da_gsensor_drv.method->mysprintf(buf+count, "---------page 0---------");
+    for (i = 0; i <= 0x003d; i++){
+        if(i%16 == 0)
+            count += mir3da_gsensor_drv.method->mysprintf(buf+count, "\n%02x\t", i);
+        mir3da_register_read(handle, i, &val); 
+        count += mir3da_gsensor_drv.method->mysprintf(buf+count, "%02X ", val);
+    }
+
+    count += mir3da_gsensor_drv.method->mysprintf(buf+count, "\n---------page 1---------");
+    for (i = 0x0100; i <= 0x012a; i++){
+        if((i&0xff)%16 == 0)
+            count += mir3da_gsensor_drv.method->mysprintf(buf+count, "\n%02x\t", (i & 0xff));
+        mir3da_register_read(handle, i, &val); 
+        count += mir3da_gsensor_drv.method->mysprintf(buf+count, "%02X ", val);
+        
+    }
+    count += mir3da_gsensor_drv.method->mysprintf(buf+count, "\n---------end---------\n");
+    
+    return count;
+}
+
+static int NSA_get_reg_data(MIR_HANDLE handle, char *buf)
+{
+    int                 count = 0;
+    int                 i;
+    unsigned char       val;
+        
+    count += mir3da_gsensor_drv.method->mysprintf(buf+count, "---------start---------");
+    for (i = 0; i <= 0xd2; i++){
+        if(i%16 == 0)
+            count += mir3da_gsensor_drv.method->mysprintf(buf+count, "\n%02x\t", i);
+        mir3da_register_read(handle, i, &val); 
+        count += mir3da_gsensor_drv.method->mysprintf(buf+count, "%02X ", val);
+    }
+
+    count += mir3da_gsensor_drv.method->mysprintf(buf+count, "\n--------end---------\n");    
+    return count;
+}
+
+int mir3da_get_reg_data(MIR_HANDLE handle, char *buf)
+{     
+    return mir3da_gsensor_drv.obj[gsensor_mod].get_reg_data(handle, buf);
+}
+
+int mir3da_set_odr(MIR_HANDLE handle, int delay)
+{
+    int     res = 0;
+    int     odr = 0;
+
+    if(delay <= 5)
+    {
+       odr = MIR3DA_ODR_200HZ;
+    }
+    else if(delay <= 10)
+    {
+       odr = MIR3DA_ODR_100HZ;
+    }
+    else
+    {
+       odr = MIR3DA_ODR_50HZ;
+    }		
+
+    res = mir3da_register_mask_write(handle, mir3da_gsensor_drv.obj[gsensor_mod].odr_sect[odr].addr, 
+			mir3da_gsensor_drv.obj[gsensor_mod].odr_sect[odr].mask,mir3da_gsensor_drv.obj[gsensor_mod].odr_sect[odr].value);
+    if(res != 0) {
+        return res;
+    } 
+
+    return res;	
+}
+
+static int mir3da_soft_reset(MIR_HANDLE handle)
+{
+    int             res = 0;
+    unsigned char   reg_data;
+
+    reg_data = mir3da_gsensor_drv.obj[gsensor_mod].soft_reset.value;
+    res = mir3da_register_mask_write(handle, mir3da_gsensor_drv.obj[gsensor_mod].soft_reset.addr, mir3da_gsensor_drv.obj[gsensor_mod].soft_reset.mask, reg_data);
+    mir3da_gsensor_drv.method->msdelay(5);
+    
+    return res;
+}
+
+int mir3da_module_detect(PLAT_HANDLE handle)
+{
+    int             i, res = 0;
+    unsigned char   cid, mid;
+    int             is_find = -1;
+
+    /* Probe gsensor module */  
+    for(i=0;i<sizeof(mir3da_gsensor)/sizeof(mir3da_gsensor[0]);i++) {
+	if(i == 0){
+		mir3da_register_mask_write(handle,SOCLE_REG_SOFT_RESET,0xff,0xAA);
+	}
+    
+	mir3da_gsensor_drv.method->msdelay(5);
+        res = mir3da_register_read(handle, mir3da_gsensor[i].chip_id.addr, &cid);
+	    if(res != 0) {
+		    return res;
+	    }
+        
+        cid &= mir3da_gsensor[i].chip_id.mask;
+        if(mir3da_gsensor[i].chip_id.value == cid) {
+            res = mir3da_register_read(handle, mir3da_gsensor[i].mod_id.addr, &mid);
+	        if(res != 0) {
+		        return res;
+	        }
+
+            mid &= mir3da_gsensor[i].mod_id.mask;
+            if( mir3da_gsensor[i].mod_id.value == mid ){
+                MI_MSG("Found Gsensor MIR3DA !");
+                gsensor_mod = i;
+                is_find =0;
+                break;
+            }
+        }
+    }
+
+    if(gsensor_mod != 1){
+		gsensor_mod = 0;
+		return 0;
+    }
+    return is_find;
+}
+
+int mir3da_install_general_ops(struct general_op_s *ops)
+{    
+    if(0 == ops){
+        return -1;
+    }
+    
+    mir3da_gsensor_drv.method = ops;
+    return 0;
+}
+
+MIR_HANDLE mir3da_core_init(PLAT_HANDLE handle)
+{
+    int             res = 0;
+    unsigned char   data;
+    int 	    count = 0;
+#if FILTER_AVERAGE_ENHANCE 
+int i =0;
+#endif
+
+    mir3da_gsensor_drv.obj = mir3da_gsensor;
+    while(count < 6)
+    {
+	count ++;
+	//mir3da_gsensor_drv.method->msdelay(5);
+    	if(gsensor_mod < 0){
+        	res = mir3da_module_detect(handle);
+        	if(res) {
+	     		MI_ERR("Can't find Mir3da gsensor!!");	
+            		continue ;
+        	}	
+
+        	/* No miramems gsensor instance found */
+        	if(gsensor_mod < 0) {   
+            		continue;
+        	}
+		else
+			break;
+    	}
+    }
+    
+    if(count >= 6)
+	return 0;
+
+    MI_MSG("Probe gsensor module: %s", mir3da_gsensor[gsensor_mod].asic);
+
+#if MIR3DA_SENS_TEMP_SOLUTION
+    if(GSENSOR_MOD_SOCLE == gsensor_mod) {
+        mir3da_register_read(handle, SOCLE_REG_OTP_TRIM_THERM_H, &data);
+        if (data == 2){
+            MI_ERR("Enable sens temp solution !");
+            bSensZoom = 1;
+        }
+    }
+#endif
+
+#if FILTER_AVERAGE_ENHANCE 
+    /* configure default filter param */    
+    for (i = 0; i < 3;i++){     
+        core_ctx.tFac[i].filter_param_l = 2;
+        core_ctx.tFac[i].filter_param_h = 8;
+        core_ctx.tFac[i].filter_threhold = 60;
+
+        core_ctx.tFac[i].refN_l = 0;
+        core_ctx.tFac[i].refN_h = 0;
+    }    
+#endif
+
+	res = mir3da_chip_resume(handle);
+	if(res) {
+		MI_ERR("chip resume fail!!\n");
+		return 0;
+	}
+
+    return handle;
+}
+
+int mir3da_chip_resume(MIR_HANDLE handle)
+{
+    int     res = 0;
+    unsigned char      reg_data;
+    unsigned char      i = 0;
+	
+    res = mir3da_soft_reset(handle); 
+    if(res) {
+        MI_ERR("Do softreset failed !");
+        return res;
+    }
+    
+    for(i=0;i<MIR3DA_INIT_SECT_LEN;i++) {
+        if( mir3da_gsensor_drv.obj[gsensor_mod].init_sect[i].addr < 0 ) {
+            break;
+        }
+
+        reg_data = mir3da_gsensor_drv.obj[gsensor_mod].init_sect[i].value;
+        res = mir3da_register_mask_write(handle, mir3da_gsensor_drv.obj[gsensor_mod].init_sect[i].addr, mir3da_gsensor_drv.obj[gsensor_mod].init_sect[i].mask, reg_data);
+        if(res != 0) {
+            return res;
+        } 
+    }
+	
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+    res = mir3da_read_offset(handle, original_offset);
+    if (res != 0){
+        MI_ERR("Read offset failed !");
+        return res;    
+    }
+	
+    bLoad = 0;
+		readOffsetCnt = -1;    
+    manual_load_cali_file(handle);
+#endif
+
+    return res;
+}
+
+int mir3da_get_primary_offset(MIR_HANDLE handle,int *x,int *y,int *z){
+    int     res = 0;
+    unsigned char      reg_data;
+    unsigned char      i = 0;
+    unsigned char      offset[9]={0};
+
+    res = mir3da_read_offset(handle, offset);
+    if (res != 0){
+        MI_ERR("Read offset failed !");
+        return -1;    
+    }
+	
+    res = mir3da_soft_reset(handle); 
+    if(res) {
+        MI_ERR("Do softreset failed !");
+        return -1;
+    }
+    
+    for(i=0;i<MIR3DA_INIT_SECT_LEN;i++) {
+        if( mir3da_gsensor_drv.obj[gsensor_mod].init_sect[i].addr < 0 ) {
+            break;
+        }
+
+        reg_data = mir3da_gsensor_drv.obj[gsensor_mod].init_sect[i].value;
+        res = mir3da_register_mask_write(handle, mir3da_gsensor_drv.obj[gsensor_mod].init_sect[i].addr, mir3da_gsensor_drv.obj[gsensor_mod].init_sect[i].mask, reg_data);
+        if(res != 0) {
+            MI_ERR("Write register[0x%x] error!",mir3da_gsensor_drv.obj[gsensor_mod].init_sect[i].addr);
+            goto EXIT;
+        } 
+    }
+
+    mir3da_gsensor_drv.method->msdelay(100);		
+
+    res = cycle_read_xyz(handle, x, y, z, 20);
+    if (res){
+            MI_ERR("i2c block read failed\n");
+            goto EXIT;
+    }
+
+    mir3da_write_offset(handle, offset);
+
+    return 0; 
+
+EXIT:
+    mir3da_write_offset(handle, offset);
+    return -1;
+}
diff --git a/drivers/input/misc/gsensor/mir3da/mir3da_core.h b/drivers/input/misc/gsensor/mir3da/mir3da_core.h
new file mode 100755
index 0000000..36554c0
--- /dev/null
+++ b/drivers/input/misc/gsensor/mir3da/mir3da_core.h
@@ -0,0 +1,321 @@
+/* Core header for MiraMEMS 3-Axis Accelerometer's driver. 
+ * 
+ * mir3da_core.h - Linux kernel modules for MiraMEMS 3-Axis Accelerometer
+ *
+ * Copyright (C) 2011-2013 MiraMEMS Sensing Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MIR3DA_CORE_H__
+#define __MIR3DA_CORE_H__
+
+#define CUST_VER                            ""                                          /* for Custom debug version */
+#define CORE_VER                            "1.4.2_2014-08-19-17:30:00_"CUST_VER
+ 
+#define MIR3DA_SUPPORT_CHIP_LIST            MIR_SOCLE, MIR_NSA_NTO, MIR_NSA_MLM
+ 
+#define MIR3DA_BUFSIZE                      256
+
+#define MIR3DA_STK_TEMP_SOLUTION            1
+#define MIR3DA_OFFSET_TEMP_SOLUTION         1
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+#define MIR3DA_AUTO_CALIBRATE               0
+#else
+#define MIR3DA_AUTO_CALIBRATE               0
+#endif /* !MIR3DA_OFFSET_TEMP_SOLUTION */
+#define MIR3DA_SENS_TEMP_SOLUTION           1
+#define FILTER_AVERAGE_ENHANCE              1
+#define FILTER_AVERAGE_EX                   1
+
+#define MIR3DA_OFFSET_LEN                   9
+
+typedef void*   MIR_HANDLE;
+typedef void*   PLAT_HANDLE;
+
+
+struct serial_manage_if_s {
+    
+    int                         (*read)(PLAT_HANDLE handle, unsigned char addr, unsigned char *data);
+    int                         (*write)(PLAT_HANDLE handle, unsigned char addr, unsigned char data);
+    int                         (*read_block)(PLAT_HANDLE handle, unsigned char base_addr, unsigned char count, unsigned char *data);
+};
+
+struct general_op_s {
+
+    struct serial_manage_if_s   smi;
+    
+    int                         (*data_save)(unsigned char *data);
+    int                         (*data_get)(unsigned char *data);
+    
+    int                         (*myprintf)(const char *fmt, ...);
+    int                         (*mysprintf)(char *buf, const char *fmt, ...);
+    void                        (*msdelay)(int ms);                        
+};  
+
+#define MIR_GENERAL_OPS_DECLARE(OPS_HDL, SMI_RD, SMI_RDBL, SMI_WR, DAT_SAVE, DAT_GET, MDELAY, MYPRINTF, MYSPRINTF)                                      \
+                                                                                                                                                        \
+                                struct general_op_s     OPS_HDL = { { SMI_RD, SMI_WR, SMI_RDBL }, DAT_SAVE, DAT_GET, MYPRINTF, MYSPRINTF, MDELAY }
+                                        
+enum interrupt_src {
+
+    INTERRUPT_ACTIVITY     = 1,
+    INTERRUPT_CLICK,
+
+};
+
+typedef enum _int_op_type {
+
+    INTERRUPT_OP_INIT,
+    INTERRUPT_OP_ENABLE,
+    INTERRUPT_OP_CONFIG,
+    INTERRUPT_OP_DISABLE,
+ 
+} mir_int_op_type;
+
+enum interrupt_pin {
+
+    INTERRUPT_PIN1,
+    INTERRUPT_PIN2,
+};
+
+enum pin_output_mode {
+
+    OUTPUT_MOD_PULL_PUSH,
+    OUTPUT_MOD_OD,
+};
+
+struct int_act_cfg_s {
+
+    unsigned char           threshold;
+    unsigned char           duration;
+};
+
+struct int_clk_cfg_s {
+
+    unsigned char                   threshold;
+    unsigned char                   click_time;     /* click time */
+    unsigned char                   quiet_time;     /* quiet time after click */
+    unsigned char                   window;         /* for second click time window */
+};
+
+typedef union _int_src_configuration {
+    
+    struct int_act_cfg_s            act;
+    struct int_clk_cfg_s            clk;
+
+} mir_int_src_cfg_t;
+    
+typedef struct _int_configuration {
+
+    enum interrupt_pin              pin;
+    enum interrupt_src              int_src;
+    
+    mir_int_src_cfg_t               int_cfg;  
+    
+} mir_int_cfg_t;
+
+typedef struct _int_init_data {
+
+    enum pin_output_mode            pin_mod;
+
+    unsigned char                   level;      /* 1: high active, 0: low active */
+    unsigned char                   latch;          /* >0: latch time, 0: no latch */
+     
+} mir_int_init_t ;
+
+typedef union _int_op_data {
+
+    enum interrupt_src              int_src;
+ 
+    mir_int_init_t                  init;
+    mir_int_cfg_t                   cfg;
+    
+} mir_int_op_data;
+
+typedef struct _int_operations {
+
+    mir_int_op_type                 type;
+    mir_int_op_data                 data;
+    
+} mir_int_ops_t;
+
+
+/* Register Define for SOCLE asic */
+#define SOCLE_REG_SOFT_RESET            0x0105
+#define SOCLE_REG_LDO_REG               0x0006
+#define SOCLE_REG_WHO_AM_I              0x000f
+#define SOCLE_REG_TEMP_CFG_REG          0x001f
+#define SOCLE_REG_CTRL_REG1             0x0020
+#define SOCLE_REG_CTRL_REG3             0X0022
+#define SOCLE_REG_CTRL_REG4             0x0023
+#define SOCLE_REG_CTRL_REG5             0x0024
+#define SOCLE_REG_CTRL_REG6             0x0025
+#define SOCLE_REG_STATUS_REG            0x0027
+#define SOCLE_REG_OUT_X_L               0x0028
+#define SOCLE_REG_OUT_X_H               0x0029
+#define SOCLE_REG_OUT_Y_L               0x002A
+#define SOCLE_REG_OUT_Y_H               0x002B
+#define SOCLE_REG_OUT_Z_L               0x002C
+#define SOCLE_REG_OUT_Z_H               0x002D
+#define SOCLE_REG_INT1_CFG              0x0030
+#define SOCLE_REG_INT1_SRC              0x0031
+#define SOCLE_REG_INT1_THS              0x0032
+#define SOCLE_REG_INT1_DURATION         0x0033
+#define SOCLE_REG_INT2_CFG              0x0034
+#define SOCLE_REG_INT2_SRC              0x0035
+#define SOCLE_REG_INT2_THS              0x0036
+#define SOCLE_REG_INT2_DURATION         0x0037
+#define SOCLE_REG_CLICK_CFG             0x0038
+#define SOCLE_REG_CLICK_SRC             0x0039
+#define SOCLE_REG_CLICK_THS             0x003A
+#define SOCLE_REG_TIME_LIMIT            0x003B
+#define SOCLE_REG_TIME_LATENCY          0x003C
+#define SOCLE_REG_TIME_WINDOW           0x003D
+#define SOCLE_REG_OTP_XOFF_L            0x0110
+#define SOCLE_REG_OTP_XOFF_H            0x0111
+#define SOCLE_REG_OTP_YOFF_L            0x0112
+#define SOCLE_REG_OTP_YOFF_H            0x0113
+#define SOCLE_REG_OTP_ZOFF_L            0x0114
+#define SOCLE_REG_OTP_ZOFF_H            0x0115
+#define SOCLE_REG_OTP_XSO               0x0116
+#define SOCLE_REG_OTP_YSO               0x0117
+#define SOCLE_REG_OTP_ZSO               0x0118
+#define SOCLE_REG_OTP_TRIM_OSC          0x011b
+#define SOCLE_REG_LPF_ABSOLUTE          0x011c
+#define SOCLE_REG_TEMP_OFF1             0x0127
+#define SOCLE_REG_TEMP_OFF2             0x0128
+#define SOCLE_REG_TEMP_OFF3             0x0129
+#define SOCLE_REG_OTP_TRIM_THERM_H      0x011a
+                                         
+                                                        
+/* Register define for NSA asic */
+#define NSA_REG_SPI_I2C                 0x00
+#define NSA_REG_WHO_AM_I                0x01
+#define NSA_REG_ACC_X_LSB               0x02
+#define NSA_REG_ACC_X_MSB               0x03
+#define NSA_REG_ACC_Y_LSB               0x04
+#define NSA_REG_ACC_Y_MSB               0x05
+#define NSA_REG_ACC_Z_LSB               0x06
+#define NSA_REG_ACC_Z_MSB               0x07 
+#define NSA_REG_G_RANGE                 0x0f
+#define NSA_REG_ODR_AXIS_DISABLE        0x10
+#define NSA_REG_POWERMODE_BW            0x11
+#define NSA_REG_SWAP_POLARITY           0x12
+#define NSA_REG_FIFO_CTRL               0x14
+#define NSA_REG_INTERRUPT_SETTINGS1     0x16
+#define NSA_REG_INTERRUPT_SETTINGS2     0x17
+#define NSA_REG_INTERRUPT_MAPPING1      0x19
+#define NSA_REG_INTERRUPT_MAPPING2      0x1a
+#define NSA_REG_INTERRUPT_MAPPING3      0x1b
+#define NSA_REG_INT_PIN_CONFIG          0x20
+#define NSA_REG_INT_LATCH               0x21
+#define NSA_REG_ACTIVE_DURATION         0x27
+#define NSA_REG_ACTIVE_THRESHOLD        0x28
+#define NSA_REG_TAP_DURATION            0x2A
+#define NSA_REG_TAP_THRESHOLD           0x2B
+#define NSA_REG_CUSTOM_OFFSET_X         0x38
+#define NSA_REG_CUSTOM_OFFSET_Y         0x39
+#define NSA_REG_CUSTOM_OFFSET_Z         0x3a
+#define NSA_REG_ENGINEERING_MODE        0x7f
+#define NSA_REG_SENSITIVITY_TRIM_X      0x80
+#define NSA_REG_SENSITIVITY_TRIM_Y      0x81
+#define NSA_REG_SENSITIVITY_TRIM_Z      0x82
+#define NSA_REG_COARSE_OFFSET_TRIM_X    0x83
+#define NSA_REG_COARSE_OFFSET_TRIM_Y    0x84
+#define NSA_REG_COARSE_OFFSET_TRIM_Z    0x85
+#define NSA_REG_FINE_OFFSET_TRIM_X      0x86
+#define NSA_REG_FINE_OFFSET_TRIM_Y      0x87
+#define NSA_REG_FINE_OFFSET_TRIM_Z      0x88
+#define NSA_REG_SENS_COMP               0x8c
+#define NSA_REG_SENS_COARSE_TRIM        0xd1
+                                         
+#define MIR3DA_ODR_50HZ                  0
+#define MIR3DA_ODR_100HZ                 1
+#define MIR3DA_ODR_200HZ                 2
+
+#define MI_TAG                          "[MIR3DA] "
+enum{
+	DEBUG_ERR=1,
+	DEBUG_ASSERT=1<<1,	
+	DEBUG_MSG=1<<2,
+	DEBUG_FUNC=1<<3,
+	DEBUG_DATA=1<<4,
+};
+
+/* register operation */
+int mir3da_register_read(MIR_HANDLE handle, short reg, unsigned char *data);
+int mir3da_register_write(MIR_HANDLE handle, short reg, unsigned char data);
+int mir3da_register_read_continuously(MIR_HANDLE handle, short base_reg, unsigned char count, unsigned char *data);
+int mir3da_register_mask_write(MIR_HANDLE handle, short addr, unsigned char mask, unsigned char data);
+
+int mir3da_install_general_ops(struct general_op_s *ops);	
+/* chip init */
+int mir3da_module_detect(PLAT_HANDLE handle);
+MIR_HANDLE mir3da_core_init(PLAT_HANDLE handle);
+
+/* data polling */
+int mir3da_read_data(MIR_HANDLE handle, short *x, short *y, short *z);
+
+/* filter configure */
+#if FILTER_AVERAGE_ENHANCE
+struct mir3da_filter_param_s{
+    int filter_param_l;
+    int filter_param_h;
+    int filter_threhold;
+};
+
+int mir3da_get_filter_param(struct mir3da_filter_param_s* param);
+int mir3da_set_filter_param(struct mir3da_filter_param_s* param);
+#endif
+
+#if MIR3DA_STK_TEMP_SOLUTION
+extern char bxstk;
+extern char bystk;
+extern char bzstk;
+extern  int squareRoot(int val);
+#endif
+
+enum {
+    GSENSOR_MOD_SOCLE = 0,
+    GSENSOR_MOD_NSA_NTO,
+    GSENSOR_MOD_NSA_MLM,
+};
+
+//static int  gsensor_mod;        /* Initial value */
+
+/* CALI */
+int mir3da_calibrate(MIR_HANDLE handle, int z_dir);
+
+/* calibration */
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+extern char bLoad;
+void manual_load_cali_file(MIR_HANDLE handle);
+#endif
+
+/* Interrupt operations */
+int mir3da_interrupt_ops(MIR_HANDLE handle, mir_int_ops_t *ops);
+
+int cycle_read_xyz(MIR_HANDLE handle, int* x, int* y, int* z, int ncycle);
+
+int mir3da_read_offset(MIR_HANDLE handle, unsigned char* offst);
+int mir3da_write_offset(MIR_HANDLE handle, unsigned char* offset);
+
+int mir3da_set_enable(MIR_HANDLE handle, char bEnable);
+int mir3da_get_enable(MIR_HANDLE handle, char *bEnable);
+int mir3da_get_reg_data(MIR_HANDLE handle, char *buf);
+int mir3da_set_odr(MIR_HANDLE handle, int delay);
+
+int mir3da_chip_resume(MIR_HANDLE handle);
+int mir3da_get_primary_offset(MIR_HANDLE handle,int *x,int *y,int *z);
+#endif    /* __MIR3DA_CORE_H__ */
+
+
diff --git a/drivers/input/misc/gsensor/mir3da/mir3da_cust.c b/drivers/input/misc/gsensor/mir3da/mir3da_cust.c
new file mode 100755
index 0000000..c1d6099
--- /dev/null
+++ b/drivers/input/misc/gsensor/mir3da/mir3da_cust.c
@@ -0,0 +1,1114 @@
+/* For ACTIONS android platform.
+ * 
+ * mir3da.c - Linux kernel modules for 3-Axis Accelerometer
+ *
+ * Copyright (C) 2011-2013 MiraMEMS Sensing Technology Co., Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/input-polldev.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/syscalls.h>
+#include <asm/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/hrtimer.h>  
+#include <linux/ktime.h> 
+//#include "../gsensor_common.h"
+#include "mir3da_core.h"
+#include "mir3da_cust.h"
+
+#define MI_DATA(format, ...)            if(DEBUG_DATA&Log_level){printk(KERN_ERR MI_TAG format "\n", ## __VA_ARGS__);}
+#define MI_MSG(format, ...)             if(DEBUG_MSG&Log_level){printk(KERN_ERR MI_TAG format "\n", ## __VA_ARGS__);}
+#define MI_ERR(format, ...)             if(DEBUG_ERR&Log_level){printk(KERN_ERR MI_TAG format "\n", ## __VA_ARGS__);}
+#define MI_FUN                          if(DEBUG_FUNC&Log_level){printk(KERN_ERR MI_TAG "%s is called, line: %d\n", __FUNCTION__,__LINE__);}
+#define MI_ASSERT(expr)              	if (!(expr)) {printk(KERN_ERR "Assertion failed! %s,%d,%s,%s\n",__FILE__, __LINE__, __func__, #expr);}
+//  for XML config
+//#if CFG_GSENSOR_USE_CONFIG
+#define CFG_GSENSOR_ADAP_ID          "gsensor.i2c_adap_id"
+#define CFG_GSENSOR_POSITION         "gsensor.position"
+#define CFG_GSENSOR_CALIBRATION   "gsensor.calibration"
+#define CFG_GSENSOR_MOD_POSITION    "gsensor_"MIR3DA_DRV_NAME".position"
+
+//extern int get_config(const char *key, char *buff, int len);*/
+//#endif
+//#define CFG_GSENSOR_CALIBRATION      "gsensor.calibration"
+#define CFG_GSENSOR_USE_CONFIG				1
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+#define MIR3DA_AUTO_CALIBRAE 0
+
+#define MIR3DA_HRTIMER 1
+
+struct mir3da_acc{
+    int    x;
+    int    y;
+    int    z;
+} ;
+
+struct mir3da_data {
+    struct i2c_client *mir3da_client;
+    struct input_dev *input;
+    atomic_t delay;
+    atomic_t enable;
+    struct mutex enable_mutex;
+    struct hrtimer hr_timer;
+    struct workqueue_struct *wq;
+    struct delayed_work work;
+    atomic_t position;
+    atomic_t calibrated;
+    struct mir3da_acc offset;
+};
+
+static MIR_HANDLE             		mir_handle;
+extern int                           	Log_level;
+//static struct i2c_board_info            mir3da_i2c_boardinfo = { I2C_BOARD_INFO(MIR3DA_DRV_NAME, MIR3DA_I2C_ADDR) };
+
+/**************************************************************************/
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+static char OffsetFileName[] = "/data/miraGSensorOffset.txt";
+#define OFFSET_STRING_LEN               26
+struct work_info
+{
+    char        tst1[20];
+    char        tst2[20];
+    char        buffer[OFFSET_STRING_LEN];
+    struct      workqueue_struct *wq;
+    struct      delayed_work read_work;
+    struct      delayed_work write_work;
+    struct      completion completion;
+    int         len;
+    int         rst;
+};
+/**************************************************************************/
+static struct work_info m_work_info = {{0}};
+static void sensor_write_work( struct work_struct *work )
+{
+    struct work_info*   pWorkInfo;
+    struct file         *filep;
+    u32                 orgfs;
+    int                 ret;   
+
+    orgfs = get_fs();
+    set_fs(KERNEL_DS);
+
+    pWorkInfo = container_of((struct delayed_work*)work, struct work_info, write_work);
+    if (pWorkInfo == NULL){            
+            MI_ERR("get pWorkInfo failed!");       
+            return;
+    }
+    
+    filep = filp_open(OffsetFileName, O_RDWR|O_CREAT, 0600);
+    if (IS_ERR(filep)){
+        MI_ERR("write, sys_open %s error!!.\n", OffsetFileName);
+        ret =  -1;
+    }
+    else
+    {   
+        filep->f_op->write(filep, pWorkInfo->buffer, pWorkInfo->len, &filep->f_pos);
+        filp_close(filep, NULL);
+        ret = 0;        
+    }
+    
+    set_fs(orgfs);   
+    pWorkInfo->rst = ret;
+    complete( &pWorkInfo->completion );
+}
+/**************************************************************************/
+static void sensor_read_work( struct work_struct *work )
+{
+    u32 orgfs;
+    struct file *filep;
+    int ret; 
+    struct work_info* pWorkInfo;
+        
+    orgfs = get_fs();
+    set_fs(KERNEL_DS);
+    
+    pWorkInfo = container_of((struct delayed_work*)work, struct work_info, read_work);
+    if (pWorkInfo == NULL){            
+        MI_ERR("get pWorkInfo failed!");       
+        return;
+    }
+ 
+    filep = filp_open(OffsetFileName, O_RDONLY, 0600);
+    if (IS_ERR(filep)){
+        //MI_ERR("read, sys_open %s error!!.\n",OffsetFileName);
+        set_fs(orgfs);
+        ret =  -1;
+    }
+    else{
+        filep->f_op->read(filep, pWorkInfo->buffer,  sizeof(pWorkInfo->buffer), &filep->f_pos);
+        filp_close(filep, NULL);    
+        set_fs(orgfs);
+        ret = 0;
+    }
+
+    pWorkInfo->rst = ret;
+    MI_MSG("pWorkInfo->rst = %d\n", pWorkInfo->rst );
+    complete( &(pWorkInfo->completion) );
+}
+/**************************************************************************/
+static int sensor_sync_read(u8* offset)
+{
+    int     err;
+    int     off[MIR3DA_OFFSET_LEN] = {0};
+    struct work_info* pWorkInfo = &m_work_info;
+     
+    init_completion( &pWorkInfo->completion );
+    queue_delayed_work( pWorkInfo->wq, &pWorkInfo->read_work, msecs_to_jiffies(0) );
+    err = wait_for_completion_timeout( &pWorkInfo->completion, msecs_to_jiffies( 2000 ) );
+    if ( err == 0 ){
+        MI_ERR("wait_for_completion_timeout TIMEOUT");
+        return -1;
+    }
+
+    if (pWorkInfo->rst != 0){
+        //MI_ERR("work_info.rst  not equal 0");
+        return pWorkInfo->rst;
+    }
+    
+    sscanf(m_work_info.buffer, "%x,%x,%x,%x,%x,%x,%x,%x,%x", &off[0], &off[1], &off[2], &off[3], &off[4], &off[5],&off[6], &off[7], &off[8]);
+
+    offset[0] = (u8)off[0];
+    offset[1] = (u8)off[1];
+    offset[2] = (u8)off[2];
+    offset[3] = (u8)off[3];
+    offset[4] = (u8)off[4];
+    offset[5] = (u8)off[5];
+    offset[6] = (u8)off[6];
+    offset[7] = (u8)off[7];
+    offset[8] = (u8)off[8];
+    
+    return 0;
+}
+/**************************************************************************/
+static int sensor_sync_write(u8* off)
+{
+    int err = 0;
+    struct work_info* pWorkInfo = &m_work_info;
+       
+    init_completion( &pWorkInfo->completion );
+    
+    sprintf(m_work_info.buffer, "%x,%x,%x,%x,%x,%x,%x,%x,%x\n", off[0],off[1],off[2],off[3],off[4],off[5],off[6],off[7],off[8]);
+    
+    pWorkInfo->len = sizeof(m_work_info.buffer);
+        
+    queue_delayed_work( pWorkInfo->wq, &pWorkInfo->write_work, msecs_to_jiffies(0) );
+    err = wait_for_completion_timeout( &pWorkInfo->completion, msecs_to_jiffies( 2000 ) );
+    if ( err == 0 ){
+        MI_ERR("wait_for_completion_timeout TIMEOUT");
+        return -1;
+    }
+
+    if (pWorkInfo->rst != 0){
+        //MI_ERR("work_info.rst  not equal 0");
+        return pWorkInfo->rst;
+    }
+    
+    return 0;
+}
+#endif
+/**************************************************************************/
+#if MIR3DA_AUTO_CALIBRAE
+static bool check_califile_exist(void)
+{
+    u32     orgfs = 0;
+    struct  file *filep;
+        
+    orgfs = get_fs();
+    set_fs(KERNEL_DS);
+
+    filep = filp_open(OffsetFileName, O_RDONLY, 0600);
+    if (IS_ERR(filep)) {
+        //MI_ERR("%s read, sys_open %s error!!.\n",__func__,OffsetFileName);
+        set_fs(orgfs);
+        return false;
+    }
+
+    filp_close(filep, NULL);    
+    set_fs(orgfs); 
+
+    return true;
+}
+#endif
+/**************************************************************************/
+static ssize_t mir3da_enable_show(struct device *dev,
+                   struct device_attribute *attr, char *buf)
+{
+    int             ret;
+    char            bEnable;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);	
+	
+    ret = mir3da_get_enable(mir3da->mir3da_client, &bEnable);    
+    if (ret < 0){
+        ret = -EINVAL;
+    }
+    else{
+        ret = sprintf(buf, "%d\n", bEnable);
+    }
+
+    return ret;
+}
+/**************************************************************************/
+static void mir3da_do_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+    int pre_enable = atomic_read(&mir3da->enable);
+
+    mutex_lock(&mir3da->enable_mutex);
+
+    MI_MSG("%s:enable =%d pre_enable=%d\n",__func__,enable,pre_enable);
+
+    if (enable != pre_enable) {
+    	mir3da_set_enable(mir3da->mir3da_client, enable);
+        
+    	if(enable){
+        #if (MIR3DA_HRTIMER == 0)
+            queue_delayed_work(mir3da->wq, &mir3da->work, msecs_to_jiffies(0));
+        #else
+            hrtimer_start(&mir3da->hr_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+        #endif
+    	}else{
+    	#if MIR3DA_HRTIMER
+    	    hrtimer_cancel(&mir3da->hr_timer);
+        #endif
+            cancel_delayed_work_sync(&mir3da->work);
+    	}
+        
+        atomic_set(&mir3da->enable, enable);
+    }
+    mutex_unlock(&mir3da->enable_mutex);
+}
+/**************************************************************************/
+static ssize_t mir3da_enable_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    unsigned long data=0;
+    int error=0;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if ((data == 0) || (data == 1))
+        mir3da_do_enable(dev, data);
+
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_delay_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&mir3da->delay));
+}
+/**************************************************************************/
+static ssize_t mir3da_delay_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long data=0;
+    int error=0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&mir3da->delay, (unsigned int) data);
+
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_axis_data_show(struct device *dev,
+           struct device_attribute *attr, char *buf)
+{
+    int result;
+    short x,y,z;
+    int count = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);	
+	
+    result = mir3da_read_data(mir3da->mir3da_client, &x, &y, &z);
+    if (result == 0)
+        count += sprintf(buf+count, "x= %d;y=%d;z=%d\n", x,y,z);
+    else
+        count += sprintf(buf+count, "reading failed!");
+
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_reg_data_store(struct device *dev,
+           struct device_attribute *attr, const char *buf, size_t count)
+{
+    int                 addr, data;
+    int                 result;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);	
+	
+    sscanf(buf, "0x%x, 0x%x\n", &addr, &data);
+    
+    result = mir3da_register_write(mir3da->mir3da_client, addr, data);
+    
+    MI_ASSERT(result==0);
+
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_reg_data_show(struct device *dev,
+           struct device_attribute *attr, char *buf)
+{
+    MIR_HANDLE          handle = mir_handle;
+        
+    return mir3da_get_reg_data(handle, buf);
+}
+/**************************************************************************/
+static ssize_t mir3da_offset_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    ssize_t count = 0;
+    int rst = 0;
+    u8 off[9] = {0};
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);	
+	
+    rst = mir3da_read_offset(mir3da->mir3da_client, off);
+    if (!rst){
+        count = sprintf(buf, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n", off[0],off[1],off[2],off[3],off[4],off[5],off[6],off[7],off[8]);
+    }
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_offset_store(struct device *dev, struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    int off[9] = {0};
+    u8  offset[9] = {0};
+    int rst = 0;
+	
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);	
+	
+    sscanf(buf, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n", &off[0], &off[1], &off[2], &off[3], &off[4], &off[5],&off[6], &off[7], &off[8]);
+
+    offset[0] = (u8)off[0];
+    offset[1] = (u8)off[1];
+    offset[2] = (u8)off[2];
+    offset[3] = (u8)off[3];
+    offset[4] = (u8)off[4];
+    offset[5] = (u8)off[5];
+    offset[6] = (u8)off[6];
+    offset[7] = (u8)off[7];
+    offset[8] = (u8)off[8];
+
+    rst = mir3da_write_offset(mir3da->mir3da_client, offset);
+    return count;
+}
+/**************************************************************************/
+#if FILTER_AVERAGE_ENHANCE
+static ssize_t mir3da_average_enhance_show(struct device *dev,
+                   struct device_attribute *attr, char *buf)
+{
+    int                             ret = 0;
+    struct mir3da_filter_param_s    param = {0};
+
+    ret = mir3da_get_filter_param(&param);
+    ret |= sprintf(buf, "%d %d %d\n", param.filter_param_l, param.filter_param_h, param.filter_threhold);
+
+    return ret;
+}
+/**************************************************************************/
+static ssize_t mir3da_average_enhance_store(struct device *dev,struct device_attribute *attr,const char *buf, size_t count)
+{ 
+    int                             ret = 0;
+    struct mir3da_filter_param_s    param = {0};
+    
+    sscanf(buf, "%d %d %d\n", &param.filter_param_l, &param.filter_param_h, &param.filter_threhold);
+    
+    ret = mir3da_set_filter_param(&param);
+    
+    return count;
+}
+#endif 
+/**************************************************************************/
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+int bCaliResult = -1;
+static ssize_t mir3da_calibrate_show(struct device *dev,struct device_attribute *attr,char *buf)
+{
+    int ret;       
+
+    ret = sprintf(buf, "%d\n", bCaliResult);   
+    return ret;
+}
+/**************************************************************************/
+static ssize_t mir3da_calibrate_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    s8              z_dir = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);	
+    
+    z_dir = simple_strtol(buf, NULL, 10);
+    bCaliResult = mir3da_calibrate(mir3da->mir3da_client, z_dir);
+    
+    return count;
+}
+#endif
+/**************************************************************************/
+static ssize_t mir3da_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+    struct mir3da_acc acc;
+
+    cycle_read_xyz(mir3da->mir3da_client,&(acc.x),&(acc.y),&(acc.z),20);	
+
+    mir3da->offset.x = 0 - acc.x;
+    mir3da->offset.y = 0 - acc.y;
+    if (atomic_read(&mir3da->position) > 0) {
+        mir3da->offset.z = LSG - acc.z;
+    } else {
+        mir3da->offset.z = (-LSG) - acc.z;
+    }
+	
+    MI_MSG("fast calibration: %d %d %d\n", mir3da->offset.x,mir3da->offset.y, mir3da->offset.z);
+
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+    
+    memset(&(mir3da->offset), 0, sizeof(struct mir3da_acc));
+
+    MI_MSG( "reset fast calibration finished\n");
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d %d %d\n", mir3da->offset.x, mir3da->offset.y, mir3da->offset.z);
+}
+/**************************************************************************/
+static ssize_t mir3da_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[3]={0};
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+
+    sscanf(buf, "%d %d %d", &data[0], &data[1], &data[2]);
+    mir3da->offset.x = (signed short) data[0];
+    mir3da->offset.y = (signed short) data[1];
+    mir3da->offset.z = (signed short) data[2];
+    
+    MI_MSG( "set fast calibration finished\n");
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+
+    data = atomic_read(&(mir3da->position));
+
+    return sprintf(buf, "%d\n", data);
+}
+/**************************************************************************/
+static ssize_t mir3da_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data=0;
+    int error=0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(mir3da->position), (int) data);
+
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_log_level_show(struct device *dev,
+                   struct device_attribute *attr, char *buf)
+{
+    int ret;
+
+    ret = sprintf(buf, "%d\n", Log_level);
+
+    return ret;
+}
+/**************************************************************************/
+static ssize_t mir3da_log_level_store(struct device *dev,
+                    struct device_attribute *attr,
+                    const char *buf, size_t count)
+{
+    Log_level = simple_strtoul(buf, NULL, 10);    
+
+    return count;
+}
+/**************************************************************************/
+static ssize_t mir3da_primary_offset_show(struct device *dev,
+                   struct device_attribute *attr, char *buf){    
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);  
+    int x=0,y=0,z=0;
+   
+    mir3da_get_primary_offset(mir3da->mir3da_client,&x,&y,&z);
+
+	return sprintf(buf, "x=%d ,y=%d ,z=%d\n",x,y,z);
+
+}
+/**************************************************************************/
+static ssize_t mir3da_version_show(struct device *dev,
+                   struct device_attribute *attr, char *buf){    
+
+	return sprintf(buf, "%s_%s\n", DRI_VER, CORE_VER);
+}
+/**************************************************************************/
+static ssize_t mir3da_vendor_show(struct device *dev,
+                   struct device_attribute *attr, char *buf){
+	return sprintf(buf, "%s\n", "MiraMEMS");
+}
+/**************************************************************************/
+static DEVICE_ATTR(enable,          	S_IRUGO | S_IWUGO,  mir3da_enable_show,             mir3da_enable_store);
+static DEVICE_ATTR(delay,      	        S_IRUGO | S_IWUGO,  mir3da_delay_show,              mir3da_delay_store);
+static DEVICE_ATTR(axis_data,       	S_IRUGO|S_IWUSR|S_IWGRP,    mir3da_axis_data_show,          NULL);
+static DEVICE_ATTR(reg_data,        	S_IRUGO|S_IWUSR|S_IWGRP,  mir3da_reg_data_show,           mir3da_reg_data_store);
+static DEVICE_ATTR(log_level,       	S_IRUGO|S_IWUSR|S_IWGRP,  mir3da_log_level_show,          mir3da_log_level_store);
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+static DEVICE_ATTR(offset,          	S_IRUGO|S_IWUSR|S_IWGRP,  mir3da_offset_show,             mir3da_offset_store);
+static DEVICE_ATTR(calibrate_miraGSensor,       S_IRUGO|S_IWUSR|S_IWGRP,  mir3da_calibrate_show,          mir3da_calibrate_store);
+#endif
+#if FILTER_AVERAGE_ENHANCE
+static DEVICE_ATTR(average_enhance,     S_IRUGO|S_IWUSR|S_IWGRP,  mir3da_average_enhance_show,    mir3da_average_enhance_store);
+#endif
+static DEVICE_ATTR(calibration_run, 	S_IWUGO | S_IRUGO,NULL, mir3da_calibration_run_store);
+static DEVICE_ATTR(calibration_reset,	S_IWUGO | S_IRUGO, NULL, mir3da_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, 	S_IWUGO | S_IRUGO,mir3da_calibration_value_show,mir3da_calibration_value_store);
+static DEVICE_ATTR(board_position, 	    S_IRUGO|S_IWUSR|S_IWGRP,mir3da_board_position_show, mir3da_board_position_store);
+static DEVICE_ATTR(primary_offset,      S_IWUGO ,                     mir3da_primary_offset_show,     NULL);
+static DEVICE_ATTR(version,          	S_IRUGO|S_IWUSR|S_IWGRP,            mir3da_version_show,            NULL);
+static DEVICE_ATTR(vendor,           	S_IRUGO|S_IWUSR|S_IWGRP,            mir3da_vendor_show,             NULL); 
+/**************************************************************************/
+static struct attribute *mir3da_attributes[] = { 
+    &dev_attr_enable.attr,
+    &dev_attr_delay.attr,
+    &dev_attr_axis_data.attr,
+    &dev_attr_reg_data.attr,
+    &dev_attr_log_level.attr,
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+    &dev_attr_offset.attr,    
+    &dev_attr_calibrate_miraGSensor.attr,
+#endif
+#if FILTER_AVERAGE_ENHANCE
+    &dev_attr_average_enhance.attr,
+#endif
+    &dev_attr_calibration_run.attr,
+    &dev_attr_calibration_reset.attr,
+    &dev_attr_calibration_value.attr,
+    &dev_attr_board_position.attr, 
+    &dev_attr_primary_offset.attr,    
+    &dev_attr_version.attr,
+    &dev_attr_vendor.attr,
+    NULL
+};
+
+static const struct attribute_group mir3da_attr_group = {
+    .attrs  = mir3da_attributes,
+};
+/**************************************************************************/
+int i2c_smbus_read(PLAT_HANDLE handle, u8 addr, u8 *data)
+{
+    int                 res = 0;
+    struct i2c_client   *client = (struct i2c_client*)handle;
+    
+    *data = i2c_smbus_read_byte_data(client, addr);
+    
+    return res;
+}
+/**************************************************************************/
+int i2c_smbus_read_block(PLAT_HANDLE handle, u8 addr, u8 count, u8 *data)
+{
+    int                 res = 0;
+    struct i2c_client   *client = (struct i2c_client*)handle;
+    
+    res = i2c_smbus_read_i2c_block_data(client, addr, count, data);
+    
+    return res;
+}
+/**************************************************************************/
+int i2c_smbus_write(PLAT_HANDLE handle, u8 addr, u8 data)
+{
+    int                 res = 0;
+    struct i2c_client   *client = (struct i2c_client*)handle;
+    
+    res = i2c_smbus_write_byte_data(client, addr, data);
+    
+    return res;
+}
+/**************************************************************************/
+void msdelay(int ms)
+{
+    mdelay(ms);
+}
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+MIR_GENERAL_OPS_DECLARE(ops_handle, i2c_smbus_read, i2c_smbus_read_block, i2c_smbus_write, sensor_sync_write, sensor_sync_read, msdelay, printk, sprintf);
+#else
+MIR_GENERAL_OPS_DECLARE(ops_handle, i2c_smbus_read, i2c_smbus_read_block, i2c_smbus_write, NULL, NULL, msdelay, printk, sprintf);
+#endif
+/**************************************************************************/
+static void mir3da_axis_remap(struct i2c_client *client,short *x,short *y,short *z)
+{
+    short swap=0;
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);
+    int position = atomic_read(&mir3da->position);
+
+    switch (abs(position)) {
+        case 1:
+            break;
+        case 2:
+            swap = *x;
+            *x = *y;
+            *y = -swap; 
+            break;
+        case 3:
+            *x = -(*x);
+            *y = -(*y);
+            break;
+        case 4:
+            swap = *x;
+            *x = -(*y);
+            *y = swap;
+            break;
+    }
+    
+    if (position < 0) {
+        *z = -(*z);
+        *x = -(*x);
+    }
+    
+}
+/**************************************************************************/
+static int mir3da_read_file(char *path, char *buf, int size)
+{
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+/**************************************************************************/
+static int mir3da_load_user_calibration(struct i2c_client *client)
+{
+    char buffer[16]={0};
+    int data[3]={0};
+    int ret = 0;
+	
+    struct mir3da_data *mir3da = i2c_get_clientdata(client);    
+    int calibrated = atomic_read(&mir3da->calibrated);
+    
+    if (calibrated) {
+        goto usr_calib_end;
+    } else {
+        atomic_set(&mir3da->calibrated, 1);
+    }
+
+    ret = mir3da_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        MI_ERR("gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d", &data[0], &data[1], &data[2]);
+    mir3da->offset.x = (signed short) data[0];
+    mir3da->offset.y = (signed short) data[1];
+    mir3da->offset.z = (signed short) data[2];
+    
+    MI_MSG( "load cfg_calibration: %d %d %d\n", data[0], data[1], data[2]);
+    
+usr_calib_end:
+    return ret;
+}
+/**************************************************************************/
+#if MIR3DA_HRTIMER
+enum hrtimer_restart mir3da_hrtimer_callback( struct hrtimer *timer )  
+{  
+    struct mir3da_data *mir3da = container_of((struct hrtimer *)timer, struct mir3da_data, hr_timer);
+    int wq_delay = atomic_read(&mir3da->delay) - 3;
+
+    queue_delayed_work(mir3da->wq, &mir3da->work, msecs_to_jiffies(0));
+    hrtimer_forward_now(&mir3da->hr_timer, ktime_set(0, wq_delay * 1000000));
+    
+    return HRTIMER_RESTART;
+}
+#endif
+
+/**************************************************************************/
+static void mir3da_work_func(struct work_struct *work)
+{
+    int result=0;
+    short x=0,y=0,z=0;
+    struct mir3da_data *mir3da = container_of((struct delayed_work *)work, struct mir3da_data, work);
+    int wq_delay = atomic_read(&mir3da->delay);
+
+
+#if (MIR3DA_HRTIMER == 0)
+    queue_delayed_work(mir3da->wq, &mir3da->work, msecs_to_jiffies(wq_delay - 3));
+#endif
+    
+    mir3da_load_user_calibration(mir3da->mir3da_client);
+	
+    result = mir3da_read_data(mir3da->mir3da_client, &x,&y,&z);
+
+    x += mir3da->offset.x;
+    y += mir3da->offset.y;
+    z += mir3da->offset.z;
+	
+    if (result == 0) {
+	    mir3da_axis_remap(mir3da->mir3da_client,&x,&y,&z);
+        
+	    input_report_abs(mir3da->input, ABS_X, x);
+	    input_report_abs(mir3da->input, ABS_Y, y);
+	    input_report_abs(mir3da->input, ABS_Z, z);
+	    input_sync(mir3da->input);
+        
+    } else {
+        MI_ERR("mir3da_read_data failed!\n");
+    }
+}
+/**************************************************************************/
+static int  mir3da_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    int result;
+    int err = 0;
+    const char * buf;
+		long int temp;
+    struct mir3da_data *data;
+    struct input_dev *dev;
+    int cfg_position =0;
+    int cfg_calibration[3]={0};	
+	
+    MI_FUN;
+    
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        MI_ERR("i2c_check_functionality error\n");
+        goto exit;
+    }
+
+    data = kzalloc(sizeof(struct mir3da_data), GFP_KERNEL);
+    if (!data) {
+        result = -ENOMEM;
+        goto exit;
+    }
+
+    if(mir3da_install_general_ops(&ops_handle)){
+        MI_ERR("Install ops failed !\n");
+        goto kfree_exit;
+    }
+
+    i2c_set_clientdata(client, data);
+    data->mir3da_client = client;
+    mutex_init(&data->enable_mutex);
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+	err = of_property_read_string(client->dev.of_node, "position", &buf);
+	if (err != 0) {
+	  	printk(KERN_ERR"get position fail\n");
+		cfg_position = -3;
+	}
+	else{
+		err = strict_strtol(buf, 10, &temp);  
+		cfg_position = (int)temp;
+	}	
+#else
+	cfg_position = -3;
+#endif
+
+    atomic_set(&data->position, cfg_position);
+    atomic_set(&data->calibrated, 0);
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+    //get dts configures
+    err = of_property_read_u32_array(client->dev.of_node, "calibration_table", cfg_calibration, 3);
+    if (err != 0) {
+        printk(KERN_ERR"get calibration fail\n");
+        memset(cfg_calibration, 0, sizeof(cfg_calibration));
+    }
+#else
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+#endif   
+
+    data->offset.x = (signed short) cfg_calibration[0];
+    data->offset.y = (signed short) cfg_calibration[1];
+    data->offset.z = (signed short) cfg_calibration[2];
+
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+    m_work_info.wq = create_singlethread_workqueue( "oo" );
+    if(NULL==m_work_info.wq) {
+        MI_ERR("Failed to create workqueue !");
+        goto kfree_exit;
+    }
+    
+    INIT_DELAYED_WORK( &m_work_info.read_work, sensor_read_work );
+    INIT_DELAYED_WORK( &m_work_info.write_work, sensor_write_work );
+#endif
+
+    mir_handle = mir3da_core_init((PLAT_HANDLE)client);
+    if(NULL == mir_handle){
+        MI_ERR("chip init failed !\n");
+        goto kfree_exit;
+    }
+
+#if MIR3DA_HRTIMER
+    hrtimer_init( &data->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL );
+    data->hr_timer.function = mir3da_hrtimer_callback; 
+#endif
+
+    data->wq = create_singlethread_workqueue( "mir3da_wq" );
+    INIT_DELAYED_WORK(&data->work, mir3da_work_func);
+    
+    atomic_set(&data->delay, DELAY_INTERVAL_MAX);
+    atomic_set(&data->enable, 0);
+
+    dev = input_allocate_device();
+    if (!dev){
+	   MI_ERR("input allocate error!");
+          return -ENOMEM;
+     }		
+    dev->name = MIR3DA_DRV_NAME;
+    dev->id.bustype = BUS_I2C;
+
+    input_set_capability(dev, EV_ABS, ABS_MISC);
+    input_set_abs_params(dev, ABS_X, -16384, 16383, INPUT_FUZZ, INPUT_FLAT);
+    input_set_abs_params(dev, ABS_Y, -16384, 16383, INPUT_FUZZ, INPUT_FLAT);
+    input_set_abs_params(dev, ABS_Z, -16384, 16383, INPUT_FUZZ, INPUT_FLAT); 
+    input_set_drvdata(dev, data);
+
+    result = input_register_device(dev);
+    if (result < 0) {
+	 MI_ERR("input register error!");	
+        input_free_device(dev);
+        goto kfree_exit;
+    }
+
+    data->input = dev;
+  
+    result = sysfs_create_group(&data->input->dev.kobj, &mir3da_attr_group);
+    if (result < 0){
+	MI_ERR("create sysfs group error!");		
+        goto error_sysfs;
+    }
+    
+    return result;
+error_sysfs:
+    input_unregister_device(data->input);
+
+kfree_exit:
+    kfree(data);
+exit:
+    return -1;	
+}
+/**************************************************************************/
+static int  mir3da_remove(struct i2c_client *client)
+{
+    struct mir3da_data *data = i2c_get_clientdata(client);
+
+    MI_FUN; 	
+
+    mir3da_set_enable(data->mir3da_client, false);
+#if MIR3DA_HRTIMER    
+    hrtimer_cancel(&data->hr_timer);
+#endif
+    cancel_delayed_work_sync(&data->work);    
+    flush_workqueue(data->wq);
+    destroy_workqueue(data->wq);
+    sysfs_remove_group(&data->input->dev.kobj, &mir3da_attr_group);
+    input_unregister_device(data->input);
+#if MIR3DA_OFFSET_TEMP_SOLUTION
+    flush_workqueue(m_work_info.wq);
+    destroy_workqueue(m_work_info.wq);
+#endif
+    kfree(data);
+
+    return 0;
+}
+/**************************************************************************/
+static int mir3da_suspend(struct device *dev)
+{
+    int result = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *data = i2c_get_clientdata(client);
+
+    MI_FUN;	
+
+#if MIR3DA_HRTIMER    
+    hrtimer_cancel(&data->hr_timer);
+#endif
+    cancel_delayed_work_sync(&data->work);
+
+    result = mir3da_set_enable(data->mir3da_client, false);
+    if(result) {
+	     MI_ERR("%s: disable fail!!\n",__func__);	
+            return result;
+     }
+
+//     cancel_delayed_work_sync(&data->work);
+	
+      return result;
+}
+/**************************************************************************/
+static int mir3da_resume(struct device *dev)
+{
+    int result = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mir3da_data *data = i2c_get_clientdata(client);
+    int pre_enable = atomic_read(&data->enable);
+
+    MI_FUN;	
+	
+    result = mir3da_chip_resume(data->mir3da_client);
+    if(result) {
+		MI_ERR("chip resume fail!!\n");
+		return result;
+    }
+
+    if (pre_enable) {
+        result = mir3da_set_enable(data->mir3da_client, true);
+        if(result) {
+    	     MI_ERR("%s: enable fail!!\n",__func__);		
+                return result;
+        }
+    #if (MIR3DA_HRTIMER == 0)
+        queue_delayed_work(data->wq, &data->work, msecs_to_jiffies(0));
+    #else
+        hrtimer_start(&data->hr_timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+    #endif        
+    }
+    
+    return result;
+}
+
+static SIMPLE_DEV_PM_OPS(mir3da_pm_ops, mir3da_suspend, mir3da_resume);
+
+/**************************************************************************/
+static const struct i2c_device_id mir3da_id[] = {
+    { MIR3DA_DRV_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, mir3da_id);
+
+static struct of_device_id mir3da_of_match[] = {
+	{ .compatible = "mir3da" },
+	{ }
+};
+
+static struct i2c_driver mir3da_driver = {
+    .driver = {
+        .name    = MIR3DA_DRV_NAME,
+        .owner    = THIS_MODULE,
+        .pm    = &mir3da_pm_ops,
+        .of_match_table	= of_match_ptr(mir3da_of_match),
+    },
+    .class        = I2C_CLASS_HWMON,
+    .id_table = mir3da_id,    
+    .probe    = mir3da_probe,
+    .remove    = mir3da_remove,
+};
+/**************************************************************************/
+static int __init mir3da_init(void)
+{   
+    int res;
+    MI_MSG("mir3da init !\n");
+    res = i2c_add_driver(&mir3da_driver);
+    if (res < 0){
+        MI_ERR("add mir3da i2c driver failed\n");
+        return -ENODEV;
+    }
+	
+    MI_MSG("add mir3da i2c driver ok !\n");
+	
+    return (res);
+}
+/**************************************************************************/
+static void __exit mir3da_exit(void)
+{
+    MI_FUN;
+	
+    i2c_unregister_device(mir_handle);
+    i2c_del_driver(&mir3da_driver);
+}
+/**************************************************************************/
+MODULE_AUTHOR("MiraMEMS <lschen@miramems.com>");
+MODULE_DESCRIPTION("MIR3DA 3-Axis Accelerometer driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+module_init(mir3da_init);
+module_exit(mir3da_exit);
diff --git a/drivers/input/misc/gsensor/mir3da/mir3da_cust.h b/drivers/input/misc/gsensor/mir3da/mir3da_cust.h
new file mode 100755
index 0000000..275d707
--- /dev/null
+++ b/drivers/input/misc/gsensor/mir3da/mir3da_cust.h
@@ -0,0 +1,41 @@
+/* For ACTIONS android platform.
+ *
+ * mir3da.h - Linux kernel modules for 3-Axis Accelerometer
+ *
+ * Copyright (C) 2011-2013 MiraMEMS Sensing Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MIR3DA_STANDARD_H__
+#define __MIR3DA_STANDARD_H__
+	 
+#include <linux/ioctl.h>
+
+#define MIR3DA_I2C_ADDR		                    0x27
+
+#define DRI_VER                  		        "1.0"
+#define MIR3DA_DRV_NAME                 			"mir3da"
+#define MIR3DA_INPUT_DEV_NAME      			MIR3DA_DRV_NAME
+#define MIR3DA_MISC_NAME                			MIR3DA_DRV_NAME
+
+
+#define DELAY_INTERVAL_MAX              			200
+#define INPUT_FUZZ                      				0
+#define INPUT_FLAT                      				0
+#define LSG                                  				1024
+
+#define CFG_GSENSOR_USE_CONFIG   			1
+
+
+#endif /* !__MIR3DA_STANDARD_H__ */
+
+
diff --git a/drivers/input/misc/gsensor/mma7660/Makefile b/drivers/input/misc/gsensor/mma7660/Makefile
new file mode 100755
index 0000000..d98b4c1
--- /dev/null
+++ b/drivers/input/misc/gsensor/mma7660/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the mma7660 drivers
+#
+
+obj-$(CONFIG_GSENSOR_MMA7660) += gsensor_mma7660.o
+gsensor_mma7660-objs := mma7660.o
diff --git a/drivers/input/misc/gsensor/mma7660/XYZ_Filter.h b/drivers/input/misc/gsensor/mma7660/XYZ_Filter.h
new file mode 100755
index 0000000..f60eac9
--- /dev/null
+++ b/drivers/input/misc/gsensor/mma7660/XYZ_Filter.h
@@ -0,0 +1,138 @@
+
+#include <linux/kernel.h>
+
+typedef signed char VINT8;
+typedef unsigned char VUINT8;
+typedef signed short VINT16;
+typedef unsigned short VUINT16;
+typedef unsigned long VUINT32;
+typedef signed long VINT32;
+
+#define _MMA7660_LOW_PASS_FILTER_
+#define LowPassFactor 3
+#define RawDataLength 4
+
+#define MMA7660_Sin30pos 10
+#define MMA7660_Sin30neg -10
+
+
+
+
+VINT8 Xraw[RawDataLength];
+VINT8 Yraw[RawDataLength];
+VINT8 Zraw[RawDataLength];
+
+VINT8 RawDataPointer = 0;
+
+VINT8 Xnew8, Ynew8, Znew8;
+VINT8 Xavg8, Yavg8, Zavg8;
+#ifdef _MMA7660_LOW_PASS_FILTER_
+VINT8 Xflt8, Yflt8, Zflt8;
+VINT8 Xrsdl, Yrsdl, Zrsdl;
+#endif
+
+
+void XYZ_Filter(VINT8 *X, VINT8 *Y, VINT8 *Z);
+
+void XYZ_Filter(VINT8 *X, VINT8 *Y, VINT8 *Z){
+  VUINT8 i;
+  VINT8 temp8_1, temp8_2;
+  VINT16 temp16, temp16_2;
+  
+
+  Xnew8 = *X;
+  Ynew8 = *Y;
+  Znew8 = *Z;
+  
+  
+  //printk(KERN_ERR "filting...\n");
+
+#ifdef _MMA7660_LOW_PASS_FILTER_
+
+  if((++RawDataPointer)>=RawDataLength) RawDataPointer = 0;
+
+  Xraw[RawDataPointer] = Xnew8;
+  Yraw[RawDataPointer] = Ynew8;
+  Zraw[RawDataPointer] = Znew8;
+
+  for(i=0, temp16=0;i<RawDataLength;i++)
+  {
+    temp16 += Xraw[i];
+  }
+  Xflt8 = (VINT8)(temp16/RawDataLength);
+  for(i=0, temp16=0;i<RawDataLength;i++)
+  {
+    temp16 += Yraw[i];
+  }
+  Yflt8 = (VINT8)(temp16/RawDataLength);
+  for(i=0, temp16=0;i<RawDataLength;i++)
+  {
+    temp16 += Zraw[i];
+  }
+  Zflt8 = (VINT8)(temp16/RawDataLength);
+  
+  temp8_1 = Xflt8 - Xavg8;
+  temp8_2 = temp8_1 / (1 + LowPassFactor);
+  Xavg8 += temp8_2;
+  temp8_1 -= temp8_2 * (1 + LowPassFactor);   //Current Residual
+  Xrsdl += temp8_1;                           //Overall Residual
+  temp8_2 = Xrsdl / (1 + LowPassFactor);
+  Xavg8 += temp8_2;
+  Xrsdl -= temp8_2 * (1 + LowPassFactor);
+  
+  temp8_1 = Yflt8 - Yavg8;
+  temp8_2 = temp8_1 / (1 + LowPassFactor);
+  Yavg8 += temp8_2;
+  temp8_1 -= temp8_2 * (1 + LowPassFactor);
+  Yrsdl += temp8_1;
+  temp8_2 = Yrsdl / (1 + LowPassFactor);
+  Yavg8 += temp8_2;
+  Yrsdl -= temp8_2 * (1 + LowPassFactor);
+  
+  temp8_1 = Zflt8 - Zavg8;
+  temp8_2 = temp8_1 / (1 + LowPassFactor);
+  Zavg8 += temp8_2;
+  temp8_1 -= temp8_2 * (1 + LowPassFactor);
+  Zrsdl += temp8_1;
+  temp8_2 = Zrsdl / (1 + LowPassFactor);
+  Zavg8 += temp8_2;
+  Zrsdl -= temp8_2 * (1 + LowPassFactor);
+
+  *X = Xavg8;
+  *Y = Yavg8;
+  *Z = Zavg8;
+
+#else
+  if((++RawDataPointer)>=RawDataLength) RawDataPointer = 0;
+
+  Xraw[RawDataPointer] = Xnew8;
+  Yraw[RawDataPointer] = Ynew8;
+  Zraw[RawDataPointer] = Znew8;
+
+  for(i=0, temp16=0;i<RawDataLength;i++)
+  {
+    temp16 += Xraw[i];
+  }
+  Xavg8 = (VINT8)(temp16/RawDataLength);
+  for(i=0, temp16=0;i<RawDataLength;i++)
+  {
+    temp16 += Yraw[i];
+  }
+  Yavg8 = (VINT8)(temp16/RawDataLength);
+  for(i=0, temp16=0;i<RawDataLength;i++)
+  {
+    temp16 += Zraw[i];
+  }
+  Zavg8 = (VINT8)(temp16/RawDataLength);
+
+  *X = Xavg8;
+  *Y = Yavg8;
+  *Z = Zavg8;
+
+#endif
+ 
+}
+
+
+
+
diff --git a/drivers/input/misc/gsensor/mma7660/mma7660.c b/drivers/input/misc/gsensor/mma7660/mma7660.c
new file mode 100755
index 0000000..7af2401
--- /dev/null
+++ b/drivers/input/misc/gsensor/mma7660/mma7660.c
@@ -0,0 +1,1010 @@
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/uaccess.h>
+
+#include "XYZ_Filter.h"
+
+
+// device info
+#define SENSOR_NAME                   "mma7660"
+#define SENSOR_I2C_ADDR            0x4c
+#define ABSMIN                              -32
+#define ABSMAX                             31
+#define FUZZ                       0
+#define LSG                                   21
+#define MAX_DELAY                       200
+
+// constant define
+#define MMA7660_MODE_STANDBY          0x00
+#define MMA7660_MODE_ACTIVE             0x01
+
+#define MMA7660_RATE_120                 0x00
+#define MMA7660_RATE_64                 0x01
+#define MMA7660_RATE_32                 0x02
+#define MMA7660_RATE_16                 0x03
+#define MMA7660_RATE_8                   0x04
+
+// register define
+#define MMA7660_XOUT_REG              0x00
+#define MMA7660_YOUT_REG              0x01
+#define MMA7660_ZOUT_REG              0x02
+#define MMA7660_MODE_REG              0x07
+#define MMA7660_SR_REG                   0x08
+
+// register bits define
+#define MMA7660_XOUT_BIT__POS            0
+#define MMA7660_XOUT_BIT__LEN            6
+#define MMA7660_XOUT_BIT__MSK            0x3f
+#define MMA7660_XOUT_BIT__REG            MMA7660_XOUT_REG
+
+#define MMA7660_XALERT_BIT__POS            6
+#define MMA7660_XALERT_BIT__LEN            1
+#define MMA7660_XALERT_BIT__MSK            0x40
+#define MMA7660_XALERT_BIT__REG            MMA7660_XOUT_REG
+
+#define MMA7660_MODE_BIT__POS            0
+#define MMA7660_MODE_BIT__LEN            1
+#define MMA7660_MODE_BIT__MSK            0x01
+#define MMA7660_MODE_BIT__REG            MMA7660_MODE_REG
+
+#define MMA7660_RATE_BIT__POS            0
+#define MMA7660_RATE_BIT__LEN            3
+#define MMA7660_RATE_BIT__MSK            0x07
+#define MMA7660_RATE_BIT__REG            MMA7660_SR_REG
+
+
+#define MMA7660_GET_BITSLICE(regvar, bitname)\
+    ((regvar & bitname##__MSK) >> bitname##__POS)
+
+#define MMA7660_SET_BITSLICE(regvar, bitname, val)\
+    ((regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK))
+
+
+struct mma7660_acc{
+    s16    x;
+    s16    y;
+    s16    z;
+} ;
+
+struct mma7660_data {
+    struct i2c_client *mma7660_client;
+    struct input_dev *input;
+    atomic_t delay;
+    atomic_t enable;
+    struct mutex enable_mutex;
+    struct delayed_work work;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend early_suspend;
+#endif
+    atomic_t position;
+    atomic_t calibrated;
+    struct mma7660_acc offset;
+    atomic_t fuzz;
+};
+
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  0
+
+// calibration file path
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+/*******************************************
+* for xml cfg
+*******************************************/
+#define CFG_GSENSOR_ADAP_ID          "gsensor.i2c_adap_id"
+#define CFG_GSENSOR_POSITION         "gsensor.position"
+#define CFG_GSENSOR_CALIBRATION      "gsensor.calibration"
+#define CFG_GSENSOR_MOD_POSITION   "gsensor_"SENSOR_NAME".position"
+
+extern int get_config(const char *key, char *buff, int len);
+/*******************************************
+* end for xml cfg
+*******************************************/
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mma7660_early_suspend(struct early_suspend *h);
+static void mma7660_early_resume(struct early_suspend *h);
+#endif
+
+
+static int mma7660_axis_remap(struct i2c_client *client, struct mma7660_acc *acc);
+
+static int mma7660_smbus_read_byte(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data)
+{
+    s32 dummy;
+    dummy = i2c_smbus_read_byte_data(client, reg_addr);
+    if (dummy < 0)
+        return -1;
+    *data = dummy & 0x000000ff;
+
+    return 0;
+}
+
+static int mma7660_smbus_write_byte(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data)
+{
+    s32 dummy;
+    dummy = i2c_smbus_write_byte_data(client, reg_addr, *data);
+    if (dummy < 0)
+        return -1;
+    return 0;
+}
+
+static int mma7660_smbus_read_byte_block(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;
+    dummy = i2c_smbus_read_i2c_block_data(client, reg_addr, len, data);
+    if (dummy < 0)
+        return -1;
+    return 0;
+}
+
+static int mma7660_smbus_write_byte_block(struct i2c_client *client,
+        unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+    s32 dummy;    
+    dummy = i2c_smbus_write_i2c_block_data(client, reg_addr, len, data);
+        if (dummy < 0)
+            return -1;    
+    return 0;
+}
+
+static int mma7660_set_mode(struct i2c_client *client, unsigned char mode)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = mma7660_smbus_read_byte(client, MMA7660_MODE_BIT__REG, &data);    
+    data  = MMA7660_SET_BITSLICE(data, MMA7660_MODE_BIT, mode);
+    comres += mma7660_smbus_write_byte(client, MMA7660_MODE_BIT__REG, &data);
+
+    return comres;
+}
+
+static int mma7660_get_mode(struct i2c_client *client, unsigned char *mode)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = mma7660_smbus_read_byte(client, MMA7660_MODE_BIT__REG, &data);
+    *mode  = MMA7660_GET_BITSLICE(data, MMA7660_MODE_BIT);
+
+    return comres;
+}
+
+static int mma7660_set_rate(struct i2c_client *client, unsigned char rate)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres += mma7660_smbus_read_byte(client, MMA7660_RATE_BIT__REG, &data);    
+    data  = MMA7660_SET_BITSLICE(data, MMA7660_RATE_BIT, rate);
+    comres += mma7660_smbus_write_byte(client, MMA7660_RATE_BIT__REG, &data);
+
+    return comres;
+}
+
+static int mma7660_get_rate(struct i2c_client *client, unsigned char *rate)
+{
+    int comres = 0;
+    unsigned char data = 0;
+
+    comres = mma7660_smbus_read_byte(client, MMA7660_RATE_BIT__REG, &data);
+    *rate  = MMA7660_GET_BITSLICE(data, MMA7660_RATE_BIT);
+
+    return comres;
+}
+
+static int mma7660_hw_init(struct i2c_client *client)
+{
+    int comres = 0;
+    
+    // sample rate: 32
+    comres += mma7660_set_rate(client, MMA7660_RATE_120);
+    
+    return comres;
+}
+
+static int mma7660_read_data(struct i2c_client *client, struct mma7660_acc *acc)
+{
+    int comres = 0;
+    unsigned char data[3];
+    int idx, alert;
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    for (idx = 0; idx < 3; idx ++) {
+        do {
+            comres += mma7660_smbus_read_byte(client, idx+MMA7660_XOUT_BIT__REG, &(data[idx]));
+            if (comres < 0) {
+                printk(KERN_ERR"read data fail! comres=%d\n", comres);
+                break;
+            } else {
+                alert = MMA7660_GET_BITSLICE(data[idx], MMA7660_XALERT_BIT);
+            }
+        } while (alert); //read again if alert
+        
+        data[idx] = MMA7660_GET_BITSLICE(data[idx], MMA7660_XOUT_BIT);
+        // process symbol bit
+        if (data[idx] & (1 << (MMA7660_XOUT_BIT__LEN-1))) {   
+            data[idx] |= ~MMA7660_XOUT_BIT__MSK;
+        }
+    }
+    
+    acc->x =  (signed char)data[0];
+    acc->y =  (signed char)data[1];
+    acc->z =  (signed char)data[2];
+
+    // calibrate offset
+    acc->x += mma7660->offset.x;
+    acc->y += mma7660->offset.y;
+    acc->z += mma7660->offset.z;
+    
+    return comres;
+}
+
+
+static ssize_t mma7660_register_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int address, value;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    sscanf(buf, "[0x%x]=0x%x", &address, &value);
+    
+    if (mma7660_smbus_write_byte(mma7660->mma7660_client, (unsigned char)address,
+                (unsigned char *)&value) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t mma7660_register_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);    
+    size_t count = 0;
+    u8 reg[0x0b];
+    int i;
+    
+    for (i = 0 ; i < 0x0b; i++) {
+        mma7660_smbus_read_byte(mma7660->mma7660_client, i, reg+i);    
+        count += sprintf(&buf[count], "0x%x: 0x%x\n", i, reg[i]);
+    }
+    
+    return count;
+}
+
+static ssize_t mma7660_mode_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    if (mma7660_get_mode(mma7660->mma7660_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t mma7660_mode_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (mma7660_set_mode(mma7660->mma7660_client, (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t mma7660_rate_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    unsigned char data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    if (mma7660_get_rate(mma7660->mma7660_client, &data) < 0)
+        return sprintf(buf, "Read error\n");
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t mma7660_rate_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if (mma7660_set_rate(mma7660->mma7660_client, (unsigned char) data) < 0)
+        return -EINVAL;
+
+    return count;
+}
+
+static ssize_t mma7660_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct input_dev *input = to_input_dev(dev);
+    struct mma7660_data *mma7660 = input_get_drvdata(input);
+    struct mma7660_acc acc;
+
+    mma7660_read_data(mma7660->mma7660_client, &acc);
+    mma7660_axis_remap(mma7660->mma7660_client, &acc);   
+    
+    return sprintf(buf, "%d %d %d\n", acc.x, acc.y, acc.z);
+}
+
+static ssize_t mma7660_delay_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&mma7660->delay));
+
+}
+
+static ssize_t mma7660_delay_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&mma7660->delay, (unsigned int) data);
+
+    return count;
+}
+
+
+static ssize_t mma7660_enable_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&mma7660->enable));
+
+}
+
+static void mma7660_do_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    if (enable) {
+        mma7660_set_mode(mma7660->mma7660_client, MMA7660_MODE_ACTIVE);
+        schedule_delayed_work(&mma7660->work,
+            msecs_to_jiffies(atomic_read(&mma7660->delay)));
+    } else {
+        mma7660_set_mode(mma7660->mma7660_client, MMA7660_MODE_STANDBY);
+        cancel_delayed_work_sync(&mma7660->work);
+    }
+}
+
+static void mma7660_set_enable(struct device *dev, int enable)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+    int pre_enable = atomic_read(&mma7660->enable);
+
+    mutex_lock(&mma7660->enable_mutex);
+    if (enable != pre_enable) {
+        mma7660_do_enable(dev, enable);
+        atomic_set(&mma7660->enable, enable);
+    }
+    mutex_unlock(&mma7660->enable_mutex);
+}
+
+static ssize_t mma7660_enable_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    if ((data == 0) || (data == 1))
+        mma7660_set_enable(dev, data);
+
+    return count;
+}
+
+static ssize_t mma7660_fuzz_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d\n", atomic_read(&mma7660->fuzz));
+
+}
+
+static ssize_t mma7660_fuzz_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    error = strict_strtoul(buf, 10, &data);
+    if (error)
+        return error;
+    
+    atomic_set(&(mma7660->fuzz), (int) data);
+    
+    if(mma7660->input != NULL) {
+        mma7660->input->absinfo[ABS_X].fuzz = data;
+        mma7660->input->absinfo[ABS_Y].fuzz = data;
+        mma7660->input->absinfo[ABS_Z].fuzz = data;
+    }
+
+    return count;
+}
+
+static ssize_t mma7660_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    data = atomic_read(&(mma7660->position));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t mma7660_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(mma7660->position), (int) data);
+
+    return count;
+}
+
+static ssize_t mma7660_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+    struct mma7660_acc acc;
+
+    mma7660_read_data(mma7660->mma7660_client, &acc);
+    
+    mma7660->offset.x = 0 - acc.x;
+    mma7660->offset.y = 0 - acc.y;
+    if (atomic_read(&mma7660->position) > 0) {
+        mma7660->offset.z = LSG - acc.z;
+    } else {
+        mma7660->offset.z = (-LSG) - acc.z;
+    }
+    
+    printk(KERN_INFO "fast calibration: %d %d %d\n", mma7660->offset.x,
+                        mma7660->offset.y, mma7660->offset.z);
+    
+    cfg_calibration[0] = mma7660->offset.x;
+    cfg_calibration[1] = mma7660->offset.y;
+    cfg_calibration[2] = mma7660->offset.z;
+
+    printk(KERN_INFO "run fast calibration finished\n");
+    return count;
+}
+
+static ssize_t mma7660_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int cfg_calibration[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+    
+    memset(&(mma7660->offset), 0, sizeof(struct mma7660_acc));
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+
+    printk(KERN_INFO "reset fast calibration finished\n");
+    return count;
+}
+
+static ssize_t mma7660_calibration_value_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    return sprintf(buf, "%d %d %d\n", mma7660->offset.x, 
+                                mma7660->offset.y, mma7660->offset.z);
+}
+
+static ssize_t mma7660_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    int data[3];
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+
+    sscanf(buf, "%d %d %d", &data[0], &data[1], &data[2]);
+    mma7660->offset.x = (signed short) data[0];
+    mma7660->offset.y = (signed short) data[1];
+    mma7660->offset.z = (signed short) data[2];
+    
+    printk(KERN_INFO "set fast calibration finished\n");
+    return count;
+}
+
+static DEVICE_ATTR(reg, S_IRUGO|S_IWUSR|S_IWGRP,
+        mma7660_register_show, mma7660_register_store);
+static DEVICE_ATTR(mode, S_IRUGO|S_IWUSR|S_IWGRP,
+        mma7660_mode_show, mma7660_mode_store);
+static DEVICE_ATTR(rate, S_IRUGO|S_IWUSR|S_IWGRP,
+        mma7660_rate_show, mma7660_rate_store);
+static DEVICE_ATTR(value, S_IRUGO,
+        mma7660_value_show, NULL);
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP,
+        mma7660_delay_show, mma7660_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP,
+        mma7660_enable_show, mma7660_enable_store);
+static DEVICE_ATTR(fuzz, S_IRUGO|S_IWUSR|S_IWGRP,
+        mma7660_fuzz_show, mma7660_fuzz_store);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP,
+        mma7660_board_position_show, mma7660_board_position_store);
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP,
+        NULL, mma7660_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP,
+        NULL, mma7660_calibration_reset_store);
+static DEVICE_ATTR(calibration_value, S_IRUGO|S_IWUSR|S_IWGRP,
+        mma7660_calibration_value_show,
+        mma7660_calibration_value_store);
+
+static struct attribute *mma7660_attributes[] = {
+    &dev_attr_reg.attr,
+    &dev_attr_mode.attr,
+    &dev_attr_rate.attr,
+    &dev_attr_value.attr,
+    &dev_attr_delay.attr,
+    &dev_attr_enable.attr,
+    &dev_attr_fuzz.attr,
+    &dev_attr_board_position.attr,
+    &dev_attr_calibration_run.attr,
+    &dev_attr_calibration_reset.attr,
+    &dev_attr_calibration_value.attr,
+    NULL
+};
+
+static struct attribute_group mma7660_attribute_group = {
+    .attrs = mma7660_attributes
+};
+
+static int mma7660_read_file(char *path, char *buf, int size)
+{
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+static int mma7660_load_user_calibration(struct i2c_client *client)
+{
+    char buffer[16];
+    int ret = 0;
+    int data[3];
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);    
+    int calibrated = atomic_read(&mma7660->calibrated);
+    
+    // only calibrate once
+    if (calibrated) {
+        goto usr_calib_end;
+    } else {
+        atomic_set(&mma7660->calibrated, 1);
+    }
+
+    ret = mma7660_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d", &data[0], &data[1], &data[2]);
+    mma7660->offset.x = (signed short) data[0];
+    mma7660->offset.y = (signed short) data[1];
+    mma7660->offset.z = (signed short) data[2];
+    
+    printk(KERN_INFO "user cfg_calibration: %d %d %d\n", data[0], data[1], data[2]);
+    
+usr_calib_end:
+    return ret;
+}
+
+static int mma7660_axis_remap(struct i2c_client *client, struct mma7660_acc *acc)
+{
+    s16 swap;
+    struct mma7660_data *mma7660 = i2c_get_clientdata(client);
+    int position = atomic_read(&mma7660->position);
+
+    switch (abs(position)) {
+        case 1:
+            break;
+        case 2:
+            swap = acc->x;
+            acc->x = acc->y;
+            acc->y = -swap; 
+            break;
+        case 3:
+            acc->x = -(acc->x);
+            acc->y = -(acc->y);
+            break;
+        case 4:
+            swap = acc->x;
+            acc->x = -acc->y;
+            acc->y = swap;
+            break;
+    }
+    
+    if (position < 0) {
+        acc->z = -(acc->z);
+        acc->x = -(acc->x);
+    }
+    
+    return 0;
+}
+
+
+static void mma7660_work_func(struct work_struct *work)
+{
+    struct mma7660_data *mma7660 = container_of((struct delayed_work *)work,
+            struct mma7660_data, work);
+    static struct mma7660_acc acc;    
+    int result;
+    //unsigned long delay = msecs_to_jiffies(atomic_read(&mma7660->delay));
+    unsigned long delay = msecs_to_jiffies(10);
+    
+    mma7660_load_user_calibration(mma7660->mma7660_client);
+    
+    result = mma7660_read_data(mma7660->mma7660_client, &acc);
+    if (result == 0) {
+        mma7660_axis_remap(mma7660->mma7660_client, &acc);
+
+
+        //È¥\B6\B6\A3\ACÆ½\BB\AC
+        //printk(KERN_ERR "before %d,%d,%d!\n",acc.x,acc.y,acc.z);
+        VINT8 x = acc.x & 0xff;
+        VINT8 y = acc.y & 0xff;
+        VINT8 z = acc.z & 0xff;
+        
+        XYZ_Filter(&x,&y,&z);
+        
+        acc.x = x;
+        acc.y = y;
+        acc.z = z;
+
+        //printk(KERN_ERR "after  %d,%d,%d!\n",acc.x,acc.y,acc.z);
+        
+        input_report_abs(mma7660->input, ABS_X, acc.x);
+        input_report_abs(mma7660->input, ABS_Y, acc.y);
+        input_report_abs(mma7660->input, ABS_Z, acc.z);
+        input_sync(mma7660->input);
+    }
+    schedule_delayed_work(&mma7660->work, delay);
+}
+
+
+
+
+
+static int mma7660_probe(struct i2c_client *client,
+        const struct i2c_device_id *id)
+{
+    int err = 0;
+    struct mma7660_data *data;
+    struct input_dev *dev;
+    int cfg_position;
+    int cfg_calibration[3];
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        printk(KERN_INFO "i2c_check_functionality error\n");
+        goto exit;
+    }
+    data = kzalloc(sizeof(struct mma7660_data), GFP_KERNEL);
+    if (!data) {
+        err = -ENOMEM;
+        goto exit;
+    }
+
+    i2c_set_clientdata(client, data);
+    data->mma7660_client = client;
+    mutex_init(&data->enable_mutex);
+
+    INIT_DELAYED_WORK(&data->work, mma7660_work_func);
+    atomic_set(&data->delay, MAX_DELAY);
+    atomic_set(&data->enable, 0);
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+        /*get xml cfg*/
+        err = get_config(CFG_GSENSOR_MOD_POSITION, (char *)(&cfg_position), sizeof(int));
+        if (err != 0) {
+            err = get_config(CFG_GSENSOR_POSITION, (char *)(&cfg_position), sizeof(int));
+            if (err != 0) {
+                printk(KERN_ERR"get position %d fail\n", cfg_position);
+                goto kfree_exit;
+            }
+        }
+#else
+        cfg_position = -3;
+#endif
+    atomic_set(&data->position, cfg_position);
+    atomic_set(&data->calibrated, 0);
+    atomic_set(&data->fuzz, FUZZ);
+        
+    //power on init regs    
+    err = mma7660_hw_init(data->mma7660_client); 
+    if (err < 0) {
+        printk(KERN_ERR"mma7660 probe fail! err:%d\n", err);
+        goto kfree_exit;
+    }
+
+    dev = input_allocate_device();
+    if (!dev)
+        return -ENOMEM;
+    dev->name = SENSOR_NAME;
+    dev->id.bustype = BUS_I2C;
+
+    input_set_capability(dev, EV_ABS, ABS_MISC);
+    input_set_abs_params(dev, ABS_X, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_abs_params(dev, ABS_Y, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_abs_params(dev, ABS_Z, ABSMIN, ABSMAX, FUZZ, 0);
+    input_set_drvdata(dev, data);
+
+    err = input_register_device(dev);
+    if (err < 0) {
+        input_free_device(dev);
+        goto kfree_exit;
+    }
+
+    data->input = dev;
+
+    err = sysfs_create_group(&data->input->dev.kobj,
+            &mma7660_attribute_group);
+    if (err < 0)
+        goto error_sysfs;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    data->early_suspend.suspend = mma7660_early_suspend;
+    data->early_suspend.resume = mma7660_early_resume;
+    register_early_suspend(&data->early_suspend);
+#endif
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+    /*get xml cfg*/
+    err = get_config(CFG_GSENSOR_CALIBRATION, (char *)cfg_calibration, sizeof(cfg_calibration));
+    if (err != 0) {
+        printk(KERN_ERR"get calibration fail\n");
+        goto error_sysfs;
+    }
+#else
+    memset(cfg_calibration, 0, sizeof(cfg_calibration));
+#endif    
+    
+    data->offset.x = (signed short) cfg_calibration[0];
+    data->offset.y = (signed short) cfg_calibration[1];
+    data->offset.z = (signed short) cfg_calibration[2];
+        
+    return 0;
+
+error_sysfs:
+    input_unregister_device(data->input);
+
+kfree_exit:
+    kfree(data);
+exit:
+    return err;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mma7660_early_suspend(struct early_suspend *h)
+{
+    // sensor hal will disable when early suspend
+}
+
+
+static void mma7660_early_resume(struct early_suspend *h)
+{
+    // sensor hal will enable when early resume
+}
+#endif
+
+static int mma7660_remove(struct i2c_client *client)
+{
+    struct mma7660_data *data = i2c_get_clientdata(client);
+
+    mma7660_set_enable(&client->dev, 0);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    unregister_early_suspend(&data->early_suspend);
+#endif
+    sysfs_remove_group(&data->input->dev.kobj, &mma7660_attribute_group);
+    input_unregister_device(data->input);
+    kfree(data);
+
+    return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int mma7660_suspend(struct device *dev)
+{
+    mma7660_do_enable(dev, 0);
+    
+    return 0;
+}
+
+static int mma7660_resume(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct mma7660_data *data = i2c_get_clientdata(client);
+    
+    //power on init regs    
+    mma7660_hw_init(data->mma7660_client);     
+    mma7660_do_enable(dev, atomic_read(&data->enable));
+    
+    return 0;
+}
+
+#else
+
+#define mma7660_suspend        NULL
+#define mma7660_resume        NULL
+
+#endif /* CONFIG_PM */
+
+static SIMPLE_DEV_PM_OPS(mma7660_pm_ops, mma7660_suspend, mma7660_resume);
+
+static const unsigned short  mma7660_addresses[] = {
+    SENSOR_I2C_ADDR,
+    I2C_CLIENT_END,
+};
+
+static const struct i2c_device_id mma7660_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, mma7660_id);
+
+static struct i2c_driver mma7660_driver = {
+    .driver = {
+        .owner    = THIS_MODULE,
+        .name    = SENSOR_NAME,
+        .pm    = &mma7660_pm_ops,
+    },
+    .class        = I2C_CLASS_HWMON,
+//    .address_list    = mma7660_addresses,
+    .id_table    = mma7660_id,
+    .probe        = mma7660_probe,
+    .remove        = mma7660_remove,
+
+};
+
+static struct i2c_board_info mma7660_board_info={
+    .type = SENSOR_NAME, 
+    .addr = SENSOR_I2C_ADDR,
+};
+
+static struct i2c_client *mma7660_client;
+
+static int __init mma7660_init(void)
+{
+    struct i2c_adapter *i2c_adap;
+    unsigned int cfg_i2c_adap_id;
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+    int ret;
+    
+    /*get xml cfg*/
+    ret = get_config(CFG_GSENSOR_ADAP_ID, (char *)(&cfg_i2c_adap_id), sizeof(unsigned int));
+    if (ret != 0) {
+        printk(KERN_ERR"get i2c_adap_id %d fail\n", cfg_i2c_adap_id);
+        return ret;
+    }
+#else
+    cfg_i2c_adap_id = 2;
+#endif
+    
+    i2c_adap = i2c_get_adapter(cfg_i2c_adap_id);  
+    mma7660_client = i2c_new_device(i2c_adap, &mma7660_board_info);  
+    i2c_put_adapter(i2c_adap);
+    
+    return i2c_add_driver(&mma7660_driver);
+}
+
+static void __exit mma7660_exit(void)
+{
+    i2c_unregister_device(mma7660_client);
+    i2c_del_driver(&mma7660_driver);
+}
+
+MODULE_AUTHOR("Zhining Song <songzhining@actions-semi.com>");
+MODULE_DESCRIPTION("MMA7660 3-Axis Orientation/Motion Detection Sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(mma7660_init);
+module_exit(mma7660_exit);
+
diff --git a/drivers/input/misc/gsensor/stk8312/Makefile b/drivers/input/misc/gsensor/stk8312/Makefile
new file mode 100755
index 0000000..ad0c9a2
--- /dev/null
+++ b/drivers/input/misc/gsensor/stk8312/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the mma7660 drivers
+#
+
+obj-$(CONFIG_GSENSOR_STK8312) += gsensor_stk8312.o
+gsensor_stk8312-objs := stk831x.o
diff --git a/drivers/input/misc/gsensor/stk8312/stk8312.h b/drivers/input/misc/gsensor/stk8312/stk8312.h
new file mode 100755
index 0000000..15f8b50
--- /dev/null
+++ b/drivers/input/misc/gsensor/stk8312/stk8312.h
@@ -0,0 +1,51 @@
+/*
+ * Definitions for Sensortek stk8312 accelerometer
+ */
+#ifndef _STK831X_H_
+#define _STK831X_H_
+
+#include <linux/ioctl.h>
+#define STK831X_I2C_NAME		"stk831x"
+#define ACC_IDEVICE_NAME		"stk8312"
+#define STKDIR				0x3D
+#define STK_LSB_1G		21
+/* registers for stk8312 registers */
+
+#define	STK831X_XOUT	0x00	/* x-axis acceleration*/
+#define	STK831X_YOUT	0x01	/* y-axis acceleration*/
+#define	STK831X_ZOUT	0x02	/* z-axis acceleration*/
+#define	STK831X_TILT	 	0x03	/* Tilt Status */
+#define	STK831X_SRST	0x04	/* Sampling Rate Status */
+#define	STK831X_SPCNT	0x05	/* Sleep Count */
+#define	STK831X_INTSU	0x06	/* Interrupt setup*/
+#define	STK831X_MODE	0x07
+#define	STK831X_SR		0x08	/* Sample rate */
+#define	STK831X_PDET	0x09	/* Tap Detection */
+#define	STK831X_DEVID	0x0B	/* Device ID */
+#define	STK831X_OFSX	0x0C	/* X-Axis offset */
+#define	STK831X_OFSY	0x0D	/* Y-Axis offset */
+#define	STK831X_OFSZ	0x0E	/* Z-Axis offset */
+#define	STK831X_PLAT	0x0F	/* Tap Latency */
+#define	STK831X_PWIN	0x10	/* Tap Window */	
+#define	STK831X_FTH		0x11	/* Free-Fall Threshold */
+#define	STK831X_FTM	0x12	/* Free-Fall Time */
+#define	STK831X_STH	0x13	/* Shake Threshold */
+#define	STK831X_CTRL	0x14	/* Control Register */
+#define	STK831X_RESET	0x20	/*software reset*/
+
+/* IOCTLs*/
+#define STK_IOCTL_WRITE				_IOW(STKDIR, 0x01, char[8])
+#define STK_IOCTL_READ				_IOWR(STKDIR, 0x02, char[8])
+#define STK_IOCTL_SET_ENABLE			_IOW(STKDIR, 0x03, char)
+#define STK_IOCTL_GET_ENABLE			_IOR(STKDIR, 0x04, char)
+#define STK_IOCTL_SET_DELAY			_IOW(STKDIR, 0x05, char)
+#define STK_IOCTL_GET_DELAY			_IOR(STKDIR, 0x06, char)
+#define STK_IOCTL_SET_OFFSET			_IOW(STKDIR, 0x07, char[3])
+#define STK_IOCTL_GET_OFFSET			_IOR(STKDIR, 0x08, char[3])
+#define STK_IOCTL_GET_ACCELERATION	_IOR(STKDIR, 0x09, int[3])
+#define STK_IOCTL_SET_RANGE			_IOW(STKDIR, 0x10, char)
+#define STK_IOCTL_GET_RANGE			_IOR(STKDIR, 0x11, char)
+#define STK_IOCTL_SET_CALI			_IOW(STKDIR, 0x12, char)
+
+
+#endif
diff --git a/drivers/input/misc/gsensor/stk8312/stk831x.c b/drivers/input/misc/gsensor/stk8312/stk831x.c
new file mode 100755
index 0000000..93de4d6
--- /dev/null
+++ b/drivers/input/misc/gsensor/stk8312/stk831x.c
@@ -0,0 +1,2989 @@
+/* file stk8312.c
+   brief This file contains all function implementations for the SK8312 in linux
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/fcntl.h>
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+//#include "../gsensor_common.h"
+
+
+#define CONFIG_SENSORS_STK8312
+//#define CONFIG_SENSORS_STK8313
+
+
+
+
+#ifdef CONFIG_SENSORS_STK8312
+	#include "stk8312.h"
+	#define SENSOR_NAME              "stk8312"
+	#define SENSOR_I2C_ADDR         0x3d
+#elif defined (CONFIG_SENSORS_STK8313)
+	#include "stk8313.h"
+	#define SENSOR_NAME              "stk8313"
+	#define SENSOR_I2C_ADDR         0x22
+#endif
+
+
+//#define ABSMIN                          -32
+//#define ABSMAX                          31
+//#define FUZZ                    1
+
+#define STK_ACC_POLLING_MODE	1
+#if (!STK_ACC_POLLING_MODE)
+	#define ADDITIONAL_GPIO_CFG 1
+	#define STK_INT_PIN	39
+#endif
+
+#define POSITIVE_Z_UP		0
+#define NEGATIVE_Z_UP	1
+#define POSITIVE_X_UP		2
+#define NEGATIVE_X_UP	3
+#define POSITIVE_Y_UP		4
+#define NEGATIVE_Y_UP	5
+static unsigned char stk831x_placement = POSITIVE_Z_UP;
+
+
+#define STK_PERMISSION_THREAD
+#define STK_RESUME_RE_INIT	
+//#define STK_DEBUG_PRINT
+//#define STK_DEBUG_RAWDATA
+//#define STK_LOWPASS
+#define STK_FIR_LEN	4
+
+#define STK831X_INIT_ODR		0		//0:100Hz, 1:50Hz, 2:25Hz
+#define STK831X_SAMPLE_TIME_BASE		2
+#define STK831X_SAMPLE_TIME_NO		4
+const static int STK831X_SAMPLE_TIME[STK831X_SAMPLE_TIME_NO] = {10000, 20000, 40000, 80000};
+static struct stk831x_data *stk831x_data_ptr;
+
+
+#define STK_ACC_DRIVER_VERSION	"1.6.1 2013/05/24"
+
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  1
+
+// calibration file path
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+#define MAX_DELAY              10
+
+#define STK_DEBUG_CALI
+#define STK_SAMPLE_NO				10
+#define STK_ACC_CALI_VER0			0x3D
+#define STK_ACC_CALI_VER1			0x01
+//#define STK_ACC_CALI_FILE 			"/data/misc/stkacccali.conf"
+#define STK_ACC_CALI_FILE 	 "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+#define STK_ACC_CALI_FILE_SIZE 		10
+
+#define STK_K_SUCCESS_TUNE			0x04
+#define STK_K_SUCCESS_FT2			0x03
+#define STK_K_SUCCESS_FT1			0x02
+#define STK_K_SUCCESS_FILE			0x01
+#define STK_K_NO_CALI					0xFF
+#define STK_K_RUNNING				0xFE
+#define STK_K_FAIL_LRG_DIFF			0xFD
+#define STK_K_FAIL_OPEN_FILE			0xFC
+#define STK_K_FAIL_W_FILE				0xFB
+#define STK_K_FAIL_R_BACK			0xFA
+#define STK_K_FAIL_R_BACK_COMP		0xF9
+#define STK_K_FAIL_I2C					0xF8
+#define STK_K_FAIL_K_PARA			0xF7
+#define STK_K_FAIL_OTP_OUT_RG		0xF6
+#define STK_K_FAIL_ENG_I2C			0xF5
+#define STK_K_FAIL_FT1_USD			0xF4
+#define STK_K_FAIL_FT2_USD			0xF3
+#define STK_K_FAIL_WRITE_NOFST		0xF2
+#define STK_K_FAIL_OTP_5T			0xF1
+#define STK_K_FAIL_PLACEMENT		0xF0
+
+
+//#define STK_ZG_FILTER
+#ifdef CONFIG_SENSORS_STK8312
+	#define STK_ZG_COUNT	1
+#elif defined (CONFIG_SENSORS_STK8313)
+	#define STK_ZG_COUNT	4
+#endif
+
+#define STK_TUNE
+#ifdef CONFIG_SENSORS_STK8312
+	#define STK_TUNE_XYOFFSET 3
+	#define STK_TUNE_ZOFFSET 6
+	#define STK_TUNE_NOISE 5
+#elif defined (CONFIG_SENSORS_STK8313)
+	#define STK_TUNE_XYOFFSET 35
+	#define STK_TUNE_ZOFFSET 75
+	#define STK_TUNE_NOISE 20	
+#endif
+#define STK_TUNE_NUM 125
+#define STK_TUNE_DELAY 125
+
+#ifdef STK_TUNE
+static char stk_tune_offset_record[3] = {0};
+static int stk_tune_offset[3] = {0};
+static int stk_tune_sum[3] = {0};
+static int stk_tune_max[3] = {0};
+static int stk_tune_min[3] = {0};
+static int stk_tune_index = 0;
+static int stk_tune_done = 0;
+#endif
+
+#define DEBUG_ENABLE      1
+#define stk831x_info(fmt,arg...) \
+	do { if (DEBUG_ENABLE) printk("[STK831x][%s][LINE:%d]"fmt,__func__, __LINE__ , ##arg) ;} \
+		while(0)
+
+#define stk831x_err(fmt , arg...) \
+	printk("[STK831X_ERROR][%s][LINE:%d]"fmt, __func__ , __LINE__ ,##arg)
+
+
+
+#if defined(STK_LOWPASS)
+#define MAX_FIR_LEN 32
+struct data_filter {
+    s16 raw[MAX_FIR_LEN][3];
+    int sum[3];
+    int num;
+    int idx;
+};
+#endif
+
+struct stk831x_data 
+{
+    struct input_dev *input_dev;
+    struct mutex enable_mutex;
+    atomic_t selftest_result;
+	int irq;	
+	int raw_data[3]; 
+
+	atomic_t delay1;
+    unsigned char delay;
+    atomic_t enabled;
+	bool re_enable;
+	bool first_enable;
+    struct input_dev *input;
+    struct delayed_work work;
+    unsigned char mode;
+	atomic_t cali_status;
+	struct mutex write_lock;
+	char recv_reg;
+	
+#if STK_ACC_POLLING_MODE
+	struct hrtimer acc_timer;	
+    struct work_struct stk_acc_work;
+	struct workqueue_struct *stk_acc_wq;	
+	ktime_t acc_poll_delay;		
+#endif	
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend early_suspend;
+#endif
+    atomic_t fuzz;
+    atomic_t position;
+    atomic_t calibrated;
+    unsigned char offset_saved[3];
+#if defined(STK_LOWPASS)
+		atomic_t				firlength;
+		atomic_t				fir_en;
+		struct data_filter		fir;
+#endif 	
+
+};
+
+
+
+static int event_since_en = 0;
+
+static void STK831X_Tune(struct stk831x_data *stk, int acc[]);
+static int STK831X_GetEnable(struct stk831x_data *stk, char* gState);
+static int STK831X_SetOffset(char buf[]);
+static int STK831X_SetEnable(struct stk831x_data *stk, char en);
+static int STK831X_GetCali(struct stk831x_data *stk);
+static int STK831X_SetCali(struct stk831x_data *stk, char sstate);
+static int STK831X_GetOffset(char buf[]);
+static int STK831X_SetDelay(struct stk831x_data *stk, uint32_t sdelay_ns);
+static int STK831X_GetDelay(struct stk831x_data *stk, uint32_t* gdelay_ns);
+//static int STK831X_SetRange(char srange);
+//static int STK831X_GetRange(char* grange);
+static int32_t stk_get_file_content(char * r_buf, int8_t buf_size);
+static int stk_store_in_file(char offset[], char mode);
+static int STK831X_Init(struct stk831x_data *stk, struct i2c_client *client);
+
+static struct i2c_client *this_client;
+
+static int STK_i2c_Rx(char *rxData, int length)
+{
+	uint8_t retry;	
+	struct i2c_msg msgs[] = 
+	{
+		{
+			.addr = this_client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = rxData,
+		},
+		{
+			.addr = this_client->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = rxData,
+		},
+	};
+	
+	for (retry = 0; retry <= 3; retry++) 
+	{
+		if (i2c_transfer(this_client->adapter, msgs, 2) > 0)
+			break;
+		else
+			mdelay(10);
+	}
+	
+	if (retry > 3) 
+	{
+		printk(KERN_ERR "%s: retry over 3\n", __func__);
+		return -EIO;
+	} 
+	else
+		return 0;	
+}
+
+static int STK_i2c_Tx(char *txData, int length)
+{
+
+	int retry;
+	struct i2c_msg msg[] = 
+	{
+		{
+			.addr = this_client->addr,
+			.flags = 0,
+			.len = length,
+			.buf = txData,
+		},
+	};
+	
+	for (retry = 0; retry <= 3; retry++) 
+	{
+		if (i2c_transfer(this_client->adapter, msg, 1) > 0)
+			break;
+		else
+			mdelay(10);
+	}
+	
+	if(*txData >= 0x21 && *txData <= 0x3F)
+	{
+		if(*txData == 0x3F)
+			msleep(1);
+		for (retry = 0; retry <= 3; retry++) 
+		{
+			if (i2c_transfer(this_client->adapter, msg, 1) > 0)
+				break;
+			else
+				mdelay(10);
+		}		
+	}
+	
+	if (retry > 3) 
+	{
+		printk(KERN_ERR "%s: retry over 3\n", __func__);
+		return -EIO;
+	}
+	else
+		return 0;	
+}
+
+static int STK831X_ReadByteOTP(char rReg, char *value)
+{
+	int redo = 0;
+	int result;
+	char buffer[2] = "";
+	*value = 0;
+	
+	buffer[0] = 0x3D;
+	buffer[1] = rReg;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto eng_i2c_r_err;
+	}
+	buffer[0] = 0x3F;
+	buffer[1] = 0x02;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto eng_i2c_r_err;
+	}
+	
+	msleep(1);	
+	do {
+		buffer[0] = 0x3F;
+		result = STK_i2c_Rx(buffer, 1);	
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed\n", __func__);
+			goto eng_i2c_r_err;
+		}
+		if(buffer[0]& 0x80)
+		{
+			break;
+		}		
+		msleep(1);
+		redo++;
+	}while(redo < 5);
+	
+	if(redo == 5)
+	{
+		printk(KERN_ERR "%s:OTP read repeat read 5 times! Failed!\n", __func__);
+		return -STK_K_FAIL_OTP_5T;
+	}	
+	buffer[0] = 0x3E;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto eng_i2c_r_err;
+	}	
+	*value = buffer[0];
+#ifdef STK_DEBUG_CALI		
+	printk(KERN_INFO "%s: read 0x%x=0x%x\n", __func__, rReg, *value);
+#endif	
+	return 0;
+	
+eng_i2c_r_err:	
+	return -STK_K_FAIL_ENG_I2C;	
+}
+
+static int STK831X_WriteByteOTP(char wReg, char value)
+{
+
+	int redo = 0;
+	int result;
+	char buffer[2] = "";
+	char read_back;
+	
+	redo = 0;
+	do {
+		redo++;
+		
+		buffer[0] = 0x3D;
+		buffer[1] = wReg;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);
+			goto eng_i2c_w_err;
+		}
+		buffer[0] = 0x3E;
+		buffer[1] = value;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);
+			goto eng_i2c_w_err;
+		}				
+		buffer[0] = 0x3F;
+		buffer[1] = 0x01;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);			
+			goto eng_i2c_w_err;
+		}				
+		msleep(1);
+		
+		buffer[0] = 0x3F;
+		result = STK_i2c_Rx(buffer, 1);	
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);			
+			goto eng_i2c_w_err;
+		}
+		if(buffer[0]& 0x80)
+		{
+			result = STK831X_ReadByteOTP(wReg, &read_back);
+			if(result < 0)
+			{
+				printk(KERN_ERR "%s: read back error, result=%d\n", __func__, result);
+				goto eng_i2c_w_err;
+			}
+			
+			if(read_back == value)
+			{
+#ifdef STK_DEBUG_CALI					
+				printk(KERN_INFO "%s: write 0x%x=0x%x successfully\n", __func__, wReg, value);
+#endif				
+				break;
+			}
+			else
+				printk(KERN_ERR "%s: read back mismatch, write 0x%x=0x%x, read 0x%x=0x%x, try again\n", __func__, wReg, value, wReg, read_back);
+		}
+		msleep(1);
+	}while(redo < 5);
+	
+	if(redo == 5)
+	{
+		printk(KERN_ERR "%s:OTP write 0x%x repeat read 5 times! Failed!\n", __func__, wReg);
+		return -STK_K_FAIL_OTP_5T;
+	}		
+	return 0;
+
+eng_i2c_w_err:	
+	return -STK_K_FAIL_ENG_I2C;
+}
+
+
+static int STK831X_SetVD(struct stk831x_data *stk)
+{
+
+	int result;
+	char buffer[2] = "";
+	char reg24;
+	
+	msleep(2);
+	result = STK831X_ReadByteOTP(0x70, &reg24);
+	if(result < 0)
+	{
+		printk(KERN_ERR "%s: read back error, result=%d\n", __func__, result);
+		return result;
+	}
+	
+	if(reg24 != 0)
+	{
+		buffer[0] = 0x24;
+		buffer[1] = reg24;
+		//printk(KERN_INFO "%s:write 0x%x to 0x24\n",  __func__, buffer[1]);
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed\n", __func__);
+			return result;
+		}
+	}	
+	else
+	{
+		//printk(KERN_INFO "%s: reg24=0, do nothing\n", __func__);
+		return 0;
+	}
+	
+	buffer[0] = 0x24;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}				
+	if(buffer[0] != reg24)
+	{
+		printk(KERN_ERR "%s: error, reg24=0x%x, read=0x%x\n", __func__, reg24, buffer[0]);
+		return -1;
+	}
+	//printk(KERN_INFO "%s: successfully", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_SENSORS_STK8312
+static int STK831X_ReadSensorData(struct stk831x_data *stk)
+{	
+	int result;
+	char buffer[3] = "";
+	int acc_xyz[3] = {0};
+#ifdef STK_ZG_FILTER	
+	s16 zero_fir = 0;	
+#endif	
+#ifdef STK_LOWPASS
+	int idx, firlength = atomic_read(&stk->firlength);   
+#endif	
+	int k_status = atomic_read(&stk->cali_status);
+	memset(buffer, 0, 3);
+	
+	buffer[0] = STK831X_XOUT;
+	result = STK_i2c_Rx(buffer, 3);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:i2c transfer error\n", __func__);
+		return result;
+	}	
+
+	if (buffer[0] & 0x80)
+		acc_xyz[0] = buffer[0] - 256;
+	else
+		acc_xyz[0] = buffer[0];
+	if (buffer[1] & 0x80)
+		acc_xyz[1] = buffer[1] - 256;
+	else
+		acc_xyz[1] = buffer[1];
+	if (buffer[2] & 0x80)
+		acc_xyz[2] = buffer[2] - 256;
+	else
+		acc_xyz[2] = buffer[2];
+
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:RAW  %4d,%4d,%4d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+
+	if(k_status == STK_K_RUNNING)
+	{
+		stk->raw_data[0] = acc_xyz[0];
+		stk->raw_data[1] = acc_xyz[1];
+		stk->raw_data[2] = acc_xyz[2];	
+		return 0;
+	}		
+	
+	
+#ifdef STK_LOWPASS
+	if(atomic_read(&stk->fir_en))
+	{
+		if(stk->fir.num < firlength)
+		{                
+			stk->fir.raw[stk->fir.num][0] = acc_xyz[0];
+			stk->fir.raw[stk->fir.num][1] = acc_xyz[1];
+			stk->fir.raw[stk->fir.num][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.num++;
+			stk->fir.idx++;
+		}
+		else
+		{
+			idx = stk->fir.idx % firlength;
+			stk->fir.sum[0] -= stk->fir.raw[idx][0];
+			stk->fir.sum[1] -= stk->fir.raw[idx][1];
+			stk->fir.sum[2] -= stk->fir.raw[idx][2];
+			stk->fir.raw[idx][0] = acc_xyz[0];
+			stk->fir.raw[idx][1] = acc_xyz[1];
+			stk->fir.raw[idx][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.idx++;	
+			acc_xyz[0] = stk->fir.sum[0]/firlength;
+			acc_xyz[1] = stk->fir.sum[1]/firlength;
+			acc_xyz[2] = stk->fir.sum[2]/firlength;					
+		}
+	}
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:After FIR  %4d,%4d,%4d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+
+#endif  	/* #ifdef STK_LOWPASS */
+		
+
+		
+#ifdef STK_TUNE
+	if((k_status&0xF0) != 0)
+		STK831X_Tune(stk, acc_xyz);		
+#endif					
+
+#ifdef STK_ZG_FILTER
+	if( abs(acc_xyz[0]) <= STK_ZG_COUNT)	
+		acc_xyz[0] = (acc_xyz[0]*zero_fir);	
+	if( abs(acc_xyz[1]) <= STK_ZG_COUNT)
+		acc_xyz[1] = (acc_xyz[1]*zero_fir);
+	if( abs(acc_xyz[2]) <= STK_ZG_COUNT)
+		acc_xyz[2] = (acc_xyz[2]*zero_fir);
+#endif 	/* #ifdef STK_ZG_FILTER */	
+
+	stk->raw_data[0] = acc_xyz[0];
+	stk->raw_data[1] = acc_xyz[1];
+	stk->raw_data[2] = acc_xyz[2];
+	
+	return 0;	
+}
+
+#elif defined CONFIG_SENSORS_STK8313
+static int STK831X_ReadSensorData(struct stk831x_data *stk)
+{	
+	int result;
+	char buffer[6] = "";
+	int acc_xyz[3] = {0};	
+#ifdef STK_ZG_FILTER	
+	s16 zero_fir = 0;	
+#endif	
+#ifdef STK_LOWPASS
+	int idx, firlength = atomic_read(&stk->firlength);   
+#endif	
+	int k_status = atomic_read(&stk->cali_status);
+	
+	memset(buffer, 0, 6);	
+	buffer[0] = STK831X_XOUT;
+	result = STK_i2c_Rx(buffer, 6);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:i2c transfer error\n", __func__);
+		return result;
+	}			
+		
+	if (buffer[0] & 0x80)
+		acc_xyz[0] = ((int)buffer[0]<<4) + (buffer[1]>>4) - 4096;
+	else
+		acc_xyz[0] = ((int)buffer[0]<<4) + (buffer[1]>>4);
+	if (buffer[2] & 0x80)
+		acc_xyz[1] = ((int)buffer[2]<<4) + (buffer[3]>>4) - 4096;
+	else
+		acc_xyz[1] = ((int)buffer[2]<<4) + (buffer[3]>>4);
+	if (buffer[4] & 0x80)
+		acc_xyz[2] = ((int)buffer[4]<<4) + (buffer[5]>>4) - 4096;
+	else
+		acc_xyz[2] = ((int)buffer[4]<<4) + (buffer[5]>>4);
+
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:RAW  %4d,%4d,%4d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+
+	if(k_status == STK_K_RUNNING)
+	{
+		stk->raw_data[0] = acc_xyz[0];
+		stk->raw_data[1] = acc_xyz[1];
+		stk->raw_data[2] = acc_xyz[2];	
+		return 0;
+	}
+	
+	
+#ifdef STK_LOWPASS
+	if(atomic_read(&stk->fir_en))
+	{
+		if(stk->fir.num < firlength)
+		{                
+			stk->fir.raw[stk->fir.num][0] = acc_xyz[0];
+			stk->fir.raw[stk->fir.num][1] = acc_xyz[1];
+			stk->fir.raw[stk->fir.num][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.num++;
+			stk->fir.idx++;
+		}
+		else
+		{
+			idx = stk->fir.idx % firlength;
+			stk->fir.sum[0] -= stk->fir.raw[idx][0];
+			stk->fir.sum[1] -= stk->fir.raw[idx][1];
+			stk->fir.sum[2] -= stk->fir.raw[idx][2];
+			stk->fir.raw[idx][0] = acc_xyz[0];
+			stk->fir.raw[idx][1] = acc_xyz[1];
+			stk->fir.raw[idx][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.idx++;	
+			acc_xyz[0] = stk->fir.sum[0]/firlength;
+			acc_xyz[1] = stk->fir.sum[1]/firlength;
+			acc_xyz[2] = stk->fir.sum[2]/firlength;					
+		}
+	}
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:After FIR  %4d,%4d,%4d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+	
+#endif  	/* #ifdef STK_LOWPASS */
+			
+		
+#ifdef STK_TUNE
+	if((k_status&0xF0) != 0)
+		STK831X_Tune(stk, acc_xyz);		
+#endif					
+
+#ifdef STK_ZG_FILTER
+	if( abs(acc_xyz[0]) <= STK_ZG_COUNT)	
+		acc_xyz[0] = (acc_xyz[0]*zero_fir);	
+	if( abs(acc_xyz[1]) <= STK_ZG_COUNT)
+		acc_xyz[1] = (acc_xyz[1]*zero_fir);
+	if( abs(acc_xyz[2]) <= STK_ZG_COUNT)
+		acc_xyz[2] = (acc_xyz[2]*zero_fir);
+#endif 	/* #ifdef STK_ZG_FILTER */	
+
+	stk->raw_data[0] = acc_xyz[0];
+	stk->raw_data[1] = acc_xyz[1];
+	stk->raw_data[2] = acc_xyz[2];
+
+	return 0;	
+}
+#endif
+
+
+static int stk831x_axis_remap(struct stk831x_data *stk)
+{
+
+	s16 swap;
+    int stk_position = atomic_read(&stk->position);
+
+    switch (abs(stk_position)) {
+        case 1:
+            stk->raw_data[0] = -(stk->raw_data[0]);
+           stk->raw_data[1] = -(stk->raw_data[1]);
+            break;
+        case 2:
+            swap = stk->raw_data[0];
+            stk->raw_data[0] = -stk->raw_data[1];
+            stk->raw_data[1] = swap;
+            break;
+        case 3:
+            break;
+        case 4:
+            swap = stk->raw_data[0];
+            stk->raw_data[0] = stk->raw_data[1];
+            stk->raw_data[1] = -swap; 
+            break;
+    }
+    
+    if (stk_position < 0) {
+        stk->raw_data[2] = -(stk->raw_data[2]);
+        stk->raw_data[0] = -(stk->raw_data[0]);
+    }
+    
+    return 0;
+}
+
+
+static int STK831X_ReportValue(struct stk831x_data *stk)
+{
+	if(event_since_en < 1200)
+	{
+		event_since_en++;
+		if(event_since_en < 12)
+			return 0;		
+	}
+		
+#ifdef STK_DEBUG_PRINT	
+	printk(KERN_INFO "report  X:%4d,Y:%4d, Z:%4d\n",stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif	
+	
+	stk831x_axis_remap(stk);
+	
+	input_report_abs(stk->input_dev, ABS_X, stk->raw_data[0]);  
+	input_report_abs(stk->input_dev, ABS_Y, stk->raw_data[1]);
+	input_report_abs(stk->input_dev, ABS_Z, stk->raw_data[2]);
+	input_sync(stk->input_dev);
+	return 0;
+}
+
+static int stk831x_read_file(char *path, char *buf, int size)
+{
+	
+
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+
+static int stk831x_load_user_calibration(struct stk831x_data *stk)
+{
+    char buffer[16];
+    int ret = 0;
+    int data[3];
+    unsigned char offset[3];
+   	char enable;
+	
+    int calibrated = atomic_read(&stk->calibrated);
+    
+    // only calibrate once
+    if (calibrated) {
+        goto usr_calib_end;
+    } else {
+        atomic_set(&stk->calibrated, 1);
+    }
+
+    ret = stk831x_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d", &data[0], &data[1], &data[2]);
+    offset[0] = (unsigned char) data[0];
+    offset[1] = (unsigned char) data[1];
+    offset[2] = (unsigned char) data[2];    
+    
+    printk(KERN_ERR "-------------user cfg_calibration: %d %d %d----------\n", offset[0], offset[1], offset[2]);
+
+	STK831X_GetEnable(stk , &enable);
+
+	stk831x_info("enable = %d \n" , enable);
+	STK831X_SetEnable(stk , 0);
+    if (STK831X_SetOffset(offset) < 0) {
+        printk(KERN_ERR "set offset fail\n");
+        goto usr_calib_end;
+    }
+    stk->first_enable = false;  //david add.
+    printk(KERN_INFO "load user calibration finished\n");
+	STK831X_SetEnable(stk , enable);
+	
+usr_calib_end:
+    return ret;
+}
+
+
+#if STK_ACC_POLLING_MODE
+static void stk831x_work_func(struct work_struct *work)
+{
+	struct stk831x_data *stk = container_of((struct delayed_work *)work, struct stk831x_data, work);
+
+    unsigned long delay = msecs_to_jiffies(atomic_read(&stk->delay1));
+
+	STK831X_ReadSensorData(stk);
+	STK831X_ReportValue(stk);
+    
+    
+    schedule_delayed_work(&stk->work, delay);
+}
+#endif
+
+static ssize_t stk831x_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	return scnprintf(buf, PAGE_SIZE,  "%d\n", atomic_read(&stk->enabled));
+}
+
+static ssize_t stk831x_enable_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+
+	unsigned long data;
+	int error;
+
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+	if ((data == 0)||(data==1)) 
+		STK831X_SetEnable(stk,data);	
+	else
+		printk(KERN_ERR "%s: invalud argument, data=%ld\n", __func__, data);
+	return count;
+}
+
+static ssize_t stk831x_value_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+	int ddata[3];
+
+	printk(KERN_INFO "driver version:%s\n",STK_ACC_DRIVER_VERSION);	
+	STK831X_ReadSensorData(stk);
+	ddata[0]= stk->raw_data[0];
+	ddata[1]= stk->raw_data[1];
+	ddata[2]= stk->raw_data[2];
+	return scnprintf(buf, PAGE_SIZE,  "%d %d %d\n", ddata[0], ddata[1], ddata[2]);
+}
+
+static ssize_t stk831x_calibration_value_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	
+	char buffer[3] = "";
+	struct stk831x_data *stk = NULL;
+	
+	stk = i2c_get_clientdata(this_client);
+	
+	printk(KERN_INFO "driver version:%s\n",STK_ACC_DRIVER_VERSION);	
+
+	buffer[0] = STK831X_OFSX;
+    STK_i2c_Rx(buffer, 3);
+	
+	return sprintf(buf, "%d %d %d\n", buffer[0] , buffer[1], buffer[2]);
+}
+
+static ssize_t stk831x_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)		
+{
+	int result;
+	char buffer[4] = "";
+	struct stk831x_data *stk = NULL;
+
+	stk = i2c_get_clientdata(this_client);
+
+	buffer[0] = STK831X_OFSX;	
+	buffer[1] = buf[0];
+	buffer[2] = buf[1];
+	buffer[3] = buf[2];
+	
+	result = STK_i2c_Tx(buffer, 4);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed\n", __func__);
+			return result;
+		}	
+		return count;
+
+}
+
+
+static int STK831X_GetDelay(struct stk831x_data *stk, uint32_t* gdelay_ns)
+{
+	*gdelay_ns = (uint32_t) STK831X_SAMPLE_TIME[stk->delay] * 1000;
+	return 0;	
+}
+
+static ssize_t stk831x_delay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+
+	
+
+	
+	return sprintf(buf , "%d\n", atomic_read(&stk->delay1));
+}
+
+static ssize_t stk831x_delay_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+
+	if(data < 10)
+		data = 10;
+	else if(data > 20)
+		data = 20;
+	
+	atomic_set(&stk->delay1 , data);
+	STK831X_SetDelay(stk, data*1000000);	// ms to ns
+	
+	return count;
+}
+
+static int STK831X_GetCali(struct stk831x_data *stk)
+{
+
+	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
+	char offset[3], mode;	
+	int cnt, result;
+	char regR[6];
+	
+#ifdef STK_TUNE		
+	printk(KERN_INFO "%s: stk_tune_done=%d, stk_tune_offset=%d,%d,%d\n", __func__, stk_tune_done, stk_tune_offset[0],
+		stk_tune_offset[1], stk_tune_offset[2]);
+#endif		
+	if ((stk_get_file_content(r_buf, STK_ACC_CALI_FILE_SIZE)) == 0)
+	{
+		if(r_buf[0] == STK_ACC_CALI_VER0 && r_buf[1] == STK_ACC_CALI_VER1)
+		{
+			offset[0] = r_buf[2];
+			offset[1] = r_buf[3];
+			offset[2] = r_buf[4];
+			mode = r_buf[5];
+			printk(KERN_INFO "%s:file offset:%#02x,%#02x,%#02x,%#02x\n", __func__, offset[0], offset[1], offset[2], mode);							
+		}
+		else
+		{
+			printk(KERN_ERR "%s: cali version number error! r_buf=0x%x,0x%x,0x%x,0x%x,0x%x\n", 
+			__func__, r_buf[0], r_buf[1], r_buf[2], r_buf[3], r_buf[4]);						
+		}
+	}
+	else
+		printk(KERN_INFO "%s: No file offset\n", __func__);
+	
+	for(cnt=0x43;cnt<0x49;cnt++)
+	{
+		result = STK831X_ReadByteOTP(cnt, &(regR[cnt-0x43]));
+		if(result < 0)
+			printk(KERN_ERR "%s: STK831X_ReadByteOTP failed, ret=%d\n", __func__, result);		
+	}
+	printk(KERN_INFO "%s: OTP offset 1:%#02x,%#02x,%#02x,%#02x,%#02x,%#02x\n", __func__, regR[0], 
+		regR[1], regR[2],regR[3], regR[4], regR[5]);
+		
+	for(cnt=0x53;cnt<0x59;cnt++)
+	{
+		result = STK831X_ReadByteOTP(cnt, &(regR[cnt-0x53]));
+		if(result < 0)
+			printk(KERN_ERR "%s: STK831X_ReadByteOTP failed, ret=%d\n", __func__, result);
+	}
+	printk(KERN_INFO "%s: OTP offset 2:%#02x,%#02x,%#02x,%#02x,%#02x,%#02x\n", __func__, regR[0], 
+		regR[1], regR[2],regR[3], regR[4], regR[5]);
+	
+	return 0;
+}
+
+static int STK831X_GetEnable(struct stk831x_data *stk, char* gState)
+{
+
+
+	*gState = atomic_read(&stk->enabled);
+	return 0;
+}
+
+
+static int STK831X_VerifyCali(struct stk831x_data *stk, unsigned char en_dis)
+{
+
+	unsigned char axis, state;	
+	int acc_ave[3] = {0, 0, 0};
+	const unsigned char verify_sample_no = 3;		
+#ifdef CONFIG_SENSORS_STK8313
+	const unsigned char verify_diff = 20;	
+#elif defined CONFIG_SENSORS_STK8312
+	const unsigned char verify_diff = 2;		
+#endif		
+	int result;
+	char buffer[2] = "";
+	int ret = 0;
+	
+	if(en_dis)
+	{
+		STK831X_SetDelay(stk, 10000000);
+		buffer[0] = STK831X_MODE;
+		result = STK_i2c_Rx(buffer, 1);	
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);
+			return -STK_K_FAIL_I2C;
+		}			
+		buffer[1] = (buffer[0] & 0xF8) | 0x01;
+		buffer[0] = STK831X_MODE;	
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+			return -STK_K_FAIL_I2C;
+		}
+		STK831X_SetVD(stk);			
+		msleep(150);	
+	}
+	
+	for(state=0;state<verify_sample_no;state++)
+	{
+		STK831X_ReadSensorData(stk);
+		for(axis=0;axis<3;axis++)			
+			acc_ave[axis] += stk->raw_data[axis];	
+#ifdef STK_DEBUG_CALI				
+		printk(KERN_INFO "%s: acc=%d,%d,%d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+		msleep(10);		
+	}		
+	
+	for(axis=0;axis<3;axis++)
+		acc_ave[axis] /= verify_sample_no;
+	
+	switch(stk831x_placement)
+	{
+	case POSITIVE_X_UP:
+		acc_ave[0] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_X_UP:
+		acc_ave[0] += STK_LSB_1G;		
+		break;
+	case POSITIVE_Y_UP:
+		acc_ave[1] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_Y_UP:
+		acc_ave[1] += STK_LSB_1G;
+		break;
+	case POSITIVE_Z_UP:
+		acc_ave[2] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_Z_UP:
+		acc_ave[2] += STK_LSB_1G;
+		break;
+	default:
+		printk("%s: invalid stk831x_placement=%d\n", __func__, stk831x_placement);
+		ret = -STK_K_FAIL_PLACEMENT;
+		break;
+	}	
+	if(abs(acc_ave[0]) > verify_diff || abs(acc_ave[1]) > verify_diff || abs(acc_ave[2]) > verify_diff)
+	{
+		printk(KERN_INFO "%s:Check data x:%d, y:%d, z:%d\n", __func__,acc_ave[0],acc_ave[1],acc_ave[2]);		
+		printk(KERN_ERR "%s:Check Fail, Calibration Fail\n", __func__);
+		ret = -STK_K_FAIL_LRG_DIFF;
+	}	
+#ifdef STK_DEBUG_CALI
+	else
+		printk(KERN_INFO "%s:Check data pass\n", __func__);
+#endif	
+	if(en_dis)
+	{
+		buffer[0] = STK831X_MODE;
+		result = STK_i2c_Rx(buffer, 1);	
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+			return -STK_K_FAIL_I2C;
+		}			
+		buffer[1] = (buffer[0] & 0xF8);
+		buffer[0] = STK831X_MODE;	
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+			return -STK_K_FAIL_I2C;
+		}		
+	}	
+	
+	return ret;
+}
+
+static int STK831X_SetDelay(struct stk831x_data *stk, uint32_t sdelay_ns)
+{
+
+	unsigned char sr_no;	
+	int result;
+	char buffer[2] = "";
+	uint32_t sdelay_us = sdelay_ns / 1000;
+
+	for(sr_no=(STK831X_SAMPLE_TIME_NO-1);sr_no>0;sr_no--)
+	{
+		if(sdelay_us >= STK831X_SAMPLE_TIME[sr_no])	
+			break;		
+	}	
+
+	
+#ifdef STK_DEBUG_PRINT		
+	printk(KERN_INFO "%s:sdelay_us=%d\n", __func__, sdelay_us);
+#endif	
+
+	mutex_lock(&stk->write_lock);
+	if(stk->delay == sr_no)
+	{
+		mutex_unlock(&stk->write_lock);	
+		return 0;
+	}
+	buffer[0] = STK831X_SR;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto d_err_i2c;
+	}			
+	
+	buffer[1] = (buffer[0] & 0xF8) | ((sr_no & 0x07) + STK831X_SAMPLE_TIME_BASE);
+	buffer[0] = STK831X_SR;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto d_err_i2c;
+	}	
+	stk->delay = sr_no;
+#if STK_ACC_POLLING_MODE	
+//	atomic_set(stk->delay1 , STK831X_SAMPLE_TIME[sr_no]*USEC_PER_MSEC);
+	//stk->acc_poll_delay = ns_to_ktime(STK831X_SAMPLE_TIME[sr_no]*USEC_PER_MSEC);	
+#endif
+	
+#if defined(STK_LOWPASS)
+	stk->fir.num = 0;
+	stk->fir.idx = 0;
+	stk->fir.sum[0] = 0;
+	stk->fir.sum[1] = 0;
+	stk->fir.sum[2] = 0;
+#endif		
+	mutex_unlock(&stk->write_lock);	
+	
+	return 0;
+d_err_i2c:
+	mutex_unlock(&stk->write_lock);	
+	return result;
+}
+
+
+
+static int STK831X_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetData[])
+{
+	
+
+	char regR[6];
+	char mode; 
+	int result;
+	char buffer[2] = "";
+	
+//Check FT1
+	if(FT==1)
+	{
+		result = STK831X_ReadByteOTP(0x7F, &regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;
+		
+		if(regR[0]&0x10)
+		{
+			printk(KERN_ERR "%s: 0x7F=0x%x\n", __func__, regR[0]);
+			return -STK_K_FAIL_FT1_USD;
+		}
+	}
+	else if (FT == 2)
+	{
+		result = STK831X_ReadByteOTP(0x7F, &regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;
+			
+		if(regR[0]&0x20)
+		{
+			printk(KERN_ERR "%s: 0x7F=0x%x\n", __func__, regR[0]);
+			return -STK_K_FAIL_FT2_USD;
+		}		
+	}
+	
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	mode = buffer[0];
+	buffer[1] = (mode | 0x01);
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	msleep(2);
+	
+	result = STK831X_ReadByteOTP(0x30, &regR[0]);
+	if(result < 0)
+		goto eng_i2c_err;
+	result = STK831X_ReadByteOTP(0x31, &regR[1]);
+	if(result < 0)
+		goto eng_i2c_err;
+	result = STK831X_ReadByteOTP(0x32, &regR[2]);
+	if(result < 0)
+		goto eng_i2c_err;
+	
+	if(FT == 1)
+	{
+		result = STK831X_WriteByteOTP(0x40, regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;
+		result = STK831X_WriteByteOTP(0x41, regR[1]);
+		if(result < 0)
+			goto eng_i2c_err;		
+		result = STK831X_WriteByteOTP(0x42, regR[2]);
+		if(result < 0)
+			goto eng_i2c_err;		
+	}
+	else if (FT == 2)
+	{
+		result = STK831X_WriteByteOTP(0x50, regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;
+		result = STK831X_WriteByteOTP(0x51, regR[1]);
+		if(result < 0)
+			goto eng_i2c_err;		
+		result = STK831X_WriteByteOTP(0x52, regR[2]);
+		if(result < 0)
+			goto eng_i2c_err;		
+	}
+#ifdef STK_DEBUG_CALI
+	printk(KERN_INFO "%s:OTP step1 Success!\n", __func__);
+#endif
+	buffer[0] = 0x2A;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[0] = buffer[0];
+	}
+	buffer[0] = 0x2B;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[1] = buffer[0];
+	}
+	buffer[0] = 0x2E;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[2] = buffer[0];
+	}
+	buffer[0] = 0x2F;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[3] = buffer[0];
+	}
+
+
+
+	buffer[0] = 0x32;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[4] = buffer[0];
+	}
+	buffer[0] = 0x33;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[5] = buffer[0];
+	}
+	
+	regR[1] = offsetData[0];
+	regR[3] = offsetData[2];
+	regR[5] = offsetData[1];
+	if(FT==1)
+	{
+		result = STK831X_WriteByteOTP(0x43, regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;		
+		result = STK831X_WriteByteOTP(0x44, regR[1]);
+		if(result < 0)
+			goto eng_i2c_err;		
+		result = STK831X_WriteByteOTP(0x45, regR[2]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x46, regR[3]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x47, regR[4]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x48, regR[5]);
+		if(result < 0)
+			goto eng_i2c_err;				
+	}
+	else if (FT == 2)
+	{
+		result = STK831X_WriteByteOTP(0x53, regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x54, regR[1]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x55, regR[2]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x56, regR[3]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x57, regR[4]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x58, regR[5]);
+		if(result < 0)
+			goto eng_i2c_err;				
+	}
+#ifdef STK_DEBUG_CALI	
+	printk(KERN_INFO "%s:OTP step2 Success!\n", __func__);
+#endif
+	result = STK831X_ReadByteOTP(0x7F, &regR[0]);
+	if(result < 0)
+		goto eng_i2c_err;
+	
+	if(FT==1)
+		regR[0] = regR[0]|0x10;
+	else if(FT==2)
+		regR[0] = regR[0]|0x20;
+
+	result = STK831X_WriteByteOTP(0x7F, regR[0]);
+	if(result < 0)
+		goto eng_i2c_err;
+#ifdef STK_DEBUG_CALI	
+	printk(KERN_INFO "%s:OTP step3 Success!\n", __func__);
+#endif	
+	return 0;
+	
+eng_i2c_err:
+	printk(KERN_ERR "%s: read/write eng i2c error, result=0x%x\n", __func__, result);	
+	return result;
+	
+common_i2c_error:
+	printk(KERN_ERR "%s: read/write common i2c error, result=0x%x\n", __func__, result);
+	return result;	
+}
+
+static int stk_store_in_ic( struct stk831x_data *stk, char otp_offset[], char FT_index, unsigned char stk831x_placement)
+{
+	int result;
+	char buffer[2] = "";
+
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}			
+	buffer[1] = (buffer[0] & 0xF8) | 0x01;
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}		
+	STK831X_SetVD(stk);
+	
+	buffer[0] = 0x2B;	
+	buffer[1] = otp_offset[0];
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}
+	buffer[0] = 0x2F;	
+	buffer[1] = otp_offset[2];
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}
+	buffer[0] = 0x33;	
+	buffer[1] = otp_offset[1];
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}		
+	
+
+
+#ifdef STK_DEBUG_CALI	
+	//printk(KERN_INFO "%s:Check All OTP Data after write 0x2B 0x2F 0x33\n", __func__);
+	//STK831X_ReadAllOTP();
+#endif	
+	
+	msleep(150);		
+	result = STK831X_VerifyCali(stk, 0);
+	if(result)
+	{
+		printk(KERN_ERR "%s: calibration check1 fail, FT_index=%d\n", __func__, FT_index);				
+		goto ic_err_misc;
+	}
+#ifdef STK_DEBUG_CALI		
+	//printk(KERN_INFO "\n%s:Check All OTP Data before write OTP\n", __func__);
+	//STK831X_ReadAllOTP();
+
+#endif	
+	//Write OTP	
+	printk(KERN_INFO "\n%s:Write offset data to FT%d OTP\n", __func__, FT_index);
+	result = STK831X_WriteOffsetOTP(stk, FT_index, otp_offset);
+	if(result < 0)
+	{
+		printk(KERN_INFO "%s: write OTP%d fail\n", __func__, FT_index);
+		
+		goto ic_err_misc;
+	}
+	
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}			
+	buffer[1] = (buffer[0] & 0xF8);
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}	
+	
+	msleep(1);
+	STK831X_Init(stk, this_client);
+#ifdef STK_DEBUG_CALI		
+	//printk(KERN_INFO "\n%s:Check All OTP Data after write OTP and reset\n", __func__);
+	//STK831X_ReadAllOTP();
+#endif
+		
+	result = STK831X_VerifyCali(stk, 1);
+	if(result)
+	{
+		printk(KERN_ERR "%s: calibration check2 fail\n", __func__);
+		goto ic_err_misc;
+	}
+	return 0;
+
+ic_err_misc:
+	STK831X_Init(stk, this_client);	
+	//STK831X_SetEnable(stk , 1 );
+	msleep(1);
+	//atomic_set(&stk->cali_status, -result);	
+	return result;
+	
+ic_err_i2c_rw:	
+	printk(KERN_ERR "%s: i2c read/write error, err=0x%x\n", __func__, result);
+	msleep(1);
+	STK831X_Init(stk, this_client);	
+	atomic_set(&stk->cali_status, STK_K_FAIL_I2C);	
+	return result;	
+}
+
+
+static int STK831X_SetCali(struct stk831x_data *stk, char sstate)
+{
+	char org_enable;
+	int acc_ave[3] = {0, 0, 0};
+	int state, axis;
+	int new_offset[3];
+	char char_offset[3] = {0};
+	int result;
+	char buffer[2] = "";
+	char reg_offset[3] = {0};
+	char store_location = sstate;
+	uint32_t gdelay_ns;
+	char offset[3];	
+	
+	atomic_set(&stk->cali_status, STK_K_RUNNING);	
+	//sstate=1, STORE_OFFSET_IN_FILE
+	//sstate=2, STORE_OFFSET_IN_IC		
+#ifdef STK_DEBUG_CALI		
+	printk(KERN_INFO "%s:store_location=%d, stk831x_placement=%d\n", __func__, store_location, stk831x_placement);
+#endif	
+	printk(KERN_INFO "%s:store_location=%d, stk831x_placement=%d\n", __func__, store_location, stk831x_placement);
+	if((store_location != 3 && store_location != 2 && store_location != 1) || (stk831x_placement < 0 || stk831x_placement > 5) )
+	{
+		printk(KERN_ERR "%s, invalid parameters\n", __func__);
+		atomic_set(&stk->cali_status, STK_K_FAIL_K_PARA);	
+		return -STK_K_FAIL_K_PARA;
+	}	
+	STK831X_GetDelay(stk, &gdelay_ns);
+	STK831X_GetEnable(stk, &org_enable);
+	if(org_enable)
+		STK831X_SetEnable(stk, 0);
+	STK831X_SetDelay(stk, 10000000);
+	STK831X_SetOffset(reg_offset);
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto err_i2c_rw;
+	}			
+	buffer[1] = (buffer[0] & 0xF8) | 0x01;
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto err_i2c_rw;
+	}
+
+	STK831X_SetVD(stk);
+	if(store_location >= 2)
+	{
+		buffer[0] = 0x2B;	
+		buffer[1] = 0x0;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			goto err_i2c_rw;
+		}
+		buffer[0] = 0x2F;	
+		buffer[1] = 0x0;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			goto err_i2c_rw;
+		}
+		buffer[0] = 0x33;	
+		buffer[1] = 0x0;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			goto err_i2c_rw;
+		}
+	}	
+
+	msleep(150);				
+	for(state=0;state<STK_SAMPLE_NO;state++)
+	{
+		STK831X_ReadSensorData(stk);
+		for(axis=0;axis<3;axis++)			
+			acc_ave[axis] += stk->raw_data[axis];	
+#ifdef STK_DEBUG_CALI				
+		printk(KERN_INFO "%s: acc=%d,%d,%d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif		
+		msleep(10);		
+	}		
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto err_i2c_rw;
+	}			
+	buffer[1] = (buffer[0] & 0xF8);
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto err_i2c_rw;
+	}	
+	
+	for(axis=0;axis<3;axis++)
+		acc_ave[axis] /= STK_SAMPLE_NO;
+	
+	if(acc_ave[2]<=0)
+		stk831x_placement = NEGATIVE_Z_UP;
+	else
+		stk831x_placement = POSITIVE_Z_UP;
+
+	
+	switch(stk831x_placement)
+	{
+	case POSITIVE_X_UP:
+		acc_ave[0] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_X_UP:
+		acc_ave[0] += STK_LSB_1G;		
+		break;
+	case POSITIVE_Y_UP:
+		acc_ave[1] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_Y_UP:
+		acc_ave[1] += STK_LSB_1G;
+		break;
+	case POSITIVE_Z_UP:
+		acc_ave[2] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_Z_UP:
+		acc_ave[2] += STK_LSB_1G;
+		break;
+	default:
+		printk("%s: invalid stk831x_placement=%d\n", __func__, stk831x_placement);
+		atomic_set(&stk->cali_status, STK_K_FAIL_PLACEMENT);	
+		return -STK_K_FAIL_K_PARA;
+		break;
+	}		
+	
+	for(axis=0;axis<3;axis++)
+	{
+		acc_ave[axis] = -acc_ave[axis];
+		new_offset[axis] = acc_ave[axis];
+		char_offset[axis] = new_offset[axis];
+	}				
+#ifdef STK_DEBUG_CALI	
+	printk(KERN_INFO "%s: New offset:%d,%d,%d\n", __func__, new_offset[0], new_offset[1], new_offset[2]);	
+#endif	
+	if(store_location == 1)
+	{
+		STK831X_SetOffset(char_offset);
+		msleep(1);
+		STK831X_GetOffset(reg_offset);
+		for(axis=0;axis<3;axis++)
+		{
+			if(char_offset[axis] != reg_offset[axis])		
+			{
+				printk(KERN_ERR "%s: set offset to register fail!, char_offset[%d]=%d,reg_offset[%d]=%d\n",
+					__func__, axis,char_offset[axis], axis, reg_offset[axis]);
+				atomic_set(&stk->cali_status, STK_K_FAIL_WRITE_NOFST);				
+				return -STK_K_FAIL_WRITE_NOFST;
+			}
+		}
+	
+		result = STK831X_VerifyCali(stk, 1);
+		if(result)
+		{
+			printk(KERN_ERR "%s: calibration check fail, result=0x%x\n", __func__, result);
+			atomic_set(&stk->cali_status, -result);
+		}
+		else
+		{
+			result = stk_store_in_file(char_offset, STK_K_SUCCESS_FILE);
+			if(result)
+			{
+				printk(KERN_INFO "%s:write calibration failed\n", __func__);
+				atomic_set(&stk->cali_status, -result);				
+			}
+			else
+			{
+				printk(KERN_INFO "%s  Line %d successfully\n", __func__, __LINE__);
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_FILE);
+			}		
+			
+		}
+	}
+	else if(store_location >= 2)
+	{
+		for(axis=0; axis<3; axis++)
+		{
+#ifdef CONFIG_SENSORS_STK8313
+			new_offset[axis]>>=2;
+#endif				
+			char_offset[axis] = (char)new_offset[axis];
+			if( (char_offset[axis]>>7)==0)
+			{
+				if(char_offset[axis] >= 0x20 )
+				{
+					printk(KERN_ERR "%s: offset[%d]=0x%x is too large, limit to 0x1f\n", __func__, axis, char_offset[axis] );
+					char_offset[axis] = 0x1F;
+					//atomic_set(&stk->cali_status, STK_K_FAIL_OTP_OUT_RG);						
+					//return -STK_K_FAIL_OTP_OUT_RG;
+				}
+			}	
+			else
+			{
+				if(char_offset[axis] <= 0xDF)
+				{
+					printk(KERN_ERR "%s: offset[%d]=0x%x is too large, limit to 0x20\n", __func__, axis, char_offset[axis]);				
+					char_offset[axis] = 0x20;
+					//atomic_set(&stk->cali_status, STK_K_FAIL_OTP_OUT_RG);			
+					//return -STK_K_FAIL_OTP_OUT_RG;					
+				}
+				else
+					char_offset[axis] = char_offset[axis] & 0x3f;
+			}			
+		}
+
+		printk(KERN_INFO "%s: OTP offset:0x%x,0x%x,0x%x\n", __func__, char_offset[0], char_offset[1], char_offset[2]);
+		if(store_location == 2)
+		{
+			result = stk_store_in_ic( stk, char_offset, 1, stk831x_placement);
+			if(result == 0)
+			{
+				printk(KERN_INFO "%s successfully\n", __func__);
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_FT1);
+			}
+			else
+			{
+				printk(KERN_ERR "%s fail, result=%d\n", __func__, result);
+			}
+		}
+		else if(store_location == 3)
+		{
+			result = stk_store_in_ic( stk, char_offset, 2, stk831x_placement);
+			if(result == 0)
+			{
+				printk(KERN_INFO "%s successfully\n", __func__);
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_FT2);
+			}
+			else
+			{
+				printk(KERN_ERR "%s fail, result=%d\n", __func__, result);
+			}
+		}
+		offset[0] = offset[1] = offset[2] = 0;
+		stk_store_in_file(offset, store_location);			
+	}
+#ifdef STK_TUNE	
+	stk_tune_done = 1;
+#endif	
+	stk->first_enable = false;		
+	STK831X_SetDelay(stk, gdelay_ns);
+	
+	if(org_enable)
+		STK831X_SetEnable(stk, 1);		
+	return 0;
+	
+err_i2c_rw:
+	stk->first_enable = false;		
+	if(org_enable)
+		STK831X_SetEnable(stk, 1);				
+	printk(KERN_ERR "%s: i2c read/write error, err=0x%x\n", __func__, result);
+	atomic_set(&stk->cali_status, STK_K_FAIL_I2C);	
+	return result;
+}
+
+
+static ssize_t stk831x_cali_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	int status = atomic_read(&stk->cali_status);
+	
+	if(status != STK_K_RUNNING)
+		STK831X_GetCali(stk);
+	return scnprintf(buf, PAGE_SIZE,  "%02x\n", status);
+}
+
+static ssize_t stk831x_cali_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+
+    printk("-----%s,%d-------\n", __func__, __LINE__);
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+
+//	if (data == 0)
+//		data = 1;
+//	else
+//		data = 2;
+	STK831X_SetCali(stk, data);
+
+//	STK831X_SetEnable(stk , 1 );
+	return count;
+}
+
+static ssize_t stk831x_send_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	
+
+	int error, i;
+	char *token[2];	
+	int w_reg[2];
+	char buffer[2] = "";
+	
+	for (i = 0; i < 2; i++)
+		token[i] = strsep((char **)&buf, " ");
+	if((error = strict_strtoul(token[0], 16, (unsigned long *)&(w_reg[0]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	if((error = strict_strtoul(token[1], 16, (unsigned long *)&(w_reg[1]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, w_reg[0], w_reg[1]);	
+	buffer[0] = w_reg[0];
+	buffer[1] = w_reg[1];
+	error = STK_i2c_Tx(buffer, 2);
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	return count;
+}
+
+static ssize_t stk831x_recv_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	
+
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	return scnprintf(buf, PAGE_SIZE,  "%02x\n", stk->recv_reg);	
+}
+
+static ssize_t stk831x_recv_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	
+
+	char buffer[2] = "";
+	unsigned long data;
+	int error;
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+
+	error = strict_strtoul(buf, 16, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+	
+	buffer[0] = data;
+	error = STK_i2c_Rx(buffer, 2);	
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	stk->recv_reg = buffer[0];
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, (int)data , (int)buffer[0]);		
+	return count;
+}
+
+static ssize_t stk831x_allreg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	
+
+	int error;	
+	char buffer[16] = "";
+	int aa,bb;
+	
+	for(bb=0;bb<4;bb++)
+	{
+		buffer[0] = bb * 0x10;
+		error = STK_i2c_Rx(buffer, 16);	
+		if (error < 0) 
+		{
+			printk(KERN_ERR "%s:failed\n", __func__);
+			return error;
+		}
+		for(aa=0;aa<16;aa++)
+			printk(KERN_INFO "stk reg[0x%x]=0x%x\n", (bb*0x10+aa) , buffer[aa]);	
+	}	
+	return 0;
+}
+
+static ssize_t stk831x_sendo_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	
+
+	int error, i;
+	char *token[2];	
+	int w_reg[2];
+	char buffer[2] = "";
+	
+	for (i = 0; i < 2; i++)
+		token[i] = strsep((char **)&buf, " ");
+	if((error = strict_strtoul(token[0], 16, (unsigned long *)&(w_reg[0]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	if((error = strict_strtoul(token[1], 16, (unsigned long *)&(w_reg[1]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, w_reg[0], w_reg[1]);	
+
+	buffer[0] = w_reg[0];
+	buffer[1] = w_reg[1];
+	error = STK831X_WriteByteOTP(buffer[0], buffer[1]);
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	return count;
+}
+
+
+static ssize_t stk831x_recvo_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	
+
+	char buffer[2] = "";
+	unsigned long data;
+	int error;
+	
+	error = strict_strtoul(buf, 16, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+	
+	buffer[0] = data;
+	error = STK831X_ReadByteOTP(buffer[0], &buffer[1]);	
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, buffer[0] , buffer[1]);		
+	return count;
+}
+
+static ssize_t stk831x_firlen_show(struct device *dev,
+																		struct device_attribute *attr, char *buf)
+{
+	
+
+#ifdef STK_LOWPASS
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+	int len = atomic_read(&stk->firlength);
+	
+	if(atomic_read(&stk->firlength))
+	{
+		printk(KERN_INFO "len = %2d, idx = %2d\n", stk->fir.num, stk->fir.idx);			
+		printk(KERN_INFO "sum = [%5d %5d %5d]\n", stk->fir.sum[0], stk->fir.sum[1], stk->fir.sum[2]);
+		printk(KERN_INFO "avg = [%5d %5d %5d]\n", stk->fir.sum[0]/len, stk->fir.sum[1]/len, stk->fir.sum[2]/len);
+	}
+	return snprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&stk->firlength));
+#else
+	return snprintf(buf, PAGE_SIZE, "not support\n");
+#endif	
+}
+
+static ssize_t stk831x_firlen_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	
+
+#ifdef STK_LOWPASS
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+	int error;
+	unsigned long data;
+	
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=%d\n", __func__, error);
+		return error;
+	}			
+	
+	if(data > MAX_FIR_LEN)
+	{
+		printk(KERN_ERR "%s: firlen exceed maximum filter length\n", __func__);
+	}
+	else if (data < 1)
+	{
+		atomic_set(&stk->firlength, 1);
+		atomic_set(&stk->fir_en, 0);	
+		memset(&stk->fir, 0x00, sizeof(stk->fir));
+	}
+	else
+	{ 
+		atomic_set(&stk->firlength, data);
+		memset(&stk->fir, 0x00, sizeof(stk->fir));
+		atomic_set(&stk->fir_en, 1);	
+	}
+#else
+	printk(KERN_ERR "%s: firlen is not supported\n", __func__);
+#endif    
+	return count;	
+}
+
+static ssize_t stk831x_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+
+    data = atomic_read(&(stk->position));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t stk831x_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+   struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(stk->position), (int) data);
+
+    return count;
+}
+
+static ssize_t stk831x_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	printk(KERN_ERR"-----%s,%d-----\n", __func__, __LINE__);
+	STK831X_SetCali(stk, 1);
+	
+	return count;
+}
+
+
+static ssize_t stk831x_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	char offset[3];	
+	char enable;
+
+	offset[0] = offset[1] = offset[2] = 0;
+	STK831X_GetEnable(stk , &enable);
+	STK831X_SetEnable(stk , 0);
+	STK831X_SetOffset(offset);
+	stk_store_in_file(offset, STK_K_NO_CALI);
+	atomic_set(&stk->cali_status, STK_K_NO_CALI);
+	STK831X_SetEnable(stk , enable);
+   
+    return count;
+}
+
+
+static DEVICE_ATTR(enable, 0664, stk831x_enable_show, stk831x_enable_store);
+static DEVICE_ATTR(value, 0444, stk831x_value_show, NULL);
+static DEVICE_ATTR(calibration_value, 0664, stk831x_calibration_value_show, stk831x_calibration_value_store);
+static DEVICE_ATTR(delay, 0664, stk831x_delay_show, stk831x_delay_store);
+static DEVICE_ATTR(cali, 0664, stk831x_cali_show, stk831x_cali_store);
+static DEVICE_ATTR(send, 0224, NULL, stk831x_send_store);
+static DEVICE_ATTR(recv, 0664, stk831x_recv_show, stk831x_recv_store);
+static DEVICE_ATTR(allreg, 0444, stk831x_allreg_show, NULL);
+static DEVICE_ATTR(sendo, 0224, NULL, stk831x_sendo_store);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP,
+        stk831x_board_position_show, stk831x_board_position_store);
+
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP,
+        NULL, stk831x_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP,
+        NULL, stk831x_calibration_reset_store);
+
+
+
+static DEVICE_ATTR(recvo, 0224, NULL, stk831x_recvo_store);
+static DEVICE_ATTR(firlen, 0664, stk831x_firlen_show, stk831x_firlen_store);
+
+static struct attribute *stk831x_attributes[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_value.attr,
+	&dev_attr_delay.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_calibration_value.attr,
+	&dev_attr_send.attr,
+	&dev_attr_recv.attr,
+	&dev_attr_allreg.attr,
+	&dev_attr_board_position.attr,
+	&dev_attr_sendo.attr,
+	&dev_attr_recvo.attr,
+	&dev_attr_calibration_reset.attr,
+	&dev_attr_calibration_run.attr,
+	&dev_attr_firlen.attr,
+	NULL
+};
+
+
+
+static struct attribute_group stk831x_attribute_group = {
+	//.name = "driver",
+	.attrs = stk831x_attributes,
+};
+
+
+static int stk831x_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int error;
+	struct stk831x_data *stk;
+	int cfg_position = 0;
+  const char * buf;
+  long int temp; 
+
+	printk(KERN_INFO "stk831x_probe: driver version:%s\n",STK_ACC_DRIVER_VERSION);	
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
+	{
+		printk(KERN_ERR "%s:i2c_check_functionality error\n", __func__);
+		error = -ENODEV;
+		goto exit_i2c_check_functionality_error;
+	}	
+	
+	stk = kzalloc(sizeof(struct stk831x_data),GFP_KERNEL);
+	if (!stk) 
+	{	
+		printk(KERN_ERR "%s:memory allocation error\n", __func__);
+		error = -ENOMEM;
+		goto exit_kzalloc_error;
+	}
+	stk831x_data_ptr = stk;
+	mutex_init(&stk->write_lock);
+
+#if (STK_ACC_POLLING_MODE)	
+
+	stk831x_info("Use Polling_mode\n");
+
+	atomic_set(&stk->delay1, MAX_DELAY);
+	atomic_set(&stk->calibrated , 0);
+	INIT_DELAYED_WORK(&stk->work, stk831x_work_func);
+
+#endif	//#if STK_ACC_POLLING_MODE
+	
+	i2c_set_clientdata(client, stk);	
+	this_client = client;
+
+	
+	
+	error = STK831X_Init(stk, client);
+	if (error) 
+	{		
+		stk831x_info(KERN_ERR "%s:stk831x initialization failed\n", __func__);	
+		return error;
+	}
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+        error = of_property_read_string(client->dev.of_node, "position", &buf);
+        if (error != 0) {
+          printk(KERN_ERR"get position fail\n");
+        }
+        error = strict_strtol(buf, 10, &temp);  
+        cfg_position = (int)temp;
+#else
+        cfg_position = 4;
+#endif
+	
+	atomic_set(&stk->position, cfg_position);
+
+	
+	atomic_set(&stk->cali_status, STK_K_NO_CALI);	
+	stk->first_enable = true;
+	stk->re_enable = false;
+
+	stk->input_dev = input_allocate_device();
+	if (!stk->input_dev) 
+	{
+		error = -ENOMEM;
+		printk(KERN_ERR "%s:input_allocate_device failed\n", __func__);
+		goto exit_input_dev_alloc_error;
+	}
+	
+	stk->input_dev->name = ACC_IDEVICE_NAME;
+	
+	set_bit(EV_ABS, stk->input_dev->evbit);	
+#ifdef CONFIG_SENSORS_STK8312
+	input_set_abs_params(stk->input_dev, ABS_X, -128, 127, 0, 0);
+	input_set_abs_params(stk->input_dev, ABS_Y, -128, 127, 0, 0);
+	input_set_abs_params(stk->input_dev, ABS_Z, -128, 127, 0, 0);	
+#elif defined CONFIG_SENSORS_STK8313
+	input_set_abs_params(stk->input_dev, ABS_X, -512, 511, 0, 0);
+	input_set_abs_params(stk->input_dev, ABS_Y, -512, 511, 0, 0);
+	input_set_abs_params(stk->input_dev, ABS_Z, -512, 511, 0, 0);	
+#endif
+
+	
+	error = input_register_device(stk->input_dev);
+	if (error) 
+	{
+		printk(KERN_ERR "%s:Unable to register input device: %s\n", __func__, stk->input_dev->name);					 
+		goto exit_input_register_device_error;
+	}
+	
+	
+	error = sysfs_create_group(&stk->input_dev->dev.kobj, &stk831x_attribute_group);
+	if (error) 
+	{
+		printk(KERN_ERR "%s: sysfs_create_group failed\n", __func__);
+		goto exit_sysfs_create_group_error;
+	}	
+
+
+	stk831x_load_user_calibration(stk);
+	printk(KERN_INFO "%s successfully\n", __func__);
+	return 0;
+
+exit_sysfs_create_group_error:
+	sysfs_remove_group(&stk->input_dev->dev.kobj, &stk831x_attribute_group);
+exit_input_dev_alloc_error:
+
+exit_input_register_device_error:	
+	input_unregister_device(stk->input_dev);	
+
+	mutex_destroy(&stk->write_lock);
+	kfree(stk);	
+	stk = NULL;	
+exit_kzalloc_error:	
+exit_i2c_check_functionality_error:	
+	return error;
+}
+
+static int stk831x_remove(struct i2c_client *client)
+{
+
+	struct stk831x_data *stk = i2c_get_clientdata(client);
+
+	sysfs_remove_group(&stk->input_dev->dev.kobj, &stk831x_attribute_group);
+	input_unregister_device(stk->input_dev);	
+#if (STK_ACC_POLLING_MODE)
+	//hrtimer_try_to_cancel(&stk->acc_timer);	
+	//destroy_workqueue(stk->stk_acc_wq);
+	cancel_delayed_work_sync(&stk->work);
+#else		
+	free_irq(client->irq, stk);
+#if ADDITIONAL_GPIO_CFG
+	gpio_free( STK_INT_PIN );
+#endif	
+	if (stk_mems_work_queue)
+		destroy_workqueue(stk_mems_work_queue);	
+#endif
+	mutex_destroy(&stk->write_lock);	
+	kfree(stk);
+	stk = NULL;
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int32_t stk_get_file_content(char * r_buf, int8_t buf_size)
+{
+	struct file  *cali_file;
+	mm_segment_t fs;	
+	ssize_t ret;
+	
+    cali_file = filp_open(STK_ACC_CALI_FILE, O_RDONLY,0);
+    if(IS_ERR(cali_file))
+	{
+        printk(KERN_ERR "%s: filp_open error, no offset file!\n", __func__);
+        return -ENOENT;
+	}
+	else
+	{
+		fs = get_fs();
+		set_fs(get_ds());
+		ret = cali_file->f_op->read(cali_file,r_buf, STK_ACC_CALI_FILE_SIZE,&cali_file->f_pos);
+		if(ret < 0)
+		{
+			printk(KERN_ERR "%s: read error, ret=%d\n", __func__, ret);
+			filp_close(cali_file,NULL);
+			return -EIO;
+		}		
+		set_fs(fs);
+    }
+	
+    filp_close(cali_file,NULL);	
+	return 0;	
+}
+
+
+static int STK831X_SetOffset(char buf[])
+{
+	int result;
+	char buffer[4] = "";
+	
+	buffer[0] = STK831X_OFSX;	
+	buffer[1] = buf[0];
+	buffer[2] = buf[1];
+	buffer[3] = buf[2];
+
+	result = STK_i2c_Tx(buffer, 4);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}
+	return 0;
+}
+
+static int STK831X_GetOffset(char buf[])
+{
+
+	
+
+	int result;
+	char buffer[3] = "";
+	
+	buffer[0] = STK831X_OFSX;
+	result = STK_i2c_Rx(buffer, 3);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}		
+	buf[0] = buffer[0];
+	buf[1] = buffer[1];
+	buf[2] = buffer[2];
+	return 0;
+}
+
+static int stk_store_in_file(char offset[], char mode)
+{
+	
+
+	struct file  *cali_file;
+	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
+	char w_buf[STK_ACC_CALI_FILE_SIZE] = {0};	
+	mm_segment_t fs;	
+	ssize_t ret;
+	int8_t i;
+	
+	w_buf[0] = STK_ACC_CALI_VER0;
+	w_buf[1] = STK_ACC_CALI_VER1;
+	w_buf[2] = offset[0];
+	w_buf[3] = offset[1];
+	w_buf[4] = offset[2];
+	w_buf[5] = mode;
+	
+    cali_file = filp_open(STK_ACC_CALI_FILE, O_CREAT | O_RDWR,0666);
+	
+    if(IS_ERR(cali_file))
+	{
+        printk(KERN_ERR "%s: filp_open error!\n", __func__);
+        return -STK_K_FAIL_OPEN_FILE;
+	}
+	else
+	{
+		fs = get_fs();
+		set_fs(get_ds());
+		
+		ret = cali_file->f_op->write(cali_file,w_buf,STK_ACC_CALI_FILE_SIZE,&cali_file->f_pos);
+		if(ret != STK_ACC_CALI_FILE_SIZE)
+		{
+			printk(KERN_ERR "%s: write error!\n", __func__);
+			filp_close(cali_file,NULL);
+			return -STK_K_FAIL_W_FILE;
+		}
+		cali_file->f_pos=0x00;
+		ret = cali_file->f_op->read(cali_file,r_buf, STK_ACC_CALI_FILE_SIZE,&cali_file->f_pos);
+		if(ret < 0)
+		{
+			printk(KERN_ERR "%s: read error!\n", __func__);
+			filp_close(cali_file,NULL);
+			return -STK_K_FAIL_R_BACK;
+		}		
+		set_fs(fs);
+		
+		//printk(KERN_INFO "%s: read ret=%d!\n", __func__, ret);
+		for(i=0;i<STK_ACC_CALI_FILE_SIZE;i++)
+		{
+			if(r_buf[i] != w_buf[i])
+			{
+				printk(KERN_ERR "%s: read back error, r_buf[%x](0x%x) != w_buf[%x](0x%x)\n", 
+					__func__, i, r_buf[i], i, w_buf[i]);				
+				filp_close(cali_file,NULL);
+				return -STK_K_FAIL_R_BACK_COMP;
+			}
+		}
+    }
+    filp_close(cali_file,NULL);	
+
+	return 0;		
+}
+
+
+#ifdef STK_TUNE
+static void STK831X_ResetPara(void)
+{
+
+	
+
+	int ii;
+	for(ii=0;ii<3;ii++)
+	{
+		stk_tune_sum[ii] = 0;
+		stk_tune_min[ii] = 4096;
+		stk_tune_max[ii] = -4096;
+	}
+	return;
+}
+
+static void STK831X_Tune(struct stk831x_data *stk, int acc[])
+{	
+
+	//
+
+	int ii;
+	char offset[3];		
+	char mode_reg;
+	int result;
+	char buffer[2] = "";
+	
+	if (stk_tune_done==0)
+	{	
+		if( event_since_en >= STK_TUNE_DELAY)
+		{	
+			if ((abs(acc[0]) <= STK_TUNE_XYOFFSET) && (abs(acc[1]) <= STK_TUNE_XYOFFSET)
+				&& (abs(abs(acc[2])-STK_LSB_1G) <= STK_TUNE_ZOFFSET))				
+				stk_tune_index++;
+			else
+				stk_tune_index = 0;
+
+			if (stk_tune_index==0)			
+				STK831X_ResetPara();			
+			else
+			{
+				for(ii=0;ii<3;ii++)
+				{
+					stk_tune_sum[ii] += acc[ii];
+					if(acc[ii] > stk_tune_max[ii])
+						stk_tune_max[ii] = acc[ii];
+					if(acc[ii] < stk_tune_min[ii])
+						stk_tune_min[ii] = acc[ii];						
+				}	
+			}			
+
+			if(stk_tune_index == STK_TUNE_NUM)
+			{
+				for(ii=0;ii<3;ii++)
+				{
+					if((stk_tune_max[ii] - stk_tune_min[ii]) > STK_TUNE_NOISE)
+					{
+						stk_tune_index = 0;
+						STK831X_ResetPara();
+						return;
+					}
+				}
+				buffer[0] = STK831X_MODE;
+				result = STK_i2c_Rx(buffer, 1);	
+				if (result < 0) 
+				{
+					printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);
+					return;
+				}
+				mode_reg = buffer[0];
+				buffer[1] = mode_reg & 0xF8;
+				buffer[0] = STK831X_MODE;	
+				result = STK_i2c_Tx(buffer, 2);
+				if (result < 0) 
+				{
+					printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+					return;
+				}				
+				
+				stk_tune_offset[0] = stk_tune_sum[0]/STK_TUNE_NUM;
+				stk_tune_offset[1] = stk_tune_sum[1]/STK_TUNE_NUM;
+				if (acc[2] > 0)
+					stk_tune_offset[2] = stk_tune_sum[2]/STK_TUNE_NUM - STK_LSB_1G;
+				else
+					stk_tune_offset[2] = stk_tune_sum[2]/STK_TUNE_NUM - (-STK_LSB_1G);				
+				
+				offset[0] = (char) (-stk_tune_offset[0]);
+				offset[1] = (char) (-stk_tune_offset[1]);
+				offset[2] = (char) (-stk_tune_offset[2]);
+				//STK831X_SetOffset(offset);   //david
+				stk_tune_offset_record[0] = offset[0];
+				stk_tune_offset_record[1] = offset[1];
+				stk_tune_offset_record[2] = offset[2];
+				
+				buffer[1] = mode_reg | 0x1;
+				buffer[0] = STK831X_MODE;	
+				result = STK_i2c_Tx(buffer, 2);
+				if (result < 0) 
+				{
+					printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+					return;
+				}
+				
+				STK831X_SetVD(stk);			
+				//stk_store_in_file(offset, STK_K_SUCCESS_TUNE);	  //david	
+				stk_tune_done = 1;				
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_TUNE);				
+				event_since_en = 0;				
+				printk(KERN_INFO "%s:TUNE done, %d,%d,%d\n", __func__, offset[0], offset[1],offset[2]);		
+			}	
+		}		
+	}
+	
+	return;
+}
+#endif
+
+
+static void stk_handle_first_en(struct stk831x_data *stk)
+{
+	
+
+	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
+	char offset[3];	
+	char mode;
+	printk(KERN_INFO "%s: In.\n", __func__);
+#ifdef STK_TUNE
+	if(stk_tune_offset_record[0]!=0 || stk_tune_offset_record[1]!=0 || stk_tune_offset_record[2]!=0)
+	{
+		STK831X_SetOffset(stk_tune_offset_record);
+		stk_tune_done = 1;				
+		atomic_set(&stk->cali_status, STK_K_SUCCESS_TUNE);	
+		printk(KERN_INFO "%s: set offset:%d,%d,%d\n", __func__, stk_tune_offset_record[0], stk_tune_offset_record[1],stk_tune_offset_record[2]);	
+	}
+	else if ((stk_get_file_content(r_buf, STK_ACC_CALI_FILE_SIZE)) == 0)
+#else
+	if ((stk_get_file_content(r_buf, STK_ACC_CALI_FILE_SIZE)) == 0)
+#endif
+	{
+		if(r_buf[0] == STK_ACC_CALI_VER0 && r_buf[1] == STK_ACC_CALI_VER1)
+		{
+			offset[0] = r_buf[2];
+			offset[1] = r_buf[3];
+			offset[2] = r_buf[4];
+			mode = r_buf[5];
+			STK831X_SetOffset(offset);
+#ifdef STK_TUNE
+			stk_tune_offset_record[0] = offset[0];
+			stk_tune_offset_record[1] = offset[1];
+			stk_tune_offset_record[2] = offset[2];
+#endif
+			printk(KERN_INFO "%s: set offset:%d,%d,%d, mode=%d\n", __func__, offset[0], offset[1], offset[2], mode);
+			atomic_set(&stk->cali_status, mode);								
+		}
+		else
+		{
+			printk(KERN_ERR "%s: cali version number error! r_buf=0x%x,0x%x,0x%x,0x%x,0x%x\n", 
+				__func__, r_buf[0], r_buf[1], r_buf[2], r_buf[3], r_buf[4]);						
+			//return -EINVAL;
+		}
+	}
+	else
+	{
+		offset[0] = offset[1] = offset[2] = 0;
+		stk_store_in_file(offset, STK_K_NO_CALI);
+		atomic_set(&stk->cali_status, STK_K_NO_CALI);			
+	}
+	printk(KERN_INFO "%s: Out. cali_status = 0x%x\n", __func__, atomic_read(&stk->cali_status));
+	return;
+}
+
+static int32_t stk_get_ic_content(struct stk831x_data *stk)
+{
+	
+
+	int result;
+	char regR;
+		
+	result = STK831X_ReadByteOTP(0x7F, &regR);
+	if(result < 0)
+	{
+		printk(KERN_ERR "%s: read/write eng i2c error, result=0x%x\n", __func__, result);	
+		return result;
+	}
+	
+	if(regR&0x20)
+	{
+		atomic_set(&stk->cali_status, STK_K_SUCCESS_FT2);	
+		printk(KERN_INFO "%s: OTP 2 used\n", __func__);
+		return 2;	
+	}
+	if(regR&0x10)	
+	{
+		atomic_set(&stk->cali_status, STK_K_SUCCESS_FT1);	
+		printk(KERN_INFO "%s: OTP 1 used\n", __func__);		
+		return 1;	
+	}
+	return 0;
+}
+
+
+
+static int STK831X_SetEnable(struct stk831x_data *stk, char en)
+{
+	int result;
+	unsigned long delay;
+	char buffer[2] = "";
+	int new_enabled = (en)?1:0; 
+	int k_status = atomic_read(&stk->cali_status);
+	
+	if(new_enabled == atomic_read(&stk->enabled))
+		return 0;
+	printk(KERN_INFO "%s:%x\n", __func__, en);
+
+	//mutex_lock(&stk->write_lock);		
+	if(stk->first_enable && k_status != STK_K_RUNNING)			
+		stk_handle_first_en(stk);
+	
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto e_err_i2c;
+	}			
+	if(en)
+	{
+		buffer[1] = (buffer[0] & 0xF8) | 0x01;
+		event_since_en = 0;
+#ifdef STK_TUNE		
+		if((k_status&0xF0) != 0 && stk_tune_done == 0)
+		{
+			stk_tune_index = 0;
+			STK831X_ResetPara();
+		}
+#endif		
+	}
+	else
+		buffer[1] = (buffer[0] & 0xF8);
+		
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto e_err_i2c;
+	}
+	
+	if(stk->first_enable && k_status != STK_K_RUNNING)
+	{
+		stk->first_enable = false;	
+		msleep(2);
+		result = stk_get_ic_content(stk);			
+	}	
+	if(en)
+	{
+		STK831X_SetVD(stk);		
+#if STK_ACC_POLLING_MODE
+//		hrtimer_start(&stk->acc_timer, stk->acc_poll_delay, HRTIMER_MODE_REL);	
+		delay = msecs_to_jiffies(atomic_read(&stk->delay1)); 
+
+		schedule_delayed_work(&stk->work, delay);		
+#else
+		enable_irq((unsigned int)stk->irq);	
+#endif	//#if STK_ACC_POLLING_MODE	
+	}			
+	else
+	{
+#if STK_ACC_POLLING_MODE
+		cancel_delayed_work_sync(&stk->work);
+#else
+		disable_irq((unsigned int)stk->irq);	
+#endif	//#if STK_ACC_POLLING_MODE
+	}	
+	//mutex_unlock(&stk->write_lock);	
+	atomic_set(&stk->enabled, new_enabled);
+	return 0;
+	
+e_err_i2c:
+	//mutex_unlock(&stk->write_lock);		
+	return result;
+}
+
+
+static int stk831x_suspend(struct device *dev)
+{
+	
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct stk831x_data *stk = i2c_get_clientdata(client);
+
+	printk(KERN_INFO "---------%s-----\n", __func__);
+
+    STK831X_GetOffset(stk->offset_saved);
+
+	if(atomic_read(&stk->enabled))
+	{
+		STK831X_SetEnable(stk, 0);
+		stk->re_enable = true;
+	}
+	return 0;
+}
+
+
+static int STK831X_Init(struct stk831x_data *stk, struct i2c_client *client)
+{
+
+	
+
+	int result;
+	char buffer[2] = "";
+	
+
+#ifdef CONFIG_SENSORS_STK8312
+	stk831x_info(KERN_INFO "%s: Initialize stk831x\n", __func__);
+#elif defined CONFIG_SENSORS_STK8313
+	stk831x_info(KERN_INFO "%s: Initialize stk8313\n", __func__);
+#endif		
+	
+	buffer[0] = STK831X_RESET;
+	buffer[1] = 0x00;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}		
+	
+	/* int pin is active high, psuh-pull */
+	buffer[0] = STK831X_MODE;
+	buffer[1] = 0xC0;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}			
+	
+	/* 100 Hz ODR */
+	stk->delay = STK831X_INIT_ODR;
+	buffer[0] = STK831X_SR;
+	buffer[1] = stk->delay + STK831X_SAMPLE_TIME_BASE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		stk831x_info(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}	
+
+#if (!STK_ACC_POLLING_MODE)
+	/* enable GINT, int after every measurement */
+	buffer[0] = STK831X_INTSU;
+	buffer[1] = 0x10;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:interrupt init failed\n", __func__);
+		return result;
+	}	
+#endif 
+	/* +- 6g mode */
+	buffer[0] = STK831X_STH;
+#ifdef CONFIG_SENSORS_STK8312	
+	buffer[1] = 0x42;
+#elif defined CONFIG_SENSORS_STK8313
+	buffer[1] = 0x82;
+#endif	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:set range failed\n", __func__);	
+		return result;
+	}	
+	
+	atomic_set(&stk->enabled, 0);				
+	event_since_en = 0;
+
+#ifdef STK_LOWPASS
+	memset(&stk->fir, 0x00, sizeof(stk->fir));  
+	atomic_set(&stk->firlength, STK_FIR_LEN);
+	atomic_set(&stk->fir_en, 1);
+#endif	
+
+
+#ifdef STK_TUNE	
+	stk_tune_offset[0] = 0;
+	stk_tune_offset[1] = 0;
+	stk_tune_offset[2] = 0;	
+	stk_tune_done = 0;
+#endif	
+	return 0;
+}
+
+
+static int stk831x_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct stk831x_data *stk = i2c_get_clientdata(client);
+   
+#ifdef STK_RESUME_RE_INIT
+	int error;
+#endif
+
+	printk(KERN_INFO "---------%s-----\n", __func__);
+#ifdef STK_RESUME_RE_INIT
+	error = STK831X_Init(stk, this_client);
+	if (error) 
+	{		
+		printk(KERN_ERR "%s:stk831x initialization failed\n", __func__);	
+		return error;
+	}	
+	//stk->first_enable = true;
+#endif
+	if(stk->re_enable)	
+	{
+		stk->re_enable = false;
+		STK831X_SetEnable(stk, 1);
+	}
+
+	STK831X_SetOffset(stk->offset_saved);
+	return 0;		
+}
+
+
+#endif /* CONFIG_PM */
+
+static SIMPLE_DEV_PM_OPS(stk831x_pm_ops, stk831x_suspend, stk831x_resume);
+
+int stk831x_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+  struct i2c_adapter *adapter = client->adapter;
+  printk("gsensor detect %s\n",SENSOR_NAME);
+  if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+  {
+	printk(KERN_INFO "gsensor %s not support I2C_FUNC_SMBUS! \n", SENSOR_NAME);
+	return -ENODEV;
+  }
+  strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+  return 0;
+}
+
+static const struct i2c_device_id stk831x_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, stk831x_id);
+
+static struct of_device_id stk831x_of_match[] = {
+	{ .compatible = "stk8312" },
+	{ }
+};
+
+static struct i2c_driver stk831x_driver = {
+	.driver = {
+			   .owner   = THIS_MODULE,
+			   .name    = STK831X_I2C_NAME,
+			   .pm     = &stk831x_pm_ops,
+			   .of_match_table	= of_match_ptr(stk831x_of_match),
+		},
+	.class = I2C_CLASS_HWMON,
+	.detect = stk831x_detect,
+	.probe = stk831x_probe,
+	.remove = stk831x_remove,
+	.id_table	= stk831x_id,
+};
+
+#if 0
+static struct i2c_board_info stk831x_board_info={
+    .type = SENSOR_NAME, 
+    .addr = SENSOR_I2C_ADDR,
+};
+#endif
+
+static int __init stk831x_init(void)
+{
+    return i2c_add_driver(&stk831x_driver);
+}
+
+static void __exit stk831x_exit(void)
+{
+    i2c_del_driver(&stk831x_driver);
+}
+
+module_init(stk831x_init);
+module_exit(stk831x_exit);
+
+MODULE_AUTHOR("Lex Hsieh / Sensortek");
+MODULE_DESCRIPTION("stk831x 3-Axis accelerometer driver");
+MODULE_LICENSE("GPL");	
+MODULE_VERSION(STK_ACC_DRIVER_VERSION);
+
+
diff --git a/drivers/input/misc/gsensor/stk8313/Makefile b/drivers/input/misc/gsensor/stk8313/Makefile
new file mode 100755
index 0000000..44e491e
--- /dev/null
+++ b/drivers/input/misc/gsensor/stk8313/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the mma7660 drivers
+#
+
+obj-$(CONFIG_GSENSOR_STK8313) += gsensor_stk8313.o
+gsensor_stk8313-objs := stk831x.o
diff --git a/drivers/input/misc/gsensor/stk8313/readme.txt b/drivers/input/misc/gsensor/stk8313/readme.txt
new file mode 100755
index 0000000..a67800e
--- /dev/null
+++ b/drivers/input/misc/gsensor/stk8313/readme.txt
@@ -0,0 +1,4 @@
+×¢\D2\E2:\B8Ã´\FA\C2\EBÍ¬Ê±Ö§\B3\D6stk8312\D3\EBstk8313\C1\BD\BF\EEgsensor\A3\AC
+\D0\E8Òª\CC\ED\BC\D3Ò»\B8\F6\BA\EA\C0\B4\C7\F8\B1\F0\CA\C7stk8312\BB\B9\CA\C7stk8313\A3\AC
+\B8Ãºê¶¨\D2\E5\D4\DAstk831x.c\CEÄ¼\FE\D6\D0\C8\E7#define CONFIG_SENSORS_STK8312\BA\CD#defineCONFIG_SENSORS_STK8313\C0\B4\C7\F8\B1\F0\A3\AC
+\BFÍ»\A7\BFÉ¸\F9\BE\DD\D0\E8Òª\B1\E0\D2\EB\C4Ä¿\EEgsensor\C0\B4\B4ò¿ª¶\D4Ó¦\B5Äºê¶¨\D2å¡£
\ No newline at end of file
diff --git a/drivers/input/misc/gsensor/stk8313/stk8313.h b/drivers/input/misc/gsensor/stk8313/stk8313.h
new file mode 100755
index 0000000..0121485
--- /dev/null
+++ b/drivers/input/misc/gsensor/stk8313/stk8313.h
@@ -0,0 +1,52 @@
+/*
+ * Definitions for Sensortek stk8313 accelerometer
+ */
+#ifndef _STK831X_H_
+#define _STK831X_H_
+
+#include <linux/ioctl.h>
+#define STK831X_I2C_NAME		"stk831x"
+#define ACC_IDEVICE_NAME		"stk8313"
+#define STKDIR				0x3D
+#define STK_LSB_1G			256
+/* register for stk8313 registers */
+
+#define	STK831X_XOUT	0x00
+#define	STK831X_YOUT	0x02
+#define	STK831X_ZOUT	0x04
+#define	STK831X_TILT		0x06	/* Tilt Status */
+#define	STK831X_SRST	0x07	/* Sampling Rate Status */
+#define	STK831X_SPCNT	0x08	/* Sleep Count */
+#define	STK831X_INTSU	0x09	/* Interrupt setup*/
+#define	STK831X_MODE	0x0A
+#define	STK831X_SR		0x0B	/* Sample rate */
+#define	STK831X_PDET	0x0C	/* Tap Detection */
+#define	STK831X_DEVID	0x0E	/* Device ID */
+#define	STK831X_OFSX	0x0F	/* X-Axis offset */
+#define	STK831X_OFSY	0x10	/* Y-Axis offset */
+#define	STK831X_OFSZ	0x11	/* Z-Axis offset */
+#define	STK831X_PLAT	0x12	/* Tap Latency */
+#define	STK831X_PWIN	0x13	/* Tap Window */	
+#define	STK831X_FTH		0x14	/* Fre	e-Fall Threshold */
+#define	STK831X_FTM	0x15	/* Free-Fall Time */
+#define	STK831X_STH	0x16	/* Shake Threshold */
+#define	STK831X_ISTMP	0x17	/* Interrupt Setup */
+#define 	STK831X_INTMAP	0x18	/*Interrupt Map*/
+#define	STK831X_RESET	0x20	/*software reset*/
+
+/* IOCTLs*/
+#define STK_IOCTL_WRITE				_IOW(STKDIR, 0x01, char[8])
+#define STK_IOCTL_READ				_IOWR(STKDIR, 0x02, char[8])
+#define STK_IOCTL_SET_ENABLE			_IOW(STKDIR, 0x03, char)
+#define STK_IOCTL_GET_ENABLE			_IOR(STKDIR, 0x04, char)
+#define STK_IOCTL_SET_DELAY			_IOW(STKDIR, 0x05, char)
+#define STK_IOCTL_GET_DELAY			_IOR(STKDIR, 0x06, char)
+#define STK_IOCTL_SET_OFFSET			_IOW(STKDIR, 0x07, char[3])
+#define STK_IOCTL_GET_OFFSET			_IOR(STKDIR, 0x08, char[3])
+#define STK_IOCTL_GET_ACCELERATION	_IOR(STKDIR, 0x09, int[3])
+#define STK_IOCTL_SET_RANGE			_IOW(STKDIR, 0x10, char)
+#define STK_IOCTL_GET_RANGE			_IOR(STKDIR, 0x11, char)
+#define STK_IOCTL_SET_CALI			_IOW(STKDIR, 0x12, char)
+
+
+#endif
diff --git a/drivers/input/misc/gsensor/stk8313/stk831x.c b/drivers/input/misc/gsensor/stk8313/stk831x.c
new file mode 100755
index 0000000..6d8344d
--- /dev/null
+++ b/drivers/input/misc/gsensor/stk8313/stk831x.c
@@ -0,0 +1,2989 @@
+/* file stk8312.c
+   brief This file contains all function implementations for the SK8312 in linux
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/fcntl.h>
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+//#include "../gsensor_common.h"
+
+
+//#define CONFIG_SENSORS_STK8312
+#define CONFIG_SENSORS_STK8313
+
+
+
+
+#ifdef CONFIG_SENSORS_STK8312
+	#include "stk8312.h"
+	#define SENSOR_NAME              "stk8312"
+	#define SENSOR_I2C_ADDR         0x3d
+#elif defined (CONFIG_SENSORS_STK8313)
+	#include "stk8313.h"
+	#define SENSOR_NAME              "stk8313"
+	#define SENSOR_I2C_ADDR         0x22
+#endif
+
+
+//#define ABSMIN                          -32
+//#define ABSMAX                          31
+//#define FUZZ                    1
+
+#define STK_ACC_POLLING_MODE	1
+#if (!STK_ACC_POLLING_MODE)
+	#define ADDITIONAL_GPIO_CFG 1
+	#define STK_INT_PIN	39
+#endif
+
+#define POSITIVE_Z_UP		0
+#define NEGATIVE_Z_UP	1
+#define POSITIVE_X_UP		2
+#define NEGATIVE_X_UP	3
+#define POSITIVE_Y_UP		4
+#define NEGATIVE_Y_UP	5
+static unsigned char stk831x_placement = POSITIVE_Z_UP;
+
+
+#define STK_PERMISSION_THREAD
+#define STK_RESUME_RE_INIT	
+//#define STK_DEBUG_PRINT
+//#define STK_DEBUG_RAWDATA
+//#define STK_LOWPASS
+#define STK_FIR_LEN	4
+
+#define STK831X_INIT_ODR		0		//0:100Hz, 1:50Hz, 2:25Hz
+#define STK831X_SAMPLE_TIME_BASE		2
+#define STK831X_SAMPLE_TIME_NO		4
+const static int STK831X_SAMPLE_TIME[STK831X_SAMPLE_TIME_NO] = {10000, 20000, 40000, 80000};
+static struct stk831x_data *stk831x_data_ptr;
+
+
+#define STK_ACC_DRIVER_VERSION	"1.6.1 2013/05/24"
+
+// cfg data : 1-- used
+#define CFG_GSENSOR_USE_CONFIG  1
+
+// calibration file path
+#define CFG_GSENSOR_CALIBFILE   "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+#define MAX_DELAY              10
+
+#define STK_DEBUG_CALI
+#define STK_SAMPLE_NO				10
+#define STK_ACC_CALI_VER0			0x3D
+#define STK_ACC_CALI_VER1			0x01
+//#define STK_ACC_CALI_FILE 			"/data/misc/stkacccali.conf"
+#define STK_ACC_CALI_FILE 	 "/data/data/com.actions.sensor.calib/files/gsensor_calib.txt"
+
+#define STK_ACC_CALI_FILE_SIZE 		10
+
+#define STK_K_SUCCESS_TUNE			0x04
+#define STK_K_SUCCESS_FT2			0x03
+#define STK_K_SUCCESS_FT1			0x02
+#define STK_K_SUCCESS_FILE			0x01
+#define STK_K_NO_CALI					0xFF
+#define STK_K_RUNNING				0xFE
+#define STK_K_FAIL_LRG_DIFF			0xFD
+#define STK_K_FAIL_OPEN_FILE			0xFC
+#define STK_K_FAIL_W_FILE				0xFB
+#define STK_K_FAIL_R_BACK			0xFA
+#define STK_K_FAIL_R_BACK_COMP		0xF9
+#define STK_K_FAIL_I2C					0xF8
+#define STK_K_FAIL_K_PARA			0xF7
+#define STK_K_FAIL_OTP_OUT_RG		0xF6
+#define STK_K_FAIL_ENG_I2C			0xF5
+#define STK_K_FAIL_FT1_USD			0xF4
+#define STK_K_FAIL_FT2_USD			0xF3
+#define STK_K_FAIL_WRITE_NOFST		0xF2
+#define STK_K_FAIL_OTP_5T			0xF1
+#define STK_K_FAIL_PLACEMENT		0xF0
+
+
+//#define STK_ZG_FILTER
+#ifdef CONFIG_SENSORS_STK8312
+	#define STK_ZG_COUNT	1
+#elif defined (CONFIG_SENSORS_STK8313)
+	#define STK_ZG_COUNT	4
+#endif
+
+#define STK_TUNE
+#ifdef CONFIG_SENSORS_STK8312
+	#define STK_TUNE_XYOFFSET 3
+	#define STK_TUNE_ZOFFSET 6
+	#define STK_TUNE_NOISE 5
+#elif defined (CONFIG_SENSORS_STK8313)
+	#define STK_TUNE_XYOFFSET 35
+	#define STK_TUNE_ZOFFSET 75
+	#define STK_TUNE_NOISE 20	
+#endif
+#define STK_TUNE_NUM 125
+#define STK_TUNE_DELAY 125
+
+#ifdef STK_TUNE
+static char stk_tune_offset_record[3] = {0};
+static int stk_tune_offset[3] = {0};
+static int stk_tune_sum[3] = {0};
+static int stk_tune_max[3] = {0};
+static int stk_tune_min[3] = {0};
+static int stk_tune_index = 0;
+static int stk_tune_done = 0;
+#endif
+
+#define DEBUG_ENABLE      1
+#define stk831x_info(fmt,arg...) \
+	do { if (DEBUG_ENABLE) printk("[STK831x][%s][LINE:%d]"fmt,__func__, __LINE__ , ##arg) ;} \
+		while(0)
+
+#define stk831x_err(fmt , arg...) \
+	printk("[STK831X_ERROR][%s][LINE:%d]"fmt, __func__ , __LINE__ ,##arg)
+
+
+
+#if defined(STK_LOWPASS)
+#define MAX_FIR_LEN 32
+struct data_filter {
+    s16 raw[MAX_FIR_LEN][3];
+    int sum[3];
+    int num;
+    int idx;
+};
+#endif
+
+struct stk831x_data 
+{
+    struct input_dev *input_dev;
+    struct mutex enable_mutex;
+    atomic_t selftest_result;
+	int irq;	
+	int raw_data[3]; 
+
+	atomic_t delay1;
+    unsigned char delay;
+    atomic_t enabled;
+	bool re_enable;
+	bool first_enable;
+    struct input_dev *input;
+    struct delayed_work work;
+    unsigned char mode;
+	atomic_t cali_status;
+	struct mutex write_lock;
+	char recv_reg;
+	
+#if STK_ACC_POLLING_MODE
+	struct hrtimer acc_timer;	
+    struct work_struct stk_acc_work;
+	struct workqueue_struct *stk_acc_wq;	
+	ktime_t acc_poll_delay;		
+#endif	
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend early_suspend;
+#endif
+    atomic_t fuzz;
+    atomic_t position;
+    atomic_t calibrated;
+    unsigned char offset_saved[3];
+#if defined(STK_LOWPASS)
+		atomic_t				firlength;
+		atomic_t				fir_en;
+		struct data_filter		fir;
+#endif 	
+
+};
+
+
+
+static int event_since_en = 0;
+
+static void STK831X_Tune(struct stk831x_data *stk, int acc[]);
+static int STK831X_GetEnable(struct stk831x_data *stk, char* gState);
+static int STK831X_SetOffset(char buf[]);
+static int STK831X_SetEnable(struct stk831x_data *stk, char en);
+static int STK831X_GetCali(struct stk831x_data *stk);
+static int STK831X_SetCali(struct stk831x_data *stk, char sstate);
+static int STK831X_GetOffset(char buf[]);
+static int STK831X_SetDelay(struct stk831x_data *stk, uint32_t sdelay_ns);
+static int STK831X_GetDelay(struct stk831x_data *stk, uint32_t* gdelay_ns);
+//static int STK831X_SetRange(char srange);
+//static int STK831X_GetRange(char* grange);
+static int32_t stk_get_file_content(char * r_buf, int8_t buf_size);
+static int stk_store_in_file(char offset[], char mode);
+static int STK831X_Init(struct stk831x_data *stk, struct i2c_client *client);
+
+static struct i2c_client *this_client;
+
+static int STK_i2c_Rx(char *rxData, int length)
+{
+	uint8_t retry;	
+	struct i2c_msg msgs[] = 
+	{
+		{
+			.addr = this_client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = rxData,
+		},
+		{
+			.addr = this_client->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = rxData,
+		},
+	};
+	
+	for (retry = 0; retry <= 3; retry++) 
+	{
+		if (i2c_transfer(this_client->adapter, msgs, 2) > 0)
+			break;
+		else
+			mdelay(10);
+	}
+	
+	if (retry > 3) 
+	{
+		printk(KERN_ERR "%s: retry over 3\n", __func__);
+		return -EIO;
+	} 
+	else
+		return 0;	
+}
+
+static int STK_i2c_Tx(char *txData, int length)
+{
+
+	int retry;
+	struct i2c_msg msg[] = 
+	{
+		{
+			.addr = this_client->addr,
+			.flags = 0,
+			.len = length,
+			.buf = txData,
+		},
+	};
+	
+	for (retry = 0; retry <= 3; retry++) 
+	{
+		if (i2c_transfer(this_client->adapter, msg, 1) > 0)
+			break;
+		else
+			mdelay(10);
+	}
+	
+	if(*txData >= 0x21 && *txData <= 0x3F)
+	{
+		if(*txData == 0x3F)
+			msleep(1);
+		for (retry = 0; retry <= 3; retry++) 
+		{
+			if (i2c_transfer(this_client->adapter, msg, 1) > 0)
+				break;
+			else
+				mdelay(10);
+		}		
+	}
+	
+	if (retry > 3) 
+	{
+		printk(KERN_ERR "%s: retry over 3\n", __func__);
+		return -EIO;
+	}
+	else
+		return 0;	
+}
+
+static int STK831X_ReadByteOTP(char rReg, char *value)
+{
+	int redo = 0;
+	int result;
+	char buffer[2] = "";
+	*value = 0;
+	
+	buffer[0] = 0x3D;
+	buffer[1] = rReg;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto eng_i2c_r_err;
+	}
+	buffer[0] = 0x3F;
+	buffer[1] = 0x02;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto eng_i2c_r_err;
+	}
+	
+	msleep(1);	
+	do {
+		buffer[0] = 0x3F;
+		result = STK_i2c_Rx(buffer, 1);	
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed\n", __func__);
+			goto eng_i2c_r_err;
+		}
+		if(buffer[0]& 0x80)
+		{
+			break;
+		}		
+		msleep(1);
+		redo++;
+	}while(redo < 5);
+	
+	if(redo == 5)
+	{
+		printk(KERN_ERR "%s:OTP read repeat read 5 times! Failed!\n", __func__);
+		return -STK_K_FAIL_OTP_5T;
+	}	
+	buffer[0] = 0x3E;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto eng_i2c_r_err;
+	}	
+	*value = buffer[0];
+#ifdef STK_DEBUG_CALI		
+	printk(KERN_INFO "%s: read 0x%x=0x%x\n", __func__, rReg, *value);
+#endif	
+	return 0;
+	
+eng_i2c_r_err:	
+	return -STK_K_FAIL_ENG_I2C;	
+}
+
+static int STK831X_WriteByteOTP(char wReg, char value)
+{
+
+	int redo = 0;
+	int result;
+	char buffer[2] = "";
+	char read_back;
+	
+	redo = 0;
+	do {
+		redo++;
+		
+		buffer[0] = 0x3D;
+		buffer[1] = wReg;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);
+			goto eng_i2c_w_err;
+		}
+		buffer[0] = 0x3E;
+		buffer[1] = value;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);
+			goto eng_i2c_w_err;
+		}				
+		buffer[0] = 0x3F;
+		buffer[1] = 0x01;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);			
+			goto eng_i2c_w_err;
+		}				
+		msleep(1);
+		
+		buffer[0] = 0x3F;
+		result = STK_i2c_Rx(buffer, 1);	
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, err=0x%x\n", __func__, result);			
+			goto eng_i2c_w_err;
+		}
+		if(buffer[0]& 0x80)
+		{
+			result = STK831X_ReadByteOTP(wReg, &read_back);
+			if(result < 0)
+			{
+				printk(KERN_ERR "%s: read back error, result=%d\n", __func__, result);
+				goto eng_i2c_w_err;
+			}
+			
+			if(read_back == value)
+			{
+#ifdef STK_DEBUG_CALI					
+				printk(KERN_INFO "%s: write 0x%x=0x%x successfully\n", __func__, wReg, value);
+#endif				
+				break;
+			}
+			else
+				printk(KERN_ERR "%s: read back mismatch, write 0x%x=0x%x, read 0x%x=0x%x, try again\n", __func__, wReg, value, wReg, read_back);
+		}
+		msleep(1);
+	}while(redo < 5);
+	
+	if(redo == 5)
+	{
+		printk(KERN_ERR "%s:OTP write 0x%x repeat read 5 times! Failed!\n", __func__, wReg);
+		return -STK_K_FAIL_OTP_5T;
+	}		
+	return 0;
+
+eng_i2c_w_err:	
+	return -STK_K_FAIL_ENG_I2C;
+}
+
+
+static int STK831X_SetVD(struct stk831x_data *stk)
+{
+
+	int result;
+	char buffer[2] = "";
+	char reg24;
+	
+	msleep(2);
+	result = STK831X_ReadByteOTP(0x70, &reg24);
+	if(result < 0)
+	{
+		printk(KERN_ERR "%s: read back error, result=%d\n", __func__, result);
+		return result;
+	}
+	
+	if(reg24 != 0)
+	{
+		buffer[0] = 0x24;
+		buffer[1] = reg24;
+		//printk(KERN_INFO "%s:write 0x%x to 0x24\n",  __func__, buffer[1]);
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed\n", __func__);
+			return result;
+		}
+	}	
+	else
+	{
+		//printk(KERN_INFO "%s: reg24=0, do nothing\n", __func__);
+		return 0;
+	}
+	
+	buffer[0] = 0x24;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}				
+	if(buffer[0] != reg24)
+	{
+		printk(KERN_ERR "%s: error, reg24=0x%x, read=0x%x\n", __func__, reg24, buffer[0]);
+		return -1;
+	}
+	//printk(KERN_INFO "%s: successfully", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_SENSORS_STK8312
+static int STK831X_ReadSensorData(struct stk831x_data *stk)
+{	
+	int result;
+	char buffer[3] = "";
+	int acc_xyz[3] = {0};
+#ifdef STK_ZG_FILTER	
+	s16 zero_fir = 0;	
+#endif	
+#ifdef STK_LOWPASS
+	int idx, firlength = atomic_read(&stk->firlength);   
+#endif	
+	int k_status = atomic_read(&stk->cali_status);
+	memset(buffer, 0, 3);
+	
+	buffer[0] = STK831X_XOUT;
+	result = STK_i2c_Rx(buffer, 3);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:i2c transfer error\n", __func__);
+		return result;
+	}	
+
+	if (buffer[0] & 0x80)
+		acc_xyz[0] = buffer[0] - 256;
+	else
+		acc_xyz[0] = buffer[0];
+	if (buffer[1] & 0x80)
+		acc_xyz[1] = buffer[1] - 256;
+	else
+		acc_xyz[1] = buffer[1];
+	if (buffer[2] & 0x80)
+		acc_xyz[2] = buffer[2] - 256;
+	else
+		acc_xyz[2] = buffer[2];
+
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:RAW  %4d,%4d,%4d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+
+	if(k_status == STK_K_RUNNING)
+	{
+		stk->raw_data[0] = acc_xyz[0];
+		stk->raw_data[1] = acc_xyz[1];
+		stk->raw_data[2] = acc_xyz[2];	
+		return 0;
+	}		
+	
+	
+#ifdef STK_LOWPASS
+	if(atomic_read(&stk->fir_en))
+	{
+		if(stk->fir.num < firlength)
+		{                
+			stk->fir.raw[stk->fir.num][0] = acc_xyz[0];
+			stk->fir.raw[stk->fir.num][1] = acc_xyz[1];
+			stk->fir.raw[stk->fir.num][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.num++;
+			stk->fir.idx++;
+		}
+		else
+		{
+			idx = stk->fir.idx % firlength;
+			stk->fir.sum[0] -= stk->fir.raw[idx][0];
+			stk->fir.sum[1] -= stk->fir.raw[idx][1];
+			stk->fir.sum[2] -= stk->fir.raw[idx][2];
+			stk->fir.raw[idx][0] = acc_xyz[0];
+			stk->fir.raw[idx][1] = acc_xyz[1];
+			stk->fir.raw[idx][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.idx++;	
+			acc_xyz[0] = stk->fir.sum[0]/firlength;
+			acc_xyz[1] = stk->fir.sum[1]/firlength;
+			acc_xyz[2] = stk->fir.sum[2]/firlength;					
+		}
+	}
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:After FIR  %4d,%4d,%4d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+
+#endif  	/* #ifdef STK_LOWPASS */
+		
+
+		
+#ifdef STK_TUNE
+	if((k_status&0xF0) != 0)
+		STK831X_Tune(stk, acc_xyz);		
+#endif					
+
+#ifdef STK_ZG_FILTER
+	if( abs(acc_xyz[0]) <= STK_ZG_COUNT)	
+		acc_xyz[0] = (acc_xyz[0]*zero_fir);	
+	if( abs(acc_xyz[1]) <= STK_ZG_COUNT)
+		acc_xyz[1] = (acc_xyz[1]*zero_fir);
+	if( abs(acc_xyz[2]) <= STK_ZG_COUNT)
+		acc_xyz[2] = (acc_xyz[2]*zero_fir);
+#endif 	/* #ifdef STK_ZG_FILTER */	
+
+	stk->raw_data[0] = acc_xyz[0];
+	stk->raw_data[1] = acc_xyz[1];
+	stk->raw_data[2] = acc_xyz[2];
+	
+	return 0;	
+}
+
+#elif defined CONFIG_SENSORS_STK8313
+static int STK831X_ReadSensorData(struct stk831x_data *stk)
+{	
+	int result;
+	char buffer[6] = "";
+	int acc_xyz[3] = {0};	
+#ifdef STK_ZG_FILTER	
+	s16 zero_fir = 0;	
+#endif	
+#ifdef STK_LOWPASS
+	int idx, firlength = atomic_read(&stk->firlength);   
+#endif	
+	int k_status = atomic_read(&stk->cali_status);
+	
+	memset(buffer, 0, 6);	
+	buffer[0] = STK831X_XOUT;
+	result = STK_i2c_Rx(buffer, 6);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:i2c transfer error\n", __func__);
+		return result;
+	}			
+		
+	if (buffer[0] & 0x80)
+		acc_xyz[0] = ((int)buffer[0]<<4) + (buffer[1]>>4) - 4096;
+	else
+		acc_xyz[0] = ((int)buffer[0]<<4) + (buffer[1]>>4);
+	if (buffer[2] & 0x80)
+		acc_xyz[1] = ((int)buffer[2]<<4) + (buffer[3]>>4) - 4096;
+	else
+		acc_xyz[1] = ((int)buffer[2]<<4) + (buffer[3]>>4);
+	if (buffer[4] & 0x80)
+		acc_xyz[2] = ((int)buffer[4]<<4) + (buffer[5]>>4) - 4096;
+	else
+		acc_xyz[2] = ((int)buffer[4]<<4) + (buffer[5]>>4);
+
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:RAW  %4d,%4d,%4d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+
+	if(k_status == STK_K_RUNNING)
+	{
+		stk->raw_data[0] = acc_xyz[0];
+		stk->raw_data[1] = acc_xyz[1];
+		stk->raw_data[2] = acc_xyz[2];	
+		return 0;
+	}
+	
+	
+#ifdef STK_LOWPASS
+	if(atomic_read(&stk->fir_en))
+	{
+		if(stk->fir.num < firlength)
+		{                
+			stk->fir.raw[stk->fir.num][0] = acc_xyz[0];
+			stk->fir.raw[stk->fir.num][1] = acc_xyz[1];
+			stk->fir.raw[stk->fir.num][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.num++;
+			stk->fir.idx++;
+		}
+		else
+		{
+			idx = stk->fir.idx % firlength;
+			stk->fir.sum[0] -= stk->fir.raw[idx][0];
+			stk->fir.sum[1] -= stk->fir.raw[idx][1];
+			stk->fir.sum[2] -= stk->fir.raw[idx][2];
+			stk->fir.raw[idx][0] = acc_xyz[0];
+			stk->fir.raw[idx][1] = acc_xyz[1];
+			stk->fir.raw[idx][2] = acc_xyz[2];
+			stk->fir.sum[0] += acc_xyz[0];
+			stk->fir.sum[1] += acc_xyz[1];
+			stk->fir.sum[2] += acc_xyz[2];
+			stk->fir.idx++;	
+			acc_xyz[0] = stk->fir.sum[0]/firlength;
+			acc_xyz[1] = stk->fir.sum[1]/firlength;
+			acc_xyz[2] = stk->fir.sum[2]/firlength;					
+		}
+	}
+#ifdef STK_DEBUG_RAWDATA
+	printk(KERN_INFO "%s:After FIR  %4d,%4d,%4d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+	
+#endif  	/* #ifdef STK_LOWPASS */
+			
+		
+#ifdef STK_TUNE
+	if((k_status&0xF0) != 0)
+		STK831X_Tune(stk, acc_xyz);		
+#endif					
+
+#ifdef STK_ZG_FILTER
+	if( abs(acc_xyz[0]) <= STK_ZG_COUNT)	
+		acc_xyz[0] = (acc_xyz[0]*zero_fir);	
+	if( abs(acc_xyz[1]) <= STK_ZG_COUNT)
+		acc_xyz[1] = (acc_xyz[1]*zero_fir);
+	if( abs(acc_xyz[2]) <= STK_ZG_COUNT)
+		acc_xyz[2] = (acc_xyz[2]*zero_fir);
+#endif 	/* #ifdef STK_ZG_FILTER */	
+
+	stk->raw_data[0] = acc_xyz[0];
+	stk->raw_data[1] = acc_xyz[1];
+	stk->raw_data[2] = acc_xyz[2];
+
+	return 0;	
+}
+#endif
+
+
+static int stk831x_axis_remap(struct stk831x_data *stk)
+{
+
+	s16 swap;
+    int stk_position = atomic_read(&stk->position);
+
+    switch (abs(stk_position)) {
+        case 1:
+            stk->raw_data[0] = -(stk->raw_data[0]);
+           stk->raw_data[1] = -(stk->raw_data[1]);
+            break;
+        case 2:
+            swap = stk->raw_data[0];
+            stk->raw_data[0] = -stk->raw_data[1];
+            stk->raw_data[1] = swap;
+            break;
+        case 3:
+            break;
+        case 4:
+            swap = stk->raw_data[0];
+            stk->raw_data[0] = stk->raw_data[1];
+            stk->raw_data[1] = -swap; 
+            break;
+    }
+    
+    if (stk_position < 0) {
+        stk->raw_data[2] = -(stk->raw_data[2]);
+        stk->raw_data[0] = -(stk->raw_data[0]);
+    }
+    
+    return 0;
+}
+
+
+static int STK831X_ReportValue(struct stk831x_data *stk)
+{
+	if(event_since_en < 1200)
+	{
+		event_since_en++;
+		if(event_since_en < 12)
+			return 0;		
+	}
+		
+#ifdef STK_DEBUG_PRINT	
+	printk(KERN_INFO "report  X:%4d,Y:%4d, Z:%4d\n",stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif	
+	
+	stk831x_axis_remap(stk);
+	
+	input_report_abs(stk->input_dev, ABS_X, stk->raw_data[0]);  
+	input_report_abs(stk->input_dev, ABS_Y, stk->raw_data[1]);
+	input_report_abs(stk->input_dev, ABS_Z, stk->raw_data[2]);
+	input_sync(stk->input_dev);
+	return 0;
+}
+
+static int stk831x_read_file(char *path, char *buf, int size)
+{
+	
+
+    struct file *filp;
+    loff_t len, offset;
+    int ret=0;
+    mm_segment_t fs;
+
+    filp = filp_open(path, O_RDWR, 0777);
+    if (IS_ERR(filp)) {
+        ret = PTR_ERR(filp);
+        goto out;
+    }
+
+    len = vfs_llseek(filp, 0, SEEK_END);
+    if (len > size) {
+        len = size;
+    }
+    
+    offset = vfs_llseek(filp, 0, SEEK_SET);
+
+    fs=get_fs();
+    set_fs(KERNEL_DS);
+
+    ret = vfs_read(filp, (char __user *)buf, (size_t)len, &(filp->f_pos));
+
+    set_fs(fs);
+
+    filp_close(filp, NULL);    
+out:
+    return ret;
+}
+
+
+static int stk831x_load_user_calibration(struct stk831x_data *stk)
+{
+    char buffer[16];
+    int ret = 0;
+    int data[3];
+    unsigned char offset[3];
+   	char enable;
+	
+    int calibrated = atomic_read(&stk->calibrated);
+    
+    // only calibrate once
+    if (calibrated) {
+        goto usr_calib_end;
+    } else {
+        atomic_set(&stk->calibrated, 1);
+    }
+
+    ret = stk831x_read_file(CFG_GSENSOR_CALIBFILE, buffer, sizeof(buffer));
+    if (ret <= 0) {
+        printk(KERN_ERR "gsensor calibration file not exist!\n");
+        goto usr_calib_end;
+    }
+    
+    sscanf(buffer, "%d %d %d", &data[0], &data[1], &data[2]);
+    offset[0] = (unsigned char) data[0];
+    offset[1] = (unsigned char) data[1];
+    offset[2] = (unsigned char) data[2];    
+    
+    printk(KERN_ERR "-------------user cfg_calibration: %d %d %d----------\n", offset[0], offset[1], offset[2]);
+
+	STK831X_GetEnable(stk , &enable);
+
+	stk831x_info("enable = %d \n" , enable);
+	STK831X_SetEnable(stk , 0);
+    if (STK831X_SetOffset(offset) < 0) {
+        printk(KERN_ERR "set offset fail\n");
+        goto usr_calib_end;
+    }
+    stk->first_enable = false;  //david add.
+    printk(KERN_INFO "load user calibration finished\n");
+	STK831X_SetEnable(stk , enable);
+	
+usr_calib_end:
+    return ret;
+}
+
+
+#if STK_ACC_POLLING_MODE
+static void stk831x_work_func(struct work_struct *work)
+{
+	struct stk831x_data *stk = container_of((struct delayed_work *)work, struct stk831x_data, work);
+
+    unsigned long delay = msecs_to_jiffies(atomic_read(&stk->delay1));
+
+	STK831X_ReadSensorData(stk);
+	STK831X_ReportValue(stk);
+    
+    
+    schedule_delayed_work(&stk->work, delay);
+}
+#endif
+
+static ssize_t stk831x_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	return scnprintf(buf, PAGE_SIZE,  "%d\n", atomic_read(&stk->enabled));
+}
+
+static ssize_t stk831x_enable_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+
+	unsigned long data;
+	int error;
+
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+	if ((data == 0)||(data==1)) 
+		STK831X_SetEnable(stk,data);	
+	else
+		printk(KERN_ERR "%s: invalud argument, data=%ld\n", __func__, data);
+	return count;
+}
+
+static ssize_t stk831x_value_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+	int ddata[3];
+
+	printk(KERN_INFO "driver version:%s\n",STK_ACC_DRIVER_VERSION);	
+	STK831X_ReadSensorData(stk);
+	ddata[0]= stk->raw_data[0];
+	ddata[1]= stk->raw_data[1];
+	ddata[2]= stk->raw_data[2];
+	return scnprintf(buf, PAGE_SIZE,  "%d %d %d\n", ddata[0], ddata[1], ddata[2]);
+}
+
+static ssize_t stk831x_calibration_value_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	
+	char buffer[3] = "";
+	struct stk831x_data *stk = NULL;
+	
+	stk = i2c_get_clientdata(this_client);
+	
+	printk(KERN_INFO "driver version:%s\n",STK_ACC_DRIVER_VERSION);	
+
+	buffer[0] = STK831X_OFSX;
+    STK_i2c_Rx(buffer, 3);
+	
+	return sprintf(buf, "%d %d %d\n", buffer[0] , buffer[1], buffer[2]);
+}
+
+static ssize_t stk831x_calibration_value_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)		
+{
+	int result;
+	char buffer[4] = "";
+	struct stk831x_data *stk = NULL;
+
+	stk = i2c_get_clientdata(this_client);
+
+	buffer[0] = STK831X_OFSX;	
+	buffer[1] = buf[0];
+	buffer[2] = buf[1];
+	buffer[3] = buf[2];
+	
+	result = STK_i2c_Tx(buffer, 4);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed\n", __func__);
+			return result;
+		}	
+		return count;
+
+}
+
+
+static int STK831X_GetDelay(struct stk831x_data *stk, uint32_t* gdelay_ns)
+{
+	*gdelay_ns = (uint32_t) STK831X_SAMPLE_TIME[stk->delay] * 1000;
+	return 0;	
+}
+
+static ssize_t stk831x_delay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+
+	
+
+	
+	return sprintf(buf , "%d\n", atomic_read(&stk->delay1));
+}
+
+static ssize_t stk831x_delay_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+
+	if(data < 10)
+		data = 10;
+	else if(data > 20)
+		data = 20;
+	
+	atomic_set(&stk->delay1 , data);
+	STK831X_SetDelay(stk, data*1000000);	// ms to ns
+	
+	return count;
+}
+
+static int STK831X_GetCali(struct stk831x_data *stk)
+{
+
+	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
+	char offset[3], mode;	
+	int cnt, result;
+	char regR[6];
+	
+#ifdef STK_TUNE		
+	printk(KERN_INFO "%s: stk_tune_done=%d, stk_tune_offset=%d,%d,%d\n", __func__, stk_tune_done, stk_tune_offset[0],
+		stk_tune_offset[1], stk_tune_offset[2]);
+#endif		
+	if ((stk_get_file_content(r_buf, STK_ACC_CALI_FILE_SIZE)) == 0)
+	{
+		if(r_buf[0] == STK_ACC_CALI_VER0 && r_buf[1] == STK_ACC_CALI_VER1)
+		{
+			offset[0] = r_buf[2];
+			offset[1] = r_buf[3];
+			offset[2] = r_buf[4];
+			mode = r_buf[5];
+			printk(KERN_INFO "%s:file offset:%#02x,%#02x,%#02x,%#02x\n", __func__, offset[0], offset[1], offset[2], mode);							
+		}
+		else
+		{
+			printk(KERN_ERR "%s: cali version number error! r_buf=0x%x,0x%x,0x%x,0x%x,0x%x\n", 
+			__func__, r_buf[0], r_buf[1], r_buf[2], r_buf[3], r_buf[4]);						
+		}
+	}
+	else
+		printk(KERN_INFO "%s: No file offset\n", __func__);
+	
+	for(cnt=0x43;cnt<0x49;cnt++)
+	{
+		result = STK831X_ReadByteOTP(cnt, &(regR[cnt-0x43]));
+		if(result < 0)
+			printk(KERN_ERR "%s: STK831X_ReadByteOTP failed, ret=%d\n", __func__, result);		
+	}
+	printk(KERN_INFO "%s: OTP offset 1:%#02x,%#02x,%#02x,%#02x,%#02x,%#02x\n", __func__, regR[0], 
+		regR[1], regR[2],regR[3], regR[4], regR[5]);
+		
+	for(cnt=0x53;cnt<0x59;cnt++)
+	{
+		result = STK831X_ReadByteOTP(cnt, &(regR[cnt-0x53]));
+		if(result < 0)
+			printk(KERN_ERR "%s: STK831X_ReadByteOTP failed, ret=%d\n", __func__, result);
+	}
+	printk(KERN_INFO "%s: OTP offset 2:%#02x,%#02x,%#02x,%#02x,%#02x,%#02x\n", __func__, regR[0], 
+		regR[1], regR[2],regR[3], regR[4], regR[5]);
+	
+	return 0;
+}
+
+static int STK831X_GetEnable(struct stk831x_data *stk, char* gState)
+{
+
+
+	*gState = atomic_read(&stk->enabled);
+	return 0;
+}
+
+
+static int STK831X_VerifyCali(struct stk831x_data *stk, unsigned char en_dis)
+{
+
+	unsigned char axis, state;	
+	int acc_ave[3] = {0, 0, 0};
+	const unsigned char verify_sample_no = 3;		
+#ifdef CONFIG_SENSORS_STK8313
+	const unsigned char verify_diff = 20;	
+#elif defined CONFIG_SENSORS_STK8312
+	const unsigned char verify_diff = 2;		
+#endif		
+	int result;
+	char buffer[2] = "";
+	int ret = 0;
+	
+	if(en_dis)
+	{
+		STK831X_SetDelay(stk, 10000000);
+		buffer[0] = STK831X_MODE;
+		result = STK_i2c_Rx(buffer, 1);	
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);
+			return -STK_K_FAIL_I2C;
+		}			
+		buffer[1] = (buffer[0] & 0xF8) | 0x01;
+		buffer[0] = STK831X_MODE;	
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+			return -STK_K_FAIL_I2C;
+		}
+		STK831X_SetVD(stk);			
+		msleep(150);	
+	}
+	
+	for(state=0;state<verify_sample_no;state++)
+	{
+		STK831X_ReadSensorData(stk);
+		for(axis=0;axis<3;axis++)			
+			acc_ave[axis] += stk->raw_data[axis];	
+#ifdef STK_DEBUG_CALI				
+		printk(KERN_INFO "%s: acc=%d,%d,%d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif
+		msleep(10);		
+	}		
+	
+	for(axis=0;axis<3;axis++)
+		acc_ave[axis] /= verify_sample_no;
+	
+	switch(stk831x_placement)
+	{
+	case POSITIVE_X_UP:
+		acc_ave[0] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_X_UP:
+		acc_ave[0] += STK_LSB_1G;		
+		break;
+	case POSITIVE_Y_UP:
+		acc_ave[1] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_Y_UP:
+		acc_ave[1] += STK_LSB_1G;
+		break;
+	case POSITIVE_Z_UP:
+		acc_ave[2] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_Z_UP:
+		acc_ave[2] += STK_LSB_1G;
+		break;
+	default:
+		printk("%s: invalid stk831x_placement=%d\n", __func__, stk831x_placement);
+		ret = -STK_K_FAIL_PLACEMENT;
+		break;
+	}	
+	if(abs(acc_ave[0]) > verify_diff || abs(acc_ave[1]) > verify_diff || abs(acc_ave[2]) > verify_diff)
+	{
+		printk(KERN_INFO "%s:Check data x:%d, y:%d, z:%d\n", __func__,acc_ave[0],acc_ave[1],acc_ave[2]);		
+		printk(KERN_ERR "%s:Check Fail, Calibration Fail\n", __func__);
+		ret = -STK_K_FAIL_LRG_DIFF;
+	}	
+#ifdef STK_DEBUG_CALI
+	else
+		printk(KERN_INFO "%s:Check data pass\n", __func__);
+#endif	
+	if(en_dis)
+	{
+		buffer[0] = STK831X_MODE;
+		result = STK_i2c_Rx(buffer, 1);	
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+			return -STK_K_FAIL_I2C;
+		}			
+		buffer[1] = (buffer[0] & 0xF8);
+		buffer[0] = STK831X_MODE;	
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+			return -STK_K_FAIL_I2C;
+		}		
+	}	
+	
+	return ret;
+}
+
+static int STK831X_SetDelay(struct stk831x_data *stk, uint32_t sdelay_ns)
+{
+
+	unsigned char sr_no;	
+	int result;
+	char buffer[2] = "";
+	uint32_t sdelay_us = sdelay_ns / 1000;
+
+	for(sr_no=(STK831X_SAMPLE_TIME_NO-1);sr_no>0;sr_no--)
+	{
+		if(sdelay_us >= STK831X_SAMPLE_TIME[sr_no])	
+			break;		
+	}	
+
+	
+#ifdef STK_DEBUG_PRINT		
+	printk(KERN_INFO "%s:sdelay_us=%d\n", __func__, sdelay_us);
+#endif	
+
+	mutex_lock(&stk->write_lock);
+	if(stk->delay == sr_no)
+	{
+		mutex_unlock(&stk->write_lock);	
+		return 0;
+	}
+	buffer[0] = STK831X_SR;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto d_err_i2c;
+	}			
+	
+	buffer[1] = (buffer[0] & 0xF8) | ((sr_no & 0x07) + STK831X_SAMPLE_TIME_BASE);
+	buffer[0] = STK831X_SR;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto d_err_i2c;
+	}	
+	stk->delay = sr_no;
+#if STK_ACC_POLLING_MODE	
+//	atomic_set(stk->delay1 , STK831X_SAMPLE_TIME[sr_no]*USEC_PER_MSEC);
+	//stk->acc_poll_delay = ns_to_ktime(STK831X_SAMPLE_TIME[sr_no]*USEC_PER_MSEC);	
+#endif
+	
+#if defined(STK_LOWPASS)
+	stk->fir.num = 0;
+	stk->fir.idx = 0;
+	stk->fir.sum[0] = 0;
+	stk->fir.sum[1] = 0;
+	stk->fir.sum[2] = 0;
+#endif		
+	mutex_unlock(&stk->write_lock);	
+	
+	return 0;
+d_err_i2c:
+	mutex_unlock(&stk->write_lock);	
+	return result;
+}
+
+
+
+static int STK831X_WriteOffsetOTP(struct stk831x_data *stk, int FT, char offsetData[])
+{
+	
+
+	char regR[6];
+	char mode; 
+	int result;
+	char buffer[2] = "";
+	
+//Check FT1
+	if(FT==1)
+	{
+		result = STK831X_ReadByteOTP(0x7F, &regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;
+		
+		if(regR[0]&0x10)
+		{
+			printk(KERN_ERR "%s: 0x7F=0x%x\n", __func__, regR[0]);
+			return -STK_K_FAIL_FT1_USD;
+		}
+	}
+	else if (FT == 2)
+	{
+		result = STK831X_ReadByteOTP(0x7F, &regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;
+			
+		if(regR[0]&0x20)
+		{
+			printk(KERN_ERR "%s: 0x7F=0x%x\n", __func__, regR[0]);
+			return -STK_K_FAIL_FT2_USD;
+		}		
+	}
+	
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	mode = buffer[0];
+	buffer[1] = (mode | 0x01);
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	msleep(2);
+	
+	result = STK831X_ReadByteOTP(0x30, &regR[0]);
+	if(result < 0)
+		goto eng_i2c_err;
+	result = STK831X_ReadByteOTP(0x31, &regR[1]);
+	if(result < 0)
+		goto eng_i2c_err;
+	result = STK831X_ReadByteOTP(0x32, &regR[2]);
+	if(result < 0)
+		goto eng_i2c_err;
+	
+	if(FT == 1)
+	{
+		result = STK831X_WriteByteOTP(0x40, regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;
+		result = STK831X_WriteByteOTP(0x41, regR[1]);
+		if(result < 0)
+			goto eng_i2c_err;		
+		result = STK831X_WriteByteOTP(0x42, regR[2]);
+		if(result < 0)
+			goto eng_i2c_err;		
+	}
+	else if (FT == 2)
+	{
+		result = STK831X_WriteByteOTP(0x50, regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;
+		result = STK831X_WriteByteOTP(0x51, regR[1]);
+		if(result < 0)
+			goto eng_i2c_err;		
+		result = STK831X_WriteByteOTP(0x52, regR[2]);
+		if(result < 0)
+			goto eng_i2c_err;		
+	}
+#ifdef STK_DEBUG_CALI
+	printk(KERN_INFO "%s:OTP step1 Success!\n", __func__);
+#endif
+	buffer[0] = 0x2A;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[0] = buffer[0];
+	}
+	buffer[0] = 0x2B;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[1] = buffer[0];
+	}
+	buffer[0] = 0x2E;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[2] = buffer[0];
+	}
+	buffer[0] = 0x2F;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[3] = buffer[0];
+	}
+
+
+
+	buffer[0] = 0x32;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[4] = buffer[0];
+	}
+	buffer[0] = 0x33;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto common_i2c_error;
+	}
+	else
+	{
+		regR[5] = buffer[0];
+	}
+	
+	regR[1] = offsetData[0];
+	regR[3] = offsetData[2];
+	regR[5] = offsetData[1];
+	if(FT==1)
+	{
+		result = STK831X_WriteByteOTP(0x43, regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;		
+		result = STK831X_WriteByteOTP(0x44, regR[1]);
+		if(result < 0)
+			goto eng_i2c_err;		
+		result = STK831X_WriteByteOTP(0x45, regR[2]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x46, regR[3]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x47, regR[4]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x48, regR[5]);
+		if(result < 0)
+			goto eng_i2c_err;				
+	}
+	else if (FT == 2)
+	{
+		result = STK831X_WriteByteOTP(0x53, regR[0]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x54, regR[1]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x55, regR[2]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x56, regR[3]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x57, regR[4]);
+		if(result < 0)
+			goto eng_i2c_err;				
+		result = STK831X_WriteByteOTP(0x58, regR[5]);
+		if(result < 0)
+			goto eng_i2c_err;				
+	}
+#ifdef STK_DEBUG_CALI	
+	printk(KERN_INFO "%s:OTP step2 Success!\n", __func__);
+#endif
+	result = STK831X_ReadByteOTP(0x7F, &regR[0]);
+	if(result < 0)
+		goto eng_i2c_err;
+	
+	if(FT==1)
+		regR[0] = regR[0]|0x10;
+	else if(FT==2)
+		regR[0] = regR[0]|0x20;
+
+	result = STK831X_WriteByteOTP(0x7F, regR[0]);
+	if(result < 0)
+		goto eng_i2c_err;
+#ifdef STK_DEBUG_CALI	
+	printk(KERN_INFO "%s:OTP step3 Success!\n", __func__);
+#endif	
+	return 0;
+	
+eng_i2c_err:
+	printk(KERN_ERR "%s: read/write eng i2c error, result=0x%x\n", __func__, result);	
+	return result;
+	
+common_i2c_error:
+	printk(KERN_ERR "%s: read/write common i2c error, result=0x%x\n", __func__, result);
+	return result;	
+}
+
+static int stk_store_in_ic( struct stk831x_data *stk, char otp_offset[], char FT_index, unsigned char stk831x_placement)
+{
+	int result;
+	char buffer[2] = "";
+
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}			
+	buffer[1] = (buffer[0] & 0xF8) | 0x01;
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}		
+	STK831X_SetVD(stk);
+	
+	buffer[0] = 0x2B;	
+	buffer[1] = otp_offset[0];
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}
+	buffer[0] = 0x2F;	
+	buffer[1] = otp_offset[2];
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}
+	buffer[0] = 0x33;	
+	buffer[1] = otp_offset[1];
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}		
+	
+
+
+#ifdef STK_DEBUG_CALI	
+	//printk(KERN_INFO "%s:Check All OTP Data after write 0x2B 0x2F 0x33\n", __func__);
+	//STK831X_ReadAllOTP();
+#endif	
+	
+	msleep(150);		
+	result = STK831X_VerifyCali(stk, 0);
+	if(result)
+	{
+		printk(KERN_ERR "%s: calibration check1 fail, FT_index=%d\n", __func__, FT_index);				
+		goto ic_err_misc;
+	}
+#ifdef STK_DEBUG_CALI		
+	//printk(KERN_INFO "\n%s:Check All OTP Data before write OTP\n", __func__);
+	//STK831X_ReadAllOTP();
+
+#endif	
+	//Write OTP	
+	printk(KERN_INFO "\n%s:Write offset data to FT%d OTP\n", __func__, FT_index);
+	result = STK831X_WriteOffsetOTP(stk, FT_index, otp_offset);
+	if(result < 0)
+	{
+		printk(KERN_INFO "%s: write OTP%d fail\n", __func__, FT_index);
+		
+		goto ic_err_misc;
+	}
+	
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}			
+	buffer[1] = (buffer[0] & 0xF8);
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto ic_err_i2c_rw;
+	}	
+	
+	msleep(1);
+	STK831X_Init(stk, this_client);
+#ifdef STK_DEBUG_CALI		
+	//printk(KERN_INFO "\n%s:Check All OTP Data after write OTP and reset\n", __func__);
+	//STK831X_ReadAllOTP();
+#endif
+		
+	result = STK831X_VerifyCali(stk, 1);
+	if(result)
+	{
+		printk(KERN_ERR "%s: calibration check2 fail\n", __func__);
+		goto ic_err_misc;
+	}
+	return 0;
+
+ic_err_misc:
+	STK831X_Init(stk, this_client);	
+	//STK831X_SetEnable(stk , 1 );
+	msleep(1);
+	//atomic_set(&stk->cali_status, -result);	
+	return result;
+	
+ic_err_i2c_rw:	
+	printk(KERN_ERR "%s: i2c read/write error, err=0x%x\n", __func__, result);
+	msleep(1);
+	STK831X_Init(stk, this_client);	
+	atomic_set(&stk->cali_status, STK_K_FAIL_I2C);	
+	return result;	
+}
+
+
+static int STK831X_SetCali(struct stk831x_data *stk, char sstate)
+{
+	char org_enable;
+	int acc_ave[3] = {0, 0, 0};
+	int state, axis;
+	int new_offset[3];
+	char char_offset[3] = {0};
+	int result;
+	char buffer[2] = "";
+	char reg_offset[3] = {0};
+	char store_location = sstate;
+	uint32_t gdelay_ns;
+	char offset[3];	
+	
+	atomic_set(&stk->cali_status, STK_K_RUNNING);	
+	//sstate=1, STORE_OFFSET_IN_FILE
+	//sstate=2, STORE_OFFSET_IN_IC		
+#ifdef STK_DEBUG_CALI		
+	printk(KERN_INFO "%s:store_location=%d, stk831x_placement=%d\n", __func__, store_location, stk831x_placement);
+#endif	
+	printk(KERN_INFO "%s:store_location=%d, stk831x_placement=%d\n", __func__, store_location, stk831x_placement);
+	if((store_location != 3 && store_location != 2 && store_location != 1) || (stk831x_placement < 0 || stk831x_placement > 5) )
+	{
+		printk(KERN_ERR "%s, invalid parameters\n", __func__);
+		atomic_set(&stk->cali_status, STK_K_FAIL_K_PARA);	
+		return -STK_K_FAIL_K_PARA;
+	}	
+	STK831X_GetDelay(stk, &gdelay_ns);
+	STK831X_GetEnable(stk, &org_enable);
+	if(org_enable)
+		STK831X_SetEnable(stk, 0);
+	STK831X_SetDelay(stk, 10000000);
+	STK831X_SetOffset(reg_offset);
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto err_i2c_rw;
+	}			
+	buffer[1] = (buffer[0] & 0xF8) | 0x01;
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto err_i2c_rw;
+	}
+
+	STK831X_SetVD(stk);
+	if(store_location >= 2)
+	{
+		buffer[0] = 0x2B;	
+		buffer[1] = 0x0;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			goto err_i2c_rw;
+		}
+		buffer[0] = 0x2F;	
+		buffer[1] = 0x0;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			goto err_i2c_rw;
+		}
+		buffer[0] = 0x33;	
+		buffer[1] = 0x0;
+		result = STK_i2c_Tx(buffer, 2);
+		if (result < 0) 
+		{
+			goto err_i2c_rw;
+		}
+	}	
+
+	msleep(150);				
+	for(state=0;state<STK_SAMPLE_NO;state++)
+	{
+		STK831X_ReadSensorData(stk);
+		for(axis=0;axis<3;axis++)			
+			acc_ave[axis] += stk->raw_data[axis];	
+#ifdef STK_DEBUG_CALI				
+		printk(KERN_INFO "%s: acc=%d,%d,%d\n", __func__, stk->raw_data[0], stk->raw_data[1], stk->raw_data[2]);	
+#endif		
+		msleep(10);		
+	}		
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		goto err_i2c_rw;
+	}			
+	buffer[1] = (buffer[0] & 0xF8);
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		goto err_i2c_rw;
+	}	
+	
+	for(axis=0;axis<3;axis++)
+		acc_ave[axis] /= STK_SAMPLE_NO;
+	
+	if(acc_ave[2]<=0)
+		stk831x_placement = NEGATIVE_Z_UP;
+	else
+		stk831x_placement = POSITIVE_Z_UP;
+
+	
+	switch(stk831x_placement)
+	{
+	case POSITIVE_X_UP:
+		acc_ave[0] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_X_UP:
+		acc_ave[0] += STK_LSB_1G;		
+		break;
+	case POSITIVE_Y_UP:
+		acc_ave[1] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_Y_UP:
+		acc_ave[1] += STK_LSB_1G;
+		break;
+	case POSITIVE_Z_UP:
+		acc_ave[2] -= STK_LSB_1G;
+		break;
+	case NEGATIVE_Z_UP:
+		acc_ave[2] += STK_LSB_1G;
+		break;
+	default:
+		printk("%s: invalid stk831x_placement=%d\n", __func__, stk831x_placement);
+		atomic_set(&stk->cali_status, STK_K_FAIL_PLACEMENT);	
+		return -STK_K_FAIL_K_PARA;
+		break;
+	}		
+	
+	for(axis=0;axis<3;axis++)
+	{
+		acc_ave[axis] = -acc_ave[axis];
+		new_offset[axis] = acc_ave[axis];
+		char_offset[axis] = new_offset[axis];
+	}				
+#ifdef STK_DEBUG_CALI	
+	printk(KERN_INFO "%s: New offset:%d,%d,%d\n", __func__, new_offset[0], new_offset[1], new_offset[2]);	
+#endif	
+	if(store_location == 1)
+	{
+		STK831X_SetOffset(char_offset);
+		msleep(1);
+		STK831X_GetOffset(reg_offset);
+		for(axis=0;axis<3;axis++)
+		{
+			if(char_offset[axis] != reg_offset[axis])		
+			{
+				printk(KERN_ERR "%s: set offset to register fail!, char_offset[%d]=%d,reg_offset[%d]=%d\n",
+					__func__, axis,char_offset[axis], axis, reg_offset[axis]);
+				atomic_set(&stk->cali_status, STK_K_FAIL_WRITE_NOFST);				
+				return -STK_K_FAIL_WRITE_NOFST;
+			}
+		}
+	
+		result = STK831X_VerifyCali(stk, 1);
+		if(result)
+		{
+			printk(KERN_ERR "%s: calibration check fail, result=0x%x\n", __func__, result);
+			atomic_set(&stk->cali_status, -result);
+		}
+		else
+		{
+			result = stk_store_in_file(char_offset, STK_K_SUCCESS_FILE);
+			if(result)
+			{
+				printk(KERN_INFO "%s:write calibration failed\n", __func__);
+				atomic_set(&stk->cali_status, -result);				
+			}
+			else
+			{
+				printk(KERN_INFO "%s  Line %d successfully\n", __func__, __LINE__);
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_FILE);
+			}		
+			
+		}
+	}
+	else if(store_location >= 2)
+	{
+		for(axis=0; axis<3; axis++)
+		{
+#ifdef CONFIG_SENSORS_STK8313
+			new_offset[axis]>>=2;
+#endif				
+			char_offset[axis] = (char)new_offset[axis];
+			if( (char_offset[axis]>>7)==0)
+			{
+				if(char_offset[axis] >= 0x20 )
+				{
+					printk(KERN_ERR "%s: offset[%d]=0x%x is too large, limit to 0x1f\n", __func__, axis, char_offset[axis] );
+					char_offset[axis] = 0x1F;
+					//atomic_set(&stk->cali_status, STK_K_FAIL_OTP_OUT_RG);						
+					//return -STK_K_FAIL_OTP_OUT_RG;
+				}
+			}	
+			else
+			{
+				if(char_offset[axis] <= 0xDF)
+				{
+					printk(KERN_ERR "%s: offset[%d]=0x%x is too large, limit to 0x20\n", __func__, axis, char_offset[axis]);				
+					char_offset[axis] = 0x20;
+					//atomic_set(&stk->cali_status, STK_K_FAIL_OTP_OUT_RG);			
+					//return -STK_K_FAIL_OTP_OUT_RG;					
+				}
+				else
+					char_offset[axis] = char_offset[axis] & 0x3f;
+			}			
+		}
+
+		printk(KERN_INFO "%s: OTP offset:0x%x,0x%x,0x%x\n", __func__, char_offset[0], char_offset[1], char_offset[2]);
+		if(store_location == 2)
+		{
+			result = stk_store_in_ic( stk, char_offset, 1, stk831x_placement);
+			if(result == 0)
+			{
+				printk(KERN_INFO "%s successfully\n", __func__);
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_FT1);
+			}
+			else
+			{
+				printk(KERN_ERR "%s fail, result=%d\n", __func__, result);
+			}
+		}
+		else if(store_location == 3)
+		{
+			result = stk_store_in_ic( stk, char_offset, 2, stk831x_placement);
+			if(result == 0)
+			{
+				printk(KERN_INFO "%s successfully\n", __func__);
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_FT2);
+			}
+			else
+			{
+				printk(KERN_ERR "%s fail, result=%d\n", __func__, result);
+			}
+		}
+		offset[0] = offset[1] = offset[2] = 0;
+		stk_store_in_file(offset, store_location);			
+	}
+#ifdef STK_TUNE	
+	stk_tune_done = 1;
+#endif	
+	stk->first_enable = false;		
+	STK831X_SetDelay(stk, gdelay_ns);
+	
+	if(org_enable)
+		STK831X_SetEnable(stk, 1);		
+	return 0;
+	
+err_i2c_rw:
+	stk->first_enable = false;		
+	if(org_enable)
+		STK831X_SetEnable(stk, 1);				
+	printk(KERN_ERR "%s: i2c read/write error, err=0x%x\n", __func__, result);
+	atomic_set(&stk->cali_status, STK_K_FAIL_I2C);	
+	return result;
+}
+
+
+static ssize_t stk831x_cali_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	int status = atomic_read(&stk->cali_status);
+	
+	if(status != STK_K_RUNNING)
+		STK831X_GetCali(stk);
+	return scnprintf(buf, PAGE_SIZE,  "%02x\n", status);
+}
+
+static ssize_t stk831x_cali_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+
+    printk("-----%s,%d-------\n", __func__, __LINE__);
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+
+//	if (data == 0)
+//		data = 1;
+//	else
+//		data = 2;
+	STK831X_SetCali(stk, data);
+
+//	STK831X_SetEnable(stk , 1 );
+	return count;
+}
+
+static ssize_t stk831x_send_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	
+
+	int error, i;
+	char *token[2];	
+	int w_reg[2];
+	char buffer[2] = "";
+	
+	for (i = 0; i < 2; i++)
+		token[i] = strsep((char **)&buf, " ");
+	if((error = strict_strtoul(token[0], 16, (unsigned long *)&(w_reg[0]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	if((error = strict_strtoul(token[1], 16, (unsigned long *)&(w_reg[1]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, w_reg[0], w_reg[1]);	
+	buffer[0] = w_reg[0];
+	buffer[1] = w_reg[1];
+	error = STK_i2c_Tx(buffer, 2);
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	return count;
+}
+
+static ssize_t stk831x_recv_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	
+
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	return scnprintf(buf, PAGE_SIZE,  "%02x\n", stk->recv_reg);	
+}
+
+static ssize_t stk831x_recv_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	
+
+	char buffer[2] = "";
+	unsigned long data;
+	int error;
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+
+	error = strict_strtoul(buf, 16, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+	
+	buffer[0] = data;
+	error = STK_i2c_Rx(buffer, 2);	
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	stk->recv_reg = buffer[0];
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, (int)data , (int)buffer[0]);		
+	return count;
+}
+
+static ssize_t stk831x_allreg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	
+
+	int error;	
+	char buffer[16] = "";
+	int aa,bb;
+	
+	for(bb=0;bb<4;bb++)
+	{
+		buffer[0] = bb * 0x10;
+		error = STK_i2c_Rx(buffer, 16);	
+		if (error < 0) 
+		{
+			printk(KERN_ERR "%s:failed\n", __func__);
+			return error;
+		}
+		for(aa=0;aa<16;aa++)
+			printk(KERN_INFO "stk reg[0x%x]=0x%x\n", (bb*0x10+aa) , buffer[aa]);	
+	}	
+	return 0;
+}
+
+static ssize_t stk831x_sendo_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	
+
+	int error, i;
+	char *token[2];	
+	int w_reg[2];
+	char buffer[2] = "";
+	
+	for (i = 0; i < 2; i++)
+		token[i] = strsep((char **)&buf, " ");
+	if((error = strict_strtoul(token[0], 16, (unsigned long *)&(w_reg[0]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	if((error = strict_strtoul(token[1], 16, (unsigned long *)&(w_reg[1]))) < 0)
+	{
+		printk(KERN_ERR "%s:strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;	
+	}
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, w_reg[0], w_reg[1]);	
+
+	buffer[0] = w_reg[0];
+	buffer[1] = w_reg[1];
+	error = STK831X_WriteByteOTP(buffer[0], buffer[1]);
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	return count;
+}
+
+
+static ssize_t stk831x_recvo_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	
+
+	char buffer[2] = "";
+	unsigned long data;
+	int error;
+	
+	error = strict_strtoul(buf, 16, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=0x%x\n", __func__, error);
+		return error;
+	}
+	
+	buffer[0] = data;
+	error = STK831X_ReadByteOTP(buffer[0], &buffer[1]);	
+	if (error < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return error;
+	}		
+	printk(KERN_INFO "%s: reg[0x%x]=0x%x\n", __func__, buffer[0] , buffer[1]);		
+	return count;
+}
+
+static ssize_t stk831x_firlen_show(struct device *dev,
+																		struct device_attribute *attr, char *buf)
+{
+	
+
+#ifdef STK_LOWPASS
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+	int len = atomic_read(&stk->firlength);
+	
+	if(atomic_read(&stk->firlength))
+	{
+		printk(KERN_INFO "len = %2d, idx = %2d\n", stk->fir.num, stk->fir.idx);			
+		printk(KERN_INFO "sum = [%5d %5d %5d]\n", stk->fir.sum[0], stk->fir.sum[1], stk->fir.sum[2]);
+		printk(KERN_INFO "avg = [%5d %5d %5d]\n", stk->fir.sum[0]/len, stk->fir.sum[1]/len, stk->fir.sum[2]/len);
+	}
+	return snprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&stk->firlength));
+#else
+	return snprintf(buf, PAGE_SIZE, "not support\n");
+#endif	
+}
+
+static ssize_t stk831x_firlen_store(struct device *dev,
+	struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	
+
+#ifdef STK_LOWPASS
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+	int error;
+	unsigned long data;
+	
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+	{
+		printk(KERN_ERR "%s: strict_strtoul failed, error=%d\n", __func__, error);
+		return error;
+	}			
+	
+	if(data > MAX_FIR_LEN)
+	{
+		printk(KERN_ERR "%s: firlen exceed maximum filter length\n", __func__);
+	}
+	else if (data < 1)
+	{
+		atomic_set(&stk->firlength, 1);
+		atomic_set(&stk->fir_en, 0);	
+		memset(&stk->fir, 0x00, sizeof(stk->fir));
+	}
+	else
+	{ 
+		atomic_set(&stk->firlength, data);
+		memset(&stk->fir, 0x00, sizeof(stk->fir));
+		atomic_set(&stk->fir_en, 1);	
+	}
+#else
+	printk(KERN_ERR "%s: firlen is not supported\n", __func__);
+#endif    
+	return count;	
+}
+
+static ssize_t stk831x_board_position_show(struct device *dev,
+        struct device_attribute *attr, char *buf)
+{
+    int data;
+    struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+
+    data = atomic_read(&(stk->position));
+
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t stk831x_board_position_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+    unsigned long data;
+    int error;
+   struct stk831x_data *stk = i2c_get_clientdata(this_client);	
+
+    error = strict_strtol(buf, 10, &data);
+    if (error)
+        return error;
+
+    atomic_set(&(stk->position), (int) data);
+
+    return count;
+}
+
+static ssize_t stk831x_calibration_run_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	printk(KERN_ERR"-----%s,%d-----\n", __func__, __LINE__);
+	STK831X_SetCali(stk, 1);
+	
+	return count;
+}
+
+
+static ssize_t stk831x_calibration_reset_store(struct device *dev,
+        struct device_attribute *attr,
+        const char *buf, size_t count)
+{
+	struct stk831x_data *stk = i2c_get_clientdata(this_client);
+	char offset[3];	
+	char enable;
+
+	offset[0] = offset[1] = offset[2] = 0;
+	STK831X_GetEnable(stk , &enable);
+	STK831X_SetEnable(stk , 0);
+	STK831X_SetOffset(offset);
+	stk_store_in_file(offset, STK_K_NO_CALI);
+	atomic_set(&stk->cali_status, STK_K_NO_CALI);
+	STK831X_SetEnable(stk , enable);
+   
+    return count;
+}
+
+
+static DEVICE_ATTR(enable, 0664, stk831x_enable_show, stk831x_enable_store);
+static DEVICE_ATTR(value, 0444, stk831x_value_show, NULL);
+static DEVICE_ATTR(calibration_value, 0664, stk831x_calibration_value_show, stk831x_calibration_value_store);
+static DEVICE_ATTR(delay, 0664, stk831x_delay_show, stk831x_delay_store);
+static DEVICE_ATTR(cali, 0664, stk831x_cali_show, stk831x_cali_store);
+static DEVICE_ATTR(send, 0224, NULL, stk831x_send_store);
+static DEVICE_ATTR(recv, 0664, stk831x_recv_show, stk831x_recv_store);
+static DEVICE_ATTR(allreg, 0444, stk831x_allreg_show, NULL);
+static DEVICE_ATTR(sendo, 0224, NULL, stk831x_sendo_store);
+static DEVICE_ATTR(board_position, S_IRUGO|S_IWUSR|S_IWGRP,
+        stk831x_board_position_show, stk831x_board_position_store);
+
+static DEVICE_ATTR(calibration_run, S_IWUSR|S_IWGRP,
+        NULL, stk831x_calibration_run_store);
+static DEVICE_ATTR(calibration_reset, S_IWUSR|S_IWGRP,
+        NULL, stk831x_calibration_reset_store);
+
+
+
+static DEVICE_ATTR(recvo, 0224, NULL, stk831x_recvo_store);
+static DEVICE_ATTR(firlen, 0664, stk831x_firlen_show, stk831x_firlen_store);
+
+static struct attribute *stk831x_attributes[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_value.attr,
+	&dev_attr_delay.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_calibration_value.attr,
+	&dev_attr_send.attr,
+	&dev_attr_recv.attr,
+	&dev_attr_allreg.attr,
+	&dev_attr_board_position.attr,
+	&dev_attr_sendo.attr,
+	&dev_attr_recvo.attr,
+	&dev_attr_calibration_reset.attr,
+	&dev_attr_calibration_run.attr,
+	&dev_attr_firlen.attr,
+	NULL
+};
+
+
+
+static struct attribute_group stk831x_attribute_group = {
+	//.name = "driver",
+	.attrs = stk831x_attributes,
+};
+
+
+static int stk831x_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int error;
+	struct stk831x_data *stk;
+	int cfg_position = 0;
+  const char * buf;
+  long int temp; 
+
+	printk(KERN_INFO "stk831x_probe: driver version:%s\n",STK_ACC_DRIVER_VERSION);	
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
+	{
+		printk(KERN_ERR "%s:i2c_check_functionality error\n", __func__);
+		error = -ENODEV;
+		goto exit_i2c_check_functionality_error;
+	}	
+	
+	stk = kzalloc(sizeof(struct stk831x_data),GFP_KERNEL);
+	if (!stk) 
+	{	
+		printk(KERN_ERR "%s:memory allocation error\n", __func__);
+		error = -ENOMEM;
+		goto exit_kzalloc_error;
+	}
+	stk831x_data_ptr = stk;
+	mutex_init(&stk->write_lock);
+
+#if (STK_ACC_POLLING_MODE)	
+
+	stk831x_info("Use Polling_mode\n");
+
+	atomic_set(&stk->delay1, MAX_DELAY);
+	atomic_set(&stk->calibrated , 0);
+	INIT_DELAYED_WORK(&stk->work, stk831x_work_func);
+
+#endif	//#if STK_ACC_POLLING_MODE
+	
+	i2c_set_clientdata(client, stk);	
+	this_client = client;
+
+	
+	
+	error = STK831X_Init(stk, client);
+	if (error) 
+	{		
+		stk831x_info(KERN_ERR "%s:stk831x initialization failed\n", __func__);	
+		return error;
+	}
+
+#if CFG_GSENSOR_USE_CONFIG > 0
+        error = of_property_read_string(client->dev.of_node, "position", &buf);
+        if (error != 0) {
+          printk(KERN_ERR"get position fail\n");
+        }
+        error = strict_strtol(buf, 10, &temp);  
+        cfg_position = (int)temp;
+#else
+        cfg_position = 4;
+#endif
+	
+	atomic_set(&stk->position, cfg_position);
+
+	
+	atomic_set(&stk->cali_status, STK_K_NO_CALI);	
+	stk->first_enable = true;
+	stk->re_enable = false;
+
+	stk->input_dev = input_allocate_device();
+	if (!stk->input_dev) 
+	{
+		error = -ENOMEM;
+		printk(KERN_ERR "%s:input_allocate_device failed\n", __func__);
+		goto exit_input_dev_alloc_error;
+	}
+	
+	stk->input_dev->name = ACC_IDEVICE_NAME;
+	
+	set_bit(EV_ABS, stk->input_dev->evbit);	
+#ifdef CONFIG_SENSORS_STK8312
+	input_set_abs_params(stk->input_dev, ABS_X, -128, 127, 0, 0);
+	input_set_abs_params(stk->input_dev, ABS_Y, -128, 127, 0, 0);
+	input_set_abs_params(stk->input_dev, ABS_Z, -128, 127, 0, 0);	
+#elif defined CONFIG_SENSORS_STK8313
+	input_set_abs_params(stk->input_dev, ABS_X, -512, 511, 0, 0);
+	input_set_abs_params(stk->input_dev, ABS_Y, -512, 511, 0, 0);
+	input_set_abs_params(stk->input_dev, ABS_Z, -512, 511, 0, 0);	
+#endif
+
+	
+	error = input_register_device(stk->input_dev);
+	if (error) 
+	{
+		printk(KERN_ERR "%s:Unable to register input device: %s\n", __func__, stk->input_dev->name);					 
+		goto exit_input_register_device_error;
+	}
+	
+	
+	error = sysfs_create_group(&stk->input_dev->dev.kobj, &stk831x_attribute_group);
+	if (error) 
+	{
+		printk(KERN_ERR "%s: sysfs_create_group failed\n", __func__);
+		goto exit_sysfs_create_group_error;
+	}	
+
+
+	stk831x_load_user_calibration(stk);
+	printk(KERN_INFO "%s successfully\n", __func__);
+	return 0;
+
+exit_sysfs_create_group_error:
+	sysfs_remove_group(&stk->input_dev->dev.kobj, &stk831x_attribute_group);
+exit_input_dev_alloc_error:
+
+exit_input_register_device_error:	
+	input_unregister_device(stk->input_dev);	
+
+	mutex_destroy(&stk->write_lock);
+	kfree(stk);	
+	stk = NULL;	
+exit_kzalloc_error:	
+exit_i2c_check_functionality_error:	
+	return error;
+}
+
+static int stk831x_remove(struct i2c_client *client)
+{
+
+	struct stk831x_data *stk = i2c_get_clientdata(client);
+
+	sysfs_remove_group(&stk->input_dev->dev.kobj, &stk831x_attribute_group);
+	input_unregister_device(stk->input_dev);	
+#if (STK_ACC_POLLING_MODE)
+	//hrtimer_try_to_cancel(&stk->acc_timer);	
+	//destroy_workqueue(stk->stk_acc_wq);
+	cancel_delayed_work_sync(&stk->work);
+#else		
+	free_irq(client->irq, stk);
+#if ADDITIONAL_GPIO_CFG
+	gpio_free( STK_INT_PIN );
+#endif	
+	if (stk_mems_work_queue)
+		destroy_workqueue(stk_mems_work_queue);	
+#endif
+	mutex_destroy(&stk->write_lock);	
+	kfree(stk);
+	stk = NULL;
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int32_t stk_get_file_content(char * r_buf, int8_t buf_size)
+{
+	struct file  *cali_file;
+	mm_segment_t fs;	
+	ssize_t ret;
+	
+    cali_file = filp_open(STK_ACC_CALI_FILE, O_RDONLY,0);
+    if(IS_ERR(cali_file))
+	{
+        printk(KERN_ERR "%s: filp_open error, no offset file!\n", __func__);
+        return -ENOENT;
+	}
+	else
+	{
+		fs = get_fs();
+		set_fs(get_ds());
+		ret = cali_file->f_op->read(cali_file,r_buf, STK_ACC_CALI_FILE_SIZE,&cali_file->f_pos);
+		if(ret < 0)
+		{
+			printk(KERN_ERR "%s: read error, ret=%d\n", __func__, ret);
+			filp_close(cali_file,NULL);
+			return -EIO;
+		}		
+		set_fs(fs);
+    }
+	
+    filp_close(cali_file,NULL);	
+	return 0;	
+}
+
+
+static int STK831X_SetOffset(char buf[])
+{
+	int result;
+	char buffer[4] = "";
+	
+	buffer[0] = STK831X_OFSX;	
+	buffer[1] = buf[0];
+	buffer[2] = buf[1];
+	buffer[3] = buf[2];
+
+	result = STK_i2c_Tx(buffer, 4);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}
+	return 0;
+}
+
+static int STK831X_GetOffset(char buf[])
+{
+
+	
+
+	int result;
+	char buffer[3] = "";
+	
+	buffer[0] = STK831X_OFSX;
+	result = STK_i2c_Rx(buffer, 3);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}		
+	buf[0] = buffer[0];
+	buf[1] = buffer[1];
+	buf[2] = buffer[2];
+	return 0;
+}
+
+static int stk_store_in_file(char offset[], char mode)
+{
+	
+
+	struct file  *cali_file;
+	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
+	char w_buf[STK_ACC_CALI_FILE_SIZE] = {0};	
+	mm_segment_t fs;	
+	ssize_t ret;
+	int8_t i;
+	
+	w_buf[0] = STK_ACC_CALI_VER0;
+	w_buf[1] = STK_ACC_CALI_VER1;
+	w_buf[2] = offset[0];
+	w_buf[3] = offset[1];
+	w_buf[4] = offset[2];
+	w_buf[5] = mode;
+	
+    cali_file = filp_open(STK_ACC_CALI_FILE, O_CREAT | O_RDWR,0666);
+	
+    if(IS_ERR(cali_file))
+	{
+        printk(KERN_ERR "%s: filp_open error!\n", __func__);
+        return -STK_K_FAIL_OPEN_FILE;
+	}
+	else
+	{
+		fs = get_fs();
+		set_fs(get_ds());
+		
+		ret = cali_file->f_op->write(cali_file,w_buf,STK_ACC_CALI_FILE_SIZE,&cali_file->f_pos);
+		if(ret != STK_ACC_CALI_FILE_SIZE)
+		{
+			printk(KERN_ERR "%s: write error!\n", __func__);
+			filp_close(cali_file,NULL);
+			return -STK_K_FAIL_W_FILE;
+		}
+		cali_file->f_pos=0x00;
+		ret = cali_file->f_op->read(cali_file,r_buf, STK_ACC_CALI_FILE_SIZE,&cali_file->f_pos);
+		if(ret < 0)
+		{
+			printk(KERN_ERR "%s: read error!\n", __func__);
+			filp_close(cali_file,NULL);
+			return -STK_K_FAIL_R_BACK;
+		}		
+		set_fs(fs);
+		
+		//printk(KERN_INFO "%s: read ret=%d!\n", __func__, ret);
+		for(i=0;i<STK_ACC_CALI_FILE_SIZE;i++)
+		{
+			if(r_buf[i] != w_buf[i])
+			{
+				printk(KERN_ERR "%s: read back error, r_buf[%x](0x%x) != w_buf[%x](0x%x)\n", 
+					__func__, i, r_buf[i], i, w_buf[i]);				
+				filp_close(cali_file,NULL);
+				return -STK_K_FAIL_R_BACK_COMP;
+			}
+		}
+    }
+    filp_close(cali_file,NULL);	
+
+	return 0;		
+}
+
+
+#ifdef STK_TUNE
+static void STK831X_ResetPara(void)
+{
+
+	
+
+	int ii;
+	for(ii=0;ii<3;ii++)
+	{
+		stk_tune_sum[ii] = 0;
+		stk_tune_min[ii] = 4096;
+		stk_tune_max[ii] = -4096;
+	}
+	return;
+}
+
+static void STK831X_Tune(struct stk831x_data *stk, int acc[])
+{	
+
+	//
+
+	int ii;
+	char offset[3];		
+	char mode_reg;
+	int result;
+	char buffer[2] = "";
+	
+	if (stk_tune_done==0)
+	{	
+		if( event_since_en >= STK_TUNE_DELAY)
+		{	
+			if ((abs(acc[0]) <= STK_TUNE_XYOFFSET) && (abs(acc[1]) <= STK_TUNE_XYOFFSET)
+				&& (abs(abs(acc[2])-STK_LSB_1G) <= STK_TUNE_ZOFFSET))				
+				stk_tune_index++;
+			else
+				stk_tune_index = 0;
+
+			if (stk_tune_index==0)			
+				STK831X_ResetPara();			
+			else
+			{
+				for(ii=0;ii<3;ii++)
+				{
+					stk_tune_sum[ii] += acc[ii];
+					if(acc[ii] > stk_tune_max[ii])
+						stk_tune_max[ii] = acc[ii];
+					if(acc[ii] < stk_tune_min[ii])
+						stk_tune_min[ii] = acc[ii];						
+				}	
+			}			
+
+			if(stk_tune_index == STK_TUNE_NUM)
+			{
+				for(ii=0;ii<3;ii++)
+				{
+					if((stk_tune_max[ii] - stk_tune_min[ii]) > STK_TUNE_NOISE)
+					{
+						stk_tune_index = 0;
+						STK831X_ResetPara();
+						return;
+					}
+				}
+				buffer[0] = STK831X_MODE;
+				result = STK_i2c_Rx(buffer, 1);	
+				if (result < 0) 
+				{
+					printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);
+					return;
+				}
+				mode_reg = buffer[0];
+				buffer[1] = mode_reg & 0xF8;
+				buffer[0] = STK831X_MODE;	
+				result = STK_i2c_Tx(buffer, 2);
+				if (result < 0) 
+				{
+					printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+					return;
+				}				
+				
+				stk_tune_offset[0] = stk_tune_sum[0]/STK_TUNE_NUM;
+				stk_tune_offset[1] = stk_tune_sum[1]/STK_TUNE_NUM;
+				if (acc[2] > 0)
+					stk_tune_offset[2] = stk_tune_sum[2]/STK_TUNE_NUM - STK_LSB_1G;
+				else
+					stk_tune_offset[2] = stk_tune_sum[2]/STK_TUNE_NUM - (-STK_LSB_1G);				
+				
+				offset[0] = (char) (-stk_tune_offset[0]);
+				offset[1] = (char) (-stk_tune_offset[1]);
+				offset[2] = (char) (-stk_tune_offset[2]);
+				//STK831X_SetOffset(offset);   //david
+				stk_tune_offset_record[0] = offset[0];
+				stk_tune_offset_record[1] = offset[1];
+				stk_tune_offset_record[2] = offset[2];
+				
+				buffer[1] = mode_reg | 0x1;
+				buffer[0] = STK831X_MODE;	
+				result = STK_i2c_Tx(buffer, 2);
+				if (result < 0) 
+				{
+					printk(KERN_ERR "%s:failed, result=0x%x\n", __func__, result);			
+					return;
+				}
+				
+				STK831X_SetVD(stk);			
+				//stk_store_in_file(offset, STK_K_SUCCESS_TUNE);	  //david	
+				stk_tune_done = 1;				
+				atomic_set(&stk->cali_status, STK_K_SUCCESS_TUNE);				
+				event_since_en = 0;				
+				printk(KERN_INFO "%s:TUNE done, %d,%d,%d\n", __func__, offset[0], offset[1],offset[2]);		
+			}	
+		}		
+	}
+	
+	return;
+}
+#endif
+
+
+static void stk_handle_first_en(struct stk831x_data *stk)
+{
+	
+
+	char r_buf[STK_ACC_CALI_FILE_SIZE] = {0};
+	char offset[3];	
+	char mode;
+	printk(KERN_INFO "%s: In.\n", __func__);
+#ifdef STK_TUNE
+	if(stk_tune_offset_record[0]!=0 || stk_tune_offset_record[1]!=0 || stk_tune_offset_record[2]!=0)
+	{
+		STK831X_SetOffset(stk_tune_offset_record);
+		stk_tune_done = 1;				
+		atomic_set(&stk->cali_status, STK_K_SUCCESS_TUNE);	
+		printk(KERN_INFO "%s: set offset:%d,%d,%d\n", __func__, stk_tune_offset_record[0], stk_tune_offset_record[1],stk_tune_offset_record[2]);	
+	}
+	else if ((stk_get_file_content(r_buf, STK_ACC_CALI_FILE_SIZE)) == 0)
+#else
+	if ((stk_get_file_content(r_buf, STK_ACC_CALI_FILE_SIZE)) == 0)
+#endif
+	{
+		if(r_buf[0] == STK_ACC_CALI_VER0 && r_buf[1] == STK_ACC_CALI_VER1)
+		{
+			offset[0] = r_buf[2];
+			offset[1] = r_buf[3];
+			offset[2] = r_buf[4];
+			mode = r_buf[5];
+			STK831X_SetOffset(offset);
+#ifdef STK_TUNE
+			stk_tune_offset_record[0] = offset[0];
+			stk_tune_offset_record[1] = offset[1];
+			stk_tune_offset_record[2] = offset[2];
+#endif
+			printk(KERN_INFO "%s: set offset:%d,%d,%d, mode=%d\n", __func__, offset[0], offset[1], offset[2], mode);
+			atomic_set(&stk->cali_status, mode);								
+		}
+		else
+		{
+			printk(KERN_ERR "%s: cali version number error! r_buf=0x%x,0x%x,0x%x,0x%x,0x%x\n", 
+				__func__, r_buf[0], r_buf[1], r_buf[2], r_buf[3], r_buf[4]);						
+			//return -EINVAL;
+		}
+	}
+	else
+	{
+		offset[0] = offset[1] = offset[2] = 0;
+		stk_store_in_file(offset, STK_K_NO_CALI);
+		atomic_set(&stk->cali_status, STK_K_NO_CALI);			
+	}
+	printk(KERN_INFO "%s: Out. cali_status = 0x%x\n", __func__, atomic_read(&stk->cali_status));
+	return;
+}
+
+static int32_t stk_get_ic_content(struct stk831x_data *stk)
+{
+	
+
+	int result;
+	char regR;
+		
+	result = STK831X_ReadByteOTP(0x7F, &regR);
+	if(result < 0)
+	{
+		printk(KERN_ERR "%s: read/write eng i2c error, result=0x%x\n", __func__, result);	
+		return result;
+	}
+	
+	if(regR&0x20)
+	{
+		atomic_set(&stk->cali_status, STK_K_SUCCESS_FT2);	
+		printk(KERN_INFO "%s: OTP 2 used\n", __func__);
+		return 2;	
+	}
+	if(regR&0x10)	
+	{
+		atomic_set(&stk->cali_status, STK_K_SUCCESS_FT1);	
+		printk(KERN_INFO "%s: OTP 1 used\n", __func__);		
+		return 1;	
+	}
+	return 0;
+}
+
+
+
+static int STK831X_SetEnable(struct stk831x_data *stk, char en)
+{
+	int result;
+	unsigned long delay;
+	char buffer[2] = "";
+	int new_enabled = (en)?1:0; 
+	int k_status = atomic_read(&stk->cali_status);
+	
+	if(new_enabled == atomic_read(&stk->enabled))
+		return 0;
+	printk(KERN_INFO "%s:%x\n", __func__, en);
+
+	//mutex_lock(&stk->write_lock);		
+	if(stk->first_enable && k_status != STK_K_RUNNING)			
+		stk_handle_first_en(stk);
+	
+	buffer[0] = STK831X_MODE;
+	result = STK_i2c_Rx(buffer, 1);	
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto e_err_i2c;
+	}			
+	if(en)
+	{
+		buffer[1] = (buffer[0] & 0xF8) | 0x01;
+		event_since_en = 0;
+#ifdef STK_TUNE		
+		if((k_status&0xF0) != 0 && stk_tune_done == 0)
+		{
+			stk_tune_index = 0;
+			STK831X_ResetPara();
+		}
+#endif		
+	}
+	else
+		buffer[1] = (buffer[0] & 0xF8);
+		
+	buffer[0] = STK831X_MODE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		goto e_err_i2c;
+	}
+	
+	if(stk->first_enable && k_status != STK_K_RUNNING)
+	{
+		stk->first_enable = false;	
+		msleep(2);
+		result = stk_get_ic_content(stk);			
+	}	
+	if(en)
+	{
+		STK831X_SetVD(stk);		
+#if STK_ACC_POLLING_MODE
+//		hrtimer_start(&stk->acc_timer, stk->acc_poll_delay, HRTIMER_MODE_REL);	
+		delay = msecs_to_jiffies(atomic_read(&stk->delay1)); 
+
+		schedule_delayed_work(&stk->work, delay);		
+#else
+		enable_irq((unsigned int)stk->irq);	
+#endif	//#if STK_ACC_POLLING_MODE	
+	}			
+	else
+	{
+#if STK_ACC_POLLING_MODE
+		cancel_delayed_work_sync(&stk->work);
+#else
+		disable_irq((unsigned int)stk->irq);	
+#endif	//#if STK_ACC_POLLING_MODE
+	}	
+	//mutex_unlock(&stk->write_lock);	
+	atomic_set(&stk->enabled, new_enabled);
+	return 0;
+	
+e_err_i2c:
+	//mutex_unlock(&stk->write_lock);		
+	return result;
+}
+
+
+static int stk831x_suspend(struct device *dev)
+{
+	
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct stk831x_data *stk = i2c_get_clientdata(client);
+
+	printk(KERN_INFO "---------%s-----\n", __func__);
+
+    STK831X_GetOffset(stk->offset_saved);
+
+	if(atomic_read(&stk->enabled))
+	{
+		STK831X_SetEnable(stk, 0);
+		stk->re_enable = true;
+	}
+	return 0;
+}
+
+
+static int STK831X_Init(struct stk831x_data *stk, struct i2c_client *client)
+{
+
+	
+
+	int result;
+	char buffer[2] = "";
+	
+
+#ifdef CONFIG_SENSORS_STK8312
+	stk831x_info(KERN_INFO "%s: Initialize stk831x\n", __func__);
+#elif defined CONFIG_SENSORS_STK8313
+	stk831x_info(KERN_INFO "%s: Initialize stk8313\n", __func__);
+#endif		
+	
+	buffer[0] = STK831X_RESET;
+	buffer[1] = 0x00;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}		
+	
+	/* int pin is active high, psuh-pull */
+	buffer[0] = STK831X_MODE;
+	buffer[1] = 0xC0;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}			
+	
+	/* 100 Hz ODR */
+	stk->delay = STK831X_INIT_ODR;
+	buffer[0] = STK831X_SR;
+	buffer[1] = stk->delay + STK831X_SAMPLE_TIME_BASE;	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		stk831x_info(KERN_ERR "%s:failed\n", __func__);
+		return result;
+	}	
+
+#if (!STK_ACC_POLLING_MODE)
+	/* enable GINT, int after every measurement */
+	buffer[0] = STK831X_INTSU;
+	buffer[1] = 0x10;
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:interrupt init failed\n", __func__);
+		return result;
+	}	
+#endif 
+	/* +- 6g mode */
+	buffer[0] = STK831X_STH;
+#ifdef CONFIG_SENSORS_STK8312	
+	buffer[1] = 0x42;
+#elif defined CONFIG_SENSORS_STK8313
+	buffer[1] = 0x82;
+#endif	
+	result = STK_i2c_Tx(buffer, 2);
+	if (result < 0) 
+	{
+		printk(KERN_ERR "%s:set range failed\n", __func__);	
+		return result;
+	}	
+	
+	atomic_set(&stk->enabled, 0);				
+	event_since_en = 0;
+
+#ifdef STK_LOWPASS
+	memset(&stk->fir, 0x00, sizeof(stk->fir));  
+	atomic_set(&stk->firlength, STK_FIR_LEN);
+	atomic_set(&stk->fir_en, 1);
+#endif	
+
+
+#ifdef STK_TUNE	
+	stk_tune_offset[0] = 0;
+	stk_tune_offset[1] = 0;
+	stk_tune_offset[2] = 0;	
+	stk_tune_done = 0;
+#endif	
+	return 0;
+}
+
+
+static int stk831x_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct stk831x_data *stk = i2c_get_clientdata(client);
+   
+#ifdef STK_RESUME_RE_INIT
+	int error;
+#endif
+
+	printk(KERN_INFO "---------%s-----\n", __func__);
+#ifdef STK_RESUME_RE_INIT
+	error = STK831X_Init(stk, this_client);
+	if (error) 
+	{		
+		printk(KERN_ERR "%s:stk831x initialization failed\n", __func__);	
+		return error;
+	}	
+	//stk->first_enable = true;
+#endif
+	if(stk->re_enable)	
+	{
+		stk->re_enable = false;
+		STK831X_SetEnable(stk, 1);
+	}
+
+	STK831X_SetOffset(stk->offset_saved);
+	return 0;		
+}
+
+
+#endif /* CONFIG_PM */
+
+static SIMPLE_DEV_PM_OPS(stk831x_pm_ops, stk831x_suspend, stk831x_resume);
+
+int stk831x_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+  struct i2c_adapter *adapter = client->adapter;
+  printk("gsensor detect %s\n",SENSOR_NAME);
+  if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+  {
+	printk(KERN_INFO "gsensor %s not support I2C_FUNC_SMBUS! \n", SENSOR_NAME);
+	return -ENODEV;
+  }
+  strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+  return 0;
+}
+
+static const struct i2c_device_id stk831x_id[] = {
+    { SENSOR_NAME, 0 },
+    { }
+};
+
+MODULE_DEVICE_TABLE(i2c, stk831x_id);
+
+static struct of_device_id stk831x_of_match[] = {
+	{ .compatible = "stk8313" },
+	{ }
+};
+
+static struct i2c_driver stk831x_driver = {
+	.driver = {
+			   .owner   = THIS_MODULE,
+			   .name    = STK831X_I2C_NAME,
+			   .pm     = &stk831x_pm_ops,
+			   .of_match_table	= of_match_ptr(stk831x_of_match),
+		},
+	.class = I2C_CLASS_HWMON,
+	.detect = stk831x_detect,
+	.probe = stk831x_probe,
+	.remove = stk831x_remove,
+	.id_table	= stk831x_id,
+};
+
+#if 0
+static struct i2c_board_info stk831x_board_info={
+    .type = SENSOR_NAME, 
+    .addr = SENSOR_I2C_ADDR,
+};
+#endif
+
+static int __init stk831x_init(void)
+{
+    return i2c_add_driver(&stk831x_driver);
+}
+
+static void __exit stk831x_exit(void)
+{
+    i2c_del_driver(&stk831x_driver);
+}
+
+module_init(stk831x_init);
+module_exit(stk831x_exit);
+
+MODULE_AUTHOR("Lex Hsieh / Sensortek");
+MODULE_DESCRIPTION("stk831x 3-Axis accelerometer driver");
+MODULE_LICENSE("GPL");	
+MODULE_VERSION(STK_ACC_DRIVER_VERSION);
+
+
-- 
1.7.5.4

