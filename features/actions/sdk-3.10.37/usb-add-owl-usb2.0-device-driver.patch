From ed785db7c3bcb304fb1bd57e0ca0975a2194233d Mon Sep 17 00:00:00 2001
From: dengtaiping <dengtaiping@actions-semi.com>
Date: Mon, 14 Dec 2015 09:15:22 +0800
Subject: [PATCH 36/62] usb: add owl usb2.0 device driver

commit 5d06e9631f877611fe07931889cb0c60442c5aab from
https://github.com/xapp-le/kernel.git

Change-Id: I202119b8f58b3e231cdd5fd5268cdcafe5c71438
---
 arch/arm/boot/dts/actduino_bubble_gum.dts |    1 +
 drivers/usb/Kconfig                       |    2 +
 drivers/usb/Makefile                      |    2 +
 drivers/usb/aotg/Kconfig                  |   13 +
 drivers/usb/aotg/Makefile                 |    6 +
 drivers/usb/aotg/aotg.h                   |   55 +
 drivers/usb/aotg/aotg_core.c              |  878 ++++++++
 drivers/usb/aotg/aotg_hcd.c               | 3464 +++++++++++++++++++++++++++++
 drivers/usb/aotg/aotg_hcd.h               |  462 ++++
 drivers/usb/aotg/aotg_hcd_debug.c         |  980 ++++++++
 drivers/usb/aotg/aotg_hcd_debug.h         |   87 +
 drivers/usb/aotg/aotg_mon.c               |  381 ++++
 drivers/usb/aotg/aotg_mon.h               |   14 +
 drivers/usb/aotg/aotg_plat_data.h         |   54 +
 drivers/usb/aotg/aotg_regs.h              | 1534 +++++++++++++
 drivers/usb/aotg/aotg_ring.c              | 1509 +++++++++++++
 drivers/usb/aotg/aotg_ring.h              |   48 +
 drivers/usb/aotg/aotg_udc.c               | 2181 ++++++++++++++++++
 drivers/usb/aotg/aotg_udc.h               |  232 ++
 drivers/usb/aotg/aotg_udc_debug.c         |  409 ++++
 drivers/usb/aotg/aotg_udc_debug.h         |   19 +
 drivers/usb/host/Makefile                 |    4 +-
 22 files changed, 12333 insertions(+), 2 deletions(-)
 create mode 100755 drivers/usb/aotg/Kconfig
 create mode 100755 drivers/usb/aotg/Makefile
 create mode 100755 drivers/usb/aotg/aotg.h
 create mode 100755 drivers/usb/aotg/aotg_core.c
 create mode 100755 drivers/usb/aotg/aotg_hcd.c
 create mode 100755 drivers/usb/aotg/aotg_hcd.h
 create mode 100755 drivers/usb/aotg/aotg_hcd_debug.c
 create mode 100755 drivers/usb/aotg/aotg_hcd_debug.h
 create mode 100755 drivers/usb/aotg/aotg_mon.c
 create mode 100755 drivers/usb/aotg/aotg_mon.h
 create mode 100755 drivers/usb/aotg/aotg_plat_data.h
 create mode 100755 drivers/usb/aotg/aotg_regs.h
 create mode 100755 drivers/usb/aotg/aotg_ring.c
 create mode 100755 drivers/usb/aotg/aotg_ring.h
 create mode 100755 drivers/usb/aotg/aotg_udc.c
 create mode 100755 drivers/usb/aotg/aotg_udc.h
 create mode 100755 drivers/usb/aotg/aotg_udc_debug.c
 create mode 100755 drivers/usb/aotg/aotg_udc_debug.h

diff --git a/arch/arm/boot/dts/actduino_bubble_gum.dts b/arch/arm/boot/dts/actduino_bubble_gum.dts
index 8ebe5ae..4d498b9 100755
--- a/arch/arm/boot/dts/actduino_bubble_gum.dts
+++ b/arch/arm/boot/dts/actduino_bubble_gum.dts
@@ -1013,6 +1013,7 @@
 	};
 
 	usb@b0600000 {
+		aotg_udc_enable = <1>;
 		vbus_otg_en_gpio = <&gpio 36 1>; /*GPIO B4*/
 		port0_host_plug_detect = <3>;
 		status = "disabled";
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 1074941..b165fdc 100755
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -97,6 +97,8 @@ source "drivers/usb/usbip/Kconfig"
 
 endif
 
+source "drivers/usb/aotg/Kconfig"
+
 source "drivers/usb/musb/Kconfig"
 
 source "drivers/usb/dwc3/Kconfig"
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index 059faed..5d1a816 100755
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -7,6 +7,8 @@
 obj-$(CONFIG_USB)		+= core/
 obj-$(CONFIG_USB_SUPPORT)	+= phy/
 
+obj-$(CONFIG_USB_AOTG)		+= aotg/
+
 obj-$(CONFIG_USB_DWC3)		+= dwc3/
 obj-$(CONFIG_USB_DWC2)		+= dwc2/
 obj-$(CONFIG_USB_ISP1760)	+= isp1760/
diff --git a/drivers/usb/aotg/Kconfig b/drivers/usb/aotg/Kconfig
new file mode 100755
index 0000000..dfb848f
--- /dev/null
+++ b/drivers/usb/aotg/Kconfig
@@ -0,0 +1,13 @@
+#
+# Actions usb2.0 controllers configuration
+#
+
+config USB_AOTG
+	tristate "Actions usb2.0 otg support"
+	default y
+	---help---
+	  The Actions chips have USB2.0 otg controllers. Enable
+	  this option if your board uses this chip. If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called acts_usb.
\ No newline at end of file
diff --git a/drivers/usb/aotg/Makefile b/drivers/usb/aotg/Makefile
new file mode 100755
index 0000000..7c40b6a
--- /dev/null
+++ b/drivers/usb/aotg/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for Actions usb2.0 controllers
+#
+obj-$(CONFIG_USB_AOTG)	+= aotg.o
+aotg-y := aotg_core.o aotg_udc.o aotg_hcd.o aotg_udc_debug.o aotg_hcd_debug.o aotg_ring.o aotg_mon.o
+
diff --git a/drivers/usb/aotg/aotg.h b/drivers/usb/aotg/aotg.h
new file mode 100755
index 0000000..ab6849d
--- /dev/null
+++ b/drivers/usb/aotg/aotg.h
@@ -0,0 +1,55 @@
+#ifndef  __LINUX_AOTG_H 
+#define  __LINUX_AOTG_H 
+
+#include <mach/hardware.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/hcd.h>
+#include <linux/earlysuspend.h>
+
+#include "aotg_regs.h"
+
+#define TRB_ITE	(1 << 11)
+#define TRB_CHN	(1 << 10)
+#define TRB_CSP	(1 << 9)
+#define TRB_COF	(1 << 8)
+#define TRB_ICE	(1 << 7)
+#define TRB_IZE	(1 << 6)
+#define TRB_ISE (1 << 5)
+#define TRB_LT	(1 << 4)
+#define AOTG_TRB_IOC	(1 << 3)
+#define AOTG_TRB_IOZ	(1 << 2)
+#define AOTG_TRB_IOS	(1 << 1)
+#define TRB_OF	(1 << 0)
+
+#define USE_SG
+#ifdef USE_SG
+#define NUM_TRBS (256)
+#define RING_SIZE (NUM_TRBS * 16)
+#else
+#define NUM_TRBS (64)
+#define RING_SIZE (NUM_TRBS * 16)
+#endif
+
+struct aotg_trb {
+	u32 hw_buf_ptr;
+	u32 hw_buf_len;
+	u32 hw_buf_remain;
+	u32 hw_token;
+};
+
+extern int vbus_otg_en_gpio[2][2];
+extern int aotg_udc_enable[2];
+void aotg_hardware_init(int id);
+void aotg_udc_exit(int id);
+extern struct aotg_hcd *act_hcd_ptr[2];
+extern struct aotg_udc *acts_udc_controller;
+extern unsigned int port_device_enable[2];
+extern struct of_device_id aotg_of_match[];
+extern int aotg_probe(struct platform_device *pdev);
+extern int aotg_remove(struct platform_device *pdev);
+void aotg_clk_enable(int id, int is_enable);
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/usb/aotg/aotg_core.c b/drivers/usb/aotg/aotg_core.c
new file mode 100755
index 0000000..64d37c3
--- /dev/null
+++ b/drivers/usb/aotg/aotg_core.c
@@ -0,0 +1,878 @@
+/*
+ * (C) Copyright www.actions-semi.com 2012-2014
+ *     Written by houjingkun. <houjingkun@actions-semi.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/kthread.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/highmem.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+
+#include <asm/irq.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/hardware.h>
+#include <linux/clk.h>
+#include <linux/wakelock.h>
+#include <linux/suspend.h>
+#include <mach/debug.h>
+#include <asm/prom.h>
+#include <mach/gpio.h>
+#include <linux/kallsyms.h>
+#include <mach/powergate.h>
+#include <mach/module-owl.h>
+
+#include "aotg_hcd.h"
+#include "aotg_plat_data.h"
+#include "aotg_hcd_debug.h"
+#include "aotg_udc_debug.h"
+#include "aotg_mon.h"
+#include "aotg_udc.h"
+
+static int aotg0_slew_rate = -1;
+module_param(aotg0_slew_rate, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(aotg0_slew_rate, "aotg0_slew_rate");
+static int aotg0_tx_bias = -1;
+module_param(aotg0_tx_bias, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(aotg0_tx_bias, "aotg0_tx_bias");
+
+static int aotg1_slew_rate = -1;
+module_param(aotg1_slew_rate, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(aotg1_slew_rate, "aotg1_slew_rate");
+static int aotg1_tx_bias = -1;
+module_param(aotg1_tx_bias, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(aotg1_tx_bias, "aotg1_tx_bias");
+
+struct aotg_udc *acts_udc_controller;
+unsigned int port_device_enable[2];
+int vbus_otg_en_gpio[2][2];
+enum aotg_mode_e aotg_mode[2];
+static struct platform_device *aotg_dev[2][2];
+static int aotg_initialized[2][2];
+int is_ls_device[2]; /*if detect low speed device plug in,must disable usbh high speed*/
+struct mutex aotg_onoff_mutex;
+struct aotg_hcd *act_hcd_ptr[2];
+int aotg_udc_enable[2];
+
+static u64 hcd_dmamask = DMA_BIT_MASK(32);
+static struct aotg_plat_data aotg_data0 = {
+	.usbecs = (void __iomem *)IO_ADDRESS(USBH0_ECS),
+	.usbpll = (void __iomem *)IO_ADDRESS(CMU_USBPLL),
+	.usbpll_bits = CMU_USBPLL_USBPLL0EN,
+	.devrst = (void __iomem *)IO_ADDRESS(CMU_DEVRST1),
+	.devrst_bits = CMU_DEVRST1_USBH0,
+	.no_hs = 0,
+};
+
+static struct aotg_plat_data aotg_data1 = {
+	.usbecs = (void __iomem *)IO_ADDRESS(USBH1_ECS),
+	.usbpll = (void __iomem *)IO_ADDRESS(CMU_USBPLL),
+	.usbpll_bits = CMU_USBPLL_USBPLL1EN,
+	.devrst = (void __iomem *)IO_ADDRESS(CMU_DEVRST1),
+	.devrst_bits = CMU_DEVRST1_USB1,
+	.no_hs = 0,
+};
+
+static void aotg_DD_set_phy(void __iomem *base, u8 reg, u8 value)
+{
+	u8 addrlow, addrhigh;
+	int time = 1;
+
+	addrlow = reg & 0x0f;
+	addrhigh = (reg >> 4) & 0x0f;
+
+	/*write vstatus: */
+	writeb(value, base + VDSTATUS);
+	mb();
+
+	/*write vcontrol: */
+	writeb(addrlow | 0x10, base + VDCTRL);
+	udelay(time); //the vload period should > 33.3ns
+	writeb(addrlow & 0x0f, base + VDCTRL);
+	udelay(time);
+	mb();
+	writeb(addrlow | 0x10, base + VDCTRL);
+	udelay(time);
+	writeb(addrhigh | 0x10, base + VDCTRL);
+	udelay(time);
+	writeb(addrhigh & 0x0f, base + VDCTRL);
+	udelay(time);
+	writeb(addrhigh | 0x10, base + VDCTRL);
+	udelay(time);
+	return;
+}
+
+static void aotg_set_hcd_phy(int id)
+{
+	int slew_rate,tx_bias;
+	void __iomem *base = act_hcd_ptr[id]->base;
+	if (id) {
+		slew_rate = aotg1_slew_rate;
+		tx_bias = aotg1_tx_bias;
+	} else {
+		slew_rate = aotg0_slew_rate;
+		tx_bias = aotg0_tx_bias;
+	}
+
+	aotg_DD_set_phy(base, 0xf4,(1<<7) |(1<<5)|(1<<4)|(2<<2)|(3<<0));
+	aotg_DD_set_phy(base, 0xe0,(1<<5) |(1<<4)|(0<<3)|(1<<2)|(1<<0));
+
+	aotg_DD_set_phy(base, 0xf4,(1<<7) |(1<<5)|(1<<4)|(2<<2)|(3<<0));
+	if((slew_rate >=0) && (slew_rate <= 7))
+		aotg_DD_set_phy(base, 0xe1,(slew_rate<<5)|(0<<4)|(1<<3)|(1<<2)|(3<<0));
+	else
+		aotg_DD_set_phy(base, 0xe1,(3<<5) |(0<<4)|(1<<3)|(1<<2)|(3<<0));
+
+	aotg_DD_set_phy(base, 0xf4,(1<<7) |(0<<5)|(1<<4)|(2<<2)|(3<<0));
+	aotg_DD_set_phy(base, 0xe6,(1<<7) |(4<<4)|(1<<3)|(0<<2)|(3<<0));
+
+	aotg_DD_set_phy(base, 0xf4,(1<<7) |(0<<5)|(1<<4)|(2<<2)|(3<<0));
+	//aotg_DD_set_phy(base, 0xe7,(7<<4)|(0<<1)|(1<<0));
+	aotg_DD_set_phy(base, 0xe7,(9<<4)|(0<<1)|(1<<0));
+
+	aotg_DD_set_phy(base, 0xf4,(1<<7) |(1<<5)|(1<<4)|(2<<2)|(3<<0));
+	aotg_DD_set_phy(base, 0xe0,(1<<5) |(1<<4)|(0<<3)|(0<<2)|(1<<0));
+	
+	
+	aotg_DD_set_phy(base, 0xf4,(1<<7) |(0<<5)|(1<<4)|(2<<2)|(3<<0));
+	if((tx_bias >=0) && (tx_bias <= 15))
+		aotg_DD_set_phy(base, 0xe4, (0xc<<4)|(tx_bias<<0));
+	else
+		aotg_DD_set_phy(base, 0xe4, (0xc<<4)|(4<<0));
+	
+	aotg_DD_set_phy(base, 0xf0,(1<<7) |(1<<6) |(1<<5)|(1<<4)|(1<<3)|(1<<2)|(0<<1)|(0<<0));
+	return;
+}
+
+void aotg_clk_enable(int id, int is_enable)
+{
+	struct aotg_plat_data *data;
+	if (id)
+		data = &aotg_data1;
+	else
+		data = &aotg_data0;
+
+	if (is_enable) {
+		usb_setbitsl(data->usbpll_bits, data->usbpll);
+	} else {
+		usb_clearbitsl(data->usbpll_bits, data->usbpll);
+	}
+
+	return;
+}
+
+static int aotg_controller_reset(int id)
+{
+	struct aotg_plat_data *data;
+	void __iomem *usb_reset;
+	int i = 0;
+
+	if (id)
+		data = &aotg_data1;
+	else
+		data = &aotg_data0;
+	usb_clearbitsl(data->devrst_bits, data->devrst);
+	udelay(1);
+	usb_setbitsl(data->devrst_bits, data->devrst);
+
+	if (aotg_mode[id] == HCD_MODE)
+		usb_reset = act_hcd_ptr[id]->base + USBERESET;
+	else
+		usb_reset = acts_udc_controller->base + USBERESET;
+	while (((readb(usb_reset) & USBERES_USBRESET) != 0) && (i < 300000)) {
+		i++;
+		udelay(1);
+	}
+
+	if (!(readb(usb_reset) & USBERES_USBRESET)) {
+		pr_info("usb reset OK: %x.\n", readb(usb_reset));
+	} else {
+		pr_err("usb reset ERROR: %x.\n", readb(usb_reset));
+		return -EBUSY;
+	}
+	return 0;
+}
+
+void aotg_hardware_init(int id)
+{
+	u8 val8;
+	unsigned long flags;
+	struct aotg_plat_data *data;
+	void __iomem *base;
+	if (id)
+		data = &aotg_data1;
+	else
+		data = &aotg_data0;
+
+	if (aotg_mode[id] == HCD_MODE)
+		base = act_hcd_ptr[id]->base;
+	else
+		base = acts_udc_controller->base;
+
+	owl_powergate_power_on(id ? OWL_POWERGATE_USB2_1 : OWL_POWERGATE_USB2_0);
+	//module_clk_enable(MOD_ID_USB2);
+	module_clk_enable(id ? MOD_ID_USB2_1 : MOD_ID_USB2_0);
+	aotg_clk_enable(id, 1);
+
+	local_irq_save(flags);
+	aotg_controller_reset(id);
+	/* fpga : new DMA mode */
+	writel(0x1, base + HCDMABCKDOOR);
+
+	if (aotg_mode[id] == HCD_MODE) {
+		writel((0x37 << 24) | (0x10 << 13) | (0xb << 4), data->usbecs);
+		udelay(100);
+		aotg_set_hcd_phy(id);
+
+		/***** TA_BCON_COUNT *****/
+		writeb(0x0, base + TA_BCON_COUNT);     		//110ms
+
+		/*set TA_AIDL_BDIS timeout never generate */
+		writeb(0xff, base + TAAIDLBDIS);
+		/*set TA_WAIT_BCON timeout never generate */
+		writeb(0xff, base + TAWAITBCON);
+		/*set TB_VBUS_DISCHARGE_PLS timeout value = 40.68ms*/
+		writeb(0x28, base + TBVBUSDISPLS);
+		/*set TA_WAIT_BCON timeout never generate*/
+		usb_setbitsb(1 << 7, base + TAWAITBCON);
+
+		writew(0x1000, base + VBUSDBCTIMERL);
+//	writeb(0x40, base + USBCS);
+
+		val8 = readb(base + BKDOOR);
+		if (data && data->no_hs) {
+			val8 |= (1 << 7);
+		} else {
+			val8 &= ~(1 << 7);
+		}
+		if (is_ls_device[id])
+			val8 |= (1<<7);
+		writeb(val8, base + BKDOOR);
+	} else {
+		if (acts_udc_controller->inited == 0) { /*in poweron,don't enter device mode*/
+			writel((0x37 << 24) | (0x10 << 13) | (0xb << 4), data->usbecs);
+			acts_udc_controller->inited = 1;
+		} else {
+			writel((0x3f << 24) | (0x10 << 13) | (0xb << 4) | (0x0f), data->usbecs);
+		}
+		udelay(100);
+		printk("USBECS(0x%x),CMU_USBPLL(0x%x)\n",usb_readl(data->usbecs),usb_readl(data->usbpll));
+		//aotg_set_udc_phy(base);
+		usb_setbitsb(1 << 4, base + BKDOOR);  /*clk40m */
+
+		writeb(0xff,base + USBIRQ);
+		writeb(0xff,base + OTGIRQ);
+		writeb(readb(base + USBEIRQ), base + USBEIRQ);
+		writeb(0xff,base + OTGIEN);
+		writeb(0x0D,base + USBEIRQ);
+	}
+	mb();
+	local_irq_restore(flags);
+
+	return;
+}
+
+struct of_device_id aotg_of_match[] = {
+	{.compatible = "actions,owl-usb-2.0-0",.data = &aotg_data0},
+	{.compatible = "actions,owl-usb-2.0-1",.data = &aotg_data1},
+	{},
+};
+MODULE_DEVICE_TABLE(of, aotg_of_match);
+
+static int aotg_platform_device_init(struct platform_device *pdev)
+{
+	struct device_node *of_node;
+	enum of_gpio_flags flags;
+
+	of_node = of_find_compatible_node(NULL, NULL, aotg_of_match[pdev->id].compatible);
+	if (NULL == of_node) {
+		dev_err(&pdev->dev, "can't find usbh%d dts node\n",pdev->id);
+		return -1;
+	}
+
+	if (aotg_mode[pdev->id] == UDC_MODE)
+		return 0;
+
+	if (!of_find_property(of_node, "vbus_otg_en_gpio", NULL)) {
+		pr_info("can't find vbus_otg_en_gpio config\n");
+		vbus_otg_en_gpio[pdev->id][0] = -1;
+	} else {
+		vbus_otg_en_gpio[pdev->id][0] = of_get_named_gpio_flags(of_node, "vbus_otg_en_gpio",0, &flags);
+		vbus_otg_en_gpio[pdev->id][1] = flags & 0x01;
+		if (gpio_request(vbus_otg_en_gpio[pdev->id][0], aotg_of_match[pdev->id].compatible)) {
+			dev_dbg(&pdev->dev, "fail to request vbus gpio [%d]\n", vbus_otg_en_gpio[pdev->id][0]);
+			//return -3;
+		}
+		gpio_direction_output(vbus_otg_en_gpio[pdev->id][0], 1);
+	}
+	
+	pr_info("vbus_otg_en_gpio:%d\n",vbus_otg_en_gpio[pdev->id][0]);
+	
+	aotg_power_onoff(pdev->id,1);
+
+	return 0;
+};
+
+int aotg_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct resource *res_mem;
+	void __iomem		*regs;
+	struct aotg_hcd *acthcd;
+	struct aotg_udc *udc;
+	int irq;
+	int retval;
+
+	if (aotg_platform_device_init(pdev) <0) {
+		retval = -ENODEV;
+		goto err0;
+	}
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res_mem) {
+		dev_err(&pdev->dev, "<HCD_PROBE>usb has no resource for mem!\n");
+		retval = -ENODEV;
+		goto err0;
+	}
+	printk("res_mem->start--end = 0x%x--0x%x\n",res_mem->start,res_mem->end);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_err(&pdev->dev, "<AOTG_PROBE>usb has no resource for irq!\n");
+		retval = -ENODEV;
+		goto err0;
+	}
+	printk("irq = %d\n",irq);
+
+	if (!request_mem_region(res_mem->start, res_mem->end - res_mem->start + 1, dev_name(&pdev->dev))) {
+		dev_err(&pdev->dev, "<AOTG_PROBE>request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err0;
+	}
+
+	regs = ioremap(res_mem->start, res_mem->end - res_mem->start + 1);
+	if (!regs) {
+		dev_err(&pdev->dev, "<AOTG_PROBE>ioremap failed\n");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	printk("pdev->id:%d\n",pdev->id);
+
+	if (aotg_mode[pdev->id] == HCD_MODE) {
+		hcd = usb_create_hcd(&act_hc_driver, &pdev->dev, dev_name(&pdev->dev));
+		if (!hcd) {
+			dev_err(&pdev->dev, "<HCD_PROBE>usb create hcd failed\n");
+			retval = -ENOMEM;
+			goto err2;
+		}
+
+		hcd->regs = regs;
+		hcd->rsrc_start = res_mem->start;
+		hcd->rsrc_len = res_mem->end - res_mem->start + 1;
+		retval = aotg_hcd_init(hcd, pdev);
+		if (retval) {
+			dev_err(&pdev->dev, "<HCD_PROBE>hcd init failed\n");
+			usb_put_hcd(hcd);
+			goto err2;
+		}
+
+		acthcd = hcd_to_aotg(hcd);
+		act_hcd_ptr[pdev->id] = acthcd;
+		acthcd->dev = &pdev->dev;
+		acthcd->base = hcd->regs;
+		acthcd->hcd_exiting = 0;
+		acthcd->uhc_irq = irq;
+		acthcd->id = pdev->id;
+		dev_info(&pdev->dev, "pdev->id probe:%d\n", pdev->id);
+		aotg_hardware_init(pdev->id);
+
+#if 0    
+#ifdef	CONFIG_PM
+		aotg_hcd_register_earlysuspend(acthcd);
+#endif
+#endif
+
+		hcd->self.sg_tablesize = 32;
+
+		hcd->has_tt = 1;
+		hcd->self.uses_pio_for_control = 1;	/* for ep0, using CPU mode only. */
+
+		init_timer(&acthcd->hotplug_timer);
+		acthcd->hotplug_timer.function = aotg_hub_hotplug_timer;
+		acthcd->hotplug_timer.data = (unsigned long)acthcd;
+
+		init_timer(&acthcd->trans_wait_timer);
+		acthcd->trans_wait_timer.function = aotg_hub_trans_wait_timer;
+		acthcd->trans_wait_timer.data = (unsigned long)acthcd;
+		init_timer(&acthcd->check_trb_timer);
+		acthcd->check_trb_timer.function = aotg_check_trb_timer;
+		acthcd->check_trb_timer.data = (unsigned long)acthcd;
+
+		retval = usb_add_hcd(hcd, irq, 0);
+		if (likely(retval == 0)) {
+			aotg_enable_irq(acthcd);
+			create_debug_file(acthcd);
+			dev_info(&pdev->dev, "hcd controller initialized. OTGIRQ: 0x%02X, OTGSTATE: 0x%02X \n", 
+				readb(acthcd->base + OTGIRQ),
+				readb(acthcd->base + OTGSTATE));
+
+			writeb(readb(acthcd->base + USBEIRQ), acthcd->base + USBEIRQ);
+			printk("USBEIRQ(0x%p): 0x%02X\n", acthcd->base + USBEIRQ, readb(acthcd->base + USBEIRQ));
+			return 0;
+		} else {
+			dev_err(acthcd->dev, "<HCD_PROBE>usb add hcd failed\n");
+		}
+
+		del_timer_sync(&acthcd->hotplug_timer);
+		del_timer_sync(&acthcd->trans_wait_timer);
+		del_timer_sync(&acthcd->check_trb_timer);
+	} else {
+		//aotg_power_onoff(pdev->id, 0);
+		udc = &memory;
+		udc->port_specific = pdev->dev.platform_data;
+		acts_udc_controller = udc;
+		udc->irq = irq;
+		udc->dev =  &pdev->dev;
+		udc->base = regs;
+		udc->rsrc_start = res_mem->start;
+		udc->rsrc_len = res_mem->end - res_mem->start + 1;
+		udc->id = pdev->id;
+		platform_set_drvdata(pdev, udc);
+		udc_reinit(udc);
+
+		aotg_hardware_init(pdev->id);
+		printk("udc->irq:%d\n", udc->irq);
+		retval = request_irq(udc->irq, aotg_udc_irq, 0, udc_driver_name, udc);
+		if (retval != 0) {
+			dev_err(udc->dev, "%s: can't get irq %i, err %d\n", udc_driver_name, udc->irq, retval);
+			goto err2;
+		}
+
+		retval = usb_add_gadget_udc(&pdev->dev, &udc->gadget);
+		if (retval) {
+			free_irq(udc->irq, udc);
+			goto err2;
+		}
+		return 0;
+	}
+
+err2:
+	aotg_clk_enable(pdev->id, 0);
+	owl_powergate_power_off(acthcd->id ? OWL_POWERGATE_USB2_1 : OWL_POWERGATE_USB2_0);
+	iounmap(hcd->regs);
+err1:
+	release_mem_region(res_mem->start, res_mem->end - res_mem->start + 1);
+err0:
+	dev_err(&pdev->dev, "%s: usb probe hcd  failed, error is %d", __func__, retval);
+
+	return retval;
+}
+static inline int aotg_device_calc_id(int dev_id)
+{
+	int id;
+
+	if (hcd_ports_en_ctrl == 1) {
+		id = 0;
+	} else if (hcd_ports_en_ctrl == 2) {
+		id = 1;
+	} else if (hcd_ports_en_ctrl == 3) {
+		if (dev_id) {
+			id = 0;
+		} else {
+			id = 1;
+		}
+	} else {
+		id = dev_id;
+	}
+	return id;
+}
+
+int aotg_device_init(int dev_id, enum aotg_mode_e mode)
+{
+	struct device_node *of_node;
+	struct resource res[2];
+	int ret = 0;
+
+	mutex_lock(&aotg_onoff_mutex);
+	if (aotg_initialized[dev_id][mode]) {
+		aotg_initialized[dev_id][mode]++;
+		printk("aotg%d initialized already! cnt:%d\n", dev_id, aotg_initialized[dev_id][mode]);
+		mutex_unlock(&aotg_onoff_mutex);
+		return 0;
+	}
+	aotg_initialized[dev_id][mode] = 1;
+	aotg_mode[dev_id] = mode;
+	of_node = of_find_compatible_node(NULL, NULL, aotg_of_match[dev_id].compatible);
+	if (NULL == of_node) {
+		ERR("can't find usbh%d dts node\n",dev_id);
+		ret = -1;
+		goto err1;
+	}
+
+	memset(&res, 0, sizeof(res));
+	if (of_address_to_resource(of_node, 0, &res[0])) {
+		ERR("can't fetch mem info from dts\n");
+		ret = -2;
+		goto err1;
+	}
+
+	if (of_irq_to_resource(of_node, 0, &res[1]) == NO_IRQ) {
+		ERR("can't fetch IRQ info from dts\n");
+		ret = -3;
+		goto err1;
+	}
+
+	printk("id=%d,aotg_mode=%d\n",dev_id, mode);
+	if (mode == HCD_MODE)
+		aotg_dev[dev_id][mode] = platform_device_alloc("aotg_hcd", dev_id);
+	else
+		aotg_dev[dev_id][mode] = platform_device_alloc("aotg_udc", dev_id);
+	if (!aotg_dev[dev_id][mode]) {
+		ERR("platform_device_alloc fail\n");
+		ret = -ENOMEM;
+		goto err1;
+	}
+	aotg_dev[dev_id][mode]->dev.dma_mask = &hcd_dmamask;
+	aotg_dev[dev_id][mode]->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+
+	ret = platform_device_add_resources(aotg_dev[dev_id][mode], res, ARRAY_SIZE(res));
+	if (ret) {
+		ERR("platform_device_add_resources fail\n");
+		goto err;
+	}
+
+	ret = platform_device_add_data(aotg_dev[dev_id][mode], aotg_of_match[dev_id].data, sizeof(struct aotg_plat_data));
+	if (ret) {
+		ERR("platform_device_add_data fail\n");
+		goto err;
+	}
+
+	ret = platform_device_add(aotg_dev[dev_id][mode]);
+	if (ret) {
+		ERR("platform_device_add fail\n");
+		goto err;
+	}
+	mutex_unlock(&aotg_onoff_mutex);
+	return 0; 
+err:
+	platform_device_put(aotg_dev[dev_id][mode]);
+	aotg_dev[dev_id][mode] = NULL;
+err1:
+	mutex_unlock(&aotg_onoff_mutex);
+	return ret; 
+}
+
+void aotg_device_exit(int dev_id, enum aotg_mode_e mode)
+{
+	mutex_lock(&aotg_onoff_mutex);
+	printk("id=%d,aotg_mode=%d\n",dev_id, mode);
+	if (!aotg_initialized[dev_id][mode]) {
+		printk("aotg%d exit already!\n",dev_id);
+		mutex_unlock(&aotg_onoff_mutex);
+		return;
+	}
+
+	aotg_initialized[dev_id][mode]--;
+	if (aotg_initialized[dev_id][mode] > 0) {
+		printk("aotg%d_exit cnt:%d\n", dev_id, aotg_initialized[dev_id][mode]);
+		mutex_unlock(&aotg_onoff_mutex);
+		return;
+	}
+	aotg_initialized[dev_id][mode] = 0;
+	aotg_mode[dev_id] = mode;
+
+	if (aotg_dev[dev_id][mode] != NULL) {
+		platform_device_unregister(aotg_dev[dev_id][mode]);
+		aotg_dev[dev_id][mode] = NULL;
+	}
+	mutex_unlock(&aotg_onoff_mutex);
+}
+
+void aotg_udc_init(int id)
+{
+	struct resource *res_mem;
+	void __iomem		*regs;
+	struct aotg_udc *udc;
+	int irq;
+	int retval;
+	struct platform_device *pdev;
+
+	pdev = aotg_dev[id][UDC_MODE];
+	aotg_power_onoff(id, 0);
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res_mem) {
+		dev_err(&pdev->dev, "<HCD_PROBE>usb has no resource for mem!\n");
+		retval = -ENODEV;
+		goto err0;
+	}
+	printk("res_mem->start--end = 0x%x--0x%x\n",res_mem->start,res_mem->end);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_err(&pdev->dev, "<AOTG_PROBE>usb has no resource for irq!\n");
+		retval = -ENODEV;
+		goto err0;
+	}
+	printk("irq = %d\n",irq);
+
+	if (!request_mem_region(res_mem->start, res_mem->end - res_mem->start + 1, dev_name(&pdev->dev))) {
+		dev_err(&pdev->dev, "<AOTG_PROBE>request_mem_region failed\n");
+		retval = -EBUSY;
+		goto err0;
+	}
+
+	regs = ioremap(res_mem->start, res_mem->end - res_mem->start + 1);
+	if (!regs) {
+		dev_err(&pdev->dev, "<AOTG_PROBE>ioremap failed\n");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	udc = &memory;
+	udc->port_specific = pdev->dev.platform_data;
+	acts_udc_controller = udc;
+	udc->irq = irq;
+	udc->dev =  &pdev->dev;
+	udc->base = regs;
+	udc->id = pdev->id;
+	platform_set_drvdata(pdev, udc);
+	udc_reinit(udc);
+
+	aotg_mode[id] = UDC_MODE;
+	aotg_hardware_init(pdev->id);
+	printk("udc->irq:%d\n", udc->irq);
+	retval = request_irq(udc->irq, aotg_udc_irq, 0, udc_driver_name, udc);
+	if (retval != 0) {
+		dev_err(udc->dev, "%s: can't get irq %i, err %d\n", udc_driver_name, udc->irq, retval);
+		goto err2;
+	}
+	return;
+
+err2:
+	aotg_clk_enable(id, 0);
+	owl_powergate_power_off(id ? OWL_POWERGATE_USB2_1 : OWL_POWERGATE_USB2_0);
+	iounmap(regs);
+err1:
+	release_mem_region(res_mem->start, res_mem->end - res_mem->start + 1);
+err0:
+	dev_err(&pdev->dev, "%s: usb probe hcd  failed, error is %d", __func__, retval);
+
+	return;
+}
+
+void aotg_udc_exit(int id)
+{
+	struct aotg_udc *udc = acts_udc_controller;
+	free_irq(udc->irq, udc);
+	aotg_clk_enable(id, 0);
+	iounmap(udc->base);
+	release_mem_region(udc->rsrc_start, udc->rsrc_len);
+	owl_powergate_power_off(id ? OWL_POWERGATE_USB2_1 : OWL_POWERGATE_USB2_0);
+}
+
+int aotg_udc_register(int id)
+{
+	int ret = 0;
+	if (aotg_dev[id][HCD_MODE]) {
+		pr_err("aotg%d is used in hcd mode now!\n",id);
+		return -1;
+	}
+
+	if (aotg_dev[id][UDC_MODE]) {
+		if (id) {
+			if (aotg_uhost_mon1) {
+				wake_lock(&aotg_uhost_mon1->aotg_wake_lock);
+				aotg_uhost_mon1->aotg_uhost_det = 0;
+				usb_clearbitsl(USB2_PLL_EN1,aotg_uhost_mon1->usbpll);
+				owl_powergate_power_off(OWL_POWERGATE_USB2_1);
+			}
+		} else {
+			if (aotg_uhost_mon0) {
+				wake_lock(&aotg_uhost_mon0->aotg_wake_lock);
+				aotg_uhost_mon0->aotg_uhost_det = 0;
+				usb_clearbitsl(USB2_PLL_EN0,aotg_uhost_mon0->usbpll);
+				owl_powergate_power_off(OWL_POWERGATE_USB2_0);
+			}
+		}
+		aotg_udc_init(id);
+		pullup(acts_udc_controller, 1);
+		usb_setbitsb(USBEIRQ_USBIEN, acts_udc_controller->base + USBEIEN);
+	} else {
+		pr_err("udc%d device not exist !\n",id);
+		ret = -1;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(aotg_udc_register);
+
+void aotg_udc_unregister(int id)
+{
+	if (!aotg_dev[id][UDC_MODE])
+		return;
+	aotg_udc_exit(id);
+	if (id) {
+		if (aotg_uhost_mon1) {
+			aotg_power_onoff(id, 1);
+			wake_lock_timeout(&aotg_uhost_mon1->aotg_wake_lock, 15*HZ);
+			owl_powergate_power_on(OWL_POWERGATE_USB2_1);
+			usb_setbitsl(USB2_PLL_EN1,aotg_uhost_mon1->usbpll);
+			usb_setbitsl(USB2_PHYCLK_EN1,aotg_uhost_mon1->usbpll);
+			usb_setbitsl(USB2_ECS_PLL_LDO_EN,aotg_uhost_mon1->usbecs);
+			usb2_set_dp_500k_15k(aotg_uhost_mon1, 0, 1);
+			is_ls_device[1]=0;
+			aotg_uhost_mon1->aotg_uhost_det = 1;
+			mod_timer(&aotg_uhost_mon1->hotplug_timer, jiffies + msecs_to_jiffies(1000));
+		}
+	} else {
+		if (aotg_uhost_mon0) {
+			aotg_power_onoff(id, 1);
+			wake_lock_timeout(&aotg_uhost_mon0->aotg_wake_lock, 15*HZ);
+			owl_powergate_power_on(OWL_POWERGATE_USB2_0);
+			usb_setbitsl(USB2_PLL_EN0,aotg_uhost_mon0->usbpll);
+			usb_setbitsl(USB2_PHYCLK_EN0,aotg_uhost_mon0->usbpll);
+			usb_setbitsl(USB2_ECS_PLL_LDO_EN,aotg_uhost_mon0->usbecs);
+			usb2_set_dp_500k_15k(aotg_uhost_mon0, 0, 1);
+			is_ls_device[0]=0;
+			aotg_uhost_mon0->aotg_uhost_det = 1;
+			mod_timer(&aotg_uhost_mon0->hotplug_timer, jiffies + msecs_to_jiffies(1000));
+		}
+	}
+}
+EXPORT_SYMBOL(aotg_udc_unregister);
+
+int aotg_hub_register(int dev_id)
+{
+	int proc_id, ret = -1;
+	proc_id = aotg_device_calc_id(dev_id);
+	ret = aotg_device_init(proc_id, HCD_MODE);
+	return ret;
+}
+EXPORT_SYMBOL(aotg_hub_register);
+
+void aotg_hub_unregister(int dev_id)
+{
+	int proc_id;
+	proc_id = aotg_device_calc_id(dev_id);
+	aotg_device_exit(dev_id, HCD_MODE);
+}
+EXPORT_SYMBOL(aotg_hub_unregister);
+
+int is_udc_enable(int id)
+{
+	struct device_node *of_node;
+
+	of_node = of_find_compatible_node(NULL, NULL, aotg_of_match[id].compatible);
+	if (NULL == of_node) {
+		pr_err("can't find usbh%d dts node\n",id);
+		return 0;
+	}
+
+	if (!of_find_property(of_node, "aotg_udc_enable", NULL)) {
+		pr_info("can't find aotg_udc_enable config\n");
+		return 0;
+	} else {
+		aotg_udc_enable[id] = !!(be32_to_cpup((const __be32 *)of_get_property(of_node,  "aotg_udc_enable",NULL)));
+		return aotg_udc_enable[id];
+	}
+}
+
+void aotg_udc_add(void)
+{
+	int id;
+	printk("%s %d.............\n",__func__,__LINE__);
+	if (is_udc_enable(0)) {
+		id = 0;
+	} else if (is_udc_enable(1)) {
+		id = 1;
+	} else {
+		pr_info("No aotg_udc being enabled!\n");
+		return;
+	}
+	aotg_device_init(id, UDC_MODE);
+}
+
+void aotg_udc_remove(void)
+{
+	int id;
+	if (aotg_udc_enable[0])
+		id = 0;
+	else if (aotg_udc_enable[1])
+		id = 1;
+	else
+		return;
+
+	aotg_device_exit(id, UDC_MODE);
+}
+
+static struct workqueue_struct *start_mon_wq;
+static struct delayed_work start_mon_wker;
+
+static int __init aotg_init(void)
+{
+	mutex_init(&aotg_onoff_mutex);
+	platform_driver_register(&aotg_hcd_driver);
+	create_acts_hcd_proc();
+	platform_driver_register(&aotg_udc_driver);
+	create_acts_udc_proc();
+	aotg_udc_add();
+	start_mon_wq = create_singlethread_workqueue("aotg_start_mon_wq");
+	INIT_DELAYED_WORK(&start_mon_wker, aotg_uhost_mon_init);
+	queue_delayed_work(start_mon_wq, &start_mon_wker, msecs_to_jiffies(10000));
+	return 0;	
+}
+
+static void __exit aotg_exit(void)
+{
+	cancel_delayed_work_sync(&start_mon_wker);
+	flush_workqueue(start_mon_wq);
+	destroy_workqueue(start_mon_wq);
+	aotg_udc_remove();
+	remove_acts_hcd_proc();
+	platform_driver_unregister(&aotg_hcd_driver);	
+	remove_acts_udc_proc();
+	platform_driver_unregister(&aotg_udc_driver);
+	return;
+}
+
+module_init(aotg_init);
+module_exit(aotg_exit);
+
+MODULE_DESCRIPTION("Actions OTG controller driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/aotg/aotg_hcd.c b/drivers/usb/aotg/aotg_hcd.c
new file mode 100755
index 0000000..831395e
--- /dev/null
+++ b/drivers/usb/aotg/aotg_hcd.c
@@ -0,0 +1,3464 @@
+/*
+ * (C) Copyright www.actions-semi.com 2012-2014
+ *     Written by houjingkun. <houjingkun@actions-semi.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/kthread.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/highmem.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+
+#include <asm/irq.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/hardware.h>
+#include <linux/clk.h>
+#include <linux/wakelock.h>
+#include <linux/suspend.h>
+#include <mach/debug.h>
+#include <asm/prom.h>
+#include <mach/gpio.h>
+#include <linux/kallsyms.h>
+#include <mach/powergate.h>
+#include <mach/module-owl.h>
+
+#include "aotg_hcd.h"
+#include "aotg_plat_data.h"
+#include "aotg_hcd_debug.h"
+#include "aotg_mon.h"
+
+#define	DRIVER_DESC	"AOTG USB Host Controller Driver"
+int hcd_ports_en_ctrl = 0;
+
+static int handle_setup_packet(struct aotg_hcd *acthcd, struct aotg_queue *q);
+static void handle_hcep0_in(struct aotg_hcd *acthcd);
+static void handle_hcep0_out(struct aotg_hcd *acthcd);
+//static int aotg_hcd_flush_queue(struct aotg_hcd *acthcd);
+#if 0
+#ifdef	CONFIG_PM
+static void aotg_hcd_register_earlysuspend(struct aotg_hcd *acthcd);
+static void aotg_hcd_unregister_earlysuspend(struct aotg_hcd *acthcd);
+static void aotg_hcd_early_suspend(struct early_suspend *h);
+static void aotg_hcd_late_resume(struct early_suspend *h);
+
+typedef int (* aotg_hcd_reset_device_f)(struct usb_device *udev);
+aotg_hcd_reset_device_f aotg_hcd_reset_device = NULL;
+void aotg_hcd_reset_and_verify_device(struct aotg_hcd *acthcd, int reset_device);
+#endif
+#endif
+
+#define MAX_PACKET(x)	((x)&0x7FF)
+
+/* because usb0 and usb1's pll is all controlled together, 
+ * we couldn't enable aotg0 and aotg1 seperately. 
+ */
+//static int hcd_2clk_bits_en = 0;
+/* 0 is all enable, 1 -- just usb0 enable, 2 -- usb1 enable, 
+ * 3 -- usb0 and usb1 enable,but reversed. 
+ */
+
+#if 0
+/* forbid to enter suspend when driver is installed. */
+//struct wake_lock acts_hcd_wakelock;
+
+#ifdef	CONFIG_PM
+
+static void aotg_hcd_register_earlysuspend(struct aotg_hcd *acthcd)
+{
+	if (!acthcd) {
+		ACT_HCD_ERR
+		return;
+	}
+	
+	acthcd->earlysuspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 10;
+	acthcd->earlysuspend.suspend = aotg_hcd_early_suspend;
+	acthcd->earlysuspend.resume = aotg_hcd_late_resume;
+	register_early_suspend(&acthcd->earlysuspend);
+	
+	acthcd->lr_flag = 0;
+	
+	return;
+}
+
+static void aotg_hcd_unregister_earlysuspend(struct aotg_hcd *acthcd)
+{
+	if (acthcd->earlysuspend.suspend) 
+		unregister_early_suspend(&acthcd->earlysuspend);
+
+	acthcd->earlysuspend.suspend = NULL;
+	acthcd->earlysuspend.resume = NULL;
+	
+	return;
+}
+
+static void aotg_hcd_early_suspend(struct early_suspend *h)
+{
+	printk(KERN_DEBUG"%s do nothing!\n", __FUNCTION__);
+	
+	return;
+}
+
+static void aotg_hcd_late_resume(struct early_suspend *h)
+{
+	struct aotg_hcd *acthcd = container_of(h, struct aotg_hcd, earlysuspend);
+	if (!acthcd) {
+		printk(KERN_ERR"%s err, acthcd is NULL pointer!\n", __FUNCTION__);
+		return;
+	}
+	
+	if (acthcd->lr_flag) {
+		acthcd->lr_flag = 0;
+		printk(KERN_DEBUG"%s, %d\n", __FUNCTION__, __LINE__);
+//		if(hcd_suspend_en==0)
+			aotg_hcd_reset_and_verify_device(acthcd, USB_RESET_AND_VERIFY_DEVICE);
+	}
+	
+	return;
+}
+
+#if 0
+static void aotg_hcd_resume_disconnect(struct aotg_hcd *acthcd)
+{
+	//printk("uhost%d, usb device inserted : %d, otg state : 0x%02X\n",	acthcd->id, acthcd->inserted, usb_readb(acthcd->base + OTGSTATE) );
+	if ( (acthcd->inserted ==1) && 
+	    (usb_readb(acthcd->base + OTGSTATE) != AOTG_STATE_A_HOST)) {
+		printk("uhost%d,usb device disconnect in suspend, so,  now disconnect it!\n", acthcd->id);
+		acthcd->discon_happened = 1;
+		mod_timer(&acthcd->hotplug_timer, jiffies + msecs_to_jiffies(1));
+	}
+}
+#endif
+
+void aotg_hcd_reset_and_verify_device(struct aotg_hcd *acthcd, int reset_device)
+{	
+	int i, ret = 0;
+	unsigned long jiffies_expire = jiffies + HZ;
+	struct usb_device *udev = NULL;
+	
+	printk (KERN_DEBUG"* %s, %d *\n", __FUNCTION__, __LINE__);
+		
+	if (acthcd == NULL){
+		ACT_HCD_ERR
+		return;
+	}
+	
+	for (i = 0; i < MAX_EP_NUM; i++) {
+			if (acthcd->ep0[i] != NULL) {
+				break;
+			}
+		}
+	
+	if (i == MAX_EP_NUM) {
+		printk(KERN_ERR"%s, usb device is NULL!\n", __FUNCTION__);
+	}
+	else
+		udev = acthcd->ep0[i]->udev;
+
+	if (udev == NULL) {
+		printk(KERN_ERR"%s, udev is NULL, can't reset device here!\n", __FUNCTION__);
+		return;
+	}
+
+	while (!usb_trylock_device(udev)) {
+		if (time_after(jiffies, jiffies_expire)){
+			ret = -1;
+			break;
+		}
+		msleep(15);
+	}
+	
+	if (ret == 0) {
+		if (reset_device){
+			printk (KERN_DEBUG"usb_reset_and_verify_device\n");
+			aotg_hcd_reset_device = (aotg_hcd_reset_device_f)kallsyms_lookup_name("usb_reset_and_verify_device");
+			if (aotg_hcd_reset_device != NULL)
+				aotg_hcd_reset_device(udev);
+			else 
+				printk(KERN_ERR"Get reset_device fail!\n");
+		} else {
+				printk (KERN_DEBUG"usb_reset_device\n");
+				usb_reset_device(udev);		
+		}
+		mutex_unlock(&(udev->dev).mutex);
+	} else {
+		printk (KERN_ERR"Fail to reset usb device!\n");
+	}
+}
+
+EXPORT_SYMBOL_GPL (aotg_hcd_reset_and_verify_device);
+#endif
+#endif
+
+typedef void (* aotg_hub_symbol_func_t)(int);
+aotg_hub_symbol_func_t aotg_hub_notify_func = NULL;
+
+void aotg_power_onoff(int id,int on_off)
+{
+	if(port_host_plug_detect[id] == 2)
+		return;
+	if(port_host_plug_detect[id] == 3){
+		if(act_hcd_ptr[1-id] != NULL)//if the other port is working;don't change vbus status
+			return;
+	}
+	if (vbus_otg_en_gpio[id][0] >= 0)
+		gpio_set_value(vbus_otg_en_gpio[id][0], !(on_off^vbus_otg_en_gpio[id][1]));
+}
+
+
+static void aotg_hub_notify_hcd_exit(int state)
+{
+	static int is_first_call = 1;
+
+	if (is_first_call) {
+		is_first_call = 0;
+		aotg_hub_notify_func = (aotg_hub_symbol_func_t)kallsyms_lookup_name("aotg_hub_notify_exit");
+	}
+	if (aotg_hub_notify_func) {
+		aotg_hub_notify_func(state);
+	}
+	return;
+}
+
+static ulong get_fifo_addr(struct aotg_hcd *acthcd, int size)
+{
+	int i, j;
+	ulong addr = 0;
+	int mul = size / ALLOC_FIFO_UNIT;
+	int max_unit = AOTG_MAX_FIFO_SIZE/ALLOC_FIFO_UNIT;
+	int find_next = 0;
+
+	if (mul == 0)
+		mul = 1;
+
+	for (i = 2; i < max_unit;) {
+		if (acthcd->fifo_map[i] != 0) {
+			i++;
+			continue;    //find first unused addr
+		}
+
+		for (j = i; j < max_unit; j++) {
+			if ((j - i + 1) == mul)
+				break;
+
+			if (acthcd->fifo_map[j]) {
+				i = j;
+				find_next = 1;
+				break;
+			}
+		}
+
+		if (j == 64) {
+			break;
+		} else if (find_next) {
+			find_next = 0;
+			continue;
+		} else {
+			int k;
+			for (k = i; k <= j; k++) {
+				acthcd->fifo_map[k] = (1 << 31) | (i * 64);
+			}
+			addr = i * ALLOC_FIFO_UNIT;
+			break;
+		}
+	}
+
+	return addr;
+}
+
+static void release_fifo_addr(struct aotg_hcd *acthcd, ulong addr)
+{
+	int i;
+
+	for (i = addr/ALLOC_FIFO_UNIT; i < AOTG_MAX_FIFO_SIZE/ALLOC_FIFO_UNIT ; i++) {
+		if ((acthcd->fifo_map[i] & 0x7FFFFFFF) == addr)
+			acthcd->fifo_map[i] = 0;
+ 		else
+			break;
+	}
+	return;
+}
+
+static struct aotg_queue * aotg_hcd_get_queue(struct aotg_hcd *acthcd, struct urb *urb, unsigned mem_flags)
+{
+	int i;
+	int empty_idx = -1;
+	struct aotg_queue *q = NULL;
+
+	for (i = 0; i < AOTG_QUEUE_POOL_CNT; i++) {
+		if (acthcd->queue_pool[i] != NULL) {
+			if (acthcd->queue_pool[i]->in_using == 0) {
+				q = acthcd->queue_pool[i];
+				break;
+			}
+		} else {
+			if (empty_idx < 0) {
+				empty_idx = i;
+			}
+		}
+	}
+	if (i == AOTG_QUEUE_POOL_CNT) {
+		q = kzalloc(sizeof(*q), GFP_ATOMIC);
+		if (unlikely(!q)) {
+			dev_err(acthcd->dev, "aotg_hcd_get_queue failed\n");
+			return NULL;
+		}
+		if ((empty_idx >= 0) && (empty_idx < AOTG_QUEUE_POOL_CNT)) {
+			acthcd->queue_pool[empty_idx] = q;
+		}
+	}
+
+	memset(q, 0, sizeof(*q));
+	q->length = 0;
+	q->td.trb_vaddr = NULL;
+	INIT_LIST_HEAD(&q->enqueue_list);
+	INIT_LIST_HEAD(&q->dequeue_list);
+	INIT_LIST_HEAD(&q->finished_list);
+
+	q->in_using = 1;
+	return q;
+}
+
+static void aotg_hcd_release_queue(struct aotg_hcd *acthcd, struct aotg_queue *q)
+{
+	int i;
+
+	if (NULL == q)
+		return;
+
+	q->td.trb_vaddr = NULL;
+
+	/* release all */
+	if (q == NULL) {
+		for (i = 0; i < AOTG_QUEUE_POOL_CNT; i++) {
+			if (acthcd->queue_pool[i] != NULL) {
+				kfree(acthcd->queue_pool[i]);
+				acthcd->queue_pool[i] = NULL;
+			}
+		}
+		return;
+	}
+
+	for (i = 0; i < AOTG_QUEUE_POOL_CNT; i++) {
+		if (acthcd->queue_pool[i] == q) {
+			acthcd->queue_pool[i]->in_using = 0;
+			return;
+		}
+	}
+
+	kfree(q);
+	return;
+}
+
+static __inline__ int is_epfifo_busy(struct aotg_hcep *ep, int is_in)
+{
+	
+	if (is_in) 
+		return(EPCS_BUSY & readb(ep->reg_hcepcs)) == 0;	
+	else 
+		return (EPCS_BUSY & readb(ep->reg_hcepcs)) != 0;
+}
+
+static __inline__ void ep_setup(struct aotg_hcep *ep, u8 type, u8 buftype)
+{
+	ep->buftype = buftype;
+	writeb(type | buftype, ep->reg_hcepcon);
+}
+
+static __inline__ void pio_irq_disable(struct aotg_hcd *acthcd, u8 mask)
+{
+	u8 is_out = mask & USB_HCD_OUT_MASK;
+	u8 ep_num = mask & 0x0f;
+
+	if (is_out) {
+		usb_clearbitsw(1 << ep_num, acthcd->base + HCOUTxIEN0);
+	} else {
+		usb_clearbitsw(1 << ep_num, acthcd->base + HCINxIEN0);
+	}
+	return;
+}
+
+static __inline__ void pio_irq_enable(struct aotg_hcd *acthcd, u8 mask)
+{
+	u8 is_out = mask & USB_HCD_OUT_MASK;
+	u8 ep_num = mask & 0x0f;
+
+	if (is_out) {
+		usb_setbitsw(1 << ep_num, acthcd->base + HCOUTxIEN0);
+	} else {
+		usb_setbitsw(1 << ep_num, acthcd->base + HCINxIEN0);
+	}
+	return;
+}
+
+static __inline__ void pio_irq_clear(struct aotg_hcd *acthcd, u8 mask)
+{
+	u8 is_out = mask & USB_HCD_OUT_MASK;
+	u8 ep_num = mask & 0x0f;
+
+	if (is_out) {
+		writew(1 << ep_num, acthcd->base + HCOUTxIRQ0);
+	}
+	else {
+		writew(1 << ep_num, acthcd->base + HCINxIRQ0);
+	}
+	return;
+}
+
+static __inline__ void ep_enable(struct aotg_hcep *ep)
+{
+	usb_setbitsb(0x80, ep->reg_hcepcon);
+}
+
+static __inline__ void ep_disable(struct aotg_hcep *ep)
+{
+	usb_clearbitsb(0x80, ep->reg_hcepcon);
+}
+
+static __inline__ void aotg_sofirq_on(struct aotg_hcd *acthcd)
+{
+	usb_setbitsb((1 << 1), acthcd->base + USBIEN);
+}
+
+static __inline__ void aotg_sofirq_off(struct aotg_hcd *acthcd)
+{
+	usb_clearbitsb(1 << 1, acthcd->base + USBIEN);
+}
+
+static __inline__ int get_subbuffer_count(u8 buftype)
+{
+	int count = 0;
+
+	switch (buftype) {
+	case EPCON_BUF_SINGLE:
+		count = 1;
+		break;
+	case EPCON_BUF_DOUBLE:
+		count = 2;
+		break;
+	case EPCON_BUF_TRIPLE:
+		count = 3;
+		break;
+	case EPCON_BUF_QUAD:
+		count = 4;
+		break;
+	}
+
+	return count;
+}
+
+static inline void aotg_config_hub_addr(struct urb *urb, struct aotg_hcep *ep) 
+{
+	if (ep->has_hub) {
+		if (urb->dev->speed == USB_SPEED_HIGH) {
+			writeb(usb_pipedevice(urb->pipe), ep->reg_hcep_dev_addr);
+			writeb(urb->dev->portnum, ep->reg_hcep_port);
+		} else {
+			writeb((0x80 | usb_pipedevice(urb->pipe)), ep->reg_hcep_dev_addr);
+			if (urb->dev->speed == USB_SPEED_LOW) {
+				writeb(0x80 | urb->dev->portnum, ep->reg_hcep_port);
+			} else {
+				writeb(urb->dev->portnum, ep->reg_hcep_port);
+			}
+		}
+		//writeb(0, ep->reg_hcep_splitcs);
+	} else {
+		writeb(usb_pipedevice(urb->pipe), ep->reg_hcep_dev_addr);
+		writeb(urb->dev->portnum, ep->reg_hcep_port);
+	}
+}
+
+#if (1)
+static void aotg_start_ring_transfer(struct aotg_hcd *acthcd, struct aotg_hcep *ep,
+		struct urb *urb)
+{
+	u32 addr;
+	struct aotg_trb *trb;
+	struct aotg_ring *ring = ep->ring;
+
+	aotg_config_hub_addr(urb, ep);
+	if (usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {
+		writeb(ep->interval, ep->reg_hcep_interval);
+		if (ring->is_out) {
+			trb = ring->dequeue_trb;
+			trb->hw_buf_ptr = urb->transfer_dma;
+			trb->hw_buf_len = urb->transfer_buffer_length;
+		}
+
+	}
+	ep_enable(ep);
+	addr = ring_trb_virt_to_dma(ring, ring->dequeue_trb);
+	aotg_start_ring(ring, addr);
+}
+
+#else
+static void aotg_start_ring_transfer(struct aotg_hcd *acthcd, struct aotg_hcep *ep,
+							struct urb *urb)
+{
+	u32 addr;
+	struct aotg_ring *ring = ep->ring;
+
+	aotg_config_hub_addr(urb, ep);
+	if (usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {
+		writeb(ep->interval, ep->reg_hcep_interval);
+		addr = ring_trb_virt_to_dma(ring, ring->first_trb);
+	} else {
+		addr = ring_trb_virt_to_dma(ring, ring->dequeue_trb);
+	}
+	ep_enable(ep);	
+	aotg_start_ring(ring, addr);
+}
+#endif
+/*
+static void aotg_stop_ring_transfer(struct aotg_hcd *acthcd, struct aotg_hcep *ep)
+{
+	struct aotg_ring *ring = ep->ring;
+
+	ep_disable(ep);
+	aotg_stop_ring(ring);
+}
+*/
+static int aotg_hcep_config_iso(struct aotg_hcd *acthcd, struct aotg_hcep *ep,
+			u8 type, u8 buftype, int is_out)
+{
+	int index = 0;
+	ulong addr = 0;
+	int get_ep = 0;
+	int subbuffer_count;
+	//u8 fifo_ctrl;
+
+	if (0 == (subbuffer_count = get_subbuffer_count(buftype))) {
+		dev_err(acthcd->dev, "error buftype: %02X, %s, %d\n", buftype, __func__, __LINE__);
+		return -EPIPE;
+	}
+
+	if (is_out) {
+		for (index = 1; index < MAX_EP_NUM; index++) {
+			if (acthcd->outep[index] == NULL) {
+				ep->is_out = 1;
+				ep->index = index;
+				ep->mask = (u8) (USB_HCD_OUT_MASK | index);
+				acthcd->outep[index] = ep;
+				get_ep = 1;
+				break;
+			}
+		}
+	} else {
+		for (index = 1; index < MAX_EP_NUM; index++) {
+			if (acthcd->inep[index] == NULL) {
+				ep->is_out = 0;
+				ep->index = index;
+				ep->mask = (u8) index;
+				acthcd->inep[index] = ep;
+				get_ep = 1;
+				break;
+			}
+		}
+	}
+
+	if (!get_ep) {
+		dev_err(acthcd->dev, "%s: no more available space for ep\n", __func__);
+		return -ENOSPC;
+	}
+
+	addr = get_fifo_addr(acthcd, subbuffer_count * MAX_PACKET(ep->maxpacket));
+	if (addr == 0) {
+		dev_err(acthcd->dev, "buffer configuration overload!! addr: %08X, subbuffer_count: %d, ep->maxpacket: %u\n",
+				(u32)addr, subbuffer_count, MAX_PACKET(ep->maxpacket));
+		if (is_out) {
+			acthcd->outep[ep->index] = NULL;
+		}
+		else {
+			acthcd->inep[ep->index] = NULL;
+		}
+		return -ENOSPC;
+	}
+	else {
+		ep->fifo_addr = addr;
+	}
+
+	ep->reg_hcepcon = get_hcepcon_reg(is_out, 
+							acthcd->base + HCOUT1CON, 
+							acthcd->base + HCIN1CON, 
+							ep->index);
+	ep->reg_hcepcs = get_hcepcs_reg(is_out, 
+							acthcd->base + HCOUT1CS, 
+							acthcd->base + HCIN1CS, 
+							ep->index);
+	ep->reg_hcepbc = get_hcepbc_reg(is_out, 
+							acthcd->base + HCOUT1BCL, 
+							acthcd->base + HCIN1BCL, 
+							ep->index);
+	ep->reg_hcepctrl = get_hcepctrl_reg(is_out, 
+							acthcd->base + HCOUT1CTRL, 
+							acthcd->base + HCIN1CTRL, 
+							ep->index);
+	ep->reg_hcmaxpck = get_hcepmaxpck_reg(is_out, 
+							acthcd->base + HCOUT1MAXPCKL, 
+							acthcd->base + HCIN1MAXPCKL, 
+							ep->index);
+	ep->reg_hcepaddr = get_hcepaddr_reg(is_out, 
+							acthcd->base + HCOUT1STADDR, 
+	    						acthcd->base + HCIN1STADDR, 
+	    						ep->index);
+	ep->reg_hcep_dev_addr = get_hcep_dev_addr_reg(is_out,
+							acthcd->base + HCOUT1ADDR, 
+	    						acthcd->base + HCIN1ADDR, 
+	    						ep->index);
+	ep->reg_hcep_port = get_hcep_port_reg(is_out,
+							acthcd->base + HCOUT1PORT, 
+	    						acthcd->base + HCIN1PORT, 
+	    						ep->index);
+	ep->reg_hcep_splitcs = get_hcep_splitcs_reg(is_out,
+							acthcd->base + HCOUT1SPILITCS, 
+	    						acthcd->base + HCIN1SPILITCS, 
+	    						ep->index);
+
+	//ep->reg_hcfifo = get_hcfifo_reg(acthcd->base + FIFO1DATA, ep->index);
+	if (!is_out) {
+		///* 5202 is just for write, read's HCINXCOUNT address is not the same with write address. */
+		//ep->reg_hcincount_wt = acthcd->base + HCIN1_COUNTL + (ep->index - 1) * 4;
+		//ep->reg_hcincount_rd = acthcd->base + HCIN1_COUNTL + (ep->index - 1) * 2;
+		ep->reg_hcerr = acthcd->base + HCIN0ERR + ep->index * 0x4;
+		ep->reg_hcep_interval = acthcd->base + HCEP0BINTERVAL + ep->index * 0x8;
+	}
+	else {
+		ep->reg_hcerr = acthcd->base + HCOUT0ERR + ep->index * 0x4;
+		ep->reg_hcep_interval = acthcd->base + HCOUT1BINTERVAL + (ep->index - 1) * 0x8;
+	}
+
+#ifdef DEBUG_EP_CONFIG
+	dev_info(acthcd->dev, "== ep->index: %d, is_out: %d, fifo addr: %08X\n", ep->index, is_out, (u32)addr);
+	dev_info(acthcd->dev, "== reg_hcepcon: %08lX, reg_hcepcs: %08lX, reg_hcepbc: %08lX, reg_hcepctrl: %08lX, reg_hcmaxpck: %08lX, ep->reg_hcepaddr: %08lX\n",
+			ep->reg_hcepcon,
+			ep->reg_hcepcs,
+			ep->reg_hcepbc,
+			ep->reg_hcepctrl,
+			ep->reg_hcmaxpck,
+			ep->reg_hcepaddr);
+#endif
+	
+	/*allocate buffer address of ep fifo */
+	writel(addr, ep->reg_hcepaddr);
+	writew(ep->maxpacket, ep->reg_hcmaxpck);
+	ep_setup(ep, type, buftype);	/*ep setup */
+	
+	/*reset this ep */
+	usb_settoggle(ep->udev, ep->epnum, is_out, 0);
+	aotg_hcep_reset(acthcd, ep->mask, ENDPRST_FIFORST | ENDPRST_TOGRST);
+	writeb(ep->epnum, ep->reg_hcepctrl);
+
+	return 0;
+}
+
+//support 3 bulk, 1 interrupt
+static int aotg_hcep_config(struct aotg_hcd *acthcd,
+			    struct aotg_hcep *ep,
+			    u8 type, u8 buftype, int is_out)
+{
+	int index = 0;
+	ulong addr = 0;
+	int get_ep = 0;
+	int subbuffer_count;
+	//u8 fifo_ctrl;
+
+	if (0 == (subbuffer_count = get_subbuffer_count(buftype))) {
+		dev_err(acthcd->dev, "error buftype: %02X, %s, %d\n", buftype, __func__, __LINE__);
+		return -EPIPE;
+	}
+
+	if (is_out) {
+		for (index = 1; index < MAX_EP_NUM; index++) {
+			if (acthcd->outep[index] == NULL) {
+				ep->is_out = 1;
+				ep->index = index;
+				ep->mask = (u8) (USB_HCD_OUT_MASK | index);
+				acthcd->outep[index] = ep;
+				get_ep = 1;
+				break;
+			}
+		}
+	} else {
+		for (index = 1; index < MAX_EP_NUM; index++) {
+			if (acthcd->inep[index] == NULL) {
+				ep->is_out = 0;
+				ep->index = index;
+				ep->mask = (u8) index;
+				acthcd->inep[index] = ep;
+				get_ep = 1;
+				break;
+			}
+		}
+	}
+
+	if (!get_ep) {
+		dev_err(acthcd->dev, "%s: no more available space for ep\n", __func__);
+		return -ENOSPC;
+	}
+
+	addr = get_fifo_addr(acthcd, subbuffer_count * MAX_PACKET(ep->maxpacket));
+	if (addr == 0) {
+		dev_err(acthcd->dev, "buffer configuration overload!! addr: %08X, subbuffer_count: %d, ep->maxpacket: %u\n",
+				(u32)addr, subbuffer_count, MAX_PACKET(ep->maxpacket));
+		if (is_out) {
+			acthcd->outep[ep->index] = NULL;
+		}
+		else {
+			acthcd->inep[ep->index] = NULL;
+		}
+		return -ENOSPC;
+	}
+	else {
+		ep->fifo_addr = addr;
+	}
+
+	ep->reg_hcepcon = get_hcepcon_reg(is_out, 
+							acthcd->base + HCOUT1CON, 
+							acthcd->base + HCIN1CON, 
+							ep->index);
+	ep->reg_hcepcs = get_hcepcs_reg(is_out, 
+							acthcd->base + HCOUT1CS, 
+							acthcd->base + HCIN1CS, 
+							ep->index);
+	ep->reg_hcepbc = get_hcepbc_reg(is_out, 
+							acthcd->base + HCOUT1BCL, 
+							acthcd->base + HCIN1BCL, 
+							ep->index);
+	ep->reg_hcepctrl = get_hcepctrl_reg(is_out, 
+							acthcd->base + HCOUT1CTRL, 
+							acthcd->base + HCIN1CTRL, 
+							ep->index);
+	ep->reg_hcmaxpck = get_hcepmaxpck_reg(is_out, 
+							acthcd->base + HCOUT1MAXPCKL, 
+							acthcd->base + HCIN1MAXPCKL, 
+							ep->index);
+	ep->reg_hcepaddr = get_hcepaddr_reg(is_out, 
+							acthcd->base + HCOUT1STADDR, 
+	    						acthcd->base + HCIN1STADDR, 
+	    						ep->index);
+	ep->reg_hcep_dev_addr = get_hcep_dev_addr_reg(is_out,
+							acthcd->base + HCOUT1ADDR, 
+	    						acthcd->base + HCIN1ADDR, 
+	    						ep->index);
+	ep->reg_hcep_port = get_hcep_port_reg(is_out,
+							acthcd->base + HCOUT1PORT, 
+	    						acthcd->base + HCIN1PORT, 
+	    						ep->index);
+	ep->reg_hcep_splitcs = get_hcep_splitcs_reg(is_out,
+							acthcd->base + HCOUT1SPILITCS, 
+	    						acthcd->base + HCIN1SPILITCS, 
+	    						ep->index);
+
+	//ep->reg_hcfifo = get_hcfifo_reg(acthcd->base + FIFO1DATA, ep->index);
+	if (!is_out) {
+		///* 5202 is just for write, read's HCINXCOUNT address is not the same with write address. */
+		//ep->reg_hcincount_wt = acthcd->base + HCIN1_COUNTL + (ep->index - 1) * 4;
+		//ep->reg_hcincount_rd = acthcd->base + HCIN1_COUNTL + (ep->index - 1) * 2;
+		ep->reg_hcerr = acthcd->base + HCIN0ERR + ep->index * 0x4;
+		ep->reg_hcep_interval = acthcd->base + HCEP0BINTERVAL + ep->index * 0x8;
+	}
+	else {
+		ep->reg_hcerr = acthcd->base + HCOUT0ERR + ep->index * 0x4;
+		ep->reg_hcep_interval = acthcd->base + HCOUT1BINTERVAL + (ep->index - 1) * 0x8;
+	}
+
+#ifdef DEBUG_EP_CONFIG
+	dev_info(acthcd->dev, "== ep->index: %d, is_out: %d, fifo addr: %08X\n", ep->index, is_out, (u32)addr);
+	dev_info(acthcd->dev, "== reg_hcepcon: %08lX, reg_hcepcs: %08lX, reg_hcepbc: %08lX, reg_hcepctrl: %08lX, reg_hcmaxpck: %08lX, ep->reg_hcepaddr: %08lX\n",
+			ep->reg_hcepcon,
+			ep->reg_hcepcs,
+			ep->reg_hcepbc,
+			ep->reg_hcepctrl,
+			ep->reg_hcmaxpck,
+			ep->reg_hcepaddr);
+#endif
+	
+	pio_irq_disable(acthcd, ep->mask);
+	pio_irq_clear(acthcd, ep->mask);
+	
+	ep_disable(ep);
+
+	/*allocate buffer address of ep fifo */
+	writel(addr, ep->reg_hcepaddr);
+	writew(ep->maxpacket, ep->reg_hcmaxpck);
+	ep_setup(ep, type, buftype);	/*ep setup */
+	
+	/*reset this ep */
+	usb_settoggle(ep->udev, ep->epnum, is_out, 0);
+	aotg_hcep_reset(acthcd, ep->mask, ENDPRST_FIFORST | ENDPRST_TOGRST);
+	writeb(ep->epnum, ep->reg_hcepctrl);
+
+	//fifo_ctrl = (1<<5) | ((!!is_out) << 4) | ep->index; //set auto fifo
+	//writeb(fifo_ctrl, acthcd->base + FIFOCTRL);
+	//pio_irq_enable(acthcd, ep->mask);
+
+	return 0;
+}
+
+static int aotg_hcep_set_split_micro_frame(struct aotg_hcd *acthcd, struct aotg_hcep *ep)
+{
+	static const u8 split_val[] = {0x31, 0x42, 0x53, 0x64, 0x75, 0x17, 0x20};
+	int i, index;
+	u8 set_val, rd_val;
+
+	for (i=0; i<sizeof(split_val); i++) {
+		set_val = split_val[i];
+
+		for (index=0; index<MAX_EP_NUM; index++) {
+			if (acthcd->inep[index] != NULL) {
+				rd_val = acthcd->inep[index]->reg_hcep_splitcs_val;
+
+				if ((0 == rd_val) || (set_val != rd_val)) {
+					continue;
+				}
+				if (set_val == rd_val)
+					set_val = 0;
+				break;
+			}
+		}
+		if (set_val == 0)
+			continue;
+
+		for (index=0; index<MAX_EP_NUM; index++) {
+			if (acthcd->outep[index] != NULL) {
+				rd_val = acthcd->outep[index]->reg_hcep_splitcs_val;
+
+				if ((0 == rd_val) || (set_val != rd_val)) {
+					continue;
+				}
+				if (set_val == rd_val)
+					set_val = 0;
+				break;
+			}
+		}
+
+		if (set_val != 0)
+			break;
+	}
+
+	if (set_val != 0) {
+		ep->reg_hcep_splitcs_val = set_val;
+		writeb(set_val, ep->reg_hcep_splitcs);
+		printk("====reg_hcep_splitcs_val:%x, index:%d\n", set_val, ep->index);
+	}
+	return 0;
+}
+
+static void finish_request(struct aotg_hcd *acthcd,
+			   struct aotg_queue *q,
+			   int status)
+{
+	struct urb *urb = q->urb;
+
+	if (unlikely((acthcd == NULL) || (q == NULL) || (urb == NULL))) {
+		WARN_ON(1);
+		return;
+	}
+
+	q->status = status;
+	if (list_empty(&q->finished_list)) {
+		list_add_tail(&q->finished_list, &acthcd->hcd_finished_list);
+	} else {
+		ACT_HCD_ERR
+	}
+	tasklet_hi_schedule(&acthcd->urb_tasklet);
+	return;
+}
+
+static void tasklet_finish_request(struct aotg_hcd *acthcd,
+			   struct aotg_queue *q,
+			   int status)
+{
+	struct urb *urb = q->urb;
+	struct aotg_hcep *ep = q->ep;
+
+	if (unlikely((acthcd == NULL) || (q == NULL) || (urb == NULL))) {
+		WARN_ON(1);
+		return;
+	}
+
+	if ((q != NULL) && (ep != NULL)) {
+		if (ep->q == NULL) {
+			ACT_HCD_ERR
+		} else {
+			if (ep->q == q) {
+				ep->q = NULL;
+			}
+		}
+	} else {
+		ACT_HCD_ERR
+		return;
+	}
+
+	if (status == 0) {
+		q->err_count = 0;
+	}
+
+	if (usb_pipetype(urb->pipe) == PIPE_CONTROL) {
+		if ((acthcd->active_ep0 != NULL) && (acthcd->active_ep0 == q->ep)) {
+			if (acthcd->active_ep0->q == NULL) {
+				acthcd->active_ep0 = NULL;
+			} else {
+				ACT_HCD_ERR
+			}
+		} else {
+			ACT_HCD_ERR
+		}
+	} 
+#if 0
+	if (q->td.trb_vaddr && q->td.trb_num) {
+		dma_free_coherent(aotg_to_hcd(acthcd)->self.controller,
+			q->td.trb_num * sizeof(struct aotg_trb),
+			q->td.trb_vaddr, q->td.trb_dma);
+	}
+#endif
+	aotg_dbg_finish_q(q);
+	aotg_hcd_release_queue(acthcd, q);
+	//usb_hcd_unlink_urb_from_ep(hcd, urb);
+	//usb_hcd_giveback_urb(hcd, urb, status);
+
+	ep->urb_endque_cnt++;
+	//ep->fifo_busy = 0;
+	//if (usb_pipeint(urb->pipe)) 
+	return;
+}
+
+static __inline__ void handle_status(struct aotg_hcd *acthcd, struct aotg_hcep *ep, int is_out)
+{
+	/*status always DATA1,set 1 to ep0 toggle */
+	writeb(EP0CS_HCSETTOOGLE, acthcd->base + EP0CS);
+
+	if (is_out) {
+		writeb(0, acthcd->base + HCIN0BC); //recv 0 packet
+	}
+	else {
+		writeb(0, acthcd->base + HCOUT0BC); //send 0 packet
+	}
+}
+
+static void write_hcep0_fifo(struct aotg_hcd *acthcd, struct aotg_hcep *ep, struct urb *urb)
+{
+	u32 *buf;
+	int length, count;
+	void __iomem *addr = acthcd->base + EP0INDATA_W0;
+
+	if (!(readb(acthcd->base + EP0CS) & EP0CS_HCOUTBSY)) {
+		buf = (u32 *) (urb->transfer_buffer + urb->actual_length);
+		prefetch(buf);
+
+		/* how big will this packet be? */
+		length = min((int)ep->maxpacket, (int)urb->transfer_buffer_length - (int)urb->actual_length);
+
+		count = length >> 2;	/*wirte in DWORD */
+		if (length & 0x3) count++;
+
+		while (likely(count--)) {
+			writel(*buf, addr);
+			buf++;
+			addr += 4;
+		}
+
+		ep->length = length;
+		writeb(length, acthcd->base + HCOUT0BC);
+		usb_dotoggle(urb->dev, usb_pipeendpoint(urb->pipe), 1);
+	} else {
+		dev_err(acthcd->dev, "<CTRL>OUT data is not ready\n");
+	}
+}
+
+static void read_hcep0_fifo(struct aotg_hcd *acthcd, struct aotg_hcep *ep, struct urb *urb)
+{
+	u8 *buf;
+	unsigned overflag, is_short, shorterr, is_last;
+	unsigned length, count;
+	struct usb_device *udev;
+	void __iomem *addr = acthcd->base + EP0OUTDATA_W0;  //HCEP0INDAT0;
+	unsigned bufferspace;
+
+	overflag = 0;
+	is_short = 0;
+	shorterr = 0;
+	is_last = 0;
+	udev = ep->udev;
+
+	if (readb(acthcd->base + EP0CS) & EP0CS_HCINBSY) {
+		dev_err(acthcd->dev, "<CTRL>IN data is not ready\n");
+		return;
+	} else {
+		usb_dotoggle(udev, ep->epnum, 0);
+		buf = urb->transfer_buffer + urb->actual_length;
+		bufferspace = urb->transfer_buffer_length - urb->actual_length;
+		//prefetch(buf);
+
+		length = count = readb(acthcd->base + HCIN0BC);
+		if (length > bufferspace) {
+			count = bufferspace;
+			urb->status = -EOVERFLOW;
+			overflag = 1;
+		}
+
+		urb->actual_length += count;
+		while (count--) {
+			*buf++ = readb(addr);
+#if 0
+			buf--;
+			printk("ep0in:%x, cnt:%d\n", (unsigned int)*buf, count);
+			buf++;
+#endif
+			addr++;
+		}
+
+		if (urb->actual_length >= urb->transfer_buffer_length) {
+			ep->nextpid = USB_PID_ACK;
+			is_last = 1;
+			handle_status(acthcd, ep, 0);
+		} else if (length < ep->maxpacket) {
+			is_short = 1;
+			is_last = 1;
+			if (urb->transfer_flags & URB_SHORT_NOT_OK) {
+				urb->status = -EREMOTEIO;
+				shorterr = 1;
+			}
+			ep->nextpid = USB_PID_ACK;
+			handle_status(acthcd, ep, 0);
+		}
+		else {
+			writeb(0, acthcd->base + HCIN0BC);
+		}
+	}
+}
+
+static int handle_setup_packet(struct aotg_hcd *acthcd, struct aotg_queue *q)
+{
+	struct urb *urb = q->urb;
+	struct aotg_hcep *ep = q->ep;
+	u32 *buf;
+	void __iomem *addr = acthcd->base + EP0INDATA_W0;
+	int i = 0;
+
+#ifdef DEBUG_SETUP_DATA
+	u16 w_value, w_index, w_length;
+	struct usb_ctrlrequest *ctrlreq;
+
+	ctrlreq = (struct usb_ctrlrequest *)urb->setup_packet;
+	w_value = le16_to_cpu(ctrlreq->wValue);
+	w_index = le16_to_cpu(ctrlreq->wIndex);
+	w_length = le16_to_cpu(ctrlreq->wLength);
+	dev_info(acthcd->dev, "<CTRL>SETUP stage  %02x.%02x V%04x I%04x L%04x\n ",
+		  ctrlreq->bRequestType, ctrlreq->bRequest, w_value, w_index,
+		  w_length);
+#endif
+	if ((q->is_xfer_start) || (ep->q)) {
+		ACT_HCD_DBG
+		printk("q->is_xfer_start:%d\n", q->is_xfer_start);
+		return 0;
+	}
+	if (unlikely(!HC_IS_RUNNING(aotg_to_hcd(acthcd)->state))) {
+		ACT_HCD_DBG
+		return -ESHUTDOWN;
+	}
+	if (acthcd->active_ep0 != NULL) {
+		ACT_HCD_ERR
+		return -EBUSY;
+	}
+
+	writeb(ep->epnum, acthcd->base + HCEP0CTRL);
+	writeb((u8)ep->maxpacket, acthcd->base + HCIN0MAXPCK);
+
+	acthcd->active_ep0 = ep;
+	ep->q = q;
+	q->is_xfer_start = 1;
+	usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), 1, 1);
+	ep->nextpid = USB_PID_SETUP;
+	buf = (u32 *) urb->setup_packet;
+
+	/*initialize the setup stage */
+	writeb(EP0CS_HCSET, acthcd->base + EP0CS);
+	while (readb(acthcd->base + EP0CS) & EP0CS_HCOUTBSY) {
+		writeb(EP0CS_HCSET, acthcd->base + EP0CS);
+		i++;
+		if (i > 2000000) {
+			printk("handle_setup timeout!\n");
+			break;
+		}
+	}
+	
+	if (!(readb(acthcd->base + EP0CS) & EP0CS_HCOUTBSY)) {
+		/*fill the setup data in fifo */
+		writel(*buf, addr);
+		addr += 4;
+		buf++;
+		writel(*buf, addr);
+		writeb(8, acthcd->base + HCOUT0BC);
+	}
+	else {
+		dev_warn(acthcd->dev, "setup ep busy!!!!!!!\n");
+	}
+
+	return 0;
+}
+
+static void handle_hcep0_out(struct aotg_hcd *acthcd)
+{
+	struct aotg_hcep *ep;
+	struct urb *urb;
+	struct usb_device *udev;
+	struct aotg_queue *q;
+	
+	ep = acthcd->active_ep0;
+	
+	if (unlikely(!ep)) {
+		ACT_HCD_ERR
+		return;
+	}
+	q = ep->q;
+	if (q == NULL) {
+		ACT_HCD_ERR
+		return;
+	}
+
+	urb = q->urb;
+	udev = ep->udev;
+
+	switch (ep->nextpid) {
+	case USB_PID_SETUP:
+		if (urb->transfer_buffer_length == urb->actual_length) {
+			ep->nextpid = USB_PID_ACK;
+			handle_status(acthcd, ep, 1);	/*no-data transfer */
+		} else if (usb_pipeout(urb->pipe)) {
+			usb_settoggle(udev, 0, 1, 1);
+			ep->nextpid = USB_PID_OUT;
+			write_hcep0_fifo(acthcd, ep, urb);
+		} else {
+			usb_settoggle(udev, 0, 0, 1);
+			ep->nextpid = USB_PID_IN;
+			writeb(0, acthcd->base + HCIN0BC);
+		}
+		break;
+	case USB_PID_OUT:
+		urb->actual_length += ep->length;
+		usb_dotoggle(udev, ep->epnum, 1);
+		if (urb->actual_length >= urb->transfer_buffer_length) {
+			ep->nextpid = USB_PID_ACK;
+			handle_status(acthcd, ep, 1);	/*control write transfer */
+		}
+		else {
+			ep->nextpid = USB_PID_OUT;
+			write_hcep0_fifo(acthcd, ep, urb);
+		}
+		break;
+	case USB_PID_ACK:
+		finish_request(acthcd, q, 0);
+		break;
+	default:
+		dev_err(acthcd->dev, "<CTRL>ep0 out ,odd pid %d, %s, %d\n", 
+				ep->nextpid, __func__, __LINE__);
+	}
+}
+
+static void handle_hcep0_in(struct aotg_hcd *acthcd)
+{
+	struct aotg_hcep *ep;
+	struct urb *urb;
+	struct usb_device *udev;
+	struct aotg_queue *q;
+	
+	ep = acthcd->active_ep0;
+	if (unlikely(!ep)) {
+		return;
+	}
+	q = ep->q;
+	if (q == NULL) {
+		ACT_HCD_ERR
+		return;
+	}
+
+	urb = q->urb;
+	udev = ep->udev;
+
+	switch (ep->nextpid) {
+	case USB_PID_IN:
+		read_hcep0_fifo(acthcd, ep, urb);
+		break;
+	case USB_PID_ACK:
+		finish_request(acthcd, q, 0);
+		break;
+	default:
+		dev_err(acthcd->dev, "<CTRL>ep0 out ,odd pid %d\n", ep->nextpid);
+	}
+}
+
+static void aotg_hcd_err_handle(struct aotg_hcd *acthcd, u32 irqvector, 
+				int ep_num, int is_in)
+{
+	struct urb *urb;
+	struct aotg_queue *q;
+	struct aotg_hcep *ep = NULL;
+	struct aotg_ring *ring = NULL;
+	struct aotg_td *td = NULL;
+	int status = -EOVERFLOW;
+	u8 err_val = 0;
+	u8 err_type = 0;
+	u8 reset = 0;
+	struct usb_hcd *hcd = aotg_to_hcd(acthcd);
+
+	printk("hcd ep err ep_num:%d, is_in:%d\n", ep_num, is_in);
+		
+	if (ep_num == 0) {
+		ep = acthcd->active_ep0;
+		if (ep == NULL) {
+			ACT_HCD_ERR
+			return;
+		}
+		q = ep->q;
+		if (is_in) {
+			ep->reg_hcerr = acthcd->base + HCIN0ERR;
+		} else {
+			ep->reg_hcerr = acthcd->base + HCOUT0ERR;
+		}
+	} else {
+		if (is_in) {
+			ep = acthcd->inep[ep_num];
+		} else {
+			ep = acthcd->outep[ep_num];
+		}
+		if (ep == NULL) {
+			ACT_HCD_ERR
+			printk("is_in:%d, ep_num:%d\n", is_in, ep_num);
+			return;
+		}
+		ring = ep->ring;
+		if (!ring) {
+			ACT_HCD_ERR
+			return;
+		}
+		td = list_first_entry_or_null(&ep->enring_td_list, struct aotg_td, enring_list);
+		if (!td) {
+			aotg_stop_ring(ring);
+			ACT_HCD_ERR
+			return;
+		}
+	}
+	
+	err_val = readb(ep->reg_hcerr);
+	if (is_in) {
+		writew(1 << ep_num, acthcd->base + HCINxERRIRQ0);
+	} else {
+		writew(1 << ep_num, acthcd->base + HCOUTxERRIRQ0);
+	}
+
+	err_type = err_val & HCINxERR_TYPE_MASK;
+	printk("err_type:%x\n",err_type>>2);
+	switch (err_type) {
+	case HCINxERR_NO_ERR:
+	case HCINxERR_OVER_RUN:
+		status = -EOVERFLOW;
+		break;
+	case HCINxERR_UNDER_RUN:
+		status = -EREMOTEIO;
+		break;
+	case HCINxERR_STALL:
+		status = -EPIPE;
+		break;
+	case HCINxERR_TIMEOUT:
+		status = -ETIMEDOUT;
+		break;
+	case HCINxERR_CRC_ERR:
+	case HCINxERR_TOG_ERR:
+	case HCINxERR_PID_ERR:
+		status = -EPROTO;
+		break;
+	//case HCINxERR_SPLIET:
+	default:
+		printk("err_val:0x%x, err_type:%d\n", err_val, err_type);
+		if (is_in) {
+			printk("HCINEP%dSPILITCS:0x%x\n", ep_num, 
+					readb(acthcd->base + ep_num * 8 + HCEP0SPILITCS));
+		} else { 
+			printk("HCOUTEP%dSPILITCS:0x%x\n", ep_num, 
+					readb(acthcd->base + (ep_num - 1) * 8 + HCOUT1SPILITCS));
+		}
+		status = -EPIPE;
+		break;
+
+	//default:
+	//	printk("err_type:%x\n", err_type);
+	//	status = -EOVERFLOW;
+	//	reset = ENDPRST_FIFORST | ENDPRST_TOGRST;
+	}
+
+	if (!(acthcd->port & USB_PORT_STAT_ENABLE)
+			|| (acthcd->port & (USB_PORT_STAT_C_CONNECTION << 16))
+			|| (acthcd->hcd_exiting != 0)
+			|| (acthcd->inserted == 0)
+    		|| !HC_IS_RUNNING(hcd->state)) {
+		dev_err(acthcd->dev, "usbport, dead, port:%x, hcd_exiting:%d \n", acthcd->port, acthcd->hcd_exiting);
+		status = -ENODEV;
+	}
+
+	if (ep->index == 0) {
+		q = ep->q;
+		urb = q->urb;
+		if ((status == -EPIPE) || (status == -ENODEV)) 
+			writeb(HCINxERR_RESEND, ep->reg_hcerr);  /* resend. */
+		finish_request(acthcd, q, status);
+		dev_info(acthcd->dev, "%s ep %d error [0x%02X] error type [0x%02X], reset it...\n",
+			    usb_pipeout(urb->pipe)?"HC OUT":"HC IN", ep->index, err_val, (err_val>>2)&0x7);
+	} else {
+		if ((status != -EPIPE) && (status != -ENODEV)) {
+			printk("td->err_count:%d\n", td->err_count);
+			td->err_count++;
+			
+			if (td->err_count < MAX_ERROR_COUNT) {				
+				writeb(HCINxERR_RESEND, ep->reg_hcerr);  /* resend. */
+				return;
+			}		
+		}
+			if (status == -ETIMEDOUT || status == -EPIPE) {
+					ep->error_count++;
+		}
+		
+		reset = ENDPRST_FIFORST | ENDPRST_TOGRST;
+		ep_disable(ep);
+		if (is_in) {
+			aotg_hcep_reset(acthcd, ep->mask, reset);
+		} else {
+			aotg_hcep_reset(acthcd, ep->mask | USB_HCD_OUT_MASK, reset);
+		}
+		
+		/*if (usb_pipeout(urb->pipe)) {
+			aotg_hcep_reset(acthcd, ep->mask | USB_HCD_OUT_MASK, reset);
+		} else {
+			aotg_hcep_reset(acthcd, ep->mask, reset);
+		}*/
+		
+		aotg_stop_ring(ring);
+		urb = td->urb;
+		//writel(DMACTRL_DMACC,ep->ring->reg_dmactrl);
+		if (ep->type == PIPE_INTERRUPT)
+			dequeue_intr_td(ring, td);
+		else
+			dequeue_td(ring, td, TD_IN_FINISH);
+		
+		if (urb) {
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			usb_hcd_giveback_urb(hcd, urb, status);
+		}
+		else
+		{
+			ERR("urb not exist!\n");
+		}
+
+		/*
+		 * after, need to rewrite port_num, dev_addr when using hub ?
+		 */
+		/*if ((urb) && (!list_empty(&ep->enring_td_list)) &&
+				!is_ring_running(ring)) {
+			ACT_HCD_DBG
+			ep_enable(ep);	
+			addr = ring_trb_virt_to_dma(ring, ring->dequeue_trb);
+			aotg_start_ring(ring, addr);
+		}*/
+		dev_info(acthcd->dev, "%s ep %d error [0x%02X] error type [0x%02X], reset it...\n",
+			    is_in?"HC IN":"HC OUT", ep->index, err_val, (err_val>>2)&0x7);
+	}
+	
+	return;
+}
+#if 0
+static void aotg_hcd_error(struct aotg_hcd *acthcd, u32 irqvector, int ep_num, int is_in)
+{
+	struct aotg_queue *q;
+	struct aotg_hcep *ep = NULL;
+	struct urb *urb;
+	int status;
+	u8 error = 0;
+	u8 reset = 0;
+	struct usb_hcd *hcd = aotg_to_hcd(acthcd);
+
+	printk("hcd ep err ep_num:%d, is_in:%d\n", ep_num, is_in);
+
+	if (ep_num == 0) {
+		ep = acthcd->active_ep0;
+		if (ep == NULL) {
+			ACT_HCD_ERR
+			return;
+		}
+		q = ep->q;
+		if (is_in) {
+			ep->reg_hcerr = acthcd->base + HCIN0ERR;
+		} else {
+			ep->reg_hcerr = acthcd->base + HCOUT0ERR;
+		}
+	} else {
+		if (is_in) {
+			ep = acthcd->inep[ep_num];
+		} else {
+			ep = acthcd->outep[ep_num];
+		}
+		if (ep == NULL) {
+			ACT_HCD_ERR
+			printk("is_in:%d, ep_num:%d\n", is_in, ep_num);
+			return;
+		}
+		q = ep->q;
+	}
+
+	if (is_in) {
+		writew(1 << ep_num, acthcd->base + HCINxERRIRQ0);
+	} else {
+		writew(1 << ep_num, acthcd->base + HCOUTxERRIRQ0);
+	}
+	error = readb(ep->reg_hcerr);
+
+	if (q) {
+		urb = q->urb;
+
+		switch (error & HCINxERR_TYPE_MASK) {
+		case HCINxERR_NO_ERR:
+			status = 0;
+			break;
+		
+		case HCINxERR_STALL:
+			status = -EPIPE;
+			reset = ENDPRST_FIFORST | ENDPRST_TOGRST;
+			break;
+		
+		case HCINxERR_TIMEOUT:
+			status = -ETIMEDOUT;
+			reset = ENDPRST_FIFORST | ENDPRST_TOGRST;
+			break;
+
+		default:
+			printk("error:%x\n", ((error & HCINxERR_TYPE_MASK) >> 2));
+			status = -EIO;
+			reset = ENDPRST_FIFORST | ENDPRST_TOGRST;
+		}
+
+		if (!(acthcd->port & USB_PORT_STAT_ENABLE)
+			|| (acthcd->port & (USB_PORT_STAT_C_CONNECTION << 16))
+			|| (acthcd->hcd_exiting != 0)
+			|| (acthcd->inserted == 0)
+	    		|| !HC_IS_RUNNING(hcd->state)) {
+			dev_err(acthcd->dev, "usbport, dead, port:%x, hcd_exiting:%d \n", acthcd->port, acthcd->hcd_exiting);
+			status = -ENODEV;
+		}
+
+		if (status < 0) {
+			ACT_HCD_DBG
+			printk("status:%d\n", status);
+
+			if (ep->index > 0 && (status != -EPIPE) && (status != -ENODEV)) {
+				printk("q->err_count:%d\n", q->err_count);
+				q->err_count++;
+				writeb(HCINxERR_RESEND, ep->reg_hcerr);  /* resend. */
+
+				if ((q->err_count % MAX_ERROR_COUNT) < (MAX_ERROR_COUNT - 1)) {
+					return;
+				}
+				if (q->err_count > MAX_ERROR_COUNT * 3) {
+					ACT_HCD_DBG
+					q->err_count = 0;
+					acthcd->discon_happened = 1;
+					mod_timer(&acthcd->hotplug_timer, jiffies + msecs_to_jiffies(1));
+					return;
+				}
+			}
+
+			if ((ep->index == 0) && ((status == -EPIPE) || (status == -ENODEV))) {
+				writeb(HCINxERR_RESEND, ep->reg_hcerr);  /* resend. */
+			}
+
+			if (ep->index > 0) {
+				if (usb_pipeout(urb->pipe)) {
+					aotg_hcep_reset(acthcd, ep->mask | USB_HCD_OUT_MASK, reset);
+				} else {
+					ep_disable(ep);
+					aotg_hcep_reset(acthcd, ep->mask, reset);
+				}
+			}
+			dev_info(acthcd->dev, "%s ep %d error [0x%02X] error type [0x%02X], reset it...\n",
+				    usb_pipeout(urb->pipe)?"HC OUT":"HC IN", ep->index, error, (error>>2)&0x7);
+#if 0
+			if (AOTG_GET_DMA_NUM(q->dma_no)) {
+				ACT_HCD_DBG
+				__clear_dma(acthcd, q);
+			}
+#endif
+			finish_request(acthcd, q, status);
+		}
+	}
+	tasklet_hi_schedule(&acthcd->urb_tasklet);
+
+	return;
+}
+#endif 
+
+void aotg_hcd_abort_urb(struct aotg_hcd *acthcd)
+{
+	int cnt;
+	struct aotg_hcep *ep;
+	struct urb *urb;
+	struct aotg_ring *ring;
+	struct aotg_td *td;
+	unsigned long flags;
+//	struct aotg_queue *q;
+	struct usb_hcd *hcd = aotg_to_hcd(acthcd);
+	
+/*	if (HC_IS_SUSPENDED(hcd->state)) {
+		usb_hcd_resume_root_hub(hcd);
+	}
+		//ACT_HCD_DBG
+		//aotg_hcd_flush_queue(acthcd);
+	usb_hcd_poll_rh_status(hcd);*/
+	
+	spin_lock_irqsave(&acthcd->lock, flags);
+	/*ep = acthcd->active_ep0;
+	if (ep && ep->q) {
+		q = ep->q;
+		urb = q->urb;
+		q->status = -ENODEV;
+		//printk("%s in ep 0\n",__func__);
+		aotg_hcd_release_queue(acthcd, q);
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		spin_unlock(&acthcd->lock);
+		usb_hcd_giveback_urb(hcd, urb, -ENODEV);
+		spin_lock(&acthcd->lock);
+	}*/
+	
+	for (cnt=1; cnt<MAX_EP_NUM; cnt++) {
+		ep = acthcd->inep[cnt];
+		if (ep) {
+			ring = ep->ring;
+			td = list_first_entry_or_null(&ep->enring_td_list, struct aotg_td, enring_list);
+			if (!td)
+				continue;
+			urb = td->urb;
+			if (!urb)
+				continue;
+			if (ep->type == PIPE_INTERRUPT)
+				dequeue_intr_td(ring, td);
+			else
+				dequeue_td(ring, td, TD_IN_FINISH);
+			//printk("%s in ep %d\n",__func__,cnt);
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			spin_unlock(&acthcd->lock);
+			usb_hcd_giveback_urb(hcd, urb, -ENODEV);
+			spin_lock(&acthcd->lock);
+		}
+	}
+	
+	for (cnt=1; cnt<MAX_EP_NUM; cnt++) {
+		ep = acthcd->outep[cnt];
+		if (ep) {
+			ring = ep->ring;
+			td = list_first_entry_or_null(&ep->enring_td_list, struct aotg_td, enring_list);
+			if (!td)
+				continue;
+			urb = td->urb;
+			if (!urb)
+				continue;
+			if (ep->type == PIPE_INTERRUPT)
+				dequeue_intr_td(ring, td);
+			else
+				dequeue_td(ring, td, TD_IN_FINISH);
+			//printk("%s out ep %d\n",__func__,cnt);
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			spin_unlock(&acthcd->lock);
+			usb_hcd_giveback_urb(hcd, urb, -ENODEV);
+			spin_lock(&acthcd->lock);
+		}
+	}
+	
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+}
+
+static irqreturn_t aotg_hub_irq(struct usb_hcd *hcd)
+{
+	struct platform_device *pdev;
+	unsigned int port_no;
+	u32 irqvector;
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	u8 eirq_mask = readb(acthcd->base + USBEIEN);
+	u8 eirq_pending = readb(acthcd->base + USBEIRQ);
+	u8 otg_state;
+
+	/* take cate to use lock, because in irq -> dma_handler -> finish_request -> 
+	 * usb_hcd_giveback_urb -> urb->complete(), it maybe call enqueue and get spin_lock again.
+	 */
+	//spin_lock(&acthcd->lock);
+	pdev = to_platform_device(hcd->self.controller);
+	port_no = pdev->id & 0xff;
+#if(0)
+	int i = 0;
+	irqvector = (u32)readb(acthcd->base + IVECT);
+	printk("USBEIEN:0x%x, USBEIRQ:0x%x, ivec:0x%x\n", readb(acthcd->base + USBEIEN),
+			readb(acthcd->base + USBEIRQ), irqvector);
+	printk("HCINxDMAIRQ0:0x%x, HCOUTxDMAIRQ0:0x%x\n",
+		readw(acthcd->base + HCINxDMAIRQ0),
+		readw(acthcd->base + HCOUTxDMAIRQ0));
+	for (i = 0; i <= 0x1d; i++) {
+		printk("0x%p : 0x%x\n", acthcd->base + 0x500 + i,
+			readb(acthcd->base + 0x500 + i));
+	}
+#endif
+
+	if (eirq_pending & USBEIRQ_USBIRQ) {
+		irqvector = (u32)readb(acthcd->base + IVECT);
+		writeb(eirq_mask | USBEIRQ_USBIRQ, acthcd->base + USBEIRQ);
+//		HUB_DEBUG("irqvector:%d, 0x%x\n", irqvector, irqvector);
+
+		switch (irqvector) {
+		//case UIV_OTGIRQ:
+		case UIV_IDLE:
+		case UIV_SRPDET:
+		case UIV_LOCSOF:
+		case UIV_VBUSERR:
+		case UIV_PERIPH:
+			if (readb(acthcd->base + OTGIRQ) & (0x1<<2)) {
+				writeb(0x1<<2, acthcd->base + OTGIRQ);
+				otg_state = readb(acthcd->base + OTGSTATE);
+
+				printk("port_no:%d OTG IRQ, OTGSTATE: 0x%02X, USBIRQ:0x%02X\n", 
+					port_no, otg_state,
+					readb(acthcd->base + USBIRQ));
+
+				if (otg_state == 0x4) {
+					return IRQ_HANDLED;
+				}
+				
+				if ((otg_state == 0x02) && port_host_plug_detect[acthcd->id]) {
+					aotg_disable_irq(acthcd);
+					acthcd->hcd_exiting = 1;
+					aotg_hcd_abort_urb(acthcd);
+					aotg_dev_plugout_msg(acthcd->id);
+					return IRQ_HANDLED;
+				}
+				acthcd->put_aout_msg = 0;
+				if (otg_state == AOTG_STATE_A_HOST) {
+					/*if (acthcd->inserted != 0) {
+						acthcd->discon_happened = 1;
+					}*/
+
+					//if (acthcd->port & (USB_PORT_STAT_C_CONNECTION << 16)) {
+					//	mod_timer(&acthcd->hotplug_timer, jiffies + msecs_to_jiffies(1000));
+					//} else {
+						if (acthcd->discon_happened == 1) {
+							mod_timer(&acthcd->hotplug_timer, jiffies + msecs_to_jiffies(500));
+						} else {
+							mod_timer(&acthcd->hotplug_timer, jiffies + msecs_to_jiffies(1));
+						}
+					//}
+				} else {
+					acthcd->discon_happened = 1;
+					mod_timer(&acthcd->hotplug_timer, jiffies + msecs_to_jiffies(1));
+				}
+			} else {
+				printk("port_no:%d error OTG irq! OTGIRQ: 0x%02X\n", 
+					port_no, readb(acthcd->base + OTGIRQ));
+			}
+			break;
+		case UIV_SOF:
+			writeb(USBIRQ_SOF, acthcd->base + USBIRQ);
+#if 0
+			{
+				u16 index;
+				struct aotg_hcep *ep;
+	
+				index = acthcd->frame;
+				ep = acthcd->periodic[index];
+				aotg_hcd_period_transfer(acthcd, ep);
+	
+				acthcd->frame++;
+				acthcd->frame = acthcd->frame % PERIODIC_SIZE;
+			}
+#endif
+			break;
+		case UIV_USBRESET:
+			if (acthcd->port & (USB_PORT_STAT_POWER | USB_PORT_STAT_CONNECTION)) {
+				acthcd->speed = USB_SPEED_FULL;	/*FS is the default */
+				acthcd->port |= (USB_PORT_STAT_C_RESET << 16);
+				acthcd->port &= ~USB_PORT_STAT_RESET;
+
+				/*clear usb reset irq */
+				writeb(USBIRQ_URES, acthcd->base + USBIRQ); 
+	
+				/*reset all ep-in */
+				aotg_hcep_reset(acthcd, USB_HCD_IN_MASK,
+						ENDPRST_FIFORST | ENDPRST_TOGRST);
+				/*reset all ep-out */
+				aotg_hcep_reset(acthcd, USB_HCD_OUT_MASK,
+						ENDPRST_FIFORST | ENDPRST_TOGRST);
+	
+				acthcd->port |= USB_PORT_STAT_ENABLE;
+				acthcd->rhstate = AOTG_RH_ENABLE;
+				/*now root port is enabled fully */
+				if (readb(acthcd->base + USBCS) & USBCS_HFMODE) {
+					acthcd->speed = USB_SPEED_HIGH;
+					acthcd->port |= USB_PORT_STAT_HIGH_SPEED;
+					writeb(USBIRQ_HS, acthcd->base + USBIRQ);
+					HCD_DEBUG("%s: USB device is  HS\n", __func__);
+				} else if (readb(acthcd->base + USBCS) & USBCS_LSMODE) {
+					acthcd->speed = USB_SPEED_LOW;
+					acthcd->port |= USB_PORT_STAT_LOW_SPEED;
+					HCD_DEBUG("%s: USB device is  LS\n", __func__);
+				} else {
+					acthcd->speed = USB_SPEED_FULL;
+					HCD_DEBUG("%s: USB device is  FS\n", __func__);
+				}
+	
+				/*usb_clearbitsb(USBIEN_URES,USBIEN);*/ /*disable reset irq */
+				/*khu del for must enable USBIEN_URES again*/
+				writew(0xffff, acthcd->base + HCINxERRIRQ0);
+				writew(0xffff, acthcd->base + HCOUTxERRIRQ0);
+
+				writew(0xffff, acthcd->base + HCINxIRQ0);
+				writew(0xffff, acthcd->base + HCOUTxIRQ0);
+	
+				writew(0xffff, acthcd->base + HCINxERRIEN0);
+				writew(0xffff, acthcd->base + HCOUTxERRIEN0);
+	
+				HCD_DEBUG("%s: USB reset end\n", __func__);
+			}
+			break;
+	
+		case UIV_EP0IN:
+			writew(1, acthcd->base + HCOUTxIRQ0);	/*clear hcep0out irq */
+			handle_hcep0_out(acthcd);
+			break;
+		case UIV_EP0OUT:
+			writew(1, acthcd->base + HCINxIRQ0);	/*clear hcep0in irq */
+			handle_hcep0_in(acthcd);
+			break;
+		case UIV_EP1IN:
+			ACT_HCD_DBG
+			writew(1<<1, acthcd->base + HCOUTxIRQ0);	/*clear hcep1out irq */
+			break;
+		case UIV_EP1OUT:
+			ACT_HCD_DBG
+			writeb(1<<1, acthcd->base + HCINxIRQ0);	/*clear hcep1in irq */
+			break;
+		case UIV_EP2IN:
+			ACT_HCD_DBG
+			writew(1<<2, acthcd->base + HCOUTxIRQ0);	/*clear hcep2out irq */
+			break;
+		case UIV_EP2OUT:
+			ACT_HCD_DBG
+			writeb(1<<2, acthcd->base + HCINxIRQ0);	/*clear hcep2in irq */
+			break;
+
+		default:
+			if ((irqvector >= UIV_HCOUT0ERR) && (irqvector <= UIV_HCOUT15ERR)) {
+				printk("irqvector:%d, 0x%x\n", irqvector, irqvector);
+				aotg_hcd_err_handle(acthcd, irqvector, (irqvector - UIV_HCOUT0ERR), 0);
+				break;
+			}
+			if ((irqvector >= UIV_HCIN0ERR) && (irqvector <= UIV_HCIN15ERR)) {				
+				printk("irqvector:%d, 0x%x\n", irqvector, irqvector);
+				aotg_hcd_err_handle(acthcd, irqvector, (irqvector - UIV_HCIN0ERR), 1);
+				break;
+			}
+			dev_err(acthcd->dev, "error interrupt, pls check it! irqvector: 0x%02X\n", (u8)irqvector);
+			//spin_unlock(&acthcd->lock);
+			return IRQ_NONE;
+		}
+	}
+
+	//writeb(readb(acthcd->base + 0x518), acthcd->base + 0x518);
+
+	
+	aotg_clear_all_overflow_irq(acthcd);
+	aotg_clear_all_shortpkt_irq(acthcd);
+	aotg_clear_all_zeropkt_irq(acthcd);
+	aotg_clear_all_hcoutdma_irq(acthcd);
+	aotg_ring_irq_handler(acthcd);
+
+	//ACT_HCD_DBG
+	//spin_unlock(&acthcd->lock);
+	//printk("%s,(0x%p : 0x%x)\n",__FUNCTION__, acthcd->base + HCINxDMAIRQ0,
+	   //readw(acthcd->base + HCINxDMAIRQ0));
+	return IRQ_HANDLED;
+}
+
+void aotg_hub_hotplug_timer(unsigned long data)
+{
+	struct aotg_hcd *acthcd = (struct aotg_hcd *)data;
+	struct usb_hcd *hcd = aotg_to_hcd(acthcd);
+	struct platform_device *pdev;
+	unsigned int port_no;
+	unsigned long flags;
+	int connect_changed = 0;
+
+	//if ((void *)data == (void *)NULL) 
+	if (unlikely(IS_ERR_OR_NULL((void *)data))) {
+		ACT_HCD_DBG
+		return;
+	}
+	if (acthcd->hcd_exiting != 0) {
+		ACT_HCD_DBG
+		return;
+	}
+
+	//disable_irq_nosync(acthcd->uhc_irq);
+	disable_irq(acthcd->uhc_irq);
+	spin_lock_irqsave(&acthcd->lock, flags);
+
+	if (acthcd->put_aout_msg != 0) {
+		pdev = to_platform_device(hcd->self.controller);
+		port_no = pdev->id & 0xff;
+		ACT_HCD_DBG
+		//update_driver_state(UPDATE_UDEVICE_OUT, port_no);
+		acthcd->put_aout_msg = 0;
+		spin_unlock_irqrestore(&acthcd->lock, flags);
+		enable_irq(acthcd->uhc_irq);
+		aotg_hub_notify_hcd_exit(0);
+		return;
+	}
+	
+	if ((readb(acthcd->base + OTGSTATE) == AOTG_STATE_A_HOST) && (acthcd->discon_happened == 0)) {
+		if (!acthcd->inserted) {
+			acthcd->port |= (USB_PORT_STAT_C_CONNECTION << 16);
+			/*set port status bit,and indicate the present of  a device */
+			acthcd->port |= USB_PORT_STAT_CONNECTION;
+			acthcd->rhstate = AOTG_RH_ATTACHED;
+			acthcd->inserted = 1;
+			connect_changed = 1;
+		}
+	} else {
+		if (acthcd->inserted) {
+			acthcd->port &= ~(USB_PORT_STAT_CONNECTION |
+					  USB_PORT_STAT_ENABLE |
+					  USB_PORT_STAT_LOW_SPEED |
+					  USB_PORT_STAT_HIGH_SPEED | USB_PORT_STAT_SUSPEND);
+			acthcd->port |= (USB_PORT_STAT_C_CONNECTION << 16);
+			acthcd->rhstate = AOTG_RH_NOATTACHED;
+			acthcd->inserted = 0;
+			connect_changed = 1;
+		}
+		if (acthcd->discon_happened == 1) {
+			acthcd->discon_happened = 0;
+
+			if (readb(acthcd->base + OTGSTATE) == AOTG_STATE_A_HOST) {
+				mod_timer(&acthcd->hotplug_timer, jiffies + msecs_to_jiffies(1000));
+			}
+		}
+	}
+
+	dev_info(acthcd->dev, "<USB> %s connection changed: %d, acthcd->inserted: %d\n", 
+			dev_name(hcd->self.controller), connect_changed, acthcd->inserted);
+	if (connect_changed) {
+		if (HC_IS_SUSPENDED(hcd->state)) {
+			usb_hcd_resume_root_hub(hcd);
+		}
+		ACT_HCD_DBG
+		//aotg_hcd_flush_queue(acthcd);
+		usb_hcd_poll_rh_status(hcd);
+	}
+
+	if ((acthcd->inserted == 0) && (connect_changed	== 1) && 
+	    (readb(acthcd->base + OTGSTATE) != AOTG_STATE_A_HOST)) {
+		acthcd->put_aout_msg = 1;
+		mod_timer(&acthcd->hotplug_timer, jiffies + msecs_to_jiffies(2200));
+	}
+	acthcd->suspend_request_pend = 0;
+
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	enable_irq(acthcd->uhc_irq);
+	return;
+}
+
+static inline int aotg_print_ep_timeout(struct aotg_hcep *ep)
+{
+	int ret = 0;
+
+	if (ep == NULL) {
+		return ret;
+	}
+	if (ep->q != NULL) {
+		if (ep->q->timeout == 0)
+			return ret;
+
+		if (time_after(jiffies, ep->q->timeout)) {
+			ret = 1;
+			printk("ep->index:%x ep->mask:%x\n", ep->index, ep->mask);
+			printk("timeout:0x%x!\n", (unsigned int)ep->q->timeout);
+			ep->q->timeout = jiffies + HZ;
+		}
+	}
+	return ret;
+}
+
+void aotg_check_trb_timer(unsigned long data)
+{
+	unsigned long flags;
+	struct aotg_hcep *ep;
+	int i;
+	struct aotg_hcd *acthcd = (struct aotg_hcd *)data;
+
+	if (unlikely(IS_ERR_OR_NULL((void *)data))) {
+		ACT_HCD_DBG
+		return;
+	}
+	if (acthcd->hcd_exiting != 0) {
+		ACT_HCD_DBG
+		return;
+	}
+
+	spin_lock_irqsave(&acthcd->lock, flags);
+	if (acthcd->check_trb_mutex) {
+		mod_timer(&acthcd->check_trb_timer, jiffies + msecs_to_jiffies(1));
+		spin_unlock_irqrestore(&acthcd->lock, flags);
+		return;
+	}
+
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		ep = acthcd->inep[i];
+		if (ep && (ep->ring) && (ep->ring->type == PIPE_BULK))
+				handle_ring_dma_tx(acthcd,i);
+	}
+
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		ep = acthcd->outep[i];
+		if (ep && (ep->ring) && (ep->ring->type == PIPE_BULK))
+			handle_ring_dma_tx(acthcd,i | AOTG_DMA_OUT_PREFIX);
+	}
+
+	mod_timer(&acthcd->check_trb_timer, jiffies + msecs_to_jiffies(3));
+
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	return;
+}
+
+void aotg_hub_trans_wait_timer(unsigned long data)
+{
+	unsigned long flags;
+	struct aotg_hcep *ep;
+	int i, ret;
+	struct aotg_hcd *acthcd = (struct aotg_hcd *)data;
+
+	if (unlikely(IS_ERR_OR_NULL((void *)data))) {
+		ACT_HCD_DBG
+		return;
+	}
+	if (acthcd->hcd_exiting != 0) {
+		ACT_HCD_DBG
+		return;
+	}
+
+	//disable_irq_nosync(acthcd->uhc_irq);
+	disable_irq(acthcd->uhc_irq);
+	spin_lock_irqsave(&acthcd->lock, flags);
+
+	ep = acthcd->active_ep0;
+	ret = aotg_print_ep_timeout(ep);
+
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		ep = acthcd->inep[i];
+		ret |= aotg_print_ep_timeout(ep);
+	}
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		ep = acthcd->outep[i];
+		if (ep == NULL) {
+			continue;
+		}
+		ret |= aotg_print_ep_timeout(ep);
+
+		if (ep->fifo_busy) {
+			if ((ep->fifo_busy > 80) && (ep->fifo_busy % 80 == 0))  {
+				printk("ep->fifo_busy:%d\n", ep->fifo_busy);
+			}
+			if (ret == 0) {
+				tasklet_hi_schedule(&acthcd->urb_tasklet);
+				break;
+			}
+		}
+	}
+
+	if (ret != 0) {
+		tasklet_hi_schedule(&acthcd->urb_tasklet);
+	}
+	mod_timer(&acthcd->trans_wait_timer, jiffies + msecs_to_jiffies(500));
+
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	enable_irq(acthcd->uhc_irq);
+	return;
+}
+//FIXME
+static inline int start_transfer(struct aotg_hcd *acthcd, struct aotg_queue *q, struct aotg_hcep *ep)
+{
+	struct urb *urb = q->urb;
+	int retval = 0;
+
+	ep->urb_enque_cnt++;
+	q->length = urb->transfer_buffer_length;
+
+	/* do with hub connected. */
+	if (ep->has_hub) {
+		if (urb->dev->speed == USB_SPEED_HIGH) {
+			writeb(usb_pipedevice(urb->pipe), ep->reg_hcep_dev_addr);
+			writeb(urb->dev->portnum, ep->reg_hcep_port);
+		} else {
+			writeb((0x80 | usb_pipedevice(urb->pipe)), ep->reg_hcep_dev_addr);
+			if (urb->dev->speed == USB_SPEED_LOW) {
+				writeb(0x80 | urb->dev->portnum, ep->reg_hcep_port);
+			} else {
+				writeb(urb->dev->portnum, ep->reg_hcep_port);
+			}
+		}
+		//writeb(0, ep->reg_hcep_splitcs);
+	} else {
+		writeb(usb_pipedevice(urb->pipe), ep->reg_hcep_dev_addr);
+		writeb(urb->dev->portnum, ep->reg_hcep_port);
+	}
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_CONTROL:
+		q->timeout = jiffies + HZ/2;
+		retval = handle_setup_packet(acthcd, q);
+		break;
+
+	default:
+		printk(KERN_ERR"%s err, check it pls!\n", __FUNCTION__);
+	}
+
+	return retval;
+}
+
+#if 0
+#define USB_CLASS_PER_INTERFACE		0	/* for DeviceClass */
+#define USB_CLASS_AUDIO			1
+#define USB_CLASS_COMM			2
+#define USB_CLASS_HID			3
+#define USB_CLASS_PHYSICAL		5
+#define USB_CLASS_STILL_IMAGE		6
+#define USB_CLASS_PRINTER		7
+#define USB_CLASS_MASS_STORAGE		8
+#define USB_CLASS_HUB			9
+#define USB_CLASS_CDC_DATA		0x0a
+#define USB_CLASS_CSCID			0x0b	/* chip+ smart card */
+#define USB_CLASS_CONTENT_SEC		0x0d	/* content security */
+#define USB_CLASS_VIDEO			0x0e
+#define USB_CLASS_WIRELESS_CONTROLLER	0xe0
+#define USB_CLASS_MISC			0xef
+#define USB_CLASS_APP_SPEC		0xfe
+#define USB_CLASS_VENDOR_SPEC		0xff
+#endif
+/*
+static void aotg_hcd_dump_isoc_packet(struct urb *urb)
+{
+	int i;
+	int number_of_packets;
+	u32 start_addr, addr;
+	unsigned int len;
+	
+	number_of_packets = urb->number_of_packets;
+	start_addr = (u32)urb->transfer_dma;
+
+	printk("----dump iso_packets( addr--len )----\n");
+	for (i = 0; i < number_of_packets; i++) {
+		addr = start_addr + urb->iso_frame_desc[i].offset;
+		len = urb->iso_frame_desc[i].length;
+		printk("packet%d : %u, %d\n", i, addr, len);
+	}
+	return;
+}
+*/
+static struct aotg_hcep	*aotg_hcep_alloc(struct usb_hcd *hcd, struct urb *urb)
+{
+	struct aotg_hcep *ep = NULL;
+	int pipe = urb->pipe;
+	int is_out = usb_pipeout(pipe);
+	int type = usb_pipetype(pipe);
+	int i, retval = 0;
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	u8 think_time;
+
+	ep = kzalloc(sizeof	*ep, GFP_ATOMIC);
+	if (NULL == ep)	{
+		dev_err(acthcd->dev, "alloc	ep failed\n");
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	ep->udev = usb_get_dev(urb->dev);
+	ep->epnum = usb_pipeendpoint(pipe);
+	ep->maxpacket = usb_maxpacket(ep->udev, urb->pipe, is_out);
+	ep->type = type;
+	ep->urb_enque_cnt = 0;
+	ep->urb_endque_cnt = 0;
+	ep->urb_stop_stran_cnt = 0;
+	ep->urb_unlinked_cnt = 0;
+#ifdef USBH_DEBUG
+	dev_info(acthcd->dev, "ep->epnum: %d, ep->maxpacket : %d, ep->type : %d\n", ep->epnum, ep->maxpacket, ep->type);
+#endif
+	ep->length = 0;
+	usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), is_out, 0);
+
+	if (urb->dev->parent) {
+		if (urb->dev->tt) {
+			/* calculate in ns. */
+			think_time = (urb->dev->tt->think_time / 666);
+			printk("think_time:%d\n", think_time);
+			if (think_time <= 0) {
+				think_time = 1;
+			} else if (think_time > 4) {
+				think_time = 4;
+			}
+			think_time = think_time * 20;
+			writeb(think_time, acthcd->base + HCTRAINTERVAL);
+			printk("think_time:0x%x\n", readb(acthcd->base + HCTRAINTERVAL));
+			//printk("urb->dev->tt->hub:%p \n", urb->dev->tt->hub);
+		}
+
+		if ((urb->dev->parent->parent) && (urb->dev->parent != hcd->self.root_hub)) {
+			ep->has_hub = 1;
+			ep->hub_addr = 0x7f & readb(acthcd->base + FNADDR);
+		} else {
+			ep->has_hub = 0;
+		}
+	}
+
+	switch (type) {
+	case PIPE_CONTROL:
+		ep->reg_hcep_dev_addr = acthcd->base + HCEP0ADDR;
+		ep->reg_hcep_port = acthcd->base + HCEP0PORT;
+		ep->reg_hcep_splitcs = acthcd->base + HCEP0SPILITCS;
+
+		for (i = 0; i < MAX_EP_NUM; i++) {
+			if (acthcd->ep0[i] == NULL) {
+				ep->ep0_index = i;
+				acthcd->ep0[i] = ep;
+				break;
+			}
+		}
+		if (i == MAX_EP_NUM) {
+			ACT_HCD_ERR
+		}
+
+		ep->index = 0;
+		ep->mask = 0;
+		usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), 1, 0);
+		usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), 0, 0);
+
+		if (acthcd->active_ep0 == NULL) {
+			//writeb(ep->epnum, acthcd->base + HCEP0CTRL);
+			//writeb((u8)ep->maxpacket, acthcd->base + HCIN0MAXPCK);
+			//writeb((u8)ep->maxpacket, acthcd->base + HCOUT0MAXPCK);
+			usb_setbitsw(1, acthcd->base + HCOUTxIEN0);
+			usb_setbitsw(1, acthcd->base + HCINxIEN0);
+			writew(1, acthcd->base + HCOUTxIRQ0);
+			writew(1, acthcd->base + HCINxIRQ0);
+
+			if (ep->has_hub) {
+				usb_setbitsb(0x80, acthcd->base + FNADDR);
+			} else {
+				writeb(usb_pipedevice(urb->pipe), acthcd->base + FNADDR);
+			}
+			dev_info(acthcd->dev, "device addr : 0x%08x\n", readb(acthcd->base + FNADDR));
+		} else {
+			ACT_HCD_ERR
+		}
+		break;
+
+	case PIPE_BULK:
+		retval = aotg_hcep_config(acthcd, ep, EPCON_TYPE_BULK, EPCON_BUF_SINGLE, is_out);
+		if (retval < 0) {
+			dev_err(acthcd->dev, "PIPE_BULK, retval: %d\n", retval);
+			kfree(ep);
+			goto exit;
+		}
+		break;
+
+	case PIPE_INTERRUPT:
+		retval = aotg_hcep_config(acthcd, ep, EPCON_TYPE_INT, EPCON_BUF_SINGLE, is_out);
+		if (retval < 0) {
+			dev_err(acthcd->dev, "PIPE_INTERRUPT, retval: %d\n", retval);
+			kfree(ep);
+			goto exit;
+		}
+		ep->interval= urb->ep->desc.bInterval;
+		writeb(ep->interval, ep->reg_hcep_interval);		
+		//printk("urb->interval: %d\n", urb->interval);
+		//printk("urb->ep->desc.bInterval: %d, reg_interval:0x%x\n", 
+		//		urb->ep->desc.bInterval, readb(ep->reg_hcep_interval));
+		
+		break;
+
+	case PIPE_ISOCHRONOUS:
+		retval = aotg_hcep_config_iso(acthcd, ep, EPCON_TYPE_ISO, EPCON_BUF_SINGLE, is_out);
+		ep->iso_packets = (urb->ep->desc.wMaxPacketSize >> 11) & 3;
+		ep->interval = urb->ep->desc.bInterval;
+		writeb(ep->interval, ep->reg_hcep_interval);
+		usb_setb(ep->iso_packets << 4, ep->reg_hcepcon);
+		printk("iso_packets:%d, bInterval:%d, urb_interval:%d, reg_con:0x%x\n",
+					ep->iso_packets, ep->interval, urb->interval, readb(ep->reg_hcepcon));				
+		break;
+
+	default:
+		dev_err(acthcd->dev, "not support type, type: %d\n", type);
+		retval = -ENODEV;
+		kfree(ep);
+		goto exit;
+	}
+
+	if ((ep->udev->speed != USB_SPEED_HIGH) && ep->has_hub && (type == PIPE_INTERRUPT)) {
+		aotg_hcep_set_split_micro_frame(acthcd, ep);
+	}
+	ep->hep = urb->ep;
+	urb->ep->hcpriv = ep;
+	return ep;
+
+exit:
+	return NULL;
+}
+
+static int aotg_hub_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, unsigned mem_flags)
+{
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	struct aotg_queue *q=NULL;
+	unsigned long flags;
+	struct aotg_hcep *ep = NULL;
+	struct aotg_td *td, *next; 
+	int pipe = urb->pipe;
+	int type = usb_pipetype(pipe);
+	int retval = 0;
+	
+	if ((acthcd == NULL) || (act_hcd_ptr[acthcd->id] == NULL)) {
+		printk("aotg_hcd device had been removed...\n");
+		return -EIO;
+	}
+
+	if (acthcd->hcd_exiting != 0) {
+		dev_dbg(acthcd->dev, "aotg hcd exiting! type:%d\n", type);
+		return -ENODEV;
+	}
+
+	if (!(acthcd->port & USB_PORT_STAT_ENABLE)
+		|| (acthcd->port & (USB_PORT_STAT_C_CONNECTION << 16))
+		|| (acthcd->hcd_exiting != 0)
+		|| (acthcd->inserted == 0)
+	    	|| !HC_IS_RUNNING(hcd->state)) {
+		dev_err(acthcd->dev, "usbport dead or disable\n");
+		return -ENODEV;
+	}
+
+	spin_lock_irqsave(&acthcd->lock, flags);
+	
+	ep = urb->ep->hcpriv;
+	if ((unlikely(!urb->ep->enabled)) || (likely(ep) && unlikely(ep->error_count > 3))) {
+		printk("ep had been stopped!\n");
+		//spin_unlock_irqrestore(&acthcd->lock, flags);
+		//ep = (struct aotg_hcep *)urb->ep->hcpriv;
+		retval = -ENOENT;
+		goto exit0;
+	}
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval) {
+		dev_err(acthcd->dev, "<QUEUE>  usb_hcd_link_urb_to_ep error!! retval:0x%x\n",retval);
+		goto exit0;
+	}
+
+	if (likely(urb->ep->hcpriv)) {
+		ep = (struct aotg_hcep *)urb->ep->hcpriv;
+	} else {
+		ep = aotg_hcep_alloc(hcd, urb);
+		if (NULL == ep) {
+			dev_err(acthcd->dev, "<QUEUE> alloc ep failed\n");
+			retval = -ENOMEM;
+			goto exit1;
+		}
+		if (!usb_pipecontrol(pipe)) {
+			if (usb_pipeint(pipe)) 
+				ep->ring = aotg_alloc_ring(acthcd, ep, INTR_TRBS, GFP_ATOMIC);
+			else
+				ep->ring = aotg_alloc_ring(acthcd, ep, NUM_TRBS, GFP_ATOMIC);							
+			if (!ep->ring) {
+				dev_err(acthcd->dev, "alloc td_ring failed\n");
+				retval = -ENOMEM;
+				goto exit1;
+			}
+			INIT_LIST_HEAD(&ep->queue_td_list);
+			INIT_LIST_HEAD(&ep->enring_td_list);
+			INIT_LIST_HEAD(&ep->dering_td_list);
+
+			//enable_overflow_irq(acthcd, ep);
+		}
+		urb->ep->hcpriv	= ep;
+		if (type == PIPE_BULK)
+			mod_timer(&acthcd->check_trb_timer, jiffies + msecs_to_jiffies(100));
+	}
+
+	urb->hcpriv = hcd;
+
+	if (type == PIPE_CONTROL) {
+		q = aotg_hcd_get_queue(acthcd, urb, mem_flags);
+		if (unlikely(!q)) {
+			dev_err(acthcd->dev, "<QUEUE>  alloc dma queue failed\n");
+			spin_unlock_irqrestore(&acthcd->lock, flags);
+			return -ENOMEM;
+		}		
+
+		q->ep = ep;
+		q->urb = urb;
+		list_add_tail(&q->enqueue_list, &acthcd->hcd_enqueue_list);
+		aotg_dbg_put_q(q, usb_pipeendpoint(q->urb->pipe), usb_pipein(q->urb->pipe), 
+			q->urb->transfer_buffer_length);
+	} else if (type == PIPE_BULK) {
+		td = aotg_alloc_td(mem_flags);
+		if (!td) {
+			dev_err(acthcd->dev, "alloc td failed\n");
+			retval = -ENOMEM;
+			goto exit1;
+		}
+		td->urb = urb;
+
+		ep->urb_enque_cnt++;
+
+		if (list_empty(&ep->queue_td_list)) {
+			//ACT_HCD_DBG
+			retval = aotg_ring_enqueue_td(acthcd, ep->ring, td);
+			if (retval) {
+				list_add_tail(&td->queue_list, &ep->queue_td_list);
+				goto out;
+			} 
+
+			list_add_tail(&td->enring_list, &ep->enring_td_list);
+			ep->ring->enring_cnt++;
+		} else {
+			//ACT_HCD_DBG
+			list_add_tail(&td->queue_list, &ep->queue_td_list);
+		}
+
+		if (!list_empty(&ep->enring_td_list) && 
+								!is_ring_running(ep->ring)) {
+			//ACT_HCD_DBG
+			aotg_start_ring_transfer(acthcd, ep, urb);
+		}
+		
+	} else if (type == PIPE_INTERRUPT) {
+		if (unlikely(ep->ring->intr_inited == 0)) {
+			retval = aotg_ring_enqueue_intr_td(acthcd, ep->ring, ep, urb, GFP_ATOMIC);
+			if (retval) {
+				printk("%s, intr urb enqueue err!\n", __FUNCTION__);
+				goto exit1;
+			}
+			ep->ring->intr_started = 0;
+		}
+		ep->urb_enque_cnt++;
+		list_for_each_entry_safe(td, next, &ep->enring_td_list, enring_list) {
+			if (td->urb) {
+				continue;
+			} else {
+				td->urb = urb;
+				break;
+			}			
+		}
+		
+		if (unlikely(ep->ring->enqueue_trb->hw_buf_len != urb->transfer_buffer_length)) {
+			//printk("ep:%p,hw_buf_len:%d, urb_len:%d .......\n",ep,ep->ring->enqueue_trb->hw_buf_len,urb->transfer_buffer_length);
+			aotg_intr_chg_buf_len(acthcd,ep->ring,urb->transfer_buffer_length);
+			printk("WARNNING:interrupt urb length changed......\n");
+		}
+
+		if (ep->ring->intr_started == 0) {
+			ep->ring->intr_started = 1;			
+			//printk("%s, start ep%d intr transfer\n", __FUNCTION__, ep->index);
+			aotg_start_ring_transfer(acthcd, ep, urb);
+		}
+		
+		if (!is_ring_running(ep->ring)) { /*trb overflow or no urb*/
+			if (ep->is_out) {
+				aotg_start_ring_transfer(acthcd, ep, urb);
+			} else {
+				//if (ep->ring->ring_stopped == 0) {
+				if (aotg_intr_get_finish_trb(ep->ring) == 0) {
+					ep->ring->ring_stopped = 0;
+					aotg_reorder_intr_td(ep);
+					ep_enable(ep);
+					mb();
+					writel(DMACTRL_DMACS,ep->ring->reg_dmactrl);
+				//	printk("restart intr!\n");
+				} else ep->ring->ring_stopped = 1;
+			}
+		}
+	} else {// type == PIPE_ISOCHRONOUS
+		td = aotg_alloc_td(mem_flags);
+		if (!td) {
+			dev_err(acthcd->dev, "alloc td failed\n");
+			retval = -ENOMEM;
+			goto exit1;
+		}
+		td->urb = urb;
+		
+		ep->urb_enque_cnt++;
+
+		if (list_empty(&ep->queue_td_list)) {
+			//ACT_HCD_DBG
+			retval = aotg_ring_enqueue_isoc_td(acthcd, ep->ring, td);
+			if (retval) {
+				list_add_tail(&td->queue_list, &ep->queue_td_list);
+				goto out;
+			} 
+
+			list_add_tail(&td->enring_list, &ep->enring_td_list);
+			ep->ring->enring_cnt++;
+		} else {
+			//ACT_HCD_DBG
+			list_add_tail(&td->queue_list, &ep->queue_td_list);
+		}
+
+		if (!list_empty(&ep->enring_td_list) && !is_ring_running(ep->ring)) {
+			if (ep->ring->dequeue_trb != ep->ring->first_trb)
+				aotg_reorder_iso_td(acthcd, ep->ring);
+			aotg_start_ring_transfer(acthcd, ep, urb);
+		}
+	}
+out:
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	tasklet_hi_schedule(&acthcd->urb_tasklet);
+	return retval;
+exit1:
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
+exit0:
+	/* FIXME */
+	printk("never goto here, need to just\n");
+	if (unlikely(retval < 0) && ep) {
+		if (type == PIPE_CONTROL)	{
+			ACT_HCD_ERR
+			if (ep)
+				ep->q = NULL;
+			if(q)
+				aotg_hcd_release_queue(acthcd, q);
+		} else {
+			writel(DMACTRL_DMACC,ep->ring->reg_dmactrl);
+			ep_disable(ep);
+			/*if (!list_empty(&ep->queue_td_list)) {
+				list_for_each_entry_safe(td, next, &ep->queue_td_list, queue_list) {
+					list_del(&td->queue_list);
+					if (td)
+						kfree(td);
+				}
+			}
+		
+			if (!list_empty(&ep->enring_td_list)) {
+				list_for_each_entry_safe(td, next, &ep->enring_td_list, enring_list) {
+					list_del(&td->enring_list);
+					if (td)
+						kfree(td);
+				}
+			}*/
+		}
+	}
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	return retval;
+}
+
+static int aotg_hub_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	struct aotg_hcep *ep;
+	struct aotg_queue *q = NULL, *next, *tmp;
+	struct aotg_ring *ring;
+	struct aotg_td *td, *next_td;
+	unsigned long flags;
+	int retval = 0;
+	
+	if ((acthcd == NULL) || (act_hcd_ptr[acthcd->id] == NULL)) {
+		printk("aotg_hcd device had been removed...\n");
+		return -EIO;
+	}
+
+	spin_lock_irqsave(&acthcd->lock, flags);
+
+	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (retval) {
+		printk("%s, retval:%d, urb not submitted or unlinked\n", __FUNCTION__, 
+				retval);
+		goto dequeue_out;
+	}
+
+	ep = (struct aotg_hcep *)urb->ep->hcpriv;
+	if (ep == NULL) {
+		ACT_HCD_ERR
+		retval = -EINVAL;
+		goto dequeue_out;
+	}
+
+	if (!usb_pipecontrol(urb->pipe)) {
+//		ACT_HCD_DBG
+		ep->urb_unlinked_cnt++;
+		ring = ep->ring;
+		
+		if (usb_pipeint(urb->pipe)) {
+			list_for_each_entry_safe(td, next_td, &ep->enring_td_list, enring_list) {
+				if (urb == td->urb) {
+					retval = aotg_ring_dequeue_intr_td(acthcd, ep, ring, td);
+					goto de_bulk;				
+				}
+			}
+			printk("%s, intr dequeue err\n", __FUNCTION__);
+		}
+
+		list_for_each_entry_safe(td, next_td, &ep->queue_td_list, queue_list) {
+			if (urb == td->urb) {
+				retval = aotg_ring_dequeue_td(acthcd, ring, td, TD_IN_QUEUE);
+				goto de_bulk;
+			}
+		}
+
+		list_for_each_entry_safe(td, next_td, &ep->enring_td_list, enring_list) {
+			mb();
+			if (urb == td->urb) {
+				retval = aotg_ring_dequeue_td(acthcd, ring, td, TD_IN_RING);
+				ep->urb_stop_stran_cnt++;
+				goto de_bulk;
+			} 
+		}
+
+		//pr_err("%s err, never be here, pls check it!\n", __func__);		
+		retval = -EINVAL;
+		goto dequeue_out;
+de_bulk:
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		spin_unlock(&acthcd->lock);
+		usb_hcd_giveback_urb(hcd, urb, status);
+		spin_lock(&acthcd->lock);
+
+		spin_unlock_irqrestore(&acthcd->lock, flags);
+		return retval;
+	}
+	
+	q = ep->q;
+
+	/* ep->mask currently equal to q->dma_no. */
+	if (q && (q->urb == urb)) {
+		writeb(EP0CS_HCSET,acthcd->base + EP0CS);
+		//dev_info(acthcd->dev, 
+			//"current dequeue -- ep->index: %d, dir : %s, type: %d, transfer_buffer_length: %d, actual_length:%d\n",
+			//ep->index, usb_pipeout(urb->pipe)?"out":"in", usb_pipetype(urb->pipe), 
+			//urb->transfer_buffer_length, urb->actual_length);
+
+		/* maybe finished in tasklet_finish_request. */
+		if (!list_empty(&q->finished_list)) {
+			if (q->finished_list.next != LIST_POISON1) {
+				list_del(&q->finished_list);
+			}
+		}
+
+		if (q->is_xfer_start) {
+			ep->urb_stop_stran_cnt++;
+			q->is_xfer_start = 0;
+		}
+	} else {
+		q = NULL;
+		list_for_each_entry_safe(tmp, next, &acthcd->hcd_enqueue_list, enqueue_list) {
+			if (tmp->urb == urb) {
+				list_del(&tmp->enqueue_list);
+				q = tmp;
+				ep = q->ep;
+				if (ep->q == q) {
+					ACT_HCD_DBG
+				}
+				break;
+			}
+		}
+	}
+
+	if (likely(q)) {
+		//ACT_HCD_DBG
+		//if (ep->q == q) 
+			//ep->q = NULL;
+		q->status = status;
+		list_add_tail(&q->dequeue_list, &acthcd->hcd_dequeue_list);
+		spin_unlock_irqrestore(&acthcd->lock, flags);
+		tasklet_schedule(&acthcd->urb_tasklet);
+		return retval;
+	} else {
+		ACT_HCD_ERR
+		printk("dequeue's urb not find in enqueue_list!\n");
+	}	
+
+dequeue_out:
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	return retval;
+}
+
+void urb_tasklet_func(unsigned long data)
+{
+	struct aotg_hcd *acthcd = (struct aotg_hcd *)data;
+	struct aotg_queue *q, *next;
+	struct aotg_hcep *ep;
+	struct urb *urb;
+	struct aotg_ring *ring;
+	struct aotg_td *td;
+	unsigned long flags;
+	int status;
+	struct usb_hcd *hcd = aotg_to_hcd(acthcd);
+	int cnt = 0;
+	//static struct aotg_hcep * hcin_ep = NULL;
+
+	//spin_lock(&acthcd->tasklet_lock);
+
+	do {
+		status = (int)spin_is_locked(&acthcd->tasklet_lock);
+		if (status) {
+			acthcd->tasklet_retry = 1;
+			printk("locked, urb retry later!\n");
+			return;
+		}
+		cnt++;
+		/* sometimes tasklet_lock is unlocked, but spin_trylock still will be failed, 
+		 * maybe caused by the instruction of strexeq in spin_trylock, it will return failed   
+		 * if other cpu is accessing the nearby address of &acthcd->tasklet_lock.
+		 */
+		status = spin_trylock(&acthcd->tasklet_lock);
+		if ((!status) && (cnt > 10))  {
+			acthcd->tasklet_retry = 1;
+			printk("urb retry later!\n");
+			return;
+		}
+	} while (status == 0);
+
+	disable_irq(acthcd->uhc_irq);
+	spin_lock_irqsave(&acthcd->lock, flags);
+
+	for (cnt=1; cnt<MAX_EP_NUM; cnt++) {
+		ep = acthcd->inep[cnt];
+		if (ep && (ep->type == PIPE_INTERRUPT)) {
+			ring = ep->ring;
+			if (ring->ring_stopped) {
+				td = list_first_entry_or_null(&ep->enring_td_list, struct aotg_td, enring_list);
+				if (!td)
+					continue;
+				urb = td->urb;
+				if (!urb)
+					continue;
+				intr_finish_td(acthcd, ring, td);
+			}
+		}
+	}
+	/* do dequeue task. */
+DO_DEQUEUE_TASK:
+	urb = NULL;
+	list_for_each_entry_safe(q, next, &acthcd->hcd_dequeue_list, dequeue_list) {
+		if (q->status < 0) {
+			urb = q->urb;
+			ep = q->ep;
+			if (ep) {
+				ep->urb_unlinked_cnt++;
+				//ep->q = NULL;
+			}
+			list_del(&q->dequeue_list);
+			status = q->status;
+			tasklet_finish_request(acthcd, q, status);
+			hcd = bus_to_hcd(urb->dev->bus);
+			break;
+		} else {
+			ACT_HCD_ERR
+		}
+	}
+	if (urb != NULL) {
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		spin_unlock_irqrestore(&acthcd->lock, flags);
+		/* in usb_hcd_giveback_urb, complete function may call new urb_enqueue. */ 
+		usb_hcd_giveback_urb(hcd, urb, status);
+		spin_lock_irqsave(&acthcd->lock, flags);
+		goto DO_DEQUEUE_TASK;
+	}
+
+	/* do finished task. */
+DO_FINISH_TASK:
+	urb = NULL;
+	list_for_each_entry_safe(q, next, &acthcd->hcd_finished_list, finished_list) {
+		if (q->finished_list.next != LIST_POISON1) {
+			list_del(&q->finished_list);
+		} else {
+			ACT_HCD_ERR
+			break;
+		}
+		status = q->status;
+		tasklet_finish_request(acthcd, q, status);
+
+		hcd = aotg_to_hcd(acthcd);
+		urb = q->urb;
+		ep = q->ep;
+		if (urb != NULL) {
+			break;
+		}
+	}
+	if (urb != NULL) {
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+
+		spin_unlock_irqrestore(&acthcd->lock, flags);
+
+		/* in usb_hcd_giveback_urb, complete function may call new urb_enqueue. */ 
+		usb_hcd_giveback_urb(hcd, urb, status);
+
+		spin_lock_irqsave(&acthcd->lock, flags);
+		goto DO_FINISH_TASK;
+	}
+
+//DO_ENQUEUE_TASK:
+	/* do enqueue task. */
+	/* start transfer directly, don't care setup appearing in bulkout. */
+	list_for_each_entry_safe(q, next, &acthcd->hcd_enqueue_list, enqueue_list) {
+		urb = q->urb;
+		ep = q->ep;
+
+		/* deal with controll request. */
+		if (usb_pipetype(urb->pipe) == PIPE_CONTROL) {
+			if ((acthcd->active_ep0 != NULL) && (acthcd->active_ep0->q != NULL)) {
+				acthcd->ep0_block_cnt++;
+				//ACT_HCD_DBG
+				if ((acthcd->ep0_block_cnt % 10) == 0) {
+					ACT_HCD_DBG
+					printk("cnt:%d\n", acthcd->ep0_block_cnt);
+					acthcd->ep0_block_cnt = 0;
+					//aotg_hub_urb_dequeue(hcd, acthcd->active_ep0->q->urb, -ETIMEDOUT);
+				}
+				continue;
+			} else {
+				acthcd->ep0_block_cnt = 0;
+				goto BEGIN_START_TANSFER;
+			}
+		} 
+
+		/* deal with new bulk in request. */
+		if ((usb_pipetype(urb->pipe) == PIPE_BULK) && (usb_pipein(urb->pipe))) {
+			if (ep->q != NULL) {
+				continue;
+			}
+			goto BEGIN_START_TANSFER;
+		}
+
+		/* deal with bulk out request. */
+		if ((usb_pipetype(urb->pipe) == PIPE_BULK) && (usb_pipeout(urb->pipe))) {
+			if (ep->q != NULL) {
+				continue;
+			}
+			if ((EPCS_BUSY & readb(ep->reg_hcepcs)) != 0) {
+				ep->fifo_busy++;
+				mod_timer(&acthcd->trans_wait_timer, jiffies + msecs_to_jiffies(3));
+				continue;
+			} else {
+				ep->fifo_busy = 0;
+			}
+			goto BEGIN_START_TANSFER;
+		}
+
+BEGIN_START_TANSFER:
+		list_del(&q->enqueue_list);
+		status = start_transfer(acthcd, q, ep);
+
+		if (unlikely(status < 0)) {
+			ACT_HCD_ERR
+			hcd = bus_to_hcd(urb->dev->bus);
+			aotg_hcd_release_queue(acthcd, q);
+
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			spin_unlock_irqrestore(&acthcd->lock, flags);
+			usb_hcd_giveback_urb(hcd, urb, status);
+			spin_lock_irqsave(&acthcd->lock, flags);
+		}
+		//spin_unlock_irqrestore(&acthcd->lock, flags);
+		//enable_irq(acthcd->uhc_irq);
+		//spin_unlock(&acthcd->tasklet_lock);
+		//return;
+	}
+
+	if (acthcd->tasklet_retry != 0) {
+		acthcd->tasklet_retry = 0;
+		goto DO_DEQUEUE_TASK;
+	}
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	enable_irq(acthcd->uhc_irq);
+	spin_unlock(&acthcd->tasklet_lock);
+	return;
+}
+
+static void aotg_hub_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)
+{
+	int i;
+	int index;
+	unsigned long flags;
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	struct aotg_hcep *ep = hep->hcpriv;
+	
+	if (!ep)
+		return;
+
+	/* assume we'd just wait for the irq */
+//	for (i = 0; i < 100 && !list_empty(&hep->urb_list); i++)
+//		msleep(3);
+
+	if (in_irq()) {
+		disable_irq_nosync(acthcd->uhc_irq);
+	} else {
+		disable_irq(acthcd->uhc_irq);
+	}
+	spin_lock_irqsave(&acthcd->lock, flags);
+
+//	usb_put_dev(ep->udev);
+	index = ep->index;
+	if (index == 0) {
+		acthcd->ep0[ep->ep0_index] = NULL;
+		if (acthcd->active_ep0 == ep) {
+			acthcd->active_ep0 = NULL;
+		}
+		for (i = 0; i < MAX_EP_NUM; i++) {
+			if (acthcd->ep0[i] != NULL) {
+				break;
+			}
+		}
+		if (i == MAX_EP_NUM) {
+			usb_clearbitsw(1, acthcd->base + HCOUTxIEN0);
+			usb_clearbitsw(1, acthcd->base + HCINxIEN0);
+			writew(1, acthcd->base + HCOUTxIRQ0);
+			writew(1, acthcd->base + HCINxIRQ0);
+		}
+	} else {
+		ep_disable(ep);
+		if (ep->mask & USB_HCD_OUT_MASK) {
+			acthcd->outep[index] = NULL;
+		} else {
+			acthcd->inep[index] = NULL;
+		}
+//		pio_irq_disable(acthcd, ep->mask);
+//		pio_irq_clear(acthcd, ep->mask);
+		release_fifo_addr(acthcd, ep->fifo_addr);
+	}
+	
+	hep->hcpriv = NULL;
+
+	if(ep->ring){
+		printk("%s\n", __FUNCTION__);
+		
+		aotg_stop_ring(ep->ring);
+		if (ep->ring->type == PIPE_INTERRUPT) {
+			printk("%s, ep%d dma buf free\n", __FUNCTION__, ep->index);
+			aotg_intr_dma_buf_free(acthcd, ep->ring);
+		}
+			
+		aotg_free_ring(acthcd, ep->ring);
+	}
+		
+	dev_info(acthcd->dev, "<EP DISABLE> ep%d index %d from ep [%s]\n", 
+			ep->epnum, index, 
+			ep->mask & USB_HCD_OUT_MASK ? "out":"in");
+
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	enable_irq(acthcd->uhc_irq);
+	kfree(ep);
+	return;
+}
+
+static int aotg_hcd_get_frame(struct usb_hcd *hcd)
+{
+	struct timeval	tv;
+
+	do_gettimeofday(&tv);
+	return tv.tv_usec / 1000;
+}
+
+static int aotg_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct aotg_hcd *acthcd;
+	unsigned long flags;
+	int retval = 0;
+
+	acthcd = hcd_to_aotg(hcd);
+	local_irq_save(flags);
+	if (!HC_IS_RUNNING(hcd->state))
+		goto done;
+
+	if ((acthcd->port & AOTG_PORT_C_MASK) != 0) {
+		*buf = (1 << 1);
+		HUB_DEBUG("<HUB STATUS>port status %08x has changes\n", acthcd->port);
+		retval = 1;
+	}
+done:
+	local_irq_restore(flags);
+	return retval;
+}
+
+static __inline__ void port_reset(struct aotg_hcd *acthcd)
+{
+	HCD_DEBUG("<USB> port reset\n");
+	writeb(0x1<<6 | 0x1<<5, acthcd->base + HCPORTCTRL);	/*portrst & 55ms */
+}
+
+static void port_power(struct aotg_hcd *acthcd, int is_on)
+{
+	struct usb_hcd *hcd = aotg_to_hcd(acthcd);
+	//struct device *dev = hcd->self.controller;
+
+	/* hub is inactive unless the port is powered */
+	if (is_on) {
+		hcd->self.controller->power.power_state = PMSG_ON;
+		dev_dbg(acthcd->dev, "<USB> power on\n");
+	} else {
+		hcd->self.controller->power.power_state = PMSG_SUSPEND;
+		dev_dbg(acthcd->dev, "<USB> power off\n");
+	}
+}
+
+static void port_suspend(struct aotg_hcd *acthcd)
+{
+	usb_clearbitsb(OTGCTRL_BUSREQ, acthcd->base + OTGCTRL);
+}
+
+static void port_resume(struct aotg_hcd *acthcd)
+{
+	usb_setbitsb(OTGCTRL_BUSREQ, acthcd->base + OTGCTRL);
+}
+
+static int aotg_hcd_start(struct usb_hcd *hcd)
+{
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	//struct device *dev = hcd->self.controller;
+	//struct aotg_plat_data *data = dev->platform_data;
+	int retval = 0;
+	unsigned long flags;
+	
+	dev_info(acthcd->dev, "<HCD> start\n");
+	
+	local_irq_save(flags);
+	hcd->state = HC_STATE_RUNNING;
+	hcd->uses_new_polling = 1;
+	local_irq_restore(flags);
+	
+	return retval;
+
+}
+
+static void aotg_hcd_stop(struct usb_hcd *hcd)
+{
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	//struct device *dev = hcd->self.controller;
+	//struct aotg_plat_data *data = dev->platform_data;
+	unsigned long flags;
+	
+	dev_info(acthcd->dev, "<HCD> stop\n");
+	
+	local_irq_save(flags);
+	hcd->state = HC_STATE_HALT;
+	acthcd->port = 0;
+	acthcd->rhstate = AOTG_RH_POWEROFF;
+	local_irq_restore(flags);
+	return;
+}
+
+#ifdef	CONFIG_PM
+
+static int aotg_hub_suspend(struct usb_hcd *hcd)
+{
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+
+	if ((hcd == NULL) || (acthcd == NULL)) {
+		ACT_HCD_ERR
+		return 0;
+	}
+	acthcd->suspend_request_pend = 1;
+	port_suspend(acthcd);
+	
+	return 0;
+}
+
+static int
+aotg_hub_resume(struct usb_hcd *hcd)
+{
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	
+	port_resume(acthcd);
+
+	return 0;
+}
+
+#else
+
+#define	aotg_hub_suspend	NULL
+#define	aotg_hub_resume		NULL
+
+#endif
+
+static __inline__ void aotg_hub_descriptor(struct usb_hub_descriptor *desc)
+{
+	memset(desc, 0, sizeof *desc);
+	desc->bDescriptorType = 0x29;
+	desc->bDescLength = 9;
+	desc->wHubCharacteristics = (__force __u16)
+	    (__constant_cpu_to_le16(0x0001));
+	desc->bNbrPorts = 1;
+	//desc->bitmap[0] = 1 << 1;
+	//desc->bitmap[1] = 0xff;
+}
+
+static int aotg_hub_control(struct usb_hcd *hcd,
+			    u16 typeReq,
+			    u16 wValue, u16 wIndex, char *buf, u16 wLength)
+{
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	unsigned long flags;
+	int retval = 0;
+
+	if (in_irq()) {
+		disable_irq_nosync(acthcd->uhc_irq);
+	} else {
+		disable_irq(acthcd->uhc_irq);
+	}
+	spin_lock_irqsave(&acthcd->lock, flags);
+
+	if (!HC_IS_RUNNING(hcd->state)) {
+		dev_err(acthcd->dev, "<HUB_CONTROL> hc state is not HC_STATE_RUNNING\n");
+		spin_unlock_irqrestore(&acthcd->lock, flags);
+		enable_irq(acthcd->uhc_irq);
+		return -EPERM;
+	}
+	HUB_DEBUG("<HUB_CONTROL> typeReq:%x, wValue:%04x, wIndex: %04x, wLength: %04x\n", typeReq, wValue, wIndex, wLength);
+
+	switch (typeReq) {
+	case ClearHubFeature:
+		HUB_DEBUG("<HUB_CONTROL> ClearHubFeature, wValue:%04x, wIndex: %04x, wLength: %04x\n",
+		     wValue, wIndex, wLength);
+		break;
+	case ClearPortFeature:
+		HUB_DEBUG("<HUB_CONTROL> ClearPortFeature, wValue:%04x, wIndex: %04x, wLength: %04x\n",
+		     wValue, wIndex, wLength);
+
+		if (wIndex != 1 || wLength != 0)
+			goto hub_error;
+		HUB_DEBUG("<HUB_CONTROL> before clear operation,the port status is %08x\n", acthcd->port);
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			acthcd->port &= ~(USB_PORT_STAT_ENABLE
+					  | USB_PORT_STAT_LOW_SPEED
+					  | USB_PORT_STAT_HIGH_SPEED);
+			acthcd->rhstate = AOTG_RH_DISABLE;
+			if (acthcd->port & USB_PORT_STAT_POWER)
+				port_power(acthcd, 0);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			HUB_DEBUG("<HUB_CONTROL>clear suspend feathure\n");
+			//port_resume(acthcd);
+			acthcd->port &= ~(1 << wValue);
+			break;
+		case USB_PORT_FEAT_POWER:
+			acthcd->port = 0;
+			acthcd->rhstate = AOTG_RH_POWEROFF;
+			port_power(acthcd, 0);
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+		case USB_PORT_FEAT_C_SUSPEND:
+		case USB_PORT_FEAT_C_CONNECTION:
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+		case USB_PORT_FEAT_C_RESET:
+			acthcd->port &= ~(1 << wValue);
+			break;
+		default:
+			goto hub_error;
+		}
+		HUB_DEBUG("<HUB_CONTROL> after clear operation,the port status is %08x\n", acthcd->port);
+		break;
+	case GetHubDescriptor:
+		HUB_DEBUG("<HUB_CONTROL> GetHubDescriptor, wValue:%04x, wIndex: %04x, wLength: %04x\n",
+		     wValue, wIndex, wLength);
+		aotg_hub_descriptor((struct usb_hub_descriptor *)buf);
+		break;
+	case GetHubStatus:
+		HUB_DEBUG("<HUB_CONTROL> GetHubStatus, wValue:%04x, wIndex: %04x, wLength: %04x\n",
+		     wValue, wIndex, wLength);
+
+		*(__le32 *) buf = __constant_cpu_to_le32(0);
+		break;
+	case GetPortStatus:
+		HUB_DEBUG("<HUB_CONTROL> GetPortStatus, wValue:%04x, wIndex: %04x, wLength: %04x\n",
+		     wValue, wIndex, wLength);
+
+		if (wIndex != 1)
+			goto hub_error;
+		*(__le32 *) buf = cpu_to_le32(acthcd->port);
+		HUB_DEBUG("<HUB_CONTROL> the port status is %08x\n ",
+			 acthcd->port);
+		break;
+	case SetHubFeature:
+		HUB_DEBUG("<HUB_CONTROL> SetHubFeature, wValue: %04x,wIndex: %04x, wLength: %04x\n",
+		     wValue, wIndex, wLength);
+		goto hub_error;
+		break;
+	case SetPortFeature:
+		HUB_DEBUG("<HUB_CONTROL> SetPortFeature, wValue:%04x, wIndex: %04x, wLength: %04x\n",
+		     wValue, wIndex, wLength);
+
+		switch (wValue) {
+		case USB_PORT_FEAT_POWER:
+			if (unlikely(acthcd->port & USB_PORT_STAT_POWER))
+				break;
+			acthcd->port |= (1 << wValue);
+			acthcd->rhstate = AOTG_RH_POWERED;
+			port_power(acthcd, 1);
+			break;
+		case USB_PORT_FEAT_RESET:
+			port_reset(acthcd);
+			/* if it's already enabled, disable */
+			acthcd->port &= ~(USB_PORT_STAT_ENABLE
+					  | USB_PORT_STAT_LOW_SPEED
+					  | USB_PORT_STAT_HIGH_SPEED);
+			acthcd->port |= (1 << wValue);
+			mdelay(2);
+			acthcd->rhstate = AOTG_RH_RESET;
+			usb_setbitsb(USBIEN_URES, acthcd->base + USBIEN);
+			/*enable reset irq */
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			/*acthcd->port |= USB_PORT_FEAT_SUSPEND;*/
+			acthcd->port |= (1 << wValue);
+			acthcd->rhstate = AOTG_RH_SUSPEND;
+			//port_suspend(acthcd);
+			break;
+		default:
+			if (acthcd->port & USB_PORT_STAT_POWER)
+				acthcd->port |= (1 << wValue);
+		}
+		break;
+	default:
+hub_error:
+		retval = -EPIPE;
+		dev_err(acthcd->dev, "<HUB_CONTROL> hub control error\n");
+		break;
+
+	}
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	enable_irq(acthcd->uhc_irq);
+
+	return retval;
+}
+
+int aotg_hcd_init(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	int retval = 0;
+	int i;
+
+	/*init software state */
+	spin_lock_init(&acthcd->lock);
+	spin_lock_init(&acthcd->tasklet_lock);
+	acthcd->tasklet_retry = 0;
+	//acthcd->dev = &pdev->dev;
+	acthcd->port_specific = pdev->dev.platform_data;
+	acthcd->port = 0;
+	acthcd->rhstate = AOTG_RH_POWEROFF;
+	acthcd->inserted = 0;
+
+	INIT_LIST_HEAD(&acthcd->hcd_enqueue_list);
+	INIT_LIST_HEAD(&acthcd->hcd_dequeue_list);
+	INIT_LIST_HEAD(&acthcd->hcd_finished_list);
+	tasklet_init(&acthcd->urb_tasklet, urb_tasklet_func, (unsigned long)acthcd);
+
+#if 0
+	for (i = 0; i < PERIODIC_SIZE; i++) {
+		acthcd->load[i] = 0;
+		acthcd->periodic[i] = NULL;
+	}
+#endif
+
+	acthcd->active_ep0 = NULL;
+	for (i = 0; i < MAX_EP_NUM; i++) {
+		acthcd->ep0[i] = NULL;
+		acthcd->inep[i] = NULL;
+		acthcd->outep[i] = NULL;
+	}
+
+	acthcd->fifo_map[0] = 1<<31;
+	acthcd->fifo_map[1] = 1<<31 | 64;
+	for (i = 2; i < 64; i++) {
+		acthcd->fifo_map[i] = 0;
+	}
+
+	acthcd->put_aout_msg = 0;
+	acthcd->discon_happened = 0;
+	acthcd->uhc_irq = 0;
+	acthcd->check_trb_mutex = 0;
+	for (i = 0; i < AOTG_QUEUE_POOL_CNT; i++) {
+		acthcd->queue_pool[i] = NULL;
+	}
+
+	return retval;
+}
+
+static const char platform_drv_name[] = "aotg_hcd";
+static const char hcd_driver_name[] = "aotg_hub_hcd";
+
+#define AOTG_BUF_NEED_MAP(x, y)	((x != NULL) && (((unsigned long)x & 0x3) == 0))
+//#define AOTG_BUF_NEED_MAP(x, y)	((x != NULL) && ((y & 0x3) == 0))
+
+static int aotg_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
+				      gfp_t mem_flags)
+{
+	int ret = 0;
+
+	if (usb_pipetype(urb->pipe) != PIPE_INTERRUPT) {
+		ret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);
+	}
+	return ret;
+}
+
+static void aotg_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
+{
+	if (usb_pipetype(urb->pipe) != PIPE_INTERRUPT) {
+
+		usb_hcd_unmap_urb_for_dma(hcd, urb);
+	}
+	return;
+}
+
+struct hc_driver act_hc_driver = {
+	.description = hcd_driver_name,
+	.hcd_priv_size = sizeof(struct aotg_hcd),
+	.product_desc = DRIVER_DESC,
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = aotg_hub_irq,
+	.flags = HCD_USB2 | HCD_MEMORY,
+
+	/* Basic lifecycle operations */
+	.start = aotg_hcd_start,
+	.stop = aotg_hcd_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = aotg_hub_urb_enqueue,
+	.urb_dequeue = aotg_hub_urb_dequeue,
+
+	.map_urb_for_dma	= aotg_map_urb_for_dma,
+	.unmap_urb_for_dma	= aotg_unmap_urb_for_dma,
+
+	.endpoint_disable = aotg_hub_endpoint_disable,
+
+	/*
+	 * periodic schedule support
+	 */
+	.get_frame_number = aotg_hcd_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = aotg_hub_status_data,
+	.hub_control = aotg_hub_control,
+
+	.bus_suspend =        aotg_hub_suspend,
+	.bus_resume =         aotg_hub_resume,
+};
+
+static int aotg_hub_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	struct aotg_hcep *ep;
+	int i;
+
+	usb_remove_hcd(hcd);
+	act_hcd_ptr[pdev->id] = NULL;
+#if 0    
+#ifdef CONFIG_PM
+	aotg_hcd_unregister_earlysuspend(acthcd);
+#endif
+#endif
+	aotg_disable_irq(acthcd);
+	aotg_clk_enable(acthcd->id, 0);
+	acthcd->hcd_exiting = 1;
+
+	tasklet_kill(&acthcd->urb_tasklet);
+	del_timer_sync(&acthcd->trans_wait_timer);
+	del_timer_sync(&acthcd->check_trb_timer);
+	del_timer_sync(&acthcd->hotplug_timer);
+	remove_debug_file(acthcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	//aotg_hcd_release_queue(acthcd, NULL);
+	owl_powergate_power_off(acthcd->id == 0 ? OWL_POWERGATE_USB2_0 : OWL_POWERGATE_USB2_1);
+
+	for (i = 0; i < MAX_EP_NUM; i++) {
+		ep = acthcd->ep0[i];
+		if (ep) {
+			ACT_HCD_DBG
+			if (ep->q)
+				ACT_HCD_DBG
+			kfree(ep);
+		}
+	}
+//fix here in 64 bit
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		ep = acthcd->inep[i];
+		if (ep) {
+			ACT_HCD_DBG
+			if (ep->ring) {
+				ACT_HCD_DBG
+				//aotg_free_ring(acthcd, ep->ring);
+			}
+			kfree(ep);
+		}
+	}
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		ep = acthcd->outep[i];
+		if (ep) {
+			ACT_HCD_DBG
+			if (ep->ring) {
+				ACT_HCD_DBG
+				//aotg_free_ring(acthcd,ep->ring);
+			}
+			kfree(ep);
+		}
+	}
+	
+	usb_put_hcd(hcd);
+	printk("pdev->id remove:%d\n", pdev->id);
+	
+	if (!port_host_plug_detect[acthcd->id])
+		aotg_power_onoff(pdev->id,0);
+
+	return 0;
+}
+
+#ifdef	CONFIG_PM
+static int aotg_hcd_hub_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+
+	if ((hcd == NULL) || (acthcd == NULL)) {
+		ACT_HCD_ERR
+		return 0;
+	}
+	dev_info(acthcd->dev, " ==> %s\n", __func__);
+	/*do {
+		i++;
+		msleep(1);
+	} while ((acthcd->suspend_request_pend != 0) && (i < 200));*/
+
+	aotg_disable_irq(acthcd);
+	//usb_clearbitsb(OTGCTRL_BUSREQ, acthcd->base + OTGCTRL);
+	owl_powergate_power_off(acthcd->id == 0 ?
+		OWL_POWERGATE_USB2_0 : OWL_POWERGATE_USB2_1);
+	aotg_clk_enable(acthcd->id, 0);
+
+	aotg_power_onoff(pdev->id,0);
+	acthcd->lr_flag = 1;
+	return 0;
+}
+
+static int aotg_hcd_hub_resume(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct aotg_hcd *acthcd = hcd_to_aotg(hcd);
+	struct usb_device *udev;
+	int i;
+	
+	if ((hcd == NULL) || (acthcd == NULL)) {
+		ACT_HCD_ERR
+		return 0;
+	}
+
+	/* power on. */
+/*	if (acthcd->id == 0) {
+		aotg0_device_init(1);
+	} else {
+		aotg1_device_init(1);
+	}*/
+	//gpio_set_value_cansleep(vbus_otg_en_gpio[pdev->id][0], 1);
+	aotg_power_onoff(pdev->id,1);
+	msleep(10);
+
+	dev_info(acthcd->dev, " ==> %s\n", __func__);
+	aotg_hardware_init(acthcd->id);
+
+	//INIT_LIST_HEAD(&acthcd->hcd_enqueue_list);
+	
+	for (i = 0; i < MAX_EP_NUM; i++) {
+			if (acthcd->ep0[i] != NULL) {
+				break;
+			}
+		}
+	
+	if (i == MAX_EP_NUM) {
+		printk(KERN_ERR"%s, usb device is NULL!\n", __FUNCTION__);
+	}
+	else {
+		udev = acthcd->ep0[i]->udev;
+		//if (port_plug_en[acthcd->id]) {
+			usb_set_device_state(udev, USB_STATE_NOTATTACHED);
+		//}	else {
+		//	usb_set_device_state(udev, USB_STATE_CONFIGURED);
+		//}
+	}
+	if (port_host_plug_detect[acthcd->id]) {
+		aotg_dev_plugout_msg(acthcd->id);
+	} else {
+		aotg_enable_irq(acthcd);
+	}
+	return 0;
+}
+#endif
+
+void aotg_hcd_shutdown(struct platform_device *pdev)
+{	
+	struct usb_hcd *hcd	= platform_get_drvdata(pdev);
+	struct aotg_hcd	*acthcd	= hcd_to_aotg(hcd);
+	printk("usb2-%d shutdown\n", acthcd->id);
+	
+	//gpio_set_value_cansleep(vbus_otg_en_gpio[pdev->id][0], 0);
+	aotg_power_onoff(pdev->id,0);
+	return;
+}
+
+struct platform_driver aotg_hcd_driver = {
+	.probe = aotg_probe,
+	.remove = aotg_hub_remove,
+#ifdef	CONFIG_PM
+	.suspend = aotg_hcd_hub_suspend,
+	.resume = aotg_hcd_hub_resume,
+#endif
+	.shutdown = aotg_hcd_shutdown,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = platform_drv_name,
+		.of_match_table = aotg_of_match,
+	},
+};
diff --git a/drivers/usb/aotg/aotg_hcd.h b/drivers/usb/aotg/aotg_hcd.h
new file mode 100755
index 0000000..f58e35d
--- /dev/null
+++ b/drivers/usb/aotg/aotg_hcd.h
@@ -0,0 +1,462 @@
+#ifndef  __LINUX_USB_HOST_AOTG_H 
+#define  __LINUX_USB_HOST_AOTG_H 
+
+#include <mach/hardware.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/hcd.h>
+#include <linux/earlysuspend.h>
+
+#include "aotg_regs.h"
+#include "aotg.h"
+
+//#define USBH_DEBUG
+
+#define	PERIODIC_SIZE		64 
+#define MAX_PERIODIC_LOAD	500 //50%
+
+#define  AOTG_BULK_FIFO_START_ADDR	0x0080
+#define  AOTG_INTERRUPT_FIFO_START_ADDR		0xC00    //max 1k
+
+ 
+#define  USB_HCD_IN_MASK	0x00 
+#define  USB_HCD_OUT_MASK 0x10 
+ 
+#define  AOTG_MAX_FIFO_SIZE    (512*10 + 64*2)	//5k
+#define  ALLOC_FIFO_UNIT        64
+//#define  AOTG_MIN_DMA_SIZE	  512
+//#define  AOTG_MIN_DMA_SIZE	  64
+#define  AOTG_MIN_DMA_SIZE	  0
+ 
+#define AOTG_PORT_C_MASK  ((USB_PORT_STAT_C_CONNECTION \
+	| USB_PORT_STAT_C_ENABLE \
+	| USB_PORT_STAT_C_SUSPEND \
+	| USB_PORT_STAT_C_OVERCURRENT \
+	| USB_PORT_STAT_C_RESET) << 16) 
+
+#define MAX_EP_NUM		16   //count of each type, 1st is reserved
+#define MAX_SG_TABLE	(0x1 << 9)
+
+#define MAX_ERROR_COUNT	6
+
+#ifndef USBH0_ECS
+#define USBH0_ECS  (TIMER_2HZ_BASE+0x0084)
+#endif
+
+#define CMU_USBPLL_USBPLL0EN	0x1500
+
+#define CMU_DEVRST1_USBH0	0x01
+
+#define CMU_USBPLL_USBPLL1EN	0x2a00
+
+#define CMU_DEVRST1_USB1	(1<<22)
+
+#ifndef USBH1_ECS
+#define USBH1_ECS  (TIMER_2HZ_BASE+0x0088)
+#endif
+
+/* 0 is all enable, 1 -- just usb0 enable, 2 -- usb1 enable, 
+ * 3 -- usb0 and usb1 enable,but reversed. 
+ */
+extern int hcd_ports_en_ctrl;
+extern struct platform_driver aotg_hcd_driver;
+extern struct hc_driver act_hc_driver;
+
+struct hcd_stats { 
+	unsigned long  insrmv; 
+	unsigned long  wake; 
+	unsigned long sof; 
+}; 
+ 
+enum aotg_rh_state { 
+	AOTG_RH_POWEROFF, 
+	AOTG_RH_POWERED, 
+	AOTG_RH_ATTACHED, 
+	AOTG_RH_NOATTACHED, 
+	AOTG_RH_RESET, 
+	AOTG_RH_ENABLE, 
+	AOTG_RH_DISABLE, 
+	AOTG_RH_SUSPEND, 
+	AOTG_RH_ERR 
+}; 
+
+enum control_phase {
+	PHASE_UNDEFINED,
+	PHASE_SETUP,
+	PHASE_DATA,
+	PHASE_STATUS,
+};
+
+//#define INTR_TRBS (256)
+#define INTR_TRBS (10)
+
+
+#define RING_IN_OF (0xFFFE)
+#define RING_OUT_OF (0xFFFE0000)
+
+#define TD_IN_FINISH (0) 
+#define TD_IN_RING  (0x1 << 0)
+#define TD_IN_QUEUE (0x1 << 1)
+
+struct aotg_ring {
+	//need a protect lock
+	unsigned is_running:1;
+	unsigned is_out:1;
+	unsigned intr_inited:1;
+	unsigned intr_started:1;
+	unsigned ring_stopped:1;
+	int num_trbs;
+	//int irq_interval;
+	//int td_irq_interval;
+	int type;
+	u8 mask;
+	void *priv;
+	atomic_t num_trbs_free;
+
+	int intr_mem_size;
+	struct dma_pool *intr_dma_pool;
+	u8 *intr_dma_buf_vaddr;
+	dma_addr_t intr_dma_buf_phyaddr;
+	char pool_name[32];
+	
+	struct aotg_trb *enqueue_trb;
+	struct aotg_trb *dequeue_trb;
+	struct aotg_trb *first_trb;
+	struct aotg_trb *last_trb;
+	struct aotg_trb *ring_trb;
+	u32 trb_dma;
+
+	unsigned int enring_cnt;
+	unsigned int dering_cnt;
+
+	volatile void __iomem *reg_dmalinkaddr;
+	volatile void __iomem *reg_curaddr;
+	volatile void __iomem *reg_dmactrl;
+	volatile void __iomem *reg_dmacomplete_cnt;
+};
+
+struct aotg_td {
+	struct urb *urb;
+	int num_trbs; 
+	u32 trb_dma;	
+	int err_count;
+	struct aotg_trb *trb_vaddr;
+
+	struct list_head queue_list;
+	struct list_head enring_list;
+	struct list_head dering_list;
+
+	u8 *intr_mem_vaddr;
+	dma_addr_t intr_men_phyaddr;
+	int mem_size;
+
+	unsigned cross_ring:1;
+};
+
+struct aotg_queue {
+	int in_using;
+	struct aotg_hcep *ep;
+	struct urb *urb;
+	int dma_no;
+	int is_xfer_start;
+	int need_zero;
+
+	//struct list_head dma_q_list;
+	//struct list_head ep_q_list;
+	struct list_head enqueue_list;
+	struct list_head dequeue_list;
+	struct list_head finished_list;
+	int status;	//for dequeue
+	int length;
+
+	struct aotg_td td;
+
+	struct scatterlist *cur_sg;
+	int err_count;
+	unsigned long timeout;	/* jiffies + n. */
+
+	/* fixing dma address unaligned to 4 Bytes. */
+	u8 * dma_copy_buf;
+	dma_addr_t dma_addr;	
+
+	/* for debug. */
+	unsigned int seq_info;
+} __attribute__ ((aligned (4)));
+
+struct aotg_dma_buf { 
+	unsigned int size;
+	u8 * buf;
+	dma_addr_t dma;	
+	int in_using;
+};
+
+struct aotg_hcd { 
+	int	id;
+	spinlock_t lock;
+	spinlock_t tasklet_lock;
+	int check_trb_mutex;
+	volatile int tasklet_retry;
+	void __iomem *base;
+	struct device *dev;
+	struct aotg_plat_data  *port_specific;
+	struct proc_dir_entry *pde; 
+	enum   usb_device_speed  speed; 
+	int    inserted;	/*imply a USB deivce inserting in MiniA receptacle*/ 
+	u32 port;		/*indicate portstatus and portchange*/
+	enum aotg_rh_state  rhstate;
+
+	int hcd_exiting;
+
+	u16 hcin_dma_ien;
+	u16 hcout_dma_ien;
+	
+	/* when using hub, every usb device need a ep0 hcep data struct, but share the same hcd ep0. */
+	struct aotg_hcep    *active_ep0;
+	int ep0_block_cnt;
+	struct aotg_hcep    *ep0[MAX_EP_NUM];
+	struct aotg_hcep	*inep[MAX_EP_NUM];   // 0 for reserved
+	struct aotg_hcep	*outep[MAX_EP_NUM];  // 0 for reserved
+
+	struct list_head hcd_enqueue_list;
+	struct list_head hcd_dequeue_list;
+	struct list_head hcd_finished_list;
+	struct tasklet_struct urb_tasklet;
+
+	struct timer_list hotplug_timer;
+	struct timer_list check_trb_timer;
+	struct timer_list trans_wait_timer;
+	ulong fifo_map[AOTG_MAX_FIFO_SIZE/ALLOC_FIFO_UNIT];
+
+	int discon_happened;
+	int put_aout_msg;
+	int suspend_request_pend;
+	int uhc_irq;
+	
+#ifdef CONFIG_PM	
+#define USB_RESET_DEVICE (0)
+#define USB_RESET_AND_VERIFY_DEVICE	(1)
+	int lr_flag;
+  struct early_suspend earlysuspend;
+
+#	endif
+
+	#define AOTG_QUEUE_POOL_CNT	60
+	struct aotg_queue *queue_pool[AOTG_QUEUE_POOL_CNT];
+	#define AOTG_DMA_BUF_CNT	8
+	struct aotg_dma_buf dma_poll[AOTG_DMA_BUF_CNT];
+}; 
+ 
+struct aotg_hcep { 
+	struct usb_host_endpoint *hep; 
+	struct usb_device *udev; 
+	int index;
+	/* just for ep0, when using hub, every usb device need a ep0 hcep data struct, but share the same hcd ep0. */
+	int ep0_index;
+	int iso_packets;
+	u32 maxpacket; 
+	u16 error_count; 
+	u16 length;
+	u8 epnum; 
+	u8 nextpid; 
+	u8 mask; 
+	u8 type;
+	u8 is_out;
+	u8 buftype; 
+	u8 has_hub; 
+	u8 hub_addr; 
+	u8 reg_hcep_splitcs_val; 
+
+	void __iomem *reg_hcepcs; 
+	void __iomem *reg_hcepcon; 
+   	void __iomem *reg_hcepctrl; 
+	void __iomem *reg_hcepbc; 
+	void __iomem *reg_hcmaxpck; 
+	void __iomem *reg_hcepaddr; 
+	void __iomem *reg_hcerr;
+	//void __iomem *reg_hcfifo; 
+	void __iomem *reg_hcep_interval;
+	void __iomem *reg_hcep_dev_addr; 
+	void __iomem *reg_hcep_port; 
+	void __iomem *reg_hcep_splitcs; 
+
+	unsigned int urb_enque_cnt; 
+	unsigned int urb_endque_cnt; 
+	unsigned int urb_stop_stran_cnt; 
+	unsigned int urb_unlinked_cnt; 
+
+	u32 dma_bytes;
+	u16 interval; 
+	u16 load; 	/* one packet times in us. */
+
+	//u16 branch; 
+	//struct aotg_hcep *next; 
+	u16 fifo_busy;
+
+	ulong fifo_addr;
+	struct aotg_queue *q;
+
+	struct aotg_ring *ring;
+	struct list_head queue_td_list;
+	struct list_head enring_td_list;
+	struct list_head dering_td_list;
+	
+}; 
+
+#define  get_hcepcon_reg(dir , x , y , z)   ((dir ? x : y) + (z - 1)*8)
+#define  get_hcepcs_reg(dir , x , y , z)   ((dir ? x : y) + (z - 1)*8)
+#define  get_hcepctrl_reg(dir , x , y , z)   ((dir ? x : y) + (z - 1)*4)
+#define  get_hcepbc_reg(dir , x , y , z)   ((dir ? x : y) + (z - 1)*8)
+#define  get_hcepmaxpck_reg(dir , x , y , z)   ((dir ? x : y) + (z - 1)*2)
+#define  get_hcepaddr_reg(dir , x , y , z)  ((dir ? x : y) + (z - 1)*4)
+//#define  get_hcfifo_reg(x , z)   (x + (z - 1)*4)
+#define  get_hcep_dev_addr_reg(dir , x , y , z)  ((dir ? x : y) + (z - 1)*8)
+#define  get_hcep_port_reg(dir , x , y , z)  ((dir ? x : y) + (z - 1)*8)
+#define  get_hcep_splitcs_reg(dir , x , y , z)  ((dir ? x : y) + (z - 1)*8)
+
+#define AOTG_DMA_OUT_PREFIX		0x10
+#define AOTG_DMA_NUM_MASK		0xf
+#define AOTG_IS_DMA_OUT(x)		((x) & AOTG_DMA_OUT_PREFIX)
+#define AOTG_GET_DMA_NUM(x)		((x) & AOTG_DMA_NUM_MASK)
+
+#define GET_DMALINKADDR_REG(dir, x, y, z) ((dir ? x : y) + (z - 1) * 0x10)
+#define GET_CURADDR_REG(dir, x, y, z) ((dir ? x : y) + (z - 1) * 0x10)
+#define GET_DMACTRL_REG(dir, x, y, z) ((dir ? x : y) + (z - 1) * 0x10)
+#define GET_DMACOMPLETE_CNT_REG(dir, x, y, z) ((dir ? x : y) + (z - 1) * 0x10)
+
+
+static inline struct aotg_hcd *hcd_to_aotg(struct usb_hcd *hcd) 
+{ 
+	return (struct aotg_hcd *) (hcd->hcd_priv); 
+}
+
+static inline void aotg_clear_all_overflow_irq(struct aotg_hcd *acthcd)
+{
+	unsigned int irq_pend = 0; 
+	
+	irq_pend = readl(acthcd->base + HCDMAxOVERFLOWIRQ);
+	
+	if (irq_pend) {
+		writel(irq_pend, acthcd->base + HCDMAxOVERFLOWIRQ);		
+	}
+	return;
+}
+
+static inline void aotg_clear_all_shortpkt_irq(struct aotg_hcd *acthcd)
+{
+	unsigned int irq_pend = 0;
+
+	irq_pend = readw(acthcd->base + HCINxSHORTPCKIRQ0);
+
+	if (irq_pend) {
+		writew(irq_pend, acthcd->base + HCINxSHORTPCKIRQ0);
+	}
+	return;
+}
+
+static inline void aotg_enable_irq(struct aotg_hcd *acthcd)
+{
+	writeb(USBEIRQ_USBIEN, acthcd->base + USBEIRQ);
+	usb_setbitsb(USBEIRQ_USBIEN, acthcd->base + USBEIEN);
+	usb_setbitsb(0x1<<2, acthcd->base + OTGIEN);
+
+	printk("USBEIEN(0x%p): 0x%02X\n", acthcd->base + USBEIEN, readb(acthcd->base + USBEIEN));
+	usb_setbitsb(OTGCTRL_BUSREQ, acthcd->base + OTGCTRL);	
+}
+
+static inline void aotg_disable_irq(struct aotg_hcd *acthcd)
+{
+	writeb(USBEIRQ_USBIEN, acthcd->base + USBEIRQ);
+	usb_clearbitsb(USBEIRQ_USBIEN, acthcd->base + USBEIEN);
+	usb_clearbitsb(0x1<<2, acthcd->base + OTGIEN);
+	usb_clearbitsb(OTGCTRL_BUSREQ, acthcd->base + OTGCTRL);	
+}
+
+static inline void aotg_clear_all_zeropkt_irq(struct aotg_hcd *acthcd)
+{
+	unsigned int irq_pend = 0;
+
+	irq_pend = readw(acthcd->base + HCINxZEROPCKIEN0);
+
+	if (irq_pend) {
+		writew(irq_pend, acthcd->base + HCINxZEROPCKIEN0);
+	}
+	return;
+}
+
+static inline void aotg_clear_all_hcoutdma_irq(struct aotg_hcd *acthcd)
+{
+	unsigned int irq_pend = 0;
+
+	irq_pend = readw(acthcd->base + HCOUTxDMAIRQ0);
+
+	if (irq_pend) {
+		writew(irq_pend, acthcd->base + HCOUTxDMAIRQ0);
+	}
+	return;
+}
+
+static inline void aotg_hcep_reset(struct aotg_hcd *acthcd, u8 ep_mask, u8 type_mask)
+{
+	u8 val;
+
+	writeb(ep_mask, acthcd->base + ENDPRST);	/*select ep */
+	val = ep_mask | type_mask;
+	writeb(val, acthcd->base + ENDPRST);	/*reset ep */
+	return;
+}
+ 
+static inline struct usb_hcd *aotg_to_hcd(struct aotg_hcd *acthcd) 
+{ 
+	return container_of((void *)acthcd, struct usb_hcd, hcd_priv); 
+}
+
+void aotg_hub_trans_wait_timer(unsigned long data);
+void aotg_hub_hotplug_timer(unsigned long data);
+int aotg_hcd_init(struct usb_hcd *hcd, struct platform_device *pdev);
+void aotg_check_trb_timer(unsigned long data);
+void aotg_power_onoff(int id,int on_off);
+void aotg_hcd_dump_td(struct aotg_ring *ring, struct aotg_td *td);
+struct aotg_ring *aotg_alloc_ring(struct aotg_hcd *acthcd,
+				struct aotg_hcep *ep, unsigned int num_trbs, 
+				gfp_t mem_flags);
+void aotg_free_ring(struct aotg_hcd *acthcd, struct aotg_ring *ring);
+void enable_overflow_irq(struct aotg_hcd *acthcd, struct aotg_hcep *ep);
+
+void dequeue_td(struct aotg_ring *ring, struct aotg_td *td, int dequeue_flag);
+int aotg_ring_enqueue_td(struct aotg_hcd *acthcd, 
+				struct aotg_ring *ring, struct aotg_td *td);
+int aotg_ring_dequeue_td(struct aotg_hcd *acthcd, struct aotg_ring *ring, 
+			struct aotg_td *td, int dequeue_flag);
+int aotg_ring_enqueue_isoc_td(struct aotg_hcd *acthcd, 
+				struct aotg_ring *ring, struct aotg_td *td);
+int aotg_ring_enqueue_intr_td(struct aotg_hcd *acthcd, struct aotg_ring *ring, 
+							struct aotg_hcep *ep, struct urb *urb, gfp_t mem_flags);
+int aotg_ring_dequeue_intr_td(struct aotg_hcd *acthcd, struct aotg_hcep *ep,
+			struct aotg_ring *ring,	struct aotg_td *td);
+void aotg_intr_dma_pool_destroy(struct aotg_ring *ring);
+void aotg_intr_dma_buf_free(struct aotg_hcd *acthcd, struct aotg_ring *ring);
+
+struct aotg_td *aotg_alloc_td(gfp_t mem_flags);
+void aotg_release_td(struct aotg_td *td);
+
+int is_ring_running(struct aotg_ring *ring);
+void aotg_start_ring(struct aotg_ring *ring, u32 addr);
+void aotg_stop_ring(struct aotg_ring *ring);
+u32 ring_trb_virt_to_dma(struct aotg_ring *ring, 
+							struct aotg_trb *trb_vaddr);
+
+void aotg_ring_irq_handler(struct aotg_hcd *acthcd);
+
+void aotg_dump_linklist_reg_2(struct aotg_hcd *acthcd, int dmanr);
+
+int intr_finish_td(struct aotg_hcd *acthcd, struct aotg_ring *ring, struct aotg_td *td);
+void dequeue_intr_td(struct aotg_ring *ring, struct aotg_td *td);
+void aotg_reorder_intr_td( struct aotg_hcep *ep);
+int aotg_intr_chg_buf_len(struct aotg_hcd *acthcd, struct aotg_ring *ring, int len);
+int aotg_intr_get_finish_trb(struct aotg_ring *ring);
+void aotg_reorder_iso_td(struct aotg_hcd *acthcd, struct aotg_ring *ring);
+void handle_ring_dma_tx(struct aotg_hcd *acthcd, unsigned int irq_mask);
+
+#endif /* __LINUX_USB_HOST_AOTG_H */ 
+ 
diff --git a/drivers/usb/aotg/aotg_hcd_debug.c b/drivers/usb/aotg/aotg_hcd_debug.c
new file mode 100755
index 0000000..198e8ca
--- /dev/null
+++ b/drivers/usb/aotg/aotg_hcd_debug.c
@@ -0,0 +1,980 @@
+/*
+ * (C) Copyright www.actions-semi.com 2012-2014
+ *     Written by houjingkun. <houjingkun@actions-semi.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/highmem.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/hcd.h>
+#include <linux/timer.h>
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/../../fs/proc/internal.h>
+
+#include <mach/hardware.h>
+#include <linux/gpio.h>
+
+#include "aotg_hcd.h"
+#include "aotg_regs.h"
+#include "aotg_plat_data.h"
+//#include "aotg_dma.h"
+#include "aotg_hcd_debug.h"
+
+
+char aotg_hcd_proc_sign = 'n';
+unsigned int aotg_trace_onff = 0;
+
+void aotg_dbg_proc_output_ep(void)
+{
+	return;
+}
+
+void aotg_dbg_output_info(void)
+{
+	return;
+}
+
+void aotg_dbg_put_q(struct aotg_queue *q, unsigned int num, unsigned int type, unsigned int len)
+{
+	return;
+}
+
+void aotg_dbg_finish_q(struct aotg_queue *q)
+{
+	return;
+}
+
+void aotg_dump_ep_reg(struct aotg_hcd *acthcd, int ep_index, int is_out)
+{
+	int index_multi = ep_index - 1;
+	if (NULL == acthcd) {
+		ACT_HCD_ERR
+		return;
+	}
+
+	if (ep_index > 15) {
+		printk("ep_index : %d too big, err!\n", ep_index);
+		return;
+	}	
+	
+	printk("=== dump hc-%s ep%d reg info ===\n",
+		is_out ? "out" : "in", ep_index);
+
+	if (ep_index == 0) {
+		printk(" HCIN0BC(0x%p) : 0x%X\n",
+	            acthcd->base + HCIN0BC, usb_readb(acthcd->base + HCIN0BC));
+		printk(" EP0CS(0x%p) : 0x%X\n",
+	            acthcd->base + EP0CS, usb_readb(acthcd->base + EP0CS));
+		printk(" HCOUT0BC(0x%p) : 0x%X\n",
+	            acthcd->base + HCOUT0BC, usb_readb(acthcd->base + HCOUT0BC));
+		printk(" HCEP0CTRL(0x%p) : 0x%X\n",
+	            acthcd->base + HCEP0CTRL, usb_readb(acthcd->base + HCEP0CTRL));
+		printk(" HCIN0ERR(0x%p) : 0x%X\n",
+				acthcd->base + HCIN0ERR, usb_readb(acthcd->base + HCIN0ERR));
+		return;
+	}
+	
+	if (is_out) {
+		printk(" HCOUT%dBC(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCOUT1BC + index_multi * 0x8,
+			usb_readw(acthcd->base + HCOUT1BC+ index_multi *0x8));	
+		printk(" HCOUT%dCON(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCOUT1CON + index_multi * 0x8,
+			usb_readb(acthcd->base + HCOUT1CON + index_multi *0x8));
+		printk(" HCOUT%dCS(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCOUT1CS + index_multi * 0x8,
+			usb_readb(acthcd->base + HCOUT1CS + index_multi *0x8));
+		printk(" HCOUT%dCTRL(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCOUT1CTRL + index_multi * 0x4,
+			usb_readb(acthcd->base + HCOUT1CTRL + index_multi *0x4));
+		printk(" HCOUT%dERR(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCOUT1ERR + index_multi * 0x4,
+			usb_readb(acthcd->base + HCOUT1ERR + index_multi *0x4));
+		printk(" HCOUT%dSTADDR(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCOUT1STADDR + index_multi * 0x4,
+			usb_readl(acthcd->base + HCOUT1STADDR + index_multi * 0x4));
+		printk(" HCOUT%dMAXPCK(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCOUT1MAXPCK + index_multi * 0x2,
+			usb_readw(acthcd->base + HCOUT1MAXPCK + index_multi * 0x2));
+		
+		printk(" HCOUT%dDMASTADDR(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCOUT1DMASTADDR + index_multi * 0x8,
+			usb_readl(acthcd->base + HCOUT1DMASTADDR + index_multi * 0x8));
+		printk(" HCOUT%dDMACOUNTER(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCOUT1DMACOUNTER + index_multi * 0x8,
+			usb_readl(acthcd->base + HCOUT1DMACOUNTER + index_multi * 0x8));
+	} else {
+		printk(" HCIN%dBC(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCIN1BC + index_multi * 0x8,
+			usb_readw(acthcd->base + HCIN1BC + index_multi *0x8));
+		printk(" HCIN%dCON(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCIN1CON+ index_multi * 0x8,
+			usb_readb(acthcd->base + HCIN1CON+ index_multi *0x8));
+		printk(" HCIN%dCS(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCIN1CS + index_multi * 0x8,
+			usb_readb(acthcd->base + HCIN1CS + index_multi *0x8));
+		printk(" HCIN%dCS(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCIN1CTRL + index_multi * 0x4,
+			usb_readb(acthcd->base + HCIN1CTRL+ index_multi *0x4));
+		printk(" HCIN%dERR(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCIN1ERR + index_multi * 0x4,
+			usb_readb(acthcd->base + HCIN1ERR + index_multi *0x4));
+		printk(" HCIN%dSTADDR(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCIN1STADDR + index_multi * 0x4,
+			usb_readl(acthcd->base + HCIN1STADDR + index_multi *0x4));
+		printk(" HCIN%dMAXPCK(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCIN1MAXPCK + index_multi * 0x2,
+			usb_readw(acthcd->base + HCIN1MAXPCK + index_multi * 0x2));
+
+		printk(" HCIN%dDMASTADDR(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCIN1DMASTADDR + index_multi * 0x8,
+			usb_readl(acthcd->base + HCIN1DMASTADDR + index_multi * 0x8));
+		printk(" HCIN%dDMACOUNTER(0x%p) : 0x%X\n", ep_index,
+			acthcd->base + HCIN1DMACOUNTER + index_multi * 0x8,
+			usb_readl(acthcd->base + HCIN1DMACOUNTER + index_multi * 0x8));
+	}
+
+}
+
+#ifdef AOTG_REG_DUMP
+void aotg_dbg_regs(struct aotg_hcd *acthcd)
+{
+    struct aotg_plat_data *data = acthcd->port_specific;
+#if 1
+	int i = 0;
+
+	do {
+		printk(" USB reg(0x%p):0x%X  ", acthcd->base + i, usb_readl(acthcd->base + i));
+		i += 4;
+		printk(":0x%X ", usb_readl(acthcd->base + i));
+		i += 4;
+		printk(":0x%X ", usb_readl(acthcd->base + i));
+		i += 4;
+		printk(":0x%X ", usb_readl(acthcd->base + i));
+		i += 4;
+		printk("\n");
+	} while (i < 0x600);
+#endif
+	dev_info(acthcd->dev, "============== aotg regs ==================\n");
+
+  printk("usbecs:0x%X ", usb_readl(data->usbecs));
+#if 1
+	printk(" USBEIRQ(0x%p) : 0x%X\n",
+            acthcd->base + USBEIRQ, usb_readb(acthcd->base + USBEIRQ));
+	printk(" USBEIEN(0x%p) : 0x%X\n",
+            acthcd->base + USBEIEN, usb_readb(acthcd->base + USBEIEN));
+	printk(" SRPCTRL(0x%p) : 0x%X\n",
+            acthcd->base + SRPCTRL, usb_readb(acthcd->base + SRPCTRL));
+
+	printk("HCINxSHORTPCKIRQ0(0x%p) : 0x%X\n",
+            acthcd->base + HCINxSHORTPCKIRQ0 , usb_readb(acthcd->base + HCINxSHORTPCKIRQ0 ));
+	printk("HCINxSHORTPCKIRQ1 (0x%p) : 0x%X\n",
+            acthcd->base + HCINxSHORTPCKIRQ1 , usb_readb(acthcd->base + HCINxSHORTPCKIRQ1 ));
+	printk("HCINxSHORTPCKIEN0 (0x%p) : 0x%X\n",
+            acthcd->base + HCINxSHORTPCKIEN0 , usb_readb(acthcd->base + HCINxSHORTPCKIEN0 ));
+	printk("HCINxSHORTPCKIEN1 (0x%p) : 0x%X\n",
+            acthcd->base + HCINxSHORTPCKIEN1 , usb_readb(acthcd->base + HCINxSHORTPCKIEN1 ));
+
+	printk("HCINxERRIRQ0(0x%p) : 0x%X\n",
+            acthcd->base + HCINxERRIRQ0, usb_readw(acthcd->base + HCINxERRIRQ0));
+
+	printk(" OTGIRQ(0x%p) : 0x%X\n",
+            acthcd->base + OTGIRQ, usb_readb(acthcd->base + OTGIRQ));
+	printk(" OTGSTATE(0x%p) : 0x%X\n",
+            acthcd->base + OTGSTATE, usb_readb(acthcd->base + OTGSTATE));
+	printk(" OTGCTRL(0x%p) : 0x%X\n",
+            acthcd->base + OTGCTRL, usb_readb(acthcd->base + OTGCTRL));
+	printk(" OTGSTATUS(0x%p) : 0x%X\n",
+            acthcd->base + OTGSTATUS, usb_readb(acthcd->base + OTGSTATUS));
+	printk(" OTGIEN(0x%p) : 0x%X\n",
+            acthcd->base + OTGIEN, usb_readb(acthcd->base + OTGIEN));
+	printk("\n");
+	printk(" BKDOOR(0x%p) : 0x%X\n",
+            acthcd->base + BKDOOR, usb_readb(acthcd->base + BKDOOR));
+	printk(" USBIRQ(0x%p) : 0x%X\n",
+            acthcd->base + USBIRQ, usb_readb(acthcd->base + USBIRQ));
+	printk(" USBIEN(0x%p) : 0x%X\n",
+            acthcd->base + USBIEN, usb_readb(acthcd->base + USBIEN));
+	printk("\n");
+#endif
+
+	printk("HCINxPNGIEN0:%x\n", (u32)usb_readb(acthcd->base + HCINxPNGIEN0));
+	printk(" HCIN1DMACOUNTER(0x%p) : 0x%X\n",
+            acthcd->base + HCIN1DMACOUNTER, usb_readb(acthcd->base + HCIN1DMACOUNTER));
+	printk(" HCIN2DMASTADDR(0x%p) : 0x%X\n",
+            acthcd->base + HCIN2DMASTADDR, usb_readb(acthcd->base + HCIN2DMASTADDR));
+
+	printk(" HCOUTxIRQ0(0x%p) : 0x%X\n",
+            acthcd->base + HCOUTxIRQ0, usb_readb(acthcd->base + HCOUTxIRQ0));
+	printk(" HCOUTxIEN0(0x%p) : 0x%X\n",
+            acthcd->base + HCOUTxIEN0, usb_readb(acthcd->base + HCOUTxIEN0));
+	printk(" HCINxIRQ0(0x%p) : 0x%X\n",
+            acthcd->base + HCINxIRQ0, usb_readb(acthcd->base + HCINxIRQ0));
+	printk(" HCINxIEN0(0x%p) : 0x%X\n",
+            acthcd->base + HCINxIEN0, usb_readb(acthcd->base + HCINxIEN0));
+	printk("\n");
+#if 1
+	printk(" HCIN0BC(0x%p) : 0x%X\n",
+            acthcd->base + HCIN0BC, usb_readb(acthcd->base + HCIN0BC));
+	printk(" EP0CS(0x%p) : 0x%X\n",
+            acthcd->base + EP0CS, usb_readb(acthcd->base + EP0CS));
+	printk(" HCOUT0BC(0x%p) : 0x%X\n",
+            acthcd->base + HCOUT0BC, usb_readb(acthcd->base + HCOUT0BC));
+	printk(" HCEP0CTRL(0x%p) : 0x%X\n",
+            acthcd->base + HCEP0CTRL, usb_readb(acthcd->base + HCEP0CTRL));
+	printk("\n");
+	printk(" HCIN1BC(0x%p) : 0x%X\n",
+            acthcd->base + HCIN1BCL, usb_readw(acthcd->base + HCIN1BCL));
+	printk(" HCIN1CON(0x%p) : 0x%X\n",
+            acthcd->base + HCIN1CON, usb_readb(acthcd->base + HCIN1CON));
+	printk(" HCIN1CS(0x%p) : 0x%X\n",
+            acthcd->base + HCIN1CS, usb_readb(acthcd->base + HCIN1CS));
+	printk(" HCIN1CTRL(0x%p) : 0x%X\n",
+            acthcd->base + HCIN1CTRL, usb_readb(acthcd->base + HCIN1CTRL));
+	printk(" HCIN2BC(0x%p) : 0x%X\n",
+            acthcd->base + HCIN2BCL, usb_readw(acthcd->base + HCIN2BCL));
+	printk(" HCIN2CON(0x%p) : 0x%X\n",
+            acthcd->base + HCIN2CON, usb_readb(acthcd->base + HCIN2CON));
+	printk(" HCIN2CS(0x%p) : 0x%X\n",
+            acthcd->base + HCIN2CS, usb_readb(acthcd->base + HCIN2CS));
+	printk(" HCIN2CTRL(0x%p) : 0x%X\n",
+            acthcd->base + HCIN2CTRL, usb_readb(acthcd->base + HCIN2CTRL));
+	printk("\n");
+	printk(" HCIN4DMASTADDR(0x%p) : 0x%X\n",
+            acthcd->base + HCIN4DMASTADDR, usb_readw(acthcd->base + HCIN4DMASTADDR));
+	printk(" HCIN4DMACOUNTER(0x%p) : 0x%X\n",
+            acthcd->base + HCIN4DMACOUNTER, usb_readw(acthcd->base + HCIN4DMACOUNTER));
+	//printk(" HCINCTRL(0x%p) : 0x%X\n", acthcd->base + HCINCTRL, usb_readb(acthcd->base + HCINCTRL));
+	printk("\n");
+#endif
+	printk(" HCOUT1BC(0x%p) : 0x%X\n",
+            acthcd->base + HCOUT1BCL, usb_readw(acthcd->base + HCOUT1BCL));
+	printk(" HCOUT1CON(0x%p) : 0x%X\n",
+            acthcd->base + HCOUT1CON, usb_readb(acthcd->base + HCOUT1CON));
+	printk(" HCOUT1CS(0x%p) : 0x%X\n",
+            acthcd->base + HCOUT1CS, usb_readb(acthcd->base + HCOUT1CS));
+	printk(" HCOUT1CTRL(0x%p) : 0x%X\n",
+            acthcd->base + HCOUT1CTRL, usb_readb(acthcd->base + HCOUT1CTRL));
+	printk(" HCOUT2BC(0x%p) : 0x%X\n",
+            acthcd->base + HCOUT2BCL, usb_readw(acthcd->base + HCOUT2BCL));
+	printk(" HCOUT2CON(0x%p) : 0x%X\n",
+            acthcd->base + HCOUT2CON, usb_readb(acthcd->base + HCOUT2CON));
+	printk(" HCOUT2CS(0x%p) : 0x%X\n",
+            acthcd->base + HCOUT2CS, usb_readb(acthcd->base + HCOUT2CS));
+	printk(" HCOUT2CTRL(0x%p) : 0x%X\n",
+            acthcd->base + HCOUT2CTRL, usb_readb(acthcd->base + HCOUT2CTRL));
+	printk("\n");
+	printk("\n");
+	return;
+}
+
+#else	/* AOTG_REG_DUMP */
+
+void aotg_dbg_regs(struct aotg_hcd *acthcd)
+{
+	/* fpga5209 dump */
+	printk("dump gl5209 reg\n");
+
+/*
+	printk("CMU_USBPLL(0x%p) : 0x%X\n",
+		acthcd->base + CMU_USBPLL, usb_readl(acthcd->base + CMU_USBPLL));
+	printk("CMU_DEVRST1(0x%p) : 0x%X\n",
+		acthcd->base + CMU_DEVRST1, usb_readl(acthcd->base + CMU_DEVRST1));
+	printk("HCDMABCKDOOR(0x%p) : 0x%X\n",
+		acthcd->base + HCDMABCKDOOR, usb_readl(acthcd->base + HCDMABCKDOOR));
+	printk("USBH_0ECS(0x%p) : 0x%X\n",
+		acthcd->base + USBH_0ECS, usb_readl(acthcd->base + USBH_0ECS));	
+*/
+	printk(" USBEIEN(0x%p) : 0x%X\n",
+            acthcd->base + USBEIEN, usb_readb(acthcd->base + USBEIEN));
+	printk(" OTGIRQ(0x%p) : 0x%X\n",
+            acthcd->base + OTGIRQ, usb_readb(acthcd->base + OTGIRQ));
+	printk(" OTGSTATE(0x%p) : 0x%X\n",
+            acthcd->base + OTGSTATE, usb_readb(acthcd->base + OTGSTATE));
+	printk(" OTGCTRL(0x%p) : 0x%X\n",
+            acthcd->base + OTGCTRL, usb_readb(acthcd->base + OTGCTRL));
+	printk(" OTGSTATUS(0x%p) : 0x%X\n",
+            acthcd->base + OTGSTATUS, usb_readb(acthcd->base + OTGSTATUS));
+	printk(" OTGIEN(0x%p) : 0x%X\n",
+            acthcd->base + OTGIEN, usb_readb(acthcd->base + OTGIEN));
+
+    return;
+}
+
+#endif	/* AOTG_REG_DUMP */
+
+
+#ifdef AOTG_DEBUG_FILE
+
+int aotg_dbg_proc_output_ep_state1(struct aotg_hcd *acthcd)
+{
+	struct aotg_hcep *tmp_ep;
+	int i;
+	struct aotg_queue *q, *next;
+	struct aotg_hcep *ep;
+	struct urb *urb;
+
+	ep = acthcd->active_ep0;
+	if (ep) {
+		printk("------------- active ep0 queue: \n");
+		printk("urb_enque_cnt:%d\n", ep->urb_enque_cnt);
+		printk("urb_endque_cnt:%d\n", ep->urb_endque_cnt);
+		printk("urb_stop_stran_cnt:%d\n", ep->urb_stop_stran_cnt);
+		printk("urb_unlinked_cnt:%d\n", ep->urb_unlinked_cnt);
+
+		if (ep->q != NULL) {
+			q = ep->q;
+			printk("dma[0]: ep->index: %d, type: %d, dir : %s, transfer_buffer_length: %d, actual_length:%d\n",
+				q->ep->index,
+				usb_pipetype(q->urb->pipe), usb_pipeout(q->urb->pipe)?"out":"in",
+				q->urb->transfer_buffer_length, q->urb->actual_length);
+		}
+	}
+
+	for (i = 0; i < MAX_EP_NUM; i++) {
+		ep = acthcd->ep0[i];
+		if (ep) {
+			printk("------------- ep0 list index:%d queue: \n", i);
+			printk("urb_enque_cnt:%d\n", ep->urb_enque_cnt);
+			printk("urb_endque_cnt:%d\n", ep->urb_endque_cnt);
+			printk("urb_stop_stran_cnt:%d\n", ep->urb_stop_stran_cnt);
+			printk("urb_unlinked_cnt:%d\n", ep->urb_unlinked_cnt);
+			printk("ep->epnum:%d\n", ep->epnum);
+
+			if (ep->q != NULL) {
+				q = ep->q;
+				printk("ep->index: %d, type: %d, dir : %s, transfer_buffer_length: %d, actual_length:%d\n",
+					q->ep->index,
+					usb_pipetype(q->urb->pipe), usb_pipeout(q->urb->pipe)?"out":"in",
+					q->urb->transfer_buffer_length, q->urb->actual_length);
+			}
+		}
+	}
+
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		tmp_ep = acthcd->inep[i];
+		if (tmp_ep) {
+			//if (tmp_ep->urb_enque_cnt > (tmp_ep->urb_endque_cnt + tmp_ep->urb_stop_stran_cnt)) 
+			{
+				printk("inep:%d\n", i);
+				printk("urb_enque_cnt:%d\n", tmp_ep->urb_enque_cnt);
+				printk("urb_endque_cnt:%d\n", tmp_ep->urb_endque_cnt);
+				printk("urb_stop_stran_cnt:%d\n", tmp_ep->urb_stop_stran_cnt);
+				printk("urb_unlinked_cnt:%d\n", tmp_ep->urb_unlinked_cnt);
+
+				printk("index:%d\n", tmp_ep->index);
+				printk("maxpacket:%d\n", tmp_ep->maxpacket);
+				printk("epnum:%d\n", tmp_ep->epnum);
+			}
+		}
+	}
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		tmp_ep = acthcd->outep[i];
+		if (tmp_ep) {
+			//if (tmp_ep->urb_enque_cnt > (tmp_ep->urb_endque_cnt + tmp_ep->urb_stop_stran_cnt)) 
+			{
+				printk("outep:%d\n", i);
+				printk("urb_enque_cnt:%d\n", tmp_ep->urb_enque_cnt);
+				printk("urb_endque_cnt:%d\n", tmp_ep->urb_endque_cnt);
+				printk("urb_stop_stran_cnt:%d\n", tmp_ep->urb_stop_stran_cnt);
+				printk("urb_unlinked_cnt:%d\n", tmp_ep->urb_unlinked_cnt);
+
+				printk("index:%d\n", tmp_ep->index);
+				printk("maxpacket:%d\n", tmp_ep->maxpacket);
+				printk("epnum:%d\n", tmp_ep->epnum);
+			}
+		}
+	}
+
+	printk("in hcd enqueue list: \n");
+	list_for_each_entry_safe(q, next, &acthcd->hcd_enqueue_list, enqueue_list) {
+		urb = q->urb;
+		ep = q->ep;
+		printk("ep->epnum:%d ", ep->epnum);
+		printk("urb->transfer_buffer_length:%d ", urb->transfer_buffer_length);
+		printk("usb_pipein(urb->pipe):%x\n", usb_pipein(urb->pipe));
+		printk("usb_pipetype(urb->pipe):%x\n", usb_pipetype(urb->pipe));
+	}
+	return 0;
+}
+
+int aotg_dbg_proc_output_ep_state(struct aotg_hcd *acthcd)
+{
+	struct aotg_queue *q, *next;
+	struct aotg_hcep *ep;
+	struct urb *urb;
+	int i = 0;
+
+	list_for_each_entry_safe(q, next, &acthcd->hcd_enqueue_list, enqueue_list) {
+		urb = q->urb;
+		ep = q->ep;
+		i++;
+	}
+
+	if (i>2) {
+		printk("error, more enque.\n");
+		//aotg_dbg_output_info();
+		//aotg_dbg_regs(acthcd);
+		//BUG_ON(1);
+	}
+	if (i <= 1) {
+		i = 0;
+	}
+	aotg_dbg_proc_output_ep_state1(acthcd);
+	return i;
+}
+
+int aotg_dump_regs(struct aotg_hcd *acthcd)
+{
+	int i;
+	struct aotg_hcep *ep;
+
+	for (i = 0; i < MAX_EP_NUM; i++) {
+		ep = acthcd->inep[i];
+		if (ep) {
+			aotg_dump_linklist_reg_2(acthcd, ep->mask);
+		}
+	}
+
+	for (i = 0; i < MAX_EP_NUM; i++) {
+		ep = acthcd->outep[i];
+		if (ep) {
+			aotg_dump_linklist_reg_2(acthcd, ep->mask);	
+		}
+	}
+
+	return 0;
+
+}
+
+void __dump_ring_info(struct aotg_hcep *ep)
+{
+	int i;
+	struct aotg_ring *ring = NULL;
+	struct aotg_td *td, *next;
+	struct urb *urb;
+	struct aotg_trb *trb;
+
+	//struct aotg_trb trb_val;
+
+	if (!ep)
+		return;
+	printk("\n------------- current %s ep%d ring : \n", ep->is_out ? "OUT" : "IN",
+					ep->index);
+	printk("urb_enque_cnt:%d\n", ep->urb_enque_cnt);
+	printk("urb_endque_cnt:%d\n", ep->urb_endque_cnt);
+	printk("urb_stop_stran_cnt:%d\n", ep->urb_stop_stran_cnt);
+	printk("urb_unlinked_cnt:%d\n", ep->urb_unlinked_cnt);
+	printk("ep_num:%d\n", ep->epnum);
+	printk("ep_type:%d\n", ep->type);
+
+	ring = ep->ring;
+	
+	i=0;
+	if (ring) {
+		trb = ring->first_trb;
+		while(trb <= ring->last_trb) {
+			printk("%d hw_buf_ptr:%x,hw_buf_len:%x,hw_buf_remain:%x,hw_token:%x\n",i, \
+			       trb->hw_buf_ptr,trb->hw_buf_len,trb->hw_buf_remain,trb->hw_token);
+			trb++;
+			i++;
+		}
+		
+	}
+	
+	if (ring) {		
+		printk("-----\n");
+		printk("enring_cnt:%d\n", ring->enring_cnt);
+		printk("dering_cnt:%d\n", ring->dering_cnt);
+		printk("num_trbs_free:%d\n", (u32)atomic_read(&ring->num_trbs_free));
+		printk("first_trb:0x%p, dma:0x%x\n", ring->first_trb, 
+					ring_trb_virt_to_dma(ring, ring->first_trb));
+		printk("last_trb:0x%x, dma:0x%x\n", (u32)(ring->last_trb),
+					ring_trb_virt_to_dma(ring, ring->last_trb));
+		printk("ring_enqueue:0x%x(%d)\n", (u32)(ring->enqueue_trb),
+					ring->enqueue_trb - ring->first_trb);
+		printk("ring_dequeue:0x%x(%d)\n", (u32)(ring->dequeue_trb),
+					ring->dequeue_trb - ring->first_trb);
+		printk("reg_linkaddr(0x%p):0x%x\n", ring->reg_dmalinkaddr,
+					usb_readl(ring->reg_dmalinkaddr));
+		printk("reg_curradr(0x%p):0x%x\n", ring->reg_curaddr,
+					usb_readl(ring->reg_curaddr));
+		printk("reg_dmactrl(0x%p):0x%x\n", ring->reg_dmactrl,
+					usb_readl(ring->reg_dmactrl));
+
+		printk( "in eq_enqueue_td list: \n");
+		i = 0;
+		list_for_each_entry_safe(td, next, &ep->queue_td_list, queue_list) {
+			urb = td->urb;	
+			i++;
+			printk("-----\n");
+			printk("urb->transfer_buffer_length:%d\n", urb->transfer_buffer_length);
+			printk("usb_pipein(urb->pipe):%x\n", usb_pipein(urb->pipe));
+			printk("usb_pipetype(urb->pipe):%x\n", usb_pipetype(urb->pipe));
+		}
+		if (i) {
+			i = 0;
+			printk("======td in queue num : %d\n", i);
+		}
+
+		printk( "in eq_enring_td list: \n");
+		list_for_each_entry_safe(td, next, &ep->enring_td_list, enring_list) {
+			//trb_val = *(td->trb_vaddr);
+			printk("-----\n");
+			i++;
+			trb = td->trb_vaddr;
+			if (td->urb)
+				printk("urb:%p\n",td->urb);
+			printk("hw_buf_ptr:%x,hw_buf_len:%x,hw_buf_remain:%x,hw_token:%x\n", \
+			       trb->hw_buf_ptr,trb->hw_buf_len,trb->hw_buf_remain,trb->hw_token);
+			printk("num_trbs:%d\n", td->num_trbs);
+			//printk("trb_dma:0x%x\n", td->trb_dma);
+			//printk("trb_vaddr:0x%x\n", td->trb_vaddr);
+			//printk("trb_dma:0x%x\n", td->trb_dma);
+			//printk("cross_ring:0x%d\n", td->cross_ring);
+
+			//aotg_hcd_dump_td(ring, td);
+			//printk("hw_buf_ptr : 0x%x\n", trb_val.hw_buf_ptr);
+			//printk("hw_buf_len : %d\n", trb_val.hw_buf_len);
+			//printk("hw_buf_remain : %d\n", trb_val.hw_buf_remain);
+			//printk("hw_token : 0x%x\n", trb_val.hw_token);	
+			//printk("in_dma_irq:0x%x\n",usb_readw(USBH_BASE0 + HCINxDMAIRQ0));
+		}
+		if (i) {
+			printk("======td in ring num : %d\n", i);
+		}
+	}
+ 
+/*
+	seq_printf(s, "------------- current IN ep%d ring : \n", i);
+	seq_printf(s, "urb_enque_cnt:%d\n", ep->urb_enque_cnt);
+	seq_printf(s, "urb_endque_cnt:%d\n", ep->urb_endque_cnt);
+	seq_printf(s, "urb_stop_stran_cnt:%d\n", ep->urb_stop_stran_cnt);
+	seq_printf(s, "urb_unlinked_cnt:%d\n", ep->urb_unlinked_cnt);
+	seq_printf(s, "ep->epnum:%d\n", ep->epnum);
+
+	ring = ep->ring;
+	if (ring) {
+		seq_printf(s, "enring_cnt:%d\n", ring->enring_cnt);
+		seq_printf(s, "dering_cnt:%d\n", ring->dering_cnt);
+		seq_printf(s, "num_trbs_free:%d\n", ring->num_trbs_free);
+		seq_printf(s, "ring_enqueue_ptr:0x%x", ring->enqueue_trb);
+		seq_printf(s, "ring_dequeue_ptr:0x%x", ring->dequeue_trb);
+
+		seq_printf(s, "in eq_enqueue_td list: \n");
+		list_for_each_entry_safe(td, next, &ep->queue_td_list, queue_td_list) {
+			urb = td->urb;
+			seq_printf(s, "urb->transfer_buffer_length:%d ", urb->transfer_buffer_length);
+			seq_printf(s, "usb_pipein(urb->pipe):%x\n", usb_pipein(urb->pipe));
+			seq_printf(s, "usb_pipetype(urb->pipe):%x\n", usb_pipetype(urb->pipe));
+		}
+
+		seq_printf(s, "in eq_enring_td list: \n");
+		list_for_each_entry_safe(td, next, &ep->enring_td_list, enring_list) {
+			seq_printf(s, "num_trbs:%d\n", td->num_trbs);
+			seq_printf(s, "trb_vaddr:0x%x\n", td->trb_vaddr);
+			seq_printf(s, "trb_dma:0x%x\n", td->trb_dma);
+			seq_printf(s, "cross_ring:0x%d\n", td->cross_ring);
+		}
+	}
+*/
+}
+
+static int aotg_hcd_show_ring_info(struct aotg_hcd *acthcd)
+{
+	int i;
+	struct aotg_hcep *ep;
+	struct aotg_queue *q;
+
+	ep = acthcd->active_ep0;
+	if (ep) {
+		printk("------------- active ep0 queue: \n");
+		printk("urb_enque_cnt:%d\n", ep->urb_enque_cnt);
+		printk("urb_endque_cnt:%d\n", ep->urb_endque_cnt);
+		printk("urb_stop_stran_cnt:%d\n", ep->urb_stop_stran_cnt);
+		printk("urb_unlinked_cnt:%d\n", ep->urb_unlinked_cnt);
+
+		if (ep->q != NULL) {
+			q = ep->q;
+			printk("dma[0]: ep->index: %d, type: %d, dir : %s, transfer_buffer_length: %d, actual_length:%d\n",
+				q->ep->index,
+				usb_pipetype(q->urb->pipe), usb_pipeout(q->urb->pipe)?"out":"in",
+				q->urb->transfer_buffer_length, q->urb->actual_length);
+		}
+	}
+
+	for (i = 0; i < MAX_EP_NUM; i++) {
+		ep = acthcd->inep[i];
+		__dump_ring_info(ep);
+	}
+
+	for (i = 0; i < MAX_EP_NUM; i++) {
+		ep = acthcd->outep[i];
+		__dump_ring_info(ep);
+	}
+
+	return 0;
+}
+#if 0
+static int aotg_hcd_show_enque_info(struct seq_file *s, struct aotg_hcd	*acthcd)
+{
+	int i;
+	struct aotg_queue *q, *next;
+	struct aotg_hcep *ep;
+
+	for (i = 0; i < AOTG_QUEUE_POOL_CNT; i++) {
+		if (acthcd->queue_pool[i] != NULL) {
+			seq_printf(s, "queue_pool[%d]->in_using: %d\n", 
+			      	i, acthcd->queue_pool[i]->in_using);
+		} 
+	}
+
+	seq_printf(s, "current dma queue: \n");
+
+	ep = acthcd->active_ep0;
+	if (ep) {
+		seq_printf(s, "------------- active ep0 queue: \n");
+		seq_printf(s, "urb_enque_cnt:%d\n", ep->urb_enque_cnt);
+		seq_printf(s, "urb_endque_cnt:%d\n", ep->urb_endque_cnt);
+		seq_printf(s, "urb_stop_stran_cnt:%d\n", ep->urb_stop_stran_cnt);
+		seq_printf(s, "urb_unlinked_cnt:%d\n", ep->urb_unlinked_cnt);
+
+		if (ep->q != NULL) {
+			q = ep->q;
+			seq_printf(s, "dma[0]: ep->index: %d, type: %d, dir : %s, transfer_buffer_length: %d, actual_length:%d\n",
+				q->ep->index,
+				usb_pipetype(q->urb->pipe), usb_pipeout(q->urb->pipe)?"out":"in",
+				q->urb->transfer_buffer_length, q->urb->actual_length);
+		}
+	}
+
+	for (i = 0; i < MAX_EP_NUM; i++) {
+		ep = acthcd->ep0[i];
+		if (ep) {
+			seq_printf(s, "------------- ep0 list index:%d queue: \n", i);
+			seq_printf(s, "urb_enque_cnt:%d\n", ep->urb_enque_cnt);
+			seq_printf(s, "urb_endque_cnt:%d\n", ep->urb_endque_cnt);
+			seq_printf(s, "urb_stop_stran_cnt:%d\n", ep->urb_stop_stran_cnt);
+			seq_printf(s, "urb_unlinked_cnt:%d\n", ep->urb_unlinked_cnt);
+			seq_printf(s, "ep->epnum:%d\n", ep->epnum);
+
+			if (ep->q != NULL) {
+				q = ep->q;
+				seq_printf(s, "ep->index: %d, type: %d, dir : %s, transfer_buffer_length: %d, actual_length:%d\n",
+					q->ep->index,
+					usb_pipetype(q->urb->pipe), usb_pipeout(q->urb->pipe)?"out":"in",
+					q->urb->transfer_buffer_length, q->urb->actual_length);
+			}
+		}
+	}
+	
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		ep = acthcd->inep[i];
+		if (ep) {
+			seq_printf(s, "------------- current IN ep%d queue: \n", i);
+			seq_printf(s, "urb_enque_cnt:%d\n", ep->urb_enque_cnt);
+			seq_printf(s, "urb_endque_cnt:%d\n", ep->urb_endque_cnt);
+			seq_printf(s, "urb_stop_stran_cnt:%d\n", ep->urb_stop_stran_cnt);
+			seq_printf(s, "urb_unlinked_cnt:%d\n", ep->urb_unlinked_cnt);
+			seq_printf(s, "ep->epnum:%d\n", ep->epnum);
+
+			if (ep->q != NULL) {
+				q = ep->q;
+				seq_printf(s, "ep->index: %d, type: %d, dir : %s, transfer_buffer_length: %d, actual_length:%d\n",
+					q->ep->index,
+					usb_pipetype(q->urb->pipe), usb_pipeout(q->urb->pipe)?"out":"in",
+					q->urb->transfer_buffer_length, q->urb->actual_length);
+			}
+		}
+	}
+	
+	for (i = 1; i < MAX_EP_NUM; i++) {
+		ep = acthcd->outep[i];
+		if (ep) {
+			seq_printf(s, "------------- current OUT ep%d queue: \n", i);
+			seq_printf(s, "urb_enque_cnt:%d\n", ep->urb_enque_cnt);
+			seq_printf(s, "urb_endque_cnt:%d\n", ep->urb_endque_cnt);
+			seq_printf(s, "urb_stop_stran_cnt:%d\n", ep->urb_stop_stran_cnt);
+			seq_printf(s, "urb_unlinked_cnt:%d\n", ep->urb_unlinked_cnt);
+			seq_printf(s, "ep->epnum:%d\n", ep->epnum);
+
+			if (ep->q != NULL) {
+				q = ep->q;
+				seq_printf(s, "ep->index: %d, type: %d, dir : %s, transfer_buffer_length: %d, actual_length:%d\n",
+					q->ep->index,
+					usb_pipetype(q->urb->pipe), usb_pipeout(q->urb->pipe)?"out":"in",
+					q->urb->transfer_buffer_length, q->urb->actual_length);
+			}
+		}
+	}
+
+	seq_printf(s, "\n");
+	seq_printf(s, "in hcd enqueue list: \n");
+	list_for_each_entry_safe(q, next, &acthcd->hcd_enqueue_list, enqueue_list) {
+		ep = q->ep;
+		seq_printf(s, "ep->epnum:%d ", ep->epnum);
+		seq_printf(s, "urb->transfer_buffer_length:%d ", q->urb->transfer_buffer_length);
+		seq_printf(s, "usb_pipein(urb->pipe):%x\n", usb_pipein(q->urb->pipe));
+		seq_printf(s, "usb_pipetype(urb->pipe):%x\n", usb_pipetype(q->urb->pipe));
+	}
+	return 0;
+}
+#endif
+/* 
+ * echo a value to controll the cat /proc/aotg_hcd output content.
+ * echo h>/proc/aotg_hcd.0 to see help info.
+ */
+ssize_t aotg_hcd_proc_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	char c = 'n';
+
+	if (count) {
+		if (get_user(c, buf))
+			return -EFAULT;
+		aotg_hcd_proc_sign = c;
+	}
+	if (c == 'h') {
+		printk(" a ---- all.  \n");
+		printk(" b ---- backup info.  \n");
+		printk(" d ---- dma related.  \n");
+		printk(" e ---- enque and outque info.  \n");
+		printk(" f ---- trace in info.  \n");
+		printk(" h ---- help info.  \n");
+		printk(" n ---- normal.  \n");
+		printk(" r ---- register info.  \n");
+		printk(" s ---- aotg state.  \n");
+		printk(" t ---- trace out info.  \n");
+		printk(" z ---- stop stace.  \n");
+	}
+        return count;
+}
+
+int aotg_hcd_proc_show(struct seq_file *s, void *unused)
+{
+	struct aotg_hcd	*acthcd = s->private;
+	struct usb_hcd *hcd = aotg_to_hcd(acthcd);
+	//struct aotg_plat_data *data = acthcd->port_specific;
+
+	if (aotg_hcd_proc_sign == 'd') {
+		// todo.
+	}
+
+	if (aotg_hcd_proc_sign == 's') {
+		aotg_dbg_proc_output_ep_state(acthcd);
+		seq_printf(s, "hcd state : 0x%08X\n", hcd->state);
+	}
+
+	if (aotg_hcd_proc_sign == 'r') {
+		//aotg_dbg_regs(acthcd);
+		aotg_dump_regs(acthcd);
+	}
+
+	if (aotg_hcd_proc_sign == 'e') {
+		//aotg_hcd_show_enque_info(s, acthcd);
+		aotg_hcd_show_ring_info(acthcd);
+	}
+
+	if (aotg_hcd_proc_sign == 'b') {
+		aotg_dbg_proc_output_ep();
+		aotg_dbg_output_info();
+	}
+
+	if (aotg_hcd_proc_sign == 'a') {
+	}
+
+	seq_printf(s, "\n");
+	return 0;
+}
+
+
+static int aotg_hcd_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, aotg_hcd_proc_show, PDE(inode)->data);
+}
+
+static const struct file_operations proc_ops = {
+	.open		= aotg_hcd_proc_open,
+	.read		= seq_read,
+	.write		= aotg_hcd_proc_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+void create_debug_file(struct aotg_hcd *acthcd)
+{
+	struct device *dev = aotg_to_hcd(acthcd)->self.controller;
+
+	acthcd->pde = proc_create_data(dev_name(dev), 0, NULL, &proc_ops, acthcd);
+	return;
+}
+
+void remove_debug_file(struct aotg_hcd *acthcd)
+{
+	struct device *dev = aotg_to_hcd(acthcd)->self.controller;
+	
+	if (acthcd->pde)
+		remove_proc_entry(dev_name(dev), NULL);
+	return;
+}
+
+#else	/* AOTG_DEBUG_FILE */
+
+void create_debug_file(struct aotg_hcd *acthcd)
+{
+	return;
+}
+
+void remove_debug_file(struct aotg_hcd *acthcd)
+{
+	return;
+}
+
+#endif	/* AOTG_DEBUG_FILE */
+
+
+void aotg_print_xmit_cnt(char * info, int cnt)
+{
+	if (aotg_hcd_proc_sign == 'e') {
+		printk("%s cnt:%d\n", info, cnt);
+	}
+	//printk("\n");
+	//aotg_dbg_proc_output_ep();
+	//aotg_dbg_regs(p_aotg_hcd0);
+	//aotg_dbg_output_info();
+
+	return;
+}
+//EXPORT_SYMBOL(aotg_print_xmit_cnt);
+
+
+static struct proc_dir_entry *acts_hub_pde = NULL; 
+
+int acts_hcd_proc_show(struct seq_file *s, void *unused)
+{
+	seq_printf(s, "hcd_ports_en_ctrl: %d\n", hcd_ports_en_ctrl);
+	return 0;
+}
+
+static int acts_hub_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, acts_hcd_proc_show, PDE(inode)->data);
+}
+
+static ssize_t acts_hub_proc_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	char c = 'n';
+
+	if (count) {
+		if (get_user(c, buf))
+			return -EFAULT;
+	}
+	if ((c >= '0') && (c <= '3')) { 
+		hcd_ports_en_ctrl = c - '0';
+		printk("hcd_hub en:%d\n", hcd_ports_en_ctrl);
+	}
+	if (c == 'h') {
+		printk(" num ---- 0-all enable, 1-usb0 enable, 2-usb1 enable, 3-reversed. \n");
+		printk("o ---- hcd_hub power on\n");
+		printk("f ---- hcd_hub power off\n");
+		printk("a ---- hcd_hub aotg0 add\n");
+		printk("b ---- hcd_hub aotg0 remove\n");
+		printk("c ---- hcd_hub aotg1 add\n");
+		printk("d ---- hcd_hub aotg1 remove\n");
+	}
+
+	if (c == 'a') {
+		printk("hcd_hub aotg0 add\n");
+		//aotg0_device_init(0);
+		aotg_hub_register(0);
+	}
+	if (c == 'b') {
+		printk("hcd_hub aotg0 remove\n");
+		//aotg0_device_exit(0);
+		aotg_hub_unregister(0);
+	}
+
+	if (c == 'c') {
+		printk("hcd_hub aotg1 add\n");
+		//aotg1_device_init(0);
+		aotg_hub_register(1);
+	}
+	if (c == 'd') {
+		printk("hcd_hub aotg1 remove\n");
+		//aotg1_device_exit(0);
+		aotg_hub_unregister(1);
+	}
+
+	if (c == 'e') {
+		aotg_trace_onff = 1;
+	}
+	if (c == 'f') {
+		aotg_trace_onff = 0;
+	}
+	
+	if (c == 'g') {
+		aotg_dbg_regs(act_hcd_ptr[0]); 
+	}
+	
+	if (c == 'i') {
+		aotg_dbg_regs(act_hcd_ptr[1]); 
+	}
+		return count;
+}
+
+static const struct file_operations acts_hub_proc_ops = {
+	.open		= acts_hub_proc_open,
+	.read		= seq_read,
+	.write		= acts_hub_proc_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+void create_acts_hcd_proc(void)
+{
+	acts_hub_pde = proc_create_data("acts_hub", S_IRUSR|S_IWUSR | S_IRGRP|S_IWGRP | S_IROTH|S_IWOTH, NULL, &acts_hub_proc_ops, acts_hub_pde);
+	return;
+}
+
+void remove_acts_hcd_proc(void)
+{
+	if (acts_hub_pde) {
+		remove_proc_entry("acts_hub", NULL);
+		acts_hub_pde = NULL;
+	}
+	return;
+}
+
diff --git a/drivers/usb/aotg/aotg_hcd_debug.h b/drivers/usb/aotg/aotg_hcd_debug.h
new file mode 100755
index 0000000..33c58bc
--- /dev/null
+++ b/drivers/usb/aotg/aotg_hcd_debug.h
@@ -0,0 +1,87 @@
+#ifndef  __LINUX_USB_AOTG_DEBUG_H__ 
+#define  __LINUX_USB_AOTG_DEBUG_H__ 
+
+//#define DEBUG_HCD
+//#define DEBUG_HUB
+//#define DEBUG_SETUP_DATA
+//#define DEBUG_EP_CONFIG
+//#define IN_PROCESS_DEBUG
+//#define DEBUG_IN_DATA
+//#define OUT_PROCESS_DEBUG
+//#define DEBUG_OUT_DATA
+//#define DEBUG_DMA
+#define AOTG_REG_DUMP
+//#define AOTG_DEBUG_RECORD_URB
+#define AOTG_DEBUG_FILE
+#define DEBUG_LINKLIST_DMA
+
+#define ACT_HCD_ERR		printk("%s:%d, err!\n", __func__, __LINE__);
+#define ACT_HCD_DBG		printk("%s:%d, dbg!\n", __func__, __LINE__);
+
+#ifdef  ERR
+#undef  ERR
+#endif
+#define ERR(fmt, args...) printk(KERN_ERR fmt, ## args)
+
+#ifdef DEBUG_HUB
+#define HUB_DEBUG(fmt, args...) printk(KERN_ERR fmt, ## args)
+#else
+#define HUB_DEBUG(fmt, args...) do {} while (0)
+#endif
+
+#ifdef DEBUG_HCD
+#define HCD_DEBUG(fmt, args...) printk(KERN_ERR fmt, ## args)
+#else
+#define HCD_DEBUG(fmt, args...) do {} while (0)
+#endif
+
+#ifdef IN_PROCESS_DEBUG  //ep1, ep2
+#define IN_DEBUG(fmt, args...) printk(KERN_ERR fmt, ## args)
+#else
+#define IN_DEBUG(fmt, args...) do {} while (0)
+#endif
+
+#ifdef  OUT_PROCESS_DEBUG
+#define OUT_DEBUG(fmt, args...) printk(KERN_ERR fmt, ## args)
+#else
+#define OUT_DEBUG(fmt, args...) do {} while (0)
+#endif
+
+#ifdef DEBUG_DMA
+#define ACT_DMA_DEBUG(fmt, args...) printk(KERN_ERR fmt, ## args)
+#else
+#define ACT_DMA_DEBUG(fmt, args...) do {} while (0)
+#endif
+
+#ifdef DEBUG_LINKLIST_DMA
+#define ACT_LINKLIST_DMA_DEBUG(fmt, args...) printk(KERN_ERR fmt, ## args)
+#else
+#define ACT_LINKLIST_DMA_DEBUG(fmt,args...) do {} while(0)
+#endif
+
+#define HCD_WARN(fmt, args...) printk(KERN_WARNING fmt, ## args)
+#define HCD_WARNING(fmt, args...) printk(KERN_WARNING fmt, ## args)
+
+extern unsigned int aotg_trace_onff;
+#define	AOTG_TRACE_ERR_PLACE	if (aotg_trace_onff) printk("-%d\n", __LINE__);
+
+void aotg_dbg_output_info(void);
+
+void aotg_dbg_put_q(struct aotg_queue *q, unsigned int num, unsigned int type, unsigned int len);
+void aotg_dbg_finish_q(struct aotg_queue *q);
+
+void aotg_dbg_proc_output_ep(void);
+int aotg_dbg_proc_output_ep_state(struct aotg_hcd *acthcd);
+
+void create_debug_file(struct aotg_hcd *acthcd);
+void remove_debug_file(struct aotg_hcd *acthcd);
+
+void aotg_dbg_regs(struct aotg_hcd *acthcd);
+
+void create_acts_hcd_proc(void);
+void remove_acts_hcd_proc(void);
+void aotg_dump_ep_reg(struct aotg_hcd *acthcd, int ep_index, int is_out);
+
+
+#endif /* __LINUX_USB_AOTG_DEBUG_H__ */ 
+ 
diff --git a/drivers/usb/aotg/aotg_mon.c b/drivers/usb/aotg/aotg_mon.c
new file mode 100755
index 0000000..78de6b8
--- /dev/null
+++ b/drivers/usb/aotg/aotg_mon.c
@@ -0,0 +1,381 @@
+/*
+ * (C) Copyright www.actions-semi.com 2012-2014
+ *	   Written by houjingkun. <houjingkun@actions-semi.com>
+ * 
+ * This	program	is free	software; you can redistribute it and/or modify	it
+ * under the terms of the GNU General Public License as	published by the
+ * Free	Software Foundation; either	version	2 of the License, or (at your
+ * option) any later version.
+ *
+ * This	program	is distributed in the hope that	it will	be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A	PARTICULAR PURPOSE.	 See the GNU General Public	License
+ * for more	details.
+ *
+ * You should have received	a copy of the GNU General Public License
+ * along with this program;	if not,	write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139,	USA.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/kthread.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/highmem.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/hcd.h>
+
+#include <asm/irq.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <linux/clk.h>
+#include <linux/wakelock.h>
+#include <linux/suspend.h>
+#include <mach/debug.h>
+#include <asm/prom.h>
+#include <mach/gpio.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <mach/powergate.h>
+
+#include "aotg_hcd.h"
+#include "aotg_regs.h"
+#include "aotg_plat_data.h"
+#include "aotg_hcd_debug.h"
+
+//int aotg_device_init(int dev_id);
+int aotg_hub_register(int dev_id);
+void aotg_hub_unregister(int dev_id);
+//void aotg_device_exit(int dev_id);
+void aotg_power_onoff(int id,int on_off);
+
+
+/* usbecs register. */
+#define	USB2_ECS_VBUS_P0		10
+#define	USB2_ECS_ID_P0			12
+#define USB2_ECS_LS_P0_SHIFT	8
+#define USB2_ECS_LS_P0_MASK		(0x3<<8)
+#define USB2_ECS_DPPUEN_P0     3
+#define USB2_ECS_DMPUEN_P0     2
+//#define USB2_ECS_DMPDDIS_P0    1
+//#define USB2_ECS_DPPDDIS_P0    0
+#define USB2_ECS_SOFTIDEN_P0   26
+#define USB2_ECS_SOFTID_P0     27
+#define USB2_ECS_SOFTVBUSEN_P0 24
+#define USB2_ECS_SOFTVBUS_P0   25
+
+
+int port_host_plug_detect[2] = {0};
+extern int is_ls_device[2];
+extern int vbus_otg_en_gpio[2][2];
+extern struct of_device_id aotg_of_match[];
+struct aotg_uhost_mon_t * aotg_uhost_mon0 = NULL;
+struct aotg_uhost_mon_t * aotg_uhost_mon1 = NULL;
+
+int usb2_set_dp_500k_15k(struct aotg_uhost_mon_t * umon, int enable_500k_up, int enable_15k_down)
+{
+	unsigned int val;
+	
+	val = readl(umon->usbecs) & (~((1 << USB2_ECS_DPPUEN_P0) |
+			(1 << USB2_ECS_DMPUEN_P0)));
+			
+	if (enable_500k_up != 0) {
+		val |= (1 << USB2_ECS_DPPUEN_P0)|(1 << USB2_ECS_DMPUEN_P0);
+	}
+	/*if (enable_15k_down == 0) {
+		val |= (1 << USB2_ECS_DPPDDIS_P0)|(1 << USB2_ECS_DMPDDIS_P0);
+	}*/
+	
+	writel(val, umon->usbecs);	/* 500k up enable, 15k down disable; */
+	return 0;		
+}
+
+/* return dp, dm state. */
+static inline unsigned int usb_get_linestates(struct aotg_uhost_mon_t * umon)
+{
+	unsigned int state;
+
+	state = ((readl(umon->usbecs) & USB2_ECS_LS_P0_MASK) >> USB2_ECS_LS_P0_SHIFT);
+	return state;
+}
+
+static void aotg_uhost_mon_timer(unsigned long data)
+{
+	static int cnt = 0;
+	struct aotg_uhost_mon_t * umon = (struct aotg_uhost_mon_t *)data;
+
+	if ((!umon) || (!umon->aotg_uhost_det)) {
+		return;
+	}
+	umon->state = usb_get_linestates(umon);
+
+	cnt++;
+	if ((cnt % 16) == 0) {
+		//printk("umon%d->state:%x\n",umon->id, umon->state);
+		//printk("(usbces%d:%x)=%x\n",umon->id,umon->usbecs,readl(umon->usbecs));
+	}
+
+	if (umon->state != 0) {
+		//printk("umon%d->state:%x\n", umon->id, umon->state);
+		//printk("(usbces%d:%x)=%x\n",umon->id,umon->usbecs,readl(umon->usbecs));
+		if ((umon->state == umon->old_state) && (umon->state != 0x3)) {
+			umon->aotg_uhost_det = 0;
+			umon->old_state = 0;
+			if(umon->state==2) 
+				is_ls_device[umon->id]=1;
+			queue_delayed_work(umon->aotg_dev_onoff, &umon->aotg_dev_init, msecs_to_jiffies(1));
+			return;
+		}
+	}
+
+	umon->old_state = umon->state;
+	mod_timer(&umon->hotplug_timer, jiffies + msecs_to_jiffies(500));
+	return;
+}
+
+static void aotg_dev_register(struct work_struct *w)
+{
+	struct aotg_uhost_mon_t *umon = container_of(w, struct aotg_uhost_mon_t, aotg_dev_init.work);
+
+	/*if (umon->id == 0) {
+		aotg0_device_init(0);
+	} else {
+		aotg1_device_init(0);
+	}*/
+	if (umon->id) {
+		usb_clearbitsl(USB2_PLL_EN1,aotg_uhost_mon1->usbpll);
+		owl_powergate_power_off(OWL_POWERGATE_USB2_1);
+	} else {
+		usb_clearbitsl(USB2_PLL_EN0,aotg_uhost_mon0->usbpll);
+		owl_powergate_power_off(OWL_POWERGATE_USB2_0);
+	}
+	wake_lock_timeout(&umon->aotg_wake_lock, 15*HZ);
+	aotg_hub_register(umon->id);
+	return;
+}
+
+static void aotg_dev_unregister(struct work_struct *w)
+{
+	struct aotg_uhost_mon_t *umon = container_of(w, struct aotg_uhost_mon_t, aotg_dev_exit.work);
+
+	lock_system_sleep();
+	wake_lock_timeout(&umon->aotg_wake_lock, 15*HZ);
+	unlock_system_sleep();
+
+	aotg_hub_unregister(umon->id);
+	umon->aotg_uhost_det = 1;
+	if (umon->id) {
+		owl_powergate_power_on(OWL_POWERGATE_USB2_1);
+		usb_setbitsl(USB2_PLL_EN1,aotg_uhost_mon1->usbpll);
+		usb_setbitsl(USB2_PHYCLK_EN1,aotg_uhost_mon1->usbpll);
+		usb_setbitsl(USB2_ECS_PLL_LDO_EN,aotg_uhost_mon1->usbecs);
+		usb2_set_dp_500k_15k(aotg_uhost_mon1, 0, 1);
+		is_ls_device[1]=0;
+	} else {
+		owl_powergate_power_on(OWL_POWERGATE_USB2_0);
+		usb_setbitsl(USB2_PLL_EN0,aotg_uhost_mon0->usbpll);
+		usb_setbitsl(USB2_PHYCLK_EN0,aotg_uhost_mon0->usbpll);
+		usb_setbitsl(USB2_ECS_PLL_LDO_EN,aotg_uhost_mon0->usbecs);
+		usb2_set_dp_500k_15k(aotg_uhost_mon0, 0, 1);
+		is_ls_device[0]=0;
+	}
+
+	mod_timer(&umon->hotplug_timer, jiffies + msecs_to_jiffies(1000));
+	return;
+}
+
+void aotg_dev_plugout_msg(int id)
+{
+	struct aotg_uhost_mon_t *umon = NULL;
+
+	printk("usb%d had been plugged out!\n",id);
+	if ((id == 0) && aotg_uhost_mon0) {
+		umon = aotg_uhost_mon0;
+	} else if ((id == 1) && aotg_uhost_mon1) {
+		umon = aotg_uhost_mon1;
+	} else {
+		ACT_HCD_DBG
+		return;
+	}
+
+	umon->old_state = 0;
+	queue_delayed_work(umon->aotg_dev_onoff, &umon->aotg_dev_exit, msecs_to_jiffies(1000));
+	return;
+}
+
+static struct aotg_uhost_mon_t * aotg_uhost_mon_alloc(void)
+{
+	struct aotg_uhost_mon_t *umon = NULL;
+
+	umon = kzalloc(sizeof(*umon), GFP_KERNEL);
+	if (!umon)
+		return NULL;
+
+	init_timer(&umon->hotplug_timer);
+	umon->hotplug_timer.function = aotg_uhost_mon_timer;
+	umon->hotplug_timer.data = (unsigned long)umon;
+
+	INIT_DELAYED_WORK(&umon->aotg_dev_init, aotg_dev_register);
+	INIT_DELAYED_WORK(&umon->aotg_dev_exit, aotg_dev_unregister);
+
+	umon->aotg_uhost_det = 1;
+
+	return umon;
+}
+
+void aotg_uhost_mon_init(void)
+{
+	struct device_node *of_node;
+	enum of_gpio_flags flags;
+	
+	of_node = of_find_compatible_node(NULL, NULL, "actions,owl-usb-2.0-0");
+	if (of_node) {
+		if (!of_find_property(of_node, "port0_host_plug_detect", NULL)) {
+			pr_info("can't find port0_host_plug_detect config\n");
+			port_host_plug_detect[0] = 0;
+		}	else {
+			port_host_plug_detect[0] = be32_to_cpup((const __be32 *)of_get_property(of_node,  "port0_host_plug_detect",NULL));
+		}
+		pr_info("port_host_plug_detect[0]:%d\n", port_host_plug_detect[0]);
+		
+		if (!of_find_property(of_node, "vbus_otg_en_gpio", NULL)) {
+			pr_debug("can't find vbus_otg0_en_gpio config\n");
+			vbus_otg_en_gpio[0][0] = -1;
+		}	else {
+			vbus_otg_en_gpio[0][0] = of_get_named_gpio_flags(of_node,  "vbus_otg_en_gpio",0, &flags);
+			vbus_otg_en_gpio[0][1] = flags & 0x01;
+			if (gpio_request(vbus_otg_en_gpio[0][0], aotg_of_match[0].compatible))
+				pr_debug("fail to request vbus gpio [%d]\n", vbus_otg_en_gpio[0][0]);
+			if (port_host_plug_detect[0] != 2)
+				gpio_direction_output(vbus_otg_en_gpio[0][0], !!port_host_plug_detect[0]);
+		}
+		pr_info("port0_vubs_en:%d\n",vbus_otg_en_gpio[0][0]);
+	}
+	else {
+		pr_debug("can't find usbh0 dts node\n");
+	}
+	
+	of_node = of_find_compatible_node(NULL, NULL, "actions,owl-usb-2.0-1");
+	if (of_node) {
+		if (!of_find_property(of_node, "port1_host_plug_detect", NULL)) {
+			pr_info("can't find port1_host_plug_detect config\n");
+			port_host_plug_detect[1] = 0;
+		}	else {
+			port_host_plug_detect[1] = be32_to_cpup((const __be32 *)of_get_property(of_node,  "port1_host_plug_detect",NULL));
+		}
+		pr_info("port_host_plug_detect[1]:%d\n", port_host_plug_detect[1]);
+		
+		if (!of_find_property(of_node, "vbus_otg_en_gpio", NULL)) {
+			printk("can't find vbus_otg1_en_gpio config\n");
+			vbus_otg_en_gpio[1][0] = -1;
+		}	else {
+			vbus_otg_en_gpio[1][0] = of_get_named_gpio_flags(of_node,  "vbus_otg_en_gpio",0, &flags);
+			vbus_otg_en_gpio[1][1] = flags & 0x01;
+			if (gpio_request(vbus_otg_en_gpio[1][0], aotg_of_match[1].compatible))
+				pr_debug("fail to request vbus gpio [%d]\n", vbus_otg_en_gpio[1][0]);
+			if (port_host_plug_detect[1] != 2)
+				gpio_direction_output(vbus_otg_en_gpio[1][0], !!port_host_plug_detect[1]);
+		}
+		pr_info("port1_vubs_en:%d\n",vbus_otg_en_gpio[1][0]);
+	}
+	else {
+		pr_debug("can't find usbh1 dts node\n");
+	}
+	
+	if (port_host_plug_detect[0]) {
+		aotg_uhost_mon0 = aotg_uhost_mon_alloc();
+		aotg_uhost_mon0->id = 0;
+		aotg_uhost_mon0->aotg_dev_onoff = create_singlethread_workqueue("aotg_dev0_onoff");
+		aotg_uhost_mon0->usbecs = (void __iomem *)IO_ADDRESS(USBH0_ECS);
+		aotg_uhost_mon0->usbpll = (void __iomem *)IO_ADDRESS(CMU_USBPLL);
+
+		if (aotg_udc_enable[0])
+			aotg_udc_exit(0);
+		owl_powergate_power_on(OWL_POWERGATE_USB2_0);
+		usb_setbitsl(USB2_PLL_EN0,aotg_uhost_mon0->usbpll);
+		usb_setbitsl(USB2_PHYCLK_EN0,aotg_uhost_mon0->usbpll);
+		usb_setbitsl(USB2_ECS_PLL_LDO_EN,aotg_uhost_mon0->usbecs);
+		usb2_set_dp_500k_15k(aotg_uhost_mon0, 0, 1);
+		wake_lock_init(&aotg_uhost_mon0->aotg_wake_lock, WAKE_LOCK_SUSPEND, "aotg_wake_lock0");
+		printk("start mon 0 ......\n");
+		mod_timer(&aotg_uhost_mon0->hotplug_timer, jiffies + msecs_to_jiffies(10000));
+	}
+	if (port_host_plug_detect[1]) {
+		aotg_uhost_mon1 = aotg_uhost_mon_alloc();
+		aotg_uhost_mon1->id = 1;
+		aotg_uhost_mon1->aotg_dev_onoff = create_singlethread_workqueue("aotg_dev1_onoff");
+		aotg_uhost_mon1->usbecs = (void __iomem *)IO_ADDRESS(USBH1_ECS);
+		aotg_uhost_mon1->usbpll = (void __iomem *)IO_ADDRESS(CMU_USBPLL);
+
+		if (aotg_udc_enable[1])
+			aotg_udc_exit(1);
+		owl_powergate_power_on(OWL_POWERGATE_USB2_1);
+		usb_setbitsl(USB2_PLL_EN1,aotg_uhost_mon1->usbpll);
+		usb_setbitsl(USB2_PHYCLK_EN1,aotg_uhost_mon1->usbpll);
+		usb_setbitsl(USB2_ECS_PLL_LDO_EN,aotg_uhost_mon1->usbecs);
+		usb2_set_dp_500k_15k(aotg_uhost_mon1, 0, 1);
+		wake_lock_init(&aotg_uhost_mon1->aotg_wake_lock, WAKE_LOCK_SUSPEND, "aotg_wake_lock1");
+		printk("start mon 1 ......\n");
+		mod_timer(&aotg_uhost_mon1->hotplug_timer, jiffies + msecs_to_jiffies(1000));
+	}
+
+	return;
+}
+
+static int inline aotg_uhost_mon_free(struct aotg_uhost_mon_t *umon)
+{
+	if (!umon)
+		return -1;
+
+	if (umon->id) {
+		usb_clearbitsl(USB2_PLL_EN1,aotg_uhost_mon1->usbpll);
+		owl_powergate_power_off(OWL_POWERGATE_USB2_1);
+	} else {
+		usb_clearbitsl(USB2_PLL_EN0,aotg_uhost_mon0->usbpll);
+		owl_powergate_power_off(OWL_POWERGATE_USB2_0);
+	}
+	
+	if (umon->aotg_dev_onoff) {
+		cancel_delayed_work_sync(&umon->aotg_dev_init);
+		cancel_delayed_work_sync(&umon->aotg_dev_exit);
+		flush_workqueue(umon->aotg_dev_onoff);
+		destroy_workqueue(umon->aotg_dev_onoff);
+	}
+	wake_unlock(&umon->aotg_wake_lock);
+	del_timer_sync(&umon->hotplug_timer);
+	kfree(umon);
+	return 0;
+}
+
+void aotg_uhost_mon_exit(void)
+{
+	aotg_power_onoff(0,0);
+	aotg_power_onoff(1,0);
+
+	aotg_uhost_mon_free(aotg_uhost_mon0);
+	aotg_uhost_mon_free(aotg_uhost_mon1);
+	aotg_uhost_mon0 = NULL;
+	aotg_uhost_mon1 = NULL;
+	return;
+}
diff --git a/drivers/usb/aotg/aotg_mon.h b/drivers/usb/aotg/aotg_mon.h
new file mode 100755
index 0000000..f502146
--- /dev/null
+++ b/drivers/usb/aotg/aotg_mon.h
@@ -0,0 +1,14 @@
+#ifndef __AOTG_UHOST_MON_H__
+#define __AOTG_UHOST_MON_H__
+
+void aotg_dev_plugout_msg(int id);
+extern int port_host_plug_detect[2];
+extern struct aotg_uhost_mon_t *aotg_uhost_mon0;
+extern struct aotg_uhost_mon_t *aotg_uhost_mon1;
+
+void aotg_uhost_mon_init(void);
+void aotg_uhost_mon_exit(void);
+int usb2_set_dp_500k_15k(struct aotg_uhost_mon_t * umon, int enable_500k_up, int enable_15k_down);
+
+#endif /* __AOTG_UHOST_MON_H__ */
+
diff --git a/drivers/usb/aotg/aotg_plat_data.h b/drivers/usb/aotg/aotg_plat_data.h
new file mode 100755
index 0000000..755fefa
--- /dev/null
+++ b/drivers/usb/aotg/aotg_plat_data.h
@@ -0,0 +1,54 @@
+
+#ifndef __AOTG_PLAT_DATA_H__
+#define __AOTG_PLAT_DATA_H__
+
+#include <linux/wakelock.h>
+
+#define USB2_PLL_EN0           (1<<12)
+#define USB2_PLL_EN1           (1<<13)
+#define USB2_PHYCLK_EN0           (1<<10)
+#define USB2_PHYCLK_EN1           (1<<11)
+#define USB2_ECS_PLL_LDO_EN   (1<<7)
+
+struct aotg_plat_data {
+	void __iomem *usbecs;
+	void __iomem *usbpll;
+	u32 usbpll_bits;
+	void __iomem *devrst;
+	u32 devrst_bits;
+	int no_hs;
+};
+
+struct aotg_uhost_mon_t {
+	int id;
+	void __iomem *usbecs;
+	void __iomem *usbpll;
+
+	struct timer_list hotplug_timer;
+
+	struct workqueue_struct *aotg_dev_onoff;
+	struct delayed_work aotg_dev_init;
+	struct delayed_work aotg_dev_exit; 
+	struct wake_lock aotg_wake_lock;
+
+	unsigned int aotg_uhost_det;
+
+	/* dp, dm state. */
+	unsigned int old_state;
+	unsigned int state;
+};
+
+enum aotg_mode_e {
+	HCD_MODE,
+	UDC_MODE,
+};
+
+int aotg0_device_init(int power_only);
+void aotg0_device_exit(int power_only);
+
+int aotg1_device_init(int power_only);
+void aotg1_device_exit(int power_only);
+extern void aotg_hub_unregister(int dev_id);
+extern int aotg_hub_register(int dev_id);
+
+#endif
diff --git a/drivers/usb/aotg/aotg_regs.h b/drivers/usb/aotg/aotg_regs.h
new file mode 100755
index 0000000..6ca4e19
--- /dev/null
+++ b/drivers/usb/aotg/aotg_regs.h
@@ -0,0 +1,1534 @@
+/*
+ * for Actions AOTG 
+ *
+ */
+
+#ifndef  __AOTG_REGS_H__
+#define  __AOTG_REGS_H__
+
+//#include <mach/hardware.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/of_device.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+//#include <mach/irqs.h>
+#include <mach/hardware.h>
+
+#define USBH_BASE0				0xB0600000
+#define USBH_BASE1				0xB0700000
+
+#define AOTG_REGS_SIZE		(64*1024)    //64k
+
+#define	    HCIN0BC             0x00000000
+#define	    HCOUT0BC            0x00000001
+#define     EP0CS           	0x00000002
+
+#define     HCIN1BC         	0x00000008
+#define     HCIN2BC         	0x00000010
+#define     HCIN3BC         	0x00000018
+#define     HCIN4BC         	0x00000020
+#define     HCIN5BC         	0x00000028
+#define     HCIN6BC         	0x00000030
+#define     HCIN7BC         	0x00000038
+#define     HCIN8BC         	0x00000040
+#define     HCIN9BC         	0x00000048
+#define     HCIN10BC            0x00000050
+#define     HCIN11BC            0x00000058
+#define     HCIN12BC            0x00000060
+#define     HCIN13BC            0x00000068
+#define     HCIN14BC            0x00000070
+#define     HCIN15BC            0x00000078
+
+#define     HCIN1BCL            0x00000008
+#define     HCIN2BCL            0x00000010
+#define     HCIN3BCL            0x00000018
+#define     HCIN4BCL            0x00000020
+#define     HCIN5BCL            0x00000028
+#define     HCIN6BCL            0x00000030
+#define     HCIN7BCL            0x00000038
+#define     HCIN8BCL            0x00000040
+#define     HCIN9BCL            0x00000048
+#define     HCIN10BCL           0x00000050
+#define     HCIN11BCL           0x00000058
+#define     HCIN12BCL           0x00000060
+#define     HCIN13BCL           0x00000068
+#define     HCIN14BCL           0x00000070
+#define     HCIN15BCL           0x00000078
+
+#define     HCIN1BCH            0x00000009
+#define     HCIN2BCH            0x00000011
+#define     HCIN3BCH            0x00000019
+#define     HCIN4BCH            0x00000021
+#define     HCIN5BCH            0x00000029
+#define     HCIN6BCH            0x00000031
+#define     HCIN7BCH            0x00000039
+#define     HCIN8BCH            0x00000041
+#define     HCIN9BCH            0x00000049
+#define     HCIN10BCH           0x00000051
+#define     HCIN11BCH           0x00000059
+#define     HCIN12BCH           0x00000061
+#define     HCIN13BCH           0x00000069
+#define     HCIN14BCH           0x00000071
+#define     HCIN15BCH           0x00000079
+
+#define     HCIN1CON            0x0000000A
+#define     HCIN2CON            0x00000012
+#define     HCIN3CON            0x0000001A
+#define     HCIN4CON            0x00000022
+#define     HCIN5CON            0x0000002A
+#define     HCIN6CON            0x00000032
+#define     HCIN7CON            0x0000003A
+#define     HCIN8CON            0x00000042
+#define     HCIN9CON            0x0000004A
+#define     HCIN10CON           0x00000052
+#define     HCIN11CON           0x0000005A
+#define     HCIN12CON           0x00000062
+#define     HCIN13CON           0x0000006A
+#define     HCIN14CON           0x00000072
+#define     HCIN15CON           0x0000007A
+
+#define     HCIN1CS         0x0000000B
+#define     HCIN2CS         0x00000013
+#define     HCIN3CS         0x0000001B
+#define     HCIN4CS         0x00000023
+#define     HCIN5CS         0x0000002B
+#define     HCIN6CS         0x00000033
+#define     HCIN7CS         0x0000003B
+#define     HCIN8CS         0x00000043
+#define     HCIN9CS         0x0000004B
+#define     HCIN10CS            0x00000053
+#define     HCIN11CS            0x0000005B
+#define     HCIN12CS            0x00000063
+#define     HCIN13CS            0x0000006B
+#define     HCIN14CS            0x00000073
+#define     HCIN15CS            0x0000007B
+
+#define     HCOUT1BC            0x0000000C
+#define     HCOUT2BC            0x00000014
+#define     HCOUT3BC            0x0000001C
+#define     HCOUT4BC            0x00000024
+#define     HCOUT5BC            0x0000002C
+#define     HCOUT6BC            0x00000034
+#define     HCOUT7BC            0x0000003C
+#define     HCOUT8BC            0x00000044
+#define     HCOUT9BC            0x0000004C
+#define     HCOUT10BC           0x00000054
+#define     HCOUT11BC           0x0000005C
+#define     HCOUT12BC           0x00000064
+#define     HCOUT13BC           0x0000006C
+#define     HCOUT14BC           0x00000074
+#define     HCOUT15BC           0x0000007C
+
+#define     HCOUT1BCL           0x0000000C
+#define     HCOUT2BCL           0x00000014
+#define     HCOUT3BCL           0x0000001C
+#define     HCOUT4BCL           0x00000024
+#define     HCOUT5BCL           0x0000002C
+#define     HCOUT6BCL           0x00000034
+#define     HCOUT7BCL           0x0000003C
+#define     HCOUT8BCL           0x00000044
+#define     HCOUT9BCL           0x0000004C
+#define     HCOUT10BCL          0x00000054
+#define     HCOUT11BCL          0x0000005C
+#define     HCOUT12BCL          0x00000064
+#define     HCOUT13BCL          0x0000006C
+#define     HCOUT14BCL          0x00000074
+#define     HCOUT15BCL          0x0000007C
+
+#define     HCOUT1BCH           0x0000000D
+#define     HCOUT2BCH           0x00000015
+#define     HCOUT3BCH           0x0000001D
+#define     HCOUT4BCH           0x00000025
+#define     HCOUT5BCH           0x0000002D
+#define     HCOUT6BCH           0x00000035
+#define     HCOUT7BCH           0x0000003D
+#define     HCOUT8BCH           0x00000045
+#define     HCOUT9BCH           0x0000004D
+#define     HCOUT10BCH          0x00000055
+#define     HCOUT11BCH          0x0000005D
+#define     HCOUT12BCH          0x00000065
+#define     HCOUT13BCH          0x0000006D
+#define     HCOUT14BCH          0x00000075
+#define     HCOUT15BCH          0x0000007D
+
+#define     HCOUT1CON           0x0000000E
+#define     HCOUT2CON           0x00000016
+#define     HCOUT3CON           0x0000001E
+#define     HCOUT4CON           0x00000026
+#define     HCOUT5CON           0x0000002E
+#define     HCOUT6CON           0x00000036
+#define     HCOUT7CON           0x0000003E
+#define     HCOUT8CON           0x00000046
+#define     HCOUT9CON           0x0000004E
+#define     HCOUT10CON          0x00000056
+#define     HCOUT11CON          0x0000005E
+#define     HCOUT12CON          0x00000066
+#define     HCOUT13CON          0x0000006E
+#define     HCOUT14CON          0x00000076
+#define     HCOUT15CON          0x0000007E
+
+#define     HCOUT1CS            0x0000000F
+#define     HCOUT2CS            0x00000017
+#define     HCOUT3CS            0x0000001F
+#define     HCOUT4CS            0x00000027
+#define     HCOUT5CS            0x0000002F
+#define     HCOUT6CS            0x00000037
+#define     HCOUT7CS            0x0000003F
+#define     HCOUT8CS            0x00000047
+#define     HCOUT9CS            0x0000004F
+#define     HCOUT10CS           0x00000057
+#define     HCOUT11CS           0x0000005F
+#define     HCOUT12CS           0x00000067
+#define     HCOUT13CS           0x0000006F
+#define     HCOUT14CS           0x00000077
+#define     HCOUT15CS           0x0000007F
+
+#define     HCEP0CTRL           0x000000C0
+#define     HCOUT1CTRL          0x000000C4
+#define     HCOUT2CTRL          0x000000C8
+#define     HCOUT3CTRL          0x000000CC
+#define     HCOUT4CTRL          0x000000D0
+#define     HCOUT5CTRL          0x000000D4
+#define     HCOUT6CTRL          0x000000D8
+#define     HCOUT7CTRL          0x000000DC
+#define     HCOUT8CTRL          0x000000E0
+#define     HCOUT9CTRL          0x000000E4
+#define     HCOUT10CTRL         0x000000E8
+#define     HCOUT11CTRL         0x000000EC
+#define     HCOUT12CTRL         0x000000F0
+#define     HCOUT13CTRL         0x000000F4
+#define     HCOUT14CTRL         0x000000F8
+#define     HCOUT15CTRL         0x000000FC
+
+#define     HCOUT0ERR           0x000000C1
+#define     HCOUT1ERR           0x000000C5
+#define     HCOUT2ERR           0x000000C9
+#define     HCOUT3ERR           0x000000CD
+#define     HCOUT4ERR           0x000000D1
+#define     HCOUT5ERR           0x000000D5
+#define     HCOUT6ERR           0x000000D9
+#define     HCOUT7ERR           0x000000DD
+#define     HCOUT8ERR           0x000000E1
+#define     HCOUT9ERR           0x000000E5
+#define     HCOUT10ERR          0x000000E9
+#define     HCOUT11ERR          0x000000ED
+#define     HCOUT12ERR          0x000000F1
+#define     HCOUT13ERR          0x000000F5
+#define     HCOUT14ERR          0x000000F9
+#define     HCOUT15ERR          0x000000FD
+
+#define     HCIN1CTRL           0x000000C6
+#define     HCIN2CTRL           0x000000CA
+#define     HCIN3CTRL           0x000000CE
+#define     HCIN4CTRL           0x000000D2
+#define     HCIN5CTRL           0x000000D6
+#define     HCIN6CTRL           0x000000DA
+#define     HCIN7CTRL           0x000000DE
+#define     HCIN8CTRL           0x000000E2
+#define     HCIN9CTRL           0x000000E6
+#define     HCIN10CTRL          0x000000EA
+#define     HCIN11CTRL          0x000000EE
+#define     HCIN12CTRL          0x000000F2
+#define     HCIN13CTRL          0x000000F6
+#define     HCIN14CTRL          0x000000FA
+#define     HCIN15CTRL          0x000000FE
+
+#define     HCIN0ERR            0x000000C3
+#define     HCIN1ERR            0x000000C7
+#define     HCIN2ERR            0x000000CB
+#define     HCIN3ERR            0x000000CF
+#define     HCIN4ERR            0x000000D3
+#define     HCIN5ERR            0x000000D7
+#define     HCIN6ERR            0x000000DB
+#define     HCIN7ERR            0x000000DF
+#define     HCIN8ERR            0x000000E3
+#define     HCIN9ERR            0x000000E7
+#define     HCIN10ERR           0x000000EB
+#define     HCIN11ERR           0x000000EF
+#define     HCIN12ERR           0x000000F3
+#define     HCIN13ERR           0x000000F7
+#define     HCIN14ERR           0x000000FB
+#define     HCIN15ERR           0x000000FF
+
+#define     EP0INDATA_W0            0x00000100
+#define     EP0INDATA_W1            0x00000104
+#define     EP0INDATA_W2            0x00000108
+#define     EP0INDATA_W3            0x0000010C
+#define     EP0INDATA_W4            0x00000110
+#define     EP0INDATA_W5            0x00000114
+#define     EP0INDATA_W6            0x00000118
+#define     EP0INDATA_W7            0x0000011C
+#define     EP0INDATA_W8            0x00000120
+#define     EP0INDATA_W9            0x00000124
+#define     EP0INDATA_W10           0x00000128
+#define     EP0INDATA_W11           0x0000012C
+#define     EP0INDATA_W12           0x00000130
+#define     EP0INDATA_W13           0x00000134
+#define     EP0INDATA_W14           0x00000138
+#define     EP0INDATA_W15           0x0000013C
+#define     EP0OUTDATA_W0           0x00000140
+#define     EP0OUTDATA_W1           0x00000144
+#define     EP0OUTDATA_W2           0x00000148
+#define     EP0OUTDATA_W3           0x0000014C
+#define     EP0OUTDATA_W4           0x00000150
+#define     EP0OUTDATA_W5           0x00000154
+#define     EP0OUTDATA_W6           0x00000158
+#define     EP0OUTDATA_W7           0x0000015C
+#define     EP0OUTDATA_W8           0x00000160
+#define     EP0OUTDATA_W9           0x00000164
+#define     EP0OUTDATA_W10          0x00000168
+#define     EP0OUTDATA_W11          0x0000016C
+#define     EP0OUTDATA_W12          0x00000170
+#define     EP0OUTDATA_W13          0x00000174
+#define     EP0OUTDATA_W14          0x00000178
+#define     EP0OUTDATA_W15          0x0000017C
+#define     SETUPDATA_W0            0x00000180
+#define     SETUPDATA_W1            0x00000184
+
+/////////////////////////////////////////////////////
+/*******  for device.  *****************************/ 
+/////////////////////////////////////////////////////
+#define OUT0BC                  0x00000000
+#define IN0BC                   0x00000001
+
+#define OUT1BCL                 0x00000008
+#define OUT1BCH                 0x00000009
+#define OUT1CON                 0x0000000A
+#define OUT1CS                  0x0000000B
+#define IN1BCL                  0x0000000C
+#define IN1BCH                  0x0000000D
+#define IN1CON                  0x0000000E
+#define IN1CS                   0x0000000F
+#define OUT2BCL                 0x00000010
+#define OUT2BCH                 0x00000011
+#define OUT2CON                 0x00000012
+#define OUT2CS                  0x00000013
+#define IN2BCL                  0x00000014
+#define IN2BCH                  0x00000015
+#define IN2CON                  0x00000016
+#define IN2CS                   0x00000017
+#define OUT3BCL                 0x00000018
+#define OUT3BCH                 0x00000019
+#define OUT3CON                 0x0000001A
+#define OUT3CS                  0x0000001B
+#define IN3BCL                  0x0000001C
+#define IN3BCH                  0x0000001D
+#define IN3CON                  0x0000001E
+#define IN3CS                   0x0000001F
+#define OUT4BCL                 0x00000020
+#define OUT4BCH                 0x00000021
+#define OUT4CON                 0x00000022
+#define OUT4CS                  0x00000023
+#define IN4BCL                  0x00000024
+#define IN4BCH                  0x00000025
+#define IN4CON                  0x00000026
+#define IN4CS                   0x00000027
+#define OUT5BCL                 0x00000028
+#define OUT5BCH                 0x00000029
+#define OUT5CON                 0x0000002A
+#define OUT5CS                  0x0000002B
+#define IN5BCL                  0x0000002C
+#define IN5BCH                  0x0000002D
+#define IN5CON                  0x0000002E
+#define IN5CS                   0x0000002F
+#define OUT6BCL                 0x00000030
+#define OUT6BCH                 0x00000031
+#define OUT6CON                 0x00000032
+#define OUT6CS                  0x00000033
+#define IN6BCL                  0x00000034
+#define IN6BCH                  0x00000035
+#define IN6CON                  0x00000036
+#define IN6CS                   0x00000037
+    
+//#define FIFO1DATA               0x00000084
+//#define FIFO2DATA               0x00000088
+//#define FIFO3DATA               0x0000008C
+//#define FIFO4DATA               0x00000090
+//#define FIFO5DATA               0x00000094
+//#define EP0INDAT                0x00000100
+//#define HCEP0OUTDAT             0x00000100
+    
+#if 1
+/***************  for 0-7 ep to 0-15 ep. *****************/ 
+#define INxIRQ                 0x00000188
+//#define HCOUT07IRQ              0x00000188
+#define OUTxIRQ                0x0000018A
+//#define HCIN07IRQ               0x0000018A
+//#define USBIRQ                  0x0000018C
+//#define OUT07PNGIRQ             0x0000018E
+#define INTXKIRQ                0x00000190
+//#define OUTXTOKIRQ              0x00000190
+#define OUTxEMPTIRQ            0x00000191
+//#define HCIN07EMPTIRQ           0x00000191
+#define INxIEN                 0x00000194
+//#define HCOUT07IEN              0x00000194
+#define OUTxIEN                0x00000196
+//#define HCIN07IEN               0x00000196
+//#define USBIEN                  0x00000198
+#define OUTxPNGIEN             0x0000019A
+//#define INTXKIEN                0x0000019C
+//#define OUTXTOKIEN              0x0000019D
+#endif	/*  */
+
+#define     HCOUTxIRQ0          0x00000188
+#define     HCOUTxIRQ1          0x00000189
+#define     HCINxIRQ0           0x0000018A
+#define     HCINxIRQ1           0x0000018B
+#define     USBIRQ              0x0000018C
+#define     HCINxPNGIRQ0            0x0000018E
+#define     HCINxPNGIRQ1            0x0000018F
+#define     HCOUTxTOKIRQ0           0x00000190
+#define     HCOUTxTOKIRQ1           0x00000191
+#define     HCINxTOKIRQ0            0x00000192
+#define     HCINxTOKIRQ1            0x00000193
+#define     HCOUTxIEN0          0x00000194
+#define     HCOUTxIEN1          0x00000195
+#define     HCINxIEN0           0x00000196
+#define     HCINxIEN1           0x00000197
+#define     USBIEN              0x00000198
+#define     HCINxPNGIEN0            0x0000019A
+#define     HCINxPNGIEN1            0x0000019B
+#define     HCOUTxTOKIEN0           0x0000019C
+#define     HCOUTxTOKIEN1           0x0000019D
+#define     HCINxTOKIEN0            0x0000019E
+#define     HCINxTOKIEN1            0x0000019F
+
+#define IVECT                   0x000001A0
+#define ENDPRST                 0x000001A2
+//#define HCENDPRST               0x000001A2
+#define USBCS                   0x000001A3
+#define FRMNRL                  0x000001A4
+#define     FRMNRH              0x000001A5
+//#define FRMNFH                  0x000001A5
+#define FNADDR                  0x000001A6
+#define CLKGATE                 0x000001A7
+//#define FIFOCTRL                0x000001A8
+#define HCTRAINTERVAL		0x000001A8
+#define HCPORTCTRL              0x000001AB
+#define HCFRMNRL                0x000001AC
+#define HCFRMNRH                0x000001AD
+#define HCFRMREMAINL            0x000001AE
+#define HCFRMREMAINH            0x000001AF
+
+#if 0
+/************** ep0-7 to ep0-15 ******************/
+//#define HCIN07ERRIRQ            0x000001B4
+//#define HCOUT07ERRIRQ           0x000001B6
+//#define HCIN07ERRIEN            0x000001B8
+//#define HCOUT07ERRIEN           0x000001BA
+#endif
+#define     HCINxERRIRQ0            0x000001B4
+#define     HCINxERRIRQ1            0x000001B5
+#define     HCOUTxERRIRQ0           0x000001B6
+#define     HCOUTxERRIRQ1           0x000001B7
+#define     HCINxERRIEN0            0x000001B8
+#define     HCINxERRIEN1            0x000001B9
+#define     HCOUTxERRIEN0           0x000001BA
+#define     HCOUTxERRIEN1           0x000001BB
+
+#define OTGIRQ                  0x000001BC
+#define OTGSTATE                0x000001BD
+#define OTGCTRL                 0x000001BE
+#define OTGSTATUS               0x000001BF
+#define OTGIEN                  0x000001C0
+#define TAAIDLBDIS              0x000001C1
+#define TAWAITBCON              0x000001C2
+#define TBVBUSPLS               0x000001C3
+//#define TBVBUSDISCHPLS          0x000001C7
+#define     TBVBUSDISPLS            0x000001C7
+
+#define     HCIN0MAXPCK         0x000001E0
+#define     HCIN1MAXPCK         0x000001E2
+#define     HCIN2MAXPCK         0x000001E4
+#define     HCIN3MAXPCK         0x000001E6
+#define     HCIN4MAXPCK         0x000001E8
+#define     HCIN5MAXPCK         0x000001EA
+#define     HCIN6MAXPCK         0x000001EC
+#define     HCIN7MAXPCK         0x000001EE
+#define     HCIN8MAXPCK         0x000001F0
+#define     HCIN9MAXPCK         0x000001F2
+#define     HCIN10MAXPCK            0x000001F4
+#define     HCIN11MAXPCK            0x000001F6
+#define     HCIN12MAXPCK            0x000001F8
+#define     HCIN13MAXPCK            0x000001FA
+#define     HCIN14MAXPCK            0x000001FC
+#define     HCIN15MAXPCK            0x000001FE
+#define     HCIN1MAXPCKL            0x000001E2
+#define     HCIN2MAXPCKL            0x000001E4
+#define     HCIN3MAXPCKL            0x000001E6
+#define     HCIN4MAXPCKL            0x000001E8
+#define     HCIN5MAXPCKL            0x000001EA
+#define     HCIN6MAXPCKL            0x000001EC
+#define     HCIN7MAXPCKL            0x000001EE
+#define     HCIN8MAXPCKL            0x000001F0
+#define     HCIN9MAXPCKL            0x000001F2
+#define     HCIN10MAXPCKL           0x000001F4
+#define     HCIN11MAXPCKL           0x000001F6
+#define     HCIN12MAXPCKL           0x000001F8
+#define     HCIN13MAXPCKL           0x000001FA
+#define     HCIN14MAXPCKL           0x000001FC
+#define     HCIN15MAXPCKL           0x000001FE
+#define     HCIN1MAXPCKH            0x000001E3
+#define     HCIN2MAXPCKH            0x000001E5
+#define     HCIN3MAXPCKH            0x000001E7
+#define     HCIN4MAXPCKH            0x000001E9
+#define     HCIN5MAXPCKH            0x000001EB
+#define     HCIN6MAXPCKH            0x000001ED
+#define     HCIN7MAXPCKH            0x000001EF
+#define     HCIN8MAXPCKH            0x000001F1
+#define     HCIN9MAXPCKH            0x000001F3
+#define     HCIN10MAXPCKH           0x000001F5
+#define     HCIN11MAXPCKH           0x000001F7
+#define     HCIN12MAXPCKH           0x000001F9
+#define     HCIN13MAXPCKH           0x000001FB
+#define     HCIN14MAXPCKH           0x000001FD
+#define     HCIN15MAXPCKH           0x000001FF
+
+#define     HCEP0BINTERVAL          0x00000200
+#define     HCIN1BINTERVAL          0x00000208
+#define     HCIN2BINTERVAL          0x00000210
+#define     HCIN3BINTERVAL          0x00000218
+#define     HCIN4BINTERVAL          0x00000220
+#define     HCIN5BINTERVAL          0x00000228
+#define     HCIN6BINTERVAL          0x00000230
+#define     HCIN7BINTERVAL          0x00000238
+#define     HCIN8BINTERVAL          0x00000240
+#define     HCIN9BINTERVAL          0x00000248
+#define     HCIN10BINTERVAL     0x00000250
+#define     HCIN11BINTERVAL     0x00000258
+#define     HCIN12BINTERVAL     0x00000260
+#define     HCIN13BINTERVAL     0x00000268
+#define     HCIN14BINTERVAL     0x00000270
+#define     HCIN15BINTERVAL     0x00000278
+#define     HCEP0ADDR           0x201
+#define     HCIN1ADDR           0x00000209
+#define     HCIN2ADDR           0x00000211
+#define     HCIN3ADDR           0x00000219
+#define     HCIN4ADDR           0x00000221
+#define     HCIN5ADDR           0x00000229
+#define     HCIN6ADDR           0x00000231
+#define     HCIN7ADDR           0x00000239
+#define     HCIN8ADDR           0x00000241
+#define     HCIN9ADDR           0x00000249
+#define     HCIN10ADDR          0x00000251
+#define     HCIN11ADDR          0x00000259
+#define     HCIN12ADDR          0x00000261
+#define     HCIN13ADDR          0x00000269
+#define     HCIN14ADDR          0x00000271
+#define     HCIN15ADDR          0x00000279
+#define     HCEP0PORT           0x00000202
+#define     HCIN1PORT           0x0000020A
+#define     HCIN2PORT           0x00000212
+#define     HCIN3PORT           0x0000021A
+#define     HCIN4PORT           0x00000222
+#define     HCIN5PORT           0x0000022A
+#define     HCIN6PORT           0x00000232
+#define     HCIN7PORT           0x0000023A
+#define     HCIN8PORT           0x00000242
+#define     HCIN9PORT           0x0000024A
+#define     HCIN10PORT          0x00000252
+#define     HCIN11PORT          0x0000025A
+#define     HCIN12PORT          0x00000262
+#define     HCIN13PORT          0x0000026A
+#define     HCIN14PORT          0x00000272
+#define     HCIN15PORT          0x0000027A
+#define     HCEP0SPILITCS           0x00000203
+#define     HCIN1SPILITCS           0x0000020B
+#define     HCIN2SPILITCS           0x00000213
+#define     HCIN3SPILITCS           0x0000021B
+#define     HCIN4SPILITCS           0x00000223
+#define     HCIN5SPILITCS           0x0000022B
+#define     HCIN6SPILITCS           0x00000233
+#define     HCIN7SPILITCS           0x0000023B
+#define     HCIN8SPILITCS           0x00000243
+#define     HCIN9SPILITCS           0x0000024B
+#define     HCIN10SPILITCS          0x00000253
+#define     HCIN11SPILITCS          0x0000025B
+#define     HCIN12SPILITCS          0x00000263
+#define     HCIN13SPILITCS          0x0000026B
+#define     HCIN14SPILITCS          0x00000273
+#define     HCIN15SPILITCS          0x0000027B
+#define     HCOUT1BINTERVAL     0x00000288
+#define     HCOUT2BINTERVAL     0x00000290
+#define     HCOUT3BINTERVAL     0x00000298
+#define     HCOUT4BINTERVAL     0x000002A0
+#define     HCOUT5BINTERVAL     0x000002A8
+#define     HCOUT6BINTERVAL     0x000002B0
+#define     HCOUT7BINTERVAL     0x000002B8
+#define     HCOUT8BINTERVAL     0x000002C0
+#define     HCOUT9BINTERVAL     0x000002C8
+#define     HCOUT10BINTERVAL        0x000002D0
+#define     HCOUT11BINTERVAL        0x000002D8
+#define     HCOUT12BINTERVAL        0x000002E0
+#define     HCOUT13BINTERVAL        0x000002E8
+#define     HCOUT14BINTERVAL        0x000002F0
+#define     HCOUT15BINTERVAL        0x000002F8
+#define     HCOUT1ADDR          0x00000289
+#define     HCOUT2ADDR          0x00000291
+#define     HCOUT3ADDR          0x00000299
+#define     HCOUT4ADDR          0x000002A1
+#define     HCOUT5ADDR          0x000002A9
+#define     HCOUT6ADDR          0x000002B1
+#define     HCOUT7ADDR          0x000002B9
+#define     HCOUT8ADDR          0x000002C1
+#define     HCOUT9ADDR          0x000002C9
+#define     HCOUT10ADDR         0x000002D1
+#define     HCOUT11ADDR         0x000002D9
+#define     HCOUT12ADDR         0x000002E1
+#define     HCOUT13ADDR         0x000002E9
+#define     HCOUT14ADDR         0x000002F1
+#define     HCOUT15ADDR         0x000002F9
+#define     HCOUT1PORT          0x0000028A
+#define     HCOUT2PORT          0x00000292
+#define     HCOUT3PORT          0x0000029A
+#define     HCOUT4PORT          0x000002A2
+#define     HCOUT5PORT          0x000002AA
+#define     HCOUT6PORT          0x000002B2
+#define     HCOUT7PORT          0x000002BA
+#define     HCOUT8PORT          0x000002C2
+#define     HCOUT9PORT          0x000002CA
+#define     HCOUT10PORT         0x000002D2
+#define     HCOUT11PORT         0x000002DA
+#define     HCOUT12PORT         0x000002E2
+#define     HCOUT13PORT         0x000002EA
+#define     HCOUT14PORT         0x000002F2
+#define     HCOUT15PORT         0x000002FA
+#define     HCOUT1SPILITCS          0x0000028B
+#define     HCOUT2SPILITCS          0x00000293
+#define     HCOUT3SPILITCS          0x0000029B
+#define     HCOUT4SPILITCS          0x000002A3
+#define     HCOUT5SPILITCS          0x000002AB
+#define     HCOUT6SPILITCS          0x000002B3
+#define     HCOUT7SPILITCS          0x000002BB
+#define     HCOUT8SPILITCS          0x000002C3
+#define     HCOUT9SPILITCS          0x000002CB
+#define     HCOUT10SPILITCS     0x000002D3
+#define     HCOUT11SPILITCS     0x000002DB
+#define     HCOUT12SPILITCS     0x000002E3
+#define     HCOUT13SPILITCS     0x000002EB
+#define     HCOUT14SPILITCS     0x000002F3
+#define     HCOUT15SPILITCS     0x000002FB
+    
+/*************  replaced by new register define. ************/ 
+#define OUT1STARTADDRESS        0x00000304
+#define OUT1STARTADDRESSL       0x00000304
+#define OUT1STARTADDRESSH       0x00000305
+#define OUT2STARTADDRESS        0x00000308
+#define OUT2STARTADDRESSL       0x00000308
+    
+#define OUT3STADDR              0x0000030C
+#define OUT4STADDR              0x00000310
+#define OUT5STADDR              0x00000314
+//#define OUT2STARTADDRESSH       0x00000309
+    
+#define IN1STARTADDRESS         0x00000344
+#define IN1STARTADDRESSL        0x00000344
+#define IN1STARTADDRESSH        0x00000345
+#define IN2STARTADDRESS         0x00000348
+#define IN2STARTADDRESSL        0x00000348
+#define IN2STARTADDRESSH        0x00000349
+    
+#define IN3STADDR               0x0000034C
+#define IN4STADDR               0x00000350
+#define IN5STADDR               0x00000354
+#define IN6STADDR               0x00000358
+    
+#if 0
+#define HCOUT0MAXPCK            0x000003E0
+#define HCOUT1MAXPCKL           0x000003E2
+#define HCOUT1MAXPCKH           0x000003E3
+#define HCOUT2MAXPCKL           0x000003E4
+#define HCOUT2MAXPCKH           0x000003E5
+#define HCOUT3MAXPCKL           0x000003E6
+#define HCOUT3MAXPCKH           0x000003E7
+#define HCOUT4MAXPCKL           0x000003E8
+#define HCOUT4MAXPCKH           0x000003E9
+#define HCOUT5MAXPCKL           0x000003EA
+#define HCOUT5MAXPCKH           0x000003EB
+
+//#define USBERESET               0x00000400
+#define TA_BCON_COUNT           0x00000401
+#define VBUSDBCTIMERL           0x00000402
+#define VBUSDBCTIMERH           0x00000403
+#define VDCTRL                  0x00000404
+#define VDSTATE                 0x00000405
+#define BKDOOR                  0x00000406
+#define DBGMODE                 0x00000407
+#define SRPCTRL                 0x00000408
+//#define USBEIRQ                 0x0000040A
+#define USBEIEN                 0x0000040C
+#define UDMAIRQ                 0x0000040E
+#define UDMAIEN                 0x0000040F
+#define OUTXSHORTPCKIRQ         0x00000410
+#define OUTXSHORTPCKIEN         0x00000412
+#define OUTXNAKCTRL             0x00000414
+#define HCINXSTART              0x00000416
+#define HCINXENDIRQ             0x00000418
+#define HCINXENDIEN             0x0000041A
+
+/* HCINxCounter\BCĴ\E6\C6\F7\B5\C4д\C8\EB\B5\D8ַΪ0x420,0x424,0x428,0x42c,0x430,\B6\C1ȡ\B5\D8ַΪ0x420\A3\AC0x422,0x424,0x426,0x428\A1\A3*/
+//#define HCIN1_COUNTL            0x00000420
+//#define HCIN1_COUNTH            0x00000421
+//#define HCIN2_COUNTL            0x00000422
+//#define HCIN2_COUNTH            0x00000423
+//#define HCIN3_COUNTL            0x00000424
+//#define HCIN3_COUNTH            0x00000425
+//#define HCIN4_COUNTL            0x00000426
+//#define HCIN4_COUNTH            0x00000427
+//#define HCIN5_COUNTL            0x00000428
+//#define HCIN5_COUNTH            0x00000429
+#define HCIN1_COUNTL            0x00000420
+#define HCIN1_COUNTH            0x00000421
+#define HCIN2_COUNTL            0x00000424
+#define HCIN2_COUNTH            0x00000425
+#define HCIN3_COUNTL            0x00000428
+#define HCIN3_COUNTH            0x00000429
+#define HCIN4_COUNTL            0x0000042c
+#define HCIN4_COUNTH            0x0000042d
+#define HCIN5_COUNTL            0x00000430
+#define HCIN5_COUNTH            0x00000431
+
+#define INXBUFEMPTYIRQ          0x00000440
+#define INXBUFEMPTYIEN          0x00000442
+#define INXBUFEMPTYCTRL         0x00000444
+#define UDMA1MEMADDR            0x00000450
+#define UDMA1EPSEL              0x00000454
+#define UDMA1COM                0x00000455
+#define UDMA1CNTL               0x00000458
+#define UDMA1CNTM               0x00000459
+#define UDMA1CNTH               0x0000045A
+#define UDMA1REML               0x0000045C
+#define UDMA1REMM               0x0000045D
+#define UDMA1REMH               0x0000045E
+#define UDMA2MEMADDR            0x00000460
+#define UDMA2EPSEL              0x00000464
+#define UDMA2COM                0x00000465
+#define UDMA2CNTL               0x00000468
+#define UDMA2CNTM               0x00000469
+#define UDMA2CNTH               0x0000046A
+#define UDMA2REML               0x0000046C
+#define UDMA2REMM               0x0000046D
+#define UDMA2REMH               0x0000046E
+#endif
+
+#define     HCIN1STADDR         0x00000304
+#define     HCIN2STADDR         0x00000308
+#define     HCIN3STADDR         0x0000030C
+#define     HCIN4STADDR         0x00000310
+#define     HCIN5STADDR         0x00000314
+#define     HCIN6STADDR         0x00000318
+#define     HCIN7STADDR         0x0000031C
+#define     HCIN8STADDR         0x00000320
+#define     HCIN9STADDR         0x00000324
+#define     HCIN10STADDR            0x00000328
+#define     HCIN11STADDR            0x0000032C
+#define     HCIN12STADDR            0x00000330
+#define     HCIN13STADDR            0x00000334
+#define     HCIN14STADDR            0x00000338
+#define     HCIN15STADDR            0x0000033C
+#define     HCOUT1STADDR            0x00000344
+#define     HCOUT2STADDR            0x00000348
+#define     HCOUT3STADDR            0x0000034C
+#define     HCOUT4STADDR            0x00000350
+#define     HCOUT5STADDR            0x00000354
+#define     HCOUT6STADDR            0x00000358
+#define     HCOUT7STADDR            0x0000035C
+#define     HCOUT8STADDR            0x00000360
+#define     HCOUT9STADDR            0x00000364
+#define     HCOUT10STADDR           0x00000368
+#define     HCOUT11STADDR           0x0000036C
+#define     HCOUT12STADDR           0x00000370
+#define     HCOUT13STADDR           0x00000374
+#define     HCOUT14STADDR           0x00000378
+#define     HCOUT15STADDR           0x0000037C
+#define     HCOUT1MAXPCK            0x000003E2
+#define     HCOUT2MAXPCK            0x000003E4
+#define     HCOUT3MAXPCK            0x000003E6
+#define     HCOUT4MAXPCK            0x000003E8
+#define     HCOUT5MAXPCK            0x000003EA
+#define     HCOUT6MAXPCK            0x000003EC
+#define     HCOUT7MAXPCK            0x000003EE
+#define     HCOUT8MAXPCK            0x3F0
+#define     HCOUT9MAXPCK            0x000003F2
+#define     HCOUT10MAXPCK           0x000003F4
+#define     HCOUT11MAXPCK           0x000003F6
+#define     HCOUT12MAXPCK           0x000003F8
+#define     HCOUT13MAXPCK           0x000003FA
+#define     HCOUT14MAXPCK           0x000003FC
+#define     HCOUT15MAXPCK           0x000003FE
+#define     HCOUT1MAXPCKL           0x000003E2
+#define     HCOUT2MAXPCKL           0x000003E4
+#define     HCOUT3MAXPCKL           0x000003E6
+#define     HCOUT4MAXPCKL           0x000003E8
+#define     HCOUT5MAXPCKL           0x000003EA
+#define     HCOUT6MAXPCKL           0x000003EC
+#define     HCOUT7MAXPCKL           0x000003EE
+#define     HCOUT8MAXPCKL           0x3F0
+#define     HCOUT9MAXPCKL           0x000003F2
+#define     HCOUT10MAXPCKL          0x000003F4
+#define     HCOUT11MAXPCKL          0x000003F6
+#define     HCOUT12MAXPCKL          0x000003F8
+#define     HCOUT13MAXPCKL          0x000003FA
+#define     HCOUT14MAXPCKL          0x000003FC
+#define     HCOUT15MAXPCKL          0x000003FE
+#define     HCOUT1MAXPCKH           0x000003E3
+#define     HCOUT2MAXPCKH           0x000003E5
+#define     HCOUT3MAXPCKH           0x000003E7
+#define     HCOUT4MAXPCKH           0x000003E9
+#define     HCOUT5MAXPCKH           0x000003EB
+#define     HCOUT6MAXPCKH           0x000003ED
+#define     HCOUT7MAXPCKH           0x000003EF
+#define     HCOUT8MAXPCKH           0x3F1
+#define     HCOUT9MAXPCKH           0x000003F3
+#define     HCOUT10MAXPCKH          0x000003F5
+#define     HCOUT11MAXPCKH          0x000003F7
+#define     HCOUT12MAXPCKH          0x000003F9
+#define     HCOUT13MAXPCKH          0x000003FB
+#define     HCOUT14MAXPCKH          0x000003FD
+#define     HCOUT15MAXPCKH          0x000003FF
+#define     HCINxDMASTART0          0x00000400
+#define     HCINxDMASTART1          0x00000401
+#define     HCINDMAERROR            0x00000402
+#define     HCINxDMAIRQ0            0x00000404
+#define     HCINxDMAIRQ1            0x00000405
+#define     HCINxDMAIEN0            0x00000406
+#define     HCINxDMAIEN1            0x00000407
+#define     HCIN1DMASTADDR          0x00000408
+#define     HCIN2DMASTADDR          0x00000410
+#define     HCIN3DMASTADDR          0x00000418
+#define     HCIN4DMASTADDR          0x00000420
+#define     HCIN5DMASTADDR          0x00000428
+#define     HCIN6DMASTADDR          0x00000430
+#define     HCIN7DMASTADDR          0x00000438
+#define     HCIN8DMASTADDR          0x00000440
+#define     HCIN9DMASTADDR          0x00000448
+#define     HCIN10DMASTADDR     0x00000450
+#define     HCIN11DMASTADDR     0x00000458
+#define     HCIN12DMASTADDR     0x00000460
+#define     HCIN13DMASTADDR     0x00000468
+#define     HCIN14DMASTADDR     0x00000470
+#define     HCIN15DMASTADDR     0x00000478
+#define     HCIN1DMACOUNTER     0x0000040C
+#define     HCIN2DMACOUNTER     0x00000414
+#define     HCIN3DMACOUNTER     0x0000041C
+#define     HCIN4DMACOUNTER     0x00000424
+#define     HCIN5DMACOUNTER     0x0000042C
+#define     HCIN6DMACOUNTER     0x00000434
+#define     HCIN7DMACOUNTER     0x0000043C
+#define     HCIN8DMACOUNTER     0x00000444
+#define     HCIN9DMACOUNTER     0x0000044C
+#define     HCIN10DMACOUNTER        0x00000454
+#define     HCIN11DMACOUNTER        0x0000045C
+#define     HCIN12DMACOUNTER        0x00000464
+#define     HCIN13DMACOUNTER        0x0000046C
+#define     HCIN14DMACOUNTER        0x00000474
+#define     HCIN15DMACOUNTER        0x0000047C
+#define     HCOUTxDMASTART0     0x00000480
+#define     HCOUTxDMASTART1     0x00000481
+#define     HCOUTxDMAIRQ0           0x00000484
+#define     HCOUTxDMAIRQ1           0x00000485
+#define     HCOUTxDMAIEN0           0x00000486
+#define     HCOUTxDMAIEN1           0x00000487
+#define     HCOUT1DMASTADDR     0x00000488
+#define     HCOUT2DMASTADDR     0x00000490
+#define     HCOUT3DMASTADDR     0x00000498
+#define     HCOUT4DMASTADDR     0x000004A0
+#define     HCOUT5DMASTADDR     0x000004A8
+#define     HCOUT6DMASTADDR     0x000004B0
+#define     HCOUT7DMASTADDR     0x000004B8
+#define     HCOUT8DMASTADDR     0x000004C0
+#define     HCOUT9DMASTADDR     0x000004C8
+#define     HCOUT10DMASTADDR        0x000004D0
+#define     HCOUT11DMASTADDR        0x000004D8
+#define     HCOUT12DMASTADDR        0x000004E0
+#define     HCOUT13DMASTADDR        0x000004E8
+#define     HCOUT14DMASTADDR        0x000004F0
+#define     HCOUT15DMASTADDR        0x000004F8
+#define     HCOUT1DMACOUNTER        0x0000048C
+#define     HCOUT2DMACOUNTER        0x00000494
+#define     HCOUT3DMACOUNTER        0x0000049C
+#define     HCOUT4DMACOUNTER        0x000004A4
+#define     HCOUT5DMACOUNTER        0x000004AC
+#define     HCOUT6DMACOUNTER        0x000004B4
+#define     HCOUT7DMACOUNTER        0x000004BC
+#define     HCOUT8DMACOUNTER        0x000004C4
+#define     HCOUT9DMACOUNTER        0x000004CC
+#define     HCOUT10DMACOUNTER       0x000004D4
+#define     HCOUT11DMACOUNTER       0x000004DC
+#define     HCOUT12DMACOUNTER       0x000004E4
+#define     HCOUT13DMACOUNTER       0x000004EC
+#define     HCOUT14DMACOUNTER       0x000004F4
+#define     HCOUT15DMACOUNTER       0x000004FC
+#define     USBERESET           0x00000500
+#define     TA_BCON_COUNT           0x00000501
+#define     VBUSDBCTIMERL           0x00000502
+#define     VBUSDBCTIMERH           0x00000503
+#define     VDCTRL              0x00000504
+#define     VDSTATUS            0x00000505
+#define     BKDOOR              0x00000506
+#define     DBGMODE         0x00000507
+#define     SRPCTRL         0x00000508
+#define     USBEIRQ         0x0000050A
+#define     USBEIEN         0x0000050B
+#define     HCINxSHORTPCKIRQ0       0x00000510
+#define     HCINxSHORTPCKIRQ1       0x00000511
+#define     HCINxSHORTPCKIEN0       0x00000512
+#define     HCINxSHORTPCKIEN1       0x00000513
+#define     HCINxZEROPCKIRQ0        0x00000514
+#define     HCINxZEROPCKIRQ1        0x00000515
+#define     HCINxZEROPCKIEN0        0x00000516
+#define     HCINxZEROPCKIEN1        0x00000517
+#define     HCOUTxBUFEMPTYIRQ0      0x00000518
+#define     HCOUTxBUFEMPTYIRQ1      0x00000519
+#define     HCOUTxBUFEMPTYIEN0      0x0000051A
+#define     HCOUTxBUFEMPTYIEN1      0x0000051B
+#define     HCOUTxBUFEMPTYCTRL0     0x0000051C
+#define     HCOUTxBUFEMPTYCTRL1     0x0000051D
+
+
+//linklist regs
+#define	HCDMABCKDOOR	0x00000800
+#define	HCDMAxOVERFLOWIRQ	0x00000808
+#define HCDMAxOVERFLOWIEN	0x0000080C
+
+#define	HCOUT1DMALINKADDR	0x00000910
+#define	HCOUT2DMALINKADDR	0x00000920
+#define	HCOUT3DMALINKADDR	0x00000930
+#define	HCOUT4DMALINKADDR	0x00000940
+#define	HCOUT5DMALINKADDR	0x00000950
+#define	HCOUT6DMALINKADDR	0x00000960
+#define	HCOUT7DMALINKADDR	0x00000970
+#define	HCOUT8DMALINKADDR	0x00000980
+#define	HCOUT9DMALINKADDR	0x00000990
+#define	HCOUT10DMALINKADDR	0x000009A0
+#define	HCOUT11DMALINKADDR	0x000009B0
+#define	HCOUT12DMALINKADDR	0x000009C0
+#define	HCOUT13DMALINKADDR	0x000009D0
+#define	HCOUT14DMALINKADDR	0x000009E0
+#define	HCOUT15DMALINKADDR	0x000009F0
+
+#define HCOUT1DMACURADDR	0x00000914
+#define HCOUT2DMACURADDR	0x00000924
+#define HCOUT3DMACURADDR	0x00000934
+#define HCOUT4DMACURADDR	0x00000944
+#define HCOUT5DMACURADDR	0x00000954
+#define HCOUT6DMACURADDR	0x00000964
+#define HCOUT7DMACURADDR	0x00000974
+#define HCOUT8DMACURADDR	0x00000984
+#define HCOUT9DMACURADDR	0x00000994
+#define HCOUT10DMACURADDR	0x000009A4
+#define HCOUT11DMACURADDR	0x000009B4
+#define HCOUT12DMACURADDR	0x000009C4
+#define HCOUT13DMACURADDR	0x000009D4
+#define HCOUT14DMACURADDR	0x000009E4
+#define HCOUT15DMACURADDR	0x000009F4
+
+#define	HCOUT1DMACTRL	0x00000918
+#define	HCOUT2DMACTRL	0x00000928
+#define	HCOUT3DMACTRL	0x00000938
+#define	HCOUT4DMACTRL	0x00000948
+#define	HCOUT5DMACTRL	0x00000958
+#define	HCOUT6DMACTRL	0x00000968
+#define	HCOUT7DMACTRL	0x00000978
+#define	HCOUT8DMACTRL	0x00000988
+#define	HCOUT9DMACTRL	0x00000998
+#define	HCOUT10DMACTRL	0x000009A8
+#define	HCOUT11DMACTRL	0x000009B8
+#define	HCOUT12DMACTRL	0x000009C8
+#define	HCOUT13DMACTRL	0x000009D8
+#define	HCOUT14DMACTRL	0x000009E8
+#define	HCOUT15DMACTRL	0x000009F8
+
+#define	HCOUT1DMACOMPLETECNT	0x0000091C
+#define	HCOUT2DMACOMPLETECNT	0x0000092C
+#define	HCOUT3DMACOMPLETECNT	0x0000093C
+#define	HCOUT4DMACOMPLETECNT	0x0000094C
+#define	HCOUT5DMACOMPLETECNT	0x0000095C
+#define	HCOUT6DMACOMPLETECNT	0x0000096C
+#define	HCOUT7DMACOMPLETECNT	0x0000097C
+#define	HCOUT8DMACOMPLETECNT	0x0000098C
+#define	HCOUT9DMACOMPLETECNT	0x0000099C
+#define	HCOUT10DMACOMPLETECNT	0x000009AC
+#define	HCOUT11DMACOMPLETECNT	0x000009BC
+#define	HCOUT12DMACOMPLETECNT	0x000009CC
+#define	HCOUT13DMACOMPLETECNT	0x000009DC
+#define	HCOUT14DMACOMPLETECNT	0x000009EC
+#define	HCOUT15DMACOMPLETECNT	0x000009FC
+
+#define	HCIN1DMALINKADDR	0x00000810
+#define	HCIN2DMALINKADDR	0x00000820
+#define	HCIN3DMALINKADDR	0x00000830
+#define	HCIN4DMALINKADDR	0x00000840
+#define	HCIN5DMALINKADDR	0x00000850
+#define	HCIN6DMALINKADDR	0x00000860
+#define	HCIN7DMALINKADDR	0x00000870
+#define	HCIN8DMALINKADDR	0x00000880
+#define	HCIN9DMALINKADDR	0x00000890
+#define	HCIN10DMALINKADDR	0x000008A0
+#define	HCIN11DMALINKADDR	0x000008B0
+#define	HCIN12DMALINKADDR	0x000008C0
+#define	HCIN13DMALINKADDR	0x000008D0
+#define	HCIN14DMALINKADDR	0x000008E0
+#define	HCIN15DMALINKADDR	0x000008F0
+
+#define	HCIN1DMACURADDR		0x00000814
+#define	HCIN2DMACURADDR		0x00000824
+#define	HCIN3DMACURADDR		0x00000834
+#define	HCIN4DMACURADDR		0x00000844
+#define	HCIN5DMACURADDR		0x00000854
+#define	HCIN6DMACURADDR		0x00000864
+#define	HCIN7DMACURADDR		0x00000874
+#define	HCIN8DMACURADDR		0x00000884
+#define	HCIN9DMACURADDR		0x00000894
+#define	HCIN10DMACURADDR	0x000008A4
+#define	HCIN11DMACURADDR	0x000008B4
+#define	HCIN12DMACURADDR	0x000008C4
+#define	HCIN13DMACURADDR	0x000008D4
+#define	HCIN14DMACURADDR	0x000008E4
+#define	HCIN15DMACURADDR	0x000008F4
+
+#define	HCIN1DMACTRL		0x00000818
+#define	HCIN2DMACTRL		0x00000828
+#define	HCIN3DMACTRL		0x00000838
+#define	HCIN4DMACTRL		0x00000848
+#define	HCIN5DMACTRL		0x00000858
+#define	HCIN6DMACTRL		0x00000868
+#define	HCIN7DMACTRL		0x00000878
+#define	HCIN8DMACTRL		0x00000888
+#define	HCIN9DMACTRL		0x00000898
+#define	HCIN10DMACTRL		0x000008A8
+#define	HCIN11DMACTRL		0x000008B8
+#define	HCIN12DMACTRL		0x000008C8
+#define	HCIN13DMACTRL		0x000008D8
+#define	HCIN14DMACTRL		0x000008E8
+#define	HCIN15DMACTRL		0x000008F8
+
+#define HCIN1DMACOMPLETECNT		0x0000081C
+#define HCIN2DMACOMPLETECNT		0x0000082C
+#define HCIN3DMACOMPLETECNT		0x0000083C
+#define HCIN4DMACOMPLETECNT		0x0000084C
+#define HCIN5DMACOMPLETECNT		0x0000085C
+#define HCIN6DMACOMPLETECNT		0x0000086C
+#define HCIN7DMACOMPLETECNT		0x0000087C
+#define HCIN8DMACOMPLETECNT		0x0000088C
+#define HCIN9DMACOMPLETECNT		0x0000089C
+#define HCIN10DMACOMPLETECNT	0x000008AC
+#define HCIN11DMACOMPLETECNT	0x000008BC
+#define HCIN12DMACOMPLETECNT	0x000008CC
+#define HCIN13DMACOMPLETECNT	0x000008DC
+#define HCIN14DMACOMPLETECNT	0x000008EC
+#define HCIN15DMACOMPLETECNT	0x000008FC
+
+
+
+/******************************************************************************/
+/* DMA LINK_LIST */
+/******************************************************************************/
+#define DMACTRL_DMACS	(1 << 0)
+#define DMACTRL_DMACC	(1 << 1)
+
+/******************************************************************************/
+/*OTG external Registers USBEIRQ, USBEIEN. */
+/******************************************************************************/
+#define USBEIRQ_USBIRQ          (0x1 << 7)
+#define USBEIRQ_USBIEN          (0x1 << 7)
+#define RESUME_IRQIEN           (0x1 << 1)
+#define SUSPEND_IRQIEN          (0x1 << 4)
+
+/* USBERESET USBERES*/
+#define USBERES_USBRESET        (1 << 0)
+
+/*VDCTRL*/
+#define VDCTRL_VLOAD            (1 << 4)
+#define VDCTRL_VCONTROL(x)      ((x) & 0xf)
+
+/******************************************************************************/
+/*OTG SFR Registers*/
+/******************************************************************************/
+/*OTGIRQ*/
+#define	OTGIRQ_PERIPH	            (1<<4)
+#define	OTGIRQ_VBUSEER		    (1<<3)
+#define	OTGIRQ_LOCSOF	            (1<<2)
+#define	OTGIRQ_SRPDET		    (1<<1)
+#define	OTGIRQ_IDLE		    (1<<0)
+
+/*bit 7:5 reserved*/
+/*OTGSTATE*/
+#define	A_IDLE				        (0x00)
+#define	A_WAIT_VRISE		        (0x01)
+#define	A_WAIT_BCON		            (0x02)
+#define	A_HOST				        (0x03)
+#define	A_SUSPEND			        (0x04)
+#define	A_PHERIPHERAL	            (0x05)
+#define	A_VBUS_ERR		            (0x06)
+#define	A_WAIT_VFAL		            (0x07)
+#define B_IDLE				        (0x08)
+#define	B_PHERIPHERAL	            (0x09)
+#define	B_WAIT_ACON		            (0x0a)
+#define	B_HOST				        (0x0b)
+#define	B_SRP_INIT1		            (0x0c)
+#define	B_SRP_INIT2		            (0x0d)
+#define	B_DISCHRG1		            (0x0e)
+#define	B_DISCHRG2		            (0x0f)
+
+/* OTGSTATE value. */
+/* extra dual-role default-b states */
+/* dual-role default-a */
+#define AOTG_STATE_A_IDLE		0
+#define AOTG_STATE_A_WAIT_VRISE		1
+#define AOTG_STATE_A_WAIT_BCON		2
+#define AOTG_STATE_A_HOST		3
+#define AOTG_STATE_A_SUSPEND		4
+#define AOTG_STATE_A_PERIPHERAL		5
+#define AOTG_STATE_A_VBUS_ERR		6
+#define AOTG_STATE_A_WAIT_VFALL		7
+/* single-role peripheral, and dual-role default-b */
+#define AOTG_STATE_B_IDLE		8
+#define AOTG_STATE_B_PERIPHERAL		9
+#define AOTG_STATE_B_WAIT_ACON		10
+#define AOTG_STATE_B_HOST		11
+#define AOTG_STATE_B_SRP_INIT		12
+#define AOTG_STATE_UNDEFINED		17
+
+/*bit 7:4 reserved*/
+/*OTGCTRL*/
+#define	OTGCTRL_FORCEBCONN	        (1 << 7)
+/*bit 6 reserved*/
+#define	OTGCTRL_SRPDATDETEN 		(1 << 5)
+#define	OTGCTRL_SRPVBUSDETEN 		(1 << 4)
+#define	OTGCTRL_BHNPEN				(1 << 3)
+#define	OTGCTRL_ASETBHNPEN			(1 << 2)
+#define	OTGCTRL_ABUSDROP			(1 << 1)
+#define	OTGCTRL_BUSREQ				(1 << 0)
+
+/*OTGSTATUS*/
+/*bit 7 reserved*/
+#define	OTGSTATUS_ID	        	(1 << 6)
+#define	OTGSTATUS_AVBUSSVAL 		(1 << 5)
+#define	OTGSTATUS_BSESSEND			(1 << 4)
+#define	OTGSTATUS_ASESSVAL			(1 << 3)
+#define	OTGSTATUS_BSESSVAL			(1 << 2)
+#define	OTGSTATUS_CONN				(1 << 1)
+#define	OTGSTATUS_BSE0SRP			(1 << 0)
+
+/*OTGIEN*/
+/*bit 7:5 reserved*/
+#define	OTGIEN_PERIPH	            (1 << 4)
+#define	OTGIEN_VBUSEER		        (1 << 3)
+#define	OTGIEN_LOCSOF	            (1 << 2)
+#define	OTGIEN_SRPDET		        (1 << 1)
+#define	OTGIEN_IDLE			        (1 << 0)
+
+/*HCEP0CTRL*/
+#define HCEP0CTRL_ENDPNR(x)         (((x) & 0xf) << 0)
+/*bit 7:4 reserved*/
+
+/* HCINxERR */
+#define	HCINxERR_TYPE_MASK		(0xf << 2)
+/*
+ * 0000 \A8C reserved (no error)
+ * 0001 \A8C CRC error
+ * 0010 \A8C data toggle mismatch
+ * 0011 \A8C endpoint sent STALL handshake
+ * 0100 \A8C no endpoint handshake (timeout)
+ * 0101 \A8C PID error (pid check=error or unknown PID)
+ * 0110 \A8C Data Overrun (too long packet \A8C babble)
+ * 0111 \A8C Data Underrun (packet shorter than MaxPacketSize)
+ * 1xxx \A8C Spilit Transaction Error, reference to HCOUTxSPILITCS register
+*/
+#define	HCINxERR_NO_ERR			(0x0 << 2)
+#define	HCINxERR_CRC_ERR		(0x1 << 2)
+#define	HCINxERR_TOG_ERR		(0x2 << 2)
+#define	HCINxERR_STALL			(0x3 << 2)
+#define	HCINxERR_TIMEOUT		(0x4 << 2)
+#define	HCINxERR_PID_ERR		(0x5 << 2)
+#define	HCINxERR_OVER_RUN		(0x6 << 2)
+#define	HCINxERR_UNDER_RUN		(0x7 << 2)
+#define	HCINxERR_SPLIET			(0x8 << 2)
+#define	HCINxERR_RESEND			(1 << 6)
+
+/*HCOUTXCTRL*/
+//#define HCOUTXCTRL(x)               (((x) & 0xf) << 0)
+/*bit 7:4 reserved*/
+
+
+/******************************************************************************/
+/*Device Mode Special Function Registers*/
+/******************************************************************************/
+/*EP0CS*/
+/*bit 7 reserved*/
+#define EP0CS_HCSETTOOGLE           (1 << 6)
+#define EP0CS_HCCLRTOOGLE           (1 << 5)
+#define EP0CS_HCSET                 (1 << 4)
+#define EP0CS_HCINBSY		        (1 << 3)
+#define	EP0CS_HCOUTBSY	            (1 << 2)
+#define EP0CS_OUTBSY	            (1 << 3)
+#define	EP0CS_INBSY	                (1 << 2)
+#define	EP0CS_HSNAK	                (1 << 1)
+#define	EP0CS_STALL	                (1 << 0)
+
+/*EPXCS host & device*/
+/* HCIN1CS */
+/*bit 7 reserved*/
+//#define	EPCS_AUTO_IN		        (1 << 4)
+//#define	EPCS_AUTO_OUT		        (1 << 4)
+#define EPCS_NPAK                   	(0x3 << 2)
+#define	EPCS_BUSY		       (1 << 1)
+#define	EPCS_ERR		       (1 << 0)
+
+/*EPXCON host & device*/
+#define	EPCON_VAL	                (1 << 7)
+#define	EPCON_STALL	                (1 << 6)
+#define	EPCON_TYPE                  (0x3 << 2)
+#define	EPCON_TYPE_INT		        (0x3 << 2)
+#define	EPCON_TYPE_BULK	            (0x2 << 2)
+#define	EPCON_TYPE_ISO		        (0x1 << 2)
+#define	EPCON_BUF                   (0x03)
+#define	EPCON_BUF_QUAD	            (0x03)
+#define	EPCON_BUF_TRIPLE	        (0x02)
+#define	EPCON_BUF_DOUBLE	        (0x01)
+#define	EPCON_BUF_SINGLE	        (0x00)
+
+/*OUTXIRQ*/
+//#define OUTXIRQ(x)                  (1 << (x))
+/*INXIRQ*/
+//#define INXIRQ(x)                   (1 << (x))
+
+/*USBIRQ*/
+#define	USBIRQ_HS	                (1 << 5)
+#define	USBIRQ_URES	                (1 << 4)
+#define	USBIRQ_SUSP	                (1 << 3)
+#define	USBIRQ_SUTOK	            (1 << 2)
+#define	USBIRQ_SOF	                (1 << 1)
+#define	USBIRQ_SUDAV	            (1 << 0)
+
+/*OUTXIEN*/
+//#define OUTXIEN(x)                  (1 << (x))
+/*INXIEN*/
+//#define INXIEN(x)                   (1 << (x))
+
+/*USBIEN*/
+/*bit 7:6 reserved*/
+#define	USBIEN_HS	                (1 << 5)
+#define	USBIEN_URES               	(1 << 4)
+#define	USBIEN_SUSP             	(1 << 3)
+#define	USBIEN_SUTOK            	(1 << 2)
+#define	USBIEN_SOF	                (1 << 1)
+#define	USBIEN_SUDAV            	(1 << 0)
+
+/* IVECT, USB Interrupt Vector. */
+//#define UIV_OTGIRQ          (0xd8)
+
+#define UIV_SUDAV           0x01
+#define UIV_SOF             0x02
+#define UIV_SUTOK           0x03
+#define UIV_SUSPEND         0x04
+#define UIV_USBRESET        0x05
+#define UIV_HSPEED          0x06
+
+/* otg status. */
+#define UIV_IDLE            0x07
+#define UIV_SRPDET          0x08
+#define UIV_LOCSOF          0x09
+#define UIV_VBUSERR         0x0a
+#define UIV_PERIPH          0x0b
+
+#define UIV_HCOUT0ERR       0x10
+#define UIV_EP0IN           0x20
+#define UIV_HCEP0OUT        0x20
+#define UIV_IN0TOKEN        0x30
+#define UIV_HCIN0ERR        0x40
+#define UIV_EP0OUT          0x50
+#define UIV_HCEP0IN         0x50
+#define UIV_OUT0TOKEN       0x60
+#define UIV_EP0PING         0x70
+
+#define UIV_HCOUT1ERR       0x11
+#define UIV_EP1IN           0x21
+#define UIV_HCEP1OUT        0x21
+#define UIV_IN0T1KEN        0x31
+#define UIV_HCIN1ERR        0x41
+#define UIV_EP1OUT          0x51
+#define UIV_HCEP1IN         0x51
+#define UIV_OUT1TOKEN       0x61
+#define UIV_EP1PING         0x71
+
+#define UIV_HCOUT2ERR       0x12
+#define UIV_EP2IN           0x22
+#define UIV_HCEP2OUT        0x22
+#define UIV_IN2TOKEN        0x32
+#define UIV_HCIN2ERR        0x42
+#define UIV_EP2OUT          0x52
+#define UIV_HCEP2IN         0x52
+#define UIV_OUT2TOKEN       0x62
+#define UIV_EP2PING         0x72
+
+#define UIV_HCOUT3ERR       0x13
+#define UIV_EP3IN           0x23
+#define UIV_HCEP3OUT        0x23
+#define UIV_IN3TOKEN        0x33
+#define UIV_HCIN3ERR        0x43
+#define UIV_EP3OUT          0x53
+#define UIV_HCEP3IN         0x53
+#define UIV_OUT3TOKEN       0x63
+#define UIV_EP3PING         0x73
+
+#define UIV_HCOUT4ERR       0x14
+#define UIV_EP4IN           0x24
+#define UIV_HCEP4OUT        0x24
+#define UIV_IN4TOKEN        0x34
+#define UIV_HCIN4ERR        0x44
+#define UIV_EP4OUT          0x54
+#define UIV_HCEP4IN         0x54
+#define UIV_OUT4TOKEN       0x64
+#define UIV_EP4PING         0x74
+
+#define UIV_HCOUT5ERR       0x15
+#define UIV_EP5IN           0x25
+#define UIV_HCEP5OUT        0x25
+#define UIV_IN5TOKEN        0x35
+#define UIV_HCIN5ERR        0x45
+#define UIV_EP5OUT          0x55
+#define UIV_HCEP5IN         0x55
+#define UIV_OUT5TOKEN       0x65
+#define UIV_EP5PING         0x75
+
+#define UIV_HCOUT6ERR       0x16
+#define UIV_EP6IN           0x26
+#define UIV_HCEP6OUT        0x26
+#define UIV_IN6TOKEN        0x36
+#define UIV_HCIN6ERR        0x46
+#define UIV_EP6OUT          0x56
+#define UIV_HCEP6IN         0x56
+#define UIV_OUT6TOKEN       0x66
+#define UIV_EP6PING         0x76
+
+#define UIV_HCOUT7ERR       0x17
+#define UIV_EP7IN           0x27
+#define UIV_HCEP7OUT        0x27
+#define UIV_IN7TOKEN        0x37
+#define UIV_HCIN7ERR        0x47
+#define UIV_EP7OUT          0x57
+#define UIV_HCEP7IN         0x57
+#define UIV_OUT7TOKEN       0x67
+#define UIV_EP7PING         0x77
+
+#define UIV_HCOUT8ERR       0x18
+#define UIV_EP8IN           0x28
+#define UIV_HCEP8OUT        0x28
+#define UIV_IN8TOKEN        0x38
+#define UIV_HCIN8ERR        0x48
+#define UIV_EP8OUT          0x58
+#define UIV_HCEP8IN         0x58
+#define UIV_OUT8TOKEN       0x68
+#define UIV_EP8PING         0x78
+
+#define UIV_HCOUT9ERR       0x19
+#define UIV_EP9IN           0x29
+#define UIV_HCEP9OUT        0x29
+#define UIV_IN9TOKEN        0x39
+#define UIV_HCIN9ERR        0x49
+#define UIV_EP9OUT          0x59
+#define UIV_HCEP9IN         0x59
+#define UIV_OUT9TOKEN       0x69
+#define UIV_EP9PING         0x79
+
+#define UIV_HCOUT10ERR       0x1a
+#define UIV_EP10IN           0x2a
+#define UIV_HCEP10OUT        0x2a
+#define UIV_IN10TOKEN        0x3a
+#define UIV_HCIN10ERR        0x4a
+#define UIV_EP10OUT          0x5a
+#define UIV_HCEP10IN         0x5a
+#define UIV_OUT10TOKEN       0x6a
+#define UIV_EP10PING         0x7a
+
+#define UIV_HCOUT11ERR       0x1b
+#define UIV_EP11IN           0x2b
+#define UIV_HCEP11OUT        0x2b
+#define UIV_IN11TOKEN        0x3b
+#define UIV_HCIN11ERR        0x4b
+#define UIV_EP11OUT          0x5b
+#define UIV_HCEP11IN         0x5b
+#define UIV_OUT11TOKEN       0x6b
+#define UIV_EP11PING         0x7b
+
+#define UIV_HCOUT12ERR       0x1c
+#define UIV_EP12IN           0x2c
+#define UIV_HCEP12OUT        0x2c
+#define UIV_IN12TOKEN        0x3c
+#define UIV_HCIN12ERR        0x4c
+#define UIV_EP12OUT          0x5c
+#define UIV_HCEP12IN         0x5c
+#define UIV_OUT12TOKEN       0x6c
+#define UIV_EP12PING         0x7c
+
+#define UIV_HCOUT13ERR       0x1d
+#define UIV_EP13IN           0x2d
+#define UIV_HCEP13OUT        0x2d
+#define UIV_IN13TOKEN        0x3d
+#define UIV_HCIN13ERR        0x4d
+#define UIV_EP13OUT          0x5d
+#define UIV_HCEP13IN         0x5d
+#define UIV_OUT13TOKEN       0x6d
+#define UIV_EP13PING         0x7d 
+
+#define UIV_HCOUT14ERR       0x1e
+#define UIV_EP14IN           0x2e
+#define UIV_HCEP14OUT        0x2e
+#define UIV_IN14TOKEN        0x3e
+#define UIV_HCIN14ERR        0x4e
+#define UIV_EP14OUT          0x5e
+#define UIV_HCEP14IN         0x5e
+#define UIV_OUT14TOKEN       0x6e
+#define UIV_EP14PING         0x7e 
+
+#define UIV_HCOUT15ERR       0x1f
+#define UIV_EP15IN           0x2f
+#define UIV_HCEP15OUT        0x2f
+#define UIV_IN15TOKEN        0x3f
+#define UIV_HCIN15ERR        0x4f
+#define UIV_EP15OUT          0x5f
+#define UIV_HCEP15IN         0x5f
+#define UIV_OUT15TOKEN       0x6f
+#define UIV_EP15PING         0x7f 
+
+
+/*ENDPRST*/
+#define ENDPRST_EPX(x)              ((x) & 0xf)
+#define ENDPRST_IO                  (1 << 4)
+#define ENDPRST_FIFORST             (1 << 5)
+#define ENDPRST_TOGRST              (1 << 6)
+#define ENDPRST_TOGRST_R            (0x3 << 6)
+/*bit 7 reserved*/
+
+/*USBCS*/
+/*bit 7 reserved*/
+#define	USBCS_DISCONN		        (1 << 6)
+#define	USBCS_SIGRSUME		        (1 << 5)
+#define	USBCS_HFMODE                (1 << 1)
+#define USBCS_LSMODE                (1 << 0)
+
+#if 0 /******** need to check bits. ***********************/
+/*FIFOCTRL*/
+/*bit 7:6 reserved*/
+#define FIFOCTRL_EPX(x)             ((x) & 0xf)
+#define	FIFOCTRL_FIFOAUTO	        (1 << 5)
+#define	FIFOCTRL_IO			        (1 << 4)
+
+#endif
+
+
+static void inline usb_writeb(u8 val, volatile void __iomem *reg)
+{
+	writeb(val, reg);
+}
+
+static void inline usb_writew(u16 val, volatile void __iomem *reg)
+{
+	writew(val, reg);
+}
+
+static void inline usb_writel(u32 val, volatile void __iomem *reg)
+{
+	writel(val, reg);
+}
+
+/******************************************************************************/
+static inline u8 usb_readb(volatile void __iomem *reg)
+{
+	return readb(reg);
+}
+
+static inline u16 usb_readw(volatile void __iomem *reg)
+{
+	return readw(reg);
+}
+
+static inline u32 usb_readl(volatile void __iomem *reg)
+{
+	return readl(reg);
+}
+
+/******************************************************************************/
+static void inline usb_setb(u8 val, volatile void __iomem *reg)
+{
+	//act_setb(val, (u32)reg);
+	writeb(readb(reg) | val, reg);
+}
+
+static void inline usb_setw(u16 val,volatile void __iomem *reg)
+{
+	//act_setw(val, (u32)reg);
+	writew(readw(reg) | val, reg);
+}
+
+static void inline usb_setl(u32 val,volatile void __iomem *reg)
+{
+	//act_setl(val, (u32)reg);
+	writel(readl(reg) | val, reg);
+}
+
+/******************************************************************************/
+static void inline usb_clearb(u8 val,volatile void __iomem *reg)
+{
+	//act_clearb(val, (u32)reg);
+	writeb(readb(reg)&(~val),reg);
+}
+
+static void inline usb_clearw(u16 val,volatile void __iomem *reg)
+{
+	//act_clearw(val, (u32)reg);
+	writew(readw(reg)&(~val),reg);
+}
+
+static void inline usb_clearl(u32 val,volatile void __iomem *reg)
+{
+	//act_clearl(val, (u32)reg);
+	writel(readl(reg)&(~val),reg);
+}
+
+/*********************** old define. *****************************************/
+
+static inline void usb_setbitsb(u8 mask, volatile void __iomem *mem)
+{
+	writeb(readb(mem) | mask, mem);
+}
+
+static inline void usb_setbitsw(u16 mask, volatile void __iomem *mem)
+{
+	writew(readw(mem) | mask, mem);
+}
+
+static inline void usb_setbitsl(ulong mask, volatile void __iomem *mem)
+{
+	writel(readl(mem) | mask, mem);
+}
+
+static inline void usb_clearbitsb(u8 mask, volatile void __iomem *mem)
+{
+	writeb(readb(mem) & ~mask, mem);
+}
+
+static inline void usb_clearbitsw(u16 mask, volatile void __iomem *mem)
+{
+	writew(readw(mem) & ~mask, mem);
+}
+
+static inline void usb_clearbitsl(ulong mask, volatile void __iomem *mem)
+{
+	writel(readl(mem) & ~mask, mem);
+}
+
+#endif  /* __AOTG_REGS_H__ */
+
diff --git a/drivers/usb/aotg/aotg_ring.c b/drivers/usb/aotg/aotg_ring.c
new file mode 100755
index 0000000..d81de65
--- /dev/null
+++ b/drivers/usb/aotg/aotg_ring.c
@@ -0,0 +1,1509 @@
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+
+#include "aotg_hcd.h"
+#include "aotg_hcd_debug.h"
+#include "aotg_mon.h"
+
+void aotg_set_ring_linkaddr(struct aotg_ring *ring, u32 addr);
+int aotg_set_trb_as_ring_linkaddr(struct aotg_ring *ring, struct aotg_trb *trb);
+u32 ring_trb_virt_to_dma(struct aotg_ring *ring, 
+							struct aotg_trb *trb_vaddr);
+void clear_ring_irq(struct aotg_hcd *acthcd, unsigned int irq_mask);
+
+void aotg_dump_linklist_reg_2(struct aotg_hcd *acthcd, int dmanr)
+{
+	int is_out, index, index_multi;
+	
+	is_out = (dmanr & AOTG_DMA_OUT_PREFIX) ? 1 : 0;
+	index = dmanr & 0xf;
+	if (index >= 1) {
+		index_multi = index - 1;
+	} else {
+		ACT_HCD_ERR
+		return;
+	}
+
+	printk("--------- dma reg, ep%d-%s-------\n", index,
+			is_out ? "out" : "in");
+		
+	printk("HCDMABCKDOOR(0x%p) : 0x%x\n",
+		acthcd->base + HCDMABCKDOOR, readl(acthcd->base + HCDMABCKDOOR));
+	printk("HCDMAxOVERFLOWIRQ(0x%p) : 0x%x\n",
+		acthcd->base + HCDMAxOVERFLOWIRQ, readl(acthcd->base + HCDMAxOVERFLOWIRQ));
+	printk("HCDMAxOVERFLOWIEN(0x%p) : 0x%x\n",
+		acthcd->base + HCDMAxOVERFLOWIEN, readl(acthcd->base + HCDMAxOVERFLOWIEN));
+
+	if (is_out) {
+		printk("HCOUT%dDMALINKADDR(0x%p) : 0x%x\n", index,
+			acthcd->base + HCOUT1DMALINKADDR + index_multi * 0x10,
+			readl(acthcd->base + HCOUT1DMALINKADDR + index_multi * 0x10));
+		printk("HCOUT%dDMACURADDR(0x%p) : 0x%x\n",index,
+			acthcd->base + HCOUT1DMACURADDR + index_multi * 0x10,
+			readl(acthcd->base + HCOUT1DMACURADDR + index_multi * 0x10));
+		printk("HCOUT%dDMACTRL(0x%p) : 0x%x\n", index,
+			acthcd->base + HCOUT1DMACTRL + index_multi * 0x10,
+			readl(acthcd->base + HCOUT1DMACTRL + index_multi * 0x10));
+		printk("HCOUT%dDMACOMPLETECNT(0x%p) : 0x%x\n", index,
+			acthcd->base + HCOUT1DMACOMPLETECNT + index_multi * 0x10,
+			readl(acthcd->base + HCOUT1DMACOMPLETECNT + index_multi * 0x10));
+	} else {		
+		printk("HCIN%dDMALINKADDR(0x%p) : 0x%x\n", index,
+			acthcd->base + HCIN1DMALINKADDR+ index_multi * 0x10,
+			readl(acthcd->base + HCIN1DMALINKADDR+ index_multi * 0x10));
+		printk("HCIN%dDMACURADDR(0x%p) : 0x%x\n", index,
+			acthcd->base + HCIN1DMACURADDR + index_multi * 0x10,
+			readl(acthcd->base + HCIN1DMACURADDR + index_multi * 0x10));
+		printk("HCIN%dDMACTRL(0x%p) : 0x%x\n", index,
+			acthcd->base + HCIN1DMACTRL+ index_multi * 0x10,
+			readl(acthcd->base + HCIN1DMACTRL+ index_multi * 0x10));	
+		printk("HCIN%dDMACOMPLETECNT(0x%p) : 0x%x\n", index,
+			acthcd->base + HCIN1DMACOMPLETECNT + index_multi * 0x10,
+			readl(acthcd->base + HCIN1DMACOMPLETECNT + index_multi * 0x10));	
+	}
+}
+
+static void aotg_hcd_dump_trb(struct aotg_ring *ring, struct aotg_trb *trb)
+{
+	printk("trb:0x%x, dma:0x%x\n", (u32)trb, 
+		(u32)ring_trb_virt_to_dma(ring, trb));
+	printk("hw_buf_ptr : 0x%x\n", trb->hw_buf_ptr);
+	printk("hw_buf_len : %d\n", trb->hw_buf_len);
+	printk("hw_buf_remain : %d\n", trb->hw_buf_remain);
+	printk("hw_token : 0x%x\n", trb->hw_token);	
+}
+
+void aotg_hcd_dump_td(struct aotg_ring *ring, struct aotg_td *td)
+{
+	int i, j;
+	int num_trbs;	
+	struct aotg_trb *trb;
+
+	if (td == NULL){
+		ACT_HCD_ERR
+		return;
+	}
+	
+	num_trbs = td->num_trbs;
+	trb = td->trb_vaddr;
+
+	printk("==== dump td: %d trbs ====\n", td->num_trbs);
+	
+	if (trb + num_trbs > ring->last_trb) {
+		for (i = 0; trb + i < ring->last_trb + 1; i++) {
+			printk("trb_%d:\n", i);
+			aotg_hcd_dump_trb(ring, trb + i);												
+		}
+		trb = ring->first_trb;
+		j = 0;
+		for (; i < num_trbs; i++) {
+			printk("trb_%d:\n", i);
+			aotg_hcd_dump_trb(ring, trb + j);
+			j++;
+		}	
+	} else {
+		for (i = 0; i < num_trbs; i++) {
+			printk("trb_%d:\n", i);
+			aotg_hcd_dump_trb(ring, trb + i);
+		}
+	}
+	
+	printk("\n");
+
+	return;	
+}
+
+void inc_dequeue_safe(struct aotg_ring *ring)
+{
+	atomic_inc(&ring->num_trbs_free);
+	if (ring->dequeue_trb == ring->ring_trb) {
+		ring->dequeue_trb = ring->first_trb;
+	} else {
+		ring->dequeue_trb++;
+	}
+	return;
+}
+
+struct aotg_ring *aotg_alloc_ring(struct aotg_hcd *acthcd,
+				struct aotg_hcep *ep, unsigned int num_trbs, 
+				gfp_t mem_flags)
+{
+	dma_addr_t	dma;
+	struct device *dev = aotg_to_hcd(acthcd)->self.controller;
+	struct aotg_ring *ring;
+
+	ring = kmalloc(sizeof(struct aotg_ring), mem_flags);
+	if (!ring) {
+		return NULL;
+	}
+
+	ring->num_trbs = num_trbs;
+	if (num_trbs == 0) {
+		ACT_HCD_DBG
+		return ring;
+	}
+		
+	ring->first_trb = (struct aotg_trb *)
+					dma_alloc_coherent(dev,	num_trbs * sizeof(struct aotg_trb),
+					&dma, mem_flags);
+
+	HUB_DEBUG("frist_trb:%x,dma:%x\n",ring->first_trb,dma);
+	memset(ring->first_trb, 0, num_trbs * sizeof(struct aotg_trb));
+	//memset(ring->first_trb, 0, RING_SIZE);
+	ring->trb_dma = (u32)dma;
+	ring->last_trb = ring->first_trb + num_trbs - 1;
+	ring->ring_trb = ring->last_trb;
+	atomic_set(&ring->num_trbs_free, num_trbs);
+	ring->enqueue_trb = ring->first_trb;
+	ring->dequeue_trb = ring->first_trb;
+
+	ring->is_running = 0;
+	ring->is_out = ep->is_out ? 1 : 0;
+	ring->intr_inited = 0;
+	ring->intr_started = 0;
+	ring->priv = ep;
+	ring->mask = ep->mask;
+	ring->type = ep->type;
+	ring->enring_cnt = 0;
+	ring->dering_cnt = 0;
+	ring->ring_stopped= 0;
+
+	ring->reg_dmalinkaddr = GET_DMALINKADDR_REG(ring->is_out, acthcd->base + HCOUT1DMALINKADDR,
+								acthcd->base + HCIN1DMALINKADDR, ep->index);
+	ring->reg_curaddr = GET_CURADDR_REG(ring->is_out, acthcd->base + HCOUT1DMACURADDR,
+								acthcd->base + HCIN1DMACURADDR, ep->index);
+	ring->reg_dmactrl = GET_DMACTRL_REG(ring->is_out, acthcd->base + HCOUT1DMACTRL,
+								acthcd->base + HCIN1DMACTRL, ep->index);
+	ring->reg_dmacomplete_cnt = GET_DMACOMPLETE_CNT_REG(ring->is_out, 
+								acthcd->base + HCOUT1DMACOMPLETECNT,
+								acthcd->base + HCIN1DMACOMPLETECNT, ep->index);
+
+
+	/*printk("=====================================\n");
+		
+	printk("first_trb:0x%x,last_trb:0x%x, ring_trb:0x%x\n",
+			(u32)(ring->first_trb), (u32)(ring->last_trb), (u32)(ring->ring_trb));
+
+	printk("enq_trb:0x%x, deq_trb:0x%x\n",
+			(u32)(ring->enqueue_trb), (u32)(ring->dequeue_trb));
+	printk("=====================================\n");*/
+	return ring;
+}
+
+void aotg_free_ring(struct aotg_hcd *acthcd, struct aotg_ring *ring)
+{
+	struct device *dev = aotg_to_hcd(acthcd)->self.controller;
+	if (!ring) {
+		return;
+	}
+
+	dma_free_coherent(dev, ring->num_trbs * sizeof(struct aotg_trb),
+			ring->first_trb, ring->trb_dma);
+	kfree(ring);
+	return;
+}
+
+struct aotg_td *aotg_alloc_td(gfp_t mem_flags)
+{
+	struct aotg_td *td;
+
+	//td = kmalloc(sizeof(struct aotg_td), mem_flags);	
+	td = kmalloc(sizeof(struct aotg_td), GFP_ATOMIC);
+	if (!td) {
+		return NULL;
+	}
+	memset(td, 0, sizeof(struct aotg_td));
+
+	td->cross_ring = 0;
+	td->err_count = 0;
+	td->urb = NULL;
+	INIT_LIST_HEAD(&td->queue_list);
+	INIT_LIST_HEAD(&td->enring_list);
+	INIT_LIST_HEAD(&td->dering_list);	
+
+	return td;
+}
+
+void aotg_release_td(struct aotg_td *td)
+{
+	if (!td)
+		return;
+	kfree(td);
+}
+
+void enable_overflow_irq(struct aotg_hcd *acthcd, struct aotg_hcep *ep)
+{
+	u8 mask = ep->mask;
+	u8 is_out = mask & USB_HCD_OUT_MASK;
+	u8 ep_num = mask & 0x0f;
+
+	if (is_out) {
+		usb_setbitsl(1 << (ep_num + 16), acthcd->base + HCDMAxOVERFLOWIEN);
+	} else {
+		usb_setbitsl(1 << ep_num, acthcd->base + HCDMAxOVERFLOWIEN);
+	}
+	return;
+}
+
+void disable_overflow_irq(struct aotg_hcd *acthcd, struct aotg_hcep *ep)
+{
+	u8 mask = ep->mask;
+	u8 is_out = mask & USB_HCD_OUT_MASK;
+	u8 ep_num = mask & 0x0f;
+
+	if (is_out) {
+		usb_clearbitsl(1 << (ep_num + 16), acthcd->base + HCDMAxOVERFLOWIEN);
+	} else {
+		usb_clearbitsl(1 << ep_num, acthcd->base + HCDMAxOVERFLOWIEN);
+	}
+	return;
+}
+
+void clear_overflow_irq(struct aotg_hcd *acthcd, struct aotg_hcep *ep)
+{
+	u8 mask = ep->mask;
+	u8 is_out = mask & USB_HCD_OUT_MASK;
+	u8 ep_num = mask & 0x0f;
+
+	if (is_out) {
+		usb_clearbitsl(1 << (ep_num + 16), acthcd->base + HCDMAxOVERFLOWIRQ);
+	} else {		
+		usb_clearbitsl(1 << ep_num, acthcd->base + HCDMAxOVERFLOWIRQ);
+	}
+}
+
+// FIXME
+void overflow_irq_handler(struct aotg_hcd *acthcd, struct aotg_hcep *ep)
+{
+	struct aotg_ring *ring;
+	
+	if (!ep) {
+		printk(KERN_ERR"%s, ep%d is NULL!\n", __FUNCTION__, ep->index);
+		return;
+	}
+
+	ring = ep->ring;
+
+	return;
+}
+/*
+void aotg_handle_overflow_irq(struct aotg_hcd *acthcd)
+{
+	int i;
+	unsigned int irq_pend = 0;
+	struct aotg_hcep *ep;
+
+	irq_pend = readl(acthcd->base + HCDMAxOVERFLOWIRQ);
+
+	if (irq_pend & RING_IN_OF) {
+		for (i = 1; i < 16; i++) {
+			if (irq_pend & (0x1 << i)) {
+				ep = acthcd->inep[i];
+ 				overflow_irq_handler(acthcd, ep);
+			}
+		}
+	}
+
+	if (irq_pend & RING_OUT_OF) {
+		for (i = 1; i < 16; i++) {
+			if (irq_pend & (0x1 << (i + 16))) {
+				ep = acthcd->outep[i];
+ 				overflow_irq_handler(acthcd, ep);
+			}	
+	}
+
+	writel(irq_pend, acthcd->base + HCDMAxOVERFLOWIRQ); 		
+}
+*/
+int is_ring_running(struct aotg_ring *ring)
+{
+	return (readl(ring->reg_dmactrl) & 0x1) ? 1 : 0;
+}
+
+void aotg_start_ring(struct aotg_ring *ring, u32 addr)
+{
+	struct aotg_trb *temp_trb = ring->dequeue_trb;
+	int i;
+	if ((ring->type == PIPE_BULK) && ((temp_trb->hw_token & TRB_OF)== 0)) {
+		for (i=0; i< NUM_TRBS; i++) {
+			if (temp_trb->hw_token == 0xaa) { /*deal dequeue urb*/
+				inc_dequeue_safe(ring);
+				memset(temp_trb,0,sizeof(struct aotg_trb));
+			}
+			else if (temp_trb->hw_token & TRB_OF) {
+				break;
+			}
+			
+			if (temp_trb == ring->last_trb) {
+				temp_trb= ring->first_trb;
+			}
+			else {
+				temp_trb++;
+			}
+		}
+		addr = ring_trb_virt_to_dma(ring, temp_trb);
+	}
+	aotg_set_ring_linkaddr(ring, addr);
+	mb();
+	writel(DMACTRL_DMACS,ring->reg_dmactrl);
+
+}
+
+void aotg_stop_ring(struct aotg_ring *ring)
+{
+	writel(DMACTRL_DMACC, ring->reg_dmactrl);
+}
+
+void aotg_pause_ring(struct aotg_ring *ring)
+{
+	usb_setbitsl(DMACTRL_DMACC, ring->reg_dmactrl);			
+}
+
+#if(0)
+void aotg_stop_ring(struct aotg_hcd *acthcd, struct aotg_hcep *ep)
+{
+	writel(DMACTRL_DMACC,ep->ring->reg_dmactrl);
+	usb_clearbitsb(0x80, ep->reg_hcepcon);
+	usb_settoggle(ep->udev, ep->epnum, ep->is_out, 0);
+	aotg_hcep_reset(acthcd, ep->mask, ENDPRST_FIFORST);
+	writeb(ep->epnum, ep->reg_hcepctrl);
+	usb_setbitsb(0x80, ep->reg_hcepcon);
+}
+#endif
+
+u32 ring_trb_virt_to_dma(struct aotg_ring *ring, 
+							struct aotg_trb *trb_vaddr)
+{
+	u32 addr;
+	
+	unsigned long offset;
+
+	if (!ring || !trb_vaddr) {
+		return 0;
+	}
+
+	if (trb_vaddr > ring->last_trb) {
+		return 0;
+	}
+
+	offset = trb_vaddr - ring->first_trb;
+	//return ring->trb_dma + (offset * sizeof(*trb_vaddr));
+	addr = ring->trb_dma + (offset * sizeof(*trb_vaddr));
+	
+	//addr = (u32)virt_to_phys(trb_vaddr);
+	//printk("---out:%d,offset:%ld, trb:0x%x,addr:0x%x------\n",ring->is_out,offset, 
+	//		trb_vaddr, addr);
+	return addr;
+	
+}
+
+void aotg_set_ring_linkaddr(struct aotg_ring *ring, u32 addr)
+{
+	if (!ring) {
+		ACT_HCD_ERR
+		return;
+	}
+	writel(addr, ring->reg_dmalinkaddr);
+
+	//printk("linkaddr(0x%p):0x%x\n", ring->reg_dmalinkaddr,
+	//		readl(ring->reg_dmalinkaddr));
+}
+
+int aotg_set_trb_as_ring_linkaddr(struct aotg_ring *ring, struct aotg_trb *trb)
+{
+	u32 addr;
+
+	addr = (u32)ring_trb_virt_to_dma(ring, trb);
+	if (!addr) {
+		ACT_HCD_ERR
+		return -1;
+	}
+	
+	aotg_set_ring_linkaddr(ring, addr);
+	return 0;
+}
+
+int ring_empty(struct aotg_ring *ring)
+{
+	return (atomic_read(&ring->num_trbs_free) == NUM_TRBS) ? 1 : 0;
+}
+
+int ring_full(struct aotg_ring *ring)
+{
+	return (atomic_read(&ring->num_trbs_free) == 0) ? 1 : 0;
+}
+
+inline int is_room_on_ring(struct aotg_ring *ring, unsigned int num_trbs)
+{
+	return (num_trbs > atomic_read(&ring->num_trbs_free)) ? 0 : 1;
+}
+
+inline unsigned int	count_urb_need_trbs(struct urb *urb)
+{
+	int num_sgs, num_trbs;
+	/* at least one trb */
+	num_sgs = urb->num_mapped_sgs;
+	if (num_sgs == 0) {
+		num_trbs = 1;
+	} else {
+		num_trbs = num_sgs;
+	}
+		
+	if (usb_pipeout(urb->pipe) && 
+			(urb->transfer_flags & URB_ZERO_PACKET)) {
+		num_trbs++;
+	}
+
+	return num_trbs;
+}
+
+void aotg_fill_trb(struct aotg_trb *trb,
+					u32 dma_addr, u32 len, u32 token)
+{
+	trb->hw_buf_ptr = dma_addr;
+	trb->hw_buf_len = len;
+	trb->hw_token = token;
+
+	ACT_LINKLIST_DMA_DEBUG("hw_ptr(0x%x), hw_len(%d),hw_token(0x%x)\n",
+			trb->hw_buf_ptr, trb->hw_buf_len, trb->hw_token);
+	return;
+}
+
+int aotg_sg_map_trb(struct aotg_trb *trb, 
+						struct scatterlist *sg, int len, u32 token) 
+{
+	int this_trb_len;
+
+	if (NULL == sg) {
+		aotg_fill_trb(trb, 0, 0, token);
+		return 0;
+	}
+
+	this_trb_len = min_t(int, sg_dma_len(sg), len);
+
+	aotg_fill_trb(trb, (u32)sg_dma_address(sg), this_trb_len, token);
+
+	return this_trb_len;
+}
+#if (0)
+/*
+ * ring->enqueue_trb should be overflow
+ */
+void inc_enqueue_safe(struct aotg_ring *ring)
+{
+	atomic_dec(&ring->num_trbs_free);
+	if (ring->enqueue_trb == ring->ring_trb) {
+		if (ring->type == PIPE_BULK) {
+			ring->enqueue_trb->hw_token &= ~TRB_CHN;
+			if (ring->is_out)			
+				ring->enqueue_trb->hw_token |= TRB_ITE | TRB_LT;
+			else 		
+				ring->enqueue_trb->hw_token |= TRB_ICE | TRB_LT;
+			ring->enqueue_trb = ring->first_trb;
+		} else {
+			ring->enqueue_trb->hw_token |= TRB_COF;
+			ring->enqueue_trb = ring->first_trb;
+		}
+	} else {
+		ring->enqueue_trb += 1;
+	}
+}
+#endif
+void enqueue_trb(struct aotg_ring *ring, u32 buf_ptr, u32 buf_len,
+				u32 token)
+{
+	struct aotg_trb *trb;
+	trb = ring->enqueue_trb;
+
+	atomic_dec(&ring->num_trbs_free);
+	if (trb == ring->last_trb) {
+		if (ring->type == PIPE_BULK) {
+			token &= ~TRB_CHN;
+			if (ring->is_out)
+				token |= TRB_ITE | TRB_LT;
+			else
+				token |= TRB_ICE | TRB_LT;
+			ring->enqueue_trb = ring->first_trb;
+		} else {
+			token |= TRB_COF;
+			ring->enqueue_trb = ring->first_trb;
+		}
+	} else {
+		ring->enqueue_trb += 1;
+	}
+
+	trb->hw_buf_ptr = buf_ptr;
+	trb->hw_buf_len = buf_len;
+	trb->hw_buf_remain = 0;
+	wmb();
+	trb->hw_token = token;
+}
+
+/*
+ * ensure ring has enough room for this td 
+ * before call this function.
+ */
+int ring_enqueue_sg_td(struct aotg_hcd *acthcd,
+				struct aotg_ring *ring, struct aotg_td *td)
+{
+	u8 is_out;
+	int num_sgs, num_trbs;
+	int len, this_trb_len;
+	u32 addr, token;
+	struct urb *urb = td->urb;
+	struct scatterlist *sg;
+
+	is_out = usb_pipeout(urb->pipe);
+
+	len = urb->transfer_buffer_length;
+	num_sgs = urb->num_mapped_sgs;	
+	num_trbs = count_urb_need_trbs(urb);
+
+	td->num_trbs = num_trbs;
+	td->trb_vaddr = ring->enqueue_trb;
+	td->trb_dma= ring_trb_virt_to_dma(ring, ring->enqueue_trb);
+
+	if (td->trb_vaddr + (num_trbs - 1) > ring->last_trb) {
+		td->cross_ring = 1;
+	}
+
+	sg = urb->sg;
+	addr = (u32)sg_dma_address(sg);
+	this_trb_len = (u32)min_t(int, sg_dma_len(sg), len);
+
+	if (is_out) 
+		token = TRB_OF;
+	else 
+		//token = TRB_CSP | TRB_ISE | TRB_IZE | TRB_OF;		
+		token = TRB_CSP | TRB_OF;
+				
+	do {
+		if (num_trbs == 1) {		
+			token &= ~TRB_CHN;
+			if (is_out) 
+				token |= TRB_ITE;
+			else 
+				token |= TRB_ICE;
+			
+			if (is_out && (urb->transfer_flags & URB_ZERO_PACKET)) 
+				enqueue_trb(ring, 0, 0, token);
+		 	else 
+				enqueue_trb(ring, addr, this_trb_len, token);
+			break;			
+		}
+		token |= TRB_CHN;
+		enqueue_trb(ring, addr, this_trb_len, token);
+		len -= this_trb_len;
+		num_trbs--;
+		num_sgs--;
+
+		if (num_sgs) {
+			sg = sg_next(sg);
+			addr = (u32)sg_dma_address(sg);
+			this_trb_len = (u32)min_t(int, sg_dma_len(sg), len);
+		}
+	} while (num_trbs);
+
+	//aotg_hcd_dump_td(ring, td);
+
+	return 0;
+}
+
+int aotg_ring_enqueue_td(struct aotg_hcd *acthcd, 
+				struct aotg_ring *ring, struct aotg_td *td)
+{
+	u8 is_out;
+	u32 addr, token, this_trb_len;
+	int num_trbs;
+	struct urb *urb = td->urb;
+
+	if (!acthcd || !td || !ring || !urb) {
+		ACT_HCD_ERR
+		return -1;
+	}
+	
+	num_trbs = count_urb_need_trbs(urb);
+
+	if (!is_room_on_ring(ring, num_trbs)) {
+		//ACT_HCD_DBG
+		return -1;
+	}
+
+	if (urb->num_sgs) {
+		return ring_enqueue_sg_td(acthcd, ring, td);		
+	}
+	
+	is_out = usb_pipeout(urb->pipe);
+	
+	td->num_trbs = num_trbs;
+	td->trb_vaddr = ring->enqueue_trb;
+	td->trb_dma = ring_trb_virt_to_dma(ring, ring->enqueue_trb);
+	
+	addr = (u32)urb->transfer_dma;
+	this_trb_len = (u32)urb->transfer_buffer_length;
+
+	if (is_out) {
+		token = TRB_OF;
+	} else {
+		token = TRB_CSP | TRB_OF;
+	}
+
+	/*
+	 * Finish bulk OUT with short packet	
+	 */
+	if (num_trbs > 1) {
+		token |= TRB_CHN;
+		enqueue_trb(ring, addr, this_trb_len, token);
+		addr = 0;
+		this_trb_len = 0;
+	}
+	
+	token &= ~TRB_CHN;
+	if (!port_host_plug_detect[acthcd->id])
+		token |= TRB_LT; /*8723bu,release cpu for interrupt transfer*/
+	if (is_out)	
+		token |= TRB_ITE;
+	else 
+		token |= TRB_ICE;
+
+	enqueue_trb(ring, addr, this_trb_len, token);
+	
+	//aotg_hcd_dump_td(ring, td);
+	
+	return 0;
+}
+
+void aotg_reorder_intr_td( struct aotg_hcep *ep) {
+	struct aotg_td *td, *next, *entry_td = NULL;
+	struct urb *urb;
+	struct aotg_ring *ring;
+	unsigned long td_temp = ULONG_MAX;
+	ring = ep->ring;
+	
+	ring->dequeue_trb = ring->first_trb;
+	ring->enqueue_trb = ring->first_trb;
+	list_for_each_entry(td, &ep->enring_td_list, enring_list) {
+		if (td_temp > (unsigned long)(td->intr_mem_vaddr)) {
+			td_temp = (unsigned long)(td->intr_mem_vaddr);
+			entry_td = td;
+		}
+	}
+	
+	list_for_each_entry_safe(td, next, &ep->enring_td_list, enring_list) {
+		if ((unsigned long)(td->intr_mem_vaddr) > td_temp) {
+			if (td->urb) {
+				urb = td->urb;
+				td->urb = NULL;
+				entry_td->urb = urb;
+				entry_td = list_entry(entry_td->enring_list.next,struct aotg_td,enring_list);
+			}
+			list_del(&td->enring_list);
+			list_add_tail(&td->enring_list, &ep->enring_td_list);
+		}
+		else {
+			break;
+		}
+	}
+}
+
+void aotg_reorder_iso_td(struct aotg_hcd *acthcd, struct aotg_ring *ring) {
+	struct aotg_td *td, *next;
+	struct aotg_trb *new_trb_q, *prev_trb_q, *trb;
+	int i;
+	dma_addr_t dma, prev_dma;
+	struct device *dev = aotg_to_hcd(acthcd)->self.controller;
+	struct aotg_hcep *ep = (struct aotg_hcep *)ring->priv;
+
+	new_trb_q = (struct aotg_trb *)
+		dma_alloc_coherent(dev,	NUM_TRBS * sizeof(struct aotg_trb),
+		&dma, GFP_ATOMIC);
+	if (!new_trb_q) {
+		pr_err("dma_alloc_coherent trb error!!!\n" );
+		return;
+	}
+	memset(new_trb_q, 0, NUM_TRBS * sizeof(struct aotg_trb));
+	prev_trb_q = ring->first_trb;
+	ring->first_trb = new_trb_q;
+	prev_dma = ring->trb_dma;
+	ring->trb_dma = (u32)dma;
+	ring->last_trb = ring->first_trb + NUM_TRBS - 1;
+	ring->ring_trb = ring->last_trb;
+	atomic_set(&ring->num_trbs_free, NUM_TRBS);
+	ring->enqueue_trb = ring->first_trb;
+	ring->dequeue_trb = ring->first_trb;
+
+	list_for_each_entry_safe(td, next, &ep->enring_td_list, enring_list) {
+		if (td) {
+			trb = td->trb_vaddr;
+			td->trb_vaddr = ring->enqueue_trb;
+			td->trb_dma = ring_trb_virt_to_dma(ring, ring->enqueue_trb);
+			for (i = 0; i < td->num_trbs; i++) {
+				enqueue_trb(ring, trb->hw_buf_ptr, trb->hw_buf_len, trb->hw_token &(~TRB_COF));
+			}
+		}
+	}
+	dma_free_coherent(dev, NUM_TRBS * sizeof(struct aotg_trb), prev_trb_q, prev_dma);
+}
+
+int aotg_ring_enqueue_intr_td(struct aotg_hcd *acthcd, struct aotg_ring *ring, 
+						struct aotg_hcep *ep, struct urb *urb, gfp_t mem_flags)
+{
+	u8 is_out;
+	u32 addr, token, this_trb_len;
+	int i;
+	int mem_size;
+	dma_addr_t	dma;
+	struct aotg_td *td, *next;
+	struct device *dev = aotg_to_hcd(acthcd)->self.controller;
+
+	if (!is_room_on_ring(ring, INTR_TRBS)) {
+		printk("%s err, check it!\n", __FUNCTION__);
+		return -1;
+	}
+
+	is_out = usb_pipeout(urb->pipe);
+	//mem_size = max(urb->transfer_buffer_length,usb_maxpacket(ep->udev, urb->pipe, is_out));
+	mem_size = urb->transfer_buffer_length;
+	//printk("====ep:%p,mem_size:%d...........====\n",ep,mem_size);
+	ring->intr_mem_size = mem_size;
+	ring->intr_dma_buf_vaddr = (u8 *)dma_alloc_coherent(dev, mem_size * INTR_TRBS, 
+		&dma, mem_flags);
+	if (!ring->intr_dma_buf_vaddr) {
+		printk("%s err, alloc dma buf for intr fail!\n", __FUNCTION__);
+		return -1;
+	}
+	ring->intr_dma_buf_phyaddr = dma;
+	//printk("dma_buf_vaddr:0x%p, dma_buf_phyaddr:0x%x\n",
+	//		ring->intr_dma_buf_vaddr, (u32)ring->intr_dma_buf_phyaddr);
+
+	for (i = 0; i < INTR_TRBS; i++) {
+		td = aotg_alloc_td(mem_flags);
+		if (!td) {
+			printk("%s err, alloc td fail\n", __FUNCTION__);
+			goto fail;
+		}
+		td->intr_mem_vaddr = ring->intr_dma_buf_vaddr + mem_size * i;
+		td->intr_men_phyaddr = ring->intr_dma_buf_phyaddr + mem_size * i;
+		//td->intr_mem_phyaddr = virt_to_phys(td->intr_mem_vaddr);
+		memset(td->intr_mem_vaddr, 0, mem_size);
+//		printk("buf_%d  virt_addr:0x%p, phy_addr:0x%x, size:%d\n",
+//				i, td->intr_mem_vaddr, (u32)td->intr_men_phyaddr, mem_size);
+		
+		td->num_trbs = 1;
+		td->trb_vaddr = ring->enqueue_trb;
+		td->trb_dma = ring_trb_virt_to_dma(ring, ring->enqueue_trb);
+
+		this_trb_len = mem_size;
+		if (is_out) {
+			token = TRB_OF | TRB_ITE | TRB_LT;
+			enqueue_trb(ring, urb->transfer_dma, this_trb_len, token);
+		}	else {
+			token = TRB_OF | TRB_ICE | TRB_CSP;
+			addr = (u32)td->intr_men_phyaddr;
+			enqueue_trb(ring, addr, this_trb_len, token);
+		}
+
+
+		list_add_tail(&td->enring_list, &ep->enring_td_list);
+		ring->enring_cnt++;
+	}
+
+	ring->intr_inited = 1;
+	return 0;
+
+fail:
+	list_for_each_entry_safe(td, next, &ep->enring_td_list, enring_list) {
+		aotg_release_td(td);
+	}
+	
+	dma_free_coherent(dev, ring->intr_mem_size * INTR_TRBS,
+				ring->intr_dma_buf_vaddr, ring->intr_dma_buf_phyaddr);
+
+	return -1;
+}
+
+int aotg_intr_get_finish_trb(struct aotg_ring *ring)
+{
+	int i,count = 0;
+	struct aotg_trb *trb = ring->first_trb;
+	
+	for (i=0; i<INTR_TRBS; i++) {
+		if ((trb->hw_token&TRB_OF) == 0) {
+			count++;
+		}
+		trb++;
+	}
+	return count;
+}
+
+int aotg_intr_chg_buf_len(struct aotg_hcd *acthcd, struct aotg_ring *ring, int len)
+{
+	struct aotg_td *td;
+	dma_addr_t	dma;
+	int i = 0;
+	u32 token;
+	struct aotg_hcep *ep = (struct aotg_hcep *)ring->priv;
+	struct device *dev = aotg_to_hcd(acthcd)->self.controller;
+	//aotg_stop_ring(ring);
+	writel(DMACTRL_DMACC,ring->reg_dmactrl);
+	usb_clearbitsb(0x80, ep->reg_hcepcon);
+	usb_settoggle(ep->udev, ep->epnum, ep->is_out, 0);
+	aotg_hcep_reset(acthcd, ep->mask, ENDPRST_FIFORST);
+	writeb(ep->epnum, ep->reg_hcepctrl);
+	usb_setbitsb(0x80, ep->reg_hcepcon);
+
+	dma_free_coherent(dev, ring->intr_mem_size * INTR_TRBS,
+			ring->intr_dma_buf_vaddr, ring->intr_dma_buf_phyaddr);
+
+	ring->intr_mem_size = len;
+	ring->intr_dma_buf_vaddr = (u8 *)dma_alloc_coherent(dev, len * INTR_TRBS, 
+		&dma, GFP_ATOMIC);
+	if (!ring->intr_dma_buf_vaddr) {
+		printk("%s err, alloc dma buf for intr fail!\n", __FUNCTION__);
+		return -1;
+	}
+	ring->intr_dma_buf_phyaddr = dma;
+	
+	aotg_reorder_intr_td(ep);
+	list_for_each_entry(td, &ep->enring_td_list, enring_list) {
+		td->intr_mem_vaddr = ring->intr_dma_buf_vaddr + len * i;
+		td->intr_men_phyaddr = ring->intr_dma_buf_phyaddr + len * i;
+		memset(td->intr_mem_vaddr, 0, len);
+		
+		if (ring->is_out) 
+			token = TRB_OF | TRB_ITE | TRB_LT;
+		else 
+			token = TRB_OF | TRB_ICE | TRB_CSP;	
+
+		enqueue_trb(ring, td->intr_men_phyaddr, len, token);
+		i++;
+	}
+	mb();
+	writel(DMACTRL_DMACS,ep->ring->reg_dmactrl);
+	
+	return 0;
+}
+
+void aotg_intr_dma_buf_free(struct aotg_hcd *acthcd, struct aotg_ring *ring)
+{
+	struct aotg_td *td, *next;
+	struct aotg_hcep *ep = (struct aotg_hcep *)ring->priv;
+	struct device *dev = aotg_to_hcd(acthcd)->self.controller;
+
+	list_for_each_entry_safe(td, next, &ep->enring_td_list, enring_list) {
+		aotg_release_td(td);
+	}
+
+	dma_free_coherent(dev, ring->intr_mem_size * INTR_TRBS,
+			ring->intr_dma_buf_vaddr, ring->intr_dma_buf_phyaddr);
+}
+
+int aotg_ring_enqueue_isoc_td(struct aotg_hcd *acthcd, 
+				struct aotg_ring *ring, struct aotg_td *td)
+{
+	u8 is_out;
+	u32 start_addr;
+	u32 addr, token, this_trb_len;
+	int i = 0;
+	int start_frame;
+	int num_trbs;
+	struct urb *urb = td->urb;
+
+	if (!acthcd || !td || !ring || !urb) {
+		ACT_HCD_ERR
+		return -1;
+	}	
+
+	num_trbs = urb->number_of_packets;
+	if (unlikely(num_trbs == 0)) {
+		ACT_HCD_ERR
+		return -1;
+	}
+	
+	if (unlikely(!is_room_on_ring(ring, num_trbs))) {
+		ACT_HCD_DBG
+		return -1;
+	}	
+	
+	is_out = usb_pipeout(urb->pipe);
+	
+	td->num_trbs = num_trbs;
+	td->trb_vaddr = ring->enqueue_trb;
+	td->trb_dma = ring_trb_virt_to_dma(ring, ring->enqueue_trb);
+
+	start_frame = readw(acthcd->base + HCFRMNRL);
+	start_frame &= 0x3fff;
+	urb->start_frame = start_frame;
+	
+	start_addr = (u32)urb->transfer_dma;
+	
+	if (is_out) {
+		token = TRB_OF;
+	} else {
+		token = TRB_CSP | TRB_OF;
+	}
+
+	do {
+		addr = start_addr + urb->iso_frame_desc[i].offset;
+		this_trb_len = urb->iso_frame_desc[i].length;
+		if (num_trbs == 1) {
+			token &= ~TRB_CHN;
+			if (is_out)	
+				token |= TRB_ITE;
+			else 
+				token |= TRB_ICE;
+			
+			enqueue_trb(ring, addr, this_trb_len, token);
+			break;
+		}
+		enqueue_trb(ring, addr, this_trb_len, token);
+		i++;
+		num_trbs--;
+	} while(num_trbs);
+	
+	return 0;
+}
+
+void dequeue_td(struct aotg_ring *ring, struct aotg_td *td, int dequeue_flag)
+{
+	int i,num_trbs;
+	struct aotg_trb *trb;
+
+	if (!ring || !td || ((struct list_head *)(&td->enring_list)->next == LIST_POISON1)) {
+		ACT_HCD_ERR
+		return;
+	}
+	trb = td->trb_vaddr;
+	num_trbs = td->num_trbs;
+	for (i = 0; i < num_trbs; i++) {
+		if (dequeue_flag != TD_IN_RING) {
+			inc_dequeue_safe(ring);
+			memset(trb,0,sizeof(struct aotg_trb));
+		}
+		else {
+		 /*perhaps the dequeue urb in the middle of queue_list,don't change ring->dequeue here*/
+			trb->hw_token = 0xaa;
+		}
+		if (trb == ring->last_trb) {
+			trb = ring->first_trb;
+		}
+		else {
+			trb++;
+		}
+	}
+	list_del(&td->enring_list);
+	aotg_release_td(td);
+	ring->dering_cnt++;
+}
+
+void dequeue_intr_td(struct aotg_ring *ring, struct aotg_td *td)
+{
+	u32 addr, token, this_trb_len;
+	struct aotg_trb *trb;
+	struct aotg_hcep *ep;
+
+	if (!ring || !td) {
+		ACT_HCD_ERR
+		return;
+	}
+
+	trb = td->trb_vaddr;
+	inc_dequeue_safe(ring);
+	list_del(&td->enring_list);
+	ring->dering_cnt++;
+
+	td->urb = NULL;
+	memset(td->intr_mem_vaddr, 0, ring->intr_mem_size);
+
+	if (ring->is_out) 
+		token = TRB_OF | TRB_ITE | TRB_LT;
+	else 
+		token = TRB_OF | TRB_ICE | TRB_CSP;	
+	this_trb_len = ring->intr_mem_size;	
+	addr = (u32)td->intr_men_phyaddr;
+
+	ep = (struct aotg_hcep *)ring->priv;
+	enqueue_trb(ring, addr, this_trb_len, token);
+	list_add_tail(&td->enring_list, &ep->enring_td_list);
+	ring->enring_cnt++;	
+	return;
+}
+
+#if (1)
+int aotg_ring_dequeue_intr_td(struct aotg_hcd *acthcd, struct aotg_hcep *ep,
+		struct aotg_ring *ring,	struct aotg_td *td)
+{
+	u32 addr;
+	struct aotg_td *td_tmp;
+
+	/*To INTR transfer: first dequeue happens at the last step of insertion
+	  while there isn't any data transmission, so we just empty the urb of
+	  the first td but	don't dequeue the td.*/
+	//     aotg_stop_ring(ring);
+	if (td->trb_vaddr->hw_token & TRB_OF)
+		td->urb = NULL;
+	else
+		dequeue_intr_td(ring, td);
+
+	td_tmp = list_first_entry_or_null(&ep->enring_td_list, struct aotg_td, enring_list);
+	if ((td_tmp) && (td_tmp->urb)) {
+		printk("%s, unormal circumstances, pls check it...\n", __FUNCTION__);
+		printk("restart ep%d intr ring\n", ep->index);
+		addr = ring_trb_virt_to_dma(ring, ring->dequeue_trb);
+		aotg_start_ring(ring, addr);
+	}
+	return 0;
+}
+#else
+int aotg_ring_dequeue_intr_td(struct aotg_hcd *acthcd, struct aotg_hcep *ep,
+			struct aotg_ring *ring,	struct aotg_td *td)
+{
+	struct aotg_trb *trb;
+	trb = td->trb_vaddr;
+	
+	writel(DMACTRL_DMACC,ep->ring->reg_dmactrl);
+	usb_clearbitsb(0x80, ep->reg_hcepcon);
+	usb_settoggle(ep->udev, ep->epnum, ep->is_out, 0);
+	aotg_hcep_reset(acthcd, ep->mask, ENDPRST_FIFORST);
+	writeb(ep->epnum, ep->reg_hcepctrl);
+	usb_setbitsb(0x80, ep->reg_hcepcon);
+	
+	td->urb = NULL;
+	mb();
+	trb->hw_token |= TRB_OF;
+	trb->hw_token &= ~(AOTG_TRB_IOC|AOTG_TRB_IOZ|AOTG_TRB_IOS);
+	aotg_reorder_intr_td(ep);
+
+	/*td_tmp = list_first_entry(&ep->enring_td_list, struct aotg_td, enring_list);
+	if (td_tmp->urb) {
+		printk("%s, unormal circumstances, pls check it...\n", __FUNCTION__);
+		printk("restart ep%d intr ring\n", ep->index);
+		addr = ring_trb_virt_to_dma(ring, ring->dequeue_trb);
+		aotg_start_ring(ring, addr);		
+	}*/
+
+	return 0;
+}
+#endif
+
+int aotg_ring_dequeue_td(struct aotg_hcd *acthcd, struct aotg_ring *ring, 
+			struct aotg_td *td, int dequeue_flag)
+{
+	int index;
+	struct aotg_hcep *ep;
+	struct urb *urb = td->urb;
+	td->urb = NULL;
+	//u32 addr;
+	
+	//u32 ring_curaddr;
+
+	//ring_curaddr = readl(ring->reg_curaddr);
+
+	//aotg_hcd_dump_td(ring, td);
+
+	if (dequeue_flag == TD_IN_QUEUE) {
+		/*
+	 	 * must hold the spin_lock_irq, prevent td will be enqueue in ep->enring_list
+	 	 * in interrupt contex
+	 	 */
+		list_del(&td->queue_list);
+		aotg_release_td(td);
+		//ACT_HCD_DBG
+		return 0;
+	} else if (dequeue_flag == TD_IN_RING) {
+		//if (ring_curaddr < td->trb_dma || 
+		//	ring_curaddr > ring_trb_virt_to_dma(ring, td->trb_vaddr + td->num_trbs -1)) {
+		//	printk(KERN_ERR"%s, unknow situation!\n", __FUNCTION__);
+		//}
+		ep = (struct aotg_hcep *)urb->ep->hcpriv;
+		//aotg_stop_ring(ring);
+		writel(DMACTRL_DMACC,ep->ring->reg_dmactrl);
+		usb_clearbitsb(0x80, ep->reg_hcepcon);
+		usb_settoggle(ep->udev, ep->epnum, ep->is_out, 0);
+		aotg_hcep_reset(acthcd, ep->mask, ENDPRST_FIFORST);
+		writeb(ep->epnum, ep->reg_hcepctrl);
+		usb_setbitsb(0x80, ep->reg_hcepcon);
+		/*
+		 * dequeue urb, when the urb complete in hardware contex
+		 */
+		index = ring->mask & 0xf;		
+		if ((0x1 << index) & (readw(acthcd->base + HCINxDMAIRQ0)) ||
+			(0x1 << index) & (readw(acthcd->base + HCOUTxBUFEMPTYIRQ0))) {
+			printk("noticd:%s, IN%dIRQ:0x%x; OUT%dIRQ:0x%x\n",
+					__FUNCTION__, index, readw(acthcd->base + HCINxDMAIRQ0),
+					index, readw(acthcd->base + HCOUTxBUFEMPTYIRQ0));
+			clear_ring_irq(acthcd, ring->mask);
+		}
+		
+		dequeue_td(ring, td, dequeue_flag);	
+		//ACT_HCD_DBG
+		/*
+		 * need restart the remain td in the ring or wait to be dequeue ?
+		 */
+		/*if (!ring_empty(ring)) {
+			addr = ring_trb_virt_to_dma(ring, ring->dequeue_trb);
+			aotg_start_ring(ring, addr);
+			//ACT_HCD_DBG
+		}*/
+	}
+
+	return 0;
+}
+
+unsigned int get_ring_irq(struct aotg_hcd *acthcd)
+{
+	unsigned int data;
+	unsigned int i;
+	unsigned int pending = 0;
+
+//	printk("%s,INdma(0x%p):0x%x\n", __FUNCTION__,
+//		acthcd->base + HCINxDMAIRQ0, 
+//		readw(acthcd->base + HCINxDMAIRQ0));
+		
+	data = readw(acthcd->base+ HCINxDMAIRQ0);
+	
+	if (data) {
+		for (i = 1; i < 16; i++) {
+			if (data & (0x1 << i)) {
+				pending = i;
+				return pending;
+			}
+		}
+	}
+	
+	data = readw(acthcd->base + HCOUTxBUFEMPTYIRQ0);
+	
+	if (data) {
+		for (i = 1; i < 16; i++) {
+			if (data & (0x1 << i)) {
+				pending = i | AOTG_DMA_OUT_PREFIX;
+				return pending;
+			}
+		}
+	}
+
+	return pending;
+}
+
+void clear_ring_irq(struct aotg_hcd *acthcd, unsigned int irq_mask)
+{
+	int index;
+	u8 is_out = irq_mask & AOTG_DMA_OUT_PREFIX;
+	index = irq_mask & 0xf;
+//	u32 cnt;
+
+	
+	if (is_out) {
+		writew((0x1 << index), (acthcd->base + HCOUTxBUFEMPTYIRQ0));
+	} else {
+		writew((0x1 << index), (acthcd->base + HCINxDMAIRQ0));
+	}
+
+//	printk("%s,(0x%p):0x%x\n", __FUNCTION__,
+//		acthcd->base + HCOUTxBUFEMPTYIRQ0,
+//		readw(acthcd->base + HCOUTxBUFEMPTYIRQ0));
+	
+	return;
+}
+
+int finish_td(struct aotg_hcd *acthcd, struct aotg_ring *ring, struct aotg_td *td)
+{
+	struct urb *urb;
+	struct aotg_trb *trb;
+	int num_trbs;
+	int i, trb_tx_len, length = 0;
+	int status;
+
+	urb = td->urb;
+	trb = td->trb_vaddr;
+	num_trbs = td->num_trbs;
+
+	if (td->cross_ring) {
+		if ((ring->last_trb->hw_token & TRB_OF) != 0)
+			return -1;
+		td->cross_ring = 0;
+		aotg_set_trb_as_ring_linkaddr(ring, ring->first_trb);
+		usb_setbitsl(DMACTRL_DMACS, ring->reg_dmactrl);
+		//aotg_hcd_dump_trb(ring, ring->first_trb);
+		return 1;
+	}
+
+	for (i = 0; i < num_trbs; i++) {
+		if (trb->hw_token & (AOTG_TRB_IOS | AOTG_TRB_IOZ)){
+			trb_tx_len = trb->hw_buf_len - trb->hw_buf_remain;
+			length += trb_tx_len;
+			break;
+		} else if (trb->hw_token & AOTG_TRB_IOC) {
+			length += trb->hw_buf_len;
+		} else {
+//			printk("%s, td still not finish\n", __FUNCTION__);
+			//aotg_hcd_dump_td(ring, td);
+			return -1;
+		}
+		if (trb == ring->last_trb)
+			trb = ring->first_trb;
+		else
+			trb += 1;
+	}
+
+#if 0
+	if (usb_pipetype(urb->pipe) == PIPE_BULK)
+		aotg_hcd_dump_td(ring, td);
+#endif 
+
+	dequeue_td(ring, td, TD_IN_FINISH);
+
+	urb->actual_length = length;
+	status = 0;
+
+
+	if (urb->actual_length > urb->transfer_buffer_length) {
+		ACT_HCD_DBG
+		urb->actual_length = 0;
+		if (td->urb->transfer_flags & URB_SHORT_NOT_OK)
+			status = -EREMOTEIO;			
+		else
+			status = 0;
+	}
+	
+	usb_hcd_unlink_urb_from_ep(bus_to_hcd(urb->dev->bus), urb);
+	spin_unlock(&acthcd->lock);
+	usb_hcd_giveback_urb(bus_to_hcd(urb->dev->bus), urb, status);
+	spin_lock(&acthcd->lock);
+	/* when unlock,maybe list_del(&td->enring_list) in dequeue_td*/
+	if ((urb->ep) && unlikely(!urb->ep->enabled)) {
+		return -1;
+	}
+	
+	return 0;
+}
+
+int intr_finish_td(struct aotg_hcd *acthcd, struct aotg_ring *ring, struct aotg_td *td)
+{
+	int length;
+	int status;
+	struct urb *urb;
+	struct aotg_trb *trb;
+
+	trb = td->trb_vaddr;
+	if (td->urb == NULL) {
+		//printk("%s err, pls fix it!\n", __FUNCTION__);
+		if ((trb->hw_token&TRB_OF) == 0) {
+				aotg_stop_ring(ring);
+		} 
+		return -1;
+	}
+	
+
+	urb = td->urb;
+
+	if (trb->hw_token & (AOTG_TRB_IOS | AOTG_TRB_IOZ)){
+		length = trb->hw_buf_len - trb->hw_buf_remain;
+	} else if (trb->hw_token & AOTG_TRB_IOC) {
+		length = trb->hw_buf_len;
+	} else {
+		return -1;
+	}
+
+	if (!ring->is_out)
+		memcpy(urb->transfer_buffer, td->intr_mem_vaddr, length);
+	dequeue_intr_td(ring, td);
+	
+	urb->actual_length = length;
+	status = 0;
+
+	usb_hcd_unlink_urb_from_ep(bus_to_hcd(urb->dev->bus), urb);
+	spin_unlock(&acthcd->lock);
+	usb_hcd_giveback_urb(bus_to_hcd(urb->dev->bus), urb, status);
+	spin_lock(&acthcd->lock);
+	
+	return 0;
+}
+
+int isoc_finish_td(struct aotg_hcd *acthcd, struct aotg_ring *ring, struct aotg_td *td)
+{
+	struct urb *urb;
+	struct aotg_trb *trb;
+	int num_trbs;
+	int i, trb_tx_len, length = 0;
+	int status;
+
+//	mb();
+	if (!ring || !td || ((struct list_head *)(&td->enring_list)->next == LIST_POISON1)) {
+		ACT_HCD_ERR
+		return -1;
+	}
+
+	urb = td->urb;
+	if (!urb || !urb->dev)
+		return -1;
+	trb = td->trb_vaddr;
+	num_trbs = td->num_trbs;
+
+	for (i = 0; i < num_trbs; i++) {
+		if (trb->hw_token & (AOTG_TRB_IOS | AOTG_TRB_IOZ)){
+			trb_tx_len = trb->hw_buf_len - trb->hw_buf_remain;
+			urb->iso_frame_desc[i].actual_length = trb_tx_len;
+			urb->iso_frame_desc[i].status = 0;
+			length += trb_tx_len;
+		} else if (trb->hw_token & AOTG_TRB_IOC) {
+			trb_tx_len = trb->hw_buf_len;
+			urb->iso_frame_desc[i].actual_length = trb_tx_len;
+			urb->iso_frame_desc[i].status = 0;
+			length += trb->hw_buf_len;
+		} else {
+			//printk("%s, td still not finish\n", __FUNCTION__);
+			//aotg_hcd_dump_td(ring, td);
+			return -1;
+		}
+		if (trb == ring->last_trb)
+			trb = ring->first_trb;
+		else
+			trb += 1;
+	}
+
+	td->urb = NULL;
+	dequeue_td(ring, td, TD_IN_FINISH);
+
+	urb->actual_length = length;
+	status = 0;
+
+	usb_hcd_unlink_urb_from_ep(bus_to_hcd(urb->dev->bus), urb);
+	spin_unlock(&acthcd->lock);
+	usb_hcd_giveback_urb(bus_to_hcd(urb->dev->bus), urb, status);
+	spin_lock(&acthcd->lock);
+	
+	return 0;
+}
+
+void handle_ring_dma_tx(struct aotg_hcd *acthcd, unsigned int irq_mask)
+{	
+	int ret;
+	struct aotg_td *td = NULL, *next;	
+	struct aotg_ring *ring;
+	struct aotg_hcep *ep;
+	
+	if (AOTG_IS_DMA_OUT(irq_mask)) {
+		ep = acthcd->outep[AOTG_GET_DMA_NUM(irq_mask)];
+	} else {
+		ep = acthcd->inep[AOTG_GET_DMA_NUM(irq_mask)];
+	}
+	if (ep == NULL) {
+		ACT_HCD_ERR
+		return;
+	}
+	ep->error_count = 0;
+
+	ring = ep->ring;
+	if (!ring) {
+		ACT_HCD_ERR
+		return;
+	}
+
+	if (list_empty(&ep->enring_td_list) || ring_empty(ring))
+		return;
+
+	if (ring->type == PIPE_ISOCHRONOUS) {
+		do {
+			mb();
+			td = list_first_entry_or_null(&ep->enring_td_list, struct aotg_td, enring_list);
+			if (!td)
+				break;
+			ret = isoc_finish_td(acthcd, ring, td);
+		} while (ret == 0);
+
+		if (!list_empty(&ep->queue_td_list)) {
+			list_for_each_entry_safe(td, next, &ep->queue_td_list, queue_list) {
+				ret = aotg_ring_enqueue_isoc_td(acthcd, ring, td);
+				if (ret)
+					return;
+				list_del(&td->queue_list);
+				list_add_tail(&td->enring_list, &ep->enring_td_list);
+				ring->enring_cnt++;
+			}
+		}
+
+		if (!list_empty(&ep->enring_td_list) && !is_ring_running(ring)) {
+			if (ring->dequeue_trb != ring->first_trb)
+				aotg_reorder_iso_td(acthcd, ring);
+			aotg_start_ring(ring, ring_trb_virt_to_dma(ring, ring->dequeue_trb));
+		}
+		else if (list_empty(&ep->enring_td_list) && is_ring_running(ring)) {
+			aotg_stop_ring(ring);
+		}
+		return;
+	} else if (ring->type == PIPE_INTERRUPT) {
+		if (!ring->intr_started)
+			return;
+		do {
+			mb();
+			td = list_first_entry_or_null(&ep->enring_td_list, struct aotg_td, enring_list);
+			if (!td)
+				break;
+			ret = intr_finish_td(acthcd, ring, td);
+		} while (ret == 0);
+
+		if (!is_ring_running(ring)) {
+			pr_debug("%s, intr stop!\n", __func__);
+		}
+		return;
+	}
+
+	do {
+		mb();
+		td = list_first_entry_or_null(&ep->enring_td_list, struct aotg_td, enring_list);
+		if (!td)
+			break;
+		ret = finish_td(acthcd, ring, td);
+	} while (ret == 0);
+	
+	if (ret == 1)
+		return;
+
+	if (!list_empty(&ep->queue_td_list)) {
+		list_for_each_entry_safe(td, next, &ep->queue_td_list, queue_list) {
+			ret = aotg_ring_enqueue_td(acthcd, ring, td);
+			if (ret) {
+				return;
+			}
+			list_del(&td->queue_list);
+			list_add_tail(&td->enring_list, &ep->enring_td_list);
+			ring->enring_cnt++;
+		}
+	}
+
+	if (!list_empty(&ep->enring_td_list) && !is_ring_running(ring))
+		aotg_start_ring(ring, ring_trb_virt_to_dma(ring, ring->dequeue_trb));
+	else if (list_empty(&ep->enring_td_list) && is_ring_running(ring))
+		aotg_stop_ring(ring);
+}
+
+void aotg_ring_irq_handler(struct aotg_hcd *acthcd)
+{
+	unsigned int irq_mask;
+	unsigned long flags;
+
+	spin_lock_irqsave(&acthcd->lock, flags);
+	acthcd->check_trb_mutex = 1;
+
+	do {
+		irq_mask = get_ring_irq(acthcd);
+		if (irq_mask == 0) {
+			acthcd->check_trb_mutex = 0;
+			spin_unlock_irqrestore(&acthcd->lock, flags);
+			return;
+		}
+		clear_ring_irq(acthcd, irq_mask);
+
+		handle_ring_dma_tx(acthcd, irq_mask);
+	} while (irq_mask);
+	acthcd->check_trb_mutex = 0;
+	spin_unlock_irqrestore(&acthcd->lock, flags);
+	return;
+}
+
+
+
diff --git a/drivers/usb/aotg/aotg_ring.h b/drivers/usb/aotg/aotg_ring.h
new file mode 100755
index 0000000..fe69508
--- /dev/null
+++ b/drivers/usb/aotg/aotg_ring.h
@@ -0,0 +1,48 @@
+#ifndef  __LINUX_USB_AOTG_RING_H__ 
+#define  __LINUX_USB_AOTG_RING_H__ 
+
+/* about dma_no: if (dma_no & 0x10) == 0x10, it's hcout, otherwise it's hcin. */
+
+
+void aotg_hcd_dump_trb(struct aotg_trb *trb);
+void aotg_hcd_dump_td(struct aotg_td *td);
+void enable_overflow_irq(struct aotg_hcd *acthcd, struct aotg_hcep *ep);
+void disable_overflow_irq(struct aotg_hcd *acthcd, struct aotg_hcep *ep);
+void clear_overflow_irq(struct aotg_hcd *acthcd, struct aotg_hcep *ep);
+struct aotg_td *aotg_alloc_td(gfp_t mem_flags);
+void aotg_release_td(struct aotg_td *td);
+int is_ring_running(struct aotg_ring *ring);
+void start_ring(struct aotg_ring *ring);
+void stop_ring(struct aotg_ring *ring);
+struct aotg_ring *aotg_alloc_ring(struct aotg_hcd *acthcd,
+				struct aotg_hcep *ep, unsigned int num_trbs, 
+				gfp_t mem_flags);
+void aotg_free_ring(struct aotg_hcd *acthcd, struct aotg_ring *ring);
+dma_addr_t ring_trb_virt_to_dma(struct aotg_ring *ring, 							struct aotg_trb *trb_vaddr);
+int ring_empty(struct aotg_ring *ring);
+inline int is_room_on_ring(struct aotg_ring *ring, unsigned int num_trbs);
+inline unsigned int	count_urb_need_trbs(struct urb *urb);
+void aotg_fill_trb(struct aotg_trb *trb,
+					u32 dma_addr, u32 len, u32 token);
+int aotg_sg_map_trb(struct aotg_trb *trb, 
+						struct scatterlist *sg, int len, u32 token);
+void inc_enqueue_safe(struct aotg_ring *ring);
+void enqueue_trb(struct aotg_ring *ring, u32 buf_ptr, u32 buf_len,
+				u32 token); 
+int ring_enqueue_sg_td(struct aotg_hcd *acthcd,
+				struct aotg_ring *ring, struct aotg_td *td); 
+int aotg_ring_enqueue_td(struct aotg_hcd *acthcd, 
+				struct aotg_ring *ring, struct aotg_td *td); 
+void inc_dequeue_safe(struct aotg_ring *ring);
+void aotg_ring_dequeue_td(struct aotg_ring *ring, struct aotg_td *td);
+unsigned int get_ring_irq(struct aotg_hcd *acthcd);
+void clear_ring_irq(struct aotg_hcd *acthcd, unsigned int irq_mask);
+int finish_td(struct aotg_ring *ring, struct aotg_td *td);
+void handle_ring_dma_tx(struct aotg_hcd *acthcd, unsigned int irq_mask);
+void aotg_ring_irq_handler(struct aotg_hcd *acthcd);
+ 
+#endif
+
+
+
+
diff --git a/drivers/usb/aotg/aotg_udc.c b/drivers/usb/aotg/aotg_udc.c
new file mode 100755
index 0000000..f4c29fa
--- /dev/null
+++ b/drivers/usb/aotg/aotg_udc.c
@@ -0,0 +1,2181 @@
+/*
+ * Actions OWL SoCs usb2.0 controller driver
+ *
+ * Copyright (c) 2015 Actions Semiconductor Co., ltd.
+ * dengtaiping <dengtaiping@actions-semi.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License v2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/kthread.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/highmem.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+
+#include <asm/irq.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/hardware.h>
+#include <linux/clk.h>
+#include <linux/wakelock.h>
+#include <linux/suspend.h>
+#include <mach/debug.h>
+#include <asm/prom.h>
+#include <mach/gpio.h>
+#include <linux/kallsyms.h>
+#include <mach/powergate.h>
+#include <mach/module-owl.h>
+
+#include "aotg_plat_data.h"
+#include "aotg_udc.h"
+#include "aotg_regs.h"
+#include "aotg_udc_debug.h"
+#include "aotg.h"
+
+#define DRIVER_DESC "Actions USB Device Controller Driver"
+
+static int aotg_udc_kick_dma(struct aotg_ep *ep, struct aotg_request *req);
+extern void aotg_udc_dma_handler(struct aotg_udc *udc, u8 dma_number);
+
+static void aotg_ep_reset(struct aotg_udc *udc, u8 ep_mask, u8 type_mask);
+static int aotg_ep_disable(struct usb_ep *_ep);
+static void nuke(struct aotg_ep *ep, int status);
+static inline void udc_handle_status(struct aotg_udc *udc);
+extern void done(struct aotg_ep *ep, struct aotg_request *req, int status);
+static int write_ep0_fifo(struct aotg_ep *ep, struct aotg_request *req);
+int pullup(struct aotg_udc *udc, int is_active);
+static int aotg_udc_endpoint_config(struct aotg_udc *udc, struct usb_gadget_driver *driver);
+static void udc_enable(struct aotg_udc *dev);
+static void udc_disable(struct aotg_udc *dev);
+
+#ifndef NO_IRQ
+#define NO_IRQ  ((unsigned int)(-1))
+#endif
+#define MAX_PACKET(x)	((x)&0x7FF)
+
+const char udc_driver_name[] = "aotg_udc";
+static const char ep0name[] = "ep0";
+
+static inline int is_room_on_udc_ring(struct udc_ring *ring, unsigned int num_trbs)
+{
+	return (num_trbs > atomic_read(&ring->num_trbs_free)) ? 0 : 1;
+}
+
+static inline unsigned int	count_need_trbs(struct usb_request *req)
+{
+	if (req->num_mapped_sgs > 0)
+		return req->num_mapped_sgs;
+	else
+		return 1;
+}
+
+void aotg_epin_dma_reset(struct aotg_udc *udc)
+{
+	usb_setbitsb(0xa0, udc->base + HCINDMAERROR);
+	udelay(1);
+	usb_clearbitsb(0x80, udc->base + HCINDMAERROR);
+}
+
+int aotg_dma_enable_irq(struct aotg_udc *udc, int dma_nr, int enable)
+{
+	int index;
+
+	index = dma_nr & 0xf;
+	if (enable) {
+		if (AOTG_IS_DMA_DEVICE_IN_HOUT(dma_nr)) {
+			usb_setbitsw((0x1 << index), (udc->base + HCOUTxDMAIEN0));
+		} else {
+			usb_setbitsw((0x1 << index), (udc->base + HCINxDMAIEN0));
+		}
+	} else {
+		if (AOTG_IS_DMA_DEVICE_IN_HOUT(dma_nr)) {
+			usb_clearbitsw((0x1 << index), (udc->base + HCOUTxDMAIEN0));
+		} else {
+			usb_clearbitsw((0x1 << index), (udc->base + HCINxDMAIEN0));
+		}
+	}
+	return 0;
+}
+
+/* return the dma irq's dma number. */
+unsigned int aotg_udc_get_irq(struct aotg_udc *udc)
+{
+	unsigned int data;
+	unsigned int i;
+	unsigned int pending = 0;
+
+	data = usb_readw(udc->base + HCOUTxBUFEMPTYIRQ0);
+	if (data) {
+		for (i = 1; i < 16; i++) {
+			if (data & (0x1 << i)) {
+				pending = i | AOTG_DMA_OUT_PREFIX;
+				return pending;
+			}
+		}
+	}
+
+	data = usb_readw(udc->base + HCINxDMAIRQ0);
+	if (data) {
+		for (i = 1; i < 16; i++) {
+			if (data & (0x1 << i)) {
+				pending = i;
+				return pending;
+			}
+		}
+	}
+
+	return pending;
+}
+
+int aotg_dma_clear_pend(struct aotg_udc *udc, int dma_nr)
+{
+	int index;
+
+	index = dma_nr & 0xf;
+	if (AOTG_IS_DMA_DEVICE_IN_HOUT(dma_nr)) {
+		usb_writew((0x1 << index), (udc->base + HCOUTxBUFEMPTYIRQ0));
+	} else {
+		usb_writew((0x1 << index), (udc->base + HCINxDMAIRQ0));
+	}
+	return 0;
+}
+
+int aotg_dma_clear_pend_all(struct aotg_udc *udc)
+{
+	usb_writew(0xffff, udc->base + HCINxDMAIRQ0);
+	usb_writew(0xffff, udc->base + HCOUTxDMAIRQ0);
+	usb_writew(0xffff, udc->base + HCOUTxBUFEMPTYIRQ0);
+	return 0;
+}
+
+int is_udc_ring_running(struct aotg_ep *ep)
+{
+	struct aotg_udc *udc = ep->dev;
+	return (readl(udc->base + ep->reg_dmactrl) & 0x1);
+}
+
+void aotg_start_udc_ring(struct aotg_ep *ep)
+{
+	struct aotg_udc *udc = ep->dev;
+	mb();
+	writel(DMACTRL_DMACS, udc->base + ep->reg_dmactrl);
+}
+
+void aotg_stop_udc_ring(struct aotg_ep *ep)
+{
+	struct aotg_udc *udc = ep->dev;
+	writel(DMACTRL_DMACC,  udc->base + ep->reg_dmactrl);
+}
+
+void aotg_set_udc_ring_linkaddr(struct aotg_ep *ep, u32 addr)
+{
+	struct aotg_udc *udc = ep->dev;
+	writel(addr, udc->base + ep->reg_dmalinkaddr);
+}
+
+u32 udc_ring_trb_virt_to_dma(struct udc_ring *ring, struct aotg_trb *trb)
+{
+	u32 addr;
+	unsigned long offset;
+
+	if (!ring || !trb || (trb > ring->last_trb)) {
+		UDC_DBG_ERR;
+		return 0;
+	}
+
+	offset = trb - ring->first_trb;
+	addr = ring->trb_dma + (offset * sizeof(*trb));
+
+	return addr;
+}
+
+static void pio_udc_irq_disable(struct aotg_ep *ep)
+{
+	struct aotg_udc *udc = ep->dev;
+	u8 is_in = ep->mask & USB_UDC_IN_MASK;
+	u8 ep_num = ep->mask & EP_ADDR_MASK;
+
+	if (is_in)
+		usb_clearbitsb(1 << ep_num, udc->base + INxIEN);
+	else
+		usb_clearbitsb(1 << ep_num, udc->base + OUTxIEN);
+}
+ 
+void udc_ep_packet_config(enum usb_device_speed usb_speed, struct aotg_udc *udc)
+{
+	int i;
+	u16 packsize;
+	struct aotg_ep *ep;
+
+	for (i = 1; i < AOTG_UDC_NUM_ENDPOINTS; i++) {
+		ep = &udc->ep[i];
+		if (ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
+			packsize = (usb_speed == USB_SPEED_FULL) ? BULK_FS_PACKET_SIZE : BULK_HS_PACKET_SIZE;
+		} else if (ep->bmAttributes == USB_ENDPOINT_XFER_INT) {
+			packsize = (usb_speed == USB_SPEED_FULL) ? INT_FS_PACKET_SIZE : INT_HS_PACKET_SIZE;
+		} else if (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
+			packsize = (usb_speed == USB_SPEED_FULL) ? ISO_FS_PACKET_SIZE : ISO_HS_PACKET_SIZE;
+		} else {
+			continue;
+		}
+		ep->ep.maxpacket = packsize;
+		ep->maxpacket = packsize;
+		writew(packsize, udc->base + ep->reg_maxckl);
+	}
+	return;
+}
+
+#if (0)
+void aotg_udc_dump_td(struct aotg_ep *ep)
+{
+	struct aotg_request *req;
+	struct aotg_trb *trb;
+	struct udc_ring *ring = ep->ring;
+	struct aotg_udc *udc = ep->dev;
+	printk("reg_dmalinkaddr:(%x)%x, reg_curaddr:(%x)%x, reg_dmactrl:(%x)%x, reg_dmacomplete_cnt:(%x)%x\n",
+		ep->reg_dmalinkaddr,readl(udc->base + ep->reg_dmalinkaddr),
+		ep->reg_curaddr,readl(udc->base + ep->reg_curaddr),
+		ep->reg_dmactrl,readl(udc->base + ep->reg_dmactrl),
+		ep->reg_dmacomplete_cnt,readl(udc->base + ep->reg_dmacomplete_cnt));
+
+	printk("===========ring infos==============:\n");
+	printk("first_trb:%p, last_trb:%p,enqueue_trb:%p, cur_trb:%p, trb_dma:%p, num_trbs_free:%d\n",
+		ring->first_trb, ring->last_trb, ring->enqueue_trb, ring->cur_trb, ring->trb_dma, ring->num_trbs_free);
+	trb = ring->first_trb;
+	for(trb=ring->first_trb; trb < ring->last_trb; trb++)	{
+		printk("hw_buf_ptr:%x, hw_buf_len:%x, hw_buf_remain:%x, hw_token:%x\n",
+			trb->hw_buf_ptr, trb->hw_buf_len, trb->hw_buf_remain, trb->hw_token);
+	}
+	list_for_each_entry(req, &ep->queue, queue) {
+		printk("\t req %p len %d/%d buf %p\n",
+		&req->req, req->req.actual, req->req.length, req->req.buf);
+	}
+}
+#endif
+
+static int aotg_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
+{
+	struct aotg_ep *ep;
+	struct aotg_udc *udc;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct aotg_ep, ep);
+	/*sanity check */
+	if (!_ep || !desc || _ep->name == ep0name
+	    || desc->bDescriptorType != USB_DT_ENDPOINT
+	    || ep->bEndpointAddress != desc->bEndpointAddress 
+	    || ep->maxpacket < le16_to_cpu(desc->wMaxPacketSize)) {
+		UDC_ERR("<AOTG_EP_ENABLE>%s, bad ep or descriptor\n", __func__);
+		return -EINVAL;
+	}
+
+	/*xfer types must match, except that interrupt ~= bulk */
+	if (ep->bmAttributes != desc->bmAttributes
+	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
+	    && ep->bmAttributes != USB_ENDPOINT_XFER_ISOC 
+	    && ep->bmAttributes != USB_ENDPOINT_XFER_INT) {
+		UDC_ERR("<AOTG_EP_ENABLE>%s: %s type mismatch\n", __func__, _ep->name);
+		return -EINVAL;
+	}
+
+	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK && le16_to_cpu(desc->wMaxPacketSize)
+	     != ep->maxpacket)
+	    || !desc->wMaxPacketSize) {
+		UDC_ERR("<AOTG_EP_ENABLE>%s: bad %s maxpacket\n", __func__, _ep->name);
+		return -ERANGE;
+	}
+
+	udc = ep->dev;
+	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {
+		if (!udc->driver)
+			UDC_DEBUG("no driver\n");
+		if (udc->gadget.speed == USB_SPEED_UNKNOWN)
+			UDC_DEBUG("UNKNOW speed\n");
+		UDC_DEBUG("%s: bogus device state\n", __func__);
+		return -ESHUTDOWN;
+	}
+	spin_lock_irqsave(&udc->lock, flags);
+	ep->ep.desc = desc;
+	ep->stopped = 0;
+	ep->udc_irqs = 0;
+	ep->read.bytes = 0;
+	ep->read.ops = 0;
+	ep->write.bytes = 0;
+	ep->write.ops = 0;
+	ep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
+
+	ep->dma_no = ep->bEndpointAddress & EP_ADDR_MASK;
+	if (((ep->mask & USB_UDC_IN_MASK) != 0) && (ep->dma_no != 0)) {
+		ep->dma_no = AOTG_DMA_OUT_PREFIX | ep->dma_no;
+	}
+
+	aotg_ep_reset(udc, ep->mask, ENDPRST_FIFORST | ENDPRST_TOGRST);
+	usb_setbitsb(EPCON_VAL, udc->base + ep->reg_udccon);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	UDC_DEBUG("<EP ENABLE>%s enable, reg_udccon is %02x\n", _ep->name, readb(udc->base + ep->reg_udccon));
+
+	if (ep->dma_no) 
+		aotg_dma_clear_pend(udc, ep->dma_no);
+
+	if (ep->bmAttributes == USB_ENDPOINT_XFER_CONTROL)
+		return 0;
+
+	if (ep->ring != NULL) {
+		UDC_DBG_ERR;
+		return 0;
+	}
+
+	ep->ring = kmalloc(sizeof(struct udc_ring), GFP_ATOMIC);
+	if (!ep->ring) {
+		printk("no ring mem!\n");
+		return -ENOMEM;
+	}
+	
+	ep->ring->is_running = 0;
+	ep->ring->num_trbs = NUM_TRBS;
+	atomic_set(&ep->ring->num_trbs_free, NUM_TRBS);
+
+	ep->ring->first_trb = (struct aotg_trb *)
+		dma_alloc_coherent(udc->dev, NUM_TRBS * sizeof(struct aotg_trb),
+		(dma_addr_t *)&ep->ring->trb_dma, GFP_ATOMIC);
+	memset(ep->ring->first_trb, 0, RING_SIZE);
+	ep->ring->last_trb = ep->ring->first_trb + (NUM_TRBS - 1);
+	ep->ring->enqueue_trb = ep->ring->first_trb;
+	ep->ring->cur_trb = ep->ring->first_trb;
+	return 0;
+}
+
+#if (0)
+void aotg_dump_ring(void)
+{
+	struct aotg_ep *ep;
+	struct aotg_request *req;
+	struct usb_endpoint_descriptor *desc;
+	struct aotg_trb *trb;
+	struct udc_ring *ring;
+	struct aotg_udc *udc;
+	int i;
+
+	for (i = 0; i < AOTG_UDC_NUM_ENDPOINTS; i++) {
+		ep = &acts_udc_controller->ep[i];
+		udc = ep->dev;
+
+		if (i != 0) {
+			desc = ep->ep.desc;
+			if (!desc)
+				continue;
+			
+			printk("index:%d\n",i);
+			printk("%s max %d irqs %d\n",
+				ep->ep.name, le16_to_cpu(desc->wMaxPacketSize), ep->udc_irqs);
+
+		} else		/* ep0 should only have one transfer queued */
+			printk("ep0 max 16 pio irqs %x\n", ep->udc_irqs);
+
+		if (list_empty(&ep->queue)) {
+			printk("(nothing queued)\n");
+			continue;
+		}
+		printk("reg_dmalinkaddr:(%x)%x, reg_curaddr:(%x)%x, reg_dmactrl:(%x)%x, reg_dmacomplete_cnt:(%x)%x\n",
+			ep->reg_dmalinkaddr,readl(udc->base + ep->reg_dmalinkaddr),
+			ep->reg_curaddr,readl(udc->base + ep->reg_curaddr),
+			ep->reg_dmactrl,readl(udc->base + ep->reg_dmactrl),
+			ep->reg_dmacomplete_cnt, readl(udc->base + ep->reg_dmacomplete_cnt));
+		
+		ring = ep->ring;
+		if (!ring)
+			continue;
+		printk("===========ring infos==============:\n");
+		printk("first_trb:%p, last_trb:%p, enqueue_trb:%p, cur_trb:%p, trb_dma:%d, num_trbs_free:%d\n",
+				ring->first_trb,ring->last_trb, ring->enqueue_trb, ring->cur_trb,ring->trb_dma, ring->num_trbs_free);
+		trb = ring->first_trb;
+		for(trb=ring->first_trb; trb < ring->last_trb; trb++)	{
+			printk("hw_buf_ptr:%x, hw_buf_len:%x, hw_buf_remain:%x, hw_token:%x\n",
+				trb->hw_buf_ptr, trb->hw_buf_len, trb->hw_buf_remain, trb->hw_token);
+		}
+
+		list_for_each_entry(req, &ep->queue, queue) {
+			printk("req %p len %d/%d buf %p\n",
+				&req->req, req->req.actual, req->req.length, req->req.buf);
+		}
+	}
+	return;
+}
+#endif
+
+static int aotg_ep_disable(struct usb_ep *_ep)
+{
+	struct aotg_ep *ep;
+	struct aotg_udc *udc;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct aotg_ep, ep);
+	if (!_ep || !ep->ep.desc) {
+		UDC_DEBUG("<EP DISABLE> %s not enabled\n", _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	udc = ep->dev;
+	spin_lock_irqsave(&udc->lock, flags);
+	nuke(ep, -ESHUTDOWN);
+
+	aotg_stop_udc_ring(ep);
+	usb_clearbitsb(EPCON_VAL, udc->base + ep->reg_udccon);
+	pio_udc_irq_disable(ep);
+	if (ep->dma_no) {
+		aotg_dma_enable_irq(udc, ep->dma_no, 0);
+		aotg_dma_clear_pend(udc, ep->dma_no);
+	}
+	ep->ep.driver_data = NULL;
+	ep->desc = NULL;
+	ep->stopped = 1;
+
+	if (ep->ring != NULL) {
+		dma_free_coherent(udc->dev, 
+			NUM_TRBS * sizeof(struct aotg_trb), ep->ring->first_trb, ep->ring->trb_dma);
+		kfree(ep->ring);
+		ep->ring = NULL;
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);\
+	UDC_DEBUG("<EP DISABLE>%s disable\n", _ep->name);
+	return 0;
+}
+
+static struct usb_request *aotg_ep_alloc_request(struct usb_ep *_ep, unsigned gfp_flags)
+{
+	struct aotg_request *req;
+
+	UDC_DEBUG("<EP ALLOC REQ>%s, flags is %d\n", _ep->name, gfp_flags);
+	req = kmalloc(sizeof(*req), gfp_flags);
+	if (!req)
+		return NULL;
+	memset(req, 0, sizeof(*req));
+	INIT_LIST_HEAD(&req->queue);
+	return &req->req;
+}
+
+static void aotg_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct aotg_request *req;
+
+	UDC_DEBUG("<EP FREE REQ>%s, %p\n", _ep->name, _req);
+	req = container_of(_req, struct aotg_request, req);
+	if (!list_empty(&req->queue))
+		UDC_DEBUG("<EP FREE REQ>ep's queue is not empty\n");
+	kfree(req);
+
+}
+
+void udc_inc_enqueue_safe(struct udc_ring *ring)
+{
+	atomic_dec(&ring->num_trbs_free);
+	if (ring->enqueue_trb == ring->last_trb) {
+		ring->enqueue_trb->hw_token &= ~(TRB_CHN|TRB_CSP);
+		ring->enqueue_trb->hw_token |= TRB_LT;
+		ring->enqueue_trb = ring->first_trb;
+	} else {
+		ring->enqueue_trb += 1;
+	}
+}
+
+void udc_inc_dequeue_safe(struct udc_ring *ring)
+{
+	memset(ring->cur_trb, 0, sizeof(struct aotg_trb));
+	atomic_inc(&ring->num_trbs_free);
+	if (ring->cur_trb == ring->last_trb) {
+		ring->cur_trb = ring->first_trb;
+	} else {
+		ring->cur_trb++;
+	}
+	return;
+}
+
+void aotg_dma_enqueue_trb(struct udc_ring *ring, u32 buf_ptr, u32 buf_len, u32 token)
+{
+	struct aotg_trb *trb;
+	trb = ring->enqueue_trb;
+
+	trb->hw_buf_ptr = buf_ptr;
+	trb->hw_buf_len = buf_len;
+	trb->hw_token = token;
+	trb->hw_buf_remain = 0;
+	udc_inc_enqueue_safe(ring);	
+}
+
+static void aotg_start_udc_ring_transfer(struct aotg_ep *ep, struct aotg_trb *trb)
+{
+	u32 addr;
+	struct udc_ring *ring = ep->ring;
+	addr = udc_ring_trb_virt_to_dma(ring, trb);
+	if (addr) {
+		aotg_set_udc_ring_linkaddr(ep, addr);
+		aotg_start_udc_ring(ep);
+	}
+}
+
+static int aotg_ep_queue(struct usb_ep *_ep, struct usb_request *_req, unsigned gfp_flags)
+{
+	struct aotg_ep *ep;
+	struct aotg_udc *udc;
+	struct aotg_request *req;
+	unsigned long flags;
+
+	UDC_DEBUG("<EP QUEUE> %s queues one req %p\n", _ep->name, _req);
+	/*sanity check */
+	req = container_of(_req, struct aotg_request, req);
+	if (unlikely(!_req || !_req->complete || !_req->buf || !list_empty(&req->queue))) {
+		UDC_ERR("<EP QUEUE>bad params\n");
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct aotg_ep, ep);
+	if (unlikely(!_ep || (!ep->ep.desc && ep->ep.name != ep0name))) {
+		UDC_ERR("<EP QUEUE> bad ep\n");
+		return -EINVAL;
+	}
+
+	udc = ep->dev;
+	if (unlikely(!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)) {
+		UDC_ERR("<EP QUEUE> bogus device state\n");
+		return -ESHUTDOWN;
+	}
+
+	//aotg_dbg_put_info("ep_que", ep->ep.name, _req->length, _req->buf, _req->actual);
+	UDC_DEBUG("<EP QUEUE>%s queue req %p, len %d buf %p\n", _ep->name, _req, _req->length, _req->buf);
+	/*it may be very noisy */
+
+	spin_lock_irqsave(&udc->lock, flags);
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+	UDC_DEBUG("<EP QUEUE>%s queue req %p, len %d buf %p\n", _ep->name, _req, _req->length, _req->buf);
+
+	/*only if the req queue of ep is empty and ep is working ,
+	 we kick start the queue */
+	if (!ep->stopped) {
+		if (ep->bEndpointAddress == 0) {
+			if (!udc->req_pending) {
+				UDC_ERR("<EP QUEUE> something wrong with Control Xfers, req_pending is missing\n");
+				spin_unlock_irqrestore(&udc->lock, flags);
+				return -EL2HLT;
+			}
+
+			switch (udc->ep0state) {
+			case EP0_OUT_DATA_PHASE:
+				udc->stats.read.ops++;
+				/*No-Data Control Xfer */
+				if (!req->req.length) {
+					 /*ACK*/ 
+					udc_handle_status(udc);
+					/*cleanup */
+					udc->req_pending = 0;
+					udc->ep0state = EP0_WAIT_FOR_SETUP;
+					done(ep, req, 0);
+					req = NULL;
+					spin_unlock_irqrestore(&udc->lock, flags);
+					return 0;
+
+					/*Control Write Xfer */
+				} else {
+					/*in this case, we just arm the OUT EP0
+					   for first OUT transaction during
+					   the data stage
+					   hang this req at the tail of
+					   queue aossciated with EP0
+					   expect OUT EP0 interrupt
+					   to advance the i/o queue
+					 */
+
+					writeb(0, udc->base + OUT0BC);
+				}
+				break;
+			case EP0_IN_DATA_PHASE:
+				udc->stats.write.ops++;
+				/*Control Read Xfer */
+				if (write_ep0_fifo(ep, req))
+					udc->ep0state = EP0_END_XFER;	//!!!!handle_ep0_in will call done(ep, req, 0);
+				break;
+			default:
+				UDC_DEBUG("<EP QUEUE> ep0 i/o, odd state %d\n", udc->ep0state);
+				spin_unlock_irqrestore(&udc->lock, flags);
+				return -EL2HLT;
+			}
+
+		}	else {
+			aotg_udc_kick_dma(ep, req);
+		}
+	}
+
+	/*pio or dma irq handler advances the queue. */
+	if (likely(req != NULL)) {
+		list_add_tail(&req->queue, &ep->queue);
+		UDC_DEBUG("<EP QUEUE>the req of %s is not be done completely,queueing and wait irq kickstart\n", ep->ep.name);
+	}
+	
+	if (ep->bEndpointAddress != 0) {
+		if (!is_udc_ring_running(ep)) {
+			aotg_start_udc_ring_transfer(ep, ep->ring->cur_trb);
+		}
+	}
+	
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return 0;
+}
+
+static int aotg_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct aotg_ep *ep;
+	struct aotg_request *req;
+	struct aotg_udc *udc;
+	struct aotg_trb *trb;
+	struct udc_ring *ring;
+	unsigned long flags;
+	int i;
+
+	UDC_DEBUG("<EP DEQUEUE> %s dequeues one req %p\n", _ep->name, _req);
+	ep = container_of(_ep, struct aotg_ep, ep);
+
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	udc = ep->dev;
+	spin_lock_irqsave(&udc->lock, flags);
+	/*make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		UDC_DBG_ERR;
+		spin_unlock_irqrestore(&udc->lock, flags);
+		return -EINVAL;
+	}
+
+	//aotg_dbg_put_info("ep_dequeue", ep->ep.name, _req->length, _req->buf, _req->actual);
+
+	aotg_stop_udc_ring(ep);
+	done(ep, req, -ECONNRESET);
+	trb = req->start_trb;
+	ring = ep->ring;
+	for (i = 0; i < req->num_trbs; i++) {
+		memset(req->start_trb,0,sizeof(struct aotg_trb));
+		udc_inc_dequeue_safe(ring);
+		if (trb == ring->last_trb)
+			trb = ring->first_trb;
+		else
+			trb += 1;
+	}
+	
+	if (!list_empty(&ep->queue)) {
+		UDC_DBG_ERR;
+		aotg_start_udc_ring_transfer(ep,ring->cur_trb);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return 0;
+}
+
+// ========================================== hjk_checked  
+static int aotg_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct aotg_ep *ep;
+	struct aotg_udc *udc;
+	int retval = -EOPNOTSUPP;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct aotg_ep, ep);
+	if (!_ep || (!ep->ep.desc && ep->ep.name != ep0name)) {
+		UDC_DEBUG("<EP HALT>, bad ep\n");
+		return -EINVAL;
+	}
+
+	udc = ep->dev;
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/*EP0 */
+	if (ep->bEndpointAddress == 0) {
+		if (value) {
+			usb_setbitsb(EP0CS_STALL, udc->base + EP0CS);
+			udc->req_pending = 0;
+			udc->ep0state = EP0_STALL;
+			retval = 0;
+		} else {
+			usb_clearbitsb(EP0CS_STALL, udc->base + EP0CS);
+			udc->ep0state = EP0_WAIT_FOR_SETUP;
+			retval = 0;
+		}
+
+		/*otherwise, all active non-ISO endpoints can halt */
+	} else if (ep->bmAttributes != USB_ENDPOINT_XFER_ISOC && ep->desc) {
+		/*IN endpoints must already be idle */
+		if ((ep->bEndpointAddress & USB_DIR_IN)
+		    && !list_empty(&ep->queue)) {
+			UDC_ERR("<EP HALT>dangrous,epin queue is not empty\n");
+			retval = 0;
+			goto done;
+		}
+		/*IN endpoint FIFO must be empty */
+		if (ep->bEndpointAddress & USB_DIR_IN) {
+			u8 not_empty;
+			not_empty = (readb(udc->base + ep->reg_udccs) & EPCS_BUSY)
+			    || (ep->buftype - ((readb(udc->base + ep->reg_udccs) >> 2) & 0x03));
+			if (not_empty) {
+				UDC_ERR("<EP HALT>dangrous, epin fifo is not empty\n");
+				retval = 0;
+				goto done;
+			}
+		}
+
+		if (value) {
+			/*set the stall bit */
+			usb_setbitsb(EPCON_STALL, udc->base + ep->reg_udccon);
+			ep->stopped = 1;
+		} else {
+			/*clear the stall bit */
+			usb_clearbitsb(EPCON_STALL, udc->base + ep->reg_udccon);
+			ep->stopped = 0;
+		}
+		retval = 0;
+	}
+
+      done:
+	UDC_DEBUG("<EP HALT>%s %s halt stat %d\n", ep->ep.name, value ? "set" : "clear", retval);
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return retval;
+}
+
+static void aotg_ep_fifo_flush(struct usb_ep *_ep)
+{
+	struct aotg_udc *udc;
+	struct aotg_ep *ep;
+	ep = container_of(_ep, struct aotg_ep, ep);
+	if (!_ep || ep->ep.name == ep0name || !list_empty(&ep->queue)) {
+		UDC_DEBUG("<EP FIFO FLUSH>bad ep\n");
+		return;
+	}
+	UDC_DEBUG("<EP FIFO FLUSH>%s fifo flush\n", ep->ep.name);
+	udc = ep->dev;
+	aotg_ep_reset(udc, ep->mask, ENDPRST_FIFORST);
+}
+
+static struct usb_ep_ops aotg_ep_ops = {
+	.enable = aotg_ep_enable,
+	.disable = aotg_ep_disable,
+
+	.alloc_request = aotg_ep_alloc_request,
+	.free_request = aotg_ep_free_request,
+
+	.queue = aotg_ep_queue,
+	.dequeue = aotg_ep_dequeue,
+
+	.set_halt = aotg_ep_set_halt,
+	//.fifo_status  = aotg_ep_fifo_status,
+	.fifo_flush = aotg_ep_fifo_flush,	/*not sure */
+
+};
+
+/*---------------------------------------------------------------------------
+ *  device operations  related parts of
+ *  the api to the usb controller hardware,
+ *  which don't involve endpoints (or i/o), used by gadget driver;
+ *  and the inner talker-to-hardware core.
+ *---------------------------------------------------------------------------
+ */
+static int aotg_udc_get_frame(struct usb_gadget *_gadget)
+{
+	struct aotg_udc *udc;
+	u16 frmnum = 0;
+
+	udc = container_of(_gadget, struct aotg_udc, gadget);
+
+	UDC_DEBUG("<UDC_GET_FRAME>Frame No.: %d\n", frmnum);
+	return frmnum;
+
+}
+
+static int aotg_udc_wakeup(struct usb_gadget *_gadget)
+{
+	struct aotg_udc *udc;
+	int retval = -EHOSTUNREACH;
+
+	udc = container_of(_gadget, struct aotg_udc, gadget);
+
+	return retval;
+}
+
+static int aotg_udc_vbus_session(struct usb_gadget *_gadget, int is_active)
+{
+	struct aotg_udc *udc;
+	unsigned long flags;
+
+	UDC_DEBUG("<UDC_VBUS_SESSION> VBUS %s\n", is_active ? "on" : "off");
+	udc = container_of(_gadget, struct aotg_udc, gadget);
+	spin_lock_irqsave(&udc->lock, flags);
+	pullup(udc, is_active);
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+
+}
+
+static int aotg_udc_pullup(struct usb_gadget *_gadget, int is_on)
+{
+	struct aotg_udc *udc;
+	unsigned long flags;
+
+	udc = container_of(_gadget, struct aotg_udc, gadget);
+	spin_lock_irqsave(&udc->lock, flags);
+	udc->softconnect = (is_on != 0);
+	pullup(udc, is_on);
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static int aotg_udc_vbus_draw(struct usb_gadget *_gadget, unsigned mA)
+{
+	struct aotg_udc *udc;
+
+	udc = container_of(_gadget, struct aotg_udc, gadget);
+	if (udc->transceiver)
+		return usb_phy_set_power(udc->transceiver, mA);
+	return -EOPNOTSUPP;
+}
+
+static int aotg_udc_start(struct usb_gadget *g, struct usb_gadget_driver *driver)
+{
+	int retval;
+	struct aotg_udc *udc = container_of(g, struct aotg_udc, gadget);
+	udc->driver = driver;
+	extern_irq_enable(udc);
+	udc_enable(udc);
+	aotg_udc_endpoint_config(udc, driver);
+
+	if (udc->transceiver) {
+		retval = otg_set_peripheral(udc->transceiver->otg, &udc->gadget);
+		if (retval) {
+			dev_err(udc->dev, "can't bind to transceiver\n");
+			return retval;
+		}
+	}
+
+	return 0;
+}
+
+static int aotg_udc_stop(struct usb_gadget *g)
+{
+	struct aotg_udc *udc = container_of(g, struct aotg_udc, gadget);
+	udc->driver = NULL;
+	extern_irq_disable(udc);
+	udc_disable(udc);
+	if (udc->transceiver)
+		return otg_set_peripheral(udc->transceiver->otg, NULL);
+	return 0;
+}
+
+static const struct usb_gadget_ops aotg_udc_ops = {
+	.get_frame = aotg_udc_get_frame,
+	.wakeup = aotg_udc_wakeup,
+	.pullup = aotg_udc_pullup,
+	.vbus_session = aotg_udc_vbus_session,
+	.vbus_draw = aotg_udc_vbus_draw,
+	.udc_start = aotg_udc_start,
+	.udc_stop = aotg_udc_stop,
+};
+
+int aotg_enqueue_req(struct aotg_ep *ep, struct aotg_request *aotg_req)
+{
+	unsigned	length;
+	dma_addr_t	dma;
+	struct usb_request *req = &aotg_req->req;
+	struct udc_ring *ring = ep->ring;
+	u32 token = 0,num_trbs;
+	int is_in = !!(ep->bEndpointAddress & USB_DIR_IN);
+	
+	num_trbs = count_need_trbs(req);
+	if (!is_room_on_udc_ring(ring, num_trbs)) {
+		UDC_DBG_ERR;
+		return -1;
+	}
+	
+	aotg_req->start_trb = ring->enqueue_trb;
+	aotg_req->cross_req = 0;
+	aotg_req->num_trbs = num_trbs;
+	
+	if (req->num_mapped_sgs > 0) {
+		struct scatterlist *sg = req->sg;
+		struct scatterlist *s;
+		int	i;
+		for_each_sg(sg, s, req->num_mapped_sgs, i) {
+			length = sg_dma_len(s);
+			dma = sg_dma_address(s);
+			token = TRB_OF;
+			if (!is_in)
+				token |= TRB_CSP;
+			
+			if (i == (req->num_mapped_sgs - 1) || sg_is_last(s)) {
+				break;
+			}	else {
+				if (ring->enqueue_trb == ring->last_trb) {
+					aotg_req->cross_req = 1;
+					if (is_in) {
+						token |= TRB_ITE;
+					} else {
+						token |= TRB_ICE;
+					}
+				} else {
+					token |= TRB_CHN;
+				}
+				aotg_dma_enqueue_trb(ring, (u32)dma, length, token);
+			}
+		}
+	}
+	else {
+
+		dma = req->dma;
+		length = req->length;
+	}
+	
+	token = TRB_OF;
+	if (is_in) {
+			token |= TRB_ITE;
+	} else {
+		token |= TRB_CSP|TRB_ICE;
+	}
+	aotg_req->end_trb = ring->enqueue_trb;
+	aotg_dma_enqueue_trb(ring, (u32)dma, length, token);
+	return 0;
+}
+
+static int aotg_udc_kick_dma(struct aotg_ep *ep, struct aotg_request *aotg_req)
+{
+	int is_in = !!(ep->bEndpointAddress & USB_DIR_IN);
+	struct aotg_udc *udc = ep->dev;
+
+	usb_gadget_map_request(&udc->gadget, &aotg_req->req, is_in);
+	return aotg_enqueue_req(ep, aotg_req);
+}
+
+static int aotg_udc_dma_irq_handler(struct aotg_udc *udc, u8 irqshare)
+{
+	unsigned int dma_pend;
+	int i = 0;
+
+	do {
+		dma_pend = (unsigned int) aotg_udc_get_irq(udc);
+		if (dma_pend == 0)
+			return i;
+		aotg_dma_clear_pend(udc, dma_pend);
+
+		if (i++ >= 30) {
+			UDC_DBG_INFO;
+			return i;
+		}
+
+		aotg_udc_dma_handler(udc, dma_pend);
+	} while (dma_pend);
+
+	return i;
+}
+
+int aotg_udc_finish_req(struct aotg_ep *ep, struct aotg_request *aotg_req)
+{
+	struct aotg_trb *trb;
+	int i, trb_tx_len, length = 0;
+	struct udc_ring *ring = ep->ring;
+	if (aotg_req->cross_req) {
+		aotg_req->cross_req = 0;
+		aotg_start_udc_ring_transfer(ep,ring->first_trb);
+		return 1;
+	}
+
+	trb = aotg_req->start_trb;
+	for (i = 0; i < aotg_req->num_trbs; i++) {
+		if (trb->hw_token & (AOTG_TRB_IOS | AOTG_TRB_IOZ)){
+			trb_tx_len = trb->hw_buf_len - trb->hw_buf_remain;
+			length += trb_tx_len;
+			udc_inc_dequeue_safe(ring);
+			break;
+		} else if (trb->hw_token & AOTG_TRB_IOC) {
+			length += trb->hw_buf_len;
+		} else {
+			if (!is_udc_ring_running(ep)) {
+				aotg_start_udc_ring_transfer(ep,ring->cur_trb);
+			}
+			return -1;
+		}
+
+		udc_inc_dequeue_safe(ring);
+		if (trb == ring->last_trb)
+			trb = ring->first_trb;
+		else
+			trb += 1;
+	}
+
+	aotg_req->req.actual = length;
+	done(ep, aotg_req, 0);
+
+	return 0;
+}
+
+void aotg_udc_dma_handler(struct aotg_udc *udc, u8 dma_number)
+{
+	struct aotg_ep *ep = (struct aotg_ep *) (&(udc->ep));
+	struct aotg_request *aotg_req = NULL, *next;
+	unsigned int is_in = 0;
+	unsigned int i;
+	struct udc_ring *ring;
+
+	for (i = 0; i < AOTG_UDC_NUM_ENDPOINTS; i++) {
+		if (ep[i].dma_no == dma_number) {
+			ep = &ep[i];
+			break;
+		}
+	}
+	if (i == AOTG_UDC_NUM_ENDPOINTS) {
+		printk("can't find correct ep no in dma irq! dma_number:%d\n", dma_number);
+		return;
+	}
+
+	ring = ep->ring;
+	is_in = !!(ep->bEndpointAddress & USB_DIR_IN);
+	aotg_req = list_first_entry_or_null(&ep->queue,struct aotg_request, queue);
+	if (aotg_req == NULL)
+		return;
+
+	UDC_DEBUG("<dma_handler>:ep address =%d \n", ep->bEndpointAddress);
+	ep->udc_irqs++;
+	ep->dev->stats.irqs++;
+
+	if (list_empty(&ep->queue)) {
+		UDC_DBG_ERR;
+		return;
+	}
+	list_for_each_entry_safe(aotg_req, next, &ep->queue, queue) {
+		if (aotg_udc_finish_req(ep, aotg_req))
+			break;
+	}
+
+	if (list_empty(&ep->queue) && is_udc_ring_running(ep)) {
+		aotg_stop_udc_ring(ep);
+		UDC_DBG_ERR;
+	} else if (!list_empty(&ep->queue) && !(is_udc_ring_running(ep))) {
+		UDC_DBG_ERR;
+		aotg_start_udc_ring_transfer(ep, ep->ring->cur_trb);
+	}
+
+	return;
+}
+
+/*---------------------------------------------------------------------------
+ *  handle  interrupt
+ *---------------------------------------------------------------------------
+*/
+void done(struct aotg_ep *ep, struct aotg_request *req, int status)
+{
+	//unsigned stopped = ep->stopped;
+	u8 direction;
+	struct aotg_udc *udc = ep->dev;
+
+	list_del_init(&req->queue);
+
+	if (likely(req->req.status == -EINPROGRESS)) {
+		req->req.status = status;
+	} else {
+		printk("status:%x req.status:%x\n",status,req->req.status);
+		status = req->req.status;
+	}
+
+
+
+	if (status && status != -ESHUTDOWN) {
+		UDC_DEBUG("<REQ RELEASE>complete %s req %p stat %d len %u/%u\n",
+			  ep->ep.name, &req->req, status, req->req.actual, req->req.length);
+	}
+	if (ep->bEndpointAddress != 0) {
+		direction = !!(ep->mask & USB_UDC_IN_MASK);
+		usb_gadget_unmap_request(&udc->gadget, &req->req, direction);
+	}
+
+	spin_unlock(&ep->dev->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->dev->lock);
+	return;
+}
+
+static inline void aotg_ep_setup(struct aotg_udc *udc, u8 index, char *name, u8 addr, u8 type, u8 buftype)
+{
+	struct aotg_ep *ep;
+	ep = &udc->ep[index];
+
+	strlcpy(ep->name, name, sizeof ep->name);
+	ep->ep.name = ep->name;
+	ep->bmAttributes = type;
+	ep->bEndpointAddress = addr;
+
+	if (type == USB_ENDPOINT_XFER_BULK) {
+		if (ep->bEndpointAddress & USB_DIR_IN) {
+			if ((ep->bEndpointAddress & EP_ADDR_MASK) == 1)
+				writel(EP1_BULK_IN_STARTADD, udc->base + ep->reg_fifostaddr);
+			else
+				writel(EP2_BULK_IN_STARTADD, udc->base + ep->reg_fifostaddr);
+		} else {
+			if ((ep->bEndpointAddress & EP_ADDR_MASK) == 1)
+				writel(EP1_BULK_OUT_STARTADD, udc->base + ep->reg_fifostaddr);
+			else
+				writel(EP2_BULK_OUT_STARTADD, udc->base + ep->reg_fifostaddr);
+		}
+
+	} else if (type == USB_ENDPOINT_XFER_INT) {
+		writel(EP_INT_IN_STARTADD, udc->base + ep->reg_fifostaddr);
+	} else if (type == USB_ENDPOINT_XFER_ISOC) {
+		writel(EP_ISO_IN_STARTADD, udc->base + ep->reg_fifostaddr);
+	} else {
+		return;
+	}
+
+	ep->buftype = buftype;
+	if (type == USB_ENDPOINT_XFER_ISOC)
+		writeb((type << 2) | buftype | (1 << 5), udc->base + ep->reg_udccon);
+	else
+		writeb((type << 2) | buftype, udc->base + ep->reg_udccon);
+	return;
+}
+
+static void aotg_ep_reset(struct aotg_udc *udc, u8 ep_mask, u8 type_mask)
+{
+	u8 val;
+
+	writeb(ep_mask, udc->base + ENDPRST);	/*select ep */
+	val = ep_mask | type_mask;
+	writeb(val, udc->base + ENDPRST);	/*reset ep */
+}
+
+static inline void udc_handle_status(struct aotg_udc *udc)
+{
+	usb_setbitsb(EP0CS_HSNAK, udc->base + EP0CS);
+	UDC_DEBUG("<CTRL>ACK the status stage\n");
+}
+
+static void nuke(struct aotg_ep *ep, int status)
+{
+	struct aotg_request *req;
+
+	if ((ep->bEndpointAddress != 0) && !ep->stopped)
+		aotg_stop_udc_ring(ep);
+	UDC_DEBUG("<EP NUKE> %s is nuked with status %d\n", ep->ep.name, status);
+
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct aotg_request, queue);
+		done(ep, req, status);
+	}
+/*	if (ep->desc)
+		pio_udc_irq_disable(ep);*/
+}
+
+static void handle_setup(struct aotg_udc *dev, unsigned long *pflag)
+{
+	u16 w_value, w_length, w_index;
+	u32 ackval = 0;
+	int reciptype;
+	int ep_num;
+	struct aotg_ep *ep;
+	struct aotg_udc *udc = dev;
+	struct aotg_ep *ep0 = &udc->ep[0];
+	union {
+		struct usb_ctrlrequest r;
+		u8 raw[8];
+	} u;
+	int i, status = 0;
+	unsigned long addr = SETUPDATA_W0;
+	unsigned long flags = *pflag;
+
+	if (udc->ep0state != EP0_WAIT_FOR_SETUP) {
+		nuke(ep0, -ESHUTDOWN);
+		udc->ep0state = EP0_WAIT_FOR_SETUP;
+	} else
+		nuke(ep0, -EPROTO);
+	for (i = 0; i < 8; i++) {
+		u.raw[i] = readb(udc->base + addr);
+		addr++;
+	}
+	w_value = le16_to_cpup(&u.r.wValue);
+	w_length = le16_to_cpup(&u.r.wLength);
+	w_index = le16_to_cpup(&u.r.wIndex);
+	UDC_DEBUG("<CTRL> SETUP %02x.%02x v%04x i%04x l%04x\n", u.r.bRequestType, u.r.bRequest, w_value, w_index, w_length);
+
+	/*Delegate almost all control requests to the gadget driver,
+	 *except for a handful of ch9 status/feature requests that
+	 *hardware doesn't autodecode and the gadget API hides.
+	 */
+	udc->req_std = (u.r.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD;
+	udc->req_config = 0;
+	udc->req_pending = 1;
+	ep0->stopped = 0;
+	reciptype = (u.r.bRequestType & USB_RECIP_MASK);
+#if 1
+	if ((u.r.bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR)
+		goto delegate;
+#endif
+
+	switch (u.r.bRequest) {
+	case USB_REQ_GET_STATUS:
+		UDC_DEBUG("<CTRL>USB_REQ_GET_STATUS\n");
+		if (reciptype == USB_RECIP_INTERFACE) {
+			/*according to USB spec,
+			   this does nothing but return 0 */
+			break;
+		} else if (reciptype == USB_RECIP_DEVICE) {
+			/*return self powered and remote wakeup status
+			 *we are self powered , so just check wakeup character
+			 */
+			if (udc->rwk)
+				ackval = 0x02;
+			else
+				ackval = 0x00;
+		} else if (reciptype == USB_RECIP_ENDPOINT) {
+			ep_num = u.r.wIndex & EP_ADDR_MASK;
+
+			if (ep_num > (AOTG_UDC_NUM_ENDPOINTS - 1)
+			    || u.r.wLength > 2)
+				goto stall;
+			ep = &udc->ep[ep_num];
+			if ((ep_num != 0)
+			    && (ep->bEndpointAddress != u.r.wIndex))
+				goto stall;
+			if (ep->bEndpointAddress == 0)
+				ackval |= ((readb(udc->base + EP0CS)
+					    & EP0CS_STALL) >> 1);
+			/* weird is there should do right twist? */
+			else
+				ackval |= ((readb(udc->base + ep->reg_udccon)
+					    & EPCON_STALL) >> 6);
+		} else
+			goto stall;
+
+		/*back the status */
+		/*FIXME not check whether ep0 fifo is empty */
+		writel(ackval, udc->base + EP0INDATA_W0);
+		writeb(2, udc->base + IN0BC);
+		udc->ep0state = EP0_END_XFER;
+		return;
+	case USB_REQ_CLEAR_FEATURE:
+		if ((u.r.bRequestType & 0x60) == 0x20) {
+			UDC_DEBUG("hgl: is class request = 0x%x 0x%x\n", u.r.bRequestType, u.r.bRequest);
+			break;
+		}
+		if ((u.r.bRequestType == USB_RECIP_DEVICE)
+		    && (u.r.wValue == USB_DEVICE_REMOTE_WAKEUP)) {
+			UDC_DEBUG("<CTRL> clear remote wakeup feature\n");
+			udc->rwk = 0;	/*clear the remote wakeup character */
+		} else if ((u.r.bRequestType == USB_RECIP_ENDPOINT)
+			   && (u.r.wValue == USB_ENDPOINT_HALT)) {
+			ep_num = u.r.wIndex & EP_ADDR_MASK;
+
+			if (ep_num > (AOTG_UDC_NUM_ENDPOINTS - 1)
+			    || u.r.wLength > 2)
+				goto stall;
+			ep = &udc->ep[ep_num];
+			if ((ep_num != 0)
+			    && (ep->bEndpointAddress != u.r.wIndex))
+				goto stall;
+
+			if (ep->bEndpointAddress == 0) {
+				usb_clearbitsb(EP0CS_STALL, udc->base + EP0CS);
+			} else {
+				usb_clearbitsb(EPCON_STALL, udc->base + ep->reg_udccon);
+				ep->stopped = 0;
+				aotg_ep_reset(udc, ep->mask, ENDPRST_TOGRST);
+				/*reset the ep toggle */
+			}
+			UDC_DEBUG("<CTRL> clear %s halt feature\n", ep->ep.name);
+		} else
+			goto stall;
+		/*ACK the status stage */
+		udc_handle_status(udc);
+		return;
+	case USB_REQ_SET_FEATURE:
+		if ((u.r.bRequestType == USB_RECIP_DEVICE)) {
+			switch (u.r.wValue) {
+			case USB_DEVICE_REMOTE_WAKEUP:
+				udc->rwk = 1;
+				/*clear the remmote wakeup character */
+				break;
+			case USB_DEVICE_B_HNP_ENABLE:
+				UDC_DEBUG("<UDC:()>:b_hnp_enable = 1\n");
+				udc->gadget.b_hnp_enable = 1;
+				//set_b_hnp_en();
+				break;
+			case USB_DEVICE_A_HNP_SUPPORT:
+				UDC_DEBUG("<UDC:()>:a_hnp_support = 1\n");
+				udc->gadget.a_hnp_support = 1;
+				break;
+			case USB_DEVICE_A_ALT_HNP_SUPPORT:
+				UDC_DEBUG("<UDC:()>:a_alt_hnp_support = 1\n");
+				udc->gadget.a_alt_hnp_support = 1;
+				break;
+			default:
+				goto stall;
+			}
+		} else if ((u.r.bRequestType == USB_RECIP_ENDPOINT)
+			   && (u.r.wValue == USB_ENDPOINT_HALT)) {
+			ep_num = u.r.wIndex & EP_ADDR_MASK;
+
+			if (ep_num > (AOTG_UDC_NUM_ENDPOINTS - 1)
+			    || u.r.wLength > 2)
+				goto stall;
+			ep = &udc->ep[ep_num];
+			if ((ep_num != 0)
+			    && (ep->bEndpointAddress != u.r.wIndex))
+				goto stall;
+			if (ep->bEndpointAddress == 0) {
+				usb_setbitsb(EP0CS_STALL, udc->base + EP0CS);
+				udc->ep0state = EP0_STALL;
+			} else
+				usb_setbitsb(EPCON_STALL, udc->base + ep->reg_udccon);
+		} else
+			goto stall;
+
+		/*ACK the status stage */
+		udc_handle_status(udc);
+		return;
+	case USB_REQ_SET_ADDRESS:
+		UDC_DEBUG("<CTRL>USB_REQ_SET_ADDRESS\n");
+		udc->req_pending = 0;
+		/*automatically reponse this request by hardware,
+		   so hide it to software */
+		return;
+	case USB_REQ_SET_INTERFACE:
+		UDC_DEBUG("<CTRL>USB_REQ_SET_INTERFACE\n");
+		udc->req_config = 1;
+		if (w_length != 0)
+			goto stall;
+		goto delegate;
+		/*delegate to the upper gadget driver */
+	case USB_REQ_SET_CONFIGURATION:
+		UDC_DEBUG("<CTRL>USB_REQ_SET_CONFIGURATION\n");
+		if (u.r.bRequestType == USB_RECIP_DEVICE) {
+			if (w_length != 0)
+				goto stall;
+			udc->req_config = 1;
+			if (w_value == 0) {
+				/*enter address state and all endpoint
+				   should be disabled except for endpoint0 */
+				UDC_DEBUG("<CTRL>disable all ep\n");
+				for (i = 1; i < AOTG_UDC_NUM_ENDPOINTS; i++)
+					usb_clearbitsb(EPCON_VAL, udc->base + udc->ep[i].reg_udccon);
+			} else {	/*enter configured state */
+				UDC_DEBUG("<CTRL>enter configured state\n");
+				for (i = 1; i < AOTG_UDC_NUM_ENDPOINTS; i++)
+					usb_setbitsb(EPCON_VAL, udc->base + udc->ep[i].reg_udccon);
+			}
+		} else
+			goto stall;
+		/*delegate to the upper gadget driver */
+		break;
+	default:
+		/*delegate to the upper gadget driver */
+		break;
+	}
+	/*gadget drivers see class/vendor specific requests,
+	 *{SET, GET}_{INTERFACE, DESCRIPTOR, CONFIGURATION},
+	 *and more
+	 *The gadget driver may return an error here,
+	 *causing an immediate protocol stall.
+	 *
+	 *Else it must issue a response, either queueing a
+	 *response buffer for the DATA stage, or halting ep0
+	 *(causing a protocol stall, not a real halt).  A
+	 *zero length buffer means no DATA stage.
+	 *
+	 *It's fine to issue that response after the setup()
+	 *call returns.
+	 */
+
+      delegate:
+	UDC_DEBUG("<CTRL>delegate\n");
+	if (u.r.bRequestType & USB_DIR_IN)
+		udc->ep0state = EP0_IN_DATA_PHASE;
+	else
+		udc->ep0state = EP0_OUT_DATA_PHASE;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	status = udc->driver->setup(&udc->gadget, &u.r);	/*delegate */
+	spin_lock_irqsave(&udc->lock, flags);
+	*pflag=flags;
+	if (status < 0) {
+stall:
+		printk("%p\n",udc->driver->setup);
+		printk("<CTRL> req %02x.%02x protocol STALL, err  %d\n", u.r.bRequestType, u.r.bRequest, status);
+		if (udc->req_config) {
+			UDC_DEBUG("<CTRL>config change erro\n");
+		}
+		usb_setbitsb(EP0CS_STALL, udc->base + EP0CS);
+		udc->req_pending = 0;
+		udc->ep0state = EP0_STALL;
+    }
+    return;
+}
+
+static void handle_ep0_in(struct aotg_udc *dev)
+{
+	struct aotg_udc *udc = dev;
+	struct aotg_ep *ep = &udc->ep[0];
+	struct aotg_request *req;
+	ep->udc_irqs++;
+	if (list_empty(&ep->queue))
+		req = NULL;
+	else
+		req = list_entry(ep->queue.next, struct aotg_request, queue);
+
+	UDC_DEBUG("<CTRL>ep0in irq handler, state is %d, queue is %s\n",
+		  udc->ep0state, (req == NULL) ? "empty" : "not empty");
+
+	switch (udc->ep0state) {
+	case EP0_IN_DATA_PHASE:
+		if (req) {
+			if (write_ep0_fifo(ep, req))
+				udc->ep0state = EP0_END_XFER;
+		}
+		break;
+	case EP0_END_XFER:
+		/*ACK*/ 
+		udc_handle_status(udc);
+		/*cleanup */
+		udc->req_pending = 0;
+		udc->ep0state = EP0_WAIT_FOR_SETUP;
+		if (req) {
+			done(ep, req, 0);
+			req = NULL;
+		}
+		break;
+	case EP0_STALL:
+		if (req) {
+			done(ep, req, -ESHUTDOWN);
+			req = NULL;
+		}
+		break;
+	default:
+		UDC_DEBUG("<CTRL>ep0in irq error, odd state %d\n", udc->ep0state);
+	}
+	usb_clearbitsb(1, udc->base + INxIEN);
+}
+
+/*
+ *  EP0 related operations
+ */
+static inline int write_ep0_packet(struct aotg_udc *udc, struct aotg_request *req, unsigned max)
+{
+	u32 *buf;
+	unsigned length, count;
+	unsigned long addr = EP0INDATA_W0;
+
+	buf = (u32 *) (req->req.buf + req->req.actual);
+	prefetch(buf);
+	/*how big will this packet be? */
+	length = min(req->req.length - req->req.actual, max);
+	req->req.actual += length;
+
+	count = length / 4;	/*wirte in DWORD */
+	if ((length % 4) != 0)
+		count++;
+
+	while (likely(count--)) {
+		writel(*buf, udc->base + addr);
+		buf++;
+		addr += 4;
+	}
+	writeb(length, udc->base + IN0BC);
+	/*arm IN EP0 for the next IN transaction */
+	return length;
+}
+
+static int read_ep0_fifo(struct aotg_ep *ep, struct aotg_request *req)
+{
+	u8 *buf, byte;
+	unsigned bufferspace, count, length;
+	unsigned long addr;
+	struct aotg_udc *udc;
+
+	udc = ep->dev;
+	if (readb(udc->base + EP0CS) & EP0CS_OUTBSY)	/*data is not ready */
+		return 0;
+	/*fifo can be accessed validly */
+	else {
+		buf = req->req.buf + req->req.actual;
+		bufferspace = req->req.length - req->req.actual;
+
+		length = count = readb(udc->base + OUT0BC);
+		addr = EP0OUTDATA_W0;
+		for (; count != 0; count--) {
+			byte = readb(udc->base + addr);
+			if (unlikely(bufferspace == 0)) {
+				/*this happens when the driver's buffer
+				 *is smaller than what the host sent.
+				 *discard the extra data.
+				 */
+				if (req->req.status != -EOVERFLOW)
+					UDC_DEBUG("%s overflow\n", ep->ep.name);
+				req->req.status = -EOVERFLOW;
+				break;
+			} else {
+				*buf++ = byte;
+				req->req.actual++;
+				bufferspace--;
+				addr++;
+				ep->dev->stats.read.bytes++;
+			}
+		}
+	}
+
+	UDC_DEBUG("ep0out %d bytes %s %d left %p\n", length,
+		  (req->req.actual >= req->req.length) ? "/L" : "", req->req.length - req->req.actual, req);
+	if ((req->req.actual >= req->req.length))
+		return 1;
+	return 0;
+}
+
+static int write_ep0_fifo(struct aotg_ep *ep, struct aotg_request *req)
+{
+	unsigned count;
+	int is_last;
+	struct aotg_udc *udc = ep->dev;
+
+	count = write_ep0_packet(udc, req, EP0_PACKET_SIZE);
+	ep->dev->stats.write.bytes += count;
+
+	/*last packet must be a short packet or zlp */
+	if (count != EP0_PACKET_SIZE)
+		is_last = 1;
+	else {
+		if ((req->req.length != req->req.actual) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+	UDC_DEBUG("ep0in %d bytes %s %d left %p\n", count, is_last ? "/L" : "", req->req.length - req->req.actual, req);
+	usb_setbitsb(1, udc->base + INxIEN);
+	return is_last;
+}
+
+static void handle_ep0_out(struct aotg_udc *dev)
+{
+	struct aotg_udc *udc = dev;
+	struct aotg_ep *ep = &udc->ep[0];
+	struct aotg_request *req;
+	ep->udc_irqs++;
+
+	if (list_empty(&ep->queue)) {
+		/* empty queue */
+		req = NULL;
+	} else
+		req = list_entry(ep->queue.next, struct aotg_request, queue);
+
+	UDC_DEBUG("<CTRL>ep0out irq handler, state is %d, queue is %s\n",
+		  udc->ep0state, (req == NULL) ? "empty" : "not empty");
+
+	switch (udc->ep0state) {
+	case EP0_OUT_DATA_PHASE:
+		if (req) {
+			if (read_ep0_fifo(ep, req)) {
+				/*ACK*/ 
+				udc_handle_status(udc);
+				/*cleanup */
+				udc->req_pending = 0;
+				udc->ep0state = EP0_WAIT_FOR_SETUP;
+				done(ep, req, 0);
+				req = NULL;
+			} else
+				writeb(0, udc->base + OUT0BC);
+			/*write OUT0BC with any value to
+			   enable next OUT transaction */
+		} else
+			UDC_DEBUG("<CTRL>ep0out irq error, queue is empty but state is EP0_OUT_DATA_PHASE\n");
+		/*never enter this branch */
+		break;
+	case EP0_STALL:
+		if (req) {
+			done(ep, req, -ESHUTDOWN);
+			req = NULL;
+		}
+		break;
+	default:
+		UDC_DEBUG("<CTRL>ep0out irq error, odd state %d\n", udc->ep0state);
+	}
+}
+
+static void udc_enable(struct aotg_udc *dev)
+{
+	struct aotg_udc *udc = dev;
+
+	dev->ep0state = EP0_WAIT_FOR_SETUP;
+	dev->stats.irqs = 0;
+	dev->state = UDC_IDLE;
+	dev->gadget.dev.parent->power.power_state = PMSG_ON;
+	dev->gadget.dev.power.power_state = PMSG_ON;
+	UDC_DEBUG("<UDC_ENABLE> %p, AOTG enters :%d state\n", dev, readb(udc->base + OTGSTATE));
+
+	UDC_DEBUG("Pull up D+\n");
+	/*pull up D+ to let  host  see us */
+	dplus_up(udc);
+}
+
+static void udc_disable(struct aotg_udc *dev)
+{
+	struct aotg_udc *udc = dev;
+
+	UDC_DEBUG("<UDC_DISABLE> %p,%d state\n", dev,readb(udc->base + OTGSTATE));
+	/*FIX ME: clear some irqs */
+	UDC_DEBUG("Pull down D+\n");
+	/*Pull down D+ */
+	dplus_down(udc);
+
+	/*Clear software state */
+	dev->ep0state = EP0_WAIT_FOR_SETUP;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	printk("%d,===============set speed unknown=============\n",__LINE__);
+	dev->state = UDC_DISABLE;
+}
+
+int pullup(struct aotg_udc *udc, int is_active)
+{
+	is_active = is_active && udc->softconnect;
+	UDC_DEBUG("<PULL_UP> %s\n", is_active ? "active" : "inactive");
+	if (is_active)
+		udc_enable(udc);
+	else
+		udc_disable(udc);
+
+	return 0;
+}
+
+irqreturn_t aotg_udc_irq(int irq, void *data)
+{
+	struct aotg_udc *udc = (struct aotg_udc *)data;
+	irqreturn_t retval = IRQ_HANDLED;
+	u8 irqvector, external_irq, dma_irq;
+	u8 otgint, otg_state;
+	int dma_pend_cnt = 0;
+	unsigned long flags = 0;
+	unsigned long tmp_flag;
+
+	external_irq = readb(udc->base + USBEIRQ);
+
+	spin_lock_irqsave(&udc->lock, flags);
+	if (!(external_irq & USBEIRQ_USBIRQ)) {
+		dma_pend_cnt = aotg_udc_dma_irq_handler(udc, dma_irq);
+		spin_unlock_irqrestore(&udc->lock, flags);
+		if (dma_pend_cnt == 0)
+			return IRQ_NONE;
+		else
+			return IRQ_HANDLED;
+	}
+
+	writeb(external_irq, udc->base + USBEIRQ);
+
+	/* connect disconnect happened */
+	if ((external_irq & 0x50) != 0) {
+		printk("<UDC>external irq: %x\n", external_irq);
+
+		if (external_irq & 0x40) {
+			aotg_udc_pullup(&udc->gadget, 0);
+			udc->state = UDC_UNKNOWN;
+			if (udc->driver && udc->driver->disconnect) {
+				udc->driver->disconnect(&udc->gadget);
+			}
+			udc->gadget.speed = USB_SPEED_UNKNOWN;
+			printk("%d,===============set speed unknown=============\n",__LINE__);
+		}
+		spin_unlock_irqrestore(&udc->lock, flags);
+		return retval;
+	}
+
+	irqvector = readb(udc->base + IVECT);
+	printk("i%x\n", irqvector);
+
+	switch (irqvector) {
+	case UIV_IDLE:
+	case UIV_SRPDET:
+	case UIV_LOCSOF:
+	case UIV_VBUSERR:
+	case UIV_PERIPH:
+		otgint = readb(udc->base + OTGIEN) & readb(udc->base + OTGIRQ);
+		writeb(otgint, udc->base + OTGIRQ);
+		otg_state = readb(udc->base + OTGSTATE);
+		UDC_DEBUG("OTG_STATE is %x\n", otg_state);
+		switch (otgint) {
+		case OTGIRQ_PERIPH:
+UDC_DBG_ERR;
+			usb_setbitsb(USBIEN_URES | USBIEN_HS | USBIEN_SUDAV | USBIEN_SUSP, udc->base + USBIEN);
+			udc->state = UDC_ACTIVE;
+			udc->disconnect = 0;
+			break;
+		case OTGIRQ_IDLE:
+UDC_DBG_ERR;
+			UDC_DEBUG("Enter B-IDLE\n");
+			udc->state = UDC_IDLE;
+			break;
+		default:
+UDC_DBG_ERR;
+			break;
+
+		}
+		UDC_DEBUG("UIV_OTG_IRQ 0x%x\n", otgint);
+		break;
+	case UIV_USBRESET:
+		printk("reset irq come!\n");
+		if (  udc->gadget.speed != USB_SPEED_UNKNOWN)
+		{
+			if (udc->driver && udc->driver->disconnect) {
+				spin_unlock_irqrestore(&udc->lock, flags);
+				udc->driver->disconnect(&udc->gadget);
+				spin_lock_irqsave(&udc->lock, flags);
+			}
+		}
+		writeb(0xdf, udc->base + USBIRQ);
+		writeb(0xff, udc->base + OTGIRQ);
+		writeb(0xff, udc->base + INxIRQ);
+		writeb(0xff, udc->base + OUTxIRQ);
+
+		/* reset dma channel */
+		aotg_epin_dma_reset(udc);
+		UDC_DEBUG("gadget %s, USB reset done\n", udc->driver->driver.name);
+
+		/*when bus reset, we assume the current speed is FS */
+		udc->gadget.speed = USB_SPEED_FULL;
+		udc->gadget.b_hnp_enable = 0;
+		udc->gadget.a_hnp_support = 0;
+		udc->gadget.a_alt_hnp_support = 0;
+		udc->highspeed = 0;
+		udc_ep_packet_config(USB_SPEED_FULL, udc);
+		mdelay(4);
+		udc->reset_cnt++;
+		break;
+	case UIV_HSPEED:
+		writeb(USBIRQ_HS, udc->base + USBIRQ);
+		udc->gadget.speed = USB_SPEED_HIGH;
+		udc->highspeed = 1;
+		udc_ep_packet_config(USB_SPEED_HIGH, udc);
+#if 0
+		if (udc->reset_cnt > 2) {
+			usb_setbitsb(0x80, udc->base + BKDOOR);
+		}
+#endif
+		break;
+	case UIV_SUSPEND:
+UDC_DBG_ERR;
+		writeb(USBIRQ_SUSP, udc->base + USBIRQ);
+		udc->state = UDC_SUSPEND;
+		udc->reset_cnt = 0;
+#if 0
+		aotg_udc_pullup(&udc->gadget, 0);
+		udc->state = UDC_UNKNOWN;
+		if (udc->driver && udc->driver->disconnect) {
+			udc->driver->disconnect(&udc->gadget);
+		}
+		udc->gadget.speed = USB_SPEED_UNKNOWN;
+		printk("%d,===============set speed unknown=============\n",__LINE__);
+#endif
+		break;
+	case UIV_SUDAV:
+		writeb(USBIRQ_SUDAV, udc->base + USBIRQ);
+		tmp_flag = flags;
+		handle_setup(udc,&tmp_flag);
+		flags = tmp_flag;
+		break;
+	case UIV_EP0IN:
+		writeb(1, udc->base + INxIRQ);
+		handle_ep0_in(udc);
+		break;
+	case UIV_EP0OUT:
+		writeb(1, udc + OUTxIRQ);
+		handle_ep0_out(udc);
+		break;
+	case UIV_EP1IN:
+	case UIV_EP2IN:
+	case UIV_EP3IN:
+	case UIV_EP4IN:
+	case UIV_EP5IN:
+		printk("no ep_in irq any more!\n");
+		break;
+	case UIV_EP1OUT:
+	case UIV_EP2OUT:
+	case UIV_EP3OUT:
+	case UIV_EP4OUT:
+	case UIV_EP5OUT:
+		printk("no ep_out irq any more!\n");
+		break;
+	case UIV_SOF:
+		UDC_DEBUG("<UDC> sof is come\n");
+		break;
+	default:
+		UDC_DEBUG("The ivent is 0x%x.\n", irqvector);
+		retval = IRQ_NONE;
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return retval;
+}
+
+void udc_reinit(struct aotg_udc *dev)
+{
+	unsigned i;
+
+	/*device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+
+	dev->ep0state = EP0_WAIT_FOR_SETUP;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	printk("%d,===============set speed unknown=============\n",__LINE__);
+	dev->state = UDC_UNKNOWN;
+	memset(&dev->stats, 0, sizeof(struct udc_stats));
+
+	/*basic endpoint records init */
+	for (i = 0; i < AOTG_UDC_NUM_ENDPOINTS; i++) {
+		struct aotg_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->ep.desc = NULL;
+		ep->dev = dev;
+		ep->stopped = 0;
+		INIT_LIST_HEAD(&ep->queue);
+		ep->udc_irqs = 0;
+	}
+}
+
+static int aotg_udc_endpoint_config(struct aotg_udc *udc, struct usb_gadget_driver *driver)
+{
+	UDC_BULK_EP(1, "ep1out", USB_DIR_OUT | 1, EPCON_BUF_SINGLE);
+	UDC_BULK_EP(2, "ep1in", USB_DIR_IN | 1, EPCON_BUF_SINGLE);
+	UDC_BULK_EP(3, "ep2out", USB_DIR_OUT | 2, EPCON_BUF_SINGLE);
+	UDC_BULK_EP(4, "ep2in", USB_DIR_IN | 2, EPCON_BUF_SINGLE);
+	UDC_BULK_EP(5, "ep3out", USB_DIR_OUT | 3, EPCON_BUF_SINGLE);
+	UDC_INT_EP(6, "ep3in", USB_DIR_IN | 3, EPCON_BUF_SINGLE);
+	UDC_ISO_EP(7, "ep4in", USB_DIR_IN | 4, EPCON_BUF_SINGLE);
+
+	udc_ep_packet_config(USB_SPEED_FULL, udc);
+	return 0;
+}
+
+struct aotg_udc memory = {
+	.lock = __SPIN_LOCK_UNLOCKED(memory.lock),
+	.gadget = {
+		   .ops = &aotg_udc_ops,
+		   .ep0 = &memory.ep[0].ep,
+		   .max_speed = USB_SPEED_HIGH,
+		   .speed		= USB_SPEED_UNKNOWN,
+		   .name = udc_driver_name,
+		   .dev = {
+			   .init_name = "gadget",
+			   },
+		   },
+
+	/*control endpoint */
+	.ep[0] = {
+		  .ep = {
+			 .name = ep0name,
+			 .ops = &aotg_ep_ops,
+			 .maxpacket = EP0_PACKET_SIZE,
+			 },
+		  .dev = &memory,
+		  .maxpacket = EP0_PACKET_SIZE,
+
+		  .ring = NULL,
+		  },
+
+	/*bulk out endpoint */
+	.ep[1] = {
+		  .ep = {
+			 .ops = &aotg_ep_ops,
+			 },
+		  .dev = &memory,
+		  .bEndpointAddress = 1,
+		  .mask = 1,
+		  .reg_udccs = OUT1CS,
+		  .reg_udccon = OUT1CON,
+		  .reg_udcbc = OUT1BCL,
+		  .reg_udcfifo = 0,
+		  .reg_maxckl = HCIN1MAXPCKL,
+		  .reg_fifostaddr = OUT1STARTADDRESS,
+
+		  .reg_dmalinkaddr = HCIN1DMALINKADDR,
+		  .reg_curaddr = HCIN1DMACURADDR,
+		  .reg_dmactrl = HCIN1DMACTRL,
+		  .reg_dmacomplete_cnt = HCIN1DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+
+	/*bulk in endpoint */
+	.ep[2] = {
+		  .ep = {
+			 .ops = &aotg_ep_ops,
+			 },
+		  .dev = &memory,
+		  .bEndpointAddress = USB_DIR_IN | 1,
+		  .mask = USB_UDC_IN_MASK | 1,
+		  .reg_udccs = IN1CS,
+		  .reg_udccon = IN1CON,
+		  .reg_udcbc = IN1BCL,
+		  .reg_udcfifo = 0,
+		  .reg_maxckl = HCOUT1MAXPCKL,
+		  .reg_fifostaddr = IN1STARTADDRESS,
+
+		  .reg_dmalinkaddr = HCOUT1DMALINKADDR,
+		  .reg_curaddr = HCOUT1DMACURADDR,
+		  .reg_dmactrl = HCOUT1DMACTRL,
+		  .reg_dmacomplete_cnt = HCOUT1DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+
+	/*bulk out endpoint */
+	.ep[3] = {
+		  .ep = {
+			 .ops = &aotg_ep_ops,
+			 },
+		  .dev = &memory,
+		  .bEndpointAddress = 2,
+		  .mask = 2,
+		  .reg_udccs = OUT2CS,
+		  .reg_udccon = OUT2CON,
+		  .reg_udcbc = OUT2BCL,
+		  .reg_udcfifo = 0,
+		  .reg_maxckl = HCIN2MAXPCKL,
+		  .reg_fifostaddr = OUT2STARTADDRESS,
+
+		  .reg_dmalinkaddr = HCIN2DMALINKADDR,
+		  .reg_curaddr = HCIN2DMACURADDR,
+		  .reg_dmactrl = HCIN2DMACTRL,
+		  .reg_dmacomplete_cnt = HCIN2DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+
+	/*bulk in endpoint */
+	.ep[4] = {
+		  .ep = {
+			 .ops = &aotg_ep_ops,
+			 },
+		  .dev = &memory,
+		  .bEndpointAddress = USB_DIR_IN | 2,
+		  .mask = USB_UDC_IN_MASK | 2,
+		  .reg_udccs = IN2CS,
+		  .reg_udccon = IN2CON,
+		  .reg_udcbc = IN2BCL,
+		  .reg_udcfifo = 0,
+		  .reg_maxckl = HCOUT2MAXPCKL,
+		  .reg_fifostaddr = IN2STARTADDRESS,
+
+		  .reg_dmalinkaddr = HCOUT2DMALINKADDR,
+		  .reg_curaddr = HCOUT2DMACURADDR,
+		  .reg_dmactrl = HCOUT2DMACTRL,
+		  .reg_dmacomplete_cnt = HCOUT2DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+
+	/*bulk out endpoint */
+	.ep[5] = {
+		  .ep = {
+			 .ops = &aotg_ep_ops,
+			 },
+		  .dev = &memory,
+		  .bEndpointAddress = 3,
+		  .mask = 3,
+		  .reg_udccs = OUT3CS,
+		  .reg_udccon = OUT3CON,
+		  .reg_udcbc = OUT3BCL,
+		  .reg_udcfifo = 0,
+		  .reg_maxckl = HCIN3MAXPCKL,
+		  .reg_fifostaddr = OUT3STADDR,
+
+		  .reg_dmalinkaddr = HCIN3DMALINKADDR,
+		  .reg_curaddr = HCIN3DMACURADDR,
+		  .reg_dmactrl = HCIN3DMACTRL,
+		  .reg_dmacomplete_cnt = HCIN3DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+
+	/* interupt in */
+	.ep[6] = {
+		  .ep = {
+			 .ops = &aotg_ep_ops,
+			 },
+		  .dev = &memory,
+		  .bEndpointAddress = USB_DIR_IN | 3,
+		  .mask = USB_UDC_IN_MASK | 3,
+		  .reg_udccs = IN3CS,
+		  .reg_udccon = IN3CON,
+		  .reg_udcbc = IN3BCL,
+		  .reg_udcfifo = 0,
+		  .reg_maxckl = HCOUT3MAXPCKL,
+		  .reg_fifostaddr = IN3STADDR,
+
+		  .reg_dmalinkaddr = HCOUT3DMALINKADDR,
+		  .reg_curaddr = HCOUT3DMACURADDR,
+		  .reg_dmactrl = HCOUT3DMACTRL,
+		  .reg_dmacomplete_cnt = HCOUT3DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+
+	/*iso in endpoint */
+	.ep[7] = {
+		  .ep = {
+			 .ops = &aotg_ep_ops,
+			 },
+		  .dev = &memory,
+		  .bEndpointAddress = USB_DIR_IN | 4,
+		  .mask = USB_UDC_IN_MASK | 4,
+		  .reg_udccs = IN4CS,
+		  .reg_udccon = IN4CON,
+		  .reg_udcbc = IN4BCL,
+		  .reg_udcfifo = 0,
+		  .reg_maxckl = HCOUT4MAXPCKL,
+		  .reg_fifostaddr = IN4STADDR,
+
+		  .reg_dmalinkaddr = HCOUT4DMALINKADDR,
+		  .reg_curaddr = HCOUT4DMACURADDR,
+		  .reg_dmactrl = HCOUT4DMACTRL,
+		  .reg_dmacomplete_cnt = HCOUT4DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+
+	/*bulk out endpoint */
+	.ep[8] = {
+		  .ep = {
+			 .ops = &aotg_ep_ops,
+			 },
+		  .dev = &memory,
+		  .bEndpointAddress = 4,
+		  .mask = 4,
+		  .reg_udccs = OUT4CS,
+		  .reg_udccon = OUT4CON,
+		  .reg_udcbc = OUT4BCL,
+		  .reg_udcfifo = 0,
+		  .reg_maxckl = HCIN4MAXPCKL,
+		  .reg_fifostaddr = OUT4STADDR,
+
+		  .reg_dmalinkaddr = HCIN4DMALINKADDR,
+		  .reg_curaddr = HCIN4DMACURADDR,
+		  .reg_dmactrl = HCIN4DMACTRL,
+		  .reg_dmacomplete_cnt = HCIN4DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+	/*bulk in endpoint */
+	.ep[9] = {
+		  .ep = {
+			 .ops = &aotg_ep_ops,
+			 },
+		  .dev = &memory,
+		  .bEndpointAddress = USB_DIR_IN | 5,
+		  .mask = USB_UDC_IN_MASK | 5,
+		  .reg_udccs = IN5CS,
+		  .reg_udccon = IN5CON,
+		  .reg_udcbc = IN5BCL,
+		  .reg_udcfifo = 0,
+		  .reg_maxckl = HCOUT5MAXPCKL,
+		  .reg_fifostaddr = IN5STADDR,
+
+		  .reg_dmalinkaddr = HCOUT5DMALINKADDR,
+		  .reg_curaddr = HCOUT5DMACURADDR,
+		  .reg_dmactrl = HCOUT5DMACTRL,
+		  .reg_dmacomplete_cnt = HCOUT5DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+
+	/*bulk out endpoint */
+	.ep[10] = {
+		   .ep = {
+			  .ops = &aotg_ep_ops,
+			  },
+		   .dev = &memory,
+		   .bEndpointAddress = 5,
+		   .mask = 5,
+		   .reg_udccs = OUT5CS,
+		   .reg_udccon = OUT5CON,
+		   .reg_udcbc = OUT5BCL,
+		   .reg_udcfifo = 0,
+		   .reg_maxckl = HCIN5MAXPCKL,
+		   .reg_fifostaddr = OUT5STADDR,
+
+		  .reg_dmalinkaddr = HCIN5DMALINKADDR,
+		  .reg_curaddr = HCIN5DMACURADDR,
+		  .reg_dmactrl = HCIN5DMACTRL,
+		  .reg_dmacomplete_cnt = HCIN5DMACOMPLETECNT,
+		  .ring = NULL,
+
+		  },
+};
+
+static int __exit aotg_udc_remove(struct platform_device *pdev)
+{
+	struct aotg_udc *udc = platform_get_drvdata(pdev);
+
+	usb_del_gadget_udc(&udc->gadget);
+	usb_gadget_unregister_driver(udc->driver);
+	free_irq(udc->irq, udc);
+	udc->transceiver = NULL;
+	platform_set_drvdata(pdev, NULL);
+	acts_udc_controller = NULL;
+	aotg_clk_enable(pdev->id, 0);
+	iounmap(udc->base);
+	release_mem_region(udc->rsrc_start, udc->rsrc_len);
+	owl_powergate_power_off(pdev->id == 0 ? OWL_POWERGATE_USB2_0 : OWL_POWERGATE_USB2_1);
+
+	return 0;
+}
+
+struct platform_driver aotg_udc_driver = {
+	.driver = {
+		.name = "aotg_udc",
+		.owner = THIS_MODULE,
+		.of_match_table = aotg_of_match,
+	},
+	.probe = aotg_probe,
+	.remove = __exit_p(aotg_udc_remove),
+//	.suspend = aotg_udc_suspend,
+//	.resume = aotg_udc_resume,
+};
diff --git a/drivers/usb/aotg/aotg_udc.h b/drivers/usb/aotg/aotg_udc.h
new file mode 100755
index 0000000..7dfcf66
--- /dev/null
+++ b/drivers/usb/aotg/aotg_udc.h
@@ -0,0 +1,232 @@
+
+#ifndef  __LINUX_USB_GADGET_AOTG_H
+#define  __LINUX_USB_GADGET_AOTG_H
+
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/otg.h>
+#include <linux/io.h>
+#include "aotg.h"
+
+struct udc_ring {
+	unsigned is_running:1;
+	int num_trbs;
+	u8 mask;
+	atomic_t num_trbs_free;
+	struct aotg_trb *first_trb;
+	struct aotg_trb *last_trb;
+	struct aotg_trb *enqueue_trb;
+	struct aotg_trb *cur_trb;
+	u32 trb_dma;
+};
+
+/* about dma_no: if (dma_no & 0x10) == 0x10, it's hcout, otherwise it's hcin. */
+#define AOTG_DMA_OUT_PREFIX		0x10
+#define AOTG_DMA_NUM_MASK		0xf
+#define AOTG_IS_DMA_DEVICE_IN_HOUT(x)	((x) & AOTG_DMA_OUT_PREFIX)
+#define AOTG_GET_DMA_NUM(x)		((x) & AOTG_DMA_NUM_MASK)
+
+#define   CONFIG_USB_GADGET_DEBUG_FS
+
+#define   EP0_PACKET_SIZE       64
+
+#define   BULK_HS_PACKET_SIZE		512
+#define   BULK_FS_PACKET_SIZE		64
+
+#define   INT_HS_PACKET_SIZE   	1024
+#define   INT_FS_PACKET_SIZE     	64
+
+#define   ISO_HS_PACKET_SIZE   	1024
+#define   ISO_FS_PACKET_SIZE    1023
+
+#define 	IRQ_AOTG_DMA    			0
+
+#define  	USB_UDC_IN_MASK       0x10
+#define   	EP_ADDR_MASK          0x0F
+
+#define		EP1_BULK_OUT_STARTADD   		0x00000080
+#define 	EP1_BULK_IN_STARTADD  			0x00000480
+#define		EP2_BULK_IN_STARTADD   			0x00000880
+#define 	EP2_BULK_OUT_STARTADD  			0x00000A80
+
+#define 	EP_ISO_IN_STARTADD  			0x00000E80
+#define 	EP_INT_IN_STARTADD  			0x00001280
+
+#define AOTG_UDC_NUM_ENDPOINTS      11
+#define	OUT_EP_MAX_NUM			5
+#define	IN_EP_MAX_NUM			5
+
+
+#define UDC_BULK_EP(index,name,addr,buftype) \
+		aotg_ep_setup(udc, index, name "-bulk", addr, \
+				USB_ENDPOINT_XFER_BULK, buftype);
+#define UDC_INT_EP(index,name,addr, buftype) \
+		aotg_ep_setup(udc, index, name "-int", addr, \
+				USB_ENDPOINT_XFER_INT, buftype);
+#define UDC_ISO_EP(index, name, addr, buftype) \
+		aotg_ep_setup(udc , index, name "-iso", addr, \
+				USB_ENDPOINT_XFER_ISOC, buftype);
+
+struct epstats {
+	u32 ops;
+	u32 bytes;
+};
+
+//struct aotg_udc;
+
+struct aotg_ep {
+	struct usb_ep ep;
+	struct aotg_udc *dev;
+	const struct usb_endpoint_descriptor *desc;
+	struct list_head queue;
+	char name[14];
+	u32 udc_irqs;
+	struct epstats read;
+	struct epstats write;
+	unsigned short maxpacket;
+	u8 bEndpointAddress;
+	u8 bmAttributes;
+	unsigned stopped:1;
+	u8 mask;
+	u8 buftype;
+	u32 reg_udccs;
+	u32 reg_udccon;
+	u32 reg_udcbc;
+	u32 reg_udcfifo;
+	u32 reg_maxckl;
+	u32 reg_fifostaddr;
+	int dma_no;
+
+	u32 reg_dmalinkaddr;
+	u32 reg_curaddr;
+	u32 reg_dmactrl;
+	u32 reg_dmacomplete_cnt;
+
+	struct udc_ring *ring;
+};
+
+struct aotg_request {
+	struct usb_request req;
+	struct list_head queue;
+	struct aotg_trb *queue_trb;
+	struct aotg_trb *start_trb;
+	struct aotg_trb *end_trb;
+	unsigned num_trbs:16;
+	unsigned cross_req:1;
+};
+
+enum ep0_state {
+	EP0_WAIT_FOR_SETUP,
+	EP0_IN_DATA_PHASE,
+	EP0_OUT_DATA_PHASE,
+	EP0_END_XFER,
+	EP0_STALL,
+};
+
+enum udc_state {
+	UDC_UNKNOWN,
+	UDC_IDLE,
+	UDC_ACTIVE,
+	UDC_SUSPEND,
+	UDC_DISABLE,
+};
+
+struct udc_stats {
+	struct epstats read, write;
+	u32 irqs;
+};
+
+struct aotg_udc {
+	void __iomem *base;
+	int irq;
+	int	id;
+	int reset_cnt;
+	spinlock_t lock;
+
+	struct aotg_plat_data  *port_specific;
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+	struct device *dev;
+	struct usb_phy *transceiver;
+
+	enum ep0_state ep0state;
+	enum udc_state state;
+	struct udc_stats stats;
+	resource_size_t		rsrc_start;
+	resource_size_t		rsrc_len;
+
+	struct aotg_ep ep[AOTG_UDC_NUM_ENDPOINTS];
+
+	unsigned enabled:1;
+	unsigned pullup_on:1;
+	unsigned pullup_resume:1;
+	unsigned softconnect:1;
+	unsigned config:2;
+	unsigned highspeed:1;
+	unsigned suspend:1;
+	unsigned disconnect:1;
+	unsigned req_pending:1;
+	unsigned req_std:1;
+	unsigned req_config:1;
+	unsigned rwk:1;
+	unsigned inited:1;
+
+#ifdef CONFIG_PM
+	unsigned udccsr0;
+#endif
+#ifdef CONFIG_USB_GADGET_DEBUG_FS
+	struct dentry *debugfs_udc;
+#endif
+};
+
+#define		dplus_up(udc)  	usb_clearbitsb(USBCS_DISCONN, udc->base + USBCS)
+#define		dplus_down(udc)  	usb_setbitsb(USBCS_DISCONN, udc->base + USBCS)
+
+#define		extern_irq_enable(udc) usb_setbitsb(USBEIRQ_USBIEN, udc->base + USBEIEN)
+#define		extern_irq_disable(udc) usb_setbitsb(USBEIRQ_USBIEN, udc->base + USBEIEN)
+
+/*#define DEBUG_UDC
+#define ERR_UDC
+#define ERR_UDC_DMA*/
+#define UDC_DBG_INFO		printk(KERN_ERR "udch--<%s:%d>", __func__, __LINE__)
+/*#define UDC_DBG_INFO		do {} while (0)*/
+#define UDC_DBG_ERR		pr_err("udch err!--<%s:%d>", __func__, __LINE__)
+#define UDC_DBG_TRACE		do {} while (0)
+/*#define UDC_DBG_TRACE		printk(KERN_ERR "udch trace:--<%s:%d>", __func__, __LINE__)*/
+
+#ifdef DEBUG_UDC
+#define UDC_DEBUG(fmt, args...)    printk(KERN_ERR "<UDC %s:%d>"fmt,__func__,__LINE__, ## args)
+#else
+#define UDC_DEBUG(fmt, args...)	/*not printk */
+#endif
+
+#define UDC_NOTICE(fmt, args...)    printk(KERN_ERR "<UDC %s:%d>"fmt,__func__,__LINE__, ## args)
+
+#define UDC_PRINTK(fmt, args...)
+
+#ifdef ERR_UDC
+#define UDC_ERR(fmt, args...)    printk(KERN_ERR "<UDC %s:%d>"fmt,__func__,__LINE__, ## args)
+#else
+#define UDC_ERR(fmt, args...)	/*not printk */
+#endif
+
+#ifdef ERR_UDC_DMA
+#define UDC_DMA_DEBUG(fmt, args...)    printk(KERN_ERR fmt, ## args)
+#else
+#define UDC_DMA_DEBUG(fmt, args...)	/*not printk */
+#endif
+
+#define UDC_WARNING(fmt, args...) printk(KERN_WARNING fmt, ## args)
+
+extern struct aotg_udc memory;
+extern struct aotg_udc *acts_udc_controller;
+extern const char udc_driver_name[];
+ int aotg_udc_register(int dev_id);
+void aotg_udc_unregister(int dev_id);
+extern struct platform_driver aotg_udc_driver;
+irqreturn_t aotg_udc_irq(int irq, void *data);
+void udc_reinit(struct aotg_udc *dev);
+int pullup(struct aotg_udc *udc, int is_active);
+
+#endif				/* __LINUX_USB_GADGET_AOTG_H */
diff --git a/drivers/usb/aotg/aotg_udc_debug.c b/drivers/usb/aotg/aotg_udc_debug.c
new file mode 100755
index 0000000..0ccb76a
--- /dev/null
+++ b/drivers/usb/aotg/aotg_udc_debug.c
@@ -0,0 +1,409 @@
+/*
+ * (C) Copyright www.actions-semi.com 2012-2014
+ *     Written by houjingkun. <houjingkun@actions-semi.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/highmem.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/hcd.h>
+#include <linux/timer.h>
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/../../fs/proc/internal.h>
+
+#include <mach/hardware.h>
+#include <linux/gpio.h>
+
+#include "aotg_udc_debug.h"
+#include "aotg.h"
+#include "aotg_regs.h"
+#include "aotg_plat_data.h"
+
+
+unsigned int aotg_udc_trace_onff = 0;
+
+#define AOTG_DEBUG_INFO_CNT	30
+static int aotg_dbg_idx = 0;
+static char aotg_dbg_strings[AOTG_DEBUG_INFO_CNT][8];
+static char* aotg_dbg_infoh[AOTG_DEBUG_INFO_CNT];
+static char* aotg_dbg_info0[AOTG_DEBUG_INFO_CNT];
+static unsigned int aotg_dbg_info1[AOTG_DEBUG_INFO_CNT];
+static unsigned int aotg_dbg_info2[AOTG_DEBUG_INFO_CNT];
+static unsigned int aotg_dbg_info3[AOTG_DEBUG_INFO_CNT];
+
+void aotg_dbg_put_info(char *info_h, char *info0, unsigned int info1, unsigned int info2, unsigned int info3)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	strncpy(&aotg_dbg_strings[aotg_dbg_idx][0], info0, 7);
+	aotg_dbg_strings[aotg_dbg_idx][7] = 0;
+	aotg_dbg_infoh[aotg_dbg_idx] = info_h;
+	aotg_dbg_info0[aotg_dbg_idx] = info0;
+	aotg_dbg_info1[aotg_dbg_idx] = info1;
+	aotg_dbg_info2[aotg_dbg_idx] = info2;
+	aotg_dbg_info3[aotg_dbg_idx] = info3;
+	aotg_dbg_idx++;
+	if (aotg_dbg_idx >= AOTG_DEBUG_INFO_CNT)
+		aotg_dbg_idx = 0;
+	local_irq_restore(flags);
+	return;
+}
+
+void aotg_udc_dbg_output_info(void)
+{
+	int i;
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	for (i = 0; i < AOTG_DEBUG_INFO_CNT; i++) {
+		printk("i:%d  ", i);
+		//printk("strins:%s: ", &aotg_dbg_strings[aotg_dbg_idx][0]);
+		printk("info_h:%s: ", aotg_dbg_infoh[aotg_dbg_idx]);
+		printk("info0:%s: ", aotg_dbg_info0[aotg_dbg_idx]);
+		printk("info1:%d, 0x%x; ", aotg_dbg_info1[aotg_dbg_idx], aotg_dbg_info1[aotg_dbg_idx]);
+		printk("info2:%d, 0x%x; ", aotg_dbg_info2[aotg_dbg_idx], aotg_dbg_info2[aotg_dbg_idx]);
+		printk("info3:%d, 0x%x; \n", aotg_dbg_info3[aotg_dbg_idx], aotg_dbg_info3[aotg_dbg_idx]);
+		aotg_dbg_idx++;
+		if (aotg_dbg_idx >= AOTG_DEBUG_INFO_CNT)
+			aotg_dbg_idx = 0;
+	}
+	local_irq_restore(flags);
+	return;
+}
+
+void aotg_output_current_ep_status(struct seq_file *m)
+{
+	struct aotg_ep *ep;
+	struct aotg_request *req;
+	const struct usb_endpoint_descriptor *desc;
+	struct aotg_trb *trb;
+	struct udc_ring *ring;
+	struct aotg_udc *udc;
+	int i;
+
+	printk("%s %d\n",__func__,__LINE__);
+	for (i = 0; i < AOTG_UDC_NUM_ENDPOINTS; i++) {
+		ep = &acts_udc_controller->ep[i];
+		udc = ep->dev;
+
+		if (i != 0) {
+			desc = ep->ep.desc;
+			if (!desc)
+				continue;
+			
+			printk("index:%d\n",i);
+			printk("%s max %d irqs %d\n",
+				   ep->ep.name, le16_to_cpu(desc->wMaxPacketSize), ep->udc_irqs);
+
+		} else		/* ep0 should only have one transfer queued */
+			printk("ep0 max 16 pio irqs %x\n", ep->udc_irqs);
+
+		if (list_empty(&ep->queue)) {
+			printk("(nothing queued)\n");
+			continue;
+		}
+		printk("reg_dmalinkaddr:(%x)%x,reg_curaddr:(%x)%x,reg_dmactrl:(%x)%x,reg_dmacomplete_cnt:(%x)%x\n",
+			   ep->reg_dmalinkaddr,readl(udc->base + ep->reg_dmalinkaddr),
+			   ep->reg_curaddr,readl(udc->base + ep->reg_curaddr),
+			   ep->reg_dmactrl,readl(udc->base + ep->reg_dmactrl),
+			   ep->reg_dmacomplete_cnt,readl(udc->base + ep->reg_dmacomplete_cnt));
+		
+		ring = ep->ring;
+		if (!ring)
+			continue;
+		printk("===========ring infos==============:\nfirst_trb:%p,last_trb:%p,enqueue_trb:%p,cur_trb:%p,trb_dma:%d,num_trbs_free:%d\n",
+				ring->first_trb,ring->last_trb,ring->enqueue_trb,ring->cur_trb,ring->trb_dma,ring->num_trbs_free.counter);
+		trb = ring->first_trb;
+		for(trb=ring->first_trb; trb < ring->last_trb; trb++)	{
+			printk("hw_buf_ptr:%x,hw_buf_len:%x,hw_buf_remain:%x,hw_token:%x\n",
+					trb->hw_buf_ptr,trb->hw_buf_len,trb->hw_buf_remain,trb->hw_token);
+		}
+						
+		list_for_each_entry(req, &ep->queue, queue) {
+			printk("req %p len %d/%d buf %p\n",
+				   &req->req, req->req.actual, req->req.length, req->req.buf);
+		}
+	}
+
+	return;
+}
+
+//void acts_udc_test_output(char * info, int cnt)
+//{
+	//return;
+//}
+//EXPORT_SYMBOL(acts_udc_test_output);
+
+
+static struct proc_dir_entry *acts_udc_pde = NULL; 
+
+int acts_udc_proc_show(struct seq_file *s, void *unused)
+{
+	//seq_printf(s, "aotg_udc_trace_onff: %d\n", aotg_udc_trace_onff);
+	aotg_output_current_ep_status(s);
+	return 0;
+}
+
+static int acts_udc_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, acts_udc_proc_show, PDE_DATA(inode));
+}
+
+void demp_regs(struct aotg_udc *udc)
+{
+	printk(" USBEIRQ(0x%p) : 0x%X\n",
+		udc->base + USBEIRQ, readb(udc->base + USBEIRQ));
+	printk(" USBEIEN(0x%p) : 0x%X\n",
+		udc->base + USBEIEN, readb(udc->base + USBEIEN));
+	printk(" USBIRQ(0x%p) : 0x%X\n",
+		udc->base + USBIRQ, readb(udc->base + USBIRQ));
+	printk(" USBIEN(0x%p) : 0x%X\n",
+		udc->base + USBIEN, readb(udc->base + USBIEN));
+}
+
+void aotg_dbg_udc_regs(struct aotg_udc *udc)
+{
+	struct aotg_plat_data *data = udc->port_specific;
+	/*int i = 0;*/
+	printk("usbpll:%x,devrst:%x\n",usb_readl(data->usbpll), usb_readl(data->devrst));
+#if 0
+
+	do {
+		printk(" USB reg(0x%p):0x%X  ", udc->base + i, usb_readl(udc->base + i));
+		i += 4;
+		printk(":0x%X ", readl(udc->base + i));
+		i += 4;
+		printk(":0x%X ", readl(udc->base + i));
+		i += 4;
+		printk(":0x%X ", readl(udc->base + i));
+		i += 4;
+		printk("\n");
+	} while (i < 0x600);
+#endif
+	dev_info(udc->dev, "============== aotg regs ==================\n");
+
+  printk("usbecs:0x%X ", readl(data->usbecs));
+#if 1
+	printk(" USBEIRQ(0x%p) : 0x%X\n",
+            udc->base + USBEIRQ, readb(udc->base + USBEIRQ));
+	printk(" USBEIEN(0x%p) : 0x%X\n",
+            udc->base + USBEIEN, readb(udc->base + USBEIEN));
+	printk(" SRPCTRL(0x%p) : 0x%X\n",
+            udc->base + SRPCTRL, readb(udc->base + SRPCTRL));
+
+	printk("HCINxSHORTPCKIRQ0(0x%p) : 0x%X\n",
+            udc->base + HCINxSHORTPCKIRQ0 , readb(udc->base + HCINxSHORTPCKIRQ0 ));
+	printk("HCINxSHORTPCKIRQ1 (0x%p) : 0x%X\n",
+            udc->base + HCINxSHORTPCKIRQ1 , readb(udc->base + HCINxSHORTPCKIRQ1 ));
+	printk("HCINxSHORTPCKIEN0 (0x%p) : 0x%X\n",
+            udc->base + HCINxSHORTPCKIEN0 , readb(udc->base + HCINxSHORTPCKIEN0 ));
+	printk("HCINxSHORTPCKIEN1 (0x%p) : 0x%X\n",
+            udc->base + HCINxSHORTPCKIEN1 , readb(udc->base + HCINxSHORTPCKIEN1 ));
+
+	printk("HCINxERRIRQ0(0x%p) : 0x%X\n",
+            udc->base + HCINxERRIRQ0, readw(udc->base + HCINxERRIRQ0));
+
+	printk(" OTGIRQ(0x%p) : 0x%X\n",
+            udc->base + OTGIRQ, readb(udc->base + OTGIRQ));
+	printk(" OTGSTATE(0x%p) : 0x%X\n",
+            udc->base + OTGSTATE, readb(udc->base + OTGSTATE));
+	printk(" OTGCTRL(0x%p) : 0x%X\n",
+            udc->base + OTGCTRL, readb(udc->base + OTGCTRL));
+	printk(" OTGSTATUS(0x%p) : 0x%X\n",
+            udc->base + OTGSTATUS, readb(udc->base + OTGSTATUS));
+	printk(" OTGIEN(0x%p) : 0x%X\n",
+            udc->base + OTGIEN, readb(udc->base + OTGIEN));
+	printk("\n");
+	printk(" BKDOOR(0x%p) : 0x%X\n",
+            udc->base + BKDOOR, readb(udc->base + BKDOOR));
+	printk(" USBIRQ(0x%p) : 0x%X\n",
+            udc->base + USBIRQ, readb(udc->base + USBIRQ));
+	printk(" USBIEN(0x%p) : 0x%X\n",
+            udc->base + USBIEN, readb(udc->base + USBIEN));
+	printk("\n");
+#endif
+
+	printk("HCINxPNGIEN0:%x\n", (u32)readb(udc->base + HCINxPNGIEN0));
+	printk(" HCIN1DMACOUNTER(0x%p) : 0x%X\n",
+            udc->base + HCIN1DMACOUNTER, readb(udc->base + HCIN1DMACOUNTER));
+	printk(" HCIN2DMASTADDR(0x%p) : 0x%X\n",
+            udc->base + HCIN2DMASTADDR, readb(udc->base + HCIN2DMASTADDR));
+
+	printk(" HCOUTxIRQ0(0x%p) : 0x%X\n",
+            udc->base + HCOUTxIRQ0, readb(udc->base + HCOUTxIRQ0));
+	printk(" HCOUTxIEN0(0x%p) : 0x%X\n",
+            udc->base + HCOUTxIEN0, readb(udc->base + HCOUTxIEN0));
+	printk(" HCINxIRQ0(0x%p) : 0x%X\n",
+            udc->base + HCINxIRQ0, readb(udc->base + HCINxIRQ0));
+	printk(" HCINxIEN0(0x%p) : 0x%X\n",
+            udc->base + HCINxIEN0, readb(udc->base + HCINxIEN0));
+	printk("\n");
+#if 1
+	printk(" HCIN0BC(0x%p) : 0x%X\n",
+            udc->base + HCIN0BC, readb(udc->base + HCIN0BC));
+	printk(" EP0CS(0x%p) : 0x%X\n",
+            udc->base + EP0CS, readb(udc->base + EP0CS));
+	printk(" HCOUT0BC(0x%p) : 0x%X\n",
+            udc->base + HCOUT0BC, readb(udc->base + HCOUT0BC));
+	printk(" HCEP0CTRL(0x%p) : 0x%X\n",
+            udc->base + HCEP0CTRL, readb(udc->base + HCEP0CTRL));
+	printk("\n");
+	printk(" HCIN1BC(0x%p) : 0x%X\n",
+            udc->base + HCIN1BCL, readw(udc->base + HCIN1BCL));
+	printk(" HCIN1CON(0x%p) : 0x%X\n",
+            udc->base + HCIN1CON, readb(udc->base + HCIN1CON));
+	printk(" HCIN1CS(0x%p) : 0x%X\n",
+            udc->base + HCIN1CS, readb(udc->base + HCIN1CS));
+	printk(" HCIN1CTRL(0x%p) : 0x%X\n",
+            udc->base + HCIN1CTRL, readb(udc->base + HCIN1CTRL));
+	printk(" HCIN2BC(0x%p) : 0x%X\n",
+            udc->base + HCIN2BCL, readw(udc->base + HCIN2BCL));
+	printk(" HCIN2CON(0x%p) : 0x%X\n",
+            udc->base + HCIN2CON, readb(udc->base + HCIN2CON));
+	printk(" HCIN2CS(0x%p) : 0x%X\n",
+            udc->base + HCIN2CS, readb(udc->base + HCIN2CS));
+	printk(" HCIN2CTRL(0x%p) : 0x%X\n",
+            udc->base + HCIN2CTRL, readb(udc->base + HCIN2CTRL));
+	printk("\n");
+	printk(" HCIN4DMASTADDR(0x%p) : 0x%X\n",
+            udc->base + HCIN4DMASTADDR, readw(udc->base + HCIN4DMASTADDR));
+	printk(" HCIN4DMACOUNTER(0x%p) : 0x%X\n",
+            udc->base + HCIN4DMACOUNTER, readw(udc->base + HCIN4DMACOUNTER));
+	//printk(" HCINCTRL(0x%p) : 0x%X\n", udc->base + HCINCTRL, usb_readb(udc->base + HCINCTRL));
+	printk("\n");
+#endif
+	printk(" HCOUT1BC(0x%p) : 0x%X\n",
+            udc->base + HCOUT1BCL, readw(udc->base + HCOUT1BCL));
+	printk(" HCOUT1CON(0x%p) : 0x%X\n",
+            udc->base + HCOUT1CON, readb(udc->base + HCOUT1CON));
+	printk(" HCOUT1CS(0x%p) : 0x%X\n",
+            udc->base + HCOUT1CS, readb(udc->base + HCOUT1CS));
+	printk(" HCOUT1CTRL(0x%p) : 0x%X\n",
+            udc->base + HCOUT1CTRL, readb(udc->base + HCOUT1CTRL));
+	printk(" HCOUT2BC(0x%p) : 0x%X\n",
+            udc->base + HCOUT2BCL, readw(udc->base + HCOUT2BCL));
+	printk(" HCOUT2CON(0x%p) : 0x%X\n",
+            udc->base + HCOUT2CON, readb(udc->base + HCOUT2CON));
+	printk(" HCOUT2CS(0x%p) : 0x%X\n",
+            udc->base + HCOUT2CS, readb(udc->base + HCOUT2CS));
+	printk(" HCOUT2CTRL(0x%p) : 0x%X\n",
+            udc->base + HCOUT2CTRL, readb(udc->base + HCOUT2CTRL));
+	printk("\n");
+	printk("\n");
+	return;
+}
+
+static ssize_t acts_udc_proc_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	char c = 'n';
+
+	if (count) 
+		if (get_user(c, buf))
+			return -EFAULT;
+
+	if ((c >= '0') && (c <= '3'))
+		aotg_udc_trace_onff = c - '0';
+
+	if (c == 'a') {
+		printk("aotg udc 0 add\n");
+		aotg_udc_register(0);
+	}
+
+	if (c == 'b') {
+		printk("aotg udc 0 remove\n");
+		aotg_udc_unregister(0);
+	}
+
+	if (c == 'c') {
+		printk("aotg udc 1 add\n");
+		aotg_udc_register(1);
+	}
+
+	if (c == 'd') {
+		printk("aotg udc 1 remove\n");
+		aotg_udc_unregister(1);
+	}
+
+	if (c == 'e') 
+		aotg_udc_dbg_output_info();
+
+	if (c == 'f') 
+		aotg_udc_trace_onff = 0;
+
+	if (c == 'g')
+		if (acts_udc_controller)
+			aotg_dbg_udc_regs(acts_udc_controller); 
+
+
+	return count;
+}
+
+static const struct file_operations acts_udc_proc_ops = {
+	.open		= acts_udc_proc_open,
+	.read		= seq_read,
+	.write		= acts_udc_proc_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+void create_acts_udc_proc(void)
+{
+	acts_udc_pde = proc_create_data("acts_udc", 0, NULL, &acts_udc_proc_ops, acts_udc_pde);
+	return;
+}
+
+void remove_acts_udc_proc(void)
+{
+	if (acts_udc_pde) {
+		remove_proc_entry("acts_udc", NULL);
+		acts_udc_pde = NULL;
+	}
+	return;
+}
+
+void aotg_dbg_ep_queue_list(struct aotg_ep *ep)
+{
+	struct aotg_request *req;
+
+	printk("ep %s queue list:\n", ep->name);
+	list_for_each_entry(req, &ep->queue, queue) {
+		printk("req:%p\n", req);
+	}
+	return;
+}
diff --git a/drivers/usb/aotg/aotg_udc_debug.h b/drivers/usb/aotg/aotg_udc_debug.h
new file mode 100755
index 0000000..f314934
--- /dev/null
+++ b/drivers/usb/aotg/aotg_udc_debug.h
@@ -0,0 +1,19 @@
+#ifndef  __LINUX_USB_AOTG_UDC_DEBUG_H__ 
+#define  __LINUX_USB_AOTG_UDC_DEBUG_H__ 
+
+#include "aotg.h"
+#include "aotg_udc.h"
+
+extern unsigned int aotg_trace_onff;
+#define	AOTG_TRACE_ERR_PLACE	if (aotg_trace_onff) printk("-%d\n", __LINE__);
+
+void aotg_dbg_put_info(char *info_h, char *info0, unsigned int info1, unsigned int info2, unsigned int info3);
+void aotg_dbg_output_info(void);
+
+void create_acts_udc_proc(void);
+void remove_acts_udc_proc(void);
+
+void aotg_dbg_ep_queue_list(struct aotg_ep *ep);
+
+#endif /* __LINUX_USB_AOTG_DEBUG_H__ */ 
+ 
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 6d69301..7058b65 100755
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -75,5 +75,5 @@ obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
 obj-$(CONFIG_USB_FUSBH200_HCD)	+= fusbh200-hcd.o
 obj-$(CONFIG_USB_FOTG210_HCD)	+= fotg210-hcd.o
 obj-$(CONFIG_USB_MAX3421_HCD)	+= max3421-hcd.o
-obj-$(CONFIG_USB_AOTG_HCD)	+= acts_hub.o
-acts_hub-y := aotg_debug.o aotg_ring.o aotg_hcd.o aotg_mon.o
+#obj-$(CONFIG_USB_AOTG_HCD)	+= acts_hub.o
+#acts_hub-y := aotg_debug.o aotg_ring.o aotg_hcd.o aotg_mon.o
-- 
1.7.5.4

