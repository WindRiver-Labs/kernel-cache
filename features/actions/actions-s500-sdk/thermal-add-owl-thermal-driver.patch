From 02948a9e37e848bd05123fb44867fe961ae160e4 Mon Sep 17 00:00:00 2001
From: wurui <wurui@actions-semi.com>
Date: Mon, 7 Dec 2015 13:20:49 +0800
Subject: [PATCH 18/62] thermal: add owl thermal driver

commit 0906797fcddc802c64e4675276623a239ceb6715 from
https://github.com/xapp-le/kernel.git

Change-Id: If45e74130bbfdb48bed79a389edd91a17d6eab2e
---
 drivers/thermal/Kconfig                   |    8 +
 drivers/thermal/Makefile                  |    1 +
 drivers/thermal/cpu_cooling.c             |   67 +++
 drivers/thermal/s500-thermal.c            |  781 +++++++++++++++++++++++++++++
 drivers/thermal/step_wise.c               |   41 +-
 include/linux/cpu_cooling.h               |   24 +
 include/linux/platform_data/owl_thermal.h |  119 +++++
 7 files changed, 1026 insertions(+), 15 deletions(-)
 mode change 100644 => 100755 drivers/thermal/Kconfig
 mode change 100644 => 100755 drivers/thermal/Makefile
 mode change 100644 => 100755 drivers/thermal/cpu_cooling.c
 create mode 100755 drivers/thermal/s500-thermal.c
 mode change 100644 => 100755 drivers/thermal/step_wise.c
 mode change 100644 => 100755 include/linux/cpu_cooling.h
 create mode 100755 include/linux/platform_data/owl_thermal.h

diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
old mode 100644
new mode 100755
index f72b352..08a9243
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -207,6 +207,14 @@ config ARMADA_THERMAL
 	  Enable this option if you want to have support for thermal management
 	  controller present in Armada 370 and Armada XP SoC.
 
+config OWL_THERMAL
+	tristate "Actions Owl thermal management"
+	depends on ARCH_OWL
+	depends on OF
+	help
+	  Enable this option if you want to have support for thermal management
+	  controller present in Actions Owl SoC.
+	  
 config TEGRA_SOCTHERM
 	tristate "Tegra SOCTHERM thermal management"
 	depends on ARCH_TEGRA
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
old mode 100644
new mode 100755
index 17d3f92..18a892f
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -30,6 +30,7 @@ obj-y				+= samsung/
 obj-$(CONFIG_DOVE_THERMAL)  	+= dove_thermal.o
 obj-$(CONFIG_DB8500_THERMAL)	+= db8500_thermal.o
 obj-$(CONFIG_ARMADA_THERMAL)	+= armada_thermal.o
+obj-$(CONFIG_OWL_THERMAL)	+= s500-thermal.o
 obj-$(CONFIG_IMX_THERMAL)	+= imx_thermal.o
 obj-$(CONFIG_DB8500_CPUFREQ_COOLING)	+= db8500_cpufreq_cooling.o
 obj-$(CONFIG_INTEL_POWERCLAMP)	+= intel_powerclamp.o
diff --git a/drivers/thermal/cpu_cooling.c b/drivers/thermal/cpu_cooling.c
old mode 100644
new mode 100755
index f65f0d1..df924e8
--- a/drivers/thermal/cpu_cooling.c
+++ b/drivers/thermal/cpu_cooling.c
@@ -76,6 +76,9 @@ static DEFINE_IDR(cpufreq_idr);
 static DEFINE_MUTEX(cooling_cpufreq_lock);
 
 static LIST_HEAD(cpufreq_dev_list);
+/*Head of the blocking notifier chain to inform about frequency clamping*/
+static BLOCKING_NOTIFIER_HEAD(cputherm_state_notifier_list);
+
 
 /**
  * get_idr - function to get a unique id.
@@ -262,6 +265,7 @@ static int cpufreq_set_cur_state(struct thermal_cooling_device *cdev,
 	struct cpufreq_cooling_device *cpufreq_device = cdev->devdata;
 	unsigned int cpu = cpumask_any(&cpufreq_device->allowed_cpus);
 	unsigned int clip_freq;
+	unsigned int event;
 
 	/* Request state should be less than max_level */
 	if (WARN_ON(state > cpufreq_device->max_level))
@@ -275,6 +279,17 @@ static int cpufreq_set_cur_state(struct thermal_cooling_device *cdev,
 	cpufreq_device->cpufreq_state = state;
 	cpufreq_device->cpufreq_val = clip_freq;
 
+	if (state != 0) {
+		event = CPUFREQ_COOLING_START;
+		pr_info("[TMU] COOLING START\n");
+	} else {
+		event = CPUFREQ_COOLING_STOP;
+		pr_info("[TMU] COOLING STOP\n");
+	}
+
+	blocking_notifier_call_chain(&cputherm_state_notifier_list,
+						event, NULL);
+
 	cpufreq_update_policy(cpu);
 
 	return 0;
@@ -479,3 +494,55 @@ void cpufreq_cooling_unregister(struct thermal_cooling_device *cdev)
 	kfree(cpufreq_dev);
 }
 EXPORT_SYMBOL_GPL(cpufreq_cooling_unregister);
+
+/**
+ * cputherm_register_notifier - Register a notifier with cpu cooling interface.
+ * @nb:	struct notifier_block * with callback info.
+ * @list: integer value for which notification is needed. possible values are
+ *	CPUFREQ_COOLING_START and CPUFREQ_COOLING_STOP.
+ *
+ * This exported function registers a driver with cpu cooling layer. The driver
+ * will be notified when any cpu cooling action is called.
+ */
+
+int cputherm_register_notifier(struct notifier_block *nb, unsigned int list)
+{
+	int ret = 0;
+	pr_info("cputherm_register_notifier list %d\n",list);
+	switch (list) {
+	case CPUFREQ_COOLING_START:
+	case CPUFREQ_COOLING_STOP:
+		ret = blocking_notifier_chain_register(
+				&cputherm_state_notifier_list, nb);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(cputherm_register_notifier);
+
+/**
+ * cputherm_unregister_notifier - Un-register a notifier.
+ * @nb:	struct notifier_block * with callback info.
+ * @list: integer value for which notification is needed. values possible are
+ *	CPUFREQ_COOLING_START or CPUFREQ_COOLING_STOP.
+ *
+ * This exported function un-registers a driver with cpu cooling layer.
+ */
+int cputherm_unregister_notifier(struct notifier_block *nb, unsigned int list)
+{
+	int ret = 0;
+	pr_info("cputherm_unregister_notifier list %d\n",list);
+	switch (list) {
+	case CPUFREQ_COOLING_START:
+	case CPUFREQ_COOLING_STOP:
+		ret = blocking_notifier_chain_unregister(
+				&cputherm_state_notifier_list, nb);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(cputherm_unregister_notifier);
diff --git a/drivers/thermal/s500-thermal.c b/drivers/thermal/s500-thermal.c
new file mode 100755
index 0000000..197ff13
--- /dev/null
+++ b/drivers/thermal/s500-thermal.c
@@ -0,0 +1,781 @@
+/*
+ * owl_thermal.c - Actions OWL TMU (Thermal Management Unit)
+ *
+ *  Copyright (C) 2014 Actions (Zhuhai) Technology Co., Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <mach/bootdev.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/sysfs.h>
+#include <linux/kobject.h>
+#include <linux/io.h>
+#include <linux/mutex.h>
+#include <linux/platform_data/owl_thermal.h>
+#include <linux/thermal.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu_cooling.h>
+#include <linux/of.h>
+#include <linux/io.h>
+/* Owl generic registers */
+#define OWL_TMU_DEF_CODE_TO_TEMP_OFFSET	50
+
+/* atm7059a specific registers */
+
+
+/* In-kernel thermal framework related macros & definations */
+#define SENSOR_NAME_LEN	16
+#define MAX_TRIP_COUNT	8
+#define MAX_COOLING_DEVICE 4
+#define MAX_THRESHOLD_LEVS 4
+
+#define ACTIVE_INTERVAL 500
+#define IDLE_INTERVAL 2000
+#define MCELSIUS	1000
+
+/* CPU Zone information */
+#define PANIC_ZONE      4
+#define WARN_ZONE       3
+#define MONITOR_ZONE    2
+#define SAFE_ZONE       1
+
+#define GET_ZONE(trip) (trip + 2)
+#define GET_TRIP(zone) (zone - 2)
+
+#define OWL_ZONE_COUNT	3
+
+struct owl_tmu_data {
+	struct owl_tmu_platform_data *pdata;
+	struct resource *mem;
+	void __iomem *base;
+	/* int irq; */
+	enum soc_type soc;
+	/* struct work_struct irq_work; */
+	struct delayed_work wait_cpufreq_ready_work;
+	struct mutex lock;
+	/* struct clk *clk; */
+	u8 temp_error1, temp_error2;
+	int temp_emu;
+};
+
+struct	thermal_trip_point_conf {
+	int trip_val[MAX_TRIP_COUNT];
+	int trip_count;
+	u8 trigger_falling;
+};
+
+struct	thermal_cooling_conf {
+	struct freq_clip_table freq_data[MAX_TRIP_COUNT];
+	int freq_clip_count;
+};
+
+struct thermal_sensor_conf {
+	char name[SENSOR_NAME_LEN];
+	int (*read_temperature)(void *data);
+	int (*write_emul_temp)(void *drv_data, unsigned long temp);
+	struct thermal_trip_point_conf trip_data;
+	struct thermal_cooling_conf cooling_data;
+	void *private_data;
+};
+
+struct owl_thermal_zone {
+	enum thermal_device_mode mode;
+	struct thermal_zone_device *therm_dev;
+	struct thermal_cooling_device *cool_dev[MAX_COOLING_DEVICE];
+	unsigned int cool_dev_size;
+	struct platform_device *owl_dev;
+	struct thermal_sensor_conf *sensor_conf;
+	bool bind;
+};
+
+static struct owl_thermal_zone *th_zone;
+static void owl_unregister_thermal(void);
+static int owl_register_thermal(struct thermal_sensor_conf *sensor_conf);
+
+/* Get mode callback functions for thermal zone */
+static int owl_get_mode(struct thermal_zone_device *thermal,
+			enum thermal_device_mode *mode)
+{
+	if (th_zone)
+		*mode = th_zone->mode;
+	return 0;
+}
+
+/* Set mode callback functions for thermal zone */
+static int owl_set_mode(struct thermal_zone_device *thermal,
+			enum thermal_device_mode mode)
+{
+	if (!th_zone->therm_dev) {
+		pr_notice("thermal zone not registered\n");
+		return 0;
+	}
+
+	mutex_lock(&th_zone->therm_dev->lock);
+
+	if (mode == THERMAL_DEVICE_ENABLED)
+		th_zone->therm_dev->polling_delay = IDLE_INTERVAL;
+	else
+		th_zone->therm_dev->polling_delay = 0;
+
+	mutex_unlock(&th_zone->therm_dev->lock);
+
+	th_zone->mode = mode;
+	thermal_zone_device_update(th_zone->therm_dev);
+	pr_info("thermal polling set for duration=%d msec\n",
+				th_zone->therm_dev->polling_delay);
+	return 0;
+}
+
+
+/* Get trip type callback functions for thermal zone */
+static int owl_get_trip_type(struct thermal_zone_device *thermal, int trip,
+				 enum thermal_trip_type *type)
+{
+	switch (GET_ZONE(trip)) {
+	case MONITOR_ZONE:
+	case WARN_ZONE:
+		*type = THERMAL_TRIP_ACTIVE;
+		break;
+	case PANIC_ZONE:
+		*type = THERMAL_TRIP_CRITICAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* Get trip temperature callback functions for thermal zone */
+static int owl_get_trip_temp(struct thermal_zone_device *thermal, int trip,
+				unsigned long *temp)
+{
+	if (trip < GET_TRIP(MONITOR_ZONE) || trip > GET_TRIP(PANIC_ZONE))
+		return -EINVAL;
+
+	*temp = th_zone->sensor_conf->trip_data.trip_val[trip];
+	/* convert the temperature into millicelsius */
+	*temp = *temp * MCELSIUS;
+
+	return 0;
+}
+
+/* Set trip temperature callback functions for thermal zone */
+static int owl_set_trip_temp(struct thermal_zone_device *thermal, int trip,
+				unsigned long temp)
+{
+	if (trip < GET_TRIP(MONITOR_ZONE) || trip > GET_TRIP(PANIC_ZONE))
+		return -EINVAL;
+
+	printk("set temp%d= %ld\n", trip, temp);
+	th_zone->sensor_conf->trip_data.trip_val[trip] = temp/MCELSIUS;
+	return 0;
+}
+
+
+/* Get trip hyst temperature callback functions for thermal zone */
+static int owl_get_trip_hyst(struct thermal_zone_device *thermal, int trip,
+				unsigned long *temp)
+{
+	if (trip < GET_TRIP(MONITOR_ZONE) || trip > GET_TRIP(PANIC_ZONE))
+		return -EINVAL;
+
+	*temp = th_zone->sensor_conf->trip_data.trigger_falling;
+	/* convert the temperature into millicelsius */
+	*temp = *temp * MCELSIUS;
+
+	return 0;
+}
+
+/* Get critical temperature callback functions for thermal zone */
+static int owl_get_crit_temp(struct thermal_zone_device *thermal,
+				unsigned long *temp)
+{
+	int ret;
+	/* Panic zone */
+	ret = owl_get_trip_temp(thermal, GET_TRIP(PANIC_ZONE), temp);
+	return ret;
+}
+
+/* Bind callback functions for thermal zone */
+static int owl_bind(struct thermal_zone_device *thermal,
+			struct thermal_cooling_device *cdev)
+{
+	int ret = 0, i, tab_size, level;
+	struct freq_clip_table *tab_ptr, *clip_data;
+	struct thermal_sensor_conf *data = th_zone->sensor_conf;
+
+	tab_ptr = (struct freq_clip_table *)data->cooling_data.freq_data;
+	tab_size = data->cooling_data.freq_clip_count;
+
+	if (tab_ptr == NULL || tab_size == 0)
+		return -EINVAL;
+
+	/* find the cooling device registered*/
+	for (i = 0; i < th_zone->cool_dev_size; i++)
+		if (cdev == th_zone->cool_dev[i])
+			break;
+
+	/* No matching cooling device */
+	if (i == th_zone->cool_dev_size)
+		return 0;
+
+	/* Bind the thermal zone to the cpufreq cooling device */
+	for (i = 0; i < tab_size; i++) {
+		clip_data = (struct freq_clip_table *)&(tab_ptr[i]);
+		level = cpufreq_cooling_get_level(0, clip_data->freq_clip_max);
+		if (level == THERMAL_CSTATE_INVALID)
+			return 0;
+		switch (GET_ZONE(i)) {
+		case MONITOR_ZONE:
+		case WARN_ZONE:
+			if (thermal_zone_bind_cooling_device(thermal, i, cdev,
+								level, 0)) {
+				pr_err("error binding cdev inst %d\n", i);
+				ret = -EINVAL;
+			}
+			th_zone->bind = true;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+	}
+
+	return ret;
+}
+
+/* Unbind callback functions for thermal zone */
+static int owl_unbind(struct thermal_zone_device *thermal,
+			struct thermal_cooling_device *cdev)
+{
+	int ret = 0, i, tab_size;
+	struct thermal_sensor_conf *data = th_zone->sensor_conf;
+
+	if (th_zone->bind == false)
+		return 0;
+
+	tab_size = data->cooling_data.freq_clip_count;
+
+	if (tab_size == 0)
+		return -EINVAL;
+
+	/* find the cooling device registered*/
+	for (i = 0; i < th_zone->cool_dev_size; i++)
+		if (cdev == th_zone->cool_dev[i])
+			break;
+
+	/* No matching cooling device */
+	if (i == th_zone->cool_dev_size)
+		return 0;
+
+	/* Bind the thermal zone to the cpufreq cooling device */
+	for (i = 0; i < tab_size; i++) {
+		switch (GET_ZONE(i)) {
+		case MONITOR_ZONE:
+		case WARN_ZONE:
+			if (thermal_zone_unbind_cooling_device(thermal, i,
+								cdev)) {
+				pr_err("error unbinding cdev inst=%d\n", i);
+				ret = -EINVAL;
+			}
+			th_zone->bind = false;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+	}
+	return ret;
+}
+
+/* Get temperature callback functions for thermal zone */
+static int owl_get_temp(struct thermal_zone_device *thermal,
+			unsigned long *temp)
+{
+	void *data;
+
+	if (!th_zone->sensor_conf) {
+		pr_info("Temperature sensor not initialised\n");
+		return -EINVAL;
+	}
+	data = th_zone->sensor_conf->private_data;
+	*temp = th_zone->sensor_conf->read_temperature(data);
+	/* convert the temperature into millicelsius */
+	*temp = *temp * MCELSIUS;
+	return 0;
+}
+
+/* Get the temperature trend */
+static int owl_get_trend(struct thermal_zone_device *thermal,
+			int trip, enum thermal_trend *trend)
+{
+	int ret;
+	unsigned long trip_temp;
+
+	ret = owl_get_trip_temp(thermal, trip, &trip_temp);
+	if (ret < 0)
+		return ret;
+	/*TODO:*/
+	if (thermal->temperature >= trip_temp)
+		*trend = THERMAL_TREND_RAISE_FULL;
+	else
+		*trend = THERMAL_TREND_DROP_FULL;
+
+	return 0;
+}
+/* Operation callback functions for thermal zone */
+static struct thermal_zone_device_ops owl_dev_ops = {
+	.bind = owl_bind,
+	.unbind = owl_unbind,
+	.get_temp = owl_get_temp,
+	.get_trend = owl_get_trend,
+	.get_mode = owl_get_mode,
+	.set_mode = owl_set_mode,
+	.get_trip_type = owl_get_trip_type,
+	.get_trip_temp = owl_get_trip_temp,
+	.set_trip_temp = owl_set_trip_temp,
+	.get_trip_hyst = owl_get_trip_hyst,
+	.get_crit_temp = owl_get_crit_temp,
+};
+
+/* Register with the in-kernel thermal management */
+static int owl_register_thermal(struct thermal_sensor_conf *sensor_conf)
+{
+	int ret;
+	struct cpumask mask_val;
+
+	if (!sensor_conf || !sensor_conf->read_temperature) {
+		pr_err("Temperature sensor not initialised\n");
+		return -EINVAL;
+	}
+
+	th_zone = kzalloc(sizeof(struct owl_thermal_zone), GFP_KERNEL);
+	if (!th_zone)
+		return -ENOMEM;
+
+	th_zone->sensor_conf = sensor_conf;
+	cpumask_set_cpu(0, &mask_val);
+	th_zone->cool_dev[0] = cpufreq_cooling_register(&mask_val);
+	if (IS_ERR(th_zone->cool_dev[0])) {
+		pr_err("Failed to register cpufreq cooling device\n");
+		ret = -EINVAL;
+		goto err_unregister;
+	}
+	th_zone->cool_dev_size++;
+
+	th_zone->therm_dev = thermal_zone_device_register(sensor_conf->name,
+			OWL_ZONE_COUNT, 0x7, NULL, &owl_dev_ops, NULL, 0, IDLE_INTERVAL);
+
+	if (IS_ERR(th_zone->therm_dev)) {
+		pr_err("Failed to register thermal zone device\n");
+		ret = PTR_ERR(th_zone->therm_dev);
+		goto err_unregister;
+	}
+	th_zone->mode = THERMAL_DEVICE_ENABLED;
+
+	pr_info("OWL: Kernel Thermal management registered\n");
+
+	return 0;
+
+err_unregister:
+	owl_unregister_thermal();
+	return ret;
+}
+
+/* Un-Register with the in-kernel thermal management */
+static void owl_unregister_thermal(void)
+{
+	int i;
+
+	if (!th_zone)
+		return;
+
+	if (th_zone->therm_dev)
+		thermal_zone_device_unregister(th_zone->therm_dev);
+
+	for (i = 0; i < th_zone->cool_dev_size; i++) {
+		if (th_zone->cool_dev[i])
+			cpufreq_cooling_unregister(th_zone->cool_dev[i]);
+	}
+
+	kfree(th_zone);
+	pr_info("OWL: Kernel Thermal management unregistered\n");
+}
+
+/*
+ * Calculate a temperature value from a temperature code.
+ * The unit of the temperature is degree Celsius.
+ * T = 838.45*7.894/(1024*12/count+7.894)-275+offset
+ */
+static int offset=0;
+static int code_to_temp(struct owl_tmu_data *data, u32 temp_code)
+{
+	int tmp1,tmp2;
+	tmp1 = 83845*7894;
+	tmp2 = (1024*12*100000/temp_code)+789400;
+	tmp1 = tmp1/tmp2;
+	tmp1 = tmp1 - 275 + offset;
+	//printk(KERN_DEBUG "temp:%d\n", tmp1);
+	printk(KERN_INFO "temp:%d\n", tmp1);
+	return tmp1;
+}
+
+static int owl_tmu_initialize(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+
+static void owl_tmu_control(struct platform_device *pdev, bool on)
+{
+
+}
+
+#define TRY_TEMP_CNT	5
+static u32 owl_tmu_temp_code_read(struct owl_tmu_data *data)
+{
+	int i, j, ready;
+	u32 tmp, temp_code=0, temp_arry[TRY_TEMP_CNT];
+	void __iomem *TS_CTL;
+	void __iomem *TS_OUT;
+
+	TS_CTL = data->base;
+	TS_OUT = data->base + 4;
+	
+	//printk(KERN_DEBUG "TS_CTL:%p, TS_OUT:%p\n", TS_CTL, TS_OUT);
+	
+	tmp = readl(TS_CTL);
+	tmp = tmp & 0xfffcffff;	
+	tmp = tmp | 0x00010000;		//11bit adc								
+	writel(tmp, TS_CTL);
+		
+	writel(0x01000000, TS_OUT);		//enable alarm irq
+	
+	for(i=0;i<TRY_TEMP_CNT;i++) {
+		tmp = readl(TS_CTL);
+		tmp = tmp | 0x1;										//enable tsensor
+		writel(tmp, TS_CTL);
+		
+		ready = 0;
+		do{
+			tmp = readl(TS_OUT);
+			ready = tmp & 0x2000000;
+		}while(ready==0);
+		
+		temp_arry[i] = tmp & 0xfff;
+		//printk(KERN_INFO "temp_arry[%d]:%d\n", i, temp_arry[i]);
+		
+		tmp = readl(TS_CTL);
+		tmp = tmp & 0xfffffffe;	//disable tsensor
+		writel(tmp, TS_CTL);
+		writel(0x03000000, TS_OUT);		//clr pending	
+	}
+
+	//sort temp arry
+	for(i=0;i<TRY_TEMP_CNT-1;i++) {
+		for(j=i+1; j<TRY_TEMP_CNT; j++) {
+			if(temp_arry[j] < temp_arry[i]) {
+				tmp = temp_arry[i];
+				temp_arry[i] = temp_arry[j];
+				temp_arry[j] = tmp;
+			}
+		}
+	}
+
+	// discard min & max, then take ther average
+	for(i=1;i<TRY_TEMP_CNT-1;i++) {
+		temp_code += temp_arry[i];
+	}		
+	temp_code = temp_code/(TRY_TEMP_CNT-2);
+	//printk(KERN_INFO "temp_code:%d\n", temp_code);
+	return temp_code;
+}
+
+static int owl_tmu_read(struct owl_tmu_data *data)
+{
+	int temp_code;
+	int temp;
+
+	mutex_lock(&data->lock);
+
+	temp_code = owl_tmu_temp_code_read(data);
+	temp = code_to_temp(data, temp_code);
+
+	mutex_unlock(&data->lock);
+	
+	return temp;
+}
+
+static struct thermal_sensor_conf owl_sensor_conf = {
+	.name			= "owl-thermal",
+	.read_temperature	= (int (*)(void *))owl_tmu_read,
+};
+
+static struct owl_tmu_platform_data atm7095a_default_tmu_data = {
+	.threshold_falling = 10,
+	.threshold = 105,
+	.trigger_levels[0] = 0,
+	.trigger_levels[1] = 10,
+	.trigger_levels[2] = 20,
+	.trigger_level0_en = 1,
+	.trigger_level1_en = 1,
+	.trigger_level2_en = 1,
+	.trigger_level3_en = 0,
+	.gain = 15,
+	.reference_voltage = 7,
+	.cal_type = TYPE_ONE_POINT_TRIMMING,
+	.freq_tab[0] = {
+		.freq_clip_max = 504 * 1000,
+		
+	},
+	.freq_tab[1] = {
+		.freq_clip_max = 504 * 1000,
+		
+	},
+	.freq_tab_count = 2,
+	.type = SOC_ARCH_OWL,
+};
+#define ATM7095A_TMU_DRV_DATA (&atm7095a_default_tmu_data)
+
+#define ATM7095TC_TMU_DRV_DATA (&atm7095a_default_tmu_data)
+
+#ifdef CONFIG_OF
+static const struct of_device_id owl_tmu_match[] = {
+	{
+		.compatible = "actions,atm7059tc-thermal",
+		.data = (void *)ATM7095TC_TMU_DRV_DATA,
+	},
+	{
+		.compatible = "actions,atm7059a-thermal",
+		.data = (void *)ATM7095A_TMU_DRV_DATA,
+	},	
+	{},
+};
+MODULE_DEVICE_TABLE(of, owl_tmu_match);
+#endif
+
+static struct platform_device_id owl_tmu_driver_ids[] = {
+	{
+		.name		= "atm7059tc-tmu",
+		.driver_data    = (kernel_ulong_t)ATM7095TC_TMU_DRV_DATA,
+	},
+	{
+		.name		= "atm7059a-tmu",
+		.driver_data    = (kernel_ulong_t)ATM7095A_TMU_DRV_DATA,
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(platform, owl_tmu_driver_ids);
+
+static inline struct  owl_tmu_platform_data *owl_get_driver_data(
+			struct platform_device *pdev)
+{
+#ifdef CONFIG_OF
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+		match = of_match_node(owl_tmu_match, pdev->dev.of_node);
+		if (!match)
+			return NULL;
+		return (struct owl_tmu_platform_data *) match->data;
+	}
+#endif
+	return (struct owl_tmu_platform_data *)
+			platform_get_device_id(pdev)->driver_data;
+}
+
+/* 
+wait for cpufreq ready
+ */
+static void wait_cpufreq_ready(struct work_struct *work)
+{
+	int ret = 0;
+	int i;
+	struct owl_tmu_data *data;
+	struct cpufreq_frequency_table *table;
+	struct owl_tmu_platform_data *pdata;
+
+	data = (&owl_sensor_conf)->private_data;
+	table = cpufreq_frequency_get_table(0);
+	if(NULL == table)
+	{
+		schedule_delayed_work(&data->wait_cpufreq_ready_work, HZ);
+		printk("--------cpufreq not ready--------\n");
+		return;
+	}
+	pr_notice("++++++++cpufreq ready++++++++\n");
+	/* get thermal freq from freqtable */
+	pdata = data->pdata;
+	pdata->freq_tab[0].freq_clip_max = table[1].frequency;
+	pdata->freq_tab[1].freq_clip_max = table[1].frequency;
+	for (i = 0; i < 2; i++)
+		pr_notice("++++++++pdata->freq_tab[%d].freq_clip_max:%d++++++++\n", i, pdata->freq_tab[i].freq_clip_max);
+
+	ret = owl_register_thermal(&owl_sensor_conf);
+	if (ret) {
+		printk("Failed to register thermal interface\n");
+	}
+	return ;
+}
+
+static int owl_tmu_probe(struct platform_device *pdev)
+{
+	struct owl_tmu_data *data;
+	struct owl_tmu_platform_data *pdata = pdev->dev.platform_data;
+	int ret, i;
+
+	
+
+	if (owl_get_boot_mode() == OWL_BOOT_MODE_UPGRADE) {
+		printk("product process  not need to thmu modules!\n");
+		return -ENODEV;
+	}
+
+	if (!pdata)
+		pdata = owl_get_driver_data(pdev);
+
+		
+	if (!pdata) {
+		dev_err(&pdev->dev, "No platform init data supplied.\n");
+		return -ENODEV;
+	}
+	
+	data = devm_kzalloc(&pdev->dev, sizeof(struct owl_tmu_data),
+					GFP_KERNEL);
+	if (!data) {
+		dev_err(&pdev->dev, "Failed to allocate driver structure\n");
+		return -ENOMEM;
+	}
+
+	data->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	//data->mem->start = 0xb01b00e8;
+	//data->mem->end = 0xb01b00e8 + 0x8;
+	printk("tmu-mem:start=0x%x\n",data->mem->start);
+	data->base = devm_ioremap_resource(&pdev->dev, data->mem);
+	if (IS_ERR(data->base))
+		return PTR_ERR(data->base);
+
+	if (pdata->type == SOC_ARCH_OWL ||
+				pdata->type == SOC_ARCH_OWL_2)
+		data->soc = pdata->type;
+	else {
+		ret = -EINVAL;
+		dev_err(&pdev->dev, "Platform not supported\n");
+		goto err_clk;
+	}
+
+	data->pdata = pdata;
+	platform_set_drvdata(pdev, data);
+	mutex_init(&data->lock);
+
+	ret = owl_tmu_initialize(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to initialize TMU\n");
+		goto err_clk;
+	}
+
+	owl_tmu_control(pdev, true);
+
+	/* Register the sensor with thermal management interface */
+	(&owl_sensor_conf)->private_data = data;
+	owl_sensor_conf.trip_data.trip_count = pdata->trigger_level0_en +
+			pdata->trigger_level1_en + pdata->trigger_level2_en +
+			pdata->trigger_level3_en;
+
+	for (i = 0; i < owl_sensor_conf.trip_data.trip_count; i++)
+		owl_sensor_conf.trip_data.trip_val[i] =
+			pdata->threshold + pdata->trigger_levels[i];
+
+	owl_sensor_conf.trip_data.trigger_falling = pdata->threshold_falling;
+
+	owl_sensor_conf.cooling_data.freq_clip_count =
+						pdata->freq_tab_count;
+	for (i = 0; i < pdata->freq_tab_count; i++) {
+		owl_sensor_conf.cooling_data.freq_data[i].freq_clip_max =
+					pdata->freq_tab[i].freq_clip_max;
+		owl_sensor_conf.cooling_data.freq_data[i].temp_level =
+					pdata->freq_tab[i].temp_level;
+	}
+
+	INIT_DELAYED_WORK(&data->wait_cpufreq_ready_work, wait_cpufreq_ready);
+	schedule_delayed_work(&data->wait_cpufreq_ready_work, HZ);
+
+	return 0;
+err_clk:
+	platform_set_drvdata(pdev, NULL);
+	return ret;
+}
+
+static int owl_tmu_remove(struct platform_device *pdev)
+{
+	owl_tmu_control(pdev, false);
+
+	owl_unregister_thermal();
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int owl_tmu_suspend(struct device *dev)
+{
+	owl_tmu_control(to_platform_device(dev), false);
+
+	return 0;
+}
+
+static int owl_tmu_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	owl_tmu_initialize(pdev);
+	owl_tmu_control(pdev, true);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(owl_tmu_pm,
+			 owl_tmu_suspend, owl_tmu_resume);
+#define OWL_TMU_PM	(&owl_tmu_pm)
+#else
+#define OWL_TMU_PM	NULL
+#endif
+
+static struct platform_driver owl_tmu_driver = {
+	.driver = {
+		.name   = "owl-tmu",
+		.owner  = THIS_MODULE,
+		.pm     = OWL_TMU_PM,
+		.of_match_table = of_match_ptr(owl_tmu_match),
+	},
+	.probe = owl_tmu_probe,
+	.remove	= owl_tmu_remove,
+	.id_table = owl_tmu_driver_ids,
+};
+
+module_platform_driver(owl_tmu_driver);
+
+MODULE_DESCRIPTION("OWL TMU Driver");
+MODULE_AUTHOR("Actions (Zhuhai) Technology Co., Limited");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:owl-tmu");
diff --git a/drivers/thermal/step_wise.c b/drivers/thermal/step_wise.c
old mode 100644
new mode 100755
index ec4ea59..7628de1
--- a/drivers/thermal/step_wise.c
+++ b/drivers/thermal/step_wise.c
@@ -27,6 +27,12 @@
 
 #include "thermal_core.h"
 
+enum throttle_status{
+	THROTTLE_OVER_TRIP_TEMP,
+	THROTTLE_UNDER_TRIP_TEMP,
+	THROTTLE_UNDER_TRIP_FALLING
+};
+
 /*
  * If the temperature is higher than a trip point,
  *    a. if the trend is THERMAL_TREND_RAISING, use higher cooling
@@ -48,7 +54,7 @@
  *       deactivate the thermal instance
  */
 static unsigned long get_target_state(struct thermal_instance *instance,
-				enum thermal_trend trend, bool throttle)
+				enum thermal_trend trend, enum throttle_status throttle)
 {
 	struct thermal_cooling_device *cdev = instance->cdev;
 	unsigned long cur_state;
@@ -78,7 +84,7 @@ static unsigned long get_target_state(struct thermal_instance *instance,
 
 	switch (trend) {
 	case THERMAL_TREND_RAISING:
-		if (throttle) {
+		if (throttle == THROTTLE_OVER_TRIP_TEMP) {
 			next_target = cur_state < instance->upper ?
 				    (cur_state + 1) : instance->upper;
 			if (next_target < instance->lower)
@@ -86,25 +92,30 @@ static unsigned long get_target_state(struct thermal_instance *instance,
 		}
 		break;
 	case THERMAL_TREND_RAISE_FULL:
-		if (throttle)
+		if (throttle == THROTTLE_OVER_TRIP_TEMP)
 			next_target = instance->upper;
 		break;
 	case THERMAL_TREND_DROPPING:
-		if (cur_state <= instance->lower) {
-			if (!throttle)
-				next_target = THERMAL_NO_TARGET;
+		if (cur_state <= (instance->lower+1)) {
+			if (throttle == THROTTLE_UNDER_TRIP_FALLING) {
+				next_target = cur_state != instance->lower ?
+						(cur_state - 1) : -1;   
+			}
 		} else {
-			next_target = cur_state - 1;
-			if (next_target > instance->upper)
-				next_target = instance->upper;
+			if((throttle == THROTTLE_UNDER_TRIP_TEMP) || (throttle == THROTTLE_UNDER_TRIP_FALLING)) {
+				next_target -= 1;
+				if (cur_state > instance->upper)
+					next_target = instance->upper;
+			}
 		}
 		break;
 	case THERMAL_TREND_DROP_FULL:
-		if (cur_state == instance->lower) {
-			if (!throttle)
+		if (throttle == THROTTLE_UNDER_TRIP_FALLING) {
+			if (cur_state == instance->lower)
 				next_target = THERMAL_NO_TARGET;
-		} else
-			next_target = instance->lower;
+			else
+				next_target = instance->lower;
+		}
 		break;
 	default:
 		break;
@@ -130,8 +141,8 @@ static void thermal_zone_trip_update(struct thermal_zone_device *tz, int trip)
 	enum thermal_trip_type trip_type;
 	enum thermal_trend trend;
 	struct thermal_instance *instance;
-	bool throttle = false;
 	int old_target;
+	bool throttle = false;
 
 	if (trip == THERMAL_TRIPS_NONE) {
 		trip_temp = tz->forced_passive;
@@ -147,7 +158,7 @@ static void thermal_zone_trip_update(struct thermal_zone_device *tz, int trip)
 		throttle = true;
 		trace_thermal_zone_trip(tz, trip, trip_type);
 	}
-
+	
 	dev_dbg(&tz->device, "Trip%d[type=%d,temp=%ld]:trend=%d,throttle=%d\n",
 				trip, trip_type, trip_temp, trend, throttle);
 
diff --git a/include/linux/cpu_cooling.h b/include/linux/cpu_cooling.h
old mode 100644
new mode 100755
index bd95527..e0a039c
--- a/include/linux/cpu_cooling.h
+++ b/include/linux/cpu_cooling.h
@@ -29,6 +29,30 @@
 #include <linux/cpumask.h>
 
 #ifdef CONFIG_CPU_THERMAL
+#define CPUFREQ_COOLING_START		0
+#define CPUFREQ_COOLING_STOP		1
+
+/**
+ * cputherm_register_notifier - Register a notifier with cpu cooling interface.
+ * @nb:	struct notifier_block * with callback info.
+ * @list: integer value for which notification is needed. possible values are
+ *	CPUFREQ_COOLING_TYPE and CPUHOTPLUG_COOLING_TYPE.
+ *
+ * This exported function registers a driver with cpu cooling layer. The driver
+ * will be notified when any cpu cooling action is called.
+ */
+int cputherm_register_notifier(struct notifier_block *nb, unsigned int list);
+
+/**
+ * cputherm_unregister_notifier - Un-register a notifier.
+ * @nb:	struct notifier_block * with callback info.
+ * @list: integer value for which notification is needed. values possible are
+ *	CPUFREQ_COOLING_TYPE.
+ *
+ * This exported function un-registers a driver with cpu cooling layer.
+ */
+int cputherm_unregister_notifier(struct notifier_block *nb, unsigned int list);
+
 /**
  * cpufreq_cooling_register - function to create cpufreq cooling device.
  * @clip_cpus: cpumask of cpus where the frequency constraints will happen
diff --git a/include/linux/platform_data/owl_thermal.h b/include/linux/platform_data/owl_thermal.h
new file mode 100755
index 0000000..4e7eff7
--- /dev/null
+++ b/include/linux/platform_data/owl_thermal.h
@@ -0,0 +1,119 @@
+/*
+ * owl_thermal.h - Samsung EXYNOS TMU (Thermal Management Unit)
+ *
+ *  Copyright (C) 2011 Samsung Electronics
+ *  Donggeun Kim <dg77.kim@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LINUX_OWL_THERMAL_H
+#define _LINUX_OWL_THERMAL_H
+#include <linux/cpu_cooling.h>
+
+enum calibration_type {
+	TYPE_ONE_POINT_TRIMMING,
+	TYPE_TWO_POINT_TRIMMING,
+	TYPE_NONE,
+};
+
+enum soc_type {
+	SOC_ARCH_OWL = 1,
+	SOC_ARCH_OWL_2,
+};
+/**
+ * struct freq_clip_table
+ * @freq_clip_max: maximum frequency allowed for this cooling state.
+ * @temp_level: Temperature level at which the temperature clipping will
+ *	happen.
+ * @mask_val: cpumask of the allowed cpu's where the clipping will take place.
+ *
+ * This structure is required to be filled and passed to the
+ * cpufreq_cooling_unregister function.
+ */
+struct freq_clip_table {
+	unsigned int freq_clip_max;
+	unsigned int temp_level;
+	const struct cpumask *mask_val;
+};
+
+/**
+ * struct owl_tmu_platform_data
+ * @threshold: basic temperature for generating interrupt
+ *	       25 <= threshold <= 125 [unit: degree Celsius]
+ * @threshold_falling: differntial value for setting threshold
+ *		       of temperature falling interrupt.
+ * @trigger_levels: array for each interrupt levels
+ *	[unit: degree Celsius]
+ *	0: temperature for trigger_level0 interrupt
+ *	   condition for trigger_level0 interrupt:
+ *		current temperature > threshold + trigger_levels[0]
+ *	1: temperature for trigger_level1 interrupt
+ *	   condition for trigger_level1 interrupt:
+ *		current temperature > threshold + trigger_levels[1]
+ *	2: temperature for trigger_level2 interrupt
+ *	   condition for trigger_level2 interrupt:
+ *		current temperature > threshold + trigger_levels[2]
+ *	3: temperature for trigger_level3 interrupt
+ *	   condition for trigger_level3 interrupt:
+ *		current temperature > threshold + trigger_levels[3]
+ * @trigger_level0_en:
+ *	1 = enable trigger_level0 interrupt,
+ *	0 = disable trigger_level0 interrupt
+ * @trigger_level1_en:
+ *	1 = enable trigger_level1 interrupt,
+ *	0 = disable trigger_level1 interrupt
+ * @trigger_level2_en:
+ *	1 = enable trigger_level2 interrupt,
+ *	0 = disable trigger_level2 interrupt
+ * @trigger_level3_en:
+ *	1 = enable trigger_level3 interrupt,
+ *	0 = disable trigger_level3 interrupt
+ * @gain: gain of amplifier in the positive-TC generator block
+ *	0 <= gain <= 15
+ * @reference_voltage: reference voltage of amplifier
+ *	in the positive-TC generator block
+ *	0 <= reference_voltage <= 31
+ * @noise_cancel_mode: noise cancellation mode
+ *	000, 100, 101, 110 and 111 can be different modes
+ * @type: determines the type of SOC
+ * @efuse_value: platform defined fuse value
+ * @cal_type: calibration type for temperature
+ * @freq_clip_table: Table representing frequency reduction percentage.
+ * @freq_tab_count: Count of the above table as frequency reduction may
+ *	applicable to only some of the trigger levels.
+ *
+ * This structure is required for configuration of owl_tmu driver.
+ */
+struct owl_tmu_platform_data {
+	u8 threshold;
+	u8 threshold_falling;
+	u8 trigger_levels[4];
+	bool trigger_level0_en;
+	bool trigger_level1_en;
+	bool trigger_level2_en;
+	bool trigger_level3_en;
+
+	u8 gain;
+	u8 reference_voltage;
+	u8 noise_cancel_mode;
+	u32 efuse_value;
+
+	enum calibration_type cal_type;
+	enum soc_type type;
+	struct freq_clip_table freq_tab[4];
+	unsigned int freq_tab_count;
+};
+#endif /* _LINUX_OWL_THERMAL_H */
-- 
1.7.5.4

