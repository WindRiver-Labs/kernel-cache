Add the implementations to handle SPFP instruction exceptions
complying with IEEE-754.

Signed-off-by:Ebony Zhu <ebony.zhu@freescale.com>
---
 arch/powerpc/math-emu/efsabs.c   |   16 +++++++++++++
 arch/powerpc/math-emu/efsadd.c   |   36 ++++++++++++++++++++++++++++++
 arch/powerpc/math-emu/efscfd.c   |   37 +++++++++++++++++++++++++++++++
 arch/powerpc/math-emu/efscmpeq.c |   45 ++++++++++++++++++++++++++++++++++++++
 arch/powerpc/math-emu/efscmpgt.c |   45 ++++++++++++++++++++++++++++++++++++++
 arch/powerpc/math-emu/efscmplt.c |   45 ++++++++++++++++++++++++++++++++++++++
 arch/powerpc/math-emu/efsctsf.c  |   29 ++++++++++++++++++++++++
 arch/powerpc/math-emu/efsctsi.c  |   26 ++++++++++++++++++++++
 arch/powerpc/math-emu/efsctsiz.c |   26 ++++++++++++++++++++++
 arch/powerpc/math-emu/efsctuf.c  |   28 +++++++++++++++++++++++
 arch/powerpc/math-emu/efsctui.c  |   26 ++++++++++++++++++++++
 arch/powerpc/math-emu/efsctuiz.c |   26 ++++++++++++++++++++++
 arch/powerpc/math-emu/efsdiv.c   |   36 ++++++++++++++++++++++++++++++
 arch/powerpc/math-emu/efsmul.c   |   38 ++++++++++++++++++++++++++++++++
 arch/powerpc/math-emu/efsnabs.c  |   16 +++++++++++++
 arch/powerpc/math-emu/efsneg.c   |   16 +++++++++++++
 arch/powerpc/math-emu/efssub.c   |   39 ++++++++++++++++++++++++++++++++
 17 files changed, 530 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/math-emu/efsabs.c b/arch/powerpc/math-emu/efsabs.c
new file mode 100644
index 0000000..083cc46
--- /dev/null
+++ b/arch/powerpc/math-emu/efsabs.c
@@ -0,0 +1,16 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+int
+efsabs(u32 *rD, u32 *rA)
+{
+	rD[0] = rA[0] & 0x7fffffff;
+
+#ifdef DEBUG
+	printk("%s: D %p, A %p: ", __FUNCTION__, rD, rA);
+	printk("\n");
+#endif
+
+	return 0;
+}
diff --git a/arch/powerpc/math-emu/efsadd.c b/arch/powerpc/math-emu/efsadd.c
new file mode 100644
index 0000000..a09e216
--- /dev/null
+++ b/arch/powerpc/math-emu/efsadd.c
@@ -0,0 +1,36 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efsadd(void *rD, void *rA, void *rB)
+{
+	FP_DECL_S(A);
+	FP_DECL_S(B);
+	FP_DECL_S(R);
+	int ret = 0;
+
+#ifdef DEBUG
+	printk("%s: %p %p %p\n", __FUNCTION__, rD, rA, rB);
+#endif
+
+	__FP_UNPACK_S(A, rA);
+	__FP_UNPACK_S(B, rB);
+
+#ifdef DEBUG
+	printk("A: %ld %lu %ld (%ld)\n", A_s, A_f, A_e, A_c);
+	printk("B: %ld %lu %ld (%ld)\n", B_s, B_f, B_e, B_c);
+#endif
+
+	FP_ADD_S(R, A, B);
+
+#ifdef DEBUG
+	printk("D: %ld %lu %ld (%ld)\n", R_s, R_f, R_e, R_c);
+#endif
+
+	return (ret | __FP_PACK_S(rD, R));
+}
diff --git a/arch/powerpc/math-emu/efscfd.c b/arch/powerpc/math-emu/efscfd.c
new file mode 100644
index 0000000..f2c2920
--- /dev/null
+++ b/arch/powerpc/math-emu/efscfd.c
@@ -0,0 +1,37 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "double.h"
+#include "single.h"
+
+int
+efscfd(void *rD, u64 *rB)
+{
+	FP_DECL_D(B);
+	FP_DECL_S(R);
+	int ret;
+	u32 tmp;
+	tmp = rB[0] >> 32;
+	rB[0] = rB[0] <<32 | tmp;
+
+#ifdef DEBUG
+	printk("%s: S %p, ea %p\n", __FUNCTION__, rD, rB);
+#endif
+
+	__FP_UNPACK_D(B, rB);
+
+#ifdef DEBUG
+	printk("B: %ld %lu %lu %ld (%ld)\n", B_s, B_f1, B_f0, B_e, B_c);
+#endif
+
+	FP_CONV(S, D, 1, 2, R, B);
+
+#ifdef DEBUG
+	printk("R: %ld %lu %ld (%ld)\n", R_s, R_f, R_e, R_c);
+#endif
+
+	return (ret | __FP_PACK_S(rD, R));
+}
diff --git a/arch/powerpc/math-emu/efscmpeq.c b/arch/powerpc/math-emu/efscmpeq.c
new file mode 100644
index 0000000..8ad0d9d
--- /dev/null
+++ b/arch/powerpc/math-emu/efscmpeq.c
@@ -0,0 +1,45 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efscmpeq(u32 *ccr, int crD, void *rA, void *rB)
+{
+	FP_DECL_S(A);
+	FP_DECL_S(B);
+	long cmp;
+	int ret = 0;
+
+#ifdef DEBUG
+	printk("%s: %p (%08x) %d %p %p\n", __FUNCTION__, ccr, *ccr, crD, rA, rB);
+#endif
+
+	__FP_UNPACK_S(A, rA);
+	__FP_UNPACK_S(B, rB);
+
+#ifdef DEBUG
+	printk("A: %ld %lu %ld (%ld)\n", A_s, A_f, A_e, A_c);
+	printk("B: %ld %lu %ld (%ld)\n", B_s, B_f, B_e, B_c);
+#endif
+
+	FP_CMP_S(cmp, A, B, 2);
+	
+	if (cmp == 0) {
+		cmp = 0x4;
+	} else {
+		cmp = 0;
+	}
+
+	*ccr &= ~(15 << ((7 - crD) << 2));
+	*ccr |= (cmp << ((7 - crD) << 2));
+
+#ifdef DEBUG
+	printk("CR: %08x\n", *ccr);
+#endif
+
+	return ret;
+}
diff --git a/arch/powerpc/math-emu/efscmpgt.c b/arch/powerpc/math-emu/efscmpgt.c
new file mode 100644
index 0000000..95a16f5
--- /dev/null
+++ b/arch/powerpc/math-emu/efscmpgt.c
@@ -0,0 +1,45 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efscmpgt(u32 *ccr, int crD, void *rA, void *rB)
+{
+	FP_DECL_S(A);
+	FP_DECL_S(B);
+	long cmp;
+	int ret = 0;
+
+#ifdef DEBUG
+	printk("%s: %p (%08x) %d %p %p\n", __FUNCTION__, ccr, *ccr, crD, rA, rB);
+#endif
+
+	__FP_UNPACK_S(A, rA);
+	__FP_UNPACK_S(B, rB);
+
+#ifdef DEBUG
+	printk("A: %ld %lu %ld (%ld)\n", A_s, A_f, A_e, A_c);
+	printk("B: %ld %lu %ld (%ld)\n", B_s, B_f, B_e, B_c);
+#endif
+
+	FP_CMP_S(cmp, A, B, 2);
+	
+	if (cmp == 1) {
+		cmp = 0x4;
+	} else {
+		cmp = 0;
+	}
+	
+	*ccr &= ~(15 << ((7 - crD) << 2));
+	*ccr |= (cmp << ((7 - crD) << 2));
+
+#ifdef DEBUG
+	printk("CR: %08x\n", *ccr);
+#endif
+
+	return ret;
+}
diff --git a/arch/powerpc/math-emu/efscmplt.c b/arch/powerpc/math-emu/efscmplt.c
new file mode 100644
index 0000000..dd1154a
--- /dev/null
+++ b/arch/powerpc/math-emu/efscmplt.c
@@ -0,0 +1,45 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efscmplt(u32 *ccr, int crD, void *rA, void *rB)
+{
+	FP_DECL_S(A);
+	FP_DECL_S(B);
+	long cmp;
+	int ret = 0;
+
+#ifdef DEBUG
+	printk("%s: %p (%08x) %d %p %p\n", __FUNCTION__, ccr, *ccr, crD, rA, rB);
+#endif
+
+	__FP_UNPACK_S(A, rA);
+	__FP_UNPACK_S(B, rB);
+
+#ifdef DEBUG
+	printk("A: %ld %lu %ld (%ld)\n", A_s, A_f, A_e, A_c);
+	printk("B: %ld %lu %ld (%ld)\n", B_s, B_f, B_e, B_c);
+#endif
+
+	FP_CMP_S(cmp, A, B, 2);
+	
+	if (cmp == -1) {
+		cmp = 0x4;
+	} else {
+		cmp = 0;
+	}
+	
+	*ccr &= ~(15 << ((7 - crD) << 2));
+	*ccr |= (cmp << ((7 - crD) << 2));
+
+#ifdef DEBUG
+	printk("CR: %08x\n", *ccr);
+#endif
+
+	return ret;
+}
diff --git a/arch/powerpc/math-emu/efsctsf.c b/arch/powerpc/math-emu/efsctsf.c
new file mode 100644
index 0000000..dcbd7ab
--- /dev/null
+++ b/arch/powerpc/math-emu/efsctsf.c
@@ -0,0 +1,29 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efsctsf(u32 *rD, u32 *rB)
+{
+	if (!((rB[0] >> 23) == 0xff && ((rB[0] & 0x7fffff) > 0))) {/* Not an NaN */
+		if (((rB[0] >> 23) & 0xff) == 0 ) { /* rB is Denorm */
+			rD[0] = 0x0;
+		} else if ((rB[0] >> 31) == 0) { /* rB is positive normal */
+			rD[0] = 0x7fffffff;
+		} else { /* rB is negative normal */
+			rD[0] = 0x80000000;
+		}
+	} else { /* rB is NaN */
+		rD[0] = 0x0;
+	}
+#ifdef DEBUG
+	printk("%s: D %p, B %p: ", __FUNCTION__, rD, rB);
+	printk("\n");
+#endif
+
+	return 0;
+}
diff --git a/arch/powerpc/math-emu/efsctsi.c b/arch/powerpc/math-emu/efsctsi.c
new file mode 100644
index 0000000..aa73b95
--- /dev/null
+++ b/arch/powerpc/math-emu/efsctsi.c
@@ -0,0 +1,26 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efsctsi(u32 *rD, void *rB)
+{
+	FP_DECL_S(B);
+	unsigned int r;
+
+	__FP_UNPACK_S(B, rB);
+	_FP_ROUND(1, B);
+	FP_TO_INT_S(r, B, 32, 1);
+	rD[0] = r;
+
+#ifdef DEBUG
+	printk("%s: D %p, B %p: ", __FUNCTION__, rD, rB);
+	printk("\n");
+#endif
+
+	return 0;
+}
diff --git a/arch/powerpc/math-emu/efsctsiz.c b/arch/powerpc/math-emu/efsctsiz.c
new file mode 100644
index 0000000..a849bb4
--- /dev/null
+++ b/arch/powerpc/math-emu/efsctsiz.c
@@ -0,0 +1,26 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efsctsiz(u32 *rD, void *rB)
+{
+	FP_DECL_S(B);
+	unsigned int r;
+
+	__FP_UNPACK_S(B, rB);
+	_FP_ROUND_ZERO(1, B);
+	FP_TO_INT_S(r, B, 32, 1);
+	rD[0] = r;
+
+#ifdef DEBUG
+	printk("%s: D %p, B %p: ", __FUNCTION__, rD, rB);
+	printk("\n");
+#endif
+
+	return 0;
+}
diff --git a/arch/powerpc/math-emu/efsctuf.c b/arch/powerpc/math-emu/efsctuf.c
new file mode 100644
index 0000000..e1bab26
--- /dev/null
+++ b/arch/powerpc/math-emu/efsctuf.c
@@ -0,0 +1,28 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efsctuf(u32 *rD, u32 *rB)
+{
+        if (!((rB[0] >> 23) == 0xff && ((rB[0] & 0x7fffff) > 0 )) /* Not an NaN */
+	    && (rB[0] >> 31) == 0) { /* rB is positive */
+		if (((rB[0] >> 23) & 0xff) == 0 ) { /* rB is Denorm */
+			rD[0] = 0x0;
+		} else { /* rB is normal */
+			rD[0] = 0xffffffff;
+		}
+        } else { /* rB < 0 or rB is NaN */
+		rD[0] = 0x0;
+	}
+#ifdef DEBUG
+	printk("%s: D %p, B %p: ", __FUNCTION__, rD, rB);
+	printk("\n");
+#endif
+
+	return 0;
+}
diff --git a/arch/powerpc/math-emu/efsctui.c b/arch/powerpc/math-emu/efsctui.c
new file mode 100644
index 0000000..b45e4a9
--- /dev/null
+++ b/arch/powerpc/math-emu/efsctui.c
@@ -0,0 +1,26 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efsctui(u32 *rD, void *rB)
+{
+	FP_DECL_S(B);
+	unsigned int r;
+
+	__FP_UNPACK_S(B, rB);
+	_FP_ROUND(1, B);
+	FP_TO_INT_S(r, B, 32, 0);
+	rD[0] = r;
+
+#ifdef DEBUG
+	printk("%s: D %p, B %p: ", __FUNCTION__, rD, rB);
+	printk("\n");
+#endif
+
+	return 0;
+}
diff --git a/arch/powerpc/math-emu/efsctuiz.c b/arch/powerpc/math-emu/efsctuiz.c
new file mode 100644
index 0000000..1df9c2d
--- /dev/null
+++ b/arch/powerpc/math-emu/efsctuiz.c
@@ -0,0 +1,26 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efsctuiz(u32 *rD, void *rB)
+{
+	FP_DECL_S(B);
+	unsigned int r;
+
+	__FP_UNPACK_S(B, rB);
+	_FP_ROUND_ZERO(1, B);
+	FP_TO_INT_S(r, B, 32, 0);
+	rD[0] = r;
+
+#ifdef DEBUG
+	printk("%s: D %p, B %p: ", __FUNCTION__, rD, rB);
+	printk("\n");
+#endif
+
+	return 0;
+}
diff --git a/arch/powerpc/math-emu/efsdiv.c b/arch/powerpc/math-emu/efsdiv.c
new file mode 100644
index 0000000..3d21522
--- /dev/null
+++ b/arch/powerpc/math-emu/efsdiv.c
@@ -0,0 +1,36 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efsdiv(void *rD, void *rA, void *rB)
+{
+	FP_DECL_S(A);
+	FP_DECL_S(B);
+	FP_DECL_S(R);
+	int ret = 0;
+
+#ifdef DEBUG
+	printk("%s: %p %p %p\n", __FUNCTION__, rD, rA, rB);
+#endif
+
+	__FP_UNPACK_S(A, rA);
+	__FP_UNPACK_S(B, rB);
+
+#ifdef DEBUG
+	printk("A: %ld %lu %ld (%ld)\n", A_s, A_f, A_e, A_c);
+	printk("B: %ld %lu %ld (%ld)\n", B_s, B_f, B_e, B_c);
+#endif
+
+	FP_DIV_S(R, A, B);
+
+#ifdef DEBUG
+	printk("D: %ld %lu %ld (%ld)\n", R_s, R_f, R_e, R_c);
+#endif
+
+	return (ret | __FP_PACK_S(rD, R));
+}
diff --git a/arch/powerpc/math-emu/efsmul.c b/arch/powerpc/math-emu/efsmul.c
new file mode 100644
index 0000000..9101399
--- /dev/null
+++ b/arch/powerpc/math-emu/efsmul.c
@@ -0,0 +1,38 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+int
+efsmul(void *rD, void *rA, void *rB)
+{
+	FP_DECL_S(A);
+	FP_DECL_S(B);
+	FP_DECL_S(R);
+	int ret = 0;
+#ifdef DEBUG
+	printk("%s: %p %p %p\n", __FUNCTION__, rD, rA, rB);
+#endif
+
+	__FP_UNPACK_S(A, rA);
+	__FP_UNPACK_S(B, rB);
+
+#ifdef DEBUG
+        printk("A: %ld %lu %ld (%ld) [%08lx %lx]\n",
+               A_s, A_f, A_e, A_c, A_f, A_e + 127);
+        printk("B: %ld %lu %ld (%ld) [%08lx %lx]\n",
+               B_s, B_f, B_e, B_c, B_f, B_e + 127);
+#endif
+	
+	FP_MUL_S(R, A, B);
+
+#ifdef DEBUG
+	printk("D: %ld %lu %ld (%ld) [%08lx %lx]\n",
+	       R_s, R_f, R_e, R_c, R_f, R_e + 127);
+#endif
+
+	return (ret | __FP_PACK_S(rD, R));
+}
+
diff --git a/arch/powerpc/math-emu/efsnabs.c b/arch/powerpc/math-emu/efsnabs.c
new file mode 100644
index 0000000..6db3d86
--- /dev/null
+++ b/arch/powerpc/math-emu/efsnabs.c
@@ -0,0 +1,16 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+int
+efsnabs(u32 *rD, u32 *rA)
+{
+	rD[0] = rA[0] | 0x80000000;
+
+#ifdef DEBUG
+	printk("%s: D %p, A %p: ", __FUNCTION__, rD, rA);
+	printk("\n");
+#endif
+
+	return 0;
+}
diff --git a/arch/powerpc/math-emu/efsneg.c b/arch/powerpc/math-emu/efsneg.c
new file mode 100644
index 0000000..f4abc86
--- /dev/null
+++ b/arch/powerpc/math-emu/efsneg.c
@@ -0,0 +1,16 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+int
+efsneg(u32 *rD, u32 *rA)
+{
+	rD[0] = rA[0] ^ 0x80000000;
+
+#ifdef DEBUG
+	printk("%s: D %p, A %p: ", __FUNCTION__, rD, rA);
+	printk("\n");
+#endif
+
+	return 0;
+}
diff --git a/arch/powerpc/math-emu/efssub.c b/arch/powerpc/math-emu/efssub.c
new file mode 100644
index 0000000..55bec0a
--- /dev/null
+++ b/arch/powerpc/math-emu/efssub.c
@@ -0,0 +1,39 @@
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+
+#include "spe.h"
+#include "soft-fp.h"
+#include "single.h"
+
+int
+efssub(void *rD, void *rA, void *rB)
+{
+	FP_DECL_S(A);
+	FP_DECL_S(B);
+	FP_DECL_S(R);
+	int ret = 0;
+
+#ifdef DEBUG
+	printk("%s: %p %p %p\n", __FUNCTION__, rD, rA, rB);
+#endif
+
+	__FP_UNPACK_S(A, rA);
+	__FP_UNPACK_S(B, rB);
+
+#ifdef DEBUG
+	printk("A: %ld %lu %ld (%ld)\n", A_s, A_f, A_e, A_c);
+	printk("B: %ld %lu %ld (%ld)\n", B_s, B_f, B_e, B_c);
+#endif
+
+	if (B_c != FP_CLS_NAN)
+		B_s ^= 1;
+
+	FP_ADD_S(R, A, B);
+
+#ifdef DEBUG
+	printk("D: %ld %lu %ld (%ld)\n", R_s, R_f, R_e, R_c);
+#endif
+
+	return (ret | __FP_PACK_S(rD, R));
+}
