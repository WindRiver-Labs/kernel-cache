From 78e87a8c42ac94dc42be6ce57fbe4c0be8461a90 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 24 Jun 2010 13:58:14 -0700
Subject: [PATCH] grsec: update PaX to pax-linux-2.6.33.5-test25 patch

Significant changes are x86-centric , most of them related to UDEREF
implementation on x86_64, including PER_CPU_PGD (enabled when UDEREF
is used). Apart from that, the usual pax modifications of adding const,
do..while(0) around macros, type fixes, etc.

Also, there was the issue of VM_PAGEEXEC overloading the VM_MERGEABLE
flag. The latest PAX patch redefines it as VM_SAO, which is only used
by PPC64. However, our kernel uses that flag for VM_REVOKED. Instead,
use VM_MAPPED_COPY, which is only used by nommu setups. This is only
relevant to x86_32 targets.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/x86/boot/memory.c                   |    2 +-
 arch/x86/boot/video.c                    |    2 +-
 arch/x86/include/asm/cacheflush.h        |    4 +-
 arch/x86/include/asm/desc.h              |   12 +++---
 arch/x86/include/asm/mc146818rtc.h       |    4 +-
 arch/x86/include/asm/pgtable.h           |    5 ++
 arch/x86/include/asm/pgtable_64.h        |    4 --
 arch/x86/include/asm/pgtable_64_types.h  |    2 +
 arch/x86/include/asm/uaccess.h           |    1 -
 arch/x86/kernel/entry_32.S               |    6 +-
 arch/x86/kernel/entry_64.S               |   60 +++++++++++++++++++----------
 arch/x86/kernel/head64.c                 |    6 ---
 arch/x86/kernel/head_32.S                |    3 +-
 arch/x86/kernel/kprobes.c                |    2 +
 arch/x86/kernel/machine_kexec_64.c       |    6 ---
 arch/x86/kernel/paravirt.c               |    6 +-
 arch/x86/kvm/emulate.c                   |    4 +-
 arch/x86/kvm/lapic.c                     |    2 +-
 arch/x86/kvm/vmx.c                       |    2 +-
 arch/x86/mm/fault.c                      |   35 +++++++++++++----
 arch/x86/mm/init.c                       |    6 ---
 arch/x86/mm/init_64.c                    |    1 -
 arch/x86/mm/pageattr.c                   |   27 +++++++++++--
 arch/x86/mm/pgtable.c                    |   22 ++++-------
 arch/x86/mm/setup_nx.c                   |    2 +
 arch/x86/xen/enlighten.c                 |   12 +++++-
 arch/x86/xen/xen-head.S                  |   11 +++++
 drivers/acpi/power_meter.c               |    2 -
 drivers/acpi/proc.c                      |   17 +++-----
 drivers/char/hpet.c                      |    9 +++-
 drivers/firewire/core-cdev.c             |    3 +-
 drivers/gpu/drm/radeon/radeon_display.c  |    2 +-
 drivers/gpu/drm/ttm/ttm_bo.c             |    2 +-
 drivers/hid/usbhid/hiddev.c              |    2 +-
 drivers/message/fusion/mptdebug.h        |    2 +-
 drivers/net/wireless/iwlwifi/iwl-debug.h |    4 +-
 drivers/net/wireless/rndis_wlan.c        |    2 +-
 drivers/scsi/mpt2sas/mpt2sas_debug.h     |    2 +-
 drivers/staging/hv/Hv.c                  |    2 +-
 drivers/video/fbcmap.c                   |    3 +-
 fs/block_dev.c                           |    2 +-
 fs/cachefiles/bind.c                     |    6 +--
 fs/cachefiles/daemon.c                   |    6 +-
 fs/ext2/xattr.c                          |    4 +-
 fs/ext4/xattr.c                          |    4 +-
 fs/udf/udfdecl.h                         |    2 +-
 include/acpi/acoutput.h                  |    4 +-
 include/linux/mm.h                       |   11 +++--
 include/linux/vmalloc.h                  |    2 +-
 init/main.c                              |    4 +-
 kernel/kprobes.c                         |    4 +-
 kernel/lockdep_proc.c                    |    2 +-
 kernel/signal.c                          |    8 ++--
 mm/memory.c                              |    8 ++++
 mm/mprotect.c                            |    6 +++
 mm/vmalloc.c                             |   10 ++--
 net/8021q/vlan.c                         |    3 +-
 net/wireless/wext-core.c                 |    3 +-
 58 files changed, 226 insertions(+), 164 deletions(-)

diff --git a/arch/x86/boot/memory.c b/arch/x86/boot/memory.c
index cae3feb..ff8ff2a 100644
--- a/arch/x86/boot/memory.c
+++ b/arch/x86/boot/memory.c
@@ -19,7 +19,7 @@
 
 static int detect_memory_e820(void)
 {
-	int count = 0;
+	unsigned int count = 0;
 	struct biosregs ireg, oreg;
 	struct e820entry *desc = boot_params.e820_map;
 	static struct e820entry buf; /* static so it is zeroed */
diff --git a/arch/x86/boot/video.c b/arch/x86/boot/video.c
index 43eda28..dd4c75a 100644
--- a/arch/x86/boot/video.c
+++ b/arch/x86/boot/video.c
@@ -97,7 +97,7 @@ static unsigned int get_entry(void)
 {
 	char entry_buf[4];
 	int i, len = 0;
-	int key;
+	unsigned int key;
 	unsigned int v;
 
 	do {
diff --git a/arch/x86/include/asm/cacheflush.h b/arch/x86/include/asm/cacheflush.h
index 634c40a..86227d0 100644
--- a/arch/x86/include/asm/cacheflush.h
+++ b/arch/x86/include/asm/cacheflush.h
@@ -61,7 +61,7 @@ PAGEFLAG(WC, WC)
 static inline unsigned long get_page_memtype(struct page *pg)
 {
 	if (!PageUncached(pg) && !PageWC(pg))
-		return -1;
+		return ~0UL;
 	else if (!PageUncached(pg) && PageWC(pg))
 		return _PAGE_CACHE_WC;
 	else if (PageUncached(pg) && !PageWC(pg))
@@ -86,7 +86,7 @@ static inline void set_page_memtype(struct page *pg, unsigned long memtype)
 		SetPageWC(pg);
 		break;
 	default:
-	case -1:
+	case ~0UL:
 		ClearPageUncached(pg);
 		ClearPageWC(pg);
 		break;
diff --git a/arch/x86/include/asm/desc.h b/arch/x86/include/asm/desc.h
index cab912d..0a7d66d 100644
--- a/arch/x86/include/asm/desc.h
+++ b/arch/x86/include/asm/desc.h
@@ -319,7 +319,7 @@ static inline void set_desc_limit(struct desc_struct *desc, unsigned long limit)
 	desc->limit = (limit >> 16) & 0xf;
 }
 
-static inline void _set_gate(int gate, unsigned type, void *addr,
+static inline void _set_gate(int gate, unsigned type, const void *addr,
 			     unsigned dpl, unsigned ist, unsigned seg)
 {
 	gate_desc s;
@@ -337,7 +337,7 @@ static inline void _set_gate(int gate, unsigned type, void *addr,
  * Pentium F0 0F bugfix can have resulted in the mapped
  * IDT being write-protected.
  */
-static inline void set_intr_gate(unsigned int n, void *addr)
+static inline void set_intr_gate(unsigned int n, const void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0, 0, __KERNEL_CS);
@@ -366,13 +366,13 @@ static inline void alloc_intr_gate(unsigned int n, void *addr)
 /*
  * This routine sets up an interrupt gate at directory privilege level 3.
  */
-static inline void set_system_intr_gate(unsigned int n, void *addr)
+static inline void set_system_intr_gate(unsigned int n, const void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0x3, 0, __KERNEL_CS);
 }
 
-static inline void set_system_trap_gate(unsigned int n, void *addr)
+static inline void set_system_trap_gate(unsigned int n, const void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_TRAP, addr, 0x3, 0, __KERNEL_CS);
@@ -390,13 +390,13 @@ static inline void set_task_gate(unsigned int n, unsigned int gdt_entry)
 	_set_gate(n, GATE_TASK, (void *)0, 0, 0, (gdt_entry<<3));
 }
 
-static inline void set_intr_gate_ist(int n, void *addr, unsigned ist)
+static inline void set_intr_gate_ist(int n, const void *addr, unsigned ist)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0, ist, __KERNEL_CS);
 }
 
-static inline void set_system_intr_gate_ist(int n, void *addr, unsigned ist)
+static inline void set_system_intr_gate_ist(int n, const void *addr, unsigned ist)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0x3, ist, __KERNEL_CS);
diff --git a/arch/x86/include/asm/mc146818rtc.h b/arch/x86/include/asm/mc146818rtc.h
index 01fdf56..2b0f2bc 100644
--- a/arch/x86/include/asm/mc146818rtc.h
+++ b/arch/x86/include/asm/mc146818rtc.h
@@ -81,8 +81,8 @@ static inline unsigned char current_lock_cmos_reg(void)
 #else
 #define lock_cmos_prefix(reg) do {} while (0)
 #define lock_cmos_suffix(reg) do {} while (0)
-#define lock_cmos(reg)
-#define unlock_cmos()
+#define lock_cmos(reg)	do {} while (0)
+#define unlock_cmos()	do {} while (0)
 #define do_i_have_lock_cmos() 0
 #define current_lock_cmos_reg() 0
 #endif
diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
index 1efa6d2..4eab179 100644
--- a/arch/x86/include/asm/pgtable.h
+++ b/arch/x86/include/asm/pgtable.h
@@ -714,7 +714,12 @@ static inline void clone_pgd_range(pgd_t *dst, const pgd_t *src, int count)
 
 #ifdef CONFIG_PAX_PER_CPU_PGD
 extern void __clone_user_pgds(pgd_t *dst, const pgd_t *src, int count);
+#endif
+
+#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
 extern void __shadow_user_pgds(pgd_t *dst, const pgd_t *src, int count);
+#else
+static inline void __shadow_user_pgds(pgd_t *dst, const pgd_t *src, int count) {}
 #endif
 
 #include <asm-generic/pgtable.h>
diff --git a/arch/x86/include/asm/pgtable_64.h b/arch/x86/include/asm/pgtable_64.h
index f501853..7ab9c31 100644
--- a/arch/x86/include/asm/pgtable_64.h
+++ b/arch/x86/include/asm/pgtable_64.h
@@ -106,11 +106,7 @@ static inline void native_set_pgd(pgd_t *pgdp, pgd_t pgd)
 
 static inline void native_pgd_clear(pgd_t *pgd)
 {
-
-#ifndef CONFIG_PAX_PER_CPU_PGD
 	native_set_pgd(pgd, native_make_pgd(0));
-#endif
-
 }
 
 /*
diff --git a/arch/x86/include/asm/pgtable_64_types.h b/arch/x86/include/asm/pgtable_64_types.h
index 766ea16..7cb721d 100644
--- a/arch/x86/include/asm/pgtable_64_types.h
+++ b/arch/x86/include/asm/pgtable_64_types.h
@@ -59,5 +59,7 @@ typedef struct { pteval_t pte; } pte_t;
 #define MODULES_VADDR    _AC(0xffffffffa0000000, UL)
 #define MODULES_END      _AC(0xffffffffff000000, UL)
 #define MODULES_LEN   (MODULES_END - MODULES_VADDR)
+#define MODULES_EXEC_VADDR MODULES_VADDR
+#define MODULES_EXEC_END MODULES_END
 
 #endif /* _ASM_X86_PGTABLE_64_DEFS_H */
diff --git a/arch/x86/include/asm/uaccess.h b/arch/x86/include/asm/uaccess.h
index 1572767..921e6ca 100644
--- a/arch/x86/include/asm/uaccess.h
+++ b/arch/x86/include/asm/uaccess.h
@@ -12,7 +12,6 @@
 #include <linux/slab.h>
 #include <asm/asm.h>
 #include <asm/page.h>
-#include <asm/segment.h>
 
 #define VERIFY_READ 0
 #define VERIFY_WRITE 1
diff --git a/arch/x86/kernel/entry_32.S b/arch/x86/kernel/entry_32.S
index 6511348..0b373c8 100644
--- a/arch/x86/kernel/entry_32.S
+++ b/arch/x86/kernel/entry_32.S
@@ -1456,9 +1456,6 @@ error_code:
 	movl %ecx, %fs
 	UNWIND_ESPFIX_STACK
 	GS_TO_REG %ecx
-
-	PAX_ENTER_KERNEL
-
 	movl PT_GS(%esp), %edi		# get the function address
 	movl PT_ORIG_EAX(%esp), %edx	# get the error code
 	movl $-1, PT_ORIG_EAX(%esp)	# no syscall to restart
@@ -1467,6 +1464,9 @@ error_code:
 	movl $(__KERNEL_DS), %ecx
 	movl %ecx, %ds
 	movl %ecx, %es
+
+	PAX_ENTER_KERNEL
+
 	TRACE_IRQS_OFF
 	movl %esp,%eax			# pt_regs pointer
 	call *%edi
diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S
index 7661f1b..1600dd9 100644
--- a/arch/x86/kernel/entry_64.S
+++ b/arch/x86/kernel/entry_64.S
@@ -523,7 +523,7 @@ ENTRY(save_args)
 	 */
 	movq %rbp, 8(%rsp)
 	leaq 16(%rsp), %rbp		/* mov %rsp, %rbp */
-	testl $3, CS(%rdi)
+	testb $3, CS(%rdi)
 	je 1f
 	SWAPGS
 	/*
@@ -617,7 +617,7 @@ ENTRY(ret_from_fork)
 
 	RESTORE_REST
 
-	testl $3, CS-ARGOFFSET(%rsp)		# from kernel_thread?
+	testb $3, CS-ARGOFFSET(%rsp)		# from kernel_thread?
 	je   int_ret_from_sys_call
 
 	testl $_TIF_IA32, TI_flags(%rcx)	# 32-bit compat task needs IRET
@@ -851,7 +851,7 @@ tracesys_done:
 GLOBAL(int_ret_from_sys_call)
 	DISABLE_INTERRUPTS(CLBR_NONE)
 	TRACE_IRQS_OFF
-	testl $3,CS-ARGOFFSET(%rsp)
+	testb $3,CS-ARGOFFSET(%rsp)
 	je retint_restore_args
 	movl $_TIF_ALLWORK_MASK,%edi
 	/* edi:	mask to check */
@@ -1045,15 +1045,16 @@ END(interrupt)
 	call save_args
 	PARTIAL_FRAME 0
 #ifdef CONFIG_PAX_MEMORY_UDEREF
-	testl $3, CS(%rdi)
+	testb $3, CS(%rdi)
 	jnz 1f
 	call pax_enter_kernel
 	jmp 2f
 1:	call pax_enter_kernel_user
+2:
 #else
 	call pax_enter_kernel
 #endif
-2:	call \func
+	call \func
 	.endm
 
 /*
@@ -1079,7 +1080,7 @@ ret_from_intr:
 	CFI_ADJUST_CFA_OFFSET	-8
 exit_intr:
 	GET_THREAD_INFO(%rcx)
-	testl $3,CS-ARGOFFSET(%rsp)
+	testb $3,CS-ARGOFFSET(%rsp)
 	je retint_kernel
 
 	/* Interrupt came from user space */
@@ -1321,15 +1322,16 @@ ENTRY(\sym)
 	call error_entry
 	DEFAULT_FRAME 0
 #ifdef CONFIG_PAX_MEMORY_UDEREF
-	testl $3, CS(%rsp)
+	testb $3, CS(%rsp)
 	jnz 1f
 	call pax_enter_kernel
 	jmp 2f
 1:	call pax_enter_kernel_user
+2:
 #else
 	call pax_enter_kernel
 #endif
-2:	movq %rsp,%rdi		/* pt_regs pointer */
+	movq %rsp,%rdi		/* pt_regs pointer */
 	xorl %esi,%esi		/* no error code */
 	call \do_sym
 	jmp error_exit		/* %ebx: no swapgs flag */
@@ -1347,15 +1349,16 @@ ENTRY(\sym)
 	call save_paranoid
 	TRACE_IRQS_OFF
 #ifdef CONFIG_PAX_MEMORY_UDEREF
-	testl $3, CS(%rsp)
+	testb $3, CS(%rsp)
 	jnz 1f
 	call pax_enter_kernel
 	jmp 2f
 1:	call pax_enter_kernel_user
+2:
 #else
 	call pax_enter_kernel
 #endif
-2:	movq %rsp,%rdi		/* pt_regs pointer */
+	movq %rsp,%rdi		/* pt_regs pointer */
 	xorl %esi,%esi		/* no error code */
 	call \do_sym
 	jmp paranoid_exit	/* %ebx: no swapgs flag */
@@ -1373,15 +1376,16 @@ ENTRY(\sym)
 	call save_paranoid
 	TRACE_IRQS_OFF
 #ifdef CONFIG_PAX_MEMORY_UDEREF
-	testl $3, CS(%rsp)
+	testb $3, CS(%rsp)
 	jnz 1f
 	call pax_enter_kernel
 	jmp 2f
 1:	call pax_enter_kernel_user
+2:
 #else
 	call pax_enter_kernel
 #endif
-2:	movq %rsp,%rdi		/* pt_regs pointer */
+	movq %rsp,%rdi		/* pt_regs pointer */
 	xorl %esi,%esi		/* no error code */
 #ifdef CONFIG_SMP
 	imul $TSS_size, PER_CPU_VAR(cpu_number), %r12d
@@ -1406,15 +1410,16 @@ ENTRY(\sym)
 	call error_entry
 	DEFAULT_FRAME 0
 #ifdef CONFIG_PAX_MEMORY_UDEREF
-	testl $3, CS(%rsp)
+	testb $3, CS(%rsp)
 	jnz 1f
 	call pax_enter_kernel
 	jmp 2f
 1:	call pax_enter_kernel_user
+2:
 #else
 	call pax_enter_kernel
 #endif
-2:	movq %rsp,%rdi			/* pt_regs pointer */
+	movq %rsp,%rdi			/* pt_regs pointer */
 	movq ORIG_RAX(%rsp),%rsi	/* get error code */
 	movq $-1,ORIG_RAX(%rsp)		/* no syscall to restart */
 	call \do_sym
@@ -1434,15 +1439,16 @@ ENTRY(\sym)
 	DEFAULT_FRAME 0
 	TRACE_IRQS_OFF
 #ifdef CONFIG_PAX_MEMORY_UDEREF
-	testl $3, CS(%rsp)
+	testb $3, CS(%rsp)
 	jnz 1f
 	call pax_enter_kernel
 	jmp 2f
 1:	call pax_enter_kernel_user
+2:
 #else
 	call pax_enter_kernel
 #endif
-2:	movq %rsp,%rdi			/* pt_regs pointer */
+	movq %rsp,%rdi			/* pt_regs pointer */
 	movq ORIG_RAX(%rsp),%rsi	/* get error code */
 	movq $-1,ORIG_RAX(%rsp)		/* no syscall to restart */
 	call \do_sym
@@ -1700,9 +1706,21 @@ ENTRY(paranoid_exit)
 	TRACE_IRQS_OFF
 	testl %ebx,%ebx				/* swapgs needed? */
 	jnz paranoid_restore
-	testl $3,CS(%rsp)
+	testb $3,CS(%rsp)
 	jnz   paranoid_userspace
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	call pax_exit_kernel
+	TRACE_IRQS_IRETQ 0
+	SWAPGS_UNSAFE_STACK
+	RESTORE_ALL 8
+	jmp irq_return
+#endif
 paranoid_swapgs:
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	call pax_exit_kernel_user
+#else
+	call pax_exit_kernel
+#endif
 	call pax_exit_kernel
 	TRACE_IRQS_IRETQ 0
 	SWAPGS_UNSAFE_STACK
@@ -1773,7 +1791,7 @@ ENTRY(error_entry)
 	movq_cfi r14, R14+8
 	movq_cfi r15, R15+8
 	xorl %ebx,%ebx
-	testl $3,CS+8(%rsp)
+	testb $3,CS+8(%rsp)
 	je error_kernelspace
 error_swapgs:
 	SWAPGS
@@ -1838,15 +1856,15 @@ ENTRY(nmi)
 	call save_paranoid
 	DEFAULT_FRAME 0
 #ifdef CONFIG_PAX_MEMORY_UDEREF
-	testl $3, CS(%rsp)
+	testb $3, CS(%rsp)
 	jnz 1f
 	call pax_enter_kernel
 	jmp 2f
 1:	call pax_enter_kernel_user
+2:
 #else
 	call pax_enter_kernel
 #endif
-2:
 	/* paranoidentry do_nmi, 0; without TRACE_IRQS_OFF */
 	movq %rsp,%rdi
 	movq $-1,%rsi
@@ -1857,7 +1875,7 @@ ENTRY(nmi)
 	DISABLE_INTERRUPTS(CLBR_NONE)
 	testl %ebx,%ebx				/* swapgs needed? */
 	jnz nmi_restore
-	testl $3,CS(%rsp)
+	testb $3,CS(%rsp)
 	jnz nmi_userspace
 nmi_swapgs:
 	SWAPGS_UNSAFE_STACK
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index b5bd11e..3a01ee7 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -29,13 +29,7 @@
 static void __init zap_identity_mappings(void)
 {
 	pgd_t *pgd = pgd_offset_k(0UL);
-
-#ifdef CONFIG_PAX_PER_CPU_PGD
-	set_pgd(pgd, native_make_pgd(0));
-#else
 	pgd_clear(pgd);
-#endif
-
 	__flush_tlb_all();
 }
 
diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S
index b8a3916..e86e3f6 100644
--- a/arch/x86/kernel/head_32.S
+++ b/arch/x86/kernel/head_32.S
@@ -21,7 +21,6 @@
 #include <asm/msr-index.h>
 #include <asm/cpufeature.h>
 #include <asm/percpu.h>
-#include <asm/msr-index.h>
 
 /* Physical address */
 #define pa(X) ((X) - __PAGE_OFFSET)
@@ -747,7 +746,7 @@ ENTRY(idt_table)
 #ifdef CONFIG_PAX_PER_CPU_PGD
 ENTRY(cpu_pgd)
 	.rept NR_CPUS
-	.fill	512,8,0
+	.fill	4,8,0
 	.endr
 #endif
 
diff --git a/arch/x86/kernel/kprobes.c b/arch/x86/kernel/kprobes.c
index 161a30d..5551fea 100644
--- a/arch/x86/kernel/kprobes.c
+++ b/arch/x86/kernel/kprobes.c
@@ -341,7 +341,9 @@ static int __kprobes __copy_instruction(u8 *dest, u8 *src, int recover)
 			  (u8 *) dest;
 		BUG_ON((s64) (s32) newdisp != newdisp); /* Sanity check.  */
 		disp = (u8 *) dest + insn_offset_displacement(&insn);
+		pax_open_kernel();
 		*(s32 *) disp = (s32) newdisp;
+		pax_close_kernel();
 	}
 #endif
 	return insn.length;
diff --git a/arch/x86/kernel/machine_kexec_64.c b/arch/x86/kernel/machine_kexec_64.c
index 5bba86b..035c8c5 100644
--- a/arch/x86/kernel/machine_kexec_64.c
+++ b/arch/x86/kernel/machine_kexec_64.c
@@ -128,13 +128,7 @@ static int init_level4_page(struct kimage *image, pgd_t *level4p,
 	}
 	/* clear the unused entries */
 	while (addr < end_addr) {
-
-#ifdef CONFIG_PAX_PER_CPU_PGD
-		set_pgd(level4p++, native_make_pgd(0));
-#else
 		pgd_clear(level4p++);
-#endif
-
 		addr += PGDIR_SIZE;
 	}
 out:
diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c
index dbfc019..251c605 100644
--- a/arch/x86/kernel/paravirt.c
+++ b/arch/x86/kernel/paravirt.c
@@ -145,14 +145,14 @@ unsigned paravirt_patch_default(u8 type, u16 clobbers, void *insnbuf,
 	if (opfunc == NULL)
 		/* If there's no function, patch it with a ud2a (BUG) */
 		ret = paravirt_patch_insns(insnbuf, len, ud2a, ud2a+sizeof(ud2a));
-	else if (opfunc == _paravirt_nop)
+	else if (opfunc == (void *)_paravirt_nop)
 		/* If the operation is a nop, then nop the callsite */
 		ret = paravirt_patch_nop();
 
 	/* identity functions just return their single argument */
-	else if (opfunc == _paravirt_ident_32)
+	else if (opfunc == (void *)_paravirt_ident_32)
 		ret = paravirt_patch_ident_32(insnbuf, len);
-	else if (opfunc == _paravirt_ident_64)
+	else if (opfunc == (void *)_paravirt_ident_64)
 		ret = paravirt_patch_ident_64(insnbuf, len);
 
 	else if (type == PARAVIRT_PATCH(pv_cpu_ops.iret) ||
diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index e79638a..6126b1b 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -84,8 +84,8 @@
 #define Src2CL      (1<<29)
 #define Src2ImmByte (2<<29)
 #define Src2One     (3<<29)
-#define Src2Imm16   (4<<29)
-#define Src2Mask    (7<<29)
+#define Src2Imm16   (4U<<29)
+#define Src2Mask    (7U<<29)
 
 enum {
 	Group1_80, Group1_81, Group1_82, Group1_83,
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 1eb7a4a..66513e0 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -52,7 +52,7 @@
 #define APIC_BUS_CYCLE_NS 1
 
 /* #define apic_debug(fmt,arg...) printk(KERN_WARNING fmt,##arg) */
-#define apic_debug(fmt, arg...)
+#define apic_debug(fmt, arg...) do {} while (0)
 
 #define APIC_LVT_NUM			6
 /* 14 is the version for Xeon and Pentium 8.4.8*/
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 8468326..43e2689 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -3910,7 +3910,7 @@ static void vmx_vcpu_run(struct kvm_vcpu *vcpu)
 #endif
 
 	      : "cc", "memory"
-		, R"bx", R"di", R"si"
+		, R"ax", R"bx", R"di", R"si"
 #ifdef CONFIG_X86_64
 		, "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
 #endif
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 4f8f885..4add77a 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -264,11 +264,24 @@ void vmalloc_sync_all(void)
 	     address += PMD_SIZE) {
 
 		unsigned long flags;
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		unsigned long cpu;
+#else
 		struct page *page;
+#endif
 
 		spin_lock_irqsave(&pgd_lock, flags);
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		for (cpu = 0; cpu < NR_CPUS; ++cpu) {
+			pgd_t *pgd = get_cpu_pgd(cpu);
+#else
 		list_for_each_entry(page, &pgd_list, lru) {
-			if (!vmalloc_sync_one(page_address(page), address))
+			pgd_t *pgd = page_address(page);
+#endif
+
+			if (!vmalloc_sync_one(pgd, address))
 				break;
 		}
 		spin_unlock_irqrestore(&pgd_lock, flags);
@@ -297,6 +310,10 @@ static noinline __kprobes int vmalloc_fault(unsigned long address)
 	 * Do _not_ use "current" here. We might be inside
 	 * an interrupt in the middle of a task switch..
 	 */
+#ifdef CONFIG_PAX_PER_CPU_PGD
+	BUG_ON(__pa(get_cpu_pgd(smp_processor_id())) !=
+		(pgd_paddr & PHYSICAL_PAGE_MASK));
+#endif
 	pgd_paddr = read_cr3();
 	pmd_k = vmalloc_sync_one(__va(pgd_paddr), address);
 	if (!pmd_k)
@@ -1194,14 +1211,16 @@ do_page_fault(struct pt_regs *regs, unsigned long error_code)
 	unsigned long address = read_cr2();
 
 #if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
-	if (!user_mode(regs)) {
+	if (!user_mode(regs) && address < 2 * PAX_USER_SHADOW_BASE) {
+		if (!search_exception_tables(regs->ip)) {
+			bad_area_nosemaphore(regs, error_code, address);
+			return;
+		}
 		if (address < PAX_USER_SHADOW_BASE) {
-			if (search_exception_tables(regs->ip)) {
-				printk(KERN_ERR "PAX: please report this to pageexec@freemail.hu\n");
-				printk(KERN_ERR "PAX: faulting IP: %pS\n", (void *)regs->ip);
-				show_trace_log_lvl(NULL, NULL, (void *)regs->sp, regs->bp, KERN_ERR);
-			}
-		} else if (address < 2 * PAX_USER_SHADOW_BASE)
+			printk(KERN_ERR "PAX: please report this to pageexec@freemail.hu\n");
+			printk(KERN_ERR "PAX: faulting IP: %pS\n", (void *)regs->ip);
+			show_trace_log_lvl(NULL, NULL, (void *)regs->sp, regs->bp, KERN_ERR);
+		} else
 			address -= PAX_USER_SHADOW_BASE;
 	}
 #endif
diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c
index 1363ed4..9a1b393 100644
--- a/arch/x86/mm/init.c
+++ b/arch/x86/mm/init.c
@@ -417,12 +417,6 @@ void free_initmem(void)
 */
 #ifdef CONFIG_X86_PAE
 	set_memory_nx(PFN_ALIGN(__init_begin), (PFN_ALIGN(__init_end) - PFN_ALIGN(__init_begin)) >> PAGE_SHIFT);
-	for (addr = (unsigned long)&__init_begin; addr < (unsigned long)&__init_end; addr += PMD_SIZE) {
-		pgd = pgd_offset_k(addr);
-		pud = pud_offset(pgd, addr);
-		pmd = pmd_offset(pud, addr);
-		set_pmd(pmd, __pmd(pmd_val(*pmd) | (_PAGE_NX & __supported_pte_mask)));
-	}
 #endif
 
 #ifdef CONFIG_MODULES
diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c
index 342944d..94a8b29 100644
--- a/arch/x86/mm/init_64.c
+++ b/arch/x86/mm/init_64.c
@@ -50,7 +50,6 @@
 #include <asm/numa.h>
 #include <asm/cacheflush.h>
 #include <asm/init.h>
-#include <linux/bootmem.h>
 
 static unsigned long dma_reserve __initdata;
 
diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c
index 8a4e091..6725135 100644
--- a/arch/x86/mm/pageattr.c
+++ b/arch/x86/mm/pageattr.c
@@ -261,7 +261,7 @@ static inline pgprot_t static_protections(pgprot_t prot, unsigned long address,
 	 * PCI BIOS based config access (CONFIG_PCI_GOBIOS) support.
 	 */
 	if (within(pfn, BIOS_BEGIN >> PAGE_SHIFT, BIOS_END >> PAGE_SHIFT))
-		pgprot_val(forbidden) |= _PAGE_NX;
+		pgprot_val(forbidden) |= _PAGE_NX & __supported_pte_mask;
 
 	/*
 	 * The kernel text needs to be executable for obvious reasons
@@ -269,7 +269,7 @@ static inline pgprot_t static_protections(pgprot_t prot, unsigned long address,
 	 * 64bit we do not enforce !NX on the low mapping
 	 */
 	if (within(address, ktla_ktva((unsigned long)_text), ktla_ktva((unsigned long)_etext)))
-		pgprot_val(forbidden) |= _PAGE_NX;
+		pgprot_val(forbidden) |= _PAGE_NX & __supported_pte_mask;
 
 #ifdef CONFIG_DEBUG_RODATA
 	/*
@@ -318,6 +318,13 @@ static inline pgprot_t static_protections(pgprot_t prot, unsigned long address,
 	}
 #endif
 
+#ifdef CONFIG_PAX_KERNEXEC
+	if (within(pfn, __pa((unsigned long)&_text), __pa((unsigned long)&_sdata))) {
+		pgprot_val(forbidden) |= _PAGE_RW;
+		pgprot_val(forbidden) |= _PAGE_NX & __supported_pte_mask;
+	}
+#endif
+
 	prot = __pgprot(pgprot_val(prot) & ~pgprot_val(forbidden));
 
 	return prot;
@@ -372,24 +379,34 @@ static void __set_pmd_pte(pte_t *kpte, unsigned long address, pte_t pte)
 	/* change init_mm */
 	pax_open_kernel();
 	set_pte_atomic(kpte, pte);
-	pax_close_kernel();
 
 #ifdef CONFIG_X86_32
 	if (!SHARED_KERNEL_PMD) {
+
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		unsigned long cpu;
+#else
 		struct page *page;
+#endif
 
+#ifdef CONFIG_PAX_PER_CPU_PGD
+		for (cpu = 0; cpu < NR_CPUS; ++cpu) {
+			pgd_t *pgd = get_cpu_pgd(cpu);
+#else
 		list_for_each_entry(page, &pgd_list, lru) {
-			pgd_t *pgd;
+			pgd_t *pgd = (pgd_t *)page_address(page);;
+#endif
 			pud_t *pud;
 			pmd_t *pmd;
 
-			pgd = (pgd_t *)page_address(page) + pgd_index(address);
+			pgd += pgd_index(address);
 			pud = pud_offset(pgd, address);
 			pmd = pmd_offset(pud, address);
 			set_pte_atomic((pte_t *)pmd, pte);
 		}
 	}
 #endif
+	pax_close_kernel();
 }
 
 static int
diff --git a/arch/x86/mm/pgtable.c b/arch/x86/mm/pgtable.c
index 6bf54f7..147966b 100644
--- a/arch/x86/mm/pgtable.c
+++ b/arch/x86/mm/pgtable.c
@@ -64,12 +64,8 @@ void ___pmd_free_tlb(struct mmu_gather *tlb, pmd_t *pmd)
 #if PAGETABLE_LEVELS > 3
 void ___pud_free_tlb(struct mmu_gather *tlb, pud_t *pud)
 {
-
-#ifndef CONFIG_PAX_PER_CPU_PGD
 	paravirt_release_pud(__pa(pud) >> PAGE_SHIFT);
 	tlb_remove_page(tlb, virt_to_page(pud));
-#endif
-
 }
 #endif	/* PAGETABLE_LEVELS > 3 */
 #endif	/* PAGETABLE_LEVELS > 2 */
@@ -89,7 +85,14 @@ static inline void pgd_list_del(pgd_t *pgd)
 }
 
 #if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
-pteval_t clone_pgd_mask __read_only = ~_PAGE_PRESENT;
+pgdval_t clone_pgd_mask __read_only = ~_PAGE_PRESENT;
+
+void __shadow_user_pgds(pgd_t *dst, const pgd_t *src, int count)
+{
+	while (count--)
+		*dst++ = __pgd((pgd_val(*src++) | _PAGE_NX) & ~_PAGE_USER);
+
+}
 #endif
 
 #ifdef CONFIG_PAX_PER_CPU_PGD
@@ -105,15 +108,6 @@ void __clone_user_pgds(pgd_t *dst, const pgd_t *src, int count)
 
 }
 
-void __shadow_user_pgds(pgd_t *dst, const pgd_t *src, int count)
-{
-
-#if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
-	while (count--)
-		*dst++ = __pgd((pgd_val(*src++) | _PAGE_NX) & ~_PAGE_USER);
-#endif
-
-}
 #endif
 
 #ifdef CONFIG_PAX_PER_CPU_PGD
diff --git a/arch/x86/mm/setup_nx.c b/arch/x86/mm/setup_nx.c
index a3250aa..acd64b3 100644
--- a/arch/x86/mm/setup_nx.c
+++ b/arch/x86/mm/setup_nx.c
@@ -7,6 +7,7 @@
 
 static int disable_nx __cpuinitdata;
 
+#if defined(CONFIG_X86_PAE) && !defined(CONFIG_PAX_PAGEEXEC)
 /*
  * noexec = on|off
  *
@@ -28,6 +29,7 @@ static int __init noexec_setup(char *str)
 	return 0;
 }
 early_param("noexec", noexec_setup);
+#endif
 
 void __cpuinit x86_configure_nx(void)
 {
diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c
index b28133a..65ced5a 100644
--- a/arch/x86/xen/enlighten.c
+++ b/arch/x86/xen/enlighten.c
@@ -1102,7 +1102,17 @@ asmlinkage void __init xen_start_kernel(void)
 	__userpte_alloc_gfp &= ~__GFP_HIGHMEM;
 
 	/* Work out if we support NX */
-	x86_configure_nx();
+#if defined (CONFIG_X86_64) || defined(CONFIG_X86_PAE)
+	if ((cpuid_eax(0x80000000) & 0xffff0000) == 0x80000000 &&
+	    (cpuid_edx(0x80000001) & (1U << (X86_FEATURE_NX & 31)))) {
+		unsigned l, h;
+
+		__supported_pte_mask |= _PAGE_NX;
+		rdmsr(MSR_EFER, l, h);
+		l |= EFER_NX;
+		wrmsr(MSR_EFER, l, h);
+	}
+#endif
 
 	xen_setup_features();
 
diff --git a/arch/x86/xen/xen-head.S b/arch/x86/xen/xen-head.S
index 1a5ff24..a187d40 100644
--- a/arch/x86/xen/xen-head.S
+++ b/arch/x86/xen/xen-head.S
@@ -19,6 +19,17 @@ ENTRY(startup_xen)
 #ifdef CONFIG_X86_32
 	mov %esi,xen_start_info
 	mov $init_thread_union+THREAD_SIZE,%esp
+#ifdef CONFIG_SMP
+	movl $cpu_gdt_table,%edi
+	movl $__per_cpu_load,%eax
+	movw %ax,__KERNEL_PERCPU + 2(%edi)
+	rorl $16,%eax
+	movb %al,__KERNEL_PERCPU + 4(%edi)
+	movb %ah,__KERNEL_PERCPU + 7(%edi)
+	movl $__per_cpu_end - 1,%eax
+	subl $__per_cpu_start,%eax
+	movw %ax,__KERNEL_PERCPU + 0(%edi)
+#endif
 #else
 	mov %rsi,xen_start_info
 	mov $init_thread_union+THREAD_SIZE,%rsp
diff --git a/drivers/acpi/power_meter.c b/drivers/acpi/power_meter.c
index 66f6729..2d6de0a 100644
--- a/drivers/acpi/power_meter.c
+++ b/drivers/acpi/power_meter.c
@@ -316,8 +316,6 @@ static ssize_t set_trip(struct device *dev, struct device_attribute *devattr,
 		return res;
 
 	temp /= 1000;
-	if (temp < 0)
-		return -EINVAL;
 
 	mutex_lock(&resource->lock);
 	resource->trip[attr->index - 7] = temp;
diff --git a/drivers/acpi/proc.c b/drivers/acpi/proc.c
index 1ac678d..ebee2d7 100644
--- a/drivers/acpi/proc.c
+++ b/drivers/acpi/proc.c
@@ -391,20 +391,15 @@ acpi_system_write_wakeup_device(struct file *file,
 				size_t count, loff_t * ppos)
 {
 	struct list_head *node, *next;
-	char strbuf[5];
-	char str[5] = "";
-	unsigned int len = count;
+	char strbuf[5] = {0};
 	struct acpi_device *found_dev = NULL;
 
-	if (len > 4)
-		len = 4;
-	if (len < 0)
-		return -EFAULT;
+	if (count > 4)
+		count = 4;
 
-	if (copy_from_user(strbuf, buffer, len))
+	if (copy_from_user(strbuf, buffer, count))
 		return -EFAULT;
-	strbuf[len] = '\0';
-	sscanf(strbuf, "%s", str);
+	strbuf[count] = '\0';
 
 	mutex_lock(&acpi_device_lock);
 	list_for_each_safe(node, next, &acpi_wakeup_device_list) {
@@ -413,7 +408,7 @@ acpi_system_write_wakeup_device(struct file *file,
 		if (!dev->wakeup.flags.valid)
 			continue;
 
-		if (!strncmp(dev->pnp.bus_id, str, 4)) {
+		if (!strncmp(dev->pnp.bus_id, strbuf, 4)) {
 			dev->wakeup.state.enabled =
 			    dev->wakeup.state.enabled ? 0 : 1;
 			found_dev = dev;
diff --git a/drivers/char/hpet.c b/drivers/char/hpet.c
index 4bebbb6..6412492 100644
--- a/drivers/char/hpet.c
+++ b/drivers/char/hpet.c
@@ -429,7 +429,8 @@ static int hpet_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static int hpet_ioctl_common(struct hpet_dev *, int, unsigned long, int);
+static int hpet_ioctl_common(struct hpet_dev *, unsigned int,
+				unsigned long, int);
 
 static int
 hpet_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
@@ -549,7 +550,8 @@ static inline unsigned long hpet_time_div(struct hpets *hpets,
 }
 
 static int
-hpet_ioctl_common(struct hpet_dev *devp, int cmd, unsigned long arg, int kernel)
+hpet_ioctl_common(struct hpet_dev *devp, unsigned int cmd,
+			unsigned long arg, int kernel)
 {
 	struct hpet_timer __iomem *timer;
 	struct hpet __iomem *hpet;
@@ -994,7 +996,8 @@ static struct acpi_driver hpet_acpi_driver = {
 		},
 };
 
-static struct miscdevice hpet_misc = { HPET_MINOR, "hpet", &hpet_fops, {NULL, NULL}, NULL, NULL };
+static struct miscdevice hpet_misc = { HPET_MINOR, "hpet", &hpet_fops,
+					{NULL, NULL}, NULL, NULL };
 
 static int __init hpet_init(void)
 {
diff --git a/drivers/firewire/core-cdev.c b/drivers/firewire/core-cdev.c
index 14a34d9..5fe9347 100644
--- a/drivers/firewire/core-cdev.c
+++ b/drivers/firewire/core-cdev.c
@@ -1195,8 +1195,7 @@ static int init_iso_resource(struct client *client,
 	int ret;
 
 	if ((request->channels == 0 && request->bandwidth == 0) ||
-	    request->bandwidth > BANDWIDTH_AVAILABLE_INITIAL ||
-	    request->bandwidth < 0)
+	    request->bandwidth > BANDWIDTH_AVAILABLE_INITIAL)
 		return -EINVAL;
 
 	r  = kmalloc(sizeof(*r), GFP_KERNEL);
diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
index c2848e0..dc08b00 100644
--- a/drivers/gpu/drm/radeon/radeon_display.c
+++ b/drivers/gpu/drm/radeon/radeon_display.c
@@ -560,7 +560,7 @@ static void radeon_compute_pll_legacy(struct radeon_pll *pll,
 
 					if (pll->flags & RADEON_PLL_PREFER_CLOSEST_LOWER) {
 						error = freq - current_freq;
-						error = error < 0 ? 0xffffffff : error;
+						error = (int32_t)error < 0 ? 0xffffffff : error;
 					} else
 						error = abs(current_freq - freq);
 					vco_diff = abs(vco - best_vco);
diff --git a/drivers/gpu/drm/ttm/ttm_bo.c b/drivers/gpu/drm/ttm/ttm_bo.c
index 0e3754a..071011b 100644
--- a/drivers/gpu/drm/ttm/ttm_bo.c
+++ b/drivers/gpu/drm/ttm/ttm_bo.c
@@ -47,7 +47,7 @@
 #include <linux/module.h>
 
 #define TTM_ASSERT_LOCKED(param)
-#define TTM_DEBUG(fmt, arg...)
+#define TTM_DEBUG(fmt, arg...) do {} while (0)
 #define TTM_BO_HASH_ORDER 13
 
 static int ttm_bo_setup_vm(struct ttm_buffer_object *bo);
diff --git a/drivers/hid/usbhid/hiddev.c b/drivers/hid/usbhid/hiddev.c
index 433602a..1aab6ea 100644
--- a/drivers/hid/usbhid/hiddev.c
+++ b/drivers/hid/usbhid/hiddev.c
@@ -615,7 +615,7 @@ static long hiddev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		return put_user(HID_VERSION, (int __user *)arg);
 
 	case HIDIOCAPPLICATION:
-		if (arg < 0 || arg >= hid->maxapplication)
+		if (arg >= hid->maxapplication)
 			return -EINVAL;
 
 		for (i = 0; i < hid->maxcollection; i++)
diff --git a/drivers/message/fusion/mptdebug.h b/drivers/message/fusion/mptdebug.h
index 28e4788..d701a42 100644
--- a/drivers/message/fusion/mptdebug.h
+++ b/drivers/message/fusion/mptdebug.h
@@ -71,7 +71,7 @@
 		CMD;						\
 }
 #else
-#define MPT_CHECK_LOGGING(IOC, CMD, BITS)
+#define MPT_CHECK_LOGGING(IOC, CMD, BITS) do {} while (0)
 #endif
 
 
diff --git a/drivers/net/wireless/iwlwifi/iwl-debug.h b/drivers/net/wireless/iwlwifi/iwl-debug.h
index 1c7b53d..04da79d 100644
--- a/drivers/net/wireless/iwlwifi/iwl-debug.h
+++ b/drivers/net/wireless/iwlwifi/iwl-debug.h
@@ -68,8 +68,8 @@ do {                                            			\
 } while (0)
 
 #else
-#define IWL_DEBUG(__priv, level, fmt, args...)
-#define IWL_DEBUG_LIMIT(__priv, level, fmt, args...)
+#define IWL_DEBUG(__priv, level, fmt, args...) do {} while (0)
+#define IWL_DEBUG_LIMIT(__priv, level, fmt, args...) do {} while (0)
 static inline void iwl_print_hex_dump(struct iwl_priv *priv, int level,
 				      void *p, u32 len)
 {}
diff --git a/drivers/net/wireless/rndis_wlan.c b/drivers/net/wireless/rndis_wlan.c
index 1de5b22..e1ae50a 100644
--- a/drivers/net/wireless/rndis_wlan.c
+++ b/drivers/net/wireless/rndis_wlan.c
@@ -1185,7 +1185,7 @@ static int set_rts_threshold(struct usbnet *usbdev, u32 rts_threshold)
 
 	netdev_dbg(usbdev->net, "%s(): %i\n", __func__, rts_threshold);
 
-	if (rts_threshold < 0 || rts_threshold > 2347)
+	if (rts_threshold > 2347)
 		rts_threshold = 2347;
 
 	tmp = cpu_to_le32(rts_threshold);
diff --git a/drivers/scsi/mpt2sas/mpt2sas_debug.h b/drivers/scsi/mpt2sas/mpt2sas_debug.h
index 5308a25..6422fef 100644
--- a/drivers/scsi/mpt2sas/mpt2sas_debug.h
+++ b/drivers/scsi/mpt2sas/mpt2sas_debug.h
@@ -79,7 +79,7 @@
 		CMD;						\
 }
 #else
-#define MPT_CHECK_LOGGING(IOC, CMD, BITS)
+#define MPT_CHECK_LOGGING(IOC, CMD, BITS) do {} while (0)
 #endif /* CONFIG_SCSI_MPT2SAS_LOGGING */
 
 
diff --git a/drivers/staging/hv/Hv.c b/drivers/staging/hv/Hv.c
index 3a1112d..f398c14 100644
--- a/drivers/staging/hv/Hv.c
+++ b/drivers/staging/hv/Hv.c
@@ -134,7 +134,7 @@ static u64 HvDoHypercall(u64 Control, void *Input, void *Output)
 	u64 hvStatus = 0;
 	u64 inputAddress = (Input) ? virt_to_phys(Input) : 0;
 	u64 outputAddress = (Output) ? virt_to_phys(Output) : 0;
-	volatile void *hypercallPage = gHvContext.HypercallPage;
+	volatile void *hypercallPage = ktva_ktla(gHvContext.HypercallPage);
 
 	DPRINT_DBG(VMBUS, "Hypercall <control %llx input phys %llx virt %p "
 		   "output phys %llx virt %p hypercall %p>",
diff --git a/drivers/video/fbcmap.c b/drivers/video/fbcmap.c
index f53b9f1..a26146d 100644
--- a/drivers/video/fbcmap.c
+++ b/drivers/video/fbcmap.c
@@ -266,8 +266,7 @@ int fb_set_user_cmap(struct fb_cmap_user *cmap, struct fb_info *info)
 		rc = -ENODEV;
 		goto out;
 	}
-	if (cmap->start < 0 || (!info->fbops->fb_setcolreg &&
-				!info->fbops->fb_setcmap)) {
+	if ((!info->fbops->fb_setcolreg && !info->fbops->fb_setcmap)) {
 		rc = -EINVAL;
 		goto out1;
 	}
diff --git a/fs/block_dev.c b/fs/block_dev.c
index 6dcee88..0bb4403 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -681,7 +681,7 @@ int bd_claim(struct block_device *bdev, void *holder)
 	else if (bdev->bd_contains == bdev)
 		res = 0;  	 /* is a whole device which isn't held */
 
-	else if (bdev->bd_contains->bd_holder == bd_claim)
+	else if (bdev->bd_contains->bd_holder == (void *)bd_claim)
 		res = 0; 	 /* is a partition of a device that is being partitioned */
 	else if (bdev->bd_contains->bd_holder != NULL)
 		res = -EBUSY;	 /* is a partition of a held device */
diff --git a/fs/cachefiles/bind.c b/fs/cachefiles/bind.c
index 2906077..4f99320 100644
--- a/fs/cachefiles/bind.c
+++ b/fs/cachefiles/bind.c
@@ -39,13 +39,11 @@ int cachefiles_daemon_bind(struct cachefiles_cache *cache, char *args)
 	       args);
 
 	/* start by checking things over */
-	ASSERT(cache->fstop_percent >= 0 &&
-	       cache->fstop_percent < cache->fcull_percent &&
+	ASSERT(cache->fstop_percent < cache->fcull_percent &&
 	       cache->fcull_percent < cache->frun_percent &&
 	       cache->frun_percent  < 100);
 
-	ASSERT(cache->bstop_percent >= 0 &&
-	       cache->bstop_percent < cache->bcull_percent &&
+	ASSERT(cache->bstop_percent < cache->bcull_percent &&
 	       cache->bcull_percent < cache->brun_percent &&
 	       cache->brun_percent  < 100);
 
diff --git a/fs/cachefiles/daemon.c b/fs/cachefiles/daemon.c
index c4fa241..ab93ae5 100644
--- a/fs/cachefiles/daemon.c
+++ b/fs/cachefiles/daemon.c
@@ -221,7 +221,7 @@ static ssize_t cachefiles_daemon_write(struct file *file,
 	if (test_bit(CACHEFILES_DEAD, &cache->flags))
 		return -EIO;
 
-	if (datalen < 0 || datalen > PAGE_SIZE - 1)
+	if (datalen > PAGE_SIZE - 1)
 		return -EOPNOTSUPP;
 
 	/* drag the command string into the kernel so we can parse it */
@@ -385,7 +385,7 @@ static int cachefiles_daemon_fstop(struct cachefiles_cache *cache, char *args)
 	if (args[0] != '%' || args[1] != '\0')
 		return -EINVAL;
 
-	if (fstop < 0 || fstop >= cache->fcull_percent)
+	if (fstop >= cache->fcull_percent)
 		return cachefiles_daemon_range_error(cache, args);
 
 	cache->fstop_percent = fstop;
@@ -457,7 +457,7 @@ static int cachefiles_daemon_bstop(struct cachefiles_cache *cache, char *args)
 	if (args[0] != '%' || args[1] != '\0')
 		return -EINVAL;
 
-	if (bstop < 0 || bstop >= cache->bcull_percent)
+	if (bstop >= cache->bcull_percent)
 		return cachefiles_daemon_range_error(cache, args);
 
 	cache->bstop_percent = bstop;
diff --git a/fs/ext2/xattr.c b/fs/ext2/xattr.c
index e44dc92..1ef2794 100644
--- a/fs/ext2/xattr.c
+++ b/fs/ext2/xattr.c
@@ -86,8 +86,8 @@
 		printk("\n"); \
 	} while (0)
 #else
-# define ea_idebug(f...)
-# define ea_bdebug(f...)
+# define ea_idebug(f...) do {} while (0)
+# define ea_bdebug(f...) do {} while (0)
 #endif
 
 static int ext2_xattr_set2(struct inode *, struct buffer_head *,
diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index b4c5aa8..0d83b81 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -82,8 +82,8 @@
 		printk("\n"); \
 	} while (0)
 #else
-# define ea_idebug(f...)
-# define ea_bdebug(f...)
+# define ea_idebug(f...) do {} while (0)
+# define ea_bdebug(f...) do {} while (0)
 #endif
 
 static void ext4_xattr_cache_insert(struct buffer_head *);
diff --git a/fs/udf/udfdecl.h b/fs/udf/udfdecl.h
index 702a114..530a35f 100644
--- a/fs/udf/udfdecl.h
+++ b/fs/udf/udfdecl.h
@@ -26,7 +26,7 @@ do { \
 	printk(f, ##a); \
 } while (0)
 #else
-#define udf_debug(f, a...) /**/
+#define udf_debug(f, a...) do {} while (0)
 #endif
 
 #define udf_info(f, a...) \
diff --git a/include/acpi/acoutput.h b/include/acpi/acoutput.h
index d772668..011271e 100644
--- a/include/acpi/acoutput.h
+++ b/include/acpi/acoutput.h
@@ -266,8 +266,8 @@
  * leaving no executable debug code!
  */
 #define ACPI_FUNCTION_NAME(a)
-#define ACPI_DEBUG_PRINT(pl)
-#define ACPI_DEBUG_PRINT_RAW(pl)
+#define ACPI_DEBUG_PRINT(pl) do {} while (0)
+#define ACPI_DEBUG_PRINT_RAW(pl) do {} while (0)
 
 #endif				/* ACPI_DEBUG_OUTPUT */
 
diff --git a/include/linux/mm.h b/include/linux/mm.h
index bf42eb9..f66dd67 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -101,7 +101,14 @@ extern unsigned int kobjsize(const void *objp);
 #define VM_NORESERVE	0x00200000	/* should the VM suppress accounting */
 #define VM_HUGETLB	0x00400000	/* Huge TLB Page VM */
 #define VM_NONLINEAR	0x00800000	/* Is non-linear (remap_file_pages) */
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_X86_32)
+#define VM_PAGEEXEC	0x01000000	/* vma->vm_page_prot needs special handling */
+#define VM_MAPPED_COPY	0x00000000	/* T if mapped copy of data (nommu mmap) */
+#else
 #define VM_MAPPED_COPY	0x01000000	/* T if mapped copy of data (nommu mmap) */
+#endif
+
 #define VM_INSERTPAGE	0x02000000	/* The vma has had "vm_insert_page()" done on it */
 #define VM_NODUMP	0x04000000	/* Do not include in the core dump */
 
@@ -107,10 +114,6 @@ extern unsigned int kobjsize(const void *objp);
 #define VM_PFN_AT_MMAP	0x40000000	/* PFNMAP vma that is fully mapped at mmap time */
 #define VM_MERGEABLE	0x80000000	/* KSM may merge identical pages */
 
-#ifdef CONFIG_PAX_PAGEEXEC
-#define VM_PAGEEXEC	0x80000000	/* vma->vm_page_prot needs special handling */
-#endif
-
 #ifndef VM_STACK_DEFAULT_FLAGS		/* arch can override this */
 #define VM_STACK_DEFAULT_FLAGS VM_DATA_DEFAULT_FLAGS
 #endif
diff --git a/include/linux/vmalloc.h b/include/linux/vmalloc.h
index 51ee862..3cb7d22 100644
--- a/include/linux/vmalloc.h
+++ b/include/linux/vmalloc.h
@@ -15,7 +15,7 @@ struct vm_area_struct;		/* vma defining user mapping in mm_types.h */
 #define VM_VPAGES	0x00000010	/* buffer for pages was vmalloc'ed */
 #define VM_UNLIST	0x00000020	/* vm_struct is not listed in vmlist */
 
-#if defined(CONFIG_MODULES) && defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86) && defined(CONFIG_PAX_KERNEXEC)
 #define VM_KERNEXEC	0x00000020	/* allocate from executable kernel memory range */
 #endif
 
diff --git a/init/main.c b/init/main.c
index d1d8fd0..606454c 100644
--- a/init/main.c
+++ b/init/main.c
@@ -207,7 +207,7 @@ __setup("reset_devices", set_reset_devices);
 #if defined(CONFIG_X86_64) && defined(CONFIG_PAX_MEMORY_UDEREF)
 extern void pax_enter_kernel_user(void);
 extern void pax_exit_kernel_user(void);
-extern pteval_t clone_pgd_mask;
+extern pgdval_t clone_pgd_mask;
 #endif
 
 #if defined(CONFIG_X86) && defined(CONFIG_PAX_MEMORY_UDEREF)
@@ -229,7 +229,7 @@ static int __init setup_pax_nouderef(char *str)
 	*p = 0xc3;
 	p = (char *)pax_exit_kernel_user;
 	*p = 0xc3;
-	clone_pgd_mask = ~(pteval_t)0UL;
+	clone_pgd_mask = ~(pgdval_t)0UL;
 #endif
 
 	return 0;
diff --git a/kernel/kprobes.c b/kernel/kprobes.c
index 58b1f51..8d113ab 100644
--- a/kernel/kprobes.c
+++ b/kernel/kprobes.c
@@ -1643,7 +1643,7 @@ static int __init init_kprobes(void)
 {
 	int i, err = 0;
 	unsigned long offset = 0, size = 0;
-	char *modname, namebuf[128];
+	char *modname, namebuf[KSYM_NAME_LEN];
 	const char *symbol_name;
 	void *addr;
 	struct kprobe_blackpoint *kb;
@@ -1769,7 +1769,7 @@ static int __kprobes show_kprobe_addr(struct seq_file *pi, void *v)
 	const char *sym = NULL;
 	unsigned int i = *(loff_t *) v;
 	unsigned long offset = 0;
-	char *modname, namebuf[128];
+	char *modname, namebuf[KSYM_NAME_LEN];
 
 	head = &kprobe_table[i];
 	preempt_disable();
diff --git a/kernel/lockdep_proc.c b/kernel/lockdep_proc.c
index d4aba4f..02a353f 100644
--- a/kernel/lockdep_proc.c
+++ b/kernel/lockdep_proc.c
@@ -39,7 +39,7 @@ static void l_stop(struct seq_file *m, void *v)
 
 static void print_name(struct seq_file *m, struct lock_class *class)
 {
-	char str[128];
+	char str[KSYM_NAME_LEN];
 	const char *name = class->name;
 
 	if (!name) {
diff --git a/kernel/signal.c b/kernel/signal.c
index 86dc315..0af6ebb 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -45,12 +45,12 @@ static struct kmem_cache *sigqueue_cachep;
 
 int print_fatal_signals __read_mostly;
 
-static void __user *sig_handler(struct task_struct *t, int sig)
+static __sighandler_t *sig_handler(struct task_struct *t, int sig)
 {
 	return t->sighand->action[sig - 1].sa.sa_handler;
 }
 
-static int sig_handler_ignored(void __user *handler, int sig)
+static int sig_handler_ignored(__sighandler_t handler, int sig)
 {
 	/* Is it explicitly or implicitly ignored? */
 	return handler == SIG_IGN ||
@@ -60,7 +60,7 @@ static int sig_handler_ignored(void __user *handler, int sig)
 static int sig_task_ignored(struct task_struct *t, int sig,
 		int from_ancestor_ns)
 {
-	void __user *handler;
+	__sighandler_t handler;
 
 	handler = sig_handler(t, sig);
 
@@ -370,7 +370,7 @@ flush_signal_handlers(struct task_struct *t, int force_default)
 
 int unhandled_signal(struct task_struct *tsk, int sig)
 {
-	void __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;
+	__sighandler_t handler = tsk->sighand->action[sig-1].sa.sa_handler;
 	if (is_global_init(tsk))
 		return 1;
 	if (handler != SIG_IGN && handler != SIG_DFL)
diff --git a/mm/memory.c b/mm/memory.c
index e43b5aa..bcdaf9a 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -268,8 +268,12 @@ static inline void free_pmd_range(struct mmu_gather *tlb, pud_t *pud,
 		return;
 
 	pmd = pmd_offset(pud, start);
+
+#if !defined(CONFIG_X86_32) || !defined(CONFIG_PAX_PER_CPU_PGD)
 	pud_clear(pud);
 	pmd_free_tlb(tlb, pmd, start);
+#endif
+
 }
 
 static inline void free_pud_range(struct mmu_gather *tlb, pgd_t *pgd,
@@ -301,8 +305,12 @@ static inline void free_pud_range(struct mmu_gather *tlb, pgd_t *pgd,
 		return;
 
 	pud = pud_offset(pgd, start);
+
+#if !defined(CONFIG_X86_64) || !defined(CONFIG_PAX_PER_CPU_PGD)
 	pgd_clear(pgd);
 	pud_free_tlb(tlb, pud, start);
+#endif
+
 }
 
 /*
diff --git a/mm/mprotect.c b/mm/mprotect.c
index e643807..30929fd 100644
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@ -282,6 +282,12 @@ success:
 	 * vm_flags and vm_page_prot are protected by the mmap_sem
 	 * held in write mode.
 	 */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (newflags & VM_EXEC) && ((vma->vm_flags ^ newflags) & VM_READ))
+		pax_find_mirror_vma(vma)->vm_flags ^= VM_READ;
+#endif
+
 	vma->vm_flags = newflags;
 
 #ifdef CONFIG_PAX_MPROTECT
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index 576be08..5fb1565 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -1259,12 +1259,12 @@ static struct vm_struct *__get_vm_area_node(unsigned long size,
 
 	BUG_ON(in_interrupt());
 
-#if defined(CONFIG_MODULES) && defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86) && defined(CONFIG_PAX_KERNEXEC)
 	if (flags & VM_KERNEXEC) {
 		if (start != VMALLOC_START || end != VMALLOC_END)
 			return NULL;
-		start = (unsigned long)&MODULES_EXEC_VADDR;
-		end = (unsigned long)&MODULES_EXEC_END;
+		start = (unsigned long)MODULES_EXEC_VADDR;
+		end = (unsigned long)MODULES_EXEC_END;
 	}
 #endif
 
@@ -1493,7 +1493,7 @@ void *vmap(struct page **pages, unsigned int count,
 	if (count > totalram_pages)
 		return NULL;
 
-#if defined(CONFIG_MODULES) && defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86) && defined(CONFIG_PAX_KERNEXEC)
 	if (!(pgprot_val(prot) & _PAGE_NX))
 		flags |= VM_KERNEXEC;
 #endif
@@ -1607,7 +1607,7 @@ static void *__vmalloc_node(unsigned long size, unsigned long align,
 	if (!size || (size >> PAGE_SHIFT) > totalram_pages)
 		return NULL;
 
-#if defined(CONFIG_MODULES) && defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+#if defined(CONFIG_MODULES) && defined(CONFIG_X86) && defined(CONFIG_PAX_KERNEXEC)
 	if (!(pgprot_val(prot) & _PAGE_NX))
 		area = __get_vm_area_node(size, align, VM_ALLOC | VM_KERNEXEC, VMALLOC_START, VMALLOC_END,
 						node, gfp_mask, caller);
diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c
index 97da977..3fe019d 100644
--- a/net/8021q/vlan.c
+++ b/net/8021q/vlan.c
@@ -614,8 +614,7 @@ static int vlan_ioctl_handler(struct net *net, void __user *arg)
 		err = -EPERM;
 		if (!capable(CAP_NET_ADMIN))
 			break;
-		if ((args.u.name_type >= 0) &&
-		    (args.u.name_type < VLAN_NAME_TYPE_HIGHEST)) {
+		if ((args.u.name_type < VLAN_NAME_TYPE_HIGHEST)) {
 			struct vlan_net *vn;
 
 			vn = net_generic(net, vlan_net_id);
diff --git a/net/wireless/wext-core.c b/net/wireless/wext-core.c
index 4f5a470..d4d37f6 100644
--- a/net/wireless/wext-core.c
+++ b/net/wireless/wext-core.c
@@ -744,8 +744,7 @@ static int ioctl_standard_iw_point(struct iw_point *iwp, unsigned int cmd,
 		 */
 
 		/* Support for very large requests */
-		if ((descr->flags & IW_DESCR_FLAG_NOMAX) &&
-		    (user_length > descr->max_tokens)) {
+		if ((user_length > descr->max_tokens)) {
 			/* Allow userspace to GET more than max so
 			 * we can support any size GET requests.
 			 * There is still a limit : -ENOMEM.
-- 
1.6.0.3

