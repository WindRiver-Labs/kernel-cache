From 154042e66f7d6bec7ed08d54ca2f4de3613aa68b Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 6 May 2010 22:01:33 -0400
Subject: [PATCH 12/12] grsec: allow to optionally work with alternate stacks

This allows gresecurity to work with alternate IP stacks.
In particular the optional ANT stack modifications are
provided.

Originally for 2.6.27, updated to apply to 2.6.34.

Signed-off-by: Jonas Rendel <Jonas.Rendel@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 grsecurity/gracl_ip.c   |   77 ++++++++++++++++++++++++++++++++++++++++++++++-
 grsecurity/grsec_sock.c |   25 +++++++++++++++
 2 files changed, 101 insertions(+), 1 deletions(-)

diff --git a/grsecurity/gracl_ip.c b/grsecurity/gracl_ip.c
index 98f91ce..3c183d5 100644
--- a/grsecurity/gracl_ip.c
+++ b/grsecurity/gracl_ip.c
@@ -162,7 +162,9 @@ gr_search_connectbind(const int full_mode, struct sock *sk,
 	struct acl_ip_label *ip;
 	struct inet_sock *isk;
 	struct net_device *dev;
+#ifndef CONFIG_INTERPEAK
 	struct in_device *idev;
+#endif
 	unsigned long i;
 	int ret;
 	int mode = full_mode & (GR_BIND | GR_CONNECT);
@@ -227,6 +229,41 @@ gr_search_connectbind(const int full_mode, struct sock *sk,
 			dev = dev_get_by_name(sock_net(sk), iface);
 			if (dev == NULL)
 				continue;
+#ifdef CONFIG_INTERPEAK
+			{
+				struct ifreq	   ifr;
+				struct sockaddr_in *sin;
+				struct socket	   *sock;
+
+				if (sock_create_kern(AF_INET, SOCK_DGRAM,
+					IPPROTO_UDP, &sock) < 0)
+					continue;
+
+				strcpy(ifr.ifr_name, dev->name);
+				sin = (struct sockaddr_in *)&ifr.ifr_addr;
+
+				if (kernel_sock_ioctl(sock, SIOCGIFADDR,
+						(unsigned long)&ifr) < 0) {
+					sock_release(sock);
+					continue;
+				}
+
+				sock_release(sock);
+
+				our_addr = sin->sin_addr.s_addr;
+				our_netmask = 0xffffffff;
+
+				ret = check_ip_policy(ip, ip_addr, ip_port,
+							sk->sk_protocol, mode,
+							type, our_addr,
+							our_netmask);
+
+				if (ret == 1)
+					return 1;
+				else if (ret == 2)
+					goto denied;
+			}
+#else
 			idev = in_dev_get(dev);
 			if (idev == NULL) {
 				dev_put(dev);
@@ -254,6 +291,7 @@ gr_search_connectbind(const int full_mode, struct sock *sk,
 			rcu_read_unlock();
 			in_dev_put(idev);
 			dev_put(dev);
+#endif
 		} else {
 			our_addr = ip->addr;
 			our_netmask = ip->netmask;
@@ -291,8 +329,21 @@ int gr_search_listen(struct socket *sock)
 	struct sock *sk = sock->sk;
 	struct sockaddr_in addr;
 
+#ifdef CONFIG_INTERPEAK
+	int addr_sz = sizeof(addr);
+
+	if (sk && sk->sk_family == AF_INET) {
+		if (kernel_getsockname((struct socket *)sock,
+					(struct sockaddr *)&addr,
+					&addr_sz) < 0)
+			return -1;
+	} else {
+		memset(&addr, 0, sizeof(addr));
+	}
+#else
 	addr.sin_addr.s_addr = inet_sk(sk)->inet_saddr;
 	addr.sin_port = inet_sk(sk)->inet_sport;
+#endif
 
 	return gr_search_connectbind(GR_BIND | GR_CONNECTOVERRIDE, sock->sk, &addr, sock->type);
 }
@@ -302,8 +353,21 @@ int gr_search_accept(struct socket *sock)
 	struct sock *sk = sock->sk;
 	struct sockaddr_in addr;
 
+#ifdef CONFIG_INTERPEAK
+	int addr_sz = sizeof(addr);
+
+	if (sk && sk->sk_family == AF_INET) {
+		if (kernel_getsockname((struct socket *)sock,
+					(struct sockaddr *)&addr,
+					&addr_sz) < 0)
+			return -1;
+	} else {
+		memset(&addr, 0, sizeof(addr));
+	}
+#else
 	addr.sin_addr.s_addr = inet_sk(sk)->inet_saddr;
 	addr.sin_port = inet_sk(sk)->inet_sport;
+#endif
 
 	return gr_search_connectbind(GR_BIND | GR_CONNECTOVERRIDE, sock->sk, &addr, sock->type);
 }
@@ -315,10 +379,21 @@ gr_search_udp_sendmsg(struct sock *sk, struct sockaddr_in *addr)
 		return gr_search_connectbind(GR_CONNECT, sk, addr, SOCK_DGRAM);
 	else {
 		struct sockaddr_in sin;
+#ifdef CONFIG_INTERPEAK
+	int sin_sz = sizeof(sin);
+	if (sk && sk->sk_family == AF_INET) {
+		if (kernel_getpeername(sk->sk_socket,
+					(struct sockaddr *)&sin,
+					&sin_sz) < 0)
+			return -1;
+	} else {
+		memset(&sin, 0, sizeof(sin));
+	}
+#else
 		const struct inet_sock *inet = inet_sk(sk);
-
 		sin.sin_addr.s_addr = inet->inet_daddr;
 		sin.sin_port = inet->inet_dport;
+#endif
 
 		return gr_search_connectbind(GR_CONNECT | GR_CONNECTOVERRIDE, sk, &sin, SOCK_DGRAM);
 	}
diff --git a/grsecurity/grsec_sock.c b/grsecurity/grsec_sock.c
index bfa940f..198f03f 100644
--- a/grsecurity/grsec_sock.c
+++ b/grsecurity/grsec_sock.c
@@ -160,16 +160,37 @@ gr_attach_curr_ip(const struct sock *sk)
 {
 #ifdef CONFIG_GRKERNSEC
 	struct signal_struct *p, *set;
+#ifdef CONFIG_INTERPEAK
+	struct sockaddr_in src;
+	struct sockaddr_in dst;
+	size_t len = sizeof(struct sockaddr_in);
+#else
 	const struct inet_sock *inet = inet_sk(sk);
+#endif
 
 	if (unlikely(sk->sk_protocol != IPPROTO_TCP))
 		return;
 
 	set = current->signal;
 
+
+#ifdef CONFIG_INTERPEAK
+	if (kernel_getsockname(sk->sk_socket, (struct sockaddr *)&src,
+				&len) < 0)
+		return;
+
+	if (kernel_getpeername(sk->sk_socket, (struct sockaddr *)&dst,
+				&len) < 0)
+		return;
+
+	spin_lock_bh(&gr_conn_table_lock);
+	p = gr_lookup_task_ip_table(dst.sin_addr.s_addr, src.sin_addr.s_addr,
+				    dst.sin_port, src.sin_port);
+#else
 	spin_lock_bh(&gr_conn_table_lock);
 	p = gr_lookup_task_ip_table(inet->inet_daddr, inet->inet_rcv_saddr,
 				    inet->inet_dport, inet->inet_sport);
+#endif
 	if (unlikely(p != NULL)) {
 		set->curr_ip = p->curr_ip;
 		set->used_accept = 1;
@@ -179,7 +200,11 @@ gr_attach_curr_ip(const struct sock *sk)
 	}
 	spin_unlock_bh(&gr_conn_table_lock);
 
+#ifdef CONFIG_INTERPEAK
+	set->curr_ip = dst.sin_addr.s_addr;
+#else
 	set->curr_ip = inet->inet_daddr;
+#endif
 	set->used_accept = 1;
 #endif
 	return;
-- 
1.6.5.2

